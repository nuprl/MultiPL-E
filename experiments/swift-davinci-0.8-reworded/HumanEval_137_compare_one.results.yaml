language: swift
name: HumanEval_137_compare_one
results:
- exit_code: 1
  program: "\nenum Value: Equatable, Hashable {\n    case intValue(Int)\n    case\
    \ doubleValue(Double)\n    case stringValue(String)\n}\n\n            \n/// Create\
    \ a function that takes integers, floats, or strings representing\n/// real numbers,\
    \ and returns the larger variable in its given variable type.\n/// Return nil\
    \ if the values are equal.\n/// Note: If a real number is represented as a string,\
    \ the floating point might be . or ,\n/// >>> compare_one(a: .intValue(1), b:\
    \ .doubleValue(2.5))\n/// .doubleValue(2.5)\n/// >>> compare_one(a: .intValue(1),\
    \ b: .stringValue(\"2,3\"))\n/// .stringValue(\"2,3\")\n/// >>> compare_one(a:\
    \ .stringValue(\"5,1\"), b: .stringValue(\"6\"))\n/// .stringValue(\"6\")\n///\
    \ >>> compare_one(a: .stringValue(\"1\"), b: .intValue(1))\n/// nil\nfunc compare_one(a:\
    \ Value, b: Value) -> Value? {\n    var firstVal = 0.0\n    var secondVal = 0.0\n\
    \    switch a {\n    case .intValue(let x):\n        firstVal = Double(x)\n  \
    \  case .doubleValue(let x):\n        firstVal = x\n    case .stringValue(let\
    \ x):\n        firstVal = Double(x.replacingOccurrences(of: \",\", with: \".\"\
    )) ?? 0.0\n    }\n    switch b {\n    case .intValue(let x):\n        secondVal\
    \ = Double(x)\n    case .doubleValue(let x):\n        secondVal = x\n    case\
    \ .stringValue(let x):\n        secondVal = Double(x.replacingOccurrences(of:\
    \ \",\", with: \".\")) ?? 0.0\n    }\n    if firstVal > secondVal {\n        return\
    \ a\n    } else if firstVal < secondVal {\n        return b\n    } else {\n  \
    \      return nil\n    }\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(compare_one(a:\
    \ .intValue(1), b: .intValue(2)) == .intValue(2))\nassert(compare_one(a: .intValue(1),\
    \ b: .doubleValue(2.5)) == .doubleValue(2.5))\nassert(compare_one(a: .intValue(2),\
    \ b: .intValue(3)) == .intValue(3))\nassert(compare_one(a: .intValue(5), b: .intValue(6))\
    \ == .intValue(6))\nassert(compare_one(a: .intValue(1), b: .stringValue(\"2,3\"\
    )) == .stringValue(\"2,3\"))\nassert(compare_one(a: .stringValue(\"5,1\"), b:\
    \ .stringValue(\"6\")) == .stringValue(\"6\"))\nassert(compare_one(a: .stringValue(\"\
    1\"), b: .stringValue(\"2\")) == .stringValue(\"2\"))\nassert(compare_one(a: .stringValue(\"\
    1\"), b: .intValue(1)) == nil)"
  status: SyntaxError
  stderr: "/tmp/tmpyi2vk3_y.swift:30:29: error: value of type 'String' has no member\
    \ 'replacingOccurrences'\n        firstVal = Double(x.replacingOccurrences(of:\
    \ \",\", with: \".\")) ?? 0.0\n                          ~ ^~~~~~~~~~~~~~~~~~~~\n\
    /tmp/tmpyi2vk3_y.swift:38:30: error: value of type 'String' has no member 'replacingOccurrences'\n\
    \        secondVal = Double(x.replacingOccurrences(of: \",\", with: \".\")) ??\
    \ 0.0\n                           ~ ^~~~~~~~~~~~~~~~~~~~\n"
  stdout: ''
  timestamp: 1660013179
- exit_code: 1
  program: "\nenum Value: Equatable, Hashable {\n    case intValue(Int)\n    case\
    \ doubleValue(Double)\n    case stringValue(String)\n}\n\n            \n/// Create\
    \ a function that takes integers, floats, or strings representing\n/// real numbers,\
    \ and returns the larger variable in its given variable type.\n/// Return nil\
    \ if the values are equal.\n/// Note: If a real number is represented as a string,\
    \ the floating point might be . or ,\n/// >>> compare_one(a: .intValue(1), b:\
    \ .doubleValue(2.5))\n/// .doubleValue(2.5)\n/// >>> compare_one(a: .intValue(1),\
    \ b: .stringValue(\"2,3\"))\n/// .stringValue(\"2,3\")\n/// >>> compare_one(a:\
    \ .stringValue(\"5,1\"), b: .stringValue(\"6\"))\n/// .stringValue(\"6\")\n///\
    \ >>> compare_one(a: .stringValue(\"1\"), b: .intValue(1))\n/// nil\nfunc compare_one(a:\
    \ Value, b: Value) -> Value? {\n    switch (a, b) {\n    case (.intValue(let x),\
    \ .intValue(let y)) where x == y:\n        return nil\n    case (.intValue(let\
    \ x), .intValue(let y)) where x > y:\n        return a\n    case (.intValue(let\
    \ x), .intValue(let y)) where x < y:\n        return b\n    case (.intValue(let\
    \ x), .doubleValue(let y)) where x == y:\n        return nil\n    case (.intValue(let\
    \ x), .doubleValue(let y)) where x > y:\n        return .intValue(x)\n    case\
    \ (.intValue(let x), .doubleValue(let y)) where x < y:\n        return .doubleValue(y)\n\
    \    case (.intValue(let x), .stringValue(let y)) where x == Double(y):\n    \
    \    return nil\n    case (.intValue(let x), .stringValue(let y)) where x > Double(y):\n\
    \        return .intValue(x)\n    case (.intValue(let x), .stringValue(let y))\
    \ where x < Double(y):\n        return .stringValue(y)\n    case (.doubleValue(let\
    \ x), .intValue(let y)) where x == y:\n        return nil\n    case (.doubleValue(let\
    \ x), .intValue(let y)) where x > y:\n        return .doubleValue(x)\n    case\
    \ (.doubleValue(let x), .intValue(let y)) where x < y:\n        return .intValue(y)\n\
    \    case (.doubleValue(let x), .doubleValue(let y)) where x == y:\n        return\
    \ nil\n    case (.doubleValue(let x), .doubleValue(let y)) where x > y:\n    \
    \    return .doubleValue(x)\n    case (.doubleValue(let x), .doubleValue(let y))\
    \ where x < y:\n        return .doubleValue(y)\n    case (.doubleValue(let x),\
    \ .stringValue(let y)) where x == Double(y):\n        return nil\n    case (.doubleValue(let\
    \ x), .stringValue(let y)) where x > Double(y):\n        return .doubleValue(x)\n\
    \    case (.doubleValue\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(compare_one(a:\
    \ .intValue(1), b: .intValue(2)) == .intValue(2))\nassert(compare_one(a: .intValue(1),\
    \ b: .doubleValue(2.5)) == .doubleValue(2.5))\nassert(compare_one(a: .intValue(2),\
    \ b: .intValue(3)) == .intValue(3))\nassert(compare_one(a: .intValue(5), b: .intValue(6))\
    \ == .intValue(6))\nassert(compare_one(a: .intValue(1), b: .stringValue(\"2,3\"\
    )) == .stringValue(\"2,3\"))\nassert(compare_one(a: .stringValue(\"5,1\"), b:\
    \ .stringValue(\"6\")) == .stringValue(\"6\"))\nassert(compare_one(a: .stringValue(\"\
    1\"), b: .stringValue(\"2\")) == .stringValue(\"2\"))\nassert(compare_one(a: .stringValue(\"\
    1\"), b: .intValue(1)) == nil)"
  status: SyntaxError
  stderr: "/tmp/tmp0dt9ee7g.swift:58:1: error: expected ')' in expression list\n}\n\
    ^\n/tmp/tmp0dt9ee7g.swift:57:10: note: to match this opening '('\n    case (.doubleValue\n\
    \         ^\n/tmp/tmp0dt9ee7g.swift:57:23: error: expected ':' after 'case'\n\
    \    case (.doubleValue\n                      ^\n/tmp/tmp0dt9ee7g.swift:80:66:\
    \ error: expected '}' at end of brace statement\nassert(compare_one(a: .stringValue(\"\
    1\"), b: .intValue(1)) == nil)\n                                             \
    \                    ^\n/tmp/tmp0dt9ee7g.swift:21:48: note: to match this opening\
    \ '{'\nfunc compare_one(a: Value, b: Value) -> Value? {\n                    \
    \                           ^\n/tmp/tmp0dt9ee7g.swift:29:58: error: binary operator\
    \ '==' cannot be applied to operands of type 'Int' and 'Double'\n    case (.intValue(let\
    \ x), .doubleValue(let y)) where x == y:\n                                   \
    \                    ~ ^  ~\n/tmp/tmp0dt9ee7g.swift:29:58: note: overloads for\
    \ '==' exist with these partially matching parameter lists: (Int, Int)\n    case\
    \ (.intValue(let x), .doubleValue(let y)) where x == y:\n                    \
    \                                     ^\n/tmp/tmp0dt9ee7g.swift:31:58: error:\
    \ binary operator '>' cannot be applied to operands of type 'Int' and 'Double'\n\
    \    case (.intValue(let x), .doubleValue(let y)) where x > y:\n             \
    \                                          ~ ^ ~\n/tmp/tmp0dt9ee7g.swift:31:58:\
    \ note: overloads for '>' exist with these partially matching parameter lists:\
    \ (Int, Int)\n    case (.intValue(let x), .doubleValue(let y)) where x > y:\n\
    \                                                         ^\n/tmp/tmp0dt9ee7g.swift:33:58:\
    \ error: binary operator '<' cannot be applied to operands of type 'Int' and 'Double'\n\
    \    case (.intValue(let x), .doubleValue(let y)) where x < y:\n             \
    \                                          ~ ^ ~\n/tmp/tmp0dt9ee7g.swift:33:58:\
    \ note: overloads for '<' exist with these partially matching parameter lists:\
    \ (Int, Int)\n    case (.intValue(let x), .doubleValue(let y)) where x < y:\n\
    \                           "
  stdout: ''
  timestamp: 1660013179
- exit_code: 1
  program: "\nenum Value: Equatable, Hashable {\n    case intValue(Int)\n    case\
    \ doubleValue(Double)\n    case stringValue(String)\n}\n\n            \n/// Create\
    \ a function that takes integers, floats, or strings representing\n/// real numbers,\
    \ and returns the larger variable in its given variable type.\n/// Return nil\
    \ if the values are equal.\n/// Note: If a real number is represented as a string,\
    \ the floating point might be . or ,\n/// >>> compare_one(a: .intValue(1), b:\
    \ .doubleValue(2.5))\n/// .doubleValue(2.5)\n/// >>> compare_one(a: .intValue(1),\
    \ b: .stringValue(\"2,3\"))\n/// .stringValue(\"2,3\")\n/// >>> compare_one(a:\
    \ .stringValue(\"5,1\"), b: .stringValue(\"6\"))\n/// .stringValue(\"6\")\n///\
    \ >>> compare_one(a: .stringValue(\"1\"), b: .intValue(1))\n/// nil\nfunc compare_one(a:\
    \ Value, b: Value) -> Value? {\n    switch (a, b) {\n    case (.intValue(let aInt),\
    \ .intValue(let bInt)):\n        if aInt > bInt {\n            return .intValue(aInt)\n\
    \        } else if aInt < bInt {\n            return .intValue(bInt)\n       \
    \ } else {\n            return nil\n        }\n    case (.intValue(let aInt),\
    \ .doubleValue(let bDouble)):\n        if Double(aInt) > bDouble {\n         \
    \   return .doubleValue(Double(aInt))\n        } else if Double(aInt) < bDouble\
    \ {\n            return .doubleValue(bDouble)\n        } else {\n            return\
    \ nil\n        }\n    case (.intValue(let aInt), .stringValue(let bString)):\n\
    \        if Int(bString) == nil {\n            return nil\n        } else if Double(bString)\
    \ == nil {\n            if aInt > Int(bString)! {\n                return .intValue(aInt)\n\
    \            } else if aInt < Int(bString)! {\n                return .stringValue(bString)\n\
    \            } else {\n                return nil\n            }\n        } else\
    \ {\n            if Double(aInt) > Double(bString)! {\n                return\
    \ .doubleValue(Double(aInt))\n            } else if Double(aInt) < Double(bString)!\
    \ {\n                return .doubleValue(Double(bString)!)\n            } else\
    \ {\n                return nil\n            }\n        }\n    case (.doubleValue(let\
    \ aDouble), .intValue(let bInt)):\n        if aDouble > Double(bInt) {\n     \
    \       return .doubleValue(aDouble)\n        } else if aDouble < Double(bInt)\
    \ {\n            return .doubleValue(Double(bInt))\n        } else {\n       \
    \     return nil\n        }\n    case (.doubleValue(let aDouble), .doubleValue(let\
    \ bDouble)):\n        if aDouble > bDouble {\n            return .doubleValue(aDouble)\n\
    \        } else if aDouble < bDouble {\n            return .doubleValue(bDouble)\n\
    \        } else {\n            return nil\n        }\n    case (.doubleValue(let\
    \ aDouble), .stringValue(let\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int,\
    \ Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n\
    \    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n          \
    \  return false\n        }\n    }\n    return true\n}\n            \nassert(compare_one(a:\
    \ .intValue(1), b: .intValue(2)) == .intValue(2))\nassert(compare_one(a: .intValue(1),\
    \ b: .doubleValue(2.5)) == .doubleValue(2.5))\nassert(compare_one(a: .intValue(2),\
    \ b: .intValue(3)) == .intValue(3))\nassert(compare_one(a: .intValue(5), b: .intValue(6))\
    \ == .intValue(6))\nassert(compare_one(a: .intValue(1), b: .stringValue(\"2,3\"\
    )) == .stringValue(\"2,3\"))\nassert(compare_one(a: .stringValue(\"5,1\"), b:\
    \ .stringValue(\"6\")) == .stringValue(\"6\"))\nassert(compare_one(a: .stringValue(\"\
    1\"), b: .stringValue(\"2\")) == .stringValue(\"2\"))\nassert(compare_one(a: .stringValue(\"\
    1\"), b: .intValue(1)) == nil)"
  status: SyntaxError
  stderr: "/tmp/tmpfm7ia07z.swift:75:54: error: expected pattern\n    case (.doubleValue(let\
    \ aDouble), .stringValue(let\n                                               \
    \      ^\n/tmp/tmpfm7ia07z.swift:75:54: error: expected ':' after 'case'\n   \
    \ case (.doubleValue(let aDouble), .stringValue(let\n                        \
    \                             ^\n/tmp/tmpfm7ia07z.swift:98:66: error: expected\
    \ '}' at end of brace statement\nassert(compare_one(a: .stringValue(\"1\"), b:\
    \ .intValue(1)) == nil)\n                                                    \
    \             ^\n/tmp/tmpfm7ia07z.swift:21:48: note: to match this opening '{'\n\
    func compare_one(a: Value, b: Value) -> Value? {\n                           \
    \                    ^\n/tmp/tmpfm7ia07z.swift:75:50: error: tuple pattern cannot\
    \ match values of the non-tuple type 'String'\n    case (.doubleValue(let aDouble),\
    \ .stringValue(let\n                                                 ^\n/tmp/tmpfm7ia07z.swift:79:6:\
    \ error: operator functions can only be declared at global or in type scope\n\
    func ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n     ^\n"
  stdout: ''
  timestamp: 1660013179
- exit_code: 1
  program: "\nenum Value: Equatable, Hashable {\n    case intValue(Int)\n    case\
    \ doubleValue(Double)\n    case stringValue(String)\n}\n\n            \n/// Create\
    \ a function that takes integers, floats, or strings representing\n/// real numbers,\
    \ and returns the larger variable in its given variable type.\n/// Return nil\
    \ if the values are equal.\n/// Note: If a real number is represented as a string,\
    \ the floating point might be . or ,\n/// >>> compare_one(a: .intValue(1), b:\
    \ .doubleValue(2.5))\n/// .doubleValue(2.5)\n/// >>> compare_one(a: .intValue(1),\
    \ b: .stringValue(\"2,3\"))\n/// .stringValue(\"2,3\")\n/// >>> compare_one(a:\
    \ .stringValue(\"5,1\"), b: .stringValue(\"6\"))\n/// .stringValue(\"6\")\n///\
    \ >>> compare_one(a: .stringValue(\"1\"), b: .intValue(1))\n/// nil\nfunc compare_one(a:\
    \ Value, b: Value) -> Value? {\n    if a == b {\n        return nil\n    }\n \
    \   if case let .intValue(int) = a {\n        if case let .intValue(otherInt)\
    \ = b {\n            return int > otherInt ? a : b\n        }\n        if case\
    \ let .doubleValue(double) = b {\n            return double > Double(int) ? b\
    \ : a\n        }\n        if case let .stringValue(string) = b {\n           \
    \ return Double(string) > Double(int) ? b : a\n        }\n    }\n    if case let\
    \ .doubleValue(double) = a {\n        if case let .intValue(int) = b {\n     \
    \       return double > Double(int) ? a : b\n        }\n        if case let .doubleValue(otherDouble)\
    \ = b {\n            return double > otherDouble ? a : b\n        }\n        if\
    \ case let .stringValue(string) = b {\n            return Double(string) > double\
    \ ? b : a\n        }\n    }\n    if case let .stringValue(string) = a {\n    \
    \    if case let .intValue(int) = b {\n            return Double(string) > Double(int)\
    \ ? a : b\n        }\n        if case let .doubleValue(double) = b {\n       \
    \     return Double(string) > double ? a : b\n        }\n        if case let .stringValue(otherString)\
    \ = b {\n            return Double(string) > Double(otherString) ? a : b\n   \
    \     }\n    }\n    return nil\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int,\
    \ Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n\
    \    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n          \
    \  return false\n        }\n    }\n    return true\n}\n            \nassert(compare_one(a:\
    \ .intValue(1), b: .intValue(2)) == .intValue(2))\nassert(compare_one(a: .intValue(1),\
    \ b: .doubleValue(2.5)) == .doubleValue(2.5))\nassert(compare_one(a: .intValue(2),\
    \ b: .intValue(3)) == .intValue(3))\nassert(compare_one(a: .intValue(5), b: .intValue(6))\
    \ == .intValue(6))\nassert(compare_one(a: .intValue(1), b: .stringValue(\"2,3\"\
    )) == .stringValue(\"2,3\"))\nassert(compare_one(a: .stringValue(\"5,1\"), b:\
    \ .stringValue(\"6\")) == .stringValue(\"6\"))\nassert(compare_one(a: .stringValue(\"\
    1\"), b: .stringValue(\"2\")) == .stringValue(\"2\"))\nassert(compare_one(a: .stringValue(\"\
    1\"), b: .intValue(1)) == nil)"
  status: SyntaxError
  stderr: "/tmp/tmp3_fjhkjx.swift:33:20: error: value of optional type 'Double?' must\
    \ be unwrapped to a value of type 'Double'\n            return Double(string)\
    \ > Double(int) ? b : a\n                   ^\n/tmp/tmp3_fjhkjx.swift:33:20: note:\
    \ coalesce using '??' to provide a default when the optional value contains 'nil'\n\
    \            return Double(string) > Double(int) ? b : a\n                   ^\n\
    \                                  ?? <#default value#>\n/tmp/tmp3_fjhkjx.swift:33:20:\
    \ note: force-unwrap using '!' to abort execution if the optional value contains\
    \ 'nil'\n            return Double(string) > Double(int) ? b : a\n           \
    \        ^\n                                 !\n/tmp/tmp3_fjhkjx.swift:44:20:\
    \ error: value of optional type 'Double?' must be unwrapped to a value of type\
    \ 'Double'\n            return Double(string) > double ? b : a\n             \
    \      ^\n/tmp/tmp3_fjhkjx.swift:44:20: note: coalesce using '??' to provide a\
    \ default when the optional value contains 'nil'\n            return Double(string)\
    \ > double ? b : a\n                   ^\n                                  ??\
    \ <#default value#>\n/tmp/tmp3_fjhkjx.swift:44:20: note: force-unwrap using '!'\
    \ to abort execution if the optional value contains 'nil'\n            return\
    \ Double(string) > double ? b : a\n                   ^\n                    \
    \             !\n/tmp/tmp3_fjhkjx.swift:49:20: error: value of optional type 'Double?'\
    \ must be unwrapped to a value of type 'Double'\n            return Double(string)\
    \ > Double(int) ? a : b\n                   ^\n/tmp/tmp3_fjhkjx.swift:49:20: note:\
    \ coalesce using '??' to provide a default when the optional value contains 'nil'\n\
    \            return Double(string) > Double(int) ? a : b\n                   ^\n\
    \                                  ?? <#default value#>\n/tmp/tmp3_fjhkjx.swift:49:20:\
    \ note: force-unwrap using '!' to abort execution if the optional value contains\
    \ 'nil'\n            return Double(string) > Double(int) ? a : b\n           \
    \        ^\n                                 !\n/tmp/tmp3_fjhkjx.swift:52:20:\
    \ error: value of optional type"
  stdout: ''
  timestamp: 1660013179
- exit_code: -4
  program: "\nenum Value: Equatable, Hashable {\n    case intValue(Int)\n    case\
    \ doubleValue(Double)\n    case stringValue(String)\n}\n\n            \n/// Create\
    \ a function that takes integers, floats, or strings representing\n/// real numbers,\
    \ and returns the larger variable in its given variable type.\n/// Return nil\
    \ if the values are equal.\n/// Note: If a real number is represented as a string,\
    \ the floating point might be . or ,\n/// >>> compare_one(a: .intValue(1), b:\
    \ .doubleValue(2.5))\n/// .doubleValue(2.5)\n/// >>> compare_one(a: .intValue(1),\
    \ b: .stringValue(\"2,3\"))\n/// .stringValue(\"2,3\")\n/// >>> compare_one(a:\
    \ .stringValue(\"5,1\"), b: .stringValue(\"6\"))\n/// .stringValue(\"6\")\n///\
    \ >>> compare_one(a: .stringValue(\"1\"), b: .intValue(1))\n/// nil\nfunc compare_one(a:\
    \ Value, b: Value) -> Value? {\n    return nil\n}\n\n\nfunc ==(left: [(Int, Int)],\
    \ right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n       \
    \ return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r\
    \ {\n            return false\n        }\n    }\n    return true\n}\n        \
    \    \nassert(compare_one(a: .intValue(1), b: .intValue(2)) == .intValue(2))\n\
    assert(compare_one(a: .intValue(1), b: .doubleValue(2.5)) == .doubleValue(2.5))\n\
    assert(compare_one(a: .intValue(2), b: .intValue(3)) == .intValue(3))\nassert(compare_one(a:\
    \ .intValue(5), b: .intValue(6)) == .intValue(6))\nassert(compare_one(a: .intValue(1),\
    \ b: .stringValue(\"2,3\")) == .stringValue(\"2,3\"))\nassert(compare_one(a: .stringValue(\"\
    5,1\"), b: .stringValue(\"6\")) == .stringValue(\"6\"))\nassert(compare_one(a:\
    \ .stringValue(\"1\"), b: .stringValue(\"2\")) == .stringValue(\"2\"))\nassert(compare_one(a:\
    \ .stringValue(\"1\"), b: .intValue(1)) == nil)"
  status: Exception
  stderr: 'tmpllswmh2d/tmpllswmh2d.swift:38: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b05c2ae8c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b05c27dfb6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b05c27df988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b05c27de7b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpllswmh2d                        0x000055f806e32a56 <unavailable> + 6742

    5    libc.so.6                          0x00002b05c2cd4460 __libc_start_main +
    245

    6    tmpllswmh2d                        0x000055f806e32499 <unavailable> + 5273

    '
  stdout: ''
  timestamp: 1660013179
- exit_code: 1
  program: "\nenum Value: Equatable, Hashable {\n    case intValue(Int)\n    case\
    \ doubleValue(Double)\n    case stringValue(String)\n}\n\n            \n/// Create\
    \ a function that takes integers, floats, or strings representing\n/// real numbers,\
    \ and returns the larger variable in its given variable type.\n/// Return nil\
    \ if the values are equal.\n/// Note: If a real number is represented as a string,\
    \ the floating point might be . or ,\n/// >>> compare_one(a: .intValue(1), b:\
    \ .doubleValue(2.5))\n/// .doubleValue(2.5)\n/// >>> compare_one(a: .intValue(1),\
    \ b: .stringValue(\"2,3\"))\n/// .stringValue(\"2,3\")\n/// >>> compare_one(a:\
    \ .stringValue(\"5,1\"), b: .stringValue(\"6\"))\n/// .stringValue(\"6\")\n///\
    \ >>> compare_one(a: .stringValue(\"1\"), b: .intValue(1))\n/// nil\nfunc compare_one(a:\
    \ Value, b: Value) -> Value? {\n    switch (a, b) {\n    case let (.intValue(a),\
    \ .intValue(b)) where a == b:\n        return nil\n    case let (.intValue(a),\
    \ .intValue(b)) where a > b:\n        return a\n    case let (.intValue(a), .intValue(b))\
    \ where a < b:\n        return b\n    case let (.intValue(a), .doubleValue(b))\
    \ where a == b:\n        return nil\n    case let (.intValue(a), .doubleValue(b))\
    \ where a > b:\n        return a\n    case let (.intValue(a), .doubleValue(b))\
    \ where a < b:\n        return b\n    case let (.intValue(a), .stringValue(b))\
    \ where a == Double(b):\n        return nil\n    case let (.intValue(a), .stringValue(b))\
    \ where a > Double(b):\n        return a\n    case let (.intValue(a), .stringValue(b))\
    \ where a < Double(b):\n        return b\n    case let (.doubleValue(a), .intValue(b))\
    \ where a == b:\n        return nil\n    case let (.doubleValue(a), .intValue(b))\
    \ where a > b:\n        return a\n    case let (.doubleValue(a), .intValue(b))\
    \ where a < b:\n        return b\n    case let (.doubleValue(a), .doubleValue(b))\
    \ where a == b:\n        return nil\n    case let (.doubleValue(a), .doubleValue(b))\
    \ where a > b:\n        return a\n    case let (.doubleValue(a), .doubleValue(b))\
    \ where a < b:\n        return b\n    case let (.doubleValue(a), .stringValue(b))\
    \ where a == Double(b):\n        return nil\n    case let (.doubleValue(a), .stringValue(b))\
    \ where a > Double(b):\n        return a\n    case let (.doubleValue(a), .stringValue(b))\
    \ where a < Double(b):\n        return b\n    case let (.stringValue(a), .intValue(b))\
    \ where Double(a) == b:\n        return nil\n    case let (.stringValue(a), .intValue\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(compare_one(a: .intValue(1), b: .intValue(2))\
    \ == .intValue(2))\nassert(compare_one(a: .intValue(1), b: .doubleValue(2.5))\
    \ == .doubleValue(2.5))\nassert(compare_one(a: .intValue(2), b: .intValue(3))\
    \ == .intValue(3))\nassert(compare_one(a: .intValue(5), b: .intValue(6)) == .intValue(6))\n\
    assert(compare_one(a: .intValue(1), b: .stringValue(\"2,3\")) == .stringValue(\"\
    2,3\"))\nassert(compare_one(a: .stringValue(\"5,1\"), b: .stringValue(\"6\"))\
    \ == .stringValue(\"6\"))\nassert(compare_one(a: .stringValue(\"1\"), b: .stringValue(\"\
    2\")) == .stringValue(\"2\"))\nassert(compare_one(a: .stringValue(\"1\"), b: .intValue(1))\
    \ == nil)"
  status: SyntaxError
  stderr: "/tmp/tmpkck_mg69.swift:62:1: error: expected ')' in expression list\n}\n\
    ^\n/tmp/tmpkck_mg69.swift:61:14: note: to match this opening '('\n    case let\
    \ (.stringValue(a), .intValue\n             ^\n/tmp/tmpkck_mg69.swift:61:41: error:\
    \ expected ':' after 'case'\n    case let (.stringValue(a), .intValue\n      \
    \                                  ^\n/tmp/tmpkck_mg69.swift:84:66: error: expected\
    \ '}' at end of brace statement\nassert(compare_one(a: .stringValue(\"1\"), b:\
    \ .intValue(1)) == nil)\n                                                    \
    \             ^\n/tmp/tmpkck_mg69.swift:21:48: note: to match this opening '{'\n\
    func compare_one(a: Value, b: Value) -> Value? {\n                           \
    \                    ^\n/tmp/tmpkck_mg69.swift:29:54: error: binary operator '=='\
    \ cannot be applied to operands of type 'Int' and 'Double'\n    case let (.intValue(a),\
    \ .doubleValue(b)) where a == b:\n                                           \
    \        ~ ^  ~\n/tmp/tmpkck_mg69.swift:29:54: note: overloads for '==' exist\
    \ with these partially matching parameter lists: (Int, Int)\n    case let (.intValue(a),\
    \ .doubleValue(b)) where a == b:\n                                           \
    \          ^\n/tmp/tmpkck_mg69.swift:31:54: error: binary operator '>' cannot\
    \ be applied to operands of type 'Int' and 'Double'\n    case let (.intValue(a),\
    \ .doubleValue(b)) where a > b:\n                                            \
    \       ~ ^ ~\n/tmp/tmpkck_mg69.swift:31:54: note: overloads for '>' exist with\
    \ these partially matching parameter lists: (Int, Int)\n    case let (.intValue(a),\
    \ .doubleValue(b)) where a > b:\n                                            \
    \         ^\n/tmp/tmpkck_mg69.swift:33:54: error: binary operator '<' cannot be\
    \ applied to operands of type 'Int' and 'Double'\n    case let (.intValue(a),\
    \ .doubleValue(b)) where a < b:\n                                            \
    \       ~ ^ ~\n/tmp/tmpkck_mg69.swift:33:54: note: overloads for '<' exist with\
    \ these partially matching parameter lists: (Int, Int)\n    case let (.intValue(a),\
    \ .doubleValue(b)) where a < b:\n             "
  stdout: ''
  timestamp: 1660013179
- exit_code: 1
  program: "\nenum Value: Equatable, Hashable {\n    case intValue(Int)\n    case\
    \ doubleValue(Double)\n    case stringValue(String)\n}\n\n            \n/// Create\
    \ a function that takes integers, floats, or strings representing\n/// real numbers,\
    \ and returns the larger variable in its given variable type.\n/// Return nil\
    \ if the values are equal.\n/// Note: If a real number is represented as a string,\
    \ the floating point might be . or ,\n/// >>> compare_one(a: .intValue(1), b:\
    \ .doubleValue(2.5))\n/// .doubleValue(2.5)\n/// >>> compare_one(a: .intValue(1),\
    \ b: .stringValue(\"2,3\"))\n/// .stringValue(\"2,3\")\n/// >>> compare_one(a:\
    \ .stringValue(\"5,1\"), b: .stringValue(\"6\"))\n/// .stringValue(\"6\")\n///\
    \ >>> compare_one(a: .stringValue(\"1\"), b: .intValue(1))\n/// nil\nfunc compare_one(a:\
    \ Value, b: Value) -> Value? {\n    switch (a, b) {\n    case (.intValue(let aInt),\
    \ .intValue(let bInt)):\n        return aInt > bInt ? a : bInt > aInt ? b : nil\n\
    \    case (.intValue(let aInt), .doubleValue(let bDouble)):\n        return aInt\
    \ > bDouble ? a : bDouble > aInt ? b : nil\n    case (.intValue(let aInt), .stringValue(let\
    \ bString)):\n        let bDouble = Double(bString.components(separatedBy: \"\
    ,\").joined()) ?? Double(bString)\n        return aInt > bDouble ? a : bDouble\
    \ > aInt ? b : nil\n    case (.doubleValue(let aDouble), .intValue(let bInt)):\n\
    \        return aDouble > bInt ? a : bInt > aDouble ? b : nil\n    case (.doubleValue(let\
    \ aDouble), .doubleValue(let bDouble)):\n        return aDouble > bDouble ? a\
    \ : bDouble > aDouble ? b : nil\n    case (.doubleValue(let aDouble), .stringValue(let\
    \ bString)):\n        let bDouble = Double(bString.components(separatedBy: \"\
    ,\").joined()) ?? Double(bString)\n        return aDouble > bDouble ? a : bDouble\
    \ > aDouble ? b : nil\n    case (.stringValue(let aString), .intValue(let bInt)):\n\
    \        let aDouble = Double(aString.components(separatedBy: \",\").joined())\
    \ ?? Double(aString)\n        return aDouble > bInt ? a : bInt > aDouble ? b :\
    \ nil\n    case (.stringValue(let aString), .doubleValue(let bDouble)):\n    \
    \    let aDouble = Double(aString.components(separatedBy: \",\").joined()) ??\
    \ Double(aString)\n        return aDouble > bDouble ? a : bDouble > aDouble ?\
    \ b : nil\n    case (.stringValue(let aString), .stringValue(let bString)):\n\
    \        let aDouble = Double(aString.components(separatedBy: \",\").joined())\
    \ ?? Double(aString)\n        let bDouble = Double(bString.components(separatedBy:\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(compare_one(a: .intValue(1), b: .intValue(2))\
    \ == .intValue(2))\nassert(compare_one(a: .intValue(1), b: .doubleValue(2.5))\
    \ == .doubleValue(2.5))\nassert(compare_one(a: .intValue(2), b: .intValue(3))\
    \ == .intValue(3))\nassert(compare_one(a: .intValue(5), b: .intValue(6)) == .intValue(6))\n\
    assert(compare_one(a: .intValue(1), b: .stringValue(\"2,3\")) == .stringValue(\"\
    2,3\"))\nassert(compare_one(a: .stringValue(\"5,1\"), b: .stringValue(\"6\"))\
    \ == .stringValue(\"6\"))\nassert(compare_one(a: .stringValue(\"1\"), b: .stringValue(\"\
    2\")) == .stringValue(\"2\"))\nassert(compare_one(a: .stringValue(\"1\"), b: .intValue(1))\
    \ == nil)"
  status: SyntaxError
  stderr: "/tmp/tmpewzlgzip.swift:46:1: error: expected expression in list of expressions\n\
    }\n^\n/tmp/tmpewzlgzip.swift:68:66: error: expected '}' at end of brace statement\n\
    assert(compare_one(a: .stringValue(\"1\"), b: .intValue(1)) == nil)\n        \
    \                                                         ^\n/tmp/tmpewzlgzip.swift:21:48:\
    \ note: to match this opening '{'\nfunc compare_one(a: Value, b: Value) -> Value?\
    \ {\n                                               ^\n/tmp/tmpewzlgzip.swift:26:23:\
    \ error: cannot convert value of type 'Double' to expected argument type 'Int'\n\
    \        return aInt > bDouble ? a : bDouble > aInt ? b : nil\n              \
    \        ^\n                      Int(   )\n/tmp/tmpewzlgzip.swift:26:37: error:\
    \ cannot convert value of type 'Double' to expected argument type 'Int'\n    \
    \    return aInt > bDouble ? a : bDouble > aInt ? b : nil\n                  \
    \                  ^\n                                    Int(   )\n/tmp/tmpewzlgzip.swift:28:38:\
    \ error: value of type 'String' has no member 'components'\n        let bDouble\
    \ = Double(bString.components(separatedBy: \",\").joined()) ?? Double(bString)\n\
    \                             ~~~~~~~ ^~~~~~~~~~\n/tmp/tmpewzlgzip.swift:31:16:\
    \ error: cannot convert value of type 'Double' to expected argument type 'Int'\n\
    \        return aDouble > bInt ? a : bInt > aDouble ? b : nil\n              \
    \ ^\n               Int(   )\n/tmp/tmpewzlgzip.swift:31:44: error: cannot convert\
    \ value of type 'Double' to expected argument type 'Int'\n        return aDouble\
    \ > bInt ? a : bInt > aDouble ? b : nil\n                                    \
    \       ^\n                                           Int(   )\n/tmp/tmpewzlgzip.swift:35:38:\
    \ error: value of type 'String' has no member 'components'\n        let bDouble\
    \ = Double(bString.components(separatedBy: \",\").joined()) ?? Double(bString)\n\
    \                             ~~~~~~~ ^~~~~~~~~~\n/tmp/tmpewzlgzip.swift:38:38:\
    \ error: value of type 'String' has no member 'components'\n        let aDouble\
    \ = Double(aString.components(separatedBy: \",\").joined()) ?? Double(aString)\n\
    \      "
  stdout: ''
  timestamp: 1660013179
- exit_code: -4
  program: "\nenum Value: Equatable, Hashable {\n    case intValue(Int)\n    case\
    \ doubleValue(Double)\n    case stringValue(String)\n}\n\n            \n/// Create\
    \ a function that takes integers, floats, or strings representing\n/// real numbers,\
    \ and returns the larger variable in its given variable type.\n/// Return nil\
    \ if the values are equal.\n/// Note: If a real number is represented as a string,\
    \ the floating point might be . or ,\n/// >>> compare_one(a: .intValue(1), b:\
    \ .doubleValue(2.5))\n/// .doubleValue(2.5)\n/// >>> compare_one(a: .intValue(1),\
    \ b: .stringValue(\"2,3\"))\n/// .stringValue(\"2,3\")\n/// >>> compare_one(a:\
    \ .stringValue(\"5,1\"), b: .stringValue(\"6\"))\n/// .stringValue(\"6\")\n///\
    \ >>> compare_one(a: .stringValue(\"1\"), b: .intValue(1))\n/// nil\nfunc compare_one(a:\
    \ Value, b: Value) -> Value? {\n    var aVal: Double?\n    var bVal: Double?\n\
    \    switch a {\n    case .intValue(let val):\n        aVal = Double(val)\n  \
    \  case .doubleValue(let val):\n        aVal = val\n    case .stringValue(let\
    \ val):\n        aVal = Double(val)\n    }\n    switch b {\n    case .intValue(let\
    \ val):\n        bVal = Double(val)\n    case .doubleValue(let val):\n       \
    \ bVal = val\n    case .stringValue(let val):\n        bVal = Double(val)\n  \
    \  }\n    guard let aValReal = aVal, let bValReal = bVal else {\n        return\
    \ nil\n    }\n    if aValReal == bValReal {\n        return nil\n    }\n    if\
    \ aValReal > bValReal {\n        return a\n    }\n    return b\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(compare_one(a: .intValue(1), b: .intValue(2)) == .intValue(2))\n\
    assert(compare_one(a: .intValue(1), b: .doubleValue(2.5)) == .doubleValue(2.5))\n\
    assert(compare_one(a: .intValue(2), b: .intValue(3)) == .intValue(3))\nassert(compare_one(a:\
    \ .intValue(5), b: .intValue(6)) == .intValue(6))\nassert(compare_one(a: .intValue(1),\
    \ b: .stringValue(\"2,3\")) == .stringValue(\"2,3\"))\nassert(compare_one(a: .stringValue(\"\
    5,1\"), b: .stringValue(\"6\")) == .stringValue(\"6\"))\nassert(compare_one(a:\
    \ .stringValue(\"1\"), b: .stringValue(\"2\")) == .stringValue(\"2\"))\nassert(compare_one(a:\
    \ .stringValue(\"1\"), b: .intValue(1)) == nil)"
  status: Exception
  stderr: 'tmph351nnep/tmph351nnep.swift:69: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b1bde811c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b1bde508b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b1bde508988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b1bde5077b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmph351nnep                        0x00005637347fb78b <unavailable> + 10123

    5    libc.so.6                          0x00002b1bde9fd460 __libc_start_main +
    245

    6    tmph351nnep                        0x00005637347fa539 <unavailable> + 5433

    '
  stdout: ''
  timestamp: 1660013180
- exit_code: 1
  program: "\nenum Value: Equatable, Hashable {\n    case intValue(Int)\n    case\
    \ doubleValue(Double)\n    case stringValue(String)\n}\n\n            \n/// Create\
    \ a function that takes integers, floats, or strings representing\n/// real numbers,\
    \ and returns the larger variable in its given variable type.\n/// Return nil\
    \ if the values are equal.\n/// Note: If a real number is represented as a string,\
    \ the floating point might be . or ,\n/// >>> compare_one(a: .intValue(1), b:\
    \ .doubleValue(2.5))\n/// .doubleValue(2.5)\n/// >>> compare_one(a: .intValue(1),\
    \ b: .stringValue(\"2,3\"))\n/// .stringValue(\"2,3\")\n/// >>> compare_one(a:\
    \ .stringValue(\"5,1\"), b: .stringValue(\"6\"))\n/// .stringValue(\"6\")\n///\
    \ >>> compare_one(a: .stringValue(\"1\"), b: .intValue(1))\n/// nil\nfunc compare_one(a:\
    \ Value, b: Value) -> Value? {\n    // YOUR CODE HERE\n    switch a {\n    case\
    \ .intValue(let value):\n        switch b {\n        case .intValue(let value2):\n\
    \            if value == value2 {\n                return nil\n            } else\
    \ if value < value2 {\n                return b\n            } else {\n      \
    \          return a\n            }\n        case .doubleValue(let value2):\n \
    \           if Double(value) == value2 {\n                return nil\n       \
    \     } else if Double(value) < value2 {\n                return b\n         \
    \   } else {\n                return a\n            }\n        case .stringValue(let\
    \ value2):\n            if String(value) == value2 {\n                return nil\n\
    \            } else if String(value) < value2 {\n                return b\n  \
    \          } else {\n                return a\n            }\n        }\n    case\
    \ .doubleValue(let value):\n        switch b {\n        case .intValue(let value2):\n\
    \            if value == Double(value2) {\n                return nil\n      \
    \      } else if value < Double(value2) {\n                return b\n        \
    \    } else {\n                return a\n            }\n        case .doubleValue(let\
    \ value2):\n            if value == value2 {\n                return nil\n   \
    \         } else if value < value2 {\n                return b\n            }\
    \ else {\n                return a\n            }\n        case .stringValue(let\
    \ value2):\n            if String(value) == value2 {\n                return nil\n\
    \            } else if String(value) < value2 {\n                return b\n  \
    \          } else {\n                return a\n            }\n        }\n    case\
    \ .stringValue(let value):\n        switch b {\n        case .intValue(let value2):\n\
    \            if value == String(value2) {\n                return nil\n      \
    \      } else if value < String(value2) {\n                return b\n        \
    \    } else {\n                return a\n            }\n        case .doubleValue(let\
    \ value2):\n            if value == String(value2) {\n                return nil\n\
    \            } else if value < String(value2) {\n                return b\n  \
    \          } else {\n                return a\n            }\n        case .stringValue(let\
    \ value2):\n            if value == value2 {\n                return\n}\n\n\n\
    func ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(compare_one(a: .intValue(1), b: .intValue(2))\
    \ == .intValue(2))\nassert(compare_one(a: .intValue(1), b: .doubleValue(2.5))\
    \ == .doubleValue(2.5))\nassert(compare_one(a: .intValue(2), b: .intValue(3))\
    \ == .intValue(3))\nassert(compare_one(a: .intValue(5), b: .intValue(6)) == .intValue(6))\n\
    assert(compare_one(a: .intValue(1), b: .stringValue(\"2,3\")) == .stringValue(\"\
    2,3\"))\nassert(compare_one(a: .stringValue(\"5,1\"), b: .stringValue(\"6\"))\
    \ == .stringValue(\"6\"))\nassert(compare_one(a: .stringValue(\"1\"), b: .stringValue(\"\
    2\")) == .stringValue(\"2\"))\nassert(compare_one(a: .stringValue(\"1\"), b: .intValue(1))\
    \ == nil)"
  status: SyntaxError
  stderr: "/tmp/tmpjn96vjzs.swift:121:66: error: expected '}' at end of 'switch' statement\n\
    assert(compare_one(a: .stringValue(\"1\"), b: .intValue(1)) == nil)\n        \
    \                                                         ^\n/tmp/tmpjn96vjzs.swift:79:18:\
    \ note: to match this opening '{'\n        switch b {\n                 ^\n/tmp/tmpjn96vjzs.swift:121:66:\
    \ error: expected '}' at end of 'switch' statement\nassert(compare_one(a: .stringValue(\"\
    1\"), b: .intValue(1)) == nil)\n                                             \
    \                    ^\n/tmp/tmpjn96vjzs.swift:23:14: note: to match this opening\
    \ '{'\n    switch a {\n             ^\n/tmp/tmpjn96vjzs.swift:121:66: error: expected\
    \ '}' at end of brace statement\nassert(compare_one(a: .stringValue(\"1\"), b:\
    \ .intValue(1)) == nil)\n                                                    \
    \             ^\n/tmp/tmpjn96vjzs.swift:21:48: note: to match this opening '{'\n\
    func compare_one(a: Value, b: Value) -> Value? {\n                           \
    \                    ^\n/tmp/tmpjn96vjzs.swift:98:17: error: non-void function\
    \ should return a value\n                return\n                ^\n/tmp/tmpjn96vjzs.swift:102:6:\
    \ error: operator functions can only be declared at global or in type scope\n\
    func ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n     ^\n"
  stdout: ''
  timestamp: 1660013179
- exit_code: 1
  program: "\nenum Value: Equatable, Hashable {\n    case intValue(Int)\n    case\
    \ doubleValue(Double)\n    case stringValue(String)\n}\n\n            \n/// Create\
    \ a function that takes integers, floats, or strings representing\n/// real numbers,\
    \ and returns the larger variable in its given variable type.\n/// Return nil\
    \ if the values are equal.\n/// Note: If a real number is represented as a string,\
    \ the floating point might be . or ,\n/// >>> compare_one(a: .intValue(1), b:\
    \ .doubleValue(2.5))\n/// .doubleValue(2.5)\n/// >>> compare_one(a: .intValue(1),\
    \ b: .stringValue(\"2,3\"))\n/// .stringValue(\"2,3\")\n/// >>> compare_one(a:\
    \ .stringValue(\"5,1\"), b: .stringValue(\"6\"))\n/// .stringValue(\"6\")\n///\
    \ >>> compare_one(a: .stringValue(\"1\"), b: .intValue(1))\n/// nil\nfunc compare_one(a:\
    \ Value, b: Value) -> Value? {\n    switch (a, b) {\n    case (.intValue(let a1),\
    \ .intValue(let b1)) where a1 == b1:\n        return nil\n    case (.intValue(let\
    \ a1), .intValue(let b1)) where a1 > b1:\n        return a\n    case (.intValue(let\
    \ a1), .intValue(let b1)) where a1 < b1:\n        return b\n    case (.intValue(let\
    \ a1), .doubleValue(let b1)) where a1 == b1:\n        return nil\n    case (.intValue(let\
    \ a1), .doubleValue(let b1)) where a1 > b1:\n        return .doubleValue(Double(a1))\n\
    \    case (.intValue(let a1), .doubleValue(let b1)) where a1 < b1:\n        return\
    \ b\n    case (.intValue(let a1), .stringValue(let b1)) where a1 == Double(b1.replacingOccurrences(of:\
    \ \",\", with: \".\"))!:\n        return nil\n    case (.intValue(let a1), .stringValue(let\
    \ b1)) where a1 > Double(b1.replacingOccurrences(of: \",\", with: \".\"))!:\n\
    \        return .stringValue(String(a1))\n    case (.intValue(let a1), .stringValue(let\
    \ b1)) where a1 < Double(b1.replacingOccurrences(of: \",\", with: \".\"))!:\n\
    \        return b\n    case (.doubleValue(let a1), .intValue(let b1)) where a1\
    \ == b1:\n        return nil\n    case (.doubleValue(let a1), .intValue(let b1))\
    \ where a1 > b1:\n        return a\n    case (.doubleValue(let a1), .intValue(let\
    \ b1)) where a1 < b1:\n        return .intValue(Int(b1))\n    case (.doubleValue(let\
    \ a1), .doubleValue(let b1)) where a1 == b1:\n        return nil\n    case (.doubleValue(let\
    \ a1), .doubleValue(let b1)) where a1 > b1:\n        return a\n   \n}\n\n\nfunc\
    \ ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count !=\
    \ right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(compare_one(a: .intValue(1), b: .intValue(2))\
    \ == .intValue(2))\nassert(compare_one(a: .intValue(1), b: .doubleValue(2.5))\
    \ == .doubleValue(2.5))\nassert(compare_one(a: .intValue(2), b: .intValue(3))\
    \ == .intValue(3))\nassert(compare_one(a: .intValue(5), b: .intValue(6)) == .intValue(6))\n\
    assert(compare_one(a: .intValue(1), b: .stringValue(\"2,3\")) == .stringValue(\"\
    2,3\"))\nassert(compare_one(a: .stringValue(\"5,1\"), b: .stringValue(\"6\"))\
    \ == .stringValue(\"6\"))\nassert(compare_one(a: .stringValue(\"1\"), b: .stringValue(\"\
    2\")) == .stringValue(\"2\"))\nassert(compare_one(a: .stringValue(\"1\"), b: .intValue(1))\
    \ == nil)"
  status: SyntaxError
  stderr: "/tmp/tmp1v6a5y_5.swift:74:66: error: expected '}' at end of brace statement\n\
    assert(compare_one(a: .stringValue(\"1\"), b: .intValue(1)) == nil)\n        \
    \                                                         ^\n/tmp/tmp1v6a5y_5.swift:21:48:\
    \ note: to match this opening '{'\nfunc compare_one(a: Value, b: Value) -> Value?\
    \ {\n                                               ^\n/tmp/tmp1v6a5y_5.swift:29:61:\
    \ error: binary operator '==' cannot be applied to operands of type 'Int' and\
    \ 'Double'\n    case (.intValue(let a1), .doubleValue(let b1)) where a1 == b1:\n\
    \                                                         ~~ ^  ~~\n/tmp/tmp1v6a5y_5.swift:29:61:\
    \ note: overloads for '==' exist with these partially matching parameter lists:\
    \ (Int, Int)\n    case (.intValue(let a1), .doubleValue(let b1)) where a1 == b1:\n\
    \                                                            ^\n/tmp/tmp1v6a5y_5.swift:31:61:\
    \ error: binary operator '>' cannot be applied to operands of type 'Int' and 'Double'\n\
    \    case (.intValue(let a1), .doubleValue(let b1)) where a1 > b1:\n         \
    \                                                ~~ ^ ~~\n/tmp/tmp1v6a5y_5.swift:31:61:\
    \ note: overloads for '>' exist with these partially matching parameter lists:\
    \ (Int, Int)\n    case (.intValue(let a1), .doubleValue(let b1)) where a1 > b1:\n\
    \                                                            ^\n/tmp/tmp1v6a5y_5.swift:33:61:\
    \ error: binary operator '<' cannot be applied to operands of type 'Int' and 'Double'\n\
    \    case (.intValue(let a1), .doubleValue(let b1)) where a1 < b1:\n         \
    \                                                ~~ ^ ~~\n/tmp/tmp1v6a5y_5.swift:33:61:\
    \ note: overloads for '<' exist with these partially matching parameter lists:\
    \ (Int, Int)\n    case (.intValue(let a1), .doubleValue(let b1)) where a1 < b1:\n\
    \                                                            ^\n/tmp/tmp1v6a5y_5.swift:35:115:\
    \ error: cannot convert value of type 'Double' to expected argument type 'Int'\n\
    \    case (.intValue(let a1), .stringValue(let b1)) where a1 == Double(b1.replacingOccurrences"
  stdout: ''
  timestamp: 1660013179
- exit_code: 1
  program: "\nenum Value: Equatable, Hashable {\n    case intValue(Int)\n    case\
    \ doubleValue(Double)\n    case stringValue(String)\n}\n\n            \n/// Create\
    \ a function that takes integers, floats, or strings representing\n/// real numbers,\
    \ and returns the larger variable in its given variable type.\n/// Return nil\
    \ if the values are equal.\n/// Note: If a real number is represented as a string,\
    \ the floating point might be . or ,\n/// >>> compare_one(a: .intValue(1), b:\
    \ .doubleValue(2.5))\n/// .doubleValue(2.5)\n/// >>> compare_one(a: .intValue(1),\
    \ b: .stringValue(\"2,3\"))\n/// .stringValue(\"2,3\")\n/// >>> compare_one(a:\
    \ .stringValue(\"5,1\"), b: .stringValue(\"6\"))\n/// .stringValue(\"6\")\n///\
    \ >>> compare_one(a: .stringValue(\"1\"), b: .intValue(1))\n/// nil\nfunc compare_one(a:\
    \ Value, b: Value) -> Value? {\n    switch (a, b) {\n    case let (.intValue(aInt),\
    \ .intValue(bInt)):\n        if aInt > bInt {\n            return .intValue(aInt)\n\
    \        } else if aInt < bInt {\n            return .intValue(bInt)\n       \
    \ } else {\n            return nil\n        }\n    case let (.intValue(aInt),\
    \ .doubleValue(bDouble)):\n        if Double(aInt) > bDouble {\n            return\
    \ .doubleValue(Double(aInt))\n        } else if Double(aInt) < bDouble {\n   \
    \         return .doubleValue(bDouble)\n        } else {\n            return nil\n\
    \        }\n    case let (.intValue(aInt), .stringValue(bString)):\n        if\
    \ Double(aInt) > Double(bString.replacingOccurrences(of: \",\", with: \".\"))!\
    \ {\n            return .stringValue(String(aInt))\n        } else if Double(aInt)\
    \ < Double(bString.replacingOccurrences(of: \",\", with: \".\"))! {\n        \
    \    return .stringValue(bString)\n        } else {\n            return nil\n\
    \        }\n    case let (.doubleValue(aDouble), .intValue(bInt)):\n        if\
    \ aDouble > Double(bInt) {\n            return .doubleValue(aDouble)\n       \
    \ } else if aDouble < Double(bInt) {\n            return .doubleValue(Double(bInt))\n\
    \        } else {\n            return nil\n        }\n    case let (.doubleValue(aDouble),\
    \ .doubleValue(bDouble)):\n        if aDouble > bDouble {\n            return\
    \ .doubleValue(aDouble)\n        } else if aDouble < bDouble {\n            return\
    \ .doubleValue(bDouble)\n        } else {\n            return nil\n        }\n\
    \    case let (.doubleValue(aDouble), .stringValue(bString)):\n        if aDouble\
    \ > Double(bString.replacingOccurrences(of: \",\", with: \".\"))! {\n        \
    \    return .doubleValue(aDouble)\n        } else if aDouble < Double(bString.replacingOccurrences(of:\
    \ \",\", with:\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool\
    \ {\n    if left.count != right.count {\n        return false\n    }\n    for\
    \ (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(compare_one(a: .intValue(1),\
    \ b: .intValue(2)) == .intValue(2))\nassert(compare_one(a: .intValue(1), b: .doubleValue(2.5))\
    \ == .doubleValue(2.5))\nassert(compare_one(a: .intValue(2), b: .intValue(3))\
    \ == .intValue(3))\nassert(compare_one(a: .intValue(5), b: .intValue(6)) == .intValue(6))\n\
    assert(compare_one(a: .intValue(1), b: .stringValue(\"2,3\")) == .stringValue(\"\
    2,3\"))\nassert(compare_one(a: .stringValue(\"5,1\"), b: .stringValue(\"6\"))\
    \ == .stringValue(\"6\"))\nassert(compare_one(a: .stringValue(\"1\"), b: .stringValue(\"\
    2\")) == .stringValue(\"2\"))\nassert(compare_one(a: .stringValue(\"1\"), b: .intValue(1))\
    \ == nil)"
  status: SyntaxError
  stderr: "/tmp/tmp1hg4v1vl.swift:67:1: error: expected expression in list of expressions\n\
    }\n^\n/tmp/tmp1hg4v1vl.swift:89:66: error: expected '}' at end of brace statement\n\
    assert(compare_one(a: .stringValue(\"1\"), b: .intValue(1)) == nil)\n        \
    \                                                         ^\n/tmp/tmp1hg4v1vl.swift:21:48:\
    \ note: to match this opening '{'\nfunc compare_one(a: Value, b: Value) -> Value?\
    \ {\n                                               ^\n/tmp/tmp1hg4v1vl.swift:40:42:\
    \ error: value of type 'String' has no member 'replacingOccurrences'\n       \
    \ if Double(aInt) > Double(bString.replacingOccurrences(of: \",\", with: \".\"\
    ))! {\n                                 ~~~~~~~ ^~~~~~~~~~~~~~~~~~~~\n/tmp/tmp1hg4v1vl.swift:42:49:\
    \ error: value of type 'String' has no member 'replacingOccurrences'\n       \
    \ } else if Double(aInt) < Double(bString.replacingOccurrences(of: \",\", with:\
    \ \".\"))! {\n                                        ~~~~~~~ ^~~~~~~~~~~~~~~~~~~~\n\
    /tmp/tmp1hg4v1vl.swift:64:37: error: value of type 'String' has no member 'replacingOccurrences'\n\
    \        if aDouble > Double(bString.replacingOccurrences(of: \",\", with: \"\
    .\"))! {\n                            ~~~~~~~ ^~~~~~~~~~~~~~~~~~~~\n/tmp/tmp1hg4v1vl.swift:66:44:\
    \ error: value of type 'String' has no member 'replacingOccurrences'\n       \
    \ } else if aDouble < Double(bString.replacingOccurrences(of: \",\", with:\n \
    \                                  ~~~~~~~ ^~~~~~~~~~~~~~~~~~~~\n/tmp/tmp1hg4v1vl.swift:22:5:\
    \ error: switch must be exhaustive\n    switch (a, b) {\n    ^\n/tmp/tmp1hg4v1vl.swift:22:5:\
    \ note: add missing case: '(.stringValue(_), _)'\n    switch (a, b) {\n    ^\n\
    /tmp/tmp1hg4v1vl.swift:70:6: error: operator functions can only be declared at\
    \ global or in type scope\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) ->\
    \ Bool {\n     ^\n"
  stdout: ''
  timestamp: 1660013179
- exit_code: 1
  program: "\nenum Value: Equatable, Hashable {\n    case intValue(Int)\n    case\
    \ doubleValue(Double)\n    case stringValue(String)\n}\n\n            \n/// Create\
    \ a function that takes integers, floats, or strings representing\n/// real numbers,\
    \ and returns the larger variable in its given variable type.\n/// Return nil\
    \ if the values are equal.\n/// Note: If a real number is represented as a string,\
    \ the floating point might be . or ,\n/// >>> compare_one(a: .intValue(1), b:\
    \ .doubleValue(2.5))\n/// .doubleValue(2.5)\n/// >>> compare_one(a: .intValue(1),\
    \ b: .stringValue(\"2,3\"))\n/// .stringValue(\"2,3\")\n/// >>> compare_one(a:\
    \ .stringValue(\"5,1\"), b: .stringValue(\"6\"))\n/// .stringValue(\"6\")\n///\
    \ >>> compare_one(a: .stringValue(\"1\"), b: .intValue(1))\n/// nil\nfunc compare_one(a:\
    \ Value, b: Value) -> Value? {\n    switch (a, b) {\n    case (.intValue(let aValue),\
    \ .intValue(let bValue)):\n        return (aValue > bValue) ? a : (aValue < bValue)\
    \ ? b : nil\n    case (.intValue(let aValue), .doubleValue(let bValue)):\n   \
    \     return (aValue > bValue) ? a : (aValue < bValue) ? b : nil\n    case (.intValue(let\
    \ aValue), .stringValue(let bValue)):\n        return (aValue > (bValue as NSString).doubleValue)\
    \ ? a : (aValue < (bValue as NSString).doubleValue) ? b : nil\n    case (.doubleValue(let\
    \ aValue), .intValue(let bValue)):\n        return (aValue > bValue) ? a : (aValue\
    \ < bValue) ? b : nil\n    case (.doubleValue(let aValue), .doubleValue(let bValue)):\n\
    \        return (aValue > bValue) ? a : (aValue < bValue) ? b : nil\n    case\
    \ (.doubleValue(let aValue), .stringValue(let bValue)):\n        return (aValue\
    \ > (bValue as NSString).doubleValue) ? a : (aValue < (bValue as NSString).doubleValue)\
    \ ? b : nil\n    case (.stringValue(let aValue), .intValue(let bValue)):\n   \
    \     return ((aValue as NSString).doubleValue > bValue) ? a : ((aValue as NSString).doubleValue\
    \ < bValue) ? b : nil\n    case (.stringValue(let aValue), .doubleValue(let bValue)):\n\
    \        return ((aValue as NSString).doubleValue > bValue) ? a : ((aValue as\
    \ NSString).doubleValue < bValue) ? b : nil\n    case (.stringValue(let aValue),\
    \ .stringValue(let bValue)):\n        return ((aValue as NSString).doubleValue\
    \ > (bValue as NSString).doubleValue) ? a : ((aValue as NSString).doubleValue\
    \ < (bValue as NSString).doubleValue) ? b : nil\n    }\n}\n\n\nfunc ==(left: [(Int,\
    \ Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n\
    \        return false\n    }\n    for (l, r) in zip(left, right) {\n        if\
    \ l != r {\n            return false\n        }\n    }\n    return true\n}\n \
    \           \nassert(compare_one(a: .intValue(1), b: .intValue(2)) == .intValue(2))\n\
    assert(compare_one(a: .intValue(1), b: .doubleValue(2.5)) == .doubleValue(2.5))\n\
    assert(compare_one(a: .intValue(2), b: .intValue(3)) == .intValue(3))\nassert(compare_one(a:\
    \ .intValue(5), b: .intValue(6)) == .intValue(6))\nassert(compare_one(a: .intValue(1),\
    \ b: .stringValue(\"2,3\")) == .stringValue(\"2,3\"))\nassert(compare_one(a: .stringValue(\"\
    5,1\"), b: .stringValue(\"6\")) == .stringValue(\"6\"))\nassert(compare_one(a:\
    \ .stringValue(\"1\"), b: .stringValue(\"2\")) == .stringValue(\"2\"))\nassert(compare_one(a:\
    \ .stringValue(\"1\"), b: .intValue(1)) == nil)"
  status: SyntaxError
  stderr: "/tmp/tmpa9o0sihe.swift:26:26: error: cannot convert value of type 'Double'\
    \ to expected argument type 'Int'\n        return (aValue > bValue) ? a : (aValue\
    \ < bValue) ? b : nil\n                         ^\n                         Int(\
    \  )\n/tmp/tmpa9o0sihe.swift:26:50: error: cannot convert value of type 'Double'\
    \ to expected argument type 'Int'\n        return (aValue > bValue) ? a : (aValue\
    \ < bValue) ? b : nil\n                                                 ^\n  \
    \                                               Int(  )\n/tmp/tmpa9o0sihe.swift:28:37:\
    \ error: cannot find type 'NSString' in scope\n        return (aValue > (bValue\
    \ as NSString).doubleValue) ? a : (aValue < (bValue as NSString).doubleValue)\
    \ ? b : nil\n                                    ^~~~~~~~\n/tmp/tmpa9o0sihe.swift:28:87:\
    \ error: cannot find type 'NSString' in scope\n        return (aValue > (bValue\
    \ as NSString).doubleValue) ? a : (aValue < (bValue as NSString).doubleValue)\
    \ ? b : nil\n                                                                \
    \                      ^~~~~~~~\n/tmp/tmpa9o0sihe.swift:28:47: error: value of\
    \ type 'String' has no member 'doubleValue'\n        return (aValue > (bValue\
    \ as NSString).doubleValue) ? a : (aValue < (bValue as NSString).doubleValue)\
    \ ? b : nil\n                         ~~~~~~~~~~~~~~~~~~~~ ^~~~~~~~~~~\n/tmp/tmpa9o0sihe.swift:28:97:\
    \ error: value of type 'String' has no member 'doubleValue'\n        return (aValue\
    \ > (bValue as NSString).doubleValue) ? a : (aValue < (bValue as NSString).doubleValue)\
    \ ? b : nil\n                                                                \
    \           ~~~~~~~~~~~~~~~~~~~~ ^~~~~~~~~~~\n/tmp/tmpa9o0sihe.swift:30:17: error:\
    \ cannot convert value of type 'Double' to expected argument type 'Int'\n    \
    \    return (aValue > bValue) ? a : (aValue < bValue) ? b : nil\n            \
    \    ^\n                Int(  )\n/tmp/tmpa9o0sihe.swift:30:41: error: cannot convert\
    \ value of type 'Double' to expected argument type 'Int'\n        return (aValue\
    \ > bValue) ? a : (aValue < bValue) ? b : nil\n                              \
    \      "
  stdout: ''
  timestamp: 1660013179
- exit_code: 1
  program: "\nenum Value: Equatable, Hashable {\n    case intValue(Int)\n    case\
    \ doubleValue(Double)\n    case stringValue(String)\n}\n\n            \n/// Create\
    \ a function that takes integers, floats, or strings representing\n/// real numbers,\
    \ and returns the larger variable in its given variable type.\n/// Return nil\
    \ if the values are equal.\n/// Note: If a real number is represented as a string,\
    \ the floating point might be . or ,\n/// >>> compare_one(a: .intValue(1), b:\
    \ .doubleValue(2.5))\n/// .doubleValue(2.5)\n/// >>> compare_one(a: .intValue(1),\
    \ b: .stringValue(\"2,3\"))\n/// .stringValue(\"2,3\")\n/// >>> compare_one(a:\
    \ .stringValue(\"5,1\"), b: .stringValue(\"6\"))\n/// .stringValue(\"6\")\n///\
    \ >>> compare_one(a: .stringValue(\"1\"), b: .intValue(1))\n/// nil\nfunc compare_one(a:\
    \ Value, b: Value) -> Value? {\n    \n    switch (a, b) {\n    case (.intValue(let\
    \ int1), .intValue(let int2)):\n        if int1 > int2 {\n            return .intValue(int1)\n\
    \        } else if int1 < int2 {\n            return .intValue(int2)\n       \
    \ } else {\n            return nil\n        }\n    case (.intValue(let int1),\
    \ .doubleValue(let double2)):\n        if Double(int1) > double2 {\n         \
    \   return .doubleValue(Double(int1))\n        } else if Double(int1) < double2\
    \ {\n            return .doubleValue(double2)\n        } else {\n            return\
    \ nil\n        }\n    case (.intValue(let int1), .stringValue(let string2)):\n\
    \        if let double2 = Double(string2) {\n            if Double(int1) > double2\
    \ {\n                return .doubleValue(Double(int1))\n            } else if\
    \ Double(int1) < double2 {\n                return .doubleValue(double2)\n   \
    \         } else {\n                return nil\n            }\n        } else\
    \ {\n            return .stringValue(string2)\n        }\n    case (.doubleValue(let\
    \ double1), .intValue(let int2)):\n        if double1 > Double(int2) {\n     \
    \       return .doubleValue(double1)\n        } else if double1 < Double(int2)\
    \ {\n            return .doubleValue(Double(int2))\n        } else {\n       \
    \     return nil\n        }\n    case (.doubleValue(let double1), .doubleValue(let\
    \ double2)):\n        if double1 > double2 {\n            return .doubleValue(double1)\n\
    \        } else if double1 < double2 {\n            return .doubleValue(double2)\n\
    \        } else {\n            return nil\n        }\n    case (.doubleValue(let\
    \ double1), .stringValue(let string2)):\n        if let double2 = Double(string2)\
    \ {\n            if double1 > double2 {\n                return .doubleValue(double1)\n\
    \            } else if double1 < double2 {\n                return .doubleValue(double2)\n\
    \            } else {\n                return nil\n            }\n\n}\n\n\nfunc\
    \ ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count !=\
    \ right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(compare_one(a: .intValue(1), b: .intValue(2))\
    \ == .intValue(2))\nassert(compare_one(a: .intValue(1), b: .doubleValue(2.5))\
    \ == .doubleValue(2.5))\nassert(compare_one(a: .intValue(2), b: .intValue(3))\
    \ == .intValue(3))\nassert(compare_one(a: .intValue(5), b: .intValue(6)) == .intValue(6))\n\
    assert(compare_one(a: .intValue(1), b: .stringValue(\"2,3\")) == .stringValue(\"\
    2,3\"))\nassert(compare_one(a: .stringValue(\"5,1\"), b: .stringValue(\"6\"))\
    \ == .stringValue(\"6\"))\nassert(compare_one(a: .stringValue(\"1\"), b: .stringValue(\"\
    2\")) == .stringValue(\"2\"))\nassert(compare_one(a: .stringValue(\"1\"), b: .intValue(1))\
    \ == nil)"
  status: SyntaxError
  stderr: "/tmp/tmpcm7v02a0.swift:100:66: error: expected '}' at end of 'switch' statement\n\
    assert(compare_one(a: .stringValue(\"1\"), b: .intValue(1)) == nil)\n        \
    \                                                         ^\n/tmp/tmpcm7v02a0.swift:23:19:\
    \ note: to match this opening '{'\n    switch (a, b) {\n                  ^\n\
    /tmp/tmpcm7v02a0.swift:100:66: error: expected '}' at end of brace statement\n\
    assert(compare_one(a: .stringValue(\"1\"), b: .intValue(1)) == nil)\n        \
    \                                                         ^\n/tmp/tmpcm7v02a0.swift:21:48:\
    \ note: to match this opening '{'\nfunc compare_one(a: Value, b: Value) -> Value?\
    \ {\n                                               ^\n/tmp/tmpcm7v02a0.swift:81:6:\
    \ error: operator functions can only be declared at global or in type scope\n\
    func ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n     ^\n/tmp/tmpcm7v02a0.swift:23:5:\
    \ error: switch must be exhaustive\n    switch (a, b) {\n    ^\n/tmp/tmpcm7v02a0.swift:23:5:\
    \ note: add missing case: '(.stringValue(_), _)'\n    switch (a, b) {\n    ^\n"
  stdout: ''
  timestamp: 1660013179
- exit_code: 1
  program: "\nenum Value: Equatable, Hashable {\n    case intValue(Int)\n    case\
    \ doubleValue(Double)\n    case stringValue(String)\n}\n\n            \n/// Create\
    \ a function that takes integers, floats, or strings representing\n/// real numbers,\
    \ and returns the larger variable in its given variable type.\n/// Return nil\
    \ if the values are equal.\n/// Note: If a real number is represented as a string,\
    \ the floating point might be . or ,\n/// >>> compare_one(a: .intValue(1), b:\
    \ .doubleValue(2.5))\n/// .doubleValue(2.5)\n/// >>> compare_one(a: .intValue(1),\
    \ b: .stringValue(\"2,3\"))\n/// .stringValue(\"2,3\")\n/// >>> compare_one(a:\
    \ .stringValue(\"5,1\"), b: .stringValue(\"6\"))\n/// .stringValue(\"6\")\n///\
    \ >>> compare_one(a: .stringValue(\"1\"), b: .intValue(1))\n/// nil\nfunc compare_one(a:\
    \ Value, b: Value) -> Value? {\n    let value1 = a\n    let value2 = b\n    var\
    \ ans: Value? = nil\n    switch value1 {\n    case .intValue(let i1):\n      \
    \  switch value2 {\n        case .intValue(let i2):\n            if i1 == i2 {\n\
    \                return nil\n            } else if i1 > i2 {\n               \
    \ ans = .intValue(i1)\n            } else {\n                ans = .intValue(i2)\n\
    \            }\n        case .doubleValue(let d2):\n            if Double(i1)\
    \ == d2 {\n                return nil\n            } else if Double(i1) > d2 {\n\
    \                ans = .doubleValue(Double(i1))\n            } else {\n      \
    \          ans = .doubleValue(d2)\n            }\n        case .stringValue(let\
    \ s2):\n            if Double(i1) == Double(s2) {\n                return nil\n\
    \            } else if Double(i1) > Double(s2) {\n                ans = .doubleValue(Double(i1))\n\
    \            } else {\n                ans = .stringValue(s2)\n            }\n\
    \        }\n    case .doubleValue(let d1):\n        switch value2 {\n        case\
    \ .intValue(let i2):\n            if d1 == Double(i2) {\n                return\
    \ nil\n            } else if d1 > Double(i2) {\n                ans = .doubleValue(d1)\n\
    \            } else {\n                ans = .intValue(i2)\n            }\n  \
    \      case .doubleValue(let d2):\n            if d1 == d2 {\n               \
    \ return nil\n            } else if d1 > d2 {\n                ans = .doubleValue(d1)\n\
    \            } else {\n                ans = .doubleValue(d2)\n            }\n\
    \        case .stringValue(let s2):\n            if d1 == Double(s2) {\n     \
    \           return nil\n            } else if d1 > Double(s2) {\n            \
    \    ans = .doubleValue(d1)\n            } else {\n                ans = .stringValue(s2)\n\
    \            }\n        }\n    case .stringValue(let s1):\n        switch value2\
    \ {\n       \n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool\
    \ {\n    if left.count != right.count {\n        return false\n    }\n    for\
    \ (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(compare_one(a: .intValue(1),\
    \ b: .intValue(2)) == .intValue(2))\nassert(compare_one(a: .intValue(1), b: .doubleValue(2.5))\
    \ == .doubleValue(2.5))\nassert(compare_one(a: .intValue(2), b: .intValue(3))\
    \ == .intValue(3))\nassert(compare_one(a: .intValue(5), b: .intValue(6)) == .intValue(6))\n\
    assert(compare_one(a: .intValue(1), b: .stringValue(\"2,3\")) == .stringValue(\"\
    2,3\"))\nassert(compare_one(a: .stringValue(\"5,1\"), b: .stringValue(\"6\"))\
    \ == .stringValue(\"6\"))\nassert(compare_one(a: .stringValue(\"1\"), b: .stringValue(\"\
    2\")) == .stringValue(\"2\"))\nassert(compare_one(a: .stringValue(\"1\"), b: .intValue(1))\
    \ == nil)"
  status: SyntaxError
  stderr: "/tmp/tmpac59drq8.swift:105:66: error: expected '}' at end of 'switch' statement\n\
    assert(compare_one(a: .stringValue(\"1\"), b: .intValue(1)) == nil)\n        \
    \                                                         ^\n/tmp/tmpac59drq8.swift:25:19:\
    \ note: to match this opening '{'\n    switch value1 {\n                  ^\n\
    /tmp/tmpac59drq8.swift:105:66: error: expected '}' at end of brace statement\n\
    assert(compare_one(a: .stringValue(\"1\"), b: .intValue(1)) == nil)\n        \
    \                                                         ^\n/tmp/tmpac59drq8.swift:21:48:\
    \ note: to match this opening '{'\nfunc compare_one(a: Value, b: Value) -> Value?\
    \ {\n                                               ^\n/tmp/tmpac59drq8.swift:47:36:\
    \ error: value of optional type 'Double?' must be unwrapped to a value of type\
    \ 'Double'\n            } else if Double(i1) > Double(s2) {\n                \
    \                   ^\n/tmp/tmpac59drq8.swift:47:36: note: coalesce using '??'\
    \ to provide a default when the optional value contains 'nil'\n            } else\
    \ if Double(i1) > Double(s2) {\n                                   ^\n       \
    \                                       ?? <#default value#>\n/tmp/tmpac59drq8.swift:47:36:\
    \ note: force-unwrap using '!' to abort execution if the optional value contains\
    \ 'nil'\n            } else if Double(i1) > Double(s2) {\n                   \
    \                ^\n                                             !\n/tmp/tmpac59drq8.swift:74:28:\
    \ error: value of optional type 'Double?' must be unwrapped to a value of type\
    \ 'Double'\n            } else if d1 > Double(s2) {\n                        \
    \   ^\n/tmp/tmpac59drq8.swift:74:28: note: coalesce using '??' to provide a default\
    \ when the optional value contains 'nil'\n            } else if d1 > Double(s2)\
    \ {\n                           ^\n                                      ?? <#default\
    \ value#>\n/tmp/tmpac59drq8.swift:74:28: note: force-unwrap using '!' to abort\
    \ execution if the optional value contains 'nil'\n            } else if d1 > Double(s2)\
    \ {\n                           ^\n                                  "
  stdout: ''
  timestamp: 1660013179
- exit_code: 1
  program: "\nenum Value: Equatable, Hashable {\n    case intValue(Int)\n    case\
    \ doubleValue(Double)\n    case stringValue(String)\n}\n\n            \n/// Create\
    \ a function that takes integers, floats, or strings representing\n/// real numbers,\
    \ and returns the larger variable in its given variable type.\n/// Return nil\
    \ if the values are equal.\n/// Note: If a real number is represented as a string,\
    \ the floating point might be . or ,\n/// >>> compare_one(a: .intValue(1), b:\
    \ .doubleValue(2.5))\n/// .doubleValue(2.5)\n/// >>> compare_one(a: .intValue(1),\
    \ b: .stringValue(\"2,3\"))\n/// .stringValue(\"2,3\")\n/// >>> compare_one(a:\
    \ .stringValue(\"5,1\"), b: .stringValue(\"6\"))\n/// .stringValue(\"6\")\n///\
    \ >>> compare_one(a: .stringValue(\"1\"), b: .intValue(1))\n/// nil\nfunc compare_one(a:\
    \ Value, b: Value) -> Value? {\n    let aDouble = Double(a)\n    let bDouble =\
    \ Double(b)\n    switch (aDouble, bDouble) {\n    case let (aDouble?, bDouble?):\n\
    \        return aDouble > bDouble ? a : b\n    case (nil, let .some(bDouble)):\n\
    \        return b\n    case (let .some(aDouble), nil):\n        return a\n   \
    \ default:\n        return nil\n    }\n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(compare_one(a: .intValue(1), b: .intValue(2)) == .intValue(2))\nassert(compare_one(a:\
    \ .intValue(1), b: .doubleValue(2.5)) == .doubleValue(2.5))\nassert(compare_one(a:\
    \ .intValue(2), b: .intValue(3)) == .intValue(3))\nassert(compare_one(a: .intValue(5),\
    \ b: .intValue(6)) == .intValue(6))\nassert(compare_one(a: .intValue(1), b: .stringValue(\"\
    2,3\")) == .stringValue(\"2,3\"))\nassert(compare_one(a: .stringValue(\"5,1\"\
    ), b: .stringValue(\"6\")) == .stringValue(\"6\"))\nassert(compare_one(a: .stringValue(\"\
    1\"), b: .stringValue(\"2\")) == .stringValue(\"2\"))\nassert(compare_one(a: .stringValue(\"\
    1\"), b: .intValue(1)) == nil)"
  status: SyntaxError
  stderr: "/tmp/tmpq_0m_aa6.swift:22:19: error: no exact matches in call to initializer\
    \ \n    let aDouble = Double(a)\n                  ^\nSwift.Double:2:23: note:\
    \ candidate requires that 'Value' conform to 'StringProtocol' (requirement specified\
    \ as 'S' : 'StringProtocol')\n    @inlinable public init?<S>(_ text: S) where\
    \ S : StringProtocol\n                      ^\nSwift.Double:3:23: note: candidate\
    \ requires that 'Value' conform to 'BinaryInteger' (requirement specified as 'Source'\
    \ : 'BinaryInteger')\n    @inlinable public init<Source>(_ value: Source) where\
    \ Source : BinaryInteger\n                      ^\nSwift.BinaryFloatingPoint:5:23:\
    \ note: candidate requires that 'Value' conform to 'BinaryFloatingPoint' (requirement\
    \ specified as 'Source' : 'BinaryFloatingPoint')\n    @inlinable public init<Source>(_\
    \ value: Source) where Source : BinaryFloatingPoint\n                      ^\n\
    Swift.BinaryFloatingPoint:3:23: note: candidate requires that 'Value' conform\
    \ to 'BinaryInteger' (requirement specified as 'Source' : 'BinaryInteger')\n \
    \   @inlinable public init<Source>(_ value: Source) where Source : BinaryInteger\n\
    \                      ^\n/tmp/tmpq_0m_aa6.swift:23:19: error: no exact matches\
    \ in call to initializer \n    let bDouble = Double(b)\n                  ^\n\
    Swift.Double:2:23: note: candidate requires that 'Value' conform to 'StringProtocol'\
    \ (requirement specified as 'S' : 'StringProtocol')\n    @inlinable public init?<S>(_\
    \ text: S) where S : StringProtocol\n                      ^\nSwift.Double:3:23:\
    \ note: candidate requires that 'Value' conform to 'BinaryInteger' (requirement\
    \ specified as 'Source' : 'BinaryInteger')\n    @inlinable public init<Source>(_\
    \ value: Source) where Source : BinaryInteger\n                      ^\nSwift.BinaryFloatingPoint:5:23:\
    \ note: candidate requires that 'Value' conform to 'BinaryFloatingPoint' (requirement\
    \ specified as 'Source' : 'BinaryFloatingPoint')\n    @inlinable public init<Source>(_\
    \ value: Source) where Source : BinaryFloatingPoint\n                      ^\n\
    Swift.BinaryFloatingPoint:3:23: note: candidate requir"
  stdout: ''
  timestamp: 1660013179
- exit_code: 1
  program: "\nenum Value: Equatable, Hashable {\n    case intValue(Int)\n    case\
    \ doubleValue(Double)\n    case stringValue(String)\n}\n\n            \n/// Create\
    \ a function that takes integers, floats, or strings representing\n/// real numbers,\
    \ and returns the larger variable in its given variable type.\n/// Return nil\
    \ if the values are equal.\n/// Note: If a real number is represented as a string,\
    \ the floating point might be . or ,\n/// >>> compare_one(a: .intValue(1), b:\
    \ .doubleValue(2.5))\n/// .doubleValue(2.5)\n/// >>> compare_one(a: .intValue(1),\
    \ b: .stringValue(\"2,3\"))\n/// .stringValue(\"2,3\")\n/// >>> compare_one(a:\
    \ .stringValue(\"5,1\"), b: .stringValue(\"6\"))\n/// .stringValue(\"6\")\n///\
    \ >>> compare_one(a: .stringValue(\"1\"), b: .intValue(1))\n/// nil\nfunc compare_one(a:\
    \ Value, b: Value) -> Value? {\n    switch a {\n    case .intValue(let a):\n \
    \       switch b {\n        case .intValue(let b):\n            return a > b ?\
    \ a : b\n        case .doubleValue(let b):\n            return a > b ? .doubleValue(Double(a))\
    \ : .doubleValue(b)\n        case .stringValue(let b):\n            let value\
    \ = Double(b.replacingOccurrences(of: \",\", with: \".\"))\n            return\
    \ a > value! ? .doubleValue(Double(a)) : .doubleValue(value!)\n        }\n   \
    \ case .doubleValue(let a):\n        switch b {\n        case .intValue(let b):\n\
    \            return a > Double(b) ? .doubleValue(a) : .doubleValue(Double(b))\n\
    \        case .doubleValue(let b):\n            return a > b ? .doubleValue(a)\
    \ : .doubleValue(b)\n        case .stringValue(let b):\n            let value\
    \ = Double(b.replacingOccurrences(of: \",\", with: \".\"))\n            return\
    \ a > value! ? .doubleValue(a) : .doubleValue(value!)\n        }\n    case .stringValue(let\
    \ a):\n        switch b {\n        case .intValue(let b):\n            let value\
    \ = Double(a.replacingOccurrences(of: \",\", with: \".\"))\n            return\
    \ value! > Double(b) ? .doubleValue(value!) : .doubleValue(Double(b))\n      \
    \  case .doubleValue(let b):\n            let value = Double(a.replacingOccurrences(of:\
    \ \",\", with: \".\"))\n            return value! > b ? .doubleValue(value!) :\
    \ .doubleValue(b)\n        case .stringValue(let b):\n            let valueA =\
    \ Double(a.replacingOccurrences(of: \",\", with: \".\"))\n            let valueB\
    \ = Double(b.replacingOccurrences(of: \",\", with: \".\"))\n            return\
    \ valueA! > valueB! ? .doubleValue(valueA!) : .doubleValue(valueB!)\n        }\n\
    \    }\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n  \
    \  if left.count != right.count {\n        return false\n    }\n    for (l, r)\
    \ in zip(left, right) {\n        if l != r {\n            return false\n     \
    \   }\n    }\n    return true\n}\n            \nassert(compare_one(a: .intValue(1),\
    \ b: .intValue(2)) == .intValue(2))\nassert(compare_one(a: .intValue(1), b: .doubleValue(2.5))\
    \ == .doubleValue(2.5))\nassert(compare_one(a: .intValue(2), b: .intValue(3))\
    \ == .intValue(3))\nassert(compare_one(a: .intValue(5), b: .intValue(6)) == .intValue(6))\n\
    assert(compare_one(a: .intValue(1), b: .stringValue(\"2,3\")) == .stringValue(\"\
    2,3\"))\nassert(compare_one(a: .stringValue(\"5,1\"), b: .stringValue(\"6\"))\
    \ == .stringValue(\"6\"))\nassert(compare_one(a: .stringValue(\"1\"), b: .stringValue(\"\
    2\")) == .stringValue(\"2\"))\nassert(compare_one(a: .stringValue(\"1\"), b: .intValue(1))\
    \ == nil)"
  status: SyntaxError
  stderr: "/tmp/tmp7lqz9ld2.swift:26:26: error: cannot convert return expression of\
    \ type 'Int' to return type 'Value?'\n            return a > b ? a : b\n     \
    \              ~~~~~~^~~~~~~\n/tmp/tmp7lqz9ld2.swift:28:24: error: cannot convert\
    \ value of type 'Double' to expected argument type 'Int'\n            return a\
    \ > b ? .doubleValue(Double(a)) : .doubleValue(b)\n                       ^\n\
    \                       Int( )\n/tmp/tmp7lqz9ld2.swift:30:34: error: value of\
    \ type 'String' has no member 'replacingOccurrences'\n            let value =\
    \ Double(b.replacingOccurrences(of: \",\", with: \".\"))\n                   \
    \            ~ ^~~~~~~~~~~~~~~~~~~~\n/tmp/tmp7lqz9ld2.swift:40:34: error: value\
    \ of type 'String' has no member 'replacingOccurrences'\n            let value\
    \ = Double(b.replacingOccurrences(of: \",\", with: \".\"))\n                 \
    \              ~ ^~~~~~~~~~~~~~~~~~~~\n/tmp/tmp7lqz9ld2.swift:46:34: error: value\
    \ of type 'String' has no member 'replacingOccurrences'\n            let value\
    \ = Double(a.replacingOccurrences(of: \",\", with: \".\"))\n                 \
    \              ~ ^~~~~~~~~~~~~~~~~~~~\n/tmp/tmp7lqz9ld2.swift:49:34: error: value\
    \ of type 'String' has no member 'replacingOccurrences'\n            let value\
    \ = Double(a.replacingOccurrences(of: \",\", with: \".\"))\n                 \
    \              ~ ^~~~~~~~~~~~~~~~~~~~\n/tmp/tmp7lqz9ld2.swift:52:35: error: value\
    \ of type 'String' has no member 'replacingOccurrences'\n            let valueA\
    \ = Double(a.replacingOccurrences(of: \",\", with: \".\"))\n                 \
    \               ~ ^~~~~~~~~~~~~~~~~~~~\n/tmp/tmp7lqz9ld2.swift:53:35: error: value\
    \ of type 'String' has no member 'replacingOccurrences'\n            let valueB\
    \ = Double(b.replacingOccurrences(of: \",\", with: \".\"))\n                 \
    \               ~ ^~~~~~~~~~~~~~~~~~~~\n"
  stdout: ''
  timestamp: 1660013179
- exit_code: 1
  program: "\nenum Value: Equatable, Hashable {\n    case intValue(Int)\n    case\
    \ doubleValue(Double)\n    case stringValue(String)\n}\n\n            \n/// Create\
    \ a function that takes integers, floats, or strings representing\n/// real numbers,\
    \ and returns the larger variable in its given variable type.\n/// Return nil\
    \ if the values are equal.\n/// Note: If a real number is represented as a string,\
    \ the floating point might be . or ,\n/// >>> compare_one(a: .intValue(1), b:\
    \ .doubleValue(2.5))\n/// .doubleValue(2.5)\n/// >>> compare_one(a: .intValue(1),\
    \ b: .stringValue(\"2,3\"))\n/// .stringValue(\"2,3\")\n/// >>> compare_one(a:\
    \ .stringValue(\"5,1\"), b: .stringValue(\"6\"))\n/// .stringValue(\"6\")\n///\
    \ >>> compare_one(a: .stringValue(\"1\"), b: .intValue(1))\n/// nil\nfunc compare_one(a:\
    \ Value, b: Value) -> Value? {\n    switch (a, b) {\n    case let (.intValue(a),\
    \ .intValue(b)) where a != b:\n        return a > b ? a : b\n    case let (.doubleValue(a),\
    \ .doubleValue(b)) where a != b:\n        return a > b ? a : b\n    case let (.stringValue(a),\
    \ .stringValue(b)) where a != b:\n        return a > b ? a : b\n    default:\n\
    \        return nil\n    }\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(compare_one(a:\
    \ .intValue(1), b: .intValue(2)) == .intValue(2))\nassert(compare_one(a: .intValue(1),\
    \ b: .doubleValue(2.5)) == .doubleValue(2.5))\nassert(compare_one(a: .intValue(2),\
    \ b: .intValue(3)) == .intValue(3))\nassert(compare_one(a: .intValue(5), b: .intValue(6))\
    \ == .intValue(6))\nassert(compare_one(a: .intValue(1), b: .stringValue(\"2,3\"\
    )) == .stringValue(\"2,3\"))\nassert(compare_one(a: .stringValue(\"5,1\"), b:\
    \ .stringValue(\"6\")) == .stringValue(\"6\"))\nassert(compare_one(a: .stringValue(\"\
    1\"), b: .stringValue(\"2\")) == .stringValue(\"2\"))\nassert(compare_one(a: .stringValue(\"\
    1\"), b: .intValue(1)) == nil)"
  status: SyntaxError
  stderr: "/tmp/tmpe9rc17ll.swift:24:22: error: cannot convert return expression of\
    \ type 'Int' to return type 'Value?'\n        return a > b ? a : b\n         \
    \      ~~~~~~^~~~~~~\n/tmp/tmpe9rc17ll.swift:26:22: error: cannot convert return\
    \ expression of type 'Double' to return type 'Value?'\n        return a > b ?\
    \ a : b\n               ~~~~~~^~~~~~~\n/tmp/tmpe9rc17ll.swift:28:22: error: cannot\
    \ convert return expression of type 'String' to return type 'Value?'\n       \
    \ return a > b ? a : b\n               ~~~~~~^~~~~~~\n"
  stdout: ''
  timestamp: 1660013179
- exit_code: 1
  program: "\nenum Value: Equatable, Hashable {\n    case intValue(Int)\n    case\
    \ doubleValue(Double)\n    case stringValue(String)\n}\n\n            \n/// Create\
    \ a function that takes integers, floats, or strings representing\n/// real numbers,\
    \ and returns the larger variable in its given variable type.\n/// Return nil\
    \ if the values are equal.\n/// Note: If a real number is represented as a string,\
    \ the floating point might be . or ,\n/// >>> compare_one(a: .intValue(1), b:\
    \ .doubleValue(2.5))\n/// .doubleValue(2.5)\n/// >>> compare_one(a: .intValue(1),\
    \ b: .stringValue(\"2,3\"))\n/// .stringValue(\"2,3\")\n/// >>> compare_one(a:\
    \ .stringValue(\"5,1\"), b: .stringValue(\"6\"))\n/// .stringValue(\"6\")\n///\
    \ >>> compare_one(a: .stringValue(\"1\"), b: .intValue(1))\n/// nil\nfunc compare_one(a:\
    \ Value, b: Value) -> Value? {\n    switch (a, b) {\n    case (.intValue(let i),\
    \ .intValue(let j)):\n        return i >= j ? a : b\n    case (.intValue(let i),\
    \ .doubleValue(let j)):\n        return i >= j ? a : b\n    case (.intValue(let\
    \ i), .stringValue(let j)):\n        return i >= Double(j) ? a : b\n    case (.doubleValue(let\
    \ i), .intValue(let j)):\n        return i >= j ? a : b\n    case (.doubleValue(let\
    \ i), .doubleValue(let j)):\n        return i >= j ? a : b\n    case (.doubleValue(let\
    \ i), .stringValue(let j)):\n        return i >= Double(j) ? a : b\n    case (.stringValue(let\
    \ i), .intValue(let j)):\n        return Double(i) >= j ? a : b\n    case (.stringValue(let\
    \ i), .doubleValue(let j)):\n        return Double(i) >= j ? a : b\n    case (.stringValue(let\
    \ i), .stringValue(let j)):\n        return Double(i) >= Double(j) ? a : b\n \
    \   }\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n   \
    \ if left.count != right.count {\n        return false\n    }\n    for (l, r)\
    \ in zip(left, right) {\n        if l != r {\n            return false\n     \
    \   }\n    }\n    return true\n}\n            \nassert(compare_one(a: .intValue(1),\
    \ b: .intValue(2)) == .intValue(2))\nassert(compare_one(a: .intValue(1), b: .doubleValue(2.5))\
    \ == .doubleValue(2.5))\nassert(compare_one(a: .intValue(2), b: .intValue(3))\
    \ == .intValue(3))\nassert(compare_one(a: .intValue(5), b: .intValue(6)) == .intValue(6))\n\
    assert(compare_one(a: .intValue(1), b: .stringValue(\"2,3\")) == .stringValue(\"\
    2,3\"))\nassert(compare_one(a: .stringValue(\"5,1\"), b: .stringValue(\"6\"))\
    \ == .stringValue(\"6\"))\nassert(compare_one(a: .stringValue(\"1\"), b: .stringValue(\"\
    2\")) == .stringValue(\"2\"))\nassert(compare_one(a: .stringValue(\"1\"), b: .intValue(1))\
    \ == nil)"
  status: SyntaxError
  stderr: "/tmp/tmpibl9m7aa.swift:26:21: error: cannot convert value of type 'Double'\
    \ to expected argument type 'Int'\n        return i >= j ? a : b\n           \
    \         ^\n                    Int( )\n/tmp/tmpibl9m7aa.swift:28:21: error:\
    \ cannot convert value of type 'Double?' to expected argument type 'Int'\n   \
    \     return i >= Double(j) ? a : b\n                    ^\n/tmp/tmpibl9m7aa.swift:30:16:\
    \ error: cannot convert value of type 'Double' to expected argument type 'Int'\n\
    \        return i >= j ? a : b\n               ^\n               Int( )\n/tmp/tmpibl9m7aa.swift:34:21:\
    \ error: value of optional type 'Double?' must be unwrapped to a value of type\
    \ 'Double'\n        return i >= Double(j) ? a : b\n                    ^\n/tmp/tmpibl9m7aa.swift:34:21:\
    \ note: coalesce using '??' to provide a default when the optional value contains\
    \ 'nil'\n        return i >= Double(j) ? a : b\n                    ^\n      \
    \                        ?? <#default value#>\n/tmp/tmpibl9m7aa.swift:34:21: note:\
    \ force-unwrap using '!' to abort execution if the optional value contains 'nil'\n\
    \        return i >= Double(j) ? a : b\n                    ^\n              \
    \               !\n/tmp/tmpibl9m7aa.swift:36:16: error: cannot convert value of\
    \ type 'Double?' to expected argument type 'Int'\n        return Double(i) >=\
    \ j ? a : b\n               ^\n/tmp/tmpibl9m7aa.swift:38:16: error: value of optional\
    \ type 'Double?' must be unwrapped to a value of type 'Double'\n        return\
    \ Double(i) >= j ? a : b\n               ^\n/tmp/tmpibl9m7aa.swift:38:16: note:\
    \ coalesce using '??' to provide a default when the optional value contains 'nil'\n\
    \        return Double(i) >= j ? a : b\n               ^\n                   \
    \      ?? <#default value#>\n/tmp/tmpibl9m7aa.swift:38:16: note: force-unwrap\
    \ using '!' to abort execution if the optional value contains 'nil'\n        return\
    \ Double(i) >= j ? a : b\n               ^\n                        !\n/tmp/tmpibl9m7aa.swift:40:29:\
    \ error: value of optional type 'Double?' must be unwrapped to a value of type\
    \ 'Double'\n        return Double(i) >= Double(j) ? a : b\n"
  stdout: ''
  timestamp: 1660013179
- exit_code: 1
  program: "\nenum Value: Equatable, Hashable {\n    case intValue(Int)\n    case\
    \ doubleValue(Double)\n    case stringValue(String)\n}\n\n            \n/// Create\
    \ a function that takes integers, floats, or strings representing\n/// real numbers,\
    \ and returns the larger variable in its given variable type.\n/// Return nil\
    \ if the values are equal.\n/// Note: If a real number is represented as a string,\
    \ the floating point might be . or ,\n/// >>> compare_one(a: .intValue(1), b:\
    \ .doubleValue(2.5))\n/// .doubleValue(2.5)\n/// >>> compare_one(a: .intValue(1),\
    \ b: .stringValue(\"2,3\"))\n/// .stringValue(\"2,3\")\n/// >>> compare_one(a:\
    \ .stringValue(\"5,1\"), b: .stringValue(\"6\"))\n/// .stringValue(\"6\")\n///\
    \ >>> compare_one(a: .stringValue(\"1\"), b: .intValue(1))\n/// nil\nfunc compare_one(a:\
    \ Value, b: Value) -> Value? {\n    switch (a, b) {\n    case let (.intValue(lhs),\
    \ .intValue(rhs)):\n        return lhs >= rhs ? a : b\n    case let (.intValue(lhs),\
    \ .doubleValue(rhs)):\n        return lhs >= rhs ? a : b\n    case let (.intValue(lhs),\
    \ .stringValue(rhs)):\n        let realRhs = Double(rhs) ?? Double.infinity\n\
    \        return lhs >= realRhs ? a : b\n    case let (.doubleValue(lhs), .intValue(rhs)):\n\
    \        return lhs >= rhs ? a : b\n    case let (.doubleValue(lhs), .doubleValue(rhs)):\n\
    \        return lhs >= rhs ? a : b\n    case let (.doubleValue(lhs), .stringValue(rhs)):\n\
    \        let realRhs = Double(rhs) ?? Double.infinity\n        return lhs >= realRhs\
    \ ? a : b\n    case let (.stringValue(lhs), .intValue(rhs)):\n        let realLhs\
    \ = Double(lhs) ?? Double.infinity\n        return realLhs >= rhs ? a : b\n  \
    \  case let (.stringValue(lhs), .doubleValue(rhs)):\n        let realLhs = Double(lhs)\
    \ ?? Double.infinity\n        return realLhs >= rhs ? a : b\n    case let (.stringValue(lhs),\
    \ .stringValue(rhs)):\n        let realLhs = Double(lhs) ?? Double.infinity\n\
    \        let realRhs = Double(rhs) ?? Double.infinity\n        return realLhs\
    \ >= realRhs ? a : b\n    }\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int,\
    \ Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n\
    \    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n          \
    \  return false\n        }\n    }\n    return true\n}\n            \nassert(compare_one(a:\
    \ .intValue(1), b: .intValue(2)) == .intValue(2))\nassert(compare_one(a: .intValue(1),\
    \ b: .doubleValue(2.5)) == .doubleValue(2.5))\nassert(compare_one(a: .intValue(2),\
    \ b: .intValue(3)) == .intValue(3))\nassert(compare_one(a: .intValue(5), b: .intValue(6))\
    \ == .intValue(6))\nassert(compare_one(a: .intValue(1), b: .stringValue(\"2,3\"\
    )) == .stringValue(\"2,3\"))\nassert(compare_one(a: .stringValue(\"5,1\"), b:\
    \ .stringValue(\"6\")) == .stringValue(\"6\"))\nassert(compare_one(a: .stringValue(\"\
    1\"), b: .stringValue(\"2\")) == .stringValue(\"2\"))\nassert(compare_one(a: .stringValue(\"\
    1\"), b: .intValue(1)) == nil)"
  status: SyntaxError
  stderr: "/tmp/tmpr8vgrr8v.swift:26:23: error: cannot convert value of type 'Double'\
    \ to expected argument type 'Int'\n        return lhs >= rhs ? a : b\n       \
    \               ^\n                      Int( )\n/tmp/tmpr8vgrr8v.swift:29:23:\
    \ error: cannot convert value of type 'Double' to expected argument type 'Int'\n\
    \        return lhs >= realRhs ? a : b\n                      ^\n            \
    \          Int(   )\n/tmp/tmpr8vgrr8v.swift:31:16: error: cannot convert value\
    \ of type 'Double' to expected argument type 'Int'\n        return lhs >= rhs\
    \ ? a : b\n               ^\n               Int( )\n/tmp/tmpr8vgrr8v.swift:39:16:\
    \ error: cannot convert value of type 'Double' to expected argument type 'Int'\n\
    \        return realLhs >= rhs ? a : b\n               ^\n               Int(\
    \   )\n"
  stdout: ''
  timestamp: 1660013179
- exit_code: 1
  program: "\nenum Value: Equatable, Hashable {\n    case intValue(Int)\n    case\
    \ doubleValue(Double)\n    case stringValue(String)\n}\n\n            \n/// Create\
    \ a function that takes integers, floats, or strings representing\n/// real numbers,\
    \ and returns the larger variable in its given variable type.\n/// Return nil\
    \ if the values are equal.\n/// Note: If a real number is represented as a string,\
    \ the floating point might be . or ,\n/// >>> compare_one(a: .intValue(1), b:\
    \ .doubleValue(2.5))\n/// .doubleValue(2.5)\n/// >>> compare_one(a: .intValue(1),\
    \ b: .stringValue(\"2,3\"))\n/// .stringValue(\"2,3\")\n/// >>> compare_one(a:\
    \ .stringValue(\"5,1\"), b: .stringValue(\"6\"))\n/// .stringValue(\"6\")\n///\
    \ >>> compare_one(a: .stringValue(\"1\"), b: .intValue(1))\n/// nil\nfunc compare_one(a:\
    \ Value, b: Value) -> Value? {\n    switch a {\n    case .intValue(let a):\n \
    \       switch b {\n        case .intValue(let b):\n            return a > b ?\
    \ a : b\n        case .doubleValue(let b):\n            return b\n        case\
    \ .stringValue(let b):\n            let d_b = Double(b.replacingOccurrences(of:\
    \ \",\", with: \".\"))\n            return d_b!\n        }\n    case .doubleValue(let\
    \ a):\n        switch b {\n        case .intValue(let b):\n            return\
    \ a\n        case .doubleValue(let b):\n            return a > b ? a : b\n   \
    \     case .stringValue(let b):\n            let d_b = Double(b.replacingOccurrences(of:\
    \ \",\", with: \".\"))\n            return a > d_b! ? a : d_b!\n        }\n  \
    \  case .stringValue(let a):\n        switch b {\n        case .intValue(let b):\n\
    \            let d_a = Double(a.replacingOccurrences(of: \",\", with: \".\"))\n\
    \            return d_a!\n        case .doubleValue(let b):\n            let d_a\
    \ = Double(a.replacingOccurrences(of: \",\", with: \".\"))\n            return\
    \ d_a! > b ? d_a! : b\n        case .stringValue(let b):\n            let d_a\
    \ = Double(a.replacingOccurrences(of: \",\", with: \".\"))\n            let d_b\
    \ = Double(b.replacingOccurrences(of: \",\", with: \".\"))\n            return\
    \ d_a! > d_b! ? d_a! : d_b!\n        }\n    }\n}\n\n\nfunc ==(left: [(Int, Int)],\
    \ right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n       \
    \ return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r\
    \ {\n            return false\n        }\n    }\n    return true\n}\n        \
    \    \nassert(compare_one(a: .intValue(1), b: .intValue(2)) == .intValue(2))\n\
    assert(compare_one(a: .intValue(1), b: .doubleValue(2.5)) == .doubleValue(2.5))\n\
    assert(compare_one(a: .intValue(2), b: .intValue(3)) == .intValue(3))\nassert(compare_one(a:\
    \ .intValue(5), b: .intValue(6)) == .intValue(6))\nassert(compare_one(a: .intValue(1),\
    \ b: .stringValue(\"2,3\")) == .stringValue(\"2,3\"))\nassert(compare_one(a: .stringValue(\"\
    5,1\"), b: .stringValue(\"6\")) == .stringValue(\"6\"))\nassert(compare_one(a:\
    \ .stringValue(\"1\"), b: .stringValue(\"2\")) == .stringValue(\"2\"))\nassert(compare_one(a:\
    \ .stringValue(\"1\"), b: .intValue(1)) == nil)"
  status: SyntaxError
  stderr: "/tmp/tmp8uf9s5ep.swift:26:26: error: cannot convert return expression of\
    \ type 'Int' to return type 'Value?'\n            return a > b ? a : b\n     \
    \              ~~~~~~^~~~~~~\n/tmp/tmp8uf9s5ep.swift:28:20: error: cannot convert\
    \ return expression of type 'Double' to return type 'Value?'\n            return\
    \ b\n                   ^\n/tmp/tmp8uf9s5ep.swift:30:32: error: value of type\
    \ 'String' has no member 'replacingOccurrences'\n            let d_b = Double(b.replacingOccurrences(of:\
    \ \",\", with: \".\"))\n                             ~ ^~~~~~~~~~~~~~~~~~~~\n\
    /tmp/tmp8uf9s5ep.swift:36:20: error: cannot convert return expression of type\
    \ 'Double' to return type 'Value?'\n            return a\n                   ^\n\
    /tmp/tmp8uf9s5ep.swift:38:26: error: cannot convert return expression of type\
    \ 'Double' to return type 'Value?'\n            return a > b ? a : b\n       \
    \            ~~~~~~^~~~~~~\n/tmp/tmp8uf9s5ep.swift:40:32: error: value of type\
    \ 'String' has no member 'replacingOccurrences'\n            let d_b = Double(b.replacingOccurrences(of:\
    \ \",\", with: \".\"))\n                             ~ ^~~~~~~~~~~~~~~~~~~~\n\
    /tmp/tmp8uf9s5ep.swift:41:29: error: cannot convert return expression of type\
    \ 'Double' to return type 'Value?'\n            return a > d_b! ? a : d_b!\n \
    \                  ~~~~~~~~~^~~~~~~~~~\n/tmp/tmp8uf9s5ep.swift:46:32: error: value\
    \ of type 'String' has no member 'replacingOccurrences'\n            let d_a =\
    \ Double(a.replacingOccurrences(of: \",\", with: \".\"))\n                   \
    \          ~ ^~~~~~~~~~~~~~~~~~~~\n/tmp/tmp8uf9s5ep.swift:49:32: error: value\
    \ of type 'String' has no member 'replacingOccurrences'\n            let d_a =\
    \ Double(a.replacingOccurrences(of: \",\", with: \".\"))\n                   \
    \          ~ ^~~~~~~~~~~~~~~~~~~~\n/tmp/tmp8uf9s5ep.swift:50:29: error: cannot\
    \ convert return expression of type 'Double' to return type 'Value?'\n       \
    \     return d_a! > b ? d_a! : b\n                   ~~~~~~~~~^~~~~~~~~~\n/tmp/tmp8uf9s5ep.swift:52:32:\
    \ error: value of type 'String' has no member 'replacingOccurrences'\n       \
    \     let d_a = Double"
  stdout: ''
  timestamp: 1660013179
- exit_code: 1
  program: "\nenum Value: Equatable, Hashable {\n    case intValue(Int)\n    case\
    \ doubleValue(Double)\n    case stringValue(String)\n}\n\n            \n/// Create\
    \ a function that takes integers, floats, or strings representing\n/// real numbers,\
    \ and returns the larger variable in its given variable type.\n/// Return nil\
    \ if the values are equal.\n/// Note: If a real number is represented as a string,\
    \ the floating point might be . or ,\n/// >>> compare_one(a: .intValue(1), b:\
    \ .doubleValue(2.5))\n/// .doubleValue(2.5)\n/// >>> compare_one(a: .intValue(1),\
    \ b: .stringValue(\"2,3\"))\n/// .stringValue(\"2,3\")\n/// >>> compare_one(a:\
    \ .stringValue(\"5,1\"), b: .stringValue(\"6\"))\n/// .stringValue(\"6\")\n///\
    \ >>> compare_one(a: .stringValue(\"1\"), b: .intValue(1))\n/// nil\nfunc compare_one(a:\
    \ Value, b: Value) -> Value? {\n    guard let a = valueToNumber(a), let b = valueToNumber(b)\
    \ else { return nil }\n    return a > b ? a : b\n}\n\n\nfunc ==(left: [(Int, Int)],\
    \ right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n       \
    \ return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r\
    \ {\n            return false\n        }\n    }\n    return true\n}\n        \
    \    \nassert(compare_one(a: .intValue(1), b: .intValue(2)) == .intValue(2))\n\
    assert(compare_one(a: .intValue(1), b: .doubleValue(2.5)) == .doubleValue(2.5))\n\
    assert(compare_one(a: .intValue(2), b: .intValue(3)) == .intValue(3))\nassert(compare_one(a:\
    \ .intValue(5), b: .intValue(6)) == .intValue(6))\nassert(compare_one(a: .intValue(1),\
    \ b: .stringValue(\"2,3\")) == .stringValue(\"2,3\"))\nassert(compare_one(a: .stringValue(\"\
    5,1\"), b: .stringValue(\"6\")) == .stringValue(\"6\"))\nassert(compare_one(a:\
    \ .stringValue(\"1\"), b: .stringValue(\"2\")) == .stringValue(\"2\"))\nassert(compare_one(a:\
    \ .stringValue(\"1\"), b: .intValue(1)) == nil)"
  status: SyntaxError
  stderr: "/tmp/tmpxb86rvjl.swift:22:19: error: cannot find 'valueToNumber' in scope\n\
    \    guard let a = valueToNumber(a), let b = valueToNumber(b) else { return nil\
    \ }\n                  ^~~~~~~~~~~~~\n/tmp/tmpxb86rvjl.swift:22:45: error: cannot\
    \ find 'valueToNumber' in scope\n    guard let a = valueToNumber(a), let b = valueToNumber(b)\
    \ else { return nil }\n                                            ^~~~~~~~~~~~~\n"
  stdout: ''
  timestamp: 1660013179
- exit_code: 1
  program: "\nenum Value: Equatable, Hashable {\n    case intValue(Int)\n    case\
    \ doubleValue(Double)\n    case stringValue(String)\n}\n\n            \n/// Create\
    \ a function that takes integers, floats, or strings representing\n/// real numbers,\
    \ and returns the larger variable in its given variable type.\n/// Return nil\
    \ if the values are equal.\n/// Note: If a real number is represented as a string,\
    \ the floating point might be . or ,\n/// >>> compare_one(a: .intValue(1), b:\
    \ .doubleValue(2.5))\n/// .doubleValue(2.5)\n/// >>> compare_one(a: .intValue(1),\
    \ b: .stringValue(\"2,3\"))\n/// .stringValue(\"2,3\")\n/// >>> compare_one(a:\
    \ .stringValue(\"5,1\"), b: .stringValue(\"6\"))\n/// .stringValue(\"6\")\n///\
    \ >>> compare_one(a: .stringValue(\"1\"), b: .intValue(1))\n/// nil\nfunc compare_one(a:\
    \ Value, b: Value) -> Value? {\n    switch a {\n    case .intValue(let a_value)\
    \ where a_value > (b as! Int):\n        return a\n    case .doubleValue(let a_value)\
    \ where a_value > (b as! Double):\n        return a\n    case .stringValue(let\
    \ a_value) where Double(a_value) > (b as! Double):\n        return a\n    default:\n\
    \        return nil\n    }\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(compare_one(a:\
    \ .intValue(1), b: .intValue(2)) == .intValue(2))\nassert(compare_one(a: .intValue(1),\
    \ b: .doubleValue(2.5)) == .doubleValue(2.5))\nassert(compare_one(a: .intValue(2),\
    \ b: .intValue(3)) == .intValue(3))\nassert(compare_one(a: .intValue(5), b: .intValue(6))\
    \ == .intValue(6))\nassert(compare_one(a: .intValue(1), b: .stringValue(\"2,3\"\
    )) == .stringValue(\"2,3\"))\nassert(compare_one(a: .stringValue(\"5,1\"), b:\
    \ .stringValue(\"6\")) == .stringValue(\"6\"))\nassert(compare_one(a: .stringValue(\"\
    1\"), b: .stringValue(\"2\")) == .stringValue(\"2\"))\nassert(compare_one(a: .stringValue(\"\
    1\"), b: .intValue(1)) == nil)"
  status: SyntaxError
  stderr: "/tmp/tmpbh5ndnzc.swift:23:52: warning: cast from 'Value' to unrelated type\
    \ 'Int' always fails\n    case .intValue(let a_value) where a_value > (b as! Int):\n\
    \                                                 ~ ^   ~~~\n/tmp/tmpbh5ndnzc.swift:25:55:\
    \ warning: cast from 'Value' to unrelated type 'Double' always fails\n    case\
    \ .doubleValue(let a_value) where a_value > (b as! Double):\n                \
    \                                    ~ ^   ~~~~~~\n/tmp/tmpbh5ndnzc.swift:27:42:\
    \ error: value of optional type 'Double?' must be unwrapped to a value of type\
    \ 'Double'\n    case .stringValue(let a_value) where Double(a_value) > (b as!\
    \ Double):\n                                         ^\n/tmp/tmpbh5ndnzc.swift:27:42:\
    \ note: coalesce using '??' to provide a default when the optional value contains\
    \ 'nil'\n    case .stringValue(let a_value) where Double(a_value) > (b as! Double):\n\
    \                                         ^\n                                \
    \                         ?? <#default value#>\n/tmp/tmpbh5ndnzc.swift:27:42:\
    \ note: force-unwrap using '!' to abort execution if the optional value contains\
    \ 'nil'\n    case .stringValue(let a_value) where Double(a_value) > (b as! Double):\n\
    \                                         ^\n                                \
    \                        !\n/tmp/tmpbh5ndnzc.swift:27:63: warning: cast from 'Value'\
    \ to unrelated type 'Double' always fails\n    case .stringValue(let a_value)\
    \ where Double(a_value) > (b as! Double):\n                                  \
    \                          ~ ^   ~~~~~~\n"
  stdout: ''
  timestamp: 1660013179
- exit_code: 1
  program: "\nenum Value: Equatable, Hashable {\n    case intValue(Int)\n    case\
    \ doubleValue(Double)\n    case stringValue(String)\n}\n\n            \n/// Create\
    \ a function that takes integers, floats, or strings representing\n/// real numbers,\
    \ and returns the larger variable in its given variable type.\n/// Return nil\
    \ if the values are equal.\n/// Note: If a real number is represented as a string,\
    \ the floating point might be . or ,\n/// >>> compare_one(a: .intValue(1), b:\
    \ .doubleValue(2.5))\n/// .doubleValue(2.5)\n/// >>> compare_one(a: .intValue(1),\
    \ b: .stringValue(\"2,3\"))\n/// .stringValue(\"2,3\")\n/// >>> compare_one(a:\
    \ .stringValue(\"5,1\"), b: .stringValue(\"6\"))\n/// .stringValue(\"6\")\n///\
    \ >>> compare_one(a: .stringValue(\"1\"), b: .intValue(1))\n/// nil\nfunc compare_one(a:\
    \ Value, b: Value) -> Value? {\n    switch (a, b) {\n    case let (.intValue(a),\
    \ .intValue(b)) where a != b:\n        return a > b ? a : b\n    case let (.doubleValue(a),\
    \ .doubleValue(b)) where a != b:\n        return a > b ? a : b\n    case let (.stringValue(a),\
    \ .stringValue(b)) where a != b:\n        return a > b ? a : b\n    default:\n\
    \        return nil\n    }\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(compare_one(a:\
    \ .intValue(1), b: .intValue(2)) == .intValue(2))\nassert(compare_one(a: .intValue(1),\
    \ b: .doubleValue(2.5)) == .doubleValue(2.5))\nassert(compare_one(a: .intValue(2),\
    \ b: .intValue(3)) == .intValue(3))\nassert(compare_one(a: .intValue(5), b: .intValue(6))\
    \ == .intValue(6))\nassert(compare_one(a: .intValue(1), b: .stringValue(\"2,3\"\
    )) == .stringValue(\"2,3\"))\nassert(compare_one(a: .stringValue(\"5,1\"), b:\
    \ .stringValue(\"6\")) == .stringValue(\"6\"))\nassert(compare_one(a: .stringValue(\"\
    1\"), b: .stringValue(\"2\")) == .stringValue(\"2\"))\nassert(compare_one(a: .stringValue(\"\
    1\"), b: .intValue(1)) == nil)"
  status: SyntaxError
  stderr: "/tmp/tmpe9rc17ll.swift:24:22: error: cannot convert return expression of\
    \ type 'Int' to return type 'Value?'\n        return a > b ? a : b\n         \
    \      ~~~~~~^~~~~~~\n/tmp/tmpe9rc17ll.swift:26:22: error: cannot convert return\
    \ expression of type 'Double' to return type 'Value?'\n        return a > b ?\
    \ a : b\n               ~~~~~~^~~~~~~\n/tmp/tmpe9rc17ll.swift:28:22: error: cannot\
    \ convert return expression of type 'String' to return type 'Value?'\n       \
    \ return a > b ? a : b\n               ~~~~~~^~~~~~~\n"
  stdout: ''
  timestamp: 1660013179
- exit_code: 1
  program: "\nenum Value: Equatable, Hashable {\n    case intValue(Int)\n    case\
    \ doubleValue(Double)\n    case stringValue(String)\n}\n\n            \n/// Create\
    \ a function that takes integers, floats, or strings representing\n/// real numbers,\
    \ and returns the larger variable in its given variable type.\n/// Return nil\
    \ if the values are equal.\n/// Note: If a real number is represented as a string,\
    \ the floating point might be . or ,\n/// >>> compare_one(a: .intValue(1), b:\
    \ .doubleValue(2.5))\n/// .doubleValue(2.5)\n/// >>> compare_one(a: .intValue(1),\
    \ b: .stringValue(\"2,3\"))\n/// .stringValue(\"2,3\")\n/// >>> compare_one(a:\
    \ .stringValue(\"5,1\"), b: .stringValue(\"6\"))\n/// .stringValue(\"6\")\n///\
    \ >>> compare_one(a: .stringValue(\"1\"), b: .intValue(1))\n/// nil\nfunc compare_one(a:\
    \ Value, b: Value) -> Value? {\n    switch (a, b) {\n    case (.intValue(let a1),\
    \ .intValue(let b1)) where a1 < b1:\n        return b\n    case (.intValue(let\
    \ a1), .intValue(let b1)) where a1 > b1:\n        return a\n    case (.intValue(let\
    \ a1), .doubleValue(let b1)) where Double(a1) < b1:\n        return b\n    case\
    \ (.intValue(let a1), .doubleValue(let b1)) where Double(a1) > b1:\n        return\
    \ a\n    case (.intValue(let a1), .stringValue(let b1)) where Double(a1) < Double(b1.replacingOccurrences(of:\
    \ \",\", with: \".\"))!:\n        return b\n    case (.intValue(let a1), .stringValue(let\
    \ b1)) where Double(a1) > Double(b1.replacingOccurrences(of: \",\", with: \".\"\
    ))!:\n        return a\n    case (.doubleValue(let a1), .intValue(let b1)) where\
    \ a1 < Double(b1):\n        return b\n    case (.doubleValue(let a1), .intValue(let\
    \ b1)) where a1 > Double(b1):\n        return a\n    case (.doubleValue(let a1),\
    \ .doubleValue(let b1)) where a1 < b1:\n        return b\n    case (.doubleValue(let\
    \ a1), .doubleValue(let b1)) where a1 > b1:\n        return a\n    case (.doubleValue(let\
    \ a1), .stringValue(let b1)) where a1 < Double(b1.replacingOccurrences(of: \"\
    ,\", with: \".\"))!:\n        return b\n    case (.doubleValue(let a1), .stringValue(let\
    \ b1)) where a1 > Double(b1.replacingOccurrences(of: \",\", with: \".\"))!:\n\
    \        return a\n    case (.stringValue(let a1), .intValue(let b1)) where Double(a1.replacingOccurrences(of:\
    \ \",\", with: \".\"))! < Double(b1):\n        return\n}\n\n\nfunc ==(left: [(Int,\
    \ Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n\
    \        return false\n    }\n    for (l, r) in zip(left, right) {\n        if\
    \ l != r {\n            return false\n        }\n    }\n    return true\n}\n \
    \           \nassert(compare_one(a: .intValue(1), b: .intValue(2)) == .intValue(2))\n\
    assert(compare_one(a: .intValue(1), b: .doubleValue(2.5)) == .doubleValue(2.5))\n\
    assert(compare_one(a: .intValue(2), b: .intValue(3)) == .intValue(3))\nassert(compare_one(a:\
    \ .intValue(5), b: .intValue(6)) == .intValue(6))\nassert(compare_one(a: .intValue(1),\
    \ b: .stringValue(\"2,3\")) == .stringValue(\"2,3\"))\nassert(compare_one(a: .stringValue(\"\
    5,1\"), b: .stringValue(\"6\")) == .stringValue(\"6\"))\nassert(compare_one(a:\
    \ .stringValue(\"1\"), b: .stringValue(\"2\")) == .stringValue(\"2\"))\nassert(compare_one(a:\
    \ .stringValue(\"1\"), b: .intValue(1)) == nil)"
  status: SyntaxError
  stderr: "/tmp/tmpj8ahwmq0.swift:71:66: error: expected '}' at end of brace statement\n\
    assert(compare_one(a: .stringValue(\"1\"), b: .intValue(1)) == nil)\n        \
    \                                                         ^\n/tmp/tmpj8ahwmq0.swift:21:48:\
    \ note: to match this opening '{'\nfunc compare_one(a: Value, b: Value) -> Value?\
    \ {\n                                               ^\n/tmp/tmpj8ahwmq0.swift:31:81:\
    \ error: value of type 'String' has no member 'replacingOccurrences'\n    case\
    \ (.intValue(let a1), .stringValue(let b1)) where Double(a1) < Double(b1.replacingOccurrences(of:\
    \ \",\", with: \".\"))!:\n                                                   \
    \                          ~~ ^~~~~~~~~~~~~~~~~~~~\n/tmp/tmpj8ahwmq0.swift:33:81:\
    \ error: value of type 'String' has no member 'replacingOccurrences'\n    case\
    \ (.intValue(let a1), .stringValue(let b1)) where Double(a1) > Double(b1.replacingOccurrences(of:\
    \ \",\", with: \".\"))!:\n                                                   \
    \                          ~~ ^~~~~~~~~~~~~~~~~~~~\n/tmp/tmpj8ahwmq0.swift:43:76:\
    \ error: value of type 'String' has no member 'replacingOccurrences'\n    case\
    \ (.doubleValue(let a1), .stringValue(let b1)) where a1 < Double(b1.replacingOccurrences(of:\
    \ \",\", with: \".\"))!:\n                                                   \
    \                     ~~ ^~~~~~~~~~~~~~~~~~~~\n/tmp/tmpj8ahwmq0.swift:45:76: error:\
    \ value of type 'String' has no member 'replacingOccurrences'\n    case (.doubleValue(let\
    \ a1), .stringValue(let b1)) where a1 > Double(b1.replacingOccurrences(of: \"\
    ,\", with: \".\"))!:\n                                                       \
    \                 ~~ ^~~~~~~~~~~~~~~~~~~~\n/tmp/tmpj8ahwmq0.swift:47:68: error:\
    \ value of type 'String' has no member 'replacingOccurrences'\n    case (.stringValue(let\
    \ a1), .intValue(let b1)) where Double(a1.replacingOccurrences(of: \",\", with:\
    \ \".\"))! < Double(b1):\n                                                   \
    \             ~~ ^~~~~~~~~~~~~~~~~~~~\n/tmp/tmpj8ahwmq0.swift:48:9: error: non-void\
    \ function should return a value\n        return\n        ^\n/"
  stdout: ''
  timestamp: 1660013179
- exit_code: 1
  program: "\nenum Value: Equatable, Hashable {\n    case intValue(Int)\n    case\
    \ doubleValue(Double)\n    case stringValue(String)\n}\n\n            \n/// Create\
    \ a function that takes integers, floats, or strings representing\n/// real numbers,\
    \ and returns the larger variable in its given variable type.\n/// Return nil\
    \ if the values are equal.\n/// Note: If a real number is represented as a string,\
    \ the floating point might be . or ,\n/// >>> compare_one(a: .intValue(1), b:\
    \ .doubleValue(2.5))\n/// .doubleValue(2.5)\n/// >>> compare_one(a: .intValue(1),\
    \ b: .stringValue(\"2,3\"))\n/// .stringValue(\"2,3\")\n/// >>> compare_one(a:\
    \ .stringValue(\"5,1\"), b: .stringValue(\"6\"))\n/// .stringValue(\"6\")\n///\
    \ >>> compare_one(a: .stringValue(\"1\"), b: .intValue(1))\n/// nil\nfunc compare_one(a:\
    \ Value, b: Value) -> Value? {\n    if a == b {\n        return nil\n    } else\
    \ if case .doubleValue(let x) = a, case .intValue(let y) = b {\n        return\
    \ x > Double(y) ? a : b\n    } else if case .intValue(let x) = a, case .doubleValue(let\
    \ y) = b {\n        return Double(x) > y ? a : b\n    } else if case .stringValue(let\
    \ x) = a, case .intValue(let y) = b {\n        return Double(x) > Double(y) ?\
    \ a : b\n    } else if case .intValue(let x) = a, case .stringValue(let y) = b\
    \ {\n        return Double(x) > Double(y) ? a : b\n    } else if case .stringValue(let\
    \ x) = a, case .doubleValue(let y) = b {\n        return Double(x) > y ? a : b\n\
    \    } else if case .doubleValue(let x) = a, case .stringValue(let y) = b {\n\
    \        return x > Double(y) ? a : b\n    } else if case .stringValue(let x)\
    \ = a, case .stringValue(let y) = b {\n        return Double(x) > Double(y) ?\
    \ a : b\n    } else {\n        fatalError(\"Cannot compare \\(a) and \\(b)\")\n\
    \    }\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n  \
    \  if left.count != right.count {\n        return false\n    }\n    for (l, r)\
    \ in zip(left, right) {\n        if l != r {\n            return false\n     \
    \   }\n    }\n    return true\n}\n            \nassert(compare_one(a: .intValue(1),\
    \ b: .intValue(2)) == .intValue(2))\nassert(compare_one(a: .intValue(1), b: .doubleValue(2.5))\
    \ == .doubleValue(2.5))\nassert(compare_one(a: .intValue(2), b: .intValue(3))\
    \ == .intValue(3))\nassert(compare_one(a: .intValue(5), b: .intValue(6)) == .intValue(6))\n\
    assert(compare_one(a: .intValue(1), b: .stringValue(\"2,3\")) == .stringValue(\"\
    2,3\"))\nassert(compare_one(a: .stringValue(\"5,1\"), b: .stringValue(\"6\"))\
    \ == .stringValue(\"6\"))\nassert(compare_one(a: .stringValue(\"1\"), b: .stringValue(\"\
    2\")) == .stringValue(\"2\"))\nassert(compare_one(a: .stringValue(\"1\"), b: .intValue(1))\
    \ == nil)"
  status: SyntaxError
  stderr: "/tmp/tmpq5mr6fyj.swift:29:16: error: value of optional type 'Double?' must\
    \ be unwrapped to a value of type 'Double'\n        return Double(x) > Double(y)\
    \ ? a : b\n               ^\n/tmp/tmpq5mr6fyj.swift:29:16: note: coalesce using\
    \ '??' to provide a default when the optional value contains 'nil'\n        return\
    \ Double(x) > Double(y) ? a : b\n               ^\n                         ??\
    \ <#default value#>\n/tmp/tmpq5mr6fyj.swift:29:16: note: force-unwrap using '!'\
    \ to abort execution if the optional value contains 'nil'\n        return Double(x)\
    \ > Double(y) ? a : b\n               ^\n                        !\n/tmp/tmpq5mr6fyj.swift:31:28:\
    \ error: value of optional type 'Double?' must be unwrapped to a value of type\
    \ 'Double'\n        return Double(x) > Double(y) ? a : b\n                   \
    \        ^\n/tmp/tmpq5mr6fyj.swift:31:28: note: coalesce using '??' to provide\
    \ a default when the optional value contains 'nil'\n        return Double(x) >\
    \ Double(y) ? a : b\n                           ^\n                          \
    \           ?? <#default value#>\n/tmp/tmpq5mr6fyj.swift:31:28: note: force-unwrap\
    \ using '!' to abort execution if the optional value contains 'nil'\n        return\
    \ Double(x) > Double(y) ? a : b\n                           ^\n              \
    \                      !\n/tmp/tmpq5mr6fyj.swift:33:16: error: value of optional\
    \ type 'Double?' must be unwrapped to a value of type 'Double'\n        return\
    \ Double(x) > y ? a : b\n               ^\n/tmp/tmpq5mr6fyj.swift:33:16: note:\
    \ coalesce using '??' to provide a default when the optional value contains 'nil'\n\
    \        return Double(x) > y ? a : b\n               ^\n                    \
    \     ?? <#default value#>\n/tmp/tmpq5mr6fyj.swift:33:16: note: force-unwrap using\
    \ '!' to abort execution if the optional value contains 'nil'\n        return\
    \ Double(x) > y ? a : b\n               ^\n                        !\n/tmp/tmpq5mr6fyj.swift:35:20:\
    \ error: value of optional type 'Double?' must be unwrapped to a value of type\
    \ 'Double'\n        return x > Double(y) ? a : b\n                   ^\n/tmp/tmpq5mr6fyj.swift:"
  stdout: ''
  timestamp: 1660013180
- exit_code: 1
  program: "\nenum Value: Equatable, Hashable {\n    case intValue(Int)\n    case\
    \ doubleValue(Double)\n    case stringValue(String)\n}\n\n            \n/// Create\
    \ a function that takes integers, floats, or strings representing\n/// real numbers,\
    \ and returns the larger variable in its given variable type.\n/// Return nil\
    \ if the values are equal.\n/// Note: If a real number is represented as a string,\
    \ the floating point might be . or ,\n/// >>> compare_one(a: .intValue(1), b:\
    \ .doubleValue(2.5))\n/// .doubleValue(2.5)\n/// >>> compare_one(a: .intValue(1),\
    \ b: .stringValue(\"2,3\"))\n/// .stringValue(\"2,3\")\n/// >>> compare_one(a:\
    \ .stringValue(\"5,1\"), b: .stringValue(\"6\"))\n/// .stringValue(\"6\")\n///\
    \ >>> compare_one(a: .stringValue(\"1\"), b: .intValue(1))\n/// nil\nfunc compare_one(a:\
    \ Value, b: Value) -> Value? {\n    switch (a, b) {\n    case (.intValue(let a),\
    \ .intValue(let b)):\n        return a >= b ? a : b\n    case (.doubleValue(let\
    \ a), .doubleValue(let b)):\n        return a >= b ? a : b\n    case (.stringValue(let\
    \ a), .stringValue(let b)):\n        return a >= b ? a : b\n    case (.intValue(let\
    \ a), .doubleValue(let b)):\n        return a >= b ? a : b\n    case (.intValue(let\
    \ a), .stringValue(let b)):\n        return a >= b ? a : b\n    case (.doubleValue(let\
    \ a), .intValue(let b)):\n        return a >= b ? a : b\n    case (.doubleValue(let\
    \ a), .stringValue(let b)):\n        return a >= b ? a : b\n    case (.stringValue(let\
    \ a), .intValue(let b)):\n        return a >= b ? a : b\n    case (.stringValue(let\
    \ a), .doubleValue(let b)):\n        return a >= b ? a : b\n    default:\n   \
    \     return nil\n    }\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(compare_one(a:\
    \ .intValue(1), b: .intValue(2)) == .intValue(2))\nassert(compare_one(a: .intValue(1),\
    \ b: .doubleValue(2.5)) == .doubleValue(2.5))\nassert(compare_one(a: .intValue(2),\
    \ b: .intValue(3)) == .intValue(3))\nassert(compare_one(a: .intValue(5), b: .intValue(6))\
    \ == .intValue(6))\nassert(compare_one(a: .intValue(1), b: .stringValue(\"2,3\"\
    )) == .stringValue(\"2,3\"))\nassert(compare_one(a: .stringValue(\"5,1\"), b:\
    \ .stringValue(\"6\")) == .stringValue(\"6\"))\nassert(compare_one(a: .stringValue(\"\
    1\"), b: .stringValue(\"2\")) == .stringValue(\"2\"))\nassert(compare_one(a: .stringValue(\"\
    1\"), b: .intValue(1)) == nil)"
  status: SyntaxError
  stderr: "/tmp/tmpa4w3uz2b.swift:24:23: error: cannot convert return expression of\
    \ type 'Int' to return type 'Value?'\n        return a >= b ? a : b\n        \
    \       ~~~~~~~^~~~~~~\n/tmp/tmpa4w3uz2b.swift:26:23: error: cannot convert return\
    \ expression of type 'Double' to return type 'Value?'\n        return a >= b ?\
    \ a : b\n               ~~~~~~~^~~~~~~\n/tmp/tmpa4w3uz2b.swift:28:23: error: cannot\
    \ convert return expression of type 'String' to return type 'Value?'\n       \
    \ return a >= b ? a : b\n               ~~~~~~~^~~~~~~\n/tmp/tmpa4w3uz2b.swift:30:21:\
    \ error: cannot convert value of type 'Double' to expected argument type 'Int'\n\
    \        return a >= b ? a : b\n                    ^\n                    Int(\
    \ )\n/tmp/tmpa4w3uz2b.swift:30:23: error: cannot convert return expression of\
    \ type 'Int' to return type 'Value?'\n        return a >= b ? a : b\n        \
    \       ~~~~~~~^~~~~~~\n/tmp/tmpa4w3uz2b.swift:32:21: error: cannot convert value\
    \ of type 'String' to expected argument type 'Int'\n        return a >= b ? a\
    \ : b\n                    ^\n/tmp/tmpa4w3uz2b.swift:32:23: error: cannot convert\
    \ return expression of type 'Int' to return type 'Value?'\n        return a >=\
    \ b ? a : b\n               ~~~~~~~^~~~~~~\n/tmp/tmpa4w3uz2b.swift:34:16: error:\
    \ cannot convert value of type 'Double' to expected argument type 'Int'\n    \
    \    return a >= b ? a : b\n               ^\n               Int( )\n/tmp/tmpa4w3uz2b.swift:34:23:\
    \ error: cannot convert return expression of type 'Double' to return type 'Value?'\n\
    \        return a >= b ? a : b\n               ~~~~~~~^~~~~~~\n/tmp/tmpa4w3uz2b.swift:36:18:\
    \ error: binary operator '>=' cannot be applied to operands of type 'Double' and\
    \ 'String'\n        return a >= b ? a : b\n               ~ ^  ~\n/tmp/tmpa4w3uz2b.swift:36:23:\
    \ error: cannot convert return expression of type 'Double' to return type 'Value?'\n\
    \        return a >= b ? a : b\n               ~~~~~~~^~~~~~~\n/tmp/tmpa4w3uz2b.swift:38:16:\
    \ error: cannot convert value of type 'String' to expected argument type 'Int'\n\
    \        return a >= b ? a : b\n               ^\n/tmp/tmpa4w3uz2"
  stdout: ''
  timestamp: 1660013180
- exit_code: -4
  program: "\nenum Value: Equatable, Hashable {\n    case intValue(Int)\n    case\
    \ doubleValue(Double)\n    case stringValue(String)\n}\n\n            \n/// Create\
    \ a function that takes integers, floats, or strings representing\n/// real numbers,\
    \ and returns the larger variable in its given variable type.\n/// Return nil\
    \ if the values are equal.\n/// Note: If a real number is represented as a string,\
    \ the floating point might be . or ,\n/// >>> compare_one(a: .intValue(1), b:\
    \ .doubleValue(2.5))\n/// .doubleValue(2.5)\n/// >>> compare_one(a: .intValue(1),\
    \ b: .stringValue(\"2,3\"))\n/// .stringValue(\"2,3\")\n/// >>> compare_one(a:\
    \ .stringValue(\"5,1\"), b: .stringValue(\"6\"))\n/// .stringValue(\"6\")\n///\
    \ >>> compare_one(a: .stringValue(\"1\"), b: .intValue(1))\n/// nil\nfunc compare_one(a:\
    \ Value, b: Value) -> Value? {\n    return nil\n}\n\n\nfunc ==(left: [(Int, Int)],\
    \ right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n       \
    \ return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r\
    \ {\n            return false\n        }\n    }\n    return true\n}\n        \
    \    \nassert(compare_one(a: .intValue(1), b: .intValue(2)) == .intValue(2))\n\
    assert(compare_one(a: .intValue(1), b: .doubleValue(2.5)) == .doubleValue(2.5))\n\
    assert(compare_one(a: .intValue(2), b: .intValue(3)) == .intValue(3))\nassert(compare_one(a:\
    \ .intValue(5), b: .intValue(6)) == .intValue(6))\nassert(compare_one(a: .intValue(1),\
    \ b: .stringValue(\"2,3\")) == .stringValue(\"2,3\"))\nassert(compare_one(a: .stringValue(\"\
    5,1\"), b: .stringValue(\"6\")) == .stringValue(\"6\"))\nassert(compare_one(a:\
    \ .stringValue(\"1\"), b: .stringValue(\"2\")) == .stringValue(\"2\"))\nassert(compare_one(a:\
    \ .stringValue(\"1\"), b: .intValue(1)) == nil)"
  status: Exception
  stderr: 'tmpllswmh2d/tmpllswmh2d.swift:38: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b05c2ae8c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b05c27dfb6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b05c27df988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b05c27de7b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpllswmh2d                        0x000055f806e32a56 <unavailable> + 6742

    5    libc.so.6                          0x00002b05c2cd4460 __libc_start_main +
    245

    6    tmpllswmh2d                        0x000055f806e32499 <unavailable> + 5273

    '
  stdout: ''
  timestamp: 1660013179
- exit_code: 1
  program: "\nenum Value: Equatable, Hashable {\n    case intValue(Int)\n    case\
    \ doubleValue(Double)\n    case stringValue(String)\n}\n\n            \n/// Create\
    \ a function that takes integers, floats, or strings representing\n/// real numbers,\
    \ and returns the larger variable in its given variable type.\n/// Return nil\
    \ if the values are equal.\n/// Note: If a real number is represented as a string,\
    \ the floating point might be . or ,\n/// >>> compare_one(a: .intValue(1), b:\
    \ .doubleValue(2.5))\n/// .doubleValue(2.5)\n/// >>> compare_one(a: .intValue(1),\
    \ b: .stringValue(\"2,3\"))\n/// .stringValue(\"2,3\")\n/// >>> compare_one(a:\
    \ .stringValue(\"5,1\"), b: .stringValue(\"6\"))\n/// .stringValue(\"6\")\n///\
    \ >>> compare_one(a: .stringValue(\"1\"), b: .intValue(1))\n/// nil\nfunc compare_one(a:\
    \ Value, b: Value) -> Value? {\n    switch (a, b) {\n    case (.intValue(let aValue),\
    \ .intValue(let bValue)):\n        return (aValue > bValue) ? a : b\n    case\
    \ (.doubleValue(let aValue), .doubleValue(let bValue)):\n        return (aValue\
    \ > bValue) ? a : b\n    case (.stringValue(let aValue), .stringValue(let bValue)):\n\
    \        return (Double(aValue) > Double(bValue)) ? a : b\n    case (.intValue(let\
    \ aValue), .doubleValue(let bValue)):\n        return (Double(aValue) > bValue)\
    \ ? a : b\n    case (.intValue(let aValue), .stringValue(let bValue)):\n     \
    \   return (Double(aValue) > Double(bValue)) ? a : b\n    case (.doubleValue(let\
    \ aValue), .intValue(let bValue)):\n        return (aValue > Double(bValue)) ?\
    \ a : b\n    case (.doubleValue(let aValue), .stringValue(let bValue)):\n    \
    \    return (aValue > Double(bValue)) ? a : b\n    case (.stringValue(let aValue),\
    \ .intValue(let bValue)):\n        return (Double(aValue) > Double(bValue)) ?\
    \ a : b\n    case (.stringValue(let aValue), .doubleValue(let bValue)):\n    \
    \    return (Double(aValue) > bValue) ? a : b\n    default:\n        return nil\n\
    \    }\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n  \
    \  if left.count != right.count {\n        return false\n    }\n    for (l, r)\
    \ in zip(left, right) {\n        if l != r {\n            return false\n     \
    \   }\n    }\n    return true\n}\n            \nassert(compare_one(a: .intValue(1),\
    \ b: .intValue(2)) == .intValue(2))\nassert(compare_one(a: .intValue(1), b: .doubleValue(2.5))\
    \ == .doubleValue(2.5))\nassert(compare_one(a: .intValue(2), b: .intValue(3))\
    \ == .intValue(3))\nassert(compare_one(a: .intValue(5), b: .intValue(6)) == .intValue(6))\n\
    assert(compare_one(a: .intValue(1), b: .stringValue(\"2,3\")) == .stringValue(\"\
    2,3\"))\nassert(compare_one(a: .stringValue(\"5,1\"), b: .stringValue(\"6\"))\
    \ == .stringValue(\"6\"))\nassert(compare_one(a: .stringValue(\"1\"), b: .stringValue(\"\
    2\")) == .stringValue(\"2\"))\nassert(compare_one(a: .stringValue(\"1\"), b: .intValue(1))\
    \ == nil)"
  status: SyntaxError
  stderr: "/tmp/tmpydehvepj.swift:28:34: error: value of optional type 'Double?' must\
    \ be unwrapped to a value of type 'Double'\n        return (Double(aValue) > Double(bValue))\
    \ ? a : b\n                                 ^\n/tmp/tmpydehvepj.swift:28:34: note:\
    \ coalesce using '??' to provide a default when the optional value contains 'nil'\n\
    \        return (Double(aValue) > Double(bValue)) ? a : b\n                  \
    \               ^\n                                                ?? <#default\
    \ value#>\n/tmp/tmpydehvepj.swift:28:34: note: force-unwrap using '!' to abort\
    \ execution if the optional value contains 'nil'\n        return (Double(aValue)\
    \ > Double(bValue)) ? a : b\n                                 ^\n            \
    \                                   !\n/tmp/tmpydehvepj.swift:28:17: error: value\
    \ of optional type 'Double?' must be unwrapped to a value of type 'Double'\n \
    \       return (Double(aValue) > Double(bValue)) ? a : b\n                ^\n\
    /tmp/tmpydehvepj.swift:28:17: note: coalesce using '??' to provide a default when\
    \ the optional value contains 'nil'\n        return (Double(aValue) > Double(bValue))\
    \ ? a : b\n                ^\n                               ?? <#default value#>\n\
    /tmp/tmpydehvepj.swift:28:17: note: force-unwrap using '!' to abort execution\
    \ if the optional value contains 'nil'\n        return (Double(aValue) > Double(bValue))\
    \ ? a : b\n                ^\n                              !\n/tmp/tmpydehvepj.swift:32:34:\
    \ error: value of optional type 'Double?' must be unwrapped to a value of type\
    \ 'Double'\n        return (Double(aValue) > Double(bValue)) ? a : b\n       \
    \                          ^\n/tmp/tmpydehvepj.swift:32:34: note: coalesce using\
    \ '??' to provide a default when the optional value contains 'nil'\n        return\
    \ (Double(aValue) > Double(bValue)) ? a : b\n                                \
    \ ^\n                                                ?? <#default value#>\n/tmp/tmpydehvepj.swift:32:34:\
    \ note: force-unwrap using '!' to abort execution if the optional value contains\
    \ 'nil'\n        return (Double(aValue) > Double(bValue)) ? "
  stdout: ''
  timestamp: 1660013180
- exit_code: 1
  program: "\nenum Value: Equatable, Hashable {\n    case intValue(Int)\n    case\
    \ doubleValue(Double)\n    case stringValue(String)\n}\n\n            \n/// Create\
    \ a function that takes integers, floats, or strings representing\n/// real numbers,\
    \ and returns the larger variable in its given variable type.\n/// Return nil\
    \ if the values are equal.\n/// Note: If a real number is represented as a string,\
    \ the floating point might be . or ,\n/// >>> compare_one(a: .intValue(1), b:\
    \ .doubleValue(2.5))\n/// .doubleValue(2.5)\n/// >>> compare_one(a: .intValue(1),\
    \ b: .stringValue(\"2,3\"))\n/// .stringValue(\"2,3\")\n/// >>> compare_one(a:\
    \ .stringValue(\"5,1\"), b: .stringValue(\"6\"))\n/// .stringValue(\"6\")\n///\
    \ >>> compare_one(a: .stringValue(\"1\"), b: .intValue(1))\n/// nil\nfunc compare_one(a:\
    \ Value, b: Value) -> Value? {\n    switch (a, b) {\n    case (.intValue(let a),\
    \ .intValue(let b)):\n        return a > b ? a : b\n    case (.doubleValue(let\
    \ a), .doubleValue(let b)):\n        return a > b ? a : b\n    case (.stringValue(let\
    \ a), .stringValue(let b)):\n        return a > b ? a : b\n    default:\n    \
    \    return nil\n    }\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(compare_one(a:\
    \ .intValue(1), b: .intValue(2)) == .intValue(2))\nassert(compare_one(a: .intValue(1),\
    \ b: .doubleValue(2.5)) == .doubleValue(2.5))\nassert(compare_one(a: .intValue(2),\
    \ b: .intValue(3)) == .intValue(3))\nassert(compare_one(a: .intValue(5), b: .intValue(6))\
    \ == .intValue(6))\nassert(compare_one(a: .intValue(1), b: .stringValue(\"2,3\"\
    )) == .stringValue(\"2,3\"))\nassert(compare_one(a: .stringValue(\"5,1\"), b:\
    \ .stringValue(\"6\")) == .stringValue(\"6\"))\nassert(compare_one(a: .stringValue(\"\
    1\"), b: .stringValue(\"2\")) == .stringValue(\"2\"))\nassert(compare_one(a: .stringValue(\"\
    1\"), b: .intValue(1)) == nil)"
  status: SyntaxError
  stderr: "/tmp/tmp07haxekb.swift:24:22: error: cannot convert return expression of\
    \ type 'Int' to return type 'Value?'\n        return a > b ? a : b\n         \
    \      ~~~~~~^~~~~~~\n/tmp/tmp07haxekb.swift:26:22: error: cannot convert return\
    \ expression of type 'Double' to return type 'Value?'\n        return a > b ?\
    \ a : b\n               ~~~~~~^~~~~~~\n/tmp/tmp07haxekb.swift:28:22: error: cannot\
    \ convert return expression of type 'String' to return type 'Value?'\n       \
    \ return a > b ? a : b\n               ~~~~~~^~~~~~~\n"
  stdout: ''
  timestamp: 1660013180
- exit_code: 1
  program: "\nenum Value: Equatable, Hashable {\n    case intValue(Int)\n    case\
    \ doubleValue(Double)\n    case stringValue(String)\n}\n\n            \n/// Create\
    \ a function that takes integers, floats, or strings representing\n/// real numbers,\
    \ and returns the larger variable in its given variable type.\n/// Return nil\
    \ if the values are equal.\n/// Note: If a real number is represented as a string,\
    \ the floating point might be . or ,\n/// >>> compare_one(a: .intValue(1), b:\
    \ .doubleValue(2.5))\n/// .doubleValue(2.5)\n/// >>> compare_one(a: .intValue(1),\
    \ b: .stringValue(\"2,3\"))\n/// .stringValue(\"2,3\")\n/// >>> compare_one(a:\
    \ .stringValue(\"5,1\"), b: .stringValue(\"6\"))\n/// .stringValue(\"6\")\n///\
    \ >>> compare_one(a: .stringValue(\"1\"), b: .intValue(1))\n/// nil\nfunc compare_one(a:\
    \ Value, b: Value) -> Value? {\n    switch (a, b) {\n    case (.intValue(let a),\
    \ .intValue(let b)):\n        return a > b ? a : b\n    case (.doubleValue(let\
    \ a), .doubleValue(let b)):\n        return a > b ? a : b\n    case (.stringValue(let\
    \ a), .stringValue(let b)):\n        return a > b ? a : b\n    default:\n    \
    \    return nil\n    }\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(compare_one(a:\
    \ .intValue(1), b: .intValue(2)) == .intValue(2))\nassert(compare_one(a: .intValue(1),\
    \ b: .doubleValue(2.5)) == .doubleValue(2.5))\nassert(compare_one(a: .intValue(2),\
    \ b: .intValue(3)) == .intValue(3))\nassert(compare_one(a: .intValue(5), b: .intValue(6))\
    \ == .intValue(6))\nassert(compare_one(a: .intValue(1), b: .stringValue(\"2,3\"\
    )) == .stringValue(\"2,3\"))\nassert(compare_one(a: .stringValue(\"5,1\"), b:\
    \ .stringValue(\"6\")) == .stringValue(\"6\"))\nassert(compare_one(a: .stringValue(\"\
    1\"), b: .stringValue(\"2\")) == .stringValue(\"2\"))\nassert(compare_one(a: .stringValue(\"\
    1\"), b: .intValue(1)) == nil)"
  status: SyntaxError
  stderr: "/tmp/tmp07haxekb.swift:24:22: error: cannot convert return expression of\
    \ type 'Int' to return type 'Value?'\n        return a > b ? a : b\n         \
    \      ~~~~~~^~~~~~~\n/tmp/tmp07haxekb.swift:26:22: error: cannot convert return\
    \ expression of type 'Double' to return type 'Value?'\n        return a > b ?\
    \ a : b\n               ~~~~~~^~~~~~~\n/tmp/tmp07haxekb.swift:28:22: error: cannot\
    \ convert return expression of type 'String' to return type 'Value?'\n       \
    \ return a > b ? a : b\n               ~~~~~~^~~~~~~\n"
  stdout: ''
  timestamp: 1660013180
- exit_code: 1
  program: "\nenum Value: Equatable, Hashable {\n    case intValue(Int)\n    case\
    \ doubleValue(Double)\n    case stringValue(String)\n}\n\n            \n/// Create\
    \ a function that takes integers, floats, or strings representing\n/// real numbers,\
    \ and returns the larger variable in its given variable type.\n/// Return nil\
    \ if the values are equal.\n/// Note: If a real number is represented as a string,\
    \ the floating point might be . or ,\n/// >>> compare_one(a: .intValue(1), b:\
    \ .doubleValue(2.5))\n/// .doubleValue(2.5)\n/// >>> compare_one(a: .intValue(1),\
    \ b: .stringValue(\"2,3\"))\n/// .stringValue(\"2,3\")\n/// >>> compare_one(a:\
    \ .stringValue(\"5,1\"), b: .stringValue(\"6\"))\n/// .stringValue(\"6\")\n///\
    \ >>> compare_one(a: .stringValue(\"1\"), b: .intValue(1))\n/// nil\nfunc compare_one(a:\
    \ Value, b: Value) -> Value? {\n    switch a {\n    case .intValue(let a):\n \
    \       switch b {\n        case .intValue(let b):\n            return a > b ?\
    \ a : b\n        case .doubleValue(let b):\n            return b\n        case\
    \ .stringValue(let b):\n            return b\n        }\n    case .doubleValue(let\
    \ a):\n        switch b {\n        case .intValue(let b):\n            return\
    \ a\n        case .doubleValue(let b):\n            return a > b ? a : b\n   \
    \     case .stringValue(let b):\n            return b\n        }\n    case .stringValue(let\
    \ a):\n        switch b {\n        case .intValue(let b):\n            return\
    \ a\n        case .doubleValue(let b):\n            return a\n        case .stringValue(let\
    \ b):\n            return a > b ? a : b\n        }\n    }\n    return nil\n}\n\
    \n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(compare_one(a: .intValue(1), b: .intValue(2))\
    \ == .intValue(2))\nassert(compare_one(a: .intValue(1), b: .doubleValue(2.5))\
    \ == .doubleValue(2.5))\nassert(compare_one(a: .intValue(2), b: .intValue(3))\
    \ == .intValue(3))\nassert(compare_one(a: .intValue(5), b: .intValue(6)) == .intValue(6))\n\
    assert(compare_one(a: .intValue(1), b: .stringValue(\"2,3\")) == .stringValue(\"\
    2,3\"))\nassert(compare_one(a: .stringValue(\"5,1\"), b: .stringValue(\"6\"))\
    \ == .stringValue(\"6\"))\nassert(compare_one(a: .stringValue(\"1\"), b: .stringValue(\"\
    2\")) == .stringValue(\"2\"))\nassert(compare_one(a: .stringValue(\"1\"), b: .intValue(1))\
    \ == nil)"
  status: SyntaxError
  stderr: "/tmp/tmpyxwhqv92.swift:26:26: error: cannot convert return expression of\
    \ type 'Int' to return type 'Value?'\n            return a > b ? a : b\n     \
    \              ~~~~~~^~~~~~~\n/tmp/tmpyxwhqv92.swift:28:20: error: cannot convert\
    \ return expression of type 'Double' to return type 'Value?'\n            return\
    \ b\n                   ^\n/tmp/tmpyxwhqv92.swift:30:20: error: cannot convert\
    \ return expression of type 'String' to return type 'Value?'\n            return\
    \ b\n                   ^\n/tmp/tmpyxwhqv92.swift:35:20: error: cannot convert\
    \ return expression of type 'Double' to return type 'Value?'\n            return\
    \ a\n                   ^\n/tmp/tmpyxwhqv92.swift:37:26: error: cannot convert\
    \ return expression of type 'Double' to return type 'Value?'\n            return\
    \ a > b ? a : b\n                   ~~~~~~^~~~~~~\n/tmp/tmpyxwhqv92.swift:39:20:\
    \ error: cannot convert return expression of type 'String' to return type 'Value?'\n\
    \            return b\n                   ^\n/tmp/tmpyxwhqv92.swift:44:20: error:\
    \ cannot convert return expression of type 'String' to return type 'Value?'\n\
    \            return a\n                   ^\n/tmp/tmpyxwhqv92.swift:46:20: error:\
    \ cannot convert return expression of type 'String' to return type 'Value?'\n\
    \            return a\n                   ^\n/tmp/tmpyxwhqv92.swift:48:26: error:\
    \ cannot convert return expression of type 'String' to return type 'Value?'\n\
    \            return a > b ? a : b\n                   ~~~~~~^~~~~~~\n"
  stdout: ''
  timestamp: 1660013180
- exit_code: 1
  program: "\nenum Value: Equatable, Hashable {\n    case intValue(Int)\n    case\
    \ doubleValue(Double)\n    case stringValue(String)\n}\n\n            \n/// Create\
    \ a function that takes integers, floats, or strings representing\n/// real numbers,\
    \ and returns the larger variable in its given variable type.\n/// Return nil\
    \ if the values are equal.\n/// Note: If a real number is represented as a string,\
    \ the floating point might be . or ,\n/// >>> compare_one(a: .intValue(1), b:\
    \ .doubleValue(2.5))\n/// .doubleValue(2.5)\n/// >>> compare_one(a: .intValue(1),\
    \ b: .stringValue(\"2,3\"))\n/// .stringValue(\"2,3\")\n/// >>> compare_one(a:\
    \ .stringValue(\"5,1\"), b: .stringValue(\"6\"))\n/// .stringValue(\"6\")\n///\
    \ >>> compare_one(a: .stringValue(\"1\"), b: .intValue(1))\n/// nil\nfunc compare_one(a:\
    \ Value, b: Value) -> Value? {\n    var c = \"\";\n    var d = \"\";\n    switch\
    \ a {\n    case .intValue(let c):\n        c = String(c)\n    case .doubleValue(let\
    \ c):\n        c = String(c)\n    case .stringValue(let c):\n        c = c\n \
    \   }\n    switch b {\n    case .intValue(let d):\n        d = String(d)\n   \
    \ case .doubleValue(let d):\n        d = String(d)\n    case .stringValue(let\
    \ d):\n        d = d\n    }\n    if c.range(of: \"[0-9]\") != nil && d.range(of:\
    \ \"[0-9]\") != nil {\n        let a = c.replacingOccurrences(of: \",\", with:\
    \ \".\")\n        let b = d.replacingOccurrences(of: \",\", with: \".\")\n   \
    \     if a < b {\n            switch b {\n            case \"\":\n           \
    \     return nil\n            case _ where Double(b) != nil:\n               \
    \ return .doubleValue(Double(b)!)\n            case _ where Int(b) != nil:\n \
    \               return .intValue(Int(b)!)\n            default:\n            \
    \    return .stringValue(b)\n            }\n        } else if a > b {\n      \
    \      switch a {\n            case \"\":\n                return nil\n      \
    \      case _ where Double(a) != nil:\n                return .doubleValue(Double(a)!)\n\
    \            case _ where Int(a) != nil:\n                return .intValue(Int(a)!)\n\
    \            default:\n                return .stringValue(a)\n            }\n\
    \        } else {\n            return nil\n        }\n    } else {\n        return\
    \ nil\n    }\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool\
    \ {\n    if left.count != right.count {\n        return false\n    }\n    for\
    \ (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(compare_one(a: .intValue(1),\
    \ b: .intValue(2)) == .intValue(2))\nassert(compare_one(a: .intValue(1), b: .doubleValue(2.5))\
    \ == .doubleValue(2.5))\nassert(compare_one(a: .intValue(2), b: .intValue(3))\
    \ == .intValue(3))\nassert(compare_one(a: .intValue(5), b: .intValue(6)) == .intValue(6))\n\
    assert(compare_one(a: .intValue(1), b: .stringValue(\"2,3\")) == .stringValue(\"\
    2,3\"))\nassert(compare_one(a: .stringValue(\"5,1\"), b: .stringValue(\"6\"))\
    \ == .stringValue(\"6\"))\nassert(compare_one(a: .stringValue(\"1\"), b: .stringValue(\"\
    2\")) == .stringValue(\"2\"))\nassert(compare_one(a: .stringValue(\"1\"), b: .intValue(1))\
    \ == nil)"
  status: SyntaxError
  stderr: "/tmp/tmp26f6td_n.swift:26:9: error: cannot assign to value: 'c' is immutable\n\
    \        c = String(c)\n        ^\n/tmp/tmp26f6td_n.swift:26:13: error: cannot\
    \ assign value of type 'String' to type 'Int'\n        c = String(c)\n       \
    \     ^~~~~~~~~\n/tmp/tmp26f6td_n.swift:28:9: error: cannot assign to value: 'c'\
    \ is immutable\n        c = String(c)\n        ^\n/tmp/tmp26f6td_n.swift:28:13:\
    \ error: cannot assign value of type 'String' to type 'Double'\n        c = String(c)\n\
    \            ^~~~~~~~~\n/tmp/tmp26f6td_n.swift:30:9: error: cannot assign to value:\
    \ 'c' is immutable\n        c = c\n        ^\n/tmp/tmp26f6td_n.swift:34:9: error:\
    \ cannot assign to value: 'd' is immutable\n        d = String(d)\n        ^\n\
    /tmp/tmp26f6td_n.swift:34:13: error: cannot assign value of type 'String' to type\
    \ 'Int'\n        d = String(d)\n            ^~~~~~~~~\n/tmp/tmp26f6td_n.swift:36:9:\
    \ error: cannot assign to value: 'd' is immutable\n        d = String(d)\n   \
    \     ^\n/tmp/tmp26f6td_n.swift:36:13: error: cannot assign value of type 'String'\
    \ to type 'Double'\n        d = String(d)\n            ^~~~~~~~~\n/tmp/tmp26f6td_n.swift:38:9:\
    \ error: cannot assign to value: 'd' is immutable\n        d = d\n        ^\n\
    /tmp/tmp26f6td_n.swift:40:10: error: value of type 'String' has no member 'range'\n\
    \    if c.range(of: \"[0-9]\") != nil && d.range(of: \"[0-9]\") != nil {\n   \
    \    ~ ^~~~~\n/tmp/tmp26f6td_n.swift:40:41: error: value of type 'String' has\
    \ no member 'range'\n    if c.range(of: \"[0-9]\") != nil && d.range(of: \"[0-9]\"\
    ) != nil {\n                                      ~ ^~~~~\n/tmp/tmp26f6td_n.swift:41:19:\
    \ error: value of type 'String' has no member 'replacingOccurrences'\n       \
    \ let a = c.replacingOccurrences(of: \",\", with: \".\")\n                ~ ^~~~~~~~~~~~~~~~~~~~\n\
    /tmp/tmp26f6td_n.swift:42:19: error: value of type 'String' has no member 'replacingOccurrences'\n\
    \        let b = d.replacingOccurrences(of: \",\", with: \".\")\n            \
    \    ~ ^~~~~~~~~~~~~~~~~~~~\n"
  stdout: ''
  timestamp: 1660013180
- exit_code: 1
  program: "\nenum Value: Equatable, Hashable {\n    case intValue(Int)\n    case\
    \ doubleValue(Double)\n    case stringValue(String)\n}\n\n            \n/// Create\
    \ a function that takes integers, floats, or strings representing\n/// real numbers,\
    \ and returns the larger variable in its given variable type.\n/// Return nil\
    \ if the values are equal.\n/// Note: If a real number is represented as a string,\
    \ the floating point might be . or ,\n/// >>> compare_one(a: .intValue(1), b:\
    \ .doubleValue(2.5))\n/// .doubleValue(2.5)\n/// >>> compare_one(a: .intValue(1),\
    \ b: .stringValue(\"2,3\"))\n/// .stringValue(\"2,3\")\n/// >>> compare_one(a:\
    \ .stringValue(\"5,1\"), b: .stringValue(\"6\"))\n/// .stringValue(\"6\")\n///\
    \ >>> compare_one(a: .stringValue(\"1\"), b: .intValue(1))\n/// nil\nfunc compare_one(a:\
    \ Value, b: Value) -> Value? {\n    // TODO: Implement this function!\n    //\
    \ You should use the patterns below to solve this problem:\n    switch a {\n \
    \   case .intValue(let i):\n        switch b {\n        case .intValue(let j):\n\
    \            if i < j {\n                return b\n            } else if i > j\
    \ {\n                return a\n            } else {\n                return nil\n\
    \            }\n        case .doubleValue(let j):\n            if Double(i) <\
    \ j {\n                return b\n            } else if Double(i) > j {\n     \
    \           return a\n            } else {\n                return nil\n     \
    \       }\n        case .stringValue(let j):\n            if Double(i) < Double(j)\
    \ {\n                return b\n            } else if Double(i) > Double(j) {\n\
    \                return a\n            } else {\n                return nil\n\
    \            }\n        }\n    case .doubleValue(let i):\n        switch b {\n\
    \        case .intValue(let j):\n            if i < Double(j) {\n            \
    \    return b\n            } else if i > Double(j) {\n                return a\n\
    \            } else {\n                return nil\n            }\n        case\
    \ .doubleValue(let j):\n            if i < j {\n                return b\n   \
    \         } else if i > j {\n                return a\n            } else {\n\
    \                return nil\n            }\n        case .stringValue(let j):\n\
    \            if i < Double(j) {\n                return b\n            } else\
    \ if i > Double(j) {\n                return a\n            } else {\n       \
    \         return nil\n            }\n        }\n    case .stringValue(let i):\n\
    \        switch b {\n        case .intValue(let j):\n            if Double(i)\
    \ < Double(j) {\n                return b\n            } else if Double(i) > Double(j)\
    \ {\n                return a\n            } else {\n                return nil\n\
    \            }\n        case .doubleValue(let j):\n            if Double(i) <\
    \ j {\n                return b\n            } else if Double(i) > j {\n     \
    \           return a\n            } else {\n                return nil\n     \
    \       }\n        case .stringValue(let j):\n            if Double(i\n}\n\n\n\
    func ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(compare_one(a: .intValue(1), b: .intValue(2))\
    \ == .intValue(2))\nassert(compare_one(a: .intValue(1), b: .doubleValue(2.5))\
    \ == .doubleValue(2.5))\nassert(compare_one(a: .intValue(2), b: .intValue(3))\
    \ == .intValue(3))\nassert(compare_one(a: .intValue(5), b: .intValue(6)) == .intValue(6))\n\
    assert(compare_one(a: .intValue(1), b: .stringValue(\"2,3\")) == .stringValue(\"\
    2,3\"))\nassert(compare_one(a: .stringValue(\"5,1\"), b: .stringValue(\"6\"))\
    \ == .stringValue(\"6\"))\nassert(compare_one(a: .stringValue(\"1\"), b: .stringValue(\"\
    2\")) == .stringValue(\"2\"))\nassert(compare_one(a: .stringValue(\"1\"), b: .intValue(1))\
    \ == nil)"
  status: SyntaxError
  stderr: "/tmp/tmpgj3q6dc5.swift:99:1: error: expected ')' in expression list\n}\n\
    ^\n/tmp/tmpgj3q6dc5.swift:98:22: note: to match this opening '('\n           \
    \ if Double(i\n                     ^\n/tmp/tmpgj3q6dc5.swift:121:66: error: expected\
    \ '}' at end of 'switch' statement\nassert(compare_one(a: .stringValue(\"1\"),\
    \ b: .intValue(1)) == nil)\n                                                 \
    \                ^\n/tmp/tmpgj3q6dc5.swift:24:14: note: to match this opening\
    \ '{'\n    switch a {\n             ^\n/tmp/tmpgj3q6dc5.swift:121:66: error: expected\
    \ '}' at end of brace statement\nassert(compare_one(a: .stringValue(\"1\"), b:\
    \ .intValue(1)) == nil)\n                                                    \
    \             ^\n/tmp/tmpgj3q6dc5.swift:21:48: note: to match this opening '{'\n\
    func compare_one(a: Value, b: Value) -> Value? {\n                           \
    \                    ^\n/tmp/tmpgj3q6dc5.swift:44:28: error: value of optional\
    \ type 'Double?' must be unwrapped to a value of type 'Double'\n            if\
    \ Double(i) < Double(j) {\n                           ^\n/tmp/tmpgj3q6dc5.swift:44:28:\
    \ note: coalesce using '??' to provide a default when the optional value contains\
    \ 'nil'\n            if Double(i) < Double(j) {\n                           ^\n\
    \                                     ?? <#default value#>\n/tmp/tmpgj3q6dc5.swift:44:28:\
    \ note: force-unwrap using '!' to abort execution if the optional value contains\
    \ 'nil'\n            if Double(i) < Double(j) {\n                           ^\n\
    \                                    !\n/tmp/tmpgj3q6dc5.swift:46:35: error: value\
    \ of optional type 'Double?' must be unwrapped to a value of type 'Double'\n \
    \           } else if Double(i) > Double(j) {\n                              \
    \    ^\n/tmp/tmpgj3q6dc5.swift:46:35: note: coalesce using '??' to provide a default\
    \ when the optional value contains 'nil'\n            } else if Double(i) > Double(j)\
    \ {\n                                  ^\n                                   \
    \         ?? <#default value#>\n/tmp/tmpgj3q6dc5.swift:46:35: note: force-unwrap\
    \ using '!' to abort execution if the"
  stdout: ''
  timestamp: 1660013180
- exit_code: 1
  program: "\nenum Value: Equatable, Hashable {\n    case intValue(Int)\n    case\
    \ doubleValue(Double)\n    case stringValue(String)\n}\n\n            \n/// Create\
    \ a function that takes integers, floats, or strings representing\n/// real numbers,\
    \ and returns the larger variable in its given variable type.\n/// Return nil\
    \ if the values are equal.\n/// Note: If a real number is represented as a string,\
    \ the floating point might be . or ,\n/// >>> compare_one(a: .intValue(1), b:\
    \ .doubleValue(2.5))\n/// .doubleValue(2.5)\n/// >>> compare_one(a: .intValue(1),\
    \ b: .stringValue(\"2,3\"))\n/// .stringValue(\"2,3\")\n/// >>> compare_one(a:\
    \ .stringValue(\"5,1\"), b: .stringValue(\"6\"))\n/// .stringValue(\"6\")\n///\
    \ >>> compare_one(a: .stringValue(\"1\"), b: .intValue(1))\n/// nil\nfunc compare_one(a:\
    \ Value, b: Value) -> Value? {\n    switch (a, b) {\n    case (.intValue(let a),\
    \ .intValue(let b)):\n        return a > b ? a : b\n    case (.doubleValue(let\
    \ a), .doubleValue(let b)):\n        return a > b ? a : b\n    case (.stringValue(let\
    \ a), .stringValue(let b)):\n        return a > b ? a : b\n    case (.intValue(let\
    \ a), .doubleValue(let b)):\n        return a > b ? a : b\n    case (.intValue(let\
    \ a), .stringValue(let b)):\n        return a > b ? a : b\n    case (.doubleValue(let\
    \ a), .intValue(let b)):\n        return a > b ? a : b\n    case (.doubleValue(let\
    \ a), .stringValue(let b)):\n        return a > b ? a : b\n    case (.stringValue(let\
    \ a), .intValue(let b)):\n        return a > b ? a : b\n    case (.stringValue(let\
    \ a), .doubleValue(let b)):\n        return a > b ? a : b\n    default:\n    \
    \    return nil\n    }\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(compare_one(a:\
    \ .intValue(1), b: .intValue(2)) == .intValue(2))\nassert(compare_one(a: .intValue(1),\
    \ b: .doubleValue(2.5)) == .doubleValue(2.5))\nassert(compare_one(a: .intValue(2),\
    \ b: .intValue(3)) == .intValue(3))\nassert(compare_one(a: .intValue(5), b: .intValue(6))\
    \ == .intValue(6))\nassert(compare_one(a: .intValue(1), b: .stringValue(\"2,3\"\
    )) == .stringValue(\"2,3\"))\nassert(compare_one(a: .stringValue(\"5,1\"), b:\
    \ .stringValue(\"6\")) == .stringValue(\"6\"))\nassert(compare_one(a: .stringValue(\"\
    1\"), b: .stringValue(\"2\")) == .stringValue(\"2\"))\nassert(compare_one(a: .stringValue(\"\
    1\"), b: .intValue(1)) == nil)"
  status: SyntaxError
  stderr: "/tmp/tmpjf037tzu.swift:24:22: error: cannot convert return expression of\
    \ type 'Int' to return type 'Value?'\n        return a > b ? a : b\n         \
    \      ~~~~~~^~~~~~~\n/tmp/tmpjf037tzu.swift:26:22: error: cannot convert return\
    \ expression of type 'Double' to return type 'Value?'\n        return a > b ?\
    \ a : b\n               ~~~~~~^~~~~~~\n/tmp/tmpjf037tzu.swift:28:22: error: cannot\
    \ convert return expression of type 'String' to return type 'Value?'\n       \
    \ return a > b ? a : b\n               ~~~~~~^~~~~~~\n/tmp/tmpjf037tzu.swift:30:20:\
    \ error: cannot convert value of type 'Double' to expected argument type 'Int'\n\
    \        return a > b ? a : b\n                   ^\n                   Int( )\n\
    /tmp/tmpjf037tzu.swift:30:22: error: cannot convert return expression of type\
    \ 'Int' to return type 'Value?'\n        return a > b ? a : b\n              \
    \ ~~~~~~^~~~~~~\n/tmp/tmpjf037tzu.swift:32:20: error: cannot convert value of\
    \ type 'String' to expected argument type 'Int'\n        return a > b ? a : b\n\
    \                   ^\n/tmp/tmpjf037tzu.swift:32:22: error: cannot convert return\
    \ expression of type 'Int' to return type 'Value?'\n        return a > b ? a :\
    \ b\n               ~~~~~~^~~~~~~\n/tmp/tmpjf037tzu.swift:34:16: error: cannot\
    \ convert value of type 'Double' to expected argument type 'Int'\n        return\
    \ a > b ? a : b\n               ^\n               Int( )\n/tmp/tmpjf037tzu.swift:34:22:\
    \ error: cannot convert return expression of type 'Double' to return type 'Value?'\n\
    \        return a > b ? a : b\n               ~~~~~~^~~~~~~\n/tmp/tmpjf037tzu.swift:36:18:\
    \ error: binary operator '>' cannot be applied to operands of type 'Double' and\
    \ 'String'\n        return a > b ? a : b\n               ~ ^ ~\n/tmp/tmpjf037tzu.swift:36:22:\
    \ error: cannot convert return expression of type 'Double' to return type 'Value?'\n\
    \        return a > b ? a : b\n               ~~~~~~^~~~~~~\n/tmp/tmpjf037tzu.swift:38:16:\
    \ error: cannot convert value of type 'String' to expected argument type 'Int'\n\
    \        return a > b ? a : b\n               ^\n/tmp/tmpjf037tzu.swift:38:22:\
    \ error: ca"
  stdout: ''
  timestamp: 1660013180
- exit_code: 1
  program: "\nenum Value: Equatable, Hashable {\n    case intValue(Int)\n    case\
    \ doubleValue(Double)\n    case stringValue(String)\n}\n\n            \n/// Create\
    \ a function that takes integers, floats, or strings representing\n/// real numbers,\
    \ and returns the larger variable in its given variable type.\n/// Return nil\
    \ if the values are equal.\n/// Note: If a real number is represented as a string,\
    \ the floating point might be . or ,\n/// >>> compare_one(a: .intValue(1), b:\
    \ .doubleValue(2.5))\n/// .doubleValue(2.5)\n/// >>> compare_one(a: .intValue(1),\
    \ b: .stringValue(\"2,3\"))\n/// .stringValue(\"2,3\")\n/// >>> compare_one(a:\
    \ .stringValue(\"5,1\"), b: .stringValue(\"6\"))\n/// .stringValue(\"6\")\n///\
    \ >>> compare_one(a: .stringValue(\"1\"), b: .intValue(1))\n/// nil\nfunc compare_one(a:\
    \ Value, b: Value) -> Value? {\n    switch (a, b) {\n    case (.intValue(let x),\
    \ .intValue(let y)):\n        return x > y ? .intValue(x) : nil\n    case (.intValue(let\
    \ x), .doubleValue(let y)):\n        return x > y ? .doubleValue(y) : nil\n  \
    \  case (.intValue(let x), .stringValue(let y)):\n        let numB = Float(y.replacingOccurrences(of:\
    \ \",\", with: \".\")) ?? 0\n        return x > numB ? .stringValue(y) : nil\n\
    \    case (.doubleValue(let x), .intValue(let y)):\n        return x > y ? .doubleValue(x)\
    \ : nil\n    case (.doubleValue(let x), .doubleValue(let y)):\n        return\
    \ x > y ? .doubleValue(x) : nil\n    case (.doubleValue(let x), .stringValue(let\
    \ y)):\n        let numB = Float(y.replacingOccurrences(of: \",\", with: \".\"\
    )) ?? 0\n        return x > numB ? .stringValue(y) : nil\n    case (.stringValue(let\
    \ x), .intValue(let y)):\n        let numA = Float(x.replacingOccurrences(of:\
    \ \",\", with: \".\")) ?? 0\n        return numA > y ? .stringValue(x) : nil\n\
    \    case (.stringValue(let x), .doubleValue(let y)):\n        let numA = Float(x.replacingOccurrences(of:\
    \ \",\", with: \".\")) ?? 0\n        return numA > y ? .stringValue(x) : nil\n\
    \    case (.stringValue(let x), .stringValue(let y)):\n        let numA = Float(x.replacingOccurrences(of:\
    \ \",\", with: \".\")) ?? 0\n        let numB = Float(y.replacingOccurrences(of:\
    \ \",\", with: \".\")) ?? 0\n        return numA > numB ? .stringValue(x) : nil\n\
    \    }\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n  \
    \  if left.count != right.count {\n        return false\n    }\n    for (l, r)\
    \ in zip(left, right) {\n        if l != r {\n            return false\n     \
    \   }\n    }\n    return true\n}\n            \nassert(compare_one(a: .intValue(1),\
    \ b: .intValue(2)) == .intValue(2))\nassert(compare_one(a: .intValue(1), b: .doubleValue(2.5))\
    \ == .doubleValue(2.5))\nassert(compare_one(a: .intValue(2), b: .intValue(3))\
    \ == .intValue(3))\nassert(compare_one(a: .intValue(5), b: .intValue(6)) == .intValue(6))\n\
    assert(compare_one(a: .intValue(1), b: .stringValue(\"2,3\")) == .stringValue(\"\
    2,3\"))\nassert(compare_one(a: .stringValue(\"5,1\"), b: .stringValue(\"6\"))\
    \ == .stringValue(\"6\"))\nassert(compare_one(a: .stringValue(\"1\"), b: .stringValue(\"\
    2\")) == .stringValue(\"2\"))\nassert(compare_one(a: .stringValue(\"1\"), b: .intValue(1))\
    \ == nil)"
  status: SyntaxError
  stderr: "/tmp/tmpmn3vwiuc.swift:26:20: error: cannot convert value of type 'Double'\
    \ to expected argument type 'Int'\n        return x > y ? .doubleValue(y) : nil\n\
    \                   ^\n                   Int( )\n/tmp/tmpmn3vwiuc.swift:28:28:\
    \ error: value of type 'String' has no member 'replacingOccurrences'\n       \
    \ let numB = Float(y.replacingOccurrences(of: \",\", with: \".\")) ?? 0\n    \
    \                     ~ ^~~~~~~~~~~~~~~~~~~~\n/tmp/tmpmn3vwiuc.swift:31:16: error:\
    \ cannot convert value of type 'Double' to expected argument type 'Int'\n    \
    \    return x > y ? .doubleValue(x) : nil\n               ^\n               Int(\
    \ )\n/tmp/tmpmn3vwiuc.swift:35:28: error: value of type 'String' has no member\
    \ 'replacingOccurrences'\n        let numB = Float(y.replacingOccurrences(of:\
    \ \",\", with: \".\")) ?? 0\n                         ~ ^~~~~~~~~~~~~~~~~~~~\n\
    /tmp/tmpmn3vwiuc.swift:38:28: error: value of type 'String' has no member 'replacingOccurrences'\n\
    \        let numA = Float(x.replacingOccurrences(of: \",\", with: \".\")) ?? 0\n\
    \                         ~ ^~~~~~~~~~~~~~~~~~~~\n/tmp/tmpmn3vwiuc.swift:41:28:\
    \ error: value of type 'String' has no member 'replacingOccurrences'\n       \
    \ let numA = Float(x.replacingOccurrences(of: \",\", with: \".\")) ?? 0\n    \
    \                     ~ ^~~~~~~~~~~~~~~~~~~~\n/tmp/tmpmn3vwiuc.swift:44:28: error:\
    \ value of type 'String' has no member 'replacingOccurrences'\n        let numA\
    \ = Float(x.replacingOccurrences(of: \",\", with: \".\")) ?? 0\n             \
    \            ~ ^~~~~~~~~~~~~~~~~~~~\n/tmp/tmpmn3vwiuc.swift:45:28: error: value\
    \ of type 'String' has no member 'replacingOccurrences'\n        let numB = Float(y.replacingOccurrences(of:\
    \ \",\", with: \".\")) ?? 0\n                         ~ ^~~~~~~~~~~~~~~~~~~~\n"
  stdout: ''
  timestamp: 1660013180
- exit_code: -4
  program: "\nenum Value: Equatable, Hashable {\n    case intValue(Int)\n    case\
    \ doubleValue(Double)\n    case stringValue(String)\n}\n\n            \n/// Create\
    \ a function that takes integers, floats, or strings representing\n/// real numbers,\
    \ and returns the larger variable in its given variable type.\n/// Return nil\
    \ if the values are equal.\n/// Note: If a real number is represented as a string,\
    \ the floating point might be . or ,\n/// >>> compare_one(a: .intValue(1), b:\
    \ .doubleValue(2.5))\n/// .doubleValue(2.5)\n/// >>> compare_one(a: .intValue(1),\
    \ b: .stringValue(\"2,3\"))\n/// .stringValue(\"2,3\")\n/// >>> compare_one(a:\
    \ .stringValue(\"5,1\"), b: .stringValue(\"6\"))\n/// .stringValue(\"6\")\n///\
    \ >>> compare_one(a: .stringValue(\"1\"), b: .intValue(1))\n/// nil\nfunc compare_one(a:\
    \ Value, b: Value) -> Value? {\n    // TODO: Implement me!\n    return nil\n}\n\
    \n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(compare_one(a: .intValue(1), b: .intValue(2))\
    \ == .intValue(2))\nassert(compare_one(a: .intValue(1), b: .doubleValue(2.5))\
    \ == .doubleValue(2.5))\nassert(compare_one(a: .intValue(2), b: .intValue(3))\
    \ == .intValue(3))\nassert(compare_one(a: .intValue(5), b: .intValue(6)) == .intValue(6))\n\
    assert(compare_one(a: .intValue(1), b: .stringValue(\"2,3\")) == .stringValue(\"\
    2,3\"))\nassert(compare_one(a: .stringValue(\"5,1\"), b: .stringValue(\"6\"))\
    \ == .stringValue(\"6\"))\nassert(compare_one(a: .stringValue(\"1\"), b: .stringValue(\"\
    2\")) == .stringValue(\"2\"))\nassert(compare_one(a: .stringValue(\"1\"), b: .intValue(1))\
    \ == nil)"
  status: Exception
  stderr: 'tmp6l4i7dmf/tmp6l4i7dmf.swift:39: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002ae710597c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002ae71028eb6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002ae71028e988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002ae71028d7b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmp6l4i7dmf                        0x000055ab78802a56 <unavailable> + 6742

    5    libc.so.6                          0x00002ae710783460 __libc_start_main +
    245

    6    tmp6l4i7dmf                        0x000055ab78802499 <unavailable> + 5273

    '
  stdout: ''
  timestamp: 1660013180
- exit_code: 1
  program: "\nenum Value: Equatable, Hashable {\n    case intValue(Int)\n    case\
    \ doubleValue(Double)\n    case stringValue(String)\n}\n\n            \n/// Create\
    \ a function that takes integers, floats, or strings representing\n/// real numbers,\
    \ and returns the larger variable in its given variable type.\n/// Return nil\
    \ if the values are equal.\n/// Note: If a real number is represented as a string,\
    \ the floating point might be . or ,\n/// >>> compare_one(a: .intValue(1), b:\
    \ .doubleValue(2.5))\n/// .doubleValue(2.5)\n/// >>> compare_one(a: .intValue(1),\
    \ b: .stringValue(\"2,3\"))\n/// .stringValue(\"2,3\")\n/// >>> compare_one(a:\
    \ .stringValue(\"5,1\"), b: .stringValue(\"6\"))\n/// .stringValue(\"6\")\n///\
    \ >>> compare_one(a: .stringValue(\"1\"), b: .intValue(1))\n/// nil\nfunc compare_one(a:\
    \ Value, b: Value) -> Value? {\n    switch a {\n    case .intValue(let aValue):\n\
    \        switch b {\n        case .intValue(let bValue):\n            return aValue\
    \ > bValue ? a : bValue > aValue ? b : nil\n        case .doubleValue(let bValue):\n\
    \            return bValue > Double(aValue) ? b : nil\n        case .stringValue(let\
    \ bValue):\n            return Double(bValue) > Double(aValue) ? b : nil\n   \
    \     }\n    case .doubleValue(let aValue):\n        switch b {\n        case\
    \ .intValue(let bValue):\n            return aValue > Double(bValue) ? a : nil\n\
    \        case .doubleValue(let bValue):\n            return aValue > bValue ?\
    \ a : bValue > aValue ? b : nil\n        case .stringValue(let bValue):\n    \
    \        return Double(bValue) > aValue ? b : nil\n        }\n    case .stringValue(let\
    \ aValue):\n        switch b {\n        case .intValue(let bValue):\n        \
    \    return Double(aValue) > Double(bValue) ? a : nil\n        case .doubleValue(let\
    \ bValue):\n            return Double(aValue) > bValue ? a : nil\n        case\
    \ .stringValue(let bValue):\n            return Double(aValue) > Double(bValue)\
    \ ? a : bValue > aValue ? b : nil\n        }\n    }\n}\n\n\nfunc ==(left: [(Int,\
    \ Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n\
    \        return false\n    }\n    for (l, r) in zip(left, right) {\n        if\
    \ l != r {\n            return false\n        }\n    }\n    return true\n}\n \
    \           \nassert(compare_one(a: .intValue(1), b: .intValue(2)) == .intValue(2))\n\
    assert(compare_one(a: .intValue(1), b: .doubleValue(2.5)) == .doubleValue(2.5))\n\
    assert(compare_one(a: .intValue(2), b: .intValue(3)) == .intValue(3))\nassert(compare_one(a:\
    \ .intValue(5), b: .intValue(6)) == .intValue(6))\nassert(compare_one(a: .intValue(1),\
    \ b: .stringValue(\"2,3\")) == .stringValue(\"2,3\"))\nassert(compare_one(a: .stringValue(\"\
    5,1\"), b: .stringValue(\"6\")) == .stringValue(\"6\"))\nassert(compare_one(a:\
    \ .stringValue(\"1\"), b: .stringValue(\"2\")) == .stringValue(\"2\"))\nassert(compare_one(a:\
    \ .stringValue(\"1\"), b: .intValue(1)) == nil)"
  status: SyntaxError
  stderr: "/tmp/tmpv120l8q1.swift:30:20: error: value of optional type 'Double?' must\
    \ be unwrapped to a value of type 'Double'\n            return Double(bValue)\
    \ > Double(aValue) ? b : nil\n                   ^\n/tmp/tmpv120l8q1.swift:30:20:\
    \ note: coalesce using '??' to provide a default when the optional value contains\
    \ 'nil'\n            return Double(bValue) > Double(aValue) ? b : nil\n      \
    \             ^\n                                  ?? <#default value#>\n/tmp/tmpv120l8q1.swift:30:20:\
    \ note: force-unwrap using '!' to abort execution if the optional value contains\
    \ 'nil'\n            return Double(bValue) > Double(aValue) ? b : nil\n      \
    \             ^\n                                 !\n/tmp/tmpv120l8q1.swift:39:20:\
    \ error: value of optional type 'Double?' must be unwrapped to a value of type\
    \ 'Double'\n            return Double(bValue) > aValue ? b : nil\n           \
    \        ^\n/tmp/tmpv120l8q1.swift:39:20: note: coalesce using '??' to provide\
    \ a default when the optional value contains 'nil'\n            return Double(bValue)\
    \ > aValue ? b : nil\n                   ^\n                                 \
    \ ?? <#default value#>\n/tmp/tmpv120l8q1.swift:39:20: note: force-unwrap using\
    \ '!' to abort execution if the optional value contains 'nil'\n            return\
    \ Double(bValue) > aValue ? b : nil\n                   ^\n                  \
    \               !\n/tmp/tmpv120l8q1.swift:44:20: error: value of optional type\
    \ 'Double?' must be unwrapped to a value of type 'Double'\n            return\
    \ Double(aValue) > Double(bValue) ? a : nil\n                   ^\n/tmp/tmpv120l8q1.swift:44:20:\
    \ note: coalesce using '??' to provide a default when the optional value contains\
    \ 'nil'\n            return Double(aValue) > Double(bValue) ? a : nil\n      \
    \             ^\n                                  ?? <#default value#>\n/tmp/tmpv120l8q1.swift:44:20:\
    \ note: force-unwrap using '!' to abort execution if the optional value contains\
    \ 'nil'\n            return Double(aValue) > Double(bValue) ? a : nil\n      \
    \             ^\n                                 !\n/tmp/tmpv120l8q1.swift:"
  stdout: ''
  timestamp: 1660013180
- exit_code: 1
  program: "\nenum Value: Equatable, Hashable {\n    case intValue(Int)\n    case\
    \ doubleValue(Double)\n    case stringValue(String)\n}\n\n            \n/// Create\
    \ a function that takes integers, floats, or strings representing\n/// real numbers,\
    \ and returns the larger variable in its given variable type.\n/// Return nil\
    \ if the values are equal.\n/// Note: If a real number is represented as a string,\
    \ the floating point might be . or ,\n/// >>> compare_one(a: .intValue(1), b:\
    \ .doubleValue(2.5))\n/// .doubleValue(2.5)\n/// >>> compare_one(a: .intValue(1),\
    \ b: .stringValue(\"2,3\"))\n/// .stringValue(\"2,3\")\n/// >>> compare_one(a:\
    \ .stringValue(\"5,1\"), b: .stringValue(\"6\"))\n/// .stringValue(\"6\")\n///\
    \ >>> compare_one(a: .stringValue(\"1\"), b: .intValue(1))\n/// nil\nfunc compare_one(a:\
    \ Value, b: Value) -> Value? {\n    switch a {\n    case .intValue(let aInt):\n\
    \        switch b {\n        case .intValue(let bInt):\n            return aInt\
    \ == bInt ? nil : aInt > bInt ? a : b\n        case .doubleValue(let bDouble):\n\
    \            return bDouble\n        case .stringValue(let bString):\n       \
    \     let bDouble = Double(bString) ?? 0\n            return bDouble\n       \
    \ }\n    case .doubleValue(let aDouble):\n        switch b {\n        case .intValue(let\
    \ bInt):\n            return aDouble\n        case .doubleValue(let bDouble):\n\
    \            return aDouble == bDouble ? nil : aDouble > bDouble ? a : b\n   \
    \     case .stringValue(let bString):\n            let bDouble = Double(bString)\
    \ ?? 0\n            return aDouble == bDouble ? nil : aDouble > bDouble ? a :\
    \ b\n        }\n    case .stringValue(let aString):\n        switch b {\n    \
    \    case .intValue(let bInt):\n            let aDouble = Double(aString) ?? 0\n\
    \            return aDouble\n        case .doubleValue(let bDouble):\n       \
    \     let aDouble = Double(aString) ?? 0\n            return aDouble == bDouble\
    \ ? nil : aDouble > bDouble ? a : b\n        case .stringValue(let bString):\n\
    \            let aDouble = Double(aString) ?? 0\n            let bDouble = Double(bString)\
    \ ?? 0\n            return aDouble == bDouble ? nil : aDouble > bDouble ? a :\
    \ b\n        }\n    }\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(compare_one(a:\
    \ .intValue(1), b: .intValue(2)) == .intValue(2))\nassert(compare_one(a: .intValue(1),\
    \ b: .doubleValue(2.5)) == .doubleValue(2.5))\nassert(compare_one(a: .intValue(2),\
    \ b: .intValue(3)) == .intValue(3))\nassert(compare_one(a: .intValue(5), b: .intValue(6))\
    \ == .intValue(6))\nassert(compare_one(a: .intValue(1), b: .stringValue(\"2,3\"\
    )) == .stringValue(\"2,3\"))\nassert(compare_one(a: .stringValue(\"5,1\"), b:\
    \ .stringValue(\"6\")) == .stringValue(\"6\"))\nassert(compare_one(a: .stringValue(\"\
    1\"), b: .stringValue(\"2\")) == .stringValue(\"2\"))\nassert(compare_one(a: .stringValue(\"\
    1\"), b: .intValue(1)) == nil)"
  status: SyntaxError
  stderr: "/tmp/tmpu_7tyzw9.swift:28:20: error: cannot convert return expression of\
    \ type 'Double' to return type 'Value?'\n            return bDouble\n        \
    \           ^~~~~~~\n/tmp/tmpu_7tyzw9.swift:31:20: error: cannot convert return\
    \ expression of type 'Double' to return type 'Value?'\n            return bDouble\n\
    \                   ^~~~~~~\n/tmp/tmpu_7tyzw9.swift:36:20: error: cannot convert\
    \ return expression of type 'Double' to return type 'Value?'\n            return\
    \ aDouble\n                   ^~~~~~~\n/tmp/tmpu_7tyzw9.swift:47:20: error: cannot\
    \ convert return expression of type 'Double' to return type 'Value?'\n       \
    \     return aDouble\n                   ^~~~~~~\n"
  stdout: ''
  timestamp: 1660013180
- exit_code: 1
  program: "\nenum Value: Equatable, Hashable {\n    case intValue(Int)\n    case\
    \ doubleValue(Double)\n    case stringValue(String)\n}\n\n            \n/// Create\
    \ a function that takes integers, floats, or strings representing\n/// real numbers,\
    \ and returns the larger variable in its given variable type.\n/// Return nil\
    \ if the values are equal.\n/// Note: If a real number is represented as a string,\
    \ the floating point might be . or ,\n/// >>> compare_one(a: .intValue(1), b:\
    \ .doubleValue(2.5))\n/// .doubleValue(2.5)\n/// >>> compare_one(a: .intValue(1),\
    \ b: .stringValue(\"2,3\"))\n/// .stringValue(\"2,3\")\n/// >>> compare_one(a:\
    \ .stringValue(\"5,1\"), b: .stringValue(\"6\"))\n/// .stringValue(\"6\")\n///\
    \ >>> compare_one(a: .stringValue(\"1\"), b: .intValue(1))\n/// nil\nfunc compare_one(a:\
    \ Value, b: Value) -> Value? {\n  if(a == b){\n    return nil\n  }\n  switch (a,\
    \ b) {\n    case (.intValue(let x), .intValue(let y)):\n      return x > y ? a\
    \ : b\n    case (.intValue(let x), .doubleValue(let y)):\n      return y > Double(x)\
    \ ? b : a\n    case (.intValue(let x), .stringValue(let y)):\n      return Double(y)\
    \ ?? 0 > Double(x) ? b : a\n    case (.doubleValue(let x), .intValue(let y)):\n\
    \      return x > Double(y) ? a : b\n    case (.doubleValue(let x), .doubleValue(let\
    \ y)):\n      return x > y ? a : b\n    case (.doubleValue(let x), .stringValue(let\
    \ y)):\n      return Double(y) ?? 0 > x ? b : a\n    case (.stringValue(let x),\
    \ .intValue(let y)):\n      return Double(x) ?? 0 > Double(y) ? a : b\n    case\
    \ (.stringValue(let x), .doubleValue(let y)):\n      return Double(x) ?? 0 > y\
    \ ? a : b\n    case (.stringValue(let x), .stringValue(let y)):\n      return\
    \ Double(x) ?? 0 > Double(y) ? a : b\n    default:\n      return nil\n  }\n}\n\
    \n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(compare_one(a: .intValue(1), b: .intValue(2))\
    \ == .intValue(2))\nassert(compare_one(a: .intValue(1), b: .doubleValue(2.5))\
    \ == .doubleValue(2.5))\nassert(compare_one(a: .intValue(2), b: .intValue(3))\
    \ == .intValue(3))\nassert(compare_one(a: .intValue(5), b: .intValue(6)) == .intValue(6))\n\
    assert(compare_one(a: .intValue(1), b: .stringValue(\"2,3\")) == .stringValue(\"\
    2,3\"))\nassert(compare_one(a: .stringValue(\"5,1\"), b: .stringValue(\"6\"))\
    \ == .stringValue(\"6\"))\nassert(compare_one(a: .stringValue(\"1\"), b: .stringValue(\"\
    2\")) == .stringValue(\"2\"))\nassert(compare_one(a: .stringValue(\"1\"), b: .intValue(1))\
    \ == nil)"
  status: SyntaxError
  stderr: "/tmp/tmppwi3at2g.swift:43:31: error: value of optional type 'Double?' must\
    \ be unwrapped to a value of type 'Double'\n      return Double(x) ?? 0 > Double(y)\
    \ ? a : b\n                              ^\n/tmp/tmppwi3at2g.swift:43:31: note:\
    \ coalesce using '??' to provide a default when the optional value contains 'nil'\n\
    \      return Double(x) ?? 0 > Double(y) ? a : b\n                           \
    \   ^\n                                        ?? <#default value#>\n/tmp/tmppwi3at2g.swift:43:31:\
    \ note: force-unwrap using '!' to abort execution if the optional value contains\
    \ 'nil'\n      return Double(x) ?? 0 > Double(y) ? a : b\n                   \
    \           ^\n                                       !\n"
  stdout: ''
  timestamp: 1660013180
- exit_code: -4
  program: "\nenum Value: Equatable, Hashable {\n    case intValue(Int)\n    case\
    \ doubleValue(Double)\n    case stringValue(String)\n}\n\n            \n/// Create\
    \ a function that takes integers, floats, or strings representing\n/// real numbers,\
    \ and returns the larger variable in its given variable type.\n/// Return nil\
    \ if the values are equal.\n/// Note: If a real number is represented as a string,\
    \ the floating point might be . or ,\n/// >>> compare_one(a: .intValue(1), b:\
    \ .doubleValue(2.5))\n/// .doubleValue(2.5)\n/// >>> compare_one(a: .intValue(1),\
    \ b: .stringValue(\"2,3\"))\n/// .stringValue(\"2,3\")\n/// >>> compare_one(a:\
    \ .stringValue(\"5,1\"), b: .stringValue(\"6\"))\n/// .stringValue(\"6\")\n///\
    \ >>> compare_one(a: .stringValue(\"1\"), b: .intValue(1))\n/// nil\nfunc compare_one(a:\
    \ Value, b: Value) -> Value? {\n    var aValue: Double\n    var bValue: Double\n\
    \    switch a {\n    case .intValue(let int):\n        aValue = Double(int)\n\
    \    case .doubleValue(let double):\n        aValue = double\n    case .stringValue(let\
    \ string):\n        guard let double = Double(string) else {\n            return\
    \ nil\n        }\n        aValue = double\n    }\n    switch b {\n    case .intValue(let\
    \ int):\n        bValue = Double(int)\n    case .doubleValue(let double):\n  \
    \      bValue = double\n    case .stringValue(let string):\n        guard let\
    \ double = Double(string) else {\n            return nil\n        }\n        bValue\
    \ = double\n    }\n    if aValue == bValue {\n        return nil\n    }\n    if\
    \ aValue > bValue {\n        switch a {\n        case .intValue(let int):\n  \
    \          return .intValue(int)\n        case .doubleValue(let double):\n   \
    \         return .doubleValue(double)\n        case .stringValue(let string):\n\
    \            return .stringValue(string)\n        }\n    } else {\n        switch\
    \ b {\n        case .intValue(let int):\n            return .intValue(int)\n \
    \       case .doubleValue(let double):\n            return .doubleValue(double)\n\
    \        case .stringValue(let string):\n            return .stringValue(string)\n\
    \        }\n    }\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) ->\
    \ Bool {\n    if left.count != right.count {\n        return false\n    }\n  \
    \  for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(compare_one(a: .intValue(1),\
    \ b: .intValue(2)) == .intValue(2))\nassert(compare_one(a: .intValue(1), b: .doubleValue(2.5))\
    \ == .doubleValue(2.5))\nassert(compare_one(a: .intValue(2), b: .intValue(3))\
    \ == .intValue(3))\nassert(compare_one(a: .intValue(5), b: .intValue(6)) == .intValue(6))\n\
    assert(compare_one(a: .intValue(1), b: .stringValue(\"2,3\")) == .stringValue(\"\
    2,3\"))\nassert(compare_one(a: .stringValue(\"5,1\"), b: .stringValue(\"6\"))\
    \ == .stringValue(\"6\"))\nassert(compare_one(a: .stringValue(\"1\"), b: .stringValue(\"\
    2\")) == .stringValue(\"2\"))\nassert(compare_one(a: .stringValue(\"1\"), b: .intValue(1))\
    \ == nil)"
  status: Exception
  stderr: 'tmpzkhsvvbo/tmpzkhsvvbo.swift:87: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b500f5b5c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b500f2acb6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b500f2ac988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b500f2ab7b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpzkhsvvbo                        0x00005573e1d8a78b <unavailable> + 10123

    5    libc.so.6                          0x00002b500f7a1460 __libc_start_main +
    245

    6    tmpzkhsvvbo                        0x00005573e1d89539 <unavailable> + 5433

    '
  stdout: ''
  timestamp: 1660013180
- exit_code: 1
  program: "\nenum Value: Equatable, Hashable {\n    case intValue(Int)\n    case\
    \ doubleValue(Double)\n    case stringValue(String)\n}\n\n            \n/// Create\
    \ a function that takes integers, floats, or strings representing\n/// real numbers,\
    \ and returns the larger variable in its given variable type.\n/// Return nil\
    \ if the values are equal.\n/// Note: If a real number is represented as a string,\
    \ the floating point might be . or ,\n/// >>> compare_one(a: .intValue(1), b:\
    \ .doubleValue(2.5))\n/// .doubleValue(2.5)\n/// >>> compare_one(a: .intValue(1),\
    \ b: .stringValue(\"2,3\"))\n/// .stringValue(\"2,3\")\n/// >>> compare_one(a:\
    \ .stringValue(\"5,1\"), b: .stringValue(\"6\"))\n/// .stringValue(\"6\")\n///\
    \ >>> compare_one(a: .stringValue(\"1\"), b: .intValue(1))\n/// nil\nfunc compare_one(a:\
    \ Value, b: Value) -> Value? {\n    let numberA = convert_to_float(value: a)\n\
    \    let numberB = convert_to_float(value: b)\n    if numberA > numberB {\n  \
    \      switch a {\n        case .intValue(let a):\n            return .intValue(a)\n\
    \        case .doubleValue(let a):\n            return .doubleValue(a)\n     \
    \   case .stringValue(let a):\n            return .stringValue(a)\n        }\n\
    \    } else if numberA < numberB {\n        switch b {\n        case .intValue(let\
    \ b):\n            return .intValue(b)\n        case .doubleValue(let b):\n  \
    \          return .doubleValue(b)\n        case .stringValue(let b):\n       \
    \     return .stringValue(b)\n        }\n    } else {\n        return nil\n  \
    \  }\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if\
    \ left.count != right.count {\n        return false\n    }\n    for (l, r) in\
    \ zip(left, right) {\n        if l != r {\n            return false\n        }\n\
    \    }\n    return true\n}\n            \nassert(compare_one(a: .intValue(1),\
    \ b: .intValue(2)) == .intValue(2))\nassert(compare_one(a: .intValue(1), b: .doubleValue(2.5))\
    \ == .doubleValue(2.5))\nassert(compare_one(a: .intValue(2), b: .intValue(3))\
    \ == .intValue(3))\nassert(compare_one(a: .intValue(5), b: .intValue(6)) == .intValue(6))\n\
    assert(compare_one(a: .intValue(1), b: .stringValue(\"2,3\")) == .stringValue(\"\
    2,3\"))\nassert(compare_one(a: .stringValue(\"5,1\"), b: .stringValue(\"6\"))\
    \ == .stringValue(\"6\"))\nassert(compare_one(a: .stringValue(\"1\"), b: .stringValue(\"\
    2\")) == .stringValue(\"2\"))\nassert(compare_one(a: .stringValue(\"1\"), b: .intValue(1))\
    \ == nil)"
  status: SyntaxError
  stderr: "/tmp/tmpoy4qgy_6.swift:22:19: error: cannot find 'convert_to_float' in\
    \ scope\n    let numberA = convert_to_float(value: a)\n                  ^~~~~~~~~~~~~~~~\n\
    /tmp/tmpoy4qgy_6.swift:23:19: error: cannot find 'convert_to_float' in scope\n\
    \    let numberB = convert_to_float(value: b)\n                  ^~~~~~~~~~~~~~~~\n"
  stdout: ''
  timestamp: 1660013180
- exit_code: 1
  program: "\nenum Value: Equatable, Hashable {\n    case intValue(Int)\n    case\
    \ doubleValue(Double)\n    case stringValue(String)\n}\n\n            \n/// Create\
    \ a function that takes integers, floats, or strings representing\n/// real numbers,\
    \ and returns the larger variable in its given variable type.\n/// Return nil\
    \ if the values are equal.\n/// Note: If a real number is represented as a string,\
    \ the floating point might be . or ,\n/// >>> compare_one(a: .intValue(1), b:\
    \ .doubleValue(2.5))\n/// .doubleValue(2.5)\n/// >>> compare_one(a: .intValue(1),\
    \ b: .stringValue(\"2,3\"))\n/// .stringValue(\"2,3\")\n/// >>> compare_one(a:\
    \ .stringValue(\"5,1\"), b: .stringValue(\"6\"))\n/// .stringValue(\"6\")\n///\
    \ >>> compare_one(a: .stringValue(\"1\"), b: .intValue(1))\n/// nil\nfunc compare_one(a:\
    \ Value, b: Value) -> Value? {\n    guard let a = a.value, let b = b.value else\
    \ { return nil }\n    return a > b ? a : b\n}\n\n\nfunc ==(left: [(Int, Int)],\
    \ right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n       \
    \ return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r\
    \ {\n            return false\n        }\n    }\n    return true\n}\n        \
    \    \nassert(compare_one(a: .intValue(1), b: .intValue(2)) == .intValue(2))\n\
    assert(compare_one(a: .intValue(1), b: .doubleValue(2.5)) == .doubleValue(2.5))\n\
    assert(compare_one(a: .intValue(2), b: .intValue(3)) == .intValue(3))\nassert(compare_one(a:\
    \ .intValue(5), b: .intValue(6)) == .intValue(6))\nassert(compare_one(a: .intValue(1),\
    \ b: .stringValue(\"2,3\")) == .stringValue(\"2,3\"))\nassert(compare_one(a: .stringValue(\"\
    5,1\"), b: .stringValue(\"6\")) == .stringValue(\"6\"))\nassert(compare_one(a:\
    \ .stringValue(\"1\"), b: .stringValue(\"2\")) == .stringValue(\"2\"))\nassert(compare_one(a:\
    \ .stringValue(\"1\"), b: .intValue(1)) == nil)"
  status: SyntaxError
  stderr: "/tmp/tmpiaukpmix.swift:22:21: error: value of type 'Value' has no member\
    \ 'value'\n    guard let a = a.value, let b = b.value else { return nil }\n  \
    \                ~ ^~~~~\n/tmp/tmpiaukpmix.swift:22:38: error: value of type 'Value'\
    \ has no member 'value'\n    guard let a = a.value, let b = b.value else { return\
    \ nil }\n                                   ~ ^~~~~\n"
  stdout: ''
  timestamp: 1660013180
- exit_code: 1
  program: "\nenum Value: Equatable, Hashable {\n    case intValue(Int)\n    case\
    \ doubleValue(Double)\n    case stringValue(String)\n}\n\n            \n/// Create\
    \ a function that takes integers, floats, or strings representing\n/// real numbers,\
    \ and returns the larger variable in its given variable type.\n/// Return nil\
    \ if the values are equal.\n/// Note: If a real number is represented as a string,\
    \ the floating point might be . or ,\n/// >>> compare_one(a: .intValue(1), b:\
    \ .doubleValue(2.5))\n/// .doubleValue(2.5)\n/// >>> compare_one(a: .intValue(1),\
    \ b: .stringValue(\"2,3\"))\n/// .stringValue(\"2,3\")\n/// >>> compare_one(a:\
    \ .stringValue(\"5,1\"), b: .stringValue(\"6\"))\n/// .stringValue(\"6\")\n///\
    \ >>> compare_one(a: .stringValue(\"1\"), b: .intValue(1))\n/// nil\nfunc compare_one(a:\
    \ Value, b: Value) -> Value? {\n    switch (a, b) {\n    case (.intValue(let a),\
    \ .intValue(let b)):\n        return a > b ? a : b\n    case (.doubleValue(let\
    \ a), .doubleValue(let b)):\n        return a > b ? a : b\n    case (.stringValue(let\
    \ a), .stringValue(let b)):\n        return Double(a) > Double(b) ? a : b\n  \
    \  case (.intValue(let a), .doubleValue(let b)):\n        return a > b ? a : b\n\
    \    case (.intValue(let a), .stringValue(let b)):\n        return Double(a) >\
    \ Double(b) ? a : b\n    case (.doubleValue(let a), .intValue(let b)):\n     \
    \   return a > b ? a : b\n    case (.doubleValue(let a), .stringValue(let b)):\n\
    \        return a > Double(b) ? a : b\n    case (.stringValue(let a), .intValue(let\
    \ b)):\n        return Double(a) > b ? a : b\n    case (.stringValue(let a), .doubleValue(let\
    \ b)):\n        return Double(a) > b ? a : b\n    }\n    return nil\n}\n\n\nfunc\
    \ ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count !=\
    \ right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(compare_one(a: .intValue(1), b: .intValue(2))\
    \ == .intValue(2))\nassert(compare_one(a: .intValue(1), b: .doubleValue(2.5))\
    \ == .doubleValue(2.5))\nassert(compare_one(a: .intValue(2), b: .intValue(3))\
    \ == .intValue(3))\nassert(compare_one(a: .intValue(5), b: .intValue(6)) == .intValue(6))\n\
    assert(compare_one(a: .intValue(1), b: .stringValue(\"2,3\")) == .stringValue(\"\
    2,3\"))\nassert(compare_one(a: .stringValue(\"5,1\"), b: .stringValue(\"6\"))\
    \ == .stringValue(\"6\"))\nassert(compare_one(a: .stringValue(\"1\"), b: .stringValue(\"\
    2\")) == .stringValue(\"2\"))\nassert(compare_one(a: .stringValue(\"1\"), b: .intValue(1))\
    \ == nil)"
  status: SyntaxError
  stderr: "/tmp/tmpo387s1x2.swift:24:22: error: cannot convert return expression of\
    \ type 'Int' to return type 'Value?'\n        return a > b ? a : b\n         \
    \      ~~~~~~^~~~~~~\n/tmp/tmpo387s1x2.swift:26:22: error: cannot convert return\
    \ expression of type 'Double' to return type 'Value?'\n        return a > b ?\
    \ a : b\n               ~~~~~~^~~~~~~\n/tmp/tmpo387s1x2.swift:28:28: error: value\
    \ of optional type 'Double?' must be unwrapped to a value of type 'Double'\n \
    \       return Double(a) > Double(b) ? a : b\n                           ^\n/tmp/tmpo387s1x2.swift:28:28:\
    \ note: coalesce using '??' to provide a default when the optional value contains\
    \ 'nil'\n        return Double(a) > Double(b) ? a : b\n                      \
    \     ^\n                                     ?? <#default value#>\n/tmp/tmpo387s1x2.swift:28:28:\
    \ note: force-unwrap using '!' to abort execution if the optional value contains\
    \ 'nil'\n        return Double(a) > Double(b) ? a : b\n                      \
    \     ^\n                                    !\n/tmp/tmpo387s1x2.swift:28:16:\
    \ error: value of optional type 'Double?' must be unwrapped to a value of type\
    \ 'Double'\n        return Double(a) > Double(b) ? a : b\n               ^\n/tmp/tmpo387s1x2.swift:28:16:\
    \ note: coalesce using '??' to provide a default when the optional value contains\
    \ 'nil'\n        return Double(a) > Double(b) ? a : b\n               ^\n    \
    \                     ?? <#default value#>\n/tmp/tmpo387s1x2.swift:28:16: note:\
    \ force-unwrap using '!' to abort execution if the optional value contains 'nil'\n\
    \        return Double(a) > Double(b) ? a : b\n               ^\n            \
    \            !\n/tmp/tmpo387s1x2.swift:28:38: error: cannot convert return expression\
    \ of type 'String' to return type 'Value?'\n        return Double(a) > Double(b)\
    \ ? a : b\n               ~~~~~~~~~~~~~~~~~~~~~~^~~~~~~\n/tmp/tmpo387s1x2.swift:30:20:\
    \ error: cannot convert value of type 'Double' to expected argument type 'Int'\n\
    \        return a > b ? a : b\n                   ^\n                   Int( )\n\
    /tmp/tmpo387s1x2.swift:30:22: error: cannot convert return "
  stdout: ''
  timestamp: 1660013180
- exit_code: -4
  program: "\nenum Value: Equatable, Hashable {\n    case intValue(Int)\n    case\
    \ doubleValue(Double)\n    case stringValue(String)\n}\n\n            \n/// Create\
    \ a function that takes integers, floats, or strings representing\n/// real numbers,\
    \ and returns the larger variable in its given variable type.\n/// Return nil\
    \ if the values are equal.\n/// Note: If a real number is represented as a string,\
    \ the floating point might be . or ,\n/// >>> compare_one(a: .intValue(1), b:\
    \ .doubleValue(2.5))\n/// .doubleValue(2.5)\n/// >>> compare_one(a: .intValue(1),\
    \ b: .stringValue(\"2,3\"))\n/// .stringValue(\"2,3\")\n/// >>> compare_one(a:\
    \ .stringValue(\"5,1\"), b: .stringValue(\"6\"))\n/// .stringValue(\"6\")\n///\
    \ >>> compare_one(a: .stringValue(\"1\"), b: .intValue(1))\n/// nil\nfunc compare_one(a:\
    \ Value, b: Value) -> Value? {\n    \n    let aDouble: Double?\n    let bDouble:\
    \ Double?\n    \n    switch a {\n    case .intValue(let value):\n        aDouble\
    \ = Double(value)\n    case .doubleValue(let value):\n        aDouble = value\n\
    \    case .stringValue(let value):\n        aDouble = Double(value)\n    }\n \
    \   \n    switch b {\n    case .intValue(let value):\n        bDouble = Double(value)\n\
    \    case .doubleValue(let value):\n        bDouble = value\n    case .stringValue(let\
    \ value):\n        bDouble = Double(value)\n    }\n    \n    if let aDouble =\
    \ aDouble, let bDouble = bDouble {\n        if aDouble > bDouble {\n         \
    \   return a\n        } else if aDouble < bDouble {\n            return b\n  \
    \      } else {\n            return nil\n        }\n    } else {\n        //handle\
    \ some error\n        return nil\n    }\n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(compare_one(a: .intValue(1), b: .intValue(2)) == .intValue(2))\nassert(compare_one(a:\
    \ .intValue(1), b: .doubleValue(2.5)) == .doubleValue(2.5))\nassert(compare_one(a:\
    \ .intValue(2), b: .intValue(3)) == .intValue(3))\nassert(compare_one(a: .intValue(5),\
    \ b: .intValue(6)) == .intValue(6))\nassert(compare_one(a: .intValue(1), b: .stringValue(\"\
    2,3\")) == .stringValue(\"2,3\"))\nassert(compare_one(a: .stringValue(\"5,1\"\
    ), b: .stringValue(\"6\")) == .stringValue(\"6\"))\nassert(compare_one(a: .stringValue(\"\
    1\"), b: .stringValue(\"2\")) == .stringValue(\"2\"))\nassert(compare_one(a: .stringValue(\"\
    1\"), b: .intValue(1)) == nil)"
  status: Exception
  stderr: 'tmp977xse39/tmp977xse39.swift:75: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b781e6d0c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b781e3c7b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b781e3c7988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b781e3c67b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmp977xse39                        0x000055ce39ea578b <unavailable> + 10123

    5    libc.so.6                          0x00002b781e8bc460 __libc_start_main +
    245

    6    tmp977xse39                        0x000055ce39ea4539 <unavailable> + 5433

    '
  stdout: ''
  timestamp: 1660013180
- exit_code: 1
  program: "\nenum Value: Equatable, Hashable {\n    case intValue(Int)\n    case\
    \ doubleValue(Double)\n    case stringValue(String)\n}\n\n            \n/// Create\
    \ a function that takes integers, floats, or strings representing\n/// real numbers,\
    \ and returns the larger variable in its given variable type.\n/// Return nil\
    \ if the values are equal.\n/// Note: If a real number is represented as a string,\
    \ the floating point might be . or ,\n/// >>> compare_one(a: .intValue(1), b:\
    \ .doubleValue(2.5))\n/// .doubleValue(2.5)\n/// >>> compare_one(a: .intValue(1),\
    \ b: .stringValue(\"2,3\"))\n/// .stringValue(\"2,3\")\n/// >>> compare_one(a:\
    \ .stringValue(\"5,1\"), b: .stringValue(\"6\"))\n/// .stringValue(\"6\")\n///\
    \ >>> compare_one(a: .stringValue(\"1\"), b: .intValue(1))\n/// nil\nfunc compare_one(a:\
    \ Value, b: Value) -> Value? {\n    switch a {\n    case .intValue(let int):\n\
    \        switch b {\n        case .intValue(let otherInt):\n            if int\
    \ > otherInt {\n                return a\n            } else if int < otherInt\
    \ {\n                return b\n            } else {\n                return nil\n\
    \            }\n        case .doubleValue(let double):\n            if Double(int)\
    \ > double {\n                return a\n            } else if Double(int) < double\
    \ {\n                return b\n            } else {\n                return nil\n\
    \            }\n        case .stringValue(let string):\n            if let double\
    \ = Double(string) {\n                if Double(int) > double {\n            \
    \        return a\n                } else if Double(int) < double {\n        \
    \            return b\n                } else {\n                    return nil\n\
    \                }\n            } else {\n                return nil\n       \
    \     }\n        }\n    case .doubleValue(let double):\n        switch b {\n \
    \       case .intValue(let int):\n            if double > Double(int) {\n    \
    \            return a\n            } else if double < Double(int) {\n        \
    \        return b\n            } else {\n                return nil\n        \
    \    }\n        case .doubleValue(let otherDouble):\n            if double > otherDouble\
    \ {\n                return a\n            } else if double < otherDouble {\n\
    \                return b\n            } else {\n                return nil\n\
    \            }\n        case .stringValue(let string):\n            if let otherDouble\
    \ = Double(string) {\n                if double > otherDouble {\n            \
    \        return a\n                } else if double < otherDouble {\n        \
    \            return b\n                } else {\n                    return nil\n\
    \                }\n            } else {\n                return nil\n       \
    \     }\n        }\n    case .stringValue(let string):\n        switch b {\n \
    \       case .intValue(let int):\n            if let double = Double(string) {\n\
    \                if double > Double(int) {\n                    return a\n   \
    \             } else if double < Double(int) {\n                    return b\n\
    \                } else {\n                    return nil\n                }\n\
    \            } else {\n                return nil\n            }\n        case\
    \ .doubleValue(let double):\n            if let otherDouble = Double(string) {\n\
    \                if otherDouble > double {\n                   \n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(compare_one(a: .intValue(1), b: .intValue(2)) == .intValue(2))\n\
    assert(compare_one(a: .intValue(1), b: .doubleValue(2.5)) == .doubleValue(2.5))\n\
    assert(compare_one(a: .intValue(2), b: .intValue(3)) == .intValue(3))\nassert(compare_one(a:\
    \ .intValue(5), b: .intValue(6)) == .intValue(6))\nassert(compare_one(a: .intValue(1),\
    \ b: .stringValue(\"2,3\")) == .stringValue(\"2,3\"))\nassert(compare_one(a: .stringValue(\"\
    5,1\"), b: .stringValue(\"6\")) == .stringValue(\"6\"))\nassert(compare_one(a:\
    \ .stringValue(\"1\"), b: .stringValue(\"2\")) == .stringValue(\"2\"))\nassert(compare_one(a:\
    \ .stringValue(\"1\"), b: .intValue(1)) == nil)"
  status: SyntaxError
  stderr: "/tmp/tmpwgxzdf1a.swift:125:66: error: expected '}' at end of brace statement\n\
    assert(compare_one(a: .stringValue(\"1\"), b: .intValue(1)) == nil)\n        \
    \                                                         ^\n/tmp/tmpwgxzdf1a.swift:100:49:\
    \ note: to match this opening '{'\n            if let otherDouble = Double(string)\
    \ {\n                                                ^\n/tmp/tmpwgxzdf1a.swift:125:66:\
    \ error: expected '}' at end of 'switch' statement\nassert(compare_one(a: .stringValue(\"\
    1\"), b: .intValue(1)) == nil)\n                                             \
    \                    ^\n/tmp/tmpwgxzdf1a.swift:86:18: note: to match this opening\
    \ '{'\n        switch b {\n                 ^\n/tmp/tmpwgxzdf1a.swift:125:66:\
    \ error: expected '}' at end of 'switch' statement\nassert(compare_one(a: .stringValue(\"\
    1\"), b: .intValue(1)) == nil)\n                                             \
    \                    ^\n/tmp/tmpwgxzdf1a.swift:22:14: note: to match this opening\
    \ '{'\n    switch a {\n             ^\n/tmp/tmpwgxzdf1a.swift:125:66: error: expected\
    \ '}' at end of brace statement\nassert(compare_one(a: .stringValue(\"1\"), b:\
    \ .intValue(1)) == nil)\n                                                    \
    \             ^\n/tmp/tmpwgxzdf1a.swift:21:48: note: to match this opening '{'\n\
    func compare_one(a: Value, b: Value) -> Value? {\n                           \
    \                    ^\n/tmp/tmpwgxzdf1a.swift:106:6: error: operator functions\
    \ can only be declared at global or in type scope\nfunc ==(left: [(Int, Int)],\
    \ right: [(Int, Int)]) -> Bool {\n     ^\n/tmp/tmpwgxzdf1a.swift:86:9: error:\
    \ switch must be exhaustive\n        switch b {\n        ^\n/tmp/tmpwgxzdf1a.swift:86:9:\
    \ note: add missing case: '.stringValue(_)'\n        switch b {\n        ^\n"
  stdout: ''
  timestamp: 1660013180
- exit_code: 1
  program: "\nenum Value: Equatable, Hashable {\n    case intValue(Int)\n    case\
    \ doubleValue(Double)\n    case stringValue(String)\n}\n\n            \n/// Create\
    \ a function that takes integers, floats, or strings representing\n/// real numbers,\
    \ and returns the larger variable in its given variable type.\n/// Return nil\
    \ if the values are equal.\n/// Note: If a real number is represented as a string,\
    \ the floating point might be . or ,\n/// >>> compare_one(a: .intValue(1), b:\
    \ .doubleValue(2.5))\n/// .doubleValue(2.5)\n/// >>> compare_one(a: .intValue(1),\
    \ b: .stringValue(\"2,3\"))\n/// .stringValue(\"2,3\")\n/// >>> compare_one(a:\
    \ .stringValue(\"5,1\"), b: .stringValue(\"6\"))\n/// .stringValue(\"6\")\n///\
    \ >>> compare_one(a: .stringValue(\"1\"), b: .intValue(1))\n/// nil\nfunc compare_one(a:\
    \ Value, b: Value) -> Value? {\n    // YOUR CODE HERE\n    switch a {\n    case\
    \ .intValue(let aInt):\n        switch b {\n        case .intValue(let bInt):\n\
    \            if (aInt > bInt) {\n                return a\n            } else\
    \ if (aInt < bInt) {\n                return b\n            } else {\n       \
    \         return nil\n            }\n        case .doubleValue(let bDouble):\n\
    \            if (Double(aInt) > bDouble) {\n                return a\n       \
    \     } else if (Double(aInt) < bDouble) {\n                return b\n       \
    \     } else {\n                return nil\n            }\n        case .stringValue(let\
    \ bString):\n            if (Double(aInt) > Double(bString)!) {\n            \
    \    return a\n            } else if (Double(aInt) < Double(bString)!) {\n   \
    \             return b\n            } else {\n                return nil\n   \
    \         }\n        }\n    case .doubleValue(let aDouble):\n        switch b\
    \ {\n        case .intValue(let bInt):\n            if (aDouble > Double(bInt))\
    \ {\n                return a\n            } else if (aDouble < Double(bInt))\
    \ {\n                return b\n            } else {\n                return nil\n\
    \            }\n        case .doubleValue(let bDouble):\n            if (aDouble\
    \ > bDouble) {\n                return a\n            } else if (aDouble < bDouble)\
    \ {\n                return b\n            } else {\n                return nil\n\
    \            }\n        case .stringValue(let bString):\n            if (aDouble\
    \ > Double(bString)!) {\n                return a\n            } else if (aDouble\
    \ < Double(bString)!) {\n                return b\n            } else {\n    \
    \            return nil\n            }\n        }\n    case .stringValue(let aString):\n\
    \        switch b {\n        case .intValue(let bInt):\n            if (Double(aString)!\
    \ > Double(bInt)) {\n                return a\n            } else if (Double(aString)!\
    \ < Double(bInt)) {\n                return b\n            } else {\n        \
    \        return nil\n            }\n        case .doubleValue(let bDouble):\n\
    \            if (Double(aString)! > bDouble)\n}\n\n\nfunc ==(left: [(Int, Int)],\
    \ right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n       \
    \ return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r\
    \ {\n            return false\n        }\n    }\n    return true\n}\n        \
    \    \nassert(compare_one(a: .intValue(1), b: .intValue(2)) == .intValue(2))\n\
    assert(compare_one(a: .intValue(1), b: .doubleValue(2.5)) == .doubleValue(2.5))\n\
    assert(compare_one(a: .intValue(2), b: .intValue(3)) == .intValue(3))\nassert(compare_one(a:\
    \ .intValue(5), b: .intValue(6)) == .intValue(6))\nassert(compare_one(a: .intValue(1),\
    \ b: .stringValue(\"2,3\")) == .stringValue(\"2,3\"))\nassert(compare_one(a: .stringValue(\"\
    5,1\"), b: .stringValue(\"6\")) == .stringValue(\"6\"))\nassert(compare_one(a:\
    \ .stringValue(\"1\"), b: .stringValue(\"2\")) == .stringValue(\"2\"))\nassert(compare_one(a:\
    \ .stringValue(\"1\"), b: .intValue(1)) == nil)"
  status: SyntaxError
  stderr: "/tmp/tmpu778_nfa.swift:89:44: error: expected '{' after 'if' condition\n\
    \            if (Double(aString)! > bDouble)\n                               \
    \            ^\n/tmp/tmpu778_nfa.swift:112:66: error: expected '}' at end of 'switch'\
    \ statement\nassert(compare_one(a: .stringValue(\"1\"), b: .intValue(1)) == nil)\n\
    \                                                                 ^\n/tmp/tmpu778_nfa.swift:23:14:\
    \ note: to match this opening '{'\n    switch a {\n             ^\n/tmp/tmpu778_nfa.swift:112:66:\
    \ error: expected '}' at end of brace statement\nassert(compare_one(a: .stringValue(\"\
    1\"), b: .intValue(1)) == nil)\n                                             \
    \                    ^\n/tmp/tmpu778_nfa.swift:21:48: note: to match this opening\
    \ '{'\nfunc compare_one(a: Value, b: Value) -> Value? {\n                    \
    \                           ^\n/tmp/tmpu778_nfa.swift:79:9: error: switch must\
    \ be exhaustive\n        switch b {\n        ^\n/tmp/tmpu778_nfa.swift:79:9: note:\
    \ add missing case: '.stringValue(_)'\n        switch b {\n        ^\n/tmp/tmpu778_nfa.swift:93:6:\
    \ error: operator functions can only be declared at global or in type scope\n\
    func ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n     ^\n"
  stdout: ''
  timestamp: 1660013180
- exit_code: -4
  program: "\nenum Value: Equatable, Hashable {\n    case intValue(Int)\n    case\
    \ doubleValue(Double)\n    case stringValue(String)\n}\n\n            \n/// Create\
    \ a function that takes integers, floats, or strings representing\n/// real numbers,\
    \ and returns the larger variable in its given variable type.\n/// Return nil\
    \ if the values are equal.\n/// Note: If a real number is represented as a string,\
    \ the floating point might be . or ,\n/// >>> compare_one(a: .intValue(1), b:\
    \ .doubleValue(2.5))\n/// .doubleValue(2.5)\n/// >>> compare_one(a: .intValue(1),\
    \ b: .stringValue(\"2,3\"))\n/// .stringValue(\"2,3\")\n/// >>> compare_one(a:\
    \ .stringValue(\"5,1\"), b: .stringValue(\"6\"))\n/// .stringValue(\"6\")\n///\
    \ >>> compare_one(a: .stringValue(\"1\"), b: .intValue(1))\n/// nil\nfunc compare_one(a:\
    \ Value, b: Value) -> Value? {\n    // Note: the Equatable protocol allows the\
    \ == operator to be used on the Value enum\n    // Note: the Hashable protocol\
    \ allows the Value enum to be used as dictionary keys\n    let type_dictionary\
    \ = [\n        (a: Value.intValue(0), b: Value.doubleValue(0.0), c: Value.stringValue(\"\
    0.0\")),\n        (a: Value.intValue(0), b: Value.stringValue(\"0.0\"), c: Value.stringValue(\"\
    0.0\")),\n        (a: Value.doubleValue(0.0), b: Value.stringValue(\"0.0\"), c:\
    \ Value.stringValue(\"0.0\"))\n    ]\n    for type_triple in type_dictionary {\n\
    \        if a == type_triple.a && b == type_triple.b {\n            return type_triple.c\n\
    \        }\n    }\n    return nil\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int,\
    \ Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n\
    \    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n          \
    \  return false\n        }\n    }\n    return true\n}\n            \nassert(compare_one(a:\
    \ .intValue(1), b: .intValue(2)) == .intValue(2))\nassert(compare_one(a: .intValue(1),\
    \ b: .doubleValue(2.5)) == .doubleValue(2.5))\nassert(compare_one(a: .intValue(2),\
    \ b: .intValue(3)) == .intValue(3))\nassert(compare_one(a: .intValue(5), b: .intValue(6))\
    \ == .intValue(6))\nassert(compare_one(a: .intValue(1), b: .stringValue(\"2,3\"\
    )) == .stringValue(\"2,3\"))\nassert(compare_one(a: .stringValue(\"5,1\"), b:\
    \ .stringValue(\"6\")) == .stringValue(\"6\"))\nassert(compare_one(a: .stringValue(\"\
    1\"), b: .stringValue(\"2\")) == .stringValue(\"2\"))\nassert(compare_one(a: .stringValue(\"\
    1\"), b: .intValue(1)) == nil)"
  status: Exception
  stderr: 'tmp06v77bi3/tmp06v77bi3.swift:50: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b88b4632c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b88b4329b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b88b4329988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b88b43287b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmp06v77bi3                        0x000055fa1bccacd6 <unavailable> + 7382

    5    libc.so.6                          0x00002b88b481e460 __libc_start_main +
    245

    6    tmp06v77bi3                        0x000055fa1bcca719 <unavailable> + 5913

    '
  stdout: ''
  timestamp: 1660013180
- exit_code: 1
  program: "\nenum Value: Equatable, Hashable {\n    case intValue(Int)\n    case\
    \ doubleValue(Double)\n    case stringValue(String)\n}\n\n            \n/// Create\
    \ a function that takes integers, floats, or strings representing\n/// real numbers,\
    \ and returns the larger variable in its given variable type.\n/// Return nil\
    \ if the values are equal.\n/// Note: If a real number is represented as a string,\
    \ the floating point might be . or ,\n/// >>> compare_one(a: .intValue(1), b:\
    \ .doubleValue(2.5))\n/// .doubleValue(2.5)\n/// >>> compare_one(a: .intValue(1),\
    \ b: .stringValue(\"2,3\"))\n/// .stringValue(\"2,3\")\n/// >>> compare_one(a:\
    \ .stringValue(\"5,1\"), b: .stringValue(\"6\"))\n/// .stringValue(\"6\")\n///\
    \ >>> compare_one(a: .stringValue(\"1\"), b: .intValue(1))\n/// nil\nfunc compare_one(a:\
    \ Value, b: Value) -> Value? {\n    var biggerValue: Value?\n    switch a {\n\
    \    case .intValue(let a):\n        switch b {\n        case .intValue(let b):\n\
    \            biggerValue = a > b ? a : b\n        case .doubleValue(let b):\n\
    \            biggerValue = a > b ? a : b\n        case .stringValue(let b):\n\
    \            let bFloat = (b as NSString).floatValue\n            biggerValue\
    \ = a > bFloat ? a : bFloat\n        }\n    case .doubleValue(let a):\n      \
    \  switch b {\n        case .intValue(let b):\n            biggerValue = a > Float(b)\
    \ ? a : b\n        case .doubleValue(let b):\n            biggerValue = a > b\
    \ ? a : b\n        case .stringValue(let b):\n            let bFloat = (b as NSString).floatValue\n\
    \            biggerValue = a > bFloat ? a : bFloat\n        }\n    case .stringValue(let\
    \ a):\n        switch b {\n        case .intValue(let b):\n            let aFloat\
    \ = (a as NSString).floatValue\n            biggerValue = aFloat > Float(b) ?\
    \ a : b\n        case .doubleValue(let b):\n            let aFloat = (a as NSString).floatValue\n\
    \            biggerValue = aFloat > b ? a : b\n        case .stringValue(let b):\n\
    \            let aFloat = (a as NSString).floatValue\n            let bFloat =\
    \ (b as NSString).floatValue\n            biggerValue = aFloat > bFloat ? a :\
    \ bFloat\n        }\n    }\n    return biggerValue\n}\n\n\nfunc ==(left: [(Int,\
    \ Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n\
    \        return false\n    }\n    for (l, r) in zip(left, right) {\n        if\
    \ l != r {\n            return false\n        }\n    }\n    return true\n}\n \
    \           \nassert(compare_one(a: .intValue(1), b: .intValue(2)) == .intValue(2))\n\
    assert(compare_one(a: .intValue(1), b: .doubleValue(2.5)) == .doubleValue(2.5))\n\
    assert(compare_one(a: .intValue(2), b: .intValue(3)) == .intValue(3))\nassert(compare_one(a:\
    \ .intValue(5), b: .intValue(6)) == .intValue(6))\nassert(compare_one(a: .intValue(1),\
    \ b: .stringValue(\"2,3\")) == .stringValue(\"2,3\"))\nassert(compare_one(a: .stringValue(\"\
    5,1\"), b: .stringValue(\"6\")) == .stringValue(\"6\"))\nassert(compare_one(a:\
    \ .stringValue(\"1\"), b: .stringValue(\"2\")) == .stringValue(\"2\"))\nassert(compare_one(a:\
    \ .stringValue(\"1\"), b: .intValue(1)) == nil)"
  status: SyntaxError
  stderr: "/tmp/tmpq_t9_199.swift:27:25: error: cannot assign value of type 'Int'\
    \ to type 'Value?'\n            biggerValue = a > b ? a : b\n                \
    \        ^\n/tmp/tmpq_t9_199.swift:29:25: error: cannot assign value of type 'Double'\
    \ to type 'Value?'\n            biggerValue = a > b ? a : b\n                \
    \        ^\n/tmp/tmpq_t9_199.swift:29:31: error: cannot convert value of type\
    \ 'Double' to expected argument type 'Int'\n            biggerValue = a > b ?\
    \ a : b\n                              ^\n                              Int( )\n\
    /tmp/tmpq_t9_199.swift:29:35: error: result values in '? :' expression have mismatching\
    \ types 'Int' and 'Double'\n            biggerValue = a > b ? a : b\n        \
    \                          ^\n                                  Double( )\n/tmp/tmpq_t9_199.swift:31:32:\
    \ error: cannot find type 'NSString' in scope\n            let bFloat = (b as\
    \ NSString).floatValue\n                               ^~~~~~~~\n/tmp/tmpq_t9_199.swift:31:42:\
    \ error: value of type 'String' has no member 'floatValue'\n            let bFloat\
    \ = (b as NSString).floatValue\n                         ~~~~~~~~~~~~~~~ ^~~~~~~~~~\n\
    /tmp/tmpq_t9_199.swift:32:40: error: result values in '? :' expression have mismatching\
    \ types 'Int' and 'Value?'\n            biggerValue = a > bFloat ? a : bFloat\n\
    \                                       ^\n/tmp/tmpq_t9_199.swift:37:29: error:\
    \ binary operator '>' cannot be applied to operands of type 'Double' and 'Float'\n\
    \            biggerValue = a > Float(b) ? a : b\n                          ~ ^\
    \ ~~~~~~~~\n/tmp/tmpq_t9_199.swift:37:25: error: cannot assign value of type 'Int'\
    \ to type 'Value?'\n            biggerValue = a > Float(b) ? a : b\n         \
    \               ^\n/tmp/tmpq_t9_199.swift:37:42: error: result values in '? :'\
    \ expression have mismatching types 'Double' and 'Int'\n            biggerValue\
    \ = a > Float(b) ? a : b\n                                         ^\n       \
    \                                  Int( )\n/tmp/tmpq_t9_199.swift:39:25: error:\
    \ cannot assign value of type 'Double' to type 'Value?'\n            biggerValu"
  stdout: ''
  timestamp: 1660013180
- exit_code: 1
  program: "\nenum Value: Equatable, Hashable {\n    case intValue(Int)\n    case\
    \ doubleValue(Double)\n    case stringValue(String)\n}\n\n            \n/// Create\
    \ a function that takes integers, floats, or strings representing\n/// real numbers,\
    \ and returns the larger variable in its given variable type.\n/// Return nil\
    \ if the values are equal.\n/// Note: If a real number is represented as a string,\
    \ the floating point might be . or ,\n/// >>> compare_one(a: .intValue(1), b:\
    \ .doubleValue(2.5))\n/// .doubleValue(2.5)\n/// >>> compare_one(a: .intValue(1),\
    \ b: .stringValue(\"2,3\"))\n/// .stringValue(\"2,3\")\n/// >>> compare_one(a:\
    \ .stringValue(\"5,1\"), b: .stringValue(\"6\"))\n/// .stringValue(\"6\")\n///\
    \ >>> compare_one(a: .stringValue(\"1\"), b: .intValue(1))\n/// nil\nfunc compare_one(a:\
    \ Value, b: Value) -> Value? {\n    switch (a, b) {\n    case (.intValue(let a),\
    \ .intValue(let b)):\n        return a > b ? a : b\n    case (.doubleValue(let\
    \ a), .doubleValue(let b)):\n        return a > b ? a : b\n    case (.stringValue(let\
    \ a), .stringValue(let b)):\n        return a > b ? a : b\n    default:\n    \
    \    return nil\n    }\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(compare_one(a:\
    \ .intValue(1), b: .intValue(2)) == .intValue(2))\nassert(compare_one(a: .intValue(1),\
    \ b: .doubleValue(2.5)) == .doubleValue(2.5))\nassert(compare_one(a: .intValue(2),\
    \ b: .intValue(3)) == .intValue(3))\nassert(compare_one(a: .intValue(5), b: .intValue(6))\
    \ == .intValue(6))\nassert(compare_one(a: .intValue(1), b: .stringValue(\"2,3\"\
    )) == .stringValue(\"2,3\"))\nassert(compare_one(a: .stringValue(\"5,1\"), b:\
    \ .stringValue(\"6\")) == .stringValue(\"6\"))\nassert(compare_one(a: .stringValue(\"\
    1\"), b: .stringValue(\"2\")) == .stringValue(\"2\"))\nassert(compare_one(a: .stringValue(\"\
    1\"), b: .intValue(1)) == nil)"
  status: SyntaxError
  stderr: "/tmp/tmp07haxekb.swift:24:22: error: cannot convert return expression of\
    \ type 'Int' to return type 'Value?'\n        return a > b ? a : b\n         \
    \      ~~~~~~^~~~~~~\n/tmp/tmp07haxekb.swift:26:22: error: cannot convert return\
    \ expression of type 'Double' to return type 'Value?'\n        return a > b ?\
    \ a : b\n               ~~~~~~^~~~~~~\n/tmp/tmp07haxekb.swift:28:22: error: cannot\
    \ convert return expression of type 'String' to return type 'Value?'\n       \
    \ return a > b ? a : b\n               ~~~~~~^~~~~~~\n"
  stdout: ''
  timestamp: 1660013180
- exit_code: 1
  program: "\nenum Value: Equatable, Hashable {\n    case intValue(Int)\n    case\
    \ doubleValue(Double)\n    case stringValue(String)\n}\n\n            \n/// Create\
    \ a function that takes integers, floats, or strings representing\n/// real numbers,\
    \ and returns the larger variable in its given variable type.\n/// Return nil\
    \ if the values are equal.\n/// Note: If a real number is represented as a string,\
    \ the floating point might be . or ,\n/// >>> compare_one(a: .intValue(1), b:\
    \ .doubleValue(2.5))\n/// .doubleValue(2.5)\n/// >>> compare_one(a: .intValue(1),\
    \ b: .stringValue(\"2,3\"))\n/// .stringValue(\"2,3\")\n/// >>> compare_one(a:\
    \ .stringValue(\"5,1\"), b: .stringValue(\"6\"))\n/// .stringValue(\"6\")\n///\
    \ >>> compare_one(a: .stringValue(\"1\"), b: .intValue(1))\n/// nil\nfunc compare_one(a:\
    \ Value, b: Value) -> Value? {\n    if case let .intValue(intA) = a, case let\
    \ .intValue(intB) = b {\n        return intA > intB ? a : intA < intB ? b : nil\n\
    \    } else if case let .doubleValue(doubleA) = a, case let .doubleValue(doubleB)\
    \ = b {\n        return doubleA > doubleB ? a : doubleA < doubleB ? b : nil\n\
    \    } else if case let .stringValue(stringA) = a, case let .stringValue(stringB)\
    \ = b {\n        let a = stringA.replacingOccurrences(of: \",\", with: \".\")\n\
    \        let b = stringB.replacingOccurrences(of: \",\", with: \".\")\n      \
    \  if let doubleA = Double(a), let doubleB = Double(b) {\n            return doubleA\
    \ > doubleB ? a : doubleA < doubleB ? b : nil\n        }\n    }\n    return nil\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(compare_one(a: .intValue(1), b: .intValue(2))\
    \ == .intValue(2))\nassert(compare_one(a: .intValue(1), b: .doubleValue(2.5))\
    \ == .doubleValue(2.5))\nassert(compare_one(a: .intValue(2), b: .intValue(3))\
    \ == .intValue(3))\nassert(compare_one(a: .intValue(5), b: .intValue(6)) == .intValue(6))\n\
    assert(compare_one(a: .intValue(1), b: .stringValue(\"2,3\")) == .stringValue(\"\
    2,3\"))\nassert(compare_one(a: .stringValue(\"5,1\"), b: .stringValue(\"6\"))\
    \ == .stringValue(\"6\"))\nassert(compare_one(a: .stringValue(\"1\"), b: .stringValue(\"\
    2\")) == .stringValue(\"2\"))\nassert(compare_one(a: .stringValue(\"1\"), b: .intValue(1))\
    \ == nil)"
  status: SyntaxError
  stderr: "/tmp/tmpmnxijnf1.swift:27:25: error: value of type 'String' has no member\
    \ 'replacingOccurrences'\n        let a = stringA.replacingOccurrences(of: \"\
    ,\", with: \".\")\n                ~~~~~~~ ^~~~~~~~~~~~~~~~~~~~\n/tmp/tmpmnxijnf1.swift:28:25:\
    \ error: value of type 'String' has no member 'replacingOccurrences'\n       \
    \ let b = stringB.replacingOccurrences(of: \",\", with: \".\")\n             \
    \   ~~~~~~~ ^~~~~~~~~~~~~~~~~~~~\n"
  stdout: ''
  timestamp: 1660013180
- exit_code: -4
  program: "\nenum Value: Equatable, Hashable {\n    case intValue(Int)\n    case\
    \ doubleValue(Double)\n    case stringValue(String)\n}\n\n            \n/// Create\
    \ a function that takes integers, floats, or strings representing\n/// real numbers,\
    \ and returns the larger variable in its given variable type.\n/// Return nil\
    \ if the values are equal.\n/// Note: If a real number is represented as a string,\
    \ the floating point might be . or ,\n/// >>> compare_one(a: .intValue(1), b:\
    \ .doubleValue(2.5))\n/// .doubleValue(2.5)\n/// >>> compare_one(a: .intValue(1),\
    \ b: .stringValue(\"2,3\"))\n/// .stringValue(\"2,3\")\n/// >>> compare_one(a:\
    \ .stringValue(\"5,1\"), b: .stringValue(\"6\"))\n/// .stringValue(\"6\")\n///\
    \ >>> compare_one(a: .stringValue(\"1\"), b: .intValue(1))\n/// nil\nfunc compare_one(a:\
    \ Value, b: Value) -> Value? {\n    // TODO: Write some code to solve this coding\
    \ challenge\n    return nil\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int,\
    \ Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n\
    \    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n          \
    \  return false\n        }\n    }\n    return true\n}\n            \nassert(compare_one(a:\
    \ .intValue(1), b: .intValue(2)) == .intValue(2))\nassert(compare_one(a: .intValue(1),\
    \ b: .doubleValue(2.5)) == .doubleValue(2.5))\nassert(compare_one(a: .intValue(2),\
    \ b: .intValue(3)) == .intValue(3))\nassert(compare_one(a: .intValue(5), b: .intValue(6))\
    \ == .intValue(6))\nassert(compare_one(a: .intValue(1), b: .stringValue(\"2,3\"\
    )) == .stringValue(\"2,3\"))\nassert(compare_one(a: .stringValue(\"5,1\"), b:\
    \ .stringValue(\"6\")) == .stringValue(\"6\"))\nassert(compare_one(a: .stringValue(\"\
    1\"), b: .stringValue(\"2\")) == .stringValue(\"2\"))\nassert(compare_one(a: .stringValue(\"\
    1\"), b: .intValue(1)) == nil)"
  status: Exception
  stderr: 'tmpo1hngg84/tmpo1hngg84.swift:39: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002af17ff61c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002af17fc58b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002af17fc58988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002af17fc577b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpo1hngg84                        0x00005621d60b5a56 <unavailable> + 6742

    5    libc.so.6                          0x00002af18014d460 __libc_start_main +
    245

    6    tmpo1hngg84                        0x00005621d60b5499 <unavailable> + 5273

    '
  stdout: ''
  timestamp: 1660013180
- exit_code: 1
  program: "\nenum Value: Equatable, Hashable {\n    case intValue(Int)\n    case\
    \ doubleValue(Double)\n    case stringValue(String)\n}\n\n            \n/// Create\
    \ a function that takes integers, floats, or strings representing\n/// real numbers,\
    \ and returns the larger variable in its given variable type.\n/// Return nil\
    \ if the values are equal.\n/// Note: If a real number is represented as a string,\
    \ the floating point might be . or ,\n/// >>> compare_one(a: .intValue(1), b:\
    \ .doubleValue(2.5))\n/// .doubleValue(2.5)\n/// >>> compare_one(a: .intValue(1),\
    \ b: .stringValue(\"2,3\"))\n/// .stringValue(\"2,3\")\n/// >>> compare_one(a:\
    \ .stringValue(\"5,1\"), b: .stringValue(\"6\"))\n/// .stringValue(\"6\")\n///\
    \ >>> compare_one(a: .stringValue(\"1\"), b: .intValue(1))\n/// nil\nfunc compare_one(a:\
    \ Value, b: Value) -> Value? {\n    \n    let aDouble = valueToDouble(a)\n   \
    \ let bDouble = valueToDouble(b)\n    \n    return aDouble > bDouble ? doubleToValue(aDouble)\
    \ : (bDouble > aDouble ? doubleToValue(bDouble) : nil)\n}\n\n\nfunc ==(left: [(Int,\
    \ Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n\
    \        return false\n    }\n    for (l, r) in zip(left, right) {\n        if\
    \ l != r {\n            return false\n        }\n    }\n    return true\n}\n \
    \           \nassert(compare_one(a: .intValue(1), b: .intValue(2)) == .intValue(2))\n\
    assert(compare_one(a: .intValue(1), b: .doubleValue(2.5)) == .doubleValue(2.5))\n\
    assert(compare_one(a: .intValue(2), b: .intValue(3)) == .intValue(3))\nassert(compare_one(a:\
    \ .intValue(5), b: .intValue(6)) == .intValue(6))\nassert(compare_one(a: .intValue(1),\
    \ b: .stringValue(\"2,3\")) == .stringValue(\"2,3\"))\nassert(compare_one(a: .stringValue(\"\
    5,1\"), b: .stringValue(\"6\")) == .stringValue(\"6\"))\nassert(compare_one(a:\
    \ .stringValue(\"1\"), b: .stringValue(\"2\")) == .stringValue(\"2\"))\nassert(compare_one(a:\
    \ .stringValue(\"1\"), b: .intValue(1)) == nil)"
  status: SyntaxError
  stderr: "/tmp/tmpz4bqlhcu.swift:23:19: error: cannot find 'valueToDouble' in scope\n\
    \    let aDouble = valueToDouble(a)\n                  ^~~~~~~~~~~~~\n/tmp/tmpz4bqlhcu.swift:24:19:\
    \ error: cannot find 'valueToDouble' in scope\n    let bDouble = valueToDouble(b)\n\
    \                  ^~~~~~~~~~~~~\n/tmp/tmpz4bqlhcu.swift:26:32: error: cannot\
    \ find 'doubleToValue' in scope\n    return aDouble > bDouble ? doubleToValue(aDouble)\
    \ : (bDouble > aDouble ? doubleToValue(bDouble) : nil)\n                     \
    \          ^~~~~~~~~~~~~\n/tmp/tmpz4bqlhcu.swift:26:78: error: cannot find 'doubleToValue'\
    \ in scope\n    return aDouble > bDouble ? doubleToValue(aDouble) : (bDouble >\
    \ aDouble ? doubleToValue(bDouble) : nil)\n                                  \
    \                                           ^~~~~~~~~~~~~\n"
  stdout: ''
  timestamp: 1660013180
- exit_code: -4
  program: "\nenum Value: Equatable, Hashable {\n    case intValue(Int)\n    case\
    \ doubleValue(Double)\n    case stringValue(String)\n}\n\n            \n/// Create\
    \ a function that takes integers, floats, or strings representing\n/// real numbers,\
    \ and returns the larger variable in its given variable type.\n/// Return nil\
    \ if the values are equal.\n/// Note: If a real number is represented as a string,\
    \ the floating point might be . or ,\n/// >>> compare_one(a: .intValue(1), b:\
    \ .doubleValue(2.5))\n/// .doubleValue(2.5)\n/// >>> compare_one(a: .intValue(1),\
    \ b: .stringValue(\"2,3\"))\n/// .stringValue(\"2,3\")\n/// >>> compare_one(a:\
    \ .stringValue(\"5,1\"), b: .stringValue(\"6\"))\n/// .stringValue(\"6\")\n///\
    \ >>> compare_one(a: .stringValue(\"1\"), b: .intValue(1))\n/// nil\nfunc compare_one(a:\
    \ Value, b: Value) -> Value? {\n    return nil\n}\n\n\nfunc ==(left: [(Int, Int)],\
    \ right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n       \
    \ return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r\
    \ {\n            return false\n        }\n    }\n    return true\n}\n        \
    \    \nassert(compare_one(a: .intValue(1), b: .intValue(2)) == .intValue(2))\n\
    assert(compare_one(a: .intValue(1), b: .doubleValue(2.5)) == .doubleValue(2.5))\n\
    assert(compare_one(a: .intValue(2), b: .intValue(3)) == .intValue(3))\nassert(compare_one(a:\
    \ .intValue(5), b: .intValue(6)) == .intValue(6))\nassert(compare_one(a: .intValue(1),\
    \ b: .stringValue(\"2,3\")) == .stringValue(\"2,3\"))\nassert(compare_one(a: .stringValue(\"\
    5,1\"), b: .stringValue(\"6\")) == .stringValue(\"6\"))\nassert(compare_one(a:\
    \ .stringValue(\"1\"), b: .stringValue(\"2\")) == .stringValue(\"2\"))\nassert(compare_one(a:\
    \ .stringValue(\"1\"), b: .intValue(1)) == nil)"
  status: Exception
  stderr: 'tmpllswmh2d/tmpllswmh2d.swift:38: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b05c2ae8c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b05c27dfb6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b05c27df988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b05c27de7b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpllswmh2d                        0x000055f806e32a56 <unavailable> + 6742

    5    libc.so.6                          0x00002b05c2cd4460 __libc_start_main +
    245

    6    tmpllswmh2d                        0x000055f806e32499 <unavailable> + 5273

    '
  stdout: ''
  timestamp: 1660013179
- exit_code: -4
  program: "\nenum Value: Equatable, Hashable {\n    case intValue(Int)\n    case\
    \ doubleValue(Double)\n    case stringValue(String)\n}\n\n            \n/// Create\
    \ a function that takes integers, floats, or strings representing\n/// real numbers,\
    \ and returns the larger variable in its given variable type.\n/// Return nil\
    \ if the values are equal.\n/// Note: If a real number is represented as a string,\
    \ the floating point might be . or ,\n/// >>> compare_one(a: .intValue(1), b:\
    \ .doubleValue(2.5))\n/// .doubleValue(2.5)\n/// >>> compare_one(a: .intValue(1),\
    \ b: .stringValue(\"2,3\"))\n/// .stringValue(\"2,3\")\n/// >>> compare_one(a:\
    \ .stringValue(\"5,1\"), b: .stringValue(\"6\"))\n/// .stringValue(\"6\")\n///\
    \ >>> compare_one(a: .stringValue(\"1\"), b: .intValue(1))\n/// nil\nfunc compare_one(a:\
    \ Value, b: Value) -> Value? {\n    // Hint: This function is deceptively simple.\n\
    \    // Again, use switch-case and pattern matching to your advantage.\n    switch\
    \ (a, b) {\n    case (.intValue(let first), .intValue(let second)):\n        return\
    \ first > second ? .intValue(first) : .intValue(second)\n    case (.doubleValue(let\
    \ first), .doubleValue(let second)):\n        return first > second ? .doubleValue(first)\
    \ : .doubleValue(second)\n    case (.stringValue(let first), .stringValue(let\
    \ second)):\n        return first > second ? .stringValue(first) : .stringValue(second)\n\
    \    case (.stringValue(let first), .intValue(let second)):\n        if let firstValue\
    \ = Double(first) {\n            return firstValue > Double(second) ? .stringValue(first)\
    \ : .intValue(second)\n        }\n    case (.stringValue(let first), .doubleValue(let\
    \ second)):\n        if let firstValue = Double(first) {\n            return firstValue\
    \ > second ? .stringValue(first) : .doubleValue(second)\n        }\n    case (.intValue(let\
    \ first), .stringValue(let second)):\n        if let secondValue = Double(second)\
    \ {\n            return Double(first) > secondValue ? .intValue(first) : .stringValue(second)\n\
    \        }\n    case (.doubleValue(let first), .stringValue(let second)):\n  \
    \      if let secondValue = Double(second) {\n            return first > secondValue\
    \ ? .doubleValue(first) : .stringValue(second)\n        }\n    default:\n    \
    \    return nil\n    }\n    return nil\n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(compare_one(a: .intValue(1), b: .intValue(2)) == .intValue(2))\nassert(compare_one(a:\
    \ .intValue(1), b: .doubleValue(2.5)) == .doubleValue(2.5))\nassert(compare_one(a:\
    \ .intValue(2), b: .intValue(3)) == .intValue(3))\nassert(compare_one(a: .intValue(5),\
    \ b: .intValue(6)) == .intValue(6))\nassert(compare_one(a: .intValue(1), b: .stringValue(\"\
    2,3\")) == .stringValue(\"2,3\"))\nassert(compare_one(a: .stringValue(\"5,1\"\
    ), b: .stringValue(\"6\")) == .stringValue(\"6\"))\nassert(compare_one(a: .stringValue(\"\
    1\"), b: .stringValue(\"2\")) == .stringValue(\"2\"))\nassert(compare_one(a: .stringValue(\"\
    1\"), b: .intValue(1)) == nil)"
  status: Exception
  stderr: 'tmply4f0102/tmply4f0102.swift:67: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002ab289363c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002ab28905ab6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002ab28905a988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002ab2890597b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmply4f0102                        0x000055981132ce84 <unavailable> + 7812

    5    libc.so.6                          0x00002ab28954f460 __libc_start_main +
    245

    6    tmply4f0102                        0x000055981132c5c9 <unavailable> + 5577

    '
  stdout: ''
  timestamp: 1660013180
- exit_code: 1
  program: "\nenum Value: Equatable, Hashable {\n    case intValue(Int)\n    case\
    \ doubleValue(Double)\n    case stringValue(String)\n}\n\n            \n/// Create\
    \ a function that takes integers, floats, or strings representing\n/// real numbers,\
    \ and returns the larger variable in its given variable type.\n/// Return nil\
    \ if the values are equal.\n/// Note: If a real number is represented as a string,\
    \ the floating point might be . or ,\n/// >>> compare_one(a: .intValue(1), b:\
    \ .doubleValue(2.5))\n/// .doubleValue(2.5)\n/// >>> compare_one(a: .intValue(1),\
    \ b: .stringValue(\"2,3\"))\n/// .stringValue(\"2,3\")\n/// >>> compare_one(a:\
    \ .stringValue(\"5,1\"), b: .stringValue(\"6\"))\n/// .stringValue(\"6\")\n///\
    \ >>> compare_one(a: .stringValue(\"1\"), b: .intValue(1))\n/// nil\nfunc compare_one(a:\
    \ Value, b: Value) -> Value? {\n    // TODO\n    let lhs: Double\n    let rhs:\
    \ Double\n    switch a {\n    case .intValue(let intValue):\n        lhs = Double(intValue)\n\
    \    case .doubleValue(let doubleValue):\n        lhs = doubleValue\n    case\
    \ .stringValue(let stringValue):\n        lhs = Double(stringValue.replacingOccurrences(of:\
    \ \",\", with: \".\")) ?? 0\n    }\n    switch b {\n    case .intValue(let intValue):\n\
    \        rhs = Double(intValue)\n    case .doubleValue(let doubleValue):\n   \
    \     rhs = doubleValue\n    case .stringValue(let stringValue):\n        rhs\
    \ = Double(stringValue.replacingOccurrences(of: \",\", with: \".\")) ?? 0\n  \
    \  }\n    if lhs == rhs {\n        return nil\n    } else if lhs > rhs {\n   \
    \     return a\n    } else {\n        return b\n    }\n}\n\n\nfunc ==(left: [(Int,\
    \ Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n\
    \        return false\n    }\n    for (l, r) in zip(left, right) {\n        if\
    \ l != r {\n            return false\n        }\n    }\n    return true\n}\n \
    \           \nassert(compare_one(a: .intValue(1), b: .intValue(2)) == .intValue(2))\n\
    assert(compare_one(a: .intValue(1), b: .doubleValue(2.5)) == .doubleValue(2.5))\n\
    assert(compare_one(a: .intValue(2), b: .intValue(3)) == .intValue(3))\nassert(compare_one(a:\
    \ .intValue(5), b: .intValue(6)) == .intValue(6))\nassert(compare_one(a: .intValue(1),\
    \ b: .stringValue(\"2,3\")) == .stringValue(\"2,3\"))\nassert(compare_one(a: .stringValue(\"\
    5,1\"), b: .stringValue(\"6\")) == .stringValue(\"6\"))\nassert(compare_one(a:\
    \ .stringValue(\"1\"), b: .stringValue(\"2\")) == .stringValue(\"2\"))\nassert(compare_one(a:\
    \ .stringValue(\"1\"), b: .intValue(1)) == nil)"
  status: SyntaxError
  stderr: "/tmp/tmpwph30jf0.swift:31:34: error: value of type 'String' has no member\
    \ 'replacingOccurrences'\n        lhs = Double(stringValue.replacingOccurrences(of:\
    \ \",\", with: \".\")) ?? 0\n                     ~~~~~~~~~~~ ^~~~~~~~~~~~~~~~~~~~\n\
    /tmp/tmpwph30jf0.swift:39:34: error: value of type 'String' has no member 'replacingOccurrences'\n\
    \        rhs = Double(stringValue.replacingOccurrences(of: \",\", with: \".\"\
    )) ?? 0\n                     ~~~~~~~~~~~ ^~~~~~~~~~~~~~~~~~~~\n"
  stdout: ''
  timestamp: 1660013180
- exit_code: -4
  program: "\nenum Value: Equatable, Hashable {\n    case intValue(Int)\n    case\
    \ doubleValue(Double)\n    case stringValue(String)\n}\n\n            \n/// Create\
    \ a function that takes integers, floats, or strings representing\n/// real numbers,\
    \ and returns the larger variable in its given variable type.\n/// Return nil\
    \ if the values are equal.\n/// Note: If a real number is represented as a string,\
    \ the floating point might be . or ,\n/// >>> compare_one(a: .intValue(1), b:\
    \ .doubleValue(2.5))\n/// .doubleValue(2.5)\n/// >>> compare_one(a: .intValue(1),\
    \ b: .stringValue(\"2,3\"))\n/// .stringValue(\"2,3\")\n/// >>> compare_one(a:\
    \ .stringValue(\"5,1\"), b: .stringValue(\"6\"))\n/// .stringValue(\"6\")\n///\
    \ >>> compare_one(a: .stringValue(\"1\"), b: .intValue(1))\n/// nil\nfunc compare_one(a:\
    \ Value, b: Value) -> Value? {\n    guard a != b else { return nil }\n    switch\
    \ (a, b) {\n    case let (.intValue(a), .intValue(b)):\n        return .intValue(max(a,\
    \ b))\n    case let (.intValue(a), .doubleValue(b)):\n        return .doubleValue(max(Double(a),\
    \ b))\n    case let (.intValue(a), .stringValue(b)):\n        return .stringValue(max(String(a),\
    \ b))\n    case let (.doubleValue(a), .intValue(b)):\n        return .doubleValue(max(a,\
    \ Double(b)))\n    case let (.doubleValue(a), .doubleValue(b)):\n        return\
    \ .doubleValue(max(a, b))\n    case let (.doubleValue(a), .stringValue(b)):\n\
    \        return .stringValue(max(String(a), b))\n    case let (.stringValue(a),\
    \ .intValue(b)):\n        return .stringValue(max(a, String(b)))\n    case let\
    \ (.stringValue(a), .doubleValue(b)):\n        return .stringValue(max(a, String(b)))\n\
    \    case let (.stringValue(a), .stringValue(b)):\n        return .stringValue(max(a,\
    \ b))\n    }\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool\
    \ {\n    if left.count != right.count {\n        return false\n    }\n    for\
    \ (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(compare_one(a: .intValue(1),\
    \ b: .intValue(2)) == .intValue(2))\nassert(compare_one(a: .intValue(1), b: .doubleValue(2.5))\
    \ == .doubleValue(2.5))\nassert(compare_one(a: .intValue(2), b: .intValue(3))\
    \ == .intValue(3))\nassert(compare_one(a: .intValue(5), b: .intValue(6)) == .intValue(6))\n\
    assert(compare_one(a: .intValue(1), b: .stringValue(\"2,3\")) == .stringValue(\"\
    2,3\"))\nassert(compare_one(a: .stringValue(\"5,1\"), b: .stringValue(\"6\"))\
    \ == .stringValue(\"6\"))\nassert(compare_one(a: .stringValue(\"1\"), b: .stringValue(\"\
    2\")) == .stringValue(\"2\"))\nassert(compare_one(a: .stringValue(\"1\"), b: .intValue(1))\
    \ == nil)"
  status: Exception
  stderr: 'tmpi4g_p0na/tmpi4g_p0na.swift:65: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b6c58ab0c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b6c587a7b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b6c587a7988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b6c587a67b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpi4g_p0na                        0x000055a3d739d24a <unavailable> + 12874

    5    libc.so.6                          0x00002b6c58c9c460 __libc_start_main +
    245

    6    tmpi4g_p0na                        0x000055a3d739b6c9 <unavailable> + 5833

    '
  stdout: ''
  timestamp: 1660013180
- exit_code: 1
  program: "\nenum Value: Equatable, Hashable {\n    case intValue(Int)\n    case\
    \ doubleValue(Double)\n    case stringValue(String)\n}\n\n            \n/// Create\
    \ a function that takes integers, floats, or strings representing\n/// real numbers,\
    \ and returns the larger variable in its given variable type.\n/// Return nil\
    \ if the values are equal.\n/// Note: If a real number is represented as a string,\
    \ the floating point might be . or ,\n/// >>> compare_one(a: .intValue(1), b:\
    \ .doubleValue(2.5))\n/// .doubleValue(2.5)\n/// >>> compare_one(a: .intValue(1),\
    \ b: .stringValue(\"2,3\"))\n/// .stringValue(\"2,3\")\n/// >>> compare_one(a:\
    \ .stringValue(\"5,1\"), b: .stringValue(\"6\"))\n/// .stringValue(\"6\")\n///\
    \ >>> compare_one(a: .stringValue(\"1\"), b: .intValue(1))\n/// nil\nfunc compare_one(a:\
    \ Value, b: Value) -> Value? {\n    switch (a, b) {\n    case (.intValue(let x),\
    \ .intValue(let y)):\n        return x > y ? .intValue(x) : .intValue(y)\n   \
    \ case (.doubleValue(let x), .doubleValue(let y)):\n        return x > y ? .doubleValue(x)\
    \ : .doubleValue(y)\n    case (.stringValue(let x), .stringValue(let y)):\n  \
    \      return x > y ? .stringValue(x) : .stringValue(y)\n    case (.intValue(let\
    \ x), .doubleValue(let y)):\n        return x > y ? .intValue(x) : .doubleValue(y)\n\
    \    case (.intValue(let x), .stringValue(let y)):\n        return x > y ? .intValue(x)\
    \ : .stringValue(y)\n    case (.doubleValue(let x), .intValue(let y)):\n     \
    \   return x > y ? .doubleValue(x) : .intValue(y)\n    case (.doubleValue(let\
    \ x), .stringValue(let y)):\n        return x > y ? .doubleValue(x) : .stringValue(y)\n\
    \    case (.stringValue(let x), .intValue(let y)):\n        return x > y ? .stringValue(x)\
    \ : .intValue(y)\n    case (.stringValue(let x), .doubleValue(let y)):\n     \
    \   return x > y ? .stringValue(x) : .doubleValue(y)\n    default:\n        return\
    \ nil\n    }\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool\
    \ {\n    if left.count != right.count {\n        return false\n    }\n    for\
    \ (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(compare_one(a: .intValue(1),\
    \ b: .intValue(2)) == .intValue(2))\nassert(compare_one(a: .intValue(1), b: .doubleValue(2.5))\
    \ == .doubleValue(2.5))\nassert(compare_one(a: .intValue(2), b: .intValue(3))\
    \ == .intValue(3))\nassert(compare_one(a: .intValue(5), b: .intValue(6)) == .intValue(6))\n\
    assert(compare_one(a: .intValue(1), b: .stringValue(\"2,3\")) == .stringValue(\"\
    2,3\"))\nassert(compare_one(a: .stringValue(\"5,1\"), b: .stringValue(\"6\"))\
    \ == .stringValue(\"6\"))\nassert(compare_one(a: .stringValue(\"1\"), b: .stringValue(\"\
    2\")) == .stringValue(\"2\"))\nassert(compare_one(a: .stringValue(\"1\"), b: .intValue(1))\
    \ == nil)"
  status: SyntaxError
  stderr: "/tmp/tmpe718pn1z.swift:30:20: error: cannot convert value of type 'Double'\
    \ to expected argument type 'Int'\n        return x > y ? .intValue(x) : .doubleValue(y)\n\
    \                   ^\n                   Int( )\n/tmp/tmpe718pn1z.swift:32:20:\
    \ error: cannot convert value of type 'String' to expected argument type 'Int'\n\
    \        return x > y ? .intValue(x) : .stringValue(y)\n                   ^\n\
    /tmp/tmpe718pn1z.swift:34:16: error: cannot convert value of type 'Double' to\
    \ expected argument type 'Int'\n        return x > y ? .doubleValue(x) : .intValue(y)\n\
    \               ^\n               Int( )\n/tmp/tmpe718pn1z.swift:36:18: error:\
    \ binary operator '>' cannot be applied to operands of type 'Double' and 'String'\n\
    \        return x > y ? .doubleValue(x) : .stringValue(y)\n               ~ ^\
    \ ~\n/tmp/tmpe718pn1z.swift:38:16: error: cannot convert value of type 'String'\
    \ to expected argument type 'Int'\n        return x > y ? .stringValue(x) : .intValue(y)\n\
    \               ^\n/tmp/tmpe718pn1z.swift:40:18: error: binary operator '>' cannot\
    \ be applied to operands of type 'String' and 'Double'\n        return x > y ?\
    \ .stringValue(x) : .doubleValue(y)\n               ~ ^ ~\n"
  stdout: ''
  timestamp: 1660013180
- exit_code: 1
  program: "\nenum Value: Equatable, Hashable {\n    case intValue(Int)\n    case\
    \ doubleValue(Double)\n    case stringValue(String)\n}\n\n            \n/// Create\
    \ a function that takes integers, floats, or strings representing\n/// real numbers,\
    \ and returns the larger variable in its given variable type.\n/// Return nil\
    \ if the values are equal.\n/// Note: If a real number is represented as a string,\
    \ the floating point might be . or ,\n/// >>> compare_one(a: .intValue(1), b:\
    \ .doubleValue(2.5))\n/// .doubleValue(2.5)\n/// >>> compare_one(a: .intValue(1),\
    \ b: .stringValue(\"2,3\"))\n/// .stringValue(\"2,3\")\n/// >>> compare_one(a:\
    \ .stringValue(\"5,1\"), b: .stringValue(\"6\"))\n/// .stringValue(\"6\")\n///\
    \ >>> compare_one(a: .stringValue(\"1\"), b: .intValue(1))\n/// nil\nfunc compare_one(a:\
    \ Value, b: Value) -> Value? {\n    switch (a, b) {\n    case let (.intValue(a),\
    \ .intValue(b)) where a > b:\n        return .intValue(a)\n    case let (.intValue(a),\
    \ .intValue(b)) where a < b:\n        return .intValue(b)\n    case let (.intValue(a),\
    \ .doubleValue(b)) where a > b:\n        return .intValue(a)\n    case let (.intValue(a),\
    \ .doubleValue(b)) where a < b:\n        return .doubleValue(b)\n    case let\
    \ (.intValue(a), .stringValue(b)) where a > Int(b.replacingOccurrences(of: \"\
    ,\", with: \".\"))!:\n        return .intValue(a)\n    case let (.intValue(a),\
    \ .stringValue(b)) where a < Int(b.replacingOccurrences(of: \",\", with: \".\"\
    ))!:\n        return .stringValue(b)\n    case let (.doubleValue(a), .intValue(b))\
    \ where a > b:\n        return .doubleValue(a)\n    case let (.doubleValue(a),\
    \ .intValue(b)) where a < b:\n        return .intValue(b)\n    case let (.doubleValue(a),\
    \ .doubleValue(b)) where a > b:\n        return .doubleValue(a)\n    case let\
    \ (.doubleValue(a), .doubleValue(b)) where a < b:\n        return .doubleValue(b)\n\
    \    case let (.doubleValue(a), .stringValue(b)) where a > Double(b.replacingOccurrences(of:\
    \ \",\", with: \".\"))!:\n        return .doubleValue(a)\n    case let (.doubleValue(a),\
    \ .stringValue(b)) where a < Double(b.replacingOccurrences(of: \",\", with: \"\
    .\"))!:\n        return .stringValue(b)\n    case let (.stringValue(a), .intValue(b))\
    \ where Double(a.replacingOccurrences(of: \",\", with: \".\"))! > Double(b):\n\
    \        return .stringValue(a)\n    case let (.stringValue(a), .intValue(b\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(compare_one(a: .intValue(1), b: .intValue(2))\
    \ == .intValue(2))\nassert(compare_one(a: .intValue(1), b: .doubleValue(2.5))\
    \ == .doubleValue(2.5))\nassert(compare_one(a: .intValue(2), b: .intValue(3))\
    \ == .intValue(3))\nassert(compare_one(a: .intValue(5), b: .intValue(6)) == .intValue(6))\n\
    assert(compare_one(a: .intValue(1), b: .stringValue(\"2,3\")) == .stringValue(\"\
    2,3\"))\nassert(compare_one(a: .stringValue(\"5,1\"), b: .stringValue(\"6\"))\
    \ == .stringValue(\"6\"))\nassert(compare_one(a: .stringValue(\"1\"), b: .stringValue(\"\
    2\")) == .stringValue(\"2\"))\nassert(compare_one(a: .stringValue(\"1\"), b: .intValue(1))\
    \ == nil)"
  status: SyntaxError
  stderr: "/tmp/tmpnpsgofuw.swift:50:1: error: expected ')' in expression list\n}\n\
    ^\n/tmp/tmpnpsgofuw.swift:49:41: note: to match this opening '('\n    case let\
    \ (.stringValue(a), .intValue(b\n                                        ^\n/tmp/tmpnpsgofuw.swift:49:43:\
    \ error: expected ':' after 'case'\n    case let (.stringValue(a), .intValue(b\n\
    \                                          ^\n/tmp/tmpnpsgofuw.swift:72:66: error:\
    \ expected '}' at end of brace statement\nassert(compare_one(a: .stringValue(\"\
    1\"), b: .intValue(1)) == nil)\n                                             \
    \                    ^\n/tmp/tmpnpsgofuw.swift:21:48: note: to match this opening\
    \ '{'\nfunc compare_one(a: Value, b: Value) -> Value? {\n                    \
    \                           ^\n/tmp/tmpnpsgofuw.swift:27:54: error: binary operator\
    \ '>' cannot be applied to operands of type 'Int' and 'Double'\n    case let (.intValue(a),\
    \ .doubleValue(b)) where a > b:\n                                            \
    \       ~ ^ ~\n/tmp/tmpnpsgofuw.swift:27:54: note: overloads for '>' exist with\
    \ these partially matching parameter lists: (Int, Int)\n    case let (.intValue(a),\
    \ .doubleValue(b)) where a > b:\n                                            \
    \         ^\n/tmp/tmpnpsgofuw.swift:29:54: error: binary operator '<' cannot be\
    \ applied to operands of type 'Int' and 'Double'\n    case let (.intValue(a),\
    \ .doubleValue(b)) where a < b:\n                                            \
    \       ~ ^ ~\n/tmp/tmpnpsgofuw.swift:29:54: note: overloads for '<' exist with\
    \ these partially matching parameter lists: (Int, Int)\n    case let (.intValue(a),\
    \ .doubleValue(b)) where a < b:\n                                            \
    \         ^\n/tmp/tmpnpsgofuw.swift:31:62: error: value of type 'String' has no\
    \ member 'replacingOccurrences'\n    case let (.intValue(a), .stringValue(b))\
    \ where a > Int(b.replacingOccurrences(of: \",\", with: \".\"))!:\n          \
    \                                                 ~ ^~~~~~~~~~~~~~~~~~~~\n/tmp/tmpnpsgofuw.swift:33:62:\
    \ error: value of type 'String' has no member 'replacingOccurrences'\n    case "
  stdout: ''
  timestamp: 1660013180
- exit_code: -4
  program: "\nenum Value: Equatable, Hashable {\n    case intValue(Int)\n    case\
    \ doubleValue(Double)\n    case stringValue(String)\n}\n\n            \n/// Create\
    \ a function that takes integers, floats, or strings representing\n/// real numbers,\
    \ and returns the larger variable in its given variable type.\n/// Return nil\
    \ if the values are equal.\n/// Note: If a real number is represented as a string,\
    \ the floating point might be . or ,\n/// >>> compare_one(a: .intValue(1), b:\
    \ .doubleValue(2.5))\n/// .doubleValue(2.5)\n/// >>> compare_one(a: .intValue(1),\
    \ b: .stringValue(\"2,3\"))\n/// .stringValue(\"2,3\")\n/// >>> compare_one(a:\
    \ .stringValue(\"5,1\"), b: .stringValue(\"6\"))\n/// .stringValue(\"6\")\n///\
    \ >>> compare_one(a: .stringValue(\"1\"), b: .intValue(1))\n/// nil\nfunc compare_one(a:\
    \ Value, b: Value) -> Value? {\n    // TODO: Implement\n    return nil\n}\n\n\n\
    func ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(compare_one(a: .intValue(1), b: .intValue(2))\
    \ == .intValue(2))\nassert(compare_one(a: .intValue(1), b: .doubleValue(2.5))\
    \ == .doubleValue(2.5))\nassert(compare_one(a: .intValue(2), b: .intValue(3))\
    \ == .intValue(3))\nassert(compare_one(a: .intValue(5), b: .intValue(6)) == .intValue(6))\n\
    assert(compare_one(a: .intValue(1), b: .stringValue(\"2,3\")) == .stringValue(\"\
    2,3\"))\nassert(compare_one(a: .stringValue(\"5,1\"), b: .stringValue(\"6\"))\
    \ == .stringValue(\"6\"))\nassert(compare_one(a: .stringValue(\"1\"), b: .stringValue(\"\
    2\")) == .stringValue(\"2\"))\nassert(compare_one(a: .stringValue(\"1\"), b: .intValue(1))\
    \ == nil)"
  status: Exception
  stderr: 'tmp8fwaskxz/tmp8fwaskxz.swift:39: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b13a9c22c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b13a9919b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b13a9919988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b13a99187b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmp8fwaskxz                        0x00005618c2d4fa56 <unavailable> + 6742

    5    libc.so.6                          0x00002b13a9e0e460 __libc_start_main +
    245

    6    tmp8fwaskxz                        0x00005618c2d4f499 <unavailable> + 5273

    '
  stdout: ''
  timestamp: 1660013180
- exit_code: 1
  program: "\nenum Value: Equatable, Hashable {\n    case intValue(Int)\n    case\
    \ doubleValue(Double)\n    case stringValue(String)\n}\n\n            \n/// Create\
    \ a function that takes integers, floats, or strings representing\n/// real numbers,\
    \ and returns the larger variable in its given variable type.\n/// Return nil\
    \ if the values are equal.\n/// Note: If a real number is represented as a string,\
    \ the floating point might be . or ,\n/// >>> compare_one(a: .intValue(1), b:\
    \ .doubleValue(2.5))\n/// .doubleValue(2.5)\n/// >>> compare_one(a: .intValue(1),\
    \ b: .stringValue(\"2,3\"))\n/// .stringValue(\"2,3\")\n/// >>> compare_one(a:\
    \ .stringValue(\"5,1\"), b: .stringValue(\"6\"))\n/// .stringValue(\"6\")\n///\
    \ >>> compare_one(a: .stringValue(\"1\"), b: .intValue(1))\n/// nil\nfunc compare_one(a:\
    \ Value, b: Value) -> Value? {\n    let f = { (a: String, b: String) -> String?\
    \ in\n        guard let a = Double(a), let b = Double(b) else { return nil }\n\
    \        return a >= b ? a.description : b.description\n    }\n    let int = {\
    \ (a: Int, b: Int) -> Int? in a >= b ? a : nil }\n    let double = { (a: Double,\
    \ b: Double) -> Double? in a >= b ? a : nil }\n    return (a, b) |> switch\n \
    \       .intValue(int), .intValue(int) => return .intValue\n        .intValue(int),\
    \ .doubleValue(double) => return .doubleValue\n        .intValue(int), .stringValue(f)\
    \ => return .stringValue\n        .doubleValue(double), .intValue(int) => return\
    \ .doubleValue\n        .doubleValue(double), .doubleValue(double) => return .doubleValue\n\
    \        .doubleValue(double), .stringValue(f) => return .stringValue\n      \
    \  .stringValue(f), .intValue(int) => return .stringValue\n        .stringValue(f),\
    \ .doubleValue(double) => return .stringValue\n        .stringValue(f), .stringValue(f)\
    \ => return .stringValue\n        >> else { return nil }\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(compare_one(a: .intValue(1), b: .intValue(2)) == .intValue(2))\n\
    assert(compare_one(a: .intValue(1), b: .doubleValue(2.5)) == .doubleValue(2.5))\n\
    assert(compare_one(a: .intValue(2), b: .intValue(3)) == .intValue(3))\nassert(compare_one(a:\
    \ .intValue(5), b: .intValue(6)) == .intValue(6))\nassert(compare_one(a: .intValue(1),\
    \ b: .stringValue(\"2,3\")) == .stringValue(\"2,3\"))\nassert(compare_one(a: .stringValue(\"\
    5,1\"), b: .stringValue(\"6\")) == .stringValue(\"6\"))\nassert(compare_one(a:\
    \ .stringValue(\"1\"), b: .stringValue(\"2\")) == .stringValue(\"2\"))\nassert(compare_one(a:\
    \ .stringValue(\"1\"), b: .intValue(1)) == nil)"
  status: SyntaxError
  stderr: "/tmp/tmpfpspi0z1.swift:28:22: error: expected expression after operator\n\
    \    return (a, b) |> switch\n                     ^\n/tmp/tmpfpspi0z1.swift:29:23:\
    \ error: expected '{' after 'switch' subject expression\n        .intValue(int),\
    \ .intValue(int) => return .intValue\n                      ^\n/tmp/tmpfpspi0z1.swift:29:23:\
    \ error: consecutive statements on a line must be separated by ';'\n        .intValue(int),\
    \ .intValue(int) => return .intValue\n                      ^\n              \
    \        ;\n/tmp/tmpfpspi0z1.swift:29:23: error: expected expression\n       \
    \ .intValue(int), .intValue(int) => return .intValue\n                      ^\n\
    /tmp/tmpfpspi0z1.swift:30:23: error: consecutive statements on a line must be\
    \ separated by ';'\n        .intValue(int), .doubleValue(double) => return .doubleValue\n\
    \                      ^\n                      ;\n/tmp/tmpfpspi0z1.swift:30:23:\
    \ error: expected expression\n        .intValue(int), .doubleValue(double) =>\
    \ return .doubleValue\n                      ^\n/tmp/tmpfpspi0z1.swift:31:23:\
    \ error: consecutive statements on a line must be separated by ';'\n        .intValue(int),\
    \ .stringValue(f) => return .stringValue\n                      ^\n          \
    \            ;\n/tmp/tmpfpspi0z1.swift:31:23: error: expected expression\n   \
    \     .intValue(int), .stringValue(f) => return .stringValue\n               \
    \       ^\n/tmp/tmpfpspi0z1.swift:32:29: error: consecutive statements on a line\
    \ must be separated by ';'\n        .doubleValue(double), .intValue(int) => return\
    \ .doubleValue\n                            ^\n                            ;\n\
    /tmp/tmpfpspi0z1.swift:32:29: error: expected expression\n        .doubleValue(double),\
    \ .intValue(int) => return .doubleValue\n                            ^\n/tmp/tmpfpspi0z1.swift:33:29:\
    \ error: consecutive statements on a line must be separated by ';'\n        .doubleValue(double),\
    \ .doubleValue(double) => return .doubleValue\n                            ^\n\
    \                            ;\n/tmp/tmpfpspi0z1.swift:33:29: error: expected\
    \ expression\n        .doubleValue(double), .doubleValue"
  stdout: ''
  timestamp: 1660013180
- exit_code: 1
  program: "\nenum Value: Equatable, Hashable {\n    case intValue(Int)\n    case\
    \ doubleValue(Double)\n    case stringValue(String)\n}\n\n            \n/// Create\
    \ a function that takes integers, floats, or strings representing\n/// real numbers,\
    \ and returns the larger variable in its given variable type.\n/// Return nil\
    \ if the values are equal.\n/// Note: If a real number is represented as a string,\
    \ the floating point might be . or ,\n/// >>> compare_one(a: .intValue(1), b:\
    \ .doubleValue(2.5))\n/// .doubleValue(2.5)\n/// >>> compare_one(a: .intValue(1),\
    \ b: .stringValue(\"2,3\"))\n/// .stringValue(\"2,3\")\n/// >>> compare_one(a:\
    \ .stringValue(\"5,1\"), b: .stringValue(\"6\"))\n/// .stringValue(\"6\")\n///\
    \ >>> compare_one(a: .stringValue(\"1\"), b: .intValue(1))\n/// nil\nfunc compare_one(a:\
    \ Value, b: Value) -> Value? {\n    // FIXME: implement!\n    var result: Value?\
    \ = nil\n    switch (a, b) {\n    case (.intValue(let aVal), .intValue(let bVal)):\n\
    \        if aVal < bVal {\n            result = b\n        } else if aVal > bVal\
    \ {\n            result = a\n        }\n    case (.intValue(let aVal), .doubleValue(let\
    \ bVal)):\n        if aVal < bVal {\n            result = b\n        } else if\
    \ aVal > bVal {\n            result = a\n        }\n    case (.intValue(let aVal),\
    \ .stringValue(let bVal)):\n        let bValNum = Float(bVal)\n        if aVal\
    \ < bValNum {\n            result = b\n        } else if aVal > bValNum {\n  \
    \          result = a\n        }\n    case (.doubleValue(let aVal), .intValue(let\
    \ bVal)):\n        if aVal < bVal {\n            result = b\n        } else if\
    \ aVal > bVal {\n            result = a\n        }\n    case (.doubleValue(let\
    \ aVal), .doubleValue(let bVal)):\n        if aVal < bVal {\n            result\
    \ = b\n        } else if aVal > bVal {\n            result = a\n        }\n  \
    \  case (.doubleValue(let aVal), .stringValue(let bVal)):\n        let bValNum\
    \ = Float(bVal)\n        if aVal < bValNum {\n            result = b\n       \
    \ } else if aVal > bValNum {\n            result = a\n        }\n    case (.stringValue(let\
    \ aVal), .intValue(let bVal)):\n        let aValNum = Float(aVal)\n        if\
    \ aValNum < bVal {\n            result = b\n        } else if aValNum > bVal {\n\
    \            result = a\n        }\n    case (.stringValue(let aVal), .doubleValue(let\
    \ bVal)):\n        let aValNum = Float(aVal)\n        if aValNum < bVal {\n  \
    \          result = b\n        } else if aValNum > bVal {\n            result\
    \ = a\n        }\n    case (.stringValue\n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(compare_one(a: .intValue(1), b: .intValue(2)) == .intValue(2))\nassert(compare_one(a:\
    \ .intValue(1), b: .doubleValue(2.5)) == .doubleValue(2.5))\nassert(compare_one(a:\
    \ .intValue(2), b: .intValue(3)) == .intValue(3))\nassert(compare_one(a: .intValue(5),\
    \ b: .intValue(6)) == .intValue(6))\nassert(compare_one(a: .intValue(1), b: .stringValue(\"\
    2,3\")) == .stringValue(\"2,3\"))\nassert(compare_one(a: .stringValue(\"5,1\"\
    ), b: .stringValue(\"6\")) == .stringValue(\"6\"))\nassert(compare_one(a: .stringValue(\"\
    1\"), b: .stringValue(\"2\")) == .stringValue(\"2\"))\nassert(compare_one(a: .stringValue(\"\
    1\"), b: .intValue(1)) == nil)"
  status: SyntaxError
  stderr: "/tmp/tmph30ilful.swift:78:1: error: expected ')' in expression list\n}\n\
    ^\n/tmp/tmph30ilful.swift:77:10: note: to match this opening '('\n    case (.stringValue\n\
    \         ^\n/tmp/tmph30ilful.swift:77:23: error: expected ':' after 'case'\n\
    \    case (.stringValue\n                      ^\n/tmp/tmph30ilful.swift:100:66:\
    \ error: expected '}' at end of brace statement\nassert(compare_one(a: .stringValue(\"\
    1\"), b: .intValue(1)) == nil)\n                                             \
    \                    ^\n/tmp/tmph30ilful.swift:21:48: note: to match this opening\
    \ '{'\nfunc compare_one(a: Value, b: Value) -> Value? {\n                    \
    \                           ^\n/tmp/tmph30ilful.swift:77:12: error: value of tuple\
    \ type '(Value, Value)' has no member 'stringValue'\n    case (.stringValue\n\
    \          ~^~~~~~~~~~~\n/tmp/tmph30ilful.swift:32:17: error: binary operator\
    \ '<' cannot be applied to operands of type 'Int' and 'Double'\n        if aVal\
    \ < bVal {\n           ~~~~ ^ ~~~~\n/tmp/tmph30ilful.swift:32:17: note: overloads\
    \ for '<' exist with these partially matching parameter lists: (Int, Int)\n  \
    \      if aVal < bVal {\n                ^\n/tmp/tmph30ilful.swift:34:24: error:\
    \ binary operator '>' cannot be applied to operands of type 'Int' and 'Double'\n\
    \        } else if aVal > bVal {\n                  ~~~~ ^ ~~~~\n/tmp/tmph30ilful.swift:34:24:\
    \ note: overloads for '>' exist with these partially matching parameter lists:\
    \ (Int, Int)\n        } else if aVal > bVal {\n                       ^\n/tmp/tmph30ilful.swift:39:19:\
    \ error: cannot convert value of type 'Float?' to expected argument type 'Int'\n\
    \        if aVal < bValNum {\n                  ^\n/tmp/tmph30ilful.swift:41:26:\
    \ error: cannot convert value of type 'Float?' to expected argument type 'Int'\n\
    \        } else if aVal > bValNum {\n                         ^\n/tmp/tmph30ilful.swift:45:17:\
    \ error: binary operator '<' cannot be applied to operands of type 'Double' and\
    \ 'Int'\n        if aVal < bVal {\n           ~~~~ ^ ~~~~\n/tmp/tmph30ilful.swift:45:17:\
    \ note: overloads for '<' exist with these partially matching pa"
  stdout: ''
  timestamp: 1660013180
- exit_code: 1
  program: "\nenum Value: Equatable, Hashable {\n    case intValue(Int)\n    case\
    \ doubleValue(Double)\n    case stringValue(String)\n}\n\n            \n/// Create\
    \ a function that takes integers, floats, or strings representing\n/// real numbers,\
    \ and returns the larger variable in its given variable type.\n/// Return nil\
    \ if the values are equal.\n/// Note: If a real number is represented as a string,\
    \ the floating point might be . or ,\n/// >>> compare_one(a: .intValue(1), b:\
    \ .doubleValue(2.5))\n/// .doubleValue(2.5)\n/// >>> compare_one(a: .intValue(1),\
    \ b: .stringValue(\"2,3\"))\n/// .stringValue(\"2,3\")\n/// >>> compare_one(a:\
    \ .stringValue(\"5,1\"), b: .stringValue(\"6\"))\n/// .stringValue(\"6\")\n///\
    \ >>> compare_one(a: .stringValue(\"1\"), b: .intValue(1))\n/// nil\nfunc compare_one(a:\
    \ Value, b: Value) -> Value? {\n    switch (a, b) {\n    case (.intValue(let a),\
    \ .intValue(let b)):\n        return a > b ? a : b\n    case (.doubleValue(let\
    \ a), .doubleValue(let b)):\n        return a > b ? a : b\n    case (.stringValue(let\
    \ a), .stringValue(let b)):\n        return a > b ? a : b\n    default:\n    \
    \    return nil\n    }\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(compare_one(a:\
    \ .intValue(1), b: .intValue(2)) == .intValue(2))\nassert(compare_one(a: .intValue(1),\
    \ b: .doubleValue(2.5)) == .doubleValue(2.5))\nassert(compare_one(a: .intValue(2),\
    \ b: .intValue(3)) == .intValue(3))\nassert(compare_one(a: .intValue(5), b: .intValue(6))\
    \ == .intValue(6))\nassert(compare_one(a: .intValue(1), b: .stringValue(\"2,3\"\
    )) == .stringValue(\"2,3\"))\nassert(compare_one(a: .stringValue(\"5,1\"), b:\
    \ .stringValue(\"6\")) == .stringValue(\"6\"))\nassert(compare_one(a: .stringValue(\"\
    1\"), b: .stringValue(\"2\")) == .stringValue(\"2\"))\nassert(compare_one(a: .stringValue(\"\
    1\"), b: .intValue(1)) == nil)"
  status: SyntaxError
  stderr: "/tmp/tmp07haxekb.swift:24:22: error: cannot convert return expression of\
    \ type 'Int' to return type 'Value?'\n        return a > b ? a : b\n         \
    \      ~~~~~~^~~~~~~\n/tmp/tmp07haxekb.swift:26:22: error: cannot convert return\
    \ expression of type 'Double' to return type 'Value?'\n        return a > b ?\
    \ a : b\n               ~~~~~~^~~~~~~\n/tmp/tmp07haxekb.swift:28:22: error: cannot\
    \ convert return expression of type 'String' to return type 'Value?'\n       \
    \ return a > b ? a : b\n               ~~~~~~^~~~~~~\n"
  stdout: ''
  timestamp: 1660013180
- exit_code: 1
  program: "\nenum Value: Equatable, Hashable {\n    case intValue(Int)\n    case\
    \ doubleValue(Double)\n    case stringValue(String)\n}\n\n            \n/// Create\
    \ a function that takes integers, floats, or strings representing\n/// real numbers,\
    \ and returns the larger variable in its given variable type.\n/// Return nil\
    \ if the values are equal.\n/// Note: If a real number is represented as a string,\
    \ the floating point might be . or ,\n/// >>> compare_one(a: .intValue(1), b:\
    \ .doubleValue(2.5))\n/// .doubleValue(2.5)\n/// >>> compare_one(a: .intValue(1),\
    \ b: .stringValue(\"2,3\"))\n/// .stringValue(\"2,3\")\n/// >>> compare_one(a:\
    \ .stringValue(\"5,1\"), b: .stringValue(\"6\"))\n/// .stringValue(\"6\")\n///\
    \ >>> compare_one(a: .stringValue(\"1\"), b: .intValue(1))\n/// nil\nfunc compare_one(a:\
    \ Value, b: Value) -> Value? {\n    switch (a, b) {\n    case let (.intValue(a),\
    \ .intValue(b)) where a > b:\n        return .intValue(a)\n    case let (.intValue(a),\
    \ .intValue(b)) where a < b:\n        return .intValue(b)\n    case let (.intValue(a),\
    \ .doubleValue(b)) where a > b:\n        return .intValue(a)\n    case let (.intValue(a),\
    \ .doubleValue(b)) where a < b:\n        return .doubleValue(b)\n    case let\
    \ (.intValue(a), .stringValue(b)) where a > Int(b)!:\n        return .intValue(a)\n\
    \    case let (.intValue(a), .stringValue(b)) where a < Int(b)!:\n        return\
    \ .stringValue(b)\n    case let (.doubleValue(a), .intValue(b)) where a > b:\n\
    \        return .doubleValue(a)\n    case let (.doubleValue(a), .intValue(b))\
    \ where a < b:\n        return .intValue(b)\n    case let (.doubleValue(a), .doubleValue(b))\
    \ where a > b:\n        return .doubleValue(a)\n    case let (.doubleValue(a),\
    \ .doubleValue(b)) where a < b:\n        return .doubleValue(b)\n    case let\
    \ (.doubleValue(a), .stringValue(b)) where a > Double(b)!:\n        return .doubleValue(a)\n\
    \    case let (.doubleValue(a), .stringValue(b)) where a < Double(b)!:\n     \
    \   return .stringValue(b)\n    case let (.stringValue(a), .intValue(b)) where\
    \ Int(a)! > b:\n        return .stringValue(a)\n    case let (.stringValue(a),\
    \ .intValue(b)) where Int(a)! < b:\n        return .intValue(b)\n    case let\
    \ (.stringValue(a), .doubleValue(b)) where Double(a)! > b:\n        return .stringValue(a)\n\
    \    case let (.stringValue(a), .doubleValue(b)) where Double(a)! < b:\n     \
    \   return .doubleValue(b\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(compare_one(a:\
    \ .intValue(1), b: .intValue(2)) == .intValue(2))\nassert(compare_one(a: .intValue(1),\
    \ b: .doubleValue(2.5)) == .doubleValue(2.5))\nassert(compare_one(a: .intValue(2),\
    \ b: .intValue(3)) == .intValue(3))\nassert(compare_one(a: .intValue(5), b: .intValue(6))\
    \ == .intValue(6))\nassert(compare_one(a: .intValue(1), b: .stringValue(\"2,3\"\
    )) == .stringValue(\"2,3\"))\nassert(compare_one(a: .stringValue(\"5,1\"), b:\
    \ .stringValue(\"6\")) == .stringValue(\"6\"))\nassert(compare_one(a: .stringValue(\"\
    1\"), b: .stringValue(\"2\")) == .stringValue(\"2\"))\nassert(compare_one(a: .stringValue(\"\
    1\"), b: .intValue(1)) == nil)"
  status: SyntaxError
  stderr: "/tmp/tmpggpb_u26.swift:55:1: error: expected ')' in expression list\n}\n\
    ^\n/tmp/tmpggpb_u26.swift:54:28: note: to match this opening '('\n        return\
    \ .doubleValue(b\n                           ^\n/tmp/tmpggpb_u26.swift:77:66:\
    \ error: expected '}' at end of brace statement\nassert(compare_one(a: .stringValue(\"\
    1\"), b: .intValue(1)) == nil)\n                                             \
    \                    ^\n/tmp/tmpggpb_u26.swift:21:48: note: to match this opening\
    \ '{'\nfunc compare_one(a: Value, b: Value) -> Value? {\n                    \
    \                           ^\n/tmp/tmpggpb_u26.swift:27:54: error: binary operator\
    \ '>' cannot be applied to operands of type 'Int' and 'Double'\n    case let (.intValue(a),\
    \ .doubleValue(b)) where a > b:\n                                            \
    \       ~ ^ ~\n/tmp/tmpggpb_u26.swift:27:54: note: overloads for '>' exist with\
    \ these partially matching parameter lists: (Int, Int)\n    case let (.intValue(a),\
    \ .doubleValue(b)) where a > b:\n                                            \
    \         ^\n/tmp/tmpggpb_u26.swift:29:54: error: binary operator '<' cannot be\
    \ applied to operands of type 'Int' and 'Double'\n    case let (.intValue(a),\
    \ .doubleValue(b)) where a < b:\n                                            \
    \       ~ ^ ~\n/tmp/tmpggpb_u26.swift:29:54: note: overloads for '<' exist with\
    \ these partially matching parameter lists: (Int, Int)\n    case let (.intValue(a),\
    \ .doubleValue(b)) where a < b:\n                                            \
    \         ^\n/tmp/tmpggpb_u26.swift:35:54: error: binary operator '>' cannot be\
    \ applied to operands of type 'Double' and 'Int'\n    case let (.doubleValue(a),\
    \ .intValue(b)) where a > b:\n                                               \
    \    ~ ^ ~\n/tmp/tmpggpb_u26.swift:35:54: note: overloads for '>' exist with these\
    \ partially matching parameter lists: (Int, Int)\n    case let (.doubleValue(a),\
    \ .intValue(b)) where a > b:\n                                               \
    \      ^\n/tmp/tmpggpb_u26.swift:37:54: error: binary operator '<' cannot be applied\
    \ to operands of type 'Double' an"
  stdout: ''
  timestamp: 1660013180
- exit_code: 1
  program: "\nenum Value: Equatable, Hashable {\n    case intValue(Int)\n    case\
    \ doubleValue(Double)\n    case stringValue(String)\n}\n\n            \n/// Create\
    \ a function that takes integers, floats, or strings representing\n/// real numbers,\
    \ and returns the larger variable in its given variable type.\n/// Return nil\
    \ if the values are equal.\n/// Note: If a real number is represented as a string,\
    \ the floating point might be . or ,\n/// >>> compare_one(a: .intValue(1), b:\
    \ .doubleValue(2.5))\n/// .doubleValue(2.5)\n/// >>> compare_one(a: .intValue(1),\
    \ b: .stringValue(\"2,3\"))\n/// .stringValue(\"2,3\")\n/// >>> compare_one(a:\
    \ .stringValue(\"5,1\"), b: .stringValue(\"6\"))\n/// .stringValue(\"6\")\n///\
    \ >>> compare_one(a: .stringValue(\"1\"), b: .intValue(1))\n/// nil\nfunc compare_one(a:\
    \ Value, b: Value) -> Value? {\n    switch (a, b) {\n    case (.intValue(let a),\
    \ .intValue(let b)):\n        return a > b ? a : b\n    case (.doubleValue(let\
    \ a), .doubleValue(let b)):\n        return a > b ? a : b\n    case (.stringValue(let\
    \ a), .stringValue(let b)):\n        let d1 = Double(a.components(separatedBy:\
    \ CharacterSet(charactersIn: \"., \")).joined()) ?? 0\n        let d2 = Double(b.components(separatedBy:\
    \ CharacterSet(charactersIn: \"., \")).joined()) ?? 0\n        return d1 > d2\
    \ ? a : b\n    case (.intValue(let a), .doubleValue(let b)):\n        return a\
    \ > b ? .intValue(a) : .doubleValue(b)\n    case (.intValue(let a), .stringValue(let\
    \ b)):\n        let d = Double(b.components(separatedBy: CharacterSet(charactersIn:\
    \ \"., \")).joined()) ?? 0\n        return a > d ? .intValue(a) : .stringValue(b)\n\
    \    case (.doubleValue(let a), .intValue(let b)):\n        return a > b ? .doubleValue(a)\
    \ : .intValue(b)\n    case (.doubleValue(let a), .stringValue(let b)):\n     \
    \   let d = Double(b.components(separatedBy: CharacterSet(charactersIn: \"., \"\
    )).joined()) ?? 0\n        return a > d ? .doubleValue(a) : .stringValue(b)\n\
    \    case (.stringValue(let a), .intValue(let b)):\n        let d = Double(a.components(separatedBy:\
    \ CharacterSet(charactersIn: \"., \")).joined()) ?? 0\n        return d > b ?\
    \ .stringValue(a) : .intValue(b)\n    case (.stringValue(let a), .doubleValue(let\
    \ b)):\n        let d = Double(a.components(separatedBy: CharacterSet(charactersIn:\
    \ \"., \")).joined()) ?? 0\n        return d > b ? .stringValue(a) : .doubleValue(b)\n\
    \n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(compare_one(a: .intValue(1), b: .intValue(2))\
    \ == .intValue(2))\nassert(compare_one(a: .intValue(1), b: .doubleValue(2.5))\
    \ == .doubleValue(2.5))\nassert(compare_one(a: .intValue(2), b: .intValue(3))\
    \ == .intValue(3))\nassert(compare_one(a: .intValue(5), b: .intValue(6)) == .intValue(6))\n\
    assert(compare_one(a: .intValue(1), b: .stringValue(\"2,3\")) == .stringValue(\"\
    2,3\"))\nassert(compare_one(a: .stringValue(\"5,1\"), b: .stringValue(\"6\"))\
    \ == .stringValue(\"6\"))\nassert(compare_one(a: .stringValue(\"1\"), b: .stringValue(\"\
    2\")) == .stringValue(\"2\"))\nassert(compare_one(a: .stringValue(\"1\"), b: .intValue(1))\
    \ == nil)"
  status: SyntaxError
  stderr: "/tmp/tmpz6_seyek.swift:70:66: error: expected '}' at end of brace statement\n\
    assert(compare_one(a: .stringValue(\"1\"), b: .intValue(1)) == nil)\n        \
    \                                                         ^\n/tmp/tmpz6_seyek.swift:21:48:\
    \ note: to match this opening '{'\nfunc compare_one(a: Value, b: Value) -> Value?\
    \ {\n                                               ^\n/tmp/tmpz6_seyek.swift:24:22:\
    \ error: cannot convert return expression of type 'Int' to return type 'Value?'\n\
    \        return a > b ? a : b\n               ~~~~~~^~~~~~~\n/tmp/tmpz6_seyek.swift:26:22:\
    \ error: cannot convert return expression of type 'Double' to return type 'Value?'\n\
    \        return a > b ? a : b\n               ~~~~~~^~~~~~~\n/tmp/tmpz6_seyek.swift:28:51:\
    \ error: cannot find 'CharacterSet' in scope\n        let d1 = Double(a.components(separatedBy:\
    \ CharacterSet(charactersIn: \"., \")).joined()) ?? 0\n                      \
    \                            ^~~~~~~~~~~~\n/tmp/tmpz6_seyek.swift:28:27: error:\
    \ value of type 'String' has no member 'components'\n        let d1 = Double(a.components(separatedBy:\
    \ CharacterSet(charactersIn: \"., \")).joined()) ?? 0\n                      \
    \  ~ ^~~~~~~~~~\n/tmp/tmpz6_seyek.swift:29:51: error: cannot find 'CharacterSet'\
    \ in scope\n        let d2 = Double(b.components(separatedBy: CharacterSet(charactersIn:\
    \ \"., \")).joined()) ?? 0\n                                                 \
    \ ^~~~~~~~~~~~\n/tmp/tmpz6_seyek.swift:29:27: error: value of type 'String' has\
    \ no member 'components'\n        let d2 = Double(b.components(separatedBy: CharacterSet(charactersIn:\
    \ \"., \")).joined()) ?? 0\n                        ~ ^~~~~~~~~~\n/tmp/tmpz6_seyek.swift:30:24:\
    \ error: cannot convert return expression of type 'String' to return type 'Value?'\n\
    \        return d1 > d2 ? a : b\n               ~~~~~~~~^~~~~~~\n/tmp/tmpz6_seyek.swift:32:20:\
    \ error: cannot convert value of type 'Double' to expected argument type 'Int'\n\
    \        return a > b ? .intValue(a) : .doubleValue(b)\n                   ^\n\
    \                   Int( )\n/tmp/tmpz6_seyek.swift:34:50: error: cannot"
  stdout: ''
  timestamp: 1660013180
- exit_code: 1
  program: "\nenum Value: Equatable, Hashable {\n    case intValue(Int)\n    case\
    \ doubleValue(Double)\n    case stringValue(String)\n}\n\n            \n/// Create\
    \ a function that takes integers, floats, or strings representing\n/// real numbers,\
    \ and returns the larger variable in its given variable type.\n/// Return nil\
    \ if the values are equal.\n/// Note: If a real number is represented as a string,\
    \ the floating point might be . or ,\n/// >>> compare_one(a: .intValue(1), b:\
    \ .doubleValue(2.5))\n/// .doubleValue(2.5)\n/// >>> compare_one(a: .intValue(1),\
    \ b: .stringValue(\"2,3\"))\n/// .stringValue(\"2,3\")\n/// >>> compare_one(a:\
    \ .stringValue(\"5,1\"), b: .stringValue(\"6\"))\n/// .stringValue(\"6\")\n///\
    \ >>> compare_one(a: .stringValue(\"1\"), b: .intValue(1))\n/// nil\nfunc compare_one(a:\
    \ Value, b: Value) -> Value? {\n    switch (a, b) {\n    case (.intValue(let x),\
    \ .intValue(let y)):\n        return x > y ? .intValue(x) : .intValue(y)\n   \
    \ case (.doubleValue(let x), .doubleValue(let y)):\n        return x > y ? .doubleValue(x)\
    \ : .doubleValue(y)\n    case (.stringValue(let x), .stringValue(let y)):\n  \
    \      return x > y ? .stringValue(x) : .stringValue(y)\n    case (.intValue(let\
    \ x), .doubleValue(let y)):\n        return x > y ? .intValue(x) : .doubleValue(y)\n\
    \    case (.intValue(let x), .stringValue(let y)):\n        return x > y ? .intValue(x)\
    \ : .stringValue(y)\n    case (.doubleValue(let x), .intValue(let y)):\n     \
    \   return x > y ? .doubleValue(x) : .intValue(y)\n    case (.doubleValue(let\
    \ x), .stringValue(let y)):\n        return x > y ? .doubleValue(x) : .stringValue(y)\n\
    \    case (.stringValue(let x), .intValue(let y)):\n        return x > y ? .stringValue(x)\
    \ : .intValue(y)\n    case (.stringValue(let x), .doubleValue(let y)):\n     \
    \   return x > y ? .stringValue(x) : .doubleValue(y)\n    default:\n        return\
    \ nil\n    }\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool\
    \ {\n    if left.count != right.count {\n        return false\n    }\n    for\
    \ (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(compare_one(a: .intValue(1),\
    \ b: .intValue(2)) == .intValue(2))\nassert(compare_one(a: .intValue(1), b: .doubleValue(2.5))\
    \ == .doubleValue(2.5))\nassert(compare_one(a: .intValue(2), b: .intValue(3))\
    \ == .intValue(3))\nassert(compare_one(a: .intValue(5), b: .intValue(6)) == .intValue(6))\n\
    assert(compare_one(a: .intValue(1), b: .stringValue(\"2,3\")) == .stringValue(\"\
    2,3\"))\nassert(compare_one(a: .stringValue(\"5,1\"), b: .stringValue(\"6\"))\
    \ == .stringValue(\"6\"))\nassert(compare_one(a: .stringValue(\"1\"), b: .stringValue(\"\
    2\")) == .stringValue(\"2\"))\nassert(compare_one(a: .stringValue(\"1\"), b: .intValue(1))\
    \ == nil)"
  status: SyntaxError
  stderr: "/tmp/tmpe718pn1z.swift:30:20: error: cannot convert value of type 'Double'\
    \ to expected argument type 'Int'\n        return x > y ? .intValue(x) : .doubleValue(y)\n\
    \                   ^\n                   Int( )\n/tmp/tmpe718pn1z.swift:32:20:\
    \ error: cannot convert value of type 'String' to expected argument type 'Int'\n\
    \        return x > y ? .intValue(x) : .stringValue(y)\n                   ^\n\
    /tmp/tmpe718pn1z.swift:34:16: error: cannot convert value of type 'Double' to\
    \ expected argument type 'Int'\n        return x > y ? .doubleValue(x) : .intValue(y)\n\
    \               ^\n               Int( )\n/tmp/tmpe718pn1z.swift:36:18: error:\
    \ binary operator '>' cannot be applied to operands of type 'Double' and 'String'\n\
    \        return x > y ? .doubleValue(x) : .stringValue(y)\n               ~ ^\
    \ ~\n/tmp/tmpe718pn1z.swift:38:16: error: cannot convert value of type 'String'\
    \ to expected argument type 'Int'\n        return x > y ? .stringValue(x) : .intValue(y)\n\
    \               ^\n/tmp/tmpe718pn1z.swift:40:18: error: binary operator '>' cannot\
    \ be applied to operands of type 'String' and 'Double'\n        return x > y ?\
    \ .stringValue(x) : .doubleValue(y)\n               ~ ^ ~\n"
  stdout: ''
  timestamp: 1660013180
- exit_code: 1
  program: "\nenum Value: Equatable, Hashable {\n    case intValue(Int)\n    case\
    \ doubleValue(Double)\n    case stringValue(String)\n}\n\n            \n/// Create\
    \ a function that takes integers, floats, or strings representing\n/// real numbers,\
    \ and returns the larger variable in its given variable type.\n/// Return nil\
    \ if the values are equal.\n/// Note: If a real number is represented as a string,\
    \ the floating point might be . or ,\n/// >>> compare_one(a: .intValue(1), b:\
    \ .doubleValue(2.5))\n/// .doubleValue(2.5)\n/// >>> compare_one(a: .intValue(1),\
    \ b: .stringValue(\"2,3\"))\n/// .stringValue(\"2,3\")\n/// >>> compare_one(a:\
    \ .stringValue(\"5,1\"), b: .stringValue(\"6\"))\n/// .stringValue(\"6\")\n///\
    \ >>> compare_one(a: .stringValue(\"1\"), b: .intValue(1))\n/// nil\nfunc compare_one(a:\
    \ Value, b: Value) -> Value? {\n    // YOUR CODE HERE\n    var ret: Value? = nil\n\
    \    switch (a, b) {\n    case let (.intValue(aInt), .intValue(bInt)):\n     \
    \   if aInt > bInt {\n            ret = a\n        } else if aInt < bInt {\n \
    \           ret = b\n        }\n    case let (.intValue(aInt), .doubleValue(bDouble)):\n\
    \        if aInt > bDouble {\n            ret = .intValue(aInt)\n        } else\
    \ if aInt < bDouble {\n            ret = .doubleValue(bDouble)\n        }\n  \
    \  case let (.intValue(aInt), .stringValue(bString)):\n        let bFloat = Float(bString)\n\
    \        if aInt > bFloat! {\n            ret = .intValue(aInt)\n        } else\
    \ if aInt < bFloat! {\n            ret = .stringValue(bString)\n        }\n  \
    \  case let (.doubleValue(aDouble), .intValue(bInt)):\n        if aDouble > bInt\
    \ {\n            ret = .doubleValue(aDouble)\n        } else if aDouble < bInt\
    \ {\n            ret = .intValue(bInt)\n        }\n    case let (.doubleValue(aDouble),\
    \ .doubleValue(bDouble)):\n        if aDouble > bDouble {\n            ret = .doubleValue(aDouble)\n\
    \        } else if aDouble < bDouble {\n            ret = .doubleValue(bDouble)\n\
    \        }\n    case let (.doubleValue(aDouble), .stringValue(bString)):\n   \
    \     let bFloat = Float(bString)\n        if aDouble > bFloat! {\n          \
    \  ret = .doubleValue(aDouble)\n        } else if aDouble < bFloat! {\n      \
    \      ret = .stringValue(bString)\n        }\n    case let (.stringValue(aString),\
    \ .intValue(bInt)):\n        let aFloat = Float(aString)\n        if aFloat! >\
    \ bInt {\n            ret = .stringValue(aString)\n        } else if aFloat! <\
    \ bInt {\n            ret = .intValue(bInt)\n        }\n    case let (.stringValue(aString),\
    \ .double\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n\
    \    if left.count != right.count {\n        return false\n    }\n    for (l,\
    \ r) in zip(left, right) {\n        if l != r {\n            return false\n  \
    \      }\n    }\n    return true\n}\n            \nassert(compare_one(a: .intValue(1),\
    \ b: .intValue(2)) == .intValue(2))\nassert(compare_one(a: .intValue(1), b: .doubleValue(2.5))\
    \ == .doubleValue(2.5))\nassert(compare_one(a: .intValue(2), b: .intValue(3))\
    \ == .intValue(3))\nassert(compare_one(a: .intValue(5), b: .intValue(6)) == .intValue(6))\n\
    assert(compare_one(a: .intValue(1), b: .stringValue(\"2,3\")) == .stringValue(\"\
    2,3\"))\nassert(compare_one(a: .stringValue(\"5,1\"), b: .stringValue(\"6\"))\
    \ == .stringValue(\"6\"))\nassert(compare_one(a: .stringValue(\"1\"), b: .stringValue(\"\
    2\")) == .stringValue(\"2\"))\nassert(compare_one(a: .stringValue(\"1\"), b: .intValue(1))\
    \ == nil)"
  status: SyntaxError
  stderr: "/tmp/tmp0ydvhqn6.swift:71:1: error: expected ')' in expression list\n}\n\
    ^\n/tmp/tmp0ydvhqn6.swift:70:14: note: to match this opening '('\n    case let\
    \ (.stringValue(aString), .double\n             ^\n/tmp/tmp0ydvhqn6.swift:70:45:\
    \ error: expected ':' after 'case'\n    case let (.stringValue(aString), .double\n\
    \                                            ^\n/tmp/tmp0ydvhqn6.swift:93:66:\
    \ error: expected '}' at end of brace statement\nassert(compare_one(a: .stringValue(\"\
    1\"), b: .intValue(1)) == nil)\n                                             \
    \                    ^\n/tmp/tmp0ydvhqn6.swift:21:48: note: to match this opening\
    \ '{'\nfunc compare_one(a: Value, b: Value) -> Value? {\n                    \
    \                           ^\n/tmp/tmp0ydvhqn6.swift:70:39: error: type 'Value'\
    \ has no member 'double'\n    case let (.stringValue(aString), .double\n     \
    \                                ~^~~~~~\n/tmp/tmp0ydvhqn6.swift:32:17: error:\
    \ binary operator '>' cannot be applied to operands of type 'Int' and 'Double'\n\
    \        if aInt > bDouble {\n           ~~~~ ^ ~~~~~~~\n/tmp/tmp0ydvhqn6.swift:32:17:\
    \ note: overloads for '>' exist with these partially matching parameter lists:\
    \ (Int, Int)\n        if aInt > bDouble {\n                ^\n/tmp/tmp0ydvhqn6.swift:34:24:\
    \ error: binary operator '<' cannot be applied to operands of type 'Int' and 'Double'\n\
    \        } else if aInt < bDouble {\n                  ~~~~ ^ ~~~~~~~\n/tmp/tmp0ydvhqn6.swift:34:24:\
    \ note: overloads for '<' exist with these partially matching parameter lists:\
    \ (Int, Int)\n        } else if aInt < bDouble {\n                       ^\n/tmp/tmp0ydvhqn6.swift:39:17:\
    \ error: binary operator '>' cannot be applied to operands of type 'Int' and 'Float'\n\
    \        if aInt > bFloat! {\n           ~~~~ ^ ~~~~~~~\n/tmp/tmp0ydvhqn6.swift:39:17:\
    \ note: overloads for '>' exist with these partially matching parameter lists:\
    \ (Int, Int)\n        if aInt > bFloat! {\n                ^\n/tmp/tmp0ydvhqn6.swift:41:24:\
    \ error: binary operator '<' cannot be applied to operands of type 'Int' and 'Float'\n\
    \        } else if aInt < bFloat!"
  stdout: ''
  timestamp: 1660013180
- exit_code: 1
  program: "\nenum Value: Equatable, Hashable {\n    case intValue(Int)\n    case\
    \ doubleValue(Double)\n    case stringValue(String)\n}\n\n            \n/// Create\
    \ a function that takes integers, floats, or strings representing\n/// real numbers,\
    \ and returns the larger variable in its given variable type.\n/// Return nil\
    \ if the values are equal.\n/// Note: If a real number is represented as a string,\
    \ the floating point might be . or ,\n/// >>> compare_one(a: .intValue(1), b:\
    \ .doubleValue(2.5))\n/// .doubleValue(2.5)\n/// >>> compare_one(a: .intValue(1),\
    \ b: .stringValue(\"2,3\"))\n/// .stringValue(\"2,3\")\n/// >>> compare_one(a:\
    \ .stringValue(\"5,1\"), b: .stringValue(\"6\"))\n/// .stringValue(\"6\")\n///\
    \ >>> compare_one(a: .stringValue(\"1\"), b: .intValue(1))\n/// nil\nfunc compare_one(a:\
    \ Value, b: Value) -> Value? {\n    switch (a, b) {\n    case (.intValue(let a),\
    \ .intValue(let b)):\n        return a > b ? a : b\n    case (.doubleValue(let\
    \ a), .doubleValue(let b)):\n        return a > b ? a : b\n    case (.stringValue(let\
    \ a), .stringValue(let b)):\n        return a > b ? a : b\n    case (.intValue(let\
    \ a), .doubleValue(let b)):\n        return a > b ? a : b\n    case (.intValue(let\
    \ a), .stringValue(let b)):\n        return a > b ? a : b\n    case (.doubleValue(let\
    \ a), .intValue(let b)):\n        return a > b ? a : b\n    case (.doubleValue(let\
    \ a), .stringValue(let b)):\n        return a > b ? a : b\n    case (.stringValue(let\
    \ a), .intValue(let b)):\n        return a > b ? a : b\n    case (.stringValue(let\
    \ a), .doubleValue(let b)):\n        return a > b ? a : b\n    default:\n    \
    \    return nil\n    }\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(compare_one(a:\
    \ .intValue(1), b: .intValue(2)) == .intValue(2))\nassert(compare_one(a: .intValue(1),\
    \ b: .doubleValue(2.5)) == .doubleValue(2.5))\nassert(compare_one(a: .intValue(2),\
    \ b: .intValue(3)) == .intValue(3))\nassert(compare_one(a: .intValue(5), b: .intValue(6))\
    \ == .intValue(6))\nassert(compare_one(a: .intValue(1), b: .stringValue(\"2,3\"\
    )) == .stringValue(\"2,3\"))\nassert(compare_one(a: .stringValue(\"5,1\"), b:\
    \ .stringValue(\"6\")) == .stringValue(\"6\"))\nassert(compare_one(a: .stringValue(\"\
    1\"), b: .stringValue(\"2\")) == .stringValue(\"2\"))\nassert(compare_one(a: .stringValue(\"\
    1\"), b: .intValue(1)) == nil)"
  status: SyntaxError
  stderr: "/tmp/tmpjf037tzu.swift:24:22: error: cannot convert return expression of\
    \ type 'Int' to return type 'Value?'\n        return a > b ? a : b\n         \
    \      ~~~~~~^~~~~~~\n/tmp/tmpjf037tzu.swift:26:22: error: cannot convert return\
    \ expression of type 'Double' to return type 'Value?'\n        return a > b ?\
    \ a : b\n               ~~~~~~^~~~~~~\n/tmp/tmpjf037tzu.swift:28:22: error: cannot\
    \ convert return expression of type 'String' to return type 'Value?'\n       \
    \ return a > b ? a : b\n               ~~~~~~^~~~~~~\n/tmp/tmpjf037tzu.swift:30:20:\
    \ error: cannot convert value of type 'Double' to expected argument type 'Int'\n\
    \        return a > b ? a : b\n                   ^\n                   Int( )\n\
    /tmp/tmpjf037tzu.swift:30:22: error: cannot convert return expression of type\
    \ 'Int' to return type 'Value?'\n        return a > b ? a : b\n              \
    \ ~~~~~~^~~~~~~\n/tmp/tmpjf037tzu.swift:32:20: error: cannot convert value of\
    \ type 'String' to expected argument type 'Int'\n        return a > b ? a : b\n\
    \                   ^\n/tmp/tmpjf037tzu.swift:32:22: error: cannot convert return\
    \ expression of type 'Int' to return type 'Value?'\n        return a > b ? a :\
    \ b\n               ~~~~~~^~~~~~~\n/tmp/tmpjf037tzu.swift:34:16: error: cannot\
    \ convert value of type 'Double' to expected argument type 'Int'\n        return\
    \ a > b ? a : b\n               ^\n               Int( )\n/tmp/tmpjf037tzu.swift:34:22:\
    \ error: cannot convert return expression of type 'Double' to return type 'Value?'\n\
    \        return a > b ? a : b\n               ~~~~~~^~~~~~~\n/tmp/tmpjf037tzu.swift:36:18:\
    \ error: binary operator '>' cannot be applied to operands of type 'Double' and\
    \ 'String'\n        return a > b ? a : b\n               ~ ^ ~\n/tmp/tmpjf037tzu.swift:36:22:\
    \ error: cannot convert return expression of type 'Double' to return type 'Value?'\n\
    \        return a > b ? a : b\n               ~~~~~~^~~~~~~\n/tmp/tmpjf037tzu.swift:38:16:\
    \ error: cannot convert value of type 'String' to expected argument type 'Int'\n\
    \        return a > b ? a : b\n               ^\n/tmp/tmpjf037tzu.swift:38:22:\
    \ error: ca"
  stdout: ''
  timestamp: 1660013180
- exit_code: 1
  program: "\nenum Value: Equatable, Hashable {\n    case intValue(Int)\n    case\
    \ doubleValue(Double)\n    case stringValue(String)\n}\n\n            \n/// Create\
    \ a function that takes integers, floats, or strings representing\n/// real numbers,\
    \ and returns the larger variable in its given variable type.\n/// Return nil\
    \ if the values are equal.\n/// Note: If a real number is represented as a string,\
    \ the floating point might be . or ,\n/// >>> compare_one(a: .intValue(1), b:\
    \ .doubleValue(2.5))\n/// .doubleValue(2.5)\n/// >>> compare_one(a: .intValue(1),\
    \ b: .stringValue(\"2,3\"))\n/// .stringValue(\"2,3\")\n/// >>> compare_one(a:\
    \ .stringValue(\"5,1\"), b: .stringValue(\"6\"))\n/// .stringValue(\"6\")\n///\
    \ >>> compare_one(a: .stringValue(\"1\"), b: .intValue(1))\n/// nil\nfunc compare_one(a:\
    \ Value, b: Value) -> Value? {\n    switch (a, b) {\n    case let (.intValue(a),\
    \ .intValue(b)) where a > b:\n        return .intValue(a)\n    case let (.intValue(a),\
    \ .intValue(b)) where a < b:\n        return .intValue(b)\n    case let (.intValue(a),\
    \ .doubleValue(b)) where a > b:\n        return .intValue(a)\n    case let (.intValue(a),\
    \ .doubleValue(b)) where a < b:\n        return .doubleValue(b)\n    case let\
    \ (.intValue(a), .stringValue(b)) where a > Double(b)!:\n        return .intValue(a)\n\
    \    case let (.intValue(a), .stringValue(b)) where a < Double(b)!:\n        return\
    \ .stringValue(b)\n    case let (.doubleValue(a), .intValue(b)) where a > b:\n\
    \        return .doubleValue(a)\n    case let (.doubleValue(a), .intValue(b))\
    \ where a < b:\n        return .intValue(b)\n    case let (.doubleValue(a), .doubleValue(b))\
    \ where a > b:\n        return .doubleValue(a)\n    case let (.doubleValue(a),\
    \ .doubleValue(b)) where a < b:\n        return .doubleValue(b)\n    case let\
    \ (.doubleValue(a), .stringValue(b)) where a > Double(b)!:\n        return .doubleValue(a)\n\
    \    case let (.doubleValue(a), .stringValue(b)) where a < Double(b)!:\n     \
    \   return .stringValue(b)\n    case let (.stringValue(a), .intValue(b)) where\
    \ Double(a)! > b:\n        return .stringValue(a)\n    case let (.stringValue(a),\
    \ .intValue(b)) where Double(a)! < b:\n        return .intValue(b)\n    case let\
    \ (.stringValue(a), .doubleValue(b)) where Double(a)! > b:\n        return .stringValue(a)\n\
    \    case let (.stringValue(a), .doubleValue(b)) where Double(a)! < b:\n     \
    \   return .doubleValue(b\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(compare_one(a:\
    \ .intValue(1), b: .intValue(2)) == .intValue(2))\nassert(compare_one(a: .intValue(1),\
    \ b: .doubleValue(2.5)) == .doubleValue(2.5))\nassert(compare_one(a: .intValue(2),\
    \ b: .intValue(3)) == .intValue(3))\nassert(compare_one(a: .intValue(5), b: .intValue(6))\
    \ == .intValue(6))\nassert(compare_one(a: .intValue(1), b: .stringValue(\"2,3\"\
    )) == .stringValue(\"2,3\"))\nassert(compare_one(a: .stringValue(\"5,1\"), b:\
    \ .stringValue(\"6\")) == .stringValue(\"6\"))\nassert(compare_one(a: .stringValue(\"\
    1\"), b: .stringValue(\"2\")) == .stringValue(\"2\"))\nassert(compare_one(a: .stringValue(\"\
    1\"), b: .intValue(1)) == nil)"
  status: SyntaxError
  stderr: "/tmp/tmp_irifzod.swift:55:1: error: expected ')' in expression list\n}\n\
    ^\n/tmp/tmp_irifzod.swift:54:28: note: to match this opening '('\n        return\
    \ .doubleValue(b\n                           ^\n/tmp/tmp_irifzod.swift:77:66:\
    \ error: expected '}' at end of brace statement\nassert(compare_one(a: .stringValue(\"\
    1\"), b: .intValue(1)) == nil)\n                                             \
    \                    ^\n/tmp/tmp_irifzod.swift:21:48: note: to match this opening\
    \ '{'\nfunc compare_one(a: Value, b: Value) -> Value? {\n                    \
    \                           ^\n/tmp/tmp_irifzod.swift:27:54: error: binary operator\
    \ '>' cannot be applied to operands of type 'Int' and 'Double'\n    case let (.intValue(a),\
    \ .doubleValue(b)) where a > b:\n                                            \
    \       ~ ^ ~\n/tmp/tmp_irifzod.swift:27:54: note: overloads for '>' exist with\
    \ these partially matching parameter lists: (Int, Int)\n    case let (.intValue(a),\
    \ .doubleValue(b)) where a > b:\n                                            \
    \         ^\n/tmp/tmp_irifzod.swift:29:54: error: binary operator '<' cannot be\
    \ applied to operands of type 'Int' and 'Double'\n    case let (.intValue(a),\
    \ .doubleValue(b)) where a < b:\n                                            \
    \       ~ ^ ~\n/tmp/tmp_irifzod.swift:29:54: note: overloads for '<' exist with\
    \ these partially matching parameter lists: (Int, Int)\n    case let (.intValue(a),\
    \ .doubleValue(b)) where a < b:\n                                            \
    \         ^\n/tmp/tmp_irifzod.swift:31:65: error: cannot convert value of type\
    \ 'Double' to expected argument type 'Int'\n    case let (.intValue(a), .stringValue(b))\
    \ where a > Double(b)!:\n                                                    \
    \            ^\n                                                       Int(  \
    \    )\n/tmp/tmp_irifzod.swift:33:65: error: cannot convert value of type 'Double'\
    \ to expected argument type 'Int'\n    case let (.intValue(a), .stringValue(b))\
    \ where a < Double(b)!:\n                                                    \
    \            ^\n                   "
  stdout: ''
  timestamp: 1660013180
- exit_code: 1
  program: "\nenum Value: Equatable, Hashable {\n    case intValue(Int)\n    case\
    \ doubleValue(Double)\n    case stringValue(String)\n}\n\n            \n/// Create\
    \ a function that takes integers, floats, or strings representing\n/// real numbers,\
    \ and returns the larger variable in its given variable type.\n/// Return nil\
    \ if the values are equal.\n/// Note: If a real number is represented as a string,\
    \ the floating point might be . or ,\n/// >>> compare_one(a: .intValue(1), b:\
    \ .doubleValue(2.5))\n/// .doubleValue(2.5)\n/// >>> compare_one(a: .intValue(1),\
    \ b: .stringValue(\"2,3\"))\n/// .stringValue(\"2,3\")\n/// >>> compare_one(a:\
    \ .stringValue(\"5,1\"), b: .stringValue(\"6\"))\n/// .stringValue(\"6\")\n///\
    \ >>> compare_one(a: .stringValue(\"1\"), b: .intValue(1))\n/// nil\nfunc compare_one(a:\
    \ Value, b: Value) -> Value? {\n    switch (a, b) {\n    case (.intValue(let a),\
    \ .intValue(let b)):\n        return a > b ? a : b\n    case (.doubleValue(let\
    \ a), .doubleValue(let b)):\n        return a > b ? a : b\n    case (.stringValue(let\
    \ a), .stringValue(let b)):\n        return a > b ? a : b\n    default:\n    \
    \    return nil\n    }\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(compare_one(a:\
    \ .intValue(1), b: .intValue(2)) == .intValue(2))\nassert(compare_one(a: .intValue(1),\
    \ b: .doubleValue(2.5)) == .doubleValue(2.5))\nassert(compare_one(a: .intValue(2),\
    \ b: .intValue(3)) == .intValue(3))\nassert(compare_one(a: .intValue(5), b: .intValue(6))\
    \ == .intValue(6))\nassert(compare_one(a: .intValue(1), b: .stringValue(\"2,3\"\
    )) == .stringValue(\"2,3\"))\nassert(compare_one(a: .stringValue(\"5,1\"), b:\
    \ .stringValue(\"6\")) == .stringValue(\"6\"))\nassert(compare_one(a: .stringValue(\"\
    1\"), b: .stringValue(\"2\")) == .stringValue(\"2\"))\nassert(compare_one(a: .stringValue(\"\
    1\"), b: .intValue(1)) == nil)"
  status: SyntaxError
  stderr: "/tmp/tmp07haxekb.swift:24:22: error: cannot convert return expression of\
    \ type 'Int' to return type 'Value?'\n        return a > b ? a : b\n         \
    \      ~~~~~~^~~~~~~\n/tmp/tmp07haxekb.swift:26:22: error: cannot convert return\
    \ expression of type 'Double' to return type 'Value?'\n        return a > b ?\
    \ a : b\n               ~~~~~~^~~~~~~\n/tmp/tmp07haxekb.swift:28:22: error: cannot\
    \ convert return expression of type 'String' to return type 'Value?'\n       \
    \ return a > b ? a : b\n               ~~~~~~^~~~~~~\n"
  stdout: ''
  timestamp: 1660013180
- exit_code: 1
  program: "\nenum Value: Equatable, Hashable {\n    case intValue(Int)\n    case\
    \ doubleValue(Double)\n    case stringValue(String)\n}\n\n            \n/// Create\
    \ a function that takes integers, floats, or strings representing\n/// real numbers,\
    \ and returns the larger variable in its given variable type.\n/// Return nil\
    \ if the values are equal.\n/// Note: If a real number is represented as a string,\
    \ the floating point might be . or ,\n/// >>> compare_one(a: .intValue(1), b:\
    \ .doubleValue(2.5))\n/// .doubleValue(2.5)\n/// >>> compare_one(a: .intValue(1),\
    \ b: .stringValue(\"2,3\"))\n/// .stringValue(\"2,3\")\n/// >>> compare_one(a:\
    \ .stringValue(\"5,1\"), b: .stringValue(\"6\"))\n/// .stringValue(\"6\")\n///\
    \ >>> compare_one(a: .stringValue(\"1\"), b: .intValue(1))\n/// nil\nfunc compare_one(a:\
    \ Value, b: Value) -> Value? {\n    switch (a, b) {\n    case (.intValue(let x),\
    \ .intValue(let y)) where x < y:\n        return .intValue(y)\n    case (.intValue(let\
    \ x), .doubleValue(let y)) where x < y:\n        return .doubleValue(y)\n    case\
    \ (.intValue(let x), .stringValue(let y)) where x < y:\n        return .stringValue(y)\n\
    \    case (.doubleValue(let x), .intValue(let y)) where x < y:\n        return\
    \ .intValue(y)\n    case (.doubleValue(let x), .doubleValue(let y)) where x <\
    \ y:\n        return .doubleValue(y)\n    case (.doubleValue(let x), .stringValue(let\
    \ y)) where x < y:\n        return .stringValue(y)\n    case (.stringValue(let\
    \ x), .intValue(let y)) where x < y:\n        return .intValue(y)\n    case (.stringValue(let\
    \ x), .doubleValue(let y)) where x < y:\n        return .doubleValue(y)\n    case\
    \ (.stringValue(let x), .stringValue(let y)) where x < y:\n        return .stringValue(y)\n\
    \    default:\n        return nil\n    }\n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(compare_one(a: .intValue(1), b: .intValue(2)) == .intValue(2))\nassert(compare_one(a:\
    \ .intValue(1), b: .doubleValue(2.5)) == .doubleValue(2.5))\nassert(compare_one(a:\
    \ .intValue(2), b: .intValue(3)) == .intValue(3))\nassert(compare_one(a: .intValue(5),\
    \ b: .intValue(6)) == .intValue(6))\nassert(compare_one(a: .intValue(1), b: .stringValue(\"\
    2,3\")) == .stringValue(\"2,3\"))\nassert(compare_one(a: .stringValue(\"5,1\"\
    ), b: .stringValue(\"6\")) == .stringValue(\"6\"))\nassert(compare_one(a: .stringValue(\"\
    1\"), b: .stringValue(\"2\")) == .stringValue(\"2\"))\nassert(compare_one(a: .stringValue(\"\
    1\"), b: .intValue(1)) == nil)"
  status: SyntaxError
  stderr: "/tmp/tmpep3fe21a.swift:25:58: error: binary operator '<' cannot be applied\
    \ to operands of type 'Int' and 'Double'\n    case (.intValue(let x), .doubleValue(let\
    \ y)) where x < y:\n                                                       ~ ^\
    \ ~\n/tmp/tmpep3fe21a.swift:25:58: note: overloads for '<' exist with these partially\
    \ matching parameter lists: (Int, Int)\n    case (.intValue(let x), .doubleValue(let\
    \ y)) where x < y:\n                                                         ^\n\
    /tmp/tmpep3fe21a.swift:27:58: error: binary operator '<' cannot be applied to\
    \ operands of type 'Int' and 'String'\n    case (.intValue(let x), .stringValue(let\
    \ y)) where x < y:\n                                                       ~ ^\
    \ ~\n/tmp/tmpep3fe21a.swift:27:58: note: overloads for '<' exist with these partially\
    \ matching parameter lists: (Int, Int), (String, String)\n    case (.intValue(let\
    \ x), .stringValue(let y)) where x < y:\n                                    \
    \                     ^\n/tmp/tmpep3fe21a.swift:29:58: error: binary operator\
    \ '<' cannot be applied to operands of type 'Double' and 'Int'\n    case (.doubleValue(let\
    \ x), .intValue(let y)) where x < y:\n                                       \
    \                ~ ^ ~\n/tmp/tmpep3fe21a.swift:29:58: note: overloads for '<'\
    \ exist with these partially matching parameter lists: (Int, Int)\n    case (.doubleValue(let\
    \ x), .intValue(let y)) where x < y:\n                                       \
    \                  ^\n/tmp/tmpep3fe21a.swift:33:61: error: binary operator '<'\
    \ cannot be applied to operands of type 'Double' and 'String'\n    case (.doubleValue(let\
    \ x), .stringValue(let y)) where x < y:\n                                    \
    \                      ~ ^ ~\n/tmp/tmpep3fe21a.swift:33:61: note: overloads for\
    \ '<' exist with these partially matching parameter lists: (String, String)\n\
    \    case (.doubleValue(let x), .stringValue(let y)) where x < y:\n          \
    \                                                  ^\n/tmp/tmpep3fe21a.swift:35:58:\
    \ error: binary operator '<' cannot be applied to operands of type 'String' a"
  stdout: ''
  timestamp: 1660013180
- exit_code: -4
  program: "\nenum Value: Equatable, Hashable {\n    case intValue(Int)\n    case\
    \ doubleValue(Double)\n    case stringValue(String)\n}\n\n            \n/// Create\
    \ a function that takes integers, floats, or strings representing\n/// real numbers,\
    \ and returns the larger variable in its given variable type.\n/// Return nil\
    \ if the values are equal.\n/// Note: If a real number is represented as a string,\
    \ the floating point might be . or ,\n/// >>> compare_one(a: .intValue(1), b:\
    \ .doubleValue(2.5))\n/// .doubleValue(2.5)\n/// >>> compare_one(a: .intValue(1),\
    \ b: .stringValue(\"2,3\"))\n/// .stringValue(\"2,3\")\n/// >>> compare_one(a:\
    \ .stringValue(\"5,1\"), b: .stringValue(\"6\"))\n/// .stringValue(\"6\")\n///\
    \ >>> compare_one(a: .stringValue(\"1\"), b: .intValue(1))\n/// nil\nfunc compare_one(a:\
    \ Value, b: Value) -> Value? {\n    // do something\n    return nil\n}\n\n\nfunc\
    \ ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count !=\
    \ right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(compare_one(a: .intValue(1), b: .intValue(2))\
    \ == .intValue(2))\nassert(compare_one(a: .intValue(1), b: .doubleValue(2.5))\
    \ == .doubleValue(2.5))\nassert(compare_one(a: .intValue(2), b: .intValue(3))\
    \ == .intValue(3))\nassert(compare_one(a: .intValue(5), b: .intValue(6)) == .intValue(6))\n\
    assert(compare_one(a: .intValue(1), b: .stringValue(\"2,3\")) == .stringValue(\"\
    2,3\"))\nassert(compare_one(a: .stringValue(\"5,1\"), b: .stringValue(\"6\"))\
    \ == .stringValue(\"6\"))\nassert(compare_one(a: .stringValue(\"1\"), b: .stringValue(\"\
    2\")) == .stringValue(\"2\"))\nassert(compare_one(a: .stringValue(\"1\"), b: .intValue(1))\
    \ == nil)"
  status: Exception
  stderr: 'tmpi3yu0eck/tmpi3yu0eck.swift:39: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b5e083c4c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b5e080bbb6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b5e080bb988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b5e080ba7b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpi3yu0eck                        0x000055b58a212a56 <unavailable> + 6742

    5    libc.so.6                          0x00002b5e085b0460 __libc_start_main +
    245

    6    tmpi3yu0eck                        0x000055b58a212499 <unavailable> + 5273

    '
  stdout: ''
  timestamp: 1660013180
- exit_code: -4
  program: "\nenum Value: Equatable, Hashable {\n    case intValue(Int)\n    case\
    \ doubleValue(Double)\n    case stringValue(String)\n}\n\n            \n/// Create\
    \ a function that takes integers, floats, or strings representing\n/// real numbers,\
    \ and returns the larger variable in its given variable type.\n/// Return nil\
    \ if the values are equal.\n/// Note: If a real number is represented as a string,\
    \ the floating point might be . or ,\n/// >>> compare_one(a: .intValue(1), b:\
    \ .doubleValue(2.5))\n/// .doubleValue(2.5)\n/// >>> compare_one(a: .intValue(1),\
    \ b: .stringValue(\"2,3\"))\n/// .stringValue(\"2,3\")\n/// >>> compare_one(a:\
    \ .stringValue(\"5,1\"), b: .stringValue(\"6\"))\n/// .stringValue(\"6\")\n///\
    \ >>> compare_one(a: .stringValue(\"1\"), b: .intValue(1))\n/// nil\nfunc compare_one(a:\
    \ Value, b: Value) -> Value? {\n    return nil\n}\n\n\nfunc ==(left: [(Int, Int)],\
    \ right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n       \
    \ return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r\
    \ {\n            return false\n        }\n    }\n    return true\n}\n        \
    \    \nassert(compare_one(a: .intValue(1), b: .intValue(2)) == .intValue(2))\n\
    assert(compare_one(a: .intValue(1), b: .doubleValue(2.5)) == .doubleValue(2.5))\n\
    assert(compare_one(a: .intValue(2), b: .intValue(3)) == .intValue(3))\nassert(compare_one(a:\
    \ .intValue(5), b: .intValue(6)) == .intValue(6))\nassert(compare_one(a: .intValue(1),\
    \ b: .stringValue(\"2,3\")) == .stringValue(\"2,3\"))\nassert(compare_one(a: .stringValue(\"\
    5,1\"), b: .stringValue(\"6\")) == .stringValue(\"6\"))\nassert(compare_one(a:\
    \ .stringValue(\"1\"), b: .stringValue(\"2\")) == .stringValue(\"2\"))\nassert(compare_one(a:\
    \ .stringValue(\"1\"), b: .intValue(1)) == nil)"
  status: Exception
  stderr: 'tmpllswmh2d/tmpllswmh2d.swift:38: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b05c2ae8c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b05c27dfb6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b05c27df988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b05c27de7b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpllswmh2d                        0x000055f806e32a56 <unavailable> + 6742

    5    libc.so.6                          0x00002b05c2cd4460 __libc_start_main +
    245

    6    tmpllswmh2d                        0x000055f806e32499 <unavailable> + 5273

    '
  stdout: ''
  timestamp: 1660013179
- exit_code: 1
  program: "\nenum Value: Equatable, Hashable {\n    case intValue(Int)\n    case\
    \ doubleValue(Double)\n    case stringValue(String)\n}\n\n            \n/// Create\
    \ a function that takes integers, floats, or strings representing\n/// real numbers,\
    \ and returns the larger variable in its given variable type.\n/// Return nil\
    \ if the values are equal.\n/// Note: If a real number is represented as a string,\
    \ the floating point might be . or ,\n/// >>> compare_one(a: .intValue(1), b:\
    \ .doubleValue(2.5))\n/// .doubleValue(2.5)\n/// >>> compare_one(a: .intValue(1),\
    \ b: .stringValue(\"2,3\"))\n/// .stringValue(\"2,3\")\n/// >>> compare_one(a:\
    \ .stringValue(\"5,1\"), b: .stringValue(\"6\"))\n/// .stringValue(\"6\")\n///\
    \ >>> compare_one(a: .stringValue(\"1\"), b: .intValue(1))\n/// nil\nfunc compare_one(a:\
    \ Value, b: Value) -> Value? {\n    switch (a, b) {\n    case (.intValue(let x),\
    \ .intValue(let y)):\n        return x > y ? .intValue(x) : y > x ? .intValue(y)\
    \ : nil\n    case (.intValue(let x), .doubleValue(let y)):\n        return x >\
    \ y ? .intValue(x) : y > x ? .doubleValue(y) : nil\n    case (.intValue(let x),\
    \ .stringValue(let y)):\n        return x > Double(y)! ? .intValue(x) : Double(y)!\
    \ > x ? .stringValue(y) : nil\n    case (.doubleValue(let x), .intValue(let y)):\n\
    \        return x > y ? .doubleValue(x) : y > x ? .intValue(y) : nil\n    case\
    \ (.doubleValue(let x), .doubleValue(let y)):\n        return x > y ? .doubleValue(x)\
    \ : y > x ? .doubleValue(y) : nil\n    case (.doubleValue(let x), .stringValue(let\
    \ y)):\n        return x > Double(y)! ? .doubleValue(x) : Double(y)! > x ? .stringValue(y)\
    \ : nil\n    case (.stringValue(let x), .intValue(let y)):\n        return Double(x)!\
    \ > y ? .stringValue(x) : y > Double(x)! ? .intValue(y) : nil\n    case (.stringValue(let\
    \ x), .doubleValue(let y)):\n        return Double(x)! > y ? .stringValue(x) :\
    \ y > Double(x)! ? .doubleValue(y) : nil\n    case (.stringValue(let x), .stringValue(let\
    \ y)):\n        return Double(x)! > Double(y)! ? .stringValue(x) : Double(y)!\
    \ > Double(x)! ? .stringValue(y) : nil\n    }\n}\n\n\nfunc ==(left: [(Int, Int)],\
    \ right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n       \
    \ return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r\
    \ {\n            return false\n        }\n    }\n    return true\n}\n        \
    \    \nassert(compare_one(a: .intValue(1), b: .intValue(2)) == .intValue(2))\n\
    assert(compare_one(a: .intValue(1), b: .doubleValue(2.5)) == .doubleValue(2.5))\n\
    assert(compare_one(a: .intValue(2), b: .intValue(3)) == .intValue(3))\nassert(compare_one(a:\
    \ .intValue(5), b: .intValue(6)) == .intValue(6))\nassert(compare_one(a: .intValue(1),\
    \ b: .stringValue(\"2,3\")) == .stringValue(\"2,3\"))\nassert(compare_one(a: .stringValue(\"\
    5,1\"), b: .stringValue(\"6\")) == .stringValue(\"6\"))\nassert(compare_one(a:\
    \ .stringValue(\"1\"), b: .stringValue(\"2\")) == .stringValue(\"2\"))\nassert(compare_one(a:\
    \ .stringValue(\"1\"), b: .intValue(1)) == nil)"
  status: SyntaxError
  stderr: "/tmp/tmpaihjjsa1.swift:26:20: error: cannot convert value of type 'Double'\
    \ to expected argument type 'Int'\n        return x > y ? .intValue(x) : y > x\
    \ ? .doubleValue(y) : nil\n                   ^\n                   Int( )\n/tmp/tmpaihjjsa1.swift:26:39:\
    \ error: cannot convert value of type 'Double' to expected argument type 'Int'\n\
    \        return x > y ? .intValue(x) : y > x ? .doubleValue(y) : nil\n       \
    \                               ^\n                                      Int(\
    \ )\n/tmp/tmpaihjjsa1.swift:28:29: error: cannot convert value of type 'Double'\
    \ to expected argument type 'Int'\n        return x > Double(y)! ? .intValue(x)\
    \ : Double(y)! > x ? .stringValue(y) : nil\n                            ^\n  \
    \                 Int(      )\n/tmp/tmpaihjjsa1.swift:28:57: error: cannot convert\
    \ value of type 'Double' to expected argument type 'Int'\n        return x > Double(y)!\
    \ ? .intValue(x) : Double(y)! > x ? .stringValue(y) : nil\n                  \
    \                                      ^\n                                   \
    \            Int(      )\n/tmp/tmpaihjjsa1.swift:30:16: error: cannot convert\
    \ value of type 'Double' to expected argument type 'Int'\n        return x > y\
    \ ? .doubleValue(x) : y > x ? .intValue(y) : nil\n               ^\n         \
    \      Int( )\n/tmp/tmpaihjjsa1.swift:30:46: error: cannot convert value of type\
    \ 'Double' to expected argument type 'Int'\n        return x > y ? .doubleValue(x)\
    \ : y > x ? .intValue(y) : nil\n                                             ^\n\
    \                                             Int( )\n/tmp/tmpaihjjsa1.swift:36:25:\
    \ error: cannot convert value of type 'Double' to expected argument type 'Int'\n\
    \        return Double(x)! > y ? .stringValue(x) : y > Double(x)! ? .intValue(y)\
    \ : nil\n                        ^\n               Int(      )\n/tmp/tmpaihjjsa1.swift:36:64:\
    \ error: cannot convert value of type 'Double' to expected argument type 'Int'\n\
    \        return Double(x)! > y ? .stringValue(x) : y > Double(x)! ? .intValue(y)\
    \ : nil\n                                                               ^\n  \
    \        "
  stdout: ''
  timestamp: 1660013180
- exit_code: 1
  program: "\nenum Value: Equatable, Hashable {\n    case intValue(Int)\n    case\
    \ doubleValue(Double)\n    case stringValue(String)\n}\n\n            \n/// Create\
    \ a function that takes integers, floats, or strings representing\n/// real numbers,\
    \ and returns the larger variable in its given variable type.\n/// Return nil\
    \ if the values are equal.\n/// Note: If a real number is represented as a string,\
    \ the floating point might be . or ,\n/// >>> compare_one(a: .intValue(1), b:\
    \ .doubleValue(2.5))\n/// .doubleValue(2.5)\n/// >>> compare_one(a: .intValue(1),\
    \ b: .stringValue(\"2,3\"))\n/// .stringValue(\"2,3\")\n/// >>> compare_one(a:\
    \ .stringValue(\"5,1\"), b: .stringValue(\"6\"))\n/// .stringValue(\"6\")\n///\
    \ >>> compare_one(a: .stringValue(\"1\"), b: .intValue(1))\n/// nil\nfunc compare_one(a:\
    \ Value, b: Value) -> Value? {\n    \n    let aDouble = a.asDouble()\n    let\
    \ bDouble = b.asDouble()\n    \n    if aDouble == nil && bDouble == nil {\n  \
    \      return nil\n    }\n    \n    if aDouble == nil {\n        return b\n  \
    \  }\n    \n    if bDouble == nil {\n        return a\n    }\n    \n    if aDouble!\
    \ >= bDouble! {\n        return a\n    } else {\n        return b\n    }\n}\n\n\
    \nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(compare_one(a: .intValue(1), b: .intValue(2))\
    \ == .intValue(2))\nassert(compare_one(a: .intValue(1), b: .doubleValue(2.5))\
    \ == .doubleValue(2.5))\nassert(compare_one(a: .intValue(2), b: .intValue(3))\
    \ == .intValue(3))\nassert(compare_one(a: .intValue(5), b: .intValue(6)) == .intValue(6))\n\
    assert(compare_one(a: .intValue(1), b: .stringValue(\"2,3\")) == .stringValue(\"\
    2,3\"))\nassert(compare_one(a: .stringValue(\"5,1\"), b: .stringValue(\"6\"))\
    \ == .stringValue(\"6\"))\nassert(compare_one(a: .stringValue(\"1\"), b: .stringValue(\"\
    2\")) == .stringValue(\"2\"))\nassert(compare_one(a: .stringValue(\"1\"), b: .intValue(1))\
    \ == nil)"
  status: SyntaxError
  stderr: "/tmp/tmpxjon0qwu.swift:23:21: error: value of type 'Value' has no member\
    \ 'asDouble'\n    let aDouble = a.asDouble()\n                  ~ ^~~~~~~~\n/tmp/tmpxjon0qwu.swift:24:21:\
    \ error: value of type 'Value' has no member 'asDouble'\n    let bDouble = b.asDouble()\n\
    \                  ~ ^~~~~~~~\n"
  stdout: ''
  timestamp: 1660013180
- exit_code: -4
  program: "\nenum Value: Equatable, Hashable {\n    case intValue(Int)\n    case\
    \ doubleValue(Double)\n    case stringValue(String)\n}\n\n            \n/// Create\
    \ a function that takes integers, floats, or strings representing\n/// real numbers,\
    \ and returns the larger variable in its given variable type.\n/// Return nil\
    \ if the values are equal.\n/// Note: If a real number is represented as a string,\
    \ the floating point might be . or ,\n/// >>> compare_one(a: .intValue(1), b:\
    \ .doubleValue(2.5))\n/// .doubleValue(2.5)\n/// >>> compare_one(a: .intValue(1),\
    \ b: .stringValue(\"2,3\"))\n/// .stringValue(\"2,3\")\n/// >>> compare_one(a:\
    \ .stringValue(\"5,1\"), b: .stringValue(\"6\"))\n/// .stringValue(\"6\")\n///\
    \ >>> compare_one(a: .stringValue(\"1\"), b: .intValue(1))\n/// nil\nfunc compare_one(a:\
    \ Value, b: Value) -> Value? {\n    // TODO: your code here\n    return nil\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(compare_one(a: .intValue(1), b: .intValue(2))\
    \ == .intValue(2))\nassert(compare_one(a: .intValue(1), b: .doubleValue(2.5))\
    \ == .doubleValue(2.5))\nassert(compare_one(a: .intValue(2), b: .intValue(3))\
    \ == .intValue(3))\nassert(compare_one(a: .intValue(5), b: .intValue(6)) == .intValue(6))\n\
    assert(compare_one(a: .intValue(1), b: .stringValue(\"2,3\")) == .stringValue(\"\
    2,3\"))\nassert(compare_one(a: .stringValue(\"5,1\"), b: .stringValue(\"6\"))\
    \ == .stringValue(\"6\"))\nassert(compare_one(a: .stringValue(\"1\"), b: .stringValue(\"\
    2\")) == .stringValue(\"2\"))\nassert(compare_one(a: .stringValue(\"1\"), b: .intValue(1))\
    \ == nil)"
  status: Exception
  stderr: 'tmp86psv7yz/tmp86psv7yz.swift:39: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002ab467c92c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002ab467989b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002ab467989988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002ab4679887b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmp86psv7yz                        0x0000558df5840a56 <unavailable> + 6742

    5    libc.so.6                          0x00002ab467e7e460 __libc_start_main +
    245

    6    tmp86psv7yz                        0x0000558df5840499 <unavailable> + 5273

    '
  stdout: ''
  timestamp: 1660013180
- exit_code: 1
  program: "\nenum Value: Equatable, Hashable {\n    case intValue(Int)\n    case\
    \ doubleValue(Double)\n    case stringValue(String)\n}\n\n            \n/// Create\
    \ a function that takes integers, floats, or strings representing\n/// real numbers,\
    \ and returns the larger variable in its given variable type.\n/// Return nil\
    \ if the values are equal.\n/// Note: If a real number is represented as a string,\
    \ the floating point might be . or ,\n/// >>> compare_one(a: .intValue(1), b:\
    \ .doubleValue(2.5))\n/// .doubleValue(2.5)\n/// >>> compare_one(a: .intValue(1),\
    \ b: .stringValue(\"2,3\"))\n/// .stringValue(\"2,3\")\n/// >>> compare_one(a:\
    \ .stringValue(\"5,1\"), b: .stringValue(\"6\"))\n/// .stringValue(\"6\")\n///\
    \ >>> compare_one(a: .stringValue(\"1\"), b: .intValue(1))\n/// nil\nfunc compare_one(a:\
    \ Value, b: Value) -> Value? {\n    switch (a, b) {\n    case let (.intValue(a_int),\
    \ .intValue(b_int)):\n        return a_int > b_int ? a : b_int > a_int ? b : nil\n\
    \    case let (.intValue(a_int), .doubleValue(b_double)):\n        return a_int\
    \ > b_double ? a : b_double > a_int ? b : nil\n    case let (.intValue(a_int),\
    \ .stringValue(b_string)):\n        return a_int > Double(b_string) ?? 0 ? a :\
    \ b\n    case let (.doubleValue(a_double), .intValue(b_int)):\n        return\
    \ a_double > b_int ? a : b_int > a_double ? b : nil\n    case let (.doubleValue(a_double),\
    \ .doubleValue(b_double)):\n        return a_double > b_double ? a : b_double\
    \ > a_double ? b : nil\n    case let (.doubleValue(a_double), .stringValue(b_string)):\n\
    \        return a_double > Double(b_string) ?? 0 ? a : b\n    case let (.stringValue(a_string),\
    \ .intValue(b_int)):\n        return Double(a_string) ?? 0 > b_int ? a : b\n \
    \   case let (.stringValue(a_string), .doubleValue(b_double)):\n        return\
    \ Double(a_string) ?? 0 > b_double ? a : b\n    case let (.stringValue(a_string),\
    \ .stringValue(b_string)):\n        return Double(a_string) ?? 0 > Double(b_string)\
    \ ?? 0 ? a : b_string > a_string ? b : nil\n    }\n}\n\n\nfunc ==(left: [(Int,\
    \ Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n\
    \        return false\n    }\n    for (l, r) in zip(left, right) {\n        if\
    \ l != r {\n            return false\n        }\n    }\n    return true\n}\n \
    \           \nassert(compare_one(a: .intValue(1), b: .intValue(2)) == .intValue(2))\n\
    assert(compare_one(a: .intValue(1), b: .doubleValue(2.5)) == .doubleValue(2.5))\n\
    assert(compare_one(a: .intValue(2), b: .intValue(3)) == .intValue(3))\nassert(compare_one(a:\
    \ .intValue(5), b: .intValue(6)) == .intValue(6))\nassert(compare_one(a: .intValue(1),\
    \ b: .stringValue(\"2,3\")) == .stringValue(\"2,3\"))\nassert(compare_one(a: .stringValue(\"\
    5,1\"), b: .stringValue(\"6\")) == .stringValue(\"6\"))\nassert(compare_one(a:\
    \ .stringValue(\"1\"), b: .stringValue(\"2\")) == .stringValue(\"2\"))\nassert(compare_one(a:\
    \ .stringValue(\"1\"), b: .intValue(1)) == nil)"
  status: SyntaxError
  stderr: "/tmp/tmp_jjc_jpy.swift:26:24: error: cannot convert value of type 'Double'\
    \ to expected argument type 'Int'\n        return a_int > b_double ? a : b_double\
    \ > a_int ? b : nil\n                       ^\n                       Int(   \
    \ )\n/tmp/tmp_jjc_jpy.swift:26:39: error: cannot convert value of type 'Double'\
    \ to expected argument type 'Int'\n        return a_int > b_double ? a : b_double\
    \ > a_int ? b : nil\n                                      ^\n               \
    \                       Int(    )\n/tmp/tmp_jjc_jpy.swift:28:41: error: cannot\
    \ convert value of type 'Double' to expected argument type 'Int'\n        return\
    \ a_int > Double(b_string) ?? 0 ? a : b\n                                    \
    \    ^\n                       Int(                 )\n/tmp/tmp_jjc_jpy.swift:30:16:\
    \ error: cannot convert value of type 'Double' to expected argument type 'Int'\n\
    \        return a_double > b_int ? a : b_int > a_double ? b : nil\n          \
    \     ^\n               Int(    )\n/tmp/tmp_jjc_jpy.swift:30:47: error: cannot\
    \ convert value of type 'Double' to expected argument type 'Int'\n        return\
    \ a_double > b_int ? a : b_int > a_double ? b : nil\n                        \
    \                      ^\n                                              Int( \
    \   )\n/tmp/tmp_jjc_jpy.swift:36:33: error: cannot convert value of type 'Double'\
    \ to expected argument type 'Int'\n        return Double(a_string) ?? 0 > b_int\
    \ ? a : b\n                                ^\n               Int(            \
    \     )\n"
  stdout: ''
  timestamp: 1660013180
- exit_code: 1
  program: "\nenum Value: Equatable, Hashable {\n    case intValue(Int)\n    case\
    \ doubleValue(Double)\n    case stringValue(String)\n}\n\n            \n/// Create\
    \ a function that takes integers, floats, or strings representing\n/// real numbers,\
    \ and returns the larger variable in its given variable type.\n/// Return nil\
    \ if the values are equal.\n/// Note: If a real number is represented as a string,\
    \ the floating point might be . or ,\n/// >>> compare_one(a: .intValue(1), b:\
    \ .doubleValue(2.5))\n/// .doubleValue(2.5)\n/// >>> compare_one(a: .intValue(1),\
    \ b: .stringValue(\"2,3\"))\n/// .stringValue(\"2,3\")\n/// >>> compare_one(a:\
    \ .stringValue(\"5,1\"), b: .stringValue(\"6\"))\n/// .stringValue(\"6\")\n///\
    \ >>> compare_one(a: .stringValue(\"1\"), b: .intValue(1))\n/// nil\nfunc compare_one(a:\
    \ Value, b: Value) -> Value? {\n    // YOUR CODE HERE\n    switch (a, b) {\n \
    \   case (.intValue(let a), .intValue(let b)):\n        return a > b ? a : b\n\
    \    case (.doubleValue(let a), .doubleValue(let b)):\n        return a > b ?\
    \ a : b\n    case (.stringValue(let a), .stringValue(let b)):\n        return\
    \ a > b ? a : b\n    default:\n        return nil\n    }\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(compare_one(a: .intValue(1), b: .intValue(2)) == .intValue(2))\n\
    assert(compare_one(a: .intValue(1), b: .doubleValue(2.5)) == .doubleValue(2.5))\n\
    assert(compare_one(a: .intValue(2), b: .intValue(3)) == .intValue(3))\nassert(compare_one(a:\
    \ .intValue(5), b: .intValue(6)) == .intValue(6))\nassert(compare_one(a: .intValue(1),\
    \ b: .stringValue(\"2,3\")) == .stringValue(\"2,3\"))\nassert(compare_one(a: .stringValue(\"\
    5,1\"), b: .stringValue(\"6\")) == .stringValue(\"6\"))\nassert(compare_one(a:\
    \ .stringValue(\"1\"), b: .stringValue(\"2\")) == .stringValue(\"2\"))\nassert(compare_one(a:\
    \ .stringValue(\"1\"), b: .intValue(1)) == nil)"
  status: SyntaxError
  stderr: "/tmp/tmp2g0gbjig.swift:25:22: error: cannot convert return expression of\
    \ type 'Int' to return type 'Value?'\n        return a > b ? a : b\n         \
    \      ~~~~~~^~~~~~~\n/tmp/tmp2g0gbjig.swift:27:22: error: cannot convert return\
    \ expression of type 'Double' to return type 'Value?'\n        return a > b ?\
    \ a : b\n               ~~~~~~^~~~~~~\n/tmp/tmp2g0gbjig.swift:29:22: error: cannot\
    \ convert return expression of type 'String' to return type 'Value?'\n       \
    \ return a > b ? a : b\n               ~~~~~~^~~~~~~\n"
  stdout: ''
  timestamp: 1660013180
- exit_code: 1
  program: "\nenum Value: Equatable, Hashable {\n    case intValue(Int)\n    case\
    \ doubleValue(Double)\n    case stringValue(String)\n}\n\n            \n/// Create\
    \ a function that takes integers, floats, or strings representing\n/// real numbers,\
    \ and returns the larger variable in its given variable type.\n/// Return nil\
    \ if the values are equal.\n/// Note: If a real number is represented as a string,\
    \ the floating point might be . or ,\n/// >>> compare_one(a: .intValue(1), b:\
    \ .doubleValue(2.5))\n/// .doubleValue(2.5)\n/// >>> compare_one(a: .intValue(1),\
    \ b: .stringValue(\"2,3\"))\n/// .stringValue(\"2,3\")\n/// >>> compare_one(a:\
    \ .stringValue(\"5,1\"), b: .stringValue(\"6\"))\n/// .stringValue(\"6\")\n///\
    \ >>> compare_one(a: .stringValue(\"1\"), b: .intValue(1))\n/// nil\nfunc compare_one(a:\
    \ Value, b: Value) -> Value? {\n    switch a {\n    case .intValue(let i):\n \
    \       switch b {\n        case .intValue(let j):\n            return i > j ?\
    \ a : (i < j ? b : nil)\n        case .doubleValue(let d):\n            return\
    \ d\n        case .stringValue(let s):\n            return .stringValue(s)\n \
    \       }\n    case .doubleValue(let d):\n        switch b {\n        case .intValue(let\
    \ i):\n            return a\n        case .doubleValue(let e):\n            return\
    \ d > e ? a : (d < e ? b : nil)\n        case .stringValue(let s):\n         \
    \   return .stringValue(s)\n        }\n    case .stringValue(let s):\n       \
    \ switch b {\n        case .intValue(let i):\n            return .stringValue(s)\n\
    \        case .doubleValue(let d):\n            return .stringValue(s)\n     \
    \   case .stringValue(let t):\n            if let ai = Int(s), let bi = Int(t)\
    \ {\n                return ai > bi ? a : (ai < bi ? b : nil)\n            } else\
    \ if let ad = Double(s), let bd = Double(t) {\n                return ad > bd\
    \ ? a : (ad < bd ? b : nil)\n            } else {\n                return a >\
    \ b ? a : (a < b ? b : nil)\n            }\n        }\n    }\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(compare_one(a: .intValue(1), b: .intValue(2)) == .intValue(2))\n\
    assert(compare_one(a: .intValue(1), b: .doubleValue(2.5)) == .doubleValue(2.5))\n\
    assert(compare_one(a: .intValue(2), b: .intValue(3)) == .intValue(3))\nassert(compare_one(a:\
    \ .intValue(5), b: .intValue(6)) == .intValue(6))\nassert(compare_one(a: .intValue(1),\
    \ b: .stringValue(\"2,3\")) == .stringValue(\"2,3\"))\nassert(compare_one(a: .stringValue(\"\
    5,1\"), b: .stringValue(\"6\")) == .stringValue(\"6\"))\nassert(compare_one(a:\
    \ .stringValue(\"1\"), b: .stringValue(\"2\")) == .stringValue(\"2\"))\nassert(compare_one(a:\
    \ .stringValue(\"1\"), b: .intValue(1)) == nil)"
  status: SyntaxError
  stderr: "/tmp/tmpod5oeyg_.swift:28:20: error: cannot convert return expression of\
    \ type 'Double' to return type 'Value?'\n            return d\n              \
    \     ^\n/tmp/tmpod5oeyg_.swift:53:26: error: referencing operator function '>'\
    \ on 'Comparable' requires that 'Value' conform to 'Comparable'\n            \
    \    return a > b ? a : (a < b ? b : nil)\n                         ^\nSwift.Comparable:1:17:\
    \ note: where 'Self' = 'Value'\npublic protocol Comparable : Equatable {\n   \
    \             ^\n/tmp/tmpod5oeyg_.swift:53:26: note: binary operator '>' cannot\
    \ be synthesized for enums with associated values\n                return a >\
    \ b ? a : (a < b ? b : nil)\n                         ^\n/tmp/tmpod5oeyg_.swift:53:39:\
    \ error: referencing operator function '<' on 'Comparable' requires that 'Value'\
    \ conform to 'Comparable'\n                return a > b ? a : (a < b ? b : nil)\n\
    \                                      ^\nSwift.Comparable:1:17: note: where 'Self'\
    \ = 'Value'\npublic protocol Comparable : Equatable {\n                ^\n/tmp/tmpod5oeyg_.swift:53:39:\
    \ note: binary operator '<' cannot be synthesized for enums with associated values\n\
    \                return a > b ? a : (a < b ? b : nil)\n                      \
    \                ^\n"
  stdout: ''
  timestamp: 1660013180
- exit_code: 1
  program: "\nenum Value: Equatable, Hashable {\n    case intValue(Int)\n    case\
    \ doubleValue(Double)\n    case stringValue(String)\n}\n\n            \n/// Create\
    \ a function that takes integers, floats, or strings representing\n/// real numbers,\
    \ and returns the larger variable in its given variable type.\n/// Return nil\
    \ if the values are equal.\n/// Note: If a real number is represented as a string,\
    \ the floating point might be . or ,\n/// >>> compare_one(a: .intValue(1), b:\
    \ .doubleValue(2.5))\n/// .doubleValue(2.5)\n/// >>> compare_one(a: .intValue(1),\
    \ b: .stringValue(\"2,3\"))\n/// .stringValue(\"2,3\")\n/// >>> compare_one(a:\
    \ .stringValue(\"5,1\"), b: .stringValue(\"6\"))\n/// .stringValue(\"6\")\n///\
    \ >>> compare_one(a: .stringValue(\"1\"), b: .intValue(1))\n/// nil\nfunc compare_one(a:\
    \ Value, b: Value) -> Value? {\n    switch a {\n    case .intValue(let intA):\n\
    \        switch b {\n        case .intValue(let intB):\n            return intA\
    \ > intB ? a : b\n        case .doubleValue(let doubleB):\n            return\
    \ doubleB > Double(intA) ? b : a\n        case .stringValue(let stringB):\n  \
    \          return Double(stringB) > Double(intA) ? b : a\n        }\n    case\
    \ .doubleValue(let doubleA):\n        switch b {\n        case .intValue(let intB):\n\
    \            return doubleA > Double(intB) ? a : b\n        case .doubleValue(let\
    \ doubleB):\n            return doubleA > doubleB ? a : b\n        case .stringValue(let\
    \ stringB):\n            return Double(stringB) > doubleA ? b : a\n        }\n\
    \    case .stringValue(let stringA):\n        switch b {\n        case .intValue(let\
    \ intB):\n            return Double(stringA) > Double(intB) ? a : b\n        case\
    \ .doubleValue(let doubleB):\n            return doubleB > Double(stringA) ? b\
    \ : a\n        case .stringValue(let stringB):\n            return Double(stringA)\
    \ > Double(stringB) ? a : b\n        }\n    }\n}\n\n\nfunc ==(left: [(Int, Int)],\
    \ right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n       \
    \ return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r\
    \ {\n            return false\n        }\n    }\n    return true\n}\n        \
    \    \nassert(compare_one(a: .intValue(1), b: .intValue(2)) == .intValue(2))\n\
    assert(compare_one(a: .intValue(1), b: .doubleValue(2.5)) == .doubleValue(2.5))\n\
    assert(compare_one(a: .intValue(2), b: .intValue(3)) == .intValue(3))\nassert(compare_one(a:\
    \ .intValue(5), b: .intValue(6)) == .intValue(6))\nassert(compare_one(a: .intValue(1),\
    \ b: .stringValue(\"2,3\")) == .stringValue(\"2,3\"))\nassert(compare_one(a: .stringValue(\"\
    5,1\"), b: .stringValue(\"6\")) == .stringValue(\"6\"))\nassert(compare_one(a:\
    \ .stringValue(\"1\"), b: .stringValue(\"2\")) == .stringValue(\"2\"))\nassert(compare_one(a:\
    \ .stringValue(\"1\"), b: .intValue(1)) == nil)"
  status: SyntaxError
  stderr: "/tmp/tmp99k8y4er.swift:30:20: error: value of optional type 'Double?' must\
    \ be unwrapped to a value of type 'Double'\n            return Double(stringB)\
    \ > Double(intA) ? b : a\n                   ^\n/tmp/tmp99k8y4er.swift:30:20:\
    \ note: coalesce using '??' to provide a default when the optional value contains\
    \ 'nil'\n            return Double(stringB) > Double(intA) ? b : a\n         \
    \          ^\n                                   ?? <#default value#>\n/tmp/tmp99k8y4er.swift:30:20:\
    \ note: force-unwrap using '!' to abort execution if the optional value contains\
    \ 'nil'\n            return Double(stringB) > Double(intA) ? b : a\n         \
    \          ^\n                                  !\n/tmp/tmp99k8y4er.swift:39:20:\
    \ error: value of optional type 'Double?' must be unwrapped to a value of type\
    \ 'Double'\n            return Double(stringB) > doubleA ? b : a\n           \
    \        ^\n/tmp/tmp99k8y4er.swift:39:20: note: coalesce using '??' to provide\
    \ a default when the optional value contains 'nil'\n            return Double(stringB)\
    \ > doubleA ? b : a\n                   ^\n                                  \
    \ ?? <#default value#>\n/tmp/tmp99k8y4er.swift:39:20: note: force-unwrap using\
    \ '!' to abort execution if the optional value contains 'nil'\n            return\
    \ Double(stringB) > doubleA ? b : a\n                   ^\n                  \
    \                !\n/tmp/tmp99k8y4er.swift:44:20: error: value of optional type\
    \ 'Double?' must be unwrapped to a value of type 'Double'\n            return\
    \ Double(stringA) > Double(intB) ? a : b\n                   ^\n/tmp/tmp99k8y4er.swift:44:20:\
    \ note: coalesce using '??' to provide a default when the optional value contains\
    \ 'nil'\n            return Double(stringA) > Double(intB) ? a : b\n         \
    \          ^\n                                   ?? <#default value#>\n/tmp/tmp99k8y4er.swift:44:20:\
    \ note: force-unwrap using '!' to abort execution if the optional value contains\
    \ 'nil'\n            return Double(stringA) > Double(intB) ? a : b\n         \
    \          ^\n                                  !\n/tmp/tmp99k8y4er.swift:46:30:\
    \ error"
  stdout: ''
  timestamp: 1660013180
- exit_code: -4
  program: "\nenum Value: Equatable, Hashable {\n    case intValue(Int)\n    case\
    \ doubleValue(Double)\n    case stringValue(String)\n}\n\n            \n/// Create\
    \ a function that takes integers, floats, or strings representing\n/// real numbers,\
    \ and returns the larger variable in its given variable type.\n/// Return nil\
    \ if the values are equal.\n/// Note: If a real number is represented as a string,\
    \ the floating point might be . or ,\n/// >>> compare_one(a: .intValue(1), b:\
    \ .doubleValue(2.5))\n/// .doubleValue(2.5)\n/// >>> compare_one(a: .intValue(1),\
    \ b: .stringValue(\"2,3\"))\n/// .stringValue(\"2,3\")\n/// >>> compare_one(a:\
    \ .stringValue(\"5,1\"), b: .stringValue(\"6\"))\n/// .stringValue(\"6\")\n///\
    \ >>> compare_one(a: .stringValue(\"1\"), b: .intValue(1))\n/// nil\nfunc compare_one(a:\
    \ Value, b: Value) -> Value? {\n    // TODO\n    return nil\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(compare_one(a: .intValue(1), b: .intValue(2)) == .intValue(2))\n\
    assert(compare_one(a: .intValue(1), b: .doubleValue(2.5)) == .doubleValue(2.5))\n\
    assert(compare_one(a: .intValue(2), b: .intValue(3)) == .intValue(3))\nassert(compare_one(a:\
    \ .intValue(5), b: .intValue(6)) == .intValue(6))\nassert(compare_one(a: .intValue(1),\
    \ b: .stringValue(\"2,3\")) == .stringValue(\"2,3\"))\nassert(compare_one(a: .stringValue(\"\
    5,1\"), b: .stringValue(\"6\")) == .stringValue(\"6\"))\nassert(compare_one(a:\
    \ .stringValue(\"1\"), b: .stringValue(\"2\")) == .stringValue(\"2\"))\nassert(compare_one(a:\
    \ .stringValue(\"1\"), b: .intValue(1)) == nil)"
  status: Exception
  stderr: 'tmpabopsadx/tmpabopsadx.swift:39: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b8c55590c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b8c55287b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b8c55287988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b8c552867b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpabopsadx                        0x00005652c4372a56 <unavailable> + 6742

    5    libc.so.6                          0x00002b8c5577c460 __libc_start_main +
    245

    6    tmpabopsadx                        0x00005652c4372499 <unavailable> + 5273

    '
  stdout: ''
  timestamp: 1660013180
- exit_code: 1
  program: "\nenum Value: Equatable, Hashable {\n    case intValue(Int)\n    case\
    \ doubleValue(Double)\n    case stringValue(String)\n}\n\n            \n/// Create\
    \ a function that takes integers, floats, or strings representing\n/// real numbers,\
    \ and returns the larger variable in its given variable type.\n/// Return nil\
    \ if the values are equal.\n/// Note: If a real number is represented as a string,\
    \ the floating point might be . or ,\n/// >>> compare_one(a: .intValue(1), b:\
    \ .doubleValue(2.5))\n/// .doubleValue(2.5)\n/// >>> compare_one(a: .intValue(1),\
    \ b: .stringValue(\"2,3\"))\n/// .stringValue(\"2,3\")\n/// >>> compare_one(a:\
    \ .stringValue(\"5,1\"), b: .stringValue(\"6\"))\n/// .stringValue(\"6\")\n///\
    \ >>> compare_one(a: .stringValue(\"1\"), b: .intValue(1))\n/// nil\nfunc compare_one(a:\
    \ Value, b: Value) -> Value? {\n    switch (a, b) {\n    case (.intValue(let a),\
    \ .intValue(let b)):\n        return a >= b ? a : b\n    case (.doubleValue(let\
    \ a), .doubleValue(let b)):\n        return a >= b ? a : b\n    case (.stringValue(let\
    \ a), .stringValue(let b)):\n        return a >= b ? a : b\n    case (.intValue(let\
    \ a), .doubleValue(let b)):\n        return a >= b ? a : b\n    case (.intValue(let\
    \ a), .stringValue(let b)):\n        return a >= b ? a : b\n    case (.doubleValue(let\
    \ a), .intValue(let b)):\n        return a >= b ? a : b\n    case (.doubleValue(let\
    \ a), .stringValue(let b)):\n        return a >= b ? a : b\n    case (.stringValue(let\
    \ a), .intValue(let b)):\n        return a >= b ? a : b\n    case (.stringValue(let\
    \ a), .doubleValue(let b)):\n        return a >= b ? a : b\n    default:\n   \
    \     return nil\n    }\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(compare_one(a:\
    \ .intValue(1), b: .intValue(2)) == .intValue(2))\nassert(compare_one(a: .intValue(1),\
    \ b: .doubleValue(2.5)) == .doubleValue(2.5))\nassert(compare_one(a: .intValue(2),\
    \ b: .intValue(3)) == .intValue(3))\nassert(compare_one(a: .intValue(5), b: .intValue(6))\
    \ == .intValue(6))\nassert(compare_one(a: .intValue(1), b: .stringValue(\"2,3\"\
    )) == .stringValue(\"2,3\"))\nassert(compare_one(a: .stringValue(\"5,1\"), b:\
    \ .stringValue(\"6\")) == .stringValue(\"6\"))\nassert(compare_one(a: .stringValue(\"\
    1\"), b: .stringValue(\"2\")) == .stringValue(\"2\"))\nassert(compare_one(a: .stringValue(\"\
    1\"), b: .intValue(1)) == nil)"
  status: SyntaxError
  stderr: "/tmp/tmpa4w3uz2b.swift:24:23: error: cannot convert return expression of\
    \ type 'Int' to return type 'Value?'\n        return a >= b ? a : b\n        \
    \       ~~~~~~~^~~~~~~\n/tmp/tmpa4w3uz2b.swift:26:23: error: cannot convert return\
    \ expression of type 'Double' to return type 'Value?'\n        return a >= b ?\
    \ a : b\n               ~~~~~~~^~~~~~~\n/tmp/tmpa4w3uz2b.swift:28:23: error: cannot\
    \ convert return expression of type 'String' to return type 'Value?'\n       \
    \ return a >= b ? a : b\n               ~~~~~~~^~~~~~~\n/tmp/tmpa4w3uz2b.swift:30:21:\
    \ error: cannot convert value of type 'Double' to expected argument type 'Int'\n\
    \        return a >= b ? a : b\n                    ^\n                    Int(\
    \ )\n/tmp/tmpa4w3uz2b.swift:30:23: error: cannot convert return expression of\
    \ type 'Int' to return type 'Value?'\n        return a >= b ? a : b\n        \
    \       ~~~~~~~^~~~~~~\n/tmp/tmpa4w3uz2b.swift:32:21: error: cannot convert value\
    \ of type 'String' to expected argument type 'Int'\n        return a >= b ? a\
    \ : b\n                    ^\n/tmp/tmpa4w3uz2b.swift:32:23: error: cannot convert\
    \ return expression of type 'Int' to return type 'Value?'\n        return a >=\
    \ b ? a : b\n               ~~~~~~~^~~~~~~\n/tmp/tmpa4w3uz2b.swift:34:16: error:\
    \ cannot convert value of type 'Double' to expected argument type 'Int'\n    \
    \    return a >= b ? a : b\n               ^\n               Int( )\n/tmp/tmpa4w3uz2b.swift:34:23:\
    \ error: cannot convert return expression of type 'Double' to return type 'Value?'\n\
    \        return a >= b ? a : b\n               ~~~~~~~^~~~~~~\n/tmp/tmpa4w3uz2b.swift:36:18:\
    \ error: binary operator '>=' cannot be applied to operands of type 'Double' and\
    \ 'String'\n        return a >= b ? a : b\n               ~ ^  ~\n/tmp/tmpa4w3uz2b.swift:36:23:\
    \ error: cannot convert return expression of type 'Double' to return type 'Value?'\n\
    \        return a >= b ? a : b\n               ~~~~~~~^~~~~~~\n/tmp/tmpa4w3uz2b.swift:38:16:\
    \ error: cannot convert value of type 'String' to expected argument type 'Int'\n\
    \        return a >= b ? a : b\n               ^\n/tmp/tmpa4w3uz2"
  stdout: ''
  timestamp: 1660013180
- exit_code: 1
  program: "\nenum Value: Equatable, Hashable {\n    case intValue(Int)\n    case\
    \ doubleValue(Double)\n    case stringValue(String)\n}\n\n            \n/// Create\
    \ a function that takes integers, floats, or strings representing\n/// real numbers,\
    \ and returns the larger variable in its given variable type.\n/// Return nil\
    \ if the values are equal.\n/// Note: If a real number is represented as a string,\
    \ the floating point might be . or ,\n/// >>> compare_one(a: .intValue(1), b:\
    \ .doubleValue(2.5))\n/// .doubleValue(2.5)\n/// >>> compare_one(a: .intValue(1),\
    \ b: .stringValue(\"2,3\"))\n/// .stringValue(\"2,3\")\n/// >>> compare_one(a:\
    \ .stringValue(\"5,1\"), b: .stringValue(\"6\"))\n/// .stringValue(\"6\")\n///\
    \ >>> compare_one(a: .stringValue(\"1\"), b: .intValue(1))\n/// nil\nfunc compare_one(a:\
    \ Value, b: Value) -> Value? {\n    \n    switch (a, b) {\n    case (.intValue(let\
    \ aVal), .intValue(let bVal)):\n        return aVal > bVal ? a : b\n    case (.doubleValue(let\
    \ aVal), .doubleValue(let bVal)):\n        return aVal > bVal ? a : b\n    case\
    \ (.stringValue(let aVal), .stringValue(let bVal)):\n        return aVal > bVal\
    \ ? a : b\n    case (.intValue(let aVal), .doubleValue(let bVal)):\n        return\
    \ aVal > bVal ? a : b\n    case (.intValue(let aVal), .stringValue(let bVal)):\n\
    \        return aVal > bVal ? a : b\n    case (.doubleValue(let aVal), .intValue(let\
    \ bVal)):\n        return aVal > bVal ? a : b\n    case (.doubleValue(let aVal),\
    \ .stringValue(let bVal)):\n        return aVal > bVal ? a : b\n    case (.stringValue(let\
    \ aVal), .intValue(let bVal)):\n        return aVal > bVal ? a : b\n    case (.stringValue(let\
    \ aVal), .doubleValue(let bVal)):\n        return aVal > bVal ? a : b\n    default:\n\
    \        return nil\n    }\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(compare_one(a:\
    \ .intValue(1), b: .intValue(2)) == .intValue(2))\nassert(compare_one(a: .intValue(1),\
    \ b: .doubleValue(2.5)) == .doubleValue(2.5))\nassert(compare_one(a: .intValue(2),\
    \ b: .intValue(3)) == .intValue(3))\nassert(compare_one(a: .intValue(5), b: .intValue(6))\
    \ == .intValue(6))\nassert(compare_one(a: .intValue(1), b: .stringValue(\"2,3\"\
    )) == .stringValue(\"2,3\"))\nassert(compare_one(a: .stringValue(\"5,1\"), b:\
    \ .stringValue(\"6\")) == .stringValue(\"6\"))\nassert(compare_one(a: .stringValue(\"\
    1\"), b: .stringValue(\"2\")) == .stringValue(\"2\"))\nassert(compare_one(a: .stringValue(\"\
    1\"), b: .intValue(1)) == nil)"
  status: SyntaxError
  stderr: "/tmp/tmpj3pvm673.swift:31:23: error: cannot convert value of type 'Double'\
    \ to expected argument type 'Int'\n        return aVal > bVal ? a : b\n      \
    \                ^\n                      Int()\n/tmp/tmpj3pvm673.swift:33:23:\
    \ error: cannot convert value of type 'String' to expected argument type 'Int'\n\
    \        return aVal > bVal ? a : b\n                      ^\n/tmp/tmpj3pvm673.swift:35:16:\
    \ error: cannot convert value of type 'Double' to expected argument type 'Int'\n\
    \        return aVal > bVal ? a : b\n               ^\n               Int()\n\
    /tmp/tmpj3pvm673.swift:37:21: error: binary operator '>' cannot be applied to\
    \ operands of type 'Double' and 'String'\n        return aVal > bVal ? a : b\n\
    \               ~~~~ ^ ~~~~\n/tmp/tmpj3pvm673.swift:39:16: error: cannot convert\
    \ value of type 'String' to expected argument type 'Int'\n        return aVal\
    \ > bVal ? a : b\n               ^\n/tmp/tmpj3pvm673.swift:41:21: error: binary\
    \ operator '>' cannot be applied to operands of type 'String' and 'Double'\n \
    \       return aVal > bVal ? a : b\n               ~~~~ ^ ~~~~\n"
  stdout: ''
  timestamp: 1660013180
- exit_code: 1
  program: "\nenum Value: Equatable, Hashable {\n    case intValue(Int)\n    case\
    \ doubleValue(Double)\n    case stringValue(String)\n}\n\n            \n/// Create\
    \ a function that takes integers, floats, or strings representing\n/// real numbers,\
    \ and returns the larger variable in its given variable type.\n/// Return nil\
    \ if the values are equal.\n/// Note: If a real number is represented as a string,\
    \ the floating point might be . or ,\n/// >>> compare_one(a: .intValue(1), b:\
    \ .doubleValue(2.5))\n/// .doubleValue(2.5)\n/// >>> compare_one(a: .intValue(1),\
    \ b: .stringValue(\"2,3\"))\n/// .stringValue(\"2,3\")\n/// >>> compare_one(a:\
    \ .stringValue(\"5,1\"), b: .stringValue(\"6\"))\n/// .stringValue(\"6\")\n///\
    \ >>> compare_one(a: .stringValue(\"1\"), b: .intValue(1))\n/// nil\nfunc compare_one(a:\
    \ Value, b: Value) -> Value? {\n    \n    var aValue = 0.0\n    var bValue = 0.0\n\
    \    \n    switch a {\n    case .intValue(let value):\n        aValue = Double(value)\n\
    \    case .doubleValue(let value):\n        aValue = value\n    case .stringValue(let\
    \ value):\n        aValue = Double(value.components(separatedBy: \",\").joined())\
    \ ?? Double(value) ?? 0.0\n    }\n    \n    switch b {\n    case .intValue(let\
    \ value):\n        bValue = Double(value)\n    case .doubleValue(let value):\n\
    \        bValue = value\n    case .stringValue(let value):\n        bValue = Double(value.components(separatedBy:\
    \ \",\").joined()) ?? Double(value) ?? 0.0\n    }\n    \n    if aValue > bValue\
    \ {\n        return a\n    } else if aValue < bValue {\n        return b\n   \
    \ } else {\n        return nil\n    }\n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(compare_one(a: .intValue(1), b: .intValue(2)) == .intValue(2))\nassert(compare_one(a:\
    \ .intValue(1), b: .doubleValue(2.5)) == .doubleValue(2.5))\nassert(compare_one(a:\
    \ .intValue(2), b: .intValue(3)) == .intValue(3))\nassert(compare_one(a: .intValue(5),\
    \ b: .intValue(6)) == .intValue(6))\nassert(compare_one(a: .intValue(1), b: .stringValue(\"\
    2,3\")) == .stringValue(\"2,3\"))\nassert(compare_one(a: .stringValue(\"5,1\"\
    ), b: .stringValue(\"6\")) == .stringValue(\"6\"))\nassert(compare_one(a: .stringValue(\"\
    1\"), b: .stringValue(\"2\")) == .stringValue(\"2\"))\nassert(compare_one(a: .stringValue(\"\
    1\"), b: .intValue(1)) == nil)"
  status: SyntaxError
  stderr: "/tmp/tmpa0cqc9ae.swift:32:31: error: value of type 'String' has no member\
    \ 'components'\n        aValue = Double(value.components(separatedBy: \",\").joined())\
    \ ?? Double(value) ?? 0.0\n                        ~~~~~ ^~~~~~~~~~\n/tmp/tmpa0cqc9ae.swift:41:31:\
    \ error: value of type 'String' has no member 'components'\n        bValue = Double(value.components(separatedBy:\
    \ \",\").joined()) ?? Double(value) ?? 0.0\n                        ~~~~~ ^~~~~~~~~~\n"
  stdout: ''
  timestamp: 1660013180
- exit_code: -4
  program: "\nenum Value: Equatable, Hashable {\n    case intValue(Int)\n    case\
    \ doubleValue(Double)\n    case stringValue(String)\n}\n\n            \n/// Create\
    \ a function that takes integers, floats, or strings representing\n/// real numbers,\
    \ and returns the larger variable in its given variable type.\n/// Return nil\
    \ if the values are equal.\n/// Note: If a real number is represented as a string,\
    \ the floating point might be . or ,\n/// >>> compare_one(a: .intValue(1), b:\
    \ .doubleValue(2.5))\n/// .doubleValue(2.5)\n/// >>> compare_one(a: .intValue(1),\
    \ b: .stringValue(\"2,3\"))\n/// .stringValue(\"2,3\")\n/// >>> compare_one(a:\
    \ .stringValue(\"5,1\"), b: .stringValue(\"6\"))\n/// .stringValue(\"6\")\n///\
    \ >>> compare_one(a: .stringValue(\"1\"), b: .intValue(1))\n/// nil\nfunc compare_one(a:\
    \ Value, b: Value) -> Value? {\n    var aa = 0.0\n    var bb = 0.0\n    switch\
    \ a {\n    case .intValue(let ai):\n        aa = Double(ai)\n    case .doubleValue(let\
    \ ad):\n        aa = ad\n    case .stringValue(let as_):\n        if let aas =\
    \ Double(as_) {\n            aa = aas\n        }\n    }\n    switch b {\n    case\
    \ .intValue(let bi):\n        bb = Double(bi)\n    case .doubleValue(let bd):\n\
    \        bb = bd\n    case .stringValue(let bs_):\n        if let bbs = Double(bs_)\
    \ {\n            bb = bbs\n        }\n    }\n    if aa > bb {\n        switch\
    \ a {\n        case .intValue(let ai):\n            return .intValue(ai)\n   \
    \     case .doubleValue(let ad):\n            return .doubleValue(ad)\n      \
    \  case .stringValue(let as_):\n            return .stringValue(as_)\n       \
    \ }\n    } else if aa < bb {\n        switch b {\n        case .intValue(let bi):\n\
    \            return .intValue(bi)\n        case .doubleValue(let bd):\n      \
    \      return .doubleValue(bd)\n        case .stringValue(let bs_):\n        \
    \    return .stringValue(bs_)\n        }\n    } else {\n        return nil\n \
    \   }\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n   \
    \ if left.count != right.count {\n        return false\n    }\n    for (l, r)\
    \ in zip(left, right) {\n        if l != r {\n            return false\n     \
    \   }\n    }\n    return true\n}\n            \nassert(compare_one(a: .intValue(1),\
    \ b: .intValue(2)) == .intValue(2))\nassert(compare_one(a: .intValue(1), b: .doubleValue(2.5))\
    \ == .doubleValue(2.5))\nassert(compare_one(a: .intValue(2), b: .intValue(3))\
    \ == .intValue(3))\nassert(compare_one(a: .intValue(5), b: .intValue(6)) == .intValue(6))\n\
    assert(compare_one(a: .intValue(1), b: .stringValue(\"2,3\")) == .stringValue(\"\
    2,3\"))\nassert(compare_one(a: .stringValue(\"5,1\"), b: .stringValue(\"6\"))\
    \ == .stringValue(\"6\"))\nassert(compare_one(a: .stringValue(\"1\"), b: .stringValue(\"\
    2\")) == .stringValue(\"2\"))\nassert(compare_one(a: .stringValue(\"1\"), b: .intValue(1))\
    \ == nil)"
  status: Exception
  stderr: 'tmp60mx2va7/tmp60mx2va7.swift:84: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b2151485c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b215117cb6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b215117c988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b215117b7b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmp60mx2va7                        0x000055971dab578b <unavailable> + 10123

    5    libc.so.6                          0x00002b2151671460 __libc_start_main +
    245

    6    tmp60mx2va7                        0x000055971dab4539 <unavailable> + 5433

    '
  stdout: ''
  timestamp: 1660013180
- exit_code: 1
  program: "\nenum Value: Equatable, Hashable {\n    case intValue(Int)\n    case\
    \ doubleValue(Double)\n    case stringValue(String)\n}\n\n            \n/// Create\
    \ a function that takes integers, floats, or strings representing\n/// real numbers,\
    \ and returns the larger variable in its given variable type.\n/// Return nil\
    \ if the values are equal.\n/// Note: If a real number is represented as a string,\
    \ the floating point might be . or ,\n/// >>> compare_one(a: .intValue(1), b:\
    \ .doubleValue(2.5))\n/// .doubleValue(2.5)\n/// >>> compare_one(a: .intValue(1),\
    \ b: .stringValue(\"2,3\"))\n/// .stringValue(\"2,3\")\n/// >>> compare_one(a:\
    \ .stringValue(\"5,1\"), b: .stringValue(\"6\"))\n/// .stringValue(\"6\")\n///\
    \ >>> compare_one(a: .stringValue(\"1\"), b: .intValue(1))\n/// nil\nfunc compare_one(a:\
    \ Value, b: Value) -> Value? {\n    switch (a, b) {\n    case (.intValue(let aInt),\
    \ .intValue(let bInt)):\n        if aInt > bInt {\n            return .intValue(aInt)\n\
    \        } else if aInt < bInt {\n            return .intValue(bInt)\n       \
    \ } else {\n            return nil\n        }\n    case (.intValue(let aInt),\
    \ .doubleValue(let bDouble)):\n        if Double(aInt) > bDouble {\n         \
    \   return .doubleValue(Double(aInt))\n        } else if Double(aInt) < bDouble\
    \ {\n            return .doubleValue(bDouble)\n        } else {\n            return\
    \ nil\n        }\n    case (.intValue(let aInt), .stringValue(let bString)):\n\
    \        if Double(aInt) > stringToDouble(string: bString) {\n            return\
    \ .doubleValue(Double(aInt))\n        } else if Double(aInt) < stringToDouble(string:\
    \ bString) {\n            return .stringValue(bString)\n        } else {\n   \
    \         return nil\n        }\n    case (.doubleValue(let aDouble), .intValue(let\
    \ bInt)):\n        if aDouble > Double(bInt) {\n            return .doubleValue(aDouble)\n\
    \        } else if aDouble < Double(bInt) {\n            return .doubleValue(Double(bInt))\n\
    \        } else {\n            return nil\n        }\n    case (.doubleValue(let\
    \ aDouble), .doubleValue(let bDouble)):\n        if aDouble > bDouble {\n    \
    \        return .doubleValue(aDouble)\n        } else if aDouble < bDouble {\n\
    \            return .doubleValue(bDouble)\n        } else {\n            return\
    \ nil\n        }\n    case (.doubleValue(let aDouble), .stringValue(let bString)):\n\
    \        if aDouble > stringToDouble(string: bString) {\n            return .doubleValue(aDouble)\n\
    \        } else if aDouble < stringToDouble(string: bString) {\n            return\
    \ .stringValue(bString)\n        } else {\n            return nil\n        }\n\
    \    case (.stringValue(let aString), .intValue(let bInt)\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(compare_one(a: .intValue(1), b: .intValue(2)) == .intValue(2))\n\
    assert(compare_one(a: .intValue(1), b: .doubleValue(2.5)) == .doubleValue(2.5))\n\
    assert(compare_one(a: .intValue(2), b: .intValue(3)) == .intValue(3))\nassert(compare_one(a:\
    \ .intValue(5), b: .intValue(6)) == .intValue(6))\nassert(compare_one(a: .intValue(1),\
    \ b: .stringValue(\"2,3\")) == .stringValue(\"2,3\"))\nassert(compare_one(a: .stringValue(\"\
    5,1\"), b: .stringValue(\"6\")) == .stringValue(\"6\"))\nassert(compare_one(a:\
    \ .stringValue(\"1\"), b: .stringValue(\"2\")) == .stringValue(\"2\"))\nassert(compare_one(a:\
    \ .stringValue(\"1\"), b: .intValue(1)) == nil)"
  status: SyntaxError
  stderr: "/tmp/tmpvio2ke_e.swift:72:1: error: expected ')' in expression list\n}\n\
    ^\n/tmp/tmpvio2ke_e.swift:71:10: note: to match this opening '('\n    case (.stringValue(let\
    \ aString), .intValue(let bInt)\n         ^\n/tmp/tmpvio2ke_e.swift:71:57: error:\
    \ expected ':' after 'case'\n    case (.stringValue(let aString), .intValue(let\
    \ bInt)\n                                                        ^\n/tmp/tmpvio2ke_e.swift:94:66:\
    \ error: expected '}' at end of brace statement\nassert(compare_one(a: .stringValue(\"\
    1\"), b: .intValue(1)) == nil)\n                                             \
    \                    ^\n/tmp/tmpvio2ke_e.swift:21:48: note: to match this opening\
    \ '{'\nfunc compare_one(a: Value, b: Value) -> Value? {\n                    \
    \                           ^\n/tmp/tmpvio2ke_e.swift:40:27: error: cannot find\
    \ 'stringToDouble' in scope\n        if Double(aInt) > stringToDouble(string:\
    \ bString) {\n                          ^~~~~~~~~~~~~~\n/tmp/tmpvio2ke_e.swift:42:34:\
    \ error: cannot find 'stringToDouble' in scope\n        } else if Double(aInt)\
    \ < stringToDouble(string: bString) {\n                                 ^~~~~~~~~~~~~~\n\
    /tmp/tmpvio2ke_e.swift:64:22: error: cannot find 'stringToDouble' in scope\n \
    \       if aDouble > stringToDouble(string: bString) {\n                     ^~~~~~~~~~~~~~\n\
    /tmp/tmpvio2ke_e.swift:66:29: error: cannot find 'stringToDouble' in scope\n \
    \       } else if aDouble < stringToDouble(string: bString) {\n              \
    \              ^~~~~~~~~~~~~~\n/tmp/tmpvio2ke_e.swift:22:5: error: switch must\
    \ be exhaustive\n    switch (a, b) {\n    ^\n/tmp/tmpvio2ke_e.swift:22:5: note:\
    \ add missing case: '(.stringValue(_), .doubleValue(_))'\n    switch (a, b) {\n\
    \    ^\n/tmp/tmpvio2ke_e.swift:22:5: note: add missing case: '(.stringValue(_),\
    \ .stringValue(_))'\n    switch (a, b) {\n    ^\n/tmp/tmpvio2ke_e.swift:75:6:\
    \ error: operator functions can only be declared at global or in type scope\n\
    func ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n     ^\n"
  stdout: ''
  timestamp: 1660013180
- exit_code: -4
  program: "\nenum Value: Equatable, Hashable {\n    case intValue(Int)\n    case\
    \ doubleValue(Double)\n    case stringValue(String)\n}\n\n            \n/// Create\
    \ a function that takes integers, floats, or strings representing\n/// real numbers,\
    \ and returns the larger variable in its given variable type.\n/// Return nil\
    \ if the values are equal.\n/// Note: If a real number is represented as a string,\
    \ the floating point might be . or ,\n/// >>> compare_one(a: .intValue(1), b:\
    \ .doubleValue(2.5))\n/// .doubleValue(2.5)\n/// >>> compare_one(a: .intValue(1),\
    \ b: .stringValue(\"2,3\"))\n/// .stringValue(\"2,3\")\n/// >>> compare_one(a:\
    \ .stringValue(\"5,1\"), b: .stringValue(\"6\"))\n/// .stringValue(\"6\")\n///\
    \ >>> compare_one(a: .stringValue(\"1\"), b: .intValue(1))\n/// nil\nfunc compare_one(a:\
    \ Value, b: Value) -> Value? {\n    // TODO: Implement function here\n    return\
    \ nil\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n   \
    \ if left.count != right.count {\n        return false\n    }\n    for (l, r)\
    \ in zip(left, right) {\n        if l != r {\n            return false\n     \
    \   }\n    }\n    return true\n}\n            \nassert(compare_one(a: .intValue(1),\
    \ b: .intValue(2)) == .intValue(2))\nassert(compare_one(a: .intValue(1), b: .doubleValue(2.5))\
    \ == .doubleValue(2.5))\nassert(compare_one(a: .intValue(2), b: .intValue(3))\
    \ == .intValue(3))\nassert(compare_one(a: .intValue(5), b: .intValue(6)) == .intValue(6))\n\
    assert(compare_one(a: .intValue(1), b: .stringValue(\"2,3\")) == .stringValue(\"\
    2,3\"))\nassert(compare_one(a: .stringValue(\"5,1\"), b: .stringValue(\"6\"))\
    \ == .stringValue(\"6\"))\nassert(compare_one(a: .stringValue(\"1\"), b: .stringValue(\"\
    2\")) == .stringValue(\"2\"))\nassert(compare_one(a: .stringValue(\"1\"), b: .intValue(1))\
    \ == nil)"
  status: Exception
  stderr: 'tmpn4vc654_/tmpn4vc654_.swift:39: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b2c24c40c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b2c24937b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b2c24937988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b2c249367b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpn4vc654_                        0x000055c76b881a56 <unavailable> + 6742

    5    libc.so.6                          0x00002b2c24e2c460 __libc_start_main +
    245

    6    tmpn4vc654_                        0x000055c76b881499 <unavailable> + 5273

    '
  stdout: ''
  timestamp: 1660013180
- exit_code: 1
  program: "\nenum Value: Equatable, Hashable {\n    case intValue(Int)\n    case\
    \ doubleValue(Double)\n    case stringValue(String)\n}\n\n            \n/// Create\
    \ a function that takes integers, floats, or strings representing\n/// real numbers,\
    \ and returns the larger variable in its given variable type.\n/// Return nil\
    \ if the values are equal.\n/// Note: If a real number is represented as a string,\
    \ the floating point might be . or ,\n/// >>> compare_one(a: .intValue(1), b:\
    \ .doubleValue(2.5))\n/// .doubleValue(2.5)\n/// >>> compare_one(a: .intValue(1),\
    \ b: .stringValue(\"2,3\"))\n/// .stringValue(\"2,3\")\n/// >>> compare_one(a:\
    \ .stringValue(\"5,1\"), b: .stringValue(\"6\"))\n/// .stringValue(\"6\")\n///\
    \ >>> compare_one(a: .stringValue(\"1\"), b: .intValue(1))\n/// nil\nfunc compare_one(a:\
    \ Value, b: Value) -> Value? {\n    \n    switch (a, b) {\n    case let (.intValue(left),\
    \ .intValue(right)):\n        if left == right {\n            return nil\n   \
    \     } else {\n            return left > right ? a : b\n        }\n    case let\
    \ (.doubleValue(left), .doubleValue(right)):\n        if left == right {\n   \
    \         return nil\n        } else {\n            return left > right ? a :\
    \ b\n        }\n    case let (.stringValue(left), .stringValue(right)):\n    \
    \    let leftInt = Int(left.replacingOccurrences(of: \",\", with: \".\"))\n  \
    \      let rightInt = Int(right.replacingOccurrences(of: \",\", with: \".\"))\n\
    \        if leftInt == rightInt {\n            return nil\n        } else {\n\
    \            return leftInt! > rightInt! ? a : b\n        }\n    case let (.intValue(left),\
    \ .doubleValue(right)):\n        if left == right {\n            return nil\n\
    \        } else {\n            return left > right ? a : b\n        }\n    case\
    \ let (.intValue(left), .stringValue(right)):\n        let rightInt = Int(right.replacingOccurrences(of:\
    \ \",\", with: \".\"))\n        if left == rightInt {\n            return nil\n\
    \        } else {\n            return left > rightInt! ? a : b\n        }\n  \
    \  case let (.doubleValue(left), .intValue(right)):\n        if left == right\
    \ {\n            return nil\n        } else {\n            return left > right\
    \ ? a : b\n        }\n    case let (.doubleValue(left), .stringValue(right)):\n\
    \        let rightInt = Int(right.replacingOccurrences(of: \",\", with: \".\"\
    ))\n        if left == rightInt {\n            return nil\n        } else {\n\
    \            return left > rightInt! ? a : b\n        }\n    case let (.stringValue(left),\
    \ .intValue(right)):\n        let leftInt = Int(left.replacingOccurrences(of:\
    \ \",\", with: \".\"))\n        if leftInt == right {\n            return nil\n\
    \        } else {\n            return\n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(compare_one(a: .intValue(1), b: .intValue(2)) == .intValue(2))\nassert(compare_one(a:\
    \ .intValue(1), b: .doubleValue(2.5)) == .doubleValue(2.5))\nassert(compare_one(a:\
    \ .intValue(2), b: .intValue(3)) == .intValue(3))\nassert(compare_one(a: .intValue(5),\
    \ b: .intValue(6)) == .intValue(6))\nassert(compare_one(a: .intValue(1), b: .stringValue(\"\
    2,3\")) == .stringValue(\"2,3\"))\nassert(compare_one(a: .stringValue(\"5,1\"\
    ), b: .stringValue(\"6\")) == .stringValue(\"6\"))\nassert(compare_one(a: .stringValue(\"\
    1\"), b: .stringValue(\"2\")) == .stringValue(\"2\"))\nassert(compare_one(a: .stringValue(\"\
    1\"), b: .intValue(1)) == nil)"
  status: SyntaxError
  stderr: "/tmp/tmpksou45qw.swift:98:66: error: expected '}' at end of 'switch' statement\n\
    assert(compare_one(a: .stringValue(\"1\"), b: .intValue(1)) == nil)\n        \
    \                                                         ^\n/tmp/tmpksou45qw.swift:23:19:\
    \ note: to match this opening '{'\n    switch (a, b) {\n                  ^\n\
    /tmp/tmpksou45qw.swift:98:66: error: expected '}' at end of brace statement\n\
    assert(compare_one(a: .stringValue(\"1\"), b: .intValue(1)) == nil)\n        \
    \                                                         ^\n/tmp/tmpksou45qw.swift:21:48:\
    \ note: to match this opening '{'\nfunc compare_one(a: Value, b: Value) -> Value?\
    \ {\n                                               ^\n/tmp/tmpksou45qw.swift:37:32:\
    \ error: value of type 'String' has no member 'replacingOccurrences'\n       \
    \ let leftInt = Int(left.replacingOccurrences(of: \",\", with: \".\"))\n     \
    \                     ~~~~ ^~~~~~~~~~~~~~~~~~~~\n/tmp/tmpksou45qw.swift:38:34:\
    \ error: value of type 'String' has no member 'replacingOccurrences'\n       \
    \ let rightInt = Int(right.replacingOccurrences(of: \",\", with: \".\"))\n   \
    \                        ~~~~~ ^~~~~~~~~~~~~~~~~~~~\n/tmp/tmpksou45qw.swift:45:17:\
    \ error: binary operator '==' cannot be applied to operands of type 'Int' and\
    \ 'Double'\n        if left == right {\n           ~~~~ ^  ~~~~~\n/tmp/tmpksou45qw.swift:45:17:\
    \ note: overloads for '==' exist with these partially matching parameter lists:\
    \ (Int, Int)\n        if left == right {\n                ^\n/tmp/tmpksou45qw.swift:48:27:\
    \ error: cannot convert value of type 'Double' to expected argument type 'Int'\n\
    \            return left > right ? a : b\n                          ^\n      \
    \                    Int( )\n/tmp/tmpksou45qw.swift:51:34: error: value of type\
    \ 'String' has no member 'replacingOccurrences'\n        let rightInt = Int(right.replacingOccurrences(of:\
    \ \",\", with: \".\"))\n                           ~~~~~ ^~~~~~~~~~~~~~~~~~~~\n\
    /tmp/tmpksou45qw.swift:58:17: error: binary operator '==' cannot be applied to\
    \ operands of type 'Double' and 'Int'\n        if left == right {\n          "
  stdout: ''
  timestamp: 1660013180
- exit_code: 1
  program: "\nenum Value: Equatable, Hashable {\n    case intValue(Int)\n    case\
    \ doubleValue(Double)\n    case stringValue(String)\n}\n\n            \n/// Create\
    \ a function that takes integers, floats, or strings representing\n/// real numbers,\
    \ and returns the larger variable in its given variable type.\n/// Return nil\
    \ if the values are equal.\n/// Note: If a real number is represented as a string,\
    \ the floating point might be . or ,\n/// >>> compare_one(a: .intValue(1), b:\
    \ .doubleValue(2.5))\n/// .doubleValue(2.5)\n/// >>> compare_one(a: .intValue(1),\
    \ b: .stringValue(\"2,3\"))\n/// .stringValue(\"2,3\")\n/// >>> compare_one(a:\
    \ .stringValue(\"5,1\"), b: .stringValue(\"6\"))\n/// .stringValue(\"6\")\n///\
    \ >>> compare_one(a: .stringValue(\"1\"), b: .intValue(1))\n/// nil\nfunc compare_one(a:\
    \ Value, b: Value) -> Value? {\n    var aValue: Double = 0\n    var bValue: Double\
    \ = 0\n    switch a {\n    case .intValue(let int):\n        aValue = Double(int)\n\
    \    case .doubleValue(let double):\n        aValue = double\n    case .stringValue(let\
    \ string):\n        aValue = Double(string.replacingOccurrences(of: \",\", with:\
    \ \".\")) ?? 0\n    }\n    switch b {\n    case .intValue(let int):\n        bValue\
    \ = Double(int)\n    case .doubleValue(let double):\n        bValue = double\n\
    \    case .stringValue(let string):\n        bValue = Double(string.replacingOccurrences(of:\
    \ \",\", with: \".\")) ?? 0\n    }\n    if aValue == bValue {\n        return\
    \ nil\n    } else if aValue > bValue {\n        return a\n    } else {\n     \
    \   return b\n    }\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) ->\
    \ Bool {\n    if left.count != right.count {\n        return false\n    }\n  \
    \  for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(compare_one(a: .intValue(1),\
    \ b: .intValue(2)) == .intValue(2))\nassert(compare_one(a: .intValue(1), b: .doubleValue(2.5))\
    \ == .doubleValue(2.5))\nassert(compare_one(a: .intValue(2), b: .intValue(3))\
    \ == .intValue(3))\nassert(compare_one(a: .intValue(5), b: .intValue(6)) == .intValue(6))\n\
    assert(compare_one(a: .intValue(1), b: .stringValue(\"2,3\")) == .stringValue(\"\
    2,3\"))\nassert(compare_one(a: .stringValue(\"5,1\"), b: .stringValue(\"6\"))\
    \ == .stringValue(\"6\"))\nassert(compare_one(a: .stringValue(\"1\"), b: .stringValue(\"\
    2\")) == .stringValue(\"2\"))\nassert(compare_one(a: .stringValue(\"1\"), b: .intValue(1))\
    \ == nil)"
  status: SyntaxError
  stderr: "/tmp/tmp4ntb9f79.swift:30:32: error: value of type 'String' has no member\
    \ 'replacingOccurrences'\n        aValue = Double(string.replacingOccurrences(of:\
    \ \",\", with: \".\")) ?? 0\n                        ~~~~~~ ^~~~~~~~~~~~~~~~~~~~\n\
    /tmp/tmp4ntb9f79.swift:38:32: error: value of type 'String' has no member 'replacingOccurrences'\n\
    \        bValue = Double(string.replacingOccurrences(of: \",\", with: \".\"))\
    \ ?? 0\n                        ~~~~~~ ^~~~~~~~~~~~~~~~~~~~\n"
  stdout: ''
  timestamp: 1660013180
- exit_code: 1
  program: "\nenum Value: Equatable, Hashable {\n    case intValue(Int)\n    case\
    \ doubleValue(Double)\n    case stringValue(String)\n}\n\n            \n/// Create\
    \ a function that takes integers, floats, or strings representing\n/// real numbers,\
    \ and returns the larger variable in its given variable type.\n/// Return nil\
    \ if the values are equal.\n/// Note: If a real number is represented as a string,\
    \ the floating point might be . or ,\n/// >>> compare_one(a: .intValue(1), b:\
    \ .doubleValue(2.5))\n/// .doubleValue(2.5)\n/// >>> compare_one(a: .intValue(1),\
    \ b: .stringValue(\"2,3\"))\n/// .stringValue(\"2,3\")\n/// >>> compare_one(a:\
    \ .stringValue(\"5,1\"), b: .stringValue(\"6\"))\n/// .stringValue(\"6\")\n///\
    \ >>> compare_one(a: .stringValue(\"1\"), b: .intValue(1))\n/// nil\nfunc compare_one(a:\
    \ Value, b: Value) -> Value? {\n    switch (a, b) {\n    case (.intValue(let ai),\
    \ .intValue(let bi)):\n        return ai >= bi ? a : b\n    case (.intValue(let\
    \ ai), .doubleValue(let bd)):\n        return ai >= bd ? a : b\n    case (.intValue(let\
    \ ai), .stringValue(let bs)):\n        if let bd = Double(bs) {\n            return\
    \ ai >= bd ? a : b\n        }\n        else {\n            return b\n        }\n\
    \    case (.doubleValue(let ad), .intValue(let bi)):\n        return ad >= bi\
    \ ? a : b\n    case (.doubleValue(let ad), .doubleValue(let bd)):\n        return\
    \ ad >= bd ? a : b\n    case (.doubleValue(let ad), .stringValue(let bs)):\n \
    \       if let bd = Double(bs) {\n            return ad >= bd ? a : b\n      \
    \  }\n        else {\n            return b\n        }\n    case (.stringValue(let\
    \ as_), .intValue(let bi)):\n        if let ad = Double(as_) {\n            return\
    \ ad >= bi ? a : b\n        }\n        else {\n            return a\n        }\n\
    \    case (.stringValue(let as_), .doubleValue(let bd)):\n        if let ad =\
    \ Double(as_) {\n            return ad >= bd ? a : b\n        }\n        else\
    \ {\n            return b\n        }\n    case (.stringValue(let as_), .stringValue(let\
    \ bs)):\n        if let ad = Double(as_), let bd = Double(bs) {\n            return\
    \ ad >= bd ? a : b\n        }\n        else {\n            return as_ >= bs ?\
    \ a : b\n        }\n    }\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(compare_one(a:\
    \ .intValue(1), b: .intValue(2)) == .intValue(2))\nassert(compare_one(a: .intValue(1),\
    \ b: .doubleValue(2.5)) == .doubleValue(2.5))\nassert(compare_one(a: .intValue(2),\
    \ b: .intValue(3)) == .intValue(3))\nassert(compare_one(a: .intValue(5), b: .intValue(6))\
    \ == .intValue(6))\nassert(compare_one(a: .intValue(1), b: .stringValue(\"2,3\"\
    )) == .stringValue(\"2,3\"))\nassert(compare_one(a: .stringValue(\"5,1\"), b:\
    \ .stringValue(\"6\")) == .stringValue(\"6\"))\nassert(compare_one(a: .stringValue(\"\
    1\"), b: .stringValue(\"2\")) == .stringValue(\"2\"))\nassert(compare_one(a: .stringValue(\"\
    1\"), b: .intValue(1)) == nil)"
  status: SyntaxError
  stderr: "/tmp/tmpwd23cx6a.swift:26:22: error: cannot convert value of type 'Double'\
    \ to expected argument type 'Int'\n        return ai >= bd ? a : b\n         \
    \            ^\n                     Int( )\n/tmp/tmpwd23cx6a.swift:29:26: error:\
    \ cannot convert value of type 'Double' to expected argument type 'Int'\n    \
    \        return ai >= bd ? a : b\n                         ^\n               \
    \          Int( )\n/tmp/tmpwd23cx6a.swift:35:16: error: cannot convert value of\
    \ type 'Double' to expected argument type 'Int'\n        return ad >= bi ? a :\
    \ b\n               ^\n               Int( )\n/tmp/tmpwd23cx6a.swift:47:20: error:\
    \ cannot convert value of type 'Double' to expected argument type 'Int'\n    \
    \        return ad >= bi ? a : b\n                   ^\n                   Int(\
    \ )\n"
  stdout: ''
  timestamp: 1660013180
- exit_code: 1
  program: "\nenum Value: Equatable, Hashable {\n    case intValue(Int)\n    case\
    \ doubleValue(Double)\n    case stringValue(String)\n}\n\n            \n/// Create\
    \ a function that takes integers, floats, or strings representing\n/// real numbers,\
    \ and returns the larger variable in its given variable type.\n/// Return nil\
    \ if the values are equal.\n/// Note: If a real number is represented as a string,\
    \ the floating point might be . or ,\n/// >>> compare_one(a: .intValue(1), b:\
    \ .doubleValue(2.5))\n/// .doubleValue(2.5)\n/// >>> compare_one(a: .intValue(1),\
    \ b: .stringValue(\"2,3\"))\n/// .stringValue(\"2,3\")\n/// >>> compare_one(a:\
    \ .stringValue(\"5,1\"), b: .stringValue(\"6\"))\n/// .stringValue(\"6\")\n///\
    \ >>> compare_one(a: .stringValue(\"1\"), b: .intValue(1))\n/// nil\nfunc compare_one(a:\
    \ Value, b: Value) -> Value? {\n    switch (a, b) {\n    case (.intValue(let a),\
    \ .intValue(let b)):\n        return a > b ? a : b\n    case (.doubleValue(let\
    \ a), .doubleValue(let b)):\n        return a > b ? a : b\n    case (.stringValue(let\
    \ a), .stringValue(let b)):\n        return a > b ? a : b\n    case (.intValue(let\
    \ a), .doubleValue(let b)):\n        return a > b ? a : b\n    case (.intValue(let\
    \ a), .stringValue(let b)):\n        return a > b ? a : b\n    case (.doubleValue(let\
    \ a), .intValue(let b)):\n        return a > b ? a : b\n    case (.doubleValue(let\
    \ a), .stringValue(let b)):\n        return a > b ? a : b\n    case (.stringValue(let\
    \ a), .intValue(let b)):\n        return a > b ? a : b\n    case (.stringValue(let\
    \ a), .doubleValue(let b)):\n        return a > b ? a : b\n    default:\n    \
    \    return nil\n    }\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(compare_one(a:\
    \ .intValue(1), b: .intValue(2)) == .intValue(2))\nassert(compare_one(a: .intValue(1),\
    \ b: .doubleValue(2.5)) == .doubleValue(2.5))\nassert(compare_one(a: .intValue(2),\
    \ b: .intValue(3)) == .intValue(3))\nassert(compare_one(a: .intValue(5), b: .intValue(6))\
    \ == .intValue(6))\nassert(compare_one(a: .intValue(1), b: .stringValue(\"2,3\"\
    )) == .stringValue(\"2,3\"))\nassert(compare_one(a: .stringValue(\"5,1\"), b:\
    \ .stringValue(\"6\")) == .stringValue(\"6\"))\nassert(compare_one(a: .stringValue(\"\
    1\"), b: .stringValue(\"2\")) == .stringValue(\"2\"))\nassert(compare_one(a: .stringValue(\"\
    1\"), b: .intValue(1)) == nil)"
  status: SyntaxError
  stderr: "/tmp/tmpjf037tzu.swift:24:22: error: cannot convert return expression of\
    \ type 'Int' to return type 'Value?'\n        return a > b ? a : b\n         \
    \      ~~~~~~^~~~~~~\n/tmp/tmpjf037tzu.swift:26:22: error: cannot convert return\
    \ expression of type 'Double' to return type 'Value?'\n        return a > b ?\
    \ a : b\n               ~~~~~~^~~~~~~\n/tmp/tmpjf037tzu.swift:28:22: error: cannot\
    \ convert return expression of type 'String' to return type 'Value?'\n       \
    \ return a > b ? a : b\n               ~~~~~~^~~~~~~\n/tmp/tmpjf037tzu.swift:30:20:\
    \ error: cannot convert value of type 'Double' to expected argument type 'Int'\n\
    \        return a > b ? a : b\n                   ^\n                   Int( )\n\
    /tmp/tmpjf037tzu.swift:30:22: error: cannot convert return expression of type\
    \ 'Int' to return type 'Value?'\n        return a > b ? a : b\n              \
    \ ~~~~~~^~~~~~~\n/tmp/tmpjf037tzu.swift:32:20: error: cannot convert value of\
    \ type 'String' to expected argument type 'Int'\n        return a > b ? a : b\n\
    \                   ^\n/tmp/tmpjf037tzu.swift:32:22: error: cannot convert return\
    \ expression of type 'Int' to return type 'Value?'\n        return a > b ? a :\
    \ b\n               ~~~~~~^~~~~~~\n/tmp/tmpjf037tzu.swift:34:16: error: cannot\
    \ convert value of type 'Double' to expected argument type 'Int'\n        return\
    \ a > b ? a : b\n               ^\n               Int( )\n/tmp/tmpjf037tzu.swift:34:22:\
    \ error: cannot convert return expression of type 'Double' to return type 'Value?'\n\
    \        return a > b ? a : b\n               ~~~~~~^~~~~~~\n/tmp/tmpjf037tzu.swift:36:18:\
    \ error: binary operator '>' cannot be applied to operands of type 'Double' and\
    \ 'String'\n        return a > b ? a : b\n               ~ ^ ~\n/tmp/tmpjf037tzu.swift:36:22:\
    \ error: cannot convert return expression of type 'Double' to return type 'Value?'\n\
    \        return a > b ? a : b\n               ~~~~~~^~~~~~~\n/tmp/tmpjf037tzu.swift:38:16:\
    \ error: cannot convert value of type 'String' to expected argument type 'Int'\n\
    \        return a > b ? a : b\n               ^\n/tmp/tmpjf037tzu.swift:38:22:\
    \ error: ca"
  stdout: ''
  timestamp: 1660013180
- exit_code: 1
  program: "\nenum Value: Equatable, Hashable {\n    case intValue(Int)\n    case\
    \ doubleValue(Double)\n    case stringValue(String)\n}\n\n            \n/// Create\
    \ a function that takes integers, floats, or strings representing\n/// real numbers,\
    \ and returns the larger variable in its given variable type.\n/// Return nil\
    \ if the values are equal.\n/// Note: If a real number is represented as a string,\
    \ the floating point might be . or ,\n/// >>> compare_one(a: .intValue(1), b:\
    \ .doubleValue(2.5))\n/// .doubleValue(2.5)\n/// >>> compare_one(a: .intValue(1),\
    \ b: .stringValue(\"2,3\"))\n/// .stringValue(\"2,3\")\n/// >>> compare_one(a:\
    \ .stringValue(\"5,1\"), b: .stringValue(\"6\"))\n/// .stringValue(\"6\")\n///\
    \ >>> compare_one(a: .stringValue(\"1\"), b: .intValue(1))\n/// nil\nfunc compare_one(a:\
    \ Value, b: Value) -> Value? {\n    switch (a, b) {\n    case (.intValue(let a),\
    \ .intValue(let b)):\n        return a > b ? a : b\n    case (.doubleValue(let\
    \ a), .doubleValue(let b)):\n        return a > b ? a : b\n    case (.stringValue(let\
    \ a), .stringValue(let b)):\n        return a > b ? a : b\n    default:\n    \
    \    return nil\n    }\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(compare_one(a:\
    \ .intValue(1), b: .intValue(2)) == .intValue(2))\nassert(compare_one(a: .intValue(1),\
    \ b: .doubleValue(2.5)) == .doubleValue(2.5))\nassert(compare_one(a: .intValue(2),\
    \ b: .intValue(3)) == .intValue(3))\nassert(compare_one(a: .intValue(5), b: .intValue(6))\
    \ == .intValue(6))\nassert(compare_one(a: .intValue(1), b: .stringValue(\"2,3\"\
    )) == .stringValue(\"2,3\"))\nassert(compare_one(a: .stringValue(\"5,1\"), b:\
    \ .stringValue(\"6\")) == .stringValue(\"6\"))\nassert(compare_one(a: .stringValue(\"\
    1\"), b: .stringValue(\"2\")) == .stringValue(\"2\"))\nassert(compare_one(a: .stringValue(\"\
    1\"), b: .intValue(1)) == nil)"
  status: SyntaxError
  stderr: "/tmp/tmp07haxekb.swift:24:22: error: cannot convert return expression of\
    \ type 'Int' to return type 'Value?'\n        return a > b ? a : b\n         \
    \      ~~~~~~^~~~~~~\n/tmp/tmp07haxekb.swift:26:22: error: cannot convert return\
    \ expression of type 'Double' to return type 'Value?'\n        return a > b ?\
    \ a : b\n               ~~~~~~^~~~~~~\n/tmp/tmp07haxekb.swift:28:22: error: cannot\
    \ convert return expression of type 'String' to return type 'Value?'\n       \
    \ return a > b ? a : b\n               ~~~~~~^~~~~~~\n"
  stdout: ''
  timestamp: 1660013180
- exit_code: 1
  program: "\nenum Value: Equatable, Hashable {\n    case intValue(Int)\n    case\
    \ doubleValue(Double)\n    case stringValue(String)\n}\n\n            \n/// Create\
    \ a function that takes integers, floats, or strings representing\n/// real numbers,\
    \ and returns the larger variable in its given variable type.\n/// Return nil\
    \ if the values are equal.\n/// Note: If a real number is represented as a string,\
    \ the floating point might be . or ,\n/// >>> compare_one(a: .intValue(1), b:\
    \ .doubleValue(2.5))\n/// .doubleValue(2.5)\n/// >>> compare_one(a: .intValue(1),\
    \ b: .stringValue(\"2,3\"))\n/// .stringValue(\"2,3\")\n/// >>> compare_one(a:\
    \ .stringValue(\"5,1\"), b: .stringValue(\"6\"))\n/// .stringValue(\"6\")\n///\
    \ >>> compare_one(a: .stringValue(\"1\"), b: .intValue(1))\n/// nil\nfunc compare_one(a:\
    \ Value, b: Value) -> Value? {\n    let aValue = evaluate(a)\n    let bValue =\
    \ evaluate(b)\n    if aValue > bValue {\n        return a\n    } else if aValue\
    \ < bValue {\n        return b\n    } else {\n        return nil\n    }\n}\n\n\
    \nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(compare_one(a: .intValue(1), b: .intValue(2))\
    \ == .intValue(2))\nassert(compare_one(a: .intValue(1), b: .doubleValue(2.5))\
    \ == .doubleValue(2.5))\nassert(compare_one(a: .intValue(2), b: .intValue(3))\
    \ == .intValue(3))\nassert(compare_one(a: .intValue(5), b: .intValue(6)) == .intValue(6))\n\
    assert(compare_one(a: .intValue(1), b: .stringValue(\"2,3\")) == .stringValue(\"\
    2,3\"))\nassert(compare_one(a: .stringValue(\"5,1\"), b: .stringValue(\"6\"))\
    \ == .stringValue(\"6\"))\nassert(compare_one(a: .stringValue(\"1\"), b: .stringValue(\"\
    2\")) == .stringValue(\"2\"))\nassert(compare_one(a: .stringValue(\"1\"), b: .intValue(1))\
    \ == nil)"
  status: SyntaxError
  stderr: "/tmp/tmpjhi4r9uh.swift:22:18: error: cannot find 'evaluate' in scope\n\
    \    let aValue = evaluate(a)\n                 ^~~~~~~~\n/tmp/tmpjhi4r9uh.swift:23:18:\
    \ error: cannot find 'evaluate' in scope\n    let bValue = evaluate(b)\n     \
    \            ^~~~~~~~\n"
  stdout: ''
  timestamp: 1660013180
- exit_code: 1
  program: "\nenum Value: Equatable, Hashable {\n    case intValue(Int)\n    case\
    \ doubleValue(Double)\n    case stringValue(String)\n}\n\n            \n/// Create\
    \ a function that takes integers, floats, or strings representing\n/// real numbers,\
    \ and returns the larger variable in its given variable type.\n/// Return nil\
    \ if the values are equal.\n/// Note: If a real number is represented as a string,\
    \ the floating point might be . or ,\n/// >>> compare_one(a: .intValue(1), b:\
    \ .doubleValue(2.5))\n/// .doubleValue(2.5)\n/// >>> compare_one(a: .intValue(1),\
    \ b: .stringValue(\"2,3\"))\n/// .stringValue(\"2,3\")\n/// >>> compare_one(a:\
    \ .stringValue(\"5,1\"), b: .stringValue(\"6\"))\n/// .stringValue(\"6\")\n///\
    \ >>> compare_one(a: .stringValue(\"1\"), b: .intValue(1))\n/// nil\nfunc compare_one(a:\
    \ Value, b: Value) -> Value? {\n    var left: Double = 0\n    var right: Double\
    \ = 0\n    switch a {\n    case .intValue(let value):\n        left = Double(value)\n\
    \    case .doubleValue(let value):\n        left = value\n    case .stringValue(let\
    \ value):\n        left = Double(value.replacingOccurrences(of: \",\", with: \"\
    .\")) ?? Double(value)!\n    }\n    switch b {\n    case .intValue(let value):\n\
    \        right = Double(value)\n    case .doubleValue(let value):\n        right\
    \ = value\n    case .stringValue(let value):\n        right = Double(value.replacingOccurrences(of:\
    \ \",\", with: \".\")) ?? Double(value)!\n    }\n    return left > right ? a :\
    \ (left < right ? b : nil)\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(compare_one(a:\
    \ .intValue(1), b: .intValue(2)) == .intValue(2))\nassert(compare_one(a: .intValue(1),\
    \ b: .doubleValue(2.5)) == .doubleValue(2.5))\nassert(compare_one(a: .intValue(2),\
    \ b: .intValue(3)) == .intValue(3))\nassert(compare_one(a: .intValue(5), b: .intValue(6))\
    \ == .intValue(6))\nassert(compare_one(a: .intValue(1), b: .stringValue(\"2,3\"\
    )) == .stringValue(\"2,3\"))\nassert(compare_one(a: .stringValue(\"5,1\"), b:\
    \ .stringValue(\"6\")) == .stringValue(\"6\"))\nassert(compare_one(a: .stringValue(\"\
    1\"), b: .stringValue(\"2\")) == .stringValue(\"2\"))\nassert(compare_one(a: .stringValue(\"\
    1\"), b: .intValue(1)) == nil)"
  status: SyntaxError
  stderr: "/tmp/tmp181vwxky.swift:30:29: error: value of type 'String' has no member\
    \ 'replacingOccurrences'\n        left = Double(value.replacingOccurrences(of:\
    \ \",\", with: \".\")) ?? Double(value)!\n                      ~~~~~ ^~~~~~~~~~~~~~~~~~~~\n\
    /tmp/tmp181vwxky.swift:38:30: error: value of type 'String' has no member 'replacingOccurrences'\n\
    \        right = Double(value.replacingOccurrences(of: \",\", with: \".\")) ??\
    \ Double(value)!\n                       ~~~~~ ^~~~~~~~~~~~~~~~~~~~\n"
  stdout: ''
  timestamp: 1660013180
- exit_code: 0
  program: "\nenum Value: Equatable, Hashable {\n    case intValue(Int)\n    case\
    \ doubleValue(Double)\n    case stringValue(String)\n}\n\n            \n/// Create\
    \ a function that takes integers, floats, or strings representing\n/// real numbers,\
    \ and returns the larger variable in its given variable type.\n/// Return nil\
    \ if the values are equal.\n/// Note: If a real number is represented as a string,\
    \ the floating point might be . or ,\n/// >>> compare_one(a: .intValue(1), b:\
    \ .doubleValue(2.5))\n/// .doubleValue(2.5)\n/// >>> compare_one(a: .intValue(1),\
    \ b: .stringValue(\"2,3\"))\n/// .stringValue(\"2,3\")\n/// >>> compare_one(a:\
    \ .stringValue(\"5,1\"), b: .stringValue(\"6\"))\n/// .stringValue(\"6\")\n///\
    \ >>> compare_one(a: .stringValue(\"1\"), b: .intValue(1))\n/// nil\nfunc compare_one(a:\
    \ Value, b: Value) -> Value? {\n    if case .intValue(let a) = a, case .intValue(let\
    \ b) = b {\n        return b > a ? .intValue(b) : nil\n    } else if case .doubleValue(let\
    \ a) = a, case .doubleValue(let b) = b {\n        return b > a ? .doubleValue(b)\
    \ : nil\n    } else if case .stringValue(let a) = a, case .stringValue(let b)\
    \ = b {\n        return b > a ? .stringValue(b) : nil\n    } else if case .intValue(let\
    \ a) = a, case .doubleValue(let b) = b {\n        return b > Double(a) ? .doubleValue(b)\
    \ : nil\n    } else if case .intValue(let a) = a, case .stringValue(let b) = b\
    \ {\n        let a = \"\\(a)\"\n        return b > a ? .stringValue(b) : nil\n\
    \    } else if case .doubleValue(let a) = a, case .intValue(let b) = b {\n   \
    \     return b > Int(a) ? .intValue(b) : nil\n    } else if case .doubleValue(let\
    \ a) = a, case .stringValue(let b) = b {\n        let a = \"\\(a)\"\n        return\
    \ b > a ? .stringValue(b) : nil\n    } else if case .stringValue(let a) = a, case\
    \ .intValue(let b) = b {\n        let b = \"\\(b)\"\n        return b > a ? .stringValue(b)\
    \ : nil\n    } else if case .stringValue(let a) = a, case .doubleValue(let b)\
    \ = b {\n        let b = \"\\(b)\"\n        return b > a ? .stringValue(b) : nil\n\
    \    }\n    return nil\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(compare_one(a:\
    \ .intValue(1), b: .intValue(2)) == .intValue(2))\nassert(compare_one(a: .intValue(1),\
    \ b: .doubleValue(2.5)) == .doubleValue(2.5))\nassert(compare_one(a: .intValue(2),\
    \ b: .intValue(3)) == .intValue(3))\nassert(compare_one(a: .intValue(5), b: .intValue(6))\
    \ == .intValue(6))\nassert(compare_one(a: .intValue(1), b: .stringValue(\"2,3\"\
    )) == .stringValue(\"2,3\"))\nassert(compare_one(a: .stringValue(\"5,1\"), b:\
    \ .stringValue(\"6\")) == .stringValue(\"6\"))\nassert(compare_one(a: .stringValue(\"\
    1\"), b: .stringValue(\"2\")) == .stringValue(\"2\"))\nassert(compare_one(a: .stringValue(\"\
    1\"), b: .intValue(1)) == nil)"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660013180
- exit_code: 1
  program: "\nenum Value: Equatable, Hashable {\n    case intValue(Int)\n    case\
    \ doubleValue(Double)\n    case stringValue(String)\n}\n\n            \n/// Create\
    \ a function that takes integers, floats, or strings representing\n/// real numbers,\
    \ and returns the larger variable in its given variable type.\n/// Return nil\
    \ if the values are equal.\n/// Note: If a real number is represented as a string,\
    \ the floating point might be . or ,\n/// >>> compare_one(a: .intValue(1), b:\
    \ .doubleValue(2.5))\n/// .doubleValue(2.5)\n/// >>> compare_one(a: .intValue(1),\
    \ b: .stringValue(\"2,3\"))\n/// .stringValue(\"2,3\")\n/// >>> compare_one(a:\
    \ .stringValue(\"5,1\"), b: .stringValue(\"6\"))\n/// .stringValue(\"6\")\n///\
    \ >>> compare_one(a: .stringValue(\"1\"), b: .intValue(1))\n/// nil\nfunc compare_one(a:\
    \ Value, b: Value) -> Value? {\n    switch (a, b) {\n    case (.intValue(let aInt),\
    \ .intValue(let bInt)):\n        return aInt > bInt ? a : bInt > aInt ? b : nil\n\
    \    case (.intValue(let aInt), .doubleValue(let bDouble)):\n        return aInt\
    \ > bDouble ? a : bDouble > aInt ? b : nil\n    case (.intValue(let aInt), .stringValue(let\
    \ bString)):\n        let bDouble = Double(bString) ?? -Double.infinity\n    \
    \    return aInt > bDouble ? a : bDouble > aInt ? b : nil\n    case (.doubleValue(let\
    \ aDouble), .intValue(let bInt)):\n        return aDouble > bInt ? a : bInt >\
    \ aDouble ? b : nil\n    case (.doubleValue(let aDouble), .doubleValue(let bDouble)):\n\
    \        return aDouble > bDouble ? a : bDouble > aDouble ? b : nil\n    case\
    \ (.doubleValue(let aDouble), .stringValue(let bString)):\n        let bDouble\
    \ = Double(bString) ?? -Double.infinity\n        return aDouble > bDouble ? a\
    \ : bDouble > aDouble ? b : nil\n    case (.stringValue(let aString), .intValue(let\
    \ bInt)):\n        let aDouble = Double(aString) ?? -Double.infinity\n       \
    \ return aDouble > bInt ? a : bInt > aDouble ? b : nil\n    case (.stringValue(let\
    \ aString), .doubleValue(let bDouble)):\n        let aDouble = Double(aString)\
    \ ?? -Double.infinity\n        return aDouble > bDouble ? a : bDouble > aDouble\
    \ ? b : nil\n    case (.stringValue(let aString), .stringValue(let bString)):\n\
    \        let aDouble = Double(aString) ?? -Double.infinity\n        let bDouble\
    \ = Double(bString) ?? -Double.infinity\n        return aDouble > bDouble ? a\
    \ : bDouble > aDouble ? b : nil\n    }\n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(compare_one(a: .intValue(1), b: .intValue(2)) == .intValue(2))\nassert(compare_one(a:\
    \ .intValue(1), b: .doubleValue(2.5)) == .doubleValue(2.5))\nassert(compare_one(a:\
    \ .intValue(2), b: .intValue(3)) == .intValue(3))\nassert(compare_one(a: .intValue(5),\
    \ b: .intValue(6)) == .intValue(6))\nassert(compare_one(a: .intValue(1), b: .stringValue(\"\
    2,3\")) == .stringValue(\"2,3\"))\nassert(compare_one(a: .stringValue(\"5,1\"\
    ), b: .stringValue(\"6\")) == .stringValue(\"6\"))\nassert(compare_one(a: .stringValue(\"\
    1\"), b: .stringValue(\"2\")) == .stringValue(\"2\"))\nassert(compare_one(a: .stringValue(\"\
    1\"), b: .intValue(1)) == nil)"
  status: SyntaxError
  stderr: "/tmp/tmpruh9rahy.swift:26:23: error: cannot convert value of type 'Double'\
    \ to expected argument type 'Int'\n        return aInt > bDouble ? a : bDouble\
    \ > aInt ? b : nil\n                      ^\n                      Int(   )\n\
    /tmp/tmpruh9rahy.swift:26:37: error: cannot convert value of type 'Double' to\
    \ expected argument type 'Int'\n        return aInt > bDouble ? a : bDouble >\
    \ aInt ? b : nil\n                                    ^\n                    \
    \                Int(   )\n/tmp/tmpruh9rahy.swift:29:23: error: cannot convert\
    \ value of type 'Double' to expected argument type 'Int'\n        return aInt\
    \ > bDouble ? a : bDouble > aInt ? b : nil\n                      ^\n        \
    \              Int(   )\n/tmp/tmpruh9rahy.swift:29:37: error: cannot convert value\
    \ of type 'Double' to expected argument type 'Int'\n        return aInt > bDouble\
    \ ? a : bDouble > aInt ? b : nil\n                                    ^\n    \
    \                                Int(   )\n/tmp/tmpruh9rahy.swift:31:16: error:\
    \ cannot convert value of type 'Double' to expected argument type 'Int'\n    \
    \    return aDouble > bInt ? a : bInt > aDouble ? b : nil\n               ^\n\
    \               Int(   )\n/tmp/tmpruh9rahy.swift:31:44: error: cannot convert\
    \ value of type 'Double' to expected argument type 'Int'\n        return aDouble\
    \ > bInt ? a : bInt > aDouble ? b : nil\n                                    \
    \       ^\n                                           Int(   )\n/tmp/tmpruh9rahy.swift:39:16:\
    \ error: cannot convert value of type 'Double' to expected argument type 'Int'\n\
    \        return aDouble > bInt ? a : bInt > aDouble ? b : nil\n              \
    \ ^\n               Int(   )\n/tmp/tmpruh9rahy.swift:39:44: error: cannot convert\
    \ value of type 'Double' to expected argument type 'Int'\n        return aDouble\
    \ > bInt ? a : bInt > aDouble ? b : nil\n                                    \
    \       ^\n                                           Int(   )\n"
  stdout: ''
  timestamp: 1660013180
- exit_code: 1
  program: "\nenum Value: Equatable, Hashable {\n    case intValue(Int)\n    case\
    \ doubleValue(Double)\n    case stringValue(String)\n}\n\n            \n/// Create\
    \ a function that takes integers, floats, or strings representing\n/// real numbers,\
    \ and returns the larger variable in its given variable type.\n/// Return nil\
    \ if the values are equal.\n/// Note: If a real number is represented as a string,\
    \ the floating point might be . or ,\n/// >>> compare_one(a: .intValue(1), b:\
    \ .doubleValue(2.5))\n/// .doubleValue(2.5)\n/// >>> compare_one(a: .intValue(1),\
    \ b: .stringValue(\"2,3\"))\n/// .stringValue(\"2,3\")\n/// >>> compare_one(a:\
    \ .stringValue(\"5,1\"), b: .stringValue(\"6\"))\n/// .stringValue(\"6\")\n///\
    \ >>> compare_one(a: .stringValue(\"1\"), b: .intValue(1))\n/// nil\nfunc compare_one(a:\
    \ Value, b: Value) -> Value? {\n    var result: Value?\n    switch a {\n    case\
    \ .intValue(let a):\n        switch b {\n        case .intValue(let b):\n    \
    \        if a > b {\n                result = a\n            } else if a < b {\n\
    \                result = b\n            }\n        case .doubleValue(let b):\n\
    \            if Double(a) > b {\n                result = .doubleValue(Double(a))\n\
    \            } else if Double(a) < b {\n                result = .doubleValue(b)\n\
    \            }\n        case .stringValue(let b):\n            if Double(a) >\
    \ Double(b) {\n                result = .stringValue(String(a))\n            }\
    \ else if Double(a) < Double(b) {\n                result = .stringValue(b)\n\
    \            }\n        }\n    case .doubleValue(let a):\n        switch b {\n\
    \        case .intValue(let b):\n            if a > Double(b) {\n            \
    \    result = .doubleValue(a)\n            } else if a < Double(b) {\n       \
    \         result = .doubleValue(Double(b))\n            }\n        case .doubleValue(let\
    \ b):\n            if a > b {\n                result = .doubleValue(a)\n    \
    \        } else if a < b {\n                result = .doubleValue(b)\n       \
    \     }\n        case .stringValue(let b):\n            if a > Double(b) {\n \
    \               result = .stringValue(String(a))\n            } else if a < Double(b)\
    \ {\n                result = .stringValue(b)\n            }\n        }\n    case\
    \ .stringValue(let a):\n        switch b {\n        case .intValue(let b):\n \
    \           if Double(a) > Double(b) {\n                result = .stringValue(a)\n\
    \            } else if Double(a) < Double(b) {\n                result = .stringValue(String(b))\n\
    \            }\n        case .doubleValue(let b):\n            if Double(a) >\
    \ b {\n                result = .stringValue(a)\n            } else if Double(a)\
    \ < b {\n                result = .stringValue(String(b))\n            }\n   \
    \     case .stringValue(\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(compare_one(a:\
    \ .intValue(1), b: .intValue(2)) == .intValue(2))\nassert(compare_one(a: .intValue(1),\
    \ b: .doubleValue(2.5)) == .doubleValue(2.5))\nassert(compare_one(a: .intValue(2),\
    \ b: .intValue(3)) == .intValue(3))\nassert(compare_one(a: .intValue(5), b: .intValue(6))\
    \ == .intValue(6))\nassert(compare_one(a: .intValue(1), b: .stringValue(\"2,3\"\
    )) == .stringValue(\"2,3\"))\nassert(compare_one(a: .stringValue(\"5,1\"), b:\
    \ .stringValue(\"6\")) == .stringValue(\"6\"))\nassert(compare_one(a: .stringValue(\"\
    1\"), b: .stringValue(\"2\")) == .stringValue(\"2\"))\nassert(compare_one(a: .stringValue(\"\
    1\"), b: .intValue(1)) == nil)"
  status: SyntaxError
  stderr: "/tmp/tmphaxn0zxu.swift:81:1: error: expected expression in list of expressions\n\
    }\n^\n/tmp/tmphaxn0zxu.swift:80:27: error: expected ':' after 'case'\n       \
    \ case .stringValue(\n                          ^\n/tmp/tmphaxn0zxu.swift:103:66:\
    \ error: expected '}' at end of 'switch' statement\nassert(compare_one(a: .stringValue(\"\
    1\"), b: .intValue(1)) == nil)\n                                             \
    \                    ^\n/tmp/tmphaxn0zxu.swift:23:14: note: to match this opening\
    \ '{'\n    switch a {\n             ^\n/tmp/tmphaxn0zxu.swift:103:66: error: expected\
    \ '}' at end of brace statement\nassert(compare_one(a: .stringValue(\"1\"), b:\
    \ .intValue(1)) == nil)\n                                                    \
    \             ^\n/tmp/tmphaxn0zxu.swift:21:48: note: to match this opening '{'\n\
    func compare_one(a: Value, b: Value) -> Value? {\n                           \
    \                    ^\n/tmp/tmphaxn0zxu.swift:28:24: error: cannot assign value\
    \ of type 'Int' to type 'Value?'\n                result = a\n               \
    \        ^\n/tmp/tmphaxn0zxu.swift:30:24: error: cannot assign value of type 'Int'\
    \ to type 'Value?'\n                result = b\n                       ^\n/tmp/tmphaxn0zxu.swift:39:28:\
    \ error: value of optional type 'Double?' must be unwrapped to a value of type\
    \ 'Double'\n            if Double(a) > Double(b) {\n                         \
    \  ^\n/tmp/tmphaxn0zxu.swift:39:28: note: coalesce using '??' to provide a default\
    \ when the optional value contains 'nil'\n            if Double(a) > Double(b)\
    \ {\n                           ^\n                                     ?? <#default\
    \ value#>\n/tmp/tmphaxn0zxu.swift:39:28: note: force-unwrap using '!' to abort\
    \ execution if the optional value contains 'nil'\n            if Double(a) > Double(b)\
    \ {\n                           ^\n                                    !\n/tmp/tmphaxn0zxu.swift:41:35:\
    \ error: value of optional type 'Double?' must be unwrapped to a value of type\
    \ 'Double'\n            } else if Double(a) < Double(b) {\n                  \
    \                ^\n/tmp/tmphaxn0zxu.swift:41:35: note: coalesce us"
  stdout: ''
  timestamp: 1660013180
- exit_code: 1
  program: "\nenum Value: Equatable, Hashable {\n    case intValue(Int)\n    case\
    \ doubleValue(Double)\n    case stringValue(String)\n}\n\n            \n/// Create\
    \ a function that takes integers, floats, or strings representing\n/// real numbers,\
    \ and returns the larger variable in its given variable type.\n/// Return nil\
    \ if the values are equal.\n/// Note: If a real number is represented as a string,\
    \ the floating point might be . or ,\n/// >>> compare_one(a: .intValue(1), b:\
    \ .doubleValue(2.5))\n/// .doubleValue(2.5)\n/// >>> compare_one(a: .intValue(1),\
    \ b: .stringValue(\"2,3\"))\n/// .stringValue(\"2,3\")\n/// >>> compare_one(a:\
    \ .stringValue(\"5,1\"), b: .stringValue(\"6\"))\n/// .stringValue(\"6\")\n///\
    \ >>> compare_one(a: .stringValue(\"1\"), b: .intValue(1))\n/// nil\nfunc compare_one(a:\
    \ Value, b: Value) -> Value? {\n    switch (a, b) {\n    case let (.intValue(x),\
    \ .intValue(y)) where x > y:\n        return .intValue(x)\n    case let (.intValue(x),\
    \ .intValue(y)) where x < y:\n        return .intValue(y)\n    case let (.intValue(x),\
    \ .doubleValue(y)) where x > y:\n        return .intValue(x)\n    case let (.intValue(x),\
    \ .doubleValue(y)) where x < y:\n        return .doubleValue(y)\n    case let\
    \ (.intValue(x), .stringValue(y)) where x > Int(y)!:\n        return .intValue(x)\n\
    \    case let (.intValue(x), .stringValue(y)) where x < Int(y)!:\n        return\
    \ .stringValue(y)\n    case let (.doubleValue(x), .intValue(y)) where x > y:\n\
    \        return .doubleValue(x)\n    case let (.doubleValue(x), .intValue(y))\
    \ where x < y:\n        return .intValue(y)\n    case let (.doubleValue(x), .doubleValue(y))\
    \ where x > y:\n        return .doubleValue(x)\n    case let (.doubleValue(x),\
    \ .doubleValue(y)) where x < y:\n        return .doubleValue(y)\n    case let\
    \ (.doubleValue(x), .stringValue(y)) where x > Double(y)!:\n        return .doubleValue(x)\n\
    \    case let (.doubleValue(x), .stringValue(y)) where x < Double(y)!:\n     \
    \   return .stringValue(y)\n    case let (.stringValue(x), .intValue(y)) where\
    \ Double(x)! > Double(y):\n        return .stringValue(x)\n    case let (.stringValue(x),\
    \ .intValue(y)) where Double(x)! < Double(y):\n        return .intValue(y)\n \
    \   case let (.stringValue(x), .doubleValue(y)) where Double(x)! > y:\n      \
    \  return .stringValue(x)\n    case let (.stringValue(x), .doubleValue(y)) where\
    \ Double(x)! < y:\n        return .\n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(compare_one(a: .intValue(1), b: .intValue(2)) == .intValue(2))\nassert(compare_one(a:\
    \ .intValue(1), b: .doubleValue(2.5)) == .doubleValue(2.5))\nassert(compare_one(a:\
    \ .intValue(2), b: .intValue(3)) == .intValue(3))\nassert(compare_one(a: .intValue(5),\
    \ b: .intValue(6)) == .intValue(6))\nassert(compare_one(a: .intValue(1), b: .stringValue(\"\
    2,3\")) == .stringValue(\"2,3\"))\nassert(compare_one(a: .stringValue(\"5,1\"\
    ), b: .stringValue(\"6\")) == .stringValue(\"6\"))\nassert(compare_one(a: .stringValue(\"\
    1\"), b: .stringValue(\"2\")) == .stringValue(\"2\"))\nassert(compare_one(a: .stringValue(\"\
    1\"), b: .intValue(1)) == nil)"
  status: SyntaxError
  stderr: "/tmp/tmpaqebr4ta.swift:55:1: error: expected identifier after '.' expression\n\
    }\n^\n/tmp/tmpaqebr4ta.swift:77:66: error: expected '}' at end of brace statement\n\
    assert(compare_one(a: .stringValue(\"1\"), b: .intValue(1)) == nil)\n        \
    \                                                         ^\n/tmp/tmpaqebr4ta.swift:21:48:\
    \ note: to match this opening '{'\nfunc compare_one(a: Value, b: Value) -> Value?\
    \ {\n                                               ^\n/tmp/tmpaqebr4ta.swift:27:54:\
    \ error: binary operator '>' cannot be applied to operands of type 'Int' and 'Double'\n\
    \    case let (.intValue(x), .doubleValue(y)) where x > y:\n                 \
    \                                  ~ ^ ~\n/tmp/tmpaqebr4ta.swift:27:54: note:\
    \ overloads for '>' exist with these partially matching parameter lists: (Int,\
    \ Int)\n    case let (.intValue(x), .doubleValue(y)) where x > y:\n          \
    \                                           ^\n/tmp/tmpaqebr4ta.swift:29:54: error:\
    \ binary operator '<' cannot be applied to operands of type 'Int' and 'Double'\n\
    \    case let (.intValue(x), .doubleValue(y)) where x < y:\n                 \
    \                                  ~ ^ ~\n/tmp/tmpaqebr4ta.swift:29:54: note:\
    \ overloads for '<' exist with these partially matching parameter lists: (Int,\
    \ Int)\n    case let (.intValue(x), .doubleValue(y)) where x < y:\n          \
    \                                           ^\n/tmp/tmpaqebr4ta.swift:35:54: error:\
    \ binary operator '>' cannot be applied to operands of type 'Double' and 'Int'\n\
    \    case let (.doubleValue(x), .intValue(y)) where x > y:\n                 \
    \                                  ~ ^ ~\n/tmp/tmpaqebr4ta.swift:35:54: note:\
    \ overloads for '>' exist with these partially matching parameter lists: (Int,\
    \ Int)\n    case let (.doubleValue(x), .intValue(y)) where x > y:\n          \
    \                                           ^\n/tmp/tmpaqebr4ta.swift:37:54: error:\
    \ binary operator '<' cannot be applied to operands of type 'Double' and 'Int'\n\
    \    case let (.doubleValue(x), .intValue(y)) where x < y:\n                 \
    \                             "
  stdout: ''
  timestamp: 1660013180
- exit_code: 1
  program: "\nenum Value: Equatable, Hashable {\n    case intValue(Int)\n    case\
    \ doubleValue(Double)\n    case stringValue(String)\n}\n\n            \n/// Create\
    \ a function that takes integers, floats, or strings representing\n/// real numbers,\
    \ and returns the larger variable in its given variable type.\n/// Return nil\
    \ if the values are equal.\n/// Note: If a real number is represented as a string,\
    \ the floating point might be . or ,\n/// >>> compare_one(a: .intValue(1), b:\
    \ .doubleValue(2.5))\n/// .doubleValue(2.5)\n/// >>> compare_one(a: .intValue(1),\
    \ b: .stringValue(\"2,3\"))\n/// .stringValue(\"2,3\")\n/// >>> compare_one(a:\
    \ .stringValue(\"5,1\"), b: .stringValue(\"6\"))\n/// .stringValue(\"6\")\n///\
    \ >>> compare_one(a: .stringValue(\"1\"), b: .intValue(1))\n/// nil\nfunc compare_one(a:\
    \ Value, b: Value) -> Value? {\n    var value1: Any\n    var value2: Any\n   \
    \ switch a {\n    case .intValue(let intValue):\n        value1 = intValue\n \
    \   case .doubleValue(let doubleValue):\n        value1 = doubleValue\n    case\
    \ .stringValue(let stringValue):\n        value1 = stringValue\n    }\n    switch\
    \ b {\n    case .intValue(let intValue):\n        value2 = intValue\n    case\
    \ .doubleValue(let doubleValue):\n        value2 = doubleValue\n    case .stringValue(let\
    \ stringValue):\n        value2 = stringValue\n    }\n    if let intValue1 = value1\
    \ as? Int, let intValue2 = value2 as? Int {\n        return intValue1 > intValue2\
    \ ? a : (intValue1 < intValue2 ? b : nil)\n    } else if let doubleValue1 = value1\
    \ as? Double, let doubleValue2 = value2 as? Double {\n        return doubleValue1\
    \ > doubleValue2 ? a : (doubleValue1 < doubleValue2 ? b : nil)\n    } else if\
    \ let stringValue1 = value1 as? String, let stringValue2 = value2 as? String {\n\
    \        if Double(stringValue1) != nil, Double(stringValue2) != nil {\n     \
    \       return Double(stringValue1)! > Double(stringValue2)! ? a : (Double(stringValue1)!\
    \ < Double(stringValue2)! ? b : nil)\n        } else {\n            return stringValue1\
    \ > stringValue2 ? a : (stringValue1 < stringValue2 ? b : nil)\n        }\n  \
    \  } else if let intValue1 = value1 as? Int, let doubleValue2 = value2 as? Double\
    \ {\n        return intValue1 > doubleValue2 ? a : (intValue1 < doubleValue2 ?\
    \ b : nil)\n    } else if let doubleValue1 = value1 as? Double, let intValue2\
    \ = value2 as? Int {\n        return doubleValue1 > intValue2 ? a : (doubleValue1\
    \ < intValue2 ? b : nil)\n    } else if let stringValue1 = value1 as? String,\
    \ let intValue2 = value2 as? Int {\n        if Double(stringValue1) != nil {\n\
    \            return Double(\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int,\
    \ Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n\
    \    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n          \
    \  return false\n        }\n    }\n    return true\n}\n            \nassert(compare_one(a:\
    \ .intValue(1), b: .intValue(2)) == .intValue(2))\nassert(compare_one(a: .intValue(1),\
    \ b: .doubleValue(2.5)) == .doubleValue(2.5))\nassert(compare_one(a: .intValue(2),\
    \ b: .intValue(3)) == .intValue(3))\nassert(compare_one(a: .intValue(5), b: .intValue(6))\
    \ == .intValue(6))\nassert(compare_one(a: .intValue(1), b: .stringValue(\"2,3\"\
    )) == .stringValue(\"2,3\"))\nassert(compare_one(a: .stringValue(\"5,1\"), b:\
    \ .stringValue(\"6\")) == .stringValue(\"6\"))\nassert(compare_one(a: .stringValue(\"\
    1\"), b: .stringValue(\"2\")) == .stringValue(\"2\"))\nassert(compare_one(a: .stringValue(\"\
    1\"), b: .intValue(1)) == nil)"
  status: SyntaxError
  stderr: "/tmp/tmpg9mo2cvr.swift:57:1: error: expected expression in list of expressions\n\
    }\n^\n/tmp/tmpg9mo2cvr.swift:79:66: error: expected '}' at end of brace statement\n\
    assert(compare_one(a: .stringValue(\"1\"), b: .intValue(1)) == nil)\n        \
    \                                                         ^\n/tmp/tmpg9mo2cvr.swift:54:84:\
    \ note: to match this opening '{'\n    } else if let stringValue1 = value1 as?\
    \ String, let intValue2 = value2 as? Int {\n                                 \
    \                                                  ^\n/tmp/tmpg9mo2cvr.swift:79:66:\
    \ error: expected '}' at end of brace statement\nassert(compare_one(a: .stringValue(\"\
    1\"), b: .intValue(1)) == nil)\n                                             \
    \                    ^\n/tmp/tmpg9mo2cvr.swift:21:48: note: to match this opening\
    \ '{'\nfunc compare_one(a: Value, b: Value) -> Value? {\n                    \
    \                           ^\n/tmp/tmpg9mo2cvr.swift:51:28: error: cannot convert\
    \ value of type 'Double' to expected argument type 'Int'\n        return intValue1\
    \ > doubleValue2 ? a : (intValue1 < doubleValue2 ? b : nil)\n                \
    \           ^\n                           Int(        )\n/tmp/tmpg9mo2cvr.swift:51:60:\
    \ error: cannot convert value of type 'Double' to expected argument type 'Int'\n\
    \        return intValue1 > doubleValue2 ? a : (intValue1 < doubleValue2 ? b :\
    \ nil)\n                                                           ^\n       \
    \                                                    Int(        )\n/tmp/tmpg9mo2cvr.swift:53:16:\
    \ error: cannot convert value of type 'Double' to expected argument type 'Int'\n\
    \        return doubleValue1 > intValue2 ? a : (doubleValue1 < intValue2 ? b :\
    \ nil)\n               ^\n               Int(        )\n/tmp/tmpg9mo2cvr.swift:53:48:\
    \ error: cannot convert value of type 'Double' to expected argument type 'Int'\n\
    \        return doubleValue1 > intValue2 ? a : (doubleValue1 < intValue2 ? b :\
    \ nil)\n                                               ^\n                   \
    \                            Int(        )\n/tmp/tmpg9mo2cvr.swift:56:20: error"
  stdout: ''
  timestamp: 1660013180
- exit_code: 1
  program: "\nenum Value: Equatable, Hashable {\n    case intValue(Int)\n    case\
    \ doubleValue(Double)\n    case stringValue(String)\n}\n\n            \n/// Create\
    \ a function that takes integers, floats, or strings representing\n/// real numbers,\
    \ and returns the larger variable in its given variable type.\n/// Return nil\
    \ if the values are equal.\n/// Note: If a real number is represented as a string,\
    \ the floating point might be . or ,\n/// >>> compare_one(a: .intValue(1), b:\
    \ .doubleValue(2.5))\n/// .doubleValue(2.5)\n/// >>> compare_one(a: .intValue(1),\
    \ b: .stringValue(\"2,3\"))\n/// .stringValue(\"2,3\")\n/// >>> compare_one(a:\
    \ .stringValue(\"5,1\"), b: .stringValue(\"6\"))\n/// .stringValue(\"6\")\n///\
    \ >>> compare_one(a: .stringValue(\"1\"), b: .intValue(1))\n/// nil\nfunc compare_one(a:\
    \ Value, b: Value) -> Value? {\n    switch (a, b) {\n    case (.intValue(let a),\
    \ .intValue(let b)):\n        return a > b ? a : b\n    case (.doubleValue(let\
    \ a), .doubleValue(let b)):\n        return a > b ? a : b\n    case (.stringValue(let\
    \ a), .stringValue(let b)):\n        return a > b ? a : b\n    default:\n    \
    \    return nil\n    }\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(compare_one(a:\
    \ .intValue(1), b: .intValue(2)) == .intValue(2))\nassert(compare_one(a: .intValue(1),\
    \ b: .doubleValue(2.5)) == .doubleValue(2.5))\nassert(compare_one(a: .intValue(2),\
    \ b: .intValue(3)) == .intValue(3))\nassert(compare_one(a: .intValue(5), b: .intValue(6))\
    \ == .intValue(6))\nassert(compare_one(a: .intValue(1), b: .stringValue(\"2,3\"\
    )) == .stringValue(\"2,3\"))\nassert(compare_one(a: .stringValue(\"5,1\"), b:\
    \ .stringValue(\"6\")) == .stringValue(\"6\"))\nassert(compare_one(a: .stringValue(\"\
    1\"), b: .stringValue(\"2\")) == .stringValue(\"2\"))\nassert(compare_one(a: .stringValue(\"\
    1\"), b: .intValue(1)) == nil)"
  status: SyntaxError
  stderr: "/tmp/tmp07haxekb.swift:24:22: error: cannot convert return expression of\
    \ type 'Int' to return type 'Value?'\n        return a > b ? a : b\n         \
    \      ~~~~~~^~~~~~~\n/tmp/tmp07haxekb.swift:26:22: error: cannot convert return\
    \ expression of type 'Double' to return type 'Value?'\n        return a > b ?\
    \ a : b\n               ~~~~~~^~~~~~~\n/tmp/tmp07haxekb.swift:28:22: error: cannot\
    \ convert return expression of type 'String' to return type 'Value?'\n       \
    \ return a > b ? a : b\n               ~~~~~~^~~~~~~\n"
  stdout: ''
  timestamp: 1660013180
- exit_code: 1
  program: "\nenum Value: Equatable, Hashable {\n    case intValue(Int)\n    case\
    \ doubleValue(Double)\n    case stringValue(String)\n}\n\n            \n/// Create\
    \ a function that takes integers, floats, or strings representing\n/// real numbers,\
    \ and returns the larger variable in its given variable type.\n/// Return nil\
    \ if the values are equal.\n/// Note: If a real number is represented as a string,\
    \ the floating point might be . or ,\n/// >>> compare_one(a: .intValue(1), b:\
    \ .doubleValue(2.5))\n/// .doubleValue(2.5)\n/// >>> compare_one(a: .intValue(1),\
    \ b: .stringValue(\"2,3\"))\n/// .stringValue(\"2,3\")\n/// >>> compare_one(a:\
    \ .stringValue(\"5,1\"), b: .stringValue(\"6\"))\n/// .stringValue(\"6\")\n///\
    \ >>> compare_one(a: .stringValue(\"1\"), b: .intValue(1))\n/// nil\nfunc compare_one(a:\
    \ Value, b: Value) -> Value? {\n    switch (a, b) {\n    case (.intValue(let aa),\
    \ .intValue(let bb)):\n        return aa > bb ? a : (aa < bb ? b : nil)\n    case\
    \ (.intValue(let aa), .doubleValue(let bb)):\n        return aa > bb ? a : (aa\
    \ < bb ? b : nil)\n    case (.intValue(let aa), .stringValue(let bb)):\n     \
    \   return aa > (Double(bb) ?? 0) ? a : (aa < (Double(bb) ?? 0) ? b : nil)\n \
    \   case (.doubleValue(let aa), .intValue(let bb)):\n        return aa > bb ?\
    \ a : (aa < bb ? b : nil)\n    case (.doubleValue(let aa), .doubleValue(let bb)):\n\
    \        return aa > bb ? a : (aa < bb ? b : nil)\n    case (.doubleValue(let\
    \ aa), .stringValue(let bb)):\n        return aa > (Double(bb) ?? 0) ? a : (aa\
    \ < (Double(bb) ?? 0) ? b : nil)\n    case (.stringValue(let aa), .intValue(let\
    \ bb)):\n        return (Double(aa) ?? 0) > bb ? a : ((Double(aa) ?? 0) < bb ?\
    \ b : nil)\n    case (.stringValue(let aa), .doubleValue(let bb)):\n        return\
    \ (Double(aa) ?? 0) > bb ? a : ((Double(aa) ?? 0) < bb ? b : nil)\n    case (.stringValue(let\
    \ aa), .stringValue(let bb)):\n        return (Double(aa) ?? 0) > (Double(bb)\
    \ ?? 0) ? a : ((Double(aa) ?? 0) < (Double(bb) ?? 0) ? b : nil)\n    }\n}\n\n\n\
    func ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(compare_one(a: .intValue(1), b: .intValue(2))\
    \ == .intValue(2))\nassert(compare_one(a: .intValue(1), b: .doubleValue(2.5))\
    \ == .doubleValue(2.5))\nassert(compare_one(a: .intValue(2), b: .intValue(3))\
    \ == .intValue(3))\nassert(compare_one(a: .intValue(5), b: .intValue(6)) == .intValue(6))\n\
    assert(compare_one(a: .intValue(1), b: .stringValue(\"2,3\")) == .stringValue(\"\
    2,3\"))\nassert(compare_one(a: .stringValue(\"5,1\"), b: .stringValue(\"6\"))\
    \ == .stringValue(\"6\"))\nassert(compare_one(a: .stringValue(\"1\"), b: .stringValue(\"\
    2\")) == .stringValue(\"2\"))\nassert(compare_one(a: .stringValue(\"1\"), b: .intValue(1))\
    \ == nil)"
  status: SyntaxError
  stderr: "/tmp/tmp786jxgbj.swift:26:21: error: cannot convert value of type 'Double'\
    \ to expected argument type 'Int'\n        return aa > bb ? a : (aa < bb ? b :\
    \ nil)\n                    ^\n                    Int( )\n/tmp/tmp786jxgbj.swift:26:36:\
    \ error: cannot convert value of type 'Double' to expected argument type 'Int'\n\
    \        return aa > bb ? a : (aa < bb ? b : nil)\n                          \
    \         ^\n                                   Int( )\n/tmp/tmp786jxgbj.swift:28:33:\
    \ error: cannot convert value of type 'Double' to expected argument type 'Int'\n\
    \        return aa > (Double(bb) ?? 0) ? a : (aa < (Double(bb) ?? 0) ? b : nil)\n\
    \                                ^\n                    Int(             )\n/tmp/tmp786jxgbj.swift:28:63:\
    \ error: cannot convert value of type 'Double' to expected argument type 'Int'\n\
    \        return aa > (Double(bb) ?? 0) ? a : (aa < (Double(bb) ?? 0) ? b : nil)\n\
    \                                                              ^\n           \
    \                                       Int(             )\n/tmp/tmp786jxgbj.swift:30:16:\
    \ error: cannot convert value of type 'Double' to expected argument type 'Int'\n\
    \        return aa > bb ? a : (aa < bb ? b : nil)\n               ^\n        \
    \       Int( )\n/tmp/tmp786jxgbj.swift:30:31: error: cannot convert value of type\
    \ 'Double' to expected argument type 'Int'\n        return aa > bb ? a : (aa <\
    \ bb ? b : nil)\n                              ^\n                           \
    \   Int( )\n/tmp/tmp786jxgbj.swift:36:28: error: cannot convert value of type\
    \ 'Double' to expected argument type 'Int'\n        return (Double(aa) ?? 0) >\
    \ bb ? a : ((Double(aa) ?? 0) < bb ? b : nil)\n                           ^\n\
    \               Int(             )\n/tmp/tmp786jxgbj.swift:36:58: error: cannot\
    \ convert value of type 'Double' to expected argument type 'Int'\n        return\
    \ (Double(aa) ?? 0) > bb ? a : ((Double(aa) ?? 0) < bb ? b : nil)\n          \
    \                                               ^\n                          \
    \                   Int(             )\n"
  stdout: ''
  timestamp: 1660013180
- exit_code: 1
  program: "\nenum Value: Equatable, Hashable {\n    case intValue(Int)\n    case\
    \ doubleValue(Double)\n    case stringValue(String)\n}\n\n            \n/// Create\
    \ a function that takes integers, floats, or strings representing\n/// real numbers,\
    \ and returns the larger variable in its given variable type.\n/// Return nil\
    \ if the values are equal.\n/// Note: If a real number is represented as a string,\
    \ the floating point might be . or ,\n/// >>> compare_one(a: .intValue(1), b:\
    \ .doubleValue(2.5))\n/// .doubleValue(2.5)\n/// >>> compare_one(a: .intValue(1),\
    \ b: .stringValue(\"2,3\"))\n/// .stringValue(\"2,3\")\n/// >>> compare_one(a:\
    \ .stringValue(\"5,1\"), b: .stringValue(\"6\"))\n/// .stringValue(\"6\")\n///\
    \ >>> compare_one(a: .stringValue(\"1\"), b: .intValue(1))\n/// nil\nfunc compare_one(a:\
    \ Value, b: Value) -> Value? {\n    switch (a, b) {\n    case (.intValue(let x),\
    \ .intValue(let y)) where x != y:\n        return .intValue(max(x, y))\n    case\
    \ (.doubleValue(let x), .doubleValue(let y)) where x != y:\n        return .doubleValue(max(x,\
    \ y))\n    case (.stringValue(let x), .stringValue(let y)) where x != y:\n   \
    \     let xfloat = Double(x.replacingOccurrences(of: \",\", with: \".\"))\n  \
    \      let yfloat = Double(y.replacingOccurrences(of: \",\", with: \".\"))\n \
    \       let z = max(xfloat!, yfloat!)\n        return .stringValue(String(z))\n\
    \    default:\n        return nil\n    }\n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(compare_one(a: .intValue(1), b: .intValue(2)) == .intValue(2))\nassert(compare_one(a:\
    \ .intValue(1), b: .doubleValue(2.5)) == .doubleValue(2.5))\nassert(compare_one(a:\
    \ .intValue(2), b: .intValue(3)) == .intValue(3))\nassert(compare_one(a: .intValue(5),\
    \ b: .intValue(6)) == .intValue(6))\nassert(compare_one(a: .intValue(1), b: .stringValue(\"\
    2,3\")) == .stringValue(\"2,3\"))\nassert(compare_one(a: .stringValue(\"5,1\"\
    ), b: .stringValue(\"6\")) == .stringValue(\"6\"))\nassert(compare_one(a: .stringValue(\"\
    1\"), b: .stringValue(\"2\")) == .stringValue(\"2\"))\nassert(compare_one(a: .stringValue(\"\
    1\"), b: .intValue(1)) == nil)"
  status: SyntaxError
  stderr: "/tmp/tmpax8ztaoz.swift:28:31: error: value of type 'String' has no member\
    \ 'replacingOccurrences'\n        let xfloat = Double(x.replacingOccurrences(of:\
    \ \",\", with: \".\"))\n                            ~ ^~~~~~~~~~~~~~~~~~~~\n/tmp/tmpax8ztaoz.swift:29:31:\
    \ error: value of type 'String' has no member 'replacingOccurrences'\n       \
    \ let yfloat = Double(y.replacingOccurrences(of: \",\", with: \".\"))\n      \
    \                      ~ ^~~~~~~~~~~~~~~~~~~~\n"
  stdout: ''
  timestamp: 1660013180
- exit_code: 1
  program: "\nenum Value: Equatable, Hashable {\n    case intValue(Int)\n    case\
    \ doubleValue(Double)\n    case stringValue(String)\n}\n\n            \n/// Create\
    \ a function that takes integers, floats, or strings representing\n/// real numbers,\
    \ and returns the larger variable in its given variable type.\n/// Return nil\
    \ if the values are equal.\n/// Note: If a real number is represented as a string,\
    \ the floating point might be . or ,\n/// >>> compare_one(a: .intValue(1), b:\
    \ .doubleValue(2.5))\n/// .doubleValue(2.5)\n/// >>> compare_one(a: .intValue(1),\
    \ b: .stringValue(\"2,3\"))\n/// .stringValue(\"2,3\")\n/// >>> compare_one(a:\
    \ .stringValue(\"5,1\"), b: .stringValue(\"6\"))\n/// .stringValue(\"6\")\n///\
    \ >>> compare_one(a: .stringValue(\"1\"), b: .intValue(1))\n/// nil\nfunc compare_one(a:\
    \ Value, b: Value) -> Value? {\n    if case let .intValue(a) = a, case let .intValue(b)\
    \ = b {\n        return a > b ? a : b\n    } else if case let .doubleValue(a)\
    \ = a, case let .doubleValue(b) = b {\n        return a > b ? a : b\n    } else\
    \ if case let .stringValue(a) = a, case let .stringValue(b) = b {\n        return\
    \ a > b ? a : b\n    } else if case let .intValue(a) = a, case let .doubleValue(b)\
    \ = b {\n        return a > b ? a : b\n    } else if case let .doubleValue(a)\
    \ = a, case let .intValue(b) = b {\n        return a > b ? a : b\n    } else if\
    \ case let .intValue(a) = a, case let .stringValue(b) = b {\n        return a\
    \ > b ? a : b\n    } else if case let .stringValue(a) = a, case let .intValue(b)\
    \ = b {\n        return a > b ? a : b\n    } else if case let .doubleValue(a)\
    \ = a, case let .stringValue(b) = b {\n        return a > b ? a : b\n    } else\
    \ if case let .stringValue(a) = a, case let .doubleValue(b) = b {\n        return\
    \ a > b ? a : b\n    } else {\n        return nil\n    }\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(compare_one(a: .intValue(1), b: .intValue(2)) == .intValue(2))\n\
    assert(compare_one(a: .intValue(1), b: .doubleValue(2.5)) == .doubleValue(2.5))\n\
    assert(compare_one(a: .intValue(2), b: .intValue(3)) == .intValue(3))\nassert(compare_one(a:\
    \ .intValue(5), b: .intValue(6)) == .intValue(6))\nassert(compare_one(a: .intValue(1),\
    \ b: .stringValue(\"2,3\")) == .stringValue(\"2,3\"))\nassert(compare_one(a: .stringValue(\"\
    5,1\"), b: .stringValue(\"6\")) == .stringValue(\"6\"))\nassert(compare_one(a:\
    \ .stringValue(\"1\"), b: .stringValue(\"2\")) == .stringValue(\"2\"))\nassert(compare_one(a:\
    \ .stringValue(\"1\"), b: .intValue(1)) == nil)"
  status: SyntaxError
  stderr: "/tmp/tmpea8cjq_d.swift:23:22: error: cannot convert return expression of\
    \ type 'Int' to return type 'Value?'\n        return a > b ? a : b\n         \
    \      ~~~~~~^~~~~~~\n/tmp/tmpea8cjq_d.swift:25:22: error: cannot convert return\
    \ expression of type 'Double' to return type 'Value?'\n        return a > b ?\
    \ a : b\n               ~~~~~~^~~~~~~\n/tmp/tmpea8cjq_d.swift:27:22: error: cannot\
    \ convert return expression of type 'String' to return type 'Value?'\n       \
    \ return a > b ? a : b\n               ~~~~~~^~~~~~~\n/tmp/tmpea8cjq_d.swift:29:20:\
    \ error: cannot convert value of type 'Double' to expected argument type 'Int'\n\
    \        return a > b ? a : b\n                   ^\n                   Int( )\n\
    /tmp/tmpea8cjq_d.swift:29:22: error: cannot convert return expression of type\
    \ 'Int' to return type 'Value?'\n        return a > b ? a : b\n              \
    \ ~~~~~~^~~~~~~\n/tmp/tmpea8cjq_d.swift:31:16: error: cannot convert value of\
    \ type 'Double' to expected argument type 'Int'\n        return a > b ? a : b\n\
    \               ^\n               Int( )\n/tmp/tmpea8cjq_d.swift:31:22: error:\
    \ cannot convert return expression of type 'Double' to return type 'Value?'\n\
    \        return a > b ? a : b\n               ~~~~~~^~~~~~~\n/tmp/tmpea8cjq_d.swift:33:20:\
    \ error: cannot convert value of type 'String' to expected argument type 'Int'\n\
    \        return a > b ? a : b\n                   ^\n/tmp/tmpea8cjq_d.swift:33:22:\
    \ error: cannot convert return expression of type 'Int' to return type 'Value?'\n\
    \        return a > b ? a : b\n               ~~~~~~^~~~~~~\n/tmp/tmpea8cjq_d.swift:35:16:\
    \ error: cannot convert value of type 'String' to expected argument type 'Int'\n\
    \        return a > b ? a : b\n               ^\n/tmp/tmpea8cjq_d.swift:35:22:\
    \ error: cannot convert return expression of type 'String' to return type 'Value?'\n\
    \        return a > b ? a : b\n               ~~~~~~^~~~~~~\n/tmp/tmpea8cjq_d.swift:37:18:\
    \ error: binary operator '>' cannot be applied to operands of type 'Double' and\
    \ 'String'\n        return a > b ? a : b\n               ~ ^ ~\n/tmp/tmpea8cjq_d.swift:37:22:\
    \ error: ca"
  stdout: ''
  timestamp: 1660013180
- exit_code: 1
  program: "\nenum Value: Equatable, Hashable {\n    case intValue(Int)\n    case\
    \ doubleValue(Double)\n    case stringValue(String)\n}\n\n            \n/// Create\
    \ a function that takes integers, floats, or strings representing\n/// real numbers,\
    \ and returns the larger variable in its given variable type.\n/// Return nil\
    \ if the values are equal.\n/// Note: If a real number is represented as a string,\
    \ the floating point might be . or ,\n/// >>> compare_one(a: .intValue(1), b:\
    \ .doubleValue(2.5))\n/// .doubleValue(2.5)\n/// >>> compare_one(a: .intValue(1),\
    \ b: .stringValue(\"2,3\"))\n/// .stringValue(\"2,3\")\n/// >>> compare_one(a:\
    \ .stringValue(\"5,1\"), b: .stringValue(\"6\"))\n/// .stringValue(\"6\")\n///\
    \ >>> compare_one(a: .stringValue(\"1\"), b: .intValue(1))\n/// nil\nfunc compare_one(a:\
    \ Value, b: Value) -> Value? {\n    switch (a, b) {\n    case let (.intValue(a),\
    \ .intValue(b)) where a == b:\n        return nil\n    case let (.intValue(a),\
    \ .intValue(b)) where a > b:\n        return a\n    case let (.intValue(a), .intValue(b))\
    \ where a < b:\n        return b\n    case let (.intValue(a), .doubleValue(b))\
    \ where a == b:\n        return nil\n    case let (.intValue(a), .doubleValue(b))\
    \ where a > b:\n        return a\n    case let (.intValue(a), .doubleValue(b))\
    \ where a < b:\n        return b\n    case let (.intValue(a), .stringValue(b))\
    \ where a == b:\n        return nil\n    case let (.intValue(a), .stringValue(b))\
    \ where a > b:\n        return a\n    case let (.intValue(a), .stringValue(b))\
    \ where a < b:\n        return b\n    case let (.doubleValue(a), .intValue(b))\
    \ where a == b:\n        return nil\n    case let (.doubleValue(a), .intValue(b))\
    \ where a > b:\n        return a\n    case let (.doubleValue(a), .intValue(b))\
    \ where a < b:\n        return b\n    case let (.doubleValue(a), .doubleValue(b))\
    \ where a == b:\n        return nil\n    case let (.doubleValue(a), .doubleValue(b))\
    \ where a > b:\n        return a\n    case let (.doubleValue(a), .doubleValue(b))\
    \ where a < b:\n        return b\n    case let (.doubleValue(a), .stringValue(b))\
    \ where a == b:\n        return nil\n    case let (.doubleValue(a), .stringValue(b))\
    \ where a > b:\n        return a\n    case let (.doubleValue(a), .stringValue(b))\
    \ where a < b:\n        return b\n    case let (.stringValue(a), .intValue(b))\
    \ where a == b:\n        return nil\n    case let (.stringValue(a), .intValue(b))\
    \ where a > b:\n        return a\n    case\n}\n\n\nfunc ==(left: [(Int, Int)],\
    \ right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n       \
    \ return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r\
    \ {\n            return false\n        }\n    }\n    return true\n}\n        \
    \    \nassert(compare_one(a: .intValue(1), b: .intValue(2)) == .intValue(2))\n\
    assert(compare_one(a: .intValue(1), b: .doubleValue(2.5)) == .doubleValue(2.5))\n\
    assert(compare_one(a: .intValue(2), b: .intValue(3)) == .intValue(3))\nassert(compare_one(a:\
    \ .intValue(5), b: .intValue(6)) == .intValue(6))\nassert(compare_one(a: .intValue(1),\
    \ b: .stringValue(\"2,3\")) == .stringValue(\"2,3\"))\nassert(compare_one(a: .stringValue(\"\
    5,1\"), b: .stringValue(\"6\")) == .stringValue(\"6\"))\nassert(compare_one(a:\
    \ .stringValue(\"1\"), b: .stringValue(\"2\")) == .stringValue(\"2\"))\nassert(compare_one(a:\
    \ .stringValue(\"1\"), b: .intValue(1)) == nil)"
  status: SyntaxError
  stderr: "/tmp/tmpk5hrytzn.swift:63:9: error: expected pattern\n    case\n      \
    \  ^\n/tmp/tmpk5hrytzn.swift:63:9: error: expected ':' after 'case'\n    case\n\
    \        ^\n/tmp/tmpk5hrytzn.swift:86:66: error: expected '}' at end of brace\
    \ statement\nassert(compare_one(a: .stringValue(\"1\"), b: .intValue(1)) == nil)\n\
    \                                                                 ^\n/tmp/tmpk5hrytzn.swift:21:48:\
    \ note: to match this opening '{'\nfunc compare_one(a: Value, b: Value) -> Value?\
    \ {\n                                               ^\n/tmp/tmpk5hrytzn.swift:29:54:\
    \ error: binary operator '==' cannot be applied to operands of type 'Int' and\
    \ 'Double'\n    case let (.intValue(a), .doubleValue(b)) where a == b:\n     \
    \                                              ~ ^  ~\n/tmp/tmpk5hrytzn.swift:29:54:\
    \ note: overloads for '==' exist with these partially matching parameter lists:\
    \ (Int, Int)\n    case let (.intValue(a), .doubleValue(b)) where a == b:\n   \
    \                                                  ^\n/tmp/tmpk5hrytzn.swift:31:54:\
    \ error: binary operator '>' cannot be applied to operands of type 'Int' and 'Double'\n\
    \    case let (.intValue(a), .doubleValue(b)) where a > b:\n                 \
    \                                  ~ ^ ~\n/tmp/tmpk5hrytzn.swift:31:54: note:\
    \ overloads for '>' exist with these partially matching parameter lists: (Int,\
    \ Int)\n    case let (.intValue(a), .doubleValue(b)) where a > b:\n          \
    \                                           ^\n/tmp/tmpk5hrytzn.swift:33:54: error:\
    \ binary operator '<' cannot be applied to operands of type 'Int' and 'Double'\n\
    \    case let (.intValue(a), .doubleValue(b)) where a < b:\n                 \
    \                                  ~ ^ ~\n/tmp/tmpk5hrytzn.swift:33:54: note:\
    \ overloads for '<' exist with these partially matching parameter lists: (Int,\
    \ Int)\n    case let (.intValue(a), .doubleValue(b)) where a < b:\n          \
    \                                           ^\n/tmp/tmpk5hrytzn.swift:35:54: error:\
    \ binary operator '==' cannot be applied to operands of type 'Int' and 'String'\n\
    \    case let (.intValue(a)"
  stdout: ''
  timestamp: 1660013180
- exit_code: 1
  program: "\nenum Value: Equatable, Hashable {\n    case intValue(Int)\n    case\
    \ doubleValue(Double)\n    case stringValue(String)\n}\n\n            \n/// Create\
    \ a function that takes integers, floats, or strings representing\n/// real numbers,\
    \ and returns the larger variable in its given variable type.\n/// Return nil\
    \ if the values are equal.\n/// Note: If a real number is represented as a string,\
    \ the floating point might be . or ,\n/// >>> compare_one(a: .intValue(1), b:\
    \ .doubleValue(2.5))\n/// .doubleValue(2.5)\n/// >>> compare_one(a: .intValue(1),\
    \ b: .stringValue(\"2,3\"))\n/// .stringValue(\"2,3\")\n/// >>> compare_one(a:\
    \ .stringValue(\"5,1\"), b: .stringValue(\"6\"))\n/// .stringValue(\"6\")\n///\
    \ >>> compare_one(a: .stringValue(\"1\"), b: .intValue(1))\n/// nil\nfunc compare_one(a:\
    \ Value, b: Value) -> Value? {\n    switch (a, b) {\n    case (.intValue(let a1),\
    \ .intValue(let b1)) where a1 != b1:\n        return a1 > b1 ? a : b\n    case\
    \ (.doubleValue(let a1), .doubleValue(let b1)) where a1 != b1:\n        return\
    \ a1 > b1 ? a : b\n    case (.stringValue(let a1), .stringValue(let b1)) where\
    \ a1 != b1:\n        return a1 > b1 ? a : b\n    case (.intValue(let a1), .doubleValue(let\
    \ b1)) where a1 != b1:\n        return a1 > b1 ? a : b\n    case (.intValue(let\
    \ a1), .stringValue(let b1)) where a1 != b1:\n        return a1 > b1 ? a : b\n\
    \    case (.doubleValue(let a1), .intValue(let b1)) where a1 != b1:\n        return\
    \ a1 > b1 ? a : b\n    case (.doubleValue(let a1), .stringValue(let b1)) where\
    \ a1 != b1:\n        return a1 > b1 ? a : b\n    case (.stringValue(let a1), .intValue(let\
    \ b1)) where a1 != b1:\n        return a1 > b1 ? a : b\n    case (.stringValue(let\
    \ a1), .doubleValue(let b1)) where a1 != b1:\n        return a1 > b1 ? a : b\n\
    \    default:\n        return nil\n    }\n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(compare_one(a: .intValue(1), b: .intValue(2)) == .intValue(2))\nassert(compare_one(a:\
    \ .intValue(1), b: .doubleValue(2.5)) == .doubleValue(2.5))\nassert(compare_one(a:\
    \ .intValue(2), b: .intValue(3)) == .intValue(3))\nassert(compare_one(a: .intValue(5),\
    \ b: .intValue(6)) == .intValue(6))\nassert(compare_one(a: .intValue(1), b: .stringValue(\"\
    2,3\")) == .stringValue(\"2,3\"))\nassert(compare_one(a: .stringValue(\"5,1\"\
    ), b: .stringValue(\"6\")) == .stringValue(\"6\"))\nassert(compare_one(a: .stringValue(\"\
    1\"), b: .stringValue(\"2\")) == .stringValue(\"2\"))\nassert(compare_one(a: .stringValue(\"\
    1\"), b: .intValue(1)) == nil)"
  status: SyntaxError
  stderr: "/tmp/tmpsuwfy0a2.swift:29:61: error: binary operator '!=' cannot be applied\
    \ to operands of type 'Int' and 'Double'\n    case (.intValue(let a1), .doubleValue(let\
    \ b1)) where a1 != b1:\n                                                     \
    \    ~~ ^  ~~\n/tmp/tmpsuwfy0a2.swift:31:61: error: binary operator '!=' cannot\
    \ be applied to operands of type 'Int' and 'String'\n    case (.intValue(let a1),\
    \ .stringValue(let b1)) where a1 != b1:\n                                    \
    \                     ~~ ^  ~~\n/tmp/tmpsuwfy0a2.swift:33:61: error: binary operator\
    \ '!=' cannot be applied to operands of type 'Double' and 'Int'\n    case (.doubleValue(let\
    \ a1), .intValue(let b1)) where a1 != b1:\n                                  \
    \                       ~~ ^  ~~\n/tmp/tmpsuwfy0a2.swift:35:67: error: cannot\
    \ convert value of type 'String' to expected argument type 'Double'\n    case\
    \ (.doubleValue(let a1), .stringValue(let b1)) where a1 != b1:\n             \
    \                                                     ^\n/tmp/tmpsuwfy0a2.swift:37:61:\
    \ error: binary operator '!=' cannot be applied to operands of type 'String' and\
    \ 'Int'\n    case (.stringValue(let a1), .intValue(let b1)) where a1 != b1:\n\
    \                                                         ~~ ^  ~~\n/tmp/tmpsuwfy0a2.swift:39:67:\
    \ error: cannot convert value of type 'Double' to expected argument type 'String'\n\
    \    case (.stringValue(let a1), .doubleValue(let b1)) where a1 != b1:\n     \
    \                                                             ^\n/tmp/tmpsuwfy0a2.swift:30:21:\
    \ error: cannot convert value of type 'Double' to expected argument type 'Int'\n\
    \        return a1 > b1 ? a : b\n                    ^\n                    Int(\
    \ )\n/tmp/tmpsuwfy0a2.swift:32:21: error: cannot convert value of type 'String'\
    \ to expected argument type 'Int'\n        return a1 > b1 ? a : b\n          \
    \          ^\n/tmp/tmpsuwfy0a2.swift:34:16: error: cannot convert value of type\
    \ 'Double' to expected argument type 'Int'\n        return a1 > b1 ? a : b\n \
    \              ^\n               Int( )\n/tmp/tmpsuwfy0a2.swift:36:19: error:"
  stdout: ''
  timestamp: 1660013180
- exit_code: 1
  program: "\nenum Value: Equatable, Hashable {\n    case intValue(Int)\n    case\
    \ doubleValue(Double)\n    case stringValue(String)\n}\n\n            \n/// Create\
    \ a function that takes integers, floats, or strings representing\n/// real numbers,\
    \ and returns the larger variable in its given variable type.\n/// Return nil\
    \ if the values are equal.\n/// Note: If a real number is represented as a string,\
    \ the floating point might be . or ,\n/// >>> compare_one(a: .intValue(1), b:\
    \ .doubleValue(2.5))\n/// .doubleValue(2.5)\n/// >>> compare_one(a: .intValue(1),\
    \ b: .stringValue(\"2,3\"))\n/// .stringValue(\"2,3\")\n/// >>> compare_one(a:\
    \ .stringValue(\"5,1\"), b: .stringValue(\"6\"))\n/// .stringValue(\"6\")\n///\
    \ >>> compare_one(a: .stringValue(\"1\"), b: .intValue(1))\n/// nil\nfunc compare_one(a:\
    \ Value, b: Value) -> Value? {\n    \n    switch (a, b) {\n    case (.intValue(let\
    \ a), .intValue(let b)):\n        return a < b ? b : a\n    case (.intValue(let\
    \ a), .doubleValue(let b)):\n        return b\n    case (.intValue(let a), .stringValue(let\
    \ b)):\n        return b\n    case (.doubleValue(let a), .intValue(let b)):\n\
    \        return a\n    case (.doubleValue(let a), .doubleValue(let b)):\n    \
    \    return a < b ? b : a\n    case (.doubleValue(let a), .stringValue(let b)):\n\
    \        return b\n    case (.stringValue(let a), .intValue(let b)):\n       \
    \ return a\n    case (.stringValue(let a), .doubleValue(let b)):\n        return\
    \ a\n    case (.stringValue(let a), .stringValue(let b)):\n        return a <\
    \ b ? b : a\n    }\n    \n    \n    \n    \n}\n\n\nfunc ==(left: [(Int, Int)],\
    \ right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n       \
    \ return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r\
    \ {\n            return false\n        }\n    }\n    return true\n}\n        \
    \    \nassert(compare_one(a: .intValue(1), b: .intValue(2)) == .intValue(2))\n\
    assert(compare_one(a: .intValue(1), b: .doubleValue(2.5)) == .doubleValue(2.5))\n\
    assert(compare_one(a: .intValue(2), b: .intValue(3)) == .intValue(3))\nassert(compare_one(a:\
    \ .intValue(5), b: .intValue(6)) == .intValue(6))\nassert(compare_one(a: .intValue(1),\
    \ b: .stringValue(\"2,3\")) == .stringValue(\"2,3\"))\nassert(compare_one(a: .stringValue(\"\
    5,1\"), b: .stringValue(\"6\")) == .stringValue(\"6\"))\nassert(compare_one(a:\
    \ .stringValue(\"1\"), b: .stringValue(\"2\")) == .stringValue(\"2\"))\nassert(compare_one(a:\
    \ .stringValue(\"1\"), b: .intValue(1)) == nil)"
  status: SyntaxError
  stderr: "/tmp/tmpmy4kdlat.swift:25:22: error: cannot convert return expression of\
    \ type 'Int' to return type 'Value?'\n        return a < b ? b : a\n         \
    \      ~~~~~~^~~~~~~\n/tmp/tmpmy4kdlat.swift:27:16: error: cannot convert return\
    \ expression of type 'Double' to return type 'Value?'\n        return b\n    \
    \           ^\n/tmp/tmpmy4kdlat.swift:29:16: error: cannot convert return expression\
    \ of type 'String' to return type 'Value?'\n        return b\n               ^\n\
    /tmp/tmpmy4kdlat.swift:31:16: error: cannot convert return expression of type\
    \ 'Double' to return type 'Value?'\n        return a\n               ^\n/tmp/tmpmy4kdlat.swift:33:22:\
    \ error: cannot convert return expression of type 'Double' to return type 'Value?'\n\
    \        return a < b ? b : a\n               ~~~~~~^~~~~~~\n/tmp/tmpmy4kdlat.swift:35:16:\
    \ error: cannot convert return expression of type 'String' to return type 'Value?'\n\
    \        return b\n               ^\n/tmp/tmpmy4kdlat.swift:37:16: error: cannot\
    \ convert return expression of type 'String' to return type 'Value?'\n       \
    \ return a\n               ^\n/tmp/tmpmy4kdlat.swift:39:16: error: cannot convert\
    \ return expression of type 'String' to return type 'Value?'\n        return a\n\
    \               ^\n/tmp/tmpmy4kdlat.swift:41:22: error: cannot convert return\
    \ expression of type 'String' to return type 'Value?'\n        return a < b ?\
    \ b : a\n               ~~~~~~^~~~~~~\n"
  stdout: ''
  timestamp: 1660013180
- exit_code: 1
  program: "\nenum Value: Equatable, Hashable {\n    case intValue(Int)\n    case\
    \ doubleValue(Double)\n    case stringValue(String)\n}\n\n            \n/// Create\
    \ a function that takes integers, floats, or strings representing\n/// real numbers,\
    \ and returns the larger variable in its given variable type.\n/// Return nil\
    \ if the values are equal.\n/// Note: If a real number is represented as a string,\
    \ the floating point might be . or ,\n/// >>> compare_one(a: .intValue(1), b:\
    \ .doubleValue(2.5))\n/// .doubleValue(2.5)\n/// >>> compare_one(a: .intValue(1),\
    \ b: .stringValue(\"2,3\"))\n/// .stringValue(\"2,3\")\n/// >>> compare_one(a:\
    \ .stringValue(\"5,1\"), b: .stringValue(\"6\"))\n/// .stringValue(\"6\")\n///\
    \ >>> compare_one(a: .stringValue(\"1\"), b: .intValue(1))\n/// nil\nfunc compare_one(a:\
    \ Value, b: Value) -> Value? {\n    switch (a, b) {\n    case (.intValue(let a),\
    \ .intValue(let b)):\n        return a > b ? a : b\n    case (.doubleValue(let\
    \ a), .doubleValue(let b)):\n        return a > b ? a : b\n    case (.stringValue(let\
    \ a), .stringValue(let b)):\n        return a > b ? a : b\n    default:\n    \
    \    return nil\n    }\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(compare_one(a:\
    \ .intValue(1), b: .intValue(2)) == .intValue(2))\nassert(compare_one(a: .intValue(1),\
    \ b: .doubleValue(2.5)) == .doubleValue(2.5))\nassert(compare_one(a: .intValue(2),\
    \ b: .intValue(3)) == .intValue(3))\nassert(compare_one(a: .intValue(5), b: .intValue(6))\
    \ == .intValue(6))\nassert(compare_one(a: .intValue(1), b: .stringValue(\"2,3\"\
    )) == .stringValue(\"2,3\"))\nassert(compare_one(a: .stringValue(\"5,1\"), b:\
    \ .stringValue(\"6\")) == .stringValue(\"6\"))\nassert(compare_one(a: .stringValue(\"\
    1\"), b: .stringValue(\"2\")) == .stringValue(\"2\"))\nassert(compare_one(a: .stringValue(\"\
    1\"), b: .intValue(1)) == nil)"
  status: SyntaxError
  stderr: "/tmp/tmp07haxekb.swift:24:22: error: cannot convert return expression of\
    \ type 'Int' to return type 'Value?'\n        return a > b ? a : b\n         \
    \      ~~~~~~^~~~~~~\n/tmp/tmp07haxekb.swift:26:22: error: cannot convert return\
    \ expression of type 'Double' to return type 'Value?'\n        return a > b ?\
    \ a : b\n               ~~~~~~^~~~~~~\n/tmp/tmp07haxekb.swift:28:22: error: cannot\
    \ convert return expression of type 'String' to return type 'Value?'\n       \
    \ return a > b ? a : b\n               ~~~~~~^~~~~~~\n"
  stdout: ''
  timestamp: 1660013180
- exit_code: 1
  program: "\nenum Value: Equatable, Hashable {\n    case intValue(Int)\n    case\
    \ doubleValue(Double)\n    case stringValue(String)\n}\n\n            \n/// Create\
    \ a function that takes integers, floats, or strings representing\n/// real numbers,\
    \ and returns the larger variable in its given variable type.\n/// Return nil\
    \ if the values are equal.\n/// Note: If a real number is represented as a string,\
    \ the floating point might be . or ,\n/// >>> compare_one(a: .intValue(1), b:\
    \ .doubleValue(2.5))\n/// .doubleValue(2.5)\n/// >>> compare_one(a: .intValue(1),\
    \ b: .stringValue(\"2,3\"))\n/// .stringValue(\"2,3\")\n/// >>> compare_one(a:\
    \ .stringValue(\"5,1\"), b: .stringValue(\"6\"))\n/// .stringValue(\"6\")\n///\
    \ >>> compare_one(a: .stringValue(\"1\"), b: .intValue(1))\n/// nil\nfunc compare_one(a:\
    \ Value, b: Value) -> Value? {\n    switch (a, b) {\n    case (.intValue(let a),\
    \ .intValue(let b)):\n        return a > b ? a : b\n    case (.doubleValue(let\
    \ a), .doubleValue(let b)):\n        return a > b ? a : b\n    case (.stringValue(let\
    \ a), .stringValue(let b)):\n        return a > b ? a : b\n    case (.intValue(let\
    \ a), .doubleValue(let b)):\n        return a > b ? a : b\n    case (.intValue(let\
    \ a), .stringValue(let b)):\n        return a > b ? a : b\n    case (.doubleValue(let\
    \ a), .intValue(let b)):\n        return a > b ? a : b\n    case (.doubleValue(let\
    \ a), .stringValue(let b)):\n        return a > b ? a : b\n    case (.stringValue(let\
    \ a), .intValue(let b)):\n        return a > b ? a : b\n    case (.stringValue(let\
    \ a), .doubleValue(let b)):\n        return a > b ? a : b\n    default:\n    \
    \    return nil\n    }\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(compare_one(a:\
    \ .intValue(1), b: .intValue(2)) == .intValue(2))\nassert(compare_one(a: .intValue(1),\
    \ b: .doubleValue(2.5)) == .doubleValue(2.5))\nassert(compare_one(a: .intValue(2),\
    \ b: .intValue(3)) == .intValue(3))\nassert(compare_one(a: .intValue(5), b: .intValue(6))\
    \ == .intValue(6))\nassert(compare_one(a: .intValue(1), b: .stringValue(\"2,3\"\
    )) == .stringValue(\"2,3\"))\nassert(compare_one(a: .stringValue(\"5,1\"), b:\
    \ .stringValue(\"6\")) == .stringValue(\"6\"))\nassert(compare_one(a: .stringValue(\"\
    1\"), b: .stringValue(\"2\")) == .stringValue(\"2\"))\nassert(compare_one(a: .stringValue(\"\
    1\"), b: .intValue(1)) == nil)"
  status: SyntaxError
  stderr: "/tmp/tmpjf037tzu.swift:24:22: error: cannot convert return expression of\
    \ type 'Int' to return type 'Value?'\n        return a > b ? a : b\n         \
    \      ~~~~~~^~~~~~~\n/tmp/tmpjf037tzu.swift:26:22: error: cannot convert return\
    \ expression of type 'Double' to return type 'Value?'\n        return a > b ?\
    \ a : b\n               ~~~~~~^~~~~~~\n/tmp/tmpjf037tzu.swift:28:22: error: cannot\
    \ convert return expression of type 'String' to return type 'Value?'\n       \
    \ return a > b ? a : b\n               ~~~~~~^~~~~~~\n/tmp/tmpjf037tzu.swift:30:20:\
    \ error: cannot convert value of type 'Double' to expected argument type 'Int'\n\
    \        return a > b ? a : b\n                   ^\n                   Int( )\n\
    /tmp/tmpjf037tzu.swift:30:22: error: cannot convert return expression of type\
    \ 'Int' to return type 'Value?'\n        return a > b ? a : b\n              \
    \ ~~~~~~^~~~~~~\n/tmp/tmpjf037tzu.swift:32:20: error: cannot convert value of\
    \ type 'String' to expected argument type 'Int'\n        return a > b ? a : b\n\
    \                   ^\n/tmp/tmpjf037tzu.swift:32:22: error: cannot convert return\
    \ expression of type 'Int' to return type 'Value?'\n        return a > b ? a :\
    \ b\n               ~~~~~~^~~~~~~\n/tmp/tmpjf037tzu.swift:34:16: error: cannot\
    \ convert value of type 'Double' to expected argument type 'Int'\n        return\
    \ a > b ? a : b\n               ^\n               Int( )\n/tmp/tmpjf037tzu.swift:34:22:\
    \ error: cannot convert return expression of type 'Double' to return type 'Value?'\n\
    \        return a > b ? a : b\n               ~~~~~~^~~~~~~\n/tmp/tmpjf037tzu.swift:36:18:\
    \ error: binary operator '>' cannot be applied to operands of type 'Double' and\
    \ 'String'\n        return a > b ? a : b\n               ~ ^ ~\n/tmp/tmpjf037tzu.swift:36:22:\
    \ error: cannot convert return expression of type 'Double' to return type 'Value?'\n\
    \        return a > b ? a : b\n               ~~~~~~^~~~~~~\n/tmp/tmpjf037tzu.swift:38:16:\
    \ error: cannot convert value of type 'String' to expected argument type 'Int'\n\
    \        return a > b ? a : b\n               ^\n/tmp/tmpjf037tzu.swift:38:22:\
    \ error: ca"
  stdout: ''
  timestamp: 1660013180
- exit_code: 1
  program: "\nenum Value: Equatable, Hashable {\n    case intValue(Int)\n    case\
    \ doubleValue(Double)\n    case stringValue(String)\n}\n\n            \n/// Create\
    \ a function that takes integers, floats, or strings representing\n/// real numbers,\
    \ and returns the larger variable in its given variable type.\n/// Return nil\
    \ if the values are equal.\n/// Note: If a real number is represented as a string,\
    \ the floating point might be . or ,\n/// >>> compare_one(a: .intValue(1), b:\
    \ .doubleValue(2.5))\n/// .doubleValue(2.5)\n/// >>> compare_one(a: .intValue(1),\
    \ b: .stringValue(\"2,3\"))\n/// .stringValue(\"2,3\")\n/// >>> compare_one(a:\
    \ .stringValue(\"5,1\"), b: .stringValue(\"6\"))\n/// .stringValue(\"6\")\n///\
    \ >>> compare_one(a: .stringValue(\"1\"), b: .intValue(1))\n/// nil\nfunc compare_one(a:\
    \ Value, b: Value) -> Value? {\n    let a = parse(a)\n    let b = parse(b)\n \
    \   switch (a, b) {\n    case let (.intValue(a), .intValue(b)):\n        return\
    \ a > b ? a : b\n    case let (.doubleValue(a), .doubleValue(b)):\n        return\
    \ a > b ? a : b\n    case let (.stringValue(a), .stringValue(b)):\n        return\
    \ a > b ? a : b\n    case let (.intValue(a), .doubleValue(b)):\n        return\
    \ a > b ? a : b\n    case let (.doubleValue(a), .intValue(b)):\n        return\
    \ a > b ? a : b\n    case let (.intValue(a), .stringValue(b)):\n        return\
    \ a > b ? a : b\n    case let (.stringValue(a), .intValue(b)):\n        return\
    \ a > b ? a : b\n    case let (.doubleValue(a), .stringValue(b)):\n        return\
    \ a > b ? a : b\n    case let (.stringValue(a), .doubleValue(b)):\n        return\
    \ a > b ? a : b\n    }\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(compare_one(a:\
    \ .intValue(1), b: .intValue(2)) == .intValue(2))\nassert(compare_one(a: .intValue(1),\
    \ b: .doubleValue(2.5)) == .doubleValue(2.5))\nassert(compare_one(a: .intValue(2),\
    \ b: .intValue(3)) == .intValue(3))\nassert(compare_one(a: .intValue(5), b: .intValue(6))\
    \ == .intValue(6))\nassert(compare_one(a: .intValue(1), b: .stringValue(\"2,3\"\
    )) == .stringValue(\"2,3\"))\nassert(compare_one(a: .stringValue(\"5,1\"), b:\
    \ .stringValue(\"6\")) == .stringValue(\"6\"))\nassert(compare_one(a: .stringValue(\"\
    1\"), b: .stringValue(\"2\")) == .stringValue(\"2\"))\nassert(compare_one(a: .stringValue(\"\
    1\"), b: .intValue(1)) == nil)"
  status: SyntaxError
  stderr: "/tmp/tmpsa9o4qp3.swift:22:13: error: cannot find 'parse' in scope\n   \
    \ let a = parse(a)\n            ^~~~~\n/tmp/tmpsa9o4qp3.swift:23:13: error: cannot\
    \ find 'parse' in scope\n    let b = parse(b)\n            ^~~~~\n"
  stdout: ''
  timestamp: 1660013180
- exit_code: -4
  program: "\nenum Value: Equatable, Hashable {\n    case intValue(Int)\n    case\
    \ doubleValue(Double)\n    case stringValue(String)\n}\n\n            \n/// Create\
    \ a function that takes integers, floats, or strings representing\n/// real numbers,\
    \ and returns the larger variable in its given variable type.\n/// Return nil\
    \ if the values are equal.\n/// Note: If a real number is represented as a string,\
    \ the floating point might be . or ,\n/// >>> compare_one(a: .intValue(1), b:\
    \ .doubleValue(2.5))\n/// .doubleValue(2.5)\n/// >>> compare_one(a: .intValue(1),\
    \ b: .stringValue(\"2,3\"))\n/// .stringValue(\"2,3\")\n/// >>> compare_one(a:\
    \ .stringValue(\"5,1\"), b: .stringValue(\"6\"))\n/// .stringValue(\"6\")\n///\
    \ >>> compare_one(a: .stringValue(\"1\"), b: .intValue(1))\n/// nil\nfunc compare_one(a:\
    \ Value, b: Value) -> Value? {\n    guard case let .intValue(aInt) = a, case let\
    \ .intValue(bInt) = b else {\n        return nil\n    }\n    return aInt > bInt\
    \ ? a : b\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n\
    \    if left.count != right.count {\n        return false\n    }\n    for (l,\
    \ r) in zip(left, right) {\n        if l != r {\n            return false\n  \
    \      }\n    }\n    return true\n}\n            \nassert(compare_one(a: .intValue(1),\
    \ b: .intValue(2)) == .intValue(2))\nassert(compare_one(a: .intValue(1), b: .doubleValue(2.5))\
    \ == .doubleValue(2.5))\nassert(compare_one(a: .intValue(2), b: .intValue(3))\
    \ == .intValue(3))\nassert(compare_one(a: .intValue(5), b: .intValue(6)) == .intValue(6))\n\
    assert(compare_one(a: .intValue(1), b: .stringValue(\"2,3\")) == .stringValue(\"\
    2,3\"))\nassert(compare_one(a: .stringValue(\"5,1\"), b: .stringValue(\"6\"))\
    \ == .stringValue(\"6\"))\nassert(compare_one(a: .stringValue(\"1\"), b: .stringValue(\"\
    2\")) == .stringValue(\"2\"))\nassert(compare_one(a: .stringValue(\"1\"), b: .intValue(1))\
    \ == nil)"
  status: Exception
  stderr: 'tmphl7nnhc6/tmphl7nnhc6.swift:42: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b3068b36c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b306882db6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b306882d988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b306882c7b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmphl7nnhc6                        0x000055dd2b04fd54 <unavailable> + 7508

    5    libc.so.6                          0x00002b3068d22460 __libc_start_main +
    245

    6    tmphl7nnhc6                        0x000055dd2b04f499 <unavailable> + 5273

    '
  stdout: ''
  timestamp: 1660013181
- exit_code: 1
  program: "\nenum Value: Equatable, Hashable {\n    case intValue(Int)\n    case\
    \ doubleValue(Double)\n    case stringValue(String)\n}\n\n            \n/// Create\
    \ a function that takes integers, floats, or strings representing\n/// real numbers,\
    \ and returns the larger variable in its given variable type.\n/// Return nil\
    \ if the values are equal.\n/// Note: If a real number is represented as a string,\
    \ the floating point might be . or ,\n/// >>> compare_one(a: .intValue(1), b:\
    \ .doubleValue(2.5))\n/// .doubleValue(2.5)\n/// >>> compare_one(a: .intValue(1),\
    \ b: .stringValue(\"2,3\"))\n/// .stringValue(\"2,3\")\n/// >>> compare_one(a:\
    \ .stringValue(\"5,1\"), b: .stringValue(\"6\"))\n/// .stringValue(\"6\")\n///\
    \ >>> compare_one(a: .stringValue(\"1\"), b: .intValue(1))\n/// nil\nfunc compare_one(a:\
    \ Value, b: Value) -> Value? {\n    switch (a, b) {\n    case let (.intValue(a),\
    \ .intValue(b)) where a > b:\n        return .intValue(a)\n    case let (.intValue(a),\
    \ .intValue(b)) where a < b:\n        return .intValue(b)\n    case let (.intValue(a),\
    \ .doubleValue(b)) where a > b:\n        return .intValue(a)\n    case let (.intValue(a),\
    \ .doubleValue(b)) where a < b:\n        return .doubleValue(b)\n    case let\
    \ (.intValue(a), .stringValue(b)) where a > Double(b.components(separatedBy: \"\
    ,\").joined()) ?? 0:\n        return .intValue(a)\n    case let (.intValue(a),\
    \ .stringValue(b)) where a < Double(b.components(separatedBy: \",\").joined())\
    \ ?? 0:\n        return .stringValue(b)\n    case let (.doubleValue(a), .intValue(b))\
    \ where a > b:\n        return .doubleValue(a)\n    case let (.doubleValue(a),\
    \ .intValue(b)) where a < b:\n        return .intValue(b)\n    case let (.doubleValue(a),\
    \ .doubleValue(b)) where a > b:\n        return .doubleValue(a)\n    case let\
    \ (.doubleValue(a), .doubleValue(b)) where a < b:\n        return .doubleValue(b)\n\
    \    case let (.doubleValue(a), .stringValue(b)) where a > Double(b.components(separatedBy:\
    \ \",\").joined()) ?? 0:\n        return .doubleValue(a)\n    case let (.doubleValue(a),\
    \ .stringValue(b)) where a < Double(b.components(separatedBy: \",\").joined())\
    \ ?? 0:\n        return .stringValue(b)\n    case let (.stringValue(a), .intValue(b))\
    \ where Double(a.components(separatedBy: \",\").joined()) ?? 0 > b:\n        return\
    \ .stringValue(a)\n    case let (.stringValue(a), .intValue(b)) where Double(a.components(separatedBy:\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(compare_one(a: .intValue(1), b: .intValue(2))\
    \ == .intValue(2))\nassert(compare_one(a: .intValue(1), b: .doubleValue(2.5))\
    \ == .doubleValue(2.5))\nassert(compare_one(a: .intValue(2), b: .intValue(3))\
    \ == .intValue(3))\nassert(compare_one(a: .intValue(5), b: .intValue(6)) == .intValue(6))\n\
    assert(compare_one(a: .intValue(1), b: .stringValue(\"2,3\")) == .stringValue(\"\
    2,3\"))\nassert(compare_one(a: .stringValue(\"5,1\"), b: .stringValue(\"6\"))\
    \ == .stringValue(\"6\"))\nassert(compare_one(a: .stringValue(\"1\"), b: .stringValue(\"\
    2\")) == .stringValue(\"2\"))\nassert(compare_one(a: .stringValue(\"1\"), b: .intValue(1))\
    \ == nil)"
  status: SyntaxError
  stderr: "/tmp/tmp0iyw9nkl.swift:50:1: error: expected expression in list of expressions\n\
    }\n^\n/tmp/tmp0iyw9nkl.swift:49:84: error: expected ':' after 'case'\n    case\
    \ let (.stringValue(a), .intValue(b)) where Double(a.components(separatedBy:\n\
    \                                                                            \
    \       ^\n/tmp/tmp0iyw9nkl.swift:72:66: error: expected '}' at end of brace statement\n\
    assert(compare_one(a: .stringValue(\"1\"), b: .intValue(1)) == nil)\n        \
    \                                                         ^\n/tmp/tmp0iyw9nkl.swift:21:48:\
    \ note: to match this opening '{'\nfunc compare_one(a: Value, b: Value) -> Value?\
    \ {\n                                               ^\n/tmp/tmp0iyw9nkl.swift:27:54:\
    \ error: binary operator '>' cannot be applied to operands of type 'Int' and 'Double'\n\
    \    case let (.intValue(a), .doubleValue(b)) where a > b:\n                 \
    \                                  ~ ^ ~\n/tmp/tmp0iyw9nkl.swift:27:54: note:\
    \ overloads for '>' exist with these partially matching parameter lists: (Int,\
    \ Int)\n    case let (.intValue(a), .doubleValue(b)) where a > b:\n          \
    \                                           ^\n/tmp/tmp0iyw9nkl.swift:29:54: error:\
    \ binary operator '<' cannot be applied to operands of type 'Int' and 'Double'\n\
    \    case let (.intValue(a), .doubleValue(b)) where a < b:\n                 \
    \                                  ~ ^ ~\n/tmp/tmp0iyw9nkl.swift:29:54: note:\
    \ overloads for '<' exist with these partially matching parameter lists: (Int,\
    \ Int)\n    case let (.intValue(a), .doubleValue(b)) where a < b:\n          \
    \                                           ^\n/tmp/tmp0iyw9nkl.swift:31:104:\
    \ error: cannot convert value of type 'Double' to expected argument type 'Int'\n\
    \    case let (.intValue(a), .stringValue(b)) where a > Double(b.components(separatedBy:\
    \ \",\").joined()) ?? 0:\n                                                   \
    \                                                    ^\n                     \
    \                                  Int(                                      \
    \          )\n/tmp/tmp0iyw9"
  stdout: ''
  timestamp: 1660013181
- exit_code: 1
  program: "\nenum Value: Equatable, Hashable {\n    case intValue(Int)\n    case\
    \ doubleValue(Double)\n    case stringValue(String)\n}\n\n            \n/// Create\
    \ a function that takes integers, floats, or strings representing\n/// real numbers,\
    \ and returns the larger variable in its given variable type.\n/// Return nil\
    \ if the values are equal.\n/// Note: If a real number is represented as a string,\
    \ the floating point might be . or ,\n/// >>> compare_one(a: .intValue(1), b:\
    \ .doubleValue(2.5))\n/// .doubleValue(2.5)\n/// >>> compare_one(a: .intValue(1),\
    \ b: .stringValue(\"2,3\"))\n/// .stringValue(\"2,3\")\n/// >>> compare_one(a:\
    \ .stringValue(\"5,1\"), b: .stringValue(\"6\"))\n/// .stringValue(\"6\")\n///\
    \ >>> compare_one(a: .stringValue(\"1\"), b: .intValue(1))\n/// nil\nfunc compare_one(a:\
    \ Value, b: Value) -> Value? {\n    switch (a, b) {\n    case (.intValue(let lhs),\
    \ .intValue(let rhs)):\n        if lhs > rhs {\n            return .intValue(lhs)\n\
    \        } else if lhs < rhs {\n            return .intValue(rhs)\n        } else\
    \ {\n            return nil\n        }\n    case (.intValue(let lhs), .doubleValue(let\
    \ rhs)):\n        if Double(lhs) > rhs {\n            return .doubleValue(Double(lhs))\n\
    \        } else if Double(lhs) < rhs {\n            return .doubleValue(rhs)\n\
    \        } else {\n            return nil\n        }\n    case (.intValue(let\
    \ lhs), .stringValue(let rhs)):\n        if Double(lhs) > Double(rhs) {\n    \
    \        return .doubleValue(Double(lhs))\n        } else if Double(lhs) < Double(rhs)\
    \ {\n            return .doubleValue(Double(rhs))\n        } else {\n        \
    \    return nil\n        }\n    case (.doubleValue(let lhs), .intValue(let rhs)):\n\
    \        if lhs > Double(rhs) {\n            return .doubleValue(lhs)\n      \
    \  } else if lhs < Double(rhs) {\n            return .doubleValue(Double(rhs))\n\
    \        } else {\n            return nil\n        }\n    case (.doubleValue(let\
    \ lhs), .doubleValue(let rhs)):\n        if lhs > rhs {\n            return .doubleValue(lhs)\n\
    \        } else if lhs < rhs {\n            return .doubleValue(rhs)\n       \
    \ } else {\n            return nil\n        }\n    case (.doubleValue(let lhs),\
    \ .stringValue(let rhs)):\n        if lhs > Double(rhs) {\n            return\
    \ .doubleValue(lhs)\n        } else if lhs < Double(rhs) {\n            return\
    \ .doubleValue(Double(rhs))\n        } else {\n            return nil\n      \
    \  }\n    case (.stringValue(let lhs), .intValue(let rhs)):\n        if Double(lhs)\
    \ > Double(\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n\
    \    if left.count != right.count {\n        return false\n    }\n    for (l,\
    \ r) in zip(left, right) {\n        if l != r {\n            return false\n  \
    \      }\n    }\n    return true\n}\n            \nassert(compare_one(a: .intValue(1),\
    \ b: .intValue(2)) == .intValue(2))\nassert(compare_one(a: .intValue(1), b: .doubleValue(2.5))\
    \ == .doubleValue(2.5))\nassert(compare_one(a: .intValue(2), b: .intValue(3))\
    \ == .intValue(3))\nassert(compare_one(a: .intValue(5), b: .intValue(6)) == .intValue(6))\n\
    assert(compare_one(a: .intValue(1), b: .stringValue(\"2,3\")) == .stringValue(\"\
    2,3\"))\nassert(compare_one(a: .stringValue(\"5,1\"), b: .stringValue(\"6\"))\
    \ == .stringValue(\"6\"))\nassert(compare_one(a: .stringValue(\"1\"), b: .stringValue(\"\
    2\")) == .stringValue(\"2\"))\nassert(compare_one(a: .stringValue(\"1\"), b: .intValue(1))\
    \ == nil)"
  status: SyntaxError
  stderr: "/tmp/tmp5yl6e354.swift:73:1: error: expected expression in list of expressions\n\
    }\n^\n/tmp/tmp5yl6e354.swift:95:66: error: expected '}' at end of brace statement\n\
    assert(compare_one(a: .stringValue(\"1\"), b: .intValue(1)) == nil)\n        \
    \                                                         ^\n/tmp/tmp5yl6e354.swift:21:48:\
    \ note: to match this opening '{'\nfunc compare_one(a: Value, b: Value) -> Value?\
    \ {\n                                               ^\n/tmp/tmp5yl6e354.swift:40:26:\
    \ error: value of optional type 'Double?' must be unwrapped to a value of type\
    \ 'Double'\n        if Double(lhs) > Double(rhs) {\n                         ^\n\
    /tmp/tmp5yl6e354.swift:40:26: note: coalesce using '??' to provide a default when\
    \ the optional value contains 'nil'\n        if Double(lhs) > Double(rhs) {\n\
    \                         ^\n                                     ?? <#default\
    \ value#>\n/tmp/tmp5yl6e354.swift:40:26: note: force-unwrap using '!' to abort\
    \ execution if the optional value contains 'nil'\n        if Double(lhs) > Double(rhs)\
    \ {\n                         ^\n                                    !\n/tmp/tmp5yl6e354.swift:42:33:\
    \ error: value of optional type 'Double?' must be unwrapped to a value of type\
    \ 'Double'\n        } else if Double(lhs) < Double(rhs) {\n                  \
    \              ^\n/tmp/tmp5yl6e354.swift:42:33: note: coalesce using '??' to provide\
    \ a default when the optional value contains 'nil'\n        } else if Double(lhs)\
    \ < Double(rhs) {\n                                ^\n                       \
    \                     ?? <#default value#>\n/tmp/tmp5yl6e354.swift:42:33: note:\
    \ force-unwrap using '!' to abort execution if the optional value contains 'nil'\n\
    \        } else if Double(lhs) < Double(rhs) {\n                             \
    \   ^\n                                           !\n/tmp/tmp5yl6e354.swift:43:33:\
    \ error: value of optional type 'Double?' must be unwrapped to a value of type\
    \ 'Double'\n            return .doubleValue(Double(rhs))\n                   \
    \             ^\n/tmp/tmp5yl6e354.swift:43:33: note: coalesce using '??' to prov"
  stdout: ''
  timestamp: 1660013180
- exit_code: 1
  program: "\nenum Value: Equatable, Hashable {\n    case intValue(Int)\n    case\
    \ doubleValue(Double)\n    case stringValue(String)\n}\n\n            \n/// Create\
    \ a function that takes integers, floats, or strings representing\n/// real numbers,\
    \ and returns the larger variable in its given variable type.\n/// Return nil\
    \ if the values are equal.\n/// Note: If a real number is represented as a string,\
    \ the floating point might be . or ,\n/// >>> compare_one(a: .intValue(1), b:\
    \ .doubleValue(2.5))\n/// .doubleValue(2.5)\n/// >>> compare_one(a: .intValue(1),\
    \ b: .stringValue(\"2,3\"))\n/// .stringValue(\"2,3\")\n/// >>> compare_one(a:\
    \ .stringValue(\"5,1\"), b: .stringValue(\"6\"))\n/// .stringValue(\"6\")\n///\
    \ >>> compare_one(a: .stringValue(\"1\"), b: .intValue(1))\n/// nil\nfunc compare_one(a:\
    \ Value, b: Value) -> Value? {\n    switch (a, b) {\n    case (.intValue(let a),\
    \ .intValue(let b)):\n        return a > b ? a : b\n    case (.doubleValue(let\
    \ a), .doubleValue(let b)):\n        return a > b ? a : b\n    case (.stringValue(let\
    \ a), .stringValue(let b)):\n        return a > b ? a : b\n    default:\n    \
    \    return nil\n    }\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(compare_one(a:\
    \ .intValue(1), b: .intValue(2)) == .intValue(2))\nassert(compare_one(a: .intValue(1),\
    \ b: .doubleValue(2.5)) == .doubleValue(2.5))\nassert(compare_one(a: .intValue(2),\
    \ b: .intValue(3)) == .intValue(3))\nassert(compare_one(a: .intValue(5), b: .intValue(6))\
    \ == .intValue(6))\nassert(compare_one(a: .intValue(1), b: .stringValue(\"2,3\"\
    )) == .stringValue(\"2,3\"))\nassert(compare_one(a: .stringValue(\"5,1\"), b:\
    \ .stringValue(\"6\")) == .stringValue(\"6\"))\nassert(compare_one(a: .stringValue(\"\
    1\"), b: .stringValue(\"2\")) == .stringValue(\"2\"))\nassert(compare_one(a: .stringValue(\"\
    1\"), b: .intValue(1)) == nil)"
  status: SyntaxError
  stderr: "/tmp/tmp07haxekb.swift:24:22: error: cannot convert return expression of\
    \ type 'Int' to return type 'Value?'\n        return a > b ? a : b\n         \
    \      ~~~~~~^~~~~~~\n/tmp/tmp07haxekb.swift:26:22: error: cannot convert return\
    \ expression of type 'Double' to return type 'Value?'\n        return a > b ?\
    \ a : b\n               ~~~~~~^~~~~~~\n/tmp/tmp07haxekb.swift:28:22: error: cannot\
    \ convert return expression of type 'String' to return type 'Value?'\n       \
    \ return a > b ? a : b\n               ~~~~~~^~~~~~~\n"
  stdout: ''
  timestamp: 1660013180
- exit_code: 1
  program: "\nenum Value: Equatable, Hashable {\n    case intValue(Int)\n    case\
    \ doubleValue(Double)\n    case stringValue(String)\n}\n\n            \n/// Create\
    \ a function that takes integers, floats, or strings representing\n/// real numbers,\
    \ and returns the larger variable in its given variable type.\n/// Return nil\
    \ if the values are equal.\n/// Note: If a real number is represented as a string,\
    \ the floating point might be . or ,\n/// >>> compare_one(a: .intValue(1), b:\
    \ .doubleValue(2.5))\n/// .doubleValue(2.5)\n/// >>> compare_one(a: .intValue(1),\
    \ b: .stringValue(\"2,3\"))\n/// .stringValue(\"2,3\")\n/// >>> compare_one(a:\
    \ .stringValue(\"5,1\"), b: .stringValue(\"6\"))\n/// .stringValue(\"6\")\n///\
    \ >>> compare_one(a: .stringValue(\"1\"), b: .intValue(1))\n/// nil\nfunc compare_one(a:\
    \ Value, b: Value) -> Value? {\n    if case .intValue(let aValue) = a, case .intValue(let\
    \ bValue) = b {\n        return aValue > bValue ? a : bValue > aValue ? b : nil\n\
    \    } else if case .doubleValue(let aValue) = a, case .doubleValue(let bValue)\
    \ = b {\n        return aValue > bValue ? a : bValue > aValue ? b : nil\n    }\
    \ else if case .stringValue(let aValue) = a, case .stringValue(let bValue) = b\
    \ {\n        return Double(aValue) > Double(bValue) ? a : Double(bValue) > Double(aValue)\
    \ ? b : nil\n    } else if case .intValue(let aValue) = a, case .stringValue(let\
    \ bValue) = b {\n        return aValue > Double(bValue) ? a : Double(bValue) >\
    \ aValue ? b : nil\n    } else if case .stringValue(let aValue) = a, case .intValue(let\
    \ bValue) = b {\n        return Double(aValue) > bValue ? a : bValue > Double(aValue)\
    \ ? b : nil\n    } else if case .doubleValue(let aValue) = a, case .stringValue(let\
    \ bValue) = b {\n        return aValue > Double(bValue) ? a : Double(bValue) >\
    \ aValue ? b : nil\n    } else if case .stringValue(let aValue) = a, case .doubleValue(let\
    \ bValue) = b {\n        return Double(aValue) > bValue ? a : bValue > Double(aValue)\
    \ ? b : nil\n    } else {\n        return nil\n    }\n}\n\n\nfunc ==(left: [(Int,\
    \ Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n\
    \        return false\n    }\n    for (l, r) in zip(left, right) {\n        if\
    \ l != r {\n            return false\n        }\n    }\n    return true\n}\n \
    \           \nassert(compare_one(a: .intValue(1), b: .intValue(2)) == .intValue(2))\n\
    assert(compare_one(a: .intValue(1), b: .doubleValue(2.5)) == .doubleValue(2.5))\n\
    assert(compare_one(a: .intValue(2), b: .intValue(3)) == .intValue(3))\nassert(compare_one(a:\
    \ .intValue(5), b: .intValue(6)) == .intValue(6))\nassert(compare_one(a: .intValue(1),\
    \ b: .stringValue(\"2,3\")) == .stringValue(\"2,3\"))\nassert(compare_one(a: .stringValue(\"\
    5,1\"), b: .stringValue(\"6\")) == .stringValue(\"6\"))\nassert(compare_one(a:\
    \ .stringValue(\"1\"), b: .stringValue(\"2\")) == .stringValue(\"2\"))\nassert(compare_one(a:\
    \ .stringValue(\"1\"), b: .intValue(1)) == nil)"
  status: SyntaxError
  stderr: "/tmp/tmpyvy9m0_1.swift:27:33: error: value of optional type 'Double?' must\
    \ be unwrapped to a value of type 'Double'\n        return Double(aValue) > Double(bValue)\
    \ ? a : Double(bValue) > Double(aValue) ? b : nil\n                          \
    \      ^\n/tmp/tmpyvy9m0_1.swift:27:33: note: coalesce using '??' to provide a\
    \ default when the optional value contains 'nil'\n        return Double(aValue)\
    \ > Double(bValue) ? a : Double(bValue) > Double(aValue) ? b : nil\n         \
    \                       ^\n                                               ?? <#default\
    \ value#>\n/tmp/tmpyvy9m0_1.swift:27:33: note: force-unwrap using '!' to abort\
    \ execution if the optional value contains 'nil'\n        return Double(aValue)\
    \ > Double(bValue) ? a : Double(bValue) > Double(aValue) ? b : nil\n         \
    \                       ^\n                                              !\n/tmp/tmpyvy9m0_1.swift:27:16:\
    \ error: value of optional type 'Double?' must be unwrapped to a value of type\
    \ 'Double'\n        return Double(aValue) > Double(bValue) ? a : Double(bValue)\
    \ > Double(aValue) ? b : nil\n               ^\n/tmp/tmpyvy9m0_1.swift:27:16:\
    \ note: coalesce using '??' to provide a default when the optional value contains\
    \ 'nil'\n        return Double(aValue) > Double(bValue) ? a : Double(bValue) >\
    \ Double(aValue) ? b : nil\n               ^\n                              ??\
    \ <#default value#>\n/tmp/tmpyvy9m0_1.swift:27:16: note: force-unwrap using '!'\
    \ to abort execution if the optional value contains 'nil'\n        return Double(aValue)\
    \ > Double(bValue) ? a : Double(bValue) > Double(aValue) ? b : nil\n         \
    \      ^\n                             !\n/tmp/tmpyvy9m0_1.swift:27:71: error:\
    \ value of optional type 'Double?' must be unwrapped to a value of type 'Double'\n\
    \        return Double(aValue) > Double(bValue) ? a : Double(bValue) > Double(aValue)\
    \ ? b : nil\n                                                                \
    \      ^\n/tmp/tmpyvy9m0_1.swift:27:71: note: coalesce using '??' to provide a\
    \ default when the optional value contains 'nil'\n        return Double(aValue)\
    \ > Do"
  stdout: ''
  timestamp: 1660013180
- exit_code: -4
  program: "\nenum Value: Equatable, Hashable {\n    case intValue(Int)\n    case\
    \ doubleValue(Double)\n    case stringValue(String)\n}\n\n            \n/// Create\
    \ a function that takes integers, floats, or strings representing\n/// real numbers,\
    \ and returns the larger variable in its given variable type.\n/// Return nil\
    \ if the values are equal.\n/// Note: If a real number is represented as a string,\
    \ the floating point might be . or ,\n/// >>> compare_one(a: .intValue(1), b:\
    \ .doubleValue(2.5))\n/// .doubleValue(2.5)\n/// >>> compare_one(a: .intValue(1),\
    \ b: .stringValue(\"2,3\"))\n/// .stringValue(\"2,3\")\n/// >>> compare_one(a:\
    \ .stringValue(\"5,1\"), b: .stringValue(\"6\"))\n/// .stringValue(\"6\")\n///\
    \ >>> compare_one(a: .stringValue(\"1\"), b: .intValue(1))\n/// nil\nfunc compare_one(a:\
    \ Value, b: Value) -> Value? {\n    return nil\n}\n\n\nfunc ==(left: [(Int, Int)],\
    \ right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n       \
    \ return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r\
    \ {\n            return false\n        }\n    }\n    return true\n}\n        \
    \    \nassert(compare_one(a: .intValue(1), b: .intValue(2)) == .intValue(2))\n\
    assert(compare_one(a: .intValue(1), b: .doubleValue(2.5)) == .doubleValue(2.5))\n\
    assert(compare_one(a: .intValue(2), b: .intValue(3)) == .intValue(3))\nassert(compare_one(a:\
    \ .intValue(5), b: .intValue(6)) == .intValue(6))\nassert(compare_one(a: .intValue(1),\
    \ b: .stringValue(\"2,3\")) == .stringValue(\"2,3\"))\nassert(compare_one(a: .stringValue(\"\
    5,1\"), b: .stringValue(\"6\")) == .stringValue(\"6\"))\nassert(compare_one(a:\
    \ .stringValue(\"1\"), b: .stringValue(\"2\")) == .stringValue(\"2\"))\nassert(compare_one(a:\
    \ .stringValue(\"1\"), b: .intValue(1)) == nil)"
  status: Exception
  stderr: 'tmpllswmh2d/tmpllswmh2d.swift:38: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b05c2ae8c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b05c27dfb6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b05c27df988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b05c27de7b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpllswmh2d                        0x000055f806e32a56 <unavailable> + 6742

    5    libc.so.6                          0x00002b05c2cd4460 __libc_start_main +
    245

    6    tmpllswmh2d                        0x000055f806e32499 <unavailable> + 5273

    '
  stdout: ''
  timestamp: 1660013179
- exit_code: 1
  program: "\nenum Value: Equatable, Hashable {\n    case intValue(Int)\n    case\
    \ doubleValue(Double)\n    case stringValue(String)\n}\n\n            \n/// Create\
    \ a function that takes integers, floats, or strings representing\n/// real numbers,\
    \ and returns the larger variable in its given variable type.\n/// Return nil\
    \ if the values are equal.\n/// Note: If a real number is represented as a string,\
    \ the floating point might be . or ,\n/// >>> compare_one(a: .intValue(1), b:\
    \ .doubleValue(2.5))\n/// .doubleValue(2.5)\n/// >>> compare_one(a: .intValue(1),\
    \ b: .stringValue(\"2,3\"))\n/// .stringValue(\"2,3\")\n/// >>> compare_one(a:\
    \ .stringValue(\"5,1\"), b: .stringValue(\"6\"))\n/// .stringValue(\"6\")\n///\
    \ >>> compare_one(a: .stringValue(\"1\"), b: .intValue(1))\n/// nil\nfunc compare_one(a:\
    \ Value, b: Value) -> Value? {\n    switch a {\n    case .intValue(let a) where\
    \ b == .intValue(a):\n        return nil\n    case .intValue(let a) where b ==\
    \ .doubleValue(Double(a)):\n        return b\n    case .intValue(let a) where\
    \ b == .stringValue(String(a)):\n        return b\n    case .doubleValue(let a)\
    \ where b == .intValue(Int(a)):\n        return a\n    case .doubleValue(let a)\
    \ where b == .doubleValue(a):\n        return nil\n    case .doubleValue(let a)\
    \ where b == .stringValue(String(a)):\n        return b\n    case .stringValue(let\
    \ a) where b == .intValue(Int(a)):\n        return a\n    case .stringValue(let\
    \ a) where b == .doubleValue(Double(a)):\n        return a\n    case .stringValue(let\
    \ a) where b == .stringValue(a):\n        return nil\n    default:\n        return\
    \ nil\n    }\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool\
    \ {\n    if left.count != right.count {\n        return false\n    }\n    for\
    \ (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(compare_one(a: .intValue(1),\
    \ b: .intValue(2)) == .intValue(2))\nassert(compare_one(a: .intValue(1), b: .doubleValue(2.5))\
    \ == .doubleValue(2.5))\nassert(compare_one(a: .intValue(2), b: .intValue(3))\
    \ == .intValue(3))\nassert(compare_one(a: .intValue(5), b: .intValue(6)) == .intValue(6))\n\
    assert(compare_one(a: .intValue(1), b: .stringValue(\"2,3\")) == .stringValue(\"\
    2,3\"))\nassert(compare_one(a: .stringValue(\"5,1\"), b: .stringValue(\"6\"))\
    \ == .stringValue(\"6\"))\nassert(compare_one(a: .stringValue(\"1\"), b: .stringValue(\"\
    2\")) == .stringValue(\"2\"))\nassert(compare_one(a: .stringValue(\"1\"), b: .intValue(1))\
    \ == nil)"
  status: SyntaxError
  stderr: "/tmp/tmpcp1kh9ug.swift:35:51: error: value of optional type 'Int?' must\
    \ be unwrapped to a value of type 'Int'\n    case .stringValue(let a) where b\
    \ == .intValue(Int(a)):\n                                                  ^\n\
    /tmp/tmpcp1kh9ug.swift:35:51: note: coalesce using '??' to provide a default when\
    \ the optional value contains 'nil'\n    case .stringValue(let a) where b == .intValue(Int(a)):\n\
    \                                                  ^\n                       \
    \                                  ?? <#default value#>\n/tmp/tmpcp1kh9ug.swift:35:51:\
    \ note: force-unwrap using '!' to abort execution if the optional value contains\
    \ 'nil'\n    case .stringValue(let a) where b == .intValue(Int(a)):\n        \
    \                                          ^\n                               \
    \                         !\n/tmp/tmpcp1kh9ug.swift:37:54: error: value of optional\
    \ type 'Double?' must be unwrapped to a value of type 'Double'\n    case .stringValue(let\
    \ a) where b == .doubleValue(Double(a)):\n                                   \
    \                  ^\n/tmp/tmpcp1kh9ug.swift:37:54: note: coalesce using '??'\
    \ to provide a default when the optional value contains 'nil'\n    case .stringValue(let\
    \ a) where b == .doubleValue(Double(a)):\n                                   \
    \                  ^\n                                                       \
    \        ?? <#default value#>\n/tmp/tmpcp1kh9ug.swift:37:54: note: force-unwrap\
    \ using '!' to abort execution if the optional value contains 'nil'\n    case\
    \ .stringValue(let a) where b == .doubleValue(Double(a)):\n                  \
    \                                   ^\n                                      \
    \                        !\n/tmp/tmpcp1kh9ug.swift:30:16: error: cannot convert\
    \ return expression of type 'Double' to return type 'Value?'\n        return a\n\
    \               ^\n/tmp/tmpcp1kh9ug.swift:36:16: error: cannot convert return\
    \ expression of type 'String' to return type 'Value?'\n        return a\n    \
    \           ^\n/tmp/tmpcp1kh9ug.swift:38:16: error: cannot convert return expression\
    \ of type 'String' to ret"
  stdout: ''
  timestamp: 1660013180
- exit_code: 1
  program: "\nenum Value: Equatable, Hashable {\n    case intValue(Int)\n    case\
    \ doubleValue(Double)\n    case stringValue(String)\n}\n\n            \n/// Create\
    \ a function that takes integers, floats, or strings representing\n/// real numbers,\
    \ and returns the larger variable in its given variable type.\n/// Return nil\
    \ if the values are equal.\n/// Note: If a real number is represented as a string,\
    \ the floating point might be . or ,\n/// >>> compare_one(a: .intValue(1), b:\
    \ .doubleValue(2.5))\n/// .doubleValue(2.5)\n/// >>> compare_one(a: .intValue(1),\
    \ b: .stringValue(\"2,3\"))\n/// .stringValue(\"2,3\")\n/// >>> compare_one(a:\
    \ .stringValue(\"5,1\"), b: .stringValue(\"6\"))\n/// .stringValue(\"6\")\n///\
    \ >>> compare_one(a: .stringValue(\"1\"), b: .intValue(1))\n/// nil\nfunc compare_one(a:\
    \ Value, b: Value) -> Value? {\n    switch (a, b) {\n    case let (.intValue(a),\
    \ .intValue(b)) where a != b:\n        return a > b ? a : b\n    case let (.doubleValue(a),\
    \ .doubleValue(b)) where a != b:\n        return a > b ? a : b\n    case let (.stringValue(a),\
    \ .stringValue(b)) where a != b:\n        return a > b ? a : b\n    default:\n\
    \        return nil\n    }\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(compare_one(a:\
    \ .intValue(1), b: .intValue(2)) == .intValue(2))\nassert(compare_one(a: .intValue(1),\
    \ b: .doubleValue(2.5)) == .doubleValue(2.5))\nassert(compare_one(a: .intValue(2),\
    \ b: .intValue(3)) == .intValue(3))\nassert(compare_one(a: .intValue(5), b: .intValue(6))\
    \ == .intValue(6))\nassert(compare_one(a: .intValue(1), b: .stringValue(\"2,3\"\
    )) == .stringValue(\"2,3\"))\nassert(compare_one(a: .stringValue(\"5,1\"), b:\
    \ .stringValue(\"6\")) == .stringValue(\"6\"))\nassert(compare_one(a: .stringValue(\"\
    1\"), b: .stringValue(\"2\")) == .stringValue(\"2\"))\nassert(compare_one(a: .stringValue(\"\
    1\"), b: .intValue(1)) == nil)"
  status: SyntaxError
  stderr: "/tmp/tmpe9rc17ll.swift:24:22: error: cannot convert return expression of\
    \ type 'Int' to return type 'Value?'\n        return a > b ? a : b\n         \
    \      ~~~~~~^~~~~~~\n/tmp/tmpe9rc17ll.swift:26:22: error: cannot convert return\
    \ expression of type 'Double' to return type 'Value?'\n        return a > b ?\
    \ a : b\n               ~~~~~~^~~~~~~\n/tmp/tmpe9rc17ll.swift:28:22: error: cannot\
    \ convert return expression of type 'String' to return type 'Value?'\n       \
    \ return a > b ? a : b\n               ~~~~~~^~~~~~~\n"
  stdout: ''
  timestamp: 1660013179
- exit_code: 1
  program: "\nenum Value: Equatable, Hashable {\n    case intValue(Int)\n    case\
    \ doubleValue(Double)\n    case stringValue(String)\n}\n\n            \n/// Create\
    \ a function that takes integers, floats, or strings representing\n/// real numbers,\
    \ and returns the larger variable in its given variable type.\n/// Return nil\
    \ if the values are equal.\n/// Note: If a real number is represented as a string,\
    \ the floating point might be . or ,\n/// >>> compare_one(a: .intValue(1), b:\
    \ .doubleValue(2.5))\n/// .doubleValue(2.5)\n/// >>> compare_one(a: .intValue(1),\
    \ b: .stringValue(\"2,3\"))\n/// .stringValue(\"2,3\")\n/// >>> compare_one(a:\
    \ .stringValue(\"5,1\"), b: .stringValue(\"6\"))\n/// .stringValue(\"6\")\n///\
    \ >>> compare_one(a: .stringValue(\"1\"), b: .intValue(1))\n/// nil\nfunc compare_one(a:\
    \ Value, b: Value) -> Value? {\n    guard let a = toDouble(a), let b = toDouble(b)\
    \ else { return nil }\n    return a > b ? toValue(a) : toValue(b)\n}\n\n\nfunc\
    \ ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count !=\
    \ right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(compare_one(a: .intValue(1), b: .intValue(2))\
    \ == .intValue(2))\nassert(compare_one(a: .intValue(1), b: .doubleValue(2.5))\
    \ == .doubleValue(2.5))\nassert(compare_one(a: .intValue(2), b: .intValue(3))\
    \ == .intValue(3))\nassert(compare_one(a: .intValue(5), b: .intValue(6)) == .intValue(6))\n\
    assert(compare_one(a: .intValue(1), b: .stringValue(\"2,3\")) == .stringValue(\"\
    2,3\"))\nassert(compare_one(a: .stringValue(\"5,1\"), b: .stringValue(\"6\"))\
    \ == .stringValue(\"6\"))\nassert(compare_one(a: .stringValue(\"1\"), b: .stringValue(\"\
    2\")) == .stringValue(\"2\"))\nassert(compare_one(a: .stringValue(\"1\"), b: .intValue(1))\
    \ == nil)"
  status: SyntaxError
  stderr: "/tmp/tmp2le39g0j.swift:22:19: error: cannot find 'toDouble' in scope\n\
    \    guard let a = toDouble(a), let b = toDouble(b) else { return nil }\n    \
    \              ^~~~~~~~\n/tmp/tmp2le39g0j.swift:22:40: error: cannot find 'toDouble'\
    \ in scope\n    guard let a = toDouble(a), let b = toDouble(b) else { return nil\
    \ }\n                                       ^~~~~~~~\n/tmp/tmp2le39g0j.swift:23:20:\
    \ error: cannot find 'toValue' in scope\n    return a > b ? toValue(a) : toValue(b)\n\
    \                   ^~~~~~~\n/tmp/tmp2le39g0j.swift:23:33: error: cannot find\
    \ 'toValue' in scope\n    return a > b ? toValue(a) : toValue(b)\n           \
    \                     ^~~~~~~\n"
  stdout: ''
  timestamp: 1660013180
- exit_code: 1
  program: "\nenum Value: Equatable, Hashable {\n    case intValue(Int)\n    case\
    \ doubleValue(Double)\n    case stringValue(String)\n}\n\n            \n/// Create\
    \ a function that takes integers, floats, or strings representing\n/// real numbers,\
    \ and returns the larger variable in its given variable type.\n/// Return nil\
    \ if the values are equal.\n/// Note: If a real number is represented as a string,\
    \ the floating point might be . or ,\n/// >>> compare_one(a: .intValue(1), b:\
    \ .doubleValue(2.5))\n/// .doubleValue(2.5)\n/// >>> compare_one(a: .intValue(1),\
    \ b: .stringValue(\"2,3\"))\n/// .stringValue(\"2,3\")\n/// >>> compare_one(a:\
    \ .stringValue(\"5,1\"), b: .stringValue(\"6\"))\n/// .stringValue(\"6\")\n///\
    \ >>> compare_one(a: .stringValue(\"1\"), b: .intValue(1))\n/// nil\nfunc compare_one(a:\
    \ Value, b: Value) -> Value? {\n    switch (a, b) {\n    case (.intValue(let l),\
    \ .intValue(let r)):\n        return l > r ? a : nil\n    case (.intValue(let\
    \ l), .doubleValue(let r)):\n        return l > r ? .doubleValue(Double(l)) :\
    \ b\n    case (.intValue(let l), .stringValue(let r)):\n        return l > Double(r)\
    \ ? .stringValue(String(l)) : b\n    case (.doubleValue(let l), .intValue(let\
    \ r)):\n        return l > r ? a : nil\n    case (.doubleValue(let l), .doubleValue(let\
    \ r)):\n        return l > r ? a : nil\n    case (.doubleValue(let l), .stringValue(let\
    \ r)):\n        return l > Double(r) ? .stringValue(String(l)) : b\n    case (.stringValue(let\
    \ l), .intValue(let r)):\n        return Double(l) > r ? a : nil\n    case (.stringValue(let\
    \ l), .doubleValue(let r)):\n        return Double(l) > r ? a : nil\n    case\
    \ (.stringValue(let l), .stringValue(let r)):\n        return Double(l) > Double(r)\
    \ ? a : nil\n    }\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) ->\
    \ Bool {\n    if left.count != right.count {\n        return false\n    }\n  \
    \  for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(compare_one(a: .intValue(1),\
    \ b: .intValue(2)) == .intValue(2))\nassert(compare_one(a: .intValue(1), b: .doubleValue(2.5))\
    \ == .doubleValue(2.5))\nassert(compare_one(a: .intValue(2), b: .intValue(3))\
    \ == .intValue(3))\nassert(compare_one(a: .intValue(5), b: .intValue(6)) == .intValue(6))\n\
    assert(compare_one(a: .intValue(1), b: .stringValue(\"2,3\")) == .stringValue(\"\
    2,3\"))\nassert(compare_one(a: .stringValue(\"5,1\"), b: .stringValue(\"6\"))\
    \ == .stringValue(\"6\"))\nassert(compare_one(a: .stringValue(\"1\"), b: .stringValue(\"\
    2\")) == .stringValue(\"2\"))\nassert(compare_one(a: .stringValue(\"1\"), b: .intValue(1))\
    \ == nil)"
  status: SyntaxError
  stderr: "/tmp/tmpwu1bmodo.swift:26:20: error: cannot convert value of type 'Double'\
    \ to expected argument type 'Int'\n        return l > r ? .doubleValue(Double(l))\
    \ : b\n                   ^\n                   Int( )\n/tmp/tmpwu1bmodo.swift:28:20:\
    \ error: cannot convert value of type 'Double?' to expected argument type 'Int'\n\
    \        return l > Double(r) ? .stringValue(String(l)) : b\n                \
    \   ^\n/tmp/tmpwu1bmodo.swift:30:16: error: cannot convert value of type 'Double'\
    \ to expected argument type 'Int'\n        return l > r ? a : nil\n          \
    \     ^\n               Int( )\n/tmp/tmpwu1bmodo.swift:34:20: error: value of\
    \ optional type 'Double?' must be unwrapped to a value of type 'Double'\n    \
    \    return l > Double(r) ? .stringValue(String(l)) : b\n                   ^\n\
    /tmp/tmpwu1bmodo.swift:34:20: note: coalesce using '??' to provide a default when\
    \ the optional value contains 'nil'\n        return l > Double(r) ? .stringValue(String(l))\
    \ : b\n                   ^\n                             ?? <#default value#>\n\
    /tmp/tmpwu1bmodo.swift:34:20: note: force-unwrap using '!' to abort execution\
    \ if the optional value contains 'nil'\n        return l > Double(r) ? .stringValue(String(l))\
    \ : b\n                   ^\n                            !\n/tmp/tmpwu1bmodo.swift:36:16:\
    \ error: cannot convert value of type 'Double?' to expected argument type 'Int'\n\
    \        return Double(l) > r ? a : nil\n               ^\n/tmp/tmpwu1bmodo.swift:38:16:\
    \ error: value of optional type 'Double?' must be unwrapped to a value of type\
    \ 'Double'\n        return Double(l) > r ? a : nil\n               ^\n/tmp/tmpwu1bmodo.swift:38:16:\
    \ note: coalesce using '??' to provide a default when the optional value contains\
    \ 'nil'\n        return Double(l) > r ? a : nil\n               ^\n          \
    \               ?? <#default value#>\n/tmp/tmpwu1bmodo.swift:38:16: note: force-unwrap\
    \ using '!' to abort execution if the optional value contains 'nil'\n        return\
    \ Double(l) > r ? a : nil\n               ^\n                        !\n/tmp/tmpwu1bmodo.swift:40:28:\
    \ error: value of optional type "
  stdout: ''
  timestamp: 1660013180
- exit_code: 1
  program: "\nenum Value: Equatable, Hashable {\n    case intValue(Int)\n    case\
    \ doubleValue(Double)\n    case stringValue(String)\n}\n\n            \n/// Create\
    \ a function that takes integers, floats, or strings representing\n/// real numbers,\
    \ and returns the larger variable in its given variable type.\n/// Return nil\
    \ if the values are equal.\n/// Note: If a real number is represented as a string,\
    \ the floating point might be . or ,\n/// >>> compare_one(a: .intValue(1), b:\
    \ .doubleValue(2.5))\n/// .doubleValue(2.5)\n/// >>> compare_one(a: .intValue(1),\
    \ b: .stringValue(\"2,3\"))\n/// .stringValue(\"2,3\")\n/// >>> compare_one(a:\
    \ .stringValue(\"5,1\"), b: .stringValue(\"6\"))\n/// .stringValue(\"6\")\n///\
    \ >>> compare_one(a: .stringValue(\"1\"), b: .intValue(1))\n/// nil\nfunc compare_one(a:\
    \ Value, b: Value) -> Value? {\n    switch (a, b) {\n    case let (.intValue(l),\
    \ .intValue(r)):\n        return l > r ? a : b\n    case let (.intValue(l), .doubleValue(r)):\n\
    \        return l > r ? a : b\n    case let (.intValue(l), .stringValue(r)):\n\
    \        return l > (r as NSString).doubleValue ? a : b\n    case let (.doubleValue(l),\
    \ .intValue(r)):\n        return l > r ? a : b\n    case let (.doubleValue(l),\
    \ .doubleValue(r)):\n        return l > r ? a : b\n    case let (.doubleValue(l),\
    \ .stringValue(r)):\n        return l > (r as NSString).doubleValue ? a : b\n\
    \    case let (.stringValue(l), .intValue(r)):\n        return (l as NSString).doubleValue\
    \ > r ? a : b\n    case let (.stringValue(l), .doubleValue(r)):\n        return\
    \ (l as NSString).doubleValue > r ? a : b\n    case let (.stringValue(l), .stringValue(r)):\n\
    \        return (l as NSString).doubleValue > (r as NSString).doubleValue ? a\
    \ : b\n    }\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool\
    \ {\n    if left.count != right.count {\n        return false\n    }\n    for\
    \ (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(compare_one(a: .intValue(1),\
    \ b: .intValue(2)) == .intValue(2))\nassert(compare_one(a: .intValue(1), b: .doubleValue(2.5))\
    \ == .doubleValue(2.5))\nassert(compare_one(a: .intValue(2), b: .intValue(3))\
    \ == .intValue(3))\nassert(compare_one(a: .intValue(5), b: .intValue(6)) == .intValue(6))\n\
    assert(compare_one(a: .intValue(1), b: .stringValue(\"2,3\")) == .stringValue(\"\
    2,3\"))\nassert(compare_one(a: .stringValue(\"5,1\"), b: .stringValue(\"6\"))\
    \ == .stringValue(\"6\"))\nassert(compare_one(a: .stringValue(\"1\"), b: .stringValue(\"\
    2\")) == .stringValue(\"2\"))\nassert(compare_one(a: .stringValue(\"1\"), b: .intValue(1))\
    \ == nil)"
  status: SyntaxError
  stderr: "/tmp/tmpk8lvdgvs.swift:26:20: error: cannot convert value of type 'Double'\
    \ to expected argument type 'Int'\n        return l > r ? a : b\n            \
    \       ^\n                   Int( )\n/tmp/tmpk8lvdgvs.swift:28:26: error: cannot\
    \ find type 'NSString' in scope\n        return l > (r as NSString).doubleValue\
    \ ? a : b\n                         ^~~~~~~~\n/tmp/tmpk8lvdgvs.swift:28:36: error:\
    \ value of type 'String' has no member 'doubleValue'\n        return l > (r as\
    \ NSString).doubleValue ? a : b\n                   ~~~~~~~~~~~~~~~ ^~~~~~~~~~~\n\
    /tmp/tmpk8lvdgvs.swift:30:16: error: cannot convert value of type 'Double' to\
    \ expected argument type 'Int'\n        return l > r ? a : b\n               ^\n\
    \               Int( )\n/tmp/tmpk8lvdgvs.swift:34:26: error: cannot find type\
    \ 'NSString' in scope\n        return l > (r as NSString).doubleValue ? a : b\n\
    \                         ^~~~~~~~\n/tmp/tmpk8lvdgvs.swift:34:36: error: value\
    \ of type 'String' has no member 'doubleValue'\n        return l > (r as NSString).doubleValue\
    \ ? a : b\n                   ~~~~~~~~~~~~~~~ ^~~~~~~~~~~\n/tmp/tmpk8lvdgvs.swift:36:22:\
    \ error: cannot find type 'NSString' in scope\n        return (l as NSString).doubleValue\
    \ > r ? a : b\n                     ^~~~~~~~\n/tmp/tmpk8lvdgvs.swift:36:32: error:\
    \ value of type 'String' has no member 'doubleValue'\n        return (l as NSString).doubleValue\
    \ > r ? a : b\n               ~~~~~~~~~~~~~~~ ^~~~~~~~~~~\n/tmp/tmpk8lvdgvs.swift:38:22:\
    \ error: cannot find type 'NSString' in scope\n        return (l as NSString).doubleValue\
    \ > r ? a : b\n                     ^~~~~~~~\n/tmp/tmpk8lvdgvs.swift:38:32: error:\
    \ value of type 'String' has no member 'doubleValue'\n        return (l as NSString).doubleValue\
    \ > r ? a : b\n               ~~~~~~~~~~~~~~~ ^~~~~~~~~~~\n/tmp/tmpk8lvdgvs.swift:40:22:\
    \ error: cannot find type 'NSString' in scope\n        return (l as NSString).doubleValue\
    \ > (r as NSString).doubleValue ? a : b\n                     ^~~~~~~~\n/tmp/tmpk8lvdgvs.swift:40:52:\
    \ error: cannot find type 'NSString' in scope\n        return (l as NSString).doub"
  stdout: ''
  timestamp: 1660013180
- exit_code: 1
  program: "\nenum Value: Equatable, Hashable {\n    case intValue(Int)\n    case\
    \ doubleValue(Double)\n    case stringValue(String)\n}\n\n            \n/// Create\
    \ a function that takes integers, floats, or strings representing\n/// real numbers,\
    \ and returns the larger variable in its given variable type.\n/// Return nil\
    \ if the values are equal.\n/// Note: If a real number is represented as a string,\
    \ the floating point might be . or ,\n/// >>> compare_one(a: .intValue(1), b:\
    \ .doubleValue(2.5))\n/// .doubleValue(2.5)\n/// >>> compare_one(a: .intValue(1),\
    \ b: .stringValue(\"2,3\"))\n/// .stringValue(\"2,3\")\n/// >>> compare_one(a:\
    \ .stringValue(\"5,1\"), b: .stringValue(\"6\"))\n/// .stringValue(\"6\")\n///\
    \ >>> compare_one(a: .stringValue(\"1\"), b: .intValue(1))\n/// nil\nfunc compare_one(a:\
    \ Value, b: Value) -> Value? {\n    switch (a, b) {\n    case (.intValue(let a_int),\
    \ .intValue(let b_int)):\n        return a_int > b_int ? a : b\n    case (.intValue(let\
    \ a_int), .doubleValue(let b_double)):\n        return Double(a_int) > b_double\
    \ ? a : b\n    case (.intValue(let a_int), .stringValue(let b_string)):\n    \
    \    return Double(a_int) > b_string.replacingOccurrences(of: \",\", with: \"\
    .\")\n            .components(separatedBy: \".\")[0].components(separatedBy: \"\
    :\")[0].doubleValue ? a : b\n    case (.doubleValue(let a_double), .intValue(let\
    \ b_int)):\n        return a_double > Double(b_int) ? a : b\n    case (.doubleValue(let\
    \ a_double), .doubleValue(let b_double)):\n        return a_double > b_double\
    \ ? a : b\n    case (.doubleValue(let a_double), .stringValue(let b_string)):\n\
    \        return a_double > b_string.replacingOccurrences(of: \",\", with: \".\"\
    )\n            .components(separatedBy: \".\")[0].components(separatedBy: \":\"\
    )[0].doubleValue ? a : b\n    case (.stringValue(let a_string), .intValue(let\
    \ b_int)):\n        return a_string.replacingOccurrences(of: \",\", with: \".\"\
    )\n            .components(separatedBy: \".\")[0].components(separatedBy: \":\"\
    )[0].doubleValue > Double(b_int) ? a : b\n    case (.stringValue(let a_string),\
    \ .doubleValue(let b_double)):\n        return a_string.replacingOccurrences(of:\
    \ \",\", with: \".\")\n            .components(separatedBy: \".\")[0].components(separatedBy:\
    \ \":\")[0].doubleValue > b_double ? a : b\n    case (.stringValue(let a_string),\
    \ .stringValue(let b_\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(compare_one(a:\
    \ .intValue(1), b: .intValue(2)) == .intValue(2))\nassert(compare_one(a: .intValue(1),\
    \ b: .doubleValue(2.5)) == .doubleValue(2.5))\nassert(compare_one(a: .intValue(2),\
    \ b: .intValue(3)) == .intValue(3))\nassert(compare_one(a: .intValue(5), b: .intValue(6))\
    \ == .intValue(6))\nassert(compare_one(a: .intValue(1), b: .stringValue(\"2,3\"\
    )) == .stringValue(\"2,3\"))\nassert(compare_one(a: .stringValue(\"5,1\"), b:\
    \ .stringValue(\"6\")) == .stringValue(\"6\"))\nassert(compare_one(a: .stringValue(\"\
    1\"), b: .stringValue(\"2\")) == .stringValue(\"2\"))\nassert(compare_one(a: .stringValue(\"\
    1\"), b: .intValue(1)) == nil)"
  status: SyntaxError
  stderr: "/tmp/tmp3ki96ytv.swift:44:1: error: expected ')' in expression list\n}\n\
    ^\n/tmp/tmp3ki96ytv.swift:43:51: note: to match this opening '('\n    case (.stringValue(let\
    \ a_string), .stringValue(let b_\n                                           \
    \       ^\n/tmp/tmp3ki96ytv.swift:43:58: error: expected ':' after 'case'\n  \
    \  case (.stringValue(let a_string), .stringValue(let b_\n                   \
    \                                      ^\n/tmp/tmp3ki96ytv.swift:66:66: error:\
    \ expected '}' at end of brace statement\nassert(compare_one(a: .stringValue(\"\
    1\"), b: .intValue(1)) == nil)\n                                             \
    \                    ^\n/tmp/tmp3ki96ytv.swift:21:48: note: to match this opening\
    \ '{'\nfunc compare_one(a: Value, b: Value) -> Value? {\n                    \
    \                           ^\n/tmp/tmp3ki96ytv.swift:28:41: error: value of type\
    \ 'String' has no member 'replacingOccurrences'\n        return Double(a_int)\
    \ > b_string.replacingOccurrences(of: \",\", with: \".\")\n                  \
    \             ~~~~~~~~ ^~~~~~~~~~~~~~~~~~~~\n/tmp/tmp3ki96ytv.swift:35:36: error:\
    \ value of type 'String' has no member 'replacingOccurrences'\n        return\
    \ a_double > b_string.replacingOccurrences(of: \",\", with: \".\")\n         \
    \                 ~~~~~~~~ ^~~~~~~~~~~~~~~~~~~~\n/tmp/tmp3ki96ytv.swift:38:25:\
    \ error: value of type 'String' has no member 'replacingOccurrences'\n       \
    \ return a_string.replacingOccurrences(of: \",\", with: \".\")\n             \
    \  ~~~~~~~~ ^~~~~~~~~~~~~~~~~~~~\n/tmp/tmp3ki96ytv.swift:41:25: error: value of\
    \ type 'String' has no member 'replacingOccurrences'\n        return a_string.replacingOccurrences(of:\
    \ \",\", with: \".\")\n               ~~~~~~~~ ^~~~~~~~~~~~~~~~~~~~\n/tmp/tmp3ki96ytv.swift:47:6:\
    \ error: operator functions can only be declared at global or in type scope\n\
    func ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n     ^\n"
  stdout: ''
  timestamp: 1660013180
- exit_code: 1
  program: "\nenum Value: Equatable, Hashable {\n    case intValue(Int)\n    case\
    \ doubleValue(Double)\n    case stringValue(String)\n}\n\n            \n/// Create\
    \ a function that takes integers, floats, or strings representing\n/// real numbers,\
    \ and returns the larger variable in its given variable type.\n/// Return nil\
    \ if the values are equal.\n/// Note: If a real number is represented as a string,\
    \ the floating point might be . or ,\n/// >>> compare_one(a: .intValue(1), b:\
    \ .doubleValue(2.5))\n/// .doubleValue(2.5)\n/// >>> compare_one(a: .intValue(1),\
    \ b: .stringValue(\"2,3\"))\n/// .stringValue(\"2,3\")\n/// >>> compare_one(a:\
    \ .stringValue(\"5,1\"), b: .stringValue(\"6\"))\n/// .stringValue(\"6\")\n///\
    \ >>> compare_one(a: .stringValue(\"1\"), b: .intValue(1))\n/// nil\nfunc compare_one(a:\
    \ Value, b: Value) -> Value? {\n    var x: Double = 0\n    var y: Double = 0\n\
    \    switch a {\n    case .intValue(let i):\n        x = Double(i)\n    case .doubleValue(let\
    \ d):\n        x = d\n    case .stringValue(let s):\n        let replaceString\
    \ = s.replacingOccurrences(of: \",\", with: \".\")\n        x = Double(replaceString)!\n\
    \    }\n    switch b {\n    case .intValue(let i):\n        y = Double(i)\n  \
    \  case .doubleValue(let d):\n        y = d\n    case .stringValue(let s):\n \
    \       let replaceString = s.replacingOccurrences(of: \",\", with: \".\")\n \
    \       y = Double(replaceString)!\n    }\n    if x > y {\n        return a\n\
    \    } else if x < y {\n        return b\n    } else {\n        return nil\n \
    \   }\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n   \
    \ if left.count != right.count {\n        return false\n    }\n    for (l, r)\
    \ in zip(left, right) {\n        if l != r {\n            return false\n     \
    \   }\n    }\n    return true\n}\n            \nassert(compare_one(a: .intValue(1),\
    \ b: .intValue(2)) == .intValue(2))\nassert(compare_one(a: .intValue(1), b: .doubleValue(2.5))\
    \ == .doubleValue(2.5))\nassert(compare_one(a: .intValue(2), b: .intValue(3))\
    \ == .intValue(3))\nassert(compare_one(a: .intValue(5), b: .intValue(6)) == .intValue(6))\n\
    assert(compare_one(a: .intValue(1), b: .stringValue(\"2,3\")) == .stringValue(\"\
    2,3\"))\nassert(compare_one(a: .stringValue(\"5,1\"), b: .stringValue(\"6\"))\
    \ == .stringValue(\"6\"))\nassert(compare_one(a: .stringValue(\"1\"), b: .stringValue(\"\
    2\")) == .stringValue(\"2\"))\nassert(compare_one(a: .stringValue(\"1\"), b: .intValue(1))\
    \ == nil)"
  status: SyntaxError
  stderr: "/tmp/tmpo52itw3z.swift:30:31: error: value of type 'String' has no member\
    \ 'replacingOccurrences'\n        let replaceString = s.replacingOccurrences(of:\
    \ \",\", with: \".\")\n                            ~ ^~~~~~~~~~~~~~~~~~~~\n/tmp/tmpo52itw3z.swift:39:31:\
    \ error: value of type 'String' has no member 'replacingOccurrences'\n       \
    \ let replaceString = s.replacingOccurrences(of: \",\", with: \".\")\n       \
    \                     ~ ^~~~~~~~~~~~~~~~~~~~\n"
  stdout: ''
  timestamp: 1660013180
- exit_code: 1
  program: "\nenum Value: Equatable, Hashable {\n    case intValue(Int)\n    case\
    \ doubleValue(Double)\n    case stringValue(String)\n}\n\n            \n/// Create\
    \ a function that takes integers, floats, or strings representing\n/// real numbers,\
    \ and returns the larger variable in its given variable type.\n/// Return nil\
    \ if the values are equal.\n/// Note: If a real number is represented as a string,\
    \ the floating point might be . or ,\n/// >>> compare_one(a: .intValue(1), b:\
    \ .doubleValue(2.5))\n/// .doubleValue(2.5)\n/// >>> compare_one(a: .intValue(1),\
    \ b: .stringValue(\"2,3\"))\n/// .stringValue(\"2,3\")\n/// >>> compare_one(a:\
    \ .stringValue(\"5,1\"), b: .stringValue(\"6\"))\n/// .stringValue(\"6\")\n///\
    \ >>> compare_one(a: .stringValue(\"1\"), b: .intValue(1))\n/// nil\nfunc compare_one(a:\
    \ Value, b: Value) -> Value? {\n    switch (a, b) {\n    case let (.intValue(a),\
    \ .intValue(b)) where a > b:\n        return .intValue(a)\n    case let (.intValue(a),\
    \ .intValue(b)) where a < b:\n        return .intValue(b)\n    case let (.intValue(a),\
    \ .doubleValue(b)) where a > b:\n        return .intValue(a)\n    case let (.intValue(a),\
    \ .doubleValue(b)) where a < b:\n        return .doubleValue(b)\n    case let\
    \ (.intValue(a), .stringValue(b)) where a > Double(b)!:\n        return .intValue(a)\n\
    \    case let (.intValue(a), .stringValue(b)) where a < Double(b)!:\n        return\
    \ .stringValue(b)\n    case let (.doubleValue(a), .intValue(b)) where a > b:\n\
    \        return .doubleValue(a)\n    case let (.doubleValue(a), .intValue(b))\
    \ where a < b:\n        return .intValue(b)\n    case let (.doubleValue(a), .doubleValue(b))\
    \ where a > b:\n        return .doubleValue(a)\n    case let (.doubleValue(a),\
    \ .doubleValue(b)) where a < b:\n        return .doubleValue(b)\n    case let\
    \ (.doubleValue(a), .stringValue(b)) where a > Double(b)!:\n        return .doubleValue(a)\n\
    \    case let (.doubleValue(a), .stringValue(b)) where a < Double(b)!:\n     \
    \   return .stringValue(b)\n    case let (.stringValue(a), .intValue(b)) where\
    \ Double(a)! > b:\n        return .stringValue(a)\n    case let (.stringValue(a),\
    \ .intValue(b)) where Double(a)! < b:\n        return .intValue(b)\n    case let\
    \ (.stringValue(a), .doubleValue(b)) where Double(a)! > b:\n        return .stringValue(a)\n\
    \    case let (.stringValue(a), .doubleValue(b)) where Double(a)! < b:\n     \
    \   return .doubleValue(b\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(compare_one(a:\
    \ .intValue(1), b: .intValue(2)) == .intValue(2))\nassert(compare_one(a: .intValue(1),\
    \ b: .doubleValue(2.5)) == .doubleValue(2.5))\nassert(compare_one(a: .intValue(2),\
    \ b: .intValue(3)) == .intValue(3))\nassert(compare_one(a: .intValue(5), b: .intValue(6))\
    \ == .intValue(6))\nassert(compare_one(a: .intValue(1), b: .stringValue(\"2,3\"\
    )) == .stringValue(\"2,3\"))\nassert(compare_one(a: .stringValue(\"5,1\"), b:\
    \ .stringValue(\"6\")) == .stringValue(\"6\"))\nassert(compare_one(a: .stringValue(\"\
    1\"), b: .stringValue(\"2\")) == .stringValue(\"2\"))\nassert(compare_one(a: .stringValue(\"\
    1\"), b: .intValue(1)) == nil)"
  status: SyntaxError
  stderr: "/tmp/tmp_irifzod.swift:55:1: error: expected ')' in expression list\n}\n\
    ^\n/tmp/tmp_irifzod.swift:54:28: note: to match this opening '('\n        return\
    \ .doubleValue(b\n                           ^\n/tmp/tmp_irifzod.swift:77:66:\
    \ error: expected '}' at end of brace statement\nassert(compare_one(a: .stringValue(\"\
    1\"), b: .intValue(1)) == nil)\n                                             \
    \                    ^\n/tmp/tmp_irifzod.swift:21:48: note: to match this opening\
    \ '{'\nfunc compare_one(a: Value, b: Value) -> Value? {\n                    \
    \                           ^\n/tmp/tmp_irifzod.swift:27:54: error: binary operator\
    \ '>' cannot be applied to operands of type 'Int' and 'Double'\n    case let (.intValue(a),\
    \ .doubleValue(b)) where a > b:\n                                            \
    \       ~ ^ ~\n/tmp/tmp_irifzod.swift:27:54: note: overloads for '>' exist with\
    \ these partially matching parameter lists: (Int, Int)\n    case let (.intValue(a),\
    \ .doubleValue(b)) where a > b:\n                                            \
    \         ^\n/tmp/tmp_irifzod.swift:29:54: error: binary operator '<' cannot be\
    \ applied to operands of type 'Int' and 'Double'\n    case let (.intValue(a),\
    \ .doubleValue(b)) where a < b:\n                                            \
    \       ~ ^ ~\n/tmp/tmp_irifzod.swift:29:54: note: overloads for '<' exist with\
    \ these partially matching parameter lists: (Int, Int)\n    case let (.intValue(a),\
    \ .doubleValue(b)) where a < b:\n                                            \
    \         ^\n/tmp/tmp_irifzod.swift:31:65: error: cannot convert value of type\
    \ 'Double' to expected argument type 'Int'\n    case let (.intValue(a), .stringValue(b))\
    \ where a > Double(b)!:\n                                                    \
    \            ^\n                                                       Int(  \
    \    )\n/tmp/tmp_irifzod.swift:33:65: error: cannot convert value of type 'Double'\
    \ to expected argument type 'Int'\n    case let (.intValue(a), .stringValue(b))\
    \ where a < Double(b)!:\n                                                    \
    \            ^\n                   "
  stdout: ''
  timestamp: 1660013180
- exit_code: 1
  program: "\nenum Value: Equatable, Hashable {\n    case intValue(Int)\n    case\
    \ doubleValue(Double)\n    case stringValue(String)\n}\n\n            \n/// Create\
    \ a function that takes integers, floats, or strings representing\n/// real numbers,\
    \ and returns the larger variable in its given variable type.\n/// Return nil\
    \ if the values are equal.\n/// Note: If a real number is represented as a string,\
    \ the floating point might be . or ,\n/// >>> compare_one(a: .intValue(1), b:\
    \ .doubleValue(2.5))\n/// .doubleValue(2.5)\n/// >>> compare_one(a: .intValue(1),\
    \ b: .stringValue(\"2,3\"))\n/// .stringValue(\"2,3\")\n/// >>> compare_one(a:\
    \ .stringValue(\"5,1\"), b: .stringValue(\"6\"))\n/// .stringValue(\"6\")\n///\
    \ >>> compare_one(a: .stringValue(\"1\"), b: .intValue(1))\n/// nil\nfunc compare_one(a:\
    \ Value, b: Value) -> Value? {\n    // Get a and b as doubles\n    let (num1,\
    \ num2) = (a.asDouble(), b.asDouble())\n    \n    // If values are equal\n   \
    \ if num1 == num2 {\n        return nil\n    }\n    \n    // Return the larger\n\
    \    if num1 > num2 {\n        return a\n    } else {\n        return b\n    }\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(compare_one(a: .intValue(1), b: .intValue(2))\
    \ == .intValue(2))\nassert(compare_one(a: .intValue(1), b: .doubleValue(2.5))\
    \ == .doubleValue(2.5))\nassert(compare_one(a: .intValue(2), b: .intValue(3))\
    \ == .intValue(3))\nassert(compare_one(a: .intValue(5), b: .intValue(6)) == .intValue(6))\n\
    assert(compare_one(a: .intValue(1), b: .stringValue(\"2,3\")) == .stringValue(\"\
    2,3\"))\nassert(compare_one(a: .stringValue(\"5,1\"), b: .stringValue(\"6\"))\
    \ == .stringValue(\"6\"))\nassert(compare_one(a: .stringValue(\"1\"), b: .stringValue(\"\
    2\")) == .stringValue(\"2\"))\nassert(compare_one(a: .stringValue(\"1\"), b: .intValue(1))\
    \ == nil)"
  status: SyntaxError
  stderr: "/tmp/tmpg8eg75mp.swift:23:27: error: value of type 'Value' has no member\
    \ 'asDouble'\n    let (num1, num2) = (a.asDouble(), b.asDouble())\n          \
    \              ~ ^~~~~~~~\n/tmp/tmpg8eg75mp.swift:23:41: error: value of type\
    \ 'Value' has no member 'asDouble'\n    let (num1, num2) = (a.asDouble(), b.asDouble())\n\
    \                                      ~ ^~~~~~~~\n"
  stdout: ''
  timestamp: 1660013180
- exit_code: 1
  program: "\nenum Value: Equatable, Hashable {\n    case intValue(Int)\n    case\
    \ doubleValue(Double)\n    case stringValue(String)\n}\n\n            \n/// Create\
    \ a function that takes integers, floats, or strings representing\n/// real numbers,\
    \ and returns the larger variable in its given variable type.\n/// Return nil\
    \ if the values are equal.\n/// Note: If a real number is represented as a string,\
    \ the floating point might be . or ,\n/// >>> compare_one(a: .intValue(1), b:\
    \ .doubleValue(2.5))\n/// .doubleValue(2.5)\n/// >>> compare_one(a: .intValue(1),\
    \ b: .stringValue(\"2,3\"))\n/// .stringValue(\"2,3\")\n/// >>> compare_one(a:\
    \ .stringValue(\"5,1\"), b: .stringValue(\"6\"))\n/// .stringValue(\"6\")\n///\
    \ >>> compare_one(a: .stringValue(\"1\"), b: .intValue(1))\n/// nil\nfunc compare_one(a:\
    \ Value, b: Value) -> Value? {\n    let left = a\n    let right = b\n    switch(left,\
    \ right) {\n    case (.intValue(let lh), .intValue(let rh)):\n        return lh\
    \ > rh ? left : nil\n    case (.intValue(let lh), .doubleValue(let rh)):\n   \
    \     return lh > rh ? .doubleValue(Double(lh)) : nil\n    case (.intValue(let\
    \ lh), .stringValue(let rh)):\n        return Double(lh) > Double(rh) ? .stringValue(String(lh))\
    \ : nil\n    case (.doubleValue(let lh), .intValue(let rh)):\n        return lh\
    \ > Double(rh) ? left : nil\n    case (.doubleValue(let lh), .doubleValue(let\
    \ rh)):\n        return lh > rh ? left : nil\n    case (.doubleValue(let lh),\
    \ .stringValue(let rh)):\n        return lh > Double(rh) ? .stringValue(String(lh))\
    \ : nil\n    case (.stringValue(let lh), .intValue(let rh)):\n        return Double(lh)\
    \ > Double(rh) ? left : nil\n    case (.stringValue(let lh), .doubleValue(let\
    \ rh)):\n        return Double(lh) > rh ? .doubleValue(Double(lh)) : nil\n   \
    \ case (.stringValue(let lh), .stringValue(let rh)):\n        return Double(lh)\
    \ > Double(rh) ? left : nil\n    }\n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(compare_one(a: .intValue(1), b: .intValue(2)) == .intValue(2))\nassert(compare_one(a:\
    \ .intValue(1), b: .doubleValue(2.5)) == .doubleValue(2.5))\nassert(compare_one(a:\
    \ .intValue(2), b: .intValue(3)) == .intValue(3))\nassert(compare_one(a: .intValue(5),\
    \ b: .intValue(6)) == .intValue(6))\nassert(compare_one(a: .intValue(1), b: .stringValue(\"\
    2,3\")) == .stringValue(\"2,3\"))\nassert(compare_one(a: .stringValue(\"5,1\"\
    ), b: .stringValue(\"6\")) == .stringValue(\"6\"))\nassert(compare_one(a: .stringValue(\"\
    1\"), b: .stringValue(\"2\")) == .stringValue(\"2\"))\nassert(compare_one(a: .stringValue(\"\
    1\"), b: .intValue(1)) == nil)"
  status: SyntaxError
  stderr: "/tmp/tmpvviu_j7p.swift:28:21: error: cannot convert value of type 'Double'\
    \ to expected argument type 'Int'\n        return lh > rh ? .doubleValue(Double(lh))\
    \ : nil\n                    ^\n                    Int( )\n/tmp/tmpvviu_j7p.swift:30:29:\
    \ error: value of optional type 'Double?' must be unwrapped to a value of type\
    \ 'Double'\n        return Double(lh) > Double(rh) ? .stringValue(String(lh))\
    \ : nil\n                            ^\n/tmp/tmpvviu_j7p.swift:30:29: note: coalesce\
    \ using '??' to provide a default when the optional value contains 'nil'\n   \
    \     return Double(lh) > Double(rh) ? .stringValue(String(lh)) : nil\n      \
    \                      ^\n                                       ?? <#default\
    \ value#>\n/tmp/tmpvviu_j7p.swift:30:29: note: force-unwrap using '!' to abort\
    \ execution if the optional value contains 'nil'\n        return Double(lh) >\
    \ Double(rh) ? .stringValue(String(lh)) : nil\n                            ^\n\
    \                                      !\n/tmp/tmpvviu_j7p.swift:36:21: error:\
    \ value of optional type 'Double?' must be unwrapped to a value of type 'Double'\n\
    \        return lh > Double(rh) ? .stringValue(String(lh)) : nil\n           \
    \         ^\n/tmp/tmpvviu_j7p.swift:36:21: note: coalesce using '??' to provide\
    \ a default when the optional value contains 'nil'\n        return lh > Double(rh)\
    \ ? .stringValue(String(lh)) : nil\n                    ^\n                  \
    \             ?? <#default value#>\n/tmp/tmpvviu_j7p.swift:36:21: note: force-unwrap\
    \ using '!' to abort execution if the optional value contains 'nil'\n        return\
    \ lh > Double(rh) ? .stringValue(String(lh)) : nil\n                    ^\n  \
    \                            !\n/tmp/tmpvviu_j7p.swift:38:16: error: value of\
    \ optional type 'Double?' must be unwrapped to a value of type 'Double'\n    \
    \    return Double(lh) > Double(rh) ? left : nil\n               ^\n/tmp/tmpvviu_j7p.swift:38:16:\
    \ note: coalesce using '??' to provide a default when the optional value contains\
    \ 'nil'\n        return Double(lh) > Double(rh) ? left : nil\n               ^\n\
    \                        "
  stdout: ''
  timestamp: 1660013181
- exit_code: -4
  program: "\nenum Value: Equatable, Hashable {\n    case intValue(Int)\n    case\
    \ doubleValue(Double)\n    case stringValue(String)\n}\n\n            \n/// Create\
    \ a function that takes integers, floats, or strings representing\n/// real numbers,\
    \ and returns the larger variable in its given variable type.\n/// Return nil\
    \ if the values are equal.\n/// Note: If a real number is represented as a string,\
    \ the floating point might be . or ,\n/// >>> compare_one(a: .intValue(1), b:\
    \ .doubleValue(2.5))\n/// .doubleValue(2.5)\n/// >>> compare_one(a: .intValue(1),\
    \ b: .stringValue(\"2,3\"))\n/// .stringValue(\"2,3\")\n/// >>> compare_one(a:\
    \ .stringValue(\"5,1\"), b: .stringValue(\"6\"))\n/// .stringValue(\"6\")\n///\
    \ >>> compare_one(a: .stringValue(\"1\"), b: .intValue(1))\n/// nil\nfunc compare_one(a:\
    \ Value, b: Value) -> Value? {\n    // TODO: Write some code to solve this coding\
    \ challenge\n    return nil\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int,\
    \ Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n\
    \    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n          \
    \  return false\n        }\n    }\n    return true\n}\n            \nassert(compare_one(a:\
    \ .intValue(1), b: .intValue(2)) == .intValue(2))\nassert(compare_one(a: .intValue(1),\
    \ b: .doubleValue(2.5)) == .doubleValue(2.5))\nassert(compare_one(a: .intValue(2),\
    \ b: .intValue(3)) == .intValue(3))\nassert(compare_one(a: .intValue(5), b: .intValue(6))\
    \ == .intValue(6))\nassert(compare_one(a: .intValue(1), b: .stringValue(\"2,3\"\
    )) == .stringValue(\"2,3\"))\nassert(compare_one(a: .stringValue(\"5,1\"), b:\
    \ .stringValue(\"6\")) == .stringValue(\"6\"))\nassert(compare_one(a: .stringValue(\"\
    1\"), b: .stringValue(\"2\")) == .stringValue(\"2\"))\nassert(compare_one(a: .stringValue(\"\
    1\"), b: .intValue(1)) == nil)"
  status: Exception
  stderr: 'tmpo1hngg84/tmpo1hngg84.swift:39: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002af17ff61c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002af17fc58b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002af17fc58988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002af17fc577b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpo1hngg84                        0x00005621d60b5a56 <unavailable> + 6742

    5    libc.so.6                          0x00002af18014d460 __libc_start_main +
    245

    6    tmpo1hngg84                        0x00005621d60b5499 <unavailable> + 5273

    '
  stdout: ''
  timestamp: 1660013180
- exit_code: 1
  program: "\nenum Value: Equatable, Hashable {\n    case intValue(Int)\n    case\
    \ doubleValue(Double)\n    case stringValue(String)\n}\n\n            \n/// Create\
    \ a function that takes integers, floats, or strings representing\n/// real numbers,\
    \ and returns the larger variable in its given variable type.\n/// Return nil\
    \ if the values are equal.\n/// Note: If a real number is represented as a string,\
    \ the floating point might be . or ,\n/// >>> compare_one(a: .intValue(1), b:\
    \ .doubleValue(2.5))\n/// .doubleValue(2.5)\n/// >>> compare_one(a: .intValue(1),\
    \ b: .stringValue(\"2,3\"))\n/// .stringValue(\"2,3\")\n/// >>> compare_one(a:\
    \ .stringValue(\"5,1\"), b: .stringValue(\"6\"))\n/// .stringValue(\"6\")\n///\
    \ >>> compare_one(a: .stringValue(\"1\"), b: .intValue(1))\n/// nil\nfunc compare_one(a:\
    \ Value, b: Value) -> Value? {\n    switch (a, b) {\n    case (.intValue(let l),\
    \ .intValue(let r)):\n        return l > r ? a : nil\n    case (.intValue(let\
    \ l), .doubleValue(let r)):\n        return l > r ? a : nil\n    case (.intValue(let\
    \ l), .stringValue(let r)):\n        return l > Int(r) ?? 0 ? a : nil\n    case\
    \ (.doubleValue(let l), .intValue(let r)):\n        return l > r ? a : nil\n \
    \   case (.doubleValue(let l), .doubleValue(let r)):\n        return l > r ? a\
    \ : nil\n    case (.doubleValue(let l), .stringValue(let r)):\n        return\
    \ l > Double(r) ?? 0 ? a : nil\n    case (.stringValue(let l), .intValue(let r)):\n\
    \        return Int(l) ?? 0 > r ? a : nil\n    case (.stringValue(let l), .doubleValue(let\
    \ r)):\n        return Double(l) ?? 0 > r ? a : nil\n    case (.stringValue(let\
    \ l), .stringValue(let r)):\n        return Int(l) ?? 0 > Int(r) ?? 0 ? a : nil\n\
    \    }\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n  \
    \  if left.count != right.count {\n        return false\n    }\n    for (l, r)\
    \ in zip(left, right) {\n        if l != r {\n            return false\n     \
    \   }\n    }\n    return true\n}\n            \nassert(compare_one(a: .intValue(1),\
    \ b: .intValue(2)) == .intValue(2))\nassert(compare_one(a: .intValue(1), b: .doubleValue(2.5))\
    \ == .doubleValue(2.5))\nassert(compare_one(a: .intValue(2), b: .intValue(3))\
    \ == .intValue(3))\nassert(compare_one(a: .intValue(5), b: .intValue(6)) == .intValue(6))\n\
    assert(compare_one(a: .intValue(1), b: .stringValue(\"2,3\")) == .stringValue(\"\
    2,3\"))\nassert(compare_one(a: .stringValue(\"5,1\"), b: .stringValue(\"6\"))\
    \ == .stringValue(\"6\"))\nassert(compare_one(a: .stringValue(\"1\"), b: .stringValue(\"\
    2\")) == .stringValue(\"2\"))\nassert(compare_one(a: .stringValue(\"1\"), b: .intValue(1))\
    \ == nil)"
  status: SyntaxError
  stderr: "/tmp/tmp81pbpnib.swift:26:20: error: cannot convert value of type 'Double'\
    \ to expected argument type 'Int'\n        return l > r ? a : nil\n          \
    \         ^\n                   Int( )\n/tmp/tmp81pbpnib.swift:30:16: error: cannot\
    \ convert value of type 'Double' to expected argument type 'Int'\n        return\
    \ l > r ? a : nil\n               ^\n               Int( )\n"
  stdout: ''
  timestamp: 1660013181
- exit_code: -4
  program: "\nenum Value: Equatable, Hashable {\n    case intValue(Int)\n    case\
    \ doubleValue(Double)\n    case stringValue(String)\n}\n\n            \n/// Create\
    \ a function that takes integers, floats, or strings representing\n/// real numbers,\
    \ and returns the larger variable in its given variable type.\n/// Return nil\
    \ if the values are equal.\n/// Note: If a real number is represented as a string,\
    \ the floating point might be . or ,\n/// >>> compare_one(a: .intValue(1), b:\
    \ .doubleValue(2.5))\n/// .doubleValue(2.5)\n/// >>> compare_one(a: .intValue(1),\
    \ b: .stringValue(\"2,3\"))\n/// .stringValue(\"2,3\")\n/// >>> compare_one(a:\
    \ .stringValue(\"5,1\"), b: .stringValue(\"6\"))\n/// .stringValue(\"6\")\n///\
    \ >>> compare_one(a: .stringValue(\"1\"), b: .intValue(1))\n/// nil\nfunc compare_one(a:\
    \ Value, b: Value) -> Value? {\n    return nil\n}\n\n\nfunc ==(left: [(Int, Int)],\
    \ right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n       \
    \ return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r\
    \ {\n            return false\n        }\n    }\n    return true\n}\n        \
    \    \nassert(compare_one(a: .intValue(1), b: .intValue(2)) == .intValue(2))\n\
    assert(compare_one(a: .intValue(1), b: .doubleValue(2.5)) == .doubleValue(2.5))\n\
    assert(compare_one(a: .intValue(2), b: .intValue(3)) == .intValue(3))\nassert(compare_one(a:\
    \ .intValue(5), b: .intValue(6)) == .intValue(6))\nassert(compare_one(a: .intValue(1),\
    \ b: .stringValue(\"2,3\")) == .stringValue(\"2,3\"))\nassert(compare_one(a: .stringValue(\"\
    5,1\"), b: .stringValue(\"6\")) == .stringValue(\"6\"))\nassert(compare_one(a:\
    \ .stringValue(\"1\"), b: .stringValue(\"2\")) == .stringValue(\"2\"))\nassert(compare_one(a:\
    \ .stringValue(\"1\"), b: .intValue(1)) == nil)"
  status: Exception
  stderr: 'tmpllswmh2d/tmpllswmh2d.swift:38: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b05c2ae8c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b05c27dfb6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b05c27df988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b05c27de7b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpllswmh2d                        0x000055f806e32a56 <unavailable> + 6742

    5    libc.so.6                          0x00002b05c2cd4460 __libc_start_main +
    245

    6    tmpllswmh2d                        0x000055f806e32499 <unavailable> + 5273

    '
  stdout: ''
  timestamp: 1660013179
- exit_code: 1
  program: "\nenum Value: Equatable, Hashable {\n    case intValue(Int)\n    case\
    \ doubleValue(Double)\n    case stringValue(String)\n}\n\n            \n/// Create\
    \ a function that takes integers, floats, or strings representing\n/// real numbers,\
    \ and returns the larger variable in its given variable type.\n/// Return nil\
    \ if the values are equal.\n/// Note: If a real number is represented as a string,\
    \ the floating point might be . or ,\n/// >>> compare_one(a: .intValue(1), b:\
    \ .doubleValue(2.5))\n/// .doubleValue(2.5)\n/// >>> compare_one(a: .intValue(1),\
    \ b: .stringValue(\"2,3\"))\n/// .stringValue(\"2,3\")\n/// >>> compare_one(a:\
    \ .stringValue(\"5,1\"), b: .stringValue(\"6\"))\n/// .stringValue(\"6\")\n///\
    \ >>> compare_one(a: .stringValue(\"1\"), b: .intValue(1))\n/// nil\nfunc compare_one(a:\
    \ Value, b: Value) -> Value? {\n    switch (a, b) {\n    case (.intValue(let aInt),\
    \ .intValue(let bInt)):\n        return aInt > bInt ? a : bInt > aInt ? b : nil\n\
    \    case (.intValue(let aInt), .doubleValue(let bDouble)):\n        return .doubleValue(Double(aInt)\
    \ > bDouble ? Double(aInt) : bDouble)\n    case (.intValue(let aInt), .stringValue(let\
    \ bString)):\n        return .stringValue(Double(aInt) > Double(bString) ? String(aInt)\
    \ : bString)\n    case (.doubleValue(let aDouble), .intValue(let bInt)):\n   \
    \     return .doubleValue(aDouble > Double(bInt) ? aDouble : Double(bInt))\n \
    \   case (.doubleValue(let aDouble), .doubleValue(let bDouble)):\n        return\
    \ aDouble > bDouble ? a : bDouble > aDouble ? b : nil\n    case (.doubleValue(let\
    \ aDouble), .stringValue(let bString)):\n        return .stringValue(aDouble >\
    \ Double(bString) ? String(aDouble) : bString)\n    case (.stringValue(let aString),\
    \ .intValue(let bInt)):\n        return .stringValue(Double(aString) > Double(bInt)\
    \ ? aString : String(bInt))\n    case (.stringValue(let aString), .doubleValue(let\
    \ bDouble)):\n        return .stringValue(Double(aString) > bDouble ? aString\
    \ : String(bDouble))\n    case (.stringValue(let aString), .stringValue(let bString)):\n\
    \        return Double(aString) > Double(bString) ? a : Double(bString) > Double(aString)\
    \ ? b : nil\n    }\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) ->\
    \ Bool {\n    if left.count != right.count {\n        return false\n    }\n  \
    \  for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(compare_one(a: .intValue(1),\
    \ b: .intValue(2)) == .intValue(2))\nassert(compare_one(a: .intValue(1), b: .doubleValue(2.5))\
    \ == .doubleValue(2.5))\nassert(compare_one(a: .intValue(2), b: .intValue(3))\
    \ == .intValue(3))\nassert(compare_one(a: .intValue(5), b: .intValue(6)) == .intValue(6))\n\
    assert(compare_one(a: .intValue(1), b: .stringValue(\"2,3\")) == .stringValue(\"\
    2,3\"))\nassert(compare_one(a: .stringValue(\"5,1\"), b: .stringValue(\"6\"))\
    \ == .stringValue(\"6\"))\nassert(compare_one(a: .stringValue(\"1\"), b: .stringValue(\"\
    2\")) == .stringValue(\"2\"))\nassert(compare_one(a: .stringValue(\"1\"), b: .intValue(1))\
    \ == nil)"
  status: SyntaxError
  stderr: "/tmp/tmplvnyzu16.swift:28:44: error: value of optional type 'Double?' must\
    \ be unwrapped to a value of type 'Double'\n        return .stringValue(Double(aInt)\
    \ > Double(bString) ? String(aInt) : bString)\n                              \
    \             ^\n/tmp/tmplvnyzu16.swift:28:44: note: coalesce using '??' to provide\
    \ a default when the optional value contains 'nil'\n        return .stringValue(Double(aInt)\
    \ > Double(bString) ? String(aInt) : bString)\n                              \
    \             ^\n                                                           ??\
    \ <#default value#>\n/tmp/tmplvnyzu16.swift:28:44: note: force-unwrap using '!'\
    \ to abort execution if the optional value contains 'nil'\n        return .stringValue(Double(aInt)\
    \ > Double(bString) ? String(aInt) : bString)\n                              \
    \             ^\n                                                          !\n\
    /tmp/tmplvnyzu16.swift:34:39: error: value of optional type 'Double?' must be\
    \ unwrapped to a value of type 'Double'\n        return .stringValue(aDouble >\
    \ Double(bString) ? String(aDouble) : bString)\n                             \
    \         ^\n/tmp/tmplvnyzu16.swift:34:39: note: coalesce using '??' to provide\
    \ a default when the optional value contains 'nil'\n        return .stringValue(aDouble\
    \ > Double(bString) ? String(aDouble) : bString)\n                           \
    \           ^\n                                                      ?? <#default\
    \ value#>\n/tmp/tmplvnyzu16.swift:34:39: note: force-unwrap using '!' to abort\
    \ execution if the optional value contains 'nil'\n        return .stringValue(aDouble\
    \ > Double(bString) ? String(aDouble) : bString)\n                           \
    \           ^\n                                                     !\n/tmp/tmplvnyzu16.swift:36:29:\
    \ error: value of optional type 'Double?' must be unwrapped to a value of type\
    \ 'Double'\n        return .stringValue(Double(aString) > Double(bInt) ? aString\
    \ : String(bInt))\n                            ^\n/tmp/tmplvnyzu16.swift:36:29:\
    \ note: coalesce using '??' to provide a default when the optional"
  stdout: ''
  timestamp: 1660013181
- exit_code: -4
  program: "\nenum Value: Equatable, Hashable {\n    case intValue(Int)\n    case\
    \ doubleValue(Double)\n    case stringValue(String)\n}\n\n            \n/// Create\
    \ a function that takes integers, floats, or strings representing\n/// real numbers,\
    \ and returns the larger variable in its given variable type.\n/// Return nil\
    \ if the values are equal.\n/// Note: If a real number is represented as a string,\
    \ the floating point might be . or ,\n/// >>> compare_one(a: .intValue(1), b:\
    \ .doubleValue(2.5))\n/// .doubleValue(2.5)\n/// >>> compare_one(a: .intValue(1),\
    \ b: .stringValue(\"2,3\"))\n/// .stringValue(\"2,3\")\n/// >>> compare_one(a:\
    \ .stringValue(\"5,1\"), b: .stringValue(\"6\"))\n/// .stringValue(\"6\")\n///\
    \ >>> compare_one(a: .stringValue(\"1\"), b: .intValue(1))\n/// nil\nfunc compare_one(a:\
    \ Value, b: Value) -> Value? {\n    var result: Value?\n    switch a {\n    case\
    \ .intValue(let aInt):\n        switch b {\n        case .intValue(let bInt):\n\
    \            result = nil\n        case .doubleValue(let bDouble):\n         \
    \   result = .doubleValue(bDouble)\n        case .stringValue(let bString):\n\
    \            result = .stringValue(bString)\n        }\n    case .doubleValue(let\
    \ aDouble):\n        switch b {\n        case .intValue(let bInt):\n         \
    \   result = .doubleValue(aDouble)\n        case .doubleValue(let bDouble):\n\
    \            result = .doubleValue(max(aDouble, bDouble))\n        case .stringValue(let\
    \ bString):\n            result = .stringValue(bString)\n        }\n    case .stringValue(let\
    \ aString):\n        switch b {\n        case .intValue(let bInt):\n         \
    \   result = .stringValue(aString)\n        case .doubleValue(let bDouble):\n\
    \            result = .stringValue(aString)\n        case .stringValue(let bString):\n\
    \            result = .stringValue(max(aString, bString))\n        }\n    }\n\
    \    return result\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) ->\
    \ Bool {\n    if left.count != right.count {\n        return false\n    }\n  \
    \  for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(compare_one(a: .intValue(1),\
    \ b: .intValue(2)) == .intValue(2))\nassert(compare_one(a: .intValue(1), b: .doubleValue(2.5))\
    \ == .doubleValue(2.5))\nassert(compare_one(a: .intValue(2), b: .intValue(3))\
    \ == .intValue(3))\nassert(compare_one(a: .intValue(5), b: .intValue(6)) == .intValue(6))\n\
    assert(compare_one(a: .intValue(1), b: .stringValue(\"2,3\")) == .stringValue(\"\
    2,3\"))\nassert(compare_one(a: .stringValue(\"5,1\"), b: .stringValue(\"6\"))\
    \ == .stringValue(\"6\"))\nassert(compare_one(a: .stringValue(\"1\"), b: .stringValue(\"\
    2\")) == .stringValue(\"2\"))\nassert(compare_one(a: .stringValue(\"1\"), b: .intValue(1))\
    \ == nil)"
  status: Exception
  stderr: 'tmpmc5fe863/tmpmc5fe863.swift:68: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b1972e31c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b1972b28b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b1972b28988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b1972b277b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpmc5fe863                        0x0000560362329b26 <unavailable> + 6950

    5    libc.so.6                          0x00002b197301d460 __libc_start_main +
    245

    6    tmpmc5fe863                        0x0000560362329569 <unavailable> + 5481

    '
  stdout: ''
  timestamp: 1660013181
- exit_code: 1
  program: "\nenum Value: Equatable, Hashable {\n    case intValue(Int)\n    case\
    \ doubleValue(Double)\n    case stringValue(String)\n}\n\n            \n/// Create\
    \ a function that takes integers, floats, or strings representing\n/// real numbers,\
    \ and returns the larger variable in its given variable type.\n/// Return nil\
    \ if the values are equal.\n/// Note: If a real number is represented as a string,\
    \ the floating point might be . or ,\n/// >>> compare_one(a: .intValue(1), b:\
    \ .doubleValue(2.5))\n/// .doubleValue(2.5)\n/// >>> compare_one(a: .intValue(1),\
    \ b: .stringValue(\"2,3\"))\n/// .stringValue(\"2,3\")\n/// >>> compare_one(a:\
    \ .stringValue(\"5,1\"), b: .stringValue(\"6\"))\n/// .stringValue(\"6\")\n///\
    \ >>> compare_one(a: .stringValue(\"1\"), b: .intValue(1))\n/// nil\nfunc compare_one(a:\
    \ Value, b: Value) -> Value? {\n    let first: Double\n    let second: Double\n\
    \    if case .doubleValue(let d1) = a {\n        first = d1\n    } else if case\
    \ .intValue(let i1) = a {\n        first = Double(i1)\n    } else if case .stringValue(let\
    \ s1) = a {\n        if let stringToInt = Int(s1.replacingOccurrences(of: \",\"\
    , with: \".\")) {\n            first = Double(stringToInt)\n        } else {\n\
    \            first = Double(s1) ?? 0\n        }\n    } else {\n        return\
    \ nil\n    }\n    if case .doubleValue(let d2) = b {\n        second = d2\n  \
    \  } else if case .intValue(let i2) = b {\n        second = Double(i2)\n    }\
    \ else if case .stringValue(let s2) = b {\n        if let stringToInt = Int(s2.replacingOccurrences(of:\
    \ \",\", with: \".\")) {\n            second = Double(stringToInt)\n        }\
    \ else {\n            second = Double(s2) ?? 0\n        }\n    } else {\n    \
    \    return nil\n    }\n    if first == second {\n        return nil\n    } else\
    \ if first > second {\n        return a\n    } else {\n        return b\n    }\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(compare_one(a: .intValue(1), b: .intValue(2))\
    \ == .intValue(2))\nassert(compare_one(a: .intValue(1), b: .doubleValue(2.5))\
    \ == .doubleValue(2.5))\nassert(compare_one(a: .intValue(2), b: .intValue(3))\
    \ == .intValue(3))\nassert(compare_one(a: .intValue(5), b: .intValue(6)) == .intValue(6))\n\
    assert(compare_one(a: .intValue(1), b: .stringValue(\"2,3\")) == .stringValue(\"\
    2,3\"))\nassert(compare_one(a: .stringValue(\"5,1\"), b: .stringValue(\"6\"))\
    \ == .stringValue(\"6\"))\nassert(compare_one(a: .stringValue(\"1\"), b: .stringValue(\"\
    2\")) == .stringValue(\"2\"))\nassert(compare_one(a: .stringValue(\"1\"), b: .intValue(1))\
    \ == nil)"
  status: SyntaxError
  stderr: "/tmp/tmpmbl8cq1u.swift:29:37: error: value of type 'String' has no member\
    \ 'replacingOccurrences'\n        if let stringToInt = Int(s1.replacingOccurrences(of:\
    \ \",\", with: \".\")) {\n                                 ~~ ^~~~~~~~~~~~~~~~~~~~\n\
    /tmp/tmpmbl8cq1u.swift:42:37: error: value of type 'String' has no member 'replacingOccurrences'\n\
    \        if let stringToInt = Int(s2.replacingOccurrences(of: \",\", with: \"\
    .\")) {\n                                 ~~ ^~~~~~~~~~~~~~~~~~~~\n"
  stdout: ''
  timestamp: 1660013181
- exit_code: -4
  program: "\nenum Value: Equatable, Hashable {\n    case intValue(Int)\n    case\
    \ doubleValue(Double)\n    case stringValue(String)\n}\n\n            \n/// Create\
    \ a function that takes integers, floats, or strings representing\n/// real numbers,\
    \ and returns the larger variable in its given variable type.\n/// Return nil\
    \ if the values are equal.\n/// Note: If a real number is represented as a string,\
    \ the floating point might be . or ,\n/// >>> compare_one(a: .intValue(1), b:\
    \ .doubleValue(2.5))\n/// .doubleValue(2.5)\n/// >>> compare_one(a: .intValue(1),\
    \ b: .stringValue(\"2,3\"))\n/// .stringValue(\"2,3\")\n/// >>> compare_one(a:\
    \ .stringValue(\"5,1\"), b: .stringValue(\"6\"))\n/// .stringValue(\"6\")\n///\
    \ >>> compare_one(a: .stringValue(\"1\"), b: .intValue(1))\n/// nil\nfunc compare_one(a:\
    \ Value, b: Value) -> Value? {\n    return nil\n}\n\n\nfunc ==(left: [(Int, Int)],\
    \ right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n       \
    \ return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r\
    \ {\n            return false\n        }\n    }\n    return true\n}\n        \
    \    \nassert(compare_one(a: .intValue(1), b: .intValue(2)) == .intValue(2))\n\
    assert(compare_one(a: .intValue(1), b: .doubleValue(2.5)) == .doubleValue(2.5))\n\
    assert(compare_one(a: .intValue(2), b: .intValue(3)) == .intValue(3))\nassert(compare_one(a:\
    \ .intValue(5), b: .intValue(6)) == .intValue(6))\nassert(compare_one(a: .intValue(1),\
    \ b: .stringValue(\"2,3\")) == .stringValue(\"2,3\"))\nassert(compare_one(a: .stringValue(\"\
    5,1\"), b: .stringValue(\"6\")) == .stringValue(\"6\"))\nassert(compare_one(a:\
    \ .stringValue(\"1\"), b: .stringValue(\"2\")) == .stringValue(\"2\"))\nassert(compare_one(a:\
    \ .stringValue(\"1\"), b: .intValue(1)) == nil)"
  status: Exception
  stderr: 'tmpllswmh2d/tmpllswmh2d.swift:38: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b05c2ae8c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b05c27dfb6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b05c27df988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b05c27de7b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpllswmh2d                        0x000055f806e32a56 <unavailable> + 6742

    5    libc.so.6                          0x00002b05c2cd4460 __libc_start_main +
    245

    6    tmpllswmh2d                        0x000055f806e32499 <unavailable> + 5273

    '
  stdout: ''
  timestamp: 1660013179
- exit_code: 1
  program: "\nenum Value: Equatable, Hashable {\n    case intValue(Int)\n    case\
    \ doubleValue(Double)\n    case stringValue(String)\n}\n\n            \n/// Create\
    \ a function that takes integers, floats, or strings representing\n/// real numbers,\
    \ and returns the larger variable in its given variable type.\n/// Return nil\
    \ if the values are equal.\n/// Note: If a real number is represented as a string,\
    \ the floating point might be . or ,\n/// >>> compare_one(a: .intValue(1), b:\
    \ .doubleValue(2.5))\n/// .doubleValue(2.5)\n/// >>> compare_one(a: .intValue(1),\
    \ b: .stringValue(\"2,3\"))\n/// .stringValue(\"2,3\")\n/// >>> compare_one(a:\
    \ .stringValue(\"5,1\"), b: .stringValue(\"6\"))\n/// .stringValue(\"6\")\n///\
    \ >>> compare_one(a: .stringValue(\"1\"), b: .intValue(1))\n/// nil\nfunc compare_one(a:\
    \ Value, b: Value) -> Value? {\n  switch (a, b) {\n  case (.intValue(let a), .intValue(let\
    \ b)):\n    return a < b ? b : nil\n  case (.intValue(let a), .doubleValue(let\
    \ b)):\n    return a < b ? b : nil\n  case (.intValue(let a), .stringValue(let\
    \ b)):\n    return Double(a) < Double(b) ? b : nil\n  case (.doubleValue(let a),\
    \ .intValue(let b)):\n    return a < b ? a : nil\n  case (.doubleValue(let a),\
    \ .doubleValue(let b)):\n    return a < b ? b : nil\n  case (.doubleValue(let\
    \ a), .stringValue(let b)):\n    return a < Double(b) ? b : nil\n  case (.stringValue(let\
    \ a), .intValue(let b)):\n    return Double(a) < b ? a : nil\n  case (.stringValue(let\
    \ a), .doubleValue(let b)):\n    return Double(a) < b ? a : nil\n  case (.stringValue(let\
    \ a), .stringValue(let b)):\n    return Double(a) < Double(b) ? b : nil\n  }\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(compare_one(a: .intValue(1), b: .intValue(2))\
    \ == .intValue(2))\nassert(compare_one(a: .intValue(1), b: .doubleValue(2.5))\
    \ == .doubleValue(2.5))\nassert(compare_one(a: .intValue(2), b: .intValue(3))\
    \ == .intValue(3))\nassert(compare_one(a: .intValue(5), b: .intValue(6)) == .intValue(6))\n\
    assert(compare_one(a: .intValue(1), b: .stringValue(\"2,3\")) == .stringValue(\"\
    2,3\"))\nassert(compare_one(a: .stringValue(\"5,1\"), b: .stringValue(\"6\"))\
    \ == .stringValue(\"6\"))\nassert(compare_one(a: .stringValue(\"1\"), b: .stringValue(\"\
    2\")) == .stringValue(\"2\"))\nassert(compare_one(a: .stringValue(\"1\"), b: .intValue(1))\
    \ == nil)"
  status: SyntaxError
  stderr: "/tmp/tmp5jss_0_l.swift:24:18: error: cannot convert return expression of\
    \ type 'Int' to return type 'Value?'\n    return a < b ? b : nil\n           ~~~~~~^~~~~~~~~\n\
    /tmp/tmp5jss_0_l.swift:26:16: error: cannot convert value of type 'Double' to\
    \ expected argument type 'Int'\n    return a < b ? b : nil\n               ^\n\
    \               Int( )\n/tmp/tmp5jss_0_l.swift:26:18: error: cannot convert return\
    \ expression of type 'Double' to return type 'Value?'\n    return a < b ? b :\
    \ nil\n           ~~~~~~^~~~~~~~~\n/tmp/tmp5jss_0_l.swift:28:24: error: value\
    \ of optional type 'Double?' must be unwrapped to a value of type 'Double'\n \
    \   return Double(a) < Double(b) ? b : nil\n                       ^\n/tmp/tmp5jss_0_l.swift:28:24:\
    \ note: coalesce using '??' to provide a default when the optional value contains\
    \ 'nil'\n    return Double(a) < Double(b) ? b : nil\n                       ^\n\
    \                                 ?? <#default value#>\n/tmp/tmp5jss_0_l.swift:28:24:\
    \ note: force-unwrap using '!' to abort execution if the optional value contains\
    \ 'nil'\n    return Double(a) < Double(b) ? b : nil\n                       ^\n\
    \                                !\n/tmp/tmp5jss_0_l.swift:28:34: error: cannot\
    \ convert return expression of type 'String' to return type 'Value?'\n    return\
    \ Double(a) < Double(b) ? b : nil\n           ~~~~~~~~~~~~~~~~~~~~~~^~~~~~~~~\n\
    /tmp/tmp5jss_0_l.swift:30:12: error: cannot convert value of type 'Double' to\
    \ expected argument type 'Int'\n    return a < b ? a : nil\n           ^\n   \
    \        Int( )\n/tmp/tmp5jss_0_l.swift:30:18: error: cannot convert return expression\
    \ of type 'Double' to return type 'Value?'\n    return a < b ? a : nil\n     \
    \      ~~~~~~^~~~~~~~~\n/tmp/tmp5jss_0_l.swift:32:18: error: cannot convert return\
    \ expression of type 'Double' to return type 'Value?'\n    return a < b ? b :\
    \ nil\n           ~~~~~~^~~~~~~~~\n/tmp/tmp5jss_0_l.swift:34:16: error: value\
    \ of optional type 'Double?' must be unwrapped to a value of type 'Double'\n \
    \   return a < Double(b) ? b : nil\n               ^\n/tmp/tmp5jss_0_l.swift:34:16:\
    \ note: coalesce usin"
  stdout: ''
  timestamp: 1660013181
- exit_code: 1
  program: "\nenum Value: Equatable, Hashable {\n    case intValue(Int)\n    case\
    \ doubleValue(Double)\n    case stringValue(String)\n}\n\n            \n/// Create\
    \ a function that takes integers, floats, or strings representing\n/// real numbers,\
    \ and returns the larger variable in its given variable type.\n/// Return nil\
    \ if the values are equal.\n/// Note: If a real number is represented as a string,\
    \ the floating point might be . or ,\n/// >>> compare_one(a: .intValue(1), b:\
    \ .doubleValue(2.5))\n/// .doubleValue(2.5)\n/// >>> compare_one(a: .intValue(1),\
    \ b: .stringValue(\"2,3\"))\n/// .stringValue(\"2,3\")\n/// >>> compare_one(a:\
    \ .stringValue(\"5,1\"), b: .stringValue(\"6\"))\n/// .stringValue(\"6\")\n///\
    \ >>> compare_one(a: .stringValue(\"1\"), b: .intValue(1))\n/// nil\nfunc compare_one(a:\
    \ Value, b: Value) -> Value? {\n    switch (a, b) {\n    case (.intValue(let aValue),\
    \ .intValue(let bValue)):\n        return aValue > bValue ? a : (aValue < bValue\
    \ ? b : nil)\n    case (.intValue(let aValue), .doubleValue(let bValue)):\n  \
    \      return aValue > bValue ? a : (aValue < bValue ? b : nil)\n    case (.intValue(let\
    \ aValue), .stringValue(let bValue)):\n        return aValue > Int(bValue) ??\
    \ 0 ? a : (aValue < Int(bValue) ?? 0 ? b : nil)\n    case (.doubleValue(let aValue),\
    \ .intValue(let bValue)):\n        return aValue > bValue ? a : (aValue < bValue\
    \ ? b : nil)\n    case (.doubleValue(let aValue), .doubleValue(let bValue)):\n\
    \        return aValue > bValue ? a : (aValue < bValue ? b : nil)\n    case (.doubleValue(let\
    \ aValue), .stringValue(let bValue)):\n        return aValue > Double(bValue)\
    \ ?? 0 ? a : (aValue < Double(bValue) ?? 0 ? b : nil)\n    case (.stringValue(let\
    \ aValue), .intValue(let bValue)):\n        return Int(aValue) ?? 0 > bValue ?\
    \ a : (Int(aValue) ?? 0 < bValue ? b : nil)\n    case (.stringValue(let aValue),\
    \ .doubleValue(let bValue)):\n        return Double(aValue) ?? 0 > bValue ? a\
    \ : (Double(aValue) ?? 0 < bValue ? b : nil)\n    case (.stringValue(let aValue),\
    \ .stringValue(let bValue)):\n        return Int(aValue) ?? 0 > Int(bValue) ??\
    \ 0 ? a : (Int(aValue) ?? 0 < Int(bValue) ?? 0 ? b : nil)\n    }\n}\n\n\nfunc\
    \ ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count !=\
    \ right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(compare_one(a: .intValue(1), b: .intValue(2))\
    \ == .intValue(2))\nassert(compare_one(a: .intValue(1), b: .doubleValue(2.5))\
    \ == .doubleValue(2.5))\nassert(compare_one(a: .intValue(2), b: .intValue(3))\
    \ == .intValue(3))\nassert(compare_one(a: .intValue(5), b: .intValue(6)) == .intValue(6))\n\
    assert(compare_one(a: .intValue(1), b: .stringValue(\"2,3\")) == .stringValue(\"\
    2,3\"))\nassert(compare_one(a: .stringValue(\"5,1\"), b: .stringValue(\"6\"))\
    \ == .stringValue(\"6\"))\nassert(compare_one(a: .stringValue(\"1\"), b: .stringValue(\"\
    2\")) == .stringValue(\"2\"))\nassert(compare_one(a: .stringValue(\"1\"), b: .intValue(1))\
    \ == nil)"
  status: SyntaxError
  stderr: "/tmp/tmp9f17irr6.swift:26:25: error: cannot convert value of type 'Double'\
    \ to expected argument type 'Int'\n        return aValue > bValue ? a : (aValue\
    \ < bValue ? b : nil)\n                        ^\n                        Int(\
    \  )\n/tmp/tmp9f17irr6.swift:26:48: error: cannot convert value of type 'Double'\
    \ to expected argument type 'Int'\n        return aValue > bValue ? a : (aValue\
    \ < bValue ? b : nil)\n                                               ^\n    \
    \                                           Int(  )\n/tmp/tmp9f17irr6.swift:30:16:\
    \ error: cannot convert value of type 'Double' to expected argument type 'Int'\n\
    \        return aValue > bValue ? a : (aValue < bValue ? b : nil)\n          \
    \     ^\n               Int(  )\n/tmp/tmp9f17irr6.swift:30:39: error: cannot convert\
    \ value of type 'Double' to expected argument type 'Int'\n        return aValue\
    \ > bValue ? a : (aValue < bValue ? b : nil)\n                               \
    \       ^\n                                      Int(  )\n"
  stdout: ''
  timestamp: 1660013181
- exit_code: 1
  program: "\nenum Value: Equatable, Hashable {\n    case intValue(Int)\n    case\
    \ doubleValue(Double)\n    case stringValue(String)\n}\n\n            \n/// Create\
    \ a function that takes integers, floats, or strings representing\n/// real numbers,\
    \ and returns the larger variable in its given variable type.\n/// Return nil\
    \ if the values are equal.\n/// Note: If a real number is represented as a string,\
    \ the floating point might be . or ,\n/// >>> compare_one(a: .intValue(1), b:\
    \ .doubleValue(2.5))\n/// .doubleValue(2.5)\n/// >>> compare_one(a: .intValue(1),\
    \ b: .stringValue(\"2,3\"))\n/// .stringValue(\"2,3\")\n/// >>> compare_one(a:\
    \ .stringValue(\"5,1\"), b: .stringValue(\"6\"))\n/// .stringValue(\"6\")\n///\
    \ >>> compare_one(a: .stringValue(\"1\"), b: .intValue(1))\n/// nil\nfunc compare_one(a:\
    \ Value, b: Value) -> Value? {\n    switch (a, b) {\n    case (.intValue(let a),\
    \ .intValue(let b)):\n        return a > b ? a : b\n    case (.doubleValue(let\
    \ a), .doubleValue(let b)):\n        return a > b ? a : b\n    case (.stringValue(let\
    \ a), .stringValue(let b)):\n        return a > b ? a : b\n    default:\n    \
    \    return nil\n    }\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(compare_one(a:\
    \ .intValue(1), b: .intValue(2)) == .intValue(2))\nassert(compare_one(a: .intValue(1),\
    \ b: .doubleValue(2.5)) == .doubleValue(2.5))\nassert(compare_one(a: .intValue(2),\
    \ b: .intValue(3)) == .intValue(3))\nassert(compare_one(a: .intValue(5), b: .intValue(6))\
    \ == .intValue(6))\nassert(compare_one(a: .intValue(1), b: .stringValue(\"2,3\"\
    )) == .stringValue(\"2,3\"))\nassert(compare_one(a: .stringValue(\"5,1\"), b:\
    \ .stringValue(\"6\")) == .stringValue(\"6\"))\nassert(compare_one(a: .stringValue(\"\
    1\"), b: .stringValue(\"2\")) == .stringValue(\"2\"))\nassert(compare_one(a: .stringValue(\"\
    1\"), b: .intValue(1)) == nil)"
  status: SyntaxError
  stderr: "/tmp/tmp07haxekb.swift:24:22: error: cannot convert return expression of\
    \ type 'Int' to return type 'Value?'\n        return a > b ? a : b\n         \
    \      ~~~~~~^~~~~~~\n/tmp/tmp07haxekb.swift:26:22: error: cannot convert return\
    \ expression of type 'Double' to return type 'Value?'\n        return a > b ?\
    \ a : b\n               ~~~~~~^~~~~~~\n/tmp/tmp07haxekb.swift:28:22: error: cannot\
    \ convert return expression of type 'String' to return type 'Value?'\n       \
    \ return a > b ? a : b\n               ~~~~~~^~~~~~~\n"
  stdout: ''
  timestamp: 1660013180
- exit_code: 1
  program: "\nenum Value: Equatable, Hashable {\n    case intValue(Int)\n    case\
    \ doubleValue(Double)\n    case stringValue(String)\n}\n\n            \n/// Create\
    \ a function that takes integers, floats, or strings representing\n/// real numbers,\
    \ and returns the larger variable in its given variable type.\n/// Return nil\
    \ if the values are equal.\n/// Note: If a real number is represented as a string,\
    \ the floating point might be . or ,\n/// >>> compare_one(a: .intValue(1), b:\
    \ .doubleValue(2.5))\n/// .doubleValue(2.5)\n/// >>> compare_one(a: .intValue(1),\
    \ b: .stringValue(\"2,3\"))\n/// .stringValue(\"2,3\")\n/// >>> compare_one(a:\
    \ .stringValue(\"5,1\"), b: .stringValue(\"6\"))\n/// .stringValue(\"6\")\n///\
    \ >>> compare_one(a: .stringValue(\"1\"), b: .intValue(1))\n/// nil\nfunc compare_one(a:\
    \ Value, b: Value) -> Value? {\n    var result: Value?\n    if case let .intValue(a)\
    \ = a, case let .intValue(b) = b {\n        if a > b {\n            result = .intValue(a)\n\
    \        } else if a < b {\n            result = .intValue(b)\n        }\n   \
    \ } else if case let .doubleValue(a) = a, case let .doubleValue(b) = b {\n   \
    \     if a > b {\n            result = .doubleValue(a)\n        } else if a <\
    \ b {\n            result = .doubleValue(b)\n        }\n    } else if case let\
    \ .stringValue(a) = a, case let .stringValue(b) = b {\n        if a > b {\n  \
    \          result = .stringValue(a)\n        } else if a < b {\n            result\
    \ = .stringValue(b)\n        }\n    } else if case let .intValue(a) = a, case\
    \ let .doubleValue(b) = b {\n        if a > b {\n            result = .intValue(a)\n\
    \        } else if a < b {\n            result = .doubleValue(b)\n        }\n\
    \    } else if case let .intValue(a) = a, case let .stringValue(b) = b {\n   \
    \     if a > Double(b) ?? 0 {\n            result = .intValue(a)\n        } else\
    \ if a < Double(b) ?? 0 {\n            result = .stringValue(b)\n        }\n \
    \   } else if case let .doubleValue(a) = a, case let .intValue(b) = b {\n    \
    \    if a > b {\n            result = .doubleValue(a)\n        } else if a < b\
    \ {\n            result = .intValue(b)\n        }\n    } else if case let .doubleValue(a)\
    \ = a, case let .stringValue(b) = b {\n        if a > Double(b) ?? 0 {\n     \
    \       result = .doubleValue(a)\n        } else if a < Double(b) ?? 0 {\n   \
    \         result = .stringValue(b)\n        }\n    } else if case let .stringValue(a)\
    \ = a, case let .intValue(b) =\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int,\
    \ Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n\
    \    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n          \
    \  return false\n        }\n    }\n    return true\n}\n            \nassert(compare_one(a:\
    \ .intValue(1), b: .intValue(2)) == .intValue(2))\nassert(compare_one(a: .intValue(1),\
    \ b: .doubleValue(2.5)) == .doubleValue(2.5))\nassert(compare_one(a: .intValue(2),\
    \ b: .intValue(3)) == .intValue(3))\nassert(compare_one(a: .intValue(5), b: .intValue(6))\
    \ == .intValue(6))\nassert(compare_one(a: .intValue(1), b: .stringValue(\"2,3\"\
    )) == .stringValue(\"2,3\"))\nassert(compare_one(a: .stringValue(\"5,1\"), b:\
    \ .stringValue(\"6\")) == .stringValue(\"6\"))\nassert(compare_one(a: .stringValue(\"\
    1\"), b: .stringValue(\"2\")) == .stringValue(\"2\"))\nassert(compare_one(a: .stringValue(\"\
    1\"), b: .intValue(1)) == nil)"
  status: SyntaxError
  stderr: "/tmp/tmpdqopoai6.swift:65:68: error: expected expression after '=' in conditional\
    \ binding\n    } else if case let .stringValue(a) = a, case let .intValue(b) =\n\
    \                                                                   ^\n/tmp/tmpdqopoai6.swift:65:68:\
    \ error: expected '{' after 'if' condition\n    } else if case let .stringValue(a)\
    \ = a, case let .intValue(b) =\n                                             \
    \                      ^\n/tmp/tmpdqopoai6.swift:42:14: error: binary operator\
    \ '>' cannot be applied to operands of type 'Int' and 'Double'\n        if a >\
    \ b {\n           ~ ^ ~\n/tmp/tmpdqopoai6.swift:42:14: note: overloads for '>'\
    \ exist with these partially matching parameter lists: (Int, Int)\n        if\
    \ a > b {\n             ^\n/tmp/tmpdqopoai6.swift:44:21: error: binary operator\
    \ '<' cannot be applied to operands of type 'Int' and 'Double'\n        } else\
    \ if a < b {\n                  ~ ^ ~\n/tmp/tmpdqopoai6.swift:44:21: note: overloads\
    \ for '<' exist with these partially matching parameter lists: (Int, Int)\n  \
    \      } else if a < b {\n                    ^\n/tmp/tmpdqopoai6.swift:48:26:\
    \ error: cannot convert value of type 'Double' to expected argument type 'Int'\n\
    \        if a > Double(b) ?? 0 {\n                         ^\n               Int(\
    \          )\n/tmp/tmpdqopoai6.swift:50:33: error: cannot convert value of type\
    \ 'Double' to expected argument type 'Int'\n        } else if a < Double(b) ??\
    \ 0 {\n                                ^\n                      Int(         \
    \ )\n/tmp/tmpdqopoai6.swift:54:14: error: binary operator '>' cannot be applied\
    \ to operands of type 'Double' and 'Int'\n        if a > b {\n           ~ ^ ~\n\
    /tmp/tmpdqopoai6.swift:54:14: note: overloads for '>' exist with these partially\
    \ matching parameter lists: (Int, Int)\n        if a > b {\n             ^\n/tmp/tmpdqopoai6.swift:56:21:\
    \ error: binary operator '<' cannot be applied to operands of type 'Double' and\
    \ 'Int'\n        } else if a < b {\n                  ~ ^ ~\n/tmp/tmpdqopoai6.swift:56:21:\
    \ note: overloads for '<' exist with these partially matching parameter "
  stdout: ''
  timestamp: 1660013181
- exit_code: 1
  program: "\nenum Value: Equatable, Hashable {\n    case intValue(Int)\n    case\
    \ doubleValue(Double)\n    case stringValue(String)\n}\n\n            \n/// Create\
    \ a function that takes integers, floats, or strings representing\n/// real numbers,\
    \ and returns the larger variable in its given variable type.\n/// Return nil\
    \ if the values are equal.\n/// Note: If a real number is represented as a string,\
    \ the floating point might be . or ,\n/// >>> compare_one(a: .intValue(1), b:\
    \ .doubleValue(2.5))\n/// .doubleValue(2.5)\n/// >>> compare_one(a: .intValue(1),\
    \ b: .stringValue(\"2,3\"))\n/// .stringValue(\"2,3\")\n/// >>> compare_one(a:\
    \ .stringValue(\"5,1\"), b: .stringValue(\"6\"))\n/// .stringValue(\"6\")\n///\
    \ >>> compare_one(a: .stringValue(\"1\"), b: .intValue(1))\n/// nil\nfunc compare_one(a:\
    \ Value, b: Value) -> Value? {\n    let intToDouble = {(i: Int) -> Double in\n\
    \        return Double(i)\n    }\n    let stringToDouble = {(s: String) -> Double\
    \ in\n        let array = s.components(separatedBy: CharacterSet(charactersIn:\
    \ \",.\"))\n        let first = Double(array[0])!\n        if array.count == 1\
    \ {\n            return first\n        } else {\n            let second = Double(array[1])!\n\
    \            return first + second / pow(10, Double(array[1].count))\n       \
    \ }\n    }\n    switch (a, b) {\n    case (.intValue(let x), .intValue(let y)):\n\
    \        return x > y ? a : b\n    case (.intValue(let x), .doubleValue(let y)):\n\
    \        return y > intToDouble(x) ? b : a\n    case (.intValue(let x), .stringValue(let\
    \ y)):\n        return stringToDouble(y) > intToDouble(x) ? b : a\n    case (.doubleValue(let\
    \ x), .intValue(let y)):\n        return x > intToDouble(y) ? a : b\n    case\
    \ (.doubleValue(let x), .doubleValue(let y)):\n        return x > y ? a : b\n\
    \    case (.doubleValue(let x), .stringValue(let y)):\n        return stringToDouble(y)\
    \ > x ? b : a\n    case (.stringValue(let x), .intValue(let y)):\n        return\
    \ stringToDouble(x) > intToDouble(y) ? a : b\n    case (.stringValue(let x), .doubleValue(let\
    \ y)):\n        return stringToDouble(x) > y ? a : b\n    case (.stringValue(let\
    \ x), .stringValue(let y)):\n        return stringToDouble(x) > stringToDouble(y)\
    \ ? a : b\n    }\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool\
    \ {\n    if left.count != right.count {\n        return false\n    }\n    for\
    \ (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(compare_one(a: .intValue(1),\
    \ b: .intValue(2)) == .intValue(2))\nassert(compare_one(a: .intValue(1), b: .doubleValue(2.5))\
    \ == .doubleValue(2.5))\nassert(compare_one(a: .intValue(2), b: .intValue(3))\
    \ == .intValue(3))\nassert(compare_one(a: .intValue(5), b: .intValue(6)) == .intValue(6))\n\
    assert(compare_one(a: .intValue(1), b: .stringValue(\"2,3\")) == .stringValue(\"\
    2,3\"))\nassert(compare_one(a: .stringValue(\"5,1\"), b: .stringValue(\"6\"))\
    \ == .stringValue(\"6\"))\nassert(compare_one(a: .stringValue(\"1\"), b: .stringValue(\"\
    2\")) == .stringValue(\"2\"))\nassert(compare_one(a: .stringValue(\"1\"), b: .intValue(1))\
    \ == nil)"
  status: SyntaxError
  stderr: "/tmp/tmpj_u0ul7s.swift:26:47: error: cannot find 'CharacterSet' in scope\n\
    \        let array = s.components(separatedBy: CharacterSet(charactersIn: \",.\"\
    ))\n                                              ^~~~~~~~~~~~\n/tmp/tmpj_u0ul7s.swift:32:37:\
    \ error: cannot find 'pow' in scope\n            return first + second / pow(10,\
    \ Double(array[1].count))\n                                    ^~~\n"
  stdout: ''
  timestamp: 1660013180
- exit_code: 1
  program: "\nenum Value: Equatable, Hashable {\n    case intValue(Int)\n    case\
    \ doubleValue(Double)\n    case stringValue(String)\n}\n\n            \n/// Create\
    \ a function that takes integers, floats, or strings representing\n/// real numbers,\
    \ and returns the larger variable in its given variable type.\n/// Return nil\
    \ if the values are equal.\n/// Note: If a real number is represented as a string,\
    \ the floating point might be . or ,\n/// >>> compare_one(a: .intValue(1), b:\
    \ .doubleValue(2.5))\n/// .doubleValue(2.5)\n/// >>> compare_one(a: .intValue(1),\
    \ b: .stringValue(\"2,3\"))\n/// .stringValue(\"2,3\")\n/// >>> compare_one(a:\
    \ .stringValue(\"5,1\"), b: .stringValue(\"6\"))\n/// .stringValue(\"6\")\n///\
    \ >>> compare_one(a: .stringValue(\"1\"), b: .intValue(1))\n/// nil\nfunc compare_one(a:\
    \ Value, b: Value) -> Value? {\n    switch (a, b) {\n    case (.intValue(let a),\
    \ .intValue(let b)):\n        return (a >= b) ? a : b\n    case (.doubleValue(let\
    \ a), .doubleValue(let b)):\n        return (a >= b) ? a : b\n    case (.stringValue(let\
    \ a), .stringValue(let b)):\n        return (a >= b) ? a : b\n    case (.intValue(let\
    \ a), .doubleValue(let b)):\n        return (a >= b) ? a : b\n    case (.intValue(let\
    \ a), .stringValue(let b)):\n        return (a >= b) ? a : b\n    case (.doubleValue(let\
    \ a), .intValue(let b)):\n        return (a >= b) ? a : b\n    case (.doubleValue(let\
    \ a), .stringValue(let b)):\n        return (a >= b) ? a : b\n    case (.stringValue(let\
    \ a), .intValue(let b)):\n        return (a >= b) ? a : b\n    case (.stringValue(let\
    \ a), .doubleValue(let b)):\n        return (a >= b) ? a : b\n    default:\n \
    \       return nil\n    }\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(compare_one(a:\
    \ .intValue(1), b: .intValue(2)) == .intValue(2))\nassert(compare_one(a: .intValue(1),\
    \ b: .doubleValue(2.5)) == .doubleValue(2.5))\nassert(compare_one(a: .intValue(2),\
    \ b: .intValue(3)) == .intValue(3))\nassert(compare_one(a: .intValue(5), b: .intValue(6))\
    \ == .intValue(6))\nassert(compare_one(a: .intValue(1), b: .stringValue(\"2,3\"\
    )) == .stringValue(\"2,3\"))\nassert(compare_one(a: .stringValue(\"5,1\"), b:\
    \ .stringValue(\"6\")) == .stringValue(\"6\"))\nassert(compare_one(a: .stringValue(\"\
    1\"), b: .stringValue(\"2\")) == .stringValue(\"2\"))\nassert(compare_one(a: .stringValue(\"\
    1\"), b: .intValue(1)) == nil)"
  status: SyntaxError
  stderr: "/tmp/tmphc__yr_q.swift:24:25: error: cannot convert return expression of\
    \ type 'Int' to return type 'Value?'\n        return (a >= b) ? a : b\n      \
    \         ~~~~~~~~~^~~~~~~\n/tmp/tmphc__yr_q.swift:26:25: error: cannot convert\
    \ return expression of type 'Double' to return type 'Value?'\n        return (a\
    \ >= b) ? a : b\n               ~~~~~~~~~^~~~~~~\n/tmp/tmphc__yr_q.swift:28:25:\
    \ error: cannot convert return expression of type 'String' to return type 'Value?'\n\
    \        return (a >= b) ? a : b\n               ~~~~~~~~~^~~~~~~\n/tmp/tmphc__yr_q.swift:30:22:\
    \ error: cannot convert value of type 'Double' to expected argument type 'Int'\n\
    \        return (a >= b) ? a : b\n                     ^\n                   \
    \  Int( )\n/tmp/tmphc__yr_q.swift:30:25: error: cannot convert return expression\
    \ of type 'Int' to return type 'Value?'\n        return (a >= b) ? a : b\n   \
    \            ~~~~~~~~~^~~~~~~\n/tmp/tmphc__yr_q.swift:32:22: error: cannot convert\
    \ value of type 'String' to expected argument type 'Int'\n        return (a >=\
    \ b) ? a : b\n                     ^\n/tmp/tmphc__yr_q.swift:32:25: error: cannot\
    \ convert return expression of type 'Int' to return type 'Value?'\n        return\
    \ (a >= b) ? a : b\n               ~~~~~~~~~^~~~~~~\n/tmp/tmphc__yr_q.swift:34:17:\
    \ error: cannot convert value of type 'Double' to expected argument type 'Int'\n\
    \        return (a >= b) ? a : b\n                ^\n                Int( )\n\
    /tmp/tmphc__yr_q.swift:34:25: error: cannot convert return expression of type\
    \ 'Double' to return type 'Value?'\n        return (a >= b) ? a : b\n        \
    \       ~~~~~~~~~^~~~~~~\n/tmp/tmphc__yr_q.swift:36:19: error: binary operator\
    \ '>=' cannot be applied to operands of type 'Double' and 'String'\n        return\
    \ (a >= b) ? a : b\n                ~ ^  ~\n/tmp/tmphc__yr_q.swift:36:25: error:\
    \ cannot convert return expression of type 'Double' to return type 'Value?'\n\
    \        return (a >= b) ? a : b\n               ~~~~~~~~~^~~~~~~\n/tmp/tmphc__yr_q.swift:38:17:\
    \ error: cannot convert value of type 'String' to expected argument type 'Int'\n\
    \        return (a >="
  stdout: ''
  timestamp: 1660013181
- exit_code: 1
  program: "\nenum Value: Equatable, Hashable {\n    case intValue(Int)\n    case\
    \ doubleValue(Double)\n    case stringValue(String)\n}\n\n            \n/// Create\
    \ a function that takes integers, floats, or strings representing\n/// real numbers,\
    \ and returns the larger variable in its given variable type.\n/// Return nil\
    \ if the values are equal.\n/// Note: If a real number is represented as a string,\
    \ the floating point might be . or ,\n/// >>> compare_one(a: .intValue(1), b:\
    \ .doubleValue(2.5))\n/// .doubleValue(2.5)\n/// >>> compare_one(a: .intValue(1),\
    \ b: .stringValue(\"2,3\"))\n/// .stringValue(\"2,3\")\n/// >>> compare_one(a:\
    \ .stringValue(\"5,1\"), b: .stringValue(\"6\"))\n/// .stringValue(\"6\")\n///\
    \ >>> compare_one(a: .stringValue(\"1\"), b: .intValue(1))\n/// nil\nfunc compare_one(a:\
    \ Value, b: Value) -> Value? {\n    switch a {\n    case .intValue(let a):\n \
    \       switch b {\n        case .intValue(let b):\n            return a > b ?\
    \ a : b\n        case .doubleValue(let b):\n            return a > b ? a : b\n\
    \        case .stringValue(let b):\n            return a > Int(b) ?? 0 ? a : b\n\
    \        }\n    case .doubleValue(let a):\n        switch b {\n        case .intValue(let\
    \ b):\n            return a > b ? a : b\n        case .doubleValue(let b):\n \
    \           return a > b ? a : b\n        case .stringValue(let b):\n        \
    \    return a > Double(b) ?? 0 ? a : b\n        }\n    case .stringValue(let a):\n\
    \        switch b {\n        case .intValue(let b):\n            return Int(a)\
    \ ?? 0 > b ? a : b\n        case .doubleValue(let b):\n            return Double(a)\
    \ ?? 0 > b ? a : b\n        case .stringValue(let b):\n            return a >\
    \ b ? a : b\n        }\n    }\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int,\
    \ Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n\
    \    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n          \
    \  return false\n        }\n    }\n    return true\n}\n            \nassert(compare_one(a:\
    \ .intValue(1), b: .intValue(2)) == .intValue(2))\nassert(compare_one(a: .intValue(1),\
    \ b: .doubleValue(2.5)) == .doubleValue(2.5))\nassert(compare_one(a: .intValue(2),\
    \ b: .intValue(3)) == .intValue(3))\nassert(compare_one(a: .intValue(5), b: .intValue(6))\
    \ == .intValue(6))\nassert(compare_one(a: .intValue(1), b: .stringValue(\"2,3\"\
    )) == .stringValue(\"2,3\"))\nassert(compare_one(a: .stringValue(\"5,1\"), b:\
    \ .stringValue(\"6\")) == .stringValue(\"6\"))\nassert(compare_one(a: .stringValue(\"\
    1\"), b: .stringValue(\"2\")) == .stringValue(\"2\"))\nassert(compare_one(a: .stringValue(\"\
    1\"), b: .intValue(1)) == nil)"
  status: SyntaxError
  stderr: "/tmp/tmpek19kugk.swift:26:26: error: cannot convert return expression of\
    \ type 'Int' to return type 'Value?'\n            return a > b ? a : b\n     \
    \              ~~~~~~^~~~~~~\n/tmp/tmpek19kugk.swift:28:24: error: cannot convert\
    \ value of type 'Double' to expected argument type 'Int'\n            return a\
    \ > b ? a : b\n                       ^\n                       Int( )\n/tmp/tmpek19kugk.swift:28:26:\
    \ error: cannot convert return expression of type 'Int' to return type 'Value?'\n\
    \            return a > b ? a : b\n                   ~~~~~~^~~~~~~\n/tmp/tmpek19kugk.swift:30:36:\
    \ error: cannot convert return expression of type 'Int' to return type 'Value?'\n\
    \            return a > Int(b) ?? 0 ? a : b\n                   ~~~~~~~~~~~~~~~~^~~~~~~\n\
    /tmp/tmpek19kugk.swift:35:20: error: cannot convert value of type 'Double' to\
    \ expected argument type 'Int'\n            return a > b ? a : b\n           \
    \        ^\n                   Int( )\n/tmp/tmpek19kugk.swift:35:26: error: cannot\
    \ convert return expression of type 'Double' to return type 'Value?'\n       \
    \     return a > b ? a : b\n                   ~~~~~~^~~~~~~\n/tmp/tmpek19kugk.swift:37:26:\
    \ error: cannot convert return expression of type 'Double' to return type 'Value?'\n\
    \            return a > b ? a : b\n                   ~~~~~~^~~~~~~\n/tmp/tmpek19kugk.swift:39:39:\
    \ error: cannot convert return expression of type 'Double' to return type 'Value?'\n\
    \            return a > Double(b) ?? 0 ? a : b\n                   ~~~~~~~~~~~~~~~~~~~^~~~~~~\n\
    /tmp/tmpek19kugk.swift:44:36: error: cannot convert return expression of type\
    \ 'String' to return type 'Value?'\n            return Int(a) ?? 0 > b ? a : b\n\
    \                   ~~~~~~~~~~~~~~~~^~~~~~~\n/tmp/tmpek19kugk.swift:46:39: error:\
    \ cannot convert return expression of type 'String' to return type 'Value?'\n\
    \            return Double(a) ?? 0 > b ? a : b\n                   ~~~~~~~~~~~~~~~~~~~^~~~~~~\n\
    /tmp/tmpek19kugk.swift:48:26: error: cannot convert return expression of type\
    \ 'String' to return type 'Value?'\n            return a > b ? a : b\n       \
    \            ~~~~"
  stdout: ''
  timestamp: 1660013181
- exit_code: 1
  program: "\nenum Value: Equatable, Hashable {\n    case intValue(Int)\n    case\
    \ doubleValue(Double)\n    case stringValue(String)\n}\n\n            \n/// Create\
    \ a function that takes integers, floats, or strings representing\n/// real numbers,\
    \ and returns the larger variable in its given variable type.\n/// Return nil\
    \ if the values are equal.\n/// Note: If a real number is represented as a string,\
    \ the floating point might be . or ,\n/// >>> compare_one(a: .intValue(1), b:\
    \ .doubleValue(2.5))\n/// .doubleValue(2.5)\n/// >>> compare_one(a: .intValue(1),\
    \ b: .stringValue(\"2,3\"))\n/// .stringValue(\"2,3\")\n/// >>> compare_one(a:\
    \ .stringValue(\"5,1\"), b: .stringValue(\"6\"))\n/// .stringValue(\"6\")\n///\
    \ >>> compare_one(a: .stringValue(\"1\"), b: .intValue(1))\n/// nil\nfunc compare_one(a:\
    \ Value, b: Value) -> Value? {\n    switch (a, b) {\n    case (.intValue(let a),\
    \ .intValue(let b)):\n        return a > b ? a : b\n    case (.doubleValue(let\
    \ a), .doubleValue(let b)):\n        return a > b ? a : b\n    case (.stringValue(let\
    \ a), .stringValue(let b)):\n        return a > b ? a : b\n    default:\n    \
    \    return nil\n    }\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(compare_one(a:\
    \ .intValue(1), b: .intValue(2)) == .intValue(2))\nassert(compare_one(a: .intValue(1),\
    \ b: .doubleValue(2.5)) == .doubleValue(2.5))\nassert(compare_one(a: .intValue(2),\
    \ b: .intValue(3)) == .intValue(3))\nassert(compare_one(a: .intValue(5), b: .intValue(6))\
    \ == .intValue(6))\nassert(compare_one(a: .intValue(1), b: .stringValue(\"2,3\"\
    )) == .stringValue(\"2,3\"))\nassert(compare_one(a: .stringValue(\"5,1\"), b:\
    \ .stringValue(\"6\")) == .stringValue(\"6\"))\nassert(compare_one(a: .stringValue(\"\
    1\"), b: .stringValue(\"2\")) == .stringValue(\"2\"))\nassert(compare_one(a: .stringValue(\"\
    1\"), b: .intValue(1)) == nil)"
  status: SyntaxError
  stderr: "/tmp/tmp07haxekb.swift:24:22: error: cannot convert return expression of\
    \ type 'Int' to return type 'Value?'\n        return a > b ? a : b\n         \
    \      ~~~~~~^~~~~~~\n/tmp/tmp07haxekb.swift:26:22: error: cannot convert return\
    \ expression of type 'Double' to return type 'Value?'\n        return a > b ?\
    \ a : b\n               ~~~~~~^~~~~~~\n/tmp/tmp07haxekb.swift:28:22: error: cannot\
    \ convert return expression of type 'String' to return type 'Value?'\n       \
    \ return a > b ? a : b\n               ~~~~~~^~~~~~~\n"
  stdout: ''
  timestamp: 1660013180
- exit_code: 1
  program: "\nenum Value: Equatable, Hashable {\n    case intValue(Int)\n    case\
    \ doubleValue(Double)\n    case stringValue(String)\n}\n\n            \n/// Create\
    \ a function that takes integers, floats, or strings representing\n/// real numbers,\
    \ and returns the larger variable in its given variable type.\n/// Return nil\
    \ if the values are equal.\n/// Note: If a real number is represented as a string,\
    \ the floating point might be . or ,\n/// >>> compare_one(a: .intValue(1), b:\
    \ .doubleValue(2.5))\n/// .doubleValue(2.5)\n/// >>> compare_one(a: .intValue(1),\
    \ b: .stringValue(\"2,3\"))\n/// .stringValue(\"2,3\")\n/// >>> compare_one(a:\
    \ .stringValue(\"5,1\"), b: .stringValue(\"6\"))\n/// .stringValue(\"6\")\n///\
    \ >>> compare_one(a: .stringValue(\"1\"), b: .intValue(1))\n/// nil\nfunc compare_one(a:\
    \ Value, b: Value) -> Value? {\n    switch a {\n    case .intValue(let aInt):\n\
    \        switch b {\n        case .intValue(let bInt):\n            return aInt\
    \ >= bInt ? a : b\n        case .doubleValue(let bDouble):\n            return\
    \ aInt >= bDouble ? a : b\n        case .stringValue(let bString):\n         \
    \   return aInt >= Double(bString) ?? 0 ? a : b\n        }\n    case .doubleValue(let\
    \ aDouble):\n        switch b {\n        case .intValue(let bInt):\n         \
    \   return aDouble >= bInt ? a : b\n        case .doubleValue(let bDouble):\n\
    \            return aDouble >= bDouble ? a : b\n        case .stringValue(let\
    \ bString):\n            return aDouble >= Double(bString) ?? 0 ? a : b\n    \
    \    }\n    case .stringValue(let aString):\n        switch b {\n        case\
    \ .intValue(let bInt):\n            return Double(aString) ?? 0 >= bInt ? a :\
    \ b\n        case .doubleValue(let bDouble):\n            return Double(aString)\
    \ ?? 0 >= bDouble ? a : b\n        case .stringValue(let bString):\n         \
    \   return Double(aString) ?? 0 >= Double(bString) ?? 0 ? a : b\n        }\n \
    \   }\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n   \
    \ if left.count != right.count {\n        return false\n    }\n    for (l, r)\
    \ in zip(left, right) {\n        if l != r {\n            return false\n     \
    \   }\n    }\n    return true\n}\n            \nassert(compare_one(a: .intValue(1),\
    \ b: .intValue(2)) == .intValue(2))\nassert(compare_one(a: .intValue(1), b: .doubleValue(2.5))\
    \ == .doubleValue(2.5))\nassert(compare_one(a: .intValue(2), b: .intValue(3))\
    \ == .intValue(3))\nassert(compare_one(a: .intValue(5), b: .intValue(6)) == .intValue(6))\n\
    assert(compare_one(a: .intValue(1), b: .stringValue(\"2,3\")) == .stringValue(\"\
    2,3\"))\nassert(compare_one(a: .stringValue(\"5,1\"), b: .stringValue(\"6\"))\
    \ == .stringValue(\"6\"))\nassert(compare_one(a: .stringValue(\"1\"), b: .stringValue(\"\
    2\")) == .stringValue(\"2\"))\nassert(compare_one(a: .stringValue(\"1\"), b: .intValue(1))\
    \ == nil)"
  status: SyntaxError
  stderr: "/tmp/tmp0j3tege3.swift:28:28: error: cannot convert value of type 'Double'\
    \ to expected argument type 'Int'\n            return aInt >= bDouble ? a : b\n\
    \                           ^\n                           Int(   )\n/tmp/tmp0j3tege3.swift:30:44:\
    \ error: cannot convert value of type 'Double' to expected argument type 'Int'\n\
    \            return aInt >= Double(bString) ?? 0 ? a : b\n                   \
    \                        ^\n                           Int(                )\n\
    /tmp/tmp0j3tege3.swift:35:20: error: cannot convert value of type 'Double' to\
    \ expected argument type 'Int'\n            return aDouble >= bInt ? a : b\n \
    \                  ^\n                   Int(   )\n/tmp/tmp0j3tege3.swift:44:36:\
    \ error: cannot convert value of type 'Double' to expected argument type 'Int'\n\
    \            return Double(aString) ?? 0 >= bInt ? a : b\n                   \
    \                ^\n                   Int(                )\n"
  stdout: ''
  timestamp: 1660013181
- exit_code: 1
  program: "\nenum Value: Equatable, Hashable {\n    case intValue(Int)\n    case\
    \ doubleValue(Double)\n    case stringValue(String)\n}\n\n            \n/// Create\
    \ a function that takes integers, floats, or strings representing\n/// real numbers,\
    \ and returns the larger variable in its given variable type.\n/// Return nil\
    \ if the values are equal.\n/// Note: If a real number is represented as a string,\
    \ the floating point might be . or ,\n/// >>> compare_one(a: .intValue(1), b:\
    \ .doubleValue(2.5))\n/// .doubleValue(2.5)\n/// >>> compare_one(a: .intValue(1),\
    \ b: .stringValue(\"2,3\"))\n/// .stringValue(\"2,3\")\n/// >>> compare_one(a:\
    \ .stringValue(\"5,1\"), b: .stringValue(\"6\"))\n/// .stringValue(\"6\")\n///\
    \ >>> compare_one(a: .stringValue(\"1\"), b: .intValue(1))\n/// nil\nfunc compare_one(a:\
    \ Value, b: Value) -> Value? {\n    switch (a, b) {\n    case (.intValue(let x),\
    \ .intValue(let y)):\n        return (x == y) ? nil : x > y ? a : b\n    case\
    \ (.doubleValue(let x), .doubleValue(let y)):\n        return (x == y) ? nil :\
    \ x > y ? a : b\n    case (.stringValue(let x), .stringValue(let y)):\n      \
    \  return (x == y) ? nil : Double(x)! > Double(y)! ? a : b\n    case (.intValue(let\
    \ x), .doubleValue(let y)):\n        return (x == y) ? nil : x > y ? a : b\n \
    \   case (.intValue(let x), .stringValue(let y)):\n        return (x == Double(y)!)\
    \ ? nil : x > Double(y)! ? a : b\n    case (.doubleValue(let x), .intValue(let\
    \ y)):\n        return (x == y) ? nil : x > y ? a : b\n    case (.doubleValue(let\
    \ x), .stringValue(let y)):\n        return (x == Double(y)!) ? nil : x > Double(y)!\
    \ ? a : b\n    case (.stringValue(let x), .intValue(let y)):\n        return (Double(x)!\
    \ == y) ? nil : Double(x)! > y ? a : b\n    case (.stringValue(let x), .doubleValue(let\
    \ y)):\n        return (Double(x)! == y) ? nil : Double(x)! > y ? a : b\n    }\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(compare_one(a: .intValue(1), b: .intValue(2))\
    \ == .intValue(2))\nassert(compare_one(a: .intValue(1), b: .doubleValue(2.5))\
    \ == .doubleValue(2.5))\nassert(compare_one(a: .intValue(2), b: .intValue(3))\
    \ == .intValue(3))\nassert(compare_one(a: .intValue(5), b: .intValue(6)) == .intValue(6))\n\
    assert(compare_one(a: .intValue(1), b: .stringValue(\"2,3\")) == .stringValue(\"\
    2,3\"))\nassert(compare_one(a: .stringValue(\"5,1\"), b: .stringValue(\"6\"))\
    \ == .stringValue(\"6\"))\nassert(compare_one(a: .stringValue(\"1\"), b: .stringValue(\"\
    2\")) == .stringValue(\"2\"))\nassert(compare_one(a: .stringValue(\"1\"), b: .intValue(1))\
    \ == nil)"
  status: SyntaxError
  stderr: "/tmp/tmpka6aawim.swift:30:22: error: cannot convert value of type 'Double'\
    \ to expected argument type 'Int'\n        return (x == y) ? nil : x > y ? a :\
    \ b\n                     ^\n                     Int( )\n/tmp/tmpka6aawim.swift:30:37:\
    \ error: cannot convert value of type 'Double' to expected argument type 'Int'\n\
    \        return (x == y) ? nil : x > y ? a : b\n                             \
    \       ^\n                                    Int( )\n/tmp/tmpka6aawim.swift:32:31:\
    \ error: cannot convert value of type 'Double' to expected argument type 'Int'\n\
    \        return (x == Double(y)!) ? nil : x > Double(y)! ? a : b\n           \
    \                   ^\n                     Int(      )\n/tmp/tmpka6aawim.swift:32:55:\
    \ error: cannot convert value of type 'Double' to expected argument type 'Int'\n\
    \        return (x == Double(y)!) ? nil : x > Double(y)! ? a : b\n           \
    \                                           ^\n                              \
    \               Int(      )\n/tmp/tmpka6aawim.swift:34:17: error: cannot convert\
    \ value of type 'Double' to expected argument type 'Int'\n        return (x ==\
    \ y) ? nil : x > y ? a : b\n                ^\n                Int( )\n/tmp/tmpka6aawim.swift:34:33:\
    \ error: cannot convert value of type 'Double' to expected argument type 'Int'\n\
    \        return (x == y) ? nil : x > y ? a : b\n                             \
    \   ^\n                                Int( )\n/tmp/tmpka6aawim.swift:38:26: error:\
    \ cannot convert value of type 'Double' to expected argument type 'Int'\n    \
    \    return (Double(x)! == y) ? nil : Double(x)! > y ? a : b\n               \
    \          ^\n                Int(      )\n/tmp/tmpka6aawim.swift:38:51: error:\
    \ cannot convert value of type 'Double' to expected argument type 'Int'\n    \
    \    return (Double(x)! == y) ? nil : Double(x)! > y ? a : b\n               \
    \                                   ^\n                                      \
    \   Int(      )\n"
  stdout: ''
  timestamp: 1660013181
- exit_code: 1
  program: "\nenum Value: Equatable, Hashable {\n    case intValue(Int)\n    case\
    \ doubleValue(Double)\n    case stringValue(String)\n}\n\n            \n/// Create\
    \ a function that takes integers, floats, or strings representing\n/// real numbers,\
    \ and returns the larger variable in its given variable type.\n/// Return nil\
    \ if the values are equal.\n/// Note: If a real number is represented as a string,\
    \ the floating point might be . or ,\n/// >>> compare_one(a: .intValue(1), b:\
    \ .doubleValue(2.5))\n/// .doubleValue(2.5)\n/// >>> compare_one(a: .intValue(1),\
    \ b: .stringValue(\"2,3\"))\n/// .stringValue(\"2,3\")\n/// >>> compare_one(a:\
    \ .stringValue(\"5,1\"), b: .stringValue(\"6\"))\n/// .stringValue(\"6\")\n///\
    \ >>> compare_one(a: .stringValue(\"1\"), b: .intValue(1))\n/// nil\nfunc compare_one(a:\
    \ Value, b: Value) -> Value? {\n    let intA = a.getInt()\n    let intB = b.getInt()\n\
    \    let doubleA = a.getDouble()\n    let doubleB = b.getDouble()\n    if (intA\
    \ == nil && intB == nil) {\n        if (doubleA == nil && doubleB == nil) {\n\
    \            return nil\n        } else if (doubleA == nil) {\n            return\
    \ .doubleValue(doubleB!)\n        } else if (doubleB == nil) {\n            return\
    \ .doubleValue(doubleA!)\n        } else {\n            return doubleA! >= doubleB!\
    \ ? .doubleValue(doubleA!) : .doubleValue(doubleB!)\n        }\n    } else if\
    \ (intA == nil) {\n        return .intValue(intB!)\n    } else if (intB == nil)\
    \ {\n        return .intValue(intA!)\n    } else {\n        return intA! >= intB!\
    \ ? .intValue(intA!) : .intValue(intB!)\n    }\n}\n\n\nfunc ==(left: [(Int, Int)],\
    \ right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n       \
    \ return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r\
    \ {\n            return false\n        }\n    }\n    return true\n}\n        \
    \    \nassert(compare_one(a: .intValue(1), b: .intValue(2)) == .intValue(2))\n\
    assert(compare_one(a: .intValue(1), b: .doubleValue(2.5)) == .doubleValue(2.5))\n\
    assert(compare_one(a: .intValue(2), b: .intValue(3)) == .intValue(3))\nassert(compare_one(a:\
    \ .intValue(5), b: .intValue(6)) == .intValue(6))\nassert(compare_one(a: .intValue(1),\
    \ b: .stringValue(\"2,3\")) == .stringValue(\"2,3\"))\nassert(compare_one(a: .stringValue(\"\
    5,1\"), b: .stringValue(\"6\")) == .stringValue(\"6\"))\nassert(compare_one(a:\
    \ .stringValue(\"1\"), b: .stringValue(\"2\")) == .stringValue(\"2\"))\nassert(compare_one(a:\
    \ .stringValue(\"1\"), b: .intValue(1)) == nil)"
  status: SyntaxError
  stderr: "/tmp/tmpgppt1inj.swift:22:18: error: value of type 'Value' has no member\
    \ 'getInt'\n    let intA = a.getInt()\n               ~ ^~~~~~\n/tmp/tmpgppt1inj.swift:23:18:\
    \ error: value of type 'Value' has no member 'getInt'\n    let intB = b.getInt()\n\
    \               ~ ^~~~~~\n/tmp/tmpgppt1inj.swift:24:21: error: value of type 'Value'\
    \ has no member 'getDouble'\n    let doubleA = a.getDouble()\n               \
    \   ~ ^~~~~~~~~\n/tmp/tmpgppt1inj.swift:25:21: error: value of type 'Value' has\
    \ no member 'getDouble'\n    let doubleB = b.getDouble()\n                  ~\
    \ ^~~~~~~~~\n"
  stdout: ''
  timestamp: 1660013181
- exit_code: 1
  program: "\nenum Value: Equatable, Hashable {\n    case intValue(Int)\n    case\
    \ doubleValue(Double)\n    case stringValue(String)\n}\n\n            \n/// Create\
    \ a function that takes integers, floats, or strings representing\n/// real numbers,\
    \ and returns the larger variable in its given variable type.\n/// Return nil\
    \ if the values are equal.\n/// Note: If a real number is represented as a string,\
    \ the floating point might be . or ,\n/// >>> compare_one(a: .intValue(1), b:\
    \ .doubleValue(2.5))\n/// .doubleValue(2.5)\n/// >>> compare_one(a: .intValue(1),\
    \ b: .stringValue(\"2,3\"))\n/// .stringValue(\"2,3\")\n/// >>> compare_one(a:\
    \ .stringValue(\"5,1\"), b: .stringValue(\"6\"))\n/// .stringValue(\"6\")\n///\
    \ >>> compare_one(a: .stringValue(\"1\"), b: .intValue(1))\n/// nil\nfunc compare_one(a:\
    \ Value, b: Value) -> Value? {\n    switch (a, b) {\n    case (.intValue(let a),\
    \ .intValue(let b)):\n        return a > b ? a : b\n    case (.doubleValue(let\
    \ a), .doubleValue(let b)):\n        return a > b ? a : b\n    case (.stringValue(let\
    \ a), .stringValue(let b)):\n        let va = Double(a) ?? 0\n        let vb =\
    \ Double(b) ?? 0\n        return va > vb ? va : vb\n    default:\n        return\
    \ nil\n    }\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool\
    \ {\n    if left.count != right.count {\n        return false\n    }\n    for\
    \ (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(compare_one(a: .intValue(1),\
    \ b: .intValue(2)) == .intValue(2))\nassert(compare_one(a: .intValue(1), b: .doubleValue(2.5))\
    \ == .doubleValue(2.5))\nassert(compare_one(a: .intValue(2), b: .intValue(3))\
    \ == .intValue(3))\nassert(compare_one(a: .intValue(5), b: .intValue(6)) == .intValue(6))\n\
    assert(compare_one(a: .intValue(1), b: .stringValue(\"2,3\")) == .stringValue(\"\
    2,3\"))\nassert(compare_one(a: .stringValue(\"5,1\"), b: .stringValue(\"6\"))\
    \ == .stringValue(\"6\"))\nassert(compare_one(a: .stringValue(\"1\"), b: .stringValue(\"\
    2\")) == .stringValue(\"2\"))\nassert(compare_one(a: .stringValue(\"1\"), b: .intValue(1))\
    \ == nil)"
  status: SyntaxError
  stderr: "/tmp/tmpjl5flv9i.swift:24:22: error: cannot convert return expression of\
    \ type 'Int' to return type 'Value?'\n        return a > b ? a : b\n         \
    \      ~~~~~~^~~~~~~\n/tmp/tmpjl5flv9i.swift:26:22: error: cannot convert return\
    \ expression of type 'Double' to return type 'Value?'\n        return a > b ?\
    \ a : b\n               ~~~~~~^~~~~~~\n/tmp/tmpjl5flv9i.swift:30:24: error: cannot\
    \ convert return expression of type 'Double' to return type 'Value?'\n       \
    \ return va > vb ? va : vb\n               ~~~~~~~~^~~~~~~~~\n"
  stdout: ''
  timestamp: 1660013181
- exit_code: 1
  program: "\nenum Value: Equatable, Hashable {\n    case intValue(Int)\n    case\
    \ doubleValue(Double)\n    case stringValue(String)\n}\n\n            \n/// Create\
    \ a function that takes integers, floats, or strings representing\n/// real numbers,\
    \ and returns the larger variable in its given variable type.\n/// Return nil\
    \ if the values are equal.\n/// Note: If a real number is represented as a string,\
    \ the floating point might be . or ,\n/// >>> compare_one(a: .intValue(1), b:\
    \ .doubleValue(2.5))\n/// .doubleValue(2.5)\n/// >>> compare_one(a: .intValue(1),\
    \ b: .stringValue(\"2,3\"))\n/// .stringValue(\"2,3\")\n/// >>> compare_one(a:\
    \ .stringValue(\"5,1\"), b: .stringValue(\"6\"))\n/// .stringValue(\"6\")\n///\
    \ >>> compare_one(a: .stringValue(\"1\"), b: .intValue(1))\n/// nil\nfunc compare_one(a:\
    \ Value, b: Value) -> Value? {\n    switch (a, b) {\n    case (.intValue(let intA),\
    \ .intValue(let intB)):\n        return intA > intB ? a : b\n    case (.intValue(let\
    \ intA), .doubleValue(let doubleB)):\n        return Double(intA) > doubleB ?\
    \ a : b\n    case (.intValue(let intA), .stringValue(let stringB)):\n        return\
    \ Double(intA) > Double(stringB.replacingOccurrences(of: \",\", with: \".\"))\
    \ ?? 0 ? a : b\n    case (.doubleValue(let doubleA), .intValue(let intB)):\n \
    \       return doubleA > Double(intB) ? a : b\n    case (.doubleValue(let doubleA),\
    \ .doubleValue(let doubleB)):\n        return doubleA > doubleB ? a : b\n    case\
    \ (.doubleValue(let doubleA), .stringValue(let stringB)):\n        return doubleA\
    \ > Double(stringB.replacingOccurrences(of: \",\", with: \".\")) ?? 0 ? a : b\n\
    \    case (.stringValue(let stringA), .intValue(let intB)):\n        return Double(stringA.replacingOccurrences(of:\
    \ \",\", with: \".\")) ?? 0 > Double(intB) ? a : b\n    case (.stringValue(let\
    \ stringA), .doubleValue(let doubleB)):\n        return Double(stringA.replacingOccurrences(of:\
    \ \",\", with: \".\")) ?? 0 > doubleB ? a : b\n    case (.stringValue(let stringA),\
    \ .stringValue(let stringB)):\n        return Double(stringA.replacingOccurrences(of:\
    \ \",\", with: \".\")) ?? 0 > Double(stringB.replacingOccurrences(of: \",\", with:\
    \ \".\")) ?? 0 ? a : b\n    }\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int,\
    \ Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n\
    \    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n          \
    \  return false\n        }\n    }\n    return true\n}\n            \nassert(compare_one(a:\
    \ .intValue(1), b: .intValue(2)) == .intValue(2))\nassert(compare_one(a: .intValue(1),\
    \ b: .doubleValue(2.5)) == .doubleValue(2.5))\nassert(compare_one(a: .intValue(2),\
    \ b: .intValue(3)) == .intValue(3))\nassert(compare_one(a: .intValue(5), b: .intValue(6))\
    \ == .intValue(6))\nassert(compare_one(a: .intValue(1), b: .stringValue(\"2,3\"\
    )) == .stringValue(\"2,3\"))\nassert(compare_one(a: .stringValue(\"5,1\"), b:\
    \ .stringValue(\"6\")) == .stringValue(\"6\"))\nassert(compare_one(a: .stringValue(\"\
    1\"), b: .stringValue(\"2\")) == .stringValue(\"2\"))\nassert(compare_one(a: .stringValue(\"\
    1\"), b: .intValue(1)) == nil)"
  status: SyntaxError
  stderr: "/tmp/tmpm5y8y5fm.swift:28:46: error: value of type 'String' has no member\
    \ 'replacingOccurrences'\n        return Double(intA) > Double(stringB.replacingOccurrences(of:\
    \ \",\", with: \".\")) ?? 0 ? a : b\n                                     ~~~~~~~\
    \ ^~~~~~~~~~~~~~~~~~~~\n/tmp/tmpm5y8y5fm.swift:34:41: error: value of type 'String'\
    \ has no member 'replacingOccurrences'\n        return doubleA > Double(stringB.replacingOccurrences(of:\
    \ \",\", with: \".\")) ?? 0 ? a : b\n                                ~~~~~~~ ^~~~~~~~~~~~~~~~~~~~\n\
    /tmp/tmpm5y8y5fm.swift:36:31: error: value of type 'String' has no member 'replacingOccurrences'\n\
    \        return Double(stringA.replacingOccurrences(of: \",\", with: \".\")) ??\
    \ 0 > Double(intB) ? a : b\n                      ~~~~~~~ ^~~~~~~~~~~~~~~~~~~~\n\
    /tmp/tmpm5y8y5fm.swift:38:31: error: value of type 'String' has no member 'replacingOccurrences'\n\
    \        return Double(stringA.replacingOccurrences(of: \",\", with: \".\")) ??\
    \ 0 > doubleB ? a : b\n                      ~~~~~~~ ^~~~~~~~~~~~~~~~~~~~\n/tmp/tmpm5y8y5fm.swift:40:31:\
    \ error: value of type 'String' has no member 'replacingOccurrences'\n       \
    \ return Double(stringA.replacingOccurrences(of: \",\", with: \".\")) ?? 0 > Double(stringB.replacingOccurrences(of:\
    \ \",\", with: \".\")) ?? 0 ? a : b\n                      ~~~~~~~ ^~~~~~~~~~~~~~~~~~~~\n\
    /tmp/tmpm5y8y5fm.swift:40:95: error: value of type 'String' has no member 'replacingOccurrences'\n\
    \        return Double(stringA.replacingOccurrences(of: \",\", with: \".\")) ??\
    \ 0 > Double(stringB.replacingOccurrences(of: \",\", with: \".\")) ?? 0 ? a :\
    \ b\n                                                                        \
    \              ~~~~~~~ ^~~~~~~~~~~~~~~~~~~~\n"
  stdout: ''
  timestamp: 1660013182
- exit_code: 1
  program: "\nenum Value: Equatable, Hashable {\n    case intValue(Int)\n    case\
    \ doubleValue(Double)\n    case stringValue(String)\n}\n\n            \n/// Create\
    \ a function that takes integers, floats, or strings representing\n/// real numbers,\
    \ and returns the larger variable in its given variable type.\n/// Return nil\
    \ if the values are equal.\n/// Note: If a real number is represented as a string,\
    \ the floating point might be . or ,\n/// >>> compare_one(a: .intValue(1), b:\
    \ .doubleValue(2.5))\n/// .doubleValue(2.5)\n/// >>> compare_one(a: .intValue(1),\
    \ b: .stringValue(\"2,3\"))\n/// .stringValue(\"2,3\")\n/// >>> compare_one(a:\
    \ .stringValue(\"5,1\"), b: .stringValue(\"6\"))\n/// .stringValue(\"6\")\n///\
    \ >>> compare_one(a: .stringValue(\"1\"), b: .intValue(1))\n/// nil\nfunc compare_one(a:\
    \ Value, b: Value) -> Value? {\n    //TODO: Write implementation\n}\n\n\nfunc\
    \ ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count !=\
    \ right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(compare_one(a: .intValue(1), b: .intValue(2))\
    \ == .intValue(2))\nassert(compare_one(a: .intValue(1), b: .doubleValue(2.5))\
    \ == .doubleValue(2.5))\nassert(compare_one(a: .intValue(2), b: .intValue(3))\
    \ == .intValue(3))\nassert(compare_one(a: .intValue(5), b: .intValue(6)) == .intValue(6))\n\
    assert(compare_one(a: .intValue(1), b: .stringValue(\"2,3\")) == .stringValue(\"\
    2,3\"))\nassert(compare_one(a: .stringValue(\"5,1\"), b: .stringValue(\"6\"))\
    \ == .stringValue(\"6\"))\nassert(compare_one(a: .stringValue(\"1\"), b: .stringValue(\"\
    2\")) == .stringValue(\"2\"))\nassert(compare_one(a: .stringValue(\"1\"), b: .intValue(1))\
    \ == nil)"
  status: SyntaxError
  stderr: '/tmp/tmpbh3m1isr.swift:23:1: error: missing return in global function expected
    to return ''Value?''

    }

    ^

    '
  stdout: ''
  timestamp: 1660013181
- exit_code: 1
  program: "\nenum Value: Equatable, Hashable {\n    case intValue(Int)\n    case\
    \ doubleValue(Double)\n    case stringValue(String)\n}\n\n            \n/// Create\
    \ a function that takes integers, floats, or strings representing\n/// real numbers,\
    \ and returns the larger variable in its given variable type.\n/// Return nil\
    \ if the values are equal.\n/// Note: If a real number is represented as a string,\
    \ the floating point might be . or ,\n/// >>> compare_one(a: .intValue(1), b:\
    \ .doubleValue(2.5))\n/// .doubleValue(2.5)\n/// >>> compare_one(a: .intValue(1),\
    \ b: .stringValue(\"2,3\"))\n/// .stringValue(\"2,3\")\n/// >>> compare_one(a:\
    \ .stringValue(\"5,1\"), b: .stringValue(\"6\"))\n/// .stringValue(\"6\")\n///\
    \ >>> compare_one(a: .stringValue(\"1\"), b: .intValue(1))\n/// nil\nfunc compare_one(a:\
    \ Value, b: Value) -> Value? {\n    switch a {\n    case .intValue(let aa):\n\
    \        switch b {\n        case .intValue(let bb):\n            return aa >\
    \ bb ? a : b\n        case .doubleValue(let bb):\n            return aa > bb ?\
    \ a : b\n        case .stringValue(let bb):\n            let bbi = Double(bb.replacingOccurrences(of:\
    \ \",\", with: \".\")) ?? 0\n            return aa > bbi ? a : b\n        }\n\
    \    case .doubleValue(let aa):\n        switch b {\n        case .intValue(let\
    \ bb):\n            return aa > Double(bb) ? a : b\n        case .doubleValue(let\
    \ bb):\n            return aa > bb ? a : b\n        case .stringValue(let bb):\n\
    \            let bbi = Double(bb.replacingOccurrences(of: \",\", with: \".\"))\
    \ ?? 0\n            return aa > bbi ? a : b\n        }\n    case .stringValue(let\
    \ aa):\n        switch b {\n        case .intValue(let bb):\n            let aai\
    \ = Double(aa.replacingOccurrences(of: \",\", with: \".\")) ?? 0\n           \
    \ return aai > Double(bb) ? a : b\n        case .doubleValue(let bb):\n      \
    \      let aai = Double(aa.replacingOccurrences(of: \",\", with: \".\")) ?? 0\n\
    \            return aai > bb ? a : b\n        case .stringValue(let bb):\n   \
    \         let aai = Double(aa.replacingOccurrences(of: \",\", with: \".\")) ??\
    \ 0\n            let bbi = Double(bb.replacingOccurrences(of: \",\", with: \"\
    .\")) ?? 0\n            return aai > bbi ? a : b\n        }\n    }\n}\n\n\nfunc\
    \ ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count !=\
    \ right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(compare_one(a: .intValue(1), b: .intValue(2))\
    \ == .intValue(2))\nassert(compare_one(a: .intValue(1), b: .doubleValue(2.5))\
    \ == .doubleValue(2.5))\nassert(compare_one(a: .intValue(2), b: .intValue(3))\
    \ == .intValue(3))\nassert(compare_one(a: .intValue(5), b: .intValue(6)) == .intValue(6))\n\
    assert(compare_one(a: .intValue(1), b: .stringValue(\"2,3\")) == .stringValue(\"\
    2,3\"))\nassert(compare_one(a: .stringValue(\"5,1\"), b: .stringValue(\"6\"))\
    \ == .stringValue(\"6\"))\nassert(compare_one(a: .stringValue(\"1\"), b: .stringValue(\"\
    2\")) == .stringValue(\"2\"))\nassert(compare_one(a: .stringValue(\"1\"), b: .intValue(1))\
    \ == nil)"
  status: SyntaxError
  stderr: "/tmp/tmp2ffyhtj6.swift:28:25: error: cannot convert value of type 'Double'\
    \ to expected argument type 'Int'\n            return aa > bb ? a : b\n      \
    \                  ^\n                        Int( )\n/tmp/tmp2ffyhtj6.swift:30:33:\
    \ error: value of type 'String' has no member 'replacingOccurrences'\n       \
    \     let bbi = Double(bb.replacingOccurrences(of: \",\", with: \".\")) ?? 0\n\
    \                             ~~ ^~~~~~~~~~~~~~~~~~~~\n/tmp/tmp2ffyhtj6.swift:40:33:\
    \ error: value of type 'String' has no member 'replacingOccurrences'\n       \
    \     let bbi = Double(bb.replacingOccurrences(of: \",\", with: \".\")) ?? 0\n\
    \                             ~~ ^~~~~~~~~~~~~~~~~~~~\n/tmp/tmp2ffyhtj6.swift:46:33:\
    \ error: value of type 'String' has no member 'replacingOccurrences'\n       \
    \     let aai = Double(aa.replacingOccurrences(of: \",\", with: \".\")) ?? 0\n\
    \                             ~~ ^~~~~~~~~~~~~~~~~~~~\n/tmp/tmp2ffyhtj6.swift:49:33:\
    \ error: value of type 'String' has no member 'replacingOccurrences'\n       \
    \     let aai = Double(aa.replacingOccurrences(of: \",\", with: \".\")) ?? 0\n\
    \                             ~~ ^~~~~~~~~~~~~~~~~~~~\n/tmp/tmp2ffyhtj6.swift:52:33:\
    \ error: value of type 'String' has no member 'replacingOccurrences'\n       \
    \     let aai = Double(aa.replacingOccurrences(of: \",\", with: \".\")) ?? 0\n\
    \                             ~~ ^~~~~~~~~~~~~~~~~~~~\n/tmp/tmp2ffyhtj6.swift:53:33:\
    \ error: value of type 'String' has no member 'replacingOccurrences'\n       \
    \     let bbi = Double(bb.replacingOccurrences(of: \",\", with: \".\")) ?? 0\n\
    \                             ~~ ^~~~~~~~~~~~~~~~~~~~\n"
  stdout: ''
  timestamp: 1660013181
- exit_code: 1
  program: "\nenum Value: Equatable, Hashable {\n    case intValue(Int)\n    case\
    \ doubleValue(Double)\n    case stringValue(String)\n}\n\n            \n/// Create\
    \ a function that takes integers, floats, or strings representing\n/// real numbers,\
    \ and returns the larger variable in its given variable type.\n/// Return nil\
    \ if the values are equal.\n/// Note: If a real number is represented as a string,\
    \ the floating point might be . or ,\n/// >>> compare_one(a: .intValue(1), b:\
    \ .doubleValue(2.5))\n/// .doubleValue(2.5)\n/// >>> compare_one(a: .intValue(1),\
    \ b: .stringValue(\"2,3\"))\n/// .stringValue(\"2,3\")\n/// >>> compare_one(a:\
    \ .stringValue(\"5,1\"), b: .stringValue(\"6\"))\n/// .stringValue(\"6\")\n///\
    \ >>> compare_one(a: .stringValue(\"1\"), b: .intValue(1))\n/// nil\nfunc compare_one(a:\
    \ Value, b: Value) -> Value? {\n    switch (a, b) {\n    case (.intValue(let a),\
    \ .intValue(let b)):\n        return a >= b ? a : b\n    case (.doubleValue(let\
    \ a), .doubleValue(let b)):\n        return a >= b ? a : b\n    case (.stringValue(let\
    \ a), .stringValue(let b)):\n        return a >= b ? a : b\n    case (.stringValue(let\
    \ a), .intValue(let b)):\n        return a >= String(b) ? a : b\n    case (.intValue(let\
    \ a), .stringValue(let b)):\n        return String(a) >= b ? a : b\n    case (.stringValue(let\
    \ a), .doubleValue(let b)):\n        return a >= String(b) ? a : b\n    case (.doubleValue(let\
    \ a), .stringValue(let b)):\n        return String(a) >= b ? a : b\n    case (.intValue(let\
    \ a), .doubleValue(let b)):\n        return a >= b ? a : b\n    case (.doubleValue(let\
    \ a), .intValue(let b)):\n        return a >= b ? a : b\n    }\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(compare_one(a: .intValue(1), b: .intValue(2)) == .intValue(2))\n\
    assert(compare_one(a: .intValue(1), b: .doubleValue(2.5)) == .doubleValue(2.5))\n\
    assert(compare_one(a: .intValue(2), b: .intValue(3)) == .intValue(3))\nassert(compare_one(a:\
    \ .intValue(5), b: .intValue(6)) == .intValue(6))\nassert(compare_one(a: .intValue(1),\
    \ b: .stringValue(\"2,3\")) == .stringValue(\"2,3\"))\nassert(compare_one(a: .stringValue(\"\
    5,1\"), b: .stringValue(\"6\")) == .stringValue(\"6\"))\nassert(compare_one(a:\
    \ .stringValue(\"1\"), b: .stringValue(\"2\")) == .stringValue(\"2\"))\nassert(compare_one(a:\
    \ .stringValue(\"1\"), b: .intValue(1)) == nil)"
  status: SyntaxError
  stderr: "/tmp/tmpn_0x_gxo.swift:24:23: error: cannot convert return expression of\
    \ type 'Int' to return type 'Value?'\n        return a >= b ? a : b\n        \
    \       ~~~~~~~^~~~~~~\n/tmp/tmpn_0x_gxo.swift:26:23: error: cannot convert return\
    \ expression of type 'Double' to return type 'Value?'\n        return a >= b ?\
    \ a : b\n               ~~~~~~~^~~~~~~\n/tmp/tmpn_0x_gxo.swift:28:23: error: cannot\
    \ convert return expression of type 'String' to return type 'Value?'\n       \
    \ return a >= b ? a : b\n               ~~~~~~~^~~~~~~\n/tmp/tmpn_0x_gxo.swift:30:31:\
    \ error: cannot convert return expression of type 'String' to return type 'Value?'\n\
    \        return a >= String(b) ? a : b\n               ~~~~~~~~~~~~~~~^~~~~~~\n\
    /tmp/tmpn_0x_gxo.swift:32:31: error: cannot convert return expression of type\
    \ 'Int' to return type 'Value?'\n        return String(a) >= b ? a : b\n     \
    \          ~~~~~~~~~~~~~~~^~~~~~~\n/tmp/tmpn_0x_gxo.swift:34:31: error: cannot\
    \ convert return expression of type 'String' to return type 'Value?'\n       \
    \ return a >= String(b) ? a : b\n               ~~~~~~~~~~~~~~~^~~~~~~\n/tmp/tmpn_0x_gxo.swift:36:31:\
    \ error: cannot convert return expression of type 'Double' to return type 'Value?'\n\
    \        return String(a) >= b ? a : b\n               ~~~~~~~~~~~~~~~^~~~~~~\n\
    /tmp/tmpn_0x_gxo.swift:38:21: error: cannot convert value of type 'Double' to\
    \ expected argument type 'Int'\n        return a >= b ? a : b\n              \
    \      ^\n                    Int( )\n/tmp/tmpn_0x_gxo.swift:38:23: error: cannot\
    \ convert return expression of type 'Int' to return type 'Value?'\n        return\
    \ a >= b ? a : b\n               ~~~~~~~^~~~~~~\n/tmp/tmpn_0x_gxo.swift:40:16:\
    \ error: cannot convert value of type 'Double' to expected argument type 'Int'\n\
    \        return a >= b ? a : b\n               ^\n               Int( )\n/tmp/tmpn_0x_gxo.swift:40:23:\
    \ error: cannot convert return expression of type 'Double' to return type 'Value?'\n\
    \        return a >= b ? a : b\n               ~~~~~~~^~~~~~~\n"
  stdout: ''
  timestamp: 1660013181
- exit_code: -4
  program: "\nenum Value: Equatable, Hashable {\n    case intValue(Int)\n    case\
    \ doubleValue(Double)\n    case stringValue(String)\n}\n\n            \n/// Create\
    \ a function that takes integers, floats, or strings representing\n/// real numbers,\
    \ and returns the larger variable in its given variable type.\n/// Return nil\
    \ if the values are equal.\n/// Note: If a real number is represented as a string,\
    \ the floating point might be . or ,\n/// >>> compare_one(a: .intValue(1), b:\
    \ .doubleValue(2.5))\n/// .doubleValue(2.5)\n/// >>> compare_one(a: .intValue(1),\
    \ b: .stringValue(\"2,3\"))\n/// .stringValue(\"2,3\")\n/// >>> compare_one(a:\
    \ .stringValue(\"5,1\"), b: .stringValue(\"6\"))\n/// .stringValue(\"6\")\n///\
    \ >>> compare_one(a: .stringValue(\"1\"), b: .intValue(1))\n/// nil\nfunc compare_one(a:\
    \ Value, b: Value) -> Value? {\n    return nil\n}\n\n\nfunc ==(left: [(Int, Int)],\
    \ right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n       \
    \ return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r\
    \ {\n            return false\n        }\n    }\n    return true\n}\n        \
    \    \nassert(compare_one(a: .intValue(1), b: .intValue(2)) == .intValue(2))\n\
    assert(compare_one(a: .intValue(1), b: .doubleValue(2.5)) == .doubleValue(2.5))\n\
    assert(compare_one(a: .intValue(2), b: .intValue(3)) == .intValue(3))\nassert(compare_one(a:\
    \ .intValue(5), b: .intValue(6)) == .intValue(6))\nassert(compare_one(a: .intValue(1),\
    \ b: .stringValue(\"2,3\")) == .stringValue(\"2,3\"))\nassert(compare_one(a: .stringValue(\"\
    5,1\"), b: .stringValue(\"6\")) == .stringValue(\"6\"))\nassert(compare_one(a:\
    \ .stringValue(\"1\"), b: .stringValue(\"2\")) == .stringValue(\"2\"))\nassert(compare_one(a:\
    \ .stringValue(\"1\"), b: .intValue(1)) == nil)"
  status: Exception
  stderr: 'tmpllswmh2d/tmpllswmh2d.swift:38: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b05c2ae8c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b05c27dfb6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b05c27df988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b05c27de7b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpllswmh2d                        0x000055f806e32a56 <unavailable> + 6742

    5    libc.so.6                          0x00002b05c2cd4460 __libc_start_main +
    245

    6    tmpllswmh2d                        0x000055f806e32499 <unavailable> + 5273

    '
  stdout: ''
  timestamp: 1660013179
- exit_code: 1
  program: "\nenum Value: Equatable, Hashable {\n    case intValue(Int)\n    case\
    \ doubleValue(Double)\n    case stringValue(String)\n}\n\n            \n/// Create\
    \ a function that takes integers, floats, or strings representing\n/// real numbers,\
    \ and returns the larger variable in its given variable type.\n/// Return nil\
    \ if the values are equal.\n/// Note: If a real number is represented as a string,\
    \ the floating point might be . or ,\n/// >>> compare_one(a: .intValue(1), b:\
    \ .doubleValue(2.5))\n/// .doubleValue(2.5)\n/// >>> compare_one(a: .intValue(1),\
    \ b: .stringValue(\"2,3\"))\n/// .stringValue(\"2,3\")\n/// >>> compare_one(a:\
    \ .stringValue(\"5,1\"), b: .stringValue(\"6\"))\n/// .stringValue(\"6\")\n///\
    \ >>> compare_one(a: .stringValue(\"1\"), b: .intValue(1))\n/// nil\nfunc compare_one(a:\
    \ Value, b: Value) -> Value? {\n    // your code here\n    var result: Value?\n\
    \    switch (a, b) {\n    case (.intValue(let a), .intValue(let b)):\n       \
    \ result = (a > b) ? .intValue(a) : .intValue(b)\n    case (.intValue(let a),\
    \ .doubleValue(let b)):\n        result = (Double(a) > b) ? .intValue(a) : .doubleValue(b)\n\
    \    case (.intValue(let a), .stringValue(let b)):\n        result = (Double(a)\
    \ > Float(b)!) ? .intValue(a) : .stringValue(b)\n    case (.doubleValue(let a),\
    \ .intValue(let b)):\n        result = (a > Double(b)) ? .doubleValue(a) : .intValue(b)\n\
    \    case (.doubleValue(let a), .doubleValue(let b)):\n        result = (a > b)\
    \ ? .doubleValue(a) : .doubleValue(b)\n    case (.doubleValue(let a), .stringValue(let\
    \ b)):\n        result = (a > Float(b)!) ? .doubleValue(a) : .stringValue(b)\n\
    \    case (.stringValue(let a), .intValue(let b)):\n        result = (Float(a)!\
    \ > Double(b)) ? .stringValue(a) : .intValue(b)\n    case (.stringValue(let a),\
    \ .doubleValue(let b)):\n        result = (Float(a)! > b) ? .stringValue(a) :\
    \ .doubleValue(b)\n    case (.stringValue(let a), .stringValue(let b)):\n    \
    \    result = (Float(a)! > Float(b)!) ? .stringValue(a) : .stringValue(b)\n  \
    \  }\n    if a == b {\n        result = nil\n    }\n    return result\n}\n\n\n\
    func ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(compare_one(a: .intValue(1), b: .intValue(2))\
    \ == .intValue(2))\nassert(compare_one(a: .intValue(1), b: .doubleValue(2.5))\
    \ == .doubleValue(2.5))\nassert(compare_one(a: .intValue(2), b: .intValue(3))\
    \ == .intValue(3))\nassert(compare_one(a: .intValue(5), b: .intValue(6)) == .intValue(6))\n\
    assert(compare_one(a: .intValue(1), b: .stringValue(\"2,3\")) == .stringValue(\"\
    2,3\"))\nassert(compare_one(a: .stringValue(\"5,1\"), b: .stringValue(\"6\"))\
    \ == .stringValue(\"6\"))\nassert(compare_one(a: .stringValue(\"1\"), b: .stringValue(\"\
    2\")) == .stringValue(\"2\"))\nassert(compare_one(a: .stringValue(\"1\"), b: .intValue(1))\
    \ == nil)"
  status: SyntaxError
  stderr: "/tmp/tmp67p621lw.swift:30:29: error: binary operator '>' cannot be applied\
    \ to operands of type 'Double' and 'Float'\n        result = (Double(a) > Float(b)!)\
    \ ? .intValue(a) : .stringValue(b)\n                  ~~~~~~~~~ ^ ~~~~~~~~~\n\
    /tmp/tmp67p621lw.swift:36:21: error: binary operator '>' cannot be applied to\
    \ operands of type 'Double' and 'Float'\n        result = (a > Float(b)!) ? .doubleValue(a)\
    \ : .stringValue(b)\n                  ~ ^ ~~~~~~~~~\n/tmp/tmp67p621lw.swift:38:29:\
    \ error: binary operator '>' cannot be applied to operands of type 'Float' and\
    \ 'Double'\n        result = (Float(a)! > Double(b)) ? .stringValue(a) : .intValue(b)\n\
    \                  ~~~~~~~~~ ^ ~~~~~~~~~\n/tmp/tmp67p621lw.swift:40:29: error:\
    \ binary operator '>' cannot be applied to operands of type 'Float' and 'Double'\n\
    \        result = (Float(a)! > b) ? .stringValue(a) : .doubleValue(b)\n      \
    \            ~~~~~~~~~ ^ ~\n"
  stdout: ''
  timestamp: 1660013181
- exit_code: 1
  program: "\nenum Value: Equatable, Hashable {\n    case intValue(Int)\n    case\
    \ doubleValue(Double)\n    case stringValue(String)\n}\n\n            \n/// Create\
    \ a function that takes integers, floats, or strings representing\n/// real numbers,\
    \ and returns the larger variable in its given variable type.\n/// Return nil\
    \ if the values are equal.\n/// Note: If a real number is represented as a string,\
    \ the floating point might be . or ,\n/// >>> compare_one(a: .intValue(1), b:\
    \ .doubleValue(2.5))\n/// .doubleValue(2.5)\n/// >>> compare_one(a: .intValue(1),\
    \ b: .stringValue(\"2,3\"))\n/// .stringValue(\"2,3\")\n/// >>> compare_one(a:\
    \ .stringValue(\"5,1\"), b: .stringValue(\"6\"))\n/// .stringValue(\"6\")\n///\
    \ >>> compare_one(a: .stringValue(\"1\"), b: .intValue(1))\n/// nil\nfunc compare_one(a:\
    \ Value, b: Value) -> Value? {\n    switch (a, b) {\n    case (.intValue(let a),\
    \ .intValue(let b)):\n        return a > b ? a : b\n    case (.doubleValue(let\
    \ a), .doubleValue(let b)):\n        return a > b ? a : b\n    case (.stringValue(let\
    \ a), .stringValue(let b)):\n        if let a = Double(a), let b = Double(b) {\n\
    \            return a > b ? a : b\n        }\n        return nil\n    default:\n\
    \        return nil\n    }\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(compare_one(a:\
    \ .intValue(1), b: .intValue(2)) == .intValue(2))\nassert(compare_one(a: .intValue(1),\
    \ b: .doubleValue(2.5)) == .doubleValue(2.5))\nassert(compare_one(a: .intValue(2),\
    \ b: .intValue(3)) == .intValue(3))\nassert(compare_one(a: .intValue(5), b: .intValue(6))\
    \ == .intValue(6))\nassert(compare_one(a: .intValue(1), b: .stringValue(\"2,3\"\
    )) == .stringValue(\"2,3\"))\nassert(compare_one(a: .stringValue(\"5,1\"), b:\
    \ .stringValue(\"6\")) == .stringValue(\"6\"))\nassert(compare_one(a: .stringValue(\"\
    1\"), b: .stringValue(\"2\")) == .stringValue(\"2\"))\nassert(compare_one(a: .stringValue(\"\
    1\"), b: .intValue(1)) == nil)"
  status: SyntaxError
  stderr: "/tmp/tmprr0stqnw.swift:24:22: error: cannot convert return expression of\
    \ type 'Int' to return type 'Value?'\n        return a > b ? a : b\n         \
    \      ~~~~~~^~~~~~~\n/tmp/tmprr0stqnw.swift:26:22: error: cannot convert return\
    \ expression of type 'Double' to return type 'Value?'\n        return a > b ?\
    \ a : b\n               ~~~~~~^~~~~~~\n/tmp/tmprr0stqnw.swift:29:26: error: cannot\
    \ convert return expression of type 'Double' to return type 'Value?'\n       \
    \     return a > b ? a : b\n                   ~~~~~~^~~~~~~\n"
  stdout: ''
  timestamp: 1660013181
- exit_code: 1
  program: "\nenum Value: Equatable, Hashable {\n    case intValue(Int)\n    case\
    \ doubleValue(Double)\n    case stringValue(String)\n}\n\n            \n/// Create\
    \ a function that takes integers, floats, or strings representing\n/// real numbers,\
    \ and returns the larger variable in its given variable type.\n/// Return nil\
    \ if the values are equal.\n/// Note: If a real number is represented as a string,\
    \ the floating point might be . or ,\n/// >>> compare_one(a: .intValue(1), b:\
    \ .doubleValue(2.5))\n/// .doubleValue(2.5)\n/// >>> compare_one(a: .intValue(1),\
    \ b: .stringValue(\"2,3\"))\n/// .stringValue(\"2,3\")\n/// >>> compare_one(a:\
    \ .stringValue(\"5,1\"), b: .stringValue(\"6\"))\n/// .stringValue(\"6\")\n///\
    \ >>> compare_one(a: .stringValue(\"1\"), b: .intValue(1))\n/// nil\nfunc compare_one(a:\
    \ Value, b: Value) -> Value? {\n    // TODO: Implement me!\n    var aInt: Int\n\
    \    var bInt: Int\n    var aDouble: Double\n    var bDouble: Double\n    var\
    \ aString: String\n    var bString: String\n    \n    switch a {\n    case .intValue(let\
    \ value):\n        aInt = value\n    case .doubleValue(let value):\n        aDouble\
    \ = value\n    case .stringValue(let value):\n        aString = value\n    }\n\
    \    \n    switch b {\n    case .intValue(let value):\n        bInt = value\n\
    \    case .doubleValue(let value):\n        bDouble = value\n    case .stringValue(let\
    \ value):\n        bString = value\n    }\n    \n    if aInt > bInt {\n      \
    \  return a\n    } else if aInt < bInt {\n        return b\n    } else if aDouble\
    \ > bDouble {\n        return a\n    } else if aDouble < bDouble {\n        return\
    \ b\n    } else if aString > bString {\n        return a\n    } else if aString\
    \ < bString {\n        return b\n    } else {\n        return nil\n    }\n}\n\n\
    \nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(compare_one(a: .intValue(1), b: .intValue(2))\
    \ == .intValue(2))\nassert(compare_one(a: .intValue(1), b: .doubleValue(2.5))\
    \ == .doubleValue(2.5))\nassert(compare_one(a: .intValue(2), b: .intValue(3))\
    \ == .intValue(3))\nassert(compare_one(a: .intValue(5), b: .intValue(6)) == .intValue(6))\n\
    assert(compare_one(a: .intValue(1), b: .stringValue(\"2,3\")) == .stringValue(\"\
    2,3\"))\nassert(compare_one(a: .stringValue(\"5,1\"), b: .stringValue(\"6\"))\
    \ == .stringValue(\"6\"))\nassert(compare_one(a: .stringValue(\"1\"), b: .stringValue(\"\
    2\")) == .stringValue(\"2\"))\nassert(compare_one(a: .stringValue(\"1\"), b: .intValue(1))\
    \ == nil)"
  status: SyntaxError
  stderr: "/tmp/tmpxrs8qmxh.swift:48:8: error: variable 'aInt' used before being initialized\n\
    \    if aInt > bInt {\n       ^\n/tmp/tmpxrs8qmxh.swift:23:9: note: variable defined\
    \ here\n    var aInt: Int\n        ^\n/tmp/tmpxrs8qmxh.swift:50:15: error: variable\
    \ 'aInt' used before being initialized\n    } else if aInt < bInt {\n        \
    \      ^\n/tmp/tmpxrs8qmxh.swift:23:9: note: variable defined here\n    var aInt:\
    \ Int\n        ^\n/tmp/tmpxrs8qmxh.swift:48:15: error: variable 'bInt' used before\
    \ being initialized\n    if aInt > bInt {\n              ^\n/tmp/tmpxrs8qmxh.swift:24:9:\
    \ note: variable defined here\n    var bInt: Int\n        ^\n/tmp/tmpxrs8qmxh.swift:50:22:\
    \ error: variable 'bInt' used before being initialized\n    } else if aInt < bInt\
    \ {\n                     ^\n/tmp/tmpxrs8qmxh.swift:24:9: note: variable defined\
    \ here\n    var bInt: Int\n        ^\n/tmp/tmpxrs8qmxh.swift:52:15: error: variable\
    \ 'aDouble' used before being initialized\n    } else if aDouble > bDouble {\n\
    \              ^\n/tmp/tmpxrs8qmxh.swift:25:9: note: variable defined here\n \
    \   var aDouble: Double\n        ^\n/tmp/tmpxrs8qmxh.swift:54:15: error: variable\
    \ 'aDouble' used before being initialized\n    } else if aDouble < bDouble {\n\
    \              ^\n/tmp/tmpxrs8qmxh.swift:25:9: note: variable defined here\n \
    \   var aDouble: Double\n        ^\n/tmp/tmpxrs8qmxh.swift:52:25: error: variable\
    \ 'bDouble' used before being initialized\n    } else if aDouble > bDouble {\n\
    \                        ^\n/tmp/tmpxrs8qmxh.swift:26:9: note: variable defined\
    \ here\n    var bDouble: Double\n        ^\n/tmp/tmpxrs8qmxh.swift:54:25: error:\
    \ variable 'bDouble' used before being initialized\n    } else if aDouble < bDouble\
    \ {\n                        ^\n/tmp/tmpxrs8qmxh.swift:26:9: note: variable defined\
    \ here\n    var bDouble: Double\n        ^\n/tmp/tmpxrs8qmxh.swift:56:15: error:\
    \ variable 'aString' used before being initialized\n    } else if aString > bString\
    \ {\n              ^\n/tmp/tmpxrs8qmxh.swift:27:9: note: variable defined here\n\
    \    var aString: String\n        ^\n/tmp/tmpxrs8qmxh.swift:58:15: error: variable\
    \ 'aString' used"
  stdout: ''
  timestamp: 1660013181
- exit_code: -4
  program: "\nenum Value: Equatable, Hashable {\n    case intValue(Int)\n    case\
    \ doubleValue(Double)\n    case stringValue(String)\n}\n\n            \n/// Create\
    \ a function that takes integers, floats, or strings representing\n/// real numbers,\
    \ and returns the larger variable in its given variable type.\n/// Return nil\
    \ if the values are equal.\n/// Note: If a real number is represented as a string,\
    \ the floating point might be . or ,\n/// >>> compare_one(a: .intValue(1), b:\
    \ .doubleValue(2.5))\n/// .doubleValue(2.5)\n/// >>> compare_one(a: .intValue(1),\
    \ b: .stringValue(\"2,3\"))\n/// .stringValue(\"2,3\")\n/// >>> compare_one(a:\
    \ .stringValue(\"5,1\"), b: .stringValue(\"6\"))\n/// .stringValue(\"6\")\n///\
    \ >>> compare_one(a: .stringValue(\"1\"), b: .intValue(1))\n/// nil\nfunc compare_one(a:\
    \ Value, b: Value) -> Value? {\n    return nil\n}\n\n\nfunc ==(left: [(Int, Int)],\
    \ right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n       \
    \ return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r\
    \ {\n            return false\n        }\n    }\n    return true\n}\n        \
    \    \nassert(compare_one(a: .intValue(1), b: .intValue(2)) == .intValue(2))\n\
    assert(compare_one(a: .intValue(1), b: .doubleValue(2.5)) == .doubleValue(2.5))\n\
    assert(compare_one(a: .intValue(2), b: .intValue(3)) == .intValue(3))\nassert(compare_one(a:\
    \ .intValue(5), b: .intValue(6)) == .intValue(6))\nassert(compare_one(a: .intValue(1),\
    \ b: .stringValue(\"2,3\")) == .stringValue(\"2,3\"))\nassert(compare_one(a: .stringValue(\"\
    5,1\"), b: .stringValue(\"6\")) == .stringValue(\"6\"))\nassert(compare_one(a:\
    \ .stringValue(\"1\"), b: .stringValue(\"2\")) == .stringValue(\"2\"))\nassert(compare_one(a:\
    \ .stringValue(\"1\"), b: .intValue(1)) == nil)"
  status: Exception
  stderr: 'tmpllswmh2d/tmpllswmh2d.swift:38: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b05c2ae8c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b05c27dfb6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b05c27df988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b05c27de7b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpllswmh2d                        0x000055f806e32a56 <unavailable> + 6742

    5    libc.so.6                          0x00002b05c2cd4460 __libc_start_main +
    245

    6    tmpllswmh2d                        0x000055f806e32499 <unavailable> + 5273

    '
  stdout: ''
  timestamp: 1660013179
- exit_code: 1
  program: "\nenum Value: Equatable, Hashable {\n    case intValue(Int)\n    case\
    \ doubleValue(Double)\n    case stringValue(String)\n}\n\n            \n/// Create\
    \ a function that takes integers, floats, or strings representing\n/// real numbers,\
    \ and returns the larger variable in its given variable type.\n/// Return nil\
    \ if the values are equal.\n/// Note: If a real number is represented as a string,\
    \ the floating point might be . or ,\n/// >>> compare_one(a: .intValue(1), b:\
    \ .doubleValue(2.5))\n/// .doubleValue(2.5)\n/// >>> compare_one(a: .intValue(1),\
    \ b: .stringValue(\"2,3\"))\n/// .stringValue(\"2,3\")\n/// >>> compare_one(a:\
    \ .stringValue(\"5,1\"), b: .stringValue(\"6\"))\n/// .stringValue(\"6\")\n///\
    \ >>> compare_one(a: .stringValue(\"1\"), b: .intValue(1))\n/// nil\nfunc compare_one(a:\
    \ Value, b: Value) -> Value? {\n    switch a {\n    case .intValue(let intA):\n\
    \        switch b {\n        case .intValue(let intB):\n            return intA\
    \ >= intB ? a : b\n        case .doubleValue(let doubleB):\n            return\
    \ intA >= doubleB ? a : b\n        case .stringValue(let stringB):\n         \
    \   return Double(stringB) >= intA ? b : a\n        }\n    case .doubleValue(let\
    \ doubleA):\n        switch b {\n        case .intValue(let intB):\n         \
    \   return doubleA >= intB ? a : b\n        case .doubleValue(let doubleB):\n\
    \            return doubleA >= doubleB ? a : b\n        case .stringValue(let\
    \ stringB):\n            return Double(stringB) >= doubleA ? b : a\n        }\n\
    \    case .stringValue(let stringA):\n        switch b {\n        case .intValue(let\
    \ intB):\n            return Double(stringA) >= intB ? a : b\n        case .doubleValue(let\
    \ doubleB):\n            return Double(stringA) >= doubleB ? a : b\n        case\
    \ .stringValue(let stringB):\n            return Double(stringA) >= Double(stringB)\
    \ ? a : b\n        }\n    }\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int,\
    \ Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n\
    \    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n          \
    \  return false\n        }\n    }\n    return true\n}\n            \nassert(compare_one(a:\
    \ .intValue(1), b: .intValue(2)) == .intValue(2))\nassert(compare_one(a: .intValue(1),\
    \ b: .doubleValue(2.5)) == .doubleValue(2.5))\nassert(compare_one(a: .intValue(2),\
    \ b: .intValue(3)) == .intValue(3))\nassert(compare_one(a: .intValue(5), b: .intValue(6))\
    \ == .intValue(6))\nassert(compare_one(a: .intValue(1), b: .stringValue(\"2,3\"\
    )) == .stringValue(\"2,3\"))\nassert(compare_one(a: .stringValue(\"5,1\"), b:\
    \ .stringValue(\"6\")) == .stringValue(\"6\"))\nassert(compare_one(a: .stringValue(\"\
    1\"), b: .stringValue(\"2\")) == .stringValue(\"2\"))\nassert(compare_one(a: .stringValue(\"\
    1\"), b: .intValue(1)) == nil)"
  status: SyntaxError
  stderr: "/tmp/tmp0k5asu9j.swift:28:28: error: cannot convert value of type 'Double'\
    \ to expected argument type 'Int'\n            return intA >= doubleB ? a : b\n\
    \                           ^\n                           Int(   )\n/tmp/tmp0k5asu9j.swift:30:20:\
    \ error: cannot convert value of type 'Double?' to expected argument type 'Int'\n\
    \            return Double(stringB) >= intA ? b : a\n                   ^\n/tmp/tmp0k5asu9j.swift:35:20:\
    \ error: cannot convert value of type 'Double' to expected argument type 'Int'\n\
    \            return doubleA >= intB ? a : b\n                   ^\n          \
    \         Int(   )\n/tmp/tmp0k5asu9j.swift:39:20: error: value of optional type\
    \ 'Double?' must be unwrapped to a value of type 'Double'\n            return\
    \ Double(stringB) >= doubleA ? b : a\n                   ^\n/tmp/tmp0k5asu9j.swift:39:20:\
    \ note: coalesce using '??' to provide a default when the optional value contains\
    \ 'nil'\n            return Double(stringB) >= doubleA ? b : a\n             \
    \      ^\n                                   ?? <#default value#>\n/tmp/tmp0k5asu9j.swift:39:20:\
    \ note: force-unwrap using '!' to abort execution if the optional value contains\
    \ 'nil'\n            return Double(stringB) >= doubleA ? b : a\n             \
    \      ^\n                                  !\n/tmp/tmp0k5asu9j.swift:44:20: error:\
    \ cannot convert value of type 'Double?' to expected argument type 'Int'\n   \
    \         return Double(stringA) >= intB ? a : b\n                   ^\n/tmp/tmp0k5asu9j.swift:46:20:\
    \ error: value of optional type 'Double?' must be unwrapped to a value of type\
    \ 'Double'\n            return Double(stringA) >= doubleB ? a : b\n          \
    \         ^\n/tmp/tmp0k5asu9j.swift:46:20: note: coalesce using '??' to provide\
    \ a default when the optional value contains 'nil'\n            return Double(stringA)\
    \ >= doubleB ? a : b\n                   ^\n                                 \
    \  ?? <#default value#>\n/tmp/tmp0k5asu9j.swift:46:20: note: force-unwrap using\
    \ '!' to abort execution if the optional value contains 'nil'\n            return\
    \ Double(stringA) >= doubleB ? a : b\n   "
  stdout: ''
  timestamp: 1660013181
- exit_code: -4
  program: "\nenum Value: Equatable, Hashable {\n    case intValue(Int)\n    case\
    \ doubleValue(Double)\n    case stringValue(String)\n}\n\n            \n/// Create\
    \ a function that takes integers, floats, or strings representing\n/// real numbers,\
    \ and returns the larger variable in its given variable type.\n/// Return nil\
    \ if the values are equal.\n/// Note: If a real number is represented as a string,\
    \ the floating point might be . or ,\n/// >>> compare_one(a: .intValue(1), b:\
    \ .doubleValue(2.5))\n/// .doubleValue(2.5)\n/// >>> compare_one(a: .intValue(1),\
    \ b: .stringValue(\"2,3\"))\n/// .stringValue(\"2,3\")\n/// >>> compare_one(a:\
    \ .stringValue(\"5,1\"), b: .stringValue(\"6\"))\n/// .stringValue(\"6\")\n///\
    \ >>> compare_one(a: .stringValue(\"1\"), b: .intValue(1))\n/// nil\nfunc compare_one(a:\
    \ Value, b: Value) -> Value? {\n    // TODO: Your code here\n    return nil\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(compare_one(a: .intValue(1), b: .intValue(2))\
    \ == .intValue(2))\nassert(compare_one(a: .intValue(1), b: .doubleValue(2.5))\
    \ == .doubleValue(2.5))\nassert(compare_one(a: .intValue(2), b: .intValue(3))\
    \ == .intValue(3))\nassert(compare_one(a: .intValue(5), b: .intValue(6)) == .intValue(6))\n\
    assert(compare_one(a: .intValue(1), b: .stringValue(\"2,3\")) == .stringValue(\"\
    2,3\"))\nassert(compare_one(a: .stringValue(\"5,1\"), b: .stringValue(\"6\"))\
    \ == .stringValue(\"6\"))\nassert(compare_one(a: .stringValue(\"1\"), b: .stringValue(\"\
    2\")) == .stringValue(\"2\"))\nassert(compare_one(a: .stringValue(\"1\"), b: .intValue(1))\
    \ == nil)"
  status: Exception
  stderr: 'tmpm7w5q_b6/tmpm7w5q_b6.swift:39: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002af452e89c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002af452b80b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002af452b80988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002af452b7f7b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpm7w5q_b6                        0x0000562dd6607a56 <unavailable> + 6742

    5    libc.so.6                          0x00002af453075460 __libc_start_main +
    245

    6    tmpm7w5q_b6                        0x0000562dd6607499 <unavailable> + 5273

    '
  stdout: ''
  timestamp: 1660013181
- exit_code: 1
  program: "\nenum Value: Equatable, Hashable {\n    case intValue(Int)\n    case\
    \ doubleValue(Double)\n    case stringValue(String)\n}\n\n            \n/// Create\
    \ a function that takes integers, floats, or strings representing\n/// real numbers,\
    \ and returns the larger variable in its given variable type.\n/// Return nil\
    \ if the values are equal.\n/// Note: If a real number is represented as a string,\
    \ the floating point might be . or ,\n/// >>> compare_one(a: .intValue(1), b:\
    \ .doubleValue(2.5))\n/// .doubleValue(2.5)\n/// >>> compare_one(a: .intValue(1),\
    \ b: .stringValue(\"2,3\"))\n/// .stringValue(\"2,3\")\n/// >>> compare_one(a:\
    \ .stringValue(\"5,1\"), b: .stringValue(\"6\"))\n/// .stringValue(\"6\")\n///\
    \ >>> compare_one(a: .stringValue(\"1\"), b: .intValue(1))\n/// nil\nfunc compare_one(a:\
    \ Value, b: Value) -> Value? {\n    switch (a, b) {\n    case let (.intValue(x),\
    \ .intValue(y)) where x == y:\n        return nil\n    case let (.intValue(x),\
    \ .intValue(y)) where x > y:\n        return a\n    case let (.intValue(x), .intValue(y))\
    \ where x < y:\n        return b\n    case let (.intValue(x), .doubleValue(y))\
    \ where x > y:\n        return a\n    case let (.intValue(x), .doubleValue(y))\
    \ where x < y:\n        return b\n    case let (.intValue(x), .doubleValue(y))\
    \ where x == y:\n        return b\n    case let (.intValue(x), .stringValue(y))\
    \ where x > Double(y)!:\n        return a\n    case let (.intValue(x), .stringValue(y))\
    \ where x < Double(y)!:\n        return b\n    case let (.intValue(x), .stringValue(y))\
    \ where x == Double(y)!:\n        return b\n    case let (.doubleValue(x), .intValue(y))\
    \ where x > y:\n        return a\n    case let (.doubleValue(x), .intValue(y))\
    \ where x < y:\n        return b\n    case let (.doubleValue(x), .intValue(y))\
    \ where x == y:\n        return a\n    case let (.doubleValue(x), .doubleValue(y))\
    \ where x == y:\n        return nil\n    case let (.doubleValue(x), .doubleValue(y))\
    \ where x > y:\n        return a\n    case let (.doubleValue(x), .doubleValue(y))\
    \ where x < y:\n        return b\n    case let (.doubleValue(x), .stringValue(y))\
    \ where x > Double(y)!:\n        return a\n    case let (.doubleValue(x), .stringValue(y))\
    \ where x < Double(y)!:\n        return b\n    case let (.doubleValue(x), .stringValue(y))\
    \ where x == Double(y)!:\n        return a\n    case let (.stringValue(x), .intValue(y))\
    \ where Double(x)! > y:\n        return a\n    case let (.stringValue\n}\n\n\n\
    func ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(compare_one(a: .intValue(1), b: .intValue(2))\
    \ == .intValue(2))\nassert(compare_one(a: .intValue(1), b: .doubleValue(2.5))\
    \ == .doubleValue(2.5))\nassert(compare_one(a: .intValue(2), b: .intValue(3))\
    \ == .intValue(3))\nassert(compare_one(a: .intValue(5), b: .intValue(6)) == .intValue(6))\n\
    assert(compare_one(a: .intValue(1), b: .stringValue(\"2,3\")) == .stringValue(\"\
    2,3\"))\nassert(compare_one(a: .stringValue(\"5,1\"), b: .stringValue(\"6\"))\
    \ == .stringValue(\"6\"))\nassert(compare_one(a: .stringValue(\"1\"), b: .stringValue(\"\
    2\")) == .stringValue(\"2\"))\nassert(compare_one(a: .stringValue(\"1\"), b: .intValue(1))\
    \ == nil)"
  status: SyntaxError
  stderr: "/tmp/tmpb53l9yrm.swift:62:1: error: expected ')' in expression list\n}\n\
    ^\n/tmp/tmpb53l9yrm.swift:61:14: note: to match this opening '('\n    case let\
    \ (.stringValue\n             ^\n/tmp/tmpb53l9yrm.swift:61:27: error: expected\
    \ ':' after 'case'\n    case let (.stringValue\n                          ^\n\
    /tmp/tmpb53l9yrm.swift:84:66: error: expected '}' at end of brace statement\n\
    assert(compare_one(a: .stringValue(\"1\"), b: .intValue(1)) == nil)\n        \
    \                                                         ^\n/tmp/tmpb53l9yrm.swift:21:48:\
    \ note: to match this opening '{'\nfunc compare_one(a: Value, b: Value) -> Value?\
    \ {\n                                               ^\n/tmp/tmpb53l9yrm.swift:29:54:\
    \ error: binary operator '>' cannot be applied to operands of type 'Int' and 'Double'\n\
    \    case let (.intValue(x), .doubleValue(y)) where x > y:\n                 \
    \                                  ~ ^ ~\n/tmp/tmpb53l9yrm.swift:29:54: note:\
    \ overloads for '>' exist with these partially matching parameter lists: (Int,\
    \ Int)\n    case let (.intValue(x), .doubleValue(y)) where x > y:\n          \
    \                                           ^\n/tmp/tmpb53l9yrm.swift:31:54: error:\
    \ binary operator '<' cannot be applied to operands of type 'Int' and 'Double'\n\
    \    case let (.intValue(x), .doubleValue(y)) where x < y:\n                 \
    \                                  ~ ^ ~\n/tmp/tmpb53l9yrm.swift:31:54: note:\
    \ overloads for '<' exist with these partially matching parameter lists: (Int,\
    \ Int)\n    case let (.intValue(x), .doubleValue(y)) where x < y:\n          \
    \                                           ^\n/tmp/tmpb53l9yrm.swift:33:54: error:\
    \ binary operator '==' cannot be applied to operands of type 'Int' and 'Double'\n\
    \    case let (.intValue(x), .doubleValue(y)) where x == y:\n                \
    \                                   ~ ^  ~\n/tmp/tmpb53l9yrm.swift:33:54: note:\
    \ overloads for '==' exist with these partially matching parameter lists: (Int,\
    \ Int)\n    case let (.intValue(x), .doubleValue(y)) where x == y:\n         \
    \                                            ^\n"
  stdout: ''
  timestamp: 1660013181
- exit_code: 1
  program: "\nenum Value: Equatable, Hashable {\n    case intValue(Int)\n    case\
    \ doubleValue(Double)\n    case stringValue(String)\n}\n\n            \n/// Create\
    \ a function that takes integers, floats, or strings representing\n/// real numbers,\
    \ and returns the larger variable in its given variable type.\n/// Return nil\
    \ if the values are equal.\n/// Note: If a real number is represented as a string,\
    \ the floating point might be . or ,\n/// >>> compare_one(a: .intValue(1), b:\
    \ .doubleValue(2.5))\n/// .doubleValue(2.5)\n/// >>> compare_one(a: .intValue(1),\
    \ b: .stringValue(\"2,3\"))\n/// .stringValue(\"2,3\")\n/// >>> compare_one(a:\
    \ .stringValue(\"5,1\"), b: .stringValue(\"6\"))\n/// .stringValue(\"6\")\n///\
    \ >>> compare_one(a: .stringValue(\"1\"), b: .intValue(1))\n/// nil\nfunc compare_one(a:\
    \ Value, b: Value) -> Value? {\n    var a: Double\n    var b: Double\n    switch\
    \ a {\n    case .intValue(let intValue):\n        a = Double(intValue)\n    case\
    \ .doubleValue(let doubleValue):\n        a = doubleValue\n    case .stringValue(let\
    \ stringValue):\n        a = Double(stringValue.replacingOccurrences(of: \",\"\
    , with: \".\")) ?? 0\n    }\n    switch b {\n    case .intValue(let intValue):\n\
    \        b = Double(intValue)\n    case .doubleValue(let doubleValue):\n     \
    \   b = doubleValue\n    case .stringValue(let stringValue):\n        b = Double(stringValue.replacingOccurrences(of:\
    \ \",\", with: \".\")) ?? 0\n    }\n    switch (a, b) {\n    case (let a, let\
    \ b) where a == b:\n        return nil\n    case (let a, let b) where a > b:\n\
    \        return a\n    case (let a, let b) where a < b:\n        return b\n  \
    \  default:\n        return nil\n    }\n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(compare_one(a: .intValue(1), b: .intValue(2)) == .intValue(2))\nassert(compare_one(a:\
    \ .intValue(1), b: .doubleValue(2.5)) == .doubleValue(2.5))\nassert(compare_one(a:\
    \ .intValue(2), b: .intValue(3)) == .intValue(3))\nassert(compare_one(a: .intValue(5),\
    \ b: .intValue(6)) == .intValue(6))\nassert(compare_one(a: .intValue(1), b: .stringValue(\"\
    2,3\")) == .stringValue(\"2,3\"))\nassert(compare_one(a: .stringValue(\"5,1\"\
    ), b: .stringValue(\"6\")) == .stringValue(\"6\"))\nassert(compare_one(a: .stringValue(\"\
    1\"), b: .stringValue(\"2\")) == .stringValue(\"2\"))\nassert(compare_one(a: .stringValue(\"\
    1\"), b: .intValue(1)) == nil)"
  status: SyntaxError
  stderr: "/tmp/tmpiebzm1ks.swift:25:11: error: type 'Double' has no member 'intValue'\n\
    \    case .intValue(let intValue):\n         ~^~~~~~~~\n/tmp/tmpiebzm1ks.swift:27:11:\
    \ error: type 'Double' has no member 'doubleValue'\n    case .doubleValue(let\
    \ doubleValue):\n         ~^~~~~~~~~~~\n/tmp/tmpiebzm1ks.swift:29:11: error: type\
    \ 'Double' has no member 'stringValue'\n    case .stringValue(let stringValue):\n\
    \         ~^~~~~~~~~~~\n/tmp/tmpiebzm1ks.swift:33:11: error: type 'Double' has\
    \ no member 'intValue'\n    case .intValue(let intValue):\n         ~^~~~~~~~\n\
    /tmp/tmpiebzm1ks.swift:35:11: error: type 'Double' has no member 'doubleValue'\n\
    \    case .doubleValue(let doubleValue):\n         ~^~~~~~~~~~~\n/tmp/tmpiebzm1ks.swift:37:11:\
    \ error: type 'Double' has no member 'stringValue'\n    case .stringValue(let\
    \ stringValue):\n         ~^~~~~~~~~~~\n/tmp/tmpiebzm1ks.swift:44:16: error: cannot\
    \ convert return expression of type 'Double' to return type 'Value?'\n       \
    \ return a\n               ^\n/tmp/tmpiebzm1ks.swift:46:16: error: cannot convert\
    \ return expression of type 'Double' to return type 'Value?'\n        return b\n\
    \               ^\n"
  stdout: ''
  timestamp: 1660013181
- exit_code: 1
  program: "\nenum Value: Equatable, Hashable {\n    case intValue(Int)\n    case\
    \ doubleValue(Double)\n    case stringValue(String)\n}\n\n            \n/// Create\
    \ a function that takes integers, floats, or strings representing\n/// real numbers,\
    \ and returns the larger variable in its given variable type.\n/// Return nil\
    \ if the values are equal.\n/// Note: If a real number is represented as a string,\
    \ the floating point might be . or ,\n/// >>> compare_one(a: .intValue(1), b:\
    \ .doubleValue(2.5))\n/// .doubleValue(2.5)\n/// >>> compare_one(a: .intValue(1),\
    \ b: .stringValue(\"2,3\"))\n/// .stringValue(\"2,3\")\n/// >>> compare_one(a:\
    \ .stringValue(\"5,1\"), b: .stringValue(\"6\"))\n/// .stringValue(\"6\")\n///\
    \ >>> compare_one(a: .stringValue(\"1\"), b: .intValue(1))\n/// nil\nfunc compare_one(a:\
    \ Value, b: Value) -> Value? {\n    switch (a, b) {\n    case (.intValue(let a),\
    \ .intValue(let b)):\n        return a > b ? a : b\n    case (.doubleValue(let\
    \ a), .doubleValue(let b)):\n        return a > b ? a : b\n    case (.stringValue(let\
    \ a), .stringValue(let b)):\n        return a > b ? a : b\n    case (.stringValue(let\
    \ a), .intValue(let b)):\n        if let aDouble = Double(a) {\n            return\
    \ aDouble > Double(b) ? a : nil\n        }\n    case (.intValue(let a), .stringValue(let\
    \ b)):\n        if let bDouble = Double(b) {\n            return Double(a) > bDouble\
    \ ? b : nil\n        }\n    case (.stringValue(let a), .doubleValue(let b)):\n\
    \        if let aDouble = Double(a) {\n            return aDouble > b ? a : nil\n\
    \        }\n    case (.doubleValue(let a), .stringValue(let b)):\n        if let\
    \ bDouble = Double(b) {\n            return a > bDouble ? b : nil\n        }\n\
    \    case (.doubleValue(let a), .intValue(let b)):\n        return a > Double(b)\
    \ ? a : nil\n    case (.intValue(let a), .doubleValue(let b)):\n        return\
    \ Double(a) > b ? b : nil\n    }\n    return nil\n}\n\n\nfunc ==(left: [(Int,\
    \ Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n\
    \        return false\n    }\n    for (l, r) in zip(left, right) {\n        if\
    \ l != r {\n            return false\n        }\n    }\n    return true\n}\n \
    \           \nassert(compare_one(a: .intValue(1), b: .intValue(2)) == .intValue(2))\n\
    assert(compare_one(a: .intValue(1), b: .doubleValue(2.5)) == .doubleValue(2.5))\n\
    assert(compare_one(a: .intValue(2), b: .intValue(3)) == .intValue(3))\nassert(compare_one(a:\
    \ .intValue(5), b: .intValue(6)) == .intValue(6))\nassert(compare_one(a: .intValue(1),\
    \ b: .stringValue(\"2,3\")) == .stringValue(\"2,3\"))\nassert(compare_one(a: .stringValue(\"\
    5,1\"), b: .stringValue(\"6\")) == .stringValue(\"6\"))\nassert(compare_one(a:\
    \ .stringValue(\"1\"), b: .stringValue(\"2\")) == .stringValue(\"2\"))\nassert(compare_one(a:\
    \ .stringValue(\"1\"), b: .intValue(1)) == nil)"
  status: SyntaxError
  stderr: "/tmp/tmpyuucsgik.swift:24:22: error: cannot convert return expression of\
    \ type 'Int' to return type 'Value?'\n        return a > b ? a : b\n         \
    \      ~~~~~~^~~~~~~\n/tmp/tmpyuucsgik.swift:26:22: error: cannot convert return\
    \ expression of type 'Double' to return type 'Value?'\n        return a > b ?\
    \ a : b\n               ~~~~~~^~~~~~~\n/tmp/tmpyuucsgik.swift:28:22: error: cannot\
    \ convert return expression of type 'String' to return type 'Value?'\n       \
    \ return a > b ? a : b\n               ~~~~~~^~~~~~~\n/tmp/tmpyuucsgik.swift:31:40:\
    \ error: cannot convert return expression of type 'String' to return type 'Value?'\n\
    \            return aDouble > Double(b) ? a : nil\n                   ~~~~~~~~~~~~~~~~~~~~^~~~~~~~~\n\
    /tmp/tmpyuucsgik.swift:35:40: error: cannot convert return expression of type\
    \ 'String' to return type 'Value?'\n            return Double(a) > bDouble ? b\
    \ : nil\n                   ~~~~~~~~~~~~~~~~~~~~^~~~~~~~~\n/tmp/tmpyuucsgik.swift:39:32:\
    \ error: cannot convert return expression of type 'String' to return type 'Value?'\n\
    \            return aDouble > b ? a : nil\n                   ~~~~~~~~~~~~^~~~~~~~~\n\
    /tmp/tmpyuucsgik.swift:43:32: error: cannot convert return expression of type\
    \ 'String' to return type 'Value?'\n            return a > bDouble ? b : nil\n\
    \                   ~~~~~~~~~~~~^~~~~~~~~\n/tmp/tmpyuucsgik.swift:46:30: error:\
    \ cannot convert return expression of type 'Double' to return type 'Value?'\n\
    \        return a > Double(b) ? a : nil\n               ~~~~~~~~~~~~~~^~~~~~~~~\n\
    /tmp/tmpyuucsgik.swift:48:30: error: cannot convert return expression of type\
    \ 'Double' to return type 'Value?'\n        return Double(a) > b ? b : nil\n \
    \              ~~~~~~~~~~~~~~^~~~~~~~~\n"
  stdout: ''
  timestamp: 1660013181
- exit_code: 1
  program: "\nenum Value: Equatable, Hashable {\n    case intValue(Int)\n    case\
    \ doubleValue(Double)\n    case stringValue(String)\n}\n\n            \n/// Create\
    \ a function that takes integers, floats, or strings representing\n/// real numbers,\
    \ and returns the larger variable in its given variable type.\n/// Return nil\
    \ if the values are equal.\n/// Note: If a real number is represented as a string,\
    \ the floating point might be . or ,\n/// >>> compare_one(a: .intValue(1), b:\
    \ .doubleValue(2.5))\n/// .doubleValue(2.5)\n/// >>> compare_one(a: .intValue(1),\
    \ b: .stringValue(\"2,3\"))\n/// .stringValue(\"2,3\")\n/// >>> compare_one(a:\
    \ .stringValue(\"5,1\"), b: .stringValue(\"6\"))\n/// .stringValue(\"6\")\n///\
    \ >>> compare_one(a: .stringValue(\"1\"), b: .intValue(1))\n/// nil\nfunc compare_one(a:\
    \ Value, b: Value) -> Value? {\n    // my code\n    switch (a, b) {\n    case\
    \ let (.intValue(a), .intValue(b)) where a > b:\n        return .intValue(a)\n\
    \    case let (.intValue(a), .intValue(b)) where a < b:\n        return .intValue(b)\n\
    \    case let (.intValue(a), .doubleValue(b)) where a > b:\n        return .intValue(a)\n\
    \    case let (.intValue(a), .doubleValue(b)) where a < b:\n        return .doubleValue(b)\n\
    \    case let (.intValue(a), .stringValue(b)) where Double(b)! > Double(a):\n\
    \        return .stringValue(b)\n    case let (.intValue(a), .stringValue(b))\
    \ where Double(b)! < Double(a):\n        return .intValue(a)\n    case let (.doubleValue(a),\
    \ .intValue(b)) where a > b:\n        return .doubleValue(a)\n    case let (.doubleValue(a),\
    \ .intValue(b)) where a < b:\n        return .intValue(b)\n    case let (.doubleValue(a),\
    \ .doubleValue(b)) where a > b:\n        return .doubleValue(a)\n    case let\
    \ (.doubleValue(a), .doubleValue(b)) where a < b:\n        return .doubleValue(b)\n\
    \    case let (.doubleValue(a), .stringValue(b)) where Double(b)! > a:\n     \
    \   return .stringValue(b)\n    case let (.doubleValue(a), .stringValue(b)) where\
    \ Double(b)! < a:\n        return .doubleValue(a)\n    case let (.stringValue(a),\
    \ .intValue(b)) where Double(a)! > Double(b):\n        return .stringValue(a)\n\
    \    case let (.stringValue(a), .intValue(b)) where Double(a)! < Double(b):\n\
    \        return .intValue(b)\n    case let (.stringValue(a), .doubleValue(b))\
    \ where Double(a)! > b:\n        return .stringValue(a)\n    case let (.stringValue(a),\
    \ .doubleValue(b)) where Double(\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int,\
    \ Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n\
    \    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n          \
    \  return false\n        }\n    }\n    return true\n}\n            \nassert(compare_one(a:\
    \ .intValue(1), b: .intValue(2)) == .intValue(2))\nassert(compare_one(a: .intValue(1),\
    \ b: .doubleValue(2.5)) == .doubleValue(2.5))\nassert(compare_one(a: .intValue(2),\
    \ b: .intValue(3)) == .intValue(3))\nassert(compare_one(a: .intValue(5), b: .intValue(6))\
    \ == .intValue(6))\nassert(compare_one(a: .intValue(1), b: .stringValue(\"2,3\"\
    )) == .stringValue(\"2,3\"))\nassert(compare_one(a: .stringValue(\"5,1\"), b:\
    \ .stringValue(\"6\")) == .stringValue(\"6\"))\nassert(compare_one(a: .stringValue(\"\
    1\"), b: .stringValue(\"2\")) == .stringValue(\"2\"))\nassert(compare_one(a: .stringValue(\"\
    1\"), b: .intValue(1)) == nil)"
  status: SyntaxError
  stderr: "/tmp/tmps0o8pk2a.swift:55:1: error: expected expression in list of expressions\n\
    }\n^\n/tmp/tmps0o8pk2a.swift:54:62: error: expected ':' after 'case'\n    case\
    \ let (.stringValue(a), .doubleValue(b)) where Double(\n                     \
    \                                        ^\n/tmp/tmps0o8pk2a.swift:77:66: error:\
    \ expected '}' at end of brace statement\nassert(compare_one(a: .stringValue(\"\
    1\"), b: .intValue(1)) == nil)\n                                             \
    \                    ^\n/tmp/tmps0o8pk2a.swift:21:48: note: to match this opening\
    \ '{'\nfunc compare_one(a: Value, b: Value) -> Value? {\n                    \
    \                           ^\n/tmp/tmps0o8pk2a.swift:28:54: error: binary operator\
    \ '>' cannot be applied to operands of type 'Int' and 'Double'\n    case let (.intValue(a),\
    \ .doubleValue(b)) where a > b:\n                                            \
    \       ~ ^ ~\n/tmp/tmps0o8pk2a.swift:28:54: note: overloads for '>' exist with\
    \ these partially matching parameter lists: (Int, Int)\n    case let (.intValue(a),\
    \ .doubleValue(b)) where a > b:\n                                            \
    \         ^\n/tmp/tmps0o8pk2a.swift:30:54: error: binary operator '<' cannot be\
    \ applied to operands of type 'Int' and 'Double'\n    case let (.intValue(a),\
    \ .doubleValue(b)) where a < b:\n                                            \
    \       ~ ^ ~\n/tmp/tmps0o8pk2a.swift:30:54: note: overloads for '<' exist with\
    \ these partially matching parameter lists: (Int, Int)\n    case let (.intValue(a),\
    \ .doubleValue(b)) where a < b:\n                                            \
    \         ^\n/tmp/tmps0o8pk2a.swift:36:54: error: binary operator '>' cannot be\
    \ applied to operands of type 'Double' and 'Int'\n    case let (.doubleValue(a),\
    \ .intValue(b)) where a > b:\n                                               \
    \    ~ ^ ~\n/tmp/tmps0o8pk2a.swift:36:54: note: overloads for '>' exist with these\
    \ partially matching parameter lists: (Int, Int)\n    case let (.doubleValue(a),\
    \ .intValue(b)) where a > b:\n                                               \
    \      ^\n/tmp/tmps0o8pk2a.swift:38:54"
  stdout: ''
  timestamp: 1660013181
- exit_code: 1
  program: "\nenum Value: Equatable, Hashable {\n    case intValue(Int)\n    case\
    \ doubleValue(Double)\n    case stringValue(String)\n}\n\n            \n/// Create\
    \ a function that takes integers, floats, or strings representing\n/// real numbers,\
    \ and returns the larger variable in its given variable type.\n/// Return nil\
    \ if the values are equal.\n/// Note: If a real number is represented as a string,\
    \ the floating point might be . or ,\n/// >>> compare_one(a: .intValue(1), b:\
    \ .doubleValue(2.5))\n/// .doubleValue(2.5)\n/// >>> compare_one(a: .intValue(1),\
    \ b: .stringValue(\"2,3\"))\n/// .stringValue(\"2,3\")\n/// >>> compare_one(a:\
    \ .stringValue(\"5,1\"), b: .stringValue(\"6\"))\n/// .stringValue(\"6\")\n///\
    \ >>> compare_one(a: .stringValue(\"1\"), b: .intValue(1))\n/// nil\nfunc compare_one(a:\
    \ Value, b: Value) -> Value? {\n    switch a {\n    case .intValue(let a):\n \
    \       switch b {\n        case .intValue(let b):\n            return a > b ?\
    \ a : b\n        case .doubleValue(let b):\n            return a > b ? a : b\n\
    \        case .stringValue(let b):\n            return a > Double(b) ? a : b\n\
    \        }\n    case .doubleValue(let a):\n        switch b {\n        case .intValue(let\
    \ b):\n            return a > b ? a : b\n        case .doubleValue(let b):\n \
    \           return a > b ? a : b\n        case .stringValue(let b):\n        \
    \    return a > Double(b) ? a : b\n        }\n    case .stringValue(let a):\n\
    \        switch b {\n        case .intValue(let b):\n            return Double(a)\
    \ > b ? a : b\n        case .doubleValue(let b):\n            return Double(a)\
    \ > b ? a : b\n        case .stringValue(let b):\n            return Double(a)\
    \ > Double(b) ? a : b\n        }\n    }\n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(compare_one(a: .intValue(1), b: .intValue(2)) == .intValue(2))\nassert(compare_one(a:\
    \ .intValue(1), b: .doubleValue(2.5)) == .doubleValue(2.5))\nassert(compare_one(a:\
    \ .intValue(2), b: .intValue(3)) == .intValue(3))\nassert(compare_one(a: .intValue(5),\
    \ b: .intValue(6)) == .intValue(6))\nassert(compare_one(a: .intValue(1), b: .stringValue(\"\
    2,3\")) == .stringValue(\"2,3\"))\nassert(compare_one(a: .stringValue(\"5,1\"\
    ), b: .stringValue(\"6\")) == .stringValue(\"6\"))\nassert(compare_one(a: .stringValue(\"\
    1\"), b: .stringValue(\"2\")) == .stringValue(\"2\"))\nassert(compare_one(a: .stringValue(\"\
    1\"), b: .intValue(1)) == nil)"
  status: SyntaxError
  stderr: "/tmp/tmpxcr4o5ir.swift:26:26: error: cannot convert return expression of\
    \ type 'Int' to return type 'Value?'\n            return a > b ? a : b\n     \
    \              ~~~~~~^~~~~~~\n/tmp/tmpxcr4o5ir.swift:28:24: error: cannot convert\
    \ value of type 'Double' to expected argument type 'Int'\n            return a\
    \ > b ? a : b\n                       ^\n                       Int( )\n/tmp/tmpxcr4o5ir.swift:28:26:\
    \ error: cannot convert return expression of type 'Int' to return type 'Value?'\n\
    \            return a > b ? a : b\n                   ~~~~~~^~~~~~~\n/tmp/tmpxcr4o5ir.swift:30:24:\
    \ error: cannot convert value of type 'Double?' to expected argument type 'Int'\n\
    \            return a > Double(b) ? a : b\n                       ^\n/tmp/tmpxcr4o5ir.swift:30:34:\
    \ error: cannot convert return expression of type 'Int' to return type 'Value?'\n\
    \            return a > Double(b) ? a : b\n                   ~~~~~~~~~~~~~~^~~~~~~\n\
    /tmp/tmpxcr4o5ir.swift:35:20: error: cannot convert value of type 'Double' to\
    \ expected argument type 'Int'\n            return a > b ? a : b\n           \
    \        ^\n                   Int( )\n/tmp/tmpxcr4o5ir.swift:35:26: error: cannot\
    \ convert return expression of type 'Double' to return type 'Value?'\n       \
    \     return a > b ? a : b\n                   ~~~~~~^~~~~~~\n/tmp/tmpxcr4o5ir.swift:37:26:\
    \ error: cannot convert return expression of type 'Double' to return type 'Value?'\n\
    \            return a > b ? a : b\n                   ~~~~~~^~~~~~~\n/tmp/tmpxcr4o5ir.swift:39:24:\
    \ error: value of optional type 'Double?' must be unwrapped to a value of type\
    \ 'Double'\n            return a > Double(b) ? a : b\n                       ^\n\
    /tmp/tmpxcr4o5ir.swift:39:24: note: coalesce using '??' to provide a default when\
    \ the optional value contains 'nil'\n            return a > Double(b) ? a : b\n\
    \                       ^\n                                 ?? <#default value#>\n\
    /tmp/tmpxcr4o5ir.swift:39:24: note: force-unwrap using '!' to abort execution\
    \ if the optional value contains 'nil'\n            return a > Double(b) ? a :\
    \ b\n                       ^\n "
  stdout: ''
  timestamp: 1660013181
- exit_code: -4
  program: "\nenum Value: Equatable, Hashable {\n    case intValue(Int)\n    case\
    \ doubleValue(Double)\n    case stringValue(String)\n}\n\n            \n/// Create\
    \ a function that takes integers, floats, or strings representing\n/// real numbers,\
    \ and returns the larger variable in its given variable type.\n/// Return nil\
    \ if the values are equal.\n/// Note: If a real number is represented as a string,\
    \ the floating point might be . or ,\n/// >>> compare_one(a: .intValue(1), b:\
    \ .doubleValue(2.5))\n/// .doubleValue(2.5)\n/// >>> compare_one(a: .intValue(1),\
    \ b: .stringValue(\"2,3\"))\n/// .stringValue(\"2,3\")\n/// >>> compare_one(a:\
    \ .stringValue(\"5,1\"), b: .stringValue(\"6\"))\n/// .stringValue(\"6\")\n///\
    \ >>> compare_one(a: .stringValue(\"1\"), b: .intValue(1))\n/// nil\nfunc compare_one(a:\
    \ Value, b: Value) -> Value? {\n    var aValue: Double\n    var bValue: Double\n\
    \    switch a {\n    case .intValue(let aInt):\n        aValue = Double(aInt)\n\
    \    case .doubleValue(let aDouble):\n        aValue = aDouble\n    case .stringValue(let\
    \ aString):\n        aValue = Double(aString) ?? 0\n    }\n    switch b {\n  \
    \  case .intValue(let bInt):\n        bValue = Double(bInt)\n    case .doubleValue(let\
    \ bDouble):\n        bValue = bDouble\n    case .stringValue(let bString):\n \
    \       bValue = Double(bString) ?? 0\n    }\n    if aValue == bValue {\n    \
    \    return nil\n    } else if aValue > bValue {\n        return a\n    } else\
    \ {\n        return b\n    }\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int,\
    \ Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n\
    \    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n          \
    \  return false\n        }\n    }\n    return true\n}\n            \nassert(compare_one(a:\
    \ .intValue(1), b: .intValue(2)) == .intValue(2))\nassert(compare_one(a: .intValue(1),\
    \ b: .doubleValue(2.5)) == .doubleValue(2.5))\nassert(compare_one(a: .intValue(2),\
    \ b: .intValue(3)) == .intValue(3))\nassert(compare_one(a: .intValue(5), b: .intValue(6))\
    \ == .intValue(6))\nassert(compare_one(a: .intValue(1), b: .stringValue(\"2,3\"\
    )) == .stringValue(\"2,3\"))\nassert(compare_one(a: .stringValue(\"5,1\"), b:\
    \ .stringValue(\"6\")) == .stringValue(\"6\"))\nassert(compare_one(a: .stringValue(\"\
    1\"), b: .stringValue(\"2\")) == .stringValue(\"2\"))\nassert(compare_one(a: .stringValue(\"\
    1\"), b: .intValue(1)) == nil)"
  status: Exception
  stderr: 'tmpiwta4zjh/tmpiwta4zjh.swift:66: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b4f931acc80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b4f92ea3b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b4f92ea3988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b4f92ea27b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpiwta4zjh                        0x000056482b98678b <unavailable> + 10123

    5    libc.so.6                          0x00002b4f93398460 __libc_start_main +
    245

    6    tmpiwta4zjh                        0x000056482b985539 <unavailable> + 5433

    '
  stdout: ''
  timestamp: 1660013181
- exit_code: 1
  program: "\nenum Value: Equatable, Hashable {\n    case intValue(Int)\n    case\
    \ doubleValue(Double)\n    case stringValue(String)\n}\n\n            \n/// Create\
    \ a function that takes integers, floats, or strings representing\n/// real numbers,\
    \ and returns the larger variable in its given variable type.\n/// Return nil\
    \ if the values are equal.\n/// Note: If a real number is represented as a string,\
    \ the floating point might be . or ,\n/// >>> compare_one(a: .intValue(1), b:\
    \ .doubleValue(2.5))\n/// .doubleValue(2.5)\n/// >>> compare_one(a: .intValue(1),\
    \ b: .stringValue(\"2,3\"))\n/// .stringValue(\"2,3\")\n/// >>> compare_one(a:\
    \ .stringValue(\"5,1\"), b: .stringValue(\"6\"))\n/// .stringValue(\"6\")\n///\
    \ >>> compare_one(a: .stringValue(\"1\"), b: .intValue(1))\n/// nil\nfunc compare_one(a:\
    \ Value, b: Value) -> Value? {\n    let intValue = { (x: Int) -> Value in .intValue(x)\
    \ }\n    let doubleValue = { (x: Double) -> Value in .doubleValue(x) }\n    let\
    \ stringValue = { (x: String) -> Value in .stringValue(x) }\n    let toInt = {\
    \ (x: Value) -> Int? in\n        if case let .intValue(y) = x { return y }\n \
    \       return nil\n    }\n    let toDouble = { (x: Value) -> Double? in\n   \
    \     if case let .doubleValue(y) = x { return y }\n        return nil\n    }\n\
    \    let toString = { (x: Value) -> String? in\n        if case let .stringValue(y)\
    \ = x { return y }\n        return nil\n    }\n    let toReal = { (x: Value) ->\
    \ Double? in\n        if let z = toInt(x) { return Double(z) }\n        if let\
    \ z = toDouble(x) { return z }\n        if let z = toString(x) {\n           \
    \ let d = NumberFormatter().number(from: z)\n            return d?.doubleValue\n\
    \        }\n        return nil\n    }\n    if let x = toReal(a), let y = toReal(b)\
    \ {\n        if x > y { return a }\n        if x < y { return b }\n        return\
    \ nil\n    }\n    if case let .intValue(x) = a, case let .intValue(y) = b {\n\
    \        if x > y { return intValue(x) }\n        if x < y { return intValue(y)\
    \ }\n        return nil\n    }\n    if case let .doubleValue(x) = a, case let\
    \ .doubleValue(y) = b {\n        if x > y { return doubleValue(x) }\n        if\
    \ x < y { return doubleValue(y) }\n        return nil\n    }\n    if case let\
    \ .stringValue(x) = a, case let .stringValue(y) = b {\n        if x > y { return\
    \ stringValue(x) }\n        if x < y { return stringValue(y) }\n        return\
    \ nil\n    }\n    return nil\n\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int,\
    \ Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n\
    \    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n          \
    \  return false\n        }\n    }\n    return true\n}\n            \nassert(compare_one(a:\
    \ .intValue(1), b: .intValue(2)) == .intValue(2))\nassert(compare_one(a: .intValue(1),\
    \ b: .doubleValue(2.5)) == .doubleValue(2.5))\nassert(compare_one(a: .intValue(2),\
    \ b: .intValue(3)) == .intValue(3))\nassert(compare_one(a: .intValue(5), b: .intValue(6))\
    \ == .intValue(6))\nassert(compare_one(a: .intValue(1), b: .stringValue(\"2,3\"\
    )) == .stringValue(\"2,3\"))\nassert(compare_one(a: .stringValue(\"5,1\"), b:\
    \ .stringValue(\"6\")) == .stringValue(\"6\"))\nassert(compare_one(a: .stringValue(\"\
    1\"), b: .stringValue(\"2\")) == .stringValue(\"2\"))\nassert(compare_one(a: .stringValue(\"\
    1\"), b: .intValue(1)) == nil)"
  status: SyntaxError
  stderr: "/tmp/tmptip79944.swift:41:21: error: cannot find 'NumberFormatter' in scope\n\
    \            let d = NumberFormatter().number(from: z)\n                    ^~~~~~~~~~~~~~~\n"
  stdout: ''
  timestamp: 1660013181
- exit_code: 1
  program: "\nenum Value: Equatable, Hashable {\n    case intValue(Int)\n    case\
    \ doubleValue(Double)\n    case stringValue(String)\n}\n\n            \n/// Create\
    \ a function that takes integers, floats, or strings representing\n/// real numbers,\
    \ and returns the larger variable in its given variable type.\n/// Return nil\
    \ if the values are equal.\n/// Note: If a real number is represented as a string,\
    \ the floating point might be . or ,\n/// >>> compare_one(a: .intValue(1), b:\
    \ .doubleValue(2.5))\n/// .doubleValue(2.5)\n/// >>> compare_one(a: .intValue(1),\
    \ b: .stringValue(\"2,3\"))\n/// .stringValue(\"2,3\")\n/// >>> compare_one(a:\
    \ .stringValue(\"5,1\"), b: .stringValue(\"6\"))\n/// .stringValue(\"6\")\n///\
    \ >>> compare_one(a: .stringValue(\"1\"), b: .intValue(1))\n/// nil\nfunc compare_one(a:\
    \ Value, b: Value) -> Value? {\n    switch (a, b) {\n    case (.intValue(let a),\
    \ .intValue(let b)):\n        return a > b ? a : b\n    case (.doubleValue(let\
    \ a), .doubleValue(let b)):\n        return a > b ? a : b\n    case (.stringValue(let\
    \ a), .stringValue(let b)):\n        return a > b ? a : b\n    default:\n    \
    \    return nil\n    }\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(compare_one(a:\
    \ .intValue(1), b: .intValue(2)) == .intValue(2))\nassert(compare_one(a: .intValue(1),\
    \ b: .doubleValue(2.5)) == .doubleValue(2.5))\nassert(compare_one(a: .intValue(2),\
    \ b: .intValue(3)) == .intValue(3))\nassert(compare_one(a: .intValue(5), b: .intValue(6))\
    \ == .intValue(6))\nassert(compare_one(a: .intValue(1), b: .stringValue(\"2,3\"\
    )) == .stringValue(\"2,3\"))\nassert(compare_one(a: .stringValue(\"5,1\"), b:\
    \ .stringValue(\"6\")) == .stringValue(\"6\"))\nassert(compare_one(a: .stringValue(\"\
    1\"), b: .stringValue(\"2\")) == .stringValue(\"2\"))\nassert(compare_one(a: .stringValue(\"\
    1\"), b: .intValue(1)) == nil)"
  status: SyntaxError
  stderr: "/tmp/tmp07haxekb.swift:24:22: error: cannot convert return expression of\
    \ type 'Int' to return type 'Value?'\n        return a > b ? a : b\n         \
    \      ~~~~~~^~~~~~~\n/tmp/tmp07haxekb.swift:26:22: error: cannot convert return\
    \ expression of type 'Double' to return type 'Value?'\n        return a > b ?\
    \ a : b\n               ~~~~~~^~~~~~~\n/tmp/tmp07haxekb.swift:28:22: error: cannot\
    \ convert return expression of type 'String' to return type 'Value?'\n       \
    \ return a > b ? a : b\n               ~~~~~~^~~~~~~\n"
  stdout: ''
  timestamp: 1660013180
- exit_code: 1
  program: "\nenum Value: Equatable, Hashable {\n    case intValue(Int)\n    case\
    \ doubleValue(Double)\n    case stringValue(String)\n}\n\n            \n/// Create\
    \ a function that takes integers, floats, or strings representing\n/// real numbers,\
    \ and returns the larger variable in its given variable type.\n/// Return nil\
    \ if the values are equal.\n/// Note: If a real number is represented as a string,\
    \ the floating point might be . or ,\n/// >>> compare_one(a: .intValue(1), b:\
    \ .doubleValue(2.5))\n/// .doubleValue(2.5)\n/// >>> compare_one(a: .intValue(1),\
    \ b: .stringValue(\"2,3\"))\n/// .stringValue(\"2,3\")\n/// >>> compare_one(a:\
    \ .stringValue(\"5,1\"), b: .stringValue(\"6\"))\n/// .stringValue(\"6\")\n///\
    \ >>> compare_one(a: .stringValue(\"1\"), b: .intValue(1))\n/// nil\nfunc compare_one(a:\
    \ Value, b: Value) -> Value? {\n    switch (a, b) {\n    case let (.intValue(a),\
    \ .intValue(b)) where a != b:\n        return a > b ? a : b\n    case let (.doubleValue(a),\
    \ .doubleValue(b)) where a != b:\n        return a > b ? a : b\n    case let (.stringValue(a),\
    \ .stringValue(b)) where a != b:\n        return a > b ? a : b\n    default:\n\
    \        return nil\n    }\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(compare_one(a:\
    \ .intValue(1), b: .intValue(2)) == .intValue(2))\nassert(compare_one(a: .intValue(1),\
    \ b: .doubleValue(2.5)) == .doubleValue(2.5))\nassert(compare_one(a: .intValue(2),\
    \ b: .intValue(3)) == .intValue(3))\nassert(compare_one(a: .intValue(5), b: .intValue(6))\
    \ == .intValue(6))\nassert(compare_one(a: .intValue(1), b: .stringValue(\"2,3\"\
    )) == .stringValue(\"2,3\"))\nassert(compare_one(a: .stringValue(\"5,1\"), b:\
    \ .stringValue(\"6\")) == .stringValue(\"6\"))\nassert(compare_one(a: .stringValue(\"\
    1\"), b: .stringValue(\"2\")) == .stringValue(\"2\"))\nassert(compare_one(a: .stringValue(\"\
    1\"), b: .intValue(1)) == nil)"
  status: SyntaxError
  stderr: "/tmp/tmpe9rc17ll.swift:24:22: error: cannot convert return expression of\
    \ type 'Int' to return type 'Value?'\n        return a > b ? a : b\n         \
    \      ~~~~~~^~~~~~~\n/tmp/tmpe9rc17ll.swift:26:22: error: cannot convert return\
    \ expression of type 'Double' to return type 'Value?'\n        return a > b ?\
    \ a : b\n               ~~~~~~^~~~~~~\n/tmp/tmpe9rc17ll.swift:28:22: error: cannot\
    \ convert return expression of type 'String' to return type 'Value?'\n       \
    \ return a > b ? a : b\n               ~~~~~~^~~~~~~\n"
  stdout: ''
  timestamp: 1660013179
- exit_code: 1
  program: "\nenum Value: Equatable, Hashable {\n    case intValue(Int)\n    case\
    \ doubleValue(Double)\n    case stringValue(String)\n}\n\n            \n/// Create\
    \ a function that takes integers, floats, or strings representing\n/// real numbers,\
    \ and returns the larger variable in its given variable type.\n/// Return nil\
    \ if the values are equal.\n/// Note: If a real number is represented as a string,\
    \ the floating point might be . or ,\n/// >>> compare_one(a: .intValue(1), b:\
    \ .doubleValue(2.5))\n/// .doubleValue(2.5)\n/// >>> compare_one(a: .intValue(1),\
    \ b: .stringValue(\"2,3\"))\n/// .stringValue(\"2,3\")\n/// >>> compare_one(a:\
    \ .stringValue(\"5,1\"), b: .stringValue(\"6\"))\n/// .stringValue(\"6\")\n///\
    \ >>> compare_one(a: .stringValue(\"1\"), b: .intValue(1))\n/// nil\nfunc compare_one(a:\
    \ Value, b: Value) -> Value? {\n    switch (a, b) {\n    case (.intValue(let i),\
    \ .intValue(let j)):\n        return i >= j ? a : b\n    case (.intValue(let i),\
    \ .doubleValue(let j)):\n        return j >= Double(i) ? b : a\n    case (.intValue(let\
    \ i), .stringValue(let j)):\n        return Double(j) ?? 0 >= Double(i) ? b :\
    \ a\n    case (.doubleValue(let i), .intValue(let j)):\n        return i >= Double(j)\
    \ ? a : b\n    case (.doubleValue(let i), .doubleValue(let j)):\n        return\
    \ i >= j ? a : b\n    case (.doubleValue(let i), .stringValue(let j)):\n     \
    \   return Double(j) ?? 0 >= i ? b : a\n    case (.stringValue(let i), .intValue(let\
    \ j)):\n        return Double(i) ?? 0 >= Double(j) ? a : b\n    case (.stringValue(let\
    \ i), .doubleValue(let j)):\n        return Double(i) ?? 0 >= j ? a : b\n    case\
    \ (.stringValue(let i), .stringValue(let j)):\n        return Double(i) ?? 0 >=\
    \ Double(j) ? a : b\n    }\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(compare_one(a:\
    \ .intValue(1), b: .intValue(2)) == .intValue(2))\nassert(compare_one(a: .intValue(1),\
    \ b: .doubleValue(2.5)) == .doubleValue(2.5))\nassert(compare_one(a: .intValue(2),\
    \ b: .intValue(3)) == .intValue(3))\nassert(compare_one(a: .intValue(5), b: .intValue(6))\
    \ == .intValue(6))\nassert(compare_one(a: .intValue(1), b: .stringValue(\"2,3\"\
    )) == .stringValue(\"2,3\"))\nassert(compare_one(a: .stringValue(\"5,1\"), b:\
    \ .stringValue(\"6\")) == .stringValue(\"6\"))\nassert(compare_one(a: .stringValue(\"\
    1\"), b: .stringValue(\"2\")) == .stringValue(\"2\"))\nassert(compare_one(a: .stringValue(\"\
    1\"), b: .intValue(1)) == nil)"
  status: SyntaxError
  stderr: "/tmp/tmpwmy52xs_.swift:40:34: error: value of optional type 'Double?' must\
    \ be unwrapped to a value of type 'Double'\n        return Double(i) ?? 0 >= Double(j)\
    \ ? a : b\n                                 ^\n/tmp/tmpwmy52xs_.swift:40:34: note:\
    \ coalesce using '??' to provide a default when the optional value contains 'nil'\n\
    \        return Double(i) ?? 0 >= Double(j) ? a : b\n                        \
    \         ^\n                                           ?? <#default value#>\n\
    /tmp/tmpwmy52xs_.swift:40:34: note: force-unwrap using '!' to abort execution\
    \ if the optional value contains 'nil'\n        return Double(i) ?? 0 >= Double(j)\
    \ ? a : b\n                                 ^\n                              \
    \            !\n"
  stdout: ''
  timestamp: 1660013181
- exit_code: 1
  program: "\nenum Value: Equatable, Hashable {\n    case intValue(Int)\n    case\
    \ doubleValue(Double)\n    case stringValue(String)\n}\n\n            \n/// Create\
    \ a function that takes integers, floats, or strings representing\n/// real numbers,\
    \ and returns the larger variable in its given variable type.\n/// Return nil\
    \ if the values are equal.\n/// Note: If a real number is represented as a string,\
    \ the floating point might be . or ,\n/// >>> compare_one(a: .intValue(1), b:\
    \ .doubleValue(2.5))\n/// .doubleValue(2.5)\n/// >>> compare_one(a: .intValue(1),\
    \ b: .stringValue(\"2,3\"))\n/// .stringValue(\"2,3\")\n/// >>> compare_one(a:\
    \ .stringValue(\"5,1\"), b: .stringValue(\"6\"))\n/// .stringValue(\"6\")\n///\
    \ >>> compare_one(a: .stringValue(\"1\"), b: .intValue(1))\n/// nil\nfunc compare_one(a:\
    \ Value, b: Value) -> Value? {\n    switch a {\n    case .intValue(let x):\n \
    \       switch b {\n        case .intValue(let y):\n            if x > y {\n \
    \               return a\n            } else if x < y {\n                return\
    \ b\n            } else {\n                return nil\n            }\n       \
    \ case .doubleValue(let y):\n            if Double(x) > y {\n                return\
    \ a\n            } else if Double(x) < y {\n                return b\n       \
    \     } else {\n                return nil\n            }\n        case .stringValue(let\
    \ y):\n            if Double(x) > Double(y) {\n                return a\n    \
    \        } else if Double(x) < Double(y) {\n                return b\n       \
    \     } else {\n                return nil\n            }\n        }\n    case\
    \ .doubleValue(let x):\n        switch b {\n        case .intValue(let y):\n \
    \           if x > Double(y) {\n                return a\n            } else if\
    \ x < Double(y) {\n                return b\n            } else {\n          \
    \      return nil\n            }\n        case .doubleValue(let y):\n        \
    \    if x > y {\n                return a\n            } else if x < y {\n   \
    \             return b\n            } else {\n                return nil\n   \
    \         }\n        case .stringValue(let y):\n            if x > Double(y) {\n\
    \                return a\n            } else if x < Double(y) {\n           \
    \     return b\n            } else {\n                return nil\n           \
    \ }\n        }\n    case .stringValue(let x):\n        switch b {\n        case\
    \ .intValue(let y):\n            if Double(x) > Double(y) {\n                return\
    \ a\n            } else if Double(x) < Double(y) {\n                return b\n\
    \            } else {\n                return nil\n            }\n        case\
    \ .doubleValue(let y):\n            if Double(x) > y {\n                return\
    \ a\n            } else if Double(x) < y {\n                return b\n       \
    \     } else {\n                return nil\n            }\n        case .stringValue(let\
    \ y):\n            if Double(x) > Double(y) {\n                return a\n    \
    \        } else if Double(x) < Double(y\n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(compare_one(a: .intValue(1), b: .intValue(2)) == .intValue(2))\nassert(compare_one(a:\
    \ .intValue(1), b: .doubleValue(2.5)) == .doubleValue(2.5))\nassert(compare_one(a:\
    \ .intValue(2), b: .intValue(3)) == .intValue(3))\nassert(compare_one(a: .intValue(5),\
    \ b: .intValue(6)) == .intValue(6))\nassert(compare_one(a: .intValue(1), b: .stringValue(\"\
    2,3\")) == .stringValue(\"2,3\"))\nassert(compare_one(a: .stringValue(\"5,1\"\
    ), b: .stringValue(\"6\")) == .stringValue(\"6\"))\nassert(compare_one(a: .stringValue(\"\
    1\"), b: .stringValue(\"2\")) == .stringValue(\"2\"))\nassert(compare_one(a: .stringValue(\"\
    1\"), b: .intValue(1)) == nil)"
  status: SyntaxError
  stderr: "/tmp/tmpwzhpzsei.swift:99:1: error: expected ')' in expression list\n}\n\
    ^\n/tmp/tmpwzhpzsei.swift:98:41: note: to match this opening '('\n           \
    \ } else if Double(x) < Double(y\n                                        ^\n\
    /tmp/tmpwzhpzsei.swift:121:66: error: expected '}' at end of 'switch' statement\n\
    assert(compare_one(a: .stringValue(\"1\"), b: .intValue(1)) == nil)\n        \
    \                                                         ^\n/tmp/tmpwzhpzsei.swift:22:14:\
    \ note: to match this opening '{'\n    switch a {\n             ^\n/tmp/tmpwzhpzsei.swift:121:66:\
    \ error: expected '}' at end of brace statement\nassert(compare_one(a: .stringValue(\"\
    1\"), b: .intValue(1)) == nil)\n                                             \
    \                    ^\n/tmp/tmpwzhpzsei.swift:21:48: note: to match this opening\
    \ '{'\nfunc compare_one(a: Value, b: Value) -> Value? {\n                    \
    \                           ^\n/tmp/tmpwzhpzsei.swift:42:28: error: value of optional\
    \ type 'Double?' must be unwrapped to a value of type 'Double'\n            if\
    \ Double(x) > Double(y) {\n                           ^\n/tmp/tmpwzhpzsei.swift:42:28:\
    \ note: coalesce using '??' to provide a default when the optional value contains\
    \ 'nil'\n            if Double(x) > Double(y) {\n                           ^\n\
    \                                     ?? <#default value#>\n/tmp/tmpwzhpzsei.swift:42:28:\
    \ note: force-unwrap using '!' to abort execution if the optional value contains\
    \ 'nil'\n            if Double(x) > Double(y) {\n                           ^\n\
    \                                    !\n/tmp/tmpwzhpzsei.swift:44:35: error: value\
    \ of optional type 'Double?' must be unwrapped to a value of type 'Double'\n \
    \           } else if Double(x) < Double(y) {\n                              \
    \    ^\n/tmp/tmpwzhpzsei.swift:44:35: note: coalesce using '??' to provide a default\
    \ when the optional value contains 'nil'\n            } else if Double(x) < Double(y)\
    \ {\n                                  ^\n                                   \
    \         ?? <#default value#>\n/tmp/tmpwzhpzsei.swift:44:35: note: force-unwr"
  stdout: ''
  timestamp: 1660013181
- exit_code: 1
  program: "\nenum Value: Equatable, Hashable {\n    case intValue(Int)\n    case\
    \ doubleValue(Double)\n    case stringValue(String)\n}\n\n            \n/// Create\
    \ a function that takes integers, floats, or strings representing\n/// real numbers,\
    \ and returns the larger variable in its given variable type.\n/// Return nil\
    \ if the values are equal.\n/// Note: If a real number is represented as a string,\
    \ the floating point might be . or ,\n/// >>> compare_one(a: .intValue(1), b:\
    \ .doubleValue(2.5))\n/// .doubleValue(2.5)\n/// >>> compare_one(a: .intValue(1),\
    \ b: .stringValue(\"2,3\"))\n/// .stringValue(\"2,3\")\n/// >>> compare_one(a:\
    \ .stringValue(\"5,1\"), b: .stringValue(\"6\"))\n/// .stringValue(\"6\")\n///\
    \ >>> compare_one(a: .stringValue(\"1\"), b: .intValue(1))\n/// nil\nfunc compare_one(a:\
    \ Value, b: Value) -> Value? {\n    // Enter your code here\n    switch (a, b)\
    \ {\n    case let (.intValue(x), .intValue(y)):\n        return x > y ? .intValue(x)\
    \ : nil\n    case let (.intValue(x), .doubleValue(y)):\n        return y > Double(x)\
    \ ? .doubleValue(y) : nil\n    case let (.intValue(x), .stringValue(y)):\n   \
    \     return Double(y) > Double(x) ? .stringValue(y) : nil\n    case let (.doubleValue(x),\
    \ .intValue(y)):\n        return x > Double(y) ? .doubleValue(x) : nil\n    case\
    \ let (.doubleValue(x), .doubleValue(y)):\n        return x > y ? .doubleValue(x)\
    \ : nil\n    case let (.doubleValue(x), .stringValue(y)):\n        return Double(y)\
    \ > x ? .stringValue(y) : nil\n    case let (.stringValue(x), .intValue(y)):\n\
    \        return Double(x) > Double(y) ? .stringValue(x) : nil\n    case let (.stringValue(x),\
    \ .doubleValue(y)):\n        return y > Double(x) ? .doubleValue(y) : nil\n  \
    \  case let (.stringValue(x), .stringValue(y)):\n        return Double(x) > Double(y)\
    \ ? .stringValue(x) : nil\n    }\n    return nil\n}\n\n\nfunc ==(left: [(Int,\
    \ Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n\
    \        return false\n    }\n    for (l, r) in zip(left, right) {\n        if\
    \ l != r {\n            return false\n        }\n    }\n    return true\n}\n \
    \           \nassert(compare_one(a: .intValue(1), b: .intValue(2)) == .intValue(2))\n\
    assert(compare_one(a: .intValue(1), b: .doubleValue(2.5)) == .doubleValue(2.5))\n\
    assert(compare_one(a: .intValue(2), b: .intValue(3)) == .intValue(3))\nassert(compare_one(a:\
    \ .intValue(5), b: .intValue(6)) == .intValue(6))\nassert(compare_one(a: .intValue(1),\
    \ b: .stringValue(\"2,3\")) == .stringValue(\"2,3\"))\nassert(compare_one(a: .stringValue(\"\
    5,1\"), b: .stringValue(\"6\")) == .stringValue(\"6\"))\nassert(compare_one(a:\
    \ .stringValue(\"1\"), b: .stringValue(\"2\")) == .stringValue(\"2\"))\nassert(compare_one(a:\
    \ .stringValue(\"1\"), b: .intValue(1)) == nil)"
  status: SyntaxError
  stderr: "/tmp/tmpzmla88ef.swift:29:16: error: value of optional type 'Double?' must\
    \ be unwrapped to a value of type 'Double'\n        return Double(y) > Double(x)\
    \ ? .stringValue(y) : nil\n               ^\n/tmp/tmpzmla88ef.swift:29:16: note:\
    \ coalesce using '??' to provide a default when the optional value contains 'nil'\n\
    \        return Double(y) > Double(x) ? .stringValue(y) : nil\n              \
    \ ^\n                         ?? <#default value#>\n/tmp/tmpzmla88ef.swift:29:16:\
    \ note: force-unwrap using '!' to abort execution if the optional value contains\
    \ 'nil'\n        return Double(y) > Double(x) ? .stringValue(y) : nil\n      \
    \         ^\n                        !\n/tmp/tmpzmla88ef.swift:35:16: error: value\
    \ of optional type 'Double?' must be unwrapped to a value of type 'Double'\n \
    \       return Double(y) > x ? .stringValue(y) : nil\n               ^\n/tmp/tmpzmla88ef.swift:35:16:\
    \ note: coalesce using '??' to provide a default when the optional value contains\
    \ 'nil'\n        return Double(y) > x ? .stringValue(y) : nil\n              \
    \ ^\n                         ?? <#default value#>\n/tmp/tmpzmla88ef.swift:35:16:\
    \ note: force-unwrap using '!' to abort execution if the optional value contains\
    \ 'nil'\n        return Double(y) > x ? .stringValue(y) : nil\n              \
    \ ^\n                        !\n/tmp/tmpzmla88ef.swift:37:16: error: value of\
    \ optional type 'Double?' must be unwrapped to a value of type 'Double'\n    \
    \    return Double(x) > Double(y) ? .stringValue(x) : nil\n               ^\n\
    /tmp/tmpzmla88ef.swift:37:16: note: coalesce using '??' to provide a default when\
    \ the optional value contains 'nil'\n        return Double(x) > Double(y) ? .stringValue(x)\
    \ : nil\n               ^\n                         ?? <#default value#>\n/tmp/tmpzmla88ef.swift:37:16:\
    \ note: force-unwrap using '!' to abort execution if the optional value contains\
    \ 'nil'\n        return Double(x) > Double(y) ? .stringValue(x) : nil\n      \
    \         ^\n                        !\n/tmp/tmpzmla88ef.swift:39:20: error: value\
    \ of optional type 'Double?' must be unwrapped to a value of type 'Doubl"
  stdout: ''
  timestamp: 1660013181
- exit_code: 1
  program: "\nenum Value: Equatable, Hashable {\n    case intValue(Int)\n    case\
    \ doubleValue(Double)\n    case stringValue(String)\n}\n\n            \n/// Create\
    \ a function that takes integers, floats, or strings representing\n/// real numbers,\
    \ and returns the larger variable in its given variable type.\n/// Return nil\
    \ if the values are equal.\n/// Note: If a real number is represented as a string,\
    \ the floating point might be . or ,\n/// >>> compare_one(a: .intValue(1), b:\
    \ .doubleValue(2.5))\n/// .doubleValue(2.5)\n/// >>> compare_one(a: .intValue(1),\
    \ b: .stringValue(\"2,3\"))\n/// .stringValue(\"2,3\")\n/// >>> compare_one(a:\
    \ .stringValue(\"5,1\"), b: .stringValue(\"6\"))\n/// .stringValue(\"6\")\n///\
    \ >>> compare_one(a: .stringValue(\"1\"), b: .intValue(1))\n/// nil\nfunc compare_one(a:\
    \ Value, b: Value) -> Value? {\n    if a == b {\n        return nil\n    }\n \
    \   let intA = a.intValue()\n    let intB = b.intValue()\n    if intA == intB\
    \ {\n        return nil\n    }\n    let doubleA = a.doubleValue()\n    let doubleB\
    \ = b.doubleValue()\n    if doubleA == doubleB {\n        return nil\n    }\n\
    \    return max(a, b)\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(compare_one(a:\
    \ .intValue(1), b: .intValue(2)) == .intValue(2))\nassert(compare_one(a: .intValue(1),\
    \ b: .doubleValue(2.5)) == .doubleValue(2.5))\nassert(compare_one(a: .intValue(2),\
    \ b: .intValue(3)) == .intValue(3))\nassert(compare_one(a: .intValue(5), b: .intValue(6))\
    \ == .intValue(6))\nassert(compare_one(a: .intValue(1), b: .stringValue(\"2,3\"\
    )) == .stringValue(\"2,3\"))\nassert(compare_one(a: .stringValue(\"5,1\"), b:\
    \ .stringValue(\"6\")) == .stringValue(\"6\"))\nassert(compare_one(a: .stringValue(\"\
    1\"), b: .stringValue(\"2\")) == .stringValue(\"2\"))\nassert(compare_one(a: .stringValue(\"\
    1\"), b: .intValue(1)) == nil)"
  status: SyntaxError
  stderr: "/tmp/tmpeshbq8jf.swift:25:27: error: missing argument for parameter #1\
    \ in call\n    let intA = a.intValue()\n                          ^\n        \
    \                  <#Int#>\n/tmp/tmpeshbq8jf.swift:3:10: note: 'intValue' declared\
    \ here\n    case intValue(Int)\n         ^\n/tmp/tmpeshbq8jf.swift:25:16: error:\
    \ enum case 'intValue' cannot be used as an instance member\n    let intA = a.intValue()\n\
    \               ^\n               Value\n/tmp/tmpeshbq8jf.swift:26:16: error:\
    \ enum case 'intValue' cannot be used as an instance member\n    let intB = b.intValue()\n\
    \               ^\n               Value\n/tmp/tmpeshbq8jf.swift:26:27: error:\
    \ missing argument for parameter #1 in call\n    let intB = b.intValue()\n   \
    \                       ^\n                          <#Int#>\n/tmp/tmpeshbq8jf.swift:3:10:\
    \ note: 'intValue' declared here\n    case intValue(Int)\n         ^\n/tmp/tmpeshbq8jf.swift:30:19:\
    \ error: enum case 'doubleValue' cannot be used as an instance member\n    let\
    \ doubleA = a.doubleValue()\n                  ^\n                  Value\n/tmp/tmpeshbq8jf.swift:30:33:\
    \ error: missing argument for parameter #1 in call\n    let doubleA = a.doubleValue()\n\
    \                                ^\n                                <#Double#>\n\
    /tmp/tmpeshbq8jf.swift:4:10: note: 'doubleValue' declared here\n    case doubleValue(Double)\n\
    \         ^\n/tmp/tmpeshbq8jf.swift:31:33: error: missing argument for parameter\
    \ #1 in call\n    let doubleB = b.doubleValue()\n                            \
    \    ^\n                                <#Double#>\n/tmp/tmpeshbq8jf.swift:4:10:\
    \ note: 'doubleValue' declared here\n    case doubleValue(Double)\n         ^\n\
    /tmp/tmpeshbq8jf.swift:31:19: error: enum case 'doubleValue' cannot be used as\
    \ an instance member\n    let doubleB = b.doubleValue()\n                  ^\n\
    \                  Value\n/tmp/tmpeshbq8jf.swift:35:12: error: global function\
    \ 'max' requires that 'Value' conform to 'Comparable'\n    return max(a, b)\n\
    \           ^\nSwift.max:1:24: note: where 'T' = 'Value'\n@inlinable public func\
    \ max<T>(_ x: T, _ y: T) -> T where T : Comparable\n         "
  stdout: ''
  timestamp: 1660013181
- exit_code: 1
  program: "\nenum Value: Equatable, Hashable {\n    case intValue(Int)\n    case\
    \ doubleValue(Double)\n    case stringValue(String)\n}\n\n            \n/// Create\
    \ a function that takes integers, floats, or strings representing\n/// real numbers,\
    \ and returns the larger variable in its given variable type.\n/// Return nil\
    \ if the values are equal.\n/// Note: If a real number is represented as a string,\
    \ the floating point might be . or ,\n/// >>> compare_one(a: .intValue(1), b:\
    \ .doubleValue(2.5))\n/// .doubleValue(2.5)\n/// >>> compare_one(a: .intValue(1),\
    \ b: .stringValue(\"2,3\"))\n/// .stringValue(\"2,3\")\n/// >>> compare_one(a:\
    \ .stringValue(\"5,1\"), b: .stringValue(\"6\"))\n/// .stringValue(\"6\")\n///\
    \ >>> compare_one(a: .stringValue(\"1\"), b: .intValue(1))\n/// nil\nfunc compare_one(a:\
    \ Value, b: Value) -> Value? {\n    \n    var aValue: Double = 0\n    var bValue:\
    \ Double = 0\n    \n    switch a {\n    case .intValue(let value):\n        aValue\
    \ = Double(value)\n    case .doubleValue(let value):\n        aValue = value\n\
    \    case .stringValue(let value):\n        if let value = Double(value.replacingOccurrences(of:\
    \ \",\", with: \".\")) {\n            aValue = value\n        }\n    }\n    \n\
    \    switch b {\n    case .intValue(let value):\n        bValue = Double(value)\n\
    \    case .doubleValue(let value):\n        bValue = value\n    case .stringValue(let\
    \ value):\n        if let value = Double(value.replacingOccurrences(of: \",\"\
    , with: \".\")) {\n            bValue = value\n        }\n    }\n    \n    switch\
    \ aValue > bValue {\n    case true:\n        return a\n    case false:\n     \
    \   return b\n    }\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) ->\
    \ Bool {\n    if left.count != right.count {\n        return false\n    }\n  \
    \  for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(compare_one(a: .intValue(1),\
    \ b: .intValue(2)) == .intValue(2))\nassert(compare_one(a: .intValue(1), b: .doubleValue(2.5))\
    \ == .doubleValue(2.5))\nassert(compare_one(a: .intValue(2), b: .intValue(3))\
    \ == .intValue(3))\nassert(compare_one(a: .intValue(5), b: .intValue(6)) == .intValue(6))\n\
    assert(compare_one(a: .intValue(1), b: .stringValue(\"2,3\")) == .stringValue(\"\
    2,3\"))\nassert(compare_one(a: .stringValue(\"5,1\"), b: .stringValue(\"6\"))\
    \ == .stringValue(\"6\"))\nassert(compare_one(a: .stringValue(\"1\"), b: .stringValue(\"\
    2\")) == .stringValue(\"2\"))\nassert(compare_one(a: .stringValue(\"1\"), b: .intValue(1))\
    \ == nil)"
  status: SyntaxError
  stderr: "/tmp/tmp7yoy92z9.swift:32:37: error: value of type 'String' has no member\
    \ 'replacingOccurrences'\n        if let value = Double(value.replacingOccurrences(of:\
    \ \",\", with: \".\")) {\n                              ~~~~~ ^~~~~~~~~~~~~~~~~~~~\n\
    /tmp/tmp7yoy92z9.swift:43:37: error: value of type 'String' has no member 'replacingOccurrences'\n\
    \        if let value = Double(value.replacingOccurrences(of: \",\", with: \"\
    .\")) {\n                              ~~~~~ ^~~~~~~~~~~~~~~~~~~~\n"
  stdout: ''
  timestamp: 1660013181
- exit_code: 1
  program: "\nenum Value: Equatable, Hashable {\n    case intValue(Int)\n    case\
    \ doubleValue(Double)\n    case stringValue(String)\n}\n\n            \n/// Create\
    \ a function that takes integers, floats, or strings representing\n/// real numbers,\
    \ and returns the larger variable in its given variable type.\n/// Return nil\
    \ if the values are equal.\n/// Note: If a real number is represented as a string,\
    \ the floating point might be . or ,\n/// >>> compare_one(a: .intValue(1), b:\
    \ .doubleValue(2.5))\n/// .doubleValue(2.5)\n/// >>> compare_one(a: .intValue(1),\
    \ b: .stringValue(\"2,3\"))\n/// .stringValue(\"2,3\")\n/// >>> compare_one(a:\
    \ .stringValue(\"5,1\"), b: .stringValue(\"6\"))\n/// .stringValue(\"6\")\n///\
    \ >>> compare_one(a: .stringValue(\"1\"), b: .intValue(1))\n/// nil\nfunc compare_one(a:\
    \ Value, b: Value) -> Value? {\n    switch (a, b) {\n    case (.intValue(let a),\
    \ .intValue(let b)):\n        return a > b ? a : b\n    case (.doubleValue(let\
    \ a), .doubleValue(let b)):\n        return a > b ? a : b\n    case (.stringValue(let\
    \ a), .stringValue(let b)):\n        return Double(a) > Double(b) ? a : b\n  \
    \  default:\n        return nil\n    }\n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(compare_one(a: .intValue(1), b: .intValue(2)) == .intValue(2))\nassert(compare_one(a:\
    \ .intValue(1), b: .doubleValue(2.5)) == .doubleValue(2.5))\nassert(compare_one(a:\
    \ .intValue(2), b: .intValue(3)) == .intValue(3))\nassert(compare_one(a: .intValue(5),\
    \ b: .intValue(6)) == .intValue(6))\nassert(compare_one(a: .intValue(1), b: .stringValue(\"\
    2,3\")) == .stringValue(\"2,3\"))\nassert(compare_one(a: .stringValue(\"5,1\"\
    ), b: .stringValue(\"6\")) == .stringValue(\"6\"))\nassert(compare_one(a: .stringValue(\"\
    1\"), b: .stringValue(\"2\")) == .stringValue(\"2\"))\nassert(compare_one(a: .stringValue(\"\
    1\"), b: .intValue(1)) == nil)"
  status: SyntaxError
  stderr: "/tmp/tmpbqn3a4s4.swift:24:22: error: cannot convert return expression of\
    \ type 'Int' to return type 'Value?'\n        return a > b ? a : b\n         \
    \      ~~~~~~^~~~~~~\n/tmp/tmpbqn3a4s4.swift:26:22: error: cannot convert return\
    \ expression of type 'Double' to return type 'Value?'\n        return a > b ?\
    \ a : b\n               ~~~~~~^~~~~~~\n/tmp/tmpbqn3a4s4.swift:28:28: error: value\
    \ of optional type 'Double?' must be unwrapped to a value of type 'Double'\n \
    \       return Double(a) > Double(b) ? a : b\n                           ^\n/tmp/tmpbqn3a4s4.swift:28:28:\
    \ note: coalesce using '??' to provide a default when the optional value contains\
    \ 'nil'\n        return Double(a) > Double(b) ? a : b\n                      \
    \     ^\n                                     ?? <#default value#>\n/tmp/tmpbqn3a4s4.swift:28:28:\
    \ note: force-unwrap using '!' to abort execution if the optional value contains\
    \ 'nil'\n        return Double(a) > Double(b) ? a : b\n                      \
    \     ^\n                                    !\n/tmp/tmpbqn3a4s4.swift:28:16:\
    \ error: value of optional type 'Double?' must be unwrapped to a value of type\
    \ 'Double'\n        return Double(a) > Double(b) ? a : b\n               ^\n/tmp/tmpbqn3a4s4.swift:28:16:\
    \ note: coalesce using '??' to provide a default when the optional value contains\
    \ 'nil'\n        return Double(a) > Double(b) ? a : b\n               ^\n    \
    \                     ?? <#default value#>\n/tmp/tmpbqn3a4s4.swift:28:16: note:\
    \ force-unwrap using '!' to abort execution if the optional value contains 'nil'\n\
    \        return Double(a) > Double(b) ? a : b\n               ^\n            \
    \            !\n/tmp/tmpbqn3a4s4.swift:28:38: error: cannot convert return expression\
    \ of type 'String' to return type 'Value?'\n        return Double(a) > Double(b)\
    \ ? a : b\n               ~~~~~~~~~~~~~~~~~~~~~~^~~~~~~\n"
  stdout: ''
  timestamp: 1660013181
- exit_code: -4
  program: "\nenum Value: Equatable, Hashable {\n    case intValue(Int)\n    case\
    \ doubleValue(Double)\n    case stringValue(String)\n}\n\n            \n/// Create\
    \ a function that takes integers, floats, or strings representing\n/// real numbers,\
    \ and returns the larger variable in its given variable type.\n/// Return nil\
    \ if the values are equal.\n/// Note: If a real number is represented as a string,\
    \ the floating point might be . or ,\n/// >>> compare_one(a: .intValue(1), b:\
    \ .doubleValue(2.5))\n/// .doubleValue(2.5)\n/// >>> compare_one(a: .intValue(1),\
    \ b: .stringValue(\"2,3\"))\n/// .stringValue(\"2,3\")\n/// >>> compare_one(a:\
    \ .stringValue(\"5,1\"), b: .stringValue(\"6\"))\n/// .stringValue(\"6\")\n///\
    \ >>> compare_one(a: .stringValue(\"1\"), b: .intValue(1))\n/// nil\nfunc compare_one(a:\
    \ Value, b: Value) -> Value? {\n    // TODO\n    return nil\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(compare_one(a: .intValue(1), b: .intValue(2)) == .intValue(2))\n\
    assert(compare_one(a: .intValue(1), b: .doubleValue(2.5)) == .doubleValue(2.5))\n\
    assert(compare_one(a: .intValue(2), b: .intValue(3)) == .intValue(3))\nassert(compare_one(a:\
    \ .intValue(5), b: .intValue(6)) == .intValue(6))\nassert(compare_one(a: .intValue(1),\
    \ b: .stringValue(\"2,3\")) == .stringValue(\"2,3\"))\nassert(compare_one(a: .stringValue(\"\
    5,1\"), b: .stringValue(\"6\")) == .stringValue(\"6\"))\nassert(compare_one(a:\
    \ .stringValue(\"1\"), b: .stringValue(\"2\")) == .stringValue(\"2\"))\nassert(compare_one(a:\
    \ .stringValue(\"1\"), b: .intValue(1)) == nil)"
  status: Exception
  stderr: 'tmpabopsadx/tmpabopsadx.swift:39: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b8c55590c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b8c55287b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b8c55287988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b8c552867b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpabopsadx                        0x00005652c4372a56 <unavailable> + 6742

    5    libc.so.6                          0x00002b8c5577c460 __libc_start_main +
    245

    6    tmpabopsadx                        0x00005652c4372499 <unavailable> + 5273

    '
  stdout: ''
  timestamp: 1660013180
- exit_code: 1
  program: "\nenum Value: Equatable, Hashable {\n    case intValue(Int)\n    case\
    \ doubleValue(Double)\n    case stringValue(String)\n}\n\n            \n/// Create\
    \ a function that takes integers, floats, or strings representing\n/// real numbers,\
    \ and returns the larger variable in its given variable type.\n/// Return nil\
    \ if the values are equal.\n/// Note: If a real number is represented as a string,\
    \ the floating point might be . or ,\n/// >>> compare_one(a: .intValue(1), b:\
    \ .doubleValue(2.5))\n/// .doubleValue(2.5)\n/// >>> compare_one(a: .intValue(1),\
    \ b: .stringValue(\"2,3\"))\n/// .stringValue(\"2,3\")\n/// >>> compare_one(a:\
    \ .stringValue(\"5,1\"), b: .stringValue(\"6\"))\n/// .stringValue(\"6\")\n///\
    \ >>> compare_one(a: .stringValue(\"1\"), b: .intValue(1))\n/// nil\nfunc compare_one(a:\
    \ Value, b: Value) -> Value? {\n    switch a {\n    case .intValue(let aValue):\n\
    \        switch b {\n        case .intValue(let bValue):\n            if aValue\
    \ == bValue {\n                return nil\n            } else if aValue > bValue\
    \ {\n                return a\n            } else {\n                return b\n\
    \            }\n        case .doubleValue(let bValue):\n            if aValue\
    \ == bValue {\n                return nil\n            } else if aValue > bValue\
    \ {\n                return a\n            } else {\n                return b\n\
    \            }\n        case .stringValue(let bValue):\n            if let bValue\
    \ = Double(bValue) {\n                if aValue == bValue {\n                \
    \    return nil\n                } else if aValue > bValue {\n               \
    \     return a\n                } else {\n                    return b\n     \
    \           }\n            } else {\n                return nil\n            }\n\
    \        }\n    case .doubleValue(let aValue):\n        switch b {\n        case\
    \ .intValue(let bValue):\n            if aValue == Double(bValue) {\n        \
    \        return nil\n            } else if aValue > Double(bValue) {\n       \
    \         return a\n            } else {\n                return b\n         \
    \   }\n        case .doubleValue(let bValue):\n            if aValue == bValue\
    \ {\n                return nil\n            } else if aValue > bValue {\n   \
    \             return a\n            } else {\n                return b\n     \
    \       }\n        case .stringValue(let bValue):\n            if let bValue =\
    \ Double(bValue) {\n                if aValue == bValue {\n                  \
    \  return nil\n                } else if aValue > bValue {\n                 \
    \   return a\n                } else {\n                    return b\n       \
    \         }\n            } else {\n                return nil\n            }\n\
    \        }\n    case .stringValue(let aValue):\n        switch b {\n        case\
    \ .intValue(let bValue):\n            if let aValue = Double(aValue) {\n     \
    \           if aValue == Double(bValue) {\n                    return nil\n  \
    \              } else if aValue > Double(bValue) {\n                    return\
    \ a\n                } else {\n                    return b\n                }\n\
    \            } else {\n                return nil\n            }\n        case\
    \ .doubleValue(let b\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(compare_one(a:\
    \ .intValue(1), b: .intValue(2)) == .intValue(2))\nassert(compare_one(a: .intValue(1),\
    \ b: .doubleValue(2.5)) == .doubleValue(2.5))\nassert(compare_one(a: .intValue(2),\
    \ b: .intValue(3)) == .intValue(3))\nassert(compare_one(a: .intValue(5), b: .intValue(6))\
    \ == .intValue(6))\nassert(compare_one(a: .intValue(1), b: .stringValue(\"2,3\"\
    )) == .stringValue(\"2,3\"))\nassert(compare_one(a: .stringValue(\"5,1\"), b:\
    \ .stringValue(\"6\")) == .stringValue(\"6\"))\nassert(compare_one(a: .stringValue(\"\
    1\"), b: .stringValue(\"2\")) == .stringValue(\"2\"))\nassert(compare_one(a: .stringValue(\"\
    1\"), b: .intValue(1)) == nil)"
  status: SyntaxError
  stderr: "/tmp/tmpvh295tr1.swift:100:1: error: expected ')' in expression list\n\
    }\n^\n/tmp/tmpvh295tr1.swift:99:26: note: to match this opening '('\n        case\
    \ .doubleValue(let b\n                         ^\n/tmp/tmpvh295tr1.swift:99:32:\
    \ error: expected ':' after 'case'\n        case .doubleValue(let b\n        \
    \                       ^\n/tmp/tmpvh295tr1.swift:122:66: error: expected '}'\
    \ at end of 'switch' statement\nassert(compare_one(a: .stringValue(\"1\"), b:\
    \ .intValue(1)) == nil)\n                                                    \
    \             ^\n/tmp/tmpvh295tr1.swift:22:14: note: to match this opening '{'\n\
    \    switch a {\n             ^\n/tmp/tmpvh295tr1.swift:122:66: error: expected\
    \ '}' at end of brace statement\nassert(compare_one(a: .stringValue(\"1\"), b:\
    \ .intValue(1)) == nil)\n                                                    \
    \             ^\n/tmp/tmpvh295tr1.swift:21:48: note: to match this opening '{'\n\
    func compare_one(a: Value, b: Value) -> Value? {\n                           \
    \                    ^\n/tmp/tmpvh295tr1.swift:34:23: error: binary operator '=='\
    \ cannot be applied to operands of type 'Int' and 'Double'\n            if aValue\
    \ == bValue {\n               ~~~~~~ ^  ~~~~~~\n/tmp/tmpvh295tr1.swift:34:23:\
    \ note: overloads for '==' exist with these partially matching parameter lists:\
    \ (Int, Int)\n            if aValue == bValue {\n                      ^\n/tmp/tmpvh295tr1.swift:36:30:\
    \ error: binary operator '>' cannot be applied to operands of type 'Int' and 'Double'\n\
    \            } else if aValue > bValue {\n                      ~~~~~~ ^ ~~~~~~\n\
    /tmp/tmpvh295tr1.swift:36:30: note: overloads for '>' exist with these partially\
    \ matching parameter lists: (Int, Int)\n            } else if aValue > bValue\
    \ {\n                             ^\n/tmp/tmpvh295tr1.swift:43:27: error: binary\
    \ operator '==' cannot be applied to operands of type 'Int' and 'Double'\n   \
    \             if aValue == bValue {\n                   ~~~~~~ ^  ~~~~~~\n/tmp/tmpvh295tr1.swift:43:27:\
    \ note: overloads for '==' exist with these partially matching parameter lists:\
    \ (Int, Int)\n    "
  stdout: ''
  timestamp: 1660013181
- exit_code: 1
  program: "\nenum Value: Equatable, Hashable {\n    case intValue(Int)\n    case\
    \ doubleValue(Double)\n    case stringValue(String)\n}\n\n            \n/// Create\
    \ a function that takes integers, floats, or strings representing\n/// real numbers,\
    \ and returns the larger variable in its given variable type.\n/// Return nil\
    \ if the values are equal.\n/// Note: If a real number is represented as a string,\
    \ the floating point might be . or ,\n/// >>> compare_one(a: .intValue(1), b:\
    \ .doubleValue(2.5))\n/// .doubleValue(2.5)\n/// >>> compare_one(a: .intValue(1),\
    \ b: .stringValue(\"2,3\"))\n/// .stringValue(\"2,3\")\n/// >>> compare_one(a:\
    \ .stringValue(\"5,1\"), b: .stringValue(\"6\"))\n/// .stringValue(\"6\")\n///\
    \ >>> compare_one(a: .stringValue(\"1\"), b: .intValue(1))\n/// nil\nfunc compare_one(a:\
    \ Value, b: Value) -> Value? {\n    switch (a, b) {\n    case let (.intValue(int_a),\
    \ .intValue(int_b)):\n        return int_a > int_b ? a : b\n    case let (.intValue(int_a),\
    \ .doubleValue(double_b)):\n        return double_b > Double(int_a) ? b : a\n\
    \    case let (.intValue(int_a), .stringValue(string_b)):\n        return Double(string_b)\
    \ > Double(int_a) ? b : a\n    case let (.doubleValue(double_a), .intValue(int_b)):\n\
    \        return double_a > Double(int_b) ? a : b\n    case let (.doubleValue(double_a),\
    \ .doubleValue(double_b)):\n        return double_a > double_b ? a : b\n    case\
    \ let (.doubleValue(double_a), .stringValue(string_b)):\n        return Double(string_b)\
    \ > double_a ? b : a\n    case let (.stringValue(string_a), .intValue(int_b)):\n\
    \        return Double(string_a) > Double(int_b) ? a : b\n    case let (.stringValue(string_a),\
    \ .doubleValue(double_b)):\n        return double_b > Double(string_a) ? b : a\n\
    \    case let (.stringValue(string_a), .stringValue(string_b)):\n        return\
    \ Double(string_a) > Double(string_b) ? a : b\n    }\n}\n\n\nfunc ==(left: [(Int,\
    \ Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n\
    \        return false\n    }\n    for (l, r) in zip(left, right) {\n        if\
    \ l != r {\n            return false\n        }\n    }\n    return true\n}\n \
    \           \nassert(compare_one(a: .intValue(1), b: .intValue(2)) == .intValue(2))\n\
    assert(compare_one(a: .intValue(1), b: .doubleValue(2.5)) == .doubleValue(2.5))\n\
    assert(compare_one(a: .intValue(2), b: .intValue(3)) == .intValue(3))\nassert(compare_one(a:\
    \ .intValue(5), b: .intValue(6)) == .intValue(6))\nassert(compare_one(a: .intValue(1),\
    \ b: .stringValue(\"2,3\")) == .stringValue(\"2,3\"))\nassert(compare_one(a: .stringValue(\"\
    5,1\"), b: .stringValue(\"6\")) == .stringValue(\"6\"))\nassert(compare_one(a:\
    \ .stringValue(\"1\"), b: .stringValue(\"2\")) == .stringValue(\"2\"))\nassert(compare_one(a:\
    \ .stringValue(\"1\"), b: .intValue(1)) == nil)"
  status: SyntaxError
  stderr: "/tmp/tmppc_lewzd.swift:28:16: error: value of optional type 'Double?' must\
    \ be unwrapped to a value of type 'Double'\n        return Double(string_b) >\
    \ Double(int_a) ? b : a\n               ^\n/tmp/tmppc_lewzd.swift:28:16: note:\
    \ coalesce using '??' to provide a default when the optional value contains 'nil'\n\
    \        return Double(string_b) > Double(int_a) ? b : a\n               ^\n \
    \                               ?? <#default value#>\n/tmp/tmppc_lewzd.swift:28:16:\
    \ note: force-unwrap using '!' to abort execution if the optional value contains\
    \ 'nil'\n        return Double(string_b) > Double(int_a) ? b : a\n           \
    \    ^\n                               !\n/tmp/tmppc_lewzd.swift:34:16: error:\
    \ value of optional type 'Double?' must be unwrapped to a value of type 'Double'\n\
    \        return Double(string_b) > double_a ? b : a\n               ^\n/tmp/tmppc_lewzd.swift:34:16:\
    \ note: coalesce using '??' to provide a default when the optional value contains\
    \ 'nil'\n        return Double(string_b) > double_a ? b : a\n               ^\n\
    \                                ?? <#default value#>\n/tmp/tmppc_lewzd.swift:34:16:\
    \ note: force-unwrap using '!' to abort execution if the optional value contains\
    \ 'nil'\n        return Double(string_b) > double_a ? b : a\n               ^\n\
    \                               !\n/tmp/tmppc_lewzd.swift:36:16: error: value\
    \ of optional type 'Double?' must be unwrapped to a value of type 'Double'\n \
    \       return Double(string_a) > Double(int_b) ? a : b\n               ^\n/tmp/tmppc_lewzd.swift:36:16:\
    \ note: coalesce using '??' to provide a default when the optional value contains\
    \ 'nil'\n        return Double(string_a) > Double(int_b) ? a : b\n           \
    \    ^\n                                ?? <#default value#>\n/tmp/tmppc_lewzd.swift:36:16:\
    \ note: force-unwrap using '!' to abort execution if the optional value contains\
    \ 'nil'\n        return Double(string_a) > Double(int_b) ? a : b\n           \
    \    ^\n                               !\n/tmp/tmppc_lewzd.swift:38:27: error:\
    \ value of optional type 'Double?' must be unwrapped to a value of type "
  stdout: ''
  timestamp: 1660013181
- exit_code: 1
  program: "\nenum Value: Equatable, Hashable {\n    case intValue(Int)\n    case\
    \ doubleValue(Double)\n    case stringValue(String)\n}\n\n            \n/// Create\
    \ a function that takes integers, floats, or strings representing\n/// real numbers,\
    \ and returns the larger variable in its given variable type.\n/// Return nil\
    \ if the values are equal.\n/// Note: If a real number is represented as a string,\
    \ the floating point might be . or ,\n/// >>> compare_one(a: .intValue(1), b:\
    \ .doubleValue(2.5))\n/// .doubleValue(2.5)\n/// >>> compare_one(a: .intValue(1),\
    \ b: .stringValue(\"2,3\"))\n/// .stringValue(\"2,3\")\n/// >>> compare_one(a:\
    \ .stringValue(\"5,1\"), b: .stringValue(\"6\"))\n/// .stringValue(\"6\")\n///\
    \ >>> compare_one(a: .stringValue(\"1\"), b: .intValue(1))\n/// nil\nfunc compare_one(a:\
    \ Value, b: Value) -> Value? {\n    switch (a, b) {\n    case (.intValue(let a),\
    \ .intValue(let b)):\n        return a > b ? a : b\n    case (.doubleValue(let\
    \ a), .doubleValue(let b)):\n        return a > b ? a : b\n    case (.stringValue(let\
    \ a), .stringValue(let b)):\n        return a > b ? a : b\n    case (.intValue(let\
    \ a), .doubleValue(let b)):\n        return a > b ? a : b\n    case (.intValue(let\
    \ a), .stringValue(let b)):\n        return a > b ? a : b\n    case (.doubleValue(let\
    \ a), .intValue(let b)):\n        return a > b ? a : b\n    case (.doubleValue(let\
    \ a), .stringValue(let b)):\n        return a > b ? a : b\n    case (.stringValue(let\
    \ a), .intValue(let b)):\n        return a > b ? a : b\n    case (.stringValue(let\
    \ a), .doubleValue(let b)):\n        return a > b ? a : b\n    default:\n    \
    \    return nil\n    }\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(compare_one(a:\
    \ .intValue(1), b: .intValue(2)) == .intValue(2))\nassert(compare_one(a: .intValue(1),\
    \ b: .doubleValue(2.5)) == .doubleValue(2.5))\nassert(compare_one(a: .intValue(2),\
    \ b: .intValue(3)) == .intValue(3))\nassert(compare_one(a: .intValue(5), b: .intValue(6))\
    \ == .intValue(6))\nassert(compare_one(a: .intValue(1), b: .stringValue(\"2,3\"\
    )) == .stringValue(\"2,3\"))\nassert(compare_one(a: .stringValue(\"5,1\"), b:\
    \ .stringValue(\"6\")) == .stringValue(\"6\"))\nassert(compare_one(a: .stringValue(\"\
    1\"), b: .stringValue(\"2\")) == .stringValue(\"2\"))\nassert(compare_one(a: .stringValue(\"\
    1\"), b: .intValue(1)) == nil)"
  status: SyntaxError
  stderr: "/tmp/tmpjf037tzu.swift:24:22: error: cannot convert return expression of\
    \ type 'Int' to return type 'Value?'\n        return a > b ? a : b\n         \
    \      ~~~~~~^~~~~~~\n/tmp/tmpjf037tzu.swift:26:22: error: cannot convert return\
    \ expression of type 'Double' to return type 'Value?'\n        return a > b ?\
    \ a : b\n               ~~~~~~^~~~~~~\n/tmp/tmpjf037tzu.swift:28:22: error: cannot\
    \ convert return expression of type 'String' to return type 'Value?'\n       \
    \ return a > b ? a : b\n               ~~~~~~^~~~~~~\n/tmp/tmpjf037tzu.swift:30:20:\
    \ error: cannot convert value of type 'Double' to expected argument type 'Int'\n\
    \        return a > b ? a : b\n                   ^\n                   Int( )\n\
    /tmp/tmpjf037tzu.swift:30:22: error: cannot convert return expression of type\
    \ 'Int' to return type 'Value?'\n        return a > b ? a : b\n              \
    \ ~~~~~~^~~~~~~\n/tmp/tmpjf037tzu.swift:32:20: error: cannot convert value of\
    \ type 'String' to expected argument type 'Int'\n        return a > b ? a : b\n\
    \                   ^\n/tmp/tmpjf037tzu.swift:32:22: error: cannot convert return\
    \ expression of type 'Int' to return type 'Value?'\n        return a > b ? a :\
    \ b\n               ~~~~~~^~~~~~~\n/tmp/tmpjf037tzu.swift:34:16: error: cannot\
    \ convert value of type 'Double' to expected argument type 'Int'\n        return\
    \ a > b ? a : b\n               ^\n               Int( )\n/tmp/tmpjf037tzu.swift:34:22:\
    \ error: cannot convert return expression of type 'Double' to return type 'Value?'\n\
    \        return a > b ? a : b\n               ~~~~~~^~~~~~~\n/tmp/tmpjf037tzu.swift:36:18:\
    \ error: binary operator '>' cannot be applied to operands of type 'Double' and\
    \ 'String'\n        return a > b ? a : b\n               ~ ^ ~\n/tmp/tmpjf037tzu.swift:36:22:\
    \ error: cannot convert return expression of type 'Double' to return type 'Value?'\n\
    \        return a > b ? a : b\n               ~~~~~~^~~~~~~\n/tmp/tmpjf037tzu.swift:38:16:\
    \ error: cannot convert value of type 'String' to expected argument type 'Int'\n\
    \        return a > b ? a : b\n               ^\n/tmp/tmpjf037tzu.swift:38:22:\
    \ error: ca"
  stdout: ''
  timestamp: 1660013180
- exit_code: 1
  program: "\nenum Value: Equatable, Hashable {\n    case intValue(Int)\n    case\
    \ doubleValue(Double)\n    case stringValue(String)\n}\n\n            \n/// Create\
    \ a function that takes integers, floats, or strings representing\n/// real numbers,\
    \ and returns the larger variable in its given variable type.\n/// Return nil\
    \ if the values are equal.\n/// Note: If a real number is represented as a string,\
    \ the floating point might be . or ,\n/// >>> compare_one(a: .intValue(1), b:\
    \ .doubleValue(2.5))\n/// .doubleValue(2.5)\n/// >>> compare_one(a: .intValue(1),\
    \ b: .stringValue(\"2,3\"))\n/// .stringValue(\"2,3\")\n/// >>> compare_one(a:\
    \ .stringValue(\"5,1\"), b: .stringValue(\"6\"))\n/// .stringValue(\"6\")\n///\
    \ >>> compare_one(a: .stringValue(\"1\"), b: .intValue(1))\n/// nil\nfunc compare_one(a:\
    \ Value, b: Value) -> Value? {\n    var aNum = 0.0\n    var bNum = 0.0\n    if\
    \ case let .intValue(value) = a {\n        aNum = Double(value)\n    } else if\
    \ case let .doubleValue(value) = a {\n        aNum = value\n    } else if case\
    \ let .stringValue(value) = a {\n        aNum = Double(value.replacingOccurrences(of:\
    \ \",\", with: \".\")) ?? 0.0\n    }\n    if case let .intValue(value) = b {\n\
    \        bNum = Double(value)\n    } else if case let .doubleValue(value) = b\
    \ {\n        bNum = value\n    } else if case let .stringValue(value) = b {\n\
    \        bNum = Double(value.replacingOccurrences(of: \",\", with: \".\")) ??\
    \ 0.0\n    }\n    if aNum > bNum {\n        return a\n    } else if aNum < bNum\
    \ {\n        return b\n    } else {\n        return nil\n    }\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(compare_one(a: .intValue(1), b: .intValue(2)) == .intValue(2))\n\
    assert(compare_one(a: .intValue(1), b: .doubleValue(2.5)) == .doubleValue(2.5))\n\
    assert(compare_one(a: .intValue(2), b: .intValue(3)) == .intValue(3))\nassert(compare_one(a:\
    \ .intValue(5), b: .intValue(6)) == .intValue(6))\nassert(compare_one(a: .intValue(1),\
    \ b: .stringValue(\"2,3\")) == .stringValue(\"2,3\"))\nassert(compare_one(a: .stringValue(\"\
    5,1\"), b: .stringValue(\"6\")) == .stringValue(\"6\"))\nassert(compare_one(a:\
    \ .stringValue(\"1\"), b: .stringValue(\"2\")) == .stringValue(\"2\"))\nassert(compare_one(a:\
    \ .stringValue(\"1\"), b: .intValue(1)) == nil)"
  status: SyntaxError
  stderr: "/tmp/tmpp8eu65g5.swift:29:29: error: value of type 'String' has no member\
    \ 'replacingOccurrences'\n        aNum = Double(value.replacingOccurrences(of:\
    \ \",\", with: \".\")) ?? 0.0\n                      ~~~~~ ^~~~~~~~~~~~~~~~~~~~\n\
    /tmp/tmpp8eu65g5.swift:36:29: error: value of type 'String' has no member 'replacingOccurrences'\n\
    \        bNum = Double(value.replacingOccurrences(of: \",\", with: \".\")) ??\
    \ 0.0\n                      ~~~~~ ^~~~~~~~~~~~~~~~~~~~\n"
  stdout: ''
  timestamp: 1660013181
- exit_code: 1
  program: "\nenum Value: Equatable, Hashable {\n    case intValue(Int)\n    case\
    \ doubleValue(Double)\n    case stringValue(String)\n}\n\n            \n/// Create\
    \ a function that takes integers, floats, or strings representing\n/// real numbers,\
    \ and returns the larger variable in its given variable type.\n/// Return nil\
    \ if the values are equal.\n/// Note: If a real number is represented as a string,\
    \ the floating point might be . or ,\n/// >>> compare_one(a: .intValue(1), b:\
    \ .doubleValue(2.5))\n/// .doubleValue(2.5)\n/// >>> compare_one(a: .intValue(1),\
    \ b: .stringValue(\"2,3\"))\n/// .stringValue(\"2,3\")\n/// >>> compare_one(a:\
    \ .stringValue(\"5,1\"), b: .stringValue(\"6\"))\n/// .stringValue(\"6\")\n///\
    \ >>> compare_one(a: .stringValue(\"1\"), b: .intValue(1))\n/// nil\nfunc compare_one(a:\
    \ Value, b: Value) -> Value? {\n    var aValue = 0.0\n    var bValue = 0.0\n \
    \   switch a {\n    case .intValue(let value):\n        aValue = Double(value)\n\
    \    case .doubleValue(let value):\n        aValue = value\n    case .stringValue(let\
    \ value):\n        aValue = Double(value.replacingOccurrences(of: \",\", with:\
    \ \".\")) ?? 0.0\n    }\n    switch b {\n    case .intValue(let value):\n    \
    \    bValue = Double(value)\n    case .doubleValue(let value):\n        bValue\
    \ = value\n    case .stringValue(let value):\n        bValue = Double(value.replacingOccurrences(of:\
    \ \",\", with: \".\")) ?? 0.0\n    }\n    if (aValue == bValue) {\n        return\
    \ nil\n    }\n    if (aValue > bValue) {\n        return a\n    }\n    return\
    \ b\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if\
    \ left.count != right.count {\n        return false\n    }\n    for (l, r) in\
    \ zip(left, right) {\n        if l != r {\n            return false\n        }\n\
    \    }\n    return true\n}\n            \nassert(compare_one(a: .intValue(1),\
    \ b: .intValue(2)) == .intValue(2))\nassert(compare_one(a: .intValue(1), b: .doubleValue(2.5))\
    \ == .doubleValue(2.5))\nassert(compare_one(a: .intValue(2), b: .intValue(3))\
    \ == .intValue(3))\nassert(compare_one(a: .intValue(5), b: .intValue(6)) == .intValue(6))\n\
    assert(compare_one(a: .intValue(1), b: .stringValue(\"2,3\")) == .stringValue(\"\
    2,3\"))\nassert(compare_one(a: .stringValue(\"5,1\"), b: .stringValue(\"6\"))\
    \ == .stringValue(\"6\"))\nassert(compare_one(a: .stringValue(\"1\"), b: .stringValue(\"\
    2\")) == .stringValue(\"2\"))\nassert(compare_one(a: .stringValue(\"1\"), b: .intValue(1))\
    \ == nil)"
  status: SyntaxError
  stderr: "/tmp/tmpyuxy4xhi.swift:30:31: error: value of type 'String' has no member\
    \ 'replacingOccurrences'\n        aValue = Double(value.replacingOccurrences(of:\
    \ \",\", with: \".\")) ?? 0.0\n                        ~~~~~ ^~~~~~~~~~~~~~~~~~~~\n\
    /tmp/tmpyuxy4xhi.swift:38:31: error: value of type 'String' has no member 'replacingOccurrences'\n\
    \        bValue = Double(value.replacingOccurrences(of: \",\", with: \".\")) ??\
    \ 0.0\n                        ~~~~~ ^~~~~~~~~~~~~~~~~~~~\n"
  stdout: ''
  timestamp: 1660013181
- exit_code: 1
  program: "\nenum Value: Equatable, Hashable {\n    case intValue(Int)\n    case\
    \ doubleValue(Double)\n    case stringValue(String)\n}\n\n            \n/// Create\
    \ a function that takes integers, floats, or strings representing\n/// real numbers,\
    \ and returns the larger variable in its given variable type.\n/// Return nil\
    \ if the values are equal.\n/// Note: If a real number is represented as a string,\
    \ the floating point might be . or ,\n/// >>> compare_one(a: .intValue(1), b:\
    \ .doubleValue(2.5))\n/// .doubleValue(2.5)\n/// >>> compare_one(a: .intValue(1),\
    \ b: .stringValue(\"2,3\"))\n/// .stringValue(\"2,3\")\n/// >>> compare_one(a:\
    \ .stringValue(\"5,1\"), b: .stringValue(\"6\"))\n/// .stringValue(\"6\")\n///\
    \ >>> compare_one(a: .stringValue(\"1\"), b: .intValue(1))\n/// nil\nfunc compare_one(a:\
    \ Value, b: Value) -> Value? {\n    // TODO: Implement\n    let c: Value?\n  \
    \  switch (a, b) {\n    case let (.intValue(a), .intValue(b)):\n        c = a\
    \ >= b ? a : b\n    case let (.intValue(a), .doubleValue(b)):\n        c = a >=\
    \ b ? a : b\n    case let (.intValue(a), .stringValue(b)):\n        c = a >= Double(b)!\
    \ ? a : b\n    case let (.doubleValue(a), .intValue(b)):\n        c = a >= b ?\
    \ a : b\n    case let (.doubleValue(a), .doubleValue(b)):\n        c = a >= b\
    \ ? a : b\n    case let (.doubleValue(a), .stringValue(b)):\n        c = a >=\
    \ Double(b)! ? a : b\n    case let (.stringValue(a), .intValue(b)):\n        c\
    \ = Double(a)! >= b ? a : b\n    case let (.stringValue(a), .doubleValue(b)):\n\
    \        c = Double(a)! >= b ? a : b\n    case let (.stringValue(a), .stringValue(b)):\n\
    \        c = Double(a)! >= Double(b)! ? a : b\n    }\n    return c\n}\n\n\nfunc\
    \ ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count !=\
    \ right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(compare_one(a: .intValue(1), b: .intValue(2))\
    \ == .intValue(2))\nassert(compare_one(a: .intValue(1), b: .doubleValue(2.5))\
    \ == .doubleValue(2.5))\nassert(compare_one(a: .intValue(2), b: .intValue(3))\
    \ == .intValue(3))\nassert(compare_one(a: .intValue(5), b: .intValue(6)) == .intValue(6))\n\
    assert(compare_one(a: .intValue(1), b: .stringValue(\"2,3\")) == .stringValue(\"\
    2,3\"))\nassert(compare_one(a: .stringValue(\"5,1\"), b: .stringValue(\"6\"))\
    \ == .stringValue(\"6\"))\nassert(compare_one(a: .stringValue(\"1\"), b: .stringValue(\"\
    2\")) == .stringValue(\"2\"))\nassert(compare_one(a: .stringValue(\"1\"), b: .intValue(1))\
    \ == nil)"
  status: SyntaxError
  stderr: "/tmp/tmpjvpkx4wi.swift:26:11: error: cannot assign value of type 'Int'\
    \ to type 'Value?'\n        c = a >= b ? a : b\n          ^\n/tmp/tmpjvpkx4wi.swift:28:11:\
    \ error: cannot assign value of type 'Double' to type 'Value?'\n        c = a\
    \ >= b ? a : b\n          ^\n/tmp/tmpjvpkx4wi.swift:28:18: error: cannot convert\
    \ value of type 'Double' to expected argument type 'Int'\n        c = a >= b ?\
    \ a : b\n                 ^\n                 Int( )\n/tmp/tmpjvpkx4wi.swift:28:22:\
    \ error: result values in '? :' expression have mismatching types 'Int' and 'Double'\n\
    \        c = a >= b ? a : b\n                     ^\n                     Double(\
    \ )\n/tmp/tmpjvpkx4wi.swift:30:11: error: cannot assign value of type 'String'\
    \ to type 'Value?'\n        c = a >= Double(b)! ? a : b\n          ^\n/tmp/tmpjvpkx4wi.swift:30:27:\
    \ error: cannot convert value of type 'Double' to expected argument type 'Int'\n\
    \        c = a >= Double(b)! ? a : b\n                          ^\n          \
    \       Int(      )\n/tmp/tmpjvpkx4wi.swift:30:31: error: result values in '?\
    \ :' expression have mismatching types 'Int' and 'String'\n        c = a >= Double(b)!\
    \ ? a : b\n                              ^\n/tmp/tmpjvpkx4wi.swift:32:11: error:\
    \ cannot assign value of type 'Int' to type 'Value?'\n        c = a >= b ? a :\
    \ b\n          ^\n/tmp/tmpjvpkx4wi.swift:32:13: error: cannot convert value of\
    \ type 'Double' to expected argument type 'Int'\n        c = a >= b ? a : b\n\
    \            ^\n            Int( )\n/tmp/tmpjvpkx4wi.swift:32:22: error: result\
    \ values in '? :' expression have mismatching types 'Double' and 'Int'\n     \
    \   c = a >= b ? a : b\n                     ^\n                     Int( )\n\
    /tmp/tmpjvpkx4wi.swift:34:11: error: cannot assign value of type 'Double' to type\
    \ 'Value?'\n        c = a >= b ? a : b\n          ^\n/tmp/tmpjvpkx4wi.swift:36:11:\
    \ error: cannot assign value of type 'String' to type 'Value?'\n        c = a\
    \ >= Double(b)! ? a : b\n          ^\n/tmp/tmpjvpkx4wi.swift:36:31: error: result\
    \ values in '? :' expression have mismatching types 'Double' and 'String'\n  \
    \      c = a >= Double(b)! ? "
  stdout: ''
  timestamp: 1660013181
- exit_code: -4
  program: "\nenum Value: Equatable, Hashable {\n    case intValue(Int)\n    case\
    \ doubleValue(Double)\n    case stringValue(String)\n}\n\n            \n/// Create\
    \ a function that takes integers, floats, or strings representing\n/// real numbers,\
    \ and returns the larger variable in its given variable type.\n/// Return nil\
    \ if the values are equal.\n/// Note: If a real number is represented as a string,\
    \ the floating point might be . or ,\n/// >>> compare_one(a: .intValue(1), b:\
    \ .doubleValue(2.5))\n/// .doubleValue(2.5)\n/// >>> compare_one(a: .intValue(1),\
    \ b: .stringValue(\"2,3\"))\n/// .stringValue(\"2,3\")\n/// >>> compare_one(a:\
    \ .stringValue(\"5,1\"), b: .stringValue(\"6\"))\n/// .stringValue(\"6\")\n///\
    \ >>> compare_one(a: .stringValue(\"1\"), b: .intValue(1))\n/// nil\nfunc compare_one(a:\
    \ Value, b: Value) -> Value? {\n    \n    switch (a, b) {\n    case let (.intValue(i1),\
    \ .intValue(i2)):\n        return i1 > i2 ? a : (i1 < i2 ? b : nil)\n    case\
    \ let (.intValue(i1), .doubleValue(d2)):\n        return a\n    case let (.intValue(i1),\
    \ .stringValue(s2)):\n        return a\n    case let (.doubleValue(d1), .intValue(i2)):\n\
    \        return b\n    case let (.doubleValue(d1), .doubleValue(d2)):\n      \
    \  return d1 > d2 ? a : (d1 < d2 ? b : nil)\n    case let (.doubleValue(d1), .stringValue(s2)):\n\
    \        return a\n    case let (.stringValue(s1), .intValue(i2)):\n        return\
    \ b\n    case let (.stringValue(s1), .doubleValue(d2)):\n        return b\n  \
    \  case let (.stringValue(s1), .stringValue(s2)):\n        if let d1 = Double(s1),\
    \ let d2 = Double(s2) {\n            return d1 > d2 ? a : (d1 < d2 ? b : nil)\n\
    \        } else {\n            return s1 > s2 ? a : (s1 < s2 ? b : nil)\n    \
    \    }\n    }\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool\
    \ {\n    if left.count != right.count {\n        return false\n    }\n    for\
    \ (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(compare_one(a: .intValue(1),\
    \ b: .intValue(2)) == .intValue(2))\nassert(compare_one(a: .intValue(1), b: .doubleValue(2.5))\
    \ == .doubleValue(2.5))\nassert(compare_one(a: .intValue(2), b: .intValue(3))\
    \ == .intValue(3))\nassert(compare_one(a: .intValue(5), b: .intValue(6)) == .intValue(6))\n\
    assert(compare_one(a: .intValue(1), b: .stringValue(\"2,3\")) == .stringValue(\"\
    2,3\"))\nassert(compare_one(a: .stringValue(\"5,1\"), b: .stringValue(\"6\"))\
    \ == .stringValue(\"6\"))\nassert(compare_one(a: .stringValue(\"1\"), b: .stringValue(\"\
    2\")) == .stringValue(\"2\"))\nassert(compare_one(a: .stringValue(\"1\"), b: .intValue(1))\
    \ == nil)"
  status: Exception
  stderr: 'tmpqs8l97k7/tmpqs8l97k7.swift:63: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b1c24072c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b1c23d69b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b1c23d69988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b1c23d687b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpqs8l97k7                        0x000055d21cfa4ed4 <unavailable> + 7892

    5    libc.so.6                          0x00002b1c2425e460 __libc_start_main +
    245

    6    tmpqs8l97k7                        0x000055d21cfa4619 <unavailable> + 5657

    '
  stdout: ''
  timestamp: 1660013181
- exit_code: -4
  program: "\nenum Value: Equatable, Hashable {\n    case intValue(Int)\n    case\
    \ doubleValue(Double)\n    case stringValue(String)\n}\n\n            \n/// Create\
    \ a function that takes integers, floats, or strings representing\n/// real numbers,\
    \ and returns the larger variable in its given variable type.\n/// Return nil\
    \ if the values are equal.\n/// Note: If a real number is represented as a string,\
    \ the floating point might be . or ,\n/// >>> compare_one(a: .intValue(1), b:\
    \ .doubleValue(2.5))\n/// .doubleValue(2.5)\n/// >>> compare_one(a: .intValue(1),\
    \ b: .stringValue(\"2,3\"))\n/// .stringValue(\"2,3\")\n/// >>> compare_one(a:\
    \ .stringValue(\"5,1\"), b: .stringValue(\"6\"))\n/// .stringValue(\"6\")\n///\
    \ >>> compare_one(a: .stringValue(\"1\"), b: .intValue(1))\n/// nil\nfunc compare_one(a:\
    \ Value, b: Value) -> Value? {\n    switch (a, b) {\n    case (.intValue(let intA),\
    \ .intValue(let intB)):\n        return intA > intB ? a : b\n    case (.intValue(let\
    \ intA), .doubleValue(let doubleB)):\n        return doubleB > Double(intA) ?\
    \ b : a\n    case (.intValue(let intA), .stringValue(let stringB)):\n        return\
    \ Double(stringB)! > Double(intA) ? b : a\n    case (.doubleValue(let doubleA),\
    \ .intValue(let intB)):\n        return doubleA > Double(intB) ? a : b\n    case\
    \ (.doubleValue(let doubleA), .doubleValue(let doubleB)):\n        return doubleA\
    \ > doubleB ? a : b\n    case (.doubleValue(let doubleA), .stringValue(let stringB)):\n\
    \        return Double(stringB)! > doubleA ? b : a\n    case (.stringValue(let\
    \ stringA), .intValue(let intB)):\n        return Double(stringA)! > Double(intB)\
    \ ? a : b\n    case (.stringValue(let stringA), .doubleValue(let doubleB)):\n\
    \        return Double(stringA)! > doubleB ? a : b\n    case (.stringValue(let\
    \ stringA), .stringValue(let stringB)):\n        return Double(stringA)! > Double(stringB)!\
    \ ? a : b\n    }\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool\
    \ {\n    if left.count != right.count {\n        return false\n    }\n    for\
    \ (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(compare_one(a: .intValue(1),\
    \ b: .intValue(2)) == .intValue(2))\nassert(compare_one(a: .intValue(1), b: .doubleValue(2.5))\
    \ == .doubleValue(2.5))\nassert(compare_one(a: .intValue(2), b: .intValue(3))\
    \ == .intValue(3))\nassert(compare_one(a: .intValue(5), b: .intValue(6)) == .intValue(6))\n\
    assert(compare_one(a: .intValue(1), b: .stringValue(\"2,3\")) == .stringValue(\"\
    2,3\"))\nassert(compare_one(a: .stringValue(\"5,1\"), b: .stringValue(\"6\"))\
    \ == .stringValue(\"6\"))\nassert(compare_one(a: .stringValue(\"1\"), b: .stringValue(\"\
    2\")) == .stringValue(\"2\"))\nassert(compare_one(a: .stringValue(\"1\"), b: .intValue(1))\
    \ == nil)"
  status: Exception
  stderr: 'tmpmi9yl8k1/tmpmi9yl8k1.swift:28: Fatal error: Unexpectedly found nil while
    unwrapping an Optional value

    Current stack trace:

    0    libswiftCore.so                    0x00002b1f79249c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b1f78f40561 <unavailable> + 1434977

    2    libswiftCore.so                    0x00002b1f78f40286 <unavailable> + 1434246

    3    libswiftCore.so                    0x00002b1f78f4013c <unavailable> + 1433916

    4    libswiftCore.so                    0x00002b1f78f3fbb0 _assertionFailure(_:_:file:line:flags:)
    + 251

    5    tmpmi9yl8k1                        0x00005562cc733d0d <unavailable> + 15629

    6    tmpmi9yl8k1                        0x00005562cc7324cd <unavailable> + 9421

    7    libc.so.6                          0x00002b1f79435460 __libc_start_main +
    245

    8    tmpmi9yl8k1                        0x00005562cc7315c9 <unavailable> + 5577

    '
  stdout: ''
  timestamp: 1660013181
- exit_code: 1
  program: "\nenum Value: Equatable, Hashable {\n    case intValue(Int)\n    case\
    \ doubleValue(Double)\n    case stringValue(String)\n}\n\n            \n/// Create\
    \ a function that takes integers, floats, or strings representing\n/// real numbers,\
    \ and returns the larger variable in its given variable type.\n/// Return nil\
    \ if the values are equal.\n/// Note: If a real number is represented as a string,\
    \ the floating point might be . or ,\n/// >>> compare_one(a: .intValue(1), b:\
    \ .doubleValue(2.5))\n/// .doubleValue(2.5)\n/// >>> compare_one(a: .intValue(1),\
    \ b: .stringValue(\"2,3\"))\n/// .stringValue(\"2,3\")\n/// >>> compare_one(a:\
    \ .stringValue(\"5,1\"), b: .stringValue(\"6\"))\n/// .stringValue(\"6\")\n///\
    \ >>> compare_one(a: .stringValue(\"1\"), b: .intValue(1))\n/// nil\nfunc compare_one(a:\
    \ Value, b: Value) -> Value? {\n    switch (a, b) {\n    case (.intValue(let a),\
    \ .intValue(let b)):\n        return a > b ? a : b\n    case (.doubleValue(let\
    \ a), .doubleValue(let b)):\n        return a > b ? a : b\n    case (.stringValue(let\
    \ a), .stringValue(let b)):\n        return a > b ? a : b\n    default:\n    \
    \    return nil\n    }\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(compare_one(a:\
    \ .intValue(1), b: .intValue(2)) == .intValue(2))\nassert(compare_one(a: .intValue(1),\
    \ b: .doubleValue(2.5)) == .doubleValue(2.5))\nassert(compare_one(a: .intValue(2),\
    \ b: .intValue(3)) == .intValue(3))\nassert(compare_one(a: .intValue(5), b: .intValue(6))\
    \ == .intValue(6))\nassert(compare_one(a: .intValue(1), b: .stringValue(\"2,3\"\
    )) == .stringValue(\"2,3\"))\nassert(compare_one(a: .stringValue(\"5,1\"), b:\
    \ .stringValue(\"6\")) == .stringValue(\"6\"))\nassert(compare_one(a: .stringValue(\"\
    1\"), b: .stringValue(\"2\")) == .stringValue(\"2\"))\nassert(compare_one(a: .stringValue(\"\
    1\"), b: .intValue(1)) == nil)"
  status: SyntaxError
  stderr: "/tmp/tmp07haxekb.swift:24:22: error: cannot convert return expression of\
    \ type 'Int' to return type 'Value?'\n        return a > b ? a : b\n         \
    \      ~~~~~~^~~~~~~\n/tmp/tmp07haxekb.swift:26:22: error: cannot convert return\
    \ expression of type 'Double' to return type 'Value?'\n        return a > b ?\
    \ a : b\n               ~~~~~~^~~~~~~\n/tmp/tmp07haxekb.swift:28:22: error: cannot\
    \ convert return expression of type 'String' to return type 'Value?'\n       \
    \ return a > b ? a : b\n               ~~~~~~^~~~~~~\n"
  stdout: ''
  timestamp: 1660013180
- exit_code: 1
  program: "\nenum Value: Equatable, Hashable {\n    case intValue(Int)\n    case\
    \ doubleValue(Double)\n    case stringValue(String)\n}\n\n            \n/// Create\
    \ a function that takes integers, floats, or strings representing\n/// real numbers,\
    \ and returns the larger variable in its given variable type.\n/// Return nil\
    \ if the values are equal.\n/// Note: If a real number is represented as a string,\
    \ the floating point might be . or ,\n/// >>> compare_one(a: .intValue(1), b:\
    \ .doubleValue(2.5))\n/// .doubleValue(2.5)\n/// >>> compare_one(a: .intValue(1),\
    \ b: .stringValue(\"2,3\"))\n/// .stringValue(\"2,3\")\n/// >>> compare_one(a:\
    \ .stringValue(\"5,1\"), b: .stringValue(\"6\"))\n/// .stringValue(\"6\")\n///\
    \ >>> compare_one(a: .stringValue(\"1\"), b: .intValue(1))\n/// nil\nfunc compare_one(a:\
    \ Value, b: Value) -> Value? {\n    var valueA: Double\n    var valueB: Double\n\
    \    if case .intValue(let v) = a {\n        valueA = Double(v)\n    } else if\
    \ case .doubleValue(let v) = a {\n        valueA = v\n    } else if case .stringValue(let\
    \ v) = a {\n        valueA = Double(v.replacingOccurrences(of: \",\", with: \"\
    .\")) ?? 0\n    } else {\n        return nil\n    }\n    if case .intValue(let\
    \ v) = b {\n        valueB = Double(v)\n    } else if case .doubleValue(let v)\
    \ = b {\n        valueB = v\n    } else if case .stringValue(let v) = b {\n  \
    \      valueB = Double(v.replacingOccurrences(of: \",\", with: \".\")) ?? 0\n\
    \    } else {\n        return nil\n    }\n    if valueA == valueB {\n        return\
    \ nil\n    } else if valueA > valueB {\n        return a\n    } else {\n     \
    \   return b\n    }\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) ->\
    \ Bool {\n    if left.count != right.count {\n        return false\n    }\n  \
    \  for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(compare_one(a: .intValue(1),\
    \ b: .intValue(2)) == .intValue(2))\nassert(compare_one(a: .intValue(1), b: .doubleValue(2.5))\
    \ == .doubleValue(2.5))\nassert(compare_one(a: .intValue(2), b: .intValue(3))\
    \ == .intValue(3))\nassert(compare_one(a: .intValue(5), b: .intValue(6)) == .intValue(6))\n\
    assert(compare_one(a: .intValue(1), b: .stringValue(\"2,3\")) == .stringValue(\"\
    2,3\"))\nassert(compare_one(a: .stringValue(\"5,1\"), b: .stringValue(\"6\"))\
    \ == .stringValue(\"6\"))\nassert(compare_one(a: .stringValue(\"1\"), b: .stringValue(\"\
    2\")) == .stringValue(\"2\"))\nassert(compare_one(a: .stringValue(\"1\"), b: .intValue(1))\
    \ == nil)"
  status: SyntaxError
  stderr: "/tmp/tmphubse3j1.swift:29:27: error: value of type 'String' has no member\
    \ 'replacingOccurrences'\n        valueA = Double(v.replacingOccurrences(of: \"\
    ,\", with: \".\")) ?? 0\n                        ~ ^~~~~~~~~~~~~~~~~~~~\n/tmp/tmphubse3j1.swift:38:27:\
    \ error: value of type 'String' has no member 'replacingOccurrences'\n       \
    \ valueB = Double(v.replacingOccurrences(of: \",\", with: \".\")) ?? 0\n     \
    \                   ~ ^~~~~~~~~~~~~~~~~~~~\n"
  stdout: ''
  timestamp: 1660013181
- exit_code: -4
  program: "\nenum Value: Equatable, Hashable {\n    case intValue(Int)\n    case\
    \ doubleValue(Double)\n    case stringValue(String)\n}\n\n            \n/// Create\
    \ a function that takes integers, floats, or strings representing\n/// real numbers,\
    \ and returns the larger variable in its given variable type.\n/// Return nil\
    \ if the values are equal.\n/// Note: If a real number is represented as a string,\
    \ the floating point might be . or ,\n/// >>> compare_one(a: .intValue(1), b:\
    \ .doubleValue(2.5))\n/// .doubleValue(2.5)\n/// >>> compare_one(a: .intValue(1),\
    \ b: .stringValue(\"2,3\"))\n/// .stringValue(\"2,3\")\n/// >>> compare_one(a:\
    \ .stringValue(\"5,1\"), b: .stringValue(\"6\"))\n/// .stringValue(\"6\")\n///\
    \ >>> compare_one(a: .stringValue(\"1\"), b: .intValue(1))\n/// nil\nfunc compare_one(a:\
    \ Value, b: Value) -> Value? {\n    // TODO\n    return nil\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(compare_one(a: .intValue(1), b: .intValue(2)) == .intValue(2))\n\
    assert(compare_one(a: .intValue(1), b: .doubleValue(2.5)) == .doubleValue(2.5))\n\
    assert(compare_one(a: .intValue(2), b: .intValue(3)) == .intValue(3))\nassert(compare_one(a:\
    \ .intValue(5), b: .intValue(6)) == .intValue(6))\nassert(compare_one(a: .intValue(1),\
    \ b: .stringValue(\"2,3\")) == .stringValue(\"2,3\"))\nassert(compare_one(a: .stringValue(\"\
    5,1\"), b: .stringValue(\"6\")) == .stringValue(\"6\"))\nassert(compare_one(a:\
    \ .stringValue(\"1\"), b: .stringValue(\"2\")) == .stringValue(\"2\"))\nassert(compare_one(a:\
    \ .stringValue(\"1\"), b: .intValue(1)) == nil)"
  status: Exception
  stderr: 'tmpabopsadx/tmpabopsadx.swift:39: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b8c55590c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b8c55287b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b8c55287988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b8c552867b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpabopsadx                        0x00005652c4372a56 <unavailable> + 6742

    5    libc.so.6                          0x00002b8c5577c460 __libc_start_main +
    245

    6    tmpabopsadx                        0x00005652c4372499 <unavailable> + 5273

    '
  stdout: ''
  timestamp: 1660013180
- exit_code: 1
  program: "\nenum Value: Equatable, Hashable {\n    case intValue(Int)\n    case\
    \ doubleValue(Double)\n    case stringValue(String)\n}\n\n            \n/// Create\
    \ a function that takes integers, floats, or strings representing\n/// real numbers,\
    \ and returns the larger variable in its given variable type.\n/// Return nil\
    \ if the values are equal.\n/// Note: If a real number is represented as a string,\
    \ the floating point might be . or ,\n/// >>> compare_one(a: .intValue(1), b:\
    \ .doubleValue(2.5))\n/// .doubleValue(2.5)\n/// >>> compare_one(a: .intValue(1),\
    \ b: .stringValue(\"2,3\"))\n/// .stringValue(\"2,3\")\n/// >>> compare_one(a:\
    \ .stringValue(\"5,1\"), b: .stringValue(\"6\"))\n/// .stringValue(\"6\")\n///\
    \ >>> compare_one(a: .stringValue(\"1\"), b: .intValue(1))\n/// nil\nfunc compare_one(a:\
    \ Value, b: Value) -> Value? {\n    switch (a, b) {\n    case let (.intValue(a),\
    \ .intValue(b)) where a != b:\n        return a > b ? a : b\n    case let (.doubleValue(a),\
    \ .doubleValue(b)) where a != b:\n        return a > b ? a : b\n    case let (.stringValue(a),\
    \ .stringValue(b)) where a != b:\n        return a > b ? a : b\n    default:\n\
    \        return nil\n    }\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(compare_one(a:\
    \ .intValue(1), b: .intValue(2)) == .intValue(2))\nassert(compare_one(a: .intValue(1),\
    \ b: .doubleValue(2.5)) == .doubleValue(2.5))\nassert(compare_one(a: .intValue(2),\
    \ b: .intValue(3)) == .intValue(3))\nassert(compare_one(a: .intValue(5), b: .intValue(6))\
    \ == .intValue(6))\nassert(compare_one(a: .intValue(1), b: .stringValue(\"2,3\"\
    )) == .stringValue(\"2,3\"))\nassert(compare_one(a: .stringValue(\"5,1\"), b:\
    \ .stringValue(\"6\")) == .stringValue(\"6\"))\nassert(compare_one(a: .stringValue(\"\
    1\"), b: .stringValue(\"2\")) == .stringValue(\"2\"))\nassert(compare_one(a: .stringValue(\"\
    1\"), b: .intValue(1)) == nil)"
  status: SyntaxError
  stderr: "/tmp/tmpe9rc17ll.swift:24:22: error: cannot convert return expression of\
    \ type 'Int' to return type 'Value?'\n        return a > b ? a : b\n         \
    \      ~~~~~~^~~~~~~\n/tmp/tmpe9rc17ll.swift:26:22: error: cannot convert return\
    \ expression of type 'Double' to return type 'Value?'\n        return a > b ?\
    \ a : b\n               ~~~~~~^~~~~~~\n/tmp/tmpe9rc17ll.swift:28:22: error: cannot\
    \ convert return expression of type 'String' to return type 'Value?'\n       \
    \ return a > b ? a : b\n               ~~~~~~^~~~~~~\n"
  stdout: ''
  timestamp: 1660013179
- exit_code: 1
  program: "\nenum Value: Equatable, Hashable {\n    case intValue(Int)\n    case\
    \ doubleValue(Double)\n    case stringValue(String)\n}\n\n            \n/// Create\
    \ a function that takes integers, floats, or strings representing\n/// real numbers,\
    \ and returns the larger variable in its given variable type.\n/// Return nil\
    \ if the values are equal.\n/// Note: If a real number is represented as a string,\
    \ the floating point might be . or ,\n/// >>> compare_one(a: .intValue(1), b:\
    \ .doubleValue(2.5))\n/// .doubleValue(2.5)\n/// >>> compare_one(a: .intValue(1),\
    \ b: .stringValue(\"2,3\"))\n/// .stringValue(\"2,3\")\n/// >>> compare_one(a:\
    \ .stringValue(\"5,1\"), b: .stringValue(\"6\"))\n/// .stringValue(\"6\")\n///\
    \ >>> compare_one(a: .stringValue(\"1\"), b: .intValue(1))\n/// nil\nfunc compare_one(a:\
    \ Value, b: Value) -> Value? {\n    // TODO: Write your code here\n    var a_max:\
    \ Value?\n    var b_max: Value?\n    switch (a, b) {\n        case let (.intValue(a),\
    \ .intValue(b)):\n            if a > b {\n                a_max = a\n        \
    \    } else if a < b {\n                b_max = b\n            }\n        case\
    \ let (.intValue(a), .doubleValue(b)):\n            if a > b {\n             \
    \   a_max = a\n            } else if a < b {\n                b_max = b\n    \
    \        }\n        case let (.intValue(a), .stringValue(b)):\n            if\
    \ a > Int(b)! {\n                a_max = a\n            } else if a < Int(b)!\
    \ {\n                b_max = b\n            }\n        case let (.doubleValue(a),\
    \ .intValue(b)):\n            if a > b {\n                a_max = a\n        \
    \    } else if a < b {\n                b_max = b\n            }\n        case\
    \ let (.doubleValue(a), .doubleValue(b)):\n            if a > b {\n          \
    \      a_max = a\n            } else if a < b {\n                b_max = b\n \
    \           }\n        case let (.doubleValue(a), .stringValue(b)):\n        \
    \    if a > Double(b)! {\n                a_max = a\n            } else if a <\
    \ Double(b)! {\n                b_max = b\n            }\n        case let (.stringValue(a),\
    \ .intValue(b)):\n            if Int(a)! > b {\n                a_max = a\n  \
    \          } else if Int(a)! < b {\n                b_max = b\n            }\n\
    \        case let (.stringValue(a), .doubleValue(b)):\n            if Double(a)!\
    \ > b {\n                a_max = a\n            } else if Double(a)! < b {\n \
    \               b_max = b\n            }\n        case let (.stringValue(a), .stringValue(b)):\n\
    \            if Int(a)! > Int(b)! {\n                a_max = a\n            }\
    \ else if Int(a)! < Int(b)!\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int,\
    \ Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n\
    \    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n          \
    \  return false\n        }\n    }\n    return true\n}\n            \nassert(compare_one(a:\
    \ .intValue(1), b: .intValue(2)) == .intValue(2))\nassert(compare_one(a: .intValue(1),\
    \ b: .doubleValue(2.5)) == .doubleValue(2.5))\nassert(compare_one(a: .intValue(2),\
    \ b: .intValue(3)) == .intValue(3))\nassert(compare_one(a: .intValue(5), b: .intValue(6))\
    \ == .intValue(6))\nassert(compare_one(a: .intValue(1), b: .stringValue(\"2,3\"\
    )) == .stringValue(\"2,3\"))\nassert(compare_one(a: .stringValue(\"5,1\"), b:\
    \ .stringValue(\"6\")) == .stringValue(\"6\"))\nassert(compare_one(a: .stringValue(\"\
    1\"), b: .stringValue(\"2\")) == .stringValue(\"2\"))\nassert(compare_one(a: .stringValue(\"\
    1\"), b: .intValue(1)) == nil)"
  status: SyntaxError
  stderr: "/tmp/tmp_0_wolyy.swift:77:40: error: expected '{' after 'if' condition\n\
    \            } else if Int(a)! < Int(b)!\n                                   \
    \    ^\n/tmp/tmp_0_wolyy.swift:100:66: error: expected '}' at end of brace statement\n\
    assert(compare_one(a: .stringValue(\"1\"), b: .intValue(1)) == nil)\n        \
    \                                                         ^\n/tmp/tmp_0_wolyy.swift:21:48:\
    \ note: to match this opening '{'\nfunc compare_one(a: Value, b: Value) -> Value?\
    \ {\n                                               ^\n/tmp/tmp_0_wolyy.swift:28:23:\
    \ error: cannot assign value of type 'Int' to type 'Value?'\n                a_max\
    \ = a\n                      ^\n/tmp/tmp_0_wolyy.swift:30:23: error: cannot assign\
    \ value of type 'Int' to type 'Value?'\n                b_max = b\n          \
    \            ^\n/tmp/tmp_0_wolyy.swift:33:18: error: binary operator '>' cannot\
    \ be applied to operands of type 'Int' and 'Double'\n            if a > b {\n\
    \               ~ ^ ~\n/tmp/tmp_0_wolyy.swift:33:18: note: overloads for '>' exist\
    \ with these partially matching parameter lists: (Int, Int)\n            if a\
    \ > b {\n                 ^\n/tmp/tmp_0_wolyy.swift:34:23: error: cannot assign\
    \ value of type 'Int' to type 'Value?'\n                a_max = a\n          \
    \            ^\n/tmp/tmp_0_wolyy.swift:35:25: error: binary operator '<' cannot\
    \ be applied to operands of type 'Int' and 'Double'\n            } else if a <\
    \ b {\n                      ~ ^ ~\n/tmp/tmp_0_wolyy.swift:35:25: note: overloads\
    \ for '<' exist with these partially matching parameter lists: (Int, Int)\n  \
    \          } else if a < b {\n                        ^\n/tmp/tmp_0_wolyy.swift:36:23:\
    \ error: cannot assign value of type 'Double' to type 'Value?'\n             \
    \   b_max = b\n                      ^\n/tmp/tmp_0_wolyy.swift:40:23: error: cannot\
    \ assign value of type 'Int' to type 'Value?'\n                a_max = a\n   \
    \                   ^\n/tmp/tmp_0_wolyy.swift:42:23: error: cannot assign value\
    \ of type 'String' to type 'Value?'\n                b_max = b\n             \
    \         ^\n/tmp/tmp_0_wolyy.swift:45:18"
  stdout: ''
  timestamp: 1660013181
- exit_code: 1
  program: "\nenum Value: Equatable, Hashable {\n    case intValue(Int)\n    case\
    \ doubleValue(Double)\n    case stringValue(String)\n}\n\n            \n/// Create\
    \ a function that takes integers, floats, or strings representing\n/// real numbers,\
    \ and returns the larger variable in its given variable type.\n/// Return nil\
    \ if the values are equal.\n/// Note: If a real number is represented as a string,\
    \ the floating point might be . or ,\n/// >>> compare_one(a: .intValue(1), b:\
    \ .doubleValue(2.5))\n/// .doubleValue(2.5)\n/// >>> compare_one(a: .intValue(1),\
    \ b: .stringValue(\"2,3\"))\n/// .stringValue(\"2,3\")\n/// >>> compare_one(a:\
    \ .stringValue(\"5,1\"), b: .stringValue(\"6\"))\n/// .stringValue(\"6\")\n///\
    \ >>> compare_one(a: .stringValue(\"1\"), b: .intValue(1))\n/// nil\nfunc compare_one(a:\
    \ Value, b: Value) -> Value? {\n    switch a {\n    case .intValue(let numA):\n\
    \        switch b {\n        case .intValue(let numB):\n            return numA\
    \ > numB ? a : b\n        case .doubleValue(let numB):\n            return numA\
    \ > numB ? a : b\n        case .stringValue(let numB):\n            return numA\
    \ > numB.asDouble() ? a : b\n        }\n    case .doubleValue(let numA):\n   \
    \     switch b {\n        case .intValue(let numB):\n            return numA >\
    \ numB ? a : b\n        case .doubleValue(let numB):\n            return numA\
    \ > numB ? a : b\n        case .stringValue(let numB):\n            return numA\
    \ > numB.asDouble() ? a : b\n        }\n    case .stringValue(let numA):\n   \
    \     switch b {\n        case .intValue(let numB):\n            return numA.asDouble()\
    \ > numB ? a : b\n        case .doubleValue(let numB):\n            return numA.asDouble()\
    \ > numB ? a : b\n        case .stringValue(let numB):\n            return numA.asDouble()\
    \ > numB.asDouble() ? a : b\n        }\n    }\n}\n\n\nfunc ==(left: [(Int, Int)],\
    \ right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n       \
    \ return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r\
    \ {\n            return false\n        }\n    }\n    return true\n}\n        \
    \    \nassert(compare_one(a: .intValue(1), b: .intValue(2)) == .intValue(2))\n\
    assert(compare_one(a: .intValue(1), b: .doubleValue(2.5)) == .doubleValue(2.5))\n\
    assert(compare_one(a: .intValue(2), b: .intValue(3)) == .intValue(3))\nassert(compare_one(a:\
    \ .intValue(5), b: .intValue(6)) == .intValue(6))\nassert(compare_one(a: .intValue(1),\
    \ b: .stringValue(\"2,3\")) == .stringValue(\"2,3\"))\nassert(compare_one(a: .stringValue(\"\
    5,1\"), b: .stringValue(\"6\")) == .stringValue(\"6\"))\nassert(compare_one(a:\
    \ .stringValue(\"1\"), b: .stringValue(\"2\")) == .stringValue(\"2\"))\nassert(compare_one(a:\
    \ .stringValue(\"1\"), b: .intValue(1)) == nil)"
  status: SyntaxError
  stderr: "/tmp/tmpy_as8qqf.swift:28:27: error: cannot convert value of type 'Double'\
    \ to expected argument type 'Int'\n            return numA > numB ? a : b\n  \
    \                        ^\n                          Int()\n/tmp/tmpy_as8qqf.swift:30:32:\
    \ error: value of type 'String' has no member 'asDouble'\n            return numA\
    \ > numB.asDouble() ? a : b\n                          ~~~~ ^~~~~~~~\n/tmp/tmpy_as8qqf.swift:35:20:\
    \ error: cannot convert value of type 'Double' to expected argument type 'Int'\n\
    \            return numA > numB ? a : b\n                   ^\n              \
    \     Int()\n/tmp/tmpy_as8qqf.swift:39:32: error: value of type 'String' has no\
    \ member 'asDouble'\n            return numA > numB.asDouble() ? a : b\n     \
    \                     ~~~~ ^~~~~~~~\n/tmp/tmpy_as8qqf.swift:44:25: error: value\
    \ of type 'String' has no member 'asDouble'\n            return numA.asDouble()\
    \ > numB ? a : b\n                   ~~~~ ^~~~~~~~\n/tmp/tmpy_as8qqf.swift:46:25:\
    \ error: value of type 'String' has no member 'asDouble'\n            return numA.asDouble()\
    \ > numB ? a : b\n                   ~~~~ ^~~~~~~~\n/tmp/tmpy_as8qqf.swift:48:25:\
    \ error: value of type 'String' has no member 'asDouble'\n            return numA.asDouble()\
    \ > numB.asDouble() ? a : b\n                   ~~~~ ^~~~~~~~\n/tmp/tmpy_as8qqf.swift:48:43:\
    \ error: value of type 'String' has no member 'asDouble'\n            return numA.asDouble()\
    \ > numB.asDouble() ? a : b\n                                     ~~~~ ^~~~~~~~\n"
  stdout: ''
  timestamp: 1660013181
- exit_code: 1
  program: "\nenum Value: Equatable, Hashable {\n    case intValue(Int)\n    case\
    \ doubleValue(Double)\n    case stringValue(String)\n}\n\n            \n/// Create\
    \ a function that takes integers, floats, or strings representing\n/// real numbers,\
    \ and returns the larger variable in its given variable type.\n/// Return nil\
    \ if the values are equal.\n/// Note: If a real number is represented as a string,\
    \ the floating point might be . or ,\n/// >>> compare_one(a: .intValue(1), b:\
    \ .doubleValue(2.5))\n/// .doubleValue(2.5)\n/// >>> compare_one(a: .intValue(1),\
    \ b: .stringValue(\"2,3\"))\n/// .stringValue(\"2,3\")\n/// >>> compare_one(a:\
    \ .stringValue(\"5,1\"), b: .stringValue(\"6\"))\n/// .stringValue(\"6\")\n///\
    \ >>> compare_one(a: .stringValue(\"1\"), b: .intValue(1))\n/// nil\nfunc compare_one(a:\
    \ Value, b: Value) -> Value? {\n    let result = (a, b)\n    switch result {\n\
    \    case let (.intValue(a), .intValue(b)) where a > b:\n        return .intValue(a)\n\
    \    case let (.intValue(a), .intValue(b)) where a < b:\n        return .intValue(b)\n\
    \    case let (.intValue(a), .doubleValue(b)) where a > b:\n        return .intValue(a)\n\
    \    case let (.intValue(a), .doubleValue(b)) where a < b:\n        return .doubleValue(b)\n\
    \    case let (.intValue(a), .stringValue(b)) where a > Double(b.trimmingCharacters(in:\
    \ CharacterSet(charactersIn: \"0123456789.\").inverted))!:\n        return .intValue(a)\n\
    \    case let (.intValue(a), .stringValue(b)) where a < Double(b.trimmingCharacters(in:\
    \ CharacterSet(charactersIn: \"0123456789.\").inverted))!:\n        return .stringValue(b)\n\
    \    case let (.doubleValue(a), .intValue(b)) where a > b:\n        return .doubleValue(a)\n\
    \    case let (.doubleValue(a), .intValue(b)) where a < b:\n        return .intValue(b)\n\
    \    case let (.doubleValue(a), .doubleValue(b)) where a > b:\n        return\
    \ .doubleValue(a)\n    case let (.doubleValue(a), .doubleValue(b)) where a < b:\n\
    \        return .doubleValue(b)\n    case let (.doubleValue(a), .stringValue(b))\
    \ where a > Double(b.trimmingCharacters(in: CharacterSet(charactersIn: \"0123456789.\"\
    ).inverted))!:\n        return .doubleValue(a)\n    case let (.doubleValue(a),\
    \ .stringValue(b)) where a < Double(b.trimmingCharacters(in: CharacterSet(charactersIn:\
    \ \"0123456789.\").inverted))!:\n        return .stringValue(b)\n    case let\
    \ (.stringValue(a), .intValue(b)) where Double(a.trimmingCharacters(in: CharacterSet\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(compare_one(a: .intValue(1), b: .intValue(2))\
    \ == .intValue(2))\nassert(compare_one(a: .intValue(1), b: .doubleValue(2.5))\
    \ == .doubleValue(2.5))\nassert(compare_one(a: .intValue(2), b: .intValue(3))\
    \ == .intValue(3))\nassert(compare_one(a: .intValue(5), b: .intValue(6)) == .intValue(6))\n\
    assert(compare_one(a: .intValue(1), b: .stringValue(\"2,3\")) == .stringValue(\"\
    2,3\"))\nassert(compare_one(a: .stringValue(\"5,1\"), b: .stringValue(\"6\"))\
    \ == .stringValue(\"6\"))\nassert(compare_one(a: .stringValue(\"1\"), b: .stringValue(\"\
    2\")) == .stringValue(\"2\"))\nassert(compare_one(a: .stringValue(\"1\"), b: .intValue(1))\
    \ == nil)"
  status: SyntaxError
  stderr: "/tmp/tmphct32rek.swift:49:1: error: expected ')' in expression list\n}\n\
    ^\n/tmp/tmphct32rek.swift:48:79: note: to match this opening '('\n    case let\
    \ (.stringValue(a), .intValue(b)) where Double(a.trimmingCharacters(in: CharacterSet\n\
    \                                                                            \
    \  ^\n/tmp/tmphct32rek.swift:48:96: error: expected ':' after 'case'\n    case\
    \ let (.stringValue(a), .intValue(b)) where Double(a.trimmingCharacters(in: CharacterSet\n\
    \                                                                            \
    \                   ^\n/tmp/tmphct32rek.swift:71:66: error: expected '}' at end\
    \ of brace statement\nassert(compare_one(a: .stringValue(\"1\"), b: .intValue(1))\
    \ == nil)\n                                                                 ^\n\
    /tmp/tmphct32rek.swift:21:48: note: to match this opening '{'\nfunc compare_one(a:\
    \ Value, b: Value) -> Value? {\n                                             \
    \  ^\n/tmp/tmphct32rek.swift:28:54: error: binary operator '>' cannot be applied\
    \ to operands of type 'Int' and 'Double'\n    case let (.intValue(a), .doubleValue(b))\
    \ where a > b:\n                                                   ~ ^ ~\n/tmp/tmphct32rek.swift:28:54:\
    \ note: overloads for '>' exist with these partially matching parameter lists:\
    \ (Int, Int)\n    case let (.intValue(a), .doubleValue(b)) where a > b:\n    \
    \                                                 ^\n/tmp/tmphct32rek.swift:30:54:\
    \ error: binary operator '<' cannot be applied to operands of type 'Int' and 'Double'\n\
    \    case let (.intValue(a), .doubleValue(b)) where a < b:\n                 \
    \                                  ~ ^ ~\n/tmp/tmphct32rek.swift:30:54: note:\
    \ overloads for '<' exist with these partially matching parameter lists: (Int,\
    \ Int)\n    case let (.intValue(a), .doubleValue(b)) where a < b:\n          \
    \                                           ^\n/tmp/tmphct32rek.swift:32:88: error:\
    \ cannot find 'CharacterSet' in scope\n    case let (.intValue(a), .stringValue(b))\
    \ where a > Double(b.trimmingCharacters(in: CharacterSet(charactersIn: \"01234"
  stdout: ''
  timestamp: 1660013181
- exit_code: -4
  program: "\nenum Value: Equatable, Hashable {\n    case intValue(Int)\n    case\
    \ doubleValue(Double)\n    case stringValue(String)\n}\n\n            \n/// Create\
    \ a function that takes integers, floats, or strings representing\n/// real numbers,\
    \ and returns the larger variable in its given variable type.\n/// Return nil\
    \ if the values are equal.\n/// Note: If a real number is represented as a string,\
    \ the floating point might be . or ,\n/// >>> compare_one(a: .intValue(1), b:\
    \ .doubleValue(2.5))\n/// .doubleValue(2.5)\n/// >>> compare_one(a: .intValue(1),\
    \ b: .stringValue(\"2,3\"))\n/// .stringValue(\"2,3\")\n/// >>> compare_one(a:\
    \ .stringValue(\"5,1\"), b: .stringValue(\"6\"))\n/// .stringValue(\"6\")\n///\
    \ >>> compare_one(a: .stringValue(\"1\"), b: .intValue(1))\n/// nil\nfunc compare_one(a:\
    \ Value, b: Value) -> Value? {\n    // your code here\n    return nil\n}\n\n\n\
    func ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(compare_one(a: .intValue(1), b: .intValue(2))\
    \ == .intValue(2))\nassert(compare_one(a: .intValue(1), b: .doubleValue(2.5))\
    \ == .doubleValue(2.5))\nassert(compare_one(a: .intValue(2), b: .intValue(3))\
    \ == .intValue(3))\nassert(compare_one(a: .intValue(5), b: .intValue(6)) == .intValue(6))\n\
    assert(compare_one(a: .intValue(1), b: .stringValue(\"2,3\")) == .stringValue(\"\
    2,3\"))\nassert(compare_one(a: .stringValue(\"5,1\"), b: .stringValue(\"6\"))\
    \ == .stringValue(\"6\"))\nassert(compare_one(a: .stringValue(\"1\"), b: .stringValue(\"\
    2\")) == .stringValue(\"2\"))\nassert(compare_one(a: .stringValue(\"1\"), b: .intValue(1))\
    \ == nil)"
  status: Exception
  stderr: 'tmpgzc2mhk7/tmpgzc2mhk7.swift:39: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002af65e722c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002af65e419b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002af65e419988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002af65e4187b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpgzc2mhk7                        0x00005560a78a2a56 <unavailable> + 6742

    5    libc.so.6                          0x00002af65e90e460 __libc_start_main +
    245

    6    tmpgzc2mhk7                        0x00005560a78a2499 <unavailable> + 5273

    '
  stdout: ''
  timestamp: 1660013181
- exit_code: 1
  program: "\nenum Value: Equatable, Hashable {\n    case intValue(Int)\n    case\
    \ doubleValue(Double)\n    case stringValue(String)\n}\n\n            \n/// Create\
    \ a function that takes integers, floats, or strings representing\n/// real numbers,\
    \ and returns the larger variable in its given variable type.\n/// Return nil\
    \ if the values are equal.\n/// Note: If a real number is represented as a string,\
    \ the floating point might be . or ,\n/// >>> compare_one(a: .intValue(1), b:\
    \ .doubleValue(2.5))\n/// .doubleValue(2.5)\n/// >>> compare_one(a: .intValue(1),\
    \ b: .stringValue(\"2,3\"))\n/// .stringValue(\"2,3\")\n/// >>> compare_one(a:\
    \ .stringValue(\"5,1\"), b: .stringValue(\"6\"))\n/// .stringValue(\"6\")\n///\
    \ >>> compare_one(a: .stringValue(\"1\"), b: .intValue(1))\n/// nil\nfunc compare_one(a:\
    \ Value, b: Value) -> Value? {\n    if a == b {\n        return nil\n    }\n \
    \   let aTuple = getTuple(value: a)\n    let bTuple = getTuple(value: b)\n   \
    \ if aTuple.1 < bTuple.1 {\n        return b\n    }\n    return a\n}\n\n\nfunc\
    \ ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count !=\
    \ right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(compare_one(a: .intValue(1), b: .intValue(2))\
    \ == .intValue(2))\nassert(compare_one(a: .intValue(1), b: .doubleValue(2.5))\
    \ == .doubleValue(2.5))\nassert(compare_one(a: .intValue(2), b: .intValue(3))\
    \ == .intValue(3))\nassert(compare_one(a: .intValue(5), b: .intValue(6)) == .intValue(6))\n\
    assert(compare_one(a: .intValue(1), b: .stringValue(\"2,3\")) == .stringValue(\"\
    2,3\"))\nassert(compare_one(a: .stringValue(\"5,1\"), b: .stringValue(\"6\"))\
    \ == .stringValue(\"6\"))\nassert(compare_one(a: .stringValue(\"1\"), b: .stringValue(\"\
    2\")) == .stringValue(\"2\"))\nassert(compare_one(a: .stringValue(\"1\"), b: .intValue(1))\
    \ == nil)"
  status: SyntaxError
  stderr: "/tmp/tmpds9phaa2.swift:25:18: error: cannot find 'getTuple' in scope\n\
    \    let aTuple = getTuple(value: a)\n                 ^~~~~~~~\n/tmp/tmpds9phaa2.swift:26:18:\
    \ error: cannot find 'getTuple' in scope\n    let bTuple = getTuple(value: b)\n\
    \                 ^~~~~~~~\n"
  stdout: ''
  timestamp: 1660013181
- exit_code: 1
  program: "\nenum Value: Equatable, Hashable {\n    case intValue(Int)\n    case\
    \ doubleValue(Double)\n    case stringValue(String)\n}\n\n            \n/// Create\
    \ a function that takes integers, floats, or strings representing\n/// real numbers,\
    \ and returns the larger variable in its given variable type.\n/// Return nil\
    \ if the values are equal.\n/// Note: If a real number is represented as a string,\
    \ the floating point might be . or ,\n/// >>> compare_one(a: .intValue(1), b:\
    \ .doubleValue(2.5))\n/// .doubleValue(2.5)\n/// >>> compare_one(a: .intValue(1),\
    \ b: .stringValue(\"2,3\"))\n/// .stringValue(\"2,3\")\n/// >>> compare_one(a:\
    \ .stringValue(\"5,1\"), b: .stringValue(\"6\"))\n/// .stringValue(\"6\")\n///\
    \ >>> compare_one(a: .stringValue(\"1\"), b: .intValue(1))\n/// nil\nfunc compare_one(a:\
    \ Value, b: Value) -> Value? {\n    if case let .intValue(a) = a, case let .intValue(b)\
    \ = b {\n        return a < b ? b : a\n    } else if case let .doubleValue(a)\
    \ = a, case let .doubleValue(b) = b {\n        return a < b ? b : a\n    } else\
    \ if case let .stringValue(a) = a, case let .stringValue(b) = b {\n        return\
    \ a < b ? b : a\n    } else if case let .intValue(a) = a, case let .doubleValue(b)\
    \ = b {\n        return a < b ? b : a\n    } else if case let .intValue(a) = a,\
    \ case let .stringValue(b) = b {\n        return a < b ? b : a\n    } else if\
    \ case let .doubleValue(a) = a, case let .intValue(b) = b {\n        return a\
    \ < b ? b : a\n    } else if case let .doubleValue(a) = a, case let .stringValue(b)\
    \ = b {\n        return a < b ? b : a\n    } else if case let .stringValue(a)\
    \ = a, case let .intValue(b) = b {\n        return a < b ? b : a\n    } else if\
    \ case let .stringValue(a) = a, case let .doubleValue(b) = b {\n        return\
    \ a < b ? b : a\n    } else {\n        return nil\n    }\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(compare_one(a: .intValue(1), b: .intValue(2)) == .intValue(2))\n\
    assert(compare_one(a: .intValue(1), b: .doubleValue(2.5)) == .doubleValue(2.5))\n\
    assert(compare_one(a: .intValue(2), b: .intValue(3)) == .intValue(3))\nassert(compare_one(a:\
    \ .intValue(5), b: .intValue(6)) == .intValue(6))\nassert(compare_one(a: .intValue(1),\
    \ b: .stringValue(\"2,3\")) == .stringValue(\"2,3\"))\nassert(compare_one(a: .stringValue(\"\
    5,1\"), b: .stringValue(\"6\")) == .stringValue(\"6\"))\nassert(compare_one(a:\
    \ .stringValue(\"1\"), b: .stringValue(\"2\")) == .stringValue(\"2\"))\nassert(compare_one(a:\
    \ .stringValue(\"1\"), b: .intValue(1)) == nil)"
  status: SyntaxError
  stderr: "/tmp/tmpfv4c1l0g.swift:23:22: error: cannot convert return expression of\
    \ type 'Int' to return type 'Value?'\n        return a < b ? b : a\n         \
    \      ~~~~~~^~~~~~~\n/tmp/tmpfv4c1l0g.swift:25:22: error: cannot convert return\
    \ expression of type 'Double' to return type 'Value?'\n        return a < b ?\
    \ b : a\n               ~~~~~~^~~~~~~\n/tmp/tmpfv4c1l0g.swift:27:22: error: cannot\
    \ convert return expression of type 'String' to return type 'Value?'\n       \
    \ return a < b ? b : a\n               ~~~~~~^~~~~~~\n/tmp/tmpfv4c1l0g.swift:29:20:\
    \ error: cannot convert value of type 'Double' to expected argument type 'Int'\n\
    \        return a < b ? b : a\n                   ^\n                   Int( )\n\
    /tmp/tmpfv4c1l0g.swift:29:22: error: cannot convert return expression of type\
    \ 'Double' to return type 'Value?'\n        return a < b ? b : a\n           \
    \    ~~~~~~^~~~~~~\n/tmp/tmpfv4c1l0g.swift:31:18: error: binary operator '<' cannot\
    \ be applied to operands of type 'Int' and 'String'\n        return a < b ? b\
    \ : a\n               ~ ^ ~\n/tmp/tmpfv4c1l0g.swift:31:18: note: overloads for\
    \ '<' exist with these partially matching parameter lists: (Int, Int), (String,\
    \ String)\n        return a < b ? b : a\n                 ^\n/tmp/tmpfv4c1l0g.swift:31:22:\
    \ error: cannot convert return expression of type 'String' to return type 'Value?'\n\
    \        return a < b ? b : a\n               ~~~~~~^~~~~~~\n/tmp/tmpfv4c1l0g.swift:33:16:\
    \ error: cannot convert value of type 'Double' to expected argument type 'Int'\n\
    \        return a < b ? b : a\n               ^\n               Int( )\n/tmp/tmpfv4c1l0g.swift:33:22:\
    \ error: cannot convert return expression of type 'Int' to return type 'Value?'\n\
    \        return a < b ? b : a\n               ~~~~~~^~~~~~~\n/tmp/tmpfv4c1l0g.swift:35:16:\
    \ error: cannot convert value of type 'Double' to expected argument type 'String'\n\
    \        return a < b ? b : a\n               ^\n/tmp/tmpfv4c1l0g.swift:35:22:\
    \ error: cannot convert return expression of type 'String' to return type 'Value?'\n\
    \        return a < b ? b : a\n               ~~~~~~^~~~~~~\n/tmp/tmpf"
  stdout: ''
  timestamp: 1660013181
- exit_code: 1
  program: "\nenum Value: Equatable, Hashable {\n    case intValue(Int)\n    case\
    \ doubleValue(Double)\n    case stringValue(String)\n}\n\n            \n/// Create\
    \ a function that takes integers, floats, or strings representing\n/// real numbers,\
    \ and returns the larger variable in its given variable type.\n/// Return nil\
    \ if the values are equal.\n/// Note: If a real number is represented as a string,\
    \ the floating point might be . or ,\n/// >>> compare_one(a: .intValue(1), b:\
    \ .doubleValue(2.5))\n/// .doubleValue(2.5)\n/// >>> compare_one(a: .intValue(1),\
    \ b: .stringValue(\"2,3\"))\n/// .stringValue(\"2,3\")\n/// >>> compare_one(a:\
    \ .stringValue(\"5,1\"), b: .stringValue(\"6\"))\n/// .stringValue(\"6\")\n///\
    \ >>> compare_one(a: .stringValue(\"1\"), b: .intValue(1))\n/// nil\nfunc compare_one(a:\
    \ Value, b: Value) -> Value? {\n    switch (a, b) {\n    case (.intValue(let a),\
    \ .intValue(let b)):\n        return a > b ? a : b\n    case (.doubleValue(let\
    \ a), .doubleValue(let b)):\n        return a > b ? a : b\n    case (.stringValue(let\
    \ a), .stringValue(let b)):\n        return a > b ? a : b\n    case (.stringValue(let\
    \ a), .intValue(let b)):\n        return a > String(b) ? a : b\n    case (.intValue(let\
    \ a), .stringValue(let b)):\n        return a > Double(b) ? a : b\n    case (.doubleValue(let\
    \ a), .intValue(let b)):\n        return a > Double(b) ? a : b\n    case (.intValue(let\
    \ a), .doubleValue(let b)):\n        return a > b ? a : b\n    case (.doubleValue(let\
    \ a), .stringValue(let b)):\n        return a > Double(b) ? a : b\n    case (.stringValue(let\
    \ a), .doubleValue(let b)):\n        return a > String(b) ? a : b\n    default:\n\
    \        return nil\n    }\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(compare_one(a:\
    \ .intValue(1), b: .intValue(2)) == .intValue(2))\nassert(compare_one(a: .intValue(1),\
    \ b: .doubleValue(2.5)) == .doubleValue(2.5))\nassert(compare_one(a: .intValue(2),\
    \ b: .intValue(3)) == .intValue(3))\nassert(compare_one(a: .intValue(5), b: .intValue(6))\
    \ == .intValue(6))\nassert(compare_one(a: .intValue(1), b: .stringValue(\"2,3\"\
    )) == .stringValue(\"2,3\"))\nassert(compare_one(a: .stringValue(\"5,1\"), b:\
    \ .stringValue(\"6\")) == .stringValue(\"6\"))\nassert(compare_one(a: .stringValue(\"\
    1\"), b: .stringValue(\"2\")) == .stringValue(\"2\"))\nassert(compare_one(a: .stringValue(\"\
    1\"), b: .intValue(1)) == nil)"
  status: SyntaxError
  stderr: "/tmp/tmpiombltkw.swift:24:22: error: cannot convert return expression of\
    \ type 'Int' to return type 'Value?'\n        return a > b ? a : b\n         \
    \      ~~~~~~^~~~~~~\n/tmp/tmpiombltkw.swift:26:22: error: cannot convert return\
    \ expression of type 'Double' to return type 'Value?'\n        return a > b ?\
    \ a : b\n               ~~~~~~^~~~~~~\n/tmp/tmpiombltkw.swift:28:22: error: cannot\
    \ convert return expression of type 'String' to return type 'Value?'\n       \
    \ return a > b ? a : b\n               ~~~~~~^~~~~~~\n/tmp/tmpiombltkw.swift:30:30:\
    \ error: cannot convert return expression of type 'String' to return type 'Value?'\n\
    \        return a > String(b) ? a : b\n               ~~~~~~~~~~~~~~^~~~~~~\n\
    /tmp/tmpiombltkw.swift:32:20: error: cannot convert value of type 'Double?' to\
    \ expected argument type 'Int'\n        return a > Double(b) ? a : b\n       \
    \            ^\n/tmp/tmpiombltkw.swift:32:30: error: cannot convert return expression\
    \ of type 'Int' to return type 'Value?'\n        return a > Double(b) ? a : b\n\
    \               ~~~~~~~~~~~~~~^~~~~~~\n/tmp/tmpiombltkw.swift:34:30: error: cannot\
    \ convert return expression of type 'Double' to return type 'Value?'\n       \
    \ return a > Double(b) ? a : b\n               ~~~~~~~~~~~~~~^~~~~~~\n/tmp/tmpiombltkw.swift:36:20:\
    \ error: cannot convert value of type 'Double' to expected argument type 'Int'\n\
    \        return a > b ? a : b\n                   ^\n                   Int( )\n\
    /tmp/tmpiombltkw.swift:36:22: error: cannot convert return expression of type\
    \ 'Int' to return type 'Value?'\n        return a > b ? a : b\n              \
    \ ~~~~~~^~~~~~~\n/tmp/tmpiombltkw.swift:38:20: error: value of optional type 'Double?'\
    \ must be unwrapped to a value of type 'Double'\n        return a > Double(b)\
    \ ? a : b\n                   ^\n/tmp/tmpiombltkw.swift:38:20: note: coalesce\
    \ using '??' to provide a default when the optional value contains 'nil'\n   \
    \     return a > Double(b) ? a : b\n                   ^\n                   \
    \          ?? <#default value#>\n/tmp/tmpiombltkw.swift:38:20: note: force-unwrap\
    \ using '!' to abort execution i"
  stdout: ''
  timestamp: 1660013181
- exit_code: 1
  program: "\nenum Value: Equatable, Hashable {\n    case intValue(Int)\n    case\
    \ doubleValue(Double)\n    case stringValue(String)\n}\n\n            \n/// Create\
    \ a function that takes integers, floats, or strings representing\n/// real numbers,\
    \ and returns the larger variable in its given variable type.\n/// Return nil\
    \ if the values are equal.\n/// Note: If a real number is represented as a string,\
    \ the floating point might be . or ,\n/// >>> compare_one(a: .intValue(1), b:\
    \ .doubleValue(2.5))\n/// .doubleValue(2.5)\n/// >>> compare_one(a: .intValue(1),\
    \ b: .stringValue(\"2,3\"))\n/// .stringValue(\"2,3\")\n/// >>> compare_one(a:\
    \ .stringValue(\"5,1\"), b: .stringValue(\"6\"))\n/// .stringValue(\"6\")\n///\
    \ >>> compare_one(a: .stringValue(\"1\"), b: .intValue(1))\n/// nil\nfunc compare_one(a:\
    \ Value, b: Value) -> Value? {\n    switch (a, b) {\n    case (.intValue(let a),\
    \ .intValue(let b)):\n        return (a < b) ? b : nil\n    case (.intValue(let\
    \ a), .doubleValue(let b)):\n        return (Double(a) < b) ? b : nil\n    case\
    \ (.intValue(let a), .stringValue(let b)):\n        let bValue = Double(b.replacingOccurrences(of:\
    \ \",\", with: \".\"))\n        return (Double(a) < bValue!) ? b : nil\n    case\
    \ (.doubleValue(let a), .intValue(let b)):\n        return (a < Double(b)) ? a\
    \ : nil\n    case (.doubleValue(let a), .doubleValue(let b)):\n        return\
    \ (a < b) ? b : nil\n    case (.doubleValue(let a), .stringValue(let b)):\n  \
    \      let bValue = Double(b.replacingOccurrences(of: \",\", with: \".\"))\n \
    \       return (a < bValue!) ? b : nil\n    case (.stringValue(let a), .intValue(let\
    \ b)):\n        let aValue = Double(a.replacingOccurrences(of: \",\", with: \"\
    .\"))\n        return (aValue! < Double(b)) ? a : nil\n    case (.stringValue(let\
    \ a), .doubleValue(let b)):\n        let aValue = Double(a.replacingOccurrences(of:\
    \ \",\", with: \".\"))\n        return (aValue! < b) ? a : nil\n    case (.stringValue(let\
    \ a), .stringValue(let b)):\n        let aValue = Double(a.replacingOccurrences(of:\
    \ \",\", with: \".\"))\n        let bValue = Double(b.replacingOccurrences(of:\
    \ \",\", with: \".\"))\n        return (aValue! < bValue!) ? b : nil\n    }\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(compare_one(a: .intValue(1), b: .intValue(2))\
    \ == .intValue(2))\nassert(compare_one(a: .intValue(1), b: .doubleValue(2.5))\
    \ == .doubleValue(2.5))\nassert(compare_one(a: .intValue(2), b: .intValue(3))\
    \ == .intValue(3))\nassert(compare_one(a: .intValue(5), b: .intValue(6)) == .intValue(6))\n\
    assert(compare_one(a: .intValue(1), b: .stringValue(\"2,3\")) == .stringValue(\"\
    2,3\"))\nassert(compare_one(a: .stringValue(\"5,1\"), b: .stringValue(\"6\"))\
    \ == .stringValue(\"6\"))\nassert(compare_one(a: .stringValue(\"1\"), b: .stringValue(\"\
    2\")) == .stringValue(\"2\"))\nassert(compare_one(a: .stringValue(\"1\"), b: .intValue(1))\
    \ == nil)"
  status: SyntaxError
  stderr: "/tmp/tmpzplyfgww.swift:24:24: error: cannot convert return expression of\
    \ type 'Int' to return type 'Value?'\n        return (a < b) ? b : nil\n     \
    \          ~~~~~~~~^~~~~~~~~\n/tmp/tmpzplyfgww.swift:26:32: error: cannot convert\
    \ return expression of type 'Double' to return type 'Value?'\n        return (Double(a)\
    \ < b) ? b : nil\n               ~~~~~~~~~~~~~~~~^~~~~~~~~\n/tmp/tmpzplyfgww.swift:28:31:\
    \ error: value of type 'String' has no member 'replacingOccurrences'\n       \
    \ let bValue = Double(b.replacingOccurrences(of: \",\", with: \".\"))\n      \
    \                      ~ ^~~~~~~~~~~~~~~~~~~~\n/tmp/tmpzplyfgww.swift:29:38: error:\
    \ cannot convert return expression of type 'String' to return type 'Value?'\n\
    \        return (Double(a) < bValue!) ? b : nil\n               ~~~~~~~~~~~~~~~~~~~~~~^~~~~~~~~\n\
    /tmp/tmpzplyfgww.swift:31:32: error: cannot convert return expression of type\
    \ 'Double' to return type 'Value?'\n        return (a < Double(b)) ? a : nil\n\
    \               ~~~~~~~~~~~~~~~~^~~~~~~~~\n/tmp/tmpzplyfgww.swift:33:24: error:\
    \ cannot convert return expression of type 'Double' to return type 'Value?'\n\
    \        return (a < b) ? b : nil\n               ~~~~~~~~^~~~~~~~~\n/tmp/tmpzplyfgww.swift:35:31:\
    \ error: value of type 'String' has no member 'replacingOccurrences'\n       \
    \ let bValue = Double(b.replacingOccurrences(of: \",\", with: \".\"))\n      \
    \                      ~ ^~~~~~~~~~~~~~~~~~~~\n/tmp/tmpzplyfgww.swift:36:30: error:\
    \ cannot convert return expression of type 'String' to return type 'Value?'\n\
    \        return (a < bValue!) ? b : nil\n               ~~~~~~~~~~~~~~^~~~~~~~~\n\
    /tmp/tmpzplyfgww.swift:38:31: error: value of type 'String' has no member 'replacingOccurrences'\n\
    \        let aValue = Double(a.replacingOccurrences(of: \",\", with: \".\"))\n\
    \                            ~ ^~~~~~~~~~~~~~~~~~~~\n/tmp/tmpzplyfgww.swift:39:38:\
    \ error: cannot convert return expression of type 'String' to return type 'Value?'\n\
    \        return (aValue! < Double(b)) ? a : nil\n               ~~~~~~~~~~~~~~~~~~~~~~^~~~~~~~~\n\
    /tmp/tmpzplyfgww.swift:41:31: error: value of type '"
  stdout: ''
  timestamp: 1660013181
- exit_code: 1
  program: "\nenum Value: Equatable, Hashable {\n    case intValue(Int)\n    case\
    \ doubleValue(Double)\n    case stringValue(String)\n}\n\n            \n/// Create\
    \ a function that takes integers, floats, or strings representing\n/// real numbers,\
    \ and returns the larger variable in its given variable type.\n/// Return nil\
    \ if the values are equal.\n/// Note: If a real number is represented as a string,\
    \ the floating point might be . or ,\n/// >>> compare_one(a: .intValue(1), b:\
    \ .doubleValue(2.5))\n/// .doubleValue(2.5)\n/// >>> compare_one(a: .intValue(1),\
    \ b: .stringValue(\"2,3\"))\n/// .stringValue(\"2,3\")\n/// >>> compare_one(a:\
    \ .stringValue(\"5,1\"), b: .stringValue(\"6\"))\n/// .stringValue(\"6\")\n///\
    \ >>> compare_one(a: .stringValue(\"1\"), b: .intValue(1))\n/// nil\nfunc compare_one(a:\
    \ Value, b: Value) -> Value? {\n    switch (a, b) {\n    case (.intValue(let a),\
    \ .intValue(let b)):\n        return a > b ? a : b\n    case (.doubleValue(let\
    \ a), .doubleValue(let b)):\n        return a > b ? a : b\n    case (.stringValue(let\
    \ a), .stringValue(let b)):\n        return Double(a) > Double(b) ? a : b\n  \
    \  case (.intValue(let a), .doubleValue(let b)):\n        return a > b ? .intValue(a)\
    \ : .doubleValue(b)\n    case (.intValue(let a), .stringValue(let b)):\n     \
    \   return Double(a) > Double(b) ? .intValue(a) : .stringValue(b)\n    case (.doubleValue(let\
    \ a), .intValue(let b)):\n        return a > b ? .doubleValue(a) : .intValue(b)\n\
    \    case (.doubleValue(let a), .stringValue(let b)):\n        return a > Double(b)\
    \ ? .doubleValue(a) : .stringValue(b)\n    case (.stringValue(let a), .intValue(let\
    \ b)):\n        return Double(a) > b ? .stringValue(a) : .intValue(b)\n    case\
    \ (.stringValue(let a), .doubleValue(let b)):\n        return Double(a) > b ?\
    \ .stringValue(a) : .doubleValue(b)\n    default:\n        return nil\n    }\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(compare_one(a: .intValue(1), b: .intValue(2))\
    \ == .intValue(2))\nassert(compare_one(a: .intValue(1), b: .doubleValue(2.5))\
    \ == .doubleValue(2.5))\nassert(compare_one(a: .intValue(2), b: .intValue(3))\
    \ == .intValue(3))\nassert(compare_one(a: .intValue(5), b: .intValue(6)) == .intValue(6))\n\
    assert(compare_one(a: .intValue(1), b: .stringValue(\"2,3\")) == .stringValue(\"\
    2,3\"))\nassert(compare_one(a: .stringValue(\"5,1\"), b: .stringValue(\"6\"))\
    \ == .stringValue(\"6\"))\nassert(compare_one(a: .stringValue(\"1\"), b: .stringValue(\"\
    2\")) == .stringValue(\"2\"))\nassert(compare_one(a: .stringValue(\"1\"), b: .intValue(1))\
    \ == nil)"
  status: SyntaxError
  stderr: "/tmp/tmpx61tou1x.swift:24:22: error: cannot convert return expression of\
    \ type 'Int' to return type 'Value?'\n        return a > b ? a : b\n         \
    \      ~~~~~~^~~~~~~\n/tmp/tmpx61tou1x.swift:26:22: error: cannot convert return\
    \ expression of type 'Double' to return type 'Value?'\n        return a > b ?\
    \ a : b\n               ~~~~~~^~~~~~~\n/tmp/tmpx61tou1x.swift:28:28: error: value\
    \ of optional type 'Double?' must be unwrapped to a value of type 'Double'\n \
    \       return Double(a) > Double(b) ? a : b\n                           ^\n/tmp/tmpx61tou1x.swift:28:28:\
    \ note: coalesce using '??' to provide a default when the optional value contains\
    \ 'nil'\n        return Double(a) > Double(b) ? a : b\n                      \
    \     ^\n                                     ?? <#default value#>\n/tmp/tmpx61tou1x.swift:28:28:\
    \ note: force-unwrap using '!' to abort execution if the optional value contains\
    \ 'nil'\n        return Double(a) > Double(b) ? a : b\n                      \
    \     ^\n                                    !\n/tmp/tmpx61tou1x.swift:28:16:\
    \ error: value of optional type 'Double?' must be unwrapped to a value of type\
    \ 'Double'\n        return Double(a) > Double(b) ? a : b\n               ^\n/tmp/tmpx61tou1x.swift:28:16:\
    \ note: coalesce using '??' to provide a default when the optional value contains\
    \ 'nil'\n        return Double(a) > Double(b) ? a : b\n               ^\n    \
    \                     ?? <#default value#>\n/tmp/tmpx61tou1x.swift:28:16: note:\
    \ force-unwrap using '!' to abort execution if the optional value contains 'nil'\n\
    \        return Double(a) > Double(b) ? a : b\n               ^\n            \
    \            !\n/tmp/tmpx61tou1x.swift:28:38: error: cannot convert return expression\
    \ of type 'String' to return type 'Value?'\n        return Double(a) > Double(b)\
    \ ? a : b\n               ~~~~~~~~~~~~~~~~~~~~~~^~~~~~~\n/tmp/tmpx61tou1x.swift:30:20:\
    \ error: cannot convert value of type 'Double' to expected argument type 'Int'\n\
    \        return a > b ? .intValue(a) : .doubleValue(b)\n                   ^\n\
    \                   Int( )\n/tmp/tmpx61tou1x.swift:32:28: erro"
  stdout: ''
  timestamp: 1660013181
- exit_code: 1
  program: "\nenum Value: Equatable, Hashable {\n    case intValue(Int)\n    case\
    \ doubleValue(Double)\n    case stringValue(String)\n}\n\n            \n/// Create\
    \ a function that takes integers, floats, or strings representing\n/// real numbers,\
    \ and returns the larger variable in its given variable type.\n/// Return nil\
    \ if the values are equal.\n/// Note: If a real number is represented as a string,\
    \ the floating point might be . or ,\n/// >>> compare_one(a: .intValue(1), b:\
    \ .doubleValue(2.5))\n/// .doubleValue(2.5)\n/// >>> compare_one(a: .intValue(1),\
    \ b: .stringValue(\"2,3\"))\n/// .stringValue(\"2,3\")\n/// >>> compare_one(a:\
    \ .stringValue(\"5,1\"), b: .stringValue(\"6\"))\n/// .stringValue(\"6\")\n///\
    \ >>> compare_one(a: .stringValue(\"1\"), b: .intValue(1))\n/// nil\nfunc compare_one(a:\
    \ Value, b: Value) -> Value? {\n    switch (a, b) {\n    case (.intValue(let a),\
    \ .intValue(let b)):\n        return a > b ? a : b\n    case (.doubleValue(let\
    \ a), .doubleValue(let b)):\n        return a > b ? a : b\n    case (.stringValue(let\
    \ a), .stringValue(let b)):\n        return a > b ? a : b\n    case (.stringValue(let\
    \ a), .intValue(let b)):\n        return a > String(b) ? a : nil\n    case (.intValue(let\
    \ a), .stringValue(let b)):\n        return String(a) > b ? b : nil\n    case\
    \ (.stringValue(let a), .doubleValue(let b)):\n        return a > String(b) ?\
    \ a : nil\n    case (.doubleValue(let a), .stringValue(let b)):\n        return\
    \ String(a) > b ? b : nil\n    case (.doubleValue(let a), .intValue(let b)):\n\
    \        return a > Double(b) ? a : b\n    case (.intValue(let a), .doubleValue(let\
    \ b)):\n        return Double(a) > b ? a : b\n    }\n}\n\n\nfunc ==(left: [(Int,\
    \ Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n\
    \        return false\n    }\n    for (l, r) in zip(left, right) {\n        if\
    \ l != r {\n            return false\n        }\n    }\n    return true\n}\n \
    \           \nassert(compare_one(a: .intValue(1), b: .intValue(2)) == .intValue(2))\n\
    assert(compare_one(a: .intValue(1), b: .doubleValue(2.5)) == .doubleValue(2.5))\n\
    assert(compare_one(a: .intValue(2), b: .intValue(3)) == .intValue(3))\nassert(compare_one(a:\
    \ .intValue(5), b: .intValue(6)) == .intValue(6))\nassert(compare_one(a: .intValue(1),\
    \ b: .stringValue(\"2,3\")) == .stringValue(\"2,3\"))\nassert(compare_one(a: .stringValue(\"\
    5,1\"), b: .stringValue(\"6\")) == .stringValue(\"6\"))\nassert(compare_one(a:\
    \ .stringValue(\"1\"), b: .stringValue(\"2\")) == .stringValue(\"2\"))\nassert(compare_one(a:\
    \ .stringValue(\"1\"), b: .intValue(1)) == nil)"
  status: SyntaxError
  stderr: "/tmp/tmp28h9a0ci.swift:24:22: error: cannot convert return expression of\
    \ type 'Int' to return type 'Value?'\n        return a > b ? a : b\n         \
    \      ~~~~~~^~~~~~~\n/tmp/tmp28h9a0ci.swift:26:22: error: cannot convert return\
    \ expression of type 'Double' to return type 'Value?'\n        return a > b ?\
    \ a : b\n               ~~~~~~^~~~~~~\n/tmp/tmp28h9a0ci.swift:28:22: error: cannot\
    \ convert return expression of type 'String' to return type 'Value?'\n       \
    \ return a > b ? a : b\n               ~~~~~~^~~~~~~\n/tmp/tmp28h9a0ci.swift:30:30:\
    \ error: cannot convert return expression of type 'String' to return type 'Value?'\n\
    \        return a > String(b) ? a : nil\n               ~~~~~~~~~~~~~~^~~~~~~~~\n\
    /tmp/tmp28h9a0ci.swift:32:30: error: cannot convert return expression of type\
    \ 'String' to return type 'Value?'\n        return String(a) > b ? b : nil\n \
    \              ~~~~~~~~~~~~~~^~~~~~~~~\n/tmp/tmp28h9a0ci.swift:34:30: error: cannot\
    \ convert return expression of type 'String' to return type 'Value?'\n       \
    \ return a > String(b) ? a : nil\n               ~~~~~~~~~~~~~~^~~~~~~~~\n/tmp/tmp28h9a0ci.swift:36:30:\
    \ error: cannot convert return expression of type 'String' to return type 'Value?'\n\
    \        return String(a) > b ? b : nil\n               ~~~~~~~~~~~~~~^~~~~~~~~\n\
    /tmp/tmp28h9a0ci.swift:38:30: error: cannot convert return expression of type\
    \ 'Double' to return type 'Value?'\n        return a > Double(b) ? a : b\n   \
    \            ~~~~~~~~~~~~~~^~~~~~~\n/tmp/tmp28h9a0ci.swift:40:30: error: cannot\
    \ convert return expression of type 'Int' to return type 'Value?'\n        return\
    \ Double(a) > b ? a : b\n               ~~~~~~~~~~~~~~^~~~~~~\n"
  stdout: ''
  timestamp: 1660013181
- exit_code: 1
  program: "\nenum Value: Equatable, Hashable {\n    case intValue(Int)\n    case\
    \ doubleValue(Double)\n    case stringValue(String)\n}\n\n            \n/// Create\
    \ a function that takes integers, floats, or strings representing\n/// real numbers,\
    \ and returns the larger variable in its given variable type.\n/// Return nil\
    \ if the values are equal.\n/// Note: If a real number is represented as a string,\
    \ the floating point might be . or ,\n/// >>> compare_one(a: .intValue(1), b:\
    \ .doubleValue(2.5))\n/// .doubleValue(2.5)\n/// >>> compare_one(a: .intValue(1),\
    \ b: .stringValue(\"2,3\"))\n/// .stringValue(\"2,3\")\n/// >>> compare_one(a:\
    \ .stringValue(\"5,1\"), b: .stringValue(\"6\"))\n/// .stringValue(\"6\")\n///\
    \ >>> compare_one(a: .stringValue(\"1\"), b: .intValue(1))\n/// nil\nfunc compare_one(a:\
    \ Value, b: Value) -> Value? {\n    switch (a, b) {\n    case (.intValue(let a),\
    \ .intValue(let b)):\n        return a > b ? a : b\n    case (.doubleValue(let\
    \ a), .doubleValue(let b)):\n        return a > b ? a : b\n    case (.stringValue(let\
    \ a), .stringValue(let b)):\n        return a > b ? a : b\n    case (.intValue(let\
    \ a), .doubleValue(let b)):\n        return a > b ? a : b\n    case (.intValue(let\
    \ a), .stringValue(let b)):\n        return a > b ? a : b\n    case (.doubleValue(let\
    \ a), .intValue(let b)):\n        return a > b ? a : b\n    case (.doubleValue(let\
    \ a), .stringValue(let b)):\n        return a > b ? a : b\n    case (.stringValue(let\
    \ a), .intValue(let b)):\n        return a > b ? a : b\n    case (.stringValue(let\
    \ a), .doubleValue(let b)):\n        return a > b ? a : b\n    default:\n    \
    \    return nil\n    }\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(compare_one(a:\
    \ .intValue(1), b: .intValue(2)) == .intValue(2))\nassert(compare_one(a: .intValue(1),\
    \ b: .doubleValue(2.5)) == .doubleValue(2.5))\nassert(compare_one(a: .intValue(2),\
    \ b: .intValue(3)) == .intValue(3))\nassert(compare_one(a: .intValue(5), b: .intValue(6))\
    \ == .intValue(6))\nassert(compare_one(a: .intValue(1), b: .stringValue(\"2,3\"\
    )) == .stringValue(\"2,3\"))\nassert(compare_one(a: .stringValue(\"5,1\"), b:\
    \ .stringValue(\"6\")) == .stringValue(\"6\"))\nassert(compare_one(a: .stringValue(\"\
    1\"), b: .stringValue(\"2\")) == .stringValue(\"2\"))\nassert(compare_one(a: .stringValue(\"\
    1\"), b: .intValue(1)) == nil)"
  status: SyntaxError
  stderr: "/tmp/tmpjf037tzu.swift:24:22: error: cannot convert return expression of\
    \ type 'Int' to return type 'Value?'\n        return a > b ? a : b\n         \
    \      ~~~~~~^~~~~~~\n/tmp/tmpjf037tzu.swift:26:22: error: cannot convert return\
    \ expression of type 'Double' to return type 'Value?'\n        return a > b ?\
    \ a : b\n               ~~~~~~^~~~~~~\n/tmp/tmpjf037tzu.swift:28:22: error: cannot\
    \ convert return expression of type 'String' to return type 'Value?'\n       \
    \ return a > b ? a : b\n               ~~~~~~^~~~~~~\n/tmp/tmpjf037tzu.swift:30:20:\
    \ error: cannot convert value of type 'Double' to expected argument type 'Int'\n\
    \        return a > b ? a : b\n                   ^\n                   Int( )\n\
    /tmp/tmpjf037tzu.swift:30:22: error: cannot convert return expression of type\
    \ 'Int' to return type 'Value?'\n        return a > b ? a : b\n              \
    \ ~~~~~~^~~~~~~\n/tmp/tmpjf037tzu.swift:32:20: error: cannot convert value of\
    \ type 'String' to expected argument type 'Int'\n        return a > b ? a : b\n\
    \                   ^\n/tmp/tmpjf037tzu.swift:32:22: error: cannot convert return\
    \ expression of type 'Int' to return type 'Value?'\n        return a > b ? a :\
    \ b\n               ~~~~~~^~~~~~~\n/tmp/tmpjf037tzu.swift:34:16: error: cannot\
    \ convert value of type 'Double' to expected argument type 'Int'\n        return\
    \ a > b ? a : b\n               ^\n               Int( )\n/tmp/tmpjf037tzu.swift:34:22:\
    \ error: cannot convert return expression of type 'Double' to return type 'Value?'\n\
    \        return a > b ? a : b\n               ~~~~~~^~~~~~~\n/tmp/tmpjf037tzu.swift:36:18:\
    \ error: binary operator '>' cannot be applied to operands of type 'Double' and\
    \ 'String'\n        return a > b ? a : b\n               ~ ^ ~\n/tmp/tmpjf037tzu.swift:36:22:\
    \ error: cannot convert return expression of type 'Double' to return type 'Value?'\n\
    \        return a > b ? a : b\n               ~~~~~~^~~~~~~\n/tmp/tmpjf037tzu.swift:38:16:\
    \ error: cannot convert value of type 'String' to expected argument type 'Int'\n\
    \        return a > b ? a : b\n               ^\n/tmp/tmpjf037tzu.swift:38:22:\
    \ error: ca"
  stdout: ''
  timestamp: 1660013180
- exit_code: 1
  program: "\nenum Value: Equatable, Hashable {\n    case intValue(Int)\n    case\
    \ doubleValue(Double)\n    case stringValue(String)\n}\n\n            \n/// Create\
    \ a function that takes integers, floats, or strings representing\n/// real numbers,\
    \ and returns the larger variable in its given variable type.\n/// Return nil\
    \ if the values are equal.\n/// Note: If a real number is represented as a string,\
    \ the floating point might be . or ,\n/// >>> compare_one(a: .intValue(1), b:\
    \ .doubleValue(2.5))\n/// .doubleValue(2.5)\n/// >>> compare_one(a: .intValue(1),\
    \ b: .stringValue(\"2,3\"))\n/// .stringValue(\"2,3\")\n/// >>> compare_one(a:\
    \ .stringValue(\"5,1\"), b: .stringValue(\"6\"))\n/// .stringValue(\"6\")\n///\
    \ >>> compare_one(a: .stringValue(\"1\"), b: .intValue(1))\n/// nil\nfunc compare_one(a:\
    \ Value, b: Value) -> Value? {\n    switch (a, b) {\n    case (.intValue(let x),\
    \ .intValue(let y)):\n        return x > y ? .intValue(x) : (y > x ? .intValue(y)\
    \ : nil)\n    case (.intValue(let x), .doubleValue(let y)):\n        return y\
    \ > Double(x) ? .doubleValue(y) : nil\n    case (.intValue(let x), .stringValue(let\
    \ y)):\n        let z = y.replacingOccurrences(of: \",\", with: \".\")\n     \
    \   return Double(z) > Double(x) ? .stringValue(y) : nil\n    case (.doubleValue(let\
    \ x), .intValue(let y)):\n        return x > Double(y) ? .doubleValue(x) : nil\n\
    \    case (.doubleValue(let x), .doubleValue(let y)):\n        return x > y ?\
    \ .doubleValue(x) : (y > x ? .doubleValue(y) : nil)\n    case (.doubleValue(let\
    \ x), .stringValue(let y)):\n        let z = y.replacingOccurrences(of: \",\"\
    , with: \".\")\n        return Double(z) > x ? .stringValue(y) : nil\n    case\
    \ (.stringValue(let x), .intValue(let y)):\n        let z = x.replacingOccurrences(of:\
    \ \",\", with: \".\")\n        return Double(z) > Double(y) ? .stringValue(x)\
    \ : nil\n    case (.stringValue(let x), .doubleValue(let y)):\n        let z =\
    \ x.replacingOccurrences(of: \",\", with: \".\")\n        return Double(z) > y\
    \ ? .stringValue(x) : nil\n    case (.stringValue(let x), .stringValue(let y)):\n\
    \        let z = x.replacingOccurrences(of: \",\", with: \".\")\n        let k\
    \ = y.replacingOccurrences(of: \",\", with: \".\")\n        return Double(z) >\
    \ Double(k) ? .stringValue(x) : (Double(k) > Double(z) ? .stringValue(y) : nil\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(compare_one(a: .intValue(1), b: .intValue(2))\
    \ == .intValue(2))\nassert(compare_one(a: .intValue(1), b: .doubleValue(2.5))\
    \ == .doubleValue(2.5))\nassert(compare_one(a: .intValue(2), b: .intValue(3))\
    \ == .intValue(3))\nassert(compare_one(a: .intValue(5), b: .intValue(6)) == .intValue(6))\n\
    assert(compare_one(a: .intValue(1), b: .stringValue(\"2,3\")) == .stringValue(\"\
    2,3\"))\nassert(compare_one(a: .stringValue(\"5,1\"), b: .stringValue(\"6\"))\
    \ == .stringValue(\"6\"))\nassert(compare_one(a: .stringValue(\"1\"), b: .stringValue(\"\
    2\")) == .stringValue(\"2\"))\nassert(compare_one(a: .stringValue(\"1\"), b: .intValue(1))\
    \ == nil)"
  status: SyntaxError
  stderr: "/tmp/tmprchx914h.swift:47:1: error: expected ')' in expression list\n}\n\
    ^\n/tmp/tmprchx914h.swift:46:58: note: to match this opening '('\n        return\
    \ Double(z) > Double(k) ? .stringValue(x) : (Double(k) > Double(z) ? .stringValue(y)\
    \ : nil\n                                                         ^\n/tmp/tmprchx914h.swift:69:66:\
    \ error: expected '}' at end of brace statement\nassert(compare_one(a: .stringValue(\"\
    1\"), b: .intValue(1)) == nil)\n                                             \
    \                    ^\n/tmp/tmprchx914h.swift:21:48: note: to match this opening\
    \ '{'\nfunc compare_one(a: Value, b: Value) -> Value? {\n                    \
    \                           ^\n/tmp/tmprchx914h.swift:28:19: error: value of type\
    \ 'String' has no member 'replacingOccurrences'\n        let z = y.replacingOccurrences(of:\
    \ \",\", with: \".\")\n                ~ ^~~~~~~~~~~~~~~~~~~~\n/tmp/tmprchx914h.swift:35:19:\
    \ error: value of type 'String' has no member 'replacingOccurrences'\n       \
    \ let z = y.replacingOccurrences(of: \",\", with: \".\")\n                ~ ^~~~~~~~~~~~~~~~~~~~\n\
    /tmp/tmprchx914h.swift:38:19: error: value of type 'String' has no member 'replacingOccurrences'\n\
    \        let z = x.replacingOccurrences(of: \",\", with: \".\")\n            \
    \    ~ ^~~~~~~~~~~~~~~~~~~~\n/tmp/tmprchx914h.swift:41:19: error: value of type\
    \ 'String' has no member 'replacingOccurrences'\n        let z = x.replacingOccurrences(of:\
    \ \",\", with: \".\")\n                ~ ^~~~~~~~~~~~~~~~~~~~\n/tmp/tmprchx914h.swift:44:19:\
    \ error: value of type 'String' has no member 'replacingOccurrences'\n       \
    \ let z = x.replacingOccurrences(of: \",\", with: \".\")\n                ~ ^~~~~~~~~~~~~~~~~~~~\n\
    /tmp/tmprchx914h.swift:45:19: error: value of type 'String' has no member 'replacingOccurrences'\n\
    \        let k = y.replacingOccurrences(of: \",\", with: \".\")\n            \
    \    ~ ^~~~~~~~~~~~~~~~~~~~\n/tmp/tmprchx914h.swift:50:6: error: operator functions\
    \ can only be declared at global or in type scope\nfunc ==(left: [(Int, Int)],\
    \ right: [(Int, Int)]) -> Bool {\n     ^\n"
  stdout: ''
  timestamp: 1660013182
- exit_code: 1
  program: "\nenum Value: Equatable, Hashable {\n    case intValue(Int)\n    case\
    \ doubleValue(Double)\n    case stringValue(String)\n}\n\n            \n/// Create\
    \ a function that takes integers, floats, or strings representing\n/// real numbers,\
    \ and returns the larger variable in its given variable type.\n/// Return nil\
    \ if the values are equal.\n/// Note: If a real number is represented as a string,\
    \ the floating point might be . or ,\n/// >>> compare_one(a: .intValue(1), b:\
    \ .doubleValue(2.5))\n/// .doubleValue(2.5)\n/// >>> compare_one(a: .intValue(1),\
    \ b: .stringValue(\"2,3\"))\n/// .stringValue(\"2,3\")\n/// >>> compare_one(a:\
    \ .stringValue(\"5,1\"), b: .stringValue(\"6\"))\n/// .stringValue(\"6\")\n///\
    \ >>> compare_one(a: .stringValue(\"1\"), b: .intValue(1))\n/// nil\nfunc compare_one(a:\
    \ Value, b: Value) -> Value? {\n    switch a {\n    case .intValue(let intValue):\n\
    \        switch b {\n        case .intValue(let bIntValue):\n            return\
    \ intValue > bIntValue ? a : b\n        case .doubleValue(let bDoubleValue):\n\
    \            return a\n        case .stringValue(let bStringValue):\n        \
    \    return Double(bStringValue) ?? Double(bStringValue.replacingOccurrences(of:\
    \ \",\", with: \".\")) != nil ? b : nil\n        }\n    case .doubleValue(let\
    \ doubleValue):\n        switch b {\n        case .intValue(let bIntValue):\n\
    \            return b\n        case .doubleValue(let bDoubleValue):\n        \
    \    return doubleValue > bDoubleValue ? a : b\n        case .stringValue(let\
    \ bStringValue):\n            return Double(bStringValue) ?? Double(bStringValue.replacingOccurrences(of:\
    \ \",\", with: \".\")) != nil ? b : nil\n        }\n    case .stringValue(let\
    \ stringValue):\n        switch b {\n        case .intValue(let bIntValue):\n\
    \            return Double(stringValue) ?? Double(stringValue.replacingOccurrences(of:\
    \ \",\", with: \".\")) != nil ? a : nil\n        case .doubleValue(let bDoubleValue):\n\
    \            return a\n        case .stringValue(let bStringValue):\n        \
    \    if let aDouble = Double(stringValue) ?? Double(stringValue.replacingOccurrences(of:\
    \ \",\", with: \".\")),\n                let bDouble = Double(bStringValue) ??\
    \ Double(bStringValue.replacingOccurrences(of: \",\", with: \".\")) {\n      \
    \          return aDouble > bDouble ? a : b\n            } else {\n          \
    \      return nil\n            }\n        }\n    }\n}\n\n\nfunc ==(left: [(Int,\
    \ Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n\
    \        return false\n    }\n    for (l, r) in zip(left, right) {\n        if\
    \ l != r {\n            return false\n        }\n    }\n    return true\n}\n \
    \           \nassert(compare_one(a: .intValue(1), b: .intValue(2)) == .intValue(2))\n\
    assert(compare_one(a: .intValue(1), b: .doubleValue(2.5)) == .doubleValue(2.5))\n\
    assert(compare_one(a: .intValue(2), b: .intValue(3)) == .intValue(3))\nassert(compare_one(a:\
    \ .intValue(5), b: .intValue(6)) == .intValue(6))\nassert(compare_one(a: .intValue(1),\
    \ b: .stringValue(\"2,3\")) == .stringValue(\"2,3\"))\nassert(compare_one(a: .stringValue(\"\
    5,1\"), b: .stringValue(\"6\")) == .stringValue(\"6\"))\nassert(compare_one(a:\
    \ .stringValue(\"1\"), b: .stringValue(\"2\")) == .stringValue(\"2\"))\nassert(compare_one(a:\
    \ .stringValue(\"1\"), b: .intValue(1)) == nil)"
  status: SyntaxError
  stderr: "/tmp/tmpw02lqid3.swift:30:64: error: value of type 'String' has no member\
    \ 'replacingOccurrences'\n            return Double(bStringValue) ?? Double(bStringValue.replacingOccurrences(of:\
    \ \",\", with: \".\")) != nil ? b : nil\n                                    \
    \              ~~~~~~~~~~~~ ^~~~~~~~~~~~~~~~~~~~\n/tmp/tmpw02lqid3.swift:39:64:\
    \ error: value of type 'String' has no member 'replacingOccurrences'\n       \
    \     return Double(bStringValue) ?? Double(bStringValue.replacingOccurrences(of:\
    \ \",\", with: \".\")) != nil ? b : nil\n                                    \
    \              ~~~~~~~~~~~~ ^~~~~~~~~~~~~~~~~~~~\n/tmp/tmpw02lqid3.swift:44:62:\
    \ error: value of type 'String' has no member 'replacingOccurrences'\n       \
    \     return Double(stringValue) ?? Double(stringValue.replacingOccurrences(of:\
    \ \",\", with: \".\")) != nil ? a : nil\n                                    \
    \             ~~~~~~~~~~~ ^~~~~~~~~~~~~~~~~~~~\n/tmp/tmpw02lqid3.swift:48:72:\
    \ error: value of type 'String' has no member 'replacingOccurrences'\n       \
    \     if let aDouble = Double(stringValue) ?? Double(stringValue.replacingOccurrences(of:\
    \ \",\", with: \".\")),\n                                                    \
    \       ~~~~~~~~~~~ ^~~~~~~~~~~~~~~~~~~~\n/tmp/tmpw02lqid3.swift:49:75: error:\
    \ value of type 'String' has no member 'replacingOccurrences'\n              \
    \  let bDouble = Double(bStringValue) ?? Double(bStringValue.replacingOccurrences(of:\
    \ \",\", with: \".\")) {\n                                                   \
    \          ~~~~~~~~~~~~ ^~~~~~~~~~~~~~~~~~~~\n"
  stdout: ''
  timestamp: 1660013181
- exit_code: 1
  program: "\nenum Value: Equatable, Hashable {\n    case intValue(Int)\n    case\
    \ doubleValue(Double)\n    case stringValue(String)\n}\n\n            \n/// Create\
    \ a function that takes integers, floats, or strings representing\n/// real numbers,\
    \ and returns the larger variable in its given variable type.\n/// Return nil\
    \ if the values are equal.\n/// Note: If a real number is represented as a string,\
    \ the floating point might be . or ,\n/// >>> compare_one(a: .intValue(1), b:\
    \ .doubleValue(2.5))\n/// .doubleValue(2.5)\n/// >>> compare_one(a: .intValue(1),\
    \ b: .stringValue(\"2,3\"))\n/// .stringValue(\"2,3\")\n/// >>> compare_one(a:\
    \ .stringValue(\"5,1\"), b: .stringValue(\"6\"))\n/// .stringValue(\"6\")\n///\
    \ >>> compare_one(a: .stringValue(\"1\"), b: .intValue(1))\n/// nil\nfunc compare_one(a:\
    \ Value, b: Value) -> Value? {\n    switch (a, b) {\n    case let (.intValue(a),\
    \ .intValue(b)) where a == b:\n        return nil\n    case let (.intValue(a),\
    \ .intValue(b)) where a > b:\n        return a\n    case let (.intValue(a), .intValue(b))\
    \ where a < b:\n        return b\n    case let (.intValue(a), .doubleValue(b))\
    \ where a > b:\n        return a\n    case let (.intValue(a), .doubleValue(b))\
    \ where a < b:\n        return b\n    case let (.intValue(a), .stringValue(b))\
    \ where a > Int(b)!:\n        return a\n    case let (.intValue(a), .stringValue(b))\
    \ where a < Int(b)!:\n        return b\n    case let (.doubleValue(a), .intValue(b))\
    \ where a > b:\n        return a\n    case let (.doubleValue(a), .intValue(b))\
    \ where a < b:\n        return b\n    case let (.doubleValue(a), .doubleValue(b))\
    \ where a == b:\n        return nil\n    case let (.doubleValue(a), .doubleValue(b))\
    \ where a > b:\n        return a\n    case let (.doubleValue(a), .doubleValue(b))\
    \ where a < b:\n        return b\n    case let (.doubleValue(a), .stringValue(b))\
    \ where a > Double(b)!:\n        return a\n    case let (.doubleValue(a), .stringValue(b))\
    \ where a < Double(b)!:\n        return b\n    case let (.stringValue(a), .intValue(b))\
    \ where Double(a)! > b:\n        return a\n    case let (.stringValue(a), .intValue(b))\
    \ where Double(a)! < b:\n        return b\n    case let (.stringValue(a), .doubleValue(b))\
    \ where Double(a)! > b:\n        return a\n    case let (.stringValue(a), .doubleValue(b))\
    \ where Double(a)! < b:\n        return b\n    case let (.stringValue(a), .stringValue(b))\
    \ where Double(a)! == Double(b)!:\n       \n}\n\n\nfunc ==(left: [(Int, Int)],\
    \ right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n       \
    \ return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r\
    \ {\n            return false\n        }\n    }\n    return true\n}\n        \
    \    \nassert(compare_one(a: .intValue(1), b: .intValue(2)) == .intValue(2))\n\
    assert(compare_one(a: .intValue(1), b: .doubleValue(2.5)) == .doubleValue(2.5))\n\
    assert(compare_one(a: .intValue(2), b: .intValue(3)) == .intValue(3))\nassert(compare_one(a:\
    \ .intValue(5), b: .intValue(6)) == .intValue(6))\nassert(compare_one(a: .intValue(1),\
    \ b: .stringValue(\"2,3\")) == .stringValue(\"2,3\"))\nassert(compare_one(a: .stringValue(\"\
    5,1\"), b: .stringValue(\"6\")) == .stringValue(\"6\"))\nassert(compare_one(a:\
    \ .stringValue(\"1\"), b: .stringValue(\"2\")) == .stringValue(\"2\"))\nassert(compare_one(a:\
    \ .stringValue(\"1\"), b: .intValue(1)) == nil)"
  status: SyntaxError
  stderr: "/tmp/tmp52_od5qv.swift:59:5: error: 'case' label in a 'switch' must have\
    \ at least one executable statement\n    case let (.stringValue(a), .stringValue(b))\
    \ where Double(a)! == Double(b)!:\n    ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n\
    \                                                                            \
    \    break\n/tmp/tmp52_od5qv.swift:83:66: error: expected '}' at end of brace\
    \ statement\nassert(compare_one(a: .stringValue(\"1\"), b: .intValue(1)) == nil)\n\
    \                                                                 ^\n/tmp/tmp52_od5qv.swift:21:48:\
    \ note: to match this opening '{'\nfunc compare_one(a: Value, b: Value) -> Value?\
    \ {\n                                               ^\n/tmp/tmp52_od5qv.swift:29:54:\
    \ error: binary operator '>' cannot be applied to operands of type 'Int' and 'Double'\n\
    \    case let (.intValue(a), .doubleValue(b)) where a > b:\n                 \
    \                                  ~ ^ ~\n/tmp/tmp52_od5qv.swift:29:54: note:\
    \ overloads for '>' exist with these partially matching parameter lists: (Int,\
    \ Int)\n    case let (.intValue(a), .doubleValue(b)) where a > b:\n          \
    \                                           ^\n/tmp/tmp52_od5qv.swift:31:54: error:\
    \ binary operator '<' cannot be applied to operands of type 'Int' and 'Double'\n\
    \    case let (.intValue(a), .doubleValue(b)) where a < b:\n                 \
    \                                  ~ ^ ~\n/tmp/tmp52_od5qv.swift:31:54: note:\
    \ overloads for '<' exist with these partially matching parameter lists: (Int,\
    \ Int)\n    case let (.intValue(a), .doubleValue(b)) where a < b:\n          \
    \                                           ^\n/tmp/tmp52_od5qv.swift:37:54: error:\
    \ binary operator '>' cannot be applied to operands of type 'Double' and 'Int'\n\
    \    case let (.doubleValue(a), .intValue(b)) where a > b:\n                 \
    \                                  ~ ^ ~\n/tmp/tmp52_od5qv.swift:37:54: note:\
    \ overloads for '>' exist with these partially matching parameter lists: (Int,\
    \ Int)\n    case let (.doubleValue(a), .intValue(b)) where a > b:\n "
  stdout: ''
  timestamp: 1660013181
- exit_code: 1
  program: "\nenum Value: Equatable, Hashable {\n    case intValue(Int)\n    case\
    \ doubleValue(Double)\n    case stringValue(String)\n}\n\n            \n/// Create\
    \ a function that takes integers, floats, or strings representing\n/// real numbers,\
    \ and returns the larger variable in its given variable type.\n/// Return nil\
    \ if the values are equal.\n/// Note: If a real number is represented as a string,\
    \ the floating point might be . or ,\n/// >>> compare_one(a: .intValue(1), b:\
    \ .doubleValue(2.5))\n/// .doubleValue(2.5)\n/// >>> compare_one(a: .intValue(1),\
    \ b: .stringValue(\"2,3\"))\n/// .stringValue(\"2,3\")\n/// >>> compare_one(a:\
    \ .stringValue(\"5,1\"), b: .stringValue(\"6\"))\n/// .stringValue(\"6\")\n///\
    \ >>> compare_one(a: .stringValue(\"1\"), b: .intValue(1))\n/// nil\nfunc compare_one(a:\
    \ Value, b: Value) -> Value? {\n    switch (a, b) {\n    case (.intValue(let a),\
    \ .intValue(let b)):\n        return a >= b ? a : b\n    case (.doubleValue(let\
    \ a), .doubleValue(let b)):\n        return a >= b ? a : b\n    case (.stringValue(let\
    \ a), .stringValue(let b)):\n        return a >= b ? a : b\n    case (.intValue(let\
    \ a), .doubleValue(let b)):\n        return a >= b ? a : b\n    case (.intValue(let\
    \ a), .stringValue(let b)):\n        return a >= b ? a : b\n    case (.doubleValue(let\
    \ a), .intValue(let b)):\n        return a >= b ? a : b\n    case (.doubleValue(let\
    \ a), .stringValue(let b)):\n        return a >= b ? a : b\n    case (.stringValue(let\
    \ a), .intValue(let b)):\n        return a >= b ? a : b\n    case (.stringValue(let\
    \ a), .doubleValue(let b)):\n        return a >= b ? a : b\n    default:\n   \
    \     return nil\n    }\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(compare_one(a:\
    \ .intValue(1), b: .intValue(2)) == .intValue(2))\nassert(compare_one(a: .intValue(1),\
    \ b: .doubleValue(2.5)) == .doubleValue(2.5))\nassert(compare_one(a: .intValue(2),\
    \ b: .intValue(3)) == .intValue(3))\nassert(compare_one(a: .intValue(5), b: .intValue(6))\
    \ == .intValue(6))\nassert(compare_one(a: .intValue(1), b: .stringValue(\"2,3\"\
    )) == .stringValue(\"2,3\"))\nassert(compare_one(a: .stringValue(\"5,1\"), b:\
    \ .stringValue(\"6\")) == .stringValue(\"6\"))\nassert(compare_one(a: .stringValue(\"\
    1\"), b: .stringValue(\"2\")) == .stringValue(\"2\"))\nassert(compare_one(a: .stringValue(\"\
    1\"), b: .intValue(1)) == nil)"
  status: SyntaxError
  stderr: "/tmp/tmpa4w3uz2b.swift:24:23: error: cannot convert return expression of\
    \ type 'Int' to return type 'Value?'\n        return a >= b ? a : b\n        \
    \       ~~~~~~~^~~~~~~\n/tmp/tmpa4w3uz2b.swift:26:23: error: cannot convert return\
    \ expression of type 'Double' to return type 'Value?'\n        return a >= b ?\
    \ a : b\n               ~~~~~~~^~~~~~~\n/tmp/tmpa4w3uz2b.swift:28:23: error: cannot\
    \ convert return expression of type 'String' to return type 'Value?'\n       \
    \ return a >= b ? a : b\n               ~~~~~~~^~~~~~~\n/tmp/tmpa4w3uz2b.swift:30:21:\
    \ error: cannot convert value of type 'Double' to expected argument type 'Int'\n\
    \        return a >= b ? a : b\n                    ^\n                    Int(\
    \ )\n/tmp/tmpa4w3uz2b.swift:30:23: error: cannot convert return expression of\
    \ type 'Int' to return type 'Value?'\n        return a >= b ? a : b\n        \
    \       ~~~~~~~^~~~~~~\n/tmp/tmpa4w3uz2b.swift:32:21: error: cannot convert value\
    \ of type 'String' to expected argument type 'Int'\n        return a >= b ? a\
    \ : b\n                    ^\n/tmp/tmpa4w3uz2b.swift:32:23: error: cannot convert\
    \ return expression of type 'Int' to return type 'Value?'\n        return a >=\
    \ b ? a : b\n               ~~~~~~~^~~~~~~\n/tmp/tmpa4w3uz2b.swift:34:16: error:\
    \ cannot convert value of type 'Double' to expected argument type 'Int'\n    \
    \    return a >= b ? a : b\n               ^\n               Int( )\n/tmp/tmpa4w3uz2b.swift:34:23:\
    \ error: cannot convert return expression of type 'Double' to return type 'Value?'\n\
    \        return a >= b ? a : b\n               ~~~~~~~^~~~~~~\n/tmp/tmpa4w3uz2b.swift:36:18:\
    \ error: binary operator '>=' cannot be applied to operands of type 'Double' and\
    \ 'String'\n        return a >= b ? a : b\n               ~ ^  ~\n/tmp/tmpa4w3uz2b.swift:36:23:\
    \ error: cannot convert return expression of type 'Double' to return type 'Value?'\n\
    \        return a >= b ? a : b\n               ~~~~~~~^~~~~~~\n/tmp/tmpa4w3uz2b.swift:38:16:\
    \ error: cannot convert value of type 'String' to expected argument type 'Int'\n\
    \        return a >= b ? a : b\n               ^\n/tmp/tmpa4w3uz2"
  stdout: ''
  timestamp: 1660013180
- exit_code: -4
  program: "\nenum Value: Equatable, Hashable {\n    case intValue(Int)\n    case\
    \ doubleValue(Double)\n    case stringValue(String)\n}\n\n            \n/// Create\
    \ a function that takes integers, floats, or strings representing\n/// real numbers,\
    \ and returns the larger variable in its given variable type.\n/// Return nil\
    \ if the values are equal.\n/// Note: If a real number is represented as a string,\
    \ the floating point might be . or ,\n/// >>> compare_one(a: .intValue(1), b:\
    \ .doubleValue(2.5))\n/// .doubleValue(2.5)\n/// >>> compare_one(a: .intValue(1),\
    \ b: .stringValue(\"2,3\"))\n/// .stringValue(\"2,3\")\n/// >>> compare_one(a:\
    \ .stringValue(\"5,1\"), b: .stringValue(\"6\"))\n/// .stringValue(\"6\")\n///\
    \ >>> compare_one(a: .stringValue(\"1\"), b: .intValue(1))\n/// nil\nfunc compare_one(a:\
    \ Value, b: Value) -> Value? {\n    return nil\n}\n\n\nfunc ==(left: [(Int, Int)],\
    \ right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n       \
    \ return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r\
    \ {\n            return false\n        }\n    }\n    return true\n}\n        \
    \    \nassert(compare_one(a: .intValue(1), b: .intValue(2)) == .intValue(2))\n\
    assert(compare_one(a: .intValue(1), b: .doubleValue(2.5)) == .doubleValue(2.5))\n\
    assert(compare_one(a: .intValue(2), b: .intValue(3)) == .intValue(3))\nassert(compare_one(a:\
    \ .intValue(5), b: .intValue(6)) == .intValue(6))\nassert(compare_one(a: .intValue(1),\
    \ b: .stringValue(\"2,3\")) == .stringValue(\"2,3\"))\nassert(compare_one(a: .stringValue(\"\
    5,1\"), b: .stringValue(\"6\")) == .stringValue(\"6\"))\nassert(compare_one(a:\
    \ .stringValue(\"1\"), b: .stringValue(\"2\")) == .stringValue(\"2\"))\nassert(compare_one(a:\
    \ .stringValue(\"1\"), b: .intValue(1)) == nil)"
  status: Exception
  stderr: 'tmpllswmh2d/tmpllswmh2d.swift:38: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b05c2ae8c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b05c27dfb6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b05c27df988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b05c27de7b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpllswmh2d                        0x000055f806e32a56 <unavailable> + 6742

    5    libc.so.6                          0x00002b05c2cd4460 __libc_start_main +
    245

    6    tmpllswmh2d                        0x000055f806e32499 <unavailable> + 5273

    '
  stdout: ''
  timestamp: 1660013179
- exit_code: 1
  program: "\nenum Value: Equatable, Hashable {\n    case intValue(Int)\n    case\
    \ doubleValue(Double)\n    case stringValue(String)\n}\n\n            \n/// Create\
    \ a function that takes integers, floats, or strings representing\n/// real numbers,\
    \ and returns the larger variable in its given variable type.\n/// Return nil\
    \ if the values are equal.\n/// Note: If a real number is represented as a string,\
    \ the floating point might be . or ,\n/// >>> compare_one(a: .intValue(1), b:\
    \ .doubleValue(2.5))\n/// .doubleValue(2.5)\n/// >>> compare_one(a: .intValue(1),\
    \ b: .stringValue(\"2,3\"))\n/// .stringValue(\"2,3\")\n/// >>> compare_one(a:\
    \ .stringValue(\"5,1\"), b: .stringValue(\"6\"))\n/// .stringValue(\"6\")\n///\
    \ >>> compare_one(a: .stringValue(\"1\"), b: .intValue(1))\n/// nil\nfunc compare_one(a:\
    \ Value, b: Value) -> Value? {\n    var aInt: Int?\n    var aDouble: Double?\n\
    \    var aString: String?\n    var bInt: Int?\n    var bDouble: Double?\n    var\
    \ bString: String?\n    \n    switch a {\n    case .intValue(let x):\n       \
    \ aInt = x\n    case .doubleValue(let x):\n        aDouble = x\n    case .stringValue(let\
    \ x):\n        aString = x\n    }\n    \n    switch b {\n    case .intValue(let\
    \ x):\n        bInt = x\n    case .doubleValue(let x):\n        bDouble = x\n\
    \    case .stringValue(let x):\n        bString = x\n    }\n    \n    if let aI\
    \ = aInt, let bI = bInt {\n        if aI == bI {\n            return nil\n   \
    \     } else if aI > bI {\n            return a\n        } else {\n          \
    \  return b\n        }\n    } else if let aD = aDouble, let bD = bDouble {\n \
    \       if aD == bD {\n            return nil\n        } else if aD > bD {\n \
    \           return a\n        } else {\n            return b\n        }\n    }\
    \ else if let aS = aString, let bS = bString {\n        if aS == bS {\n      \
    \      return nil\n        } else if aS > bS {\n            return a\n       \
    \ } else {\n            return b\n        }\n    } else if let aI = aInt, let\
    \ bD = bDouble {\n        if Double(aI) == bD {\n            return nil\n    \
    \    } else if Double(aI) > bD {\n            return a\n        } else {\n   \
    \         return b\n        }\n    } else if let aI = aInt, let bS = bString {\n\
    \        if Double(aI) == Double(bS) {\n            return nil\n        } else\
    \ if Double(aI) > Double(bS) {\n            return a\n        } else {\n     \
    \       return b\n        }\n    } else if let aD = aDouble, let bI = bInt {\n\
    \        if aD == Double(bI) {\n            return nil\n}\n\n\nfunc ==(left: [(Int,\
    \ Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n\
    \        return false\n    }\n    for (l, r) in zip(left, right) {\n        if\
    \ l != r {\n            return false\n        }\n    }\n    return true\n}\n \
    \           \nassert(compare_one(a: .intValue(1), b: .intValue(2)) == .intValue(2))\n\
    assert(compare_one(a: .intValue(1), b: .doubleValue(2.5)) == .doubleValue(2.5))\n\
    assert(compare_one(a: .intValue(2), b: .intValue(3)) == .intValue(3))\nassert(compare_one(a:\
    \ .intValue(5), b: .intValue(6)) == .intValue(6))\nassert(compare_one(a: .intValue(1),\
    \ b: .stringValue(\"2,3\")) == .stringValue(\"2,3\"))\nassert(compare_one(a: .stringValue(\"\
    5,1\"), b: .stringValue(\"6\")) == .stringValue(\"6\"))\nassert(compare_one(a:\
    \ .stringValue(\"1\"), b: .stringValue(\"2\")) == .stringValue(\"2\"))\nassert(compare_one(a:\
    \ .stringValue(\"1\"), b: .intValue(1)) == nil)"
  status: SyntaxError
  stderr: "/tmp/tmpeboasyu7.swift:112:66: error: expected '}' at end of brace statement\n\
    assert(compare_one(a: .stringValue(\"1\"), b: .intValue(1)) == nil)\n        \
    \                                                         ^\n/tmp/tmpeboasyu7.swift:87:47:\
    \ note: to match this opening '{'\n    } else if let aD = aDouble, let bI = bInt\
    \ {\n                                              ^\n/tmp/tmpeboasyu7.swift:112:66:\
    \ error: expected '}' at end of brace statement\nassert(compare_one(a: .stringValue(\"\
    1\"), b: .intValue(1)) == nil)\n                                             \
    \                    ^\n/tmp/tmpeboasyu7.swift:21:48: note: to match this opening\
    \ '{'\nfunc compare_one(a: Value, b: Value) -> Value? {\n                    \
    \                           ^\n/tmp/tmpeboasyu7.swift:82:32: error: value of optional\
    \ type 'Double?' must be unwrapped to a value of type 'Double'\n        } else\
    \ if Double(aI) > Double(bS) {\n                               ^\n/tmp/tmpeboasyu7.swift:82:32:\
    \ note: coalesce using '??' to provide a default when the optional value contains\
    \ 'nil'\n        } else if Double(aI) > Double(bS) {\n                       \
    \        ^\n                                          ?? <#default value#>\n/tmp/tmpeboasyu7.swift:82:32:\
    \ note: force-unwrap using '!' to abort execution if the optional value contains\
    \ 'nil'\n        } else if Double(aI) > Double(bS) {\n                       \
    \        ^\n                                         !\n/tmp/tmpeboasyu7.swift:93:6:\
    \ error: operator functions can only be declared at global or in type scope\n\
    func ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n     ^\n"
  stdout: ''
  timestamp: 1660013181
- exit_code: 1
  program: "\nenum Value: Equatable, Hashable {\n    case intValue(Int)\n    case\
    \ doubleValue(Double)\n    case stringValue(String)\n}\n\n            \n/// Create\
    \ a function that takes integers, floats, or strings representing\n/// real numbers,\
    \ and returns the larger variable in its given variable type.\n/// Return nil\
    \ if the values are equal.\n/// Note: If a real number is represented as a string,\
    \ the floating point might be . or ,\n/// >>> compare_one(a: .intValue(1), b:\
    \ .doubleValue(2.5))\n/// .doubleValue(2.5)\n/// >>> compare_one(a: .intValue(1),\
    \ b: .stringValue(\"2,3\"))\n/// .stringValue(\"2,3\")\n/// >>> compare_one(a:\
    \ .stringValue(\"5,1\"), b: .stringValue(\"6\"))\n/// .stringValue(\"6\")\n///\
    \ >>> compare_one(a: .stringValue(\"1\"), b: .intValue(1))\n/// nil\nfunc compare_one(a:\
    \ Value, b: Value) -> Value? {\n    guard let aValue = convertToDouble(a), let\
    \ bValue = convertToDouble(b) else {\n        return nil\n    }\n    return aValue\
    \ < bValue ? b : a\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) ->\
    \ Bool {\n    if left.count != right.count {\n        return false\n    }\n  \
    \  for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(compare_one(a: .intValue(1),\
    \ b: .intValue(2)) == .intValue(2))\nassert(compare_one(a: .intValue(1), b: .doubleValue(2.5))\
    \ == .doubleValue(2.5))\nassert(compare_one(a: .intValue(2), b: .intValue(3))\
    \ == .intValue(3))\nassert(compare_one(a: .intValue(5), b: .intValue(6)) == .intValue(6))\n\
    assert(compare_one(a: .intValue(1), b: .stringValue(\"2,3\")) == .stringValue(\"\
    2,3\"))\nassert(compare_one(a: .stringValue(\"5,1\"), b: .stringValue(\"6\"))\
    \ == .stringValue(\"6\"))\nassert(compare_one(a: .stringValue(\"1\"), b: .stringValue(\"\
    2\")) == .stringValue(\"2\"))\nassert(compare_one(a: .stringValue(\"1\"), b: .intValue(1))\
    \ == nil)"
  status: SyntaxError
  stderr: "/tmp/tmpu0e9jum1.swift:22:24: error: cannot find 'convertToDouble' in scope\n\
    \    guard let aValue = convertToDouble(a), let bValue = convertToDouble(b) else\
    \ {\n                       ^~~~~~~~~~~~~~~\n/tmp/tmpu0e9jum1.swift:22:57: error:\
    \ cannot find 'convertToDouble' in scope\n    guard let aValue = convertToDouble(a),\
    \ let bValue = convertToDouble(b) else {\n                                   \
    \                     ^~~~~~~~~~~~~~~\n"
  stdout: ''
  timestamp: 1660013181
