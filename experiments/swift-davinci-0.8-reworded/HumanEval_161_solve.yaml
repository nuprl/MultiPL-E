name: HumanEval_161_solve
language: swift
prompt: "\n/// You are given a string s.\n/// if s[i] is a letter, reverse its case\
  \ from lower to upper or vise versa, \n/// otherwise keep it as it is.\n/// If the\
  \ string contains no letters, reverse the string.\n/// The function should return\
  \ the resulted string.\n/// Examples\n/// >>> solve(s: \"1234\")\n/// \"4321\"\n\
  /// >>> solve(s: \"ab\")\n/// \"AB\"\n/// >>> solve(s: \"#a@C\")\n/// \"#A@c\"\n\
  func solve(s: String) -> String {\n"
tests: "}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if\
  \ left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left,\
  \ right) {\n        if l != r {\n            return false\n        }\n    }\n  \
  \  return true\n}\n            \nassert(solve(s: \"AsDf\") == \"aSdF\")\nassert(solve(s:\
  \ \"1234\") == \"4321\")\nassert(solve(s: \"ab\") == \"AB\")\nassert(solve(s: \"\
  #a@C\") == \"#A@c\")\nassert(solve(s: \"#AsdfW^45\") == \"#aSDFw^45\")\nassert(solve(s:\
  \ \"#6@2\") == \"2@6#\")\nassert(solve(s: \"#$a^D\") == \"#$A^d\")\nassert(solve(s:\
  \ \"#ccc\") == \"#CCC\")"
completions: ['    return String(s.reversed().map { $0.isLetter ? String($0).lowercased()
    == String($0) ? String($0).uppercased() : String($0).lowercased() : String($0)
    })', "    var str = String()\n    for ch in s {\n        if ch.isLetter {\n  \
    \          if ch.isLowercase {\n                str.append(ch.uppercased())\n\
    \            } else {\n                str.append(ch.lowercased())\n         \
    \   }\n        } else {\n            str.append(ch)\n        }\n    }\n    return\
    \ str.isEmpty ? String(s.reversed()) : str", "    if s.contains(\"[a-zA-Z]\")\
    \ {\n        return String(s.reversed())\n    } else {\n        return s.lowercased()\n\
    \    }", '  return ""', "    var r = s.reversed()\n    if let char = r.first,\
    \ char.isLetter {\n        r = String(r.map { char in\n            if char.isLetter\
    \ {\n                return char.isUppercase ? Character(char.lowercased()) :\
    \ Character(char.uppercased())\n            }\n            return char\n     \
    \   })\n    }\n    return String(r)", '    return String(s.reversed())', "   \
    \ var s = s\n    var newS = \"\"\n    var letterCount = 0\n    var i = 0\n   \
    \ while i < s.count {\n        let c = s[s.index(s.startIndex, offsetBy: i)]\n\
    \        if c.isLetter {\n            letterCount += 1\n        }\n        i +=\
    \ 1\n    }\n    if letterCount == 0 {\n        return String(s.reversed())\n \
    \   }\n    i = 0\n    while i < s.count {\n        let c = s[s.index(s.startIndex,\
    \ offsetBy: i)]\n        if c.isLetter {\n            newS.append(c.isLowercase\
    \ ? Character(String(c).uppercased()) : Character(String(c).lowercased()))\n \
    \       } else {\n            newS.append(c)\n        }\n        i += 1\n    }\n\
    \    return newS", '    // code', "    var array: [Character] = []\n    for char\
    \ in s {\n        array.append(char)\n    }\n    var reversed: [Character] = []\n\
    \    for index in 0..<array.count {\n        if array[index].isLetter {\n    \
    \        if array[index].isUppercase {\n                reversed.append(array[index].lowercased())\n\
    \            } else {\n                reversed.append(array[index].uppercased())\n\
    \            }\n        } else {\n            reversed.append(array[index])\n\
    \        }\n    }\n    return String(reversed.reversed())", "    if(!s.contains(\"\
    a\") && !s.contains(\"b\") && !s.contains(\"c\") && !s.contains(\"d\") && !s.contains(\"\
    e\") && !s.contains(\"f\") && !s.contains(\"g\") && !s.contains(\"h\") && !s.contains(\"\
    i\") && !s.contains(\"j\") && !s.contains(\"k\") && !s.contains(\"l\") && !s.contains(\"\
    m\") && !s.contains(\"n\") && !s.contains(\"o\") && !s.contains(\"p\") && !s.contains(\"\
    q\") && !s.contains(\"r\") && !s.contains(\"s\") && !s.contains(\"t\") && !s.contains(\"\
    u\") && !s.contains(\"v\") && !s.contains(\"w\") && !s.contains(\"x\") && !s.contains(\"\
    y\") && !s.contains(\"z\") && !s.contains(\"A\") && !s.contains(\"B\") && !s.contains(\"\
    C\") && !s.contains(\"D\") && !s.contains(\"E\") && !s.contains(\"F\") && !s.contains(\"\
    G\") && !s.contains(\"H\") && !s.contains(\"I\") && !s.contains(\"J\") && !s.contains(\"\
    K\") && !s.contains(\"L\") && !s.contains(\"M\") && !s.contains(\"N\") && !s.contains(\"\
    O\") && !s.contains(\"P\") && !s.contains(\"Q\") && !s.contains(\"R\") && !s.contains(\"\
    S\") && !s.contains(\"T\") && !s.contains(\"U\") && !s.contains(\"V\") && !s.contains(\"\
    W\") && !s.contains(\"X\") && !s.contains(\"Y\") && !s.contains(\"Z\")){\n   \
    \     return String(s.reversed())\n    }else{\n        var sArray = Array(s)\n\
    \        for i in 0..<sArray.count{\n", "    guard s.contains(\"[a-zA-Z]\") else\
    \ { return String(s.reversed()) }\n    return s.map { $0.isLetter ? $0.lowercased()\
    \ == $0 ? $0.uppercased() : $0.lowercased() : $0 }", "  var res = \"\"\n  for\
    \ char in s {\n    if \"A\"...\"Z\" ~= char {\n      res += String(char).lowercased()\n\
    \    } else if \"a\"...\"z\" ~= char {\n      res += String(char).uppercased()\n\
    \    } else {\n      res += String(char)\n    }\n  }\n  return res.isEmpty ? String(s.reversed())\
    \ : res", "    if !s.contains(where: { $0.isLetter }) {\n        return String(s.reversed())\n\
    \    }\n    var result = \"\"\n    for char in s {\n        if char.isLetter {\n\
    \            result.append(char.isUppercase ? char.lowercased() : char.uppercased())\n\
    \        } else {\n            result.append(char)\n        }\n    }\n    return\
    \ result", "    guard s.filter({ $0.isLetter }).count > 0 else {\n        return\
    \ String(s.reversed())\n    }\n    return String(s.map({ $0.isLetter ? $0.isUppercase\
    \ ? Character($0.lowercased()) : Character($0.uppercased()) : $0 }))", "    let\
    \ uppers = CharacterSet.uppercaseLetters\n    let lowers = CharacterSet.lowercaseLetters\n\
    \    return String(s.reversed().map {\n        switch ($0, lowers.contains($0),\
    \ uppers.contains($0)) {\n        case (_, true, _): return Character(String($0).uppercased())\n\
    \        case (_, _, true): return Character(String($0).lowercased())\n      \
    \  default: return $0\n        }\n    })", "    let containsLetter = s.contains\
    \ { $0.isLetter }\n    if containsLetter {\n        let letters = s.map { String($0)\
    \ }\n        let result = letters.map {\n            if $0.isLetter {\n      \
    \          if $0.lowercased() == $0 {\n                    return $0.uppercased()\n\
    \                } else {\n                    return $0.lowercased()\n      \
    \          }\n            } else {\n                return $0\n            }\n\
    \        }\n        return result.joined()\n    } else {\n        return String(s.reversed())\n\
    \    }", "    var newString = String()\n    let lowercased = Set(\"abcdefghijklmnopqrstuvwxyz\"\
    )\n    let uppercased = Set(\"ABCDEFGHIJKLMNOPQRSTUVWXYZ\")\n    for char in s\
    \ {\n        if lowercased.contains(char) {\n            newString.append(char.uppercased())\n\
    \        } else if uppercased.contains(char) {\n            newString.append(char.lowercased())\n\
    \        } else {\n            newString.append(char)\n        }\n    }\n    if\
    \ newString.contains(\"a\") || newString.contains(\"A\") {\n        return newString\n\
    \    } else {\n        var reverseString = String()\n        for char in newString\
    \ {\n            reverseString.insert(char, at: reverseString.startIndex)\n  \
    \      }\n        return reverseString\n    }", "    var reversed = \"\"\n   \
    \ for char in s {\n        if char.isLetter {\n            if char.isUppercase\
    \ {\n                reversed.append(char.lowercased())\n            } else {\n\
    \                reversed.append(char.uppercased())\n            }\n        }\
    \ else {\n            reversed.append(char)\n        }\n    }\n    return reversed.isEmpty\
    \ ? s.reversed() : reversed", '  // your code', "    var arr = Array(s)\n    for\
    \ i in 0..<arr.count {\n        if arr[i].isLetter {\n            if arr[i].isUppercase\
    \ {\n                arr[i] = Character(arr[i].lowercased())\n            } else\
    \ {\n                arr[i] = Character(arr[i].uppercased())\n            }\n\
    \        }\n    }\n    return String(arr)", "    var result = s\n    let nonLetterChars\
    \ = CharacterSet.letters.inverted\n    let lettersArray = s.components(separatedBy:\
    \ nonLetterChars)\n    if lettersArray.count == 0 {\n        return String(s.reversed())\n\
    \    }\n    let letterSet = CharacterSet.letters\n    var i = 0\n    for letter\
    \ in s {\n        if letterSet.contains(letter.unicodeScalars.first!) {\n    \
    \        if let index = result.index(of: letter) {\n                result.replaceSubrange(index...index,\
    \ with: String(letter).lowercased())\n            }\n            if let index\
    \ = result.index(of: lettersArray[i].lowercased()) {\n                result.replaceSubrange(index...index,\
    \ with: String(lettersArray[i].lowercased()).uppercased())\n            }\n  \
    \          i += 1\n        }\n    }\n    return result", "    let temp = s.isEmpty\
    \ ? \"\" : s.filter({ $0.isLetter }).count == 0 ? String(s.reversed()) : s.map({\
    \ $0.isLetter ? $0.isUppercase ? $0.lowercased() : $0.uppercased() : $0 })\n \
    \   return String(temp)", "    var str: String = \"\"\n    let set = NSCharacterSet.letters\n\
    \    for c in s {\n        if set.contains(UnicodeScalar(String(c))!) {\n    \
    \        if c.isUppercase {\n                str.append(c.lowercased())\n    \
    \        } else {\n                str.append(c.uppercased())\n            }\n\
    \        } else {\n            str.append(c)\n        }\n    }\n    if str.count\
    \ == 0 {\n        str = String(s.reversed())\n    }\n    return str", "  var newS\
    \ = \"\"\n  for letter in s {\n    if letter.isLetter {\n      newS.append(letter.isLowercase\
    \ ? String(letter).uppercased() : String(letter).lowercased())\n    } else {\n\
    \      newS.append(letter)\n    }\n  }\n  return newS.isEmpty ? String(s.reversed())\
    \ : newS", "    var result = \"\"\n    for c in s {\n        if c.isLetter {\n\
    \            result.append(c.isLowercase ? c.uppercased() : c.lowercased())\n\
    \        } else {\n            result.append(c)\n        }\n    }\n    return\
    \ result.isEmpty ? String(s.reversed()) : result", '    return s.isEmpty ? s :
    String(s.compactMap { $0.isLetter ? $0.isUppercase ? $0.lowercased() : $0.uppercased()
    : $0 })', "\tlet letters = CharacterSet.letters\n\tvar string = s\n\tfor character\
    \ in string.characters {\n\t\tif letters.contains(UnicodeScalar(String(character))!)\
    \ {\n\t\t\tif String(character) == String(character).lowercased() {\n\t\t\t\t\
    string = string.replacingOccurrences(of: String(character), with: String(character).uppercased())\n\
    \t\t\t} else {\n\t\t\t\tstring = string.replacingOccurrences(of: String(character),\
    \ with: String(character).lowercased())\n\t\t\t}\n\t\t}\n\t}\n\tif string.characters.contains(where:\
    \ { letters.contains(UnicodeScalar(String($0))!) }) {\n\t\treturn string\n\t}\
    \ else {\n\t\treturn String(string.characters.reversed())\n\t}", "    if s.isEmpty\
    \ {\n        return s\n    }\n    var str = \"\"\n    for i in s {\n        if\
    \ i.isLetter {\n            str += String(i.lowercased() == String(i) ? i.uppercased()\
    \ : i.lowercased())\n        } else {\n            str += String(i)\n        }\n\
    \    }\n    return str", "    if s.isEmpty {\n        return \"\"\n    }\n   \
    \ var temp = [Character]()\n    for item in s {\n        if item.isLetter {\n\
    \            if item.isUppercase {\n                temp.append(item.lowercased())\n\
    \            } else {\n                temp.append(item.uppercased())\n      \
    \      }\n        } else {\n            temp.append(item)\n        }\n    }\n\
    \    if temp.isEmpty {\n        return String(s.reversed())\n    }\n    return\
    \ String(temp)", '    return ""', "    let reversed = s.reversed()\n    var result\
    \ = \"\"\n    for letter in reversed {\n        if letter.isLetter {\n       \
    \     result.append(letter.lowercased())\n        } else {\n            result.append(letter)\n\
    \        }\n    }\n    return result", "    var s = s\n    var i = 0\n    while\
    \ i < s.count {\n        let c = s[s.index(s.startIndex, offsetBy: i)]\n     \
    \   if isLetter(c) {\n            let j = s.index(s.startIndex, offsetBy: i)\n\
    \            s.replaceSubrange(j...j, with: String(c).lowercased())\n        }\n\
    \        i += 1\n    }\n    return s", "    // your code goes here\n    let str\
    \ = Array(s)\n    var output = \"\"\n    var isLetterExist = false\n    for c\
    \ in str {\n        if let ch = c.lowercased().first {\n            isLetterExist\
    \ = true\n            if (ch >= \"a\" && ch <= \"z\") {\n                output.append(String(ch).uppercased())\n\
    \            } else {\n                output.append(String(ch).lowercased())\n\
    \            }\n        } else {\n            output.append(c)\n        }\n  \
    \  }\n    if !isLetterExist {\n        output = String(output.reversed())\n  \
    \  }\n    return output", "    let uppers = Set(\"ABCDEFGHIJKLMNOPQRSTUVWXYZ\"\
    )\n    let lowers = Set(\"abcdefghijklmnopqrstuvwxyz\")\n    var result = \"\"\
    \n    for c in s {\n        result += uppers.contains(c) ? String(c).lowercased()\
    \ :\n            lowers.contains(c) ? String(c).uppercased() : String(c)\n   \
    \ }\n    return result", "    guard s.contains(\"[a-zA-Z]\") else { return String(s.reversed())\
    \ }\n    return s.components(separatedBy: .whitespaces).map { $0.components(separatedBy:\
    \ .punctuationCharacters).compactMap { $0.rangeOfCharacter(from: .letters) !=\
    \ nil ? String($0.reversed()) : nil }.joined() }.joined(separator: \" \")", " \
    \   guard s.count != 0 else { return s }\n    var solution = \"\"\n    for char\
    \ in s {\n        if char.isLetter {\n            solution.append(char.isUppercase\
    \ ? char.lowercased() : char.uppercased())\n        } else {\n            solution.append(char)\n\
    \        }\n    }\n    return s.containsLetters() ? solution : String(solution.reversed())",
  "    guard s.contains(where: { \"a\"...\"z\" ~= $0 || \"A\"...\"Z\" ~= $0 }) else\
    \ {\n        return String(s.reversed())\n    }\n    return String(s.map { $0.isLowercase\
    \ ? $0.uppercased() : $0.lowercased() })", "    if s.count > 0 {\n        var\
    \ newString = \"\"\n        let chars = Array(s)\n        for i in 0..<chars.count\
    \ {\n            let character = String(chars[i])\n            if character ==\
    \ character.uppercased() {\n                newString.append(character.lowercased())\n\
    \            } else if character == character.lowercased() {\n               \
    \ newString.append(character.uppercased())\n            } else {\n           \
    \     newString.append(character)\n            }\n        }\n        return newString\n\
    \    } else {\n        return String(s.reversed())\n    }", "    var res = \"\"\
    \n    for item in s {\n        if item >= \"a\" && item <= \"z\" {\n         \
    \   res += \"\\(item)\".uppercased()\n        } else if item >= \"A\" && item\
    \ <= \"Z\" {\n            res += \"\\(item)\".lowercased()\n        } else {\n\
    \            res += \"\\(item)\"\n        }\n    }\n    return s.rangeOfCharacter(from:\
    \ CharacterSet.letters) == nil ? String(res.reversed()) : res", "    if s.contains(\"\
    a\") || s.contains(\"A\") {\n        return String(s.reversed()).capitalized\n\
    \    } else {\n        return String(s.reversed())\n    }", "    var result =\
    \ \"\"\n    for c in s {\n        if (c >= \"a\" && c <= \"z\") || (c >= \"A\"\
    \ && c <= \"Z\") {\n            result.append(c.lowercased() == c ? c.uppercased()\
    \ : c.lowercased())\n        } else {\n            result.append(c)\n        }\n\
    \    }\n    return result.isEmpty ? String(s.reversed()) : result", "\tvar result\
    \ = String()\n\tfor char in s {\n\t\tlet c = CharacterSet.letters\n\t\tif c.contains(char.unicodeScalars.first!)\
    \ {\n\t\t\tif (char == char.uppercased()) {\n\t\t\t\tresult.append(char.lowercased())\n\
    \t\t\t} else {\n\t\t\t\tresult.append(char.uppercased())\n\t\t\t}\n\t\t} else\
    \ {\n\t\t\tresult.append(char)\n\t\t}\n\t}\n\tif result.count == 0 {\n\t\treturn\
    \ String(s.reversed())\n\t}\n\treturn result", "    var str = \"\"\n    for (_,\
    \ char) in s.enumerated() {\n        if char.isUppercase {\n            str.append(char.lowercased())\n\
    \        } else if char.isLowercase {\n            str.append(char.uppercased())\n\
    \        } else {\n            str.append(char)\n        }\n    }\n    return\
    \ str", "    let flag = Set(\"abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ\"\
    )\n    var result = \"\"\n    var letters = \"\"\n    for c in s {\n        if\
    \ flag.contains(c) {\n            letters += String(c)\n        } else {\n   \
    \         result += String(c)\n        }\n    }\n    if letters.isEmpty {\n  \
    \      return String(result.reversed())\n    }\n    for c in letters {\n     \
    \   if String(c).uppercased() == String(c) {\n            result += String(c).lowercased()\n\
    \        } else {\n            result += String(c).uppercased()\n        }\n \
    \   }\n    return result", '    return ""', "    var letters = [Character]()\n\
    \    for char in s {\n        letters.append(char)\n    }\n    for i in 0..<letters.count\
    \ {\n        if letters[i].isLetter {\n            letters[i].switchCase()\n \
    \       }\n    }\n    return letters.isEmpty ? String(letters.reversed()) : String(letters)",
  "    guard s.count > 0 else { return s }\n    var output = String()\n    for character\
    \ in s {\n        let scalars = String(character).unicodeScalars\n        let\
    \ value = scalars[scalars.startIndex].value\n        if (value > 90 && value <\
    \ 123) || (value > 64 && value < 91) {\n            output.append(Character(unicodeScalar:\
    \ scalars[scalars.startIndex].value ^^ 0x20))\n        } else {\n            output.append(character)\n\
    \        }\n    }\n    return output", "    if s.contains(\"a\") || s.contains(\"\
    A\") || s.contains(\"e\") || s.contains(\"E\") || s.contains(\"i\") || s.contains(\"\
    I\") || s.contains(\"o\") || s.contains(\"O\") || s.contains(\"u\") || s.contains(\"\
    U\"){\n        var result = \"\"\n        for i in s{\n            if i == \"\
    a\" || i == \"e\" || i == \"i\" || i == \"o\" || i == \"u\" {\n              \
    \  result.append(String(i).uppercased())\n            } else if i == \"A\" ||\
    \ i == \"E\" || i == \"I\" || i == \"O\" || i == \"U\" {\n                result.append(String(i).lowercased())\n\
    \            } else {\n                result.append(i)\n            }\n     \
    \   }\n        return result\n    } else {\n        var result = \"\"\n      \
    \  for i in s.reversed(){\n            result.append(i)\n        }\n        return\
    \ result\n    }", "    var result = \"\"\n    let alphabet = \"ABCDEFGHIJKLMNOPQRSTUVWXYZ\"\
    \n    let lowercase = \"abcdefghijklmnopqrstuvwxyz\"\n    for char in s {\n  \
    \      if alphabet.contains(char) {\n            let index = alphabet.firstIndex(of:\
    \ char)!\n            result.append(lowercase[index])\n        } else if lowercase.contains(char)\
    \ {\n            let index = lowercase.firstIndex(of: char)!\n            result.append(alphabet[index])\n\
    \        } else {\n            result.append(char)\n        }\n    }\n    return\
    \ result.isEmpty ? s.reversed() : result", '    // your code goes here', "   \
    \ var newStr = \"\"\n    if s.rangeOfCharacter(from: CharacterSet.letters) ==\
    \ nil {\n        return String(s.reversed())\n    }\n    for letter in s {\n \
    \       if CharacterSet.lowercaseLetters.contains(letter.unicodeScalars.first!)\
    \ {\n            newStr.append(letter.uppercased())\n        } else if CharacterSet.uppercaseLetters.contains(letter.unicodeScalars.first!)\
    \ {\n            newStr.append(letter.lowercased())\n        } else {\n      \
    \      newStr.append(letter)\n        }\n    }\n    return newStr", "    if s.isEmpty\
    \ {\n        return s\n    }\n    let arr = s.map { String($0) }\n    var flag\
    \ = false\n    for i in 0..<arr.count {\n        if arr[i].isLetter {\n      \
    \      flag = true\n            break\n        }\n    }\n    if flag {\n     \
    \   for i in 0..<arr.count {\n            if arr[i].isLetter {\n             \
    \   arr[i] = String(arr[i].lowercased().first!)\n            }\n        }\n  \
    \  }\n    var ans = \"\"\n    for i in stride(from: arr.count - 1, through: 0,\
    \ by: -1) {\n        ans += arr[i]\n    }\n    return ans", "    var output =\
    \ \"\"\n    let isLetter = s.rangeOfCharacter(from: .letters)\n    let isUpper\
    \ = s.rangeOfCharacter(from: .uppercaseLetters)\n    let isLower = s.rangeOfCharacter(from:\
    \ .lowercaseLetters)\n    for element in s {\n        if isLetter != nil {\n \
    \           if isUpper != nil && isLower != nil {\n                output.append(element.lowercased())\n\
    \            } else {\n                output.append(element.uppercased())\n \
    \           }\n        } else {\n            output.append(String(element.asciiValue!))\n\
    \        }\n    }\n    return String(output.reversed())", "    if !(s.contains(where:\
    \ { $0.isLetter })) {\n        return String(s.reversed())\n    }\n    return\
    \ String(s.map { $0.isLetter ? $0.isUppercase ? Character($0.lowercased()) : Character($0.uppercased())\
    \ : $0 })", "    let chars = Array(s)\n    var result = \"\"\n    var hasLetter\
    \ = false\n    for char in chars {\n        if char.isLetter {\n            hasLetter\
    \ = true\n            result.append(char.isLowercase ? Character(char.uppercased())\
    \ : Character(char.lowercased()))\n        } else {\n            result.append(char)\n\
    \        }\n    }\n    return hasLetter ? result : String(result.reversed())",
  "    var new = \"\"\n    for character in s {\n        switch character {\n    \
    \    case \"a\"...\"z\":\n            new.append(character.uppercased())\n   \
    \     case \"A\"...\"Z\":\n            new.append(character.lowercased())\n  \
    \      default:\n            new.append(character)\n        }\n    }\n    return\
    \ new.isEmpty ? s.reversed() : new", "    let lower = \"abcdefghijklmnopqrstuvwxyz\"\
    \n    let upper = \"ABCDEFGHIJKLMNOPQRSTUVWXYZ\"\n    var newString = \"\"\n \
    \   for c in s {\n        if lower.contains(c) {\n            newString.append(c.uppercased())\n\
    \        } else if upper.contains(c) {\n            newString.append(c.lowercased())\n\
    \        } else {\n            newString.append(c)\n        }\n    }\n    if newString.isEmpty\
    \ {\n        return String(s.reversed())\n    }\n    return newString", '    return
    "";', "\treturn s.contains(where: { $0.isLetter }) ? String(s.map({ $0.isLowercase\
    \ ? Character($0.uppercased()) : Character($0.lowercased()) })) : String(s.reversed())",
  "  if s.isEmpty { return s }\n  var tmp = \"\"\n  for char in s {\n    if char.isLetter\
    \ {\n      tmp.append(char.isUppercase ? char.lowercased() : char.uppercased())\n\
    \    } else {\n      tmp.append(char)\n    }\n  }\n  return s.isAllLetters ? String(tmp.reversed())\
    \ : tmp", "    var result = \"\"\n    if s.first(where: { $0.isLetter }) == nil\
    \ {\n        for i in stride(from: s.count - 1, through: 0, by: -1) {\n      \
    \      result.append(s[s.index(s.startIndex, offsetBy: i)])\n        }\n    }\
    \ else {\n        for i in s {\n            if i.isLetter {\n                result.append(i.isLowercase\
    \ ? i.uppercased() : i.lowercased())\n            } else {\n                result.append(i)\n\
    \            }\n        }\n    }\n    return result", "    if s.contains(\"a\"\
    ) || s.contains(\"b\") || s.contains(\"c\") || s.contains(\"d\") || s.contains(\"\
    e\") || s.contains(\"f\") || s.contains(\"g\") || s.contains(\"h\") || s.contains(\"\
    i\") || s.contains(\"j\") || s.contains(\"k\") || s.contains(\"l\") || s.contains(\"\
    m\") || s.contains(\"n\") || s.contains(\"o\") || s.contains(\"p\") || s.contains(\"\
    q\") || s.contains(\"r\") || s.contains(\"s\") || s.contains(\"t\") || s.contains(\"\
    u\") || s.contains(\"v\") || s.contains(\"w\") || s.contains(\"x\") || s.contains(\"\
    y\") || s.contains(\"z\") {\n        return String(s.map{ $0.isUppercase ? $0.lowercased()\
    \ : $0.uppercased() })\n    } else {\n        return String(s.reversed())\n  \
    \  }", "    guard s.contains(where: { $0.isLetter }) else {\n        return String(s.reversed())\n\
    \    }\n    return String(s.map { (ch) -> Character in\n        guard ch.isLetter\
    \ else {\n            return ch\n        }\n        return ch.isUppercase ? ch.lowercased().first!\
    \ : ch.uppercased().first!\n    })", "    var result = \"\"\n    for item in s\
    \ {\n        if item.isLetter {\n            result.append(item.isLowercase ?\
    \ item.uppercased() : item.lowercased())\n        } else {\n            result.append(item)\n\
    \        }\n    }\n    return result.isEmpty ? String(s.reversed()) : result",
  "    if s.rangeOfCharacter(from: CharacterSet.letters) == nil {\n        return\
    \ String(s.reversed())\n    }\n    var result = \"\"\n    for c in s {\n     \
    \   let charSet = CharacterSet.init(charactersIn: c.lowercased())\n        if\
    \ charSet.isSubset(of: CharacterSet.letters) {\n            result += (c.lowercased()\
    \ == c) ? c.uppercased() : c.lowercased()\n        } else {\n            result\
    \ += String(c)\n        }\n    }\n    return result", "    if s.rangeOfCharacter(from:\
    \ CharacterSet.letters) == nil {\n        return String(s.reversed())\n    }\n\
    \    var res = \"\"\n    for char in s {\n        if char.isLetter {\n       \
    \     if char.isUppercase {\n                res.append(char.lowercased())\n \
    \           } else {\n                res.append(char.uppercased())\n        \
    \    }\n        } else {\n            res.append(char)\n        }\n    }\n   \
    \ return res", "    if s.lowercased() == s {\n        return s.uppercased()\n\
    \    } else if s.uppercased() == s {\n        return s.lowercased()\n    } else\
    \ {\n        var rev = \"\"\n        for char in s {\n            if char.isLowercase\
    \ {\n                rev += String(char).uppercased()\n            } else if char.isUppercase\
    \ {\n                rev += String(char).lowercased()\n            } else {\n\
    \                rev += String(char)\n            }\n        }\n        return\
    \ rev\n    }", "    var result = \"\"\n    if !s.contains(\"a\"...\"z\") && !s.contains(\"\
    A\"...\"Z\") {\n        for (index, element) in s.reversed().enumerated() {\n\
    \            result.append(element)\n        }\n    } else {\n        for (index,\
    \ element) in s.enumerated() {\n            if element.isLetter {\n          \
    \      if element.isLowercase {\n                    result.append(element.uppercased())\n\
    \                } else {\n                    result.append(element.lowercased())\n\
    \                }\n            } else {\n                result.append(element)\n\
    \            }\n        }\n    }\n    return result", "    var result = \"\"\n\
    \    var hasLetter = false\n    for c in s {\n        if c.isLetter {\n      \
    \      hasLetter = true\n            result.append(c.isLowercase ? c.uppercased()\
    \ : c.lowercased())\n        } else {\n            result.append(c)\n        }\n\
    \    }\n    return hasLetter ? result : String(result.reversed())", "    var res\
    \ = String()\n    var rev = String()\n    var revs = String()\n    for i in s\
    \ {\n        if i.isLetter {\n            if i.isLowercase {\n               \
    \ res += String(i).uppercased()\n            } else {\n                res +=\
    \ String(i).lowercased()\n            }\n        } else {\n            res +=\
    \ String(i)\n        }\n    }\n    if res.isEmpty {\n        for i in s {\n  \
    \          rev = String(i) + rev\n        }\n        return rev\n    }\n    for\
    \ i in res {\n        revs = String(i) + revs\n    }\n    return revs", "    var\
    \ s = s\n    var letters = [Character]()\n    for c in s {\n        if c.isLetter\
    \ {\n            letters.append(c)\n        }\n    }\n    if letters.isEmpty {\n\
    \        return String(s.reversed())\n    }\n    var reversed = letters.reversed()\n\
    \    var idx = 0\n    for i in 0..<s.count {\n        let c = s[s.index(s.startIndex,\
    \ offsetBy: i)]\n        if c.isLetter {\n            s.replaceSubrange(s.index(s.startIndex,\
    \ offsetBy: i)...s.index(s.startIndex, offsetBy: i), with: \"\\(reversed[idx])\"\
    )\n            idx += 1\n        }\n    }\n    return s", "    var arr = [Character]()\n\
    \    var s = s\n    if s.containsAlphabets(){\n        for i in s.indices{\n \
    \           if s[i].isLetter {\n                arr.append(s[i].isUppercase ?\
    \ s[i].lowercased() : s[i].uppercased())\n            }else{\n               \
    \ arr.append(s[i])\n            }\n        }\n        return String(arr)\n   \
    \ }else{\n        return String(s.reversed())\n    }", "    let lower = CharacterSet.lowercaseLetters\n\
    \    let upper = CharacterSet.uppercaseLetters\n    var s = s\n    for i in s.indices\
    \ {\n        if lower.contains(s[i].unicodeScalars.first!) {\n            s.replaceSubrange(i...i,\
    \ with: String(s[i]).uppercased())\n        } else if upper.contains(s[i].unicodeScalars.first!)\
    \ {\n            s.replaceSubrange(i...i, with: String(s[i]).lowercased())\n \
    \       }\n    }\n    return s", "  var result = \"\"\n  let s = Array(s)\n  for\
    \ char in s {\n    if char.isLetter {\n      result.append(char.isUppercase ?\
    \ char.lowercased() : char.uppercased())\n    } else {\n      result.append(char)\n\
    \    }\n  }\n  return result.isEmpty ? String(s.reversed()) : result", "    var\
    \ res = \"\"\n    for item in s {\n        if item.isLetter {\n            if\
    \ item.isLowercase {\n                res.append(item.uppercased())\n        \
    \    } else {\n                res.append(item.lowercased())\n            }\n\
    \        } else {\n            res.append(item)\n        }\n    }\n    if res.isEmpty\
    \ {\n        return String(s.reversed())\n    }\n    return res", '    return
    s.allSatisfy({ $0.isLetter }) ? String(s.reversed()) : s.map({ $0.isLetter ? $0.isUppercase
    ? Character($0.lowercased()) : Character($0.uppercased()) : $0 }).joined()', " \
    \   let isUpper = { \"A\"...\"Z\" ~= $0 }\n    let isLower = { \"a\"...\"z\" ~=\
    \ $0 }\n    let hasLetters = s.contains(where: isUpper) || s.contains(where: isLower)\n\
    \    let chars = s.map { isUpper($0) ? Character($0.lowercased()) : isLower($0)\
    \ ? Character($0.uppercased()) : $0 }\n    return hasLetters ? String(chars) :\
    \ String(chars.reversed())", "  // Write your code here.\n  // I assume that the\
    \ input string contains only numbers, letters and symbols.\n  // I assume that\
    \ the symbols are not letters.\n  // I assume that the returned string should\
    \ not contain any symbols.\n  // I assume that the returned string should contain\
    \ only numbers and/or letters.\n  // I assume that the returned string should\
    \ not contain any spaces.\n  // I assume that the returned string should not contain\
    \ any symbols.\n  // I assume that the returned string should not contain any\
    \ numbers.\n  // I assume that the returned string should be in the same order\
    \ as the input string.\n  // I assume that the case of the returned string is\
    \ the same as the case of the input string.\n  let letters: [Character] = [\"\
    a\", \"b\", \"c\", \"d\", \"e\", \"f\", \"g\", \"h\", \"i\", \"j\", \"k\", \"\
    l\", \"m\", \"n\", \"o\", \"p\", \"q\", \"r\", \"s\", \"t\", \"u\", \"v\", \"\
    w\", \"x\", \"y\", \"z\"]\n  let uppercaseLetters: [Character] = [\"A\", \"B\"\
    , \"C\", \"D\", \"E\", \"F\", \"G\", \"H\", \"I\", \"J\", \"K\", \"L\", \"M\"\
    , \"N\", \"O\", \"P\", \"Q\", \"R\", \"S\", \"T\", \"U\", \"V\", \"W\", \"X\"\
    , \"Y\", \"Z\"]\n  let reverseLetters: [Character] = [\"z\", \"y\", \"x\", \"\
    w\", \"v\", \"u\", \"t\", \"s\", \"r\", \"q\", \"p\", \"o\", \"n\", \"m\", \"\
    l\", \"k\", \"j\", \"i\", \"h\", \"g\", \"f\", \"e\", \"d\", \"c\", \"b\", \"\
    a\"]\n  let reverseUppercaseLetters: [Character] = [\"Z\", \"Y\", \"X\", \"W\"\
    , \"V\", \"U\", \"T\", \"S\", \"R\", \"Q\", \"P\", \"O\", \"N\", \"M\", \"L\"\
    , \"K\", \"J\", \"I\", \"H\", \"G\", \"F\", \"E\", \"D\", \"C\", \"", "    guard\
    \ s.contains(where: { $0.isLetter }) else {\n        return String(s.reversed())\n\
    \    }\n    var res = String()\n    for char in s {\n        if char.isLetter\
    \ {\n            res.append(char.isUppercase ? char.lowercased() : char.uppercased())\n\
    \        } else {\n            res.append(char)\n        }\n    }\n    return\
    \ res", "    if !s.containsLetter {\n        return String(s.reversed())\n   \
    \ }\n    var result = \"\"\n    for c in s {\n        if c.isLetter {\n      \
    \      result.append(c.isUppercase ? c.lowercased() : c.uppercased())\n      \
    \  } else {\n            result.append(c)\n        }\n    }\n    return result",
  "\treturn s.filter { $0.isLetter }.isEmpty ? String(s.reversed()) : s.map { $0.isLetter\
    \ ? $0.isUppercase ? Character($0.lowercased()) : Character($0.uppercased()) :\
    \ $0 }.joined()", '    return s.replacingOccurrences(of: "[a-zA-Z]", with: "$0".uppercased(),
    options: .regularExpression)', "    let letters = s.filter { $0.isLetter }\n \
    \   guard !letters.isEmpty else { return String(s.reversed()) }\n    return s.map\
    \ { $0.isLetter ? $0.toggled() : $0 }", "  let letters: Set<Character> = [\"a\"\
    , \"b\", \"c\", \"d\", \"e\", \"f\", \"g\", \"h\", \"i\", \"j\", \"k\", \"l\"\
    , \"m\", \"n\", \"o\", \"p\", \"q\", \"r\", \"s\", \"t\", \"u\", \"v\", \"w\"\
    , \"x\", \"y\", \"z\"]\n  var result = \"\"\n  for letter in s {\n    if letters.contains(letter)\
    \ {\n      if letter.uppercased() == letter {\n        result.append(letter.lowercased())\n\
    \      } else {\n        result.append(letter.uppercased())\n      }\n    } else\
    \ {\n      result.append(letter)\n    }\n  }\n  if result.count == 0 {\n    return\
    \ String(s.reversed())\n  }\n  return result", "    return s.isEmpty || !s.contains(where:\
    \ { $0.isLetter }) ? String(s.reversed()) : String(s.map {\n        $0.isLetter\
    \ ? $0.isUppercase ? Character($0.lowercased()) : Character($0.uppercased()) :\
    \ $0\n    })", "    var result = \"\"\n    for char in s {\n        if let unicode\
    \ = UnicodeScalar(String(char)) {\n            if CharacterSet.letters.contains(unicode)\
    \ {\n                if char.isUppercase {\n                    result.append(char.lowercased())\n\
    \                } else {\n                    result.append(char.uppercased())\n\
    \                }\n            } else {\n                result.append(char)\n\
    \            }\n        }\n    }\n    return result.count == 0 ? String(s.reversed())\
    \ : result", "    guard s.rangeOfCharacter(from: CharacterSet.letters) != nil\
    \ else {\n        return String(s.reversed())\n    }\n    var x = Array(s)\n \
    \   for i in 0..<x.count {\n        if CharacterSet.letters.contains(x[i].unicodeScalars.first!)\
    \ {\n            if x[i].lowercased() == x[i] {\n                x[i] = Character(x[i].uppercased())\n\
    \            } else {\n                x[i] = Character(x[i].lowercased())\n \
    \           }\n        }\n    }\n    return String(x)", "    return s.reduce(\"\
    \") { (a, b) in\n        guard CharacterSet.letters.contains(b.unicodeScalars.first!)\
    \ else {\n            return a + String(b)\n        }\n        return a + String(b.unicodeScalars.first!.value\
    \ < 97 ? Character(UnicodeScalar(b.unicodeScalars.first!.value + 32)!) : Character(UnicodeScalar(b.unicodeScalars.first!.value\
    \ - 32)!))\n    }", "    let letters = s.filter { $0.isLetter }\n    if letters.isEmpty\
    \ {\n        return String(s.reversed())\n    }\n    return String(letters.reversed().map\
    \ { $0.isUppercase ? $0.lowercased() : $0.uppercased() })", "    //if(s.count\
    \ == 0) {return s}\n    var result: String = \"\"\n    var temp: String = \"\"\
    \n    for ch in s {\n        if ch.isLetter {\n            temp = String(ch)\n\
    \            result += String(temp.lowercased().reversed())\n        } else {\n\
    \            result += String(ch)\n        }\n    }\n    if(s.count == 0) {return\
    \ result.reversed()}\n    return result", "    guard !s.isEmpty else { return\
    \ \"\" }\n    var result = \"\"\n    for char in s {\n        if char.isLetter\
    \ {\n            result.append(char.isUppercase ? char.lowercased() : char.uppercased())\n\
    \        } else {\n            result.append(char)\n        }\n    }\n    if result.isEmpty\
    \ {\n        return String(s.reversed())\n    }\n    return result", "  guard\
    \ !s.isEmpty else { return \"\" }\n  var revStr = String()\n  let chars = s.map\
    \ { String($0) }\n  for i in 0..<chars.count {\n    guard chars[i].rangeOfCharacter(from:\
    \ CharacterSet.letters) != nil else {\n      revStr.append(chars[i])\n      continue\n\
    \    }\n    revStr.append(chars[i].uppercased() == chars[i] ? chars[i].lowercased()\
    \ : chars[i].uppercased())\n  }\n  return revStr", "    var result = s\n    for\
    \ i in s.indices {\n        if s[i].isLetter {\n            result.replaceSubrange(i...i,\
    \ with: String(s[i].isUppercase ? s[i].lowercased() : s[i].uppercased()))\n  \
    \      }\n    }\n    return result.reversed()", '    return ""', "\t\n\tvar result\
    \ = \"\"\n\tlet upper = \"ABCDEFGHIJKLMNOPQRSTUVWXYZ\"\n\tlet lower = \"abcdefghijklmnopqrstuvwxyz\"\
    \n\t\n\tif s.rangeOfCharacter(from: .letters) == nil {\n\t\tfor c in s.reversed()\
    \ {\n\t\t\tresult.append(c)\n\t\t}\n\t} else {\n\t\tfor c in s {\n\t\t\tif let\
    \ index = upper.firstIndex(of: c) {\n\t\t\t\tresult.append(lower[index])\n\t\t\
    \t} else if let index = lower.firstIndex(of: c) {\n\t\t\t\tresult.append(upper[index])\n\
    \t\t\t} else {\n\t\t\t\tresult.append(c)\n\t\t\t}\n\t\t}\n\t}\n\t\n\treturn result",
  "\tvar result = \"\"\n\tfor char in s {\n\t\tif isalpha(char) {\n\t\t\tif isupper(char)\
    \ {\n\t\t\t\tresult.append(char.lowercased())\n\t\t\t} else {\n\t\t\t\tresult.append(char.uppercased())\n\
    \t\t\t}\n\t\t} else {\n\t\t\tresult.append(char)\n\t\t}\n\t}\n\tif isDigit(s:\
    \ result) {\n\t\treturn String(result.reversed())\n\t}\n\treturn result", "  \
    \  guard !s.isEmpty else { return s }\n    guard s.rangeOfCharacter(from: CharacterSet.letters)\
    \ != nil else { return String(s.reversed()) }\n    return String(s.map { character\
    \ -> Character in\n        guard let ascii = character.asciiValue else { return\
    \ character }\n        if ascii >= 65 && ascii <= 90 { return Character(UnicodeScalar(ascii\
    \ + 32)!) }\n        if ascii >= 97 && ascii <= 122 { return Character(UnicodeScalar(ascii\
    \ - 32)!) }\n        return character\n    })", '    return ""', "    guard s.isLetter\
    \ else {\n        return String(s.reversed())\n    }\n    var result = \"\"\n\
    \    for char in s {\n        if char.isLetter {\n            result += String(char.isUppercase\
    \ ? char.lowercased() : char.uppercased())\n        } else {\n            result\
    \ += String(char)\n        }\n    }\n    return result", '    return String(s.map{$0.isLetter
    ? ($0.isLowercase ? Character($0.uppercased()) : Character($0.lowercased())) :
    $0})', '    return s.isEmpty ? s : s.map{ $0.isLetter ? $0.isUppercase ? $0.lowercased()
    : $0.uppercased() : $0 }.joined()', "    var reversed = \"\"\n    for ch in s\
    \ {\n        switch ch {\n        case \"a\"...\"z\":\n            reversed.append(ch.uppercased())\n\
    \        case \"A\"...\"Z\":\n            reversed.append(ch.lowercased())\n \
    \       default:\n            reversed.append(ch)\n        }\n    }\n    return\
    \ String(reversed.reversed())", "  var s = s\n  let l = s.filter { $0.isLetter\
    \ }\n  if l.isEmpty {\n    s = String(s.reversed())\n  } else {\n    for (i, c)\
    \ in s.enumerated() {\n      if c.isLetter {\n        let ns = c.isLowercase ?\
    \ c.uppercased() : c.lowercased()\n        s.replaceSubrange(i...i, with: ns)\n\
    \      }\n    }\n  }\n  return s", "    let letters = CharacterSet.letters\n \
    \   let digits = CharacterSet.decimalDigits\n    var result = \"\"\n    for c\
    \ in s {\n        if let _ = String(c).rangeOfCharacter(from: letters) {\n   \
    \         if let _ = String(c).rangeOfCharacter(from: digits) {\n            \
    \    result.append(c)\n            } else {\n                result.append(c.isUppercase\
    \ ? c.lowercased() : c.uppercased())\n            }\n        } else {\n      \
    \      result.append(c)\n        }\n    }\n    return result.isEmpty ? s : String(result.reversed())",
  "    var result = String()\n    var count = 0\n    for ch in s {\n        if ch.isLetter\
    \ {\n            if ch.isLowercase {\n                result.append(ch.uppercased())\n\
    \            } else {\n                result.append(ch.lowercased())\n      \
    \      }\n        } else {\n            result.append(ch)\n        }\n       \
    \ count += 1\n    }\n    if count == 0 {\n        return String(s.reversed())\n\
    \    }\n    return result", "    var newString = String()\n    let letters = s.characters.filter\
    \ { String($0).rangeOfCharacter(from: CharacterSet.letters) != nil }\n    if letters.count\
    \ > 0 {\n        newString = s.characters.map {\n            if String($0).rangeOfCharacter(from:\
    \ CharacterSet.letters) != nil {\n                if String($0).lowercased() ==\
    \ String($0) {\n                    return Character(String($0).uppercased())\n\
    \                } else {\n                    return Character(String($0).lowercased())\n\
    \                }\n            } else {\n                return $0\n        \
    \    }\n        }.map { String($0) }.joined()\n    } else {\n        newString\
    \ = String(s.characters.reversed())\n    }\n    return newString", "    let letters\
    \ = s.filter({ $0.isLetter })\n    if letters.isEmpty {\n        return String(s.reversed())\n\
    \    }\n    var result = \"\"\n    for char in s {\n        if char.isLetter {\n\
    \            if let newChar = char.switchedCase() {\n                result.append(newChar)\n\
    \            }\n        } else {\n            result.append(char)\n        }\n\
    \    }\n    return result", "  var result = \"\"\n  for char in s {\n    if char.isLetter\
    \ {\n      result.append(char.isUppercase ? char.lowercased() : char.uppercased())\n\
    \    } else {\n      result.append(char)\n    }\n  }\n  return result.isEmpty\
    \ ? String(s.reversed()) : result", '    return s.contains("[a-zA-Z]") ? String(s.reversed())
    : String(s.lowercased().reversed().map({$0 == "#" ? "0" : $0 == "@" ? "0" : $0
    == "a" ? "A" : $0 == "b" ? "B" : $0 == "c" ? "C" : $0 == "d" ? "D" : $0 == "e"
    ? "E" : $0 == "f" ? "F" : $0 == "g" ? "G" : $0 == "h" ? "H" : $0 == "i" ? "I"
    : $0 == "j" ? "J" : $0 == "k" ? "K" : $0 == "l" ? "L" : $0 == "m" ? "M" : $0 ==
    "n" ? "N" : $0 == "o" ? "O" : $0 == "p" ? "P" : $0 == "q" ? "Q" : $0 == "r" ?
    "R" : $0 == "s" ? "S" : $0 == "t" ? "T" : $0 == "u" ? "U" : $0 == "v" ? "V" :
    $0 == "w" ? "W" : $0 == "x" ? "X" : $0 == "y" ? "Y" : $0 == "z" ? "Z" : $0}))',
  "  var s = Array(s)\n  var index = 0\n  while index < s.count {\n    if s[index].isLetter\
    \ {\n      s[index].toggle()\n    }\n    index += 1\n  }\n  return String(s)",
  "    var str = \"\"\n    var flag = false\n    for i in s {\n        if i.isLetter\
    \ {\n            flag = true\n            if i.lowercased() == i {\n         \
    \       str.append(i.uppercased())\n            } else {\n                str.append(i.lowercased())\n\
    \            }\n        } else {\n            str.append(i)\n        }\n    }\n\
    \    if flag {\n        return str\n    } else {\n        return String(str.reversed())\n\
    \    }", "    var letters = [Character]()\n    var nonLetters = [Character]()\n\
    \    var string = \"\"\n    var result = \"\"\n    for char in s {\n        if\
    \ char.isLetter {\n            letters.append(char)\n        } else {\n      \
    \      nonLetters.append(char)\n        }\n    }\n    if letters.count == 0 {\n\
    \        for char in s {\n            result += String(char)\n        }\n    \
    \    return String(result.reversed())\n    }\n    for char in letters {\n    \
    \    if char.isUppercase {\n            string += String(char.lowercased())\n\
    \        } else {\n            string += String(char.uppercased())\n        }\n\
    \    }\n    var i = 0\n    var j = 0\n    for char in s {\n        if char.isLetter\
    \ {\n            result += String(string[string.index(string.startIndex, offsetBy:\
    \ i)])\n            i += 1\n        } else {\n            result += String(nonLetters[j])\n\
    \            j += 1\n        }\n    }\n    return result", "    guard !s.isEmpty\
    \ else { return s }\n    let upperLetters = s.filter { $0.isLetter && $0.isUppercase\
    \ }\n    guard !upperLetters.isEmpty else { return String(s.reversed()) }\n  \
    \  return String(s.reversed().map { $0.isLetter ? ($0.isUppercase ? $0.lowercased()\
    \ : $0.uppercased()) : $0 })", "    let strArray = Array(s)\n    var result: String\
    \ = \"\"\n    var hasLetter = false\n    for c in strArray {\n        if c.isLetter\
    \ {\n            hasLetter = true\n            if c.isLowercase {\n          \
    \      result.append(c.uppercased())\n            } else {\n                result.append(c.lowercased())\n\
    \            }\n        } else {\n            result.append(c)\n        }\n  \
    \  }\n    if !hasLetter {\n        result = String(result.reversed())\n    }\n\
    \    return result", "\tvar newString = \"\"\n\tfor char in s {\n\t\tvar newChar\
    \ = char\n\t\tlet oldValue = char.asciiValue\n\t\tif oldValue != nil {\n\t\t\t\
    let newValue = oldValue! + 32\n\t\t\tnewChar = Character(UnicodeScalar(newValue)!)\n\
    \t\t}\n\t\tnewString.append(newChar)\n\t}\n\treturn newString", "    var result\
    \ = \"\"\n    var reversed = \"\"\n    for char in s {\n        let charString\
    \ = String(char)\n        if charString.lowercased() == charString.uppercased()\
    \ {\n            reversed += charString\n        } else {\n            result\
    \ += charString\n        }\n    }\n    return result.count == 0 ? String(reversed.reversed())\
    \ : result.reversed()", "    var str = \"\"\n    for i in s {\n        switch\
    \ i {\n        case \"a\"...\"z\":\n            str.append(i.uppercased())\n \
    \       case \"A\"...\"Z\":\n            str.append(i.lowercased())\n        default:\n\
    \            str.append(i)\n        }\n    }\n    return str.count > 0 ? str :\
    \ String(s.reversed())", '    return s.contains { $0.isLetter } ? String(s.map
    { $0.isLetter ? $0.isUppercase ? Character($0.lowercased()) : Character($0.uppercased())
    : $0 }) : String(s.reversed())', "    guard s.rangeOfCharacter(from: CharacterSet.letters)\
    \ != nil else {\n        return String(s.reversed())\n    }\n    var result =\
    \ \"\"\n    for ch in s {\n        if ch.isLetter {\n            result.append(ch.isUppercase\
    \ ? Character(ch.lowercased()) : Character(ch.uppercased()))\n        } else {\n\
    \            result.append(ch)\n        }\n    }\n    return result", '    return
    ""', "  if s.containsAny(from: .letters) {\n    return s.map { $0.isLetter ? $0.changeCase()\
    \ : $0 }.joined()\n  } else {\n    return String(s.reversed())\n  }", "    let\
    \ letters = Set(\"abcdefghijklmnopqrstuvwxyz\".uppercased())\n    let numbers\
    \ = Set(\"0123456789\")\n    var result = \"\"\n    var reverse = false\n    for\
    \ c in s {\n        if letters.contains(c) {\n            reverse = true\n   \
    \         result.append(c.isUppercase ? c.lowercased() : c.uppercased())\n   \
    \     } else if numbers.contains(c) {\n            reverse = true\n          \
    \  result.append(c)\n        } else {\n            result.append(c)\n        }\n\
    \    }\n    return reverse ? String(result.reversed()) : result", "    guard s.count\
    \ > 0 else { return \"\" }\n    guard s.rangeOfCharacter(from: CharacterSet.letters)\
    \ != nil else {\n        return String(s.reversed())\n    }\n    var res = \"\"\
    \n    for ch in s {\n        let string = String(ch)\n        if string.rangeOfCharacter(from:\
    \ CharacterSet.letters) != nil {\n            res += (string == string.uppercased())\
    \ ? string.lowercased() : string.uppercased()\n        } else {\n            res\
    \ += string\n        }\n    }\n    return res", "    var s = s\n    if s.first\
    \ == nil {\n        return s\n    }\n    if s.first?.isLetter == false {\n   \
    \     s = String(s.reversed())\n    } else {\n        s = s.map { $0.isLetter\
    \ ? $0.isUppercase ? $0.lowercased() : $0.uppercased() : $0 }\n    }\n    return\
    \ s", "    var temp: String = \"\"\n    if !s.containsLetters {\n        for i\
    \ in s.reversed() {\n            temp.append(i)\n        }\n        return temp\n\
    \    }\n    for char in s {\n        if char.isLetter {\n            if char.isUppercase\
    \ {\n                temp.append(char.lowercased())\n            } else {\n  \
    \              temp.append(char.uppercased())\n            }\n        } else {\n\
    \            temp.append(char)\n        }\n    }\n    return temp", "    let a\
    \ = Array(s.characters)\n    var x = \"\"\n    var all = false\n    for i in a\
    \ {\n        if all {\n            x += String(i)\n        } else {\n        \
    \    if i.isLetter {\n                if i.isUppercase {\n                   \
    \ x += String(i).lowercased()\n                } else {\n                    x\
    \ += String(i).uppercased()\n                }\n            } else {\n       \
    \         all = true\n                x += String(i)\n            }\n        }\n\
    \    }\n    return String(x.characters.reversed())", '    return ""', "    let\
    \ letters = Set<Character>(\"abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ\"\
    )\n    let lettersAndNot = s.filter { !letters.contains($0) }\n    if lettersAndNot\
    \ == s {\n        return String(s.reversed())\n    }\n    var result = \"\"\n\
    \    for letter in s {\n        if letters.contains(letter) {\n            result\
    \ += String(letter.toggled())\n        } else {\n            result += String(letter)\n\
    \        }\n    }\n    return result", "\t// your code here\n\treturn \"\"", " \
    \   var solution: String = \"\"\n    for char in s {\n        if char.isLetter\
    \ {\n            solution.append(char.isUppercase ? char.lowercased() : char.uppercased())\n\
    \        } else {\n            solution.append(char)\n        }\n    }\n    return\
    \ solution.isEmpty ? String(s.reversed()) : solution", '    return s.replacingOccurrences(of:
    "[a-zA-Z]", with: "$0", options: .regularExpression).uppercased()', "    let arr\
    \ = s.compactMap { \"\\($0)\".unicodeScalars.first?.value }\n    let res = arr.isEmpty\
    \ ? Array(s.reversed()) :\n        arr.map { Int($0) > 96 && Int($0) < 123 ? String(UnicodeScalar(Int($0)\
    \ - 32)!) :\n                Int($0) > 64 && Int($0) < 91 ? String(UnicodeScalar(Int($0)\
    \ + 32)!) : \"\\($0)\" }\n    return String(res)", "    var str = \"\"\n    for\
    \ char in s {\n        if char.isLetter {\n            str.append(char.isLowercase\
    \ ? char.uppercased() : char.lowercased())\n        } else {\n            str.append(char)\n\
    \        }\n    }\n    return str.isEmpty ? String(s.reversed()) : str", "   \
    \ let result = s.components(separatedBy: [\"0\", \"1\", \"2\", \"3\", \"4\", \"\
    5\", \"6\", \"7\", \"8\", \"9\"]).joined()\n    var finalString = \"\"\n    for\
    \ char in result {\n        if char.isLetter {\n            finalString.append(char.isUppercase\
    \ ? char.lowercased() : char.uppercased())\n        } else {\n            finalString.append(char)\n\
    \        }\n    }\n    return result.isEmpty ? s.reversed() : finalString", " \
    \   var output = s\n    if !s.contains(\"[a-zA-Z]\") {\n        output = String(s.reversed())\n\
    \    } else {\n        var index = s.startIndex\n        while index < s.endIndex\
    \ {\n            if s[index].isLetter {\n                output.remove(at: index)\n\
    \                output.insert(s[index].uppercased(), at: index)\n           \
    \ }\n            index = s.index(after: index)\n        }\n    }\n    return output",
  "    var charArray = [Character]()\n    let letters = Set(\"abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLKMNOPQRSTUVWXYZ\"\
    )\n    var res = \"\"\n    for char in s {\n        if letters.contains(char)\
    \ {\n            charArray.append(char)\n        }\n    }\n    if charArray.isEmpty\
    \ {\n        for i in s.reversed() {\n            res += String(i)\n        }\n\
    \    } else {\n        charArray = charArray.reversed()\n        var index = 0\n\
    \        for char in s {\n            if letters.contains(char) {\n          \
    \      res += String(charArray[index])\n                index += 1\n         \
    \   } else {\n                res += String(char)\n            }\n        }\n\
    \    }\n    return res", "    let letters = CharacterSet.letters\n    let decimalDigits\
    \ = CharacterSet.decimalDigits\n    var result = \"\"\n    var isLettersFound\
    \ = false\n    var i = s.startIndex\n    while i < s.endIndex {\n        let range\
    \ = s.rangeOfCharacter(from: letters, options: [], range: i..<s.endIndex)\n  \
    \      if let range = range {\n            let letter = s[range]\n           \
    \ isLettersFound = true\n            result.append(letter.lowercased() == letter\
    \ ? letter.uppercased() : letter.lowercased())\n            i = range.upperBound\n\
    \        } else {\n            break\n        }\n    }\n    while i < s.endIndex\
    \ {\n        let range = s.rangeOfCharacter(from: decimalDigits, options: [],\
    \ range: i..<s.endIndex)\n        if let range = range {\n            let digit\
    \ = s[range]\n            result.append(digit)\n            i = range.upperBound\n\
    \        } else {\n            break\n        }\n    }\n    return isLettersFound\
    \ ? result : String(result.reversed())", "    var str = \"\"\n    for character\
    \ in s {\n        if character.isLetter {\n            if character.isUppercase\
    \ {\n                str.append(character.lowercased())\n            } else {\n\
    \                str.append(character.uppercased())\n            }\n        }\
    \ else {\n            str.append(character)\n        }\n    }\n    return str.isEmpty\
    \ ? String(s.reversed()) : str", "  return String(\n    s.reversed().map { \n\
    \      $0.isLetter ? Character($0.unicodeScalars.first!.value ^ 32) : $0 \n  \
    \  }\n  )", "    if s.count == 0 {\n        return s\n    }\n    var result =\
    \ \"\"\n    for i in s {\n        result += \"\\(i.isLetter ? i.lowercased() ==\
    \ i ? i.uppercased() : i.lowercased() : i)\"\n    }\n    return result", "   \
    \ // Write your code here.\n    var reversed = \"\"\n    for char in s {\n   \
    \     if char.isLetter {\n            reversed.append(char.isLowercase ? char.uppercased()\
    \ : char.lowercased())\n        } else {\n            reversed.append(char)\n\
    \        }\n    }\n    return reversed.isEmpty ? String(s.reversed()) : reversed",
  "    guard !s.isEmpty else { return s }\n    let letters = CharacterSet.letters\n\
    \    let capitalized = CharacterSet.uppercaseLetters\n    var temp = \"\"\n  \
    \  for item in s {\n        if letters.contains(item.unicodeScalars.first!) {\n\
    \            if capitalized.contains(item.unicodeScalars.first!) {\n         \
    \       temp.append(Character(String(item).lowercased()))\n            } else\
    \ {\n                temp.append(Character(String(item).uppercased()))\n     \
    \       }\n        } else {\n            temp.append(item)\n        }\n    }\n\
    \    return String(temp.reversed())", "    let letterRegex = try! NSRegularExpression(pattern:\
    \ \"[a-zA-Z]\")\n    var result = \"\"\n    for ch in s {\n        if letterRegex.firstMatch(in:\
    \ String(ch), options: [], range: NSRange(location: 0, length: 1)) != nil {\n\
    \            result.append(ch.isLowercase ? Character(ch.uppercased()) : Character(ch.lowercased()))\n\
    \        } else {\n            result.append(ch)\n        }\n    }\n    return\
    \ result.isEmpty ? String(s.reversed()) : result", "    var res = \"\"\n    for\
    \ ch in s {\n        if ch.isLetter {\n            res.append(ch.isLowercase ?\
    \ ch.uppercased() : ch.lowercased())\n        } else {\n            res.append(ch)\n\
    \        }\n    }\n    return res.isEmpty ? String(s.reversed()) : res", "   \
    \ guard !s.isEmpty else { return s }\n    guard s.rangeOfCharacter(from: CharacterSet.letters)\
    \ != nil else { return String(s.reversed()) }\n    var s = s\n    var newStr =\
    \ \"\"\n    for char in s {\n        if char.isLetter {\n            if char.isUppercase\
    \ {\n                newStr.append(char.lowercased())\n            } else {\n\
    \                newStr.append(char.uppercased())\n            }\n        } else\
    \ {\n            newStr.append(char)\n        }\n    }\n    return newStr", " \
    \   guard s.rangeOfCharacter(from: CharacterSet.letters) != nil else {\n     \
    \   return String(s.reversed())\n    }\n    var s = s\n    for i in s.indices\
    \ {\n        let char = s[i]\n        if CharacterSet.letters.contains(char.unicodeScalars.first!)\
    \ {\n            let unicodeScalar = Character(s[i]).unicodeScalars.first!.value\n\
    \            let newChar = (unicodeScalar >= 97 && unicodeScalar <= 122) ? Character(UnicodeScalar(unicodeScalar\
    \ - 32)!) : Character(UnicodeScalar(unicodeScalar + 32)!)\n            s.replaceSubrange(i...i,\
    \ with: String(newChar))\n        }\n    }\n    return s", '    return ""', " \
    \   var result: String = \"\"\n    for i in s {\n        if i.isLetter == true\
    \ {\n            result += String(i.uppercased() == String(i) ? i.lowercased()\
    \ : i.uppercased())\n        } else {\n            result += String(i)\n     \
    \   }\n    }\n    return result.isEmpty ? String(s.reversed()) : result", "  \
    \  var str = Array(s)\n    var isLetter = false\n    var result = \"\"\n    for\
    \ (i,c) in str.enumerated() {\n        if c.isLetter {\n            isLetter =\
    \ true\n            if c.isLowercase {\n                str[i] = Character(c.uppercased())\n\
    \            } else {\n                str[i] = Character(c.lowercased())\n  \
    \          }\n        }\n    }\n    if isLetter {\n        result = String(str)\n\
    \    } else {\n        result = String(str.reversed())\n    }\n    return result",
  "    var str = \"\"\n    var ans = \"\"\n    for c in s {\n        if !c.isLetter\
    \ {\n            str += \"\\(c)\"\n        }\n    }\n    if str.count == s.count\
    \ {\n        return String(s.reversed())\n    }\n    for c in s {\n        if\
    \ c.isLetter {\n            ans += c.isUppercase ? \"\\(c.lowercased())\" : \"\
    \\(c.uppercased())\"\n        } else {\n            ans += \"\\(c)\"\n       \
    \ }\n    }\n    return ans", "    var result = String()\n    let letters = s.filter\
    \ { $0.isLetter }\n    if letters.isEmpty {\n        return String(s.reversed())\n\
    \    }\n    for c in s {\n        if c.isLetter {\n            result.append(c.isUppercase\
    \ ? c.lowercased() : c.uppercased())\n        } else {\n            result.append(c)\n\
    \        }\n    }\n    return result", "    let s = s.map { $0.isLetter ? $0.toggleCase()\
    \ : $0 }\n    return s.contains(where: { $0.isLetter }) ? String(s) : String(s.reversed())",
  "    if s.filter({(c: Character) -> Bool in c.isLetter}).isEmpty {\n        return\
    \ String(s.reversed())\n    }\n    var ans = \"\"\n    for c in s {\n        if\
    \ c.isLetter {\n            ans.append(c.isUppercase ? c.lowercased() : c.uppercased())\n\
    \        } else {\n            ans.append(c)\n        }\n    }\n    return ans",
  "    if s.isEmpty {\n        return \"\"\n    }\n    let result = s.map {\n    \
    \    if $0.isLowercase {\n            return $0.uppercased()\n        } else if\
    \ $0.isUppercase {\n            return $0.lowercased()\n        } else {\n   \
    \         return $0\n        }\n    }\n    return String(result)", "    let result\
    \ = s.components(separatedBy: .letters).reduce(\"\") { (acc, item) -> String in\n\
    \        var result = acc\n        if let char = item.first {\n            if\
    \ char.isUppercase {\n                result += item.lowercased()\n          \
    \  } else {\n                result += item.uppercased()\n            }\n    \
    \    } else {\n            result += item\n        }\n        return result\n\
    \    }\n    return String(result.reversed())", "    guard s.rangeOfCharacter(from:\
    \ CharacterSet.letters) != nil else {\n        return String(s.reversed())\n \
    \   }\n    var arr: [Character] = []\n    for char in s {\n        if char.isLetter\
    \ {\n            arr.append(char.isUpperCase ? char.lowercased() : char.uppercased())\n\
    \        } else {\n            arr.append(char)\n        }\n    }\n    return\
    \ String(arr)", "    var result = \"\"\n    var symbols = \"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz\"\
    \n    for char in s {\n        if symbols.contains(char) {\n            var symbol\
    \ = \"\"\n            for x in symbols {\n                if x == char {\n   \
    \                 symbol = String(x)\n                    break\n            \
    \    }\n            }\n            if symbol == String(char) {\n             \
    \   for y in symbols {\n                    if String(y) == symbol.uppercased()\
    \ {\n                        result += String(y)\n                        break\n\
    \                    }\n                }\n            } else {\n            \
    \    for y in symbols {\n                    if String(y) == symbol.lowercased()\
    \ {\n                        result += String(y)\n                        break\n\
    \                    }\n                }\n            }\n        } else {\n \
    \           result += String(char)\n        }\n    }\n    return result.count\
    \ > 0 ? result : String(s.reversed())", "    return String(s.map { char in\n \
    \       switch char {\n        case \"a\"...\"z\":\n            return Character(char.uppercased())\n\
    \        case \"A\"...\"Z\":\n            return Character(char.lowercased())\n\
    \        default:\n            return char\n        }\n    })", "    var result\
    \ = \"\"\n    if s.count == 0 {\n        return result\n    }\n    for i in s\
    \ {\n        let s = String(i)\n        if s.isLetter {\n            if s.lowercased()\
    \ == s {\n                result += s.uppercased()\n            } else {\n   \
    \             result += s.lowercased()\n            }\n        } else {\n    \
    \        result += s\n        }\n    }\n    return result.count == 0 ? s : result",
  '    return s.isEmpty ? s : s.reversed().map { $0.isLetter ? $0.isUppercase ? Character($0.lowercased())
    : Character($0.uppercased()) : $0 }.joined()', "    var result = \"\"\n    for\
    \ c in s {\n        if let lowCase = c.lowercased().first, lowCase == c {\n  \
    \          result.append(c.uppercased())\n        } else if let upCase = c.uppercased().first,\
    \ upCase == c {\n            result.append(c.lowercased())\n        } else {\n\
    \            result.append(c)\n        }\n    }\n    return s.contains(\"a\")\
    \ || s.contains(\"A\") ? result : String(result.reversed())", '    // your code',
  "    let lowerLetters = \"abcdefghijklmnopqrstuvwxyz\"\n    let upperLetters = \"\
    ABCDEFGHIJKLMNOPQRSTUVWXYZ\"\n    var reverseString = \"\"\n    var hasLetter\
    \ = false\n    for char in s {\n        if lowerLetters.contains(char) {\n   \
    \         hasLetter = true\n            let idx = lowerLetters.firstIndex(of:\
    \ char)!\n            reverseString.append(upperLetters[idx])\n        } else\
    \ if upperLetters.contains(char) {\n            hasLetter = true\n           \
    \ let idx = upperLetters.firstIndex(of: char)!\n            reverseString.append(lowerLetters[idx])\n\
    \        } else {\n            reverseString.append(char)\n        }\n    }\n\
    \    return hasLetter ? reverseString : String(reverseString.reversed())", " \
    \   let S = s.components(separatedBy: .punctuationCharacters).joined()\n    let\
    \ s = S.components(separatedBy: .whitespaces).joined()\n    if s.isEmpty {\n \
    \       return String(s.reversed())\n    }\n    var res = \"\"\n    for c in s\
    \ {\n        if c.isLetter {\n            res.append(c.isUppercase ? c.lowercased()\
    \ : c.uppercased())\n        } else {\n            res.append(c)\n        }\n\
    \    }\n    return res", "    var result: String = \"\"\n    for char in s {\n\
    \        if char.isLetter {\n            if char.isUppercase {\n             \
    \   result.append(char.lowercased())\n            } else {\n                result.append(char.uppercased())\n\
    \            }\n        } else {\n            result.append(char)\n        }\n\
    \    }\n    return s.isEmpty || !s.contains(\"a\") ? String(s.reversed()) : result",
  "    guard s.rangeOfCharacter(from: CharacterSet.letters) != nil else {\n      \
    \  return String(s.reversed())\n    }\n    var result = \"\"\n    for character\
    \ in s {\n        if character.isLetter {\n            result.append(character.isUppercase\
    \ ?\n                String(character).lowercased() :\n                String(character).uppercased())\n\
    \        } else {\n            result.append(character)\n        }\n    }\n  \
    \  return result", '    return ""', "    var newS = \"\"\n    for letter in s\
    \ {\n        if letter.isLetter {\n            newS.append(letter.isUppercase\
    \ ? letter.lowercased() : letter.uppercased())\n        } else {\n           \
    \ newS.append(letter)\n        }\n    }\n    return newS.isEmpty ? String(s.reversed())\
    \ : newS", "    if s.lowercased() == s {\n        return s.uppercased()\n    }\
    \ else if s.uppercased() == s {\n        return s.lowercased()\n    } else {\n\
    \        var result = \"\"\n        for c in s {\n            if c.isLowercase\
    \ {\n                result.append(c.uppercased())\n            } else if c.isUppercase\
    \ {\n                result.append(c.lowercased())\n            } else {\n   \
    \             result.append(c)\n            }\n        }\n        return result\n\
    \    }", "    var result: String = \"\"\n    for i in s {\n        if i >= \"\
    a\" && i <= \"z\" {\n            result.append(i.uppercased())\n        } else\
    \ if i >= \"A\" && i <= \"Z\" {\n            result.append(i.lowercased())\n \
    \       } else {\n            result.append(i)\n        }\n    }\n    return result.count\
    \ > 0 ? result : String(s.reversed())", "    guard s.count > 0 else { return s\
    \ }\n    let letters = Set(\"abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ\"\
    )\n    let reverse = String(s.reversed())\n    var result = \"\"\n    for char\
    \ in reverse {\n        if let uChar = UnicodeScalar(String(char)) {\n       \
    \     if letters.contains(uChar) {\n                result.append(String(unicodeScalarLiteral:\
    \ uChar.value ^ 32))\n            } else {\n                result.append(char)\n\
    \            }\n        }\n    }\n    return result", "    if s.count == 0 {\n\
    \        return s\n    }\n    var result = \"\"\n    let letters = CharacterSet.letters\n\
    \    for item in s {\n        if letters.contains(item.unicodeScalars.first!)\
    \ {\n            result.append(String(item).lowercased() == String(item) ? String(item).uppercased()\
    \ : String(item).lowercased())\n        } else {\n            result.append(item)\n\
    \        }\n    }\n    return result.count == 0 ? String(s.reversed()) : result",
  "    var s = s\n    guard let r = s.rangeOfCharacter(from: CharacterSet.letters)\
    \ else {\n        return String(s.reversed())\n    }\n    let ns = NSString(string:\
    \ s)\n    let start = ns.rangeOfCharacter(from: CharacterSet.letters, options:\
    \ [], range: NSRange(location: 0, length: ns.length)).location\n    let end =\
    \ ns.rangeOfCharacter(from: CharacterSet.letters, options: .backwards, range:\
    \ NSRange(location: 0, length: ns.length)).location\n    let range = NSRange(location:\
    \ start, length: end - start + 1)\n    let sub = ns.substring(with: range)\n \
    \   let subRev = String(sub.reversed())\n    let subEnum = sub.enumerated()\n\
    \    let subRevEnum = subRev.enumerated()\n    for (i, c) in subEnum {\n     \
    \   let nc = subRevEnum.first(where: { $0.offset == i })!.element\n        s.replaceSubrange(Range(range,\
    \ in: s)!.lowerBound.advanced(by: i), with: String(nc))\n    }\n    return s",
  "    var result = \"\"\n    for char in s {\n        if char.isLetter {\n      \
    \      if char.isUppercase {\n                result.append(char.lowercased())\n\
    \            } else {\n                result.append(char.uppercased())\n    \
    \        }\n        } else {\n            result.append(char)\n        }\n   \
    \ }\n    return result.isEmpty ? String(s.reversed()) : result", "\treturn \"\"",
  "    if s.lowercased() == s {\n        return s.uppercased()\n    } else if s.uppercased()\
    \ == s {\n        return s.lowercased()\n    } else {\n        var output = \"\
    \"\n        for character in s {\n            if character.isLetter {\n      \
    \          output += character.isUppercase ? character.lowercased() : character.uppercased()\n\
    \            } else {\n                output += String(character)\n         \
    \   }\n        }\n        return output\n    }", '    return s.map { $0.isLetter
    ? $0.isUppercase ? $0.lowercased() : $0.uppercased() : $0 }.joined()', "    var\
    \ result = \"\"\n    for c in s {\n        if c.isLetter {\n            result.append(c.isLowercase\
    \ ? c.uppercased() : c.lowercased())\n        } else {\n            result.append(c)\n\
    \        }\n    }\n    return result.isEmpty ? String(s.reversed()) : result",
  "    guard !s.isEmpty else { return \"\" }\n    var result = s\n    for i in 0..<s.count\
    \ {\n        let index = s.index(s.startIndex, offsetBy: i)\n        let value\
    \ = s[index]\n        if let character = value.asciiValue {\n            if character\
    \ >= 65 && character <= 90 {\n                result.replaceSubrange(index...index,\
    \ with: String(value).lowercased())\n            } else if character >= 97 &&\
    \ character <= 122 {\n                result.replaceSubrange(index...index, with:\
    \ String(value).uppercased())\n            }\n        }\n    }\n    return result",
  "    if s.lowercased() == s {\n        return s.uppercased()\n    } else if s.uppercased()\
    \ == s {\n        return s.lowercased()\n    } else {\n        return String(s.reversed())\n\
    \    }", "    var str = \"\"\n    for char in s {\n        if char.isLetter {\n\
    \            str.append(char.lowercased() == String(char) ? String(char).uppercased()\
    \ : String(char).lowercased())\n        } else {\n            str.append(char)\n\
    \        }\n    }\n    return str.isEmpty ? String(s.reversed()) : str", "   \
    \ return s.reversed().map {\n        if $0.isLetter {\n            return $0.isUppercase\
    \ ? Character($0.lowercased()) : Character($0.uppercased())\n        }\n     \
    \   return $0\n    }.reduce(\"\", +)", "    var reverseCase = \"\"\n    if s.containsOnlyLetters()\
    \ {\n        for ch in s {\n            if ch.isUppercase() {\n              \
    \  reverseCase += ch.lowercased()\n            } else {\n                reverseCase\
    \ += ch.uppercased()\n            }\n        }\n    } else {\n        for ch in\
    \ s.reversed() {\n            reverseCase += String(ch)\n        }\n    }\n  \
    \  return reverseCase", "    if s.isEmpty {\n        return \"\"\n    }\n    var\
    \ result = \"\"\n    for char in s {\n        result += isLetter(char: char) ?\
    \ toogleCase(char: char) : \"\\(char)\"\n    }\n    return result", '  return
    ""', "    var str = s\n    if s.rangeOfCharacter(from: CharacterSet.letters) ==\
    \ nil {\n        str = String(s.reversed())\n    } else {\n        for i in 0..<s.count\
    \ {\n            if let j = s.index(s.startIndex, offsetBy: i, limitedBy: s.endIndex)\
    \ {\n                let c = s[j]\n                if c.isLetter {\n         \
    \           let range = NSRange(location: i, length: 1)\n                    str\
    \ = str.replacingCharacters(in: range, with: String(c).uppercased())\n       \
    \         }\n            }\n        }\n    }\n    return str", "    var newStr\
    \ = \"\"\n    let characterSet = CharacterSet.letters\n    if s.rangeOfCharacter(from:\
    \ characterSet) == nil {\n        return String(s.reversed())\n    }\n    for\
    \ char in s {\n        if char.isUppercase {\n            newStr.append(char.lowercased())\n\
    \        } else if char.isLowercase {\n            newStr.append(char.uppercased())\n\
    \        } else {\n            newStr.append(char)\n        }\n    }\n    return\
    \ newStr", "    guard s.rangeOfCharacter(from: CharacterSet.letters) != nil else\
    \ {\n        return String(s.reversed())\n    }\n    return String(s.map { c in\n\
    \        if c.isLetter {\n            if c.isUppercase {\n                return\
    \ Character(c.lowercased())\n            } else {\n                return Character(c.uppercased())\n\
    \            }\n        } else {\n            return c\n        }\n    })", " \
    \   var result = \"\"\n    var string = Array(s)\n    if containsLetters(s: s)\
    \ {\n        for char in string {\n            if char.isLetter {\n          \
    \      if char.isUppercase {\n                    result.append(char.lowercased())\n\
    \                } else {\n                    result.append(char.uppercased())\n\
    \                }\n            } else {\n                result.append(char)\n\
    \            }\n        }\n    } else {\n        result = String(string.reversed())\n\
    \    }\n    return result", '    return s.reversed().map { $0.isLetter ? $0.isUppercase
    ? Character($0.lowercased()) : Character($0.uppercased()) : $0 }.joined()', " \
    \   var chars = Array(s)\n    var anyLetter = false\n    for i in 0..<chars.count\
    \ {\n        let char = chars[i]\n        if char.isLetter {\n            anyLetter\
    \ = true\n            if char.isLowercase {\n                chars[i] = Character(char.uppercased())\n\
    \            } else {\n                chars[i] = Character(char.lowercased())\n\
    \            }\n        }\n    }\n    if !anyLetter {\n        chars.reverse()\n\
    \    }\n    return String(chars)", "    let chars = Array(s.unicodeScalars)\n\
    \    var newChars = [Character]()\n    var letters = false\n    for i in 0..<chars.count\
    \ {\n        if(chars[i].isLetter){\n            letters = true\n            let\
    \ newChar = chars[i].value\n            if(newChar >= 65 && newChar <= 90){\n\
    \                newChars.append(Character(UnicodeScalar(newChar + 32)!))\n  \
    \          }else{\n                newChars.append(Character(UnicodeScalar(newChar\
    \ - 32)!))\n            }\n        }else{\n            newChars.append(Character(chars[i]))\n\
    \        }\n    }\n    if(letters){\n        return String(newChars)\n    }else{\n\
    \        return String(newChars.reversed())\n    }", '    return ""', "    var\
    \ str = s\n    if s.isEmpty {\n        return \"\"\n    }\n    if s.isNumber {\n\
    \        str = s.reverse\n    } else {\n        var newStr = \"\"\n        for\
    \ char in s {\n            if char.isUppercase {\n                newStr.append(char.lowercased())\n\
    \            } else if char.isLowercase {\n                newStr.append(char.uppercased())\n\
    \            } else {\n                newStr.append(char)\n            }\n  \
    \      }\n        str = newStr\n    }\n    return str", "    var result = \"\"\
    \n    for character in s {\n        if (character.isLetter) {\n            result.append(String(character).lowercased()\
    \ == String(character) ? String(character).uppercased() : String(character).lowercased())\n\
    \        } else {\n            result.append(character)\n        }\n    }\n  \
    \  return result.count > 0 ? result : String(s.reversed())", "    let letters\
    \ = s.filter { $0.isLetter }\n    guard !letters.isEmpty else { return String(s.reversed())\
    \ }\n    let result = s.map { $0.isLetter ? Character(String($0).uppercased())\
    \ : $0 }\n    return String(result)", "    var res = \"\"\n    for c in s {\n\
    \        let scalars = c.unicodeScalars\n        let char = Character(UnicodeScalar(scalars[scalars.startIndex].value\
    \ ^ 32)!)\n        res.append(char)\n    }\n    return res", "\tguard s.contains(where:\
    \ { $0.isLetter }) else {\n\t\treturn String(s.reversed())\n\t}\n\treturn String(s.map\
    \ {\n\t\t$0.isLetter ? $0.isUppercase ? Character($0.lowercased()) : Character($0.uppercased())\
    \ : $0\n\t})", "  let letters = CharacterSet.letters\n  let s = s.unicodeScalars\n\
    \  var result = \"\"\n  for c in s {\n    if letters.contains(c) {\n      result.append(Character(UnicodeScalar(c.value\
    \ ^ 32)!))\n    } else {\n      result.append(Character(c))\n    }\n  }\n  return\
    \ result", "    let letters = \"abcdefghijklmnopqrstuvwxyz\"\n    let result =\
    \ s.reversed().compactMap { char -> Character? in\n        if letters.contains(char)\
    \ {\n            return letters.contains(char.lowercased()) ? char.uppercased()\
    \ : char.lowercased()\n        }\n        return char\n    }\n    return String(result)"]
stop_tokens:
- "\n}"
