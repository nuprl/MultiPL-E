language: swift
name: HumanEval_159_eat
results:
- exit_code: -4
  program: "\n/// You're a hungry rabbit, and you already have eaten a certain number\
    \ of carrots,\n/// but now you need to eat more carrots to complete the day's\
    \ meals.\n/// you should return an array of [ total number of eaten carrots after\
    \ your meals,\n/// the number of carrots left after your meals ]\n/// if there\
    \ are not enough remaining carrots, you will eat all remaining carrots, but will\
    \ still be hungry.\n/// Example:\n/// >>> eat(number: 5, need: 6, remaining: 10)\n\
    /// [11, 4]\n/// >>> eat(number: 4, need: 8, remaining: 9)\n/// [12, 1]\n/// >>>\
    \ eat(number: 1, need: 10, remaining: 10)\n/// [11, 0]\n/// >>> eat(number: 2,\
    \ need: 11, remaining: 5)\n/// [7, 0]\n/// Variables:\n/// @number : integer\n\
    /// the number of carrots that you have eaten.\n/// @need : integer\n/// the number\
    \ of carrots that you need to eat.\n/// @remaining : integer\n/// the number of\
    \ remaining carrots thet exist in stock\n/// Constrain:\n/// * 0 <= number <=\
    \ 1000\n/// * 0 <= need <= 1000\n/// * 0 <= remaining <= 1000\n/// Have fun :)\n\
    func eat(number: Int, need: Int, remaining: Int) -> [Int] {\n    var newArr =\
    \ [Int]()\n    if (number + remaining) >= need {\n        newArr.append(need)\n\
    \        newArr.append(remaining - (need - number))\n    } else {\n        newArr.append(number\
    \ + remaining)\n        newArr.append(0)\n    }\n    return newArr\n}\n\n\nfunc\
    \ ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count !=\
    \ right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(eat(number: 5, need: 6, remaining: 10) == [11,\
    \ 4])\nassert(eat(number: 4, need: 8, remaining: 9) == [12, 1])\nassert(eat(number:\
    \ 1, need: 10, remaining: 10) == [11, 0])\nassert(eat(number: 2, need: 11, remaining:\
    \ 5) == [7, 0])\nassert(eat(number: 4, need: 5, remaining: 7) == [9, 2])\nassert(eat(number:\
    \ 4, need: 5, remaining: 1) == [5, 0])"
  status: Exception
  stderr: 'tmpbbtdr53u/tmpbbtdr53u.swift:53: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b0c9778ac80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b0c97481b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b0c97481988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b0c974807b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpbbtdr53u                        0x000055d9ab12c444 <unavailable> + 5188

    5    libc.so.6                          0x00002b0c97976460 __libc_start_main +
    245

    6    tmpbbtdr53u                        0x000055d9ab12c089 <unavailable> + 4233

    '
  stdout: ''
  timestamp: 1660014019
- exit_code: 0
  program: "\n/// You're a hungry rabbit, and you already have eaten a certain number\
    \ of carrots,\n/// but now you need to eat more carrots to complete the day's\
    \ meals.\n/// you should return an array of [ total number of eaten carrots after\
    \ your meals,\n/// the number of carrots left after your meals ]\n/// if there\
    \ are not enough remaining carrots, you will eat all remaining carrots, but will\
    \ still be hungry.\n/// Example:\n/// >>> eat(number: 5, need: 6, remaining: 10)\n\
    /// [11, 4]\n/// >>> eat(number: 4, need: 8, remaining: 9)\n/// [12, 1]\n/// >>>\
    \ eat(number: 1, need: 10, remaining: 10)\n/// [11, 0]\n/// >>> eat(number: 2,\
    \ need: 11, remaining: 5)\n/// [7, 0]\n/// Variables:\n/// @number : integer\n\
    /// the number of carrots that you have eaten.\n/// @need : integer\n/// the number\
    \ of carrots that you need to eat.\n/// @remaining : integer\n/// the number of\
    \ remaining carrots thet exist in stock\n/// Constrain:\n/// * 0 <= number <=\
    \ 1000\n/// * 0 <= need <= 1000\n/// * 0 <= remaining <= 1000\n/// Have fun :)\n\
    func eat(number: Int, need: Int, remaining: Int) -> [Int] {\n    return [number\
    \ + min(need, remaining), max(0, remaining - need)]\n}\n\n\nfunc ==(left: [(Int,\
    \ Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n\
    \        return false\n    }\n    for (l, r) in zip(left, right) {\n        if\
    \ l != r {\n            return false\n        }\n    }\n    return true\n}\n \
    \           \nassert(eat(number: 5, need: 6, remaining: 10) == [11, 4])\nassert(eat(number:\
    \ 4, need: 8, remaining: 9) == [12, 1])\nassert(eat(number: 1, need: 10, remaining:\
    \ 10) == [11, 0])\nassert(eat(number: 2, need: 11, remaining: 5) == [7, 0])\n\
    assert(eat(number: 4, need: 5, remaining: 7) == [9, 2])\nassert(eat(number: 4,\
    \ need: 5, remaining: 1) == [5, 0])"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660013824
- exit_code: -4
  program: "\n/// You're a hungry rabbit, and you already have eaten a certain number\
    \ of carrots,\n/// but now you need to eat more carrots to complete the day's\
    \ meals.\n/// you should return an array of [ total number of eaten carrots after\
    \ your meals,\n/// the number of carrots left after your meals ]\n/// if there\
    \ are not enough remaining carrots, you will eat all remaining carrots, but will\
    \ still be hungry.\n/// Example:\n/// >>> eat(number: 5, need: 6, remaining: 10)\n\
    /// [11, 4]\n/// >>> eat(number: 4, need: 8, remaining: 9)\n/// [12, 1]\n/// >>>\
    \ eat(number: 1, need: 10, remaining: 10)\n/// [11, 0]\n/// >>> eat(number: 2,\
    \ need: 11, remaining: 5)\n/// [7, 0]\n/// Variables:\n/// @number : integer\n\
    /// the number of carrots that you have eaten.\n/// @need : integer\n/// the number\
    \ of carrots that you need to eat.\n/// @remaining : integer\n/// the number of\
    \ remaining carrots thet exist in stock\n/// Constrain:\n/// * 0 <= number <=\
    \ 1000\n/// * 0 <= need <= 1000\n/// * 0 <= remaining <= 1000\n/// Have fun :)\n\
    func eat(number: Int, need: Int, remaining: Int) -> [Int] {\n    // good luck\
    \ !\n    let needEat = need - number\n    if remaining >= needEat {\n        return\
    \ [number + needEat, remaining - needEat]\n    } else {\n        return [number\
    \ + remaining, 0]\n    }\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(eat(number:\
    \ 5, need: 6, remaining: 10) == [11, 4])\nassert(eat(number: 4, need: 8, remaining:\
    \ 9) == [12, 1])\nassert(eat(number: 1, need: 10, remaining: 10) == [11, 0])\n\
    assert(eat(number: 2, need: 11, remaining: 5) == [7, 0])\nassert(eat(number: 4,\
    \ need: 5, remaining: 7) == [9, 2])\nassert(eat(number: 4, need: 5, remaining:\
    \ 1) == [5, 0])"
  status: Exception
  stderr: 'tmpwos338c2/tmpwos338c2.swift:51: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002ab31a6bfc80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002ab31a3b6b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002ab31a3b6988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002ab31a3b57b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpwos338c2                        0x00005590dfe7d384 <unavailable> + 4996

    5    libc.so.6                          0x00002ab31a8ab460 __libc_start_main +
    245

    6    tmpwos338c2                        0x00005590dfe7cfc9 <unavailable> + 4041

    '
  stdout: ''
  timestamp: 1660014019
- exit_code: 0
  program: "\n/// You're a hungry rabbit, and you already have eaten a certain number\
    \ of carrots,\n/// but now you need to eat more carrots to complete the day's\
    \ meals.\n/// you should return an array of [ total number of eaten carrots after\
    \ your meals,\n/// the number of carrots left after your meals ]\n/// if there\
    \ are not enough remaining carrots, you will eat all remaining carrots, but will\
    \ still be hungry.\n/// Example:\n/// >>> eat(number: 5, need: 6, remaining: 10)\n\
    /// [11, 4]\n/// >>> eat(number: 4, need: 8, remaining: 9)\n/// [12, 1]\n/// >>>\
    \ eat(number: 1, need: 10, remaining: 10)\n/// [11, 0]\n/// >>> eat(number: 2,\
    \ need: 11, remaining: 5)\n/// [7, 0]\n/// Variables:\n/// @number : integer\n\
    /// the number of carrots that you have eaten.\n/// @need : integer\n/// the number\
    \ of carrots that you need to eat.\n/// @remaining : integer\n/// the number of\
    \ remaining carrots thet exist in stock\n/// Constrain:\n/// * 0 <= number <=\
    \ 1000\n/// * 0 <= need <= 1000\n/// * 0 <= remaining <= 1000\n/// Have fun :)\n\
    func eat(number: Int, need: Int, remaining: Int) -> [Int] {\n    let carrotsConsumed\
    \ = number + min(need, remaining)\n    let carrotsRemaining = max(0, remaining\
    \ - need)\n    return [carrotsConsumed, carrotsRemaining]\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(eat(number: 5, need: 6, remaining: 10) == [11, 4])\nassert(eat(number:\
    \ 4, need: 8, remaining: 9) == [12, 1])\nassert(eat(number: 1, need: 10, remaining:\
    \ 10) == [11, 0])\nassert(eat(number: 2, need: 11, remaining: 5) == [7, 0])\n\
    assert(eat(number: 4, need: 5, remaining: 7) == [9, 2])\nassert(eat(number: 4,\
    \ need: 5, remaining: 1) == [5, 0])"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660014019
- exit_code: 0
  program: "\n/// You're a hungry rabbit, and you already have eaten a certain number\
    \ of carrots,\n/// but now you need to eat more carrots to complete the day's\
    \ meals.\n/// you should return an array of [ total number of eaten carrots after\
    \ your meals,\n/// the number of carrots left after your meals ]\n/// if there\
    \ are not enough remaining carrots, you will eat all remaining carrots, but will\
    \ still be hungry.\n/// Example:\n/// >>> eat(number: 5, need: 6, remaining: 10)\n\
    /// [11, 4]\n/// >>> eat(number: 4, need: 8, remaining: 9)\n/// [12, 1]\n/// >>>\
    \ eat(number: 1, need: 10, remaining: 10)\n/// [11, 0]\n/// >>> eat(number: 2,\
    \ need: 11, remaining: 5)\n/// [7, 0]\n/// Variables:\n/// @number : integer\n\
    /// the number of carrots that you have eaten.\n/// @need : integer\n/// the number\
    \ of carrots that you need to eat.\n/// @remaining : integer\n/// the number of\
    \ remaining carrots thet exist in stock\n/// Constrain:\n/// * 0 <= number <=\
    \ 1000\n/// * 0 <= need <= 1000\n/// * 0 <= remaining <= 1000\n/// Have fun :)\n\
    func eat(number: Int, need: Int, remaining: Int) -> [Int] {\n    let result =\
    \ [number + min(need, remaining), max(0, remaining - need)]\n    return result\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(eat(number: 5, need: 6, remaining: 10) == [11,\
    \ 4])\nassert(eat(number: 4, need: 8, remaining: 9) == [12, 1])\nassert(eat(number:\
    \ 1, need: 10, remaining: 10) == [11, 0])\nassert(eat(number: 2, need: 11, remaining:\
    \ 5) == [7, 0])\nassert(eat(number: 4, need: 5, remaining: 7) == [9, 2])\nassert(eat(number:\
    \ 4, need: 5, remaining: 1) == [5, 0])"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660014019
- exit_code: -4
  program: "\n/// You're a hungry rabbit, and you already have eaten a certain number\
    \ of carrots,\n/// but now you need to eat more carrots to complete the day's\
    \ meals.\n/// you should return an array of [ total number of eaten carrots after\
    \ your meals,\n/// the number of carrots left after your meals ]\n/// if there\
    \ are not enough remaining carrots, you will eat all remaining carrots, but will\
    \ still be hungry.\n/// Example:\n/// >>> eat(number: 5, need: 6, remaining: 10)\n\
    /// [11, 4]\n/// >>> eat(number: 4, need: 8, remaining: 9)\n/// [12, 1]\n/// >>>\
    \ eat(number: 1, need: 10, remaining: 10)\n/// [11, 0]\n/// >>> eat(number: 2,\
    \ need: 11, remaining: 5)\n/// [7, 0]\n/// Variables:\n/// @number : integer\n\
    /// the number of carrots that you have eaten.\n/// @need : integer\n/// the number\
    \ of carrots that you need to eat.\n/// @remaining : integer\n/// the number of\
    \ remaining carrots thet exist in stock\n/// Constrain:\n/// * 0 <= number <=\
    \ 1000\n/// * 0 <= need <= 1000\n/// * 0 <= remaining <= 1000\n/// Have fun :)\n\
    func eat(number: Int, need: Int, remaining: Int) -> [Int] {\n    if number < 0\
    \ || need < 0 || remaining < 0 {\n        return [0, 0]\n    }\n    if number\
    \ > 1000 || need > 1000 || remaining > 1000 {\n        return [0, 0]\n    }\n\
    \    if need > number + remaining {\n        return [number + remaining, 0]\n\
    \    }\n    return [need, remaining - (need - number)]\n}\n\n\nfunc ==(left: [(Int,\
    \ Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n\
    \        return false\n    }\n    for (l, r) in zip(left, right) {\n        if\
    \ l != r {\n            return false\n        }\n    }\n    return true\n}\n \
    \           \nassert(eat(number: 5, need: 6, remaining: 10) == [11, 4])\nassert(eat(number:\
    \ 4, need: 8, remaining: 9) == [12, 1])\nassert(eat(number: 1, need: 10, remaining:\
    \ 10) == [11, 0])\nassert(eat(number: 2, need: 11, remaining: 5) == [7, 0])\n\
    assert(eat(number: 4, need: 5, remaining: 7) == [9, 2])\nassert(eat(number: 4,\
    \ need: 5, remaining: 1) == [5, 0])"
  status: Exception
  stderr: 'tmpjcvqllhm/tmpjcvqllhm.swift:54: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002ba02caa4c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002ba02c79bb6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002ba02c79b988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002ba02c79a7b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpjcvqllhm                        0x0000562d43298384 <unavailable> + 4996

    5    libc.so.6                          0x00002ba02cc90460 __libc_start_main +
    245

    6    tmpjcvqllhm                        0x0000562d43297fc9 <unavailable> + 4041

    '
  stdout: ''
  timestamp: 1660014019
- exit_code: -4
  program: "\n/// You're a hungry rabbit, and you already have eaten a certain number\
    \ of carrots,\n/// but now you need to eat more carrots to complete the day's\
    \ meals.\n/// you should return an array of [ total number of eaten carrots after\
    \ your meals,\n/// the number of carrots left after your meals ]\n/// if there\
    \ are not enough remaining carrots, you will eat all remaining carrots, but will\
    \ still be hungry.\n/// Example:\n/// >>> eat(number: 5, need: 6, remaining: 10)\n\
    /// [11, 4]\n/// >>> eat(number: 4, need: 8, remaining: 9)\n/// [12, 1]\n/// >>>\
    \ eat(number: 1, need: 10, remaining: 10)\n/// [11, 0]\n/// >>> eat(number: 2,\
    \ need: 11, remaining: 5)\n/// [7, 0]\n/// Variables:\n/// @number : integer\n\
    /// the number of carrots that you have eaten.\n/// @need : integer\n/// the number\
    \ of carrots that you need to eat.\n/// @remaining : integer\n/// the number of\
    \ remaining carrots thet exist in stock\n/// Constrain:\n/// * 0 <= number <=\
    \ 1000\n/// * 0 <= need <= 1000\n/// * 0 <= remaining <= 1000\n/// Have fun :)\n\
    func eat(number: Int, need: Int, remaining: Int) -> [Int] {\n    return [number\
    \ + remaining >= need ? need : number + remaining, number + remaining >= need\
    \ ? remaining - (need - number) : 0]\n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(eat(number: 5, need: 6, remaining: 10) == [11, 4])\nassert(eat(number:\
    \ 4, need: 8, remaining: 9) == [12, 1])\nassert(eat(number: 1, need: 10, remaining:\
    \ 10) == [11, 0])\nassert(eat(number: 2, need: 11, remaining: 5) == [7, 0])\n\
    assert(eat(number: 4, need: 5, remaining: 7) == [9, 2])\nassert(eat(number: 4,\
    \ need: 5, remaining: 1) == [5, 0])"
  status: Exception
  stderr: 'tmpukg_7u_c/tmpukg_7u_c.swift:45: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b7ac6c48c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b7ac693fb6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b7ac693f988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b7ac693e7b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpukg_7u_c                        0x00005605a46ee384 <unavailable> + 4996

    5    libc.so.6                          0x00002b7ac6e34460 __libc_start_main +
    245

    6    tmpukg_7u_c                        0x00005605a46edfc9 <unavailable> + 4041

    '
  stdout: ''
  timestamp: 1660014019
- exit_code: -4
  program: "\n/// You're a hungry rabbit, and you already have eaten a certain number\
    \ of carrots,\n/// but now you need to eat more carrots to complete the day's\
    \ meals.\n/// you should return an array of [ total number of eaten carrots after\
    \ your meals,\n/// the number of carrots left after your meals ]\n/// if there\
    \ are not enough remaining carrots, you will eat all remaining carrots, but will\
    \ still be hungry.\n/// Example:\n/// >>> eat(number: 5, need: 6, remaining: 10)\n\
    /// [11, 4]\n/// >>> eat(number: 4, need: 8, remaining: 9)\n/// [12, 1]\n/// >>>\
    \ eat(number: 1, need: 10, remaining: 10)\n/// [11, 0]\n/// >>> eat(number: 2,\
    \ need: 11, remaining: 5)\n/// [7, 0]\n/// Variables:\n/// @number : integer\n\
    /// the number of carrots that you have eaten.\n/// @need : integer\n/// the number\
    \ of carrots that you need to eat.\n/// @remaining : integer\n/// the number of\
    \ remaining carrots thet exist in stock\n/// Constrain:\n/// * 0 <= number <=\
    \ 1000\n/// * 0 <= need <= 1000\n/// * 0 <= remaining <= 1000\n/// Have fun :)\n\
    func eat(number: Int, need: Int, remaining: Int) -> [Int] {\n    let totalCarrots\
    \ = number + remaining\n    if totalCarrots >= need {\n        return [need, totalCarrots\
    \ - need]\n    } else {\n        return [totalCarrots, 0]\n    }\n}\n\n\nfunc\
    \ ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count !=\
    \ right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(eat(number: 5, need: 6, remaining: 10) == [11,\
    \ 4])\nassert(eat(number: 4, need: 8, remaining: 9) == [12, 1])\nassert(eat(number:\
    \ 1, need: 10, remaining: 10) == [11, 0])\nassert(eat(number: 2, need: 11, remaining:\
    \ 5) == [7, 0])\nassert(eat(number: 4, need: 5, remaining: 7) == [9, 2])\nassert(eat(number:\
    \ 4, need: 5, remaining: 1) == [5, 0])"
  status: Exception
  stderr: 'tmp70fv29oq/tmp70fv29oq.swift:50: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b92b12eac80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b92b0fe1b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b92b0fe1988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b92b0fe07b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmp70fv29oq                        0x00005633a0a4b384 <unavailable> + 4996

    5    libc.so.6                          0x00002b92b14d6460 __libc_start_main +
    245

    6    tmp70fv29oq                        0x00005633a0a4afc9 <unavailable> + 4041

    '
  stdout: ''
  timestamp: 1660014019
- exit_code: -4
  program: "\n/// You're a hungry rabbit, and you already have eaten a certain number\
    \ of carrots,\n/// but now you need to eat more carrots to complete the day's\
    \ meals.\n/// you should return an array of [ total number of eaten carrots after\
    \ your meals,\n/// the number of carrots left after your meals ]\n/// if there\
    \ are not enough remaining carrots, you will eat all remaining carrots, but will\
    \ still be hungry.\n/// Example:\n/// >>> eat(number: 5, need: 6, remaining: 10)\n\
    /// [11, 4]\n/// >>> eat(number: 4, need: 8, remaining: 9)\n/// [12, 1]\n/// >>>\
    \ eat(number: 1, need: 10, remaining: 10)\n/// [11, 0]\n/// >>> eat(number: 2,\
    \ need: 11, remaining: 5)\n/// [7, 0]\n/// Variables:\n/// @number : integer\n\
    /// the number of carrots that you have eaten.\n/// @need : integer\n/// the number\
    \ of carrots that you need to eat.\n/// @remaining : integer\n/// the number of\
    \ remaining carrots thet exist in stock\n/// Constrain:\n/// * 0 <= number <=\
    \ 1000\n/// * 0 <= need <= 1000\n/// * 0 <= remaining <= 1000\n/// Have fun :)\n\
    func eat(number: Int, need: Int, remaining: Int) -> [Int] {\n  // your code here...\n\
    \  return []\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool\
    \ {\n    if left.count != right.count {\n        return false\n    }\n    for\
    \ (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(eat(number: 5, need:\
    \ 6, remaining: 10) == [11, 4])\nassert(eat(number: 4, need: 8, remaining: 9)\
    \ == [12, 1])\nassert(eat(number: 1, need: 10, remaining: 10) == [11, 0])\nassert(eat(number:\
    \ 2, need: 11, remaining: 5) == [7, 0])\nassert(eat(number: 4, need: 5, remaining:\
    \ 7) == [9, 2])\nassert(eat(number: 4, need: 5, remaining: 1) == [5, 0])"
  status: Exception
  stderr: 'tmpv2s696f8/tmpv2s696f8.swift:46: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002ae9ac8d1c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002ae9ac5c8b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002ae9ac5c8988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002ae9ac5c77b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpv2s696f8                        0x000055c017e96384 <unavailable> + 4996

    5    libc.so.6                          0x00002ae9acabd460 __libc_start_main +
    245

    6    tmpv2s696f8                        0x000055c017e95fc9 <unavailable> + 4041

    '
  stdout: ''
  timestamp: 1660014019
- exit_code: 0
  program: "\n/// You're a hungry rabbit, and you already have eaten a certain number\
    \ of carrots,\n/// but now you need to eat more carrots to complete the day's\
    \ meals.\n/// you should return an array of [ total number of eaten carrots after\
    \ your meals,\n/// the number of carrots left after your meals ]\n/// if there\
    \ are not enough remaining carrots, you will eat all remaining carrots, but will\
    \ still be hungry.\n/// Example:\n/// >>> eat(number: 5, need: 6, remaining: 10)\n\
    /// [11, 4]\n/// >>> eat(number: 4, need: 8, remaining: 9)\n/// [12, 1]\n/// >>>\
    \ eat(number: 1, need: 10, remaining: 10)\n/// [11, 0]\n/// >>> eat(number: 2,\
    \ need: 11, remaining: 5)\n/// [7, 0]\n/// Variables:\n/// @number : integer\n\
    /// the number of carrots that you have eaten.\n/// @need : integer\n/// the number\
    \ of carrots that you need to eat.\n/// @remaining : integer\n/// the number of\
    \ remaining carrots thet exist in stock\n/// Constrain:\n/// * 0 <= number <=\
    \ 1000\n/// * 0 <= need <= 1000\n/// * 0 <= remaining <= 1000\n/// Have fun :)\n\
    func eat(number: Int, need: Int, remaining: Int) -> [Int] {\n    return [(number\
    \ + min(need, remaining)), (remaining - min(need, remaining))]\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(eat(number: 5, need: 6, remaining: 10) == [11, 4])\nassert(eat(number:\
    \ 4, need: 8, remaining: 9) == [12, 1])\nassert(eat(number: 1, need: 10, remaining:\
    \ 10) == [11, 0])\nassert(eat(number: 2, need: 11, remaining: 5) == [7, 0])\n\
    assert(eat(number: 4, need: 5, remaining: 7) == [9, 2])\nassert(eat(number: 4,\
    \ need: 5, remaining: 1) == [5, 0])"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660014019
- exit_code: -4
  program: "\n/// You're a hungry rabbit, and you already have eaten a certain number\
    \ of carrots,\n/// but now you need to eat more carrots to complete the day's\
    \ meals.\n/// you should return an array of [ total number of eaten carrots after\
    \ your meals,\n/// the number of carrots left after your meals ]\n/// if there\
    \ are not enough remaining carrots, you will eat all remaining carrots, but will\
    \ still be hungry.\n/// Example:\n/// >>> eat(number: 5, need: 6, remaining: 10)\n\
    /// [11, 4]\n/// >>> eat(number: 4, need: 8, remaining: 9)\n/// [12, 1]\n/// >>>\
    \ eat(number: 1, need: 10, remaining: 10)\n/// [11, 0]\n/// >>> eat(number: 2,\
    \ need: 11, remaining: 5)\n/// [7, 0]\n/// Variables:\n/// @number : integer\n\
    /// the number of carrots that you have eaten.\n/// @need : integer\n/// the number\
    \ of carrots that you need to eat.\n/// @remaining : integer\n/// the number of\
    \ remaining carrots thet exist in stock\n/// Constrain:\n/// * 0 <= number <=\
    \ 1000\n/// * 0 <= need <= 1000\n/// * 0 <= remaining <= 1000\n/// Have fun :)\n\
    func eat(number: Int, need: Int, remaining: Int) -> [Int] {\n    let totalEat\
    \ = number + remaining < need ? number + remaining : need\n    return [totalEat,\
    \ remaining - totalEat + number]\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int,\
    \ Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n\
    \    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n          \
    \  return false\n        }\n    }\n    return true\n}\n            \nassert(eat(number:\
    \ 5, need: 6, remaining: 10) == [11, 4])\nassert(eat(number: 4, need: 8, remaining:\
    \ 9) == [12, 1])\nassert(eat(number: 1, need: 10, remaining: 10) == [11, 0])\n\
    assert(eat(number: 2, need: 11, remaining: 5) == [7, 0])\nassert(eat(number: 4,\
    \ need: 5, remaining: 7) == [9, 2])\nassert(eat(number: 4, need: 5, remaining:\
    \ 1) == [5, 0])"
  status: Exception
  stderr: 'tmporhgz56x/tmporhgz56x.swift:46: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b86b319ec80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b86b2e95b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b86b2e95988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b86b2e947b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmporhgz56x                        0x00005632d85e6384 <unavailable> + 4996

    5    libc.so.6                          0x00002b86b338a460 __libc_start_main +
    245

    6    tmporhgz56x                        0x00005632d85e5fc9 <unavailable> + 4041

    '
  stdout: ''
  timestamp: 1660014019
- exit_code: -4
  program: "\n/// You're a hungry rabbit, and you already have eaten a certain number\
    \ of carrots,\n/// but now you need to eat more carrots to complete the day's\
    \ meals.\n/// you should return an array of [ total number of eaten carrots after\
    \ your meals,\n/// the number of carrots left after your meals ]\n/// if there\
    \ are not enough remaining carrots, you will eat all remaining carrots, but will\
    \ still be hungry.\n/// Example:\n/// >>> eat(number: 5, need: 6, remaining: 10)\n\
    /// [11, 4]\n/// >>> eat(number: 4, need: 8, remaining: 9)\n/// [12, 1]\n/// >>>\
    \ eat(number: 1, need: 10, remaining: 10)\n/// [11, 0]\n/// >>> eat(number: 2,\
    \ need: 11, remaining: 5)\n/// [7, 0]\n/// Variables:\n/// @number : integer\n\
    /// the number of carrots that you have eaten.\n/// @need : integer\n/// the number\
    \ of carrots that you need to eat.\n/// @remaining : integer\n/// the number of\
    \ remaining carrots thet exist in stock\n/// Constrain:\n/// * 0 <= number <=\
    \ 1000\n/// * 0 <= need <= 1000\n/// * 0 <= remaining <= 1000\n/// Have fun :)\n\
    func eat(number: Int, need: Int, remaining: Int) -> [Int] {\n    if (number +\
    \ remaining) > need {\n        return [need, number + remaining - need]\n    }\
    \ else {\n        return [number + remaining, 0]\n    }\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(eat(number: 5, need: 6, remaining: 10) == [11, 4])\nassert(eat(number:\
    \ 4, need: 8, remaining: 9) == [12, 1])\nassert(eat(number: 1, need: 10, remaining:\
    \ 10) == [11, 0])\nassert(eat(number: 2, need: 11, remaining: 5) == [7, 0])\n\
    assert(eat(number: 4, need: 5, remaining: 7) == [9, 2])\nassert(eat(number: 4,\
    \ need: 5, remaining: 1) == [5, 0])"
  status: Exception
  stderr: 'tmpy7wfw9q5/tmpy7wfw9q5.swift:49: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002ac57eb0cc80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002ac57e803b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002ac57e803988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002ac57e8027b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpy7wfw9q5                        0x0000560881cfd384 <unavailable> + 4996

    5    libc.so.6                          0x00002ac57ecf8460 __libc_start_main +
    245

    6    tmpy7wfw9q5                        0x0000560881cfcfc9 <unavailable> + 4041

    '
  stdout: ''
  timestamp: 1660014019
- exit_code: -4
  program: "\n/// You're a hungry rabbit, and you already have eaten a certain number\
    \ of carrots,\n/// but now you need to eat more carrots to complete the day's\
    \ meals.\n/// you should return an array of [ total number of eaten carrots after\
    \ your meals,\n/// the number of carrots left after your meals ]\n/// if there\
    \ are not enough remaining carrots, you will eat all remaining carrots, but will\
    \ still be hungry.\n/// Example:\n/// >>> eat(number: 5, need: 6, remaining: 10)\n\
    /// [11, 4]\n/// >>> eat(number: 4, need: 8, remaining: 9)\n/// [12, 1]\n/// >>>\
    \ eat(number: 1, need: 10, remaining: 10)\n/// [11, 0]\n/// >>> eat(number: 2,\
    \ need: 11, remaining: 5)\n/// [7, 0]\n/// Variables:\n/// @number : integer\n\
    /// the number of carrots that you have eaten.\n/// @need : integer\n/// the number\
    \ of carrots that you need to eat.\n/// @remaining : integer\n/// the number of\
    \ remaining carrots thet exist in stock\n/// Constrain:\n/// * 0 <= number <=\
    \ 1000\n/// * 0 <= need <= 1000\n/// * 0 <= remaining <= 1000\n/// Have fun :)\n\
    func eat(number: Int, need: Int, remaining: Int) -> [Int] {\n    let total = number\
    \ + remaining\n    if total > need {\n        return [need, total - need]\n  \
    \  } else {\n        return [total, 0]\n    }\n}\n\n\nfunc ==(left: [(Int, Int)],\
    \ right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n       \
    \ return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r\
    \ {\n            return false\n        }\n    }\n    return true\n}\n        \
    \    \nassert(eat(number: 5, need: 6, remaining: 10) == [11, 4])\nassert(eat(number:\
    \ 4, need: 8, remaining: 9) == [12, 1])\nassert(eat(number: 1, need: 10, remaining:\
    \ 10) == [11, 0])\nassert(eat(number: 2, need: 11, remaining: 5) == [7, 0])\n\
    assert(eat(number: 4, need: 5, remaining: 7) == [9, 2])\nassert(eat(number: 4,\
    \ need: 5, remaining: 1) == [5, 0])"
  status: Exception
  stderr: 'tmprovp3dx6/tmprovp3dx6.swift:50: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b51e68d9c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b51e65d0b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b51e65d0988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b51e65cf7b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmprovp3dx6                        0x0000559121cc3384 <unavailable> + 4996

    5    libc.so.6                          0x00002b51e6ac5460 __libc_start_main +
    245

    6    tmprovp3dx6                        0x0000559121cc2fc9 <unavailable> + 4041

    '
  stdout: ''
  timestamp: 1660014019
- exit_code: -4
  program: "\n/// You're a hungry rabbit, and you already have eaten a certain number\
    \ of carrots,\n/// but now you need to eat more carrots to complete the day's\
    \ meals.\n/// you should return an array of [ total number of eaten carrots after\
    \ your meals,\n/// the number of carrots left after your meals ]\n/// if there\
    \ are not enough remaining carrots, you will eat all remaining carrots, but will\
    \ still be hungry.\n/// Example:\n/// >>> eat(number: 5, need: 6, remaining: 10)\n\
    /// [11, 4]\n/// >>> eat(number: 4, need: 8, remaining: 9)\n/// [12, 1]\n/// >>>\
    \ eat(number: 1, need: 10, remaining: 10)\n/// [11, 0]\n/// >>> eat(number: 2,\
    \ need: 11, remaining: 5)\n/// [7, 0]\n/// Variables:\n/// @number : integer\n\
    /// the number of carrots that you have eaten.\n/// @need : integer\n/// the number\
    \ of carrots that you need to eat.\n/// @remaining : integer\n/// the number of\
    \ remaining carrots thet exist in stock\n/// Constrain:\n/// * 0 <= number <=\
    \ 1000\n/// * 0 <= need <= 1000\n/// * 0 <= remaining <= 1000\n/// Have fun :)\n\
    func eat(number: Int, need: Int, remaining: Int) -> [Int] {\n    let carrotNumber\
    \ = number + need\n    var carrotRemaining = carrotNumber - remaining\n    if\
    \ carrotRemaining < 0 {\n        carrotRemaining = 0\n    }\n    return [carrotNumber,\
    \ carrotRemaining]\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) ->\
    \ Bool {\n    if left.count != right.count {\n        return false\n    }\n  \
    \  for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(eat(number: 5, need:\
    \ 6, remaining: 10) == [11, 4])\nassert(eat(number: 4, need: 8, remaining: 9)\
    \ == [12, 1])\nassert(eat(number: 1, need: 10, remaining: 10) == [11, 0])\nassert(eat(number:\
    \ 2, need: 11, remaining: 5) == [7, 0])\nassert(eat(number: 4, need: 5, remaining:\
    \ 7) == [9, 2])\nassert(eat(number: 4, need: 5, remaining: 1) == [5, 0])"
  status: Exception
  stderr: 'tmp4y4nusis/tmp4y4nusis.swift:50: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002aedf489bc80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002aedf4592b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002aedf4592988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002aedf45917b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmp4y4nusis                        0x00005627d669f384 <unavailable> + 4996

    5    libc.so.6                          0x00002aedf4a87460 __libc_start_main +
    245

    6    tmp4y4nusis                        0x00005627d669efc9 <unavailable> + 4041

    '
  stdout: ''
  timestamp: 1660014019
- exit_code: 0
  program: "\n/// You're a hungry rabbit, and you already have eaten a certain number\
    \ of carrots,\n/// but now you need to eat more carrots to complete the day's\
    \ meals.\n/// you should return an array of [ total number of eaten carrots after\
    \ your meals,\n/// the number of carrots left after your meals ]\n/// if there\
    \ are not enough remaining carrots, you will eat all remaining carrots, but will\
    \ still be hungry.\n/// Example:\n/// >>> eat(number: 5, need: 6, remaining: 10)\n\
    /// [11, 4]\n/// >>> eat(number: 4, need: 8, remaining: 9)\n/// [12, 1]\n/// >>>\
    \ eat(number: 1, need: 10, remaining: 10)\n/// [11, 0]\n/// >>> eat(number: 2,\
    \ need: 11, remaining: 5)\n/// [7, 0]\n/// Variables:\n/// @number : integer\n\
    /// the number of carrots that you have eaten.\n/// @need : integer\n/// the number\
    \ of carrots that you need to eat.\n/// @remaining : integer\n/// the number of\
    \ remaining carrots thet exist in stock\n/// Constrain:\n/// * 0 <= number <=\
    \ 1000\n/// * 0 <= need <= 1000\n/// * 0 <= remaining <= 1000\n/// Have fun :)\n\
    func eat(number: Int, need: Int, remaining: Int) -> [Int] {\n    let total = number\
    \ + min(need, remaining)\n    let left = max(0, remaining - need)\n    return\
    \ [total, left]\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool\
    \ {\n    if left.count != right.count {\n        return false\n    }\n    for\
    \ (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(eat(number: 5, need:\
    \ 6, remaining: 10) == [11, 4])\nassert(eat(number: 4, need: 8, remaining: 9)\
    \ == [12, 1])\nassert(eat(number: 1, need: 10, remaining: 10) == [11, 0])\nassert(eat(number:\
    \ 2, need: 11, remaining: 5) == [7, 0])\nassert(eat(number: 4, need: 5, remaining:\
    \ 7) == [9, 2])\nassert(eat(number: 4, need: 5, remaining: 1) == [5, 0])"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660013824
- exit_code: -4
  program: "\n/// You're a hungry rabbit, and you already have eaten a certain number\
    \ of carrots,\n/// but now you need to eat more carrots to complete the day's\
    \ meals.\n/// you should return an array of [ total number of eaten carrots after\
    \ your meals,\n/// the number of carrots left after your meals ]\n/// if there\
    \ are not enough remaining carrots, you will eat all remaining carrots, but will\
    \ still be hungry.\n/// Example:\n/// >>> eat(number: 5, need: 6, remaining: 10)\n\
    /// [11, 4]\n/// >>> eat(number: 4, need: 8, remaining: 9)\n/// [12, 1]\n/// >>>\
    \ eat(number: 1, need: 10, remaining: 10)\n/// [11, 0]\n/// >>> eat(number: 2,\
    \ need: 11, remaining: 5)\n/// [7, 0]\n/// Variables:\n/// @number : integer\n\
    /// the number of carrots that you have eaten.\n/// @need : integer\n/// the number\
    \ of carrots that you need to eat.\n/// @remaining : integer\n/// the number of\
    \ remaining carrots thet exist in stock\n/// Constrain:\n/// * 0 <= number <=\
    \ 1000\n/// * 0 <= need <= 1000\n/// * 0 <= remaining <= 1000\n/// Have fun :)\n\
    func eat(number: Int, need: Int, remaining: Int) -> [Int] {\n    let total = number\
    \ + remaining\n    if need > total {\n        return [total, 0]\n    }\n    let\
    \ left = total - need\n    return [need, left]\n}\n\n\nfunc ==(left: [(Int, Int)],\
    \ right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n       \
    \ return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r\
    \ {\n            return false\n        }\n    }\n    return true\n}\n        \
    \    \nassert(eat(number: 5, need: 6, remaining: 10) == [11, 4])\nassert(eat(number:\
    \ 4, need: 8, remaining: 9) == [12, 1])\nassert(eat(number: 1, need: 10, remaining:\
    \ 10) == [11, 0])\nassert(eat(number: 2, need: 11, remaining: 5) == [7, 0])\n\
    assert(eat(number: 4, need: 5, remaining: 7) == [9, 2])\nassert(eat(number: 4,\
    \ need: 5, remaining: 1) == [5, 0])"
  status: Exception
  stderr: 'tmp42utky90/tmp42utky90.swift:50: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b3cfd3eac80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b3cfd0e1b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b3cfd0e1988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b3cfd0e07b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmp42utky90                        0x0000563807248384 <unavailable> + 4996

    5    libc.so.6                          0x00002b3cfd5d6460 __libc_start_main +
    245

    6    tmp42utky90                        0x0000563807247fc9 <unavailable> + 4041

    '
  stdout: ''
  timestamp: 1660014019
- exit_code: 0
  program: "\n/// You're a hungry rabbit, and you already have eaten a certain number\
    \ of carrots,\n/// but now you need to eat more carrots to complete the day's\
    \ meals.\n/// you should return an array of [ total number of eaten carrots after\
    \ your meals,\n/// the number of carrots left after your meals ]\n/// if there\
    \ are not enough remaining carrots, you will eat all remaining carrots, but will\
    \ still be hungry.\n/// Example:\n/// >>> eat(number: 5, need: 6, remaining: 10)\n\
    /// [11, 4]\n/// >>> eat(number: 4, need: 8, remaining: 9)\n/// [12, 1]\n/// >>>\
    \ eat(number: 1, need: 10, remaining: 10)\n/// [11, 0]\n/// >>> eat(number: 2,\
    \ need: 11, remaining: 5)\n/// [7, 0]\n/// Variables:\n/// @number : integer\n\
    /// the number of carrots that you have eaten.\n/// @need : integer\n/// the number\
    \ of carrots that you need to eat.\n/// @remaining : integer\n/// the number of\
    \ remaining carrots thet exist in stock\n/// Constrain:\n/// * 0 <= number <=\
    \ 1000\n/// * 0 <= need <= 1000\n/// * 0 <= remaining <= 1000\n/// Have fun :)\n\
    func eat(number: Int, need: Int, remaining: Int) -> [Int] {\n    return [number\
    \ + min(need, remaining), max(0, remaining - need)]\n}\n\n\nfunc ==(left: [(Int,\
    \ Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n\
    \        return false\n    }\n    for (l, r) in zip(left, right) {\n        if\
    \ l != r {\n            return false\n        }\n    }\n    return true\n}\n \
    \           \nassert(eat(number: 5, need: 6, remaining: 10) == [11, 4])\nassert(eat(number:\
    \ 4, need: 8, remaining: 9) == [12, 1])\nassert(eat(number: 1, need: 10, remaining:\
    \ 10) == [11, 0])\nassert(eat(number: 2, need: 11, remaining: 5) == [7, 0])\n\
    assert(eat(number: 4, need: 5, remaining: 7) == [9, 2])\nassert(eat(number: 4,\
    \ need: 5, remaining: 1) == [5, 0])"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660013824
- exit_code: 0
  program: "\n/// You're a hungry rabbit, and you already have eaten a certain number\
    \ of carrots,\n/// but now you need to eat more carrots to complete the day's\
    \ meals.\n/// you should return an array of [ total number of eaten carrots after\
    \ your meals,\n/// the number of carrots left after your meals ]\n/// if there\
    \ are not enough remaining carrots, you will eat all remaining carrots, but will\
    \ still be hungry.\n/// Example:\n/// >>> eat(number: 5, need: 6, remaining: 10)\n\
    /// [11, 4]\n/// >>> eat(number: 4, need: 8, remaining: 9)\n/// [12, 1]\n/// >>>\
    \ eat(number: 1, need: 10, remaining: 10)\n/// [11, 0]\n/// >>> eat(number: 2,\
    \ need: 11, remaining: 5)\n/// [7, 0]\n/// Variables:\n/// @number : integer\n\
    /// the number of carrots that you have eaten.\n/// @need : integer\n/// the number\
    \ of carrots that you need to eat.\n/// @remaining : integer\n/// the number of\
    \ remaining carrots thet exist in stock\n/// Constrain:\n/// * 0 <= number <=\
    \ 1000\n/// * 0 <= need <= 1000\n/// * 0 <= remaining <= 1000\n/// Have fun :)\n\
    func eat(number: Int, need: Int, remaining: Int) -> [Int] {\n    let eaten = number\
    \ + min(need, remaining)\n    let remainingCarrots = max(0, remaining - need)\n\
    \    return [eaten, remainingCarrots]\n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(eat(number: 5, need: 6, remaining: 10) == [11, 4])\nassert(eat(number:\
    \ 4, need: 8, remaining: 9) == [12, 1])\nassert(eat(number: 1, need: 10, remaining:\
    \ 10) == [11, 0])\nassert(eat(number: 2, need: 11, remaining: 5) == [7, 0])\n\
    assert(eat(number: 4, need: 5, remaining: 7) == [9, 2])\nassert(eat(number: 4,\
    \ need: 5, remaining: 1) == [5, 0])"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660014019
- exit_code: 0
  program: "\n/// You're a hungry rabbit, and you already have eaten a certain number\
    \ of carrots,\n/// but now you need to eat more carrots to complete the day's\
    \ meals.\n/// you should return an array of [ total number of eaten carrots after\
    \ your meals,\n/// the number of carrots left after your meals ]\n/// if there\
    \ are not enough remaining carrots, you will eat all remaining carrots, but will\
    \ still be hungry.\n/// Example:\n/// >>> eat(number: 5, need: 6, remaining: 10)\n\
    /// [11, 4]\n/// >>> eat(number: 4, need: 8, remaining: 9)\n/// [12, 1]\n/// >>>\
    \ eat(number: 1, need: 10, remaining: 10)\n/// [11, 0]\n/// >>> eat(number: 2,\
    \ need: 11, remaining: 5)\n/// [7, 0]\n/// Variables:\n/// @number : integer\n\
    /// the number of carrots that you have eaten.\n/// @need : integer\n/// the number\
    \ of carrots that you need to eat.\n/// @remaining : integer\n/// the number of\
    \ remaining carrots thet exist in stock\n/// Constrain:\n/// * 0 <= number <=\
    \ 1000\n/// * 0 <= need <= 1000\n/// * 0 <= remaining <= 1000\n/// Have fun :)\n\
    func eat(number: Int, need: Int, remaining: Int) -> [Int] {\n    let result =\
    \ number + min(need, remaining)\n    return [result, max(0, remaining - need)]\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(eat(number: 5, need: 6, remaining: 10) == [11,\
    \ 4])\nassert(eat(number: 4, need: 8, remaining: 9) == [12, 1])\nassert(eat(number:\
    \ 1, need: 10, remaining: 10) == [11, 0])\nassert(eat(number: 2, need: 11, remaining:\
    \ 5) == [7, 0])\nassert(eat(number: 4, need: 5, remaining: 7) == [9, 2])\nassert(eat(number:\
    \ 4, need: 5, remaining: 1) == [5, 0])"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660014019
- exit_code: -4
  program: "\n/// You're a hungry rabbit, and you already have eaten a certain number\
    \ of carrots,\n/// but now you need to eat more carrots to complete the day's\
    \ meals.\n/// you should return an array of [ total number of eaten carrots after\
    \ your meals,\n/// the number of carrots left after your meals ]\n/// if there\
    \ are not enough remaining carrots, you will eat all remaining carrots, but will\
    \ still be hungry.\n/// Example:\n/// >>> eat(number: 5, need: 6, remaining: 10)\n\
    /// [11, 4]\n/// >>> eat(number: 4, need: 8, remaining: 9)\n/// [12, 1]\n/// >>>\
    \ eat(number: 1, need: 10, remaining: 10)\n/// [11, 0]\n/// >>> eat(number: 2,\
    \ need: 11, remaining: 5)\n/// [7, 0]\n/// Variables:\n/// @number : integer\n\
    /// the number of carrots that you have eaten.\n/// @need : integer\n/// the number\
    \ of carrots that you need to eat.\n/// @remaining : integer\n/// the number of\
    \ remaining carrots thet exist in stock\n/// Constrain:\n/// * 0 <= number <=\
    \ 1000\n/// * 0 <= need <= 1000\n/// * 0 <= remaining <= 1000\n/// Have fun :)\n\
    func eat(number: Int, need: Int, remaining: Int) -> [Int] {\n    let needed =\
    \ need - number\n    let total = number + min(needed, remaining)\n    let left\
    \ = max(0, remaining - needed)\n    return [total, left]\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(eat(number: 5, need: 6, remaining: 10) == [11, 4])\nassert(eat(number:\
    \ 4, need: 8, remaining: 9) == [12, 1])\nassert(eat(number: 1, need: 10, remaining:\
    \ 10) == [11, 0])\nassert(eat(number: 2, need: 11, remaining: 5) == [7, 0])\n\
    assert(eat(number: 4, need: 5, remaining: 7) == [9, 2])\nassert(eat(number: 4,\
    \ need: 5, remaining: 1) == [5, 0])"
  status: Exception
  stderr: 'tmpgq59vxte/tmpgq59vxte.swift:48: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002ad01a807c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002ad01a4feb6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002ad01a4fe988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002ad01a4fd7b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpgq59vxte                        0x000055c0a6d04474 <unavailable> + 5236

    5    libc.so.6                          0x00002ad01a9f3460 __libc_start_main +
    245

    6    tmpgq59vxte                        0x000055c0a6d040b9 <unavailable> + 4281

    '
  stdout: ''
  timestamp: 1660014019
- exit_code: -4
  program: "\n/// You're a hungry rabbit, and you already have eaten a certain number\
    \ of carrots,\n/// but now you need to eat more carrots to complete the day's\
    \ meals.\n/// you should return an array of [ total number of eaten carrots after\
    \ your meals,\n/// the number of carrots left after your meals ]\n/// if there\
    \ are not enough remaining carrots, you will eat all remaining carrots, but will\
    \ still be hungry.\n/// Example:\n/// >>> eat(number: 5, need: 6, remaining: 10)\n\
    /// [11, 4]\n/// >>> eat(number: 4, need: 8, remaining: 9)\n/// [12, 1]\n/// >>>\
    \ eat(number: 1, need: 10, remaining: 10)\n/// [11, 0]\n/// >>> eat(number: 2,\
    \ need: 11, remaining: 5)\n/// [7, 0]\n/// Variables:\n/// @number : integer\n\
    /// the number of carrots that you have eaten.\n/// @need : integer\n/// the number\
    \ of carrots that you need to eat.\n/// @remaining : integer\n/// the number of\
    \ remaining carrots thet exist in stock\n/// Constrain:\n/// * 0 <= number <=\
    \ 1000\n/// * 0 <= need <= 1000\n/// * 0 <= remaining <= 1000\n/// Have fun :)\n\
    func eat(number: Int, need: Int, remaining: Int) -> [Int] {\n    let eaten = min(number\
    \ + remaining, need)\n    return [eaten, remaining - (eaten - number)]\n}\n\n\n\
    func ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(eat(number: 5, need: 6, remaining: 10) == [11,\
    \ 4])\nassert(eat(number: 4, need: 8, remaining: 9) == [12, 1])\nassert(eat(number:\
    \ 1, need: 10, remaining: 10) == [11, 0])\nassert(eat(number: 2, need: 11, remaining:\
    \ 5) == [7, 0])\nassert(eat(number: 4, need: 5, remaining: 7) == [9, 2])\nassert(eat(number:\
    \ 4, need: 5, remaining: 1) == [5, 0])"
  status: Exception
  stderr: 'tmpgpgndo8_/tmpgpgndo8_.swift:46: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002af3c4296c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002af3c3f8db6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002af3c3f8d988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002af3c3f8c7b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpgpgndo8_                        0x000056366f0ec424 <unavailable> + 5156

    5    libc.so.6                          0x00002af3c4482460 __libc_start_main +
    245

    6    tmpgpgndo8_                        0x000056366f0ec069 <unavailable> + 4201

    '
  stdout: ''
  timestamp: 1660014019
- exit_code: 0
  program: "\n/// You're a hungry rabbit, and you already have eaten a certain number\
    \ of carrots,\n/// but now you need to eat more carrots to complete the day's\
    \ meals.\n/// you should return an array of [ total number of eaten carrots after\
    \ your meals,\n/// the number of carrots left after your meals ]\n/// if there\
    \ are not enough remaining carrots, you will eat all remaining carrots, but will\
    \ still be hungry.\n/// Example:\n/// >>> eat(number: 5, need: 6, remaining: 10)\n\
    /// [11, 4]\n/// >>> eat(number: 4, need: 8, remaining: 9)\n/// [12, 1]\n/// >>>\
    \ eat(number: 1, need: 10, remaining: 10)\n/// [11, 0]\n/// >>> eat(number: 2,\
    \ need: 11, remaining: 5)\n/// [7, 0]\n/// Variables:\n/// @number : integer\n\
    /// the number of carrots that you have eaten.\n/// @need : integer\n/// the number\
    \ of carrots that you need to eat.\n/// @remaining : integer\n/// the number of\
    \ remaining carrots thet exist in stock\n/// Constrain:\n/// * 0 <= number <=\
    \ 1000\n/// * 0 <= need <= 1000\n/// * 0 <= remaining <= 1000\n/// Have fun :)\n\
    func eat(number: Int, need: Int, remaining: Int) -> [Int] {\n    var rem = remaining\n\
    \    var need = need\n    var number = number\n    if remaining < need {\n   \
    \     if remaining <= 0 {\n            rem = 0\n            number = number +\
    \ need\n        } else {\n            rem = 0\n            number = number + remaining\n\
    \            need = need - remaining\n        }\n    } else {\n        rem = remaining\
    \ - need\n        number = number + need\n    }\n    return [number, rem]\n}\n\
    \n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(eat(number: 5, need: 6, remaining: 10) == [11,\
    \ 4])\nassert(eat(number: 4, need: 8, remaining: 9) == [12, 1])\nassert(eat(number:\
    \ 1, need: 10, remaining: 10) == [11, 0])\nassert(eat(number: 2, need: 11, remaining:\
    \ 5) == [7, 0])\nassert(eat(number: 4, need: 5, remaining: 7) == [9, 2])\nassert(eat(number:\
    \ 4, need: 5, remaining: 1) == [5, 0])"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660014019
- exit_code: -4
  program: "\n/// You're a hungry rabbit, and you already have eaten a certain number\
    \ of carrots,\n/// but now you need to eat more carrots to complete the day's\
    \ meals.\n/// you should return an array of [ total number of eaten carrots after\
    \ your meals,\n/// the number of carrots left after your meals ]\n/// if there\
    \ are not enough remaining carrots, you will eat all remaining carrots, but will\
    \ still be hungry.\n/// Example:\n/// >>> eat(number: 5, need: 6, remaining: 10)\n\
    /// [11, 4]\n/// >>> eat(number: 4, need: 8, remaining: 9)\n/// [12, 1]\n/// >>>\
    \ eat(number: 1, need: 10, remaining: 10)\n/// [11, 0]\n/// >>> eat(number: 2,\
    \ need: 11, remaining: 5)\n/// [7, 0]\n/// Variables:\n/// @number : integer\n\
    /// the number of carrots that you have eaten.\n/// @need : integer\n/// the number\
    \ of carrots that you need to eat.\n/// @remaining : integer\n/// the number of\
    \ remaining carrots thet exist in stock\n/// Constrain:\n/// * 0 <= number <=\
    \ 1000\n/// * 0 <= need <= 1000\n/// * 0 <= remaining <= 1000\n/// Have fun :)\n\
    func eat(number: Int, need: Int, remaining: Int) -> [Int] {\n    var total = number\
    \ + remaining\n    if total >= need {\n        total = need\n    }\n    return\
    \ [total, number + remaining - total]\n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(eat(number: 5, need: 6, remaining: 10) == [11, 4])\nassert(eat(number:\
    \ 4, need: 8, remaining: 9) == [12, 1])\nassert(eat(number: 1, need: 10, remaining:\
    \ 10) == [11, 0])\nassert(eat(number: 2, need: 11, remaining: 5) == [7, 0])\n\
    assert(eat(number: 4, need: 5, remaining: 7) == [9, 2])\nassert(eat(number: 4,\
    \ need: 5, remaining: 1) == [5, 0])"
  status: Exception
  stderr: 'tmpis8nfic9/tmpis8nfic9.swift:49: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b5fa3cadc80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b5fa39a4b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b5fa39a4988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b5fa39a37b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpis8nfic9                        0x0000564ef46b2384 <unavailable> + 4996

    5    libc.so.6                          0x00002b5fa3e99460 __libc_start_main +
    245

    6    tmpis8nfic9                        0x0000564ef46b1fc9 <unavailable> + 4041

    '
  stdout: ''
  timestamp: 1660014019
- exit_code: -4
  program: "\n/// You're a hungry rabbit, and you already have eaten a certain number\
    \ of carrots,\n/// but now you need to eat more carrots to complete the day's\
    \ meals.\n/// you should return an array of [ total number of eaten carrots after\
    \ your meals,\n/// the number of carrots left after your meals ]\n/// if there\
    \ are not enough remaining carrots, you will eat all remaining carrots, but will\
    \ still be hungry.\n/// Example:\n/// >>> eat(number: 5, need: 6, remaining: 10)\n\
    /// [11, 4]\n/// >>> eat(number: 4, need: 8, remaining: 9)\n/// [12, 1]\n/// >>>\
    \ eat(number: 1, need: 10, remaining: 10)\n/// [11, 0]\n/// >>> eat(number: 2,\
    \ need: 11, remaining: 5)\n/// [7, 0]\n/// Variables:\n/// @number : integer\n\
    /// the number of carrots that you have eaten.\n/// @need : integer\n/// the number\
    \ of carrots that you need to eat.\n/// @remaining : integer\n/// the number of\
    \ remaining carrots thet exist in stock\n/// Constrain:\n/// * 0 <= number <=\
    \ 1000\n/// * 0 <= need <= 1000\n/// * 0 <= remaining <= 1000\n/// Have fun :)\n\
    func eat(number: Int, need: Int, remaining: Int) -> [Int] {\n    let eat = min(remaining,\
    \ need - number)\n    return [eat + number, remaining - eat]\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(eat(number: 5, need: 6, remaining: 10) == [11, 4])\nassert(eat(number:\
    \ 4, need: 8, remaining: 9) == [12, 1])\nassert(eat(number: 1, need: 10, remaining:\
    \ 10) == [11, 0])\nassert(eat(number: 2, need: 11, remaining: 5) == [7, 0])\n\
    assert(eat(number: 4, need: 5, remaining: 7) == [9, 2])\nassert(eat(number: 4,\
    \ need: 5, remaining: 1) == [5, 0])"
  status: Exception
  stderr: 'tmp632d7u8f/tmp632d7u8f.swift:46: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b529fcd6c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b529f9cdb6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b529f9cd988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b529f9cc7b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmp632d7u8f                        0x000055d753f7c424 <unavailable> + 5156

    5    libc.so.6                          0x00002b529fec2460 __libc_start_main +
    245

    6    tmp632d7u8f                        0x000055d753f7c069 <unavailable> + 4201

    '
  stdout: ''
  timestamp: 1660014019
- exit_code: -4
  program: "\n/// You're a hungry rabbit, and you already have eaten a certain number\
    \ of carrots,\n/// but now you need to eat more carrots to complete the day's\
    \ meals.\n/// you should return an array of [ total number of eaten carrots after\
    \ your meals,\n/// the number of carrots left after your meals ]\n/// if there\
    \ are not enough remaining carrots, you will eat all remaining carrots, but will\
    \ still be hungry.\n/// Example:\n/// >>> eat(number: 5, need: 6, remaining: 10)\n\
    /// [11, 4]\n/// >>> eat(number: 4, need: 8, remaining: 9)\n/// [12, 1]\n/// >>>\
    \ eat(number: 1, need: 10, remaining: 10)\n/// [11, 0]\n/// >>> eat(number: 2,\
    \ need: 11, remaining: 5)\n/// [7, 0]\n/// Variables:\n/// @number : integer\n\
    /// the number of carrots that you have eaten.\n/// @need : integer\n/// the number\
    \ of carrots that you need to eat.\n/// @remaining : integer\n/// the number of\
    \ remaining carrots thet exist in stock\n/// Constrain:\n/// * 0 <= number <=\
    \ 1000\n/// * 0 <= need <= 1000\n/// * 0 <= remaining <= 1000\n/// Have fun :)\n\
    func eat(number: Int, need: Int, remaining: Int) -> [Int] {\n    if remaining\
    \ == 0 {\n        return [number, 0]\n    } else if number + remaining < need\
    \ {\n        return [number + remaining, 0]\n    } else {\n        return [number\
    \ + need, remaining - need]\n    }\n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(eat(number: 5, need: 6, remaining: 10) == [11, 4])\nassert(eat(number:\
    \ 4, need: 8, remaining: 9) == [12, 1])\nassert(eat(number: 1, need: 10, remaining:\
    \ 10) == [11, 0])\nassert(eat(number: 2, need: 11, remaining: 5) == [7, 0])\n\
    assert(eat(number: 4, need: 5, remaining: 7) == [9, 2])\nassert(eat(number: 4,\
    \ need: 5, remaining: 1) == [5, 0])"
  status: Exception
  stderr: 'tmpq65enriw/tmpq65enriw.swift:56: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002ac1792dfc80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002ac178fd6b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002ac178fd6988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002ac178fd57b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpq65enriw                        0x0000555c6ece5873 <unavailable> + 6259

    5    libc.so.6                          0x00002ac1794cb460 __libc_start_main +
    245

    6    tmpq65enriw                        0x0000555c6ece4fc9 <unavailable> + 4041

    '
  stdout: ''
  timestamp: 1660014019
- exit_code: 0
  program: "\n/// You're a hungry rabbit, and you already have eaten a certain number\
    \ of carrots,\n/// but now you need to eat more carrots to complete the day's\
    \ meals.\n/// you should return an array of [ total number of eaten carrots after\
    \ your meals,\n/// the number of carrots left after your meals ]\n/// if there\
    \ are not enough remaining carrots, you will eat all remaining carrots, but will\
    \ still be hungry.\n/// Example:\n/// >>> eat(number: 5, need: 6, remaining: 10)\n\
    /// [11, 4]\n/// >>> eat(number: 4, need: 8, remaining: 9)\n/// [12, 1]\n/// >>>\
    \ eat(number: 1, need: 10, remaining: 10)\n/// [11, 0]\n/// >>> eat(number: 2,\
    \ need: 11, remaining: 5)\n/// [7, 0]\n/// Variables:\n/// @number : integer\n\
    /// the number of carrots that you have eaten.\n/// @need : integer\n/// the number\
    \ of carrots that you need to eat.\n/// @remaining : integer\n/// the number of\
    \ remaining carrots thet exist in stock\n/// Constrain:\n/// * 0 <= number <=\
    \ 1000\n/// * 0 <= need <= 1000\n/// * 0 <= remaining <= 1000\n/// Have fun :)\n\
    func eat(number: Int, need: Int, remaining: Int) -> [Int] {\n    return [number\
    \ + min(need, remaining), max(0, remaining - need)]\n}\n\n\nfunc ==(left: [(Int,\
    \ Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n\
    \        return false\n    }\n    for (l, r) in zip(left, right) {\n        if\
    \ l != r {\n            return false\n        }\n    }\n    return true\n}\n \
    \           \nassert(eat(number: 5, need: 6, remaining: 10) == [11, 4])\nassert(eat(number:\
    \ 4, need: 8, remaining: 9) == [12, 1])\nassert(eat(number: 1, need: 10, remaining:\
    \ 10) == [11, 0])\nassert(eat(number: 2, need: 11, remaining: 5) == [7, 0])\n\
    assert(eat(number: 4, need: 5, remaining: 7) == [9, 2])\nassert(eat(number: 4,\
    \ need: 5, remaining: 1) == [5, 0])"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660013824
- exit_code: -4
  program: "\n/// You're a hungry rabbit, and you already have eaten a certain number\
    \ of carrots,\n/// but now you need to eat more carrots to complete the day's\
    \ meals.\n/// you should return an array of [ total number of eaten carrots after\
    \ your meals,\n/// the number of carrots left after your meals ]\n/// if there\
    \ are not enough remaining carrots, you will eat all remaining carrots, but will\
    \ still be hungry.\n/// Example:\n/// >>> eat(number: 5, need: 6, remaining: 10)\n\
    /// [11, 4]\n/// >>> eat(number: 4, need: 8, remaining: 9)\n/// [12, 1]\n/// >>>\
    \ eat(number: 1, need: 10, remaining: 10)\n/// [11, 0]\n/// >>> eat(number: 2,\
    \ need: 11, remaining: 5)\n/// [7, 0]\n/// Variables:\n/// @number : integer\n\
    /// the number of carrots that you have eaten.\n/// @need : integer\n/// the number\
    \ of carrots that you need to eat.\n/// @remaining : integer\n/// the number of\
    \ remaining carrots thet exist in stock\n/// Constrain:\n/// * 0 <= number <=\
    \ 1000\n/// * 0 <= need <= 1000\n/// * 0 <= remaining <= 1000\n/// Have fun :)\n\
    func eat(number: Int, need: Int, remaining: Int) -> [Int] {\n    let carrots =\
    \ number + remaining\n    return carrots >= need ? [need, carrots - need] : [carrots,\
    \ 0]\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if\
    \ left.count != right.count {\n        return false\n    }\n    for (l, r) in\
    \ zip(left, right) {\n        if l != r {\n            return false\n        }\n\
    \    }\n    return true\n}\n            \nassert(eat(number: 5, need: 6, remaining:\
    \ 10) == [11, 4])\nassert(eat(number: 4, need: 8, remaining: 9) == [12, 1])\n\
    assert(eat(number: 1, need: 10, remaining: 10) == [11, 0])\nassert(eat(number:\
    \ 2, need: 11, remaining: 5) == [7, 0])\nassert(eat(number: 4, need: 5, remaining:\
    \ 7) == [9, 2])\nassert(eat(number: 4, need: 5, remaining: 1) == [5, 0])"
  status: Exception
  stderr: 'tmp3eai46ya/tmp3eai46ya.swift:46: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b3429874c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b342956bb6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b342956b988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b342956a7b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmp3eai46ya                        0x0000560898912384 <unavailable> + 4996

    5    libc.so.6                          0x00002b3429a60460 __libc_start_main +
    245

    6    tmp3eai46ya                        0x0000560898911fc9 <unavailable> + 4041

    '
  stdout: ''
  timestamp: 1660014019
- exit_code: -4
  program: "\n/// You're a hungry rabbit, and you already have eaten a certain number\
    \ of carrots,\n/// but now you need to eat more carrots to complete the day's\
    \ meals.\n/// you should return an array of [ total number of eaten carrots after\
    \ your meals,\n/// the number of carrots left after your meals ]\n/// if there\
    \ are not enough remaining carrots, you will eat all remaining carrots, but will\
    \ still be hungry.\n/// Example:\n/// >>> eat(number: 5, need: 6, remaining: 10)\n\
    /// [11, 4]\n/// >>> eat(number: 4, need: 8, remaining: 9)\n/// [12, 1]\n/// >>>\
    \ eat(number: 1, need: 10, remaining: 10)\n/// [11, 0]\n/// >>> eat(number: 2,\
    \ need: 11, remaining: 5)\n/// [7, 0]\n/// Variables:\n/// @number : integer\n\
    /// the number of carrots that you have eaten.\n/// @need : integer\n/// the number\
    \ of carrots that you need to eat.\n/// @remaining : integer\n/// the number of\
    \ remaining carrots thet exist in stock\n/// Constrain:\n/// * 0 <= number <=\
    \ 1000\n/// * 0 <= need <= 1000\n/// * 0 <= remaining <= 1000\n/// Have fun :)\n\
    func eat(number: Int, need: Int, remaining: Int) -> [Int] {\n    var eatNumber\
    \ = number\n    var eatNeed = need\n    var eatRemaining = remaining\n    if eatNeed\
    \ < eatNumber {\n        return [eatNeed, eatRemaining]\n    }\n    eatNumber\
    \ += eatRemaining\n    eatRemaining = 0\n    if eatNeed < eatNumber {\n      \
    \  eatRemaining = eatNumber - eatNeed\n        eatNumber = eatNeed\n    }\n  \
    \  return [eatNumber, eatRemaining]\n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(eat(number: 5, need: 6, remaining: 10) == [11, 4])\nassert(eat(number:\
    \ 4, need: 8, remaining: 9) == [12, 1])\nassert(eat(number: 1, need: 10, remaining:\
    \ 10) == [11, 0])\nassert(eat(number: 2, need: 11, remaining: 5) == [7, 0])\n\
    assert(eat(number: 4, need: 5, remaining: 7) == [9, 2])\nassert(eat(number: 4,\
    \ need: 5, remaining: 1) == [5, 0])"
  status: Exception
  stderr: 'tmpsfc4kinm/tmpsfc4kinm.swift:57: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b66225adc80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b66222a4b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b66222a4988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b66222a37b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpsfc4kinm                        0x00005598f6cc1384 <unavailable> + 4996

    5    libc.so.6                          0x00002b6622799460 __libc_start_main +
    245

    6    tmpsfc4kinm                        0x00005598f6cc0fc9 <unavailable> + 4041

    '
  stdout: ''
  timestamp: 1660014019
- exit_code: 0
  program: "\n/// You're a hungry rabbit, and you already have eaten a certain number\
    \ of carrots,\n/// but now you need to eat more carrots to complete the day's\
    \ meals.\n/// you should return an array of [ total number of eaten carrots after\
    \ your meals,\n/// the number of carrots left after your meals ]\n/// if there\
    \ are not enough remaining carrots, you will eat all remaining carrots, but will\
    \ still be hungry.\n/// Example:\n/// >>> eat(number: 5, need: 6, remaining: 10)\n\
    /// [11, 4]\n/// >>> eat(number: 4, need: 8, remaining: 9)\n/// [12, 1]\n/// >>>\
    \ eat(number: 1, need: 10, remaining: 10)\n/// [11, 0]\n/// >>> eat(number: 2,\
    \ need: 11, remaining: 5)\n/// [7, 0]\n/// Variables:\n/// @number : integer\n\
    /// the number of carrots that you have eaten.\n/// @need : integer\n/// the number\
    \ of carrots that you need to eat.\n/// @remaining : integer\n/// the number of\
    \ remaining carrots thet exist in stock\n/// Constrain:\n/// * 0 <= number <=\
    \ 1000\n/// * 0 <= need <= 1000\n/// * 0 <= remaining <= 1000\n/// Have fun :)\n\
    func eat(number: Int, need: Int, remaining: Int) -> [Int] {\n    let num = number\
    \ + min(need, remaining)\n    let rem = max(0, remaining - need)\n    return [num,\
    \ rem]\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n  \
    \  if left.count != right.count {\n        return false\n    }\n    for (l, r)\
    \ in zip(left, right) {\n        if l != r {\n            return false\n     \
    \   }\n    }\n    return true\n}\n            \nassert(eat(number: 5, need: 6,\
    \ remaining: 10) == [11, 4])\nassert(eat(number: 4, need: 8, remaining: 9) ==\
    \ [12, 1])\nassert(eat(number: 1, need: 10, remaining: 10) == [11, 0])\nassert(eat(number:\
    \ 2, need: 11, remaining: 5) == [7, 0])\nassert(eat(number: 4, need: 5, remaining:\
    \ 7) == [9, 2])\nassert(eat(number: 4, need: 5, remaining: 1) == [5, 0])"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660014019
- exit_code: -4
  program: "\n/// You're a hungry rabbit, and you already have eaten a certain number\
    \ of carrots,\n/// but now you need to eat more carrots to complete the day's\
    \ meals.\n/// you should return an array of [ total number of eaten carrots after\
    \ your meals,\n/// the number of carrots left after your meals ]\n/// if there\
    \ are not enough remaining carrots, you will eat all remaining carrots, but will\
    \ still be hungry.\n/// Example:\n/// >>> eat(number: 5, need: 6, remaining: 10)\n\
    /// [11, 4]\n/// >>> eat(number: 4, need: 8, remaining: 9)\n/// [12, 1]\n/// >>>\
    \ eat(number: 1, need: 10, remaining: 10)\n/// [11, 0]\n/// >>> eat(number: 2,\
    \ need: 11, remaining: 5)\n/// [7, 0]\n/// Variables:\n/// @number : integer\n\
    /// the number of carrots that you have eaten.\n/// @need : integer\n/// the number\
    \ of carrots that you need to eat.\n/// @remaining : integer\n/// the number of\
    \ remaining carrots thet exist in stock\n/// Constrain:\n/// * 0 <= number <=\
    \ 1000\n/// * 0 <= need <= 1000\n/// * 0 <= remaining <= 1000\n/// Have fun :)\n\
    func eat(number: Int, need: Int, remaining: Int) -> [Int] {\n    // your code\
    \ here\n    return [0, 0]\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(eat(number:\
    \ 5, need: 6, remaining: 10) == [11, 4])\nassert(eat(number: 4, need: 8, remaining:\
    \ 9) == [12, 1])\nassert(eat(number: 1, need: 10, remaining: 10) == [11, 0])\n\
    assert(eat(number: 2, need: 11, remaining: 5) == [7, 0])\nassert(eat(number: 4,\
    \ need: 5, remaining: 7) == [9, 2])\nassert(eat(number: 4, need: 5, remaining:\
    \ 1) == [5, 0])"
  status: Exception
  stderr: 'tmpo3p8aefa/tmpo3p8aefa.swift:46: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b598c114c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b598be0bb6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b598be0b988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b598be0a7b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpo3p8aefa                        0x000055b191e9e384 <unavailable> + 4996

    5    libc.so.6                          0x00002b598c300460 __libc_start_main +
    245

    6    tmpo3p8aefa                        0x000055b191e9dfc9 <unavailable> + 4041

    '
  stdout: ''
  timestamp: 1660014019
- exit_code: 0
  program: "\n/// You're a hungry rabbit, and you already have eaten a certain number\
    \ of carrots,\n/// but now you need to eat more carrots to complete the day's\
    \ meals.\n/// you should return an array of [ total number of eaten carrots after\
    \ your meals,\n/// the number of carrots left after your meals ]\n/// if there\
    \ are not enough remaining carrots, you will eat all remaining carrots, but will\
    \ still be hungry.\n/// Example:\n/// >>> eat(number: 5, need: 6, remaining: 10)\n\
    /// [11, 4]\n/// >>> eat(number: 4, need: 8, remaining: 9)\n/// [12, 1]\n/// >>>\
    \ eat(number: 1, need: 10, remaining: 10)\n/// [11, 0]\n/// >>> eat(number: 2,\
    \ need: 11, remaining: 5)\n/// [7, 0]\n/// Variables:\n/// @number : integer\n\
    /// the number of carrots that you have eaten.\n/// @need : integer\n/// the number\
    \ of carrots that you need to eat.\n/// @remaining : integer\n/// the number of\
    \ remaining carrots thet exist in stock\n/// Constrain:\n/// * 0 <= number <=\
    \ 1000\n/// * 0 <= need <= 1000\n/// * 0 <= remaining <= 1000\n/// Have fun :)\n\
    func eat(number: Int, need: Int, remaining: Int) -> [Int] {\n    return [number\
    \ + min(need, remaining), max(0, remaining - need)]\n}\n\n\nfunc ==(left: [(Int,\
    \ Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n\
    \        return false\n    }\n    for (l, r) in zip(left, right) {\n        if\
    \ l != r {\n            return false\n        }\n    }\n    return true\n}\n \
    \           \nassert(eat(number: 5, need: 6, remaining: 10) == [11, 4])\nassert(eat(number:\
    \ 4, need: 8, remaining: 9) == [12, 1])\nassert(eat(number: 1, need: 10, remaining:\
    \ 10) == [11, 0])\nassert(eat(number: 2, need: 11, remaining: 5) == [7, 0])\n\
    assert(eat(number: 4, need: 5, remaining: 7) == [9, 2])\nassert(eat(number: 4,\
    \ need: 5, remaining: 1) == [5, 0])"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660013824
- exit_code: -4
  program: "\n/// You're a hungry rabbit, and you already have eaten a certain number\
    \ of carrots,\n/// but now you need to eat more carrots to complete the day's\
    \ meals.\n/// you should return an array of [ total number of eaten carrots after\
    \ your meals,\n/// the number of carrots left after your meals ]\n/// if there\
    \ are not enough remaining carrots, you will eat all remaining carrots, but will\
    \ still be hungry.\n/// Example:\n/// >>> eat(number: 5, need: 6, remaining: 10)\n\
    /// [11, 4]\n/// >>> eat(number: 4, need: 8, remaining: 9)\n/// [12, 1]\n/// >>>\
    \ eat(number: 1, need: 10, remaining: 10)\n/// [11, 0]\n/// >>> eat(number: 2,\
    \ need: 11, remaining: 5)\n/// [7, 0]\n/// Variables:\n/// @number : integer\n\
    /// the number of carrots that you have eaten.\n/// @need : integer\n/// the number\
    \ of carrots that you need to eat.\n/// @remaining : integer\n/// the number of\
    \ remaining carrots thet exist in stock\n/// Constrain:\n/// * 0 <= number <=\
    \ 1000\n/// * 0 <= need <= 1000\n/// * 0 <= remaining <= 1000\n/// Have fun :)\n\
    func eat(number: Int, need: Int, remaining: Int) -> [Int] {\n  return []\n}\n\n\
    \nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(eat(number: 5, need: 6, remaining: 10) == [11,\
    \ 4])\nassert(eat(number: 4, need: 8, remaining: 9) == [12, 1])\nassert(eat(number:\
    \ 1, need: 10, remaining: 10) == [11, 0])\nassert(eat(number: 2, need: 11, remaining:\
    \ 5) == [7, 0])\nassert(eat(number: 4, need: 5, remaining: 7) == [9, 2])\nassert(eat(number:\
    \ 4, need: 5, remaining: 1) == [5, 0])"
  status: Exception
  stderr: 'tmpox5xlvdj/tmpox5xlvdj.swift:45: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002ba0b642cc80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002ba0b6123b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002ba0b6123988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002ba0b61227b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpox5xlvdj                        0x0000557d36f93384 <unavailable> + 4996

    5    libc.so.6                          0x00002ba0b6618460 __libc_start_main +
    245

    6    tmpox5xlvdj                        0x0000557d36f92fc9 <unavailable> + 4041

    '
  stdout: ''
  timestamp: 1660014019
- exit_code: -4
  program: "\n/// You're a hungry rabbit, and you already have eaten a certain number\
    \ of carrots,\n/// but now you need to eat more carrots to complete the day's\
    \ meals.\n/// you should return an array of [ total number of eaten carrots after\
    \ your meals,\n/// the number of carrots left after your meals ]\n/// if there\
    \ are not enough remaining carrots, you will eat all remaining carrots, but will\
    \ still be hungry.\n/// Example:\n/// >>> eat(number: 5, need: 6, remaining: 10)\n\
    /// [11, 4]\n/// >>> eat(number: 4, need: 8, remaining: 9)\n/// [12, 1]\n/// >>>\
    \ eat(number: 1, need: 10, remaining: 10)\n/// [11, 0]\n/// >>> eat(number: 2,\
    \ need: 11, remaining: 5)\n/// [7, 0]\n/// Variables:\n/// @number : integer\n\
    /// the number of carrots that you have eaten.\n/// @need : integer\n/// the number\
    \ of carrots that you need to eat.\n/// @remaining : integer\n/// the number of\
    \ remaining carrots thet exist in stock\n/// Constrain:\n/// * 0 <= number <=\
    \ 1000\n/// * 0 <= need <= 1000\n/// * 0 <= remaining <= 1000\n/// Have fun :)\n\
    func eat(number: Int, need: Int, remaining: Int) -> [Int] {\n    if number + remaining\
    \ < need {\n        return [number + remaining, 0]\n    } else {\n        return\
    \ [need, number + remaining - need]\n    }\n}\n\n\nfunc ==(left: [(Int, Int)],\
    \ right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n       \
    \ return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r\
    \ {\n            return false\n        }\n    }\n    return true\n}\n        \
    \    \nassert(eat(number: 5, need: 6, remaining: 10) == [11, 4])\nassert(eat(number:\
    \ 4, need: 8, remaining: 9) == [12, 1])\nassert(eat(number: 1, need: 10, remaining:\
    \ 10) == [11, 0])\nassert(eat(number: 2, need: 11, remaining: 5) == [7, 0])\n\
    assert(eat(number: 4, need: 5, remaining: 7) == [9, 2])\nassert(eat(number: 4,\
    \ need: 5, remaining: 1) == [5, 0])"
  status: Exception
  stderr: 'tmpodhds56n/tmpodhds56n.swift:49: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002adcacffac80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002adcaccf1b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002adcaccf1988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002adcaccf07b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpodhds56n                        0x0000556fbfc9c384 <unavailable> + 4996

    5    libc.so.6                          0x00002adcad1e6460 __libc_start_main +
    245

    6    tmpodhds56n                        0x0000556fbfc9bfc9 <unavailable> + 4041

    '
  stdout: ''
  timestamp: 1660013825
- exit_code: -4
  program: "\n/// You're a hungry rabbit, and you already have eaten a certain number\
    \ of carrots,\n/// but now you need to eat more carrots to complete the day's\
    \ meals.\n/// you should return an array of [ total number of eaten carrots after\
    \ your meals,\n/// the number of carrots left after your meals ]\n/// if there\
    \ are not enough remaining carrots, you will eat all remaining carrots, but will\
    \ still be hungry.\n/// Example:\n/// >>> eat(number: 5, need: 6, remaining: 10)\n\
    /// [11, 4]\n/// >>> eat(number: 4, need: 8, remaining: 9)\n/// [12, 1]\n/// >>>\
    \ eat(number: 1, need: 10, remaining: 10)\n/// [11, 0]\n/// >>> eat(number: 2,\
    \ need: 11, remaining: 5)\n/// [7, 0]\n/// Variables:\n/// @number : integer\n\
    /// the number of carrots that you have eaten.\n/// @need : integer\n/// the number\
    \ of carrots that you need to eat.\n/// @remaining : integer\n/// the number of\
    \ remaining carrots thet exist in stock\n/// Constrain:\n/// * 0 <= number <=\
    \ 1000\n/// * 0 <= need <= 1000\n/// * 0 <= remaining <= 1000\n/// Have fun :)\n\
    func eat(number: Int, need: Int, remaining: Int) -> [Int] {\n    let total = number\
    \ + remaining\n    let left = total - need\n    if left >= 0 {\n        return\
    \ [need, left]\n    } else {\n        return [total, 0]\n    }\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(eat(number: 5, need: 6, remaining: 10) == [11, 4])\nassert(eat(number:\
    \ 4, need: 8, remaining: 9) == [12, 1])\nassert(eat(number: 1, need: 10, remaining:\
    \ 10) == [11, 0])\nassert(eat(number: 2, need: 11, remaining: 5) == [7, 0])\n\
    assert(eat(number: 4, need: 5, remaining: 7) == [9, 2])\nassert(eat(number: 4,\
    \ need: 5, remaining: 1) == [5, 0])"
  status: Exception
  stderr: 'tmp20hqaopo/tmp20hqaopo.swift:51: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b4d615f1c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b4d612e8b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b4d612e8988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b4d612e77b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmp20hqaopo                        0x0000564ade4ae384 <unavailable> + 4996

    5    libc.so.6                          0x00002b4d617dd460 __libc_start_main +
    245

    6    tmp20hqaopo                        0x0000564ade4adfc9 <unavailable> + 4041

    '
  stdout: ''
  timestamp: 1660014019
- exit_code: 0
  program: "\n/// You're a hungry rabbit, and you already have eaten a certain number\
    \ of carrots,\n/// but now you need to eat more carrots to complete the day's\
    \ meals.\n/// you should return an array of [ total number of eaten carrots after\
    \ your meals,\n/// the number of carrots left after your meals ]\n/// if there\
    \ are not enough remaining carrots, you will eat all remaining carrots, but will\
    \ still be hungry.\n/// Example:\n/// >>> eat(number: 5, need: 6, remaining: 10)\n\
    /// [11, 4]\n/// >>> eat(number: 4, need: 8, remaining: 9)\n/// [12, 1]\n/// >>>\
    \ eat(number: 1, need: 10, remaining: 10)\n/// [11, 0]\n/// >>> eat(number: 2,\
    \ need: 11, remaining: 5)\n/// [7, 0]\n/// Variables:\n/// @number : integer\n\
    /// the number of carrots that you have eaten.\n/// @need : integer\n/// the number\
    \ of carrots that you need to eat.\n/// @remaining : integer\n/// the number of\
    \ remaining carrots thet exist in stock\n/// Constrain:\n/// * 0 <= number <=\
    \ 1000\n/// * 0 <= need <= 1000\n/// * 0 <= remaining <= 1000\n/// Have fun :)\n\
    func eat(number: Int, need: Int, remaining: Int) -> [Int] {\n    let total = number\
    \ + min(need, remaining)\n    let left = max(0, remaining - need)\n    return\
    \ [total, left]\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool\
    \ {\n    if left.count != right.count {\n        return false\n    }\n    for\
    \ (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(eat(number: 5, need:\
    \ 6, remaining: 10) == [11, 4])\nassert(eat(number: 4, need: 8, remaining: 9)\
    \ == [12, 1])\nassert(eat(number: 1, need: 10, remaining: 10) == [11, 0])\nassert(eat(number:\
    \ 2, need: 11, remaining: 5) == [7, 0])\nassert(eat(number: 4, need: 5, remaining:\
    \ 7) == [9, 2])\nassert(eat(number: 4, need: 5, remaining: 1) == [5, 0])"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660013824
- exit_code: 0
  program: "\n/// You're a hungry rabbit, and you already have eaten a certain number\
    \ of carrots,\n/// but now you need to eat more carrots to complete the day's\
    \ meals.\n/// you should return an array of [ total number of eaten carrots after\
    \ your meals,\n/// the number of carrots left after your meals ]\n/// if there\
    \ are not enough remaining carrots, you will eat all remaining carrots, but will\
    \ still be hungry.\n/// Example:\n/// >>> eat(number: 5, need: 6, remaining: 10)\n\
    /// [11, 4]\n/// >>> eat(number: 4, need: 8, remaining: 9)\n/// [12, 1]\n/// >>>\
    \ eat(number: 1, need: 10, remaining: 10)\n/// [11, 0]\n/// >>> eat(number: 2,\
    \ need: 11, remaining: 5)\n/// [7, 0]\n/// Variables:\n/// @number : integer\n\
    /// the number of carrots that you have eaten.\n/// @need : integer\n/// the number\
    \ of carrots that you need to eat.\n/// @remaining : integer\n/// the number of\
    \ remaining carrots thet exist in stock\n/// Constrain:\n/// * 0 <= number <=\
    \ 1000\n/// * 0 <= need <= 1000\n/// * 0 <= remaining <= 1000\n/// Have fun :)\n\
    func eat(number: Int, need: Int, remaining: Int) -> [Int] {\n    let eaten = number\
    \ + min(need, remaining)\n    let left = max(0, remaining - need)\n    return\
    \ [eaten, left]\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool\
    \ {\n    if left.count != right.count {\n        return false\n    }\n    for\
    \ (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(eat(number: 5, need:\
    \ 6, remaining: 10) == [11, 4])\nassert(eat(number: 4, need: 8, remaining: 9)\
    \ == [12, 1])\nassert(eat(number: 1, need: 10, remaining: 10) == [11, 0])\nassert(eat(number:\
    \ 2, need: 11, remaining: 5) == [7, 0])\nassert(eat(number: 4, need: 5, remaining:\
    \ 7) == [9, 2])\nassert(eat(number: 4, need: 5, remaining: 1) == [5, 0])"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660013824
- exit_code: -4
  program: "\n/// You're a hungry rabbit, and you already have eaten a certain number\
    \ of carrots,\n/// but now you need to eat more carrots to complete the day's\
    \ meals.\n/// you should return an array of [ total number of eaten carrots after\
    \ your meals,\n/// the number of carrots left after your meals ]\n/// if there\
    \ are not enough remaining carrots, you will eat all remaining carrots, but will\
    \ still be hungry.\n/// Example:\n/// >>> eat(number: 5, need: 6, remaining: 10)\n\
    /// [11, 4]\n/// >>> eat(number: 4, need: 8, remaining: 9)\n/// [12, 1]\n/// >>>\
    \ eat(number: 1, need: 10, remaining: 10)\n/// [11, 0]\n/// >>> eat(number: 2,\
    \ need: 11, remaining: 5)\n/// [7, 0]\n/// Variables:\n/// @number : integer\n\
    /// the number of carrots that you have eaten.\n/// @need : integer\n/// the number\
    \ of carrots that you need to eat.\n/// @remaining : integer\n/// the number of\
    \ remaining carrots thet exist in stock\n/// Constrain:\n/// * 0 <= number <=\
    \ 1000\n/// * 0 <= need <= 1000\n/// * 0 <= remaining <= 1000\n/// Have fun :)\n\
    func eat(number: Int, need: Int, remaining: Int) -> [Int] {\n    var result =\
    \ [Int]()\n    var newRemaining = remaining\n    if number >= need {\n       \
    \ result.append(number)\n        result.append(remaining)\n    } else {\n    \
    \    if need - number <= remaining {\n            result.append(number + need\
    \ - number)\n            result.append(remaining - (need - number))\n        }\
    \ else {\n            result.append(number + remaining)\n            result.append(0)\n\
    \        }\n    }\n    return result\n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(eat(number: 5, need: 6, remaining: 10) == [11, 4])\nassert(eat(number:\
    \ 4, need: 8, remaining: 9) == [12, 1])\nassert(eat(number: 1, need: 10, remaining:\
    \ 10) == [11, 0])\nassert(eat(number: 2, need: 11, remaining: 5) == [7, 0])\n\
    assert(eat(number: 4, need: 5, remaining: 7) == [9, 2])\nassert(eat(number: 4,\
    \ need: 5, remaining: 1) == [5, 0])"
  status: Exception
  stderr: 'tmpxrazwfv9/tmpxrazwfv9.swift:59: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b66e7785c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b66e747cb6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b66e747c988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b66e747b7b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpxrazwfv9                        0x00005613d57bd444 <unavailable> + 5188

    5    libc.so.6                          0x00002b66e7971460 __libc_start_main +
    245

    6    tmpxrazwfv9                        0x00005613d57bd089 <unavailable> + 4233

    '
  stdout: ''
  timestamp: 1660014019
- exit_code: -4
  program: "\n/// You're a hungry rabbit, and you already have eaten a certain number\
    \ of carrots,\n/// but now you need to eat more carrots to complete the day's\
    \ meals.\n/// you should return an array of [ total number of eaten carrots after\
    \ your meals,\n/// the number of carrots left after your meals ]\n/// if there\
    \ are not enough remaining carrots, you will eat all remaining carrots, but will\
    \ still be hungry.\n/// Example:\n/// >>> eat(number: 5, need: 6, remaining: 10)\n\
    /// [11, 4]\n/// >>> eat(number: 4, need: 8, remaining: 9)\n/// [12, 1]\n/// >>>\
    \ eat(number: 1, need: 10, remaining: 10)\n/// [11, 0]\n/// >>> eat(number: 2,\
    \ need: 11, remaining: 5)\n/// [7, 0]\n/// Variables:\n/// @number : integer\n\
    /// the number of carrots that you have eaten.\n/// @need : integer\n/// the number\
    \ of carrots that you need to eat.\n/// @remaining : integer\n/// the number of\
    \ remaining carrots thet exist in stock\n/// Constrain:\n/// * 0 <= number <=\
    \ 1000\n/// * 0 <= need <= 1000\n/// * 0 <= remaining <= 1000\n/// Have fun :)\n\
    func eat(number: Int, need: Int, remaining: Int) -> [Int] {\n    // your code\
    \ here\n    var arr : [Int] = []\n    if remaining >= need - number {\n      \
    \  arr.append(number + need)\n        arr.append(remaining - need + number)\n\
    \    } else {\n        arr.append(number + remaining)\n        arr.append(0)\n\
    \    }\n    return arr\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(eat(number:\
    \ 5, need: 6, remaining: 10) == [11, 4])\nassert(eat(number: 4, need: 8, remaining:\
    \ 9) == [12, 1])\nassert(eat(number: 1, need: 10, remaining: 10) == [11, 0])\n\
    assert(eat(number: 2, need: 11, remaining: 5) == [7, 0])\nassert(eat(number: 4,\
    \ need: 5, remaining: 7) == [9, 2])\nassert(eat(number: 4, need: 5, remaining:\
    \ 1) == [5, 0])"
  status: Exception
  stderr: 'tmp9k836tl_/tmp9k836tl_.swift:54: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002ab805aa7c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002ab80579eb6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002ab80579e988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002ab80579d7b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmp9k836tl_                        0x000055a1b500e3e4 <unavailable> + 5092

    5    libc.so.6                          0x00002ab805c93460 __libc_start_main +
    245

    6    tmp9k836tl_                        0x000055a1b500e029 <unavailable> + 4137

    '
  stdout: ''
  timestamp: 1660014019
- exit_code: -4
  program: "\n/// You're a hungry rabbit, and you already have eaten a certain number\
    \ of carrots,\n/// but now you need to eat more carrots to complete the day's\
    \ meals.\n/// you should return an array of [ total number of eaten carrots after\
    \ your meals,\n/// the number of carrots left after your meals ]\n/// if there\
    \ are not enough remaining carrots, you will eat all remaining carrots, but will\
    \ still be hungry.\n/// Example:\n/// >>> eat(number: 5, need: 6, remaining: 10)\n\
    /// [11, 4]\n/// >>> eat(number: 4, need: 8, remaining: 9)\n/// [12, 1]\n/// >>>\
    \ eat(number: 1, need: 10, remaining: 10)\n/// [11, 0]\n/// >>> eat(number: 2,\
    \ need: 11, remaining: 5)\n/// [7, 0]\n/// Variables:\n/// @number : integer\n\
    /// the number of carrots that you have eaten.\n/// @need : integer\n/// the number\
    \ of carrots that you need to eat.\n/// @remaining : integer\n/// the number of\
    \ remaining carrots thet exist in stock\n/// Constrain:\n/// * 0 <= number <=\
    \ 1000\n/// * 0 <= need <= 1000\n/// * 0 <= remaining <= 1000\n/// Have fun :)\n\
    func eat(number: Int, need: Int, remaining: Int) -> [Int] {\n    var eaten = number\n\
    \    var left = remaining\n    if number + remaining < need {\n        eaten +=\
    \ remaining\n        left = 0\n    } else {\n        eaten += need\n        left\
    \ -= (need - number)\n    }\n    return [eaten, left]\n}\n\n\nfunc ==(left: [(Int,\
    \ Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n\
    \        return false\n    }\n    for (l, r) in zip(left, right) {\n        if\
    \ l != r {\n            return false\n        }\n    }\n    return true\n}\n \
    \           \nassert(eat(number: 5, need: 6, remaining: 10) == [11, 4])\nassert(eat(number:\
    \ 4, need: 8, remaining: 9) == [12, 1])\nassert(eat(number: 1, need: 10, remaining:\
    \ 10) == [11, 0])\nassert(eat(number: 2, need: 11, remaining: 5) == [7, 0])\n\
    assert(eat(number: 4, need: 5, remaining: 7) == [9, 2])\nassert(eat(number: 4,\
    \ need: 5, remaining: 1) == [5, 0])"
  status: Exception
  stderr: 'tmpr7z4xvir/tmpr7z4xvir.swift:54: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002affd941bc80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002affd9112b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002affd9112988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002affd91117b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpr7z4xvir                        0x000055bf34a8f384 <unavailable> + 4996

    5    libc.so.6                          0x00002affd9607460 __libc_start_main +
    245

    6    tmpr7z4xvir                        0x000055bf34a8efc9 <unavailable> + 4041

    '
  stdout: ''
  timestamp: 1660014019
- exit_code: -4
  program: "\n/// You're a hungry rabbit, and you already have eaten a certain number\
    \ of carrots,\n/// but now you need to eat more carrots to complete the day's\
    \ meals.\n/// you should return an array of [ total number of eaten carrots after\
    \ your meals,\n/// the number of carrots left after your meals ]\n/// if there\
    \ are not enough remaining carrots, you will eat all remaining carrots, but will\
    \ still be hungry.\n/// Example:\n/// >>> eat(number: 5, need: 6, remaining: 10)\n\
    /// [11, 4]\n/// >>> eat(number: 4, need: 8, remaining: 9)\n/// [12, 1]\n/// >>>\
    \ eat(number: 1, need: 10, remaining: 10)\n/// [11, 0]\n/// >>> eat(number: 2,\
    \ need: 11, remaining: 5)\n/// [7, 0]\n/// Variables:\n/// @number : integer\n\
    /// the number of carrots that you have eaten.\n/// @need : integer\n/// the number\
    \ of carrots that you need to eat.\n/// @remaining : integer\n/// the number of\
    \ remaining carrots thet exist in stock\n/// Constrain:\n/// * 0 <= number <=\
    \ 1000\n/// * 0 <= need <= 1000\n/// * 0 <= remaining <= 1000\n/// Have fun :)\n\
    func eat(number: Int, need: Int, remaining: Int) -> [Int] {\n    return [remaining\
    \ - (need - number), remaining - need]\n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(eat(number: 5, need: 6, remaining: 10) == [11, 4])\nassert(eat(number:\
    \ 4, need: 8, remaining: 9) == [12, 1])\nassert(eat(number: 1, need: 10, remaining:\
    \ 10) == [11, 0])\nassert(eat(number: 2, need: 11, remaining: 5) == [7, 0])\n\
    assert(eat(number: 4, need: 5, remaining: 7) == [9, 2])\nassert(eat(number: 4,\
    \ need: 5, remaining: 1) == [5, 0])"
  status: Exception
  stderr: 'tmpbw_epcja/tmpbw_epcja.swift:45: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002aab3b316c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002aab3b00db6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002aab3b00d988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002aab3b00c7b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpbw_epcja                        0x000056101634d384 <unavailable> + 4996

    5    libc.so.6                          0x00002aab3b502460 __libc_start_main +
    245

    6    tmpbw_epcja                        0x000056101634cfc9 <unavailable> + 4041

    '
  stdout: ''
  timestamp: 1660014019
- exit_code: -4
  program: "\n/// You're a hungry rabbit, and you already have eaten a certain number\
    \ of carrots,\n/// but now you need to eat more carrots to complete the day's\
    \ meals.\n/// you should return an array of [ total number of eaten carrots after\
    \ your meals,\n/// the number of carrots left after your meals ]\n/// if there\
    \ are not enough remaining carrots, you will eat all remaining carrots, but will\
    \ still be hungry.\n/// Example:\n/// >>> eat(number: 5, need: 6, remaining: 10)\n\
    /// [11, 4]\n/// >>> eat(number: 4, need: 8, remaining: 9)\n/// [12, 1]\n/// >>>\
    \ eat(number: 1, need: 10, remaining: 10)\n/// [11, 0]\n/// >>> eat(number: 2,\
    \ need: 11, remaining: 5)\n/// [7, 0]\n/// Variables:\n/// @number : integer\n\
    /// the number of carrots that you have eaten.\n/// @need : integer\n/// the number\
    \ of carrots that you need to eat.\n/// @remaining : integer\n/// the number of\
    \ remaining carrots thet exist in stock\n/// Constrain:\n/// * 0 <= number <=\
    \ 1000\n/// * 0 <= need <= 1000\n/// * 0 <= remaining <= 1000\n/// Have fun :)\n\
    func eat(number: Int, need: Int, remaining: Int) -> [Int] {\n  var result = number\n\
    \  var remaining = remaining\n  let need = need - number\n  if remaining >= need\
    \ {\n    result += need\n    remaining -= need\n  } else {\n    result += remaining\n\
    \    remaining = 0\n  }\n  return [result, remaining]\n}\n\n\nfunc ==(left: [(Int,\
    \ Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n\
    \        return false\n    }\n    for (l, r) in zip(left, right) {\n        if\
    \ l != r {\n            return false\n        }\n    }\n    return true\n}\n \
    \           \nassert(eat(number: 5, need: 6, remaining: 10) == [11, 4])\nassert(eat(number:\
    \ 4, need: 8, remaining: 9) == [12, 1])\nassert(eat(number: 1, need: 10, remaining:\
    \ 10) == [11, 0])\nassert(eat(number: 2, need: 11, remaining: 5) == [7, 0])\n\
    assert(eat(number: 4, need: 5, remaining: 7) == [9, 2])\nassert(eat(number: 4,\
    \ need: 5, remaining: 1) == [5, 0])"
  status: Exception
  stderr: 'tmpo8jlb1ma/tmpo8jlb1ma.swift:55: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b7e4b16cc80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b7e4ae63b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b7e4ae63988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b7e4ae627b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpo8jlb1ma                        0x000055e0a7379384 <unavailable> + 4996

    5    libc.so.6                          0x00002b7e4b358460 __libc_start_main +
    245

    6    tmpo8jlb1ma                        0x000055e0a7378fc9 <unavailable> + 4041

    '
  stdout: ''
  timestamp: 1660014019
- exit_code: 0
  program: "\n/// You're a hungry rabbit, and you already have eaten a certain number\
    \ of carrots,\n/// but now you need to eat more carrots to complete the day's\
    \ meals.\n/// you should return an array of [ total number of eaten carrots after\
    \ your meals,\n/// the number of carrots left after your meals ]\n/// if there\
    \ are not enough remaining carrots, you will eat all remaining carrots, but will\
    \ still be hungry.\n/// Example:\n/// >>> eat(number: 5, need: 6, remaining: 10)\n\
    /// [11, 4]\n/// >>> eat(number: 4, need: 8, remaining: 9)\n/// [12, 1]\n/// >>>\
    \ eat(number: 1, need: 10, remaining: 10)\n/// [11, 0]\n/// >>> eat(number: 2,\
    \ need: 11, remaining: 5)\n/// [7, 0]\n/// Variables:\n/// @number : integer\n\
    /// the number of carrots that you have eaten.\n/// @need : integer\n/// the number\
    \ of carrots that you need to eat.\n/// @remaining : integer\n/// the number of\
    \ remaining carrots thet exist in stock\n/// Constrain:\n/// * 0 <= number <=\
    \ 1000\n/// * 0 <= need <= 1000\n/// * 0 <= remaining <= 1000\n/// Have fun :)\n\
    func eat(number: Int, need: Int, remaining: Int) -> [Int] {\n    return [number\
    \ + min(need, remaining), remaining - min(need, remaining)]\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(eat(number: 5, need: 6, remaining: 10) == [11, 4])\nassert(eat(number:\
    \ 4, need: 8, remaining: 9) == [12, 1])\nassert(eat(number: 1, need: 10, remaining:\
    \ 10) == [11, 0])\nassert(eat(number: 2, need: 11, remaining: 5) == [7, 0])\n\
    assert(eat(number: 4, need: 5, remaining: 7) == [9, 2])\nassert(eat(number: 4,\
    \ need: 5, remaining: 1) == [5, 0])"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660014019
- exit_code: -4
  program: "\n/// You're a hungry rabbit, and you already have eaten a certain number\
    \ of carrots,\n/// but now you need to eat more carrots to complete the day's\
    \ meals.\n/// you should return an array of [ total number of eaten carrots after\
    \ your meals,\n/// the number of carrots left after your meals ]\n/// if there\
    \ are not enough remaining carrots, you will eat all remaining carrots, but will\
    \ still be hungry.\n/// Example:\n/// >>> eat(number: 5, need: 6, remaining: 10)\n\
    /// [11, 4]\n/// >>> eat(number: 4, need: 8, remaining: 9)\n/// [12, 1]\n/// >>>\
    \ eat(number: 1, need: 10, remaining: 10)\n/// [11, 0]\n/// >>> eat(number: 2,\
    \ need: 11, remaining: 5)\n/// [7, 0]\n/// Variables:\n/// @number : integer\n\
    /// the number of carrots that you have eaten.\n/// @need : integer\n/// the number\
    \ of carrots that you need to eat.\n/// @remaining : integer\n/// the number of\
    \ remaining carrots thet exist in stock\n/// Constrain:\n/// * 0 <= number <=\
    \ 1000\n/// * 0 <= need <= 1000\n/// * 0 <= remaining <= 1000\n/// Have fun :)\n\
    func eat(number: Int, need: Int, remaining: Int) -> [Int] {\n  var carrots = number\n\
    \  if remaining < (number + need) {\n    carrots += remaining\n  } else {\n  \
    \  carrots += need\n  }\n  return [carrots, remaining - (carrots - number)]\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(eat(number: 5, need: 6, remaining: 10) == [11,\
    \ 4])\nassert(eat(number: 4, need: 8, remaining: 9) == [12, 1])\nassert(eat(number:\
    \ 1, need: 10, remaining: 10) == [11, 0])\nassert(eat(number: 2, need: 11, remaining:\
    \ 5) == [7, 0])\nassert(eat(number: 4, need: 5, remaining: 7) == [9, 2])\nassert(eat(number:\
    \ 4, need: 5, remaining: 1) == [5, 0])"
  status: Exception
  stderr: 'tmp_46deu38/tmp_46deu38.swift:51: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b8f91d90c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b8f91a87b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b8f91a87988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b8f91a867b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmp_46deu38                        0x0000563d5c938384 <unavailable> + 4996

    5    libc.so.6                          0x00002b8f91f7c460 __libc_start_main +
    245

    6    tmp_46deu38                        0x0000563d5c937fc9 <unavailable> + 4041

    '
  stdout: ''
  timestamp: 1660014019
- exit_code: -4
  program: "\n/// You're a hungry rabbit, and you already have eaten a certain number\
    \ of carrots,\n/// but now you need to eat more carrots to complete the day's\
    \ meals.\n/// you should return an array of [ total number of eaten carrots after\
    \ your meals,\n/// the number of carrots left after your meals ]\n/// if there\
    \ are not enough remaining carrots, you will eat all remaining carrots, but will\
    \ still be hungry.\n/// Example:\n/// >>> eat(number: 5, need: 6, remaining: 10)\n\
    /// [11, 4]\n/// >>> eat(number: 4, need: 8, remaining: 9)\n/// [12, 1]\n/// >>>\
    \ eat(number: 1, need: 10, remaining: 10)\n/// [11, 0]\n/// >>> eat(number: 2,\
    \ need: 11, remaining: 5)\n/// [7, 0]\n/// Variables:\n/// @number : integer\n\
    /// the number of carrots that you have eaten.\n/// @need : integer\n/// the number\
    \ of carrots that you need to eat.\n/// @remaining : integer\n/// the number of\
    \ remaining carrots thet exist in stock\n/// Constrain:\n/// * 0 <= number <=\
    \ 1000\n/// * 0 <= need <= 1000\n/// * 0 <= remaining <= 1000\n/// Have fun :)\n\
    func eat(number: Int, need: Int, remaining: Int) -> [Int] {\n    return [0, 0]\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(eat(number: 5, need: 6, remaining: 10) == [11,\
    \ 4])\nassert(eat(number: 4, need: 8, remaining: 9) == [12, 1])\nassert(eat(number:\
    \ 1, need: 10, remaining: 10) == [11, 0])\nassert(eat(number: 2, need: 11, remaining:\
    \ 5) == [7, 0])\nassert(eat(number: 4, need: 5, remaining: 7) == [9, 2])\nassert(eat(number:\
    \ 4, need: 5, remaining: 1) == [5, 0])"
  status: Exception
  stderr: 'tmpes0rme1m/tmpes0rme1m.swift:45: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002ab15656fc80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002ab156266b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002ab156266988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002ab1562657b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpes0rme1m                        0x000055d20b065384 <unavailable> + 4996

    5    libc.so.6                          0x00002ab15675b460 __libc_start_main +
    245

    6    tmpes0rme1m                        0x000055d20b064fc9 <unavailable> + 4041

    '
  stdout: ''
  timestamp: 1660014019
- exit_code: 0
  program: "\n/// You're a hungry rabbit, and you already have eaten a certain number\
    \ of carrots,\n/// but now you need to eat more carrots to complete the day's\
    \ meals.\n/// you should return an array of [ total number of eaten carrots after\
    \ your meals,\n/// the number of carrots left after your meals ]\n/// if there\
    \ are not enough remaining carrots, you will eat all remaining carrots, but will\
    \ still be hungry.\n/// Example:\n/// >>> eat(number: 5, need: 6, remaining: 10)\n\
    /// [11, 4]\n/// >>> eat(number: 4, need: 8, remaining: 9)\n/// [12, 1]\n/// >>>\
    \ eat(number: 1, need: 10, remaining: 10)\n/// [11, 0]\n/// >>> eat(number: 2,\
    \ need: 11, remaining: 5)\n/// [7, 0]\n/// Variables:\n/// @number : integer\n\
    /// the number of carrots that you have eaten.\n/// @need : integer\n/// the number\
    \ of carrots that you need to eat.\n/// @remaining : integer\n/// the number of\
    \ remaining carrots thet exist in stock\n/// Constrain:\n/// * 0 <= number <=\
    \ 1000\n/// * 0 <= need <= 1000\n/// * 0 <= remaining <= 1000\n/// Have fun :)\n\
    func eat(number: Int, need: Int, remaining: Int) -> [Int] {\n    return [(min(need,\
    \ remaining) + number), max(0, remaining - need)]\n}\n\n\nfunc ==(left: [(Int,\
    \ Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n\
    \        return false\n    }\n    for (l, r) in zip(left, right) {\n        if\
    \ l != r {\n            return false\n        }\n    }\n    return true\n}\n \
    \           \nassert(eat(number: 5, need: 6, remaining: 10) == [11, 4])\nassert(eat(number:\
    \ 4, need: 8, remaining: 9) == [12, 1])\nassert(eat(number: 1, need: 10, remaining:\
    \ 10) == [11, 0])\nassert(eat(number: 2, need: 11, remaining: 5) == [7, 0])\n\
    assert(eat(number: 4, need: 5, remaining: 7) == [9, 2])\nassert(eat(number: 4,\
    \ need: 5, remaining: 1) == [5, 0])"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660014019
- exit_code: 0
  program: "\n/// You're a hungry rabbit, and you already have eaten a certain number\
    \ of carrots,\n/// but now you need to eat more carrots to complete the day's\
    \ meals.\n/// you should return an array of [ total number of eaten carrots after\
    \ your meals,\n/// the number of carrots left after your meals ]\n/// if there\
    \ are not enough remaining carrots, you will eat all remaining carrots, but will\
    \ still be hungry.\n/// Example:\n/// >>> eat(number: 5, need: 6, remaining: 10)\n\
    /// [11, 4]\n/// >>> eat(number: 4, need: 8, remaining: 9)\n/// [12, 1]\n/// >>>\
    \ eat(number: 1, need: 10, remaining: 10)\n/// [11, 0]\n/// >>> eat(number: 2,\
    \ need: 11, remaining: 5)\n/// [7, 0]\n/// Variables:\n/// @number : integer\n\
    /// the number of carrots that you have eaten.\n/// @need : integer\n/// the number\
    \ of carrots that you need to eat.\n/// @remaining : integer\n/// the number of\
    \ remaining carrots thet exist in stock\n/// Constrain:\n/// * 0 <= number <=\
    \ 1000\n/// * 0 <= need <= 1000\n/// * 0 <= remaining <= 1000\n/// Have fun :)\n\
    func eat(number: Int, need: Int, remaining: Int) -> [Int] {\n    // Write your\
    \ code here\n    var result = number + min(need, remaining)\n    var left = max(0,\
    \ remaining - need)\n    return [result, left]\n}\n\n\nfunc ==(left: [(Int, Int)],\
    \ right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n       \
    \ return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r\
    \ {\n            return false\n        }\n    }\n    return true\n}\n        \
    \    \nassert(eat(number: 5, need: 6, remaining: 10) == [11, 4])\nassert(eat(number:\
    \ 4, need: 8, remaining: 9) == [12, 1])\nassert(eat(number: 1, need: 10, remaining:\
    \ 10) == [11, 0])\nassert(eat(number: 2, need: 11, remaining: 5) == [7, 0])\n\
    assert(eat(number: 4, need: 5, remaining: 7) == [9, 2])\nassert(eat(number: 4,\
    \ need: 5, remaining: 1) == [5, 0])"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660014019
- exit_code: -4
  program: "\n/// You're a hungry rabbit, and you already have eaten a certain number\
    \ of carrots,\n/// but now you need to eat more carrots to complete the day's\
    \ meals.\n/// you should return an array of [ total number of eaten carrots after\
    \ your meals,\n/// the number of carrots left after your meals ]\n/// if there\
    \ are not enough remaining carrots, you will eat all remaining carrots, but will\
    \ still be hungry.\n/// Example:\n/// >>> eat(number: 5, need: 6, remaining: 10)\n\
    /// [11, 4]\n/// >>> eat(number: 4, need: 8, remaining: 9)\n/// [12, 1]\n/// >>>\
    \ eat(number: 1, need: 10, remaining: 10)\n/// [11, 0]\n/// >>> eat(number: 2,\
    \ need: 11, remaining: 5)\n/// [7, 0]\n/// Variables:\n/// @number : integer\n\
    /// the number of carrots that you have eaten.\n/// @need : integer\n/// the number\
    \ of carrots that you need to eat.\n/// @remaining : integer\n/// the number of\
    \ remaining carrots thet exist in stock\n/// Constrain:\n/// * 0 <= number <=\
    \ 1000\n/// * 0 <= need <= 1000\n/// * 0 <= remaining <= 1000\n/// Have fun :)\n\
    func eat(number: Int, need: Int, remaining: Int) -> [Int] {\n    let total = number\
    \ + remaining\n    return [min(total, need), max(total - need, 0)]\n}\n\n\nfunc\
    \ ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count !=\
    \ right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(eat(number: 5, need: 6, remaining: 10) == [11,\
    \ 4])\nassert(eat(number: 4, need: 8, remaining: 9) == [12, 1])\nassert(eat(number:\
    \ 1, need: 10, remaining: 10) == [11, 0])\nassert(eat(number: 2, need: 11, remaining:\
    \ 5) == [7, 0])\nassert(eat(number: 4, need: 5, remaining: 7) == [9, 2])\nassert(eat(number:\
    \ 4, need: 5, remaining: 1) == [5, 0])"
  status: Exception
  stderr: 'tmpmz16z1vl/tmpmz16z1vl.swift:46: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b07d8f4bc80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b07d8c42b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b07d8c42988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b07d8c417b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpmz16z1vl                        0x00005589a9cc1474 <unavailable> + 5236

    5    libc.so.6                          0x00002b07d9137460 __libc_start_main +
    245

    6    tmpmz16z1vl                        0x00005589a9cc10b9 <unavailable> + 4281

    '
  stdout: ''
  timestamp: 1660013825
- exit_code: -4
  program: "\n/// You're a hungry rabbit, and you already have eaten a certain number\
    \ of carrots,\n/// but now you need to eat more carrots to complete the day's\
    \ meals.\n/// you should return an array of [ total number of eaten carrots after\
    \ your meals,\n/// the number of carrots left after your meals ]\n/// if there\
    \ are not enough remaining carrots, you will eat all remaining carrots, but will\
    \ still be hungry.\n/// Example:\n/// >>> eat(number: 5, need: 6, remaining: 10)\n\
    /// [11, 4]\n/// >>> eat(number: 4, need: 8, remaining: 9)\n/// [12, 1]\n/// >>>\
    \ eat(number: 1, need: 10, remaining: 10)\n/// [11, 0]\n/// >>> eat(number: 2,\
    \ need: 11, remaining: 5)\n/// [7, 0]\n/// Variables:\n/// @number : integer\n\
    /// the number of carrots that you have eaten.\n/// @need : integer\n/// the number\
    \ of carrots that you need to eat.\n/// @remaining : integer\n/// the number of\
    \ remaining carrots thet exist in stock\n/// Constrain:\n/// * 0 <= number <=\
    \ 1000\n/// * 0 <= need <= 1000\n/// * 0 <= remaining <= 1000\n/// Have fun :)\n\
    func eat(number: Int, need: Int, remaining: Int) -> [Int] {\n    let left = number\
    \ + remaining\n    return [left, max(0, left - need)]\n}\n\n\nfunc ==(left: [(Int,\
    \ Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n\
    \        return false\n    }\n    for (l, r) in zip(left, right) {\n        if\
    \ l != r {\n            return false\n        }\n    }\n    return true\n}\n \
    \           \nassert(eat(number: 5, need: 6, remaining: 10) == [11, 4])\nassert(eat(number:\
    \ 4, need: 8, remaining: 9) == [12, 1])\nassert(eat(number: 1, need: 10, remaining:\
    \ 10) == [11, 0])\nassert(eat(number: 2, need: 11, remaining: 5) == [7, 0])\n\
    assert(eat(number: 4, need: 5, remaining: 7) == [9, 2])\nassert(eat(number: 4,\
    \ need: 5, remaining: 1) == [5, 0])"
  status: Exception
  stderr: 'tmps_cszi19/tmps_cszi19.swift:46: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002ad67be23c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002ad67bb1ab6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002ad67bb1a988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002ad67bb197b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmps_cszi19                        0x00005614958f5424 <unavailable> + 5156

    5    libc.so.6                          0x00002ad67c00f460 __libc_start_main +
    245

    6    tmps_cszi19                        0x00005614958f5069 <unavailable> + 4201

    '
  stdout: ''
  timestamp: 1660014019
- exit_code: 0
  program: "\n/// You're a hungry rabbit, and you already have eaten a certain number\
    \ of carrots,\n/// but now you need to eat more carrots to complete the day's\
    \ meals.\n/// you should return an array of [ total number of eaten carrots after\
    \ your meals,\n/// the number of carrots left after your meals ]\n/// if there\
    \ are not enough remaining carrots, you will eat all remaining carrots, but will\
    \ still be hungry.\n/// Example:\n/// >>> eat(number: 5, need: 6, remaining: 10)\n\
    /// [11, 4]\n/// >>> eat(number: 4, need: 8, remaining: 9)\n/// [12, 1]\n/// >>>\
    \ eat(number: 1, need: 10, remaining: 10)\n/// [11, 0]\n/// >>> eat(number: 2,\
    \ need: 11, remaining: 5)\n/// [7, 0]\n/// Variables:\n/// @number : integer\n\
    /// the number of carrots that you have eaten.\n/// @need : integer\n/// the number\
    \ of carrots that you need to eat.\n/// @remaining : integer\n/// the number of\
    \ remaining carrots thet exist in stock\n/// Constrain:\n/// * 0 <= number <=\
    \ 1000\n/// * 0 <= need <= 1000\n/// * 0 <= remaining <= 1000\n/// Have fun :)\n\
    func eat(number: Int, need: Int, remaining: Int) -> [Int] {\n    var totalEaten\
    \ = number\n    var carrotsLeft = remaining\n    for _ in number..<(number + need)\
    \ {\n        if carrotsLeft > 0 {\n            totalEaten += 1\n            carrotsLeft\
    \ -= 1\n        }\n    }\n    return [totalEaten, carrotsLeft]\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(eat(number: 5, need: 6, remaining: 10) == [11, 4])\nassert(eat(number:\
    \ 4, need: 8, remaining: 9) == [12, 1])\nassert(eat(number: 1, need: 10, remaining:\
    \ 10) == [11, 0])\nassert(eat(number: 2, need: 11, remaining: 5) == [7, 0])\n\
    assert(eat(number: 4, need: 5, remaining: 7) == [9, 2])\nassert(eat(number: 4,\
    \ need: 5, remaining: 1) == [5, 0])"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660014019
- exit_code: -4
  program: "\n/// You're a hungry rabbit, and you already have eaten a certain number\
    \ of carrots,\n/// but now you need to eat more carrots to complete the day's\
    \ meals.\n/// you should return an array of [ total number of eaten carrots after\
    \ your meals,\n/// the number of carrots left after your meals ]\n/// if there\
    \ are not enough remaining carrots, you will eat all remaining carrots, but will\
    \ still be hungry.\n/// Example:\n/// >>> eat(number: 5, need: 6, remaining: 10)\n\
    /// [11, 4]\n/// >>> eat(number: 4, need: 8, remaining: 9)\n/// [12, 1]\n/// >>>\
    \ eat(number: 1, need: 10, remaining: 10)\n/// [11, 0]\n/// >>> eat(number: 2,\
    \ need: 11, remaining: 5)\n/// [7, 0]\n/// Variables:\n/// @number : integer\n\
    /// the number of carrots that you have eaten.\n/// @need : integer\n/// the number\
    \ of carrots that you need to eat.\n/// @remaining : integer\n/// the number of\
    \ remaining carrots thet exist in stock\n/// Constrain:\n/// * 0 <= number <=\
    \ 1000\n/// * 0 <= need <= 1000\n/// * 0 <= remaining <= 1000\n/// Have fun :)\n\
    func eat(number: Int, need: Int, remaining: Int) -> [Int] {\n    var total = number\
    \ + remaining\n    let need = need - number\n    if need > remaining {\n     \
    \   total -= (need - remaining)\n    }\n    return [total, total > need ? total\
    \ - need : 0]\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool\
    \ {\n    if left.count != right.count {\n        return false\n    }\n    for\
    \ (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(eat(number: 5, need:\
    \ 6, remaining: 10) == [11, 4])\nassert(eat(number: 4, need: 8, remaining: 9)\
    \ == [12, 1])\nassert(eat(number: 1, need: 10, remaining: 10) == [11, 0])\nassert(eat(number:\
    \ 2, need: 11, remaining: 5) == [7, 0])\nassert(eat(number: 4, need: 5, remaining:\
    \ 7) == [9, 2])\nassert(eat(number: 4, need: 5, remaining: 1) == [5, 0])"
  status: Exception
  stderr: 'tmpahx609u7/tmpahx609u7.swift:50: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b58c1b79c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b58c1870b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b58c1870988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b58c186f7b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpahx609u7                        0x00005631c8387384 <unavailable> + 4996

    5    libc.so.6                          0x00002b58c1d65460 __libc_start_main +
    245

    6    tmpahx609u7                        0x00005631c8386fc9 <unavailable> + 4041

    '
  stdout: ''
  timestamp: 1660014019
- exit_code: -4
  program: "\n/// You're a hungry rabbit, and you already have eaten a certain number\
    \ of carrots,\n/// but now you need to eat more carrots to complete the day's\
    \ meals.\n/// you should return an array of [ total number of eaten carrots after\
    \ your meals,\n/// the number of carrots left after your meals ]\n/// if there\
    \ are not enough remaining carrots, you will eat all remaining carrots, but will\
    \ still be hungry.\n/// Example:\n/// >>> eat(number: 5, need: 6, remaining: 10)\n\
    /// [11, 4]\n/// >>> eat(number: 4, need: 8, remaining: 9)\n/// [12, 1]\n/// >>>\
    \ eat(number: 1, need: 10, remaining: 10)\n/// [11, 0]\n/// >>> eat(number: 2,\
    \ need: 11, remaining: 5)\n/// [7, 0]\n/// Variables:\n/// @number : integer\n\
    /// the number of carrots that you have eaten.\n/// @need : integer\n/// the number\
    \ of carrots that you need to eat.\n/// @remaining : integer\n/// the number of\
    \ remaining carrots thet exist in stock\n/// Constrain:\n/// * 0 <= number <=\
    \ 1000\n/// * 0 <= need <= 1000\n/// * 0 <= remaining <= 1000\n/// Have fun :)\n\
    func eat(number: Int, need: Int, remaining: Int) -> [Int] {\n    return [min(need\
    \ + number, 1000), remaining - min(need, remaining)]\n}\n\n\nfunc ==(left: [(Int,\
    \ Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n\
    \        return false\n    }\n    for (l, r) in zip(left, right) {\n        if\
    \ l != r {\n            return false\n        }\n    }\n    return true\n}\n \
    \           \nassert(eat(number: 5, need: 6, remaining: 10) == [11, 4])\nassert(eat(number:\
    \ 4, need: 8, remaining: 9) == [12, 1])\nassert(eat(number: 1, need: 10, remaining:\
    \ 10) == [11, 0])\nassert(eat(number: 2, need: 11, remaining: 5) == [7, 0])\n\
    assert(eat(number: 4, need: 5, remaining: 7) == [9, 2])\nassert(eat(number: 4,\
    \ need: 5, remaining: 1) == [5, 0])"
  status: Exception
  stderr: 'tmpdxxqkkng/tmpdxxqkkng.swift:48: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b85eb5c0c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b85eb2b7b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b85eb2b7988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b85eb2b67b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpdxxqkkng                        0x000056403c4176f8 <unavailable> + 5880

    5    libc.so.6                          0x00002b85eb7ac460 __libc_start_main +
    245

    6    tmpdxxqkkng                        0x000056403c417069 <unavailable> + 4201

    '
  stdout: ''
  timestamp: 1660014019
- exit_code: -4
  program: "\n/// You're a hungry rabbit, and you already have eaten a certain number\
    \ of carrots,\n/// but now you need to eat more carrots to complete the day's\
    \ meals.\n/// you should return an array of [ total number of eaten carrots after\
    \ your meals,\n/// the number of carrots left after your meals ]\n/// if there\
    \ are not enough remaining carrots, you will eat all remaining carrots, but will\
    \ still be hungry.\n/// Example:\n/// >>> eat(number: 5, need: 6, remaining: 10)\n\
    /// [11, 4]\n/// >>> eat(number: 4, need: 8, remaining: 9)\n/// [12, 1]\n/// >>>\
    \ eat(number: 1, need: 10, remaining: 10)\n/// [11, 0]\n/// >>> eat(number: 2,\
    \ need: 11, remaining: 5)\n/// [7, 0]\n/// Variables:\n/// @number : integer\n\
    /// the number of carrots that you have eaten.\n/// @need : integer\n/// the number\
    \ of carrots that you need to eat.\n/// @remaining : integer\n/// the number of\
    \ remaining carrots thet exist in stock\n/// Constrain:\n/// * 0 <= number <=\
    \ 1000\n/// * 0 <= need <= 1000\n/// * 0 <= remaining <= 1000\n/// Have fun :)\n\
    func eat(number: Int, need: Int, remaining: Int) -> [Int] {\n  var left = remaining\
    \ - (need - number)\n  if left < 0 {\n    left = 0\n  }\n  return [number + remaining\
    \ - left, left]\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool\
    \ {\n    if left.count != right.count {\n        return false\n    }\n    for\
    \ (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(eat(number: 5, need:\
    \ 6, remaining: 10) == [11, 4])\nassert(eat(number: 4, need: 8, remaining: 9)\
    \ == [12, 1])\nassert(eat(number: 1, need: 10, remaining: 10) == [11, 0])\nassert(eat(number:\
    \ 2, need: 11, remaining: 5) == [7, 0])\nassert(eat(number: 4, need: 5, remaining:\
    \ 7) == [9, 2])\nassert(eat(number: 4, need: 5, remaining: 1) == [5, 0])"
  status: Exception
  stderr: 'tmpfq98tf3w/tmpfq98tf3w.swift:49: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b30460efc80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b3045de6b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b3045de6988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b3045de57b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpfq98tf3w                        0x000055f386859384 <unavailable> + 4996

    5    libc.so.6                          0x00002b30462db460 __libc_start_main +
    245

    6    tmpfq98tf3w                        0x000055f386858fc9 <unavailable> + 4041

    '
  stdout: ''
  timestamp: 1660014019
- exit_code: 0
  program: "\n/// You're a hungry rabbit, and you already have eaten a certain number\
    \ of carrots,\n/// but now you need to eat more carrots to complete the day's\
    \ meals.\n/// you should return an array of [ total number of eaten carrots after\
    \ your meals,\n/// the number of carrots left after your meals ]\n/// if there\
    \ are not enough remaining carrots, you will eat all remaining carrots, but will\
    \ still be hungry.\n/// Example:\n/// >>> eat(number: 5, need: 6, remaining: 10)\n\
    /// [11, 4]\n/// >>> eat(number: 4, need: 8, remaining: 9)\n/// [12, 1]\n/// >>>\
    \ eat(number: 1, need: 10, remaining: 10)\n/// [11, 0]\n/// >>> eat(number: 2,\
    \ need: 11, remaining: 5)\n/// [7, 0]\n/// Variables:\n/// @number : integer\n\
    /// the number of carrots that you have eaten.\n/// @need : integer\n/// the number\
    \ of carrots that you need to eat.\n/// @remaining : integer\n/// the number of\
    \ remaining carrots thet exist in stock\n/// Constrain:\n/// * 0 <= number <=\
    \ 1000\n/// * 0 <= need <= 1000\n/// * 0 <= remaining <= 1000\n/// Have fun :)\n\
    func eat(number: Int, need: Int, remaining: Int) -> [Int] {\n    let carrot =\
    \ number + min(need, remaining)\n    return [carrot, remaining - min(need, remaining)]\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(eat(number: 5, need: 6, remaining: 10) == [11,\
    \ 4])\nassert(eat(number: 4, need: 8, remaining: 9) == [12, 1])\nassert(eat(number:\
    \ 1, need: 10, remaining: 10) == [11, 0])\nassert(eat(number: 2, need: 11, remaining:\
    \ 5) == [7, 0])\nassert(eat(number: 4, need: 5, remaining: 7) == [9, 2])\nassert(eat(number:\
    \ 4, need: 5, remaining: 1) == [5, 0])"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660014019
- exit_code: -4
  program: "\n/// You're a hungry rabbit, and you already have eaten a certain number\
    \ of carrots,\n/// but now you need to eat more carrots to complete the day's\
    \ meals.\n/// you should return an array of [ total number of eaten carrots after\
    \ your meals,\n/// the number of carrots left after your meals ]\n/// if there\
    \ are not enough remaining carrots, you will eat all remaining carrots, but will\
    \ still be hungry.\n/// Example:\n/// >>> eat(number: 5, need: 6, remaining: 10)\n\
    /// [11, 4]\n/// >>> eat(number: 4, need: 8, remaining: 9)\n/// [12, 1]\n/// >>>\
    \ eat(number: 1, need: 10, remaining: 10)\n/// [11, 0]\n/// >>> eat(number: 2,\
    \ need: 11, remaining: 5)\n/// [7, 0]\n/// Variables:\n/// @number : integer\n\
    /// the number of carrots that you have eaten.\n/// @need : integer\n/// the number\
    \ of carrots that you need to eat.\n/// @remaining : integer\n/// the number of\
    \ remaining carrots thet exist in stock\n/// Constrain:\n/// * 0 <= number <=\
    \ 1000\n/// * 0 <= need <= 1000\n/// * 0 <= remaining <= 1000\n/// Have fun :)\n\
    func eat(number: Int, need: Int, remaining: Int) -> [Int] {\n    \n    let totalAfterMeals\
    \ = number + need\n    let totalRemaining = remaining - need\n    \n    if remaining\
    \ < number + need {\n        return [totalAfterMeals, 0]\n    } else {\n     \
    \   return [totalAfterMeals, totalRemaining]\n    }\n}\n\n\nfunc ==(left: [(Int,\
    \ Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n\
    \        return false\n    }\n    for (l, r) in zip(left, right) {\n        if\
    \ l != r {\n            return false\n        }\n    }\n    return true\n}\n \
    \           \nassert(eat(number: 5, need: 6, remaining: 10) == [11, 4])\nassert(eat(number:\
    \ 4, need: 8, remaining: 9) == [12, 1])\nassert(eat(number: 1, need: 10, remaining:\
    \ 10) == [11, 0])\nassert(eat(number: 2, need: 11, remaining: 5) == [7, 0])\n\
    assert(eat(number: 4, need: 5, remaining: 7) == [9, 2])\nassert(eat(number: 4,\
    \ need: 5, remaining: 1) == [5, 0])"
  status: Exception
  stderr: 'tmpbaowug1h/tmpbaowug1h.swift:53: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b9ce6561c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b9ce6258b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b9ce6258988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b9ce62577b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpbaowug1h                        0x000055f6df2dc384 <unavailable> + 4996

    5    libc.so.6                          0x00002b9ce674d460 __libc_start_main +
    245

    6    tmpbaowug1h                        0x000055f6df2dbfc9 <unavailable> + 4041

    '
  stdout: ''
  timestamp: 1660014019
- exit_code: -4
  program: "\n/// You're a hungry rabbit, and you already have eaten a certain number\
    \ of carrots,\n/// but now you need to eat more carrots to complete the day's\
    \ meals.\n/// you should return an array of [ total number of eaten carrots after\
    \ your meals,\n/// the number of carrots left after your meals ]\n/// if there\
    \ are not enough remaining carrots, you will eat all remaining carrots, but will\
    \ still be hungry.\n/// Example:\n/// >>> eat(number: 5, need: 6, remaining: 10)\n\
    /// [11, 4]\n/// >>> eat(number: 4, need: 8, remaining: 9)\n/// [12, 1]\n/// >>>\
    \ eat(number: 1, need: 10, remaining: 10)\n/// [11, 0]\n/// >>> eat(number: 2,\
    \ need: 11, remaining: 5)\n/// [7, 0]\n/// Variables:\n/// @number : integer\n\
    /// the number of carrots that you have eaten.\n/// @need : integer\n/// the number\
    \ of carrots that you need to eat.\n/// @remaining : integer\n/// the number of\
    \ remaining carrots thet exist in stock\n/// Constrain:\n/// * 0 <= number <=\
    \ 1000\n/// * 0 <= need <= 1000\n/// * 0 <= remaining <= 1000\n/// Have fun :)\n\
    func eat(number: Int, need: Int, remaining: Int) -> [Int] {\n  // enter your code\
    \ here\n  let total = number + need\n  return [total, remaining > total ? remaining\
    \ - total : 0]\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool\
    \ {\n    if left.count != right.count {\n        return false\n    }\n    for\
    \ (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(eat(number: 5, need:\
    \ 6, remaining: 10) == [11, 4])\nassert(eat(number: 4, need: 8, remaining: 9)\
    \ == [12, 1])\nassert(eat(number: 1, need: 10, remaining: 10) == [11, 0])\nassert(eat(number:\
    \ 2, need: 11, remaining: 5) == [7, 0])\nassert(eat(number: 4, need: 5, remaining:\
    \ 7) == [9, 2])\nassert(eat(number: 4, need: 5, remaining: 1) == [5, 0])"
  status: Exception
  stderr: 'tmps6rrwnrv/tmps6rrwnrv.swift:47: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002ad690d59c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002ad690a50b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002ad690a50988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002ad690a4f7b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmps6rrwnrv                        0x00005556f5750384 <unavailable> + 4996

    5    libc.so.6                          0x00002ad690f45460 __libc_start_main +
    245

    6    tmps6rrwnrv                        0x00005556f574ffc9 <unavailable> + 4041

    '
  stdout: ''
  timestamp: 1660014019
- exit_code: 0
  program: "\n/// You're a hungry rabbit, and you already have eaten a certain number\
    \ of carrots,\n/// but now you need to eat more carrots to complete the day's\
    \ meals.\n/// you should return an array of [ total number of eaten carrots after\
    \ your meals,\n/// the number of carrots left after your meals ]\n/// if there\
    \ are not enough remaining carrots, you will eat all remaining carrots, but will\
    \ still be hungry.\n/// Example:\n/// >>> eat(number: 5, need: 6, remaining: 10)\n\
    /// [11, 4]\n/// >>> eat(number: 4, need: 8, remaining: 9)\n/// [12, 1]\n/// >>>\
    \ eat(number: 1, need: 10, remaining: 10)\n/// [11, 0]\n/// >>> eat(number: 2,\
    \ need: 11, remaining: 5)\n/// [7, 0]\n/// Variables:\n/// @number : integer\n\
    /// the number of carrots that you have eaten.\n/// @need : integer\n/// the number\
    \ of carrots that you need to eat.\n/// @remaining : integer\n/// the number of\
    \ remaining carrots thet exist in stock\n/// Constrain:\n/// * 0 <= number <=\
    \ 1000\n/// * 0 <= need <= 1000\n/// * 0 <= remaining <= 1000\n/// Have fun :)\n\
    func eat(number: Int, need: Int, remaining: Int) -> [Int] {\n    return [ number\
    \ + min(remaining, need), max(0, remaining - need) ]\n}\n\n\nfunc ==(left: [(Int,\
    \ Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n\
    \        return false\n    }\n    for (l, r) in zip(left, right) {\n        if\
    \ l != r {\n            return false\n        }\n    }\n    return true\n}\n \
    \           \nassert(eat(number: 5, need: 6, remaining: 10) == [11, 4])\nassert(eat(number:\
    \ 4, need: 8, remaining: 9) == [12, 1])\nassert(eat(number: 1, need: 10, remaining:\
    \ 10) == [11, 0])\nassert(eat(number: 2, need: 11, remaining: 5) == [7, 0])\n\
    assert(eat(number: 4, need: 5, remaining: 7) == [9, 2])\nassert(eat(number: 4,\
    \ need: 5, remaining: 1) == [5, 0])"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660014019
- exit_code: -4
  program: "\n/// You're a hungry rabbit, and you already have eaten a certain number\
    \ of carrots,\n/// but now you need to eat more carrots to complete the day's\
    \ meals.\n/// you should return an array of [ total number of eaten carrots after\
    \ your meals,\n/// the number of carrots left after your meals ]\n/// if there\
    \ are not enough remaining carrots, you will eat all remaining carrots, but will\
    \ still be hungry.\n/// Example:\n/// >>> eat(number: 5, need: 6, remaining: 10)\n\
    /// [11, 4]\n/// >>> eat(number: 4, need: 8, remaining: 9)\n/// [12, 1]\n/// >>>\
    \ eat(number: 1, need: 10, remaining: 10)\n/// [11, 0]\n/// >>> eat(number: 2,\
    \ need: 11, remaining: 5)\n/// [7, 0]\n/// Variables:\n/// @number : integer\n\
    /// the number of carrots that you have eaten.\n/// @need : integer\n/// the number\
    \ of carrots that you need to eat.\n/// @remaining : integer\n/// the number of\
    \ remaining carrots thet exist in stock\n/// Constrain:\n/// * 0 <= number <=\
    \ 1000\n/// * 0 <= need <= 1000\n/// * 0 <= remaining <= 1000\n/// Have fun :)\n\
    func eat(number: Int, need: Int, remaining: Int) -> [Int] {\n  if number >= need\
    \ {\n    return [number, remaining]\n  }\n  let needAdd = need - number\n  if\
    \ needAdd <= remaining {\n    return [number + needAdd, remaining - needAdd]\n\
    \  }\n  return [number + remaining, 0]\n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(eat(number: 5, need: 6, remaining: 10) == [11, 4])\nassert(eat(number:\
    \ 4, need: 8, remaining: 9) == [12, 1])\nassert(eat(number: 1, need: 10, remaining:\
    \ 10) == [11, 0])\nassert(eat(number: 2, need: 11, remaining: 5) == [7, 0])\n\
    assert(eat(number: 4, need: 5, remaining: 7) == [9, 2])\nassert(eat(number: 4,\
    \ need: 5, remaining: 1) == [5, 0])"
  status: Exception
  stderr: 'tmp9duodm9v/tmp9duodm9v.swift:52: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b5bf4f59c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b5bf4c50b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b5bf4c50988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b5bf4c4f7b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmp9duodm9v                        0x000055a49e837384 <unavailable> + 4996

    5    libc.so.6                          0x00002b5bf5145460 __libc_start_main +
    245

    6    tmp9duodm9v                        0x000055a49e836fc9 <unavailable> + 4041

    '
  stdout: ''
  timestamp: 1660014019
- exit_code: -4
  program: "\n/// You're a hungry rabbit, and you already have eaten a certain number\
    \ of carrots,\n/// but now you need to eat more carrots to complete the day's\
    \ meals.\n/// you should return an array of [ total number of eaten carrots after\
    \ your meals,\n/// the number of carrots left after your meals ]\n/// if there\
    \ are not enough remaining carrots, you will eat all remaining carrots, but will\
    \ still be hungry.\n/// Example:\n/// >>> eat(number: 5, need: 6, remaining: 10)\n\
    /// [11, 4]\n/// >>> eat(number: 4, need: 8, remaining: 9)\n/// [12, 1]\n/// >>>\
    \ eat(number: 1, need: 10, remaining: 10)\n/// [11, 0]\n/// >>> eat(number: 2,\
    \ need: 11, remaining: 5)\n/// [7, 0]\n/// Variables:\n/// @number : integer\n\
    /// the number of carrots that you have eaten.\n/// @need : integer\n/// the number\
    \ of carrots that you need to eat.\n/// @remaining : integer\n/// the number of\
    \ remaining carrots thet exist in stock\n/// Constrain:\n/// * 0 <= number <=\
    \ 1000\n/// * 0 <= need <= 1000\n/// * 0 <= remaining <= 1000\n/// Have fun :)\n\
    func eat(number: Int, need: Int, remaining: Int) -> [Int] {\n    let total = number\
    \ + need <= remaining ? number + need : remaining\n    return [total, remaining\
    \ - total]\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n\
    \    if left.count != right.count {\n        return false\n    }\n    for (l,\
    \ r) in zip(left, right) {\n        if l != r {\n            return false\n  \
    \      }\n    }\n    return true\n}\n            \nassert(eat(number: 5, need:\
    \ 6, remaining: 10) == [11, 4])\nassert(eat(number: 4, need: 8, remaining: 9)\
    \ == [12, 1])\nassert(eat(number: 1, need: 10, remaining: 10) == [11, 0])\nassert(eat(number:\
    \ 2, need: 11, remaining: 5) == [7, 0])\nassert(eat(number: 4, need: 5, remaining:\
    \ 7) == [9, 2])\nassert(eat(number: 4, need: 5, remaining: 1) == [5, 0])"
  status: Exception
  stderr: 'tmpgldls6ug/tmpgldls6ug.swift:46: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b036e4b0c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b036e1a7b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b036e1a7988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b036e1a67b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpgldls6ug                        0x00005645e7644384 <unavailable> + 4996

    5    libc.so.6                          0x00002b036e69c460 __libc_start_main +
    245

    6    tmpgldls6ug                        0x00005645e7643fc9 <unavailable> + 4041

    '
  stdout: ''
  timestamp: 1660014019
- exit_code: -4
  program: "\n/// You're a hungry rabbit, and you already have eaten a certain number\
    \ of carrots,\n/// but now you need to eat more carrots to complete the day's\
    \ meals.\n/// you should return an array of [ total number of eaten carrots after\
    \ your meals,\n/// the number of carrots left after your meals ]\n/// if there\
    \ are not enough remaining carrots, you will eat all remaining carrots, but will\
    \ still be hungry.\n/// Example:\n/// >>> eat(number: 5, need: 6, remaining: 10)\n\
    /// [11, 4]\n/// >>> eat(number: 4, need: 8, remaining: 9)\n/// [12, 1]\n/// >>>\
    \ eat(number: 1, need: 10, remaining: 10)\n/// [11, 0]\n/// >>> eat(number: 2,\
    \ need: 11, remaining: 5)\n/// [7, 0]\n/// Variables:\n/// @number : integer\n\
    /// the number of carrots that you have eaten.\n/// @need : integer\n/// the number\
    \ of carrots that you need to eat.\n/// @remaining : integer\n/// the number of\
    \ remaining carrots thet exist in stock\n/// Constrain:\n/// * 0 <= number <=\
    \ 1000\n/// * 0 <= need <= 1000\n/// * 0 <= remaining <= 1000\n/// Have fun :)\n\
    func eat(number: Int, need: Int, remaining: Int) -> [Int] {\n    var numberEaten\
    \ = number\n    var remainingCarrots = remaining\n    while numberEaten < need\
    \ && remainingCarrots > 0 {\n        numberEaten += 1\n        remainingCarrots\
    \ -= 1\n    }\n    return [numberEaten, remainingCarrots]\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(eat(number: 5, need: 6, remaining: 10) == [11, 4])\nassert(eat(number:\
    \ 4, need: 8, remaining: 9) == [12, 1])\nassert(eat(number: 1, need: 10, remaining:\
    \ 10) == [11, 0])\nassert(eat(number: 2, need: 11, remaining: 5) == [7, 0])\n\
    assert(eat(number: 4, need: 5, remaining: 7) == [9, 2])\nassert(eat(number: 4,\
    \ need: 5, remaining: 1) == [5, 0])"
  status: Exception
  stderr: 'tmpu7bv3g_u/tmpu7bv3g_u.swift:51: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002af7b07bdc80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002af7b04b4b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002af7b04b4988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002af7b04b37b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpu7bv3g_u                        0x000055665ba78384 <unavailable> + 4996

    5    libc.so.6                          0x00002af7b09a9460 __libc_start_main +
    245

    6    tmpu7bv3g_u                        0x000055665ba77fc9 <unavailable> + 4041

    '
  stdout: ''
  timestamp: 1660014019
- exit_code: -4
  program: "\n/// You're a hungry rabbit, and you already have eaten a certain number\
    \ of carrots,\n/// but now you need to eat more carrots to complete the day's\
    \ meals.\n/// you should return an array of [ total number of eaten carrots after\
    \ your meals,\n/// the number of carrots left after your meals ]\n/// if there\
    \ are not enough remaining carrots, you will eat all remaining carrots, but will\
    \ still be hungry.\n/// Example:\n/// >>> eat(number: 5, need: 6, remaining: 10)\n\
    /// [11, 4]\n/// >>> eat(number: 4, need: 8, remaining: 9)\n/// [12, 1]\n/// >>>\
    \ eat(number: 1, need: 10, remaining: 10)\n/// [11, 0]\n/// >>> eat(number: 2,\
    \ need: 11, remaining: 5)\n/// [7, 0]\n/// Variables:\n/// @number : integer\n\
    /// the number of carrots that you have eaten.\n/// @need : integer\n/// the number\
    \ of carrots that you need to eat.\n/// @remaining : integer\n/// the number of\
    \ remaining carrots thet exist in stock\n/// Constrain:\n/// * 0 <= number <=\
    \ 1000\n/// * 0 <= need <= 1000\n/// * 0 <= remaining <= 1000\n/// Have fun :)\n\
    func eat(number: Int, need: Int, remaining: Int) -> [Int] {\n    let total = number\
    \ + remaining\n    let ate = min(total, need)\n    return [ate, total - ate]\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(eat(number: 5, need: 6, remaining: 10) == [11,\
    \ 4])\nassert(eat(number: 4, need: 8, remaining: 9) == [12, 1])\nassert(eat(number:\
    \ 1, need: 10, remaining: 10) == [11, 0])\nassert(eat(number: 2, need: 11, remaining:\
    \ 5) == [7, 0])\nassert(eat(number: 4, need: 5, remaining: 7) == [9, 2])\nassert(eat(number:\
    \ 4, need: 5, remaining: 1) == [5, 0])"
  status: Exception
  stderr: 'tmpwo4cclyk/tmpwo4cclyk.swift:47: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002af270ec5c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002af270bbcb6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002af270bbc988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002af270bbb7b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpwo4cclyk                        0x00005628238d6424 <unavailable> + 5156

    5    libc.so.6                          0x00002af2710b1460 __libc_start_main +
    245

    6    tmpwo4cclyk                        0x00005628238d6069 <unavailable> + 4201

    '
  stdout: ''
  timestamp: 1660014019
- exit_code: -4
  program: "\n/// You're a hungry rabbit, and you already have eaten a certain number\
    \ of carrots,\n/// but now you need to eat more carrots to complete the day's\
    \ meals.\n/// you should return an array of [ total number of eaten carrots after\
    \ your meals,\n/// the number of carrots left after your meals ]\n/// if there\
    \ are not enough remaining carrots, you will eat all remaining carrots, but will\
    \ still be hungry.\n/// Example:\n/// >>> eat(number: 5, need: 6, remaining: 10)\n\
    /// [11, 4]\n/// >>> eat(number: 4, need: 8, remaining: 9)\n/// [12, 1]\n/// >>>\
    \ eat(number: 1, need: 10, remaining: 10)\n/// [11, 0]\n/// >>> eat(number: 2,\
    \ need: 11, remaining: 5)\n/// [7, 0]\n/// Variables:\n/// @number : integer\n\
    /// the number of carrots that you have eaten.\n/// @need : integer\n/// the number\
    \ of carrots that you need to eat.\n/// @remaining : integer\n/// the number of\
    \ remaining carrots thet exist in stock\n/// Constrain:\n/// * 0 <= number <=\
    \ 1000\n/// * 0 <= need <= 1000\n/// * 0 <= remaining <= 1000\n/// Have fun :)\n\
    func eat(number: Int, need: Int, remaining: Int) -> [Int] {\n    return [0,0]\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(eat(number: 5, need: 6, remaining: 10) == [11,\
    \ 4])\nassert(eat(number: 4, need: 8, remaining: 9) == [12, 1])\nassert(eat(number:\
    \ 1, need: 10, remaining: 10) == [11, 0])\nassert(eat(number: 2, need: 11, remaining:\
    \ 5) == [7, 0])\nassert(eat(number: 4, need: 5, remaining: 7) == [9, 2])\nassert(eat(number:\
    \ 4, need: 5, remaining: 1) == [5, 0])"
  status: Exception
  stderr: 'tmpdxl6ijls/tmpdxl6ijls.swift:45: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b3c68025c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b3c67d1cb6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b3c67d1c988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b3c67d1b7b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpdxl6ijls                        0x000056155b39d384 <unavailable> + 4996

    5    libc.so.6                          0x00002b3c68211460 __libc_start_main +
    245

    6    tmpdxl6ijls                        0x000056155b39cfc9 <unavailable> + 4041

    '
  stdout: ''
  timestamp: 1660014019
- exit_code: 0
  program: "\n/// You're a hungry rabbit, and you already have eaten a certain number\
    \ of carrots,\n/// but now you need to eat more carrots to complete the day's\
    \ meals.\n/// you should return an array of [ total number of eaten carrots after\
    \ your meals,\n/// the number of carrots left after your meals ]\n/// if there\
    \ are not enough remaining carrots, you will eat all remaining carrots, but will\
    \ still be hungry.\n/// Example:\n/// >>> eat(number: 5, need: 6, remaining: 10)\n\
    /// [11, 4]\n/// >>> eat(number: 4, need: 8, remaining: 9)\n/// [12, 1]\n/// >>>\
    \ eat(number: 1, need: 10, remaining: 10)\n/// [11, 0]\n/// >>> eat(number: 2,\
    \ need: 11, remaining: 5)\n/// [7, 0]\n/// Variables:\n/// @number : integer\n\
    /// the number of carrots that you have eaten.\n/// @need : integer\n/// the number\
    \ of carrots that you need to eat.\n/// @remaining : integer\n/// the number of\
    \ remaining carrots thet exist in stock\n/// Constrain:\n/// * 0 <= number <=\
    \ 1000\n/// * 0 <= need <= 1000\n/// * 0 <= remaining <= 1000\n/// Have fun :)\n\
    func eat(number: Int, need: Int, remaining: Int) -> [Int] {\n    let eaten = number\
    \ + min(need, remaining)\n    let remain = max(0, remaining - need)\n    return\
    \ [eaten, remain]\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) ->\
    \ Bool {\n    if left.count != right.count {\n        return false\n    }\n  \
    \  for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(eat(number: 5, need:\
    \ 6, remaining: 10) == [11, 4])\nassert(eat(number: 4, need: 8, remaining: 9)\
    \ == [12, 1])\nassert(eat(number: 1, need: 10, remaining: 10) == [11, 0])\nassert(eat(number:\
    \ 2, need: 11, remaining: 5) == [7, 0])\nassert(eat(number: 4, need: 5, remaining:\
    \ 7) == [9, 2])\nassert(eat(number: 4, need: 5, remaining: 1) == [5, 0])"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660014019
- exit_code: 0
  program: "\n/// You're a hungry rabbit, and you already have eaten a certain number\
    \ of carrots,\n/// but now you need to eat more carrots to complete the day's\
    \ meals.\n/// you should return an array of [ total number of eaten carrots after\
    \ your meals,\n/// the number of carrots left after your meals ]\n/// if there\
    \ are not enough remaining carrots, you will eat all remaining carrots, but will\
    \ still be hungry.\n/// Example:\n/// >>> eat(number: 5, need: 6, remaining: 10)\n\
    /// [11, 4]\n/// >>> eat(number: 4, need: 8, remaining: 9)\n/// [12, 1]\n/// >>>\
    \ eat(number: 1, need: 10, remaining: 10)\n/// [11, 0]\n/// >>> eat(number: 2,\
    \ need: 11, remaining: 5)\n/// [7, 0]\n/// Variables:\n/// @number : integer\n\
    /// the number of carrots that you have eaten.\n/// @need : integer\n/// the number\
    \ of carrots that you need to eat.\n/// @remaining : integer\n/// the number of\
    \ remaining carrots thet exist in stock\n/// Constrain:\n/// * 0 <= number <=\
    \ 1000\n/// * 0 <= need <= 1000\n/// * 0 <= remaining <= 1000\n/// Have fun :)\n\
    func eat(number: Int, need: Int, remaining: Int) -> [Int] {\n    return [number\
    \ + min(need, remaining), max(0, remaining - need)]\n}\n\n\nfunc ==(left: [(Int,\
    \ Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n\
    \        return false\n    }\n    for (l, r) in zip(left, right) {\n        if\
    \ l != r {\n            return false\n        }\n    }\n    return true\n}\n \
    \           \nassert(eat(number: 5, need: 6, remaining: 10) == [11, 4])\nassert(eat(number:\
    \ 4, need: 8, remaining: 9) == [12, 1])\nassert(eat(number: 1, need: 10, remaining:\
    \ 10) == [11, 0])\nassert(eat(number: 2, need: 11, remaining: 5) == [7, 0])\n\
    assert(eat(number: 4, need: 5, remaining: 7) == [9, 2])\nassert(eat(number: 4,\
    \ need: 5, remaining: 1) == [5, 0])"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660013824
- exit_code: 0
  program: "\n/// You're a hungry rabbit, and you already have eaten a certain number\
    \ of carrots,\n/// but now you need to eat more carrots to complete the day's\
    \ meals.\n/// you should return an array of [ total number of eaten carrots after\
    \ your meals,\n/// the number of carrots left after your meals ]\n/// if there\
    \ are not enough remaining carrots, you will eat all remaining carrots, but will\
    \ still be hungry.\n/// Example:\n/// >>> eat(number: 5, need: 6, remaining: 10)\n\
    /// [11, 4]\n/// >>> eat(number: 4, need: 8, remaining: 9)\n/// [12, 1]\n/// >>>\
    \ eat(number: 1, need: 10, remaining: 10)\n/// [11, 0]\n/// >>> eat(number: 2,\
    \ need: 11, remaining: 5)\n/// [7, 0]\n/// Variables:\n/// @number : integer\n\
    /// the number of carrots that you have eaten.\n/// @need : integer\n/// the number\
    \ of carrots that you need to eat.\n/// @remaining : integer\n/// the number of\
    \ remaining carrots thet exist in stock\n/// Constrain:\n/// * 0 <= number <=\
    \ 1000\n/// * 0 <= need <= 1000\n/// * 0 <= remaining <= 1000\n/// Have fun :)\n\
    func eat(number: Int, need: Int, remaining: Int) -> [Int] {\n    let result =\
    \ number + min(need, remaining)\n    return [result, max(0, remaining - need)]\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(eat(number: 5, need: 6, remaining: 10) == [11,\
    \ 4])\nassert(eat(number: 4, need: 8, remaining: 9) == [12, 1])\nassert(eat(number:\
    \ 1, need: 10, remaining: 10) == [11, 0])\nassert(eat(number: 2, need: 11, remaining:\
    \ 5) == [7, 0])\nassert(eat(number: 4, need: 5, remaining: 7) == [9, 2])\nassert(eat(number:\
    \ 4, need: 5, remaining: 1) == [5, 0])"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660014019
- exit_code: -4
  program: "\n/// You're a hungry rabbit, and you already have eaten a certain number\
    \ of carrots,\n/// but now you need to eat more carrots to complete the day's\
    \ meals.\n/// you should return an array of [ total number of eaten carrots after\
    \ your meals,\n/// the number of carrots left after your meals ]\n/// if there\
    \ are not enough remaining carrots, you will eat all remaining carrots, but will\
    \ still be hungry.\n/// Example:\n/// >>> eat(number: 5, need: 6, remaining: 10)\n\
    /// [11, 4]\n/// >>> eat(number: 4, need: 8, remaining: 9)\n/// [12, 1]\n/// >>>\
    \ eat(number: 1, need: 10, remaining: 10)\n/// [11, 0]\n/// >>> eat(number: 2,\
    \ need: 11, remaining: 5)\n/// [7, 0]\n/// Variables:\n/// @number : integer\n\
    /// the number of carrots that you have eaten.\n/// @need : integer\n/// the number\
    \ of carrots that you need to eat.\n/// @remaining : integer\n/// the number of\
    \ remaining carrots thet exist in stock\n/// Constrain:\n/// * 0 <= number <=\
    \ 1000\n/// * 0 <= need <= 1000\n/// * 0 <= remaining <= 1000\n/// Have fun :)\n\
    func eat(number: Int, need: Int, remaining: Int) -> [Int] {\n    // Checking the\
    \ validity of the arguments\n    guard number > 0 && number <= 1000 else {\n \
    \       fatalError(\"The argument number is not valid, number must be greater\
    \ than 0 and less than 1000\")\n    }\n    guard need > 0 && need <= 1000 else\
    \ {\n        fatalError(\"The argument need is not valid, need must be greater\
    \ than 0 and less than 1000\")\n    }\n    guard remaining > 0 && remaining <=\
    \ 1000 else {\n        fatalError(\"The argument remaining is not valid, remaining\
    \ must be greater than 0 and less than 1000\")\n    }\n    // Here I made a simple\
    \ calculation to get the result\n    var afterEat = number + remaining\n    var\
    \ left = 0\n    if afterEat < need {\n        afterEat = need\n    }\n    else\
    \ {\n        left = afterEat - need\n    }\n    return [afterEat, left]\n}\n\n\
    \nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(eat(number: 5, need: 6, remaining: 10) == [11,\
    \ 4])\nassert(eat(number: 4, need: 8, remaining: 9) == [12, 1])\nassert(eat(number:\
    \ 1, need: 10, remaining: 10) == [11, 0])\nassert(eat(number: 2, need: 11, remaining:\
    \ 5) == [7, 0])\nassert(eat(number: 4, need: 5, remaining: 7) == [9, 2])\nassert(eat(number:\
    \ 4, need: 5, remaining: 1) == [5, 0])"
  status: Exception
  stderr: 'tmpr9hjdn_9/tmpr9hjdn_9.swift:64: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b1a6d067c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b1a6cd5eb6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b1a6cd5e988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b1a6cd5d7b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpr9hjdn_9                        0x000055ed128bf414 <unavailable> + 5140

    5    libc.so.6                          0x00002b1a6d253460 __libc_start_main +
    245

    6    tmpr9hjdn_9                        0x000055ed128bf059 <unavailable> + 4185

    '
  stdout: ''
  timestamp: 1660014019
- exit_code: -4
  program: "\n/// You're a hungry rabbit, and you already have eaten a certain number\
    \ of carrots,\n/// but now you need to eat more carrots to complete the day's\
    \ meals.\n/// you should return an array of [ total number of eaten carrots after\
    \ your meals,\n/// the number of carrots left after your meals ]\n/// if there\
    \ are not enough remaining carrots, you will eat all remaining carrots, but will\
    \ still be hungry.\n/// Example:\n/// >>> eat(number: 5, need: 6, remaining: 10)\n\
    /// [11, 4]\n/// >>> eat(number: 4, need: 8, remaining: 9)\n/// [12, 1]\n/// >>>\
    \ eat(number: 1, need: 10, remaining: 10)\n/// [11, 0]\n/// >>> eat(number: 2,\
    \ need: 11, remaining: 5)\n/// [7, 0]\n/// Variables:\n/// @number : integer\n\
    /// the number of carrots that you have eaten.\n/// @need : integer\n/// the number\
    \ of carrots that you need to eat.\n/// @remaining : integer\n/// the number of\
    \ remaining carrots thet exist in stock\n/// Constrain:\n/// * 0 <= number <=\
    \ 1000\n/// * 0 <= need <= 1000\n/// * 0 <= remaining <= 1000\n/// Have fun :)\n\
    func eat(number: Int, need: Int, remaining: Int) -> [Int] {\n    return []\n}\n\
    \n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(eat(number: 5, need: 6, remaining: 10) == [11,\
    \ 4])\nassert(eat(number: 4, need: 8, remaining: 9) == [12, 1])\nassert(eat(number:\
    \ 1, need: 10, remaining: 10) == [11, 0])\nassert(eat(number: 2, need: 11, remaining:\
    \ 5) == [7, 0])\nassert(eat(number: 4, need: 5, remaining: 7) == [9, 2])\nassert(eat(number:\
    \ 4, need: 5, remaining: 1) == [5, 0])"
  status: Exception
  stderr: 'tmp5d0or02d/tmp5d0or02d.swift:45: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b0276059c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b0275d50b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b0275d50988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b0275d4f7b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmp5d0or02d                        0x000056073e3c5384 <unavailable> + 4996

    5    libc.so.6                          0x00002b0276245460 __libc_start_main +
    245

    6    tmp5d0or02d                        0x000056073e3c4fc9 <unavailable> + 4041

    '
  stdout: ''
  timestamp: 1660014019
- exit_code: 0
  program: "\n/// You're a hungry rabbit, and you already have eaten a certain number\
    \ of carrots,\n/// but now you need to eat more carrots to complete the day's\
    \ meals.\n/// you should return an array of [ total number of eaten carrots after\
    \ your meals,\n/// the number of carrots left after your meals ]\n/// if there\
    \ are not enough remaining carrots, you will eat all remaining carrots, but will\
    \ still be hungry.\n/// Example:\n/// >>> eat(number: 5, need: 6, remaining: 10)\n\
    /// [11, 4]\n/// >>> eat(number: 4, need: 8, remaining: 9)\n/// [12, 1]\n/// >>>\
    \ eat(number: 1, need: 10, remaining: 10)\n/// [11, 0]\n/// >>> eat(number: 2,\
    \ need: 11, remaining: 5)\n/// [7, 0]\n/// Variables:\n/// @number : integer\n\
    /// the number of carrots that you have eaten.\n/// @need : integer\n/// the number\
    \ of carrots that you need to eat.\n/// @remaining : integer\n/// the number of\
    \ remaining carrots thet exist in stock\n/// Constrain:\n/// * 0 <= number <=\
    \ 1000\n/// * 0 <= need <= 1000\n/// * 0 <= remaining <= 1000\n/// Have fun :)\n\
    func eat(number: Int, need: Int, remaining: Int) -> [Int] {\n    if remaining\
    \ < need {\n        return [number + remaining, 0]\n    }\n    return [number\
    \ + need, remaining - need]\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int,\
    \ Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n\
    \    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n          \
    \  return false\n        }\n    }\n    return true\n}\n            \nassert(eat(number:\
    \ 5, need: 6, remaining: 10) == [11, 4])\nassert(eat(number: 4, need: 8, remaining:\
    \ 9) == [12, 1])\nassert(eat(number: 1, need: 10, remaining: 10) == [11, 0])\n\
    assert(eat(number: 2, need: 11, remaining: 5) == [7, 0])\nassert(eat(number: 4,\
    \ need: 5, remaining: 7) == [9, 2])\nassert(eat(number: 4, need: 5, remaining:\
    \ 1) == [5, 0])"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660014019
- exit_code: 0
  program: "\n/// You're a hungry rabbit, and you already have eaten a certain number\
    \ of carrots,\n/// but now you need to eat more carrots to complete the day's\
    \ meals.\n/// you should return an array of [ total number of eaten carrots after\
    \ your meals,\n/// the number of carrots left after your meals ]\n/// if there\
    \ are not enough remaining carrots, you will eat all remaining carrots, but will\
    \ still be hungry.\n/// Example:\n/// >>> eat(number: 5, need: 6, remaining: 10)\n\
    /// [11, 4]\n/// >>> eat(number: 4, need: 8, remaining: 9)\n/// [12, 1]\n/// >>>\
    \ eat(number: 1, need: 10, remaining: 10)\n/// [11, 0]\n/// >>> eat(number: 2,\
    \ need: 11, remaining: 5)\n/// [7, 0]\n/// Variables:\n/// @number : integer\n\
    /// the number of carrots that you have eaten.\n/// @need : integer\n/// the number\
    \ of carrots that you need to eat.\n/// @remaining : integer\n/// the number of\
    \ remaining carrots thet exist in stock\n/// Constrain:\n/// * 0 <= number <=\
    \ 1000\n/// * 0 <= need <= 1000\n/// * 0 <= remaining <= 1000\n/// Have fun :)\n\
    func eat(number: Int, need: Int, remaining: Int) -> [Int] {\n    return [(number\
    \ + (remaining >= need ? need : remaining)), (remaining >= need ? remaining -\
    \ need : 0)]\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool\
    \ {\n    if left.count != right.count {\n        return false\n    }\n    for\
    \ (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(eat(number: 5, need:\
    \ 6, remaining: 10) == [11, 4])\nassert(eat(number: 4, need: 8, remaining: 9)\
    \ == [12, 1])\nassert(eat(number: 1, need: 10, remaining: 10) == [11, 0])\nassert(eat(number:\
    \ 2, need: 11, remaining: 5) == [7, 0])\nassert(eat(number: 4, need: 5, remaining:\
    \ 7) == [9, 2])\nassert(eat(number: 4, need: 5, remaining: 1) == [5, 0])"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660014019
- exit_code: -4
  program: "\n/// You're a hungry rabbit, and you already have eaten a certain number\
    \ of carrots,\n/// but now you need to eat more carrots to complete the day's\
    \ meals.\n/// you should return an array of [ total number of eaten carrots after\
    \ your meals,\n/// the number of carrots left after your meals ]\n/// if there\
    \ are not enough remaining carrots, you will eat all remaining carrots, but will\
    \ still be hungry.\n/// Example:\n/// >>> eat(number: 5, need: 6, remaining: 10)\n\
    /// [11, 4]\n/// >>> eat(number: 4, need: 8, remaining: 9)\n/// [12, 1]\n/// >>>\
    \ eat(number: 1, need: 10, remaining: 10)\n/// [11, 0]\n/// >>> eat(number: 2,\
    \ need: 11, remaining: 5)\n/// [7, 0]\n/// Variables:\n/// @number : integer\n\
    /// the number of carrots that you have eaten.\n/// @need : integer\n/// the number\
    \ of carrots that you need to eat.\n/// @remaining : integer\n/// the number of\
    \ remaining carrots thet exist in stock\n/// Constrain:\n/// * 0 <= number <=\
    \ 1000\n/// * 0 <= need <= 1000\n/// * 0 <= remaining <= 1000\n/// Have fun :)\n\
    func eat(number: Int, need: Int, remaining: Int) -> [Int] {\n    let diff = number\
    \ - need\n    let result = (remaining - diff) > 0 ? remaining - diff : 0\n   \
    \ return [number + need, result]\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int,\
    \ Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n\
    \    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n          \
    \  return false\n        }\n    }\n    return true\n}\n            \nassert(eat(number:\
    \ 5, need: 6, remaining: 10) == [11, 4])\nassert(eat(number: 4, need: 8, remaining:\
    \ 9) == [12, 1])\nassert(eat(number: 1, need: 10, remaining: 10) == [11, 0])\n\
    assert(eat(number: 2, need: 11, remaining: 5) == [7, 0])\nassert(eat(number: 4,\
    \ need: 5, remaining: 7) == [9, 2])\nassert(eat(number: 4, need: 5, remaining:\
    \ 1) == [5, 0])"
  status: Exception
  stderr: 'tmpfqdl_jwy/tmpfqdl_jwy.swift:47: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b70805e0c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b70802d7b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b70802d7988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b70802d67b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpfqdl_jwy                        0x000056388eea7384 <unavailable> + 4996

    5    libc.so.6                          0x00002b70807cc460 __libc_start_main +
    245

    6    tmpfqdl_jwy                        0x000056388eea6fc9 <unavailable> + 4041

    '
  stdout: ''
  timestamp: 1660014019
- exit_code: -4
  program: "\n/// You're a hungry rabbit, and you already have eaten a certain number\
    \ of carrots,\n/// but now you need to eat more carrots to complete the day's\
    \ meals.\n/// you should return an array of [ total number of eaten carrots after\
    \ your meals,\n/// the number of carrots left after your meals ]\n/// if there\
    \ are not enough remaining carrots, you will eat all remaining carrots, but will\
    \ still be hungry.\n/// Example:\n/// >>> eat(number: 5, need: 6, remaining: 10)\n\
    /// [11, 4]\n/// >>> eat(number: 4, need: 8, remaining: 9)\n/// [12, 1]\n/// >>>\
    \ eat(number: 1, need: 10, remaining: 10)\n/// [11, 0]\n/// >>> eat(number: 2,\
    \ need: 11, remaining: 5)\n/// [7, 0]\n/// Variables:\n/// @number : integer\n\
    /// the number of carrots that you have eaten.\n/// @need : integer\n/// the number\
    \ of carrots that you need to eat.\n/// @remaining : integer\n/// the number of\
    \ remaining carrots thet exist in stock\n/// Constrain:\n/// * 0 <= number <=\
    \ 1000\n/// * 0 <= need <= 1000\n/// * 0 <= remaining <= 1000\n/// Have fun :)\n\
    func eat(number: Int, need: Int, remaining: Int) -> [Int] {\n  var eaten = 0\n\
    \  var left = 0\n  if (number + remaining) >= need {\n    eaten = need\n    left\
    \ = remaining - (need - number)\n  } else {\n    eaten = number + remaining\n\
    \    left = 0\n  }\n  return [eaten, left]\n}\n\n\nfunc ==(left: [(Int, Int)],\
    \ right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n       \
    \ return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r\
    \ {\n            return false\n        }\n    }\n    return true\n}\n        \
    \    \nassert(eat(number: 5, need: 6, remaining: 10) == [11, 4])\nassert(eat(number:\
    \ 4, need: 8, remaining: 9) == [12, 1])\nassert(eat(number: 1, need: 10, remaining:\
    \ 10) == [11, 0])\nassert(eat(number: 2, need: 11, remaining: 5) == [7, 0])\n\
    assert(eat(number: 4, need: 5, remaining: 7) == [9, 2])\nassert(eat(number: 4,\
    \ need: 5, remaining: 1) == [5, 0])"
  status: Exception
  stderr: 'tmpqw3gftvv/tmpqw3gftvv.swift:54: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b4801255c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b4800f4cb6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b4800f4c988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b4800f4b7b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpqw3gftvv                        0x000055e0c4ae7384 <unavailable> + 4996

    5    libc.so.6                          0x00002b4801441460 __libc_start_main +
    245

    6    tmpqw3gftvv                        0x000055e0c4ae6fc9 <unavailable> + 4041

    '
  stdout: ''
  timestamp: 1660014019
- exit_code: -4
  program: "\n/// You're a hungry rabbit, and you already have eaten a certain number\
    \ of carrots,\n/// but now you need to eat more carrots to complete the day's\
    \ meals.\n/// you should return an array of [ total number of eaten carrots after\
    \ your meals,\n/// the number of carrots left after your meals ]\n/// if there\
    \ are not enough remaining carrots, you will eat all remaining carrots, but will\
    \ still be hungry.\n/// Example:\n/// >>> eat(number: 5, need: 6, remaining: 10)\n\
    /// [11, 4]\n/// >>> eat(number: 4, need: 8, remaining: 9)\n/// [12, 1]\n/// >>>\
    \ eat(number: 1, need: 10, remaining: 10)\n/// [11, 0]\n/// >>> eat(number: 2,\
    \ need: 11, remaining: 5)\n/// [7, 0]\n/// Variables:\n/// @number : integer\n\
    /// the number of carrots that you have eaten.\n/// @need : integer\n/// the number\
    \ of carrots that you need to eat.\n/// @remaining : integer\n/// the number of\
    \ remaining carrots thet exist in stock\n/// Constrain:\n/// * 0 <= number <=\
    \ 1000\n/// * 0 <= need <= 1000\n/// * 0 <= remaining <= 1000\n/// Have fun :)\n\
    func eat(number: Int, need: Int, remaining: Int) -> [Int] {\n    var full = number\
    \ + remaining\n    var left = 0\n    if full < need {\n        left = 0\n    }\
    \ else {\n        left = full - need\n    }\n    return [full, left]\n}\n\n\n\
    func ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(eat(number: 5, need: 6, remaining: 10) == [11,\
    \ 4])\nassert(eat(number: 4, need: 8, remaining: 9) == [12, 1])\nassert(eat(number:\
    \ 1, need: 10, remaining: 10) == [11, 0])\nassert(eat(number: 2, need: 11, remaining:\
    \ 5) == [7, 0])\nassert(eat(number: 4, need: 5, remaining: 7) == [9, 2])\nassert(eat(number:\
    \ 4, need: 5, remaining: 1) == [5, 0])"
  status: Exception
  stderr: 'tmpq32yhhor/tmpq32yhhor.swift:52: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b6251bcbc80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b62518c2b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b62518c2988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b62518c17b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpq32yhhor                        0x0000559572413384 <unavailable> + 4996

    5    libc.so.6                          0x00002b6251db7460 __libc_start_main +
    245

    6    tmpq32yhhor                        0x0000559572412fc9 <unavailable> + 4041

    '
  stdout: ''
  timestamp: 1660014019
- exit_code: -4
  program: "\n/// You're a hungry rabbit, and you already have eaten a certain number\
    \ of carrots,\n/// but now you need to eat more carrots to complete the day's\
    \ meals.\n/// you should return an array of [ total number of eaten carrots after\
    \ your meals,\n/// the number of carrots left after your meals ]\n/// if there\
    \ are not enough remaining carrots, you will eat all remaining carrots, but will\
    \ still be hungry.\n/// Example:\n/// >>> eat(number: 5, need: 6, remaining: 10)\n\
    /// [11, 4]\n/// >>> eat(number: 4, need: 8, remaining: 9)\n/// [12, 1]\n/// >>>\
    \ eat(number: 1, need: 10, remaining: 10)\n/// [11, 0]\n/// >>> eat(number: 2,\
    \ need: 11, remaining: 5)\n/// [7, 0]\n/// Variables:\n/// @number : integer\n\
    /// the number of carrots that you have eaten.\n/// @need : integer\n/// the number\
    \ of carrots that you need to eat.\n/// @remaining : integer\n/// the number of\
    \ remaining carrots thet exist in stock\n/// Constrain:\n/// * 0 <= number <=\
    \ 1000\n/// * 0 <= need <= 1000\n/// * 0 <= remaining <= 1000\n/// Have fun :)\n\
    func eat(number: Int, need: Int, remaining: Int) -> [Int] {\n    let x = remaining\
    \ - need + number\n    let y = x >= 0 ? x : 0\n    return [need + number, y]\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(eat(number: 5, need: 6, remaining: 10) == [11,\
    \ 4])\nassert(eat(number: 4, need: 8, remaining: 9) == [12, 1])\nassert(eat(number:\
    \ 1, need: 10, remaining: 10) == [11, 0])\nassert(eat(number: 2, need: 11, remaining:\
    \ 5) == [7, 0])\nassert(eat(number: 4, need: 5, remaining: 7) == [9, 2])\nassert(eat(number:\
    \ 4, need: 5, remaining: 1) == [5, 0])"
  status: Exception
  stderr: 'tmpybk4rune/tmpybk4rune.swift:47: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002af0dfb59c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002af0df850b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002af0df850988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002af0df84f7b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpybk4rune                        0x000055e439ba5384 <unavailable> + 4996

    5    libc.so.6                          0x00002af0dfd45460 __libc_start_main +
    245

    6    tmpybk4rune                        0x000055e439ba4fc9 <unavailable> + 4041

    '
  stdout: ''
  timestamp: 1660014019
- exit_code: -4
  program: "\n/// You're a hungry rabbit, and you already have eaten a certain number\
    \ of carrots,\n/// but now you need to eat more carrots to complete the day's\
    \ meals.\n/// you should return an array of [ total number of eaten carrots after\
    \ your meals,\n/// the number of carrots left after your meals ]\n/// if there\
    \ are not enough remaining carrots, you will eat all remaining carrots, but will\
    \ still be hungry.\n/// Example:\n/// >>> eat(number: 5, need: 6, remaining: 10)\n\
    /// [11, 4]\n/// >>> eat(number: 4, need: 8, remaining: 9)\n/// [12, 1]\n/// >>>\
    \ eat(number: 1, need: 10, remaining: 10)\n/// [11, 0]\n/// >>> eat(number: 2,\
    \ need: 11, remaining: 5)\n/// [7, 0]\n/// Variables:\n/// @number : integer\n\
    /// the number of carrots that you have eaten.\n/// @need : integer\n/// the number\
    \ of carrots that you need to eat.\n/// @remaining : integer\n/// the number of\
    \ remaining carrots thet exist in stock\n/// Constrain:\n/// * 0 <= number <=\
    \ 1000\n/// * 0 <= need <= 1000\n/// * 0 <= remaining <= 1000\n/// Have fun :)\n\
    func eat(number: Int, need: Int, remaining: Int) -> [Int] {\n    let summ = number\
    \ + need\n    let newRemaining = remaining - need\n    return newRemaining >=\
    \ 0 ? [summ, newRemaining] : [summ, 0]\n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(eat(number: 5, need: 6, remaining: 10) == [11, 4])\nassert(eat(number:\
    \ 4, need: 8, remaining: 9) == [12, 1])\nassert(eat(number: 1, need: 10, remaining:\
    \ 10) == [11, 0])\nassert(eat(number: 2, need: 11, remaining: 5) == [7, 0])\n\
    assert(eat(number: 4, need: 5, remaining: 7) == [9, 2])\nassert(eat(number: 4,\
    \ need: 5, remaining: 1) == [5, 0])"
  status: Exception
  stderr: 'tmpcm8m98pq/tmpcm8m98pq.swift:50: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002ad2ef518c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002ad2ef20fb6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002ad2ef20f988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002ad2ef20e7b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpcm8m98pq                        0x0000563e6ed07658 <unavailable> + 5720

    5    libc.so.6                          0x00002ad2ef704460 __libc_start_main +
    245

    6    tmpcm8m98pq                        0x0000563e6ed06fc9 <unavailable> + 4041

    '
  stdout: ''
  timestamp: 1660014019
- exit_code: -4
  program: "\n/// You're a hungry rabbit, and you already have eaten a certain number\
    \ of carrots,\n/// but now you need to eat more carrots to complete the day's\
    \ meals.\n/// you should return an array of [ total number of eaten carrots after\
    \ your meals,\n/// the number of carrots left after your meals ]\n/// if there\
    \ are not enough remaining carrots, you will eat all remaining carrots, but will\
    \ still be hungry.\n/// Example:\n/// >>> eat(number: 5, need: 6, remaining: 10)\n\
    /// [11, 4]\n/// >>> eat(number: 4, need: 8, remaining: 9)\n/// [12, 1]\n/// >>>\
    \ eat(number: 1, need: 10, remaining: 10)\n/// [11, 0]\n/// >>> eat(number: 2,\
    \ need: 11, remaining: 5)\n/// [7, 0]\n/// Variables:\n/// @number : integer\n\
    /// the number of carrots that you have eaten.\n/// @need : integer\n/// the number\
    \ of carrots that you need to eat.\n/// @remaining : integer\n/// the number of\
    \ remaining carrots thet exist in stock\n/// Constrain:\n/// * 0 <= number <=\
    \ 1000\n/// * 0 <= need <= 1000\n/// * 0 <= remaining <= 1000\n/// Have fun :)\n\
    func eat(number: Int, need: Int, remaining: Int) -> [Int] {\n    if number + remaining\
    \ < need {\n        return [number + remaining, 0]\n    } else {\n        return\
    \ [need, number + remaining - need]\n    }\n}\n\n\nfunc ==(left: [(Int, Int)],\
    \ right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n       \
    \ return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r\
    \ {\n            return false\n        }\n    }\n    return true\n}\n        \
    \    \nassert(eat(number: 5, need: 6, remaining: 10) == [11, 4])\nassert(eat(number:\
    \ 4, need: 8, remaining: 9) == [12, 1])\nassert(eat(number: 1, need: 10, remaining:\
    \ 10) == [11, 0])\nassert(eat(number: 2, need: 11, remaining: 5) == [7, 0])\n\
    assert(eat(number: 4, need: 5, remaining: 7) == [9, 2])\nassert(eat(number: 4,\
    \ need: 5, remaining: 1) == [5, 0])"
  status: Exception
  stderr: 'tmpodhds56n/tmpodhds56n.swift:49: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002adcacffac80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002adcaccf1b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002adcaccf1988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002adcaccf07b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpodhds56n                        0x0000556fbfc9c384 <unavailable> + 4996

    5    libc.so.6                          0x00002adcad1e6460 __libc_start_main +
    245

    6    tmpodhds56n                        0x0000556fbfc9bfc9 <unavailable> + 4041

    '
  stdout: ''
  timestamp: 1660013825
- exit_code: -4
  program: "\n/// You're a hungry rabbit, and you already have eaten a certain number\
    \ of carrots,\n/// but now you need to eat more carrots to complete the day's\
    \ meals.\n/// you should return an array of [ total number of eaten carrots after\
    \ your meals,\n/// the number of carrots left after your meals ]\n/// if there\
    \ are not enough remaining carrots, you will eat all remaining carrots, but will\
    \ still be hungry.\n/// Example:\n/// >>> eat(number: 5, need: 6, remaining: 10)\n\
    /// [11, 4]\n/// >>> eat(number: 4, need: 8, remaining: 9)\n/// [12, 1]\n/// >>>\
    \ eat(number: 1, need: 10, remaining: 10)\n/// [11, 0]\n/// >>> eat(number: 2,\
    \ need: 11, remaining: 5)\n/// [7, 0]\n/// Variables:\n/// @number : integer\n\
    /// the number of carrots that you have eaten.\n/// @need : integer\n/// the number\
    \ of carrots that you need to eat.\n/// @remaining : integer\n/// the number of\
    \ remaining carrots thet exist in stock\n/// Constrain:\n/// * 0 <= number <=\
    \ 1000\n/// * 0 <= need <= 1000\n/// * 0 <= remaining <= 1000\n/// Have fun :)\n\
    func eat(number: Int, need: Int, remaining: Int) -> [Int] {\n  if number + remaining\
    \ < need {\n    return [remaining + number, 0]\n  } else {\n    return [need,\
    \ number + remaining - need]\n  }\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int,\
    \ Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n\
    \    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n          \
    \  return false\n        }\n    }\n    return true\n}\n            \nassert(eat(number:\
    \ 5, need: 6, remaining: 10) == [11, 4])\nassert(eat(number: 4, need: 8, remaining:\
    \ 9) == [12, 1])\nassert(eat(number: 1, need: 10, remaining: 10) == [11, 0])\n\
    assert(eat(number: 2, need: 11, remaining: 5) == [7, 0])\nassert(eat(number: 4,\
    \ need: 5, remaining: 7) == [9, 2])\nassert(eat(number: 4, need: 5, remaining:\
    \ 1) == [5, 0])"
  status: Exception
  stderr: 'tmpz_0odo4s/tmpz_0odo4s.swift:49: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002ba5d6898c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002ba5d658fb6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002ba5d658f988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002ba5d658e7b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpz_0odo4s                        0x000055bf5a1d4384 <unavailable> + 4996

    5    libc.so.6                          0x00002ba5d6a84460 __libc_start_main +
    245

    6    tmpz_0odo4s                        0x000055bf5a1d3fc9 <unavailable> + 4041

    '
  stdout: ''
  timestamp: 1660014019
- exit_code: -4
  program: "\n/// You're a hungry rabbit, and you already have eaten a certain number\
    \ of carrots,\n/// but now you need to eat more carrots to complete the day's\
    \ meals.\n/// you should return an array of [ total number of eaten carrots after\
    \ your meals,\n/// the number of carrots left after your meals ]\n/// if there\
    \ are not enough remaining carrots, you will eat all remaining carrots, but will\
    \ still be hungry.\n/// Example:\n/// >>> eat(number: 5, need: 6, remaining: 10)\n\
    /// [11, 4]\n/// >>> eat(number: 4, need: 8, remaining: 9)\n/// [12, 1]\n/// >>>\
    \ eat(number: 1, need: 10, remaining: 10)\n/// [11, 0]\n/// >>> eat(number: 2,\
    \ need: 11, remaining: 5)\n/// [7, 0]\n/// Variables:\n/// @number : integer\n\
    /// the number of carrots that you have eaten.\n/// @need : integer\n/// the number\
    \ of carrots that you need to eat.\n/// @remaining : integer\n/// the number of\
    \ remaining carrots thet exist in stock\n/// Constrain:\n/// * 0 <= number <=\
    \ 1000\n/// * 0 <= need <= 1000\n/// * 0 <= remaining <= 1000\n/// Have fun :)\n\
    func eat(number: Int, need: Int, remaining: Int) -> [Int] {\n    var number =\
    \ number\n    var remaining = remaining\n    if remaining + number < need {\n\
    \        number += remaining\n        remaining = 0\n    } else {\n        number\
    \ += need\n        remaining -= need\n    }\n    return [number, remaining]\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(eat(number: 5, need: 6, remaining: 10) == [11,\
    \ 4])\nassert(eat(number: 4, need: 8, remaining: 9) == [12, 1])\nassert(eat(number:\
    \ 1, need: 10, remaining: 10) == [11, 0])\nassert(eat(number: 2, need: 11, remaining:\
    \ 5) == [7, 0])\nassert(eat(number: 4, need: 5, remaining: 7) == [9, 2])\nassert(eat(number:\
    \ 4, need: 5, remaining: 1) == [5, 0])"
  status: Exception
  stderr: 'tmp3s7r2y4w/tmp3s7r2y4w.swift:59: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002af2fff66c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002af2ffc5db6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002af2ffc5d988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002af2ffc5c7b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmp3s7r2y4w                        0x00005651c1d0a873 <unavailable> + 6259

    5    libc.so.6                          0x00002af300152460 __libc_start_main +
    245

    6    tmp3s7r2y4w                        0x00005651c1d09fc9 <unavailable> + 4041

    '
  stdout: ''
  timestamp: 1660014019
- exit_code: -4
  program: "\n/// You're a hungry rabbit, and you already have eaten a certain number\
    \ of carrots,\n/// but now you need to eat more carrots to complete the day's\
    \ meals.\n/// you should return an array of [ total number of eaten carrots after\
    \ your meals,\n/// the number of carrots left after your meals ]\n/// if there\
    \ are not enough remaining carrots, you will eat all remaining carrots, but will\
    \ still be hungry.\n/// Example:\n/// >>> eat(number: 5, need: 6, remaining: 10)\n\
    /// [11, 4]\n/// >>> eat(number: 4, need: 8, remaining: 9)\n/// [12, 1]\n/// >>>\
    \ eat(number: 1, need: 10, remaining: 10)\n/// [11, 0]\n/// >>> eat(number: 2,\
    \ need: 11, remaining: 5)\n/// [7, 0]\n/// Variables:\n/// @number : integer\n\
    /// the number of carrots that you have eaten.\n/// @need : integer\n/// the number\
    \ of carrots that you need to eat.\n/// @remaining : integer\n/// the number of\
    \ remaining carrots thet exist in stock\n/// Constrain:\n/// * 0 <= number <=\
    \ 1000\n/// * 0 <= need <= 1000\n/// * 0 <= remaining <= 1000\n/// Have fun :)\n\
    func eat(number: Int, need: Int, remaining: Int) -> [Int] {\n    // do something\n\
    \    return [0, 0]\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) ->\
    \ Bool {\n    if left.count != right.count {\n        return false\n    }\n  \
    \  for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(eat(number: 5, need:\
    \ 6, remaining: 10) == [11, 4])\nassert(eat(number: 4, need: 8, remaining: 9)\
    \ == [12, 1])\nassert(eat(number: 1, need: 10, remaining: 10) == [11, 0])\nassert(eat(number:\
    \ 2, need: 11, remaining: 5) == [7, 0])\nassert(eat(number: 4, need: 5, remaining:\
    \ 7) == [9, 2])\nassert(eat(number: 4, need: 5, remaining: 1) == [5, 0])"
  status: Exception
  stderr: 'tmp_ync6mxp/tmp_ync6mxp.swift:46: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b893dbc8c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b893d8bfb6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b893d8bf988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b893d8be7b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmp_ync6mxp                        0x000055dbf8d0d384 <unavailable> + 4996

    5    libc.so.6                          0x00002b893ddb4460 __libc_start_main +
    245

    6    tmp_ync6mxp                        0x000055dbf8d0cfc9 <unavailable> + 4041

    '
  stdout: ''
  timestamp: 1660014019
- exit_code: -4
  program: "\n/// You're a hungry rabbit, and you already have eaten a certain number\
    \ of carrots,\n/// but now you need to eat more carrots to complete the day's\
    \ meals.\n/// you should return an array of [ total number of eaten carrots after\
    \ your meals,\n/// the number of carrots left after your meals ]\n/// if there\
    \ are not enough remaining carrots, you will eat all remaining carrots, but will\
    \ still be hungry.\n/// Example:\n/// >>> eat(number: 5, need: 6, remaining: 10)\n\
    /// [11, 4]\n/// >>> eat(number: 4, need: 8, remaining: 9)\n/// [12, 1]\n/// >>>\
    \ eat(number: 1, need: 10, remaining: 10)\n/// [11, 0]\n/// >>> eat(number: 2,\
    \ need: 11, remaining: 5)\n/// [7, 0]\n/// Variables:\n/// @number : integer\n\
    /// the number of carrots that you have eaten.\n/// @need : integer\n/// the number\
    \ of carrots that you need to eat.\n/// @remaining : integer\n/// the number of\
    \ remaining carrots thet exist in stock\n/// Constrain:\n/// * 0 <= number <=\
    \ 1000\n/// * 0 <= need <= 1000\n/// * 0 <= remaining <= 1000\n/// Have fun :)\n\
    func eat(number: Int, need: Int, remaining: Int) -> [Int] {\n    let max = need\
    \ - number\n    let result = [number + min(max, remaining), max - min(max, remaining)]\n\
    \    return result\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) ->\
    \ Bool {\n    if left.count != right.count {\n        return false\n    }\n  \
    \  for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(eat(number: 5, need:\
    \ 6, remaining: 10) == [11, 4])\nassert(eat(number: 4, need: 8, remaining: 9)\
    \ == [12, 1])\nassert(eat(number: 1, need: 10, remaining: 10) == [11, 0])\nassert(eat(number:\
    \ 2, need: 11, remaining: 5) == [7, 0])\nassert(eat(number: 4, need: 5, remaining:\
    \ 7) == [9, 2])\nassert(eat(number: 4, need: 5, remaining: 1) == [5, 0])"
  status: Exception
  stderr: 'tmpzrmtdab2/tmpzrmtdab2.swift:47: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b02495e7c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b02492deb6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b02492de988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b02492dd7b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpzrmtdab2                        0x00005590fe0c9424 <unavailable> + 5156

    5    libc.so.6                          0x00002b02497d3460 __libc_start_main +
    245

    6    tmpzrmtdab2                        0x00005590fe0c9069 <unavailable> + 4201

    '
  stdout: ''
  timestamp: 1660014019
- exit_code: -4
  program: "\n/// You're a hungry rabbit, and you already have eaten a certain number\
    \ of carrots,\n/// but now you need to eat more carrots to complete the day's\
    \ meals.\n/// you should return an array of [ total number of eaten carrots after\
    \ your meals,\n/// the number of carrots left after your meals ]\n/// if there\
    \ are not enough remaining carrots, you will eat all remaining carrots, but will\
    \ still be hungry.\n/// Example:\n/// >>> eat(number: 5, need: 6, remaining: 10)\n\
    /// [11, 4]\n/// >>> eat(number: 4, need: 8, remaining: 9)\n/// [12, 1]\n/// >>>\
    \ eat(number: 1, need: 10, remaining: 10)\n/// [11, 0]\n/// >>> eat(number: 2,\
    \ need: 11, remaining: 5)\n/// [7, 0]\n/// Variables:\n/// @number : integer\n\
    /// the number of carrots that you have eaten.\n/// @need : integer\n/// the number\
    \ of carrots that you need to eat.\n/// @remaining : integer\n/// the number of\
    \ remaining carrots thet exist in stock\n/// Constrain:\n/// * 0 <= number <=\
    \ 1000\n/// * 0 <= need <= 1000\n/// * 0 <= remaining <= 1000\n/// Have fun :)\n\
    func eat(number: Int, need: Int, remaining: Int) -> [Int] {\n    if remaining\
    \ + number >= need {\n        return [need, remaining + number - need]\n    }\
    \ else {\n        return [remaining + number, 0]\n    }\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(eat(number: 5, need: 6, remaining: 10) == [11, 4])\nassert(eat(number:\
    \ 4, need: 8, remaining: 9) == [12, 1])\nassert(eat(number: 1, need: 10, remaining:\
    \ 10) == [11, 0])\nassert(eat(number: 2, need: 11, remaining: 5) == [7, 0])\n\
    assert(eat(number: 4, need: 5, remaining: 7) == [9, 2])\nassert(eat(number: 4,\
    \ need: 5, remaining: 1) == [5, 0])"
  status: Exception
  stderr: 'tmpk09lp6sp/tmpk09lp6sp.swift:49: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002afd62d35c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002afd62a2cb6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002afd62a2c988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002afd62a2b7b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpk09lp6sp                        0x000055a80db19384 <unavailable> + 4996

    5    libc.so.6                          0x00002afd62f21460 __libc_start_main +
    245

    6    tmpk09lp6sp                        0x000055a80db18fc9 <unavailable> + 4041

    '
  stdout: ''
  timestamp: 1660014019
- exit_code: -4
  program: "\n/// You're a hungry rabbit, and you already have eaten a certain number\
    \ of carrots,\n/// but now you need to eat more carrots to complete the day's\
    \ meals.\n/// you should return an array of [ total number of eaten carrots after\
    \ your meals,\n/// the number of carrots left after your meals ]\n/// if there\
    \ are not enough remaining carrots, you will eat all remaining carrots, but will\
    \ still be hungry.\n/// Example:\n/// >>> eat(number: 5, need: 6, remaining: 10)\n\
    /// [11, 4]\n/// >>> eat(number: 4, need: 8, remaining: 9)\n/// [12, 1]\n/// >>>\
    \ eat(number: 1, need: 10, remaining: 10)\n/// [11, 0]\n/// >>> eat(number: 2,\
    \ need: 11, remaining: 5)\n/// [7, 0]\n/// Variables:\n/// @number : integer\n\
    /// the number of carrots that you have eaten.\n/// @need : integer\n/// the number\
    \ of carrots that you need to eat.\n/// @remaining : integer\n/// the number of\
    \ remaining carrots thet exist in stock\n/// Constrain:\n/// * 0 <= number <=\
    \ 1000\n/// * 0 <= need <= 1000\n/// * 0 <= remaining <= 1000\n/// Have fun :)\n\
    func eat(number: Int, need: Int, remaining: Int) -> [Int] {\n    if number >=\
    \ need {\n        return [number, remaining]\n    }\n    if remaining == 0 {\n\
    \        return [number, 0]\n    }\n    let total = number + remaining\n    return\
    \ total >= need ? [need, total - need] : [total, 0]\n}\n\n\nfunc ==(left: [(Int,\
    \ Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n\
    \        return false\n    }\n    for (l, r) in zip(left, right) {\n        if\
    \ l != r {\n            return false\n        }\n    }\n    return true\n}\n \
    \           \nassert(eat(number: 5, need: 6, remaining: 10) == [11, 4])\nassert(eat(number:\
    \ 4, need: 8, remaining: 9) == [12, 1])\nassert(eat(number: 1, need: 10, remaining:\
    \ 10) == [11, 0])\nassert(eat(number: 2, need: 11, remaining: 5) == [7, 0])\n\
    assert(eat(number: 4, need: 5, remaining: 7) == [9, 2])\nassert(eat(number: 4,\
    \ need: 5, remaining: 1) == [5, 0])"
  status: Exception
  stderr: 'tmpohgyi78a/tmpohgyi78a.swift:52: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b26f827bc80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b26f7f72b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b26f7f72988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b26f7f717b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpohgyi78a                        0x0000560a56173384 <unavailable> + 4996

    5    libc.so.6                          0x00002b26f8467460 __libc_start_main +
    245

    6    tmpohgyi78a                        0x0000560a56172fc9 <unavailable> + 4041

    '
  stdout: ''
  timestamp: 1660014019
- exit_code: -4
  program: "\n/// You're a hungry rabbit, and you already have eaten a certain number\
    \ of carrots,\n/// but now you need to eat more carrots to complete the day's\
    \ meals.\n/// you should return an array of [ total number of eaten carrots after\
    \ your meals,\n/// the number of carrots left after your meals ]\n/// if there\
    \ are not enough remaining carrots, you will eat all remaining carrots, but will\
    \ still be hungry.\n/// Example:\n/// >>> eat(number: 5, need: 6, remaining: 10)\n\
    /// [11, 4]\n/// >>> eat(number: 4, need: 8, remaining: 9)\n/// [12, 1]\n/// >>>\
    \ eat(number: 1, need: 10, remaining: 10)\n/// [11, 0]\n/// >>> eat(number: 2,\
    \ need: 11, remaining: 5)\n/// [7, 0]\n/// Variables:\n/// @number : integer\n\
    /// the number of carrots that you have eaten.\n/// @need : integer\n/// the number\
    \ of carrots that you need to eat.\n/// @remaining : integer\n/// the number of\
    \ remaining carrots thet exist in stock\n/// Constrain:\n/// * 0 <= number <=\
    \ 1000\n/// * 0 <= need <= 1000\n/// * 0 <= remaining <= 1000\n/// Have fun :)\n\
    func eat(number: Int, need: Int, remaining: Int) -> [Int] {\n    return [number\
    \ + (remaining >= need ? need : remaining), remaining - need]\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(eat(number: 5, need: 6, remaining: 10) == [11, 4])\nassert(eat(number:\
    \ 4, need: 8, remaining: 9) == [12, 1])\nassert(eat(number: 1, need: 10, remaining:\
    \ 10) == [11, 0])\nassert(eat(number: 2, need: 11, remaining: 5) == [7, 0])\n\
    assert(eat(number: 4, need: 5, remaining: 7) == [9, 2])\nassert(eat(number: 4,\
    \ need: 5, remaining: 1) == [5, 0])"
  status: Exception
  stderr: 'tmp2yzdivfz/tmp2yzdivfz.swift:48: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002ab661fbac80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002ab661cb1b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002ab661cb1988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002ab661cb07b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmp2yzdivfz                        0x000056513b5da658 <unavailable> + 5720

    5    libc.so.6                          0x00002ab6621a6460 __libc_start_main +
    245

    6    tmp2yzdivfz                        0x000056513b5d9fc9 <unavailable> + 4041

    '
  stdout: ''
  timestamp: 1660014019
- exit_code: -4
  program: "\n/// You're a hungry rabbit, and you already have eaten a certain number\
    \ of carrots,\n/// but now you need to eat more carrots to complete the day's\
    \ meals.\n/// you should return an array of [ total number of eaten carrots after\
    \ your meals,\n/// the number of carrots left after your meals ]\n/// if there\
    \ are not enough remaining carrots, you will eat all remaining carrots, but will\
    \ still be hungry.\n/// Example:\n/// >>> eat(number: 5, need: 6, remaining: 10)\n\
    /// [11, 4]\n/// >>> eat(number: 4, need: 8, remaining: 9)\n/// [12, 1]\n/// >>>\
    \ eat(number: 1, need: 10, remaining: 10)\n/// [11, 0]\n/// >>> eat(number: 2,\
    \ need: 11, remaining: 5)\n/// [7, 0]\n/// Variables:\n/// @number : integer\n\
    /// the number of carrots that you have eaten.\n/// @need : integer\n/// the number\
    \ of carrots that you need to eat.\n/// @remaining : integer\n/// the number of\
    \ remaining carrots thet exist in stock\n/// Constrain:\n/// * 0 <= number <=\
    \ 1000\n/// * 0 <= need <= 1000\n/// * 0 <= remaining <= 1000\n/// Have fun :)\n\
    func eat(number: Int, need: Int, remaining: Int) -> [Int] {\n    let total = number\
    \ + remaining - need >= 0 ? need : need - number\n    return [total + number,\
    \ remaining - total]\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(eat(number:\
    \ 5, need: 6, remaining: 10) == [11, 4])\nassert(eat(number: 4, need: 8, remaining:\
    \ 9) == [12, 1])\nassert(eat(number: 1, need: 10, remaining: 10) == [11, 0])\n\
    assert(eat(number: 2, need: 11, remaining: 5) == [7, 0])\nassert(eat(number: 4,\
    \ need: 5, remaining: 7) == [9, 2])\nassert(eat(number: 4, need: 5, remaining:\
    \ 1) == [5, 0])"
  status: Exception
  stderr: 'tmpwuok44gh/tmpwuok44gh.swift:49: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b37147d0c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b37144c7b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b37144c7988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b37144c67b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpwuok44gh                        0x0000564c33c3e658 <unavailable> + 5720

    5    libc.so.6                          0x00002b37149bc460 __libc_start_main +
    245

    6    tmpwuok44gh                        0x0000564c33c3dfc9 <unavailable> + 4041

    '
  stdout: ''
  timestamp: 1660014020
- exit_code: 0
  program: "\n/// You're a hungry rabbit, and you already have eaten a certain number\
    \ of carrots,\n/// but now you need to eat more carrots to complete the day's\
    \ meals.\n/// you should return an array of [ total number of eaten carrots after\
    \ your meals,\n/// the number of carrots left after your meals ]\n/// if there\
    \ are not enough remaining carrots, you will eat all remaining carrots, but will\
    \ still be hungry.\n/// Example:\n/// >>> eat(number: 5, need: 6, remaining: 10)\n\
    /// [11, 4]\n/// >>> eat(number: 4, need: 8, remaining: 9)\n/// [12, 1]\n/// >>>\
    \ eat(number: 1, need: 10, remaining: 10)\n/// [11, 0]\n/// >>> eat(number: 2,\
    \ need: 11, remaining: 5)\n/// [7, 0]\n/// Variables:\n/// @number : integer\n\
    /// the number of carrots that you have eaten.\n/// @need : integer\n/// the number\
    \ of carrots that you need to eat.\n/// @remaining : integer\n/// the number of\
    \ remaining carrots thet exist in stock\n/// Constrain:\n/// * 0 <= number <=\
    \ 1000\n/// * 0 <= need <= 1000\n/// * 0 <= remaining <= 1000\n/// Have fun :)\n\
    func eat(number: Int, need: Int, remaining: Int) -> [Int] {\n    var res = [Int]()\n\
    \    if remaining >= need {\n        res.append(number + need)\n        res.append(remaining\
    \ - need)\n    } else {\n        res.append(number + remaining)\n        res.append(0)\n\
    \    }\n    return res\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(eat(number:\
    \ 5, need: 6, remaining: 10) == [11, 4])\nassert(eat(number: 4, need: 8, remaining:\
    \ 9) == [12, 1])\nassert(eat(number: 1, need: 10, remaining: 10) == [11, 0])\n\
    assert(eat(number: 2, need: 11, remaining: 5) == [7, 0])\nassert(eat(number: 4,\
    \ need: 5, remaining: 7) == [9, 2])\nassert(eat(number: 4, need: 5, remaining:\
    \ 1) == [5, 0])"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660014020
- exit_code: 0
  program: "\n/// You're a hungry rabbit, and you already have eaten a certain number\
    \ of carrots,\n/// but now you need to eat more carrots to complete the day's\
    \ meals.\n/// you should return an array of [ total number of eaten carrots after\
    \ your meals,\n/// the number of carrots left after your meals ]\n/// if there\
    \ are not enough remaining carrots, you will eat all remaining carrots, but will\
    \ still be hungry.\n/// Example:\n/// >>> eat(number: 5, need: 6, remaining: 10)\n\
    /// [11, 4]\n/// >>> eat(number: 4, need: 8, remaining: 9)\n/// [12, 1]\n/// >>>\
    \ eat(number: 1, need: 10, remaining: 10)\n/// [11, 0]\n/// >>> eat(number: 2,\
    \ need: 11, remaining: 5)\n/// [7, 0]\n/// Variables:\n/// @number : integer\n\
    /// the number of carrots that you have eaten.\n/// @need : integer\n/// the number\
    \ of carrots that you need to eat.\n/// @remaining : integer\n/// the number of\
    \ remaining carrots thet exist in stock\n/// Constrain:\n/// * 0 <= number <=\
    \ 1000\n/// * 0 <= need <= 1000\n/// * 0 <= remaining <= 1000\n/// Have fun :)\n\
    func eat(number: Int, need: Int, remaining: Int) -> [Int] {\n    \n    var result\
    \ = [0,0]\n    var required = number + need\n    var total = remaining + number\n\
    \    \n    if required > total {\n        required = total\n    }\n    \n    result[0]\
    \ = required\n    result[1] = total - required\n    \n    return result\n}\n\n\
    \nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(eat(number: 5, need: 6, remaining: 10) == [11,\
    \ 4])\nassert(eat(number: 4, need: 8, remaining: 9) == [12, 1])\nassert(eat(number:\
    \ 1, need: 10, remaining: 10) == [11, 0])\nassert(eat(number: 2, need: 11, remaining:\
    \ 5) == [7, 0])\nassert(eat(number: 4, need: 5, remaining: 7) == [9, 2])\nassert(eat(number:\
    \ 4, need: 5, remaining: 1) == [5, 0])"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660014020
- exit_code: -4
  program: "\n/// You're a hungry rabbit, and you already have eaten a certain number\
    \ of carrots,\n/// but now you need to eat more carrots to complete the day's\
    \ meals.\n/// you should return an array of [ total number of eaten carrots after\
    \ your meals,\n/// the number of carrots left after your meals ]\n/// if there\
    \ are not enough remaining carrots, you will eat all remaining carrots, but will\
    \ still be hungry.\n/// Example:\n/// >>> eat(number: 5, need: 6, remaining: 10)\n\
    /// [11, 4]\n/// >>> eat(number: 4, need: 8, remaining: 9)\n/// [12, 1]\n/// >>>\
    \ eat(number: 1, need: 10, remaining: 10)\n/// [11, 0]\n/// >>> eat(number: 2,\
    \ need: 11, remaining: 5)\n/// [7, 0]\n/// Variables:\n/// @number : integer\n\
    /// the number of carrots that you have eaten.\n/// @need : integer\n/// the number\
    \ of carrots that you need to eat.\n/// @remaining : integer\n/// the number of\
    \ remaining carrots thet exist in stock\n/// Constrain:\n/// * 0 <= number <=\
    \ 1000\n/// * 0 <= need <= 1000\n/// * 0 <= remaining <= 1000\n/// Have fun :)\n\
    func eat(number: Int, need: Int, remaining: Int) -> [Int] {\n    let carrotAfterMeals\
    \ = number + need\n    let carrotLeft = carrotAfterMeals - remaining\n    if carrotLeft\
    \ > 0 {\n        return [carrotAfterMeals, 0]\n    } else {\n        return [carrotAfterMeals,\
    \ remaining - carrotAfterMeals]\n    }\n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(eat(number: 5, need: 6, remaining: 10) == [11, 4])\nassert(eat(number:\
    \ 4, need: 8, remaining: 9) == [12, 1])\nassert(eat(number: 1, need: 10, remaining:\
    \ 10) == [11, 0])\nassert(eat(number: 2, need: 11, remaining: 5) == [7, 0])\n\
    assert(eat(number: 4, need: 5, remaining: 7) == [9, 2])\nassert(eat(number: 4,\
    \ need: 5, remaining: 1) == [5, 0])"
  status: Exception
  stderr: 'tmpytl8vxj9/tmpytl8vxj9.swift:51: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002ba6993b9c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002ba6990b0b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002ba6990b0988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002ba6990af7b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpytl8vxj9                        0x00005557a4671384 <unavailable> + 4996

    5    libc.so.6                          0x00002ba6995a5460 __libc_start_main +
    245

    6    tmpytl8vxj9                        0x00005557a4670fc9 <unavailable> + 4041

    '
  stdout: ''
  timestamp: 1660014020
- exit_code: -4
  program: "\n/// You're a hungry rabbit, and you already have eaten a certain number\
    \ of carrots,\n/// but now you need to eat more carrots to complete the day's\
    \ meals.\n/// you should return an array of [ total number of eaten carrots after\
    \ your meals,\n/// the number of carrots left after your meals ]\n/// if there\
    \ are not enough remaining carrots, you will eat all remaining carrots, but will\
    \ still be hungry.\n/// Example:\n/// >>> eat(number: 5, need: 6, remaining: 10)\n\
    /// [11, 4]\n/// >>> eat(number: 4, need: 8, remaining: 9)\n/// [12, 1]\n/// >>>\
    \ eat(number: 1, need: 10, remaining: 10)\n/// [11, 0]\n/// >>> eat(number: 2,\
    \ need: 11, remaining: 5)\n/// [7, 0]\n/// Variables:\n/// @number : integer\n\
    /// the number of carrots that you have eaten.\n/// @need : integer\n/// the number\
    \ of carrots that you need to eat.\n/// @remaining : integer\n/// the number of\
    \ remaining carrots thet exist in stock\n/// Constrain:\n/// * 0 <= number <=\
    \ 1000\n/// * 0 <= need <= 1000\n/// * 0 <= remaining <= 1000\n/// Have fun :)\n\
    func eat(number: Int, need: Int, remaining: Int) -> [Int] {\n    if remaining\
    \ < need - number {\n        return [number + remaining, 0]\n    }\n    return\
    \ [number + need, remaining - need + number]\n}\n\n\nfunc ==(left: [(Int, Int)],\
    \ right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n       \
    \ return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r\
    \ {\n            return false\n        }\n    }\n    return true\n}\n        \
    \    \nassert(eat(number: 5, need: 6, remaining: 10) == [11, 4])\nassert(eat(number:\
    \ 4, need: 8, remaining: 9) == [12, 1])\nassert(eat(number: 1, need: 10, remaining:\
    \ 10) == [11, 0])\nassert(eat(number: 2, need: 11, remaining: 5) == [7, 0])\n\
    assert(eat(number: 4, need: 5, remaining: 7) == [9, 2])\nassert(eat(number: 4,\
    \ need: 5, remaining: 1) == [5, 0])"
  status: Exception
  stderr: 'tmp22mo913u/tmp22mo913u.swift:48: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b2f47f77c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b2f47c6eb6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b2f47c6e988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b2f47c6d7b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmp22mo913u                        0x0000557be8d95384 <unavailable> + 4996

    5    libc.so.6                          0x00002b2f48163460 __libc_start_main +
    245

    6    tmp22mo913u                        0x0000557be8d94fc9 <unavailable> + 4041

    '
  stdout: ''
  timestamp: 1660014020
- exit_code: -4
  program: "\n/// You're a hungry rabbit, and you already have eaten a certain number\
    \ of carrots,\n/// but now you need to eat more carrots to complete the day's\
    \ meals.\n/// you should return an array of [ total number of eaten carrots after\
    \ your meals,\n/// the number of carrots left after your meals ]\n/// if there\
    \ are not enough remaining carrots, you will eat all remaining carrots, but will\
    \ still be hungry.\n/// Example:\n/// >>> eat(number: 5, need: 6, remaining: 10)\n\
    /// [11, 4]\n/// >>> eat(number: 4, need: 8, remaining: 9)\n/// [12, 1]\n/// >>>\
    \ eat(number: 1, need: 10, remaining: 10)\n/// [11, 0]\n/// >>> eat(number: 2,\
    \ need: 11, remaining: 5)\n/// [7, 0]\n/// Variables:\n/// @number : integer\n\
    /// the number of carrots that you have eaten.\n/// @need : integer\n/// the number\
    \ of carrots that you need to eat.\n/// @remaining : integer\n/// the number of\
    \ remaining carrots thet exist in stock\n/// Constrain:\n/// * 0 <= number <=\
    \ 1000\n/// * 0 <= need <= 1000\n/// * 0 <= remaining <= 1000\n/// Have fun :)\n\
    func eat(number: Int, need: Int, remaining: Int) -> [Int] {\n    if number + remaining\
    \ >= need {\n        return [need, remaining - (need - number)]\n    } else {\n\
    \        return [number + remaining, 0]\n    }\n}\n\n\nfunc ==(left: [(Int, Int)],\
    \ right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n       \
    \ return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r\
    \ {\n            return false\n        }\n    }\n    return true\n}\n        \
    \    \nassert(eat(number: 5, need: 6, remaining: 10) == [11, 4])\nassert(eat(number:\
    \ 4, need: 8, remaining: 9) == [12, 1])\nassert(eat(number: 1, need: 10, remaining:\
    \ 10) == [11, 0])\nassert(eat(number: 2, need: 11, remaining: 5) == [7, 0])\n\
    assert(eat(number: 4, need: 5, remaining: 7) == [9, 2])\nassert(eat(number: 4,\
    \ need: 5, remaining: 1) == [5, 0])"
  status: Exception
  stderr: 'tmputj49vw9/tmputj49vw9.swift:49: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b86b7d23c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b86b7a1ab6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b86b7a1a988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b86b7a197b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmputj49vw9                        0x00005645b5c1b384 <unavailable> + 4996

    5    libc.so.6                          0x00002b86b7f0f460 __libc_start_main +
    245

    6    tmputj49vw9                        0x00005645b5c1afc9 <unavailable> + 4041

    '
  stdout: ''
  timestamp: 1660014020
- exit_code: 0
  program: "\n/// You're a hungry rabbit, and you already have eaten a certain number\
    \ of carrots,\n/// but now you need to eat more carrots to complete the day's\
    \ meals.\n/// you should return an array of [ total number of eaten carrots after\
    \ your meals,\n/// the number of carrots left after your meals ]\n/// if there\
    \ are not enough remaining carrots, you will eat all remaining carrots, but will\
    \ still be hungry.\n/// Example:\n/// >>> eat(number: 5, need: 6, remaining: 10)\n\
    /// [11, 4]\n/// >>> eat(number: 4, need: 8, remaining: 9)\n/// [12, 1]\n/// >>>\
    \ eat(number: 1, need: 10, remaining: 10)\n/// [11, 0]\n/// >>> eat(number: 2,\
    \ need: 11, remaining: 5)\n/// [7, 0]\n/// Variables:\n/// @number : integer\n\
    /// the number of carrots that you have eaten.\n/// @need : integer\n/// the number\
    \ of carrots that you need to eat.\n/// @remaining : integer\n/// the number of\
    \ remaining carrots thet exist in stock\n/// Constrain:\n/// * 0 <= number <=\
    \ 1000\n/// * 0 <= need <= 1000\n/// * 0 <= remaining <= 1000\n/// Have fun :)\n\
    func eat(number: Int, need: Int, remaining: Int) -> [Int] {\n    var result =\
    \ Array(repeating: 0, count: 2)\n    if remaining == 0 {\n        result[0] =\
    \ number\n        result[1] = 0\n    } else if remaining <= need {\n        result[0]\
    \ = number + remaining\n        result[1] = 0\n    } else {\n        result[0]\
    \ = number + need\n        result[1] = remaining - need\n    }\n    return result\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(eat(number: 5, need: 6, remaining: 10) == [11,\
    \ 4])\nassert(eat(number: 4, need: 8, remaining: 9) == [12, 1])\nassert(eat(number:\
    \ 1, need: 10, remaining: 10) == [11, 0])\nassert(eat(number: 2, need: 11, remaining:\
    \ 5) == [7, 0])\nassert(eat(number: 4, need: 5, remaining: 7) == [9, 2])\nassert(eat(number:\
    \ 4, need: 5, remaining: 1) == [5, 0])"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660014020
- exit_code: 0
  program: "\n/// You're a hungry rabbit, and you already have eaten a certain number\
    \ of carrots,\n/// but now you need to eat more carrots to complete the day's\
    \ meals.\n/// you should return an array of [ total number of eaten carrots after\
    \ your meals,\n/// the number of carrots left after your meals ]\n/// if there\
    \ are not enough remaining carrots, you will eat all remaining carrots, but will\
    \ still be hungry.\n/// Example:\n/// >>> eat(number: 5, need: 6, remaining: 10)\n\
    /// [11, 4]\n/// >>> eat(number: 4, need: 8, remaining: 9)\n/// [12, 1]\n/// >>>\
    \ eat(number: 1, need: 10, remaining: 10)\n/// [11, 0]\n/// >>> eat(number: 2,\
    \ need: 11, remaining: 5)\n/// [7, 0]\n/// Variables:\n/// @number : integer\n\
    /// the number of carrots that you have eaten.\n/// @need : integer\n/// the number\
    \ of carrots that you need to eat.\n/// @remaining : integer\n/// the number of\
    \ remaining carrots thet exist in stock\n/// Constrain:\n/// * 0 <= number <=\
    \ 1000\n/// * 0 <= need <= 1000\n/// * 0 <= remaining <= 1000\n/// Have fun :)\n\
    func eat(number: Int, need: Int, remaining: Int) -> [Int] {\n    \n    // if remaining\
    \ amount is less than need than eat all remaining amount\n    if remaining < need\
    \ {\n        return [number + remaining, 0]\n    }\n    \n    // eat all need\
    \ amount\n    return [number + need, remaining - need]\n}\n\n\nfunc ==(left: [(Int,\
    \ Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n\
    \        return false\n    }\n    for (l, r) in zip(left, right) {\n        if\
    \ l != r {\n            return false\n        }\n    }\n    return true\n}\n \
    \           \nassert(eat(number: 5, need: 6, remaining: 10) == [11, 4])\nassert(eat(number:\
    \ 4, need: 8, remaining: 9) == [12, 1])\nassert(eat(number: 1, need: 10, remaining:\
    \ 10) == [11, 0])\nassert(eat(number: 2, need: 11, remaining: 5) == [7, 0])\n\
    assert(eat(number: 4, need: 5, remaining: 7) == [9, 2])\nassert(eat(number: 4,\
    \ need: 5, remaining: 1) == [5, 0])"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660014020
- exit_code: -4
  program: "\n/// You're a hungry rabbit, and you already have eaten a certain number\
    \ of carrots,\n/// but now you need to eat more carrots to complete the day's\
    \ meals.\n/// you should return an array of [ total number of eaten carrots after\
    \ your meals,\n/// the number of carrots left after your meals ]\n/// if there\
    \ are not enough remaining carrots, you will eat all remaining carrots, but will\
    \ still be hungry.\n/// Example:\n/// >>> eat(number: 5, need: 6, remaining: 10)\n\
    /// [11, 4]\n/// >>> eat(number: 4, need: 8, remaining: 9)\n/// [12, 1]\n/// >>>\
    \ eat(number: 1, need: 10, remaining: 10)\n/// [11, 0]\n/// >>> eat(number: 2,\
    \ need: 11, remaining: 5)\n/// [7, 0]\n/// Variables:\n/// @number : integer\n\
    /// the number of carrots that you have eaten.\n/// @need : integer\n/// the number\
    \ of carrots that you need to eat.\n/// @remaining : integer\n/// the number of\
    \ remaining carrots thet exist in stock\n/// Constrain:\n/// * 0 <= number <=\
    \ 1000\n/// * 0 <= need <= 1000\n/// * 0 <= remaining <= 1000\n/// Have fun :)\n\
    func eat(number: Int, need: Int, remaining: Int) -> [Int] {\n    let total = number\
    \ + remaining\n    let eaten = total >= need ? need : total\n    return [eaten,\
    \ total - eaten]\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool\
    \ {\n    if left.count != right.count {\n        return false\n    }\n    for\
    \ (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(eat(number: 5, need:\
    \ 6, remaining: 10) == [11, 4])\nassert(eat(number: 4, need: 8, remaining: 9)\
    \ == [12, 1])\nassert(eat(number: 1, need: 10, remaining: 10) == [11, 0])\nassert(eat(number:\
    \ 2, need: 11, remaining: 5) == [7, 0])\nassert(eat(number: 4, need: 5, remaining:\
    \ 7) == [9, 2])\nassert(eat(number: 4, need: 5, remaining: 1) == [5, 0])"
  status: Exception
  stderr: 'tmpz9wr2vgy/tmpz9wr2vgy.swift:47: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b845660ec80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b8456305b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b8456305988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b84563047b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpz9wr2vgy                        0x000055d5af66d384 <unavailable> + 4996

    5    libc.so.6                          0x00002b84567fa460 __libc_start_main +
    245

    6    tmpz9wr2vgy                        0x000055d5af66cfc9 <unavailable> + 4041

    '
  stdout: ''
  timestamp: 1660013824
- exit_code: -4
  program: "\n/// You're a hungry rabbit, and you already have eaten a certain number\
    \ of carrots,\n/// but now you need to eat more carrots to complete the day's\
    \ meals.\n/// you should return an array of [ total number of eaten carrots after\
    \ your meals,\n/// the number of carrots left after your meals ]\n/// if there\
    \ are not enough remaining carrots, you will eat all remaining carrots, but will\
    \ still be hungry.\n/// Example:\n/// >>> eat(number: 5, need: 6, remaining: 10)\n\
    /// [11, 4]\n/// >>> eat(number: 4, need: 8, remaining: 9)\n/// [12, 1]\n/// >>>\
    \ eat(number: 1, need: 10, remaining: 10)\n/// [11, 0]\n/// >>> eat(number: 2,\
    \ need: 11, remaining: 5)\n/// [7, 0]\n/// Variables:\n/// @number : integer\n\
    /// the number of carrots that you have eaten.\n/// @need : integer\n/// the number\
    \ of carrots that you need to eat.\n/// @remaining : integer\n/// the number of\
    \ remaining carrots thet exist in stock\n/// Constrain:\n/// * 0 <= number <=\
    \ 1000\n/// * 0 <= need <= 1000\n/// * 0 <= remaining <= 1000\n/// Have fun :)\n\
    func eat(number: Int, need: Int, remaining: Int) -> [Int] {\n    let carrots =\
    \ number + remaining\n    if carrots >= need {\n        return [need, carrots\
    \ - need]\n    } else {\n        return [carrots, 0]\n    }\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(eat(number: 5, need: 6, remaining: 10) == [11, 4])\nassert(eat(number:\
    \ 4, need: 8, remaining: 9) == [12, 1])\nassert(eat(number: 1, need: 10, remaining:\
    \ 10) == [11, 0])\nassert(eat(number: 2, need: 11, remaining: 5) == [7, 0])\n\
    assert(eat(number: 4, need: 5, remaining: 7) == [9, 2])\nassert(eat(number: 4,\
    \ need: 5, remaining: 1) == [5, 0])"
  status: Exception
  stderr: 'tmpnk0zb4zj/tmpnk0zb4zj.swift:50: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002afa977e6c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002afa974ddb6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002afa974dd988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002afa974dc7b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpnk0zb4zj                        0x0000561c51bff384 <unavailable> + 4996

    5    libc.so.6                          0x00002afa979d2460 __libc_start_main +
    245

    6    tmpnk0zb4zj                        0x0000561c51bfefc9 <unavailable> + 4041

    '
  stdout: ''
  timestamp: 1660014020
- exit_code: -4
  program: "\n/// You're a hungry rabbit, and you already have eaten a certain number\
    \ of carrots,\n/// but now you need to eat more carrots to complete the day's\
    \ meals.\n/// you should return an array of [ total number of eaten carrots after\
    \ your meals,\n/// the number of carrots left after your meals ]\n/// if there\
    \ are not enough remaining carrots, you will eat all remaining carrots, but will\
    \ still be hungry.\n/// Example:\n/// >>> eat(number: 5, need: 6, remaining: 10)\n\
    /// [11, 4]\n/// >>> eat(number: 4, need: 8, remaining: 9)\n/// [12, 1]\n/// >>>\
    \ eat(number: 1, need: 10, remaining: 10)\n/// [11, 0]\n/// >>> eat(number: 2,\
    \ need: 11, remaining: 5)\n/// [7, 0]\n/// Variables:\n/// @number : integer\n\
    /// the number of carrots that you have eaten.\n/// @need : integer\n/// the number\
    \ of carrots that you need to eat.\n/// @remaining : integer\n/// the number of\
    \ remaining carrots thet exist in stock\n/// Constrain:\n/// * 0 <= number <=\
    \ 1000\n/// * 0 <= need <= 1000\n/// * 0 <= remaining <= 1000\n/// Have fun :)\n\
    func eat(number: Int, need: Int, remaining: Int) -> [Int] {\n  let carrot = number\
    \ + need - remaining\n  if carrot > 0 {\n    return [carrot, 0]\n  } else {\n\
    \    return [number + need, -carrot]\n  }\n}\n\n\nfunc ==(left: [(Int, Int)],\
    \ right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n       \
    \ return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r\
    \ {\n            return false\n        }\n    }\n    return true\n}\n        \
    \    \nassert(eat(number: 5, need: 6, remaining: 10) == [11, 4])\nassert(eat(number:\
    \ 4, need: 8, remaining: 9) == [12, 1])\nassert(eat(number: 1, need: 10, remaining:\
    \ 10) == [11, 0])\nassert(eat(number: 2, need: 11, remaining: 5) == [7, 0])\n\
    assert(eat(number: 4, need: 5, remaining: 7) == [9, 2])\nassert(eat(number: 4,\
    \ need: 5, remaining: 1) == [5, 0])"
  status: Exception
  stderr: 'tmp3hafjis0/tmp3hafjis0.swift:50: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002afd4eee6c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002afd4ebddb6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002afd4ebdd988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002afd4ebdc7b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmp3hafjis0                        0x0000563128bb6384 <unavailable> + 4996

    5    libc.so.6                          0x00002afd4f0d2460 __libc_start_main +
    245

    6    tmp3hafjis0                        0x0000563128bb5fc9 <unavailable> + 4041

    '
  stdout: ''
  timestamp: 1660014020
- exit_code: 1
  program: "\n/// You're a hungry rabbit, and you already have eaten a certain number\
    \ of carrots,\n/// but now you need to eat more carrots to complete the day's\
    \ meals.\n/// you should return an array of [ total number of eaten carrots after\
    \ your meals,\n/// the number of carrots left after your meals ]\n/// if there\
    \ are not enough remaining carrots, you will eat all remaining carrots, but will\
    \ still be hungry.\n/// Example:\n/// >>> eat(number: 5, need: 6, remaining: 10)\n\
    /// [11, 4]\n/// >>> eat(number: 4, need: 8, remaining: 9)\n/// [12, 1]\n/// >>>\
    \ eat(number: 1, need: 10, remaining: 10)\n/// [11, 0]\n/// >>> eat(number: 2,\
    \ need: 11, remaining: 5)\n/// [7, 0]\n/// Variables:\n/// @number : integer\n\
    /// the number of carrots that you have eaten.\n/// @need : integer\n/// the number\
    \ of carrots that you need to eat.\n/// @remaining : integer\n/// the number of\
    \ remaining carrots thet exist in stock\n/// Constrain:\n/// * 0 <= number <=\
    \ 1000\n/// * 0 <= need <= 1000\n/// * 0 <= remaining <= 1000\n/// Have fun :)\n\
    func eat(number: Int, need: Int, remaining: Int) -> [Int] {\n  var carrots = number\
    \ + remaining\n  carrots >= need ? [need, carrots - need] : [carrots, 0]\n}\n\n\
    \nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(eat(number: 5, need: 6, remaining: 10) == [11,\
    \ 4])\nassert(eat(number: 4, need: 8, remaining: 9) == [12, 1])\nassert(eat(number:\
    \ 1, need: 10, remaining: 10) == [11, 0])\nassert(eat(number: 2, need: 11, remaining:\
    \ 5) == [7, 0])\nassert(eat(number: 4, need: 5, remaining: 7) == [9, 2])\nassert(eat(number:\
    \ 4, need: 5, remaining: 1) == [5, 0])"
  status: SyntaxError
  stderr: "/tmp/tmpuq7hvbbx.swift:30:19: warning: expression of type '[Int]' is unused\n\
    \  carrots >= need ? [need, carrots - need] : [carrots, 0]\n  ~~~~~~~~~~~~~~~~^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n\
    /tmp/tmpuq7hvbbx.swift:29:7: warning: variable 'carrots' was never mutated; consider\
    \ changing to 'let' constant\n  var carrots = number + remaining\n  ~~~ ^\n  let\n\
    /tmp/tmpuq7hvbbx.swift:30:3: error: missing return in global function expected\
    \ to return '[Int]'\n  carrots >= need ? [need, carrots - need] : [carrots, 0]\n\
    \  ^\n/tmp/tmpuq7hvbbx.swift:30:3: note: did you mean to return the last expression?\n\
    \  carrots >= need ? [need, carrots - need] : [carrots, 0]\n  ^\n  return \n"
  stdout: ''
  timestamp: 1660014020
- exit_code: 0
  program: "\n/// You're a hungry rabbit, and you already have eaten a certain number\
    \ of carrots,\n/// but now you need to eat more carrots to complete the day's\
    \ meals.\n/// you should return an array of [ total number of eaten carrots after\
    \ your meals,\n/// the number of carrots left after your meals ]\n/// if there\
    \ are not enough remaining carrots, you will eat all remaining carrots, but will\
    \ still be hungry.\n/// Example:\n/// >>> eat(number: 5, need: 6, remaining: 10)\n\
    /// [11, 4]\n/// >>> eat(number: 4, need: 8, remaining: 9)\n/// [12, 1]\n/// >>>\
    \ eat(number: 1, need: 10, remaining: 10)\n/// [11, 0]\n/// >>> eat(number: 2,\
    \ need: 11, remaining: 5)\n/// [7, 0]\n/// Variables:\n/// @number : integer\n\
    /// the number of carrots that you have eaten.\n/// @need : integer\n/// the number\
    \ of carrots that you need to eat.\n/// @remaining : integer\n/// the number of\
    \ remaining carrots thet exist in stock\n/// Constrain:\n/// * 0 <= number <=\
    \ 1000\n/// * 0 <= need <= 1000\n/// * 0 <= remaining <= 1000\n/// Have fun :)\n\
    func eat(number: Int, need: Int, remaining: Int) -> [Int] {\n    var totalCarrots\
    \ = number\n    var remainingCarrots = remaining\n    if remainingCarrots < need\
    \ {\n        totalCarrots += remainingCarrots\n        remainingCarrots = 0\n\
    \    } else {\n        totalCarrots += need\n        remainingCarrots -= need\n\
    \    }\n    return [totalCarrots, remainingCarrots]\n}\n\n\nfunc ==(left: [(Int,\
    \ Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n\
    \        return false\n    }\n    for (l, r) in zip(left, right) {\n        if\
    \ l != r {\n            return false\n        }\n    }\n    return true\n}\n \
    \           \nassert(eat(number: 5, need: 6, remaining: 10) == [11, 4])\nassert(eat(number:\
    \ 4, need: 8, remaining: 9) == [12, 1])\nassert(eat(number: 1, need: 10, remaining:\
    \ 10) == [11, 0])\nassert(eat(number: 2, need: 11, remaining: 5) == [7, 0])\n\
    assert(eat(number: 4, need: 5, remaining: 7) == [9, 2])\nassert(eat(number: 4,\
    \ need: 5, remaining: 1) == [5, 0])"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660014020
- exit_code: -4
  program: "\n/// You're a hungry rabbit, and you already have eaten a certain number\
    \ of carrots,\n/// but now you need to eat more carrots to complete the day's\
    \ meals.\n/// you should return an array of [ total number of eaten carrots after\
    \ your meals,\n/// the number of carrots left after your meals ]\n/// if there\
    \ are not enough remaining carrots, you will eat all remaining carrots, but will\
    \ still be hungry.\n/// Example:\n/// >>> eat(number: 5, need: 6, remaining: 10)\n\
    /// [11, 4]\n/// >>> eat(number: 4, need: 8, remaining: 9)\n/// [12, 1]\n/// >>>\
    \ eat(number: 1, need: 10, remaining: 10)\n/// [11, 0]\n/// >>> eat(number: 2,\
    \ need: 11, remaining: 5)\n/// [7, 0]\n/// Variables:\n/// @number : integer\n\
    /// the number of carrots that you have eaten.\n/// @need : integer\n/// the number\
    \ of carrots that you need to eat.\n/// @remaining : integer\n/// the number of\
    \ remaining carrots thet exist in stock\n/// Constrain:\n/// * 0 <= number <=\
    \ 1000\n/// * 0 <= need <= 1000\n/// * 0 <= remaining <= 1000\n/// Have fun :)\n\
    func eat(number: Int, need: Int, remaining: Int) -> [Int] {\n    let total = number\
    \ + remaining\n    let totalNeed = total - need\n    if totalNeed > 0 {\n    \
    \    return [need, totalNeed]\n    } else {\n        return [total, 0]\n    }\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(eat(number: 5, need: 6, remaining: 10) == [11,\
    \ 4])\nassert(eat(number: 4, need: 8, remaining: 9) == [12, 1])\nassert(eat(number:\
    \ 1, need: 10, remaining: 10) == [11, 0])\nassert(eat(number: 2, need: 11, remaining:\
    \ 5) == [7, 0])\nassert(eat(number: 4, need: 5, remaining: 7) == [9, 2])\nassert(eat(number:\
    \ 4, need: 5, remaining: 1) == [5, 0])"
  status: Exception
  stderr: 'tmp92ru0_r1/tmp92ru0_r1.swift:51: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002accb2070c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002accb1d67b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002accb1d67988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002accb1d667b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmp92ru0_r1                        0x0000559421514384 <unavailable> + 4996

    5    libc.so.6                          0x00002accb225c460 __libc_start_main +
    245

    6    tmp92ru0_r1                        0x0000559421513fc9 <unavailable> + 4041

    '
  stdout: ''
  timestamp: 1660014020
- exit_code: -4
  program: "\n/// You're a hungry rabbit, and you already have eaten a certain number\
    \ of carrots,\n/// but now you need to eat more carrots to complete the day's\
    \ meals.\n/// you should return an array of [ total number of eaten carrots after\
    \ your meals,\n/// the number of carrots left after your meals ]\n/// if there\
    \ are not enough remaining carrots, you will eat all remaining carrots, but will\
    \ still be hungry.\n/// Example:\n/// >>> eat(number: 5, need: 6, remaining: 10)\n\
    /// [11, 4]\n/// >>> eat(number: 4, need: 8, remaining: 9)\n/// [12, 1]\n/// >>>\
    \ eat(number: 1, need: 10, remaining: 10)\n/// [11, 0]\n/// >>> eat(number: 2,\
    \ need: 11, remaining: 5)\n/// [7, 0]\n/// Variables:\n/// @number : integer\n\
    /// the number of carrots that you have eaten.\n/// @need : integer\n/// the number\
    \ of carrots that you need to eat.\n/// @remaining : integer\n/// the number of\
    \ remaining carrots thet exist in stock\n/// Constrain:\n/// * 0 <= number <=\
    \ 1000\n/// * 0 <= need <= 1000\n/// * 0 <= remaining <= 1000\n/// Have fun :)\n\
    func eat(number: Int, need: Int, remaining: Int) -> [Int] {\n    \n    let carrotsToEat\
    \ = need - number\n    let totalEaten = remaining > carrotsToEat ? number + carrotsToEat\
    \ : number + remaining\n    let remainingCarrots = remaining > carrotsToEat ?\
    \ remaining - carrotsToEat : 0\n    \n    return [totalEaten, remainingCarrots]\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(eat(number: 5, need: 6, remaining: 10) == [11,\
    \ 4])\nassert(eat(number: 4, need: 8, remaining: 9) == [12, 1])\nassert(eat(number:\
    \ 1, need: 10, remaining: 10) == [11, 0])\nassert(eat(number: 2, need: 11, remaining:\
    \ 5) == [7, 0])\nassert(eat(number: 4, need: 5, remaining: 7) == [9, 2])\nassert(eat(number:\
    \ 4, need: 5, remaining: 1) == [5, 0])"
  status: Exception
  stderr: 'tmp0s1wwjd4/tmp0s1wwjd4.swift:50: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002ad18f713c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002ad18f40ab6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002ad18f40a988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002ad18f4097b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmp0s1wwjd4                        0x000055cf304a2384 <unavailable> + 4996

    5    libc.so.6                          0x00002ad18f8ff460 __libc_start_main +
    245

    6    tmp0s1wwjd4                        0x000055cf304a1fc9 <unavailable> + 4041

    '
  stdout: ''
  timestamp: 1660014020
- exit_code: -4
  program: "\n/// You're a hungry rabbit, and you already have eaten a certain number\
    \ of carrots,\n/// but now you need to eat more carrots to complete the day's\
    \ meals.\n/// you should return an array of [ total number of eaten carrots after\
    \ your meals,\n/// the number of carrots left after your meals ]\n/// if there\
    \ are not enough remaining carrots, you will eat all remaining carrots, but will\
    \ still be hungry.\n/// Example:\n/// >>> eat(number: 5, need: 6, remaining: 10)\n\
    /// [11, 4]\n/// >>> eat(number: 4, need: 8, remaining: 9)\n/// [12, 1]\n/// >>>\
    \ eat(number: 1, need: 10, remaining: 10)\n/// [11, 0]\n/// >>> eat(number: 2,\
    \ need: 11, remaining: 5)\n/// [7, 0]\n/// Variables:\n/// @number : integer\n\
    /// the number of carrots that you have eaten.\n/// @need : integer\n/// the number\
    \ of carrots that you need to eat.\n/// @remaining : integer\n/// the number of\
    \ remaining carrots thet exist in stock\n/// Constrain:\n/// * 0 <= number <=\
    \ 1000\n/// * 0 <= need <= 1000\n/// * 0 <= remaining <= 1000\n/// Have fun :)\n\
    func eat(number: Int, need: Int, remaining: Int) -> [Int] {\n    // your code\
    \ is here :)\n    return [0, 0]\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int,\
    \ Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n\
    \    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n          \
    \  return false\n        }\n    }\n    return true\n}\n            \nassert(eat(number:\
    \ 5, need: 6, remaining: 10) == [11, 4])\nassert(eat(number: 4, need: 8, remaining:\
    \ 9) == [12, 1])\nassert(eat(number: 1, need: 10, remaining: 10) == [11, 0])\n\
    assert(eat(number: 2, need: 11, remaining: 5) == [7, 0])\nassert(eat(number: 4,\
    \ need: 5, remaining: 7) == [9, 2])\nassert(eat(number: 4, need: 5, remaining:\
    \ 1) == [5, 0])"
  status: Exception
  stderr: 'tmpnhjsf2uu/tmpnhjsf2uu.swift:46: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b7a63229c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b7a62f20b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b7a62f20988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b7a62f1f7b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpnhjsf2uu                        0x0000557192806384 <unavailable> + 4996

    5    libc.so.6                          0x00002b7a63415460 __libc_start_main +
    245

    6    tmpnhjsf2uu                        0x0000557192805fc9 <unavailable> + 4041

    '
  stdout: ''
  timestamp: 1660014020
- exit_code: -4
  program: "\n/// You're a hungry rabbit, and you already have eaten a certain number\
    \ of carrots,\n/// but now you need to eat more carrots to complete the day's\
    \ meals.\n/// you should return an array of [ total number of eaten carrots after\
    \ your meals,\n/// the number of carrots left after your meals ]\n/// if there\
    \ are not enough remaining carrots, you will eat all remaining carrots, but will\
    \ still be hungry.\n/// Example:\n/// >>> eat(number: 5, need: 6, remaining: 10)\n\
    /// [11, 4]\n/// >>> eat(number: 4, need: 8, remaining: 9)\n/// [12, 1]\n/// >>>\
    \ eat(number: 1, need: 10, remaining: 10)\n/// [11, 0]\n/// >>> eat(number: 2,\
    \ need: 11, remaining: 5)\n/// [7, 0]\n/// Variables:\n/// @number : integer\n\
    /// the number of carrots that you have eaten.\n/// @need : integer\n/// the number\
    \ of carrots that you need to eat.\n/// @remaining : integer\n/// the number of\
    \ remaining carrots thet exist in stock\n/// Constrain:\n/// * 0 <= number <=\
    \ 1000\n/// * 0 <= need <= 1000\n/// * 0 <= remaining <= 1000\n/// Have fun :)\n\
    func eat(number: Int, need: Int, remaining: Int) -> [Int] {\n    var need = need\n\
    \    var number = number\n    if need >= remaining {\n        let r = need - remaining\n\
    \        need = need - r\n        number = number + remaining\n    } else {\n\
    \        number = number + need\n        need = 0\n    }\n    return [number,\
    \ need]\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n \
    \   if left.count != right.count {\n        return false\n    }\n    for (l, r)\
    \ in zip(left, right) {\n        if l != r {\n            return false\n     \
    \   }\n    }\n    return true\n}\n            \nassert(eat(number: 5, need: 6,\
    \ remaining: 10) == [11, 4])\nassert(eat(number: 4, need: 8, remaining: 9) ==\
    \ [12, 1])\nassert(eat(number: 1, need: 10, remaining: 10) == [11, 0])\nassert(eat(number:\
    \ 2, need: 11, remaining: 5) == [7, 0])\nassert(eat(number: 4, need: 5, remaining:\
    \ 7) == [9, 2])\nassert(eat(number: 4, need: 5, remaining: 1) == [5, 0])"
  status: Exception
  stderr: 'tmp76ba7ugz/tmp76ba7ugz.swift:55: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b118e5d1c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b118e2c8b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b118e2c8988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b118e2c77b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmp76ba7ugz                        0x00005644e1de5384 <unavailable> + 4996

    5    libc.so.6                          0x00002b118e7bd460 __libc_start_main +
    245

    6    tmp76ba7ugz                        0x00005644e1de4fc9 <unavailable> + 4041

    '
  stdout: ''
  timestamp: 1660014020
- exit_code: -4
  program: "\n/// You're a hungry rabbit, and you already have eaten a certain number\
    \ of carrots,\n/// but now you need to eat more carrots to complete the day's\
    \ meals.\n/// you should return an array of [ total number of eaten carrots after\
    \ your meals,\n/// the number of carrots left after your meals ]\n/// if there\
    \ are not enough remaining carrots, you will eat all remaining carrots, but will\
    \ still be hungry.\n/// Example:\n/// >>> eat(number: 5, need: 6, remaining: 10)\n\
    /// [11, 4]\n/// >>> eat(number: 4, need: 8, remaining: 9)\n/// [12, 1]\n/// >>>\
    \ eat(number: 1, need: 10, remaining: 10)\n/// [11, 0]\n/// >>> eat(number: 2,\
    \ need: 11, remaining: 5)\n/// [7, 0]\n/// Variables:\n/// @number : integer\n\
    /// the number of carrots that you have eaten.\n/// @need : integer\n/// the number\
    \ of carrots that you need to eat.\n/// @remaining : integer\n/// the number of\
    \ remaining carrots thet exist in stock\n/// Constrain:\n/// * 0 <= number <=\
    \ 1000\n/// * 0 <= need <= 1000\n/// * 0 <= remaining <= 1000\n/// Have fun :)\n\
    func eat(number: Int, need: Int, remaining: Int) -> [Int] {\n    let total = number\
    \ + remaining\n    if total < need {\n        return [total, 0]\n    }\n    return\
    \ [need, total - need]\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(eat(number:\
    \ 5, need: 6, remaining: 10) == [11, 4])\nassert(eat(number: 4, need: 8, remaining:\
    \ 9) == [12, 1])\nassert(eat(number: 1, need: 10, remaining: 10) == [11, 0])\n\
    assert(eat(number: 2, need: 11, remaining: 5) == [7, 0])\nassert(eat(number: 4,\
    \ need: 5, remaining: 7) == [9, 2])\nassert(eat(number: 4, need: 5, remaining:\
    \ 1) == [5, 0])"
  status: Exception
  stderr: 'tmp7_l7zyb1/tmp7_l7zyb1.swift:49: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b3fb02e3c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b3faffdab6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b3faffda988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b3faffd97b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmp7_l7zyb1                        0x000056281db46384 <unavailable> + 4996

    5    libc.so.6                          0x00002b3fb04cf460 __libc_start_main +
    245

    6    tmp7_l7zyb1                        0x000056281db45fc9 <unavailable> + 4041

    '
  stdout: ''
  timestamp: 1660014020
- exit_code: 1
  program: "\n/// You're a hungry rabbit, and you already have eaten a certain number\
    \ of carrots,\n/// but now you need to eat more carrots to complete the day's\
    \ meals.\n/// you should return an array of [ total number of eaten carrots after\
    \ your meals,\n/// the number of carrots left after your meals ]\n/// if there\
    \ are not enough remaining carrots, you will eat all remaining carrots, but will\
    \ still be hungry.\n/// Example:\n/// >>> eat(number: 5, need: 6, remaining: 10)\n\
    /// [11, 4]\n/// >>> eat(number: 4, need: 8, remaining: 9)\n/// [12, 1]\n/// >>>\
    \ eat(number: 1, need: 10, remaining: 10)\n/// [11, 0]\n/// >>> eat(number: 2,\
    \ need: 11, remaining: 5)\n/// [7, 0]\n/// Variables:\n/// @number : integer\n\
    /// the number of carrots that you have eaten.\n/// @need : integer\n/// the number\
    \ of carrots that you need to eat.\n/// @remaining : integer\n/// the number of\
    \ remaining carrots thet exist in stock\n/// Constrain:\n/// * 0 <= number <=\
    \ 1000\n/// * 0 <= need <= 1000\n/// * 0 <= remaining <= 1000\n/// Have fun :)\n\
    func eat(number: Int, need: Int, remaining: Int) -> [Int] {\n    return [(number\
    \ + remaining).clamp(0, need), (need - number - remaining).clamp(0, remaining)]\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(eat(number: 5, need: 6, remaining: 10) == [11,\
    \ 4])\nassert(eat(number: 4, need: 8, remaining: 9) == [12, 1])\nassert(eat(number:\
    \ 1, need: 10, remaining: 10) == [11, 0])\nassert(eat(number: 2, need: 11, remaining:\
    \ 5) == [7, 0])\nassert(eat(number: 4, need: 5, remaining: 7) == [9, 2])\nassert(eat(number:\
    \ 4, need: 5, remaining: 1) == [5, 0])"
  status: SyntaxError
  stderr: "/tmp/tmpj_sebz7i.swift:29:34: error: value of type 'Int' has no member\
    \ 'clamp'\n    return [(number + remaining).clamp(0, need), (need - number - remaining).clamp(0,\
    \ remaining)]\n            ~~~~~~~~~~~~~~~~~~~~ ^~~~~\n/tmp/tmpj_sebz7i.swift:29:78:\
    \ error: value of type 'Int' has no member 'clamp'\n    return [(number + remaining).clamp(0,\
    \ need), (need - number - remaining).clamp(0, remaining)]\n                  \
    \                               ~~~~~~~~~~~~~~~~~~~~~~~~~~~ ^~~~~\n"
  stdout: ''
  timestamp: 1660014020
- exit_code: -4
  program: "\n/// You're a hungry rabbit, and you already have eaten a certain number\
    \ of carrots,\n/// but now you need to eat more carrots to complete the day's\
    \ meals.\n/// you should return an array of [ total number of eaten carrots after\
    \ your meals,\n/// the number of carrots left after your meals ]\n/// if there\
    \ are not enough remaining carrots, you will eat all remaining carrots, but will\
    \ still be hungry.\n/// Example:\n/// >>> eat(number: 5, need: 6, remaining: 10)\n\
    /// [11, 4]\n/// >>> eat(number: 4, need: 8, remaining: 9)\n/// [12, 1]\n/// >>>\
    \ eat(number: 1, need: 10, remaining: 10)\n/// [11, 0]\n/// >>> eat(number: 2,\
    \ need: 11, remaining: 5)\n/// [7, 0]\n/// Variables:\n/// @number : integer\n\
    /// the number of carrots that you have eaten.\n/// @need : integer\n/// the number\
    \ of carrots that you need to eat.\n/// @remaining : integer\n/// the number of\
    \ remaining carrots thet exist in stock\n/// Constrain:\n/// * 0 <= number <=\
    \ 1000\n/// * 0 <= need <= 1000\n/// * 0 <= remaining <= 1000\n/// Have fun :)\n\
    func eat(number: Int, need: Int, remaining: Int) -> [Int] {\n    var result =\
    \ [Int]()\n    if number >= 0 && number <= 1000 && need >= 0 && need <= 1000 &&\
    \ remaining >= 0 && remaining <= 1000 {\n        let total = number + remaining\n\
    \        if total >= need {\n            result.append(need)\n            result.append(total\
    \ - need)\n        } else {\n            result.append(total)\n            result.append(0)\n\
    \        }\n    }\n    return result\n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(eat(number: 5, need: 6, remaining: 10) == [11, 4])\nassert(eat(number:\
    \ 4, need: 8, remaining: 9) == [12, 1])\nassert(eat(number: 1, need: 10, remaining:\
    \ 10) == [11, 0])\nassert(eat(number: 2, need: 11, remaining: 5) == [7, 0])\n\
    assert(eat(number: 4, need: 5, remaining: 7) == [9, 2])\nassert(eat(number: 4,\
    \ need: 5, remaining: 1) == [5, 0])"
  status: Exception
  stderr: 'tmpvgat3pry/tmpvgat3pry.swift:56: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b8dd09f6c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b8dd06edb6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b8dd06ed988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b8dd06ec7b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpvgat3pry                        0x00005558e120a444 <unavailable> + 5188

    5    libc.so.6                          0x00002b8dd0be2460 __libc_start_main +
    245

    6    tmpvgat3pry                        0x00005558e120a089 <unavailable> + 4233

    '
  stdout: ''
  timestamp: 1660014020
- exit_code: 0
  program: "\n/// You're a hungry rabbit, and you already have eaten a certain number\
    \ of carrots,\n/// but now you need to eat more carrots to complete the day's\
    \ meals.\n/// you should return an array of [ total number of eaten carrots after\
    \ your meals,\n/// the number of carrots left after your meals ]\n/// if there\
    \ are not enough remaining carrots, you will eat all remaining carrots, but will\
    \ still be hungry.\n/// Example:\n/// >>> eat(number: 5, need: 6, remaining: 10)\n\
    /// [11, 4]\n/// >>> eat(number: 4, need: 8, remaining: 9)\n/// [12, 1]\n/// >>>\
    \ eat(number: 1, need: 10, remaining: 10)\n/// [11, 0]\n/// >>> eat(number: 2,\
    \ need: 11, remaining: 5)\n/// [7, 0]\n/// Variables:\n/// @number : integer\n\
    /// the number of carrots that you have eaten.\n/// @need : integer\n/// the number\
    \ of carrots that you need to eat.\n/// @remaining : integer\n/// the number of\
    \ remaining carrots thet exist in stock\n/// Constrain:\n/// * 0 <= number <=\
    \ 1000\n/// * 0 <= need <= 1000\n/// * 0 <= remaining <= 1000\n/// Have fun :)\n\
    func eat(number: Int, need: Int, remaining: Int) -> [Int] {\n    return [number\
    \ + min(need, remaining), max(0, remaining - need)]\n}\n\n\nfunc ==(left: [(Int,\
    \ Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n\
    \        return false\n    }\n    for (l, r) in zip(left, right) {\n        if\
    \ l != r {\n            return false\n        }\n    }\n    return true\n}\n \
    \           \nassert(eat(number: 5, need: 6, remaining: 10) == [11, 4])\nassert(eat(number:\
    \ 4, need: 8, remaining: 9) == [12, 1])\nassert(eat(number: 1, need: 10, remaining:\
    \ 10) == [11, 0])\nassert(eat(number: 2, need: 11, remaining: 5) == [7, 0])\n\
    assert(eat(number: 4, need: 5, remaining: 7) == [9, 2])\nassert(eat(number: 4,\
    \ need: 5, remaining: 1) == [5, 0])"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660013824
- exit_code: -4
  program: "\n/// You're a hungry rabbit, and you already have eaten a certain number\
    \ of carrots,\n/// but now you need to eat more carrots to complete the day's\
    \ meals.\n/// you should return an array of [ total number of eaten carrots after\
    \ your meals,\n/// the number of carrots left after your meals ]\n/// if there\
    \ are not enough remaining carrots, you will eat all remaining carrots, but will\
    \ still be hungry.\n/// Example:\n/// >>> eat(number: 5, need: 6, remaining: 10)\n\
    /// [11, 4]\n/// >>> eat(number: 4, need: 8, remaining: 9)\n/// [12, 1]\n/// >>>\
    \ eat(number: 1, need: 10, remaining: 10)\n/// [11, 0]\n/// >>> eat(number: 2,\
    \ need: 11, remaining: 5)\n/// [7, 0]\n/// Variables:\n/// @number : integer\n\
    /// the number of carrots that you have eaten.\n/// @need : integer\n/// the number\
    \ of carrots that you need to eat.\n/// @remaining : integer\n/// the number of\
    \ remaining carrots thet exist in stock\n/// Constrain:\n/// * 0 <= number <=\
    \ 1000\n/// * 0 <= need <= 1000\n/// * 0 <= remaining <= 1000\n/// Have fun :)\n\
    func eat(number: Int, need: Int, remaining: Int) -> [Int] {\n    if number + remaining\
    \ < need {\n        return [number + remaining, 0]\n    } else {\n        return\
    \ [need, remaining - (need - number)]\n    }\n}\n\n\nfunc ==(left: [(Int, Int)],\
    \ right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n       \
    \ return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r\
    \ {\n            return false\n        }\n    }\n    return true\n}\n        \
    \    \nassert(eat(number: 5, need: 6, remaining: 10) == [11, 4])\nassert(eat(number:\
    \ 4, need: 8, remaining: 9) == [12, 1])\nassert(eat(number: 1, need: 10, remaining:\
    \ 10) == [11, 0])\nassert(eat(number: 2, need: 11, remaining: 5) == [7, 0])\n\
    assert(eat(number: 4, need: 5, remaining: 7) == [9, 2])\nassert(eat(number: 4,\
    \ need: 5, remaining: 1) == [5, 0])"
  status: Exception
  stderr: 'tmp_o5qg5i7/tmp_o5qg5i7.swift:49: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002af2e0e54c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002af2e0b4bb6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002af2e0b4b988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002af2e0b4a7b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmp_o5qg5i7                        0x000055d420b62384 <unavailable> + 4996

    5    libc.so.6                          0x00002af2e1040460 __libc_start_main +
    245

    6    tmp_o5qg5i7                        0x000055d420b61fc9 <unavailable> + 4041

    '
  stdout: ''
  timestamp: 1660014020
- exit_code: 0
  program: "\n/// You're a hungry rabbit, and you already have eaten a certain number\
    \ of carrots,\n/// but now you need to eat more carrots to complete the day's\
    \ meals.\n/// you should return an array of [ total number of eaten carrots after\
    \ your meals,\n/// the number of carrots left after your meals ]\n/// if there\
    \ are not enough remaining carrots, you will eat all remaining carrots, but will\
    \ still be hungry.\n/// Example:\n/// >>> eat(number: 5, need: 6, remaining: 10)\n\
    /// [11, 4]\n/// >>> eat(number: 4, need: 8, remaining: 9)\n/// [12, 1]\n/// >>>\
    \ eat(number: 1, need: 10, remaining: 10)\n/// [11, 0]\n/// >>> eat(number: 2,\
    \ need: 11, remaining: 5)\n/// [7, 0]\n/// Variables:\n/// @number : integer\n\
    /// the number of carrots that you have eaten.\n/// @need : integer\n/// the number\
    \ of carrots that you need to eat.\n/// @remaining : integer\n/// the number of\
    \ remaining carrots thet exist in stock\n/// Constrain:\n/// * 0 <= number <=\
    \ 1000\n/// * 0 <= need <= 1000\n/// * 0 <= remaining <= 1000\n/// Have fun :)\n\
    func eat(number: Int, need: Int, remaining: Int) -> [Int] {\n    let sum = number\
    \ + min(need, remaining)\n    let result = sum >= need ? [sum, remaining - min(need,\
    \ remaining)] : [sum, 0]\n    return result\n}\n\n\nfunc ==(left: [(Int, Int)],\
    \ right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n       \
    \ return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r\
    \ {\n            return false\n        }\n    }\n    return true\n}\n        \
    \    \nassert(eat(number: 5, need: 6, remaining: 10) == [11, 4])\nassert(eat(number:\
    \ 4, need: 8, remaining: 9) == [12, 1])\nassert(eat(number: 1, need: 10, remaining:\
    \ 10) == [11, 0])\nassert(eat(number: 2, need: 11, remaining: 5) == [7, 0])\n\
    assert(eat(number: 4, need: 5, remaining: 7) == [9, 2])\nassert(eat(number: 4,\
    \ need: 5, remaining: 1) == [5, 0])"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660014020
- exit_code: -4
  program: "\n/// You're a hungry rabbit, and you already have eaten a certain number\
    \ of carrots,\n/// but now you need to eat more carrots to complete the day's\
    \ meals.\n/// you should return an array of [ total number of eaten carrots after\
    \ your meals,\n/// the number of carrots left after your meals ]\n/// if there\
    \ are not enough remaining carrots, you will eat all remaining carrots, but will\
    \ still be hungry.\n/// Example:\n/// >>> eat(number: 5, need: 6, remaining: 10)\n\
    /// [11, 4]\n/// >>> eat(number: 4, need: 8, remaining: 9)\n/// [12, 1]\n/// >>>\
    \ eat(number: 1, need: 10, remaining: 10)\n/// [11, 0]\n/// >>> eat(number: 2,\
    \ need: 11, remaining: 5)\n/// [7, 0]\n/// Variables:\n/// @number : integer\n\
    /// the number of carrots that you have eaten.\n/// @need : integer\n/// the number\
    \ of carrots that you need to eat.\n/// @remaining : integer\n/// the number of\
    \ remaining carrots thet exist in stock\n/// Constrain:\n/// * 0 <= number <=\
    \ 1000\n/// * 0 <= need <= 1000\n/// * 0 <= remaining <= 1000\n/// Have fun :)\n\
    func eat(number: Int, need: Int, remaining: Int) -> [Int] {\n    // Your code\
    \ here\n    let result = number + remaining\n    let list = [result, result-need]\n\
    \    if result < need {\n        return [number+remaining, 0]\n    }\n    return\
    \ list\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n  \
    \  if left.count != right.count {\n        return false\n    }\n    for (l, r)\
    \ in zip(left, right) {\n        if l != r {\n            return false\n     \
    \   }\n    }\n    return true\n}\n            \nassert(eat(number: 5, need: 6,\
    \ remaining: 10) == [11, 4])\nassert(eat(number: 4, need: 8, remaining: 9) ==\
    \ [12, 1])\nassert(eat(number: 1, need: 10, remaining: 10) == [11, 0])\nassert(eat(number:\
    \ 2, need: 11, remaining: 5) == [7, 0])\nassert(eat(number: 4, need: 5, remaining:\
    \ 7) == [9, 2])\nassert(eat(number: 4, need: 5, remaining: 1) == [5, 0])"
  status: Exception
  stderr: 'tmpirebspad/tmpirebspad.swift:51: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b20efc78c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b20ef96fb6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b20ef96f988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b20ef96e7b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpirebspad                        0x000055ecb6493384 <unavailable> + 4996

    5    libc.so.6                          0x00002b20efe64460 __libc_start_main +
    245

    6    tmpirebspad                        0x000055ecb6492fc9 <unavailable> + 4041

    '
  stdout: ''
  timestamp: 1660014020
- exit_code: 0
  program: "\n/// You're a hungry rabbit, and you already have eaten a certain number\
    \ of carrots,\n/// but now you need to eat more carrots to complete the day's\
    \ meals.\n/// you should return an array of [ total number of eaten carrots after\
    \ your meals,\n/// the number of carrots left after your meals ]\n/// if there\
    \ are not enough remaining carrots, you will eat all remaining carrots, but will\
    \ still be hungry.\n/// Example:\n/// >>> eat(number: 5, need: 6, remaining: 10)\n\
    /// [11, 4]\n/// >>> eat(number: 4, need: 8, remaining: 9)\n/// [12, 1]\n/// >>>\
    \ eat(number: 1, need: 10, remaining: 10)\n/// [11, 0]\n/// >>> eat(number: 2,\
    \ need: 11, remaining: 5)\n/// [7, 0]\n/// Variables:\n/// @number : integer\n\
    /// the number of carrots that you have eaten.\n/// @need : integer\n/// the number\
    \ of carrots that you need to eat.\n/// @remaining : integer\n/// the number of\
    \ remaining carrots thet exist in stock\n/// Constrain:\n/// * 0 <= number <=\
    \ 1000\n/// * 0 <= need <= 1000\n/// * 0 <= remaining <= 1000\n/// Have fun :)\n\
    func eat(number: Int, need: Int, remaining: Int) -> [Int] {\n  var eaten = number\
    \ + min(need, remaining)\n  var remaining = remaining - min(need, remaining)\n\
    \  return [eaten, remaining]\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int,\
    \ Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n\
    \    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n          \
    \  return false\n        }\n    }\n    return true\n}\n            \nassert(eat(number:\
    \ 5, need: 6, remaining: 10) == [11, 4])\nassert(eat(number: 4, need: 8, remaining:\
    \ 9) == [12, 1])\nassert(eat(number: 1, need: 10, remaining: 10) == [11, 0])\n\
    assert(eat(number: 2, need: 11, remaining: 5) == [7, 0])\nassert(eat(number: 4,\
    \ need: 5, remaining: 7) == [9, 2])\nassert(eat(number: 4, need: 5, remaining:\
    \ 1) == [5, 0])"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660014020
- exit_code: -4
  program: "\n/// You're a hungry rabbit, and you already have eaten a certain number\
    \ of carrots,\n/// but now you need to eat more carrots to complete the day's\
    \ meals.\n/// you should return an array of [ total number of eaten carrots after\
    \ your meals,\n/// the number of carrots left after your meals ]\n/// if there\
    \ are not enough remaining carrots, you will eat all remaining carrots, but will\
    \ still be hungry.\n/// Example:\n/// >>> eat(number: 5, need: 6, remaining: 10)\n\
    /// [11, 4]\n/// >>> eat(number: 4, need: 8, remaining: 9)\n/// [12, 1]\n/// >>>\
    \ eat(number: 1, need: 10, remaining: 10)\n/// [11, 0]\n/// >>> eat(number: 2,\
    \ need: 11, remaining: 5)\n/// [7, 0]\n/// Variables:\n/// @number : integer\n\
    /// the number of carrots that you have eaten.\n/// @need : integer\n/// the number\
    \ of carrots that you need to eat.\n/// @remaining : integer\n/// the number of\
    \ remaining carrots thet exist in stock\n/// Constrain:\n/// * 0 <= number <=\
    \ 1000\n/// * 0 <= need <= 1000\n/// * 0 <= remaining <= 1000\n/// Have fun :)\n\
    func eat(number: Int, need: Int, remaining: Int) -> [Int] {\n  let total = number\
    \ + need\n  let left = total - remaining\n  return left > 0 ? [remaining, 0] :\
    \ [total, remaining - total]\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int,\
    \ Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n\
    \    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n          \
    \  return false\n        }\n    }\n    return true\n}\n            \nassert(eat(number:\
    \ 5, need: 6, remaining: 10) == [11, 4])\nassert(eat(number: 4, need: 8, remaining:\
    \ 9) == [12, 1])\nassert(eat(number: 1, need: 10, remaining: 10) == [11, 0])\n\
    assert(eat(number: 2, need: 11, remaining: 5) == [7, 0])\nassert(eat(number: 4,\
    \ need: 5, remaining: 7) == [9, 2])\nassert(eat(number: 4, need: 5, remaining:\
    \ 1) == [5, 0])"
  status: Exception
  stderr: 'tmpd4v36wyp/tmpd4v36wyp.swift:47: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002abba860bc80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002abba8302b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002abba8302988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002abba83017b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpd4v36wyp                        0x000055e176422384 <unavailable> + 4996

    5    libc.so.6                          0x00002abba87f7460 __libc_start_main +
    245

    6    tmpd4v36wyp                        0x000055e176421fc9 <unavailable> + 4041

    '
  stdout: ''
  timestamp: 1660014020
- exit_code: 0
  program: "\n/// You're a hungry rabbit, and you already have eaten a certain number\
    \ of carrots,\n/// but now you need to eat more carrots to complete the day's\
    \ meals.\n/// you should return an array of [ total number of eaten carrots after\
    \ your meals,\n/// the number of carrots left after your meals ]\n/// if there\
    \ are not enough remaining carrots, you will eat all remaining carrots, but will\
    \ still be hungry.\n/// Example:\n/// >>> eat(number: 5, need: 6, remaining: 10)\n\
    /// [11, 4]\n/// >>> eat(number: 4, need: 8, remaining: 9)\n/// [12, 1]\n/// >>>\
    \ eat(number: 1, need: 10, remaining: 10)\n/// [11, 0]\n/// >>> eat(number: 2,\
    \ need: 11, remaining: 5)\n/// [7, 0]\n/// Variables:\n/// @number : integer\n\
    /// the number of carrots that you have eaten.\n/// @need : integer\n/// the number\
    \ of carrots that you need to eat.\n/// @remaining : integer\n/// the number of\
    \ remaining carrots thet exist in stock\n/// Constrain:\n/// * 0 <= number <=\
    \ 1000\n/// * 0 <= need <= 1000\n/// * 0 <= remaining <= 1000\n/// Have fun :)\n\
    func eat(number: Int, need: Int, remaining: Int) -> [Int] {\n    var res: [Int]\
    \ = []\n    if remaining >= need {\n        res.append(number + need)\n      \
    \  res.append(remaining - need)\n    } else {\n        res.append(number + remaining)\n\
    \        res.append(0)\n    }\n    return res\n}\n\n\nfunc ==(left: [(Int, Int)],\
    \ right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n       \
    \ return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r\
    \ {\n            return false\n        }\n    }\n    return true\n}\n        \
    \    \nassert(eat(number: 5, need: 6, remaining: 10) == [11, 4])\nassert(eat(number:\
    \ 4, need: 8, remaining: 9) == [12, 1])\nassert(eat(number: 1, need: 10, remaining:\
    \ 10) == [11, 0])\nassert(eat(number: 2, need: 11, remaining: 5) == [7, 0])\n\
    assert(eat(number: 4, need: 5, remaining: 7) == [9, 2])\nassert(eat(number: 4,\
    \ need: 5, remaining: 1) == [5, 0])"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660014020
- exit_code: -4
  program: "\n/// You're a hungry rabbit, and you already have eaten a certain number\
    \ of carrots,\n/// but now you need to eat more carrots to complete the day's\
    \ meals.\n/// you should return an array of [ total number of eaten carrots after\
    \ your meals,\n/// the number of carrots left after your meals ]\n/// if there\
    \ are not enough remaining carrots, you will eat all remaining carrots, but will\
    \ still be hungry.\n/// Example:\n/// >>> eat(number: 5, need: 6, remaining: 10)\n\
    /// [11, 4]\n/// >>> eat(number: 4, need: 8, remaining: 9)\n/// [12, 1]\n/// >>>\
    \ eat(number: 1, need: 10, remaining: 10)\n/// [11, 0]\n/// >>> eat(number: 2,\
    \ need: 11, remaining: 5)\n/// [7, 0]\n/// Variables:\n/// @number : integer\n\
    /// the number of carrots that you have eaten.\n/// @need : integer\n/// the number\
    \ of carrots that you need to eat.\n/// @remaining : integer\n/// the number of\
    \ remaining carrots thet exist in stock\n/// Constrain:\n/// * 0 <= number <=\
    \ 1000\n/// * 0 <= need <= 1000\n/// * 0 <= remaining <= 1000\n/// Have fun :)\n\
    func eat(number: Int, need: Int, remaining: Int) -> [Int] {\n    let carrotsToEat\
    \ = need - number\n    let actualCarrotsLeft = remaining - carrotsToEat\n    return\
    \ actualCarrotsLeft < 0 ? [remaining + number, 0] : [carrotsToEat + number, actualCarrotsLeft]\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(eat(number: 5, need: 6, remaining: 10) == [11,\
    \ 4])\nassert(eat(number: 4, need: 8, remaining: 9) == [12, 1])\nassert(eat(number:\
    \ 1, need: 10, remaining: 10) == [11, 0])\nassert(eat(number: 2, need: 11, remaining:\
    \ 5) == [7, 0])\nassert(eat(number: 4, need: 5, remaining: 7) == [9, 2])\nassert(eat(number:\
    \ 4, need: 5, remaining: 1) == [5, 0])"
  status: Exception
  stderr: 'tmp3b5t218z/tmp3b5t218z.swift:47: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002abd6a11ac80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002abd69e11b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002abd69e11988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002abd69e107b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmp3b5t218z                        0x000055dd073c0384 <unavailable> + 4996

    5    libc.so.6                          0x00002abd6a306460 __libc_start_main +
    245

    6    tmp3b5t218z                        0x000055dd073bffc9 <unavailable> + 4041

    '
  stdout: ''
  timestamp: 1660014020
- exit_code: -4
  program: "\n/// You're a hungry rabbit, and you already have eaten a certain number\
    \ of carrots,\n/// but now you need to eat more carrots to complete the day's\
    \ meals.\n/// you should return an array of [ total number of eaten carrots after\
    \ your meals,\n/// the number of carrots left after your meals ]\n/// if there\
    \ are not enough remaining carrots, you will eat all remaining carrots, but will\
    \ still be hungry.\n/// Example:\n/// >>> eat(number: 5, need: 6, remaining: 10)\n\
    /// [11, 4]\n/// >>> eat(number: 4, need: 8, remaining: 9)\n/// [12, 1]\n/// >>>\
    \ eat(number: 1, need: 10, remaining: 10)\n/// [11, 0]\n/// >>> eat(number: 2,\
    \ need: 11, remaining: 5)\n/// [7, 0]\n/// Variables:\n/// @number : integer\n\
    /// the number of carrots that you have eaten.\n/// @need : integer\n/// the number\
    \ of carrots that you need to eat.\n/// @remaining : integer\n/// the number of\
    \ remaining carrots thet exist in stock\n/// Constrain:\n/// * 0 <= number <=\
    \ 1000\n/// * 0 <= need <= 1000\n/// * 0 <= remaining <= 1000\n/// Have fun :)\n\
    func eat(number: Int, need: Int, remaining: Int) -> [Int] {\n    return [remaining,\
    \ number + remaining]\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(eat(number:\
    \ 5, need: 6, remaining: 10) == [11, 4])\nassert(eat(number: 4, need: 8, remaining:\
    \ 9) == [12, 1])\nassert(eat(number: 1, need: 10, remaining: 10) == [11, 0])\n\
    assert(eat(number: 2, need: 11, remaining: 5) == [7, 0])\nassert(eat(number: 4,\
    \ need: 5, remaining: 7) == [9, 2])\nassert(eat(number: 4, need: 5, remaining:\
    \ 1) == [5, 0])"
  status: Exception
  stderr: 'tmpoptk4jvt/tmpoptk4jvt.swift:45: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002ac7de288c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002ac7ddf7fb6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002ac7ddf7f988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002ac7ddf7e7b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpoptk4jvt                        0x0000557966c52384 <unavailable> + 4996

    5    libc.so.6                          0x00002ac7de474460 __libc_start_main +
    245

    6    tmpoptk4jvt                        0x0000557966c51fc9 <unavailable> + 4041

    '
  stdout: ''
  timestamp: 1660014020
- exit_code: -4
  program: "\n/// You're a hungry rabbit, and you already have eaten a certain number\
    \ of carrots,\n/// but now you need to eat more carrots to complete the day's\
    \ meals.\n/// you should return an array of [ total number of eaten carrots after\
    \ your meals,\n/// the number of carrots left after your meals ]\n/// if there\
    \ are not enough remaining carrots, you will eat all remaining carrots, but will\
    \ still be hungry.\n/// Example:\n/// >>> eat(number: 5, need: 6, remaining: 10)\n\
    /// [11, 4]\n/// >>> eat(number: 4, need: 8, remaining: 9)\n/// [12, 1]\n/// >>>\
    \ eat(number: 1, need: 10, remaining: 10)\n/// [11, 0]\n/// >>> eat(number: 2,\
    \ need: 11, remaining: 5)\n/// [7, 0]\n/// Variables:\n/// @number : integer\n\
    /// the number of carrots that you have eaten.\n/// @need : integer\n/// the number\
    \ of carrots that you need to eat.\n/// @remaining : integer\n/// the number of\
    \ remaining carrots thet exist in stock\n/// Constrain:\n/// * 0 <= number <=\
    \ 1000\n/// * 0 <= need <= 1000\n/// * 0 <= remaining <= 1000\n/// Have fun :)\n\
    func eat(number: Int, need: Int, remaining: Int) -> [Int] {\n    return []\n}\n\
    \n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(eat(number: 5, need: 6, remaining: 10) == [11,\
    \ 4])\nassert(eat(number: 4, need: 8, remaining: 9) == [12, 1])\nassert(eat(number:\
    \ 1, need: 10, remaining: 10) == [11, 0])\nassert(eat(number: 2, need: 11, remaining:\
    \ 5) == [7, 0])\nassert(eat(number: 4, need: 5, remaining: 7) == [9, 2])\nassert(eat(number:\
    \ 4, need: 5, remaining: 1) == [5, 0])"
  status: Exception
  stderr: 'tmp5d0or02d/tmp5d0or02d.swift:45: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b0276059c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b0275d50b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b0275d50988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b0275d4f7b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmp5d0or02d                        0x000056073e3c5384 <unavailable> + 4996

    5    libc.so.6                          0x00002b0276245460 __libc_start_main +
    245

    6    tmp5d0or02d                        0x000056073e3c4fc9 <unavailable> + 4041

    '
  stdout: ''
  timestamp: 1660014019
- exit_code: -4
  program: "\n/// You're a hungry rabbit, and you already have eaten a certain number\
    \ of carrots,\n/// but now you need to eat more carrots to complete the day's\
    \ meals.\n/// you should return an array of [ total number of eaten carrots after\
    \ your meals,\n/// the number of carrots left after your meals ]\n/// if there\
    \ are not enough remaining carrots, you will eat all remaining carrots, but will\
    \ still be hungry.\n/// Example:\n/// >>> eat(number: 5, need: 6, remaining: 10)\n\
    /// [11, 4]\n/// >>> eat(number: 4, need: 8, remaining: 9)\n/// [12, 1]\n/// >>>\
    \ eat(number: 1, need: 10, remaining: 10)\n/// [11, 0]\n/// >>> eat(number: 2,\
    \ need: 11, remaining: 5)\n/// [7, 0]\n/// Variables:\n/// @number : integer\n\
    /// the number of carrots that you have eaten.\n/// @need : integer\n/// the number\
    \ of carrots that you need to eat.\n/// @remaining : integer\n/// the number of\
    \ remaining carrots thet exist in stock\n/// Constrain:\n/// * 0 <= number <=\
    \ 1000\n/// * 0 <= need <= 1000\n/// * 0 <= remaining <= 1000\n/// Have fun :)\n\
    func eat(number: Int, need: Int, remaining: Int) -> [Int] {\n    return [ number\
    \ + min(remaining, need - number), max(0, remaining - need + number) ]\n}\n\n\n\
    func ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(eat(number: 5, need: 6, remaining: 10) == [11,\
    \ 4])\nassert(eat(number: 4, need: 8, remaining: 9) == [12, 1])\nassert(eat(number:\
    \ 1, need: 10, remaining: 10) == [11, 0])\nassert(eat(number: 2, need: 11, remaining:\
    \ 5) == [7, 0])\nassert(eat(number: 4, need: 5, remaining: 7) == [9, 2])\nassert(eat(number:\
    \ 4, need: 5, remaining: 1) == [5, 0])"
  status: Exception
  stderr: 'tmp4y87bc5b/tmp4y87bc5b.swift:45: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002ac8dc25bc80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002ac8dbf52b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002ac8dbf52988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002ac8dbf517b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmp4y87bc5b                        0x000055795881f474 <unavailable> + 5236

    5    libc.so.6                          0x00002ac8dc447460 __libc_start_main +
    245

    6    tmp4y87bc5b                        0x000055795881f0b9 <unavailable> + 4281

    '
  stdout: ''
  timestamp: 1660014020
- exit_code: -4
  program: "\n/// You're a hungry rabbit, and you already have eaten a certain number\
    \ of carrots,\n/// but now you need to eat more carrots to complete the day's\
    \ meals.\n/// you should return an array of [ total number of eaten carrots after\
    \ your meals,\n/// the number of carrots left after your meals ]\n/// if there\
    \ are not enough remaining carrots, you will eat all remaining carrots, but will\
    \ still be hungry.\n/// Example:\n/// >>> eat(number: 5, need: 6, remaining: 10)\n\
    /// [11, 4]\n/// >>> eat(number: 4, need: 8, remaining: 9)\n/// [12, 1]\n/// >>>\
    \ eat(number: 1, need: 10, remaining: 10)\n/// [11, 0]\n/// >>> eat(number: 2,\
    \ need: 11, remaining: 5)\n/// [7, 0]\n/// Variables:\n/// @number : integer\n\
    /// the number of carrots that you have eaten.\n/// @need : integer\n/// the number\
    \ of carrots that you need to eat.\n/// @remaining : integer\n/// the number of\
    \ remaining carrots thet exist in stock\n/// Constrain:\n/// * 0 <= number <=\
    \ 1000\n/// * 0 <= need <= 1000\n/// * 0 <= remaining <= 1000\n/// Have fun :)\n\
    func eat(number: Int, need: Int, remaining: Int) -> [Int] {\n    if number < 0\
    \ || need < 0 || remaining < 0 {\n        return []\n    }\n    var total = number\n\
    \    let carrots = (need - number)\n    total += (carrots <= remaining) ? carrots\
    \ : remaining\n    let left = (carrots <= remaining) ? (remaining - carrots) :\
    \ 0\n    return [total, left]\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int,\
    \ Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n\
    \    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n          \
    \  return false\n        }\n    }\n    return true\n}\n            \nassert(eat(number:\
    \ 5, need: 6, remaining: 10) == [11, 4])\nassert(eat(number: 4, need: 8, remaining:\
    \ 9) == [12, 1])\nassert(eat(number: 1, need: 10, remaining: 10) == [11, 0])\n\
    assert(eat(number: 2, need: 11, remaining: 5) == [7, 0])\nassert(eat(number: 4,\
    \ need: 5, remaining: 7) == [9, 2])\nassert(eat(number: 4, need: 5, remaining:\
    \ 1) == [5, 0])"
  status: Exception
  stderr: 'tmpn5kgg5j_/tmpn5kgg5j_.swift:52: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b904dc58c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b904d94fb6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b904d94f988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b904d94e7b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpn5kgg5j_                        0x000055bd4c094384 <unavailable> + 4996

    5    libc.so.6                          0x00002b904de44460 __libc_start_main +
    245

    6    tmpn5kgg5j_                        0x000055bd4c093fc9 <unavailable> + 4041

    '
  stdout: ''
  timestamp: 1660014020
- exit_code: -4
  program: "\n/// You're a hungry rabbit, and you already have eaten a certain number\
    \ of carrots,\n/// but now you need to eat more carrots to complete the day's\
    \ meals.\n/// you should return an array of [ total number of eaten carrots after\
    \ your meals,\n/// the number of carrots left after your meals ]\n/// if there\
    \ are not enough remaining carrots, you will eat all remaining carrots, but will\
    \ still be hungry.\n/// Example:\n/// >>> eat(number: 5, need: 6, remaining: 10)\n\
    /// [11, 4]\n/// >>> eat(number: 4, need: 8, remaining: 9)\n/// [12, 1]\n/// >>>\
    \ eat(number: 1, need: 10, remaining: 10)\n/// [11, 0]\n/// >>> eat(number: 2,\
    \ need: 11, remaining: 5)\n/// [7, 0]\n/// Variables:\n/// @number : integer\n\
    /// the number of carrots that you have eaten.\n/// @need : integer\n/// the number\
    \ of carrots that you need to eat.\n/// @remaining : integer\n/// the number of\
    \ remaining carrots thet exist in stock\n/// Constrain:\n/// * 0 <= number <=\
    \ 1000\n/// * 0 <= need <= 1000\n/// * 0 <= remaining <= 1000\n/// Have fun :)\n\
    func eat(number: Int, need: Int, remaining: Int) -> [Int] {\n    var total = number\n\
    \    var totalCarrots = remaining\n    for _ in number..<need {\n        if totalCarrots\
    \ > 0 {\n            total += 1\n            totalCarrots -= 1\n        }\n  \
    \  }\n    return [total, totalCarrots]\n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(eat(number: 5, need: 6, remaining: 10) == [11, 4])\nassert(eat(number:\
    \ 4, need: 8, remaining: 9) == [12, 1])\nassert(eat(number: 1, need: 10, remaining:\
    \ 10) == [11, 0])\nassert(eat(number: 2, need: 11, remaining: 5) == [7, 0])\n\
    assert(eat(number: 4, need: 5, remaining: 7) == [9, 2])\nassert(eat(number: 4,\
    \ need: 5, remaining: 1) == [5, 0])"
  status: Exception
  stderr: 'tmp9679ilhc/tmp9679ilhc.swift:53: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002ab35a5dec80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002ab35a2d5b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002ab35a2d5988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002ab35a2d47b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmp9679ilhc                        0x0000557612942514 <unavailable> + 5396

    5    libc.so.6                          0x00002ab35a7ca460 __libc_start_main +
    245

    6    tmp9679ilhc                        0x0000557612942159 <unavailable> + 4441

    '
  stdout: ''
  timestamp: 1660014020
- exit_code: -4
  program: "\n/// You're a hungry rabbit, and you already have eaten a certain number\
    \ of carrots,\n/// but now you need to eat more carrots to complete the day's\
    \ meals.\n/// you should return an array of [ total number of eaten carrots after\
    \ your meals,\n/// the number of carrots left after your meals ]\n/// if there\
    \ are not enough remaining carrots, you will eat all remaining carrots, but will\
    \ still be hungry.\n/// Example:\n/// >>> eat(number: 5, need: 6, remaining: 10)\n\
    /// [11, 4]\n/// >>> eat(number: 4, need: 8, remaining: 9)\n/// [12, 1]\n/// >>>\
    \ eat(number: 1, need: 10, remaining: 10)\n/// [11, 0]\n/// >>> eat(number: 2,\
    \ need: 11, remaining: 5)\n/// [7, 0]\n/// Variables:\n/// @number : integer\n\
    /// the number of carrots that you have eaten.\n/// @need : integer\n/// the number\
    \ of carrots that you need to eat.\n/// @remaining : integer\n/// the number of\
    \ remaining carrots thet exist in stock\n/// Constrain:\n/// * 0 <= number <=\
    \ 1000\n/// * 0 <= need <= 1000\n/// * 0 <= remaining <= 1000\n/// Have fun :)\n\
    func eat(number: Int, need: Int, remaining: Int) -> [Int] {\n    let total = number\
    \ + remaining\n    let eat = total >= need ? need : total\n    return [eat, total\
    \ - eat]\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n\
    \    if left.count != right.count {\n        return false\n    }\n    for (l,\
    \ r) in zip(left, right) {\n        if l != r {\n            return false\n  \
    \      }\n    }\n    return true\n}\n            \nassert(eat(number: 5, need:\
    \ 6, remaining: 10) == [11, 4])\nassert(eat(number: 4, need: 8, remaining: 9)\
    \ == [12, 1])\nassert(eat(number: 1, need: 10, remaining: 10) == [11, 0])\nassert(eat(number:\
    \ 2, need: 11, remaining: 5) == [7, 0])\nassert(eat(number: 4, need: 5, remaining:\
    \ 7) == [9, 2])\nassert(eat(number: 4, need: 5, remaining: 1) == [5, 0])"
  status: Exception
  stderr: 'tmpov8puhi9/tmpov8puhi9.swift:47: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b886c675c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b886c36cb6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b886c36c988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b886c36b7b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpov8puhi9                        0x000055764678e384 <unavailable> + 4996

    5    libc.so.6                          0x00002b886c861460 __libc_start_main +
    245

    6    tmpov8puhi9                        0x000055764678dfc9 <unavailable> + 4041

    '
  stdout: ''
  timestamp: 1660014020
- exit_code: -4
  program: "\n/// You're a hungry rabbit, and you already have eaten a certain number\
    \ of carrots,\n/// but now you need to eat more carrots to complete the day's\
    \ meals.\n/// you should return an array of [ total number of eaten carrots after\
    \ your meals,\n/// the number of carrots left after your meals ]\n/// if there\
    \ are not enough remaining carrots, you will eat all remaining carrots, but will\
    \ still be hungry.\n/// Example:\n/// >>> eat(number: 5, need: 6, remaining: 10)\n\
    /// [11, 4]\n/// >>> eat(number: 4, need: 8, remaining: 9)\n/// [12, 1]\n/// >>>\
    \ eat(number: 1, need: 10, remaining: 10)\n/// [11, 0]\n/// >>> eat(number: 2,\
    \ need: 11, remaining: 5)\n/// [7, 0]\n/// Variables:\n/// @number : integer\n\
    /// the number of carrots that you have eaten.\n/// @need : integer\n/// the number\
    \ of carrots that you need to eat.\n/// @remaining : integer\n/// the number of\
    \ remaining carrots thet exist in stock\n/// Constrain:\n/// * 0 <= number <=\
    \ 1000\n/// * 0 <= need <= 1000\n/// * 0 <= remaining <= 1000\n/// Have fun :)\n\
    func eat(number: Int, need: Int, remaining: Int) -> [Int] {\n    if number > 1000\
    \ || need > 1000 || remaining > 1000 {\n        return []\n    }\n    if number\
    \ < 0 || need < 0 || remaining < 0 {\n        return []\n    }\n    let sumNeed\
    \ = number + need\n    let totalRemaining = sumNeed - remaining\n    if totalRemaining\
    \ > remaining {\n        return [remaining, 0]\n    }\n    return [sumNeed, remaining\
    \ - totalRemaining]\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) ->\
    \ Bool {\n    if left.count != right.count {\n        return false\n    }\n  \
    \  for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(eat(number: 5, need:\
    \ 6, remaining: 10) == [11, 4])\nassert(eat(number: 4, need: 8, remaining: 9)\
    \ == [12, 1])\nassert(eat(number: 1, need: 10, remaining: 10) == [11, 0])\nassert(eat(number:\
    \ 2, need: 11, remaining: 5) == [7, 0])\nassert(eat(number: 4, need: 5, remaining:\
    \ 7) == [9, 2])\nassert(eat(number: 4, need: 5, remaining: 1) == [5, 0])"
  status: Exception
  stderr: 'tmp0l5tir3d/tmp0l5tir3d.swift:56: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b4c28b67c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b4c2885eb6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b4c2885e988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b4c2885d7b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmp0l5tir3d                        0x00005605810b2384 <unavailable> + 4996

    5    libc.so.6                          0x00002b4c28d53460 __libc_start_main +
    245

    6    tmp0l5tir3d                        0x00005605810b1fc9 <unavailable> + 4041

    '
  stdout: ''
  timestamp: 1660014020
- exit_code: -4
  program: "\n/// You're a hungry rabbit, and you already have eaten a certain number\
    \ of carrots,\n/// but now you need to eat more carrots to complete the day's\
    \ meals.\n/// you should return an array of [ total number of eaten carrots after\
    \ your meals,\n/// the number of carrots left after your meals ]\n/// if there\
    \ are not enough remaining carrots, you will eat all remaining carrots, but will\
    \ still be hungry.\n/// Example:\n/// >>> eat(number: 5, need: 6, remaining: 10)\n\
    /// [11, 4]\n/// >>> eat(number: 4, need: 8, remaining: 9)\n/// [12, 1]\n/// >>>\
    \ eat(number: 1, need: 10, remaining: 10)\n/// [11, 0]\n/// >>> eat(number: 2,\
    \ need: 11, remaining: 5)\n/// [7, 0]\n/// Variables:\n/// @number : integer\n\
    /// the number of carrots that you have eaten.\n/// @need : integer\n/// the number\
    \ of carrots that you need to eat.\n/// @remaining : integer\n/// the number of\
    \ remaining carrots thet exist in stock\n/// Constrain:\n/// * 0 <= number <=\
    \ 1000\n/// * 0 <= need <= 1000\n/// * 0 <= remaining <= 1000\n/// Have fun :)\n\
    func eat(number: Int, need: Int, remaining: Int) -> [Int] {\n    return []\n}\n\
    \n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(eat(number: 5, need: 6, remaining: 10) == [11,\
    \ 4])\nassert(eat(number: 4, need: 8, remaining: 9) == [12, 1])\nassert(eat(number:\
    \ 1, need: 10, remaining: 10) == [11, 0])\nassert(eat(number: 2, need: 11, remaining:\
    \ 5) == [7, 0])\nassert(eat(number: 4, need: 5, remaining: 7) == [9, 2])\nassert(eat(number:\
    \ 4, need: 5, remaining: 1) == [5, 0])"
  status: Exception
  stderr: 'tmp5d0or02d/tmp5d0or02d.swift:45: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b0276059c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b0275d50b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b0275d50988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b0275d4f7b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmp5d0or02d                        0x000056073e3c5384 <unavailable> + 4996

    5    libc.so.6                          0x00002b0276245460 __libc_start_main +
    245

    6    tmp5d0or02d                        0x000056073e3c4fc9 <unavailable> + 4041

    '
  stdout: ''
  timestamp: 1660014019
- exit_code: 0
  program: "\n/// You're a hungry rabbit, and you already have eaten a certain number\
    \ of carrots,\n/// but now you need to eat more carrots to complete the day's\
    \ meals.\n/// you should return an array of [ total number of eaten carrots after\
    \ your meals,\n/// the number of carrots left after your meals ]\n/// if there\
    \ are not enough remaining carrots, you will eat all remaining carrots, but will\
    \ still be hungry.\n/// Example:\n/// >>> eat(number: 5, need: 6, remaining: 10)\n\
    /// [11, 4]\n/// >>> eat(number: 4, need: 8, remaining: 9)\n/// [12, 1]\n/// >>>\
    \ eat(number: 1, need: 10, remaining: 10)\n/// [11, 0]\n/// >>> eat(number: 2,\
    \ need: 11, remaining: 5)\n/// [7, 0]\n/// Variables:\n/// @number : integer\n\
    /// the number of carrots that you have eaten.\n/// @need : integer\n/// the number\
    \ of carrots that you need to eat.\n/// @remaining : integer\n/// the number of\
    \ remaining carrots thet exist in stock\n/// Constrain:\n/// * 0 <= number <=\
    \ 1000\n/// * 0 <= need <= 1000\n/// * 0 <= remaining <= 1000\n/// Have fun :)\n\
    func eat(number: Int, need: Int, remaining: Int) -> [Int] {\n    return [remaining\
    \ < need ? number + remaining : number + need,\n            remaining < need ?\
    \ 0 : remaining - need]\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(eat(number:\
    \ 5, need: 6, remaining: 10) == [11, 4])\nassert(eat(number: 4, need: 8, remaining:\
    \ 9) == [12, 1])\nassert(eat(number: 1, need: 10, remaining: 10) == [11, 0])\n\
    assert(eat(number: 2, need: 11, remaining: 5) == [7, 0])\nassert(eat(number: 4,\
    \ need: 5, remaining: 7) == [9, 2])\nassert(eat(number: 4, need: 5, remaining:\
    \ 1) == [5, 0])"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660014020
- exit_code: -4
  program: "\n/// You're a hungry rabbit, and you already have eaten a certain number\
    \ of carrots,\n/// but now you need to eat more carrots to complete the day's\
    \ meals.\n/// you should return an array of [ total number of eaten carrots after\
    \ your meals,\n/// the number of carrots left after your meals ]\n/// if there\
    \ are not enough remaining carrots, you will eat all remaining carrots, but will\
    \ still be hungry.\n/// Example:\n/// >>> eat(number: 5, need: 6, remaining: 10)\n\
    /// [11, 4]\n/// >>> eat(number: 4, need: 8, remaining: 9)\n/// [12, 1]\n/// >>>\
    \ eat(number: 1, need: 10, remaining: 10)\n/// [11, 0]\n/// >>> eat(number: 2,\
    \ need: 11, remaining: 5)\n/// [7, 0]\n/// Variables:\n/// @number : integer\n\
    /// the number of carrots that you have eaten.\n/// @need : integer\n/// the number\
    \ of carrots that you need to eat.\n/// @remaining : integer\n/// the number of\
    \ remaining carrots thet exist in stock\n/// Constrain:\n/// * 0 <= number <=\
    \ 1000\n/// * 0 <= need <= 1000\n/// * 0 <= remaining <= 1000\n/// Have fun :)\n\
    func eat(number: Int, need: Int, remaining: Int) -> [Int] {\n    let total = number\
    \ + remaining\n    if total >= need {\n        return [need, total - need]\n \
    \   } else {\n        return [total, 0]\n    }\n}\n\n\nfunc ==(left: [(Int, Int)],\
    \ right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n       \
    \ return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r\
    \ {\n            return false\n        }\n    }\n    return true\n}\n        \
    \    \nassert(eat(number: 5, need: 6, remaining: 10) == [11, 4])\nassert(eat(number:\
    \ 4, need: 8, remaining: 9) == [12, 1])\nassert(eat(number: 1, need: 10, remaining:\
    \ 10) == [11, 0])\nassert(eat(number: 2, need: 11, remaining: 5) == [7, 0])\n\
    assert(eat(number: 4, need: 5, remaining: 7) == [9, 2])\nassert(eat(number: 4,\
    \ need: 5, remaining: 1) == [5, 0])"
  status: Exception
  stderr: 'tmp92cxyi7a/tmp92cxyi7a.swift:50: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b58084b1c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b58081a8b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b58081a8988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b58081a77b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmp92cxyi7a                        0x000055903e706384 <unavailable> + 4996

    5    libc.so.6                          0x00002b580869d460 __libc_start_main +
    245

    6    tmp92cxyi7a                        0x000055903e705fc9 <unavailable> + 4041

    '
  stdout: ''
  timestamp: 1660013824
- exit_code: -4
  program: "\n/// You're a hungry rabbit, and you already have eaten a certain number\
    \ of carrots,\n/// but now you need to eat more carrots to complete the day's\
    \ meals.\n/// you should return an array of [ total number of eaten carrots after\
    \ your meals,\n/// the number of carrots left after your meals ]\n/// if there\
    \ are not enough remaining carrots, you will eat all remaining carrots, but will\
    \ still be hungry.\n/// Example:\n/// >>> eat(number: 5, need: 6, remaining: 10)\n\
    /// [11, 4]\n/// >>> eat(number: 4, need: 8, remaining: 9)\n/// [12, 1]\n/// >>>\
    \ eat(number: 1, need: 10, remaining: 10)\n/// [11, 0]\n/// >>> eat(number: 2,\
    \ need: 11, remaining: 5)\n/// [7, 0]\n/// Variables:\n/// @number : integer\n\
    /// the number of carrots that you have eaten.\n/// @need : integer\n/// the number\
    \ of carrots that you need to eat.\n/// @remaining : integer\n/// the number of\
    \ remaining carrots thet exist in stock\n/// Constrain:\n/// * 0 <= number <=\
    \ 1000\n/// * 0 <= need <= 1000\n/// * 0 <= remaining <= 1000\n/// Have fun :)\n\
    func eat(number: Int, need: Int, remaining: Int) -> [Int] {\n    let required\
    \ = number + need\n    return required <= remaining ? [required, remaining - required]\
    \ : [required - remaining, 0]\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int,\
    \ Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n\
    \    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n          \
    \  return false\n        }\n    }\n    return true\n}\n            \nassert(eat(number:\
    \ 5, need: 6, remaining: 10) == [11, 4])\nassert(eat(number: 4, need: 8, remaining:\
    \ 9) == [12, 1])\nassert(eat(number: 1, need: 10, remaining: 10) == [11, 0])\n\
    assert(eat(number: 2, need: 11, remaining: 5) == [7, 0])\nassert(eat(number: 4,\
    \ need: 5, remaining: 7) == [9, 2])\nassert(eat(number: 4, need: 5, remaining:\
    \ 1) == [5, 0])"
  status: Exception
  stderr: 'tmphv2rtual/tmphv2rtual.swift:46: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002ad747beac80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002ad7478e1b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002ad7478e1988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002ad7478e07b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmphv2rtual                        0x000055eaaede9384 <unavailable> + 4996

    5    libc.so.6                          0x00002ad747dd6460 __libc_start_main +
    245

    6    tmphv2rtual                        0x000055eaaede8fc9 <unavailable> + 4041

    '
  stdout: ''
  timestamp: 1660014020
- exit_code: -4
  program: "\n/// You're a hungry rabbit, and you already have eaten a certain number\
    \ of carrots,\n/// but now you need to eat more carrots to complete the day's\
    \ meals.\n/// you should return an array of [ total number of eaten carrots after\
    \ your meals,\n/// the number of carrots left after your meals ]\n/// if there\
    \ are not enough remaining carrots, you will eat all remaining carrots, but will\
    \ still be hungry.\n/// Example:\n/// >>> eat(number: 5, need: 6, remaining: 10)\n\
    /// [11, 4]\n/// >>> eat(number: 4, need: 8, remaining: 9)\n/// [12, 1]\n/// >>>\
    \ eat(number: 1, need: 10, remaining: 10)\n/// [11, 0]\n/// >>> eat(number: 2,\
    \ need: 11, remaining: 5)\n/// [7, 0]\n/// Variables:\n/// @number : integer\n\
    /// the number of carrots that you have eaten.\n/// @need : integer\n/// the number\
    \ of carrots that you need to eat.\n/// @remaining : integer\n/// the number of\
    \ remaining carrots thet exist in stock\n/// Constrain:\n/// * 0 <= number <=\
    \ 1000\n/// * 0 <= need <= 1000\n/// * 0 <= remaining <= 1000\n/// Have fun :)\n\
    func eat(number: Int, need: Int, remaining: Int) -> [Int] {\n    let totalNumber\
    \ = number + remaining\n    let maxNumber = min(totalNumber, need)\n    let leftover\
    \ = totalNumber - maxNumber\n    return [maxNumber, leftover]\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(eat(number: 5, need: 6, remaining: 10) == [11, 4])\nassert(eat(number:\
    \ 4, need: 8, remaining: 9) == [12, 1])\nassert(eat(number: 1, need: 10, remaining:\
    \ 10) == [11, 0])\nassert(eat(number: 2, need: 11, remaining: 5) == [7, 0])\n\
    assert(eat(number: 4, need: 5, remaining: 7) == [9, 2])\nassert(eat(number: 4,\
    \ need: 5, remaining: 1) == [5, 0])"
  status: Exception
  stderr: 'tmpljjmj3pz/tmpljjmj3pz.swift:48: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002ad7e0a5dc80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002ad7e0754b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002ad7e0754988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002ad7e07537b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpljjmj3pz                        0x0000556864709424 <unavailable> + 5156

    5    libc.so.6                          0x00002ad7e0c49460 __libc_start_main +
    245

    6    tmpljjmj3pz                        0x0000556864709069 <unavailable> + 4201

    '
  stdout: ''
  timestamp: 1660014020
- exit_code: -4
  program: "\n/// You're a hungry rabbit, and you already have eaten a certain number\
    \ of carrots,\n/// but now you need to eat more carrots to complete the day's\
    \ meals.\n/// you should return an array of [ total number of eaten carrots after\
    \ your meals,\n/// the number of carrots left after your meals ]\n/// if there\
    \ are not enough remaining carrots, you will eat all remaining carrots, but will\
    \ still be hungry.\n/// Example:\n/// >>> eat(number: 5, need: 6, remaining: 10)\n\
    /// [11, 4]\n/// >>> eat(number: 4, need: 8, remaining: 9)\n/// [12, 1]\n/// >>>\
    \ eat(number: 1, need: 10, remaining: 10)\n/// [11, 0]\n/// >>> eat(number: 2,\
    \ need: 11, remaining: 5)\n/// [7, 0]\n/// Variables:\n/// @number : integer\n\
    /// the number of carrots that you have eaten.\n/// @need : integer\n/// the number\
    \ of carrots that you need to eat.\n/// @remaining : integer\n/// the number of\
    \ remaining carrots thet exist in stock\n/// Constrain:\n/// * 0 <= number <=\
    \ 1000\n/// * 0 <= need <= 1000\n/// * 0 <= remaining <= 1000\n/// Have fun :)\n\
    func eat(number: Int, need: Int, remaining: Int) -> [Int] {\n    return [0, 0]\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(eat(number: 5, need: 6, remaining: 10) == [11,\
    \ 4])\nassert(eat(number: 4, need: 8, remaining: 9) == [12, 1])\nassert(eat(number:\
    \ 1, need: 10, remaining: 10) == [11, 0])\nassert(eat(number: 2, need: 11, remaining:\
    \ 5) == [7, 0])\nassert(eat(number: 4, need: 5, remaining: 7) == [9, 2])\nassert(eat(number:\
    \ 4, need: 5, remaining: 1) == [5, 0])"
  status: Exception
  stderr: 'tmpes0rme1m/tmpes0rme1m.swift:45: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002ab15656fc80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002ab156266b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002ab156266988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002ab1562657b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpes0rme1m                        0x000055d20b065384 <unavailable> + 4996

    5    libc.so.6                          0x00002ab15675b460 __libc_start_main +
    245

    6    tmpes0rme1m                        0x000055d20b064fc9 <unavailable> + 4041

    '
  stdout: ''
  timestamp: 1660014019
- exit_code: -4
  program: "\n/// You're a hungry rabbit, and you already have eaten a certain number\
    \ of carrots,\n/// but now you need to eat more carrots to complete the day's\
    \ meals.\n/// you should return an array of [ total number of eaten carrots after\
    \ your meals,\n/// the number of carrots left after your meals ]\n/// if there\
    \ are not enough remaining carrots, you will eat all remaining carrots, but will\
    \ still be hungry.\n/// Example:\n/// >>> eat(number: 5, need: 6, remaining: 10)\n\
    /// [11, 4]\n/// >>> eat(number: 4, need: 8, remaining: 9)\n/// [12, 1]\n/// >>>\
    \ eat(number: 1, need: 10, remaining: 10)\n/// [11, 0]\n/// >>> eat(number: 2,\
    \ need: 11, remaining: 5)\n/// [7, 0]\n/// Variables:\n/// @number : integer\n\
    /// the number of carrots that you have eaten.\n/// @need : integer\n/// the number\
    \ of carrots that you need to eat.\n/// @remaining : integer\n/// the number of\
    \ remaining carrots thet exist in stock\n/// Constrain:\n/// * 0 <= number <=\
    \ 1000\n/// * 0 <= need <= 1000\n/// * 0 <= remaining <= 1000\n/// Have fun :)\n\
    func eat(number: Int, need: Int, remaining: Int) -> [Int] {\n    var n = number\n\
    \    var r = remaining\n    while n < need && r > 0 {\n        n += 1\n      \
    \  r -= 1\n    }\n    return [n, r]\n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(eat(number: 5, need: 6, remaining: 10) == [11, 4])\nassert(eat(number:\
    \ 4, need: 8, remaining: 9) == [12, 1])\nassert(eat(number: 1, need: 10, remaining:\
    \ 10) == [11, 0])\nassert(eat(number: 2, need: 11, remaining: 5) == [7, 0])\n\
    assert(eat(number: 4, need: 5, remaining: 7) == [9, 2])\nassert(eat(number: 4,\
    \ need: 5, remaining: 1) == [5, 0])"
  status: Exception
  stderr: 'tmpl2h1ih_v/tmpl2h1ih_v.swift:51: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b80a514cc80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b80a4e43b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b80a4e43988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b80a4e427b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpl2h1ih_v                        0x00005575ea8c8384 <unavailable> + 4996

    5    libc.so.6                          0x00002b80a5338460 __libc_start_main +
    245

    6    tmpl2h1ih_v                        0x00005575ea8c7fc9 <unavailable> + 4041

    '
  stdout: ''
  timestamp: 1660014020
- exit_code: -4
  program: "\n/// You're a hungry rabbit, and you already have eaten a certain number\
    \ of carrots,\n/// but now you need to eat more carrots to complete the day's\
    \ meals.\n/// you should return an array of [ total number of eaten carrots after\
    \ your meals,\n/// the number of carrots left after your meals ]\n/// if there\
    \ are not enough remaining carrots, you will eat all remaining carrots, but will\
    \ still be hungry.\n/// Example:\n/// >>> eat(number: 5, need: 6, remaining: 10)\n\
    /// [11, 4]\n/// >>> eat(number: 4, need: 8, remaining: 9)\n/// [12, 1]\n/// >>>\
    \ eat(number: 1, need: 10, remaining: 10)\n/// [11, 0]\n/// >>> eat(number: 2,\
    \ need: 11, remaining: 5)\n/// [7, 0]\n/// Variables:\n/// @number : integer\n\
    /// the number of carrots that you have eaten.\n/// @need : integer\n/// the number\
    \ of carrots that you need to eat.\n/// @remaining : integer\n/// the number of\
    \ remaining carrots thet exist in stock\n/// Constrain:\n/// * 0 <= number <=\
    \ 1000\n/// * 0 <= need <= 1000\n/// * 0 <= remaining <= 1000\n/// Have fun :)\n\
    func eat(number: Int, need: Int, remaining: Int) -> [Int] {\n    if number > 1000\
    \ || need > 1000 || remaining > 1000 {\n        return [0, 0]\n    }\n    return\
    \ [need + number, remaining - (need - number)].sorted()\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(eat(number: 5, need: 6, remaining: 10) == [11, 4])\nassert(eat(number:\
    \ 4, need: 8, remaining: 9) == [12, 1])\nassert(eat(number: 1, need: 10, remaining:\
    \ 10) == [11, 0])\nassert(eat(number: 2, need: 11, remaining: 5) == [7, 0])\n\
    assert(eat(number: 4, need: 5, remaining: 7) == [9, 2])\nassert(eat(number: 4,\
    \ need: 5, remaining: 1) == [5, 0])"
  status: Exception
  stderr: 'tmpu0eu4x8l/tmpu0eu4x8l.swift:48: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002aeb22319c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002aeb22010b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002aeb22010988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002aeb2200f7b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpu0eu4x8l                        0x000055d7cab79434 <unavailable> + 5172

    5    libc.so.6                          0x00002aeb22505460 __libc_start_main +
    245

    6    tmpu0eu4x8l                        0x000055d7cab79079 <unavailable> + 4217

    '
  stdout: ''
  timestamp: 1660014020
- exit_code: -4
  program: "\n/// You're a hungry rabbit, and you already have eaten a certain number\
    \ of carrots,\n/// but now you need to eat more carrots to complete the day's\
    \ meals.\n/// you should return an array of [ total number of eaten carrots after\
    \ your meals,\n/// the number of carrots left after your meals ]\n/// if there\
    \ are not enough remaining carrots, you will eat all remaining carrots, but will\
    \ still be hungry.\n/// Example:\n/// >>> eat(number: 5, need: 6, remaining: 10)\n\
    /// [11, 4]\n/// >>> eat(number: 4, need: 8, remaining: 9)\n/// [12, 1]\n/// >>>\
    \ eat(number: 1, need: 10, remaining: 10)\n/// [11, 0]\n/// >>> eat(number: 2,\
    \ need: 11, remaining: 5)\n/// [7, 0]\n/// Variables:\n/// @number : integer\n\
    /// the number of carrots that you have eaten.\n/// @need : integer\n/// the number\
    \ of carrots that you need to eat.\n/// @remaining : integer\n/// the number of\
    \ remaining carrots thet exist in stock\n/// Constrain:\n/// * 0 <= number <=\
    \ 1000\n/// * 0 <= need <= 1000\n/// * 0 <= remaining <= 1000\n/// Have fun :)\n\
    func eat(number: Int, need: Int, remaining: Int) -> [Int] {\n    \n    var total\
    \ = number + remaining\n    if total >= need {\n        total = need\n    }\n\
    \    return [total, remaining - (total - number)]\n}\n\n\nfunc ==(left: [(Int,\
    \ Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n\
    \        return false\n    }\n    for (l, r) in zip(left, right) {\n        if\
    \ l != r {\n            return false\n        }\n    }\n    return true\n}\n \
    \           \nassert(eat(number: 5, need: 6, remaining: 10) == [11, 4])\nassert(eat(number:\
    \ 4, need: 8, remaining: 9) == [12, 1])\nassert(eat(number: 1, need: 10, remaining:\
    \ 10) == [11, 0])\nassert(eat(number: 2, need: 11, remaining: 5) == [7, 0])\n\
    assert(eat(number: 4, need: 5, remaining: 7) == [9, 2])\nassert(eat(number: 4,\
    \ need: 5, remaining: 1) == [5, 0])"
  status: Exception
  stderr: 'tmp7u2cdk2k/tmp7u2cdk2k.swift:50: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002af861ebbc80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002af861bb2b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002af861bb2988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002af861bb17b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmp7u2cdk2k                        0x000055dad2e10384 <unavailable> + 4996

    5    libc.so.6                          0x00002af8620a7460 __libc_start_main +
    245

    6    tmp7u2cdk2k                        0x000055dad2e0ffc9 <unavailable> + 4041

    '
  stdout: ''
  timestamp: 1660014020
- exit_code: 1
  program: "\n/// You're a hungry rabbit, and you already have eaten a certain number\
    \ of carrots,\n/// but now you need to eat more carrots to complete the day's\
    \ meals.\n/// you should return an array of [ total number of eaten carrots after\
    \ your meals,\n/// the number of carrots left after your meals ]\n/// if there\
    \ are not enough remaining carrots, you will eat all remaining carrots, but will\
    \ still be hungry.\n/// Example:\n/// >>> eat(number: 5, need: 6, remaining: 10)\n\
    /// [11, 4]\n/// >>> eat(number: 4, need: 8, remaining: 9)\n/// [12, 1]\n/// >>>\
    \ eat(number: 1, need: 10, remaining: 10)\n/// [11, 0]\n/// >>> eat(number: 2,\
    \ need: 11, remaining: 5)\n/// [7, 0]\n/// Variables:\n/// @number : integer\n\
    /// the number of carrots that you have eaten.\n/// @need : integer\n/// the number\
    \ of carrots that you need to eat.\n/// @remaining : integer\n/// the number of\
    \ remaining carrots thet exist in stock\n/// Constrain:\n/// * 0 <= number <=\
    \ 1000\n/// * 0 <= need <= 1000\n/// * 0 <= remaining <= 1000\n/// Have fun :)\n\
    func eat(number: Int, need: Int, remaining: Int) -> [Int] {\n    var eaten = number\n\
    \    var left = remaining\n    while (need > 0 && left > 0) {\n        eaten +=\
    \ 1\n        left -= 1\n        need -= 1\n    }\n    return [eaten, left]\n}\n\
    \n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(eat(number: 5, need: 6, remaining: 10) == [11,\
    \ 4])\nassert(eat(number: 4, need: 8, remaining: 9) == [12, 1])\nassert(eat(number:\
    \ 1, need: 10, remaining: 10) == [11, 0])\nassert(eat(number: 2, need: 11, remaining:\
    \ 5) == [7, 0])\nassert(eat(number: 4, need: 5, remaining: 7) == [9, 2])\nassert(eat(number:\
    \ 4, need: 5, remaining: 1) == [5, 0])"
  status: SyntaxError
  stderr: "/tmp/tmp6fdy0b5g.swift:34:14: error: left side of mutating operator isn't\
    \ mutable: 'need' is a 'let' constant\n        need -= 1\n        ~~~~ ^\n"
  stdout: ''
  timestamp: 1660014020
- exit_code: -4
  program: "\n/// You're a hungry rabbit, and you already have eaten a certain number\
    \ of carrots,\n/// but now you need to eat more carrots to complete the day's\
    \ meals.\n/// you should return an array of [ total number of eaten carrots after\
    \ your meals,\n/// the number of carrots left after your meals ]\n/// if there\
    \ are not enough remaining carrots, you will eat all remaining carrots, but will\
    \ still be hungry.\n/// Example:\n/// >>> eat(number: 5, need: 6, remaining: 10)\n\
    /// [11, 4]\n/// >>> eat(number: 4, need: 8, remaining: 9)\n/// [12, 1]\n/// >>>\
    \ eat(number: 1, need: 10, remaining: 10)\n/// [11, 0]\n/// >>> eat(number: 2,\
    \ need: 11, remaining: 5)\n/// [7, 0]\n/// Variables:\n/// @number : integer\n\
    /// the number of carrots that you have eaten.\n/// @need : integer\n/// the number\
    \ of carrots that you need to eat.\n/// @remaining : integer\n/// the number of\
    \ remaining carrots thet exist in stock\n/// Constrain:\n/// * 0 <= number <=\
    \ 1000\n/// * 0 <= need <= 1000\n/// * 0 <= remaining <= 1000\n/// Have fun :)\n\
    func eat(number: Int, need: Int, remaining: Int) -> [Int] {\n    let total = number\
    \ + remaining\n    let left = total - need\n    if left >= 0 {\n        return\
    \ [need, left]\n    } else {\n        return [total, 0]\n    }\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(eat(number: 5, need: 6, remaining: 10) == [11, 4])\nassert(eat(number:\
    \ 4, need: 8, remaining: 9) == [12, 1])\nassert(eat(number: 1, need: 10, remaining:\
    \ 10) == [11, 0])\nassert(eat(number: 2, need: 11, remaining: 5) == [7, 0])\n\
    assert(eat(number: 4, need: 5, remaining: 7) == [9, 2])\nassert(eat(number: 4,\
    \ need: 5, remaining: 1) == [5, 0])"
  status: Exception
  stderr: 'tmp20hqaopo/tmp20hqaopo.swift:51: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b4d615f1c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b4d612e8b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b4d612e8988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b4d612e77b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmp20hqaopo                        0x0000564ade4ae384 <unavailable> + 4996

    5    libc.so.6                          0x00002b4d617dd460 __libc_start_main +
    245

    6    tmp20hqaopo                        0x0000564ade4adfc9 <unavailable> + 4041

    '
  stdout: ''
  timestamp: 1660014019
- exit_code: -4
  program: "\n/// You're a hungry rabbit, and you already have eaten a certain number\
    \ of carrots,\n/// but now you need to eat more carrots to complete the day's\
    \ meals.\n/// you should return an array of [ total number of eaten carrots after\
    \ your meals,\n/// the number of carrots left after your meals ]\n/// if there\
    \ are not enough remaining carrots, you will eat all remaining carrots, but will\
    \ still be hungry.\n/// Example:\n/// >>> eat(number: 5, need: 6, remaining: 10)\n\
    /// [11, 4]\n/// >>> eat(number: 4, need: 8, remaining: 9)\n/// [12, 1]\n/// >>>\
    \ eat(number: 1, need: 10, remaining: 10)\n/// [11, 0]\n/// >>> eat(number: 2,\
    \ need: 11, remaining: 5)\n/// [7, 0]\n/// Variables:\n/// @number : integer\n\
    /// the number of carrots that you have eaten.\n/// @need : integer\n/// the number\
    \ of carrots that you need to eat.\n/// @remaining : integer\n/// the number of\
    \ remaining carrots thet exist in stock\n/// Constrain:\n/// * 0 <= number <=\
    \ 1000\n/// * 0 <= need <= 1000\n/// * 0 <= remaining <= 1000\n/// Have fun :)\n\
    func eat(number: Int, need: Int, remaining: Int) -> [Int] {\n    // Write your\
    \ code here\n    if number < 0 || need < 0 || remaining < 0 {\n        return\
    \ []\n    }\n    if number > 1000 || need > 1000 || remaining > 1000 {\n     \
    \   return []\n    }\n    if need - number <= remaining {\n        return [number\
    \ + need - number, remaining - (need - number)]\n    } else {\n        return\
    \ [number + remaining, 0]\n    }\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int,\
    \ Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n\
    \    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n          \
    \  return false\n        }\n    }\n    return true\n}\n            \nassert(eat(number:\
    \ 5, need: 6, remaining: 10) == [11, 4])\nassert(eat(number: 4, need: 8, remaining:\
    \ 9) == [12, 1])\nassert(eat(number: 1, need: 10, remaining: 10) == [11, 0])\n\
    assert(eat(number: 2, need: 11, remaining: 5) == [7, 0])\nassert(eat(number: 4,\
    \ need: 5, remaining: 7) == [9, 2])\nassert(eat(number: 4, need: 5, remaining:\
    \ 1) == [5, 0])"
  status: Exception
  stderr: 'tmp902myzse/tmp902myzse.swift:56: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b7784ca3c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b778499ab6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b778499a988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b77849997b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmp902myzse                        0x000055ae6418e384 <unavailable> + 4996

    5    libc.so.6                          0x00002b7784e8f460 __libc_start_main +
    245

    6    tmp902myzse                        0x000055ae6418dfc9 <unavailable> + 4041

    '
  stdout: ''
  timestamp: 1660014020
- exit_code: 1
  program: "\n/// You're a hungry rabbit, and you already have eaten a certain number\
    \ of carrots,\n/// but now you need to eat more carrots to complete the day's\
    \ meals.\n/// you should return an array of [ total number of eaten carrots after\
    \ your meals,\n/// the number of carrots left after your meals ]\n/// if there\
    \ are not enough remaining carrots, you will eat all remaining carrots, but will\
    \ still be hungry.\n/// Example:\n/// >>> eat(number: 5, need: 6, remaining: 10)\n\
    /// [11, 4]\n/// >>> eat(number: 4, need: 8, remaining: 9)\n/// [12, 1]\n/// >>>\
    \ eat(number: 1, need: 10, remaining: 10)\n/// [11, 0]\n/// >>> eat(number: 2,\
    \ need: 11, remaining: 5)\n/// [7, 0]\n/// Variables:\n/// @number : integer\n\
    /// the number of carrots that you have eaten.\n/// @need : integer\n/// the number\
    \ of carrots that you need to eat.\n/// @remaining : integer\n/// the number of\
    \ remaining carrots thet exist in stock\n/// Constrain:\n/// * 0 <= number <=\
    \ 1000\n/// * 0 <= need <= 1000\n/// * 0 <= remaining <= 1000\n/// Have fun :)\n\
    func eat(number: Int, need: Int, remaining: Int) -> [Int] {\n    return [(number\
    \ + remaining).minimum(number + need), (number + remaining).maximum(number + need)\
    \ - (number + need)]\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(eat(number:\
    \ 5, need: 6, remaining: 10) == [11, 4])\nassert(eat(number: 4, need: 8, remaining:\
    \ 9) == [12, 1])\nassert(eat(number: 1, need: 10, remaining: 10) == [11, 0])\n\
    assert(eat(number: 2, need: 11, remaining: 5) == [7, 0])\nassert(eat(number: 4,\
    \ need: 5, remaining: 7) == [9, 2])\nassert(eat(number: 4, need: 5, remaining:\
    \ 1) == [5, 0])"
  status: SyntaxError
  stderr: "/tmp/tmpvbhei9nq.swift:29:34: error: value of type 'Int' has no member\
    \ 'minimum'\n    return [(number + remaining).minimum(number + need), (number\
    \ + remaining).maximum(number + need) - (number + need)]\n            ~~~~~~~~~~~~~~~~~~~~\
    \ ^~~~~~~\n/tmp/tmpvbhei9nq.swift:29:79: error: value of type 'Int' has no member\
    \ 'maximum'\n    return [(number + remaining).minimum(number + need), (number\
    \ + remaining).maximum(number + need) - (number + need)]\n                   \
    \                                      ~~~~~~~~~~~~~~~~~~~~ ^~~~~~~\n"
  stdout: ''
  timestamp: 1660014020
- exit_code: -4
  program: "\n/// You're a hungry rabbit, and you already have eaten a certain number\
    \ of carrots,\n/// but now you need to eat more carrots to complete the day's\
    \ meals.\n/// you should return an array of [ total number of eaten carrots after\
    \ your meals,\n/// the number of carrots left after your meals ]\n/// if there\
    \ are not enough remaining carrots, you will eat all remaining carrots, but will\
    \ still be hungry.\n/// Example:\n/// >>> eat(number: 5, need: 6, remaining: 10)\n\
    /// [11, 4]\n/// >>> eat(number: 4, need: 8, remaining: 9)\n/// [12, 1]\n/// >>>\
    \ eat(number: 1, need: 10, remaining: 10)\n/// [11, 0]\n/// >>> eat(number: 2,\
    \ need: 11, remaining: 5)\n/// [7, 0]\n/// Variables:\n/// @number : integer\n\
    /// the number of carrots that you have eaten.\n/// @need : integer\n/// the number\
    \ of carrots that you need to eat.\n/// @remaining : integer\n/// the number of\
    \ remaining carrots thet exist in stock\n/// Constrain:\n/// * 0 <= number <=\
    \ 1000\n/// * 0 <= need <= 1000\n/// * 0 <= remaining <= 1000\n/// Have fun :)\n\
    func eat(number: Int, need: Int, remaining: Int) -> [Int] {\n    let total = number\
    \ + need\n    return total <= remaining ? [total, remaining - total] : [remaining,\
    \ 0]\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if\
    \ left.count != right.count {\n        return false\n    }\n    for (l, r) in\
    \ zip(left, right) {\n        if l != r {\n            return false\n        }\n\
    \    }\n    return true\n}\n            \nassert(eat(number: 5, need: 6, remaining:\
    \ 10) == [11, 4])\nassert(eat(number: 4, need: 8, remaining: 9) == [12, 1])\n\
    assert(eat(number: 1, need: 10, remaining: 10) == [11, 0])\nassert(eat(number:\
    \ 2, need: 11, remaining: 5) == [7, 0])\nassert(eat(number: 4, need: 5, remaining:\
    \ 7) == [9, 2])\nassert(eat(number: 4, need: 5, remaining: 1) == [5, 0])"
  status: Exception
  stderr: 'tmpzl1g17xh/tmpzl1g17xh.swift:46: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b4714ac2c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b47147b9b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b47147b9988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b47147b87b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpzl1g17xh                        0x0000559ecf68e384 <unavailable> + 4996

    5    libc.so.6                          0x00002b4714cae460 __libc_start_main +
    245

    6    tmpzl1g17xh                        0x0000559ecf68dfc9 <unavailable> + 4041

    '
  stdout: ''
  timestamp: 1660014020
- exit_code: -4
  program: "\n/// You're a hungry rabbit, and you already have eaten a certain number\
    \ of carrots,\n/// but now you need to eat more carrots to complete the day's\
    \ meals.\n/// you should return an array of [ total number of eaten carrots after\
    \ your meals,\n/// the number of carrots left after your meals ]\n/// if there\
    \ are not enough remaining carrots, you will eat all remaining carrots, but will\
    \ still be hungry.\n/// Example:\n/// >>> eat(number: 5, need: 6, remaining: 10)\n\
    /// [11, 4]\n/// >>> eat(number: 4, need: 8, remaining: 9)\n/// [12, 1]\n/// >>>\
    \ eat(number: 1, need: 10, remaining: 10)\n/// [11, 0]\n/// >>> eat(number: 2,\
    \ need: 11, remaining: 5)\n/// [7, 0]\n/// Variables:\n/// @number : integer\n\
    /// the number of carrots that you have eaten.\n/// @need : integer\n/// the number\
    \ of carrots that you need to eat.\n/// @remaining : integer\n/// the number of\
    \ remaining carrots thet exist in stock\n/// Constrain:\n/// * 0 <= number <=\
    \ 1000\n/// * 0 <= need <= 1000\n/// * 0 <= remaining <= 1000\n/// Have fun :)\n\
    func eat(number: Int, need: Int, remaining: Int) -> [Int] {\n    let all = number\
    \ + remaining\n    return (all >= need) ? [need, all - need] : [all, 0]\n}\n\n\
    \nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(eat(number: 5, need: 6, remaining: 10) == [11,\
    \ 4])\nassert(eat(number: 4, need: 8, remaining: 9) == [12, 1])\nassert(eat(number:\
    \ 1, need: 10, remaining: 10) == [11, 0])\nassert(eat(number: 2, need: 11, remaining:\
    \ 5) == [7, 0])\nassert(eat(number: 4, need: 5, remaining: 7) == [9, 2])\nassert(eat(number:\
    \ 4, need: 5, remaining: 1) == [5, 0])"
  status: Exception
  stderr: 'tmpw4mivt82/tmpw4mivt82.swift:46: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b8061c7fc80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b8061976b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b8061976988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b80619757b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpw4mivt82                        0x000055c00c4e3384 <unavailable> + 4996

    5    libc.so.6                          0x00002b8061e6b460 __libc_start_main +
    245

    6    tmpw4mivt82                        0x000055c00c4e2fc9 <unavailable> + 4041

    '
  stdout: ''
  timestamp: 1660014020
- exit_code: -4
  program: "\n/// You're a hungry rabbit, and you already have eaten a certain number\
    \ of carrots,\n/// but now you need to eat more carrots to complete the day's\
    \ meals.\n/// you should return an array of [ total number of eaten carrots after\
    \ your meals,\n/// the number of carrots left after your meals ]\n/// if there\
    \ are not enough remaining carrots, you will eat all remaining carrots, but will\
    \ still be hungry.\n/// Example:\n/// >>> eat(number: 5, need: 6, remaining: 10)\n\
    /// [11, 4]\n/// >>> eat(number: 4, need: 8, remaining: 9)\n/// [12, 1]\n/// >>>\
    \ eat(number: 1, need: 10, remaining: 10)\n/// [11, 0]\n/// >>> eat(number: 2,\
    \ need: 11, remaining: 5)\n/// [7, 0]\n/// Variables:\n/// @number : integer\n\
    /// the number of carrots that you have eaten.\n/// @need : integer\n/// the number\
    \ of carrots that you need to eat.\n/// @remaining : integer\n/// the number of\
    \ remaining carrots thet exist in stock\n/// Constrain:\n/// * 0 <= number <=\
    \ 1000\n/// * 0 <= need <= 1000\n/// * 0 <= remaining <= 1000\n/// Have fun :)\n\
    func eat(number: Int, need: Int, remaining: Int) -> [Int] {\n    if (number >\
    \ 1000 || need > 1000 || remaining > 1000 || number < 0 || need < 0 || remaining\
    \ < 0) {\n        return [0, 0]\n    }\n    let newNeed = need - number\n    let\
    \ finalEat = min(newNeed, remaining)\n    return [number + finalEat, remaining\
    \ - finalEat]\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool\
    \ {\n    if left.count != right.count {\n        return false\n    }\n    for\
    \ (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(eat(number: 5, need:\
    \ 6, remaining: 10) == [11, 4])\nassert(eat(number: 4, need: 8, remaining: 9)\
    \ == [12, 1])\nassert(eat(number: 1, need: 10, remaining: 10) == [11, 0])\nassert(eat(number:\
    \ 2, need: 11, remaining: 5) == [7, 0])\nassert(eat(number: 4, need: 5, remaining:\
    \ 7) == [9, 2])\nassert(eat(number: 4, need: 5, remaining: 1) == [5, 0])"
  status: Exception
  stderr: 'tmpluikyvkx/tmpluikyvkx.swift:50: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b2ab8daec80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b2ab8aa5b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b2ab8aa5988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b2ab8aa47b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpluikyvkx                        0x0000564387c6e424 <unavailable> + 5156

    5    libc.so.6                          0x00002b2ab8f9a460 __libc_start_main +
    245

    6    tmpluikyvkx                        0x0000564387c6e069 <unavailable> + 4201

    '
  stdout: ''
  timestamp: 1660014020
- exit_code: -4
  program: "\n/// You're a hungry rabbit, and you already have eaten a certain number\
    \ of carrots,\n/// but now you need to eat more carrots to complete the day's\
    \ meals.\n/// you should return an array of [ total number of eaten carrots after\
    \ your meals,\n/// the number of carrots left after your meals ]\n/// if there\
    \ are not enough remaining carrots, you will eat all remaining carrots, but will\
    \ still be hungry.\n/// Example:\n/// >>> eat(number: 5, need: 6, remaining: 10)\n\
    /// [11, 4]\n/// >>> eat(number: 4, need: 8, remaining: 9)\n/// [12, 1]\n/// >>>\
    \ eat(number: 1, need: 10, remaining: 10)\n/// [11, 0]\n/// >>> eat(number: 2,\
    \ need: 11, remaining: 5)\n/// [7, 0]\n/// Variables:\n/// @number : integer\n\
    /// the number of carrots that you have eaten.\n/// @need : integer\n/// the number\
    \ of carrots that you need to eat.\n/// @remaining : integer\n/// the number of\
    \ remaining carrots thet exist in stock\n/// Constrain:\n/// * 0 <= number <=\
    \ 1000\n/// * 0 <= need <= 1000\n/// * 0 <= remaining <= 1000\n/// Have fun :)\n\
    func eat(number: Int, need: Int, remaining: Int) -> [Int] {\n    let eaten = number\
    \ + (need - number) > remaining ? remaining : number + (need - number)\n    return\
    \ [eaten, remaining - eaten]\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int,\
    \ Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n\
    \    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n          \
    \  return false\n        }\n    }\n    return true\n}\n            \nassert(eat(number:\
    \ 5, need: 6, remaining: 10) == [11, 4])\nassert(eat(number: 4, need: 8, remaining:\
    \ 9) == [12, 1])\nassert(eat(number: 1, need: 10, remaining: 10) == [11, 0])\n\
    assert(eat(number: 2, need: 11, remaining: 5) == [7, 0])\nassert(eat(number: 4,\
    \ need: 5, remaining: 7) == [9, 2])\nassert(eat(number: 4, need: 5, remaining:\
    \ 1) == [5, 0])"
  status: Exception
  stderr: 'tmpwxnmyi78/tmpwxnmyi78.swift:46: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002adbc02bcc80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002adbbffb3b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002adbbffb3988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002adbbffb27b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpwxnmyi78                        0x00005629aaad1384 <unavailable> + 4996

    5    libc.so.6                          0x00002adbc04a8460 __libc_start_main +
    245

    6    tmpwxnmyi78                        0x00005629aaad0fc9 <unavailable> + 4041

    '
  stdout: ''
  timestamp: 1660014020
- exit_code: -4
  program: "\n/// You're a hungry rabbit, and you already have eaten a certain number\
    \ of carrots,\n/// but now you need to eat more carrots to complete the day's\
    \ meals.\n/// you should return an array of [ total number of eaten carrots after\
    \ your meals,\n/// the number of carrots left after your meals ]\n/// if there\
    \ are not enough remaining carrots, you will eat all remaining carrots, but will\
    \ still be hungry.\n/// Example:\n/// >>> eat(number: 5, need: 6, remaining: 10)\n\
    /// [11, 4]\n/// >>> eat(number: 4, need: 8, remaining: 9)\n/// [12, 1]\n/// >>>\
    \ eat(number: 1, need: 10, remaining: 10)\n/// [11, 0]\n/// >>> eat(number: 2,\
    \ need: 11, remaining: 5)\n/// [7, 0]\n/// Variables:\n/// @number : integer\n\
    /// the number of carrots that you have eaten.\n/// @need : integer\n/// the number\
    \ of carrots that you need to eat.\n/// @remaining : integer\n/// the number of\
    \ remaining carrots thet exist in stock\n/// Constrain:\n/// * 0 <= number <=\
    \ 1000\n/// * 0 <= need <= 1000\n/// * 0 <= remaining <= 1000\n/// Have fun :)\n\
    func eat(number: Int, need: Int, remaining: Int) -> [Int] {\n    let numberOfEatenCarrots\
    \ = min(remaining, need - number)\n    return [number + numberOfEatenCarrots,\
    \ remaining - numberOfEatenCarrots]\n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(eat(number: 5, need: 6, remaining: 10) == [11, 4])\nassert(eat(number:\
    \ 4, need: 8, remaining: 9) == [12, 1])\nassert(eat(number: 1, need: 10, remaining:\
    \ 10) == [11, 0])\nassert(eat(number: 2, need: 11, remaining: 5) == [7, 0])\n\
    assert(eat(number: 4, need: 5, remaining: 7) == [9, 2])\nassert(eat(number: 4,\
    \ need: 5, remaining: 1) == [5, 0])"
  status: Exception
  stderr: 'tmpc61l26pi/tmpc61l26pi.swift:46: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b743dddbc80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b743dad2b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b743dad2988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b743dad17b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpc61l26pi                        0x000055fe46f65424 <unavailable> + 5156

    5    libc.so.6                          0x00002b743dfc7460 __libc_start_main +
    245

    6    tmpc61l26pi                        0x000055fe46f65069 <unavailable> + 4201

    '
  stdout: ''
  timestamp: 1660014020
- exit_code: 0
  program: "\n/// You're a hungry rabbit, and you already have eaten a certain number\
    \ of carrots,\n/// but now you need to eat more carrots to complete the day's\
    \ meals.\n/// you should return an array of [ total number of eaten carrots after\
    \ your meals,\n/// the number of carrots left after your meals ]\n/// if there\
    \ are not enough remaining carrots, you will eat all remaining carrots, but will\
    \ still be hungry.\n/// Example:\n/// >>> eat(number: 5, need: 6, remaining: 10)\n\
    /// [11, 4]\n/// >>> eat(number: 4, need: 8, remaining: 9)\n/// [12, 1]\n/// >>>\
    \ eat(number: 1, need: 10, remaining: 10)\n/// [11, 0]\n/// >>> eat(number: 2,\
    \ need: 11, remaining: 5)\n/// [7, 0]\n/// Variables:\n/// @number : integer\n\
    /// the number of carrots that you have eaten.\n/// @need : integer\n/// the number\
    \ of carrots that you need to eat.\n/// @remaining : integer\n/// the number of\
    \ remaining carrots thet exist in stock\n/// Constrain:\n/// * 0 <= number <=\
    \ 1000\n/// * 0 <= need <= 1000\n/// * 0 <= remaining <= 1000\n/// Have fun :)\n\
    func eat(number: Int, need: Int, remaining: Int) -> [Int] {\n    let totalEat\
    \ = number + min(need, remaining)\n    let left = max(0, remaining - need)\n \
    \   return [totalEat, left]\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int,\
    \ Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n\
    \    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n          \
    \  return false\n        }\n    }\n    return true\n}\n            \nassert(eat(number:\
    \ 5, need: 6, remaining: 10) == [11, 4])\nassert(eat(number: 4, need: 8, remaining:\
    \ 9) == [12, 1])\nassert(eat(number: 1, need: 10, remaining: 10) == [11, 0])\n\
    assert(eat(number: 2, need: 11, remaining: 5) == [7, 0])\nassert(eat(number: 4,\
    \ need: 5, remaining: 7) == [9, 2])\nassert(eat(number: 4, need: 5, remaining:\
    \ 1) == [5, 0])"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660014020
- exit_code: -4
  program: "\n/// You're a hungry rabbit, and you already have eaten a certain number\
    \ of carrots,\n/// but now you need to eat more carrots to complete the day's\
    \ meals.\n/// you should return an array of [ total number of eaten carrots after\
    \ your meals,\n/// the number of carrots left after your meals ]\n/// if there\
    \ are not enough remaining carrots, you will eat all remaining carrots, but will\
    \ still be hungry.\n/// Example:\n/// >>> eat(number: 5, need: 6, remaining: 10)\n\
    /// [11, 4]\n/// >>> eat(number: 4, need: 8, remaining: 9)\n/// [12, 1]\n/// >>>\
    \ eat(number: 1, need: 10, remaining: 10)\n/// [11, 0]\n/// >>> eat(number: 2,\
    \ need: 11, remaining: 5)\n/// [7, 0]\n/// Variables:\n/// @number : integer\n\
    /// the number of carrots that you have eaten.\n/// @need : integer\n/// the number\
    \ of carrots that you need to eat.\n/// @remaining : integer\n/// the number of\
    \ remaining carrots thet exist in stock\n/// Constrain:\n/// * 0 <= number <=\
    \ 1000\n/// * 0 <= need <= 1000\n/// * 0 <= remaining <= 1000\n/// Have fun :)\n\
    func eat(number: Int, need: Int, remaining: Int) -> [Int] {\n    var need = need\n\
    \    var n = 0\n    var r = remaining\n    for i in number..<need {\n        r\
    \ -= 1\n        n += 1\n        if r == 0 {\n            break\n        }\n  \
    \  }\n    if n + number == need {\n        return [n + number, r]\n    } else\
    \ {\n        return [number + remaining, 0]\n    }\n}\n\n\nfunc ==(left: [(Int,\
    \ Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n\
    \        return false\n    }\n    for (l, r) in zip(left, right) {\n        if\
    \ l != r {\n            return false\n        }\n    }\n    return true\n}\n \
    \           \nassert(eat(number: 5, need: 6, remaining: 10) == [11, 4])\nassert(eat(number:\
    \ 4, need: 8, remaining: 9) == [12, 1])\nassert(eat(number: 1, need: 10, remaining:\
    \ 10) == [11, 0])\nassert(eat(number: 2, need: 11, remaining: 5) == [7, 0])\n\
    assert(eat(number: 4, need: 5, remaining: 7) == [9, 2])\nassert(eat(number: 4,\
    \ need: 5, remaining: 1) == [5, 0])"
  status: Exception
  stderr: 'tmpb1izp7xv/tmpb1izp7xv.swift:59: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b464cd74c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b464ca6bb6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b464ca6b988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b464ca6a7b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpb1izp7xv                        0x000055dc87ca7514 <unavailable> + 5396

    5    libc.so.6                          0x00002b464cf60460 __libc_start_main +
    245

    6    tmpb1izp7xv                        0x000055dc87ca7159 <unavailable> + 4441

    '
  stdout: ''
  timestamp: 1660014020
- exit_code: -4
  program: "\n/// You're a hungry rabbit, and you already have eaten a certain number\
    \ of carrots,\n/// but now you need to eat more carrots to complete the day's\
    \ meals.\n/// you should return an array of [ total number of eaten carrots after\
    \ your meals,\n/// the number of carrots left after your meals ]\n/// if there\
    \ are not enough remaining carrots, you will eat all remaining carrots, but will\
    \ still be hungry.\n/// Example:\n/// >>> eat(number: 5, need: 6, remaining: 10)\n\
    /// [11, 4]\n/// >>> eat(number: 4, need: 8, remaining: 9)\n/// [12, 1]\n/// >>>\
    \ eat(number: 1, need: 10, remaining: 10)\n/// [11, 0]\n/// >>> eat(number: 2,\
    \ need: 11, remaining: 5)\n/// [7, 0]\n/// Variables:\n/// @number : integer\n\
    /// the number of carrots that you have eaten.\n/// @need : integer\n/// the number\
    \ of carrots that you need to eat.\n/// @remaining : integer\n/// the number of\
    \ remaining carrots thet exist in stock\n/// Constrain:\n/// * 0 <= number <=\
    \ 1000\n/// * 0 <= need <= 1000\n/// * 0 <= remaining <= 1000\n/// Have fun :)\n\
    func eat(number: Int, need: Int, remaining: Int) -> [Int] {\n    let requiredToEat\
    \ = need - number\n    let totalEaten = number + min(requiredToEat, remaining)\n\
    \    let remainingCarrots = max(0, remaining - requiredToEat)\n    return [totalEaten,\
    \ remainingCarrots]\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) ->\
    \ Bool {\n    if left.count != right.count {\n        return false\n    }\n  \
    \  for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(eat(number: 5, need:\
    \ 6, remaining: 10) == [11, 4])\nassert(eat(number: 4, need: 8, remaining: 9)\
    \ == [12, 1])\nassert(eat(number: 1, need: 10, remaining: 10) == [11, 0])\nassert(eat(number:\
    \ 2, need: 11, remaining: 5) == [7, 0])\nassert(eat(number: 4, need: 5, remaining:\
    \ 7) == [9, 2])\nassert(eat(number: 4, need: 5, remaining: 1) == [5, 0])"
  status: Exception
  stderr: 'tmpivnambwd/tmpivnambwd.swift:48: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002ac81a23fc80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002ac819f36b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002ac819f36988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002ac819f357b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpivnambwd                        0x00005593f18c6474 <unavailable> + 5236

    5    libc.so.6                          0x00002ac81a42b460 __libc_start_main +
    245

    6    tmpivnambwd                        0x00005593f18c60b9 <unavailable> + 4281

    '
  stdout: ''
  timestamp: 1660014020
- exit_code: -4
  program: "\n/// You're a hungry rabbit, and you already have eaten a certain number\
    \ of carrots,\n/// but now you need to eat more carrots to complete the day's\
    \ meals.\n/// you should return an array of [ total number of eaten carrots after\
    \ your meals,\n/// the number of carrots left after your meals ]\n/// if there\
    \ are not enough remaining carrots, you will eat all remaining carrots, but will\
    \ still be hungry.\n/// Example:\n/// >>> eat(number: 5, need: 6, remaining: 10)\n\
    /// [11, 4]\n/// >>> eat(number: 4, need: 8, remaining: 9)\n/// [12, 1]\n/// >>>\
    \ eat(number: 1, need: 10, remaining: 10)\n/// [11, 0]\n/// >>> eat(number: 2,\
    \ need: 11, remaining: 5)\n/// [7, 0]\n/// Variables:\n/// @number : integer\n\
    /// the number of carrots that you have eaten.\n/// @need : integer\n/// the number\
    \ of carrots that you need to eat.\n/// @remaining : integer\n/// the number of\
    \ remaining carrots thet exist in stock\n/// Constrain:\n/// * 0 <= number <=\
    \ 1000\n/// * 0 <= need <= 1000\n/// * 0 <= remaining <= 1000\n/// Have fun :)\n\
    func eat(number: Int, need: Int, remaining: Int) -> [Int] {\n    return []\n}\n\
    \n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(eat(number: 5, need: 6, remaining: 10) == [11,\
    \ 4])\nassert(eat(number: 4, need: 8, remaining: 9) == [12, 1])\nassert(eat(number:\
    \ 1, need: 10, remaining: 10) == [11, 0])\nassert(eat(number: 2, need: 11, remaining:\
    \ 5) == [7, 0])\nassert(eat(number: 4, need: 5, remaining: 7) == [9, 2])\nassert(eat(number:\
    \ 4, need: 5, remaining: 1) == [5, 0])"
  status: Exception
  stderr: 'tmp5d0or02d/tmp5d0or02d.swift:45: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b0276059c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b0275d50b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b0275d50988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b0275d4f7b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmp5d0or02d                        0x000056073e3c5384 <unavailable> + 4996

    5    libc.so.6                          0x00002b0276245460 __libc_start_main +
    245

    6    tmp5d0or02d                        0x000056073e3c4fc9 <unavailable> + 4041

    '
  stdout: ''
  timestamp: 1660014019
- exit_code: -4
  program: "\n/// You're a hungry rabbit, and you already have eaten a certain number\
    \ of carrots,\n/// but now you need to eat more carrots to complete the day's\
    \ meals.\n/// you should return an array of [ total number of eaten carrots after\
    \ your meals,\n/// the number of carrots left after your meals ]\n/// if there\
    \ are not enough remaining carrots, you will eat all remaining carrots, but will\
    \ still be hungry.\n/// Example:\n/// >>> eat(number: 5, need: 6, remaining: 10)\n\
    /// [11, 4]\n/// >>> eat(number: 4, need: 8, remaining: 9)\n/// [12, 1]\n/// >>>\
    \ eat(number: 1, need: 10, remaining: 10)\n/// [11, 0]\n/// >>> eat(number: 2,\
    \ need: 11, remaining: 5)\n/// [7, 0]\n/// Variables:\n/// @number : integer\n\
    /// the number of carrots that you have eaten.\n/// @need : integer\n/// the number\
    \ of carrots that you need to eat.\n/// @remaining : integer\n/// the number of\
    \ remaining carrots thet exist in stock\n/// Constrain:\n/// * 0 <= number <=\
    \ 1000\n/// * 0 <= need <= 1000\n/// * 0 <= remaining <= 1000\n/// Have fun :)\n\
    func eat(number: Int, need: Int, remaining: Int) -> [Int] {\n    // Write your\
    \ code here\n    let total = number + remaining\n    if total < need {\n     \
    \   return [total, 0]\n    } else {\n        return [need, total - need]\n   \
    \ }\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if\
    \ left.count != right.count {\n        return false\n    }\n    for (l, r) in\
    \ zip(left, right) {\n        if l != r {\n            return false\n        }\n\
    \    }\n    return true\n}\n            \nassert(eat(number: 5, need: 6, remaining:\
    \ 10) == [11, 4])\nassert(eat(number: 4, need: 8, remaining: 9) == [12, 1])\n\
    assert(eat(number: 1, need: 10, remaining: 10) == [11, 0])\nassert(eat(number:\
    \ 2, need: 11, remaining: 5) == [7, 0])\nassert(eat(number: 4, need: 5, remaining:\
    \ 7) == [9, 2])\nassert(eat(number: 4, need: 5, remaining: 1) == [5, 0])"
  status: Exception
  stderr: 'tmprxd1pynj/tmprxd1pynj.swift:51: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b63fdeb3c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b63fdbaab6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b63fdbaa988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b63fdba97b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmprxd1pynj                        0x000055b4e2935384 <unavailable> + 4996

    5    libc.so.6                          0x00002b63fe09f460 __libc_start_main +
    245

    6    tmprxd1pynj                        0x000055b4e2934fc9 <unavailable> + 4041

    '
  stdout: ''
  timestamp: 1660014020
- exit_code: -4
  program: "\n/// You're a hungry rabbit, and you already have eaten a certain number\
    \ of carrots,\n/// but now you need to eat more carrots to complete the day's\
    \ meals.\n/// you should return an array of [ total number of eaten carrots after\
    \ your meals,\n/// the number of carrots left after your meals ]\n/// if there\
    \ are not enough remaining carrots, you will eat all remaining carrots, but will\
    \ still be hungry.\n/// Example:\n/// >>> eat(number: 5, need: 6, remaining: 10)\n\
    /// [11, 4]\n/// >>> eat(number: 4, need: 8, remaining: 9)\n/// [12, 1]\n/// >>>\
    \ eat(number: 1, need: 10, remaining: 10)\n/// [11, 0]\n/// >>> eat(number: 2,\
    \ need: 11, remaining: 5)\n/// [7, 0]\n/// Variables:\n/// @number : integer\n\
    /// the number of carrots that you have eaten.\n/// @need : integer\n/// the number\
    \ of carrots that you need to eat.\n/// @remaining : integer\n/// the number of\
    \ remaining carrots thet exist in stock\n/// Constrain:\n/// * 0 <= number <=\
    \ 1000\n/// * 0 <= need <= 1000\n/// * 0 <= remaining <= 1000\n/// Have fun :)\n\
    func eat(number: Int, need: Int, remaining: Int) -> [Int] {\n    if number >=\
    \ need {\n        return [number, number - need]\n    }\n    var remaining = remaining\n\
    \    if remaining + number < need {\n        return [remaining + number, 0]\n\
    \    }\n    return [need, remaining + number - need]\n}\n\n\nfunc ==(left: [(Int,\
    \ Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n\
    \        return false\n    }\n    for (l, r) in zip(left, right) {\n        if\
    \ l != r {\n            return false\n        }\n    }\n    return true\n}\n \
    \           \nassert(eat(number: 5, need: 6, remaining: 10) == [11, 4])\nassert(eat(number:\
    \ 4, need: 8, remaining: 9) == [12, 1])\nassert(eat(number: 1, need: 10, remaining:\
    \ 10) == [11, 0])\nassert(eat(number: 2, need: 11, remaining: 5) == [7, 0])\n\
    assert(eat(number: 4, need: 5, remaining: 7) == [9, 2])\nassert(eat(number: 4,\
    \ need: 5, remaining: 1) == [5, 0])"
  status: Exception
  stderr: 'tmpdx552kkd/tmpdx552kkd.swift:52: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002ae58ec7bc80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002ae58e972b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002ae58e972988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002ae58e9717b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpdx552kkd                        0x00005624e6cf0384 <unavailable> + 4996

    5    libc.so.6                          0x00002ae58ee67460 __libc_start_main +
    245

    6    tmpdx552kkd                        0x00005624e6ceffc9 <unavailable> + 4041

    '
  stdout: ''
  timestamp: 1660014020
- exit_code: -4
  program: "\n/// You're a hungry rabbit, and you already have eaten a certain number\
    \ of carrots,\n/// but now you need to eat more carrots to complete the day's\
    \ meals.\n/// you should return an array of [ total number of eaten carrots after\
    \ your meals,\n/// the number of carrots left after your meals ]\n/// if there\
    \ are not enough remaining carrots, you will eat all remaining carrots, but will\
    \ still be hungry.\n/// Example:\n/// >>> eat(number: 5, need: 6, remaining: 10)\n\
    /// [11, 4]\n/// >>> eat(number: 4, need: 8, remaining: 9)\n/// [12, 1]\n/// >>>\
    \ eat(number: 1, need: 10, remaining: 10)\n/// [11, 0]\n/// >>> eat(number: 2,\
    \ need: 11, remaining: 5)\n/// [7, 0]\n/// Variables:\n/// @number : integer\n\
    /// the number of carrots that you have eaten.\n/// @need : integer\n/// the number\
    \ of carrots that you need to eat.\n/// @remaining : integer\n/// the number of\
    \ remaining carrots thet exist in stock\n/// Constrain:\n/// * 0 <= number <=\
    \ 1000\n/// * 0 <= need <= 1000\n/// * 0 <= remaining <= 1000\n/// Have fun :)\n\
    func eat(number: Int, need: Int, remaining: Int) -> [Int] {\n    let totalEaten\
    \ = min(remaining, number + need)\n    let rest = max(0, remaining - totalEaten)\n\
    \    return [totalEaten, rest]\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int,\
    \ Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n\
    \    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n          \
    \  return false\n        }\n    }\n    return true\n}\n            \nassert(eat(number:\
    \ 5, need: 6, remaining: 10) == [11, 4])\nassert(eat(number: 4, need: 8, remaining:\
    \ 9) == [12, 1])\nassert(eat(number: 1, need: 10, remaining: 10) == [11, 0])\n\
    assert(eat(number: 2, need: 11, remaining: 5) == [7, 0])\nassert(eat(number: 4,\
    \ need: 5, remaining: 7) == [9, 2])\nassert(eat(number: 4, need: 5, remaining:\
    \ 1) == [5, 0])"
  status: Exception
  stderr: 'tmpd1f2g7sg/tmpd1f2g7sg.swift:47: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b284bb8ac80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b284b881b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b284b881988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b284b8807b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpd1f2g7sg                        0x0000559c83de9474 <unavailable> + 5236

    5    libc.so.6                          0x00002b284bd76460 __libc_start_main +
    245

    6    tmpd1f2g7sg                        0x0000559c83de90b9 <unavailable> + 4281

    '
  stdout: ''
  timestamp: 1660014020
- exit_code: 0
  program: "\n/// You're a hungry rabbit, and you already have eaten a certain number\
    \ of carrots,\n/// but now you need to eat more carrots to complete the day's\
    \ meals.\n/// you should return an array of [ total number of eaten carrots after\
    \ your meals,\n/// the number of carrots left after your meals ]\n/// if there\
    \ are not enough remaining carrots, you will eat all remaining carrots, but will\
    \ still be hungry.\n/// Example:\n/// >>> eat(number: 5, need: 6, remaining: 10)\n\
    /// [11, 4]\n/// >>> eat(number: 4, need: 8, remaining: 9)\n/// [12, 1]\n/// >>>\
    \ eat(number: 1, need: 10, remaining: 10)\n/// [11, 0]\n/// >>> eat(number: 2,\
    \ need: 11, remaining: 5)\n/// [7, 0]\n/// Variables:\n/// @number : integer\n\
    /// the number of carrots that you have eaten.\n/// @need : integer\n/// the number\
    \ of carrots that you need to eat.\n/// @remaining : integer\n/// the number of\
    \ remaining carrots thet exist in stock\n/// Constrain:\n/// * 0 <= number <=\
    \ 1000\n/// * 0 <= need <= 1000\n/// * 0 <= remaining <= 1000\n/// Have fun :)\n\
    func eat(number: Int, need: Int, remaining: Int) -> [Int] {\n    let n = number\
    \ + min(need, remaining)\n    let m = max(0, remaining - need)\n    return [n,\
    \ m]\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if\
    \ left.count != right.count {\n        return false\n    }\n    for (l, r) in\
    \ zip(left, right) {\n        if l != r {\n            return false\n        }\n\
    \    }\n    return true\n}\n            \nassert(eat(number: 5, need: 6, remaining:\
    \ 10) == [11, 4])\nassert(eat(number: 4, need: 8, remaining: 9) == [12, 1])\n\
    assert(eat(number: 1, need: 10, remaining: 10) == [11, 0])\nassert(eat(number:\
    \ 2, need: 11, remaining: 5) == [7, 0])\nassert(eat(number: 4, need: 5, remaining:\
    \ 7) == [9, 2])\nassert(eat(number: 4, need: 5, remaining: 1) == [5, 0])"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660014020
- exit_code: -4
  program: "\n/// You're a hungry rabbit, and you already have eaten a certain number\
    \ of carrots,\n/// but now you need to eat more carrots to complete the day's\
    \ meals.\n/// you should return an array of [ total number of eaten carrots after\
    \ your meals,\n/// the number of carrots left after your meals ]\n/// if there\
    \ are not enough remaining carrots, you will eat all remaining carrots, but will\
    \ still be hungry.\n/// Example:\n/// >>> eat(number: 5, need: 6, remaining: 10)\n\
    /// [11, 4]\n/// >>> eat(number: 4, need: 8, remaining: 9)\n/// [12, 1]\n/// >>>\
    \ eat(number: 1, need: 10, remaining: 10)\n/// [11, 0]\n/// >>> eat(number: 2,\
    \ need: 11, remaining: 5)\n/// [7, 0]\n/// Variables:\n/// @number : integer\n\
    /// the number of carrots that you have eaten.\n/// @need : integer\n/// the number\
    \ of carrots that you need to eat.\n/// @remaining : integer\n/// the number of\
    \ remaining carrots thet exist in stock\n/// Constrain:\n/// * 0 <= number <=\
    \ 1000\n/// * 0 <= need <= 1000\n/// * 0 <= remaining <= 1000\n/// Have fun :)\n\
    func eat(number: Int, need: Int, remaining: Int) -> [Int] {\n    var sum = number\
    \ + need\n    var remain = 0\n    if sum > remaining {\n        sum = remaining\n\
    \        remain = 0\n    } else {\n        remain = remaining - sum\n    }\n \
    \   return [sum, remain]\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(eat(number:\
    \ 5, need: 6, remaining: 10) == [11, 4])\nassert(eat(number: 4, need: 8, remaining:\
    \ 9) == [12, 1])\nassert(eat(number: 1, need: 10, remaining: 10) == [11, 0])\n\
    assert(eat(number: 2, need: 11, remaining: 5) == [7, 0])\nassert(eat(number: 4,\
    \ need: 5, remaining: 7) == [9, 2])\nassert(eat(number: 4, need: 5, remaining:\
    \ 1) == [5, 0])"
  status: Exception
  stderr: 'tmpy7smhpim/tmpy7smhpim.swift:53: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b5db8cccc80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b5db89c3b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b5db89c3988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b5db89c27b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpy7smhpim                        0x000055790394c384 <unavailable> + 4996

    5    libc.so.6                          0x00002b5db8eb8460 __libc_start_main +
    245

    6    tmpy7smhpim                        0x000055790394bfc9 <unavailable> + 4041

    '
  stdout: ''
  timestamp: 1660014020
- exit_code: -4
  program: "\n/// You're a hungry rabbit, and you already have eaten a certain number\
    \ of carrots,\n/// but now you need to eat more carrots to complete the day's\
    \ meals.\n/// you should return an array of [ total number of eaten carrots after\
    \ your meals,\n/// the number of carrots left after your meals ]\n/// if there\
    \ are not enough remaining carrots, you will eat all remaining carrots, but will\
    \ still be hungry.\n/// Example:\n/// >>> eat(number: 5, need: 6, remaining: 10)\n\
    /// [11, 4]\n/// >>> eat(number: 4, need: 8, remaining: 9)\n/// [12, 1]\n/// >>>\
    \ eat(number: 1, need: 10, remaining: 10)\n/// [11, 0]\n/// >>> eat(number: 2,\
    \ need: 11, remaining: 5)\n/// [7, 0]\n/// Variables:\n/// @number : integer\n\
    /// the number of carrots that you have eaten.\n/// @need : integer\n/// the number\
    \ of carrots that you need to eat.\n/// @remaining : integer\n/// the number of\
    \ remaining carrots thet exist in stock\n/// Constrain:\n/// * 0 <= number <=\
    \ 1000\n/// * 0 <= need <= 1000\n/// * 0 <= remaining <= 1000\n/// Have fun :)\n\
    func eat(number: Int, need: Int, remaining: Int) -> [Int] {\n    let need_to_eat\
    \ = need - number\n    let carrots_left = (remaining - need_to_eat) > 0 ? (remaining\
    \ - need_to_eat) : 0\n    return [number + need_to_eat, carrots_left]\n}\n\n\n\
    func ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(eat(number: 5, need: 6, remaining: 10) == [11,\
    \ 4])\nassert(eat(number: 4, need: 8, remaining: 9) == [12, 1])\nassert(eat(number:\
    \ 1, need: 10, remaining: 10) == [11, 0])\nassert(eat(number: 2, need: 11, remaining:\
    \ 5) == [7, 0])\nassert(eat(number: 4, need: 5, remaining: 7) == [9, 2])\nassert(eat(number:\
    \ 4, need: 5, remaining: 1) == [5, 0])"
  status: Exception
  stderr: 'tmpawkdttlx/tmpawkdttlx.swift:47: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002acfd8db9c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002acfd8ab0b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002acfd8ab0988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002acfd8aaf7b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpawkdttlx                        0x0000563708095384 <unavailable> + 4996

    5    libc.so.6                          0x00002acfd8fa5460 __libc_start_main +
    245

    6    tmpawkdttlx                        0x0000563708094fc9 <unavailable> + 4041

    '
  stdout: ''
  timestamp: 1660014020
- exit_code: -4
  program: "\n/// You're a hungry rabbit, and you already have eaten a certain number\
    \ of carrots,\n/// but now you need to eat more carrots to complete the day's\
    \ meals.\n/// you should return an array of [ total number of eaten carrots after\
    \ your meals,\n/// the number of carrots left after your meals ]\n/// if there\
    \ are not enough remaining carrots, you will eat all remaining carrots, but will\
    \ still be hungry.\n/// Example:\n/// >>> eat(number: 5, need: 6, remaining: 10)\n\
    /// [11, 4]\n/// >>> eat(number: 4, need: 8, remaining: 9)\n/// [12, 1]\n/// >>>\
    \ eat(number: 1, need: 10, remaining: 10)\n/// [11, 0]\n/// >>> eat(number: 2,\
    \ need: 11, remaining: 5)\n/// [7, 0]\n/// Variables:\n/// @number : integer\n\
    /// the number of carrots that you have eaten.\n/// @need : integer\n/// the number\
    \ of carrots that you need to eat.\n/// @remaining : integer\n/// the number of\
    \ remaining carrots thet exist in stock\n/// Constrain:\n/// * 0 <= number <=\
    \ 1000\n/// * 0 <= need <= 1000\n/// * 0 <= remaining <= 1000\n/// Have fun :)\n\
    func eat(number: Int, need: Int, remaining: Int) -> [Int] {\n    let carrots =\
    \ number + (need - number > remaining ? remaining : need - number)\n    return\
    \ [carrots, remaining - carrots]\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int,\
    \ Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n\
    \    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n          \
    \  return false\n        }\n    }\n    return true\n}\n            \nassert(eat(number:\
    \ 5, need: 6, remaining: 10) == [11, 4])\nassert(eat(number: 4, need: 8, remaining:\
    \ 9) == [12, 1])\nassert(eat(number: 1, need: 10, remaining: 10) == [11, 0])\n\
    assert(eat(number: 2, need: 11, remaining: 5) == [7, 0])\nassert(eat(number: 4,\
    \ need: 5, remaining: 7) == [9, 2])\nassert(eat(number: 4, need: 5, remaining:\
    \ 1) == [5, 0])"
  status: Exception
  stderr: 'tmp1wf7knd7/tmp1wf7knd7.swift:46: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b161b9a1c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b161b698b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b161b698988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b161b6977b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmp1wf7knd7                        0x0000561ecc7ae384 <unavailable> + 4996

    5    libc.so.6                          0x00002b161bb8d460 __libc_start_main +
    245

    6    tmp1wf7knd7                        0x0000561ecc7adfc9 <unavailable> + 4041

    '
  stdout: ''
  timestamp: 1660014020
- exit_code: -4
  program: "\n/// You're a hungry rabbit, and you already have eaten a certain number\
    \ of carrots,\n/// but now you need to eat more carrots to complete the day's\
    \ meals.\n/// you should return an array of [ total number of eaten carrots after\
    \ your meals,\n/// the number of carrots left after your meals ]\n/// if there\
    \ are not enough remaining carrots, you will eat all remaining carrots, but will\
    \ still be hungry.\n/// Example:\n/// >>> eat(number: 5, need: 6, remaining: 10)\n\
    /// [11, 4]\n/// >>> eat(number: 4, need: 8, remaining: 9)\n/// [12, 1]\n/// >>>\
    \ eat(number: 1, need: 10, remaining: 10)\n/// [11, 0]\n/// >>> eat(number: 2,\
    \ need: 11, remaining: 5)\n/// [7, 0]\n/// Variables:\n/// @number : integer\n\
    /// the number of carrots that you have eaten.\n/// @need : integer\n/// the number\
    \ of carrots that you need to eat.\n/// @remaining : integer\n/// the number of\
    \ remaining carrots thet exist in stock\n/// Constrain:\n/// * 0 <= number <=\
    \ 1000\n/// * 0 <= need <= 1000\n/// * 0 <= remaining <= 1000\n/// Have fun :)\n\
    func eat(number: Int, need: Int, remaining: Int) -> [Int] {\n  let carrots = number\
    \ + remaining\n  return carrots >= need ? [need, carrots - need] : [carrots, 0]\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(eat(number: 5, need: 6, remaining: 10) == [11,\
    \ 4])\nassert(eat(number: 4, need: 8, remaining: 9) == [12, 1])\nassert(eat(number:\
    \ 1, need: 10, remaining: 10) == [11, 0])\nassert(eat(number: 2, need: 11, remaining:\
    \ 5) == [7, 0])\nassert(eat(number: 4, need: 5, remaining: 7) == [9, 2])\nassert(eat(number:\
    \ 4, need: 5, remaining: 1) == [5, 0])"
  status: Exception
  stderr: 'tmpwk8foiss/tmpwk8foiss.swift:46: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b601599ac80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b6015691b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b6015691988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b60156907b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpwk8foiss                        0x000055e18dbd9384 <unavailable> + 4996

    5    libc.so.6                          0x00002b6015b86460 __libc_start_main +
    245

    6    tmpwk8foiss                        0x000055e18dbd8fc9 <unavailable> + 4041

    '
  stdout: ''
  timestamp: 1660014020
- exit_code: -4
  program: "\n/// You're a hungry rabbit, and you already have eaten a certain number\
    \ of carrots,\n/// but now you need to eat more carrots to complete the day's\
    \ meals.\n/// you should return an array of [ total number of eaten carrots after\
    \ your meals,\n/// the number of carrots left after your meals ]\n/// if there\
    \ are not enough remaining carrots, you will eat all remaining carrots, but will\
    \ still be hungry.\n/// Example:\n/// >>> eat(number: 5, need: 6, remaining: 10)\n\
    /// [11, 4]\n/// >>> eat(number: 4, need: 8, remaining: 9)\n/// [12, 1]\n/// >>>\
    \ eat(number: 1, need: 10, remaining: 10)\n/// [11, 0]\n/// >>> eat(number: 2,\
    \ need: 11, remaining: 5)\n/// [7, 0]\n/// Variables:\n/// @number : integer\n\
    /// the number of carrots that you have eaten.\n/// @need : integer\n/// the number\
    \ of carrots that you need to eat.\n/// @remaining : integer\n/// the number of\
    \ remaining carrots thet exist in stock\n/// Constrain:\n/// * 0 <= number <=\
    \ 1000\n/// * 0 <= need <= 1000\n/// * 0 <= remaining <= 1000\n/// Have fun :)\n\
    func eat(number: Int, need: Int, remaining: Int) -> [Int] {\n  if number + remaining\
    \ >= need {\n    return [number + remaining, remaining - (need - number)]\n  }\
    \ else {\n    return [number + remaining, 0]\n  }\n}\n\n\nfunc ==(left: [(Int,\
    \ Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n\
    \        return false\n    }\n    for (l, r) in zip(left, right) {\n        if\
    \ l != r {\n            return false\n        }\n    }\n    return true\n}\n \
    \           \nassert(eat(number: 5, need: 6, remaining: 10) == [11, 4])\nassert(eat(number:\
    \ 4, need: 8, remaining: 9) == [12, 1])\nassert(eat(number: 1, need: 10, remaining:\
    \ 10) == [11, 0])\nassert(eat(number: 2, need: 11, remaining: 5) == [7, 0])\n\
    assert(eat(number: 4, need: 5, remaining: 7) == [9, 2])\nassert(eat(number: 4,\
    \ need: 5, remaining: 1) == [5, 0])"
  status: Exception
  stderr: 'tmpqw_l6cuy/tmpqw_l6cuy.swift:49: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b74d0645c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b74d033cb6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b74d033c988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b74d033b7b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpqw_l6cuy                        0x0000563f17e67384 <unavailable> + 4996

    5    libc.so.6                          0x00002b74d0831460 __libc_start_main +
    245

    6    tmpqw_l6cuy                        0x0000563f17e66fc9 <unavailable> + 4041

    '
  stdout: ''
  timestamp: 1660014020
- exit_code: -4
  program: "\n/// You're a hungry rabbit, and you already have eaten a certain number\
    \ of carrots,\n/// but now you need to eat more carrots to complete the day's\
    \ meals.\n/// you should return an array of [ total number of eaten carrots after\
    \ your meals,\n/// the number of carrots left after your meals ]\n/// if there\
    \ are not enough remaining carrots, you will eat all remaining carrots, but will\
    \ still be hungry.\n/// Example:\n/// >>> eat(number: 5, need: 6, remaining: 10)\n\
    /// [11, 4]\n/// >>> eat(number: 4, need: 8, remaining: 9)\n/// [12, 1]\n/// >>>\
    \ eat(number: 1, need: 10, remaining: 10)\n/// [11, 0]\n/// >>> eat(number: 2,\
    \ need: 11, remaining: 5)\n/// [7, 0]\n/// Variables:\n/// @number : integer\n\
    /// the number of carrots that you have eaten.\n/// @need : integer\n/// the number\
    \ of carrots that you need to eat.\n/// @remaining : integer\n/// the number of\
    \ remaining carrots thet exist in stock\n/// Constrain:\n/// * 0 <= number <=\
    \ 1000\n/// * 0 <= need <= 1000\n/// * 0 <= remaining <= 1000\n/// Have fun :)\n\
    func eat(number: Int, need: Int, remaining: Int) -> [Int] {\n    let total = number\
    \ + remaining\n    if total < need {\n        return [total, 0]\n    } else {\n\
    \        return [need, total - need]\n    }\n}\n\n\nfunc ==(left: [(Int, Int)],\
    \ right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n       \
    \ return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r\
    \ {\n            return false\n        }\n    }\n    return true\n}\n        \
    \    \nassert(eat(number: 5, need: 6, remaining: 10) == [11, 4])\nassert(eat(number:\
    \ 4, need: 8, remaining: 9) == [12, 1])\nassert(eat(number: 1, need: 10, remaining:\
    \ 10) == [11, 0])\nassert(eat(number: 2, need: 11, remaining: 5) == [7, 0])\n\
    assert(eat(number: 4, need: 5, remaining: 7) == [9, 2])\nassert(eat(number: 4,\
    \ need: 5, remaining: 1) == [5, 0])"
  status: Exception
  stderr: 'tmp1i4gupyl/tmp1i4gupyl.swift:50: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002ab51efa9c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002ab51eca0b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002ab51eca0988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002ab51ec9f7b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmp1i4gupyl                        0x0000560d117c2384 <unavailable> + 4996

    5    libc.so.6                          0x00002ab51f195460 __libc_start_main +
    245

    6    tmp1i4gupyl                        0x0000560d117c1fc9 <unavailable> + 4041

    '
  stdout: ''
  timestamp: 1660013825
- exit_code: -4
  program: "\n/// You're a hungry rabbit, and you already have eaten a certain number\
    \ of carrots,\n/// but now you need to eat more carrots to complete the day's\
    \ meals.\n/// you should return an array of [ total number of eaten carrots after\
    \ your meals,\n/// the number of carrots left after your meals ]\n/// if there\
    \ are not enough remaining carrots, you will eat all remaining carrots, but will\
    \ still be hungry.\n/// Example:\n/// >>> eat(number: 5, need: 6, remaining: 10)\n\
    /// [11, 4]\n/// >>> eat(number: 4, need: 8, remaining: 9)\n/// [12, 1]\n/// >>>\
    \ eat(number: 1, need: 10, remaining: 10)\n/// [11, 0]\n/// >>> eat(number: 2,\
    \ need: 11, remaining: 5)\n/// [7, 0]\n/// Variables:\n/// @number : integer\n\
    /// the number of carrots that you have eaten.\n/// @need : integer\n/// the number\
    \ of carrots that you need to eat.\n/// @remaining : integer\n/// the number of\
    \ remaining carrots thet exist in stock\n/// Constrain:\n/// * 0 <= number <=\
    \ 1000\n/// * 0 <= need <= 1000\n/// * 0 <= remaining <= 1000\n/// Have fun :)\n\
    func eat(number: Int, need: Int, remaining: Int) -> [Int] {\n  let new = number\
    \ + remaining - need\n  return new < 0 ? [number + remaining, 0] : [number + remaining,\
    \ new]\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n  \
    \  if left.count != right.count {\n        return false\n    }\n    for (l, r)\
    \ in zip(left, right) {\n        if l != r {\n            return false\n     \
    \   }\n    }\n    return true\n}\n            \nassert(eat(number: 5, need: 6,\
    \ remaining: 10) == [11, 4])\nassert(eat(number: 4, need: 8, remaining: 9) ==\
    \ [12, 1])\nassert(eat(number: 1, need: 10, remaining: 10) == [11, 0])\nassert(eat(number:\
    \ 2, need: 11, remaining: 5) == [7, 0])\nassert(eat(number: 4, need: 5, remaining:\
    \ 7) == [9, 2])\nassert(eat(number: 4, need: 5, remaining: 1) == [5, 0])"
  status: Exception
  stderr: 'tmpvr5u5gj0/tmpvr5u5gj0.swift:46: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002aeb08360c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002aeb08057b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002aeb08057988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002aeb080567b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpvr5u5gj0                        0x000055c609caf384 <unavailable> + 4996

    5    libc.so.6                          0x00002aeb0854c460 __libc_start_main +
    245

    6    tmpvr5u5gj0                        0x000055c609caefc9 <unavailable> + 4041

    '
  stdout: ''
  timestamp: 1660014020
- exit_code: 0
  program: "\n/// You're a hungry rabbit, and you already have eaten a certain number\
    \ of carrots,\n/// but now you need to eat more carrots to complete the day's\
    \ meals.\n/// you should return an array of [ total number of eaten carrots after\
    \ your meals,\n/// the number of carrots left after your meals ]\n/// if there\
    \ are not enough remaining carrots, you will eat all remaining carrots, but will\
    \ still be hungry.\n/// Example:\n/// >>> eat(number: 5, need: 6, remaining: 10)\n\
    /// [11, 4]\n/// >>> eat(number: 4, need: 8, remaining: 9)\n/// [12, 1]\n/// >>>\
    \ eat(number: 1, need: 10, remaining: 10)\n/// [11, 0]\n/// >>> eat(number: 2,\
    \ need: 11, remaining: 5)\n/// [7, 0]\n/// Variables:\n/// @number : integer\n\
    /// the number of carrots that you have eaten.\n/// @need : integer\n/// the number\
    \ of carrots that you need to eat.\n/// @remaining : integer\n/// the number of\
    \ remaining carrots thet exist in stock\n/// Constrain:\n/// * 0 <= number <=\
    \ 1000\n/// * 0 <= need <= 1000\n/// * 0 <= remaining <= 1000\n/// Have fun :)\n\
    func eat(number: Int, need: Int, remaining: Int) -> [Int] {\n    var numberOfCarrotsEaten\
    \ = number + min(need, remaining)\n    var remainingCarrots = remaining - min(need,\
    \ remaining)\n    return [numberOfCarrotsEaten, remainingCarrots]\n}\n\n\nfunc\
    \ ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count !=\
    \ right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(eat(number: 5, need: 6, remaining: 10) == [11,\
    \ 4])\nassert(eat(number: 4, need: 8, remaining: 9) == [12, 1])\nassert(eat(number:\
    \ 1, need: 10, remaining: 10) == [11, 0])\nassert(eat(number: 2, need: 11, remaining:\
    \ 5) == [7, 0])\nassert(eat(number: 4, need: 5, remaining: 7) == [9, 2])\nassert(eat(number:\
    \ 4, need: 5, remaining: 1) == [5, 0])"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660014020
- exit_code: 0
  program: "\n/// You're a hungry rabbit, and you already have eaten a certain number\
    \ of carrots,\n/// but now you need to eat more carrots to complete the day's\
    \ meals.\n/// you should return an array of [ total number of eaten carrots after\
    \ your meals,\n/// the number of carrots left after your meals ]\n/// if there\
    \ are not enough remaining carrots, you will eat all remaining carrots, but will\
    \ still be hungry.\n/// Example:\n/// >>> eat(number: 5, need: 6, remaining: 10)\n\
    /// [11, 4]\n/// >>> eat(number: 4, need: 8, remaining: 9)\n/// [12, 1]\n/// >>>\
    \ eat(number: 1, need: 10, remaining: 10)\n/// [11, 0]\n/// >>> eat(number: 2,\
    \ need: 11, remaining: 5)\n/// [7, 0]\n/// Variables:\n/// @number : integer\n\
    /// the number of carrots that you have eaten.\n/// @need : integer\n/// the number\
    \ of carrots that you need to eat.\n/// @remaining : integer\n/// the number of\
    \ remaining carrots thet exist in stock\n/// Constrain:\n/// * 0 <= number <=\
    \ 1000\n/// * 0 <= need <= 1000\n/// * 0 <= remaining <= 1000\n/// Have fun :)\n\
    func eat(number: Int, need: Int, remaining: Int) -> [Int] {\n    return [number\
    \ + min(need, remaining), max(0, remaining - need)]\n}\n\n\nfunc ==(left: [(Int,\
    \ Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n\
    \        return false\n    }\n    for (l, r) in zip(left, right) {\n        if\
    \ l != r {\n            return false\n        }\n    }\n    return true\n}\n \
    \           \nassert(eat(number: 5, need: 6, remaining: 10) == [11, 4])\nassert(eat(number:\
    \ 4, need: 8, remaining: 9) == [12, 1])\nassert(eat(number: 1, need: 10, remaining:\
    \ 10) == [11, 0])\nassert(eat(number: 2, need: 11, remaining: 5) == [7, 0])\n\
    assert(eat(number: 4, need: 5, remaining: 7) == [9, 2])\nassert(eat(number: 4,\
    \ need: 5, remaining: 1) == [5, 0])"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660013824
- exit_code: -4
  program: "\n/// You're a hungry rabbit, and you already have eaten a certain number\
    \ of carrots,\n/// but now you need to eat more carrots to complete the day's\
    \ meals.\n/// you should return an array of [ total number of eaten carrots after\
    \ your meals,\n/// the number of carrots left after your meals ]\n/// if there\
    \ are not enough remaining carrots, you will eat all remaining carrots, but will\
    \ still be hungry.\n/// Example:\n/// >>> eat(number: 5, need: 6, remaining: 10)\n\
    /// [11, 4]\n/// >>> eat(number: 4, need: 8, remaining: 9)\n/// [12, 1]\n/// >>>\
    \ eat(number: 1, need: 10, remaining: 10)\n/// [11, 0]\n/// >>> eat(number: 2,\
    \ need: 11, remaining: 5)\n/// [7, 0]\n/// Variables:\n/// @number : integer\n\
    /// the number of carrots that you have eaten.\n/// @need : integer\n/// the number\
    \ of carrots that you need to eat.\n/// @remaining : integer\n/// the number of\
    \ remaining carrots thet exist in stock\n/// Constrain:\n/// * 0 <= number <=\
    \ 1000\n/// * 0 <= need <= 1000\n/// * 0 <= remaining <= 1000\n/// Have fun :)\n\
    func eat(number: Int, need: Int, remaining: Int) -> [Int] {\n    return [0, 0]\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(eat(number: 5, need: 6, remaining: 10) == [11,\
    \ 4])\nassert(eat(number: 4, need: 8, remaining: 9) == [12, 1])\nassert(eat(number:\
    \ 1, need: 10, remaining: 10) == [11, 0])\nassert(eat(number: 2, need: 11, remaining:\
    \ 5) == [7, 0])\nassert(eat(number: 4, need: 5, remaining: 7) == [9, 2])\nassert(eat(number:\
    \ 4, need: 5, remaining: 1) == [5, 0])"
  status: Exception
  stderr: 'tmpes0rme1m/tmpes0rme1m.swift:45: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002ab15656fc80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002ab156266b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002ab156266988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002ab1562657b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpes0rme1m                        0x000055d20b065384 <unavailable> + 4996

    5    libc.so.6                          0x00002ab15675b460 __libc_start_main +
    245

    6    tmpes0rme1m                        0x000055d20b064fc9 <unavailable> + 4041

    '
  stdout: ''
  timestamp: 1660014019
- exit_code: 0
  program: "\n/// You're a hungry rabbit, and you already have eaten a certain number\
    \ of carrots,\n/// but now you need to eat more carrots to complete the day's\
    \ meals.\n/// you should return an array of [ total number of eaten carrots after\
    \ your meals,\n/// the number of carrots left after your meals ]\n/// if there\
    \ are not enough remaining carrots, you will eat all remaining carrots, but will\
    \ still be hungry.\n/// Example:\n/// >>> eat(number: 5, need: 6, remaining: 10)\n\
    /// [11, 4]\n/// >>> eat(number: 4, need: 8, remaining: 9)\n/// [12, 1]\n/// >>>\
    \ eat(number: 1, need: 10, remaining: 10)\n/// [11, 0]\n/// >>> eat(number: 2,\
    \ need: 11, remaining: 5)\n/// [7, 0]\n/// Variables:\n/// @number : integer\n\
    /// the number of carrots that you have eaten.\n/// @need : integer\n/// the number\
    \ of carrots that you need to eat.\n/// @remaining : integer\n/// the number of\
    \ remaining carrots thet exist in stock\n/// Constrain:\n/// * 0 <= number <=\
    \ 1000\n/// * 0 <= need <= 1000\n/// * 0 <= remaining <= 1000\n/// Have fun :)\n\
    func eat(number: Int, need: Int, remaining: Int) -> [Int] {\n    let eaten = number\
    \ + min(need, remaining)\n    let left = max(0, remaining - need)\n    return\
    \ [eaten, left]\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool\
    \ {\n    if left.count != right.count {\n        return false\n    }\n    for\
    \ (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(eat(number: 5, need:\
    \ 6, remaining: 10) == [11, 4])\nassert(eat(number: 4, need: 8, remaining: 9)\
    \ == [12, 1])\nassert(eat(number: 1, need: 10, remaining: 10) == [11, 0])\nassert(eat(number:\
    \ 2, need: 11, remaining: 5) == [7, 0])\nassert(eat(number: 4, need: 5, remaining:\
    \ 7) == [9, 2])\nassert(eat(number: 4, need: 5, remaining: 1) == [5, 0])"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660013824
- exit_code: -4
  program: "\n/// You're a hungry rabbit, and you already have eaten a certain number\
    \ of carrots,\n/// but now you need to eat more carrots to complete the day's\
    \ meals.\n/// you should return an array of [ total number of eaten carrots after\
    \ your meals,\n/// the number of carrots left after your meals ]\n/// if there\
    \ are not enough remaining carrots, you will eat all remaining carrots, but will\
    \ still be hungry.\n/// Example:\n/// >>> eat(number: 5, need: 6, remaining: 10)\n\
    /// [11, 4]\n/// >>> eat(number: 4, need: 8, remaining: 9)\n/// [12, 1]\n/// >>>\
    \ eat(number: 1, need: 10, remaining: 10)\n/// [11, 0]\n/// >>> eat(number: 2,\
    \ need: 11, remaining: 5)\n/// [7, 0]\n/// Variables:\n/// @number : integer\n\
    /// the number of carrots that you have eaten.\n/// @need : integer\n/// the number\
    \ of carrots that you need to eat.\n/// @remaining : integer\n/// the number of\
    \ remaining carrots thet exist in stock\n/// Constrain:\n/// * 0 <= number <=\
    \ 1000\n/// * 0 <= need <= 1000\n/// * 0 <= remaining <= 1000\n/// Have fun :)\n\
    func eat(number: Int, need: Int, remaining: Int) -> [Int] {\n    var result =\
    \ [number, remaining]\n    let need = need - number\n    let remaining = result[1]\
    \ - need\n    if remaining > 0 {\n        result[0] += need\n        result[1]\
    \ = remaining\n    } else {\n        result[0] += result[1]\n        result[1]\
    \ = 0\n    }\n    return result\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int,\
    \ Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n\
    \    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n          \
    \  return false\n        }\n    }\n    return true\n}\n            \nassert(eat(number:\
    \ 5, need: 6, remaining: 10) == [11, 4])\nassert(eat(number: 4, need: 8, remaining:\
    \ 9) == [12, 1])\nassert(eat(number: 1, need: 10, remaining: 10) == [11, 0])\n\
    assert(eat(number: 2, need: 11, remaining: 5) == [7, 0])\nassert(eat(number: 4,\
    \ need: 5, remaining: 7) == [9, 2])\nassert(eat(number: 4, need: 5, remaining:\
    \ 1) == [5, 0])"
  status: Exception
  stderr: 'tmpovd7de0h/tmpovd7de0h.swift:55: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b1635d9ec80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b1635a95b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b1635a95988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b1635a947b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpovd7de0h                        0x00005558beceb434 <unavailable> + 5172

    5    libc.so.6                          0x00002b1635f8a460 __libc_start_main +
    245

    6    tmpovd7de0h                        0x00005558beceb079 <unavailable> + 4217

    '
  stdout: ''
  timestamp: 1660014020
- exit_code: -4
  program: "\n/// You're a hungry rabbit, and you already have eaten a certain number\
    \ of carrots,\n/// but now you need to eat more carrots to complete the day's\
    \ meals.\n/// you should return an array of [ total number of eaten carrots after\
    \ your meals,\n/// the number of carrots left after your meals ]\n/// if there\
    \ are not enough remaining carrots, you will eat all remaining carrots, but will\
    \ still be hungry.\n/// Example:\n/// >>> eat(number: 5, need: 6, remaining: 10)\n\
    /// [11, 4]\n/// >>> eat(number: 4, need: 8, remaining: 9)\n/// [12, 1]\n/// >>>\
    \ eat(number: 1, need: 10, remaining: 10)\n/// [11, 0]\n/// >>> eat(number: 2,\
    \ need: 11, remaining: 5)\n/// [7, 0]\n/// Variables:\n/// @number : integer\n\
    /// the number of carrots that you have eaten.\n/// @need : integer\n/// the number\
    \ of carrots that you need to eat.\n/// @remaining : integer\n/// the number of\
    \ remaining carrots thet exist in stock\n/// Constrain:\n/// * 0 <= number <=\
    \ 1000\n/// * 0 <= need <= 1000\n/// * 0 <= remaining <= 1000\n/// Have fun :)\n\
    func eat(number: Int, need: Int, remaining: Int) -> [Int] {\n    if number >=\
    \ need {\n        return [number, remaining]\n    }\n    if number < need {\n\
    \        if need - number <= remaining {\n            return [need, remaining\
    \ - (need - number)]\n        } else {\n            return [number + remaining,\
    \ 0]\n        }\n    }\n    return [0, 0]\n}\n\n\nfunc ==(left: [(Int, Int)],\
    \ right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n       \
    \ return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r\
    \ {\n            return false\n        }\n    }\n    return true\n}\n        \
    \    \nassert(eat(number: 5, need: 6, remaining: 10) == [11, 4])\nassert(eat(number:\
    \ 4, need: 8, remaining: 9) == [12, 1])\nassert(eat(number: 1, need: 10, remaining:\
    \ 10) == [11, 0])\nassert(eat(number: 2, need: 11, remaining: 5) == [7, 0])\n\
    assert(eat(number: 4, need: 5, remaining: 7) == [9, 2])\nassert(eat(number: 4,\
    \ need: 5, remaining: 1) == [5, 0])"
  status: Exception
  stderr: 'tmpalm5umvy/tmpalm5umvy.swift:55: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002ab0ee08bc80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002ab0edd82b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002ab0edd82988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002ab0edd817b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpalm5umvy                        0x00005630c9977384 <unavailable> + 4996

    5    libc.so.6                          0x00002ab0ee277460 __libc_start_main +
    245

    6    tmpalm5umvy                        0x00005630c9976fc9 <unavailable> + 4041

    '
  stdout: ''
  timestamp: 1660014020
- exit_code: -4
  program: "\n/// You're a hungry rabbit, and you already have eaten a certain number\
    \ of carrots,\n/// but now you need to eat more carrots to complete the day's\
    \ meals.\n/// you should return an array of [ total number of eaten carrots after\
    \ your meals,\n/// the number of carrots left after your meals ]\n/// if there\
    \ are not enough remaining carrots, you will eat all remaining carrots, but will\
    \ still be hungry.\n/// Example:\n/// >>> eat(number: 5, need: 6, remaining: 10)\n\
    /// [11, 4]\n/// >>> eat(number: 4, need: 8, remaining: 9)\n/// [12, 1]\n/// >>>\
    \ eat(number: 1, need: 10, remaining: 10)\n/// [11, 0]\n/// >>> eat(number: 2,\
    \ need: 11, remaining: 5)\n/// [7, 0]\n/// Variables:\n/// @number : integer\n\
    /// the number of carrots that you have eaten.\n/// @need : integer\n/// the number\
    \ of carrots that you need to eat.\n/// @remaining : integer\n/// the number of\
    \ remaining carrots thet exist in stock\n/// Constrain:\n/// * 0 <= number <=\
    \ 1000\n/// * 0 <= need <= 1000\n/// * 0 <= remaining <= 1000\n/// Have fun :)\n\
    func eat(number: Int, need: Int, remaining: Int) -> [Int] {\n    var result =\
    \ [Int]()\n    var summ = number + remaining\n    if summ < need {\n        result.append(summ)\n\
    \        result.append(0)\n    } else {\n        result.append(need)\n       \
    \ result.append(summ - need)\n    }\n    return result\n}\n\n\nfunc ==(left: [(Int,\
    \ Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n\
    \        return false\n    }\n    for (l, r) in zip(left, right) {\n        if\
    \ l != r {\n            return false\n        }\n    }\n    return true\n}\n \
    \           \nassert(eat(number: 5, need: 6, remaining: 10) == [11, 4])\nassert(eat(number:\
    \ 4, need: 8, remaining: 9) == [12, 1])\nassert(eat(number: 1, need: 10, remaining:\
    \ 10) == [11, 0])\nassert(eat(number: 2, need: 11, remaining: 5) == [7, 0])\n\
    assert(eat(number: 4, need: 5, remaining: 7) == [9, 2])\nassert(eat(number: 4,\
    \ need: 5, remaining: 1) == [5, 0])"
  status: Exception
  stderr: 'tmp_zfal9hk/tmp_zfal9hk.swift:54: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b70a23bdc80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b70a20b4b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b70a20b4988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b70a20b37b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmp_zfal9hk                        0x000055c58cea1444 <unavailable> + 5188

    5    libc.so.6                          0x00002b70a25a9460 __libc_start_main +
    245

    6    tmp_zfal9hk                        0x000055c58cea1089 <unavailable> + 4233

    '
  stdout: ''
  timestamp: 1660014020
- exit_code: -4
  program: "\n/// You're a hungry rabbit, and you already have eaten a certain number\
    \ of carrots,\n/// but now you need to eat more carrots to complete the day's\
    \ meals.\n/// you should return an array of [ total number of eaten carrots after\
    \ your meals,\n/// the number of carrots left after your meals ]\n/// if there\
    \ are not enough remaining carrots, you will eat all remaining carrots, but will\
    \ still be hungry.\n/// Example:\n/// >>> eat(number: 5, need: 6, remaining: 10)\n\
    /// [11, 4]\n/// >>> eat(number: 4, need: 8, remaining: 9)\n/// [12, 1]\n/// >>>\
    \ eat(number: 1, need: 10, remaining: 10)\n/// [11, 0]\n/// >>> eat(number: 2,\
    \ need: 11, remaining: 5)\n/// [7, 0]\n/// Variables:\n/// @number : integer\n\
    /// the number of carrots that you have eaten.\n/// @need : integer\n/// the number\
    \ of carrots that you need to eat.\n/// @remaining : integer\n/// the number of\
    \ remaining carrots thet exist in stock\n/// Constrain:\n/// * 0 <= number <=\
    \ 1000\n/// * 0 <= need <= 1000\n/// * 0 <= remaining <= 1000\n/// Have fun :)\n\
    func eat(number: Int, need: Int, remaining: Int) -> [Int] {\n    var result =\
    \ Array(repeating: 0, count: 2)\n    if number < 0 || need < 0 || remaining <\
    \ 0 {\n        return result\n    }\n    if number > 1000 || need > 1000 || remaining\
    \ > 1000 {\n        return result\n    }\n    result[0] = number + need > remaining\
    \ ? remaining : number + need\n    result[1] = number + need > remaining ? 0 :\
    \ remaining - need\n    return result\n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(eat(number: 5, need: 6, remaining: 10) == [11, 4])\nassert(eat(number:\
    \ 4, need: 8, remaining: 9) == [12, 1])\nassert(eat(number: 1, need: 10, remaining:\
    \ 10) == [11, 0])\nassert(eat(number: 2, need: 11, remaining: 5) == [7, 0])\n\
    assert(eat(number: 4, need: 5, remaining: 7) == [9, 2])\nassert(eat(number: 4,\
    \ need: 5, remaining: 1) == [5, 0])"
  status: Exception
  stderr: 'tmp01vu612a/tmp01vu612a.swift:54: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b19fd072c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b19fcd69b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b19fcd69988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b19fcd687b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmp01vu612a                        0x000055f45681c454 <unavailable> + 5204

    5    libc.so.6                          0x00002b19fd25e460 __libc_start_main +
    245

    6    tmp01vu612a                        0x000055f45681c099 <unavailable> + 4249

    '
  stdout: ''
  timestamp: 1660014020
- exit_code: -4
  program: "\n/// You're a hungry rabbit, and you already have eaten a certain number\
    \ of carrots,\n/// but now you need to eat more carrots to complete the day's\
    \ meals.\n/// you should return an array of [ total number of eaten carrots after\
    \ your meals,\n/// the number of carrots left after your meals ]\n/// if there\
    \ are not enough remaining carrots, you will eat all remaining carrots, but will\
    \ still be hungry.\n/// Example:\n/// >>> eat(number: 5, need: 6, remaining: 10)\n\
    /// [11, 4]\n/// >>> eat(number: 4, need: 8, remaining: 9)\n/// [12, 1]\n/// >>>\
    \ eat(number: 1, need: 10, remaining: 10)\n/// [11, 0]\n/// >>> eat(number: 2,\
    \ need: 11, remaining: 5)\n/// [7, 0]\n/// Variables:\n/// @number : integer\n\
    /// the number of carrots that you have eaten.\n/// @need : integer\n/// the number\
    \ of carrots that you need to eat.\n/// @remaining : integer\n/// the number of\
    \ remaining carrots thet exist in stock\n/// Constrain:\n/// * 0 <= number <=\
    \ 1000\n/// * 0 <= need <= 1000\n/// * 0 <= remaining <= 1000\n/// Have fun :)\n\
    func eat(number: Int, need: Int, remaining: Int) -> [Int] {\n    var leftover\
    \ = remaining - need\n    if leftover < 0 {\n        leftover = 0\n    }\n   \
    \ return [number + need, leftover]\n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(eat(number: 5, need: 6, remaining: 10) == [11, 4])\nassert(eat(number:\
    \ 4, need: 8, remaining: 9) == [12, 1])\nassert(eat(number: 1, need: 10, remaining:\
    \ 10) == [11, 0])\nassert(eat(number: 2, need: 11, remaining: 5) == [7, 0])\n\
    assert(eat(number: 4, need: 5, remaining: 7) == [9, 2])\nassert(eat(number: 4,\
    \ need: 5, remaining: 1) == [5, 0])"
  status: Exception
  stderr: 'tmp3yeoogq5/tmp3yeoogq5.swift:52: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b4a9e64dc80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b4a9e344b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b4a9e344988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b4a9e3437b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmp3yeoogq5                        0x000055b67e902658 <unavailable> + 5720

    5    libc.so.6                          0x00002b4a9e839460 __libc_start_main +
    245

    6    tmp3yeoogq5                        0x000055b67e901fc9 <unavailable> + 4041

    '
  stdout: ''
  timestamp: 1660014020
- exit_code: 0
  program: "\n/// You're a hungry rabbit, and you already have eaten a certain number\
    \ of carrots,\n/// but now you need to eat more carrots to complete the day's\
    \ meals.\n/// you should return an array of [ total number of eaten carrots after\
    \ your meals,\n/// the number of carrots left after your meals ]\n/// if there\
    \ are not enough remaining carrots, you will eat all remaining carrots, but will\
    \ still be hungry.\n/// Example:\n/// >>> eat(number: 5, need: 6, remaining: 10)\n\
    /// [11, 4]\n/// >>> eat(number: 4, need: 8, remaining: 9)\n/// [12, 1]\n/// >>>\
    \ eat(number: 1, need: 10, remaining: 10)\n/// [11, 0]\n/// >>> eat(number: 2,\
    \ need: 11, remaining: 5)\n/// [7, 0]\n/// Variables:\n/// @number : integer\n\
    /// the number of carrots that you have eaten.\n/// @need : integer\n/// the number\
    \ of carrots that you need to eat.\n/// @remaining : integer\n/// the number of\
    \ remaining carrots thet exist in stock\n/// Constrain:\n/// * 0 <= number <=\
    \ 1000\n/// * 0 <= need <= 1000\n/// * 0 <= remaining <= 1000\n/// Have fun :)\n\
    func eat(number: Int, need: Int, remaining: Int) -> [Int] {\n    return [number\
    \ + min(need, remaining), max(0, remaining - need)]\n}\n\n\nfunc ==(left: [(Int,\
    \ Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n\
    \        return false\n    }\n    for (l, r) in zip(left, right) {\n        if\
    \ l != r {\n            return false\n        }\n    }\n    return true\n}\n \
    \           \nassert(eat(number: 5, need: 6, remaining: 10) == [11, 4])\nassert(eat(number:\
    \ 4, need: 8, remaining: 9) == [12, 1])\nassert(eat(number: 1, need: 10, remaining:\
    \ 10) == [11, 0])\nassert(eat(number: 2, need: 11, remaining: 5) == [7, 0])\n\
    assert(eat(number: 4, need: 5, remaining: 7) == [9, 2])\nassert(eat(number: 4,\
    \ need: 5, remaining: 1) == [5, 0])"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660013824
- exit_code: -4
  program: "\n/// You're a hungry rabbit, and you already have eaten a certain number\
    \ of carrots,\n/// but now you need to eat more carrots to complete the day's\
    \ meals.\n/// you should return an array of [ total number of eaten carrots after\
    \ your meals,\n/// the number of carrots left after your meals ]\n/// if there\
    \ are not enough remaining carrots, you will eat all remaining carrots, but will\
    \ still be hungry.\n/// Example:\n/// >>> eat(number: 5, need: 6, remaining: 10)\n\
    /// [11, 4]\n/// >>> eat(number: 4, need: 8, remaining: 9)\n/// [12, 1]\n/// >>>\
    \ eat(number: 1, need: 10, remaining: 10)\n/// [11, 0]\n/// >>> eat(number: 2,\
    \ need: 11, remaining: 5)\n/// [7, 0]\n/// Variables:\n/// @number : integer\n\
    /// the number of carrots that you have eaten.\n/// @need : integer\n/// the number\
    \ of carrots that you need to eat.\n/// @remaining : integer\n/// the number of\
    \ remaining carrots thet exist in stock\n/// Constrain:\n/// * 0 <= number <=\
    \ 1000\n/// * 0 <= need <= 1000\n/// * 0 <= remaining <= 1000\n/// Have fun :)\n\
    func eat(number: Int, need: Int, remaining: Int) -> [Int] {\n    let eatenCarrots\
    \ = number + need\n    let carrotsLeft = eatenCarrots > remaining ? 0 : remaining\
    \ - eatenCarrots\n    return [eatenCarrots, carrotsLeft]\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(eat(number: 5, need: 6, remaining: 10) == [11, 4])\nassert(eat(number:\
    \ 4, need: 8, remaining: 9) == [12, 1])\nassert(eat(number: 1, need: 10, remaining:\
    \ 10) == [11, 0])\nassert(eat(number: 2, need: 11, remaining: 5) == [7, 0])\n\
    assert(eat(number: 4, need: 5, remaining: 7) == [9, 2])\nassert(eat(number: 4,\
    \ need: 5, remaining: 1) == [5, 0])"
  status: Exception
  stderr: 'tmpa8d7430f/tmpa8d7430f.swift:47: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b24faf16c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b24fac0db6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b24fac0d988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b24fac0c7b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpa8d7430f                        0x0000562b3eeec384 <unavailable> + 4996

    5    libc.so.6                          0x00002b24fb102460 __libc_start_main +
    245

    6    tmpa8d7430f                        0x0000562b3eeebfc9 <unavailable> + 4041

    '
  stdout: ''
  timestamp: 1660014020
- exit_code: -4
  program: "\n/// You're a hungry rabbit, and you already have eaten a certain number\
    \ of carrots,\n/// but now you need to eat more carrots to complete the day's\
    \ meals.\n/// you should return an array of [ total number of eaten carrots after\
    \ your meals,\n/// the number of carrots left after your meals ]\n/// if there\
    \ are not enough remaining carrots, you will eat all remaining carrots, but will\
    \ still be hungry.\n/// Example:\n/// >>> eat(number: 5, need: 6, remaining: 10)\n\
    /// [11, 4]\n/// >>> eat(number: 4, need: 8, remaining: 9)\n/// [12, 1]\n/// >>>\
    \ eat(number: 1, need: 10, remaining: 10)\n/// [11, 0]\n/// >>> eat(number: 2,\
    \ need: 11, remaining: 5)\n/// [7, 0]\n/// Variables:\n/// @number : integer\n\
    /// the number of carrots that you have eaten.\n/// @need : integer\n/// the number\
    \ of carrots that you need to eat.\n/// @remaining : integer\n/// the number of\
    \ remaining carrots thet exist in stock\n/// Constrain:\n/// * 0 <= number <=\
    \ 1000\n/// * 0 <= need <= 1000\n/// * 0 <= remaining <= 1000\n/// Have fun :)\n\
    func eat(number: Int, need: Int, remaining: Int) -> [Int] {\n    var add = need\
    \ - number\n    if remaining < add {\n        add = remaining\n    }\n    return\
    \ [number + add, remaining - add]\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int,\
    \ Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n\
    \    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n          \
    \  return false\n        }\n    }\n    return true\n}\n            \nassert(eat(number:\
    \ 5, need: 6, remaining: 10) == [11, 4])\nassert(eat(number: 4, need: 8, remaining:\
    \ 9) == [12, 1])\nassert(eat(number: 1, need: 10, remaining: 10) == [11, 0])\n\
    assert(eat(number: 2, need: 11, remaining: 5) == [7, 0])\nassert(eat(number: 4,\
    \ need: 5, remaining: 7) == [9, 2])\nassert(eat(number: 4, need: 5, remaining:\
    \ 1) == [5, 0])"
  status: Exception
  stderr: 'tmpaj8_f772/tmpaj8_f772.swift:49: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b9844967c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b984465eb6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b984465e988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b984465d7b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpaj8_f772                        0x0000560003031384 <unavailable> + 4996

    5    libc.so.6                          0x00002b9844b53460 __libc_start_main +
    245

    6    tmpaj8_f772                        0x0000560003030fc9 <unavailable> + 4041

    '
  stdout: ''
  timestamp: 1660014020
- exit_code: 0
  program: "\n/// You're a hungry rabbit, and you already have eaten a certain number\
    \ of carrots,\n/// but now you need to eat more carrots to complete the day's\
    \ meals.\n/// you should return an array of [ total number of eaten carrots after\
    \ your meals,\n/// the number of carrots left after your meals ]\n/// if there\
    \ are not enough remaining carrots, you will eat all remaining carrots, but will\
    \ still be hungry.\n/// Example:\n/// >>> eat(number: 5, need: 6, remaining: 10)\n\
    /// [11, 4]\n/// >>> eat(number: 4, need: 8, remaining: 9)\n/// [12, 1]\n/// >>>\
    \ eat(number: 1, need: 10, remaining: 10)\n/// [11, 0]\n/// >>> eat(number: 2,\
    \ need: 11, remaining: 5)\n/// [7, 0]\n/// Variables:\n/// @number : integer\n\
    /// the number of carrots that you have eaten.\n/// @need : integer\n/// the number\
    \ of carrots that you need to eat.\n/// @remaining : integer\n/// the number of\
    \ remaining carrots thet exist in stock\n/// Constrain:\n/// * 0 <= number <=\
    \ 1000\n/// * 0 <= need <= 1000\n/// * 0 <= remaining <= 1000\n/// Have fun :)\n\
    func eat(number: Int, need: Int, remaining: Int) -> [Int] {\n    \n    // Validate\
    \ input\n    guard number >= 0, number <= 1000 else { return [0, remaining] }\n\
    \    guard need >= 0, need <= 1000 else { return [0, remaining] }\n    guard remaining\
    \ >= 0, remaining <= 1000 else { return [0, remaining] }\n    \n    // Test all\
    \ permutations\n    var r: [Int] = []\n    r.append(number + min(need, remaining))\n\
    \    r.append(max(remaining - need, 0))\n    return r\n}\n\n\nfunc ==(left: [(Int,\
    \ Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n\
    \        return false\n    }\n    for (l, r) in zip(left, right) {\n        if\
    \ l != r {\n            return false\n        }\n    }\n    return true\n}\n \
    \           \nassert(eat(number: 5, need: 6, remaining: 10) == [11, 4])\nassert(eat(number:\
    \ 4, need: 8, remaining: 9) == [12, 1])\nassert(eat(number: 1, need: 10, remaining:\
    \ 10) == [11, 0])\nassert(eat(number: 2, need: 11, remaining: 5) == [7, 0])\n\
    assert(eat(number: 4, need: 5, remaining: 7) == [9, 2])\nassert(eat(number: 4,\
    \ need: 5, remaining: 1) == [5, 0])"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660014020
- exit_code: -4
  program: "\n/// You're a hungry rabbit, and you already have eaten a certain number\
    \ of carrots,\n/// but now you need to eat more carrots to complete the day's\
    \ meals.\n/// you should return an array of [ total number of eaten carrots after\
    \ your meals,\n/// the number of carrots left after your meals ]\n/// if there\
    \ are not enough remaining carrots, you will eat all remaining carrots, but will\
    \ still be hungry.\n/// Example:\n/// >>> eat(number: 5, need: 6, remaining: 10)\n\
    /// [11, 4]\n/// >>> eat(number: 4, need: 8, remaining: 9)\n/// [12, 1]\n/// >>>\
    \ eat(number: 1, need: 10, remaining: 10)\n/// [11, 0]\n/// >>> eat(number: 2,\
    \ need: 11, remaining: 5)\n/// [7, 0]\n/// Variables:\n/// @number : integer\n\
    /// the number of carrots that you have eaten.\n/// @need : integer\n/// the number\
    \ of carrots that you need to eat.\n/// @remaining : integer\n/// the number of\
    \ remaining carrots thet exist in stock\n/// Constrain:\n/// * 0 <= number <=\
    \ 1000\n/// * 0 <= need <= 1000\n/// * 0 <= remaining <= 1000\n/// Have fun :)\n\
    func eat(number: Int, need: Int, remaining: Int) -> [Int] {\n    if number ==\
    \ need {\n        return [number, remaining]\n    }\n    if number > need {\n\
    \        return [need, remaining + number - need]\n    }\n    if number + remaining\
    \ >= need {\n        return [need, remaining - need + number]\n    }\n    return\
    \ [number + remaining, 0]\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(eat(number:\
    \ 5, need: 6, remaining: 10) == [11, 4])\nassert(eat(number: 4, need: 8, remaining:\
    \ 9) == [12, 1])\nassert(eat(number: 1, need: 10, remaining: 10) == [11, 0])\n\
    assert(eat(number: 2, need: 11, remaining: 5) == [7, 0])\nassert(eat(number: 4,\
    \ need: 5, remaining: 7) == [9, 2])\nassert(eat(number: 4, need: 5, remaining:\
    \ 1) == [5, 0])"
  status: Exception
  stderr: 'tmp1k0rnjyo/tmp1k0rnjyo.swift:54: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b875ea2ec80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b875e725b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b875e725988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b875e7247b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmp1k0rnjyo                        0x00005568593c3384 <unavailable> + 4996

    5    libc.so.6                          0x00002b875ec1a460 __libc_start_main +
    245

    6    tmp1k0rnjyo                        0x00005568593c2fc9 <unavailable> + 4041

    '
  stdout: ''
  timestamp: 1660014020
- exit_code: -4
  program: "\n/// You're a hungry rabbit, and you already have eaten a certain number\
    \ of carrots,\n/// but now you need to eat more carrots to complete the day's\
    \ meals.\n/// you should return an array of [ total number of eaten carrots after\
    \ your meals,\n/// the number of carrots left after your meals ]\n/// if there\
    \ are not enough remaining carrots, you will eat all remaining carrots, but will\
    \ still be hungry.\n/// Example:\n/// >>> eat(number: 5, need: 6, remaining: 10)\n\
    /// [11, 4]\n/// >>> eat(number: 4, need: 8, remaining: 9)\n/// [12, 1]\n/// >>>\
    \ eat(number: 1, need: 10, remaining: 10)\n/// [11, 0]\n/// >>> eat(number: 2,\
    \ need: 11, remaining: 5)\n/// [7, 0]\n/// Variables:\n/// @number : integer\n\
    /// the number of carrots that you have eaten.\n/// @need : integer\n/// the number\
    \ of carrots that you need to eat.\n/// @remaining : integer\n/// the number of\
    \ remaining carrots thet exist in stock\n/// Constrain:\n/// * 0 <= number <=\
    \ 1000\n/// * 0 <= need <= 1000\n/// * 0 <= remaining <= 1000\n/// Have fun :)\n\
    func eat(number: Int, need: Int, remaining: Int) -> [Int] {\n    return [number\
    \ + (remaining >= need ? need : remaining),\n            remaining - need]\n}\n\
    \n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(eat(number: 5, need: 6, remaining: 10) == [11,\
    \ 4])\nassert(eat(number: 4, need: 8, remaining: 9) == [12, 1])\nassert(eat(number:\
    \ 1, need: 10, remaining: 10) == [11, 0])\nassert(eat(number: 2, need: 11, remaining:\
    \ 5) == [7, 0])\nassert(eat(number: 4, need: 5, remaining: 7) == [9, 2])\nassert(eat(number:\
    \ 4, need: 5, remaining: 1) == [5, 0])"
  status: Exception
  stderr: 'tmpvbo4jfhs/tmpvbo4jfhs.swift:49: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002ad72a90fc80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002ad72a606b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002ad72a606988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002ad72a6057b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpvbo4jfhs                        0x0000559a83864658 <unavailable> + 5720

    5    libc.so.6                          0x00002ad72aafb460 __libc_start_main +
    245

    6    tmpvbo4jfhs                        0x0000559a83863fc9 <unavailable> + 4041

    '
  stdout: ''
  timestamp: 1660014021
- exit_code: -4
  program: "\n/// You're a hungry rabbit, and you already have eaten a certain number\
    \ of carrots,\n/// but now you need to eat more carrots to complete the day's\
    \ meals.\n/// you should return an array of [ total number of eaten carrots after\
    \ your meals,\n/// the number of carrots left after your meals ]\n/// if there\
    \ are not enough remaining carrots, you will eat all remaining carrots, but will\
    \ still be hungry.\n/// Example:\n/// >>> eat(number: 5, need: 6, remaining: 10)\n\
    /// [11, 4]\n/// >>> eat(number: 4, need: 8, remaining: 9)\n/// [12, 1]\n/// >>>\
    \ eat(number: 1, need: 10, remaining: 10)\n/// [11, 0]\n/// >>> eat(number: 2,\
    \ need: 11, remaining: 5)\n/// [7, 0]\n/// Variables:\n/// @number : integer\n\
    /// the number of carrots that you have eaten.\n/// @need : integer\n/// the number\
    \ of carrots that you need to eat.\n/// @remaining : integer\n/// the number of\
    \ remaining carrots thet exist in stock\n/// Constrain:\n/// * 0 <= number <=\
    \ 1000\n/// * 0 <= need <= 1000\n/// * 0 <= remaining <= 1000\n/// Have fun :)\n\
    func eat(number: Int, need: Int, remaining: Int) -> [Int] {\n    let numberToEat\
    \ = need - number\n    let totalEaten = number + min(numberToEat, remaining)\n\
    \    let remainingCarrots = max(0, remaining - numberToEat)\n    return [totalEaten,\
    \ remainingCarrots]\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) ->\
    \ Bool {\n    if left.count != right.count {\n        return false\n    }\n  \
    \  for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(eat(number: 5, need:\
    \ 6, remaining: 10) == [11, 4])\nassert(eat(number: 4, need: 8, remaining: 9)\
    \ == [12, 1])\nassert(eat(number: 1, need: 10, remaining: 10) == [11, 0])\nassert(eat(number:\
    \ 2, need: 11, remaining: 5) == [7, 0])\nassert(eat(number: 4, need: 5, remaining:\
    \ 7) == [9, 2])\nassert(eat(number: 4, need: 5, remaining: 1) == [5, 0])"
  status: Exception
  stderr: 'tmpalsw22kg/tmpalsw22kg.swift:48: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b424b6fcc80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b424b3f3b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b424b3f3988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b424b3f27b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpalsw22kg                        0x000055c106ae6474 <unavailable> + 5236

    5    libc.so.6                          0x00002b424b8e8460 __libc_start_main +
    245

    6    tmpalsw22kg                        0x000055c106ae60b9 <unavailable> + 4281

    '
  stdout: ''
  timestamp: 1660014021
- exit_code: -4
  program: "\n/// You're a hungry rabbit, and you already have eaten a certain number\
    \ of carrots,\n/// but now you need to eat more carrots to complete the day's\
    \ meals.\n/// you should return an array of [ total number of eaten carrots after\
    \ your meals,\n/// the number of carrots left after your meals ]\n/// if there\
    \ are not enough remaining carrots, you will eat all remaining carrots, but will\
    \ still be hungry.\n/// Example:\n/// >>> eat(number: 5, need: 6, remaining: 10)\n\
    /// [11, 4]\n/// >>> eat(number: 4, need: 8, remaining: 9)\n/// [12, 1]\n/// >>>\
    \ eat(number: 1, need: 10, remaining: 10)\n/// [11, 0]\n/// >>> eat(number: 2,\
    \ need: 11, remaining: 5)\n/// [7, 0]\n/// Variables:\n/// @number : integer\n\
    /// the number of carrots that you have eaten.\n/// @need : integer\n/// the number\
    \ of carrots that you need to eat.\n/// @remaining : integer\n/// the number of\
    \ remaining carrots thet exist in stock\n/// Constrain:\n/// * 0 <= number <=\
    \ 1000\n/// * 0 <= need <= 1000\n/// * 0 <= remaining <= 1000\n/// Have fun :)\n\
    func eat(number: Int, need: Int, remaining: Int) -> [Int] {\n    \n    var total\
    \ = number\n    var rem = remaining\n    \n    while total < need && rem > 0 {\n\
    \        total += 1\n        rem -= 1\n    }\n    \n    return [total, rem]\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(eat(number: 5, need: 6, remaining: 10) == [11,\
    \ 4])\nassert(eat(number: 4, need: 8, remaining: 9) == [12, 1])\nassert(eat(number:\
    \ 1, need: 10, remaining: 10) == [11, 0])\nassert(eat(number: 2, need: 11, remaining:\
    \ 5) == [7, 0])\nassert(eat(number: 4, need: 5, remaining: 7) == [9, 2])\nassert(eat(number:\
    \ 4, need: 5, remaining: 1) == [5, 0])"
  status: Exception
  stderr: 'tmp2c4tbozh/tmp2c4tbozh.swift:54: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002ba6331aac80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002ba632ea1b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002ba632ea1988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002ba632ea07b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmp2c4tbozh                        0x000055caa7124384 <unavailable> + 4996

    5    libc.so.6                          0x00002ba633396460 __libc_start_main +
    245

    6    tmp2c4tbozh                        0x000055caa7123fc9 <unavailable> + 4041

    '
  stdout: ''
  timestamp: 1660014021
- exit_code: -4
  program: "\n/// You're a hungry rabbit, and you already have eaten a certain number\
    \ of carrots,\n/// but now you need to eat more carrots to complete the day's\
    \ meals.\n/// you should return an array of [ total number of eaten carrots after\
    \ your meals,\n/// the number of carrots left after your meals ]\n/// if there\
    \ are not enough remaining carrots, you will eat all remaining carrots, but will\
    \ still be hungry.\n/// Example:\n/// >>> eat(number: 5, need: 6, remaining: 10)\n\
    /// [11, 4]\n/// >>> eat(number: 4, need: 8, remaining: 9)\n/// [12, 1]\n/// >>>\
    \ eat(number: 1, need: 10, remaining: 10)\n/// [11, 0]\n/// >>> eat(number: 2,\
    \ need: 11, remaining: 5)\n/// [7, 0]\n/// Variables:\n/// @number : integer\n\
    /// the number of carrots that you have eaten.\n/// @need : integer\n/// the number\
    \ of carrots that you need to eat.\n/// @remaining : integer\n/// the number of\
    \ remaining carrots thet exist in stock\n/// Constrain:\n/// * 0 <= number <=\
    \ 1000\n/// * 0 <= need <= 1000\n/// * 0 <= remaining <= 1000\n/// Have fun :)\n\
    func eat(number: Int, need: Int, remaining: Int) -> [Int] {\n    let left = remaining\
    \ - (need - number)\n    return [number + remaining, left > 0 ? left : 0]\n}\n\
    \n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(eat(number: 5, need: 6, remaining: 10) == [11,\
    \ 4])\nassert(eat(number: 4, need: 8, remaining: 9) == [12, 1])\nassert(eat(number:\
    \ 1, need: 10, remaining: 10) == [11, 0])\nassert(eat(number: 2, need: 11, remaining:\
    \ 5) == [7, 0])\nassert(eat(number: 4, need: 5, remaining: 7) == [9, 2])\nassert(eat(number:\
    \ 4, need: 5, remaining: 1) == [5, 0])"
  status: Exception
  stderr: 'tmprqswvrfh/tmprqswvrfh.swift:46: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002af324e71c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002af324b68b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002af324b68988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002af324b677b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmprqswvrfh                        0x0000557f01290384 <unavailable> + 4996

    5    libc.so.6                          0x00002af32505d460 __libc_start_main +
    245

    6    tmprqswvrfh                        0x0000557f0128ffc9 <unavailable> + 4041

    '
  stdout: ''
  timestamp: 1660014021
- exit_code: 0
  program: "\n/// You're a hungry rabbit, and you already have eaten a certain number\
    \ of carrots,\n/// but now you need to eat more carrots to complete the day's\
    \ meals.\n/// you should return an array of [ total number of eaten carrots after\
    \ your meals,\n/// the number of carrots left after your meals ]\n/// if there\
    \ are not enough remaining carrots, you will eat all remaining carrots, but will\
    \ still be hungry.\n/// Example:\n/// >>> eat(number: 5, need: 6, remaining: 10)\n\
    /// [11, 4]\n/// >>> eat(number: 4, need: 8, remaining: 9)\n/// [12, 1]\n/// >>>\
    \ eat(number: 1, need: 10, remaining: 10)\n/// [11, 0]\n/// >>> eat(number: 2,\
    \ need: 11, remaining: 5)\n/// [7, 0]\n/// Variables:\n/// @number : integer\n\
    /// the number of carrots that you have eaten.\n/// @need : integer\n/// the number\
    \ of carrots that you need to eat.\n/// @remaining : integer\n/// the number of\
    \ remaining carrots thet exist in stock\n/// Constrain:\n/// * 0 <= number <=\
    \ 1000\n/// * 0 <= need <= 1000\n/// * 0 <= remaining <= 1000\n/// Have fun :)\n\
    func eat(number: Int, need: Int, remaining: Int) -> [Int] {\n    return [number\
    \ + min(need, remaining), max(0, remaining - need)]\n}\n\n\nfunc ==(left: [(Int,\
    \ Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n\
    \        return false\n    }\n    for (l, r) in zip(left, right) {\n        if\
    \ l != r {\n            return false\n        }\n    }\n    return true\n}\n \
    \           \nassert(eat(number: 5, need: 6, remaining: 10) == [11, 4])\nassert(eat(number:\
    \ 4, need: 8, remaining: 9) == [12, 1])\nassert(eat(number: 1, need: 10, remaining:\
    \ 10) == [11, 0])\nassert(eat(number: 2, need: 11, remaining: 5) == [7, 0])\n\
    assert(eat(number: 4, need: 5, remaining: 7) == [9, 2])\nassert(eat(number: 4,\
    \ need: 5, remaining: 1) == [5, 0])"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660013824
- exit_code: -4
  program: "\n/// You're a hungry rabbit, and you already have eaten a certain number\
    \ of carrots,\n/// but now you need to eat more carrots to complete the day's\
    \ meals.\n/// you should return an array of [ total number of eaten carrots after\
    \ your meals,\n/// the number of carrots left after your meals ]\n/// if there\
    \ are not enough remaining carrots, you will eat all remaining carrots, but will\
    \ still be hungry.\n/// Example:\n/// >>> eat(number: 5, need: 6, remaining: 10)\n\
    /// [11, 4]\n/// >>> eat(number: 4, need: 8, remaining: 9)\n/// [12, 1]\n/// >>>\
    \ eat(number: 1, need: 10, remaining: 10)\n/// [11, 0]\n/// >>> eat(number: 2,\
    \ need: 11, remaining: 5)\n/// [7, 0]\n/// Variables:\n/// @number : integer\n\
    /// the number of carrots that you have eaten.\n/// @need : integer\n/// the number\
    \ of carrots that you need to eat.\n/// @remaining : integer\n/// the number of\
    \ remaining carrots thet exist in stock\n/// Constrain:\n/// * 0 <= number <=\
    \ 1000\n/// * 0 <= need <= 1000\n/// * 0 <= remaining <= 1000\n/// Have fun :)\n\
    func eat(number: Int, need: Int, remaining: Int) -> [Int] {\n    let carrotsEaten\
    \ = min(number + remaining, need)\n    let numberOfRemainingCarrots = remaining\
    \ - carrotsEaten + number\n    return [carrotsEaten, numberOfRemainingCarrots]\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(eat(number: 5, need: 6, remaining: 10) == [11,\
    \ 4])\nassert(eat(number: 4, need: 8, remaining: 9) == [12, 1])\nassert(eat(number:\
    \ 1, need: 10, remaining: 10) == [11, 0])\nassert(eat(number: 2, need: 11, remaining:\
    \ 5) == [7, 0])\nassert(eat(number: 4, need: 5, remaining: 7) == [9, 2])\nassert(eat(number:\
    \ 4, need: 5, remaining: 1) == [5, 0])"
  status: Exception
  stderr: 'tmpklq9sed2/tmpklq9sed2.swift:47: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002ba861cafc80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002ba8619a6b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002ba8619a6988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002ba8619a57b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpklq9sed2                        0x00005560f022d424 <unavailable> + 5156

    5    libc.so.6                          0x00002ba861e9b460 __libc_start_main +
    245

    6    tmpklq9sed2                        0x00005560f022d069 <unavailable> + 4201

    '
  stdout: ''
  timestamp: 1660014021
- exit_code: -4
  program: "\n/// You're a hungry rabbit, and you already have eaten a certain number\
    \ of carrots,\n/// but now you need to eat more carrots to complete the day's\
    \ meals.\n/// you should return an array of [ total number of eaten carrots after\
    \ your meals,\n/// the number of carrots left after your meals ]\n/// if there\
    \ are not enough remaining carrots, you will eat all remaining carrots, but will\
    \ still be hungry.\n/// Example:\n/// >>> eat(number: 5, need: 6, remaining: 10)\n\
    /// [11, 4]\n/// >>> eat(number: 4, need: 8, remaining: 9)\n/// [12, 1]\n/// >>>\
    \ eat(number: 1, need: 10, remaining: 10)\n/// [11, 0]\n/// >>> eat(number: 2,\
    \ need: 11, remaining: 5)\n/// [7, 0]\n/// Variables:\n/// @number : integer\n\
    /// the number of carrots that you have eaten.\n/// @need : integer\n/// the number\
    \ of carrots that you need to eat.\n/// @remaining : integer\n/// the number of\
    \ remaining carrots thet exist in stock\n/// Constrain:\n/// * 0 <= number <=\
    \ 1000\n/// * 0 <= need <= 1000\n/// * 0 <= remaining <= 1000\n/// Have fun :)\n\
    func eat(number: Int, need: Int, remaining: Int) -> [Int] {\n    let total = number\
    \ + remaining\n    let meal = total - need < 0 ? total : need\n    return [meal,\
    \ total - meal]\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool\
    \ {\n    if left.count != right.count {\n        return false\n    }\n    for\
    \ (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(eat(number: 5, need:\
    \ 6, remaining: 10) == [11, 4])\nassert(eat(number: 4, need: 8, remaining: 9)\
    \ == [12, 1])\nassert(eat(number: 1, need: 10, remaining: 10) == [11, 0])\nassert(eat(number:\
    \ 2, need: 11, remaining: 5) == [7, 0])\nassert(eat(number: 4, need: 5, remaining:\
    \ 7) == [9, 2])\nassert(eat(number: 4, need: 5, remaining: 1) == [5, 0])"
  status: Exception
  stderr: 'tmpr85lhn4b/tmpr85lhn4b.swift:47: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002ab270e77c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002ab270b6eb6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002ab270b6e988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002ab270b6d7b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpr85lhn4b                        0x0000560865248384 <unavailable> + 4996

    5    libc.so.6                          0x00002ab271063460 __libc_start_main +
    245

    6    tmpr85lhn4b                        0x0000560865247fc9 <unavailable> + 4041

    '
  stdout: ''
  timestamp: 1660014021
- exit_code: -4
  program: "\n/// You're a hungry rabbit, and you already have eaten a certain number\
    \ of carrots,\n/// but now you need to eat more carrots to complete the day's\
    \ meals.\n/// you should return an array of [ total number of eaten carrots after\
    \ your meals,\n/// the number of carrots left after your meals ]\n/// if there\
    \ are not enough remaining carrots, you will eat all remaining carrots, but will\
    \ still be hungry.\n/// Example:\n/// >>> eat(number: 5, need: 6, remaining: 10)\n\
    /// [11, 4]\n/// >>> eat(number: 4, need: 8, remaining: 9)\n/// [12, 1]\n/// >>>\
    \ eat(number: 1, need: 10, remaining: 10)\n/// [11, 0]\n/// >>> eat(number: 2,\
    \ need: 11, remaining: 5)\n/// [7, 0]\n/// Variables:\n/// @number : integer\n\
    /// the number of carrots that you have eaten.\n/// @need : integer\n/// the number\
    \ of carrots that you need to eat.\n/// @remaining : integer\n/// the number of\
    \ remaining carrots thet exist in stock\n/// Constrain:\n/// * 0 <= number <=\
    \ 1000\n/// * 0 <= need <= 1000\n/// * 0 <= remaining <= 1000\n/// Have fun :)\n\
    func eat(number: Int, need: Int, remaining: Int) -> [Int] {\n    if number >=\
    \ need {\n        return [number, remaining]\n    } else if remaining >= need\
    \ - number {\n        return [need, remaining - (need - number)]\n    } else {\n\
    \        return [remaining + number, 0]\n    }\n}\n\n\nfunc ==(left: [(Int, Int)],\
    \ right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n       \
    \ return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r\
    \ {\n            return false\n        }\n    }\n    return true\n}\n        \
    \    \nassert(eat(number: 5, need: 6, remaining: 10) == [11, 4])\nassert(eat(number:\
    \ 4, need: 8, remaining: 9) == [12, 1])\nassert(eat(number: 1, need: 10, remaining:\
    \ 10) == [11, 0])\nassert(eat(number: 2, need: 11, remaining: 5) == [7, 0])\n\
    assert(eat(number: 4, need: 5, remaining: 7) == [9, 2])\nassert(eat(number: 4,\
    \ need: 5, remaining: 1) == [5, 0])"
  status: Exception
  stderr: 'tmpp88m_8f9/tmpp88m_8f9.swift:51: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b7fe6aa5c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b7fe679cb6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b7fe679c988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b7fe679b7b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpp88m_8f9                        0x000055e64c98f384 <unavailable> + 4996

    5    libc.so.6                          0x00002b7fe6c91460 __libc_start_main +
    245

    6    tmpp88m_8f9                        0x000055e64c98efc9 <unavailable> + 4041

    '
  stdout: ''
  timestamp: 1660014021
- exit_code: 0
  program: "\n/// You're a hungry rabbit, and you already have eaten a certain number\
    \ of carrots,\n/// but now you need to eat more carrots to complete the day's\
    \ meals.\n/// you should return an array of [ total number of eaten carrots after\
    \ your meals,\n/// the number of carrots left after your meals ]\n/// if there\
    \ are not enough remaining carrots, you will eat all remaining carrots, but will\
    \ still be hungry.\n/// Example:\n/// >>> eat(number: 5, need: 6, remaining: 10)\n\
    /// [11, 4]\n/// >>> eat(number: 4, need: 8, remaining: 9)\n/// [12, 1]\n/// >>>\
    \ eat(number: 1, need: 10, remaining: 10)\n/// [11, 0]\n/// >>> eat(number: 2,\
    \ need: 11, remaining: 5)\n/// [7, 0]\n/// Variables:\n/// @number : integer\n\
    /// the number of carrots that you have eaten.\n/// @need : integer\n/// the number\
    \ of carrots that you need to eat.\n/// @remaining : integer\n/// the number of\
    \ remaining carrots thet exist in stock\n/// Constrain:\n/// * 0 <= number <=\
    \ 1000\n/// * 0 <= need <= 1000\n/// * 0 <= remaining <= 1000\n/// Have fun :)\n\
    func eat(number: Int, need: Int, remaining: Int) -> [Int] {\n    let a = number\
    \ + min(need, remaining)\n    let b = max(0, remaining - need)\n    return [a,\
    \ b]\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if\
    \ left.count != right.count {\n        return false\n    }\n    for (l, r) in\
    \ zip(left, right) {\n        if l != r {\n            return false\n        }\n\
    \    }\n    return true\n}\n            \nassert(eat(number: 5, need: 6, remaining:\
    \ 10) == [11, 4])\nassert(eat(number: 4, need: 8, remaining: 9) == [12, 1])\n\
    assert(eat(number: 1, need: 10, remaining: 10) == [11, 0])\nassert(eat(number:\
    \ 2, need: 11, remaining: 5) == [7, 0])\nassert(eat(number: 4, need: 5, remaining:\
    \ 7) == [9, 2])\nassert(eat(number: 4, need: 5, remaining: 1) == [5, 0])"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660014021
- exit_code: -4
  program: "\n/// You're a hungry rabbit, and you already have eaten a certain number\
    \ of carrots,\n/// but now you need to eat more carrots to complete the day's\
    \ meals.\n/// you should return an array of [ total number of eaten carrots after\
    \ your meals,\n/// the number of carrots left after your meals ]\n/// if there\
    \ are not enough remaining carrots, you will eat all remaining carrots, but will\
    \ still be hungry.\n/// Example:\n/// >>> eat(number: 5, need: 6, remaining: 10)\n\
    /// [11, 4]\n/// >>> eat(number: 4, need: 8, remaining: 9)\n/// [12, 1]\n/// >>>\
    \ eat(number: 1, need: 10, remaining: 10)\n/// [11, 0]\n/// >>> eat(number: 2,\
    \ need: 11, remaining: 5)\n/// [7, 0]\n/// Variables:\n/// @number : integer\n\
    /// the number of carrots that you have eaten.\n/// @need : integer\n/// the number\
    \ of carrots that you need to eat.\n/// @remaining : integer\n/// the number of\
    \ remaining carrots thet exist in stock\n/// Constrain:\n/// * 0 <= number <=\
    \ 1000\n/// * 0 <= need <= 1000\n/// * 0 <= remaining <= 1000\n/// Have fun :)\n\
    func eat(number: Int, need: Int, remaining: Int) -> [Int] {\n    let eatCarrots\
    \ = number + need < remaining ? need : remaining - number\n    return [number\
    \ + eatCarrots, remaining - eatCarrots]\n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(eat(number: 5, need: 6, remaining: 10) == [11, 4])\nassert(eat(number:\
    \ 4, need: 8, remaining: 9) == [12, 1])\nassert(eat(number: 1, need: 10, remaining:\
    \ 10) == [11, 0])\nassert(eat(number: 2, need: 11, remaining: 5) == [7, 0])\n\
    assert(eat(number: 4, need: 5, remaining: 7) == [9, 2])\nassert(eat(number: 4,\
    \ need: 5, remaining: 1) == [5, 0])"
  status: Exception
  stderr: 'tmp09n4zqsi/tmp09n4zqsi.swift:46: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b6d233d5c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b6d230ccb6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b6d230cc988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b6d230cb7b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmp09n4zqsi                        0x00005586d8363384 <unavailable> + 4996

    5    libc.so.6                          0x00002b6d235c1460 __libc_start_main +
    245

    6    tmp09n4zqsi                        0x00005586d8362fc9 <unavailable> + 4041

    '
  stdout: ''
  timestamp: 1660014021
- exit_code: -4
  program: "\n/// You're a hungry rabbit, and you already have eaten a certain number\
    \ of carrots,\n/// but now you need to eat more carrots to complete the day's\
    \ meals.\n/// you should return an array of [ total number of eaten carrots after\
    \ your meals,\n/// the number of carrots left after your meals ]\n/// if there\
    \ are not enough remaining carrots, you will eat all remaining carrots, but will\
    \ still be hungry.\n/// Example:\n/// >>> eat(number: 5, need: 6, remaining: 10)\n\
    /// [11, 4]\n/// >>> eat(number: 4, need: 8, remaining: 9)\n/// [12, 1]\n/// >>>\
    \ eat(number: 1, need: 10, remaining: 10)\n/// [11, 0]\n/// >>> eat(number: 2,\
    \ need: 11, remaining: 5)\n/// [7, 0]\n/// Variables:\n/// @number : integer\n\
    /// the number of carrots that you have eaten.\n/// @need : integer\n/// the number\
    \ of carrots that you need to eat.\n/// @remaining : integer\n/// the number of\
    \ remaining carrots thet exist in stock\n/// Constrain:\n/// * 0 <= number <=\
    \ 1000\n/// * 0 <= need <= 1000\n/// * 0 <= remaining <= 1000\n/// Have fun :)\n\
    func eat(number: Int, need: Int, remaining: Int) -> [Int] {\n    let total = number\
    \ + remaining\n    let eaten = total >= need ? need : total\n    return [eaten,\
    \ total - eaten]\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool\
    \ {\n    if left.count != right.count {\n        return false\n    }\n    for\
    \ (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(eat(number: 5, need:\
    \ 6, remaining: 10) == [11, 4])\nassert(eat(number: 4, need: 8, remaining: 9)\
    \ == [12, 1])\nassert(eat(number: 1, need: 10, remaining: 10) == [11, 0])\nassert(eat(number:\
    \ 2, need: 11, remaining: 5) == [7, 0])\nassert(eat(number: 4, need: 5, remaining:\
    \ 7) == [9, 2])\nassert(eat(number: 4, need: 5, remaining: 1) == [5, 0])"
  status: Exception
  stderr: 'tmpz9wr2vgy/tmpz9wr2vgy.swift:47: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b845660ec80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b8456305b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b8456305988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b84563047b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpz9wr2vgy                        0x000055d5af66d384 <unavailable> + 4996

    5    libc.so.6                          0x00002b84567fa460 __libc_start_main +
    245

    6    tmpz9wr2vgy                        0x000055d5af66cfc9 <unavailable> + 4041

    '
  stdout: ''
  timestamp: 1660013824
- exit_code: -4
  program: "\n/// You're a hungry rabbit, and you already have eaten a certain number\
    \ of carrots,\n/// but now you need to eat more carrots to complete the day's\
    \ meals.\n/// you should return an array of [ total number of eaten carrots after\
    \ your meals,\n/// the number of carrots left after your meals ]\n/// if there\
    \ are not enough remaining carrots, you will eat all remaining carrots, but will\
    \ still be hungry.\n/// Example:\n/// >>> eat(number: 5, need: 6, remaining: 10)\n\
    /// [11, 4]\n/// >>> eat(number: 4, need: 8, remaining: 9)\n/// [12, 1]\n/// >>>\
    \ eat(number: 1, need: 10, remaining: 10)\n/// [11, 0]\n/// >>> eat(number: 2,\
    \ need: 11, remaining: 5)\n/// [7, 0]\n/// Variables:\n/// @number : integer\n\
    /// the number of carrots that you have eaten.\n/// @need : integer\n/// the number\
    \ of carrots that you need to eat.\n/// @remaining : integer\n/// the number of\
    \ remaining carrots thet exist in stock\n/// Constrain:\n/// * 0 <= number <=\
    \ 1000\n/// * 0 <= need <= 1000\n/// * 0 <= remaining <= 1000\n/// Have fun :)\n\
    func eat(number: Int, need: Int, remaining: Int) -> [Int] {\n    if number >=\
    \ need {\n        return [number, remaining]\n    }\n    if number + remaining\
    \ >= need {\n        return [need, number + remaining - need]\n    }\n    return\
    \ [number + remaining, 0]\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(eat(number:\
    \ 5, need: 6, remaining: 10) == [11, 4])\nassert(eat(number: 4, need: 8, remaining:\
    \ 9) == [12, 1])\nassert(eat(number: 1, need: 10, remaining: 10) == [11, 0])\n\
    assert(eat(number: 2, need: 11, remaining: 5) == [7, 0])\nassert(eat(number: 4,\
    \ need: 5, remaining: 7) == [9, 2])\nassert(eat(number: 4, need: 5, remaining:\
    \ 1) == [5, 0])"
  status: Exception
  stderr: 'tmpwur0yzyd/tmpwur0yzyd.swift:51: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b4fb3f58c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b4fb3c4fb6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b4fb3c4f988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b4fb3c4e7b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpwur0yzyd                        0x000055a2830ff384 <unavailable> + 4996

    5    libc.so.6                          0x00002b4fb4144460 __libc_start_main +
    245

    6    tmpwur0yzyd                        0x000055a2830fefc9 <unavailable> + 4041

    '
  stdout: ''
  timestamp: 1660014021
- exit_code: -4
  program: "\n/// You're a hungry rabbit, and you already have eaten a certain number\
    \ of carrots,\n/// but now you need to eat more carrots to complete the day's\
    \ meals.\n/// you should return an array of [ total number of eaten carrots after\
    \ your meals,\n/// the number of carrots left after your meals ]\n/// if there\
    \ are not enough remaining carrots, you will eat all remaining carrots, but will\
    \ still be hungry.\n/// Example:\n/// >>> eat(number: 5, need: 6, remaining: 10)\n\
    /// [11, 4]\n/// >>> eat(number: 4, need: 8, remaining: 9)\n/// [12, 1]\n/// >>>\
    \ eat(number: 1, need: 10, remaining: 10)\n/// [11, 0]\n/// >>> eat(number: 2,\
    \ need: 11, remaining: 5)\n/// [7, 0]\n/// Variables:\n/// @number : integer\n\
    /// the number of carrots that you have eaten.\n/// @need : integer\n/// the number\
    \ of carrots that you need to eat.\n/// @remaining : integer\n/// the number of\
    \ remaining carrots thet exist in stock\n/// Constrain:\n/// * 0 <= number <=\
    \ 1000\n/// * 0 <= need <= 1000\n/// * 0 <= remaining <= 1000\n/// Have fun :)\n\
    func eat(number: Int, need: Int, remaining: Int) -> [Int] {\n    var number =\
    \ number\n    var remaining = remaining\n    let need = need\n    while number\
    \ < need && remaining > 0 {\n        number += 1\n        remaining -= 1\n   \
    \ }\n    return [number, remaining]\n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(eat(number: 5, need: 6, remaining: 10) == [11, 4])\nassert(eat(number:\
    \ 4, need: 8, remaining: 9) == [12, 1])\nassert(eat(number: 1, need: 10, remaining:\
    \ 10) == [11, 0])\nassert(eat(number: 2, need: 11, remaining: 5) == [7, 0])\n\
    assert(eat(number: 4, need: 5, remaining: 7) == [9, 2])\nassert(eat(number: 4,\
    \ need: 5, remaining: 1) == [5, 0])"
  status: Exception
  stderr: 'tmp3a2b6_d2/tmp3a2b6_d2.swift:52: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002ac3e3ce9c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002ac3e39e0b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002ac3e39e0988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002ac3e39df7b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmp3a2b6_d2                        0x000055a21cc9b384 <unavailable> + 4996

    5    libc.so.6                          0x00002ac3e3ed5460 __libc_start_main +
    245

    6    tmp3a2b6_d2                        0x000055a21cc9afc9 <unavailable> + 4041

    '
  stdout: ''
  timestamp: 1660014021
- exit_code: -4
  program: "\n/// You're a hungry rabbit, and you already have eaten a certain number\
    \ of carrots,\n/// but now you need to eat more carrots to complete the day's\
    \ meals.\n/// you should return an array of [ total number of eaten carrots after\
    \ your meals,\n/// the number of carrots left after your meals ]\n/// if there\
    \ are not enough remaining carrots, you will eat all remaining carrots, but will\
    \ still be hungry.\n/// Example:\n/// >>> eat(number: 5, need: 6, remaining: 10)\n\
    /// [11, 4]\n/// >>> eat(number: 4, need: 8, remaining: 9)\n/// [12, 1]\n/// >>>\
    \ eat(number: 1, need: 10, remaining: 10)\n/// [11, 0]\n/// >>> eat(number: 2,\
    \ need: 11, remaining: 5)\n/// [7, 0]\n/// Variables:\n/// @number : integer\n\
    /// the number of carrots that you have eaten.\n/// @need : integer\n/// the number\
    \ of carrots that you need to eat.\n/// @remaining : integer\n/// the number of\
    \ remaining carrots thet exist in stock\n/// Constrain:\n/// * 0 <= number <=\
    \ 1000\n/// * 0 <= need <= 1000\n/// * 0 <= remaining <= 1000\n/// Have fun :)\n\
    func eat(number: Int, need: Int, remaining: Int) -> [Int] {\n    var eaten = number\n\
    \    var res = remaining\n    while eaten < need {\n        if res == 0 {\n  \
    \          break\n        }\n        eaten += 1\n        res -= 1\n    }\n   \
    \ return [eaten, res]\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(eat(number:\
    \ 5, need: 6, remaining: 10) == [11, 4])\nassert(eat(number: 4, need: 8, remaining:\
    \ 9) == [12, 1])\nassert(eat(number: 1, need: 10, remaining: 10) == [11, 0])\n\
    assert(eat(number: 2, need: 11, remaining: 5) == [7, 0])\nassert(eat(number: 4,\
    \ need: 5, remaining: 7) == [9, 2])\nassert(eat(number: 4, need: 5, remaining:\
    \ 1) == [5, 0])"
  status: Exception
  stderr: 'tmptti5jqj7/tmptti5jqj7.swift:54: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b91c87fec80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b91c84f5b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b91c84f5988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b91c84f47b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmptti5jqj7                        0x000056448ca41384 <unavailable> + 4996

    5    libc.so.6                          0x00002b91c89ea460 __libc_start_main +
    245

    6    tmptti5jqj7                        0x000056448ca40fc9 <unavailable> + 4041

    '
  stdout: ''
  timestamp: 1660014021
- exit_code: -4
  program: "\n/// You're a hungry rabbit, and you already have eaten a certain number\
    \ of carrots,\n/// but now you need to eat more carrots to complete the day's\
    \ meals.\n/// you should return an array of [ total number of eaten carrots after\
    \ your meals,\n/// the number of carrots left after your meals ]\n/// if there\
    \ are not enough remaining carrots, you will eat all remaining carrots, but will\
    \ still be hungry.\n/// Example:\n/// >>> eat(number: 5, need: 6, remaining: 10)\n\
    /// [11, 4]\n/// >>> eat(number: 4, need: 8, remaining: 9)\n/// [12, 1]\n/// >>>\
    \ eat(number: 1, need: 10, remaining: 10)\n/// [11, 0]\n/// >>> eat(number: 2,\
    \ need: 11, remaining: 5)\n/// [7, 0]\n/// Variables:\n/// @number : integer\n\
    /// the number of carrots that you have eaten.\n/// @need : integer\n/// the number\
    \ of carrots that you need to eat.\n/// @remaining : integer\n/// the number of\
    \ remaining carrots thet exist in stock\n/// Constrain:\n/// * 0 <= number <=\
    \ 1000\n/// * 0 <= need <= 1000\n/// * 0 <= remaining <= 1000\n/// Have fun :)\n\
    func eat(number: Int, need: Int, remaining: Int) -> [Int] {\n    if number >=\
    \ need {\n        return [number, remaining]\n    }\n    let eaten = number +\
    \ remaining\n    if eaten >= need {\n        return [eaten, eaten - need]\n  \
    \  }\n    return [eaten, 0]\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int,\
    \ Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n\
    \    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n          \
    \  return false\n        }\n    }\n    return true\n}\n            \nassert(eat(number:\
    \ 5, need: 6, remaining: 10) == [11, 4])\nassert(eat(number: 4, need: 8, remaining:\
    \ 9) == [12, 1])\nassert(eat(number: 1, need: 10, remaining: 10) == [11, 0])\n\
    assert(eat(number: 2, need: 11, remaining: 5) == [7, 0])\nassert(eat(number: 4,\
    \ need: 5, remaining: 7) == [9, 2])\nassert(eat(number: 4, need: 5, remaining:\
    \ 1) == [5, 0])"
  status: Exception
  stderr: 'tmpolg42gua/tmpolg42gua.swift:52: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b858bec1c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b858bbb8b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b858bbb8988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b858bbb77b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpolg42gua                        0x000055d19ce9e384 <unavailable> + 4996

    5    libc.so.6                          0x00002b858c0ad460 __libc_start_main +
    245

    6    tmpolg42gua                        0x000055d19ce9dfc9 <unavailable> + 4041

    '
  stdout: ''
  timestamp: 1660014021
- exit_code: -4
  program: "\n/// You're a hungry rabbit, and you already have eaten a certain number\
    \ of carrots,\n/// but now you need to eat more carrots to complete the day's\
    \ meals.\n/// you should return an array of [ total number of eaten carrots after\
    \ your meals,\n/// the number of carrots left after your meals ]\n/// if there\
    \ are not enough remaining carrots, you will eat all remaining carrots, but will\
    \ still be hungry.\n/// Example:\n/// >>> eat(number: 5, need: 6, remaining: 10)\n\
    /// [11, 4]\n/// >>> eat(number: 4, need: 8, remaining: 9)\n/// [12, 1]\n/// >>>\
    \ eat(number: 1, need: 10, remaining: 10)\n/// [11, 0]\n/// >>> eat(number: 2,\
    \ need: 11, remaining: 5)\n/// [7, 0]\n/// Variables:\n/// @number : integer\n\
    /// the number of carrots that you have eaten.\n/// @need : integer\n/// the number\
    \ of carrots that you need to eat.\n/// @remaining : integer\n/// the number of\
    \ remaining carrots thet exist in stock\n/// Constrain:\n/// * 0 <= number <=\
    \ 1000\n/// * 0 <= need <= 1000\n/// * 0 <= remaining <= 1000\n/// Have fun :)\n\
    func eat(number: Int, need: Int, remaining: Int) -> [Int] {\n    var carrots =\
    \ number + remaining\n    if carrots >= need {\n        return [need, carrots\
    \ - need]\n    } else {\n        return [carrots, 0]\n    }\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(eat(number: 5, need: 6, remaining: 10) == [11, 4])\nassert(eat(number:\
    \ 4, need: 8, remaining: 9) == [12, 1])\nassert(eat(number: 1, need: 10, remaining:\
    \ 10) == [11, 0])\nassert(eat(number: 2, need: 11, remaining: 5) == [7, 0])\n\
    assert(eat(number: 4, need: 5, remaining: 7) == [9, 2])\nassert(eat(number: 4,\
    \ need: 5, remaining: 1) == [5, 0])"
  status: Exception
  stderr: 'tmp_7m183j9/tmp_7m183j9.swift:50: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b111c560c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b111c257b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b111c257988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b111c2567b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmp_7m183j9                        0x000055c466414384 <unavailable> + 4996

    5    libc.so.6                          0x00002b111c74c460 __libc_start_main +
    245

    6    tmp_7m183j9                        0x000055c466413fc9 <unavailable> + 4041

    '
  stdout: ''
  timestamp: 1660014021
- exit_code: -4
  program: "\n/// You're a hungry rabbit, and you already have eaten a certain number\
    \ of carrots,\n/// but now you need to eat more carrots to complete the day's\
    \ meals.\n/// you should return an array of [ total number of eaten carrots after\
    \ your meals,\n/// the number of carrots left after your meals ]\n/// if there\
    \ are not enough remaining carrots, you will eat all remaining carrots, but will\
    \ still be hungry.\n/// Example:\n/// >>> eat(number: 5, need: 6, remaining: 10)\n\
    /// [11, 4]\n/// >>> eat(number: 4, need: 8, remaining: 9)\n/// [12, 1]\n/// >>>\
    \ eat(number: 1, need: 10, remaining: 10)\n/// [11, 0]\n/// >>> eat(number: 2,\
    \ need: 11, remaining: 5)\n/// [7, 0]\n/// Variables:\n/// @number : integer\n\
    /// the number of carrots that you have eaten.\n/// @need : integer\n/// the number\
    \ of carrots that you need to eat.\n/// @remaining : integer\n/// the number of\
    \ remaining carrots thet exist in stock\n/// Constrain:\n/// * 0 <= number <=\
    \ 1000\n/// * 0 <= need <= 1000\n/// * 0 <= remaining <= 1000\n/// Have fun :)\n\
    func eat(number: Int, need: Int, remaining: Int) -> [Int] {\n    let result =\
    \ need - number\n    let remaining = result - remaining\n    let left = remaining\
    \ < 0 ? remaining * -1 : 0\n    return [result + number, left]\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(eat(number: 5, need: 6, remaining: 10) == [11, 4])\nassert(eat(number:\
    \ 4, need: 8, remaining: 9) == [12, 1])\nassert(eat(number: 1, need: 10, remaining:\
    \ 10) == [11, 0])\nassert(eat(number: 2, need: 11, remaining: 5) == [7, 0])\n\
    assert(eat(number: 4, need: 5, remaining: 7) == [9, 2])\nassert(eat(number: 4,\
    \ need: 5, remaining: 1) == [5, 0])"
  status: Exception
  stderr: 'tmpwevcn04p/tmpwevcn04p.swift:48: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002ad4d4597c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002ad4d428eb6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002ad4d428e988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002ad4d428d7b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpwevcn04p                        0x000055cebd414384 <unavailable> + 4996

    5    libc.so.6                          0x00002ad4d4783460 __libc_start_main +
    245

    6    tmpwevcn04p                        0x000055cebd413fc9 <unavailable> + 4041

    '
  stdout: ''
  timestamp: 1660014021
- exit_code: -4
  program: "\n/// You're a hungry rabbit, and you already have eaten a certain number\
    \ of carrots,\n/// but now you need to eat more carrots to complete the day's\
    \ meals.\n/// you should return an array of [ total number of eaten carrots after\
    \ your meals,\n/// the number of carrots left after your meals ]\n/// if there\
    \ are not enough remaining carrots, you will eat all remaining carrots, but will\
    \ still be hungry.\n/// Example:\n/// >>> eat(number: 5, need: 6, remaining: 10)\n\
    /// [11, 4]\n/// >>> eat(number: 4, need: 8, remaining: 9)\n/// [12, 1]\n/// >>>\
    \ eat(number: 1, need: 10, remaining: 10)\n/// [11, 0]\n/// >>> eat(number: 2,\
    \ need: 11, remaining: 5)\n/// [7, 0]\n/// Variables:\n/// @number : integer\n\
    /// the number of carrots that you have eaten.\n/// @need : integer\n/// the number\
    \ of carrots that you need to eat.\n/// @remaining : integer\n/// the number of\
    \ remaining carrots thet exist in stock\n/// Constrain:\n/// * 0 <= number <=\
    \ 1000\n/// * 0 <= need <= 1000\n/// * 0 <= remaining <= 1000\n/// Have fun :)\n\
    func eat(number: Int, need: Int, remaining: Int) -> [Int] {\n    let all = number\
    \ + remaining\n    let total = min(all, need)\n    return [total, all - total]\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(eat(number: 5, need: 6, remaining: 10) == [11,\
    \ 4])\nassert(eat(number: 4, need: 8, remaining: 9) == [12, 1])\nassert(eat(number:\
    \ 1, need: 10, remaining: 10) == [11, 0])\nassert(eat(number: 2, need: 11, remaining:\
    \ 5) == [7, 0])\nassert(eat(number: 4, need: 5, remaining: 7) == [9, 2])\nassert(eat(number:\
    \ 4, need: 5, remaining: 1) == [5, 0])"
  status: Exception
  stderr: 'tmpprccf000/tmpprccf000.swift:47: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002ac14430dc80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002ac144004b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002ac144004988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002ac1440037b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpprccf000                        0x00005610071c9424 <unavailable> + 5156

    5    libc.so.6                          0x00002ac1444f9460 __libc_start_main +
    245

    6    tmpprccf000                        0x00005610071c9069 <unavailable> + 4201

    '
  stdout: ''
  timestamp: 1660014021
- exit_code: -4
  program: "\n/// You're a hungry rabbit, and you already have eaten a certain number\
    \ of carrots,\n/// but now you need to eat more carrots to complete the day's\
    \ meals.\n/// you should return an array of [ total number of eaten carrots after\
    \ your meals,\n/// the number of carrots left after your meals ]\n/// if there\
    \ are not enough remaining carrots, you will eat all remaining carrots, but will\
    \ still be hungry.\n/// Example:\n/// >>> eat(number: 5, need: 6, remaining: 10)\n\
    /// [11, 4]\n/// >>> eat(number: 4, need: 8, remaining: 9)\n/// [12, 1]\n/// >>>\
    \ eat(number: 1, need: 10, remaining: 10)\n/// [11, 0]\n/// >>> eat(number: 2,\
    \ need: 11, remaining: 5)\n/// [7, 0]\n/// Variables:\n/// @number : integer\n\
    /// the number of carrots that you have eaten.\n/// @need : integer\n/// the number\
    \ of carrots that you need to eat.\n/// @remaining : integer\n/// the number of\
    \ remaining carrots thet exist in stock\n/// Constrain:\n/// * 0 <= number <=\
    \ 1000\n/// * 0 <= need <= 1000\n/// * 0 <= remaining <= 1000\n/// Have fun :)\n\
    func eat(number: Int, need: Int, remaining: Int) -> [Int] {\n    var number =\
    \ number\n    var need = need\n    var remaining = remaining\n    if need < number\
    \ {\n        return [number, remaining]\n    }\n    if remaining >= need - number\
    \ {\n        return [need, remaining - (need - number)]\n    }\n    remaining\
    \ = 0\n    need -= remaining\n    number += remaining\n    return [number, remaining]\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(eat(number: 5, need: 6, remaining: 10) == [11,\
    \ 4])\nassert(eat(number: 4, need: 8, remaining: 9) == [12, 1])\nassert(eat(number:\
    \ 1, need: 10, remaining: 10) == [11, 0])\nassert(eat(number: 2, need: 11, remaining:\
    \ 5) == [7, 0])\nassert(eat(number: 4, need: 5, remaining: 7) == [9, 2])\nassert(eat(number:\
    \ 4, need: 5, remaining: 1) == [5, 0])"
  status: Exception
  stderr: 'tmpqbghb06g/tmpqbghb06g.swift:57: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b9883e0cc80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b9883b03b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b9883b03988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b9883b027b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpqbghb06g                        0x00005640c1645384 <unavailable> + 4996

    5    libc.so.6                          0x00002b9883ff8460 __libc_start_main +
    245

    6    tmpqbghb06g                        0x00005640c1644fc9 <unavailable> + 4041

    '
  stdout: ''
  timestamp: 1660014021
- exit_code: -4
  program: "\n/// You're a hungry rabbit, and you already have eaten a certain number\
    \ of carrots,\n/// but now you need to eat more carrots to complete the day's\
    \ meals.\n/// you should return an array of [ total number of eaten carrots after\
    \ your meals,\n/// the number of carrots left after your meals ]\n/// if there\
    \ are not enough remaining carrots, you will eat all remaining carrots, but will\
    \ still be hungry.\n/// Example:\n/// >>> eat(number: 5, need: 6, remaining: 10)\n\
    /// [11, 4]\n/// >>> eat(number: 4, need: 8, remaining: 9)\n/// [12, 1]\n/// >>>\
    \ eat(number: 1, need: 10, remaining: 10)\n/// [11, 0]\n/// >>> eat(number: 2,\
    \ need: 11, remaining: 5)\n/// [7, 0]\n/// Variables:\n/// @number : integer\n\
    /// the number of carrots that you have eaten.\n/// @need : integer\n/// the number\
    \ of carrots that you need to eat.\n/// @remaining : integer\n/// the number of\
    \ remaining carrots thet exist in stock\n/// Constrain:\n/// * 0 <= number <=\
    \ 1000\n/// * 0 <= need <= 1000\n/// * 0 <= remaining <= 1000\n/// Have fun :)\n\
    func eat(number: Int, need: Int, remaining: Int) -> [Int] {\n    var res = [Int]()\n\
    \    var remain = remaining\n    var need = need\n    var number = number\n  \
    \  if number + remain < need {\n        need -= number + remain\n        remain\
    \ = 0\n        number += remain\n    } else {\n        remain -= (need - number)\n\
    \        number += need\n        need = 0\n    }\n    res.append(number)\n   \
    \ res.append(remain)\n    return res\n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(eat(number: 5, need: 6, remaining: 10) == [11, 4])\nassert(eat(number:\
    \ 4, need: 8, remaining: 9) == [12, 1])\nassert(eat(number: 1, need: 10, remaining:\
    \ 10) == [11, 0])\nassert(eat(number: 2, need: 11, remaining: 5) == [7, 0])\n\
    assert(eat(number: 4, need: 5, remaining: 7) == [9, 2])\nassert(eat(number: 4,\
    \ need: 5, remaining: 1) == [5, 0])"
  status: Exception
  stderr: 'tmpxbtu6fie/tmpxbtu6fie.swift:60: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b345ff3fc80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b345fc36b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b345fc36988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b345fc357b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpxbtu6fie                        0x00005564ed9c2444 <unavailable> + 5188

    5    libc.so.6                          0x00002b346012b460 __libc_start_main +
    245

    6    tmpxbtu6fie                        0x00005564ed9c2089 <unavailable> + 4233

    '
  stdout: ''
  timestamp: 1660014021
- exit_code: -4
  program: "\n/// You're a hungry rabbit, and you already have eaten a certain number\
    \ of carrots,\n/// but now you need to eat more carrots to complete the day's\
    \ meals.\n/// you should return an array of [ total number of eaten carrots after\
    \ your meals,\n/// the number of carrots left after your meals ]\n/// if there\
    \ are not enough remaining carrots, you will eat all remaining carrots, but will\
    \ still be hungry.\n/// Example:\n/// >>> eat(number: 5, need: 6, remaining: 10)\n\
    /// [11, 4]\n/// >>> eat(number: 4, need: 8, remaining: 9)\n/// [12, 1]\n/// >>>\
    \ eat(number: 1, need: 10, remaining: 10)\n/// [11, 0]\n/// >>> eat(number: 2,\
    \ need: 11, remaining: 5)\n/// [7, 0]\n/// Variables:\n/// @number : integer\n\
    /// the number of carrots that you have eaten.\n/// @need : integer\n/// the number\
    \ of carrots that you need to eat.\n/// @remaining : integer\n/// the number of\
    \ remaining carrots thet exist in stock\n/// Constrain:\n/// * 0 <= number <=\
    \ 1000\n/// * 0 <= need <= 1000\n/// * 0 <= remaining <= 1000\n/// Have fun :)\n\
    func eat(number: Int, need: Int, remaining: Int) -> [Int] {\n    let total = number\
    \ + remaining\n    let eat = min(total, need)\n    return [eat, total - eat]\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(eat(number: 5, need: 6, remaining: 10) == [11,\
    \ 4])\nassert(eat(number: 4, need: 8, remaining: 9) == [12, 1])\nassert(eat(number:\
    \ 1, need: 10, remaining: 10) == [11, 0])\nassert(eat(number: 2, need: 11, remaining:\
    \ 5) == [7, 0])\nassert(eat(number: 4, need: 5, remaining: 7) == [9, 2])\nassert(eat(number:\
    \ 4, need: 5, remaining: 1) == [5, 0])"
  status: Exception
  stderr: 'tmp6r3nmtql/tmp6r3nmtql.swift:47: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002ba2c9c8bc80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002ba2c9982b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002ba2c9982988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002ba2c99817b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmp6r3nmtql                        0x000055f97bf80424 <unavailable> + 5156

    5    libc.so.6                          0x00002ba2c9e77460 __libc_start_main +
    245

    6    tmp6r3nmtql                        0x000055f97bf80069 <unavailable> + 4201

    '
  stdout: ''
  timestamp: 1660014021
- exit_code: -4
  program: "\n/// You're a hungry rabbit, and you already have eaten a certain number\
    \ of carrots,\n/// but now you need to eat more carrots to complete the day's\
    \ meals.\n/// you should return an array of [ total number of eaten carrots after\
    \ your meals,\n/// the number of carrots left after your meals ]\n/// if there\
    \ are not enough remaining carrots, you will eat all remaining carrots, but will\
    \ still be hungry.\n/// Example:\n/// >>> eat(number: 5, need: 6, remaining: 10)\n\
    /// [11, 4]\n/// >>> eat(number: 4, need: 8, remaining: 9)\n/// [12, 1]\n/// >>>\
    \ eat(number: 1, need: 10, remaining: 10)\n/// [11, 0]\n/// >>> eat(number: 2,\
    \ need: 11, remaining: 5)\n/// [7, 0]\n/// Variables:\n/// @number : integer\n\
    /// the number of carrots that you have eaten.\n/// @need : integer\n/// the number\
    \ of carrots that you need to eat.\n/// @remaining : integer\n/// the number of\
    \ remaining carrots thet exist in stock\n/// Constrain:\n/// * 0 <= number <=\
    \ 1000\n/// * 0 <= need <= 1000\n/// * 0 <= remaining <= 1000\n/// Have fun :)\n\
    func eat(number: Int, need: Int, remaining: Int) -> [Int] {\n  let totalNeed =\
    \ number + need\n  let remain = remaining - totalNeed\n  if remain < 0 {\n   \
    \ return [totalNeed, 0]\n  } else {\n    return [totalNeed, remain]\n  }\n}\n\n\
    \nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(eat(number: 5, need: 6, remaining: 10) == [11,\
    \ 4])\nassert(eat(number: 4, need: 8, remaining: 9) == [12, 1])\nassert(eat(number:\
    \ 1, need: 10, remaining: 10) == [11, 0])\nassert(eat(number: 2, need: 11, remaining:\
    \ 5) == [7, 0])\nassert(eat(number: 4, need: 5, remaining: 7) == [9, 2])\nassert(eat(number:\
    \ 4, need: 5, remaining: 1) == [5, 0])"
  status: Exception
  stderr: 'tmpvmwi1ewo/tmpvmwi1ewo.swift:51: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b51fda33c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b51fd72ab6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b51fd72a988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b51fd7297b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpvmwi1ewo                        0x0000555feaa16384 <unavailable> + 4996

    5    libc.so.6                          0x00002b51fdc1f460 __libc_start_main +
    245

    6    tmpvmwi1ewo                        0x0000555feaa15fc9 <unavailable> + 4041

    '
  stdout: ''
  timestamp: 1660014021
- exit_code: 0
  program: "\n/// You're a hungry rabbit, and you already have eaten a certain number\
    \ of carrots,\n/// but now you need to eat more carrots to complete the day's\
    \ meals.\n/// you should return an array of [ total number of eaten carrots after\
    \ your meals,\n/// the number of carrots left after your meals ]\n/// if there\
    \ are not enough remaining carrots, you will eat all remaining carrots, but will\
    \ still be hungry.\n/// Example:\n/// >>> eat(number: 5, need: 6, remaining: 10)\n\
    /// [11, 4]\n/// >>> eat(number: 4, need: 8, remaining: 9)\n/// [12, 1]\n/// >>>\
    \ eat(number: 1, need: 10, remaining: 10)\n/// [11, 0]\n/// >>> eat(number: 2,\
    \ need: 11, remaining: 5)\n/// [7, 0]\n/// Variables:\n/// @number : integer\n\
    /// the number of carrots that you have eaten.\n/// @need : integer\n/// the number\
    \ of carrots that you need to eat.\n/// @remaining : integer\n/// the number of\
    \ remaining carrots thet exist in stock\n/// Constrain:\n/// * 0 <= number <=\
    \ 1000\n/// * 0 <= need <= 1000\n/// * 0 <= remaining <= 1000\n/// Have fun :)\n\
    func eat(number: Int, need: Int, remaining: Int) -> [Int] {\n    let eatCarrots\
    \ = min(need, remaining) + number\n    let carrotsLeft = max(0, remaining - need)\n\
    \    return [eatCarrots, carrotsLeft]\n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(eat(number: 5, need: 6, remaining: 10) == [11, 4])\nassert(eat(number:\
    \ 4, need: 8, remaining: 9) == [12, 1])\nassert(eat(number: 1, need: 10, remaining:\
    \ 10) == [11, 0])\nassert(eat(number: 2, need: 11, remaining: 5) == [7, 0])\n\
    assert(eat(number: 4, need: 5, remaining: 7) == [9, 2])\nassert(eat(number: 4,\
    \ need: 5, remaining: 1) == [5, 0])"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660014021
- exit_code: -4
  program: "\n/// You're a hungry rabbit, and you already have eaten a certain number\
    \ of carrots,\n/// but now you need to eat more carrots to complete the day's\
    \ meals.\n/// you should return an array of [ total number of eaten carrots after\
    \ your meals,\n/// the number of carrots left after your meals ]\n/// if there\
    \ are not enough remaining carrots, you will eat all remaining carrots, but will\
    \ still be hungry.\n/// Example:\n/// >>> eat(number: 5, need: 6, remaining: 10)\n\
    /// [11, 4]\n/// >>> eat(number: 4, need: 8, remaining: 9)\n/// [12, 1]\n/// >>>\
    \ eat(number: 1, need: 10, remaining: 10)\n/// [11, 0]\n/// >>> eat(number: 2,\
    \ need: 11, remaining: 5)\n/// [7, 0]\n/// Variables:\n/// @number : integer\n\
    /// the number of carrots that you have eaten.\n/// @need : integer\n/// the number\
    \ of carrots that you need to eat.\n/// @remaining : integer\n/// the number of\
    \ remaining carrots thet exist in stock\n/// Constrain:\n/// * 0 <= number <=\
    \ 1000\n/// * 0 <= need <= 1000\n/// * 0 <= remaining <= 1000\n/// Have fun :)\n\
    func eat(number: Int, need: Int, remaining: Int) -> [Int] {\n    var number =\
    \ number\n    var need = need\n    var remaining = remaining\n    var y = 0\n\
    \    var x = 0\n    if need <= number{\n        x = number + remaining\n     \
    \   y = 0\n    }else if need > number{\n        x = remaining\n        y = number\n\
    \        while y < need{\n            y += 1\n            x -= 1\n        }\n\
    \    }\n    return [y, x]\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(eat(number:\
    \ 5, need: 6, remaining: 10) == [11, 4])\nassert(eat(number: 4, need: 8, remaining:\
    \ 9) == [12, 1])\nassert(eat(number: 1, need: 10, remaining: 10) == [11, 0])\n\
    assert(eat(number: 2, need: 11, remaining: 5) == [7, 0])\nassert(eat(number: 4,\
    \ need: 5, remaining: 7) == [9, 2])\nassert(eat(number: 4, need: 5, remaining:\
    \ 1) == [5, 0])"
  status: Exception
  stderr: 'tmp_5sa7ymc/tmp_5sa7ymc.swift:61: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b7a8ddb6c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b7a8daadb6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b7a8daad988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b7a8daac7b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmp_5sa7ymc                        0x000055e35ec37384 <unavailable> + 4996

    5    libc.so.6                          0x00002b7a8dfa2460 __libc_start_main +
    245

    6    tmp_5sa7ymc                        0x000055e35ec36fc9 <unavailable> + 4041

    '
  stdout: ''
  timestamp: 1660014021
- exit_code: -4
  program: "\n/// You're a hungry rabbit, and you already have eaten a certain number\
    \ of carrots,\n/// but now you need to eat more carrots to complete the day's\
    \ meals.\n/// you should return an array of [ total number of eaten carrots after\
    \ your meals,\n/// the number of carrots left after your meals ]\n/// if there\
    \ are not enough remaining carrots, you will eat all remaining carrots, but will\
    \ still be hungry.\n/// Example:\n/// >>> eat(number: 5, need: 6, remaining: 10)\n\
    /// [11, 4]\n/// >>> eat(number: 4, need: 8, remaining: 9)\n/// [12, 1]\n/// >>>\
    \ eat(number: 1, need: 10, remaining: 10)\n/// [11, 0]\n/// >>> eat(number: 2,\
    \ need: 11, remaining: 5)\n/// [7, 0]\n/// Variables:\n/// @number : integer\n\
    /// the number of carrots that you have eaten.\n/// @need : integer\n/// the number\
    \ of carrots that you need to eat.\n/// @remaining : integer\n/// the number of\
    \ remaining carrots thet exist in stock\n/// Constrain:\n/// * 0 <= number <=\
    \ 1000\n/// * 0 <= need <= 1000\n/// * 0 <= remaining <= 1000\n/// Have fun :)\n\
    func eat(number: Int, need: Int, remaining: Int) -> [Int] {\n    return [min(number\
    \ + remaining, need), max(remaining - need + number, 0)]\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(eat(number: 5, need: 6, remaining: 10) == [11, 4])\nassert(eat(number:\
    \ 4, need: 8, remaining: 9) == [12, 1])\nassert(eat(number: 1, need: 10, remaining:\
    \ 10) == [11, 0])\nassert(eat(number: 2, need: 11, remaining: 5) == [7, 0])\n\
    assert(eat(number: 4, need: 5, remaining: 7) == [9, 2])\nassert(eat(number: 4,\
    \ need: 5, remaining: 1) == [5, 0])"
  status: Exception
  stderr: 'tmp7j10scdi/tmp7j10scdi.swift:45: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b45d6d75c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b45d6a6cb6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b45d6a6c988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b45d6a6b7b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmp7j10scdi                        0x0000558fef5ba474 <unavailable> + 5236

    5    libc.so.6                          0x00002b45d6f61460 __libc_start_main +
    245

    6    tmp7j10scdi                        0x0000558fef5ba0b9 <unavailable> + 4281

    '
  stdout: ''
  timestamp: 1660014021
- exit_code: 0
  program: "\n/// You're a hungry rabbit, and you already have eaten a certain number\
    \ of carrots,\n/// but now you need to eat more carrots to complete the day's\
    \ meals.\n/// you should return an array of [ total number of eaten carrots after\
    \ your meals,\n/// the number of carrots left after your meals ]\n/// if there\
    \ are not enough remaining carrots, you will eat all remaining carrots, but will\
    \ still be hungry.\n/// Example:\n/// >>> eat(number: 5, need: 6, remaining: 10)\n\
    /// [11, 4]\n/// >>> eat(number: 4, need: 8, remaining: 9)\n/// [12, 1]\n/// >>>\
    \ eat(number: 1, need: 10, remaining: 10)\n/// [11, 0]\n/// >>> eat(number: 2,\
    \ need: 11, remaining: 5)\n/// [7, 0]\n/// Variables:\n/// @number : integer\n\
    /// the number of carrots that you have eaten.\n/// @need : integer\n/// the number\
    \ of carrots that you need to eat.\n/// @remaining : integer\n/// the number of\
    \ remaining carrots thet exist in stock\n/// Constrain:\n/// * 0 <= number <=\
    \ 1000\n/// * 0 <= need <= 1000\n/// * 0 <= remaining <= 1000\n/// Have fun :)\n\
    func eat(number: Int, need: Int, remaining: Int) -> [Int] {\n    var total = number\n\
    \    var remain = remaining\n    for _ in number..<(number + need) {\n       \
    \ if remain > 0 {\n            total += 1\n            remain -= 1\n        }\n\
    \    }\n    return [total, remain]\n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(eat(number: 5, need: 6, remaining: 10) == [11, 4])\nassert(eat(number:\
    \ 4, need: 8, remaining: 9) == [12, 1])\nassert(eat(number: 1, need: 10, remaining:\
    \ 10) == [11, 0])\nassert(eat(number: 2, need: 11, remaining: 5) == [7, 0])\n\
    assert(eat(number: 4, need: 5, remaining: 7) == [9, 2])\nassert(eat(number: 4,\
    \ need: 5, remaining: 1) == [5, 0])"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660014021
- exit_code: -4
  program: "\n/// You're a hungry rabbit, and you already have eaten a certain number\
    \ of carrots,\n/// but now you need to eat more carrots to complete the day's\
    \ meals.\n/// you should return an array of [ total number of eaten carrots after\
    \ your meals,\n/// the number of carrots left after your meals ]\n/// if there\
    \ are not enough remaining carrots, you will eat all remaining carrots, but will\
    \ still be hungry.\n/// Example:\n/// >>> eat(number: 5, need: 6, remaining: 10)\n\
    /// [11, 4]\n/// >>> eat(number: 4, need: 8, remaining: 9)\n/// [12, 1]\n/// >>>\
    \ eat(number: 1, need: 10, remaining: 10)\n/// [11, 0]\n/// >>> eat(number: 2,\
    \ need: 11, remaining: 5)\n/// [7, 0]\n/// Variables:\n/// @number : integer\n\
    /// the number of carrots that you have eaten.\n/// @need : integer\n/// the number\
    \ of carrots that you need to eat.\n/// @remaining : integer\n/// the number of\
    \ remaining carrots thet exist in stock\n/// Constrain:\n/// * 0 <= number <=\
    \ 1000\n/// * 0 <= need <= 1000\n/// * 0 <= remaining <= 1000\n/// Have fun :)\n\
    func eat(number: Int, need: Int, remaining: Int) -> [Int] {\n    return []\n}\n\
    \n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(eat(number: 5, need: 6, remaining: 10) == [11,\
    \ 4])\nassert(eat(number: 4, need: 8, remaining: 9) == [12, 1])\nassert(eat(number:\
    \ 1, need: 10, remaining: 10) == [11, 0])\nassert(eat(number: 2, need: 11, remaining:\
    \ 5) == [7, 0])\nassert(eat(number: 4, need: 5, remaining: 7) == [9, 2])\nassert(eat(number:\
    \ 4, need: 5, remaining: 1) == [5, 0])"
  status: Exception
  stderr: 'tmp5d0or02d/tmp5d0or02d.swift:45: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b0276059c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b0275d50b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b0275d50988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b0275d4f7b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmp5d0or02d                        0x000056073e3c5384 <unavailable> + 4996

    5    libc.so.6                          0x00002b0276245460 __libc_start_main +
    245

    6    tmp5d0or02d                        0x000056073e3c4fc9 <unavailable> + 4041

    '
  stdout: ''
  timestamp: 1660014019
- exit_code: -4
  program: "\n/// You're a hungry rabbit, and you already have eaten a certain number\
    \ of carrots,\n/// but now you need to eat more carrots to complete the day's\
    \ meals.\n/// you should return an array of [ total number of eaten carrots after\
    \ your meals,\n/// the number of carrots left after your meals ]\n/// if there\
    \ are not enough remaining carrots, you will eat all remaining carrots, but will\
    \ still be hungry.\n/// Example:\n/// >>> eat(number: 5, need: 6, remaining: 10)\n\
    /// [11, 4]\n/// >>> eat(number: 4, need: 8, remaining: 9)\n/// [12, 1]\n/// >>>\
    \ eat(number: 1, need: 10, remaining: 10)\n/// [11, 0]\n/// >>> eat(number: 2,\
    \ need: 11, remaining: 5)\n/// [7, 0]\n/// Variables:\n/// @number : integer\n\
    /// the number of carrots that you have eaten.\n/// @need : integer\n/// the number\
    \ of carrots that you need to eat.\n/// @remaining : integer\n/// the number of\
    \ remaining carrots thet exist in stock\n/// Constrain:\n/// * 0 <= number <=\
    \ 1000\n/// * 0 <= need <= 1000\n/// * 0 <= remaining <= 1000\n/// Have fun :)\n\
    func eat(number: Int, need: Int, remaining: Int) -> [Int] {\n    var eatenCarrots:\
    \ Int = number\n    var numberOfCarrotsLeft: Int = remaining\n    let neededCarrots:\
    \ Int = need - number\n    if neededCarrots > 0 {\n        if neededCarrots <=\
    \ remaining {\n            eatenCarrots += neededCarrots\n            numberOfCarrotsLeft\
    \ -= neededCarrots\n        } else {\n            eatenCarrots += remaining\n\
    \            numberOfCarrotsLeft = 0\n        }\n    }\n    return [eatenCarrots,\
    \ numberOfCarrotsLeft]\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(eat(number:\
    \ 5, need: 6, remaining: 10) == [11, 4])\nassert(eat(number: 4, need: 8, remaining:\
    \ 9) == [12, 1])\nassert(eat(number: 1, need: 10, remaining: 10) == [11, 0])\n\
    assert(eat(number: 2, need: 11, remaining: 5) == [7, 0])\nassert(eat(number: 4,\
    \ need: 5, remaining: 7) == [9, 2])\nassert(eat(number: 4, need: 5, remaining:\
    \ 1) == [5, 0])"
  status: Exception
  stderr: 'tmp1d9o7lse/tmp1d9o7lse.swift:57: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002aec4f786c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002aec4f47db6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002aec4f47d988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002aec4f47c7b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmp1d9o7lse                        0x000055cab3363384 <unavailable> + 4996

    5    libc.so.6                          0x00002aec4f972460 __libc_start_main +
    245

    6    tmp1d9o7lse                        0x000055cab3362fc9 <unavailable> + 4041

    '
  stdout: ''
  timestamp: 1660014021
- exit_code: -4
  program: "\n/// You're a hungry rabbit, and you already have eaten a certain number\
    \ of carrots,\n/// but now you need to eat more carrots to complete the day's\
    \ meals.\n/// you should return an array of [ total number of eaten carrots after\
    \ your meals,\n/// the number of carrots left after your meals ]\n/// if there\
    \ are not enough remaining carrots, you will eat all remaining carrots, but will\
    \ still be hungry.\n/// Example:\n/// >>> eat(number: 5, need: 6, remaining: 10)\n\
    /// [11, 4]\n/// >>> eat(number: 4, need: 8, remaining: 9)\n/// [12, 1]\n/// >>>\
    \ eat(number: 1, need: 10, remaining: 10)\n/// [11, 0]\n/// >>> eat(number: 2,\
    \ need: 11, remaining: 5)\n/// [7, 0]\n/// Variables:\n/// @number : integer\n\
    /// the number of carrots that you have eaten.\n/// @need : integer\n/// the number\
    \ of carrots that you need to eat.\n/// @remaining : integer\n/// the number of\
    \ remaining carrots thet exist in stock\n/// Constrain:\n/// * 0 <= number <=\
    \ 1000\n/// * 0 <= need <= 1000\n/// * 0 <= remaining <= 1000\n/// Have fun :)\n\
    func eat(number: Int, need: Int, remaining: Int) -> [Int] {\n  let total = number\
    \ + remaining\n  if total >= need {\n    return [need, total - need]\n  } else\
    \ {\n    return [total, 0]\n  }\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int,\
    \ Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n\
    \    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n          \
    \  return false\n        }\n    }\n    return true\n}\n            \nassert(eat(number:\
    \ 5, need: 6, remaining: 10) == [11, 4])\nassert(eat(number: 4, need: 8, remaining:\
    \ 9) == [12, 1])\nassert(eat(number: 1, need: 10, remaining: 10) == [11, 0])\n\
    assert(eat(number: 2, need: 11, remaining: 5) == [7, 0])\nassert(eat(number: 4,\
    \ need: 5, remaining: 7) == [9, 2])\nassert(eat(number: 4, need: 5, remaining:\
    \ 1) == [5, 0])"
  status: Exception
  stderr: 'tmpp87foz10/tmpp87foz10.swift:50: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b2004c6ec80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b2004965b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b2004965988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b20049647b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpp87foz10                        0x0000559324721384 <unavailable> + 4996

    5    libc.so.6                          0x00002b2004e5a460 __libc_start_main +
    245

    6    tmpp87foz10                        0x0000559324720fc9 <unavailable> + 4041

    '
  stdout: ''
  timestamp: 1660014021
- exit_code: -4
  program: "\n/// You're a hungry rabbit, and you already have eaten a certain number\
    \ of carrots,\n/// but now you need to eat more carrots to complete the day's\
    \ meals.\n/// you should return an array of [ total number of eaten carrots after\
    \ your meals,\n/// the number of carrots left after your meals ]\n/// if there\
    \ are not enough remaining carrots, you will eat all remaining carrots, but will\
    \ still be hungry.\n/// Example:\n/// >>> eat(number: 5, need: 6, remaining: 10)\n\
    /// [11, 4]\n/// >>> eat(number: 4, need: 8, remaining: 9)\n/// [12, 1]\n/// >>>\
    \ eat(number: 1, need: 10, remaining: 10)\n/// [11, 0]\n/// >>> eat(number: 2,\
    \ need: 11, remaining: 5)\n/// [7, 0]\n/// Variables:\n/// @number : integer\n\
    /// the number of carrots that you have eaten.\n/// @need : integer\n/// the number\
    \ of carrots that you need to eat.\n/// @remaining : integer\n/// the number of\
    \ remaining carrots thet exist in stock\n/// Constrain:\n/// * 0 <= number <=\
    \ 1000\n/// * 0 <= need <= 1000\n/// * 0 <= remaining <= 1000\n/// Have fun :)\n\
    func eat(number: Int, need: Int, remaining: Int) -> [Int] {\n    return [0, 0]\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(eat(number: 5, need: 6, remaining: 10) == [11,\
    \ 4])\nassert(eat(number: 4, need: 8, remaining: 9) == [12, 1])\nassert(eat(number:\
    \ 1, need: 10, remaining: 10) == [11, 0])\nassert(eat(number: 2, need: 11, remaining:\
    \ 5) == [7, 0])\nassert(eat(number: 4, need: 5, remaining: 7) == [9, 2])\nassert(eat(number:\
    \ 4, need: 5, remaining: 1) == [5, 0])"
  status: Exception
  stderr: 'tmpes0rme1m/tmpes0rme1m.swift:45: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002ab15656fc80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002ab156266b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002ab156266988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002ab1562657b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpes0rme1m                        0x000055d20b065384 <unavailable> + 4996

    5    libc.so.6                          0x00002ab15675b460 __libc_start_main +
    245

    6    tmpes0rme1m                        0x000055d20b064fc9 <unavailable> + 4041

    '
  stdout: ''
  timestamp: 1660014019
- exit_code: 0
  program: "\n/// You're a hungry rabbit, and you already have eaten a certain number\
    \ of carrots,\n/// but now you need to eat more carrots to complete the day's\
    \ meals.\n/// you should return an array of [ total number of eaten carrots after\
    \ your meals,\n/// the number of carrots left after your meals ]\n/// if there\
    \ are not enough remaining carrots, you will eat all remaining carrots, but will\
    \ still be hungry.\n/// Example:\n/// >>> eat(number: 5, need: 6, remaining: 10)\n\
    /// [11, 4]\n/// >>> eat(number: 4, need: 8, remaining: 9)\n/// [12, 1]\n/// >>>\
    \ eat(number: 1, need: 10, remaining: 10)\n/// [11, 0]\n/// >>> eat(number: 2,\
    \ need: 11, remaining: 5)\n/// [7, 0]\n/// Variables:\n/// @number : integer\n\
    /// the number of carrots that you have eaten.\n/// @need : integer\n/// the number\
    \ of carrots that you need to eat.\n/// @remaining : integer\n/// the number of\
    \ remaining carrots thet exist in stock\n/// Constrain:\n/// * 0 <= number <=\
    \ 1000\n/// * 0 <= need <= 1000\n/// * 0 <= remaining <= 1000\n/// Have fun :)\n\
    func eat(number: Int, need: Int, remaining: Int) -> [Int] {\n    let n = min(remaining,\
    \ need)\n    return [number + n, remaining - n]\n}\n\n\nfunc ==(left: [(Int, Int)],\
    \ right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n       \
    \ return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r\
    \ {\n            return false\n        }\n    }\n    return true\n}\n        \
    \    \nassert(eat(number: 5, need: 6, remaining: 10) == [11, 4])\nassert(eat(number:\
    \ 4, need: 8, remaining: 9) == [12, 1])\nassert(eat(number: 1, need: 10, remaining:\
    \ 10) == [11, 0])\nassert(eat(number: 2, need: 11, remaining: 5) == [7, 0])\n\
    assert(eat(number: 4, need: 5, remaining: 7) == [9, 2])\nassert(eat(number: 4,\
    \ need: 5, remaining: 1) == [5, 0])"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660014021
- exit_code: -4
  program: "\n/// You're a hungry rabbit, and you already have eaten a certain number\
    \ of carrots,\n/// but now you need to eat more carrots to complete the day's\
    \ meals.\n/// you should return an array of [ total number of eaten carrots after\
    \ your meals,\n/// the number of carrots left after your meals ]\n/// if there\
    \ are not enough remaining carrots, you will eat all remaining carrots, but will\
    \ still be hungry.\n/// Example:\n/// >>> eat(number: 5, need: 6, remaining: 10)\n\
    /// [11, 4]\n/// >>> eat(number: 4, need: 8, remaining: 9)\n/// [12, 1]\n/// >>>\
    \ eat(number: 1, need: 10, remaining: 10)\n/// [11, 0]\n/// >>> eat(number: 2,\
    \ need: 11, remaining: 5)\n/// [7, 0]\n/// Variables:\n/// @number : integer\n\
    /// the number of carrots that you have eaten.\n/// @need : integer\n/// the number\
    \ of carrots that you need to eat.\n/// @remaining : integer\n/// the number of\
    \ remaining carrots thet exist in stock\n/// Constrain:\n/// * 0 <= number <=\
    \ 1000\n/// * 0 <= need <= 1000\n/// * 0 <= remaining <= 1000\n/// Have fun :)\n\
    func eat(number: Int, need: Int, remaining: Int) -> [Int] {\n    let total = number\
    \ + need\n    return total > remaining ? [remaining, 0] : [total, remaining -\
    \ total]\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n\
    \    if left.count != right.count {\n        return false\n    }\n    for (l,\
    \ r) in zip(left, right) {\n        if l != r {\n            return false\n  \
    \      }\n    }\n    return true\n}\n            \nassert(eat(number: 5, need:\
    \ 6, remaining: 10) == [11, 4])\nassert(eat(number: 4, need: 8, remaining: 9)\
    \ == [12, 1])\nassert(eat(number: 1, need: 10, remaining: 10) == [11, 0])\nassert(eat(number:\
    \ 2, need: 11, remaining: 5) == [7, 0])\nassert(eat(number: 4, need: 5, remaining:\
    \ 7) == [9, 2])\nassert(eat(number: 4, need: 5, remaining: 1) == [5, 0])"
  status: Exception
  stderr: 'tmpo3adfpt2/tmpo3adfpt2.swift:46: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002af4daf68c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002af4dac5fb6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002af4dac5f988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002af4dac5e7b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpo3adfpt2                        0x000055b792c2d384 <unavailable> + 4996

    5    libc.so.6                          0x00002af4db154460 __libc_start_main +
    245

    6    tmpo3adfpt2                        0x000055b792c2cfc9 <unavailable> + 4041

    '
  stdout: ''
  timestamp: 1660014021
- exit_code: -4
  program: "\n/// You're a hungry rabbit, and you already have eaten a certain number\
    \ of carrots,\n/// but now you need to eat more carrots to complete the day's\
    \ meals.\n/// you should return an array of [ total number of eaten carrots after\
    \ your meals,\n/// the number of carrots left after your meals ]\n/// if there\
    \ are not enough remaining carrots, you will eat all remaining carrots, but will\
    \ still be hungry.\n/// Example:\n/// >>> eat(number: 5, need: 6, remaining: 10)\n\
    /// [11, 4]\n/// >>> eat(number: 4, need: 8, remaining: 9)\n/// [12, 1]\n/// >>>\
    \ eat(number: 1, need: 10, remaining: 10)\n/// [11, 0]\n/// >>> eat(number: 2,\
    \ need: 11, remaining: 5)\n/// [7, 0]\n/// Variables:\n/// @number : integer\n\
    /// the number of carrots that you have eaten.\n/// @need : integer\n/// the number\
    \ of carrots that you need to eat.\n/// @remaining : integer\n/// the number of\
    \ remaining carrots thet exist in stock\n/// Constrain:\n/// * 0 <= number <=\
    \ 1000\n/// * 0 <= need <= 1000\n/// * 0 <= remaining <= 1000\n/// Have fun :)\n\
    func eat(number: Int, need: Int, remaining: Int) -> [Int] {\n    return []\n}\n\
    \n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(eat(number: 5, need: 6, remaining: 10) == [11,\
    \ 4])\nassert(eat(number: 4, need: 8, remaining: 9) == [12, 1])\nassert(eat(number:\
    \ 1, need: 10, remaining: 10) == [11, 0])\nassert(eat(number: 2, need: 11, remaining:\
    \ 5) == [7, 0])\nassert(eat(number: 4, need: 5, remaining: 7) == [9, 2])\nassert(eat(number:\
    \ 4, need: 5, remaining: 1) == [5, 0])"
  status: Exception
  stderr: 'tmp5d0or02d/tmp5d0or02d.swift:45: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b0276059c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b0275d50b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b0275d50988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b0275d4f7b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmp5d0or02d                        0x000056073e3c5384 <unavailable> + 4996

    5    libc.so.6                          0x00002b0276245460 __libc_start_main +
    245

    6    tmp5d0or02d                        0x000056073e3c4fc9 <unavailable> + 4041

    '
  stdout: ''
  timestamp: 1660014019
- exit_code: 0
  program: "\n/// You're a hungry rabbit, and you already have eaten a certain number\
    \ of carrots,\n/// but now you need to eat more carrots to complete the day's\
    \ meals.\n/// you should return an array of [ total number of eaten carrots after\
    \ your meals,\n/// the number of carrots left after your meals ]\n/// if there\
    \ are not enough remaining carrots, you will eat all remaining carrots, but will\
    \ still be hungry.\n/// Example:\n/// >>> eat(number: 5, need: 6, remaining: 10)\n\
    /// [11, 4]\n/// >>> eat(number: 4, need: 8, remaining: 9)\n/// [12, 1]\n/// >>>\
    \ eat(number: 1, need: 10, remaining: 10)\n/// [11, 0]\n/// >>> eat(number: 2,\
    \ need: 11, remaining: 5)\n/// [7, 0]\n/// Variables:\n/// @number : integer\n\
    /// the number of carrots that you have eaten.\n/// @need : integer\n/// the number\
    \ of carrots that you need to eat.\n/// @remaining : integer\n/// the number of\
    \ remaining carrots thet exist in stock\n/// Constrain:\n/// * 0 <= number <=\
    \ 1000\n/// * 0 <= need <= 1000\n/// * 0 <= remaining <= 1000\n/// Have fun :)\n\
    func eat(number: Int, need: Int, remaining: Int) -> [Int] {\n    let total = number\
    \ + min(need, remaining)\n    let left = remaining - min(need, remaining)\n  \
    \  return [total, left]\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(eat(number:\
    \ 5, need: 6, remaining: 10) == [11, 4])\nassert(eat(number: 4, need: 8, remaining:\
    \ 9) == [12, 1])\nassert(eat(number: 1, need: 10, remaining: 10) == [11, 0])\n\
    assert(eat(number: 2, need: 11, remaining: 5) == [7, 0])\nassert(eat(number: 4,\
    \ need: 5, remaining: 7) == [9, 2])\nassert(eat(number: 4, need: 5, remaining:\
    \ 1) == [5, 0])"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660014021
- exit_code: -4
  program: "\n/// You're a hungry rabbit, and you already have eaten a certain number\
    \ of carrots,\n/// but now you need to eat more carrots to complete the day's\
    \ meals.\n/// you should return an array of [ total number of eaten carrots after\
    \ your meals,\n/// the number of carrots left after your meals ]\n/// if there\
    \ are not enough remaining carrots, you will eat all remaining carrots, but will\
    \ still be hungry.\n/// Example:\n/// >>> eat(number: 5, need: 6, remaining: 10)\n\
    /// [11, 4]\n/// >>> eat(number: 4, need: 8, remaining: 9)\n/// [12, 1]\n/// >>>\
    \ eat(number: 1, need: 10, remaining: 10)\n/// [11, 0]\n/// >>> eat(number: 2,\
    \ need: 11, remaining: 5)\n/// [7, 0]\n/// Variables:\n/// @number : integer\n\
    /// the number of carrots that you have eaten.\n/// @need : integer\n/// the number\
    \ of carrots that you need to eat.\n/// @remaining : integer\n/// the number of\
    \ remaining carrots thet exist in stock\n/// Constrain:\n/// * 0 <= number <=\
    \ 1000\n/// * 0 <= need <= 1000\n/// * 0 <= remaining <= 1000\n/// Have fun :)\n\
    func eat(number: Int, need: Int, remaining: Int) -> [Int] {\n    let x = number\
    \ + remaining\n    if need > x {\n        return [x, 0]\n    } else {\n      \
    \  return [need, x - need]\n    }\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int,\
    \ Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n\
    \    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n          \
    \  return false\n        }\n    }\n    return true\n}\n            \nassert(eat(number:\
    \ 5, need: 6, remaining: 10) == [11, 4])\nassert(eat(number: 4, need: 8, remaining:\
    \ 9) == [12, 1])\nassert(eat(number: 1, need: 10, remaining: 10) == [11, 0])\n\
    assert(eat(number: 2, need: 11, remaining: 5) == [7, 0])\nassert(eat(number: 4,\
    \ need: 5, remaining: 7) == [9, 2])\nassert(eat(number: 4, need: 5, remaining:\
    \ 1) == [5, 0])"
  status: Exception
  stderr: 'tmpg9lhs4sk/tmpg9lhs4sk.swift:50: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002af885c83c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002af88597ab6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002af88597a988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002af8859797b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpg9lhs4sk                        0x0000562d08beb384 <unavailable> + 4996

    5    libc.so.6                          0x00002af885e6f460 __libc_start_main +
    245

    6    tmpg9lhs4sk                        0x0000562d08beafc9 <unavailable> + 4041

    '
  stdout: ''
  timestamp: 1660014021
- exit_code: -4
  program: "\n/// You're a hungry rabbit, and you already have eaten a certain number\
    \ of carrots,\n/// but now you need to eat more carrots to complete the day's\
    \ meals.\n/// you should return an array of [ total number of eaten carrots after\
    \ your meals,\n/// the number of carrots left after your meals ]\n/// if there\
    \ are not enough remaining carrots, you will eat all remaining carrots, but will\
    \ still be hungry.\n/// Example:\n/// >>> eat(number: 5, need: 6, remaining: 10)\n\
    /// [11, 4]\n/// >>> eat(number: 4, need: 8, remaining: 9)\n/// [12, 1]\n/// >>>\
    \ eat(number: 1, need: 10, remaining: 10)\n/// [11, 0]\n/// >>> eat(number: 2,\
    \ need: 11, remaining: 5)\n/// [7, 0]\n/// Variables:\n/// @number : integer\n\
    /// the number of carrots that you have eaten.\n/// @need : integer\n/// the number\
    \ of carrots that you need to eat.\n/// @remaining : integer\n/// the number of\
    \ remaining carrots thet exist in stock\n/// Constrain:\n/// * 0 <= number <=\
    \ 1000\n/// * 0 <= need <= 1000\n/// * 0 <= remaining <= 1000\n/// Have fun :)\n\
    func eat(number: Int, need: Int, remaining: Int) -> [Int] {\n    var carrotsRemaining\
    \ = remaining - (need - number)\n    var carrotsEaten = need\n    if carrotsRemaining\
    \ <= 0 {\n        carrotsEaten = number + remaining\n        carrotsRemaining\
    \ = 0\n    }\n    return [carrotsEaten, carrotsRemaining]\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(eat(number: 5, need: 6, remaining: 10) == [11, 4])\nassert(eat(number:\
    \ 4, need: 8, remaining: 9) == [12, 1])\nassert(eat(number: 1, need: 10, remaining:\
    \ 10) == [11, 0])\nassert(eat(number: 2, need: 11, remaining: 5) == [7, 0])\n\
    assert(eat(number: 4, need: 5, remaining: 7) == [9, 2])\nassert(eat(number: 4,\
    \ need: 5, remaining: 1) == [5, 0])"
  status: Exception
  stderr: 'tmpb8qv76o1/tmpb8qv76o1.swift:51: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002ba4f5df1c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002ba4f5ae8b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002ba4f5ae8988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002ba4f5ae77b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpb8qv76o1                        0x000055fdaec39384 <unavailable> + 4996

    5    libc.so.6                          0x00002ba4f5fdd460 __libc_start_main +
    245

    6    tmpb8qv76o1                        0x000055fdaec38fc9 <unavailable> + 4041

    '
  stdout: ''
  timestamp: 1660014021
- exit_code: -4
  program: "\n/// You're a hungry rabbit, and you already have eaten a certain number\
    \ of carrots,\n/// but now you need to eat more carrots to complete the day's\
    \ meals.\n/// you should return an array of [ total number of eaten carrots after\
    \ your meals,\n/// the number of carrots left after your meals ]\n/// if there\
    \ are not enough remaining carrots, you will eat all remaining carrots, but will\
    \ still be hungry.\n/// Example:\n/// >>> eat(number: 5, need: 6, remaining: 10)\n\
    /// [11, 4]\n/// >>> eat(number: 4, need: 8, remaining: 9)\n/// [12, 1]\n/// >>>\
    \ eat(number: 1, need: 10, remaining: 10)\n/// [11, 0]\n/// >>> eat(number: 2,\
    \ need: 11, remaining: 5)\n/// [7, 0]\n/// Variables:\n/// @number : integer\n\
    /// the number of carrots that you have eaten.\n/// @need : integer\n/// the number\
    \ of carrots that you need to eat.\n/// @remaining : integer\n/// the number of\
    \ remaining carrots thet exist in stock\n/// Constrain:\n/// * 0 <= number <=\
    \ 1000\n/// * 0 <= need <= 1000\n/// * 0 <= remaining <= 1000\n/// Have fun :)\n\
    func eat(number: Int, need: Int, remaining: Int) -> [Int] {\n  let total = number\
    \ + remaining\n  if total >= need {\n    return [need, total - need]\n  } else\
    \ {\n    return [total, 0]\n  }\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int,\
    \ Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n\
    \    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n          \
    \  return false\n        }\n    }\n    return true\n}\n            \nassert(eat(number:\
    \ 5, need: 6, remaining: 10) == [11, 4])\nassert(eat(number: 4, need: 8, remaining:\
    \ 9) == [12, 1])\nassert(eat(number: 1, need: 10, remaining: 10) == [11, 0])\n\
    assert(eat(number: 2, need: 11, remaining: 5) == [7, 0])\nassert(eat(number: 4,\
    \ need: 5, remaining: 7) == [9, 2])\nassert(eat(number: 4, need: 5, remaining:\
    \ 1) == [5, 0])"
  status: Exception
  stderr: 'tmpp87foz10/tmpp87foz10.swift:50: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b2004c6ec80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b2004965b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b2004965988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b20049647b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpp87foz10                        0x0000559324721384 <unavailable> + 4996

    5    libc.so.6                          0x00002b2004e5a460 __libc_start_main +
    245

    6    tmpp87foz10                        0x0000559324720fc9 <unavailable> + 4041

    '
  stdout: ''
  timestamp: 1660014021
