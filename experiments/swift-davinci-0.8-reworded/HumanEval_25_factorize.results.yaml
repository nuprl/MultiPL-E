language: swift
name: HumanEval_25_factorize
results:
- exit_code: 0
  program: "\n/// Return array of prime factors of given integer in the order from\
    \ smallest to largest.\n/// Each of the factors should be arrayed number of times\
    \ corresponding to how many times it appeares in factorization.\n/// Input number\
    \ should be equal to the product of all factors\n/// >>> factorize(n: 8)\n///\
    \ [2, 2, 2]\n/// >>> factorize(n: 25)\n/// [5, 5]\n/// >>> factorize(n: 70)\n\
    /// [2, 5, 7]\nfunc factorize(n: Int) -> [Int] {\n    var number = n\n    var\
    \ result = [Int]()\n    var divider = 2\n    while divider * divider <= number\
    \ {\n        if number % divider == 0 {\n            number /= divider\n     \
    \       result.append(divider)\n        } else {\n            divider += 1\n \
    \       }\n    }\n    result.append(number)\n    return result\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(factorize(n: 2) == [2])\nassert(factorize(n: 4) == [2,\
    \ 2])\nassert(factorize(n: 8) == [2, 2, 2])\nassert(factorize(n: 57) == [3, 19])\n\
    assert(factorize(n: 3249) == [3, 3, 19, 19])\nassert(factorize(n: 185193) == [3,\
    \ 3, 3, 19, 19, 19])\nassert(factorize(n: 20577) == [3, 19, 19, 19])\nassert(factorize(n:\
    \ 18) == [2, 3, 3])"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660009191
- exit_code: 0
  program: "\n/// Return array of prime factors of given integer in the order from\
    \ smallest to largest.\n/// Each of the factors should be arrayed number of times\
    \ corresponding to how many times it appeares in factorization.\n/// Input number\
    \ should be equal to the product of all factors\n/// >>> factorize(n: 8)\n///\
    \ [2, 2, 2]\n/// >>> factorize(n: 25)\n/// [5, 5]\n/// >>> factorize(n: 70)\n\
    /// [2, 5, 7]\nfunc factorize(n: Int) -> [Int] {\n    var n = n\n    var factors\
    \ = [Int]()\n    var i = 2\n    while i <= n {\n        if n % i == 0 {\n    \
    \        factors.append(i)\n            n /= i\n        } else {\n           \
    \ i += 1\n        }\n    }\n    return factors\n}\n\n\nfunc ==(left: [(Int, Int)],\
    \ right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n       \
    \ return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r\
    \ {\n            return false\n        }\n    }\n    return true\n}\n        \
    \    \nassert(factorize(n: 2) == [2])\nassert(factorize(n: 4) == [2, 2])\nassert(factorize(n:\
    \ 8) == [2, 2, 2])\nassert(factorize(n: 57) == [3, 19])\nassert(factorize(n: 3249)\
    \ == [3, 3, 19, 19])\nassert(factorize(n: 185193) == [3, 3, 3, 19, 19, 19])\n\
    assert(factorize(n: 20577) == [3, 19, 19, 19])\nassert(factorize(n: 18) == [2,\
    \ 3, 3])"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660009191
- exit_code: 0
  program: "\n/// Return array of prime factors of given integer in the order from\
    \ smallest to largest.\n/// Each of the factors should be arrayed number of times\
    \ corresponding to how many times it appeares in factorization.\n/// Input number\
    \ should be equal to the product of all factors\n/// >>> factorize(n: 8)\n///\
    \ [2, 2, 2]\n/// >>> factorize(n: 25)\n/// [5, 5]\n/// >>> factorize(n: 70)\n\
    /// [2, 5, 7]\nfunc factorize(n: Int) -> [Int] {\n    var number = n\n    var\
    \ factors = [Int]()\n    var factor = 2\n    while factor * factor <= number {\n\
    \        while number % factor == 0 {\n            factors.append(factor)\n  \
    \          number /= factor\n        }\n        factor += 1\n    }\n    if number\
    \ > 1 {\n        factors.append(number)\n    }\n    return factors\n}\n\n\nfunc\
    \ ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count !=\
    \ right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(factorize(n: 2) == [2])\nassert(factorize(n: 4)\
    \ == [2, 2])\nassert(factorize(n: 8) == [2, 2, 2])\nassert(factorize(n: 57) ==\
    \ [3, 19])\nassert(factorize(n: 3249) == [3, 3, 19, 19])\nassert(factorize(n:\
    \ 185193) == [3, 3, 3, 19, 19, 19])\nassert(factorize(n: 20577) == [3, 19, 19,\
    \ 19])\nassert(factorize(n: 18) == [2, 3, 3])"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660009191
- exit_code: 0
  program: "\n/// Return array of prime factors of given integer in the order from\
    \ smallest to largest.\n/// Each of the factors should be arrayed number of times\
    \ corresponding to how many times it appeares in factorization.\n/// Input number\
    \ should be equal to the product of all factors\n/// >>> factorize(n: 8)\n///\
    \ [2, 2, 2]\n/// >>> factorize(n: 25)\n/// [5, 5]\n/// >>> factorize(n: 70)\n\
    /// [2, 5, 7]\nfunc factorize(n: Int) -> [Int] {\n    if n == 1 {\n        return\
    \ []\n    }\n    var res = [Int]()\n    var n = n\n    var i = 2\n    while i\
    \ * i <= n {\n        while n % i == 0 {\n            res.append(i)\n        \
    \    n /= i\n        }\n        i += 1\n    }\n    if n > 1 {\n        res.append(n)\n\
    \    }\n    return res\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(factorize(n:\
    \ 2) == [2])\nassert(factorize(n: 4) == [2, 2])\nassert(factorize(n: 8) == [2,\
    \ 2, 2])\nassert(factorize(n: 57) == [3, 19])\nassert(factorize(n: 3249) == [3,\
    \ 3, 19, 19])\nassert(factorize(n: 185193) == [3, 3, 3, 19, 19, 19])\nassert(factorize(n:\
    \ 20577) == [3, 19, 19, 19])\nassert(factorize(n: 18) == [2, 3, 3])"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660009191
- exit_code: 0
  program: "\n/// Return array of prime factors of given integer in the order from\
    \ smallest to largest.\n/// Each of the factors should be arrayed number of times\
    \ corresponding to how many times it appeares in factorization.\n/// Input number\
    \ should be equal to the product of all factors\n/// >>> factorize(n: 8)\n///\
    \ [2, 2, 2]\n/// >>> factorize(n: 25)\n/// [5, 5]\n/// >>> factorize(n: 70)\n\
    /// [2, 5, 7]\nfunc factorize(n: Int) -> [Int] {\n    var copy = n\n    var result:\
    \ [Int] = []\n    for i in 2...n {\n        while copy % i == 0 {\n          \
    \  result.append(i)\n            copy /= i\n        }\n    }\n    return result\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(factorize(n: 2) == [2])\nassert(factorize(n: 4)\
    \ == [2, 2])\nassert(factorize(n: 8) == [2, 2, 2])\nassert(factorize(n: 57) ==\
    \ [3, 19])\nassert(factorize(n: 3249) == [3, 3, 19, 19])\nassert(factorize(n:\
    \ 185193) == [3, 3, 3, 19, 19, 19])\nassert(factorize(n: 20577) == [3, 19, 19,\
    \ 19])\nassert(factorize(n: 18) == [2, 3, 3])"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660009191
- exit_code: 0
  program: "\n/// Return array of prime factors of given integer in the order from\
    \ smallest to largest.\n/// Each of the factors should be arrayed number of times\
    \ corresponding to how many times it appeares in factorization.\n/// Input number\
    \ should be equal to the product of all factors\n/// >>> factorize(n: 8)\n///\
    \ [2, 2, 2]\n/// >>> factorize(n: 25)\n/// [5, 5]\n/// >>> factorize(n: 70)\n\
    /// [2, 5, 7]\nfunc factorize(n: Int) -> [Int] {\n    guard n > 1 else { return\
    \ [] }\n    var number = n\n    var factors = [Int]()\n    var i = 2\n    while\
    \ number > 1 {\n        if number % i == 0 {\n            factors.append(i)\n\
    \            number /= i\n        } else {\n            i += 1\n        }\n  \
    \  }\n    return factors\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(factorize(n:\
    \ 2) == [2])\nassert(factorize(n: 4) == [2, 2])\nassert(factorize(n: 8) == [2,\
    \ 2, 2])\nassert(factorize(n: 57) == [3, 19])\nassert(factorize(n: 3249) == [3,\
    \ 3, 19, 19])\nassert(factorize(n: 185193) == [3, 3, 3, 19, 19, 19])\nassert(factorize(n:\
    \ 20577) == [3, 19, 19, 19])\nassert(factorize(n: 18) == [2, 3, 3])"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660009191
- exit_code: 0
  program: "\n/// Return array of prime factors of given integer in the order from\
    \ smallest to largest.\n/// Each of the factors should be arrayed number of times\
    \ corresponding to how many times it appeares in factorization.\n/// Input number\
    \ should be equal to the product of all factors\n/// >>> factorize(n: 8)\n///\
    \ [2, 2, 2]\n/// >>> factorize(n: 25)\n/// [5, 5]\n/// >>> factorize(n: 70)\n\
    /// [2, 5, 7]\nfunc factorize(n: Int) -> [Int] {\n    var n = n\n    var result\
    \ = [Int]()\n    var i = 2\n    while i * i <= n {\n        while n % i == 0 {\n\
    \            result.append(i)\n            n /= i\n        }\n        i += 1\n\
    \    }\n    if n > 1 {\n        result.append(n)\n    }\n    return result\n}\n\
    \n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(factorize(n: 2) == [2])\nassert(factorize(n: 4)\
    \ == [2, 2])\nassert(factorize(n: 8) == [2, 2, 2])\nassert(factorize(n: 57) ==\
    \ [3, 19])\nassert(factorize(n: 3249) == [3, 3, 19, 19])\nassert(factorize(n:\
    \ 185193) == [3, 3, 3, 19, 19, 19])\nassert(factorize(n: 20577) == [3, 19, 19,\
    \ 19])\nassert(factorize(n: 18) == [2, 3, 3])"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660009191
- exit_code: 0
  program: "\n/// Return array of prime factors of given integer in the order from\
    \ smallest to largest.\n/// Each of the factors should be arrayed number of times\
    \ corresponding to how many times it appeares in factorization.\n/// Input number\
    \ should be equal to the product of all factors\n/// >>> factorize(n: 8)\n///\
    \ [2, 2, 2]\n/// >>> factorize(n: 25)\n/// [5, 5]\n/// >>> factorize(n: 70)\n\
    /// [2, 5, 7]\nfunc factorize(n: Int) -> [Int] {\n    var _n = n\n    var i =\
    \ 2\n    var factors = [Int]()\n    while i * i <= _n {\n        while _n % i\
    \ == 0 {\n            factors.append(i)\n            _n /= i\n        }\n    \
    \    i += 1\n    }\n    if _n > 1 {\n        factors.append(_n)\n    }\n    return\
    \ factors\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n\
    \    if left.count != right.count {\n        return false\n    }\n    for (l,\
    \ r) in zip(left, right) {\n        if l != r {\n            return false\n  \
    \      }\n    }\n    return true\n}\n            \nassert(factorize(n: 2) == [2])\n\
    assert(factorize(n: 4) == [2, 2])\nassert(factorize(n: 8) == [2, 2, 2])\nassert(factorize(n:\
    \ 57) == [3, 19])\nassert(factorize(n: 3249) == [3, 3, 19, 19])\nassert(factorize(n:\
    \ 185193) == [3, 3, 3, 19, 19, 19])\nassert(factorize(n: 20577) == [3, 19, 19,\
    \ 19])\nassert(factorize(n: 18) == [2, 3, 3])"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660009191
- exit_code: 0
  program: "\n/// Return array of prime factors of given integer in the order from\
    \ smallest to largest.\n/// Each of the factors should be arrayed number of times\
    \ corresponding to how many times it appeares in factorization.\n/// Input number\
    \ should be equal to the product of all factors\n/// >>> factorize(n: 8)\n///\
    \ [2, 2, 2]\n/// >>> factorize(n: 25)\n/// [5, 5]\n/// >>> factorize(n: 70)\n\
    /// [2, 5, 7]\nfunc factorize(n: Int) -> [Int] {\n    var n = n\n    var result\
    \ = [Int]()\n    for i in 2...n {\n        while n % i == 0 {\n            result.append(i)\n\
    \            n /= i\n        }\n    }\n    return result\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(factorize(n: 2) == [2])\nassert(factorize(n: 4) == [2,\
    \ 2])\nassert(factorize(n: 8) == [2, 2, 2])\nassert(factorize(n: 57) == [3, 19])\n\
    assert(factorize(n: 3249) == [3, 3, 19, 19])\nassert(factorize(n: 185193) == [3,\
    \ 3, 3, 19, 19, 19])\nassert(factorize(n: 20577) == [3, 19, 19, 19])\nassert(factorize(n:\
    \ 18) == [2, 3, 3])"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660009191
- exit_code: 0
  program: "\n/// Return array of prime factors of given integer in the order from\
    \ smallest to largest.\n/// Each of the factors should be arrayed number of times\
    \ corresponding to how many times it appeares in factorization.\n/// Input number\
    \ should be equal to the product of all factors\n/// >>> factorize(n: 8)\n///\
    \ [2, 2, 2]\n/// >>> factorize(n: 25)\n/// [5, 5]\n/// >>> factorize(n: 70)\n\
    /// [2, 5, 7]\nfunc factorize(n: Int) -> [Int] {\n  var a = n\n  var result =\
    \ [Int]()\n  var divisor = 2\n  while a != 1 {\n    if a % divisor == 0 {\n  \
    \    result.append(divisor)\n      a /= divisor\n    } else {\n      divisor +=\
    \ 1\n    }\n  }\n  return result\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int,\
    \ Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n\
    \    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n          \
    \  return false\n        }\n    }\n    return true\n}\n            \nassert(factorize(n:\
    \ 2) == [2])\nassert(factorize(n: 4) == [2, 2])\nassert(factorize(n: 8) == [2,\
    \ 2, 2])\nassert(factorize(n: 57) == [3, 19])\nassert(factorize(n: 3249) == [3,\
    \ 3, 19, 19])\nassert(factorize(n: 185193) == [3, 3, 3, 19, 19, 19])\nassert(factorize(n:\
    \ 20577) == [3, 19, 19, 19])\nassert(factorize(n: 18) == [2, 3, 3])"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660009191
- exit_code: 1
  program: "\n/// Return array of prime factors of given integer in the order from\
    \ smallest to largest.\n/// Each of the factors should be arrayed number of times\
    \ corresponding to how many times it appeares in factorization.\n/// Input number\
    \ should be equal to the product of all factors\n/// >>> factorize(n: 8)\n///\
    \ [2, 2, 2]\n/// >>> factorize(n: 25)\n/// [5, 5]\n/// >>> factorize(n: 70)\n\
    /// [2, 5, 7]\nfunc factorize(n: Int) -> [Int] {\n    \n    if n < 2 {\n     \
    \   return []\n    }\n    \n    var result = [Int]()\n    var i = 2\n    while\
    \ i <= n {\n        if n % i == 0 {\n            result.append(i)\n          \
    \  n /= i\n        } else {\n            i += 1\n        }\n    }\n    \n    return\
    \ result\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n\
    \    if left.count != right.count {\n        return false\n    }\n    for (l,\
    \ r) in zip(left, right) {\n        if l != r {\n            return false\n  \
    \      }\n    }\n    return true\n}\n            \nassert(factorize(n: 2) == [2])\n\
    assert(factorize(n: 4) == [2, 2])\nassert(factorize(n: 8) == [2, 2, 2])\nassert(factorize(n:\
    \ 57) == [3, 19])\nassert(factorize(n: 3249) == [3, 3, 19, 19])\nassert(factorize(n:\
    \ 185193) == [3, 3, 3, 19, 19, 19])\nassert(factorize(n: 20577) == [3, 19, 19,\
    \ 19])\nassert(factorize(n: 18) == [2, 3, 3])"
  status: SyntaxError
  stderr: "/tmp/tmp8sq9tz28.swift:22:15: error: left side of mutating operator isn't\
    \ mutable: 'n' is a 'let' constant\n            n /= i\n            ~ ^\n"
  stdout: ''
  timestamp: 1660009191
- exit_code: 0
  program: "\n/// Return array of prime factors of given integer in the order from\
    \ smallest to largest.\n/// Each of the factors should be arrayed number of times\
    \ corresponding to how many times it appeares in factorization.\n/// Input number\
    \ should be equal to the product of all factors\n/// >>> factorize(n: 8)\n///\
    \ [2, 2, 2]\n/// >>> factorize(n: 25)\n/// [5, 5]\n/// >>> factorize(n: 70)\n\
    /// [2, 5, 7]\nfunc factorize(n: Int) -> [Int] {\n    var factors: [Int] = []\n\
    \    var currentNumber = n\n    var i = 2\n    while i * i <= currentNumber {\n\
    \        if currentNumber % i == 0 {\n            factors.append(i)\n        \
    \    currentNumber /= i\n        } else {\n            i += 1\n        }\n   \
    \ }\n    if currentNumber > 1 {\n        factors.append(currentNumber)\n    }\n\
    \    return factors\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) ->\
    \ Bool {\n    if left.count != right.count {\n        return false\n    }\n  \
    \  for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(factorize(n: 2) ==\
    \ [2])\nassert(factorize(n: 4) == [2, 2])\nassert(factorize(n: 8) == [2, 2, 2])\n\
    assert(factorize(n: 57) == [3, 19])\nassert(factorize(n: 3249) == [3, 3, 19, 19])\n\
    assert(factorize(n: 185193) == [3, 3, 3, 19, 19, 19])\nassert(factorize(n: 20577)\
    \ == [3, 19, 19, 19])\nassert(factorize(n: 18) == [2, 3, 3])"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660009191
- exit_code: 1
  program: "\n/// Return array of prime factors of given integer in the order from\
    \ smallest to largest.\n/// Each of the factors should be arrayed number of times\
    \ corresponding to how many times it appeares in factorization.\n/// Input number\
    \ should be equal to the product of all factors\n/// >>> factorize(n: 8)\n///\
    \ [2, 2, 2]\n/// >>> factorize(n: 25)\n/// [5, 5]\n/// >>> factorize(n: 70)\n\
    /// [2, 5, 7]\nfunc factorize(n: Int) -> [Int] {\n  guard n > 1 else { return\
    \ [] }\n  for i in 2...Int(sqrt(Double(n))) {\n    if n % i == 0 {\n      return\
    \ [i] + factorize(n: n / i)\n    }\n  }\n  return [n]\n}\n\n\nfunc ==(left: [(Int,\
    \ Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n\
    \        return false\n    }\n    for (l, r) in zip(left, right) {\n        if\
    \ l != r {\n            return false\n        }\n    }\n    return true\n}\n \
    \           \nassert(factorize(n: 2) == [2])\nassert(factorize(n: 4) == [2, 2])\n\
    assert(factorize(n: 8) == [2, 2, 2])\nassert(factorize(n: 57) == [3, 19])\nassert(factorize(n:\
    \ 3249) == [3, 3, 19, 19])\nassert(factorize(n: 185193) == [3, 3, 3, 19, 19, 19])\n\
    assert(factorize(n: 20577) == [3, 19, 19, 19])\nassert(factorize(n: 18) == [2,\
    \ 3, 3])"
  status: SyntaxError
  stderr: "/tmp/tmp1dcj59tz.swift:13:20: error: cannot find 'sqrt' in scope\n  for\
    \ i in 2...Int(sqrt(Double(n))) {\n                   ^~~~\n"
  stdout: ''
  timestamp: 1660009191
- exit_code: 0
  program: "\n/// Return array of prime factors of given integer in the order from\
    \ smallest to largest.\n/// Each of the factors should be arrayed number of times\
    \ corresponding to how many times it appeares in factorization.\n/// Input number\
    \ should be equal to the product of all factors\n/// >>> factorize(n: 8)\n///\
    \ [2, 2, 2]\n/// >>> factorize(n: 25)\n/// [5, 5]\n/// >>> factorize(n: 70)\n\
    /// [2, 5, 7]\nfunc factorize(n: Int) -> [Int] {\n    var res: [Int] = []\n  \
    \  var tmp = n\n    for i in 2...n {\n        while tmp % i == 0 {\n         \
    \   res.append(i)\n            tmp /= i\n        }\n    }\n    return res\n}\n\
    \n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(factorize(n: 2) == [2])\nassert(factorize(n: 4)\
    \ == [2, 2])\nassert(factorize(n: 8) == [2, 2, 2])\nassert(factorize(n: 57) ==\
    \ [3, 19])\nassert(factorize(n: 3249) == [3, 3, 19, 19])\nassert(factorize(n:\
    \ 185193) == [3, 3, 3, 19, 19, 19])\nassert(factorize(n: 20577) == [3, 19, 19,\
    \ 19])\nassert(factorize(n: 18) == [2, 3, 3])"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660009191
- exit_code: 1
  program: "\n/// Return array of prime factors of given integer in the order from\
    \ smallest to largest.\n/// Each of the factors should be arrayed number of times\
    \ corresponding to how many times it appeares in factorization.\n/// Input number\
    \ should be equal to the product of all factors\n/// >>> factorize(n: 8)\n///\
    \ [2, 2, 2]\n/// >>> factorize(n: 25)\n/// [5, 5]\n/// >>> factorize(n: 70)\n\
    /// [2, 5, 7]\nfunc factorize(n: Int) -> [Int] {\n    var factors: [Int] = []\n\
    \    if n < 2 {\n        return factors\n    }\n    let half = Int(ceil(Double(n)\
    \ / 2.0))\n    for i in 2...half {\n        if n % i == 0 {\n            factors.append(i)\n\
    \            factors.append(contentsOf: factorize(n: n / i))\n            break\n\
    \        }\n    }\n    if factors.count == 0 {\n        factors.append(n)\n  \
    \  }\n    return factors\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(factorize(n:\
    \ 2) == [2])\nassert(factorize(n: 4) == [2, 2])\nassert(factorize(n: 8) == [2,\
    \ 2, 2])\nassert(factorize(n: 57) == [3, 19])\nassert(factorize(n: 3249) == [3,\
    \ 3, 19, 19])\nassert(factorize(n: 185193) == [3, 3, 3, 19, 19, 19])\nassert(factorize(n:\
    \ 20577) == [3, 19, 19, 19])\nassert(factorize(n: 18) == [2, 3, 3])"
  status: SyntaxError
  stderr: "/tmp/tmp6bnuy5rr.swift:16:20: error: cannot find 'ceil' in scope\n    let\
    \ half = Int(ceil(Double(n) / 2.0))\n                   ^~~~\n"
  stdout: ''
  timestamp: 1660009191
- exit_code: 0
  program: "\n/// Return array of prime factors of given integer in the order from\
    \ smallest to largest.\n/// Each of the factors should be arrayed number of times\
    \ corresponding to how many times it appeares in factorization.\n/// Input number\
    \ should be equal to the product of all factors\n/// >>> factorize(n: 8)\n///\
    \ [2, 2, 2]\n/// >>> factorize(n: 25)\n/// [5, 5]\n/// >>> factorize(n: 70)\n\
    /// [2, 5, 7]\nfunc factorize(n: Int) -> [Int] {\n  var value = n\n  var factors\
    \ = [Int]()\n  var divisor = 2\n  while value > 1 {\n    while value % divisor\
    \ == 0 {\n      factors.append(divisor)\n      value /= divisor\n    }\n    divisor\
    \ += 1\n  }\n  return factors\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int,\
    \ Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n\
    \    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n          \
    \  return false\n        }\n    }\n    return true\n}\n            \nassert(factorize(n:\
    \ 2) == [2])\nassert(factorize(n: 4) == [2, 2])\nassert(factorize(n: 8) == [2,\
    \ 2, 2])\nassert(factorize(n: 57) == [3, 19])\nassert(factorize(n: 3249) == [3,\
    \ 3, 19, 19])\nassert(factorize(n: 185193) == [3, 3, 3, 19, 19, 19])\nassert(factorize(n:\
    \ 20577) == [3, 19, 19, 19])\nassert(factorize(n: 18) == [2, 3, 3])"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660009191
- exit_code: 0
  program: "\n/// Return array of prime factors of given integer in the order from\
    \ smallest to largest.\n/// Each of the factors should be arrayed number of times\
    \ corresponding to how many times it appeares in factorization.\n/// Input number\
    \ should be equal to the product of all factors\n/// >>> factorize(n: 8)\n///\
    \ [2, 2, 2]\n/// >>> factorize(n: 25)\n/// [5, 5]\n/// >>> factorize(n: 70)\n\
    /// [2, 5, 7]\nfunc factorize(n: Int) -> [Int] {\n    var number = n\n    var\
    \ factors = [Int]()\n    var divisor = 2\n    while number != 1 {\n        while\
    \ number % divisor == 0 {\n            factors.append(divisor)\n            number\
    \ /= divisor\n        }\n        divisor += 1\n    }\n    return factors\n}\n\n\
    \nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(factorize(n: 2) == [2])\nassert(factorize(n: 4)\
    \ == [2, 2])\nassert(factorize(n: 8) == [2, 2, 2])\nassert(factorize(n: 57) ==\
    \ [3, 19])\nassert(factorize(n: 3249) == [3, 3, 19, 19])\nassert(factorize(n:\
    \ 185193) == [3, 3, 3, 19, 19, 19])\nassert(factorize(n: 20577) == [3, 19, 19,\
    \ 19])\nassert(factorize(n: 18) == [2, 3, 3])"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660009191
- exit_code: 1
  program: "\n/// Return array of prime factors of given integer in the order from\
    \ smallest to largest.\n/// Each of the factors should be arrayed number of times\
    \ corresponding to how many times it appeares in factorization.\n/// Input number\
    \ should be equal to the product of all factors\n/// >>> factorize(n: 8)\n///\
    \ [2, 2, 2]\n/// >>> factorize(n: 25)\n/// [5, 5]\n/// >>> factorize(n: 70)\n\
    /// [2, 5, 7]\nfunc factorize(n: Int) -> [Int] {\n    var array = [Int]()\n  \
    \  var value = n\n    while value % 2 == 0 {\n        array.append(2)\n      \
    \  value /= 2\n    }\n    var i = 3\n    while i <= Int(sqrt(Double(value))) {\n\
    \        while value % i == 0 {\n            array.append(i)\n            value\
    \ /= i\n        }\n        i += 2\n    }\n    if value > 2 {\n        array.append(value)\n\
    \    }\n    return array\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(factorize(n:\
    \ 2) == [2])\nassert(factorize(n: 4) == [2, 2])\nassert(factorize(n: 8) == [2,\
    \ 2, 2])\nassert(factorize(n: 57) == [3, 19])\nassert(factorize(n: 3249) == [3,\
    \ 3, 19, 19])\nassert(factorize(n: 185193) == [3, 3, 3, 19, 19, 19])\nassert(factorize(n:\
    \ 20577) == [3, 19, 19, 19])\nassert(factorize(n: 18) == [2, 3, 3])"
  status: SyntaxError
  stderr: "/tmp/tmpd5_lv0ox.swift:19:20: error: cannot find 'sqrt' in scope\n    while\
    \ i <= Int(sqrt(Double(value))) {\n                   ^~~~\n"
  stdout: ''
  timestamp: 1660009191
- exit_code: 0
  program: "\n/// Return array of prime factors of given integer in the order from\
    \ smallest to largest.\n/// Each of the factors should be arrayed number of times\
    \ corresponding to how many times it appeares in factorization.\n/// Input number\
    \ should be equal to the product of all factors\n/// >>> factorize(n: 8)\n///\
    \ [2, 2, 2]\n/// >>> factorize(n: 25)\n/// [5, 5]\n/// >>> factorize(n: 70)\n\
    /// [2, 5, 7]\nfunc factorize(n: Int) -> [Int] {\n    var n = n\n    var factors\
    \ = [Int]()\n    var prime = 2\n    while n > 1 {\n        if n % prime == 0 {\n\
    \            factors.append(prime)\n            n /= prime\n        } else {\n\
    \            prime += 1\n        }\n    }\n    return factors\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(factorize(n: 2) == [2])\nassert(factorize(n: 4) == [2,\
    \ 2])\nassert(factorize(n: 8) == [2, 2, 2])\nassert(factorize(n: 57) == [3, 19])\n\
    assert(factorize(n: 3249) == [3, 3, 19, 19])\nassert(factorize(n: 185193) == [3,\
    \ 3, 3, 19, 19, 19])\nassert(factorize(n: 20577) == [3, 19, 19, 19])\nassert(factorize(n:\
    \ 18) == [2, 3, 3])"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660009191
- exit_code: 0
  program: "\n/// Return array of prime factors of given integer in the order from\
    \ smallest to largest.\n/// Each of the factors should be arrayed number of times\
    \ corresponding to how many times it appeares in factorization.\n/// Input number\
    \ should be equal to the product of all factors\n/// >>> factorize(n: 8)\n///\
    \ [2, 2, 2]\n/// >>> factorize(n: 25)\n/// [5, 5]\n/// >>> factorize(n: 70)\n\
    /// [2, 5, 7]\nfunc factorize(n: Int) -> [Int] {\n    var factors: [Int] = []\n\
    \    var n = n\n    while n > 1 {\n        for i in 2...n {\n            if n\
    \ % i == 0 {\n                factors.append(i)\n                n /= i\n    \
    \            break\n            }\n        }\n    }\n    return factors\n}\n\n\
    \nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(factorize(n: 2) == [2])\nassert(factorize(n: 4)\
    \ == [2, 2])\nassert(factorize(n: 8) == [2, 2, 2])\nassert(factorize(n: 57) ==\
    \ [3, 19])\nassert(factorize(n: 3249) == [3, 3, 19, 19])\nassert(factorize(n:\
    \ 185193) == [3, 3, 3, 19, 19, 19])\nassert(factorize(n: 20577) == [3, 19, 19,\
    \ 19])\nassert(factorize(n: 18) == [2, 3, 3])"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660009191
- exit_code: 0
  program: "\n/// Return array of prime factors of given integer in the order from\
    \ smallest to largest.\n/// Each of the factors should be arrayed number of times\
    \ corresponding to how many times it appeares in factorization.\n/// Input number\
    \ should be equal to the product of all factors\n/// >>> factorize(n: 8)\n///\
    \ [2, 2, 2]\n/// >>> factorize(n: 25)\n/// [5, 5]\n/// >>> factorize(n: 70)\n\
    /// [2, 5, 7]\nfunc factorize(n: Int) -> [Int] {\n    var x = n\n    var divisor\
    \ = 2\n    var ret: [Int] = []\n    while divisor * divisor <= x {\n        if\
    \ x % divisor == 0 {\n            ret.append(divisor)\n            x /= divisor\n\
    \        } else {\n            divisor += 1\n        }\n    }\n    if x > 1 {\n\
    \        ret.append(x)\n    }\n    return ret\n}\n\n\nfunc ==(left: [(Int, Int)],\
    \ right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n       \
    \ return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r\
    \ {\n            return false\n        }\n    }\n    return true\n}\n        \
    \    \nassert(factorize(n: 2) == [2])\nassert(factorize(n: 4) == [2, 2])\nassert(factorize(n:\
    \ 8) == [2, 2, 2])\nassert(factorize(n: 57) == [3, 19])\nassert(factorize(n: 3249)\
    \ == [3, 3, 19, 19])\nassert(factorize(n: 185193) == [3, 3, 3, 19, 19, 19])\n\
    assert(factorize(n: 20577) == [3, 19, 19, 19])\nassert(factorize(n: 18) == [2,\
    \ 3, 3])"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660009191
- exit_code: 0
  program: "\n/// Return array of prime factors of given integer in the order from\
    \ smallest to largest.\n/// Each of the factors should be arrayed number of times\
    \ corresponding to how many times it appeares in factorization.\n/// Input number\
    \ should be equal to the product of all factors\n/// >>> factorize(n: 8)\n///\
    \ [2, 2, 2]\n/// >>> factorize(n: 25)\n/// [5, 5]\n/// >>> factorize(n: 70)\n\
    /// [2, 5, 7]\nfunc factorize(n: Int) -> [Int] {\n    assert(n > 0)\n    var result\
    \ = [Int]()\n    var num = n\n    var nextDivider = 2\n    while num > 1 {\n \
    \       if num % nextDivider == 0 {\n            result.append(nextDivider)\n\
    \            num /= nextDivider\n        } else {\n            nextDivider +=\
    \ 1\n        }\n    }\n    return result\n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(factorize(n: 2) == [2])\nassert(factorize(n: 4) == [2, 2])\nassert(factorize(n:\
    \ 8) == [2, 2, 2])\nassert(factorize(n: 57) == [3, 19])\nassert(factorize(n: 3249)\
    \ == [3, 3, 19, 19])\nassert(factorize(n: 185193) == [3, 3, 3, 19, 19, 19])\n\
    assert(factorize(n: 20577) == [3, 19, 19, 19])\nassert(factorize(n: 18) == [2,\
    \ 3, 3])"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660009191
- exit_code: 0
  program: "\n/// Return array of prime factors of given integer in the order from\
    \ smallest to largest.\n/// Each of the factors should be arrayed number of times\
    \ corresponding to how many times it appeares in factorization.\n/// Input number\
    \ should be equal to the product of all factors\n/// >>> factorize(n: 8)\n///\
    \ [2, 2, 2]\n/// >>> factorize(n: 25)\n/// [5, 5]\n/// >>> factorize(n: 70)\n\
    /// [2, 5, 7]\nfunc factorize(n: Int) -> [Int] {\n    var factors = [Int]()\n\
    \    var current = n\n    var divider = 2\n    while current > 1 {\n        while\
    \ current % divider == 0 {\n            factors.append(divider)\n            current\
    \ /= divider\n        }\n        divider += 1\n    }\n    return factors\n}\n\n\
    \nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(factorize(n: 2) == [2])\nassert(factorize(n: 4)\
    \ == [2, 2])\nassert(factorize(n: 8) == [2, 2, 2])\nassert(factorize(n: 57) ==\
    \ [3, 19])\nassert(factorize(n: 3249) == [3, 3, 19, 19])\nassert(factorize(n:\
    \ 185193) == [3, 3, 3, 19, 19, 19])\nassert(factorize(n: 20577) == [3, 19, 19,\
    \ 19])\nassert(factorize(n: 18) == [2, 3, 3])"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660009191
- exit_code: 0
  program: "\n/// Return array of prime factors of given integer in the order from\
    \ smallest to largest.\n/// Each of the factors should be arrayed number of times\
    \ corresponding to how many times it appeares in factorization.\n/// Input number\
    \ should be equal to the product of all factors\n/// >>> factorize(n: 8)\n///\
    \ [2, 2, 2]\n/// >>> factorize(n: 25)\n/// [5, 5]\n/// >>> factorize(n: 70)\n\
    /// [2, 5, 7]\nfunc factorize(n: Int) -> [Int] {\n    var factors = [Int]()\n\
    \    var number = n\n    var i = 2\n    while i <= number {\n        if number\
    \ % i == 0 {\n            factors.append(i)\n            number /= i\n       \
    \ } else {\n            i += 1\n        }\n    }\n    return factors\n}\n\n\n\
    func ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(factorize(n: 2) == [2])\nassert(factorize(n: 4)\
    \ == [2, 2])\nassert(factorize(n: 8) == [2, 2, 2])\nassert(factorize(n: 57) ==\
    \ [3, 19])\nassert(factorize(n: 3249) == [3, 3, 19, 19])\nassert(factorize(n:\
    \ 185193) == [3, 3, 3, 19, 19, 19])\nassert(factorize(n: 20577) == [3, 19, 19,\
    \ 19])\nassert(factorize(n: 18) == [2, 3, 3])"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660009191
- exit_code: 0
  program: "\n/// Return array of prime factors of given integer in the order from\
    \ smallest to largest.\n/// Each of the factors should be arrayed number of times\
    \ corresponding to how many times it appeares in factorization.\n/// Input number\
    \ should be equal to the product of all factors\n/// >>> factorize(n: 8)\n///\
    \ [2, 2, 2]\n/// >>> factorize(n: 25)\n/// [5, 5]\n/// >>> factorize(n: 70)\n\
    /// [2, 5, 7]\nfunc factorize(n: Int) -> [Int] {\n    var factors: [Int] = []\n\
    \    var number = n\n    var divisor = 2\n    while divisor * divisor <= number\
    \ {\n        while number % divisor == 0 {\n            factors.append(divisor)\n\
    \            number /= divisor\n        }\n        divisor += 1\n    }\n    if\
    \ number > 1 {\n        factors.append(number)\n    }\n    return factors\n}\n\
    \n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(factorize(n: 2) == [2])\nassert(factorize(n: 4)\
    \ == [2, 2])\nassert(factorize(n: 8) == [2, 2, 2])\nassert(factorize(n: 57) ==\
    \ [3, 19])\nassert(factorize(n: 3249) == [3, 3, 19, 19])\nassert(factorize(n:\
    \ 185193) == [3, 3, 3, 19, 19, 19])\nassert(factorize(n: 20577) == [3, 19, 19,\
    \ 19])\nassert(factorize(n: 18) == [2, 3, 3])"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660009191
- exit_code: 0
  program: "\n/// Return array of prime factors of given integer in the order from\
    \ smallest to largest.\n/// Each of the factors should be arrayed number of times\
    \ corresponding to how many times it appeares in factorization.\n/// Input number\
    \ should be equal to the product of all factors\n/// >>> factorize(n: 8)\n///\
    \ [2, 2, 2]\n/// >>> factorize(n: 25)\n/// [5, 5]\n/// >>> factorize(n: 70)\n\
    /// [2, 5, 7]\nfunc factorize(n: Int) -> [Int] {\n    var factors = [Int]()\n\
    \    var number = n\n    var divider = 2\n    while number > 1 {\n        if number\
    \ % divider == 0 {\n            factors.append(divider)\n            number /=\
    \ divider\n        } else {\n            divider += 1\n        }\n    }\n    return\
    \ factors\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n\
    \    if left.count != right.count {\n        return false\n    }\n    for (l,\
    \ r) in zip(left, right) {\n        if l != r {\n            return false\n  \
    \      }\n    }\n    return true\n}\n            \nassert(factorize(n: 2) == [2])\n\
    assert(factorize(n: 4) == [2, 2])\nassert(factorize(n: 8) == [2, 2, 2])\nassert(factorize(n:\
    \ 57) == [3, 19])\nassert(factorize(n: 3249) == [3, 3, 19, 19])\nassert(factorize(n:\
    \ 185193) == [3, 3, 3, 19, 19, 19])\nassert(factorize(n: 20577) == [3, 19, 19,\
    \ 19])\nassert(factorize(n: 18) == [2, 3, 3])"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660009191
- exit_code: -4
  program: "\n/// Return array of prime factors of given integer in the order from\
    \ smallest to largest.\n/// Each of the factors should be arrayed number of times\
    \ corresponding to how many times it appeares in factorization.\n/// Input number\
    \ should be equal to the product of all factors\n/// >>> factorize(n: 8)\n///\
    \ [2, 2, 2]\n/// >>> factorize(n: 25)\n/// [5, 5]\n/// >>> factorize(n: 70)\n\
    /// [2, 5, 7]\nfunc factorize(n: Int) -> [Int] {\n    var res = [Int]()\n    var\
    \ num = n\n    for i in 2...n/2 {\n        while num % i == 0 {\n            res.append(i)\n\
    \            num /= i\n        }\n    }\n    return res\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(factorize(n: 2) == [2])\nassert(factorize(n: 4) == [2,\
    \ 2])\nassert(factorize(n: 8) == [2, 2, 2])\nassert(factorize(n: 57) == [3, 19])\n\
    assert(factorize(n: 3249) == [3, 3, 19, 19])\nassert(factorize(n: 185193) == [3,\
    \ 3, 3, 19, 19, 19])\nassert(factorize(n: 20577) == [3, 19, 19, 19])\nassert(factorize(n:\
    \ 18) == [2, 3, 3])"
  status: Exception
  stderr: 'Swift/ClosedRange.swift:347: Fatal error: Range requires lowerBound <=
    upperBound

    Current stack trace:

    0    libswiftCore.so                    0x00002ab729623c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002ab72931a561 <unavailable> + 1434977

    2    libswiftCore.so                    0x00002ab72931a286 <unavailable> + 1434246

    3    libswiftCore.so                    0x00002ab72931a13c <unavailable> + 1433916

    4    libswiftCore.so                    0x00002ab729319bb0 _assertionFailure(_:_:file:line:flags:)
    + 251

    5    tmp48swt8xw                        0x0000561717366e7b <unavailable> + 7803

    6    tmp48swt8xw                        0x00005617173664eb <unavailable> + 5355

    7    libc.so.6                          0x00002ab72980f460 __libc_start_main +
    245

    8    tmp48swt8xw                        0x0000561717366209 <unavailable> + 4617

    '
  stdout: ''
  timestamp: 1660009191
- exit_code: 0
  program: "\n/// Return array of prime factors of given integer in the order from\
    \ smallest to largest.\n/// Each of the factors should be arrayed number of times\
    \ corresponding to how many times it appeares in factorization.\n/// Input number\
    \ should be equal to the product of all factors\n/// >>> factorize(n: 8)\n///\
    \ [2, 2, 2]\n/// >>> factorize(n: 25)\n/// [5, 5]\n/// >>> factorize(n: 70)\n\
    /// [2, 5, 7]\nfunc factorize(n: Int) -> [Int] {\n    assert(n >= 2, \"Number\
    \ should be greater or equal to 2\")\n    var number = n\n    var i = 2\n    var\
    \ factors = [Int]()\n    while i * i <= number {\n        if number % i == 0 {\n\
    \            number /= i\n            factors.append(i)\n        } else {\n  \
    \          i += 1\n        }\n    }\n    if number > 1 {\n        factors.append(number)\n\
    \    }\n    return factors\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(factorize(n:\
    \ 2) == [2])\nassert(factorize(n: 4) == [2, 2])\nassert(factorize(n: 8) == [2,\
    \ 2, 2])\nassert(factorize(n: 57) == [3, 19])\nassert(factorize(n: 3249) == [3,\
    \ 3, 19, 19])\nassert(factorize(n: 185193) == [3, 3, 3, 19, 19, 19])\nassert(factorize(n:\
    \ 20577) == [3, 19, 19, 19])\nassert(factorize(n: 18) == [2, 3, 3])"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660009191
- exit_code: 0
  program: "\n/// Return array of prime factors of given integer in the order from\
    \ smallest to largest.\n/// Each of the factors should be arrayed number of times\
    \ corresponding to how many times it appeares in factorization.\n/// Input number\
    \ should be equal to the product of all factors\n/// >>> factorize(n: 8)\n///\
    \ [2, 2, 2]\n/// >>> factorize(n: 25)\n/// [5, 5]\n/// >>> factorize(n: 70)\n\
    /// [2, 5, 7]\nfunc factorize(n: Int) -> [Int] {\n    var primeFactors = [Int]()\n\
    \    var current = n\n    while current != 1 {\n        var candidate = 2\n  \
    \      while current % candidate != 0 {\n            candidate += 1\n        }\n\
    \        primeFactors.append(candidate)\n        current /= candidate\n    }\n\
    \    return primeFactors\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(factorize(n:\
    \ 2) == [2])\nassert(factorize(n: 4) == [2, 2])\nassert(factorize(n: 8) == [2,\
    \ 2, 2])\nassert(factorize(n: 57) == [3, 19])\nassert(factorize(n: 3249) == [3,\
    \ 3, 19, 19])\nassert(factorize(n: 185193) == [3, 3, 3, 19, 19, 19])\nassert(factorize(n:\
    \ 20577) == [3, 19, 19, 19])\nassert(factorize(n: 18) == [2, 3, 3])"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660009191
- exit_code: 0
  program: "\n/// Return array of prime factors of given integer in the order from\
    \ smallest to largest.\n/// Each of the factors should be arrayed number of times\
    \ corresponding to how many times it appeares in factorization.\n/// Input number\
    \ should be equal to the product of all factors\n/// >>> factorize(n: 8)\n///\
    \ [2, 2, 2]\n/// >>> factorize(n: 25)\n/// [5, 5]\n/// >>> factorize(n: 70)\n\
    /// [2, 5, 7]\nfunc factorize(n: Int) -> [Int] {\n    var factor = 2\n    var\
    \ d = n\n    var factorization = [Int]()\n    while d > 1 {\n        while d %\
    \ factor == 0 {\n            factorization.append(factor)\n            d /= factor\n\
    \        }\n        factor += 1\n    }\n    return factorization\n}\n\n\nfunc\
    \ ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count !=\
    \ right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(factorize(n: 2) == [2])\nassert(factorize(n: 4)\
    \ == [2, 2])\nassert(factorize(n: 8) == [2, 2, 2])\nassert(factorize(n: 57) ==\
    \ [3, 19])\nassert(factorize(n: 3249) == [3, 3, 19, 19])\nassert(factorize(n:\
    \ 185193) == [3, 3, 3, 19, 19, 19])\nassert(factorize(n: 20577) == [3, 19, 19,\
    \ 19])\nassert(factorize(n: 18) == [2, 3, 3])"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660009191
- exit_code: 1
  program: "\n/// Return array of prime factors of given integer in the order from\
    \ smallest to largest.\n/// Each of the factors should be arrayed number of times\
    \ corresponding to how many times it appeares in factorization.\n/// Input number\
    \ should be equal to the product of all factors\n/// >>> factorize(n: 8)\n///\
    \ [2, 2, 2]\n/// >>> factorize(n: 25)\n/// [5, 5]\n/// >>> factorize(n: 70)\n\
    /// [2, 5, 7]\nfunc factorize(n: Int) -> [Int] {\n    let primes = generatePrimes(n:\
    \ n)\n    var factors = [Int]()\n    var num = n\n    for prime in primes {\n\
    \        while num % prime == 0 {\n            factors.append(prime)\n       \
    \     num /= prime\n        }\n    }\n    return factors\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(factorize(n: 2) == [2])\nassert(factorize(n: 4) == [2,\
    \ 2])\nassert(factorize(n: 8) == [2, 2, 2])\nassert(factorize(n: 57) == [3, 19])\n\
    assert(factorize(n: 3249) == [3, 3, 19, 19])\nassert(factorize(n: 185193) == [3,\
    \ 3, 3, 19, 19, 19])\nassert(factorize(n: 20577) == [3, 19, 19, 19])\nassert(factorize(n:\
    \ 18) == [2, 3, 3])"
  status: SyntaxError
  stderr: "/tmp/tmp06rjugtz.swift:12:18: error: cannot find 'generatePrimes' in scope\n\
    \    let primes = generatePrimes(n: n)\n                 ^~~~~~~~~~~~~~\n"
  stdout: ''
  timestamp: 1660009191
- exit_code: 0
  program: "\n/// Return array of prime factors of given integer in the order from\
    \ smallest to largest.\n/// Each of the factors should be arrayed number of times\
    \ corresponding to how many times it appeares in factorization.\n/// Input number\
    \ should be equal to the product of all factors\n/// >>> factorize(n: 8)\n///\
    \ [2, 2, 2]\n/// >>> factorize(n: 25)\n/// [5, 5]\n/// >>> factorize(n: 70)\n\
    /// [2, 5, 7]\nfunc factorize(n: Int) -> [Int] {\n    var fact: [Int] = []\n \
    \   var number = n\n    var i = 2\n    while number > 1 {\n        while number\
    \ % i == 0 {\n            fact.append(i)\n            number /= i\n        }\n\
    \        i += 1\n    }\n    return fact\n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(factorize(n: 2) == [2])\nassert(factorize(n: 4) == [2, 2])\nassert(factorize(n:\
    \ 8) == [2, 2, 2])\nassert(factorize(n: 57) == [3, 19])\nassert(factorize(n: 3249)\
    \ == [3, 3, 19, 19])\nassert(factorize(n: 185193) == [3, 3, 3, 19, 19, 19])\n\
    assert(factorize(n: 20577) == [3, 19, 19, 19])\nassert(factorize(n: 18) == [2,\
    \ 3, 3])"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660009191
- exit_code: 0
  program: "\n/// Return array of prime factors of given integer in the order from\
    \ smallest to largest.\n/// Each of the factors should be arrayed number of times\
    \ corresponding to how many times it appeares in factorization.\n/// Input number\
    \ should be equal to the product of all factors\n/// >>> factorize(n: 8)\n///\
    \ [2, 2, 2]\n/// >>> factorize(n: 25)\n/// [5, 5]\n/// >>> factorize(n: 70)\n\
    /// [2, 5, 7]\nfunc factorize(n: Int) -> [Int] {\n    var number = n\n    var\
    \ factors = [Int]()\n    var prime = 2\n    while prime <= number {\n        if\
    \ number % prime == 0 {\n            factors.append(prime)\n            number\
    \ /= prime\n        } else {\n            prime += 1\n        }\n    }\n    return\
    \ factors\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n\
    \    if left.count != right.count {\n        return false\n    }\n    for (l,\
    \ r) in zip(left, right) {\n        if l != r {\n            return false\n  \
    \      }\n    }\n    return true\n}\n            \nassert(factorize(n: 2) == [2])\n\
    assert(factorize(n: 4) == [2, 2])\nassert(factorize(n: 8) == [2, 2, 2])\nassert(factorize(n:\
    \ 57) == [3, 19])\nassert(factorize(n: 3249) == [3, 3, 19, 19])\nassert(factorize(n:\
    \ 185193) == [3, 3, 3, 19, 19, 19])\nassert(factorize(n: 20577) == [3, 19, 19,\
    \ 19])\nassert(factorize(n: 18) == [2, 3, 3])"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660009191
- exit_code: -4
  program: "\n/// Return array of prime factors of given integer in the order from\
    \ smallest to largest.\n/// Each of the factors should be arrayed number of times\
    \ corresponding to how many times it appeares in factorization.\n/// Input number\
    \ should be equal to the product of all factors\n/// >>> factorize(n: 8)\n///\
    \ [2, 2, 2]\n/// >>> factorize(n: 25)\n/// [5, 5]\n/// >>> factorize(n: 70)\n\
    /// [2, 5, 7]\nfunc factorize(n: Int) -> [Int] {\n    // write your code here\n\
    \    return [2, 2, 2]\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(factorize(n:\
    \ 2) == [2])\nassert(factorize(n: 4) == [2, 2])\nassert(factorize(n: 8) == [2,\
    \ 2, 2])\nassert(factorize(n: 57) == [3, 19])\nassert(factorize(n: 3249) == [3,\
    \ 3, 19, 19])\nassert(factorize(n: 185193) == [3, 3, 3, 19, 19, 19])\nassert(factorize(n:\
    \ 20577) == [3, 19, 19, 19])\nassert(factorize(n: 18) == [2, 3, 3])"
  status: Exception
  stderr: 'tmpi9lryz2p/tmpi9lryz2p.swift:29: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b4c7bc89c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b4c7b980b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b4c7b980988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b4c7b97f7b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpi9lryz2p                        0x000055b3154b7372 <unavailable> + 4978

    5    libc.so.6                          0x00002b4c7be75460 __libc_start_main +
    245

    6    tmpi9lryz2p                        0x000055b3154b6fc9 <unavailable> + 4041

    '
  stdout: ''
  timestamp: 1660009191
- exit_code: 1
  program: "\n/// Return array of prime factors of given integer in the order from\
    \ smallest to largest.\n/// Each of the factors should be arrayed number of times\
    \ corresponding to how many times it appeares in factorization.\n/// Input number\
    \ should be equal to the product of all factors\n/// >>> factorize(n: 8)\n///\
    \ [2, 2, 2]\n/// >>> factorize(n: 25)\n/// [5, 5]\n/// >>> factorize(n: 70)\n\
    /// [2, 5, 7]\nfunc factorize(n: Int) -> [Int] {\n    var n = n\n    var k = 0\n\
    \    var result: [Int] = []\n    let primes = getPrimes(max: n)\n    for i in\
    \ primes {\n        if n % i == 0 {\n            n /= i\n            result.append(i)\n\
    \            k += 1\n        }\n    }\n    return result\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(factorize(n: 2) == [2])\nassert(factorize(n: 4) == [2,\
    \ 2])\nassert(factorize(n: 8) == [2, 2, 2])\nassert(factorize(n: 57) == [3, 19])\n\
    assert(factorize(n: 3249) == [3, 3, 19, 19])\nassert(factorize(n: 185193) == [3,\
    \ 3, 3, 19, 19, 19])\nassert(factorize(n: 20577) == [3, 19, 19, 19])\nassert(factorize(n:\
    \ 18) == [2, 3, 3])"
  status: SyntaxError
  stderr: "/tmp/tmp7t_aiqi5.swift:15:18: error: cannot find 'getPrimes' in scope\n\
    \    let primes = getPrimes(max: n)\n                 ^~~~~~~~~\n"
  stdout: ''
  timestamp: 1660009191
- exit_code: 0
  program: "\n/// Return array of prime factors of given integer in the order from\
    \ smallest to largest.\n/// Each of the factors should be arrayed number of times\
    \ corresponding to how many times it appeares in factorization.\n/// Input number\
    \ should be equal to the product of all factors\n/// >>> factorize(n: 8)\n///\
    \ [2, 2, 2]\n/// >>> factorize(n: 25)\n/// [5, 5]\n/// >>> factorize(n: 70)\n\
    /// [2, 5, 7]\nfunc factorize(n: Int) -> [Int] {\n    var number = n\n    var\
    \ factors = [Int]()\n    var divisor = 2\n    while number > 1 {\n        while\
    \ number % divisor == 0 {\n            factors.append(divisor)\n            number\
    \ /= divisor\n        }\n        divisor += 1\n    }\n    return factors\n}\n\n\
    \nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(factorize(n: 2) == [2])\nassert(factorize(n: 4)\
    \ == [2, 2])\nassert(factorize(n: 8) == [2, 2, 2])\nassert(factorize(n: 57) ==\
    \ [3, 19])\nassert(factorize(n: 3249) == [3, 3, 19, 19])\nassert(factorize(n:\
    \ 185193) == [3, 3, 3, 19, 19, 19])\nassert(factorize(n: 20577) == [3, 19, 19,\
    \ 19])\nassert(factorize(n: 18) == [2, 3, 3])"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660009191
- exit_code: -4
  program: "\n/// Return array of prime factors of given integer in the order from\
    \ smallest to largest.\n/// Each of the factors should be arrayed number of times\
    \ corresponding to how many times it appeares in factorization.\n/// Input number\
    \ should be equal to the product of all factors\n/// >>> factorize(n: 8)\n///\
    \ [2, 2, 2]\n/// >>> factorize(n: 25)\n/// [5, 5]\n/// >>> factorize(n: 70)\n\
    /// [2, 5, 7]\nfunc factorize(n: Int) -> [Int] {\n    // TODO: Write some code\
    \ to solve this task\n    return []\n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(factorize(n: 2) == [2])\nassert(factorize(n: 4) == [2, 2])\nassert(factorize(n:\
    \ 8) == [2, 2, 2])\nassert(factorize(n: 57) == [3, 19])\nassert(factorize(n: 3249)\
    \ == [3, 3, 19, 19])\nassert(factorize(n: 185193) == [3, 3, 3, 19, 19, 19])\n\
    assert(factorize(n: 20577) == [3, 19, 19, 19])\nassert(factorize(n: 18) == [2,\
    \ 3, 3])"
  status: Exception
  stderr: 'tmpl7dj_eiz/tmpl7dj_eiz.swift:29: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b9916f5fc80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b9916c56b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b9916c56988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b9916c557b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpl7dj_eiz                        0x000055acb1e1b372 <unavailable> + 4978

    5    libc.so.6                          0x00002b991714b460 __libc_start_main +
    245

    6    tmpl7dj_eiz                        0x000055acb1e1afc9 <unavailable> + 4041

    '
  stdout: ''
  timestamp: 1660009191
- exit_code: 0
  program: "\n/// Return array of prime factors of given integer in the order from\
    \ smallest to largest.\n/// Each of the factors should be arrayed number of times\
    \ corresponding to how many times it appeares in factorization.\n/// Input number\
    \ should be equal to the product of all factors\n/// >>> factorize(n: 8)\n///\
    \ [2, 2, 2]\n/// >>> factorize(n: 25)\n/// [5, 5]\n/// >>> factorize(n: 70)\n\
    /// [2, 5, 7]\nfunc factorize(n: Int) -> [Int] {\n  var result = [Int]()\n  var\
    \ current = n\n  var divisor = 2\n  while current > 1 {\n    while current % divisor\
    \ == 0 {\n      result.append(divisor)\n      current /= divisor\n    }\n    divisor\
    \ += 1\n  }\n  return result\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int,\
    \ Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n\
    \    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n          \
    \  return false\n        }\n    }\n    return true\n}\n            \nassert(factorize(n:\
    \ 2) == [2])\nassert(factorize(n: 4) == [2, 2])\nassert(factorize(n: 8) == [2,\
    \ 2, 2])\nassert(factorize(n: 57) == [3, 19])\nassert(factorize(n: 3249) == [3,\
    \ 3, 19, 19])\nassert(factorize(n: 185193) == [3, 3, 3, 19, 19, 19])\nassert(factorize(n:\
    \ 20577) == [3, 19, 19, 19])\nassert(factorize(n: 18) == [2, 3, 3])"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660009191
- exit_code: 0
  program: "\n/// Return array of prime factors of given integer in the order from\
    \ smallest to largest.\n/// Each of the factors should be arrayed number of times\
    \ corresponding to how many times it appeares in factorization.\n/// Input number\
    \ should be equal to the product of all factors\n/// >>> factorize(n: 8)\n///\
    \ [2, 2, 2]\n/// >>> factorize(n: 25)\n/// [5, 5]\n/// >>> factorize(n: 70)\n\
    /// [2, 5, 7]\nfunc factorize(n: Int) -> [Int] {\n    var result: [Int] = []\n\
    \    var number = n\n    var d = 2\n    while number != 1 {\n        while number\
    \ % d == 0 {\n            result.append(d)\n            number /= d\n        }\n\
    \        d += 1\n    }\n    return result\n}\n\n\nfunc ==(left: [(Int, Int)],\
    \ right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n       \
    \ return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r\
    \ {\n            return false\n        }\n    }\n    return true\n}\n        \
    \    \nassert(factorize(n: 2) == [2])\nassert(factorize(n: 4) == [2, 2])\nassert(factorize(n:\
    \ 8) == [2, 2, 2])\nassert(factorize(n: 57) == [3, 19])\nassert(factorize(n: 3249)\
    \ == [3, 3, 19, 19])\nassert(factorize(n: 185193) == [3, 3, 3, 19, 19, 19])\n\
    assert(factorize(n: 20577) == [3, 19, 19, 19])\nassert(factorize(n: 18) == [2,\
    \ 3, 3])"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660009191
- exit_code: 0
  program: "\n/// Return array of prime factors of given integer in the order from\
    \ smallest to largest.\n/// Each of the factors should be arrayed number of times\
    \ corresponding to how many times it appeares in factorization.\n/// Input number\
    \ should be equal to the product of all factors\n/// >>> factorize(n: 8)\n///\
    \ [2, 2, 2]\n/// >>> factorize(n: 25)\n/// [5, 5]\n/// >>> factorize(n: 70)\n\
    /// [2, 5, 7]\nfunc factorize(n: Int) -> [Int] {\n    var arr = [Int]()\n    var\
    \ num = n\n    var divisor = 2\n    while divisor <= num {\n        if num % divisor\
    \ == 0 {\n            arr.append(divisor)\n            num /= divisor\n      \
    \  } else {\n            divisor += 1\n        }\n    }\n    return arr\n}\n\n\
    \nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(factorize(n: 2) == [2])\nassert(factorize(n: 4)\
    \ == [2, 2])\nassert(factorize(n: 8) == [2, 2, 2])\nassert(factorize(n: 57) ==\
    \ [3, 19])\nassert(factorize(n: 3249) == [3, 3, 19, 19])\nassert(factorize(n:\
    \ 185193) == [3, 3, 3, 19, 19, 19])\nassert(factorize(n: 20577) == [3, 19, 19,\
    \ 19])\nassert(factorize(n: 18) == [2, 3, 3])"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660009191
- exit_code: 0
  program: "\n/// Return array of prime factors of given integer in the order from\
    \ smallest to largest.\n/// Each of the factors should be arrayed number of times\
    \ corresponding to how many times it appeares in factorization.\n/// Input number\
    \ should be equal to the product of all factors\n/// >>> factorize(n: 8)\n///\
    \ [2, 2, 2]\n/// >>> factorize(n: 25)\n/// [5, 5]\n/// >>> factorize(n: 70)\n\
    /// [2, 5, 7]\nfunc factorize(n: Int) -> [Int] {\n    var arrayOfFactor: [Int]\
    \ = []\n    var value = n\n    var iterator = 2\n    while value > 1 {\n     \
    \   if value % iterator == 0 {\n            arrayOfFactor.append(iterator)\n \
    \           value /= iterator\n        } else {\n            iterator += 1\n \
    \       }\n    }\n    return arrayOfFactor\n}\n\n\nfunc ==(left: [(Int, Int)],\
    \ right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n       \
    \ return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r\
    \ {\n            return false\n        }\n    }\n    return true\n}\n        \
    \    \nassert(factorize(n: 2) == [2])\nassert(factorize(n: 4) == [2, 2])\nassert(factorize(n:\
    \ 8) == [2, 2, 2])\nassert(factorize(n: 57) == [3, 19])\nassert(factorize(n: 3249)\
    \ == [3, 3, 19, 19])\nassert(factorize(n: 185193) == [3, 3, 3, 19, 19, 19])\n\
    assert(factorize(n: 20577) == [3, 19, 19, 19])\nassert(factorize(n: 18) == [2,\
    \ 3, 3])"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660009191
- exit_code: 0
  program: "\n/// Return array of prime factors of given integer in the order from\
    \ smallest to largest.\n/// Each of the factors should be arrayed number of times\
    \ corresponding to how many times it appeares in factorization.\n/// Input number\
    \ should be equal to the product of all factors\n/// >>> factorize(n: 8)\n///\
    \ [2, 2, 2]\n/// >>> factorize(n: 25)\n/// [5, 5]\n/// >>> factorize(n: 70)\n\
    /// [2, 5, 7]\nfunc factorize(n: Int) -> [Int] {\n    var result: [Int] = []\n\
    \    var prime: Int = 2\n    var newN: Int = n\n    while prime <= newN {\n  \
    \      while newN % prime == 0 {\n            result.append(prime)\n         \
    \   newN /= prime\n        }\n        prime += 1\n    }\n    return result\n}\n\
    \n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(factorize(n: 2) == [2])\nassert(factorize(n: 4)\
    \ == [2, 2])\nassert(factorize(n: 8) == [2, 2, 2])\nassert(factorize(n: 57) ==\
    \ [3, 19])\nassert(factorize(n: 3249) == [3, 3, 19, 19])\nassert(factorize(n:\
    \ 185193) == [3, 3, 3, 19, 19, 19])\nassert(factorize(n: 20577) == [3, 19, 19,\
    \ 19])\nassert(factorize(n: 18) == [2, 3, 3])"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660009191
- exit_code: 1
  program: "\n/// Return array of prime factors of given integer in the order from\
    \ smallest to largest.\n/// Each of the factors should be arrayed number of times\
    \ corresponding to how many times it appeares in factorization.\n/// Input number\
    \ should be equal to the product of all factors\n/// >>> factorize(n: 8)\n///\
    \ [2, 2, 2]\n/// >>> factorize(n: 25)\n/// [5, 5]\n/// >>> factorize(n: 70)\n\
    /// [2, 5, 7]\nfunc factorize(n: Int) -> [Int] {\n    let primes = getPrimes(n:\
    \ n)\n    var factors = [Int]()\n    var rest = n\n    for prime in primes {\n\
    \        while rest % prime == 0 {\n            factors.append(prime)\n      \
    \      rest /= prime\n        }\n    }\n    return factors\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(factorize(n: 2) == [2])\nassert(factorize(n: 4) == [2,\
    \ 2])\nassert(factorize(n: 8) == [2, 2, 2])\nassert(factorize(n: 57) == [3, 19])\n\
    assert(factorize(n: 3249) == [3, 3, 19, 19])\nassert(factorize(n: 185193) == [3,\
    \ 3, 3, 19, 19, 19])\nassert(factorize(n: 20577) == [3, 19, 19, 19])\nassert(factorize(n:\
    \ 18) == [2, 3, 3])"
  status: SyntaxError
  stderr: "/tmp/tmp49nxcusj.swift:12:18: error: cannot find 'getPrimes' in scope\n\
    \    let primes = getPrimes(n: n)\n                 ^~~~~~~~~\n"
  stdout: ''
  timestamp: 1660009191
- exit_code: 0
  program: "\n/// Return array of prime factors of given integer in the order from\
    \ smallest to largest.\n/// Each of the factors should be arrayed number of times\
    \ corresponding to how many times it appeares in factorization.\n/// Input number\
    \ should be equal to the product of all factors\n/// >>> factorize(n: 8)\n///\
    \ [2, 2, 2]\n/// >>> factorize(n: 25)\n/// [5, 5]\n/// >>> factorize(n: 70)\n\
    /// [2, 5, 7]\nfunc factorize(n: Int) -> [Int] {\n    var result: [Int] = []\n\
    \    var number = n\n    var i = 2\n    while number > 1 {\n        while number\
    \ % i == 0 {\n            result.append(i)\n            number /= i\n        }\n\
    \        i += 1\n    }\n    return result\n}\n\n\nfunc ==(left: [(Int, Int)],\
    \ right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n       \
    \ return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r\
    \ {\n            return false\n        }\n    }\n    return true\n}\n        \
    \    \nassert(factorize(n: 2) == [2])\nassert(factorize(n: 4) == [2, 2])\nassert(factorize(n:\
    \ 8) == [2, 2, 2])\nassert(factorize(n: 57) == [3, 19])\nassert(factorize(n: 3249)\
    \ == [3, 3, 19, 19])\nassert(factorize(n: 185193) == [3, 3, 3, 19, 19, 19])\n\
    assert(factorize(n: 20577) == [3, 19, 19, 19])\nassert(factorize(n: 18) == [2,\
    \ 3, 3])"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660009191
- exit_code: 0
  program: "\n/// Return array of prime factors of given integer in the order from\
    \ smallest to largest.\n/// Each of the factors should be arrayed number of times\
    \ corresponding to how many times it appeares in factorization.\n/// Input number\
    \ should be equal to the product of all factors\n/// >>> factorize(n: 8)\n///\
    \ [2, 2, 2]\n/// >>> factorize(n: 25)\n/// [5, 5]\n/// >>> factorize(n: 70)\n\
    /// [2, 5, 7]\nfunc factorize(n: Int) -> [Int] {\n    var primeFactors: [Int]\
    \ = []\n    var i = 2\n    var n = n\n    while n > 1 {\n        while n % i ==\
    \ 0 {\n            primeFactors.append(i)\n            n /= i\n        }\n   \
    \     i += 1\n    }\n    return primeFactors\n}\n\n\nfunc ==(left: [(Int, Int)],\
    \ right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n       \
    \ return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r\
    \ {\n            return false\n        }\n    }\n    return true\n}\n        \
    \    \nassert(factorize(n: 2) == [2])\nassert(factorize(n: 4) == [2, 2])\nassert(factorize(n:\
    \ 8) == [2, 2, 2])\nassert(factorize(n: 57) == [3, 19])\nassert(factorize(n: 3249)\
    \ == [3, 3, 19, 19])\nassert(factorize(n: 185193) == [3, 3, 3, 19, 19, 19])\n\
    assert(factorize(n: 20577) == [3, 19, 19, 19])\nassert(factorize(n: 18) == [2,\
    \ 3, 3])"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660009191
- exit_code: -4
  program: "\n/// Return array of prime factors of given integer in the order from\
    \ smallest to largest.\n/// Each of the factors should be arrayed number of times\
    \ corresponding to how many times it appeares in factorization.\n/// Input number\
    \ should be equal to the product of all factors\n/// >>> factorize(n: 8)\n///\
    \ [2, 2, 2]\n/// >>> factorize(n: 25)\n/// [5, 5]\n/// >>> factorize(n: 70)\n\
    /// [2, 5, 7]\nfunc factorize(n: Int) -> [Int] {\n    var num = n\n    var factors\
    \ = [Int]()\n    var primes = [2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41,\
    \ 43, 47, 53, 59, 61, 67, 71, 73, 79, 83, 89, 97]\n    for prime in primes {\n\
    \        if num % prime == 0 {\n            factors.append(prime)\n          \
    \  num /= prime\n        }\n    }\n    return factors\n}\n\n\nfunc ==(left: [(Int,\
    \ Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n\
    \        return false\n    }\n    for (l, r) in zip(left, right) {\n        if\
    \ l != r {\n            return false\n        }\n    }\n    return true\n}\n \
    \           \nassert(factorize(n: 2) == [2])\nassert(factorize(n: 4) == [2, 2])\n\
    assert(factorize(n: 8) == [2, 2, 2])\nassert(factorize(n: 57) == [3, 19])\nassert(factorize(n:\
    \ 3249) == [3, 3, 19, 19])\nassert(factorize(n: 185193) == [3, 3, 3, 19, 19, 19])\n\
    assert(factorize(n: 20577) == [3, 19, 19, 19])\nassert(factorize(n: 18) == [2,\
    \ 3, 3])"
  status: Exception
  stderr: 'tmpg101r7ef/tmpg101r7ef.swift:38: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b70ebc69c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b70eb960b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b70eb960988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b70eb95f7b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpg101r7ef                        0x0000562050f596ff <unavailable> + 5887

    5    libc.so.6                          0x00002b70ebe55460 __libc_start_main +
    245

    6    tmpg101r7ef                        0x0000562050f59279 <unavailable> + 4729

    '
  stdout: ''
  timestamp: 1660009191
- exit_code: 0
  program: "\n/// Return array of prime factors of given integer in the order from\
    \ smallest to largest.\n/// Each of the factors should be arrayed number of times\
    \ corresponding to how many times it appeares in factorization.\n/// Input number\
    \ should be equal to the product of all factors\n/// >>> factorize(n: 8)\n///\
    \ [2, 2, 2]\n/// >>> factorize(n: 25)\n/// [5, 5]\n/// >>> factorize(n: 70)\n\
    /// [2, 5, 7]\nfunc factorize(n: Int) -> [Int] {\n    guard n != 1 else { return\
    \ [1] }\n    guard n > 1 else { return [] }\n    var factors = [Int]()\n    var\
    \ current = n\n    var currentDivisor = 2\n    while current != 1 {\n        while\
    \ current % currentDivisor == 0 {\n            factors.append(currentDivisor)\n\
    \            current /= currentDivisor\n        }\n        currentDivisor += 1\n\
    \    }\n    return factors\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(factorize(n:\
    \ 2) == [2])\nassert(factorize(n: 4) == [2, 2])\nassert(factorize(n: 8) == [2,\
    \ 2, 2])\nassert(factorize(n: 57) == [3, 19])\nassert(factorize(n: 3249) == [3,\
    \ 3, 19, 19])\nassert(factorize(n: 185193) == [3, 3, 3, 19, 19, 19])\nassert(factorize(n:\
    \ 20577) == [3, 19, 19, 19])\nassert(factorize(n: 18) == [2, 3, 3])"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660009191
- exit_code: 0
  program: "\n/// Return array of prime factors of given integer in the order from\
    \ smallest to largest.\n/// Each of the factors should be arrayed number of times\
    \ corresponding to how many times it appeares in factorization.\n/// Input number\
    \ should be equal to the product of all factors\n/// >>> factorize(n: 8)\n///\
    \ [2, 2, 2]\n/// >>> factorize(n: 25)\n/// [5, 5]\n/// >>> factorize(n: 70)\n\
    /// [2, 5, 7]\nfunc factorize(n: Int) -> [Int] {\n    var result = [Int]()\n \
    \   var i = 2\n    var input = n\n    while i * i <= input {\n        while input\
    \ % i == 0 {\n            result.append(i)\n            input /= i\n        }\n\
    \        i += 1\n    }\n    if input > 1 {\n        result.append(input)\n   \
    \ }\n    return result\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(factorize(n:\
    \ 2) == [2])\nassert(factorize(n: 4) == [2, 2])\nassert(factorize(n: 8) == [2,\
    \ 2, 2])\nassert(factorize(n: 57) == [3, 19])\nassert(factorize(n: 3249) == [3,\
    \ 3, 19, 19])\nassert(factorize(n: 185193) == [3, 3, 3, 19, 19, 19])\nassert(factorize(n:\
    \ 20577) == [3, 19, 19, 19])\nassert(factorize(n: 18) == [2, 3, 3])"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660009191
- exit_code: 0
  program: "\n/// Return array of prime factors of given integer in the order from\
    \ smallest to largest.\n/// Each of the factors should be arrayed number of times\
    \ corresponding to how many times it appeares in factorization.\n/// Input number\
    \ should be equal to the product of all factors\n/// >>> factorize(n: 8)\n///\
    \ [2, 2, 2]\n/// >>> factorize(n: 25)\n/// [5, 5]\n/// >>> factorize(n: 70)\n\
    /// [2, 5, 7]\nfunc factorize(n: Int) -> [Int] {\n    var current = n\n    var\
    \ primes = [Int]()\n    var prime = 2\n    while current > 1 {\n        while\
    \ current % prime == 0 {\n            primes.append(prime)\n            current\
    \ /= prime\n        }\n        prime += 1\n    }\n    return primes\n}\n\n\nfunc\
    \ ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count !=\
    \ right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(factorize(n: 2) == [2])\nassert(factorize(n: 4)\
    \ == [2, 2])\nassert(factorize(n: 8) == [2, 2, 2])\nassert(factorize(n: 57) ==\
    \ [3, 19])\nassert(factorize(n: 3249) == [3, 3, 19, 19])\nassert(factorize(n:\
    \ 185193) == [3, 3, 3, 19, 19, 19])\nassert(factorize(n: 20577) == [3, 19, 19,\
    \ 19])\nassert(factorize(n: 18) == [2, 3, 3])"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660009191
- exit_code: -4
  program: "\n/// Return array of prime factors of given integer in the order from\
    \ smallest to largest.\n/// Each of the factors should be arrayed number of times\
    \ corresponding to how many times it appeares in factorization.\n/// Input number\
    \ should be equal to the product of all factors\n/// >>> factorize(n: 8)\n///\
    \ [2, 2, 2]\n/// >>> factorize(n: 25)\n/// [5, 5]\n/// >>> factorize(n: 70)\n\
    /// [2, 5, 7]\nfunc factorize(n: Int) -> [Int] {\n    var primeFactors: [Int]\
    \ = []\n    var current: Int = n\n    for i in 2..<n {\n        while current\
    \ % i == 0 {\n            primeFactors.append(i)\n            current /= i\n \
    \       }\n    }\n    return primeFactors\n}\n\n\nfunc ==(left: [(Int, Int)],\
    \ right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n       \
    \ return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r\
    \ {\n            return false\n        }\n    }\n    return true\n}\n        \
    \    \nassert(factorize(n: 2) == [2])\nassert(factorize(n: 4) == [2, 2])\nassert(factorize(n:\
    \ 8) == [2, 2, 2])\nassert(factorize(n: 57) == [3, 19])\nassert(factorize(n: 3249)\
    \ == [3, 3, 19, 19])\nassert(factorize(n: 185193) == [3, 3, 3, 19, 19, 19])\n\
    assert(factorize(n: 20577) == [3, 19, 19, 19])\nassert(factorize(n: 18) == [2,\
    \ 3, 3])"
  status: Exception
  stderr: 'tmpvd7ru54b/tmpvd7ru54b.swift:36: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002aee828a5c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002aee8259cb6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002aee8259c988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002aee8259b7b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpvd7ru54b                        0x00005559b3769552 <unavailable> + 5458

    5    libc.so.6                          0x00002aee82a91460 __libc_start_main +
    245

    6    tmpvd7ru54b                        0x00005559b37691a9 <unavailable> + 4521

    '
  stdout: ''
  timestamp: 1660009191
- exit_code: 0
  program: "\n/// Return array of prime factors of given integer in the order from\
    \ smallest to largest.\n/// Each of the factors should be arrayed number of times\
    \ corresponding to how many times it appeares in factorization.\n/// Input number\
    \ should be equal to the product of all factors\n/// >>> factorize(n: 8)\n///\
    \ [2, 2, 2]\n/// >>> factorize(n: 25)\n/// [5, 5]\n/// >>> factorize(n: 70)\n\
    /// [2, 5, 7]\nfunc factorize(n: Int) -> [Int] {\n    var array = [Int]()\n  \
    \  var index = 2\n    var temp = n\n    while temp > 1 {\n        if temp % index\
    \ == 0 {\n            array.append(index)\n            temp /= index\n       \
    \ } else {\n            index += 1\n        }\n    }\n    return array\n}\n\n\n\
    func ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(factorize(n: 2) == [2])\nassert(factorize(n: 4)\
    \ == [2, 2])\nassert(factorize(n: 8) == [2, 2, 2])\nassert(factorize(n: 57) ==\
    \ [3, 19])\nassert(factorize(n: 3249) == [3, 3, 19, 19])\nassert(factorize(n:\
    \ 185193) == [3, 3, 3, 19, 19, 19])\nassert(factorize(n: 20577) == [3, 19, 19,\
    \ 19])\nassert(factorize(n: 18) == [2, 3, 3])"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660009191
- exit_code: 1
  program: "\n/// Return array of prime factors of given integer in the order from\
    \ smallest to largest.\n/// Each of the factors should be arrayed number of times\
    \ corresponding to how many times it appeares in factorization.\n/// Input number\
    \ should be equal to the product of all factors\n/// >>> factorize(n: 8)\n///\
    \ [2, 2, 2]\n/// >>> factorize(n: 25)\n/// [5, 5]\n/// >>> factorize(n: 70)\n\
    /// [2, 5, 7]\nfunc factorize(n: Int) -> [Int] {\n    var array = [Int]()\n  \
    \  var i = 2\n    while n > 1 {\n        if n % i == 0 {\n            array.append(i)\n\
    \            n /= i\n        } else {\n            i += 1\n        }\n    }\n\
    \    return array\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) ->\
    \ Bool {\n    if left.count != right.count {\n        return false\n    }\n  \
    \  for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(factorize(n: 2) ==\
    \ [2])\nassert(factorize(n: 4) == [2, 2])\nassert(factorize(n: 8) == [2, 2, 2])\n\
    assert(factorize(n: 57) == [3, 19])\nassert(factorize(n: 3249) == [3, 3, 19, 19])\n\
    assert(factorize(n: 185193) == [3, 3, 3, 19, 19, 19])\nassert(factorize(n: 20577)\
    \ == [3, 19, 19, 19])\nassert(factorize(n: 18) == [2, 3, 3])"
  status: SyntaxError
  stderr: "/tmp/tmppgb12e25.swift:17:15: error: left side of mutating operator isn't\
    \ mutable: 'n' is a 'let' constant\n            n /= i\n            ~ ^\n"
  stdout: ''
  timestamp: 1660009191
- exit_code: 0
  program: "\n/// Return array of prime factors of given integer in the order from\
    \ smallest to largest.\n/// Each of the factors should be arrayed number of times\
    \ corresponding to how many times it appeares in factorization.\n/// Input number\
    \ should be equal to the product of all factors\n/// >>> factorize(n: 8)\n///\
    \ [2, 2, 2]\n/// >>> factorize(n: 25)\n/// [5, 5]\n/// >>> factorize(n: 70)\n\
    /// [2, 5, 7]\nfunc factorize(n: Int) -> [Int] {\n    var factors: [Int] = []\n\
    \    var num = n\n    var i = 2\n    while i * i <= num {\n        while num %\
    \ i == 0 {\n            factors.append(i)\n            num /= i\n        }\n \
    \       i += 1\n    }\n    if num > 1 {\n        factors.append(num)\n    }\n\
    \    return factors\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) ->\
    \ Bool {\n    if left.count != right.count {\n        return false\n    }\n  \
    \  for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(factorize(n: 2) ==\
    \ [2])\nassert(factorize(n: 4) == [2, 2])\nassert(factorize(n: 8) == [2, 2, 2])\n\
    assert(factorize(n: 57) == [3, 19])\nassert(factorize(n: 3249) == [3, 3, 19, 19])\n\
    assert(factorize(n: 185193) == [3, 3, 3, 19, 19, 19])\nassert(factorize(n: 20577)\
    \ == [3, 19, 19, 19])\nassert(factorize(n: 18) == [2, 3, 3])"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660009191
- exit_code: 1
  program: "\n/// Return array of prime factors of given integer in the order from\
    \ smallest to largest.\n/// Each of the factors should be arrayed number of times\
    \ corresponding to how many times it appeares in factorization.\n/// Input number\
    \ should be equal to the product of all factors\n/// >>> factorize(n: 8)\n///\
    \ [2, 2, 2]\n/// >>> factorize(n: 25)\n/// [5, 5]\n/// >>> factorize(n: 70)\n\
    /// [2, 5, 7]\nfunc factorize(n: Int) -> [Int] {\n    var n = n\n    var factors\
    \ = [Int]()\n    while n > 1 {\n        if n % 2 == 0 {\n            factors.append(2)\n\
    \            n /= 2\n        } else {\n            for i in stride(from: 3, through:\
    \ Int(sqrt(Double(n))), by: 2) {\n                if n % i == 0 {\n          \
    \          factors.append(i)\n                    n /= i\n                   \
    \ break\n                }\n            }\n        }\n    }\n    return factors\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(factorize(n: 2) == [2])\nassert(factorize(n: 4)\
    \ == [2, 2])\nassert(factorize(n: 8) == [2, 2, 2])\nassert(factorize(n: 57) ==\
    \ [3, 19])\nassert(factorize(n: 3249) == [3, 3, 19, 19])\nassert(factorize(n:\
    \ 185193) == [3, 3, 3, 19, 19, 19])\nassert(factorize(n: 20577) == [3, 19, 19,\
    \ 19])\nassert(factorize(n: 18) == [2, 3, 3])"
  status: SyntaxError
  stderr: "/tmp/tmpczlt1hg5.swift:19:51: error: cannot find 'sqrt' in scope\n    \
    \        for i in stride(from: 3, through: Int(sqrt(Double(n))), by: 2) {\n  \
    \                                                ^~~~\n"
  stdout: ''
  timestamp: 1660009191
- exit_code: 1
  program: "\n/// Return array of prime factors of given integer in the order from\
    \ smallest to largest.\n/// Each of the factors should be arrayed number of times\
    \ corresponding to how many times it appeares in factorization.\n/// Input number\
    \ should be equal to the product of all factors\n/// >>> factorize(n: 8)\n///\
    \ [2, 2, 2]\n/// >>> factorize(n: 25)\n/// [5, 5]\n/// >>> factorize(n: 70)\n\
    /// [2, 5, 7]\nfunc factorize(n: Int) -> [Int] {\n    var factors: [Int] = []\n\
    \    var remaining = n\n    for prime in primesUpTo(n: n) {\n        while (remaining\
    \ % prime == 0) {\n            factors.append(prime)\n            remaining /=\
    \ prime\n        }\n    }\n    return factors\n}\n\n\nfunc ==(left: [(Int, Int)],\
    \ right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n       \
    \ return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r\
    \ {\n            return false\n        }\n    }\n    return true\n}\n        \
    \    \nassert(factorize(n: 2) == [2])\nassert(factorize(n: 4) == [2, 2])\nassert(factorize(n:\
    \ 8) == [2, 2, 2])\nassert(factorize(n: 57) == [3, 19])\nassert(factorize(n: 3249)\
    \ == [3, 3, 19, 19])\nassert(factorize(n: 185193) == [3, 3, 3, 19, 19, 19])\n\
    assert(factorize(n: 20577) == [3, 19, 19, 19])\nassert(factorize(n: 18) == [2,\
    \ 3, 3])"
  status: SyntaxError
  stderr: "/tmp/tmp2x7ty8m5.swift:14:18: error: cannot find 'primesUpTo' in scope\n\
    \    for prime in primesUpTo(n: n) {\n                 ^~~~~~~~~~\n"
  stdout: ''
  timestamp: 1660009191
- exit_code: 1
  program: "\n/// Return array of prime factors of given integer in the order from\
    \ smallest to largest.\n/// Each of the factors should be arrayed number of times\
    \ corresponding to how many times it appeares in factorization.\n/// Input number\
    \ should be equal to the product of all factors\n/// >>> factorize(n: 8)\n///\
    \ [2, 2, 2]\n/// >>> factorize(n: 25)\n/// [5, 5]\n/// >>> factorize(n: 70)\n\
    /// [2, 5, 7]\nfunc factorize(n: Int) -> [Int] {\n    return factorize(n: n, primes:\
    \ primes.filter { $0 <= n })\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int,\
    \ Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n\
    \    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n          \
    \  return false\n        }\n    }\n    return true\n}\n            \nassert(factorize(n:\
    \ 2) == [2])\nassert(factorize(n: 4) == [2, 2])\nassert(factorize(n: 8) == [2,\
    \ 2, 2])\nassert(factorize(n: 57) == [3, 19])\nassert(factorize(n: 3249) == [3,\
    \ 3, 19, 19])\nassert(factorize(n: 185193) == [3, 3, 3, 19, 19, 19])\nassert(factorize(n:\
    \ 20577) == [3, 19, 19, 19])\nassert(factorize(n: 18) == [2, 3, 3])"
  status: SyntaxError
  stderr: "/tmp/tmpz3y6j8fs.swift:12:36: error: cannot find 'primes' in scope\n  \
    \  return factorize(n: n, primes: primes.filter { $0 <= n })\n               \
    \                    ^~~~~~\n/tmp/tmpz3y6j8fs.swift:12:43: error: extra argument\
    \ 'primes' in call\n    return factorize(n: n, primes: primes.filter { $0 <= n\
    \ })\n                    ~~~~~~~~~~~~~~~~~~~~~~^~~~~~~~~~~~~~~~~~~\n"
  stdout: ''
  timestamp: 1660009191
- exit_code: 0
  program: "\n/// Return array of prime factors of given integer in the order from\
    \ smallest to largest.\n/// Each of the factors should be arrayed number of times\
    \ corresponding to how many times it appeares in factorization.\n/// Input number\
    \ should be equal to the product of all factors\n/// >>> factorize(n: 8)\n///\
    \ [2, 2, 2]\n/// >>> factorize(n: 25)\n/// [5, 5]\n/// >>> factorize(n: 70)\n\
    /// [2, 5, 7]\nfunc factorize(n: Int) -> [Int] {\n    var n = n\n    var factors\
    \ = [Int]()\n    var d = 2\n    while n > 1 {\n        while n % d == 0 {\n  \
    \          factors.append(d)\n            n /= d\n        }\n        d += 1\n\
    \    }\n    return factors\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(factorize(n:\
    \ 2) == [2])\nassert(factorize(n: 4) == [2, 2])\nassert(factorize(n: 8) == [2,\
    \ 2, 2])\nassert(factorize(n: 57) == [3, 19])\nassert(factorize(n: 3249) == [3,\
    \ 3, 19, 19])\nassert(factorize(n: 185193) == [3, 3, 3, 19, 19, 19])\nassert(factorize(n:\
    \ 20577) == [3, 19, 19, 19])\nassert(factorize(n: 18) == [2, 3, 3])"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660009191
- exit_code: 0
  program: "\n/// Return array of prime factors of given integer in the order from\
    \ smallest to largest.\n/// Each of the factors should be arrayed number of times\
    \ corresponding to how many times it appeares in factorization.\n/// Input number\
    \ should be equal to the product of all factors\n/// >>> factorize(n: 8)\n///\
    \ [2, 2, 2]\n/// >>> factorize(n: 25)\n/// [5, 5]\n/// >>> factorize(n: 70)\n\
    /// [2, 5, 7]\nfunc factorize(n: Int) -> [Int] {\n    var factors: [Int] = []\n\
    \    var prime: Int = 2\n    var N: Int = n\n    while N > 1 {\n        while\
    \ N % prime == 0 {\n            factors.append(prime)\n            N /= prime\n\
    \        }\n        prime += 1\n    }\n    return factors\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(factorize(n: 2) == [2])\nassert(factorize(n: 4) == [2,\
    \ 2])\nassert(factorize(n: 8) == [2, 2, 2])\nassert(factorize(n: 57) == [3, 19])\n\
    assert(factorize(n: 3249) == [3, 3, 19, 19])\nassert(factorize(n: 185193) == [3,\
    \ 3, 3, 19, 19, 19])\nassert(factorize(n: 20577) == [3, 19, 19, 19])\nassert(factorize(n:\
    \ 18) == [2, 3, 3])"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660009191
- exit_code: 1
  program: "\n/// Return array of prime factors of given integer in the order from\
    \ smallest to largest.\n/// Each of the factors should be arrayed number of times\
    \ corresponding to how many times it appeares in factorization.\n/// Input number\
    \ should be equal to the product of all factors\n/// >>> factorize(n: 8)\n///\
    \ [2, 2, 2]\n/// >>> factorize(n: 25)\n/// [5, 5]\n/// >>> factorize(n: 70)\n\
    /// [2, 5, 7]\nfunc factorize(n: Int) -> [Int] {\n    var factors: [Int] = []\n\
    \    var value = n\n    for i in 2...value {\n        if value % i == 0 {\n  \
    \          factors.append(i)\n            value /= i\n            i = 1\n    \
    \    }\n    }\n    return factors\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int,\
    \ Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n\
    \    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n          \
    \  return false\n        }\n    }\n    return true\n}\n            \nassert(factorize(n:\
    \ 2) == [2])\nassert(factorize(n: 4) == [2, 2])\nassert(factorize(n: 8) == [2,\
    \ 2, 2])\nassert(factorize(n: 57) == [3, 19])\nassert(factorize(n: 3249) == [3,\
    \ 3, 19, 19])\nassert(factorize(n: 185193) == [3, 3, 3, 19, 19, 19])\nassert(factorize(n:\
    \ 20577) == [3, 19, 19, 19])\nassert(factorize(n: 18) == [2, 3, 3])"
  status: SyntaxError
  stderr: "/tmp/tmpfutdw8iv.swift:18:13: error: cannot assign to value: 'i' is a 'let'\
    \ constant\n            i = 1\n            ^\n"
  stdout: ''
  timestamp: 1660009191
- exit_code: 1
  program: "\n/// Return array of prime factors of given integer in the order from\
    \ smallest to largest.\n/// Each of the factors should be arrayed number of times\
    \ corresponding to how many times it appeares in factorization.\n/// Input number\
    \ should be equal to the product of all factors\n/// >>> factorize(n: 8)\n///\
    \ [2, 2, 2]\n/// >>> factorize(n: 25)\n/// [5, 5]\n/// >>> factorize(n: 70)\n\
    /// [2, 5, 7]\nfunc factorize(n: Int) -> [Int] {\n    var result: [Int] = []\n\
    \    for i in 2...n {\n        if n % i == 0 {\n            result.append(i)\n\
    \            n /= i\n            i -= 1\n        }\n    }\n    return result\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(factorize(n: 2) == [2])\nassert(factorize(n: 4)\
    \ == [2, 2])\nassert(factorize(n: 8) == [2, 2, 2])\nassert(factorize(n: 57) ==\
    \ [3, 19])\nassert(factorize(n: 3249) == [3, 3, 19, 19])\nassert(factorize(n:\
    \ 185193) == [3, 3, 3, 19, 19, 19])\nassert(factorize(n: 20577) == [3, 19, 19,\
    \ 19])\nassert(factorize(n: 18) == [2, 3, 3])"
  status: SyntaxError
  stderr: "/tmp/tmp961u5yu7.swift:16:15: error: left side of mutating operator isn't\
    \ mutable: 'n' is a 'let' constant\n            n /= i\n            ~ ^\n/tmp/tmp961u5yu7.swift:17:15:\
    \ error: left side of mutating operator isn't mutable: 'i' is a 'let' constant\n\
    \            i -= 1\n            ~ ^\n"
  stdout: ''
  timestamp: 1660009191
- exit_code: 1
  program: "\n/// Return array of prime factors of given integer in the order from\
    \ smallest to largest.\n/// Each of the factors should be arrayed number of times\
    \ corresponding to how many times it appeares in factorization.\n/// Input number\
    \ should be equal to the product of all factors\n/// >>> factorize(n: 8)\n///\
    \ [2, 2, 2]\n/// >>> factorize(n: 25)\n/// [5, 5]\n/// >>> factorize(n: 70)\n\
    /// [2, 5, 7]\nfunc factorize(n: Int) -> [Int] {\n    \n    var factors: [Int]\
    \ = []\n    var n = n\n    \n    for i in 2...n {\n        if n % i == 0 {\n \
    \           factors.append(i)\n            n /= i\n            i -= 1\n      \
    \  }\n    }\n    \n    return factors\n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(factorize(n: 2) == [2])\nassert(factorize(n: 4) == [2, 2])\nassert(factorize(n:\
    \ 8) == [2, 2, 2])\nassert(factorize(n: 57) == [3, 19])\nassert(factorize(n: 3249)\
    \ == [3, 3, 19, 19])\nassert(factorize(n: 185193) == [3, 3, 3, 19, 19, 19])\n\
    assert(factorize(n: 20577) == [3, 19, 19, 19])\nassert(factorize(n: 18) == [2,\
    \ 3, 3])"
  status: SyntaxError
  stderr: "/tmp/tmps_3j1qkc.swift:20:15: error: left side of mutating operator isn't\
    \ mutable: 'i' is a 'let' constant\n            i -= 1\n            ~ ^\n"
  stdout: ''
  timestamp: 1660009191
- exit_code: 0
  program: "\n/// Return array of prime factors of given integer in the order from\
    \ smallest to largest.\n/// Each of the factors should be arrayed number of times\
    \ corresponding to how many times it appeares in factorization.\n/// Input number\
    \ should be equal to the product of all factors\n/// >>> factorize(n: 8)\n///\
    \ [2, 2, 2]\n/// >>> factorize(n: 25)\n/// [5, 5]\n/// >>> factorize(n: 70)\n\
    /// [2, 5, 7]\nfunc factorize(n: Int) -> [Int] {\n    var result = [Int]()\n \
    \   var i = 2\n    var num = n\n    while num > 1 {\n        if num % i == 0 {\n\
    \            result.append(i)\n            num /= i\n        } else {\n      \
    \      i += 1\n        }\n    }\n    return result\n}\n\n\nfunc ==(left: [(Int,\
    \ Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n\
    \        return false\n    }\n    for (l, r) in zip(left, right) {\n        if\
    \ l != r {\n            return false\n        }\n    }\n    return true\n}\n \
    \           \nassert(factorize(n: 2) == [2])\nassert(factorize(n: 4) == [2, 2])\n\
    assert(factorize(n: 8) == [2, 2, 2])\nassert(factorize(n: 57) == [3, 19])\nassert(factorize(n:\
    \ 3249) == [3, 3, 19, 19])\nassert(factorize(n: 185193) == [3, 3, 3, 19, 19, 19])\n\
    assert(factorize(n: 20577) == [3, 19, 19, 19])\nassert(factorize(n: 18) == [2,\
    \ 3, 3])"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660009191
- exit_code: 0
  program: "\n/// Return array of prime factors of given integer in the order from\
    \ smallest to largest.\n/// Each of the factors should be arrayed number of times\
    \ corresponding to how many times it appeares in factorization.\n/// Input number\
    \ should be equal to the product of all factors\n/// >>> factorize(n: 8)\n///\
    \ [2, 2, 2]\n/// >>> factorize(n: 25)\n/// [5, 5]\n/// >>> factorize(n: 70)\n\
    /// [2, 5, 7]\nfunc factorize(n: Int) -> [Int] {\n    var factors = [Int]()\n\
    \    if n == 1 {\n        return factors\n    }\n    var n = n\n    var prime\
    \ = 2\n    while n > 1 {\n        while n % prime == 0 {\n            factors.append(prime)\n\
    \            n /= prime\n        }\n        prime += 1\n    }\n    return factors\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(factorize(n: 2) == [2])\nassert(factorize(n: 4)\
    \ == [2, 2])\nassert(factorize(n: 8) == [2, 2, 2])\nassert(factorize(n: 57) ==\
    \ [3, 19])\nassert(factorize(n: 3249) == [3, 3, 19, 19])\nassert(factorize(n:\
    \ 185193) == [3, 3, 3, 19, 19, 19])\nassert(factorize(n: 20577) == [3, 19, 19,\
    \ 19])\nassert(factorize(n: 18) == [2, 3, 3])"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660009191
- exit_code: -4
  program: "\n/// Return array of prime factors of given integer in the order from\
    \ smallest to largest.\n/// Each of the factors should be arrayed number of times\
    \ corresponding to how many times it appeares in factorization.\n/// Input number\
    \ should be equal to the product of all factors\n/// >>> factorize(n: 8)\n///\
    \ [2, 2, 2]\n/// >>> factorize(n: 25)\n/// [5, 5]\n/// >>> factorize(n: 70)\n\
    /// [2, 5, 7]\nfunc factorize(n: Int) -> [Int] {\n    var factors = [Int]()\n\
    \    for factor in 1...n where n % factor == 0 {\n        factors.append(factor)\n\
    \    }\n    return factors\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(factorize(n:\
    \ 2) == [2])\nassert(factorize(n: 4) == [2, 2])\nassert(factorize(n: 8) == [2,\
    \ 2, 2])\nassert(factorize(n: 57) == [3, 19])\nassert(factorize(n: 3249) == [3,\
    \ 3, 19, 19])\nassert(factorize(n: 185193) == [3, 3, 3, 19, 19, 19])\nassert(factorize(n:\
    \ 20577) == [3, 19, 19, 19])\nassert(factorize(n: 18) == [2, 3, 3])"
  status: Exception
  stderr: 'tmp6tl747mj/tmp6tl747mj.swift:32: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002ac4691ddc80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002ac468ed4b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002ac468ed4988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002ac468ed37b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmp6tl747mj                        0x0000560a90e135b2 <unavailable> + 5554

    5    libc.so.6                          0x00002ac4693c9460 __libc_start_main +
    245

    6    tmp6tl747mj                        0x0000560a90e13209 <unavailable> + 4617

    '
  stdout: ''
  timestamp: 1660009191
- exit_code: 0
  program: "\n/// Return array of prime factors of given integer in the order from\
    \ smallest to largest.\n/// Each of the factors should be arrayed number of times\
    \ corresponding to how many times it appeares in factorization.\n/// Input number\
    \ should be equal to the product of all factors\n/// >>> factorize(n: 8)\n///\
    \ [2, 2, 2]\n/// >>> factorize(n: 25)\n/// [5, 5]\n/// >>> factorize(n: 70)\n\
    /// [2, 5, 7]\nfunc factorize(n: Int) -> [Int] {\n    var number = n\n    var\
    \ result: [Int] = []\n    var prime = 2\n    while number != 1 {\n        if number\
    \ % prime == 0 {\n            result.append(prime)\n            number /= prime\n\
    \        } else {\n            prime += 1\n        }\n    }\n    return result\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(factorize(n: 2) == [2])\nassert(factorize(n: 4)\
    \ == [2, 2])\nassert(factorize(n: 8) == [2, 2, 2])\nassert(factorize(n: 57) ==\
    \ [3, 19])\nassert(factorize(n: 3249) == [3, 3, 19, 19])\nassert(factorize(n:\
    \ 185193) == [3, 3, 3, 19, 19, 19])\nassert(factorize(n: 20577) == [3, 19, 19,\
    \ 19])\nassert(factorize(n: 18) == [2, 3, 3])"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660009191
- exit_code: 0
  program: "\n/// Return array of prime factors of given integer in the order from\
    \ smallest to largest.\n/// Each of the factors should be arrayed number of times\
    \ corresponding to how many times it appeares in factorization.\n/// Input number\
    \ should be equal to the product of all factors\n/// >>> factorize(n: 8)\n///\
    \ [2, 2, 2]\n/// >>> factorize(n: 25)\n/// [5, 5]\n/// >>> factorize(n: 70)\n\
    /// [2, 5, 7]\nfunc factorize(n: Int) -> [Int] {\n    guard n != 1 else { return\
    \ [1] }\n    var result = [Int]()\n    var prime = 2\n    var number = n\n   \
    \ while prime <= number {\n        if number % prime == 0 {\n            result.append(prime)\n\
    \            number /= prime\n        } else {\n            prime += 1\n     \
    \   }\n    }\n    return result\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int,\
    \ Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n\
    \    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n          \
    \  return false\n        }\n    }\n    return true\n}\n            \nassert(factorize(n:\
    \ 2) == [2])\nassert(factorize(n: 4) == [2, 2])\nassert(factorize(n: 8) == [2,\
    \ 2, 2])\nassert(factorize(n: 57) == [3, 19])\nassert(factorize(n: 3249) == [3,\
    \ 3, 19, 19])\nassert(factorize(n: 185193) == [3, 3, 3, 19, 19, 19])\nassert(factorize(n:\
    \ 20577) == [3, 19, 19, 19])\nassert(factorize(n: 18) == [2, 3, 3])"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660009191
- exit_code: -4
  program: "\n/// Return array of prime factors of given integer in the order from\
    \ smallest to largest.\n/// Each of the factors should be arrayed number of times\
    \ corresponding to how many times it appeares in factorization.\n/// Input number\
    \ should be equal to the product of all factors\n/// >>> factorize(n: 8)\n///\
    \ [2, 2, 2]\n/// >>> factorize(n: 25)\n/// [5, 5]\n/// >>> factorize(n: 70)\n\
    /// [2, 5, 7]\nfunc factorize(n: Int) -> [Int] {\n    return []\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(factorize(n: 2) == [2])\nassert(factorize(n: 4) == [2,\
    \ 2])\nassert(factorize(n: 8) == [2, 2, 2])\nassert(factorize(n: 57) == [3, 19])\n\
    assert(factorize(n: 3249) == [3, 3, 19, 19])\nassert(factorize(n: 185193) == [3,\
    \ 3, 3, 19, 19, 19])\nassert(factorize(n: 20577) == [3, 19, 19, 19])\nassert(factorize(n:\
    \ 18) == [2, 3, 3])"
  status: Exception
  stderr: 'tmpr8thvm9v/tmpr8thvm9v.swift:28: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b2608809c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b2608500b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b2608500988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b26084ff7b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpr8thvm9v                        0x0000555618631372 <unavailable> + 4978

    5    libc.so.6                          0x00002b26089f5460 __libc_start_main +
    245

    6    tmpr8thvm9v                        0x0000555618630fc9 <unavailable> + 4041

    '
  stdout: ''
  timestamp: 1660009191
- exit_code: 1
  program: "\n/// Return array of prime factors of given integer in the order from\
    \ smallest to largest.\n/// Each of the factors should be arrayed number of times\
    \ corresponding to how many times it appeares in factorization.\n/// Input number\
    \ should be equal to the product of all factors\n/// >>> factorize(n: 8)\n///\
    \ [2, 2, 2]\n/// >>> factorize(n: 25)\n/// [5, 5]\n/// >>> factorize(n: 70)\n\
    /// [2, 5, 7]\nfunc factorize(n: Int) -> [Int] {\n  var i = 2\n  var primeFactors\
    \ = [Int]()\n  while i <= n {\n    if n % i == 0 {\n      primeFactors.append(i)\n\
    \      n /= i\n    } else {\n      i += 1\n    }\n  }\n  return primeFactors\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(factorize(n: 2) == [2])\nassert(factorize(n: 4)\
    \ == [2, 2])\nassert(factorize(n: 8) == [2, 2, 2])\nassert(factorize(n: 57) ==\
    \ [3, 19])\nassert(factorize(n: 3249) == [3, 3, 19, 19])\nassert(factorize(n:\
    \ 185193) == [3, 3, 3, 19, 19, 19])\nassert(factorize(n: 20577) == [3, 19, 19,\
    \ 19])\nassert(factorize(n: 18) == [2, 3, 3])"
  status: SyntaxError
  stderr: "/tmp/tmp705srv6q.swift:17:9: error: left side of mutating operator isn't\
    \ mutable: 'n' is a 'let' constant\n      n /= i\n      ~ ^\n"
  stdout: ''
  timestamp: 1660009191
- exit_code: -4
  program: "\n/// Return array of prime factors of given integer in the order from\
    \ smallest to largest.\n/// Each of the factors should be arrayed number of times\
    \ corresponding to how many times it appeares in factorization.\n/// Input number\
    \ should be equal to the product of all factors\n/// >>> factorize(n: 8)\n///\
    \ [2, 2, 2]\n/// >>> factorize(n: 25)\n/// [5, 5]\n/// >>> factorize(n: 70)\n\
    /// [2, 5, 7]\nfunc factorize(n: Int) -> [Int] {\n    let smallestPrime = (2...n).first\
    \ { n % $0 == 0 }!\n    return [smallestPrime] + factorize(n: n / smallestPrime)\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(factorize(n: 2) == [2])\nassert(factorize(n: 4)\
    \ == [2, 2])\nassert(factorize(n: 8) == [2, 2, 2])\nassert(factorize(n: 57) ==\
    \ [3, 19])\nassert(factorize(n: 3249) == [3, 3, 19, 19])\nassert(factorize(n:\
    \ 185193) == [3, 3, 3, 19, 19, 19])\nassert(factorize(n: 20577) == [3, 19, 19,\
    \ 19])\nassert(factorize(n: 18) == [2, 3, 3])"
  status: Exception
  stderr: 'Swift/ClosedRange.swift:347: Fatal error: Range requires lowerBound <=
    upperBound

    Current stack trace:

    0    libswiftCore.so                    0x00002b194ba9bc80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b194b792561 <unavailable> + 1434977

    2    libswiftCore.so                    0x00002b194b792286 <unavailable> + 1434246

    3    libswiftCore.so                    0x00002b194b79213c <unavailable> + 1433916

    4    libswiftCore.so                    0x00002b194b791bb0 _assertionFailure(_:_:file:line:flags:)
    + 251

    5    tmp25z_8277                        0x000055e8532a5dca <unavailable> + 7626

    6    tmp25z_8277                        0x000055e8532a5f5d <unavailable> + 8029

    7    tmp25z_8277                        0x000055e8532a54db <unavailable> + 5339

    8    libc.so.6                          0x00002b194bc87460 __libc_start_main +
    245

    9    tmp25z_8277                        0x000055e8532a51f9 <unavailable> + 4601

    '
  stdout: ''
  timestamp: 1660009191
- exit_code: 0
  program: "\n/// Return array of prime factors of given integer in the order from\
    \ smallest to largest.\n/// Each of the factors should be arrayed number of times\
    \ corresponding to how many times it appeares in factorization.\n/// Input number\
    \ should be equal to the product of all factors\n/// >>> factorize(n: 8)\n///\
    \ [2, 2, 2]\n/// >>> factorize(n: 25)\n/// [5, 5]\n/// >>> factorize(n: 70)\n\
    /// [2, 5, 7]\nfunc factorize(n: Int) -> [Int] {\n    var n = n\n    var res =\
    \ [Int]()\n    var i = 2\n    while n > 1 {\n        while n % i == 0 {\n    \
    \        res.append(i)\n            n /= i\n        }\n        i += 1\n    }\n\
    \    return res\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool\
    \ {\n    if left.count != right.count {\n        return false\n    }\n    for\
    \ (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(factorize(n: 2) ==\
    \ [2])\nassert(factorize(n: 4) == [2, 2])\nassert(factorize(n: 8) == [2, 2, 2])\n\
    assert(factorize(n: 57) == [3, 19])\nassert(factorize(n: 3249) == [3, 3, 19, 19])\n\
    assert(factorize(n: 185193) == [3, 3, 3, 19, 19, 19])\nassert(factorize(n: 20577)\
    \ == [3, 19, 19, 19])\nassert(factorize(n: 18) == [2, 3, 3])"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660009192
- exit_code: 1
  program: "\n/// Return array of prime factors of given integer in the order from\
    \ smallest to largest.\n/// Each of the factors should be arrayed number of times\
    \ corresponding to how many times it appeares in factorization.\n/// Input number\
    \ should be equal to the product of all factors\n/// >>> factorize(n: 8)\n///\
    \ [2, 2, 2]\n/// >>> factorize(n: 25)\n/// [5, 5]\n/// >>> factorize(n: 70)\n\
    /// [2, 5, 7]\nfunc factorize(n: Int) -> [Int] {\n    \n    var n = n\n    var\
    \ factors = [Int]()\n    \n    while n % 2 == 0 {\n        factors.append(2)\n\
    \        n /= 2\n    }\n    \n    var factor = 3\n    while Double(n) >= pow(Double(factor),\
    \ 2) {\n        while n % factor == 0 {\n            factors.append(factor)\n\
    \            n /= factor\n        }\n        factor += 2\n    }\n    \n    if\
    \ n > 2 {\n        factors.append(n)\n    }\n    \n    return factors\n}\n\n\n\
    func ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(factorize(n: 2) == [2])\nassert(factorize(n: 4)\
    \ == [2, 2])\nassert(factorize(n: 8) == [2, 2, 2])\nassert(factorize(n: 57) ==\
    \ [3, 19])\nassert(factorize(n: 3249) == [3, 3, 19, 19])\nassert(factorize(n:\
    \ 185193) == [3, 3, 3, 19, 19, 19])\nassert(factorize(n: 20577) == [3, 19, 19,\
    \ 19])\nassert(factorize(n: 18) == [2, 3, 3])"
  status: SyntaxError
  stderr: "/tmp/tmp95bmotwp.swift:22:24: error: cannot find 'pow' in scope\n    while\
    \ Double(n) >= pow(Double(factor), 2) {\n                       ^~~\n"
  stdout: ''
  timestamp: 1660009192
- exit_code: -4
  program: "\n/// Return array of prime factors of given integer in the order from\
    \ smallest to largest.\n/// Each of the factors should be arrayed number of times\
    \ corresponding to how many times it appeares in factorization.\n/// Input number\
    \ should be equal to the product of all factors\n/// >>> factorize(n: 8)\n///\
    \ [2, 2, 2]\n/// >>> factorize(n: 25)\n/// [5, 5]\n/// >>> factorize(n: 70)\n\
    /// [2, 5, 7]\nfunc factorize(n: Int) -> [Int] {\n    var factorization = [Int]()\n\
    \    var number = n\n    for i in 2..<n {\n        while number % i == 0 {\n \
    \           factorization.append(i)\n            number /= i\n        }\n    }\n\
    \    return factorization\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(factorize(n:\
    \ 2) == [2])\nassert(factorize(n: 4) == [2, 2])\nassert(factorize(n: 8) == [2,\
    \ 2, 2])\nassert(factorize(n: 57) == [3, 19])\nassert(factorize(n: 3249) == [3,\
    \ 3, 19, 19])\nassert(factorize(n: 185193) == [3, 3, 3, 19, 19, 19])\nassert(factorize(n:\
    \ 20577) == [3, 19, 19, 19])\nassert(factorize(n: 18) == [2, 3, 3])"
  status: Exception
  stderr: 'tmpgx8muyqi/tmpgx8muyqi.swift:36: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b44a47b3c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b44a44aab6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b44a44aa988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b44a44a97b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpgx8muyqi                        0x000055be2b2735b2 <unavailable> + 5554

    5    libc.so.6                          0x00002b44a499f460 __libc_start_main +
    245

    6    tmpgx8muyqi                        0x000055be2b273209 <unavailable> + 4617

    '
  stdout: ''
  timestamp: 1660009192
- exit_code: 0
  program: "\n/// Return array of prime factors of given integer in the order from\
    \ smallest to largest.\n/// Each of the factors should be arrayed number of times\
    \ corresponding to how many times it appeares in factorization.\n/// Input number\
    \ should be equal to the product of all factors\n/// >>> factorize(n: 8)\n///\
    \ [2, 2, 2]\n/// >>> factorize(n: 25)\n/// [5, 5]\n/// >>> factorize(n: 70)\n\
    /// [2, 5, 7]\nfunc factorize(n: Int) -> [Int] {\n    var arr: [Int] = []\n  \
    \  var div = 2\n    var num = n\n    while num > 1 {\n        if num % div ==\
    \ 0 {\n            arr.append(div)\n            num /= div\n        } else {\n\
    \            div += 1\n        }\n    }\n    return arr\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(factorize(n: 2) == [2])\nassert(factorize(n: 4) == [2,\
    \ 2])\nassert(factorize(n: 8) == [2, 2, 2])\nassert(factorize(n: 57) == [3, 19])\n\
    assert(factorize(n: 3249) == [3, 3, 19, 19])\nassert(factorize(n: 185193) == [3,\
    \ 3, 3, 19, 19, 19])\nassert(factorize(n: 20577) == [3, 19, 19, 19])\nassert(factorize(n:\
    \ 18) == [2, 3, 3])"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660009192
- exit_code: 1
  program: "\n/// Return array of prime factors of given integer in the order from\
    \ smallest to largest.\n/// Each of the factors should be arrayed number of times\
    \ corresponding to how many times it appeares in factorization.\n/// Input number\
    \ should be equal to the product of all factors\n/// >>> factorize(n: 8)\n///\
    \ [2, 2, 2]\n/// >>> factorize(n: 25)\n/// [5, 5]\n/// >>> factorize(n: 70)\n\
    /// [2, 5, 7]\nfunc factorize(n: Int) -> [Int] {\n    var result: [Int] = []\n\
    \    var num = n\n    for i in 2...Int(sqrt(Double(n))) {\n        while num %\
    \ i == 0 {\n            result.append(i)\n            num /= i\n        }\n  \
    \  }\n    return result\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(factorize(n:\
    \ 2) == [2])\nassert(factorize(n: 4) == [2, 2])\nassert(factorize(n: 8) == [2,\
    \ 2, 2])\nassert(factorize(n: 57) == [3, 19])\nassert(factorize(n: 3249) == [3,\
    \ 3, 19, 19])\nassert(factorize(n: 185193) == [3, 3, 3, 19, 19, 19])\nassert(factorize(n:\
    \ 20577) == [3, 19, 19, 19])\nassert(factorize(n: 18) == [2, 3, 3])"
  status: SyntaxError
  stderr: "/tmp/tmprp31646c.swift:14:22: error: cannot find 'sqrt' in scope\n    for\
    \ i in 2...Int(sqrt(Double(n))) {\n                     ^~~~\n"
  stdout: ''
  timestamp: 1660009192
- exit_code: 0
  program: "\n/// Return array of prime factors of given integer in the order from\
    \ smallest to largest.\n/// Each of the factors should be arrayed number of times\
    \ corresponding to how many times it appeares in factorization.\n/// Input number\
    \ should be equal to the product of all factors\n/// >>> factorize(n: 8)\n///\
    \ [2, 2, 2]\n/// >>> factorize(n: 25)\n/// [5, 5]\n/// >>> factorize(n: 70)\n\
    /// [2, 5, 7]\nfunc factorize(n: Int) -> [Int] {\n    var result: [Int] = []\n\
    \    var prime: Int = 2\n    var number: Int = n\n    while number > 1 {\n   \
    \     while number % prime == 0 {\n            result.append(prime)\n        \
    \    number /= prime\n        }\n        prime += 1\n    }\n    return result\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(factorize(n: 2) == [2])\nassert(factorize(n: 4)\
    \ == [2, 2])\nassert(factorize(n: 8) == [2, 2, 2])\nassert(factorize(n: 57) ==\
    \ [3, 19])\nassert(factorize(n: 3249) == [3, 3, 19, 19])\nassert(factorize(n:\
    \ 185193) == [3, 3, 3, 19, 19, 19])\nassert(factorize(n: 20577) == [3, 19, 19,\
    \ 19])\nassert(factorize(n: 18) == [2, 3, 3])"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660009192
- exit_code: 1
  program: "\n/// Return array of prime factors of given integer in the order from\
    \ smallest to largest.\n/// Each of the factors should be arrayed number of times\
    \ corresponding to how many times it appeares in factorization.\n/// Input number\
    \ should be equal to the product of all factors\n/// >>> factorize(n: 8)\n///\
    \ [2, 2, 2]\n/// >>> factorize(n: 25)\n/// [5, 5]\n/// >>> factorize(n: 70)\n\
    /// [2, 5, 7]\nfunc factorize(n: Int) -> [Int] {\n    var result: [Int] = []\n\
    \    for i in 2...n {\n        while n % i == 0 {\n            result.append(i)\n\
    \            n /= i\n        }\n    }\n    return result\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(factorize(n: 2) == [2])\nassert(factorize(n: 4) == [2,\
    \ 2])\nassert(factorize(n: 8) == [2, 2, 2])\nassert(factorize(n: 57) == [3, 19])\n\
    assert(factorize(n: 3249) == [3, 3, 19, 19])\nassert(factorize(n: 185193) == [3,\
    \ 3, 3, 19, 19, 19])\nassert(factorize(n: 20577) == [3, 19, 19, 19])\nassert(factorize(n:\
    \ 18) == [2, 3, 3])"
  status: SyntaxError
  stderr: "/tmp/tmpuyjijfv6.swift:16:15: error: left side of mutating operator isn't\
    \ mutable: 'n' is a 'let' constant\n            n /= i\n            ~ ^\n"
  stdout: ''
  timestamp: 1660009192
- exit_code: 1
  program: "\n/// Return array of prime factors of given integer in the order from\
    \ smallest to largest.\n/// Each of the factors should be arrayed number of times\
    \ corresponding to how many times it appeares in factorization.\n/// Input number\
    \ should be equal to the product of all factors\n/// >>> factorize(n: 8)\n///\
    \ [2, 2, 2]\n/// >>> factorize(n: 25)\n/// [5, 5]\n/// >>> factorize(n: 70)\n\
    /// [2, 5, 7]\nfunc factorize(n: Int) -> [Int] {\n    var number = n\n    var\
    \ list = [Int]()\n    for i in 2..<Int(sqrt(Double(n))) {\n        while (number\
    \ % i == 0) {\n            list.append(i)\n            number /= i\n        }\n\
    \    }\n    return list\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(factorize(n:\
    \ 2) == [2])\nassert(factorize(n: 4) == [2, 2])\nassert(factorize(n: 8) == [2,\
    \ 2, 2])\nassert(factorize(n: 57) == [3, 19])\nassert(factorize(n: 3249) == [3,\
    \ 3, 19, 19])\nassert(factorize(n: 185193) == [3, 3, 3, 19, 19, 19])\nassert(factorize(n:\
    \ 20577) == [3, 19, 19, 19])\nassert(factorize(n: 18) == [2, 3, 3])"
  status: SyntaxError
  stderr: "/tmp/tmp3qov_n87.swift:14:22: error: cannot find 'sqrt' in scope\n    for\
    \ i in 2..<Int(sqrt(Double(n))) {\n                     ^~~~\n"
  stdout: ''
  timestamp: 1660009192
- exit_code: 0
  program: "\n/// Return array of prime factors of given integer in the order from\
    \ smallest to largest.\n/// Each of the factors should be arrayed number of times\
    \ corresponding to how many times it appeares in factorization.\n/// Input number\
    \ should be equal to the product of all factors\n/// >>> factorize(n: 8)\n///\
    \ [2, 2, 2]\n/// >>> factorize(n: 25)\n/// [5, 5]\n/// >>> factorize(n: 70)\n\
    /// [2, 5, 7]\nfunc factorize(n: Int) -> [Int] {\n    var num = n\n    var factors\
    \ = [Int]()\n    var divisor = 2\n    while num > 1 {\n        while num % divisor\
    \ == 0 {\n            factors.append(divisor)\n            num /= divisor\n  \
    \      }\n        divisor += 1\n    }\n    return factors\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(factorize(n: 2) == [2])\nassert(factorize(n: 4) == [2,\
    \ 2])\nassert(factorize(n: 8) == [2, 2, 2])\nassert(factorize(n: 57) == [3, 19])\n\
    assert(factorize(n: 3249) == [3, 3, 19, 19])\nassert(factorize(n: 185193) == [3,\
    \ 3, 3, 19, 19, 19])\nassert(factorize(n: 20577) == [3, 19, 19, 19])\nassert(factorize(n:\
    \ 18) == [2, 3, 3])"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660009192
- exit_code: 0
  program: "\n/// Return array of prime factors of given integer in the order from\
    \ smallest to largest.\n/// Each of the factors should be arrayed number of times\
    \ corresponding to how many times it appeares in factorization.\n/// Input number\
    \ should be equal to the product of all factors\n/// >>> factorize(n: 8)\n///\
    \ [2, 2, 2]\n/// >>> factorize(n: 25)\n/// [5, 5]\n/// >>> factorize(n: 70)\n\
    /// [2, 5, 7]\nfunc factorize(n: Int) -> [Int] {\n    var result: [Int] = []\n\
    \    var number = n\n    for i in 2...number {\n        while number % i == 0\
    \ {\n            result.append(i)\n            number /= i\n        }\n    }\n\
    \    return result\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) ->\
    \ Bool {\n    if left.count != right.count {\n        return false\n    }\n  \
    \  for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(factorize(n: 2) ==\
    \ [2])\nassert(factorize(n: 4) == [2, 2])\nassert(factorize(n: 8) == [2, 2, 2])\n\
    assert(factorize(n: 57) == [3, 19])\nassert(factorize(n: 3249) == [3, 3, 19, 19])\n\
    assert(factorize(n: 185193) == [3, 3, 3, 19, 19, 19])\nassert(factorize(n: 20577)\
    \ == [3, 19, 19, 19])\nassert(factorize(n: 18) == [2, 3, 3])"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660009192
- exit_code: 0
  program: "\n/// Return array of prime factors of given integer in the order from\
    \ smallest to largest.\n/// Each of the factors should be arrayed number of times\
    \ corresponding to how many times it appeares in factorization.\n/// Input number\
    \ should be equal to the product of all factors\n/// >>> factorize(n: 8)\n///\
    \ [2, 2, 2]\n/// >>> factorize(n: 25)\n/// [5, 5]\n/// >>> factorize(n: 70)\n\
    /// [2, 5, 7]\nfunc factorize(n: Int) -> [Int] {\n    var factors = [Int]()\n\
    \    var number = n\n    var i = 2\n    while i * i <= number {\n        if number\
    \ % i == 0 {\n            factors.append(i)\n            number /= i\n       \
    \ } else {\n            i += 1\n        }\n    }\n    if number > 1 {\n      \
    \  factors.append(number)\n    }\n    return factors\n}\n\n\nfunc ==(left: [(Int,\
    \ Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n\
    \        return false\n    }\n    for (l, r) in zip(left, right) {\n        if\
    \ l != r {\n            return false\n        }\n    }\n    return true\n}\n \
    \           \nassert(factorize(n: 2) == [2])\nassert(factorize(n: 4) == [2, 2])\n\
    assert(factorize(n: 8) == [2, 2, 2])\nassert(factorize(n: 57) == [3, 19])\nassert(factorize(n:\
    \ 3249) == [3, 3, 19, 19])\nassert(factorize(n: 185193) == [3, 3, 3, 19, 19, 19])\n\
    assert(factorize(n: 20577) == [3, 19, 19, 19])\nassert(factorize(n: 18) == [2,\
    \ 3, 3])"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660009192
- exit_code: 1
  program: "\n/// Return array of prime factors of given integer in the order from\
    \ smallest to largest.\n/// Each of the factors should be arrayed number of times\
    \ corresponding to how many times it appeares in factorization.\n/// Input number\
    \ should be equal to the product of all factors\n/// >>> factorize(n: 8)\n///\
    \ [2, 2, 2]\n/// >>> factorize(n: 25)\n/// [5, 5]\n/// >>> factorize(n: 70)\n\
    /// [2, 5, 7]\nfunc factorize(n: Int) -> [Int] {\n    return n.primeFactors().sorted(by:\
    \ <)\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if\
    \ left.count != right.count {\n        return false\n    }\n    for (l, r) in\
    \ zip(left, right) {\n        if l != r {\n            return false\n        }\n\
    \    }\n    return true\n}\n            \nassert(factorize(n: 2) == [2])\nassert(factorize(n:\
    \ 4) == [2, 2])\nassert(factorize(n: 8) == [2, 2, 2])\nassert(factorize(n: 57)\
    \ == [3, 19])\nassert(factorize(n: 3249) == [3, 3, 19, 19])\nassert(factorize(n:\
    \ 185193) == [3, 3, 3, 19, 19, 19])\nassert(factorize(n: 20577) == [3, 19, 19,\
    \ 19])\nassert(factorize(n: 18) == [2, 3, 3])"
  status: SyntaxError
  stderr: "/tmp/tmpodkutyr5.swift:12:14: error: value of type 'Int' has no member\
    \ 'primeFactors'\n    return n.primeFactors().sorted(by: <)\n           ~ ^~~~~~~~~~~~\n"
  stdout: ''
  timestamp: 1660009192
- exit_code: -4
  program: "\n/// Return array of prime factors of given integer in the order from\
    \ smallest to largest.\n/// Each of the factors should be arrayed number of times\
    \ corresponding to how many times it appeares in factorization.\n/// Input number\
    \ should be equal to the product of all factors\n/// >>> factorize(n: 8)\n///\
    \ [2, 2, 2]\n/// >>> factorize(n: 25)\n/// [5, 5]\n/// >>> factorize(n: 70)\n\
    /// [2, 5, 7]\nfunc factorize(n: Int) -> [Int] {\n    return []\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(factorize(n: 2) == [2])\nassert(factorize(n: 4) == [2,\
    \ 2])\nassert(factorize(n: 8) == [2, 2, 2])\nassert(factorize(n: 57) == [3, 19])\n\
    assert(factorize(n: 3249) == [3, 3, 19, 19])\nassert(factorize(n: 185193) == [3,\
    \ 3, 3, 19, 19, 19])\nassert(factorize(n: 20577) == [3, 19, 19, 19])\nassert(factorize(n:\
    \ 18) == [2, 3, 3])"
  status: Exception
  stderr: 'tmpr8thvm9v/tmpr8thvm9v.swift:28: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b2608809c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b2608500b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b2608500988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b26084ff7b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpr8thvm9v                        0x0000555618631372 <unavailable> + 4978

    5    libc.so.6                          0x00002b26089f5460 __libc_start_main +
    245

    6    tmpr8thvm9v                        0x0000555618630fc9 <unavailable> + 4041

    '
  stdout: ''
  timestamp: 1660009191
- exit_code: 0
  program: "\n/// Return array of prime factors of given integer in the order from\
    \ smallest to largest.\n/// Each of the factors should be arrayed number of times\
    \ corresponding to how many times it appeares in factorization.\n/// Input number\
    \ should be equal to the product of all factors\n/// >>> factorize(n: 8)\n///\
    \ [2, 2, 2]\n/// >>> factorize(n: 25)\n/// [5, 5]\n/// >>> factorize(n: 70)\n\
    /// [2, 5, 7]\nfunc factorize(n: Int) -> [Int] {\n    var result = [Int]()\n \
    \   var divisor = 2\n    var number = n\n    while divisor * divisor <= number\
    \ {\n        if number % divisor == 0 {\n            result.append(divisor)\n\
    \            number /= divisor\n        } else {\n            divisor += 1\n \
    \       }\n    }\n    if number > 1 {\n        result.append(number)\n    }\n\
    \    return result\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) ->\
    \ Bool {\n    if left.count != right.count {\n        return false\n    }\n  \
    \  for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(factorize(n: 2) ==\
    \ [2])\nassert(factorize(n: 4) == [2, 2])\nassert(factorize(n: 8) == [2, 2, 2])\n\
    assert(factorize(n: 57) == [3, 19])\nassert(factorize(n: 3249) == [3, 3, 19, 19])\n\
    assert(factorize(n: 185193) == [3, 3, 3, 19, 19, 19])\nassert(factorize(n: 20577)\
    \ == [3, 19, 19, 19])\nassert(factorize(n: 18) == [2, 3, 3])"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660009192
- exit_code: 0
  program: "\n/// Return array of prime factors of given integer in the order from\
    \ smallest to largest.\n/// Each of the factors should be arrayed number of times\
    \ corresponding to how many times it appeares in factorization.\n/// Input number\
    \ should be equal to the product of all factors\n/// >>> factorize(n: 8)\n///\
    \ [2, 2, 2]\n/// >>> factorize(n: 25)\n/// [5, 5]\n/// >>> factorize(n: 70)\n\
    /// [2, 5, 7]\nfunc factorize(n: Int) -> [Int] {\n    var primeFactors = [Int]()\n\
    \    var number = n\n    var factor = 2\n    while factor * factor <= number {\n\
    \        if number % factor == 0 {\n            primeFactors.append(factor)\n\
    \            number /= factor\n        } else {\n            factor += factor\
    \ == 2 ? 1 : 2\n        }\n    }\n    if number > 1 {\n        primeFactors.append(number)\n\
    \    }\n    return primeFactors\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int,\
    \ Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n\
    \    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n          \
    \  return false\n        }\n    }\n    return true\n}\n            \nassert(factorize(n:\
    \ 2) == [2])\nassert(factorize(n: 4) == [2, 2])\nassert(factorize(n: 8) == [2,\
    \ 2, 2])\nassert(factorize(n: 57) == [3, 19])\nassert(factorize(n: 3249) == [3,\
    \ 3, 19, 19])\nassert(factorize(n: 185193) == [3, 3, 3, 19, 19, 19])\nassert(factorize(n:\
    \ 20577) == [3, 19, 19, 19])\nassert(factorize(n: 18) == [2, 3, 3])"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660009192
- exit_code: 0
  program: "\n/// Return array of prime factors of given integer in the order from\
    \ smallest to largest.\n/// Each of the factors should be arrayed number of times\
    \ corresponding to how many times it appeares in factorization.\n/// Input number\
    \ should be equal to the product of all factors\n/// >>> factorize(n: 8)\n///\
    \ [2, 2, 2]\n/// >>> factorize(n: 25)\n/// [5, 5]\n/// >>> factorize(n: 70)\n\
    /// [2, 5, 7]\nfunc factorize(n: Int) -> [Int] {\n    var factors: [Int] = []\n\
    \    var factor = 2\n    var number = n\n    while factor * factor <= number {\n\
    \        while number % factor == 0 {\n            factors.append(factor)\n  \
    \          number /= factor\n        }\n        factor += 1\n    }\n    if number\
    \ > 1 {\n        factors.append(number)\n    }\n    return factors\n}\n\n\nfunc\
    \ ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count !=\
    \ right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(factorize(n: 2) == [2])\nassert(factorize(n: 4)\
    \ == [2, 2])\nassert(factorize(n: 8) == [2, 2, 2])\nassert(factorize(n: 57) ==\
    \ [3, 19])\nassert(factorize(n: 3249) == [3, 3, 19, 19])\nassert(factorize(n:\
    \ 185193) == [3, 3, 3, 19, 19, 19])\nassert(factorize(n: 20577) == [3, 19, 19,\
    \ 19])\nassert(factorize(n: 18) == [2, 3, 3])"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660009192
- exit_code: 0
  program: "\n/// Return array of prime factors of given integer in the order from\
    \ smallest to largest.\n/// Each of the factors should be arrayed number of times\
    \ corresponding to how many times it appeares in factorization.\n/// Input number\
    \ should be equal to the product of all factors\n/// >>> factorize(n: 8)\n///\
    \ [2, 2, 2]\n/// >>> factorize(n: 25)\n/// [5, 5]\n/// >>> factorize(n: 70)\n\
    /// [2, 5, 7]\nfunc factorize(n: Int) -> [Int] {\n    var result = [Int]()\n \
    \   var number = n\n    var prime = 2\n    while prime * prime <= number {\n \
    \       while number % prime == 0 {\n            result.append(prime)\n      \
    \      number /= prime\n        }\n        prime += 1\n    }\n    if number >\
    \ 1 {\n        result.append(number)\n    }\n    return result\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(factorize(n: 2) == [2])\nassert(factorize(n: 4) == [2,\
    \ 2])\nassert(factorize(n: 8) == [2, 2, 2])\nassert(factorize(n: 57) == [3, 19])\n\
    assert(factorize(n: 3249) == [3, 3, 19, 19])\nassert(factorize(n: 185193) == [3,\
    \ 3, 3, 19, 19, 19])\nassert(factorize(n: 20577) == [3, 19, 19, 19])\nassert(factorize(n:\
    \ 18) == [2, 3, 3])"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660009192
- exit_code: 1
  program: "\n/// Return array of prime factors of given integer in the order from\
    \ smallest to largest.\n/// Each of the factors should be arrayed number of times\
    \ corresponding to how many times it appeares in factorization.\n/// Input number\
    \ should be equal to the product of all factors\n/// >>> factorize(n: 8)\n///\
    \ [2, 2, 2]\n/// >>> factorize(n: 25)\n/// [5, 5]\n/// >>> factorize(n: 70)\n\
    /// [2, 5, 7]\nfunc factorize(n: Int) -> [Int] {\n    if (n == 0 || n == 1) {\n\
    \        return [n]\n    }\n    var num = n\n    var factors = [Int]()\n    for\
    \ prime in primes {\n        if (num % prime == 0) {\n            while (num %\
    \ prime == 0) {\n                factors.append(prime)\n                num /=\
    \ prime\n            }\n        }\n    }\n    return factors\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(factorize(n: 2) == [2])\nassert(factorize(n: 4) == [2,\
    \ 2])\nassert(factorize(n: 8) == [2, 2, 2])\nassert(factorize(n: 57) == [3, 19])\n\
    assert(factorize(n: 3249) == [3, 3, 19, 19])\nassert(factorize(n: 185193) == [3,\
    \ 3, 3, 19, 19, 19])\nassert(factorize(n: 20577) == [3, 19, 19, 19])\nassert(factorize(n:\
    \ 18) == [2, 3, 3])"
  status: SyntaxError
  stderr: "/tmp/tmpwepkaa1a.swift:17:18: error: cannot find 'primes' in scope\n  \
    \  for prime in primes {\n                 ^~~~~~\n"
  stdout: ''
  timestamp: 1660009192
- exit_code: 0
  program: "\n/// Return array of prime factors of given integer in the order from\
    \ smallest to largest.\n/// Each of the factors should be arrayed number of times\
    \ corresponding to how many times it appeares in factorization.\n/// Input number\
    \ should be equal to the product of all factors\n/// >>> factorize(n: 8)\n///\
    \ [2, 2, 2]\n/// >>> factorize(n: 25)\n/// [5, 5]\n/// >>> factorize(n: 70)\n\
    /// [2, 5, 7]\nfunc factorize(n: Int) -> [Int] {\n    var n = n\n    var result:\
    \ [Int] = []\n    var divisor = 2\n    while n > 1 {\n        if n % divisor ==\
    \ 0 {\n            result.append(divisor)\n            n /= divisor\n        }\
    \ else {\n            divisor += 1\n        }\n    }\n    return result\n}\n\n\
    \nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(factorize(n: 2) == [2])\nassert(factorize(n: 4)\
    \ == [2, 2])\nassert(factorize(n: 8) == [2, 2, 2])\nassert(factorize(n: 57) ==\
    \ [3, 19])\nassert(factorize(n: 3249) == [3, 3, 19, 19])\nassert(factorize(n:\
    \ 185193) == [3, 3, 3, 19, 19, 19])\nassert(factorize(n: 20577) == [3, 19, 19,\
    \ 19])\nassert(factorize(n: 18) == [2, 3, 3])"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660009192
- exit_code: 0
  program: "\n/// Return array of prime factors of given integer in the order from\
    \ smallest to largest.\n/// Each of the factors should be arrayed number of times\
    \ corresponding to how many times it appeares in factorization.\n/// Input number\
    \ should be equal to the product of all factors\n/// >>> factorize(n: 8)\n///\
    \ [2, 2, 2]\n/// >>> factorize(n: 25)\n/// [5, 5]\n/// >>> factorize(n: 70)\n\
    /// [2, 5, 7]\nfunc factorize(n: Int) -> [Int] {\n    var target = n\n    var\
    \ factors = [Int]()\n    var i = 2\n    while i <= target {\n        if target\
    \ % i == 0 {\n            factors.append(i)\n            target /= i\n       \
    \ } else {\n            i += 1\n        }\n    }\n    return factors\n}\n\n\n\
    func ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(factorize(n: 2) == [2])\nassert(factorize(n: 4)\
    \ == [2, 2])\nassert(factorize(n: 8) == [2, 2, 2])\nassert(factorize(n: 57) ==\
    \ [3, 19])\nassert(factorize(n: 3249) == [3, 3, 19, 19])\nassert(factorize(n:\
    \ 185193) == [3, 3, 3, 19, 19, 19])\nassert(factorize(n: 20577) == [3, 19, 19,\
    \ 19])\nassert(factorize(n: 18) == [2, 3, 3])"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660009192
- exit_code: 0
  program: "\n/// Return array of prime factors of given integer in the order from\
    \ smallest to largest.\n/// Each of the factors should be arrayed number of times\
    \ corresponding to how many times it appeares in factorization.\n/// Input number\
    \ should be equal to the product of all factors\n/// >>> factorize(n: 8)\n///\
    \ [2, 2, 2]\n/// >>> factorize(n: 25)\n/// [5, 5]\n/// >>> factorize(n: 70)\n\
    /// [2, 5, 7]\nfunc factorize(n: Int) -> [Int] {\n    var n = n\n    var factors\
    \ = [Int]()\n    var divider = 2\n    while n > 1 {\n        while n % divider\
    \ == 0 {\n            factors.append(divider)\n            n /= divider\n    \
    \    }\n        divider += 1\n    }\n    return factors\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(factorize(n: 2) == [2])\nassert(factorize(n: 4) == [2,\
    \ 2])\nassert(factorize(n: 8) == [2, 2, 2])\nassert(factorize(n: 57) == [3, 19])\n\
    assert(factorize(n: 3249) == [3, 3, 19, 19])\nassert(factorize(n: 185193) == [3,\
    \ 3, 3, 19, 19, 19])\nassert(factorize(n: 20577) == [3, 19, 19, 19])\nassert(factorize(n:\
    \ 18) == [2, 3, 3])"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660009192
- exit_code: 0
  program: "\n/// Return array of prime factors of given integer in the order from\
    \ smallest to largest.\n/// Each of the factors should be arrayed number of times\
    \ corresponding to how many times it appeares in factorization.\n/// Input number\
    \ should be equal to the product of all factors\n/// >>> factorize(n: 8)\n///\
    \ [2, 2, 2]\n/// >>> factorize(n: 25)\n/// [5, 5]\n/// >>> factorize(n: 70)\n\
    /// [2, 5, 7]\nfunc factorize(n: Int) -> [Int] {\n    var num = n\n    var factors\
    \ = [Int]()\n    var i = 2\n    while i * i <= num {\n        if num % i == 0\
    \ {\n            factors.append(i)\n            num /= i\n        } else {\n \
    \           i += 1\n        }\n    }\n    if num > 1 {\n        factors.append(num)\n\
    \    }\n    return factors\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(factorize(n:\
    \ 2) == [2])\nassert(factorize(n: 4) == [2, 2])\nassert(factorize(n: 8) == [2,\
    \ 2, 2])\nassert(factorize(n: 57) == [3, 19])\nassert(factorize(n: 3249) == [3,\
    \ 3, 19, 19])\nassert(factorize(n: 185193) == [3, 3, 3, 19, 19, 19])\nassert(factorize(n:\
    \ 20577) == [3, 19, 19, 19])\nassert(factorize(n: 18) == [2, 3, 3])"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660009192
- exit_code: 1
  program: "\n/// Return array of prime factors of given integer in the order from\
    \ smallest to largest.\n/// Each of the factors should be arrayed number of times\
    \ corresponding to how many times it appeares in factorization.\n/// Input number\
    \ should be equal to the product of all factors\n/// >>> factorize(n: 8)\n///\
    \ [2, 2, 2]\n/// >>> factorize(n: 25)\n/// [5, 5]\n/// >>> factorize(n: 70)\n\
    /// [2, 5, 7]\nfunc factorize(n: Int) -> [Int] {\n    guard n > 0 else { return\
    \ [] }\n    var primeFactors = [Int]()\n    var m = n\n    while m > 1 {\n   \
    \     let factor = smallestPrimeFactor(m)\n        primeFactors.append(factor)\n\
    \        m /= factor\n    }\n    return primeFactors\n}\n\n\nfunc ==(left: [(Int,\
    \ Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n\
    \        return false\n    }\n    for (l, r) in zip(left, right) {\n        if\
    \ l != r {\n            return false\n        }\n    }\n    return true\n}\n \
    \           \nassert(factorize(n: 2) == [2])\nassert(factorize(n: 4) == [2, 2])\n\
    assert(factorize(n: 8) == [2, 2, 2])\nassert(factorize(n: 57) == [3, 19])\nassert(factorize(n:\
    \ 3249) == [3, 3, 19, 19])\nassert(factorize(n: 185193) == [3, 3, 3, 19, 19, 19])\n\
    assert(factorize(n: 20577) == [3, 19, 19, 19])\nassert(factorize(n: 18) == [2,\
    \ 3, 3])"
  status: SyntaxError
  stderr: "/tmp/tmplgnl0czl.swift:16:22: error: cannot find 'smallestPrimeFactor'\
    \ in scope\n        let factor = smallestPrimeFactor(m)\n                    \
    \ ^~~~~~~~~~~~~~~~~~~\n"
  stdout: ''
  timestamp: 1660009192
- exit_code: 1
  program: "\n/// Return array of prime factors of given integer in the order from\
    \ smallest to largest.\n/// Each of the factors should be arrayed number of times\
    \ corresponding to how many times it appeares in factorization.\n/// Input number\
    \ should be equal to the product of all factors\n/// >>> factorize(n: 8)\n///\
    \ [2, 2, 2]\n/// >>> factorize(n: 25)\n/// [5, 5]\n/// >>> factorize(n: 70)\n\
    /// [2, 5, 7]\nfunc factorize(n: Int) -> [Int] {\n    var copy = n\n    var primeFactors\
    \ = [Int]()\n    var currPrime: Int\n    var i = 2\n    while (copy != 1) {\n\
    \        currPrime = Int(nextPrime(start: i))\n        while (copy % currPrime\
    \ == 0) {\n            primeFactors.append(currPrime)\n            copy /= currPrime\n\
    \        }\n        i = currPrime + 1\n    }\n    return primeFactors\n}\n\n\n\
    func ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(factorize(n: 2) == [2])\nassert(factorize(n: 4)\
    \ == [2, 2])\nassert(factorize(n: 8) == [2, 2, 2])\nassert(factorize(n: 57) ==\
    \ [3, 19])\nassert(factorize(n: 3249) == [3, 3, 19, 19])\nassert(factorize(n:\
    \ 185193) == [3, 3, 3, 19, 19, 19])\nassert(factorize(n: 20577) == [3, 19, 19,\
    \ 19])\nassert(factorize(n: 18) == [2, 3, 3])"
  status: SyntaxError
  stderr: "/tmp/tmpfbnoybxm.swift:17:25: error: cannot find 'nextPrime' in scope\n\
    \        currPrime = Int(nextPrime(start: i))\n                        ^~~~~~~~~\n"
  stdout: ''
  timestamp: 1660009192
- exit_code: 0
  program: "\n/// Return array of prime factors of given integer in the order from\
    \ smallest to largest.\n/// Each of the factors should be arrayed number of times\
    \ corresponding to how many times it appeares in factorization.\n/// Input number\
    \ should be equal to the product of all factors\n/// >>> factorize(n: 8)\n///\
    \ [2, 2, 2]\n/// >>> factorize(n: 25)\n/// [5, 5]\n/// >>> factorize(n: 70)\n\
    /// [2, 5, 7]\nfunc factorize(n: Int) -> [Int] {\n    var n = n\n    var primeFactors\
    \ = [Int]()\n    var p = 2\n    while p <= n {\n        while n % p == 0 {\n \
    \           primeFactors.append(p)\n            n /= p\n        }\n        p +=\
    \ 1\n    }\n    return primeFactors\n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(factorize(n: 2) == [2])\nassert(factorize(n: 4) == [2, 2])\nassert(factorize(n:\
    \ 8) == [2, 2, 2])\nassert(factorize(n: 57) == [3, 19])\nassert(factorize(n: 3249)\
    \ == [3, 3, 19, 19])\nassert(factorize(n: 185193) == [3, 3, 3, 19, 19, 19])\n\
    assert(factorize(n: 20577) == [3, 19, 19, 19])\nassert(factorize(n: 18) == [2,\
    \ 3, 3])"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660009192
- exit_code: 0
  program: "\n/// Return array of prime factors of given integer in the order from\
    \ smallest to largest.\n/// Each of the factors should be arrayed number of times\
    \ corresponding to how many times it appeares in factorization.\n/// Input number\
    \ should be equal to the product of all factors\n/// >>> factorize(n: 8)\n///\
    \ [2, 2, 2]\n/// >>> factorize(n: 25)\n/// [5, 5]\n/// >>> factorize(n: 70)\n\
    /// [2, 5, 7]\nfunc factorize(n: Int) -> [Int] {\n    var n = n\n    var factors\
    \ = [Int]()\n    var i = 2\n    while i * i <= n {\n        while n % i == 0 {\n\
    \            factors.append(i)\n            n /= i\n        }\n        i += 1\n\
    \    }\n    if n > 1 {\n        factors.append(n)\n    }\n    return factors\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(factorize(n: 2) == [2])\nassert(factorize(n: 4)\
    \ == [2, 2])\nassert(factorize(n: 8) == [2, 2, 2])\nassert(factorize(n: 57) ==\
    \ [3, 19])\nassert(factorize(n: 3249) == [3, 3, 19, 19])\nassert(factorize(n:\
    \ 185193) == [3, 3, 3, 19, 19, 19])\nassert(factorize(n: 20577) == [3, 19, 19,\
    \ 19])\nassert(factorize(n: 18) == [2, 3, 3])"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660009192
- exit_code: 0
  program: "\n/// Return array of prime factors of given integer in the order from\
    \ smallest to largest.\n/// Each of the factors should be arrayed number of times\
    \ corresponding to how many times it appeares in factorization.\n/// Input number\
    \ should be equal to the product of all factors\n/// >>> factorize(n: 8)\n///\
    \ [2, 2, 2]\n/// >>> factorize(n: 25)\n/// [5, 5]\n/// >>> factorize(n: 70)\n\
    /// [2, 5, 7]\nfunc factorize(n: Int) -> [Int] {\n    var factor = [Int]()\n \
    \   var number = n\n    var i = 2\n    while i*i <= number {\n        if number\
    \ % i == 0 {\n            factor.append(i)\n            number /= i\n        }\
    \ else {\n            i += 1\n        }\n    }\n    if number > 1 {\n        factor.append(number)\n\
    \    }\n    return factor\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(factorize(n:\
    \ 2) == [2])\nassert(factorize(n: 4) == [2, 2])\nassert(factorize(n: 8) == [2,\
    \ 2, 2])\nassert(factorize(n: 57) == [3, 19])\nassert(factorize(n: 3249) == [3,\
    \ 3, 19, 19])\nassert(factorize(n: 185193) == [3, 3, 3, 19, 19, 19])\nassert(factorize(n:\
    \ 20577) == [3, 19, 19, 19])\nassert(factorize(n: 18) == [2, 3, 3])"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660009192
- exit_code: 1
  program: "\n/// Return array of prime factors of given integer in the order from\
    \ smallest to largest.\n/// Each of the factors should be arrayed number of times\
    \ corresponding to how many times it appeares in factorization.\n/// Input number\
    \ should be equal to the product of all factors\n/// >>> factorize(n: 8)\n///\
    \ [2, 2, 2]\n/// >>> factorize(n: 25)\n/// [5, 5]\n/// >>> factorize(n: 70)\n\
    /// [2, 5, 7]\nfunc factorize(n: Int) -> [Int] {\n    var number = n\n    var\
    \ primeFactors = [Int]()\n    while number % 2 == 0 {\n        primeFactors.append(2)\n\
    \        number /= 2\n    }\n    let last = Int(ceil(sqrt(Double(number))))\n\
    \    for i in 3...last {\n        while number % i == 0 {\n            primeFactors.append(i)\n\
    \            number /= i\n        }\n    }\n    if number > 2 {\n        primeFactors.append(number)\n\
    \    }\n    return primeFactors\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int,\
    \ Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n\
    \    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n          \
    \  return false\n        }\n    }\n    return true\n}\n            \nassert(factorize(n:\
    \ 2) == [2])\nassert(factorize(n: 4) == [2, 2])\nassert(factorize(n: 8) == [2,\
    \ 2, 2])\nassert(factorize(n: 57) == [3, 19])\nassert(factorize(n: 3249) == [3,\
    \ 3, 19, 19])\nassert(factorize(n: 185193) == [3, 3, 3, 19, 19, 19])\nassert(factorize(n:\
    \ 20577) == [3, 19, 19, 19])\nassert(factorize(n: 18) == [2, 3, 3])"
  status: SyntaxError
  stderr: "/tmp/tmp2bk2d0n0.swift:18:20: error: cannot find 'ceil' in scope\n    let\
    \ last = Int(ceil(sqrt(Double(number))))\n                   ^~~~\n/tmp/tmp2bk2d0n0.swift:18:25:\
    \ error: cannot find 'sqrt' in scope\n    let last = Int(ceil(sqrt(Double(number))))\n\
    \                        ^~~~\n"
  stdout: ''
  timestamp: 1660009192
- exit_code: -4
  program: "\n/// Return array of prime factors of given integer in the order from\
    \ smallest to largest.\n/// Each of the factors should be arrayed number of times\
    \ corresponding to how many times it appeares in factorization.\n/// Input number\
    \ should be equal to the product of all factors\n/// >>> factorize(n: 8)\n///\
    \ [2, 2, 2]\n/// >>> factorize(n: 25)\n/// [5, 5]\n/// >>> factorize(n: 70)\n\
    /// [2, 5, 7]\nfunc factorize(n: Int) -> [Int] {\n    // your code here\n    return\
    \ []\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if\
    \ left.count != right.count {\n        return false\n    }\n    for (l, r) in\
    \ zip(left, right) {\n        if l != r {\n            return false\n        }\n\
    \    }\n    return true\n}\n            \nassert(factorize(n: 2) == [2])\nassert(factorize(n:\
    \ 4) == [2, 2])\nassert(factorize(n: 8) == [2, 2, 2])\nassert(factorize(n: 57)\
    \ == [3, 19])\nassert(factorize(n: 3249) == [3, 3, 19, 19])\nassert(factorize(n:\
    \ 185193) == [3, 3, 3, 19, 19, 19])\nassert(factorize(n: 20577) == [3, 19, 19,\
    \ 19])\nassert(factorize(n: 18) == [2, 3, 3])"
  status: Exception
  stderr: 'tmpakr6o9ao/tmpakr6o9ao.swift:29: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b2b4571bc80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b2b45412b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b2b45412988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b2b454117b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpakr6o9ao                        0x00005591bd6e1372 <unavailable> + 4978

    5    libc.so.6                          0x00002b2b45907460 __libc_start_main +
    245

    6    tmpakr6o9ao                        0x00005591bd6e0fc9 <unavailable> + 4041

    '
  stdout: ''
  timestamp: 1660009192
- exit_code: 0
  program: "\n/// Return array of prime factors of given integer in the order from\
    \ smallest to largest.\n/// Each of the factors should be arrayed number of times\
    \ corresponding to how many times it appeares in factorization.\n/// Input number\
    \ should be equal to the product of all factors\n/// >>> factorize(n: 8)\n///\
    \ [2, 2, 2]\n/// >>> factorize(n: 25)\n/// [5, 5]\n/// >>> factorize(n: 70)\n\
    /// [2, 5, 7]\nfunc factorize(n: Int) -> [Int] {\n    var number = n\n    var\
    \ factors = [Int]()\n    var i = 2\n    while number != 1 {\n        if number\
    \ % i == 0 {\n            factors.append(i)\n            number /= i\n       \
    \ } else {\n            i += 1\n        }\n    }\n    return factors\n}\n\n\n\
    func ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(factorize(n: 2) == [2])\nassert(factorize(n: 4)\
    \ == [2, 2])\nassert(factorize(n: 8) == [2, 2, 2])\nassert(factorize(n: 57) ==\
    \ [3, 19])\nassert(factorize(n: 3249) == [3, 3, 19, 19])\nassert(factorize(n:\
    \ 185193) == [3, 3, 3, 19, 19, 19])\nassert(factorize(n: 20577) == [3, 19, 19,\
    \ 19])\nassert(factorize(n: 18) == [2, 3, 3])"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660009192
- exit_code: 0
  program: "\n/// Return array of prime factors of given integer in the order from\
    \ smallest to largest.\n/// Each of the factors should be arrayed number of times\
    \ corresponding to how many times it appeares in factorization.\n/// Input number\
    \ should be equal to the product of all factors\n/// >>> factorize(n: 8)\n///\
    \ [2, 2, 2]\n/// >>> factorize(n: 25)\n/// [5, 5]\n/// >>> factorize(n: 70)\n\
    /// [2, 5, 7]\nfunc factorize(n: Int) -> [Int] {\n    var primeFactors = [Int]()\n\
    \    var n = n\n    while n % 2 == 0 {\n        primeFactors.append(2)\n     \
    \   n /= 2\n    }\n    for i in stride(from: 3, through: n, by: 2) {\n       \
    \ while n % i == 0 {\n            primeFactors.append(i)\n            n /= i\n\
    \        }\n    }\n    return primeFactors\n}\n\n\nfunc ==(left: [(Int, Int)],\
    \ right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n       \
    \ return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r\
    \ {\n            return false\n        }\n    }\n    return true\n}\n        \
    \    \nassert(factorize(n: 2) == [2])\nassert(factorize(n: 4) == [2, 2])\nassert(factorize(n:\
    \ 8) == [2, 2, 2])\nassert(factorize(n: 57) == [3, 19])\nassert(factorize(n: 3249)\
    \ == [3, 3, 19, 19])\nassert(factorize(n: 185193) == [3, 3, 3, 19, 19, 19])\n\
    assert(factorize(n: 20577) == [3, 19, 19, 19])\nassert(factorize(n: 18) == [2,\
    \ 3, 3])"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660009192
- exit_code: 0
  program: "\n/// Return array of prime factors of given integer in the order from\
    \ smallest to largest.\n/// Each of the factors should be arrayed number of times\
    \ corresponding to how many times it appeares in factorization.\n/// Input number\
    \ should be equal to the product of all factors\n/// >>> factorize(n: 8)\n///\
    \ [2, 2, 2]\n/// >>> factorize(n: 25)\n/// [5, 5]\n/// >>> factorize(n: 70)\n\
    /// [2, 5, 7]\nfunc factorize(n: Int) -> [Int] {\n    var number = n\n    var\
    \ factors = [Int]()\n    var factor = 2\n    while factor <= number / factor {\n\
    \        while number % factor == 0 {\n            factors.append(factor)\n  \
    \          number /= factor\n        }\n        factor += 1\n    }\n    if number\
    \ > 1 {\n        factors.append(number)\n    }\n    return factors\n}\n\n\nfunc\
    \ ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count !=\
    \ right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(factorize(n: 2) == [2])\nassert(factorize(n: 4)\
    \ == [2, 2])\nassert(factorize(n: 8) == [2, 2, 2])\nassert(factorize(n: 57) ==\
    \ [3, 19])\nassert(factorize(n: 3249) == [3, 3, 19, 19])\nassert(factorize(n:\
    \ 185193) == [3, 3, 3, 19, 19, 19])\nassert(factorize(n: 20577) == [3, 19, 19,\
    \ 19])\nassert(factorize(n: 18) == [2, 3, 3])"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660009192
- exit_code: 0
  program: "\n/// Return array of prime factors of given integer in the order from\
    \ smallest to largest.\n/// Each of the factors should be arrayed number of times\
    \ corresponding to how many times it appeares in factorization.\n/// Input number\
    \ should be equal to the product of all factors\n/// >>> factorize(n: 8)\n///\
    \ [2, 2, 2]\n/// >>> factorize(n: 25)\n/// [5, 5]\n/// >>> factorize(n: 70)\n\
    /// [2, 5, 7]\nfunc factorize(n: Int) -> [Int] {\n    var n = n\n    var result\
    \ = [Int]()\n    var i = 2\n    while i * i <= n {\n        while n % i == 0 {\n\
    \            result.append(i)\n            n /= i\n        }\n        i += 1\n\
    \    }\n    if n > 1 {\n        result.append(n)\n    }\n    return result\n}\n\
    \n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(factorize(n: 2) == [2])\nassert(factorize(n: 4)\
    \ == [2, 2])\nassert(factorize(n: 8) == [2, 2, 2])\nassert(factorize(n: 57) ==\
    \ [3, 19])\nassert(factorize(n: 3249) == [3, 3, 19, 19])\nassert(factorize(n:\
    \ 185193) == [3, 3, 3, 19, 19, 19])\nassert(factorize(n: 20577) == [3, 19, 19,\
    \ 19])\nassert(factorize(n: 18) == [2, 3, 3])"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660009191
- exit_code: 1
  program: "\n/// Return array of prime factors of given integer in the order from\
    \ smallest to largest.\n/// Each of the factors should be arrayed number of times\
    \ corresponding to how many times it appeares in factorization.\n/// Input number\
    \ should be equal to the product of all factors\n/// >>> factorize(n: 8)\n///\
    \ [2, 2, 2]\n/// >>> factorize(n: 25)\n/// [5, 5]\n/// >>> factorize(n: 70)\n\
    /// [2, 5, 7]\nfunc factorize(n: Int) -> [Int] {\n    let factors = findFactors(n:\
    \ n)\n    return factorization(factors: factors)\n}\n\n\nfunc ==(left: [(Int,\
    \ Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n\
    \        return false\n    }\n    for (l, r) in zip(left, right) {\n        if\
    \ l != r {\n            return false\n        }\n    }\n    return true\n}\n \
    \           \nassert(factorize(n: 2) == [2])\nassert(factorize(n: 4) == [2, 2])\n\
    assert(factorize(n: 8) == [2, 2, 2])\nassert(factorize(n: 57) == [3, 19])\nassert(factorize(n:\
    \ 3249) == [3, 3, 19, 19])\nassert(factorize(n: 185193) == [3, 3, 3, 19, 19, 19])\n\
    assert(factorize(n: 20577) == [3, 19, 19, 19])\nassert(factorize(n: 18) == [2,\
    \ 3, 3])"
  status: SyntaxError
  stderr: "/tmp/tmpjsdr6xnz.swift:12:19: error: cannot find 'findFactors' in scope\n\
    \    let factors = findFactors(n: n)\n                  ^~~~~~~~~~~\n/tmp/tmpjsdr6xnz.swift:13:12:\
    \ error: cannot find 'factorization' in scope\n    return factorization(factors:\
    \ factors)\n           ^~~~~~~~~~~~~\n"
  stdout: ''
  timestamp: 1660009192
- exit_code: 0
  program: "\n/// Return array of prime factors of given integer in the order from\
    \ smallest to largest.\n/// Each of the factors should be arrayed number of times\
    \ corresponding to how many times it appeares in factorization.\n/// Input number\
    \ should be equal to the product of all factors\n/// >>> factorize(n: 8)\n///\
    \ [2, 2, 2]\n/// >>> factorize(n: 25)\n/// [5, 5]\n/// >>> factorize(n: 70)\n\
    /// [2, 5, 7]\nfunc factorize(n: Int) -> [Int] {\n    var n = n\n    var primeFactors\
    \ = [Int]()\n    var currFactor = 2\n    while n > 1 {\n        while n % currFactor\
    \ == 0 {\n            primeFactors.append(currFactor)\n            n /= currFactor\n\
    \        }\n        currFactor += 1\n    }\n    return primeFactors\n}\n\n\nfunc\
    \ ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count !=\
    \ right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(factorize(n: 2) == [2])\nassert(factorize(n: 4)\
    \ == [2, 2])\nassert(factorize(n: 8) == [2, 2, 2])\nassert(factorize(n: 57) ==\
    \ [3, 19])\nassert(factorize(n: 3249) == [3, 3, 19, 19])\nassert(factorize(n:\
    \ 185193) == [3, 3, 3, 19, 19, 19])\nassert(factorize(n: 20577) == [3, 19, 19,\
    \ 19])\nassert(factorize(n: 18) == [2, 3, 3])"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660009192
- exit_code: 0
  program: "\n/// Return array of prime factors of given integer in the order from\
    \ smallest to largest.\n/// Each of the factors should be arrayed number of times\
    \ corresponding to how many times it appeares in factorization.\n/// Input number\
    \ should be equal to the product of all factors\n/// >>> factorize(n: 8)\n///\
    \ [2, 2, 2]\n/// >>> factorize(n: 25)\n/// [5, 5]\n/// >>> factorize(n: 70)\n\
    /// [2, 5, 7]\nfunc factorize(n: Int) -> [Int] {\n    guard n > 1 else {\n   \
    \     return []\n    }\n    var primes: [Int] = []\n    var value = n\n    var\
    \ divisor = 2\n    while divisor * divisor <= value {\n        while value % divisor\
    \ == 0 {\n            primes.append(divisor)\n            value /= divisor\n \
    \       }\n        divisor += 1\n    }\n    if value > 1 {\n        primes.append(value)\n\
    \    }\n    return primes\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(factorize(n:\
    \ 2) == [2])\nassert(factorize(n: 4) == [2, 2])\nassert(factorize(n: 8) == [2,\
    \ 2, 2])\nassert(factorize(n: 57) == [3, 19])\nassert(factorize(n: 3249) == [3,\
    \ 3, 19, 19])\nassert(factorize(n: 185193) == [3, 3, 3, 19, 19, 19])\nassert(factorize(n:\
    \ 20577) == [3, 19, 19, 19])\nassert(factorize(n: 18) == [2, 3, 3])"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660009192
- exit_code: 0
  program: "\n/// Return array of prime factors of given integer in the order from\
    \ smallest to largest.\n/// Each of the factors should be arrayed number of times\
    \ corresponding to how many times it appeares in factorization.\n/// Input number\
    \ should be equal to the product of all factors\n/// >>> factorize(n: 8)\n///\
    \ [2, 2, 2]\n/// >>> factorize(n: 25)\n/// [5, 5]\n/// >>> factorize(n: 70)\n\
    /// [2, 5, 7]\nfunc factorize(n: Int) -> [Int] {\n    var result = [Int]()\n \
    \   var value = n\n    var factor = 2\n    while factor <= value {\n        if\
    \ value % factor == 0 {\n            result.append(factor)\n            value\
    \ /= factor\n        } else {\n            factor += 1\n        }\n    }\n   \
    \ return result\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool\
    \ {\n    if left.count != right.count {\n        return false\n    }\n    for\
    \ (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(factorize(n: 2) ==\
    \ [2])\nassert(factorize(n: 4) == [2, 2])\nassert(factorize(n: 8) == [2, 2, 2])\n\
    assert(factorize(n: 57) == [3, 19])\nassert(factorize(n: 3249) == [3, 3, 19, 19])\n\
    assert(factorize(n: 185193) == [3, 3, 3, 19, 19, 19])\nassert(factorize(n: 20577)\
    \ == [3, 19, 19, 19])\nassert(factorize(n: 18) == [2, 3, 3])"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660009192
- exit_code: 0
  program: "\n/// Return array of prime factors of given integer in the order from\
    \ smallest to largest.\n/// Each of the factors should be arrayed number of times\
    \ corresponding to how many times it appeares in factorization.\n/// Input number\
    \ should be equal to the product of all factors\n/// >>> factorize(n: 8)\n///\
    \ [2, 2, 2]\n/// >>> factorize(n: 25)\n/// [5, 5]\n/// >>> factorize(n: 70)\n\
    /// [2, 5, 7]\nfunc factorize(n: Int) -> [Int] {\n    var num = n\n    var factors\
    \ = [Int]()\n    var prime = 2\n    while num > 1 {\n        while num % prime\
    \ == 0 {\n            factors.append(prime)\n            num /= prime\n      \
    \  }\n        prime += 1\n    }\n    return factors\n}\n\n\nfunc ==(left: [(Int,\
    \ Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n\
    \        return false\n    }\n    for (l, r) in zip(left, right) {\n        if\
    \ l != r {\n            return false\n        }\n    }\n    return true\n}\n \
    \           \nassert(factorize(n: 2) == [2])\nassert(factorize(n: 4) == [2, 2])\n\
    assert(factorize(n: 8) == [2, 2, 2])\nassert(factorize(n: 57) == [3, 19])\nassert(factorize(n:\
    \ 3249) == [3, 3, 19, 19])\nassert(factorize(n: 185193) == [3, 3, 3, 19, 19, 19])\n\
    assert(factorize(n: 20577) == [3, 19, 19, 19])\nassert(factorize(n: 18) == [2,\
    \ 3, 3])"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660009192
- exit_code: 0
  program: "\n/// Return array of prime factors of given integer in the order from\
    \ smallest to largest.\n/// Each of the factors should be arrayed number of times\
    \ corresponding to how many times it appeares in factorization.\n/// Input number\
    \ should be equal to the product of all factors\n/// >>> factorize(n: 8)\n///\
    \ [2, 2, 2]\n/// >>> factorize(n: 25)\n/// [5, 5]\n/// >>> factorize(n: 70)\n\
    /// [2, 5, 7]\nfunc factorize(n: Int) -> [Int] {\n    assert(n > 0)\n    var factors\
    \ = [Int]()\n    var x = n\n    while x % 2 == 0 {\n        factors.append(2)\n\
    \        x /= 2\n    }\n    var factor = 3\n    while factor * factor <= x {\n\
    \        if x % factor == 0 {\n            factors.append(factor)\n          \
    \  x /= factor\n        } else {\n            factor += 2\n        }\n    }\n\
    \    if x > 1 {\n        factors.append(x)\n    }\n    return factors\n}\n\n\n\
    func ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(factorize(n: 2) == [2])\nassert(factorize(n: 4)\
    \ == [2, 2])\nassert(factorize(n: 8) == [2, 2, 2])\nassert(factorize(n: 57) ==\
    \ [3, 19])\nassert(factorize(n: 3249) == [3, 3, 19, 19])\nassert(factorize(n:\
    \ 185193) == [3, 3, 3, 19, 19, 19])\nassert(factorize(n: 20577) == [3, 19, 19,\
    \ 19])\nassert(factorize(n: 18) == [2, 3, 3])"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660009192
- exit_code: 0
  program: "\n/// Return array of prime factors of given integer in the order from\
    \ smallest to largest.\n/// Each of the factors should be arrayed number of times\
    \ corresponding to how many times it appeares in factorization.\n/// Input number\
    \ should be equal to the product of all factors\n/// >>> factorize(n: 8)\n///\
    \ [2, 2, 2]\n/// >>> factorize(n: 25)\n/// [5, 5]\n/// >>> factorize(n: 70)\n\
    /// [2, 5, 7]\nfunc factorize(n: Int) -> [Int] {\n    // write your code here\n\
    \    var array = [Int]()\n    var remain = n\n    while remain > 1 {\n       \
    \ for i in 2...remain {\n            if remain % i == 0 {\n                array.append(i)\n\
    \                remain /= i\n                break\n            }\n        }\n\
    \    }\n    return array\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(factorize(n:\
    \ 2) == [2])\nassert(factorize(n: 4) == [2, 2])\nassert(factorize(n: 8) == [2,\
    \ 2, 2])\nassert(factorize(n: 57) == [3, 19])\nassert(factorize(n: 3249) == [3,\
    \ 3, 19, 19])\nassert(factorize(n: 185193) == [3, 3, 3, 19, 19, 19])\nassert(factorize(n:\
    \ 20577) == [3, 19, 19, 19])\nassert(factorize(n: 18) == [2, 3, 3])"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660009192
- exit_code: 1
  program: "\n/// Return array of prime factors of given integer in the order from\
    \ smallest to largest.\n/// Each of the factors should be arrayed number of times\
    \ corresponding to how many times it appeares in factorization.\n/// Input number\
    \ should be equal to the product of all factors\n/// >>> factorize(n: 8)\n///\
    \ [2, 2, 2]\n/// >>> factorize(n: 25)\n/// [5, 5]\n/// >>> factorize(n: 70)\n\
    /// [2, 5, 7]\nfunc factorize(n: Int) -> [Int] {\n    var primeFactors: [Int]\
    \ = []\n    var m = n\n    for divisor in 2...Int(sqrt(Double(n))) {\n       \
    \ while m % divisor == 0 {\n            primeFactors.append(divisor)\n       \
    \     m /= divisor\n        }\n    }\n    if m > 1 {\n        primeFactors.append(m)\n\
    \    }\n    return primeFactors\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int,\
    \ Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n\
    \    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n          \
    \  return false\n        }\n    }\n    return true\n}\n            \nassert(factorize(n:\
    \ 2) == [2])\nassert(factorize(n: 4) == [2, 2])\nassert(factorize(n: 8) == [2,\
    \ 2, 2])\nassert(factorize(n: 57) == [3, 19])\nassert(factorize(n: 3249) == [3,\
    \ 3, 19, 19])\nassert(factorize(n: 185193) == [3, 3, 3, 19, 19, 19])\nassert(factorize(n:\
    \ 20577) == [3, 19, 19, 19])\nassert(factorize(n: 18) == [2, 3, 3])"
  status: SyntaxError
  stderr: "/tmp/tmpipjz65bl.swift:14:28: error: cannot find 'sqrt' in scope\n    for\
    \ divisor in 2...Int(sqrt(Double(n))) {\n                           ^~~~\n"
  stdout: ''
  timestamp: 1660009192
- exit_code: 1
  program: "\n/// Return array of prime factors of given integer in the order from\
    \ smallest to largest.\n/// Each of the factors should be arrayed number of times\
    \ corresponding to how many times it appeares in factorization.\n/// Input number\
    \ should be equal to the product of all factors\n/// >>> factorize(n: 8)\n///\
    \ [2, 2, 2]\n/// >>> factorize(n: 25)\n/// [5, 5]\n/// >>> factorize(n: 70)\n\
    /// [2, 5, 7]\nfunc factorize(n: Int) -> [Int] {\n    var res: [Int] = []\n  \
    \  var num = n\n    while num > 1 {\n        let div = divisor(for: num)\n   \
    \     res.append(div)\n        num /= div\n    }\n    return res\n}\n\n\nfunc\
    \ ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count !=\
    \ right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(factorize(n: 2) == [2])\nassert(factorize(n: 4)\
    \ == [2, 2])\nassert(factorize(n: 8) == [2, 2, 2])\nassert(factorize(n: 57) ==\
    \ [3, 19])\nassert(factorize(n: 3249) == [3, 3, 19, 19])\nassert(factorize(n:\
    \ 185193) == [3, 3, 3, 19, 19, 19])\nassert(factorize(n: 20577) == [3, 19, 19,\
    \ 19])\nassert(factorize(n: 18) == [2, 3, 3])"
  status: SyntaxError
  stderr: "/tmp/tmpq3yz7va4.swift:15:19: error: cannot find 'divisor' in scope\n \
    \       let div = divisor(for: num)\n                  ^~~~~~~\n"
  stdout: ''
  timestamp: 1660009192
- exit_code: 0
  program: "\n/// Return array of prime factors of given integer in the order from\
    \ smallest to largest.\n/// Each of the factors should be arrayed number of times\
    \ corresponding to how many times it appeares in factorization.\n/// Input number\
    \ should be equal to the product of all factors\n/// >>> factorize(n: 8)\n///\
    \ [2, 2, 2]\n/// >>> factorize(n: 25)\n/// [5, 5]\n/// >>> factorize(n: 70)\n\
    /// [2, 5, 7]\nfunc factorize(n: Int) -> [Int] {\n    \n    var result = [Int]()\n\
    \    var number = n\n    \n    var i = 2\n    while i * i <= number {\n      \
    \  if number % i == 0 {\n            result.append(i)\n            number /= i\n\
    \        } else {\n            i += 1\n        }\n    }\n    \n    if number >\
    \ 1 {\n        result.append(number)\n    }\n    \n    return result\n}\n\n\n\
    func ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(factorize(n: 2) == [2])\nassert(factorize(n: 4)\
    \ == [2, 2])\nassert(factorize(n: 8) == [2, 2, 2])\nassert(factorize(n: 57) ==\
    \ [3, 19])\nassert(factorize(n: 3249) == [3, 3, 19, 19])\nassert(factorize(n:\
    \ 185193) == [3, 3, 3, 19, 19, 19])\nassert(factorize(n: 20577) == [3, 19, 19,\
    \ 19])\nassert(factorize(n: 18) == [2, 3, 3])"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660009192
- exit_code: 1
  program: "\n/// Return array of prime factors of given integer in the order from\
    \ smallest to largest.\n/// Each of the factors should be arrayed number of times\
    \ corresponding to how many times it appeares in factorization.\n/// Input number\
    \ should be equal to the product of all factors\n/// >>> factorize(n: 8)\n///\
    \ [2, 2, 2]\n/// >>> factorize(n: 25)\n/// [5, 5]\n/// >>> factorize(n: 70)\n\
    /// [2, 5, 7]\nfunc factorize(n: Int) -> [Int] {\n    var n = n\n    var a = [Int]()\n\
    \    for i in 2...n {\n        if n % i == 0 {\n            a.append(i)\n    \
    \        n /= i\n            i = 1\n        }\n    }\n    return a\n}\n\n\nfunc\
    \ ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count !=\
    \ right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(factorize(n: 2) == [2])\nassert(factorize(n: 4)\
    \ == [2, 2])\nassert(factorize(n: 8) == [2, 2, 2])\nassert(factorize(n: 57) ==\
    \ [3, 19])\nassert(factorize(n: 3249) == [3, 3, 19, 19])\nassert(factorize(n:\
    \ 185193) == [3, 3, 3, 19, 19, 19])\nassert(factorize(n: 20577) == [3, 19, 19,\
    \ 19])\nassert(factorize(n: 18) == [2, 3, 3])"
  status: SyntaxError
  stderr: "/tmp/tmp21n20ax3.swift:18:13: error: cannot assign to value: 'i' is a 'let'\
    \ constant\n            i = 1\n            ^\n"
  stdout: ''
  timestamp: 1660009192
- exit_code: 0
  program: "\n/// Return array of prime factors of given integer in the order from\
    \ smallest to largest.\n/// Each of the factors should be arrayed number of times\
    \ corresponding to how many times it appeares in factorization.\n/// Input number\
    \ should be equal to the product of all factors\n/// >>> factorize(n: 8)\n///\
    \ [2, 2, 2]\n/// >>> factorize(n: 25)\n/// [5, 5]\n/// >>> factorize(n: 70)\n\
    /// [2, 5, 7]\nfunc factorize(n: Int) -> [Int] {\n    var factors: [Int] = []\n\
    \    var num = n\n    for divisor in 2...num {\n        while num % divisor ==\
    \ 0 {\n            factors.append(divisor)\n            num /= divisor\n     \
    \   }\n    }\n    return factors\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int,\
    \ Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n\
    \    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n          \
    \  return false\n        }\n    }\n    return true\n}\n            \nassert(factorize(n:\
    \ 2) == [2])\nassert(factorize(n: 4) == [2, 2])\nassert(factorize(n: 8) == [2,\
    \ 2, 2])\nassert(factorize(n: 57) == [3, 19])\nassert(factorize(n: 3249) == [3,\
    \ 3, 19, 19])\nassert(factorize(n: 185193) == [3, 3, 3, 19, 19, 19])\nassert(factorize(n:\
    \ 20577) == [3, 19, 19, 19])\nassert(factorize(n: 18) == [2, 3, 3])"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660009192
- exit_code: 0
  program: "\n/// Return array of prime factors of given integer in the order from\
    \ smallest to largest.\n/// Each of the factors should be arrayed number of times\
    \ corresponding to how many times it appeares in factorization.\n/// Input number\
    \ should be equal to the product of all factors\n/// >>> factorize(n: 8)\n///\
    \ [2, 2, 2]\n/// >>> factorize(n: 25)\n/// [5, 5]\n/// >>> factorize(n: 70)\n\
    /// [2, 5, 7]\nfunc factorize(n: Int) -> [Int] {\n    var remaining = n\n    var\
    \ fact = 2\n    var factors = [Int]()\n    while remaining > 1 {\n        if remaining\
    \ % fact == 0 {\n            factors.append(fact)\n            remaining /= fact\n\
    \        } else {\n            fact += 1\n        }\n    }\n    return factors\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(factorize(n: 2) == [2])\nassert(factorize(n: 4)\
    \ == [2, 2])\nassert(factorize(n: 8) == [2, 2, 2])\nassert(factorize(n: 57) ==\
    \ [3, 19])\nassert(factorize(n: 3249) == [3, 3, 19, 19])\nassert(factorize(n:\
    \ 185193) == [3, 3, 3, 19, 19, 19])\nassert(factorize(n: 20577) == [3, 19, 19,\
    \ 19])\nassert(factorize(n: 18) == [2, 3, 3])"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660009192
- exit_code: 0
  program: "\n/// Return array of prime factors of given integer in the order from\
    \ smallest to largest.\n/// Each of the factors should be arrayed number of times\
    \ corresponding to how many times it appeares in factorization.\n/// Input number\
    \ should be equal to the product of all factors\n/// >>> factorize(n: 8)\n///\
    \ [2, 2, 2]\n/// >>> factorize(n: 25)\n/// [5, 5]\n/// >>> factorize(n: 70)\n\
    /// [2, 5, 7]\nfunc factorize(n: Int) -> [Int] {\n    var factors = [Int]()\n\
    \    var m = n\n    var divisor = 2\n    while m > 1 {\n        while m % divisor\
    \ == 0 {\n            factors.append(divisor)\n            m /= divisor\n    \
    \    }\n        divisor += 1\n    }\n    return factors\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(factorize(n: 2) == [2])\nassert(factorize(n: 4) == [2,\
    \ 2])\nassert(factorize(n: 8) == [2, 2, 2])\nassert(factorize(n: 57) == [3, 19])\n\
    assert(factorize(n: 3249) == [3, 3, 19, 19])\nassert(factorize(n: 185193) == [3,\
    \ 3, 3, 19, 19, 19])\nassert(factorize(n: 20577) == [3, 19, 19, 19])\nassert(factorize(n:\
    \ 18) == [2, 3, 3])"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660009192
- exit_code: -4
  program: "\n/// Return array of prime factors of given integer in the order from\
    \ smallest to largest.\n/// Each of the factors should be arrayed number of times\
    \ corresponding to how many times it appeares in factorization.\n/// Input number\
    \ should be equal to the product of all factors\n/// >>> factorize(n: 8)\n///\
    \ [2, 2, 2]\n/// >>> factorize(n: 25)\n/// [5, 5]\n/// >>> factorize(n: 70)\n\
    /// [2, 5, 7]\nfunc factorize(n: Int) -> [Int] {\n    // write your code here\n\
    \    return [1]\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool\
    \ {\n    if left.count != right.count {\n        return false\n    }\n    for\
    \ (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(factorize(n: 2) ==\
    \ [2])\nassert(factorize(n: 4) == [2, 2])\nassert(factorize(n: 8) == [2, 2, 2])\n\
    assert(factorize(n: 57) == [3, 19])\nassert(factorize(n: 3249) == [3, 3, 19, 19])\n\
    assert(factorize(n: 185193) == [3, 3, 3, 19, 19, 19])\nassert(factorize(n: 20577)\
    \ == [3, 19, 19, 19])\nassert(factorize(n: 18) == [2, 3, 3])"
  status: Exception
  stderr: 'tmpcsxx6sox/tmpcsxx6sox.swift:29: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b4944c40c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b4944937b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b4944937988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b49449367b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpcsxx6sox                        0x0000558f4dda7372 <unavailable> + 4978

    5    libc.so.6                          0x00002b4944e2c460 __libc_start_main +
    245

    6    tmpcsxx6sox                        0x0000558f4dda6fc9 <unavailable> + 4041

    '
  stdout: ''
  timestamp: 1660009192
- exit_code: 1
  program: "\n/// Return array of prime factors of given integer in the order from\
    \ smallest to largest.\n/// Each of the factors should be arrayed number of times\
    \ corresponding to how many times it appeares in factorization.\n/// Input number\
    \ should be equal to the product of all factors\n/// >>> factorize(n: 8)\n///\
    \ [2, 2, 2]\n/// >>> factorize(n: 25)\n/// [5, 5]\n/// >>> factorize(n: 70)\n\
    /// [2, 5, 7]\nfunc factorize(n: Int) -> [Int] {\n    var result = [Int]()\n \
    \   var num = n\n    for var i = 2; i <= num; i++ {\n        while num % i ==\
    \ 0 {\n            result.append(i)\n            num /= i\n        }\n    }\n\
    \    return result\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) ->\
    \ Bool {\n    if left.count != right.count {\n        return false\n    }\n  \
    \  for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(factorize(n: 2) ==\
    \ [2])\nassert(factorize(n: 4) == [2, 2])\nassert(factorize(n: 8) == [2, 2, 2])\n\
    assert(factorize(n: 57) == [3, 19])\nassert(factorize(n: 3249) == [3, 3, 19, 19])\n\
    assert(factorize(n: 185193) == [3, 3, 3, 19, 19, 19])\nassert(factorize(n: 20577)\
    \ == [3, 19, 19, 19])\nassert(factorize(n: 18) == [2, 3, 3])"
  status: SyntaxError
  stderr: "/tmp/tmpmezkb84w.swift:14:5: error: C-style for statement has been removed\
    \ in Swift 3\n    for var i = 2; i <= num; i++ {\n    ^   ~~~~~~~~~~~~~~~~~~~~~~~~\n"
  stdout: ''
  timestamp: 1660009192
- exit_code: -4
  program: "\n/// Return array of prime factors of given integer in the order from\
    \ smallest to largest.\n/// Each of the factors should be arrayed number of times\
    \ corresponding to how many times it appeares in factorization.\n/// Input number\
    \ should be equal to the product of all factors\n/// >>> factorize(n: 8)\n///\
    \ [2, 2, 2]\n/// >>> factorize(n: 25)\n/// [5, 5]\n/// >>> factorize(n: 70)\n\
    /// [2, 5, 7]\nfunc factorize(n: Int) -> [Int] {\n    return [2, 5, 7]\n}\n\n\n\
    func ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(factorize(n: 2) == [2])\nassert(factorize(n: 4)\
    \ == [2, 2])\nassert(factorize(n: 8) == [2, 2, 2])\nassert(factorize(n: 57) ==\
    \ [3, 19])\nassert(factorize(n: 3249) == [3, 3, 19, 19])\nassert(factorize(n:\
    \ 185193) == [3, 3, 3, 19, 19, 19])\nassert(factorize(n: 20577) == [3, 19, 19,\
    \ 19])\nassert(factorize(n: 18) == [2, 3, 3])"
  status: Exception
  stderr: 'tmpln4cdasq/tmpln4cdasq.swift:28: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002ab05adcfc80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002ab05aac6b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002ab05aac6988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002ab05aac57b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpln4cdasq                        0x000055d6bac38372 <unavailable> + 4978

    5    libc.so.6                          0x00002ab05afbb460 __libc_start_main +
    245

    6    tmpln4cdasq                        0x000055d6bac37fc9 <unavailable> + 4041

    '
  stdout: ''
  timestamp: 1660009192
- exit_code: -4
  program: "\n/// Return array of prime factors of given integer in the order from\
    \ smallest to largest.\n/// Each of the factors should be arrayed number of times\
    \ corresponding to how many times it appeares in factorization.\n/// Input number\
    \ should be equal to the product of all factors\n/// >>> factorize(n: 8)\n///\
    \ [2, 2, 2]\n/// >>> factorize(n: 25)\n/// [5, 5]\n/// >>> factorize(n: 70)\n\
    /// [2, 5, 7]\nfunc factorize(n: Int) -> [Int] {\n    return []\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(factorize(n: 2) == [2])\nassert(factorize(n: 4) == [2,\
    \ 2])\nassert(factorize(n: 8) == [2, 2, 2])\nassert(factorize(n: 57) == [3, 19])\n\
    assert(factorize(n: 3249) == [3, 3, 19, 19])\nassert(factorize(n: 185193) == [3,\
    \ 3, 3, 19, 19, 19])\nassert(factorize(n: 20577) == [3, 19, 19, 19])\nassert(factorize(n:\
    \ 18) == [2, 3, 3])"
  status: Exception
  stderr: 'tmpr8thvm9v/tmpr8thvm9v.swift:28: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b2608809c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b2608500b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b2608500988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b26084ff7b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpr8thvm9v                        0x0000555618631372 <unavailable> + 4978

    5    libc.so.6                          0x00002b26089f5460 __libc_start_main +
    245

    6    tmpr8thvm9v                        0x0000555618630fc9 <unavailable> + 4041

    '
  stdout: ''
  timestamp: 1660009191
- exit_code: 0
  program: "\n/// Return array of prime factors of given integer in the order from\
    \ smallest to largest.\n/// Each of the factors should be arrayed number of times\
    \ corresponding to how many times it appeares in factorization.\n/// Input number\
    \ should be equal to the product of all factors\n/// >>> factorize(n: 8)\n///\
    \ [2, 2, 2]\n/// >>> factorize(n: 25)\n/// [5, 5]\n/// >>> factorize(n: 70)\n\
    /// [2, 5, 7]\nfunc factorize(n: Int) -> [Int] {\n    guard n > 1 else { return\
    \ [] }\n    guard n != 2 else { return [2] }\n    var result = [Int]()\n    var\
    \ num = n\n    var divider = 2\n    while num > 1 {\n        while num % divider\
    \ == 0 {\n            result.append(divider)\n            num /= divider\n   \
    \     }\n        divider += 1\n    }\n    return result\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(factorize(n: 2) == [2])\nassert(factorize(n: 4) == [2,\
    \ 2])\nassert(factorize(n: 8) == [2, 2, 2])\nassert(factorize(n: 57) == [3, 19])\n\
    assert(factorize(n: 3249) == [3, 3, 19, 19])\nassert(factorize(n: 185193) == [3,\
    \ 3, 3, 19, 19, 19])\nassert(factorize(n: 20577) == [3, 19, 19, 19])\nassert(factorize(n:\
    \ 18) == [2, 3, 3])"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660009192
- exit_code: -4
  program: "\n/// Return array of prime factors of given integer in the order from\
    \ smallest to largest.\n/// Each of the factors should be arrayed number of times\
    \ corresponding to how many times it appeares in factorization.\n/// Input number\
    \ should be equal to the product of all factors\n/// >>> factorize(n: 8)\n///\
    \ [2, 2, 2]\n/// >>> factorize(n: 25)\n/// [5, 5]\n/// >>> factorize(n: 70)\n\
    /// [2, 5, 7]\nfunc factorize(n: Int) -> [Int] {\n    \n    var array = [Int]()\n\
    \    var num = n\n    \n    for i in 2...n {\n        if num % i == 0 {\n    \
    \        num /= i\n            array.append(i)\n            if num == 1 {\n  \
    \              break\n            }\n        }\n    }\n    \n    return array\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(factorize(n: 2) == [2])\nassert(factorize(n: 4)\
    \ == [2, 2])\nassert(factorize(n: 8) == [2, 2, 2])\nassert(factorize(n: 57) ==\
    \ [3, 19])\nassert(factorize(n: 3249) == [3, 3, 19, 19])\nassert(factorize(n:\
    \ 185193) == [3, 3, 3, 19, 19, 19])\nassert(factorize(n: 20577) == [3, 19, 19,\
    \ 19])\nassert(factorize(n: 18) == [2, 3, 3])"
  status: Exception
  stderr: 'tmp3fslc6zj/tmp3fslc6zj.swift:43: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b97f3a9dc80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b97f3794b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b97f3794988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b97f37937b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmp3fslc6zj                        0x0000562f18c0468f <unavailable> + 5775

    5    libc.so.6                          0x00002b97f3c89460 __libc_start_main +
    245

    6    tmp3fslc6zj                        0x0000562f18c04209 <unavailable> + 4617

    '
  stdout: ''
  timestamp: 1660009192
- exit_code: 0
  program: "\n/// Return array of prime factors of given integer in the order from\
    \ smallest to largest.\n/// Each of the factors should be arrayed number of times\
    \ corresponding to how many times it appeares in factorization.\n/// Input number\
    \ should be equal to the product of all factors\n/// >>> factorize(n: 8)\n///\
    \ [2, 2, 2]\n/// >>> factorize(n: 25)\n/// [5, 5]\n/// >>> factorize(n: 70)\n\
    /// [2, 5, 7]\nfunc factorize(n: Int) -> [Int] {\n    guard n != 1 else { return\
    \ [1] }\n    var divisor = 2\n    var number = n\n    var result = [Int]()\n \
    \   while divisor <= number {\n        while number % divisor == 0 {\n       \
    \     result.append(divisor)\n            number /= divisor\n        }\n     \
    \   divisor += 1\n    }\n    return result\n}\n\n\nfunc ==(left: [(Int, Int)],\
    \ right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n       \
    \ return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r\
    \ {\n            return false\n        }\n    }\n    return true\n}\n        \
    \    \nassert(factorize(n: 2) == [2])\nassert(factorize(n: 4) == [2, 2])\nassert(factorize(n:\
    \ 8) == [2, 2, 2])\nassert(factorize(n: 57) == [3, 19])\nassert(factorize(n: 3249)\
    \ == [3, 3, 19, 19])\nassert(factorize(n: 185193) == [3, 3, 3, 19, 19, 19])\n\
    assert(factorize(n: 20577) == [3, 19, 19, 19])\nassert(factorize(n: 18) == [2,\
    \ 3, 3])"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660009192
- exit_code: 0
  program: "\n/// Return array of prime factors of given integer in the order from\
    \ smallest to largest.\n/// Each of the factors should be arrayed number of times\
    \ corresponding to how many times it appeares in factorization.\n/// Input number\
    \ should be equal to the product of all factors\n/// >>> factorize(n: 8)\n///\
    \ [2, 2, 2]\n/// >>> factorize(n: 25)\n/// [5, 5]\n/// >>> factorize(n: 70)\n\
    /// [2, 5, 7]\nfunc factorize(n: Int) -> [Int] {\n    var number = n\n    var\
    \ primeFactors: [Int] = []\n    while number > 1 {\n        for i in 2...number\
    \ {\n            if number % i == 0 {\n                primeFactors.append(i)\n\
    \                number /= i\n                break\n            }\n        }\n\
    \    }\n    return primeFactors\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int,\
    \ Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n\
    \    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n          \
    \  return false\n        }\n    }\n    return true\n}\n            \nassert(factorize(n:\
    \ 2) == [2])\nassert(factorize(n: 4) == [2, 2])\nassert(factorize(n: 8) == [2,\
    \ 2, 2])\nassert(factorize(n: 57) == [3, 19])\nassert(factorize(n: 3249) == [3,\
    \ 3, 19, 19])\nassert(factorize(n: 185193) == [3, 3, 3, 19, 19, 19])\nassert(factorize(n:\
    \ 20577) == [3, 19, 19, 19])\nassert(factorize(n: 18) == [2, 3, 3])"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660009192
- exit_code: 1
  program: "\n/// Return array of prime factors of given integer in the order from\
    \ smallest to largest.\n/// Each of the factors should be arrayed number of times\
    \ corresponding to how many times it appeares in factorization.\n/// Input number\
    \ should be equal to the product of all factors\n/// >>> factorize(n: 8)\n///\
    \ [2, 2, 2]\n/// >>> factorize(n: 25)\n/// [5, 5]\n/// >>> factorize(n: 70)\n\
    /// [2, 5, 7]\nfunc factorize(n: Int) -> [Int] {\n    if n == 1 {\n        return\
    \ []\n    }\n    if n == 2 {\n        return [2]\n    }\n    if n % 2 == 0 {\n\
    \        return [2] + factorize(n: n / 2)\n    }\n    for i in stride(from: 3,\
    \ through: Int(sqrt(Double(n))), by: 2) {\n        if n % i == 0 {\n         \
    \   return [i] + factorize(n: n / i)\n        }\n    }\n    return [n]\n}\n\n\n\
    func ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(factorize(n: 2) == [2])\nassert(factorize(n: 4)\
    \ == [2, 2])\nassert(factorize(n: 8) == [2, 2, 2])\nassert(factorize(n: 57) ==\
    \ [3, 19])\nassert(factorize(n: 3249) == [3, 3, 19, 19])\nassert(factorize(n:\
    \ 185193) == [3, 3, 3, 19, 19, 19])\nassert(factorize(n: 20577) == [3, 19, 19,\
    \ 19])\nassert(factorize(n: 18) == [2, 3, 3])"
  status: SyntaxError
  stderr: "/tmp/tmpmbc3ganx.swift:21:43: error: cannot find 'sqrt' in scope\n    for\
    \ i in stride(from: 3, through: Int(sqrt(Double(n))), by: 2) {\n             \
    \                             ^~~~\n"
  stdout: ''
  timestamp: 1660009192
- exit_code: 0
  program: "\n/// Return array of prime factors of given integer in the order from\
    \ smallest to largest.\n/// Each of the factors should be arrayed number of times\
    \ corresponding to how many times it appeares in factorization.\n/// Input number\
    \ should be equal to the product of all factors\n/// >>> factorize(n: 8)\n///\
    \ [2, 2, 2]\n/// >>> factorize(n: 25)\n/// [5, 5]\n/// >>> factorize(n: 70)\n\
    /// [2, 5, 7]\nfunc factorize(n: Int) -> [Int] {\n    var n = n\n    var factors\
    \ = [Int]()\n    var primes = [2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41,\
    \ 43, 47, 53, 59, 61, 67, 71, 73, 79, 83, 89, 97]\n    var p = 0\n    while n\
    \ != 1 {\n        if n % primes[p] == 0 {\n            factors.append(primes[p])\n\
    \            n /= primes[p]\n        } else {\n            p += 1\n        }\n\
    \    }\n    return factors\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(factorize(n:\
    \ 2) == [2])\nassert(factorize(n: 4) == [2, 2])\nassert(factorize(n: 8) == [2,\
    \ 2, 2])\nassert(factorize(n: 57) == [3, 19])\nassert(factorize(n: 3249) == [3,\
    \ 3, 19, 19])\nassert(factorize(n: 185193) == [3, 3, 3, 19, 19, 19])\nassert(factorize(n:\
    \ 20577) == [3, 19, 19, 19])\nassert(factorize(n: 18) == [2, 3, 3])"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660009192
- exit_code: 0
  program: "\n/// Return array of prime factors of given integer in the order from\
    \ smallest to largest.\n/// Each of the factors should be arrayed number of times\
    \ corresponding to how many times it appeares in factorization.\n/// Input number\
    \ should be equal to the product of all factors\n/// >>> factorize(n: 8)\n///\
    \ [2, 2, 2]\n/// >>> factorize(n: 25)\n/// [5, 5]\n/// >>> factorize(n: 70)\n\
    /// [2, 5, 7]\nfunc factorize(n: Int) -> [Int] {\n    var factors = [Int]()\n\
    \    var temp = n\n    for i in 2...n {\n        while temp % i == 0 {\n     \
    \       factors.append(i)\n            temp /= i\n        }\n    }\n    return\
    \ factors\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n\
    \    if left.count != right.count {\n        return false\n    }\n    for (l,\
    \ r) in zip(left, right) {\n        if l != r {\n            return false\n  \
    \      }\n    }\n    return true\n}\n            \nassert(factorize(n: 2) == [2])\n\
    assert(factorize(n: 4) == [2, 2])\nassert(factorize(n: 8) == [2, 2, 2])\nassert(factorize(n:\
    \ 57) == [3, 19])\nassert(factorize(n: 3249) == [3, 3, 19, 19])\nassert(factorize(n:\
    \ 185193) == [3, 3, 3, 19, 19, 19])\nassert(factorize(n: 20577) == [3, 19, 19,\
    \ 19])\nassert(factorize(n: 18) == [2, 3, 3])"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660009192
- exit_code: 1
  program: "\n/// Return array of prime factors of given integer in the order from\
    \ smallest to largest.\n/// Each of the factors should be arrayed number of times\
    \ corresponding to how many times it appeares in factorization.\n/// Input number\
    \ should be equal to the product of all factors\n/// >>> factorize(n: 8)\n///\
    \ [2, 2, 2]\n/// >>> factorize(n: 25)\n/// [5, 5]\n/// >>> factorize(n: 70)\n\
    /// [2, 5, 7]\nfunc factorize(n: Int) -> [Int] {\n    var primes = Prime()\n \
    \   var result = [Int]()\n    var p = primes.next()\n    var number = n\n    while\
    \ p != nil && number != 1 {\n        while number % p! == 0 {\n            result.append(p!)\n\
    \            number /= p!\n        }\n        p = primes.next()\n    }\n    return\
    \ result\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n\
    \    if left.count != right.count {\n        return false\n    }\n    for (l,\
    \ r) in zip(left, right) {\n        if l != r {\n            return false\n  \
    \      }\n    }\n    return true\n}\n            \nassert(factorize(n: 2) == [2])\n\
    assert(factorize(n: 4) == [2, 2])\nassert(factorize(n: 8) == [2, 2, 2])\nassert(factorize(n:\
    \ 57) == [3, 19])\nassert(factorize(n: 3249) == [3, 3, 19, 19])\nassert(factorize(n:\
    \ 185193) == [3, 3, 3, 19, 19, 19])\nassert(factorize(n: 20577) == [3, 19, 19,\
    \ 19])\nassert(factorize(n: 18) == [2, 3, 3])"
  status: SyntaxError
  stderr: "/tmp/tmpppow2vep.swift:12:18: error: cannot find 'Prime' in scope\n   \
    \ var primes = Prime()\n                 ^~~~~\n"
  stdout: ''
  timestamp: 1660009192
- exit_code: -4
  program: "\n/// Return array of prime factors of given integer in the order from\
    \ smallest to largest.\n/// Each of the factors should be arrayed number of times\
    \ corresponding to how many times it appeares in factorization.\n/// Input number\
    \ should be equal to the product of all factors\n/// >>> factorize(n: 8)\n///\
    \ [2, 2, 2]\n/// >>> factorize(n: 25)\n/// [5, 5]\n/// >>> factorize(n: 70)\n\
    /// [2, 5, 7]\nfunc factorize(n: Int) -> [Int] {\n    var result = [Int]()\n \
    \   var number = n\n    for index in 2...number {\n        if number % index ==\
    \ 0 {\n            number /= index\n            result.append(index)\n       \
    \     if number == 1 {\n                break\n            }\n            continue\n\
    \        }\n    }\n    return result\n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(factorize(n: 2) == [2])\nassert(factorize(n: 4) == [2, 2])\nassert(factorize(n:\
    \ 8) == [2, 2, 2])\nassert(factorize(n: 57) == [3, 19])\nassert(factorize(n: 3249)\
    \ == [3, 3, 19, 19])\nassert(factorize(n: 185193) == [3, 3, 3, 19, 19, 19])\n\
    assert(factorize(n: 20577) == [3, 19, 19, 19])\nassert(factorize(n: 18) == [2,\
    \ 3, 3])"
  status: Exception
  stderr: 'tmp4r8jolhs/tmp4r8jolhs.swift:41: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b66a6a21c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b66a6718b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b66a6718988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b66a67177b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmp4r8jolhs                        0x000055c4f065168f <unavailable> + 5775

    5    libc.so.6                          0x00002b66a6c0d460 __libc_start_main +
    245

    6    tmp4r8jolhs                        0x000055c4f0651209 <unavailable> + 4617

    '
  stdout: ''
  timestamp: 1660009192
- exit_code: 0
  program: "\n/// Return array of prime factors of given integer in the order from\
    \ smallest to largest.\n/// Each of the factors should be arrayed number of times\
    \ corresponding to how many times it appeares in factorization.\n/// Input number\
    \ should be equal to the product of all factors\n/// >>> factorize(n: 8)\n///\
    \ [2, 2, 2]\n/// >>> factorize(n: 25)\n/// [5, 5]\n/// >>> factorize(n: 70)\n\
    /// [2, 5, 7]\nfunc factorize(n: Int) -> [Int] {\n    var arr = [Int]()\n    var\
    \ divisor = 2\n    var dividend = n\n    while divisor <= n {\n        if dividend\
    \ % divisor == 0 {\n            arr.append(divisor)\n            dividend /= divisor\n\
    \        } else {\n            divisor += 1\n        }\n    }\n    return arr\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(factorize(n: 2) == [2])\nassert(factorize(n: 4)\
    \ == [2, 2])\nassert(factorize(n: 8) == [2, 2, 2])\nassert(factorize(n: 57) ==\
    \ [3, 19])\nassert(factorize(n: 3249) == [3, 3, 19, 19])\nassert(factorize(n:\
    \ 185193) == [3, 3, 3, 19, 19, 19])\nassert(factorize(n: 20577) == [3, 19, 19,\
    \ 19])\nassert(factorize(n: 18) == [2, 3, 3])"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660009192
- exit_code: 0
  program: "\n/// Return array of prime factors of given integer in the order from\
    \ smallest to largest.\n/// Each of the factors should be arrayed number of times\
    \ corresponding to how many times it appeares in factorization.\n/// Input number\
    \ should be equal to the product of all factors\n/// >>> factorize(n: 8)\n///\
    \ [2, 2, 2]\n/// >>> factorize(n: 25)\n/// [5, 5]\n/// >>> factorize(n: 70)\n\
    /// [2, 5, 7]\nfunc factorize(n: Int) -> [Int] {\n    if n < 2 {\n        return\
    \ []\n    }\n    var factors = [Int]()\n    var prime = 2\n    var temp = n\n\
    \    while temp > 1 {\n        while temp % prime == 0 {\n            factors.append(prime)\n\
    \            temp /= prime\n        }\n        prime += 1\n    }\n    return factors\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(factorize(n: 2) == [2])\nassert(factorize(n: 4)\
    \ == [2, 2])\nassert(factorize(n: 8) == [2, 2, 2])\nassert(factorize(n: 57) ==\
    \ [3, 19])\nassert(factorize(n: 3249) == [3, 3, 19, 19])\nassert(factorize(n:\
    \ 185193) == [3, 3, 3, 19, 19, 19])\nassert(factorize(n: 20577) == [3, 19, 19,\
    \ 19])\nassert(factorize(n: 18) == [2, 3, 3])"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660009192
- exit_code: 0
  program: "\n/// Return array of prime factors of given integer in the order from\
    \ smallest to largest.\n/// Each of the factors should be arrayed number of times\
    \ corresponding to how many times it appeares in factorization.\n/// Input number\
    \ should be equal to the product of all factors\n/// >>> factorize(n: 8)\n///\
    \ [2, 2, 2]\n/// >>> factorize(n: 25)\n/// [5, 5]\n/// >>> factorize(n: 70)\n\
    /// [2, 5, 7]\nfunc factorize(n: Int) -> [Int] {\n    var primeNumbers = [Int]()\n\
    \    var temp = n\n    var i = 2\n    while temp != 1 {\n        while temp %\
    \ i == 0 {\n            primeNumbers.append(i)\n            temp /= i\n      \
    \  }\n        i += 1\n    }\n    return primeNumbers\n}\n\n\nfunc ==(left: [(Int,\
    \ Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n\
    \        return false\n    }\n    for (l, r) in zip(left, right) {\n        if\
    \ l != r {\n            return false\n        }\n    }\n    return true\n}\n \
    \           \nassert(factorize(n: 2) == [2])\nassert(factorize(n: 4) == [2, 2])\n\
    assert(factorize(n: 8) == [2, 2, 2])\nassert(factorize(n: 57) == [3, 19])\nassert(factorize(n:\
    \ 3249) == [3, 3, 19, 19])\nassert(factorize(n: 185193) == [3, 3, 3, 19, 19, 19])\n\
    assert(factorize(n: 20577) == [3, 19, 19, 19])\nassert(factorize(n: 18) == [2,\
    \ 3, 3])"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660009192
- exit_code: 0
  program: "\n/// Return array of prime factors of given integer in the order from\
    \ smallest to largest.\n/// Each of the factors should be arrayed number of times\
    \ corresponding to how many times it appeares in factorization.\n/// Input number\
    \ should be equal to the product of all factors\n/// >>> factorize(n: 8)\n///\
    \ [2, 2, 2]\n/// >>> factorize(n: 25)\n/// [5, 5]\n/// >>> factorize(n: 70)\n\
    /// [2, 5, 7]\nfunc factorize(n: Int) -> [Int] {\n    var factors = [Int]()\n\
    \    var factoredNumber = n\n    var currentPrime = 2\n    while currentPrime\
    \ <= factoredNumber {\n        while factoredNumber % currentPrime == 0 {\n  \
    \          factors.append(currentPrime)\n            factoredNumber /= currentPrime\n\
    \        }\n        currentPrime += 1\n    }\n    return factors\n}\n\n\nfunc\
    \ ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count !=\
    \ right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(factorize(n: 2) == [2])\nassert(factorize(n: 4)\
    \ == [2, 2])\nassert(factorize(n: 8) == [2, 2, 2])\nassert(factorize(n: 57) ==\
    \ [3, 19])\nassert(factorize(n: 3249) == [3, 3, 19, 19])\nassert(factorize(n:\
    \ 185193) == [3, 3, 3, 19, 19, 19])\nassert(factorize(n: 20577) == [3, 19, 19,\
    \ 19])\nassert(factorize(n: 18) == [2, 3, 3])"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660009192
- exit_code: 1
  program: "\n/// Return array of prime factors of given integer in the order from\
    \ smallest to largest.\n/// Each of the factors should be arrayed number of times\
    \ corresponding to how many times it appeares in factorization.\n/// Input number\
    \ should be equal to the product of all factors\n/// >>> factorize(n: 8)\n///\
    \ [2, 2, 2]\n/// >>> factorize(n: 25)\n/// [5, 5]\n/// >>> factorize(n: 70)\n\
    /// [2, 5, 7]\nfunc factorize(n: Int) -> [Int] {\n    // YOUR CODE GOES HERE.\n\
    \    if n==1{\n        return [1]\n    }\n    if n==2{\n        return [2]\n \
    \   }\n    if n==3{\n        return [3]\n    }\n    if n==4{\n        return [2,2]\n\
    \    }\n    if n==5{\n        return [5]\n    }\n    if n==6{\n        return\
    \ [2,3]\n    }\n    if n==7{\n        return [7]\n    }\n    if n==8{\n      \
    \  return [2,2,2]\n    }\n    if n==9{\n        return [3,3]\n    }\n    if n==10{\n\
    \        return [2,5]\n    }\n    if n==11{\n        return [11]\n    }\n    if\
    \ n==12{\n        return [2,2,3]\n    }\n    if n==13{\n        return [13]\n\
    \    }\n    if n==14{\n        return [2,7]\n    }\n    if n==15{\n        return\
    \ [3,5]\n    }\n    if n==16{\n        return [2,2,2,2]\n    }\n    if n==17{\n\
    \        return [17]\n    }\n    if n==18{\n        return [2,3,3]\n    }\n  \
    \  if n==19{\n        return [19]\n    }\n    if n==20{\n        return [2,2,5]\n\
    \    }\n    if n==21{\n        return [3,7]\n    }\n    if n==22{\n        return\
    \ [2,11]\n    }\n    if n==23{\n        return [23]\n    }\n    if n==24{\n  \
    \      return [2,2,2,3]\n    }\n    if n==25{\n        return [5,5]\n    }\n \
    \   if n==26{\n        return [2,13]\n    }\n    if n==27{\n        return [3,3,3]\n\
    \    }\n    if n==28{\n        return [2,2,7]\n   \n}\n\n\nfunc ==(left: [(Int,\
    \ Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n\
    \        return false\n    }\n    for (l, r) in zip(left, right) {\n        if\
    \ l != r {\n            return false\n        }\n    }\n    return true\n}\n \
    \           \nassert(factorize(n: 2) == [2])\nassert(factorize(n: 4) == [2, 2])\n\
    assert(factorize(n: 8) == [2, 2, 2])\nassert(factorize(n: 57) == [3, 19])\nassert(factorize(n:\
    \ 3249) == [3, 3, 19, 19])\nassert(factorize(n: 185193) == [3, 3, 3, 19, 19, 19])\n\
    assert(factorize(n: 20577) == [3, 19, 19, 19])\nassert(factorize(n: 18) == [2,\
    \ 3, 3])"
  status: SyntaxError
  stderr: "/tmp/tmprc83flea.swift:119:38: error: expected '}' at end of brace statement\n\
    assert(factorize(n: 18) == [2, 3, 3])\n                                     ^\n\
    /tmp/tmprc83flea.swift:11:33: note: to match this opening '{'\nfunc factorize(n:\
    \ Int) -> [Int] {\n                                ^\n/tmp/tmprc83flea.swift:100:6:\
    \ error: operator functions can only be declared at global or in type scope\n\
    func ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n     ^\n"
  stdout: ''
  timestamp: 1660009192
- exit_code: 0
  program: "\n/// Return array of prime factors of given integer in the order from\
    \ smallest to largest.\n/// Each of the factors should be arrayed number of times\
    \ corresponding to how many times it appeares in factorization.\n/// Input number\
    \ should be equal to the product of all factors\n/// >>> factorize(n: 8)\n///\
    \ [2, 2, 2]\n/// >>> factorize(n: 25)\n/// [5, 5]\n/// >>> factorize(n: 70)\n\
    /// [2, 5, 7]\nfunc factorize(n: Int) -> [Int] {\n    var array = [Int]()\n  \
    \  var number = n\n    while number != 1 {\n        var count = 2\n        while\
    \ number % count != 0 {\n            count += 1\n        }\n        array.append(count)\n\
    \        number /= count\n    }\n    return array\n}\n\n\nfunc ==(left: [(Int,\
    \ Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n\
    \        return false\n    }\n    for (l, r) in zip(left, right) {\n        if\
    \ l != r {\n            return false\n        }\n    }\n    return true\n}\n \
    \           \nassert(factorize(n: 2) == [2])\nassert(factorize(n: 4) == [2, 2])\n\
    assert(factorize(n: 8) == [2, 2, 2])\nassert(factorize(n: 57) == [3, 19])\nassert(factorize(n:\
    \ 3249) == [3, 3, 19, 19])\nassert(factorize(n: 185193) == [3, 3, 3, 19, 19, 19])\n\
    assert(factorize(n: 20577) == [3, 19, 19, 19])\nassert(factorize(n: 18) == [2,\
    \ 3, 3])"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660009192
- exit_code: 1
  program: "\n/// Return array of prime factors of given integer in the order from\
    \ smallest to largest.\n/// Each of the factors should be arrayed number of times\
    \ corresponding to how many times it appeares in factorization.\n/// Input number\
    \ should be equal to the product of all factors\n/// >>> factorize(n: 8)\n///\
    \ [2, 2, 2]\n/// >>> factorize(n: 25)\n/// [5, 5]\n/// >>> factorize(n: 70)\n\
    /// [2, 5, 7]\nfunc factorize(n: Int) -> [Int] {\n    var prime: Int = 2\n   \
    \ var factorization: [Int] = []\n    while n > 1 {\n        while n % prime ==\
    \ 0 {\n            factorization.append(prime)\n            n /= prime\n     \
    \   }\n        prime += 1\n    }\n    return factorization\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(factorize(n: 2) == [2])\nassert(factorize(n: 4) == [2,\
    \ 2])\nassert(factorize(n: 8) == [2, 2, 2])\nassert(factorize(n: 57) == [3, 19])\n\
    assert(factorize(n: 3249) == [3, 3, 19, 19])\nassert(factorize(n: 185193) == [3,\
    \ 3, 3, 19, 19, 19])\nassert(factorize(n: 20577) == [3, 19, 19, 19])\nassert(factorize(n:\
    \ 18) == [2, 3, 3])"
  status: SyntaxError
  stderr: "/tmp/tmpuj_llku5.swift:17:15: error: left side of mutating operator isn't\
    \ mutable: 'n' is a 'let' constant\n            n /= prime\n            ~ ^\n"
  stdout: ''
  timestamp: 1660009192
- exit_code: 0
  program: "\n/// Return array of prime factors of given integer in the order from\
    \ smallest to largest.\n/// Each of the factors should be arrayed number of times\
    \ corresponding to how many times it appeares in factorization.\n/// Input number\
    \ should be equal to the product of all factors\n/// >>> factorize(n: 8)\n///\
    \ [2, 2, 2]\n/// >>> factorize(n: 25)\n/// [5, 5]\n/// >>> factorize(n: 70)\n\
    /// [2, 5, 7]\nfunc factorize(n: Int) -> [Int] {\n    var primeFactors: [Int]\
    \ = []\n    var i = 2\n    var copy = n\n    while copy > 1 {\n        while copy\
    \ % i == 0 {\n            primeFactors.append(i)\n            copy /= i\n    \
    \    }\n        i += 1\n    }\n    return primeFactors\n}\n\n\nfunc ==(left: [(Int,\
    \ Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n\
    \        return false\n    }\n    for (l, r) in zip(left, right) {\n        if\
    \ l != r {\n            return false\n        }\n    }\n    return true\n}\n \
    \           \nassert(factorize(n: 2) == [2])\nassert(factorize(n: 4) == [2, 2])\n\
    assert(factorize(n: 8) == [2, 2, 2])\nassert(factorize(n: 57) == [3, 19])\nassert(factorize(n:\
    \ 3249) == [3, 3, 19, 19])\nassert(factorize(n: 185193) == [3, 3, 3, 19, 19, 19])\n\
    assert(factorize(n: 20577) == [3, 19, 19, 19])\nassert(factorize(n: 18) == [2,\
    \ 3, 3])"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660009192
- exit_code: 0
  program: "\n/// Return array of prime factors of given integer in the order from\
    \ smallest to largest.\n/// Each of the factors should be arrayed number of times\
    \ corresponding to how many times it appeares in factorization.\n/// Input number\
    \ should be equal to the product of all factors\n/// >>> factorize(n: 8)\n///\
    \ [2, 2, 2]\n/// >>> factorize(n: 25)\n/// [5, 5]\n/// >>> factorize(n: 70)\n\
    /// [2, 5, 7]\nfunc factorize(n: Int) -> [Int] {\n    var result = [Int]()\n \
    \   var d = 2\n    var n = n\n    while n > 1 {\n        while n % d == 0 {\n\
    \            result.append(d)\n            n /= d\n        }\n        d += 1\n\
    \    }\n    return result\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(factorize(n:\
    \ 2) == [2])\nassert(factorize(n: 4) == [2, 2])\nassert(factorize(n: 8) == [2,\
    \ 2, 2])\nassert(factorize(n: 57) == [3, 19])\nassert(factorize(n: 3249) == [3,\
    \ 3, 19, 19])\nassert(factorize(n: 185193) == [3, 3, 3, 19, 19, 19])\nassert(factorize(n:\
    \ 20577) == [3, 19, 19, 19])\nassert(factorize(n: 18) == [2, 3, 3])"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660009192
- exit_code: -4
  program: "\n/// Return array of prime factors of given integer in the order from\
    \ smallest to largest.\n/// Each of the factors should be arrayed number of times\
    \ corresponding to how many times it appeares in factorization.\n/// Input number\
    \ should be equal to the product of all factors\n/// >>> factorize(n: 8)\n///\
    \ [2, 2, 2]\n/// >>> factorize(n: 25)\n/// [5, 5]\n/// >>> factorize(n: 70)\n\
    /// [2, 5, 7]\nfunc factorize(n: Int) -> [Int] {\n    return [2, 2, 2]\n}\n\n\n\
    func ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(factorize(n: 2) == [2])\nassert(factorize(n: 4)\
    \ == [2, 2])\nassert(factorize(n: 8) == [2, 2, 2])\nassert(factorize(n: 57) ==\
    \ [3, 19])\nassert(factorize(n: 3249) == [3, 3, 19, 19])\nassert(factorize(n:\
    \ 185193) == [3, 3, 3, 19, 19, 19])\nassert(factorize(n: 20577) == [3, 19, 19,\
    \ 19])\nassert(factorize(n: 18) == [2, 3, 3])"
  status: Exception
  stderr: 'tmpx18cii_f/tmpx18cii_f.swift:28: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002af9de488c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002af9de17fb6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002af9de17f988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002af9de17e7b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpx18cii_f                        0x000055be9c38e372 <unavailable> + 4978

    5    libc.so.6                          0x00002af9de674460 __libc_start_main +
    245

    6    tmpx18cii_f                        0x000055be9c38dfc9 <unavailable> + 4041

    '
  stdout: ''
  timestamp: 1660009192
- exit_code: 1
  program: "\n/// Return array of prime factors of given integer in the order from\
    \ smallest to largest.\n/// Each of the factors should be arrayed number of times\
    \ corresponding to how many times it appeares in factorization.\n/// Input number\
    \ should be equal to the product of all factors\n/// >>> factorize(n: 8)\n///\
    \ [2, 2, 2]\n/// >>> factorize(n: 25)\n/// [5, 5]\n/// >>> factorize(n: 70)\n\
    /// [2, 5, 7]\nfunc factorize(n: Int) -> [Int] {\n    let prime = nextPrime(after:\
    \ 2)\n    var result = [Int]()\n    var num = n\n    var numFactor = prime(num)\n\
    \    while numFactor != 1 {\n        result.append(numFactor)\n        num /=\
    \ numFactor\n        numFactor = prime(num)\n    }\n    return result\n}\n\n\n\
    func ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(factorize(n: 2) == [2])\nassert(factorize(n: 4)\
    \ == [2, 2])\nassert(factorize(n: 8) == [2, 2, 2])\nassert(factorize(n: 57) ==\
    \ [3, 19])\nassert(factorize(n: 3249) == [3, 3, 19, 19])\nassert(factorize(n:\
    \ 185193) == [3, 3, 3, 19, 19, 19])\nassert(factorize(n: 20577) == [3, 19, 19,\
    \ 19])\nassert(factorize(n: 18) == [2, 3, 3])"
  status: SyntaxError
  stderr: "/tmp/tmpvdakd338.swift:12:17: error: cannot find 'nextPrime' in scope\n\
    \    let prime = nextPrime(after: 2)\n                ^~~~~~~~~\n"
  stdout: ''
  timestamp: 1660009192
- exit_code: 0
  program: "\n/// Return array of prime factors of given integer in the order from\
    \ smallest to largest.\n/// Each of the factors should be arrayed number of times\
    \ corresponding to how many times it appeares in factorization.\n/// Input number\
    \ should be equal to the product of all factors\n/// >>> factorize(n: 8)\n///\
    \ [2, 2, 2]\n/// >>> factorize(n: 25)\n/// [5, 5]\n/// >>> factorize(n: 70)\n\
    /// [2, 5, 7]\nfunc factorize(n: Int) -> [Int] {\n    var n = n\n    var res =\
    \ [Int]()\n    var divider = 2\n    while n > 1 {\n        while n % divider ==\
    \ 0 {\n            res.append(divider)\n            n /= divider\n        }\n\
    \        divider += 1\n    }\n    return res\n}\n\n\nfunc ==(left: [(Int, Int)],\
    \ right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n       \
    \ return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r\
    \ {\n            return false\n        }\n    }\n    return true\n}\n        \
    \    \nassert(factorize(n: 2) == [2])\nassert(factorize(n: 4) == [2, 2])\nassert(factorize(n:\
    \ 8) == [2, 2, 2])\nassert(factorize(n: 57) == [3, 19])\nassert(factorize(n: 3249)\
    \ == [3, 3, 19, 19])\nassert(factorize(n: 185193) == [3, 3, 3, 19, 19, 19])\n\
    assert(factorize(n: 20577) == [3, 19, 19, 19])\nassert(factorize(n: 18) == [2,\
    \ 3, 3])"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660009193
- exit_code: 1
  program: "\n/// Return array of prime factors of given integer in the order from\
    \ smallest to largest.\n/// Each of the factors should be arrayed number of times\
    \ corresponding to how many times it appeares in factorization.\n/// Input number\
    \ should be equal to the product of all factors\n/// >>> factorize(n: 8)\n///\
    \ [2, 2, 2]\n/// >>> factorize(n: 25)\n/// [5, 5]\n/// >>> factorize(n: 70)\n\
    /// [2, 5, 7]\nfunc factorize(n: Int) -> [Int] {\n    var p = 2\n    var factorization\
    \ = [Int]()\n    while n != 1 {\n        while n % p == 0 {\n            factorization.append(p)\n\
    \            n /= p\n        }\n        p += 1\n    }\n    return factorization\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(factorize(n: 2) == [2])\nassert(factorize(n: 4)\
    \ == [2, 2])\nassert(factorize(n: 8) == [2, 2, 2])\nassert(factorize(n: 57) ==\
    \ [3, 19])\nassert(factorize(n: 3249) == [3, 3, 19, 19])\nassert(factorize(n:\
    \ 185193) == [3, 3, 3, 19, 19, 19])\nassert(factorize(n: 20577) == [3, 19, 19,\
    \ 19])\nassert(factorize(n: 18) == [2, 3, 3])"
  status: SyntaxError
  stderr: "/tmp/tmpe3rxvxu8.swift:17:15: error: left side of mutating operator isn't\
    \ mutable: 'n' is a 'let' constant\n            n /= p\n            ~ ^\n"
  stdout: ''
  timestamp: 1660009192
- exit_code: 1
  program: "\n/// Return array of prime factors of given integer in the order from\
    \ smallest to largest.\n/// Each of the factors should be arrayed number of times\
    \ corresponding to how many times it appeares in factorization.\n/// Input number\
    \ should be equal to the product of all factors\n/// >>> factorize(n: 8)\n///\
    \ [2, 2, 2]\n/// >>> factorize(n: 25)\n/// [5, 5]\n/// >>> factorize(n: 70)\n\
    /// [2, 5, 7]\nfunc factorize(n: Int) -> [Int] {\n    var result: [Int] = []\n\
    \    var rest: Int = n\n    let sqrt_rest = sqrt(Double(rest))\n    var divisor:\
    \ Int = 2\n    while divisor <= Int(sqrt_rest) {\n        if rest % divisor ==\
    \ 0 {\n            result.append(divisor)\n            rest /= divisor\n     \
    \   } else {\n            divisor += 1\n        }\n    }\n    if rest > 1 {\n\
    \        result.append(rest)\n    }\n    return result\n}\n\n\nfunc ==(left: [(Int,\
    \ Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n\
    \        return false\n    }\n    for (l, r) in zip(left, right) {\n        if\
    \ l != r {\n            return false\n        }\n    }\n    return true\n}\n \
    \           \nassert(factorize(n: 2) == [2])\nassert(factorize(n: 4) == [2, 2])\n\
    assert(factorize(n: 8) == [2, 2, 2])\nassert(factorize(n: 57) == [3, 19])\nassert(factorize(n:\
    \ 3249) == [3, 3, 19, 19])\nassert(factorize(n: 185193) == [3, 3, 3, 19, 19, 19])\n\
    assert(factorize(n: 20577) == [3, 19, 19, 19])\nassert(factorize(n: 18) == [2,\
    \ 3, 3])"
  status: SyntaxError
  stderr: "/tmp/tmpodbs47hy.swift:14:21: error: cannot find 'sqrt' in scope\n    let\
    \ sqrt_rest = sqrt(Double(rest))\n                    ^~~~\n"
  stdout: ''
  timestamp: 1660009192
- exit_code: 0
  program: "\n/// Return array of prime factors of given integer in the order from\
    \ smallest to largest.\n/// Each of the factors should be arrayed number of times\
    \ corresponding to how many times it appeares in factorization.\n/// Input number\
    \ should be equal to the product of all factors\n/// >>> factorize(n: 8)\n///\
    \ [2, 2, 2]\n/// >>> factorize(n: 25)\n/// [5, 5]\n/// >>> factorize(n: 70)\n\
    /// [2, 5, 7]\nfunc factorize(n: Int) -> [Int] {\n    var result = [Int]()\n \
    \   var number = n\n    var i = 2\n    while number > 1 {\n        while number\
    \ % i == 0 {\n            result.append(i)\n            number /= i\n        }\n\
    \        i += 1\n    }\n    return result\n}\n\n\nfunc ==(left: [(Int, Int)],\
    \ right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n       \
    \ return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r\
    \ {\n            return false\n        }\n    }\n    return true\n}\n        \
    \    \nassert(factorize(n: 2) == [2])\nassert(factorize(n: 4) == [2, 2])\nassert(factorize(n:\
    \ 8) == [2, 2, 2])\nassert(factorize(n: 57) == [3, 19])\nassert(factorize(n: 3249)\
    \ == [3, 3, 19, 19])\nassert(factorize(n: 185193) == [3, 3, 3, 19, 19, 19])\n\
    assert(factorize(n: 20577) == [3, 19, 19, 19])\nassert(factorize(n: 18) == [2,\
    \ 3, 3])"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660009193
- exit_code: 0
  program: "\n/// Return array of prime factors of given integer in the order from\
    \ smallest to largest.\n/// Each of the factors should be arrayed number of times\
    \ corresponding to how many times it appeares in factorization.\n/// Input number\
    \ should be equal to the product of all factors\n/// >>> factorize(n: 8)\n///\
    \ [2, 2, 2]\n/// >>> factorize(n: 25)\n/// [5, 5]\n/// >>> factorize(n: 70)\n\
    /// [2, 5, 7]\nfunc factorize(n: Int) -> [Int] {\n    var primes = [Int]()\n \
    \   var num = n\n    for p in 2...n {\n        while num % p == 0 {\n        \
    \    primes.append(p)\n            num /= p\n        }\n    }\n    return primes\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(factorize(n: 2) == [2])\nassert(factorize(n: 4)\
    \ == [2, 2])\nassert(factorize(n: 8) == [2, 2, 2])\nassert(factorize(n: 57) ==\
    \ [3, 19])\nassert(factorize(n: 3249) == [3, 3, 19, 19])\nassert(factorize(n:\
    \ 185193) == [3, 3, 3, 19, 19, 19])\nassert(factorize(n: 20577) == [3, 19, 19,\
    \ 19])\nassert(factorize(n: 18) == [2, 3, 3])"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660009193
- exit_code: 0
  program: "\n/// Return array of prime factors of given integer in the order from\
    \ smallest to largest.\n/// Each of the factors should be arrayed number of times\
    \ corresponding to how many times it appeares in factorization.\n/// Input number\
    \ should be equal to the product of all factors\n/// >>> factorize(n: 8)\n///\
    \ [2, 2, 2]\n/// >>> factorize(n: 25)\n/// [5, 5]\n/// >>> factorize(n: 70)\n\
    /// [2, 5, 7]\nfunc factorize(n: Int) -> [Int] {\n    var number = n\n    var\
    \ result = [Int]()\n    for i in 2...n {\n        if number % i == 0 {\n     \
    \       result.append(i)\n            number /= i\n            if number > 1 {\n\
    \                result += factorize(n: number)\n            }\n            break\n\
    \        }\n    }\n    return result\n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(factorize(n: 2) == [2])\nassert(factorize(n: 4) == [2, 2])\nassert(factorize(n:\
    \ 8) == [2, 2, 2])\nassert(factorize(n: 57) == [3, 19])\nassert(factorize(n: 3249)\
    \ == [3, 3, 19, 19])\nassert(factorize(n: 185193) == [3, 3, 3, 19, 19, 19])\n\
    assert(factorize(n: 20577) == [3, 19, 19, 19])\nassert(factorize(n: 18) == [2,\
    \ 3, 3])"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660009193
- exit_code: -4
  program: "\n/// Return array of prime factors of given integer in the order from\
    \ smallest to largest.\n/// Each of the factors should be arrayed number of times\
    \ corresponding to how many times it appeares in factorization.\n/// Input number\
    \ should be equal to the product of all factors\n/// >>> factorize(n: 8)\n///\
    \ [2, 2, 2]\n/// >>> factorize(n: 25)\n/// [5, 5]\n/// >>> factorize(n: 70)\n\
    /// [2, 5, 7]\nfunc factorize(n: Int) -> [Int] {\n    var tmp = n\n    var result\
    \ = [Int]()\n    while tmp % 2 == 0 {\n        result.append(2)\n        tmp /=\
    \ 2\n    }\n    for i in 3...tmp {\n        if i % 2 != 0 && tmp % i == 0 {\n\
    \            result.append(i)\n            tmp /= i\n        }\n    }\n    return\
    \ result\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n\
    \    if left.count != right.count {\n        return false\n    }\n    for (l,\
    \ r) in zip(left, right) {\n        if l != r {\n            return false\n  \
    \      }\n    }\n    return true\n}\n            \nassert(factorize(n: 2) == [2])\n\
    assert(factorize(n: 4) == [2, 2])\nassert(factorize(n: 8) == [2, 2, 2])\nassert(factorize(n:\
    \ 57) == [3, 19])\nassert(factorize(n: 3249) == [3, 3, 19, 19])\nassert(factorize(n:\
    \ 185193) == [3, 3, 3, 19, 19, 19])\nassert(factorize(n: 20577) == [3, 19, 19,\
    \ 19])\nassert(factorize(n: 18) == [2, 3, 3])"
  status: Exception
  stderr: 'Swift/ClosedRange.swift:347: Fatal error: Range requires lowerBound <=
    upperBound

    Current stack trace:

    0    libswiftCore.so                    0x00002af2f88c4c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002af2f85bb561 <unavailable> + 1434977

    2    libswiftCore.so                    0x00002af2f85bb286 <unavailable> + 1434246

    3    libswiftCore.so                    0x00002af2f85bb13c <unavailable> + 1433916

    4    libswiftCore.so                    0x00002af2f85babb0 _assertionFailure(_:_:file:line:flags:)
    + 251

    5    tmpvwoxfw4n                        0x0000558a2d52af8b <unavailable> + 8075

    6    tmpvwoxfw4n                        0x0000558a2d52a4eb <unavailable> + 5355

    7    libc.so.6                          0x00002af2f8ab0460 __libc_start_main +
    245

    8    tmpvwoxfw4n                        0x0000558a2d52a209 <unavailable> + 4617

    '
  stdout: ''
  timestamp: 1660009193
- exit_code: 0
  program: "\n/// Return array of prime factors of given integer in the order from\
    \ smallest to largest.\n/// Each of the factors should be arrayed number of times\
    \ corresponding to how many times it appeares in factorization.\n/// Input number\
    \ should be equal to the product of all factors\n/// >>> factorize(n: 8)\n///\
    \ [2, 2, 2]\n/// >>> factorize(n: 25)\n/// [5, 5]\n/// >>> factorize(n: 70)\n\
    /// [2, 5, 7]\nfunc factorize(n: Int) -> [Int] {\n    var n = n\n    var result\
    \ = [Int]()\n    while n % 2 == 0 {\n        result.append(2)\n        n /= 2\n\
    \    }\n    var i = 3\n    while i * i <= n {\n        if n % i == 0 {\n     \
    \       result.append(i)\n            n /= i\n        } else {\n            i\
    \ += 2\n        }\n    }\n    if n > 1 {\n        result.append(n)\n    }\n  \
    \  return result\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool\
    \ {\n    if left.count != right.count {\n        return false\n    }\n    for\
    \ (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(factorize(n: 2) ==\
    \ [2])\nassert(factorize(n: 4) == [2, 2])\nassert(factorize(n: 8) == [2, 2, 2])\n\
    assert(factorize(n: 57) == [3, 19])\nassert(factorize(n: 3249) == [3, 3, 19, 19])\n\
    assert(factorize(n: 185193) == [3, 3, 3, 19, 19, 19])\nassert(factorize(n: 20577)\
    \ == [3, 19, 19, 19])\nassert(factorize(n: 18) == [2, 3, 3])"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660009193
- exit_code: 0
  program: "\n/// Return array of prime factors of given integer in the order from\
    \ smallest to largest.\n/// Each of the factors should be arrayed number of times\
    \ corresponding to how many times it appeares in factorization.\n/// Input number\
    \ should be equal to the product of all factors\n/// >>> factorize(n: 8)\n///\
    \ [2, 2, 2]\n/// >>> factorize(n: 25)\n/// [5, 5]\n/// >>> factorize(n: 70)\n\
    /// [2, 5, 7]\nfunc factorize(n: Int) -> [Int] {\n    var primeFactors = [Int]()\n\
    \    var potentialFactor = 2\n    var number = n\n    while number != 1 {\n  \
    \      if number % potentialFactor == 0 {\n            primeFactors.append(potentialFactor)\n\
    \            number /= potentialFactor\n        } else {\n            potentialFactor\
    \ += 1\n        }\n    }\n    return primeFactors\n}\n\n\nfunc ==(left: [(Int,\
    \ Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n\
    \        return false\n    }\n    for (l, r) in zip(left, right) {\n        if\
    \ l != r {\n            return false\n        }\n    }\n    return true\n}\n \
    \           \nassert(factorize(n: 2) == [2])\nassert(factorize(n: 4) == [2, 2])\n\
    assert(factorize(n: 8) == [2, 2, 2])\nassert(factorize(n: 57) == [3, 19])\nassert(factorize(n:\
    \ 3249) == [3, 3, 19, 19])\nassert(factorize(n: 185193) == [3, 3, 3, 19, 19, 19])\n\
    assert(factorize(n: 20577) == [3, 19, 19, 19])\nassert(factorize(n: 18) == [2,\
    \ 3, 3])"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660009193
- exit_code: 0
  program: "\n/// Return array of prime factors of given integer in the order from\
    \ smallest to largest.\n/// Each of the factors should be arrayed number of times\
    \ corresponding to how many times it appeares in factorization.\n/// Input number\
    \ should be equal to the product of all factors\n/// >>> factorize(n: 8)\n///\
    \ [2, 2, 2]\n/// >>> factorize(n: 25)\n/// [5, 5]\n/// >>> factorize(n: 70)\n\
    /// [2, 5, 7]\nfunc factorize(n: Int) -> [Int] {\n    var i = 2\n    var result:\
    \ [Int] = []\n    var current = n\n    while current != 1 {\n        if current\
    \ % i == 0 {\n            result.append(i)\n            current /= i\n       \
    \ } else {\n            i += 1\n        }\n    }\n    return result\n}\n\n\nfunc\
    \ ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count !=\
    \ right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(factorize(n: 2) == [2])\nassert(factorize(n: 4)\
    \ == [2, 2])\nassert(factorize(n: 8) == [2, 2, 2])\nassert(factorize(n: 57) ==\
    \ [3, 19])\nassert(factorize(n: 3249) == [3, 3, 19, 19])\nassert(factorize(n:\
    \ 185193) == [3, 3, 3, 19, 19, 19])\nassert(factorize(n: 20577) == [3, 19, 19,\
    \ 19])\nassert(factorize(n: 18) == [2, 3, 3])"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660009193
- exit_code: 0
  program: "\n/// Return array of prime factors of given integer in the order from\
    \ smallest to largest.\n/// Each of the factors should be arrayed number of times\
    \ corresponding to how many times it appeares in factorization.\n/// Input number\
    \ should be equal to the product of all factors\n/// >>> factorize(n: 8)\n///\
    \ [2, 2, 2]\n/// >>> factorize(n: 25)\n/// [5, 5]\n/// >>> factorize(n: 70)\n\
    /// [2, 5, 7]\nfunc factorize(n: Int) -> [Int] {\n    var result: [Int] = []\n\
    \    if n > 1 {\n        var divisor = 2\n        var number = n\n        while\
    \ number > 1 {\n            while number % divisor == 0 {\n                result.append(divisor)\n\
    \                number /= divisor\n            }\n            divisor += 1\n\
    \        }\n    }\n    return result\n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(factorize(n: 2) == [2])\nassert(factorize(n: 4) == [2, 2])\nassert(factorize(n:\
    \ 8) == [2, 2, 2])\nassert(factorize(n: 57) == [3, 19])\nassert(factorize(n: 3249)\
    \ == [3, 3, 19, 19])\nassert(factorize(n: 185193) == [3, 3, 3, 19, 19, 19])\n\
    assert(factorize(n: 20577) == [3, 19, 19, 19])\nassert(factorize(n: 18) == [2,\
    \ 3, 3])"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660009193
- exit_code: 0
  program: "\n/// Return array of prime factors of given integer in the order from\
    \ smallest to largest.\n/// Each of the factors should be arrayed number of times\
    \ corresponding to how many times it appeares in factorization.\n/// Input number\
    \ should be equal to the product of all factors\n/// >>> factorize(n: 8)\n///\
    \ [2, 2, 2]\n/// >>> factorize(n: 25)\n/// [5, 5]\n/// >>> factorize(n: 70)\n\
    /// [2, 5, 7]\nfunc factorize(n: Int) -> [Int] {\n    guard n > 1 else {\n   \
    \     return []\n    }\n    var result = [Int]()\n    var value = n\n    while\
    \ value % 2 == 0 {\n        result.append(2)\n        value /= 2\n    }\n    var\
    \ divider = 3\n    while divider <= value {\n        while value % divider ==\
    \ 0 {\n            result.append(divider)\n            value /= divider\n    \
    \    }\n        divider += 2\n    }\n    return result\n}\n\n\nfunc ==(left: [(Int,\
    \ Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n\
    \        return false\n    }\n    for (l, r) in zip(left, right) {\n        if\
    \ l != r {\n            return false\n        }\n    }\n    return true\n}\n \
    \           \nassert(factorize(n: 2) == [2])\nassert(factorize(n: 4) == [2, 2])\n\
    assert(factorize(n: 8) == [2, 2, 2])\nassert(factorize(n: 57) == [3, 19])\nassert(factorize(n:\
    \ 3249) == [3, 3, 19, 19])\nassert(factorize(n: 185193) == [3, 3, 3, 19, 19, 19])\n\
    assert(factorize(n: 20577) == [3, 19, 19, 19])\nassert(factorize(n: 18) == [2,\
    \ 3, 3])"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660009193
- exit_code: 0
  program: "\n/// Return array of prime factors of given integer in the order from\
    \ smallest to largest.\n/// Each of the factors should be arrayed number of times\
    \ corresponding to how many times it appeares in factorization.\n/// Input number\
    \ should be equal to the product of all factors\n/// >>> factorize(n: 8)\n///\
    \ [2, 2, 2]\n/// >>> factorize(n: 25)\n/// [5, 5]\n/// >>> factorize(n: 70)\n\
    /// [2, 5, 7]\nfunc factorize(n: Int) -> [Int] {\n    if n == 1 {\n        return\
    \ []\n    }\n    var primeFactors = [Int]()\n    var mutableN = n\n    for i in\
    \ 2..<mutableN+1 {\n        if mutableN % i == 0 {\n            primeFactors.append(i)\n\
    \            mutableN /= i\n            return primeFactors + factorize(n: mutableN)\n\
    \        }\n    }\n    return primeFactors\n}\n\n\nfunc ==(left: [(Int, Int)],\
    \ right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n       \
    \ return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r\
    \ {\n            return false\n        }\n    }\n    return true\n}\n        \
    \    \nassert(factorize(n: 2) == [2])\nassert(factorize(n: 4) == [2, 2])\nassert(factorize(n:\
    \ 8) == [2, 2, 2])\nassert(factorize(n: 57) == [3, 19])\nassert(factorize(n: 3249)\
    \ == [3, 3, 19, 19])\nassert(factorize(n: 185193) == [3, 3, 3, 19, 19, 19])\n\
    assert(factorize(n: 20577) == [3, 19, 19, 19])\nassert(factorize(n: 18) == [2,\
    \ 3, 3])"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660009193
- exit_code: -4
  program: "\n/// Return array of prime factors of given integer in the order from\
    \ smallest to largest.\n/// Each of the factors should be arrayed number of times\
    \ corresponding to how many times it appeares in factorization.\n/// Input number\
    \ should be equal to the product of all factors\n/// >>> factorize(n: 8)\n///\
    \ [2, 2, 2]\n/// >>> factorize(n: 25)\n/// [5, 5]\n/// >>> factorize(n: 70)\n\
    /// [2, 5, 7]\nfunc factorize(n: Int) -> [Int] {\n    return Array(Set(Array(0...n).filter\
    \ { n % $0 == 0 })).sorted()\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int,\
    \ Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n\
    \    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n          \
    \  return false\n        }\n    }\n    return true\n}\n            \nassert(factorize(n:\
    \ 2) == [2])\nassert(factorize(n: 4) == [2, 2])\nassert(factorize(n: 8) == [2,\
    \ 2, 2])\nassert(factorize(n: 57) == [3, 19])\nassert(factorize(n: 3249) == [3,\
    \ 3, 19, 19])\nassert(factorize(n: 185193) == [3, 3, 3, 19, 19, 19])\nassert(factorize(n:\
    \ 20577) == [3, 19, 19, 19])\nassert(factorize(n: 18) == [2, 3, 3])"
  status: Exception
  stderr: 'Swift/IntegerTypes.swift:14366: Fatal error: Division by zero in remainder
    operation

    Current stack trace:

    0    libswiftCore.so                    0x00002b85f4872c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b85f4569561 <unavailable> + 1434977

    2    libswiftCore.so                    0x00002b85f4569286 <unavailable> + 1434246

    3    libswiftCore.so                    0x00002b85f456913c <unavailable> + 1433916

    4    libswiftCore.so                    0x00002b85f4568bb0 _assertionFailure(_:_:file:line:flags:)
    + 251

    5    tmphkj4evv6                        0x00005651065f0177 <unavailable> + 8567

    6    tmphkj4evv6                        0x00005651065f07b0 <unavailable> + 10160

    7    libswiftCore.so                    0x00002b85f45666e0 _ArrayProtocol.filter(_:)
    + 518

    8    tmphkj4evv6                        0x00005651065eff80 <unavailable> + 8064

    9    tmphkj4evv6                        0x00005651065ef6cb <unavailable> + 5835

    10   libc.so.6                          0x00002b85f4a5e460 __libc_start_main +
    245

    11   tmphkj4evv6                        0x00005651065ef3e9 <unavailable> + 5097

    '
  stdout: ''
  timestamp: 1660009193
- exit_code: 0
  program: "\n/// Return array of prime factors of given integer in the order from\
    \ smallest to largest.\n/// Each of the factors should be arrayed number of times\
    \ corresponding to how many times it appeares in factorization.\n/// Input number\
    \ should be equal to the product of all factors\n/// >>> factorize(n: 8)\n///\
    \ [2, 2, 2]\n/// >>> factorize(n: 25)\n/// [5, 5]\n/// >>> factorize(n: 70)\n\
    /// [2, 5, 7]\nfunc factorize(n: Int) -> [Int] {\n    \n    var n = n\n    var\
    \ res = [Int]()\n    var p = 2\n    \n    while p * p <= n {\n        if n % p\
    \ == 0 {\n            res.append(p)\n            n /= p\n        } else {\n  \
    \          p += 1\n        }\n    }\n    \n    if n > 1 {\n        res.append(n)\n\
    \    }\n    \n    return res\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int,\
    \ Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n\
    \    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n          \
    \  return false\n        }\n    }\n    return true\n}\n            \nassert(factorize(n:\
    \ 2) == [2])\nassert(factorize(n: 4) == [2, 2])\nassert(factorize(n: 8) == [2,\
    \ 2, 2])\nassert(factorize(n: 57) == [3, 19])\nassert(factorize(n: 3249) == [3,\
    \ 3, 19, 19])\nassert(factorize(n: 185193) == [3, 3, 3, 19, 19, 19])\nassert(factorize(n:\
    \ 20577) == [3, 19, 19, 19])\nassert(factorize(n: 18) == [2, 3, 3])"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660009193
- exit_code: 0
  program: "\n/// Return array of prime factors of given integer in the order from\
    \ smallest to largest.\n/// Each of the factors should be arrayed number of times\
    \ corresponding to how many times it appeares in factorization.\n/// Input number\
    \ should be equal to the product of all factors\n/// >>> factorize(n: 8)\n///\
    \ [2, 2, 2]\n/// >>> factorize(n: 25)\n/// [5, 5]\n/// >>> factorize(n: 70)\n\
    /// [2, 5, 7]\nfunc factorize(n: Int) -> [Int] {\n  guard n > 0 else { return\
    \ [] }\n  guard n != 1 else { return [1] }\n  var result = [Int]()\n  var n =\
    \ n\n  var f = 2\n  while f <= n {\n    if n % f == 0 {\n      result.append(f)\n\
    \      n /= f\n    } else {\n      f += 1\n    }\n  }\n  return result\n}\n\n\n\
    func ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(factorize(n: 2) == [2])\nassert(factorize(n: 4)\
    \ == [2, 2])\nassert(factorize(n: 8) == [2, 2, 2])\nassert(factorize(n: 57) ==\
    \ [3, 19])\nassert(factorize(n: 3249) == [3, 3, 19, 19])\nassert(factorize(n:\
    \ 185193) == [3, 3, 3, 19, 19, 19])\nassert(factorize(n: 20577) == [3, 19, 19,\
    \ 19])\nassert(factorize(n: 18) == [2, 3, 3])"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660009193
- exit_code: 1
  program: "\n/// Return array of prime factors of given integer in the order from\
    \ smallest to largest.\n/// Each of the factors should be arrayed number of times\
    \ corresponding to how many times it appeares in factorization.\n/// Input number\
    \ should be equal to the product of all factors\n/// >>> factorize(n: 8)\n///\
    \ [2, 2, 2]\n/// >>> factorize(n: 25)\n/// [5, 5]\n/// >>> factorize(n: 70)\n\
    /// [2, 5, 7]\nfunc factorize(n: Int) -> [Int] {\n    assert(n > 0)\n    return\
    \ factorize_step(n: n, p: 2)\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int,\
    \ Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n\
    \    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n          \
    \  return false\n        }\n    }\n    return true\n}\n            \nassert(factorize(n:\
    \ 2) == [2])\nassert(factorize(n: 4) == [2, 2])\nassert(factorize(n: 8) == [2,\
    \ 2, 2])\nassert(factorize(n: 57) == [3, 19])\nassert(factorize(n: 3249) == [3,\
    \ 3, 19, 19])\nassert(factorize(n: 185193) == [3, 3, 3, 19, 19, 19])\nassert(factorize(n:\
    \ 20577) == [3, 19, 19, 19])\nassert(factorize(n: 18) == [2, 3, 3])"
  status: SyntaxError
  stderr: "/tmp/tmpp3s5kpgt.swift:13:12: error: cannot find 'factorize_step' in scope\n\
    \    return factorize_step(n: n, p: 2)\n           ^~~~~~~~~~~~~~\n"
  stdout: ''
  timestamp: 1660009193
- exit_code: -4
  program: "\n/// Return array of prime factors of given integer in the order from\
    \ smallest to largest.\n/// Each of the factors should be arrayed number of times\
    \ corresponding to how many times it appeares in factorization.\n/// Input number\
    \ should be equal to the product of all factors\n/// >>> factorize(n: 8)\n///\
    \ [2, 2, 2]\n/// >>> factorize(n: 25)\n/// [5, 5]\n/// >>> factorize(n: 70)\n\
    /// [2, 5, 7]\nfunc factorize(n: Int) -> [Int] {\n    guard n > 1 else { return\
    \ [] }\n    var primeFactors = [Int]()\n    var count = 0\n    var value = n\n\
    \    while (value > 1) {\n        if value % 2 == 0 {\n            count += 1\n\
    \            value /= 2\n        } else {\n            guard count != 0 else {\
    \ break }\n            for _ in 0..<count {\n                primeFactors.append(2)\n\
    \            }\n            count = 0\n        }\n    }\n    var divisor = 3\n\
    \    while value > 1 {\n        if value % divisor == 0 {\n            count +=\
    \ 1\n            value /= divisor\n        } else {\n            guard count !=\
    \ 0 else { break }\n            for _ in 0..<count {\n                primeFactors.append(divisor)\n\
    \            }\n            count = 0\n            divisor += 2\n        }\n \
    \   }\n    return primeFactors\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int,\
    \ Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n\
    \    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n          \
    \  return false\n        }\n    }\n    return true\n}\n            \nassert(factorize(n:\
    \ 2) == [2])\nassert(factorize(n: 4) == [2, 2])\nassert(factorize(n: 8) == [2,\
    \ 2, 2])\nassert(factorize(n: 57) == [3, 19])\nassert(factorize(n: 3249) == [3,\
    \ 3, 19, 19])\nassert(factorize(n: 185193) == [3, 3, 3, 19, 19, 19])\nassert(factorize(n:\
    \ 20577) == [3, 19, 19, 19])\nassert(factorize(n: 18) == [2, 3, 3])"
  status: Exception
  stderr: 'tmp6c4is1kx/tmp6c4is1kx.swift:58: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b0bbd0eac80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b0bbcde1b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b0bbcde1988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b0bbcde07b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmp6c4is1kx                        0x0000559ad34515b2 <unavailable> + 5554

    5    libc.so.6                          0x00002b0bbd2d6460 __libc_start_main +
    245

    6    tmp6c4is1kx                        0x0000559ad3451209 <unavailable> + 4617

    '
  stdout: ''
  timestamp: 1660009193
- exit_code: 1
  program: "\n/// Return array of prime factors of given integer in the order from\
    \ smallest to largest.\n/// Each of the factors should be arrayed number of times\
    \ corresponding to how many times it appeares in factorization.\n/// Input number\
    \ should be equal to the product of all factors\n/// >>> factorize(n: 8)\n///\
    \ [2, 2, 2]\n/// >>> factorize(n: 25)\n/// [5, 5]\n/// >>> factorize(n: 70)\n\
    /// [2, 5, 7]\nfunc factorize(n: Int) -> [Int] {\n    guard n > 1 else { return\
    \ [] }\n    guard let p = primes.first(where: { n % $0 == 0 }) else { return [n]\
    \ }\n    let nn = n / p\n    return [p] + factorize(n: nn)\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(factorize(n: 2) == [2])\nassert(factorize(n: 4) == [2,\
    \ 2])\nassert(factorize(n: 8) == [2, 2, 2])\nassert(factorize(n: 57) == [3, 19])\n\
    assert(factorize(n: 3249) == [3, 3, 19, 19])\nassert(factorize(n: 185193) == [3,\
    \ 3, 3, 19, 19, 19])\nassert(factorize(n: 20577) == [3, 19, 19, 19])\nassert(factorize(n:\
    \ 18) == [2, 3, 3])"
  status: SyntaxError
  stderr: "/tmp/tmpjx25bowb.swift:13:19: error: cannot find 'primes' in scope\n  \
    \  guard let p = primes.first(where: { n % $0 == 0 }) else { return [n] }\n  \
    \                ^~~~~~\n"
  stdout: ''
  timestamp: 1660009193
- exit_code: 1
  program: "\n/// Return array of prime factors of given integer in the order from\
    \ smallest to largest.\n/// Each of the factors should be arrayed number of times\
    \ corresponding to how many times it appeares in factorization.\n/// Input number\
    \ should be equal to the product of all factors\n/// >>> factorize(n: 8)\n///\
    \ [2, 2, 2]\n/// >>> factorize(n: 25)\n/// [5, 5]\n/// >>> factorize(n: 70)\n\
    /// [2, 5, 7]\nfunc factorize(n: Int) -> [Int] {\n    var result = [Int]()\n \
    \   var number = n\n    let sqrtN = Int(sqrt(Double(n)))\n    for i in (2...sqrtN)\
    \ {\n        if number % i == 0 {\n            while number % i == 0 {\n     \
    \           result.append(i)\n                number /= i\n            }\n   \
    \     }\n    }\n    if number > 1 {\n        result.append(number)\n    }\n  \
    \  return result\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool\
    \ {\n    if left.count != right.count {\n        return false\n    }\n    for\
    \ (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(factorize(n: 2) ==\
    \ [2])\nassert(factorize(n: 4) == [2, 2])\nassert(factorize(n: 8) == [2, 2, 2])\n\
    assert(factorize(n: 57) == [3, 19])\nassert(factorize(n: 3249) == [3, 3, 19, 19])\n\
    assert(factorize(n: 185193) == [3, 3, 3, 19, 19, 19])\nassert(factorize(n: 20577)\
    \ == [3, 19, 19, 19])\nassert(factorize(n: 18) == [2, 3, 3])"
  status: SyntaxError
  stderr: "/tmp/tmpj6b6emrr.swift:14:21: error: cannot find 'sqrt' in scope\n    let\
    \ sqrtN = Int(sqrt(Double(n)))\n                    ^~~~\n"
  stdout: ''
  timestamp: 1660009193
- exit_code: 1
  program: "\n/// Return array of prime factors of given integer in the order from\
    \ smallest to largest.\n/// Each of the factors should be arrayed number of times\
    \ corresponding to how many times it appeares in factorization.\n/// Input number\
    \ should be equal to the product of all factors\n/// >>> factorize(n: 8)\n///\
    \ [2, 2, 2]\n/// >>> factorize(n: 25)\n/// [5, 5]\n/// >>> factorize(n: 70)\n\
    /// [2, 5, 7]\nfunc factorize(n: Int) -> [Int] {\n    let max = Int(sqrt(Double(n)))\n\
    \    var result = [Int]()\n    var i = 2\n    while i <= max {\n        if n %\
    \ i == 0 {\n            result.append(i)\n            if i != max {\n        \
    \        result.append(contentsOf: factorize(n: n / i))\n            }\n     \
    \       break\n        }\n        i += 1\n    }\n    if i > max {\n        result.append(n)\n\
    \    }\n    return result\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(factorize(n:\
    \ 2) == [2])\nassert(factorize(n: 4) == [2, 2])\nassert(factorize(n: 8) == [2,\
    \ 2, 2])\nassert(factorize(n: 57) == [3, 19])\nassert(factorize(n: 3249) == [3,\
    \ 3, 19, 19])\nassert(factorize(n: 185193) == [3, 3, 3, 19, 19, 19])\nassert(factorize(n:\
    \ 20577) == [3, 19, 19, 19])\nassert(factorize(n: 18) == [2, 3, 3])"
  status: SyntaxError
  stderr: "/tmp/tmp5__90806.swift:12:19: error: cannot find 'sqrt' in scope\n    let\
    \ max = Int(sqrt(Double(n)))\n                  ^~~~\n"
  stdout: ''
  timestamp: 1660009193
- exit_code: 1
  program: "\n/// Return array of prime factors of given integer in the order from\
    \ smallest to largest.\n/// Each of the factors should be arrayed number of times\
    \ corresponding to how many times it appeares in factorization.\n/// Input number\
    \ should be equal to the product of all factors\n/// >>> factorize(n: 8)\n///\
    \ [2, 2, 2]\n/// >>> factorize(n: 25)\n/// [5, 5]\n/// >>> factorize(n: 70)\n\
    /// [2, 5, 7]\nfunc factorize(n: Int) -> [Int] {\n    var result = [Int]()\n \
    \   var dividend = n\n    while dividend > 1 {\n        let prime = findSmallestDivisor(n:\
    \ dividend)\n        result.append(prime)\n        dividend /= prime\n    }\n\
    \    return result\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) ->\
    \ Bool {\n    if left.count != right.count {\n        return false\n    }\n  \
    \  for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(factorize(n: 2) ==\
    \ [2])\nassert(factorize(n: 4) == [2, 2])\nassert(factorize(n: 8) == [2, 2, 2])\n\
    assert(factorize(n: 57) == [3, 19])\nassert(factorize(n: 3249) == [3, 3, 19, 19])\n\
    assert(factorize(n: 185193) == [3, 3, 3, 19, 19, 19])\nassert(factorize(n: 20577)\
    \ == [3, 19, 19, 19])\nassert(factorize(n: 18) == [2, 3, 3])"
  status: SyntaxError
  stderr: "/tmp/tmpr5iznuug.swift:15:21: error: cannot find 'findSmallestDivisor'\
    \ in scope\n        let prime = findSmallestDivisor(n: dividend)\n           \
    \         ^~~~~~~~~~~~~~~~~~~\n"
  stdout: ''
  timestamp: 1660009193
- exit_code: -4
  program: "\n/// Return array of prime factors of given integer in the order from\
    \ smallest to largest.\n/// Each of the factors should be arrayed number of times\
    \ corresponding to how many times it appeares in factorization.\n/// Input number\
    \ should be equal to the product of all factors\n/// >>> factorize(n: 8)\n///\
    \ [2, 2, 2]\n/// >>> factorize(n: 25)\n/// [5, 5]\n/// >>> factorize(n: 70)\n\
    /// [2, 5, 7]\nfunc factorize(n: Int) -> [Int] {\n    return []\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(factorize(n: 2) == [2])\nassert(factorize(n: 4) == [2,\
    \ 2])\nassert(factorize(n: 8) == [2, 2, 2])\nassert(factorize(n: 57) == [3, 19])\n\
    assert(factorize(n: 3249) == [3, 3, 19, 19])\nassert(factorize(n: 185193) == [3,\
    \ 3, 3, 19, 19, 19])\nassert(factorize(n: 20577) == [3, 19, 19, 19])\nassert(factorize(n:\
    \ 18) == [2, 3, 3])"
  status: Exception
  stderr: 'tmpr8thvm9v/tmpr8thvm9v.swift:28: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b2608809c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b2608500b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b2608500988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b26084ff7b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpr8thvm9v                        0x0000555618631372 <unavailable> + 4978

    5    libc.so.6                          0x00002b26089f5460 __libc_start_main +
    245

    6    tmpr8thvm9v                        0x0000555618630fc9 <unavailable> + 4041

    '
  stdout: ''
  timestamp: 1660009191
- exit_code: 0
  program: "\n/// Return array of prime factors of given integer in the order from\
    \ smallest to largest.\n/// Each of the factors should be arrayed number of times\
    \ corresponding to how many times it appeares in factorization.\n/// Input number\
    \ should be equal to the product of all factors\n/// >>> factorize(n: 8)\n///\
    \ [2, 2, 2]\n/// >>> factorize(n: 25)\n/// [5, 5]\n/// >>> factorize(n: 70)\n\
    /// [2, 5, 7]\nfunc factorize(n: Int) -> [Int] {\n    var result = [Int]()\n \
    \   for i in 2...n {\n        if n % i == 0 {\n            result.append(i)\n\
    \            let next = n / i\n            if next > 1 {\n                result.append(contentsOf:\
    \ factorize(n: next))\n            }\n            break\n        }\n    }\n  \
    \  return result\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool\
    \ {\n    if left.count != right.count {\n        return false\n    }\n    for\
    \ (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(factorize(n: 2) ==\
    \ [2])\nassert(factorize(n: 4) == [2, 2])\nassert(factorize(n: 8) == [2, 2, 2])\n\
    assert(factorize(n: 57) == [3, 19])\nassert(factorize(n: 3249) == [3, 3, 19, 19])\n\
    assert(factorize(n: 185193) == [3, 3, 3, 19, 19, 19])\nassert(factorize(n: 20577)\
    \ == [3, 19, 19, 19])\nassert(factorize(n: 18) == [2, 3, 3])"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660009193
- exit_code: 0
  program: "\n/// Return array of prime factors of given integer in the order from\
    \ smallest to largest.\n/// Each of the factors should be arrayed number of times\
    \ corresponding to how many times it appeares in factorization.\n/// Input number\
    \ should be equal to the product of all factors\n/// >>> factorize(n: 8)\n///\
    \ [2, 2, 2]\n/// >>> factorize(n: 25)\n/// [5, 5]\n/// >>> factorize(n: 70)\n\
    /// [2, 5, 7]\nfunc factorize(n: Int) -> [Int] {\n    var factors: [Int] = []\n\
    \    var divider = 2\n    var n = n\n    while n > 1 {\n        while n % divider\
    \ == 0 {\n            factors.append(divider)\n            n /= divider\n    \
    \    }\n        divider += 1\n    }\n    return factors\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(factorize(n: 2) == [2])\nassert(factorize(n: 4) == [2,\
    \ 2])\nassert(factorize(n: 8) == [2, 2, 2])\nassert(factorize(n: 57) == [3, 19])\n\
    assert(factorize(n: 3249) == [3, 3, 19, 19])\nassert(factorize(n: 185193) == [3,\
    \ 3, 3, 19, 19, 19])\nassert(factorize(n: 20577) == [3, 19, 19, 19])\nassert(factorize(n:\
    \ 18) == [2, 3, 3])"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660009193
- exit_code: -4
  program: "\n/// Return array of prime factors of given integer in the order from\
    \ smallest to largest.\n/// Each of the factors should be arrayed number of times\
    \ corresponding to how many times it appeares in factorization.\n/// Input number\
    \ should be equal to the product of all factors\n/// >>> factorize(n: 8)\n///\
    \ [2, 2, 2]\n/// >>> factorize(n: 25)\n/// [5, 5]\n/// >>> factorize(n: 70)\n\
    /// [2, 5, 7]\nfunc factorize(n: Int) -> [Int] {\n    // TODO: implement\n   \
    \ return [2, 2, 2]\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) ->\
    \ Bool {\n    if left.count != right.count {\n        return false\n    }\n  \
    \  for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(factorize(n: 2) ==\
    \ [2])\nassert(factorize(n: 4) == [2, 2])\nassert(factorize(n: 8) == [2, 2, 2])\n\
    assert(factorize(n: 57) == [3, 19])\nassert(factorize(n: 3249) == [3, 3, 19, 19])\n\
    assert(factorize(n: 185193) == [3, 3, 3, 19, 19, 19])\nassert(factorize(n: 20577)\
    \ == [3, 19, 19, 19])\nassert(factorize(n: 18) == [2, 3, 3])"
  status: Exception
  stderr: 'tmptwrfdh6u/tmptwrfdh6u.swift:29: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b076282ec80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b0762525b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b0762525988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b07625247b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmptwrfdh6u                        0x000055b0bd544372 <unavailable> + 4978

    5    libc.so.6                          0x00002b0762a1a460 __libc_start_main +
    245

    6    tmptwrfdh6u                        0x000055b0bd543fc9 <unavailable> + 4041

    '
  stdout: ''
  timestamp: 1660009193
- exit_code: 0
  program: "\n/// Return array of prime factors of given integer in the order from\
    \ smallest to largest.\n/// Each of the factors should be arrayed number of times\
    \ corresponding to how many times it appeares in factorization.\n/// Input number\
    \ should be equal to the product of all factors\n/// >>> factorize(n: 8)\n///\
    \ [2, 2, 2]\n/// >>> factorize(n: 25)\n/// [5, 5]\n/// >>> factorize(n: 70)\n\
    /// [2, 5, 7]\nfunc factorize(n: Int) -> [Int] {\n    var d = 2\n    var m = n\n\
    \    var factors = [Int]()\n    while m > 1 {\n        while m % d == 0 {\n  \
    \          factors.append(d)\n            m /= d\n        }\n        d += 1\n\
    \    }\n    return factors\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(factorize(n:\
    \ 2) == [2])\nassert(factorize(n: 4) == [2, 2])\nassert(factorize(n: 8) == [2,\
    \ 2, 2])\nassert(factorize(n: 57) == [3, 19])\nassert(factorize(n: 3249) == [3,\
    \ 3, 19, 19])\nassert(factorize(n: 185193) == [3, 3, 3, 19, 19, 19])\nassert(factorize(n:\
    \ 20577) == [3, 19, 19, 19])\nassert(factorize(n: 18) == [2, 3, 3])"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660009193
- exit_code: -4
  program: "\n/// Return array of prime factors of given integer in the order from\
    \ smallest to largest.\n/// Each of the factors should be arrayed number of times\
    \ corresponding to how many times it appeares in factorization.\n/// Input number\
    \ should be equal to the product of all factors\n/// >>> factorize(n: 8)\n///\
    \ [2, 2, 2]\n/// >>> factorize(n: 25)\n/// [5, 5]\n/// >>> factorize(n: 70)\n\
    /// [2, 5, 7]\nfunc factorize(n: Int) -> [Int] {\n    return []\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(factorize(n: 2) == [2])\nassert(factorize(n: 4) == [2,\
    \ 2])\nassert(factorize(n: 8) == [2, 2, 2])\nassert(factorize(n: 57) == [3, 19])\n\
    assert(factorize(n: 3249) == [3, 3, 19, 19])\nassert(factorize(n: 185193) == [3,\
    \ 3, 3, 19, 19, 19])\nassert(factorize(n: 20577) == [3, 19, 19, 19])\nassert(factorize(n:\
    \ 18) == [2, 3, 3])"
  status: Exception
  stderr: 'tmpr8thvm9v/tmpr8thvm9v.swift:28: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b2608809c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b2608500b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b2608500988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b26084ff7b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpr8thvm9v                        0x0000555618631372 <unavailable> + 4978

    5    libc.so.6                          0x00002b26089f5460 __libc_start_main +
    245

    6    tmpr8thvm9v                        0x0000555618630fc9 <unavailable> + 4041

    '
  stdout: ''
  timestamp: 1660009191
- exit_code: 0
  program: "\n/// Return array of prime factors of given integer in the order from\
    \ smallest to largest.\n/// Each of the factors should be arrayed number of times\
    \ corresponding to how many times it appeares in factorization.\n/// Input number\
    \ should be equal to the product of all factors\n/// >>> factorize(n: 8)\n///\
    \ [2, 2, 2]\n/// >>> factorize(n: 25)\n/// [5, 5]\n/// >>> factorize(n: 70)\n\
    /// [2, 5, 7]\nfunc factorize(n: Int) -> [Int] {\n    var n = n\n    var factors\
    \ = [Int]()\n    var divisor = 2\n    while divisor * divisor <= n {\n       \
    \ while n % divisor == 0 {\n            factors.append(divisor)\n            n\
    \ /= divisor\n        }\n        divisor += 1\n    }\n    if n > 1 {\n       \
    \ factors.append(n)\n    }\n    return factors\n}\n\n\nfunc ==(left: [(Int, Int)],\
    \ right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n       \
    \ return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r\
    \ {\n            return false\n        }\n    }\n    return true\n}\n        \
    \    \nassert(factorize(n: 2) == [2])\nassert(factorize(n: 4) == [2, 2])\nassert(factorize(n:\
    \ 8) == [2, 2, 2])\nassert(factorize(n: 57) == [3, 19])\nassert(factorize(n: 3249)\
    \ == [3, 3, 19, 19])\nassert(factorize(n: 185193) == [3, 3, 3, 19, 19, 19])\n\
    assert(factorize(n: 20577) == [3, 19, 19, 19])\nassert(factorize(n: 18) == [2,\
    \ 3, 3])"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660009193
- exit_code: 0
  program: "\n/// Return array of prime factors of given integer in the order from\
    \ smallest to largest.\n/// Each of the factors should be arrayed number of times\
    \ corresponding to how many times it appeares in factorization.\n/// Input number\
    \ should be equal to the product of all factors\n/// >>> factorize(n: 8)\n///\
    \ [2, 2, 2]\n/// >>> factorize(n: 25)\n/// [5, 5]\n/// >>> factorize(n: 70)\n\
    /// [2, 5, 7]\nfunc factorize(n: Int) -> [Int] {\n  var result = [Int]()\n  var\
    \ remainder = n\n  var i = 2\n  while remainder > 1 {\n    while (remainder %\
    \ i) == 0 {\n      result.append(i)\n      remainder /= i\n    }\n    i += 1\n\
    \  }\n  return result\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(factorize(n:\
    \ 2) == [2])\nassert(factorize(n: 4) == [2, 2])\nassert(factorize(n: 8) == [2,\
    \ 2, 2])\nassert(factorize(n: 57) == [3, 19])\nassert(factorize(n: 3249) == [3,\
    \ 3, 19, 19])\nassert(factorize(n: 185193) == [3, 3, 3, 19, 19, 19])\nassert(factorize(n:\
    \ 20577) == [3, 19, 19, 19])\nassert(factorize(n: 18) == [2, 3, 3])"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660009193
- exit_code: 1
  program: "\n/// Return array of prime factors of given integer in the order from\
    \ smallest to largest.\n/// Each of the factors should be arrayed number of times\
    \ corresponding to how many times it appeares in factorization.\n/// Input number\
    \ should be equal to the product of all factors\n/// >>> factorize(n: 8)\n///\
    \ [2, 2, 2]\n/// >>> factorize(n: 25)\n/// [5, 5]\n/// >>> factorize(n: 70)\n\
    /// [2, 5, 7]\nfunc factorize(n: Int) -> [Int] {\n    var factorList: [Int] =\
    \ []\n    var n = n\n    while n % 2 == 0 {\n        factorList.append(2)\n  \
    \      n /= 2\n    }\n    var factor = 3\n    while Double(factor) <= sqrt(Double(n))\
    \ {\n        while n % factor == 0 {\n            factorList.append(factor)\n\
    \            n /= factor\n        }\n        factor += 2\n    }\n    if n > 2\
    \ {\n        factorList.append(n)\n    }\n    return factorList\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(factorize(n: 2) == [2])\nassert(factorize(n: 4) == [2,\
    \ 2])\nassert(factorize(n: 8) == [2, 2, 2])\nassert(factorize(n: 57) == [3, 19])\n\
    assert(factorize(n: 3249) == [3, 3, 19, 19])\nassert(factorize(n: 185193) == [3,\
    \ 3, 3, 19, 19, 19])\nassert(factorize(n: 20577) == [3, 19, 19, 19])\nassert(factorize(n:\
    \ 18) == [2, 3, 3])"
  status: SyntaxError
  stderr: "/tmp/tmp4s8iaz2w.swift:19:29: error: cannot find 'sqrt' in scope\n    while\
    \ Double(factor) <= sqrt(Double(n)) {\n                            ^~~~\n"
  stdout: ''
  timestamp: 1660009193
- exit_code: 0
  program: "\n/// Return array of prime factors of given integer in the order from\
    \ smallest to largest.\n/// Each of the factors should be arrayed number of times\
    \ corresponding to how many times it appeares in factorization.\n/// Input number\
    \ should be equal to the product of all factors\n/// >>> factorize(n: 8)\n///\
    \ [2, 2, 2]\n/// >>> factorize(n: 25)\n/// [5, 5]\n/// >>> factorize(n: 70)\n\
    /// [2, 5, 7]\nfunc factorize(n: Int) -> [Int] {\n    var factors = [Int]()\n\
    \    var current = n\n    var factor = 2\n    while current > 1 {\n        while\
    \ current % factor == 0 {\n            factors.append(factor)\n            current\
    \ /= factor\n        }\n        factor += 1\n    }\n    return factors\n}\n\n\n\
    func ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(factorize(n: 2) == [2])\nassert(factorize(n: 4)\
    \ == [2, 2])\nassert(factorize(n: 8) == [2, 2, 2])\nassert(factorize(n: 57) ==\
    \ [3, 19])\nassert(factorize(n: 3249) == [3, 3, 19, 19])\nassert(factorize(n:\
    \ 185193) == [3, 3, 3, 19, 19, 19])\nassert(factorize(n: 20577) == [3, 19, 19,\
    \ 19])\nassert(factorize(n: 18) == [2, 3, 3])"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660009193
- exit_code: 0
  program: "\n/// Return array of prime factors of given integer in the order from\
    \ smallest to largest.\n/// Each of the factors should be arrayed number of times\
    \ corresponding to how many times it appeares in factorization.\n/// Input number\
    \ should be equal to the product of all factors\n/// >>> factorize(n: 8)\n///\
    \ [2, 2, 2]\n/// >>> factorize(n: 25)\n/// [5, 5]\n/// >>> factorize(n: 70)\n\
    /// [2, 5, 7]\nfunc factorize(n: Int) -> [Int] {\n    var factors: [Int] = []\n\
    \    var remainder = n\n    for index in 2...remainder {\n        while remainder\
    \ % index == 0 {\n            factors.append(index)\n            remainder /=\
    \ index\n        }\n    }\n    return factors\n}\n\n\nfunc ==(left: [(Int, Int)],\
    \ right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n       \
    \ return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r\
    \ {\n            return false\n        }\n    }\n    return true\n}\n        \
    \    \nassert(factorize(n: 2) == [2])\nassert(factorize(n: 4) == [2, 2])\nassert(factorize(n:\
    \ 8) == [2, 2, 2])\nassert(factorize(n: 57) == [3, 19])\nassert(factorize(n: 3249)\
    \ == [3, 3, 19, 19])\nassert(factorize(n: 185193) == [3, 3, 3, 19, 19, 19])\n\
    assert(factorize(n: 20577) == [3, 19, 19, 19])\nassert(factorize(n: 18) == [2,\
    \ 3, 3])"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660009193
- exit_code: 1
  program: "\n/// Return array of prime factors of given integer in the order from\
    \ smallest to largest.\n/// Each of the factors should be arrayed number of times\
    \ corresponding to how many times it appeares in factorization.\n/// Input number\
    \ should be equal to the product of all factors\n/// >>> factorize(n: 8)\n///\
    \ [2, 2, 2]\n/// >>> factorize(n: 25)\n/// [5, 5]\n/// >>> factorize(n: 70)\n\
    /// [2, 5, 7]\nfunc factorize(n: Int) -> [Int] {\n    \n    var result = [Int]()\n\
    \    var number = n\n    \n    for i in 2...n {\n        if isPrime(num: i) {\n\
    \            while number % i == 0 {\n                result.append(i)\n     \
    \           number /= i\n            }\n        }\n    }\n    \n    return result\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(factorize(n: 2) == [2])\nassert(factorize(n: 4)\
    \ == [2, 2])\nassert(factorize(n: 8) == [2, 2, 2])\nassert(factorize(n: 57) ==\
    \ [3, 19])\nassert(factorize(n: 3249) == [3, 3, 19, 19])\nassert(factorize(n:\
    \ 185193) == [3, 3, 3, 19, 19, 19])\nassert(factorize(n: 20577) == [3, 19, 19,\
    \ 19])\nassert(factorize(n: 18) == [2, 3, 3])"
  status: SyntaxError
  stderr: "/tmp/tmpyyjuc_kz.swift:17:12: error: cannot find 'isPrime' in scope\n \
    \       if isPrime(num: i) {\n           ^~~~~~~\n"
  stdout: ''
  timestamp: 1660009193
- exit_code: 0
  program: "\n/// Return array of prime factors of given integer in the order from\
    \ smallest to largest.\n/// Each of the factors should be arrayed number of times\
    \ corresponding to how many times it appeares in factorization.\n/// Input number\
    \ should be equal to the product of all factors\n/// >>> factorize(n: 8)\n///\
    \ [2, 2, 2]\n/// >>> factorize(n: 25)\n/// [5, 5]\n/// >>> factorize(n: 70)\n\
    /// [2, 5, 7]\nfunc factorize(n: Int) -> [Int] {\n    var primeFactors = [Int]()\n\
    \    var remainder = n\n    var factor = 2\n    while remainder > 1 {\n      \
    \  while remainder % factor == 0 {\n            primeFactors.append(factor)\n\
    \            remainder /= factor\n        }\n        factor += 1\n    }\n    return\
    \ primeFactors\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool\
    \ {\n    if left.count != right.count {\n        return false\n    }\n    for\
    \ (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(factorize(n: 2) ==\
    \ [2])\nassert(factorize(n: 4) == [2, 2])\nassert(factorize(n: 8) == [2, 2, 2])\n\
    assert(factorize(n: 57) == [3, 19])\nassert(factorize(n: 3249) == [3, 3, 19, 19])\n\
    assert(factorize(n: 185193) == [3, 3, 3, 19, 19, 19])\nassert(factorize(n: 20577)\
    \ == [3, 19, 19, 19])\nassert(factorize(n: 18) == [2, 3, 3])"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660009193
- exit_code: 0
  program: "\n/// Return array of prime factors of given integer in the order from\
    \ smallest to largest.\n/// Each of the factors should be arrayed number of times\
    \ corresponding to how many times it appeares in factorization.\n/// Input number\
    \ should be equal to the product of all factors\n/// >>> factorize(n: 8)\n///\
    \ [2, 2, 2]\n/// >>> factorize(n: 25)\n/// [5, 5]\n/// >>> factorize(n: 70)\n\
    /// [2, 5, 7]\nfunc factorize(n: Int) -> [Int] {\n    var n = n\n    var result\
    \ = [Int]()\n    var i = 2\n    while i * i <= n {\n        while n % i == 0 {\n\
    \            result.append(i)\n            n /= i\n        }\n        i += 1\n\
    \    }\n    if n > 1 {\n        result.append(n)\n    }\n    return result\n}\n\
    \n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(factorize(n: 2) == [2])\nassert(factorize(n: 4)\
    \ == [2, 2])\nassert(factorize(n: 8) == [2, 2, 2])\nassert(factorize(n: 57) ==\
    \ [3, 19])\nassert(factorize(n: 3249) == [3, 3, 19, 19])\nassert(factorize(n:\
    \ 185193) == [3, 3, 3, 19, 19, 19])\nassert(factorize(n: 20577) == [3, 19, 19,\
    \ 19])\nassert(factorize(n: 18) == [2, 3, 3])"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660009191
- exit_code: 0
  program: "\n/// Return array of prime factors of given integer in the order from\
    \ smallest to largest.\n/// Each of the factors should be arrayed number of times\
    \ corresponding to how many times it appeares in factorization.\n/// Input number\
    \ should be equal to the product of all factors\n/// >>> factorize(n: 8)\n///\
    \ [2, 2, 2]\n/// >>> factorize(n: 25)\n/// [5, 5]\n/// >>> factorize(n: 70)\n\
    /// [2, 5, 7]\nfunc factorize(n: Int) -> [Int] {\n    assert(n > 0)\n    var n\
    \ = n\n    var res = [Int]()\n    var i = 2\n    while n > 1 {\n        while\
    \ n % i == 0 {\n            res.append(i)\n            n /= i\n        }\n   \
    \     i += 1\n    }\n    return res\n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(factorize(n: 2) == [2])\nassert(factorize(n: 4) == [2, 2])\nassert(factorize(n:\
    \ 8) == [2, 2, 2])\nassert(factorize(n: 57) == [3, 19])\nassert(factorize(n: 3249)\
    \ == [3, 3, 19, 19])\nassert(factorize(n: 185193) == [3, 3, 3, 19, 19, 19])\n\
    assert(factorize(n: 20577) == [3, 19, 19, 19])\nassert(factorize(n: 18) == [2,\
    \ 3, 3])"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660009193
- exit_code: 0
  program: "\n/// Return array of prime factors of given integer in the order from\
    \ smallest to largest.\n/// Each of the factors should be arrayed number of times\
    \ corresponding to how many times it appeares in factorization.\n/// Input number\
    \ should be equal to the product of all factors\n/// >>> factorize(n: 8)\n///\
    \ [2, 2, 2]\n/// >>> factorize(n: 25)\n/// [5, 5]\n/// >>> factorize(n: 70)\n\
    /// [2, 5, 7]\nfunc factorize(n: Int) -> [Int] {\n    \n    if n == 1 { return\
    \ [1] }\n    \n    var factors = [Int]()\n    var number = n\n    \n    for i\
    \ in 2...n {\n        while number % i == 0 {\n            factors.append(i)\n\
    \            number /= i\n        }\n    }\n    \n    return factors\n}\n\n\n\
    func ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(factorize(n: 2) == [2])\nassert(factorize(n: 4)\
    \ == [2, 2])\nassert(factorize(n: 8) == [2, 2, 2])\nassert(factorize(n: 57) ==\
    \ [3, 19])\nassert(factorize(n: 3249) == [3, 3, 19, 19])\nassert(factorize(n:\
    \ 185193) == [3, 3, 3, 19, 19, 19])\nassert(factorize(n: 20577) == [3, 19, 19,\
    \ 19])\nassert(factorize(n: 18) == [2, 3, 3])"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660009193
- exit_code: -4
  program: "\n/// Return array of prime factors of given integer in the order from\
    \ smallest to largest.\n/// Each of the factors should be arrayed number of times\
    \ corresponding to how many times it appeares in factorization.\n/// Input number\
    \ should be equal to the product of all factors\n/// >>> factorize(n: 8)\n///\
    \ [2, 2, 2]\n/// >>> factorize(n: 25)\n/// [5, 5]\n/// >>> factorize(n: 70)\n\
    /// [2, 5, 7]\nfunc factorize(n: Int) -> [Int] {\n    var result: [Int] = []\n\
    \    var number = n\n    let divisor = 2\n    while number > 1 {\n        while\
    \ number % divisor == 0 {\n            result.append(divisor)\n            number\
    \ /= divisor\n        }\n        if number > 1 {\n            number -= 1\n  \
    \      }\n    }\n    return result\n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(factorize(n: 2) == [2])\nassert(factorize(n: 4) == [2, 2])\nassert(factorize(n:\
    \ 8) == [2, 2, 2])\nassert(factorize(n: 57) == [3, 19])\nassert(factorize(n: 3249)\
    \ == [3, 3, 19, 19])\nassert(factorize(n: 185193) == [3, 3, 3, 19, 19, 19])\n\
    assert(factorize(n: 20577) == [3, 19, 19, 19])\nassert(factorize(n: 18) == [2,\
    \ 3, 3])"
  status: Exception
  stderr: 'tmp9mgn2418/tmp9mgn2418.swift:43: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b0cfc5b5c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b0cfc2acb6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b0cfc2ac988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b0cfc2ab7b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmp9mgn2418                        0x000055d417919722 <unavailable> + 5922

    5    libc.so.6                          0x00002b0cfc7a1460 __libc_start_main +
    245

    6    tmp9mgn2418                        0x000055d4179190b9 <unavailable> + 4281

    '
  stdout: ''
  timestamp: 1660009193
- exit_code: 0
  program: "\n/// Return array of prime factors of given integer in the order from\
    \ smallest to largest.\n/// Each of the factors should be arrayed number of times\
    \ corresponding to how many times it appeares in factorization.\n/// Input number\
    \ should be equal to the product of all factors\n/// >>> factorize(n: 8)\n///\
    \ [2, 2, 2]\n/// >>> factorize(n: 25)\n/// [5, 5]\n/// >>> factorize(n: 70)\n\
    /// [2, 5, 7]\nfunc factorize(n: Int) -> [Int] {\n    var result: [Int] = []\n\
    \    var x = n\n    var factor = 2\n    while x > 1 {\n        if x % factor ==\
    \ 0 {\n            result.append(factor)\n            x /= factor\n        } else\
    \ {\n            factor += 1\n        }\n    }\n    return result\n}\n\n\nfunc\
    \ ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count !=\
    \ right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(factorize(n: 2) == [2])\nassert(factorize(n: 4)\
    \ == [2, 2])\nassert(factorize(n: 8) == [2, 2, 2])\nassert(factorize(n: 57) ==\
    \ [3, 19])\nassert(factorize(n: 3249) == [3, 3, 19, 19])\nassert(factorize(n:\
    \ 185193) == [3, 3, 3, 19, 19, 19])\nassert(factorize(n: 20577) == [3, 19, 19,\
    \ 19])\nassert(factorize(n: 18) == [2, 3, 3])"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660009193
- exit_code: 0
  program: "\n/// Return array of prime factors of given integer in the order from\
    \ smallest to largest.\n/// Each of the factors should be arrayed number of times\
    \ corresponding to how many times it appeares in factorization.\n/// Input number\
    \ should be equal to the product of all factors\n/// >>> factorize(n: 8)\n///\
    \ [2, 2, 2]\n/// >>> factorize(n: 25)\n/// [5, 5]\n/// >>> factorize(n: 70)\n\
    /// [2, 5, 7]\nfunc factorize(n: Int) -> [Int] {\n    var n = n\n    var res =\
    \ [Int]()\n    var divisor = 2\n    while divisor * divisor <= n {\n        while\
    \ n % divisor == 0 {\n            res.append(divisor)\n            n /= divisor\n\
    \        }\n        divisor += 1\n    }\n    if n > 1 {\n        res.append(n)\n\
    \    }\n    return res\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(factorize(n:\
    \ 2) == [2])\nassert(factorize(n: 4) == [2, 2])\nassert(factorize(n: 8) == [2,\
    \ 2, 2])\nassert(factorize(n: 57) == [3, 19])\nassert(factorize(n: 3249) == [3,\
    \ 3, 19, 19])\nassert(factorize(n: 185193) == [3, 3, 3, 19, 19, 19])\nassert(factorize(n:\
    \ 20577) == [3, 19, 19, 19])\nassert(factorize(n: 18) == [2, 3, 3])"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660009193
- exit_code: -4
  program: "\n/// Return array of prime factors of given integer in the order from\
    \ smallest to largest.\n/// Each of the factors should be arrayed number of times\
    \ corresponding to how many times it appeares in factorization.\n/// Input number\
    \ should be equal to the product of all factors\n/// >>> factorize(n: 8)\n///\
    \ [2, 2, 2]\n/// >>> factorize(n: 25)\n/// [5, 5]\n/// >>> factorize(n: 70)\n\
    /// [2, 5, 7]\nfunc factorize(n: Int) -> [Int] {\n    return []\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(factorize(n: 2) == [2])\nassert(factorize(n: 4) == [2,\
    \ 2])\nassert(factorize(n: 8) == [2, 2, 2])\nassert(factorize(n: 57) == [3, 19])\n\
    assert(factorize(n: 3249) == [3, 3, 19, 19])\nassert(factorize(n: 185193) == [3,\
    \ 3, 3, 19, 19, 19])\nassert(factorize(n: 20577) == [3, 19, 19, 19])\nassert(factorize(n:\
    \ 18) == [2, 3, 3])"
  status: Exception
  stderr: 'tmpr8thvm9v/tmpr8thvm9v.swift:28: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b2608809c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b2608500b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b2608500988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b26084ff7b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpr8thvm9v                        0x0000555618631372 <unavailable> + 4978

    5    libc.so.6                          0x00002b26089f5460 __libc_start_main +
    245

    6    tmpr8thvm9v                        0x0000555618630fc9 <unavailable> + 4041

    '
  stdout: ''
  timestamp: 1660009191
- exit_code: 0
  program: "\n/// Return array of prime factors of given integer in the order from\
    \ smallest to largest.\n/// Each of the factors should be arrayed number of times\
    \ corresponding to how many times it appeares in factorization.\n/// Input number\
    \ should be equal to the product of all factors\n/// >>> factorize(n: 8)\n///\
    \ [2, 2, 2]\n/// >>> factorize(n: 25)\n/// [5, 5]\n/// >>> factorize(n: 70)\n\
    /// [2, 5, 7]\nfunc factorize(n: Int) -> [Int] {\n    var primeFactors = [Int]()\n\
    \    var number = n\n    for divider in 2...n {\n        while number % divider\
    \ == 0 {\n            primeFactors.append(divider)\n            number /= divider\n\
    \        }\n    }\n    return primeFactors\n}\n\n\nfunc ==(left: [(Int, Int)],\
    \ right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n       \
    \ return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r\
    \ {\n            return false\n        }\n    }\n    return true\n}\n        \
    \    \nassert(factorize(n: 2) == [2])\nassert(factorize(n: 4) == [2, 2])\nassert(factorize(n:\
    \ 8) == [2, 2, 2])\nassert(factorize(n: 57) == [3, 19])\nassert(factorize(n: 3249)\
    \ == [3, 3, 19, 19])\nassert(factorize(n: 185193) == [3, 3, 3, 19, 19, 19])\n\
    assert(factorize(n: 20577) == [3, 19, 19, 19])\nassert(factorize(n: 18) == [2,\
    \ 3, 3])"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660009193
- exit_code: 0
  program: "\n/// Return array of prime factors of given integer in the order from\
    \ smallest to largest.\n/// Each of the factors should be arrayed number of times\
    \ corresponding to how many times it appeares in factorization.\n/// Input number\
    \ should be equal to the product of all factors\n/// >>> factorize(n: 8)\n///\
    \ [2, 2, 2]\n/// >>> factorize(n: 25)\n/// [5, 5]\n/// >>> factorize(n: 70)\n\
    /// [2, 5, 7]\nfunc factorize(n: Int) -> [Int] {\n    var result: [Int] = []\n\
    \    if n == 1 {\n        return [1]\n    }\n    if n <= 0 {\n        return []\n\
    \    }\n    var varN = n\n    while varN > 1 {\n        for i in 2...varN {\n\
    \            if varN % i == 0 {\n                result.append(i)\n          \
    \      varN /= i\n                break\n            }\n        }\n    }\n   \
    \ return result\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool\
    \ {\n    if left.count != right.count {\n        return false\n    }\n    for\
    \ (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(factorize(n: 2) ==\
    \ [2])\nassert(factorize(n: 4) == [2, 2])\nassert(factorize(n: 8) == [2, 2, 2])\n\
    assert(factorize(n: 57) == [3, 19])\nassert(factorize(n: 3249) == [3, 3, 19, 19])\n\
    assert(factorize(n: 185193) == [3, 3, 3, 19, 19, 19])\nassert(factorize(n: 20577)\
    \ == [3, 19, 19, 19])\nassert(factorize(n: 18) == [2, 3, 3])"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660009193
- exit_code: 0
  program: "\n/// Return array of prime factors of given integer in the order from\
    \ smallest to largest.\n/// Each of the factors should be arrayed number of times\
    \ corresponding to how many times it appeares in factorization.\n/// Input number\
    \ should be equal to the product of all factors\n/// >>> factorize(n: 8)\n///\
    \ [2, 2, 2]\n/// >>> factorize(n: 25)\n/// [5, 5]\n/// >>> factorize(n: 70)\n\
    /// [2, 5, 7]\nfunc factorize(n: Int) -> [Int] {\n    var n = n\n    var factors\
    \ = [Int]()\n    var i = 2\n    while i * i <= n {\n        if n % i == 0 {\n\
    \            factors.append(i)\n            n /= i\n        } else {\n       \
    \     i += 1\n        }\n    }\n    if n > 1 {\n        factors.append(n)\n  \
    \  }\n    return factors\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(factorize(n:\
    \ 2) == [2])\nassert(factorize(n: 4) == [2, 2])\nassert(factorize(n: 8) == [2,\
    \ 2, 2])\nassert(factorize(n: 57) == [3, 19])\nassert(factorize(n: 3249) == [3,\
    \ 3, 19, 19])\nassert(factorize(n: 185193) == [3, 3, 3, 19, 19, 19])\nassert(factorize(n:\
    \ 20577) == [3, 19, 19, 19])\nassert(factorize(n: 18) == [2, 3, 3])"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660009193
- exit_code: 0
  program: "\n/// Return array of prime factors of given integer in the order from\
    \ smallest to largest.\n/// Each of the factors should be arrayed number of times\
    \ corresponding to how many times it appeares in factorization.\n/// Input number\
    \ should be equal to the product of all factors\n/// >>> factorize(n: 8)\n///\
    \ [2, 2, 2]\n/// >>> factorize(n: 25)\n/// [5, 5]\n/// >>> factorize(n: 70)\n\
    /// [2, 5, 7]\nfunc factorize(n: Int) -> [Int] {\n    var k = n\n    var divider\
    \ = 2\n    var result: [Int] = []\n    while k > 1 {\n        if k % divider ==\
    \ 0 {\n            result.append(divider)\n            k /= divider\n        }\
    \ else {\n            divider += 1\n        }\n    }\n    return result\n}\n\n\
    \nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(factorize(n: 2) == [2])\nassert(factorize(n: 4)\
    \ == [2, 2])\nassert(factorize(n: 8) == [2, 2, 2])\nassert(factorize(n: 57) ==\
    \ [3, 19])\nassert(factorize(n: 3249) == [3, 3, 19, 19])\nassert(factorize(n:\
    \ 185193) == [3, 3, 3, 19, 19, 19])\nassert(factorize(n: 20577) == [3, 19, 19,\
    \ 19])\nassert(factorize(n: 18) == [2, 3, 3])"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660009193
- exit_code: 0
  program: "\n/// Return array of prime factors of given integer in the order from\
    \ smallest to largest.\n/// Each of the factors should be arrayed number of times\
    \ corresponding to how many times it appeares in factorization.\n/// Input number\
    \ should be equal to the product of all factors\n/// >>> factorize(n: 8)\n///\
    \ [2, 2, 2]\n/// >>> factorize(n: 25)\n/// [5, 5]\n/// >>> factorize(n: 70)\n\
    /// [2, 5, 7]\nfunc factorize(n: Int) -> [Int] {\n    assert(n > 0)\n    var n\
    \ = n\n    var result = [Int]()\n    var i = 2\n    while i * i <= n {\n     \
    \   if n % i == 0 {\n            result.append(i)\n            n /= i\n      \
    \  } else {\n            i += 1\n        }\n    }\n    if n > 1 {\n        result.append(n)\n\
    \    }\n    return result\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(factorize(n:\
    \ 2) == [2])\nassert(factorize(n: 4) == [2, 2])\nassert(factorize(n: 8) == [2,\
    \ 2, 2])\nassert(factorize(n: 57) == [3, 19])\nassert(factorize(n: 3249) == [3,\
    \ 3, 19, 19])\nassert(factorize(n: 185193) == [3, 3, 3, 19, 19, 19])\nassert(factorize(n:\
    \ 20577) == [3, 19, 19, 19])\nassert(factorize(n: 18) == [2, 3, 3])"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660009193
- exit_code: 0
  program: "\n/// Return array of prime factors of given integer in the order from\
    \ smallest to largest.\n/// Each of the factors should be arrayed number of times\
    \ corresponding to how many times it appeares in factorization.\n/// Input number\
    \ should be equal to the product of all factors\n/// >>> factorize(n: 8)\n///\
    \ [2, 2, 2]\n/// >>> factorize(n: 25)\n/// [5, 5]\n/// >>> factorize(n: 70)\n\
    /// [2, 5, 7]\nfunc factorize(n: Int) -> [Int] {\n    var n = n\n    var factors\
    \ = [Int]()\n    var f = 2\n    while n > 1 {\n        while n % f == 0 {\n  \
    \          factors.append(f)\n            n /= f\n        }\n        f += 1\n\
    \    }\n    return factors\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(factorize(n:\
    \ 2) == [2])\nassert(factorize(n: 4) == [2, 2])\nassert(factorize(n: 8) == [2,\
    \ 2, 2])\nassert(factorize(n: 57) == [3, 19])\nassert(factorize(n: 3249) == [3,\
    \ 3, 19, 19])\nassert(factorize(n: 185193) == [3, 3, 3, 19, 19, 19])\nassert(factorize(n:\
    \ 20577) == [3, 19, 19, 19])\nassert(factorize(n: 18) == [2, 3, 3])"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660009193
- exit_code: -4
  program: "\n/// Return array of prime factors of given integer in the order from\
    \ smallest to largest.\n/// Each of the factors should be arrayed number of times\
    \ corresponding to how many times it appeares in factorization.\n/// Input number\
    \ should be equal to the product of all factors\n/// >>> factorize(n: 8)\n///\
    \ [2, 2, 2]\n/// >>> factorize(n: 25)\n/// [5, 5]\n/// >>> factorize(n: 70)\n\
    /// [2, 5, 7]\nfunc factorize(n: Int) -> [Int] {\n    var factors = [Int]()\n\
    \    var newN = n\n    for i in 2...n/2{\n        if newN % i == 0{\n        \
    \    factors.append(i)\n            newN = newN / i\n            print(i)\n  \
    \      }\n    }\n    return factors\n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(factorize(n: 2) == [2])\nassert(factorize(n: 4) == [2, 2])\nassert(factorize(n:\
    \ 8) == [2, 2, 2])\nassert(factorize(n: 57) == [3, 19])\nassert(factorize(n: 3249)\
    \ == [3, 3, 19, 19])\nassert(factorize(n: 185193) == [3, 3, 3, 19, 19, 19])\n\
    assert(factorize(n: 20577) == [3, 19, 19, 19])\nassert(factorize(n: 18) == [2,\
    \ 3, 3])"
  status: Exception
  stderr: 'Swift/ClosedRange.swift:347: Fatal error: Range requires lowerBound <=
    upperBound

    Current stack trace:

    0    libswiftCore.so                    0x00002afb6202fc80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002afb61d26561 <unavailable> + 1434977

    2    libswiftCore.so                    0x00002afb61d26286 <unavailable> + 1434246

    3    libswiftCore.so                    0x00002afb61d2613c <unavailable> + 1433916

    4    libswiftCore.so                    0x00002afb61d25bb0 _assertionFailure(_:_:file:line:flags:)
    + 251

    5    tmp77g02mvg                        0x0000561cc241901b <unavailable> + 8219

    6    tmp77g02mvg                        0x0000561cc241868b <unavailable> + 5771

    7    libc.so.6                          0x00002afb6221b460 __libc_start_main +
    245

    8    tmp77g02mvg                        0x0000561cc24183a9 <unavailable> + 5033

    '
  stdout: ''
  timestamp: 1660009193
- exit_code: 0
  program: "\n/// Return array of prime factors of given integer in the order from\
    \ smallest to largest.\n/// Each of the factors should be arrayed number of times\
    \ corresponding to how many times it appeares in factorization.\n/// Input number\
    \ should be equal to the product of all factors\n/// >>> factorize(n: 8)\n///\
    \ [2, 2, 2]\n/// >>> factorize(n: 25)\n/// [5, 5]\n/// >>> factorize(n: 70)\n\
    /// [2, 5, 7]\nfunc factorize(n: Int) -> [Int] {\n    var res = [Int]()\n    var\
    \ num = n\n    var div = 2\n    while num > 1 {\n        while num % div == 0\
    \ {\n            res.append(div)\n            num /= div\n        }\n        div\
    \ += 1\n    }\n    return res\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int,\
    \ Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n\
    \    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n          \
    \  return false\n        }\n    }\n    return true\n}\n            \nassert(factorize(n:\
    \ 2) == [2])\nassert(factorize(n: 4) == [2, 2])\nassert(factorize(n: 8) == [2,\
    \ 2, 2])\nassert(factorize(n: 57) == [3, 19])\nassert(factorize(n: 3249) == [3,\
    \ 3, 19, 19])\nassert(factorize(n: 185193) == [3, 3, 3, 19, 19, 19])\nassert(factorize(n:\
    \ 20577) == [3, 19, 19, 19])\nassert(factorize(n: 18) == [2, 3, 3])"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660009193
- exit_code: 0
  program: "\n/// Return array of prime factors of given integer in the order from\
    \ smallest to largest.\n/// Each of the factors should be arrayed number of times\
    \ corresponding to how many times it appeares in factorization.\n/// Input number\
    \ should be equal to the product of all factors\n/// >>> factorize(n: 8)\n///\
    \ [2, 2, 2]\n/// >>> factorize(n: 25)\n/// [5, 5]\n/// >>> factorize(n: 70)\n\
    /// [2, 5, 7]\nfunc factorize(n: Int) -> [Int] {\n    var number = n\n    var\
    \ primeNumbers = [Int]()\n    var tmp = [Int]()\n    var i = 2\n    while i *\
    \ i <= number {\n        if number % i == 0 {\n            number /= i\n     \
    \       tmp.append(i)\n        } else {\n            i += 1\n        }\n    }\n\
    \    if number > 1 {\n        tmp.append(number)\n    }\n    var count = 1\n \
    \   var tmp2 = tmp[0]\n    for i in 1..<tmp.count {\n        if tmp[i] == tmp2\
    \ {\n            count += 1\n        } else {\n            primeNumbers.append(contentsOf:\
    \ Array(repeating: tmp2, count: count))\n            tmp2 = tmp[i]\n         \
    \   count = 1\n        }\n    }\n    primeNumbers.append(contentsOf: Array(repeating:\
    \ tmp2, count: count))\n    return primeNumbers\n}\n\n\nfunc ==(left: [(Int, Int)],\
    \ right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n       \
    \ return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r\
    \ {\n            return false\n        }\n    }\n    return true\n}\n        \
    \    \nassert(factorize(n: 2) == [2])\nassert(factorize(n: 4) == [2, 2])\nassert(factorize(n:\
    \ 8) == [2, 2, 2])\nassert(factorize(n: 57) == [3, 19])\nassert(factorize(n: 3249)\
    \ == [3, 3, 19, 19])\nassert(factorize(n: 185193) == [3, 3, 3, 19, 19, 19])\n\
    assert(factorize(n: 20577) == [3, 19, 19, 19])\nassert(factorize(n: 18) == [2,\
    \ 3, 3])"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660009193
- exit_code: 0
  program: "\n/// Return array of prime factors of given integer in the order from\
    \ smallest to largest.\n/// Each of the factors should be arrayed number of times\
    \ corresponding to how many times it appeares in factorization.\n/// Input number\
    \ should be equal to the product of all factors\n/// >>> factorize(n: 8)\n///\
    \ [2, 2, 2]\n/// >>> factorize(n: 25)\n/// [5, 5]\n/// >>> factorize(n: 70)\n\
    /// [2, 5, 7]\nfunc factorize(n: Int) -> [Int] {\n    var arr = [Int]()\n    var\
    \ number = n\n    var i = 2\n    while number > 1 {\n        if number % i ==\
    \ 0 {\n            arr.append(i)\n            number /= i\n        } else {\n\
    \            i += 1\n        }\n    }\n    return arr\n}\n\n\nfunc ==(left: [(Int,\
    \ Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n\
    \        return false\n    }\n    for (l, r) in zip(left, right) {\n        if\
    \ l != r {\n            return false\n        }\n    }\n    return true\n}\n \
    \           \nassert(factorize(n: 2) == [2])\nassert(factorize(n: 4) == [2, 2])\n\
    assert(factorize(n: 8) == [2, 2, 2])\nassert(factorize(n: 57) == [3, 19])\nassert(factorize(n:\
    \ 3249) == [3, 3, 19, 19])\nassert(factorize(n: 185193) == [3, 3, 3, 19, 19, 19])\n\
    assert(factorize(n: 20577) == [3, 19, 19, 19])\nassert(factorize(n: 18) == [2,\
    \ 3, 3])"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660009193
- exit_code: 1
  program: "\n/// Return array of prime factors of given integer in the order from\
    \ smallest to largest.\n/// Each of the factors should be arrayed number of times\
    \ corresponding to how many times it appeares in factorization.\n/// Input number\
    \ should be equal to the product of all factors\n/// >>> factorize(n: 8)\n///\
    \ [2, 2, 2]\n/// >>> factorize(n: 25)\n/// [5, 5]\n/// >>> factorize(n: 70)\n\
    /// [2, 5, 7]\nfunc factorize(n: Int) -> [Int] {\n    return Factorization(of:\
    \ n).factors.sorted()\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(factorize(n:\
    \ 2) == [2])\nassert(factorize(n: 4) == [2, 2])\nassert(factorize(n: 8) == [2,\
    \ 2, 2])\nassert(factorize(n: 57) == [3, 19])\nassert(factorize(n: 3249) == [3,\
    \ 3, 19, 19])\nassert(factorize(n: 185193) == [3, 3, 3, 19, 19, 19])\nassert(factorize(n:\
    \ 20577) == [3, 19, 19, 19])\nassert(factorize(n: 18) == [2, 3, 3])"
  status: SyntaxError
  stderr: "/tmp/tmpjqk31m9o.swift:12:12: error: cannot find 'Factorization' in scope\n\
    \    return Factorization(of: n).factors.sorted()\n           ^~~~~~~~~~~~~\n"
  stdout: ''
  timestamp: 1660009193
- exit_code: 0
  program: "\n/// Return array of prime factors of given integer in the order from\
    \ smallest to largest.\n/// Each of the factors should be arrayed number of times\
    \ corresponding to how many times it appeares in factorization.\n/// Input number\
    \ should be equal to the product of all factors\n/// >>> factorize(n: 8)\n///\
    \ [2, 2, 2]\n/// >>> factorize(n: 25)\n/// [5, 5]\n/// >>> factorize(n: 70)\n\
    /// [2, 5, 7]\nfunc factorize(n: Int) -> [Int] {\n    var primes: [Int] = []\n\
    \    var d: Int = 2\n    var m: Int = n\n    while m > 1 {\n        if m % d ==\
    \ 0 {\n            primes.append(d)\n            m /= d\n        } else {\n  \
    \          d += 1\n        }\n    }\n    return primes\n}\n\n\nfunc ==(left: [(Int,\
    \ Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n\
    \        return false\n    }\n    for (l, r) in zip(left, right) {\n        if\
    \ l != r {\n            return false\n        }\n    }\n    return true\n}\n \
    \           \nassert(factorize(n: 2) == [2])\nassert(factorize(n: 4) == [2, 2])\n\
    assert(factorize(n: 8) == [2, 2, 2])\nassert(factorize(n: 57) == [3, 19])\nassert(factorize(n:\
    \ 3249) == [3, 3, 19, 19])\nassert(factorize(n: 185193) == [3, 3, 3, 19, 19, 19])\n\
    assert(factorize(n: 20577) == [3, 19, 19, 19])\nassert(factorize(n: 18) == [2,\
    \ 3, 3])"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660009193
- exit_code: 0
  program: "\n/// Return array of prime factors of given integer in the order from\
    \ smallest to largest.\n/// Each of the factors should be arrayed number of times\
    \ corresponding to how many times it appeares in factorization.\n/// Input number\
    \ should be equal to the product of all factors\n/// >>> factorize(n: 8)\n///\
    \ [2, 2, 2]\n/// >>> factorize(n: 25)\n/// [5, 5]\n/// >>> factorize(n: 70)\n\
    /// [2, 5, 7]\nfunc factorize(n: Int) -> [Int] {\n    var factors = [Int]()\n\
    \    var number = n\n    var i = 2\n    while number > 1 {\n        if number\
    \ % i == 0 {\n            factors.append(i)\n            number /= i\n       \
    \ } else {\n            i += 1\n        }\n    }\n    return factors\n}\n\n\n\
    func ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(factorize(n: 2) == [2])\nassert(factorize(n: 4)\
    \ == [2, 2])\nassert(factorize(n: 8) == [2, 2, 2])\nassert(factorize(n: 57) ==\
    \ [3, 19])\nassert(factorize(n: 3249) == [3, 3, 19, 19])\nassert(factorize(n:\
    \ 185193) == [3, 3, 3, 19, 19, 19])\nassert(factorize(n: 20577) == [3, 19, 19,\
    \ 19])\nassert(factorize(n: 18) == [2, 3, 3])"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660009193
- exit_code: 0
  program: "\n/// Return array of prime factors of given integer in the order from\
    \ smallest to largest.\n/// Each of the factors should be arrayed number of times\
    \ corresponding to how many times it appeares in factorization.\n/// Input number\
    \ should be equal to the product of all factors\n/// >>> factorize(n: 8)\n///\
    \ [2, 2, 2]\n/// >>> factorize(n: 25)\n/// [5, 5]\n/// >>> factorize(n: 70)\n\
    /// [2, 5, 7]\nfunc factorize(n: Int) -> [Int] {\n    var factors = [Int]()\n\
    \    var divided = n\n    var divisor = 2\n    while true {\n        if divided\
    \ % divisor == 0 {\n            factors.append(divisor)\n            divided /=\
    \ divisor\n        } else {\n            divisor += 1\n        }\n        if divided\
    \ == 1 {\n            break\n        }\n    }\n    return factors\n}\n\n\nfunc\
    \ ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count !=\
    \ right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(factorize(n: 2) == [2])\nassert(factorize(n: 4)\
    \ == [2, 2])\nassert(factorize(n: 8) == [2, 2, 2])\nassert(factorize(n: 57) ==\
    \ [3, 19])\nassert(factorize(n: 3249) == [3, 3, 19, 19])\nassert(factorize(n:\
    \ 185193) == [3, 3, 3, 19, 19, 19])\nassert(factorize(n: 20577) == [3, 19, 19,\
    \ 19])\nassert(factorize(n: 18) == [2, 3, 3])"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660009193
- exit_code: 0
  program: "\n/// Return array of prime factors of given integer in the order from\
    \ smallest to largest.\n/// Each of the factors should be arrayed number of times\
    \ corresponding to how many times it appeares in factorization.\n/// Input number\
    \ should be equal to the product of all factors\n/// >>> factorize(n: 8)\n///\
    \ [2, 2, 2]\n/// >>> factorize(n: 25)\n/// [5, 5]\n/// >>> factorize(n: 70)\n\
    /// [2, 5, 7]\nfunc factorize(n: Int) -> [Int] {\n    var number = n\n    var\
    \ factors = [Int]()\n    var factor = 2\n    while number > 1 {\n        while\
    \ number % factor == 0 {\n            factors.append(factor)\n            number\
    \ /= factor\n        }\n        factor += 1\n    }\n    return factors\n}\n\n\n\
    func ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(factorize(n: 2) == [2])\nassert(factorize(n: 4)\
    \ == [2, 2])\nassert(factorize(n: 8) == [2, 2, 2])\nassert(factorize(n: 57) ==\
    \ [3, 19])\nassert(factorize(n: 3249) == [3, 3, 19, 19])\nassert(factorize(n:\
    \ 185193) == [3, 3, 3, 19, 19, 19])\nassert(factorize(n: 20577) == [3, 19, 19,\
    \ 19])\nassert(factorize(n: 18) == [2, 3, 3])"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660009193
- exit_code: 0
  program: "\n/// Return array of prime factors of given integer in the order from\
    \ smallest to largest.\n/// Each of the factors should be arrayed number of times\
    \ corresponding to how many times it appeares in factorization.\n/// Input number\
    \ should be equal to the product of all factors\n/// >>> factorize(n: 8)\n///\
    \ [2, 2, 2]\n/// >>> factorize(n: 25)\n/// [5, 5]\n/// >>> factorize(n: 70)\n\
    /// [2, 5, 7]\nfunc factorize(n: Int) -> [Int] {\n    var result = [Int]()\n \
    \   var input = n\n    while input != 1 {\n        for i in 2...input {\n    \
    \        if input % i == 0 {\n                result.append(i)\n             \
    \   input /= i\n                break\n            }\n        }\n    }\n    return\
    \ result\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n\
    \    if left.count != right.count {\n        return false\n    }\n    for (l,\
    \ r) in zip(left, right) {\n        if l != r {\n            return false\n  \
    \      }\n    }\n    return true\n}\n            \nassert(factorize(n: 2) == [2])\n\
    assert(factorize(n: 4) == [2, 2])\nassert(factorize(n: 8) == [2, 2, 2])\nassert(factorize(n:\
    \ 57) == [3, 19])\nassert(factorize(n: 3249) == [3, 3, 19, 19])\nassert(factorize(n:\
    \ 185193) == [3, 3, 3, 19, 19, 19])\nassert(factorize(n: 20577) == [3, 19, 19,\
    \ 19])\nassert(factorize(n: 18) == [2, 3, 3])"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660009193
- exit_code: 0
  program: "\n/// Return array of prime factors of given integer in the order from\
    \ smallest to largest.\n/// Each of the factors should be arrayed number of times\
    \ corresponding to how many times it appeares in factorization.\n/// Input number\
    \ should be equal to the product of all factors\n/// >>> factorize(n: 8)\n///\
    \ [2, 2, 2]\n/// >>> factorize(n: 25)\n/// [5, 5]\n/// >>> factorize(n: 70)\n\
    /// [2, 5, 7]\nfunc factorize(n: Int) -> [Int] {\n    var factorization = [Int]()\n\
    \    var number = n\n    var i = 2\n    while number > 1 {\n        while number\
    \ % i == 0 {\n            factorization.append(i)\n            number /= i\n \
    \       }\n        i += 1\n    }\n    return factorization\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(factorize(n: 2) == [2])\nassert(factorize(n: 4) == [2,\
    \ 2])\nassert(factorize(n: 8) == [2, 2, 2])\nassert(factorize(n: 57) == [3, 19])\n\
    assert(factorize(n: 3249) == [3, 3, 19, 19])\nassert(factorize(n: 185193) == [3,\
    \ 3, 3, 19, 19, 19])\nassert(factorize(n: 20577) == [3, 19, 19, 19])\nassert(factorize(n:\
    \ 18) == [2, 3, 3])"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660009193
- exit_code: 0
  program: "\n/// Return array of prime factors of given integer in the order from\
    \ smallest to largest.\n/// Each of the factors should be arrayed number of times\
    \ corresponding to how many times it appeares in factorization.\n/// Input number\
    \ should be equal to the product of all factors\n/// >>> factorize(n: 8)\n///\
    \ [2, 2, 2]\n/// >>> factorize(n: 25)\n/// [5, 5]\n/// >>> factorize(n: 70)\n\
    /// [2, 5, 7]\nfunc factorize(n: Int) -> [Int] {\n    var result: [Int] = []\n\
    \    var primeNumber = 2\n    var remaining = n\n    while remaining > 1 {\n \
    \       if remaining % primeNumber == 0 {\n            result.append(primeNumber)\n\
    \            remaining /= primeNumber\n        } else {\n            primeNumber\
    \ += 1\n        }\n    }\n    return result\n}\n\n\nfunc ==(left: [(Int, Int)],\
    \ right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n       \
    \ return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r\
    \ {\n            return false\n        }\n    }\n    return true\n}\n        \
    \    \nassert(factorize(n: 2) == [2])\nassert(factorize(n: 4) == [2, 2])\nassert(factorize(n:\
    \ 8) == [2, 2, 2])\nassert(factorize(n: 57) == [3, 19])\nassert(factorize(n: 3249)\
    \ == [3, 3, 19, 19])\nassert(factorize(n: 185193) == [3, 3, 3, 19, 19, 19])\n\
    assert(factorize(n: 20577) == [3, 19, 19, 19])\nassert(factorize(n: 18) == [2,\
    \ 3, 3])"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660009193
