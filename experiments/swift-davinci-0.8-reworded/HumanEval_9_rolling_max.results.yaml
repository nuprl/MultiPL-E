language: swift
name: HumanEval_9_rolling_max
results:
- exit_code: 1
  program: "\n/// From a given array of integers, generate an array of rolling maximum\
    \ element found until given moment\n/// in the sequence.\n/// >>> rolling_max(numbers:\
    \ [1, 2, 3, 2, 3, 4, 2])\n/// [1, 2, 3, 3, 3, 4, 4]\nfunc rolling_max(numbers:\
    \ [Int]) -> [Int] {\n    var result = [Int]()\n    var max = 0\n    for number\
    \ in numbers {\n        max = max(max, number)\n        result.append(max)\n \
    \   }\n    return result\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(rolling_max(numbers:\
    \ [] as [Int]) == [] as [Int])\nassert(rolling_max(numbers: [1, 2, 3, 4]) == [1,\
    \ 2, 3, 4])\nassert(rolling_max(numbers: [4, 3, 2, 1]) == [4, 4, 4, 4])\nassert(rolling_max(numbers:\
    \ [3, 2, 3, 100, 3]) == [3, 3, 3, 100, 100])"
  status: SyntaxError
  stderr: "/tmp/tmp_qgxldda.swift:10:15: error: cannot call value of non-function\
    \ type 'Int'\n        max = max(max, number)\n              ^\n"
  stdout: ''
  timestamp: 1659979940
- exit_code: 1
  program: "\n/// From a given array of integers, generate an array of rolling maximum\
    \ element found until given moment\n/// in the sequence.\n/// >>> rolling_max(numbers:\
    \ [1, 2, 3, 2, 3, 4, 2])\n/// [1, 2, 3, 3, 3, 4, 4]\nfunc rolling_max(numbers:\
    \ [Int]) -> [Int] {\n    return rolling_max(numbers: numbers, step: 1)\n}\n\n\n\
    func ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(rolling_max(numbers: [] as [Int]) == [] as [Int])\n\
    assert(rolling_max(numbers: [1, 2, 3, 4]) == [1, 2, 3, 4])\nassert(rolling_max(numbers:\
    \ [4, 3, 2, 1]) == [4, 4, 4, 4])\nassert(rolling_max(numbers: [3, 2, 3, 100, 3])\
    \ == [3, 3, 3, 100, 100])"
  status: SyntaxError
  stderr: "/tmp/tmpn1am00jb.swift:7:48: error: extra argument 'step' in call\n   \
    \ return rolling_max(numbers: numbers, step: 1)\n                      ~~~~~~~~~~~~~~~~~~~~~~~~~^~\n"
  stdout: ''
  timestamp: 1659979940
- exit_code: 0
  program: "\n/// From a given array of integers, generate an array of rolling maximum\
    \ element found until given moment\n/// in the sequence.\n/// >>> rolling_max(numbers:\
    \ [1, 2, 3, 2, 3, 4, 2])\n/// [1, 2, 3, 3, 3, 4, 4]\nfunc rolling_max(numbers:\
    \ [Int]) -> [Int] {\n    var maxes = [Int]()\n    for (index, number) in numbers.enumerated()\
    \ {\n        var maxValue = number\n        for i in 0..<index {\n           \
    \ maxValue = max(maxValue, numbers[i])\n        }\n        maxes.append(maxValue)\n\
    \    }\n    return maxes\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(rolling_max(numbers:\
    \ [] as [Int]) == [] as [Int])\nassert(rolling_max(numbers: [1, 2, 3, 4]) == [1,\
    \ 2, 3, 4])\nassert(rolling_max(numbers: [4, 3, 2, 1]) == [4, 4, 4, 4])\nassert(rolling_max(numbers:\
    \ [3, 2, 3, 100, 3]) == [3, 3, 3, 100, 100])"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659979940
- exit_code: -4
  program: "\n/// From a given array of integers, generate an array of rolling maximum\
    \ element found until given moment\n/// in the sequence.\n/// >>> rolling_max(numbers:\
    \ [1, 2, 3, 2, 3, 4, 2])\n/// [1, 2, 3, 3, 3, 4, 4]\nfunc rolling_max(numbers:\
    \ [Int]) -> [Int] {\n    var result = [Int]()\n    var max_so_far = numbers[0]\n\
    \    result.append(max_so_far)\n    for i in 1..<numbers.count {\n        if numbers[i]\
    \ > max_so_far {\n            max_so_far = numbers[i]\n        }\n        result.append(max_so_far)\n\
    \    }\n    return result\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(rolling_max(numbers:\
    \ [] as [Int]) == [] as [Int])\nassert(rolling_max(numbers: [1, 2, 3, 4]) == [1,\
    \ 2, 3, 4])\nassert(rolling_max(numbers: [4, 3, 2, 1]) == [4, 4, 4, 4])\nassert(rolling_max(numbers:\
    \ [3, 2, 3, 100, 3]) == [3, 3, 3, 100, 100])"
  status: Exception
  stderr: 'Swift/ContiguousArrayBuffer.swift:600: Fatal error: Index out of range

    Current stack trace:

    0    libswiftCore.so                    0x00002ab19e84ec80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002ab19e545561 <unavailable> + 1434977

    2    libswiftCore.so                    0x00002ab19e545286 <unavailable> + 1434246

    3    libswiftCore.so                    0x00002ab19e54513c <unavailable> + 1433916

    4    libswiftCore.so                    0x00002ab19e544bb0 _assertionFailure(_:_:file:line:flags:)
    + 251

    5    libswiftSwiftOnoneSupport.so       0x00002ab19e344e83 <unavailable> + 188035

    6    tmpgj1zvtr4                        0x00005604c4c16ae8 <unavailable> + 6888

    7    tmpgj1zvtr4                        0x00005604c4c165ad <unavailable> + 5549

    8    libc.so.6                          0x00002ab19ea3a460 __libc_start_main +
    245

    9    tmpgj1zvtr4                        0x00005604c4c162b9 <unavailable> + 4793

    '
  stdout: ''
  timestamp: 1659979940
- exit_code: -4
  program: "\n/// From a given array of integers, generate an array of rolling maximum\
    \ element found until given moment\n/// in the sequence.\n/// >>> rolling_max(numbers:\
    \ [1, 2, 3, 2, 3, 4, 2])\n/// [1, 2, 3, 3, 3, 4, 4]\nfunc rolling_max(numbers:\
    \ [Int]) -> [Int] {\n    var max_element = numbers[0]\n    var rolling_maximum\
    \ = [Int]()\n    for (index, element) in numbers.enumerated() {\n        if index\
    \ == 0 {\n            rolling_maximum.append(element)\n        } else {\n    \
    \        max_element = max(max_element, element)\n            rolling_maximum.append(max_element)\n\
    \        }\n    }\n    return rolling_maximum\n}\n\n\nfunc ==(left: [(Int, Int)],\
    \ right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n       \
    \ return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r\
    \ {\n            return false\n        }\n    }\n    return true\n}\n        \
    \    \nassert(rolling_max(numbers: [] as [Int]) == [] as [Int])\nassert(rolling_max(numbers:\
    \ [1, 2, 3, 4]) == [1, 2, 3, 4])\nassert(rolling_max(numbers: [4, 3, 2, 1]) ==\
    \ [4, 4, 4, 4])\nassert(rolling_max(numbers: [3, 2, 3, 100, 3]) == [3, 3, 3, 100,\
    \ 100])"
  status: Exception
  stderr: 'Swift/ContiguousArrayBuffer.swift:600: Fatal error: Index out of range

    Current stack trace:

    0    libswiftCore.so                    0x00002b1c26025c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b1c25d1c561 <unavailable> + 1434977

    2    libswiftCore.so                    0x00002b1c25d1c286 <unavailable> + 1434246

    3    libswiftCore.so                    0x00002b1c25d1c13c <unavailable> + 1433916

    4    libswiftCore.so                    0x00002b1c25d1bbb0 _assertionFailure(_:_:file:line:flags:)
    + 251

    5    libswiftSwiftOnoneSupport.so       0x00002b1c25b1be83 <unavailable> + 188035

    6    tmpv_19skgs                        0x000056540d3e8ba8 <unavailable> + 7080

    7    tmpv_19skgs                        0x000056540d3e866d <unavailable> + 5741

    8    libc.so.6                          0x00002b1c26211460 __libc_start_main +
    245

    9    tmpv_19skgs                        0x000056540d3e8379 <unavailable> + 4985

    '
  stdout: ''
  timestamp: 1659979940
- exit_code: 0
  program: "\n/// From a given array of integers, generate an array of rolling maximum\
    \ element found until given moment\n/// in the sequence.\n/// >>> rolling_max(numbers:\
    \ [1, 2, 3, 2, 3, 4, 2])\n/// [1, 2, 3, 3, 3, 4, 4]\nfunc rolling_max(numbers:\
    \ [Int]) -> [Int] {\n    var rollingMax = [Int]()\n    for n in numbers {\n  \
    \      if let last = rollingMax.last {\n            rollingMax.append(max(last,\
    \ n))\n        } else {\n            rollingMax.append(n)\n        }\n    }\n\
    \    return rollingMax\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(rolling_max(numbers:\
    \ [] as [Int]) == [] as [Int])\nassert(rolling_max(numbers: [1, 2, 3, 4]) == [1,\
    \ 2, 3, 4])\nassert(rolling_max(numbers: [4, 3, 2, 1]) == [4, 4, 4, 4])\nassert(rolling_max(numbers:\
    \ [3, 2, 3, 100, 3]) == [3, 3, 3, 100, 100])"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659979940
- exit_code: 0
  program: "\n/// From a given array of integers, generate an array of rolling maximum\
    \ element found until given moment\n/// in the sequence.\n/// >>> rolling_max(numbers:\
    \ [1, 2, 3, 2, 3, 4, 2])\n/// [1, 2, 3, 3, 3, 4, 4]\nfunc rolling_max(numbers:\
    \ [Int]) -> [Int] {\n    var result = [Int]()\n    var maximum = 0\n    for i\
    \ in 0..<numbers.count {\n        maximum = max(maximum, numbers[i])\n       \
    \ result.append(maximum)\n    }\n    return result\n}\n\n\nfunc ==(left: [(Int,\
    \ Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n\
    \        return false\n    }\n    for (l, r) in zip(left, right) {\n        if\
    \ l != r {\n            return false\n        }\n    }\n    return true\n}\n \
    \           \nassert(rolling_max(numbers: [] as [Int]) == [] as [Int])\nassert(rolling_max(numbers:\
    \ [1, 2, 3, 4]) == [1, 2, 3, 4])\nassert(rolling_max(numbers: [4, 3, 2, 1]) ==\
    \ [4, 4, 4, 4])\nassert(rolling_max(numbers: [3, 2, 3, 100, 3]) == [3, 3, 3, 100,\
    \ 100])"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659979940
- exit_code: 0
  program: "\n/// From a given array of integers, generate an array of rolling maximum\
    \ element found until given moment\n/// in the sequence.\n/// >>> rolling_max(numbers:\
    \ [1, 2, 3, 2, 3, 4, 2])\n/// [1, 2, 3, 3, 3, 4, 4]\nfunc rolling_max(numbers:\
    \ [Int]) -> [Int] {\n    var ret: [Int] = []\n    var cur_max = Int.min\n    for\
    \ i in numbers {\n        if i > cur_max {\n            cur_max = i\n        }\n\
    \        ret.append(cur_max)\n    }\n    return ret\n}\n\n\nfunc ==(left: [(Int,\
    \ Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n\
    \        return false\n    }\n    for (l, r) in zip(left, right) {\n        if\
    \ l != r {\n            return false\n        }\n    }\n    return true\n}\n \
    \           \nassert(rolling_max(numbers: [] as [Int]) == [] as [Int])\nassert(rolling_max(numbers:\
    \ [1, 2, 3, 4]) == [1, 2, 3, 4])\nassert(rolling_max(numbers: [4, 3, 2, 1]) ==\
    \ [4, 4, 4, 4])\nassert(rolling_max(numbers: [3, 2, 3, 100, 3]) == [3, 3, 3, 100,\
    \ 100])"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659979940
- exit_code: -4
  program: "\n/// From a given array of integers, generate an array of rolling maximum\
    \ element found until given moment\n/// in the sequence.\n/// >>> rolling_max(numbers:\
    \ [1, 2, 3, 2, 3, 4, 2])\n/// [1, 2, 3, 3, 3, 4, 4]\nfunc rolling_max(numbers:\
    \ [Int]) -> [Int] {\n    //MARK: - Implementation\n    //MARK: -\n    var rolling_max_array\
    \ = [Int]()\n    var max = numbers[0]\n    rolling_max_array.append(max)\n   \
    \ for i in 1..<numbers.count {\n        max = max > numbers[i] ? max : numbers[i]\n\
    \        rolling_max_array.append(max)\n    }\n    return rolling_max_array\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(rolling_max(numbers: [] as [Int]) == [] as [Int])\n\
    assert(rolling_max(numbers: [1, 2, 3, 4]) == [1, 2, 3, 4])\nassert(rolling_max(numbers:\
    \ [4, 3, 2, 1]) == [4, 4, 4, 4])\nassert(rolling_max(numbers: [3, 2, 3, 100, 3])\
    \ == [3, 3, 3, 100, 100])"
  status: Exception
  stderr: 'Swift/ContiguousArrayBuffer.swift:600: Fatal error: Index out of range

    Current stack trace:

    0    libswiftCore.so                    0x00002b81e1da6c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b81e1a9d561 <unavailable> + 1434977

    2    libswiftCore.so                    0x00002b81e1a9d286 <unavailable> + 1434246

    3    libswiftCore.so                    0x00002b81e1a9d13c <unavailable> + 1433916

    4    libswiftCore.so                    0x00002b81e1a9cbb0 _assertionFailure(_:_:file:line:flags:)
    + 251

    5    libswiftSwiftOnoneSupport.so       0x00002b81e189ce83 <unavailable> + 188035

    6    tmpne3iwc3y                        0x00005612682d8ae8 <unavailable> + 6888

    7    tmpne3iwc3y                        0x00005612682d85ad <unavailable> + 5549

    8    libc.so.6                          0x00002b81e1f92460 __libc_start_main +
    245

    9    tmpne3iwc3y                        0x00005612682d82b9 <unavailable> + 4793

    '
  stdout: ''
  timestamp: 1659979940
- exit_code: -4
  program: "\n/// From a given array of integers, generate an array of rolling maximum\
    \ element found until given moment\n/// in the sequence.\n/// >>> rolling_max(numbers:\
    \ [1, 2, 3, 2, 3, 4, 2])\n/// [1, 2, 3, 3, 3, 4, 4]\nfunc rolling_max(numbers:\
    \ [Int]) -> [Int] {\n    return numbers.dropFirst().reduce([numbers[0]]) { prev,\
    \ curr in\n        let maxValue = max(prev.last!, curr)\n        return prev +\
    \ [maxValue]\n    }\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) ->\
    \ Bool {\n    if left.count != right.count {\n        return false\n    }\n  \
    \  for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(rolling_max(numbers:\
    \ [] as [Int]) == [] as [Int])\nassert(rolling_max(numbers: [1, 2, 3, 4]) == [1,\
    \ 2, 3, 4])\nassert(rolling_max(numbers: [4, 3, 2, 1]) == [4, 4, 4, 4])\nassert(rolling_max(numbers:\
    \ [3, 2, 3, 100, 3]) == [3, 3, 3, 100, 100])"
  status: Exception
  stderr: 'Swift/ContiguousArrayBuffer.swift:600: Fatal error: Index out of range

    Current stack trace:

    0    libswiftCore.so                    0x00002b0c764f6c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b0c761ed561 <unavailable> + 1434977

    2    libswiftCore.so                    0x00002b0c761ed286 <unavailable> + 1434246

    3    libswiftCore.so                    0x00002b0c761ed13c <unavailable> + 1433916

    4    libswiftCore.so                    0x00002b0c761ecbb0 _assertionFailure(_:_:file:line:flags:)
    + 251

    5    libswiftSwiftOnoneSupport.so       0x00002b0c75fece83 <unavailable> + 188035

    6    tmpq1j8wfhl                        0x0000560f86276c5f <unavailable> + 7263

    7    tmpq1j8wfhl                        0x0000560f862766dd <unavailable> + 5853

    8    libc.so.6                          0x00002b0c766e2460 __libc_start_main +
    245

    9    tmpq1j8wfhl                        0x0000560f862763e9 <unavailable> + 5097

    '
  stdout: ''
  timestamp: 1659979940
- exit_code: 0
  program: "\n/// From a given array of integers, generate an array of rolling maximum\
    \ element found until given moment\n/// in the sequence.\n/// >>> rolling_max(numbers:\
    \ [1, 2, 3, 2, 3, 4, 2])\n/// [1, 2, 3, 3, 3, 4, 4]\nfunc rolling_max(numbers:\
    \ [Int]) -> [Int] {\n    var result = [Int]()\n    var max_element = 0\n    for\
    \ number in numbers {\n        max_element = max(max_element, number)\n      \
    \  result.append(max_element)\n    }\n    return result\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(rolling_max(numbers: [] as [Int]) == [] as [Int])\nassert(rolling_max(numbers:\
    \ [1, 2, 3, 4]) == [1, 2, 3, 4])\nassert(rolling_max(numbers: [4, 3, 2, 1]) ==\
    \ [4, 4, 4, 4])\nassert(rolling_max(numbers: [3, 2, 3, 100, 3]) == [3, 3, 3, 100,\
    \ 100])"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659979940
- exit_code: 0
  program: "\n/// From a given array of integers, generate an array of rolling maximum\
    \ element found until given moment\n/// in the sequence.\n/// >>> rolling_max(numbers:\
    \ [1, 2, 3, 2, 3, 4, 2])\n/// [1, 2, 3, 3, 3, 4, 4]\nfunc rolling_max(numbers:\
    \ [Int]) -> [Int] {\n    var rolling_max: [Int] = []\n    var last_max = 0\n \
    \   for number in numbers {\n        if last_max > number {\n            rolling_max.append(last_max)\n\
    \        } else {\n            rolling_max.append(number)\n            last_max\
    \ = number\n        }\n    }\n    return rolling_max\n}\n\n\nfunc ==(left: [(Int,\
    \ Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n\
    \        return false\n    }\n    for (l, r) in zip(left, right) {\n        if\
    \ l != r {\n            return false\n        }\n    }\n    return true\n}\n \
    \           \nassert(rolling_max(numbers: [] as [Int]) == [] as [Int])\nassert(rolling_max(numbers:\
    \ [1, 2, 3, 4]) == [1, 2, 3, 4])\nassert(rolling_max(numbers: [4, 3, 2, 1]) ==\
    \ [4, 4, 4, 4])\nassert(rolling_max(numbers: [3, 2, 3, 100, 3]) == [3, 3, 3, 100,\
    \ 100])"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659979940
- exit_code: -4
  program: "\n/// From a given array of integers, generate an array of rolling maximum\
    \ element found until given moment\n/// in the sequence.\n/// >>> rolling_max(numbers:\
    \ [1, 2, 3, 2, 3, 4, 2])\n/// [1, 2, 3, 3, 3, 4, 4]\nfunc rolling_max(numbers:\
    \ [Int]) -> [Int] {\n    var numbersCopy = numbers\n    var maxValues = [Int]()\n\
    \    while !numbersCopy.isEmpty {\n        maxValues.append(numbersCopy.max()!)\n\
    \        numbersCopy.removeLast()\n    }\n    return maxValues\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(rolling_max(numbers: [] as [Int]) == [] as [Int])\nassert(rolling_max(numbers:\
    \ [1, 2, 3, 4]) == [1, 2, 3, 4])\nassert(rolling_max(numbers: [4, 3, 2, 1]) ==\
    \ [4, 4, 4, 4])\nassert(rolling_max(numbers: [3, 2, 3, 100, 3]) == [3, 3, 3, 100,\
    \ 100])"
  status: Exception
  stderr: 'tmp7ig3_d75/tmp7ig3_d75.swift:30: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b37db917c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b37db60eb6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b37db60e988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b37db60d7b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmp7ig3_d75                        0x0000560ef5a0b80d <unavailable> + 6157

    5    libc.so.6                          0x00002b37dbb03460 __libc_start_main +
    245

    6    tmp7ig3_d75                        0x0000560ef5a0b329 <unavailable> + 4905

    '
  stdout: ''
  timestamp: 1659979940
- exit_code: 0
  program: "\n/// From a given array of integers, generate an array of rolling maximum\
    \ element found until given moment\n/// in the sequence.\n/// >>> rolling_max(numbers:\
    \ [1, 2, 3, 2, 3, 4, 2])\n/// [1, 2, 3, 3, 3, 4, 4]\nfunc rolling_max(numbers:\
    \ [Int]) -> [Int] {\n    var result = [Int]()\n    var last_max = Int.min\n  \
    \  for n in numbers {\n        if last_max < n {\n            last_max = n\n \
    \       }\n        result.append(last_max)\n    }\n    return result\n}\n\n\n\
    func ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(rolling_max(numbers: [] as [Int]) == [] as [Int])\n\
    assert(rolling_max(numbers: [1, 2, 3, 4]) == [1, 2, 3, 4])\nassert(rolling_max(numbers:\
    \ [4, 3, 2, 1]) == [4, 4, 4, 4])\nassert(rolling_max(numbers: [3, 2, 3, 100, 3])\
    \ == [3, 3, 3, 100, 100])"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659979940
- exit_code: 0
  program: "\n/// From a given array of integers, generate an array of rolling maximum\
    \ element found until given moment\n/// in the sequence.\n/// >>> rolling_max(numbers:\
    \ [1, 2, 3, 2, 3, 4, 2])\n/// [1, 2, 3, 3, 3, 4, 4]\nfunc rolling_max(numbers:\
    \ [Int]) -> [Int] {\n    var maxes = [Int]()\n    var max_so_far = Int.min\n \
    \   for element in numbers {\n        max_so_far = max(max_so_far, element)\n\
    \        maxes.append(max_so_far)\n    }\n    return maxes\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(rolling_max(numbers: [] as [Int]) == [] as [Int])\nassert(rolling_max(numbers:\
    \ [1, 2, 3, 4]) == [1, 2, 3, 4])\nassert(rolling_max(numbers: [4, 3, 2, 1]) ==\
    \ [4, 4, 4, 4])\nassert(rolling_max(numbers: [3, 2, 3, 100, 3]) == [3, 3, 3, 100,\
    \ 100])"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659979940
- exit_code: 1
  program: "\n/// From a given array of integers, generate an array of rolling maximum\
    \ element found until given moment\n/// in the sequence.\n/// >>> rolling_max(numbers:\
    \ [1, 2, 3, 2, 3, 4, 2])\n/// [1, 2, 3, 3, 3, 4, 4]\nfunc rolling_max(numbers:\
    \ [Int]) -> [Int] {\n    var result = [Int]()\n    var max = numbers[0]\n    for\
    \ i in numbers {\n        max = max(max, i)\n        result.append(max)\n    }\n\
    \    return result\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) ->\
    \ Bool {\n    if left.count != right.count {\n        return false\n    }\n  \
    \  for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(rolling_max(numbers:\
    \ [] as [Int]) == [] as [Int])\nassert(rolling_max(numbers: [1, 2, 3, 4]) == [1,\
    \ 2, 3, 4])\nassert(rolling_max(numbers: [4, 3, 2, 1]) == [4, 4, 4, 4])\nassert(rolling_max(numbers:\
    \ [3, 2, 3, 100, 3]) == [3, 3, 3, 100, 100])"
  status: SyntaxError
  stderr: "/tmp/tmpojx8xvau.swift:10:15: error: cannot call value of non-function\
    \ type 'Int'\n        max = max(max, i)\n              ^\n"
  stdout: ''
  timestamp: 1659979940
- exit_code: -4
  program: "\n/// From a given array of integers, generate an array of rolling maximum\
    \ element found until given moment\n/// in the sequence.\n/// >>> rolling_max(numbers:\
    \ [1, 2, 3, 2, 3, 4, 2])\n/// [1, 2, 3, 3, 3, 4, 4]\nfunc rolling_max(numbers:\
    \ [Int]) -> [Int] {\n    // element and its index at the head of the queue\n \
    \   var queue: [(Int, Int)] = []\n    var result: [Int] = []\n    \n    for (index,\
    \ element) in numbers.enumerated() {\n        // remove all elements larger than\
    \ the current element and their indices from queue\n        while !queue.isEmpty\
    \ && queue.last!.0 < element {\n            queue.removeLast()\n        }\n  \
    \      \n        // if the queue is empty, append the current number to the result,\
    \ otherwise append the maximum\n        // element found in the queue (since we\
    \ remove all elements larger than the current element)\n        if queue.isEmpty\
    \ {\n            result.append(element)\n        } else {\n            result.append(queue.last!.0)\n\
    \        }\n        \n        // add current element and its index to the queue\n\
    \        queue.append((element, index))\n    }\n    \n    return result\n}\n\n\
    \nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(rolling_max(numbers: [] as [Int]) == [] as [Int])\n\
    assert(rolling_max(numbers: [1, 2, 3, 4]) == [1, 2, 3, 4])\nassert(rolling_max(numbers:\
    \ [4, 3, 2, 1]) == [4, 4, 4, 4])\nassert(rolling_max(numbers: [3, 2, 3, 100, 3])\
    \ == [3, 3, 3, 100, 100])"
  status: Exception
  stderr: 'tmpnesva8wj/tmpnesva8wj.swift:47: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b4191a77c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b419176eb6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b419176e988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b419176d7b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpnesva8wj                        0x0000556584aafb26 <unavailable> + 6950

    5    libc.so.6                          0x00002b4191c63460 __libc_start_main +
    245

    6    tmpnesva8wj                        0x0000556584aaf4f9 <unavailable> + 5369

    '
  stdout: ''
  timestamp: 1659979940
- exit_code: 0
  program: "\n/// From a given array of integers, generate an array of rolling maximum\
    \ element found until given moment\n/// in the sequence.\n/// >>> rolling_max(numbers:\
    \ [1, 2, 3, 2, 3, 4, 2])\n/// [1, 2, 3, 3, 3, 4, 4]\nfunc rolling_max(numbers:\
    \ [Int]) -> [Int] {\n    var result = [Int]()\n    for i in 0 ..< numbers.count\
    \ {\n        result.append(numbers[0...i].max()!)\n    }\n    return result\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(rolling_max(numbers: [] as [Int]) == [] as [Int])\n\
    assert(rolling_max(numbers: [1, 2, 3, 4]) == [1, 2, 3, 4])\nassert(rolling_max(numbers:\
    \ [4, 3, 2, 1]) == [4, 4, 4, 4])\nassert(rolling_max(numbers: [3, 2, 3, 100, 3])\
    \ == [3, 3, 3, 100, 100])"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659979940
- exit_code: 0
  program: "\n/// From a given array of integers, generate an array of rolling maximum\
    \ element found until given moment\n/// in the sequence.\n/// >>> rolling_max(numbers:\
    \ [1, 2, 3, 2, 3, 4, 2])\n/// [1, 2, 3, 3, 3, 4, 4]\nfunc rolling_max(numbers:\
    \ [Int]) -> [Int] {\n    var max_cache = [Int]()\n    for i in 0..<numbers.count\
    \ {\n        if i == 0 {\n            max_cache.append(numbers[i])\n        }\
    \ else {\n            max_cache.append(max(max_cache[i - 1], numbers[i]))\n  \
    \      }\n    }\n    return max_cache\n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(rolling_max(numbers: [] as [Int]) == [] as [Int])\nassert(rolling_max(numbers:\
    \ [1, 2, 3, 4]) == [1, 2, 3, 4])\nassert(rolling_max(numbers: [4, 3, 2, 1]) ==\
    \ [4, 4, 4, 4])\nassert(rolling_max(numbers: [3, 2, 3, 100, 3]) == [3, 3, 3, 100,\
    \ 100])"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659979940
- exit_code: 0
  program: "\n/// From a given array of integers, generate an array of rolling maximum\
    \ element found until given moment\n/// in the sequence.\n/// >>> rolling_max(numbers:\
    \ [1, 2, 3, 2, 3, 4, 2])\n/// [1, 2, 3, 3, 3, 4, 4]\nfunc rolling_max(numbers:\
    \ [Int]) -> [Int] {\n    var maxes = [Int]()\n    var max = 0\n    for number\
    \ in numbers {\n        max = Swift.max(max, number)\n        maxes.append(max)\n\
    \    }\n    return maxes\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(rolling_max(numbers:\
    \ [] as [Int]) == [] as [Int])\nassert(rolling_max(numbers: [1, 2, 3, 4]) == [1,\
    \ 2, 3, 4])\nassert(rolling_max(numbers: [4, 3, 2, 1]) == [4, 4, 4, 4])\nassert(rolling_max(numbers:\
    \ [3, 2, 3, 100, 3]) == [3, 3, 3, 100, 100])"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659979940
- exit_code: 0
  program: "\n/// From a given array of integers, generate an array of rolling maximum\
    \ element found until given moment\n/// in the sequence.\n/// >>> rolling_max(numbers:\
    \ [1, 2, 3, 2, 3, 4, 2])\n/// [1, 2, 3, 3, 3, 4, 4]\nfunc rolling_max(numbers:\
    \ [Int]) -> [Int] {\n    var new_numbers = [Int]()\n    var max = Int.min\n  \
    \  for number in numbers {\n        if number > max {\n            max = number\n\
    \        }\n        new_numbers.append(max)\n    }\n    return new_numbers\n}\n\
    \n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(rolling_max(numbers: [] as [Int]) == [] as [Int])\n\
    assert(rolling_max(numbers: [1, 2, 3, 4]) == [1, 2, 3, 4])\nassert(rolling_max(numbers:\
    \ [4, 3, 2, 1]) == [4, 4, 4, 4])\nassert(rolling_max(numbers: [3, 2, 3, 100, 3])\
    \ == [3, 3, 3, 100, 100])"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659979940
- exit_code: -4
  program: "\n/// From a given array of integers, generate an array of rolling maximum\
    \ element found until given moment\n/// in the sequence.\n/// >>> rolling_max(numbers:\
    \ [1, 2, 3, 2, 3, 4, 2])\n/// [1, 2, 3, 3, 3, 4, 4]\nfunc rolling_max(numbers:\
    \ [Int]) -> [Int] {\n    return .init()\n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(rolling_max(numbers: [] as [Int]) == [] as [Int])\nassert(rolling_max(numbers:\
    \ [1, 2, 3, 4]) == [1, 2, 3, 4])\nassert(rolling_max(numbers: [4, 3, 2, 1]) ==\
    \ [4, 4, 4, 4])\nassert(rolling_max(numbers: [3, 2, 3, 100, 3]) == [3, 3, 3, 100,\
    \ 100])"
  status: Exception
  stderr: 'tmp3hnu_cir/tmp3hnu_cir.swift:24: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002ad98200ec80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002ad981d05b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002ad981d05988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002ad981d047b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmp3hnu_cir                        0x00005571992a450d <unavailable> + 5389

    5    libc.so.6                          0x00002ad9821fa460 __libc_start_main +
    245

    6    tmp3hnu_cir                        0x00005571992a4029 <unavailable> + 4137

    '
  stdout: ''
  timestamp: 1659979940
- exit_code: 1
  program: "\n/// From a given array of integers, generate an array of rolling maximum\
    \ element found until given moment\n/// in the sequence.\n/// >>> rolling_max(numbers:\
    \ [1, 2, 3, 2, 3, 4, 2])\n/// [1, 2, 3, 3, 3, 4, 4]\nfunc rolling_max(numbers:\
    \ [Int]) -> [Int] {\n    return rolling_indices(numbers: numbers).map { numbers[$0]\
    \ }\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if\
    \ left.count != right.count {\n        return false\n    }\n    for (l, r) in\
    \ zip(left, right) {\n        if l != r {\n            return false\n        }\n\
    \    }\n    return true\n}\n            \nassert(rolling_max(numbers: [] as [Int])\
    \ == [] as [Int])\nassert(rolling_max(numbers: [1, 2, 3, 4]) == [1, 2, 3, 4])\n\
    assert(rolling_max(numbers: [4, 3, 2, 1]) == [4, 4, 4, 4])\nassert(rolling_max(numbers:\
    \ [3, 2, 3, 100, 3]) == [3, 3, 3, 100, 100])"
  status: SyntaxError
  stderr: "/tmp/tmpcr3wvdyp.swift:7:12: error: cannot find 'rolling_indices' in scope\n\
    \    return rolling_indices(numbers: numbers).map { numbers[$0] }\n          \
    \ ^~~~~~~~~~~~~~~\n"
  stdout: ''
  timestamp: 1659979940
- exit_code: -4
  program: "\n/// From a given array of integers, generate an array of rolling maximum\
    \ element found until given moment\n/// in the sequence.\n/// >>> rolling_max(numbers:\
    \ [1, 2, 3, 2, 3, 4, 2])\n/// [1, 2, 3, 3, 3, 4, 4]\nfunc rolling_max(numbers:\
    \ [Int]) -> [Int] {\n  var max = numbers[0]\n  var rolling_max = [max]\n  for\
    \ number in numbers[1..<numbers.count] {\n    max = Swift.max(max, number)\n \
    \   rolling_max.append(max)\n  }\n  return rolling_max\n}\n\n\nfunc ==(left: [(Int,\
    \ Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n\
    \        return false\n    }\n    for (l, r) in zip(left, right) {\n        if\
    \ l != r {\n            return false\n        }\n    }\n    return true\n}\n \
    \           \nassert(rolling_max(numbers: [] as [Int]) == [] as [Int])\nassert(rolling_max(numbers:\
    \ [1, 2, 3, 4]) == [1, 2, 3, 4])\nassert(rolling_max(numbers: [4, 3, 2, 1]) ==\
    \ [4, 4, 4, 4])\nassert(rolling_max(numbers: [3, 2, 3, 100, 3]) == [3, 3, 3, 100,\
    \ 100])"
  status: Exception
  stderr: 'Swift/ContiguousArrayBuffer.swift:600: Fatal error: Index out of range

    Current stack trace:

    0    libswiftCore.so                    0x00002b697cb67c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b697c85e561 <unavailable> + 1434977

    2    libswiftCore.so                    0x00002b697c85e286 <unavailable> + 1434246

    3    libswiftCore.so                    0x00002b697c85e13c <unavailable> + 1433916

    4    libswiftCore.so                    0x00002b697c85dbb0 _assertionFailure(_:_:file:line:flags:)
    + 251

    5    libswiftSwiftOnoneSupport.so       0x00002b697c65de83 <unavailable> + 188035

    6    tmpyuepk594                        0x0000559ea9ddec38 <unavailable> + 7224

    7    tmpyuepk594                        0x0000559ea9dde70d <unavailable> + 5901

    8    libc.so.6                          0x00002b697cd53460 __libc_start_main +
    245

    9    tmpyuepk594                        0x0000559ea9dde419 <unavailable> + 5145

    '
  stdout: ''
  timestamp: 1659979941
- exit_code: 0
  program: "\n/// From a given array of integers, generate an array of rolling maximum\
    \ element found until given moment\n/// in the sequence.\n/// >>> rolling_max(numbers:\
    \ [1, 2, 3, 2, 3, 4, 2])\n/// [1, 2, 3, 3, 3, 4, 4]\nfunc rolling_max(numbers:\
    \ [Int]) -> [Int] {\n    guard numbers.count > 0 else { return [] }\n    var result\
    \ = [Int]()\n    var currentMax = numbers[0]\n    result.append(currentMax)\n\
    \    for i in 1..<numbers.count {\n        if currentMax < numbers[i] {\n    \
    \        currentMax = numbers[i]\n        }\n        result.append(currentMax)\n\
    \    }\n    return result\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(rolling_max(numbers:\
    \ [] as [Int]) == [] as [Int])\nassert(rolling_max(numbers: [1, 2, 3, 4]) == [1,\
    \ 2, 3, 4])\nassert(rolling_max(numbers: [4, 3, 2, 1]) == [4, 4, 4, 4])\nassert(rolling_max(numbers:\
    \ [3, 2, 3, 100, 3]) == [3, 3, 3, 100, 100])"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659979941
- exit_code: 0
  program: "\n/// From a given array of integers, generate an array of rolling maximum\
    \ element found until given moment\n/// in the sequence.\n/// >>> rolling_max(numbers:\
    \ [1, 2, 3, 2, 3, 4, 2])\n/// [1, 2, 3, 3, 3, 4, 4]\nfunc rolling_max(numbers:\
    \ [Int]) -> [Int] {\n  var result = [Int]()\n  var lastMax = 0\n  for number in\
    \ numbers {\n    if number > lastMax {\n      lastMax = number\n    }\n    result.append(lastMax)\n\
    \  }\n  return result\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(rolling_max(numbers:\
    \ [] as [Int]) == [] as [Int])\nassert(rolling_max(numbers: [1, 2, 3, 4]) == [1,\
    \ 2, 3, 4])\nassert(rolling_max(numbers: [4, 3, 2, 1]) == [4, 4, 4, 4])\nassert(rolling_max(numbers:\
    \ [3, 2, 3, 100, 3]) == [3, 3, 3, 100, 100])"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659979941
- exit_code: 0
  program: "\n/// From a given array of integers, generate an array of rolling maximum\
    \ element found until given moment\n/// in the sequence.\n/// >>> rolling_max(numbers:\
    \ [1, 2, 3, 2, 3, 4, 2])\n/// [1, 2, 3, 3, 3, 4, 4]\nfunc rolling_max(numbers:\
    \ [Int]) -> [Int] {\n    return [Int](repeating: 0, count: numbers.count).enumerated().map\
    \ { (tuple) -> Int in\n        let i = tuple.offset\n        return numbers[0...i].max()!\n\
    \    }\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n  \
    \  if left.count != right.count {\n        return false\n    }\n    for (l, r)\
    \ in zip(left, right) {\n        if l != r {\n            return false\n     \
    \   }\n    }\n    return true\n}\n            \nassert(rolling_max(numbers: []\
    \ as [Int]) == [] as [Int])\nassert(rolling_max(numbers: [1, 2, 3, 4]) == [1,\
    \ 2, 3, 4])\nassert(rolling_max(numbers: [4, 3, 2, 1]) == [4, 4, 4, 4])\nassert(rolling_max(numbers:\
    \ [3, 2, 3, 100, 3]) == [3, 3, 3, 100, 100])"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659979941
- exit_code: -4
  program: "\n/// From a given array of integers, generate an array of rolling maximum\
    \ element found until given moment\n/// in the sequence.\n/// >>> rolling_max(numbers:\
    \ [1, 2, 3, 2, 3, 4, 2])\n/// [1, 2, 3, 3, 3, 4, 4]\nfunc rolling_max(numbers:\
    \ [Int]) -> [Int] {\n    guard numbers.count > 0 else { return [] }\n    var rolling_maximums\
    \ = [Int]()\n    rolling_maximums.append(numbers[0])\n    for i in 0..<numbers.count\
    \ {\n        if numbers[i] > rolling_maximums[i] {\n            rolling_maximums.append(numbers[i])\n\
    \        } else {\n            rolling_maximums.append(rolling_maximums[i])\n\
    \        }\n    }\n    return rolling_maximums\n}\n\n\nfunc ==(left: [(Int, Int)],\
    \ right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n       \
    \ return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r\
    \ {\n            return false\n        }\n    }\n    return true\n}\n        \
    \    \nassert(rolling_max(numbers: [] as [Int]) == [] as [Int])\nassert(rolling_max(numbers:\
    \ [1, 2, 3, 4]) == [1, 2, 3, 4])\nassert(rolling_max(numbers: [4, 3, 2, 1]) ==\
    \ [4, 4, 4, 4])\nassert(rolling_max(numbers: [3, 2, 3, 100, 3]) == [3, 3, 3, 100,\
    \ 100])"
  status: Exception
  stderr: 'tmpt32g2wpe/tmpt32g2wpe.swift:34: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002afba0059c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002afb9fd50b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002afb9fd50988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002afb9fd4f7b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpt32g2wpe                        0x0000557763de579d <unavailable> + 6045

    5    libc.so.6                          0x00002afba0245460 __libc_start_main +
    245

    6    tmpt32g2wpe                        0x0000557763de52b9 <unavailable> + 4793

    '
  stdout: ''
  timestamp: 1659979941
- exit_code: 0
  program: "\n/// From a given array of integers, generate an array of rolling maximum\
    \ element found until given moment\n/// in the sequence.\n/// >>> rolling_max(numbers:\
    \ [1, 2, 3, 2, 3, 4, 2])\n/// [1, 2, 3, 3, 3, 4, 4]\nfunc rolling_max(numbers:\
    \ [Int]) -> [Int] {\n    guard numbers.count > 0 else { return [] }\n    var result\
    \ = [Int]()\n    result.append(numbers[0])\n    for i in 1..<numbers.count {\n\
    \        result.append(max(result[i - 1], numbers[i]))\n    }\n    return result\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(rolling_max(numbers: [] as [Int]) == [] as [Int])\n\
    assert(rolling_max(numbers: [1, 2, 3, 4]) == [1, 2, 3, 4])\nassert(rolling_max(numbers:\
    \ [4, 3, 2, 1]) == [4, 4, 4, 4])\nassert(rolling_max(numbers: [3, 2, 3, 100, 3])\
    \ == [3, 3, 3, 100, 100])"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659979941
- exit_code: 0
  program: "\n/// From a given array of integers, generate an array of rolling maximum\
    \ element found until given moment\n/// in the sequence.\n/// >>> rolling_max(numbers:\
    \ [1, 2, 3, 2, 3, 4, 2])\n/// [1, 2, 3, 3, 3, 4, 4]\nfunc rolling_max(numbers:\
    \ [Int]) -> [Int] {\n    guard !numbers.isEmpty else { return [] }\n    var rolling_max\
    \ = [Int]()\n    var max_number = numbers[0]\n    rolling_max.append(max_number)\n\
    \    for number in numbers[1..<numbers.count] {\n        if number > max_number\
    \ {\n            max_number = number\n        }\n        rolling_max.append(max_number)\n\
    \    }\n    return rolling_max\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int,\
    \ Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n\
    \    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n          \
    \  return false\n        }\n    }\n    return true\n}\n            \nassert(rolling_max(numbers:\
    \ [] as [Int]) == [] as [Int])\nassert(rolling_max(numbers: [1, 2, 3, 4]) == [1,\
    \ 2, 3, 4])\nassert(rolling_max(numbers: [4, 3, 2, 1]) == [4, 4, 4, 4])\nassert(rolling_max(numbers:\
    \ [3, 2, 3, 100, 3]) == [3, 3, 3, 100, 100])"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659979941
- exit_code: 0
  program: "\n/// From a given array of integers, generate an array of rolling maximum\
    \ element found until given moment\n/// in the sequence.\n/// >>> rolling_max(numbers:\
    \ [1, 2, 3, 2, 3, 4, 2])\n/// [1, 2, 3, 3, 3, 4, 4]\nfunc rolling_max(numbers:\
    \ [Int]) -> [Int] {\n    return numbers.enumerated().map({ (index, number) ->\
    \ Int in\n        let max_element = numbers[0..<index].max() ?? number\n     \
    \   return max(max_element, number)\n    })\n}\n\n\nfunc ==(left: [(Int, Int)],\
    \ right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n       \
    \ return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r\
    \ {\n            return false\n        }\n    }\n    return true\n}\n        \
    \    \nassert(rolling_max(numbers: [] as [Int]) == [] as [Int])\nassert(rolling_max(numbers:\
    \ [1, 2, 3, 4]) == [1, 2, 3, 4])\nassert(rolling_max(numbers: [4, 3, 2, 1]) ==\
    \ [4, 4, 4, 4])\nassert(rolling_max(numbers: [3, 2, 3, 100, 3]) == [3, 3, 3, 100,\
    \ 100])"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659979941
- exit_code: -4
  program: "\n/// From a given array of integers, generate an array of rolling maximum\
    \ element found until given moment\n/// in the sequence.\n/// >>> rolling_max(numbers:\
    \ [1, 2, 3, 2, 3, 4, 2])\n/// [1, 2, 3, 3, 3, 4, 4]\nfunc rolling_max(numbers:\
    \ [Int]) -> [Int] {\n    var current_max = numbers[0]\n    var result = [Int]()\n\
    \    for x in numbers {\n        current_max = max(current_max, x)\n        result.append(current_max)\n\
    \    }\n    return result\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(rolling_max(numbers:\
    \ [] as [Int]) == [] as [Int])\nassert(rolling_max(numbers: [1, 2, 3, 4]) == [1,\
    \ 2, 3, 4])\nassert(rolling_max(numbers: [4, 3, 2, 1]) == [4, 4, 4, 4])\nassert(rolling_max(numbers:\
    \ [3, 2, 3, 100, 3]) == [3, 3, 3, 100, 100])"
  status: Exception
  stderr: 'Swift/ContiguousArrayBuffer.swift:600: Fatal error: Index out of range

    Current stack trace:

    0    libswiftCore.so                    0x00002b1a388b0c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b1a385a7561 <unavailable> + 1434977

    2    libswiftCore.so                    0x00002b1a385a7286 <unavailable> + 1434246

    3    libswiftCore.so                    0x00002b1a385a713c <unavailable> + 1433916

    4    libswiftCore.so                    0x00002b1a385a6bb0 _assertionFailure(_:_:file:line:flags:)
    + 251

    5    libswiftSwiftOnoneSupport.so       0x00002b1a383a6e83 <unavailable> + 188035

    6    tmp3110g4_w                        0x000055bfa8f48ae8 <unavailable> + 6888

    7    tmp3110g4_w                        0x000055bfa8f485bd <unavailable> + 5565

    8    libc.so.6                          0x00002b1a38a9c460 __libc_start_main +
    245

    9    tmp3110g4_w                        0x000055bfa8f482c9 <unavailable> + 4809

    '
  stdout: ''
  timestamp: 1659979941
- exit_code: 0
  program: "\n/// From a given array of integers, generate an array of rolling maximum\
    \ element found until given moment\n/// in the sequence.\n/// >>> rolling_max(numbers:\
    \ [1, 2, 3, 2, 3, 4, 2])\n/// [1, 2, 3, 3, 3, 4, 4]\nfunc rolling_max(numbers:\
    \ [Int]) -> [Int] {\n    // the \"window\" of maximum values will be moved from\
    \ left to right\n    // and we will record what's the maximum value recorded in\
    \ the window\n    var out = [Int]()\n    var max_value = Int.min\n    for value\
    \ in numbers {\n        max_value = max(max_value, value)\n        out.append(max_value)\n\
    \    }\n    return out\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(rolling_max(numbers:\
    \ [] as [Int]) == [] as [Int])\nassert(rolling_max(numbers: [1, 2, 3, 4]) == [1,\
    \ 2, 3, 4])\nassert(rolling_max(numbers: [4, 3, 2, 1]) == [4, 4, 4, 4])\nassert(rolling_max(numbers:\
    \ [3, 2, 3, 100, 3]) == [3, 3, 3, 100, 100])"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659979941
- exit_code: 0
  program: "\n/// From a given array of integers, generate an array of rolling maximum\
    \ element found until given moment\n/// in the sequence.\n/// >>> rolling_max(numbers:\
    \ [1, 2, 3, 2, 3, 4, 2])\n/// [1, 2, 3, 3, 3, 4, 4]\nfunc rolling_max(numbers:\
    \ [Int]) -> [Int] {\n    guard numbers.count > 0 else { return [] }\n    var result\
    \ = [Int]()\n    result.append(numbers[0])\n    for i in 1..<numbers.count {\n\
    \        result.append(max(result[i - 1], numbers[i]))\n    }\n    return result\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(rolling_max(numbers: [] as [Int]) == [] as [Int])\n\
    assert(rolling_max(numbers: [1, 2, 3, 4]) == [1, 2, 3, 4])\nassert(rolling_max(numbers:\
    \ [4, 3, 2, 1]) == [4, 4, 4, 4])\nassert(rolling_max(numbers: [3, 2, 3, 100, 3])\
    \ == [3, 3, 3, 100, 100])"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659979941
- exit_code: 1
  program: "\n/// From a given array of integers, generate an array of rolling maximum\
    \ element found until given moment\n/// in the sequence.\n/// >>> rolling_max(numbers:\
    \ [1, 2, 3, 2, 3, 4, 2])\n/// [1, 2, 3, 3, 3, 4, 4]\nfunc rolling_max(numbers:\
    \ [Int]) -> [Int] {\n    return rolling_aggregate(numbers: numbers, with: max)\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(rolling_max(numbers: [] as [Int]) == [] as [Int])\n\
    assert(rolling_max(numbers: [1, 2, 3, 4]) == [1, 2, 3, 4])\nassert(rolling_max(numbers:\
    \ [4, 3, 2, 1]) == [4, 4, 4, 4])\nassert(rolling_max(numbers: [3, 2, 3, 100, 3])\
    \ == [3, 3, 3, 100, 100])"
  status: SyntaxError
  stderr: "/tmp/tmppc1m4slb.swift:7:12: error: cannot find 'rolling_aggregate' in\
    \ scope\n    return rolling_aggregate(numbers: numbers, with: max)\n         \
    \  ^~~~~~~~~~~~~~~~~\n/tmp/tmppc1m4slb.swift:7:54: error: generic parameter 'T'\
    \ could not be inferred\n    return rolling_aggregate(numbers: numbers, with:\
    \ max)\n                                                     ^\nSwift.max:1:24:\
    \ note: in call to function 'max'\n@inlinable public func max<T>(_ x: T, _ y:\
    \ T) -> T where T : Comparable\n                       ^\n"
  stdout: ''
  timestamp: 1659979941
- exit_code: -4
  program: "\n/// From a given array of integers, generate an array of rolling maximum\
    \ element found until given moment\n/// in the sequence.\n/// >>> rolling_max(numbers:\
    \ [1, 2, 3, 2, 3, 4, 2])\n/// [1, 2, 3, 3, 3, 4, 4]\nfunc rolling_max(numbers:\
    \ [Int]) -> [Int] {\n    var max_value = numbers[0]\n    var max_values = [Int]()\n\
    \    for current_value in numbers {\n        max_value = max(max_value, current_value)\n\
    \        max_values.append(max_value)\n    }\n    return max_values\n}\n\n\nfunc\
    \ ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count !=\
    \ right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(rolling_max(numbers: [] as [Int]) == [] as [Int])\n\
    assert(rolling_max(numbers: [1, 2, 3, 4]) == [1, 2, 3, 4])\nassert(rolling_max(numbers:\
    \ [4, 3, 2, 1]) == [4, 4, 4, 4])\nassert(rolling_max(numbers: [3, 2, 3, 100, 3])\
    \ == [3, 3, 3, 100, 100])"
  status: Exception
  stderr: 'Swift/ContiguousArrayBuffer.swift:600: Fatal error: Index out of range

    Current stack trace:

    0    libswiftCore.so                    0x00002b4233e7cc80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b4233b73561 <unavailable> + 1434977

    2    libswiftCore.so                    0x00002b4233b73286 <unavailable> + 1434246

    3    libswiftCore.so                    0x00002b4233b7313c <unavailable> + 1433916

    4    libswiftCore.so                    0x00002b4233b72bb0 _assertionFailure(_:_:file:line:flags:)
    + 251

    5    libswiftSwiftOnoneSupport.so       0x00002b4233972e83 <unavailable> + 188035

    6    tmpl2m9kdjc                        0x000055d14c9c5ae8 <unavailable> + 6888

    7    tmpl2m9kdjc                        0x000055d14c9c55bd <unavailable> + 5565

    8    libc.so.6                          0x00002b4234068460 __libc_start_main +
    245

    9    tmpl2m9kdjc                        0x000055d14c9c52c9 <unavailable> + 4809

    '
  stdout: ''
  timestamp: 1659979941
- exit_code: -4
  program: "\n/// From a given array of integers, generate an array of rolling maximum\
    \ element found until given moment\n/// in the sequence.\n/// >>> rolling_max(numbers:\
    \ [1, 2, 3, 2, 3, 4, 2])\n/// [1, 2, 3, 3, 3, 4, 4]\nfunc rolling_max(numbers:\
    \ [Int]) -> [Int] {\n    var max_so_far = numbers[0]\n    var result = [Int]()\n\
    \    result.append(max_so_far)\n    for n in numbers[1..<numbers.count] {\n  \
    \      max_so_far = max(max_so_far, n)\n        result.append(max_so_far)\n  \
    \  }\n    return result\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(rolling_max(numbers:\
    \ [] as [Int]) == [] as [Int])\nassert(rolling_max(numbers: [1, 2, 3, 4]) == [1,\
    \ 2, 3, 4])\nassert(rolling_max(numbers: [4, 3, 2, 1]) == [4, 4, 4, 4])\nassert(rolling_max(numbers:\
    \ [3, 2, 3, 100, 3]) == [3, 3, 3, 100, 100])"
  status: Exception
  stderr: 'Swift/ContiguousArrayBuffer.swift:600: Fatal error: Index out of range

    Current stack trace:

    0    libswiftCore.so                    0x00002aae19f21c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002aae19c18561 <unavailable> + 1434977

    2    libswiftCore.so                    0x00002aae19c18286 <unavailable> + 1434246

    3    libswiftCore.so                    0x00002aae19c1813c <unavailable> + 1433916

    4    libswiftCore.so                    0x00002aae19c17bb0 _assertionFailure(_:_:file:line:flags:)
    + 251

    5    libswiftSwiftOnoneSupport.so       0x00002aae19a17e83 <unavailable> + 188035

    6    tmpevb496hx                        0x000055ceba0c9c8b <unavailable> + 7307

    7    tmpevb496hx                        0x000055ceba0c975d <unavailable> + 5981

    8    libc.so.6                          0x00002aae1a10d460 __libc_start_main +
    245

    9    tmpevb496hx                        0x000055ceba0c9469 <unavailable> + 5225

    '
  stdout: ''
  timestamp: 1659979941
- exit_code: -4
  program: "\n/// From a given array of integers, generate an array of rolling maximum\
    \ element found until given moment\n/// in the sequence.\n/// >>> rolling_max(numbers:\
    \ [1, 2, 3, 2, 3, 4, 2])\n/// [1, 2, 3, 3, 3, 4, 4]\nfunc rolling_max(numbers:\
    \ [Int]) -> [Int] {\n    return [Int](repeating: -1, count: numbers.count)\n}\n\
    \n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(rolling_max(numbers: [] as [Int]) == [] as [Int])\n\
    assert(rolling_max(numbers: [1, 2, 3, 4]) == [1, 2, 3, 4])\nassert(rolling_max(numbers:\
    \ [4, 3, 2, 1]) == [4, 4, 4, 4])\nassert(rolling_max(numbers: [3, 2, 3, 100, 3])\
    \ == [3, 3, 3, 100, 100])"
  status: Exception
  stderr: 'tmp8i3fr48i/tmp8i3fr48i.swift:24: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b6a9c2dbc80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b6a9bfd2b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b6a9bfd2988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b6a9bfd17b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmp8i3fr48i                        0x00005591bf7d457d <unavailable> + 5501

    5    libc.so.6                          0x00002b6a9c4c7460 __libc_start_main +
    245

    6    tmp8i3fr48i                        0x00005591bf7d4099 <unavailable> + 4249

    '
  stdout: ''
  timestamp: 1659979941
- exit_code: -4
  program: "\n/// From a given array of integers, generate an array of rolling maximum\
    \ element found until given moment\n/// in the sequence.\n/// >>> rolling_max(numbers:\
    \ [1, 2, 3, 2, 3, 4, 2])\n/// [1, 2, 3, 3, 3, 4, 4]\nfunc rolling_max(numbers:\
    \ [Int]) -> [Int] {\n    return []\n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(rolling_max(numbers: [] as [Int]) == [] as [Int])\nassert(rolling_max(numbers:\
    \ [1, 2, 3, 4]) == [1, 2, 3, 4])\nassert(rolling_max(numbers: [4, 3, 2, 1]) ==\
    \ [4, 4, 4, 4])\nassert(rolling_max(numbers: [3, 2, 3, 100, 3]) == [3, 3, 3, 100,\
    \ 100])"
  status: Exception
  stderr: 'tmp9fy9csjx/tmp9fy9csjx.swift:24: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b188eb4ac80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b188e841b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b188e841988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b188e8407b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmp9fy9csjx                        0x000055fa16c564ad <unavailable> + 5293

    5    libc.so.6                          0x00002b188ed36460 __libc_start_main +
    245

    6    tmp9fy9csjx                        0x000055fa16c55fc9 <unavailable> + 4041

    '
  stdout: ''
  timestamp: 1659979941
- exit_code: 0
  program: "\n/// From a given array of integers, generate an array of rolling maximum\
    \ element found until given moment\n/// in the sequence.\n/// >>> rolling_max(numbers:\
    \ [1, 2, 3, 2, 3, 4, 2])\n/// [1, 2, 3, 3, 3, 4, 4]\nfunc rolling_max(numbers:\
    \ [Int]) -> [Int] {\n    return numbers.reduce([]) { (array, element) in\n   \
    \     if let last = array.last {\n            return array + [max(last, element)]\n\
    \        } else {\n            return array + [element]\n        }\n    }\n}\n\
    \n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(rolling_max(numbers: [] as [Int]) == [] as [Int])\n\
    assert(rolling_max(numbers: [1, 2, 3, 4]) == [1, 2, 3, 4])\nassert(rolling_max(numbers:\
    \ [4, 3, 2, 1]) == [4, 4, 4, 4])\nassert(rolling_max(numbers: [3, 2, 3, 100, 3])\
    \ == [3, 3, 3, 100, 100])"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659979941
- exit_code: 0
  program: "\n/// From a given array of integers, generate an array of rolling maximum\
    \ element found until given moment\n/// in the sequence.\n/// >>> rolling_max(numbers:\
    \ [1, 2, 3, 2, 3, 4, 2])\n/// [1, 2, 3, 3, 3, 4, 4]\nfunc rolling_max(numbers:\
    \ [Int]) -> [Int] {\n    if numbers.count == 0 {\n        return []\n    }\n \
    \   var rolling_max = [Int]()\n    var max = numbers[0]\n    rolling_max.append(max)\n\
    \    for i in 1..<numbers.count {\n        if numbers[i] > max {\n           \
    \ max = numbers[i]\n        }\n        rolling_max.append(max)\n    }\n    return\
    \ rolling_max\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool\
    \ {\n    if left.count != right.count {\n        return false\n    }\n    for\
    \ (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(rolling_max(numbers:\
    \ [] as [Int]) == [] as [Int])\nassert(rolling_max(numbers: [1, 2, 3, 4]) == [1,\
    \ 2, 3, 4])\nassert(rolling_max(numbers: [4, 3, 2, 1]) == [4, 4, 4, 4])\nassert(rolling_max(numbers:\
    \ [3, 2, 3, 100, 3]) == [3, 3, 3, 100, 100])"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659979941
- exit_code: -4
  program: "\n/// From a given array of integers, generate an array of rolling maximum\
    \ element found until given moment\n/// in the sequence.\n/// >>> rolling_max(numbers:\
    \ [1, 2, 3, 2, 3, 4, 2])\n/// [1, 2, 3, 3, 3, 4, 4]\nfunc rolling_max(numbers:\
    \ [Int]) -> [Int] {\n    var result = [Int]()\n    var current_max = numbers[0]\n\
    \    for i in 0..<numbers.count {\n        current_max = max(current_max, numbers[i])\n\
    \        result.append(current_max)\n    }\n    return result\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(rolling_max(numbers: [] as [Int]) == [] as [Int])\nassert(rolling_max(numbers:\
    \ [1, 2, 3, 4]) == [1, 2, 3, 4])\nassert(rolling_max(numbers: [4, 3, 2, 1]) ==\
    \ [4, 4, 4, 4])\nassert(rolling_max(numbers: [3, 2, 3, 100, 3]) == [3, 3, 3, 100,\
    \ 100])"
  status: Exception
  stderr: 'Swift/ContiguousArrayBuffer.swift:600: Fatal error: Index out of range

    Current stack trace:

    0    libswiftCore.so                    0x00002ae162ed5c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002ae162bcc561 <unavailable> + 1434977

    2    libswiftCore.so                    0x00002ae162bcc286 <unavailable> + 1434246

    3    libswiftCore.so                    0x00002ae162bcc13c <unavailable> + 1433916

    4    libswiftCore.so                    0x00002ae162bcbbb0 _assertionFailure(_:_:file:line:flags:)
    + 251

    5    libswiftSwiftOnoneSupport.so       0x00002ae1629cbe83 <unavailable> + 188035

    6    tmpqry5kmpm                        0x000055f8d9813b68 <unavailable> + 7016

    7    tmpqry5kmpm                        0x000055f8d981362d <unavailable> + 5677

    8    libc.so.6                          0x00002ae1630c1460 __libc_start_main +
    245

    9    tmpqry5kmpm                        0x000055f8d9813339 <unavailable> + 4921

    '
  stdout: ''
  timestamp: 1659979941
- exit_code: 0
  program: "\n/// From a given array of integers, generate an array of rolling maximum\
    \ element found until given moment\n/// in the sequence.\n/// >>> rolling_max(numbers:\
    \ [1, 2, 3, 2, 3, 4, 2])\n/// [1, 2, 3, 3, 3, 4, 4]\nfunc rolling_max(numbers:\
    \ [Int]) -> [Int] {\n    var result = [Int]()\n    var maxSoFar = Int.min\n  \
    \  for number in numbers {\n        maxSoFar = max(maxSoFar, number)\n       \
    \ result.append(maxSoFar)\n    }\n    return result\n}\n\n\nfunc ==(left: [(Int,\
    \ Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n\
    \        return false\n    }\n    for (l, r) in zip(left, right) {\n        if\
    \ l != r {\n            return false\n        }\n    }\n    return true\n}\n \
    \           \nassert(rolling_max(numbers: [] as [Int]) == [] as [Int])\nassert(rolling_max(numbers:\
    \ [1, 2, 3, 4]) == [1, 2, 3, 4])\nassert(rolling_max(numbers: [4, 3, 2, 1]) ==\
    \ [4, 4, 4, 4])\nassert(rolling_max(numbers: [3, 2, 3, 100, 3]) == [3, 3, 3, 100,\
    \ 100])"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659979941
- exit_code: 1
  program: "\n/// From a given array of integers, generate an array of rolling maximum\
    \ element found until given moment\n/// in the sequence.\n/// >>> rolling_max(numbers:\
    \ [1, 2, 3, 2, 3, 4, 2])\n/// [1, 2, 3, 3, 3, 4, 4]\nfunc rolling_max(numbers:\
    \ [Int]) -> [Int] {\n    return numbers.map{\n        if let maxSoFar = $0.value\
    \ {\n            return max(maxSoFar, $0.0)\n        } else {\n            return\
    \ $0.0\n        }\n    }\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(rolling_max(numbers:\
    \ [] as [Int]) == [] as [Int])\nassert(rolling_max(numbers: [1, 2, 3, 4]) == [1,\
    \ 2, 3, 4])\nassert(rolling_max(numbers: [4, 3, 2, 1]) == [4, 4, 4, 4])\nassert(rolling_max(numbers:\
    \ [3, 2, 3, 100, 3]) == [3, 3, 3, 100, 100])"
  status: SyntaxError
  stderr: "/tmp/tmp8zeockw6.swift:8:30: error: value of type 'Int' has no member 'value'\n\
    \        if let maxSoFar = $0.value {\n                          ~~ ^~~~~\n"
  stdout: ''
  timestamp: 1659979941
- exit_code: 1
  program: "\n/// From a given array of integers, generate an array of rolling maximum\
    \ element found until given moment\n/// in the sequence.\n/// >>> rolling_max(numbers:\
    \ [1, 2, 3, 2, 3, 4, 2])\n/// [1, 2, 3, 3, 3, 4, 4]\nfunc rolling_max(numbers:\
    \ [Int]) -> [Int] {\n    return rolling_max(numbers: numbers, n: numbers.count)\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(rolling_max(numbers: [] as [Int]) == [] as [Int])\n\
    assert(rolling_max(numbers: [1, 2, 3, 4]) == [1, 2, 3, 4])\nassert(rolling_max(numbers:\
    \ [4, 3, 2, 1]) == [4, 4, 4, 4])\nassert(rolling_max(numbers: [3, 2, 3, 100, 3])\
    \ == [3, 3, 3, 100, 100])"
  status: SyntaxError
  stderr: "/tmp/tmpgddo3b_h.swift:7:53: error: extra argument 'n' in call\n    return\
    \ rolling_max(numbers: numbers, n: numbers.count)\n                      ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~^~~~~~\n"
  stdout: ''
  timestamp: 1659979941
- exit_code: 0
  program: "\n/// From a given array of integers, generate an array of rolling maximum\
    \ element found until given moment\n/// in the sequence.\n/// >>> rolling_max(numbers:\
    \ [1, 2, 3, 2, 3, 4, 2])\n/// [1, 2, 3, 3, 3, 4, 4]\nfunc rolling_max(numbers:\
    \ [Int]) -> [Int] {\n    var result = [Int]()\n    var max = 0\n    for value\
    \ in numbers {\n        max = Swift.max(max, value)\n        result.append(max)\n\
    \    }\n    return result\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(rolling_max(numbers:\
    \ [] as [Int]) == [] as [Int])\nassert(rolling_max(numbers: [1, 2, 3, 4]) == [1,\
    \ 2, 3, 4])\nassert(rolling_max(numbers: [4, 3, 2, 1]) == [4, 4, 4, 4])\nassert(rolling_max(numbers:\
    \ [3, 2, 3, 100, 3]) == [3, 3, 3, 100, 100])"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659979941
- exit_code: -4
  program: "\n/// From a given array of integers, generate an array of rolling maximum\
    \ element found until given moment\n/// in the sequence.\n/// >>> rolling_max(numbers:\
    \ [1, 2, 3, 2, 3, 4, 2])\n/// [1, 2, 3, 3, 3, 4, 4]\nfunc rolling_max(numbers:\
    \ [Int]) -> [Int] {\n    var results = [Int]()\n    var max = numbers[0]\n   \
    \ for i in numbers {\n        if i > max {\n            max = i\n        }\n \
    \       results.append(max)\n    }\n    return results\n}\n\n\nfunc ==(left: [(Int,\
    \ Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n\
    \        return false\n    }\n    for (l, r) in zip(left, right) {\n        if\
    \ l != r {\n            return false\n        }\n    }\n    return true\n}\n \
    \           \nassert(rolling_max(numbers: [] as [Int]) == [] as [Int])\nassert(rolling_max(numbers:\
    \ [1, 2, 3, 4]) == [1, 2, 3, 4])\nassert(rolling_max(numbers: [4, 3, 2, 1]) ==\
    \ [4, 4, 4, 4])\nassert(rolling_max(numbers: [3, 2, 3, 100, 3]) == [3, 3, 3, 100,\
    \ 100])"
  status: Exception
  stderr: 'Swift/ContiguousArrayBuffer.swift:600: Fatal error: Index out of range

    Current stack trace:

    0    libswiftCore.so                    0x00002ac9ed0c0c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002ac9ecdb7561 <unavailable> + 1434977

    2    libswiftCore.so                    0x00002ac9ecdb7286 <unavailable> + 1434246

    3    libswiftCore.so                    0x00002ac9ecdb713c <unavailable> + 1433916

    4    libswiftCore.so                    0x00002ac9ecdb6bb0 _assertionFailure(_:_:file:line:flags:)
    + 251

    5    libswiftSwiftOnoneSupport.so       0x00002ac9ecbb6e83 <unavailable> + 188035

    6    tmpdoveu0t4                        0x000055d3863e2a5f <unavailable> + 6751

    7    tmpdoveu0t4                        0x000055d3863e252d <unavailable> + 5421

    8    libc.so.6                          0x00002ac9ed2ac460 __libc_start_main +
    245

    9    tmpdoveu0t4                        0x000055d3863e2239 <unavailable> + 4665

    '
  stdout: ''
  timestamp: 1659979941
- exit_code: -4
  program: "\n/// From a given array of integers, generate an array of rolling maximum\
    \ element found until given moment\n/// in the sequence.\n/// >>> rolling_max(numbers:\
    \ [1, 2, 3, 2, 3, 4, 2])\n/// [1, 2, 3, 3, 3, 4, 4]\nfunc rolling_max(numbers:\
    \ [Int]) -> [Int] {\n    var maxes = [Int]()\n    var max = numbers[0]\n    for\
    \ number in numbers {\n        max = Swift.max(max, number)\n        maxes.append(max)\n\
    \    }\n    return maxes\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(rolling_max(numbers:\
    \ [] as [Int]) == [] as [Int])\nassert(rolling_max(numbers: [1, 2, 3, 4]) == [1,\
    \ 2, 3, 4])\nassert(rolling_max(numbers: [4, 3, 2, 1]) == [4, 4, 4, 4])\nassert(rolling_max(numbers:\
    \ [3, 2, 3, 100, 3]) == [3, 3, 3, 100, 100])"
  status: Exception
  stderr: 'Swift/ContiguousArrayBuffer.swift:600: Fatal error: Index out of range

    Current stack trace:

    0    libswiftCore.so                    0x00002b47060b9c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b4705db0561 <unavailable> + 1434977

    2    libswiftCore.so                    0x00002b4705db0286 <unavailable> + 1434246

    3    libswiftCore.so                    0x00002b4705db013c <unavailable> + 1433916

    4    libswiftCore.so                    0x00002b4705dafbb0 _assertionFailure(_:_:file:line:flags:)
    + 251

    5    libswiftSwiftOnoneSupport.so       0x00002b4705bafe83 <unavailable> + 188035

    6    tmpl1kzxe5k                        0x00005639a5015af8 <unavailable> + 6904

    7    tmpl1kzxe5k                        0x00005639a50155bd <unavailable> + 5565

    8    libc.so.6                          0x00002b47062a5460 __libc_start_main +
    245

    9    tmpl1kzxe5k                        0x00005639a50152c9 <unavailable> + 4809

    '
  stdout: ''
  timestamp: 1659979941
- exit_code: 0
  program: "\n/// From a given array of integers, generate an array of rolling maximum\
    \ element found until given moment\n/// in the sequence.\n/// >>> rolling_max(numbers:\
    \ [1, 2, 3, 2, 3, 4, 2])\n/// [1, 2, 3, 3, 3, 4, 4]\nfunc rolling_max(numbers:\
    \ [Int]) -> [Int] {\n    var rolling_max = [Int]()\n    var current_max = Int.min\n\
    \    for i in 0..<numbers.count {\n        current_max = max(current_max, numbers[i])\n\
    \        rolling_max.append(current_max)\n    }\n    return rolling_max\n}\n\n\
    \nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(rolling_max(numbers: [] as [Int]) == [] as [Int])\n\
    assert(rolling_max(numbers: [1, 2, 3, 4]) == [1, 2, 3, 4])\nassert(rolling_max(numbers:\
    \ [4, 3, 2, 1]) == [4, 4, 4, 4])\nassert(rolling_max(numbers: [3, 2, 3, 100, 3])\
    \ == [3, 3, 3, 100, 100])"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659979941
- exit_code: 1
  program: "\n/// From a given array of integers, generate an array of rolling maximum\
    \ element found until given moment\n/// in the sequence.\n/// >>> rolling_max(numbers:\
    \ [1, 2, 3, 2, 3, 4, 2])\n/// [1, 2, 3, 3, 3, 4, 4]\nfunc rolling_max(numbers:\
    \ [Int]) -> [Int] {\n  return numbers.scan(0, { rollingMax, current in max(rollingMax,\
    \ current) })\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool\
    \ {\n    if left.count != right.count {\n        return false\n    }\n    for\
    \ (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(rolling_max(numbers:\
    \ [] as [Int]) == [] as [Int])\nassert(rolling_max(numbers: [1, 2, 3, 4]) == [1,\
    \ 2, 3, 4])\nassert(rolling_max(numbers: [4, 3, 2, 1]) == [4, 4, 4, 4])\nassert(rolling_max(numbers:\
    \ [3, 2, 3, 100, 3]) == [3, 3, 3, 100, 100])"
  status: SyntaxError
  stderr: "/tmp/tmp70f315w6.swift:7:18: error: value of type '[Int]' has no member\
    \ 'scan'\n  return numbers.scan(0, { rollingMax, current in max(rollingMax, current)\
    \ })\n         ~~~~~~~ ^~~~\n"
  stdout: ''
  timestamp: 1659979941
- exit_code: 0
  program: "\n/// From a given array of integers, generate an array of rolling maximum\
    \ element found until given moment\n/// in the sequence.\n/// >>> rolling_max(numbers:\
    \ [1, 2, 3, 2, 3, 4, 2])\n/// [1, 2, 3, 3, 3, 4, 4]\nfunc rolling_max(numbers:\
    \ [Int]) -> [Int] {\n    var result = [Int]()\n    var max_so_far = Int.min\n\
    \    for n in numbers {\n        if n > max_so_far {\n            max_so_far =\
    \ n\n        }\n        result.append(max_so_far)\n    }\n    return result\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(rolling_max(numbers: [] as [Int]) == [] as [Int])\n\
    assert(rolling_max(numbers: [1, 2, 3, 4]) == [1, 2, 3, 4])\nassert(rolling_max(numbers:\
    \ [4, 3, 2, 1]) == [4, 4, 4, 4])\nassert(rolling_max(numbers: [3, 2, 3, 100, 3])\
    \ == [3, 3, 3, 100, 100])"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659979941
- exit_code: 1
  program: "\n/// From a given array of integers, generate an array of rolling maximum\
    \ element found until given moment\n/// in the sequence.\n/// >>> rolling_max(numbers:\
    \ [1, 2, 3, 2, 3, 4, 2])\n/// [1, 2, 3, 3, 3, 4, 4]\nfunc rolling_max(numbers:\
    \ [Int]) -> [Int] {\n    return rolling_aggregation(numbers: numbers, initial:\
    \ numbers[0], operation: max)\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int,\
    \ Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n\
    \    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n          \
    \  return false\n        }\n    }\n    return true\n}\n            \nassert(rolling_max(numbers:\
    \ [] as [Int]) == [] as [Int])\nassert(rolling_max(numbers: [1, 2, 3, 4]) == [1,\
    \ 2, 3, 4])\nassert(rolling_max(numbers: [4, 3, 2, 1]) == [4, 4, 4, 4])\nassert(rolling_max(numbers:\
    \ [3, 2, 3, 100, 3]) == [3, 3, 3, 100, 100])"
  status: SyntaxError
  stderr: "/tmp/tmpbpo0t0r2.swift:7:12: error: cannot find 'rolling_aggregation' in\
    \ scope\n    return rolling_aggregation(numbers: numbers, initial: numbers[0],\
    \ operation: max)\n           ^~~~~~~~~~~~~~~~~~~\n/tmp/tmpbpo0t0r2.swift:7:82:\
    \ error: generic parameter 'T' could not be inferred\n    return rolling_aggregation(numbers:\
    \ numbers, initial: numbers[0], operation: max)\n                            \
    \                                                     ^\nSwift.max:1:24: note:\
    \ in call to function 'max'\n@inlinable public func max<T>(_ x: T, _ y: T) ->\
    \ T where T : Comparable\n                       ^\n"
  stdout: ''
  timestamp: 1659979941
- exit_code: 0
  program: "\n/// From a given array of integers, generate an array of rolling maximum\
    \ element found until given moment\n/// in the sequence.\n/// >>> rolling_max(numbers:\
    \ [1, 2, 3, 2, 3, 4, 2])\n/// [1, 2, 3, 3, 3, 4, 4]\nfunc rolling_max(numbers:\
    \ [Int]) -> [Int] {\n    var result = [Int]()\n    var max = Int.min\n    for\
    \ number in numbers {\n        if number > max {\n            max = number\n \
    \       }\n        result.append(max)\n    }\n    return result\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(rolling_max(numbers: [] as [Int]) == [] as [Int])\nassert(rolling_max(numbers:\
    \ [1, 2, 3, 4]) == [1, 2, 3, 4])\nassert(rolling_max(numbers: [4, 3, 2, 1]) ==\
    \ [4, 4, 4, 4])\nassert(rolling_max(numbers: [3, 2, 3, 100, 3]) == [3, 3, 3, 100,\
    \ 100])"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659979941
- exit_code: 0
  program: "\n/// From a given array of integers, generate an array of rolling maximum\
    \ element found until given moment\n/// in the sequence.\n/// >>> rolling_max(numbers:\
    \ [1, 2, 3, 2, 3, 4, 2])\n/// [1, 2, 3, 3, 3, 4, 4]\nfunc rolling_max(numbers:\
    \ [Int]) -> [Int] {\n    var rolling_max = [Int]()\n    var current_max = Int.min\n\
    \    for number in numbers {\n        current_max = max(current_max, number)\n\
    \        rolling_max.append(current_max)\n    }\n    return rolling_max\n}\n\n\
    \nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(rolling_max(numbers: [] as [Int]) == [] as [Int])\n\
    assert(rolling_max(numbers: [1, 2, 3, 4]) == [1, 2, 3, 4])\nassert(rolling_max(numbers:\
    \ [4, 3, 2, 1]) == [4, 4, 4, 4])\nassert(rolling_max(numbers: [3, 2, 3, 100, 3])\
    \ == [3, 3, 3, 100, 100])"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659979941
- exit_code: 0
  program: "\n/// From a given array of integers, generate an array of rolling maximum\
    \ element found until given moment\n/// in the sequence.\n/// >>> rolling_max(numbers:\
    \ [1, 2, 3, 2, 3, 4, 2])\n/// [1, 2, 3, 3, 3, 4, 4]\nfunc rolling_max(numbers:\
    \ [Int]) -> [Int] {\n    let initial: [Int] = []\n    return numbers.reduce(initial)\
    \ { accumulator, item in\n        if let last = accumulator.last {\n         \
    \   return accumulator + [max(last, item)]\n        } else {\n            return\
    \ accumulator + [item]\n        }\n    }\n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(rolling_max(numbers: [] as [Int]) == [] as [Int])\nassert(rolling_max(numbers:\
    \ [1, 2, 3, 4]) == [1, 2, 3, 4])\nassert(rolling_max(numbers: [4, 3, 2, 1]) ==\
    \ [4, 4, 4, 4])\nassert(rolling_max(numbers: [3, 2, 3, 100, 3]) == [3, 3, 3, 100,\
    \ 100])"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659979941
- exit_code: 0
  program: "\n/// From a given array of integers, generate an array of rolling maximum\
    \ element found until given moment\n/// in the sequence.\n/// >>> rolling_max(numbers:\
    \ [1, 2, 3, 2, 3, 4, 2])\n/// [1, 2, 3, 3, 3, 4, 4]\nfunc rolling_max(numbers:\
    \ [Int]) -> [Int] {\n    guard numbers.count > 0 else { return [] }\n    var result\
    \ = [Int]()\n    var maxSoFar = numbers[0]\n    result.append(maxSoFar)\n    for\
    \ i in 1..<numbers.count {\n        if numbers[i] > maxSoFar {\n            maxSoFar\
    \ = numbers[i]\n        }\n        result.append(maxSoFar)\n    }\n    return\
    \ result\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n\
    \    if left.count != right.count {\n        return false\n    }\n    for (l,\
    \ r) in zip(left, right) {\n        if l != r {\n            return false\n  \
    \      }\n    }\n    return true\n}\n            \nassert(rolling_max(numbers:\
    \ [] as [Int]) == [] as [Int])\nassert(rolling_max(numbers: [1, 2, 3, 4]) == [1,\
    \ 2, 3, 4])\nassert(rolling_max(numbers: [4, 3, 2, 1]) == [4, 4, 4, 4])\nassert(rolling_max(numbers:\
    \ [3, 2, 3, 100, 3]) == [3, 3, 3, 100, 100])"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659979941
- exit_code: 0
  program: "\n/// From a given array of integers, generate an array of rolling maximum\
    \ element found until given moment\n/// in the sequence.\n/// >>> rolling_max(numbers:\
    \ [1, 2, 3, 2, 3, 4, 2])\n/// [1, 2, 3, 3, 3, 4, 4]\nfunc rolling_max(numbers:\
    \ [Int]) -> [Int] {\n    var max_so_far = 0\n    var results = [Int]()\n    for\
    \ number in numbers {\n        max_so_far = max(max_so_far, number)\n        results.append(max_so_far)\n\
    \    }\n    return results\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(rolling_max(numbers:\
    \ [] as [Int]) == [] as [Int])\nassert(rolling_max(numbers: [1, 2, 3, 4]) == [1,\
    \ 2, 3, 4])\nassert(rolling_max(numbers: [4, 3, 2, 1]) == [4, 4, 4, 4])\nassert(rolling_max(numbers:\
    \ [3, 2, 3, 100, 3]) == [3, 3, 3, 100, 100])"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659979941
- exit_code: 0
  program: "\n/// From a given array of integers, generate an array of rolling maximum\
    \ element found until given moment\n/// in the sequence.\n/// >>> rolling_max(numbers:\
    \ [1, 2, 3, 2, 3, 4, 2])\n/// [1, 2, 3, 3, 3, 4, 4]\nfunc rolling_max(numbers:\
    \ [Int]) -> [Int] {\n    var result = [Int]()\n    var maximum = Int.min\n   \
    \ for number in numbers {\n        maximum = max(maximum, number)\n        result.append(maximum)\n\
    \    }\n    return result\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(rolling_max(numbers:\
    \ [] as [Int]) == [] as [Int])\nassert(rolling_max(numbers: [1, 2, 3, 4]) == [1,\
    \ 2, 3, 4])\nassert(rolling_max(numbers: [4, 3, 2, 1]) == [4, 4, 4, 4])\nassert(rolling_max(numbers:\
    \ [3, 2, 3, 100, 3]) == [3, 3, 3, 100, 100])"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659979941
- exit_code: -4
  program: "\n/// From a given array of integers, generate an array of rolling maximum\
    \ element found until given moment\n/// in the sequence.\n/// >>> rolling_max(numbers:\
    \ [1, 2, 3, 2, 3, 4, 2])\n/// [1, 2, 3, 3, 3, 4, 4]\nfunc rolling_max(numbers:\
    \ [Int]) -> [Int] {\n    var result = Array(repeating: 0, count: numbers.count)\n\
    \    result[0] = numbers[0]\n    for index in 1..<numbers.count {\n        result[index]\
    \ = max(result[index - 1], numbers[index])\n    }\n    return result\n}\n\n\n\
    func ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(rolling_max(numbers: [] as [Int]) == [] as [Int])\n\
    assert(rolling_max(numbers: [1, 2, 3, 4]) == [1, 2, 3, 4])\nassert(rolling_max(numbers:\
    \ [4, 3, 2, 1]) == [4, 4, 4, 4])\nassert(rolling_max(numbers: [3, 2, 3, 100, 3])\
    \ == [3, 3, 3, 100, 100])"
  status: Exception
  stderr: 'Swift/ContiguousArrayBuffer.swift:600: Fatal error: Index out of range

    Current stack trace:

    0    libswiftCore.so                    0x00002b83b40c9c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b83b3dc0561 <unavailable> + 1434977

    2    libswiftCore.so                    0x00002b83b3dc0286 <unavailable> + 1434246

    3    libswiftCore.so                    0x00002b83b3dc013c <unavailable> + 1433916

    4    libswiftCore.so                    0x00002b83b3dbfbb0 _assertionFailure(_:_:file:line:flags:)
    + 251

    5    libswiftSwiftOnoneSupport.so       0x00002b83b3bbfe83 <unavailable> + 188035

    6    tmpe8ijfzao                        0x000055fda189ab7f <unavailable> + 7039

    7    tmpe8ijfzao                        0x000055fda189a63d <unavailable> + 5693

    8    libc.so.6                          0x00002b83b42b5460 __libc_start_main +
    245

    9    tmpe8ijfzao                        0x000055fda189a349 <unavailable> + 4937

    '
  stdout: ''
  timestamp: 1659979941
- exit_code: 0
  program: "\n/// From a given array of integers, generate an array of rolling maximum\
    \ element found until given moment\n/// in the sequence.\n/// >>> rolling_max(numbers:\
    \ [1, 2, 3, 2, 3, 4, 2])\n/// [1, 2, 3, 3, 3, 4, 4]\nfunc rolling_max(numbers:\
    \ [Int]) -> [Int] {\n    var result = [Int]()\n    var current_max = Int.min\n\
    \    for number in numbers {\n        current_max = max(current_max, number)\n\
    \        result.append(current_max)\n    }\n    return result\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(rolling_max(numbers: [] as [Int]) == [] as [Int])\nassert(rolling_max(numbers:\
    \ [1, 2, 3, 4]) == [1, 2, 3, 4])\nassert(rolling_max(numbers: [4, 3, 2, 1]) ==\
    \ [4, 4, 4, 4])\nassert(rolling_max(numbers: [3, 2, 3, 100, 3]) == [3, 3, 3, 100,\
    \ 100])"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659979941
- exit_code: 0
  program: "\n/// From a given array of integers, generate an array of rolling maximum\
    \ element found until given moment\n/// in the sequence.\n/// >>> rolling_max(numbers:\
    \ [1, 2, 3, 2, 3, 4, 2])\n/// [1, 2, 3, 3, 3, 4, 4]\nfunc rolling_max(numbers:\
    \ [Int]) -> [Int] {\n    var max_value: Int? = nil\n    var result: [Int] = []\n\
    \    for value in numbers {\n        if max_value == nil {\n            max_value\
    \ = value\n        } else {\n            max_value = max(max_value!, value)\n\
    \        }\n        result.append(max_value!)\n    }\n    return result\n}\n\n\
    \nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(rolling_max(numbers: [] as [Int]) == [] as [Int])\n\
    assert(rolling_max(numbers: [1, 2, 3, 4]) == [1, 2, 3, 4])\nassert(rolling_max(numbers:\
    \ [4, 3, 2, 1]) == [4, 4, 4, 4])\nassert(rolling_max(numbers: [3, 2, 3, 100, 3])\
    \ == [3, 3, 3, 100, 100])"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659979941
- exit_code: 0
  program: "\n/// From a given array of integers, generate an array of rolling maximum\
    \ element found until given moment\n/// in the sequence.\n/// >>> rolling_max(numbers:\
    \ [1, 2, 3, 2, 3, 4, 2])\n/// [1, 2, 3, 3, 3, 4, 4]\nfunc rolling_max(numbers:\
    \ [Int]) -> [Int] {\n    var result = [Int]()\n    var current_max = Int.min\n\
    \    for number in numbers {\n        current_max = max(current_max, number)\n\
    \        result.append(current_max)\n    }\n    return result\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(rolling_max(numbers: [] as [Int]) == [] as [Int])\nassert(rolling_max(numbers:\
    \ [1, 2, 3, 4]) == [1, 2, 3, 4])\nassert(rolling_max(numbers: [4, 3, 2, 1]) ==\
    \ [4, 4, 4, 4])\nassert(rolling_max(numbers: [3, 2, 3, 100, 3]) == [3, 3, 3, 100,\
    \ 100])"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659979941
- exit_code: -4
  program: "\n/// From a given array of integers, generate an array of rolling maximum\
    \ element found until given moment\n/// in the sequence.\n/// >>> rolling_max(numbers:\
    \ [1, 2, 3, 2, 3, 4, 2])\n/// [1, 2, 3, 3, 3, 4, 4]\nfunc rolling_max(numbers:\
    \ [Int]) -> [Int] {\n    var max = numbers[0]\n    var results = [Int]()\n   \
    \ results.append(max)\n    for i in 1..<numbers.count {\n        if numbers[i]\
    \ > max {\n            max = numbers[i]\n        }\n        results.append(max)\n\
    \    }\n    return results\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(rolling_max(numbers:\
    \ [] as [Int]) == [] as [Int])\nassert(rolling_max(numbers: [1, 2, 3, 4]) == [1,\
    \ 2, 3, 4])\nassert(rolling_max(numbers: [4, 3, 2, 1]) == [4, 4, 4, 4])\nassert(rolling_max(numbers:\
    \ [3, 2, 3, 100, 3]) == [3, 3, 3, 100, 100])"
  status: Exception
  stderr: 'Swift/ContiguousArrayBuffer.swift:600: Fatal error: Index out of range

    Current stack trace:

    0    libswiftCore.so                    0x00002b650883cc80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b6508533561 <unavailable> + 1434977

    2    libswiftCore.so                    0x00002b6508533286 <unavailable> + 1434246

    3    libswiftCore.so                    0x00002b650853313c <unavailable> + 1433916

    4    libswiftCore.so                    0x00002b6508532bb0 _assertionFailure(_:_:file:line:flags:)
    + 251

    5    libswiftSwiftOnoneSupport.so       0x00002b6508332e83 <unavailable> + 188035

    6    tmpk5bvvvec                        0x000055e75dcecad8 <unavailable> + 6872

    7    tmpk5bvvvec                        0x000055e75dcec5ad <unavailable> + 5549

    8    libc.so.6                          0x00002b6508a28460 __libc_start_main +
    245

    9    tmpk5bvvvec                        0x000055e75dcec2b9 <unavailable> + 4793

    '
  stdout: ''
  timestamp: 1659979941
- exit_code: 0
  program: "\n/// From a given array of integers, generate an array of rolling maximum\
    \ element found until given moment\n/// in the sequence.\n/// >>> rolling_max(numbers:\
    \ [1, 2, 3, 2, 3, 4, 2])\n/// [1, 2, 3, 3, 3, 4, 4]\nfunc rolling_max(numbers:\
    \ [Int]) -> [Int] {\n    var result = [Int]()\n    var max: Int? = nil\n    for\
    \ number in numbers {\n        if max == nil || number > max! {\n            max\
    \ = number\n        }\n        result.append(max!)\n    }\n    return result\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(rolling_max(numbers: [] as [Int]) == [] as [Int])\n\
    assert(rolling_max(numbers: [1, 2, 3, 4]) == [1, 2, 3, 4])\nassert(rolling_max(numbers:\
    \ [4, 3, 2, 1]) == [4, 4, 4, 4])\nassert(rolling_max(numbers: [3, 2, 3, 100, 3])\
    \ == [3, 3, 3, 100, 100])"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659979941
- exit_code: 0
  program: "\n/// From a given array of integers, generate an array of rolling maximum\
    \ element found until given moment\n/// in the sequence.\n/// >>> rolling_max(numbers:\
    \ [1, 2, 3, 2, 3, 4, 2])\n/// [1, 2, 3, 3, 3, 4, 4]\nfunc rolling_max(numbers:\
    \ [Int]) -> [Int] {\n    var result = [Int]()\n    var max = Int.min\n    for\
    \ number in numbers {\n        max = max > number ? max : number\n        result.append(max)\n\
    \    }\n    return result\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(rolling_max(numbers:\
    \ [] as [Int]) == [] as [Int])\nassert(rolling_max(numbers: [1, 2, 3, 4]) == [1,\
    \ 2, 3, 4])\nassert(rolling_max(numbers: [4, 3, 2, 1]) == [4, 4, 4, 4])\nassert(rolling_max(numbers:\
    \ [3, 2, 3, 100, 3]) == [3, 3, 3, 100, 100])"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659979941
- exit_code: 0
  program: "\n/// From a given array of integers, generate an array of rolling maximum\
    \ element found until given moment\n/// in the sequence.\n/// >>> rolling_max(numbers:\
    \ [1, 2, 3, 2, 3, 4, 2])\n/// [1, 2, 3, 3, 3, 4, 4]\nfunc rolling_max(numbers:\
    \ [Int]) -> [Int] {\n    guard !numbers.isEmpty else { return [] }\n    var results\
    \ = [Int]()\n    results.append(numbers[0])\n    for i in 1..<numbers.count {\n\
    \        results.append(max(results[i - 1], numbers[i]))\n    }\n    return results\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(rolling_max(numbers: [] as [Int]) == [] as [Int])\n\
    assert(rolling_max(numbers: [1, 2, 3, 4]) == [1, 2, 3, 4])\nassert(rolling_max(numbers:\
    \ [4, 3, 2, 1]) == [4, 4, 4, 4])\nassert(rolling_max(numbers: [3, 2, 3, 100, 3])\
    \ == [3, 3, 3, 100, 100])"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659979941
- exit_code: 0
  program: "\n/// From a given array of integers, generate an array of rolling maximum\
    \ element found until given moment\n/// in the sequence.\n/// >>> rolling_max(numbers:\
    \ [1, 2, 3, 2, 3, 4, 2])\n/// [1, 2, 3, 3, 3, 4, 4]\nfunc rolling_max(numbers:\
    \ [Int]) -> [Int] {\n    var rolling_max = [Int]()\n    var max = 0\n    for number\
    \ in numbers {\n        if number > max {\n            max = number\n        }\n\
    \        rolling_max.append(max)\n    }\n    return rolling_max\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(rolling_max(numbers: [] as [Int]) == [] as [Int])\nassert(rolling_max(numbers:\
    \ [1, 2, 3, 4]) == [1, 2, 3, 4])\nassert(rolling_max(numbers: [4, 3, 2, 1]) ==\
    \ [4, 4, 4, 4])\nassert(rolling_max(numbers: [3, 2, 3, 100, 3]) == [3, 3, 3, 100,\
    \ 100])"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659979941
- exit_code: -4
  program: "\n/// From a given array of integers, generate an array of rolling maximum\
    \ element found until given moment\n/// in the sequence.\n/// >>> rolling_max(numbers:\
    \ [1, 2, 3, 2, 3, 4, 2])\n/// [1, 2, 3, 3, 3, 4, 4]\nfunc rolling_max(numbers:\
    \ [Int]) -> [Int] {\n    var results = [Int]()\n    var max = numbers[0]\n   \
    \ results.append(max)\n    for i in 1..<numbers.count {\n        if numbers[i]\
    \ > max {\n            max = numbers[i]\n        }\n        results.append(max)\n\
    \    }\n    return results\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(rolling_max(numbers:\
    \ [] as [Int]) == [] as [Int])\nassert(rolling_max(numbers: [1, 2, 3, 4]) == [1,\
    \ 2, 3, 4])\nassert(rolling_max(numbers: [4, 3, 2, 1]) == [4, 4, 4, 4])\nassert(rolling_max(numbers:\
    \ [3, 2, 3, 100, 3]) == [3, 3, 3, 100, 100])"
  status: Exception
  stderr: 'Swift/ContiguousArrayBuffer.swift:600: Fatal error: Index out of range

    Current stack trace:

    0    libswiftCore.so                    0x00002b64cc32ac80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b64cc021561 <unavailable> + 1434977

    2    libswiftCore.so                    0x00002b64cc021286 <unavailable> + 1434246

    3    libswiftCore.so                    0x00002b64cc02113c <unavailable> + 1433916

    4    libswiftCore.so                    0x00002b64cc020bb0 _assertionFailure(_:_:file:line:flags:)
    + 251

    5    libswiftSwiftOnoneSupport.so       0x00002b64cbe20e83 <unavailable> + 188035

    6    tmpbvma39fx                        0x000055edb0bf1ae8 <unavailable> + 6888

    7    tmpbvma39fx                        0x000055edb0bf15ad <unavailable> + 5549

    8    libc.so.6                          0x00002b64cc516460 __libc_start_main +
    245

    9    tmpbvma39fx                        0x000055edb0bf12b9 <unavailable> + 4793

    '
  stdout: ''
  timestamp: 1659979941
- exit_code: 0
  program: "\n/// From a given array of integers, generate an array of rolling maximum\
    \ element found until given moment\n/// in the sequence.\n/// >>> rolling_max(numbers:\
    \ [1, 2, 3, 2, 3, 4, 2])\n/// [1, 2, 3, 3, 3, 4, 4]\nfunc rolling_max(numbers:\
    \ [Int]) -> [Int] {\n    var maximum = 0\n    var maximums = [Int]()\n    for\
    \ n in numbers {\n        maximum = max(maximum, n)\n        maximums.append(maximum)\n\
    \    }\n    return maximums\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int,\
    \ Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n\
    \    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n          \
    \  return false\n        }\n    }\n    return true\n}\n            \nassert(rolling_max(numbers:\
    \ [] as [Int]) == [] as [Int])\nassert(rolling_max(numbers: [1, 2, 3, 4]) == [1,\
    \ 2, 3, 4])\nassert(rolling_max(numbers: [4, 3, 2, 1]) == [4, 4, 4, 4])\nassert(rolling_max(numbers:\
    \ [3, 2, 3, 100, 3]) == [3, 3, 3, 100, 100])"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659979941
- exit_code: 0
  program: "\n/// From a given array of integers, generate an array of rolling maximum\
    \ element found until given moment\n/// in the sequence.\n/// >>> rolling_max(numbers:\
    \ [1, 2, 3, 2, 3, 4, 2])\n/// [1, 2, 3, 3, 3, 4, 4]\nfunc rolling_max(numbers:\
    \ [Int]) -> [Int] {\n    var buffer = [Int]()\n    var max_value = Int.min\n \
    \   for (index, value) in numbers.enumerated() {\n        if value > max_value\
    \ {\n            max_value = value\n        }\n        buffer.append(max_value)\n\
    \    }\n    return buffer\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(rolling_max(numbers:\
    \ [] as [Int]) == [] as [Int])\nassert(rolling_max(numbers: [1, 2, 3, 4]) == [1,\
    \ 2, 3, 4])\nassert(rolling_max(numbers: [4, 3, 2, 1]) == [4, 4, 4, 4])\nassert(rolling_max(numbers:\
    \ [3, 2, 3, 100, 3]) == [3, 3, 3, 100, 100])"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659979941
- exit_code: -4
  program: "\n/// From a given array of integers, generate an array of rolling maximum\
    \ element found until given moment\n/// in the sequence.\n/// >>> rolling_max(numbers:\
    \ [1, 2, 3, 2, 3, 4, 2])\n/// [1, 2, 3, 3, 3, 4, 4]\nfunc rolling_max(numbers:\
    \ [Int]) -> [Int] {\n    var result = [Int]()\n    result.reserveCapacity(numbers.count)\n\
    \    var max = numbers[0]\n    result.append(max)\n    for number in numbers.dropFirst()\
    \ {\n        max = Swift.max(max, number)\n        result.append(max)\n    }\n\
    \    return result\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) ->\
    \ Bool {\n    if left.count != right.count {\n        return false\n    }\n  \
    \  for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(rolling_max(numbers:\
    \ [] as [Int]) == [] as [Int])\nassert(rolling_max(numbers: [1, 2, 3, 4]) == [1,\
    \ 2, 3, 4])\nassert(rolling_max(numbers: [4, 3, 2, 1]) == [4, 4, 4, 4])\nassert(rolling_max(numbers:\
    \ [3, 2, 3, 100, 3]) == [3, 3, 3, 100, 100])"
  status: Exception
  stderr: 'Swift/ContiguousArrayBuffer.swift:600: Fatal error: Index out of range

    Current stack trace:

    0    libswiftCore.so                    0x00002b3e17cd0c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b3e179c7561 <unavailable> + 1434977

    2    libswiftCore.so                    0x00002b3e179c7286 <unavailable> + 1434246

    3    libswiftCore.so                    0x00002b3e179c713c <unavailable> + 1433916

    4    libswiftCore.so                    0x00002b3e179c6bb0 _assertionFailure(_:_:file:line:flags:)
    + 251

    5    libswiftSwiftOnoneSupport.so       0x00002b3e177c6e83 <unavailable> + 188035

    6    tmpje_v_obs                        0x0000561735b59cd3 <unavailable> + 7379

    7    tmpje_v_obs                        0x0000561735b5977d <unavailable> + 6013

    8    libc.so.6                          0x00002b3e17ebc460 __libc_start_main +
    245

    9    tmpje_v_obs                        0x0000561735b59489 <unavailable> + 5257

    '
  stdout: ''
  timestamp: 1659979941
- exit_code: -4
  program: "\n/// From a given array of integers, generate an array of rolling maximum\
    \ element found until given moment\n/// in the sequence.\n/// >>> rolling_max(numbers:\
    \ [1, 2, 3, 2, 3, 4, 2])\n/// [1, 2, 3, 3, 3, 4, 4]\nfunc rolling_max(numbers:\
    \ [Int]) -> [Int] {\n    var result = [Int]()\n    var maxSoFar = numbers[0]\n\
    \    for number in numbers {\n        if number > maxSoFar {\n            maxSoFar\
    \ = number\n        }\n        result.append(maxSoFar)\n    }\n    return result\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(rolling_max(numbers: [] as [Int]) == [] as [Int])\n\
    assert(rolling_max(numbers: [1, 2, 3, 4]) == [1, 2, 3, 4])\nassert(rolling_max(numbers:\
    \ [4, 3, 2, 1]) == [4, 4, 4, 4])\nassert(rolling_max(numbers: [3, 2, 3, 100, 3])\
    \ == [3, 3, 3, 100, 100])"
  status: Exception
  stderr: 'Swift/ContiguousArrayBuffer.swift:600: Fatal error: Index out of range

    Current stack trace:

    0    libswiftCore.so                    0x00002b8121fd4c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b8121ccb561 <unavailable> + 1434977

    2    libswiftCore.so                    0x00002b8121ccb286 <unavailable> + 1434246

    3    libswiftCore.so                    0x00002b8121ccb13c <unavailable> + 1433916

    4    libswiftCore.so                    0x00002b8121ccabb0 _assertionFailure(_:_:file:line:flags:)
    + 251

    5    libswiftSwiftOnoneSupport.so       0x00002b8121acae83 <unavailable> + 188035

    6    tmpk6yw3oca                        0x000055d088d5da5f <unavailable> + 6751

    7    tmpk6yw3oca                        0x000055d088d5d52d <unavailable> + 5421

    8    libc.so.6                          0x00002b81221c0460 __libc_start_main +
    245

    9    tmpk6yw3oca                        0x000055d088d5d239 <unavailable> + 4665

    '
  stdout: ''
  timestamp: 1659979941
- exit_code: 0
  program: "\n/// From a given array of integers, generate an array of rolling maximum\
    \ element found until given moment\n/// in the sequence.\n/// >>> rolling_max(numbers:\
    \ [1, 2, 3, 2, 3, 4, 2])\n/// [1, 2, 3, 3, 3, 4, 4]\nfunc rolling_max(numbers:\
    \ [Int]) -> [Int] {\n    var result = [Int]()\n    var max = 0\n    for number\
    \ in numbers {\n        if number > max {\n            max = number\n        }\n\
    \        result.append(max)\n    }\n    return result\n}\n\n\nfunc ==(left: [(Int,\
    \ Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n\
    \        return false\n    }\n    for (l, r) in zip(left, right) {\n        if\
    \ l != r {\n            return false\n        }\n    }\n    return true\n}\n \
    \           \nassert(rolling_max(numbers: [] as [Int]) == [] as [Int])\nassert(rolling_max(numbers:\
    \ [1, 2, 3, 4]) == [1, 2, 3, 4])\nassert(rolling_max(numbers: [4, 3, 2, 1]) ==\
    \ [4, 4, 4, 4])\nassert(rolling_max(numbers: [3, 2, 3, 100, 3]) == [3, 3, 3, 100,\
    \ 100])"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659979941
- exit_code: -4
  program: "\n/// From a given array of integers, generate an array of rolling maximum\
    \ element found until given moment\n/// in the sequence.\n/// >>> rolling_max(numbers:\
    \ [1, 2, 3, 2, 3, 4, 2])\n/// [1, 2, 3, 3, 3, 4, 4]\nfunc rolling_max(numbers:\
    \ [Int]) -> [Int] {\n    let n = numbers.count\n    var max_element = [Int](repeating:\
    \ 0, count: n)\n    max_element[0] = numbers[0]\n    for i in 1..<n {\n      \
    \  max_element[i] = max(max_element[i - 1], numbers[i])\n    }\n    return max_element\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(rolling_max(numbers: [] as [Int]) == [] as [Int])\n\
    assert(rolling_max(numbers: [1, 2, 3, 4]) == [1, 2, 3, 4])\nassert(rolling_max(numbers:\
    \ [4, 3, 2, 1]) == [4, 4, 4, 4])\nassert(rolling_max(numbers: [3, 2, 3, 100, 3])\
    \ == [3, 3, 3, 100, 100])"
  status: Exception
  stderr: 'Swift/ContiguousArrayBuffer.swift:600: Fatal error: Index out of range

    Current stack trace:

    0    libswiftCore.so                    0x00002b8f3698ec80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b8f36685561 <unavailable> + 1434977

    2    libswiftCore.so                    0x00002b8f36685286 <unavailable> + 1434246

    3    libswiftCore.so                    0x00002b8f3668513c <unavailable> + 1433916

    4    libswiftCore.so                    0x00002b8f36684bb0 _assertionFailure(_:_:file:line:flags:)
    + 251

    5    libswiftSwiftOnoneSupport.so       0x00002b8f36484e83 <unavailable> + 188035

    6    tmp590f8bqn                        0x00005624db0afb9a <unavailable> + 7066

    7    tmp590f8bqn                        0x00005624db0af63d <unavailable> + 5693

    8    libc.so.6                          0x00002b8f36b7a460 __libc_start_main +
    245

    9    tmp590f8bqn                        0x00005624db0af349 <unavailable> + 4937

    '
  stdout: ''
  timestamp: 1659979941
- exit_code: 0
  program: "\n/// From a given array of integers, generate an array of rolling maximum\
    \ element found until given moment\n/// in the sequence.\n/// >>> rolling_max(numbers:\
    \ [1, 2, 3, 2, 3, 4, 2])\n/// [1, 2, 3, 3, 3, 4, 4]\nfunc rolling_max(numbers:\
    \ [Int]) -> [Int] {\n  guard !numbers.isEmpty else { return [] }\n  guard numbers.count\
    \ > 1 else { return numbers }\n  \n  var result = [Int]()\n  result.append(numbers[0])\n\
    \  \n  for i in 1..<numbers.count {\n    result.append(max(result[i - 1], numbers[i]))\n\
    \  }\n  \n  return result\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(rolling_max(numbers:\
    \ [] as [Int]) == [] as [Int])\nassert(rolling_max(numbers: [1, 2, 3, 4]) == [1,\
    \ 2, 3, 4])\nassert(rolling_max(numbers: [4, 3, 2, 1]) == [4, 4, 4, 4])\nassert(rolling_max(numbers:\
    \ [3, 2, 3, 100, 3]) == [3, 3, 3, 100, 100])"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659979941
- exit_code: 0
  program: "\n/// From a given array of integers, generate an array of rolling maximum\
    \ element found until given moment\n/// in the sequence.\n/// >>> rolling_max(numbers:\
    \ [1, 2, 3, 2, 3, 4, 2])\n/// [1, 2, 3, 3, 3, 4, 4]\nfunc rolling_max(numbers:\
    \ [Int]) -> [Int] {\n    var max_number = 0\n    var max_numbers = [Int]()\n \
    \   for number in numbers {\n        max_number = max(max_number, number)\n  \
    \      max_numbers.append(max_number)\n    }\n    return max_numbers\n}\n\n\n\
    func ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(rolling_max(numbers: [] as [Int]) == [] as [Int])\n\
    assert(rolling_max(numbers: [1, 2, 3, 4]) == [1, 2, 3, 4])\nassert(rolling_max(numbers:\
    \ [4, 3, 2, 1]) == [4, 4, 4, 4])\nassert(rolling_max(numbers: [3, 2, 3, 100, 3])\
    \ == [3, 3, 3, 100, 100])"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659979941
- exit_code: -4
  program: "\n/// From a given array of integers, generate an array of rolling maximum\
    \ element found until given moment\n/// in the sequence.\n/// >>> rolling_max(numbers:\
    \ [1, 2, 3, 2, 3, 4, 2])\n/// [1, 2, 3, 3, 3, 4, 4]\nfunc rolling_max(numbers:\
    \ [Int]) -> [Int] {\n    var result = Array(repeating: 0, count: numbers.count)\n\
    \    result[0] = numbers[0]\n    for (i, _) in numbers.enumerated() {\n      \
    \  if i == 0 {\n            continue\n        }\n        result[i] = max(result[i\
    \ - 1], numbers[i])\n    }\n    return result\n}\n\n\nfunc ==(left: [(Int, Int)],\
    \ right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n       \
    \ return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r\
    \ {\n            return false\n        }\n    }\n    return true\n}\n        \
    \    \nassert(rolling_max(numbers: [] as [Int]) == [] as [Int])\nassert(rolling_max(numbers:\
    \ [1, 2, 3, 4]) == [1, 2, 3, 4])\nassert(rolling_max(numbers: [4, 3, 2, 1]) ==\
    \ [4, 4, 4, 4])\nassert(rolling_max(numbers: [3, 2, 3, 100, 3]) == [3, 3, 3, 100,\
    \ 100])"
  status: Exception
  stderr: 'Swift/ContiguousArrayBuffer.swift:600: Fatal error: Index out of range

    Current stack trace:

    0    libswiftCore.so                    0x00002b863963dc80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b8639334561 <unavailable> + 1434977

    2    libswiftCore.so                    0x00002b8639334286 <unavailable> + 1434246

    3    libswiftCore.so                    0x00002b863933413c <unavailable> + 1433916

    4    libswiftCore.so                    0x00002b8639333bb0 _assertionFailure(_:_:file:line:flags:)
    + 251

    5    libswiftSwiftOnoneSupport.so       0x00002b8639133e83 <unavailable> + 188035

    6    tmpsec0y87u                        0x0000563374713c0f <unavailable> + 7183

    7    tmpsec0y87u                        0x00005633747136cd <unavailable> + 5837

    8    libc.so.6                          0x00002b8639829460 __libc_start_main +
    245

    9    tmpsec0y87u                        0x00005633747133d9 <unavailable> + 5081

    '
  stdout: ''
  timestamp: 1659979941
- exit_code: 0
  program: "\n/// From a given array of integers, generate an array of rolling maximum\
    \ element found until given moment\n/// in the sequence.\n/// >>> rolling_max(numbers:\
    \ [1, 2, 3, 2, 3, 4, 2])\n/// [1, 2, 3, 3, 3, 4, 4]\nfunc rolling_max(numbers:\
    \ [Int]) -> [Int] {\n  var rolling_max = [Int]()\n  var maximum = Int.min\n  for\
    \ number in numbers {\n    maximum = max(maximum, number)\n    rolling_max.append(maximum)\n\
    \  }\n  return rolling_max\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(rolling_max(numbers:\
    \ [] as [Int]) == [] as [Int])\nassert(rolling_max(numbers: [1, 2, 3, 4]) == [1,\
    \ 2, 3, 4])\nassert(rolling_max(numbers: [4, 3, 2, 1]) == [4, 4, 4, 4])\nassert(rolling_max(numbers:\
    \ [3, 2, 3, 100, 3]) == [3, 3, 3, 100, 100])"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659979941
- exit_code: 0
  program: "\n/// From a given array of integers, generate an array of rolling maximum\
    \ element found until given moment\n/// in the sequence.\n/// >>> rolling_max(numbers:\
    \ [1, 2, 3, 2, 3, 4, 2])\n/// [1, 2, 3, 3, 3, 4, 4]\nfunc rolling_max(numbers:\
    \ [Int]) -> [Int] {\n    var max = 0\n    var result = [Int]()\n    numbers.forEach({\n\
    \        max = Swift.max(max, $0)\n        result.append(max)\n    })\n    return\
    \ result\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n\
    \    if left.count != right.count {\n        return false\n    }\n    for (l,\
    \ r) in zip(left, right) {\n        if l != r {\n            return false\n  \
    \      }\n    }\n    return true\n}\n            \nassert(rolling_max(numbers:\
    \ [] as [Int]) == [] as [Int])\nassert(rolling_max(numbers: [1, 2, 3, 4]) == [1,\
    \ 2, 3, 4])\nassert(rolling_max(numbers: [4, 3, 2, 1]) == [4, 4, 4, 4])\nassert(rolling_max(numbers:\
    \ [3, 2, 3, 100, 3]) == [3, 3, 3, 100, 100])"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659979941
- exit_code: 1
  program: "\n/// From a given array of integers, generate an array of rolling maximum\
    \ element found until given moment\n/// in the sequence.\n/// >>> rolling_max(numbers:\
    \ [1, 2, 3, 2, 3, 4, 2])\n/// [1, 2, 3, 3, 3, 4, 4]\nfunc rolling_max(numbers:\
    \ [Int]) -> [Int] {\n  guard !numbers.isEmpty else { return [] }\n  var stack\
    \ = Stack<Int>()\n  var result = [Int]()\n  for (index, number) in numbers.enumerated()\
    \ {\n    while let last = stack.peek(), last < number {\n      stack.pop()\n \
    \   }\n    stack.push(number)\n    result.append(stack.peek() ?? 0)\n  }\n  return\
    \ result\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n\
    \    if left.count != right.count {\n        return false\n    }\n    for (l,\
    \ r) in zip(left, right) {\n        if l != r {\n            return false\n  \
    \      }\n    }\n    return true\n}\n            \nassert(rolling_max(numbers:\
    \ [] as [Int]) == [] as [Int])\nassert(rolling_max(numbers: [1, 2, 3, 4]) == [1,\
    \ 2, 3, 4])\nassert(rolling_max(numbers: [4, 3, 2, 1]) == [4, 4, 4, 4])\nassert(rolling_max(numbers:\
    \ [3, 2, 3, 100, 3]) == [3, 3, 3, 100, 100])"
  status: SyntaxError
  stderr: "/tmp/tmpkm3lb_x6.swift:8:15: error: cannot find 'Stack' in scope\n  var\
    \ stack = Stack<Int>()\n              ^~~~~\n"
  stdout: ''
  timestamp: 1659979941
- exit_code: -4
  program: "\n/// From a given array of integers, generate an array of rolling maximum\
    \ element found until given moment\n/// in the sequence.\n/// >>> rolling_max(numbers:\
    \ [1, 2, 3, 2, 3, 4, 2])\n/// [1, 2, 3, 3, 3, 4, 4]\nfunc rolling_max(numbers:\
    \ [Int]) -> [Int] {\n    var maxSoFar = numbers[0]\n    var maxes = [Int]()\n\
    \    for idx in 0..<numbers.count {\n        maxSoFar = max(maxSoFar, numbers[idx])\n\
    \        maxes.append(maxSoFar)\n    }\n    return maxes\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(rolling_max(numbers: [] as [Int]) == [] as [Int])\nassert(rolling_max(numbers:\
    \ [1, 2, 3, 4]) == [1, 2, 3, 4])\nassert(rolling_max(numbers: [4, 3, 2, 1]) ==\
    \ [4, 4, 4, 4])\nassert(rolling_max(numbers: [3, 2, 3, 100, 3]) == [3, 3, 3, 100,\
    \ 100])"
  status: Exception
  stderr: 'Swift/ContiguousArrayBuffer.swift:600: Fatal error: Index out of range

    Current stack trace:

    0    libswiftCore.so                    0x00002b5ac373dc80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b5ac3434561 <unavailable> + 1434977

    2    libswiftCore.so                    0x00002b5ac3434286 <unavailable> + 1434246

    3    libswiftCore.so                    0x00002b5ac343413c <unavailable> + 1433916

    4    libswiftCore.so                    0x00002b5ac3433bb0 _assertionFailure(_:_:file:line:flags:)
    + 251

    5    libswiftSwiftOnoneSupport.so       0x00002b5ac3233e83 <unavailable> + 188035

    6    tmpdhp0ll9a                        0x000055ae0b155b58 <unavailable> + 7000

    7    tmpdhp0ll9a                        0x000055ae0b15562d <unavailable> + 5677

    8    libc.so.6                          0x00002b5ac3929460 __libc_start_main +
    245

    9    tmpdhp0ll9a                        0x000055ae0b155339 <unavailable> + 4921

    '
  stdout: ''
  timestamp: 1659979941
- exit_code: 0
  program: "\n/// From a given array of integers, generate an array of rolling maximum\
    \ element found until given moment\n/// in the sequence.\n/// >>> rolling_max(numbers:\
    \ [1, 2, 3, 2, 3, 4, 2])\n/// [1, 2, 3, 3, 3, 4, 4]\nfunc rolling_max(numbers:\
    \ [Int]) -> [Int] {\n    var maximum: Int = 0\n    var maxima: [Int] = []\n  \
    \  for index in 0..<numbers.count {\n        let number = numbers[index]\n   \
    \     maximum = max(maximum, number)\n        maxima.append(maximum)\n    }\n\
    \    return maxima\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) ->\
    \ Bool {\n    if left.count != right.count {\n        return false\n    }\n  \
    \  for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(rolling_max(numbers:\
    \ [] as [Int]) == [] as [Int])\nassert(rolling_max(numbers: [1, 2, 3, 4]) == [1,\
    \ 2, 3, 4])\nassert(rolling_max(numbers: [4, 3, 2, 1]) == [4, 4, 4, 4])\nassert(rolling_max(numbers:\
    \ [3, 2, 3, 100, 3]) == [3, 3, 3, 100, 100])"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659979941
- exit_code: -4
  program: "\n/// From a given array of integers, generate an array of rolling maximum\
    \ element found until given moment\n/// in the sequence.\n/// >>> rolling_max(numbers:\
    \ [1, 2, 3, 2, 3, 4, 2])\n/// [1, 2, 3, 3, 3, 4, 4]\nfunc rolling_max(numbers:\
    \ [Int]) -> [Int] {\n    // initialize first element to the first element of the\
    \ array\n    var max = numbers[0]\n    var maxes = [max]\n    \n    // iterate\
    \ over the array starting from the second element\n    for number in numbers[1..<numbers.count]\
    \ {\n        // if the number is greater than the previous one, then update the\
    \ max\n        if number > max {\n            max = number\n        }\n      \
    \  // append the current max to the maxes array\n        maxes.append(max)\n \
    \   }\n    \n    return maxes\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int,\
    \ Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n\
    \    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n          \
    \  return false\n        }\n    }\n    return true\n}\n            \nassert(rolling_max(numbers:\
    \ [] as [Int]) == [] as [Int])\nassert(rolling_max(numbers: [1, 2, 3, 4]) == [1,\
    \ 2, 3, 4])\nassert(rolling_max(numbers: [4, 3, 2, 1]) == [4, 4, 4, 4])\nassert(rolling_max(numbers:\
    \ [3, 2, 3, 100, 3]) == [3, 3, 3, 100, 100])"
  status: Exception
  stderr: 'Swift/ContiguousArrayBuffer.swift:600: Fatal error: Index out of range

    Current stack trace:

    0    libswiftCore.so                    0x00002b9545c23c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b954591a561 <unavailable> + 1434977

    2    libswiftCore.so                    0x00002b954591a286 <unavailable> + 1434246

    3    libswiftCore.so                    0x00002b954591a13c <unavailable> + 1433916

    4    libswiftCore.so                    0x00002b9545919bb0 _assertionFailure(_:_:file:line:flags:)
    + 251

    5    libswiftSwiftOnoneSupport.so       0x00002b9545719e83 <unavailable> + 188035

    6    tmp08jnobtb                        0x00005610e34e2ba8 <unavailable> + 7080

    7    tmp08jnobtb                        0x00005610e34e267d <unavailable> + 5757

    8    libc.so.6                          0x00002b9545e0f460 __libc_start_main +
    245

    9    tmp08jnobtb                        0x00005610e34e2389 <unavailable> + 5001

    '
  stdout: ''
  timestamp: 1659979941
- exit_code: 0
  program: "\n/// From a given array of integers, generate an array of rolling maximum\
    \ element found until given moment\n/// in the sequence.\n/// >>> rolling_max(numbers:\
    \ [1, 2, 3, 2, 3, 4, 2])\n/// [1, 2, 3, 3, 3, 4, 4]\nfunc rolling_max(numbers:\
    \ [Int]) -> [Int] {\n    var res = [Int]()\n    var max_val = Int.min\n    for\
    \ x in numbers {\n        if x > max_val {\n            max_val = x\n        }\n\
    \        res.append(max_val)\n    }\n    return res\n}\n\n\nfunc ==(left: [(Int,\
    \ Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n\
    \        return false\n    }\n    for (l, r) in zip(left, right) {\n        if\
    \ l != r {\n            return false\n        }\n    }\n    return true\n}\n \
    \           \nassert(rolling_max(numbers: [] as [Int]) == [] as [Int])\nassert(rolling_max(numbers:\
    \ [1, 2, 3, 4]) == [1, 2, 3, 4])\nassert(rolling_max(numbers: [4, 3, 2, 1]) ==\
    \ [4, 4, 4, 4])\nassert(rolling_max(numbers: [3, 2, 3, 100, 3]) == [3, 3, 3, 100,\
    \ 100])"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659979941
- exit_code: -4
  program: "\n/// From a given array of integers, generate an array of rolling maximum\
    \ element found until given moment\n/// in the sequence.\n/// >>> rolling_max(numbers:\
    \ [1, 2, 3, 2, 3, 4, 2])\n/// [1, 2, 3, 3, 3, 4, 4]\nfunc rolling_max(numbers:\
    \ [Int]) -> [Int] {\n    var result = [Int]()\n    var max_so_far = numbers[0]\n\
    \    result.append(max_so_far)\n    for i in 1..<numbers.count {\n        if max_so_far\
    \ < numbers[i] {\n            max_so_far = numbers[i]\n        }\n        result.append(max_so_far)\n\
    \    }\n    return result\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(rolling_max(numbers:\
    \ [] as [Int]) == [] as [Int])\nassert(rolling_max(numbers: [1, 2, 3, 4]) == [1,\
    \ 2, 3, 4])\nassert(rolling_max(numbers: [4, 3, 2, 1]) == [4, 4, 4, 4])\nassert(rolling_max(numbers:\
    \ [3, 2, 3, 100, 3]) == [3, 3, 3, 100, 100])"
  status: Exception
  stderr: 'Swift/ContiguousArrayBuffer.swift:600: Fatal error: Index out of range

    Current stack trace:

    0    libswiftCore.so                    0x00002abf4979ac80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002abf49491561 <unavailable> + 1434977

    2    libswiftCore.so                    0x00002abf49491286 <unavailable> + 1434246

    3    libswiftCore.so                    0x00002abf4949113c <unavailable> + 1433916

    4    libswiftCore.so                    0x00002abf49490bb0 _assertionFailure(_:_:file:line:flags:)
    + 251

    5    libswiftSwiftOnoneSupport.so       0x00002abf49290e83 <unavailable> + 188035

    6    tmppbbt5z70                        0x000055946fd44ae8 <unavailable> + 6888

    7    tmppbbt5z70                        0x000055946fd445ad <unavailable> + 5549

    8    libc.so.6                          0x00002abf49986460 __libc_start_main +
    245

    9    tmppbbt5z70                        0x000055946fd442b9 <unavailable> + 4793

    '
  stdout: ''
  timestamp: 1659979941
- exit_code: 0
  program: "\n/// From a given array of integers, generate an array of rolling maximum\
    \ element found until given moment\n/// in the sequence.\n/// >>> rolling_max(numbers:\
    \ [1, 2, 3, 2, 3, 4, 2])\n/// [1, 2, 3, 3, 3, 4, 4]\nfunc rolling_max(numbers:\
    \ [Int]) -> [Int] {\n    var max_so_far = 0\n    var result = [Int]()\n    for\
    \ item in numbers {\n        max_so_far = max(max_so_far, item)\n        result.append(max_so_far)\n\
    \    }\n    return result\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(rolling_max(numbers:\
    \ [] as [Int]) == [] as [Int])\nassert(rolling_max(numbers: [1, 2, 3, 4]) == [1,\
    \ 2, 3, 4])\nassert(rolling_max(numbers: [4, 3, 2, 1]) == [4, 4, 4, 4])\nassert(rolling_max(numbers:\
    \ [3, 2, 3, 100, 3]) == [3, 3, 3, 100, 100])"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659979941
- exit_code: 0
  program: "\n/// From a given array of integers, generate an array of rolling maximum\
    \ element found until given moment\n/// in the sequence.\n/// >>> rolling_max(numbers:\
    \ [1, 2, 3, 2, 3, 4, 2])\n/// [1, 2, 3, 3, 3, 4, 4]\nfunc rolling_max(numbers:\
    \ [Int]) -> [Int] {\n    var result = [Int]()\n    var currentMax = 0\n    for\
    \ number in numbers {\n        if number > currentMax {\n            currentMax\
    \ = number\n        }\n        result.append(currentMax)\n    }\n    return result\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(rolling_max(numbers: [] as [Int]) == [] as [Int])\n\
    assert(rolling_max(numbers: [1, 2, 3, 4]) == [1, 2, 3, 4])\nassert(rolling_max(numbers:\
    \ [4, 3, 2, 1]) == [4, 4, 4, 4])\nassert(rolling_max(numbers: [3, 2, 3, 100, 3])\
    \ == [3, 3, 3, 100, 100])"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659979941
- exit_code: -4
  program: "\n/// From a given array of integers, generate an array of rolling maximum\
    \ element found until given moment\n/// in the sequence.\n/// >>> rolling_max(numbers:\
    \ [1, 2, 3, 2, 3, 4, 2])\n/// [1, 2, 3, 3, 3, 4, 4]\nfunc rolling_max(numbers:\
    \ [Int]) -> [Int] {\n    var rolling_max = numbers.map { $0 }\n    for i in 1..<numbers.count\
    \ {\n        rolling_max[i] = max(rolling_max[i - 1], rolling_max[i])\n    }\n\
    \    return rolling_max\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(rolling_max(numbers:\
    \ [] as [Int]) == [] as [Int])\nassert(rolling_max(numbers: [1, 2, 3, 4]) == [1,\
    \ 2, 3, 4])\nassert(rolling_max(numbers: [4, 3, 2, 1]) == [4, 4, 4, 4])\nassert(rolling_max(numbers:\
    \ [3, 2, 3, 100, 3]) == [3, 3, 3, 100, 100])"
  status: Exception
  stderr: 'Swift/Range.swift:743: Fatal error: Range requires lowerBound <= upperBound

    Current stack trace:

    0    libswiftCore.so                    0x00002b29c2f8dc80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b29c2c84561 <unavailable> + 1434977

    2    libswiftCore.so                    0x00002b29c2c84286 <unavailable> + 1434246

    3    libswiftCore.so                    0x00002b29c2c8413c <unavailable> + 1433916

    4    libswiftCore.so                    0x00002b29c2c83bb0 _assertionFailure(_:_:file:line:flags:)
    + 251

    5    tmppj3s_ij8                        0x0000556147d8dcab <unavailable> + 7339

    6    tmppj3s_ij8                        0x0000556147d8d68d <unavailable> + 5773

    7    libc.so.6                          0x00002b29c3179460 __libc_start_main +
    245

    8    tmppj3s_ij8                        0x0000556147d8d399 <unavailable> + 5017

    '
  stdout: ''
  timestamp: 1659979941
- exit_code: -4
  program: "\n/// From a given array of integers, generate an array of rolling maximum\
    \ element found until given moment\n/// in the sequence.\n/// >>> rolling_max(numbers:\
    \ [1, 2, 3, 2, 3, 4, 2])\n/// [1, 2, 3, 3, 3, 4, 4]\nfunc rolling_max(numbers:\
    \ [Int]) -> [Int] {\n    var max_so_far = 0\n    var current_max = 0\n    var\
    \ result = [Int]()\n    for i in 0..<numbers.count {\n        current_max = max(numbers[i],\
    \ current_max + numbers[i])\n        max_so_far = max(max_so_far, current_max)\n\
    \        result.append(max_so_far)\n    }\n    return result\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(rolling_max(numbers: [] as [Int]) == [] as [Int])\nassert(rolling_max(numbers:\
    \ [1, 2, 3, 4]) == [1, 2, 3, 4])\nassert(rolling_max(numbers: [4, 3, 2, 1]) ==\
    \ [4, 4, 4, 4])\nassert(rolling_max(numbers: [3, 2, 3, 100, 3]) == [3, 3, 3, 100,\
    \ 100])"
  status: Exception
  stderr: 'tmp3jxmtwxb/tmp3jxmtwxb.swift:32: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b5eca68ec80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b5eca385b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b5eca385988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b5eca3847b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmp3jxmtwxb                        0x000055659c77b81d <unavailable> + 6173

    5    libc.so.6                          0x00002b5eca87a460 __libc_start_main +
    245

    6    tmp3jxmtwxb                        0x000055659c77b339 <unavailable> + 4921

    '
  stdout: ''
  timestamp: 1659979941
- exit_code: 0
  program: "\n/// From a given array of integers, generate an array of rolling maximum\
    \ element found until given moment\n/// in the sequence.\n/// >>> rolling_max(numbers:\
    \ [1, 2, 3, 2, 3, 4, 2])\n/// [1, 2, 3, 3, 3, 4, 4]\nfunc rolling_max(numbers:\
    \ [Int]) -> [Int] {\n    var max_to_moment = [Int]()\n    for (index, number)\
    \ in numbers.enumerated() {\n        if index == 0 {\n            max_to_moment.append(number)\n\
    \        } else {\n            let max_so_far = max_to_moment[index - 1]\n   \
    \         max_to_moment.append(max(max_so_far, number))\n        }\n    }\n  \
    \  return max_to_moment\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(rolling_max(numbers:\
    \ [] as [Int]) == [] as [Int])\nassert(rolling_max(numbers: [1, 2, 3, 4]) == [1,\
    \ 2, 3, 4])\nassert(rolling_max(numbers: [4, 3, 2, 1]) == [4, 4, 4, 4])\nassert(rolling_max(numbers:\
    \ [3, 2, 3, 100, 3]) == [3, 3, 3, 100, 100])"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659979941
- exit_code: -4
  program: "\n/// From a given array of integers, generate an array of rolling maximum\
    \ element found until given moment\n/// in the sequence.\n/// >>> rolling_max(numbers:\
    \ [1, 2, 3, 2, 3, 4, 2])\n/// [1, 2, 3, 3, 3, 4, 4]\nfunc rolling_max(numbers:\
    \ [Int]) -> [Int] {\n    var index = 0\n    var max = numbers[0]\n    return numbers.map\
    \ { value in\n        if value > max {\n            max = value\n        }\n \
    \       return max\n    }\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(rolling_max(numbers:\
    \ [] as [Int]) == [] as [Int])\nassert(rolling_max(numbers: [1, 2, 3, 4]) == [1,\
    \ 2, 3, 4])\nassert(rolling_max(numbers: [4, 3, 2, 1]) == [4, 4, 4, 4])\nassert(rolling_max(numbers:\
    \ [3, 2, 3, 100, 3]) == [3, 3, 3, 100, 100])"
  status: Exception
  stderr: 'Swift/ContiguousArrayBuffer.swift:600: Fatal error: Index out of range

    Current stack trace:

    0    libswiftCore.so                    0x00002b996846cc80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b9968163561 <unavailable> + 1434977

    2    libswiftCore.so                    0x00002b9968163286 <unavailable> + 1434246

    3    libswiftCore.so                    0x00002b996816313c <unavailable> + 1433916

    4    libswiftCore.so                    0x00002b9968162bb0 _assertionFailure(_:_:file:line:flags:)
    + 251

    5    libswiftSwiftOnoneSupport.so       0x00002b9967f62e83 <unavailable> + 188035

    6    tmpd449ikd0                        0x0000563702ee18b4 <unavailable> + 6324

    7    tmpd449ikd0                        0x0000563702ee13bd <unavailable> + 5053

    8    libc.so.6                          0x00002b9968658460 __libc_start_main +
    245

    9    tmpd449ikd0                        0x0000563702ee10c9 <unavailable> + 4297

    '
  stdout: ''
  timestamp: 1659979941
- exit_code: -4
  program: "\n/// From a given array of integers, generate an array of rolling maximum\
    \ element found until given moment\n/// in the sequence.\n/// >>> rolling_max(numbers:\
    \ [1, 2, 3, 2, 3, 4, 2])\n/// [1, 2, 3, 3, 3, 4, 4]\nfunc rolling_max(numbers:\
    \ [Int]) -> [Int] {\n    var result = [Int]()\n    var maxElement = numbers[0]\n\
    \    for i in 0..<numbers.count {\n        maxElement = Swift.max(maxElement,\
    \ numbers[i])\n        result.append(maxElement)\n    }\n    return result\n}\n\
    \n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(rolling_max(numbers: [] as [Int]) == [] as [Int])\n\
    assert(rolling_max(numbers: [1, 2, 3, 4]) == [1, 2, 3, 4])\nassert(rolling_max(numbers:\
    \ [4, 3, 2, 1]) == [4, 4, 4, 4])\nassert(rolling_max(numbers: [3, 2, 3, 100, 3])\
    \ == [3, 3, 3, 100, 100])"
  status: Exception
  stderr: 'Swift/ContiguousArrayBuffer.swift:600: Fatal error: Index out of range

    Current stack trace:

    0    libswiftCore.so                    0x00002ae1e295ac80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002ae1e2651561 <unavailable> + 1434977

    2    libswiftCore.so                    0x00002ae1e2651286 <unavailable> + 1434246

    3    libswiftCore.so                    0x00002ae1e265113c <unavailable> + 1433916

    4    libswiftCore.so                    0x00002ae1e2650bb0 _assertionFailure(_:_:file:line:flags:)
    + 251

    5    libswiftSwiftOnoneSupport.so       0x00002ae1e2450e83 <unavailable> + 188035

    6    tmpr_fr9ij3                        0x000055d679d85b68 <unavailable> + 7016

    7    tmpr_fr9ij3                        0x000055d679d8562d <unavailable> + 5677

    8    libc.so.6                          0x00002ae1e2b46460 __libc_start_main +
    245

    9    tmpr_fr9ij3                        0x000055d679d85339 <unavailable> + 4921

    '
  stdout: ''
  timestamp: 1659979941
- exit_code: 0
  program: "\n/// From a given array of integers, generate an array of rolling maximum\
    \ element found until given moment\n/// in the sequence.\n/// >>> rolling_max(numbers:\
    \ [1, 2, 3, 2, 3, 4, 2])\n/// [1, 2, 3, 3, 3, 4, 4]\nfunc rolling_max(numbers:\
    \ [Int]) -> [Int] {\n    guard numbers.count > 0 else { return [] }\n    var result\
    \ = [Int]()\n    result.append(numbers[0])\n    for i in 1..<numbers.count {\n\
    \        result.append(max(result[i - 1], numbers[i]))\n    }\n    return result\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(rolling_max(numbers: [] as [Int]) == [] as [Int])\n\
    assert(rolling_max(numbers: [1, 2, 3, 4]) == [1, 2, 3, 4])\nassert(rolling_max(numbers:\
    \ [4, 3, 2, 1]) == [4, 4, 4, 4])\nassert(rolling_max(numbers: [3, 2, 3, 100, 3])\
    \ == [3, 3, 3, 100, 100])"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659979941
- exit_code: -4
  program: "\n/// From a given array of integers, generate an array of rolling maximum\
    \ element found until given moment\n/// in the sequence.\n/// >>> rolling_max(numbers:\
    \ [1, 2, 3, 2, 3, 4, 2])\n/// [1, 2, 3, 3, 3, 4, 4]\nfunc rolling_max(numbers:\
    \ [Int]) -> [Int] {\n    var maximum = numbers[0]\n    var result = [Int]()\n\
    \    for number in numbers {\n        maximum = max(maximum, number)\n       \
    \ result.append(maximum)\n    }\n    return result\n}\n\n\nfunc ==(left: [(Int,\
    \ Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n\
    \        return false\n    }\n    for (l, r) in zip(left, right) {\n        if\
    \ l != r {\n            return false\n        }\n    }\n    return true\n}\n \
    \           \nassert(rolling_max(numbers: [] as [Int]) == [] as [Int])\nassert(rolling_max(numbers:\
    \ [1, 2, 3, 4]) == [1, 2, 3, 4])\nassert(rolling_max(numbers: [4, 3, 2, 1]) ==\
    \ [4, 4, 4, 4])\nassert(rolling_max(numbers: [3, 2, 3, 100, 3]) == [3, 3, 3, 100,\
    \ 100])"
  status: Exception
  stderr: 'Swift/ContiguousArrayBuffer.swift:600: Fatal error: Index out of range

    Current stack trace:

    0    libswiftCore.so                    0x00002b0b14d1bc80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b0b14a12561 <unavailable> + 1434977

    2    libswiftCore.so                    0x00002b0b14a12286 <unavailable> + 1434246

    3    libswiftCore.so                    0x00002b0b14a1213c <unavailable> + 1433916

    4    libswiftCore.so                    0x00002b0b14a11bb0 _assertionFailure(_:_:file:line:flags:)
    + 251

    5    libswiftSwiftOnoneSupport.so       0x00002b0b14811e83 <unavailable> + 188035

    6    tmpxtmuyeu2                        0x000055cbc57c1ae8 <unavailable> + 6888

    7    tmpxtmuyeu2                        0x000055cbc57c15bd <unavailable> + 5565

    8    libc.so.6                          0x00002b0b14f07460 __libc_start_main +
    245

    9    tmpxtmuyeu2                        0x000055cbc57c12c9 <unavailable> + 4809

    '
  stdout: ''
  timestamp: 1659979941
- exit_code: 0
  program: "\n/// From a given array of integers, generate an array of rolling maximum\
    \ element found until given moment\n/// in the sequence.\n/// >>> rolling_max(numbers:\
    \ [1, 2, 3, 2, 3, 4, 2])\n/// [1, 2, 3, 3, 3, 4, 4]\nfunc rolling_max(numbers:\
    \ [Int]) -> [Int] {\n    var output: [Int] = []\n    var max_so_far = Int.min\n\
    \    for number in numbers {\n        max_so_far = max(max_so_far, number)\n \
    \       output.append(max_so_far)\n    }\n    return output\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(rolling_max(numbers: [] as [Int]) == [] as [Int])\nassert(rolling_max(numbers:\
    \ [1, 2, 3, 4]) == [1, 2, 3, 4])\nassert(rolling_max(numbers: [4, 3, 2, 1]) ==\
    \ [4, 4, 4, 4])\nassert(rolling_max(numbers: [3, 2, 3, 100, 3]) == [3, 3, 3, 100,\
    \ 100])"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659979941
- exit_code: 0
  program: "\n/// From a given array of integers, generate an array of rolling maximum\
    \ element found until given moment\n/// in the sequence.\n/// >>> rolling_max(numbers:\
    \ [1, 2, 3, 2, 3, 4, 2])\n/// [1, 2, 3, 3, 3, 4, 4]\nfunc rolling_max(numbers:\
    \ [Int]) -> [Int] {\n    var result = [Int]()\n    var maxNum = Int.min\n    for\
    \ num in numbers {\n        maxNum = max(maxNum, num)\n        result.append(maxNum)\n\
    \    }\n    return result\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(rolling_max(numbers:\
    \ [] as [Int]) == [] as [Int])\nassert(rolling_max(numbers: [1, 2, 3, 4]) == [1,\
    \ 2, 3, 4])\nassert(rolling_max(numbers: [4, 3, 2, 1]) == [4, 4, 4, 4])\nassert(rolling_max(numbers:\
    \ [3, 2, 3, 100, 3]) == [3, 3, 3, 100, 100])"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659979941
- exit_code: 0
  program: "\n/// From a given array of integers, generate an array of rolling maximum\
    \ element found until given moment\n/// in the sequence.\n/// >>> rolling_max(numbers:\
    \ [1, 2, 3, 2, 3, 4, 2])\n/// [1, 2, 3, 3, 3, 4, 4]\nfunc rolling_max(numbers:\
    \ [Int]) -> [Int] {\n    var result = [Int]()\n    for (i, _) in numbers.enumerated()\
    \ {\n        result.append(numbers[0...i].max()!)\n    }\n    return result\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(rolling_max(numbers: [] as [Int]) == [] as [Int])\n\
    assert(rolling_max(numbers: [1, 2, 3, 4]) == [1, 2, 3, 4])\nassert(rolling_max(numbers:\
    \ [4, 3, 2, 1]) == [4, 4, 4, 4])\nassert(rolling_max(numbers: [3, 2, 3, 100, 3])\
    \ == [3, 3, 3, 100, 100])"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659979941
- exit_code: -4
  program: "\n/// From a given array of integers, generate an array of rolling maximum\
    \ element found until given moment\n/// in the sequence.\n/// >>> rolling_max(numbers:\
    \ [1, 2, 3, 2, 3, 4, 2])\n/// [1, 2, 3, 3, 3, 4, 4]\nfunc rolling_max(numbers:\
    \ [Int]) -> [Int] {\n    var result = [Int]()\n    var current_max = numbers[0]\n\
    \    for number in numbers {\n        if current_max < number {\n            current_max\
    \ = number\n        }\n        result.append(current_max)\n    }\n    return result\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(rolling_max(numbers: [] as [Int]) == [] as [Int])\n\
    assert(rolling_max(numbers: [1, 2, 3, 4]) == [1, 2, 3, 4])\nassert(rolling_max(numbers:\
    \ [4, 3, 2, 1]) == [4, 4, 4, 4])\nassert(rolling_max(numbers: [3, 2, 3, 100, 3])\
    \ == [3, 3, 3, 100, 100])"
  status: Exception
  stderr: 'Swift/ContiguousArrayBuffer.swift:600: Fatal error: Index out of range

    Current stack trace:

    0    libswiftCore.so                    0x00002b9e717bec80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b9e714b5561 <unavailable> + 1434977

    2    libswiftCore.so                    0x00002b9e714b5286 <unavailable> + 1434246

    3    libswiftCore.so                    0x00002b9e714b513c <unavailable> + 1433916

    4    libswiftCore.so                    0x00002b9e714b4bb0 _assertionFailure(_:_:file:line:flags:)
    + 251

    5    libswiftSwiftOnoneSupport.so       0x00002b9e712b4e83 <unavailable> + 188035

    6    tmpupap4vzk                        0x000055a78c8c8a5f <unavailable> + 6751

    7    tmpupap4vzk                        0x000055a78c8c852d <unavailable> + 5421

    8    libc.so.6                          0x00002b9e719aa460 __libc_start_main +
    245

    9    tmpupap4vzk                        0x000055a78c8c8239 <unavailable> + 4665

    '
  stdout: ''
  timestamp: 1659979941
- exit_code: 1
  program: "\n/// From a given array of integers, generate an array of rolling maximum\
    \ element found until given moment\n/// in the sequence.\n/// >>> rolling_max(numbers:\
    \ [1, 2, 3, 2, 3, 4, 2])\n/// [1, 2, 3, 3, 3, 4, 4]\nfunc rolling_max(numbers:\
    \ [Int]) -> [Int] {\n    var rolling_max: [Int] = []\n    for (idx, number) in\
    \ numbers.enumerated() {\n        rolling_max.append(contentsOf: [Int](repeating:\
    \ number, count: idx + 1).max()!)\n    }\n    return rolling_max\n}\n\n\nfunc\
    \ ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count !=\
    \ right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(rolling_max(numbers: [] as [Int]) == [] as [Int])\n\
    assert(rolling_max(numbers: [1, 2, 3, 4]) == [1, 2, 3, 4])\nassert(rolling_max(numbers:\
    \ [4, 3, 2, 1]) == [4, 4, 4, 4])\nassert(rolling_max(numbers: [3, 2, 3, 100, 3])\
    \ == [3, 3, 3, 100, 100])"
  status: SyntaxError
  stderr: "/tmp/tmp703g0mpi.swift:9:21: error: no exact matches in call to instance\
    \ method 'append'\n        rolling_max.append(contentsOf: [Int](repeating: number,\
    \ count: idx + 1).max()!)\n                    ^\nSwift.Array:7:37: note: candidate\
    \ requires that 'Int' conform to 'Sequence' (requirement specified as 'S' : 'Sequence')\n\
    \    @inlinable public mutating func append<S>(contentsOf newElements: __owned\
    \ S) where Element == S.Element, S : Sequence\n                              \
    \      ^\nSwift.RangeReplaceableCollection:5:37: note: candidate requires that\
    \ 'Int' conform to 'Sequence' (requirement specified as 'S' : 'Sequence')\n  \
    \  @inlinable public mutating func append<S>(contentsOf newElements: __owned S)\
    \ where S : Sequence, Self.Element == S.Element\n                            \
    \        ^\n"
  stdout: ''
  timestamp: 1659979941
- exit_code: 0
  program: "\n/// From a given array of integers, generate an array of rolling maximum\
    \ element found until given moment\n/// in the sequence.\n/// >>> rolling_max(numbers:\
    \ [1, 2, 3, 2, 3, 4, 2])\n/// [1, 2, 3, 3, 3, 4, 4]\nfunc rolling_max(numbers:\
    \ [Int]) -> [Int] {\n    return numbers.enumerated().map { (index, number) ->\
    \ Int in\n        return numbers[0...index].max()!\n    }\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(rolling_max(numbers: [] as [Int]) == [] as [Int])\nassert(rolling_max(numbers:\
    \ [1, 2, 3, 4]) == [1, 2, 3, 4])\nassert(rolling_max(numbers: [4, 3, 2, 1]) ==\
    \ [4, 4, 4, 4])\nassert(rolling_max(numbers: [3, 2, 3, 100, 3]) == [3, 3, 3, 100,\
    \ 100])"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659979942
- exit_code: -4
  program: "\n/// From a given array of integers, generate an array of rolling maximum\
    \ element found until given moment\n/// in the sequence.\n/// >>> rolling_max(numbers:\
    \ [1, 2, 3, 2, 3, 4, 2])\n/// [1, 2, 3, 3, 3, 4, 4]\nfunc rolling_max(numbers:\
    \ [Int]) -> [Int] {\n    var rolling = [Int]()\n    var max = numbers[0]\n   \
    \ rolling.append(max)\n    for number in numbers[1..<numbers.count] {\n      \
    \  if number > max {\n            max = number\n        }\n        rolling.append(max)\n\
    \    }\n    return rolling\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(rolling_max(numbers:\
    \ [] as [Int]) == [] as [Int])\nassert(rolling_max(numbers: [1, 2, 3, 4]) == [1,\
    \ 2, 3, 4])\nassert(rolling_max(numbers: [4, 3, 2, 1]) == [4, 4, 4, 4])\nassert(rolling_max(numbers:\
    \ [3, 2, 3, 100, 3]) == [3, 3, 3, 100, 100])"
  status: Exception
  stderr: 'Swift/ContiguousArrayBuffer.swift:600: Fatal error: Index out of range

    Current stack trace:

    0    libswiftCore.so                    0x00002b02d7903c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b02d75fa561 <unavailable> + 1434977

    2    libswiftCore.so                    0x00002b02d75fa286 <unavailable> + 1434246

    3    libswiftCore.so                    0x00002b02d75fa13c <unavailable> + 1433916

    4    libswiftCore.so                    0x00002b02d75f9bb0 _assertionFailure(_:_:file:line:flags:)
    + 251

    5    libswiftSwiftOnoneSupport.so       0x00002b02d73f9e83 <unavailable> + 188035

    6    tmp4ds3106c                        0x00005563fb46ec0b <unavailable> + 7179

    7    tmp4ds3106c                        0x00005563fb46e6cd <unavailable> + 5837

    8    libc.so.6                          0x00002b02d7aef460 __libc_start_main +
    245

    9    tmp4ds3106c                        0x00005563fb46e3d9 <unavailable> + 5081

    '
  stdout: ''
  timestamp: 1659979942
- exit_code: -4
  program: "\n/// From a given array of integers, generate an array of rolling maximum\
    \ element found until given moment\n/// in the sequence.\n/// >>> rolling_max(numbers:\
    \ [1, 2, 3, 2, 3, 4, 2])\n/// [1, 2, 3, 3, 3, 4, 4]\nfunc rolling_max(numbers:\
    \ [Int]) -> [Int] {\n    return []\n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(rolling_max(numbers: [] as [Int]) == [] as [Int])\nassert(rolling_max(numbers:\
    \ [1, 2, 3, 4]) == [1, 2, 3, 4])\nassert(rolling_max(numbers: [4, 3, 2, 1]) ==\
    \ [4, 4, 4, 4])\nassert(rolling_max(numbers: [3, 2, 3, 100, 3]) == [3, 3, 3, 100,\
    \ 100])"
  status: Exception
  stderr: 'tmp9fy9csjx/tmp9fy9csjx.swift:24: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b188eb4ac80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b188e841b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b188e841988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b188e8407b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmp9fy9csjx                        0x000055fa16c564ad <unavailable> + 5293

    5    libc.so.6                          0x00002b188ed36460 __libc_start_main +
    245

    6    tmp9fy9csjx                        0x000055fa16c55fc9 <unavailable> + 4041

    '
  stdout: ''
  timestamp: 1659979941
- exit_code: -4
  program: "\n/// From a given array of integers, generate an array of rolling maximum\
    \ element found until given moment\n/// in the sequence.\n/// >>> rolling_max(numbers:\
    \ [1, 2, 3, 2, 3, 4, 2])\n/// [1, 2, 3, 3, 3, 4, 4]\nfunc rolling_max(numbers:\
    \ [Int]) -> [Int] {\n    var stack = Array(repeating: 0, count: numbers.count)\n\
    \    stack[0] = numbers[0]\n    for index in 1..<numbers.count {\n        stack[index]\
    \ = max(stack[index - 1], numbers[index])\n    }\n    return stack\n}\n\n\nfunc\
    \ ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count !=\
    \ right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(rolling_max(numbers: [] as [Int]) == [] as [Int])\n\
    assert(rolling_max(numbers: [1, 2, 3, 4]) == [1, 2, 3, 4])\nassert(rolling_max(numbers:\
    \ [4, 3, 2, 1]) == [4, 4, 4, 4])\nassert(rolling_max(numbers: [3, 2, 3, 100, 3])\
    \ == [3, 3, 3, 100, 100])"
  status: Exception
  stderr: 'Swift/ContiguousArrayBuffer.swift:600: Fatal error: Index out of range

    Current stack trace:

    0    libswiftCore.so                    0x00002ad14ea6bc80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002ad14e762561 <unavailable> + 1434977

    2    libswiftCore.so                    0x00002ad14e762286 <unavailable> + 1434246

    3    libswiftCore.so                    0x00002ad14e76213c <unavailable> + 1433916

    4    libswiftCore.so                    0x00002ad14e761bb0 _assertionFailure(_:_:file:line:flags:)
    + 251

    5    libswiftSwiftOnoneSupport.so       0x00002ad14e561e83 <unavailable> + 188035

    6    tmp7gvx75jr                        0x000056425c56fb7f <unavailable> + 7039

    7    tmp7gvx75jr                        0x000056425c56f63d <unavailable> + 5693

    8    libc.so.6                          0x00002ad14ec57460 __libc_start_main +
    245

    9    tmp7gvx75jr                        0x000056425c56f349 <unavailable> + 4937

    '
  stdout: ''
  timestamp: 1659979942
- exit_code: -4
  program: "\n/// From a given array of integers, generate an array of rolling maximum\
    \ element found until given moment\n/// in the sequence.\n/// >>> rolling_max(numbers:\
    \ [1, 2, 3, 2, 3, 4, 2])\n/// [1, 2, 3, 3, 3, 4, 4]\nfunc rolling_max(numbers:\
    \ [Int]) -> [Int] {\n    var result = [Int]()\n    var max_elem = numbers[0]\n\
    \    for n in numbers {\n        max_elem = max(max_elem, n)\n        result.append(max_elem)\n\
    \    }\n    return result\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(rolling_max(numbers:\
    \ [] as [Int]) == [] as [Int])\nassert(rolling_max(numbers: [1, 2, 3, 4]) == [1,\
    \ 2, 3, 4])\nassert(rolling_max(numbers: [4, 3, 2, 1]) == [4, 4, 4, 4])\nassert(rolling_max(numbers:\
    \ [3, 2, 3, 100, 3]) == [3, 3, 3, 100, 100])"
  status: Exception
  stderr: 'Swift/ContiguousArrayBuffer.swift:600: Fatal error: Index out of range

    Current stack trace:

    0    libswiftCore.so                    0x00002b0abed8dc80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b0abea84561 <unavailable> + 1434977

    2    libswiftCore.so                    0x00002b0abea84286 <unavailable> + 1434246

    3    libswiftCore.so                    0x00002b0abea8413c <unavailable> + 1433916

    4    libswiftCore.so                    0x00002b0abea83bb0 _assertionFailure(_:_:file:line:flags:)
    + 251

    5    libswiftSwiftOnoneSupport.so       0x00002b0abe883e83 <unavailable> + 188035

    6    tmpji04ka0b                        0x0000555bf19caaf8 <unavailable> + 6904

    7    tmpji04ka0b                        0x0000555bf19ca5bd <unavailable> + 5565

    8    libc.so.6                          0x00002b0abef79460 __libc_start_main +
    245

    9    tmpji04ka0b                        0x0000555bf19ca2c9 <unavailable> + 4809

    '
  stdout: ''
  timestamp: 1659979942
- exit_code: -4
  program: "\n/// From a given array of integers, generate an array of rolling maximum\
    \ element found until given moment\n/// in the sequence.\n/// >>> rolling_max(numbers:\
    \ [1, 2, 3, 2, 3, 4, 2])\n/// [1, 2, 3, 3, 3, 4, 4]\nfunc rolling_max(numbers:\
    \ [Int]) -> [Int] {\n    var currentMax = numbers[0]\n    var result = [Int]()\n\
    \    result.append(currentMax)\n    for i in 1..<numbers.count {\n        if numbers[i]\
    \ > currentMax {\n            currentMax = numbers[i]\n        }\n        result.append(currentMax)\n\
    \    }\n    return result\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(rolling_max(numbers:\
    \ [] as [Int]) == [] as [Int])\nassert(rolling_max(numbers: [1, 2, 3, 4]) == [1,\
    \ 2, 3, 4])\nassert(rolling_max(numbers: [4, 3, 2, 1]) == [4, 4, 4, 4])\nassert(rolling_max(numbers:\
    \ [3, 2, 3, 100, 3]) == [3, 3, 3, 100, 100])"
  status: Exception
  stderr: 'Swift/ContiguousArrayBuffer.swift:600: Fatal error: Index out of range

    Current stack trace:

    0    libswiftCore.so                    0x00002b5d40895c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b5d4058c561 <unavailable> + 1434977

    2    libswiftCore.so                    0x00002b5d4058c286 <unavailable> + 1434246

    3    libswiftCore.so                    0x00002b5d4058c13c <unavailable> + 1433916

    4    libswiftCore.so                    0x00002b5d4058bbb0 _assertionFailure(_:_:file:line:flags:)
    + 251

    5    libswiftSwiftOnoneSupport.so       0x00002b5d4038de83 <unavailable> + 188035

    6    tmpybm1lhe3                        0x000055d640332ad8 <unavailable> + 6872

    7    tmpybm1lhe3                        0x000055d6403325ad <unavailable> + 5549

    8    libc.so.6                          0x00002b5d40a81460 __libc_start_main +
    245

    9    tmpybm1lhe3                        0x000055d6403322b9 <unavailable> + 4793

    '
  stdout: ''
  timestamp: 1659979942
- exit_code: 0
  program: "\n/// From a given array of integers, generate an array of rolling maximum\
    \ element found until given moment\n/// in the sequence.\n/// >>> rolling_max(numbers:\
    \ [1, 2, 3, 2, 3, 4, 2])\n/// [1, 2, 3, 3, 3, 4, 4]\nfunc rolling_max(numbers:\
    \ [Int]) -> [Int] {\n    var result = [Int]()\n    var currentMax = Int.min\n\
    \    for number in numbers {\n        if number > currentMax {\n            currentMax\
    \ = number\n        }\n        result.append(currentMax)\n    }\n    return result\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(rolling_max(numbers: [] as [Int]) == [] as [Int])\n\
    assert(rolling_max(numbers: [1, 2, 3, 4]) == [1, 2, 3, 4])\nassert(rolling_max(numbers:\
    \ [4, 3, 2, 1]) == [4, 4, 4, 4])\nassert(rolling_max(numbers: [3, 2, 3, 100, 3])\
    \ == [3, 3, 3, 100, 100])"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659979942
- exit_code: 0
  program: "\n/// From a given array of integers, generate an array of rolling maximum\
    \ element found until given moment\n/// in the sequence.\n/// >>> rolling_max(numbers:\
    \ [1, 2, 3, 2, 3, 4, 2])\n/// [1, 2, 3, 3, 3, 4, 4]\nfunc rolling_max(numbers:\
    \ [Int]) -> [Int] {\n    var maxes = [Int]()\n    var max: Int?\n    for number\
    \ in numbers {\n        if max == nil || number > max! {\n            max = number\n\
    \        }\n        maxes.append(max!)\n    }\n    return maxes\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(rolling_max(numbers: [] as [Int]) == [] as [Int])\nassert(rolling_max(numbers:\
    \ [1, 2, 3, 4]) == [1, 2, 3, 4])\nassert(rolling_max(numbers: [4, 3, 2, 1]) ==\
    \ [4, 4, 4, 4])\nassert(rolling_max(numbers: [3, 2, 3, 100, 3]) == [3, 3, 3, 100,\
    \ 100])"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659979942
- exit_code: 0
  program: "\n/// From a given array of integers, generate an array of rolling maximum\
    \ element found until given moment\n/// in the sequence.\n/// >>> rolling_max(numbers:\
    \ [1, 2, 3, 2, 3, 4, 2])\n/// [1, 2, 3, 3, 3, 4, 4]\nfunc rolling_max(numbers:\
    \ [Int]) -> [Int] {\n    var maxArray = [Int]()\n    var maxNumber = 0\n    for\
    \ number in numbers {\n        if number > maxNumber {\n            maxNumber\
    \ = number\n        }\n        maxArray.append(maxNumber)\n    }\n    return maxArray\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(rolling_max(numbers: [] as [Int]) == [] as [Int])\n\
    assert(rolling_max(numbers: [1, 2, 3, 4]) == [1, 2, 3, 4])\nassert(rolling_max(numbers:\
    \ [4, 3, 2, 1]) == [4, 4, 4, 4])\nassert(rolling_max(numbers: [3, 2, 3, 100, 3])\
    \ == [3, 3, 3, 100, 100])"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659979942
- exit_code: 0
  program: "\n/// From a given array of integers, generate an array of rolling maximum\
    \ element found until given moment\n/// in the sequence.\n/// >>> rolling_max(numbers:\
    \ [1, 2, 3, 2, 3, 4, 2])\n/// [1, 2, 3, 3, 3, 4, 4]\nfunc rolling_max(numbers:\
    \ [Int]) -> [Int] {\n    var result = [Int]()\n    var maxSoFar = Int.min\n  \
    \  for number in numbers {\n        maxSoFar = max(maxSoFar, number)\n       \
    \ result.append(maxSoFar)\n    }\n    return result\n}\n\n\nfunc ==(left: [(Int,\
    \ Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n\
    \        return false\n    }\n    for (l, r) in zip(left, right) {\n        if\
    \ l != r {\n            return false\n        }\n    }\n    return true\n}\n \
    \           \nassert(rolling_max(numbers: [] as [Int]) == [] as [Int])\nassert(rolling_max(numbers:\
    \ [1, 2, 3, 4]) == [1, 2, 3, 4])\nassert(rolling_max(numbers: [4, 3, 2, 1]) ==\
    \ [4, 4, 4, 4])\nassert(rolling_max(numbers: [3, 2, 3, 100, 3]) == [3, 3, 3, 100,\
    \ 100])"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659979941
- exit_code: 0
  program: "\n/// From a given array of integers, generate an array of rolling maximum\
    \ element found until given moment\n/// in the sequence.\n/// >>> rolling_max(numbers:\
    \ [1, 2, 3, 2, 3, 4, 2])\n/// [1, 2, 3, 3, 3, 4, 4]\nfunc rolling_max(numbers:\
    \ [Int]) -> [Int] {\n    var max_elements = [Int]()\n    var current_max = Int.min\n\
    \    for index in 0..<numbers.count {\n        let element = numbers[index]\n\
    \        if element > current_max {\n            current_max = element\n     \
    \   }\n        max_elements.append(current_max)\n    }\n    return max_elements\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(rolling_max(numbers: [] as [Int]) == [] as [Int])\n\
    assert(rolling_max(numbers: [1, 2, 3, 4]) == [1, 2, 3, 4])\nassert(rolling_max(numbers:\
    \ [4, 3, 2, 1]) == [4, 4, 4, 4])\nassert(rolling_max(numbers: [3, 2, 3, 100, 3])\
    \ == [3, 3, 3, 100, 100])"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659979942
- exit_code: 0
  program: "\n/// From a given array of integers, generate an array of rolling maximum\
    \ element found until given moment\n/// in the sequence.\n/// >>> rolling_max(numbers:\
    \ [1, 2, 3, 2, 3, 4, 2])\n/// [1, 2, 3, 3, 3, 4, 4]\nfunc rolling_max(numbers:\
    \ [Int]) -> [Int] {\n    var maximum = Int.min\n    var output = [Int]()\n   \
    \ for number in numbers {\n        maximum = max(maximum, number)\n        output.append(maximum)\n\
    \    }\n    return output\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(rolling_max(numbers:\
    \ [] as [Int]) == [] as [Int])\nassert(rolling_max(numbers: [1, 2, 3, 4]) == [1,\
    \ 2, 3, 4])\nassert(rolling_max(numbers: [4, 3, 2, 1]) == [4, 4, 4, 4])\nassert(rolling_max(numbers:\
    \ [3, 2, 3, 100, 3]) == [3, 3, 3, 100, 100])"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659979942
- exit_code: 0
  program: "\n/// From a given array of integers, generate an array of rolling maximum\
    \ element found until given moment\n/// in the sequence.\n/// >>> rolling_max(numbers:\
    \ [1, 2, 3, 2, 3, 4, 2])\n/// [1, 2, 3, 3, 3, 4, 4]\nfunc rolling_max(numbers:\
    \ [Int]) -> [Int] {\n  var current_max = 0\n  var result = [Int]()\n  for number\
    \ in numbers {\n    if number > current_max {\n      current_max = number\n  \
    \  }\n    result.append(current_max)\n  }\n  return result\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(rolling_max(numbers: [] as [Int]) == [] as [Int])\nassert(rolling_max(numbers:\
    \ [1, 2, 3, 4]) == [1, 2, 3, 4])\nassert(rolling_max(numbers: [4, 3, 2, 1]) ==\
    \ [4, 4, 4, 4])\nassert(rolling_max(numbers: [3, 2, 3, 100, 3]) == [3, 3, 3, 100,\
    \ 100])"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659979942
- exit_code: 0
  program: "\n/// From a given array of integers, generate an array of rolling maximum\
    \ element found until given moment\n/// in the sequence.\n/// >>> rolling_max(numbers:\
    \ [1, 2, 3, 2, 3, 4, 2])\n/// [1, 2, 3, 3, 3, 4, 4]\nfunc rolling_max(numbers:\
    \ [Int]) -> [Int] {\n    guard numbers.count > 0 else { return [] }\n    var result\
    \ = [Int]()\n    result.append(numbers[0])\n    for i in 1..<numbers.count {\n\
    \        result.append(max(result[i - 1], numbers[i]))\n    }\n    return result\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(rolling_max(numbers: [] as [Int]) == [] as [Int])\n\
    assert(rolling_max(numbers: [1, 2, 3, 4]) == [1, 2, 3, 4])\nassert(rolling_max(numbers:\
    \ [4, 3, 2, 1]) == [4, 4, 4, 4])\nassert(rolling_max(numbers: [3, 2, 3, 100, 3])\
    \ == [3, 3, 3, 100, 100])"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659979941
- exit_code: -4
  program: "\n/// From a given array of integers, generate an array of rolling maximum\
    \ element found until given moment\n/// in the sequence.\n/// >>> rolling_max(numbers:\
    \ [1, 2, 3, 2, 3, 4, 2])\n/// [1, 2, 3, 3, 3, 4, 4]\nfunc rolling_max(numbers:\
    \ [Int]) -> [Int] {\n    var roll_max = [Int]()\n    for idx in 0..<numbers.count\
    \ {\n        roll_max.append(numbers[0..<idx].max() ?? numbers[idx])\n    }\n\
    \    return roll_max\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(rolling_max(numbers:\
    \ [] as [Int]) == [] as [Int])\nassert(rolling_max(numbers: [1, 2, 3, 4]) == [1,\
    \ 2, 3, 4])\nassert(rolling_max(numbers: [4, 3, 2, 1]) == [4, 4, 4, 4])\nassert(rolling_max(numbers:\
    \ [3, 2, 3, 100, 3]) == [3, 3, 3, 100, 100])"
  status: Exception
  stderr: 'tmp4ieliprv/tmp4ieliprv.swift:28: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b4702bcec80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b47028c5b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b47028c5988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b47028c47b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmp4ieliprv                        0x000055c117c0191d <unavailable> + 6429

    5    libc.so.6                          0x00002b4702dba460 __libc_start_main +
    245

    6    tmp4ieliprv                        0x000055c117c01439 <unavailable> + 5177

    '
  stdout: ''
  timestamp: 1659979942
- exit_code: -4
  program: "\n/// From a given array of integers, generate an array of rolling maximum\
    \ element found until given moment\n/// in the sequence.\n/// >>> rolling_max(numbers:\
    \ [1, 2, 3, 2, 3, 4, 2])\n/// [1, 2, 3, 3, 3, 4, 4]\nfunc rolling_max(numbers:\
    \ [Int]) -> [Int] {\n    var result = [Int]()\n    var max_so_far = numbers[0]\n\
    \    result.append(max_so_far)\n    for i in 1..<numbers.count {\n        if numbers[i]\
    \ > max_so_far {\n            max_so_far = numbers[i]\n        }\n        result.append(max_so_far)\n\
    \    }\n    return result\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(rolling_max(numbers:\
    \ [] as [Int]) == [] as [Int])\nassert(rolling_max(numbers: [1, 2, 3, 4]) == [1,\
    \ 2, 3, 4])\nassert(rolling_max(numbers: [4, 3, 2, 1]) == [4, 4, 4, 4])\nassert(rolling_max(numbers:\
    \ [3, 2, 3, 100, 3]) == [3, 3, 3, 100, 100])"
  status: Exception
  stderr: 'Swift/ContiguousArrayBuffer.swift:600: Fatal error: Index out of range

    Current stack trace:

    0    libswiftCore.so                    0x00002ab19e84ec80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002ab19e545561 <unavailable> + 1434977

    2    libswiftCore.so                    0x00002ab19e545286 <unavailable> + 1434246

    3    libswiftCore.so                    0x00002ab19e54513c <unavailable> + 1433916

    4    libswiftCore.so                    0x00002ab19e544bb0 _assertionFailure(_:_:file:line:flags:)
    + 251

    5    libswiftSwiftOnoneSupport.so       0x00002ab19e344e83 <unavailable> + 188035

    6    tmpgj1zvtr4                        0x00005604c4c16ae8 <unavailable> + 6888

    7    tmpgj1zvtr4                        0x00005604c4c165ad <unavailable> + 5549

    8    libc.so.6                          0x00002ab19ea3a460 __libc_start_main +
    245

    9    tmpgj1zvtr4                        0x00005604c4c162b9 <unavailable> + 4793

    '
  stdout: ''
  timestamp: 1659979940
- exit_code: 0
  program: "\n/// From a given array of integers, generate an array of rolling maximum\
    \ element found until given moment\n/// in the sequence.\n/// >>> rolling_max(numbers:\
    \ [1, 2, 3, 2, 3, 4, 2])\n/// [1, 2, 3, 3, 3, 4, 4]\nfunc rolling_max(numbers:\
    \ [Int]) -> [Int] {\n    var maxes = [Int]()\n    for number in numbers {\n  \
    \      maxes.append(max(number, maxes.last ?? 0))\n    }\n    return maxes\n}\n\
    \n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(rolling_max(numbers: [] as [Int]) == [] as [Int])\n\
    assert(rolling_max(numbers: [1, 2, 3, 4]) == [1, 2, 3, 4])\nassert(rolling_max(numbers:\
    \ [4, 3, 2, 1]) == [4, 4, 4, 4])\nassert(rolling_max(numbers: [3, 2, 3, 100, 3])\
    \ == [3, 3, 3, 100, 100])"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659979942
- exit_code: -4
  program: "\n/// From a given array of integers, generate an array of rolling maximum\
    \ element found until given moment\n/// in the sequence.\n/// >>> rolling_max(numbers:\
    \ [1, 2, 3, 2, 3, 4, 2])\n/// [1, 2, 3, 3, 3, 4, 4]\nfunc rolling_max(numbers:\
    \ [Int]) -> [Int] {\n    let array = numbers\n    var result = [Int]()\n    var\
    \ currentMax = array[0]\n    result.append(currentMax)\n    var i = 1\n    while\
    \ i < array.count {\n        currentMax = max(currentMax, array[i])\n        result.append(currentMax)\n\
    \        i += 1\n    }\n    return result\n}\n\n\nfunc ==(left: [(Int, Int)],\
    \ right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n       \
    \ return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r\
    \ {\n            return false\n        }\n    }\n    return true\n}\n        \
    \    \nassert(rolling_max(numbers: [] as [Int]) == [] as [Int])\nassert(rolling_max(numbers:\
    \ [1, 2, 3, 4]) == [1, 2, 3, 4])\nassert(rolling_max(numbers: [4, 3, 2, 1]) ==\
    \ [4, 4, 4, 4])\nassert(rolling_max(numbers: [3, 2, 3, 100, 3]) == [3, 3, 3, 100,\
    \ 100])"
  status: Exception
  stderr: 'Swift/ContiguousArrayBuffer.swift:600: Fatal error: Index out of range

    Current stack trace:

    0    libswiftCore.so                    0x00002ba5f2923c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002ba5f261a561 <unavailable> + 1434977

    2    libswiftCore.so                    0x00002ba5f261a286 <unavailable> + 1434246

    3    libswiftCore.so                    0x00002ba5f261a13c <unavailable> + 1433916

    4    libswiftCore.so                    0x00002ba5f2619bb0 _assertionFailure(_:_:file:line:flags:)
    + 251

    5    libswiftSwiftOnoneSupport.so       0x00002ba5f2419e83 <unavailable> + 188035

    6    tmpunt5d25v                        0x0000555c44d649e9 <unavailable> + 6633

    7    tmpunt5d25v                        0x0000555c44d644ad <unavailable> + 5293

    8    libc.so.6                          0x00002ba5f2b0f460 __libc_start_main +
    245

    9    tmpunt5d25v                        0x0000555c44d641b9 <unavailable> + 4537

    '
  stdout: ''
  timestamp: 1659979942
- exit_code: 0
  program: "\n/// From a given array of integers, generate an array of rolling maximum\
    \ element found until given moment\n/// in the sequence.\n/// >>> rolling_max(numbers:\
    \ [1, 2, 3, 2, 3, 4, 2])\n/// [1, 2, 3, 3, 3, 4, 4]\nfunc rolling_max(numbers:\
    \ [Int]) -> [Int] {\n    var result = [Int]()\n    var currentMax = 0\n    for\
    \ number in numbers {\n        if number > currentMax {\n            currentMax\
    \ = number\n        }\n        result.append(currentMax)\n    }\n    return result\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(rolling_max(numbers: [] as [Int]) == [] as [Int])\n\
    assert(rolling_max(numbers: [1, 2, 3, 4]) == [1, 2, 3, 4])\nassert(rolling_max(numbers:\
    \ [4, 3, 2, 1]) == [4, 4, 4, 4])\nassert(rolling_max(numbers: [3, 2, 3, 100, 3])\
    \ == [3, 3, 3, 100, 100])"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659979941
- exit_code: 0
  program: "\n/// From a given array of integers, generate an array of rolling maximum\
    \ element found until given moment\n/// in the sequence.\n/// >>> rolling_max(numbers:\
    \ [1, 2, 3, 2, 3, 4, 2])\n/// [1, 2, 3, 3, 3, 4, 4]\nfunc rolling_max(numbers:\
    \ [Int]) -> [Int] {\n    var maxs = [Int]()\n    var maximum = 0\n    for num\
    \ in numbers {\n        maximum = max(maximum, num)\n        maxs.append(maximum)\n\
    \    }\n    return maxs\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(rolling_max(numbers:\
    \ [] as [Int]) == [] as [Int])\nassert(rolling_max(numbers: [1, 2, 3, 4]) == [1,\
    \ 2, 3, 4])\nassert(rolling_max(numbers: [4, 3, 2, 1]) == [4, 4, 4, 4])\nassert(rolling_max(numbers:\
    \ [3, 2, 3, 100, 3]) == [3, 3, 3, 100, 100])"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659979942
- exit_code: -4
  program: "\n/// From a given array of integers, generate an array of rolling maximum\
    \ element found until given moment\n/// in the sequence.\n/// >>> rolling_max(numbers:\
    \ [1, 2, 3, 2, 3, 4, 2])\n/// [1, 2, 3, 3, 3, 4, 4]\nfunc rolling_max(numbers:\
    \ [Int]) -> [Int] {\n    var max_numbers = [Int]()\n    var current_max = numbers[0]\n\
    \    for number in numbers {\n        current_max = max(current_max, number)\n\
    \        max_numbers.append(current_max)\n    }\n    return max_numbers\n}\n\n\
    \nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(rolling_max(numbers: [] as [Int]) == [] as [Int])\n\
    assert(rolling_max(numbers: [1, 2, 3, 4]) == [1, 2, 3, 4])\nassert(rolling_max(numbers:\
    \ [4, 3, 2, 1]) == [4, 4, 4, 4])\nassert(rolling_max(numbers: [3, 2, 3, 100, 3])\
    \ == [3, 3, 3, 100, 100])"
  status: Exception
  stderr: 'Swift/ContiguousArrayBuffer.swift:600: Fatal error: Index out of range

    Current stack trace:

    0    libswiftCore.so                    0x00002b7ed72a4c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b7ed6f9b561 <unavailable> + 1434977

    2    libswiftCore.so                    0x00002b7ed6f9b286 <unavailable> + 1434246

    3    libswiftCore.so                    0x00002b7ed6f9b13c <unavailable> + 1433916

    4    libswiftCore.so                    0x00002b7ed6f9abb0 _assertionFailure(_:_:file:line:flags:)
    + 251

    5    libswiftSwiftOnoneSupport.so       0x00002b7ed6d9ae83 <unavailable> + 188035

    6    tmpenwko3bn                        0x0000560bb7340af8 <unavailable> + 6904

    7    tmpenwko3bn                        0x0000560bb73405bd <unavailable> + 5565

    8    libc.so.6                          0x00002b7ed7490460 __libc_start_main +
    245

    9    tmpenwko3bn                        0x0000560bb73402c9 <unavailable> + 4809

    '
  stdout: ''
  timestamp: 1659979942
- exit_code: 0
  program: "\n/// From a given array of integers, generate an array of rolling maximum\
    \ element found until given moment\n/// in the sequence.\n/// >>> rolling_max(numbers:\
    \ [1, 2, 3, 2, 3, 4, 2])\n/// [1, 2, 3, 3, 3, 4, 4]\nfunc rolling_max(numbers:\
    \ [Int]) -> [Int] {\n    var result = [Int]()\n    var maxValue = Int.min\n  \
    \  for n in numbers {\n        maxValue = max(maxValue, n)\n        result.append(maxValue)\n\
    \    }\n    return result\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(rolling_max(numbers:\
    \ [] as [Int]) == [] as [Int])\nassert(rolling_max(numbers: [1, 2, 3, 4]) == [1,\
    \ 2, 3, 4])\nassert(rolling_max(numbers: [4, 3, 2, 1]) == [4, 4, 4, 4])\nassert(rolling_max(numbers:\
    \ [3, 2, 3, 100, 3]) == [3, 3, 3, 100, 100])"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659979942
- exit_code: 0
  program: "\n/// From a given array of integers, generate an array of rolling maximum\
    \ element found until given moment\n/// in the sequence.\n/// >>> rolling_max(numbers:\
    \ [1, 2, 3, 2, 3, 4, 2])\n/// [1, 2, 3, 3, 3, 4, 4]\nfunc rolling_max(numbers:\
    \ [Int]) -> [Int] {\n    guard numbers.count > 0 else { return [] }\n    var result\
    \ = [Int]()\n    var currentMax = numbers[0]\n    result.append(currentMax)\n\
    \    for i in 1..<numbers.count {\n        if numbers[i] > currentMax {\n    \
    \        currentMax = numbers[i]\n        }\n        result.append(currentMax)\n\
    \    }\n    return result\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(rolling_max(numbers:\
    \ [] as [Int]) == [] as [Int])\nassert(rolling_max(numbers: [1, 2, 3, 4]) == [1,\
    \ 2, 3, 4])\nassert(rolling_max(numbers: [4, 3, 2, 1]) == [4, 4, 4, 4])\nassert(rolling_max(numbers:\
    \ [3, 2, 3, 100, 3]) == [3, 3, 3, 100, 100])"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659979942
- exit_code: -4
  program: "\n/// From a given array of integers, generate an array of rolling maximum\
    \ element found until given moment\n/// in the sequence.\n/// >>> rolling_max(numbers:\
    \ [1, 2, 3, 2, 3, 4, 2])\n/// [1, 2, 3, 3, 3, 4, 4]\nfunc rolling_max(numbers:\
    \ [Int]) -> [Int] {\n    var maxSoFar = numbers[0]\n    var maxes = [Int]()\n\
    \    for number in numbers {\n        maxSoFar = max(maxSoFar, number)\n     \
    \   maxes.append(maxSoFar)\n    }\n    return maxes\n}\n\n\nfunc ==(left: [(Int,\
    \ Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n\
    \        return false\n    }\n    for (l, r) in zip(left, right) {\n        if\
    \ l != r {\n            return false\n        }\n    }\n    return true\n}\n \
    \           \nassert(rolling_max(numbers: [] as [Int]) == [] as [Int])\nassert(rolling_max(numbers:\
    \ [1, 2, 3, 4]) == [1, 2, 3, 4])\nassert(rolling_max(numbers: [4, 3, 2, 1]) ==\
    \ [4, 4, 4, 4])\nassert(rolling_max(numbers: [3, 2, 3, 100, 3]) == [3, 3, 3, 100,\
    \ 100])"
  status: Exception
  stderr: 'Swift/ContiguousArrayBuffer.swift:600: Fatal error: Index out of range

    Current stack trace:

    0    libswiftCore.so                    0x00002abb02191c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002abb01e88561 <unavailable> + 1434977

    2    libswiftCore.so                    0x00002abb01e88286 <unavailable> + 1434246

    3    libswiftCore.so                    0x00002abb01e8813c <unavailable> + 1433916

    4    libswiftCore.so                    0x00002abb01e87bb0 _assertionFailure(_:_:file:line:flags:)
    + 251

    5    libswiftSwiftOnoneSupport.so       0x00002abb01c87e83 <unavailable> + 188035

    6    tmptgv5konu                        0x000055fa61a3fae8 <unavailable> + 6888

    7    tmptgv5konu                        0x000055fa61a3f5bd <unavailable> + 5565

    8    libc.so.6                          0x00002abb0237d460 __libc_start_main +
    245

    9    tmptgv5konu                        0x000055fa61a3f2c9 <unavailable> + 4809

    '
  stdout: ''
  timestamp: 1659979942
- exit_code: 0
  program: "\n/// From a given array of integers, generate an array of rolling maximum\
    \ element found until given moment\n/// in the sequence.\n/// >>> rolling_max(numbers:\
    \ [1, 2, 3, 2, 3, 4, 2])\n/// [1, 2, 3, 3, 3, 4, 4]\nfunc rolling_max(numbers:\
    \ [Int]) -> [Int] {\n    var rmax: [Int] = []\n    var mx = Int.min\n    for n\
    \ in numbers {\n        mx = max(mx, n)\n        rmax.append(mx)\n    }\n    return\
    \ rmax\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n  \
    \  if left.count != right.count {\n        return false\n    }\n    for (l, r)\
    \ in zip(left, right) {\n        if l != r {\n            return false\n     \
    \   }\n    }\n    return true\n}\n            \nassert(rolling_max(numbers: []\
    \ as [Int]) == [] as [Int])\nassert(rolling_max(numbers: [1, 2, 3, 4]) == [1,\
    \ 2, 3, 4])\nassert(rolling_max(numbers: [4, 3, 2, 1]) == [4, 4, 4, 4])\nassert(rolling_max(numbers:\
    \ [3, 2, 3, 100, 3]) == [3, 3, 3, 100, 100])"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659979942
- exit_code: 0
  program: "\n/// From a given array of integers, generate an array of rolling maximum\
    \ element found until given moment\n/// in the sequence.\n/// >>> rolling_max(numbers:\
    \ [1, 2, 3, 2, 3, 4, 2])\n/// [1, 2, 3, 3, 3, 4, 4]\nfunc rolling_max(numbers:\
    \ [Int]) -> [Int] {\n    return numbers.reduce(into: [Int]()) { (accumulator,\
    \ element) in\n        accumulator.append(max(element, accumulator.last ?? 0))\n\
    \    }\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n  \
    \  if left.count != right.count {\n        return false\n    }\n    for (l, r)\
    \ in zip(left, right) {\n        if l != r {\n            return false\n     \
    \   }\n    }\n    return true\n}\n            \nassert(rolling_max(numbers: []\
    \ as [Int]) == [] as [Int])\nassert(rolling_max(numbers: [1, 2, 3, 4]) == [1,\
    \ 2, 3, 4])\nassert(rolling_max(numbers: [4, 3, 2, 1]) == [4, 4, 4, 4])\nassert(rolling_max(numbers:\
    \ [3, 2, 3, 100, 3]) == [3, 3, 3, 100, 100])"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659979942
- exit_code: -4
  program: "\n/// From a given array of integers, generate an array of rolling maximum\
    \ element found until given moment\n/// in the sequence.\n/// >>> rolling_max(numbers:\
    \ [1, 2, 3, 2, 3, 4, 2])\n/// [1, 2, 3, 3, 3, 4, 4]\nfunc rolling_max(numbers:\
    \ [Int]) -> [Int] {\n    \n    var result: [Int] = []\n    for idx in 0..<numbers.count\
    \ {\n        let max = numbers[0..<idx].max() ?? 0\n        result.append(max)\n\
    \    }\n    \n    return result\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int,\
    \ Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n\
    \    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n          \
    \  return false\n        }\n    }\n    return true\n}\n            \nassert(rolling_max(numbers:\
    \ [] as [Int]) == [] as [Int])\nassert(rolling_max(numbers: [1, 2, 3, 4]) == [1,\
    \ 2, 3, 4])\nassert(rolling_max(numbers: [4, 3, 2, 1]) == [4, 4, 4, 4])\nassert(rolling_max(numbers:\
    \ [3, 2, 3, 100, 3]) == [3, 3, 3, 100, 100])"
  status: Exception
  stderr: 'tmp6rpjdkof/tmp6rpjdkof.swift:31: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b0448a18c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b044870fb6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b044870f988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b044870e7b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmp6rpjdkof                        0x0000559656a8b87d <unavailable> + 6269

    5    libc.so.6                          0x00002b0448c04460 __libc_start_main +
    245

    6    tmp6rpjdkof                        0x0000559656a8b399 <unavailable> + 5017

    '
  stdout: ''
  timestamp: 1659979942
- exit_code: 0
  program: "\n/// From a given array of integers, generate an array of rolling maximum\
    \ element found until given moment\n/// in the sequence.\n/// >>> rolling_max(numbers:\
    \ [1, 2, 3, 2, 3, 4, 2])\n/// [1, 2, 3, 3, 3, 4, 4]\nfunc rolling_max(numbers:\
    \ [Int]) -> [Int] {\n    var result = [Int]()\n    var current = 0\n    for number\
    \ in numbers {\n        current = max(current, number)\n        result.append(current)\n\
    \    }\n    return result\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(rolling_max(numbers:\
    \ [] as [Int]) == [] as [Int])\nassert(rolling_max(numbers: [1, 2, 3, 4]) == [1,\
    \ 2, 3, 4])\nassert(rolling_max(numbers: [4, 3, 2, 1]) == [4, 4, 4, 4])\nassert(rolling_max(numbers:\
    \ [3, 2, 3, 100, 3]) == [3, 3, 3, 100, 100])"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659979942
- exit_code: 0
  program: "\n/// From a given array of integers, generate an array of rolling maximum\
    \ element found until given moment\n/// in the sequence.\n/// >>> rolling_max(numbers:\
    \ [1, 2, 3, 2, 3, 4, 2])\n/// [1, 2, 3, 3, 3, 4, 4]\nfunc rolling_max(numbers:\
    \ [Int]) -> [Int] {\n    var retval = [Int]()\n    var max_num = 0\n    for n\
    \ in numbers {\n        max_num = max(max_num, n)\n        retval.append(max_num)\n\
    \    }\n    return retval\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(rolling_max(numbers:\
    \ [] as [Int]) == [] as [Int])\nassert(rolling_max(numbers: [1, 2, 3, 4]) == [1,\
    \ 2, 3, 4])\nassert(rolling_max(numbers: [4, 3, 2, 1]) == [4, 4, 4, 4])\nassert(rolling_max(numbers:\
    \ [3, 2, 3, 100, 3]) == [3, 3, 3, 100, 100])"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659979942
- exit_code: 0
  program: "\n/// From a given array of integers, generate an array of rolling maximum\
    \ element found until given moment\n/// in the sequence.\n/// >>> rolling_max(numbers:\
    \ [1, 2, 3, 2, 3, 4, 2])\n/// [1, 2, 3, 3, 3, 4, 4]\nfunc rolling_max(numbers:\
    \ [Int]) -> [Int] {\n    guard numbers.count > 0 else { return [] }\n    var result\
    \ = [Int]()\n    var max = numbers[0]\n    result.append(max)\n    for number\
    \ in numbers[1..<numbers.count] {\n        if number > max {\n            max\
    \ = number\n        }\n        result.append(max)\n    }\n    return result\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(rolling_max(numbers: [] as [Int]) == [] as [Int])\n\
    assert(rolling_max(numbers: [1, 2, 3, 4]) == [1, 2, 3, 4])\nassert(rolling_max(numbers:\
    \ [4, 3, 2, 1]) == [4, 4, 4, 4])\nassert(rolling_max(numbers: [3, 2, 3, 100, 3])\
    \ == [3, 3, 3, 100, 100])"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659979942
- exit_code: -4
  program: "\n/// From a given array of integers, generate an array of rolling maximum\
    \ element found until given moment\n/// in the sequence.\n/// >>> rolling_max(numbers:\
    \ [1, 2, 3, 2, 3, 4, 2])\n/// [1, 2, 3, 3, 3, 4, 4]\nfunc rolling_max(numbers:\
    \ [Int]) -> [Int] {\n    var result = [Int]()\n    var maxValue = numbers[0]\n\
    \    result.append(maxValue)\n    for i in 1..<numbers.count {\n        maxValue\
    \ = max(maxValue, numbers[i])\n        result.append(maxValue)\n    }\n    return\
    \ result\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n\
    \    if left.count != right.count {\n        return false\n    }\n    for (l,\
    \ r) in zip(left, right) {\n        if l != r {\n            return false\n  \
    \      }\n    }\n    return true\n}\n            \nassert(rolling_max(numbers:\
    \ [] as [Int]) == [] as [Int])\nassert(rolling_max(numbers: [1, 2, 3, 4]) == [1,\
    \ 2, 3, 4])\nassert(rolling_max(numbers: [4, 3, 2, 1]) == [4, 4, 4, 4])\nassert(rolling_max(numbers:\
    \ [3, 2, 3, 100, 3]) == [3, 3, 3, 100, 100])"
  status: Exception
  stderr: 'Swift/ContiguousArrayBuffer.swift:600: Fatal error: Index out of range

    Current stack trace:

    0    libswiftCore.so                    0x00002acaa7402c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002acaa70f9561 <unavailable> + 1434977

    2    libswiftCore.so                    0x00002acaa70f9286 <unavailable> + 1434246

    3    libswiftCore.so                    0x00002acaa70f913c <unavailable> + 1433916

    4    libswiftCore.so                    0x00002acaa70f8bb0 _assertionFailure(_:_:file:line:flags:)
    + 251

    5    libswiftSwiftOnoneSupport.so       0x00002acaa6ef8e83 <unavailable> + 188035

    6    tmp7oocre4e                        0x000055dd895afb68 <unavailable> + 7016

    7    tmp7oocre4e                        0x000055dd895af62d <unavailable> + 5677

    8    libc.so.6                          0x00002acaa75ee460 __libc_start_main +
    245

    9    tmp7oocre4e                        0x000055dd895af339 <unavailable> + 4921

    '
  stdout: ''
  timestamp: 1659979942
- exit_code: 0
  program: "\n/// From a given array of integers, generate an array of rolling maximum\
    \ element found until given moment\n/// in the sequence.\n/// >>> rolling_max(numbers:\
    \ [1, 2, 3, 2, 3, 4, 2])\n/// [1, 2, 3, 3, 3, 4, 4]\nfunc rolling_max(numbers:\
    \ [Int]) -> [Int] {\n    guard numbers.count > 0 else { return [] }\n    var res\
    \ = [Int]()\n    res.append(numbers[0])\n    for i in 1..<numbers.count {\n  \
    \      res.append(max(res[i - 1], numbers[i]))\n    }\n    return res\n}\n\n\n\
    func ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(rolling_max(numbers: [] as [Int]) == [] as [Int])\n\
    assert(rolling_max(numbers: [1, 2, 3, 4]) == [1, 2, 3, 4])\nassert(rolling_max(numbers:\
    \ [4, 3, 2, 1]) == [4, 4, 4, 4])\nassert(rolling_max(numbers: [3, 2, 3, 100, 3])\
    \ == [3, 3, 3, 100, 100])"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659979942
- exit_code: -4
  program: "\n/// From a given array of integers, generate an array of rolling maximum\
    \ element found until given moment\n/// in the sequence.\n/// >>> rolling_max(numbers:\
    \ [1, 2, 3, 2, 3, 4, 2])\n/// [1, 2, 3, 3, 3, 4, 4]\nfunc rolling_max(numbers:\
    \ [Int]) -> [Int] {\n    var result = [Int]()\n    var max_seen = numbers[0]\n\
    \    result.append(max_seen)\n    for element in numbers[1..<numbers.count] {\n\
    \        max_seen = max(max_seen, element)\n        result.append(max_seen)\n\
    \    }\n    return result\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(rolling_max(numbers:\
    \ [] as [Int]) == [] as [Int])\nassert(rolling_max(numbers: [1, 2, 3, 4]) == [1,\
    \ 2, 3, 4])\nassert(rolling_max(numbers: [4, 3, 2, 1]) == [4, 4, 4, 4])\nassert(rolling_max(numbers:\
    \ [3, 2, 3, 100, 3]) == [3, 3, 3, 100, 100])"
  status: Exception
  stderr: 'Swift/ContiguousArrayBuffer.swift:600: Fatal error: Index out of range

    Current stack trace:

    0    libswiftCore.so                    0x00002b752264bc80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b7522342561 <unavailable> + 1434977

    2    libswiftCore.so                    0x00002b7522342286 <unavailable> + 1434246

    3    libswiftCore.so                    0x00002b752234213c <unavailable> + 1433916

    4    libswiftCore.so                    0x00002b7522341bb0 _assertionFailure(_:_:file:line:flags:)
    + 251

    5    libswiftSwiftOnoneSupport.so       0x00002b7522141e83 <unavailable> + 188035

    6    tmpldx1mgm3                        0x000055972b7bac9b <unavailable> + 7323

    7    tmpldx1mgm3                        0x000055972b7ba75d <unavailable> + 5981

    8    libc.so.6                          0x00002b7522837460 __libc_start_main +
    245

    9    tmpldx1mgm3                        0x000055972b7ba469 <unavailable> + 5225

    '
  stdout: ''
  timestamp: 1659979942
- exit_code: -4
  program: "\n/// From a given array of integers, generate an array of rolling maximum\
    \ element found until given moment\n/// in the sequence.\n/// >>> rolling_max(numbers:\
    \ [1, 2, 3, 2, 3, 4, 2])\n/// [1, 2, 3, 3, 3, 4, 4]\nfunc rolling_max(numbers:\
    \ [Int]) -> [Int] {\n    var result = [Int]()\n    var current = numbers[0]\n\
    \    result.append(current)\n    for number in numbers[1..<numbers.count] {\n\
    \        if number > current {\n            current = number\n        }\n    \
    \    result.append(current)\n    }\n    return result\n}\n\n\nfunc ==(left: [(Int,\
    \ Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n\
    \        return false\n    }\n    for (l, r) in zip(left, right) {\n        if\
    \ l != r {\n            return false\n        }\n    }\n    return true\n}\n \
    \           \nassert(rolling_max(numbers: [] as [Int]) == [] as [Int])\nassert(rolling_max(numbers:\
    \ [1, 2, 3, 4]) == [1, 2, 3, 4])\nassert(rolling_max(numbers: [4, 3, 2, 1]) ==\
    \ [4, 4, 4, 4])\nassert(rolling_max(numbers: [3, 2, 3, 100, 3]) == [3, 3, 3, 100,\
    \ 100])"
  status: Exception
  stderr: 'Swift/ContiguousArrayBuffer.swift:600: Fatal error: Index out of range

    Current stack trace:

    0    libswiftCore.so                    0x00002adf827d4c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002adf824cb561 <unavailable> + 1434977

    2    libswiftCore.so                    0x00002adf824cb286 <unavailable> + 1434246

    3    libswiftCore.so                    0x00002adf824cb13c <unavailable> + 1433916

    4    libswiftCore.so                    0x00002adf824cabb0 _assertionFailure(_:_:file:line:flags:)
    + 251

    5    libswiftSwiftOnoneSupport.so       0x00002adf822cae83 <unavailable> + 188035

    6    tmpf42horm8                        0x0000560b3c440c0b <unavailable> + 7179

    7    tmpf42horm8                        0x0000560b3c4406cd <unavailable> + 5837

    8    libc.so.6                          0x00002adf829c0460 __libc_start_main +
    245

    9    tmpf42horm8                        0x0000560b3c4403d9 <unavailable> + 5081

    '
  stdout: ''
  timestamp: 1659979942
- exit_code: 0
  program: "\n/// From a given array of integers, generate an array of rolling maximum\
    \ element found until given moment\n/// in the sequence.\n/// >>> rolling_max(numbers:\
    \ [1, 2, 3, 2, 3, 4, 2])\n/// [1, 2, 3, 3, 3, 4, 4]\nfunc rolling_max(numbers:\
    \ [Int]) -> [Int] {\n    var result = [Int]()\n    var current_max = 0\n    for\
    \ number in numbers {\n        current_max = max(current_max, number)\n      \
    \  result.append(current_max)\n    }\n    return result\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(rolling_max(numbers: [] as [Int]) == [] as [Int])\nassert(rolling_max(numbers:\
    \ [1, 2, 3, 4]) == [1, 2, 3, 4])\nassert(rolling_max(numbers: [4, 3, 2, 1]) ==\
    \ [4, 4, 4, 4])\nassert(rolling_max(numbers: [3, 2, 3, 100, 3]) == [3, 3, 3, 100,\
    \ 100])"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659979942
- exit_code: 0
  program: "\n/// From a given array of integers, generate an array of rolling maximum\
    \ element found until given moment\n/// in the sequence.\n/// >>> rolling_max(numbers:\
    \ [1, 2, 3, 2, 3, 4, 2])\n/// [1, 2, 3, 3, 3, 4, 4]\nfunc rolling_max(numbers:\
    \ [Int]) -> [Int] {\n    var max_value = Int.min\n    var max_array = [Int]()\n\
    \    for num in numbers {\n        max_value = max(max_value, num)\n        max_array.append(max_value)\n\
    \    }\n    return max_array\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int,\
    \ Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n\
    \    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n          \
    \  return false\n        }\n    }\n    return true\n}\n            \nassert(rolling_max(numbers:\
    \ [] as [Int]) == [] as [Int])\nassert(rolling_max(numbers: [1, 2, 3, 4]) == [1,\
    \ 2, 3, 4])\nassert(rolling_max(numbers: [4, 3, 2, 1]) == [4, 4, 4, 4])\nassert(rolling_max(numbers:\
    \ [3, 2, 3, 100, 3]) == [3, 3, 3, 100, 100])"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659979942
- exit_code: -4
  program: "\n/// From a given array of integers, generate an array of rolling maximum\
    \ element found until given moment\n/// in the sequence.\n/// >>> rolling_max(numbers:\
    \ [1, 2, 3, 2, 3, 4, 2])\n/// [1, 2, 3, 3, 3, 4, 4]\nfunc rolling_max(numbers:\
    \ [Int]) -> [Int] {\n    // solution in O(n)\n    // we create a new Array with\
    \ the same length\n    var maxes = Array(repeating: 0, count: numbers.count)\n\
    \    // we use a var to keep track of the max so far\n    var max_value = 0\n\
    \    // and one to keep track of the max_index so far\n    var max_index = 0\n\
    \    // the first element is the max of the first window\n    maxes[0] = numbers[0]\n\
    \    // iterate over the input array\n    for i in 1..<numbers.count {\n     \
    \   // if we found a new max,\n        if numbers[i] > max_value {\n         \
    \   // update the max value\n            max_value = numbers[i]\n            //\
    \ and remember the max index\n            max_index = i\n        }\n        //\
    \ if we are in the first window, then assign the max_value to maxes[i]\n     \
    \   if i <= max_index {\n            maxes[i] = max_value\n        } else {\n\
    \            // otherwise, assign the previous max_value from the previous window\n\
    \            maxes[i] = maxes[i - 1]\n        }\n    }\n    return maxes\n}\n\n\
    \nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(rolling_max(numbers: [] as [Int]) == [] as [Int])\n\
    assert(rolling_max(numbers: [1, 2, 3, 4]) == [1, 2, 3, 4])\nassert(rolling_max(numbers:\
    \ [4, 3, 2, 1]) == [4, 4, 4, 4])\nassert(rolling_max(numbers: [3, 2, 3, 100, 3])\
    \ == [3, 3, 3, 100, 100])"
  status: Exception
  stderr: 'Swift/ContiguousArrayBuffer.swift:600: Fatal error: Index out of range

    Current stack trace:

    0    libswiftCore.so                    0x00002b5eaaa70c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b5eaa767561 <unavailable> + 1434977

    2    libswiftCore.so                    0x00002b5eaa767286 <unavailable> + 1434246

    3    libswiftCore.so                    0x00002b5eaa76713c <unavailable> + 1433916

    4    libswiftCore.so                    0x00002b5eaa766bb0 _assertionFailure(_:_:file:line:flags:)
    + 251

    5    libswiftSwiftOnoneSupport.so       0x00002b5eaa566e83 <unavailable> + 188035

    6    tmpr_c3l7ht                        0x0000556347e8db2f <unavailable> + 6959

    7    tmpr_c3l7ht                        0x0000556347e8d5bd <unavailable> + 5565

    8    libc.so.6                          0x00002b5eaac5c460 __libc_start_main +
    245

    9    tmpr_c3l7ht                        0x0000556347e8d2c9 <unavailable> + 4809

    '
  stdout: ''
  timestamp: 1659979942
- exit_code: 1
  program: "\n/// From a given array of integers, generate an array of rolling maximum\
    \ element found until given moment\n/// in the sequence.\n/// >>> rolling_max(numbers:\
    \ [1, 2, 3, 2, 3, 4, 2])\n/// [1, 2, 3, 3, 3, 4, 4]\nfunc rolling_max(numbers:\
    \ [Int]) -> [Int] {\n    return [Int](0...numbers.count - 1).map {\n        max(numbers[0...$0])\n\
    \    }\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n  \
    \  if left.count != right.count {\n        return false\n    }\n    for (l, r)\
    \ in zip(left, right) {\n        if l != r {\n            return false\n     \
    \   }\n    }\n    return true\n}\n            \nassert(rolling_max(numbers: []\
    \ as [Int]) == [] as [Int])\nassert(rolling_max(numbers: [1, 2, 3, 4]) == [1,\
    \ 2, 3, 4])\nassert(rolling_max(numbers: [4, 3, 2, 1]) == [4, 4, 4, 4])\nassert(rolling_max(numbers:\
    \ [3, 2, 3, 100, 3]) == [3, 3, 3, 100, 100])"
  status: SyntaxError
  stderr: "/tmp/tmp63zxl4n3.swift:8:28: error: missing argument for parameter #2 in\
    \ call\n        max(numbers[0...$0])\n                           ^\n         \
    \                  , <#Int#>\nSwift.max:1:24: note: 'max' declared here\n@inlinable\
    \ public func max<T>(_ x: T, _ y: T) -> T where T : Comparable\n             \
    \          ^\n/tmp/tmp63zxl4n3.swift:8:22: error: cannot convert value of type\
    \ 'ClosedRange<Int>' to expected argument type 'Int'\n        max(numbers[0...$0])\n\
    \                     ^\n"
  stdout: ''
  timestamp: 1659979942
- exit_code: 0
  program: "\n/// From a given array of integers, generate an array of rolling maximum\
    \ element found until given moment\n/// in the sequence.\n/// >>> rolling_max(numbers:\
    \ [1, 2, 3, 2, 3, 4, 2])\n/// [1, 2, 3, 3, 3, 4, 4]\nfunc rolling_max(numbers:\
    \ [Int]) -> [Int] {\n    var rolling_max: [Int] = []\n    var max_value = 0\n\
    \    for number in numbers {\n        max_value = max(max_value, number)\n   \
    \     rolling_max.append(max_value)\n    }\n    return rolling_max\n}\n\n\nfunc\
    \ ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count !=\
    \ right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(rolling_max(numbers: [] as [Int]) == [] as [Int])\n\
    assert(rolling_max(numbers: [1, 2, 3, 4]) == [1, 2, 3, 4])\nassert(rolling_max(numbers:\
    \ [4, 3, 2, 1]) == [4, 4, 4, 4])\nassert(rolling_max(numbers: [3, 2, 3, 100, 3])\
    \ == [3, 3, 3, 100, 100])"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659979942
- exit_code: 1
  program: "\n/// From a given array of integers, generate an array of rolling maximum\
    \ element found until given moment\n/// in the sequence.\n/// >>> rolling_max(numbers:\
    \ [1, 2, 3, 2, 3, 4, 2])\n/// [1, 2, 3, 3, 3, 4, 4]\nfunc rolling_max(numbers:\
    \ [Int]) -> [Int] {\n    return _rolling_max(numbers: numbers, partial: [])\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(rolling_max(numbers: [] as [Int]) == [] as [Int])\n\
    assert(rolling_max(numbers: [1, 2, 3, 4]) == [1, 2, 3, 4])\nassert(rolling_max(numbers:\
    \ [4, 3, 2, 1]) == [4, 4, 4, 4])\nassert(rolling_max(numbers: [3, 2, 3, 100, 3])\
    \ == [3, 3, 3, 100, 100])"
  status: SyntaxError
  stderr: "/tmp/tmpi6dd1kw0.swift:7:12: error: cannot find '_rolling_max' in scope\n\
    \    return _rolling_max(numbers: numbers, partial: [])\n           ^~~~~~~~~~~~\n"
  stdout: ''
  timestamp: 1659979942
- exit_code: -4
  program: "\n/// From a given array of integers, generate an array of rolling maximum\
    \ element found until given moment\n/// in the sequence.\n/// >>> rolling_max(numbers:\
    \ [1, 2, 3, 2, 3, 4, 2])\n/// [1, 2, 3, 3, 3, 4, 4]\nfunc rolling_max(numbers:\
    \ [Int]) -> [Int] {\n    var result = [Int]()\n    var max = numbers[0]\n    for\
    \ n in numbers {\n        if n > max {\n            max = n\n        }\n     \
    \   result.append(max)\n    }\n    return result\n}\n\n\nfunc ==(left: [(Int,\
    \ Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n\
    \        return false\n    }\n    for (l, r) in zip(left, right) {\n        if\
    \ l != r {\n            return false\n        }\n    }\n    return true\n}\n \
    \           \nassert(rolling_max(numbers: [] as [Int]) == [] as [Int])\nassert(rolling_max(numbers:\
    \ [1, 2, 3, 4]) == [1, 2, 3, 4])\nassert(rolling_max(numbers: [4, 3, 2, 1]) ==\
    \ [4, 4, 4, 4])\nassert(rolling_max(numbers: [3, 2, 3, 100, 3]) == [3, 3, 3, 100,\
    \ 100])"
  status: Exception
  stderr: 'Swift/ContiguousArrayBuffer.swift:600: Fatal error: Index out of range

    Current stack trace:

    0    libswiftCore.so                    0x00002ac00cd0ec80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002ac00ca05561 <unavailable> + 1434977

    2    libswiftCore.so                    0x00002ac00ca05286 <unavailable> + 1434246

    3    libswiftCore.so                    0x00002ac00ca0513c <unavailable> + 1433916

    4    libswiftCore.so                    0x00002ac00ca04bb0 _assertionFailure(_:_:file:line:flags:)
    + 251

    5    libswiftSwiftOnoneSupport.so       0x00002ac00c804e83 <unavailable> + 188035

    6    tmpkkymlanw                        0x00005602143c1a5f <unavailable> + 6751

    7    tmpkkymlanw                        0x00005602143c152d <unavailable> + 5421

    8    libc.so.6                          0x00002ac00cefa460 __libc_start_main +
    245

    9    tmpkkymlanw                        0x00005602143c1239 <unavailable> + 4665

    '
  stdout: ''
  timestamp: 1659979942
- exit_code: 0
  program: "\n/// From a given array of integers, generate an array of rolling maximum\
    \ element found until given moment\n/// in the sequence.\n/// >>> rolling_max(numbers:\
    \ [1, 2, 3, 2, 3, 4, 2])\n/// [1, 2, 3, 3, 3, 4, 4]\nfunc rolling_max(numbers:\
    \ [Int]) -> [Int] {\n    guard numbers.count > 0 else { return [] }\n    var result\
    \ = [Int]()\n    var maxNumber = numbers[0]\n    result.append(maxNumber)\n  \
    \  for index in 1..<numbers.count {\n        maxNumber = max(maxNumber, numbers[index])\n\
    \        result.append(maxNumber)\n    }\n    return result\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(rolling_max(numbers: [] as [Int]) == [] as [Int])\nassert(rolling_max(numbers:\
    \ [1, 2, 3, 4]) == [1, 2, 3, 4])\nassert(rolling_max(numbers: [4, 3, 2, 1]) ==\
    \ [4, 4, 4, 4])\nassert(rolling_max(numbers: [3, 2, 3, 100, 3]) == [3, 3, 3, 100,\
    \ 100])"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659979942
- exit_code: -4
  program: "\n/// From a given array of integers, generate an array of rolling maximum\
    \ element found until given moment\n/// in the sequence.\n/// >>> rolling_max(numbers:\
    \ [1, 2, 3, 2, 3, 4, 2])\n/// [1, 2, 3, 3, 3, 4, 4]\nfunc rolling_max(numbers:\
    \ [Int]) -> [Int] {\n    var rolling_maxes = [Int]()\n    var max = numbers[0]\n\
    \    rolling_maxes.append(max)\n    for n in numbers[1..<numbers.count] {\n  \
    \      if n > max {\n            max = n\n        }\n        rolling_maxes.append(max)\n\
    \    }\n    return rolling_maxes\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int,\
    \ Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n\
    \    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n          \
    \  return false\n        }\n    }\n    return true\n}\n            \nassert(rolling_max(numbers:\
    \ [] as [Int]) == [] as [Int])\nassert(rolling_max(numbers: [1, 2, 3, 4]) == [1,\
    \ 2, 3, 4])\nassert(rolling_max(numbers: [4, 3, 2, 1]) == [4, 4, 4, 4])\nassert(rolling_max(numbers:\
    \ [3, 2, 3, 100, 3]) == [3, 3, 3, 100, 100])"
  status: Exception
  stderr: 'Swift/ContiguousArrayBuffer.swift:600: Fatal error: Index out of range

    Current stack trace:

    0    libswiftCore.so                    0x00002aab34f8ec80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002aab34c85561 <unavailable> + 1434977

    2    libswiftCore.so                    0x00002aab34c85286 <unavailable> + 1434246

    3    libswiftCore.so                    0x00002aab34c8513c <unavailable> + 1433916

    4    libswiftCore.so                    0x00002aab34c84bb0 _assertionFailure(_:_:file:line:flags:)
    + 251

    5    libswiftSwiftOnoneSupport.so       0x00002aab34a84e83 <unavailable> + 188035

    6    tmpipcxzf0g                        0x000055c2e4b6dc0b <unavailable> + 7179

    7    tmpipcxzf0g                        0x000055c2e4b6d6cd <unavailable> + 5837

    8    libc.so.6                          0x00002aab3517a460 __libc_start_main +
    245

    9    tmpipcxzf0g                        0x000055c2e4b6d3d9 <unavailable> + 5081

    '
  stdout: ''
  timestamp: 1659979942
- exit_code: 1
  program: "\n/// From a given array of integers, generate an array of rolling maximum\
    \ element found until given moment\n/// in the sequence.\n/// >>> rolling_max(numbers:\
    \ [1, 2, 3, 2, 3, 4, 2])\n/// [1, 2, 3, 3, 3, 4, 4]\nfunc rolling_max(numbers:\
    \ [Int]) -> [Int] {\n    return numbers.scan(0, combine: max)\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(rolling_max(numbers: [] as [Int]) == [] as [Int])\nassert(rolling_max(numbers:\
    \ [1, 2, 3, 4]) == [1, 2, 3, 4])\nassert(rolling_max(numbers: [4, 3, 2, 1]) ==\
    \ [4, 4, 4, 4])\nassert(rolling_max(numbers: [3, 2, 3, 100, 3]) == [3, 3, 3, 100,\
    \ 100])"
  status: SyntaxError
  stderr: "/tmp/tmpkbm8j58e.swift:7:37: error: generic parameter 'T' could not be\
    \ inferred\n    return numbers.scan(0, combine: max)\n                       \
    \             ^\nSwift.max:1:24: note: in call to function 'max'\n@inlinable public\
    \ func max<T>(_ x: T, _ y: T) -> T where T : Comparable\n                    \
    \   ^\n/tmp/tmpkbm8j58e.swift:7:20: error: value of type '[Int]' has no member\
    \ 'scan'\n    return numbers.scan(0, combine: max)\n           ~~~~~~~ ^~~~\n"
  stdout: ''
  timestamp: 1659979942
- exit_code: -4
  program: "\n/// From a given array of integers, generate an array of rolling maximum\
    \ element found until given moment\n/// in the sequence.\n/// >>> rolling_max(numbers:\
    \ [1, 2, 3, 2, 3, 4, 2])\n/// [1, 2, 3, 3, 3, 4, 4]\nfunc rolling_max(numbers:\
    \ [Int]) -> [Int] {\n    var numbers = numbers\n    var solution = [Int]()\n \
    \   while !numbers.isEmpty {\n        let max = numbers.max()!\n        solution.append(max)\n\
    \        numbers.remove(at: numbers.index(of: max)!)\n    }\n    return solution\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(rolling_max(numbers: [] as [Int]) == [] as [Int])\n\
    assert(rolling_max(numbers: [1, 2, 3, 4]) == [1, 2, 3, 4])\nassert(rolling_max(numbers:\
    \ [4, 3, 2, 1]) == [4, 4, 4, 4])\nassert(rolling_max(numbers: [3, 2, 3, 100, 3])\
    \ == [3, 3, 3, 100, 100])"
  status: Exception
  stderr: 'tmpvirjgyjr/tmpvirjgyjr.swift:31: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002adfbd305c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002adfbcffcb6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002adfbcffc988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002adfbcffb7b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpvirjgyjr                        0x000055e5db0447ed <unavailable> + 6125

    5    libc.so.6                          0x00002adfbd4f1460 __libc_start_main +
    245

    6    tmpvirjgyjr                        0x000055e5db044309 <unavailable> + 4873

    '
  stdout: ''
  timestamp: 1659979942
- exit_code: 0
  program: "\n/// From a given array of integers, generate an array of rolling maximum\
    \ element found until given moment\n/// in the sequence.\n/// >>> rolling_max(numbers:\
    \ [1, 2, 3, 2, 3, 4, 2])\n/// [1, 2, 3, 3, 3, 4, 4]\nfunc rolling_max(numbers:\
    \ [Int]) -> [Int] {\n    var runningMax = 0\n    var maxes = [Int]()\n    for\
    \ number in numbers {\n        if number > runningMax {\n            runningMax\
    \ = number\n        }\n        maxes.append(runningMax)\n    }\n    return maxes\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(rolling_max(numbers: [] as [Int]) == [] as [Int])\n\
    assert(rolling_max(numbers: [1, 2, 3, 4]) == [1, 2, 3, 4])\nassert(rolling_max(numbers:\
    \ [4, 3, 2, 1]) == [4, 4, 4, 4])\nassert(rolling_max(numbers: [3, 2, 3, 100, 3])\
    \ == [3, 3, 3, 100, 100])"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659979942
- exit_code: -4
  program: "\n/// From a given array of integers, generate an array of rolling maximum\
    \ element found until given moment\n/// in the sequence.\n/// >>> rolling_max(numbers:\
    \ [1, 2, 3, 2, 3, 4, 2])\n/// [1, 2, 3, 3, 3, 4, 4]\nfunc rolling_max(numbers:\
    \ [Int]) -> [Int] {\n    var maximums = [Int]()\n    var maximum = numbers[0]\n\
    \    for i in 0..<numbers.count {\n        maximum = max(maximum, numbers[i])\n\
    \        maximums.append(maximum)\n    }\n    return maximums\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(rolling_max(numbers: [] as [Int]) == [] as [Int])\nassert(rolling_max(numbers:\
    \ [1, 2, 3, 4]) == [1, 2, 3, 4])\nassert(rolling_max(numbers: [4, 3, 2, 1]) ==\
    \ [4, 4, 4, 4])\nassert(rolling_max(numbers: [3, 2, 3, 100, 3]) == [3, 3, 3, 100,\
    \ 100])"
  status: Exception
  stderr: 'Swift/ContiguousArrayBuffer.swift:600: Fatal error: Index out of range

    Current stack trace:

    0    libswiftCore.so                    0x00002ae0317d0c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002ae0314c7561 <unavailable> + 1434977

    2    libswiftCore.so                    0x00002ae0314c7286 <unavailable> + 1434246

    3    libswiftCore.so                    0x00002ae0314c713c <unavailable> + 1433916

    4    libswiftCore.so                    0x00002ae0314c6bb0 _assertionFailure(_:_:file:line:flags:)
    + 251

    5    libswiftSwiftOnoneSupport.so       0x00002ae0312c6e83 <unavailable> + 188035

    6    tmp4u4yh4bu                        0x000055e473101b68 <unavailable> + 7016

    7    tmp4u4yh4bu                        0x000055e47310162d <unavailable> + 5677

    8    libc.so.6                          0x00002ae0319bc460 __libc_start_main +
    245

    9    tmp4u4yh4bu                        0x000055e473101339 <unavailable> + 4921

    '
  stdout: ''
  timestamp: 1659979942
- exit_code: -4
  program: "\n/// From a given array of integers, generate an array of rolling maximum\
    \ element found until given moment\n/// in the sequence.\n/// >>> rolling_max(numbers:\
    \ [1, 2, 3, 2, 3, 4, 2])\n/// [1, 2, 3, 3, 3, 4, 4]\nfunc rolling_max(numbers:\
    \ [Int]) -> [Int] {\n    var max: Int = numbers[0]\n    var output: [Int] = [max]\n\
    \    for item in numbers[1..<numbers.count] {\n        if item > max {\n     \
    \       max = item\n        }\n        output.append(max)\n    }\n    return output\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(rolling_max(numbers: [] as [Int]) == [] as [Int])\n\
    assert(rolling_max(numbers: [1, 2, 3, 4]) == [1, 2, 3, 4])\nassert(rolling_max(numbers:\
    \ [4, 3, 2, 1]) == [4, 4, 4, 4])\nassert(rolling_max(numbers: [3, 2, 3, 100, 3])\
    \ == [3, 3, 3, 100, 100])"
  status: Exception
  stderr: 'Swift/ContiguousArrayBuffer.swift:600: Fatal error: Index out of range

    Current stack trace:

    0    libswiftCore.so                    0x00002ab26b4d1c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002ab26b1c8561 <unavailable> + 1434977

    2    libswiftCore.so                    0x00002ab26b1c8286 <unavailable> + 1434246

    3    libswiftCore.so                    0x00002ab26b1c813c <unavailable> + 1433916

    4    libswiftCore.so                    0x00002ab26b1c7bb0 _assertionFailure(_:_:file:line:flags:)
    + 251

    5    libswiftSwiftOnoneSupport.so       0x00002ab26afc7e83 <unavailable> + 188035

    6    tmpp4tj_yuv                        0x000055fce4cbaba8 <unavailable> + 7080

    7    tmpp4tj_yuv                        0x000055fce4cba67d <unavailable> + 5757

    8    libc.so.6                          0x00002ab26b6bd460 __libc_start_main +
    245

    9    tmpp4tj_yuv                        0x000055fce4cba389 <unavailable> + 5001

    '
  stdout: ''
  timestamp: 1659979942
- exit_code: 1
  program: "\n/// From a given array of integers, generate an array of rolling maximum\
    \ element found until given moment\n/// in the sequence.\n/// >>> rolling_max(numbers:\
    \ [1, 2, 3, 2, 3, 4, 2])\n/// [1, 2, 3, 3, 3, 4, 4]\nfunc rolling_max(numbers:\
    \ [Int]) -> [Int] {\n    return generate_rolling_array(numbers: numbers, operation:\
    \ max)\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n  \
    \  if left.count != right.count {\n        return false\n    }\n    for (l, r)\
    \ in zip(left, right) {\n        if l != r {\n            return false\n     \
    \   }\n    }\n    return true\n}\n            \nassert(rolling_max(numbers: []\
    \ as [Int]) == [] as [Int])\nassert(rolling_max(numbers: [1, 2, 3, 4]) == [1,\
    \ 2, 3, 4])\nassert(rolling_max(numbers: [4, 3, 2, 1]) == [4, 4, 4, 4])\nassert(rolling_max(numbers:\
    \ [3, 2, 3, 100, 3]) == [3, 3, 3, 100, 100])"
  status: SyntaxError
  stderr: "/tmp/tmp4annded4.swift:7:12: error: cannot find 'generate_rolling_array'\
    \ in scope\n    return generate_rolling_array(numbers: numbers, operation: max)\n\
    \           ^~~~~~~~~~~~~~~~~~~~~~\n/tmp/tmp4annded4.swift:7:64: error: generic\
    \ parameter 'T' could not be inferred\n    return generate_rolling_array(numbers:\
    \ numbers, operation: max)\n                                                 \
    \              ^\nSwift.max:1:24: note: in call to function 'max'\n@inlinable\
    \ public func max<T>(_ x: T, _ y: T) -> T where T : Comparable\n             \
    \          ^\n"
  stdout: ''
  timestamp: 1659979942
- exit_code: -4
  program: "\n/// From a given array of integers, generate an array of rolling maximum\
    \ element found until given moment\n/// in the sequence.\n/// >>> rolling_max(numbers:\
    \ [1, 2, 3, 2, 3, 4, 2])\n/// [1, 2, 3, 3, 3, 4, 4]\nfunc rolling_max(numbers:\
    \ [Int]) -> [Int] {\n    var max = numbers[0]\n    var output = [Int]()\n    for\
    \ i in numbers {\n        if i > max {\n            max = i\n        }\n     \
    \   output.append(max)\n    }\n    return output\n}\n\n\nfunc ==(left: [(Int,\
    \ Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n\
    \        return false\n    }\n    for (l, r) in zip(left, right) {\n        if\
    \ l != r {\n            return false\n        }\n    }\n    return true\n}\n \
    \           \nassert(rolling_max(numbers: [] as [Int]) == [] as [Int])\nassert(rolling_max(numbers:\
    \ [1, 2, 3, 4]) == [1, 2, 3, 4])\nassert(rolling_max(numbers: [4, 3, 2, 1]) ==\
    \ [4, 4, 4, 4])\nassert(rolling_max(numbers: [3, 2, 3, 100, 3]) == [3, 3, 3, 100,\
    \ 100])"
  status: Exception
  stderr: 'Swift/ContiguousArrayBuffer.swift:600: Fatal error: Index out of range

    Current stack trace:

    0    libswiftCore.so                    0x00002b7d1c677c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b7d1c36e561 <unavailable> + 1434977

    2    libswiftCore.so                    0x00002b7d1c36e286 <unavailable> + 1434246

    3    libswiftCore.so                    0x00002b7d1c36e13c <unavailable> + 1433916

    4    libswiftCore.so                    0x00002b7d1c36dbb0 _assertionFailure(_:_:file:line:flags:)
    + 251

    5    libswiftSwiftOnoneSupport.so       0x00002b7d1c16de83 <unavailable> + 188035

    6    tmp4xc9desw                        0x0000558303cd5a52 <unavailable> + 6738

    7    tmp4xc9desw                        0x0000558303cd552d <unavailable> + 5421

    8    libc.so.6                          0x00002b7d1c863460 __libc_start_main +
    245

    9    tmp4xc9desw                        0x0000558303cd5239 <unavailable> + 4665

    '
  stdout: ''
  timestamp: 1659979942
- exit_code: 1
  program: "\n/// From a given array of integers, generate an array of rolling maximum\
    \ element found until given moment\n/// in the sequence.\n/// >>> rolling_max(numbers:\
    \ [1, 2, 3, 2, 3, 4, 2])\n/// [1, 2, 3, 3, 3, 4, 4]\nfunc rolling_max(numbers:\
    \ [Int]) -> [Int] {\n    var result = [Int]()\n    var max = numbers[0]\n    for\
    \ number in numbers {\n        max = max(max, number)\n        result.append(max)\n\
    \    }\n    return result\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(rolling_max(numbers:\
    \ [] as [Int]) == [] as [Int])\nassert(rolling_max(numbers: [1, 2, 3, 4]) == [1,\
    \ 2, 3, 4])\nassert(rolling_max(numbers: [4, 3, 2, 1]) == [4, 4, 4, 4])\nassert(rolling_max(numbers:\
    \ [3, 2, 3, 100, 3]) == [3, 3, 3, 100, 100])"
  status: SyntaxError
  stderr: "/tmp/tmprwd0at34.swift:10:15: error: cannot call value of non-function\
    \ type 'Int'\n        max = max(max, number)\n              ^\n"
  stdout: ''
  timestamp: 1659979942
- exit_code: -4
  program: "\n/// From a given array of integers, generate an array of rolling maximum\
    \ element found until given moment\n/// in the sequence.\n/// >>> rolling_max(numbers:\
    \ [1, 2, 3, 2, 3, 4, 2])\n/// [1, 2, 3, 3, 3, 4, 4]\nfunc rolling_max(numbers:\
    \ [Int]) -> [Int] {\n    var currentMax = numbers[0]\n    var result = [Int]()\n\
    \    for number in numbers {\n        currentMax = max(currentMax, number)\n \
    \       result.append(currentMax)\n    }\n    return result\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(rolling_max(numbers: [] as [Int]) == [] as [Int])\nassert(rolling_max(numbers:\
    \ [1, 2, 3, 4]) == [1, 2, 3, 4])\nassert(rolling_max(numbers: [4, 3, 2, 1]) ==\
    \ [4, 4, 4, 4])\nassert(rolling_max(numbers: [3, 2, 3, 100, 3]) == [3, 3, 3, 100,\
    \ 100])"
  status: Exception
  stderr: 'Swift/ContiguousArrayBuffer.swift:600: Fatal error: Index out of range

    Current stack trace:

    0    libswiftCore.so                    0x00002b2dc1c32c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b2dc1929561 <unavailable> + 1434977

    2    libswiftCore.so                    0x00002b2dc1929286 <unavailable> + 1434246

    3    libswiftCore.so                    0x00002b2dc192913c <unavailable> + 1433916

    4    libswiftCore.so                    0x00002b2dc1928bb0 _assertionFailure(_:_:file:line:flags:)
    + 251

    5    libswiftSwiftOnoneSupport.so       0x00002b2dc1728e83 <unavailable> + 188035

    6    tmp7x1krqyb                        0x0000563efc32cae8 <unavailable> + 6888

    7    tmp7x1krqyb                        0x0000563efc32c5bd <unavailable> + 5565

    8    libc.so.6                          0x00002b2dc1e1e460 __libc_start_main +
    245

    9    tmp7x1krqyb                        0x0000563efc32c2c9 <unavailable> + 4809

    '
  stdout: ''
  timestamp: 1659979942
- exit_code: 1
  program: "\n/// From a given array of integers, generate an array of rolling maximum\
    \ element found until given moment\n/// in the sequence.\n/// >>> rolling_max(numbers:\
    \ [1, 2, 3, 2, 3, 4, 2])\n/// [1, 2, 3, 3, 3, 4, 4]\nfunc rolling_max(numbers:\
    \ [Int]) -> [Int] {\n    var result = [Int]()\n    var max = Int.min\n    for\
    \ number in numbers {\n        max = max(max, number)\n        result.append(max)\n\
    \    }\n    return result\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(rolling_max(numbers:\
    \ [] as [Int]) == [] as [Int])\nassert(rolling_max(numbers: [1, 2, 3, 4]) == [1,\
    \ 2, 3, 4])\nassert(rolling_max(numbers: [4, 3, 2, 1]) == [4, 4, 4, 4])\nassert(rolling_max(numbers:\
    \ [3, 2, 3, 100, 3]) == [3, 3, 3, 100, 100])"
  status: SyntaxError
  stderr: "/tmp/tmpmuh56_05.swift:10:15: error: cannot call value of non-function\
    \ type 'Int'\n        max = max(max, number)\n              ^\n"
  stdout: ''
  timestamp: 1659979942
- exit_code: -4
  program: "\n/// From a given array of integers, generate an array of rolling maximum\
    \ element found until given moment\n/// in the sequence.\n/// >>> rolling_max(numbers:\
    \ [1, 2, 3, 2, 3, 4, 2])\n/// [1, 2, 3, 3, 3, 4, 4]\nfunc rolling_max(numbers:\
    \ [Int]) -> [Int] {\n    return numbers.enumerated().map { (index, element) ->\
    \ Int in\n        let numbersFromHere = numbers[index...]\n        return numbersFromHere.max()!\n\
    \    }\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n  \
    \  if left.count != right.count {\n        return false\n    }\n    for (l, r)\
    \ in zip(left, right) {\n        if l != r {\n            return false\n     \
    \   }\n    }\n    return true\n}\n            \nassert(rolling_max(numbers: []\
    \ as [Int]) == [] as [Int])\nassert(rolling_max(numbers: [1, 2, 3, 4]) == [1,\
    \ 2, 3, 4])\nassert(rolling_max(numbers: [4, 3, 2, 1]) == [4, 4, 4, 4])\nassert(rolling_max(numbers:\
    \ [3, 2, 3, 100, 3]) == [3, 3, 3, 100, 100])"
  status: Exception
  stderr: 'tmpy0gz6vic/tmpy0gz6vic.swift:27: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b7cbaba3c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b7cba89ab6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b7cba89a988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b7cba8997b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpy0gz6vic                        0x000055817110f93d <unavailable> + 6461

    5    libc.so.6                          0x00002b7cbad8f460 __libc_start_main +
    245

    6    tmpy0gz6vic                        0x000055817110f459 <unavailable> + 5209

    '
  stdout: ''
  timestamp: 1659979942
- exit_code: 0
  program: "\n/// From a given array of integers, generate an array of rolling maximum\
    \ element found until given moment\n/// in the sequence.\n/// >>> rolling_max(numbers:\
    \ [1, 2, 3, 2, 3, 4, 2])\n/// [1, 2, 3, 3, 3, 4, 4]\nfunc rolling_max(numbers:\
    \ [Int]) -> [Int] {\n    var result = [Int]()\n    var max_so_far = 0\n    for\
    \ number in numbers {\n        max_so_far = max(max_so_far, number)\n        result.append(max_so_far)\n\
    \    }\n    return result\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(rolling_max(numbers:\
    \ [] as [Int]) == [] as [Int])\nassert(rolling_max(numbers: [1, 2, 3, 4]) == [1,\
    \ 2, 3, 4])\nassert(rolling_max(numbers: [4, 3, 2, 1]) == [4, 4, 4, 4])\nassert(rolling_max(numbers:\
    \ [3, 2, 3, 100, 3]) == [3, 3, 3, 100, 100])"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659979942
- exit_code: -4
  program: "\n/// From a given array of integers, generate an array of rolling maximum\
    \ element found until given moment\n/// in the sequence.\n/// >>> rolling_max(numbers:\
    \ [1, 2, 3, 2, 3, 4, 2])\n/// [1, 2, 3, 3, 3, 4, 4]\nfunc rolling_max(numbers:\
    \ [Int]) -> [Int] {\n    return []\n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(rolling_max(numbers: [] as [Int]) == [] as [Int])\nassert(rolling_max(numbers:\
    \ [1, 2, 3, 4]) == [1, 2, 3, 4])\nassert(rolling_max(numbers: [4, 3, 2, 1]) ==\
    \ [4, 4, 4, 4])\nassert(rolling_max(numbers: [3, 2, 3, 100, 3]) == [3, 3, 3, 100,\
    \ 100])"
  status: Exception
  stderr: 'tmp9fy9csjx/tmp9fy9csjx.swift:24: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b188eb4ac80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b188e841b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b188e841988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b188e8407b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmp9fy9csjx                        0x000055fa16c564ad <unavailable> + 5293

    5    libc.so.6                          0x00002b188ed36460 __libc_start_main +
    245

    6    tmp9fy9csjx                        0x000055fa16c55fc9 <unavailable> + 4041

    '
  stdout: ''
  timestamp: 1659979941
- exit_code: -4
  program: "\n/// From a given array of integers, generate an array of rolling maximum\
    \ element found until given moment\n/// in the sequence.\n/// >>> rolling_max(numbers:\
    \ [1, 2, 3, 2, 3, 4, 2])\n/// [1, 2, 3, 3, 3, 4, 4]\nfunc rolling_max(numbers:\
    \ [Int]) -> [Int] {\n    var index = 0\n    var maxValue = numbers[0]\n    var\
    \ result = [Int]()\n    while index < numbers.count {\n        if numbers[index]\
    \ > maxValue {\n            maxValue = numbers[index]\n        }\n        result.append(maxValue)\n\
    \        index += 1\n    }\n    return result\n}\n\n\nfunc ==(left: [(Int, Int)],\
    \ right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n       \
    \ return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r\
    \ {\n            return false\n        }\n    }\n    return true\n}\n        \
    \    \nassert(rolling_max(numbers: [] as [Int]) == [] as [Int])\nassert(rolling_max(numbers:\
    \ [1, 2, 3, 4]) == [1, 2, 3, 4])\nassert(rolling_max(numbers: [4, 3, 2, 1]) ==\
    \ [4, 4, 4, 4])\nassert(rolling_max(numbers: [3, 2, 3, 100, 3]) == [3, 3, 3, 100,\
    \ 100])"
  status: Exception
  stderr: 'Swift/ContiguousArrayBuffer.swift:600: Fatal error: Index out of range

    Current stack trace:

    0    libswiftCore.so                    0x00002ba86f559c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002ba86f250561 <unavailable> + 1434977

    2    libswiftCore.so                    0x00002ba86f250286 <unavailable> + 1434246

    3    libswiftCore.so                    0x00002ba86f25013c <unavailable> + 1433916

    4    libswiftCore.so                    0x00002ba86f24fbb0 _assertionFailure(_:_:file:line:flags:)
    + 251

    5    libswiftSwiftOnoneSupport.so       0x00002ba86f04fe83 <unavailable> + 188035

    6    tmp90hw0mho                        0x00005576bd06e937 <unavailable> + 6455

    7    tmp90hw0mho                        0x00005576bd06e41d <unavailable> + 5149

    8    libc.so.6                          0x00002ba86f745460 __libc_start_main +
    245

    9    tmp90hw0mho                        0x00005576bd06e129 <unavailable> + 4393

    '
  stdout: ''
  timestamp: 1659979942
- exit_code: 0
  program: "\n/// From a given array of integers, generate an array of rolling maximum\
    \ element found until given moment\n/// in the sequence.\n/// >>> rolling_max(numbers:\
    \ [1, 2, 3, 2, 3, 4, 2])\n/// [1, 2, 3, 3, 3, 4, 4]\nfunc rolling_max(numbers:\
    \ [Int]) -> [Int] {\n    guard !numbers.isEmpty else { return [] }\n    var max_so_far\
    \ = numbers[0]\n    var rolling_max = [max_so_far]\n    for i in 1..<numbers.count\
    \ {\n        max_so_far = max(max_so_far, numbers[i])\n        rolling_max.append(max_so_far)\n\
    \    }\n    return rolling_max\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int,\
    \ Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n\
    \    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n          \
    \  return false\n        }\n    }\n    return true\n}\n            \nassert(rolling_max(numbers:\
    \ [] as [Int]) == [] as [Int])\nassert(rolling_max(numbers: [1, 2, 3, 4]) == [1,\
    \ 2, 3, 4])\nassert(rolling_max(numbers: [4, 3, 2, 1]) == [4, 4, 4, 4])\nassert(rolling_max(numbers:\
    \ [3, 2, 3, 100, 3]) == [3, 3, 3, 100, 100])"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659979942
- exit_code: 0
  program: "\n/// From a given array of integers, generate an array of rolling maximum\
    \ element found until given moment\n/// in the sequence.\n/// >>> rolling_max(numbers:\
    \ [1, 2, 3, 2, 3, 4, 2])\n/// [1, 2, 3, 3, 3, 4, 4]\nfunc rolling_max(numbers:\
    \ [Int]) -> [Int] {\n    var numbers = numbers\n    var result = [Int]()\n   \
    \ var maxSoFar = Int.min\n    for (i, n) in numbers.enumerated() {\n        numbers[i]\
    \ = max(n, maxSoFar)\n        maxSoFar = numbers[i]\n    }\n    return numbers\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(rolling_max(numbers: [] as [Int]) == [] as [Int])\n\
    assert(rolling_max(numbers: [1, 2, 3, 4]) == [1, 2, 3, 4])\nassert(rolling_max(numbers:\
    \ [4, 3, 2, 1]) == [4, 4, 4, 4])\nassert(rolling_max(numbers: [3, 2, 3, 100, 3])\
    \ == [3, 3, 3, 100, 100])"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659979942
- exit_code: 0
  program: "\n/// From a given array of integers, generate an array of rolling maximum\
    \ element found until given moment\n/// in the sequence.\n/// >>> rolling_max(numbers:\
    \ [1, 2, 3, 2, 3, 4, 2])\n/// [1, 2, 3, 3, 3, 4, 4]\nfunc rolling_max(numbers:\
    \ [Int]) -> [Int] {\n    var result = [Int]()\n    for number in numbers {\n \
    \       result.append(result.last ?? number)\n        if result.last! < number\
    \ {\n            result[result.count - 1] = number\n        }\n    }\n    return\
    \ result\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n\
    \    if left.count != right.count {\n        return false\n    }\n    for (l,\
    \ r) in zip(left, right) {\n        if l != r {\n            return false\n  \
    \      }\n    }\n    return true\n}\n            \nassert(rolling_max(numbers:\
    \ [] as [Int]) == [] as [Int])\nassert(rolling_max(numbers: [1, 2, 3, 4]) == [1,\
    \ 2, 3, 4])\nassert(rolling_max(numbers: [4, 3, 2, 1]) == [4, 4, 4, 4])\nassert(rolling_max(numbers:\
    \ [3, 2, 3, 100, 3]) == [3, 3, 3, 100, 100])"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659979942
- exit_code: 0
  program: "\n/// From a given array of integers, generate an array of rolling maximum\
    \ element found until given moment\n/// in the sequence.\n/// >>> rolling_max(numbers:\
    \ [1, 2, 3, 2, 3, 4, 2])\n/// [1, 2, 3, 3, 3, 4, 4]\nfunc rolling_max(numbers:\
    \ [Int]) -> [Int] {\n    var rolling_max_array = [Int]()\n    for number in numbers\
    \ {\n        if rolling_max_array.isEmpty {\n            rolling_max_array.append(number)\n\
    \        } else {\n            rolling_max_array.append(max(rolling_max_array.last!,\
    \ number))\n        }\n    }\n    return rolling_max_array\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(rolling_max(numbers: [] as [Int]) == [] as [Int])\nassert(rolling_max(numbers:\
    \ [1, 2, 3, 4]) == [1, 2, 3, 4])\nassert(rolling_max(numbers: [4, 3, 2, 1]) ==\
    \ [4, 4, 4, 4])\nassert(rolling_max(numbers: [3, 2, 3, 100, 3]) == [3, 3, 3, 100,\
    \ 100])"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659979942
- exit_code: 1
  program: "\n/// From a given array of integers, generate an array of rolling maximum\
    \ element found until given moment\n/// in the sequence.\n/// >>> rolling_max(numbers:\
    \ [1, 2, 3, 2, 3, 4, 2])\n/// [1, 2, 3, 3, 3, 4, 4]\nfunc rolling_max(numbers:\
    \ [Int]) -> [Int] {\n    // this is a temporary solution\n    //  - because of\
    \ the given solution is O(n^2)\n    //  - the optimal one is O(n) using deque\n\
    \    // the optimal solution is located in the file deque.swift\n    guard !numbers.isEmpty\
    \ else { return [] }\n    var tmp: [Int] = []\n    for i in 0..<numbers.count\
    \ {\n        tmp.append(max(numbers[0..<i+1]))\n    }\n    return tmp\n}\n\n\n\
    func ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(rolling_max(numbers: [] as [Int]) == [] as [Int])\n\
    assert(rolling_max(numbers: [1, 2, 3, 4]) == [1, 2, 3, 4])\nassert(rolling_max(numbers:\
    \ [4, 3, 2, 1]) == [4, 4, 4, 4])\nassert(rolling_max(numbers: [3, 2, 3, 100, 3])\
    \ == [3, 3, 3, 100, 100])"
  status: SyntaxError
  stderr: "/tmp/tmp5589ahh_.swift:14:33: error: cannot convert value of type 'Range<Int>'\
    \ to expected argument type 'Int'\n        tmp.append(max(numbers[0..<i+1]))\n\
    \                                ^\n/tmp/tmp5589ahh_.swift:14:40: error: missing\
    \ argument for parameter #2 in call\n        tmp.append(max(numbers[0..<i+1]))\n\
    \                                       ^\n                                  \
    \     , <#Int#>\nSwift.max:1:24: note: 'max' declared here\n@inlinable public\
    \ func max<T>(_ x: T, _ y: T) -> T where T : Comparable\n                    \
    \   ^\n"
  stdout: ''
  timestamp: 1659979942
- exit_code: -4
  program: "\n/// From a given array of integers, generate an array of rolling maximum\
    \ element found until given moment\n/// in the sequence.\n/// >>> rolling_max(numbers:\
    \ [1, 2, 3, 2, 3, 4, 2])\n/// [1, 2, 3, 3, 3, 4, 4]\nfunc rolling_max(numbers:\
    \ [Int]) -> [Int] {\n  var result = [Int]()\n  var max = numbers[0]\n  for number\
    \ in numbers {\n    if number > max {\n      max = number\n    }\n    result.append(max)\n\
    \  }\n  return result\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(rolling_max(numbers:\
    \ [] as [Int]) == [] as [Int])\nassert(rolling_max(numbers: [1, 2, 3, 4]) == [1,\
    \ 2, 3, 4])\nassert(rolling_max(numbers: [4, 3, 2, 1]) == [4, 4, 4, 4])\nassert(rolling_max(numbers:\
    \ [3, 2, 3, 100, 3]) == [3, 3, 3, 100, 100])"
  status: Exception
  stderr: 'Swift/ContiguousArrayBuffer.swift:600: Fatal error: Index out of range

    Current stack trace:

    0    libswiftCore.so                    0x00002b9f57f12c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b9f57c09561 <unavailable> + 1434977

    2    libswiftCore.so                    0x00002b9f57c09286 <unavailable> + 1434246

    3    libswiftCore.so                    0x00002b9f57c0913c <unavailable> + 1433916

    4    libswiftCore.so                    0x00002b9f57c08bb0 _assertionFailure(_:_:file:line:flags:)
    + 251

    5    libswiftSwiftOnoneSupport.so       0x00002b9f57a08e83 <unavailable> + 188035

    6    tmpyt83devy                        0x000055804f0d6a5f <unavailable> + 6751

    7    tmpyt83devy                        0x000055804f0d652d <unavailable> + 5421

    8    libc.so.6                          0x00002b9f580fe460 __libc_start_main +
    245

    9    tmpyt83devy                        0x000055804f0d6239 <unavailable> + 4665

    '
  stdout: ''
  timestamp: 1659979942
- exit_code: -4
  program: "\n/// From a given array of integers, generate an array of rolling maximum\
    \ element found until given moment\n/// in the sequence.\n/// >>> rolling_max(numbers:\
    \ [1, 2, 3, 2, 3, 4, 2])\n/// [1, 2, 3, 3, 3, 4, 4]\nfunc rolling_max(numbers:\
    \ [Int]) -> [Int] {\n    var result = [Int]()\n    var max = numbers[0]\n    result.append(max)\n\
    \    for i in 1..<numbers.count {\n        if numbers[i] > max {\n           \
    \ max = numbers[i]\n        }\n        result.append(max)\n    }\n    return result\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(rolling_max(numbers: [] as [Int]) == [] as [Int])\n\
    assert(rolling_max(numbers: [1, 2, 3, 4]) == [1, 2, 3, 4])\nassert(rolling_max(numbers:\
    \ [4, 3, 2, 1]) == [4, 4, 4, 4])\nassert(rolling_max(numbers: [3, 2, 3, 100, 3])\
    \ == [3, 3, 3, 100, 100])"
  status: Exception
  stderr: 'Swift/ContiguousArrayBuffer.swift:600: Fatal error: Index out of range

    Current stack trace:

    0    libswiftCore.so                    0x00002ba2c634dc80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002ba2c6044561 <unavailable> + 1434977

    2    libswiftCore.so                    0x00002ba2c6044286 <unavailable> + 1434246

    3    libswiftCore.so                    0x00002ba2c604413c <unavailable> + 1433916

    4    libswiftCore.so                    0x00002ba2c6043bb0 _assertionFailure(_:_:file:line:flags:)
    + 251

    5    libswiftSwiftOnoneSupport.so       0x00002ba2c5e43e83 <unavailable> + 188035

    6    tmpdio67vjk                        0x0000560ee0476ae8 <unavailable> + 6888

    7    tmpdio67vjk                        0x0000560ee04765ad <unavailable> + 5549

    8    libc.so.6                          0x00002ba2c6539460 __libc_start_main +
    245

    9    tmpdio67vjk                        0x0000560ee04762b9 <unavailable> + 4793

    '
  stdout: ''
  timestamp: 1659979942
- exit_code: -4
  program: "\n/// From a given array of integers, generate an array of rolling maximum\
    \ element found until given moment\n/// in the sequence.\n/// >>> rolling_max(numbers:\
    \ [1, 2, 3, 2, 3, 4, 2])\n/// [1, 2, 3, 3, 3, 4, 4]\nfunc rolling_max(numbers:\
    \ [Int]) -> [Int] {\n    var max = numbers[0]\n    var rollingMaxes = [Int]()\n\
    \    for i in 0..<numbers.count {\n        if max < numbers[i] {\n           \
    \ max = numbers[i]\n        }\n        rollingMaxes.append(max)\n    }\n    return\
    \ rollingMaxes\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool\
    \ {\n    if left.count != right.count {\n        return false\n    }\n    for\
    \ (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(rolling_max(numbers:\
    \ [] as [Int]) == [] as [Int])\nassert(rolling_max(numbers: [1, 2, 3, 4]) == [1,\
    \ 2, 3, 4])\nassert(rolling_max(numbers: [4, 3, 2, 1]) == [4, 4, 4, 4])\nassert(rolling_max(numbers:\
    \ [3, 2, 3, 100, 3]) == [3, 3, 3, 100, 100])"
  status: Exception
  stderr: 'Swift/ContiguousArrayBuffer.swift:600: Fatal error: Index out of range

    Current stack trace:

    0    libswiftCore.so                    0x00002b62f2b7ac80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b62f2871561 <unavailable> + 1434977

    2    libswiftCore.so                    0x00002b62f2871286 <unavailable> + 1434246

    3    libswiftCore.so                    0x00002b62f287113c <unavailable> + 1433916

    4    libswiftCore.so                    0x00002b62f2870bb0 _assertionFailure(_:_:file:line:flags:)
    + 251

    5    libswiftSwiftOnoneSupport.so       0x00002b62f2670e83 <unavailable> + 188035

    6    tmp94rthngq                        0x00005615c4534ad8 <unavailable> + 6872

    7    tmp94rthngq                        0x00005615c45345ad <unavailable> + 5549

    8    libc.so.6                          0x00002b62f2d66460 __libc_start_main +
    245

    9    tmp94rthngq                        0x00005615c45342b9 <unavailable> + 4793

    '
  stdout: ''
  timestamp: 1659979942
- exit_code: 0
  program: "\n/// From a given array of integers, generate an array of rolling maximum\
    \ element found until given moment\n/// in the sequence.\n/// >>> rolling_max(numbers:\
    \ [1, 2, 3, 2, 3, 4, 2])\n/// [1, 2, 3, 3, 3, 4, 4]\nfunc rolling_max(numbers:\
    \ [Int]) -> [Int] {\n    var result = [Int]()\n    var currentMax = Int.min\n\
    \    for num in numbers {\n        if num > currentMax {\n            currentMax\
    \ = num\n        }\n        result.append(currentMax)\n    }\n    return result\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(rolling_max(numbers: [] as [Int]) == [] as [Int])\n\
    assert(rolling_max(numbers: [1, 2, 3, 4]) == [1, 2, 3, 4])\nassert(rolling_max(numbers:\
    \ [4, 3, 2, 1]) == [4, 4, 4, 4])\nassert(rolling_max(numbers: [3, 2, 3, 100, 3])\
    \ == [3, 3, 3, 100, 100])"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659979942
- exit_code: 0
  program: "\n/// From a given array of integers, generate an array of rolling maximum\
    \ element found until given moment\n/// in the sequence.\n/// >>> rolling_max(numbers:\
    \ [1, 2, 3, 2, 3, 4, 2])\n/// [1, 2, 3, 3, 3, 4, 4]\nfunc rolling_max(numbers:\
    \ [Int]) -> [Int] {\n    var rolling_max = [Int]()\n    var max_value = Int.min\n\
    \    for i in 0 ..< numbers.count {\n        max_value = max(max_value, numbers[i])\n\
    \        rolling_max.append(max_value)\n    }\n    return rolling_max\n}\n\n\n\
    func ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(rolling_max(numbers: [] as [Int]) == [] as [Int])\n\
    assert(rolling_max(numbers: [1, 2, 3, 4]) == [1, 2, 3, 4])\nassert(rolling_max(numbers:\
    \ [4, 3, 2, 1]) == [4, 4, 4, 4])\nassert(rolling_max(numbers: [3, 2, 3, 100, 3])\
    \ == [3, 3, 3, 100, 100])"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659979942
- exit_code: -4
  program: "\n/// From a given array of integers, generate an array of rolling maximum\
    \ element found until given moment\n/// in the sequence.\n/// >>> rolling_max(numbers:\
    \ [1, 2, 3, 2, 3, 4, 2])\n/// [1, 2, 3, 3, 3, 4, 4]\nfunc rolling_max(numbers:\
    \ [Int]) -> [Int] {\n    var max_element = numbers[0]\n    var rolling_max = [Int]()\n\
    \    for number in numbers {\n        max_element = max(max_element, number)\n\
    \        rolling_max.append(max_element)\n    }\n    return rolling_max\n}\n\n\
    \nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(rolling_max(numbers: [] as [Int]) == [] as [Int])\n\
    assert(rolling_max(numbers: [1, 2, 3, 4]) == [1, 2, 3, 4])\nassert(rolling_max(numbers:\
    \ [4, 3, 2, 1]) == [4, 4, 4, 4])\nassert(rolling_max(numbers: [3, 2, 3, 100, 3])\
    \ == [3, 3, 3, 100, 100])"
  status: Exception
  stderr: 'Swift/ContiguousArrayBuffer.swift:600: Fatal error: Index out of range

    Current stack trace:

    0    libswiftCore.so                    0x00002b7f4ab9ac80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b7f4a891561 <unavailable> + 1434977

    2    libswiftCore.so                    0x00002b7f4a891286 <unavailable> + 1434246

    3    libswiftCore.so                    0x00002b7f4a89113c <unavailable> + 1433916

    4    libswiftCore.so                    0x00002b7f4a890bb0 _assertionFailure(_:_:file:line:flags:)
    + 251

    5    libswiftSwiftOnoneSupport.so       0x00002b7f4a690e83 <unavailable> + 188035

    6    tmpe0w27k6s                        0x000055eeb4220ae8 <unavailable> + 6888

    7    tmpe0w27k6s                        0x000055eeb42205bd <unavailable> + 5565

    8    libc.so.6                          0x00002b7f4ad86460 __libc_start_main +
    245

    9    tmpe0w27k6s                        0x000055eeb42202c9 <unavailable> + 4809

    '
  stdout: ''
  timestamp: 1659979942
- exit_code: 0
  program: "\n/// From a given array of integers, generate an array of rolling maximum\
    \ element found until given moment\n/// in the sequence.\n/// >>> rolling_max(numbers:\
    \ [1, 2, 3, 2, 3, 4, 2])\n/// [1, 2, 3, 3, 3, 4, 4]\nfunc rolling_max(numbers:\
    \ [Int]) -> [Int] {\n    var results = [Int]()\n    var maxNumber = 0\n    for\
    \ number in numbers {\n        if maxNumber < number {\n            maxNumber\
    \ = number\n        }\n        results.append(maxNumber)\n    }\n    return results\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(rolling_max(numbers: [] as [Int]) == [] as [Int])\n\
    assert(rolling_max(numbers: [1, 2, 3, 4]) == [1, 2, 3, 4])\nassert(rolling_max(numbers:\
    \ [4, 3, 2, 1]) == [4, 4, 4, 4])\nassert(rolling_max(numbers: [3, 2, 3, 100, 3])\
    \ == [3, 3, 3, 100, 100])"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659979942
- exit_code: 0
  program: "\n/// From a given array of integers, generate an array of rolling maximum\
    \ element found until given moment\n/// in the sequence.\n/// >>> rolling_max(numbers:\
    \ [1, 2, 3, 2, 3, 4, 2])\n/// [1, 2, 3, 3, 3, 4, 4]\nfunc rolling_max(numbers:\
    \ [Int]) -> [Int] {\n    var result = [Int]()\n    var current_max = Int.min\n\
    \    for number in numbers {\n        if number > current_max {\n            current_max\
    \ = number\n        }\n        result.append(current_max)\n    }\n    return result\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(rolling_max(numbers: [] as [Int]) == [] as [Int])\n\
    assert(rolling_max(numbers: [1, 2, 3, 4]) == [1, 2, 3, 4])\nassert(rolling_max(numbers:\
    \ [4, 3, 2, 1]) == [4, 4, 4, 4])\nassert(rolling_max(numbers: [3, 2, 3, 100, 3])\
    \ == [3, 3, 3, 100, 100])"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659979942
- exit_code: 0
  program: "\n/// From a given array of integers, generate an array of rolling maximum\
    \ element found until given moment\n/// in the sequence.\n/// >>> rolling_max(numbers:\
    \ [1, 2, 3, 2, 3, 4, 2])\n/// [1, 2, 3, 3, 3, 4, 4]\nfunc rolling_max(numbers:\
    \ [Int]) -> [Int] {\n    \n    var finalArray = [Int]()\n    var maxTmp = Int.min\n\
    \    \n    for number in numbers {\n        maxTmp = max(maxTmp, number)\n   \
    \     finalArray.append(maxTmp)\n    }\n    \n    return finalArray\n}\n\n\nfunc\
    \ ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count !=\
    \ right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(rolling_max(numbers: [] as [Int]) == [] as [Int])\n\
    assert(rolling_max(numbers: [1, 2, 3, 4]) == [1, 2, 3, 4])\nassert(rolling_max(numbers:\
    \ [4, 3, 2, 1]) == [4, 4, 4, 4])\nassert(rolling_max(numbers: [3, 2, 3, 100, 3])\
    \ == [3, 3, 3, 100, 100])"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659979942
- exit_code: -4
  program: "\n/// From a given array of integers, generate an array of rolling maximum\
    \ element found until given moment\n/// in the sequence.\n/// >>> rolling_max(numbers:\
    \ [1, 2, 3, 2, 3, 4, 2])\n/// [1, 2, 3, 3, 3, 4, 4]\nfunc rolling_max(numbers:\
    \ [Int]) -> [Int] {\n    var maxes = [Int]()\n    var maximum = numbers[0]\n \
    \   for i in 0..<numbers.count {\n        if numbers[i] > maximum {\n        \
    \    maximum = numbers[i]\n        }\n        maxes.append(maximum)\n    }\n \
    \   return maxes\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool\
    \ {\n    if left.count != right.count {\n        return false\n    }\n    for\
    \ (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(rolling_max(numbers:\
    \ [] as [Int]) == [] as [Int])\nassert(rolling_max(numbers: [1, 2, 3, 4]) == [1,\
    \ 2, 3, 4])\nassert(rolling_max(numbers: [4, 3, 2, 1]) == [4, 4, 4, 4])\nassert(rolling_max(numbers:\
    \ [3, 2, 3, 100, 3]) == [3, 3, 3, 100, 100])"
  status: Exception
  stderr: 'Swift/ContiguousArrayBuffer.swift:600: Fatal error: Index out of range

    Current stack trace:

    0    libswiftCore.so                    0x00002afa35c8cc80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002afa35983561 <unavailable> + 1434977

    2    libswiftCore.so                    0x00002afa35983286 <unavailable> + 1434246

    3    libswiftCore.so                    0x00002afa3598313c <unavailable> + 1433916

    4    libswiftCore.so                    0x00002afa35982bb0 _assertionFailure(_:_:file:line:flags:)
    + 251

    5    libswiftSwiftOnoneSupport.so       0x00002afa35782e83 <unavailable> + 188035

    6    tmp_hhs3bt_                        0x000055e47ff6dae8 <unavailable> + 6888

    7    tmp_hhs3bt_                        0x000055e47ff6d5ad <unavailable> + 5549

    8    libc.so.6                          0x00002afa35e78460 __libc_start_main +
    245

    9    tmp_hhs3bt_                        0x000055e47ff6d2b9 <unavailable> + 4793

    '
  stdout: ''
  timestamp: 1659979942
- exit_code: 1
  program: "\n/// From a given array of integers, generate an array of rolling maximum\
    \ element found until given moment\n/// in the sequence.\n/// >>> rolling_max(numbers:\
    \ [1, 2, 3, 2, 3, 4, 2])\n/// [1, 2, 3, 3, 3, 4, 4]\nfunc rolling_max(numbers:\
    \ [Int]) -> [Int] {\n    return sequence(first: 0, next: { $0 + 1 }).takeWhile\
    \ { $0 < numbers.count }.map { max(numbers[0...$0]) }\n}\n\n\nfunc ==(left: [(Int,\
    \ Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n\
    \        return false\n    }\n    for (l, r) in zip(left, right) {\n        if\
    \ l != r {\n            return false\n        }\n    }\n    return true\n}\n \
    \           \nassert(rolling_max(numbers: [] as [Int]) == [] as [Int])\nassert(rolling_max(numbers:\
    \ [1, 2, 3, 4]) == [1, 2, 3, 4])\nassert(rolling_max(numbers: [4, 3, 2, 1]) ==\
    \ [4, 4, 4, 4])\nassert(rolling_max(numbers: [3, 2, 3, 100, 3]) == [3, 3, 3, 100,\
    \ 100])"
  status: SyntaxError
  stderr: "/tmp/tmp1qxkw9lk.swift:7:49: error: value of type 'UnfoldSequence<Int,\
    \ (Int?, Bool)>' has no member 'takeWhile'\n    return sequence(first: 0, next:\
    \ { $0 + 1 }).takeWhile { $0 < numbers.count }.map { max(numbers[0...$0]) }\n\
    \           ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ ^~~~~~~~~\n/tmp/tmp1qxkw9lk.swift:7:107:\
    \ error: missing argument for parameter #2 in call\n    return sequence(first:\
    \ 0, next: { $0 + 1 }).takeWhile { $0 < numbers.count }.map { max(numbers[0...$0])\
    \ }\n                                                                        \
    \                                  ^\n                                       \
    \                                                                   , <#Int#>\n\
    Swift.max:1:24: note: 'max' declared here\n@inlinable public func max<T>(_ x:\
    \ T, _ y: T) -> T where T : Comparable\n                       ^\n/tmp/tmp1qxkw9lk.swift:7:101:\
    \ error: cannot convert value of type 'ClosedRange<Int>' to expected argument\
    \ type 'Int'\n    return sequence(first: 0, next: { $0 + 1 }).takeWhile { $0 <\
    \ numbers.count }.map { max(numbers[0...$0]) }\n                             \
    \                                                                       ^\n"
  stdout: ''
  timestamp: 1659979943
- exit_code: 0
  program: "\n/// From a given array of integers, generate an array of rolling maximum\
    \ element found until given moment\n/// in the sequence.\n/// >>> rolling_max(numbers:\
    \ [1, 2, 3, 2, 3, 4, 2])\n/// [1, 2, 3, 3, 3, 4, 4]\nfunc rolling_max(numbers:\
    \ [Int]) -> [Int] {\n    var maxValue = Int.min\n    var rollingMaximum = [Int]()\n\
    \    for number in numbers {\n        if number > maxValue {\n            maxValue\
    \ = number\n        }\n        rollingMaximum.append(maxValue)\n    }\n    return\
    \ rollingMaximum\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool\
    \ {\n    if left.count != right.count {\n        return false\n    }\n    for\
    \ (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(rolling_max(numbers:\
    \ [] as [Int]) == [] as [Int])\nassert(rolling_max(numbers: [1, 2, 3, 4]) == [1,\
    \ 2, 3, 4])\nassert(rolling_max(numbers: [4, 3, 2, 1]) == [4, 4, 4, 4])\nassert(rolling_max(numbers:\
    \ [3, 2, 3, 100, 3]) == [3, 3, 3, 100, 100])"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659979942
- exit_code: -4
  program: "\n/// From a given array of integers, generate an array of rolling maximum\
    \ element found until given moment\n/// in the sequence.\n/// >>> rolling_max(numbers:\
    \ [1, 2, 3, 2, 3, 4, 2])\n/// [1, 2, 3, 3, 3, 4, 4]\nfunc rolling_max(numbers:\
    \ [Int]) -> [Int] {\n  guard !numbers.isEmpty else { return [] }\n  var min_array\
    \ = (min: numbers[0], value: numbers[0])\n  return numbers.reduce([Int]()) {\n\
    \    let max = max(min_array.min, $1)\n    min_array = (min: min_array.value,\
    \ value: $1)\n    return $0 + [max]\n  }\n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(rolling_max(numbers: [] as [Int]) == [] as [Int])\nassert(rolling_max(numbers:\
    \ [1, 2, 3, 4]) == [1, 2, 3, 4])\nassert(rolling_max(numbers: [4, 3, 2, 1]) ==\
    \ [4, 4, 4, 4])\nassert(rolling_max(numbers: [3, 2, 3, 100, 3]) == [3, 3, 3, 100,\
    \ 100])"
  status: Exception
  stderr: 'tmpmfihd3z2/tmpmfihd3z2.swift:31: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b0931a8ac80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b0931781b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b0931781988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b09317807b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpmfihd3z2                        0x0000562d94a06896 <unavailable> + 6294

    5    libc.so.6                          0x00002b0931c76460 __libc_start_main +
    245

    6    tmpmfihd3z2                        0x0000562d94a06269 <unavailable> + 4713

    '
  stdout: ''
  timestamp: 1659979942
- exit_code: 0
  program: "\n/// From a given array of integers, generate an array of rolling maximum\
    \ element found until given moment\n/// in the sequence.\n/// >>> rolling_max(numbers:\
    \ [1, 2, 3, 2, 3, 4, 2])\n/// [1, 2, 3, 3, 3, 4, 4]\nfunc rolling_max(numbers:\
    \ [Int]) -> [Int] {\n    if numbers.count == 0 {\n        return []\n    }\n \
    \   var max_list = [Int]()\n    var max_until_now = numbers[0]\n    max_list.append(max_until_now)\n\
    \    for i in 1..<numbers.count {\n        max_until_now = max(max_until_now,\
    \ numbers[i])\n        max_list.append(max_until_now)\n    }\n    return max_list\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(rolling_max(numbers: [] as [Int]) == [] as [Int])\n\
    assert(rolling_max(numbers: [1, 2, 3, 4]) == [1, 2, 3, 4])\nassert(rolling_max(numbers:\
    \ [4, 3, 2, 1]) == [4, 4, 4, 4])\nassert(rolling_max(numbers: [3, 2, 3, 100, 3])\
    \ == [3, 3, 3, 100, 100])"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659979942
- exit_code: 0
  program: "\n/// From a given array of integers, generate an array of rolling maximum\
    \ element found until given moment\n/// in the sequence.\n/// >>> rolling_max(numbers:\
    \ [1, 2, 3, 2, 3, 4, 2])\n/// [1, 2, 3, 3, 3, 4, 4]\nfunc rolling_max(numbers:\
    \ [Int]) -> [Int] {\n    let length = numbers.count\n    guard length > 0 else\
    \ { return [] }\n    var result = [Int](repeating: 0, count: length)\n    var\
    \ currentMax = numbers[0]\n    result[0] = currentMax\n    for i in 1..<length\
    \ {\n        let number = numbers[i]\n        currentMax = max(currentMax, number)\n\
    \        result[i] = currentMax\n    }\n    return result\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(rolling_max(numbers: [] as [Int]) == [] as [Int])\nassert(rolling_max(numbers:\
    \ [1, 2, 3, 4]) == [1, 2, 3, 4])\nassert(rolling_max(numbers: [4, 3, 2, 1]) ==\
    \ [4, 4, 4, 4])\nassert(rolling_max(numbers: [3, 2, 3, 100, 3]) == [3, 3, 3, 100,\
    \ 100])"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659979943
- exit_code: -4
  program: "\n/// From a given array of integers, generate an array of rolling maximum\
    \ element found until given moment\n/// in the sequence.\n/// >>> rolling_max(numbers:\
    \ [1, 2, 3, 2, 3, 4, 2])\n/// [1, 2, 3, 3, 3, 4, 4]\nfunc rolling_max(numbers:\
    \ [Int]) -> [Int] {\n    var result = [Int]()\n    var maxSoFar = numbers[0]\n\
    \    for number in numbers {\n        if number > maxSoFar {\n            maxSoFar\
    \ = number\n        }\n        result.append(maxSoFar)\n    }\n    return result\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(rolling_max(numbers: [] as [Int]) == [] as [Int])\n\
    assert(rolling_max(numbers: [1, 2, 3, 4]) == [1, 2, 3, 4])\nassert(rolling_max(numbers:\
    \ [4, 3, 2, 1]) == [4, 4, 4, 4])\nassert(rolling_max(numbers: [3, 2, 3, 100, 3])\
    \ == [3, 3, 3, 100, 100])"
  status: Exception
  stderr: 'Swift/ContiguousArrayBuffer.swift:600: Fatal error: Index out of range

    Current stack trace:

    0    libswiftCore.so                    0x00002b8121fd4c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b8121ccb561 <unavailable> + 1434977

    2    libswiftCore.so                    0x00002b8121ccb286 <unavailable> + 1434246

    3    libswiftCore.so                    0x00002b8121ccb13c <unavailable> + 1433916

    4    libswiftCore.so                    0x00002b8121ccabb0 _assertionFailure(_:_:file:line:flags:)
    + 251

    5    libswiftSwiftOnoneSupport.so       0x00002b8121acae83 <unavailable> + 188035

    6    tmpk6yw3oca                        0x000055d088d5da5f <unavailable> + 6751

    7    tmpk6yw3oca                        0x000055d088d5d52d <unavailable> + 5421

    8    libc.so.6                          0x00002b81221c0460 __libc_start_main +
    245

    9    tmpk6yw3oca                        0x000055d088d5d239 <unavailable> + 4665

    '
  stdout: ''
  timestamp: 1659979941
- exit_code: 0
  program: "\n/// From a given array of integers, generate an array of rolling maximum\
    \ element found until given moment\n/// in the sequence.\n/// >>> rolling_max(numbers:\
    \ [1, 2, 3, 2, 3, 4, 2])\n/// [1, 2, 3, 3, 3, 4, 4]\nfunc rolling_max(numbers:\
    \ [Int]) -> [Int] {\n    var result = [Int]()\n    var maxElement = Int.min\n\
    \    for num in numbers {\n        maxElement = max(maxElement, num)\n       \
    \ result.append(maxElement)\n    }\n    return result\n}\n\n\nfunc ==(left: [(Int,\
    \ Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n\
    \        return false\n    }\n    for (l, r) in zip(left, right) {\n        if\
    \ l != r {\n            return false\n        }\n    }\n    return true\n}\n \
    \           \nassert(rolling_max(numbers: [] as [Int]) == [] as [Int])\nassert(rolling_max(numbers:\
    \ [1, 2, 3, 4]) == [1, 2, 3, 4])\nassert(rolling_max(numbers: [4, 3, 2, 1]) ==\
    \ [4, 4, 4, 4])\nassert(rolling_max(numbers: [3, 2, 3, 100, 3]) == [3, 3, 3, 100,\
    \ 100])"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659979943
- exit_code: 0
  program: "\n/// From a given array of integers, generate an array of rolling maximum\
    \ element found until given moment\n/// in the sequence.\n/// >>> rolling_max(numbers:\
    \ [1, 2, 3, 2, 3, 4, 2])\n/// [1, 2, 3, 3, 3, 4, 4]\nfunc rolling_max(numbers:\
    \ [Int]) -> [Int] {\n    var result = [Int]()\n    var max_val = Int.min\n   \
    \ for i in 0..<numbers.count {\n        if numbers[i] > max_val {\n          \
    \  max_val = numbers[i]\n        }\n        result.append(max_val)\n    }\n  \
    \  return result\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool\
    \ {\n    if left.count != right.count {\n        return false\n    }\n    for\
    \ (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(rolling_max(numbers:\
    \ [] as [Int]) == [] as [Int])\nassert(rolling_max(numbers: [1, 2, 3, 4]) == [1,\
    \ 2, 3, 4])\nassert(rolling_max(numbers: [4, 3, 2, 1]) == [4, 4, 4, 4])\nassert(rolling_max(numbers:\
    \ [3, 2, 3, 100, 3]) == [3, 3, 3, 100, 100])"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659979943
- exit_code: -4
  program: "\n/// From a given array of integers, generate an array of rolling maximum\
    \ element found until given moment\n/// in the sequence.\n/// >>> rolling_max(numbers:\
    \ [1, 2, 3, 2, 3, 4, 2])\n/// [1, 2, 3, 3, 3, 4, 4]\nfunc rolling_max(numbers:\
    \ [Int]) -> [Int] {\n    return numbers.reduce([Int](), { (result, number) in\n\
    \        return [max(number, result.last ?? number)] + result\n    }).reversed()\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(rolling_max(numbers: [] as [Int]) == [] as [Int])\n\
    assert(rolling_max(numbers: [1, 2, 3, 4]) == [1, 2, 3, 4])\nassert(rolling_max(numbers:\
    \ [4, 3, 2, 1]) == [4, 4, 4, 4])\nassert(rolling_max(numbers: [3, 2, 3, 100, 3])\
    \ == [3, 3, 3, 100, 100])"
  status: Exception
  stderr: 'tmpvtd8c2py/tmpvtd8c2py.swift:28: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002ad3ffbbdc80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002ad3ff8b4b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002ad3ff8b4988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002ad3ff8b37b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpvtd8c2py                        0x000055f76f83da2f <unavailable> + 6703

    5    libc.so.6                          0x00002ad3ffda9460 __libc_start_main +
    245

    6    tmpvtd8c2py                        0x000055f76f83d289 <unavailable> + 4745

    '
  stdout: ''
  timestamp: 1659979943
- exit_code: 0
  program: "\n/// From a given array of integers, generate an array of rolling maximum\
    \ element found until given moment\n/// in the sequence.\n/// >>> rolling_max(numbers:\
    \ [1, 2, 3, 2, 3, 4, 2])\n/// [1, 2, 3, 3, 3, 4, 4]\nfunc rolling_max(numbers:\
    \ [Int]) -> [Int] {\n    var maxNumbers = [Int]()\n    var maxValue = Int.min\n\
    \    for number in numbers {\n        maxValue = max(maxValue, number)\n     \
    \   maxNumbers.append(maxValue)\n    }\n    return maxNumbers\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(rolling_max(numbers: [] as [Int]) == [] as [Int])\nassert(rolling_max(numbers:\
    \ [1, 2, 3, 4]) == [1, 2, 3, 4])\nassert(rolling_max(numbers: [4, 3, 2, 1]) ==\
    \ [4, 4, 4, 4])\nassert(rolling_max(numbers: [3, 2, 3, 100, 3]) == [3, 3, 3, 100,\
    \ 100])"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659979943
- exit_code: 0
  program: "\n/// From a given array of integers, generate an array of rolling maximum\
    \ element found until given moment\n/// in the sequence.\n/// >>> rolling_max(numbers:\
    \ [1, 2, 3, 2, 3, 4, 2])\n/// [1, 2, 3, 3, 3, 4, 4]\nfunc rolling_max(numbers:\
    \ [Int]) -> [Int] {\n    \n    var ret: [Int] = []\n    for i in 0..<numbers.count\
    \ {\n        let n = numbers[i]\n        let maxN = max(ret.last ?? n, n)\n  \
    \      ret.append(maxN)\n    }\n    return ret\n}\n\n\nfunc ==(left: [(Int, Int)],\
    \ right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n       \
    \ return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r\
    \ {\n            return false\n        }\n    }\n    return true\n}\n        \
    \    \nassert(rolling_max(numbers: [] as [Int]) == [] as [Int])\nassert(rolling_max(numbers:\
    \ [1, 2, 3, 4]) == [1, 2, 3, 4])\nassert(rolling_max(numbers: [4, 3, 2, 1]) ==\
    \ [4, 4, 4, 4])\nassert(rolling_max(numbers: [3, 2, 3, 100, 3]) == [3, 3, 3, 100,\
    \ 100])"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659979943
- exit_code: 0
  program: "\n/// From a given array of integers, generate an array of rolling maximum\
    \ element found until given moment\n/// in the sequence.\n/// >>> rolling_max(numbers:\
    \ [1, 2, 3, 2, 3, 4, 2])\n/// [1, 2, 3, 3, 3, 4, 4]\nfunc rolling_max(numbers:\
    \ [Int]) -> [Int] {\n    var result = [Int]()\n    result.reserveCapacity(numbers.count)\n\
    \    var max = Int.min\n    for number in numbers {\n        if number > max {\n\
    \            max = number\n        }\n        result.append(max)\n    }\n    return\
    \ result\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n\
    \    if left.count != right.count {\n        return false\n    }\n    for (l,\
    \ r) in zip(left, right) {\n        if l != r {\n            return false\n  \
    \      }\n    }\n    return true\n}\n            \nassert(rolling_max(numbers:\
    \ [] as [Int]) == [] as [Int])\nassert(rolling_max(numbers: [1, 2, 3, 4]) == [1,\
    \ 2, 3, 4])\nassert(rolling_max(numbers: [4, 3, 2, 1]) == [4, 4, 4, 4])\nassert(rolling_max(numbers:\
    \ [3, 2, 3, 100, 3]) == [3, 3, 3, 100, 100])"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659979943
- exit_code: 0
  program: "\n/// From a given array of integers, generate an array of rolling maximum\
    \ element found until given moment\n/// in the sequence.\n/// >>> rolling_max(numbers:\
    \ [1, 2, 3, 2, 3, 4, 2])\n/// [1, 2, 3, 3, 3, 4, 4]\nfunc rolling_max(numbers:\
    \ [Int]) -> [Int] {\n    var res = [Int]()\n    for i in 0..<numbers.count {\n\
    \        var max = 0\n        for j in 0...i {\n            if numbers[j] > max\
    \ {\n                max = numbers[j]\n            }\n        }\n        res.append(max)\n\
    \    }\n    return res\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(rolling_max(numbers:\
    \ [] as [Int]) == [] as [Int])\nassert(rolling_max(numbers: [1, 2, 3, 4]) == [1,\
    \ 2, 3, 4])\nassert(rolling_max(numbers: [4, 3, 2, 1]) == [4, 4, 4, 4])\nassert(rolling_max(numbers:\
    \ [3, 2, 3, 100, 3]) == [3, 3, 3, 100, 100])"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659979943
- exit_code: 0
  program: "\n/// From a given array of integers, generate an array of rolling maximum\
    \ element found until given moment\n/// in the sequence.\n/// >>> rolling_max(numbers:\
    \ [1, 2, 3, 2, 3, 4, 2])\n/// [1, 2, 3, 3, 3, 4, 4]\nfunc rolling_max(numbers:\
    \ [Int]) -> [Int] {\n  var m = numbers.map { _ in -1 }\n  var max = -1\n  for\
    \ i in 0..<numbers.count {\n    max = max > numbers[i] ? max : numbers[i]\n  \
    \  m[i] = max\n  }\n  return m\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int,\
    \ Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n\
    \    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n          \
    \  return false\n        }\n    }\n    return true\n}\n            \nassert(rolling_max(numbers:\
    \ [] as [Int]) == [] as [Int])\nassert(rolling_max(numbers: [1, 2, 3, 4]) == [1,\
    \ 2, 3, 4])\nassert(rolling_max(numbers: [4, 3, 2, 1]) == [4, 4, 4, 4])\nassert(rolling_max(numbers:\
    \ [3, 2, 3, 100, 3]) == [3, 3, 3, 100, 100])"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659979943
- exit_code: 0
  program: "\n/// From a given array of integers, generate an array of rolling maximum\
    \ element found until given moment\n/// in the sequence.\n/// >>> rolling_max(numbers:\
    \ [1, 2, 3, 2, 3, 4, 2])\n/// [1, 2, 3, 3, 3, 4, 4]\nfunc rolling_max(numbers:\
    \ [Int]) -> [Int] {\n    let count = numbers.count\n    guard count > 0 else {\
    \ return [] }\n    var result = [Int](repeating: 0, count: count)\n    var maximum\
    \ = 0\n    for (index, element) in numbers.enumerated() {\n        maximum = max(maximum,\
    \ element)\n        result[index] = maximum\n    }\n    return result\n}\n\n\n\
    func ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(rolling_max(numbers: [] as [Int]) == [] as [Int])\n\
    assert(rolling_max(numbers: [1, 2, 3, 4]) == [1, 2, 3, 4])\nassert(rolling_max(numbers:\
    \ [4, 3, 2, 1]) == [4, 4, 4, 4])\nassert(rolling_max(numbers: [3, 2, 3, 100, 3])\
    \ == [3, 3, 3, 100, 100])"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659979943
- exit_code: -4
  program: "\n/// From a given array of integers, generate an array of rolling maximum\
    \ element found until given moment\n/// in the sequence.\n/// >>> rolling_max(numbers:\
    \ [1, 2, 3, 2, 3, 4, 2])\n/// [1, 2, 3, 3, 3, 4, 4]\nfunc rolling_max(numbers:\
    \ [Int]) -> [Int] {\n    var maxValue: Int = numbers[0]\n    var rollingMax =\
    \ [Int]()\n    for index in 0..<numbers.count {\n        maxValue = max(maxValue,\
    \ numbers[index])\n        rollingMax.append(maxValue)\n    }\n    return rollingMax\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(rolling_max(numbers: [] as [Int]) == [] as [Int])\n\
    assert(rolling_max(numbers: [1, 2, 3, 4]) == [1, 2, 3, 4])\nassert(rolling_max(numbers:\
    \ [4, 3, 2, 1]) == [4, 4, 4, 4])\nassert(rolling_max(numbers: [3, 2, 3, 100, 3])\
    \ == [3, 3, 3, 100, 100])"
  status: Exception
  stderr: 'Swift/ContiguousArrayBuffer.swift:600: Fatal error: Index out of range

    Current stack trace:

    0    libswiftCore.so                    0x00002ad414e4fc80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002ad414b46561 <unavailable> + 1434977

    2    libswiftCore.so                    0x00002ad414b46286 <unavailable> + 1434246

    3    libswiftCore.so                    0x00002ad414b4613c <unavailable> + 1433916

    4    libswiftCore.so                    0x00002ad414b45bb0 _assertionFailure(_:_:file:line:flags:)
    + 251

    5    libswiftSwiftOnoneSupport.so       0x00002ad414945e83 <unavailable> + 188035

    6    tmpfg3ryvq_                        0x000055cca3b81b58 <unavailable> + 7000

    7    tmpfg3ryvq_                        0x000055cca3b8162d <unavailable> + 5677

    8    libc.so.6                          0x00002ad41503b460 __libc_start_main +
    245

    9    tmpfg3ryvq_                        0x000055cca3b81339 <unavailable> + 4921

    '
  stdout: ''
  timestamp: 1659979943
- exit_code: -4
  program: "\n/// From a given array of integers, generate an array of rolling maximum\
    \ element found until given moment\n/// in the sequence.\n/// >>> rolling_max(numbers:\
    \ [1, 2, 3, 2, 3, 4, 2])\n/// [1, 2, 3, 3, 3, 4, 4]\nfunc rolling_max(numbers:\
    \ [Int]) -> [Int] {\n    var result = [Int]()\n    var max = numbers[0]\n    result.append(max)\n\
    \    for i in 1..<numbers.count {\n        if numbers[i] > max {\n           \
    \ max = numbers[i]\n        }\n        result.append(max)\n    }\n    return result\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(rolling_max(numbers: [] as [Int]) == [] as [Int])\n\
    assert(rolling_max(numbers: [1, 2, 3, 4]) == [1, 2, 3, 4])\nassert(rolling_max(numbers:\
    \ [4, 3, 2, 1]) == [4, 4, 4, 4])\nassert(rolling_max(numbers: [3, 2, 3, 100, 3])\
    \ == [3, 3, 3, 100, 100])"
  status: Exception
  stderr: 'Swift/ContiguousArrayBuffer.swift:600: Fatal error: Index out of range

    Current stack trace:

    0    libswiftCore.so                    0x00002ba2c634dc80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002ba2c6044561 <unavailable> + 1434977

    2    libswiftCore.so                    0x00002ba2c6044286 <unavailable> + 1434246

    3    libswiftCore.so                    0x00002ba2c604413c <unavailable> + 1433916

    4    libswiftCore.so                    0x00002ba2c6043bb0 _assertionFailure(_:_:file:line:flags:)
    + 251

    5    libswiftSwiftOnoneSupport.so       0x00002ba2c5e43e83 <unavailable> + 188035

    6    tmpdio67vjk                        0x0000560ee0476ae8 <unavailable> + 6888

    7    tmpdio67vjk                        0x0000560ee04765ad <unavailable> + 5549

    8    libc.so.6                          0x00002ba2c6539460 __libc_start_main +
    245

    9    tmpdio67vjk                        0x0000560ee04762b9 <unavailable> + 4793

    '
  stdout: ''
  timestamp: 1659979942
- exit_code: -4
  program: "\n/// From a given array of integers, generate an array of rolling maximum\
    \ element found until given moment\n/// in the sequence.\n/// >>> rolling_max(numbers:\
    \ [1, 2, 3, 2, 3, 4, 2])\n/// [1, 2, 3, 3, 3, 4, 4]\nfunc rolling_max(numbers:\
    \ [Int]) -> [Int] {\n    var max = numbers[0]\n    var max_numbers = [Int]()\n\
    \    max_numbers.append(max)\n    for i in 1..<numbers.count {\n        if max\
    \ > numbers[i] {\n            max_numbers.append(max)\n        } else {\n    \
    \        max = numbers[i]\n            max_numbers.append(max)\n        }\n  \
    \  }\n    return max_numbers\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int,\
    \ Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n\
    \    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n          \
    \  return false\n        }\n    }\n    return true\n}\n            \nassert(rolling_max(numbers:\
    \ [] as [Int]) == [] as [Int])\nassert(rolling_max(numbers: [1, 2, 3, 4]) == [1,\
    \ 2, 3, 4])\nassert(rolling_max(numbers: [4, 3, 2, 1]) == [4, 4, 4, 4])\nassert(rolling_max(numbers:\
    \ [3, 2, 3, 100, 3]) == [3, 3, 3, 100, 100])"
  status: Exception
  stderr: 'Swift/ContiguousArrayBuffer.swift:600: Fatal error: Index out of range

    Current stack trace:

    0    libswiftCore.so                    0x00002accf77dfc80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002accf74d6561 <unavailable> + 1434977

    2    libswiftCore.so                    0x00002accf74d6286 <unavailable> + 1434246

    3    libswiftCore.so                    0x00002accf74d613c <unavailable> + 1433916

    4    libswiftCore.so                    0x00002accf74d5bb0 _assertionFailure(_:_:file:line:flags:)
    + 251

    5    libswiftSwiftOnoneSupport.so       0x00002accf72d5e83 <unavailable> + 188035

    6    tmp7ouskmah                        0x000055a21dc5dad8 <unavailable> + 6872

    7    tmp7ouskmah                        0x000055a21dc5d5ad <unavailable> + 5549

    8    libc.so.6                          0x00002accf79cb460 __libc_start_main +
    245

    9    tmp7ouskmah                        0x000055a21dc5d2b9 <unavailable> + 4793

    '
  stdout: ''
  timestamp: 1659979943
- exit_code: -4
  program: "\n/// From a given array of integers, generate an array of rolling maximum\
    \ element found until given moment\n/// in the sequence.\n/// >>> rolling_max(numbers:\
    \ [1, 2, 3, 2, 3, 4, 2])\n/// [1, 2, 3, 3, 3, 4, 4]\nfunc rolling_max(numbers:\
    \ [Int]) -> [Int] {\n    var result = [Int]()\n    var current_max = numbers[0]\n\
    \    result.append(current_max)\n    for i in 1..<numbers.count {\n        if\
    \ current_max < numbers[i] {\n            current_max = numbers[i]\n        }\n\
    \        result.append(current_max)\n    }\n    return result\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(rolling_max(numbers: [] as [Int]) == [] as [Int])\nassert(rolling_max(numbers:\
    \ [1, 2, 3, 4]) == [1, 2, 3, 4])\nassert(rolling_max(numbers: [4, 3, 2, 1]) ==\
    \ [4, 4, 4, 4])\nassert(rolling_max(numbers: [3, 2, 3, 100, 3]) == [3, 3, 3, 100,\
    \ 100])"
  status: Exception
  stderr: 'Swift/ContiguousArrayBuffer.swift:600: Fatal error: Index out of range

    Current stack trace:

    0    libswiftCore.so                    0x00002b335e6ddc80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b335e3d4561 <unavailable> + 1434977

    2    libswiftCore.so                    0x00002b335e3d4286 <unavailable> + 1434246

    3    libswiftCore.so                    0x00002b335e3d413c <unavailable> + 1433916

    4    libswiftCore.so                    0x00002b335e3d3bb0 _assertionFailure(_:_:file:line:flags:)
    + 251

    5    libswiftSwiftOnoneSupport.so       0x00002b335e1d3e83 <unavailable> + 188035

    6    tmpm3ieet1s                        0x0000557d4b04dae8 <unavailable> + 6888

    7    tmpm3ieet1s                        0x0000557d4b04d5ad <unavailable> + 5549

    8    libc.so.6                          0x00002b335e8c9460 __libc_start_main +
    245

    9    tmpm3ieet1s                        0x0000557d4b04d2b9 <unavailable> + 4793

    '
  stdout: ''
  timestamp: 1659979943
- exit_code: 0
  program: "\n/// From a given array of integers, generate an array of rolling maximum\
    \ element found until given moment\n/// in the sequence.\n/// >>> rolling_max(numbers:\
    \ [1, 2, 3, 2, 3, 4, 2])\n/// [1, 2, 3, 3, 3, 4, 4]\nfunc rolling_max(numbers:\
    \ [Int]) -> [Int] {\n    guard numbers.count > 0 else { return numbers }\n   \
    \ var result = [Int]()\n    result.append(numbers[0])\n    var current_max = numbers[0]\n\
    \    for i in 1..<numbers.count {\n        if numbers[i] > current_max {\n   \
    \         current_max = numbers[i]\n        }\n        result.append(current_max)\n\
    \    }\n    return result\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(rolling_max(numbers:\
    \ [] as [Int]) == [] as [Int])\nassert(rolling_max(numbers: [1, 2, 3, 4]) == [1,\
    \ 2, 3, 4])\nassert(rolling_max(numbers: [4, 3, 2, 1]) == [4, 4, 4, 4])\nassert(rolling_max(numbers:\
    \ [3, 2, 3, 100, 3]) == [3, 3, 3, 100, 100])"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659979943
- exit_code: 0
  program: "\n/// From a given array of integers, generate an array of rolling maximum\
    \ element found until given moment\n/// in the sequence.\n/// >>> rolling_max(numbers:\
    \ [1, 2, 3, 2, 3, 4, 2])\n/// [1, 2, 3, 3, 3, 4, 4]\nfunc rolling_max(numbers:\
    \ [Int]) -> [Int] {\n    var max_so_far = 0\n    var rolling_max_elements = [Int]()\n\
    \    for num in numbers {\n        if num > max_so_far {\n            max_so_far\
    \ = num\n        }\n        rolling_max_elements.append(max_so_far)\n    }\n \
    \   return rolling_max_elements\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int,\
    \ Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n\
    \    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n          \
    \  return false\n        }\n    }\n    return true\n}\n            \nassert(rolling_max(numbers:\
    \ [] as [Int]) == [] as [Int])\nassert(rolling_max(numbers: [1, 2, 3, 4]) == [1,\
    \ 2, 3, 4])\nassert(rolling_max(numbers: [4, 3, 2, 1]) == [4, 4, 4, 4])\nassert(rolling_max(numbers:\
    \ [3, 2, 3, 100, 3]) == [3, 3, 3, 100, 100])"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659979943
- exit_code: -4
  program: "\n/// From a given array of integers, generate an array of rolling maximum\
    \ element found until given moment\n/// in the sequence.\n/// >>> rolling_max(numbers:\
    \ [1, 2, 3, 2, 3, 4, 2])\n/// [1, 2, 3, 3, 3, 4, 4]\nfunc rolling_max(numbers:\
    \ [Int]) -> [Int] {\n    //TODO: Your code goes here\n    return []\n}\n\n\nfunc\
    \ ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count !=\
    \ right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(rolling_max(numbers: [] as [Int]) == [] as [Int])\n\
    assert(rolling_max(numbers: [1, 2, 3, 4]) == [1, 2, 3, 4])\nassert(rolling_max(numbers:\
    \ [4, 3, 2, 1]) == [4, 4, 4, 4])\nassert(rolling_max(numbers: [3, 2, 3, 100, 3])\
    \ == [3, 3, 3, 100, 100])"
  status: Exception
  stderr: 'tmp074_qppf/tmp074_qppf.swift:25: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002aabc85c7c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002aabc82beb6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002aabc82be988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002aabc82bd7b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmp074_qppf                        0x00005563561364ad <unavailable> + 5293

    5    libc.so.6                          0x00002aabc87b3460 __libc_start_main +
    245

    6    tmp074_qppf                        0x0000556356135fc9 <unavailable> + 4041

    '
  stdout: ''
  timestamp: 1659979943
- exit_code: -4
  program: "\n/// From a given array of integers, generate an array of rolling maximum\
    \ element found until given moment\n/// in the sequence.\n/// >>> rolling_max(numbers:\
    \ [1, 2, 3, 2, 3, 4, 2])\n/// [1, 2, 3, 3, 3, 4, 4]\nfunc rolling_max(numbers:\
    \ [Int]) -> [Int] {\n    var result = [Int]()\n    var max = numbers[0]\n    result.append(max)\n\
    \    for i in 1..<numbers.count {\n        if numbers[i] > max {\n           \
    \ max = numbers[i]\n        }\n        result.append(max)\n    }\n    return result\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(rolling_max(numbers: [] as [Int]) == [] as [Int])\n\
    assert(rolling_max(numbers: [1, 2, 3, 4]) == [1, 2, 3, 4])\nassert(rolling_max(numbers:\
    \ [4, 3, 2, 1]) == [4, 4, 4, 4])\nassert(rolling_max(numbers: [3, 2, 3, 100, 3])\
    \ == [3, 3, 3, 100, 100])"
  status: Exception
  stderr: 'Swift/ContiguousArrayBuffer.swift:600: Fatal error: Index out of range

    Current stack trace:

    0    libswiftCore.so                    0x00002ba2c634dc80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002ba2c6044561 <unavailable> + 1434977

    2    libswiftCore.so                    0x00002ba2c6044286 <unavailable> + 1434246

    3    libswiftCore.so                    0x00002ba2c604413c <unavailable> + 1433916

    4    libswiftCore.so                    0x00002ba2c6043bb0 _assertionFailure(_:_:file:line:flags:)
    + 251

    5    libswiftSwiftOnoneSupport.so       0x00002ba2c5e43e83 <unavailable> + 188035

    6    tmpdio67vjk                        0x0000560ee0476ae8 <unavailable> + 6888

    7    tmpdio67vjk                        0x0000560ee04765ad <unavailable> + 5549

    8    libc.so.6                          0x00002ba2c6539460 __libc_start_main +
    245

    9    tmpdio67vjk                        0x0000560ee04762b9 <unavailable> + 4793

    '
  stdout: ''
  timestamp: 1659979942
- exit_code: 0
  program: "\n/// From a given array of integers, generate an array of rolling maximum\
    \ element found until given moment\n/// in the sequence.\n/// >>> rolling_max(numbers:\
    \ [1, 2, 3, 2, 3, 4, 2])\n/// [1, 2, 3, 3, 3, 4, 4]\nfunc rolling_max(numbers:\
    \ [Int]) -> [Int] {\n    var array = [Int]()\n    var max = Int.min\n    for element\
    \ in numbers {\n        if element > max {\n            max = element\n      \
    \  }\n        array.append(max)\n    }\n    return array\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(rolling_max(numbers: [] as [Int]) == [] as [Int])\nassert(rolling_max(numbers:\
    \ [1, 2, 3, 4]) == [1, 2, 3, 4])\nassert(rolling_max(numbers: [4, 3, 2, 1]) ==\
    \ [4, 4, 4, 4])\nassert(rolling_max(numbers: [3, 2, 3, 100, 3]) == [3, 3, 3, 100,\
    \ 100])"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659979943
- exit_code: 0
  program: "\n/// From a given array of integers, generate an array of rolling maximum\
    \ element found until given moment\n/// in the sequence.\n/// >>> rolling_max(numbers:\
    \ [1, 2, 3, 2, 3, 4, 2])\n/// [1, 2, 3, 3, 3, 4, 4]\nfunc rolling_max(numbers:\
    \ [Int]) -> [Int] {\n    var _numbers = numbers\n    var _max = 0\n    for i in\
    \ 0..<_numbers.count {\n        _max = max(_max, _numbers[i])\n        _numbers[i]\
    \ = _max\n    }\n    return _numbers\n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(rolling_max(numbers: [] as [Int]) == [] as [Int])\nassert(rolling_max(numbers:\
    \ [1, 2, 3, 4]) == [1, 2, 3, 4])\nassert(rolling_max(numbers: [4, 3, 2, 1]) ==\
    \ [4, 4, 4, 4])\nassert(rolling_max(numbers: [3, 2, 3, 100, 3]) == [3, 3, 3, 100,\
    \ 100])"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659979943
- exit_code: -4
  program: "\n/// From a given array of integers, generate an array of rolling maximum\
    \ element found until given moment\n/// in the sequence.\n/// >>> rolling_max(numbers:\
    \ [1, 2, 3, 2, 3, 4, 2])\n/// [1, 2, 3, 3, 3, 4, 4]\nfunc rolling_max(numbers:\
    \ [Int]) -> [Int] {\n    var running_max: Int = numbers[0]\n    var rolling_max\
    \ = [Int]()\n    for number in numbers {\n        running_max = max(running_max,\
    \ number)\n        rolling_max.append(running_max)\n    }\n    return rolling_max\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(rolling_max(numbers: [] as [Int]) == [] as [Int])\n\
    assert(rolling_max(numbers: [1, 2, 3, 4]) == [1, 2, 3, 4])\nassert(rolling_max(numbers:\
    \ [4, 3, 2, 1]) == [4, 4, 4, 4])\nassert(rolling_max(numbers: [3, 2, 3, 100, 3])\
    \ == [3, 3, 3, 100, 100])"
  status: Exception
  stderr: 'Swift/ContiguousArrayBuffer.swift:600: Fatal error: Index out of range

    Current stack trace:

    0    libswiftCore.so                    0x00002b10a30f6c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b10a2ded561 <unavailable> + 1434977

    2    libswiftCore.so                    0x00002b10a2ded286 <unavailable> + 1434246

    3    libswiftCore.so                    0x00002b10a2ded13c <unavailable> + 1433916

    4    libswiftCore.so                    0x00002b10a2decbb0 _assertionFailure(_:_:file:line:flags:)
    + 251

    5    libswiftSwiftOnoneSupport.so       0x00002b10a2bece83 <unavailable> + 188035

    6    tmphchwg90c                        0x0000561cbcd6cae8 <unavailable> + 6888

    7    tmphchwg90c                        0x0000561cbcd6c5bd <unavailable> + 5565

    8    libc.so.6                          0x00002b10a32e2460 __libc_start_main +
    245

    9    tmphchwg90c                        0x0000561cbcd6c2c9 <unavailable> + 4809

    '
  stdout: ''
  timestamp: 1659979943
- exit_code: -4
  program: "\n/// From a given array of integers, generate an array of rolling maximum\
    \ element found until given moment\n/// in the sequence.\n/// >>> rolling_max(numbers:\
    \ [1, 2, 3, 2, 3, 4, 2])\n/// [1, 2, 3, 3, 3, 4, 4]\nfunc rolling_max(numbers:\
    \ [Int]) -> [Int] {\n    var current_max = numbers[0]\n    var rolling_max = [current_max]\n\
    \    for i in 1..<numbers.count {\n        if current_max < numbers[i] {\n   \
    \         current_max = numbers[i]\n        }\n        rolling_max.append(current_max)\n\
    \    }\n    return rolling_max\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int,\
    \ Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n\
    \    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n          \
    \  return false\n        }\n    }\n    return true\n}\n            \nassert(rolling_max(numbers:\
    \ [] as [Int]) == [] as [Int])\nassert(rolling_max(numbers: [1, 2, 3, 4]) == [1,\
    \ 2, 3, 4])\nassert(rolling_max(numbers: [4, 3, 2, 1]) == [4, 4, 4, 4])\nassert(rolling_max(numbers:\
    \ [3, 2, 3, 100, 3]) == [3, 3, 3, 100, 100])"
  status: Exception
  stderr: 'Swift/ContiguousArrayBuffer.swift:600: Fatal error: Index out of range

    Current stack trace:

    0    libswiftCore.so                    0x00002b24e6163c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b24e5e5a561 <unavailable> + 1434977

    2    libswiftCore.so                    0x00002b24e5e5a286 <unavailable> + 1434246

    3    libswiftCore.so                    0x00002b24e5e5a13c <unavailable> + 1433916

    4    libswiftCore.so                    0x00002b24e5e59bb0 _assertionFailure(_:_:file:line:flags:)
    + 251

    5    libswiftSwiftOnoneSupport.so       0x00002b24e5c59e83 <unavailable> + 188035

    6    tmprh4ays51                        0x0000557d27e07a78 <unavailable> + 6776

    7    tmprh4ays51                        0x0000557d27e0754d <unavailable> + 5453

    8    libc.so.6                          0x00002b24e634f460 __libc_start_main +
    245

    9    tmprh4ays51                        0x0000557d27e07259 <unavailable> + 4697

    '
  stdout: ''
  timestamp: 1659979943
- exit_code: 0
  program: "\n/// From a given array of integers, generate an array of rolling maximum\
    \ element found until given moment\n/// in the sequence.\n/// >>> rolling_max(numbers:\
    \ [1, 2, 3, 2, 3, 4, 2])\n/// [1, 2, 3, 3, 3, 4, 4]\nfunc rolling_max(numbers:\
    \ [Int]) -> [Int] {\n    var result = [Int]()\n    var max_num = 0\n    for i\
    \ in 0..<numbers.count {\n        max_num = max(max_num, numbers[i])\n       \
    \ result.append(max_num)\n    }\n    return result\n}\n\n\nfunc ==(left: [(Int,\
    \ Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n\
    \        return false\n    }\n    for (l, r) in zip(left, right) {\n        if\
    \ l != r {\n            return false\n        }\n    }\n    return true\n}\n \
    \           \nassert(rolling_max(numbers: [] as [Int]) == [] as [Int])\nassert(rolling_max(numbers:\
    \ [1, 2, 3, 4]) == [1, 2, 3, 4])\nassert(rolling_max(numbers: [4, 3, 2, 1]) ==\
    \ [4, 4, 4, 4])\nassert(rolling_max(numbers: [3, 2, 3, 100, 3]) == [3, 3, 3, 100,\
    \ 100])"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659979943
- exit_code: 1
  program: "\n/// From a given array of integers, generate an array of rolling maximum\
    \ element found until given moment\n/// in the sequence.\n/// >>> rolling_max(numbers:\
    \ [1, 2, 3, 2, 3, 4, 2])\n/// [1, 2, 3, 3, 3, 4, 4]\nfunc rolling_max(numbers:\
    \ [Int]) -> [Int] {\n    return rolling_max(numbers: numbers, start: 0, end: numbers.count)\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(rolling_max(numbers: [] as [Int]) == [] as [Int])\n\
    assert(rolling_max(numbers: [1, 2, 3, 4]) == [1, 2, 3, 4])\nassert(rolling_max(numbers:\
    \ [4, 3, 2, 1]) == [4, 4, 4, 4])\nassert(rolling_max(numbers: [3, 2, 3, 100, 3])\
    \ == [3, 3, 3, 100, 100])"
  status: SyntaxError
  stderr: "/tmp/tmp226pq67h.swift:7:23: error: extra arguments at positions #2, #3\
    \ in call\n    return rolling_max(numbers: numbers, start: 0, end: numbers.count)\n\
    \                      ^\n/tmp/tmp226pq67h.swift:6:6: note: 'rolling_max(numbers:)'\
    \ declared here\nfunc rolling_max(numbers: [Int]) -> [Int] {\n     ^\n"
  stdout: ''
  timestamp: 1659979943
