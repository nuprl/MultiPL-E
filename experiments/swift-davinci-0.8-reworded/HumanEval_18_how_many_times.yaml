name: HumanEval_18_how_many_times
language: swift
prompt: "\n/// Find how many times a given substring can be found in the original\
  \ string. Count overlaping cases.\n/// >>> how_many_times(string: \"\", substring:\
  \ \"a\")\n/// 0\n/// >>> how_many_times(string: \"aaa\", substring: \"a\")\n///\
  \ 3\n/// >>> how_many_times(string: \"aaaa\", substring: \"aa\")\n/// 3\nfunc how_many_times(string:\
  \ String, substring: String) -> Int {\n"
tests: "}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if\
  \ left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left,\
  \ right) {\n        if l != r {\n            return false\n        }\n    }\n  \
  \  return true\n}\n            \nassert(how_many_times(string: \"\", substring:\
  \ \"x\") == 0)\nassert(how_many_times(string: \"xyxyxyx\", substring: \"x\") ==\
  \ 4)\nassert(how_many_times(string: \"cacacacac\", substring: \"cac\") == 4)\nassert(how_many_times(string:\
  \ \"john doe\", substring: \"john\") == 1)"
completions: ["    let s = string.characters\n    let p = substring.characters\n \
    \   guard !p.isEmpty && s.count >= p.count else { return 0 }\n    let count =\
    \ s.count\n    let subCount = p.count\n    var skip = [Character: Int]()\n   \
    \ for (i, c) in p.enumerated() {\n        skip[c] = subCount - i - 1\n    }\n\
    \    var i = 0\n    while i <= count - subCount {\n        var j = subCount -\
    \ 1\n        while j >= 0 && s[s.index(s.startIndex, offsetBy: i + j)] == p[p.index(p.startIndex,\
    \ offsetBy: j)] {\n            j -= 1\n        }\n        if j < 0 {\n       \
    \     i += subCount\n        } else {\n            i += max(1, skip[s[s.index(s.startIndex,\
    \ offsetBy: i + subCount - 1)]] ?? subCount)\n        }\n    }\n    return i /\
    \ subCount", "    var count = 0\n    var range = string.startIndex..<string.endIndex\n\
    \    while let r = string.range(of: substring, options: [], range: range) {\n\
    \        count += 1\n        range = r.upperBound..<string.endIndex\n    }\n \
    \   return count", "    let nsString = string as NSString\n    let nsSubstring\
    \ = substring as NSString\n    let range = nsString.range(of: nsSubstring as String)\n\
    \    let result = nsString.range(of: nsSubstring as String, options: NSString.CompareOptions.caseInsensitive,\
    \ range: range, locale: nil)\n    return result.location != NSNotFound ? 1 + how_many_times(string:\
    \ nsString.substring(from: result.location + result.length), substring: substring)\
    \ : 0", "    var i = 0\n    var substringCount = 0\n    let searchRange = NSRange(location:\
    \ 0, length: string.characters.count)\n    while let range = string.range(of:\
    \ substring, options: [], range: searchRange, locale: nil) {\n        i = string.characters.distance(from:\
    \ string.startIndex, to: range.lowerBound)\n        substringCount += 1\n    \
    \    string.removeSubrange(string.startIndex..<string.index(string.startIndex,\
    \ offsetBy: i + 1))\n    }\n    return substringCount", "    var count = 0\n \
    \   var idx = string.startIndex\n    while let range = string.range(of: substring,\
    \ range: idx..<string.endIndex) {\n        count += 1\n        if range.upperBound\
    \ == string.endIndex {\n            break\n        }\n        idx = string.index(after:\
    \ range.upperBound)\n    }\n    return count", "    var result = 0\n    for i\
    \ in 0 ..< string.count - substring.count + 1 {\n        if String(string[i ..<\
    \ i + substring.count]) == substring {\n            result += 1\n        }\n \
    \   }\n    return result", "    if string.count == 0 || substring.count == 0 {\n\
    \        return 0\n    }\n    if substring.count > string.count {\n        return\
    \ 0\n    }\n    let start_index = string.startIndex\n    let substring_start_index\
    \ = substring.startIndex\n    var counter = 0\n    var index = start_index\n \
    \   while index < string.endIndex {\n        if string[index] == substring[substring_start_index]\
    \ {\n            let string_slice = string[index..<string.endIndex]\n        \
    \    if string_slice.hasPrefix(substring) {\n                counter += 1\n  \
    \              index = string.index(index, offsetBy: substring.count - 1)\n  \
    \          }\n        }\n        index = string.index(after: index)\n    }\n \
    \   return counter", "    let nsstring = string as NSString\n    let substring\
    \ = substring as NSString\n    var result = 0\n    var range = NSRange(location:\
    \ 0, length: nsstring.length)\n    while true {\n        range = nsstring.range(of:\
    \ substring as String, options: [], range: range)\n        if range.location ==\
    \ NSNotFound {\n            break\n        }\n        range.location += 1\n  \
    \      range.length = nsstring.length - range.location\n        result += 1\n\
    \    }\n    return result", "    let length = string.lengthOfBytes(using: .utf8)\n\
    \    let sublength = substring.lengthOfBytes(using: .utf8)\n    guard length >=\
    \ sublength else { return 0 }\n    var result = 0\n    for i in 0...(length -\
    \ sublength) {\n        if string[i...(i + sublength - 1)] == substring {\n  \
    \          result += 1\n        }\n    }\n    return result", "    let length\
    \ = string.count - substring.count + 1\n    var count = 0\n    for i in 0..<length\
    \ {\n        let start = string.index(string.startIndex, offsetBy: i)\n      \
    \  let end = string.index(start, offsetBy: substring.count)\n        if string[start..<end]\
    \ == substring {\n            count += 1\n        }\n    }\n    return count",
  "  var count = 0\n  for index in string.indices {\n    let start = string.index(index,\
    \ offsetBy: 0)\n    let end = string.index(index, offsetBy: substring.count)\n\
    \    if string[start..<end] == substring {\n      count += 1\n    }\n  }\n  return\
    \ count", "    let length = string.count - substring.count + 1\n    guard length\
    \ > 0 else { return 0 }\n    return length", "    var count = 0\n    var copied_string\
    \ = string\n    while true {\n        if let range = copied_string.range(of: substring)\
    \ {\n            count += 1\n            copied_string = copied_string.replacingCharacters(in:\
    \ range, with: \"\")\n        } else {\n            break\n        }\n    }\n\
    \    return count", '    return string.components(separatedBy: substring).count
    - 1', "    // Write your solution here\n    let index_string = string.startIndex\n\
    \    let index_substring = substring.startIndex\n    var count = 0\n    if string.count\
    \ < substring.count {\n        return 0\n    }\n    for var index in index_string..<string.endIndex\
    \ {\n        let sub = string[index...index]\n        if String(sub) == String(substring[index_substring])\
    \ {\n            count += 1\n            index = string.index(index, offsetBy:\
    \ substring.count - 1)\n        }\n    }\n    return count", "    var start =\
    \ string.startIndex\n    var num_times = 0\n    while start < string.endIndex,\
    \ let range = string.range(of: substring, range: start..<string.endIndex) {\n\
    \        num_times += 1\n        start = range.upperBound\n    }\n    return num_times",
  "    let nsString = string as NSString\n    let substringRange = nsString.range(of:\
    \ substring)\n    if substringRange.location == NSNotFound {\n        return 0\n\
    \    }\n    let otherRange = NSRange(location: substringRange.location + substringRange.length,\
    \ length: nsString.length - substringRange.location - substringRange.length)\n\
    \    return 1 + how_many_times(string: nsString.substring(with: otherRange), substring:\
    \ substring)", "    let arr = Array(string)\n    var count = 0\n    for i in 0..<arr.count\
    \ {\n        let subArr = Array(arr[i..<arr.count])\n        if String(subArr).contains(substring)\
    \ {\n            count += 1\n        }\n    }\n    return count", "    let input\
    \ = string.utf8\n    let substring = substring.utf8\n    var out: Int = 0\n  \
    \  var index = input.startIndex\n    let endIndex = input.endIndex\n    while\
    \ index < endIndex {\n        if input[index] == substring[substring.startIndex]\
    \ {\n            let result = compare_substring(input: input, substring: substring,\
    \ start: index)\n            if result {\n                out += 1\n         \
    \       index = input.index(index, offsetBy: substring.count)\n            } else\
    \ {\n                index = input.index(after: index)\n            }\n      \
    \  } else {\n            index = input.index(after: index)\n        }\n    }\n\
    \    return out", "    if string.isEmpty || substring.isEmpty {\n        return\
    \ 0\n    }\n    var n = 0\n    for i in 0...string.count - substring.count {\n\
    \        let start = string.index(string.startIndex, offsetBy: i)\n        let\
    \ end = string.index(string.startIndex, offsetBy: i + substring.count)\n     \
    \   if String(string[start..<end]) == substring {\n            n += 1\n      \
    \  }\n    }\n    return n", "    guard !string.isEmpty else { return 0 }\n   \
    \ guard !substring.isEmpty else { return 0 }\n    return string.count - string.replacingOccurrences(of:\
    \ substring, with: \"\").count", "  guard substring.count <= string.count else\
    \ { return 0 }\n  var count = 0\n  var index = string.startIndex\n  while index\
    \ != string.endIndex {\n    let candidate = string[index...]\n    if candidate.starts(with:\
    \ substring) {\n      count += 1\n      index = string.index(index, offsetBy:\
    \ substring.count)\n    } else {\n      index = string.index(after: index)\n \
    \   }\n  }\n  return count", "    let string = string as NSString\n    let substring\
    \ = substring as NSString\n    var result = 0\n    var length_of_substring = substring.length\n\
    \    var start_index = 0\n    while start_index < string.length {\n        let\
    \ found_range = string.range(of: substring as String, options: [], range: NSRange(location:\
    \ start_index, length: string.length - start_index))\n        if found_range.location\
    \ != NSNotFound {\n            result += 1\n            start_index = found_range.location\
    \ + length_of_substring\n        } else {\n            break\n        }\n    }\n\
    \    return result", "    if string.isEmpty || substring.isEmpty {\n        return\
    \ 0\n    }\n    var count = 0\n    for i in 0..<string.count {\n        let index\
    \ = string.index(string.startIndex, offsetBy: i)\n        let stringSlice = string[index...]\n\
    \        let subIndex = stringSlice.index(stringSlice.startIndex, offsetBy: substring.count)\n\
    \        let subStringSlice = stringSlice[..<subIndex]\n        if String(subStringSlice)\
    \ == substring {\n            count += 1\n        }\n    }\n    return count",
  "    var string = string\n    var count = 0\n    while let range = string.range(of:\
    \ substring) {\n        count += 1\n        string = string.replacingCharacters(in:\
    \ range, with: \"\")\n    }\n    return count", '    return ["a", "a", "a", "a",
    "a"].filter { $0 == "a" }.count', '    return 0', "    guard string.count >= substring.count\
    \ else { return 0 }\n    let count = string.count\n    let subCount = substring.count\n\
    \    let start = string.startIndex\n    let end = string.index(start, offsetBy:\
    \ count - subCount + 1)\n    var countTimes = 0\n    for i in start..<end {\n\
    \        let startIndex = string.index(i, offsetBy: 0)\n        let endIndex =\
    \ string.index(i, offsetBy: subCount)\n        let range = startIndex..<endIndex\n\
    \        if string[range] == substring {\n            countTimes += 1\n      \
    \  }\n    }\n    return countTimes", "    guard substring.count > 0 else { return\
    \ 0 }\n    guard string.count >= substring.count else { return 0 }\n    var str\
    \ = string\n    var s = 0\n    var r = 0\n    while (s < str.count) {\n      \
    \  let r = str.range(of: substring, options: .literal, range: s..<str.endIndex,\
    \ locale: nil)\n        if let found = r {\n            s = found.upperBound\n\
    \            r += 1\n        } else {\n            break\n        }\n    }\n \
    \   return r", "    guard substring.count > 0 else { return 0 }\n    guard string.count\
    \ >= substring.count else { return 0 }\n    var result = 0\n    for i in 0...(string.count\
    \ - substring.count) {\n        if String(string[string.index(string.startIndex,\
    \ offsetBy: i)..<string.index(string.startIndex, offsetBy: i + substring.count)])\
    \ == substring {\n            result += 1\n        }\n    }\n    return result",
  "    guard substring.count <= string.count else { return 0 }\n    guard substring.count\
    \ != string.count else { return string == substring ? 1 : 0 }\n    guard substring.count\
    \ != 1 else { return string.reduce(0) { $1 == substring.first! ? $0 + 1 : $0 }\
    \ }\n    var result = 0\n    let substringStart = string.startIndex\n    let substringEnd\
    \ = string.index(string.startIndex, offsetBy: substring.count)\n    while substringEnd\
    \ <= string.endIndex {\n        if String(string[substringStart..<substringEnd])\
    \ == substring {\n            result += 1\n        }\n        string.formIndex(after:\
    \ &substringStart)\n        string.formIndex(after: &substringEnd)\n    }\n  \
    \  return result", "    guard substring.count <= string.count else { return 0\
    \ }\n    var count = 0\n    var string = string\n    while string.contains(substring)\
    \ {\n        count += 1\n        let index = string.index(of: substring)\n   \
    \     string = String(string[index!...])\n    }\n    return count", "    var counter\
    \ = 0\n    var startIndex = string.startIndex\n    while let range = string.range(of:\
    \ substring, options: [], range: startIndex..<string.endIndex, locale: nil) {\n\
    \        counter += 1\n        startIndex = range.upperBound\n    }\n    return\
    \ counter", "    if string.isEmpty || substring.isEmpty {\n        return 0\n\
    \    }\n    return string.reduce(0) { (count, char) -> Int in\n        if char\
    \ == substring.first {\n            let index = string.distance(from: string.startIndex,\
    \ to: string.index(after: string.index(of: char)!))\n            let range = string.index(string.startIndex,\
    \ offsetBy: index)..<string.endIndex\n            let rest = String(string[range])\n\
    \            if rest.range(of: substring) != nil {\n                return count\
    \ + 1\n            }\n        }\n        return count\n    }", "    var count\
    \ = 0\n    var curr = 0\n    while curr != -1 {\n        curr = string.find(substring,\
    \ start: curr)\n        if curr != -1 {\n            count += 1\n            curr\
    \ += 1\n        }\n    }\n    return count", "    // FIXME\n    return 0", '    return
    string.components(separatedBy: substring).count - 1', "    var count = 0\n   \
    \ var idx = string.startIndex\n    let end = string.endIndex\n    while idx !=\
    \ end {\n        let range = string.range(of: substring, options: [], range: idx..<end,\
    \ locale: nil)\n        if range == nil {\n            break\n        }\n    \
    \    idx = range!.upperBound\n        count += 1\n    }\n    return count", '    return
    string.components(separatedBy: substring).count - 1', "    var count = 0\n   \
    \ var startIndex = string.startIndex\n    while let substringRange = string.range(of:\
    \ substring, options: .caseInsensitive, range: Range(uncheckedBounds: (lower:\
    \ startIndex, upper: string.endIndex))) {\n        count += 1\n        startIndex\
    \ = substringRange.upperBound\n    }\n    return count", '    return string.components(separatedBy:
    substring).count - 1', "    var result = 0\n    var s = string\n    while true\
    \ {\n        if let range = s.range(of: substring) {\n            s = s.substring(from:\
    \ range.upperBound)\n            result += 1\n        } else {\n            break\n\
    \        }\n    }\n    return result", "    if string.isEmpty || substring.isEmpty\
    \ {\n        return 0\n    }\n    let results = string.matches(for: substring)\n\
    \    return results.count", "\tvar count = 0\n\tif substring.isEmpty {\n\t\treturn\
    \ count\n\t}\n\t\n\tlet substring_length = substring.lengthOfBytes(using: .utf8)\n\
    \tlet string_length = string.lengthOfBytes(using: .utf8)\n\t\n\tfor offset in\
    \ 0...(string_length - substring_length) {\n\t\tif (string as NSString).substring(with:\
    \ NSRange(location: offset, length: substring_length)) == substring {\n\t\t\t\
    count += 1\n\t\t}\n\t}\n\t\n\treturn count", "\tvar count = 0\n\tvar range = string.startIndex..<string.endIndex\n\
    \twhile let r = string.range(of: substring, options: [], range: range) {\n\t\t\
    count += 1\n\t\trange = r.upperBound..<string.endIndex\n\t}\n\treturn count",
  "    if string.isEmpty || substring.isEmpty {\n        return 0\n    }\n    if string.count\
    \ < substring.count {\n        return 0\n    }\n    if string == substring {\n\
    \        return 1\n    }\n    if string.prefix(substring.count) == substring {\n\
    \        return 1 + how_many_times(string: String(string.suffix(string.count -\
    \ substring.count)), substring: substring)\n    }\n    return how_many_times(string:\
    \ String(string.suffix(string.count - 1)), substring: substring)", '    return
    string.components(separatedBy: substring).count - 1', "    if substring.isEmpty\
    \ {\n        return 0\n    }\n    if string.isEmpty {\n        return 0\n    }\n\
    \    let range = (string as NSString).range(of: substring)\n    if range.location\
    \ == NSNotFound {\n        return 0\n    }\n    var count = 1\n    var index =\
    \ range.location + range.length\n    while index < string.count {\n        let\
    \ curRange = (string as NSString).range(of: substring, options: .literal, range:\
    \ NSRange(location: index, length: string.count - index))\n        if curRange.location\
    \ == NSNotFound {\n            break\n        }\n        count += 1\n        index\
    \ = curRange.location + curRange.length\n    }\n    return count", "    guard\
    \ string.count >= substring.count else { return 0 }\n    var count = 0\n    for\
    \ i in 0..<string.count - substring.count + 1 {\n        let start = string.index(string.startIndex,\
    \ offsetBy: i)\n        let end = string.index(string.startIndex, offsetBy: i\
    \ + substring.count)\n        if string[start..<end] == substring {\n        \
    \    count += 1\n        }\n    }\n    return count", "    guard string.count\
    \ >= substring.count else { return 0 }\n    let substringLength = substring.count\n\
    \    let stringLength = string.count\n    let stringArray = Array(string)\n  \
    \  let substringArray = Array(substring)\n    var result = 0\n    for i in 0...(stringLength\
    \ - substringLength) {\n        var matchCount = 0\n        for j in 0..<substringLength\
    \ {\n            if stringArray[i + j] == substringArray[j] {\n              \
    \  matchCount += 1\n            }\n        }\n        if matchCount == substringLength\
    \ {\n            result += 1\n        }\n    }\n    return result", "    var counter\
    \ = 0\n    let length_of_string = string.count\n    let length_of_substring =\
    \ substring.count\n    for i in 0..<length_of_string {\n        let range = string.index(string.startIndex,\
    \ offsetBy: i)..<string.index(string.startIndex, offsetBy: i + length_of_substring)\n\
    \        if substring == String(string[range]) {\n            counter += 1\n \
    \       }\n    }\n    return counter", "    var count = 0\n    for i in 0..<string.count\
    \ {\n        if string[i] == substring[0] {\n            if (string.count - i)\
    \ >= substring.count {\n                let sub_string = string[i..<i+substring.count]\n\
    \                if sub_string == substring {\n                    count += 1\n\
    \                }\n            }\n        }\n    }\n    return count", "    if\
    \ string.count < substring.count {\n        return 0\n    }\n    var occurences\
    \ = 0\n    var left_index = string.startIndex\n    while left_index != string.endIndex\
    \ {\n        if let index = string.index(left_index, offsetBy: substring.count,\
    \ limitedBy: string.endIndex) {\n            if string[left_index..<index] ==\
    \ substring {\n                occurences += 1\n            }\n            left_index\
    \ = string.index(after: index)\n        } else {\n            break\n        }\n\
    \    }\n    return occurences", "    if substring.isEmpty {\n        return 0\n\
    \    }\n    if string.isEmpty {\n        return 0\n    }\n    var count = 0\n\
    \    for index in string.indices {\n        if string[index] == substring[substring.startIndex]\
    \ {\n            let indexString = string.index(index, offsetBy: substring.count)\n\
    \            if indexString <= string.endIndex && string[index..<indexString]\
    \ == substring {\n                count += 1\n            }\n        }\n    }\n\
    \    return count", "    var counter = 0\n    for i in 0..<string.count {\n  \
    \      if string[i...].starts(with: substring) {\n            counter += 1\n \
    \       }\n    }\n    return counter", "    let len = string.characters.count\n\
    \    let sublen = substring.characters.count\n    if len == 0 || sublen == 0 ||\
    \ len < sublen {\n        return 0\n    }\n    var j = 0\n    var count = 0\n\
    \    for i in 0...len-sublen {\n        for j in 0..<sublen {\n            if\
    \ string[string.index(string.startIndex, offsetBy: i+j)] != substring[substring.index(substring.startIndex,\
    \ offsetBy: j)] {\n                break\n            }\n        }\n        if\
    \ j == sublen {\n            count += 1\n        }\n    }\n    return count",
  "    if string.isEmpty || substring.isEmpty {\n        return 0\n    }\n    let\
    \ stringLength = string.count\n    let subStringLength = substring.count\n   \
    \ if stringLength < subStringLength {\n        return 0\n    }\n    if stringLength\
    \ == subStringLength {\n        return string == substring ? 1 : 0\n    }\n  \
    \  var count = 0\n    for (index, _) in string.enumerated() {\n        if index\
    \ <= stringLength - subStringLength {\n            let startIndex = string.index(string.startIndex,\
    \ offsetBy: index)\n            let endIndex = string.index(string.startIndex,\
    \ offsetBy: index + subStringLength)\n            let tempSubString = string[startIndex..<endIndex]\n\
    \            if tempSubString == substring {\n                count += 1\n   \
    \         }\n        }\n    }\n    return count", "    let s = Array(string)\n\
    \    let sub = Array(substring)\n    var count = 0\n    if string.isEmpty || substring.isEmpty\
    \ {\n        return 0\n    }\n    for i in 0..<s.count {\n        if s[i] == sub[0]\
    \ {\n            var temp = true\n            for j in 1..<sub.count {\n     \
    \           if i + j >= s.count {\n                    temp = false\n        \
    \            break\n                }\n                if s[i + j] != sub[j] {\n\
    \                    temp = false\n                    break\n               \
    \ }\n            }\n            if temp {\n                count += 1\n      \
    \      }\n        }\n    }\n    return count", "    var count = 0\n    var start\
    \ = string.startIndex\n    let end = string.endIndex\n    while start < end {\n\
    \        let range = string.range(of: substring, range: start..<end)\n       \
    \ if range != nil {\n            count += 1\n            start = range!.upperBound\n\
    \        } else {\n            break\n        }\n    }\n    return count", " \
    \   guard !string.isEmpty && !substring.isEmpty else { return 0 }\n    var sIndex\
    \ = string.startIndex\n    var count = 0\n    while let rIndex = string.range(of:\
    \ substring, range: sIndex..<string.endIndex)?.lowerBound {\n        count +=\
    \ 1\n        sIndex = string.index(after: rIndex)\n    }\n    return count", " \
    \   var i = 0\n    while true {\n        if let range = string.range(of: substring,\
    \ options: [], range: string.startIndex..<string.endIndex, locale: nil) {\n  \
    \          string.removeSubrange(range)\n            i += 1\n        } else {\n\
    \            break\n        }\n    }\n    return i", "    var counter = 0\n  \
    \  var index = string.startIndex\n    while index < string.endIndex {\n      \
    \  if string.substring(from: index).hasPrefix(substring) {\n            counter\
    \ += 1\n            index = string.index(index, offsetBy: substring.count)\n \
    \       } else {\n            index = string.index(after: index)\n        }\n\
    \    }\n    return counter", "    guard !string.isEmpty && !substring.isEmpty\
    \ else { return 0 }\n    guard string.count >= substring.count else { return 0\
    \ }\n    var count = 0\n    var location = string.startIndex\n    while let range\
    \ = string.range(of: substring, range: location..<string.endIndex) {\n       \
    \ count += 1\n        location = range.upperBound\n    }\n    return count", " \
    \   guard !string.isEmpty else { return 0 }\n    guard !substring.isEmpty else\
    \ { return 0 }\n    guard substring.count <= string.count else { return 0 }\n\
    \    \n    var howManyTimes = 0\n    var substringHead = string.startIndex\n \
    \   let substringEnd = string.index(substringHead, offsetBy: substring.count)\n\
    \    while substringHead != string.endIndex {\n        if string[substringHead..<substringEnd]\
    \ == substring {\n            howManyTimes += 1\n            substringHead = string.index(substringHead,\
    \ offsetBy: 1)\n        } else {\n            substringHead = string.index(substringHead,\
    \ offsetBy: 1)\n        }\n    }\n    return howManyTimes", "\treturn 0", '    return
    -1', "    var count = 0\n    var last_found_index = 0\n    while true {\n    \
    \    if let found_index = string.firstIndex(of: substring, starting_at: last_found_index)\
    \ {\n            count += 1\n            last_found_index = string.index(after:\
    \ found_index)\n        } else {\n            break\n        }\n    }\n    return\
    \ count", "    assert(!string.isEmpty)\n    assert(!substring.isEmpty)\n    let\
    \ string: Array<Character> = Array(string)\n    let substring: Array<Character>\
    \ = Array(substring)\n    var result = 0\n    let innerClosure = {(index: Int)\
    \ -> Int in\n        let start = string.index(string.startIndex, offsetBy: index)\n\
    \        let end = string.index(string.startIndex, offsetBy: index + substring.count)\n\
    \        let range = start..<end\n        let rangeString = String(string[range])\n\
    \        if rangeString == substring {\n            result += 1\n            return\
    \ index + 1\n        }\n        return index\n    }\n    var from = 0\n    while\
    \ from < string.count {\n        from = innerClosure(from)\n    }\n    return\
    \ result", "    var index = string.startIndex\n    var result = 0\n    while true\
    \ {\n        index = string.index(index, offsetBy: 1, limitedBy: string.endIndex)\
    \ ?? string.endIndex\n        let range = index ..< string.endIndex\n        if\
    \ let range = string.range(of: substring, options: [], range: range, locale: nil)\
    \ {\n            result += 1\n            index = range.upperBound\n        }\
    \ else {\n            break\n        }\n    }\n    return result", "    if string.count\
    \ == 0 || substring.count == 0 {\n        return 0\n    }\n    var count = 0\n\
    \    var index = string.startIndex\n    let endIndex = string.endIndex\n    while\
    \ index < endIndex {\n        let nextIndex = string.index(index, offsetBy: substring.count,\
    \ limitedBy: endIndex) ?? endIndex\n        if string[index..<nextIndex] == substring\
    \ {\n            count += 1\n            index = nextIndex\n        } else {\n\
    \            index = string.index(after: index)\n        }\n    }\n    return\
    \ count", "  let start_substring = substring.startIndex\n  let end_substring =\
    \ substring.endIndex\n  let start_string = string.startIndex\n  let end_string\
    \ = string.endIndex\n  var count = 0\n  for index in 0...string.count-substring.count\
    \ {\n    let sub = string[start_string.advancedBy(index)..<start_string.advancedBy(index+substring.count)]\n\
    \    if sub == substring {\n      count += 1\n    }\n  }\n  return count", " \
    \   var counter = 0\n    var index = string.startIndex\n    while index < string.endIndex\
    \ {\n        if string.hasPrefix(substring, startingAt: index) {\n           \
    \ counter += 1\n            index = string.index(index, offsetBy: substring.count)\n\
    \        } else {\n            index = string.index(after: index)\n        }\n\
    \    }\n    return counter", "    let charSet = CharacterSet(charactersIn: substring)\n\
    \    let noSubstring = string.components(separatedBy: charSet).joined()\n    return\
    \ string.count - noSubstring.count", "    var result = 0\n    var i = 0\n    while\
    \ i < string.characters.count - substring.characters.count + 1 {\n        let\
    \ endIndex = string.index(string.startIndex, offsetBy: i + substring.characters.count)\n\
    \        let range = string.startIndex ..< endIndex\n        if string[range]\
    \ == substring {\n            result += 1\n            i += substring.characters.count\n\
    \        } else {\n            i += 1\n        }\n    }\n    return result", " \
    \   guard !string.isEmpty else { return 0 }\n    guard !substring.isEmpty else\
    \ { return 0 }\n    var count = 0\n    var startIndex = string.startIndex\n  \
    \  while let range = string.range(of: substring, options: [], range: startIndex..<string.endIndex,\
    \ locale: nil) {\n        count += 1\n        startIndex = range.upperBound\n\
    \    }\n    return count", "    let searchString = string as NSString\n    let\
    \ count = searchString.length - substring.characters.count + 1\n    var times\
    \ = 0\n    for i in 0..<count {\n        let range = NSRange(location: i, length:\
    \ substring.characters.count)\n        if searchString.substring(with: range)\
    \ == substring {\n            times += 1\n        }\n    }\n    return times",
  "    guard string.characters.count >= substring.characters.count else { return 0\
    \ }\n    var result = 0\n    for index in 0...string.characters.count - substring.characters.count\
    \ {\n        let start = string.startIndex.advancedBy(index)\n        let end\
    \ = start.advancedBy(substring.characters.count)\n        if string[start..<end]\
    \ == substring {\n            result += 1\n        }\n    }\n    return result",
  "    var count = 0\n    var mutableString = string\n    while !mutableString.isEmpty\
    \ {\n        if let index = mutableString.index(of: substring) {\n           \
    \ count += 1\n            mutableString = String(mutableString[index...])\n  \
    \      } else {\n            break\n        }\n    }\n    return count", "   \
    \ if (string.count < substring.count) {\n        return 0\n    }\n    if (string.count\
    \ == substring.count) {\n        return 1\n    }\n    var count = 0\n    var i\
    \ = 0\n    while i < string.count - substring.count + 1 {\n        let currentIndex\
    \ = string.index(string.startIndex, offsetBy: i)\n        let result = string.distance(from:\
    \ currentIndex, to: string.endIndex)\n        let range = Range(uncheckedBounds:\
    \ (currentIndex, string.index(string.startIndex, offsetBy: substring.count + i)))\n\
    \        let substringOnRange = string[range]\n        if substringOnRange ==\
    \ substring {\n            count += 1\n        }\n        i += 1\n    }\n    return\
    \ count", "    let maxIndex = string.endIndex\n    let tlen = substring.count\n\
    \    var cnt = 0\n    var last = 0\n    for i in 0..<string.count {\n        if\
    \ last == i {\n            if i + tlen > maxIndex {\n                break\n \
    \           }\n            let range = string.index(string.startIndex, offsetBy:\
    \ i)..<string.index(string.startIndex, offsetBy: i + tlen)\n            if substring\
    \ == String(string[range]) {\n                cnt += 1\n                last =\
    \ i + tlen\n            }\n        }\n    }\n    return cnt", "  if string.isEmpty\
    \ || substring.isEmpty {\n    return 0\n  }\n  let length = string.characters.count\n\
    \  let subLength = substring.characters.count\n  var count = 0\n  var index =\
    \ 0\n  while index < length {\n    if let range = string.range(of: substring,\
    \ options: .literal, range: Range(uncheckedBounds: (lower: string.index(string.startIndex,\
    \ offsetBy: index), upper: string.endIndex)), locale: nil) {\n      count += 1\n\
    \      index = string.distance(from: string.startIndex, to: range.upperBound)\n\
    \    } else {\n      break\n    }\n  }\n  return count", "    if string.count\
    \ < substring.count {\n        return 0\n    }\n    var count = 0\n    var range\
    \ = string.startIndex ..< string.endIndex\n    while let r = string.range(of:\
    \ substring, options: .literal, range: range, locale: nil) {\n        count +=\
    \ 1\n        range = r.upperBound ..< string.endIndex\n    }\n    return count",
  "    var count = 0\n    var start = string.startIndex\n    while let range = string.range(of:\
    \ substring, range: start..<string.endIndex) {\n        count += 1\n        start\
    \ = range.upperBound\n    }\n    return count", "    if string.isEmpty || substring.isEmpty\
    \ {\n        return 0\n    }\n\n    var remainingString = string\n    var count\
    \ = 0\n    while let range = remainingString.range(of: substring) {\n        count\
    \ += 1\n        let upperBound = range.upperBound\n        let remainingSubstring\
    \ = remainingString[upperBound...]\n        remainingString = String(remainingSubstring)\n\
    \    }\n    return count", "    let length = string.count - substring.count +\
    \ 1\n    return (0..<length).map { String(string[$0..<$0+substring.count]) }.filter\
    \ { $0 == substring }.count", "    if string.isEmpty || substring.isEmpty {\n\
    \        return 0\n    }\n    var num_times = 0\n    for i in string.indices {\n\
    \        if string[i] == substring[substring.startIndex] {\n            let str_len\
    \ = string.distance(from: i, to: string.endIndex)\n            let sub_len = substring.distance(from:\
    \ substring.startIndex, to: substring.endIndex)\n            if str_len >= sub_len\
    \ {\n                let index = string.index(i, offsetBy: sub_len)\n        \
    \        if string[i..<index] == substring {\n                    num_times +=\
    \ 1\n                }\n            }\n        }\n    }\n    return num_times",
  "    var count = 0\n    var tempStr = string\n    while tempStr.contains(substring)\
    \ {\n        tempStr = String(tempStr.dropFirst(substring.count))\n        count\
    \ += 1\n    }\n    return count", "    if string.isEmpty || substring.isEmpty\
    \ {\n        return 0\n    }\n    var result = 0\n    var string = string\n  \
    \  while let index = string.index(of: substring.first!) {\n        result += 1\n\
    \        string = String(string[index...])\n    }\n    return result", "  let\
    \ string = Array(string)\n  let substring = Array(substring)\n  var count = 0\n\
    \  for i in 0..<string.count - substring.count + 1 {\n    let slice = Array(string[i..<i+substring.count])\n\
    \    if slice == substring {\n      count += 1\n    }\n  }\n  return count", '  return
    string.components(separatedBy: substring).count - 1', "    let stringLength =\
    \ string.count\n    let substringLength = substring.count\n    var count = 0\n\
    \    var i = 0\n    while i < stringLength - substringLength + 1 {\n        if\
    \ string[i..<i+substringLength] == substring {\n            count += 1\n     \
    \       i += substringLength\n        } else {\n            i += 1\n        }\n\
    \    }\n    return count", "  var count = 0\n  var searchStartIndex = string.startIndex\n\
    \  while searchStartIndex < string.endIndex,\n    let range = string.range(of:\
    \ substring, range: searchStartIndex..<string.endIndex) {\n      count += 1\n\
    \      searchStartIndex = range.upperBound\n  }\n  return count", "    if substring.isEmpty\
    \ {\n        return 0\n    }\n    return (string.count - string.replacingOccurrences(of:\
    \ substring, with: \"\").count) / substring.count", "    guard !string.isEmpty\
    \ && !substring.isEmpty else { return 0 }\n    guard string.count >= substring.count\
    \ else { return 0 }\n    var last_index = string.startIndex\n    var count = 0\n\
    \    while last_index != string.endIndex {\n        guard let index = string[last_index...].firstIndex(of:\
    \ substring.first!) else { break }\n        if string[index..<string.index(index,\
    \ offsetBy: substring.count)] == substring {\n            count += 1\n       \
    \     last_index = string.index(index, offsetBy: substring.count)\n        } else\
    \ {\n            last_index = string.index(after: index)\n        }\n    }\n \
    \   return count", "    var input = string\n    var count = 0\n    while let range\
    \ = input.range(of: substring) {\n        input = input.replacingCharacters(in:\
    \ range, with: \"\")\n        count += 1\n    }\n    return count", '    return
    0', "  var i = 0\n  var j = 0\n  var count = 0\n  while i < string.count {\n \
    \   if j == substring.count {\n      count += 1\n      j = 0\n    }\n    if string[i]\
    \ == substring[j] {\n      j += 1\n    } else {\n      j = 0\n    }\n    i +=\
    \ 1\n  }\n  if j == substring.count {\n    count += 1\n  }\n  return count", " \
    \   guard !string.isEmpty else { return 0 }\n    guard !substring.isEmpty else\
    \ { return 0 }\n    guard string.count >= substring.count else { return 0 }\n\
    \    \n    var indexes: [Int] = []\n    for i in string.indices {\n        let\
    \ length = string.distance(from: i, to: string.endIndex)\n        if length >=\
    \ substring.count {\n            let j = string.index(i, offsetBy: substring.count)\n\
    \            let sub = string[i..<j]\n            if sub == substring {\n    \
    \            indexes.append(string.distance(from: string.startIndex, to: i))\n\
    \            }\n        }\n    }\n    return indexes.count", "    if (string.count\
    \ < substring.count) {\n        return 0\n    }\n    let d = substring.count\n\
    \    let n = string.count\n    var result = 0\n    for i in 0..<n-d+1 {\n    \
    \    let range = string.index(string.startIndex, offsetBy: i)..<string.index(string.startIndex,\
    \ offsetBy: i+d)\n        if string[range] == substring {\n            result\
    \ += 1\n        }\n    }\n    return result", '    return (string.count - substring.count
    + 1) - string.replacingOccurrences(of: substring, with: "").count', "    var counter\
    \ = 0\n    var last_found_idx = -1\n    for idx in 0..<string.count {\n      \
    \  let curr_idx = string.index(string.startIndex, offsetBy: idx)\n        if string[curr_idx]\
    \ == substring[substring.startIndex] {\n            if string.index(curr_idx,\
    \ offsetBy: substring.count - 1) < string.endIndex {\n                if string[string.index(curr_idx,\
    \ offsetBy: substring.count - 1)] == substring[substring.index(before: substring.endIndex)]\
    \ {\n                    if last_found_idx + substring.count <= idx {\n      \
    \                  counter += 1\n                        last_found_idx = idx\n\
    \                    }\n                }\n            }\n        }\n    }\n \
    \   return counter", "    guard substring.count <= string.count else { return\
    \ 0 }\n    var count = 0\n    let strLength = string.count\n    let subLength\
    \ = substring.count\n    for idx in 0...(strLength - subLength) {\n        let\
    \ slice = string[idx..<(idx + subLength)]\n        if slice == substring {\n \
    \           count += 1\n        }\n    }\n    return count", "    var range =\
    \ NSRange(location: 0, length: string.count)\n    var count = 0\n    while range.location\
    \ != NSNotFound {\n        let found = string.range(of: substring, options: [],\
    \ range: range)\n        if let found = found {\n            range.location =\
    \ found.upperBound.encodedOffset\n            range.length = string.count - range.location\n\
    \            count += 1\n        } else {\n            range.location = NSNotFound\n\
    \        }\n    }\n    return count", "    let range = string.startIndex ..< string.endIndex\n\
    \    let substring_range = substring.startIndex ..< substring.endIndex\n    let\
    \ charArray = string.characters\n    let charSubArray = substring.characters\n\
    \    var count = 0\n    for i in range {\n        if charArray[i] == charSubArray[substring_range.startIndex]\
    \ {\n            var done = false\n            for j in substring_range {\n  \
    \              if i == string.endIndex || j == substring.endIndex || charArray[i]\
    \ != charSubArray[j] {\n                    done = true\n                    break\n\
    \                }\n                i = i.successor()\n            }\n       \
    \     if !done {\n                count++\n            }\n        }\n    }\n \
    \   return count", "    let end = string.count - substring.count\n    var times\
    \ = 0\n    for i in 0...end {\n        if String(string[string.index(string.startIndex,\
    \ offsetBy: i)..<string.index(string.startIndex, offsetBy: i + substring.count)])\
    \ == substring {\n            times += 1\n        }\n    }\n    return times",
  "    guard !string.isEmpty else { return 0 }\n    guard !substring.isEmpty else\
    \ { return 0 }\n    guard string.count >= substring.count else { return 0 }\n\
    \    \n    let characterArray = Array(string)\n    let subCharacterArray = Array(substring)\n\
    \    \n    var index: Int = 0\n    var count: Int = 0\n    \n    while index <\
    \ string.count {\n        let indexRange = string.index(string.startIndex, offsetBy:\
    \ index)..<string.index(string.startIndex, offsetBy: subCharacterArray.count +\
    \ index)\n        let subArray = string[indexRange]\n        let subCharacterArrayStr\
    \ = String(subCharacterArray)\n        \n        if subArray == subCharacterArrayStr\
    \ {\n            count += 1\n            index += 1\n        } else {\n      \
    \      index += 1\n        }\n    }\n    \n    return count", "    guard substring.count\
    \ > 0 else { return 0 }\n    let substringLength = substring.count\n    var index\
    \ = string.startIndex\n    var count = 0\n    while index < string.endIndex {\n\
    \        let match = string.index(index, offsetBy: substringLength, limitedBy:\
    \ string.endIndex)\n        if string[index..<match!] == substring {\n       \
    \     count += 1\n            index = match!\n        } else {\n            index\
    \ = string.index(after: index)\n        }\n    }\n    return count", "    var\
    \ index = string.startIndex\n    var count = 0\n    while let match = string.range(of:\
    \ substring, range: index..<string.endIndex) {\n        count += 1\n        index\
    \ = match.upperBound\n    }\n    return count", "    var count = 0\n    var c\
    \ = string.startIndex\n    while c < string.endIndex {\n        let s = string.range(of:\
    \ substring, options: .literal, range: c..<string.endIndex, locale: nil)\n   \
    \     if s != nil {\n            count += 1\n            c = s!.upperBound\n \
    \       } else {\n            break\n        }\n    }\n    return count", "  \
    \  let len = string.count - substring.count + 1\n    var count = 0\n    for i\
    \ in 0..<len {\n        if string[i..<i+substring.count] == substring {\n    \
    \        count += 1\n        }\n    }\n    return count", "    // TODO\n    var\
    \ count = 0\n    for i in 0..<string.count {\n        let index = string.index(string.startIndex,\
    \ offsetBy: i)\n        if (string[index] == substring[substring.startIndex])\
    \ {\n            if (string.distance(from: index, to: string.endIndex) >= substring.count)\
    \ {\n                let substr = string[index..<string.index(index, offsetBy:\
    \ substring.count)]\n                if (substr == substring) {\n            \
    \        count += 1\n                }\n            }\n        }\n    }\n    return\
    \ count", "    var count = 0\n    var start_index = string.startIndex\n    while\
    \ start_index < string.endIndex {\n        let index = string.range(of: substring,\
    \ options: .literal, range: start_index..<string.endIndex, locale: nil)\n    \
    \    if index != nil {\n            count += 1\n            start_index = index!.upperBound\n\
    \        } else {\n            break\n        }\n    }\n    return count", "\t\
    var count = 0\n\tfor index in 0..<string.count {\n\t\tvar sub = String(string[string.index(string.startIndex,\
    \ offsetBy: index)])\n\t\twhile sub.count < string.count {\n\t\t\tif sub == substring\
    \ {\n\t\t\t\tcount += 1\n\t\t\t}\n\t\t\tindex += 1\n\t\t\tif index == string.count\
    \ {\n\t\t\t\tbreak\n\t\t\t}\n\t\t\tsub += String(string[string.index(string.startIndex,\
    \ offsetBy: index)])\n\t\t}\n\t}\n\treturn count", '    return 0', "    guard\
    \ string.count >= substring.count else { return 0 }\n    let string = Array(string)\n\
    \    let substring = Array(substring)\n    var count = 0\n    for start in 0..<string.count\
    \ {\n        if start + substring.count > string.count { break }\n        for\
    \ index in 0..<substring.count {\n            if string[start + index] != substring[index]\
    \ { break }\n            if index == substring.count - 1 { count += 1 }\n    \
    \    }\n    }\n    return count", "    var count = 0\n    var substringIndex =\
    \ string.startIndex\n    while substringIndex < string.endIndex {\n        let\
    \ substringRange = substringIndex..<string.index(substringIndex, offsetBy: substring.count)\n\
    \        if string[substringRange] == substring {\n            count += 1\n  \
    \      }\n        substringIndex = string.index(after: substringIndex)\n    }\n\
    \    return count", '    return (string.count - substring.count + 1)', "    let\
    \ lenS = string.count\n    let lenP = substring.count\n    var n = 0\n    for\
    \ i in 0..<lenS {\n        let endIndex = (i + lenP) < lenS ? (i + lenP) : lenS\n\
    \        let s = string[string.index(string.startIndex, offsetBy: i)..<string.index(string.startIndex,\
    \ offsetBy: endIndex)]\n        if s == substring {\n            n += 1\n    \
    \    }\n    }\n    return n", "    guard string.count >= substring.count else\
    \ { return 0 }\n    var substring = substring\n    var string = string\n    var\
    \ count = 0\n    while let found = string.range(of: substring) {\n        substring\
    \ = String(substring.dropFirst())\n        string = String(string.suffix(from:\
    \ found.upperBound))\n        count += 1\n    }\n    return count", "    var count\
    \ = 0\n    var startIndex = string.startIndex\n    while startIndex < string.endIndex\
    \ {\n        let range = string.range(of: substring, options: [], range: startIndex..<string.endIndex)\n\
    \        if range != nil {\n            count += 1\n            startIndex = range!.upperBound\n\
    \        } else {\n            break\n        }\n    }\n    return count", " \
    \   guard string.count >= substring.count else { return 0 }\n    guard substring.count\
    \ != 0 else { return string.count + 1 }\n    var count = 0\n    var idx = string.startIndex\n\
    \    while idx != string.endIndex {\n        if string[idx...].hasPrefix(substring)\
    \ {\n            count += 1\n            idx = string.index(idx, offsetBy: substring.count\
    \ - 1)\n        }\n        idx = string.index(after: idx)\n    }\n    return count",
  "    var current_start = string.startIndex\n    var count = 0\n    while current_start\
    \ < string.endIndex {\n        if let range = string.range(of: substring, range:\
    \ current_start..<string.endIndex) {\n            count += 1\n            current_start\
    \ = range.upperBound\n        } else {\n            break\n        }\n    }\n\
    \    return count", "    let chars = string.characters\n    let subchars = substring.characters\n\
    \    var count = 0\n    var char_index = chars.startIndex\n    var subchar_index\
    \ = subchars.startIndex\n    // Scanning chars\n    while char_index != chars.endIndex\
    \ {\n        // Matching chars and subchars\n        if chars[char_index] == subchars[subchar_index]\
    \ {\n            subchar_index = subchars.index(after: subchar_index)\n      \
    \      // Found a match?\n            if subchar_index == subchars.endIndex {\n\
    \                count += 1\n                subchar_index = subchars.startIndex\n\
    \            }\n        } else {\n            subchar_index = subchars.startIndex\n\
    \        }\n        char_index = chars.index(after: char_index)\n    }\n    return\
    \ count", "    var count = 0\n    var range = string.startIndex..<string.endIndex\n\
    \    while let found = string.range(of: substring, options: .literal, range: range,\
    \ locale: nil) {\n        count += 1\n        range = found.upperBound..<string.endIndex\n\
    \    }\n    return count", "    var count = 0\n    var string = string\n    while\
    \ string.contains(substring) {\n        string = string.replacingOccurrences(of:\
    \ substring, with: \"\")\n        count += 1\n    }\n    return count", "    guard\
    \ string.count >= substring.count else { return 0 }\n    let matching = string.matchingStrings(regex:\
    \ \"(\" + substring + \")\")\n    return matching.count", "    if substring.count\
    \ == 0 {\n        return 0\n    }\n    if string.count == 0 {\n        return\
    \ 0\n    }\n    if string.count < substring.count {\n        return 0\n    }\n\
    \    var start = string.startIndex\n    var end = string.index(start, offsetBy:\
    \ substring.count - 1)\n    var count = 0\n    while end < string.endIndex {\n\
    \        if string[start...end] == substring {\n            count += 1\n     \
    \   }\n        start = string.index(after: start)\n        end = string.index(after:\
    \ end)\n    }\n    return count", "    if let range = string.range(of: substring)\
    \ {\n        let prefix = string.prefix(upTo: range.lowerBound)\n        let suffix\
    \ = string.suffix(from: range.upperBound)\n        return 1 + how_many_times(string:\
    \ String(suffix), substring: substring)\n    }\n    return 0", "    var i = string.startIndex\n\
    \    var j = string.startIndex\n    var count = 0\n    while i != string.endIndex\
    \ {\n        if string[i] == substring[j] {\n            j = j.advancedBy(1)\n\
    \            if j == substring.endIndex {\n                count += 1\n      \
    \          j = string.startIndex\n            }\n        } else {\n          \
    \  j = string.startIndex\n        }\n        i = i.advancedBy(1)\n    }\n    return\
    \ count", "    if string.characters.count == 0 || substring.characters.count ==\
    \ 0 {\n        return 0\n    }\n    let subLength = substring.characters.count\n\
    \    let stringLength = string.characters.count\n    var n = 0\n    var subStringIndex\
    \ = 0\n    for (index, char) in string.characters.enumerated() {\n        if subStringIndex\
    \ == subLength {\n            n += 1\n            subStringIndex = 0\n       \
    \ }\n        if index == stringLength - 1 {\n            if char == substring[subStringIndex]\
    \ {\n                n += 1\n            }\n        }\n        if char == substring[subStringIndex]\
    \ {\n            subStringIndex += 1\n        } else {\n            subStringIndex\
    \ = 0\n        }\n    }\n    return n", "    let start = string.startIndex\n \
    \   let end = string.endIndex\n    let stringLength = string.distance(from: start,\
    \ to: end)\n    let subStringLength = substring.count\n    var count = 0\n   \
    \ for i in 0...stringLength - subStringLength {\n        if string[string.index(start,\
    \ offsetBy: i)..<string.index(start, offsetBy: i + subStringLength)] == substring\
    \ {\n            count += 1\n        }\n    }\n    return count", "    let len\
    \ = string.count - substring.count + 1\n    var total = 0\n    for i in 0..<len\
    \ {\n        let start = string.index(string.startIndex, offsetBy: i)\n      \
    \  let end = string.index(string.startIndex, offsetBy: i + substring.count)\n\
    \        let sub = string[start..<end]\n        if sub == substring {\n      \
    \      total += 1\n        }\n    }\n    return total", '    return (string +
    string).ranges(of: substring).count', "    if substring.isEmpty {\n        return\
    \ 0\n    }\n    return string.components(separatedBy: substring).count - 1", " \
    \   var count = 0\n    var current = string.startIndex\n    var match = string.startIndex\n\
    \    for _ in 0...string.count {\n        if string[current] == substring[match]\
    \ {\n            match = substring.index(after: match)\n            if match ==\
    \ substring.endIndex {\n                count += 1\n                match = substring.startIndex\n\
    \            }\n        } else {\n            match = substring.startIndex\n \
    \       }\n        current = string.index(after: current)\n    }\n    return count",
  "    let my_string = string\n    let my_substring = substring\n    let str_count\
    \ = my_string.count\n    let substr_count = my_substring.count\n    var count\
    \ = 0\n    var i = 0\n    while i <= str_count - substr_count {\n        let sub_range\
    \ = my_string.index(my_string.startIndex, offsetBy: i) ..< my_string.index(my_string.startIndex,\
    \ offsetBy: i + substr_count)\n        if String(my_string[sub_range]) == my_substring\
    \ {\n            count += 1\n            i += substr_count\n        } else {\n\
    \            i += 1\n        }\n    }\n    return count", "    var result = 0\n\
    \    var string = string\n    while let range = string.range(of: substring) {\n\
    \        result += 1\n        string = string.replacingCharacters(in: range, with:\
    \ \"\")\n    }\n    return result", "    var count = 0\n    var startIndex = string.startIndex\n\
    \    while let current_index = string.range(of: substring, options: [], range:\
    \ startIndex..<string.endIndex)?.lowerBound {\n        count += 1\n        startIndex\
    \ = string.index(after: current_index)\n    }\n    return count", '    return
    string.components(separatedBy: substring).count - 1', "    var index = string.startIndex\n\
    \    var count = 0\n    while let range = string.range(of: substring, range: index..<string.endIndex)\
    \ {\n        count += 1\n        index = range.upperBound\n    }\n    return count",
  '    return 0', '    return string.get(matching: substring)', "    var ret = 0\n\
    \    var index = string.startIndex\n    let end = string.endIndex\n    let sub_len\
    \ = substring.count\n    while index < end {\n        let range = string.range(of:\
    \ substring, options: .literal, range: index..<end, locale: nil)\n        if range\
    \ != nil {\n            index = range!.upperBound\n            ret += 1\n    \
    \    } else {\n            break\n        }\n    }\n    return ret", "    var\
    \ count = 0\n    var string = string\n    while string.count >= substring.count\
    \ {\n        if string.hasPrefix(substring) {\n            count += 1\n      \
    \      string = String(string.dropFirst(substring.count))\n        } else {\n\
    \            string = String(string.dropFirst())\n        }\n    }\n    return\
    \ count", "    guard !string.isEmpty && !substring.isEmpty else { return 0 }\n\
    \    guard substring.count <= string.count else { return 0 }\n    let s = string.components(separatedBy:\
    \ substring)\n    return s.count - 1", "    var string = string\n    var substring\
    \ = substring\n    if string.count < substring.count {\n        return 0\n   \
    \ }\n    var count = 0\n    while let range = string.range(of: substring) {\n\
    \        string.removeSubrange(range)\n        count += 1\n    }\n    return count",
  "    guard string.count >= substring.count else { return 0 }\n    guard substring.count\
    \ > 0 else { return 0 }\n    var index = string.startIndex\n    var count = 0\n\
    \    while index < string.endIndex {\n        if string[index] == substring[substring.startIndex]\
    \ {\n            var i = index\n            var j = substring.startIndex\n   \
    \         while i < string.endIndex, j < substring.endIndex, string[i] == substring[j]\
    \ {\n                i = string.index(after: i)\n                j = substring.index(after:\
    \ j)\n            }\n            if j == substring.endIndex {\n              \
    \  count += 1\n            }\n        }\n        index = string.index(after: index)\n\
    \    }\n    return count", "    var index = string.startIndex\n    var count =\
    \ 0\n    while true {\n        let range = string.range(of: substring, options:\
    \ [], range: index..<string.endIndex, locale: nil)\n        if range == nil {\n\
    \            break\n        }\n        index = range!.upperBound\n        count\
    \ += 1\n    }\n    return count", "    var count = 0\n    var search_range = string.startIndex..<string.endIndex\n\
    \    while let range = string.range(of: substring, options: [], range: search_range,\
    \ locale: nil) {\n        count += 1\n        search_range = range.upperBound..<search_range.upperBound\n\
    \    }\n    return count", "\tlet scanner = Scanner(string: string)\n\tvar count\
    \ = 0\n\twhile !scanner.isAtEnd {\n\t\tscanner.scanUpTo(substring, into: nil)\n\
    \t\tif scanner.scanString(substring, into: nil) {\n\t\t\tcount += 1\n\t\t}\n\t\
    }\n\treturn count", "    var count = 0\n    for i in 0..<string.count {\n    \
    \    if let range = string.range(of: substring, range: i..<string.endIndex) {\n\
    \            count += 1\n            print(range)\n        }\n    }\n    return\
    \ count", "    guard string.count >= substring.count else { return 0 }\n    guard\
    \ substring.count > 0 else { return 0 }\n    guard string.count > 0 else { return\
    \ 0 }\n    \n    var index = string.startIndex\n    var endIndex = string.index(index,\
    \ offsetBy: substring.count)\n    var count = 0\n    \n    while true {\n    \
    \    let substringFromString = string[index..<endIndex]\n        if substringFromString\
    \ == substring {\n            count += 1\n        }\n        if endIndex >= string.endIndex\
    \ {\n            break\n        }\n        index = string.index(after: index)\n\
    \        endIndex = string.index(after: endIndex)\n    }\n    \n    return count",
  "    guard string.count >= substring.count else { return 0 }\n    var index = string.startIndex\n\
    \    var count = 0\n    while index <= string.index(string.endIndex, offsetBy:\
    \ -substring.count) {\n        if string[index...].hasPrefix(substring) {\n  \
    \          count += 1\n            index = string.index(index, offsetBy: substring.count)\n\
    \        } else {\n            index = string.index(after: index)\n        }\n\
    \    }\n    return count", "\treturn 0", "    if string.count < substring.count\
    \ {\n        return 0\n    }\n    var from = string.startIndex\n    var to = string.index(from,\
    \ offsetBy: substring.count)\n    var result = 0\n    while to != string.endIndex\
    \ {\n        if String(string[from..<to]) == substring {\n            result +=\
    \ 1\n        }\n        from = string.index(from, offsetBy: 1)\n        to = string.index(to,\
    \ offsetBy: 1)\n    }\n    return result", '    return 0', "    var string = string\n\
    \    var count = 0\n    while let range = string.range(of: substring) {\n    \
    \    count += 1\n        string = string.replacingCharacters(in: range, with:\
    \ \"\")\n    }\n    return count", "    guard substring.count <= string.count\
    \ else { return 0 }\n    guard !substring.isEmpty else { return 0 }\n    guard\
    \ !string.isEmpty else { return 0 }\n    \n    var count = 0\n    var index =\
    \ string.startIndex\n    while index != string.endIndex {\n        if string[index]\
    \ == substring[substring.startIndex] {\n            let endIndex = string.index(index,\
    \ offsetBy: substring.count)\n            if string[index..<endIndex] == substring\
    \ {\n                count += 1\n                index = endIndex\n          \
    \  } else {\n                index = string.index(after: index)\n            }\n\
    \        } else {\n            index = string.index(after: index)\n        }\n\
    \    }\n    return count", "  let nsString = string as NSString\n  let nsSubstring\
    \ = substring as NSString\n  let len = nsString.length\n  let sublen = nsSubstring.length\n\
    \  var count = 0\n  for i in 0..<len {\n    let range = NSRange(location: i, length:\
    \ sublen)\n    if nsString.substring(with: range) == nsSubstring as String {\n\
    \      count += 1\n    }\n  }\n  return count", "    guard substring.count > 0\
    \ && string.count >= substring.count else { return 0 }\n    guard string.count\
    \ > substring.count else { return 1 }\n    var count = 0\n    for index in 0...(string.count\
    \ - substring.count) {\n        count += (string[index...(index + substring.count\
    \ - 1)] == substring) ? 1 : 0\n    }\n    return count", "    var result = 0\n\
    \    var start = string.startIndex\n    while let range = string.range(of: substring,\
    \ range: start..<string.endIndex) {\n        start = range.upperBound\n      \
    \  result += 1\n    }\n    return result", "    guard string.count >= substring.count\
    \ else { return 0 }\n    guard substring.count > 0 else { return 0 }\n    var\
    \ result = 0\n    var idx = string.startIndex\n    while true {\n        let index\
    \ = string.index(of: substring, in: idx..<string.endIndex)\n        if index ==\
    \ nil {\n            break\n        }\n        idx = string.index(after: index!)\n\
    \        result += 1\n    }\n    return result", "    var count = 0\n    let range\
    \ = NSRange(location: 0, length: string.count)\n    let regex = try! NSRegularExpression(pattern:\
    \ substring, options: [])\n    regex.enumerateMatches(in: string, options: [],\
    \ range: range) { match, _, _ in\n        if let match = match {\n           \
    \ count += 1\n        }\n    }\n    return count", "\treturn string.characters.count\
    \ - string.replacingOccurrences(of: substring, with: \"\").characters.count",
  "    if (string.isEmpty || substring.isEmpty) {\n        return 0\n    }\n    if\
    \ (string.count < substring.count) {\n        return 0\n    }\n    var count =\
    \ 0\n    for i in 0..<string.count {\n        if (string[i..<(i+substring.count)]\
    \ == substring) {\n            count += 1\n        }\n    }\n    return count",
  "    var count = 0\n    if string.count > substring.count {\n        for (index,\
    \ _) in string.enumerated() {\n            if string[index..<index+substring.count]\
    \ == substring {\n                count += 1\n            }\n        }\n    }\n\
    \    return count", "    var count = 0\n    var startIndex = string.startIndex\n\
    \    let finalIndex = string.endIndex\n    let substringLength = substring.count\n\
    \    while startIndex < finalIndex {\n        let endIndex = string.index(startIndex,\
    \ offsetBy: substringLength, limitedBy: finalIndex) ?? finalIndex\n        if\
    \ substring == String(string[startIndex..<endIndex]) {\n            count += 1\n\
    \        }\n        startIndex = string.index(after: startIndex)\n    }\n    return\
    \ count", "    let nsString = string as NSString\n    let subStringRange = nsString.range(of:\
    \ substring)\n    if subStringRange.location == NSNotFound {\n        return 0\n\
    \    }\n    let length = string.distance(from: string.startIndex, to: subStringRange.lowerBound)\n\
    \    return how_many_times(string: string, substring: substring) + 1 + how_many_times(string:\
    \ String(string[string.index(string.startIndex, offsetBy: length + substring.count)...]),\
    \ substring: substring)", "    var count = 0\n    var startIndex = string.startIndex\n\
    \    while let range = string.range(of: substring, options: .caseInsensitive,\
    \ range: startIndex..<string.endIndex, locale: nil) {\n        count += 1\n  \
    \      startIndex = range.upperBound\n    }\n    return count", "    if string.count\
    \ < substring.count {\n        return 0\n    }\n    var n = 0\n    var i = 0\n\
    \    while i < string.count - substring.count + 1 {\n        let range = string.index(string.startIndex,\
    \ offsetBy: i) ..< string.index(string.startIndex, offsetBy: i + substring.count)\n\
    \        if String(string[range]) == substring {\n            n += 1\n       \
    \     i += substring.count\n        } else {\n            i += 1\n        }\n\
    \    }\n    return n", "    var result = 0\n    var index = string.startIndex\n\
    \    while index < string.endIndex {\n        if string.hasPrefix(substring, startingAt:\
    \ index) {\n            result += 1\n            index = string.index(index, offsetBy:\
    \ substring.count)\n        } else {\n            index = string.index(after:\
    \ index)\n        }\n    }\n    return result", "    guard string.count >= substring.count\
    \ else { return 0 }\n    var result = 0\n    for i in 0 ..< string.count {\n \
    \       if i + substring.count <= string.count {\n            let startIndex =\
    \ string.index(string.startIndex, offsetBy: i)\n            let endIndex = string.index(string.startIndex,\
    \ offsetBy: i + substring.count)\n            let temp = String(string[startIndex\
    \ ..< endIndex])\n            if temp == substring {\n                result +=\
    \ 1\n            }\n        }\n    }\n    return result", "    if string.isEmpty\
    \ || substring.isEmpty {\n        return 0\n    }\n    var count = 0\n    var\
    \ previousIndex = 0\n    while true {\n        let range = string.range(of: substring,\
    \ options: .caseInsensitive, range: string.index(string.startIndex, offsetBy:\
    \ previousIndex)..<string.endIndex, locale: nil)\n        if let range = range\
    \ {\n            count += 1\n            previousIndex = string.distance(from:\
    \ string.startIndex, to: range.upperBound)\n        } else {\n            break\n\
    \        }\n    }\n    return count", "    var last: Int = -1\n    var number_of_times:\
    \ Int = 0\n    while let range = string.range(of: substring, options: .literal,\
    \ range: Range(uncheckedBounds: (last, string.endIndex)), locale: nil) {\n   \
    \     last = string.distance(from: string.startIndex, to: range.upperBound)\n\
    \        number_of_times += 1\n    }\n    return number_of_times", '    return
    0', "    guard !string.isEmpty else { return 0 }\n    guard !substring.isEmpty\
    \ else { return 0 }\n    guard substring.count <= string.count else { return 0\
    \ }\n    \n    var string = string\n    var substring = substring\n    var found:\
    \ Int = 0\n    \n    while let range = string.range(of: substring) {\n       \
    \ string.removeSubrange(range)\n        found += 1\n    }\n    \n    return found",
  "    if string.isEmpty || substring.isEmpty {\n        return 0\n    }\n\n    var\
    \ count = 0\n    var index = string.startIndex\n    while index < string.endIndex\
    \ {\n        let range = string.range(of: substring, range: index..<string.endIndex)\n\
    \        if let r = range {\n            count += 1\n            index = r.upperBound\n\
    \        } else {\n            break\n        }\n    }\n    return count", '    return
    string.characters.split(separator: Character(substring), maxSplits: string.characters.count,
    omittingEmptySubsequences: false).count - 1', "    var count = 0\n    var i =\
    \ 0\n    var j = 0\n    for i in string.indices {\n        for j in substring.indices\
    \ {\n            let string_char = string[i]\n            let substring_char =\
    \ substring[j]\n            if string_char == substring_char {\n             \
    \   count += 1\n            }\n        }\n    }\n    return count", "    // your\
    \ code here\n    return 0", "    if string.count < substring.count {\n       \
    \ return 0\n    }\n    if string.count == substring.count {\n        return string\
    \ == substring ? 1 : 0\n    }\n    var result = 0\n    var i = 0\n    while i\
    \ < string.count - substring.count + 1 {\n        let index = string.index(string.startIndex,\
    \ offsetBy: i)\n        let sub = string[index..<string.index(index, offsetBy:\
    \ substring.count)]\n        if sub == substring {\n            result += 1\n\
    \            i += substring.count\n        } else {\n            i += 1\n    \
    \    }\n    }\n    return result", "    var count = 0\n    var stringCopy = string\n\
    \    var substringCopy = substring\n    while substringCopy.count <= stringCopy.count\
    \ {\n        if let range = stringCopy.range(of: substringCopy) {\n          \
    \  count += 1\n            stringCopy.removeSubrange(range)\n        } else {\n\
    \            break\n        }\n    }\n    return count", "    var num_times =\
    \ 0\n    var cursor = string.startIndex\n    while cursor < string.endIndex {\n\
    \        let range = string.range(of: substring, range: cursor..<string.endIndex)\n\
    \        if range != nil {\n            num_times += 1\n            cursor = range!.upperBound\n\
    \        } else {\n            break\n        }\n    }\n    return num_times",
  "\tlet chars = Array(string)\n\tlet subchars = Array(substring)\n\tvar count = 0\n\
    \t\n\tvar i = 0\n\twhile i < chars.count {\n\t\tif chars[i] == subchars[0] {\n\
    \t\t\tvar j = 1\n\t\t\twhile j < subchars.count && i + j < chars.count && chars[i\
    \ + j] == subchars[j] {\n\t\t\t\tj += 1\n\t\t\t}\n\t\t\tif j == subchars.count\
    \ {\n\t\t\t\tcount += 1\n\t\t\t\ti += j - 1\n\t\t\t}\n\t\t}\n\t\ti += 1\n\t}\n\
    \t\n\treturn count", '    return string.components(separatedBy: substring).count
    - 1', "    guard string.count >= substring.count else { return 0 }\n    var occurrences\
    \ = 0\n    var index = string.startIndex\n    while index < string.endIndex {\n\
    \        if let r = string.range(of: substring, range: index..<string.endIndex,\
    \ options: .caseInsensitive, locale: nil) {\n            occurrences += 1\n  \
    \          index = r.upperBound\n        } else {\n            break\n       \
    \ }\n    }\n    return occurrences", "    var count = 0\n    var start = string.startIndex\n\
    \    while let range = string.range(of: substring, range: start..<string.endIndex)\
    \ {\n        count += 1\n        start = range.upperBound\n    }\n    return count",
  "    guard !string.isEmpty else { return 0 }\n    guard !substring.isEmpty else\
    \ { return 0 }\n    let endIndex = string.index(string.startIndex, offsetBy: string.count\
    \ - substring.count + 1)\n    var count = 0\n    for s in string[string.startIndex..<endIndex]\
    \ {\n        if String(s) == substring.first! {\n            let currEndIndex\
    \ = string.index(string.startIndex, offsetBy: string.distance(from: string.startIndex,\
    \ to: s) + substring.count)\n            if string[s..<currEndIndex] == substring\
    \ {\n                count += 1\n            }\n        }\n    }\n    return count",
  "    if substring.isEmpty {\n        return 0\n    }\n    var fromIndex = string.startIndex\n\
    \    var occurrences = 0\n    while let range = string.range(of: substring, options:\
    \ .caseInsensitive, range: fromIndex..<string.endIndex, locale: nil) {\n     \
    \   occurrences += 1\n        fromIndex = range.upperBound\n    }\n    return\
    \ occurrences", "    if string.isEmpty || substring.isEmpty {\n        return\
    \ 0\n    }\n    var str = string\n    var count = 0\n    while let s = str.range(of:\
    \ substring) {\n        count += 1\n        str = String(str[s.upperBound...])\n\
    \    }\n    return count", "    assert(string.count >= substring.count)\n    return\
    \ (string.count - substring.count + 1) - (string.replacingOccurrences(of: substring,\
    \ with: \"\").count - substring.count + 1)", "  var count = 0\n  var i = 0\n \
    \ var l = substring.count\n  var s = string.count\n  while i < s {\n    if let\
    \ range = string.range(of: substring, options: .literal, range: i..<s, locale:\
    \ nil) {\n      count += 1\n      i = range.upperBound.encodedOffset\n    } else\
    \ {\n      break\n    }\n  }\n  return count", "    guard string.count >= substring.count\
    \ else { return 0 }\n    var searchStartIndex = string.startIndex\n    var count\
    \ = 0\n    while searchStartIndex < string.endIndex,\n        let range = string.range(of:\
    \ substring, range: searchStartIndex..<string.endIndex) {\n            searchStartIndex\
    \ = range.lowerBound < string.endIndex ? string.index(after: range.lowerBound)\
    \ : string.endIndex\n            count += 1\n    }\n    return count", "    let\
    \ elements = string.characters.split(separator: Character(substring)).map(String.init)\n\
    \    return elements.count-1", "\tlet range = string.range(of: substring)\n\t\
    if range == nil {\n\t\treturn 0\n\t} else {\n\t\tlet distance = string.distance(from:\
    \ string.startIndex, to: range!.lowerBound)\n\t\tlet newString = string.substring(from:\
    \ string.index(string.startIndex, offsetBy: distance + 1))\n\t\treturn 1 + how_many_times(string:\
    \ newString, substring: substring)\n\t}", "    // you code here\n    var total\
    \ = 0\n    var sub_index = string.startIndex\n    while sub_index < string.endIndex\
    \ {\n        if let range = string.range(of: substring, range: sub_index..<string.endIndex)\
    \ {\n            total += 1\n            sub_index = range.upperBound\n      \
    \  } else {\n            break\n        }\n    }\n    return total", "    var\
    \ count = 0\n    if string.isEmpty || substring.isEmpty {\n        return count\n\
    \    }\n    var startIndex = string.startIndex\n    let endIndex = string.endIndex\n\
    \    let subStringLength = substring.count\n    while startIndex < endIndex {\n\
    \        let range = string.range(of: substring, options: [], range: startIndex..<endIndex,\
    \ locale: nil)\n        if let foundRange = range {\n            startIndex =\
    \ foundRange.upperBound\n            count += 1\n        } else {\n          \
    \  break\n        }\n    }\n    return count", "    if string.count < substring.count\
    \ {\n        return 0\n    }\n    var count = 0\n    let range = string.startIndex\
    \ ..< string.endIndex\n    string.enumerateSubstrings(in: range, options: .byWords)\
    \ { (word, _, _, _) in\n        if let word = word, word == substring {\n    \
    \        count += 1\n        }\n    }\n    return count", "    if substring.count\
    \ > string.count {\n        return 0\n    }\n    var slice = string\n    var count\
    \ = 0\n    while let range = slice.range(of: substring) {\n        count += 1\n\
    \        slice = String(slice[range.upperBound...])\n    }\n    return count",
  '    return string.split(substring).count - 1']
stop_tokens:
- "\n}"
