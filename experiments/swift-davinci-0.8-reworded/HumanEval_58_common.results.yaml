language: swift
name: HumanEval_58_common
results:
- exit_code: 0
  program: "\n/// Return sorted unique common elements for two arrays.\n/// >>> common(l1:\
    \ [1, 4, 3, 34, 653, 2, 5], l2: [5, 7, 1, 5, 9, 653, 121])\n/// [1, 5, 653]\n\
    /// >>> common(l1: [5, 3, 2, 8], l2: [3, 2])\n/// [2, 3]\nfunc common(l1: [Int],\
    \ l2: [Int]) -> [Int] {\n    let set1 = Set(l1)\n    let set2 = Set(l2)\n    return\
    \ Array(set1.intersection(set2)).sorted()\n}\n\n\nfunc ==(left: [(Int, Int)],\
    \ right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n       \
    \ return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r\
    \ {\n            return false\n        }\n    }\n    return true\n}\n        \
    \    \nassert(common(l1: [1, 4, 3, 34, 653, 2, 5], l2: [5, 7, 1, 5, 9, 653, 121])\
    \ == [1, 5, 653])\nassert(common(l1: [5, 3, 2, 8], l2: [3, 2]) == [2, 3])\nassert(common(l1:\
    \ [4, 3, 2, 8], l2: [3, 2, 4]) == [2, 3, 4])\nassert(common(l1: [4, 3, 2, 8],\
    \ l2: [] as [Int]) == [] as [Int])"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659979279
- exit_code: 0
  program: "\n/// Return sorted unique common elements for two arrays.\n/// >>> common(l1:\
    \ [1, 4, 3, 34, 653, 2, 5], l2: [5, 7, 1, 5, 9, 653, 121])\n/// [1, 5, 653]\n\
    /// >>> common(l1: [5, 3, 2, 8], l2: [3, 2])\n/// [2, 3]\nfunc common(l1: [Int],\
    \ l2: [Int]) -> [Int] {\n    let set1 = Set(l1)\n    let set2 = Set(l2)\n    let\
    \ inter = set1.intersection(set2)\n    return Array(inter).sorted()\n}\n\n\nfunc\
    \ ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count !=\
    \ right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(common(l1: [1, 4, 3, 34, 653, 2, 5], l2: [5, 7,\
    \ 1, 5, 9, 653, 121]) == [1, 5, 653])\nassert(common(l1: [5, 3, 2, 8], l2: [3,\
    \ 2]) == [2, 3])\nassert(common(l1: [4, 3, 2, 8], l2: [3, 2, 4]) == [2, 3, 4])\n\
    assert(common(l1: [4, 3, 2, 8], l2: [] as [Int]) == [] as [Int])"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659979279
- exit_code: 0
  program: "\n/// Return sorted unique common elements for two arrays.\n/// >>> common(l1:\
    \ [1, 4, 3, 34, 653, 2, 5], l2: [5, 7, 1, 5, 9, 653, 121])\n/// [1, 5, 653]\n\
    /// >>> common(l1: [5, 3, 2, 8], l2: [3, 2])\n/// [2, 3]\nfunc common(l1: [Int],\
    \ l2: [Int]) -> [Int] {\n    var result = [Int]()\n    for item in l1 {\n    \
    \    if l2.contains(item) {\n            result.append(item)\n        }\n    }\n\
    \    return Array(Set(result)).sorted()\n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(common(l1: [1, 4, 3, 34, 653, 2, 5], l2: [5, 7, 1, 5, 9, 653, 121]) ==\
    \ [1, 5, 653])\nassert(common(l1: [5, 3, 2, 8], l2: [3, 2]) == [2, 3])\nassert(common(l1:\
    \ [4, 3, 2, 8], l2: [3, 2, 4]) == [2, 3, 4])\nassert(common(l1: [4, 3, 2, 8],\
    \ l2: [] as [Int]) == [] as [Int])"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659979279
- exit_code: 0
  program: "\n/// Return sorted unique common elements for two arrays.\n/// >>> common(l1:\
    \ [1, 4, 3, 34, 653, 2, 5], l2: [5, 7, 1, 5, 9, 653, 121])\n/// [1, 5, 653]\n\
    /// >>> common(l1: [5, 3, 2, 8], l2: [3, 2])\n/// [2, 3]\nfunc common(l1: [Int],\
    \ l2: [Int]) -> [Int] {\n    let l1_set = Set(l1)\n    let l2_set = Set(l2)\n\
    \    let common = l1_set.intersection(l2_set)\n    return Array(common).sorted()\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(common(l1: [1, 4, 3, 34, 653, 2, 5], l2: [5, 7,\
    \ 1, 5, 9, 653, 121]) == [1, 5, 653])\nassert(common(l1: [5, 3, 2, 8], l2: [3,\
    \ 2]) == [2, 3])\nassert(common(l1: [4, 3, 2, 8], l2: [3, 2, 4]) == [2, 3, 4])\n\
    assert(common(l1: [4, 3, 2, 8], l2: [] as [Int]) == [] as [Int])"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659979279
- exit_code: 0
  program: "\n/// Return sorted unique common elements for two arrays.\n/// >>> common(l1:\
    \ [1, 4, 3, 34, 653, 2, 5], l2: [5, 7, 1, 5, 9, 653, 121])\n/// [1, 5, 653]\n\
    /// >>> common(l1: [5, 3, 2, 8], l2: [3, 2])\n/// [2, 3]\nfunc common(l1: [Int],\
    \ l2: [Int]) -> [Int] {\n    let set1 = Set(l1)\n    let set2 = Set(l2)\n    return\
    \ Array(set1.intersection(set2)).sorted()\n}\n\n\nfunc ==(left: [(Int, Int)],\
    \ right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n       \
    \ return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r\
    \ {\n            return false\n        }\n    }\n    return true\n}\n        \
    \    \nassert(common(l1: [1, 4, 3, 34, 653, 2, 5], l2: [5, 7, 1, 5, 9, 653, 121])\
    \ == [1, 5, 653])\nassert(common(l1: [5, 3, 2, 8], l2: [3, 2]) == [2, 3])\nassert(common(l1:\
    \ [4, 3, 2, 8], l2: [3, 2, 4]) == [2, 3, 4])\nassert(common(l1: [4, 3, 2, 8],\
    \ l2: [] as [Int]) == [] as [Int])"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659979279
- exit_code: -4
  program: "\n/// Return sorted unique common elements for two arrays.\n/// >>> common(l1:\
    \ [1, 4, 3, 34, 653, 2, 5], l2: [5, 7, 1, 5, 9, 653, 121])\n/// [1, 5, 653]\n\
    /// >>> common(l1: [5, 3, 2, 8], l2: [3, 2])\n/// [2, 3]\nfunc common(l1: [Int],\
    \ l2: [Int]) -> [Int] {\n  return Array(Set(l1).intersection(Set(l2)))\n}\n\n\n\
    func ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(common(l1: [1, 4, 3, 34, 653, 2, 5], l2: [5, 7,\
    \ 1, 5, 9, 653, 121]) == [1, 5, 653])\nassert(common(l1: [5, 3, 2, 8], l2: [3,\
    \ 2]) == [2, 3])\nassert(common(l1: [4, 3, 2, 8], l2: [3, 2, 4]) == [2, 3, 4])\n\
    assert(common(l1: [4, 3, 2, 8], l2: [] as [Int]) == [] as [Int])"
  status: Exception
  stderr: 'tmpd8kd9pul/tmpd8kd9pul.swift:24: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b0683e05c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b0683afcb6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b0683afc988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b0683afb7b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpd8kd9pul                        0x00005556441e05fc <unavailable> + 5628

    5    libc.so.6                          0x00002b0683ff1460 __libc_start_main +
    245

    6    tmpd8kd9pul                        0x00005556441e0179 <unavailable> + 4473

    '
  stdout: ''
  timestamp: 1659979279
- exit_code: 0
  program: "\n/// Return sorted unique common elements for two arrays.\n/// >>> common(l1:\
    \ [1, 4, 3, 34, 653, 2, 5], l2: [5, 7, 1, 5, 9, 653, 121])\n/// [1, 5, 653]\n\
    /// >>> common(l1: [5, 3, 2, 8], l2: [3, 2])\n/// [2, 3]\nfunc common(l1: [Int],\
    \ l2: [Int]) -> [Int] {\n    var commonArray = [Int]()\n    var hashTable = [Int:\
    \ Int]()\n    \n    for i in l1 {\n        hashTable[i] = (hashTable[i] ?? 0)\
    \ + 1\n    }\n    \n    for i in l2 {\n        if hashTable[i] != nil {\n    \
    \        commonArray.append(i)\n            hashTable[i] = nil\n        }\n  \
    \  }\n    \n    return commonArray.sorted()\n}\n\n\nfunc ==(left: [(Int, Int)],\
    \ right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n       \
    \ return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r\
    \ {\n            return false\n        }\n    }\n    return true\n}\n        \
    \    \nassert(common(l1: [1, 4, 3, 34, 653, 2, 5], l2: [5, 7, 1, 5, 9, 653, 121])\
    \ == [1, 5, 653])\nassert(common(l1: [5, 3, 2, 8], l2: [3, 2]) == [2, 3])\nassert(common(l1:\
    \ [4, 3, 2, 8], l2: [3, 2, 4]) == [2, 3, 4])\nassert(common(l1: [4, 3, 2, 8],\
    \ l2: [] as [Int]) == [] as [Int])"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659979279
- exit_code: -4
  program: "\n/// Return sorted unique common elements for two arrays.\n/// >>> common(l1:\
    \ [1, 4, 3, 34, 653, 2, 5], l2: [5, 7, 1, 5, 9, 653, 121])\n/// [1, 5, 653]\n\
    /// >>> common(l1: [5, 3, 2, 8], l2: [3, 2])\n/// [2, 3]\nfunc common(l1: [Int],\
    \ l2: [Int]) -> [Int] {\n    return Array(Set(l1).intersection(Set(l2)))\n}\n\n\
    \nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(common(l1: [1, 4, 3, 34, 653, 2, 5], l2: [5, 7,\
    \ 1, 5, 9, 653, 121]) == [1, 5, 653])\nassert(common(l1: [5, 3, 2, 8], l2: [3,\
    \ 2]) == [2, 3])\nassert(common(l1: [4, 3, 2, 8], l2: [3, 2, 4]) == [2, 3, 4])\n\
    assert(common(l1: [4, 3, 2, 8], l2: [] as [Int]) == [] as [Int])"
  status: Exception
  stderr: 'tmpzxefsmhz/tmpzxefsmhz.swift:24: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b9cc80f7c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b9cc7deeb6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b9cc7dee988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b9cc7ded7b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpzxefsmhz                        0x0000564df22865fc <unavailable> + 5628

    5    libc.so.6                          0x00002b9cc82e3460 __libc_start_main +
    245

    6    tmpzxefsmhz                        0x0000564df2286179 <unavailable> + 4473

    '
  stdout: ''
  timestamp: 1659979279
- exit_code: 0
  program: "\n/// Return sorted unique common elements for two arrays.\n/// >>> common(l1:\
    \ [1, 4, 3, 34, 653, 2, 5], l2: [5, 7, 1, 5, 9, 653, 121])\n/// [1, 5, 653]\n\
    /// >>> common(l1: [5, 3, 2, 8], l2: [3, 2])\n/// [2, 3]\nfunc common(l1: [Int],\
    \ l2: [Int]) -> [Int] {\n    var common = Set(l1).intersection(Set(l2))\n    return\
    \ Array(common).sorted()\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(common(l1:\
    \ [1, 4, 3, 34, 653, 2, 5], l2: [5, 7, 1, 5, 9, 653, 121]) == [1, 5, 653])\nassert(common(l1:\
    \ [5, 3, 2, 8], l2: [3, 2]) == [2, 3])\nassert(common(l1: [4, 3, 2, 8], l2: [3,\
    \ 2, 4]) == [2, 3, 4])\nassert(common(l1: [4, 3, 2, 8], l2: [] as [Int]) == []\
    \ as [Int])"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659979279
- exit_code: 0
  program: "\n/// Return sorted unique common elements for two arrays.\n/// >>> common(l1:\
    \ [1, 4, 3, 34, 653, 2, 5], l2: [5, 7, 1, 5, 9, 653, 121])\n/// [1, 5, 653]\n\
    /// >>> common(l1: [5, 3, 2, 8], l2: [3, 2])\n/// [2, 3]\nfunc common(l1: [Int],\
    \ l2: [Int]) -> [Int] {\n    // Write your solution here\n    // return [1, 5,\
    \ 653]\n    var l1_sorted = l1.sorted()\n    var l2_sorted = l2.sorted()\n   \
    \ var result: [Int] = []\n    var i = 0\n    var j = 0\n    while i < l1_sorted.count\
    \ && j < l2_sorted.count {\n        if l1_sorted[i] == l2_sorted[j] {\n      \
    \      result.append(l1_sorted[i])\n            i += 1\n            j += 1\n \
    \       } else if l1_sorted[i] < l2_sorted[j] {\n            i += 1\n        }\
    \ else {\n            j += 1\n        }\n    }\n    return result\n}\n\n\nfunc\
    \ ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count !=\
    \ right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(common(l1: [1, 4, 3, 34, 653, 2, 5], l2: [5, 7,\
    \ 1, 5, 9, 653, 121]) == [1, 5, 653])\nassert(common(l1: [5, 3, 2, 8], l2: [3,\
    \ 2]) == [2, 3])\nassert(common(l1: [4, 3, 2, 8], l2: [3, 2, 4]) == [2, 3, 4])\n\
    assert(common(l1: [4, 3, 2, 8], l2: [] as [Int]) == [] as [Int])"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659979279
- exit_code: -4
  program: "\n/// Return sorted unique common elements for two arrays.\n/// >>> common(l1:\
    \ [1, 4, 3, 34, 653, 2, 5], l2: [5, 7, 1, 5, 9, 653, 121])\n/// [1, 5, 653]\n\
    /// >>> common(l1: [5, 3, 2, 8], l2: [3, 2])\n/// [2, 3]\nfunc common(l1: [Int],\
    \ l2: [Int]) -> [Int] {\n    return []\n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(common(l1: [1, 4, 3, 34, 653, 2, 5], l2: [5, 7, 1, 5, 9, 653, 121]) ==\
    \ [1, 5, 653])\nassert(common(l1: [5, 3, 2, 8], l2: [3, 2]) == [2, 3])\nassert(common(l1:\
    \ [4, 3, 2, 8], l2: [3, 2, 4]) == [2, 3, 4])\nassert(common(l1: [4, 3, 2, 8],\
    \ l2: [] as [Int]) == [] as [Int])"
  status: Exception
  stderr: 'tmpxe4ju921/tmpxe4ju921.swift:24: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b32fbf71c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b32fbc68b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b32fbc68988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b32fbc677b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpxe4ju921                        0x000055b04303844c <unavailable> + 5196

    5    libc.so.6                          0x00002b32fc15d460 __libc_start_main +
    245

    6    tmpxe4ju921                        0x000055b043037fc9 <unavailable> + 4041

    '
  stdout: ''
  timestamp: 1659979279
- exit_code: 0
  program: "\n/// Return sorted unique common elements for two arrays.\n/// >>> common(l1:\
    \ [1, 4, 3, 34, 653, 2, 5], l2: [5, 7, 1, 5, 9, 653, 121])\n/// [1, 5, 653]\n\
    /// >>> common(l1: [5, 3, 2, 8], l2: [3, 2])\n/// [2, 3]\nfunc common(l1: [Int],\
    \ l2: [Int]) -> [Int] {\n    let l1 = l1.sorted()\n    let l2 = l2.sorted()\n\
    \    var result = [Int]()\n    var i = 0\n    var j = 0\n    while i < l1.count\
    \ && j < l2.count {\n        if l1[i] < l2[j] {\n            i += 1\n        }\
    \ else if l1[i] > l2[j] {\n            j += 1\n        } else {\n            result.append(l1[i])\n\
    \            i += 1\n            j += 1\n        }\n    }\n    return result\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(common(l1: [1, 4, 3, 34, 653, 2, 5], l2: [5, 7,\
    \ 1, 5, 9, 653, 121]) == [1, 5, 653])\nassert(common(l1: [5, 3, 2, 8], l2: [3,\
    \ 2]) == [2, 3])\nassert(common(l1: [4, 3, 2, 8], l2: [3, 2, 4]) == [2, 3, 4])\n\
    assert(common(l1: [4, 3, 2, 8], l2: [] as [Int]) == [] as [Int])"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659979279
- exit_code: 1
  program: "\n/// Return sorted unique common elements for two arrays.\n/// >>> common(l1:\
    \ [1, 4, 3, 34, 653, 2, 5], l2: [5, 7, 1, 5, 9, 653, 121])\n/// [1, 5, 653]\n\
    /// >>> common(l1: [5, 3, 2, 8], l2: [3, 2])\n/// [2, 3]\nfunc common(l1: [Int],\
    \ l2: [Int]) -> [Int] {\n\treturn unique(l1: l1).filter({ l2.contains($0) })\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(common(l1: [1, 4, 3, 34, 653, 2, 5], l2: [5, 7,\
    \ 1, 5, 9, 653, 121]) == [1, 5, 653])\nassert(common(l1: [5, 3, 2, 8], l2: [3,\
    \ 2]) == [2, 3])\nassert(common(l1: [4, 3, 2, 8], l2: [3, 2, 4]) == [2, 3, 4])\n\
    assert(common(l1: [4, 3, 2, 8], l2: [] as [Int]) == [] as [Int])"
  status: SyntaxError
  stderr: "/tmp/tmp1u7xmle9.swift:8:9: error: cannot find 'unique' in scope\n    \
    \    return unique(l1: l1).filter({ l2.contains($0) })\n               ^~~~~~\n"
  stdout: ''
  timestamp: 1659979278
- exit_code: -4
  program: "\n/// Return sorted unique common elements for two arrays.\n/// >>> common(l1:\
    \ [1, 4, 3, 34, 653, 2, 5], l2: [5, 7, 1, 5, 9, 653, 121])\n/// [1, 5, 653]\n\
    /// >>> common(l1: [5, 3, 2, 8], l2: [3, 2])\n/// [2, 3]\nfunc common(l1: [Int],\
    \ l2: [Int]) -> [Int] {\n    return Array(Set(l1).intersection(Set(l2)))\n}\n\n\
    \nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(common(l1: [1, 4, 3, 34, 653, 2, 5], l2: [5, 7,\
    \ 1, 5, 9, 653, 121]) == [1, 5, 653])\nassert(common(l1: [5, 3, 2, 8], l2: [3,\
    \ 2]) == [2, 3])\nassert(common(l1: [4, 3, 2, 8], l2: [3, 2, 4]) == [2, 3, 4])\n\
    assert(common(l1: [4, 3, 2, 8], l2: [] as [Int]) == [] as [Int])"
  status: Exception
  stderr: 'tmpzxefsmhz/tmpzxefsmhz.swift:24: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b9cc80f7c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b9cc7deeb6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b9cc7dee988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b9cc7ded7b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpzxefsmhz                        0x0000564df22865fc <unavailable> + 5628

    5    libc.so.6                          0x00002b9cc82e3460 __libc_start_main +
    245

    6    tmpzxefsmhz                        0x0000564df2286179 <unavailable> + 4473

    '
  stdout: ''
  timestamp: 1659979279
- exit_code: 1
  program: "\n/// Return sorted unique common elements for two arrays.\n/// >>> common(l1:\
    \ [1, 4, 3, 34, 653, 2, 5], l2: [5, 7, 1, 5, 9, 653, 121])\n/// [1, 5, 653]\n\
    /// >>> common(l1: [5, 3, 2, 8], l2: [3, 2])\n/// [2, 3]\nfunc common(l1: [Int],\
    \ l2: [Int]) -> [Int] {\n  return l1.unique().filter({\n    l2.unique().contains($0)\n\
    \  })\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n   \
    \ if left.count != right.count {\n        return false\n    }\n    for (l, r)\
    \ in zip(left, right) {\n        if l != r {\n            return false\n     \
    \   }\n    }\n    return true\n}\n            \nassert(common(l1: [1, 4, 3, 34,\
    \ 653, 2, 5], l2: [5, 7, 1, 5, 9, 653, 121]) == [1, 5, 653])\nassert(common(l1:\
    \ [5, 3, 2, 8], l2: [3, 2]) == [2, 3])\nassert(common(l1: [4, 3, 2, 8], l2: [3,\
    \ 2, 4]) == [2, 3, 4])\nassert(common(l1: [4, 3, 2, 8], l2: [] as [Int]) == []\
    \ as [Int])"
  status: SyntaxError
  stderr: "/tmp/tmpu32ybfus.swift:8:13: error: value of type '[Int]' has no member\
    \ 'unique'\n  return l1.unique().filter({\n         ~~ ^~~~~~\n/tmp/tmpu32ybfus.swift:9:8:\
    \ error: value of type '[Int]' has no member 'unique'\n    l2.unique().contains($0)\n\
    \    ~~ ^~~~~~\n"
  stdout: ''
  timestamp: 1659979278
- exit_code: 0
  program: "\n/// Return sorted unique common elements for two arrays.\n/// >>> common(l1:\
    \ [1, 4, 3, 34, 653, 2, 5], l2: [5, 7, 1, 5, 9, 653, 121])\n/// [1, 5, 653]\n\
    /// >>> common(l1: [5, 3, 2, 8], l2: [3, 2])\n/// [2, 3]\nfunc common(l1: [Int],\
    \ l2: [Int]) -> [Int] {\n    let set1 = Set(l1)\n    let set2 = Set(l2)\n    return\
    \ Array(set1.intersection(set2)).sorted()\n}\n\n\nfunc ==(left: [(Int, Int)],\
    \ right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n       \
    \ return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r\
    \ {\n            return false\n        }\n    }\n    return true\n}\n        \
    \    \nassert(common(l1: [1, 4, 3, 34, 653, 2, 5], l2: [5, 7, 1, 5, 9, 653, 121])\
    \ == [1, 5, 653])\nassert(common(l1: [5, 3, 2, 8], l2: [3, 2]) == [2, 3])\nassert(common(l1:\
    \ [4, 3, 2, 8], l2: [3, 2, 4]) == [2, 3, 4])\nassert(common(l1: [4, 3, 2, 8],\
    \ l2: [] as [Int]) == [] as [Int])"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659979279
- exit_code: 0
  program: "\n/// Return sorted unique common elements for two arrays.\n/// >>> common(l1:\
    \ [1, 4, 3, 34, 653, 2, 5], l2: [5, 7, 1, 5, 9, 653, 121])\n/// [1, 5, 653]\n\
    /// >>> common(l1: [5, 3, 2, 8], l2: [3, 2])\n/// [2, 3]\nfunc common(l1: [Int],\
    \ l2: [Int]) -> [Int] {\n    return Set(l1).intersection(Set(l2)).sorted()\n}\n\
    \n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(common(l1: [1, 4, 3, 34, 653, 2, 5], l2: [5, 7,\
    \ 1, 5, 9, 653, 121]) == [1, 5, 653])\nassert(common(l1: [5, 3, 2, 8], l2: [3,\
    \ 2]) == [2, 3])\nassert(common(l1: [4, 3, 2, 8], l2: [3, 2, 4]) == [2, 3, 4])\n\
    assert(common(l1: [4, 3, 2, 8], l2: [] as [Int]) == [] as [Int])"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659979279
- exit_code: -4
  program: "\n/// Return sorted unique common elements for two arrays.\n/// >>> common(l1:\
    \ [1, 4, 3, 34, 653, 2, 5], l2: [5, 7, 1, 5, 9, 653, 121])\n/// [1, 5, 653]\n\
    /// >>> common(l1: [5, 3, 2, 8], l2: [3, 2])\n/// [2, 3]\nfunc common(l1: [Int],\
    \ l2: [Int]) -> [Int] {\n    var r = [Int]()\n    var ll1 = l1\n    var ll2 =\
    \ l2\n    for i in ll1 {\n        for j in ll2 {\n            if i == j {\n  \
    \              r.append(i)\n                ll1.remove(at: ll1.index(of: i)!)\n\
    \                ll2.remove(at: ll2.index(of: j)!)\n            }\n        }\n\
    \    }\n    return r.sorted()\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int,\
    \ Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n\
    \    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n          \
    \  return false\n        }\n    }\n    return true\n}\n            \nassert(common(l1:\
    \ [1, 4, 3, 34, 653, 2, 5], l2: [5, 7, 1, 5, 9, 653, 121]) == [1, 5, 653])\nassert(common(l1:\
    \ [5, 3, 2, 8], l2: [3, 2]) == [2, 3])\nassert(common(l1: [4, 3, 2, 8], l2: [3,\
    \ 2, 4]) == [2, 3, 4])\nassert(common(l1: [4, 3, 2, 8], l2: [] as [Int]) == []\
    \ as [Int])"
  status: Exception
  stderr: 'tmpi3h23nf4/tmpi3h23nf4.swift:15: Fatal error: Unexpectedly found nil while
    unwrapping an Optional value

    Current stack trace:

    0    libswiftCore.so                    0x00002adee5c99c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002adee5990561 <unavailable> + 1434977

    2    libswiftCore.so                    0x00002adee5990286 <unavailable> + 1434246

    3    libswiftCore.so                    0x00002adee599013c <unavailable> + 1433916

    4    libswiftCore.so                    0x00002adee598fbb0 _assertionFailure(_:_:file:line:flags:)
    + 251

    5    tmpi3h23nf4                        0x000055a699e63049 <unavailable> + 8265

    6    tmpi3h23nf4                        0x000055a699e62783 <unavailable> + 6019

    7    libc.so.6                          0x00002adee5e85460 __libc_start_main +
    245

    8    tmpi3h23nf4                        0x000055a699e623e9 <unavailable> + 5097

    '
  stdout: ''
  timestamp: 1659979279
- exit_code: 0
  program: "\n/// Return sorted unique common elements for two arrays.\n/// >>> common(l1:\
    \ [1, 4, 3, 34, 653, 2, 5], l2: [5, 7, 1, 5, 9, 653, 121])\n/// [1, 5, 653]\n\
    /// >>> common(l1: [5, 3, 2, 8], l2: [3, 2])\n/// [2, 3]\nfunc common(l1: [Int],\
    \ l2: [Int]) -> [Int] {\n    return Set(l1).intersection(Set(l2)).sorted()\n}\n\
    \n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(common(l1: [1, 4, 3, 34, 653, 2, 5], l2: [5, 7,\
    \ 1, 5, 9, 653, 121]) == [1, 5, 653])\nassert(common(l1: [5, 3, 2, 8], l2: [3,\
    \ 2]) == [2, 3])\nassert(common(l1: [4, 3, 2, 8], l2: [3, 2, 4]) == [2, 3, 4])\n\
    assert(common(l1: [4, 3, 2, 8], l2: [] as [Int]) == [] as [Int])"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659979279
- exit_code: -4
  program: "\n/// Return sorted unique common elements for two arrays.\n/// >>> common(l1:\
    \ [1, 4, 3, 34, 653, 2, 5], l2: [5, 7, 1, 5, 9, 653, 121])\n/// [1, 5, 653]\n\
    /// >>> common(l1: [5, 3, 2, 8], l2: [3, 2])\n/// [2, 3]\nfunc common(l1: [Int],\
    \ l2: [Int]) -> [Int] {\n    return Array(Set(l1).intersection(Set(l2)))\n}\n\n\
    \nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(common(l1: [1, 4, 3, 34, 653, 2, 5], l2: [5, 7,\
    \ 1, 5, 9, 653, 121]) == [1, 5, 653])\nassert(common(l1: [5, 3, 2, 8], l2: [3,\
    \ 2]) == [2, 3])\nassert(common(l1: [4, 3, 2, 8], l2: [3, 2, 4]) == [2, 3, 4])\n\
    assert(common(l1: [4, 3, 2, 8], l2: [] as [Int]) == [] as [Int])"
  status: Exception
  stderr: 'tmpzxefsmhz/tmpzxefsmhz.swift:24: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b9cc80f7c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b9cc7deeb6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b9cc7dee988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b9cc7ded7b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpzxefsmhz                        0x0000564df22865fc <unavailable> + 5628

    5    libc.so.6                          0x00002b9cc82e3460 __libc_start_main +
    245

    6    tmpzxefsmhz                        0x0000564df2286179 <unavailable> + 4473

    '
  stdout: ''
  timestamp: 1659979279
- exit_code: 0
  program: "\n/// Return sorted unique common elements for two arrays.\n/// >>> common(l1:\
    \ [1, 4, 3, 34, 653, 2, 5], l2: [5, 7, 1, 5, 9, 653, 121])\n/// [1, 5, 653]\n\
    /// >>> common(l1: [5, 3, 2, 8], l2: [3, 2])\n/// [2, 3]\nfunc common(l1: [Int],\
    \ l2: [Int]) -> [Int] {\n    var s1 = Set(l1)\n    var s2 = Set(l2)\n    s1.formIntersection(s2)\n\
    \    return Array(s1).sorted()\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int,\
    \ Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n\
    \    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n          \
    \  return false\n        }\n    }\n    return true\n}\n            \nassert(common(l1:\
    \ [1, 4, 3, 34, 653, 2, 5], l2: [5, 7, 1, 5, 9, 653, 121]) == [1, 5, 653])\nassert(common(l1:\
    \ [5, 3, 2, 8], l2: [3, 2]) == [2, 3])\nassert(common(l1: [4, 3, 2, 8], l2: [3,\
    \ 2, 4]) == [2, 3, 4])\nassert(common(l1: [4, 3, 2, 8], l2: [] as [Int]) == []\
    \ as [Int])"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659979279
- exit_code: 0
  program: "\n/// Return sorted unique common elements for two arrays.\n/// >>> common(l1:\
    \ [1, 4, 3, 34, 653, 2, 5], l2: [5, 7, 1, 5, 9, 653, 121])\n/// [1, 5, 653]\n\
    /// >>> common(l1: [5, 3, 2, 8], l2: [3, 2])\n/// [2, 3]\nfunc common(l1: [Int],\
    \ l2: [Int]) -> [Int] {\n    let set = Set(l1).intersection(Set(l2))\n    return\
    \ Array(set).sorted()\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(common(l1:\
    \ [1, 4, 3, 34, 653, 2, 5], l2: [5, 7, 1, 5, 9, 653, 121]) == [1, 5, 653])\nassert(common(l1:\
    \ [5, 3, 2, 8], l2: [3, 2]) == [2, 3])\nassert(common(l1: [4, 3, 2, 8], l2: [3,\
    \ 2, 4]) == [2, 3, 4])\nassert(common(l1: [4, 3, 2, 8], l2: [] as [Int]) == []\
    \ as [Int])"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659979279
- exit_code: 0
  program: "\n/// Return sorted unique common elements for two arrays.\n/// >>> common(l1:\
    \ [1, 4, 3, 34, 653, 2, 5], l2: [5, 7, 1, 5, 9, 653, 121])\n/// [1, 5, 653]\n\
    /// >>> common(l1: [5, 3, 2, 8], l2: [3, 2])\n/// [2, 3]\nfunc common(l1: [Int],\
    \ l2: [Int]) -> [Int] {\n    var t = l1\n    t.append(contentsOf: l2)\n    let\
    \ l3 = t.sorted()\n    var c: [Int] = []\n    var i = 0\n    while i < l3.count\
    \ - 1 {\n        if l3[i] == l3[i + 1] {\n            c.append(l3[i])\n      \
    \      i += 1\n        }\n        i += 1\n    }\n    return c\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(common(l1: [1, 4, 3, 34, 653, 2, 5], l2: [5, 7, 1, 5,\
    \ 9, 653, 121]) == [1, 5, 653])\nassert(common(l1: [5, 3, 2, 8], l2: [3, 2]) ==\
    \ [2, 3])\nassert(common(l1: [4, 3, 2, 8], l2: [3, 2, 4]) == [2, 3, 4])\nassert(common(l1:\
    \ [4, 3, 2, 8], l2: [] as [Int]) == [] as [Int])"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659979279
- exit_code: 0
  program: "\n/// Return sorted unique common elements for two arrays.\n/// >>> common(l1:\
    \ [1, 4, 3, 34, 653, 2, 5], l2: [5, 7, 1, 5, 9, 653, 121])\n/// [1, 5, 653]\n\
    /// >>> common(l1: [5, 3, 2, 8], l2: [3, 2])\n/// [2, 3]\nfunc common(l1: [Int],\
    \ l2: [Int]) -> [Int] {\n    var uniqueList1 = [Int]()\n    var uniqueList2 =\
    \ [Int]()\n    var result = [Int]()\n    \n    for i in l1 {\n        if !uniqueList1.contains(i)\
    \ {\n            uniqueList1.append(i)\n        }\n    }\n    \n    for i in l2\
    \ {\n        if !uniqueList2.contains(i) {\n            uniqueList2.append(i)\n\
    \        }\n    }\n    \n    for i in uniqueList1 {\n        if uniqueList2.contains(i)\
    \ {\n            result.append(i)\n        }\n    }\n    \n    return result.sorted()\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(common(l1: [1, 4, 3, 34, 653, 2, 5], l2: [5, 7,\
    \ 1, 5, 9, 653, 121]) == [1, 5, 653])\nassert(common(l1: [5, 3, 2, 8], l2: [3,\
    \ 2]) == [2, 3])\nassert(common(l1: [4, 3, 2, 8], l2: [3, 2, 4]) == [2, 3, 4])\n\
    assert(common(l1: [4, 3, 2, 8], l2: [] as [Int]) == [] as [Int])"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659979279
- exit_code: -4
  program: "\n/// Return sorted unique common elements for two arrays.\n/// >>> common(l1:\
    \ [1, 4, 3, 34, 653, 2, 5], l2: [5, 7, 1, 5, 9, 653, 121])\n/// [1, 5, 653]\n\
    /// >>> common(l1: [5, 3, 2, 8], l2: [3, 2])\n/// [2, 3]\nfunc common(l1: [Int],\
    \ l2: [Int]) -> [Int] {\n    return Array(Set(l1).intersection(Set(l2)))\n}\n\n\
    \nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(common(l1: [1, 4, 3, 34, 653, 2, 5], l2: [5, 7,\
    \ 1, 5, 9, 653, 121]) == [1, 5, 653])\nassert(common(l1: [5, 3, 2, 8], l2: [3,\
    \ 2]) == [2, 3])\nassert(common(l1: [4, 3, 2, 8], l2: [3, 2, 4]) == [2, 3, 4])\n\
    assert(common(l1: [4, 3, 2, 8], l2: [] as [Int]) == [] as [Int])"
  status: Exception
  stderr: 'tmpzxefsmhz/tmpzxefsmhz.swift:24: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b9cc80f7c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b9cc7deeb6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b9cc7dee988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b9cc7ded7b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpzxefsmhz                        0x0000564df22865fc <unavailable> + 5628

    5    libc.so.6                          0x00002b9cc82e3460 __libc_start_main +
    245

    6    tmpzxefsmhz                        0x0000564df2286179 <unavailable> + 4473

    '
  stdout: ''
  timestamp: 1659979279
- exit_code: 0
  program: "\n/// Return sorted unique common elements for two arrays.\n/// >>> common(l1:\
    \ [1, 4, 3, 34, 653, 2, 5], l2: [5, 7, 1, 5, 9, 653, 121])\n/// [1, 5, 653]\n\
    /// >>> common(l1: [5, 3, 2, 8], l2: [3, 2])\n/// [2, 3]\nfunc common(l1: [Int],\
    \ l2: [Int]) -> [Int] {\n    return l1.filter { l2.contains($0) }.sorted()\n}\n\
    \n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(common(l1: [1, 4, 3, 34, 653, 2, 5], l2: [5, 7,\
    \ 1, 5, 9, 653, 121]) == [1, 5, 653])\nassert(common(l1: [5, 3, 2, 8], l2: [3,\
    \ 2]) == [2, 3])\nassert(common(l1: [4, 3, 2, 8], l2: [3, 2, 4]) == [2, 3, 4])\n\
    assert(common(l1: [4, 3, 2, 8], l2: [] as [Int]) == [] as [Int])"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659979279
- exit_code: -4
  program: "\n/// Return sorted unique common elements for two arrays.\n/// >>> common(l1:\
    \ [1, 4, 3, 34, 653, 2, 5], l2: [5, 7, 1, 5, 9, 653, 121])\n/// [1, 5, 653]\n\
    /// >>> common(l1: [5, 3, 2, 8], l2: [3, 2])\n/// [2, 3]\nfunc common(l1: [Int],\
    \ l2: [Int]) -> [Int] {\n    return Array(Set(l1).intersection(Set(l2)))\n}\n\n\
    \nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(common(l1: [1, 4, 3, 34, 653, 2, 5], l2: [5, 7,\
    \ 1, 5, 9, 653, 121]) == [1, 5, 653])\nassert(common(l1: [5, 3, 2, 8], l2: [3,\
    \ 2]) == [2, 3])\nassert(common(l1: [4, 3, 2, 8], l2: [3, 2, 4]) == [2, 3, 4])\n\
    assert(common(l1: [4, 3, 2, 8], l2: [] as [Int]) == [] as [Int])"
  status: Exception
  stderr: 'tmpzxefsmhz/tmpzxefsmhz.swift:24: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b9cc80f7c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b9cc7deeb6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b9cc7dee988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b9cc7ded7b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpzxefsmhz                        0x0000564df22865fc <unavailable> + 5628

    5    libc.so.6                          0x00002b9cc82e3460 __libc_start_main +
    245

    6    tmpzxefsmhz                        0x0000564df2286179 <unavailable> + 4473

    '
  stdout: ''
  timestamp: 1659979279
- exit_code: 0
  program: "\n/// Return sorted unique common elements for two arrays.\n/// >>> common(l1:\
    \ [1, 4, 3, 34, 653, 2, 5], l2: [5, 7, 1, 5, 9, 653, 121])\n/// [1, 5, 653]\n\
    /// >>> common(l1: [5, 3, 2, 8], l2: [3, 2])\n/// [2, 3]\nfunc common(l1: [Int],\
    \ l2: [Int]) -> [Int] {\n    let set1 = Set(l1)\n    let set2 = Set(l2)\n    return\
    \ Array(set1.intersection(set2)).sorted()\n}\n\n\nfunc ==(left: [(Int, Int)],\
    \ right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n       \
    \ return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r\
    \ {\n            return false\n        }\n    }\n    return true\n}\n        \
    \    \nassert(common(l1: [1, 4, 3, 34, 653, 2, 5], l2: [5, 7, 1, 5, 9, 653, 121])\
    \ == [1, 5, 653])\nassert(common(l1: [5, 3, 2, 8], l2: [3, 2]) == [2, 3])\nassert(common(l1:\
    \ [4, 3, 2, 8], l2: [3, 2, 4]) == [2, 3, 4])\nassert(common(l1: [4, 3, 2, 8],\
    \ l2: [] as [Int]) == [] as [Int])"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659979279
- exit_code: 0
  program: "\n/// Return sorted unique common elements for two arrays.\n/// >>> common(l1:\
    \ [1, 4, 3, 34, 653, 2, 5], l2: [5, 7, 1, 5, 9, 653, 121])\n/// [1, 5, 653]\n\
    /// >>> common(l1: [5, 3, 2, 8], l2: [3, 2])\n/// [2, 3]\nfunc common(l1: [Int],\
    \ l2: [Int]) -> [Int] {\n    let set1 = Set(l1)\n    let set2 = Set(l2)\n    return\
    \ Array(set1.intersection(set2)).sorted()\n}\n\n\nfunc ==(left: [(Int, Int)],\
    \ right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n       \
    \ return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r\
    \ {\n            return false\n        }\n    }\n    return true\n}\n        \
    \    \nassert(common(l1: [1, 4, 3, 34, 653, 2, 5], l2: [5, 7, 1, 5, 9, 653, 121])\
    \ == [1, 5, 653])\nassert(common(l1: [5, 3, 2, 8], l2: [3, 2]) == [2, 3])\nassert(common(l1:\
    \ [4, 3, 2, 8], l2: [3, 2, 4]) == [2, 3, 4])\nassert(common(l1: [4, 3, 2, 8],\
    \ l2: [] as [Int]) == [] as [Int])"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659979279
- exit_code: 0
  program: "\n/// Return sorted unique common elements for two arrays.\n/// >>> common(l1:\
    \ [1, 4, 3, 34, 653, 2, 5], l2: [5, 7, 1, 5, 9, 653, 121])\n/// [1, 5, 653]\n\
    /// >>> common(l1: [5, 3, 2, 8], l2: [3, 2])\n/// [2, 3]\nfunc common(l1: [Int],\
    \ l2: [Int]) -> [Int] {\n    var l3 = Set(l1)\n    var l4 = Set(l2)\n    l3.formIntersection(l4)\n\
    \    return Array(l3).sorted()\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int,\
    \ Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n\
    \    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n          \
    \  return false\n        }\n    }\n    return true\n}\n            \nassert(common(l1:\
    \ [1, 4, 3, 34, 653, 2, 5], l2: [5, 7, 1, 5, 9, 653, 121]) == [1, 5, 653])\nassert(common(l1:\
    \ [5, 3, 2, 8], l2: [3, 2]) == [2, 3])\nassert(common(l1: [4, 3, 2, 8], l2: [3,\
    \ 2, 4]) == [2, 3, 4])\nassert(common(l1: [4, 3, 2, 8], l2: [] as [Int]) == []\
    \ as [Int])"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659979279
- exit_code: 0
  program: "\n/// Return sorted unique common elements for two arrays.\n/// >>> common(l1:\
    \ [1, 4, 3, 34, 653, 2, 5], l2: [5, 7, 1, 5, 9, 653, 121])\n/// [1, 5, 653]\n\
    /// >>> common(l1: [5, 3, 2, 8], l2: [3, 2])\n/// [2, 3]\nfunc common(l1: [Int],\
    \ l2: [Int]) -> [Int] {\n    return Array(Set(l1).intersection(Set(l2))).sorted()\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(common(l1: [1, 4, 3, 34, 653, 2, 5], l2: [5, 7,\
    \ 1, 5, 9, 653, 121]) == [1, 5, 653])\nassert(common(l1: [5, 3, 2, 8], l2: [3,\
    \ 2]) == [2, 3])\nassert(common(l1: [4, 3, 2, 8], l2: [3, 2, 4]) == [2, 3, 4])\n\
    assert(common(l1: [4, 3, 2, 8], l2: [] as [Int]) == [] as [Int])"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659979279
- exit_code: -4
  program: "\n/// Return sorted unique common elements for two arrays.\n/// >>> common(l1:\
    \ [1, 4, 3, 34, 653, 2, 5], l2: [5, 7, 1, 5, 9, 653, 121])\n/// [1, 5, 653]\n\
    /// >>> common(l1: [5, 3, 2, 8], l2: [3, 2])\n/// [2, 3]\nfunc common(l1: [Int],\
    \ l2: [Int]) -> [Int] {\n    return []\n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(common(l1: [1, 4, 3, 34, 653, 2, 5], l2: [5, 7, 1, 5, 9, 653, 121]) ==\
    \ [1, 5, 653])\nassert(common(l1: [5, 3, 2, 8], l2: [3, 2]) == [2, 3])\nassert(common(l1:\
    \ [4, 3, 2, 8], l2: [3, 2, 4]) == [2, 3, 4])\nassert(common(l1: [4, 3, 2, 8],\
    \ l2: [] as [Int]) == [] as [Int])"
  status: Exception
  stderr: 'tmpxe4ju921/tmpxe4ju921.swift:24: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b32fbf71c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b32fbc68b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b32fbc68988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b32fbc677b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpxe4ju921                        0x000055b04303844c <unavailable> + 5196

    5    libc.so.6                          0x00002b32fc15d460 __libc_start_main +
    245

    6    tmpxe4ju921                        0x000055b043037fc9 <unavailable> + 4041

    '
  stdout: ''
  timestamp: 1659979279
- exit_code: -4
  program: "\n/// Return sorted unique common elements for two arrays.\n/// >>> common(l1:\
    \ [1, 4, 3, 34, 653, 2, 5], l2: [5, 7, 1, 5, 9, 653, 121])\n/// [1, 5, 653]\n\
    /// >>> common(l1: [5, 3, 2, 8], l2: [3, 2])\n/// [2, 3]\nfunc common(l1: [Int],\
    \ l2: [Int]) -> [Int] {\n    let count1 = l1.count\n    let count2 = l2.count\n\
    \    var sortArr = [Int]()\n    var result = [Int]()\n    var i = 0\n    var j\
    \ = 0\n    while i < count1 && j < count2 {\n        if l1[i] == l2[j] {\n   \
    \         sortArr.append(l1[i])\n            i += 1\n            j += 1\n    \
    \    } else if l1[i] < l2[j] {\n            i += 1\n        } else {\n       \
    \     j += 1\n        }\n    }\n    if sortArr.count == 0 {\n        return result\n\
    \    }\n    var res = sortArr[0]\n    result.append(res)\n    for item in sortArr\
    \ {\n        if item == res {\n            continue\n        }\n        result.append(item)\n\
    \        res = item\n    }\n    return result\n}\n\n\nfunc ==(left: [(Int, Int)],\
    \ right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n       \
    \ return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r\
    \ {\n            return false\n        }\n    }\n    return true\n}\n        \
    \    \nassert(common(l1: [1, 4, 3, 34, 653, 2, 5], l2: [5, 7, 1, 5, 9, 653, 121])\
    \ == [1, 5, 653])\nassert(common(l1: [5, 3, 2, 8], l2: [3, 2]) == [2, 3])\nassert(common(l1:\
    \ [4, 3, 2, 8], l2: [3, 2, 4]) == [2, 3, 4])\nassert(common(l1: [4, 3, 2, 8],\
    \ l2: [] as [Int]) == [] as [Int])"
  status: Exception
  stderr: 'tmp_37q7gtz/tmp_37q7gtz.swift:53: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b397ef5bc80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b397ec52b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b397ec52988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b397ec517b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmp_37q7gtz                        0x0000560ebc74771c <unavailable> + 5916

    5    libc.so.6                          0x00002b397f147460 __libc_start_main +
    245

    6    tmp_37q7gtz                        0x0000560ebc747299 <unavailable> + 4761

    '
  stdout: ''
  timestamp: 1659979279
- exit_code: -4
  program: "\n/// Return sorted unique common elements for two arrays.\n/// >>> common(l1:\
    \ [1, 4, 3, 34, 653, 2, 5], l2: [5, 7, 1, 5, 9, 653, 121])\n/// [1, 5, 653]\n\
    /// >>> common(l1: [5, 3, 2, 8], l2: [3, 2])\n/// [2, 3]\nfunc common(l1: [Int],\
    \ l2: [Int]) -> [Int] {\n    return Array(Set(l1).intersection(Set(l2)))\n}\n\n\
    \nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(common(l1: [1, 4, 3, 34, 653, 2, 5], l2: [5, 7,\
    \ 1, 5, 9, 653, 121]) == [1, 5, 653])\nassert(common(l1: [5, 3, 2, 8], l2: [3,\
    \ 2]) == [2, 3])\nassert(common(l1: [4, 3, 2, 8], l2: [3, 2, 4]) == [2, 3, 4])\n\
    assert(common(l1: [4, 3, 2, 8], l2: [] as [Int]) == [] as [Int])"
  status: Exception
  stderr: 'tmpzxefsmhz/tmpzxefsmhz.swift:24: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b9cc80f7c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b9cc7deeb6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b9cc7dee988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b9cc7ded7b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpzxefsmhz                        0x0000564df22865fc <unavailable> + 5628

    5    libc.so.6                          0x00002b9cc82e3460 __libc_start_main +
    245

    6    tmpzxefsmhz                        0x0000564df2286179 <unavailable> + 4473

    '
  stdout: ''
  timestamp: 1659979279
- exit_code: -4
  program: "\n/// Return sorted unique common elements for two arrays.\n/// >>> common(l1:\
    \ [1, 4, 3, 34, 653, 2, 5], l2: [5, 7, 1, 5, 9, 653, 121])\n/// [1, 5, 653]\n\
    /// >>> common(l1: [5, 3, 2, 8], l2: [3, 2])\n/// [2, 3]\nfunc common(l1: [Int],\
    \ l2: [Int]) -> [Int] {\n    return Array(Set(l1).intersection(Set(l2)))\n}\n\n\
    \nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(common(l1: [1, 4, 3, 34, 653, 2, 5], l2: [5, 7,\
    \ 1, 5, 9, 653, 121]) == [1, 5, 653])\nassert(common(l1: [5, 3, 2, 8], l2: [3,\
    \ 2]) == [2, 3])\nassert(common(l1: [4, 3, 2, 8], l2: [3, 2, 4]) == [2, 3, 4])\n\
    assert(common(l1: [4, 3, 2, 8], l2: [] as [Int]) == [] as [Int])"
  status: Exception
  stderr: 'tmpzxefsmhz/tmpzxefsmhz.swift:24: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b9cc80f7c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b9cc7deeb6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b9cc7dee988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b9cc7ded7b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpzxefsmhz                        0x0000564df22865fc <unavailable> + 5628

    5    libc.so.6                          0x00002b9cc82e3460 __libc_start_main +
    245

    6    tmpzxefsmhz                        0x0000564df2286179 <unavailable> + 4473

    '
  stdout: ''
  timestamp: 1659979279
- exit_code: 1
  program: "\n/// Return sorted unique common elements for two arrays.\n/// >>> common(l1:\
    \ [1, 4, 3, 34, 653, 2, 5], l2: [5, 7, 1, 5, 9, 653, 121])\n/// [1, 5, 653]\n\
    /// >>> common(l1: [5, 3, 2, 8], l2: [3, 2])\n/// [2, 3]\nfunc common(l1: [Int],\
    \ l2: [Int]) -> [Int] {\n    var result = [Int]()\n    for i in l1 {\n       \
    \ for j in l2 {\n            if (i == j) {\n                result.append(i)\n\
    \            }\n        }\n    }\n    return result.sort()\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(common(l1: [1, 4, 3, 34, 653, 2, 5], l2: [5, 7, 1, 5,\
    \ 9, 653, 121]) == [1, 5, 653])\nassert(common(l1: [5, 3, 2, 8], l2: [3, 2]) ==\
    \ [2, 3])\nassert(common(l1: [4, 3, 2, 8], l2: [3, 2, 4]) == [2, 3, 4])\nassert(common(l1:\
    \ [4, 3, 2, 8], l2: [] as [Int]) == [] as [Int])"
  status: SyntaxError
  stderr: "/tmp/tmpzgr244bn.swift:16:19: error: cannot convert return expression of\
    \ type '()' to return type '[Int]'\n    return result.sort()\n           ~~~~~~~^~~~~~\n"
  stdout: ''
  timestamp: 1659979279
- exit_code: 0
  program: "\n/// Return sorted unique common elements for two arrays.\n/// >>> common(l1:\
    \ [1, 4, 3, 34, 653, 2, 5], l2: [5, 7, 1, 5, 9, 653, 121])\n/// [1, 5, 653]\n\
    /// >>> common(l1: [5, 3, 2, 8], l2: [3, 2])\n/// [2, 3]\nfunc common(l1: [Int],\
    \ l2: [Int]) -> [Int] {\n    let set1 = Set(l1)\n    let set2 = Set(l2)\n    return\
    \ Array(set1.intersection(set2)).sorted()\n}\n\n\nfunc ==(left: [(Int, Int)],\
    \ right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n       \
    \ return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r\
    \ {\n            return false\n        }\n    }\n    return true\n}\n        \
    \    \nassert(common(l1: [1, 4, 3, 34, 653, 2, 5], l2: [5, 7, 1, 5, 9, 653, 121])\
    \ == [1, 5, 653])\nassert(common(l1: [5, 3, 2, 8], l2: [3, 2]) == [2, 3])\nassert(common(l1:\
    \ [4, 3, 2, 8], l2: [3, 2, 4]) == [2, 3, 4])\nassert(common(l1: [4, 3, 2, 8],\
    \ l2: [] as [Int]) == [] as [Int])"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659979279
- exit_code: 0
  program: "\n/// Return sorted unique common elements for two arrays.\n/// >>> common(l1:\
    \ [1, 4, 3, 34, 653, 2, 5], l2: [5, 7, 1, 5, 9, 653, 121])\n/// [1, 5, 653]\n\
    /// >>> common(l1: [5, 3, 2, 8], l2: [3, 2])\n/// [2, 3]\nfunc common(l1: [Int],\
    \ l2: [Int]) -> [Int] {\n    return Set(l1).intersection(Set(l2)).sorted()\n}\n\
    \n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(common(l1: [1, 4, 3, 34, 653, 2, 5], l2: [5, 7,\
    \ 1, 5, 9, 653, 121]) == [1, 5, 653])\nassert(common(l1: [5, 3, 2, 8], l2: [3,\
    \ 2]) == [2, 3])\nassert(common(l1: [4, 3, 2, 8], l2: [3, 2, 4]) == [2, 3, 4])\n\
    assert(common(l1: [4, 3, 2, 8], l2: [] as [Int]) == [] as [Int])"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659979279
- exit_code: 1
  program: "\n/// Return sorted unique common elements for two arrays.\n/// >>> common(l1:\
    \ [1, 4, 3, 34, 653, 2, 5], l2: [5, 7, 1, 5, 9, 653, 121])\n/// [1, 5, 653]\n\
    /// >>> common(l1: [5, 3, 2, 8], l2: [3, 2])\n/// [2, 3]\nfunc common(l1: [Int],\
    \ l2: [Int]) -> [Int] {\n    let sortedL1 = l1.sorted()\n    let sortedL2 = l2.sorted()\n\
    \    let uniqueL1 = sortedL1.unique()\n    let uniqueL2 = sortedL2.unique()\n\
    \    let set1 = Set(uniqueL1)\n    let set2 = Set(uniqueL2)\n    return Array(set1.intersection(set2))\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(common(l1: [1, 4, 3, 34, 653, 2, 5], l2: [5, 7,\
    \ 1, 5, 9, 653, 121]) == [1, 5, 653])\nassert(common(l1: [5, 3, 2, 8], l2: [3,\
    \ 2]) == [2, 3])\nassert(common(l1: [4, 3, 2, 8], l2: [3, 2, 4]) == [2, 3, 4])\n\
    assert(common(l1: [4, 3, 2, 8], l2: [] as [Int]) == [] as [Int])"
  status: SyntaxError
  stderr: "/tmp/tmpe_du_sxm.swift:10:29: error: value of type '[Int]' has no member\
    \ 'unique'\n    let uniqueL1 = sortedL1.unique()\n                   ~~~~~~~~\
    \ ^~~~~~\n/tmp/tmpe_du_sxm.swift:11:29: error: value of type '[Int]' has no member\
    \ 'unique'\n    let uniqueL2 = sortedL2.unique()\n                   ~~~~~~~~\
    \ ^~~~~~\n"
  stdout: ''
  timestamp: 1659979279
- exit_code: 0
  program: "\n/// Return sorted unique common elements for two arrays.\n/// >>> common(l1:\
    \ [1, 4, 3, 34, 653, 2, 5], l2: [5, 7, 1, 5, 9, 653, 121])\n/// [1, 5, 653]\n\
    /// >>> common(l1: [5, 3, 2, 8], l2: [3, 2])\n/// [2, 3]\nfunc common(l1: [Int],\
    \ l2: [Int]) -> [Int] {\n    guard l1.count > 0, l2.count > 0 else { return []\
    \ }\n    guard l1.count > 1, l2.count > 1 else { return l1 == l2 ? l1 : [] }\n\
    \    return l1.filter { l2.contains($0) }.sorted { $0 < $1 }\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(common(l1: [1, 4, 3, 34, 653, 2, 5], l2: [5, 7, 1, 5,\
    \ 9, 653, 121]) == [1, 5, 653])\nassert(common(l1: [5, 3, 2, 8], l2: [3, 2]) ==\
    \ [2, 3])\nassert(common(l1: [4, 3, 2, 8], l2: [3, 2, 4]) == [2, 3, 4])\nassert(common(l1:\
    \ [4, 3, 2, 8], l2: [] as [Int]) == [] as [Int])"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659979279
- exit_code: -4
  program: "\n/// Return sorted unique common elements for two arrays.\n/// >>> common(l1:\
    \ [1, 4, 3, 34, 653, 2, 5], l2: [5, 7, 1, 5, 9, 653, 121])\n/// [1, 5, 653]\n\
    /// >>> common(l1: [5, 3, 2, 8], l2: [3, 2])\n/// [2, 3]\nfunc common(l1: [Int],\
    \ l2: [Int]) -> [Int] {\n    return Array(Set(l1).intersection(Set(l2)))\n}\n\n\
    \nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(common(l1: [1, 4, 3, 34, 653, 2, 5], l2: [5, 7,\
    \ 1, 5, 9, 653, 121]) == [1, 5, 653])\nassert(common(l1: [5, 3, 2, 8], l2: [3,\
    \ 2]) == [2, 3])\nassert(common(l1: [4, 3, 2, 8], l2: [3, 2, 4]) == [2, 3, 4])\n\
    assert(common(l1: [4, 3, 2, 8], l2: [] as [Int]) == [] as [Int])"
  status: Exception
  stderr: 'tmpzxefsmhz/tmpzxefsmhz.swift:24: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b9cc80f7c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b9cc7deeb6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b9cc7dee988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b9cc7ded7b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpzxefsmhz                        0x0000564df22865fc <unavailable> + 5628

    5    libc.so.6                          0x00002b9cc82e3460 __libc_start_main +
    245

    6    tmpzxefsmhz                        0x0000564df2286179 <unavailable> + 4473

    '
  stdout: ''
  timestamp: 1659979279
- exit_code: 1
  program: "\n/// Return sorted unique common elements for two arrays.\n/// >>> common(l1:\
    \ [1, 4, 3, 34, 653, 2, 5], l2: [5, 7, 1, 5, 9, 653, 121])\n/// [1, 5, 653]\n\
    /// >>> common(l1: [5, 3, 2, 8], l2: [3, 2])\n/// [2, 3]\nfunc common(l1: [Int],\
    \ l2: [Int]) -> [Int] {\n    var result = [Int]()\n    for i in l1 {\n       \
    \ for j in l2 {\n            if i == j {\n                result.append(i)\n \
    \           }\n        }\n    }\n    return result.sort()\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(common(l1: [1, 4, 3, 34, 653, 2, 5], l2: [5, 7, 1, 5,\
    \ 9, 653, 121]) == [1, 5, 653])\nassert(common(l1: [5, 3, 2, 8], l2: [3, 2]) ==\
    \ [2, 3])\nassert(common(l1: [4, 3, 2, 8], l2: [3, 2, 4]) == [2, 3, 4])\nassert(common(l1:\
    \ [4, 3, 2, 8], l2: [] as [Int]) == [] as [Int])"
  status: SyntaxError
  stderr: "/tmp/tmprx1e_4se.swift:16:19: error: cannot convert return expression of\
    \ type '()' to return type '[Int]'\n    return result.sort()\n           ~~~~~~~^~~~~~\n"
  stdout: ''
  timestamp: 1659979279
- exit_code: 0
  program: "\n/// Return sorted unique common elements for two arrays.\n/// >>> common(l1:\
    \ [1, 4, 3, 34, 653, 2, 5], l2: [5, 7, 1, 5, 9, 653, 121])\n/// [1, 5, 653]\n\
    /// >>> common(l1: [5, 3, 2, 8], l2: [3, 2])\n/// [2, 3]\nfunc common(l1: [Int],\
    \ l2: [Int]) -> [Int] {\n    let l1 = Set(l1)\n    let l2 = Set(l2)\n    return\
    \ Array(l1.intersection(l2)).sorted()\n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(common(l1: [1, 4, 3, 34, 653, 2, 5], l2: [5, 7, 1, 5, 9, 653, 121]) ==\
    \ [1, 5, 653])\nassert(common(l1: [5, 3, 2, 8], l2: [3, 2]) == [2, 3])\nassert(common(l1:\
    \ [4, 3, 2, 8], l2: [3, 2, 4]) == [2, 3, 4])\nassert(common(l1: [4, 3, 2, 8],\
    \ l2: [] as [Int]) == [] as [Int])"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659979279
- exit_code: 0
  program: "\n/// Return sorted unique common elements for two arrays.\n/// >>> common(l1:\
    \ [1, 4, 3, 34, 653, 2, 5], l2: [5, 7, 1, 5, 9, 653, 121])\n/// [1, 5, 653]\n\
    /// >>> common(l1: [5, 3, 2, 8], l2: [3, 2])\n/// [2, 3]\nfunc common(l1: [Int],\
    \ l2: [Int]) -> [Int] {\n    let result = Set(l1).intersection(Set(l2))\n    return\
    \ Array(result).sorted()\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(common(l1:\
    \ [1, 4, 3, 34, 653, 2, 5], l2: [5, 7, 1, 5, 9, 653, 121]) == [1, 5, 653])\nassert(common(l1:\
    \ [5, 3, 2, 8], l2: [3, 2]) == [2, 3])\nassert(common(l1: [4, 3, 2, 8], l2: [3,\
    \ 2, 4]) == [2, 3, 4])\nassert(common(l1: [4, 3, 2, 8], l2: [] as [Int]) == []\
    \ as [Int])"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659979279
- exit_code: 0
  program: "\n/// Return sorted unique common elements for two arrays.\n/// >>> common(l1:\
    \ [1, 4, 3, 34, 653, 2, 5], l2: [5, 7, 1, 5, 9, 653, 121])\n/// [1, 5, 653]\n\
    /// >>> common(l1: [5, 3, 2, 8], l2: [3, 2])\n/// [2, 3]\nfunc common(l1: [Int],\
    \ l2: [Int]) -> [Int] {\n    var result: [Int] = []\n    let c1 = l1.sorted()\n\
    \    let c2 = l2.sorted()\n    var i = 0\n    var j = 0\n    while i < c1.count\
    \ && j < c2.count {\n        if c1[i] == c2[j] {\n            result.append(c1[i])\n\
    \            i += 1\n            j += 1\n        } else if c1[i] < c2[j] {\n \
    \           i += 1\n        } else {\n            j += 1\n        }\n    }\n \
    \   return result\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) ->\
    \ Bool {\n    if left.count != right.count {\n        return false\n    }\n  \
    \  for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(common(l1: [1, 4,\
    \ 3, 34, 653, 2, 5], l2: [5, 7, 1, 5, 9, 653, 121]) == [1, 5, 653])\nassert(common(l1:\
    \ [5, 3, 2, 8], l2: [3, 2]) == [2, 3])\nassert(common(l1: [4, 3, 2, 8], l2: [3,\
    \ 2, 4]) == [2, 3, 4])\nassert(common(l1: [4, 3, 2, 8], l2: [] as [Int]) == []\
    \ as [Int])"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659979279
- exit_code: -4
  program: "\n/// Return sorted unique common elements for two arrays.\n/// >>> common(l1:\
    \ [1, 4, 3, 34, 653, 2, 5], l2: [5, 7, 1, 5, 9, 653, 121])\n/// [1, 5, 653]\n\
    /// >>> common(l1: [5, 3, 2, 8], l2: [3, 2])\n/// [2, 3]\nfunc common(l1: [Int],\
    \ l2: [Int]) -> [Int] {\n\treturn Array(Set(l1).intersection(Set(l2)))\n}\n\n\n\
    func ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(common(l1: [1, 4, 3, 34, 653, 2, 5], l2: [5, 7,\
    \ 1, 5, 9, 653, 121]) == [1, 5, 653])\nassert(common(l1: [5, 3, 2, 8], l2: [3,\
    \ 2]) == [2, 3])\nassert(common(l1: [4, 3, 2, 8], l2: [3, 2, 4]) == [2, 3, 4])\n\
    assert(common(l1: [4, 3, 2, 8], l2: [] as [Int]) == [] as [Int])"
  status: Exception
  stderr: 'tmpwy5q_tmg/tmpwy5q_tmg.swift:24: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002ae55a376c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002ae55a06db6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002ae55a06d988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002ae55a06c7b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpwy5q_tmg                        0x00005595cc8f25fc <unavailable> + 5628

    5    libc.so.6                          0x00002ae55a562460 __libc_start_main +
    245

    6    tmpwy5q_tmg                        0x00005595cc8f2179 <unavailable> + 4473

    '
  stdout: ''
  timestamp: 1659979279
- exit_code: -4
  program: "\n/// Return sorted unique common elements for two arrays.\n/// >>> common(l1:\
    \ [1, 4, 3, 34, 653, 2, 5], l2: [5, 7, 1, 5, 9, 653, 121])\n/// [1, 5, 653]\n\
    /// >>> common(l1: [5, 3, 2, 8], l2: [3, 2])\n/// [2, 3]\nfunc common(l1: [Int],\
    \ l2: [Int]) -> [Int] {\n    return []\n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(common(l1: [1, 4, 3, 34, 653, 2, 5], l2: [5, 7, 1, 5, 9, 653, 121]) ==\
    \ [1, 5, 653])\nassert(common(l1: [5, 3, 2, 8], l2: [3, 2]) == [2, 3])\nassert(common(l1:\
    \ [4, 3, 2, 8], l2: [3, 2, 4]) == [2, 3, 4])\nassert(common(l1: [4, 3, 2, 8],\
    \ l2: [] as [Int]) == [] as [Int])"
  status: Exception
  stderr: 'tmpxe4ju921/tmpxe4ju921.swift:24: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b32fbf71c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b32fbc68b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b32fbc68988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b32fbc677b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpxe4ju921                        0x000055b04303844c <unavailable> + 5196

    5    libc.so.6                          0x00002b32fc15d460 __libc_start_main +
    245

    6    tmpxe4ju921                        0x000055b043037fc9 <unavailable> + 4041

    '
  stdout: ''
  timestamp: 1659979279
- exit_code: -4
  program: "\n/// Return sorted unique common elements for two arrays.\n/// >>> common(l1:\
    \ [1, 4, 3, 34, 653, 2, 5], l2: [5, 7, 1, 5, 9, 653, 121])\n/// [1, 5, 653]\n\
    /// >>> common(l1: [5, 3, 2, 8], l2: [3, 2])\n/// [2, 3]\nfunc common(l1: [Int],\
    \ l2: [Int]) -> [Int] {\n  return Array(Set(l1).intersection(Set(l2)))\n}\n\n\n\
    func ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(common(l1: [1, 4, 3, 34, 653, 2, 5], l2: [5, 7,\
    \ 1, 5, 9, 653, 121]) == [1, 5, 653])\nassert(common(l1: [5, 3, 2, 8], l2: [3,\
    \ 2]) == [2, 3])\nassert(common(l1: [4, 3, 2, 8], l2: [3, 2, 4]) == [2, 3, 4])\n\
    assert(common(l1: [4, 3, 2, 8], l2: [] as [Int]) == [] as [Int])"
  status: Exception
  stderr: 'tmpd8kd9pul/tmpd8kd9pul.swift:24: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b0683e05c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b0683afcb6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b0683afc988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b0683afb7b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpd8kd9pul                        0x00005556441e05fc <unavailable> + 5628

    5    libc.so.6                          0x00002b0683ff1460 __libc_start_main +
    245

    6    tmpd8kd9pul                        0x00005556441e0179 <unavailable> + 4473

    '
  stdout: ''
  timestamp: 1659979279
- exit_code: 0
  program: "\n/// Return sorted unique common elements for two arrays.\n/// >>> common(l1:\
    \ [1, 4, 3, 34, 653, 2, 5], l2: [5, 7, 1, 5, 9, 653, 121])\n/// [1, 5, 653]\n\
    /// >>> common(l1: [5, 3, 2, 8], l2: [3, 2])\n/// [2, 3]\nfunc common(l1: [Int],\
    \ l2: [Int]) -> [Int] {\n    return Set(l1).intersection(Set(l2)).sorted()\n}\n\
    \n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(common(l1: [1, 4, 3, 34, 653, 2, 5], l2: [5, 7,\
    \ 1, 5, 9, 653, 121]) == [1, 5, 653])\nassert(common(l1: [5, 3, 2, 8], l2: [3,\
    \ 2]) == [2, 3])\nassert(common(l1: [4, 3, 2, 8], l2: [3, 2, 4]) == [2, 3, 4])\n\
    assert(common(l1: [4, 3, 2, 8], l2: [] as [Int]) == [] as [Int])"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659979279
- exit_code: 0
  program: "\n/// Return sorted unique common elements for two arrays.\n/// >>> common(l1:\
    \ [1, 4, 3, 34, 653, 2, 5], l2: [5, 7, 1, 5, 9, 653, 121])\n/// [1, 5, 653]\n\
    /// >>> common(l1: [5, 3, 2, 8], l2: [3, 2])\n/// [2, 3]\nfunc common(l1: [Int],\
    \ l2: [Int]) -> [Int] {\n    var result: [Int] = []\n    var l1Dict: [Int: Bool]\
    \ = [:]\n    var l2Dict: [Int: Bool] = [:]\n    for element in l1 {\n        l1Dict[element]\
    \ = true\n    }\n    for element in l2 {\n        l2Dict[element] = true\n   \
    \ }\n    for element in l1 {\n        if l2Dict[element] != nil {\n          \
    \  result.append(element)\n        }\n    }\n    return result.sorted()\n}\n\n\
    \nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(common(l1: [1, 4, 3, 34, 653, 2, 5], l2: [5, 7,\
    \ 1, 5, 9, 653, 121]) == [1, 5, 653])\nassert(common(l1: [5, 3, 2, 8], l2: [3,\
    \ 2]) == [2, 3])\nassert(common(l1: [4, 3, 2, 8], l2: [3, 2, 4]) == [2, 3, 4])\n\
    assert(common(l1: [4, 3, 2, 8], l2: [] as [Int]) == [] as [Int])"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659979279
- exit_code: 0
  program: "\n/// Return sorted unique common elements for two arrays.\n/// >>> common(l1:\
    \ [1, 4, 3, 34, 653, 2, 5], l2: [5, 7, 1, 5, 9, 653, 121])\n/// [1, 5, 653]\n\
    /// >>> common(l1: [5, 3, 2, 8], l2: [3, 2])\n/// [2, 3]\nfunc common(l1: [Int],\
    \ l2: [Int]) -> [Int] {\n    var result = [Int]()\n    var counter = 0\n    while\
    \ counter < l1.count {\n        if (l2.contains(l1[counter])) {\n            result.append(l1[counter])\n\
    \        }\n        counter += 1\n    }\n    let unique = result.reduce([]) {\
    \ (unique, x) in unique.contains(x) ? unique : unique + [x] }\n    return unique.sorted()\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(common(l1: [1, 4, 3, 34, 653, 2, 5], l2: [5, 7,\
    \ 1, 5, 9, 653, 121]) == [1, 5, 653])\nassert(common(l1: [5, 3, 2, 8], l2: [3,\
    \ 2]) == [2, 3])\nassert(common(l1: [4, 3, 2, 8], l2: [3, 2, 4]) == [2, 3, 4])\n\
    assert(common(l1: [4, 3, 2, 8], l2: [] as [Int]) == [] as [Int])"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659979279
- exit_code: 0
  program: "\n/// Return sorted unique common elements for two arrays.\n/// >>> common(l1:\
    \ [1, 4, 3, 34, 653, 2, 5], l2: [5, 7, 1, 5, 9, 653, 121])\n/// [1, 5, 653]\n\
    /// >>> common(l1: [5, 3, 2, 8], l2: [3, 2])\n/// [2, 3]\nfunc common(l1: [Int],\
    \ l2: [Int]) -> [Int] {\n\treturn Array(Set(l1).intersection(Set(l2))).sorted()\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(common(l1: [1, 4, 3, 34, 653, 2, 5], l2: [5, 7,\
    \ 1, 5, 9, 653, 121]) == [1, 5, 653])\nassert(common(l1: [5, 3, 2, 8], l2: [3,\
    \ 2]) == [2, 3])\nassert(common(l1: [4, 3, 2, 8], l2: [3, 2, 4]) == [2, 3, 4])\n\
    assert(common(l1: [4, 3, 2, 8], l2: [] as [Int]) == [] as [Int])"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659979279
- exit_code: 0
  program: "\n/// Return sorted unique common elements for two arrays.\n/// >>> common(l1:\
    \ [1, 4, 3, 34, 653, 2, 5], l2: [5, 7, 1, 5, 9, 653, 121])\n/// [1, 5, 653]\n\
    /// >>> common(l1: [5, 3, 2, 8], l2: [3, 2])\n/// [2, 3]\nfunc common(l1: [Int],\
    \ l2: [Int]) -> [Int] {\n    var list = l1\n    var list2 = l2\n    list.sort()\n\
    \    list2.sort()\n    var i = 0\n    var j = 0\n    var result = [Int]()\n  \
    \  while i < list.count && j < list2.count {\n        if list[i] == list2[j] {\n\
    \            result.append(list[i])\n            i += 1\n            j += 1\n\
    \        } else if list[i] < list2[j] {\n            i += 1\n        } else {\n\
    \            j += 1\n        }\n    }\n    return result\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(common(l1: [1, 4, 3, 34, 653, 2, 5], l2: [5, 7, 1, 5,\
    \ 9, 653, 121]) == [1, 5, 653])\nassert(common(l1: [5, 3, 2, 8], l2: [3, 2]) ==\
    \ [2, 3])\nassert(common(l1: [4, 3, 2, 8], l2: [3, 2, 4]) == [2, 3, 4])\nassert(common(l1:\
    \ [4, 3, 2, 8], l2: [] as [Int]) == [] as [Int])"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659979279
- exit_code: -4
  program: "\n/// Return sorted unique common elements for two arrays.\n/// >>> common(l1:\
    \ [1, 4, 3, 34, 653, 2, 5], l2: [5, 7, 1, 5, 9, 653, 121])\n/// [1, 5, 653]\n\
    /// >>> common(l1: [5, 3, 2, 8], l2: [3, 2])\n/// [2, 3]\nfunc common(l1: [Int],\
    \ l2: [Int]) -> [Int] {\n    var result = [Int]()\n    var usedIndexes = [Int]()\n\
    \    for i in 0..<l1.count {\n        let value = l1[i]\n        if usedIndexes.contains(i)\
    \ {\n            continue\n        }\n        if let firstIndex = l2.firstIndex(of:\
    \ value) {\n            result.append(value)\n            usedIndexes.append(firstIndex)\n\
    \        }\n    }\n    return result\n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(common(l1: [1, 4, 3, 34, 653, 2, 5], l2: [5, 7, 1, 5, 9, 653, 121]) ==\
    \ [1, 5, 653])\nassert(common(l1: [5, 3, 2, 8], l2: [3, 2]) == [2, 3])\nassert(common(l1:\
    \ [4, 3, 2, 8], l2: [3, 2, 4]) == [2, 3, 4])\nassert(common(l1: [4, 3, 2, 8],\
    \ l2: [] as [Int]) == [] as [Int])"
  status: Exception
  stderr: 'tmpv60pxw5g/tmpv60pxw5g.swift:36: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002ac3a2a0ec80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002ac3a2705b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002ac3a2705988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002ac3a27047b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpv60pxw5g                        0x00005561e6aeb84c <unavailable> + 6220

    5    libc.so.6                          0x00002ac3a2bfa460 __libc_start_main +
    245

    6    tmpv60pxw5g                        0x00005561e6aeb3c9 <unavailable> + 5065

    '
  stdout: ''
  timestamp: 1659979279
- exit_code: 1
  program: "\n/// Return sorted unique common elements for two arrays.\n/// >>> common(l1:\
    \ [1, 4, 3, 34, 653, 2, 5], l2: [5, 7, 1, 5, 9, 653, 121])\n/// [1, 5, 653]\n\
    /// >>> common(l1: [5, 3, 2, 8], l2: [3, 2])\n/// [2, 3]\nfunc common(l1: [Int],\
    \ l2: [Int]) -> [Int] {\n    return l1.filter{l2.contains($0)}.sorted().unique()\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(common(l1: [1, 4, 3, 34, 653, 2, 5], l2: [5, 7,\
    \ 1, 5, 9, 653, 121]) == [1, 5, 653])\nassert(common(l1: [5, 3, 2, 8], l2: [3,\
    \ 2]) == [2, 3])\nassert(common(l1: [4, 3, 2, 8], l2: [3, 2, 4]) == [2, 3, 4])\n\
    assert(common(l1: [4, 3, 2, 8], l2: [] as [Int]) == [] as [Int])"
  status: SyntaxError
  stderr: "/tmp/tmpj0io0213.swift:8:48: error: value of type '[Int]' has no member\
    \ 'unique'\n    return l1.filter{l2.contains($0)}.sorted().unique()\n        \
    \   ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ ^~~~~~\n"
  stdout: ''
  timestamp: 1659979279
- exit_code: 1
  program: "\n/// Return sorted unique common elements for two arrays.\n/// >>> common(l1:\
    \ [1, 4, 3, 34, 653, 2, 5], l2: [5, 7, 1, 5, 9, 653, 121])\n/// [1, 5, 653]\n\
    /// >>> common(l1: [5, 3, 2, 8], l2: [3, 2])\n/// [2, 3]\nfunc common(l1: [Int],\
    \ l2: [Int]) -> [Int] {\n    var result: [Int] = []\n    if l1.count < l2.count\
    \ {\n        result = findCommon(l1: l1, l2: l2)\n    } else {\n        result\
    \ = findCommon(l1: l2, l2: l1)\n    }\n    return result\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(common(l1: [1, 4, 3, 34, 653, 2, 5], l2: [5, 7, 1, 5,\
    \ 9, 653, 121]) == [1, 5, 653])\nassert(common(l1: [5, 3, 2, 8], l2: [3, 2]) ==\
    \ [2, 3])\nassert(common(l1: [4, 3, 2, 8], l2: [3, 2, 4]) == [2, 3, 4])\nassert(common(l1:\
    \ [4, 3, 2, 8], l2: [] as [Int]) == [] as [Int])"
  status: SyntaxError
  stderr: "/tmp/tmporwjc7z4.swift:10:18: error: cannot find 'findCommon' in scope\n\
    \        result = findCommon(l1: l1, l2: l2)\n                 ^~~~~~~~~~\n/tmp/tmporwjc7z4.swift:12:18:\
    \ error: cannot find 'findCommon' in scope\n        result = findCommon(l1: l2,\
    \ l2: l1)\n                 ^~~~~~~~~~\n"
  stdout: ''
  timestamp: 1659979279
- exit_code: 0
  program: "\n/// Return sorted unique common elements for two arrays.\n/// >>> common(l1:\
    \ [1, 4, 3, 34, 653, 2, 5], l2: [5, 7, 1, 5, 9, 653, 121])\n/// [1, 5, 653]\n\
    /// >>> common(l1: [5, 3, 2, 8], l2: [3, 2])\n/// [2, 3]\nfunc common(l1: [Int],\
    \ l2: [Int]) -> [Int] {\n    let commonElements = Set(l1).intersection(Set(l2))\n\
    \    return Array(commonElements).sorted()\n}\n\n\nfunc ==(left: [(Int, Int)],\
    \ right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n       \
    \ return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r\
    \ {\n            return false\n        }\n    }\n    return true\n}\n        \
    \    \nassert(common(l1: [1, 4, 3, 34, 653, 2, 5], l2: [5, 7, 1, 5, 9, 653, 121])\
    \ == [1, 5, 653])\nassert(common(l1: [5, 3, 2, 8], l2: [3, 2]) == [2, 3])\nassert(common(l1:\
    \ [4, 3, 2, 8], l2: [3, 2, 4]) == [2, 3, 4])\nassert(common(l1: [4, 3, 2, 8],\
    \ l2: [] as [Int]) == [] as [Int])"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659979279
- exit_code: 0
  program: "\n/// Return sorted unique common elements for two arrays.\n/// >>> common(l1:\
    \ [1, 4, 3, 34, 653, 2, 5], l2: [5, 7, 1, 5, 9, 653, 121])\n/// [1, 5, 653]\n\
    /// >>> common(l1: [5, 3, 2, 8], l2: [3, 2])\n/// [2, 3]\nfunc common(l1: [Int],\
    \ l2: [Int]) -> [Int] {\n    let set1 = Set(l1)\n    let set2 = Set(l2)\n    return\
    \ Array(set1.intersection(set2)).sorted()\n}\n\n\nfunc ==(left: [(Int, Int)],\
    \ right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n       \
    \ return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r\
    \ {\n            return false\n        }\n    }\n    return true\n}\n        \
    \    \nassert(common(l1: [1, 4, 3, 34, 653, 2, 5], l2: [5, 7, 1, 5, 9, 653, 121])\
    \ == [1, 5, 653])\nassert(common(l1: [5, 3, 2, 8], l2: [3, 2]) == [2, 3])\nassert(common(l1:\
    \ [4, 3, 2, 8], l2: [3, 2, 4]) == [2, 3, 4])\nassert(common(l1: [4, 3, 2, 8],\
    \ l2: [] as [Int]) == [] as [Int])"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659979279
- exit_code: 1
  program: "\n/// Return sorted unique common elements for two arrays.\n/// >>> common(l1:\
    \ [1, 4, 3, 34, 653, 2, 5], l2: [5, 7, 1, 5, 9, 653, 121])\n/// [1, 5, 653]\n\
    /// >>> common(l1: [5, 3, 2, 8], l2: [3, 2])\n/// [2, 3]\nfunc common(l1: [Int],\
    \ l2: [Int]) -> [Int] {\n    return unique(l1: l1, l2: l2).sorted()\n}\n\n\nfunc\
    \ ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count !=\
    \ right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(common(l1: [1, 4, 3, 34, 653, 2, 5], l2: [5, 7,\
    \ 1, 5, 9, 653, 121]) == [1, 5, 653])\nassert(common(l1: [5, 3, 2, 8], l2: [3,\
    \ 2]) == [2, 3])\nassert(common(l1: [4, 3, 2, 8], l2: [3, 2, 4]) == [2, 3, 4])\n\
    assert(common(l1: [4, 3, 2, 8], l2: [] as [Int]) == [] as [Int])"
  status: SyntaxError
  stderr: "/tmp/tmpl6hnpmr7.swift:8:12: error: cannot find 'unique' in scope\n   \
    \ return unique(l1: l1, l2: l2).sorted()\n           ^~~~~~\n"
  stdout: ''
  timestamp: 1659979279
- exit_code: 0
  program: "\n/// Return sorted unique common elements for two arrays.\n/// >>> common(l1:\
    \ [1, 4, 3, 34, 653, 2, 5], l2: [5, 7, 1, 5, 9, 653, 121])\n/// [1, 5, 653]\n\
    /// >>> common(l1: [5, 3, 2, 8], l2: [3, 2])\n/// [2, 3]\nfunc common(l1: [Int],\
    \ l2: [Int]) -> [Int] {\n    var sortL1 = l1.sorted()\n    var sortL2 = l2.sorted()\n\
    \    var count = 0\n    var result = [Int]()\n    var check = false\n    for i\
    \ in 0..<sortL1.count {\n        for j in count..<sortL2.count {\n           \
    \ if sortL1[i] == sortL2[j] {\n                result.append(sortL1[i])\n    \
    \            count = j + 1\n                check = true\n                break\n\
    \            }\n        }\n        if check == false {\n            count = 0\n\
    \        }\n        check = false\n    }\n    return result\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(common(l1: [1, 4, 3, 34, 653, 2, 5], l2: [5, 7, 1, 5,\
    \ 9, 653, 121]) == [1, 5, 653])\nassert(common(l1: [5, 3, 2, 8], l2: [3, 2]) ==\
    \ [2, 3])\nassert(common(l1: [4, 3, 2, 8], l2: [3, 2, 4]) == [2, 3, 4])\nassert(common(l1:\
    \ [4, 3, 2, 8], l2: [] as [Int]) == [] as [Int])"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659979279
- exit_code: 0
  program: "\n/// Return sorted unique common elements for two arrays.\n/// >>> common(l1:\
    \ [1, 4, 3, 34, 653, 2, 5], l2: [5, 7, 1, 5, 9, 653, 121])\n/// [1, 5, 653]\n\
    /// >>> common(l1: [5, 3, 2, 8], l2: [3, 2])\n/// [2, 3]\nfunc common(l1: [Int],\
    \ l2: [Int]) -> [Int] {\n    let s1 = Set(l1)\n    let s2 = Set(l2)\n    return\
    \ Array(s1.intersection(s2)).sorted()\n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(common(l1: [1, 4, 3, 34, 653, 2, 5], l2: [5, 7, 1, 5, 9, 653, 121]) ==\
    \ [1, 5, 653])\nassert(common(l1: [5, 3, 2, 8], l2: [3, 2]) == [2, 3])\nassert(common(l1:\
    \ [4, 3, 2, 8], l2: [3, 2, 4]) == [2, 3, 4])\nassert(common(l1: [4, 3, 2, 8],\
    \ l2: [] as [Int]) == [] as [Int])"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659979279
- exit_code: -4
  program: "\n/// Return sorted unique common elements for two arrays.\n/// >>> common(l1:\
    \ [1, 4, 3, 34, 653, 2, 5], l2: [5, 7, 1, 5, 9, 653, 121])\n/// [1, 5, 653]\n\
    /// >>> common(l1: [5, 3, 2, 8], l2: [3, 2])\n/// [2, 3]\nfunc common(l1: [Int],\
    \ l2: [Int]) -> [Int] {\n    return Array(Set(l1).intersection(Set(l2)))\n}\n\n\
    \nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(common(l1: [1, 4, 3, 34, 653, 2, 5], l2: [5, 7,\
    \ 1, 5, 9, 653, 121]) == [1, 5, 653])\nassert(common(l1: [5, 3, 2, 8], l2: [3,\
    \ 2]) == [2, 3])\nassert(common(l1: [4, 3, 2, 8], l2: [3, 2, 4]) == [2, 3, 4])\n\
    assert(common(l1: [4, 3, 2, 8], l2: [] as [Int]) == [] as [Int])"
  status: Exception
  stderr: 'tmpzxefsmhz/tmpzxefsmhz.swift:24: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b9cc80f7c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b9cc7deeb6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b9cc7dee988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b9cc7ded7b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpzxefsmhz                        0x0000564df22865fc <unavailable> + 5628

    5    libc.so.6                          0x00002b9cc82e3460 __libc_start_main +
    245

    6    tmpzxefsmhz                        0x0000564df2286179 <unavailable> + 4473

    '
  stdout: ''
  timestamp: 1659979279
- exit_code: 0
  program: "\n/// Return sorted unique common elements for two arrays.\n/// >>> common(l1:\
    \ [1, 4, 3, 34, 653, 2, 5], l2: [5, 7, 1, 5, 9, 653, 121])\n/// [1, 5, 653]\n\
    /// >>> common(l1: [5, 3, 2, 8], l2: [3, 2])\n/// [2, 3]\nfunc common(l1: [Int],\
    \ l2: [Int]) -> [Int] {\n\treturn Array(Set(l1).intersection(Set(l2))).sorted()\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(common(l1: [1, 4, 3, 34, 653, 2, 5], l2: [5, 7,\
    \ 1, 5, 9, 653, 121]) == [1, 5, 653])\nassert(common(l1: [5, 3, 2, 8], l2: [3,\
    \ 2]) == [2, 3])\nassert(common(l1: [4, 3, 2, 8], l2: [3, 2, 4]) == [2, 3, 4])\n\
    assert(common(l1: [4, 3, 2, 8], l2: [] as [Int]) == [] as [Int])"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659979279
- exit_code: 0
  program: "\n/// Return sorted unique common elements for two arrays.\n/// >>> common(l1:\
    \ [1, 4, 3, 34, 653, 2, 5], l2: [5, 7, 1, 5, 9, 653, 121])\n/// [1, 5, 653]\n\
    /// >>> common(l1: [5, 3, 2, 8], l2: [3, 2])\n/// [2, 3]\nfunc common(l1: [Int],\
    \ l2: [Int]) -> [Int] {\n    let set1 = Set(l1)\n    let set2 = Set(l2)\n    return\
    \ set1.intersection(set2).sorted()\n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(common(l1: [1, 4, 3, 34, 653, 2, 5], l2: [5, 7, 1, 5, 9, 653, 121]) ==\
    \ [1, 5, 653])\nassert(common(l1: [5, 3, 2, 8], l2: [3, 2]) == [2, 3])\nassert(common(l1:\
    \ [4, 3, 2, 8], l2: [3, 2, 4]) == [2, 3, 4])\nassert(common(l1: [4, 3, 2, 8],\
    \ l2: [] as [Int]) == [] as [Int])"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659979279
- exit_code: 0
  program: "\n/// Return sorted unique common elements for two arrays.\n/// >>> common(l1:\
    \ [1, 4, 3, 34, 653, 2, 5], l2: [5, 7, 1, 5, 9, 653, 121])\n/// [1, 5, 653]\n\
    /// >>> common(l1: [5, 3, 2, 8], l2: [3, 2])\n/// [2, 3]\nfunc common(l1: [Int],\
    \ l2: [Int]) -> [Int] {\n    var result = [Int]()\n    for element in l1 {\n \
    \       if l2.contains(element) {\n            result.append(element)\n      \
    \  }\n    }\n    return result.sorted()\n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(common(l1: [1, 4, 3, 34, 653, 2, 5], l2: [5, 7, 1, 5, 9, 653, 121]) ==\
    \ [1, 5, 653])\nassert(common(l1: [5, 3, 2, 8], l2: [3, 2]) == [2, 3])\nassert(common(l1:\
    \ [4, 3, 2, 8], l2: [3, 2, 4]) == [2, 3, 4])\nassert(common(l1: [4, 3, 2, 8],\
    \ l2: [] as [Int]) == [] as [Int])"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659979279
- exit_code: 0
  program: "\n/// Return sorted unique common elements for two arrays.\n/// >>> common(l1:\
    \ [1, 4, 3, 34, 653, 2, 5], l2: [5, 7, 1, 5, 9, 653, 121])\n/// [1, 5, 653]\n\
    /// >>> common(l1: [5, 3, 2, 8], l2: [3, 2])\n/// [2, 3]\nfunc common(l1: [Int],\
    \ l2: [Int]) -> [Int] {\n    let set1 = Set(l1)\n    let set2 = Set(l2)\n    return\
    \ Array(set1.intersection(set2)).sorted()\n}\n\n\nfunc ==(left: [(Int, Int)],\
    \ right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n       \
    \ return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r\
    \ {\n            return false\n        }\n    }\n    return true\n}\n        \
    \    \nassert(common(l1: [1, 4, 3, 34, 653, 2, 5], l2: [5, 7, 1, 5, 9, 653, 121])\
    \ == [1, 5, 653])\nassert(common(l1: [5, 3, 2, 8], l2: [3, 2]) == [2, 3])\nassert(common(l1:\
    \ [4, 3, 2, 8], l2: [3, 2, 4]) == [2, 3, 4])\nassert(common(l1: [4, 3, 2, 8],\
    \ l2: [] as [Int]) == [] as [Int])"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659979279
- exit_code: 0
  program: "\n/// Return sorted unique common elements for two arrays.\n/// >>> common(l1:\
    \ [1, 4, 3, 34, 653, 2, 5], l2: [5, 7, 1, 5, 9, 653, 121])\n/// [1, 5, 653]\n\
    /// >>> common(l1: [5, 3, 2, 8], l2: [3, 2])\n/// [2, 3]\nfunc common(l1: [Int],\
    \ l2: [Int]) -> [Int] {\n    return Array(Set(l1).intersection(Set(l2))).sorted()\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(common(l1: [1, 4, 3, 34, 653, 2, 5], l2: [5, 7,\
    \ 1, 5, 9, 653, 121]) == [1, 5, 653])\nassert(common(l1: [5, 3, 2, 8], l2: [3,\
    \ 2]) == [2, 3])\nassert(common(l1: [4, 3, 2, 8], l2: [3, 2, 4]) == [2, 3, 4])\n\
    assert(common(l1: [4, 3, 2, 8], l2: [] as [Int]) == [] as [Int])"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659979279
- exit_code: 0
  program: "\n/// Return sorted unique common elements for two arrays.\n/// >>> common(l1:\
    \ [1, 4, 3, 34, 653, 2, 5], l2: [5, 7, 1, 5, 9, 653, 121])\n/// [1, 5, 653]\n\
    /// >>> common(l1: [5, 3, 2, 8], l2: [3, 2])\n/// [2, 3]\nfunc common(l1: [Int],\
    \ l2: [Int]) -> [Int] {\n    // FIXME: Return unique and sorted array with common\
    \ elements.\n    return l1.filter{ l2.contains($0) }.sorted()\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(common(l1: [1, 4, 3, 34, 653, 2, 5], l2: [5, 7, 1, 5,\
    \ 9, 653, 121]) == [1, 5, 653])\nassert(common(l1: [5, 3, 2, 8], l2: [3, 2]) ==\
    \ [2, 3])\nassert(common(l1: [4, 3, 2, 8], l2: [3, 2, 4]) == [2, 3, 4])\nassert(common(l1:\
    \ [4, 3, 2, 8], l2: [] as [Int]) == [] as [Int])"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659979279
- exit_code: -4
  program: "\n/// Return sorted unique common elements for two arrays.\n/// >>> common(l1:\
    \ [1, 4, 3, 34, 653, 2, 5], l2: [5, 7, 1, 5, 9, 653, 121])\n/// [1, 5, 653]\n\
    /// >>> common(l1: [5, 3, 2, 8], l2: [3, 2])\n/// [2, 3]\nfunc common(l1: [Int],\
    \ l2: [Int]) -> [Int] {\n    return Array(Set(l1).intersection(Set(l2)))\n}\n\n\
    \nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(common(l1: [1, 4, 3, 34, 653, 2, 5], l2: [5, 7,\
    \ 1, 5, 9, 653, 121]) == [1, 5, 653])\nassert(common(l1: [5, 3, 2, 8], l2: [3,\
    \ 2]) == [2, 3])\nassert(common(l1: [4, 3, 2, 8], l2: [3, 2, 4]) == [2, 3, 4])\n\
    assert(common(l1: [4, 3, 2, 8], l2: [] as [Int]) == [] as [Int])"
  status: Exception
  stderr: 'tmpzxefsmhz/tmpzxefsmhz.swift:24: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b9cc80f7c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b9cc7deeb6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b9cc7dee988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b9cc7ded7b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpzxefsmhz                        0x0000564df22865fc <unavailable> + 5628

    5    libc.so.6                          0x00002b9cc82e3460 __libc_start_main +
    245

    6    tmpzxefsmhz                        0x0000564df2286179 <unavailable> + 4473

    '
  stdout: ''
  timestamp: 1659979279
- exit_code: 0
  program: "\n/// Return sorted unique common elements for two arrays.\n/// >>> common(l1:\
    \ [1, 4, 3, 34, 653, 2, 5], l2: [5, 7, 1, 5, 9, 653, 121])\n/// [1, 5, 653]\n\
    /// >>> common(l1: [5, 3, 2, 8], l2: [3, 2])\n/// [2, 3]\nfunc common(l1: [Int],\
    \ l2: [Int]) -> [Int] {\n    var result = [Int]()\n    let sortedL1 = l1.sorted()\n\
    \    let sortedL2 = l2.sorted()\n    var i = 0\n    var j = 0\n    while i < sortedL1.count\
    \ && j < sortedL2.count {\n        if sortedL1[i] < sortedL2[j] {\n          \
    \  i += 1\n        } else if sortedL1[i] > sortedL2[j] {\n            j += 1\n\
    \        } else {\n            result.append(sortedL1[i])\n            i += 1\n\
    \            j += 1\n        }\n    }\n    return result\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(common(l1: [1, 4, 3, 34, 653, 2, 5], l2: [5, 7, 1, 5,\
    \ 9, 653, 121]) == [1, 5, 653])\nassert(common(l1: [5, 3, 2, 8], l2: [3, 2]) ==\
    \ [2, 3])\nassert(common(l1: [4, 3, 2, 8], l2: [3, 2, 4]) == [2, 3, 4])\nassert(common(l1:\
    \ [4, 3, 2, 8], l2: [] as [Int]) == [] as [Int])"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659979279
- exit_code: -4
  program: "\n/// Return sorted unique common elements for two arrays.\n/// >>> common(l1:\
    \ [1, 4, 3, 34, 653, 2, 5], l2: [5, 7, 1, 5, 9, 653, 121])\n/// [1, 5, 653]\n\
    /// >>> common(l1: [5, 3, 2, 8], l2: [3, 2])\n/// [2, 3]\nfunc common(l1: [Int],\
    \ l2: [Int]) -> [Int] {\n    return Array(Set(l1).intersection(Set(l2)))\n}\n\n\
    \nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(common(l1: [1, 4, 3, 34, 653, 2, 5], l2: [5, 7,\
    \ 1, 5, 9, 653, 121]) == [1, 5, 653])\nassert(common(l1: [5, 3, 2, 8], l2: [3,\
    \ 2]) == [2, 3])\nassert(common(l1: [4, 3, 2, 8], l2: [3, 2, 4]) == [2, 3, 4])\n\
    assert(common(l1: [4, 3, 2, 8], l2: [] as [Int]) == [] as [Int])"
  status: Exception
  stderr: 'tmpzxefsmhz/tmpzxefsmhz.swift:24: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b9cc80f7c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b9cc7deeb6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b9cc7dee988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b9cc7ded7b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpzxefsmhz                        0x0000564df22865fc <unavailable> + 5628

    5    libc.so.6                          0x00002b9cc82e3460 __libc_start_main +
    245

    6    tmpzxefsmhz                        0x0000564df2286179 <unavailable> + 4473

    '
  stdout: ''
  timestamp: 1659979279
- exit_code: -4
  program: "\n/// Return sorted unique common elements for two arrays.\n/// >>> common(l1:\
    \ [1, 4, 3, 34, 653, 2, 5], l2: [5, 7, 1, 5, 9, 653, 121])\n/// [1, 5, 653]\n\
    /// >>> common(l1: [5, 3, 2, 8], l2: [3, 2])\n/// [2, 3]\nfunc common(l1: [Int],\
    \ l2: [Int]) -> [Int] {\n    var result: [Int] = []\n    for i in l1 {\n     \
    \   for j in l2 {\n            if i == j {\n                result.append(i)\n\
    \            }\n        }\n    }\n    return result.sorted()\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(common(l1: [1, 4, 3, 34, 653, 2, 5], l2: [5, 7, 1, 5,\
    \ 9, 653, 121]) == [1, 5, 653])\nassert(common(l1: [5, 3, 2, 8], l2: [3, 2]) ==\
    \ [2, 3])\nassert(common(l1: [4, 3, 2, 8], l2: [3, 2, 4]) == [2, 3, 4])\nassert(common(l1:\
    \ [4, 3, 2, 8], l2: [] as [Int]) == [] as [Int])"
  status: Exception
  stderr: 'tmpaf7rpw5v/tmpaf7rpw5v.swift:32: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b7120ef5c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b7120becb6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b7120bec988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b7120beb7b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpaf7rpw5v                        0x000055e790bf66bc <unavailable> + 5820

    5    libc.so.6                          0x00002b71210e1460 __libc_start_main +
    245

    6    tmpaf7rpw5v                        0x000055e790bf6239 <unavailable> + 4665

    '
  stdout: ''
  timestamp: 1659979279
- exit_code: 0
  program: "\n/// Return sorted unique common elements for two arrays.\n/// >>> common(l1:\
    \ [1, 4, 3, 34, 653, 2, 5], l2: [5, 7, 1, 5, 9, 653, 121])\n/// [1, 5, 653]\n\
    /// >>> common(l1: [5, 3, 2, 8], l2: [3, 2])\n/// [2, 3]\nfunc common(l1: [Int],\
    \ l2: [Int]) -> [Int] {\n    let s1 = Set(l1)\n    let s2 = Set(l2)\n    return\
    \ Array(s1.intersection(s2)).sorted()\n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(common(l1: [1, 4, 3, 34, 653, 2, 5], l2: [5, 7, 1, 5, 9, 653, 121]) ==\
    \ [1, 5, 653])\nassert(common(l1: [5, 3, 2, 8], l2: [3, 2]) == [2, 3])\nassert(common(l1:\
    \ [4, 3, 2, 8], l2: [3, 2, 4]) == [2, 3, 4])\nassert(common(l1: [4, 3, 2, 8],\
    \ l2: [] as [Int]) == [] as [Int])"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659979279
- exit_code: 1
  program: "\n/// Return sorted unique common elements for two arrays.\n/// >>> common(l1:\
    \ [1, 4, 3, 34, 653, 2, 5], l2: [5, 7, 1, 5, 9, 653, 121])\n/// [1, 5, 653]\n\
    /// >>> common(l1: [5, 3, 2, 8], l2: [3, 2])\n/// [2, 3]\nfunc common(l1: [Int],\
    \ l2: [Int]) -> [Int] {\n    return l1.filter { l2.contains($0) }.sorted().unique()\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(common(l1: [1, 4, 3, 34, 653, 2, 5], l2: [5, 7,\
    \ 1, 5, 9, 653, 121]) == [1, 5, 653])\nassert(common(l1: [5, 3, 2, 8], l2: [3,\
    \ 2]) == [2, 3])\nassert(common(l1: [4, 3, 2, 8], l2: [3, 2, 4]) == [2, 3, 4])\n\
    assert(common(l1: [4, 3, 2, 8], l2: [] as [Int]) == [] as [Int])"
  status: SyntaxError
  stderr: "/tmp/tmpv0nheia1.swift:8:51: error: value of type '[Int]' has no member\
    \ 'unique'\n    return l1.filter { l2.contains($0) }.sorted().unique()\n     \
    \      ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ ^~~~~~\n"
  stdout: ''
  timestamp: 1659979279
- exit_code: -4
  program: "\n/// Return sorted unique common elements for two arrays.\n/// >>> common(l1:\
    \ [1, 4, 3, 34, 653, 2, 5], l2: [5, 7, 1, 5, 9, 653, 121])\n/// [1, 5, 653]\n\
    /// >>> common(l1: [5, 3, 2, 8], l2: [3, 2])\n/// [2, 3]\nfunc common(l1: [Int],\
    \ l2: [Int]) -> [Int] {\n    return Array(Set(l1).intersection(Set(l2)))\n}\n\n\
    \nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(common(l1: [1, 4, 3, 34, 653, 2, 5], l2: [5, 7,\
    \ 1, 5, 9, 653, 121]) == [1, 5, 653])\nassert(common(l1: [5, 3, 2, 8], l2: [3,\
    \ 2]) == [2, 3])\nassert(common(l1: [4, 3, 2, 8], l2: [3, 2, 4]) == [2, 3, 4])\n\
    assert(common(l1: [4, 3, 2, 8], l2: [] as [Int]) == [] as [Int])"
  status: Exception
  stderr: 'tmpzxefsmhz/tmpzxefsmhz.swift:24: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b9cc80f7c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b9cc7deeb6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b9cc7dee988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b9cc7ded7b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpzxefsmhz                        0x0000564df22865fc <unavailable> + 5628

    5    libc.so.6                          0x00002b9cc82e3460 __libc_start_main +
    245

    6    tmpzxefsmhz                        0x0000564df2286179 <unavailable> + 4473

    '
  stdout: ''
  timestamp: 1659979279
- exit_code: -4
  program: "\n/// Return sorted unique common elements for two arrays.\n/// >>> common(l1:\
    \ [1, 4, 3, 34, 653, 2, 5], l2: [5, 7, 1, 5, 9, 653, 121])\n/// [1, 5, 653]\n\
    /// >>> common(l1: [5, 3, 2, 8], l2: [3, 2])\n/// [2, 3]\nfunc common(l1: [Int],\
    \ l2: [Int]) -> [Int] {\n    var set = Set<Int>()\n    var c = [Int]()\n    for\
    \ i in l1 {\n        set.insert(i)\n    }\n    for i in l2 {\n        if set.contains(i)\
    \ {\n            c.append(i)\n        }\n    }\n    return c.sorted()\n}\n\n\n\
    func ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(common(l1: [1, 4, 3, 34, 653, 2, 5], l2: [5, 7,\
    \ 1, 5, 9, 653, 121]) == [1, 5, 653])\nassert(common(l1: [5, 3, 2, 8], l2: [3,\
    \ 2]) == [2, 3])\nassert(common(l1: [4, 3, 2, 8], l2: [3, 2, 4]) == [2, 3, 4])\n\
    assert(common(l1: [4, 3, 2, 8], l2: [] as [Int]) == [] as [Int])"
  status: Exception
  stderr: 'tmpgyqqmtz2/tmpgyqqmtz2.swift:34: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002af2107d0c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002af2104c7b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002af2104c7988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002af2104c67b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpgyqqmtz2                        0x000055ac03df085c <unavailable> + 6236

    5    libc.so.6                          0x00002af2109bc460 __libc_start_main +
    245

    6    tmpgyqqmtz2                        0x000055ac03df03d9 <unavailable> + 5081

    '
  stdout: ''
  timestamp: 1659979279
- exit_code: 0
  program: "\n/// Return sorted unique common elements for two arrays.\n/// >>> common(l1:\
    \ [1, 4, 3, 34, 653, 2, 5], l2: [5, 7, 1, 5, 9, 653, 121])\n/// [1, 5, 653]\n\
    /// >>> common(l1: [5, 3, 2, 8], l2: [3, 2])\n/// [2, 3]\nfunc common(l1: [Int],\
    \ l2: [Int]) -> [Int] {\n    let set1 = Set(l1)\n    let set2 = Set(l2)\n    return\
    \ Array(set1.intersection(set2)).sorted()\n}\n\n\nfunc ==(left: [(Int, Int)],\
    \ right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n       \
    \ return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r\
    \ {\n            return false\n        }\n    }\n    return true\n}\n        \
    \    \nassert(common(l1: [1, 4, 3, 34, 653, 2, 5], l2: [5, 7, 1, 5, 9, 653, 121])\
    \ == [1, 5, 653])\nassert(common(l1: [5, 3, 2, 8], l2: [3, 2]) == [2, 3])\nassert(common(l1:\
    \ [4, 3, 2, 8], l2: [3, 2, 4]) == [2, 3, 4])\nassert(common(l1: [4, 3, 2, 8],\
    \ l2: [] as [Int]) == [] as [Int])"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659979279
- exit_code: 0
  program: "\n/// Return sorted unique common elements for two arrays.\n/// >>> common(l1:\
    \ [1, 4, 3, 34, 653, 2, 5], l2: [5, 7, 1, 5, 9, 653, 121])\n/// [1, 5, 653]\n\
    /// >>> common(l1: [5, 3, 2, 8], l2: [3, 2])\n/// [2, 3]\nfunc common(l1: [Int],\
    \ l2: [Int]) -> [Int] {\n    var c = [Int]()\n    var l1 = l1.sorted()\n    var\
    \ l2 = l2.sorted()\n    for i in 0..<l1.count {\n        for j in 0..<l2.count\
    \ {\n            if l1[i] == l2[j] {\n                c.append(l1[i])\n      \
    \          l2.remove(at: j)\n                break\n            }\n        }\n\
    \    }\n    return c\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(common(l1:\
    \ [1, 4, 3, 34, 653, 2, 5], l2: [5, 7, 1, 5, 9, 653, 121]) == [1, 5, 653])\nassert(common(l1:\
    \ [5, 3, 2, 8], l2: [3, 2]) == [2, 3])\nassert(common(l1: [4, 3, 2, 8], l2: [3,\
    \ 2, 4]) == [2, 3, 4])\nassert(common(l1: [4, 3, 2, 8], l2: [] as [Int]) == []\
    \ as [Int])"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659979279
- exit_code: 1
  program: "\n/// Return sorted unique common elements for two arrays.\n/// >>> common(l1:\
    \ [1, 4, 3, 34, 653, 2, 5], l2: [5, 7, 1, 5, 9, 653, 121])\n/// [1, 5, 653]\n\
    /// >>> common(l1: [5, 3, 2, 8], l2: [3, 2])\n/// [2, 3]\nfunc common(l1: [Int],\
    \ l2: [Int]) -> [Int] {\n    return l1.filter { l2.contains($0) }.uniqued()\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(common(l1: [1, 4, 3, 34, 653, 2, 5], l2: [5, 7,\
    \ 1, 5, 9, 653, 121]) == [1, 5, 653])\nassert(common(l1: [5, 3, 2, 8], l2: [3,\
    \ 2]) == [2, 3])\nassert(common(l1: [4, 3, 2, 8], l2: [3, 2, 4]) == [2, 3, 4])\n\
    assert(common(l1: [4, 3, 2, 8], l2: [] as [Int]) == [] as [Int])"
  status: SyntaxError
  stderr: "/tmp/tmpeusklp98.swift:8:42: error: value of type '[Int]' has no member\
    \ 'uniqued'\n    return l1.filter { l2.contains($0) }.uniqued()\n           ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\
    \ ^~~~~~~\n"
  stdout: ''
  timestamp: 1659979279
- exit_code: 0
  program: "\n/// Return sorted unique common elements for two arrays.\n/// >>> common(l1:\
    \ [1, 4, 3, 34, 653, 2, 5], l2: [5, 7, 1, 5, 9, 653, 121])\n/// [1, 5, 653]\n\
    /// >>> common(l1: [5, 3, 2, 8], l2: [3, 2])\n/// [2, 3]\nfunc common(l1: [Int],\
    \ l2: [Int]) -> [Int] {\n    let s1 = Set(l1)\n    let s2 = Set(l2)\n    return\
    \ Array(s1.intersection(s2)).sorted()\n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(common(l1: [1, 4, 3, 34, 653, 2, 5], l2: [5, 7, 1, 5, 9, 653, 121]) ==\
    \ [1, 5, 653])\nassert(common(l1: [5, 3, 2, 8], l2: [3, 2]) == [2, 3])\nassert(common(l1:\
    \ [4, 3, 2, 8], l2: [3, 2, 4]) == [2, 3, 4])\nassert(common(l1: [4, 3, 2, 8],\
    \ l2: [] as [Int]) == [] as [Int])"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659979279
- exit_code: 0
  program: "\n/// Return sorted unique common elements for two arrays.\n/// >>> common(l1:\
    \ [1, 4, 3, 34, 653, 2, 5], l2: [5, 7, 1, 5, 9, 653, 121])\n/// [1, 5, 653]\n\
    /// >>> common(l1: [5, 3, 2, 8], l2: [3, 2])\n/// [2, 3]\nfunc common(l1: [Int],\
    \ l2: [Int]) -> [Int] {\n    return Array(Set(l1).intersection(Set(l2))).sorted()\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(common(l1: [1, 4, 3, 34, 653, 2, 5], l2: [5, 7,\
    \ 1, 5, 9, 653, 121]) == [1, 5, 653])\nassert(common(l1: [5, 3, 2, 8], l2: [3,\
    \ 2]) == [2, 3])\nassert(common(l1: [4, 3, 2, 8], l2: [3, 2, 4]) == [2, 3, 4])\n\
    assert(common(l1: [4, 3, 2, 8], l2: [] as [Int]) == [] as [Int])"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659979279
- exit_code: 0
  program: "\n/// Return sorted unique common elements for two arrays.\n/// >>> common(l1:\
    \ [1, 4, 3, 34, 653, 2, 5], l2: [5, 7, 1, 5, 9, 653, 121])\n/// [1, 5, 653]\n\
    /// >>> common(l1: [5, 3, 2, 8], l2: [3, 2])\n/// [2, 3]\nfunc common(l1: [Int],\
    \ l2: [Int]) -> [Int] {\n    // Write your code here\n    let l1Set = Set(l1)\n\
    \    let l2Set = Set(l2)\n    let resultSet = l1Set.intersection(l2Set)\n    return\
    \ Array(resultSet).sorted()\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int,\
    \ Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n\
    \    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n          \
    \  return false\n        }\n    }\n    return true\n}\n            \nassert(common(l1:\
    \ [1, 4, 3, 34, 653, 2, 5], l2: [5, 7, 1, 5, 9, 653, 121]) == [1, 5, 653])\nassert(common(l1:\
    \ [5, 3, 2, 8], l2: [3, 2]) == [2, 3])\nassert(common(l1: [4, 3, 2, 8], l2: [3,\
    \ 2, 4]) == [2, 3, 4])\nassert(common(l1: [4, 3, 2, 8], l2: [] as [Int]) == []\
    \ as [Int])"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659979279
- exit_code: 0
  program: "\n/// Return sorted unique common elements for two arrays.\n/// >>> common(l1:\
    \ [1, 4, 3, 34, 653, 2, 5], l2: [5, 7, 1, 5, 9, 653, 121])\n/// [1, 5, 653]\n\
    /// >>> common(l1: [5, 3, 2, 8], l2: [3, 2])\n/// [2, 3]\nfunc common(l1: [Int],\
    \ l2: [Int]) -> [Int] {\n\tvar common = Set(l1).intersection(Set(l2))\n\tvar commonArray\
    \ = Array(common)\n\tcommonArray.sort()\n\treturn commonArray\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(common(l1: [1, 4, 3, 34, 653, 2, 5], l2: [5, 7, 1, 5,\
    \ 9, 653, 121]) == [1, 5, 653])\nassert(common(l1: [5, 3, 2, 8], l2: [3, 2]) ==\
    \ [2, 3])\nassert(common(l1: [4, 3, 2, 8], l2: [3, 2, 4]) == [2, 3, 4])\nassert(common(l1:\
    \ [4, 3, 2, 8], l2: [] as [Int]) == [] as [Int])"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659979279
- exit_code: 0
  program: "\n/// Return sorted unique common elements for two arrays.\n/// >>> common(l1:\
    \ [1, 4, 3, 34, 653, 2, 5], l2: [5, 7, 1, 5, 9, 653, 121])\n/// [1, 5, 653]\n\
    /// >>> common(l1: [5, 3, 2, 8], l2: [3, 2])\n/// [2, 3]\nfunc common(l1: [Int],\
    \ l2: [Int]) -> [Int] {\n    return Array(Set(l1).intersection(Set(l2))).sorted()\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(common(l1: [1, 4, 3, 34, 653, 2, 5], l2: [5, 7,\
    \ 1, 5, 9, 653, 121]) == [1, 5, 653])\nassert(common(l1: [5, 3, 2, 8], l2: [3,\
    \ 2]) == [2, 3])\nassert(common(l1: [4, 3, 2, 8], l2: [3, 2, 4]) == [2, 3, 4])\n\
    assert(common(l1: [4, 3, 2, 8], l2: [] as [Int]) == [] as [Int])"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659979279
- exit_code: 0
  program: "\n/// Return sorted unique common elements for two arrays.\n/// >>> common(l1:\
    \ [1, 4, 3, 34, 653, 2, 5], l2: [5, 7, 1, 5, 9, 653, 121])\n/// [1, 5, 653]\n\
    /// >>> common(l1: [5, 3, 2, 8], l2: [3, 2])\n/// [2, 3]\nfunc common(l1: [Int],\
    \ l2: [Int]) -> [Int] {\n    var l1Dict = [Int: Bool]()\n    var l2Dict = [Int:\
    \ Bool]()\n    for i in l1 {\n        l1Dict[i] = true\n    }\n    for i in l2\
    \ {\n        l2Dict[i] = true\n    }\n    var result = [Int]()\n    for (key,\
    \ _) in l1Dict {\n        if l2Dict[key] == true {\n            result.append(key)\n\
    \        }\n    }\n    return result.sorted()\n}\n\n\nfunc ==(left: [(Int, Int)],\
    \ right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n       \
    \ return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r\
    \ {\n            return false\n        }\n    }\n    return true\n}\n        \
    \    \nassert(common(l1: [1, 4, 3, 34, 653, 2, 5], l2: [5, 7, 1, 5, 9, 653, 121])\
    \ == [1, 5, 653])\nassert(common(l1: [5, 3, 2, 8], l2: [3, 2]) == [2, 3])\nassert(common(l1:\
    \ [4, 3, 2, 8], l2: [3, 2, 4]) == [2, 3, 4])\nassert(common(l1: [4, 3, 2, 8],\
    \ l2: [] as [Int]) == [] as [Int])"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659979279
- exit_code: 0
  program: "\n/// Return sorted unique common elements for two arrays.\n/// >>> common(l1:\
    \ [1, 4, 3, 34, 653, 2, 5], l2: [5, 7, 1, 5, 9, 653, 121])\n/// [1, 5, 653]\n\
    /// >>> common(l1: [5, 3, 2, 8], l2: [3, 2])\n/// [2, 3]\nfunc common(l1: [Int],\
    \ l2: [Int]) -> [Int] {\n    let l1 = l1.sorted()\n    let l2 = l2.sorted()\n\
    \    var count1 = 0\n    var count2 = 0\n    var res = [Int]()\n    while count1\
    \ < l1.count && count2 < l2.count {\n        if l1[count1] == l2[count2] {\n \
    \           if !res.contains(l1[count1]) {\n                res.append(l1[count1])\n\
    \            }\n            count1 += 1\n            count2 += 1\n        } else\
    \ if l1[count1] < l2[count2] {\n            count1 += 1\n        } else {\n  \
    \          count2 += 1\n        }\n    }\n    return res\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(common(l1: [1, 4, 3, 34, 653, 2, 5], l2: [5, 7, 1, 5,\
    \ 9, 653, 121]) == [1, 5, 653])\nassert(common(l1: [5, 3, 2, 8], l2: [3, 2]) ==\
    \ [2, 3])\nassert(common(l1: [4, 3, 2, 8], l2: [3, 2, 4]) == [2, 3, 4])\nassert(common(l1:\
    \ [4, 3, 2, 8], l2: [] as [Int]) == [] as [Int])"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659979279
- exit_code: 0
  program: "\n/// Return sorted unique common elements for two arrays.\n/// >>> common(l1:\
    \ [1, 4, 3, 34, 653, 2, 5], l2: [5, 7, 1, 5, 9, 653, 121])\n/// [1, 5, 653]\n\
    /// >>> common(l1: [5, 3, 2, 8], l2: [3, 2])\n/// [2, 3]\nfunc common(l1: [Int],\
    \ l2: [Int]) -> [Int] {\n    let l1Set = Set(l1)\n    let l2Set = Set(l2)\n  \
    \  return Array(l1Set.intersection(l2Set)).sorted()\n}\n\n\nfunc ==(left: [(Int,\
    \ Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n\
    \        return false\n    }\n    for (l, r) in zip(left, right) {\n        if\
    \ l != r {\n            return false\n        }\n    }\n    return true\n}\n \
    \           \nassert(common(l1: [1, 4, 3, 34, 653, 2, 5], l2: [5, 7, 1, 5, 9,\
    \ 653, 121]) == [1, 5, 653])\nassert(common(l1: [5, 3, 2, 8], l2: [3, 2]) == [2,\
    \ 3])\nassert(common(l1: [4, 3, 2, 8], l2: [3, 2, 4]) == [2, 3, 4])\nassert(common(l1:\
    \ [4, 3, 2, 8], l2: [] as [Int]) == [] as [Int])"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659979279
- exit_code: 0
  program: "\n/// Return sorted unique common elements for two arrays.\n/// >>> common(l1:\
    \ [1, 4, 3, 34, 653, 2, 5], l2: [5, 7, 1, 5, 9, 653, 121])\n/// [1, 5, 653]\n\
    /// >>> common(l1: [5, 3, 2, 8], l2: [3, 2])\n/// [2, 3]\nfunc common(l1: [Int],\
    \ l2: [Int]) -> [Int] {\n    return l1.filter { l2.contains($0) }.sorted()\n}\n\
    \n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(common(l1: [1, 4, 3, 34, 653, 2, 5], l2: [5, 7,\
    \ 1, 5, 9, 653, 121]) == [1, 5, 653])\nassert(common(l1: [5, 3, 2, 8], l2: [3,\
    \ 2]) == [2, 3])\nassert(common(l1: [4, 3, 2, 8], l2: [3, 2, 4]) == [2, 3, 4])\n\
    assert(common(l1: [4, 3, 2, 8], l2: [] as [Int]) == [] as [Int])"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659979279
- exit_code: 0
  program: "\n/// Return sorted unique common elements for two arrays.\n/// >>> common(l1:\
    \ [1, 4, 3, 34, 653, 2, 5], l2: [5, 7, 1, 5, 9, 653, 121])\n/// [1, 5, 653]\n\
    /// >>> common(l1: [5, 3, 2, 8], l2: [3, 2])\n/// [2, 3]\nfunc common(l1: [Int],\
    \ l2: [Int]) -> [Int] {\n\t// code\n\treturn l1.filter{l2.contains($0)}.sorted()\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(common(l1: [1, 4, 3, 34, 653, 2, 5], l2: [5, 7,\
    \ 1, 5, 9, 653, 121]) == [1, 5, 653])\nassert(common(l1: [5, 3, 2, 8], l2: [3,\
    \ 2]) == [2, 3])\nassert(common(l1: [4, 3, 2, 8], l2: [3, 2, 4]) == [2, 3, 4])\n\
    assert(common(l1: [4, 3, 2, 8], l2: [] as [Int]) == [] as [Int])"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659979279
- exit_code: -4
  program: "\n/// Return sorted unique common elements for two arrays.\n/// >>> common(l1:\
    \ [1, 4, 3, 34, 653, 2, 5], l2: [5, 7, 1, 5, 9, 653, 121])\n/// [1, 5, 653]\n\
    /// >>> common(l1: [5, 3, 2, 8], l2: [3, 2])\n/// [2, 3]\nfunc common(l1: [Int],\
    \ l2: [Int]) -> [Int] {\n  return Array(Set(l1).intersection(Set(l2)))\n}\n\n\n\
    func ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(common(l1: [1, 4, 3, 34, 653, 2, 5], l2: [5, 7,\
    \ 1, 5, 9, 653, 121]) == [1, 5, 653])\nassert(common(l1: [5, 3, 2, 8], l2: [3,\
    \ 2]) == [2, 3])\nassert(common(l1: [4, 3, 2, 8], l2: [3, 2, 4]) == [2, 3, 4])\n\
    assert(common(l1: [4, 3, 2, 8], l2: [] as [Int]) == [] as [Int])"
  status: Exception
  stderr: 'tmpd8kd9pul/tmpd8kd9pul.swift:24: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b0683e05c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b0683afcb6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b0683afc988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b0683afb7b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpd8kd9pul                        0x00005556441e05fc <unavailable> + 5628

    5    libc.so.6                          0x00002b0683ff1460 __libc_start_main +
    245

    6    tmpd8kd9pul                        0x00005556441e0179 <unavailable> + 4473

    '
  stdout: ''
  timestamp: 1659979279
- exit_code: 0
  program: "\n/// Return sorted unique common elements for two arrays.\n/// >>> common(l1:\
    \ [1, 4, 3, 34, 653, 2, 5], l2: [5, 7, 1, 5, 9, 653, 121])\n/// [1, 5, 653]\n\
    /// >>> common(l1: [5, 3, 2, 8], l2: [3, 2])\n/// [2, 3]\nfunc common(l1: [Int],\
    \ l2: [Int]) -> [Int] {\n    var common: [Int] = []\n    let sortedList1 = l1.sorted()\n\
    \    let sortedList2 = l2.sorted()\n    var i = 0\n    var j = 0\n    while i\
    \ < sortedList1.count && j < sortedList2.count {\n        if sortedList1[i] ==\
    \ sortedList2[j] {\n            common.append(sortedList1[i])\n            i +=\
    \ 1\n            j += 1\n        } else if sortedList1[i] < sortedList2[j] {\n\
    \            i += 1\n        } else {\n            j += 1\n        }\n    }\n\
    \    return common\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) ->\
    \ Bool {\n    if left.count != right.count {\n        return false\n    }\n  \
    \  for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(common(l1: [1, 4,\
    \ 3, 34, 653, 2, 5], l2: [5, 7, 1, 5, 9, 653, 121]) == [1, 5, 653])\nassert(common(l1:\
    \ [5, 3, 2, 8], l2: [3, 2]) == [2, 3])\nassert(common(l1: [4, 3, 2, 8], l2: [3,\
    \ 2, 4]) == [2, 3, 4])\nassert(common(l1: [4, 3, 2, 8], l2: [] as [Int]) == []\
    \ as [Int])"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659979279
- exit_code: 1
  program: "\n/// Return sorted unique common elements for two arrays.\n/// >>> common(l1:\
    \ [1, 4, 3, 34, 653, 2, 5], l2: [5, 7, 1, 5, 9, 653, 121])\n/// [1, 5, 653]\n\
    /// >>> common(l1: [5, 3, 2, 8], l2: [3, 2])\n/// [2, 3]\nfunc common(l1: [Int],\
    \ l2: [Int]) -> [Int] {\n    return l1.filter{l2.contains($0)}.unique()\n}\n\n\
    \nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(common(l1: [1, 4, 3, 34, 653, 2, 5], l2: [5, 7,\
    \ 1, 5, 9, 653, 121]) == [1, 5, 653])\nassert(common(l1: [5, 3, 2, 8], l2: [3,\
    \ 2]) == [2, 3])\nassert(common(l1: [4, 3, 2, 8], l2: [3, 2, 4]) == [2, 3, 4])\n\
    assert(common(l1: [4, 3, 2, 8], l2: [] as [Int]) == [] as [Int])"
  status: SyntaxError
  stderr: "/tmp/tmpt1ebt8hl.swift:8:39: error: value of type '[Int]' has no member\
    \ 'unique'\n    return l1.filter{l2.contains($0)}.unique()\n           ~~~~~~~~~~~~~~~~~~~~~~~~~~\
    \ ^~~~~~\n"
  stdout: ''
  timestamp: 1659979279
- exit_code: 0
  program: "\n/// Return sorted unique common elements for two arrays.\n/// >>> common(l1:\
    \ [1, 4, 3, 34, 653, 2, 5], l2: [5, 7, 1, 5, 9, 653, 121])\n/// [1, 5, 653]\n\
    /// >>> common(l1: [5, 3, 2, 8], l2: [3, 2])\n/// [2, 3]\nfunc common(l1: [Int],\
    \ l2: [Int]) -> [Int] {\n    return Array(Set(l1).intersection(Set(l2))).sorted()\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(common(l1: [1, 4, 3, 34, 653, 2, 5], l2: [5, 7,\
    \ 1, 5, 9, 653, 121]) == [1, 5, 653])\nassert(common(l1: [5, 3, 2, 8], l2: [3,\
    \ 2]) == [2, 3])\nassert(common(l1: [4, 3, 2, 8], l2: [3, 2, 4]) == [2, 3, 4])\n\
    assert(common(l1: [4, 3, 2, 8], l2: [] as [Int]) == [] as [Int])"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659979279
- exit_code: -4
  program: "\n/// Return sorted unique common elements for two arrays.\n/// >>> common(l1:\
    \ [1, 4, 3, 34, 653, 2, 5], l2: [5, 7, 1, 5, 9, 653, 121])\n/// [1, 5, 653]\n\
    /// >>> common(l1: [5, 3, 2, 8], l2: [3, 2])\n/// [2, 3]\nfunc common(l1: [Int],\
    \ l2: [Int]) -> [Int] {\n  return Array(Set(l1).intersection(Set(l2)))\n}\n\n\n\
    func ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(common(l1: [1, 4, 3, 34, 653, 2, 5], l2: [5, 7,\
    \ 1, 5, 9, 653, 121]) == [1, 5, 653])\nassert(common(l1: [5, 3, 2, 8], l2: [3,\
    \ 2]) == [2, 3])\nassert(common(l1: [4, 3, 2, 8], l2: [3, 2, 4]) == [2, 3, 4])\n\
    assert(common(l1: [4, 3, 2, 8], l2: [] as [Int]) == [] as [Int])"
  status: Exception
  stderr: 'tmpd8kd9pul/tmpd8kd9pul.swift:24: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b0683e05c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b0683afcb6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b0683afc988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b0683afb7b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpd8kd9pul                        0x00005556441e05fc <unavailable> + 5628

    5    libc.so.6                          0x00002b0683ff1460 __libc_start_main +
    245

    6    tmpd8kd9pul                        0x00005556441e0179 <unavailable> + 4473

    '
  stdout: ''
  timestamp: 1659979279
- exit_code: 0
  program: "\n/// Return sorted unique common elements for two arrays.\n/// >>> common(l1:\
    \ [1, 4, 3, 34, 653, 2, 5], l2: [5, 7, 1, 5, 9, 653, 121])\n/// [1, 5, 653]\n\
    /// >>> common(l1: [5, 3, 2, 8], l2: [3, 2])\n/// [2, 3]\nfunc common(l1: [Int],\
    \ l2: [Int]) -> [Int] {\n    return l1.filter { l2.contains($0) }.sorted()\n}\n\
    \n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(common(l1: [1, 4, 3, 34, 653, 2, 5], l2: [5, 7,\
    \ 1, 5, 9, 653, 121]) == [1, 5, 653])\nassert(common(l1: [5, 3, 2, 8], l2: [3,\
    \ 2]) == [2, 3])\nassert(common(l1: [4, 3, 2, 8], l2: [3, 2, 4]) == [2, 3, 4])\n\
    assert(common(l1: [4, 3, 2, 8], l2: [] as [Int]) == [] as [Int])"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659979279
- exit_code: 0
  program: "\n/// Return sorted unique common elements for two arrays.\n/// >>> common(l1:\
    \ [1, 4, 3, 34, 653, 2, 5], l2: [5, 7, 1, 5, 9, 653, 121])\n/// [1, 5, 653]\n\
    /// >>> common(l1: [5, 3, 2, 8], l2: [3, 2])\n/// [2, 3]\nfunc common(l1: [Int],\
    \ l2: [Int]) -> [Int] {\n    let set1 = Set(l1)\n    let set2 = Set(l2)\n    let\
    \ common = set1.intersection(set2)\n    return Array(common).sorted()\n}\n\n\n\
    func ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(common(l1: [1, 4, 3, 34, 653, 2, 5], l2: [5, 7,\
    \ 1, 5, 9, 653, 121]) == [1, 5, 653])\nassert(common(l1: [5, 3, 2, 8], l2: [3,\
    \ 2]) == [2, 3])\nassert(common(l1: [4, 3, 2, 8], l2: [3, 2, 4]) == [2, 3, 4])\n\
    assert(common(l1: [4, 3, 2, 8], l2: [] as [Int]) == [] as [Int])"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659979279
- exit_code: 0
  program: "\n/// Return sorted unique common elements for two arrays.\n/// >>> common(l1:\
    \ [1, 4, 3, 34, 653, 2, 5], l2: [5, 7, 1, 5, 9, 653, 121])\n/// [1, 5, 653]\n\
    /// >>> common(l1: [5, 3, 2, 8], l2: [3, 2])\n/// [2, 3]\nfunc common(l1: [Int],\
    \ l2: [Int]) -> [Int] {\n    let l1Set = Set(l1)\n    let l2Set = Set(l2)\n  \
    \  return Array(l1Set.intersection(l2Set)).sorted()\n}\n\n\nfunc ==(left: [(Int,\
    \ Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n\
    \        return false\n    }\n    for (l, r) in zip(left, right) {\n        if\
    \ l != r {\n            return false\n        }\n    }\n    return true\n}\n \
    \           \nassert(common(l1: [1, 4, 3, 34, 653, 2, 5], l2: [5, 7, 1, 5, 9,\
    \ 653, 121]) == [1, 5, 653])\nassert(common(l1: [5, 3, 2, 8], l2: [3, 2]) == [2,\
    \ 3])\nassert(common(l1: [4, 3, 2, 8], l2: [3, 2, 4]) == [2, 3, 4])\nassert(common(l1:\
    \ [4, 3, 2, 8], l2: [] as [Int]) == [] as [Int])"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659979279
- exit_code: 0
  program: "\n/// Return sorted unique common elements for two arrays.\n/// >>> common(l1:\
    \ [1, 4, 3, 34, 653, 2, 5], l2: [5, 7, 1, 5, 9, 653, 121])\n/// [1, 5, 653]\n\
    /// >>> common(l1: [5, 3, 2, 8], l2: [3, 2])\n/// [2, 3]\nfunc common(l1: [Int],\
    \ l2: [Int]) -> [Int] {\n    let l1Set = Set(l1)\n    let l2Set = Set(l2)\n  \
    \  let intersection = l1Set.intersection(l2Set)\n    return Array(intersection).sorted()\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(common(l1: [1, 4, 3, 34, 653, 2, 5], l2: [5, 7,\
    \ 1, 5, 9, 653, 121]) == [1, 5, 653])\nassert(common(l1: [5, 3, 2, 8], l2: [3,\
    \ 2]) == [2, 3])\nassert(common(l1: [4, 3, 2, 8], l2: [3, 2, 4]) == [2, 3, 4])\n\
    assert(common(l1: [4, 3, 2, 8], l2: [] as [Int]) == [] as [Int])"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659979279
- exit_code: 0
  program: "\n/// Return sorted unique common elements for two arrays.\n/// >>> common(l1:\
    \ [1, 4, 3, 34, 653, 2, 5], l2: [5, 7, 1, 5, 9, 653, 121])\n/// [1, 5, 653]\n\
    /// >>> common(l1: [5, 3, 2, 8], l2: [3, 2])\n/// [2, 3]\nfunc common(l1: [Int],\
    \ l2: [Int]) -> [Int] {\n    var result = [Int]()\n    var l1 = l1\n    var l2\
    \ = l2\n    l1.sort()\n    l2.sort()\n    var i = 0\n    var j = 0\n    while\
    \ i < l1.count && j < l2.count {\n        if l1[i] == l2[j] {\n            result.append(l1[i])\n\
    \            i += 1\n            j += 1\n        } else if l1[i] < l2[j] {\n \
    \           i += 1\n        } else {\n            j += 1\n        }\n    }\n \
    \   return result\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) ->\
    \ Bool {\n    if left.count != right.count {\n        return false\n    }\n  \
    \  for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(common(l1: [1, 4,\
    \ 3, 34, 653, 2, 5], l2: [5, 7, 1, 5, 9, 653, 121]) == [1, 5, 653])\nassert(common(l1:\
    \ [5, 3, 2, 8], l2: [3, 2]) == [2, 3])\nassert(common(l1: [4, 3, 2, 8], l2: [3,\
    \ 2, 4]) == [2, 3, 4])\nassert(common(l1: [4, 3, 2, 8], l2: [] as [Int]) == []\
    \ as [Int])"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659979279
- exit_code: 0
  program: "\n/// Return sorted unique common elements for two arrays.\n/// >>> common(l1:\
    \ [1, 4, 3, 34, 653, 2, 5], l2: [5, 7, 1, 5, 9, 653, 121])\n/// [1, 5, 653]\n\
    /// >>> common(l1: [5, 3, 2, 8], l2: [3, 2])\n/// [2, 3]\nfunc common(l1: [Int],\
    \ l2: [Int]) -> [Int] {\n\tlet a1 = l1.sorted(by: <)\n\tlet a2 = l2.sorted(by:\
    \ <)\n\t\n\tvar result = [Int]()\n\tvar index = 0\n\tfor i in 0..<a1.count {\n\
    \t\tif index >= a2.count {\n\t\t\tbreak\n\t\t}\n\t\tif a1[i] == a2[index] {\n\t\
    \t\tresult.append(a1[i])\n\t\t\twhile index < a2.count && a2[index] == a1[i] {\n\
    \t\t\t\tindex += 1\n\t\t\t}\n\t\t} else if a1[i] > a2[index] {\n\t\t\twhile index\
    \ < a2.count && a2[index] < a1[i] {\n\t\t\t\tindex += 1\n\t\t\t}\n\t\t\tif index\
    \ >= a2.count {\n\t\t\t\tbreak\n\t\t\t}\n\t\t\tif a1[i] == a2[index] {\n\t\t\t\
    \tresult.append(a1[i])\n\t\t\t\twhile index < a2.count && a2[index] == a1[i] {\n\
    \t\t\t\t\tindex += 1\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\treturn result\n}\n\n\n\
    func ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(common(l1: [1, 4, 3, 34, 653, 2, 5], l2: [5, 7,\
    \ 1, 5, 9, 653, 121]) == [1, 5, 653])\nassert(common(l1: [5, 3, 2, 8], l2: [3,\
    \ 2]) == [2, 3])\nassert(common(l1: [4, 3, 2, 8], l2: [3, 2, 4]) == [2, 3, 4])\n\
    assert(common(l1: [4, 3, 2, 8], l2: [] as [Int]) == [] as [Int])"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659979279
- exit_code: -4
  program: "\n/// Return sorted unique common elements for two arrays.\n/// >>> common(l1:\
    \ [1, 4, 3, 34, 653, 2, 5], l2: [5, 7, 1, 5, 9, 653, 121])\n/// [1, 5, 653]\n\
    /// >>> common(l1: [5, 3, 2, 8], l2: [3, 2])\n/// [2, 3]\nfunc common(l1: [Int],\
    \ l2: [Int]) -> [Int] {\n    var res = Set<Int>()\n    var p1 = 0\n    var p2\
    \ = 0\n    while p1 < l1.count && p2 < l2.count {\n        if l1[p1] == l2[p2]\
    \ {\n            res.insert(l1[p1])\n            p1 += 1\n            p2 += 1\n\
    \        } else if l1[p1] < l2[p2] {\n            p1 += 1\n        } else {\n\
    \            p2 += 1\n        }\n    }\n    return Array(res)\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(common(l1: [1, 4, 3, 34, 653, 2, 5], l2: [5, 7, 1, 5,\
    \ 9, 653, 121]) == [1, 5, 653])\nassert(common(l1: [5, 3, 2, 8], l2: [3, 2]) ==\
    \ [2, 3])\nassert(common(l1: [4, 3, 2, 8], l2: [3, 2, 4]) == [2, 3, 4])\nassert(common(l1:\
    \ [4, 3, 2, 8], l2: [] as [Int]) == [] as [Int])"
  status: Exception
  stderr: 'tmpqd8yicxg/tmpqd8yicxg.swift:38: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b7e064bfc80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b7e061b6b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b7e061b6988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b7e061b57b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpqd8yicxg                        0x0000556cb612a6ac <unavailable> + 5804

    5    libc.so.6                          0x00002b7e066ab460 __libc_start_main +
    245

    6    tmpqd8yicxg                        0x0000556cb612a229 <unavailable> + 4649

    '
  stdout: ''
  timestamp: 1659979279
- exit_code: -4
  program: "\n/// Return sorted unique common elements for two arrays.\n/// >>> common(l1:\
    \ [1, 4, 3, 34, 653, 2, 5], l2: [5, 7, 1, 5, 9, 653, 121])\n/// [1, 5, 653]\n\
    /// >>> common(l1: [5, 3, 2, 8], l2: [3, 2])\n/// [2, 3]\nfunc common(l1: [Int],\
    \ l2: [Int]) -> [Int] {\n    let n1 = l1.count\n    let n2 = l2.count\n    let\
    \ n = min(n1, n2)\n    var c: [Int] = []\n    var i = 0\n    var j = 0\n    while\
    \ i < n1 && j < n2 {\n        if l1[i] < l2[j] {\n            i += 1\n       \
    \ } else if l1[i] > l2[j] {\n            j += 1\n        } else {\n          \
    \  c.append(l1[i])\n            i += 1\n            j += 1\n        }\n    }\n\
    \    return c\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool\
    \ {\n    if left.count != right.count {\n        return false\n    }\n    for\
    \ (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(common(l1: [1, 4,\
    \ 3, 34, 653, 2, 5], l2: [5, 7, 1, 5, 9, 653, 121]) == [1, 5, 653])\nassert(common(l1:\
    \ [5, 3, 2, 8], l2: [3, 2]) == [2, 3])\nassert(common(l1: [4, 3, 2, 8], l2: [3,\
    \ 2, 4]) == [2, 3, 4])\nassert(common(l1: [4, 3, 2, 8], l2: [] as [Int]) == []\
    \ as [Int])"
  status: Exception
  stderr: 'tmpc3t51xv5/tmpc3t51xv5.swift:41: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b16aa481c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b16aa178b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b16aa178988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b16aa1777b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpc3t51xv5                        0x000056378f5485ec <unavailable> + 5612

    5    libc.so.6                          0x00002b16aa66d460 __libc_start_main +
    245

    6    tmpc3t51xv5                        0x000056378f548169 <unavailable> + 4457

    '
  stdout: ''
  timestamp: 1659979279
- exit_code: 0
  program: "\n/// Return sorted unique common elements for two arrays.\n/// >>> common(l1:\
    \ [1, 4, 3, 34, 653, 2, 5], l2: [5, 7, 1, 5, 9, 653, 121])\n/// [1, 5, 653]\n\
    /// >>> common(l1: [5, 3, 2, 8], l2: [3, 2])\n/// [2, 3]\nfunc common(l1: [Int],\
    \ l2: [Int]) -> [Int] {\n    let set1 = Set(l1)\n    let set2 = Set(l2)\n    let\
    \ common = set1.intersection(set2)\n    return Array(common).sorted()\n}\n\n\n\
    func ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(common(l1: [1, 4, 3, 34, 653, 2, 5], l2: [5, 7,\
    \ 1, 5, 9, 653, 121]) == [1, 5, 653])\nassert(common(l1: [5, 3, 2, 8], l2: [3,\
    \ 2]) == [2, 3])\nassert(common(l1: [4, 3, 2, 8], l2: [3, 2, 4]) == [2, 3, 4])\n\
    assert(common(l1: [4, 3, 2, 8], l2: [] as [Int]) == [] as [Int])"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659979279
- exit_code: 0
  program: "\n/// Return sorted unique common elements for two arrays.\n/// >>> common(l1:\
    \ [1, 4, 3, 34, 653, 2, 5], l2: [5, 7, 1, 5, 9, 653, 121])\n/// [1, 5, 653]\n\
    /// >>> common(l1: [5, 3, 2, 8], l2: [3, 2])\n/// [2, 3]\nfunc common(l1: [Int],\
    \ l2: [Int]) -> [Int] {\n    let set1 = Set(l1)\n    let set2 = Set(l2)\n    return\
    \ Array(set1.intersection(set2)).sorted()\n}\n\n\nfunc ==(left: [(Int, Int)],\
    \ right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n       \
    \ return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r\
    \ {\n            return false\n        }\n    }\n    return true\n}\n        \
    \    \nassert(common(l1: [1, 4, 3, 34, 653, 2, 5], l2: [5, 7, 1, 5, 9, 653, 121])\
    \ == [1, 5, 653])\nassert(common(l1: [5, 3, 2, 8], l2: [3, 2]) == [2, 3])\nassert(common(l1:\
    \ [4, 3, 2, 8], l2: [3, 2, 4]) == [2, 3, 4])\nassert(common(l1: [4, 3, 2, 8],\
    \ l2: [] as [Int]) == [] as [Int])"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659979279
- exit_code: 0
  program: "\n/// Return sorted unique common elements for two arrays.\n/// >>> common(l1:\
    \ [1, 4, 3, 34, 653, 2, 5], l2: [5, 7, 1, 5, 9, 653, 121])\n/// [1, 5, 653]\n\
    /// >>> common(l1: [5, 3, 2, 8], l2: [3, 2])\n/// [2, 3]\nfunc common(l1: [Int],\
    \ l2: [Int]) -> [Int] {\n    let s1 = Set(l1)\n    let s2 = Set(l2)\n    return\
    \ Array(s1.intersection(s2)).sorted()\n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(common(l1: [1, 4, 3, 34, 653, 2, 5], l2: [5, 7, 1, 5, 9, 653, 121]) ==\
    \ [1, 5, 653])\nassert(common(l1: [5, 3, 2, 8], l2: [3, 2]) == [2, 3])\nassert(common(l1:\
    \ [4, 3, 2, 8], l2: [3, 2, 4]) == [2, 3, 4])\nassert(common(l1: [4, 3, 2, 8],\
    \ l2: [] as [Int]) == [] as [Int])"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659979279
- exit_code: 0
  program: "\n/// Return sorted unique common elements for two arrays.\n/// >>> common(l1:\
    \ [1, 4, 3, 34, 653, 2, 5], l2: [5, 7, 1, 5, 9, 653, 121])\n/// [1, 5, 653]\n\
    /// >>> common(l1: [5, 3, 2, 8], l2: [3, 2])\n/// [2, 3]\nfunc common(l1: [Int],\
    \ l2: [Int]) -> [Int] {\n  return Set(l1).intersection(Set(l2)).sorted()\n}\n\n\
    \nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(common(l1: [1, 4, 3, 34, 653, 2, 5], l2: [5, 7,\
    \ 1, 5, 9, 653, 121]) == [1, 5, 653])\nassert(common(l1: [5, 3, 2, 8], l2: [3,\
    \ 2]) == [2, 3])\nassert(common(l1: [4, 3, 2, 8], l2: [3, 2, 4]) == [2, 3, 4])\n\
    assert(common(l1: [4, 3, 2, 8], l2: [] as [Int]) == [] as [Int])"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659979279
- exit_code: -4
  program: "\n/// Return sorted unique common elements for two arrays.\n/// >>> common(l1:\
    \ [1, 4, 3, 34, 653, 2, 5], l2: [5, 7, 1, 5, 9, 653, 121])\n/// [1, 5, 653]\n\
    /// >>> common(l1: [5, 3, 2, 8], l2: [3, 2])\n/// [2, 3]\nfunc common(l1: [Int],\
    \ l2: [Int]) -> [Int] {\n    var a = Array(Set(l1)), b = Array(Set(l2))\n    var\
    \ c = [Int]()\n    while !a.isEmpty && !b.isEmpty {\n        if a.first! < b.first!\
    \ {\n            a.removeFirst()\n        } else if a.first! > b.first! {\n  \
    \          b.removeFirst()\n        } else {\n            c.append(a.removeFirst())\n\
    \            b.removeFirst()\n        }\n    }\n    return c\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(common(l1: [1, 4, 3, 34, 653, 2, 5], l2: [5, 7, 1, 5,\
    \ 9, 653, 121]) == [1, 5, 653])\nassert(common(l1: [5, 3, 2, 8], l2: [3, 2]) ==\
    \ [2, 3])\nassert(common(l1: [4, 3, 2, 8], l2: [3, 2, 4]) == [2, 3, 4])\nassert(common(l1:\
    \ [4, 3, 2, 8], l2: [] as [Int]) == [] as [Int])"
  status: Exception
  stderr: 'tmp4zrpedsj/tmp4zrpedsj.swift:36: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b264ff7fc80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b264fc76b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b264fc76988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b264fc757b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmp4zrpedsj                        0x00005599f456c87c <unavailable> + 6268

    5    libc.so.6                          0x00002b265016b460 __libc_start_main +
    245

    6    tmp4zrpedsj                        0x00005599f456c3f9 <unavailable> + 5113

    '
  stdout: ''
  timestamp: 1659979279
- exit_code: 0
  program: "\n/// Return sorted unique common elements for two arrays.\n/// >>> common(l1:\
    \ [1, 4, 3, 34, 653, 2, 5], l2: [5, 7, 1, 5, 9, 653, 121])\n/// [1, 5, 653]\n\
    /// >>> common(l1: [5, 3, 2, 8], l2: [3, 2])\n/// [2, 3]\nfunc common(l1: [Int],\
    \ l2: [Int]) -> [Int] {\n    var s1 = Set(l1)\n    var s2 = Set(l2)\n    s1.formIntersection(s2)\n\
    \    return Array(s1).sorted()\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int,\
    \ Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n\
    \    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n          \
    \  return false\n        }\n    }\n    return true\n}\n            \nassert(common(l1:\
    \ [1, 4, 3, 34, 653, 2, 5], l2: [5, 7, 1, 5, 9, 653, 121]) == [1, 5, 653])\nassert(common(l1:\
    \ [5, 3, 2, 8], l2: [3, 2]) == [2, 3])\nassert(common(l1: [4, 3, 2, 8], l2: [3,\
    \ 2, 4]) == [2, 3, 4])\nassert(common(l1: [4, 3, 2, 8], l2: [] as [Int]) == []\
    \ as [Int])"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659979279
- exit_code: 0
  program: "\n/// Return sorted unique common elements for two arrays.\n/// >>> common(l1:\
    \ [1, 4, 3, 34, 653, 2, 5], l2: [5, 7, 1, 5, 9, 653, 121])\n/// [1, 5, 653]\n\
    /// >>> common(l1: [5, 3, 2, 8], l2: [3, 2])\n/// [2, 3]\nfunc common(l1: [Int],\
    \ l2: [Int]) -> [Int] {\n    guard l1.count > 0 && l2.count > 0 else { return\
    \ [] }\n    let x = l1.reduce(into: [Int]()) { (res, e) in if l2.contains(e) {\
    \ res.append(e) } }\n    return Array(Set(x)).sorted()\n}\n\n\nfunc ==(left: [(Int,\
    \ Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n\
    \        return false\n    }\n    for (l, r) in zip(left, right) {\n        if\
    \ l != r {\n            return false\n        }\n    }\n    return true\n}\n \
    \           \nassert(common(l1: [1, 4, 3, 34, 653, 2, 5], l2: [5, 7, 1, 5, 9,\
    \ 653, 121]) == [1, 5, 653])\nassert(common(l1: [5, 3, 2, 8], l2: [3, 2]) == [2,\
    \ 3])\nassert(common(l1: [4, 3, 2, 8], l2: [3, 2, 4]) == [2, 3, 4])\nassert(common(l1:\
    \ [4, 3, 2, 8], l2: [] as [Int]) == [] as [Int])"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659979279
- exit_code: 0
  program: "\n/// Return sorted unique common elements for two arrays.\n/// >>> common(l1:\
    \ [1, 4, 3, 34, 653, 2, 5], l2: [5, 7, 1, 5, 9, 653, 121])\n/// [1, 5, 653]\n\
    /// >>> common(l1: [5, 3, 2, 8], l2: [3, 2])\n/// [2, 3]\nfunc common(l1: [Int],\
    \ l2: [Int]) -> [Int] {\n    let a1 = l1.sorted()\n    let a2 = l2.sorted()\n\
    \    var c = [Int]()\n    var i = 0\n    var j = 0\n    while i < a1.count &&\
    \ j < a2.count {\n        if a1[i] == a2[j] {\n            c.append(a1[i])\n \
    \           i += 1\n            j += 1\n        } else if a1[i] < a2[j] {\n  \
    \          i += 1\n        } else {\n            j += 1\n        }\n    }\n  \
    \  return c\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n\
    \    if left.count != right.count {\n        return false\n    }\n    for (l,\
    \ r) in zip(left, right) {\n        if l != r {\n            return false\n  \
    \      }\n    }\n    return true\n}\n            \nassert(common(l1: [1, 4, 3,\
    \ 34, 653, 2, 5], l2: [5, 7, 1, 5, 9, 653, 121]) == [1, 5, 653])\nassert(common(l1:\
    \ [5, 3, 2, 8], l2: [3, 2]) == [2, 3])\nassert(common(l1: [4, 3, 2, 8], l2: [3,\
    \ 2, 4]) == [2, 3, 4])\nassert(common(l1: [4, 3, 2, 8], l2: [] as [Int]) == []\
    \ as [Int])"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659979279
- exit_code: 1
  program: "\n/// Return sorted unique common elements for two arrays.\n/// >>> common(l1:\
    \ [1, 4, 3, 34, 653, 2, 5], l2: [5, 7, 1, 5, 9, 653, 121])\n/// [1, 5, 653]\n\
    /// >>> common(l1: [5, 3, 2, 8], l2: [3, 2])\n/// [2, 3]\nfunc common(l1: [Int],\
    \ l2: [Int]) -> [Int] {\n    return l1.filter { l2.contains($0) }.sorted().uniq()\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(common(l1: [1, 4, 3, 34, 653, 2, 5], l2: [5, 7,\
    \ 1, 5, 9, 653, 121]) == [1, 5, 653])\nassert(common(l1: [5, 3, 2, 8], l2: [3,\
    \ 2]) == [2, 3])\nassert(common(l1: [4, 3, 2, 8], l2: [3, 2, 4]) == [2, 3, 4])\n\
    assert(common(l1: [4, 3, 2, 8], l2: [] as [Int]) == [] as [Int])"
  status: SyntaxError
  stderr: "/tmp/tmpn92tm7_l.swift:8:51: error: value of type '[Int]' has no member\
    \ 'uniq'\n    return l1.filter { l2.contains($0) }.sorted().uniq()\n         \
    \  ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ ^~~~\n"
  stdout: ''
  timestamp: 1659979279
- exit_code: -4
  program: "\n/// Return sorted unique common elements for two arrays.\n/// >>> common(l1:\
    \ [1, 4, 3, 34, 653, 2, 5], l2: [5, 7, 1, 5, 9, 653, 121])\n/// [1, 5, 653]\n\
    /// >>> common(l1: [5, 3, 2, 8], l2: [3, 2])\n/// [2, 3]\nfunc common(l1: [Int],\
    \ l2: [Int]) -> [Int] {\n    // Get only the elements that the other array contains.\n\
    \    let inter = l1.filter { l2.contains($0) }\n    // Return the uniques.\n \
    \   return inter.reduce([]) { $0.contains($1) ? $0 : $0 + [$1] }\n}\n\n\nfunc\
    \ ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count !=\
    \ right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(common(l1: [1, 4, 3, 34, 653, 2, 5], l2: [5, 7,\
    \ 1, 5, 9, 653, 121]) == [1, 5, 653])\nassert(common(l1: [5, 3, 2, 8], l2: [3,\
    \ 2]) == [2, 3])\nassert(common(l1: [4, 3, 2, 8], l2: [3, 2, 4]) == [2, 3, 4])\n\
    assert(common(l1: [4, 3, 2, 8], l2: [] as [Int]) == [] as [Int])"
  status: Exception
  stderr: 'tmpamrmu2t4/tmpamrmu2t4.swift:27: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b4e4d3c6c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b4e4d0bdb6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b4e4d0bd988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b4e4d0bc7b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpamrmu2t4                        0x00005599455ca64c <unavailable> + 5708

    5    libc.so.6                          0x00002b4e4d5b2460 __libc_start_main +
    245

    6    tmpamrmu2t4                        0x00005599455ca1c9 <unavailable> + 4553

    '
  stdout: ''
  timestamp: 1659979279
- exit_code: -4
  program: "\n/// Return sorted unique common elements for two arrays.\n/// >>> common(l1:\
    \ [1, 4, 3, 34, 653, 2, 5], l2: [5, 7, 1, 5, 9, 653, 121])\n/// [1, 5, 653]\n\
    /// >>> common(l1: [5, 3, 2, 8], l2: [3, 2])\n/// [2, 3]\nfunc common(l1: [Int],\
    \ l2: [Int]) -> [Int] {\n    return []\n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(common(l1: [1, 4, 3, 34, 653, 2, 5], l2: [5, 7, 1, 5, 9, 653, 121]) ==\
    \ [1, 5, 653])\nassert(common(l1: [5, 3, 2, 8], l2: [3, 2]) == [2, 3])\nassert(common(l1:\
    \ [4, 3, 2, 8], l2: [3, 2, 4]) == [2, 3, 4])\nassert(common(l1: [4, 3, 2, 8],\
    \ l2: [] as [Int]) == [] as [Int])"
  status: Exception
  stderr: 'tmpxe4ju921/tmpxe4ju921.swift:24: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b32fbf71c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b32fbc68b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b32fbc68988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b32fbc677b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpxe4ju921                        0x000055b04303844c <unavailable> + 5196

    5    libc.so.6                          0x00002b32fc15d460 __libc_start_main +
    245

    6    tmpxe4ju921                        0x000055b043037fc9 <unavailable> + 4041

    '
  stdout: ''
  timestamp: 1659979279
- exit_code: -4
  program: "\n/// Return sorted unique common elements for two arrays.\n/// >>> common(l1:\
    \ [1, 4, 3, 34, 653, 2, 5], l2: [5, 7, 1, 5, 9, 653, 121])\n/// [1, 5, 653]\n\
    /// >>> common(l1: [5, 3, 2, 8], l2: [3, 2])\n/// [2, 3]\nfunc common(l1: [Int],\
    \ l2: [Int]) -> [Int] {\n    return Array(Set(l1).intersection(Set(l2)))\n}\n\n\
    \nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(common(l1: [1, 4, 3, 34, 653, 2, 5], l2: [5, 7,\
    \ 1, 5, 9, 653, 121]) == [1, 5, 653])\nassert(common(l1: [5, 3, 2, 8], l2: [3,\
    \ 2]) == [2, 3])\nassert(common(l1: [4, 3, 2, 8], l2: [3, 2, 4]) == [2, 3, 4])\n\
    assert(common(l1: [4, 3, 2, 8], l2: [] as [Int]) == [] as [Int])"
  status: Exception
  stderr: 'tmpzxefsmhz/tmpzxefsmhz.swift:24: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b9cc80f7c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b9cc7deeb6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b9cc7dee988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b9cc7ded7b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpzxefsmhz                        0x0000564df22865fc <unavailable> + 5628

    5    libc.so.6                          0x00002b9cc82e3460 __libc_start_main +
    245

    6    tmpzxefsmhz                        0x0000564df2286179 <unavailable> + 4473

    '
  stdout: ''
  timestamp: 1659979279
- exit_code: 0
  program: "\n/// Return sorted unique common elements for two arrays.\n/// >>> common(l1:\
    \ [1, 4, 3, 34, 653, 2, 5], l2: [5, 7, 1, 5, 9, 653, 121])\n/// [1, 5, 653]\n\
    /// >>> common(l1: [5, 3, 2, 8], l2: [3, 2])\n/// [2, 3]\nfunc common(l1: [Int],\
    \ l2: [Int]) -> [Int] {\n    return l1.filter { l2.contains($0) }.sorted { $0\
    \ < $1 }\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n\
    \    if left.count != right.count {\n        return false\n    }\n    for (l,\
    \ r) in zip(left, right) {\n        if l != r {\n            return false\n  \
    \      }\n    }\n    return true\n}\n            \nassert(common(l1: [1, 4, 3,\
    \ 34, 653, 2, 5], l2: [5, 7, 1, 5, 9, 653, 121]) == [1, 5, 653])\nassert(common(l1:\
    \ [5, 3, 2, 8], l2: [3, 2]) == [2, 3])\nassert(common(l1: [4, 3, 2, 8], l2: [3,\
    \ 2, 4]) == [2, 3, 4])\nassert(common(l1: [4, 3, 2, 8], l2: [] as [Int]) == []\
    \ as [Int])"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659979279
- exit_code: 0
  program: "\n/// Return sorted unique common elements for two arrays.\n/// >>> common(l1:\
    \ [1, 4, 3, 34, 653, 2, 5], l2: [5, 7, 1, 5, 9, 653, 121])\n/// [1, 5, 653]\n\
    /// >>> common(l1: [5, 3, 2, 8], l2: [3, 2])\n/// [2, 3]\nfunc common(l1: [Int],\
    \ l2: [Int]) -> [Int] {\n    let set1 = Set(l1)\n    let set2 = Set(l2)\n    return\
    \ Array(set1.intersection(set2)).sorted()\n}\n\n\nfunc ==(left: [(Int, Int)],\
    \ right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n       \
    \ return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r\
    \ {\n            return false\n        }\n    }\n    return true\n}\n        \
    \    \nassert(common(l1: [1, 4, 3, 34, 653, 2, 5], l2: [5, 7, 1, 5, 9, 653, 121])\
    \ == [1, 5, 653])\nassert(common(l1: [5, 3, 2, 8], l2: [3, 2]) == [2, 3])\nassert(common(l1:\
    \ [4, 3, 2, 8], l2: [3, 2, 4]) == [2, 3, 4])\nassert(common(l1: [4, 3, 2, 8],\
    \ l2: [] as [Int]) == [] as [Int])"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659979279
- exit_code: -4
  program: "\n/// Return sorted unique common elements for two arrays.\n/// >>> common(l1:\
    \ [1, 4, 3, 34, 653, 2, 5], l2: [5, 7, 1, 5, 9, 653, 121])\n/// [1, 5, 653]\n\
    /// >>> common(l1: [5, 3, 2, 8], l2: [3, 2])\n/// [2, 3]\nfunc common(l1: [Int],\
    \ l2: [Int]) -> [Int] {\n\tlet arr = l1 + l2\n\treturn Array(Set(arr)).sorted()\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(common(l1: [1, 4, 3, 34, 653, 2, 5], l2: [5, 7,\
    \ 1, 5, 9, 653, 121]) == [1, 5, 653])\nassert(common(l1: [5, 3, 2, 8], l2: [3,\
    \ 2]) == [2, 3])\nassert(common(l1: [4, 3, 2, 8], l2: [3, 2, 4]) == [2, 3, 4])\n\
    assert(common(l1: [4, 3, 2, 8], l2: [] as [Int]) == [] as [Int])"
  status: Exception
  stderr: 'tmp4bmf28tp/tmp4bmf28tp.swift:25: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b1eb6289c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b1eb5f80b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b1eb5f80988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b1eb5f7f7b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmp4bmf28tp                        0x000055d07c7aa6ac <unavailable> + 5804

    5    libc.so.6                          0x00002b1eb6475460 __libc_start_main +
    245

    6    tmp4bmf28tp                        0x000055d07c7aa229 <unavailable> + 4649

    '
  stdout: ''
  timestamp: 1659979279
- exit_code: 0
  program: "\n/// Return sorted unique common elements for two arrays.\n/// >>> common(l1:\
    \ [1, 4, 3, 34, 653, 2, 5], l2: [5, 7, 1, 5, 9, 653, 121])\n/// [1, 5, 653]\n\
    /// >>> common(l1: [5, 3, 2, 8], l2: [3, 2])\n/// [2, 3]\nfunc common(l1: [Int],\
    \ l2: [Int]) -> [Int] {\n    let items = Set(l1).intersection(Set(l2))\n    return\
    \ Array(items).sorted()\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(common(l1:\
    \ [1, 4, 3, 34, 653, 2, 5], l2: [5, 7, 1, 5, 9, 653, 121]) == [1, 5, 653])\nassert(common(l1:\
    \ [5, 3, 2, 8], l2: [3, 2]) == [2, 3])\nassert(common(l1: [4, 3, 2, 8], l2: [3,\
    \ 2, 4]) == [2, 3, 4])\nassert(common(l1: [4, 3, 2, 8], l2: [] as [Int]) == []\
    \ as [Int])"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659979279
- exit_code: -4
  program: "\n/// Return sorted unique common elements for two arrays.\n/// >>> common(l1:\
    \ [1, 4, 3, 34, 653, 2, 5], l2: [5, 7, 1, 5, 9, 653, 121])\n/// [1, 5, 653]\n\
    /// >>> common(l1: [5, 3, 2, 8], l2: [3, 2])\n/// [2, 3]\nfunc common(l1: [Int],\
    \ l2: [Int]) -> [Int] {\n    return Array(Set(l1).intersection(Set(l2)))\n}\n\n\
    \nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(common(l1: [1, 4, 3, 34, 653, 2, 5], l2: [5, 7,\
    \ 1, 5, 9, 653, 121]) == [1, 5, 653])\nassert(common(l1: [5, 3, 2, 8], l2: [3,\
    \ 2]) == [2, 3])\nassert(common(l1: [4, 3, 2, 8], l2: [3, 2, 4]) == [2, 3, 4])\n\
    assert(common(l1: [4, 3, 2, 8], l2: [] as [Int]) == [] as [Int])"
  status: Exception
  stderr: 'tmpzxefsmhz/tmpzxefsmhz.swift:24: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b9cc80f7c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b9cc7deeb6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b9cc7dee988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b9cc7ded7b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpzxefsmhz                        0x0000564df22865fc <unavailable> + 5628

    5    libc.so.6                          0x00002b9cc82e3460 __libc_start_main +
    245

    6    tmpzxefsmhz                        0x0000564df2286179 <unavailable> + 4473

    '
  stdout: ''
  timestamp: 1659979279
- exit_code: -4
  program: "\n/// Return sorted unique common elements for two arrays.\n/// >>> common(l1:\
    \ [1, 4, 3, 34, 653, 2, 5], l2: [5, 7, 1, 5, 9, 653, 121])\n/// [1, 5, 653]\n\
    /// >>> common(l1: [5, 3, 2, 8], l2: [3, 2])\n/// [2, 3]\nfunc common(l1: [Int],\
    \ l2: [Int]) -> [Int] {\n    // TODO: Write me\n    return []\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(common(l1: [1, 4, 3, 34, 653, 2, 5], l2: [5, 7, 1, 5,\
    \ 9, 653, 121]) == [1, 5, 653])\nassert(common(l1: [5, 3, 2, 8], l2: [3, 2]) ==\
    \ [2, 3])\nassert(common(l1: [4, 3, 2, 8], l2: [3, 2, 4]) == [2, 3, 4])\nassert(common(l1:\
    \ [4, 3, 2, 8], l2: [] as [Int]) == [] as [Int])"
  status: Exception
  stderr: 'tmpv5ubwmnm/tmpv5ubwmnm.swift:25: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b0e89958c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b0e8964fb6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b0e8964f988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b0e8964e7b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpv5ubwmnm                        0x000055840a3b844c <unavailable> + 5196

    5    libc.so.6                          0x00002b0e89b44460 __libc_start_main +
    245

    6    tmpv5ubwmnm                        0x000055840a3b7fc9 <unavailable> + 4041

    '
  stdout: ''
  timestamp: 1659979279
- exit_code: 0
  program: "\n/// Return sorted unique common elements for two arrays.\n/// >>> common(l1:\
    \ [1, 4, 3, 34, 653, 2, 5], l2: [5, 7, 1, 5, 9, 653, 121])\n/// [1, 5, 653]\n\
    /// >>> common(l1: [5, 3, 2, 8], l2: [3, 2])\n/// [2, 3]\nfunc common(l1: [Int],\
    \ l2: [Int]) -> [Int] {\n    let s1 = Set(l1)\n    let s2 = Set(l2)\n    return\
    \ Array(s1.intersection(s2)).sorted()\n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(common(l1: [1, 4, 3, 34, 653, 2, 5], l2: [5, 7, 1, 5, 9, 653, 121]) ==\
    \ [1, 5, 653])\nassert(common(l1: [5, 3, 2, 8], l2: [3, 2]) == [2, 3])\nassert(common(l1:\
    \ [4, 3, 2, 8], l2: [3, 2, 4]) == [2, 3, 4])\nassert(common(l1: [4, 3, 2, 8],\
    \ l2: [] as [Int]) == [] as [Int])"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659979279
- exit_code: 0
  program: "\n/// Return sorted unique common elements for two arrays.\n/// >>> common(l1:\
    \ [1, 4, 3, 34, 653, 2, 5], l2: [5, 7, 1, 5, 9, 653, 121])\n/// [1, 5, 653]\n\
    /// >>> common(l1: [5, 3, 2, 8], l2: [3, 2])\n/// [2, 3]\nfunc common(l1: [Int],\
    \ l2: [Int]) -> [Int] {\n    let commonElements = l1.filter { l2.contains($0)\
    \ }\n    return commonElements.sorted()\n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(common(l1: [1, 4, 3, 34, 653, 2, 5], l2: [5, 7, 1, 5, 9, 653, 121]) ==\
    \ [1, 5, 653])\nassert(common(l1: [5, 3, 2, 8], l2: [3, 2]) == [2, 3])\nassert(common(l1:\
    \ [4, 3, 2, 8], l2: [3, 2, 4]) == [2, 3, 4])\nassert(common(l1: [4, 3, 2, 8],\
    \ l2: [] as [Int]) == [] as [Int])"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659979279
- exit_code: 0
  program: "\n/// Return sorted unique common elements for two arrays.\n/// >>> common(l1:\
    \ [1, 4, 3, 34, 653, 2, 5], l2: [5, 7, 1, 5, 9, 653, 121])\n/// [1, 5, 653]\n\
    /// >>> common(l1: [5, 3, 2, 8], l2: [3, 2])\n/// [2, 3]\nfunc common(l1: [Int],\
    \ l2: [Int]) -> [Int] {\n    let set1 = Set(l1)\n    let set2 = Set(l2)\n    let\
    \ intersection = set1.intersection(set2)\n    return Array(intersection).sorted()\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(common(l1: [1, 4, 3, 34, 653, 2, 5], l2: [5, 7,\
    \ 1, 5, 9, 653, 121]) == [1, 5, 653])\nassert(common(l1: [5, 3, 2, 8], l2: [3,\
    \ 2]) == [2, 3])\nassert(common(l1: [4, 3, 2, 8], l2: [3, 2, 4]) == [2, 3, 4])\n\
    assert(common(l1: [4, 3, 2, 8], l2: [] as [Int]) == [] as [Int])"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659979279
- exit_code: 0
  program: "\n/// Return sorted unique common elements for two arrays.\n/// >>> common(l1:\
    \ [1, 4, 3, 34, 653, 2, 5], l2: [5, 7, 1, 5, 9, 653, 121])\n/// [1, 5, 653]\n\
    /// >>> common(l1: [5, 3, 2, 8], l2: [3, 2])\n/// [2, 3]\nfunc common(l1: [Int],\
    \ l2: [Int]) -> [Int] {\n    var list = l1\n    var set: Set<Int> = []\n    for\
    \ element in l2 {\n        if list.contains(element) {\n            set.insert(element)\n\
    \        }\n    }\n    return Array(set.sorted())\n}\n\n\nfunc ==(left: [(Int,\
    \ Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n\
    \        return false\n    }\n    for (l, r) in zip(left, right) {\n        if\
    \ l != r {\n            return false\n        }\n    }\n    return true\n}\n \
    \           \nassert(common(l1: [1, 4, 3, 34, 653, 2, 5], l2: [5, 7, 1, 5, 9,\
    \ 653, 121]) == [1, 5, 653])\nassert(common(l1: [5, 3, 2, 8], l2: [3, 2]) == [2,\
    \ 3])\nassert(common(l1: [4, 3, 2, 8], l2: [3, 2, 4]) == [2, 3, 4])\nassert(common(l1:\
    \ [4, 3, 2, 8], l2: [] as [Int]) == [] as [Int])"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659979279
- exit_code: 0
  program: "\n/// Return sorted unique common elements for two arrays.\n/// >>> common(l1:\
    \ [1, 4, 3, 34, 653, 2, 5], l2: [5, 7, 1, 5, 9, 653, 121])\n/// [1, 5, 653]\n\
    /// >>> common(l1: [5, 3, 2, 8], l2: [3, 2])\n/// [2, 3]\nfunc common(l1: [Int],\
    \ l2: [Int]) -> [Int] {\n    var l1sorted = l1.sorted()\n    var l2sorted = l2.sorted()\n\
    \    var commonList = [Int]()\n    var l1Index = 0\n    var l2Index = 0\n    while\
    \ l1Index < l1sorted.count && l2Index < l2sorted.count {\n        if l1sorted[l1Index]\
    \ == l2sorted[l2Index] {\n            commonList.append(l1sorted[l1Index])\n \
    \           l1Index += 1\n            l2Index += 1\n        } else if l1sorted[l1Index]\
    \ < l2sorted[l2Index] {\n            l1Index += 1\n        } else {\n        \
    \    l2Index += 1\n        }\n    }\n    return commonList\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(common(l1: [1, 4, 3, 34, 653, 2, 5], l2: [5, 7, 1, 5,\
    \ 9, 653, 121]) == [1, 5, 653])\nassert(common(l1: [5, 3, 2, 8], l2: [3, 2]) ==\
    \ [2, 3])\nassert(common(l1: [4, 3, 2, 8], l2: [3, 2, 4]) == [2, 3, 4])\nassert(common(l1:\
    \ [4, 3, 2, 8], l2: [] as [Int]) == [] as [Int])"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659979280
- exit_code: 0
  program: "\n/// Return sorted unique common elements for two arrays.\n/// >>> common(l1:\
    \ [1, 4, 3, 34, 653, 2, 5], l2: [5, 7, 1, 5, 9, 653, 121])\n/// [1, 5, 653]\n\
    /// >>> common(l1: [5, 3, 2, 8], l2: [3, 2])\n/// [2, 3]\nfunc common(l1: [Int],\
    \ l2: [Int]) -> [Int] {\n    let s1 = Set(l1)\n    let s2 = Set(l2)\n    let common\
    \ = s1.intersection(s2)\n    return Array(common).sorted()\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(common(l1: [1, 4, 3, 34, 653, 2, 5], l2: [5, 7, 1, 5,\
    \ 9, 653, 121]) == [1, 5, 653])\nassert(common(l1: [5, 3, 2, 8], l2: [3, 2]) ==\
    \ [2, 3])\nassert(common(l1: [4, 3, 2, 8], l2: [3, 2, 4]) == [2, 3, 4])\nassert(common(l1:\
    \ [4, 3, 2, 8], l2: [] as [Int]) == [] as [Int])"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659979279
- exit_code: 0
  program: "\n/// Return sorted unique common elements for two arrays.\n/// >>> common(l1:\
    \ [1, 4, 3, 34, 653, 2, 5], l2: [5, 7, 1, 5, 9, 653, 121])\n/// [1, 5, 653]\n\
    /// >>> common(l1: [5, 3, 2, 8], l2: [3, 2])\n/// [2, 3]\nfunc common(l1: [Int],\
    \ l2: [Int]) -> [Int] {\n    var set1 = Set(l1)\n    let set2 = Set(l2)\n    set1.formIntersection(set2)\n\
    \    return Array(set1).sorted()\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int,\
    \ Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n\
    \    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n          \
    \  return false\n        }\n    }\n    return true\n}\n            \nassert(common(l1:\
    \ [1, 4, 3, 34, 653, 2, 5], l2: [5, 7, 1, 5, 9, 653, 121]) == [1, 5, 653])\nassert(common(l1:\
    \ [5, 3, 2, 8], l2: [3, 2]) == [2, 3])\nassert(common(l1: [4, 3, 2, 8], l2: [3,\
    \ 2, 4]) == [2, 3, 4])\nassert(common(l1: [4, 3, 2, 8], l2: [] as [Int]) == []\
    \ as [Int])"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659979280
- exit_code: 0
  program: "\n/// Return sorted unique common elements for two arrays.\n/// >>> common(l1:\
    \ [1, 4, 3, 34, 653, 2, 5], l2: [5, 7, 1, 5, 9, 653, 121])\n/// [1, 5, 653]\n\
    /// >>> common(l1: [5, 3, 2, 8], l2: [3, 2])\n/// [2, 3]\nfunc common(l1: [Int],\
    \ l2: [Int]) -> [Int] {\n    let l1Set = Set(l1)\n    let l2Set = Set(l2)\n  \
    \  let common = l1Set.intersection(l2Set)\n    return Array(common).sorted()\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(common(l1: [1, 4, 3, 34, 653, 2, 5], l2: [5, 7,\
    \ 1, 5, 9, 653, 121]) == [1, 5, 653])\nassert(common(l1: [5, 3, 2, 8], l2: [3,\
    \ 2]) == [2, 3])\nassert(common(l1: [4, 3, 2, 8], l2: [3, 2, 4]) == [2, 3, 4])\n\
    assert(common(l1: [4, 3, 2, 8], l2: [] as [Int]) == [] as [Int])"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659979280
- exit_code: -4
  program: "\n/// Return sorted unique common elements for two arrays.\n/// >>> common(l1:\
    \ [1, 4, 3, 34, 653, 2, 5], l2: [5, 7, 1, 5, 9, 653, 121])\n/// [1, 5, 653]\n\
    /// >>> common(l1: [5, 3, 2, 8], l2: [3, 2])\n/// [2, 3]\nfunc common(l1: [Int],\
    \ l2: [Int]) -> [Int] {\n    return []\n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(common(l1: [1, 4, 3, 34, 653, 2, 5], l2: [5, 7, 1, 5, 9, 653, 121]) ==\
    \ [1, 5, 653])\nassert(common(l1: [5, 3, 2, 8], l2: [3, 2]) == [2, 3])\nassert(common(l1:\
    \ [4, 3, 2, 8], l2: [3, 2, 4]) == [2, 3, 4])\nassert(common(l1: [4, 3, 2, 8],\
    \ l2: [] as [Int]) == [] as [Int])"
  status: Exception
  stderr: 'tmpxe4ju921/tmpxe4ju921.swift:24: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b32fbf71c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b32fbc68b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b32fbc68988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b32fbc677b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpxe4ju921                        0x000055b04303844c <unavailable> + 5196

    5    libc.so.6                          0x00002b32fc15d460 __libc_start_main +
    245

    6    tmpxe4ju921                        0x000055b043037fc9 <unavailable> + 4041

    '
  stdout: ''
  timestamp: 1659979279
- exit_code: -4
  program: "\n/// Return sorted unique common elements for two arrays.\n/// >>> common(l1:\
    \ [1, 4, 3, 34, 653, 2, 5], l2: [5, 7, 1, 5, 9, 653, 121])\n/// [1, 5, 653]\n\
    /// >>> common(l1: [5, 3, 2, 8], l2: [3, 2])\n/// [2, 3]\nfunc common(l1: [Int],\
    \ l2: [Int]) -> [Int] {\n    return []\n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(common(l1: [1, 4, 3, 34, 653, 2, 5], l2: [5, 7, 1, 5, 9, 653, 121]) ==\
    \ [1, 5, 653])\nassert(common(l1: [5, 3, 2, 8], l2: [3, 2]) == [2, 3])\nassert(common(l1:\
    \ [4, 3, 2, 8], l2: [3, 2, 4]) == [2, 3, 4])\nassert(common(l1: [4, 3, 2, 8],\
    \ l2: [] as [Int]) == [] as [Int])"
  status: Exception
  stderr: 'tmpxe4ju921/tmpxe4ju921.swift:24: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b32fbf71c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b32fbc68b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b32fbc68988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b32fbc677b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpxe4ju921                        0x000055b04303844c <unavailable> + 5196

    5    libc.so.6                          0x00002b32fc15d460 __libc_start_main +
    245

    6    tmpxe4ju921                        0x000055b043037fc9 <unavailable> + 4041

    '
  stdout: ''
  timestamp: 1659979279
- exit_code: 0
  program: "\n/// Return sorted unique common elements for two arrays.\n/// >>> common(l1:\
    \ [1, 4, 3, 34, 653, 2, 5], l2: [5, 7, 1, 5, 9, 653, 121])\n/// [1, 5, 653]\n\
    /// >>> common(l1: [5, 3, 2, 8], l2: [3, 2])\n/// [2, 3]\nfunc common(l1: [Int],\
    \ l2: [Int]) -> [Int] {\n    let arr1 = l1.sorted(by: <)\n    let arr2 = l2.sorted(by:\
    \ <)\n    var res: [Int] = []\n    var i = 0\n    var j = 0\n    while i < arr1.count\
    \ && j < arr2.count {\n        if arr1[i] == arr2[j] {\n            res.append(arr1[i])\n\
    \            i += 1\n            j += 1\n        } else if arr1[i] < arr2[j] {\n\
    \            i += 1\n        } else {\n            j += 1\n        }\n    }\n\
    \    return res\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool\
    \ {\n    if left.count != right.count {\n        return false\n    }\n    for\
    \ (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(common(l1: [1, 4,\
    \ 3, 34, 653, 2, 5], l2: [5, 7, 1, 5, 9, 653, 121]) == [1, 5, 653])\nassert(common(l1:\
    \ [5, 3, 2, 8], l2: [3, 2]) == [2, 3])\nassert(common(l1: [4, 3, 2, 8], l2: [3,\
    \ 2, 4]) == [2, 3, 4])\nassert(common(l1: [4, 3, 2, 8], l2: [] as [Int]) == []\
    \ as [Int])"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659979280
- exit_code: 0
  program: "\n/// Return sorted unique common elements for two arrays.\n/// >>> common(l1:\
    \ [1, 4, 3, 34, 653, 2, 5], l2: [5, 7, 1, 5, 9, 653, 121])\n/// [1, 5, 653]\n\
    /// >>> common(l1: [5, 3, 2, 8], l2: [3, 2])\n/// [2, 3]\nfunc common(l1: [Int],\
    \ l2: [Int]) -> [Int] {\n    var s1 = Set(l1)\n    var s2 = Set(l2)\n    s1.formIntersection(s2)\n\
    \    return Array(s1).sorted()\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int,\
    \ Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n\
    \    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n          \
    \  return false\n        }\n    }\n    return true\n}\n            \nassert(common(l1:\
    \ [1, 4, 3, 34, 653, 2, 5], l2: [5, 7, 1, 5, 9, 653, 121]) == [1, 5, 653])\nassert(common(l1:\
    \ [5, 3, 2, 8], l2: [3, 2]) == [2, 3])\nassert(common(l1: [4, 3, 2, 8], l2: [3,\
    \ 2, 4]) == [2, 3, 4])\nassert(common(l1: [4, 3, 2, 8], l2: [] as [Int]) == []\
    \ as [Int])"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659979279
- exit_code: -4
  program: "\n/// Return sorted unique common elements for two arrays.\n/// >>> common(l1:\
    \ [1, 4, 3, 34, 653, 2, 5], l2: [5, 7, 1, 5, 9, 653, 121])\n/// [1, 5, 653]\n\
    /// >>> common(l1: [5, 3, 2, 8], l2: [3, 2])\n/// [2, 3]\nfunc common(l1: [Int],\
    \ l2: [Int]) -> [Int] {\n  var l3 = [Int]()\n  var i = 0\n  var j = 0\n  while\
    \ i < l1.count && j < l2.count {\n    if l1[i] == l2[j] {\n      l3.append(l1[i])\n\
    \      i += 1\n      j += 1\n    } else if l1[i] < l2[j] {\n      i += 1\n   \
    \ } else {\n      j += 1\n    }\n  }\n  return l3\n}\n\n\nfunc ==(left: [(Int,\
    \ Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n\
    \        return false\n    }\n    for (l, r) in zip(left, right) {\n        if\
    \ l != r {\n            return false\n        }\n    }\n    return true\n}\n \
    \           \nassert(common(l1: [1, 4, 3, 34, 653, 2, 5], l2: [5, 7, 1, 5, 9,\
    \ 653, 121]) == [1, 5, 653])\nassert(common(l1: [5, 3, 2, 8], l2: [3, 2]) == [2,\
    \ 3])\nassert(common(l1: [4, 3, 2, 8], l2: [3, 2, 4]) == [2, 3, 4])\nassert(common(l1:\
    \ [4, 3, 2, 8], l2: [] as [Int]) == [] as [Int])"
  status: Exception
  stderr: 'tmps_xsxasd/tmps_xsxasd.swift:38: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b576ae0fc80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b576ab06b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b576ab06988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b576ab057b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmps_xsxasd                        0x000055aa8b67c5ac <unavailable> + 5548

    5    libc.so.6                          0x00002b576affb460 __libc_start_main +
    245

    6    tmps_xsxasd                        0x000055aa8b67c129 <unavailable> + 4393

    '
  stdout: ''
  timestamp: 1659979280
- exit_code: 0
  program: "\n/// Return sorted unique common elements for two arrays.\n/// >>> common(l1:\
    \ [1, 4, 3, 34, 653, 2, 5], l2: [5, 7, 1, 5, 9, 653, 121])\n/// [1, 5, 653]\n\
    /// >>> common(l1: [5, 3, 2, 8], l2: [3, 2])\n/// [2, 3]\nfunc common(l1: [Int],\
    \ l2: [Int]) -> [Int] {\n    let set1 = Set(l1)\n    let set2 = Set(l2)\n    return\
    \ Array(set1.intersection(set2)).sorted()\n}\n\n\nfunc ==(left: [(Int, Int)],\
    \ right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n       \
    \ return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r\
    \ {\n            return false\n        }\n    }\n    return true\n}\n        \
    \    \nassert(common(l1: [1, 4, 3, 34, 653, 2, 5], l2: [5, 7, 1, 5, 9, 653, 121])\
    \ == [1, 5, 653])\nassert(common(l1: [5, 3, 2, 8], l2: [3, 2]) == [2, 3])\nassert(common(l1:\
    \ [4, 3, 2, 8], l2: [3, 2, 4]) == [2, 3, 4])\nassert(common(l1: [4, 3, 2, 8],\
    \ l2: [] as [Int]) == [] as [Int])"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659979279
- exit_code: 1
  program: "\n/// Return sorted unique common elements for two arrays.\n/// >>> common(l1:\
    \ [1, 4, 3, 34, 653, 2, 5], l2: [5, 7, 1, 5, 9, 653, 121])\n/// [1, 5, 653]\n\
    /// >>> common(l1: [5, 3, 2, 8], l2: [3, 2])\n/// [2, 3]\nfunc common(l1: [Int],\
    \ l2: [Int]) -> [Int] {\n\tlet unique = uniqueItems(l1: l1, l2: l2)\n\treturn\
    \ unique.filter { l1.contains($0) && l2.contains($0) }\n}\n\n\nfunc ==(left: [(Int,\
    \ Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n\
    \        return false\n    }\n    for (l, r) in zip(left, right) {\n        if\
    \ l != r {\n            return false\n        }\n    }\n    return true\n}\n \
    \           \nassert(common(l1: [1, 4, 3, 34, 653, 2, 5], l2: [5, 7, 1, 5, 9,\
    \ 653, 121]) == [1, 5, 653])\nassert(common(l1: [5, 3, 2, 8], l2: [3, 2]) == [2,\
    \ 3])\nassert(common(l1: [4, 3, 2, 8], l2: [3, 2, 4]) == [2, 3, 4])\nassert(common(l1:\
    \ [4, 3, 2, 8], l2: [] as [Int]) == [] as [Int])"
  status: SyntaxError
  stderr: "/tmp/tmpoqv8vvlb.swift:8:15: error: cannot find 'uniqueItems' in scope\n\
    \        let unique = uniqueItems(l1: l1, l2: l2)\n                     ^~~~~~~~~~~\n"
  stdout: ''
  timestamp: 1659979279
- exit_code: 0
  program: "\n/// Return sorted unique common elements for two arrays.\n/// >>> common(l1:\
    \ [1, 4, 3, 34, 653, 2, 5], l2: [5, 7, 1, 5, 9, 653, 121])\n/// [1, 5, 653]\n\
    /// >>> common(l1: [5, 3, 2, 8], l2: [3, 2])\n/// [2, 3]\nfunc common(l1: [Int],\
    \ l2: [Int]) -> [Int] {\n    return l1.filter { l2.contains($0) }.sorted()\n}\n\
    \n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(common(l1: [1, 4, 3, 34, 653, 2, 5], l2: [5, 7,\
    \ 1, 5, 9, 653, 121]) == [1, 5, 653])\nassert(common(l1: [5, 3, 2, 8], l2: [3,\
    \ 2]) == [2, 3])\nassert(common(l1: [4, 3, 2, 8], l2: [3, 2, 4]) == [2, 3, 4])\n\
    assert(common(l1: [4, 3, 2, 8], l2: [] as [Int]) == [] as [Int])"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659979279
- exit_code: 0
  program: "\n/// Return sorted unique common elements for two arrays.\n/// >>> common(l1:\
    \ [1, 4, 3, 34, 653, 2, 5], l2: [5, 7, 1, 5, 9, 653, 121])\n/// [1, 5, 653]\n\
    /// >>> common(l1: [5, 3, 2, 8], l2: [3, 2])\n/// [2, 3]\nfunc common(l1: [Int],\
    \ l2: [Int]) -> [Int] {\n    let set1 = Set(l1)\n    let set2 = Set(l2)\n    return\
    \ Array(set1.intersection(set2)).sorted()\n}\n\n\nfunc ==(left: [(Int, Int)],\
    \ right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n       \
    \ return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r\
    \ {\n            return false\n        }\n    }\n    return true\n}\n        \
    \    \nassert(common(l1: [1, 4, 3, 34, 653, 2, 5], l2: [5, 7, 1, 5, 9, 653, 121])\
    \ == [1, 5, 653])\nassert(common(l1: [5, 3, 2, 8], l2: [3, 2]) == [2, 3])\nassert(common(l1:\
    \ [4, 3, 2, 8], l2: [3, 2, 4]) == [2, 3, 4])\nassert(common(l1: [4, 3, 2, 8],\
    \ l2: [] as [Int]) == [] as [Int])"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659979279
- exit_code: 0
  program: "\n/// Return sorted unique common elements for two arrays.\n/// >>> common(l1:\
    \ [1, 4, 3, 34, 653, 2, 5], l2: [5, 7, 1, 5, 9, 653, 121])\n/// [1, 5, 653]\n\
    /// >>> common(l1: [5, 3, 2, 8], l2: [3, 2])\n/// [2, 3]\nfunc common(l1: [Int],\
    \ l2: [Int]) -> [Int] {\n    let s1 = Set(l1)\n    let s2 = Set(l2)\n    return\
    \ Array(s1.intersection(s2)).sorted()\n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(common(l1: [1, 4, 3, 34, 653, 2, 5], l2: [5, 7, 1, 5, 9, 653, 121]) ==\
    \ [1, 5, 653])\nassert(common(l1: [5, 3, 2, 8], l2: [3, 2]) == [2, 3])\nassert(common(l1:\
    \ [4, 3, 2, 8], l2: [3, 2, 4]) == [2, 3, 4])\nassert(common(l1: [4, 3, 2, 8],\
    \ l2: [] as [Int]) == [] as [Int])"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659979279
- exit_code: 0
  program: "\n/// Return sorted unique common elements for two arrays.\n/// >>> common(l1:\
    \ [1, 4, 3, 34, 653, 2, 5], l2: [5, 7, 1, 5, 9, 653, 121])\n/// [1, 5, 653]\n\
    /// >>> common(l1: [5, 3, 2, 8], l2: [3, 2])\n/// [2, 3]\nfunc common(l1: [Int],\
    \ l2: [Int]) -> [Int] {\n    let set1 = Set(l1)\n    let set2 = Set(l2)\n    let\
    \ intersec = set1.intersection(set2)\n    return Array(intersec).sorted()\n}\n\
    \n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(common(l1: [1, 4, 3, 34, 653, 2, 5], l2: [5, 7,\
    \ 1, 5, 9, 653, 121]) == [1, 5, 653])\nassert(common(l1: [5, 3, 2, 8], l2: [3,\
    \ 2]) == [2, 3])\nassert(common(l1: [4, 3, 2, 8], l2: [3, 2, 4]) == [2, 3, 4])\n\
    assert(common(l1: [4, 3, 2, 8], l2: [] as [Int]) == [] as [Int])"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659979280
- exit_code: 0
  program: "\n/// Return sorted unique common elements for two arrays.\n/// >>> common(l1:\
    \ [1, 4, 3, 34, 653, 2, 5], l2: [5, 7, 1, 5, 9, 653, 121])\n/// [1, 5, 653]\n\
    /// >>> common(l1: [5, 3, 2, 8], l2: [3, 2])\n/// [2, 3]\nfunc common(l1: [Int],\
    \ l2: [Int]) -> [Int] {\n    var l = [Int]()\n    for i in l1 {\n        if l2.contains(i)\
    \ {\n            l.append(i)\n        }\n    }\n    return l.sorted()\n}\n\n\n\
    func ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(common(l1: [1, 4, 3, 34, 653, 2, 5], l2: [5, 7,\
    \ 1, 5, 9, 653, 121]) == [1, 5, 653])\nassert(common(l1: [5, 3, 2, 8], l2: [3,\
    \ 2]) == [2, 3])\nassert(common(l1: [4, 3, 2, 8], l2: [3, 2, 4]) == [2, 3, 4])\n\
    assert(common(l1: [4, 3, 2, 8], l2: [] as [Int]) == [] as [Int])"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659979280
- exit_code: 0
  program: "\n/// Return sorted unique common elements for two arrays.\n/// >>> common(l1:\
    \ [1, 4, 3, 34, 653, 2, 5], l2: [5, 7, 1, 5, 9, 653, 121])\n/// [1, 5, 653]\n\
    /// >>> common(l1: [5, 3, 2, 8], l2: [3, 2])\n/// [2, 3]\nfunc common(l1: [Int],\
    \ l2: [Int]) -> [Int] {\n    var result = [Int]()\n    for i in l1 {\n       \
    \ for j in l2 {\n            if i == j {\n                result.append(i)\n \
    \           }\n        }\n    }\n    return Array(Set(result)).sorted()\n}\n\n\
    \nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(common(l1: [1, 4, 3, 34, 653, 2, 5], l2: [5, 7,\
    \ 1, 5, 9, 653, 121]) == [1, 5, 653])\nassert(common(l1: [5, 3, 2, 8], l2: [3,\
    \ 2]) == [2, 3])\nassert(common(l1: [4, 3, 2, 8], l2: [3, 2, 4]) == [2, 3, 4])\n\
    assert(common(l1: [4, 3, 2, 8], l2: [] as [Int]) == [] as [Int])"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659979280
- exit_code: 0
  program: "\n/// Return sorted unique common elements for two arrays.\n/// >>> common(l1:\
    \ [1, 4, 3, 34, 653, 2, 5], l2: [5, 7, 1, 5, 9, 653, 121])\n/// [1, 5, 653]\n\
    /// >>> common(l1: [5, 3, 2, 8], l2: [3, 2])\n/// [2, 3]\nfunc common(l1: [Int],\
    \ l2: [Int]) -> [Int] {\n    return l1.filter { l2.contains($0) }.sorted { $0\
    \ < $1 }\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n\
    \    if left.count != right.count {\n        return false\n    }\n    for (l,\
    \ r) in zip(left, right) {\n        if l != r {\n            return false\n  \
    \      }\n    }\n    return true\n}\n            \nassert(common(l1: [1, 4, 3,\
    \ 34, 653, 2, 5], l2: [5, 7, 1, 5, 9, 653, 121]) == [1, 5, 653])\nassert(common(l1:\
    \ [5, 3, 2, 8], l2: [3, 2]) == [2, 3])\nassert(common(l1: [4, 3, 2, 8], l2: [3,\
    \ 2, 4]) == [2, 3, 4])\nassert(common(l1: [4, 3, 2, 8], l2: [] as [Int]) == []\
    \ as [Int])"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659979279
- exit_code: 0
  program: "\n/// Return sorted unique common elements for two arrays.\n/// >>> common(l1:\
    \ [1, 4, 3, 34, 653, 2, 5], l2: [5, 7, 1, 5, 9, 653, 121])\n/// [1, 5, 653]\n\
    /// >>> common(l1: [5, 3, 2, 8], l2: [3, 2])\n/// [2, 3]\nfunc common(l1: [Int],\
    \ l2: [Int]) -> [Int] {\n    var s = Set(l1)\n    s.formIntersection(l2)\n   \
    \ return Array(s).sorted()\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(common(l1:\
    \ [1, 4, 3, 34, 653, 2, 5], l2: [5, 7, 1, 5, 9, 653, 121]) == [1, 5, 653])\nassert(common(l1:\
    \ [5, 3, 2, 8], l2: [3, 2]) == [2, 3])\nassert(common(l1: [4, 3, 2, 8], l2: [3,\
    \ 2, 4]) == [2, 3, 4])\nassert(common(l1: [4, 3, 2, 8], l2: [] as [Int]) == []\
    \ as [Int])"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659979280
- exit_code: -4
  program: "\n/// Return sorted unique common elements for two arrays.\n/// >>> common(l1:\
    \ [1, 4, 3, 34, 653, 2, 5], l2: [5, 7, 1, 5, 9, 653, 121])\n/// [1, 5, 653]\n\
    /// >>> common(l1: [5, 3, 2, 8], l2: [3, 2])\n/// [2, 3]\nfunc common(l1: [Int],\
    \ l2: [Int]) -> [Int] {\n    return []\n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(common(l1: [1, 4, 3, 34, 653, 2, 5], l2: [5, 7, 1, 5, 9, 653, 121]) ==\
    \ [1, 5, 653])\nassert(common(l1: [5, 3, 2, 8], l2: [3, 2]) == [2, 3])\nassert(common(l1:\
    \ [4, 3, 2, 8], l2: [3, 2, 4]) == [2, 3, 4])\nassert(common(l1: [4, 3, 2, 8],\
    \ l2: [] as [Int]) == [] as [Int])"
  status: Exception
  stderr: 'tmpxe4ju921/tmpxe4ju921.swift:24: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b32fbf71c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b32fbc68b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b32fbc68988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b32fbc677b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpxe4ju921                        0x000055b04303844c <unavailable> + 5196

    5    libc.so.6                          0x00002b32fc15d460 __libc_start_main +
    245

    6    tmpxe4ju921                        0x000055b043037fc9 <unavailable> + 4041

    '
  stdout: ''
  timestamp: 1659979279
- exit_code: 0
  program: "\n/// Return sorted unique common elements for two arrays.\n/// >>> common(l1:\
    \ [1, 4, 3, 34, 653, 2, 5], l2: [5, 7, 1, 5, 9, 653, 121])\n/// [1, 5, 653]\n\
    /// >>> common(l1: [5, 3, 2, 8], l2: [3, 2])\n/// [2, 3]\nfunc common(l1: [Int],\
    \ l2: [Int]) -> [Int] {\n    var result: [Int] = []\n    let intersection = Set(l1).intersection(Set(l2))\n\
    \    if intersection.count > 0 {\n        result = Array(intersection).sorted()\n\
    \    }\n    return result\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(common(l1:\
    \ [1, 4, 3, 34, 653, 2, 5], l2: [5, 7, 1, 5, 9, 653, 121]) == [1, 5, 653])\nassert(common(l1:\
    \ [5, 3, 2, 8], l2: [3, 2]) == [2, 3])\nassert(common(l1: [4, 3, 2, 8], l2: [3,\
    \ 2, 4]) == [2, 3, 4])\nassert(common(l1: [4, 3, 2, 8], l2: [] as [Int]) == []\
    \ as [Int])"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659979280
- exit_code: 0
  program: "\n/// Return sorted unique common elements for two arrays.\n/// >>> common(l1:\
    \ [1, 4, 3, 34, 653, 2, 5], l2: [5, 7, 1, 5, 9, 653, 121])\n/// [1, 5, 653]\n\
    /// >>> common(l1: [5, 3, 2, 8], l2: [3, 2])\n/// [2, 3]\nfunc common(l1: [Int],\
    \ l2: [Int]) -> [Int] {\n    let set1 = Set(l1)\n    let set2 = Set(l2)\n    return\
    \ Array(set1.intersection(set2)).sorted()\n}\n\n\nfunc ==(left: [(Int, Int)],\
    \ right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n       \
    \ return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r\
    \ {\n            return false\n        }\n    }\n    return true\n}\n        \
    \    \nassert(common(l1: [1, 4, 3, 34, 653, 2, 5], l2: [5, 7, 1, 5, 9, 653, 121])\
    \ == [1, 5, 653])\nassert(common(l1: [5, 3, 2, 8], l2: [3, 2]) == [2, 3])\nassert(common(l1:\
    \ [4, 3, 2, 8], l2: [3, 2, 4]) == [2, 3, 4])\nassert(common(l1: [4, 3, 2, 8],\
    \ l2: [] as [Int]) == [] as [Int])"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659979279
- exit_code: -4
  program: "\n/// Return sorted unique common elements for two arrays.\n/// >>> common(l1:\
    \ [1, 4, 3, 34, 653, 2, 5], l2: [5, 7, 1, 5, 9, 653, 121])\n/// [1, 5, 653]\n\
    /// >>> common(l1: [5, 3, 2, 8], l2: [3, 2])\n/// [2, 3]\nfunc common(l1: [Int],\
    \ l2: [Int]) -> [Int] {\n    return Array(Set(l1).intersection(Set(l2)))\n}\n\n\
    \nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(common(l1: [1, 4, 3, 34, 653, 2, 5], l2: [5, 7,\
    \ 1, 5, 9, 653, 121]) == [1, 5, 653])\nassert(common(l1: [5, 3, 2, 8], l2: [3,\
    \ 2]) == [2, 3])\nassert(common(l1: [4, 3, 2, 8], l2: [3, 2, 4]) == [2, 3, 4])\n\
    assert(common(l1: [4, 3, 2, 8], l2: [] as [Int]) == [] as [Int])"
  status: Exception
  stderr: 'tmpzxefsmhz/tmpzxefsmhz.swift:24: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b9cc80f7c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b9cc7deeb6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b9cc7dee988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b9cc7ded7b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpzxefsmhz                        0x0000564df22865fc <unavailable> + 5628

    5    libc.so.6                          0x00002b9cc82e3460 __libc_start_main +
    245

    6    tmpzxefsmhz                        0x0000564df2286179 <unavailable> + 4473

    '
  stdout: ''
  timestamp: 1659979279
- exit_code: -4
  program: "\n/// Return sorted unique common elements for two arrays.\n/// >>> common(l1:\
    \ [1, 4, 3, 34, 653, 2, 5], l2: [5, 7, 1, 5, 9, 653, 121])\n/// [1, 5, 653]\n\
    /// >>> common(l1: [5, 3, 2, 8], l2: [3, 2])\n/// [2, 3]\nfunc common(l1: [Int],\
    \ l2: [Int]) -> [Int] {\n    var result = [Int]()\n    for i in l1 {\n       \
    \ for j in l2 {\n            if i == j {\n                result.append(i)\n \
    \           }\n        }\n    }\n    return result.sorted()\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(common(l1: [1, 4, 3, 34, 653, 2, 5], l2: [5, 7, 1, 5,\
    \ 9, 653, 121]) == [1, 5, 653])\nassert(common(l1: [5, 3, 2, 8], l2: [3, 2]) ==\
    \ [2, 3])\nassert(common(l1: [4, 3, 2, 8], l2: [3, 2, 4]) == [2, 3, 4])\nassert(common(l1:\
    \ [4, 3, 2, 8], l2: [] as [Int]) == [] as [Int])"
  status: Exception
  stderr: 'tmp1eclpvfl/tmp1eclpvfl.swift:32: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b3716789c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b3716480b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b3716480988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b371647f7b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmp1eclpvfl                        0x00005650a573670c <unavailable> + 5900

    5    libc.so.6                          0x00002b3716975460 __libc_start_main +
    245

    6    tmp1eclpvfl                        0x00005650a5736289 <unavailable> + 4745

    '
  stdout: ''
  timestamp: 1659979280
- exit_code: 0
  program: "\n/// Return sorted unique common elements for two arrays.\n/// >>> common(l1:\
    \ [1, 4, 3, 34, 653, 2, 5], l2: [5, 7, 1, 5, 9, 653, 121])\n/// [1, 5, 653]\n\
    /// >>> common(l1: [5, 3, 2, 8], l2: [3, 2])\n/// [2, 3]\nfunc common(l1: [Int],\
    \ l2: [Int]) -> [Int] {\n    var res: [Int] = []\n    let set1 = Set(l1)\n   \
    \ let set2 = Set(l2)\n    set1.forEach({\n        if set2.contains($0) {\n   \
    \         res.append($0)\n        }\n    })\n    return res.sorted()\n}\n\n\n\
    func ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(common(l1: [1, 4, 3, 34, 653, 2, 5], l2: [5, 7,\
    \ 1, 5, 9, 653, 121]) == [1, 5, 653])\nassert(common(l1: [5, 3, 2, 8], l2: [3,\
    \ 2]) == [2, 3])\nassert(common(l1: [4, 3, 2, 8], l2: [3, 2, 4]) == [2, 3, 4])\n\
    assert(common(l1: [4, 3, 2, 8], l2: [] as [Int]) == [] as [Int])"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659979280
- exit_code: -4
  program: "\n/// Return sorted unique common elements for two arrays.\n/// >>> common(l1:\
    \ [1, 4, 3, 34, 653, 2, 5], l2: [5, 7, 1, 5, 9, 653, 121])\n/// [1, 5, 653]\n\
    /// >>> common(l1: [5, 3, 2, 8], l2: [3, 2])\n/// [2, 3]\nfunc common(l1: [Int],\
    \ l2: [Int]) -> [Int] {\n    return Array(Set(l1).intersection(Set(l2)))\n}\n\n\
    \nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(common(l1: [1, 4, 3, 34, 653, 2, 5], l2: [5, 7,\
    \ 1, 5, 9, 653, 121]) == [1, 5, 653])\nassert(common(l1: [5, 3, 2, 8], l2: [3,\
    \ 2]) == [2, 3])\nassert(common(l1: [4, 3, 2, 8], l2: [3, 2, 4]) == [2, 3, 4])\n\
    assert(common(l1: [4, 3, 2, 8], l2: [] as [Int]) == [] as [Int])"
  status: Exception
  stderr: 'tmpzxefsmhz/tmpzxefsmhz.swift:24: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b9cc80f7c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b9cc7deeb6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b9cc7dee988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b9cc7ded7b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpzxefsmhz                        0x0000564df22865fc <unavailable> + 5628

    5    libc.so.6                          0x00002b9cc82e3460 __libc_start_main +
    245

    6    tmpzxefsmhz                        0x0000564df2286179 <unavailable> + 4473

    '
  stdout: ''
  timestamp: 1659979279
- exit_code: 1
  program: "\n/// Return sorted unique common elements for two arrays.\n/// >>> common(l1:\
    \ [1, 4, 3, 34, 653, 2, 5], l2: [5, 7, 1, 5, 9, 653, 121])\n/// [1, 5, 653]\n\
    /// >>> common(l1: [5, 3, 2, 8], l2: [3, 2])\n/// [2, 3]\nfunc common(l1: [Int],\
    \ l2: [Int]) -> [Int] {\n    return unique(items: intersect(l1: l1, l2: l2))\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(common(l1: [1, 4, 3, 34, 653, 2, 5], l2: [5, 7,\
    \ 1, 5, 9, 653, 121]) == [1, 5, 653])\nassert(common(l1: [5, 3, 2, 8], l2: [3,\
    \ 2]) == [2, 3])\nassert(common(l1: [4, 3, 2, 8], l2: [3, 2, 4]) == [2, 3, 4])\n\
    assert(common(l1: [4, 3, 2, 8], l2: [] as [Int]) == [] as [Int])"
  status: SyntaxError
  stderr: "/tmp/tmphphg1bwu.swift:8:12: error: cannot find 'unique' in scope\n   \
    \ return unique(items: intersect(l1: l1, l2: l2))\n           ^~~~~~\n/tmp/tmphphg1bwu.swift:8:26:\
    \ error: cannot find 'intersect' in scope\n    return unique(items: intersect(l1:\
    \ l1, l2: l2))\n                         ^~~~~~~~~\n"
  stdout: ''
  timestamp: 1659979279
- exit_code: 0
  program: "\n/// Return sorted unique common elements for two arrays.\n/// >>> common(l1:\
    \ [1, 4, 3, 34, 653, 2, 5], l2: [5, 7, 1, 5, 9, 653, 121])\n/// [1, 5, 653]\n\
    /// >>> common(l1: [5, 3, 2, 8], l2: [3, 2])\n/// [2, 3]\nfunc common(l1: [Int],\
    \ l2: [Int]) -> [Int] {\n    var set1 = Set(l1)\n    var set2 = Set(l2)\n    set1.formIntersection(set2)\n\
    \    return Array(set1).sorted()\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int,\
    \ Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n\
    \    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n          \
    \  return false\n        }\n    }\n    return true\n}\n            \nassert(common(l1:\
    \ [1, 4, 3, 34, 653, 2, 5], l2: [5, 7, 1, 5, 9, 653, 121]) == [1, 5, 653])\nassert(common(l1:\
    \ [5, 3, 2, 8], l2: [3, 2]) == [2, 3])\nassert(common(l1: [4, 3, 2, 8], l2: [3,\
    \ 2, 4]) == [2, 3, 4])\nassert(common(l1: [4, 3, 2, 8], l2: [] as [Int]) == []\
    \ as [Int])"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659979280
- exit_code: 0
  program: "\n/// Return sorted unique common elements for two arrays.\n/// >>> common(l1:\
    \ [1, 4, 3, 34, 653, 2, 5], l2: [5, 7, 1, 5, 9, 653, 121])\n/// [1, 5, 653]\n\
    /// >>> common(l1: [5, 3, 2, 8], l2: [3, 2])\n/// [2, 3]\nfunc common(l1: [Int],\
    \ l2: [Int]) -> [Int] {\n    return Array(Set(l1).intersection(Set(l2))).sorted()\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(common(l1: [1, 4, 3, 34, 653, 2, 5], l2: [5, 7,\
    \ 1, 5, 9, 653, 121]) == [1, 5, 653])\nassert(common(l1: [5, 3, 2, 8], l2: [3,\
    \ 2]) == [2, 3])\nassert(common(l1: [4, 3, 2, 8], l2: [3, 2, 4]) == [2, 3, 4])\n\
    assert(common(l1: [4, 3, 2, 8], l2: [] as [Int]) == [] as [Int])"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659979279
- exit_code: -4
  program: "\n/// Return sorted unique common elements for two arrays.\n/// >>> common(l1:\
    \ [1, 4, 3, 34, 653, 2, 5], l2: [5, 7, 1, 5, 9, 653, 121])\n/// [1, 5, 653]\n\
    /// >>> common(l1: [5, 3, 2, 8], l2: [3, 2])\n/// [2, 3]\nfunc common(l1: [Int],\
    \ l2: [Int]) -> [Int] {\n  // TODO\n  return []\n}\n\n\nfunc ==(left: [(Int, Int)],\
    \ right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n       \
    \ return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r\
    \ {\n            return false\n        }\n    }\n    return true\n}\n        \
    \    \nassert(common(l1: [1, 4, 3, 34, 653, 2, 5], l2: [5, 7, 1, 5, 9, 653, 121])\
    \ == [1, 5, 653])\nassert(common(l1: [5, 3, 2, 8], l2: [3, 2]) == [2, 3])\nassert(common(l1:\
    \ [4, 3, 2, 8], l2: [3, 2, 4]) == [2, 3, 4])\nassert(common(l1: [4, 3, 2, 8],\
    \ l2: [] as [Int]) == [] as [Int])"
  status: Exception
  stderr: 'tmpveyz9vwf/tmpveyz9vwf.swift:25: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b04d7345c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b04d703cb6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b04d703c988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b04d703b7b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpveyz9vwf                        0x0000557fa6f1a44c <unavailable> + 5196

    5    libc.so.6                          0x00002b04d7531460 __libc_start_main +
    245

    6    tmpveyz9vwf                        0x0000557fa6f19fc9 <unavailable> + 4041

    '
  stdout: ''
  timestamp: 1659979280
- exit_code: 0
  program: "\n/// Return sorted unique common elements for two arrays.\n/// >>> common(l1:\
    \ [1, 4, 3, 34, 653, 2, 5], l2: [5, 7, 1, 5, 9, 653, 121])\n/// [1, 5, 653]\n\
    /// >>> common(l1: [5, 3, 2, 8], l2: [3, 2])\n/// [2, 3]\nfunc common(l1: [Int],\
    \ l2: [Int]) -> [Int] {\n    let set1 = Set(l1)\n    let set2 = Set(l2)\n    return\
    \ Array(set1.intersection(set2)).sorted()\n}\n\n\nfunc ==(left: [(Int, Int)],\
    \ right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n       \
    \ return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r\
    \ {\n            return false\n        }\n    }\n    return true\n}\n        \
    \    \nassert(common(l1: [1, 4, 3, 34, 653, 2, 5], l2: [5, 7, 1, 5, 9, 653, 121])\
    \ == [1, 5, 653])\nassert(common(l1: [5, 3, 2, 8], l2: [3, 2]) == [2, 3])\nassert(common(l1:\
    \ [4, 3, 2, 8], l2: [3, 2, 4]) == [2, 3, 4])\nassert(common(l1: [4, 3, 2, 8],\
    \ l2: [] as [Int]) == [] as [Int])"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659979279
- exit_code: 0
  program: "\n/// Return sorted unique common elements for two arrays.\n/// >>> common(l1:\
    \ [1, 4, 3, 34, 653, 2, 5], l2: [5, 7, 1, 5, 9, 653, 121])\n/// [1, 5, 653]\n\
    /// >>> common(l1: [5, 3, 2, 8], l2: [3, 2])\n/// [2, 3]\nfunc common(l1: [Int],\
    \ l2: [Int]) -> [Int] {\n\tlet sorted1 = l1.sorted()\n\tlet sorted2 = l2.sorted()\n\
    \tvar i = 0\n\tvar j = 0\n\tvar res = [Int]()\n\twhile i < sorted1.count && j\
    \ < sorted2.count {\n\t\tif sorted1[i] < sorted2[j] {\n\t\t\ti += 1\n\t\t} else\
    \ if sorted1[i] > sorted2[j] {\n\t\t\tj += 1\n\t\t} else {\n\t\t\tres.append(sorted1[i])\n\
    \t\t\ti += 1\n\t\t\tj += 1\n\t\t}\n\t}\n\treturn res\n}\n\n\nfunc ==(left: [(Int,\
    \ Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n\
    \        return false\n    }\n    for (l, r) in zip(left, right) {\n        if\
    \ l != r {\n            return false\n        }\n    }\n    return true\n}\n \
    \           \nassert(common(l1: [1, 4, 3, 34, 653, 2, 5], l2: [5, 7, 1, 5, 9,\
    \ 653, 121]) == [1, 5, 653])\nassert(common(l1: [5, 3, 2, 8], l2: [3, 2]) == [2,\
    \ 3])\nassert(common(l1: [4, 3, 2, 8], l2: [3, 2, 4]) == [2, 3, 4])\nassert(common(l1:\
    \ [4, 3, 2, 8], l2: [] as [Int]) == [] as [Int])"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659979280
- exit_code: 0
  program: "\n/// Return sorted unique common elements for two arrays.\n/// >>> common(l1:\
    \ [1, 4, 3, 34, 653, 2, 5], l2: [5, 7, 1, 5, 9, 653, 121])\n/// [1, 5, 653]\n\
    /// >>> common(l1: [5, 3, 2, 8], l2: [3, 2])\n/// [2, 3]\nfunc common(l1: [Int],\
    \ l2: [Int]) -> [Int] {\n    var set1 = Set(l1)\n    var set2 = Set(l2)\n    set1.formIntersection(set2)\n\
    \    return set1.sorted()\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(common(l1:\
    \ [1, 4, 3, 34, 653, 2, 5], l2: [5, 7, 1, 5, 9, 653, 121]) == [1, 5, 653])\nassert(common(l1:\
    \ [5, 3, 2, 8], l2: [3, 2]) == [2, 3])\nassert(common(l1: [4, 3, 2, 8], l2: [3,\
    \ 2, 4]) == [2, 3, 4])\nassert(common(l1: [4, 3, 2, 8], l2: [] as [Int]) == []\
    \ as [Int])"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659979280
- exit_code: 0
  program: "\n/// Return sorted unique common elements for two arrays.\n/// >>> common(l1:\
    \ [1, 4, 3, 34, 653, 2, 5], l2: [5, 7, 1, 5, 9, 653, 121])\n/// [1, 5, 653]\n\
    /// >>> common(l1: [5, 3, 2, 8], l2: [3, 2])\n/// [2, 3]\nfunc common(l1: [Int],\
    \ l2: [Int]) -> [Int] {\n    var s = Set(l1)\n    var c = Set(l2)\n    s.formIntersection(c)\n\
    \    return Array(s).sorted()\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int,\
    \ Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n\
    \    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n          \
    \  return false\n        }\n    }\n    return true\n}\n            \nassert(common(l1:\
    \ [1, 4, 3, 34, 653, 2, 5], l2: [5, 7, 1, 5, 9, 653, 121]) == [1, 5, 653])\nassert(common(l1:\
    \ [5, 3, 2, 8], l2: [3, 2]) == [2, 3])\nassert(common(l1: [4, 3, 2, 8], l2: [3,\
    \ 2, 4]) == [2, 3, 4])\nassert(common(l1: [4, 3, 2, 8], l2: [] as [Int]) == []\
    \ as [Int])"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659979280
- exit_code: 0
  program: "\n/// Return sorted unique common elements for two arrays.\n/// >>> common(l1:\
    \ [1, 4, 3, 34, 653, 2, 5], l2: [5, 7, 1, 5, 9, 653, 121])\n/// [1, 5, 653]\n\
    /// >>> common(l1: [5, 3, 2, 8], l2: [3, 2])\n/// [2, 3]\nfunc common(l1: [Int],\
    \ l2: [Int]) -> [Int] {\n    var l: [Int] = []\n    for i in l1 {\n        if\
    \ l2.contains(i) {\n            l.append(i)\n        }\n    }\n    return l.sorted()\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(common(l1: [1, 4, 3, 34, 653, 2, 5], l2: [5, 7,\
    \ 1, 5, 9, 653, 121]) == [1, 5, 653])\nassert(common(l1: [5, 3, 2, 8], l2: [3,\
    \ 2]) == [2, 3])\nassert(common(l1: [4, 3, 2, 8], l2: [3, 2, 4]) == [2, 3, 4])\n\
    assert(common(l1: [4, 3, 2, 8], l2: [] as [Int]) == [] as [Int])"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659979280
- exit_code: 0
  program: "\n/// Return sorted unique common elements for two arrays.\n/// >>> common(l1:\
    \ [1, 4, 3, 34, 653, 2, 5], l2: [5, 7, 1, 5, 9, 653, 121])\n/// [1, 5, 653]\n\
    /// >>> common(l1: [5, 3, 2, 8], l2: [3, 2])\n/// [2, 3]\nfunc common(l1: [Int],\
    \ l2: [Int]) -> [Int] {\n    return Array(Set(l1).intersection(Set(l2))).sorted()\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(common(l1: [1, 4, 3, 34, 653, 2, 5], l2: [5, 7,\
    \ 1, 5, 9, 653, 121]) == [1, 5, 653])\nassert(common(l1: [5, 3, 2, 8], l2: [3,\
    \ 2]) == [2, 3])\nassert(common(l1: [4, 3, 2, 8], l2: [3, 2, 4]) == [2, 3, 4])\n\
    assert(common(l1: [4, 3, 2, 8], l2: [] as [Int]) == [] as [Int])"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659979279
- exit_code: -4
  program: "\n/// Return sorted unique common elements for two arrays.\n/// >>> common(l1:\
    \ [1, 4, 3, 34, 653, 2, 5], l2: [5, 7, 1, 5, 9, 653, 121])\n/// [1, 5, 653]\n\
    /// >>> common(l1: [5, 3, 2, 8], l2: [3, 2])\n/// [2, 3]\nfunc common(l1: [Int],\
    \ l2: [Int]) -> [Int] {\n  return Array(Set(l1).intersection(Set(l2)))\n}\n\n\n\
    func ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(common(l1: [1, 4, 3, 34, 653, 2, 5], l2: [5, 7,\
    \ 1, 5, 9, 653, 121]) == [1, 5, 653])\nassert(common(l1: [5, 3, 2, 8], l2: [3,\
    \ 2]) == [2, 3])\nassert(common(l1: [4, 3, 2, 8], l2: [3, 2, 4]) == [2, 3, 4])\n\
    assert(common(l1: [4, 3, 2, 8], l2: [] as [Int]) == [] as [Int])"
  status: Exception
  stderr: 'tmpd8kd9pul/tmpd8kd9pul.swift:24: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b0683e05c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b0683afcb6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b0683afc988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b0683afb7b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpd8kd9pul                        0x00005556441e05fc <unavailable> + 5628

    5    libc.so.6                          0x00002b0683ff1460 __libc_start_main +
    245

    6    tmpd8kd9pul                        0x00005556441e0179 <unavailable> + 4473

    '
  stdout: ''
  timestamp: 1659979279
- exit_code: 0
  program: "\n/// Return sorted unique common elements for two arrays.\n/// >>> common(l1:\
    \ [1, 4, 3, 34, 653, 2, 5], l2: [5, 7, 1, 5, 9, 653, 121])\n/// [1, 5, 653]\n\
    /// >>> common(l1: [5, 3, 2, 8], l2: [3, 2])\n/// [2, 3]\nfunc common(l1: [Int],\
    \ l2: [Int]) -> [Int] {\n    let s1 = Set(l1)\n    let s2 = Set(l2)\n    let common\
    \ = s1.intersection(s2)\n    return Array(common).sorted()\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(common(l1: [1, 4, 3, 34, 653, 2, 5], l2: [5, 7, 1, 5,\
    \ 9, 653, 121]) == [1, 5, 653])\nassert(common(l1: [5, 3, 2, 8], l2: [3, 2]) ==\
    \ [2, 3])\nassert(common(l1: [4, 3, 2, 8], l2: [3, 2, 4]) == [2, 3, 4])\nassert(common(l1:\
    \ [4, 3, 2, 8], l2: [] as [Int]) == [] as [Int])"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659979279
- exit_code: 1
  program: "\n/// Return sorted unique common elements for two arrays.\n/// >>> common(l1:\
    \ [1, 4, 3, 34, 653, 2, 5], l2: [5, 7, 1, 5, 9, 653, 121])\n/// [1, 5, 653]\n\
    /// >>> common(l1: [5, 3, 2, 8], l2: [3, 2])\n/// [2, 3]\nfunc common(l1: [Int],\
    \ l2: [Int]) -> [Int] {\n    var l = [Int]()\n    l1.forEach {\n        l2.forEach\
    \ {\n            if $0 == $1 {\n                l.append($0)\n            }\n\
    \        }\n    }\n    return l.sorted()\n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(common(l1: [1, 4, 3, 34, 653, 2, 5], l2: [5, 7, 1, 5, 9, 653, 121]) ==\
    \ [1, 5, 653])\nassert(common(l1: [5, 3, 2, 8], l2: [3, 2]) == [2, 3])\nassert(common(l1:\
    \ [4, 3, 2, 8], l2: [3, 2, 4]) == [2, 3, 4])\nassert(common(l1: [4, 3, 2, 8],\
    \ l2: [] as [Int]) == [] as [Int])"
  status: SyntaxError
  stderr: "/tmp/tmp78e4bwrg.swift:9:16: error: contextual type for closure argument\
    \ list expects 1 argument, which cannot be implicitly ignored\n    l1.forEach\
    \ {\n               ^\n                _ in \n/tmp/tmp78e4bwrg.swift:10:20: error:\
    \ contextual closure type '(Int) throws -> Void' expects 1 argument, but 2 were\
    \ used in closure body\n        l2.forEach {\n                   ^\n/tmp/tmp78e4bwrg.swift:11:16:\
    \ note: anonymous closure parameter '$0' is used here\n            if $0 == $1\
    \ {\n               ^\n/tmp/tmp78e4bwrg.swift:11:22: note: anonymous closure parameter\
    \ '$1' is used here\n            if $0 == $1 {\n                     ^\n/tmp/tmp78e4bwrg.swift:12:26:\
    \ note: anonymous closure parameter '$0' is used here\n                l.append($0)\n\
    \                         ^\n"
  stdout: ''
  timestamp: 1659979280
- exit_code: 0
  program: "\n/// Return sorted unique common elements for two arrays.\n/// >>> common(l1:\
    \ [1, 4, 3, 34, 653, 2, 5], l2: [5, 7, 1, 5, 9, 653, 121])\n/// [1, 5, 653]\n\
    /// >>> common(l1: [5, 3, 2, 8], l2: [3, 2])\n/// [2, 3]\nfunc common(l1: [Int],\
    \ l2: [Int]) -> [Int] {\n    // YOUR CODE HERE\n    let set1 = Set(l1)\n    let\
    \ set2 = Set(l2)\n    return Array(set1.intersection(set2)).sorted()\n}\n\n\n\
    func ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(common(l1: [1, 4, 3, 34, 653, 2, 5], l2: [5, 7,\
    \ 1, 5, 9, 653, 121]) == [1, 5, 653])\nassert(common(l1: [5, 3, 2, 8], l2: [3,\
    \ 2]) == [2, 3])\nassert(common(l1: [4, 3, 2, 8], l2: [3, 2, 4]) == [2, 3, 4])\n\
    assert(common(l1: [4, 3, 2, 8], l2: [] as [Int]) == [] as [Int])"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659979280
- exit_code: -4
  program: "\n/// Return sorted unique common elements for two arrays.\n/// >>> common(l1:\
    \ [1, 4, 3, 34, 653, 2, 5], l2: [5, 7, 1, 5, 9, 653, 121])\n/// [1, 5, 653]\n\
    /// >>> common(l1: [5, 3, 2, 8], l2: [3, 2])\n/// [2, 3]\nfunc common(l1: [Int],\
    \ l2: [Int]) -> [Int] {\n    var l3 = [Int]()\n    for a in l1 {\n        for\
    \ b in l2 {\n            if a == b {\n                l3.append(a)\n         \
    \   }\n        }\n    }\n    return l3.sorted()\n}\n\n\nfunc ==(left: [(Int, Int)],\
    \ right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n       \
    \ return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r\
    \ {\n            return false\n        }\n    }\n    return true\n}\n        \
    \    \nassert(common(l1: [1, 4, 3, 34, 653, 2, 5], l2: [5, 7, 1, 5, 9, 653, 121])\
    \ == [1, 5, 653])\nassert(common(l1: [5, 3, 2, 8], l2: [3, 2]) == [2, 3])\nassert(common(l1:\
    \ [4, 3, 2, 8], l2: [3, 2, 4]) == [2, 3, 4])\nassert(common(l1: [4, 3, 2, 8],\
    \ l2: [] as [Int]) == [] as [Int])"
  status: Exception
  stderr: 'tmpxjkf4axk/tmpxjkf4axk.swift:32: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b55d4e22c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b55d4b19b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b55d4b19988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b55d4b187b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpxjkf4axk                        0x0000557e438ef70c <unavailable> + 5900

    5    libc.so.6                          0x00002b55d500e460 __libc_start_main +
    245

    6    tmpxjkf4axk                        0x0000557e438ef289 <unavailable> + 4745

    '
  stdout: ''
  timestamp: 1659979280
- exit_code: -4
  program: "\n/// Return sorted unique common elements for two arrays.\n/// >>> common(l1:\
    \ [1, 4, 3, 34, 653, 2, 5], l2: [5, 7, 1, 5, 9, 653, 121])\n/// [1, 5, 653]\n\
    /// >>> common(l1: [5, 3, 2, 8], l2: [3, 2])\n/// [2, 3]\nfunc common(l1: [Int],\
    \ l2: [Int]) -> [Int] {\n    return Array(Set(l1).intersection(Set(l2)))\n}\n\n\
    \nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(common(l1: [1, 4, 3, 34, 653, 2, 5], l2: [5, 7,\
    \ 1, 5, 9, 653, 121]) == [1, 5, 653])\nassert(common(l1: [5, 3, 2, 8], l2: [3,\
    \ 2]) == [2, 3])\nassert(common(l1: [4, 3, 2, 8], l2: [3, 2, 4]) == [2, 3, 4])\n\
    assert(common(l1: [4, 3, 2, 8], l2: [] as [Int]) == [] as [Int])"
  status: Exception
  stderr: 'tmpzxefsmhz/tmpzxefsmhz.swift:24: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b9cc80f7c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b9cc7deeb6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b9cc7dee988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b9cc7ded7b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpzxefsmhz                        0x0000564df22865fc <unavailable> + 5628

    5    libc.so.6                          0x00002b9cc82e3460 __libc_start_main +
    245

    6    tmpzxefsmhz                        0x0000564df2286179 <unavailable> + 4473

    '
  stdout: ''
  timestamp: 1659979279
- exit_code: 0
  program: "\n/// Return sorted unique common elements for two arrays.\n/// >>> common(l1:\
    \ [1, 4, 3, 34, 653, 2, 5], l2: [5, 7, 1, 5, 9, 653, 121])\n/// [1, 5, 653]\n\
    /// >>> common(l1: [5, 3, 2, 8], l2: [3, 2])\n/// [2, 3]\nfunc common(l1: [Int],\
    \ l2: [Int]) -> [Int] {\n    let uniqueSet1 = Set(l1)\n    let uniqueSet2 = Set(l2)\n\
    \    return Array(uniqueSet1.intersection(uniqueSet2)).sorted()\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(common(l1: [1, 4, 3, 34, 653, 2, 5], l2: [5, 7, 1, 5,\
    \ 9, 653, 121]) == [1, 5, 653])\nassert(common(l1: [5, 3, 2, 8], l2: [3, 2]) ==\
    \ [2, 3])\nassert(common(l1: [4, 3, 2, 8], l2: [3, 2, 4]) == [2, 3, 4])\nassert(common(l1:\
    \ [4, 3, 2, 8], l2: [] as [Int]) == [] as [Int])"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659979280
- exit_code: 0
  program: "\n/// Return sorted unique common elements for two arrays.\n/// >>> common(l1:\
    \ [1, 4, 3, 34, 653, 2, 5], l2: [5, 7, 1, 5, 9, 653, 121])\n/// [1, 5, 653]\n\
    /// >>> common(l1: [5, 3, 2, 8], l2: [3, 2])\n/// [2, 3]\nfunc common(l1: [Int],\
    \ l2: [Int]) -> [Int] {\n    var result: [Int] = []\n    for item in l1 {\n  \
    \      if l2.contains(item) {\n            result.append(item)\n        }\n  \
    \  }\n    return result.sorted()\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int,\
    \ Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n\
    \    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n          \
    \  return false\n        }\n    }\n    return true\n}\n            \nassert(common(l1:\
    \ [1, 4, 3, 34, 653, 2, 5], l2: [5, 7, 1, 5, 9, 653, 121]) == [1, 5, 653])\nassert(common(l1:\
    \ [5, 3, 2, 8], l2: [3, 2]) == [2, 3])\nassert(common(l1: [4, 3, 2, 8], l2: [3,\
    \ 2, 4]) == [2, 3, 4])\nassert(common(l1: [4, 3, 2, 8], l2: [] as [Int]) == []\
    \ as [Int])"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659979280
- exit_code: 0
  program: "\n/// Return sorted unique common elements for two arrays.\n/// >>> common(l1:\
    \ [1, 4, 3, 34, 653, 2, 5], l2: [5, 7, 1, 5, 9, 653, 121])\n/// [1, 5, 653]\n\
    /// >>> common(l1: [5, 3, 2, 8], l2: [3, 2])\n/// [2, 3]\nfunc common(l1: [Int],\
    \ l2: [Int]) -> [Int] {\n    return Set(l1).intersection(Set(l2)).sorted()\n}\n\
    \n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(common(l1: [1, 4, 3, 34, 653, 2, 5], l2: [5, 7,\
    \ 1, 5, 9, 653, 121]) == [1, 5, 653])\nassert(common(l1: [5, 3, 2, 8], l2: [3,\
    \ 2]) == [2, 3])\nassert(common(l1: [4, 3, 2, 8], l2: [3, 2, 4]) == [2, 3, 4])\n\
    assert(common(l1: [4, 3, 2, 8], l2: [] as [Int]) == [] as [Int])"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659979279
- exit_code: 0
  program: "\n/// Return sorted unique common elements for two arrays.\n/// >>> common(l1:\
    \ [1, 4, 3, 34, 653, 2, 5], l2: [5, 7, 1, 5, 9, 653, 121])\n/// [1, 5, 653]\n\
    /// >>> common(l1: [5, 3, 2, 8], l2: [3, 2])\n/// [2, 3]\nfunc common(l1: [Int],\
    \ l2: [Int]) -> [Int] {\n  let l1_set = Set(l1)\n  let l2_set = Set(l2)\n  let\
    \ intersection = l1_set.intersection(l2_set)\n  return Array(intersection).sorted()\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(common(l1: [1, 4, 3, 34, 653, 2, 5], l2: [5, 7,\
    \ 1, 5, 9, 653, 121]) == [1, 5, 653])\nassert(common(l1: [5, 3, 2, 8], l2: [3,\
    \ 2]) == [2, 3])\nassert(common(l1: [4, 3, 2, 8], l2: [3, 2, 4]) == [2, 3, 4])\n\
    assert(common(l1: [4, 3, 2, 8], l2: [] as [Int]) == [] as [Int])"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659979280
- exit_code: 0
  program: "\n/// Return sorted unique common elements for two arrays.\n/// >>> common(l1:\
    \ [1, 4, 3, 34, 653, 2, 5], l2: [5, 7, 1, 5, 9, 653, 121])\n/// [1, 5, 653]\n\
    /// >>> common(l1: [5, 3, 2, 8], l2: [3, 2])\n/// [2, 3]\nfunc common(l1: [Int],\
    \ l2: [Int]) -> [Int] {\n    return Array(Set(l1).intersection(Set(l2))).sorted()\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(common(l1: [1, 4, 3, 34, 653, 2, 5], l2: [5, 7,\
    \ 1, 5, 9, 653, 121]) == [1, 5, 653])\nassert(common(l1: [5, 3, 2, 8], l2: [3,\
    \ 2]) == [2, 3])\nassert(common(l1: [4, 3, 2, 8], l2: [3, 2, 4]) == [2, 3, 4])\n\
    assert(common(l1: [4, 3, 2, 8], l2: [] as [Int]) == [] as [Int])"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659979279
- exit_code: 0
  program: "\n/// Return sorted unique common elements for two arrays.\n/// >>> common(l1:\
    \ [1, 4, 3, 34, 653, 2, 5], l2: [5, 7, 1, 5, 9, 653, 121])\n/// [1, 5, 653]\n\
    /// >>> common(l1: [5, 3, 2, 8], l2: [3, 2])\n/// [2, 3]\nfunc common(l1: [Int],\
    \ l2: [Int]) -> [Int] {\n    return l1.filter { l2.contains($0) }.sorted { $0\
    \ < $1 }\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n\
    \    if left.count != right.count {\n        return false\n    }\n    for (l,\
    \ r) in zip(left, right) {\n        if l != r {\n            return false\n  \
    \      }\n    }\n    return true\n}\n            \nassert(common(l1: [1, 4, 3,\
    \ 34, 653, 2, 5], l2: [5, 7, 1, 5, 9, 653, 121]) == [1, 5, 653])\nassert(common(l1:\
    \ [5, 3, 2, 8], l2: [3, 2]) == [2, 3])\nassert(common(l1: [4, 3, 2, 8], l2: [3,\
    \ 2, 4]) == [2, 3, 4])\nassert(common(l1: [4, 3, 2, 8], l2: [] as [Int]) == []\
    \ as [Int])"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659979279
- exit_code: 1
  program: "\n/// Return sorted unique common elements for two arrays.\n/// >>> common(l1:\
    \ [1, 4, 3, 34, 653, 2, 5], l2: [5, 7, 1, 5, 9, 653, 121])\n/// [1, 5, 653]\n\
    /// >>> common(l1: [5, 3, 2, 8], l2: [3, 2])\n/// [2, 3]\nfunc common(l1: [Int],\
    \ l2: [Int]) -> [Int] {\n    return l1.filter { l2.contains($0) }.distinct()\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(common(l1: [1, 4, 3, 34, 653, 2, 5], l2: [5, 7,\
    \ 1, 5, 9, 653, 121]) == [1, 5, 653])\nassert(common(l1: [5, 3, 2, 8], l2: [3,\
    \ 2]) == [2, 3])\nassert(common(l1: [4, 3, 2, 8], l2: [3, 2, 4]) == [2, 3, 4])\n\
    assert(common(l1: [4, 3, 2, 8], l2: [] as [Int]) == [] as [Int])"
  status: SyntaxError
  stderr: "/tmp/tmpzuxxigau.swift:8:42: error: value of type '[Int]' has no member\
    \ 'distinct'\n    return l1.filter { l2.contains($0) }.distinct()\n          \
    \ ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ ^~~~~~~~\n"
  stdout: ''
  timestamp: 1659979280
- exit_code: 0
  program: "\n/// Return sorted unique common elements for two arrays.\n/// >>> common(l1:\
    \ [1, 4, 3, 34, 653, 2, 5], l2: [5, 7, 1, 5, 9, 653, 121])\n/// [1, 5, 653]\n\
    /// >>> common(l1: [5, 3, 2, 8], l2: [3, 2])\n/// [2, 3]\nfunc common(l1: [Int],\
    \ l2: [Int]) -> [Int] {\n    return Set(l1).intersection(Set(l2)).sorted()\n}\n\
    \n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(common(l1: [1, 4, 3, 34, 653, 2, 5], l2: [5, 7,\
    \ 1, 5, 9, 653, 121]) == [1, 5, 653])\nassert(common(l1: [5, 3, 2, 8], l2: [3,\
    \ 2]) == [2, 3])\nassert(common(l1: [4, 3, 2, 8], l2: [3, 2, 4]) == [2, 3, 4])\n\
    assert(common(l1: [4, 3, 2, 8], l2: [] as [Int]) == [] as [Int])"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659979279
- exit_code: -4
  program: "\n/// Return sorted unique common elements for two arrays.\n/// >>> common(l1:\
    \ [1, 4, 3, 34, 653, 2, 5], l2: [5, 7, 1, 5, 9, 653, 121])\n/// [1, 5, 653]\n\
    /// >>> common(l1: [5, 3, 2, 8], l2: [3, 2])\n/// [2, 3]\nfunc common(l1: [Int],\
    \ l2: [Int]) -> [Int] {\n\treturn Array(Set(l1).intersection(Set(l2)))\n}\n\n\n\
    func ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(common(l1: [1, 4, 3, 34, 653, 2, 5], l2: [5, 7,\
    \ 1, 5, 9, 653, 121]) == [1, 5, 653])\nassert(common(l1: [5, 3, 2, 8], l2: [3,\
    \ 2]) == [2, 3])\nassert(common(l1: [4, 3, 2, 8], l2: [3, 2, 4]) == [2, 3, 4])\n\
    assert(common(l1: [4, 3, 2, 8], l2: [] as [Int]) == [] as [Int])"
  status: Exception
  stderr: 'tmpwy5q_tmg/tmpwy5q_tmg.swift:24: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002ae55a376c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002ae55a06db6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002ae55a06d988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002ae55a06c7b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpwy5q_tmg                        0x00005595cc8f25fc <unavailable> + 5628

    5    libc.so.6                          0x00002ae55a562460 __libc_start_main +
    245

    6    tmpwy5q_tmg                        0x00005595cc8f2179 <unavailable> + 4473

    '
  stdout: ''
  timestamp: 1659979279
- exit_code: -4
  program: "\n/// Return sorted unique common elements for two arrays.\n/// >>> common(l1:\
    \ [1, 4, 3, 34, 653, 2, 5], l2: [5, 7, 1, 5, 9, 653, 121])\n/// [1, 5, 653]\n\
    /// >>> common(l1: [5, 3, 2, 8], l2: [3, 2])\n/// [2, 3]\nfunc common(l1: [Int],\
    \ l2: [Int]) -> [Int] {\n    var result: [Int] = []\n    for i in l1 {\n     \
    \   for j in l2 {\n            if i == j {\n                result.append(i)\n\
    \            }\n        }\n    }\n    return result.sorted()\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(common(l1: [1, 4, 3, 34, 653, 2, 5], l2: [5, 7, 1, 5,\
    \ 9, 653, 121]) == [1, 5, 653])\nassert(common(l1: [5, 3, 2, 8], l2: [3, 2]) ==\
    \ [2, 3])\nassert(common(l1: [4, 3, 2, 8], l2: [3, 2, 4]) == [2, 3, 4])\nassert(common(l1:\
    \ [4, 3, 2, 8], l2: [] as [Int]) == [] as [Int])"
  status: Exception
  stderr: 'tmpaf7rpw5v/tmpaf7rpw5v.swift:32: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b7120ef5c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b7120becb6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b7120bec988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b7120beb7b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpaf7rpw5v                        0x000055e790bf66bc <unavailable> + 5820

    5    libc.so.6                          0x00002b71210e1460 __libc_start_main +
    245

    6    tmpaf7rpw5v                        0x000055e790bf6239 <unavailable> + 4665

    '
  stdout: ''
  timestamp: 1659979279
- exit_code: 0
  program: "\n/// Return sorted unique common elements for two arrays.\n/// >>> common(l1:\
    \ [1, 4, 3, 34, 653, 2, 5], l2: [5, 7, 1, 5, 9, 653, 121])\n/// [1, 5, 653]\n\
    /// >>> common(l1: [5, 3, 2, 8], l2: [3, 2])\n/// [2, 3]\nfunc common(l1: [Int],\
    \ l2: [Int]) -> [Int] {\n    let result = l1.filter({ l2.contains($0) })\n   \
    \ return result.sorted(by: <)\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int,\
    \ Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n\
    \    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n          \
    \  return false\n        }\n    }\n    return true\n}\n            \nassert(common(l1:\
    \ [1, 4, 3, 34, 653, 2, 5], l2: [5, 7, 1, 5, 9, 653, 121]) == [1, 5, 653])\nassert(common(l1:\
    \ [5, 3, 2, 8], l2: [3, 2]) == [2, 3])\nassert(common(l1: [4, 3, 2, 8], l2: [3,\
    \ 2, 4]) == [2, 3, 4])\nassert(common(l1: [4, 3, 2, 8], l2: [] as [Int]) == []\
    \ as [Int])"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659979280
- exit_code: 0
  program: "\n/// Return sorted unique common elements for two arrays.\n/// >>> common(l1:\
    \ [1, 4, 3, 34, 653, 2, 5], l2: [5, 7, 1, 5, 9, 653, 121])\n/// [1, 5, 653]\n\
    /// >>> common(l1: [5, 3, 2, 8], l2: [3, 2])\n/// [2, 3]\nfunc common(l1: [Int],\
    \ l2: [Int]) -> [Int] {\n\tvar result: [Int] = []\n\tfor i in l1 {\n\t\tif l2.contains(i)\
    \ {\n\t\t\tresult.append(i)\n\t\t}\n\t}\n\treturn Array(Set(result)).sorted()\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(common(l1: [1, 4, 3, 34, 653, 2, 5], l2: [5, 7,\
    \ 1, 5, 9, 653, 121]) == [1, 5, 653])\nassert(common(l1: [5, 3, 2, 8], l2: [3,\
    \ 2]) == [2, 3])\nassert(common(l1: [4, 3, 2, 8], l2: [3, 2, 4]) == [2, 3, 4])\n\
    assert(common(l1: [4, 3, 2, 8], l2: [] as [Int]) == [] as [Int])"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659979280
- exit_code: -4
  program: "\n/// Return sorted unique common elements for two arrays.\n/// >>> common(l1:\
    \ [1, 4, 3, 34, 653, 2, 5], l2: [5, 7, 1, 5, 9, 653, 121])\n/// [1, 5, 653]\n\
    /// >>> common(l1: [5, 3, 2, 8], l2: [3, 2])\n/// [2, 3]\nfunc common(l1: [Int],\
    \ l2: [Int]) -> [Int] {\n    return [Int](Set(l1).intersection(Set(l2)))\n}\n\n\
    \nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(common(l1: [1, 4, 3, 34, 653, 2, 5], l2: [5, 7,\
    \ 1, 5, 9, 653, 121]) == [1, 5, 653])\nassert(common(l1: [5, 3, 2, 8], l2: [3,\
    \ 2]) == [2, 3])\nassert(common(l1: [4, 3, 2, 8], l2: [3, 2, 4]) == [2, 3, 4])\n\
    assert(common(l1: [4, 3, 2, 8], l2: [] as [Int]) == [] as [Int])"
  status: Exception
  stderr: 'tmpa_862buv/tmpa_862buv.swift:24: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b0a7039dc80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b0a70094b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b0a70094988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b0a700937b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpa_862buv                        0x000056460457a5fc <unavailable> + 5628

    5    libc.so.6                          0x00002b0a70589460 __libc_start_main +
    245

    6    tmpa_862buv                        0x000056460457a179 <unavailable> + 4473

    '
  stdout: ''
  timestamp: 1659979280
- exit_code: -4
  program: "\n/// Return sorted unique common elements for two arrays.\n/// >>> common(l1:\
    \ [1, 4, 3, 34, 653, 2, 5], l2: [5, 7, 1, 5, 9, 653, 121])\n/// [1, 5, 653]\n\
    /// >>> common(l1: [5, 3, 2, 8], l2: [3, 2])\n/// [2, 3]\nfunc common(l1: [Int],\
    \ l2: [Int]) -> [Int] {\n    return Array(Set(l1).intersection(Set(l2)))\n}\n\n\
    \nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(common(l1: [1, 4, 3, 34, 653, 2, 5], l2: [5, 7,\
    \ 1, 5, 9, 653, 121]) == [1, 5, 653])\nassert(common(l1: [5, 3, 2, 8], l2: [3,\
    \ 2]) == [2, 3])\nassert(common(l1: [4, 3, 2, 8], l2: [3, 2, 4]) == [2, 3, 4])\n\
    assert(common(l1: [4, 3, 2, 8], l2: [] as [Int]) == [] as [Int])"
  status: Exception
  stderr: 'tmpzxefsmhz/tmpzxefsmhz.swift:24: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b9cc80f7c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b9cc7deeb6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b9cc7dee988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b9cc7ded7b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpzxefsmhz                        0x0000564df22865fc <unavailable> + 5628

    5    libc.so.6                          0x00002b9cc82e3460 __libc_start_main +
    245

    6    tmpzxefsmhz                        0x0000564df2286179 <unavailable> + 4473

    '
  stdout: ''
  timestamp: 1659979279
- exit_code: 0
  program: "\n/// Return sorted unique common elements for two arrays.\n/// >>> common(l1:\
    \ [1, 4, 3, 34, 653, 2, 5], l2: [5, 7, 1, 5, 9, 653, 121])\n/// [1, 5, 653]\n\
    /// >>> common(l1: [5, 3, 2, 8], l2: [3, 2])\n/// [2, 3]\nfunc common(l1: [Int],\
    \ l2: [Int]) -> [Int] {\n    var l1 = l1\n    var l2 = l2\n    l1.sort()\n   \
    \ l2.sort()\n    var l3 = [Int]()\n    var i = 0\n    var j = 0\n    while i <\
    \ l1.count && j < l2.count {\n        if l1[i] == l2[j] {\n            l3.append(l1[i])\n\
    \            i += 1\n            j += 1\n        } else if l1[i] < l2[j] {\n \
    \           i += 1\n        } else {\n            j += 1\n        }\n    }\n \
    \   return l3\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool\
    \ {\n    if left.count != right.count {\n        return false\n    }\n    for\
    \ (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(common(l1: [1, 4,\
    \ 3, 34, 653, 2, 5], l2: [5, 7, 1, 5, 9, 653, 121]) == [1, 5, 653])\nassert(common(l1:\
    \ [5, 3, 2, 8], l2: [3, 2]) == [2, 3])\nassert(common(l1: [4, 3, 2, 8], l2: [3,\
    \ 2, 4]) == [2, 3, 4])\nassert(common(l1: [4, 3, 2, 8], l2: [] as [Int]) == []\
    \ as [Int])"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659979280
- exit_code: 0
  program: "\n/// Return sorted unique common elements for two arrays.\n/// >>> common(l1:\
    \ [1, 4, 3, 34, 653, 2, 5], l2: [5, 7, 1, 5, 9, 653, 121])\n/// [1, 5, 653]\n\
    /// >>> common(l1: [5, 3, 2, 8], l2: [3, 2])\n/// [2, 3]\nfunc common(l1: [Int],\
    \ l2: [Int]) -> [Int] {\n    return l1.filter({ l2.contains($0) }).sorted()\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(common(l1: [1, 4, 3, 34, 653, 2, 5], l2: [5, 7,\
    \ 1, 5, 9, 653, 121]) == [1, 5, 653])\nassert(common(l1: [5, 3, 2, 8], l2: [3,\
    \ 2]) == [2, 3])\nassert(common(l1: [4, 3, 2, 8], l2: [3, 2, 4]) == [2, 3, 4])\n\
    assert(common(l1: [4, 3, 2, 8], l2: [] as [Int]) == [] as [Int])"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659979280
- exit_code: 0
  program: "\n/// Return sorted unique common elements for two arrays.\n/// >>> common(l1:\
    \ [1, 4, 3, 34, 653, 2, 5], l2: [5, 7, 1, 5, 9, 653, 121])\n/// [1, 5, 653]\n\
    /// >>> common(l1: [5, 3, 2, 8], l2: [3, 2])\n/// [2, 3]\nfunc common(l1: [Int],\
    \ l2: [Int]) -> [Int] {\n    return Array(Set(l1).intersection(Set(l2))).sorted()\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(common(l1: [1, 4, 3, 34, 653, 2, 5], l2: [5, 7,\
    \ 1, 5, 9, 653, 121]) == [1, 5, 653])\nassert(common(l1: [5, 3, 2, 8], l2: [3,\
    \ 2]) == [2, 3])\nassert(common(l1: [4, 3, 2, 8], l2: [3, 2, 4]) == [2, 3, 4])\n\
    assert(common(l1: [4, 3, 2, 8], l2: [] as [Int]) == [] as [Int])"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659979279
- exit_code: 0
  program: "\n/// Return sorted unique common elements for two arrays.\n/// >>> common(l1:\
    \ [1, 4, 3, 34, 653, 2, 5], l2: [5, 7, 1, 5, 9, 653, 121])\n/// [1, 5, 653]\n\
    /// >>> common(l1: [5, 3, 2, 8], l2: [3, 2])\n/// [2, 3]\nfunc common(l1: [Int],\
    \ l2: [Int]) -> [Int] {\n    var both = [Int]()\n    let s1 = l1.sorted()\n  \
    \  let s2 = l2.sorted()\n    var i = 0\n    var j = 0\n    while i < s1.count\
    \ && j < s2.count {\n        if s1[i] < s2[j] {\n            i += 1\n        }\
    \ else if s1[i] > s2[j] {\n            j += 1\n        } else {\n            both.append(s1[i])\n\
    \            i += 1\n            j += 1\n        }\n    }\n    return both\n}\n\
    \n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(common(l1: [1, 4, 3, 34, 653, 2, 5], l2: [5, 7,\
    \ 1, 5, 9, 653, 121]) == [1, 5, 653])\nassert(common(l1: [5, 3, 2, 8], l2: [3,\
    \ 2]) == [2, 3])\nassert(common(l1: [4, 3, 2, 8], l2: [3, 2, 4]) == [2, 3, 4])\n\
    assert(common(l1: [4, 3, 2, 8], l2: [] as [Int]) == [] as [Int])"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659979280
- exit_code: 0
  program: "\n/// Return sorted unique common elements for two arrays.\n/// >>> common(l1:\
    \ [1, 4, 3, 34, 653, 2, 5], l2: [5, 7, 1, 5, 9, 653, 121])\n/// [1, 5, 653]\n\
    /// >>> common(l1: [5, 3, 2, 8], l2: [3, 2])\n/// [2, 3]\nfunc common(l1: [Int],\
    \ l2: [Int]) -> [Int] {\n    var result: [Int] = []\n    for item in l1 {\n  \
    \      if l2.contains(item) {\n            result.append(item)\n        }\n  \
    \  }\n    return Set(result).sorted()\n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(common(l1: [1, 4, 3, 34, 653, 2, 5], l2: [5, 7, 1, 5, 9, 653, 121]) ==\
    \ [1, 5, 653])\nassert(common(l1: [5, 3, 2, 8], l2: [3, 2]) == [2, 3])\nassert(common(l1:\
    \ [4, 3, 2, 8], l2: [3, 2, 4]) == [2, 3, 4])\nassert(common(l1: [4, 3, 2, 8],\
    \ l2: [] as [Int]) == [] as [Int])"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659979280
- exit_code: 0
  program: "\n/// Return sorted unique common elements for two arrays.\n/// >>> common(l1:\
    \ [1, 4, 3, 34, 653, 2, 5], l2: [5, 7, 1, 5, 9, 653, 121])\n/// [1, 5, 653]\n\
    /// >>> common(l1: [5, 3, 2, 8], l2: [3, 2])\n/// [2, 3]\nfunc common(l1: [Int],\
    \ l2: [Int]) -> [Int] {\n    return Array(Set(l1).intersection(Set(l2))).sorted()\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(common(l1: [1, 4, 3, 34, 653, 2, 5], l2: [5, 7,\
    \ 1, 5, 9, 653, 121]) == [1, 5, 653])\nassert(common(l1: [5, 3, 2, 8], l2: [3,\
    \ 2]) == [2, 3])\nassert(common(l1: [4, 3, 2, 8], l2: [3, 2, 4]) == [2, 3, 4])\n\
    assert(common(l1: [4, 3, 2, 8], l2: [] as [Int]) == [] as [Int])"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659979279
- exit_code: 1
  program: "\n/// Return sorted unique common elements for two arrays.\n/// >>> common(l1:\
    \ [1, 4, 3, 34, 653, 2, 5], l2: [5, 7, 1, 5, 9, 653, 121])\n/// [1, 5, 653]\n\
    /// >>> common(l1: [5, 3, 2, 8], l2: [3, 2])\n/// [2, 3]\nfunc common(l1: [Int],\
    \ l2: [Int]) -> [Int] {\n    let unique = Array(Set(l1 + l2))\n    return unique.filter({\
    \ contains(l1, $0) && contains(l2, $0) })\n}\n\n\nfunc ==(left: [(Int, Int)],\
    \ right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n       \
    \ return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r\
    \ {\n            return false\n        }\n    }\n    return true\n}\n        \
    \    \nassert(common(l1: [1, 4, 3, 34, 653, 2, 5], l2: [5, 7, 1, 5, 9, 653, 121])\
    \ == [1, 5, 653])\nassert(common(l1: [5, 3, 2, 8], l2: [3, 2]) == [2, 3])\nassert(common(l1:\
    \ [4, 3, 2, 8], l2: [3, 2, 4]) == [2, 3, 4])\nassert(common(l1: [4, 3, 2, 8],\
    \ l2: [] as [Int]) == [] as [Int])"
  status: SyntaxError
  stderr: "/tmp/tmpmmvtk89_.swift:9:28: error: cannot find 'contains' in scope\n \
    \   return unique.filter({ contains(l1, $0) && contains(l2, $0) })\n         \
    \                  ^~~~~~~~\n/tmp/tmpmmvtk89_.swift:9:48: error: cannot find 'contains'\
    \ in scope\n    return unique.filter({ contains(l1, $0) && contains(l2, $0) })\n\
    \                                               ^~~~~~~~\n"
  stdout: ''
  timestamp: 1659979280
- exit_code: -4
  program: "\n/// Return sorted unique common elements for two arrays.\n/// >>> common(l1:\
    \ [1, 4, 3, 34, 653, 2, 5], l2: [5, 7, 1, 5, 9, 653, 121])\n/// [1, 5, 653]\n\
    /// >>> common(l1: [5, 3, 2, 8], l2: [3, 2])\n/// [2, 3]\nfunc common(l1: [Int],\
    \ l2: [Int]) -> [Int] {\n    let hashTable: [Int: Int] = l1.reduce(into: [:])\
    \ { (dict, int) in\n        dict[int, default: 0] += 1\n    }\n    return l2.filter\
    \ { hashTable[$0] != nil }\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(common(l1:\
    \ [1, 4, 3, 34, 653, 2, 5], l2: [5, 7, 1, 5, 9, 653, 121]) == [1, 5, 653])\nassert(common(l1:\
    \ [5, 3, 2, 8], l2: [3, 2]) == [2, 3])\nassert(common(l1: [4, 3, 2, 8], l2: [3,\
    \ 2, 4]) == [2, 3, 4])\nassert(common(l1: [4, 3, 2, 8], l2: [] as [Int]) == []\
    \ as [Int])"
  status: Exception
  stderr: 'tmpi2f3xptn/tmpi2f3xptn.swift:27: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b4949c15c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b494990cb6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b494990c988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b494990b7b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpi2f3xptn                        0x00005595869657bc <unavailable> + 6076

    5    libc.so.6                          0x00002b4949e01460 __libc_start_main +
    245

    6    tmpi2f3xptn                        0x0000559586965339 <unavailable> + 4921

    '
  stdout: ''
  timestamp: 1659979280
- exit_code: 0
  program: "\n/// Return sorted unique common elements for two arrays.\n/// >>> common(l1:\
    \ [1, 4, 3, 34, 653, 2, 5], l2: [5, 7, 1, 5, 9, 653, 121])\n/// [1, 5, 653]\n\
    /// >>> common(l1: [5, 3, 2, 8], l2: [3, 2])\n/// [2, 3]\nfunc common(l1: [Int],\
    \ l2: [Int]) -> [Int] {\n    var r = [Int]()\n    for e in l1 {\n        if l2.contains(e)\
    \ {\n            r.append(e)\n        }\n    }\n    r.sort()\n    r = Array(Set(r))\n\
    \    return r\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool\
    \ {\n    if left.count != right.count {\n        return false\n    }\n    for\
    \ (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(common(l1: [1, 4,\
    \ 3, 34, 653, 2, 5], l2: [5, 7, 1, 5, 9, 653, 121]) == [1, 5, 653])\nassert(common(l1:\
    \ [5, 3, 2, 8], l2: [3, 2]) == [2, 3])\nassert(common(l1: [4, 3, 2, 8], l2: [3,\
    \ 2, 4]) == [2, 3, 4])\nassert(common(l1: [4, 3, 2, 8], l2: [] as [Int]) == []\
    \ as [Int])"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659979280
- exit_code: -4
  program: "\n/// Return sorted unique common elements for two arrays.\n/// >>> common(l1:\
    \ [1, 4, 3, 34, 653, 2, 5], l2: [5, 7, 1, 5, 9, 653, 121])\n/// [1, 5, 653]\n\
    /// >>> common(l1: [5, 3, 2, 8], l2: [3, 2])\n/// [2, 3]\nfunc common(l1: [Int],\
    \ l2: [Int]) -> [Int] {\n    var result: [Int] = []\n    var index1 = 0\n    var\
    \ index2 = 0\n    while (index1 < l1.count && index2 < l2.count) {\n        if\
    \ (l1[index1] == l2[index2]) {\n            if (!result.contains(l1[index1]))\
    \ {\n                result.append(l1[index1])\n            }\n            index1\
    \ += 1\n            index2 += 1\n        } else if (l1[index1] < l2[index2]) {\n\
    \            index1 += 1\n        } else {\n            index2 += 1\n        }\n\
    \    }\n    return result\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(common(l1:\
    \ [1, 4, 3, 34, 653, 2, 5], l2: [5, 7, 1, 5, 9, 653, 121]) == [1, 5, 653])\nassert(common(l1:\
    \ [5, 3, 2, 8], l2: [3, 2]) == [2, 3])\nassert(common(l1: [4, 3, 2, 8], l2: [3,\
    \ 2, 4]) == [2, 3, 4])\nassert(common(l1: [4, 3, 2, 8], l2: [] as [Int]) == []\
    \ as [Int])"
  status: Exception
  stderr: 'tmpd4kq2t7g/tmpd4kq2t7g.swift:40: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b78697b6c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b78694adb6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b78694ad988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b78694ac7b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpd4kq2t7g                        0x0000564242e415bc <unavailable> + 5564

    5    libc.so.6                          0x00002b78699a2460 __libc_start_main +
    245

    6    tmpd4kq2t7g                        0x0000564242e41139 <unavailable> + 4409

    '
  stdout: ''
  timestamp: 1659979280
- exit_code: 0
  program: "\n/// Return sorted unique common elements for two arrays.\n/// >>> common(l1:\
    \ [1, 4, 3, 34, 653, 2, 5], l2: [5, 7, 1, 5, 9, 653, 121])\n/// [1, 5, 653]\n\
    /// >>> common(l1: [5, 3, 2, 8], l2: [3, 2])\n/// [2, 3]\nfunc common(l1: [Int],\
    \ l2: [Int]) -> [Int] {\n    var commonList = [Int]()\n    let set1 = Set(l1)\n\
    \    let set2 = Set(l2)\n    for item in set1 {\n        if set2.contains(item)\
    \ {\n            commonList.append(item)\n        }\n    }\n    return commonList.sorted()\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(common(l1: [1, 4, 3, 34, 653, 2, 5], l2: [5, 7,\
    \ 1, 5, 9, 653, 121]) == [1, 5, 653])\nassert(common(l1: [5, 3, 2, 8], l2: [3,\
    \ 2]) == [2, 3])\nassert(common(l1: [4, 3, 2, 8], l2: [3, 2, 4]) == [2, 3, 4])\n\
    assert(common(l1: [4, 3, 2, 8], l2: [] as [Int]) == [] as [Int])"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659979280
- exit_code: -4
  program: "\n/// Return sorted unique common elements for two arrays.\n/// >>> common(l1:\
    \ [1, 4, 3, 34, 653, 2, 5], l2: [5, 7, 1, 5, 9, 653, 121])\n/// [1, 5, 653]\n\
    /// >>> common(l1: [5, 3, 2, 8], l2: [3, 2])\n/// [2, 3]\nfunc common(l1: [Int],\
    \ l2: [Int]) -> [Int] {\n    // TODO: Write some code to get the expected output!\n\
    \    return []\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool\
    \ {\n    if left.count != right.count {\n        return false\n    }\n    for\
    \ (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(common(l1: [1, 4,\
    \ 3, 34, 653, 2, 5], l2: [5, 7, 1, 5, 9, 653, 121]) == [1, 5, 653])\nassert(common(l1:\
    \ [5, 3, 2, 8], l2: [3, 2]) == [2, 3])\nassert(common(l1: [4, 3, 2, 8], l2: [3,\
    \ 2, 4]) == [2, 3, 4])\nassert(common(l1: [4, 3, 2, 8], l2: [] as [Int]) == []\
    \ as [Int])"
  status: Exception
  stderr: 'tmpw8gu0rao/tmpw8gu0rao.swift:25: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b65f8765c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b65f845cb6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b65f845c988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b65f845b7b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpw8gu0rao                        0x000055d57a03d44c <unavailable> + 5196

    5    libc.so.6                          0x00002b65f8951460 __libc_start_main +
    245

    6    tmpw8gu0rao                        0x000055d57a03cfc9 <unavailable> + 4041

    '
  stdout: ''
  timestamp: 1659979280
- exit_code: 0
  program: "\n/// Return sorted unique common elements for two arrays.\n/// >>> common(l1:\
    \ [1, 4, 3, 34, 653, 2, 5], l2: [5, 7, 1, 5, 9, 653, 121])\n/// [1, 5, 653]\n\
    /// >>> common(l1: [5, 3, 2, 8], l2: [3, 2])\n/// [2, 3]\nfunc common(l1: [Int],\
    \ l2: [Int]) -> [Int] {\n  return Array(Set(l1).intersection(Set(l2))).sorted()\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(common(l1: [1, 4, 3, 34, 653, 2, 5], l2: [5, 7,\
    \ 1, 5, 9, 653, 121]) == [1, 5, 653])\nassert(common(l1: [5, 3, 2, 8], l2: [3,\
    \ 2]) == [2, 3])\nassert(common(l1: [4, 3, 2, 8], l2: [3, 2, 4]) == [2, 3, 4])\n\
    assert(common(l1: [4, 3, 2, 8], l2: [] as [Int]) == [] as [Int])"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659979280
- exit_code: 0
  program: "\n/// Return sorted unique common elements for two arrays.\n/// >>> common(l1:\
    \ [1, 4, 3, 34, 653, 2, 5], l2: [5, 7, 1, 5, 9, 653, 121])\n/// [1, 5, 653]\n\
    /// >>> common(l1: [5, 3, 2, 8], l2: [3, 2])\n/// [2, 3]\nfunc common(l1: [Int],\
    \ l2: [Int]) -> [Int] {\n    let set = Set(l1)\n    let set2 = Set(l2)\n    let\
    \ union = set.intersection(set2)\n    return Array(union).sorted()\n}\n\n\nfunc\
    \ ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count !=\
    \ right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(common(l1: [1, 4, 3, 34, 653, 2, 5], l2: [5, 7,\
    \ 1, 5, 9, 653, 121]) == [1, 5, 653])\nassert(common(l1: [5, 3, 2, 8], l2: [3,\
    \ 2]) == [2, 3])\nassert(common(l1: [4, 3, 2, 8], l2: [3, 2, 4]) == [2, 3, 4])\n\
    assert(common(l1: [4, 3, 2, 8], l2: [] as [Int]) == [] as [Int])"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659979280
- exit_code: 0
  program: "\n/// Return sorted unique common elements for two arrays.\n/// >>> common(l1:\
    \ [1, 4, 3, 34, 653, 2, 5], l2: [5, 7, 1, 5, 9, 653, 121])\n/// [1, 5, 653]\n\
    /// >>> common(l1: [5, 3, 2, 8], l2: [3, 2])\n/// [2, 3]\nfunc common(l1: [Int],\
    \ l2: [Int]) -> [Int] {\n    var res: [Int] = []\n    var l2c = l2\n    for i\
    \ in l1 {\n        if let index = l2c.firstIndex(of: i) {\n            res.append(i)\n\
    \            l2c.remove(at: index)\n        }\n    }\n    return res.sorted()\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(common(l1: [1, 4, 3, 34, 653, 2, 5], l2: [5, 7,\
    \ 1, 5, 9, 653, 121]) == [1, 5, 653])\nassert(common(l1: [5, 3, 2, 8], l2: [3,\
    \ 2]) == [2, 3])\nassert(common(l1: [4, 3, 2, 8], l2: [3, 2, 4]) == [2, 3, 4])\n\
    assert(common(l1: [4, 3, 2, 8], l2: [] as [Int]) == [] as [Int])"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659979280
- exit_code: 0
  program: "\n/// Return sorted unique common elements for two arrays.\n/// >>> common(l1:\
    \ [1, 4, 3, 34, 653, 2, 5], l2: [5, 7, 1, 5, 9, 653, 121])\n/// [1, 5, 653]\n\
    /// >>> common(l1: [5, 3, 2, 8], l2: [3, 2])\n/// [2, 3]\nfunc common(l1: [Int],\
    \ l2: [Int]) -> [Int] {\n    let set1 = Set(l1)\n    let set2 = Set(l2)\n    let\
    \ inter = set1.intersection(set2)\n    let sorted = inter.sorted()\n    return\
    \ sorted\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n\
    \    if left.count != right.count {\n        return false\n    }\n    for (l,\
    \ r) in zip(left, right) {\n        if l != r {\n            return false\n  \
    \      }\n    }\n    return true\n}\n            \nassert(common(l1: [1, 4, 3,\
    \ 34, 653, 2, 5], l2: [5, 7, 1, 5, 9, 653, 121]) == [1, 5, 653])\nassert(common(l1:\
    \ [5, 3, 2, 8], l2: [3, 2]) == [2, 3])\nassert(common(l1: [4, 3, 2, 8], l2: [3,\
    \ 2, 4]) == [2, 3, 4])\nassert(common(l1: [4, 3, 2, 8], l2: [] as [Int]) == []\
    \ as [Int])"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659979280
- exit_code: 0
  program: "\n/// Return sorted unique common elements for two arrays.\n/// >>> common(l1:\
    \ [1, 4, 3, 34, 653, 2, 5], l2: [5, 7, 1, 5, 9, 653, 121])\n/// [1, 5, 653]\n\
    /// >>> common(l1: [5, 3, 2, 8], l2: [3, 2])\n/// [2, 3]\nfunc common(l1: [Int],\
    \ l2: [Int]) -> [Int] {\n    let l1 = Set(l1)\n    let l2 = Set(l2)\n    let intersection\
    \ = l1.intersection(l2)\n    return Array(intersection).sorted()\n}\n\n\nfunc\
    \ ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count !=\
    \ right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(common(l1: [1, 4, 3, 34, 653, 2, 5], l2: [5, 7,\
    \ 1, 5, 9, 653, 121]) == [1, 5, 653])\nassert(common(l1: [5, 3, 2, 8], l2: [3,\
    \ 2]) == [2, 3])\nassert(common(l1: [4, 3, 2, 8], l2: [3, 2, 4]) == [2, 3, 4])\n\
    assert(common(l1: [4, 3, 2, 8], l2: [] as [Int]) == [] as [Int])"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659979280
- exit_code: 0
  program: "\n/// Return sorted unique common elements for two arrays.\n/// >>> common(l1:\
    \ [1, 4, 3, 34, 653, 2, 5], l2: [5, 7, 1, 5, 9, 653, 121])\n/// [1, 5, 653]\n\
    /// >>> common(l1: [5, 3, 2, 8], l2: [3, 2])\n/// [2, 3]\nfunc common(l1: [Int],\
    \ l2: [Int]) -> [Int] {\n    let l1Set = Set(l1)\n    let l2Set = Set(l2)\n  \
    \  let l3Set = l1Set.intersection(l2Set)\n    return Array(l3Set).sorted()\n}\n\
    \n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(common(l1: [1, 4, 3, 34, 653, 2, 5], l2: [5, 7,\
    \ 1, 5, 9, 653, 121]) == [1, 5, 653])\nassert(common(l1: [5, 3, 2, 8], l2: [3,\
    \ 2]) == [2, 3])\nassert(common(l1: [4, 3, 2, 8], l2: [3, 2, 4]) == [2, 3, 4])\n\
    assert(common(l1: [4, 3, 2, 8], l2: [] as [Int]) == [] as [Int])"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659979280
- exit_code: 1
  program: "\n/// Return sorted unique common elements for two arrays.\n/// >>> common(l1:\
    \ [1, 4, 3, 34, 653, 2, 5], l2: [5, 7, 1, 5, 9, 653, 121])\n/// [1, 5, 653]\n\
    /// >>> common(l1: [5, 3, 2, 8], l2: [3, 2])\n/// [2, 3]\nfunc common(l1: [Int],\
    \ l2: [Int]) -> [Int] {\n    let unique_l1 = unique(array: l1)\n    let unique_l2\
    \ = unique(array: l2)\n    var result: [Int] = []\n    for i in unique_l1 {\n\
    \        for j in unique_l2 {\n            if i == j {\n                result.append(i)\n\
    \            }\n        }\n    }\n    return result\n}\n\n\nfunc ==(left: [(Int,\
    \ Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n\
    \        return false\n    }\n    for (l, r) in zip(left, right) {\n        if\
    \ l != r {\n            return false\n        }\n    }\n    return true\n}\n \
    \           \nassert(common(l1: [1, 4, 3, 34, 653, 2, 5], l2: [5, 7, 1, 5, 9,\
    \ 653, 121]) == [1, 5, 653])\nassert(common(l1: [5, 3, 2, 8], l2: [3, 2]) == [2,\
    \ 3])\nassert(common(l1: [4, 3, 2, 8], l2: [3, 2, 4]) == [2, 3, 4])\nassert(common(l1:\
    \ [4, 3, 2, 8], l2: [] as [Int]) == [] as [Int])"
  status: SyntaxError
  stderr: "/tmp/tmpbi5bgltx.swift:8:21: error: cannot find 'unique' in scope\n   \
    \ let unique_l1 = unique(array: l1)\n                    ^~~~~~\n/tmp/tmpbi5bgltx.swift:9:21:\
    \ error: cannot find 'unique' in scope\n    let unique_l2 = unique(array: l2)\n\
    \                    ^~~~~~\n"
  stdout: ''
  timestamp: 1659979280
- exit_code: 0
  program: "\n/// Return sorted unique common elements for two arrays.\n/// >>> common(l1:\
    \ [1, 4, 3, 34, 653, 2, 5], l2: [5, 7, 1, 5, 9, 653, 121])\n/// [1, 5, 653]\n\
    /// >>> common(l1: [5, 3, 2, 8], l2: [3, 2])\n/// [2, 3]\nfunc common(l1: [Int],\
    \ l2: [Int]) -> [Int] {\n    let result = Set(l1).intersection(Set(l2))\n    return\
    \ Array(result).sorted()\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(common(l1:\
    \ [1, 4, 3, 34, 653, 2, 5], l2: [5, 7, 1, 5, 9, 653, 121]) == [1, 5, 653])\nassert(common(l1:\
    \ [5, 3, 2, 8], l2: [3, 2]) == [2, 3])\nassert(common(l1: [4, 3, 2, 8], l2: [3,\
    \ 2, 4]) == [2, 3, 4])\nassert(common(l1: [4, 3, 2, 8], l2: [] as [Int]) == []\
    \ as [Int])"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659979279
