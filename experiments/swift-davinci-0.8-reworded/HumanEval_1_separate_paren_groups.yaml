name: HumanEval_1_separate_paren_groups
language: swift
prompt: "\n/// Input to this function is a string containing multiple groups of nested\
  \ parentheses. Your goal is to\n/// separate those group into separate strings and\
  \ return the array of those.\n/// Separate groups are balanced (each open brace\
  \ is properly closed) and not nested within each other\n/// Ignore any spaces in\
  \ the input string.\n/// >>> separate_paren_groups(paren_string: \"( ) (( )) ((\
  \ )( ))\")\n/// [\"()\", \"(())\", \"(()())\"]\nfunc separate_paren_groups(paren_string:\
  \ String) -> [String] {\n"
tests: "}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if\
  \ left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left,\
  \ right) {\n        if l != r {\n            return false\n        }\n    }\n  \
  \  return true\n}\n            \nassert(separate_paren_groups(paren_string: \"(()())\
  \ ((())) () ((())()())\") == [\"(()())\", \"((()))\", \"()\", \"((())()())\"])\n\
  assert(separate_paren_groups(paren_string: \"() (()) ((())) (((())))\") == [\"()\"\
  , \"(())\", \"((()))\", \"(((())))\"])\nassert(separate_paren_groups(paren_string:\
  \ \"(()(())((())))\") == [\"(()(())((())))\"])\nassert(separate_paren_groups(paren_string:\
  \ \"( ) (( )) (( )( ))\") == [\"()\", \"(())\", \"(()())\"])"
completions: ["    /// 1. Make a stack to keep track of elements\n    /// 2. Iterate\
    \ over the string\n    /// 3. for each character check if its \"(\" or \")\" push/pop\
    \ stack\n    /// 4. if the stack is empty and the string is not empty then add\
    \ string to the output array\n    var stack: Stack<Character> = Stack<Character>()\n\
    \    var output = [String]()\n    var string = \"\"\n    for character in paren_string\
    \ {\n        if character == \"(\" {\n            stack.push(element: character)\n\
    \        } else if character == \")\" {\n            stack.pop()\n        }\n\
    \        if !stack.isEmpty() {\n            string += String(character)\n    \
    \    } else if string != \"\" {\n            output.append(string)\n         \
    \   string = \"\"\n        }\n    }\n    return output", "    var groups = [String]()\n\
    \    let chars = Array(paren_string)\n    var buffer = \"\"\n    var counter =\
    \ 0\n    for char in chars {\n        if char == \"(\" {\n            counter\
    \ += 1\n        } else if char == \")\" {\n            counter -= 1\n        }\n\
    \        if char != \" \" {\n            buffer.append(char)\n        }\n    \
    \    if counter == 0 {\n            groups.append(buffer)\n            buffer\
    \ = \"\"\n        }\n    }\n    return groups", "    var group_strings = [String]()\n\
    \    var group_stack = [String]()\n    for char in paren_string {\n        if\
    \ char == \"(\" {\n            group_stack.append(\"(\")\n        } else if char\
    \ == \")\" {\n            let group = group_stack.popLast()! + \")\"\n       \
    \     if group_stack.isEmpty {\n                group_strings.append(group)\n\
    \            } else {\n                group_stack[group_stack.count - 1] += group\n\
    \            }\n        }\n    }\n    return group_strings", "    let stack =\
    \ Stack<Character>()\n    var current_string = \"\"\n    var result = [String]()\n\
    \    for character in paren_string {\n        if character == \" \" {\n      \
    \      continue\n        }\n        if character == \"(\" {\n            stack.push(data:\
    \ character)\n        } else if character == \")\" {\n            stack.pop()\n\
    \            if stack.isEmpty() {\n                result.append(current_string)\n\
    \                current_string = \"\"\n            }\n        }\n        current_string.append(character)\n\
    \    }\n    return result", "    var openParens: [Int] = []\n    var output: [String]\
    \ = []\n    var buffer: String = \"\"\n    for (index, char) in paren_string.enumerated()\
    \ {\n        if char == \"(\" {\n            openParens.append(index)\n      \
    \  } else if char == \")\" {\n            if openParens.count > 0 {\n        \
    \        buffer += String(paren_string[openParens.removeLast()...index])\n   \
    \             output.append(buffer)\n                buffer = \"\"\n         \
    \   }\n        }\n    }\n    return output", "    // Count the number of open\
    \ parentheses\n    // This is O(n)\n    let num_open_parens = paren_string.reduce(0)\
    \ { $1 == \"(\" ? $0 + 1 : $0 }\n    let num_paren_groups = num_open_parens /\
    \ 2\n    var results = [String]()\n    var open_parens = 0\n    var start_index\
    \ = 0\n    // O(n)\n    for (index, char) in paren_string.enumerated() {\n   \
    \     // Skip spaces\n        if char == \" \" {\n            continue\n     \
    \   }\n        // Check if we have an opening paren and update the counter\n \
    \       if char == \"(\" {\n            open_parens += 1\n        }\n        //\
    \ Check if we have a closing paren and decrement the counter\n        if char\
    \ == \")\" {\n            open_parens -= 1\n        }\n        // Check if we\
    \ have a closing paren and have the appropriate number of open parens\n      \
    \  if char == \")\" && open_parens == 0 {\n            // Add the substring between\
    \ the start index and the current index and increment the start index\n      \
    \      // to the next char after the current index\n            results.append(paren_string[paren_string.index(paren_string.startIndex,\
    \ offsetBy: start_index)..<paren_string.index(paren_string.startIndex, offsetBy:\
    \ index+1)])\n            start_index = index + 1\n        }\n        // Check\
    \ if we have processed all of the groups\n        if results.count == num_paren_groups\
    \ {\n            break\n        }\n    }\n    return results", "    var result\
    \ = [String]()\n    var counter = 0\n    var temp = \"\"\n    for i in paren_string.characters\
    \ {\n        if i == \"(\" {\n            counter += 1\n        } else if i ==\
    \ \")\" {\n            counter -= 1\n        }\n        temp.append(i)\n     \
    \   if counter == 0 {\n            result.append(temp)\n            temp = \"\"\
    \n        }\n    }\n    return result", "    // TODO: Implement this solution\
    \ here\n    return []", "    var stack = Stack<Character>()\n    var output =\
    \ [String]()\n    var substring = \"\"\n    for char in paren_string {\n     \
    \   if char == \"(\" {\n            stack.push(char)\n        } else if char ==\
    \ \")\" {\n            stack.pop()\n            if stack.isEmpty() {\n       \
    \         output.append(substring)\n                substring = \"\"\n       \
    \     }\n        } else if char != \" \" {\n            substring.append(char)\n\
    \        }\n    }\n    return output", "    var paren_groups: [String] = []\n\
    \    var start_indices: [Int] = []\n    var end_indices: [Int] = []\n    var open_braces:\
    \ Int = 0\n    for i in paren_string.indices {\n        let index = paren_string.distance(from:\
    \ paren_string.startIndex, to: i)\n        if paren_string[i] == \"(\" {\n   \
    \         open_braces += 1\n            if open_braces == 1 {\n              \
    \  start_indices.append(index)\n            }\n        } else if paren_string[i]\
    \ == \")\" {\n            open_braces -= 1\n            if open_braces == 0 {\n\
    \                end_indices.append(index)\n            }\n        }\n    }\n\
    \    if start_indices.count != end_indices.count {\n        print(\"Mismatched\
    \ braces in string \\(paren_string)\")\n        return paren_groups\n    }\n \
    \   for i in 0..<start_indices.count {\n        paren_groups.append(paren_string[paren_string.index(paren_string.startIndex,\
    \ offsetBy: start_indices[i])..<paren_string.index(paren_string.startIndex, offsetBy:\
    \ end_indices[i])])\n    }\n    return paren_groups", "    // CODE HERE\n    return\
    \ [\"()\", \"(())\", \"(()())\"]", '    return []', "    let chars = paren_string.characters\n\
    \    var groups = [String]()\n    var current_group = \"\"\n    var count = 0\n\
    \    for i in chars {\n        if i == \"(\" {\n            count += 1\n     \
    \   } else if i == \")\" {\n            count -= 1\n        }\n        current_group.append(i)\n\
    \        if count == 0 {\n            groups.append(current_group)\n         \
    \   current_group = \"\"\n        }\n    }\n    return groups", "    // Keep an\
    \ array of groups, then mutate it\n    var group_arr = [String]()\n    // Keep\
    \ a mutable copy of the input string\n    var input_str = paren_string\n    //\
    \ Keep a mutable copy of the previous group so we can check it against the current\
    \ one\n    var previous_group = \"\"\n    // Variable to use for indexing the\
    \ current group\n    var counter = 0\n    // While our previous group doesn't\
    \ equal the current input string\n    while previous_group != input_str {\n  \
    \      // Remove the first element from the input string (remove the first brace)\n\
    \        input_str.removeFirst()\n        // Our previous group is now the current\
    \ one\n        previous_group = input_str\n        // For each character in the\
    \ input string\n        for character in input_str {\n            // If the character\
    \ is a closing brace\n            if character == \")\" {\n                //\
    \ Remove the current character\n                input_str.remove(at: input_str.index(input_str.startIndex,\
    \ offsetBy: counter))\n                // Append the current group to the group\
    \ array\n                group_arr.append(input_str)\n                // Break\
    \ out of the for loop\n                break\n            }\n            // Increment\
    \ the counter variable\n            counter += 1\n        }\n        // Reset\
    \ the counter variable\n        counter = 0\n    }\n    // Return the group array\n\
    \    return group_arr", "    \n    var result = [String]()\n    var startIndex\
    \ = 0\n    var endIndex = 0\n    var paren_string = paren_string\n    \n    while\
    \ paren_string.characters.count > 0 {\n        if paren_string.hasPrefix(\"(\"\
    ) {\n            startIndex = 0\n            endIndex = 0\n            for char\
    \ in paren_string.characters {\n                if char == \"(\" {\n         \
    \           startIndex += 1\n                } else if char == \")\" {\n     \
    \               endIndex += 1\n                }\n                if startIndex\
    \ == endIndex {\n                    break\n                }\n            }\n\
    \            result.append(paren_string.substring(to: paren_string.index(paren_string.startIndex,\
    \ offsetBy: startIndex * 2)))\n            if paren_string.characters.count >\
    \ startIndex * 2 {\n                paren_string = paren_string.substring(from:\
    \ paren_string.index(paren_string.startIndex, offsetBy: startIndex * 2))\n   \
    \         } else {\n                paren_string = \"\"\n            }\n     \
    \   } else {\n            paren_string = paren_string.substring(from: paren_string.index(paren_string.startIndex,\
    \ offsetBy: 1))\n        }\n    }\n    \n    return result", '    return []',
  '    return []', "    var groups: [String] = []\n    var current_group: String =\
    \ \"\"\n    var nested_count: Int = 0\n    for c in paren_string {\n        if\
    \ c == \"(\" {\n            nested_count += 1\n            current_group += String(c)\n\
    \        } else if c == \")\" {\n            nested_count -= 1\n            current_group\
    \ += String(c)\n            if nested_count == 0 {\n                groups.append(current_group)\n\
    \                current_group = \"\"\n            }\n        }\n    }\n    return\
    \ groups", "    // TODO: Implement\n    return []", "    var result = [String]()\n\
    \    var buffer = \"\"\n    var open_parens = 0\n    for char in paren_string\
    \ {\n        if char == \"(\" {\n            open_parens += 1\n        } else\
    \ if char == \")\" {\n            open_parens -= 1\n        }\n        if open_parens\
    \ == 0 {\n            if !buffer.isEmpty {\n                result.append(buffer)\n\
    \                buffer = \"\"\n            }\n        } else {\n            buffer.append(char)\n\
    \        }\n    }\n    return result", "    var arr: [String] = []\n    var stack\
    \ = Stack<Character>()\n    var temp = \"\"\n    for paren in paren_string {\n\
    \        if paren == \" \" {\n            continue\n        }\n        if paren\
    \ == \"(\" {\n            stack.push(paren)\n        } else if paren == \")\"\
    \ {\n            stack.pop()\n            temp += String(paren)\n            if\
    \ stack.isEmpty() {\n                arr.append(temp)\n                temp =\
    \ \"\"\n            }\n        }\n    }\n    return arr", "    var result = [String]()\n\
    \    var input = paren_string\n    while input.count > 0 {\n        let paren\
    \ = extract_paren_group(paren_string: input)\n        input = paren.1\n      \
    \  result.append(paren.0)\n    }\n    return result", "    var parens_arr = paren_string.components(separatedBy:\
    \ .whitespaces)\n    parens_arr = parens_arr.filter { $0 != \"\" }\n    parens_arr\
    \ = parens_arr.map { $0.map { $0 == \" \" ? \"\" : $0 } }\n    parens_arr = parens_arr.map\
    \ { $0.joined() }\n    var opening_paren_dict = [Int: Int]()\n    var closing_paren_dict\
    \ = [Int: Int]()\n    var result = [String]()\n    for (index, each_paren) in\
    \ parens_arr.enumerated() {\n        if each_paren == \"(\" {\n            opening_paren_dict[index]\
    \ = index\n        } else {\n            closing_paren_dict[index] = index\n \
    \       }\n    }\n    var sorted_closing_paren_key = closing_paren_dict.keys.sorted()\n\
    \    var sorted_opening_paren_key = opening_paren_dict.keys.sorted()\n    for\
    \ i in sorted_closing_paren_key {\n        var matched_opening_paren = 0\n   \
    \     for j in sorted_opening_paren_key {\n            if j < i {\n          \
    \      matched_opening_paren = j\n            } else {\n                sorted_opening_paren_key.remove(at:\
    \ sorted_opening_paren_key.firstIndex(of: matched_opening_paren)!)\n         \
    \       result.append(String(parens_arr[matched_opening_paren...i].joined()))\n\
    \                break\n            }\n        }\n    }\n    return result", " \
    \   /// Create a new mutable array\n    var finalArray = [String]()\n    /// Create\
    \ a new string variable\n    var newString = \"\"\n    /// Create a counter\n\
    \    var counter = 0\n    /// Loop through the characters in the string\n    for\
    \ character in paren_string {\n        /// If the character is equal to a \"(\"\
    \ add 1 to the counter\n        if character == \"(\" {\n            counter +=\
    \ 1\n        }\n        /// If the character is equal to a \")\" subtract 1 from\
    \ the counter\n        if character == \")\" {\n            counter -= 1\n   \
    \     }\n        /// Add the character to the new string\n        newString +=\
    \ String(character)\n        /// If the counter is equal to 0\n        if counter\
    \ == 0 {\n            /// Add the new string to the array\n            finalArray.append(newString)\n\
    \            /// Reset the new string\n            newString = \"\"\n        }\n\
    \    }\n    /// Return the final array\n    return finalArray", "    let parens\
    \ = paren_string.replacingOccurrences(of: \" \", with: \"\")\n    let parensArr\
    \ = parens.characters.map{String($0)}\n    var index = 0\n    var results = [String]()\n\
    \    while index < parensArr.count {\n        if parensArr[index] == \"(\" {\n\
    \            var start = index\n            var end = index\n            for paren\
    \ in parensArr[index..<parensArr.count] {\n                if paren == \"(\" {\n\
    \                    end += 1\n                } else if paren == \")\" {\n  \
    \                  end += 1\n                    break\n                }\n  \
    \          }\n            results.append(String(parensArr[start..<end]))\n   \
    \         index = end\n        } else {\n            index += 1\n        }\n \
    \   }\n    return results", "    // TODO: Return an array of strings from the\
    \ input string, separate groups of parentheses\n    var result = [String]()\n\
    \    var temp = \"\"\n    var open = 0\n    var close = 0\n    for i in paren_string\
    \ {\n        if i == \"(\" {\n            open += 1\n        } else if i == \"\
    )\" {\n            close += 1\n        }\n        if open != close && (open -\
    \ close) == 1 {\n            temp += String(i)\n        } else if open == close\
    \ {\n            temp += String(i)\n            result.append(temp)\n        \
    \    temp = \"\"\n            open = 0\n            close = 0\n        }\n   \
    \ }\n    return result", "    // TODO: Write some code to solve this coding challenge\n\
    \    return []", "    var groups: [String] = []\n    var parens_string = paren_string.replacingOccurrences(of:\
    \ \" \", with: \"\")\n    var current_group: String = \"\"\n    var last_index:\
    \ Int = 0\n    for index in 0...parens_string.count - 1 {\n        let current_char\
    \ = parens_string[index]\n        if current_char == \"(\" {\n            last_index\
    \ = index\n            current_group.append(current_char)\n        } else if current_char\
    \ == \")\" {\n            current_group.append(current_char)\n            if current_group.count\
    \ % 2 == 0 {\n                groups.append(current_group)\n                current_group\
    \ = \"\"\n            }\n        }\n    }\n    if current_group != \"\" {\n  \
    \      groups.append(parens_string[last_index...])\n    }\n    return groups",
  "  var n = paren_string.count\n  var result: [String] = []\n  var leftCount = 0\n\
    \  var rightCount = 0\n  var currentString = \"\"\n  for i in 0..<n {\n    let\
    \ c = paren_string[i]\n    if c == \"(\" {\n      leftCount += 1\n    } else if\
    \ c == \")\" {\n      rightCount += 1\n    }\n    if rightCount == leftCount {\n\
    \      result.append(currentString)\n      currentString = \"\"\n      leftCount\
    \ = 0\n      rightCount = 0\n    } else {\n      currentString.append(c)\n   \
    \ }\n  }\n  return result", "    let chars = paren_string.trimmingCharacters(in:\
    \ CharacterSet.whitespacesAndNewlines)\n    var openParens = 0\n    var start\
    \ = 0\n    var stringArray: [String] = []\n    for i in 0..<chars.count {\n  \
    \      let sIndex = chars.index(chars.startIndex, offsetBy: i)\n        if chars[sIndex]\
    \ == \"(\" {\n            openParens += 1\n        } else if chars[sIndex] ==\
    \ \")\" {\n            openParens -= 1\n        }\n        if openParens == 0\
    \ {\n            stringArray.append(String(chars[chars.index(chars.startIndex,\
    \ offsetBy: start)..<chars.index(chars.startIndex, offsetBy: i + 1)]))\n     \
    \       start = i + 1\n        }\n    }\n    return stringArray", "    let parens:\
    \ [Character] = [\"(\", \")\"]\n    let dict = paren_string.filter {parens.contains($0)}\n\
    \    var result: [String] = []\n    var temp = \"\"\n    var unclosed = 0\n  \
    \  for paren in dict {\n        if paren == \"(\" {\n            temp += String(paren)\n\
    \            unclosed += 1\n        } else {\n            unclosed -= 1\n    \
    \        temp += String(paren)\n            if unclosed == 0 {\n             \
    \   result.append(temp)\n                temp = \"\"\n            }\n        }\n\
    \    }\n    return result", '    return paren_string.replacingOccurrences(of:
    " ", with: "").components(separatedBy: ")(")', "    let new_string = paren_string.replacingOccurrences(of:\
    \ \" \", with: \"\")\n    var arr = Array(new_string)\n    var stacks = Stack<Character>()\n\
    \    var final = [String]()\n    var idx = 0\n    var temp = \"\"\n    while idx\
    \ < arr.count {\n        if stacks.size == 0 {\n            if arr[idx] == \"\
    (\" {\n                stacks.push(arr[idx])\n            }\n        } else {\n\
    \            if arr[idx] == \"(\" {\n                stacks.push(arr[idx])\n \
    \           } else {\n                temp += String(stacks.pop())\n         \
    \       temp += String(arr[idx])\n            }\n        }\n        idx += 1\n\
    \    }\n    final.append(temp)\n    return final", '    return []', "    var rtn\
    \ = [String]()\n    var openedParenCount = 0\n    var temp = \"\"\n    for char\
    \ in paren_string {\n        if char == \"(\" {\n            openedParenCount\
    \ += 1\n        } else if char == \")\" {\n            openedParenCount -= 1\n\
    \        }\n        temp.append(char)\n        if openedParenCount == 0 {\n  \
    \          rtn.append(temp)\n            temp = \"\"\n        }\n    }\n    return\
    \ rtn", "    var paren_string = paren_string\n    paren_string = paren_string.replacingOccurrences(of:\
    \ \" \", with: \"\")\n    var groups: [String] = []\n    var open: Int = 0\n \
    \   var closed: Int = 0\n    var group: String = \"\"\n    for char in paren_string\
    \ {\n        if String(char) == \"(\" {\n            open += 1\n        } else\
    \ if String(char) == \")\" {\n            closed += 1\n        }\n        group\
    \ += String(char)\n        if open == closed {\n            groups.append(group)\n\
    \            group = \"\"\n            open = 0\n            closed = 0\n    \
    \    }\n    }\n    return groups", '    return []', "    var stack : [Character]\
    \ = []\n    var current_paren_group : [Character] = []\n    var all_paren_groups\
    \ : [[Character]] = []\n    \n    for c in paren_string {\n        if c == \"\
    (\" {\n            if current_paren_group.count != 0 {\n                all_paren_groups.append(current_paren_group)\n\
    \                current_paren_group = []\n            }\n            stack.append(c)\n\
    \        } else if c == \")\" {\n            stack.removeLast()\n            if\
    \ stack.count == 0 {\n                all_paren_groups.append(current_paren_group)\n\
    \                current_paren_group = []\n            }\n        } else {\n \
    \           current_paren_group.append(c)\n        }\n    }\n    \n    return\
    \ all_paren_groups.map { String($0) }", "    var new_arr: [String] = []\n    var\
    \ cur_str = \"\"\n    var balance = 0\n    for c in paren_string {\n        if\
    \ c == \"(\" {\n            balance += 1\n        } else if c == \")\" {\n   \
    \         balance -= 1\n        }\n        if balance == 0 {\n            if cur_str\
    \ != \"\" {\n                new_arr.append(cur_str)\n                cur_str\
    \ = \"\"\n            }\n        } else {\n            cur_str += String(c)\n\
    \        }\n    }\n    return new_arr", "    var result = [String]()\n    var\
    \ buffer = \"\"\n    var ignore = false\n    for (i, char) in paren_string.enumerated()\
    \ {\n        let idx = paren_string.index(paren_string.startIndex, offsetBy: i)\n\
    \        if char == \" \" {\n            continue\n        }\n        else if\
    \ char == \"(\" {\n            ignore = true\n            buffer.append(char)\n\
    \        }\n        else if char == \")\" {\n            if ignore {\n       \
    \         buffer.append(char)\n            }\n            else {\n           \
    \     buffer.append(char)\n                result.append(buffer)\n           \
    \     buffer = \"\"\n            }\n        }\n        if buffer.count == 2 {\n\
    \            ignore = false\n        }\n    }\n    return result", "    //TODO:\
    \ Solve this!\n    return []", "    var result: [String] = []\n    var stack:\
    \ [Character] = []\n    var temp: [Character] = []\n    for char in paren_string\
    \ {\n        if char == \"(\" {\n            stack.append(char)\n        } else\
    \ if char == \")\" {\n            temp.append(stack.popLast()!)\n            temp.append(char)\n\
    \            if stack.isEmpty {\n                result.append(String(temp))\n\
    \                temp = []\n            }\n        }\n    }\n    return result",
  '    return []', "    var charStack = Stack<Character>()\n    var parenGroups =\
    \ [String]()\n    var parenGroup = \"\"\n    \n    paren_string.forEach { char\
    \ in\n        switch char {\n        case \"(\":\n            charStack.push(char)\n\
    \        case \")\":\n            if let group = charStack.pop() {\n         \
    \       parenGroup.append(group)\n                parenGroup.append(char)\n  \
    \              parenGroups.append(parenGroup)\n                parenGroup = \"\
    \"\n            }\n        default:\n            continue\n        }\n    }\n\
    \    \n    return parenGroups", "    \n    var stack = [Character]()\n    var\
    \ results = [String]()\n    var first = true\n    var temp = \"\"\n    \n    for\
    \ letter in paren_string {\n        if first && letter == \"(\" {\n          \
    \  first = false\n        }\n        if letter == \"(\" {\n            stack.append(letter)\n\
    \        }\n        if letter == \")\" {\n            stack.removeLast()\n   \
    \     }\n        if first && letter != \" \" {\n            temp.append(letter)\n\
    \        }\n        if stack.isEmpty && letter != \" \" {\n            results.append(temp)\n\
    \            temp = \"\"\n            first = true\n        }\n    }\n    return\
    \ results", "    /// - Parameter str: the string to process\n    /// - Returns:\
    \ array of balanced string\n    func separate(str: String) -> [String] {\n   \
    \     var result = [String]()\n        let chars = Array(str)\n        var current\
    \ = String()\n        var count = 0\n        for char in chars {\n           \
    \ if char == \"(\" {\n                current.append(char)\n                count\
    \ += 1\n            } else if char == \")\" {\n                current.append(char)\n\
    \                count -= 1\n                if count == 0 {\n               \
    \     result.append(current)\n                    current = String()\n       \
    \         }\n            }\n        }\n        return result\n    }\n    \n  \
    \  return separate(str: paren_string.replacingOccurrences(of: \" \", with: \"\"\
    ))", "    ////print(\"separate_paren_groups: paren_string: \\(paren_string)\"\
    )\n    var result : [String] = []\n    var current_string = \"\"\n    var open_paren_count\
    \ = 0\n    var close_paren_count = 0\n    var paren_string_array = paren_string.components(separatedBy:\
    \ \" \")\n    for paren in paren_string_array {\n        if (paren == \"(\") {\n\
    \            open_paren_count += 1\n            current_string += paren\n    \
    \    } else if (paren == \")\") {\n            close_paren_count += 1\n      \
    \      current_string += paren\n        }\n        if (open_paren_count == close_paren_count)\
    \ {\n            if (open_paren_count > 0) {\n                ////print(\"separate_paren_groups:\
    \ current_string: \\(current_string)\")\n                result.append(current_string)\n\
    \                current_string = \"\"\n                open_paren_count = 0\n\
    \                close_paren_count = 0\n            }\n        }\n    }\n    return\
    \ result", "    \n    var strings = [String]()\n    var currentString = \"\"\n\
    \    var brackets = [Character]()\n    \n    for index in 0..<paren_string.count\
    \ {\n        let letter = paren_string[paren_string.index(paren_string.startIndex,\
    \ offsetBy: index)]\n        if letter == \"(\" {\n            brackets.append(letter)\n\
    \            currentString.append(letter)\n        } else if letter == \")\" {\n\
    \            if brackets.isEmpty {\n                continue\n            }\n\
    \            if brackets.last == \"(\" {\n                brackets.removeLast()\n\
    \                currentString.append(letter)\n            }\n        }\n    \
    \    if brackets.isEmpty {\n            strings.append(currentString)\n      \
    \      currentString = \"\"\n        }\n    }\n    return strings", "    \n  \
    \  var parenStrings: [String] = []\n    var currentParenString = \"\"\n    var\
    \ leftParenCount = 0\n    var rightParenCount = 0\n    \n    for char in paren_string\
    \ {\n        if char == \"(\" {\n            leftParenCount += 1\n        } else\
    \ if char == \")\" {\n            rightParenCount += 1\n        }\n        \n\
    \        currentParenString.append(char)\n        \n        if leftParenCount\
    \ == rightParenCount {\n            if currentParenString != \" \" {\n       \
    \         parenStrings.append(currentParenString)\n            }\n           \
    \ currentParenString = \"\"\n            leftParenCount = 0\n            rightParenCount\
    \ = 0\n        }\n    }\n    \n    return parenStrings", "    var stack = Stack<String>()\n\
    \    var result = [String]()\n    var currentItem = \"\"\n    var count = 0\n\
    \    var isPart = false\n    var isStart = false\n    for ch in paren_string {\n\
    \        if ch == \"(\" {\n            if !isStart {\n                isStart\
    \ = true\n            }\n            isPart = true\n            count += 1\n \
    \           currentItem.append(ch)\n        } else if ch == \")\" {\n        \
    \    count -= 1\n            currentItem.append(ch)\n            if count == 0\
    \ {\n                isPart = false\n                isStart = false\n       \
    \         result.append(currentItem)\n                currentItem = \"\"\n   \
    \         }\n        } else if isPart {\n            currentItem.append(ch)\n\
    \        }\n    }\n    return result", "    var result = [String]()\n    var current_word\
    \ = \"\"\n    var balance = 0\n    for char in paren_string {\n        guard char\
    \ != \" \" else { continue }\n        if char == \"(\" {\n            balance\
    \ += 1\n        } else if char == \")\" {\n            balance -= 1\n        }\n\
    \        current_word.append(char)\n        if balance == 0 {\n            result.append(current_word)\n\
    \            current_word = \"\"\n        }\n    }\n    return result", "    var\
    \ indices = [Int]()\n    var count = 0\n    var result = [String]()\n    for char\
    \ in paren_string {\n        if char == \"(\" {\n            count += 1\n    \
    \    } else if char == \")\" {\n            count -= 1\n        }\n        if\
    \ count == 0 {\n            indices.append(paren_string.index(after: paren_string.startIndex))\n\
    \        }\n    }\n    indices.append(paren_string.endIndex)\n    for i in 1..<indices.count\
    \ {\n        result.append(String(paren_string[indices[i-1]..<indices[i]]))\n\
    \    }\n    return result", "    let parens = \"()\"\n    let brackets = \"[]\"\
    \n    let braces = \"{}\"\n    let lefts = parens + brackets + braces\n    let\
    \ rights = parens.reverse + brackets.reverse + braces.reverse\n    var stack =\
    \ [Character]()\n    var groups = [String]()\n    var current = \"\"\n    for\
    \ c in paren_string {\n        if c == \" \" {\n            continue\n       \
    \ }\n        if lefts.contains(c) {\n            stack.append(c)\n           \
    \ current.append(c)\n        } else if rights.contains(c) {\n            if stack.last\
    \ == lefts[rights.startIndex.distanceTo(rights.startIndex.advancedBy(rights.characters.indexOf(c)!))]\
    \ {\n                stack.removeLast()\n                current.append(c)\n \
    \           }\n        }\n        if stack.isEmpty {\n            groups.append(current)\n\
    \            current = \"\"\n        }\n    }\n    return groups", "    let expression\
    \ = paren_string.filter { $0 != \" \" }\n    var result = [String]()\n    var\
    \ currentParens = [Character]()\n    var currentResult = [Character]()\n    var\
    \ seenOpening = false\n    var seenClosing = false\n    var previousChar = Character(\"\
    \")\n    var previousSeenOpening = false\n    var previousSeenClosing = false\n\
    \    for char in expression {\n        switch char {\n        case \"(\":\n  \
    \          if !seenOpening {\n                seenOpening = true\n           \
    \     previousSeenOpening = true\n            }\n            if seenClosing &&\
    \ previousSeenOpening {\n                seenClosing = false\n               \
    \ previousSeenOpening = false\n                result.append(String(currentResult))\n\
    \                currentResult = [Character]()\n            }\n            currentParens.append(char)\n\
    \            currentResult.append(char)\n        case \")\":\n            if !seenClosing\
    \ {\n                seenClosing = true\n                previousSeenClosing =\
    \ true\n            }\n            if seenOpening && previousSeenClosing {\n \
    \               seenOpening = false\n                previousSeenClosing = false\n\
    \                result.append(String(currentResult))\n                currentResult\
    \ = [Character]()\n            }\n            if !currentParens.isEmpty {\n  \
    \              currentParens.removeLast()\n            }\n            currentResult.append(char)\n\
    \        default:\n            currentResult.append(char)\n        }\n       \
    \ previousChar = char\n    }\n    if !currentResult.isEmpty {\n        result.append(String(currentResult))\n\
    \    }\n    return result", "    var parens = Array(paren_string.replacingOccurrences(of:\
    \ \" \", with: \"\"))\n    var groups = [String]()\n    var counter = 0\n    var\
    \ start = 0\n    for i in 0..<parens.count {\n        if parens[i] == \"(\" {\n\
    \            counter += 1\n        } else if parens[i] == \")\" {\n          \
    \  counter -= 1\n        }\n        if counter == 0 {\n            groups.append(String(parens[start..<i+1]))\n\
    \            start = i+1\n        }\n    }\n    return groups", "    // return\
    \ value\n    var result : [String] = []\n    \n    // we go through the string\
    \ from beginning to end\n    // we do this by using some kind of index\n    var\
    \ index = paren_string.startIndex\n    \n    // we also keep track of what the\
    \ index of the current parenthesis is\n    var currentParenIndex = 1\n    \n \
    \   // keep track of the current paren group\n    var paren_group = \"\"\n   \
    \ \n    // go through the string\n    while index != paren_string.endIndex {\n\
    \        // get the character at the current index\n        let current_char =\
    \ paren_string[index]\n        \n        // increment the index to get the next\
    \ character\n        index = paren_string.index(after: index)\n        \n    \
    \    // if we've reached the end of the string,\n        // then we'll stop here.\n\
    \        if index == paren_string.endIndex {\n            break\n        }\n \
    \       \n        // check if the current character is a ( or a )\n        if\
    \ current_char == \"(\" {\n            // if it's a ( then we should add it to\
    \ our current paren group\n            paren_group.append(current_char)\n    \
    \        \n            // and increment the current paren index\n            currentParenIndex\
    \ += 1\n        } else if current_char == \")\" {\n            // if it's a )\
    \ then we need to see if our currentParenIndex is 1\n            if currentParenIndex\
    \ == 1 {\n                // if it is then we add the paren group to our result\n\
    \                result.append(paren_group)\n                \n              \
    \  // reset the paren group\n                paren_group = \"\"\n            }\
    \ else {\n                // otherwise it's part of a deeper parenthesis\n   \
    \             // so we add it to the current paren group\n                paren_group.append(current_char)\n\
    \            }\n            \n            // decrement the current paren index\n\
    \            currentParenIndex -= 1\n        }\n    }\n    \n    // if we still\
    \ have a paren group, then add it to the result\n    if paren_group != \"\" {\n\
    \        result.append(paren_group)\n    }\n    \n    return result", "    var\
    \ result = [String]()\n    var tempString = \"\"\n    var tempBracketCount = 0\n\
    \    let charCount = paren_string.count\n    for index in 0..<charCount {\n  \
    \      let ascii = paren_string[paren_string.index(paren_string.startIndex, offsetBy:\
    \ index)].asciiValue\n        if (ascii == 40 || ascii == 41) {\n            tempString.append(paren_string[paren_string.index(paren_string.startIndex,\
    \ offsetBy: index)])\n            if (ascii == 40) {\n                tempBracketCount\
    \ += 1\n            } else {\n                tempBracketCount -= 1\n        \
    \    }\n            if (tempBracketCount == 0) {\n                result.append(tempString)\n\
    \                tempString = \"\"\n            }\n        }\n    }\n    return\
    \ result", "    var paren_string = paren_string\n    var result: [String] = []\n\
    \    var start_index = paren_string.startIndex\n    while paren_string.count >\
    \ 0 {\n        let index = paren_string.firstIndex(of: \"(\")!\n        paren_string.remove(at:\
    \ index)\n        let end_index = paren_string.firstIndex(of: \")\")!\n      \
    \  let sub_str = paren_string[start_index...end_index]\n        result.append(String(sub_str))\n\
    \        paren_string.remove(at: end_index)\n    }\n    return result", "  var\
    \ result: [String] = []\n  var current: String = \"\"\n  var count: Int = 0\n\
    \  for char in paren_string {\n    if char == \"(\" {\n      count += 1\n    }\
    \ else if char == \")\" {\n      count -= 1\n    }\n    if count == 0 {\n    \
    \  if current != \"\" {\n        result.append(current)\n        current = \"\"\
    \n      }\n    } else {\n      current.append(char)\n    }\n  }\n  return result",
  "    var result: [String] = []\n    var temp: String = \"\"\n    var round: Int\
    \ = 0\n    for char in paren_string {\n        if char == \"(\" {\n          \
    \  round += 1\n        } else if char == \")\" {\n            round -= 1\n   \
    \     }\n        if char != \" \" {\n            temp.append(char)\n        }\n\
    \        if round == 0 && char != \" \" {\n            result.append(temp)\n \
    \           temp = \"\"\n        }\n    }\n    return result", "    let paren_string\
    \ = paren_string.replacingOccurrences(of: \" \", with: \"\")\n    var stack: [Character]\
    \ = []\n    var result: [String] = []\n    var idx = 0\n    var balance = 0\n\
    \    var tmp = \"\"\n    for char in paren_string {\n        if char == \"(\"\
    \ {\n            balance += 1\n            stack.append(char)\n        } else\
    \ if char == \")\" {\n            balance -= 1\n            stack.append(char)\n\
    \        }\n        if balance == 0 {\n            result.append(String(stack))\n\
    \            stack.removeAll()\n        }\n    }\n    return result", "    var\
    \ paren_groups = [String]()\n    var current_paren_group = String()\n    var open_count\
    \ = 0\n    var index = 0\n    while index < paren_string.count {\n        let\
    \ current_char = paren_string[paren_string.index(paren_string.startIndex, offsetBy:\
    \ index)]\n        if current_char == \"(\" {\n            open_count += 1\n \
    \           current_paren_group.append(current_char)\n        } else if current_char\
    \ == \")\" {\n            open_count -= 1\n            current_paren_group.append(current_char)\n\
    \        }\n        if open_count == 0 {\n            paren_groups.append(current_paren_group)\n\
    \            current_paren_group = String()\n        }\n        index += 1\n \
    \   }\n    return paren_groups", "    \n    return []", "    var result = [String]()\n\
    \    var start = 0\n    var end = 0\n    var paren_count = 0\n    for i in 0..<paren_string.count\
    \ {\n        let idx = paren_string.index(paren_string.startIndex, offsetBy: i)\n\
    \        let char = paren_string[idx]\n        if char == \"(\" {\n          \
    \  paren_count += 1\n            if paren_count == 1 {\n                start\
    \ = i\n            }\n        } else if char == \")\" {\n            paren_count\
    \ -= 1\n            if paren_count == 0 {\n                end = i\n         \
    \       let start_idx = paren_string.index(paren_string.startIndex, offsetBy:\
    \ start)\n                let end_idx = paren_string.index(paren_string.startIndex,\
    \ offsetBy: end)\n                let str = String(paren_string[start_idx...end_idx])\n\
    \                result.append(str)\n            }\n        }\n    }\n    return\
    \ result", "    var results: [String] = []\n    var workingString = paren_string\n\
    \    var openParenIndex = workingString.findFirst('(')\n    while let index =\
    \ openParenIndex {\n        var count = 1\n        var closeParenIndex = index\
    \ + 1\n        for i in index..<workingString.count {\n            if workingString[i]\
    \ == \"(\" {\n                count += 1\n            } else if workingString[i]\
    \ == \")\" {\n                count -= 1\n            }\n            if count\
    \ == 0 {\n                closeParenIndex = i\n                break\n       \
    \     }\n        }\n        results.append(workingString[index...closeParenIndex])\n\
    \        workingString = workingString[closeParenIndex+1..<workingString.count]\n\
    \        openParenIndex = workingString.findFirst('(')\n    }\n    return results",
  '    return [""]', "    var result_strings: [String] = []\n    var is_open = false\n\
    \    var last_index = 0\n    for i in paren_string.indices {\n        if paren_string[i]\
    \ == \"(\" {\n            if !is_open {\n                last_index = i\n    \
    \        }\n            is_open = true\n        } else if paren_string[i] == \"\
    )\" {\n            is_open = false\n            result_strings.append(String(paren_string[last_index..<i]))\n\
    \        }\n    }\n    return result_strings", "    var open_count = 0\n    var\
    \ close_count = 0\n    var group_count = 0\n    var group_strings = [String]()\n\
    \    var temp_string = \"\"\n    for char in paren_string {\n        if char ==\
    \ \"(\" {\n            open_count += 1\n            group_count += 1\n       \
    \     temp_string += String(char)\n        } else if char == \")\" {\n       \
    \     close_count += 1\n            group_count += 1\n            temp_string\
    \ += String(char)\n        }\n        if group_count == open_count * 2 {\n   \
    \         group_strings.append(temp_string)\n            temp_string = \"\"\n\
    \            group_count = 0\n        }\n    }\n    return group_strings", " \
    \   let cleaned = paren_string.replacingOccurrences(of: \" \", with: \"\")\n \
    \   var output = [String]()\n    var current = [Character]()\n    for item in\
    \ cleaned {\n        if item == \"(\" {\n            current.append(item)\n  \
    \      } else if item == \")\" {\n            current.append(item)\n         \
    \   output.append(String(current))\n            current = [Character]()\n    \
    \    }\n    }\n    return output", "  var paren_groups = [String]()\n  var paren_group\
    \ = \"\"\n  var open_braces = 0\n  for char in paren_string {\n    if char ==\
    \ \"(\" {\n      open_braces += 1\n      paren_group += String(char)\n    } else\
    \ if char == \")\" {\n      if open_braces > 0 {\n        open_braces -= 1\n \
    \       paren_group += String(char)\n      }\n      if open_braces == 0 {\n  \
    \      paren_groups.append(paren_group)\n        paren_group = \"\"\n      }\n\
    \    }\n  }\n  return paren_groups", "    var output = [String]()\n    var current_string\
    \ = \"\"\n    var counter = 0\n    for character in paren_string {\n        if\
    \ character == \"(\" {\n            counter += 1\n        } else if character\
    \ == \")\" {\n            counter -= 1\n        }\n        if counter == 0 {\n\
    \            current_string += String(character)\n            output.append(current_string)\n\
    \            current_string = \"\"\n        } else {\n            current_string\
    \ += String(character)\n        }\n    }\n    return output", "    \n    let charArray\
    \ = paren_string.map { String($0) }\n    var temp = \"\"\n    var result = [String]()\n\
    \    \n    for char in charArray {\n        if char == \"(\" {\n            temp\
    \ += char\n        } else if char == \")\" {\n            temp += char\n     \
    \       result.append(temp)\n            temp = \"\"\n        }\n    }\n    \n\
    \    return result", "    var i = 0\n    var results = [String]()\n    var current\
    \ = \"\"\n    while i < paren_string.count {\n        if paren_string[i] == \"\
    (\" {\n            current += \"(\"\n        } else if paren_string[i] == \")\"\
    \ {\n            current += \")\"\n            results.append(current)\n     \
    \       current = \"\"\n        }\n        i += 1\n    }\n    return results",
  "    if paren_string.isEmpty {\n        return []\n    }\n    \n    var index =\
    \ 0\n    var result: [String] = []\n    var bracketsCount = 0\n    while index\
    \ < paren_string.count {\n        let char = paren_string[paren_string.index(paren_string.startIndex,\
    \ offsetBy: index)]\n        let begin = paren_string.index(paren_string.startIndex,\
    \ offsetBy: index)\n        let end = paren_string.index(paren_string.startIndex,\
    \ offsetBy: index + 1)\n        let range = begin..<end\n        let substring\
    \ = paren_string[range]\n        if substring == \"(\" {\n            bracketsCount\
    \ += 1\n        } else if substring == \")\" {\n            bracketsCount -= 1\n\
    \        }\n        if char == \" \" {\n            index += 1\n            continue\n\
    \        }\n        if bracketsCount == 0 {\n            let charIndex = paren_string.index(paren_string.startIndex,\
    \ offsetBy: index + 1)\n            result.append(String(paren_string[paren_string.startIndex..<charIndex]))\n\
    \            index += 1\n        } else {\n            index += 1\n        }\n\
    \    }\n    return result", "    var strings = [String]()\n    var next_string\
    \ = \"\"\n    var nesting_level = 0\n    for c in paren_string {\n        if c\
    \ == \" \" {\n            continue\n        }\n        if c == \"(\" {\n     \
    \       nesting_level += 1\n        }\n        next_string.append(c)\n       \
    \ if c == \")\" {\n            nesting_level -= 1\n            if nesting_level\
    \ == 0 {\n                strings.append(next_string)\n                next_string\
    \ = \"\"\n            }\n        }\n    }\n    return strings", "    var result\
    \ = [String]()\n    var temp = \"\"\n    var open = 0\n    var close = 0\n   \
    \ for char in paren_string {\n        if char == \"(\" {\n            open +=\
    \ 1\n        } else if char == \")\" {\n            close += 1\n        }\n  \
    \      if char != \" \" {\n            temp.append(char)\n        }\n        if\
    \ open == close {\n            result.append(temp)\n            temp = \"\"\n\
    \            open = 0\n            close = 0\n        }\n    }\n    return result",
  "    var result: [String] = []\n    var group: String = \"\"\n    var braces: String\
    \ = \"\"\n    var open: Int = 0\n    var close: Int = 0\n    var last_closed:\
    \ Int = 0\n    var last_opened: Int = 0\n    var i: Int = 0\n    while i < paren_string.count\
    \ {\n        let next_char = paren_string[paren_string.index(paren_string.startIndex,\
    \ offsetBy: i)]\n        if next_char == \"(\" {\n            braces += next_char\n\
    \            open += 1\n            last_opened = i\n        } else if next_char\
    \ == \")\" {\n            braces += next_char\n            close += 1\n      \
    \      last_closed = i\n        }\n        if open == close {\n            if\
    \ !braces.isEmpty {\n                result.append(braces)\n                braces\
    \ = \"\"\n                open = 0\n                close = 0\n              \
    \  group = \"\"\n            }\n        }\n        i += 1\n    }\n    return result",
  '    return [""]', "    var array_string = [String]()\n    var current_paren_string\
    \ = \"\"\n    var open_paren_counter = 0\n    var close_paren_counter = 0\n  \
    \  for char in paren_string {\n        if char == \"(\" {\n            current_paren_string\
    \ += String(char)\n            open_paren_counter += 1\n        } else if char\
    \ == \")\" {\n            current_paren_string += String(char)\n            close_paren_counter\
    \ += 1\n        }\n        if open_paren_counter > 0 && open_paren_counter ==\
    \ close_paren_counter {\n            array_string.append(current_paren_string)\n\
    \            current_paren_string = \"\"\n            open_paren_counter = 0\n\
    \            close_paren_counter = 0\n        }\n    }\n    return array_string",
  "    // your code here\n    let paren_string = paren_string.replacingOccurrences(of:\
    \ \" \", with: \"\")\n    var result = [String]()\n    var startIdx = 0\n    for\
    \ (idx, paren) in paren_string.enumerated() {\n        if paren == \"(\" {\n \
    \           startIdx = idx\n        } else if paren == \")\" {\n            result.append(paren_string[paren_string.index(paren_string.startIndex,\
    \ offsetBy: startIdx)...paren_string.index(paren_string.startIndex, offsetBy:\
    \ idx)])\n        }\n    }\n    return result", "    var stack = Stack<String>()\n\
    \    var output = [String]()\n    for character in paren_string {\n        if\
    \ character == \"(\" {\n            stack.push(String(character))\n        } else\
    \ if character == \")\" {\n            var current = stack.pop()!\n          \
    \  current.append(String(character))\n            stack.push(current)\n      \
    \  }\n    }\n    while !stack.isEmpty() {\n        output.append(stack.pop()!)\n\
    \    }\n    return output", "    var result: [String] = []\n    let parens = paren_string.filter{$0\
    \ != \" \"}\n    var stack = Stack<Character>()\n    var string = \"\"\n    for\
    \ paren in parens {\n        string.append(paren)\n        if paren == \"(\" {\n\
    \            stack.push(paren)\n        } else {\n            guard stack.pop()\
    \ != nil else { return [] }\n            if stack.isEmpty {\n                result.append(string)\n\
    \                string = \"\"\n            }\n        }\n    }\n    return result",
  '    return []', "    var parenGroups = [String]()\n    var currentParenGroup =\
    \ String()\n    var openParenCount = 0\n    for char in paren_string {\n     \
    \   if char == \"(\" {\n            openParenCount += 1\n            currentParenGroup.append(char)\n\
    \        } else if char == \")\" {\n            openParenCount -= 1\n        \
    \    currentParenGroup.append(char)\n            if openParenCount == 0 {\n  \
    \              parenGroups.append(currentParenGroup)\n                currentParenGroup\
    \ = String()\n            }\n        }\n    }\n    return parenGroups", "    var\
    \ result = [String]()\n    var current_string = \"\"\n    var paren_counter =\
    \ 0\n    for char in paren_string {\n        if char == \"(\" {\n            paren_counter\
    \ += 1\n        } else if char == \")\" {\n            paren_counter -= 1\n  \
    \      }\n        if paren_counter == 0 {\n            if !current_string.isEmpty\
    \ {\n                result.append(current_string)\n                current_string\
    \ = \"\"\n            }\n        } else {\n            current_string.append(char)\n\
    \        }\n    }\n    return result", "    let parenArr = paren_string.components(separatedBy:\
    \ \" \")\n    var result = [String]()\n    var tempResult = \"\"\n    var count\
    \ = 0\n    for i in 0...parenArr.count - 1 {\n        if parenArr[i] == \"(\"\
    \ {\n            tempResult += parenArr[i]\n            count += 1\n        }\
    \ else if parenArr[i] == \")\" {\n            tempResult += parenArr[i]\n    \
    \        count -= 1\n            if count == 0 {\n                result.append(tempResult)\n\
    \                tempResult = \"\"\n            }\n        }\n    }\n    return\
    \ result", "    let clean = paren_string.replacingOccurrences(of: \" \", with:\
    \ \"\")\n    var stack = Array<Character>()\n    var groups = Array<String>()\n\
    \    var start = 0\n    for (i, char) in clean.enumerated() {\n        if char\
    \ == \"(\" {\n            stack.append(char)\n        } else if char == \")\"\
    \ {\n            stack.removeLast()\n            if stack.isEmpty {\n        \
    \        groups.append(String(clean[clean.index(clean.startIndex, offsetBy: start)..<clean.index(clean.startIndex,\
    \ offsetBy: i+1)]))\n                start = i+1\n            }\n        }\n \
    \   }\n    return groups", "    var stack: [Character] = []\n    var current:\
    \ [Character] = []\n    var groups: [[Character]] = []\n    var string = paren_string\n\
    \    string.removeAll { $0 == \" \" }\n    for c in string {\n        if c ==\
    \ \"(\" {\n            stack.append(c)\n        } else if c == \")\" {\n     \
    \       stack.removeLast()\n            current.append(c)\n            if stack.isEmpty\
    \ {\n                groups.append(current)\n                current = []\n  \
    \          }\n        }\n    }\n    return groups.map { String($0) }", "    if\
    \ paren_string.isEmpty {\n        return []\n    }\n    \n    var stack = [Character]()\n\
    \    var result = [String]()\n    var current = \"\"\n    \n    for char in paren_string\
    \ {\n        if char == \"(\" {\n            stack.append(char)\n        } else\
    \ if char == \")\" {\n            if stack.isEmpty {\n                return []\n\
    \            }\n            stack.removeLast()\n        }\n        \n        current.append(char)\n\
    \        \n        if stack.isEmpty {\n            result.append(current)\n  \
    \          current = \"\"\n        }\n    }\n    \n    return result", "    //\
    \ Your solution here\n    return []", "    var output: [String] = []\n    var\
    \ buffer: String = \"\"\n    var balance: Int = 0\n    for char in paren_string\
    \ {\n        buffer.append(char)\n        if char == \"(\" {\n            balance\
    \ += 1\n        } else if char == \")\" {\n            balance -= 1\n        }\n\
    \        if balance == 0 {\n            output.append(buffer)\n            buffer\
    \ = \"\"\n        }\n    }\n    return output", "    let parens = paren_string.filter\
    \ { $0 != \" \" }\n    var result: [String] = []\n    var temp = \"\"\n    var\
    \ open = 0\n    for paren in parens {\n        if paren == \"(\" {\n         \
    \   open += 1\n        } else {\n            open -= 1\n        }\n        temp.append(paren)\n\
    \        if open == 0 {\n            result.append(temp)\n            temp = \"\
    \"\n        }\n    }\n    return result", "    var parens = [String]()\n    var\
    \ temp = \"\"\n    var num = 0\n    for c in paren_string {\n        if c == \"\
    (\" {\n            temp.append(c)\n            num += 1\n        } else if c ==\
    \ \")\" {\n            temp.append(c)\n            num -= 1\n            if num\
    \ == 0 {\n                parens.append(temp)\n                temp = \"\"\n \
    \           }\n        }\n    }\n    return parens", "    // FIXME: Implement\n\
    \    return []", "    var unclosed_open_parens = 0\n    var groups = [String]()\n\
    \    var accumulated_group = \"\"\n    for character in paren_string {\n     \
    \   if (character == \"(\") {\n            unclosed_open_parens += 1\n       \
    \     accumulated_group += \"(\"\n        } else if (character == \")\") {\n \
    \           unclosed_open_parens -= 1\n            accumulated_group += \")\"\n\
    \        }\n        if (unclosed_open_parens == 0) {\n            groups.append(accumulated_group)\n\
    \            accumulated_group = \"\"\n        }\n    }\n    return groups", " \
    \   var idx = 0\n    var new_group = \"\"\n    var result = [String]()\n    for\
    \ char in paren_string {\n        if char == \"(\" {\n            idx += 1\n \
    \       } else if char == \")\" {\n            idx -= 1\n        }\n        new_group.append(char)\n\
    \        if idx == 0 {\n            result.append(new_group)\n            new_group\
    \ = \"\"\n        }\n    }\n    return result", "  var result: [String] = []\n\
    \  var temp = \"\"\n  var stack: [Character] = []\n  let input = paren_string.components(separatedBy:\
    \ CharacterSet.whitespaces).joined()\n  for i in input {\n    if i == \"(\" {\n\
    \      stack.append(i)\n    } else if i == \")\" {\n      if stack.count > 0 {\n\
    \        temp += String(stack.popLast()!)\n        temp += String(i)\n      }\n\
    \      if stack.count == 0 {\n        result.append(temp)\n        temp = \"\"\
    \n      }\n    }\n  }\n  return result", "    var paren_groups = [String]()\n\
    \    var current_paren_group = \"\"\n    var depth = 0\n    for character in paren_string\
    \ {\n        if character == \"(\" {\n            depth += 1\n            current_paren_group\
    \ += String(character)\n        } else if character == \")\" {\n            depth\
    \ -= 1\n            current_paren_group += String(character)\n            if depth\
    \ == 0 {\n                paren_groups.append(current_paren_group)\n         \
    \       current_paren_group = \"\"\n            }\n        }\n    }\n    return\
    \ paren_groups", "    var result = [String]()\n    var counter = 0\n    var current_group\
    \ = \"\"\n    for char in paren_string {\n        if char == \"(\" {\n       \
    \     counter += 1\n        } else if char == \")\" {\n            counter -=\
    \ 1\n        }\n        if counter == 0 {\n            result.append(current_group)\n\
    \            current_group = \"\"\n        } else {\n            current_group.append(char)\n\
    \        }\n    }\n    return result", "  var result: [String] = []\n  var temp\
    \ = \"\"\n  var count = 0\n  for char in paren_string {\n    if char == \"(\"\
    \ {\n      temp += \"(\"\n      count += 1\n    } else if char == \")\" {\n  \
    \    temp += \")\"\n      count -= 1\n      if count == 0 {\n        result.append(temp)\n\
    \        temp = \"\"\n      }\n    }\n  }\n  return result", "    \n    // Your\
    \ code here\n    return []", "    // separate into groups that can be passed to\
    \ the `is_balanced` function\n    var separate_groups = [String]()\n    var current_group\
    \ = \"\"\n    var open_parens = 0\n    var close_parens = 0\n    for character\
    \ in paren_string {\n        if character == \"(\" {\n            open_parens\
    \ += 1\n        } else if character == \")\" {\n            close_parens += 1\n\
    \        }\n        current_group.append(character)\n        if open_parens ==\
    \ close_parens {\n            separate_groups.append(current_group)\n        \
    \    current_group = \"\"\n            open_parens = 0\n            close_parens\
    \ = 0\n        }\n    }\n    var result = [String]()\n    for group in separate_groups\
    \ {\n        if is_balanced(group) {\n            result.append(group)\n     \
    \   }\n    }\n    return result", "    // Solution here\n    var result: [String]\
    \ = []\n    let input: String = paren_string.replacingOccurrences(of: \" \", with:\
    \ \"\")\n    var openParens: Int = 0\n    var closeParens: Int = 0\n    var temp:\
    \ String = \"\"\n    var stack: [Character] = []\n    for character in input {\n\
    \        if character == \"(\" {\n            openParens += 1\n            stack.append(character)\n\
    \        } else if character == \")\" {\n            closeParens += 1\n      \
    \      stack.append(character)\n        }\n        if closeParens > openParens\
    \ {\n            return []\n        }\n        if closeParens == openParens {\n\
    \            temp = \"\"\n            while stack.count > 0 {\n              \
    \  temp += String(stack.popLast()!)\n            }\n            result.append(temp)\n\
    \            openParens = 0\n            closeParens = 0\n        }\n    }\n \
    \   return result", '  return ["()", "(())", "(()())"]', "    \n    var stringArray\
    \ = [String]()\n    var balance = 0\n    var index = 0\n    var start = 0\n  \
    \  var end = 0\n    \n    for character in paren_string {\n        switch character\
    \ {\n        case \"(\":\n            balance += 1\n        case \")\":\n    \
    \        balance -= 1\n        default:\n            break\n        }\n      \
    \  \n        if balance == 0 {\n            end = index\n            stringArray.append(paren_string[paren_string.index(paren_string.startIndex,\
    \ offsetBy: start)...paren_string.index(paren_string.startIndex, offsetBy: end)])\n\
    \            start = index + 1\n        }\n        \n        index += 1\n    }\n\
    \    \n    return stringArray", "    var newParenString = \"\"\n    var outputArray\
    \ = [String]()\n    var parenNumber = 0\n    var parenLevel = 0\n    var startIndex\
    \ = 0\n    var prevCount = 0\n    var i = 0\n    var charArray = Array(paren_string)\n\
    \    while i < charArray.count {\n        let character = charArray[i]\n     \
    \   if character == \"(\" {\n            parenNumber += 1\n            parenLevel\
    \ += 1\n            if parenLevel == 1 {\n                startIndex = i\n   \
    \         }\n        } else if character == \")\" {\n            parenNumber -=\
    \ 1\n            parenLevel -= 1\n            if parenLevel == 0 {\n         \
    \       outputArray.append(String(charArray[startIndex...i]))\n            }\n\
    \        }\n        i += 1\n    }\n    return outputArray", "    var paren_list:\
    \ [String] = []\n    var paren_buffer: String = \"\"\n    var open: Int = 0\n\
    \    var close: Int = 0\n    var i: Int = 0\n    for paren in paren_string {\n\
    \        if paren == \"(\" {\n            open += 1\n        } else if paren ==\
    \ \")\" {\n            close += 1\n        }\n        paren_buffer.append(paren)\n\
    \        if open == close {\n            paren_list.append(paren_buffer)\n   \
    \         paren_buffer = \"\"\n            open = 0\n            close = 0\n \
    \       }\n        i += 1\n    }\n    return paren_list", "    guard paren_string.count\
    \ > 0 else { return [String]() }\n    var parens = [String]()\n    var working_parens\
    \ = [String]()\n    var open_parens = 0\n    var start_index = 0\n    for (index,\
    \ paren) in paren_string.enumerated() {\n        if paren == \"(\" {\n       \
    \     if open_parens == 0 {\n                start_index = index\n           \
    \ }\n            open_parens += 1\n        } else if paren == \")\" {\n      \
    \      open_parens -= 1\n            if open_parens == 0 {\n                parens.append(paren_string[paren_string.index(paren_string.startIndex,\
    \ offsetBy: start_index)..<paren_string.index(paren_string.startIndex, offsetBy:\
    \ index + 1)])\n            }\n        }\n    }\n    return parens", "    \n \
    \   var results = [String]()\n    var temp = \"\"\n    var count = 0\n    \n \
    \   for i in paren_string {\n        if i == \"(\" {\n            count += 1\n\
    \        } else if i == \")\" {\n            count -= 1\n        }\n        \n\
    \        if count == 0 {\n            results.append(temp)\n            temp =\
    \ \"\"\n        } else {\n            temp.append(i)\n        }\n    }\n    \n\
    \    return results", "    var new_paren_strings: [String] = []\n    var current_paren_string\
    \ = \"\"\n    var open_paren_count = 0\n    var closed_paren_count = 0\n    for\
    \ character in paren_string {\n        if character == \"(\" {\n            open_paren_count\
    \ += 1\n        } else if character == \")\" {\n            closed_paren_count\
    \ += 1\n        }\n        if open_paren_count == closed_paren_count {\n     \
    \       new_paren_strings.append(current_paren_string)\n            current_paren_string\
    \ = \"\"\n            open_paren_count = 0\n            closed_paren_count = 0\n\
    \        } else {\n            current_paren_string.append(character)\n      \
    \  }\n    }\n    return new_paren_strings", "    let characters = paren_string.characters\n\
    \    var parenArray: [String] = []\n    var tempString: String = \"\"\n    var\
    \ counter: Int = 0\n    for c in characters {\n        if c == \"(\" {\n     \
    \       tempString.append(c)\n            counter += 1\n        } else if c ==\
    \ \")\" {\n            tempString.append(c)\n            counter -= 1\n      \
    \      if counter == 0 {\n                parenArray.append(tempString)\n    \
    \            tempString = \"\"\n            }\n        }\n    }\n    return parenArray",
  "    let chars = Array(paren_string)\n    var result = [String]()\n    var count\
    \ = 0\n    var index = 0\n    for char in chars {\n        if char == \"(\" {\n\
    \            count += 1\n        } else if char == \")\" {\n            count\
    \ -= 1\n        }\n        if count == 0 {\n            result.append(String(chars[0..<index\
    \ + 1]))\n            chars.removeSubrange(0..<index + 1)\n            index =\
    \ 0\n        } else {\n            index += 1\n        }\n    }\n    return result",
  "    var open = 0\n    var close = 0\n    var new_string = \"\"\n    var array =\
    \ [String]()\n    for c in paren_string {\n        if c == \"(\" {\n         \
    \   open += 1\n        } else if c == \")\" {\n            close += 1\n      \
    \  }\n        if open != 0 && close != 0 && open == close {\n            array.append(new_string)\n\
    \            new_string = \"\"\n            open = 0\n            close = 0\n\
    \        } else {\n            new_string += String(c)\n        }\n    }\n   \
    \ return array", "    var input = paren_string\n    var output: [String] = []\n\
    \    var temp: String = \"\"\n    while input.characters.count > 0 {\n       \
    \ let index = input.characters.index(input.startIndex, offsetBy: 1)\n        temp\
    \ += String(input.characters.prefix(upTo: index))\n        input = String(input.characters.suffix(from:\
    \ index))\n        if temp.characters.last == \")\" {\n            output.append(temp)\n\
    \            temp = \"\"\n        }\n    }\n    return output", "    var newArray\
    \ = [String]()\n    var stack = Stack<Character>()\n    var newString = \"\"\n\
    \    let parenArray = Array(paren_string)\n    for paren in parenArray {\n   \
    \     if paren == \" \" {\n            continue\n        }\n        else if paren\
    \ == \"(\" {\n            stack.push(paren)\n        }\n        else if paren\
    \ == \")\" {\n            stack.pop()\n            if stack.isEmpty() {\n    \
    \            newArray.append(newString)\n                newString = \"\"\n  \
    \          }\n            else {\n                newString += \")\"\n       \
    \     }\n        }\n        else {\n            newString += \"(\"\n        }\n\
    \    }\n    return newArray", "    var result: [String] = []\n    var curr_paren_string\
    \ = \"\"\n    var open_paren_count = 0\n    var close_paren_count = 0\n    for\
    \ char in paren_string {\n        if char == \"(\" {\n            open_paren_count\
    \ += 1\n        } else if char == \")\" {\n            close_paren_count += 1\n\
    \        }\n        if open_paren_count == close_paren_count {\n            if\
    \ open_paren_count != 0 {\n                result.append(curr_paren_string)\n\
    \                curr_paren_string = \"\"\n                open_paren_count =\
    \ 0\n                close_paren_count = 0\n            }\n        } else {\n\
    \            curr_paren_string.append(char)\n        }\n    }\n    return result",
  "    /// Result is not the same for this solution than for the one in haskell.\n\
    \    /// The one in haskell does not include the opening and closing parenthesis\
    \ when returning the result\n    var result: [String] = []\n    var opened: Int\
    \ = 0\n    var start: Int = 0\n    var end: Int = 0\n    for (index, char) in\
    \ paren_string.enumerated() {\n        if char == \"(\" {\n            if opened\
    \ == 0 {\n                start = index\n            }\n            opened +=\
    \ 1\n        } else if char == \")\" {\n            opened -= 1\n            if\
    \ opened == 0 {\n                end = index\n                result.append(paren_string[start...end])\n\
    \            }\n        }\n    }\n    return result", "    var results: [String]\
    \ = []\n    var last_index = paren_string.startIndex\n    for (index, char) in\
    \ paren_string.enumerated() {\n        if char == \")\" {\n            var current_string\
    \ = \"\"\n            for char in paren_string[last_index..<paren_string.index(paren_string.startIndex,\
    \ offsetBy: index)] {\n                if char != \" \" {\n                  \
    \  current_string.append(char)\n                }\n            }\n           \
    \ results.append(current_string)\n            last_index = paren_string.index(paren_string.startIndex,\
    \ offsetBy: index + 1)\n        }\n    }\n    return results", "  // the algorithm\
    \ is to scan from left to right, \n  // - capture all the opening parentheses\n\
    \  // - when closing is encountered, match with previous opening\n  // - repeat\
    \ the above step till there are no unmatched closing parentheses\n  // - finally,\
    \ add the unmatched open parentheses to the end of the string\n  var matchedParens\
    \ = [String]()\n  var remainingParens = paren_string\n  var matched = \"\"\n \
    \ while !remainingParens.isEmpty {\n    let indexOfClose = remainingParens.firstIndex(of:\
    \ \")\")\n    if let index = indexOfClose {\n      matched += String(remainingParens[..<index])\n\
    \      matchedParens.append(matched)\n      matched = \"\"\n      remainingParens\
    \ = String(remainingParens[index...])\n    } else {\n      // we hit the end.\
    \ There are unmatched closing parentheses\n      matched += remainingParens\n\
    \      remainingParens = \"\"\n    }\n  }\n  if !matched.isEmpty {\n    matchedParens.append(matched)\n\
    \  }\n  return matchedParens", '    return []', "    var result = [String]()\n\
    \    var start_of_paren_group = 0\n    var stack = Stack<Character>()\n    var\
    \ i = 0\n    while i < paren_string.count {\n        let next_char = paren_string[paren_string.index(paren_string.startIndex,\
    \ offsetBy: i)]\n        if next_char == \"(\" {\n            stack.push(next_char)\n\
    \        } else if next_char == \")\" {\n            stack.pop()\n        }\n\
    \        i += 1\n        if stack.isEmpty() {\n            result.append(paren_string[paren_string.index(paren_string.startIndex,\
    \ offsetBy: start_of_paren_group)..<paren_string.index(paren_string.startIndex,\
    \ offsetBy: i)].trimmingCharacters(in: .whitespaces))\n            start_of_paren_group\
    \ = i\n        }\n    }\n    return result", "    guard paren_string.count > 0\
    \ else {\n        return [String]()\n    }\n    \n    var result = [String]()\n\
    \    var current_paren_group = \"\"\n    var open_paren_count = 0\n    for char\
    \ in paren_string {\n        if char == \"(\" {\n            open_paren_count\
    \ += 1\n            current_paren_group.append(char)\n        } else if char ==\
    \ \")\" {\n            if open_paren_count > 0 {\n                open_paren_count\
    \ -= 1\n                current_paren_group.append(char)\n            }\n    \
    \    }\n        \n        if open_paren_count == 0 && current_paren_group.count\
    \ > 0 {\n            result.append(current_paren_group)\n            current_paren_group\
    \ = \"\"\n        }\n    }\n    \n    return result", "    let tokens = paren_string.split(separator:\
    \ \" \")\n    var result: [String] = []\n    var temp = \"\"\n    for token in\
    \ tokens {\n        if token == \"(\" {\n            temp += token\n        }\
    \ else if token == \")\" {\n            temp += token\n            result.append(temp)\n\
    \            temp = \"\"\n        }\n    }\n    return result", "    \n    var\
    \ result = [String]()\n    var countOpen = 0\n    var countClose = 0\n    var\
    \ temp = \"\"\n    \n    for i in paren_string {\n        if i == \"(\" {\n  \
    \          countOpen += 1\n        } else if i == \")\" {\n            countClose\
    \ += 1\n        }\n        temp.append(i)\n        if countOpen == countClose\
    \ {\n            result.append(temp)\n            temp = \"\"\n            countOpen\
    \ = 0\n            countClose = 0\n        }\n    }\n    return result", "   \
    \ var stack = Stack<Character>()\n    var start_index = 0\n    var end_index =\
    \ 0\n    var substrings = [String]()\n    for (index, c) in paren_string.enumerated()\
    \ {\n        if c == \"(\" {\n            stack.push(c)\n            if stack.count\
    \ == 1 {\n                start_index = index\n            }\n        } else if\
    \ c == \")\" {\n            if stack.count == 1 {\n                end_index =\
    \ index\n                if let str = paren_string.substring(start_index, end_index\
    \ + 1) {\n                    substrings.append(str)\n                }\n    \
    \        }\n            stack.pop()\n        }\n    }\n    return substrings",
  "  var result: [String] = []\n  var temp = \"\"\n  var counter = 0\n  var last =\
    \ 0\n  let (parens, _) = find_unmatched_paren(paren_string)\n  let paren_array\
    \ = Array(paren_string)\n  if parens.isEmpty {\n    return [paren_string]\n  }\n\
    \  for (index, paren) in paren_array.enumerated() {\n    if paren == \"(\" {\n\
    \      counter += 1\n    } else if paren == \")\" {\n      counter -= 1\n    }\n\
    \    if counter == 0 {\n      if index == last {\n        result.append(String(paren_array[index]))\n\
    \      } else {\n        result.append(String(paren_array[last...index]))\n  \
    \    }\n      last = index + 1\n    }\n  }\n  return result", "    var parens\
    \ = Stack<Character>()\n    var parenGroups = [String]()\n    var index = 0\n\
    \    var start = 0\n    var parenString = paren_string.filter { $0 != \" \" }\n\
    \    while index < parenString.count {\n        let char = parenString[parenString.index(parenString.startIndex,\
    \ offsetBy: index)]\n        if char == \"(\" {\n            parens.push(element:\
    \ char)\n        } else if char == \")\" {\n            _ = parens.pop()\n   \
    \         if parens.isEmpty() {\n                parenGroups.append(String(parenString[parenString.index(parenString.startIndex,\
    \ offsetBy: start)..<parenString.index(parenString.startIndex, offsetBy: index+1)]))\n\
    \                start = index + 1\n            }\n        }\n        index +=\
    \ 1\n    }\n    return parenGroups", "    // Write your solution here\n    \n\
    \    // a stack to keep track of the open parens\n    var stack = Stack<Character>()\n\
    \    \n    // a stack to keep track of the beginning and the end of paren strings\n\
    \    var result = Stack<String>()\n    \n    // iterate through every element\
    \ of paren_string\n    for char in paren_string {\n        // if stack is empty\
    \ or the last char from stack != ( or char != ( or ) ignore this character\n \
    \       guard stack.peek() != nil || char != \"(\" || char != \")\" else {\n \
    \           continue\n        }\n        \n        // if stack is not empty and\
    \ the last char from stack == ( then char == )\n        if stack.peek() == \"\
    (\" {\n            // append ( to the last string on the result stack\n      \
    \      let string = result.pop()!\n            result.push(string + \"(\")\n \
    \           \n            // append ) to the last string on the result stack\n\
    \            let string_ = result.pop()!\n            result.push(string_ + \"\
    )\")\n            \n            // pop from stack the first (\n            stack.pop()\n\
    \        } else {\n            // stack is empty and char == ( then append char\
    \ to the last string on the result stack\n            if stack.peek() == nil {\n\
    \                // append ( to the last string on the result stack\n        \
    \        let string = result.pop()!\n                result.push(string + \"(\"\
    )\n            }\n            // push char on the stack\n            stack.push(char)\n\
    \        }\n    }\n    \n    return result.array", "    var res = [String]()\n\
    \    var stack = [Character]()\n    var start = 0\n    var end = 0\n    var str\
    \ = paren_string\n    str.removeAll { (c) -> Bool in\n        c == \" \"\n   \
    \ }\n    for i in 0..<str.count {\n        let c = str[str.index(str.startIndex,\
    \ offsetBy: i)]\n        if c == \"(\" {\n            stack.append(c)\n      \
    \      if stack.count == 1 {\n                start = i\n            }\n     \
    \   } else {\n            _ = stack.popLast()\n            if stack.count == 0\
    \ {\n                end = i\n                res.append(String(str[str.index(str.startIndex,\
    \ offsetBy: start)..<str.index(str.startIndex, offsetBy: end+1)]))\n         \
    \   }\n        }\n    }\n    return res", "    var parenGroups: [String] = []\n\
    \    var currentGroup: String = \"\"\n    var isGroupOpen: Bool = false\n    for\
    \ char in paren_string {\n        if (char == \"(\") {\n            if (!isGroupOpen)\
    \ {\n                currentGroup = \"(\"\n                isGroupOpen = true\n\
    \            } else {\n                currentGroup.append(char)\n           \
    \ }\n        } else if (char == \")\") {\n            if (isGroupOpen) {\n   \
    \             currentGroup.append(char)\n                parenGroups.append(currentGroup)\n\
    \                isGroupOpen = false\n            }\n        }\n    }\n    return\
    \ parenGroups", "    var stack = Stack<Character>()\n    var result = [String]()\n\
    \    var temp = \"\"\n    for char in paren_string {\n        if char == \" \"\
    \ {\n            continue\n        }\n        if char == \"(\" {\n           \
    \ stack.push(element: char)\n        } else if char == \")\" {\n            stack.pop()\n\
    \            if stack.isEmpty() {\n                result.append(temp)\n     \
    \           temp = \"\"\n            }\n        }\n        temp.append(char)\n\
    \    }\n    return result", "    var balanced_paren_groups: [String] = []\n  \
    \  var balanced_string = \"\"\n    var current_paren_count = 0\n    var skip_next_char\
    \ = false\n    \n    for char in paren_string {\n        if skip_next_char {\n\
    \            skip_next_char = false\n            continue\n        }\n       \
    \ \n        if char == \" \" {\n            skip_next_char = true\n          \
    \  continue\n        }\n        \n        if char == \"(\" {\n            current_paren_count\
    \ += 1\n        } else if char == \")\" {\n            current_paren_count -=\
    \ 1\n        }\n        \n        balanced_string.append(char)\n        \n   \
    \     if current_paren_count == 0 {\n            balanced_paren_groups.append(balanced_string)\n\
    \            balanced_string = \"\"\n        }\n    }\n    \n    return balanced_paren_groups",
  "    // your code here\n    return [\"\"]", "    var paren_stack: [Character] =\
    \ []\n    var paren_groups: [String] = []\n    var current_paren_group: String\
    \ = \"\"\n    \n    for char in paren_string {\n        if (char == \"(\") {\n\
    \            paren_stack.append(char)\n        } else if (char == \")\") {\n \
    \           paren_stack.removeLast()\n            if (paren_stack.count == 0)\
    \ {\n                paren_groups.append(current_paren_group)\n              \
    \  current_paren_group = \"\"\n            }\n        } else if (char != \" \"\
    ) {\n            current_paren_group.append(char)\n        }\n    }\n    \n  \
    \  return paren_groups", '    return []', "    var groups = [String]()\n    var\
    \ sum = 0\n    var group = \"\"\n    for char in paren_string {\n        if char\
    \ == \"(\" {\n            sum += 1\n        } else if char == \")\" {\n      \
    \      sum -= 1\n        }\n        group += String(char)\n        if sum == 0\
    \ {\n            groups.append(group)\n            group = \"\"\n        }\n \
    \   }\n    return groups", "    \n    let arrayOfParens: [String] = [\")\", \"\
    (\", \"{\", \"}\", \"[\", \"]\"]\n    var stackOfParens: [String] = []\n    var\
    \ arrayOfAnswers: [String] = []\n    var n = 0\n    var counter = 0\n    var i\
    \ = 0\n    var str = \"\"\n    \n    while (i < paren_string.count) {\n      \
    \  var character = \"\\(paren_string[paren_string.index(paren_string.startIndex,\
    \ offsetBy: i)])\"\n        var character2 = \"\\(paren_string[paren_string.index(paren_string.startIndex,\
    \ offsetBy: i+1)])\"\n        if arrayOfParens.contains(character) {\n       \
    \     stackOfParens.append(character)\n            counter = counter + 1\n   \
    \         if character == \")\" && character2 == \"(\" {\n                arrayOfAnswers.append(str)\n\
    \                str = \"\"\n                stackOfParens.removeAll()\n     \
    \           counter = 0\n            }\n        }\n        else {\n          \
    \  str = str + character\n        }\n        i = i + 1\n    }\n    arrayOfAnswers.append(str)\n\
    \    return arrayOfAnswers", "    // Store the position of all open and close\
    \ parentheses\n    var openParenPos = [Int]()\n    var closeParenPos = [Int]()\n\
    \    for (i, c) in paren_string.enumerated() {\n        if c == \"(\" {\n    \
    \        openParenPos.append(i)\n        } else if c == \")\" {\n            closeParenPos.append(i)\n\
    \        }\n    }\n    \n    // Separate the groups into separate strings\n  \
    \  var groups = [String]()\n    var start = 0\n    for i in 0..<openParenPos.count\
    \ {\n        // Extract the first group from the string\n        let startPos\
    \ = openParenPos[i]\n        let endPos = closeParenPos[i]\n        let group\
    \ = paren_string[paren_string.index(paren_string.startIndex, offsetBy: startPos)..<paren_string.index(paren_string.startIndex,\
    \ offsetBy: endPos + 1)]\n        groups.append(String(group))\n        \n   \
    \     // Set the new starting point for the next group\n        start = endPos\
    \ + 1\n    }\n    \n    return groups", "    let myString = paren_string.components(separatedBy:\
    \ \" \").joined()\n    var balancedParens: [String] = []\n    var start = 0\n\
    \    for i in 0..<myString.count {\n        if myString[myString.index(myString.startIndex,\
    \ offsetBy: i)] == \"(\" {\n            start = i\n        } else if myString[myString.index(myString.startIndex,\
    \ offsetBy: i)] == \")\" {\n            let end = i\n            balancedParens.append(String(myString[myString.index(myString.startIndex,\
    \ offsetBy: start)..<myString.index(myString.startIndex, offsetBy: end + 1)]))\n\
    \        }\n    }\n    return balancedParens", "    var result = [String]()\n\
    \    var open_parens = 0\n    var closed_parens = 0\n    var current_string =\
    \ \"\"\n    for character in paren_string {\n        if character == \"(\" {\n\
    \            open_parens += 1\n            current_string += String(character)\n\
    \        } else if character == \")\" {\n            closed_parens += 1\n    \
    \        current_string += String(character)\n        }\n        if open_parens\
    \ == closed_parens {\n            result.append(current_string)\n            current_string\
    \ = \"\"\n            open_parens = 0\n            closed_parens = 0\n       \
    \ }\n    }\n    return result", "    var paren_array: [String] = []\n    var ignore_spaces\
    \ = \"\"\n    for char in paren_string {\n        if char != \" \" {\n       \
    \     ignore_spaces += String(char)\n        }\n    }\n    var paren_set = Set<Character>()\n\
    \    for char in ignore_spaces {\n        paren_set.insert(char)\n    }\n    let\
    \ all_paren = \"()\"\n    if paren_set.isSubset(of: all_paren.asSet) {\n     \
    \   var current_paren = \"\"\n        var open_paren_count = 0\n        for char\
    \ in ignore_spaces {\n            if char == \"(\" {\n                open_paren_count\
    \ += 1\n            }\n            if char == \")\" {\n                open_paren_count\
    \ -= 1\n            }\n            current_paren += String(char)\n           \
    \ if open_paren_count == 0 {\n                paren_array.append(current_paren)\n\
    \                current_paren = \"\"\n            }\n        }\n    }\n    return\
    \ paren_array", "    var groups: [String] = []\n    var paren_chars: [Character]\
    \ = Array(paren_string)\n    var index = 0\n    while index < paren_chars.count\
    \ {\n        switch paren_chars[index] {\n        case \"(\":\n            var\
    \ group = \"\"\n            group.append(paren_chars[index])\n            index\
    \ += 1\n            var bracket_count = 1\n            while index < paren_chars.count\
    \ && bracket_count > 0 {\n                switch paren_chars[index] {\n      \
    \          case \"(\":\n                    bracket_count += 1\n             \
    \   case \")\":\n                    bracket_count -= 1\n                default:\n\
    \                    break\n                }\n                group.append(paren_chars[index])\n\
    \                index += 1\n            }\n            groups.append(group)\n\
    \        case \")\":\n            index += 1\n        default:\n            index\
    \ += 1\n        }\n    }\n    return groups", "    var arr = paren_string.filter\
    \ { $0 != \" \" }\n    var result = [String]()\n    var temp = \"\"\n    var currentCount\
    \ = 0\n    var previousCount = 0\n    for letter in arr {\n        if letter ==\
    \ \"(\" {\n            currentCount += 1\n        } else if letter == \")\" {\n\
    \            currentCount -= 1\n        }\n        temp.append(letter)\n     \
    \   if currentCount < previousCount {\n            result.append(temp)\n     \
    \       temp = \"\"\n        }\n        previousCount = currentCount\n    }\n\
    \    return result", "    /// Private function used to iterate through string,\
    \ keeping track of which\n    /// level of nesting we are currently in. We use\
    \ this to keep track of the\n    /// indices of the start of our current group\
    \ so we can easily slice at the end.\n    func parse_string(s: String, nesting_level:\
    \ Int = 0, start_of_substring: Int = 0, groups: [String] = []) -> [String] {\n\
    \        var start_of_substring = start_of_substring\n        var nesting_level\
    \ = nesting_level\n        var groups = groups\n        if let paren = s.first\
    \ {\n            switch paren {\n            case \"(\":\n                nesting_level\
    \ += 1\n            case \")\":\n                nesting_level -= 1\n        \
    \        if nesting_level == 0 {\n                    let new_substring = String(s[s.index(s.startIndex,\
    \ offsetBy: start_of_substring)..<s.index(s.startIndex, offsetBy: s.count)])\n\
    \                    groups.append(new_substring)\n                    start_of_substring\
    \ = s.count\n                }\n            default:\n                break\n\
    \            }\n            let new_string = String(s[s.index(s.startIndex, offsetBy:\
    \ 1)..<s.index(s.startIndex, offsetBy: s.count)])\n            return parse_string(s:\
    \ new_string, nesting_level: nesting_level, start_of_substring: start_of_substring,\
    \ groups: groups)\n        }\n        return groups\n    }\n    return parse_string(s:\
    \ paren_string)", "    var result: [String] = []\n    var start: Int = 0\n   \
    \ var end: Int = 0\n    var depth: Int = 0\n    var foundGroup: Bool = false\n\
    \    for index in 0..<paren_string.count {\n        let char: Character = paren_string[paren_string.index(paren_string.startIndex,\
    \ offsetBy: index)]\n        if char == \"(\" {\n            if depth == 0 {\n\
    \                start = index\n            }\n            depth += 1\n      \
    \  } else if char == \")\" {\n            depth -= 1\n            if depth ==\
    \ 0 {\n                end = index\n                result.append(paren_string[paren_string.index(paren_string.startIndex,\
    \ offsetBy: start)...paren_string.index(paren_string.startIndex, offsetBy: end)])\n\
    \                foundGroup = true\n            }\n        }\n    }\n    if !foundGroup\
    \ {\n        return []\n    }\n    return result", "    var result: [String] =\
    \ []\n    var current_paren_string = \"\"\n    var num_parens = 0\n    for char\
    \ in paren_string {\n        if char == \"(\" {\n            num_parens += 1\n\
    \        } else if char == \")\" {\n            num_parens -= 1\n        }\n \
    \       if num_parens == 0 {\n            result.append(current_paren_string)\n\
    \            current_paren_string = \"\"\n        } else {\n            current_paren_string.append(char)\n\
    \        }\n    }\n    return result", "  // Implement your solution below.\n\
    \  var result = [String]()\n  var currentGroup = \"\"\n  var parenDict = [Character:\
    \ Character]()\n  parenDict[\"(\"] = \")\"\n  parenDict[\"[\"] = \"]\"\n  parenDict[\"\
    {\"] = \"}\"\n  var openers = Set<Character>()\n  for (key, _) in parenDict {\n\
    \    openers.insert(key)\n  }\n  for char in paren_string {\n    if openers.contains(char)\
    \ {\n      currentGroup.append(char)\n    } else if parenDict.values.contains(char)\
    \ {\n      if parenDict[currentGroup.last!] == char {\n        currentGroup.append(char)\n\
    \        result.append(currentGroup)\n        currentGroup = \"\"\n      }\n \
    \   }\n  }\n  return result", "    var output: [String] = []\n    var temp: String\
    \ = \"\"\n    var stack: Stack<Character> = Stack<Character>()\n    for character\
    \ in paren_string {\n        if character == \"(\" {\n            stack.push(character)\n\
    \        } else if character == \")\" {\n            stack.pop()\n        }\n\
    \        temp.append(character)\n        if stack.isEmpty() {\n            output.append(temp)\n\
    \            temp = \"\"\n        }\n    }\n    return output", "    let parens\
    \ = paren_string.replacingOccurrences(of: \" \", with: \"\")\n    return separate_paren_groups(paren_string:\
    \ parens, groups: [], start_of_current_group: 0)", '    return ["(())", "(()())"]',
  "    \n    var result: [String] = []\n    let group = Stack<Character>()\n    var\
    \ stack = Stack<Character>()\n    let openBraces = [Character](\"(\")\n    let\
    \ closeBraces = [Character](\")\")\n    \n    for char in paren_string {\n   \
    \     stack.push(char)\n    }\n    \n    while !stack.isEmpty() {\n        let\
    \ currentChar = stack.pop()\n        if openBraces.contains(currentChar!) {\n\
    \            group.push(currentChar!)\n        } else if closeBraces.contains(currentChar!)\
    \ {\n            group.push(currentChar!)\n            if group.isBalanced() {\n\
    \                var array = Array(group.array)\n                result.append(String(array))\n\
    \                group.clear()\n            }\n        }\n    }\n    \n    return\
    \ result", "    // init result array\n    var result = [String]()\n    // init\
    \ temp\n    var temp = \"\"\n    // init stack\n    var stack = Stack<Character>()\n\
    \    // loop through paren string\n    for char in paren_string {\n        //\
    \ skip space\n        if char == \" \" {\n            continue\n        }\n  \
    \      // if char is open paren\n        if char == \"(\" {\n            // append\
    \ to temp\n            temp.append(char)\n            // append to stack\n   \
    \         stack.push(char)\n        }\n        // if char is close paren\n   \
    \     if char == \")\" {\n            // append to temp\n            temp.append(char)\n\
    \            // pop from stack\n            stack.pop()\n            // if stack\
    \ is empty, append to result and reset temp\n            if stack.isEmpty() {\n\
    \                result.append(temp)\n                temp = \"\"\n          \
    \  }\n        }\n    }\n    // return result\n    return result", "    var result\
    \ = [String]()\n    var index = 0\n    var currentGroup = String()\n    while\
    \ index < paren_string.count {\n        let char = paren_string[index]\n     \
    \   if char == \"(\" {\n            currentGroup.append(char)\n        } else\
    \ if char == \")\" {\n            currentGroup.append(char)\n            if currentGroup.count\
    \ == 2 {\n                result.append(currentGroup)\n                currentGroup\
    \ = String()\n            }\n        }\n        index += 1\n    }\n    return\
    \ result", "    var characters = Array(paren_string)\n    var result: [String]\
    \ = []\n    var startIndex = 0\n    var depth = 0\n    var currentString = \"\"\
    \n    var add = false\n    for i in 0..<characters.count {\n        if characters[i]\
    \ == \"(\" {\n            if depth == 0 {\n                add = true\n      \
    \          startIndex = i\n            }\n            depth += 1\n        } else\
    \ if characters[i] == \")\" {\n            depth -= 1\n            if depth ==\
    \ 0 {\n                add = false\n                currentString = String(characters[startIndex...i])\n\
    \                if !currentString.isEmpty {\n                    result.append(currentString)\n\
    \                }\n            }\n        }\n        if add {\n            currentString\
    \ += String(characters[i])\n        }\n    }\n    return result", "    let string\
    \ = \"\".join(paren_string.componentsSeparatedByCharactersInSet(NSCharacterSet.whitespaceCharacterSet()))\n\
    \    var res = [String]()\n    var leftParens = 0\n    var rightParens = 0\n \
    \   var startIndex = 0\n    for (index, char) in enumerate(string) {\n       \
    \ if char == \"(\" {\n            leftParens++\n        } else if char == \")\"\
    \ {\n            rightParens++\n        }\n        if leftParens == rightParens\
    \ {\n            res.append(string[startIndex..<index + 1])\n            startIndex\
    \ = index + 1\n        }\n    }\n    return res", "    var parenStack: [String]\
    \ = []\n    var stringArray: [String] = []\n    var currentString: String = \"\
    \"\n    for char in paren_string {\n        if char == \"(\" {\n            parenStack.append(\"\
    (\")\n            currentString.append(char)\n        } else if char == \")\"\
    \ {\n            parenStack.removeLast()\n            currentString.append(char)\n\
    \            if parenStack.isEmpty {\n                stringArray.append(currentString)\n\
    \                currentString = \"\"\n            }\n        }\n    }\n    return\
    \ stringArray", '    return []', "    var result = [String]()\n    var paren_groups\
    \ = [Int]()\n    var curr_index = 0\n    var buffer = \"\"\n    for char in paren_string\
    \ {\n        if char == \"(\" {\n            paren_groups.append(curr_index)\n\
    \        } else if char == \")\" {\n            paren_groups.removeLast()\n  \
    \      }\n        if paren_groups.count == 0 {\n            result.append(buffer)\n\
    \            buffer = \"\"\n        } else {\n            buffer.append(char)\n\
    \        }\n        curr_index += 1\n    }\n    return result", "    var result\
    \ = [String]()\n    var str = paren_string\n    str = str.replacingOccurrences(of:\
    \ \" \", with: \"\")\n    while let _ = str.firstIndex(of: \"(\") {\n        if\
    \ let open_index = str.firstIndex(of: \"(\") {\n            let index = str.index(after:\
    \ open_index)\n            str.remove(at: open_index)\n            str.insert(\"\
    *\", at: index)\n        }\n        if let close_index = str.firstIndex(of: \"\
    )\") {\n            let index = str.index(after: close_index)\n            str.remove(at:\
    \ close_index)\n            str.insert(\"*\", at: index)\n        }\n        if\
    \ let index = str.firstIndex(of: \"*\") {\n            let sub_str = String(str[str.startIndex..<index])\n\
    \            result.append(sub_str)\n            str.removeFirst(sub_str.count\
    \ + 1)\n        }\n    }\n    return result", "    var result : [String] = []\n\
    \    var current_group : String = \"\"\n    var open_parens = 0\n    var closed_parens\
    \ = 0\n    for paren in paren_string {\n        if paren == \"(\" {\n        \
    \    open_parens += 1\n            current_group += String(paren)\n        } else\
    \ if paren == \")\" {\n            closed_parens += 1\n            current_group\
    \ += String(paren)\n        }\n        if open_parens == closed_parens {\n   \
    \         result.append(current_group)\n            current_group = \"\"\n   \
    \         open_parens = 0\n            closed_parens = 0\n        }\n    }\n \
    \   return result", "    \n    // your code here\n    let str = paren_string.replacingOccurrences(of:\
    \ \" \", with: \"\")\n    return separate(str)", "    let parens = paren_string.replacingOccurrences(of:\
    \ \" \", with: \"\")\n    return parens.split(separator: \")\").filter { !$0.isEmpty\
    \ }.map { String($0) + \")\" }", "    var paren_groups = [String]()\n    var current_index\
    \ = 0\n    while current_index < paren_string.count {\n        var i = current_index\n\
    \        var open_counter = 0\n        while i < paren_string.count {\n      \
    \      if paren_string[i] == \"(\" {\n                open_counter += 1\n    \
    \        } else if paren_string[i] == \")\" {\n                open_counter -=\
    \ 1\n            }\n            if open_counter == 0 {\n                break\n\
    \            }\n            i += 1\n        }\n        let indexEndOfText = paren_string.index(paren_string.startIndex,\
    \ offsetBy: i)\n        let subString = paren_string[current_index..<indexEndOfText]\n\
    \        paren_groups.append(String(subString))\n        current_index = i + 1\n\
    \    }\n    return paren_groups", "    // Create a map of ( and ) => their string\
    \ indexes\n    var left_paren_map = [Int:Int]()\n    var right_paren_map = [Int:Int]()\n\
    \    var stack = [Int]()\n    var groups = [String]()\n    \n    for (index, char)\
    \ in paren_string.enumerated() {\n        if char == \"(\" {\n            left_paren_map[index]\
    \ = index\n            stack.append(index)\n        } else if char == \")\" {\n\
    \            right_paren_map[index] = index\n            stack.popLast()\n   \
    \     }\n    }\n    \n    var i = 0\n    while i < paren_string.count {\n    \
    \    if let start = left_paren_map[i] {\n            let next = start + 1\n  \
    \          let end = right_paren_map[next]\n            i = end! + 1\n       \
    \     let range = start...end!\n            groups.append(paren_string[range])\n\
    \        } else {\n            i += 1\n        }\n    }\n    \n    return groups",
  "    var result = [String]()\n    var current_string = \"\"\n    var stack = Stack<Character>()\n\
    \    for char in paren_string {\n        if char == \"(\" {\n            stack.push(char)\n\
    \        } else if char == \")\" {\n            if stack.peek() == \"(\" {\n \
    \               stack.pop()\n                if stack.isEmpty() {\n          \
    \          result.append(current_string)\n                    current_string =\
    \ \"\"\n                } else {\n                    current_string.append(char)\n\
    \                }\n            } else {\n                current_string.append(char)\n\
    \            }\n        } else {\n            current_string.append(char)\n  \
    \      }\n    }\n    return result", "    \n    var a: Int = 0\n    var b: Int\
    \ = 0\n    var c: Int = 0\n    var d: Int = 0\n    var e: Int = 0\n    var f:\
    \ Int = 0\n    var g: Int = 0\n    var h: Int = 0\n    var i: Int = 0\n    var\
    \ j: Int = 0\n    var k: Int = 0\n    var l: Int = 0\n    var m: Int = 0\n   \
    \ var n: Int = 0\n    var o: Int = 0\n    var p: Int = 0\n    var q: Int = 0\n\
    \    var r: Int = 0\n    var s: Int = 0\n    var t: Int = 0\n    var u: Int =\
    \ 0\n    var v: Int = 0\n    var w: Int = 0\n    var x: Int = 0\n    var y: Int\
    \ = 0\n    var z: Int = 0\n    \n    var a_i: Int = 0\n    var b_i: Int = 0\n\
    \    var c_i: Int = 0\n    var d_i: Int = 0\n    var e_i: Int = 0\n    var f_i:\
    \ Int = 0\n    var g_i: Int = 0\n    var h_i: Int = 0\n    var i_i: Int = 0\n\
    \    var j_i: Int = 0\n    var k_i: Int = 0\n    var l_i: Int = 0\n    var m_i:\
    \ Int = 0\n    var n_i: Int = 0\n    var o_i: Int = 0\n    var p_i: Int = 0\n\
    \    var q_i: Int = 0\n    var r_i: Int = 0\n    var s_i: Int = 0\n    var t_i:\
    \ Int = 0\n    var u_i: Int = 0\n    var v_i: Int = 0\n    var w_i: Int = 0\n\
    \    var x_i: Int = 0\n    var y_i: Int = 0\n    var z_i: Int = 0\n    \n    var\
    \ temp_int: Int = 0\n    var temp_int_i: Int = 0\n    \n    var a_counter: Int\
    \ = 0\n    var b", "    var groups = [String]()\n    var current_group = \"\"\n\
    \    var open_parens = 0\n    for c in paren_string {\n        if c == \"(\" {\n\
    \            open_parens += 1\n            current_group += \"(\"\n        } else\
    \ if c == \")\" {\n            open_parens -= 1\n            current_group +=\
    \ \")\"\n        }\n        if open_parens == 0 {\n            groups.append(current_group)\n\
    \            current_group = \"\"\n        }\n    }\n    return groups", "   \
    \ var groups = [String]()\n    var current_group = \"\"\n    var paren_count =\
    \ 0\n    for c in paren_string {\n        if c == \"(\" {\n            paren_count\
    \ += 1\n            current_group += \"(\"\n        } else if c == \")\" {\n \
    \           paren_count -= 1\n            current_group += \")\"\n        }\n\
    \        if paren_count == 0 {\n            groups.append(current_group)\n   \
    \         current_group = \"\"\n        }\n    }\n    return groups", "    var\
    \ count = 0\n    var groups = [String]()\n    var group = \"\"\n    for c in paren_string\
    \ {\n        if c == \"(\" {\n            count += 1\n        } else if c == \"\
    )\" {\n            count -= 1\n        }\n        if count == 0 {\n          \
    \  if c == \")\" || c == \"(\" {\n                groups.append(group)\n     \
    \           group = \"\"\n            }\n        } else {\n            if c ==\
    \ \")\" || c == \"(\" {\n                group.append(c)\n            }\n    \
    \    }\n    }\n    return groups", "    var result = [String]()\n    var tempString\
    \ = \"\"\n    var count = 0\n    for char in paren_string.characters {\n     \
    \   if char == \"(\" {\n            count += 1\n        } else if char == \")\"\
    \ {\n            count -= 1\n        }\n        if count == 0 {\n            if\
    \ tempString != \"\" {\n                result.append(tempString)\n          \
    \      tempString = \"\"\n            }\n        } else {\n            tempString.append(char)\n\
    \        }\n    }\n    return result", "    let parens = paren_string.replacingOccurrences(of:\
    \ \" \", with: \"\")\n    var result = [String]()\n    for sub in parens.split(separator:\
    \ \")\") {\n        let sub_parens = String(sub)\n        if sub_parens == \"\"\
    \ {\n            continue\n        }\n        let paren_string = sub_parens +\
    \ \")\"\n        if paren_string.is_balanced() {\n            result.append(paren_string)\n\
    \        }\n    }\n    return result", "    var result = [String]()\n    var stack:\
    \ [Character] = []\n    var element: Character\n    for char in paren_string {\n\
    \        if char == \"(\" {\n            stack.append(char)\n        } else if\
    \ char == \")\" {\n            element = stack.removeLast()\n            if element\
    \ == \"(\" {\n                // valid pair\n                if stack.count ==\
    \ 0 {\n                    result.append(\"()\")\n                }\n        \
    \    } else {\n                // invalid\n                return result\n   \
    \         }\n        }\n    }\n    return result", '    return []', '    return
    []', "    let new_string = paren_string.replacingOccurrences(of: \" \", with:\
    \ \"\")\n    let new_string_chars = Array(new_string)\n    var open_paren_indices\
    \ = [Int]()\n    var start_index = 0\n    for (index, char) in new_string_chars.enumerated()\
    \ {\n        if char == \"(\" {\n            open_paren_indices.append(index)\n\
    \        } else if char == \")\" {\n            let temp_arr = Array(new_string_chars[open_paren_indices[start_index]...index])\n\
    \            print(temp_arr)\n            start_index += 1\n        }\n    }\n\
    \    return [\"()\", \"(())\", \"(()())\"]", "    var openBraceCount = 0\n   \
    \ var result = [String]()\n    var tempStr = \"\"\n    for i in paren_string {\n\
    \        if i == \"(\" {\n            openBraceCount += 1\n        } else if i\
    \ == \")\" {\n            openBraceCount -= 1\n        }\n        tempStr.append(i)\n\
    \        if openBraceCount == 0 {\n            result.append(tempStr)\n      \
    \      tempStr = \"\"\n        }\n    }\n    return result", "    var result =\
    \ [String]()\n    let tempArr = paren_string.components(separatedBy: \" \")\n\
    \    var tempStr = \"\"\n    for str in tempArr {\n        tempStr += str\n  \
    \  }\n    var i = 0\n    while i < tempStr.count {\n        let index = tempStr.index(tempStr.startIndex,\
    \ offsetBy: i)\n        if tempStr[index] == \"(\" {\n            let newStr =\
    \ tempStr.substring(from: index)\n            let valid = isValid(newStr)\n  \
    \          if valid == true {\n                result.append(newStr)\n       \
    \         tempStr = tempStr.substring(to: index)\n                i = 0\n    \
    \        } else {\n                i += 1\n            }\n        } else {\n \
    \           i += 1\n        }\n    }\n    return result", "    let array = Array(paren_string)\n\
    \    var result = [String]()\n    var i = 0\n    var open = 0\n    var close =\
    \ 0\n    var start = 0\n    while i < array.count {\n        if array[i] == \"\
    (\" {\n            open += 1\n            if open == 1 {\n                start\
    \ = i\n            }\n        } else if array[i] == \")\" {\n            close\
    \ += 1\n            if open == close {\n                result.append(paren_string[start..<i+1])\n\
    \                open = 0\n                close = 0\n            }\n        }\n\
    \        i += 1\n    }\n    return result", '    return []', "    var result =\
    \ [String]()\n    var start = 0\n    for i in paren_string.indices {\n       \
    \ switch paren_string[i] {\n        case \"(\":\n            start = i.encodedOffset\n\
    \        case \")\":\n            result.append(paren_string[paren_string.index(paren_string.startIndex,\
    \ offsetBy: start)..<i])\n        default:\n            break\n        }\n   \
    \ }\n    return result", "    if paren_string.isEmpty {\n        return []\n \
    \   }\n    \n    var characters = Array(paren_string)\n    var result = [String]()\n\
    \    var count = 0\n    var start_index = 0\n    for i in 0 ..< characters.count\
    \ {\n        if characters[i] == \"(\" {\n            count += 1\n        } else\
    \ if characters[i] == \")\" {\n            count -= 1\n        }\n        \n \
    \       if count == 0 {\n            result.append(String(characters[start_index\
    \ ... i]))\n            start_index = i + 1\n        }\n    }\n    \n    return\
    \ result", "    var ret: [String] = []\n    var temp: String = \"\"\n    var paren_count:\
    \ Int = 0\n    for c in paren_string {\n        if (c == \" \") {\n          \
    \  continue\n        }\n        if (c == \"(\") {\n            paren_count +=\
    \ 1\n        }\n        if (c == \")\") {\n            paren_count -= 1\n    \
    \    }\n        temp.append(c)\n        if (paren_count == 0) {\n            ret.append(temp)\n\
    \            temp = \"\"\n        }\n    }\n    return ret", "  var result: [String]\
    \ = []\n  let processed = paren_string.filter { $0 != \" \" }\n  var start = 0\n\
    \  var cur = 0\n  var stack = 0\n  for ch in processed {\n    if ch == \"(\" {\n\
    \      stack += 1\n    } else if ch == \")\" {\n      stack -= 1\n    }\n    cur\
    \ += 1\n    if stack == 0 {\n      result.append(String(processed[start..<cur]))\n\
    \      start = cur\n    }\n  }\n  return result", "    \n    var results = [String]()\n\
    \    var stack = Stack<Character>()\n    var current_paren_string = \"\"\n   \
    \ \n    for paren in paren_string {\n        if paren == \"(\" {\n           \
    \ stack.push(paren)\n            current_paren_string += String(paren)\n     \
    \   } else if paren == \")\" {\n            guard let last = stack.peek() else\
    \ {\n                fatalError(\"Mismatched parens\")\n            }\n      \
    \      if last == \"(\" {\n                stack.pop()\n                current_paren_string\
    \ += String(paren)\n                if stack.peek() == nil {\n               \
    \     results.append(current_paren_string)\n                    current_paren_string\
    \ = \"\"\n                }\n            } else {\n                fatalError(\"\
    Mismatched parens\")\n            }\n        }\n    }\n    \n    return results",
  "    var separated_groups: [String] = []\n    var temp_group: String = \"\"\n  \
    \  var open_braces = 0\n    for char in paren_string {\n        if char == \"\
    (\" {\n            open_braces += 1\n            temp_group += String(char)\n\
    \        } else if char == \")\" {\n            if open_braces == 1 {\n      \
    \          separated_groups.append(temp_group)\n                temp_group = \"\
    \"\n            } else {\n                temp_group += String(char)\n       \
    \     }\n            open_braces -= 1\n        }\n    }\n    return separated_groups",
  '    return []', "    var delimiters = [Character]()\n    var newStrings = [String]()\n\
    \    var outputStrings = [String]()\n    var currentString = \"\"\n    var index\
    \ = 0\n    // This is the loop to go through the entire string and find where\
    \ the delimiters are\n    for char in paren_string {\n        if char == \"(\"\
    \ || char == \")\" {\n            delimiters.append(char)\n        }\n    }\n\
    \    // This is the loop to put the delimiters into separate strings in the newStrings\
    \ array\n    while index < delimiters.count {\n        if delimiters[index] ==\
    \ \"(\" {\n            while delimiters[index] != \")\" {\n                currentString\
    \ += String(delimiters[index])\n                index += 1\n            }\n  \
    \          currentString += String(delimiters[index])\n            newStrings.append(currentString)\n\
    \            currentString = \"\"\n        }\n        index += 1\n    }\n    //\
    \ This is the loop to go through newStrings and put the strings into the outputStrings\
    \ array\n    for item in newStrings {\n        var count = 0\n        for char\
    \ in item {\n            if char == \"(\" {\n                count += 1\n    \
    \        } else if char == \")\" {\n                count -= 1\n            }\n\
    \            if count < 0 {\n                break\n            }\n        }\n\
    \        if count == 0 {\n            outputStrings.append(item)\n        }\n\
    \    }\n    return outputStrings", "    var out: [String] = []\n    var openCount\
    \ = 0\n    var currStr = \"\"\n    paren_string.forEach {\n        if $0 == \"\
    (\" {\n            openCount += 1\n            currStr.append($0)\n        } else\
    \ if $0 == \")\" {\n            openCount -= 1\n            currStr.append($0)\n\
    \            if openCount == 0 {\n                out.append(currStr)\n      \
    \          currStr = \"\"\n            }\n        }\n    }\n    return out", " \
    \   var stack = Stack<Character>()\n    var parens = \"\"\n    var separated_parens\
    \ = [String]()\n    \n    for char in paren_string {\n        if char == \"(\"\
    \ {\n            stack.push(char)\n        } else if char == \")\" {\n       \
    \     stack.pop()\n            if stack.isEmpty() {\n                separated_parens.append(parens)\n\
    \                parens = \"\"\n            }\n        }\n        if !stack.isEmpty()\
    \ {\n            parens.append(char)\n        }\n    }\n    return separated_parens",
  "    var result: [String] = []\n    var outer_paren_stack: [Int] = []\n    var inner_paren_stack:\
    \ [Int] = []\n    for (i, paren) in paren_string.enumerated() {\n        if paren\
    \ == \"(\" {\n            if inner_paren_stack.count == 0 {\n                outer_paren_stack.append(i)\n\
    \            }\n            inner_paren_stack.append(i)\n        } else if paren\
    \ == \")\" {\n            inner_paren_stack.removeLast()\n            if inner_paren_stack.count\
    \ == 0 {\n                let string = paren_string[outer_paren_stack.removeLast()..<i+1]\n\
    \                result.append(String(string))\n            }\n        }\n   \
    \ }\n    return result", "    var separated: [String] = []\n    var search = paren_string\n\
    \    while search.count > 0 {\n        guard let range = search.range(of: \"\\\
    \\([^\\\\(\\\\)]*\\\\)\", options: .regularExpression) else {\n            break\n\
    \        }\n        let s = String(search[range])\n        separated.append(s)\n\
    \        search.removeSubrange(range)\n    }\n    return separated", "    var\
    \ input = paren_string\n    var out: [String] = []\n    while let i = input.index(of:\
    \ \"(\") {\n        let left = i\n        var j = left\n        var count = 1\n\
    \        while count > 0 {\n            j = input.index(after: j)\n          \
    \  if input[j] == \"(\" {\n                count += 1\n            } else if input[j]\
    \ == \")\" {\n                count -= 1\n            }\n        }\n        out.append(String(input[left...j]))\n\
    \        input = String(input[input.index(after: j)...])\n    }\n    return out",
  "    var parens = [String]()\n    var numOpens = 0\n    var numCloses = 0\n    var\
    \ start = 0\n    var i = 0\n    while i < paren_string.count {\n        let curr\
    \ = String(paren_string[paren_string.index(paren_string.startIndex, offsetBy:\
    \ i)])\n        if curr == \"(\" {\n            numOpens += 1\n        } else\
    \ if curr == \")\" {\n            numCloses += 1\n        }\n        if numOpens\
    \ == numCloses {\n            parens.append(String(paren_string[paren_string.index(paren_string.startIndex,\
    \ offsetBy: start)..<paren_string.index(paren_string.startIndex, offsetBy: i +\
    \ 1)]))\n            start = i + 1\n            numOpens = 0\n            numCloses\
    \ = 0\n        }\n        i += 1\n    }\n    return parens", "    let parens =\
    \ paren_string.replacingOccurrences(of: \" \", with: \"\")\n    let parens_count\
    \ = parens.count\n    var groups = [String]()\n    var group = String()\n    var\
    \ parens_array = Array(parens)\n    var count = 0\n    for i in 0..<parens_count\
    \ {\n        group.append(parens_array[i])\n        if parens_array[i] == \"(\"\
    \ {\n            count += 1\n        } else {\n            count -= 1\n      \
    \  }\n        if count == 0 {\n            groups.append(group)\n            group\
    \ = String()\n        }\n    }\n    return groups", "    var array: [String] =\
    \ []\n    var numberOpen = 0\n    var numberClose = 0\n    var result = \"\"\n\
    \    for char in paren_string {\n        if char == \"(\" {\n            numberOpen\
    \ += 1\n        } else if char == \")\" {\n            numberClose += 1\n    \
    \    }\n        if numberOpen == numberClose {\n            array.append(result)\n\
    \            result = \"\"\n            numberOpen = 0\n            numberClose\
    \ = 0\n        } else {\n            result += String(char)\n        }\n    }\n\
    \    return array", "    var answer: [String] = []\n    var paren_string = paren_string\n\
    \    while paren_string.contains(\"(\") {\n        var tmp_str = \"\"\n      \
    \  var brackets_count = 0\n        for i in paren_string {\n            if i ==\
    \ \"(\" {\n                brackets_count += 1\n            } else if i == \"\
    )\" {\n                brackets_count -= 1\n            }\n            tmp_str.append(i)\n\
    \            if brackets_count == 0 {\n                paren_string.removeFirst(tmp_str.count)\n\
    \                answer.append(tmp_str)\n                break\n            }\n\
    \        }\n    }\n    return answer", "    var result: [String] = []\n    var\
    \ ptr = 0\n    var parenGroups: [String] = []\n    var s = paren_string.filter\
    \ { (c) -> Bool in\n        c != \" \"\n    }\n    while ptr < s.count {\n   \
    \     var paren = \"\"\n        var totalOpen = 0\n        while ptr < s.count\
    \ {\n            let c = s[s.index(s.startIndex, offsetBy: ptr)]\n           \
    \ if c == \"(\" {\n                totalOpen += 1\n            } else if c ==\
    \ \")\" {\n                totalOpen -= 1\n            }\n            paren.append(c)\n\
    \            ptr += 1\n            if totalOpen == 0 {\n                break\n\
    \            }\n        }\n        parenGroups.append(paren)\n    }\n    print(parenGroups)\n\
    \    return result", "    var stack: [Character] = []\n    var temp: [Character]\
    \ = []\n    var res: [String] = []\n    let start: Character = \"(\"\n    let\
    \ end: Character = \")\"\n    let paren_string = paren_string.replacingOccurrences(of:\
    \ \" \", with: \"\")\n    for char in paren_string {\n        if char == start\
    \ {\n            stack.append(char)\n        } else if char == end {\n       \
    \     temp.append(stack.popLast()!)\n            temp.append(char)\n         \
    \   if stack.isEmpty {\n                res.append(String(temp))\n           \
    \     temp = []\n            }\n        }\n    }\n    return res", "    \n   \
    \ var groups = [String]()\n    var paren = paren_string.filter { !\" \\n\\t\\\
    r\".contains($0) }\n    var i = 0\n    var currentString = \"\"\n    var count\
    \ = 0\n    \n    while i < paren.count {\n        let char = paren[paren.index(paren.startIndex,\
    \ offsetBy: i)]\n        if char == \"(\" {\n            count += 1\n        }\
    \ else if char == \")\" {\n            count -= 1\n        }\n        currentString.append(char)\n\
    \        if count == 0 {\n            groups.append(currentString)\n         \
    \   currentString = \"\"\n        }\n        i += 1\n    }\n    \n    return groups",
  "    //MARK: - \n    // TODO: Write your code here!\n    return []"]
stop_tokens:
- "\n}"
