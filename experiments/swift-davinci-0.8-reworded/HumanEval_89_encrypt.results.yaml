language: swift
name: HumanEval_89_encrypt
results:
- exit_code: 1
  program: "\n/// Create a function encrypt that takes a string as an argument and\n\
    /// returns a string encrypted with the alphabet being rotated. \n/// The alphabet\
    \ should be rotated in a manner such that the letters \n/// shift down by two\
    \ multiplied to two places.\n/// For example:\n/// >>> encrypt(s: \"hi\")\n///\
    \ \"lm\"\n/// >>> encrypt(s: \"asdfghjkl\")\n/// \"ewhjklnop\"\n/// >>> encrypt(s:\
    \ \"gf\")\n/// \"kj\"\n/// >>> encrypt(s: \"et\")\n/// \"ix\"\nfunc encrypt(s:\
    \ String) -> String {\n    // Your code here\n    var encryptedString = \"\"\n\
    \    for char in s.lowercased().characters {\n        if char == \"z\" {\n   \
    \         encryptedString.append(\"b\")\n        } else if char == \"y\" {\n \
    \           encryptedString.append(\"a\")\n        } else {\n            let charIndex\
    \ = char.index(after: char.startIndex)\n            let nextCharIndex = char.index(after:\
    \ charIndex)\n            let nextNextCharIndex = char.index(after: nextCharIndex)\n\
    \            encryptedString.append(char[nextNextCharIndex])\n        }\n    }\n\
    \    return encryptedString\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int,\
    \ Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n\
    \    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n          \
    \  return false\n        }\n    }\n    return true\n}\n            \nassert(encrypt(s:\
    \ \"hi\") == \"lm\")\nassert(encrypt(s: \"asdfghjkl\") == \"ewhjklnop\")\nassert(encrypt(s:\
    \ \"gf\") == \"kj\")\nassert(encrypt(s: \"et\") == \"ix\")\nassert(encrypt(s:\
    \ \"faewfawefaewg\") == \"jeiajeaijeiak\")\nassert(encrypt(s: \"hellomyfriend\"\
    ) == \"lippsqcjvmirh\")\nassert(encrypt(s: \"dxzdlmnilfuhmilufhlihufnmlimnufhlimnufhfucufh\"\
    ) == \"hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl\")\nassert(encrypt(s: \"\
    a\") == \"e\")"
  status: SyntaxError
  stderr: "/tmp/tmpn69kecfr.swift:18:32: error: 'characters' is unavailable: Please\
    \ use String directly\n    for char in s.lowercased().characters {\n         \
    \                      ^~~~~~~~~~\nSwift.String:5:16: note: 'characters' was obsoleted\
    \ in Swift 5.0\n    public var characters: String { get set }\n              \
    \ ^\n/tmp/tmpn69kecfr.swift:24:34: error: value of type 'Character' has no member\
    \ 'index'\n            let charIndex = char.index(after: char.startIndex)\n  \
    \                          ~~~~ ^~~~~\n/tmp/tmpn69kecfr.swift:24:52: error: value\
    \ of type 'Character' has no member 'startIndex'\n            let charIndex =\
    \ char.index(after: char.startIndex)\n                                       \
    \       ~~~~ ^~~~~~~~~~\n/tmp/tmpn69kecfr.swift:25:38: error: value of type 'Character'\
    \ has no member 'index'\n            let nextCharIndex = char.index(after: charIndex)\n\
    \                                ~~~~ ^~~~~\n/tmp/tmpn69kecfr.swift:26:42: error:\
    \ value of type 'Character' has no member 'index'\n            let nextNextCharIndex\
    \ = char.index(after: nextCharIndex)\n                                    ~~~~\
    \ ^~~~~\n/tmp/tmpn69kecfr.swift:27:40: error: value of type 'Character' has no\
    \ subscripts\n            encryptedString.append(char[nextNextCharIndex])\n  \
    \                                 ~~~~^\n"
  stdout: ''
  timestamp: 1660028310
- exit_code: 1
  program: "\n/// Create a function encrypt that takes a string as an argument and\n\
    /// returns a string encrypted with the alphabet being rotated. \n/// The alphabet\
    \ should be rotated in a manner such that the letters \n/// shift down by two\
    \ multiplied to two places.\n/// For example:\n/// >>> encrypt(s: \"hi\")\n///\
    \ \"lm\"\n/// >>> encrypt(s: \"asdfghjkl\")\n/// \"ewhjklnop\"\n/// >>> encrypt(s:\
    \ \"gf\")\n/// \"kj\"\n/// >>> encrypt(s: \"et\")\n/// \"ix\"\nfunc encrypt(s:\
    \ String) -> String {\n    var output = \"\"\n    for letter in s {\n        var\
    \ offset = 65\n        if letter.lowercased() == letter {\n            offset\
    \ = 97\n        }\n        var rotatedLetter = (((Int(letter.asciiValue!) - offset)\
    \ * 2 + 26) % 26) + offset\n        let newLetter = Character(UnicodeScalar(rotatedLetter)!)\n\
    \        output.append(newLetter)\n    }\n    return output\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(encrypt(s: \"hi\") == \"lm\")\nassert(encrypt(s: \"asdfghjkl\"\
    ) == \"ewhjklnop\")\nassert(encrypt(s: \"gf\") == \"kj\")\nassert(encrypt(s: \"\
    et\") == \"ix\")\nassert(encrypt(s: \"faewfawefaewg\") == \"jeiajeaijeiak\")\n\
    assert(encrypt(s: \"hellomyfriend\") == \"lippsqcjvmirh\")\nassert(encrypt(s:\
    \ \"dxzdlmnilfuhmilufhlihufnmlimnufhlimnufhfucufh\") == \"hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl\"\
    )\nassert(encrypt(s: \"a\") == \"e\")"
  status: SyntaxError
  stderr: "/tmp/tmpyn1sktpx.swift:19:32: error: binary operator '==' cannot be applied\
    \ to operands of type 'String' and 'Character'\n        if letter.lowercased()\
    \ == letter {\n           ~~~~~~~~~~~~~~~~~~~ ^  ~~~~~~\n/tmp/tmpyn1sktpx.swift:19:32:\
    \ note: overloads for '==' exist with these partially matching parameter lists:\
    \ (Character, Character), (String, String)\n        if letter.lowercased() ==\
    \ letter {\n                               ^\n"
  stdout: ''
  timestamp: 1660028310
- exit_code: 1
  program: "\n/// Create a function encrypt that takes a string as an argument and\n\
    /// returns a string encrypted with the alphabet being rotated. \n/// The alphabet\
    \ should be rotated in a manner such that the letters \n/// shift down by two\
    \ multiplied to two places.\n/// For example:\n/// >>> encrypt(s: \"hi\")\n///\
    \ \"lm\"\n/// >>> encrypt(s: \"asdfghjkl\")\n/// \"ewhjklnop\"\n/// >>> encrypt(s:\
    \ \"gf\")\n/// \"kj\"\n/// >>> encrypt(s: \"et\")\n/// \"ix\"\nfunc encrypt(s:\
    \ String) -> String {\n    var newString = \"\"\n    for i in s {\n        if\
    \ i == \"a\" {\n            newString += \"c\"\n        } else if i == \"b\" {\n\
    \            newString += \"d\"\n        } else if i == \"c\" {\n            newString\
    \ += \"e\"\n        } else if i == \"d\" {\n            newString += \"f\"\n \
    \       } else if i == \"e\" {\n            newString += \"g\"\n        } else\
    \ if i == \"f\" {\n            newString += \"h\"\n        } else if i == \"g\"\
    \ {\n            newString += \"i\"\n        } else if i == \"h\" {\n        \
    \    newString += \"j\"\n        } else if i == \"i\" {\n            newString\
    \ += \"k\"\n        } else if i == \"j\" {\n            newString += \"l\"\n \
    \       } else if i == \"k\" {\n            newString += \"m\"\n        } else\
    \ if i == \"l\" {\n            newString += \"n\"\n        } else if i == \"m\"\
    \ {\n            newString += \"o\"\n        } else if i == \"n\" {\n        \
    \    newString += \"p\"\n        } else if i == \"o\" {\n            newString\
    \ += \"q\"\n        } else if i == \"p\" {\n            newString += \"r\"\n \
    \       } else if i == \"q\" {\n            newString += \"s\"\n        } else\
    \ if i == \"r\" {\n            newString += \"t\"\n        } else if i == \"s\"\
    \ {\n            newString += \"u\"\n        } else if i == \"t\" {\n        \
    \    newString += \"v\"\n        } else if i == \"u\" {\n            newString\
    \ += \"w\"\n        } else if i == \"v\" {\n            newString += \"x\"\n \
    \       } else if i == \"w\" {\n            newString += \"y\"\n        } else\
    \ if i == \"x\" {\n            newString += \"z\"\n        } else if i == \"y\"\
    \ {\n            newString += \"a\"\n        } else if i == \"z\" {\n        \
    \    newString += \"b\"\n        }\n    }\n}\n\n\nfunc ==(left: [(Int, Int)],\
    \ right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n       \
    \ return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r\
    \ {\n            return false\n        }\n    }\n    return true\n}\n        \
    \    \nassert(encrypt(s: \"hi\") == \"lm\")\nassert(encrypt(s: \"asdfghjkl\")\
    \ == \"ewhjklnop\")\nassert(encrypt(s: \"gf\") == \"kj\")\nassert(encrypt(s: \"\
    et\") == \"ix\")\nassert(encrypt(s: \"faewfawefaewg\") == \"jeiajeaijeiak\")\n\
    assert(encrypt(s: \"hellomyfriend\") == \"lippsqcjvmirh\")\nassert(encrypt(s:\
    \ \"dxzdlmnilfuhmilufhlihufnmlimnufhlimnufhfucufh\") == \"hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl\"\
    )\nassert(encrypt(s: \"a\") == \"e\")"
  status: SyntaxError
  stderr: '/tmp/tmp1wwnut5b.swift:72:1: error: missing return in global function expected
    to return ''String''

    }

    ^

    '
  stdout: ''
  timestamp: 1660028310
- exit_code: 1
  program: "\n/// Create a function encrypt that takes a string as an argument and\n\
    /// returns a string encrypted with the alphabet being rotated. \n/// The alphabet\
    \ should be rotated in a manner such that the letters \n/// shift down by two\
    \ multiplied to two places.\n/// For example:\n/// >>> encrypt(s: \"hi\")\n///\
    \ \"lm\"\n/// >>> encrypt(s: \"asdfghjkl\")\n/// \"ewhjklnop\"\n/// >>> encrypt(s:\
    \ \"gf\")\n/// \"kj\"\n/// >>> encrypt(s: \"et\")\n/// \"ix\"\nfunc encrypt(s:\
    \ String) -> String {\n    let letter = Array(s)\n    var output = [Character]()\n\
    \    for letter in letter {\n        output.append(getNextChar(s: letter))\n \
    \   }\n    return String(output)\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int,\
    \ Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n\
    \    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n          \
    \  return false\n        }\n    }\n    return true\n}\n            \nassert(encrypt(s:\
    \ \"hi\") == \"lm\")\nassert(encrypt(s: \"asdfghjkl\") == \"ewhjklnop\")\nassert(encrypt(s:\
    \ \"gf\") == \"kj\")\nassert(encrypt(s: \"et\") == \"ix\")\nassert(encrypt(s:\
    \ \"faewfawefaewg\") == \"jeiajeaijeiak\")\nassert(encrypt(s: \"hellomyfriend\"\
    ) == \"lippsqcjvmirh\")\nassert(encrypt(s: \"dxzdlmnilfuhmilufhlihufnmlimnufhlimnufhfucufh\"\
    ) == \"hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl\")\nassert(encrypt(s: \"\
    a\") == \"e\")"
  status: SyntaxError
  stderr: "/tmp/tmpkrjoqykr.swift:19:23: error: cannot find 'getNextChar' in scope\n\
    \        output.append(getNextChar(s: letter))\n                      ^~~~~~~~~~~\n"
  stdout: ''
  timestamp: 1660028310
- exit_code: -4
  program: "\n/// Create a function encrypt that takes a string as an argument and\n\
    /// returns a string encrypted with the alphabet being rotated. \n/// The alphabet\
    \ should be rotated in a manner such that the letters \n/// shift down by two\
    \ multiplied to two places.\n/// For example:\n/// >>> encrypt(s: \"hi\")\n///\
    \ \"lm\"\n/// >>> encrypt(s: \"asdfghjkl\")\n/// \"ewhjklnop\"\n/// >>> encrypt(s:\
    \ \"gf\")\n/// \"kj\"\n/// >>> encrypt(s: \"et\")\n/// \"ix\"\nfunc encrypt(s:\
    \ String) -> String {\n    var alphabet = \"abcdefghijklmnopqrstuvwxyz\"\n   \
    \ var stringArray = Array(s)\n    var newString = \"\"\n    for letter in stringArray\
    \ {\n        let index = alphabet.index(of: letter)\n        let newIndex = alphabet.index(index!,\
    \ offsetBy: 2)\n        let newIndex2 = alphabet.index(newIndex, offsetBy: 2)\n\
    \        newString += String(alphabet[newIndex2])\n    }\n    return newString\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(encrypt(s: \"hi\") == \"lm\")\nassert(encrypt(s:\
    \ \"asdfghjkl\") == \"ewhjklnop\")\nassert(encrypt(s: \"gf\") == \"kj\")\nassert(encrypt(s:\
    \ \"et\") == \"ix\")\nassert(encrypt(s: \"faewfawefaewg\") == \"jeiajeaijeiak\"\
    )\nassert(encrypt(s: \"hellomyfriend\") == \"lippsqcjvmirh\")\nassert(encrypt(s:\
    \ \"dxzdlmnilfuhmilufhlihufnmlimnufhlimnufhfucufh\") == \"hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl\"\
    )\nassert(encrypt(s: \"a\") == \"e\")"
  status: Exception
  stderr: 'Swift/StringIndexValidation.swift:120: Fatal error: String index is out
    of bounds

    Current stack trace:

    0    libswiftCore.so                    0x00002b3a3b9adc80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b3a3b6a4561 <unavailable> + 1434977

    2    libswiftCore.so                    0x00002b3a3b6a4286 <unavailable> + 1434246

    3    libswiftCore.so                    0x00002b3a3b6a413c <unavailable> + 1433916

    4    libswiftCore.so                    0x00002b3a3b6a3bb0 _assertionFailure(_:_:file:line:flags:)
    + 251

    5    libswiftCore.so                    0x00002b3a3b7d7ec2 <unavailable> + 2694850

    6    libswiftCore.so                    0x00002b3a3b790660 String.subscript.getter
    + 34

    7    tmpipvi2s6h                        0x0000557baaa9b4f5 <unavailable> + 9461

    8    tmpipvi2s6h                        0x0000557baaa9ac0d <unavailable> + 7181

    9    libc.so.6                          0x00002b3a3bb99460 __libc_start_main +
    245

    10   tmpipvi2s6h                        0x0000557baaa9a4f9 <unavailable> + 5369

    '
  stdout: ''
  timestamp: 1660028310
- exit_code: 0
  program: "\n/// Create a function encrypt that takes a string as an argument and\n\
    /// returns a string encrypted with the alphabet being rotated. \n/// The alphabet\
    \ should be rotated in a manner such that the letters \n/// shift down by two\
    \ multiplied to two places.\n/// For example:\n/// >>> encrypt(s: \"hi\")\n///\
    \ \"lm\"\n/// >>> encrypt(s: \"asdfghjkl\")\n/// \"ewhjklnop\"\n/// >>> encrypt(s:\
    \ \"gf\")\n/// \"kj\"\n/// >>> encrypt(s: \"et\")\n/// \"ix\"\nfunc encrypt(s:\
    \ String) -> String {\n    var encrypted = String()\n    for letter in s {\n \
    \       if let uppercaseLetter = UnicodeScalar(String(letter)) {\n           \
    \ var char = Character(UnicodeScalar(uppercaseLetter.value + (2 * 2))!)\n    \
    \        if !char.isLetter {\n                char = Character(UnicodeScalar(uppercaseLetter.value\
    \ - (26 - (2 * 2)))!)\n            }\n            encrypted.append(char)\n   \
    \     }\n    }\n    return encrypted\n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(encrypt(s: \"hi\") == \"lm\")\nassert(encrypt(s: \"asdfghjkl\") == \"ewhjklnop\"\
    )\nassert(encrypt(s: \"gf\") == \"kj\")\nassert(encrypt(s: \"et\") == \"ix\")\n\
    assert(encrypt(s: \"faewfawefaewg\") == \"jeiajeaijeiak\")\nassert(encrypt(s:\
    \ \"hellomyfriend\") == \"lippsqcjvmirh\")\nassert(encrypt(s: \"dxzdlmnilfuhmilufhlihufnmlimnufhlimnufhfucufh\"\
    ) == \"hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl\")\nassert(encrypt(s: \"\
    a\") == \"e\")"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660028310
- exit_code: -4
  program: "\n/// Create a function encrypt that takes a string as an argument and\n\
    /// returns a string encrypted with the alphabet being rotated. \n/// The alphabet\
    \ should be rotated in a manner such that the letters \n/// shift down by two\
    \ multiplied to two places.\n/// For example:\n/// >>> encrypt(s: \"hi\")\n///\
    \ \"lm\"\n/// >>> encrypt(s: \"asdfghjkl\")\n/// \"ewhjklnop\"\n/// >>> encrypt(s:\
    \ \"gf\")\n/// \"kj\"\n/// >>> encrypt(s: \"et\")\n/// \"ix\"\nfunc encrypt(s:\
    \ String) -> String {\n    \n    // TODO: Implement this function\n    return\
    \ \"\";\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n \
    \   if left.count != right.count {\n        return false\n    }\n    for (l, r)\
    \ in zip(left, right) {\n        if l != r {\n            return false\n     \
    \   }\n    }\n    return true\n}\n            \nassert(encrypt(s: \"hi\") == \"\
    lm\")\nassert(encrypt(s: \"asdfghjkl\") == \"ewhjklnop\")\nassert(encrypt(s: \"\
    gf\") == \"kj\")\nassert(encrypt(s: \"et\") == \"ix\")\nassert(encrypt(s: \"faewfawefaewg\"\
    ) == \"jeiajeaijeiak\")\nassert(encrypt(s: \"hellomyfriend\") == \"lippsqcjvmirh\"\
    )\nassert(encrypt(s: \"dxzdlmnilfuhmilufhlihufnmlimnufhlimnufhfucufh\") == \"\
    hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl\")\nassert(encrypt(s: \"a\") ==\
    \ \"e\")"
  status: Exception
  stderr: 'tmp6j8cp9_m/tmp6j8cp9_m.swift:34: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b9bedb39c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b9bed830b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b9bed830988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b9bed82f7b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmp6j8cp9_m                        0x00005640af2d4307 <unavailable> + 4871

    5    libc.so.6                          0x00002b9bedd25460 __libc_start_main +
    245

    6    tmp6j8cp9_m                        0x00005640af2d3f49 <unavailable> + 3913

    '
  stdout: ''
  timestamp: 1660028310
- exit_code: 1
  program: "\n/// Create a function encrypt that takes a string as an argument and\n\
    /// returns a string encrypted with the alphabet being rotated. \n/// The alphabet\
    \ should be rotated in a manner such that the letters \n/// shift down by two\
    \ multiplied to two places.\n/// For example:\n/// >>> encrypt(s: \"hi\")\n///\
    \ \"lm\"\n/// >>> encrypt(s: \"asdfghjkl\")\n/// \"ewhjklnop\"\n/// >>> encrypt(s:\
    \ \"gf\")\n/// \"kj\"\n/// >>> encrypt(s: \"et\")\n/// \"ix\"\nfunc encrypt(s:\
    \ String) -> String {\n    var encryptedStr = \"\"\n    for character in s {\n\
    \        encryptedStr += findNextTwoCharacters(character: character)\n    }\n\
    \    return encryptedStr\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(encrypt(s:\
    \ \"hi\") == \"lm\")\nassert(encrypt(s: \"asdfghjkl\") == \"ewhjklnop\")\nassert(encrypt(s:\
    \ \"gf\") == \"kj\")\nassert(encrypt(s: \"et\") == \"ix\")\nassert(encrypt(s:\
    \ \"faewfawefaewg\") == \"jeiajeaijeiak\")\nassert(encrypt(s: \"hellomyfriend\"\
    ) == \"lippsqcjvmirh\")\nassert(encrypt(s: \"dxzdlmnilfuhmilufhlihufnmlimnufhlimnufhfucufh\"\
    ) == \"hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl\")\nassert(encrypt(s: \"\
    a\") == \"e\")"
  status: SyntaxError
  stderr: "/tmp/tmp2zb8x91w.swift:18:25: error: cannot find 'findNextTwoCharacters'\
    \ in scope\n        encryptedStr += findNextTwoCharacters(character: character)\n\
    \                        ^~~~~~~~~~~~~~~~~~~~~\n"
  stdout: ''
  timestamp: 1660028310
- exit_code: -4
  program: "\n/// Create a function encrypt that takes a string as an argument and\n\
    /// returns a string encrypted with the alphabet being rotated. \n/// The alphabet\
    \ should be rotated in a manner such that the letters \n/// shift down by two\
    \ multiplied to two places.\n/// For example:\n/// >>> encrypt(s: \"hi\")\n///\
    \ \"lm\"\n/// >>> encrypt(s: \"asdfghjkl\")\n/// \"ewhjklnop\"\n/// >>> encrypt(s:\
    \ \"gf\")\n/// \"kj\"\n/// >>> encrypt(s: \"et\")\n/// \"ix\"\nfunc encrypt(s:\
    \ String) -> String {\n    // YOUR CODE HERE\n    return s\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(encrypt(s: \"hi\") == \"lm\")\nassert(encrypt(s: \"asdfghjkl\"\
    ) == \"ewhjklnop\")\nassert(encrypt(s: \"gf\") == \"kj\")\nassert(encrypt(s: \"\
    et\") == \"ix\")\nassert(encrypt(s: \"faewfawefaewg\") == \"jeiajeaijeiak\")\n\
    assert(encrypt(s: \"hellomyfriend\") == \"lippsqcjvmirh\")\nassert(encrypt(s:\
    \ \"dxzdlmnilfuhmilufhlihufnmlimnufhlimnufhfucufh\") == \"hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl\"\
    )\nassert(encrypt(s: \"a\") == \"e\")"
  status: Exception
  stderr: 'tmp6pk0r6ne/tmp6pk0r6ne.swift:33: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b30b602fc80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b30b5d26b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b30b5d26988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b30b5d257b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmp6pk0r6ne                        0x000056419186f307 <unavailable> + 4871

    5    libc.so.6                          0x00002b30b621b460 __libc_start_main +
    245

    6    tmp6pk0r6ne                        0x000056419186ef49 <unavailable> + 3913

    '
  stdout: ''
  timestamp: 1660028310
- exit_code: 0
  program: "\n/// Create a function encrypt that takes a string as an argument and\n\
    /// returns a string encrypted with the alphabet being rotated. \n/// The alphabet\
    \ should be rotated in a manner such that the letters \n/// shift down by two\
    \ multiplied to two places.\n/// For example:\n/// >>> encrypt(s: \"hi\")\n///\
    \ \"lm\"\n/// >>> encrypt(s: \"asdfghjkl\")\n/// \"ewhjklnop\"\n/// >>> encrypt(s:\
    \ \"gf\")\n/// \"kj\"\n/// >>> encrypt(s: \"et\")\n/// \"ix\"\nfunc encrypt(s:\
    \ String) -> String {\n  var str = String()\n  for char in s {\n    let unicode\
    \ = char.unicodeScalars.first!.value\n    let unicodeString = String(unicode)\n\
    \    if unicode >= 97 && unicode <= 122 {\n      if unicode + 4 > 122 {\n    \
    \    str.append(Character(UnicodeScalar(unicode - 22)!))\n      } else {\n   \
    \     str.append(Character(UnicodeScalar(unicode + 4)!))\n      }\n    } else\
    \ if unicode >= 65 && unicode <= 90 {\n      if unicode + 4 > 90 {\n        str.append(Character(UnicodeScalar(unicode\
    \ - 22)!))\n      } else {\n        str.append(Character(UnicodeScalar(unicode\
    \ + 4)!))\n      }\n    } else {\n      str.append(char)\n    }\n  }\n  return\
    \ str\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n   \
    \ if left.count != right.count {\n        return false\n    }\n    for (l, r)\
    \ in zip(left, right) {\n        if l != r {\n            return false\n     \
    \   }\n    }\n    return true\n}\n            \nassert(encrypt(s: \"hi\") == \"\
    lm\")\nassert(encrypt(s: \"asdfghjkl\") == \"ewhjklnop\")\nassert(encrypt(s: \"\
    gf\") == \"kj\")\nassert(encrypt(s: \"et\") == \"ix\")\nassert(encrypt(s: \"faewfawefaewg\"\
    ) == \"jeiajeaijeiak\")\nassert(encrypt(s: \"hellomyfriend\") == \"lippsqcjvmirh\"\
    )\nassert(encrypt(s: \"dxzdlmnilfuhmilufhlihufnmlimnufhlimnufhfucufh\") == \"\
    hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl\")\nassert(encrypt(s: \"a\") ==\
    \ \"e\")"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660028310
- exit_code: -4
  program: "\n/// Create a function encrypt that takes a string as an argument and\n\
    /// returns a string encrypted with the alphabet being rotated. \n/// The alphabet\
    \ should be rotated in a manner such that the letters \n/// shift down by two\
    \ multiplied to two places.\n/// For example:\n/// >>> encrypt(s: \"hi\")\n///\
    \ \"lm\"\n/// >>> encrypt(s: \"asdfghjkl\")\n/// \"ewhjklnop\"\n/// >>> encrypt(s:\
    \ \"gf\")\n/// \"kj\"\n/// >>> encrypt(s: \"et\")\n/// \"ix\"\nfunc encrypt(s:\
    \ String) -> String {\n    var alphabet = Array(\"abcdefghijklmnopqrstuvwxyz\"\
    )\n    var encryptedAlphabet = [Character]()\n    for i in 0..<alphabet.count\
    \ {\n        if i < alphabet.count - 2 {\n            encryptedAlphabet.append(alphabet[i\
    \ + 2])\n        } else {\n            encryptedAlphabet.append(alphabet[i - alphabet.count\
    \ + 2])\n        }\n    }\n    var encryptedString = \"\"\n    for letter in s\
    \ {\n        encryptedString += String(encryptedAlphabet[alphabet.firstIndex(of:\
    \ letter)!])\n    }\n    return encryptedString\n}\n\n\nfunc ==(left: [(Int, Int)],\
    \ right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n       \
    \ return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r\
    \ {\n            return false\n        }\n    }\n    return true\n}\n        \
    \    \nassert(encrypt(s: \"hi\") == \"lm\")\nassert(encrypt(s: \"asdfghjkl\")\
    \ == \"ewhjklnop\")\nassert(encrypt(s: \"gf\") == \"kj\")\nassert(encrypt(s: \"\
    et\") == \"ix\")\nassert(encrypt(s: \"faewfawefaewg\") == \"jeiajeaijeiak\")\n\
    assert(encrypt(s: \"hellomyfriend\") == \"lippsqcjvmirh\")\nassert(encrypt(s:\
    \ \"dxzdlmnilfuhmilufhlihufnmlimnufhlimnufhfucufh\") == \"hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl\"\
    )\nassert(encrypt(s: \"a\") == \"e\")"
  status: Exception
  stderr: 'tmphebg6k1h/tmphebg6k1h.swift:45: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b1bb405fc80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b1bb3d56b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b1bb3d56988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b1bb3d557b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmphebg6k1h                        0x00005572eb828997 <unavailable> + 6551

    5    libc.so.6                          0x00002b1bb424b460 __libc_start_main +
    245

    6    tmphebg6k1h                        0x00005572eb8285d9 <unavailable> + 5593

    '
  stdout: ''
  timestamp: 1660028310
- exit_code: 1
  program: "\n/// Create a function encrypt that takes a string as an argument and\n\
    /// returns a string encrypted with the alphabet being rotated. \n/// The alphabet\
    \ should be rotated in a manner such that the letters \n/// shift down by two\
    \ multiplied to two places.\n/// For example:\n/// >>> encrypt(s: \"hi\")\n///\
    \ \"lm\"\n/// >>> encrypt(s: \"asdfghjkl\")\n/// \"ewhjklnop\"\n/// >>> encrypt(s:\
    \ \"gf\")\n/// \"kj\"\n/// >>> encrypt(s: \"et\")\n/// \"ix\"\nfunc encrypt(s:\
    \ String) -> String {\n    let alphabet = \"abcdefghijklmnopqrstuvwxyz\"\n   \
    \ var encryptedString = \"\"\n    for letter in s {\n        if let index = alphabet.firstIndex(of:\
    \ letter) {\n            let newIndex = index + 2\n            if newIndex < alphabet.count\
    \ {\n                encryptedString.append(alphabet[newIndex])\n            }\
    \ else {\n                encryptedString.append(alphabet[newIndex % alphabet.count])\n\
    \            }\n        }\n    }\n    return encryptedString\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(encrypt(s: \"hi\") == \"lm\")\nassert(encrypt(s: \"asdfghjkl\"\
    ) == \"ewhjklnop\")\nassert(encrypt(s: \"gf\") == \"kj\")\nassert(encrypt(s: \"\
    et\") == \"ix\")\nassert(encrypt(s: \"faewfawefaewg\") == \"jeiajeaijeiak\")\n\
    assert(encrypt(s: \"hellomyfriend\") == \"lippsqcjvmirh\")\nassert(encrypt(s:\
    \ \"dxzdlmnilfuhmilufhlihufnmlimnufhlimnufhfucufh\") == \"hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl\"\
    )\nassert(encrypt(s: \"a\") == \"e\")"
  status: SyntaxError
  stderr: "/tmp/tmpxo9gvy_h.swift:20:28: error: cannot convert value of type 'String.Index'\
    \ to expected argument type 'Int'\n            let newIndex = index + 2\n    \
    \                       ^\n"
  stdout: ''
  timestamp: 1660028310
- exit_code: 1
  program: "\n/// Create a function encrypt that takes a string as an argument and\n\
    /// returns a string encrypted with the alphabet being rotated. \n/// The alphabet\
    \ should be rotated in a manner such that the letters \n/// shift down by two\
    \ multiplied to two places.\n/// For example:\n/// >>> encrypt(s: \"hi\")\n///\
    \ \"lm\"\n/// >>> encrypt(s: \"asdfghjkl\")\n/// \"ewhjklnop\"\n/// >>> encrypt(s:\
    \ \"gf\")\n/// \"kj\"\n/// >>> encrypt(s: \"et\")\n/// \"ix\"\nfunc encrypt(s:\
    \ String) -> String {\n    \n    var newString = \"\"\n    let characters = Array(s)\n\
    \    var charactersCount = characters.count\n    \n    while charactersCount >\
    \ 0 {\n        var newIndex = alphabet_position(char: characters[charactersCount\
    \ - 1]) + 2\n        while newIndex > 25 {\n            newIndex -= 26\n     \
    \   }\n        newString.append(alphabet[newIndex])\n        charactersCount -=\
    \ 1\n    }\n    \n    return newString\n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(encrypt(s: \"hi\") == \"lm\")\nassert(encrypt(s: \"asdfghjkl\") == \"ewhjklnop\"\
    )\nassert(encrypt(s: \"gf\") == \"kj\")\nassert(encrypt(s: \"et\") == \"ix\")\n\
    assert(encrypt(s: \"faewfawefaewg\") == \"jeiajeaijeiak\")\nassert(encrypt(s:\
    \ \"hellomyfriend\") == \"lippsqcjvmirh\")\nassert(encrypt(s: \"dxzdlmnilfuhmilufhlihufnmlimnufhlimnufhfucufh\"\
    ) == \"hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl\")\nassert(encrypt(s: \"\
    a\") == \"e\")"
  status: SyntaxError
  stderr: "/tmp/tmpxh1w36ak.swift:22:24: error: cannot find 'alphabet_position' in\
    \ scope\n        var newIndex = alphabet_position(char: characters[charactersCount\
    \ - 1]) + 2\n                       ^~~~~~~~~~~~~~~~~\n/tmp/tmpxh1w36ak.swift:26:26:\
    \ error: cannot find 'alphabet' in scope\n        newString.append(alphabet[newIndex])\n\
    \                         ^~~~~~~~\n"
  stdout: ''
  timestamp: 1660028310
- exit_code: 1
  program: "\n/// Create a function encrypt that takes a string as an argument and\n\
    /// returns a string encrypted with the alphabet being rotated. \n/// The alphabet\
    \ should be rotated in a manner such that the letters \n/// shift down by two\
    \ multiplied to two places.\n/// For example:\n/// >>> encrypt(s: \"hi\")\n///\
    \ \"lm\"\n/// >>> encrypt(s: \"asdfghjkl\")\n/// \"ewhjklnop\"\n/// >>> encrypt(s:\
    \ \"gf\")\n/// \"kj\"\n/// >>> encrypt(s: \"et\")\n/// \"ix\"\nfunc encrypt(s:\
    \ String) -> String {\n    var string = \"\"\n    for char in s {\n        var\
    \ character = char\n        if let index = alphabet.firstIndex(of: char) {\n \
    \           if (index >= 18) {\n                character = alphabet[index - 18]\n\
    \            } else {\n                character = alphabet[index + 18]\n    \
    \        }\n        }\n        string.append(character)\n    }\n    return string\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(encrypt(s: \"hi\") == \"lm\")\nassert(encrypt(s:\
    \ \"asdfghjkl\") == \"ewhjklnop\")\nassert(encrypt(s: \"gf\") == \"kj\")\nassert(encrypt(s:\
    \ \"et\") == \"ix\")\nassert(encrypt(s: \"faewfawefaewg\") == \"jeiajeaijeiak\"\
    )\nassert(encrypt(s: \"hellomyfriend\") == \"lippsqcjvmirh\")\nassert(encrypt(s:\
    \ \"dxzdlmnilfuhmilufhlihufnmlimnufhlimnufhfucufh\") == \"hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl\"\
    )\nassert(encrypt(s: \"a\") == \"e\")"
  status: SyntaxError
  stderr: "/tmp/tmp6xukikvh.swift:19:24: error: cannot find 'alphabet' in scope\n\
    \        if let index = alphabet.firstIndex(of: char) {\n                    \
    \   ^~~~~~~~\n/tmp/tmp6xukikvh.swift:21:29: error: cannot find 'alphabet' in scope\n\
    \                character = alphabet[index - 18]\n                          \
    \  ^~~~~~~~\n/tmp/tmp6xukikvh.swift:23:29: error: cannot find 'alphabet' in scope\n\
    \                character = alphabet[index + 18]\n                          \
    \  ^~~~~~~~\n"
  stdout: ''
  timestamp: 1660028310
- exit_code: 1
  program: "\n/// Create a function encrypt that takes a string as an argument and\n\
    /// returns a string encrypted with the alphabet being rotated. \n/// The alphabet\
    \ should be rotated in a manner such that the letters \n/// shift down by two\
    \ multiplied to two places.\n/// For example:\n/// >>> encrypt(s: \"hi\")\n///\
    \ \"lm\"\n/// >>> encrypt(s: \"asdfghjkl\")\n/// \"ewhjklnop\"\n/// >>> encrypt(s:\
    \ \"gf\")\n/// \"kj\"\n/// >>> encrypt(s: \"et\")\n/// \"ix\"\nfunc encrypt(s:\
    \ String) -> String {\n    var result = String()\n    for letter in s {\n    \
    \    let value = letter.asciiValue!\n        let value2 = letter.asciiValue! +\
    \ 2 * 2\n        if value < 90 && value > 65 {\n            result.append(Character(UnicodeScalar(value2)!))\n\
    \        } else if value < 122 && value > 97 {\n            result.append(Character(UnicodeScalar(value2)!))\n\
    \        } else {\n            result.append(letter)\n        }\n    }\n    return\
    \ result\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n\
    \    if left.count != right.count {\n        return false\n    }\n    for (l,\
    \ r) in zip(left, right) {\n        if l != r {\n            return false\n  \
    \      }\n    }\n    return true\n}\n            \nassert(encrypt(s: \"hi\") ==\
    \ \"lm\")\nassert(encrypt(s: \"asdfghjkl\") == \"ewhjklnop\")\nassert(encrypt(s:\
    \ \"gf\") == \"kj\")\nassert(encrypt(s: \"et\") == \"ix\")\nassert(encrypt(s:\
    \ \"faewfawefaewg\") == \"jeiajeaijeiak\")\nassert(encrypt(s: \"hellomyfriend\"\
    ) == \"lippsqcjvmirh\")\nassert(encrypt(s: \"dxzdlmnilfuhmilufhlihufnmlimnufhlimnufhfucufh\"\
    ) == \"hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl\")\nassert(encrypt(s: \"\
    a\") == \"e\")"
  status: SyntaxError
  stderr: "/tmp/tmpsykakijp.swift:21:58: error: cannot force unwrap value of non-optional\
    \ type 'UnicodeScalar' (aka 'Unicode.Scalar')\n            result.append(Character(UnicodeScalar(value2)!))\n\
    \                                    ~~~~~~~~~~~~~~~~~~~~~^\n                \
    \                                         \n/tmp/tmpsykakijp.swift:23:58: error:\
    \ cannot force unwrap value of non-optional type 'UnicodeScalar' (aka 'Unicode.Scalar')\n\
    \            result.append(Character(UnicodeScalar(value2)!))\n              \
    \                      ~~~~~~~~~~~~~~~~~~~~~^\n                              \
    \                           \n"
  stdout: ''
  timestamp: 1660028310
- exit_code: -4
  program: "\n/// Create a function encrypt that takes a string as an argument and\n\
    /// returns a string encrypted with the alphabet being rotated. \n/// The alphabet\
    \ should be rotated in a manner such that the letters \n/// shift down by two\
    \ multiplied to two places.\n/// For example:\n/// >>> encrypt(s: \"hi\")\n///\
    \ \"lm\"\n/// >>> encrypt(s: \"asdfghjkl\")\n/// \"ewhjklnop\"\n/// >>> encrypt(s:\
    \ \"gf\")\n/// \"kj\"\n/// >>> encrypt(s: \"et\")\n/// \"ix\"\nfunc encrypt(s:\
    \ String) -> String {\n    let alphabet = \"abcdefghijklmnopqrstuvwxyz\"\n   \
    \ let length = s.count\n    var cipherText = \"\"\n    for i in 0..<length {\n\
    \        let index = alphabet.index(alphabet.startIndex, offsetBy: (alphabet.firstIndex(of:\
    \ s[s.index(s.startIndex, offsetBy: i)])!.encodedOffset + (i * 2)) % 26)\n   \
    \     cipherText.append(alphabet[index])\n    }\n    return cipherText\n}\n\n\n\
    func ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(encrypt(s: \"hi\") == \"lm\")\nassert(encrypt(s:\
    \ \"asdfghjkl\") == \"ewhjklnop\")\nassert(encrypt(s: \"gf\") == \"kj\")\nassert(encrypt(s:\
    \ \"et\") == \"ix\")\nassert(encrypt(s: \"faewfawefaewg\") == \"jeiajeaijeiak\"\
    )\nassert(encrypt(s: \"hellomyfriend\") == \"lippsqcjvmirh\")\nassert(encrypt(s:\
    \ \"dxzdlmnilfuhmilufhlihufnmlimnufhlimnufhfucufh\") == \"hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl\"\
    )\nassert(encrypt(s: \"a\") == \"e\")"
  status: Exception
  stderr: 'tmpmqwwk5h9/tmpmqwwk5h9.swift:39: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002aab32be3c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002aab328dab6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002aab328da988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002aab328d97b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpmqwwk5h9                        0x0000561c6fc9b7c7 <unavailable> + 6087

    5    libc.so.6                          0x00002aab32dcf460 __libc_start_main +
    245

    6    tmpmqwwk5h9                        0x0000561c6fc9b409 <unavailable> + 5129

    '
  stdout: ''
  timestamp: 1660028310
- exit_code: 1
  program: "\n/// Create a function encrypt that takes a string as an argument and\n\
    /// returns a string encrypted with the alphabet being rotated. \n/// The alphabet\
    \ should be rotated in a manner such that the letters \n/// shift down by two\
    \ multiplied to two places.\n/// For example:\n/// >>> encrypt(s: \"hi\")\n///\
    \ \"lm\"\n/// >>> encrypt(s: \"asdfghjkl\")\n/// \"ewhjklnop\"\n/// >>> encrypt(s:\
    \ \"gf\")\n/// \"kj\"\n/// >>> encrypt(s: \"et\")\n/// \"ix\"\nfunc encrypt(s:\
    \ String) -> String {\n    var result = \"\"\n    for char in s {\n        result\
    \ += String(char).unicodeScalars.map { unicodeScalar in\n            let a = unicodeScalar.value\n\
    \            let b = a + 2 * 2\n            return UnicodeScalar(Int(b)) ?? unicodeScalar\n\
    \        }\n    }\n    return result\n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(encrypt(s: \"hi\") == \"lm\")\nassert(encrypt(s: \"asdfghjkl\") == \"ewhjklnop\"\
    )\nassert(encrypt(s: \"gf\") == \"kj\")\nassert(encrypt(s: \"et\") == \"ix\")\n\
    assert(encrypt(s: \"faewfawefaewg\") == \"jeiajeaijeiak\")\nassert(encrypt(s:\
    \ \"hellomyfriend\") == \"lippsqcjvmirh\")\nassert(encrypt(s: \"dxzdlmnilfuhmilufhlihufnmlimnufhlimnufhfucufh\"\
    ) == \"hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl\")\nassert(encrypt(s: \"\
    a\") == \"e\")"
  status: SyntaxError
  stderr: "/tmp/tmpveu479fu.swift:21:42: error: cannot convert return expression of\
    \ type 'UnicodeScalar' (aka 'Unicode.Scalar') to return type 'String.Element'\
    \ (aka 'Character')\n            return UnicodeScalar(Int(b)) ?? unicodeScalar\n\
    \                   ~~~~~~~~~~~~~~~~~~~~~~^~~~~~~~~~~~~~~~\n"
  stdout: ''
  timestamp: 1660028311
- exit_code: -4
  program: "\n/// Create a function encrypt that takes a string as an argument and\n\
    /// returns a string encrypted with the alphabet being rotated. \n/// The alphabet\
    \ should be rotated in a manner such that the letters \n/// shift down by two\
    \ multiplied to two places.\n/// For example:\n/// >>> encrypt(s: \"hi\")\n///\
    \ \"lm\"\n/// >>> encrypt(s: \"asdfghjkl\")\n/// \"ewhjklnop\"\n/// >>> encrypt(s:\
    \ \"gf\")\n/// \"kj\"\n/// >>> encrypt(s: \"et\")\n/// \"ix\"\nfunc encrypt(s:\
    \ String) -> String {\n    var encryptedString = \"\"\n    for character in s\
    \ {\n        let unicode = character.unicodeScalars.first!.value\n        let\
    \ rotatedUnicode = ((((unicode - 97) + 2) % 26) + 97)\n        let rotatedCharacter\
    \ = Character(UnicodeScalar(rotatedUnicode)!)\n        encryptedString.append(rotatedCharacter)\n\
    \    }\n    return encryptedString\n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(encrypt(s: \"hi\") == \"lm\")\nassert(encrypt(s: \"asdfghjkl\") == \"ewhjklnop\"\
    )\nassert(encrypt(s: \"gf\") == \"kj\")\nassert(encrypt(s: \"et\") == \"ix\")\n\
    assert(encrypt(s: \"faewfawefaewg\") == \"jeiajeaijeiak\")\nassert(encrypt(s:\
    \ \"hellomyfriend\") == \"lippsqcjvmirh\")\nassert(encrypt(s: \"dxzdlmnilfuhmilufhlihufnmlimnufhlimnufhfucufh\"\
    ) == \"hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl\")\nassert(encrypt(s: \"\
    a\") == \"e\")"
  status: Exception
  stderr: 'tmpw9d3aohn/tmpw9d3aohn.swift:39: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b4f3e238c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b4f3df2fb6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b4f3df2f988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b4f3df2e7b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpw9d3aohn                        0x000056303cacc737 <unavailable> + 5943

    5    libc.so.6                          0x00002b4f3e424460 __libc_start_main +
    245

    6    tmpw9d3aohn                        0x000056303cacc379 <unavailable> + 4985

    '
  stdout: ''
  timestamp: 1660028310
- exit_code: 0
  program: "\n/// Create a function encrypt that takes a string as an argument and\n\
    /// returns a string encrypted with the alphabet being rotated. \n/// The alphabet\
    \ should be rotated in a manner such that the letters \n/// shift down by two\
    \ multiplied to two places.\n/// For example:\n/// >>> encrypt(s: \"hi\")\n///\
    \ \"lm\"\n/// >>> encrypt(s: \"asdfghjkl\")\n/// \"ewhjklnop\"\n/// >>> encrypt(s:\
    \ \"gf\")\n/// \"kj\"\n/// >>> encrypt(s: \"et\")\n/// \"ix\"\nfunc encrypt(s:\
    \ String) -> String {\n    let alphabets = Array(\"abcdefghijklmnopqrstuvwxyz\"\
    )\n    var encryptedString = \"\"\n    for c in s {\n        if let index = alphabets.firstIndex(of:\
    \ c) {\n            encryptedString.append(alphabets[(index + 2 * 2) % alphabets.count])\n\
    \        }\n    }\n    return encryptedString\n}\n\n\nfunc ==(left: [(Int, Int)],\
    \ right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n       \
    \ return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r\
    \ {\n            return false\n        }\n    }\n    return true\n}\n        \
    \    \nassert(encrypt(s: \"hi\") == \"lm\")\nassert(encrypt(s: \"asdfghjkl\")\
    \ == \"ewhjklnop\")\nassert(encrypt(s: \"gf\") == \"kj\")\nassert(encrypt(s: \"\
    et\") == \"ix\")\nassert(encrypt(s: \"faewfawefaewg\") == \"jeiajeaijeiak\")\n\
    assert(encrypt(s: \"hellomyfriend\") == \"lippsqcjvmirh\")\nassert(encrypt(s:\
    \ \"dxzdlmnilfuhmilufhlihufnmlimnufhlimnufhfucufh\") == \"hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl\"\
    )\nassert(encrypt(s: \"a\") == \"e\")"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660028310
- exit_code: 1
  program: "\n/// Create a function encrypt that takes a string as an argument and\n\
    /// returns a string encrypted with the alphabet being rotated. \n/// The alphabet\
    \ should be rotated in a manner such that the letters \n/// shift down by two\
    \ multiplied to two places.\n/// For example:\n/// >>> encrypt(s: \"hi\")\n///\
    \ \"lm\"\n/// >>> encrypt(s: \"asdfghjkl\")\n/// \"ewhjklnop\"\n/// >>> encrypt(s:\
    \ \"gf\")\n/// \"kj\"\n/// >>> encrypt(s: \"et\")\n/// \"ix\"\nfunc encrypt(s:\
    \ String) -> String {\n    var cArr = Array(s)\n    for i in 0..<cArr.count {\n\
    \        cArr[i] = shiftN(c: cArr[i], n: 2)\n    }\n    return String(cArr)\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(encrypt(s: \"hi\") == \"lm\")\nassert(encrypt(s:\
    \ \"asdfghjkl\") == \"ewhjklnop\")\nassert(encrypt(s: \"gf\") == \"kj\")\nassert(encrypt(s:\
    \ \"et\") == \"ix\")\nassert(encrypt(s: \"faewfawefaewg\") == \"jeiajeaijeiak\"\
    )\nassert(encrypt(s: \"hellomyfriend\") == \"lippsqcjvmirh\")\nassert(encrypt(s:\
    \ \"dxzdlmnilfuhmilufhlihufnmlimnufhlimnufhfucufh\") == \"hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl\"\
    )\nassert(encrypt(s: \"a\") == \"e\")"
  status: SyntaxError
  stderr: "/tmp/tmpzqxsnq5m.swift:18:19: error: cannot find 'shiftN' in scope\n  \
    \      cArr[i] = shiftN(c: cArr[i], n: 2)\n                  ^~~~~~\n"
  stdout: ''
  timestamp: 1660028310
- exit_code: -4
  program: "\n/// Create a function encrypt that takes a string as an argument and\n\
    /// returns a string encrypted with the alphabet being rotated. \n/// The alphabet\
    \ should be rotated in a manner such that the letters \n/// shift down by two\
    \ multiplied to two places.\n/// For example:\n/// >>> encrypt(s: \"hi\")\n///\
    \ \"lm\"\n/// >>> encrypt(s: \"asdfghjkl\")\n/// \"ewhjklnop\"\n/// >>> encrypt(s:\
    \ \"gf\")\n/// \"kj\"\n/// >>> encrypt(s: \"et\")\n/// \"ix\"\nfunc encrypt(s:\
    \ String) -> String {\n    var str = \"\"\n    for x in s {\n        let char\
    \ = Character(\"\\(x)\")\n        let unicode = char.unicodeScalars.first!.value\n\
    \        let encrypted = unicode + (2 * 2)\n        let result = Character(UnicodeScalar(encrypted)!)\n\
    \        str += \"\\(result)\"\n    }\n    return str\n}\n\n\nfunc ==(left: [(Int,\
    \ Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n\
    \        return false\n    }\n    for (l, r) in zip(left, right) {\n        if\
    \ l != r {\n            return false\n        }\n    }\n    return true\n}\n \
    \           \nassert(encrypt(s: \"hi\") == \"lm\")\nassert(encrypt(s: \"asdfghjkl\"\
    ) == \"ewhjklnop\")\nassert(encrypt(s: \"gf\") == \"kj\")\nassert(encrypt(s: \"\
    et\") == \"ix\")\nassert(encrypt(s: \"faewfawefaewg\") == \"jeiajeaijeiak\")\n\
    assert(encrypt(s: \"hellomyfriend\") == \"lippsqcjvmirh\")\nassert(encrypt(s:\
    \ \"dxzdlmnilfuhmilufhlihufnmlimnufhlimnufhfucufh\") == \"hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl\"\
    )\nassert(encrypt(s: \"a\") == \"e\")"
  status: Exception
  stderr: 'tmp1q5s9dbv/tmp1q5s9dbv.swift:44: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b238311bc80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b2382e12b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b2382e12988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b2382e117b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmp1q5s9dbv                        0x000056097a8a6ece <unavailable> + 7886

    5    libc.so.6                          0x00002b2383307460 __libc_start_main +
    245

    6    tmp1q5s9dbv                        0x000056097a8a66c9 <unavailable> + 5833

    '
  stdout: ''
  timestamp: 1660028310
- exit_code: -4
  program: "\n/// Create a function encrypt that takes a string as an argument and\n\
    /// returns a string encrypted with the alphabet being rotated. \n/// The alphabet\
    \ should be rotated in a manner such that the letters \n/// shift down by two\
    \ multiplied to two places.\n/// For example:\n/// >>> encrypt(s: \"hi\")\n///\
    \ \"lm\"\n/// >>> encrypt(s: \"asdfghjkl\")\n/// \"ewhjklnop\"\n/// >>> encrypt(s:\
    \ \"gf\")\n/// \"kj\"\n/// >>> encrypt(s: \"et\")\n/// \"ix\"\nfunc encrypt(s:\
    \ String) -> String {\n    // implement code here\n    return \"\"\n}\n\n\nfunc\
    \ ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count !=\
    \ right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(encrypt(s: \"hi\") == \"lm\")\nassert(encrypt(s:\
    \ \"asdfghjkl\") == \"ewhjklnop\")\nassert(encrypt(s: \"gf\") == \"kj\")\nassert(encrypt(s:\
    \ \"et\") == \"ix\")\nassert(encrypt(s: \"faewfawefaewg\") == \"jeiajeaijeiak\"\
    )\nassert(encrypt(s: \"hellomyfriend\") == \"lippsqcjvmirh\")\nassert(encrypt(s:\
    \ \"dxzdlmnilfuhmilufhlihufnmlimnufhlimnufhfucufh\") == \"hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl\"\
    )\nassert(encrypt(s: \"a\") == \"e\")"
  status: Exception
  stderr: 'tmpizno4x74/tmpizno4x74.swift:33: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002ac96a22dc80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002ac969f24b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002ac969f24988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002ac969f237b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpizno4x74                        0x0000558e1e1af307 <unavailable> + 4871

    5    libc.so.6                          0x00002ac96a419460 __libc_start_main +
    245

    6    tmpizno4x74                        0x0000558e1e1aef49 <unavailable> + 3913

    '
  stdout: ''
  timestamp: 1660028310
- exit_code: -4
  program: "\n/// Create a function encrypt that takes a string as an argument and\n\
    /// returns a string encrypted with the alphabet being rotated. \n/// The alphabet\
    \ should be rotated in a manner such that the letters \n/// shift down by two\
    \ multiplied to two places.\n/// For example:\n/// >>> encrypt(s: \"hi\")\n///\
    \ \"lm\"\n/// >>> encrypt(s: \"asdfghjkl\")\n/// \"ewhjklnop\"\n/// >>> encrypt(s:\
    \ \"gf\")\n/// \"kj\"\n/// >>> encrypt(s: \"et\")\n/// \"ix\"\nfunc encrypt(s:\
    \ String) -> String {\n    return \"\"\n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(encrypt(s: \"hi\") == \"lm\")\nassert(encrypt(s: \"asdfghjkl\") == \"ewhjklnop\"\
    )\nassert(encrypt(s: \"gf\") == \"kj\")\nassert(encrypt(s: \"et\") == \"ix\")\n\
    assert(encrypt(s: \"faewfawefaewg\") == \"jeiajeaijeiak\")\nassert(encrypt(s:\
    \ \"hellomyfriend\") == \"lippsqcjvmirh\")\nassert(encrypt(s: \"dxzdlmnilfuhmilufhlihufnmlimnufhlimnufhfucufh\"\
    ) == \"hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl\")\nassert(encrypt(s: \"\
    a\") == \"e\")"
  status: Exception
  stderr: 'tmpxsqxg1op/tmpxsqxg1op.swift:32: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b607b4a6c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b607b19db6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b607b19d988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b607b19c7b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpxsqxg1op                        0x00005575dd252307 <unavailable> + 4871

    5    libc.so.6                          0x00002b607b692460 __libc_start_main +
    245

    6    tmpxsqxg1op                        0x00005575dd251f49 <unavailable> + 3913

    '
  stdout: ''
  timestamp: 1660028310
- exit_code: 1
  program: "\n/// Create a function encrypt that takes a string as an argument and\n\
    /// returns a string encrypted with the alphabet being rotated. \n/// The alphabet\
    \ should be rotated in a manner such that the letters \n/// shift down by two\
    \ multiplied to two places.\n/// For example:\n/// >>> encrypt(s: \"hi\")\n///\
    \ \"lm\"\n/// >>> encrypt(s: \"asdfghjkl\")\n/// \"ewhjklnop\"\n/// >>> encrypt(s:\
    \ \"gf\")\n/// \"kj\"\n/// >>> encrypt(s: \"et\")\n/// \"ix\"\nfunc encrypt(s:\
    \ String) -> String {\n  var result = \"\"\n  for c in s {\n    if let idx = alphabet.firstIndex(of:\
    \ c) {\n      let shift = (idx + 1) % alphabet.count\n      result.append(alphabet[shift])\n\
    \    }\n  }\n  return result\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int,\
    \ Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n\
    \    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n          \
    \  return false\n        }\n    }\n    return true\n}\n            \nassert(encrypt(s:\
    \ \"hi\") == \"lm\")\nassert(encrypt(s: \"asdfghjkl\") == \"ewhjklnop\")\nassert(encrypt(s:\
    \ \"gf\") == \"kj\")\nassert(encrypt(s: \"et\") == \"ix\")\nassert(encrypt(s:\
    \ \"faewfawefaewg\") == \"jeiajeaijeiak\")\nassert(encrypt(s: \"hellomyfriend\"\
    ) == \"lippsqcjvmirh\")\nassert(encrypt(s: \"dxzdlmnilfuhmilufhlihufnmlimnufhlimnufhfucufh\"\
    ) == \"hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl\")\nassert(encrypt(s: \"\
    a\") == \"e\")"
  status: SyntaxError
  stderr: "/tmp/tmp7k2_0aio.swift:18:18: error: cannot find 'alphabet' in scope\n\
    \    if let idx = alphabet.firstIndex(of: c) {\n                 ^~~~~~~~\n/tmp/tmp7k2_0aio.swift:19:31:\
    \ error: cannot find 'alphabet' in scope\n      let shift = (idx + 1) % alphabet.count\n\
    \                              ^~~~~~~~\n/tmp/tmp7k2_0aio.swift:20:21: error:\
    \ cannot find 'alphabet' in scope\n      result.append(alphabet[shift])\n    \
    \                ^~~~~~~~\n"
  stdout: ''
  timestamp: 1660028310
- exit_code: 1
  program: "\n/// Create a function encrypt that takes a string as an argument and\n\
    /// returns a string encrypted with the alphabet being rotated. \n/// The alphabet\
    \ should be rotated in a manner such that the letters \n/// shift down by two\
    \ multiplied to two places.\n/// For example:\n/// >>> encrypt(s: \"hi\")\n///\
    \ \"lm\"\n/// >>> encrypt(s: \"asdfghjkl\")\n/// \"ewhjklnop\"\n/// >>> encrypt(s:\
    \ \"gf\")\n/// \"kj\"\n/// >>> encrypt(s: \"et\")\n/// \"ix\"\nfunc encrypt(s:\
    \ String) -> String {\n    var encryptedString = \"\"\n    for character in s\
    \ {\n        let unicodeScalar = character.unicodeScalars.first!.value\n     \
    \   if unicodeScalar == 105 {\n            encryptedString.append(\"m\")\n   \
    \     } else if unicodeScalar == 106 {\n            encryptedString.append(\"\
    n\")\n        } else if unicodeScalar == 107 {\n            encryptedString.append(\"\
    o\")\n        } else if unicodeScalar == 108 {\n            encryptedString.append(\"\
    p\")\n        } else if unicodeScalar == 109 {\n            encryptedString.append(\"\
    q\")\n        } else if unicodeScalar == 110 {\n            encryptedString.append(\"\
    r\")\n        } else if unicodeScalar == 111 {\n            encryptedString.append(\"\
    s\")\n        } else if unicodeScalar == 112 {\n            encryptedString.append(\"\
    t\")\n        } else if unicodeScalar == 113 {\n            encryptedString.append(\"\
    u\")\n        } else if unicodeScalar == 114 {\n            encryptedString.append(\"\
    v\")\n        } else if unicodeScalar == 115 {\n            encryptedString.append(\"\
    w\")\n        } else if unicodeScalar == 116 {\n            encryptedString.append(\"\
    x\")\n        } else if unicodeScalar == 117 {\n            encryptedString.append(\"\
    y\")\n        } else if unicodeScalar == 118 {\n            encryptedString.append(\"\
    z\")\n        } else if unicodeScalar == 119 {\n            encryptedString.append(\"\
    a\")\n        } else if unicodeScalar == 120 {\n            encryptedString.append(\"\
    b\")\n        } else if unicodeScalar == 121 {\n            encryptedString.append(\"\
    c\")\n        } else if unicodeScalar == 122 {\n            encryptedString.append(\"\
    d\")\n        } else if unicodeScalar == 97 {\n            encryptedString.append(\"\
    e\")\n        } else if unicodeScalar == 98 {\n            encryptedString.append(\"\
    f\")\n        } else if unicodeScalar == 99 {\n            encryptedString.append(\"\
    g\")\n        } else if unicodeScalar == 100 {\n            encryptedString.\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(encrypt(s: \"hi\") == \"lm\")\nassert(encrypt(s:\
    \ \"asdfghjkl\") == \"ewhjklnop\")\nassert(encrypt(s: \"gf\") == \"kj\")\nassert(encrypt(s:\
    \ \"et\") == \"ix\")\nassert(encrypt(s: \"faewfawefaewg\") == \"jeiajeaijeiak\"\
    )\nassert(encrypt(s: \"hellomyfriend\") == \"lippsqcjvmirh\")\nassert(encrypt(s:\
    \ \"dxzdlmnilfuhmilufhlihufnmlimnufhlimnufhfucufh\") == \"hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl\"\
    )\nassert(encrypt(s: \"a\") == \"e\")"
  status: SyntaxError
  stderr: "/tmp/tmptq7a6xpf.swift:62:28: error: expected member name following '.'\n\
    \            encryptedString.\n                           ^\n/tmp/tmptq7a6xpf.swift:85:31:\
    \ error: expected '}' at end of brace statement\nassert(encrypt(s: \"a\") == \"\
    e\")\n                              ^\n/tmp/tmptq7a6xpf.swift:17:24: note: to\
    \ match this opening '{'\n    for character in s {\n                       ^\n\
    /tmp/tmptq7a6xpf.swift:85:31: error: expected '}' at end of brace statement\n\
    assert(encrypt(s: \"a\") == \"e\")\n                              ^\n/tmp/tmptq7a6xpf.swift:15:35:\
    \ note: to match this opening '{'\nfunc encrypt(s: String) -> String {\n     \
    \                             ^\n/tmp/tmptq7a6xpf.swift:66:6: error: operator\
    \ functions can only be declared at global or in type scope\nfunc ==(left: [(Int,\
    \ Int)], right: [(Int, Int)]) -> Bool {\n     ^\n"
  stdout: ''
  timestamp: 1660028310
- exit_code: 1
  program: "\n/// Create a function encrypt that takes a string as an argument and\n\
    /// returns a string encrypted with the alphabet being rotated. \n/// The alphabet\
    \ should be rotated in a manner such that the letters \n/// shift down by two\
    \ multiplied to two places.\n/// For example:\n/// >>> encrypt(s: \"hi\")\n///\
    \ \"lm\"\n/// >>> encrypt(s: \"asdfghjkl\")\n/// \"ewhjklnop\"\n/// >>> encrypt(s:\
    \ \"gf\")\n/// \"kj\"\n/// >>> encrypt(s: \"et\")\n/// \"ix\"\nfunc encrypt(s:\
    \ String) -> String {\n    let convertedString = String(s.utf8.map {\n       \
    \ $0 + ($0 >= 97 && $0 <= 122 ? 4 : 0)\n    })\n    var result = \"\"\n    for\
    \ i in convertedString {\n        if result.last == \"x\" {\n            result.removeLast()\n\
    \            result.append(\"a\")\n        } else if result.last == \"y\" {\n\
    \            result.removeLast()\n            result.append(\"b\")\n        }\
    \ else {\n            result.append(i)\n        }\n    }\n    return result\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(encrypt(s: \"hi\") == \"lm\")\nassert(encrypt(s:\
    \ \"asdfghjkl\") == \"ewhjklnop\")\nassert(encrypt(s: \"gf\") == \"kj\")\nassert(encrypt(s:\
    \ \"et\") == \"ix\")\nassert(encrypt(s: \"faewfawefaewg\") == \"jeiajeaijeiak\"\
    )\nassert(encrypt(s: \"hellomyfriend\") == \"lippsqcjvmirh\")\nassert(encrypt(s:\
    \ \"dxzdlmnilfuhmilufhlihufnmlimnufhlimnufhfucufh\") == \"hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl\"\
    )\nassert(encrypt(s: \"a\") == \"e\")"
  status: SyntaxError
  stderr: "/tmp/tmpmx7866m9.swift:16:34: error: missing argument label 'cString:'\
    \ in call\n    let convertedString = String(s.utf8.map {\n                   \
    \              ^\n                                 cString: \n"
  stdout: ''
  timestamp: 1660028310
- exit_code: 0
  program: "\n/// Create a function encrypt that takes a string as an argument and\n\
    /// returns a string encrypted with the alphabet being rotated. \n/// The alphabet\
    \ should be rotated in a manner such that the letters \n/// shift down by two\
    \ multiplied to two places.\n/// For example:\n/// >>> encrypt(s: \"hi\")\n///\
    \ \"lm\"\n/// >>> encrypt(s: \"asdfghjkl\")\n/// \"ewhjklnop\"\n/// >>> encrypt(s:\
    \ \"gf\")\n/// \"kj\"\n/// >>> encrypt(s: \"et\")\n/// \"ix\"\nfunc encrypt(s:\
    \ String) -> String {\n    var result = \"\"\n    let alphabet = [\"a\", \"b\"\
    , \"c\", \"d\", \"e\", \"f\", \"g\", \"h\", \"i\", \"j\", \"k\", \"l\", \"m\"\
    , \"n\", \"o\", \"p\", \"q\", \"r\", \"s\", \"t\", \"u\", \"v\", \"w\", \"x\"\
    , \"y\", \"z\"]\n    for char in s {\n        if let value = alphabet.firstIndex(of:\
    \ String(char)) {\n            if (value + 2 * 2) >= alphabet.count {\n      \
    \          result += alphabet[(value + 2 * 2) - alphabet.count]\n            }\
    \ else {\n                result += alphabet[value + 2 * 2]\n            }\n \
    \       }\n    }\n    return result\n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(encrypt(s: \"hi\") == \"lm\")\nassert(encrypt(s: \"asdfghjkl\") == \"ewhjklnop\"\
    )\nassert(encrypt(s: \"gf\") == \"kj\")\nassert(encrypt(s: \"et\") == \"ix\")\n\
    assert(encrypt(s: \"faewfawefaewg\") == \"jeiajeaijeiak\")\nassert(encrypt(s:\
    \ \"hellomyfriend\") == \"lippsqcjvmirh\")\nassert(encrypt(s: \"dxzdlmnilfuhmilufhlihufnmlimnufhlimnufhfucufh\"\
    ) == \"hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl\")\nassert(encrypt(s: \"\
    a\") == \"e\")"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660028310
- exit_code: -4
  program: "\n/// Create a function encrypt that takes a string as an argument and\n\
    /// returns a string encrypted with the alphabet being rotated. \n/// The alphabet\
    \ should be rotated in a manner such that the letters \n/// shift down by two\
    \ multiplied to two places.\n/// For example:\n/// >>> encrypt(s: \"hi\")\n///\
    \ \"lm\"\n/// >>> encrypt(s: \"asdfghjkl\")\n/// \"ewhjklnop\"\n/// >>> encrypt(s:\
    \ \"gf\")\n/// \"kj\"\n/// >>> encrypt(s: \"et\")\n/// \"ix\"\nfunc encrypt(s:\
    \ String) -> String {\n    return \"\"\n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(encrypt(s: \"hi\") == \"lm\")\nassert(encrypt(s: \"asdfghjkl\") == \"ewhjklnop\"\
    )\nassert(encrypt(s: \"gf\") == \"kj\")\nassert(encrypt(s: \"et\") == \"ix\")\n\
    assert(encrypt(s: \"faewfawefaewg\") == \"jeiajeaijeiak\")\nassert(encrypt(s:\
    \ \"hellomyfriend\") == \"lippsqcjvmirh\")\nassert(encrypt(s: \"dxzdlmnilfuhmilufhlihufnmlimnufhlimnufhfucufh\"\
    ) == \"hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl\")\nassert(encrypt(s: \"\
    a\") == \"e\")"
  status: Exception
  stderr: 'tmpxsqxg1op/tmpxsqxg1op.swift:32: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b607b4a6c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b607b19db6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b607b19d988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b607b19c7b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpxsqxg1op                        0x00005575dd252307 <unavailable> + 4871

    5    libc.so.6                          0x00002b607b692460 __libc_start_main +
    245

    6    tmpxsqxg1op                        0x00005575dd251f49 <unavailable> + 3913

    '
  stdout: ''
  timestamp: 1660028310
- exit_code: -4
  program: "\n/// Create a function encrypt that takes a string as an argument and\n\
    /// returns a string encrypted with the alphabet being rotated. \n/// The alphabet\
    \ should be rotated in a manner such that the letters \n/// shift down by two\
    \ multiplied to two places.\n/// For example:\n/// >>> encrypt(s: \"hi\")\n///\
    \ \"lm\"\n/// >>> encrypt(s: \"asdfghjkl\")\n/// \"ewhjklnop\"\n/// >>> encrypt(s:\
    \ \"gf\")\n/// \"kj\"\n/// >>> encrypt(s: \"et\")\n/// \"ix\"\nfunc encrypt(s:\
    \ String) -> String {\n    // your code here\n    return \"\"\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(encrypt(s: \"hi\") == \"lm\")\nassert(encrypt(s: \"asdfghjkl\"\
    ) == \"ewhjklnop\")\nassert(encrypt(s: \"gf\") == \"kj\")\nassert(encrypt(s: \"\
    et\") == \"ix\")\nassert(encrypt(s: \"faewfawefaewg\") == \"jeiajeaijeiak\")\n\
    assert(encrypt(s: \"hellomyfriend\") == \"lippsqcjvmirh\")\nassert(encrypt(s:\
    \ \"dxzdlmnilfuhmilufhlihufnmlimnufhlimnufhfucufh\") == \"hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl\"\
    )\nassert(encrypt(s: \"a\") == \"e\")"
  status: Exception
  stderr: 'tmprx16si5i/tmprx16si5i.swift:33: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b5d5168dc80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b5d51384b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b5d51384988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b5d513837b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmprx16si5i                        0x00005591330b6307 <unavailable> + 4871

    5    libc.so.6                          0x00002b5d51879460 __libc_start_main +
    245

    6    tmprx16si5i                        0x00005591330b5f49 <unavailable> + 3913

    '
  stdout: ''
  timestamp: 1660028310
- exit_code: -4
  program: "\n/// Create a function encrypt that takes a string as an argument and\n\
    /// returns a string encrypted with the alphabet being rotated. \n/// The alphabet\
    \ should be rotated in a manner such that the letters \n/// shift down by two\
    \ multiplied to two places.\n/// For example:\n/// >>> encrypt(s: \"hi\")\n///\
    \ \"lm\"\n/// >>> encrypt(s: \"asdfghjkl\")\n/// \"ewhjklnop\"\n/// >>> encrypt(s:\
    \ \"gf\")\n/// \"kj\"\n/// >>> encrypt(s: \"et\")\n/// \"ix\"\nfunc encrypt(s:\
    \ String) -> String {\n    let alphabet = \"abcdefghijklmnopqrstuvwxyz\"\n   \
    \ var encrptedString = \"\"\n    for (index, letter) in s.enumerated() {\n   \
    \     guard let letterIndex = alphabet.firstIndex(of: letter) else { continue\
    \ }\n        let index = letterIndex.encodedOffset + 4\n        let letter2 =\
    \ alphabet[alphabet.index(alphabet.startIndex, offsetBy: index)]\n        encrptedString.append(letter2)\n\
    \    }\n    return encrptedString\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int,\
    \ Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n\
    \    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n          \
    \  return false\n        }\n    }\n    return true\n}\n            \nassert(encrypt(s:\
    \ \"hi\") == \"lm\")\nassert(encrypt(s: \"asdfghjkl\") == \"ewhjklnop\")\nassert(encrypt(s:\
    \ \"gf\") == \"kj\")\nassert(encrypt(s: \"et\") == \"ix\")\nassert(encrypt(s:\
    \ \"faewfawefaewg\") == \"jeiajeaijeiak\")\nassert(encrypt(s: \"hellomyfriend\"\
    ) == \"lippsqcjvmirh\")\nassert(encrypt(s: \"dxzdlmnilfuhmilufhlihufnmlimnufhlimnufhfucufh\"\
    ) == \"hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl\")\nassert(encrypt(s: \"\
    a\") == \"e\")"
  status: Exception
  stderr: 'Swift/StringIndexValidation.swift:120: Fatal error: String index is out
    of bounds

    Current stack trace:

    0    libswiftCore.so                    0x00002b00fd2ccc80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b00fcfc3561 <unavailable> + 1434977

    2    libswiftCore.so                    0x00002b00fcfc3286 <unavailable> + 1434246

    3    libswiftCore.so                    0x00002b00fcfc313c <unavailable> + 1433916

    4    libswiftCore.so                    0x00002b00fcfc2bb0 _assertionFailure(_:_:file:line:flags:)
    + 251

    5    libswiftCore.so                    0x00002b00fd0f6ec2 <unavailable> + 2694850

    6    libswiftCore.so                    0x00002b00fd0af660 String.subscript.getter
    + 34

    7    tmpq3bee0yj                        0x000055a52743e357 <unavailable> + 9047

    8    tmpq3bee0yj                        0x000055a52743db9d <unavailable> + 7069

    9    libc.so.6                          0x00002b00fd4b8460 __libc_start_main +
    245

    10   tmpq3bee0yj                        0x000055a52743d489 <unavailable> + 5257

    '
  stdout: ''
  timestamp: 1660028310
- exit_code: -4
  program: "\n/// Create a function encrypt that takes a string as an argument and\n\
    /// returns a string encrypted with the alphabet being rotated. \n/// The alphabet\
    \ should be rotated in a manner such that the letters \n/// shift down by two\
    \ multiplied to two places.\n/// For example:\n/// >>> encrypt(s: \"hi\")\n///\
    \ \"lm\"\n/// >>> encrypt(s: \"asdfghjkl\")\n/// \"ewhjklnop\"\n/// >>> encrypt(s:\
    \ \"gf\")\n/// \"kj\"\n/// >>> encrypt(s: \"et\")\n/// \"ix\"\nfunc encrypt(s:\
    \ String) -> String {\n    // YOUR CODE HERE\n    return \"\"\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(encrypt(s: \"hi\") == \"lm\")\nassert(encrypt(s: \"asdfghjkl\"\
    ) == \"ewhjklnop\")\nassert(encrypt(s: \"gf\") == \"kj\")\nassert(encrypt(s: \"\
    et\") == \"ix\")\nassert(encrypt(s: \"faewfawefaewg\") == \"jeiajeaijeiak\")\n\
    assert(encrypt(s: \"hellomyfriend\") == \"lippsqcjvmirh\")\nassert(encrypt(s:\
    \ \"dxzdlmnilfuhmilufhlihufnmlimnufhlimnufhfucufh\") == \"hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl\"\
    )\nassert(encrypt(s: \"a\") == \"e\")"
  status: Exception
  stderr: 'tmpz32kggmd/tmpz32kggmd.swift:33: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002afdf288bc80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002afdf2582b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002afdf2582988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002afdf25817b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpz32kggmd                        0x0000556e54bd3307 <unavailable> + 4871

    5    libc.so.6                          0x00002afdf2a77460 __libc_start_main +
    245

    6    tmpz32kggmd                        0x0000556e54bd2f49 <unavailable> + 3913

    '
  stdout: ''
  timestamp: 1660028310
- exit_code: 1
  program: "\n/// Create a function encrypt that takes a string as an argument and\n\
    /// returns a string encrypted with the alphabet being rotated. \n/// The alphabet\
    \ should be rotated in a manner such that the letters \n/// shift down by two\
    \ multiplied to two places.\n/// For example:\n/// >>> encrypt(s: \"hi\")\n///\
    \ \"lm\"\n/// >>> encrypt(s: \"asdfghjkl\")\n/// \"ewhjklnop\"\n/// >>> encrypt(s:\
    \ \"gf\")\n/// \"kj\"\n/// >>> encrypt(s: \"et\")\n/// \"ix\"\nfunc encrypt(s:\
    \ String) -> String {\n    // write your code here\n}\n\n\nfunc ==(left: [(Int,\
    \ Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n\
    \        return false\n    }\n    for (l, r) in zip(left, right) {\n        if\
    \ l != r {\n            return false\n        }\n    }\n    return true\n}\n \
    \           \nassert(encrypt(s: \"hi\") == \"lm\")\nassert(encrypt(s: \"asdfghjkl\"\
    ) == \"ewhjklnop\")\nassert(encrypt(s: \"gf\") == \"kj\")\nassert(encrypt(s: \"\
    et\") == \"ix\")\nassert(encrypt(s: \"faewfawefaewg\") == \"jeiajeaijeiak\")\n\
    assert(encrypt(s: \"hellomyfriend\") == \"lippsqcjvmirh\")\nassert(encrypt(s:\
    \ \"dxzdlmnilfuhmilufhlihufnmlimnufhlimnufhfucufh\") == \"hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl\"\
    )\nassert(encrypt(s: \"a\") == \"e\")"
  status: SyntaxError
  stderr: '/tmp/tmphxi8ighw.swift:17:1: error: missing return in global function expected
    to return ''String''

    }

    ^

    '
  stdout: ''
  timestamp: 1660028310
- exit_code: -4
  program: "\n/// Create a function encrypt that takes a string as an argument and\n\
    /// returns a string encrypted with the alphabet being rotated. \n/// The alphabet\
    \ should be rotated in a manner such that the letters \n/// shift down by two\
    \ multiplied to two places.\n/// For example:\n/// >>> encrypt(s: \"hi\")\n///\
    \ \"lm\"\n/// >>> encrypt(s: \"asdfghjkl\")\n/// \"ewhjklnop\"\n/// >>> encrypt(s:\
    \ \"gf\")\n/// \"kj\"\n/// >>> encrypt(s: \"et\")\n/// \"ix\"\nfunc encrypt(s:\
    \ String) -> String {\n    var s2 = \"\"\n    for c in s {\n        if let x =\
    \ c.unicodeScalars.first {\n            let unicode = x.value\n            if\
    \ unicode < 110 {\n                s2 += String(UnicodeScalar(unicode + 7)!)\n\
    \            } else {\n                s2 += String(UnicodeScalar(unicode - 7)!)\n\
    \            }\n        }\n    }\n    return s2\n}\n\n\nfunc ==(left: [(Int, Int)],\
    \ right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n       \
    \ return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r\
    \ {\n            return false\n        }\n    }\n    return true\n}\n        \
    \    \nassert(encrypt(s: \"hi\") == \"lm\")\nassert(encrypt(s: \"asdfghjkl\")\
    \ == \"ewhjklnop\")\nassert(encrypt(s: \"gf\") == \"kj\")\nassert(encrypt(s: \"\
    et\") == \"ix\")\nassert(encrypt(s: \"faewfawefaewg\") == \"jeiajeaijeiak\")\n\
    assert(encrypt(s: \"hellomyfriend\") == \"lippsqcjvmirh\")\nassert(encrypt(s:\
    \ \"dxzdlmnilfuhmilufhlihufnmlimnufhlimnufhfucufh\") == \"hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl\"\
    )\nassert(encrypt(s: \"a\") == \"e\")"
  status: Exception
  stderr: 'tmpcbap_n1i/tmpcbap_n1i.swift:43: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002ba6d9b46c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002ba6d983db6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002ba6d983d988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002ba6d983c7b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpcbap_n1i                        0x00005558128ef737 <unavailable> + 5943

    5    libc.so.6                          0x00002ba6d9d32460 __libc_start_main +
    245

    6    tmpcbap_n1i                        0x00005558128ef379 <unavailable> + 4985

    '
  stdout: ''
  timestamp: 1660028310
- exit_code: -4
  program: "\n/// Create a function encrypt that takes a string as an argument and\n\
    /// returns a string encrypted with the alphabet being rotated. \n/// The alphabet\
    \ should be rotated in a manner such that the letters \n/// shift down by two\
    \ multiplied to two places.\n/// For example:\n/// >>> encrypt(s: \"hi\")\n///\
    \ \"lm\"\n/// >>> encrypt(s: \"asdfghjkl\")\n/// \"ewhjklnop\"\n/// >>> encrypt(s:\
    \ \"gf\")\n/// \"kj\"\n/// >>> encrypt(s: \"et\")\n/// \"ix\"\nfunc encrypt(s:\
    \ String) -> String {\n    \n    let alphabet = Array(\"abcdefghijklmnopqrstuvwxyz\"\
    )\n    var encryptedString = \"\"\n    \n    for letter in s {\n        if let\
    \ position = alphabet.firstIndex(of: letter) {\n            encryptedString.append(alphabet[(position\
    \ + 2) % 26])\n        }\n    }\n    \n    return encryptedString\n}\n\n\nfunc\
    \ ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count !=\
    \ right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(encrypt(s: \"hi\") == \"lm\")\nassert(encrypt(s:\
    \ \"asdfghjkl\") == \"ewhjklnop\")\nassert(encrypt(s: \"gf\") == \"kj\")\nassert(encrypt(s:\
    \ \"et\") == \"ix\")\nassert(encrypt(s: \"faewfawefaewg\") == \"jeiajeaijeiak\"\
    )\nassert(encrypt(s: \"hellomyfriend\") == \"lippsqcjvmirh\")\nassert(encrypt(s:\
    \ \"dxzdlmnilfuhmilufhlihufnmlimnufhlimnufhfucufh\") == \"hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl\"\
    )\nassert(encrypt(s: \"a\") == \"e\")"
  status: Exception
  stderr: 'tmp4rthbhhm/tmp4rthbhhm.swift:42: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b4b2fe54c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b4b2fb4bb6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b4b2fb4b988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b4b2fb4a7b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmp4rthbhhm                        0x000055d30b667707 <unavailable> + 5895

    5    libc.so.6                          0x00002b4b30040460 __libc_start_main +
    245

    6    tmp4rthbhhm                        0x000055d30b667349 <unavailable> + 4937

    '
  stdout: ''
  timestamp: 1660028310
- exit_code: 1
  program: "\n/// Create a function encrypt that takes a string as an argument and\n\
    /// returns a string encrypted with the alphabet being rotated. \n/// The alphabet\
    \ should be rotated in a manner such that the letters \n/// shift down by two\
    \ multiplied to two places.\n/// For example:\n/// >>> encrypt(s: \"hi\")\n///\
    \ \"lm\"\n/// >>> encrypt(s: \"asdfghjkl\")\n/// \"ewhjklnop\"\n/// >>> encrypt(s:\
    \ \"gf\")\n/// \"kj\"\n/// >>> encrypt(s: \"et\")\n/// \"ix\"\nfunc encrypt(s:\
    \ String) -> String {\n    return s.enumerated().map { $0.element.shift(by: $0.offset\
    \ * 2) }.joined()\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) ->\
    \ Bool {\n    if left.count != right.count {\n        return false\n    }\n  \
    \  for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(encrypt(s: \"hi\"\
    ) == \"lm\")\nassert(encrypt(s: \"asdfghjkl\") == \"ewhjklnop\")\nassert(encrypt(s:\
    \ \"gf\") == \"kj\")\nassert(encrypt(s: \"et\") == \"ix\")\nassert(encrypt(s:\
    \ \"faewfawefaewg\") == \"jeiajeaijeiak\")\nassert(encrypt(s: \"hellomyfriend\"\
    ) == \"lippsqcjvmirh\")\nassert(encrypt(s: \"dxzdlmnilfuhmilufhlihufnmlimnufhlimnufhfucufh\"\
    ) == \"hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl\")\nassert(encrypt(s: \"\
    a\") == \"e\")"
  status: SyntaxError
  stderr: "/tmp/tmpc2m9qjxt.swift:16:44: error: value of type 'String.Element' (aka\
    \ 'Character') has no member 'shift'\n    return s.enumerated().map { $0.element.shift(by:\
    \ $0.offset * 2) }.joined()\n                                ~~~~~~~~~~ ^~~~~\n"
  stdout: ''
  timestamp: 1660028310
- exit_code: 0
  program: "\n/// Create a function encrypt that takes a string as an argument and\n\
    /// returns a string encrypted with the alphabet being rotated. \n/// The alphabet\
    \ should be rotated in a manner such that the letters \n/// shift down by two\
    \ multiplied to two places.\n/// For example:\n/// >>> encrypt(s: \"hi\")\n///\
    \ \"lm\"\n/// >>> encrypt(s: \"asdfghjkl\")\n/// \"ewhjklnop\"\n/// >>> encrypt(s:\
    \ \"gf\")\n/// \"kj\"\n/// >>> encrypt(s: \"et\")\n/// \"ix\"\nfunc encrypt(s:\
    \ String) -> String {\n    var result = \"\"\n    let lowerCased = s.lowercased()\n\
    \    let alphabet = [\"a\", \"b\", \"c\", \"d\", \"e\", \"f\", \"g\", \"h\", \"\
    i\", \"j\", \"k\", \"l\", \"m\", \"n\", \"o\", \"p\", \"q\", \"r\", \"s\", \"\
    t\", \"u\", \"v\", \"w\", \"x\", \"y\", \"z\"]\n    for c in lowerCased {\n  \
    \      var index = alphabet.firstIndex(of: String(c))!\n        if index + 2 *\
    \ 2 < alphabet.count {\n            index += 2 * 2\n        } else {\n       \
    \     index -= alphabet.count - 2 * 2\n        }\n        result += alphabet[index]\n\
    \    }\n    return result\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(encrypt(s:\
    \ \"hi\") == \"lm\")\nassert(encrypt(s: \"asdfghjkl\") == \"ewhjklnop\")\nassert(encrypt(s:\
    \ \"gf\") == \"kj\")\nassert(encrypt(s: \"et\") == \"ix\")\nassert(encrypt(s:\
    \ \"faewfawefaewg\") == \"jeiajeaijeiak\")\nassert(encrypt(s: \"hellomyfriend\"\
    ) == \"lippsqcjvmirh\")\nassert(encrypt(s: \"dxzdlmnilfuhmilufhlihufnmlimnufhlimnufhfucufh\"\
    ) == \"hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl\")\nassert(encrypt(s: \"\
    a\") == \"e\")"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660028311
- exit_code: 1
  program: "\n/// Create a function encrypt that takes a string as an argument and\n\
    /// returns a string encrypted with the alphabet being rotated. \n/// The alphabet\
    \ should be rotated in a manner such that the letters \n/// shift down by two\
    \ multiplied to two places.\n/// For example:\n/// >>> encrypt(s: \"hi\")\n///\
    \ \"lm\"\n/// >>> encrypt(s: \"asdfghjkl\")\n/// \"ewhjklnop\"\n/// >>> encrypt(s:\
    \ \"gf\")\n/// \"kj\"\n/// >>> encrypt(s: \"et\")\n/// \"ix\"\nfunc encrypt(s:\
    \ String) -> String {\n    var shiftString = \"\"\n    for c in s {\n        shiftString.append(shiftChar(char:\
    \ c, shift: 2))\n    }\n    return shiftString\n}\n\n\nfunc ==(left: [(Int, Int)],\
    \ right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n       \
    \ return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r\
    \ {\n            return false\n        }\n    }\n    return true\n}\n        \
    \    \nassert(encrypt(s: \"hi\") == \"lm\")\nassert(encrypt(s: \"asdfghjkl\")\
    \ == \"ewhjklnop\")\nassert(encrypt(s: \"gf\") == \"kj\")\nassert(encrypt(s: \"\
    et\") == \"ix\")\nassert(encrypt(s: \"faewfawefaewg\") == \"jeiajeaijeiak\")\n\
    assert(encrypt(s: \"hellomyfriend\") == \"lippsqcjvmirh\")\nassert(encrypt(s:\
    \ \"dxzdlmnilfuhmilufhlihufnmlimnufhlimnufhfucufh\") == \"hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl\"\
    )\nassert(encrypt(s: \"a\") == \"e\")"
  status: SyntaxError
  stderr: "/tmp/tmp5_5_p114.swift:18:28: error: cannot find 'shiftChar' in scope\n\
    \        shiftString.append(shiftChar(char: c, shift: 2))\n                  \
    \         ^~~~~~~~~\n"
  stdout: ''
  timestamp: 1660028310
- exit_code: 1
  program: "\n/// Create a function encrypt that takes a string as an argument and\n\
    /// returns a string encrypted with the alphabet being rotated. \n/// The alphabet\
    \ should be rotated in a manner such that the letters \n/// shift down by two\
    \ multiplied to two places.\n/// For example:\n/// >>> encrypt(s: \"hi\")\n///\
    \ \"lm\"\n/// >>> encrypt(s: \"asdfghjkl\")\n/// \"ewhjklnop\"\n/// >>> encrypt(s:\
    \ \"gf\")\n/// \"kj\"\n/// >>> encrypt(s: \"et\")\n/// \"ix\"\nfunc encrypt(s:\
    \ String) -> String {\n    var result = \"\"\n    for char in s {\n        if\
    \ let ascii = char.asciiValue {\n            var newCode = ascii + (UInt8(4))\n\
    \            if newCode > 122 {\n                newCode = newCode - 26\n    \
    \        }\n            result.append(Character(UnicodeScalar(newCode)!))\n  \
    \      }\n    }\n    return result\n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(encrypt(s: \"hi\") == \"lm\")\nassert(encrypt(s: \"asdfghjkl\") == \"ewhjklnop\"\
    )\nassert(encrypt(s: \"gf\") == \"kj\")\nassert(encrypt(s: \"et\") == \"ix\")\n\
    assert(encrypt(s: \"faewfawefaewg\") == \"jeiajeaijeiak\")\nassert(encrypt(s:\
    \ \"hellomyfriend\") == \"lippsqcjvmirh\")\nassert(encrypt(s: \"dxzdlmnilfuhmilufhlihufnmlimnufhlimnufhfucufh\"\
    ) == \"hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl\")\nassert(encrypt(s: \"\
    a\") == \"e\")"
  status: SyntaxError
  stderr: "/tmp/tmpuo0u4qhq.swift:23:59: error: cannot force unwrap value of non-optional\
    \ type 'UnicodeScalar' (aka 'Unicode.Scalar')\n            result.append(Character(UnicodeScalar(newCode)!))\n\
    \                                    ~~~~~~~~~~~~~~~~~~~~~~^\n               \
    \                                           \n"
  stdout: ''
  timestamp: 1660028310
- exit_code: -4
  program: "\n/// Create a function encrypt that takes a string as an argument and\n\
    /// returns a string encrypted with the alphabet being rotated. \n/// The alphabet\
    \ should be rotated in a manner such that the letters \n/// shift down by two\
    \ multiplied to two places.\n/// For example:\n/// >>> encrypt(s: \"hi\")\n///\
    \ \"lm\"\n/// >>> encrypt(s: \"asdfghjkl\")\n/// \"ewhjklnop\"\n/// >>> encrypt(s:\
    \ \"gf\")\n/// \"kj\"\n/// >>> encrypt(s: \"et\")\n/// \"ix\"\nfunc encrypt(s:\
    \ String) -> String {\n    // implement the encryption method here...\n    var\
    \ plainText = s.lowercased()\n    var cipherText = \"\"\n    var alphabet = \"\
    abcdefghijklmnopqrstuvwxyz\"\n    let shiftBy = 4\n    // move the first 4 characters\
    \ to the end of the string\n    alphabet.append(contentsOf: alphabet.prefix(shiftBy))\n\
    \    alphabet.removeFirst(shiftBy)\n    for letter in plainText {\n        var\
    \ foundIndex = alphabet.firstIndex(of: letter)\n        if foundIndex != nil {\n\
    \            cipherText.append(alphabet[alphabet.index(after: foundIndex!)])\n\
    \        } else {\n            cipherText.append(letter)\n        }\n    }\n \
    \   return cipherText\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(encrypt(s:\
    \ \"hi\") == \"lm\")\nassert(encrypt(s: \"asdfghjkl\") == \"ewhjklnop\")\nassert(encrypt(s:\
    \ \"gf\") == \"kj\")\nassert(encrypt(s: \"et\") == \"ix\")\nassert(encrypt(s:\
    \ \"faewfawefaewg\") == \"jeiajeaijeiak\")\nassert(encrypt(s: \"hellomyfriend\"\
    ) == \"lippsqcjvmirh\")\nassert(encrypt(s: \"dxzdlmnilfuhmilufhlihufnmlimnufhlimnufhfucufh\"\
    ) == \"hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl\")\nassert(encrypt(s: \"\
    a\") == \"e\")"
  status: Exception
  stderr: 'tmp8tjtye39/tmp8tjtye39.swift:48: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b5b36bf0c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b5b368e7b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b5b368e7988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b5b368e67b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmp8tjtye39                        0x0000559981c12827 <unavailable> + 6183

    5    libc.so.6                          0x00002b5b36ddc460 __libc_start_main +
    245

    6    tmp8tjtye39                        0x0000559981c12469 <unavailable> + 5225

    '
  stdout: ''
  timestamp: 1660028311
- exit_code: -4
  program: "\n/// Create a function encrypt that takes a string as an argument and\n\
    /// returns a string encrypted with the alphabet being rotated. \n/// The alphabet\
    \ should be rotated in a manner such that the letters \n/// shift down by two\
    \ multiplied to two places.\n/// For example:\n/// >>> encrypt(s: \"hi\")\n///\
    \ \"lm\"\n/// >>> encrypt(s: \"asdfghjkl\")\n/// \"ewhjklnop\"\n/// >>> encrypt(s:\
    \ \"gf\")\n/// \"kj\"\n/// >>> encrypt(s: \"et\")\n/// \"ix\"\nfunc encrypt(s:\
    \ String) -> String {\n    return \"\"\n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(encrypt(s: \"hi\") == \"lm\")\nassert(encrypt(s: \"asdfghjkl\") == \"ewhjklnop\"\
    )\nassert(encrypt(s: \"gf\") == \"kj\")\nassert(encrypt(s: \"et\") == \"ix\")\n\
    assert(encrypt(s: \"faewfawefaewg\") == \"jeiajeaijeiak\")\nassert(encrypt(s:\
    \ \"hellomyfriend\") == \"lippsqcjvmirh\")\nassert(encrypt(s: \"dxzdlmnilfuhmilufhlihufnmlimnufhlimnufhfucufh\"\
    ) == \"hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl\")\nassert(encrypt(s: \"\
    a\") == \"e\")"
  status: Exception
  stderr: 'tmpxsqxg1op/tmpxsqxg1op.swift:32: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b607b4a6c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b607b19db6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b607b19d988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b607b19c7b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpxsqxg1op                        0x00005575dd252307 <unavailable> + 4871

    5    libc.so.6                          0x00002b607b692460 __libc_start_main +
    245

    6    tmpxsqxg1op                        0x00005575dd251f49 <unavailable> + 3913

    '
  stdout: ''
  timestamp: 1660028310
- exit_code: 1
  program: "\n/// Create a function encrypt that takes a string as an argument and\n\
    /// returns a string encrypted with the alphabet being rotated. \n/// The alphabet\
    \ should be rotated in a manner such that the letters \n/// shift down by two\
    \ multiplied to two places.\n/// For example:\n/// >>> encrypt(s: \"hi\")\n///\
    \ \"lm\"\n/// >>> encrypt(s: \"asdfghjkl\")\n/// \"ewhjklnop\"\n/// >>> encrypt(s:\
    \ \"gf\")\n/// \"kj\"\n/// >>> encrypt(s: \"et\")\n/// \"ix\"\nfunc encrypt(s:\
    \ String) -> String {\n    var alphabet = \"abcdefghijklmnopqrstuvwxyz\"\n   \
    \ var newWord = \"\"\n    var letters = Array(s)\n    var positions = [Int]()\n\
    \    var converted = [Int]()\n    for i in 0..<letters.count {\n        let position\
    \ = alphabet.firstIndex(of: letters[i])!\n        positions.append(position)\n\
    \    }\n    for i in 0..<positions.count {\n        var newPosition = positions[i]\n\
    \        newPosition = newPosition + (2 * 2)\n        converted.append(newPosition)\n\
    \    }\n    for j in 0..<converted.count {\n        newWord.append(alphabet[converted[j]])\n\
    \    }\n    return newWord\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(encrypt(s:\
    \ \"hi\") == \"lm\")\nassert(encrypt(s: \"asdfghjkl\") == \"ewhjklnop\")\nassert(encrypt(s:\
    \ \"gf\") == \"kj\")\nassert(encrypt(s: \"et\") == \"ix\")\nassert(encrypt(s:\
    \ \"faewfawefaewg\") == \"jeiajeaijeiak\")\nassert(encrypt(s: \"hellomyfriend\"\
    ) == \"lippsqcjvmirh\")\nassert(encrypt(s: \"dxzdlmnilfuhmilufhlihufnmlimnufhlimnufhfucufh\"\
    ) == \"hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl\")\nassert(encrypt(s: \"\
    a\") == \"e\")"
  status: SyntaxError
  stderr: "/tmp/tmp6kgs6z4g.swift:23:19: error: no exact matches in call to instance\
    \ method 'append'\n        positions.append(position)\n                  ^\nSwift.Array:6:37:\
    \ note: candidate expects value of type 'Int' for parameter #1 (got 'String.Index')\n\
    \    @inlinable public mutating func append(_ newElement: __owned Element)\n \
    \                                   ^\nSwift.RangeReplaceableCollection:4:37:\
    \ note: candidate expects value of type 'Int' for parameter #1 (got 'String.Index')\n\
    \    @inlinable public mutating func append(_ newElement: __owned Self.Element)\n\
    \                                    ^\n/tmp/tmp6kgs6z4g.swift:23:19: note: found\
    \ candidate with type '(__owned String.Index) -> ()'\n        positions.append(position)\n\
    \                  ^\n/tmp/tmp6kgs6z4g.swift:31:24: error: 'subscript(_:)' is\
    \ unavailable: cannot subscript String with an Int, use a String.Index instead.\n\
    \        newWord.append(alphabet[converted[j]])\n                       ^~~~~~~~~~~~~~~~~~~~~~\n\
    Swift.String:3:12: note: 'subscript(_:)' has been explicitly marked unavailable\
    \ here\n    public subscript(i: Int) -> Character { get }\n           ^\n"
  stdout: ''
  timestamp: 1660028310
- exit_code: -4
  program: "\n/// Create a function encrypt that takes a string as an argument and\n\
    /// returns a string encrypted with the alphabet being rotated. \n/// The alphabet\
    \ should be rotated in a manner such that the letters \n/// shift down by two\
    \ multiplied to two places.\n/// For example:\n/// >>> encrypt(s: \"hi\")\n///\
    \ \"lm\"\n/// >>> encrypt(s: \"asdfghjkl\")\n/// \"ewhjklnop\"\n/// >>> encrypt(s:\
    \ \"gf\")\n/// \"kj\"\n/// >>> encrypt(s: \"et\")\n/// \"ix\"\nfunc encrypt(s:\
    \ String) -> String {\n    var result = \"\"\n    for character in s {\n     \
    \   var characterInt = character.asciiValue!\n        characterInt += 4\n    \
    \    result += String(UnicodeScalar(UInt8(characterInt)))\n    }\n    return result\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(encrypt(s: \"hi\") == \"lm\")\nassert(encrypt(s:\
    \ \"asdfghjkl\") == \"ewhjklnop\")\nassert(encrypt(s: \"gf\") == \"kj\")\nassert(encrypt(s:\
    \ \"et\") == \"ix\")\nassert(encrypt(s: \"faewfawefaewg\") == \"jeiajeaijeiak\"\
    )\nassert(encrypt(s: \"hellomyfriend\") == \"lippsqcjvmirh\")\nassert(encrypt(s:\
    \ \"dxzdlmnilfuhmilufhlihufnmlimnufhlimnufhfucufh\") == \"hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl\"\
    )\nassert(encrypt(s: \"a\") == \"e\")"
  status: Exception
  stderr: 'tmpgi168vn6/tmpgi168vn6.swift:42: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002afc2d863c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002afc2d55ab6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002afc2d55a988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002afc2d5597b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpgi168vn6                        0x00005564dd4f2b9e <unavailable> + 7070

    5    libc.so.6                          0x00002afc2da4f460 __libc_start_main +
    245

    6    tmpgi168vn6                        0x00005564dd4f2399 <unavailable> + 5017

    '
  stdout: ''
  timestamp: 1660028311
- exit_code: 1
  program: "\n/// Create a function encrypt that takes a string as an argument and\n\
    /// returns a string encrypted with the alphabet being rotated. \n/// The alphabet\
    \ should be rotated in a manner such that the letters \n/// shift down by two\
    \ multiplied to two places.\n/// For example:\n/// >>> encrypt(s: \"hi\")\n///\
    \ \"lm\"\n/// >>> encrypt(s: \"asdfghjkl\")\n/// \"ewhjklnop\"\n/// >>> encrypt(s:\
    \ \"gf\")\n/// \"kj\"\n/// >>> encrypt(s: \"et\")\n/// \"ix\"\nfunc encrypt(s:\
    \ String) -> String {\n    let startIndex = s.startIndex\n    let endIndex = s.endIndex\n\
    \    var encrypted = \"\"\n    for i in s.indices {\n        let index = s.index(s.startIndex,\
    \ offsetBy: i)\n        var letter = s[index]\n        for _ in 0..<2 {\n    \
    \        letter = letter.successor()\n            if letter == \"a\" {\n     \
    \           letter = \"c\"\n            } else if letter == \"b\" {\n        \
    \        letter = \"d\"\n            }\n        }\n        encrypted.append(letter)\n\
    \    }\n    return encrypted\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int,\
    \ Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n\
    \    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n          \
    \  return false\n        }\n    }\n    return true\n}\n            \nassert(encrypt(s:\
    \ \"hi\") == \"lm\")\nassert(encrypt(s: \"asdfghjkl\") == \"ewhjklnop\")\nassert(encrypt(s:\
    \ \"gf\") == \"kj\")\nassert(encrypt(s: \"et\") == \"ix\")\nassert(encrypt(s:\
    \ \"faewfawefaewg\") == \"jeiajeaijeiak\")\nassert(encrypt(s: \"hellomyfriend\"\
    ) == \"lippsqcjvmirh\")\nassert(encrypt(s: \"dxzdlmnilfuhmilufhlihufnmlimnufhlimnufhfucufh\"\
    ) == \"hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl\")\nassert(encrypt(s: \"\
    a\") == \"e\")"
  status: SyntaxError
  stderr: "/tmp/tmpi38g3ti8.swift:20:21: error: instance method 'index(_:offsetBy:)'\
    \ requires that 'DefaultIndices<String>.Element' (aka 'String.Index') conform\
    \ to 'BinaryInteger'\n        let index = s.index(s.startIndex, offsetBy: i)\n\
    \                    ^\nSwift.Collection:3:17: note: where 'T' = 'DefaultIndices<String>.Element'\
    \ (aka 'String.Index')\n    public func index<T>(_ i: Self.Index, offsetBy n:\
    \ T) -> Self.Index where T : BinaryInteger\n                ^\n"
  stdout: ''
  timestamp: 1660028310
- exit_code: 1
  program: "\n/// Create a function encrypt that takes a string as an argument and\n\
    /// returns a string encrypted with the alphabet being rotated. \n/// The alphabet\
    \ should be rotated in a manner such that the letters \n/// shift down by two\
    \ multiplied to two places.\n/// For example:\n/// >>> encrypt(s: \"hi\")\n///\
    \ \"lm\"\n/// >>> encrypt(s: \"asdfghjkl\")\n/// \"ewhjklnop\"\n/// >>> encrypt(s:\
    \ \"gf\")\n/// \"kj\"\n/// >>> encrypt(s: \"et\")\n/// \"ix\"\nfunc encrypt(s:\
    \ String) -> String {\n    var encryptedString = \"\"\n    for char in s {\n \
    \       var asciiValue = char.asciiValue!\n        if asciiValue >= 97 {\n   \
    \         asciiValue += 16\n            if asciiValue > 122 {\n              \
    \  asciiValue -= 26\n            }\n        } else {\n            asciiValue +=\
    \ 16\n            if asciiValue > 90 {\n                asciiValue -= 26\n   \
    \         }\n        }\n        encryptedString.append(Character(UnicodeScalar(asciiValue)!))\n\
    \    }\n    return encryptedString\n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(encrypt(s: \"hi\") == \"lm\")\nassert(encrypt(s: \"asdfghjkl\") == \"ewhjklnop\"\
    )\nassert(encrypt(s: \"gf\") == \"kj\")\nassert(encrypt(s: \"et\") == \"ix\")\n\
    assert(encrypt(s: \"faewfawefaewg\") == \"jeiajeaijeiak\")\nassert(encrypt(s:\
    \ \"hellomyfriend\") == \"lippsqcjvmirh\")\nassert(encrypt(s: \"dxzdlmnilfuhmilufhlihufnmlimnufhlimnufhfucufh\"\
    ) == \"hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl\")\nassert(encrypt(s: \"\
    a\") == \"e\")"
  status: SyntaxError
  stderr: "/tmp/tmpiywl3yy5.swift:30:67: error: cannot force unwrap value of non-optional\
    \ type 'UnicodeScalar' (aka 'Unicode.Scalar')\n        encryptedString.append(Character(UnicodeScalar(asciiValue)!))\n\
    \                                         ~~~~~~~~~~~~~~~~~~~~~~~~~^\n       \
    \                                                           \n"
  stdout: ''
  timestamp: 1660028310
- exit_code: 1
  program: "\n/// Create a function encrypt that takes a string as an argument and\n\
    /// returns a string encrypted with the alphabet being rotated. \n/// The alphabet\
    \ should be rotated in a manner such that the letters \n/// shift down by two\
    \ multiplied to two places.\n/// For example:\n/// >>> encrypt(s: \"hi\")\n///\
    \ \"lm\"\n/// >>> encrypt(s: \"asdfghjkl\")\n/// \"ewhjklnop\"\n/// >>> encrypt(s:\
    \ \"gf\")\n/// \"kj\"\n/// >>> encrypt(s: \"et\")\n/// \"ix\"\nfunc encrypt(s:\
    \ String) -> String {\n    //this is a single line solution.\n    let alphabet\
    \ = \"abcdefghijklmnopqrstuvwxyz\".map { $0 }\n    let result = s.map { alphabet[alphabet.index(alphabet.startIndex,\
    \ offsetBy: (alphabet.index(of: $0)!.encodedOffset + 2) % alphabet.count)] }\n\
    \    return String(result)\n    \n//    //this is a several line solution.\n//\
    \    var alphabet = \"abcdefghijklmnopqrstuvwxyz\".map { $0 }\n//    var result\
    \ = \"\"\n//    for char in s {\n//        let index = alphabet.index(of: char)!.encodedOffset\n\
    //        alphabet.rotate(shiftingToStart: index)\n//        alphabet.rotate(shiftingToStart:\
    \ 2)\n//        result.append(alphabet[0])\n//    }\n//    return result\n}\n\n\
    \nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(encrypt(s: \"hi\") == \"lm\")\nassert(encrypt(s:\
    \ \"asdfghjkl\") == \"ewhjklnop\")\nassert(encrypt(s: \"gf\") == \"kj\")\nassert(encrypt(s:\
    \ \"et\") == \"ix\")\nassert(encrypt(s: \"faewfawefaewg\") == \"jeiajeaijeiak\"\
    )\nassert(encrypt(s: \"hellomyfriend\") == \"lippsqcjvmirh\")\nassert(encrypt(s:\
    \ \"dxzdlmnilfuhmilufhlihufnmlimnufhlimnufhfucufh\") == \"hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl\"\
    )\nassert(encrypt(s: \"a\") == \"e\")"
  status: SyntaxError
  stderr: "/tmp/tmpuvxo27dh.swift:18:106: error: value of type 'Array<String.Element>.Index'\
    \ (aka 'Int') has no member 'encodedOffset'\n    let result = s.map { alphabet[alphabet.index(alphabet.startIndex,\
    \ offsetBy: (alphabet.index(of: $0)!.encodedOffset + 2) % alphabet.count)] }\n\
    \                                                                            \
    \     ~~~~~~~~~~~~~~~~~~~~~~~ ^~~~~~~~~~~~~\n"
  stdout: ''
  timestamp: 1660028310
- exit_code: 1
  program: "\n/// Create a function encrypt that takes a string as an argument and\n\
    /// returns a string encrypted with the alphabet being rotated. \n/// The alphabet\
    \ should be rotated in a manner such that the letters \n/// shift down by two\
    \ multiplied to two places.\n/// For example:\n/// >>> encrypt(s: \"hi\")\n///\
    \ \"lm\"\n/// >>> encrypt(s: \"asdfghjkl\")\n/// \"ewhjklnop\"\n/// >>> encrypt(s:\
    \ \"gf\")\n/// \"kj\"\n/// >>> encrypt(s: \"et\")\n/// \"ix\"\nfunc encrypt(s:\
    \ String) -> String {\n    let split = s.map{String($0)}\n    var answer: String\
    \ = \"\"\n    for letter in split {\n        let ascii = letter.unicodeScalars.first!.value\n\
    \        let lower = ascii >= Int(UnicodeScalar(\"a\").value) && ascii <= Int(UnicodeScalar(\"\
    z\").value)\n        if lower {\n            var newLetter = ascii + 2*2\n   \
    \         if newLetter > Int(UnicodeScalar(\"z\").value) {\n                newLetter\
    \ = (Int(UnicodeScalar(\"a\").value) + (newLetter % Int(UnicodeScalar(\"z\").value)))\n\
    \            }\n            answer += String(UnicodeScalar(UInt8(newLetter)))\n\
    \        } else {\n            var newLetter = ascii + 2*2\n            if newLetter\
    \ > Int(UnicodeScalar(\"Z\").value) {\n                newLetter = (Int(UnicodeScalar(\"\
    A\").value) + (newLetter % Int(UnicodeScalar(\"Z\").value)))\n            }\n\
    \            answer += String(UnicodeScalar(UInt8(newLetter)))\n        }\n  \
    \  }\n    return answer\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(encrypt(s:\
    \ \"hi\") == \"lm\")\nassert(encrypt(s: \"asdfghjkl\") == \"ewhjklnop\")\nassert(encrypt(s:\
    \ \"gf\") == \"kj\")\nassert(encrypt(s: \"et\") == \"ix\")\nassert(encrypt(s:\
    \ \"faewfawefaewg\") == \"jeiajeaijeiak\")\nassert(encrypt(s: \"hellomyfriend\"\
    ) == \"lippsqcjvmirh\")\nassert(encrypt(s: \"dxzdlmnilfuhmilufhlihufnmlimnufhlimnufhfucufh\"\
    ) == \"hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl\")\nassert(encrypt(s: \"\
    a\") == \"e\")"
  status: SyntaxError
  stderr: "/tmp/tmp8u_4or1a.swift:24:60: error: cannot assign value of type 'Int'\
    \ to type 'UInt32'\n                newLetter = (Int(UnicodeScalar(\"a\").value)\
    \ + (newLetter % Int(UnicodeScalar(\"z\").value)))\n                         \
    \   ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n\
    \                            UInt32(                                         \
    \                             )\n/tmp/tmp8u_4or1a.swift:24:63: error: cannot convert\
    \ value of type 'UInt32' to expected argument type 'Int'\n                newLetter\
    \ = (Int(UnicodeScalar(\"a\").value) + (newLetter % Int(UnicodeScalar(\"z\").value)))\n\
    \                                                              ^\n           \
    \                                                   Int(     )\n/tmp/tmp8u_4or1a.swift:30:60:\
    \ error: cannot assign value of type 'Int' to type 'UInt32'\n                newLetter\
    \ = (Int(UnicodeScalar(\"A\").value) + (newLetter % Int(UnicodeScalar(\"Z\").value)))\n\
    \                            ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n\
    \                            UInt32(                                         \
    \                             )\n/tmp/tmp8u_4or1a.swift:30:63: error: cannot convert\
    \ value of type 'UInt32' to expected argument type 'Int'\n                newLetter\
    \ = (Int(UnicodeScalar(\"A\").value) + (newLetter % Int(UnicodeScalar(\"Z\").value)))\n\
    \                                                              ^\n           \
    \                                                   Int(     )\n"
  stdout: ''
  timestamp: 1660028315
- exit_code: -4
  program: "\n/// Create a function encrypt that takes a string as an argument and\n\
    /// returns a string encrypted with the alphabet being rotated. \n/// The alphabet\
    \ should be rotated in a manner such that the letters \n/// shift down by two\
    \ multiplied to two places.\n/// For example:\n/// >>> encrypt(s: \"hi\")\n///\
    \ \"lm\"\n/// >>> encrypt(s: \"asdfghjkl\")\n/// \"ewhjklnop\"\n/// >>> encrypt(s:\
    \ \"gf\")\n/// \"kj\"\n/// >>> encrypt(s: \"et\")\n/// \"ix\"\nfunc encrypt(s:\
    \ String) -> String {\n    let alphabet: String = \"abcdefghijklmnopqrstuvwxyz\"\
    \n    var encrypted: String = \"\"\n    for letter in s {\n        let i = alphabet.firstIndex(of:\
    \ letter)!\n        let i1 = alphabet.index(i, offsetBy: 2*2)\n        encrypted.append(alphabet[i1])\n\
    \    }\n    return encrypted\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int,\
    \ Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n\
    \    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n          \
    \  return false\n        }\n    }\n    return true\n}\n            \nassert(encrypt(s:\
    \ \"hi\") == \"lm\")\nassert(encrypt(s: \"asdfghjkl\") == \"ewhjklnop\")\nassert(encrypt(s:\
    \ \"gf\") == \"kj\")\nassert(encrypt(s: \"et\") == \"ix\")\nassert(encrypt(s:\
    \ \"faewfawefaewg\") == \"jeiajeaijeiak\")\nassert(encrypt(s: \"hellomyfriend\"\
    ) == \"lippsqcjvmirh\")\nassert(encrypt(s: \"dxzdlmnilfuhmilufhlihufnmlimnufhlimnufhfucufh\"\
    ) == \"hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl\")\nassert(encrypt(s: \"\
    a\") == \"e\")"
  status: Exception
  stderr: 'Swift/StringIndexValidation.swift:120: Fatal error: String index is out
    of bounds

    Current stack trace:

    0    libswiftCore.so                    0x00002acf486dec80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002acf483d5561 <unavailable> + 1434977

    2    libswiftCore.so                    0x00002acf483d5286 <unavailable> + 1434246

    3    libswiftCore.so                    0x00002acf483d513c <unavailable> + 1433916

    4    libswiftCore.so                    0x00002acf483d4bb0 _assertionFailure(_:_:file:line:flags:)
    + 251

    5    libswiftCore.so                    0x00002acf48508ec2 <unavailable> + 2694850

    6    libswiftCore.so                    0x00002acf484c1660 String.subscript.getter
    + 34

    7    tmprkw577ow                        0x000056041fd520dd <unavailable> + 8413

    8    tmprkw577ow                        0x000056041fd519dd <unavailable> + 6621

    9    libc.so.6                          0x00002acf488ca460 __libc_start_main +
    245

    10   tmprkw577ow                        0x000056041fd512c9 <unavailable> + 4809

    '
  stdout: ''
  timestamp: 1660028311
- exit_code: 1
  program: "\n/// Create a function encrypt that takes a string as an argument and\n\
    /// returns a string encrypted with the alphabet being rotated. \n/// The alphabet\
    \ should be rotated in a manner such that the letters \n/// shift down by two\
    \ multiplied to two places.\n/// For example:\n/// >>> encrypt(s: \"hi\")\n///\
    \ \"lm\"\n/// >>> encrypt(s: \"asdfghjkl\")\n/// \"ewhjklnop\"\n/// >>> encrypt(s:\
    \ \"gf\")\n/// \"kj\"\n/// >>> encrypt(s: \"et\")\n/// \"ix\"\nfunc encrypt(s:\
    \ String) -> String {\n    \n    let firstHalfAlphabet = \"abcdefghijklm\"\n \
    \   let secondHalfAlphabet = \"nopqrstuvwxyz\"\n    var encryptedString = \"\"\
    \n    \n    for letter in s {\n        if let idx = firstHalfAlphabet.firstIndex(of:\
    \ letter) {\n            encryptedString.append(firstHalfAlphabet[idx + 2])\n\
    \        } else if let idx = secondHalfAlphabet.firstIndex(of: letter) {\n   \
    \         encryptedString.append(secondHalfAlphabet[idx + 2])\n        }\n   \
    \ }\n    \n    return encryptedString\n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(encrypt(s: \"hi\") == \"lm\")\nassert(encrypt(s: \"asdfghjkl\") == \"ewhjklnop\"\
    )\nassert(encrypt(s: \"gf\") == \"kj\")\nassert(encrypt(s: \"et\") == \"ix\")\n\
    assert(encrypt(s: \"faewfawefaewg\") == \"jeiajeaijeiak\")\nassert(encrypt(s:\
    \ \"hellomyfriend\") == \"lippsqcjvmirh\")\nassert(encrypt(s: \"dxzdlmnilfuhmilufhlihufnmlimnufhlimnufhfucufh\"\
    ) == \"hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl\")\nassert(encrypt(s: \"\
    a\") == \"e\")"
  status: SyntaxError
  stderr: "/tmp/tmpsd8b2dfr.swift:23:54: error: cannot convert value of type 'String.Index'\
    \ to expected argument type 'Int'\n            encryptedString.append(firstHalfAlphabet[idx\
    \ + 2])\n                                                     ^\n/tmp/tmpsd8b2dfr.swift:25:55:\
    \ error: cannot convert value of type 'String.Index' to expected argument type\
    \ 'Int'\n            encryptedString.append(secondHalfAlphabet[idx + 2])\n   \
    \                                                   ^\n"
  stdout: ''
  timestamp: 1660028311
- exit_code: -4
  program: "\n/// Create a function encrypt that takes a string as an argument and\n\
    /// returns a string encrypted with the alphabet being rotated. \n/// The alphabet\
    \ should be rotated in a manner such that the letters \n/// shift down by two\
    \ multiplied to two places.\n/// For example:\n/// >>> encrypt(s: \"hi\")\n///\
    \ \"lm\"\n/// >>> encrypt(s: \"asdfghjkl\")\n/// \"ewhjklnop\"\n/// >>> encrypt(s:\
    \ \"gf\")\n/// \"kj\"\n/// >>> encrypt(s: \"et\")\n/// \"ix\"\nfunc encrypt(s:\
    \ String) -> String {\n    var newString = \"\"\n    let s = s.lowercased()\n\
    \    let alphabet = \"abcdefghijklmnopqrstuvwxyz\"\n    for i in s {\n       \
    \ if alphabet.contains(i) {\n            let position = alphabet.firstIndex(of:\
    \ i)!\n            let secondPosition = alphabet.index(after: position)\n    \
    \        let thirdPosition = alphabet.index(after: secondPosition)\n         \
    \   let fourthPosition = alphabet.index(after: thirdPosition)\n            let\
    \ firstCharacter = alphabet[thirdPosition]\n            let secondCharacter =\
    \ alphabet[fourthPosition]\n            newString.append(firstCharacter)\n   \
    \         newString.append(secondCharacter)\n        }\n    }\n    return newString\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(encrypt(s: \"hi\") == \"lm\")\nassert(encrypt(s:\
    \ \"asdfghjkl\") == \"ewhjklnop\")\nassert(encrypt(s: \"gf\") == \"kj\")\nassert(encrypt(s:\
    \ \"et\") == \"ix\")\nassert(encrypt(s: \"faewfawefaewg\") == \"jeiajeaijeiak\"\
    )\nassert(encrypt(s: \"hellomyfriend\") == \"lippsqcjvmirh\")\nassert(encrypt(s:\
    \ \"dxzdlmnilfuhmilufhlihufnmlimnufhlimnufhfucufh\") == \"hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl\"\
    )\nassert(encrypt(s: \"a\") == \"e\")"
  status: Exception
  stderr: 'tmp_8e8gwox/tmp_8e8gwox.swift:47: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002afa27076c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002afa26d6db6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002afa26d6d988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002afa26d6c7b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmp_8e8gwox                        0x0000557521857777 <unavailable> + 6007

    5    libc.so.6                          0x00002afa27262460 __libc_start_main +
    245

    6    tmp_8e8gwox                        0x00005575218573b9 <unavailable> + 5049

    '
  stdout: ''
  timestamp: 1660028311
- exit_code: 1
  program: "\n/// Create a function encrypt that takes a string as an argument and\n\
    /// returns a string encrypted with the alphabet being rotated. \n/// The alphabet\
    \ should be rotated in a manner such that the letters \n/// shift down by two\
    \ multiplied to two places.\n/// For example:\n/// >>> encrypt(s: \"hi\")\n///\
    \ \"lm\"\n/// >>> encrypt(s: \"asdfghjkl\")\n/// \"ewhjklnop\"\n/// >>> encrypt(s:\
    \ \"gf\")\n/// \"kj\"\n/// >>> encrypt(s: \"et\")\n/// \"ix\"\nfunc encrypt(s:\
    \ String) -> String {\n    var enc_s = \"\"\n    for i in s {\n        var code\
    \ = i.asciiValue!\n        if (i.asciiValue! >= 48 && i.asciiValue! <= 57) {\n\
    \            code = i.asciiValue! + 8\n        } else if (i.asciiValue! >= 65\
    \ && i.asciiValue! <= 90) {\n            code = i.asciiValue! + 16\n        }\
    \ else if (i.asciiValue! >= 97 && i.asciiValue! <= 122) {\n            code =\
    \ i.asciiValue! + 16\n        }\n        if (code > 57 && code < 65) {\n     \
    \       code = 64 + (code - 57)\n        } else if (code > 90 && code < 97) {\n\
    \            code = 96 + (code - 90)\n        } else if (code > 122) {\n     \
    \       code = 96 + (code - 122)\n        }\n        enc_s.append(Character(UnicodeScalar(code)!))\n\
    \    }\n    return enc_s\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(encrypt(s:\
    \ \"hi\") == \"lm\")\nassert(encrypt(s: \"asdfghjkl\") == \"ewhjklnop\")\nassert(encrypt(s:\
    \ \"gf\") == \"kj\")\nassert(encrypt(s: \"et\") == \"ix\")\nassert(encrypt(s:\
    \ \"faewfawefaewg\") == \"jeiajeaijeiak\")\nassert(encrypt(s: \"hellomyfriend\"\
    ) == \"lippsqcjvmirh\")\nassert(encrypt(s: \"dxzdlmnilfuhmilufhlihufnmlimnufhlimnufhfucufh\"\
    ) == \"hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl\")\nassert(encrypt(s: \"\
    a\") == \"e\")"
  status: SyntaxError
  stderr: "/tmp/tmphh7hds7t.swift:33:51: error: cannot force unwrap value of non-optional\
    \ type 'UnicodeScalar' (aka 'Unicode.Scalar')\n        enc_s.append(Character(UnicodeScalar(code)!))\n\
    \                               ~~~~~~~~~~~~~~~~~~~^\n                       \
    \                           \n"
  stdout: ''
  timestamp: 1660028310
- exit_code: -4
  program: "\n/// Create a function encrypt that takes a string as an argument and\n\
    /// returns a string encrypted with the alphabet being rotated. \n/// The alphabet\
    \ should be rotated in a manner such that the letters \n/// shift down by two\
    \ multiplied to two places.\n/// For example:\n/// >>> encrypt(s: \"hi\")\n///\
    \ \"lm\"\n/// >>> encrypt(s: \"asdfghjkl\")\n/// \"ewhjklnop\"\n/// >>> encrypt(s:\
    \ \"gf\")\n/// \"kj\"\n/// >>> encrypt(s: \"et\")\n/// \"ix\"\nfunc encrypt(s:\
    \ String) -> String {\n    // you code goes here\n    let alphabet = \"abcdefghijklmnopqrstuvwxyz\"\
    \n    var encrypted = \"\"\n    for letter in s {\n        let index = alphabet.index(of:\
    \ letter)\n        if let index = index {\n            let newIndex = alphabet.index(index,\
    \ offsetBy: 2)\n            let newLetter = alphabet[newIndex]\n            encrypted.append(newLetter)\n\
    \        }\n    }\n    return encrypted\n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(encrypt(s: \"hi\") == \"lm\")\nassert(encrypt(s: \"asdfghjkl\") == \"ewhjklnop\"\
    )\nassert(encrypt(s: \"gf\") == \"kj\")\nassert(encrypt(s: \"et\") == \"ix\")\n\
    assert(encrypt(s: \"faewfawefaewg\") == \"jeiajeaijeiak\")\nassert(encrypt(s:\
    \ \"hellomyfriend\") == \"lippsqcjvmirh\")\nassert(encrypt(s: \"dxzdlmnilfuhmilufhlihufnmlimnufhlimnufhfucufh\"\
    ) == \"hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl\")\nassert(encrypt(s: \"\
    a\") == \"e\")"
  status: Exception
  stderr: 'tmpayg1hmcr/tmpayg1hmcr.swift:43: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b8ebdf10c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b8ebdc07b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b8ebdc07988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b8ebdc067b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpayg1hmcr                        0x00005617672fb5e7 <unavailable> + 5607

    5    libc.so.6                          0x00002b8ebe0fc460 __libc_start_main +
    245

    6    tmpayg1hmcr                        0x00005617672fb229 <unavailable> + 4649

    '
  stdout: ''
  timestamp: 1660028311
- exit_code: 1
  program: "\n/// Create a function encrypt that takes a string as an argument and\n\
    /// returns a string encrypted with the alphabet being rotated. \n/// The alphabet\
    \ should be rotated in a manner such that the letters \n/// shift down by two\
    \ multiplied to two places.\n/// For example:\n/// >>> encrypt(s: \"hi\")\n///\
    \ \"lm\"\n/// >>> encrypt(s: \"asdfghjkl\")\n/// \"ewhjklnop\"\n/// >>> encrypt(s:\
    \ \"gf\")\n/// \"kj\"\n/// >>> encrypt(s: \"et\")\n/// \"ix\"\nfunc encrypt(s:\
    \ String) -> String {\n    var encrypted = \"\"\n    for letter in s {\n     \
    \   let index = letter.asciiValue! - \"a\".asciiValue!\n        let newIndex =\
    \ ((index + 20) % 26) + \"a\".asciiValue!\n        encrypted.append(Character(UnicodeScalar(newIndex)!))\n\
    \    }\n    return encrypted\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int,\
    \ Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n\
    \    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n          \
    \  return false\n        }\n    }\n    return true\n}\n            \nassert(encrypt(s:\
    \ \"hi\") == \"lm\")\nassert(encrypt(s: \"asdfghjkl\") == \"ewhjklnop\")\nassert(encrypt(s:\
    \ \"gf\") == \"kj\")\nassert(encrypt(s: \"et\") == \"ix\")\nassert(encrypt(s:\
    \ \"faewfawefaewg\") == \"jeiajeaijeiak\")\nassert(encrypt(s: \"hellomyfriend\"\
    ) == \"lippsqcjvmirh\")\nassert(encrypt(s: \"dxzdlmnilfuhmilufhlihufnmlimnufhlimnufhfucufh\"\
    ) == \"hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl\")\nassert(encrypt(s: \"\
    a\") == \"e\")"
  status: SyntaxError
  stderr: "/tmp/tmplwutrdc2.swift:18:46: error: value of type 'String' has no member\
    \ 'asciiValue'\n        let index = letter.asciiValue! - \"a\".asciiValue!\n \
    \                                        ~~~ ^~~~~~~~~~\n/tmp/tmplwutrdc2.swift:19:50:\
    \ error: value of type 'String' has no member 'asciiValue'\n        let newIndex\
    \ = ((index + 20) % 26) + \"a\".asciiValue!\n                                \
    \             ~~~ ^~~~~~~~~~\n"
  stdout: ''
  timestamp: 1660028311
- exit_code: -4
  program: "\n/// Create a function encrypt that takes a string as an argument and\n\
    /// returns a string encrypted with the alphabet being rotated. \n/// The alphabet\
    \ should be rotated in a manner such that the letters \n/// shift down by two\
    \ multiplied to two places.\n/// For example:\n/// >>> encrypt(s: \"hi\")\n///\
    \ \"lm\"\n/// >>> encrypt(s: \"asdfghjkl\")\n/// \"ewhjklnop\"\n/// >>> encrypt(s:\
    \ \"gf\")\n/// \"kj\"\n/// >>> encrypt(s: \"et\")\n/// \"ix\"\nfunc encrypt(s:\
    \ String) -> String {\n    return \"\"\n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(encrypt(s: \"hi\") == \"lm\")\nassert(encrypt(s: \"asdfghjkl\") == \"ewhjklnop\"\
    )\nassert(encrypt(s: \"gf\") == \"kj\")\nassert(encrypt(s: \"et\") == \"ix\")\n\
    assert(encrypt(s: \"faewfawefaewg\") == \"jeiajeaijeiak\")\nassert(encrypt(s:\
    \ \"hellomyfriend\") == \"lippsqcjvmirh\")\nassert(encrypt(s: \"dxzdlmnilfuhmilufhlihufnmlimnufhlimnufhfucufh\"\
    ) == \"hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl\")\nassert(encrypt(s: \"\
    a\") == \"e\")"
  status: Exception
  stderr: 'tmpxsqxg1op/tmpxsqxg1op.swift:32: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b607b4a6c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b607b19db6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b607b19d988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b607b19c7b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpxsqxg1op                        0x00005575dd252307 <unavailable> + 4871

    5    libc.so.6                          0x00002b607b692460 __libc_start_main +
    245

    6    tmpxsqxg1op                        0x00005575dd251f49 <unavailable> + 3913

    '
  stdout: ''
  timestamp: 1660028310
- exit_code: -4
  program: "\n/// Create a function encrypt that takes a string as an argument and\n\
    /// returns a string encrypted with the alphabet being rotated. \n/// The alphabet\
    \ should be rotated in a manner such that the letters \n/// shift down by two\
    \ multiplied to two places.\n/// For example:\n/// >>> encrypt(s: \"hi\")\n///\
    \ \"lm\"\n/// >>> encrypt(s: \"asdfghjkl\")\n/// \"ewhjklnop\"\n/// >>> encrypt(s:\
    \ \"gf\")\n/// \"kj\"\n/// >>> encrypt(s: \"et\")\n/// \"ix\"\nfunc encrypt(s:\
    \ String) -> String {\n    let alphabet = Array(\"abcdefghijklmnopqrstuvwxyz\"\
    )\n    let upperAlphabet = Array(\"ABCDEFGHIJKLMNOPQRSTUVWXYZ\")\n    var encryptedString\
    \ = \"\"\n    var letter = \"\"\n    for char in s {\n        if alphabet.contains(char)\
    \ {\n            for i in 0..<alphabet.count {\n                if alphabet[i]\
    \ == char {\n                    letter = String(alphabet[(i + 2) * 2 % alphabet.count])\n\
    \                }\n            }\n        } else if upperAlphabet.contains(char)\
    \ {\n            for i in 0..<upperAlphabet.count {\n                if upperAlphabet[i]\
    \ == char {\n                    letter = String(upperAlphabet[(i + 2) * 2 % upperAlphabet.count])\n\
    \                }\n            }\n        } else {\n            letter = String(char)\n\
    \        }\n        encryptedString += letter\n    }\n    return encryptedString\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(encrypt(s: \"hi\") == \"lm\")\nassert(encrypt(s:\
    \ \"asdfghjkl\") == \"ewhjklnop\")\nassert(encrypt(s: \"gf\") == \"kj\")\nassert(encrypt(s:\
    \ \"et\") == \"ix\")\nassert(encrypt(s: \"faewfawefaewg\") == \"jeiajeaijeiak\"\
    )\nassert(encrypt(s: \"hellomyfriend\") == \"lippsqcjvmirh\")\nassert(encrypt(s:\
    \ \"dxzdlmnilfuhmilufhlihufnmlimnufhlimnufhfucufh\") == \"hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl\"\
    )\nassert(encrypt(s: \"a\") == \"e\")"
  status: Exception
  stderr: 'tmp1m48inch/tmp1m48inch.swift:54: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b93f6248c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b93f5f3fb6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b93f5f3f988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b93f5f3e7b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmp1m48inch                        0x00005610e6e0e8a7 <unavailable> + 6311

    5    libc.so.6                          0x00002b93f6434460 __libc_start_main +
    245

    6    tmp1m48inch                        0x00005610e6e0e4e9 <unavailable> + 5353

    '
  stdout: ''
  timestamp: 1660028311
- exit_code: -4
  program: "\n/// Create a function encrypt that takes a string as an argument and\n\
    /// returns a string encrypted with the alphabet being rotated. \n/// The alphabet\
    \ should be rotated in a manner such that the letters \n/// shift down by two\
    \ multiplied to two places.\n/// For example:\n/// >>> encrypt(s: \"hi\")\n///\
    \ \"lm\"\n/// >>> encrypt(s: \"asdfghjkl\")\n/// \"ewhjklnop\"\n/// >>> encrypt(s:\
    \ \"gf\")\n/// \"kj\"\n/// >>> encrypt(s: \"et\")\n/// \"ix\"\nfunc encrypt(s:\
    \ String) -> String {\n  let alphabet = Array(\"abcdefghijklmnopqrstuvwxyz\")\n\
    \  var newWord = \"\"\n  for letter in s {\n    if let idx = alphabet.firstIndex(of:\
    \ letter) {\n      let newIdx = (idx + 2) % alphabet.count\n      newWord.append(alphabet[newIdx])\n\
    \    }\n  }\n  return newWord\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int,\
    \ Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n\
    \    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n          \
    \  return false\n        }\n    }\n    return true\n}\n            \nassert(encrypt(s:\
    \ \"hi\") == \"lm\")\nassert(encrypt(s: \"asdfghjkl\") == \"ewhjklnop\")\nassert(encrypt(s:\
    \ \"gf\") == \"kj\")\nassert(encrypt(s: \"et\") == \"ix\")\nassert(encrypt(s:\
    \ \"faewfawefaewg\") == \"jeiajeaijeiak\")\nassert(encrypt(s: \"hellomyfriend\"\
    ) == \"lippsqcjvmirh\")\nassert(encrypt(s: \"dxzdlmnilfuhmilufhlihufnmlimnufhlimnufhfucufh\"\
    ) == \"hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl\")\nassert(encrypt(s: \"\
    a\") == \"e\")"
  status: Exception
  stderr: 'tmpw85xry8p/tmpw85xry8p.swift:40: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002acfa5749c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002acfa5440b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002acfa5440988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002acfa543f7b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpw85xry8p                        0x0000562d9a38f757 <unavailable> + 5975

    5    libc.so.6                          0x00002acfa5935460 __libc_start_main +
    245

    6    tmpw85xry8p                        0x0000562d9a38f399 <unavailable> + 5017

    '
  stdout: ''
  timestamp: 1660028311
- exit_code: 1
  program: "\n/// Create a function encrypt that takes a string as an argument and\n\
    /// returns a string encrypted with the alphabet being rotated. \n/// The alphabet\
    \ should be rotated in a manner such that the letters \n/// shift down by two\
    \ multiplied to two places.\n/// For example:\n/// >>> encrypt(s: \"hi\")\n///\
    \ \"lm\"\n/// >>> encrypt(s: \"asdfghjkl\")\n/// \"ewhjklnop\"\n/// >>> encrypt(s:\
    \ \"gf\")\n/// \"kj\"\n/// >>> encrypt(s: \"et\")\n/// \"ix\"\nfunc encrypt(s:\
    \ String) -> String {\n    var result = \"\"\n    for c in s {\n        result\
    \ += String(Character(UnicodeScalar(c.asciiValue! + 2)!))\n    }\n    return result\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(encrypt(s: \"hi\") == \"lm\")\nassert(encrypt(s:\
    \ \"asdfghjkl\") == \"ewhjklnop\")\nassert(encrypt(s: \"gf\") == \"kj\")\nassert(encrypt(s:\
    \ \"et\") == \"ix\")\nassert(encrypt(s: \"faewfawefaewg\") == \"jeiajeaijeiak\"\
    )\nassert(encrypt(s: \"hellomyfriend\") == \"lippsqcjvmirh\")\nassert(encrypt(s:\
    \ \"dxzdlmnilfuhmilufhlihufnmlimnufhlimnufhfucufh\") == \"hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl\"\
    )\nassert(encrypt(s: \"a\") == \"e\")"
  status: SyntaxError
  stderr: "/tmp/tmpg6lydww0.swift:18:68: error: cannot force unwrap value of non-optional\
    \ type 'UnicodeScalar' (aka 'Unicode.Scalar')\n        result += String(Character(UnicodeScalar(c.asciiValue!\
    \ + 2)!))\n                                   ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~^\n\
    \                                                                   \n"
  stdout: ''
  timestamp: 1660028311
- exit_code: 1
  program: "\n/// Create a function encrypt that takes a string as an argument and\n\
    /// returns a string encrypted with the alphabet being rotated. \n/// The alphabet\
    \ should be rotated in a manner such that the letters \n/// shift down by two\
    \ multiplied to two places.\n/// For example:\n/// >>> encrypt(s: \"hi\")\n///\
    \ \"lm\"\n/// >>> encrypt(s: \"asdfghjkl\")\n/// \"ewhjklnop\"\n/// >>> encrypt(s:\
    \ \"gf\")\n/// \"kj\"\n/// >>> encrypt(s: \"et\")\n/// \"ix\"\nfunc encrypt(s:\
    \ String) -> String {\n    return encrypt(s: s, distance: 4)\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(encrypt(s: \"hi\") == \"lm\")\nassert(encrypt(s: \"asdfghjkl\"\
    ) == \"ewhjklnop\")\nassert(encrypt(s: \"gf\") == \"kj\")\nassert(encrypt(s: \"\
    et\") == \"ix\")\nassert(encrypt(s: \"faewfawefaewg\") == \"jeiajeaijeiak\")\n\
    assert(encrypt(s: \"hellomyfriend\") == \"lippsqcjvmirh\")\nassert(encrypt(s:\
    \ \"dxzdlmnilfuhmilufhlihufnmlimnufhlimnufhfucufh\") == \"hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl\"\
    )\nassert(encrypt(s: \"a\") == \"e\")"
  status: SyntaxError
  stderr: "/tmp/tmp7akw1gx8.swift:16:36: error: extra argument 'distance' in call\n\
    \    return encrypt(s: s, distance: 4)\n                  ~~~~~~~~~~~~~~~~~^~\n"
  stdout: ''
  timestamp: 1660028311
- exit_code: 1
  program: "\n/// Create a function encrypt that takes a string as an argument and\n\
    /// returns a string encrypted with the alphabet being rotated. \n/// The alphabet\
    \ should be rotated in a manner such that the letters \n/// shift down by two\
    \ multiplied to two places.\n/// For example:\n/// >>> encrypt(s: \"hi\")\n///\
    \ \"lm\"\n/// >>> encrypt(s: \"asdfghjkl\")\n/// \"ewhjklnop\"\n/// >>> encrypt(s:\
    \ \"gf\")\n/// \"kj\"\n/// >>> encrypt(s: \"et\")\n/// \"ix\"\nfunc encrypt(s:\
    \ String) -> String {\n    // Uppercase the string\n    let upperCased = s.uppercased()\n\
    \    var result = \"\"\n    for char in upperCased {\n        // Rotate each character\
    \ and append to result\n        let rotated = rotate(s: char)\n        result\
    \ += rotated\n    }\n    return result\n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(encrypt(s: \"hi\") == \"lm\")\nassert(encrypt(s: \"asdfghjkl\") == \"ewhjklnop\"\
    )\nassert(encrypt(s: \"gf\") == \"kj\")\nassert(encrypt(s: \"et\") == \"ix\")\n\
    assert(encrypt(s: \"faewfawefaewg\") == \"jeiajeaijeiak\")\nassert(encrypt(s:\
    \ \"hellomyfriend\") == \"lippsqcjvmirh\")\nassert(encrypt(s: \"dxzdlmnilfuhmilufhlihufnmlimnufhlimnufhfucufh\"\
    ) == \"hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl\")\nassert(encrypt(s: \"\
    a\") == \"e\")"
  status: SyntaxError
  stderr: "/tmp/tmpolcvo50r.swift:21:23: error: cannot find 'rotate' in scope\n  \
    \      let rotated = rotate(s: char)\n                      ^~~~~~\n"
  stdout: ''
  timestamp: 1660028311
- exit_code: 1
  program: "\n/// Create a function encrypt that takes a string as an argument and\n\
    /// returns a string encrypted with the alphabet being rotated. \n/// The alphabet\
    \ should be rotated in a manner such that the letters \n/// shift down by two\
    \ multiplied to two places.\n/// For example:\n/// >>> encrypt(s: \"hi\")\n///\
    \ \"lm\"\n/// >>> encrypt(s: \"asdfghjkl\")\n/// \"ewhjklnop\"\n/// >>> encrypt(s:\
    \ \"gf\")\n/// \"kj\"\n/// >>> encrypt(s: \"et\")\n/// \"ix\"\nfunc encrypt(s:\
    \ String) -> String {\n    var result = \"\"\n    for char in s {\n        let\
    \ index = getIndex(char: char)\n        result += getCharacter(index: index)\n\
    \    }\n    return result\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(encrypt(s:\
    \ \"hi\") == \"lm\")\nassert(encrypt(s: \"asdfghjkl\") == \"ewhjklnop\")\nassert(encrypt(s:\
    \ \"gf\") == \"kj\")\nassert(encrypt(s: \"et\") == \"ix\")\nassert(encrypt(s:\
    \ \"faewfawefaewg\") == \"jeiajeaijeiak\")\nassert(encrypt(s: \"hellomyfriend\"\
    ) == \"lippsqcjvmirh\")\nassert(encrypt(s: \"dxzdlmnilfuhmilufhlihufnmlimnufhlimnufhfucufh\"\
    ) == \"hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl\")\nassert(encrypt(s: \"\
    a\") == \"e\")"
  status: SyntaxError
  stderr: "/tmp/tmp7gy9n050.swift:18:21: error: cannot find 'getIndex' in scope\n\
    \        let index = getIndex(char: char)\n                    ^~~~~~~~\n/tmp/tmp7gy9n050.swift:19:19:\
    \ error: cannot find 'getCharacter' in scope\n        result += getCharacter(index:\
    \ index)\n                  ^~~~~~~~~~~~\n"
  stdout: ''
  timestamp: 1660028311
- exit_code: 1
  program: "\n/// Create a function encrypt that takes a string as an argument and\n\
    /// returns a string encrypted with the alphabet being rotated. \n/// The alphabet\
    \ should be rotated in a manner such that the letters \n/// shift down by two\
    \ multiplied to two places.\n/// For example:\n/// >>> encrypt(s: \"hi\")\n///\
    \ \"lm\"\n/// >>> encrypt(s: \"asdfghjkl\")\n/// \"ewhjklnop\"\n/// >>> encrypt(s:\
    \ \"gf\")\n/// \"kj\"\n/// >>> encrypt(s: \"et\")\n/// \"ix\"\nfunc encrypt(s:\
    \ String) -> String {\n    var ret: String = \"\"\n    for char in s {\n     \
    \   let t = Character(UnicodeScalar(UInt8(char.asciiValue!) + 2 * 2)!)\n     \
    \   ret.append(t)\n    }\n    return ret\n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(encrypt(s: \"hi\") == \"lm\")\nassert(encrypt(s: \"asdfghjkl\") == \"ewhjklnop\"\
    )\nassert(encrypt(s: \"gf\") == \"kj\")\nassert(encrypt(s: \"et\") == \"ix\")\n\
    assert(encrypt(s: \"faewfawefaewg\") == \"jeiajeaijeiak\")\nassert(encrypt(s:\
    \ \"hellomyfriend\") == \"lippsqcjvmirh\")\nassert(encrypt(s: \"dxzdlmnilfuhmilufhlihufnmlimnufhlimnufhfucufh\"\
    ) == \"hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl\")\nassert(encrypt(s: \"\
    a\") == \"e\")"
  status: SyntaxError
  stderr: "/tmp/tmpy5fg6sdh.swift:18:73: error: cannot force unwrap value of non-optional\
    \ type 'UnicodeScalar' (aka 'Unicode.Scalar')\n        let t = Character(UnicodeScalar(UInt8(char.asciiValue!)\
    \ + 2 * 2)!)\n                          ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~^\n\
    \                                                                        \n"
  stdout: ''
  timestamp: 1660028312
- exit_code: 1
  program: "\n/// Create a function encrypt that takes a string as an argument and\n\
    /// returns a string encrypted with the alphabet being rotated. \n/// The alphabet\
    \ should be rotated in a manner such that the letters \n/// shift down by two\
    \ multiplied to two places.\n/// For example:\n/// >>> encrypt(s: \"hi\")\n///\
    \ \"lm\"\n/// >>> encrypt(s: \"asdfghjkl\")\n/// \"ewhjklnop\"\n/// >>> encrypt(s:\
    \ \"gf\")\n/// \"kj\"\n/// >>> encrypt(s: \"et\")\n/// \"ix\"\nfunc encrypt(s:\
    \ String) -> String {\n    let lowercaseChars = s.lowercased().characters\n  \
    \  let lowercaseAlphabet = Alphabet.lowercase.values\n    var encrypted = \"\"\
    \n    for char in lowercaseChars {\n        if let index = lowercaseAlphabet.index(of:\
    \ char) {\n            let encryptedIndex = (index + (2 * 2)) % lowercaseAlphabet.count\n\
    \            encrypted.append(lowercaseAlphabet[encryptedIndex])\n        }\n\
    \    }\n    return encrypted\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int,\
    \ Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n\
    \    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n          \
    \  return false\n        }\n    }\n    return true\n}\n            \nassert(encrypt(s:\
    \ \"hi\") == \"lm\")\nassert(encrypt(s: \"asdfghjkl\") == \"ewhjklnop\")\nassert(encrypt(s:\
    \ \"gf\") == \"kj\")\nassert(encrypt(s: \"et\") == \"ix\")\nassert(encrypt(s:\
    \ \"faewfawefaewg\") == \"jeiajeaijeiak\")\nassert(encrypt(s: \"hellomyfriend\"\
    ) == \"lippsqcjvmirh\")\nassert(encrypt(s: \"dxzdlmnilfuhmilufhlihufnmlimnufhlimnufhfucufh\"\
    ) == \"hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl\")\nassert(encrypt(s: \"\
    a\") == \"e\")"
  status: SyntaxError
  stderr: "/tmp/tmpoly2oq_f.swift:16:41: error: 'characters' is unavailable: Please\
    \ use String directly\n    let lowercaseChars = s.lowercased().characters\n  \
    \                                      ^~~~~~~~~~\nSwift.String:5:16: note: 'characters'\
    \ was obsoleted in Swift 5.0\n    public var characters: String { get set }\n\
    \               ^\n/tmp/tmpoly2oq_f.swift:17:29: error: cannot find 'Alphabet'\
    \ in scope\n    let lowercaseAlphabet = Alphabet.lowercase.values\n          \
    \                  ^~~~~~~~\n"
  stdout: ''
  timestamp: 1660028311
- exit_code: -4
  program: "\n/// Create a function encrypt that takes a string as an argument and\n\
    /// returns a string encrypted with the alphabet being rotated. \n/// The alphabet\
    \ should be rotated in a manner such that the letters \n/// shift down by two\
    \ multiplied to two places.\n/// For example:\n/// >>> encrypt(s: \"hi\")\n///\
    \ \"lm\"\n/// >>> encrypt(s: \"asdfghjkl\")\n/// \"ewhjklnop\"\n/// >>> encrypt(s:\
    \ \"gf\")\n/// \"kj\"\n/// >>> encrypt(s: \"et\")\n/// \"ix\"\nfunc encrypt(s:\
    \ String) -> String {\n    let shift = -2 * 2\n    var output = \"\"\n    let\
    \ chars = Array(s)\n    for c in chars {\n        let unicode = c.unicodeScalars.first!.value\n\
    \        var shifted = unicode + UInt32(shift)\n        if shifted < 97 {\n  \
    \          shifted += 26\n        }\n        output.append(Character(UnicodeScalar(shifted)!))\n\
    \    }\n    return output\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(encrypt(s:\
    \ \"hi\") == \"lm\")\nassert(encrypt(s: \"asdfghjkl\") == \"ewhjklnop\")\nassert(encrypt(s:\
    \ \"gf\") == \"kj\")\nassert(encrypt(s: \"et\") == \"ix\")\nassert(encrypt(s:\
    \ \"faewfawefaewg\") == \"jeiajeaijeiak\")\nassert(encrypt(s: \"hellomyfriend\"\
    ) == \"lippsqcjvmirh\")\nassert(encrypt(s: \"dxzdlmnilfuhmilufhlihufnmlimnufhlimnufhfucufh\"\
    ) == \"hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl\")\nassert(encrypt(s: \"\
    a\") == \"e\")"
  status: Exception
  stderr: 'Swift/Integers.swift:3443: Fatal error: Negative value is not representable

    Current stack trace:

    0    libswiftCore.so                    0x00002ae1533ecc80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002ae1530e3561 <unavailable> + 1434977

    2    libswiftCore.so                    0x00002ae1530e3286 <unavailable> + 1434246

    3    libswiftCore.so                    0x00002ae1530e313c <unavailable> + 1433916

    4    libswiftCore.so                    0x00002ae1530e2bb0 _assertionFailure(_:_:file:line:flags:)
    + 251

    5    libswiftCore.so                    0x00002ae1530e1b0d <unavailable> + 1428237

    6    tmpefbnna67                        0x00005642e0c875ee <unavailable> + 9710

    7    tmpefbnna67                        0x00005642e0c86a16 <unavailable> + 6678

    8    libc.so.6                          0x00002ae1535d8460 __libc_start_main +
    245

    9    tmpefbnna67                        0x00005642e0c86719 <unavailable> + 5913

    '
  stdout: ''
  timestamp: 1660028311
- exit_code: -4
  program: "\n/// Create a function encrypt that takes a string as an argument and\n\
    /// returns a string encrypted with the alphabet being rotated. \n/// The alphabet\
    \ should be rotated in a manner such that the letters \n/// shift down by two\
    \ multiplied to two places.\n/// For example:\n/// >>> encrypt(s: \"hi\")\n///\
    \ \"lm\"\n/// >>> encrypt(s: \"asdfghjkl\")\n/// \"ewhjklnop\"\n/// >>> encrypt(s:\
    \ \"gf\")\n/// \"kj\"\n/// >>> encrypt(s: \"et\")\n/// \"ix\"\nfunc encrypt(s:\
    \ String) -> String {\n    return \"\"\n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(encrypt(s: \"hi\") == \"lm\")\nassert(encrypt(s: \"asdfghjkl\") == \"ewhjklnop\"\
    )\nassert(encrypt(s: \"gf\") == \"kj\")\nassert(encrypt(s: \"et\") == \"ix\")\n\
    assert(encrypt(s: \"faewfawefaewg\") == \"jeiajeaijeiak\")\nassert(encrypt(s:\
    \ \"hellomyfriend\") == \"lippsqcjvmirh\")\nassert(encrypt(s: \"dxzdlmnilfuhmilufhlihufnmlimnufhlimnufhfucufh\"\
    ) == \"hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl\")\nassert(encrypt(s: \"\
    a\") == \"e\")"
  status: Exception
  stderr: 'tmpxsqxg1op/tmpxsqxg1op.swift:32: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b607b4a6c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b607b19db6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b607b19d988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b607b19c7b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpxsqxg1op                        0x00005575dd252307 <unavailable> + 4871

    5    libc.so.6                          0x00002b607b692460 __libc_start_main +
    245

    6    tmpxsqxg1op                        0x00005575dd251f49 <unavailable> + 3913

    '
  stdout: ''
  timestamp: 1660028310
- exit_code: 1
  program: "\n/// Create a function encrypt that takes a string as an argument and\n\
    /// returns a string encrypted with the alphabet being rotated. \n/// The alphabet\
    \ should be rotated in a manner such that the letters \n/// shift down by two\
    \ multiplied to two places.\n/// For example:\n/// >>> encrypt(s: \"hi\")\n///\
    \ \"lm\"\n/// >>> encrypt(s: \"asdfghjkl\")\n/// \"ewhjklnop\"\n/// >>> encrypt(s:\
    \ \"gf\")\n/// \"kj\"\n/// >>> encrypt(s: \"et\")\n/// \"ix\"\nfunc encrypt(s:\
    \ String) -> String {\n    let alphabet: [Character] = [\"a\", \"b\", \"c\", \"\
    d\", \"e\", \"f\", \"g\", \"h\", \"i\", \"j\", \"k\", \"l\", \"m\", \"n\", \"\
    o\", \"p\", \"q\", \"r\", \"s\", \"t\", \"u\", \"v\", \"w\", \"x\", \"y\", \"\
    z\"]\n    var encrypted: [Character] = [\"\"]\n    for char in s {\n        if\
    \ let index = alphabet.firstIndex(of: char) {\n            if index < 21 {\n \
    \               encrypted.append(alphabet[index + 4])\n            } else {\n\
    \                encrypted.append(alphabet[index - 2])\n            }\n      \
    \  }\n    }\n    return String(encrypted)\n}\n\n\nfunc ==(left: [(Int, Int)],\
    \ right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n       \
    \ return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r\
    \ {\n            return false\n        }\n    }\n    return true\n}\n        \
    \    \nassert(encrypt(s: \"hi\") == \"lm\")\nassert(encrypt(s: \"asdfghjkl\")\
    \ == \"ewhjklnop\")\nassert(encrypt(s: \"gf\") == \"kj\")\nassert(encrypt(s: \"\
    et\") == \"ix\")\nassert(encrypt(s: \"faewfawefaewg\") == \"jeiajeaijeiak\")\n\
    assert(encrypt(s: \"hellomyfriend\") == \"lippsqcjvmirh\")\nassert(encrypt(s:\
    \ \"dxzdlmnilfuhmilufhlihufnmlimnufhlimnufhfucufh\") == \"hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl\"\
    )\nassert(encrypt(s: \"a\") == \"e\")"
  status: SyntaxError
  stderr: "/tmp/tmpvsdm00f3.swift:17:35: error: cannot convert value of type 'String'\
    \ to expected element type 'Character'\n    var encrypted: [Character] = [\"\"\
    ]\n                                  ^\n"
  stdout: ''
  timestamp: 1660028311
- exit_code: -4
  program: "\n/// Create a function encrypt that takes a string as an argument and\n\
    /// returns a string encrypted with the alphabet being rotated. \n/// The alphabet\
    \ should be rotated in a manner such that the letters \n/// shift down by two\
    \ multiplied to two places.\n/// For example:\n/// >>> encrypt(s: \"hi\")\n///\
    \ \"lm\"\n/// >>> encrypt(s: \"asdfghjkl\")\n/// \"ewhjklnop\"\n/// >>> encrypt(s:\
    \ \"gf\")\n/// \"kj\"\n/// >>> encrypt(s: \"et\")\n/// \"ix\"\nfunc encrypt(s:\
    \ String) -> String {\n    let size = s.count\n    let alphabet : [Character]\
    \ = [\"a\", \"b\", \"c\", \"d\", \"e\", \"f\", \"g\", \"h\", \"i\", \"j\", \"\
    k\", \"l\", \"m\", \"n\", \"o\", \"p\", \"q\", \"r\", \"s\", \"t\", \"u\", \"\
    v\", \"w\", \"x\", \"y\", \"z\"]\n    var encryptedString : String = \"\"\n  \
    \  var alphabetIndex : Int = 0\n    for i in s.indices {\n        let currentCharacter\
    \ : Character = s[i]\n        for j in alphabet.indices {\n            if alphabet[j]\
    \ == currentCharacter {\n                alphabetIndex = j\n                alphabetIndex\
    \ = alphabetIndex + 2\n                if alphabetIndex == 26 {\n            \
    \        alphabetIndex = alphabetIndex - 26\n                }\n             \
    \   encryptedString.append(alphabet[alphabetIndex])\n            }\n        }\n\
    \    }\n    return encryptedString\n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(encrypt(s: \"hi\") == \"lm\")\nassert(encrypt(s: \"asdfghjkl\") == \"ewhjklnop\"\
    )\nassert(encrypt(s: \"gf\") == \"kj\")\nassert(encrypt(s: \"et\") == \"ix\")\n\
    assert(encrypt(s: \"faewfawefaewg\") == \"jeiajeaijeiak\")\nassert(encrypt(s:\
    \ \"hellomyfriend\") == \"lippsqcjvmirh\")\nassert(encrypt(s: \"dxzdlmnilfuhmilufhlihufnmlimnufhlimnufhfucufh\"\
    ) == \"hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl\")\nassert(encrypt(s: \"\
    a\") == \"e\")"
  status: Exception
  stderr: 'tmpyj5d224p/tmpyj5d224p.swift:49: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b0938226c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b0937f1db6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b0937f1d988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b0937f1c7b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpyj5d224p                        0x000055d908429a47 <unavailable> + 6727

    5    libc.so.6                          0x00002b0938412460 __libc_start_main +
    245

    6    tmpyj5d224p                        0x000055d908429689 <unavailable> + 5769

    '
  stdout: ''
  timestamp: 1660028311
- exit_code: -4
  program: "\n/// Create a function encrypt that takes a string as an argument and\n\
    /// returns a string encrypted with the alphabet being rotated. \n/// The alphabet\
    \ should be rotated in a manner such that the letters \n/// shift down by two\
    \ multiplied to two places.\n/// For example:\n/// >>> encrypt(s: \"hi\")\n///\
    \ \"lm\"\n/// >>> encrypt(s: \"asdfghjkl\")\n/// \"ewhjklnop\"\n/// >>> encrypt(s:\
    \ \"gf\")\n/// \"kj\"\n/// >>> encrypt(s: \"et\")\n/// \"ix\"\nfunc encrypt(s:\
    \ String) -> String {\n    let alphabet = \"abcdefghijklmnopqrstuvwxyz\"\n   \
    \ var sAlphabet = \"\"\n    for char in s {\n        for (index, _) in alphabet.enumerated()\
    \ {\n            if char == alphabet[alphabet.index(alphabet.startIndex, offsetBy:\
    \ index)] {\n                sAlphabet.append(alphabet[alphabet.index(alphabet.startIndex,\
    \ offsetBy: index + 2)])\n            }\n        }\n    }\n    return sAlphabet\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(encrypt(s: \"hi\") == \"lm\")\nassert(encrypt(s:\
    \ \"asdfghjkl\") == \"ewhjklnop\")\nassert(encrypt(s: \"gf\") == \"kj\")\nassert(encrypt(s:\
    \ \"et\") == \"ix\")\nassert(encrypt(s: \"faewfawefaewg\") == \"jeiajeaijeiak\"\
    )\nassert(encrypt(s: \"hellomyfriend\") == \"lippsqcjvmirh\")\nassert(encrypt(s:\
    \ \"dxzdlmnilfuhmilufhlihufnmlimnufhlimnufhfucufh\") == \"hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl\"\
    )\nassert(encrypt(s: \"a\") == \"e\")"
  status: Exception
  stderr: 'tmpo4d1ohbi/tmpo4d1ohbi.swift:41: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002af002b62c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002af002859b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002af002859988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002af0028587b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpo4d1ohbi                        0x00005570e8efc807 <unavailable> + 6151

    5    libc.so.6                          0x00002af002d4e460 __libc_start_main +
    245

    6    tmpo4d1ohbi                        0x00005570e8efc449 <unavailable> + 5193

    '
  stdout: ''
  timestamp: 1660028311
- exit_code: 1
  program: "\n/// Create a function encrypt that takes a string as an argument and\n\
    /// returns a string encrypted with the alphabet being rotated. \n/// The alphabet\
    \ should be rotated in a manner such that the letters \n/// shift down by two\
    \ multiplied to two places.\n/// For example:\n/// >>> encrypt(s: \"hi\")\n///\
    \ \"lm\"\n/// >>> encrypt(s: \"asdfghjkl\")\n/// \"ewhjklnop\"\n/// >>> encrypt(s:\
    \ \"gf\")\n/// \"kj\"\n/// >>> encrypt(s: \"et\")\n/// \"ix\"\nfunc encrypt(s:\
    \ String) -> String {\n    return alphabetShift(string: s, shift: 2)\n}\n\n\n\
    func ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(encrypt(s: \"hi\") == \"lm\")\nassert(encrypt(s:\
    \ \"asdfghjkl\") == \"ewhjklnop\")\nassert(encrypt(s: \"gf\") == \"kj\")\nassert(encrypt(s:\
    \ \"et\") == \"ix\")\nassert(encrypt(s: \"faewfawefaewg\") == \"jeiajeaijeiak\"\
    )\nassert(encrypt(s: \"hellomyfriend\") == \"lippsqcjvmirh\")\nassert(encrypt(s:\
    \ \"dxzdlmnilfuhmilufhlihufnmlimnufhlimnufhfucufh\") == \"hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl\"\
    )\nassert(encrypt(s: \"a\") == \"e\")"
  status: SyntaxError
  stderr: "/tmp/tmpfbxhazcy.swift:16:12: error: cannot find 'alphabetShift' in scope\n\
    \    return alphabetShift(string: s, shift: 2)\n           ^~~~~~~~~~~~~\n"
  stdout: ''
  timestamp: 1660028311
- exit_code: 1
  program: "\n/// Create a function encrypt that takes a string as an argument and\n\
    /// returns a string encrypted with the alphabet being rotated. \n/// The alphabet\
    \ should be rotated in a manner such that the letters \n/// shift down by two\
    \ multiplied to two places.\n/// For example:\n/// >>> encrypt(s: \"hi\")\n///\
    \ \"lm\"\n/// >>> encrypt(s: \"asdfghjkl\")\n/// \"ewhjklnop\"\n/// >>> encrypt(s:\
    \ \"gf\")\n/// \"kj\"\n/// >>> encrypt(s: \"et\")\n/// \"ix\"\nfunc encrypt(s:\
    \ String) -> String {\n    var res = \"\"\n    for char in s {\n        var i\
    \ = char.toInt() - 97\n        i = (i + 4) % 26\n        let c = Character(UnicodeScalar(i\
    \ + 97)!)\n        res += String(c)\n    }\n    return res\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(encrypt(s: \"hi\") == \"lm\")\nassert(encrypt(s: \"asdfghjkl\"\
    ) == \"ewhjklnop\")\nassert(encrypt(s: \"gf\") == \"kj\")\nassert(encrypt(s: \"\
    et\") == \"ix\")\nassert(encrypt(s: \"faewfawefaewg\") == \"jeiajeaijeiak\")\n\
    assert(encrypt(s: \"hellomyfriend\") == \"lippsqcjvmirh\")\nassert(encrypt(s:\
    \ \"dxzdlmnilfuhmilufhlihufnmlimnufhlimnufhfucufh\") == \"hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl\"\
    )\nassert(encrypt(s: \"a\") == \"e\")"
  status: SyntaxError
  stderr: "/tmp/tmpwhc1t3a6.swift:18:22: error: value of type 'Character' has no member\
    \ 'toInt'\n        var i = char.toInt() - 97\n                ~~~~ ^~~~~\n"
  stdout: ''
  timestamp: 1660028311
- exit_code: -4
  program: "\n/// Create a function encrypt that takes a string as an argument and\n\
    /// returns a string encrypted with the alphabet being rotated. \n/// The alphabet\
    \ should be rotated in a manner such that the letters \n/// shift down by two\
    \ multiplied to two places.\n/// For example:\n/// >>> encrypt(s: \"hi\")\n///\
    \ \"lm\"\n/// >>> encrypt(s: \"asdfghjkl\")\n/// \"ewhjklnop\"\n/// >>> encrypt(s:\
    \ \"gf\")\n/// \"kj\"\n/// >>> encrypt(s: \"et\")\n/// \"ix\"\nfunc encrypt(s:\
    \ String) -> String {\n    var result = \"\"\n    for c in s {\n        if c ==\
    \ \"z\" {\n            result.append(\"b\")\n        } else if c == \"y\" {\n\
    \            result.append(\"a\")\n        } else {\n            let unicode =\
    \ c.unicodeScalars.first!.value\n            let newUnicode = unicode + 2\n  \
    \          let newCharacter = String(UnicodeScalar(newUnicode)!)\n           \
    \ result.append(newCharacter)\n        }\n    }\n    return result\n}\n\n\nfunc\
    \ ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count !=\
    \ right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(encrypt(s: \"hi\") == \"lm\")\nassert(encrypt(s:\
    \ \"asdfghjkl\") == \"ewhjklnop\")\nassert(encrypt(s: \"gf\") == \"kj\")\nassert(encrypt(s:\
    \ \"et\") == \"ix\")\nassert(encrypt(s: \"faewfawefaewg\") == \"jeiajeaijeiak\"\
    )\nassert(encrypt(s: \"hellomyfriend\") == \"lippsqcjvmirh\")\nassert(encrypt(s:\
    \ \"dxzdlmnilfuhmilufhlihufnmlimnufhlimnufhfucufh\") == \"hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl\"\
    )\nassert(encrypt(s: \"a\") == \"e\")"
  status: Exception
  stderr: 'tmpeawgwa8z/tmpeawgwa8z.swift:45: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002ba84ce77c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002ba84cb6eb6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002ba84cb6e988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002ba84cb6d7b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpeawgwa8z                        0x0000561dfdaa4827 <unavailable> + 6183

    5    libc.so.6                          0x00002ba84d063460 __libc_start_main +
    245

    6    tmpeawgwa8z                        0x0000561dfdaa4469 <unavailable> + 5225

    '
  stdout: ''
  timestamp: 1660028311
- exit_code: -4
  program: "\n/// Create a function encrypt that takes a string as an argument and\n\
    /// returns a string encrypted with the alphabet being rotated. \n/// The alphabet\
    \ should be rotated in a manner such that the letters \n/// shift down by two\
    \ multiplied to two places.\n/// For example:\n/// >>> encrypt(s: \"hi\")\n///\
    \ \"lm\"\n/// >>> encrypt(s: \"asdfghjkl\")\n/// \"ewhjklnop\"\n/// >>> encrypt(s:\
    \ \"gf\")\n/// \"kj\"\n/// >>> encrypt(s: \"et\")\n/// \"ix\"\nfunc encrypt(s:\
    \ String) -> String {\n    let str = s.uppercased()\n    var newStr = \"\"\n \
    \   for c in str {\n        if let u = UnicodeScalar(String(c)) {\n          \
    \  if u.value + (2 * 2) <= 90 {\n                newStr.append(Character(UnicodeScalar(u.value\
    \ + (2 * 2))!))\n            } else {\n                newStr.append(Character(UnicodeScalar(u.value\
    \ + (2 * 2) - 90 + 64)!))\n            }\n        }\n    }\n    return newStr\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(encrypt(s: \"hi\") == \"lm\")\nassert(encrypt(s:\
    \ \"asdfghjkl\") == \"ewhjklnop\")\nassert(encrypt(s: \"gf\") == \"kj\")\nassert(encrypt(s:\
    \ \"et\") == \"ix\")\nassert(encrypt(s: \"faewfawefaewg\") == \"jeiajeaijeiak\"\
    )\nassert(encrypt(s: \"hellomyfriend\") == \"lippsqcjvmirh\")\nassert(encrypt(s:\
    \ \"dxzdlmnilfuhmilufhlihufnmlimnufhlimnufhfucufh\") == \"hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl\"\
    )\nassert(encrypt(s: \"a\") == \"e\")"
  status: Exception
  stderr: 'tmp9oo3682f/tmp9oo3682f.swift:43: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002ab7ee906c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002ab7ee5fdb6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002ab7ee5fd988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002ab7ee5fc7b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmp9oo3682f                        0x0000560f20c9a6d7 <unavailable> + 5847

    5    libc.so.6                          0x00002ab7eeaf2460 __libc_start_main +
    245

    6    tmp9oo3682f                        0x0000560f20c9a319 <unavailable> + 4889

    '
  stdout: ''
  timestamp: 1660028311
- exit_code: 1
  program: "\n/// Create a function encrypt that takes a string as an argument and\n\
    /// returns a string encrypted with the alphabet being rotated. \n/// The alphabet\
    \ should be rotated in a manner such that the letters \n/// shift down by two\
    \ multiplied to two places.\n/// For example:\n/// >>> encrypt(s: \"hi\")\n///\
    \ \"lm\"\n/// >>> encrypt(s: \"asdfghjkl\")\n/// \"ewhjklnop\"\n/// >>> encrypt(s:\
    \ \"gf\")\n/// \"kj\"\n/// >>> encrypt(s: \"et\")\n/// \"ix\"\nfunc encrypt(s:\
    \ String) -> String {\n    var array: [Character] = []\n    for character in s\
    \ {\n        array.append(character)\n    }\n    var encryptedArray: [Character]\
    \ = []\n    for character in array {\n        let newCharacter = character.shiftDown(by:\
    \ 2)\n        encryptedArray.append(newCharacter)\n    }\n    var encrypted: String\
    \ = \"\"\n    for character in encryptedArray {\n        encrypted += String(character)\n\
    \    }\n    return encrypted\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int,\
    \ Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n\
    \    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n          \
    \  return false\n        }\n    }\n    return true\n}\n            \nassert(encrypt(s:\
    \ \"hi\") == \"lm\")\nassert(encrypt(s: \"asdfghjkl\") == \"ewhjklnop\")\nassert(encrypt(s:\
    \ \"gf\") == \"kj\")\nassert(encrypt(s: \"et\") == \"ix\")\nassert(encrypt(s:\
    \ \"faewfawefaewg\") == \"jeiajeaijeiak\")\nassert(encrypt(s: \"hellomyfriend\"\
    ) == \"lippsqcjvmirh\")\nassert(encrypt(s: \"dxzdlmnilfuhmilufhlihufnmlimnufhlimnufhfucufh\"\
    ) == \"hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl\")\nassert(encrypt(s: \"\
    a\") == \"e\")"
  status: SyntaxError
  stderr: "/tmp/tmp9my7v3wn.swift:22:38: error: value of type 'Character' has no member\
    \ 'shiftDown'\n        let newCharacter = character.shiftDown(by: 2)\n       \
    \                    ~~~~~~~~~ ^~~~~~~~~\n"
  stdout: ''
  timestamp: 1660028311
- exit_code: -4
  program: "\n/// Create a function encrypt that takes a string as an argument and\n\
    /// returns a string encrypted with the alphabet being rotated. \n/// The alphabet\
    \ should be rotated in a manner such that the letters \n/// shift down by two\
    \ multiplied to two places.\n/// For example:\n/// >>> encrypt(s: \"hi\")\n///\
    \ \"lm\"\n/// >>> encrypt(s: \"asdfghjkl\")\n/// \"ewhjklnop\"\n/// >>> encrypt(s:\
    \ \"gf\")\n/// \"kj\"\n/// >>> encrypt(s: \"et\")\n/// \"ix\"\nfunc encrypt(s:\
    \ String) -> String {\n    // implement the function here.\n    return \"\"\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(encrypt(s: \"hi\") == \"lm\")\nassert(encrypt(s:\
    \ \"asdfghjkl\") == \"ewhjklnop\")\nassert(encrypt(s: \"gf\") == \"kj\")\nassert(encrypt(s:\
    \ \"et\") == \"ix\")\nassert(encrypt(s: \"faewfawefaewg\") == \"jeiajeaijeiak\"\
    )\nassert(encrypt(s: \"hellomyfriend\") == \"lippsqcjvmirh\")\nassert(encrypt(s:\
    \ \"dxzdlmnilfuhmilufhlihufnmlimnufhlimnufhfucufh\") == \"hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl\"\
    )\nassert(encrypt(s: \"a\") == \"e\")"
  status: Exception
  stderr: 'tmppe2kg_qe/tmppe2kg_qe.swift:33: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b6a98fa3c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b6a98c9ab6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b6a98c9a988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b6a98c997b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmppe2kg_qe                        0x0000559966cad307 <unavailable> + 4871

    5    libc.so.6                          0x00002b6a9918f460 __libc_start_main +
    245

    6    tmppe2kg_qe                        0x0000559966cacf49 <unavailable> + 3913

    '
  stdout: ''
  timestamp: 1660028311
- exit_code: -4
  program: "\n/// Create a function encrypt that takes a string as an argument and\n\
    /// returns a string encrypted with the alphabet being rotated. \n/// The alphabet\
    \ should be rotated in a manner such that the letters \n/// shift down by two\
    \ multiplied to two places.\n/// For example:\n/// >>> encrypt(s: \"hi\")\n///\
    \ \"lm\"\n/// >>> encrypt(s: \"asdfghjkl\")\n/// \"ewhjklnop\"\n/// >>> encrypt(s:\
    \ \"gf\")\n/// \"kj\"\n/// >>> encrypt(s: \"et\")\n/// \"ix\"\nfunc encrypt(s:\
    \ String) -> String {\n  // Enter your code below\n  return \"\";\n}\n\n\nfunc\
    \ ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count !=\
    \ right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(encrypt(s: \"hi\") == \"lm\")\nassert(encrypt(s:\
    \ \"asdfghjkl\") == \"ewhjklnop\")\nassert(encrypt(s: \"gf\") == \"kj\")\nassert(encrypt(s:\
    \ \"et\") == \"ix\")\nassert(encrypt(s: \"faewfawefaewg\") == \"jeiajeaijeiak\"\
    )\nassert(encrypt(s: \"hellomyfriend\") == \"lippsqcjvmirh\")\nassert(encrypt(s:\
    \ \"dxzdlmnilfuhmilufhlihufnmlimnufhlimnufhfucufh\") == \"hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl\"\
    )\nassert(encrypt(s: \"a\") == \"e\")"
  status: Exception
  stderr: 'tmpch4epjlv/tmpch4epjlv.swift:33: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b8d84f87c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b8d84c7eb6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b8d84c7e988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b8d84c7d7b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpch4epjlv                        0x00005653fee3a307 <unavailable> + 4871

    5    libc.so.6                          0x00002b8d85173460 __libc_start_main +
    245

    6    tmpch4epjlv                        0x00005653fee39f49 <unavailable> + 3913

    '
  stdout: ''
  timestamp: 1660028311
- exit_code: 1
  program: "\n/// Create a function encrypt that takes a string as an argument and\n\
    /// returns a string encrypted with the alphabet being rotated. \n/// The alphabet\
    \ should be rotated in a manner such that the letters \n/// shift down by two\
    \ multiplied to two places.\n/// For example:\n/// >>> encrypt(s: \"hi\")\n///\
    \ \"lm\"\n/// >>> encrypt(s: \"asdfghjkl\")\n/// \"ewhjklnop\"\n/// >>> encrypt(s:\
    \ \"gf\")\n/// \"kj\"\n/// >>> encrypt(s: \"et\")\n/// \"ix\"\nfunc encrypt(s:\
    \ String) -> String {\n    var s = s\n    let alphabet = [\"a\", \"b\", \"c\"\
    , \"d\", \"e\", \"f\", \"g\", \"h\", \"i\", \"j\", \"k\", \"l\", \"m\", \"n\"\
    , \"o\", \"p\", \"q\", \"r\", \"s\", \"t\", \"u\", \"v\", \"w\", \"x\", \"y\"\
    , \"z\"]\n    var encryptedString = \"\"\n    let letterCount = s.count\n    var\
    \ i = 0\n    while i < letterCount {\n        var letterIndex = 0\n        while\
    \ alphabet[letterIndex] != String(s.removeFirst()) {\n            letterIndex\
    \ += 1\n        }\n        if letterIndex == 0 {\n            encryptedString.append(contentsOf:\
    \ \"a\")\n        } else if letterIndex == 1 {\n            encryptedString.append(contentsOf:\
    \ \"b\")\n        } else if letterIndex == 2 {\n            encryptedString.append(contentsOf:\
    \ \"c\")\n        } else if letterIndex == 3 {\n            encryptedString.append(contentsOf:\
    \ \"d\")\n        } else if letterIndex == 4 {\n            encryptedString.append(contentsOf:\
    \ \"e\")\n        } else if letterIndex == 5 {\n            encryptedString.append(contentsOf:\
    \ \"f\")\n        } else if letterIndex == 6 {\n            encryptedString.append(contentsOf:\
    \ \"g\")\n        } else if letterIndex == 7 {\n            encryptedString.append(contentsOf:\
    \ \"h\")\n        } else if letterIndex == 8 {\n            encryptedString.append(contentsOf:\
    \ \"i\")\n        } else if letterIndex == 9 {\n            encryptedString.append(contentsOf:\
    \ \"j\")\n        } else if letterIndex == 10 {\n            encryptedString.append(contentsOf:\
    \ \"k\")\n        } else if letterIndex == 11 {\n            encryptedString.append(contentsOf:\
    \ \"l\")\n        } else if letterIndex == 12 {\n            encryptedString.append(contentsOf:\
    \ \"m\")\n        } else if letterIndex == 13 {\n            encryptedString.append(contentsOf:\
    \ \"n\")\n        } else if letterIndex == 14 {\n            encryptedString.append(contentsOf:\
    \ \"o\")\n       \n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) ->\
    \ Bool {\n    if left.count != right.count {\n        return false\n    }\n  \
    \  for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(encrypt(s: \"hi\"\
    ) == \"lm\")\nassert(encrypt(s: \"asdfghjkl\") == \"ewhjklnop\")\nassert(encrypt(s:\
    \ \"gf\") == \"kj\")\nassert(encrypt(s: \"et\") == \"ix\")\nassert(encrypt(s:\
    \ \"faewfawefaewg\") == \"jeiajeaijeiak\")\nassert(encrypt(s: \"hellomyfriend\"\
    ) == \"lippsqcjvmirh\")\nassert(encrypt(s: \"dxzdlmnilfuhmilufhlihufnmlimnufhlimnufhfucufh\"\
    ) == \"hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl\")\nassert(encrypt(s: \"\
    a\") == \"e\")"
  status: SyntaxError
  stderr: "/tmp/tmp8z0vol1p.swift:79:31: error: expected '}' at end of brace statement\n\
    assert(encrypt(s: \"a\") == \"e\")\n                              ^\n/tmp/tmp8z0vol1p.swift:21:27:\
    \ note: to match this opening '{'\n    while i < letterCount {\n             \
    \             ^\n/tmp/tmp8z0vol1p.swift:79:31: error: expected '}' at end of brace\
    \ statement\nassert(encrypt(s: \"a\") == \"e\")\n                            \
    \  ^\n/tmp/tmp8z0vol1p.swift:15:35: note: to match this opening '{'\nfunc encrypt(s:\
    \ String) -> String {\n                                  ^\n/tmp/tmp8z0vol1p.swift:60:6:\
    \ error: operator functions can only be declared at global or in type scope\n\
    func ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n     ^\n/tmp/tmp8z0vol1p.swift:20:9:\
    \ warning: variable 'i' was never mutated; consider changing to 'let' constant\n\
    \    var i = 0\n    ~~~ ^\n    let\n"
  stdout: ''
  timestamp: 1660028311
- exit_code: -4
  program: "\n/// Create a function encrypt that takes a string as an argument and\n\
    /// returns a string encrypted with the alphabet being rotated. \n/// The alphabet\
    \ should be rotated in a manner such that the letters \n/// shift down by two\
    \ multiplied to two places.\n/// For example:\n/// >>> encrypt(s: \"hi\")\n///\
    \ \"lm\"\n/// >>> encrypt(s: \"asdfghjkl\")\n/// \"ewhjklnop\"\n/// >>> encrypt(s:\
    \ \"gf\")\n/// \"kj\"\n/// >>> encrypt(s: \"et\")\n/// \"ix\"\nfunc encrypt(s:\
    \ String) -> String {\n    var newS = \"\"\n    for char in s {\n        var ascii\
    \ = char.asciiValue\n        ascii = (ascii! - 97 + 2) % 26 + 97\n        let\
    \ newChar = Character(UnicodeScalar(ascii!))\n        newS += String(newChar)\n\
    \    }\n    return newS\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(encrypt(s:\
    \ \"hi\") == \"lm\")\nassert(encrypt(s: \"asdfghjkl\") == \"ewhjklnop\")\nassert(encrypt(s:\
    \ \"gf\") == \"kj\")\nassert(encrypt(s: \"et\") == \"ix\")\nassert(encrypt(s:\
    \ \"faewfawefaewg\") == \"jeiajeaijeiak\")\nassert(encrypt(s: \"hellomyfriend\"\
    ) == \"lippsqcjvmirh\")\nassert(encrypt(s: \"dxzdlmnilfuhmilufhlihufnmlimnufhlimnufhfucufh\"\
    ) == \"hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl\")\nassert(encrypt(s: \"\
    a\") == \"e\")"
  status: Exception
  stderr: 'tmphep5q0y7/tmphep5q0y7.swift:39: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b9dacaa7c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b9dac79eb6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b9dac79e988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b9dac79d7b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmphep5q0y7                        0x0000558725726617 <unavailable> + 5655

    5    libc.so.6                          0x00002b9dacc93460 __libc_start_main +
    245

    6    tmphep5q0y7                        0x0000558725726259 <unavailable> + 4697

    '
  stdout: ''
  timestamp: 1660028311
- exit_code: 1
  program: "\n/// Create a function encrypt that takes a string as an argument and\n\
    /// returns a string encrypted with the alphabet being rotated. \n/// The alphabet\
    \ should be rotated in a manner such that the letters \n/// shift down by two\
    \ multiplied to two places.\n/// For example:\n/// >>> encrypt(s: \"hi\")\n///\
    \ \"lm\"\n/// >>> encrypt(s: \"asdfghjkl\")\n/// \"ewhjklnop\"\n/// >>> encrypt(s:\
    \ \"gf\")\n/// \"kj\"\n/// >>> encrypt(s: \"et\")\n/// \"ix\"\nfunc encrypt(s:\
    \ String) -> String {\n    // Hint: Use the alphabet letters `\"abcdefghijklmnopqrstuvwxyz\"\
    `\n    //\n    // Hint: Use the `String` function `prefix` to get an index\n \
    \   //       of the first character of a string.\n    //\n    // Hint: Use the\
    \ `String` function `suffix` to get an index\n    //       of the rest of the\
    \ characters.\n    //\n    // Hint: Use the `String` function `lowercased` to\
    \ get a\n    //       lowercase version of a string.\n    //\n    // Hint: Use\
    \ the `String` function `replacingOccurrences` to\n    //       replace the character\
    \ at an index.\n    //\n    // Hint: Use the `String` function `index` to get\
    \ the index\n    //       of a character.\n    //\n    // Hint: Use the `String`\
    \ function `indices` to get all\n    //       indices of a string.\n    //\n \
    \   // Hint: Use the `String` function `isEmpty` to check if a\n    //       string\
    \ is empty.\n    //\n    // Hint: Use the `String` function `insert` to insert\
    \ a\n    //       character at a certain index.\n    //\n    // Hint: Use the\
    \ `String` function `hasPrefix` to check if\n    //       a string has a certain\
    \ prefix.\n    //\n    // Hint: Use the `String` function `remove` to remove a\n\
    \    //       certain character from a string.\n    //\n    // Hint: Use the `String`\
    \ function `sorted` to sort\n    //       the characters of a string.\n    //\n\
    \    // Hint: Use the `Int` function `distance` to get the\n    //       distance\
    \ between two integers.\n    //\n    // Hint: Use the `String` function `joined`\
    \ to join the\n    //       characters of a string into a single string.\n   \
    \ //\n    // Hint: Use the `String` function `prefix` to get a\n    //       prefix\
    \ of a string.\n    //\n    // Hint: Use the `String` function `suffix` to get\
    \ a\n    //       suffix of a string.\n    //\n\n}\n\n\nfunc ==(left: [(Int, Int)],\
    \ right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n       \
    \ return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r\
    \ {\n            return false\n        }\n    }\n    return true\n}\n        \
    \    \nassert(encrypt(s: \"hi\") == \"lm\")\nassert(encrypt(s: \"asdfghjkl\")\
    \ == \"ewhjklnop\")\nassert(encrypt(s: \"gf\") == \"kj\")\nassert(encrypt(s: \"\
    et\") == \"ix\")\nassert(encrypt(s: \"faewfawefaewg\") == \"jeiajeaijeiak\")\n\
    assert(encrypt(s: \"hellomyfriend\") == \"lippsqcjvmirh\")\nassert(encrypt(s:\
    \ \"dxzdlmnilfuhmilufhlihufnmlimnufhlimnufhfucufh\") == \"hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl\"\
    )\nassert(encrypt(s: \"a\") == \"e\")"
  status: SyntaxError
  stderr: '/tmp/tmpzqx0nazb.swift:64:1: error: missing return in global function expected
    to return ''String''

    }

    ^

    '
  stdout: ''
  timestamp: 1660028311
- exit_code: -4
  program: "\n/// Create a function encrypt that takes a string as an argument and\n\
    /// returns a string encrypted with the alphabet being rotated. \n/// The alphabet\
    \ should be rotated in a manner such that the letters \n/// shift down by two\
    \ multiplied to two places.\n/// For example:\n/// >>> encrypt(s: \"hi\")\n///\
    \ \"lm\"\n/// >>> encrypt(s: \"asdfghjkl\")\n/// \"ewhjklnop\"\n/// >>> encrypt(s:\
    \ \"gf\")\n/// \"kj\"\n/// >>> encrypt(s: \"et\")\n/// \"ix\"\nfunc encrypt(s:\
    \ String) -> String {\n    let asciiArr = s.unicodeScalars.map { (scalar) -> UInt32\
    \ in\n        scalar.value\n    }\n    let newArr = asciiArr.map { (ascii) ->\
    \ UInt32 in\n        if ascii == 122 {\n            return 122\n        } else\
    \ if ascii == 90 {\n            return 90\n        } else {\n            return\
    \ ascii + 2 * 2\n        }\n    }\n    let newChars = newArr.map { (ascii) ->\
    \ Character in\n        return Character(UnicodeScalar(ascii)!)\n    }\n    let\
    \ newString = String(newChars)\n    return newString\n}\n\n\nfunc ==(left: [(Int,\
    \ Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n\
    \        return false\n    }\n    for (l, r) in zip(left, right) {\n        if\
    \ l != r {\n            return false\n        }\n    }\n    return true\n}\n \
    \           \nassert(encrypt(s: \"hi\") == \"lm\")\nassert(encrypt(s: \"asdfghjkl\"\
    ) == \"ewhjklnop\")\nassert(encrypt(s: \"gf\") == \"kj\")\nassert(encrypt(s: \"\
    et\") == \"ix\")\nassert(encrypt(s: \"faewfawefaewg\") == \"jeiajeaijeiak\")\n\
    assert(encrypt(s: \"hellomyfriend\") == \"lippsqcjvmirh\")\nassert(encrypt(s:\
    \ \"dxzdlmnilfuhmilufhlihufnmlimnufhlimnufhfucufh\") == \"hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl\"\
    )\nassert(encrypt(s: \"a\") == \"e\")"
  status: Exception
  stderr: 'tmph8oknrhi/tmph8oknrhi.swift:52: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b5a1343ac80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b5a13131b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b5a13131988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b5a131307b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmph8oknrhi                        0x000055ed1f314c2e <unavailable> + 7214

    5    libc.so.6                          0x00002b5a13626460 __libc_start_main +
    245

    6    tmph8oknrhi                        0x000055ed1f314429 <unavailable> + 5161

    '
  stdout: ''
  timestamp: 1660028311
- exit_code: 0
  program: "\n/// Create a function encrypt that takes a string as an argument and\n\
    /// returns a string encrypted with the alphabet being rotated. \n/// The alphabet\
    \ should be rotated in a manner such that the letters \n/// shift down by two\
    \ multiplied to two places.\n/// For example:\n/// >>> encrypt(s: \"hi\")\n///\
    \ \"lm\"\n/// >>> encrypt(s: \"asdfghjkl\")\n/// \"ewhjklnop\"\n/// >>> encrypt(s:\
    \ \"gf\")\n/// \"kj\"\n/// >>> encrypt(s: \"et\")\n/// \"ix\"\nfunc encrypt(s:\
    \ String) -> String {\n    \n    let alphabet = [\"a\", \"b\", \"c\", \"d\", \"\
    e\", \"f\", \"g\", \"h\", \"i\", \"j\", \"k\", \"l\", \"m\", \"n\", \"o\", \"\
    p\", \"q\", \"r\", \"s\", \"t\", \"u\", \"v\", \"w\", \"x\", \"y\", \"z\"]\n \
    \   \n    var encryptedString = \"\"\n    \n    var shift = 0\n    \n    for char\
    \ in s {\n        for (index, letter) in alphabet.enumerated() {\n           \
    \ if char == Character(letter) {\n                shift = index + 4\n        \
    \        if shift > 25 {\n                    shift = shift - 26\n           \
    \     }\n                encryptedString.append(alphabet[shift])\n           \
    \ }\n        }\n    }\n    return encryptedString\n}\n\n\nfunc ==(left: [(Int,\
    \ Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n\
    \        return false\n    }\n    for (l, r) in zip(left, right) {\n        if\
    \ l != r {\n            return false\n        }\n    }\n    return true\n}\n \
    \           \nassert(encrypt(s: \"hi\") == \"lm\")\nassert(encrypt(s: \"asdfghjkl\"\
    ) == \"ewhjklnop\")\nassert(encrypt(s: \"gf\") == \"kj\")\nassert(encrypt(s: \"\
    et\") == \"ix\")\nassert(encrypt(s: \"faewfawefaewg\") == \"jeiajeaijeiak\")\n\
    assert(encrypt(s: \"hellomyfriend\") == \"lippsqcjvmirh\")\nassert(encrypt(s:\
    \ \"dxzdlmnilfuhmilufhlihufnmlimnufhlimnufhfucufh\") == \"hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl\"\
    )\nassert(encrypt(s: \"a\") == \"e\")"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660028311
- exit_code: 0
  program: "\n/// Create a function encrypt that takes a string as an argument and\n\
    /// returns a string encrypted with the alphabet being rotated. \n/// The alphabet\
    \ should be rotated in a manner such that the letters \n/// shift down by two\
    \ multiplied to two places.\n/// For example:\n/// >>> encrypt(s: \"hi\")\n///\
    \ \"lm\"\n/// >>> encrypt(s: \"asdfghjkl\")\n/// \"ewhjklnop\"\n/// >>> encrypt(s:\
    \ \"gf\")\n/// \"kj\"\n/// >>> encrypt(s: \"et\")\n/// \"ix\"\nfunc encrypt(s:\
    \ String) -> String {\n    \n    let alphabet = Array(\"abcdefghijklmnopqrstuvwxyz\"\
    )\n    var shiftedAlphabet = alphabet\n    var encryptedString = \"\"\n    \n\
    \    for _ in 0...3 {\n        shiftedAlphabet.append(shiftedAlphabet.removeFirst())\n\
    \    }\n    \n    for letter in s {\n        let index = alphabet.firstIndex(of:\
    \ letter)\n        let encryptedLetter = shiftedAlphabet[index!]\n        encryptedString.append(encryptedLetter)\n\
    \    }\n    \n    return encryptedString\n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(encrypt(s: \"hi\") == \"lm\")\nassert(encrypt(s: \"asdfghjkl\") == \"ewhjklnop\"\
    )\nassert(encrypt(s: \"gf\") == \"kj\")\nassert(encrypt(s: \"et\") == \"ix\")\n\
    assert(encrypt(s: \"faewfawefaewg\") == \"jeiajeaijeiak\")\nassert(encrypt(s:\
    \ \"hellomyfriend\") == \"lippsqcjvmirh\")\nassert(encrypt(s: \"dxzdlmnilfuhmilufhlihufnmlimnufhlimnufhfucufh\"\
    ) == \"hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl\")\nassert(encrypt(s: \"\
    a\") == \"e\")"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660028311
- exit_code: -4
  program: "\n/// Create a function encrypt that takes a string as an argument and\n\
    /// returns a string encrypted with the alphabet being rotated. \n/// The alphabet\
    \ should be rotated in a manner such that the letters \n/// shift down by two\
    \ multiplied to two places.\n/// For example:\n/// >>> encrypt(s: \"hi\")\n///\
    \ \"lm\"\n/// >>> encrypt(s: \"asdfghjkl\")\n/// \"ewhjklnop\"\n/// >>> encrypt(s:\
    \ \"gf\")\n/// \"kj\"\n/// >>> encrypt(s: \"et\")\n/// \"ix\"\nfunc encrypt(s:\
    \ String) -> String {\n    var encryptedString = \"\"\n    let alphabet = \"abcdefghijklmnopqrstuvwxyz\"\
    \n    for i in s {\n        let index = alphabet.index(of: i)\n        let newIndex\
    \ = alphabet.index(index!, offsetBy: 2)\n        encryptedString += String(alphabet[newIndex])\n\
    \    }\n    return encryptedString\n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(encrypt(s: \"hi\") == \"lm\")\nassert(encrypt(s: \"asdfghjkl\") == \"ewhjklnop\"\
    )\nassert(encrypt(s: \"gf\") == \"kj\")\nassert(encrypt(s: \"et\") == \"ix\")\n\
    assert(encrypt(s: \"faewfawefaewg\") == \"jeiajeaijeiak\")\nassert(encrypt(s:\
    \ \"hellomyfriend\") == \"lippsqcjvmirh\")\nassert(encrypt(s: \"dxzdlmnilfuhmilufhlihufnmlimnufhlimnufhfucufh\"\
    ) == \"hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl\")\nassert(encrypt(s: \"\
    a\") == \"e\")"
  status: Exception
  stderr: 'tmp462vb8lt/tmp462vb8lt.swift:39: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002ac0f16fec80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002ac0f13f5b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002ac0f13f5988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002ac0f13f47b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmp462vb8lt                        0x0000555f508ee6d7 <unavailable> + 5847

    5    libc.so.6                          0x00002ac0f18ea460 __libc_start_main +
    245

    6    tmp462vb8lt                        0x0000555f508ee319 <unavailable> + 4889

    '
  stdout: ''
  timestamp: 1660028311
- exit_code: -4
  program: "\n/// Create a function encrypt that takes a string as an argument and\n\
    /// returns a string encrypted with the alphabet being rotated. \n/// The alphabet\
    \ should be rotated in a manner such that the letters \n/// shift down by two\
    \ multiplied to two places.\n/// For example:\n/// >>> encrypt(s: \"hi\")\n///\
    \ \"lm\"\n/// >>> encrypt(s: \"asdfghjkl\")\n/// \"ewhjklnop\"\n/// >>> encrypt(s:\
    \ \"gf\")\n/// \"kj\"\n/// >>> encrypt(s: \"et\")\n/// \"ix\"\nfunc encrypt(s:\
    \ String) -> String {\n  var string = \"\"\n  for char in s {\n    string += String(UnicodeScalar(Int(String(char))!\
    \ + 4)!)\n  }\n  return string\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int,\
    \ Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n\
    \    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n          \
    \  return false\n        }\n    }\n    return true\n}\n            \nassert(encrypt(s:\
    \ \"hi\") == \"lm\")\nassert(encrypt(s: \"asdfghjkl\") == \"ewhjklnop\")\nassert(encrypt(s:\
    \ \"gf\") == \"kj\")\nassert(encrypt(s: \"et\") == \"ix\")\nassert(encrypt(s:\
    \ \"faewfawefaewg\") == \"jeiajeaijeiak\")\nassert(encrypt(s: \"hellomyfriend\"\
    ) == \"lippsqcjvmirh\")\nassert(encrypt(s: \"dxzdlmnilfuhmilufhlihufnmlimnufhlimnufhfucufh\"\
    ) == \"hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl\")\nassert(encrypt(s: \"\
    a\") == \"e\")"
  status: Exception
  stderr: 'tmpe54wc_tv/tmpe54wc_tv.swift:18: Fatal error: Unexpectedly found nil while
    unwrapping an Optional value

    Current stack trace:

    0    libswiftCore.so                    0x00002b3ff49bfc80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b3ff46b6561 <unavailable> + 1434977

    2    libswiftCore.so                    0x00002b3ff46b6286 <unavailable> + 1434246

    3    libswiftCore.so                    0x00002b3ff46b613c <unavailable> + 1433916

    4    libswiftCore.so                    0x00002b3ff46b5bb0 _assertionFailure(_:_:file:line:flags:)
    + 251

    5    tmpe54wc_tv                        0x0000563931fd3ff7 <unavailable> + 8183

    6    tmpe54wc_tv                        0x0000563931fd35a6 <unavailable> + 5542

    7    libc.so.6                          0x00002b3ff4bab460 __libc_start_main +
    245

    8    tmpe54wc_tv                        0x0000563931fd32a9 <unavailable> + 4777

    '
  stdout: ''
  timestamp: 1660028311
- exit_code: -4
  program: "\n/// Create a function encrypt that takes a string as an argument and\n\
    /// returns a string encrypted with the alphabet being rotated. \n/// The alphabet\
    \ should be rotated in a manner such that the letters \n/// shift down by two\
    \ multiplied to two places.\n/// For example:\n/// >>> encrypt(s: \"hi\")\n///\
    \ \"lm\"\n/// >>> encrypt(s: \"asdfghjkl\")\n/// \"ewhjklnop\"\n/// >>> encrypt(s:\
    \ \"gf\")\n/// \"kj\"\n/// >>> encrypt(s: \"et\")\n/// \"ix\"\nfunc encrypt(s:\
    \ String) -> String {\n    return \"\"\n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(encrypt(s: \"hi\") == \"lm\")\nassert(encrypt(s: \"asdfghjkl\") == \"ewhjklnop\"\
    )\nassert(encrypt(s: \"gf\") == \"kj\")\nassert(encrypt(s: \"et\") == \"ix\")\n\
    assert(encrypt(s: \"faewfawefaewg\") == \"jeiajeaijeiak\")\nassert(encrypt(s:\
    \ \"hellomyfriend\") == \"lippsqcjvmirh\")\nassert(encrypt(s: \"dxzdlmnilfuhmilufhlihufnmlimnufhlimnufhfucufh\"\
    ) == \"hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl\")\nassert(encrypt(s: \"\
    a\") == \"e\")"
  status: Exception
  stderr: 'tmpxsqxg1op/tmpxsqxg1op.swift:32: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b607b4a6c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b607b19db6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b607b19d988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b607b19c7b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpxsqxg1op                        0x00005575dd252307 <unavailable> + 4871

    5    libc.so.6                          0x00002b607b692460 __libc_start_main +
    245

    6    tmpxsqxg1op                        0x00005575dd251f49 <unavailable> + 3913

    '
  stdout: ''
  timestamp: 1660028310
- exit_code: -4
  program: "\n/// Create a function encrypt that takes a string as an argument and\n\
    /// returns a string encrypted with the alphabet being rotated. \n/// The alphabet\
    \ should be rotated in a manner such that the letters \n/// shift down by two\
    \ multiplied to two places.\n/// For example:\n/// >>> encrypt(s: \"hi\")\n///\
    \ \"lm\"\n/// >>> encrypt(s: \"asdfghjkl\")\n/// \"ewhjklnop\"\n/// >>> encrypt(s:\
    \ \"gf\")\n/// \"kj\"\n/// >>> encrypt(s: \"et\")\n/// \"ix\"\nfunc encrypt(s:\
    \ String) -> String {\n    var result = \"\"\n    for ch in s {\n        result\
    \ += \"\\(Character(UnicodeScalar(Int(String(ch))! + 3)!))\"\n    }\n    return\
    \ result\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n\
    \    if left.count != right.count {\n        return false\n    }\n    for (l,\
    \ r) in zip(left, right) {\n        if l != r {\n            return false\n  \
    \      }\n    }\n    return true\n}\n            \nassert(encrypt(s: \"hi\") ==\
    \ \"lm\")\nassert(encrypt(s: \"asdfghjkl\") == \"ewhjklnop\")\nassert(encrypt(s:\
    \ \"gf\") == \"kj\")\nassert(encrypt(s: \"et\") == \"ix\")\nassert(encrypt(s:\
    \ \"faewfawefaewg\") == \"jeiajeaijeiak\")\nassert(encrypt(s: \"hellomyfriend\"\
    ) == \"lippsqcjvmirh\")\nassert(encrypt(s: \"dxzdlmnilfuhmilufhlihufnmlimnufhlimnufhfucufh\"\
    ) == \"hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl\")\nassert(encrypt(s: \"\
    a\") == \"e\")"
  status: Exception
  stderr: 'tmp1ge3epyw/tmp1ge3epyw.swift:18: Fatal error: Unexpectedly found nil while
    unwrapping an Optional value

    Current stack trace:

    0    libswiftCore.so                    0x00002ab00551ec80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002ab005215561 <unavailable> + 1434977

    2    libswiftCore.so                    0x00002ab005215286 <unavailable> + 1434246

    3    libswiftCore.so                    0x00002ab00521513c <unavailable> + 1433916

    4    libswiftCore.so                    0x00002ab005214bb0 _assertionFailure(_:_:file:line:flags:)
    + 251

    5    tmp1ge3epyw                        0x0000560f8de9d370 <unavailable> + 9072

    6    tmp1ge3epyw                        0x0000560f8de9c8a6 <unavailable> + 6310

    7    libc.so.6                          0x00002ab00570a460 __libc_start_main +
    245

    8    tmp1ge3epyw                        0x0000560f8de9c5a9 <unavailable> + 5545

    '
  stdout: ''
  timestamp: 1660028311
- exit_code: 1
  program: "\n/// Create a function encrypt that takes a string as an argument and\n\
    /// returns a string encrypted with the alphabet being rotated. \n/// The alphabet\
    \ should be rotated in a manner such that the letters \n/// shift down by two\
    \ multiplied to two places.\n/// For example:\n/// >>> encrypt(s: \"hi\")\n///\
    \ \"lm\"\n/// >>> encrypt(s: \"asdfghjkl\")\n/// \"ewhjklnop\"\n/// >>> encrypt(s:\
    \ \"gf\")\n/// \"kj\"\n/// >>> encrypt(s: \"et\")\n/// \"ix\"\nfunc encrypt(s:\
    \ String) -> String {\n    let alphabet = \"abcdefghijklmnopqrstuvwxyz\"\n   \
    \ var encryptedString = \"\"\n    for char in s {\n        if let idx = alphabet.firstIndex(of:\
    \ char) {\n            let newPosition = alphabet.index(idx, offsetBy: (idx <\
    \ idx + 4 ? 2 : -24))\n            encryptedString.append(alphabet[newPosition])\n\
    \        }\n    }\n    return encryptedString\n}\n\n\nfunc ==(left: [(Int, Int)],\
    \ right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n       \
    \ return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r\
    \ {\n            return false\n        }\n    }\n    return true\n}\n        \
    \    \nassert(encrypt(s: \"hi\") == \"lm\")\nassert(encrypt(s: \"asdfghjkl\")\
    \ == \"ewhjklnop\")\nassert(encrypt(s: \"gf\") == \"kj\")\nassert(encrypt(s: \"\
    et\") == \"ix\")\nassert(encrypt(s: \"faewfawefaewg\") == \"jeiajeaijeiak\")\n\
    assert(encrypt(s: \"hellomyfriend\") == \"lippsqcjvmirh\")\nassert(encrypt(s:\
    \ \"dxzdlmnilfuhmilufhlihufnmlimnufhlimnufhfucufh\") == \"hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl\"\
    )\nassert(encrypt(s: \"a\") == \"e\")"
  status: SyntaxError
  stderr: "/tmp/tmp2ktqauw2.swift:20:66: error: referencing operator function '<'\
    \ on 'BinaryInteger' requires that 'String.Index' conform to 'BinaryInteger'\n\
    \            let newPosition = alphabet.index(idx, offsetBy: (idx < idx + 4 ?\
    \ 2 : -24))\n                                                                \
    \ ^\nSwift.BinaryInteger:1:11: note: where 'Self' = 'String.Index'\nextension\
    \ BinaryInteger {\n          ^\n/tmp/tmp2ktqauw2.swift:20:68: error: cannot convert\
    \ value of type 'String.Index' to expected argument type 'Int'\n            let\
    \ newPosition = alphabet.index(idx, offsetBy: (idx < idx + 4 ? 2 : -24))\n   \
    \                                                                ^\n"
  stdout: ''
  timestamp: 1660028311
- exit_code: 1
  program: "\n/// Create a function encrypt that takes a string as an argument and\n\
    /// returns a string encrypted with the alphabet being rotated. \n/// The alphabet\
    \ should be rotated in a manner such that the letters \n/// shift down by two\
    \ multiplied to two places.\n/// For example:\n/// >>> encrypt(s: \"hi\")\n///\
    \ \"lm\"\n/// >>> encrypt(s: \"asdfghjkl\")\n/// \"ewhjklnop\"\n/// >>> encrypt(s:\
    \ \"gf\")\n/// \"kj\"\n/// >>> encrypt(s: \"et\")\n/// \"ix\"\nfunc encrypt(s:\
    \ String) -> String {\n    let letters: [Character] = Array(s)\n    var encryptedLetters:\
    \ [Character] = []\n    for letter in letters {\n        if (letter == \"z\")\
    \ {\n            encryptedLetters.append(\"b\")\n        } else if (letter ==\
    \ \"y\") {\n            encryptedLetters.append(\"a\")\n        } else {\n   \
    \         encryptedLetters.append(letter.unicodeScalars.first!.value + 2)\n  \
    \      }\n    }\n    let encryptedStr = String(encryptedLetters)\n    return encryptedStr\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(encrypt(s: \"hi\") == \"lm\")\nassert(encrypt(s:\
    \ \"asdfghjkl\") == \"ewhjklnop\")\nassert(encrypt(s: \"gf\") == \"kj\")\nassert(encrypt(s:\
    \ \"et\") == \"ix\")\nassert(encrypt(s: \"faewfawefaewg\") == \"jeiajeaijeiak\"\
    )\nassert(encrypt(s: \"hellomyfriend\") == \"lippsqcjvmirh\")\nassert(encrypt(s:\
    \ \"dxzdlmnilfuhmilufhlihufnmlimnufhlimnufhfucufh\") == \"hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl\"\
    )\nassert(encrypt(s: \"a\") == \"e\")"
  status: SyntaxError
  stderr: "/tmp/tmp0geufj8m.swift:24:72: error: cannot convert value of type 'UInt32'\
    \ to expected argument type 'Character'\n            encryptedLetters.append(letter.unicodeScalars.first!.value\
    \ + 2)\n                                                                     \
    \  ^\n"
  stdout: ''
  timestamp: 1660028311
- exit_code: 0
  program: "\n/// Create a function encrypt that takes a string as an argument and\n\
    /// returns a string encrypted with the alphabet being rotated. \n/// The alphabet\
    \ should be rotated in a manner such that the letters \n/// shift down by two\
    \ multiplied to two places.\n/// For example:\n/// >>> encrypt(s: \"hi\")\n///\
    \ \"lm\"\n/// >>> encrypt(s: \"asdfghjkl\")\n/// \"ewhjklnop\"\n/// >>> encrypt(s:\
    \ \"gf\")\n/// \"kj\"\n/// >>> encrypt(s: \"et\")\n/// \"ix\"\nfunc encrypt(s:\
    \ String) -> String {\n    //your code here\n    var result = \"\"\n    let alphabet\
    \ = Array(\"abcdefghijklmnopqrstuvwxyz\")\n    for c in s {\n        result +=\
    \ String(alphabet[(alphabet.firstIndex(of: c)! + 4) % 26])\n    }\n    return\
    \ result\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n\
    \    if left.count != right.count {\n        return false\n    }\n    for (l,\
    \ r) in zip(left, right) {\n        if l != r {\n            return false\n  \
    \      }\n    }\n    return true\n}\n            \nassert(encrypt(s: \"hi\") ==\
    \ \"lm\")\nassert(encrypt(s: \"asdfghjkl\") == \"ewhjklnop\")\nassert(encrypt(s:\
    \ \"gf\") == \"kj\")\nassert(encrypt(s: \"et\") == \"ix\")\nassert(encrypt(s:\
    \ \"faewfawefaewg\") == \"jeiajeaijeiak\")\nassert(encrypt(s: \"hellomyfriend\"\
    ) == \"lippsqcjvmirh\")\nassert(encrypt(s: \"dxzdlmnilfuhmilufhlihufnmlimnufhlimnufhfucufh\"\
    ) == \"hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl\")\nassert(encrypt(s: \"\
    a\") == \"e\")"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660028311
- exit_code: 0
  program: "\n/// Create a function encrypt that takes a string as an argument and\n\
    /// returns a string encrypted with the alphabet being rotated. \n/// The alphabet\
    \ should be rotated in a manner such that the letters \n/// shift down by two\
    \ multiplied to two places.\n/// For example:\n/// >>> encrypt(s: \"hi\")\n///\
    \ \"lm\"\n/// >>> encrypt(s: \"asdfghjkl\")\n/// \"ewhjklnop\"\n/// >>> encrypt(s:\
    \ \"gf\")\n/// \"kj\"\n/// >>> encrypt(s: \"et\")\n/// \"ix\"\nfunc encrypt(s:\
    \ String) -> String {\n    let alphabetArray = [\"a\", \"b\", \"c\", \"d\", \"\
    e\", \"f\", \"g\", \"h\", \"i\", \"j\", \"k\", \"l\", \"m\", \"n\", \"o\", \"\
    p\", \"q\", \"r\", \"s\", \"t\", \"u\", \"v\", \"w\", \"x\", \"y\", \"z\"]\n \
    \   var encryptedString = \"\"\n    for (_, element) in s.enumerated() {\n   \
    \     for (index, alphabet) in alphabetArray.enumerated() {\n            if String(element)\
    \ == alphabet {\n                if index + 2 * 2 > alphabetArray.count - 1 {\n\
    \                    encryptedString += alphabetArray[(index + 2 * 2) - alphabetArray.count]\n\
    \                } else {\n                    encryptedString += alphabetArray[index\
    \ + 2 * 2]\n                }\n            }\n        }\n    }\n    return encryptedString\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(encrypt(s: \"hi\") == \"lm\")\nassert(encrypt(s:\
    \ \"asdfghjkl\") == \"ewhjklnop\")\nassert(encrypt(s: \"gf\") == \"kj\")\nassert(encrypt(s:\
    \ \"et\") == \"ix\")\nassert(encrypt(s: \"faewfawefaewg\") == \"jeiajeaijeiak\"\
    )\nassert(encrypt(s: \"hellomyfriend\") == \"lippsqcjvmirh\")\nassert(encrypt(s:\
    \ \"dxzdlmnilfuhmilufhlihufnmlimnufhlimnufhfucufh\") == \"hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl\"\
    )\nassert(encrypt(s: \"a\") == \"e\")"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660028311
- exit_code: 1
  program: "\n/// Create a function encrypt that takes a string as an argument and\n\
    /// returns a string encrypted with the alphabet being rotated. \n/// The alphabet\
    \ should be rotated in a manner such that the letters \n/// shift down by two\
    \ multiplied to two places.\n/// For example:\n/// >>> encrypt(s: \"hi\")\n///\
    \ \"lm\"\n/// >>> encrypt(s: \"asdfghjkl\")\n/// \"ewhjklnop\"\n/// >>> encrypt(s:\
    \ \"gf\")\n/// \"kj\"\n/// >>> encrypt(s: \"et\")\n/// \"ix\"\nfunc encrypt(s:\
    \ String) -> String {\n    var encrypt = [Character]()\n    for char in s {\n\
    \        let charNum = char.asciiValue!\n        if charNum >= 65 && charNum <=\
    \ 87 {\n            let shifted = Character(UnicodeScalar(charNum + 2)!)\n   \
    \         encrypt.append(shifted)\n        } else if charNum >= 88 && charNum\
    \ <= 90 {\n            let shifted = Character(UnicodeScalar(charNum - 24)!)\n\
    \            encrypt.append(shifted)\n        } else if charNum >= 97 && charNum\
    \ <= 119 {\n            let shifted = Character(UnicodeScalar(charNum + 2)!)\n\
    \            encrypt.append(shifted)\n        } else if charNum >= 120 && charNum\
    \ <= 122 {\n            let shifted = Character(UnicodeScalar(charNum - 24)!)\n\
    \            encrypt.append(shifted)\n        } else {\n            encrypt.append(char)\n\
    \        }\n    }\n    return String(encrypt)\n}\n\n\nfunc ==(left: [(Int, Int)],\
    \ right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n       \
    \ return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r\
    \ {\n            return false\n        }\n    }\n    return true\n}\n        \
    \    \nassert(encrypt(s: \"hi\") == \"lm\")\nassert(encrypt(s: \"asdfghjkl\")\
    \ == \"ewhjklnop\")\nassert(encrypt(s: \"gf\") == \"kj\")\nassert(encrypt(s: \"\
    et\") == \"ix\")\nassert(encrypt(s: \"faewfawefaewg\") == \"jeiajeaijeiak\")\n\
    assert(encrypt(s: \"hellomyfriend\") == \"lippsqcjvmirh\")\nassert(encrypt(s:\
    \ \"dxzdlmnilfuhmilufhlihufnmlimnufhlimnufhfucufh\") == \"hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl\"\
    )\nassert(encrypt(s: \"a\") == \"e\")"
  status: SyntaxError
  stderr: "/tmp/tmpm1yibdtu.swift:20:63: error: cannot force unwrap value of non-optional\
    \ type 'UnicodeScalar' (aka 'Unicode.Scalar')\n            let shifted = Character(UnicodeScalar(charNum\
    \ + 2)!)\n                                    ~~~~~~~~~~~~~~~~~~~~~~~~~~^\n  \
    \                                                            \n/tmp/tmpm1yibdtu.swift:23:64:\
    \ error: cannot force unwrap value of non-optional type 'UnicodeScalar' (aka 'Unicode.Scalar')\n\
    \            let shifted = Character(UnicodeScalar(charNum - 24)!)\n         \
    \                           ~~~~~~~~~~~~~~~~~~~~~~~~~~~^\n                   \
    \                                            \n/tmp/tmpm1yibdtu.swift:26:63: error:\
    \ cannot force unwrap value of non-optional type 'UnicodeScalar' (aka 'Unicode.Scalar')\n\
    \            let shifted = Character(UnicodeScalar(charNum + 2)!)\n          \
    \                          ~~~~~~~~~~~~~~~~~~~~~~~~~~^\n                     \
    \                                         \n/tmp/tmpm1yibdtu.swift:29:64: error:\
    \ cannot force unwrap value of non-optional type 'UnicodeScalar' (aka 'Unicode.Scalar')\n\
    \            let shifted = Character(UnicodeScalar(charNum - 24)!)\n         \
    \                           ~~~~~~~~~~~~~~~~~~~~~~~~~~~^\n                   \
    \                                            \n"
  stdout: ''
  timestamp: 1660028311
- exit_code: -4
  program: "\n/// Create a function encrypt that takes a string as an argument and\n\
    /// returns a string encrypted with the alphabet being rotated. \n/// The alphabet\
    \ should be rotated in a manner such that the letters \n/// shift down by two\
    \ multiplied to two places.\n/// For example:\n/// >>> encrypt(s: \"hi\")\n///\
    \ \"lm\"\n/// >>> encrypt(s: \"asdfghjkl\")\n/// \"ewhjklnop\"\n/// >>> encrypt(s:\
    \ \"gf\")\n/// \"kj\"\n/// >>> encrypt(s: \"et\")\n/// \"ix\"\nfunc encrypt(s:\
    \ String) -> String {\n    let lowercase = Array(\"abcdefghijklmnopqrstuvwxyz\"\
    )\n    let uppercase = Array(\"ABCDEFGHIJKLMNOPQRSTUVWXYZ\")\n    var secret =\
    \ \"\"\n    for ch in s {\n        let idx = (String(ch).lowercased() == String(ch))\
    \ ? lowercase.firstIndex(of: ch) : uppercase.firstIndex(of: ch)\n        if let\
    \ i = idx {\n            let index = (i + 2) % lowercase.count\n            secret\
    \ += String(lowercase[index])\n        } else {\n            secret += String(ch)\n\
    \        }\n    }\n    return secret\n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(encrypt(s: \"hi\") == \"lm\")\nassert(encrypt(s: \"asdfghjkl\") == \"ewhjklnop\"\
    )\nassert(encrypt(s: \"gf\") == \"kj\")\nassert(encrypt(s: \"et\") == \"ix\")\n\
    assert(encrypt(s: \"faewfawefaewg\") == \"jeiajeaijeiak\")\nassert(encrypt(s:\
    \ \"hellomyfriend\") == \"lippsqcjvmirh\")\nassert(encrypt(s: \"dxzdlmnilfuhmilufhlihufnmlimnufhlimnufhfucufh\"\
    ) == \"hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl\")\nassert(encrypt(s: \"\
    a\") == \"e\")"
  status: Exception
  stderr: 'tmp0xkdm8xh/tmp0xkdm8xh.swift:44: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b783d07fc80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b783cd76b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b783cd76988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b783cd757b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmp0xkdm8xh                        0x00005561d32a47f7 <unavailable> + 6135

    5    libc.so.6                          0x00002b783d26b460 __libc_start_main +
    245

    6    tmp0xkdm8xh                        0x00005561d32a4439 <unavailable> + 5177

    '
  stdout: ''
  timestamp: 1660028311
- exit_code: -4
  program: "\n/// Create a function encrypt that takes a string as an argument and\n\
    /// returns a string encrypted with the alphabet being rotated. \n/// The alphabet\
    \ should be rotated in a manner such that the letters \n/// shift down by two\
    \ multiplied to two places.\n/// For example:\n/// >>> encrypt(s: \"hi\")\n///\
    \ \"lm\"\n/// >>> encrypt(s: \"asdfghjkl\")\n/// \"ewhjklnop\"\n/// >>> encrypt(s:\
    \ \"gf\")\n/// \"kj\"\n/// >>> encrypt(s: \"et\")\n/// \"ix\"\nfunc encrypt(s:\
    \ String) -> String {\n    // Write your code here\n    return \"\"\n}\n\n\nfunc\
    \ ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count !=\
    \ right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(encrypt(s: \"hi\") == \"lm\")\nassert(encrypt(s:\
    \ \"asdfghjkl\") == \"ewhjklnop\")\nassert(encrypt(s: \"gf\") == \"kj\")\nassert(encrypt(s:\
    \ \"et\") == \"ix\")\nassert(encrypt(s: \"faewfawefaewg\") == \"jeiajeaijeiak\"\
    )\nassert(encrypt(s: \"hellomyfriend\") == \"lippsqcjvmirh\")\nassert(encrypt(s:\
    \ \"dxzdlmnilfuhmilufhlihufnmlimnufhlimnufhfucufh\") == \"hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl\"\
    )\nassert(encrypt(s: \"a\") == \"e\")"
  status: Exception
  stderr: 'tmpzuxxhzqm/tmpzuxxhzqm.swift:33: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b288d1bcc80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b288ceb3b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b288ceb3988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b288ceb27b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpzuxxhzqm                        0x000055b04e6ba307 <unavailable> + 4871

    5    libc.so.6                          0x00002b288d3a8460 __libc_start_main +
    245

    6    tmpzuxxhzqm                        0x000055b04e6b9f49 <unavailable> + 3913

    '
  stdout: ''
  timestamp: 1660028311
- exit_code: 1
  program: "\n/// Create a function encrypt that takes a string as an argument and\n\
    /// returns a string encrypted with the alphabet being rotated. \n/// The alphabet\
    \ should be rotated in a manner such that the letters \n/// shift down by two\
    \ multiplied to two places.\n/// For example:\n/// >>> encrypt(s: \"hi\")\n///\
    \ \"lm\"\n/// >>> encrypt(s: \"asdfghjkl\")\n/// \"ewhjklnop\"\n/// >>> encrypt(s:\
    \ \"gf\")\n/// \"kj\"\n/// >>> encrypt(s: \"et\")\n/// \"ix\"\nfunc encrypt(s:\
    \ String) -> String {\n    let lowercase: [Character] = [\"a\", \"b\", \"c\",\
    \ \"d\", \"e\", \"f\", \"g\", \"h\", \"i\", \"j\", \"k\", \"l\", \"m\", \"n\"\
    , \"o\", \"p\", \"q\", \"r\", \"s\", \"t\", \"u\", \"v\", \"w\", \"x\", \"y\"\
    , \"z\"]\n    let uppercase: [Character] = [\"A\", \"B\", \"C\", \"D\", \"E\"\
    , \"F\", \"G\", \"H\", \"I\", \"J\", \"K\", \"L\", \"M\", \"N\", \"O\", \"P\"\
    , \"Q\", \"R\", \"S\", \"T\", \"U\", \"V\", \"W\", \"X\", \"Y\", \"Z\"]\n    var\
    \ encrypted: String = \"\"\n    for char in s {\n        if char == \" \" {\n\
    \            encrypted += \" \"\n        } else if char.isUppercase {\n      \
    \      for i in 0...uppercase.count-1 {\n                if char == uppercase[i]\
    \ {\n                    encrypted += uppercase[i+4]\n                }\n    \
    \        }\n        } else {\n            for i in 0...lowercase.count-1 {\n \
    \               if char == lowercase[i] {\n                    encrypted += lowercase[i+4]\n\
    \                }\n            }\n        }\n    }\n    return encrypted\n}\n\
    \n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(encrypt(s: \"hi\") == \"lm\")\nassert(encrypt(s:\
    \ \"asdfghjkl\") == \"ewhjklnop\")\nassert(encrypt(s: \"gf\") == \"kj\")\nassert(encrypt(s:\
    \ \"et\") == \"ix\")\nassert(encrypt(s: \"faewfawefaewg\") == \"jeiajeaijeiak\"\
    )\nassert(encrypt(s: \"hellomyfriend\") == \"lippsqcjvmirh\")\nassert(encrypt(s:\
    \ \"dxzdlmnilfuhmilufhlihufnmlimnufhlimnufhfucufh\") == \"hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl\"\
    )\nassert(encrypt(s: \"a\") == \"e\")"
  status: SyntaxError
  stderr: "/tmp/tmpf7f1td8z.swift:25:43: error: no exact matches in call to subscript\
    \ \n                    encrypted += uppercase[i+4]\n                        \
    \                  ^\nSwift.String:3:35: note: candidate expects value of type\
    \ 'String' for parameter #2 (got 'Character')\n    @inlinable public static func\
    \ += (lhs: inout String, rhs: String)\n                                  ^\nSwift.Array:17:23:\
    \ note: candidate expects value of type 'Range<Int>' for parameter #1 (got 'Int')\n\
    \    @inlinable public subscript(bounds: Range<Int>) -> ArraySlice<Element> {\
    \ get set }\n                      ^\nSwift.Collection:3:23: note: candidate expects\
    \ value of type '(UnboundedRange_) -> ()' for parameter #1 (got 'Int')\n    @inlinable\
    \ public subscript(x: (UnboundedRange_) -> ()) -> Self.SubSequence { get }\n \
    \                     ^\nSwift.MutableCollection:3:23: note: candidate expects\
    \ value of type '(UnboundedRange_) -> ()' for parameter #1 (got 'Int')\n    @inlinable\
    \ public subscript(x: (UnboundedRange_) -> ()) -> Self.SubSequence { get set }\n\
    \                      ^\n/tmp/tmpf7f1td8z.swift:25:43: error: cannot convert\
    \ value of type 'Character' to expected argument type 'String'\n             \
    \       encrypted += uppercase[i+4]\n                                        \
    \  ^\n/tmp/tmpf7f1td8z.swift:31:43: error: cannot convert value of type 'Character'\
    \ to expected argument type 'String'\n                    encrypted += lowercase[i+4]\n\
    \                                          ^\n/tmp/tmpf7f1td8z.swift:31:43: error:\
    \ no exact matches in call to subscript \n                    encrypted += lowercase[i+4]\n\
    \                                          ^\nSwift.String:3:35: note: candidate\
    \ expects value of type 'String' for parameter #2 (got 'Character')\n    @inlinable\
    \ public static func += (lhs: inout String, rhs: String)\n                   \
    \               ^\nSwift.Array:17:23: note: candidate expects value of type 'Range<Int>'\
    \ for parameter #1 (got 'Int')\n    @inlinable public subscript(bounds: Range<Int>)\
    \ -> ArraySlice<Element> { get set }\n                      ^\nS"
  stdout: ''
  timestamp: 1660028311
- exit_code: -4
  program: "\n/// Create a function encrypt that takes a string as an argument and\n\
    /// returns a string encrypted with the alphabet being rotated. \n/// The alphabet\
    \ should be rotated in a manner such that the letters \n/// shift down by two\
    \ multiplied to two places.\n/// For example:\n/// >>> encrypt(s: \"hi\")\n///\
    \ \"lm\"\n/// >>> encrypt(s: \"asdfghjkl\")\n/// \"ewhjklnop\"\n/// >>> encrypt(s:\
    \ \"gf\")\n/// \"kj\"\n/// >>> encrypt(s: \"et\")\n/// \"ix\"\nfunc encrypt(s:\
    \ String) -> String {\n    let s = s.lowercased()\n    var output = \"\"\n   \
    \ for i in s {\n        switch i {\n        case \"a\"...\"w\":\n            output\
    \ += String(UnicodeScalar(UInt8(Int(i.asciiValue!) + 4)))\n        case \"x\"\
    ...\"z\":\n            output += String(UnicodeScalar(UInt8(Int(i.asciiValue!)\
    \ - 20)))\n        default:\n            output += String(i)\n        }\n    }\n\
    \    return output\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) ->\
    \ Bool {\n    if left.count != right.count {\n        return false\n    }\n  \
    \  for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(encrypt(s: \"hi\"\
    ) == \"lm\")\nassert(encrypt(s: \"asdfghjkl\") == \"ewhjklnop\")\nassert(encrypt(s:\
    \ \"gf\") == \"kj\")\nassert(encrypt(s: \"et\") == \"ix\")\nassert(encrypt(s:\
    \ \"faewfawefaewg\") == \"jeiajeaijeiak\")\nassert(encrypt(s: \"hellomyfriend\"\
    ) == \"lippsqcjvmirh\")\nassert(encrypt(s: \"dxzdlmnilfuhmilufhlihufnmlimnufhlimnufhfucufh\"\
    ) == \"hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl\")\nassert(encrypt(s: \"\
    a\") == \"e\")"
  status: Exception
  stderr: 'tmpga59r5m8/tmpga59r5m8.swift:48: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002ad02c4c2c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002ad02c1b9b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002ad02c1b9988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002ad02c1b87b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpga59r5m8                        0x0000558177404efe <unavailable> + 7934

    5    libc.so.6                          0x00002ad02c6ae460 __libc_start_main +
    245

    6    tmpga59r5m8                        0x00005581774046f9 <unavailable> + 5881

    '
  stdout: ''
  timestamp: 1660028311
- exit_code: 1
  program: "\n/// Create a function encrypt that takes a string as an argument and\n\
    /// returns a string encrypted with the alphabet being rotated. \n/// The alphabet\
    \ should be rotated in a manner such that the letters \n/// shift down by two\
    \ multiplied to two places.\n/// For example:\n/// >>> encrypt(s: \"hi\")\n///\
    \ \"lm\"\n/// >>> encrypt(s: \"asdfghjkl\")\n/// \"ewhjklnop\"\n/// >>> encrypt(s:\
    \ \"gf\")\n/// \"kj\"\n/// >>> encrypt(s: \"et\")\n/// \"ix\"\nfunc encrypt(s:\
    \ String) -> String {\n    var stringArray = [Character]()\n    for i in s {\n\
    \        var offset = alphabet.firstIndex(of: i)! + 10\n        if offset > 25\
    \ {\n            offset -= 26\n        }\n        stringArray.append(alphabet[offset])\n\
    \    }\n    return String(stringArray)\n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(encrypt(s: \"hi\") == \"lm\")\nassert(encrypt(s: \"asdfghjkl\") == \"ewhjklnop\"\
    )\nassert(encrypt(s: \"gf\") == \"kj\")\nassert(encrypt(s: \"et\") == \"ix\")\n\
    assert(encrypt(s: \"faewfawefaewg\") == \"jeiajeaijeiak\")\nassert(encrypt(s:\
    \ \"hellomyfriend\") == \"lippsqcjvmirh\")\nassert(encrypt(s: \"dxzdlmnilfuhmilufhlihufnmlimnufhlimnufhfucufh\"\
    ) == \"hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl\")\nassert(encrypt(s: \"\
    a\") == \"e\")"
  status: SyntaxError
  stderr: "/tmp/tmp29pshjaz.swift:18:22: error: cannot find 'alphabet' in scope\n\
    \        var offset = alphabet.firstIndex(of: i)! + 10\n                     ^~~~~~~~\n\
    /tmp/tmp29pshjaz.swift:22:28: error: cannot find 'alphabet' in scope\n       \
    \ stringArray.append(alphabet[offset])\n                           ^~~~~~~~\n"
  stdout: ''
  timestamp: 1660028311
- exit_code: 1
  program: "\n/// Create a function encrypt that takes a string as an argument and\n\
    /// returns a string encrypted with the alphabet being rotated. \n/// The alphabet\
    \ should be rotated in a manner such that the letters \n/// shift down by two\
    \ multiplied to two places.\n/// For example:\n/// >>> encrypt(s: \"hi\")\n///\
    \ \"lm\"\n/// >>> encrypt(s: \"asdfghjkl\")\n/// \"ewhjklnop\"\n/// >>> encrypt(s:\
    \ \"gf\")\n/// \"kj\"\n/// >>> encrypt(s: \"et\")\n/// \"ix\"\nfunc encrypt(s:\
    \ String) -> String {\n    \n    var encrypted = \"\"\n    for char in s {\n \
    \       let uni = char.unicodeScalars.first!.value\n        if (uni >= 97 && uni\
    \ <= 101) || (uni >= 103 && uni <= 107) {\n            encrypted.append(Character(UnicodeScalar(uni\
    \ + 16)!))\n        } else if uni == 108 {\n            encrypted.append(Character(UnicodeScalar(uni\
    \ - 14)!))\n        } else if uni == 109 {\n            encrypted.append(Character(UnicodeScalar(uni\
    \ - 16)!))\n        } else if uni == 110 {\n            encrypted.append(Character(UnicodeScalar(uni\
    \ - 15)!))\n        } else if uni == 111 {\n            encrypted.append(Character(UnicodeScalar(uni\
    \ - 12)!))\n        } else if uni == 112 {\n            encrypted.append(Character(UnicodeScalar(uni\
    \ - 10)!))\n        } else if uni == 113 {\n            encrypted.append(Character(UnicodeScalar(uni\
    \ - 11)!))\n        } else if uni == 114 {\n            encrypted.append(Character(UnicodeScalar(uni\
    \ - 8)!))\n        } else if uni == 115 {\n            encrypted.append(Character(UnicodeScalar(uni\
    \ - 6)!))\n        } else if uni == 116 {\n            encrypted.append(Character(UnicodeScalar(uni\
    \ - 7)!))\n        } else if uni == 117 {\n            encrypted.append(Character(UnicodeScalar(uni\
    \ - 4)!))\n        } else if uni == 118 {\n            encrypted.append(Character(UnicodeScalar(uni\
    \ - 2)!))\n        } else if uni == 119 {\n            encrypted.append(Character(UnicodeScalar(uni\
    \ - 3)!))\n        } else if uni == 120 {\n            encrypted.append(Character(UnicodeScalar(uni)!))\n\
    \        } else if uni == 121 {\n            encrypted.append(Character(UnicodeScalar(uni\
    \ + 1)!))\n        } else if uni == 122 {\n            encrypted.append(Character\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(encrypt(s: \"hi\") == \"lm\")\nassert(encrypt(s:\
    \ \"asdfghjkl\") == \"ewhjklnop\")\nassert(encrypt(s: \"gf\") == \"kj\")\nassert(encrypt(s:\
    \ \"et\") == \"ix\")\nassert(encrypt(s: \"faewfawefaewg\") == \"jeiajeaijeiak\"\
    )\nassert(encrypt(s: \"hellomyfriend\") == \"lippsqcjvmirh\")\nassert(encrypt(s:\
    \ \"dxzdlmnilfuhmilufhlihufnmlimnufhlimnufhfucufh\") == \"hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl\"\
    )\nassert(encrypt(s: \"a\") == \"e\")"
  status: SyntaxError
  stderr: "/tmp/tmp54z9rczz.swift:52:1: error: expected ')' in expression list\n}\n\
    ^\n/tmp/tmp54z9rczz.swift:51:29: note: to match this opening '('\n           \
    \ encrypted.append(Character\n                            ^\n/tmp/tmp54z9rczz.swift:74:31:\
    \ error: expected '}' at end of brace statement\nassert(encrypt(s: \"a\") == \"\
    e\")\n                              ^\n/tmp/tmp54z9rczz.swift:18:19: note: to\
    \ match this opening '{'\n    for char in s {\n                  ^\n/tmp/tmp54z9rczz.swift:74:31:\
    \ error: expected '}' at end of brace statement\nassert(encrypt(s: \"a\") == \"\
    e\")\n                              ^\n/tmp/tmp54z9rczz.swift:15:35: note: to\
    \ match this opening '{'\nfunc encrypt(s: String) -> String {\n              \
    \                    ^\n/tmp/tmp54z9rczz.swift:51:23: error: no exact matches\
    \ in call to instance method 'append'\n            encrypted.append(Character\n\
    \                      ^\nSwift.String:6:26: note: candidate expects value of\
    \ type 'String' for parameter #1 (got 'Character.Type')\n    public mutating func\
    \ append(_ other: String)\n                         ^\nSwift.String:7:26: note:\
    \ candidate expects value of type 'Character' for parameter #1 (got 'Character.Type')\n\
    \    public mutating func append(_ c: Character)\n                         ^\n\
    Swift.RangeReplaceableCollection:4:37: note: candidate expects value of type 'String.Element'\
    \ (aka 'Character') for parameter #1 (got 'Character.Type')\n    @inlinable public\
    \ mutating func append(_ newElement: __owned Self.Element)\n                 \
    \                   ^\n/tmp/tmp54z9rczz.swift:55:6: error: operator functions\
    \ can only be declared at global or in type scope\nfunc ==(left: [(Int, Int)],\
    \ right: [(Int, Int)]) -> Bool {\n     ^\n"
  stdout: ''
  timestamp: 1660028311
- exit_code: -4
  program: "\n/// Create a function encrypt that takes a string as an argument and\n\
    /// returns a string encrypted with the alphabet being rotated. \n/// The alphabet\
    \ should be rotated in a manner such that the letters \n/// shift down by two\
    \ multiplied to two places.\n/// For example:\n/// >>> encrypt(s: \"hi\")\n///\
    \ \"lm\"\n/// >>> encrypt(s: \"asdfghjkl\")\n/// \"ewhjklnop\"\n/// >>> encrypt(s:\
    \ \"gf\")\n/// \"kj\"\n/// >>> encrypt(s: \"et\")\n/// \"ix\"\nfunc encrypt(s:\
    \ String) -> String {\n    var newString = \"\"\n    let alphabetArray = Array(\"\
    abcdefghijklmnopqrstuvwxyz\")\n    for character in s {\n        for letter in\
    \ alphabetArray {\n            if character == letter {\n                let index\
    \ = alphabetArray.firstIndex(of: letter)!\n                if index >= alphabetArray.count\
    \ - 2 {\n                    let finalIndex = index - alphabetArray.count + 2\n\
    \                    newString.append(alphabetArray[finalIndex])\n           \
    \     } else {\n                    newString.append(alphabetArray[index + 2])\n\
    \                }\n            }\n        }\n    }\n    return newString\n}\n\
    \n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(encrypt(s: \"hi\") == \"lm\")\nassert(encrypt(s:\
    \ \"asdfghjkl\") == \"ewhjklnop\")\nassert(encrypt(s: \"gf\") == \"kj\")\nassert(encrypt(s:\
    \ \"et\") == \"ix\")\nassert(encrypt(s: \"faewfawefaewg\") == \"jeiajeaijeiak\"\
    )\nassert(encrypt(s: \"hellomyfriend\") == \"lippsqcjvmirh\")\nassert(encrypt(s:\
    \ \"dxzdlmnilfuhmilufhlihufnmlimnufhlimnufhfucufh\") == \"hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl\"\
    )\nassert(encrypt(s: \"a\") == \"e\")"
  status: Exception
  stderr: 'tmp6kor0w6b/tmp6kor0w6b.swift:47: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b8c3c1f5c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b8c3beecb6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b8c3beec988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b8c3beeb7b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmp6kor0w6b                        0x000055871e8de927 <unavailable> + 6439

    5    libc.so.6                          0x00002b8c3c3e1460 __libc_start_main +
    245

    6    tmp6kor0w6b                        0x000055871e8de569 <unavailable> + 5481

    '
  stdout: ''
  timestamp: 1660028311
- exit_code: -4
  program: "\n/// Create a function encrypt that takes a string as an argument and\n\
    /// returns a string encrypted with the alphabet being rotated. \n/// The alphabet\
    \ should be rotated in a manner such that the letters \n/// shift down by two\
    \ multiplied to two places.\n/// For example:\n/// >>> encrypt(s: \"hi\")\n///\
    \ \"lm\"\n/// >>> encrypt(s: \"asdfghjkl\")\n/// \"ewhjklnop\"\n/// >>> encrypt(s:\
    \ \"gf\")\n/// \"kj\"\n/// >>> encrypt(s: \"et\")\n/// \"ix\"\nfunc encrypt(s:\
    \ String) -> String {\n    var encryptedString = \"\"\n    for character in s\
    \ {\n        let unicode = character.unicodeScalars.first!.value\n        var\
    \ letter: UnicodeScalar\n        if unicode == 97 {\n            letter = UnicodeScalar(unicode\
    \ + 23)!\n        } else if unicode == 98 {\n            letter = UnicodeScalar(unicode\
    \ + 21)!\n        } else {\n            letter = UnicodeScalar(unicode - 2)!\n\
    \        }\n        encryptedString.append(Character(letter))\n    }\n    return\
    \ encryptedString\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) ->\
    \ Bool {\n    if left.count != right.count {\n        return false\n    }\n  \
    \  for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(encrypt(s: \"hi\"\
    ) == \"lm\")\nassert(encrypt(s: \"asdfghjkl\") == \"ewhjklnop\")\nassert(encrypt(s:\
    \ \"gf\") == \"kj\")\nassert(encrypt(s: \"et\") == \"ix\")\nassert(encrypt(s:\
    \ \"faewfawefaewg\") == \"jeiajeaijeiak\")\nassert(encrypt(s: \"hellomyfriend\"\
    ) == \"lippsqcjvmirh\")\nassert(encrypt(s: \"dxzdlmnilfuhmilufhlihufnmlimnufhlimnufhfucufh\"\
    ) == \"hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl\")\nassert(encrypt(s: \"\
    a\") == \"e\")"
  status: Exception
  stderr: 'tmpe446ayd0/tmpe446ayd0.swift:45: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002af688f19c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002af688c10b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002af688c10988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002af688c0f7b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpe446ayd0                        0x0000556702ed0737 <unavailable> + 5943

    5    libc.so.6                          0x00002af689105460 __libc_start_main +
    245

    6    tmpe446ayd0                        0x0000556702ed0379 <unavailable> + 4985

    '
  stdout: ''
  timestamp: 1660028311
- exit_code: -4
  program: "\n/// Create a function encrypt that takes a string as an argument and\n\
    /// returns a string encrypted with the alphabet being rotated. \n/// The alphabet\
    \ should be rotated in a manner such that the letters \n/// shift down by two\
    \ multiplied to two places.\n/// For example:\n/// >>> encrypt(s: \"hi\")\n///\
    \ \"lm\"\n/// >>> encrypt(s: \"asdfghjkl\")\n/// \"ewhjklnop\"\n/// >>> encrypt(s:\
    \ \"gf\")\n/// \"kj\"\n/// >>> encrypt(s: \"et\")\n/// \"ix\"\nfunc encrypt(s:\
    \ String) -> String {\n    var encryptedString = \"\"\n    for i in s {\n    \
    \    var asciiValue = Int(i.asciiValue!)\n        if asciiValue >= 97 && asciiValue\
    \ <= 122 {\n            if asciiValue == 120 {\n                asciiValue = 97\n\
    \            } else if asciiValue == 121 {\n                asciiValue = 98\n\
    \            } else {\n                asciiValue += 2\n            }\n      \
    \  }\n        encryptedString.append(Character(UnicodeScalar(asciiValue)!))\n\
    \    }\n    return encryptedString\n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(encrypt(s: \"hi\") == \"lm\")\nassert(encrypt(s: \"asdfghjkl\") == \"ewhjklnop\"\
    )\nassert(encrypt(s: \"gf\") == \"kj\")\nassert(encrypt(s: \"et\") == \"ix\")\n\
    assert(encrypt(s: \"faewfawefaewg\") == \"jeiajeaijeiak\")\nassert(encrypt(s:\
    \ \"hellomyfriend\") == \"lippsqcjvmirh\")\nassert(encrypt(s: \"dxzdlmnilfuhmilufhlihufnmlimnufhlimnufhfucufh\"\
    ) == \"hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl\")\nassert(encrypt(s: \"\
    a\") == \"e\")"
  status: Exception
  stderr: 'tmpc900ncig/tmpc900ncig.swift:46: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b3a4613bc80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b3a45e32b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b3a45e32988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b3a45e317b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpc900ncig                        0x000055e24e9fb747 <unavailable> + 5959

    5    libc.so.6                          0x00002b3a46327460 __libc_start_main +
    245

    6    tmpc900ncig                        0x000055e24e9fb389 <unavailable> + 5001

    '
  stdout: ''
  timestamp: 1660028311
- exit_code: -4
  program: "\n/// Create a function encrypt that takes a string as an argument and\n\
    /// returns a string encrypted with the alphabet being rotated. \n/// The alphabet\
    \ should be rotated in a manner such that the letters \n/// shift down by two\
    \ multiplied to two places.\n/// For example:\n/// >>> encrypt(s: \"hi\")\n///\
    \ \"lm\"\n/// >>> encrypt(s: \"asdfghjkl\")\n/// \"ewhjklnop\"\n/// >>> encrypt(s:\
    \ \"gf\")\n/// \"kj\"\n/// >>> encrypt(s: \"et\")\n/// \"ix\"\nfunc encrypt(s:\
    \ String) -> String {\n  return \"\"\n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(encrypt(s: \"hi\") == \"lm\")\nassert(encrypt(s: \"asdfghjkl\") == \"ewhjklnop\"\
    )\nassert(encrypt(s: \"gf\") == \"kj\")\nassert(encrypt(s: \"et\") == \"ix\")\n\
    assert(encrypt(s: \"faewfawefaewg\") == \"jeiajeaijeiak\")\nassert(encrypt(s:\
    \ \"hellomyfriend\") == \"lippsqcjvmirh\")\nassert(encrypt(s: \"dxzdlmnilfuhmilufhlihufnmlimnufhlimnufhfucufh\"\
    ) == \"hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl\")\nassert(encrypt(s: \"\
    a\") == \"e\")"
  status: Exception
  stderr: 'tmpz2v3lnhk/tmpz2v3lnhk.swift:32: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b8eaee82c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b8eaeb79b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b8eaeb79988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b8eaeb787b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpz2v3lnhk                        0x000055a49a8c4307 <unavailable> + 4871

    5    libc.so.6                          0x00002b8eaf06e460 __libc_start_main +
    245

    6    tmpz2v3lnhk                        0x000055a49a8c3f49 <unavailable> + 3913

    '
  stdout: ''
  timestamp: 1660028311
- exit_code: -4
  program: "\n/// Create a function encrypt that takes a string as an argument and\n\
    /// returns a string encrypted with the alphabet being rotated. \n/// The alphabet\
    \ should be rotated in a manner such that the letters \n/// shift down by two\
    \ multiplied to two places.\n/// For example:\n/// >>> encrypt(s: \"hi\")\n///\
    \ \"lm\"\n/// >>> encrypt(s: \"asdfghjkl\")\n/// \"ewhjklnop\"\n/// >>> encrypt(s:\
    \ \"gf\")\n/// \"kj\"\n/// >>> encrypt(s: \"et\")\n/// \"ix\"\nfunc encrypt(s:\
    \ String) -> String {\n    let alphabet = \"abcdefghijklmnopqrstuvwxyz\"\n   \
    \ var encrypted = \"\"\n    for char in s {\n        let index = alphabet.index(of:\
    \ char)!\n        let newIndex = alphabet.index(index, offsetBy: 2)\n        encrypted.append(alphabet[newIndex])\n\
    \    }\n    return encrypted\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int,\
    \ Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n\
    \    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n          \
    \  return false\n        }\n    }\n    return true\n}\n            \nassert(encrypt(s:\
    \ \"hi\") == \"lm\")\nassert(encrypt(s: \"asdfghjkl\") == \"ewhjklnop\")\nassert(encrypt(s:\
    \ \"gf\") == \"kj\")\nassert(encrypt(s: \"et\") == \"ix\")\nassert(encrypt(s:\
    \ \"faewfawefaewg\") == \"jeiajeaijeiak\")\nassert(encrypt(s: \"hellomyfriend\"\
    ) == \"lippsqcjvmirh\")\nassert(encrypt(s: \"dxzdlmnilfuhmilufhlihufnmlimnufhlimnufhfucufh\"\
    ) == \"hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl\")\nassert(encrypt(s: \"\
    a\") == \"e\")"
  status: Exception
  stderr: 'tmpezprbhpm/tmpezprbhpm.swift:39: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002acb70ed8c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002acb70bcfb6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002acb70bcf988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002acb70bce7b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpezprbhpm                        0x0000555d58943687 <unavailable> + 5767

    5    libc.so.6                          0x00002acb710c4460 __libc_start_main +
    245

    6    tmpezprbhpm                        0x0000555d589432c9 <unavailable> + 4809

    '
  stdout: ''
  timestamp: 1660028311
- exit_code: -4
  program: "\n/// Create a function encrypt that takes a string as an argument and\n\
    /// returns a string encrypted with the alphabet being rotated. \n/// The alphabet\
    \ should be rotated in a manner such that the letters \n/// shift down by two\
    \ multiplied to two places.\n/// For example:\n/// >>> encrypt(s: \"hi\")\n///\
    \ \"lm\"\n/// >>> encrypt(s: \"asdfghjkl\")\n/// \"ewhjklnop\"\n/// >>> encrypt(s:\
    \ \"gf\")\n/// \"kj\"\n/// >>> encrypt(s: \"et\")\n/// \"ix\"\nfunc encrypt(s:\
    \ String) -> String {\n    return \"\"\n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(encrypt(s: \"hi\") == \"lm\")\nassert(encrypt(s: \"asdfghjkl\") == \"ewhjklnop\"\
    )\nassert(encrypt(s: \"gf\") == \"kj\")\nassert(encrypt(s: \"et\") == \"ix\")\n\
    assert(encrypt(s: \"faewfawefaewg\") == \"jeiajeaijeiak\")\nassert(encrypt(s:\
    \ \"hellomyfriend\") == \"lippsqcjvmirh\")\nassert(encrypt(s: \"dxzdlmnilfuhmilufhlihufnmlimnufhlimnufhfucufh\"\
    ) == \"hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl\")\nassert(encrypt(s: \"\
    a\") == \"e\")"
  status: Exception
  stderr: 'tmpxsqxg1op/tmpxsqxg1op.swift:32: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b607b4a6c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b607b19db6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b607b19d988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b607b19c7b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpxsqxg1op                        0x00005575dd252307 <unavailable> + 4871

    5    libc.so.6                          0x00002b607b692460 __libc_start_main +
    245

    6    tmpxsqxg1op                        0x00005575dd251f49 <unavailable> + 3913

    '
  stdout: ''
  timestamp: 1660028310
- exit_code: -4
  program: "\n/// Create a function encrypt that takes a string as an argument and\n\
    /// returns a string encrypted with the alphabet being rotated. \n/// The alphabet\
    \ should be rotated in a manner such that the letters \n/// shift down by two\
    \ multiplied to two places.\n/// For example:\n/// >>> encrypt(s: \"hi\")\n///\
    \ \"lm\"\n/// >>> encrypt(s: \"asdfghjkl\")\n/// \"ewhjklnop\"\n/// >>> encrypt(s:\
    \ \"gf\")\n/// \"kj\"\n/// >>> encrypt(s: \"et\")\n/// \"ix\"\nfunc encrypt(s:\
    \ String) -> String {\n    return \"\"\n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(encrypt(s: \"hi\") == \"lm\")\nassert(encrypt(s: \"asdfghjkl\") == \"ewhjklnop\"\
    )\nassert(encrypt(s: \"gf\") == \"kj\")\nassert(encrypt(s: \"et\") == \"ix\")\n\
    assert(encrypt(s: \"faewfawefaewg\") == \"jeiajeaijeiak\")\nassert(encrypt(s:\
    \ \"hellomyfriend\") == \"lippsqcjvmirh\")\nassert(encrypt(s: \"dxzdlmnilfuhmilufhlihufnmlimnufhlimnufhfucufh\"\
    ) == \"hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl\")\nassert(encrypt(s: \"\
    a\") == \"e\")"
  status: Exception
  stderr: 'tmpxsqxg1op/tmpxsqxg1op.swift:32: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b607b4a6c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b607b19db6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b607b19d988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b607b19c7b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpxsqxg1op                        0x00005575dd252307 <unavailable> + 4871

    5    libc.so.6                          0x00002b607b692460 __libc_start_main +
    245

    6    tmpxsqxg1op                        0x00005575dd251f49 <unavailable> + 3913

    '
  stdout: ''
  timestamp: 1660028310
- exit_code: -4
  program: "\n/// Create a function encrypt that takes a string as an argument and\n\
    /// returns a string encrypted with the alphabet being rotated. \n/// The alphabet\
    \ should be rotated in a manner such that the letters \n/// shift down by two\
    \ multiplied to two places.\n/// For example:\n/// >>> encrypt(s: \"hi\")\n///\
    \ \"lm\"\n/// >>> encrypt(s: \"asdfghjkl\")\n/// \"ewhjklnop\"\n/// >>> encrypt(s:\
    \ \"gf\")\n/// \"kj\"\n/// >>> encrypt(s: \"et\")\n/// \"ix\"\nfunc encrypt(s:\
    \ String) -> String {\n    return \"\"\n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(encrypt(s: \"hi\") == \"lm\")\nassert(encrypt(s: \"asdfghjkl\") == \"ewhjklnop\"\
    )\nassert(encrypt(s: \"gf\") == \"kj\")\nassert(encrypt(s: \"et\") == \"ix\")\n\
    assert(encrypt(s: \"faewfawefaewg\") == \"jeiajeaijeiak\")\nassert(encrypt(s:\
    \ \"hellomyfriend\") == \"lippsqcjvmirh\")\nassert(encrypt(s: \"dxzdlmnilfuhmilufhlihufnmlimnufhlimnufhfucufh\"\
    ) == \"hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl\")\nassert(encrypt(s: \"\
    a\") == \"e\")"
  status: Exception
  stderr: 'tmpxsqxg1op/tmpxsqxg1op.swift:32: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b607b4a6c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b607b19db6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b607b19d988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b607b19c7b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpxsqxg1op                        0x00005575dd252307 <unavailable> + 4871

    5    libc.so.6                          0x00002b607b692460 __libc_start_main +
    245

    6    tmpxsqxg1op                        0x00005575dd251f49 <unavailable> + 3913

    '
  stdout: ''
  timestamp: 1660028310
- exit_code: -4
  program: "\n/// Create a function encrypt that takes a string as an argument and\n\
    /// returns a string encrypted with the alphabet being rotated. \n/// The alphabet\
    \ should be rotated in a manner such that the letters \n/// shift down by two\
    \ multiplied to two places.\n/// For example:\n/// >>> encrypt(s: \"hi\")\n///\
    \ \"lm\"\n/// >>> encrypt(s: \"asdfghjkl\")\n/// \"ewhjklnop\"\n/// >>> encrypt(s:\
    \ \"gf\")\n/// \"kj\"\n/// >>> encrypt(s: \"et\")\n/// \"ix\"\nfunc encrypt(s:\
    \ String) -> String {\n    return \"\"\n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(encrypt(s: \"hi\") == \"lm\")\nassert(encrypt(s: \"asdfghjkl\") == \"ewhjklnop\"\
    )\nassert(encrypt(s: \"gf\") == \"kj\")\nassert(encrypt(s: \"et\") == \"ix\")\n\
    assert(encrypt(s: \"faewfawefaewg\") == \"jeiajeaijeiak\")\nassert(encrypt(s:\
    \ \"hellomyfriend\") == \"lippsqcjvmirh\")\nassert(encrypt(s: \"dxzdlmnilfuhmilufhlihufnmlimnufhlimnufhfucufh\"\
    ) == \"hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl\")\nassert(encrypt(s: \"\
    a\") == \"e\")"
  status: Exception
  stderr: 'tmpxsqxg1op/tmpxsqxg1op.swift:32: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b607b4a6c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b607b19db6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b607b19d988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b607b19c7b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpxsqxg1op                        0x00005575dd252307 <unavailable> + 4871

    5    libc.so.6                          0x00002b607b692460 __libc_start_main +
    245

    6    tmpxsqxg1op                        0x00005575dd251f49 <unavailable> + 3913

    '
  stdout: ''
  timestamp: 1660028310
- exit_code: 1
  program: "\n/// Create a function encrypt that takes a string as an argument and\n\
    /// returns a string encrypted with the alphabet being rotated. \n/// The alphabet\
    \ should be rotated in a manner such that the letters \n/// shift down by two\
    \ multiplied to two places.\n/// For example:\n/// >>> encrypt(s: \"hi\")\n///\
    \ \"lm\"\n/// >>> encrypt(s: \"asdfghjkl\")\n/// \"ewhjklnop\"\n/// >>> encrypt(s:\
    \ \"gf\")\n/// \"kj\"\n/// >>> encrypt(s: \"et\")\n/// \"ix\"\nfunc encrypt(s:\
    \ String) -> String {\n    var result = \"\"\n    for character in s {\n     \
    \   let shift = character.asciiValue! + 2 * 2\n        if shift <= 122 {\n   \
    \         result.append(Character(UnicodeScalar(shift)!))\n        } else {\n\
    \            result.append(Character(UnicodeScalar(96 + shift % 122)!))\n    \
    \    }\n    }\n    return result\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int,\
    \ Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n\
    \    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n          \
    \  return false\n        }\n    }\n    return true\n}\n            \nassert(encrypt(s:\
    \ \"hi\") == \"lm\")\nassert(encrypt(s: \"asdfghjkl\") == \"ewhjklnop\")\nassert(encrypt(s:\
    \ \"gf\") == \"kj\")\nassert(encrypt(s: \"et\") == \"ix\")\nassert(encrypt(s:\
    \ \"faewfawefaewg\") == \"jeiajeaijeiak\")\nassert(encrypt(s: \"hellomyfriend\"\
    ) == \"lippsqcjvmirh\")\nassert(encrypt(s: \"dxzdlmnilfuhmilufhlihufnmlimnufhlimnufhfucufh\"\
    ) == \"hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl\")\nassert(encrypt(s: \"\
    a\") == \"e\")"
  status: SyntaxError
  stderr: "/tmp/tmpjig9w5a4.swift:20:57: error: cannot force unwrap value of non-optional\
    \ type 'UnicodeScalar' (aka 'Unicode.Scalar')\n            result.append(Character(UnicodeScalar(shift)!))\n\
    \                                    ~~~~~~~~~~~~~~~~~~~~^\n                 \
    \                                       \n/tmp/tmpjig9w5a4.swift:22:68: error:\
    \ cannot force unwrap value of non-optional type 'UnicodeScalar' (aka 'Unicode.Scalar')\n\
    \            result.append(Character(UnicodeScalar(96 + shift % 122)!))\n    \
    \                                ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~^\n          \
    \                                                         \n"
  stdout: ''
  timestamp: 1660028311
- exit_code: 1
  program: "\n/// Create a function encrypt that takes a string as an argument and\n\
    /// returns a string encrypted with the alphabet being rotated. \n/// The alphabet\
    \ should be rotated in a manner such that the letters \n/// shift down by two\
    \ multiplied to two places.\n/// For example:\n/// >>> encrypt(s: \"hi\")\n///\
    \ \"lm\"\n/// >>> encrypt(s: \"asdfghjkl\")\n/// \"ewhjklnop\"\n/// >>> encrypt(s:\
    \ \"gf\")\n/// \"kj\"\n/// >>> encrypt(s: \"et\")\n/// \"ix\"\nfunc encrypt(s:\
    \ String) -> String {\n    let letters = Array(s)\n    var encrypted = \"\"\n\
    \    for letter in letters {\n        if letter == \" \" {\n            encrypted\
    \ += \" \"\n        } else {\n            encrypted += encryptLetter(s: String(letter))\n\
    \        }\n    }\n    return encrypted\n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(encrypt(s: \"hi\") == \"lm\")\nassert(encrypt(s: \"asdfghjkl\") == \"ewhjklnop\"\
    )\nassert(encrypt(s: \"gf\") == \"kj\")\nassert(encrypt(s: \"et\") == \"ix\")\n\
    assert(encrypt(s: \"faewfawefaewg\") == \"jeiajeaijeiak\")\nassert(encrypt(s:\
    \ \"hellomyfriend\") == \"lippsqcjvmirh\")\nassert(encrypt(s: \"dxzdlmnilfuhmilufhlihufnmlimnufhlimnufhfucufh\"\
    ) == \"hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl\")\nassert(encrypt(s: \"\
    a\") == \"e\")"
  status: SyntaxError
  stderr: "/tmp/tmptayzceeh.swift:22:26: error: cannot find 'encryptLetter' in scope\n\
    \            encrypted += encryptLetter(s: String(letter))\n                 \
    \        ^~~~~~~~~~~~~\n"
  stdout: ''
  timestamp: 1660028311
- exit_code: -4
  program: "\n/// Create a function encrypt that takes a string as an argument and\n\
    /// returns a string encrypted with the alphabet being rotated. \n/// The alphabet\
    \ should be rotated in a manner such that the letters \n/// shift down by two\
    \ multiplied to two places.\n/// For example:\n/// >>> encrypt(s: \"hi\")\n///\
    \ \"lm\"\n/// >>> encrypt(s: \"asdfghjkl\")\n/// \"ewhjklnop\"\n/// >>> encrypt(s:\
    \ \"gf\")\n/// \"kj\"\n/// >>> encrypt(s: \"et\")\n/// \"ix\"\nfunc encrypt(s:\
    \ String) -> String {\n    return \"\"\n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(encrypt(s: \"hi\") == \"lm\")\nassert(encrypt(s: \"asdfghjkl\") == \"ewhjklnop\"\
    )\nassert(encrypt(s: \"gf\") == \"kj\")\nassert(encrypt(s: \"et\") == \"ix\")\n\
    assert(encrypt(s: \"faewfawefaewg\") == \"jeiajeaijeiak\")\nassert(encrypt(s:\
    \ \"hellomyfriend\") == \"lippsqcjvmirh\")\nassert(encrypt(s: \"dxzdlmnilfuhmilufhlihufnmlimnufhlimnufhfucufh\"\
    ) == \"hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl\")\nassert(encrypt(s: \"\
    a\") == \"e\")"
  status: Exception
  stderr: 'tmpxsqxg1op/tmpxsqxg1op.swift:32: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b607b4a6c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b607b19db6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b607b19d988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b607b19c7b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpxsqxg1op                        0x00005575dd252307 <unavailable> + 4871

    5    libc.so.6                          0x00002b607b692460 __libc_start_main +
    245

    6    tmpxsqxg1op                        0x00005575dd251f49 <unavailable> + 3913

    '
  stdout: ''
  timestamp: 1660028310
- exit_code: -4
  program: "\n/// Create a function encrypt that takes a string as an argument and\n\
    /// returns a string encrypted with the alphabet being rotated. \n/// The alphabet\
    \ should be rotated in a manner such that the letters \n/// shift down by two\
    \ multiplied to two places.\n/// For example:\n/// >>> encrypt(s: \"hi\")\n///\
    \ \"lm\"\n/// >>> encrypt(s: \"asdfghjkl\")\n/// \"ewhjklnop\"\n/// >>> encrypt(s:\
    \ \"gf\")\n/// \"kj\"\n/// >>> encrypt(s: \"et\")\n/// \"ix\"\nfunc encrypt(s:\
    \ String) -> String {\n    var s = s\n    var result = \"\"\n    for _ in s {\n\
    \        let c = s.removeFirst()\n        switch c {\n        case \"a\"...\"\
    c\":\n            result.append(\"x\")\n        case \"d\"...\"f\":\n        \
    \    result.append(\"y\")\n        case \"g\"...\"i\":\n            result.append(\"\
    z\")\n        case \"j\"...\"l\":\n            result.append(\"a\")\n        case\
    \ \"m\"...\"o\":\n            result.append(\"b\")\n        case \"p\"...\"r\"\
    :\n            result.append(\"c\")\n        case \"s\"...\"u\":\n           \
    \ result.append(\"d\")\n        case \"v\"...\"x\":\n            result.append(\"\
    e\")\n        case \"y\"...\"z\":\n            result.append(\"f\")\n        default:\n\
    \            result.append(c)\n        }\n    }\n    return result\n}\n\n\nfunc\
    \ ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count !=\
    \ right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(encrypt(s: \"hi\") == \"lm\")\nassert(encrypt(s:\
    \ \"asdfghjkl\") == \"ewhjklnop\")\nassert(encrypt(s: \"gf\") == \"kj\")\nassert(encrypt(s:\
    \ \"et\") == \"ix\")\nassert(encrypt(s: \"faewfawefaewg\") == \"jeiajeaijeiak\"\
    )\nassert(encrypt(s: \"hellomyfriend\") == \"lippsqcjvmirh\")\nassert(encrypt(s:\
    \ \"dxzdlmnilfuhmilufhlihufnmlimnufhlimnufhfucufh\") == \"hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl\"\
    )\nassert(encrypt(s: \"a\") == \"e\")"
  status: Exception
  stderr: 'tmpypj0y2sf/tmpypj0y2sf.swift:59: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002abf3725fc80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002abf36f56b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002abf36f56988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002abf36f557b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpypj0y2sf                        0x0000556070f25757 <unavailable> + 5975

    5    libc.so.6                          0x00002abf3744b460 __libc_start_main +
    245

    6    tmpypj0y2sf                        0x0000556070f25399 <unavailable> + 5017

    '
  stdout: ''
  timestamp: 1660028311
- exit_code: 1
  program: "\n/// Create a function encrypt that takes a string as an argument and\n\
    /// returns a string encrypted with the alphabet being rotated. \n/// The alphabet\
    \ should be rotated in a manner such that the letters \n/// shift down by two\
    \ multiplied to two places.\n/// For example:\n/// >>> encrypt(s: \"hi\")\n///\
    \ \"lm\"\n/// >>> encrypt(s: \"asdfghjkl\")\n/// \"ewhjklnop\"\n/// >>> encrypt(s:\
    \ \"gf\")\n/// \"kj\"\n/// >>> encrypt(s: \"et\")\n/// \"ix\"\nfunc encrypt(s:\
    \ String) -> String {\n    var str = \"\"\n    for letter in s {\n        str\
    \ += String(letter)\n    }\n    let uppercase = \"ABCDEFGHIJKLMNOPQRSTUVWXYZ\"\
    \n    let lowercase = \"abcdefghijklmnopqrstuvwxyz\"\n    var encrypted = \"\"\
    \n    for i in str {\n        if lowercase.contains(i) {\n            var index\
    \ = lowercase.firstIndex(of: i)!\n            encrypted += String(lowercase[index.advanced(by:\
    \ 2)])\n        } else if uppercase.contains(i) {\n            var index = uppercase.firstIndex(of:\
    \ i)!\n            encrypted += String(uppercase[index.advanced(by: 2)])\n   \
    \     } else {\n            encrypted += String(i)\n        }\n    }\n    return\
    \ encrypted\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n\
    \    if left.count != right.count {\n        return false\n    }\n    for (l,\
    \ r) in zip(left, right) {\n        if l != r {\n            return false\n  \
    \      }\n    }\n    return true\n}\n            \nassert(encrypt(s: \"hi\") ==\
    \ \"lm\")\nassert(encrypt(s: \"asdfghjkl\") == \"ewhjklnop\")\nassert(encrypt(s:\
    \ \"gf\") == \"kj\")\nassert(encrypt(s: \"et\") == \"ix\")\nassert(encrypt(s:\
    \ \"faewfawefaewg\") == \"jeiajeaijeiak\")\nassert(encrypt(s: \"hellomyfriend\"\
    ) == \"lippsqcjvmirh\")\nassert(encrypt(s: \"dxzdlmnilfuhmilufhlihufnmlimnufhlimnufhfucufh\"\
    ) == \"hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl\")\nassert(encrypt(s: \"\
    a\") == \"e\")"
  status: SyntaxError
  stderr: "/tmp/tmp17eo2zvr.swift:26:49: error: value of type 'String.Index' has no\
    \ member 'advanced'\n            encrypted += String(lowercase[index.advanced(by:\
    \ 2)])\n                                          ~~~~~ ^~~~~~~~\n/tmp/tmp17eo2zvr.swift:29:49:\
    \ error: value of type 'String.Index' has no member 'advanced'\n            encrypted\
    \ += String(uppercase[index.advanced(by: 2)])\n                              \
    \            ~~~~~ ^~~~~~~~\n"
  stdout: ''
  timestamp: 1660028311
- exit_code: -4
  program: "\n/// Create a function encrypt that takes a string as an argument and\n\
    /// returns a string encrypted with the alphabet being rotated. \n/// The alphabet\
    \ should be rotated in a manner such that the letters \n/// shift down by two\
    \ multiplied to two places.\n/// For example:\n/// >>> encrypt(s: \"hi\")\n///\
    \ \"lm\"\n/// >>> encrypt(s: \"asdfghjkl\")\n/// \"ewhjklnop\"\n/// >>> encrypt(s:\
    \ \"gf\")\n/// \"kj\"\n/// >>> encrypt(s: \"et\")\n/// \"ix\"\nfunc encrypt(s:\
    \ String) -> String {\n  var stringArray = [Character]()\n  for char in s {\n\
    \    stringArray.append(char)\n  }\n  for i in 0..<stringArray.count {\n    if\
    \ (stringArray[i] == \"z\") {\n      stringArray[i] = \"b\"\n    } else if (stringArray[i]\
    \ == \"y\") {\n      stringArray[i] = \"a\"\n    } else {\n      let index = Int(String(stringArray[i]))!\n\
    \      stringArray[i] = Character(UnicodeScalar(index + 2)!)\n    }\n  }\n  return\
    \ String(stringArray)\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(encrypt(s:\
    \ \"hi\") == \"lm\")\nassert(encrypt(s: \"asdfghjkl\") == \"ewhjklnop\")\nassert(encrypt(s:\
    \ \"gf\") == \"kj\")\nassert(encrypt(s: \"et\") == \"ix\")\nassert(encrypt(s:\
    \ \"faewfawefaewg\") == \"jeiajeaijeiak\")\nassert(encrypt(s: \"hellomyfriend\"\
    ) == \"lippsqcjvmirh\")\nassert(encrypt(s: \"dxzdlmnilfuhmilufhlihufnmlimnufhlimnufhfucufh\"\
    ) == \"hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl\")\nassert(encrypt(s: \"\
    a\") == \"e\")"
  status: Exception
  stderr: 'tmpv1vnrg72/tmpv1vnrg72.swift:26: Fatal error: Unexpectedly found nil while
    unwrapping an Optional value

    Current stack trace:

    0    libswiftCore.so                    0x00002b33db955c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b33db64c561 <unavailable> + 1434977

    2    libswiftCore.so                    0x00002b33db64c286 <unavailable> + 1434246

    3    libswiftCore.so                    0x00002b33db64c13c <unavailable> + 1433916

    4    libswiftCore.so                    0x00002b33db64bbb0 _assertionFailure(_:_:file:line:flags:)
    + 251

    5    tmpv1vnrg72                        0x000055b83c89a801 <unavailable> + 10241

    6    tmpv1vnrg72                        0x000055b83c899996 <unavailable> + 6550

    7    libc.so.6                          0x00002b33dbb41460 __libc_start_main +
    245

    8    tmpv1vnrg72                        0x000055b83c899699 <unavailable> + 5785

    '
  stdout: ''
  timestamp: 1660028311
- exit_code: -4
  program: "\n/// Create a function encrypt that takes a string as an argument and\n\
    /// returns a string encrypted with the alphabet being rotated. \n/// The alphabet\
    \ should be rotated in a manner such that the letters \n/// shift down by two\
    \ multiplied to two places.\n/// For example:\n/// >>> encrypt(s: \"hi\")\n///\
    \ \"lm\"\n/// >>> encrypt(s: \"asdfghjkl\")\n/// \"ewhjklnop\"\n/// >>> encrypt(s:\
    \ \"gf\")\n/// \"kj\"\n/// >>> encrypt(s: \"et\")\n/// \"ix\"\nfunc encrypt(s:\
    \ String) -> String {\n    var arr = Array(s)\n    var result = \"\"\n    for\
    \ i in 0..<arr.count {\n        let char = arr[i]\n        if char == \"a\" {\n\
    \            result += \"c\"\n        } else if char == \"b\" {\n            result\
    \ += \"d\"\n        } else if char == \"c\" {\n            result += \"e\"\n \
    \       } else if char == \"d\" {\n            result += \"f\"\n        } else\
    \ if char == \"e\" {\n            result += \"g\"\n        } else if char == \"\
    f\" {\n            result += \"h\"\n        } else if char == \"g\" {\n      \
    \      result += \"i\"\n        } else if char == \"h\" {\n            result\
    \ += \"j\"\n        } else if char == \"i\" {\n            result += \"k\"\n \
    \       } else if char == \"j\" {\n            result += \"l\"\n        } else\
    \ if char == \"k\" {\n            result += \"m\"\n        } else if char == \"\
    l\" {\n            result += \"n\"\n        } else if char == \"m\" {\n      \
    \      result += \"o\"\n        } else if char == \"n\" {\n            result\
    \ += \"p\"\n        } else if char == \"o\" {\n            result += \"q\"\n \
    \       } else if char == \"p\" {\n            result += \"r\"\n        } else\
    \ if char == \"q\" {\n            result += \"s\"\n        } else if char == \"\
    r\" {\n            result += \"t\"\n        } else if char == \"s\" {\n      \
    \      result += \"u\"\n        } else if char == \"t\" {\n            result\
    \ += \"v\"\n        } else if char == \"u\" {\n            result += \"w\"\n \
    \       } else if char == \"v\" {\n            result += \"x\"\n        } else\
    \ if char == \"w\" {\n            result += \"y\"\n        } else if char == \"\
    x\" {\n            result += \"z\"\n        } else if char == \"y\" {\n      \
    \      result += \"a\"\n        } else if char == \"z\" {\n            result\
    \ += \"b\"\n        }\n    }\n    return result\n}\n\n\nfunc ==(left: [(Int, Int)],\
    \ right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n       \
    \ return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r\
    \ {\n            return false\n        }\n    }\n    return true\n}\n        \
    \    \nassert(encrypt(s: \"hi\") == \"lm\")\nassert(encrypt(s: \"asdfghjkl\")\
    \ == \"ewhjklnop\")\nassert(encrypt(s: \"gf\") == \"kj\")\nassert(encrypt(s: \"\
    et\") == \"ix\")\nassert(encrypt(s: \"faewfawefaewg\") == \"jeiajeaijeiak\")\n\
    assert(encrypt(s: \"hellomyfriend\") == \"lippsqcjvmirh\")\nassert(encrypt(s:\
    \ \"dxzdlmnilfuhmilufhlihufnmlimnufhlimnufhfucufh\") == \"hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl\"\
    )\nassert(encrypt(s: \"a\") == \"e\")"
  status: Exception
  stderr: 'tmp01_ks_nk/tmp01_ks_nk.swift:90: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002aadf3081c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002aadf2d78b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002aadf2d78988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002aadf2d777b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmp01_ks_nk                        0x0000558a326ba7e7 <unavailable> + 6119

    5    libc.so.6                          0x00002aadf326d460 __libc_start_main +
    245

    6    tmp01_ks_nk                        0x0000558a326ba429 <unavailable> + 5161

    '
  stdout: ''
  timestamp: 1660028311
- exit_code: 1
  program: "\n/// Create a function encrypt that takes a string as an argument and\n\
    /// returns a string encrypted with the alphabet being rotated. \n/// The alphabet\
    \ should be rotated in a manner such that the letters \n/// shift down by two\
    \ multiplied to two places.\n/// For example:\n/// >>> encrypt(s: \"hi\")\n///\
    \ \"lm\"\n/// >>> encrypt(s: \"asdfghjkl\")\n/// \"ewhjklnop\"\n/// >>> encrypt(s:\
    \ \"gf\")\n/// \"kj\"\n/// >>> encrypt(s: \"et\")\n/// \"ix\"\nfunc encrypt(s:\
    \ String) -> String {\n    \n    var newString = \"\"\n    let lowerCaseLetters\
    \ = \"abcdefghijklmnopqrstuvwxyz\"\n    for letter in s {\n        if let index\
    \ = lowerCaseLetters.firstIndex(of: letter) {\n            if index >= 18 {\n\
    \                let newLetter = lowerCaseLetters[index-18]\n                newString.append(newLetter)\n\
    \            } else {\n                let newLetter = lowerCaseLetters[index+8]\n\
    \                newString.append(newLetter)\n            }\n        }\n    }\n\
    \    return newString\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(encrypt(s:\
    \ \"hi\") == \"lm\")\nassert(encrypt(s: \"asdfghjkl\") == \"ewhjklnop\")\nassert(encrypt(s:\
    \ \"gf\") == \"kj\")\nassert(encrypt(s: \"et\") == \"ix\")\nassert(encrypt(s:\
    \ \"faewfawefaewg\") == \"jeiajeaijeiak\")\nassert(encrypt(s: \"hellomyfriend\"\
    ) == \"lippsqcjvmirh\")\nassert(encrypt(s: \"dxzdlmnilfuhmilufhlihufnmlimnufhlimnufhfucufh\"\
    ) == \"hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl\")\nassert(encrypt(s: \"\
    a\") == \"e\")"
  status: SyntaxError
  stderr: "/tmp/tmp4v_teks_.swift:21:22: error: referencing operator function '>='\
    \ on 'BinaryInteger' requires that 'String.Index' conform to 'BinaryInteger'\n\
    \            if index >= 18 {\n                     ^\nSwift.BinaryInteger:1:11:\
    \ note: where 'Self' = 'String.Index'\nextension BinaryInteger {\n          ^\n\
    /tmp/tmp4v_teks_.swift:22:50: error: cannot convert value of type 'String.Index'\
    \ to expected argument type 'Int'\n                let newLetter = lowerCaseLetters[index-18]\n\
    \                                                 ^\n/tmp/tmp4v_teks_.swift:25:50:\
    \ error: cannot convert value of type 'String.Index' to expected argument type\
    \ 'Int'\n                let newLetter = lowerCaseLetters[index+8]\n         \
    \                                        ^\n"
  stdout: ''
  timestamp: 1660028311
- exit_code: -4
  program: "\n/// Create a function encrypt that takes a string as an argument and\n\
    /// returns a string encrypted with the alphabet being rotated. \n/// The alphabet\
    \ should be rotated in a manner such that the letters \n/// shift down by two\
    \ multiplied to two places.\n/// For example:\n/// >>> encrypt(s: \"hi\")\n///\
    \ \"lm\"\n/// >>> encrypt(s: \"asdfghjkl\")\n/// \"ewhjklnop\"\n/// >>> encrypt(s:\
    \ \"gf\")\n/// \"kj\"\n/// >>> encrypt(s: \"et\")\n/// \"ix\"\nfunc encrypt(s:\
    \ String) -> String {\n    // REPLACE ME\n    return \"\"\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(encrypt(s: \"hi\") == \"lm\")\nassert(encrypt(s: \"asdfghjkl\"\
    ) == \"ewhjklnop\")\nassert(encrypt(s: \"gf\") == \"kj\")\nassert(encrypt(s: \"\
    et\") == \"ix\")\nassert(encrypt(s: \"faewfawefaewg\") == \"jeiajeaijeiak\")\n\
    assert(encrypt(s: \"hellomyfriend\") == \"lippsqcjvmirh\")\nassert(encrypt(s:\
    \ \"dxzdlmnilfuhmilufhlihufnmlimnufhlimnufhfucufh\") == \"hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl\"\
    )\nassert(encrypt(s: \"a\") == \"e\")"
  status: Exception
  stderr: 'tmpv12njk2h/tmpv12njk2h.swift:33: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002aad7ee91c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002aad7eb88b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002aad7eb88988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002aad7eb877b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpv12njk2h                        0x00005590e5d0e307 <unavailable> + 4871

    5    libc.so.6                          0x00002aad7f07d460 __libc_start_main +
    245

    6    tmpv12njk2h                        0x00005590e5d0df49 <unavailable> + 3913

    '
  stdout: ''
  timestamp: 1660028311
- exit_code: 1
  program: "\n/// Create a function encrypt that takes a string as an argument and\n\
    /// returns a string encrypted with the alphabet being rotated. \n/// The alphabet\
    \ should be rotated in a manner such that the letters \n/// shift down by two\
    \ multiplied to two places.\n/// For example:\n/// >>> encrypt(s: \"hi\")\n///\
    \ \"lm\"\n/// >>> encrypt(s: \"asdfghjkl\")\n/// \"ewhjklnop\"\n/// >>> encrypt(s:\
    \ \"gf\")\n/// \"kj\"\n/// >>> encrypt(s: \"et\")\n/// \"ix\"\nfunc encrypt(s:\
    \ String) -> String {\n    return String(s.map { (i) -> Character in\n       \
    \ let value = i.asciiValue! + (i.asciiValue! <= 110 ? -54 : -38)\n        return\
    \ Character(UnicodeScalar(value)!)\n    })\n}\n\n\nfunc ==(left: [(Int, Int)],\
    \ right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n       \
    \ return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r\
    \ {\n            return false\n        }\n    }\n    return true\n}\n        \
    \    \nassert(encrypt(s: \"hi\") == \"lm\")\nassert(encrypt(s: \"asdfghjkl\")\
    \ == \"ewhjklnop\")\nassert(encrypt(s: \"gf\") == \"kj\")\nassert(encrypt(s: \"\
    et\") == \"ix\")\nassert(encrypt(s: \"faewfawefaewg\") == \"jeiajeaijeiak\")\n\
    assert(encrypt(s: \"hellomyfriend\") == \"lippsqcjvmirh\")\nassert(encrypt(s:\
    \ \"dxzdlmnilfuhmilufhlihufnmlimnufhlimnufhfucufh\") == \"hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl\"\
    )\nassert(encrypt(s: \"a\") == \"e\")"
  status: SyntaxError
  stderr: "/tmp/tmphvq1okpg.swift:18:46: error: cannot force unwrap value of non-optional\
    \ type 'UnicodeScalar' (aka 'Unicode.Scalar')\n        return Character(UnicodeScalar(value)!)\n\
    \                         ~~~~~~~~~~~~~~~~~~~~^\n                            \
    \                 \n"
  stdout: ''
  timestamp: 1660028311
- exit_code: 0
  program: "\n/// Create a function encrypt that takes a string as an argument and\n\
    /// returns a string encrypted with the alphabet being rotated. \n/// The alphabet\
    \ should be rotated in a manner such that the letters \n/// shift down by two\
    \ multiplied to two places.\n/// For example:\n/// >>> encrypt(s: \"hi\")\n///\
    \ \"lm\"\n/// >>> encrypt(s: \"asdfghjkl\")\n/// \"ewhjklnop\"\n/// >>> encrypt(s:\
    \ \"gf\")\n/// \"kj\"\n/// >>> encrypt(s: \"et\")\n/// \"ix\"\nfunc encrypt(s:\
    \ String) -> String {\n    let cipher = \"abcdefghijklmnopqrstuvwxyz\"\n    var\
    \ tempStr = \"\"\n    for letter in s {\n        if let index = cipher.firstIndex(of:\
    \ letter) {\n            tempStr.append(cipher[cipher.index(cipher.startIndex,\
    \ offsetBy: ((index.encodedOffset + 4) % 26))])\n        }\n    }\n    return\
    \ tempStr\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n\
    \    if left.count != right.count {\n        return false\n    }\n    for (l,\
    \ r) in zip(left, right) {\n        if l != r {\n            return false\n  \
    \      }\n    }\n    return true\n}\n            \nassert(encrypt(s: \"hi\") ==\
    \ \"lm\")\nassert(encrypt(s: \"asdfghjkl\") == \"ewhjklnop\")\nassert(encrypt(s:\
    \ \"gf\") == \"kj\")\nassert(encrypt(s: \"et\") == \"ix\")\nassert(encrypt(s:\
    \ \"faewfawefaewg\") == \"jeiajeaijeiak\")\nassert(encrypt(s: \"hellomyfriend\"\
    ) == \"lippsqcjvmirh\")\nassert(encrypt(s: \"dxzdlmnilfuhmilufhlihufnmlimnufhlimnufhfucufh\"\
    ) == \"hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl\")\nassert(encrypt(s: \"\
    a\") == \"e\")"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660028311
- exit_code: -4
  program: "\n/// Create a function encrypt that takes a string as an argument and\n\
    /// returns a string encrypted with the alphabet being rotated. \n/// The alphabet\
    \ should be rotated in a manner such that the letters \n/// shift down by two\
    \ multiplied to two places.\n/// For example:\n/// >>> encrypt(s: \"hi\")\n///\
    \ \"lm\"\n/// >>> encrypt(s: \"asdfghjkl\")\n/// \"ewhjklnop\"\n/// >>> encrypt(s:\
    \ \"gf\")\n/// \"kj\"\n/// >>> encrypt(s: \"et\")\n/// \"ix\"\nfunc encrypt(s:\
    \ String) -> String {\n    // TODO: write your code here\n    return \"\"\n}\n\
    \n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(encrypt(s: \"hi\") == \"lm\")\nassert(encrypt(s:\
    \ \"asdfghjkl\") == \"ewhjklnop\")\nassert(encrypt(s: \"gf\") == \"kj\")\nassert(encrypt(s:\
    \ \"et\") == \"ix\")\nassert(encrypt(s: \"faewfawefaewg\") == \"jeiajeaijeiak\"\
    )\nassert(encrypt(s: \"hellomyfriend\") == \"lippsqcjvmirh\")\nassert(encrypt(s:\
    \ \"dxzdlmnilfuhmilufhlihufnmlimnufhlimnufhfucufh\") == \"hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl\"\
    )\nassert(encrypt(s: \"a\") == \"e\")"
  status: Exception
  stderr: 'tmp0g_bnz4t/tmp0g_bnz4t.swift:33: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b40b1126c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b40b0e1db6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b40b0e1d988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b40b0e1c7b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmp0g_bnz4t                        0x000056147488e307 <unavailable> + 4871

    5    libc.so.6                          0x00002b40b1312460 __libc_start_main +
    245

    6    tmp0g_bnz4t                        0x000056147488df49 <unavailable> + 3913

    '
  stdout: ''
  timestamp: 1660028311
- exit_code: -4
  program: "\n/// Create a function encrypt that takes a string as an argument and\n\
    /// returns a string encrypted with the alphabet being rotated. \n/// The alphabet\
    \ should be rotated in a manner such that the letters \n/// shift down by two\
    \ multiplied to two places.\n/// For example:\n/// >>> encrypt(s: \"hi\")\n///\
    \ \"lm\"\n/// >>> encrypt(s: \"asdfghjkl\")\n/// \"ewhjklnop\"\n/// >>> encrypt(s:\
    \ \"gf\")\n/// \"kj\"\n/// >>> encrypt(s: \"et\")\n/// \"ix\"\nfunc encrypt(s:\
    \ String) -> String {\n    return \"\"\n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(encrypt(s: \"hi\") == \"lm\")\nassert(encrypt(s: \"asdfghjkl\") == \"ewhjklnop\"\
    )\nassert(encrypt(s: \"gf\") == \"kj\")\nassert(encrypt(s: \"et\") == \"ix\")\n\
    assert(encrypt(s: \"faewfawefaewg\") == \"jeiajeaijeiak\")\nassert(encrypt(s:\
    \ \"hellomyfriend\") == \"lippsqcjvmirh\")\nassert(encrypt(s: \"dxzdlmnilfuhmilufhlihufnmlimnufhlimnufhfucufh\"\
    ) == \"hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl\")\nassert(encrypt(s: \"\
    a\") == \"e\")"
  status: Exception
  stderr: 'tmpxsqxg1op/tmpxsqxg1op.swift:32: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b607b4a6c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b607b19db6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b607b19d988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b607b19c7b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpxsqxg1op                        0x00005575dd252307 <unavailable> + 4871

    5    libc.so.6                          0x00002b607b692460 __libc_start_main +
    245

    6    tmpxsqxg1op                        0x00005575dd251f49 <unavailable> + 3913

    '
  stdout: ''
  timestamp: 1660028310
- exit_code: 1
  program: "\n/// Create a function encrypt that takes a string as an argument and\n\
    /// returns a string encrypted with the alphabet being rotated. \n/// The alphabet\
    \ should be rotated in a manner such that the letters \n/// shift down by two\
    \ multiplied to two places.\n/// For example:\n/// >>> encrypt(s: \"hi\")\n///\
    \ \"lm\"\n/// >>> encrypt(s: \"asdfghjkl\")\n/// \"ewhjklnop\"\n/// >>> encrypt(s:\
    \ \"gf\")\n/// \"kj\"\n/// >>> encrypt(s: \"et\")\n/// \"ix\"\nfunc encrypt(s:\
    \ String) -> String {\n    return encryptHelper(s: s, offset: 2, times: 2)\n}\n\
    \n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(encrypt(s: \"hi\") == \"lm\")\nassert(encrypt(s:\
    \ \"asdfghjkl\") == \"ewhjklnop\")\nassert(encrypt(s: \"gf\") == \"kj\")\nassert(encrypt(s:\
    \ \"et\") == \"ix\")\nassert(encrypt(s: \"faewfawefaewg\") == \"jeiajeaijeiak\"\
    )\nassert(encrypt(s: \"hellomyfriend\") == \"lippsqcjvmirh\")\nassert(encrypt(s:\
    \ \"dxzdlmnilfuhmilufhlihufnmlimnufhlimnufhfucufh\") == \"hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl\"\
    )\nassert(encrypt(s: \"a\") == \"e\")"
  status: SyntaxError
  stderr: "/tmp/tmpzn26yx0y.swift:16:12: error: cannot find 'encryptHelper' in scope\n\
    \    return encryptHelper(s: s, offset: 2, times: 2)\n           ^~~~~~~~~~~~~\n"
  stdout: ''
  timestamp: 1660028311
- exit_code: 1
  program: "\n/// Create a function encrypt that takes a string as an argument and\n\
    /// returns a string encrypted with the alphabet being rotated. \n/// The alphabet\
    \ should be rotated in a manner such that the letters \n/// shift down by two\
    \ multiplied to two places.\n/// For example:\n/// >>> encrypt(s: \"hi\")\n///\
    \ \"lm\"\n/// >>> encrypt(s: \"asdfghjkl\")\n/// \"ewhjklnop\"\n/// >>> encrypt(s:\
    \ \"gf\")\n/// \"kj\"\n/// >>> encrypt(s: \"et\")\n/// \"ix\"\nfunc encrypt(s:\
    \ String) -> String {\n    let charArray = Array(s)\n    var encryptArray = [Character]()\n\
    \    for char in charArray {\n        encryptArray.append(encryptChar(c: char))\n\
    \    }\n    return String(encryptArray)\n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(encrypt(s: \"hi\") == \"lm\")\nassert(encrypt(s: \"asdfghjkl\") == \"ewhjklnop\"\
    )\nassert(encrypt(s: \"gf\") == \"kj\")\nassert(encrypt(s: \"et\") == \"ix\")\n\
    assert(encrypt(s: \"faewfawefaewg\") == \"jeiajeaijeiak\")\nassert(encrypt(s:\
    \ \"hellomyfriend\") == \"lippsqcjvmirh\")\nassert(encrypt(s: \"dxzdlmnilfuhmilufhlihufnmlimnufhlimnufhfucufh\"\
    ) == \"hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl\")\nassert(encrypt(s: \"\
    a\") == \"e\")"
  status: SyntaxError
  stderr: "/tmp/tmpntyb_eiw.swift:19:29: error: cannot find 'encryptChar' in scope\n\
    \        encryptArray.append(encryptChar(c: char))\n                         \
    \   ^~~~~~~~~~~\n"
  stdout: ''
  timestamp: 1660028311
- exit_code: -4
  program: "\n/// Create a function encrypt that takes a string as an argument and\n\
    /// returns a string encrypted with the alphabet being rotated. \n/// The alphabet\
    \ should be rotated in a manner such that the letters \n/// shift down by two\
    \ multiplied to two places.\n/// For example:\n/// >>> encrypt(s: \"hi\")\n///\
    \ \"lm\"\n/// >>> encrypt(s: \"asdfghjkl\")\n/// \"ewhjklnop\"\n/// >>> encrypt(s:\
    \ \"gf\")\n/// \"kj\"\n/// >>> encrypt(s: \"et\")\n/// \"ix\"\nfunc encrypt(s:\
    \ String) -> String {\n    // your code here\n    return \"\"\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(encrypt(s: \"hi\") == \"lm\")\nassert(encrypt(s: \"asdfghjkl\"\
    ) == \"ewhjklnop\")\nassert(encrypt(s: \"gf\") == \"kj\")\nassert(encrypt(s: \"\
    et\") == \"ix\")\nassert(encrypt(s: \"faewfawefaewg\") == \"jeiajeaijeiak\")\n\
    assert(encrypt(s: \"hellomyfriend\") == \"lippsqcjvmirh\")\nassert(encrypt(s:\
    \ \"dxzdlmnilfuhmilufhlihufnmlimnufhlimnufhfucufh\") == \"hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl\"\
    )\nassert(encrypt(s: \"a\") == \"e\")"
  status: Exception
  stderr: 'tmprx16si5i/tmprx16si5i.swift:33: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b5d5168dc80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b5d51384b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b5d51384988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b5d513837b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmprx16si5i                        0x00005591330b6307 <unavailable> + 4871

    5    libc.so.6                          0x00002b5d51879460 __libc_start_main +
    245

    6    tmprx16si5i                        0x00005591330b5f49 <unavailable> + 3913

    '
  stdout: ''
  timestamp: 1660028310
- exit_code: -4
  program: "\n/// Create a function encrypt that takes a string as an argument and\n\
    /// returns a string encrypted with the alphabet being rotated. \n/// The alphabet\
    \ should be rotated in a manner such that the letters \n/// shift down by two\
    \ multiplied to two places.\n/// For example:\n/// >>> encrypt(s: \"hi\")\n///\
    \ \"lm\"\n/// >>> encrypt(s: \"asdfghjkl\")\n/// \"ewhjklnop\"\n/// >>> encrypt(s:\
    \ \"gf\")\n/// \"kj\"\n/// >>> encrypt(s: \"et\")\n/// \"ix\"\nfunc encrypt(s:\
    \ String) -> String {\n    return String(s.map { (c) -> Character in\n       \
    \ let a = Int(c.asciiValue!)\n        let b = UInt8(a - 97)\n        return Character(UnicodeScalar(UInt8((b\
    \ + 2) % 26 + 97)))\n    })\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int,\
    \ Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n\
    \    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n          \
    \  return false\n        }\n    }\n    return true\n}\n            \nassert(encrypt(s:\
    \ \"hi\") == \"lm\")\nassert(encrypt(s: \"asdfghjkl\") == \"ewhjklnop\")\nassert(encrypt(s:\
    \ \"gf\") == \"kj\")\nassert(encrypt(s: \"et\") == \"ix\")\nassert(encrypt(s:\
    \ \"faewfawefaewg\") == \"jeiajeaijeiak\")\nassert(encrypt(s: \"hellomyfriend\"\
    ) == \"lippsqcjvmirh\")\nassert(encrypt(s: \"dxzdlmnilfuhmilufhlihufnmlimnufhlimnufhfucufh\"\
    ) == \"hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl\")\nassert(encrypt(s: \"\
    a\") == \"e\")"
  status: Exception
  stderr: 'tmpjh7lm437/tmpjh7lm437.swift:36: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002ba456033c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002ba455d2ab6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002ba455d2a988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002ba455d297b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpjh7lm437                        0x00005569a40f98f7 <unavailable> + 6391

    5    libc.so.6                          0x00002ba45621f460 __libc_start_main +
    245

    6    tmpjh7lm437                        0x00005569a40f9539 <unavailable> + 5433

    '
  stdout: ''
  timestamp: 1660028312
- exit_code: 1
  program: "\n/// Create a function encrypt that takes a string as an argument and\n\
    /// returns a string encrypted with the alphabet being rotated. \n/// The alphabet\
    \ should be rotated in a manner such that the letters \n/// shift down by two\
    \ multiplied to two places.\n/// For example:\n/// >>> encrypt(s: \"hi\")\n///\
    \ \"lm\"\n/// >>> encrypt(s: \"asdfghjkl\")\n/// \"ewhjklnop\"\n/// >>> encrypt(s:\
    \ \"gf\")\n/// \"kj\"\n/// >>> encrypt(s: \"et\")\n/// \"ix\"\nfunc encrypt(s:\
    \ String) -> String {\n    var encryptedString = \"\"\n    for character in s\
    \ {\n        if let index = alphabet.firstIndex(of: character) {\n           \
    \ encryptedString.append(alphabet[(index + (2 * 2)) % alphabet.count])\n     \
    \   }\n    }\n    return encryptedString\n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(encrypt(s: \"hi\") == \"lm\")\nassert(encrypt(s: \"asdfghjkl\") == \"ewhjklnop\"\
    )\nassert(encrypt(s: \"gf\") == \"kj\")\nassert(encrypt(s: \"et\") == \"ix\")\n\
    assert(encrypt(s: \"faewfawefaewg\") == \"jeiajeaijeiak\")\nassert(encrypt(s:\
    \ \"hellomyfriend\") == \"lippsqcjvmirh\")\nassert(encrypt(s: \"dxzdlmnilfuhmilufhlihufnmlimnufhlimnufhfucufh\"\
    ) == \"hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl\")\nassert(encrypt(s: \"\
    a\") == \"e\")"
  status: SyntaxError
  stderr: "/tmp/tmpnxcmj1w2.swift:18:24: error: cannot find 'alphabet' in scope\n\
    \        if let index = alphabet.firstIndex(of: character) {\n               \
    \        ^~~~~~~~\n/tmp/tmpnxcmj1w2.swift:19:36: error: cannot find 'alphabet'\
    \ in scope\n            encryptedString.append(alphabet[(index + (2 * 2)) % alphabet.count])\n\
    \                                   ^~~~~~~~\n/tmp/tmpnxcmj1w2.swift:19:65: error:\
    \ cannot find 'alphabet' in scope\n            encryptedString.append(alphabet[(index\
    \ + (2 * 2)) % alphabet.count])\n                                            \
    \                    ^~~~~~~~\n"
  stdout: ''
  timestamp: 1660028311
- exit_code: 1
  program: "\n/// Create a function encrypt that takes a string as an argument and\n\
    /// returns a string encrypted with the alphabet being rotated. \n/// The alphabet\
    \ should be rotated in a manner such that the letters \n/// shift down by two\
    \ multiplied to two places.\n/// For example:\n/// >>> encrypt(s: \"hi\")\n///\
    \ \"lm\"\n/// >>> encrypt(s: \"asdfghjkl\")\n/// \"ewhjklnop\"\n/// >>> encrypt(s:\
    \ \"gf\")\n/// \"kj\"\n/// >>> encrypt(s: \"et\")\n/// \"ix\"\nfunc encrypt(s:\
    \ String) -> String {\n    // your code here\n    var encryptS = \"\"\n    for\
    \ i in s {\n        encryptS += encryptDict[i]!\n    }\n    return encryptS\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(encrypt(s: \"hi\") == \"lm\")\nassert(encrypt(s:\
    \ \"asdfghjkl\") == \"ewhjklnop\")\nassert(encrypt(s: \"gf\") == \"kj\")\nassert(encrypt(s:\
    \ \"et\") == \"ix\")\nassert(encrypt(s: \"faewfawefaewg\") == \"jeiajeaijeiak\"\
    )\nassert(encrypt(s: \"hellomyfriend\") == \"lippsqcjvmirh\")\nassert(encrypt(s:\
    \ \"dxzdlmnilfuhmilufhlihufnmlimnufhlimnufhfucufh\") == \"hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl\"\
    )\nassert(encrypt(s: \"a\") == \"e\")"
  status: SyntaxError
  stderr: "/tmp/tmpb9ixi5gw.swift:19:21: error: cannot find 'encryptDict' in scope\n\
    \        encryptS += encryptDict[i]!\n                    ^~~~~~~~~~~\n"
  stdout: ''
  timestamp: 1660028311
- exit_code: 1
  program: "\n/// Create a function encrypt that takes a string as an argument and\n\
    /// returns a string encrypted with the alphabet being rotated. \n/// The alphabet\
    \ should be rotated in a manner such that the letters \n/// shift down by two\
    \ multiplied to two places.\n/// For example:\n/// >>> encrypt(s: \"hi\")\n///\
    \ \"lm\"\n/// >>> encrypt(s: \"asdfghjkl\")\n/// \"ewhjklnop\"\n/// >>> encrypt(s:\
    \ \"gf\")\n/// \"kj\"\n/// >>> encrypt(s: \"et\")\n/// \"ix\"\nfunc encrypt(s:\
    \ String) -> String {\n    let alphabet = Array(\"abcdefghijklmnopqrstuvwxyz\"\
    )\n    let letterToIndex = [Character: Int]()\n    let indexToLetter = [Int: Character]()\n\
    \    for (i, c) in alphabet.enumerated() {\n        letterToIndex[c] = i\n   \
    \     indexToLetter[i] = c\n    }\n    var result = [Character]()\n    for char\
    \ in s {\n        let index = letterToIndex[char]!\n        let newIndex = (index\
    \ + 2) % 26\n        result.append(indexToLetter[newIndex]!)\n    }\n    return\
    \ String(result)\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool\
    \ {\n    if left.count != right.count {\n        return false\n    }\n    for\
    \ (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(encrypt(s: \"hi\"\
    ) == \"lm\")\nassert(encrypt(s: \"asdfghjkl\") == \"ewhjklnop\")\nassert(encrypt(s:\
    \ \"gf\") == \"kj\")\nassert(encrypt(s: \"et\") == \"ix\")\nassert(encrypt(s:\
    \ \"faewfawefaewg\") == \"jeiajeaijeiak\")\nassert(encrypt(s: \"hellomyfriend\"\
    ) == \"lippsqcjvmirh\")\nassert(encrypt(s: \"dxzdlmnilfuhmilufhlihufnmlimnufhlimnufhfucufh\"\
    ) == \"hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl\")\nassert(encrypt(s: \"\
    a\") == \"e\")"
  status: SyntaxError
  stderr: "/tmp/tmplhr80emh.swift:20:22: error: cannot assign through subscript: 'letterToIndex'\
    \ is a 'let' constant\n        letterToIndex[c] = i\n        ~~~~~~~~~~~~~^\n\
    /tmp/tmplhr80emh.swift:17:5: note: change 'let' to 'var' to make it mutable\n\
    \    let letterToIndex = [Character: Int]()\n    ^~~\n    var\n/tmp/tmplhr80emh.swift:21:22:\
    \ error: cannot assign through subscript: 'indexToLetter' is a 'let' constant\n\
    \        indexToLetter[i] = c\n        ~~~~~~~~~~~~~^\n/tmp/tmplhr80emh.swift:18:5:\
    \ note: change 'let' to 'var' to make it mutable\n    let indexToLetter = [Int:\
    \ Character]()\n    ^~~\n    var\n"
  stdout: ''
  timestamp: 1660028311
- exit_code: -4
  program: "\n/// Create a function encrypt that takes a string as an argument and\n\
    /// returns a string encrypted with the alphabet being rotated. \n/// The alphabet\
    \ should be rotated in a manner such that the letters \n/// shift down by two\
    \ multiplied to two places.\n/// For example:\n/// >>> encrypt(s: \"hi\")\n///\
    \ \"lm\"\n/// >>> encrypt(s: \"asdfghjkl\")\n/// \"ewhjklnop\"\n/// >>> encrypt(s:\
    \ \"gf\")\n/// \"kj\"\n/// >>> encrypt(s: \"et\")\n/// \"ix\"\nfunc encrypt(s:\
    \ String) -> String {\n    return \"\"\n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(encrypt(s: \"hi\") == \"lm\")\nassert(encrypt(s: \"asdfghjkl\") == \"ewhjklnop\"\
    )\nassert(encrypt(s: \"gf\") == \"kj\")\nassert(encrypt(s: \"et\") == \"ix\")\n\
    assert(encrypt(s: \"faewfawefaewg\") == \"jeiajeaijeiak\")\nassert(encrypt(s:\
    \ \"hellomyfriend\") == \"lippsqcjvmirh\")\nassert(encrypt(s: \"dxzdlmnilfuhmilufhlihufnmlimnufhlimnufhfucufh\"\
    ) == \"hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl\")\nassert(encrypt(s: \"\
    a\") == \"e\")"
  status: Exception
  stderr: 'tmpxsqxg1op/tmpxsqxg1op.swift:32: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b607b4a6c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b607b19db6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b607b19d988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b607b19c7b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpxsqxg1op                        0x00005575dd252307 <unavailable> + 4871

    5    libc.so.6                          0x00002b607b692460 __libc_start_main +
    245

    6    tmpxsqxg1op                        0x00005575dd251f49 <unavailable> + 3913

    '
  stdout: ''
  timestamp: 1660028310
- exit_code: -4
  program: "\n/// Create a function encrypt that takes a string as an argument and\n\
    /// returns a string encrypted with the alphabet being rotated. \n/// The alphabet\
    \ should be rotated in a manner such that the letters \n/// shift down by two\
    \ multiplied to two places.\n/// For example:\n/// >>> encrypt(s: \"hi\")\n///\
    \ \"lm\"\n/// >>> encrypt(s: \"asdfghjkl\")\n/// \"ewhjklnop\"\n/// >>> encrypt(s:\
    \ \"gf\")\n/// \"kj\"\n/// >>> encrypt(s: \"et\")\n/// \"ix\"\nfunc encrypt(s:\
    \ String) -> String {\n    return \"\"\n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(encrypt(s: \"hi\") == \"lm\")\nassert(encrypt(s: \"asdfghjkl\") == \"ewhjklnop\"\
    )\nassert(encrypt(s: \"gf\") == \"kj\")\nassert(encrypt(s: \"et\") == \"ix\")\n\
    assert(encrypt(s: \"faewfawefaewg\") == \"jeiajeaijeiak\")\nassert(encrypt(s:\
    \ \"hellomyfriend\") == \"lippsqcjvmirh\")\nassert(encrypt(s: \"dxzdlmnilfuhmilufhlihufnmlimnufhlimnufhfucufh\"\
    ) == \"hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl\")\nassert(encrypt(s: \"\
    a\") == \"e\")"
  status: Exception
  stderr: 'tmpxsqxg1op/tmpxsqxg1op.swift:32: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b607b4a6c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b607b19db6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b607b19d988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b607b19c7b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpxsqxg1op                        0x00005575dd252307 <unavailable> + 4871

    5    libc.so.6                          0x00002b607b692460 __libc_start_main +
    245

    6    tmpxsqxg1op                        0x00005575dd251f49 <unavailable> + 3913

    '
  stdout: ''
  timestamp: 1660028310
- exit_code: 1
  program: "\n/// Create a function encrypt that takes a string as an argument and\n\
    /// returns a string encrypted with the alphabet being rotated. \n/// The alphabet\
    \ should be rotated in a manner such that the letters \n/// shift down by two\
    \ multiplied to two places.\n/// For example:\n/// >>> encrypt(s: \"hi\")\n///\
    \ \"lm\"\n/// >>> encrypt(s: \"asdfghjkl\")\n/// \"ewhjklnop\"\n/// >>> encrypt(s:\
    \ \"gf\")\n/// \"kj\"\n/// >>> encrypt(s: \"et\")\n/// \"ix\"\nfunc encrypt(s:\
    \ String) -> String {\n    let charsToBeRotated = Array(s)\n    var charsRotated\
    \ = [Character]()\n    for i in 0..<charsToBeRotated.count {\n        var charRotated\
    \ = charsToBeRotated[i]\n        if charRotated == \"a\" {\n            charRotated\
    \ = \"c\"\n        } else if charRotated == \"b\" {\n            charRotated =\
    \ \"d\"\n        } else if charRotated == \"c\" {\n            charRotated = \"\
    e\"\n        } else if charRotated == \"d\" {\n            charRotated = \"f\"\
    \n        } else if charRotated == \"e\" {\n            charRotated = \"g\"\n\
    \        } else if charRotated == \"f\" {\n            charRotated = \"h\"\n \
    \       } else if charRotated == \"g\" {\n            charRotated = \"i\"\n  \
    \      } else if charRotated == \"h\" {\n            charRotated = \"j\"\n   \
    \     } else if charRotated == \"i\" {\n            charRotated = \"k\"\n    \
    \    } else if charRotated == \"j\" {\n            charRotated = \"l\"\n     \
    \   } else if charRotated == \"k\" {\n            charRotated = \"m\"\n      \
    \  } else if charRotated == \"l\" {\n            charRotated = \"n\"\n       \
    \ } else if charRotated == \"m\" {\n            charRotated = \"o\"\n        }\
    \ else if charRotated == \"n\" {\n            charRotated = \"p\"\n        } else\
    \ if charRotated == \"o\" {\n            charRotated = \"q\"\n        } else if\
    \ charRotated == \"p\" {\n            charRotated = \"r\"\n        } else if charRotated\
    \ == \"q\" {\n            charRotated = \"s\"\n        } else if charRotated ==\
    \ \"r\" {\n            charRotated = \"t\"\n        } else if charRotated == \"\
    s\" {\n            charRotated = \"u\"\n        } else if charRotated == \"t\"\
    \ {\n            charRotated = \"v\"\n        } else if charRotated == \"u\" {\n\
    \            charRotated\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(encrypt(s:\
    \ \"hi\") == \"lm\")\nassert(encrypt(s: \"asdfghjkl\") == \"ewhjklnop\")\nassert(encrypt(s:\
    \ \"gf\") == \"kj\")\nassert(encrypt(s: \"et\") == \"ix\")\nassert(encrypt(s:\
    \ \"faewfawefaewg\") == \"jeiajeaijeiak\")\nassert(encrypt(s: \"hellomyfriend\"\
    ) == \"lippsqcjvmirh\")\nassert(encrypt(s: \"dxzdlmnilfuhmilufhlihufnmlimnufhlimnufhfucufh\"\
    ) == \"hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl\")\nassert(encrypt(s: \"\
    a\") == \"e\")"
  status: SyntaxError
  stderr: "/tmp/tmprk93zc7o.swift:84:31: error: expected '}' at end of brace statement\n\
    assert(encrypt(s: \"a\") == \"e\")\n                              ^\n/tmp/tmprk93zc7o.swift:18:41:\
    \ note: to match this opening '{'\n    for i in 0..<charsToBeRotated.count {\n\
    \                                        ^\n/tmp/tmprk93zc7o.swift:84:31: error:\
    \ expected '}' at end of brace statement\nassert(encrypt(s: \"a\") == \"e\")\n\
    \                              ^\n/tmp/tmprk93zc7o.swift:15:35: note: to match\
    \ this opening '{'\nfunc encrypt(s: String) -> String {\n                    \
    \              ^\n/tmp/tmprk93zc7o.swift:61:13: warning: variable is unused\n\
    \            charRotated\n            ^~~~~~~~~~~\n/tmp/tmprk93zc7o.swift:65:6:\
    \ error: operator functions can only be declared at global or in type scope\n\
    func ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n     ^\n/tmp/tmprk93zc7o.swift:17:9:\
    \ warning: initialization of variable 'charsRotated' was never used; consider\
    \ replacing with assignment to '_' or removing it\n    var charsRotated = [Character]()\n\
    \    ~~~~^~~~~~~~~~~~\n    _\n"
  stdout: ''
  timestamp: 1660028311
- exit_code: 1
  program: "\n/// Create a function encrypt that takes a string as an argument and\n\
    /// returns a string encrypted with the alphabet being rotated. \n/// The alphabet\
    \ should be rotated in a manner such that the letters \n/// shift down by two\
    \ multiplied to two places.\n/// For example:\n/// >>> encrypt(s: \"hi\")\n///\
    \ \"lm\"\n/// >>> encrypt(s: \"asdfghjkl\")\n/// \"ewhjklnop\"\n/// >>> encrypt(s:\
    \ \"gf\")\n/// \"kj\"\n/// >>> encrypt(s: \"et\")\n/// \"ix\"\nfunc encrypt(s:\
    \ String) -> String {\n    let newAlphabet = \"cdefghijklmnopqrstuvwxyzab\"\n\
    \    var stringToReturn = \"\"\n    for i in s {\n        let index = newAlphabet.index(newAlphabet.startIndex,\
    \ offsetBy: alphabet.index(of: i)! + 2)\n        stringToReturn.append(newAlphabet[index])\n\
    \    }\n    return stringToReturn\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int,\
    \ Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n\
    \    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n          \
    \  return false\n        }\n    }\n    return true\n}\n            \nassert(encrypt(s:\
    \ \"hi\") == \"lm\")\nassert(encrypt(s: \"asdfghjkl\") == \"ewhjklnop\")\nassert(encrypt(s:\
    \ \"gf\") == \"kj\")\nassert(encrypt(s: \"et\") == \"ix\")\nassert(encrypt(s:\
    \ \"faewfawefaewg\") == \"jeiajeaijeiak\")\nassert(encrypt(s: \"hellomyfriend\"\
    ) == \"lippsqcjvmirh\")\nassert(encrypt(s: \"dxzdlmnilfuhmilufhlihufnmlimnufhlimnufhfucufh\"\
    ) == \"hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl\")\nassert(encrypt(s: \"\
    a\") == \"e\")"
  status: SyntaxError
  stderr: "/tmp/tmpa7aj2gtq.swift:19:73: error: cannot find 'alphabet' in scope\n\
    \        let index = newAlphabet.index(newAlphabet.startIndex, offsetBy: alphabet.index(of:\
    \ i)! + 2)\n                                                                 \
    \       ^~~~~~~~\n"
  stdout: ''
  timestamp: 1660028311
- exit_code: 1
  program: "\n/// Create a function encrypt that takes a string as an argument and\n\
    /// returns a string encrypted with the alphabet being rotated. \n/// The alphabet\
    \ should be rotated in a manner such that the letters \n/// shift down by two\
    \ multiplied to two places.\n/// For example:\n/// >>> encrypt(s: \"hi\")\n///\
    \ \"lm\"\n/// >>> encrypt(s: \"asdfghjkl\")\n/// \"ewhjklnop\"\n/// >>> encrypt(s:\
    \ \"gf\")\n/// \"kj\"\n/// >>> encrypt(s: \"et\")\n/// \"ix\"\nfunc encrypt(s:\
    \ String) -> String {\n    var newString = String()\n    for i in s {\n      \
    \  newString.append(i.shiftDown(by: 2 * 2))\n    }\n    return newString\n}\n\n\
    \nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(encrypt(s: \"hi\") == \"lm\")\nassert(encrypt(s:\
    \ \"asdfghjkl\") == \"ewhjklnop\")\nassert(encrypt(s: \"gf\") == \"kj\")\nassert(encrypt(s:\
    \ \"et\") == \"ix\")\nassert(encrypt(s: \"faewfawefaewg\") == \"jeiajeaijeiak\"\
    )\nassert(encrypt(s: \"hellomyfriend\") == \"lippsqcjvmirh\")\nassert(encrypt(s:\
    \ \"dxzdlmnilfuhmilufhlihufnmlimnufhlimnufhfucufh\") == \"hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl\"\
    )\nassert(encrypt(s: \"a\") == \"e\")"
  status: SyntaxError
  stderr: "/tmp/tmpcz0zrvlj.swift:18:28: error: value of type 'Character' has no member\
    \ 'shiftDown'\n        newString.append(i.shiftDown(by: 2 * 2))\n            \
    \             ~ ^~~~~~~~~\n"
  stdout: ''
  timestamp: 1660028311
- exit_code: 1
  program: "\n/// Create a function encrypt that takes a string as an argument and\n\
    /// returns a string encrypted with the alphabet being rotated. \n/// The alphabet\
    \ should be rotated in a manner such that the letters \n/// shift down by two\
    \ multiplied to two places.\n/// For example:\n/// >>> encrypt(s: \"hi\")\n///\
    \ \"lm\"\n/// >>> encrypt(s: \"asdfghjkl\")\n/// \"ewhjklnop\"\n/// >>> encrypt(s:\
    \ \"gf\")\n/// \"kj\"\n/// >>> encrypt(s: \"et\")\n/// \"ix\"\nfunc encrypt(s:\
    \ String) -> String {\n    return encrypt(s: s, by: 2)\n}\n\n\nfunc ==(left: [(Int,\
    \ Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n\
    \        return false\n    }\n    for (l, r) in zip(left, right) {\n        if\
    \ l != r {\n            return false\n        }\n    }\n    return true\n}\n \
    \           \nassert(encrypt(s: \"hi\") == \"lm\")\nassert(encrypt(s: \"asdfghjkl\"\
    ) == \"ewhjklnop\")\nassert(encrypt(s: \"gf\") == \"kj\")\nassert(encrypt(s: \"\
    et\") == \"ix\")\nassert(encrypt(s: \"faewfawefaewg\") == \"jeiajeaijeiak\")\n\
    assert(encrypt(s: \"hellomyfriend\") == \"lippsqcjvmirh\")\nassert(encrypt(s:\
    \ \"dxzdlmnilfuhmilufhlihufnmlimnufhlimnufhfucufh\") == \"hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl\"\
    )\nassert(encrypt(s: \"a\") == \"e\")"
  status: SyntaxError
  stderr: "/tmp/tmp9fi_x2z0.swift:16:30: error: extra argument 'by' in call\n    return\
    \ encrypt(s: s, by: 2)\n                  ~~~~~~~~~~~^~\n"
  stdout: ''
  timestamp: 1660028311
- exit_code: -4
  program: "\n/// Create a function encrypt that takes a string as an argument and\n\
    /// returns a string encrypted with the alphabet being rotated. \n/// The alphabet\
    \ should be rotated in a manner such that the letters \n/// shift down by two\
    \ multiplied to two places.\n/// For example:\n/// >>> encrypt(s: \"hi\")\n///\
    \ \"lm\"\n/// >>> encrypt(s: \"asdfghjkl\")\n/// \"ewhjklnop\"\n/// >>> encrypt(s:\
    \ \"gf\")\n/// \"kj\"\n/// >>> encrypt(s: \"et\")\n/// \"ix\"\nfunc encrypt(s:\
    \ String) -> String {\n    let alphabets = Array(\"abcdefghijklmnopqrstuvwxyz\"\
    )\n    var encryptedString = \"\"\n    for char in s {\n        if let index =\
    \ alphabets.firstIndex(of: char) {\n            encryptedString.append(alphabets[(index\
    \ + 2) % 26])\n        }\n    }\n    return encryptedString\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(encrypt(s: \"hi\") == \"lm\")\nassert(encrypt(s: \"asdfghjkl\"\
    ) == \"ewhjklnop\")\nassert(encrypt(s: \"gf\") == \"kj\")\nassert(encrypt(s: \"\
    et\") == \"ix\")\nassert(encrypt(s: \"faewfawefaewg\") == \"jeiajeaijeiak\")\n\
    assert(encrypt(s: \"hellomyfriend\") == \"lippsqcjvmirh\")\nassert(encrypt(s:\
    \ \"dxzdlmnilfuhmilufhlihufnmlimnufhlimnufhfucufh\") == \"hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl\"\
    )\nassert(encrypt(s: \"a\") == \"e\")"
  status: Exception
  stderr: 'tmpcx_qfg6t/tmpcx_qfg6t.swift:39: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b957d785c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b957d47cb6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b957d47c988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b957d47b7b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpcx_qfg6t                        0x00005617df91a707 <unavailable> + 5895

    5    libc.so.6                          0x00002b957d971460 __libc_start_main +
    245

    6    tmpcx_qfg6t                        0x00005617df91a349 <unavailable> + 4937

    '
  stdout: ''
  timestamp: 1660028312
- exit_code: -4
  program: "\n/// Create a function encrypt that takes a string as an argument and\n\
    /// returns a string encrypted with the alphabet being rotated. \n/// The alphabet\
    \ should be rotated in a manner such that the letters \n/// shift down by two\
    \ multiplied to two places.\n/// For example:\n/// >>> encrypt(s: \"hi\")\n///\
    \ \"lm\"\n/// >>> encrypt(s: \"asdfghjkl\")\n/// \"ewhjklnop\"\n/// >>> encrypt(s:\
    \ \"gf\")\n/// \"kj\"\n/// >>> encrypt(s: \"et\")\n/// \"ix\"\nfunc encrypt(s:\
    \ String) -> String {\n    var encryptedWord = \"\"\n    for character in s {\n\
    \        let unicodeScalar = character.unicodeScalars.first!.value\n        let\
    \ numberFromASCIINumber = Int(unicodeScalar)\n        let newUnicodeScalar = numberFromASCIINumber\
    \ + 2 * 2\n        if newUnicodeScalar <= 111 {\n            let scalar = UnicodeScalar(newUnicodeScalar)!\n\
    \            encryptedWord.append(Character(scalar))\n        } else {\n     \
    \       var difference = newUnicodeScalar - 111\n            while difference\
    \ > 26 {\n                difference -= 26\n            }\n            let scalar\
    \ = UnicodeScalar(difference + 96)!\n            encryptedWord.append(Character(scalar))\n\
    \        }\n    }\n    return encryptedWord\n}\n\n\nfunc ==(left: [(Int, Int)],\
    \ right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n       \
    \ return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r\
    \ {\n            return false\n        }\n    }\n    return true\n}\n        \
    \    \nassert(encrypt(s: \"hi\") == \"lm\")\nassert(encrypt(s: \"asdfghjkl\")\
    \ == \"ewhjklnop\")\nassert(encrypt(s: \"gf\") == \"kj\")\nassert(encrypt(s: \"\
    et\") == \"ix\")\nassert(encrypt(s: \"faewfawefaewg\") == \"jeiajeaijeiak\")\n\
    assert(encrypt(s: \"hellomyfriend\") == \"lippsqcjvmirh\")\nassert(encrypt(s:\
    \ \"dxzdlmnilfuhmilufhlihufnmlimnufhlimnufhfucufh\") == \"hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl\"\
    )\nassert(encrypt(s: \"a\") == \"e\")"
  status: Exception
  stderr: 'tmp2q53yulw/tmp2q53yulw.swift:50: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b9302acbc80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b93027c2b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b93027c2988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b93027c17b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmp2q53yulw                        0x000056395d5de9a7 <unavailable> + 6567

    5    libc.so.6                          0x00002b9302cb7460 __libc_start_main +
    245

    6    tmp2q53yulw                        0x000056395d5de4f9 <unavailable> + 5369

    '
  stdout: ''
  timestamp: 1660028312
- exit_code: -4
  program: "\n/// Create a function encrypt that takes a string as an argument and\n\
    /// returns a string encrypted with the alphabet being rotated. \n/// The alphabet\
    \ should be rotated in a manner such that the letters \n/// shift down by two\
    \ multiplied to two places.\n/// For example:\n/// >>> encrypt(s: \"hi\")\n///\
    \ \"lm\"\n/// >>> encrypt(s: \"asdfghjkl\")\n/// \"ewhjklnop\"\n/// >>> encrypt(s:\
    \ \"gf\")\n/// \"kj\"\n/// >>> encrypt(s: \"et\")\n/// \"ix\"\nfunc encrypt(s:\
    \ String) -> String {\n    var sArr = Array(s)\n    var encryptedArr = [Character]()\n\
    \    for (index, letter) in sArr.enumerated() {\n        if letter == \"z\" {\n\
    \            encryptedArr.append(\"b\")\n        } else if letter == \"y\" {\n\
    \            encryptedArr.append(\"a\")\n        } else {\n            let shift\
    \ = (index + 1) * 2\n            let charCode = Int(letter.asciiValue!) + shift\n\
    \            let encryptedLetter = Character(UnicodeScalar(charCode)!)\n     \
    \       encryptedArr.append(encryptedLetter)\n        }\n    }\n    return String(encryptedArr)\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(encrypt(s: \"hi\") == \"lm\")\nassert(encrypt(s:\
    \ \"asdfghjkl\") == \"ewhjklnop\")\nassert(encrypt(s: \"gf\") == \"kj\")\nassert(encrypt(s:\
    \ \"et\") == \"ix\")\nassert(encrypt(s: \"faewfawefaewg\") == \"jeiajeaijeiak\"\
    )\nassert(encrypt(s: \"hellomyfriend\") == \"lippsqcjvmirh\")\nassert(encrypt(s:\
    \ \"dxzdlmnilfuhmilufhlihufnmlimnufhlimnufhfucufh\") == \"hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl\"\
    )\nassert(encrypt(s: \"a\") == \"e\")"
  status: Exception
  stderr: 'tmp7d6rfa9g/tmp7d6rfa9g.swift:46: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b09449e0c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b09446d7b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b09446d7988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b09446d67b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmp7d6rfa9g                        0x00005642d3bc7bb7 <unavailable> + 7095

    5    libc.so.6                          0x00002b0944bcc460 __libc_start_main +
    245

    6    tmp7d6rfa9g                        0x00005642d3bc77f9 <unavailable> + 6137

    '
  stdout: ''
  timestamp: 1660028312
- exit_code: 1
  program: "\n/// Create a function encrypt that takes a string as an argument and\n\
    /// returns a string encrypted with the alphabet being rotated. \n/// The alphabet\
    \ should be rotated in a manner such that the letters \n/// shift down by two\
    \ multiplied to two places.\n/// For example:\n/// >>> encrypt(s: \"hi\")\n///\
    \ \"lm\"\n/// >>> encrypt(s: \"asdfghjkl\")\n/// \"ewhjklnop\"\n/// >>> encrypt(s:\
    \ \"gf\")\n/// \"kj\"\n/// >>> encrypt(s: \"et\")\n/// \"ix\"\nfunc encrypt(s:\
    \ String) -> String {\n    var encryptedString = \"\"\n    for letter in s {\n\
    \        encryptedString += String(Character(UnicodeScalar(UInt8(letter.asciiValue!\
    \ + 32))!))\n    }\n    return encryptedString\n}\n\n\nfunc ==(left: [(Int, Int)],\
    \ right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n       \
    \ return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r\
    \ {\n            return false\n        }\n    }\n    return true\n}\n        \
    \    \nassert(encrypt(s: \"hi\") == \"lm\")\nassert(encrypt(s: \"asdfghjkl\")\
    \ == \"ewhjklnop\")\nassert(encrypt(s: \"gf\") == \"kj\")\nassert(encrypt(s: \"\
    et\") == \"ix\")\nassert(encrypt(s: \"faewfawefaewg\") == \"jeiajeaijeiak\")\n\
    assert(encrypt(s: \"hellomyfriend\") == \"lippsqcjvmirh\")\nassert(encrypt(s:\
    \ \"dxzdlmnilfuhmilufhlihufnmlimnufhlimnufhfucufh\") == \"hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl\"\
    )\nassert(encrypt(s: \"a\") == \"e\")"
  status: SyntaxError
  stderr: "/tmp/tmphdk050pc.swift:18:90: error: cannot force unwrap value of non-optional\
    \ type 'UnicodeScalar' (aka 'Unicode.Scalar')\n        encryptedString += String(Character(UnicodeScalar(UInt8(letter.asciiValue!\
    \ + 32))!))\n                                            ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~^\n\
    \                                                                            \
    \             \n"
  stdout: ''
  timestamp: 1660028312
- exit_code: -4
  program: "\n/// Create a function encrypt that takes a string as an argument and\n\
    /// returns a string encrypted with the alphabet being rotated. \n/// The alphabet\
    \ should be rotated in a manner such that the letters \n/// shift down by two\
    \ multiplied to two places.\n/// For example:\n/// >>> encrypt(s: \"hi\")\n///\
    \ \"lm\"\n/// >>> encrypt(s: \"asdfghjkl\")\n/// \"ewhjklnop\"\n/// >>> encrypt(s:\
    \ \"gf\")\n/// \"kj\"\n/// >>> encrypt(s: \"et\")\n/// \"ix\"\nfunc encrypt(s:\
    \ String) -> String {\n    var encryptedString = \"\"\n    for character in s\
    \ {\n        let unicodeScalar = character.unicodeScalars.first!.value\n     \
    \   if unicodeScalar >= 97 && unicodeScalar <= 119 {\n            encryptedString.append(String(UnicodeScalar(unicodeScalar\
    \ + 3)!))\n        } else if unicodeScalar >= 120 && unicodeScalar <= 122 {\n\
    \            encryptedString.append(String(UnicodeScalar(unicodeScalar - 23)!))\n\
    \        } else {\n            encryptedString.append(String(UnicodeScalar(unicodeScalar)!))\n\
    \        }\n    }\n    return encryptedString\n}\n\n\nfunc ==(left: [(Int, Int)],\
    \ right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n       \
    \ return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r\
    \ {\n            return false\n        }\n    }\n    return true\n}\n        \
    \    \nassert(encrypt(s: \"hi\") == \"lm\")\nassert(encrypt(s: \"asdfghjkl\")\
    \ == \"ewhjklnop\")\nassert(encrypt(s: \"gf\") == \"kj\")\nassert(encrypt(s: \"\
    et\") == \"ix\")\nassert(encrypt(s: \"faewfawefaewg\") == \"jeiajeaijeiak\")\n\
    assert(encrypt(s: \"hellomyfriend\") == \"lippsqcjvmirh\")\nassert(encrypt(s:\
    \ \"dxzdlmnilfuhmilufhlihufnmlimnufhlimnufhfucufh\") == \"hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl\"\
    )\nassert(encrypt(s: \"a\") == \"e\")"
  status: Exception
  stderr: 'tmpvnveujnq/tmpvnveujnq.swift:43: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002ad8bf6bac80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002ad8bf3b1b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002ad8bf3b1988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002ad8bf3b07b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpvnveujnq                        0x0000563e7a727737 <unavailable> + 5943

    5    libc.so.6                          0x00002ad8bf8a6460 __libc_start_main +
    245

    6    tmpvnveujnq                        0x0000563e7a727379 <unavailable> + 4985

    '
  stdout: ''
  timestamp: 1660028312
- exit_code: 1
  program: "\n/// Create a function encrypt that takes a string as an argument and\n\
    /// returns a string encrypted with the alphabet being rotated. \n/// The alphabet\
    \ should be rotated in a manner such that the letters \n/// shift down by two\
    \ multiplied to two places.\n/// For example:\n/// >>> encrypt(s: \"hi\")\n///\
    \ \"lm\"\n/// >>> encrypt(s: \"asdfghjkl\")\n/// \"ewhjklnop\"\n/// >>> encrypt(s:\
    \ \"gf\")\n/// \"kj\"\n/// >>> encrypt(s: \"et\")\n/// \"ix\"\nfunc encrypt(s:\
    \ String) -> String {\n    let rot = \"abcdefghijklmnopqrstuvwxyz\".rotate(shift:\
    \ s.count*2)\n    let a = \"abcdefghijklmnopqrstuvwxyz\"\n    var res = \"\"\n\
    \    for letter in s {\n        let i = a.index(of: letter)!\n        res.append(rot[i])\n\
    \    }\n    return res\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(encrypt(s:\
    \ \"hi\") == \"lm\")\nassert(encrypt(s: \"asdfghjkl\") == \"ewhjklnop\")\nassert(encrypt(s:\
    \ \"gf\") == \"kj\")\nassert(encrypt(s: \"et\") == \"ix\")\nassert(encrypt(s:\
    \ \"faewfawefaewg\") == \"jeiajeaijeiak\")\nassert(encrypt(s: \"hellomyfriend\"\
    ) == \"lippsqcjvmirh\")\nassert(encrypt(s: \"dxzdlmnilfuhmilufhlihufnmlimnufhlimnufhfucufh\"\
    ) == \"hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl\")\nassert(encrypt(s: \"\
    a\") == \"e\")"
  status: SyntaxError
  stderr: "/tmp/tmpjqkgz1i6.swift:16:44: error: value of type 'String' has no member\
    \ 'rotate'\n    let rot = \"abcdefghijklmnopqrstuvwxyz\".rotate(shift: s.count*2)\n\
    \              ~~~~~~~~~~~~~~~~~~~~~~~~~~~~ ^~~~~~\n/tmp/tmpjqkgz1i6.swift:20:19:\
    \ warning: 'index(of:)' is deprecated: renamed to 'firstIndex(of:)'\n        let\
    \ i = a.index(of: letter)!\n                  ^\n/tmp/tmpjqkgz1i6.swift:20:19:\
    \ note: use 'firstIndex(of:)' instead\n        let i = a.index(of: letter)!\n\
    \                  ^~~~~\n                  firstIndex\n"
  stdout: ''
  timestamp: 1660028311
- exit_code: -4
  program: "\n/// Create a function encrypt that takes a string as an argument and\n\
    /// returns a string encrypted with the alphabet being rotated. \n/// The alphabet\
    \ should be rotated in a manner such that the letters \n/// shift down by two\
    \ multiplied to two places.\n/// For example:\n/// >>> encrypt(s: \"hi\")\n///\
    \ \"lm\"\n/// >>> encrypt(s: \"asdfghjkl\")\n/// \"ewhjklnop\"\n/// >>> encrypt(s:\
    \ \"gf\")\n/// \"kj\"\n/// >>> encrypt(s: \"et\")\n/// \"ix\"\nfunc encrypt(s:\
    \ String) -> String {\n    let lowercase = Array(\"abcdefghijklmnopqrstuvwxyz\"\
    )\n    let uppercase = Array(\"ABCDEFGHIJKLMNOPQRSTUVWXYZ\")\n    var encrypted\
    \ = \"\"\n    for c in s {\n        if let lowerIndex = lowercase.firstIndex(of:\
    \ c) {\n            encrypted.append(lowercase[(lowerIndex + 2) % 26])\n     \
    \   } else if let upperIndex = uppercase.firstIndex(of: c) {\n            encrypted.append(uppercase[(upperIndex\
    \ + 2) % 26])\n        } else {\n            encrypted.append(c)\n        }\n\
    \    }\n    return encrypted\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int,\
    \ Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n\
    \    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n          \
    \  return false\n        }\n    }\n    return true\n}\n            \nassert(encrypt(s:\
    \ \"hi\") == \"lm\")\nassert(encrypt(s: \"asdfghjkl\") == \"ewhjklnop\")\nassert(encrypt(s:\
    \ \"gf\") == \"kj\")\nassert(encrypt(s: \"et\") == \"ix\")\nassert(encrypt(s:\
    \ \"faewfawefaewg\") == \"jeiajeaijeiak\")\nassert(encrypt(s: \"hellomyfriend\"\
    ) == \"lippsqcjvmirh\")\nassert(encrypt(s: \"dxzdlmnilfuhmilufhlihufnmlimnufhlimnufhfucufh\"\
    ) == \"hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl\")\nassert(encrypt(s: \"\
    a\") == \"e\")"
  status: Exception
  stderr: 'tmpzwjs1175/tmpzwjs1175.swift:44: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b4a43941c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b4a43638b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b4a43638988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b4a436377b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpzwjs1175                        0x00005618eeb11707 <unavailable> + 5895

    5    libc.so.6                          0x00002b4a43b2d460 __libc_start_main +
    245

    6    tmpzwjs1175                        0x00005618eeb11349 <unavailable> + 4937

    '
  stdout: ''
  timestamp: 1660028312
- exit_code: -4
  program: "\n/// Create a function encrypt that takes a string as an argument and\n\
    /// returns a string encrypted with the alphabet being rotated. \n/// The alphabet\
    \ should be rotated in a manner such that the letters \n/// shift down by two\
    \ multiplied to two places.\n/// For example:\n/// >>> encrypt(s: \"hi\")\n///\
    \ \"lm\"\n/// >>> encrypt(s: \"asdfghjkl\")\n/// \"ewhjklnop\"\n/// >>> encrypt(s:\
    \ \"gf\")\n/// \"kj\"\n/// >>> encrypt(s: \"et\")\n/// \"ix\"\nfunc encrypt(s:\
    \ String) -> String {\n    \n    var encryptedString = \"\"\n    let alphabet\
    \ = Array(\"abcdefghijklmnopqrstuvwxyz\")\n    let newAlphabet = Array(\"cdefghijklmnopqrstuvwxyzab\"\
    )\n    \n    for char in s {\n        let oldIndex = alphabet.index(of: char)\n\
    \        let newChar = newAlphabet[oldIndex!]\n        encryptedString.append(newChar)\n\
    \    }\n    \n    return encryptedString\n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(encrypt(s: \"hi\") == \"lm\")\nassert(encrypt(s: \"asdfghjkl\") == \"ewhjklnop\"\
    )\nassert(encrypt(s: \"gf\") == \"kj\")\nassert(encrypt(s: \"et\") == \"ix\")\n\
    assert(encrypt(s: \"faewfawefaewg\") == \"jeiajeaijeiak\")\nassert(encrypt(s:\
    \ \"hellomyfriend\") == \"lippsqcjvmirh\")\nassert(encrypt(s: \"dxzdlmnilfuhmilufhlihufnmlimnufhlimnufhfucufh\"\
    ) == \"hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl\")\nassert(encrypt(s: \"\
    a\") == \"e\")"
  status: Exception
  stderr: 'tmpng7uc_xa/tmpng7uc_xa.swift:43: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b70114e8c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b70111dfb6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b70111df988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b70111de7b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpng7uc_xa                        0x00005597758036f7 <unavailable> + 5879

    5    libc.so.6                          0x00002b70116d4460 __libc_start_main +
    245

    6    tmpng7uc_xa                        0x0000559775803339 <unavailable> + 4921

    '
  stdout: ''
  timestamp: 1660028312
- exit_code: 0
  program: "\n/// Create a function encrypt that takes a string as an argument and\n\
    /// returns a string encrypted with the alphabet being rotated. \n/// The alphabet\
    \ should be rotated in a manner such that the letters \n/// shift down by two\
    \ multiplied to two places.\n/// For example:\n/// >>> encrypt(s: \"hi\")\n///\
    \ \"lm\"\n/// >>> encrypt(s: \"asdfghjkl\")\n/// \"ewhjklnop\"\n/// >>> encrypt(s:\
    \ \"gf\")\n/// \"kj\"\n/// >>> encrypt(s: \"et\")\n/// \"ix\"\nfunc encrypt(s:\
    \ String) -> String {\n    var alphabet: [Character] = [\"a\", \"b\", \"c\", \"\
    d\", \"e\", \"f\", \"g\", \"h\", \"i\", \"j\", \"k\", \"l\", \"m\", \"n\", \"\
    o\", \"p\", \"q\", \"r\", \"s\", \"t\", \"u\", \"v\", \"w\", \"x\", \"y\", \"\
    z\"]\n    let letters: [Character] = Array(s)\n    var newString: String = \"\"\
    \n    for i in letters {\n        if let index = alphabet.firstIndex(of: i) {\n\
    \            var newIndex = (index + (2 * 2)) % alphabet.count\n            newString.append(alphabet[newIndex])\n\
    \        }\n    }\n    return newString\n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(encrypt(s: \"hi\") == \"lm\")\nassert(encrypt(s: \"asdfghjkl\") == \"ewhjklnop\"\
    )\nassert(encrypt(s: \"gf\") == \"kj\")\nassert(encrypt(s: \"et\") == \"ix\")\n\
    assert(encrypt(s: \"faewfawefaewg\") == \"jeiajeaijeiak\")\nassert(encrypt(s:\
    \ \"hellomyfriend\") == \"lippsqcjvmirh\")\nassert(encrypt(s: \"dxzdlmnilfuhmilufhlihufnmlimnufhlimnufhfucufh\"\
    ) == \"hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl\")\nassert(encrypt(s: \"\
    a\") == \"e\")"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660028312
- exit_code: 1
  program: "\n/// Create a function encrypt that takes a string as an argument and\n\
    /// returns a string encrypted with the alphabet being rotated. \n/// The alphabet\
    \ should be rotated in a manner such that the letters \n/// shift down by two\
    \ multiplied to two places.\n/// For example:\n/// >>> encrypt(s: \"hi\")\n///\
    \ \"lm\"\n/// >>> encrypt(s: \"asdfghjkl\")\n/// \"ewhjklnop\"\n/// >>> encrypt(s:\
    \ \"gf\")\n/// \"kj\"\n/// >>> encrypt(s: \"et\")\n/// \"ix\"\nfunc encrypt(s:\
    \ String) -> String {\n    return String(s.map { Character(UnicodeScalar(UInt8(ascii(char:\
    \ $0)) + 2*2)!) })\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) ->\
    \ Bool {\n    if left.count != right.count {\n        return false\n    }\n  \
    \  for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(encrypt(s: \"hi\"\
    ) == \"lm\")\nassert(encrypt(s: \"asdfghjkl\") == \"ewhjklnop\")\nassert(encrypt(s:\
    \ \"gf\") == \"kj\")\nassert(encrypt(s: \"et\") == \"ix\")\nassert(encrypt(s:\
    \ \"faewfawefaewg\") == \"jeiajeaijeiak\")\nassert(encrypt(s: \"hellomyfriend\"\
    ) == \"lippsqcjvmirh\")\nassert(encrypt(s: \"dxzdlmnilfuhmilufhlihufnmlimnufhlimnufhfucufh\"\
    ) == \"hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl\")\nassert(encrypt(s: \"\
    a\") == \"e\")"
  status: SyntaxError
  stderr: "/tmp/tmpq65p4tad.swift:16:57: error: cannot find 'ascii' in scope\n   \
    \ return String(s.map { Character(UnicodeScalar(UInt8(ascii(char: $0)) + 2*2)!)\
    \ })\n                                                        ^~~~~\n"
  stdout: ''
  timestamp: 1660028312
- exit_code: -4
  program: "\n/// Create a function encrypt that takes a string as an argument and\n\
    /// returns a string encrypted with the alphabet being rotated. \n/// The alphabet\
    \ should be rotated in a manner such that the letters \n/// shift down by two\
    \ multiplied to two places.\n/// For example:\n/// >>> encrypt(s: \"hi\")\n///\
    \ \"lm\"\n/// >>> encrypt(s: \"asdfghjkl\")\n/// \"ewhjklnop\"\n/// >>> encrypt(s:\
    \ \"gf\")\n/// \"kj\"\n/// >>> encrypt(s: \"et\")\n/// \"ix\"\nfunc encrypt(s:\
    \ String) -> String {\n    var result = \"\"\n    for char in s {\n        switch\
    \ char {\n        case \"a\"...\"c\":\n            result.append(\"x\")\n    \
    \    case \"d\"...\"f\":\n            result.append(\"y\")\n        case \"g\"\
    ...\"i\":\n            result.append(\"z\")\n        case \"j\"...\"l\":\n   \
    \         result.append(\"a\")\n        case \"m\"...\"o\":\n            result.append(\"\
    b\")\n        case \"p\"...\"r\":\n            result.append(\"c\")\n        case\
    \ \"s\"...\"u\":\n            result.append(\"d\")\n        case \"v\"...\"x\"\
    :\n            result.append(\"e\")\n        case \"y\"...\"z\":\n           \
    \ result.append(\"f\")\n        default:\n            result.append(char)\n  \
    \      }\n    }\n    return result\n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(encrypt(s: \"hi\") == \"lm\")\nassert(encrypt(s: \"asdfghjkl\") == \"ewhjklnop\"\
    )\nassert(encrypt(s: \"gf\") == \"kj\")\nassert(encrypt(s: \"et\") == \"ix\")\n\
    assert(encrypt(s: \"faewfawefaewg\") == \"jeiajeaijeiak\")\nassert(encrypt(s:\
    \ \"hellomyfriend\") == \"lippsqcjvmirh\")\nassert(encrypt(s: \"dxzdlmnilfuhmilufhlihufnmlimnufhlimnufhfucufh\"\
    ) == \"hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl\")\nassert(encrypt(s: \"\
    a\") == \"e\")"
  status: Exception
  stderr: 'tmpy3024brd/tmpy3024brd.swift:57: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b472ad7ac80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b472aa71b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b472aa71988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b472aa707b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpy3024brd                        0x0000563a5cf2c687 <unavailable> + 5767

    5    libc.so.6                          0x00002b472af66460 __libc_start_main +
    245

    6    tmpy3024brd                        0x0000563a5cf2c2c9 <unavailable> + 4809

    '
  stdout: ''
  timestamp: 1660028312
- exit_code: 1
  program: "\n/// Create a function encrypt that takes a string as an argument and\n\
    /// returns a string encrypted with the alphabet being rotated. \n/// The alphabet\
    \ should be rotated in a manner such that the letters \n/// shift down by two\
    \ multiplied to two places.\n/// For example:\n/// >>> encrypt(s: \"hi\")\n///\
    \ \"lm\"\n/// >>> encrypt(s: \"asdfghjkl\")\n/// \"ewhjklnop\"\n/// >>> encrypt(s:\
    \ \"gf\")\n/// \"kj\"\n/// >>> encrypt(s: \"et\")\n/// \"ix\"\nfunc encrypt(s:\
    \ String) -> String {\n    var result: String = \"\"\n    var index: Int = 0\n\
    \    for character in s {\n        if(index != 2){\n            if let shiftIndex\
    \ = letters.firstIndex(of: character) {\n                result.append(letters[(shiftIndex\
    \ + (index * 2)) % 26])\n            }\n        } else {\n            if let shiftIndex\
    \ = letters.firstIndex(of: character) {\n                result.append(letters[(shiftIndex\
    \ + (1 * 2)) % 26])\n            }\n        }\n        index += 1\n    }\n   \
    \ return result\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool\
    \ {\n    if left.count != right.count {\n        return false\n    }\n    for\
    \ (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(encrypt(s: \"hi\"\
    ) == \"lm\")\nassert(encrypt(s: \"asdfghjkl\") == \"ewhjklnop\")\nassert(encrypt(s:\
    \ \"gf\") == \"kj\")\nassert(encrypt(s: \"et\") == \"ix\")\nassert(encrypt(s:\
    \ \"faewfawefaewg\") == \"jeiajeaijeiak\")\nassert(encrypt(s: \"hellomyfriend\"\
    ) == \"lippsqcjvmirh\")\nassert(encrypt(s: \"dxzdlmnilfuhmilufhlihufnmlimnufhlimnufhfucufh\"\
    ) == \"hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl\")\nassert(encrypt(s: \"\
    a\") == \"e\")"
  status: SyntaxError
  stderr: "/tmp/tmpz8qykwqg.swift:20:33: error: cannot find 'letters' in scope\n \
    \           if let shiftIndex = letters.firstIndex(of: character) {\n        \
    \                        ^~~~~~~\n/tmp/tmpz8qykwqg.swift:21:31: error: cannot\
    \ find 'letters' in scope\n                result.append(letters[(shiftIndex +\
    \ (index * 2)) % 26])\n                              ^~~~~~~\n/tmp/tmpz8qykwqg.swift:24:33:\
    \ error: cannot find 'letters' in scope\n            if let shiftIndex = letters.firstIndex(of:\
    \ character) {\n                                ^~~~~~~\n/tmp/tmpz8qykwqg.swift:25:31:\
    \ error: cannot find 'letters' in scope\n                result.append(letters[(shiftIndex\
    \ + (1 * 2)) % 26])\n                              ^~~~~~~\n"
  stdout: ''
  timestamp: 1660028312
- exit_code: -4
  program: "\n/// Create a function encrypt that takes a string as an argument and\n\
    /// returns a string encrypted with the alphabet being rotated. \n/// The alphabet\
    \ should be rotated in a manner such that the letters \n/// shift down by two\
    \ multiplied to two places.\n/// For example:\n/// >>> encrypt(s: \"hi\")\n///\
    \ \"lm\"\n/// >>> encrypt(s: \"asdfghjkl\")\n/// \"ewhjklnop\"\n/// >>> encrypt(s:\
    \ \"gf\")\n/// \"kj\"\n/// >>> encrypt(s: \"et\")\n/// \"ix\"\nfunc encrypt(s:\
    \ String) -> String {\n    var encodedString = \"\"\n    let lowercaseCharacters\
    \ = Array(\"abcdefghijklmnopqrstuvwxyz\")\n    let uppercaseCharacters = Array(\"\
    ABCDEFGHIJKLMNOPQRSTUVWXYZ\")\n    for letter in s {\n        if let lowercaseIndex\
    \ = lowercaseCharacters.firstIndex(of: letter) {\n            encodedString.append(lowercaseCharacters[(lowercaseIndex\
    \ + 2) % 26])\n        } else if let uppercaseIndex = uppercaseCharacters.firstIndex(of:\
    \ letter) {\n            encodedString.append(uppercaseCharacters[(uppercaseIndex\
    \ + 2) % 26])\n        } else {\n            encodedString.append(letter)\n  \
    \      }\n    }\n    return encodedString\n}\n\n\nfunc ==(left: [(Int, Int)],\
    \ right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n       \
    \ return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r\
    \ {\n            return false\n        }\n    }\n    return true\n}\n        \
    \    \nassert(encrypt(s: \"hi\") == \"lm\")\nassert(encrypt(s: \"asdfghjkl\")\
    \ == \"ewhjklnop\")\nassert(encrypt(s: \"gf\") == \"kj\")\nassert(encrypt(s: \"\
    et\") == \"ix\")\nassert(encrypt(s: \"faewfawefaewg\") == \"jeiajeaijeiak\")\n\
    assert(encrypt(s: \"hellomyfriend\") == \"lippsqcjvmirh\")\nassert(encrypt(s:\
    \ \"dxzdlmnilfuhmilufhlihufnmlimnufhlimnufhfucufh\") == \"hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl\"\
    )\nassert(encrypt(s: \"a\") == \"e\")"
  status: Exception
  stderr: 'tmpyo7nighd/tmpyo7nighd.swift:44: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002ba3e47e1c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002ba3e44d8b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002ba3e44d8988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002ba3e44d77b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpyo7nighd                        0x0000558f1b995707 <unavailable> + 5895

    5    libc.so.6                          0x00002ba3e49cd460 __libc_start_main +
    245

    6    tmpyo7nighd                        0x0000558f1b995349 <unavailable> + 4937

    '
  stdout: ''
  timestamp: 1660028312
- exit_code: 1
  program: "\n/// Create a function encrypt that takes a string as an argument and\n\
    /// returns a string encrypted with the alphabet being rotated. \n/// The alphabet\
    \ should be rotated in a manner such that the letters \n/// shift down by two\
    \ multiplied to two places.\n/// For example:\n/// >>> encrypt(s: \"hi\")\n///\
    \ \"lm\"\n/// >>> encrypt(s: \"asdfghjkl\")\n/// \"ewhjklnop\"\n/// >>> encrypt(s:\
    \ \"gf\")\n/// \"kj\"\n/// >>> encrypt(s: \"et\")\n/// \"ix\"\nfunc encrypt(s:\
    \ String) -> String {\n    // This function takes in a string and returns a string\n\
    \    // It returns a string because the string is encrypted with the alphabet\
    \ and then converted back to a string\n    // The alphabet is rotated in a manner\
    \ that each letter shifts down by two multiplied to two places\n    // For example:\n\
    \    //      >>> encrypt(s: \"hi\")\n    //      \"lm\"\n    //      >>> encrypt(s:\
    \ \"asdfghjkl\")\n    //      \"ewhjklnop\"\n    //      >>> encrypt(s: \"gf\"\
    )\n    //      \"kj\"\n    //      >>> encrypt(s: \"et\")\n    //      \"ix\"\n\
    \    // This function returns a string, not a character\n    var string = \"\"\
    \n    for ch in s {\n        // This for loop takes in a character from the string\
    \ and checks it\n        // If the letter is a uppercase letter, it is converted\
    \ to lowercase so it is the same character\n        // This if statement checks\
    \ if it is a letter\n        if ch.isLetter {\n            // This if statement\
    \ checks if the letter is upper case\n            if ch.isUppercase {\n      \
    \          // This function converts the uppercase letter to a lowercase letter\n\
    \                string.append(Character(String(ch).lowercased()))\n         \
    \   } else {\n                // This code just appends the lowercase letter to\
    \ the string\n                string.append(ch)\n            }\n        }\n  \
    \  }\n    var converted = \"\"\n    for letter in string {\n        // This for\
    \ loop iterates through each character of the string\n        // This if statement\
    \ checks if the character is a letter\n        if letter.isLetter {\n        \
    \    // This if statement checks if the letter is the letter z\n            if\
    \ letter == \"z\" {\n                // This if statement checks if the letter\
    \ is the letter a\n                if converted.last == \"a\" {\n            \
    \        // This if statement checks if the last letter of the converted string\
    \ is the letter b\n                    if converted.last == \"b\" {\n        \
    \                // If all three if statements are true, then this code runs\n\
    \                        // This code just appends the letter c to the string\
    \ converted\n                        converted.append(\"c\")\n               \
    \     } else {\n                        // If this else statement runs, then this\
    \ if statement runs\n\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(encrypt(s:\
    \ \"hi\") == \"lm\")\nassert(encrypt(s: \"asdfghjkl\") == \"ewhjklnop\")\nassert(encrypt(s:\
    \ \"gf\") == \"kj\")\nassert(encrypt(s: \"et\") == \"ix\")\nassert(encrypt(s:\
    \ \"faewfawefaewg\") == \"jeiajeaijeiak\")\nassert(encrypt(s: \"hellomyfriend\"\
    ) == \"lippsqcjvmirh\")\nassert(encrypt(s: \"dxzdlmnilfuhmilufhlihufnmlimnufhlimnufhfucufh\"\
    ) == \"hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl\")\nassert(encrypt(s: \"\
    a\") == \"e\")"
  status: SyntaxError
  stderr: "/tmp/tmpvz3tq43m.swift:84:31: error: expected '}' at end of brace statement\n\
    assert(encrypt(s: \"a\") == \"e\")\n                              ^\n/tmp/tmpvz3tq43m.swift:53:42:\
    \ note: to match this opening '{'\n                if converted.last == \"a\"\
    \ {\n                                         ^\n/tmp/tmpvz3tq43m.swift:84:31:\
    \ error: expected '}' at end of brace statement\nassert(encrypt(s: \"a\") == \"\
    e\")\n                              ^\n/tmp/tmpvz3tq43m.swift:51:30: note: to\
    \ match this opening '{'\n            if letter == \"z\" {\n                 \
    \            ^\n/tmp/tmpvz3tq43m.swift:84:31: error: expected '}' at end of brace\
    \ statement\nassert(encrypt(s: \"a\") == \"e\")\n                            \
    \  ^\n/tmp/tmpvz3tq43m.swift:49:28: note: to match this opening '{'\n        if\
    \ letter.isLetter {\n                           ^\n/tmp/tmpvz3tq43m.swift:84:31:\
    \ error: expected '}' at end of brace statement\nassert(encrypt(s: \"a\") == \"\
    e\")\n                              ^\n/tmp/tmpvz3tq43m.swift:46:26: note: to\
    \ match this opening '{'\n    for letter in string {\n                       \
    \  ^\n/tmp/tmpvz3tq43m.swift:84:31: error: expected '}' at end of brace statement\n\
    assert(encrypt(s: \"a\") == \"e\")\n                              ^\n/tmp/tmpvz3tq43m.swift:15:35:\
    \ note: to match this opening '{'\nfunc encrypt(s: String) -> String {\n     \
    \                             ^\n/tmp/tmpvz3tq43m.swift:65:6: error: operator\
    \ functions can only be declared at global or in type scope\nfunc ==(left: [(Int,\
    \ Int)], right: [(Int, Int)]) -> Bool {\n     ^\n"
  stdout: ''
  timestamp: 1660028312
- exit_code: -4
  program: "\n/// Create a function encrypt that takes a string as an argument and\n\
    /// returns a string encrypted with the alphabet being rotated. \n/// The alphabet\
    \ should be rotated in a manner such that the letters \n/// shift down by two\
    \ multiplied to two places.\n/// For example:\n/// >>> encrypt(s: \"hi\")\n///\
    \ \"lm\"\n/// >>> encrypt(s: \"asdfghjkl\")\n/// \"ewhjklnop\"\n/// >>> encrypt(s:\
    \ \"gf\")\n/// \"kj\"\n/// >>> encrypt(s: \"et\")\n/// \"ix\"\nfunc encrypt(s:\
    \ String) -> String {\n    let alphabet = \"abcdefghijklmnopqrstuvwxyz\"\n   \
    \ var encryptedString = \"\"\n    for letter in s {\n        if let index = alphabet.firstIndex(of:\
    \ letter) {\n            var newIndex = alphabet.index(index, offsetBy: 2)\n \
    \           if alphabet.distance(from: alphabet.startIndex, to: newIndex) >= alphabet.count\
    \ {\n                newIndex = alphabet.index(alphabet.startIndex, offsetBy:\
    \ (alphabet.distance(from: alphabet.startIndex, to: newIndex) % alphabet.count))\n\
    \            }\n            encryptedString.append(alphabet[newIndex])\n     \
    \   }\n    }\n    return encryptedString\n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(encrypt(s: \"hi\") == \"lm\")\nassert(encrypt(s: \"asdfghjkl\") == \"ewhjklnop\"\
    )\nassert(encrypt(s: \"gf\") == \"kj\")\nassert(encrypt(s: \"et\") == \"ix\")\n\
    assert(encrypt(s: \"faewfawefaewg\") == \"jeiajeaijeiak\")\nassert(encrypt(s:\
    \ \"hellomyfriend\") == \"lippsqcjvmirh\")\nassert(encrypt(s: \"dxzdlmnilfuhmilufhlihufnmlimnufhlimnufhfucufh\"\
    ) == \"hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl\")\nassert(encrypt(s: \"\
    a\") == \"e\")"
  status: Exception
  stderr: 'tmpkhfq2vyy/tmpkhfq2vyy.swift:43: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b6a81403c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b6a810fab6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b6a810fa988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b6a810f97b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpkhfq2vyy                        0x000055c6bb33f797 <unavailable> + 6039

    5    libc.so.6                          0x00002b6a815ef460 __libc_start_main +
    245

    6    tmpkhfq2vyy                        0x000055c6bb33f3d9 <unavailable> + 5081

    '
  stdout: ''
  timestamp: 1660028312
- exit_code: 1
  program: "\n/// Create a function encrypt that takes a string as an argument and\n\
    /// returns a string encrypted with the alphabet being rotated. \n/// The alphabet\
    \ should be rotated in a manner such that the letters \n/// shift down by two\
    \ multiplied to two places.\n/// For example:\n/// >>> encrypt(s: \"hi\")\n///\
    \ \"lm\"\n/// >>> encrypt(s: \"asdfghjkl\")\n/// \"ewhjklnop\"\n/// >>> encrypt(s:\
    \ \"gf\")\n/// \"kj\"\n/// >>> encrypt(s: \"et\")\n/// \"ix\"\nfunc encrypt(s:\
    \ String) -> String {\n    var result = \"\"\n    for char in s {\n        result\
    \ += String(char.next())\n    }\n    return result\n}\n\n\nfunc ==(left: [(Int,\
    \ Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n\
    \        return false\n    }\n    for (l, r) in zip(left, right) {\n        if\
    \ l != r {\n            return false\n        }\n    }\n    return true\n}\n \
    \           \nassert(encrypt(s: \"hi\") == \"lm\")\nassert(encrypt(s: \"asdfghjkl\"\
    ) == \"ewhjklnop\")\nassert(encrypt(s: \"gf\") == \"kj\")\nassert(encrypt(s: \"\
    et\") == \"ix\")\nassert(encrypt(s: \"faewfawefaewg\") == \"jeiajeaijeiak\")\n\
    assert(encrypt(s: \"hellomyfriend\") == \"lippsqcjvmirh\")\nassert(encrypt(s:\
    \ \"dxzdlmnilfuhmilufhlihufnmlimnufhlimnufhfucufh\") == \"hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl\"\
    )\nassert(encrypt(s: \"a\") == \"e\")"
  status: SyntaxError
  stderr: "/tmp/tmp33slmi5x.swift:18:31: error: value of type 'Character' has no member\
    \ 'next'\n        result += String(char.next())\n                         ~~~~\
    \ ^~~~\n"
  stdout: ''
  timestamp: 1660028312
- exit_code: 1
  program: "\n/// Create a function encrypt that takes a string as an argument and\n\
    /// returns a string encrypted with the alphabet being rotated. \n/// The alphabet\
    \ should be rotated in a manner such that the letters \n/// shift down by two\
    \ multiplied to two places.\n/// For example:\n/// >>> encrypt(s: \"hi\")\n///\
    \ \"lm\"\n/// >>> encrypt(s: \"asdfghjkl\")\n/// \"ewhjklnop\"\n/// >>> encrypt(s:\
    \ \"gf\")\n/// \"kj\"\n/// >>> encrypt(s: \"et\")\n/// \"ix\"\nfunc encrypt(s:\
    \ String) -> String {\n    var encrypted = \"\"\n    for char in s {\n       \
    \ if char == \"z\" {\n            encrypted.append(\"b\")\n        } else if char\
    \ == \"y\" {\n            encrypted.append(\"a\")\n        } else {\n        \
    \    encrypted.append(Character(UnicodeScalar(UInt8(char.asciiValue! + 2))!))\n\
    \        }\n    }\n    return encrypted\n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(encrypt(s: \"hi\") == \"lm\")\nassert(encrypt(s: \"asdfghjkl\") == \"ewhjklnop\"\
    )\nassert(encrypt(s: \"gf\") == \"kj\")\nassert(encrypt(s: \"et\") == \"ix\")\n\
    assert(encrypt(s: \"faewfawefaewg\") == \"jeiajeaijeiak\")\nassert(encrypt(s:\
    \ \"hellomyfriend\") == \"lippsqcjvmirh\")\nassert(encrypt(s: \"dxzdlmnilfuhmilufhlihufnmlimnufhlimnufhfucufh\"\
    ) == \"hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl\")\nassert(encrypt(s: \"\
    a\") == \"e\")"
  status: SyntaxError
  stderr: "/tmp/tmpw8olcal1.swift:23:82: error: cannot force unwrap value of non-optional\
    \ type 'UnicodeScalar' (aka 'Unicode.Scalar')\n            encrypted.append(Character(UnicodeScalar(UInt8(char.asciiValue!\
    \ + 2))!))\n                                       ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~^\n\
    \                                                                            \
    \     \n"
  stdout: ''
  timestamp: 1660028312
- exit_code: -4
  program: "\n/// Create a function encrypt that takes a string as an argument and\n\
    /// returns a string encrypted with the alphabet being rotated. \n/// The alphabet\
    \ should be rotated in a manner such that the letters \n/// shift down by two\
    \ multiplied to two places.\n/// For example:\n/// >>> encrypt(s: \"hi\")\n///\
    \ \"lm\"\n/// >>> encrypt(s: \"asdfghjkl\")\n/// \"ewhjklnop\"\n/// >>> encrypt(s:\
    \ \"gf\")\n/// \"kj\"\n/// >>> encrypt(s: \"et\")\n/// \"ix\"\nfunc encrypt(s:\
    \ String) -> String {\n    \n    var result: String = \"\"\n    let letters: [Character]\
    \ = Array(s)\n    \n    for letter in letters {\n        let ascii: Int = Int(letter.asciiValue!)\n\
    \        let asciiNew: Int = (ascii + 2) % 26\n        let letterNew: Character\
    \ = Character(UnicodeScalar(asciiNew + Int((\"a\" as UnicodeScalar).value))!)\n\
    \        result.append(letterNew)\n    }\n    \n    return result\n}\n\n\nfunc\
    \ ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count !=\
    \ right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(encrypt(s: \"hi\") == \"lm\")\nassert(encrypt(s:\
    \ \"asdfghjkl\") == \"ewhjklnop\")\nassert(encrypt(s: \"gf\") == \"kj\")\nassert(encrypt(s:\
    \ \"et\") == \"ix\")\nassert(encrypt(s: \"faewfawefaewg\") == \"jeiajeaijeiak\"\
    )\nassert(encrypt(s: \"hellomyfriend\") == \"lippsqcjvmirh\")\nassert(encrypt(s:\
    \ \"dxzdlmnilfuhmilufhlihufnmlimnufhlimnufhfucufh\") == \"hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl\"\
    )\nassert(encrypt(s: \"a\") == \"e\")"
  status: Exception
  stderr: 'tmp4te0g9r4/tmp4te0g9r4.swift:43: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b82adbd4c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b82ad8cbb6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b82ad8cb988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b82ad8ca7b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmp4te0g9r4                        0x000055ad97c99a47 <unavailable> + 6727

    5    libc.so.6                          0x00002b82addc0460 __libc_start_main +
    245

    6    tmp4te0g9r4                        0x000055ad97c99689 <unavailable> + 5769

    '
  stdout: ''
  timestamp: 1660028312
- exit_code: 1
  program: "\n/// Create a function encrypt that takes a string as an argument and\n\
    /// returns a string encrypted with the alphabet being rotated. \n/// The alphabet\
    \ should be rotated in a manner such that the letters \n/// shift down by two\
    \ multiplied to two places.\n/// For example:\n/// >>> encrypt(s: \"hi\")\n///\
    \ \"lm\"\n/// >>> encrypt(s: \"asdfghjkl\")\n/// \"ewhjklnop\"\n/// >>> encrypt(s:\
    \ \"gf\")\n/// \"kj\"\n/// >>> encrypt(s: \"et\")\n/// \"ix\"\nfunc encrypt(s:\
    \ String) -> String {\n    // your code here\n}\n\n\nfunc ==(left: [(Int, Int)],\
    \ right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n       \
    \ return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r\
    \ {\n            return false\n        }\n    }\n    return true\n}\n        \
    \    \nassert(encrypt(s: \"hi\") == \"lm\")\nassert(encrypt(s: \"asdfghjkl\")\
    \ == \"ewhjklnop\")\nassert(encrypt(s: \"gf\") == \"kj\")\nassert(encrypt(s: \"\
    et\") == \"ix\")\nassert(encrypt(s: \"faewfawefaewg\") == \"jeiajeaijeiak\")\n\
    assert(encrypt(s: \"hellomyfriend\") == \"lippsqcjvmirh\")\nassert(encrypt(s:\
    \ \"dxzdlmnilfuhmilufhlihufnmlimnufhlimnufhfucufh\") == \"hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl\"\
    )\nassert(encrypt(s: \"a\") == \"e\")"
  status: SyntaxError
  stderr: '/tmp/tmpldo9rmlw.swift:17:1: error: missing return in global function expected
    to return ''String''

    }

    ^

    '
  stdout: ''
  timestamp: 1660028312
- exit_code: -4
  program: "\n/// Create a function encrypt that takes a string as an argument and\n\
    /// returns a string encrypted with the alphabet being rotated. \n/// The alphabet\
    \ should be rotated in a manner such that the letters \n/// shift down by two\
    \ multiplied to two places.\n/// For example:\n/// >>> encrypt(s: \"hi\")\n///\
    \ \"lm\"\n/// >>> encrypt(s: \"asdfghjkl\")\n/// \"ewhjklnop\"\n/// >>> encrypt(s:\
    \ \"gf\")\n/// \"kj\"\n/// >>> encrypt(s: \"et\")\n/// \"ix\"\nfunc encrypt(s:\
    \ String) -> String {\n    var encryptedString = \"\"\n    for char in s {\n \
    \       let charInt = Int(char.asciiValue!)\n        let newCharInt = charInt\
    \ + 2 * 2\n        encryptedString.append(Character(UnicodeScalar(newCharInt)!))\n\
    \    }\n    return encryptedString\n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(encrypt(s: \"hi\") == \"lm\")\nassert(encrypt(s: \"asdfghjkl\") == \"ewhjklnop\"\
    )\nassert(encrypt(s: \"gf\") == \"kj\")\nassert(encrypt(s: \"et\") == \"ix\")\n\
    assert(encrypt(s: \"faewfawefaewg\") == \"jeiajeaijeiak\")\nassert(encrypt(s:\
    \ \"hellomyfriend\") == \"lippsqcjvmirh\")\nassert(encrypt(s: \"dxzdlmnilfuhmilufhlihufnmlimnufhlimnufhfucufh\"\
    ) == \"hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl\")\nassert(encrypt(s: \"\
    a\") == \"e\")"
  status: Exception
  stderr: 'tmp8v3iofte/tmp8v3iofte.swift:42: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b886f053c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b886ed4ab6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b886ed4a988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b886ed497b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmp8v3iofte                        0x000055be25715b8e <unavailable> + 7054

    5    libc.so.6                          0x00002b886f23f460 __libc_start_main +
    245

    6    tmp8v3iofte                        0x000055be25715389 <unavailable> + 5001

    '
  stdout: ''
  timestamp: 1660028312
- exit_code: 1
  program: "\n/// Create a function encrypt that takes a string as an argument and\n\
    /// returns a string encrypted with the alphabet being rotated. \n/// The alphabet\
    \ should be rotated in a manner such that the letters \n/// shift down by two\
    \ multiplied to two places.\n/// For example:\n/// >>> encrypt(s: \"hi\")\n///\
    \ \"lm\"\n/// >>> encrypt(s: \"asdfghjkl\")\n/// \"ewhjklnop\"\n/// >>> encrypt(s:\
    \ \"gf\")\n/// \"kj\"\n/// >>> encrypt(s: \"et\")\n/// \"ix\"\nfunc encrypt(s:\
    \ String) -> String {\n    let currentAlpha = \"abcdefghijklmnopqrstuvwxyz\"\n\
    \    let newAlpha = \"cdefghijklmnopqrstuvwxyzab\"\n    var encryptedString =\
    \ \"\"\n    for char in s {\n        if let range = currentAlpha.range(of: char)\
    \ {\n            let index = range.lowerBound\n            let newChar = newAlpha[index]\n\
    \            encryptedString.append(newChar)\n        }\n    }\n    return encryptedString\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(encrypt(s: \"hi\") == \"lm\")\nassert(encrypt(s:\
    \ \"asdfghjkl\") == \"ewhjklnop\")\nassert(encrypt(s: \"gf\") == \"kj\")\nassert(encrypt(s:\
    \ \"et\") == \"ix\")\nassert(encrypt(s: \"faewfawefaewg\") == \"jeiajeaijeiak\"\
    )\nassert(encrypt(s: \"hellomyfriend\") == \"lippsqcjvmirh\")\nassert(encrypt(s:\
    \ \"dxzdlmnilfuhmilufhlihufnmlimnufhlimnufhfucufh\") == \"hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl\"\
    )\nassert(encrypt(s: \"a\") == \"e\")"
  status: SyntaxError
  stderr: "/tmp/tmpfj4_cua_.swift:20:37: error: value of type 'String' has no member\
    \ 'range'\n        if let range = currentAlpha.range(of: char) {\n           \
    \            ~~~~~~~~~~~~ ^~~~~\n"
  stdout: ''
  timestamp: 1660028312
- exit_code: 1
  program: "\n/// Create a function encrypt that takes a string as an argument and\n\
    /// returns a string encrypted with the alphabet being rotated. \n/// The alphabet\
    \ should be rotated in a manner such that the letters \n/// shift down by two\
    \ multiplied to two places.\n/// For example:\n/// >>> encrypt(s: \"hi\")\n///\
    \ \"lm\"\n/// >>> encrypt(s: \"asdfghjkl\")\n/// \"ewhjklnop\"\n/// >>> encrypt(s:\
    \ \"gf\")\n/// \"kj\"\n/// >>> encrypt(s: \"et\")\n/// \"ix\"\nfunc encrypt(s:\
    \ String) -> String {\n    // PUT YOUR CODE HERE\n    var result = \"\"\n    for\
    \ letter in s {\n        result += encryptLetter(letter: letter)\n    }\n    return\
    \ result\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n\
    \    if left.count != right.count {\n        return false\n    }\n    for (l,\
    \ r) in zip(left, right) {\n        if l != r {\n            return false\n  \
    \      }\n    }\n    return true\n}\n            \nassert(encrypt(s: \"hi\") ==\
    \ \"lm\")\nassert(encrypt(s: \"asdfghjkl\") == \"ewhjklnop\")\nassert(encrypt(s:\
    \ \"gf\") == \"kj\")\nassert(encrypt(s: \"et\") == \"ix\")\nassert(encrypt(s:\
    \ \"faewfawefaewg\") == \"jeiajeaijeiak\")\nassert(encrypt(s: \"hellomyfriend\"\
    ) == \"lippsqcjvmirh\")\nassert(encrypt(s: \"dxzdlmnilfuhmilufhlihufnmlimnufhlimnufhfucufh\"\
    ) == \"hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl\")\nassert(encrypt(s: \"\
    a\") == \"e\")"
  status: SyntaxError
  stderr: "/tmp/tmp3fo8j2oo.swift:19:19: error: cannot find 'encryptLetter' in scope\n\
    \        result += encryptLetter(letter: letter)\n                  ^~~~~~~~~~~~~\n"
  stdout: ''
  timestamp: 1660028312
- exit_code: -4
  program: "\n/// Create a function encrypt that takes a string as an argument and\n\
    /// returns a string encrypted with the alphabet being rotated. \n/// The alphabet\
    \ should be rotated in a manner such that the letters \n/// shift down by two\
    \ multiplied to two places.\n/// For example:\n/// >>> encrypt(s: \"hi\")\n///\
    \ \"lm\"\n/// >>> encrypt(s: \"asdfghjkl\")\n/// \"ewhjklnop\"\n/// >>> encrypt(s:\
    \ \"gf\")\n/// \"kj\"\n/// >>> encrypt(s: \"et\")\n/// \"ix\"\nfunc encrypt(s:\
    \ String) -> String {\n    var array = Array(s)\n    var encryptedArray = [Character]()\n\
    \    for i in 0...array.count - 1 {\n        switch array[i] {\n        case \"\
    a\":\n            encryptedArray.append(\"c\")\n        case \"b\":\n        \
    \    encryptedArray.append(\"d\")\n        case \"c\":\n            encryptedArray.append(\"\
    e\")\n        case \"d\":\n            encryptedArray.append(\"f\")\n        case\
    \ \"e\":\n            encryptedArray.append(\"g\")\n        case \"f\":\n    \
    \        encryptedArray.append(\"h\")\n        case \"g\":\n            encryptedArray.append(\"\
    i\")\n        case \"h\":\n            encryptedArray.append(\"j\")\n        case\
    \ \"i\":\n            encryptedArray.append(\"k\")\n        case \"j\":\n    \
    \        encryptedArray.append(\"l\")\n        case \"k\":\n            encryptedArray.append(\"\
    m\")\n        case \"l\":\n            encryptedArray.append(\"n\")\n        case\
    \ \"m\":\n            encryptedArray.append(\"o\")\n        case \"n\":\n    \
    \        encryptedArray.append(\"p\")\n        case \"o\":\n            encryptedArray.append(\"\
    q\")\n        case \"p\":\n            encryptedArray.append(\"r\")\n        case\
    \ \"q\":\n            encryptedArray.append(\"s\")\n        case \"r\":\n    \
    \        encryptedArray.append(\"t\")\n        case \"s\":\n            encryptedArray.append(\"\
    u\")\n        case \"t\":\n            encryptedArray.append(\"v\")\n        case\
    \ \"u\":\n            encryptedArray.append(\"w\")\n        case \"v\":\n    \
    \        encryptedArray.append(\"x\")\n        case \"w\":\n            encryptedArray.append(\"\
    y\")\n        case \"x\":\n            encryptedArray.append(\"z\")\n        case\
    \ \"y\":\n            encryptedArray.append(\"a\")\n        case \"z\":\n    \
    \        encryptedArray.append(\"b\")\n        default:\n            break\n \
    \       }\n    }\n    return String(encryptedArray)\n}\n\n\nfunc ==(left: [(Int,\
    \ Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n\
    \        return false\n    }\n    for (l, r) in zip(left, right) {\n        if\
    \ l != r {\n            return false\n        }\n    }\n    return true\n}\n \
    \           \nassert(encrypt(s: \"hi\") == \"lm\")\nassert(encrypt(s: \"asdfghjkl\"\
    ) == \"ewhjklnop\")\nassert(encrypt(s: \"gf\") == \"kj\")\nassert(encrypt(s: \"\
    et\") == \"ix\")\nassert(encrypt(s: \"faewfawefaewg\") == \"jeiajeaijeiak\")\n\
    assert(encrypt(s: \"hellomyfriend\") == \"lippsqcjvmirh\")\nassert(encrypt(s:\
    \ \"dxzdlmnilfuhmilufhlihufnmlimnufhlimnufhfucufh\") == \"hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl\"\
    )\nassert(encrypt(s: \"a\") == \"e\")"
  status: Exception
  stderr: 'tmpvwgztnph/tmpvwgztnph.swift:92: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002ba5e02a8c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002ba5dff9fb6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002ba5dff9f988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002ba5dff9e7b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpvwgztnph                        0x0000558448fbb897 <unavailable> + 6295

    5    libc.so.6                          0x00002ba5e0494460 __libc_start_main +
    245

    6    tmpvwgztnph                        0x0000558448fbb4d9 <unavailable> + 5337

    '
  stdout: ''
  timestamp: 1660028312
- exit_code: 0
  program: "\n/// Create a function encrypt that takes a string as an argument and\n\
    /// returns a string encrypted with the alphabet being rotated. \n/// The alphabet\
    \ should be rotated in a manner such that the letters \n/// shift down by two\
    \ multiplied to two places.\n/// For example:\n/// >>> encrypt(s: \"hi\")\n///\
    \ \"lm\"\n/// >>> encrypt(s: \"asdfghjkl\")\n/// \"ewhjklnop\"\n/// >>> encrypt(s:\
    \ \"gf\")\n/// \"kj\"\n/// >>> encrypt(s: \"et\")\n/// \"ix\"\nfunc encrypt(s:\
    \ String) -> String {\n    let alphabet = \"abcdefghijklmnopqrstuvwxyz\"\n   \
    \ var indexMap = [Character: Int]()\n    var encryptedString = \"\"\n    for i\
    \ in 0..<alphabet.count {\n        indexMap[alphabet[alphabet.index(alphabet.startIndex,\
    \ offsetBy: i)]] = i\n    }\n    for char in s {\n        let index = indexMap[char]\n\
    \        let newIndex = index! + 2 * 2\n        let newIndexMod = newIndex % alphabet.count\n\
    \        encryptedString.append(alphabet[alphabet.index(alphabet.startIndex, offsetBy:\
    \ newIndexMod)])\n    }\n    return encryptedString\n}\n\n\nfunc ==(left: [(Int,\
    \ Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n\
    \        return false\n    }\n    for (l, r) in zip(left, right) {\n        if\
    \ l != r {\n            return false\n        }\n    }\n    return true\n}\n \
    \           \nassert(encrypt(s: \"hi\") == \"lm\")\nassert(encrypt(s: \"asdfghjkl\"\
    ) == \"ewhjklnop\")\nassert(encrypt(s: \"gf\") == \"kj\")\nassert(encrypt(s: \"\
    et\") == \"ix\")\nassert(encrypt(s: \"faewfawefaewg\") == \"jeiajeaijeiak\")\n\
    assert(encrypt(s: \"hellomyfriend\") == \"lippsqcjvmirh\")\nassert(encrypt(s:\
    \ \"dxzdlmnilfuhmilufhlihufnmlimnufhlimnufhfucufh\") == \"hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl\"\
    )\nassert(encrypt(s: \"a\") == \"e\")"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660028312
- exit_code: 1
  program: "\n/// Create a function encrypt that takes a string as an argument and\n\
    /// returns a string encrypted with the alphabet being rotated. \n/// The alphabet\
    \ should be rotated in a manner such that the letters \n/// shift down by two\
    \ multiplied to two places.\n/// For example:\n/// >>> encrypt(s: \"hi\")\n///\
    \ \"lm\"\n/// >>> encrypt(s: \"asdfghjkl\")\n/// \"ewhjklnop\"\n/// >>> encrypt(s:\
    \ \"gf\")\n/// \"kj\"\n/// >>> encrypt(s: \"et\")\n/// \"ix\"\nfunc encrypt(s:\
    \ String) -> String {\n    var temp = \"\"\n    for i in s {\n        temp.append(encryption(m:\
    \ i))\n    }\n    return temp\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int,\
    \ Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n\
    \    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n          \
    \  return false\n        }\n    }\n    return true\n}\n            \nassert(encrypt(s:\
    \ \"hi\") == \"lm\")\nassert(encrypt(s: \"asdfghjkl\") == \"ewhjklnop\")\nassert(encrypt(s:\
    \ \"gf\") == \"kj\")\nassert(encrypt(s: \"et\") == \"ix\")\nassert(encrypt(s:\
    \ \"faewfawefaewg\") == \"jeiajeaijeiak\")\nassert(encrypt(s: \"hellomyfriend\"\
    ) == \"lippsqcjvmirh\")\nassert(encrypt(s: \"dxzdlmnilfuhmilufhlihufnmlimnufhlimnufhfucufh\"\
    ) == \"hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl\")\nassert(encrypt(s: \"\
    a\") == \"e\")"
  status: SyntaxError
  stderr: "/tmp/tmpq6lp2c7d.swift:18:21: error: cannot find 'encryption' in scope\n\
    \        temp.append(encryption(m: i))\n                    ^~~~~~~~~~\n"
  stdout: ''
  timestamp: 1660028312
- exit_code: -4
  program: "\n/// Create a function encrypt that takes a string as an argument and\n\
    /// returns a string encrypted with the alphabet being rotated. \n/// The alphabet\
    \ should be rotated in a manner such that the letters \n/// shift down by two\
    \ multiplied to two places.\n/// For example:\n/// >>> encrypt(s: \"hi\")\n///\
    \ \"lm\"\n/// >>> encrypt(s: \"asdfghjkl\")\n/// \"ewhjklnop\"\n/// >>> encrypt(s:\
    \ \"gf\")\n/// \"kj\"\n/// >>> encrypt(s: \"et\")\n/// \"ix\"\nfunc encrypt(s:\
    \ String) -> String {\n    \n    return \"\"\n}\n\n\nfunc ==(left: [(Int, Int)],\
    \ right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n       \
    \ return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r\
    \ {\n            return false\n        }\n    }\n    return true\n}\n        \
    \    \nassert(encrypt(s: \"hi\") == \"lm\")\nassert(encrypt(s: \"asdfghjkl\")\
    \ == \"ewhjklnop\")\nassert(encrypt(s: \"gf\") == \"kj\")\nassert(encrypt(s: \"\
    et\") == \"ix\")\nassert(encrypt(s: \"faewfawefaewg\") == \"jeiajeaijeiak\")\n\
    assert(encrypt(s: \"hellomyfriend\") == \"lippsqcjvmirh\")\nassert(encrypt(s:\
    \ \"dxzdlmnilfuhmilufhlihufnmlimnufhlimnufhfucufh\") == \"hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl\"\
    )\nassert(encrypt(s: \"a\") == \"e\")"
  status: Exception
  stderr: 'tmpy_pnjvid/tmpy_pnjvid.swift:33: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b7a35bb2c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b7a358a9b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b7a358a9988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b7a358a87b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpy_pnjvid                        0x000055604da7a307 <unavailable> + 4871

    5    libc.so.6                          0x00002b7a35d9e460 __libc_start_main +
    245

    6    tmpy_pnjvid                        0x000055604da79f49 <unavailable> + 3913

    '
  stdout: ''
  timestamp: 1660028312
- exit_code: -4
  program: "\n/// Create a function encrypt that takes a string as an argument and\n\
    /// returns a string encrypted with the alphabet being rotated. \n/// The alphabet\
    \ should be rotated in a manner such that the letters \n/// shift down by two\
    \ multiplied to two places.\n/// For example:\n/// >>> encrypt(s: \"hi\")\n///\
    \ \"lm\"\n/// >>> encrypt(s: \"asdfghjkl\")\n/// \"ewhjklnop\"\n/// >>> encrypt(s:\
    \ \"gf\")\n/// \"kj\"\n/// >>> encrypt(s: \"et\")\n/// \"ix\"\nfunc encrypt(s:\
    \ String) -> String {\n    var result = \"\"\n    for char in s {\n        result\
    \ += String(UnicodeScalar(UInt8(char.asciiValue! + 2*2)))\n    }\n    return result\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(encrypt(s: \"hi\") == \"lm\")\nassert(encrypt(s:\
    \ \"asdfghjkl\") == \"ewhjklnop\")\nassert(encrypt(s: \"gf\") == \"kj\")\nassert(encrypt(s:\
    \ \"et\") == \"ix\")\nassert(encrypt(s: \"faewfawefaewg\") == \"jeiajeaijeiak\"\
    )\nassert(encrypt(s: \"hellomyfriend\") == \"lippsqcjvmirh\")\nassert(encrypt(s:\
    \ \"dxzdlmnilfuhmilufhlihufnmlimnufhlimnufhfucufh\") == \"hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl\"\
    )\nassert(encrypt(s: \"a\") == \"e\")"
  status: Exception
  stderr: 'tmpikq8b88z/tmpikq8b88z.swift:40: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002baa188a2c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002baa18599b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002baa18599988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002baa185987b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpikq8b88z                        0x00005629932c4b9e <unavailable> + 7070

    5    libc.so.6                          0x00002baa18a8e460 __libc_start_main +
    245

    6    tmpikq8b88z                        0x00005629932c4399 <unavailable> + 5017

    '
  stdout: ''
  timestamp: 1660028312
- exit_code: -4
  program: "\n/// Create a function encrypt that takes a string as an argument and\n\
    /// returns a string encrypted with the alphabet being rotated. \n/// The alphabet\
    \ should be rotated in a manner such that the letters \n/// shift down by two\
    \ multiplied to two places.\n/// For example:\n/// >>> encrypt(s: \"hi\")\n///\
    \ \"lm\"\n/// >>> encrypt(s: \"asdfghjkl\")\n/// \"ewhjklnop\"\n/// >>> encrypt(s:\
    \ \"gf\")\n/// \"kj\"\n/// >>> encrypt(s: \"et\")\n/// \"ix\"\nfunc encrypt(s:\
    \ String) -> String {\n    let first = String(s.first ?? \"z\")\n    let second\
    \ = String(s.last ?? \"z\")\n    var lowerFirst = first.lowercased()\n    var\
    \ lowerSecond = second.lowercased()\n    var encryptedFirst = \"\"\n    var encryptedSecond\
    \ = \"\"\n    for _ in 1...2 {\n        if lowerFirst == \"z\" {\n           \
    \ lowerFirst = \"a\"\n        } else {\n            lowerFirst = String(UnicodeScalar(lowerFirst.unicodeScalars.first!.value\
    \ + 1)!)\n        }\n        if lowerSecond == \"z\" {\n            lowerSecond\
    \ = \"a\"\n        } else {\n            lowerSecond = String(UnicodeScalar(lowerSecond.unicodeScalars.first!.value\
    \ + 1)!)\n        }\n    }\n    for _ in 1...2 {\n        if lowerFirst == \"\
    z\" {\n            lowerFirst = \"a\"\n        } else {\n            lowerFirst\
    \ = String(UnicodeScalar(lowerFirst.unicodeScalars.first!.value + 1)!)\n     \
    \   }\n        if lowerSecond == \"z\" {\n            lowerSecond = \"a\"\n  \
    \      } else {\n            lowerSecond = String(UnicodeScalar(lowerSecond.unicodeScalars.first!.value\
    \ + 1)!)\n        }\n    }\n    if first == first.uppercased() {\n        encryptedFirst\
    \ = lowerFirst.uppercased()\n    } else {\n        encryptedFirst = lowerFirst\n\
    \    }\n    if second == second.uppercased() {\n        encryptedSecond = lowerSecond.uppercased()\n\
    \    } else {\n        encryptedSecond = lowerSecond\n    }\n    return encryptedFirst\
    \ + encryptedSecond\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) ->\
    \ Bool {\n    if left.count != right.count {\n        return false\n    }\n  \
    \  for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(encrypt(s: \"hi\"\
    ) == \"lm\")\nassert(encrypt(s: \"asdfghjkl\") == \"ewhjklnop\")\nassert(encrypt(s:\
    \ \"gf\") == \"kj\")\nassert(encrypt(s: \"et\") == \"ix\")\nassert(encrypt(s:\
    \ \"faewfawefaewg\") == \"jeiajeaijeiak\")\nassert(encrypt(s: \"hellomyfriend\"\
    ) == \"lippsqcjvmirh\")\nassert(encrypt(s: \"dxzdlmnilfuhmilufhlihufnmlimnufhlimnufhfucufh\"\
    ) == \"hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl\")\nassert(encrypt(s: \"\
    a\") == \"e\")"
  status: Exception
  stderr: 'tmpjzaglj4r/tmpjzaglj4r.swift:73: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002ad92f4f5c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002ad92f1ecb6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002ad92f1ec988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002ad92f1eb7b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpjzaglj4r                        0x000055bd04403b07 <unavailable> + 6919

    5    libc.so.6                          0x00002ad92f6e1460 __libc_start_main +
    245

    6    tmpjzaglj4r                        0x000055bd04403659 <unavailable> + 5721

    '
  stdout: ''
  timestamp: 1660028312
- exit_code: 0
  program: "\n/// Create a function encrypt that takes a string as an argument and\n\
    /// returns a string encrypted with the alphabet being rotated. \n/// The alphabet\
    \ should be rotated in a manner such that the letters \n/// shift down by two\
    \ multiplied to two places.\n/// For example:\n/// >>> encrypt(s: \"hi\")\n///\
    \ \"lm\"\n/// >>> encrypt(s: \"asdfghjkl\")\n/// \"ewhjklnop\"\n/// >>> encrypt(s:\
    \ \"gf\")\n/// \"kj\"\n/// >>> encrypt(s: \"et\")\n/// \"ix\"\nfunc encrypt(s:\
    \ String) -> String {\n    //var a = Array(s)\n    //var c = Array(s)\n    var\
    \ result: String = \"\"\n    for i in s.indices {\n        var charAt = s[i]\n\
    \        if (charAt >= \"a\" && charAt <= \"z\") {\n            var c = Int(charAt.asciiValue!)\n\
    \            c += 2 * 2\n            if (c > 122) {\n                c -= 26\n\
    \            }\n            charAt = Character(UnicodeScalar(c)!)\n        }\n\
    \        result.append(charAt)\n    }\n    return result\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(encrypt(s: \"hi\") == \"lm\")\nassert(encrypt(s: \"asdfghjkl\"\
    ) == \"ewhjklnop\")\nassert(encrypt(s: \"gf\") == \"kj\")\nassert(encrypt(s: \"\
    et\") == \"ix\")\nassert(encrypt(s: \"faewfawefaewg\") == \"jeiajeaijeiak\")\n\
    assert(encrypt(s: \"hellomyfriend\") == \"lippsqcjvmirh\")\nassert(encrypt(s:\
    \ \"dxzdlmnilfuhmilufhlihufnmlimnufhlimnufhfucufh\") == \"hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl\"\
    )\nassert(encrypt(s: \"a\") == \"e\")"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660028312
- exit_code: 1
  program: "\n/// Create a function encrypt that takes a string as an argument and\n\
    /// returns a string encrypted with the alphabet being rotated. \n/// The alphabet\
    \ should be rotated in a manner such that the letters \n/// shift down by two\
    \ multiplied to two places.\n/// For example:\n/// >>> encrypt(s: \"hi\")\n///\
    \ \"lm\"\n/// >>> encrypt(s: \"asdfghjkl\")\n/// \"ewhjklnop\"\n/// >>> encrypt(s:\
    \ \"gf\")\n/// \"kj\"\n/// >>> encrypt(s: \"et\")\n/// \"ix\"\nfunc encrypt(s:\
    \ String) -> String {\n    return s.encrypt()\n}\n\n\nfunc ==(left: [(Int, Int)],\
    \ right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n       \
    \ return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r\
    \ {\n            return false\n        }\n    }\n    return true\n}\n        \
    \    \nassert(encrypt(s: \"hi\") == \"lm\")\nassert(encrypt(s: \"asdfghjkl\")\
    \ == \"ewhjklnop\")\nassert(encrypt(s: \"gf\") == \"kj\")\nassert(encrypt(s: \"\
    et\") == \"ix\")\nassert(encrypt(s: \"faewfawefaewg\") == \"jeiajeaijeiak\")\n\
    assert(encrypt(s: \"hellomyfriend\") == \"lippsqcjvmirh\")\nassert(encrypt(s:\
    \ \"dxzdlmnilfuhmilufhlihufnmlimnufhlimnufhfucufh\") == \"hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl\"\
    )\nassert(encrypt(s: \"a\") == \"e\")"
  status: SyntaxError
  stderr: "/tmp/tmpr1t34skx.swift:16:14: error: value of type 'String' has no member\
    \ 'encrypt'\n    return s.encrypt()\n           ~ ^~~~~~~\n"
  stdout: ''
  timestamp: 1660028312
- exit_code: 1
  program: "\n/// Create a function encrypt that takes a string as an argument and\n\
    /// returns a string encrypted with the alphabet being rotated. \n/// The alphabet\
    \ should be rotated in a manner such that the letters \n/// shift down by two\
    \ multiplied to two places.\n/// For example:\n/// >>> encrypt(s: \"hi\")\n///\
    \ \"lm\"\n/// >>> encrypt(s: \"asdfghjkl\")\n/// \"ewhjklnop\"\n/// >>> encrypt(s:\
    \ \"gf\")\n/// \"kj\"\n/// >>> encrypt(s: \"et\")\n/// \"ix\"\nfunc encrypt(s:\
    \ String) -> String {\n    var encrypted: String = \"\"\n    for (i,c) in s.enumerated()\
    \ {\n        let newChar = encryptOne(c: c)\n        if i == 0 {\n           \
    \ encrypted = newChar\n        } else {\n            encrypted += newChar\n  \
    \      }\n    }\n    return encrypted\n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(encrypt(s: \"hi\") == \"lm\")\nassert(encrypt(s: \"asdfghjkl\") == \"ewhjklnop\"\
    )\nassert(encrypt(s: \"gf\") == \"kj\")\nassert(encrypt(s: \"et\") == \"ix\")\n\
    assert(encrypt(s: \"faewfawefaewg\") == \"jeiajeaijeiak\")\nassert(encrypt(s:\
    \ \"hellomyfriend\") == \"lippsqcjvmirh\")\nassert(encrypt(s: \"dxzdlmnilfuhmilufhlihufnmlimnufhlimnufhfucufh\"\
    ) == \"hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl\")\nassert(encrypt(s: \"\
    a\") == \"e\")"
  status: SyntaxError
  stderr: "/tmp/tmpy9wfol_a.swift:18:23: error: cannot find 'encryptOne' in scope\n\
    \        let newChar = encryptOne(c: c)\n                      ^~~~~~~~~~\n"
  stdout: ''
  timestamp: 1660028312
- exit_code: 1
  program: "\n/// Create a function encrypt that takes a string as an argument and\n\
    /// returns a string encrypted with the alphabet being rotated. \n/// The alphabet\
    \ should be rotated in a manner such that the letters \n/// shift down by two\
    \ multiplied to two places.\n/// For example:\n/// >>> encrypt(s: \"hi\")\n///\
    \ \"lm\"\n/// >>> encrypt(s: \"asdfghjkl\")\n/// \"ewhjklnop\"\n/// >>> encrypt(s:\
    \ \"gf\")\n/// \"kj\"\n/// >>> encrypt(s: \"et\")\n/// \"ix\"\nfunc encrypt(s:\
    \ String) -> String {\n    return s.rotate(by: 2*s.count)\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(encrypt(s: \"hi\") == \"lm\")\nassert(encrypt(s: \"asdfghjkl\"\
    ) == \"ewhjklnop\")\nassert(encrypt(s: \"gf\") == \"kj\")\nassert(encrypt(s: \"\
    et\") == \"ix\")\nassert(encrypt(s: \"faewfawefaewg\") == \"jeiajeaijeiak\")\n\
    assert(encrypt(s: \"hellomyfriend\") == \"lippsqcjvmirh\")\nassert(encrypt(s:\
    \ \"dxzdlmnilfuhmilufhlihufnmlimnufhlimnufhfucufh\") == \"hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl\"\
    )\nassert(encrypt(s: \"a\") == \"e\")"
  status: SyntaxError
  stderr: "/tmp/tmpk85afqvr.swift:16:14: error: value of type 'String' has no member\
    \ 'rotate'\n    return s.rotate(by: 2*s.count)\n           ~ ^~~~~~\n"
  stdout: ''
  timestamp: 1660028312
- exit_code: 1
  program: "\n/// Create a function encrypt that takes a string as an argument and\n\
    /// returns a string encrypted with the alphabet being rotated. \n/// The alphabet\
    \ should be rotated in a manner such that the letters \n/// shift down by two\
    \ multiplied to two places.\n/// For example:\n/// >>> encrypt(s: \"hi\")\n///\
    \ \"lm\"\n/// >>> encrypt(s: \"asdfghjkl\")\n/// \"ewhjklnop\"\n/// >>> encrypt(s:\
    \ \"gf\")\n/// \"kj\"\n/// >>> encrypt(s: \"et\")\n/// \"ix\"\nfunc encrypt(s:\
    \ String) -> String {\n    var temp = \"\"\n    let letters = s.lowercased()\n\
    \    for letter in letters {\n        var code = letter.asciiValue\n        code\
    \ = code! + 2 * 2\n        if code! > 122 {\n            code = code! - 26\n \
    \       }\n        temp.append(Character(UnicodeScalar(code!)!))\n    }\n    return\
    \ temp\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n  \
    \  if left.count != right.count {\n        return false\n    }\n    for (l, r)\
    \ in zip(left, right) {\n        if l != r {\n            return false\n     \
    \   }\n    }\n    return true\n}\n            \nassert(encrypt(s: \"hi\") == \"\
    lm\")\nassert(encrypt(s: \"asdfghjkl\") == \"ewhjklnop\")\nassert(encrypt(s: \"\
    gf\") == \"kj\")\nassert(encrypt(s: \"et\") == \"ix\")\nassert(encrypt(s: \"faewfawefaewg\"\
    ) == \"jeiajeaijeiak\")\nassert(encrypt(s: \"hellomyfriend\") == \"lippsqcjvmirh\"\
    )\nassert(encrypt(s: \"dxzdlmnilfuhmilufhlihufnmlimnufhlimnufhfucufh\") == \"\
    hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl\")\nassert(encrypt(s: \"a\") ==\
    \ \"e\")"
  status: SyntaxError
  stderr: "/tmp/tmpma47jijt.swift:24:51: error: cannot force unwrap value of non-optional\
    \ type 'UnicodeScalar' (aka 'Unicode.Scalar')\n        temp.append(Character(UnicodeScalar(code!)!))\n\
    \                              ~~~~~~~~~~~~~~~~~~~~^\n                       \
    \                           \n"
  stdout: ''
  timestamp: 1660028312
- exit_code: 1
  program: "\n/// Create a function encrypt that takes a string as an argument and\n\
    /// returns a string encrypted with the alphabet being rotated. \n/// The alphabet\
    \ should be rotated in a manner such that the letters \n/// shift down by two\
    \ multiplied to two places.\n/// For example:\n/// >>> encrypt(s: \"hi\")\n///\
    \ \"lm\"\n/// >>> encrypt(s: \"asdfghjkl\")\n/// \"ewhjklnop\"\n/// >>> encrypt(s:\
    \ \"gf\")\n/// \"kj\"\n/// >>> encrypt(s: \"et\")\n/// \"ix\"\nfunc encrypt(s:\
    \ String) -> String {\n    let chars = Array(s)\n    var newChars = chars\n  \
    \  for i in 0..<newChars.count {\n        let char = chars[i]\n        let newChar\
    \ = (char - 96) * 2\n        newChars[i] = Int8(newChar)\n    }\n    return String(newChars)\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(encrypt(s: \"hi\") == \"lm\")\nassert(encrypt(s:\
    \ \"asdfghjkl\") == \"ewhjklnop\")\nassert(encrypt(s: \"gf\") == \"kj\")\nassert(encrypt(s:\
    \ \"et\") == \"ix\")\nassert(encrypt(s: \"faewfawefaewg\") == \"jeiajeaijeiak\"\
    )\nassert(encrypt(s: \"hellomyfriend\") == \"lippsqcjvmirh\")\nassert(encrypt(s:\
    \ \"dxzdlmnilfuhmilufhlihufnmlimnufhlimnufhfucufh\") == \"hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl\"\
    )\nassert(encrypt(s: \"a\") == \"e\")"
  status: SyntaxError
  stderr: "/tmp/tmpofng5mnz.swift:20:24: error: cannot convert value of type 'String.Element'\
    \ (aka 'Character') to expected argument type 'Int'\n        let newChar = (char\
    \ - 96) * 2\n                       ^\n/tmp/tmpofng5mnz.swift:21:23: error: no\
    \ 'init' candidates produce the expected contextual result type 'String.Element'\
    \ (aka 'Character')\n        newChars[i] = Int8(newChar)\n                   \
    \   ^\nSwift.Int8:7:12: note: 'init(_:)' produces 'Int8', not the expected contextual\
    \ result type 'String.Element' (aka 'Character')\n    public init(_ source: Float16)\n\
    \           ^\nSwift.Int8:10:12: note: 'init(_:)' produces 'Int8', not the expected\
    \ contextual result type 'String.Element' (aka 'Character')\n    public init(_\
    \ source: Float)\n           ^\nSwift.Int8:12:12: note: 'init(_:)' produces 'Int8',\
    \ not the expected contextual result type 'String.Element' (aka 'Character')\n\
    \    public init(_ source: Double)\n           ^\nSwift.Int8:14:12: note: 'init(_:)'\
    \ produces 'Int8', not the expected contextual result type 'String.Element' (aka\
    \ 'Character')\n    public init(_ source: Float80)\n           ^\nSwift.Int8:28:12:\
    \ note: 'init(_:)' produces 'Int8', not the expected contextual result type 'String.Element'\
    \ (aka 'Character')\n    public init(_ _value: Builtin.Int8)\n           ^\nSwift.FixedWidthInteger:3:23:\
    \ note: 'init(_:)' produces 'Int8?', not the expected contextual result type 'String.Element'\
    \ (aka 'Character')\n    @inlinable public init?(_ description: String)\n    \
    \                  ^\n"
  stdout: ''
  timestamp: 1660028312
- exit_code: 1
  program: "\n/// Create a function encrypt that takes a string as an argument and\n\
    /// returns a string encrypted with the alphabet being rotated. \n/// The alphabet\
    \ should be rotated in a manner such that the letters \n/// shift down by two\
    \ multiplied to two places.\n/// For example:\n/// >>> encrypt(s: \"hi\")\n///\
    \ \"lm\"\n/// >>> encrypt(s: \"asdfghjkl\")\n/// \"ewhjklnop\"\n/// >>> encrypt(s:\
    \ \"gf\")\n/// \"kj\"\n/// >>> encrypt(s: \"et\")\n/// \"ix\"\nfunc encrypt(s:\
    \ String) -> String {\n    var key = \"\"\n    for eachChar in s {\n        let\
    \ asciiCode = eachChar.asciiValue!\n        if asciiCode == 122 {\n          \
    \  key.append(\"b\")\n        } else if asciiCode == 90 {\n            key.append(\"\
    a\")\n        } else {\n            let convertedChar = (asciiCode + 3)\n    \
    \        let newChar = Character(UnicodeScalar(convertedChar)!)\n            key.append(newChar)\n\
    \        }\n    }\n    return key\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int,\
    \ Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n\
    \    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n          \
    \  return false\n        }\n    }\n    return true\n}\n            \nassert(encrypt(s:\
    \ \"hi\") == \"lm\")\nassert(encrypt(s: \"asdfghjkl\") == \"ewhjklnop\")\nassert(encrypt(s:\
    \ \"gf\") == \"kj\")\nassert(encrypt(s: \"et\") == \"ix\")\nassert(encrypt(s:\
    \ \"faewfawefaewg\") == \"jeiajeaijeiak\")\nassert(encrypt(s: \"hellomyfriend\"\
    ) == \"lippsqcjvmirh\")\nassert(encrypt(s: \"dxzdlmnilfuhmilufhlihufnmlimnufhlimnufhfucufh\"\
    ) == \"hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl\")\nassert(encrypt(s: \"\
    a\") == \"e\")"
  status: SyntaxError
  stderr: "/tmp/tmpzwkitgnl.swift:25:65: error: cannot force unwrap value of non-optional\
    \ type 'UnicodeScalar' (aka 'Unicode.Scalar')\n            let newChar = Character(UnicodeScalar(convertedChar)!)\n\
    \                                    ~~~~~~~~~~~~~~~~~~~~~~~~~~~~^\n         \
    \                                                       \n"
  stdout: ''
  timestamp: 1660028312
- exit_code: -4
  program: "\n/// Create a function encrypt that takes a string as an argument and\n\
    /// returns a string encrypted with the alphabet being rotated. \n/// The alphabet\
    \ should be rotated in a manner such that the letters \n/// shift down by two\
    \ multiplied to two places.\n/// For example:\n/// >>> encrypt(s: \"hi\")\n///\
    \ \"lm\"\n/// >>> encrypt(s: \"asdfghjkl\")\n/// \"ewhjklnop\"\n/// >>> encrypt(s:\
    \ \"gf\")\n/// \"kj\"\n/// >>> encrypt(s: \"et\")\n/// \"ix\"\nfunc encrypt(s:\
    \ String) -> String {\n    return \"\"\n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(encrypt(s: \"hi\") == \"lm\")\nassert(encrypt(s: \"asdfghjkl\") == \"ewhjklnop\"\
    )\nassert(encrypt(s: \"gf\") == \"kj\")\nassert(encrypt(s: \"et\") == \"ix\")\n\
    assert(encrypt(s: \"faewfawefaewg\") == \"jeiajeaijeiak\")\nassert(encrypt(s:\
    \ \"hellomyfriend\") == \"lippsqcjvmirh\")\nassert(encrypt(s: \"dxzdlmnilfuhmilufhlihufnmlimnufhlimnufhfucufh\"\
    ) == \"hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl\")\nassert(encrypt(s: \"\
    a\") == \"e\")"
  status: Exception
  stderr: 'tmpxsqxg1op/tmpxsqxg1op.swift:32: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b607b4a6c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b607b19db6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b607b19d988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b607b19c7b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpxsqxg1op                        0x00005575dd252307 <unavailable> + 4871

    5    libc.so.6                          0x00002b607b692460 __libc_start_main +
    245

    6    tmpxsqxg1op                        0x00005575dd251f49 <unavailable> + 3913

    '
  stdout: ''
  timestamp: 1660028310
- exit_code: -4
  program: "\n/// Create a function encrypt that takes a string as an argument and\n\
    /// returns a string encrypted with the alphabet being rotated. \n/// The alphabet\
    \ should be rotated in a manner such that the letters \n/// shift down by two\
    \ multiplied to two places.\n/// For example:\n/// >>> encrypt(s: \"hi\")\n///\
    \ \"lm\"\n/// >>> encrypt(s: \"asdfghjkl\")\n/// \"ewhjklnop\"\n/// >>> encrypt(s:\
    \ \"gf\")\n/// \"kj\"\n/// >>> encrypt(s: \"et\")\n/// \"ix\"\nfunc encrypt(s:\
    \ String) -> String {\n    let initialAlphabet = \"abcdefghijklmnopqrstuvwxyz\"\
    \n    let rotatedAlphabet = \"cdefghijklmnopqrstuvwxyzab\"\n    var encrypted\
    \ = \"\"\n    for i in s {\n        let index = initialAlphabet.index(of: i)\n\
    \        encrypted += String(rotatedAlphabet[index!])\n    }\n    return encrypted\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(encrypt(s: \"hi\") == \"lm\")\nassert(encrypt(s:\
    \ \"asdfghjkl\") == \"ewhjklnop\")\nassert(encrypt(s: \"gf\") == \"kj\")\nassert(encrypt(s:\
    \ \"et\") == \"ix\")\nassert(encrypt(s: \"faewfawefaewg\") == \"jeiajeaijeiak\"\
    )\nassert(encrypt(s: \"hellomyfriend\") == \"lippsqcjvmirh\")\nassert(encrypt(s:\
    \ \"dxzdlmnilfuhmilufhlihufnmlimnufhlimnufhfucufh\") == \"hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl\"\
    )\nassert(encrypt(s: \"a\") == \"e\")"
  status: Exception
  stderr: 'tmpp8crrw46/tmpp8crrw46.swift:39: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b5abe52fc80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b5abe226b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b5abe226988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b5abe2257b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpp8crrw46                        0x000055625adbe667 <unavailable> + 5735

    5    libc.so.6                          0x00002b5abe71b460 __libc_start_main +
    245

    6    tmpp8crrw46                        0x000055625adbe2a9 <unavailable> + 4777

    '
  stdout: ''
  timestamp: 1660028312
- exit_code: 0
  program: "\n/// Create a function encrypt that takes a string as an argument and\n\
    /// returns a string encrypted with the alphabet being rotated. \n/// The alphabet\
    \ should be rotated in a manner such that the letters \n/// shift down by two\
    \ multiplied to two places.\n/// For example:\n/// >>> encrypt(s: \"hi\")\n///\
    \ \"lm\"\n/// >>> encrypt(s: \"asdfghjkl\")\n/// \"ewhjklnop\"\n/// >>> encrypt(s:\
    \ \"gf\")\n/// \"kj\"\n/// >>> encrypt(s: \"et\")\n/// \"ix\"\nfunc encrypt(s:\
    \ String) -> String {\n    let lowercaseAlphabet = Array(\"abcdefghijklmnopqrstuvwxyz\"\
    )\n    let uppercaseAlphabet = Array(\"ABCDEFGHIJKLMNOPQRSTUVWXYZ\")\n    var\
    \ encryptedString = \"\"\n    for letter in s {\n        if let index = lowercaseAlphabet.firstIndex(of:\
    \ letter) {\n            let newIndex = (index + 4) % 26\n            encryptedString.append(lowercaseAlphabet[newIndex])\n\
    \        } else if let index = uppercaseAlphabet.firstIndex(of: letter) {\n  \
    \          let newIndex = (index + 4) % 26\n            encryptedString.append(uppercaseAlphabet[newIndex])\n\
    \        } else {\n            encryptedString.append(letter)\n        }\n   \
    \ }\n    return encryptedString\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int,\
    \ Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n\
    \    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n          \
    \  return false\n        }\n    }\n    return true\n}\n            \nassert(encrypt(s:\
    \ \"hi\") == \"lm\")\nassert(encrypt(s: \"asdfghjkl\") == \"ewhjklnop\")\nassert(encrypt(s:\
    \ \"gf\") == \"kj\")\nassert(encrypt(s: \"et\") == \"ix\")\nassert(encrypt(s:\
    \ \"faewfawefaewg\") == \"jeiajeaijeiak\")\nassert(encrypt(s: \"hellomyfriend\"\
    ) == \"lippsqcjvmirh\")\nassert(encrypt(s: \"dxzdlmnilfuhmilufhlihufnmlimnufhlimnufhfucufh\"\
    ) == \"hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl\")\nassert(encrypt(s: \"\
    a\") == \"e\")"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660028312
- exit_code: -4
  program: "\n/// Create a function encrypt that takes a string as an argument and\n\
    /// returns a string encrypted with the alphabet being rotated. \n/// The alphabet\
    \ should be rotated in a manner such that the letters \n/// shift down by two\
    \ multiplied to two places.\n/// For example:\n/// >>> encrypt(s: \"hi\")\n///\
    \ \"lm\"\n/// >>> encrypt(s: \"asdfghjkl\")\n/// \"ewhjklnop\"\n/// >>> encrypt(s:\
    \ \"gf\")\n/// \"kj\"\n/// >>> encrypt(s: \"et\")\n/// \"ix\"\nfunc encrypt(s:\
    \ String) -> String {\n    return \"\"\n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(encrypt(s: \"hi\") == \"lm\")\nassert(encrypt(s: \"asdfghjkl\") == \"ewhjklnop\"\
    )\nassert(encrypt(s: \"gf\") == \"kj\")\nassert(encrypt(s: \"et\") == \"ix\")\n\
    assert(encrypt(s: \"faewfawefaewg\") == \"jeiajeaijeiak\")\nassert(encrypt(s:\
    \ \"hellomyfriend\") == \"lippsqcjvmirh\")\nassert(encrypt(s: \"dxzdlmnilfuhmilufhlihufnmlimnufhlimnufhfucufh\"\
    ) == \"hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl\")\nassert(encrypt(s: \"\
    a\") == \"e\")"
  status: Exception
  stderr: 'tmpxsqxg1op/tmpxsqxg1op.swift:32: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b607b4a6c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b607b19db6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b607b19d988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b607b19c7b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpxsqxg1op                        0x00005575dd252307 <unavailable> + 4871

    5    libc.so.6                          0x00002b607b692460 __libc_start_main +
    245

    6    tmpxsqxg1op                        0x00005575dd251f49 <unavailable> + 3913

    '
  stdout: ''
  timestamp: 1660028310
- exit_code: 1
  program: "\n/// Create a function encrypt that takes a string as an argument and\n\
    /// returns a string encrypted with the alphabet being rotated. \n/// The alphabet\
    \ should be rotated in a manner such that the letters \n/// shift down by two\
    \ multiplied to two places.\n/// For example:\n/// >>> encrypt(s: \"hi\")\n///\
    \ \"lm\"\n/// >>> encrypt(s: \"asdfghjkl\")\n/// \"ewhjklnop\"\n/// >>> encrypt(s:\
    \ \"gf\")\n/// \"kj\"\n/// >>> encrypt(s: \"et\")\n/// \"ix\"\nfunc encrypt(s:\
    \ String) -> String {\n    // your code here\n}\n\n\nfunc ==(left: [(Int, Int)],\
    \ right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n       \
    \ return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r\
    \ {\n            return false\n        }\n    }\n    return true\n}\n        \
    \    \nassert(encrypt(s: \"hi\") == \"lm\")\nassert(encrypt(s: \"asdfghjkl\")\
    \ == \"ewhjklnop\")\nassert(encrypt(s: \"gf\") == \"kj\")\nassert(encrypt(s: \"\
    et\") == \"ix\")\nassert(encrypt(s: \"faewfawefaewg\") == \"jeiajeaijeiak\")\n\
    assert(encrypt(s: \"hellomyfriend\") == \"lippsqcjvmirh\")\nassert(encrypt(s:\
    \ \"dxzdlmnilfuhmilufhlihufnmlimnufhlimnufhfucufh\") == \"hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl\"\
    )\nassert(encrypt(s: \"a\") == \"e\")"
  status: SyntaxError
  stderr: '/tmp/tmpldo9rmlw.swift:17:1: error: missing return in global function expected
    to return ''String''

    }

    ^

    '
  stdout: ''
  timestamp: 1660028312
- exit_code: -4
  program: "\n/// Create a function encrypt that takes a string as an argument and\n\
    /// returns a string encrypted with the alphabet being rotated. \n/// The alphabet\
    \ should be rotated in a manner such that the letters \n/// shift down by two\
    \ multiplied to two places.\n/// For example:\n/// >>> encrypt(s: \"hi\")\n///\
    \ \"lm\"\n/// >>> encrypt(s: \"asdfghjkl\")\n/// \"ewhjklnop\"\n/// >>> encrypt(s:\
    \ \"gf\")\n/// \"kj\"\n/// >>> encrypt(s: \"et\")\n/// \"ix\"\nfunc encrypt(s:\
    \ String) -> String {\n  let sLower = s.lowercased()\n  var retStr = \"\"\n  for\
    \ char in sLower {\n    switch char {\n    case \" \":\n      retStr += \" \"\n\
    \    case \"a\":\n      retStr += \"c\"\n    case \"b\":\n      retStr += \"d\"\
    \n    case \"c\":\n      retStr += \"e\"\n    case \"d\":\n      retStr += \"\
    f\"\n    case \"e\":\n      retStr += \"g\"\n    case \"f\":\n      retStr +=\
    \ \"h\"\n    case \"g\":\n      retStr += \"i\"\n    case \"h\":\n      retStr\
    \ += \"j\"\n    case \"i\":\n      retStr += \"k\"\n    case \"j\":\n      retStr\
    \ += \"l\"\n    case \"k\":\n      retStr += \"m\"\n    case \"l\":\n      retStr\
    \ += \"n\"\n    case \"m\":\n      retStr += \"o\"\n    case \"n\":\n      retStr\
    \ += \"p\"\n    case \"o\":\n      retStr += \"q\"\n    case \"p\":\n      retStr\
    \ += \"r\"\n    case \"q\":\n      retStr += \"s\"\n    case \"r\":\n      retStr\
    \ += \"t\"\n    case \"s\":\n      retStr += \"u\"\n    case \"t\":\n      retStr\
    \ += \"v\"\n    case \"u\":\n      retStr += \"w\"\n    case \"v\":\n      retStr\
    \ += \"x\"\n    case \"w\":\n      retStr += \"y\"\n    case \"x\":\n      retStr\
    \ += \"z\"\n    case \"y\":\n      retStr += \"a\"\n    case \"z\":\n      retStr\
    \ += \"b\"\n    default:\n      retStr += \" \"\n    }\n  }\n  return retStr\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(encrypt(s: \"hi\") == \"lm\")\nassert(encrypt(s:\
    \ \"asdfghjkl\") == \"ewhjklnop\")\nassert(encrypt(s: \"gf\") == \"kj\")\nassert(encrypt(s:\
    \ \"et\") == \"ix\")\nassert(encrypt(s: \"faewfawefaewg\") == \"jeiajeaijeiak\"\
    )\nassert(encrypt(s: \"hellomyfriend\") == \"lippsqcjvmirh\")\nassert(encrypt(s:\
    \ \"dxzdlmnilfuhmilufhlihufnmlimnufhlimnufhfucufh\") == \"hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl\"\
    )\nassert(encrypt(s: \"a\") == \"e\")"
  status: Exception
  stderr: 'tmpibiybd_0/tmpibiybd_0.swift:94: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b3a89dacc80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b3a89aa3b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b3a89aa3988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b3a89aa27b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpibiybd_0                        0x00005590ecc78557 <unavailable> + 5463

    5    libc.so.6                          0x00002b3a89f98460 __libc_start_main +
    245

    6    tmpibiybd_0                        0x00005590ecc78199 <unavailable> + 4505

    '
  stdout: ''
  timestamp: 1660028312
- exit_code: -4
  program: "\n/// Create a function encrypt that takes a string as an argument and\n\
    /// returns a string encrypted with the alphabet being rotated. \n/// The alphabet\
    \ should be rotated in a manner such that the letters \n/// shift down by two\
    \ multiplied to two places.\n/// For example:\n/// >>> encrypt(s: \"hi\")\n///\
    \ \"lm\"\n/// >>> encrypt(s: \"asdfghjkl\")\n/// \"ewhjklnop\"\n/// >>> encrypt(s:\
    \ \"gf\")\n/// \"kj\"\n/// >>> encrypt(s: \"et\")\n/// \"ix\"\nfunc encrypt(s:\
    \ String) -> String {\n    return \"\"\n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(encrypt(s: \"hi\") == \"lm\")\nassert(encrypt(s: \"asdfghjkl\") == \"ewhjklnop\"\
    )\nassert(encrypt(s: \"gf\") == \"kj\")\nassert(encrypt(s: \"et\") == \"ix\")\n\
    assert(encrypt(s: \"faewfawefaewg\") == \"jeiajeaijeiak\")\nassert(encrypt(s:\
    \ \"hellomyfriend\") == \"lippsqcjvmirh\")\nassert(encrypt(s: \"dxzdlmnilfuhmilufhlihufnmlimnufhlimnufhfucufh\"\
    ) == \"hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl\")\nassert(encrypt(s: \"\
    a\") == \"e\")"
  status: Exception
  stderr: 'tmpxsqxg1op/tmpxsqxg1op.swift:32: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b607b4a6c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b607b19db6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b607b19d988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b607b19c7b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpxsqxg1op                        0x00005575dd252307 <unavailable> + 4871

    5    libc.so.6                          0x00002b607b692460 __libc_start_main +
    245

    6    tmpxsqxg1op                        0x00005575dd251f49 <unavailable> + 3913

    '
  stdout: ''
  timestamp: 1660028310
- exit_code: 0
  program: "\n/// Create a function encrypt that takes a string as an argument and\n\
    /// returns a string encrypted with the alphabet being rotated. \n/// The alphabet\
    \ should be rotated in a manner such that the letters \n/// shift down by two\
    \ multiplied to two places.\n/// For example:\n/// >>> encrypt(s: \"hi\")\n///\
    \ \"lm\"\n/// >>> encrypt(s: \"asdfghjkl\")\n/// \"ewhjklnop\"\n/// >>> encrypt(s:\
    \ \"gf\")\n/// \"kj\"\n/// >>> encrypt(s: \"et\")\n/// \"ix\"\nfunc encrypt(s:\
    \ String) -> String {\n    var alphabet: [Character] = [Character]()\n    for\
    \ i in UnicodeScalar(\"a\").value...UnicodeScalar(\"z\").value {\n        alphabet.append(Character(UnicodeScalar(i)!))\n\
    \    }\n    var newStr: String = \"\"\n    for char in s {\n        var index\
    \ = alphabet.firstIndex(of: char)\n        if index == nil {\n            newStr.append(char)\n\
    \        } else {\n            index = (index! + 2 * 2) % alphabet.count\n   \
    \         newStr.append(alphabet[index!])\n        }\n    }\n    return newStr\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(encrypt(s: \"hi\") == \"lm\")\nassert(encrypt(s:\
    \ \"asdfghjkl\") == \"ewhjklnop\")\nassert(encrypt(s: \"gf\") == \"kj\")\nassert(encrypt(s:\
    \ \"et\") == \"ix\")\nassert(encrypt(s: \"faewfawefaewg\") == \"jeiajeaijeiak\"\
    )\nassert(encrypt(s: \"hellomyfriend\") == \"lippsqcjvmirh\")\nassert(encrypt(s:\
    \ \"dxzdlmnilfuhmilufhlihufnmlimnufhlimnufhfucufh\") == \"hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl\"\
    )\nassert(encrypt(s: \"a\") == \"e\")"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660028312
- exit_code: -4
  program: "\n/// Create a function encrypt that takes a string as an argument and\n\
    /// returns a string encrypted with the alphabet being rotated. \n/// The alphabet\
    \ should be rotated in a manner such that the letters \n/// shift down by two\
    \ multiplied to two places.\n/// For example:\n/// >>> encrypt(s: \"hi\")\n///\
    \ \"lm\"\n/// >>> encrypt(s: \"asdfghjkl\")\n/// \"ewhjklnop\"\n/// >>> encrypt(s:\
    \ \"gf\")\n/// \"kj\"\n/// >>> encrypt(s: \"et\")\n/// \"ix\"\nfunc encrypt(s:\
    \ String) -> String {\n    let alphabet = \"abcdefghijklmnopqrstuvwxyz\"\n   \
    \ var encryptedString = \"\"\n    for letter in s {\n        var shiftedIndex\
    \ = alphabet.firstIndex(of: letter)\n        let shift = -2\n        var shiftedLetter\
    \ = letter\n        if let index = shiftedIndex {\n            var distance =\
    \ alphabet.distance(from: alphabet.startIndex, to: index)\n            distance\
    \ = distance + shift\n            while distance < 0 {\n                distance\
    \ = distance + alphabet.count\n            }\n            shiftedIndex = alphabet.index(alphabet.startIndex,\
    \ offsetBy: distance)\n            shiftedLetter = alphabet[shiftedIndex!]\n \
    \       }\n        encryptedString.append(shiftedLetter)\n    }\n    return encryptedString\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(encrypt(s: \"hi\") == \"lm\")\nassert(encrypt(s:\
    \ \"asdfghjkl\") == \"ewhjklnop\")\nassert(encrypt(s: \"gf\") == \"kj\")\nassert(encrypt(s:\
    \ \"et\") == \"ix\")\nassert(encrypt(s: \"faewfawefaewg\") == \"jeiajeaijeiak\"\
    )\nassert(encrypt(s: \"hellomyfriend\") == \"lippsqcjvmirh\")\nassert(encrypt(s:\
    \ \"dxzdlmnilfuhmilufhlihufnmlimnufhlimnufhfucufh\") == \"hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl\"\
    )\nassert(encrypt(s: \"a\") == \"e\")"
  status: Exception
  stderr: 'tmpessps0zi/tmpessps0zi.swift:49: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002afa41d10c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002afa41a07b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002afa41a07988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002afa41a067b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpessps0zi                        0x000055f19079f707 <unavailable> + 5895

    5    libc.so.6                          0x00002afa41efc460 __libc_start_main +
    245

    6    tmpessps0zi                        0x000055f19079f349 <unavailable> + 4937

    '
  stdout: ''
  timestamp: 1660028312
- exit_code: 1
  program: "\n/// Create a function encrypt that takes a string as an argument and\n\
    /// returns a string encrypted with the alphabet being rotated. \n/// The alphabet\
    \ should be rotated in a manner such that the letters \n/// shift down by two\
    \ multiplied to two places.\n/// For example:\n/// >>> encrypt(s: \"hi\")\n///\
    \ \"lm\"\n/// >>> encrypt(s: \"asdfghjkl\")\n/// \"ewhjklnop\"\n/// >>> encrypt(s:\
    \ \"gf\")\n/// \"kj\"\n/// >>> encrypt(s: \"et\")\n/// \"ix\"\nfunc encrypt(s:\
    \ String) -> String {\n    let unicodeArray = s.unicodeScalars.map {$0.value}\n\
    \    var encryptedArray = [UInt32]()\n    for i in unicodeArray {\n        encryptedArray.append(i\
    \ + 4)\n    }\n    let encryptedString = String(unicodeScalars: encryptedArray.map\
    \ { UnicodeScalar($0)! })\n    return encryptedString\n}\n\n\nfunc ==(left: [(Int,\
    \ Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n\
    \        return false\n    }\n    for (l, r) in zip(left, right) {\n        if\
    \ l != r {\n            return false\n        }\n    }\n    return true\n}\n \
    \           \nassert(encrypt(s: \"hi\") == \"lm\")\nassert(encrypt(s: \"asdfghjkl\"\
    ) == \"ewhjklnop\")\nassert(encrypt(s: \"gf\") == \"kj\")\nassert(encrypt(s: \"\
    et\") == \"ix\")\nassert(encrypt(s: \"faewfawefaewg\") == \"jeiajeaijeiak\")\n\
    assert(encrypt(s: \"hellomyfriend\") == \"lippsqcjvmirh\")\nassert(encrypt(s:\
    \ \"dxzdlmnilfuhmilufhlihufnmlimnufhlimnufhfucufh\") == \"hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl\"\
    )\nassert(encrypt(s: \"a\") == \"e\")"
  status: SyntaxError
  stderr: "/tmp/tmpeqqv6mv3.swift:21:27: error: no exact matches in call to initializer\
    \ \n    let encryptedString = String(unicodeScalars: encryptedArray.map { UnicodeScalar($0)!\
    \ })\n                          ^\n/tmp/tmpeqqv6mv3.swift:21:27: note: found candidate\
    \ with type '([UnicodeScalar]) -> String' (aka '(Array<Unicode.Scalar>) -> String')\n\
    \    let encryptedString = String(unicodeScalars: encryptedArray.map { UnicodeScalar($0)!\
    \ })\n                          ^\nSwift.String:2:12: note: incorrect labels for\
    \ candidate (have: '(unicodeScalars:)', expected: '(describing:)')\n    public\
    \ init<Subject>(describing instance: Subject)\n           ^\nSwift.String:3:23:\
    \ note: incorrect labels for candidate (have: '(unicodeScalars:)', expected: '(describing:)')\n\
    \    @inlinable public init<Subject>(describing instance: Subject) where Subject\
    \ : CustomStringConvertible\n                      ^\nSwift.String:6:12: note:\
    \ incorrect labels for candidate (have: '(unicodeScalars:)', expected: '(reflecting:)')\n\
    \    public init<Subject>(reflecting subject: Subject)\n           ^\n"
  stdout: ''
  timestamp: 1660028312
- exit_code: -4
  program: "\n/// Create a function encrypt that takes a string as an argument and\n\
    /// returns a string encrypted with the alphabet being rotated. \n/// The alphabet\
    \ should be rotated in a manner such that the letters \n/// shift down by two\
    \ multiplied to two places.\n/// For example:\n/// >>> encrypt(s: \"hi\")\n///\
    \ \"lm\"\n/// >>> encrypt(s: \"asdfghjkl\")\n/// \"ewhjklnop\"\n/// >>> encrypt(s:\
    \ \"gf\")\n/// \"kj\"\n/// >>> encrypt(s: \"et\")\n/// \"ix\"\nfunc encrypt(s:\
    \ String) -> String {\n    return \"\"\n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(encrypt(s: \"hi\") == \"lm\")\nassert(encrypt(s: \"asdfghjkl\") == \"ewhjklnop\"\
    )\nassert(encrypt(s: \"gf\") == \"kj\")\nassert(encrypt(s: \"et\") == \"ix\")\n\
    assert(encrypt(s: \"faewfawefaewg\") == \"jeiajeaijeiak\")\nassert(encrypt(s:\
    \ \"hellomyfriend\") == \"lippsqcjvmirh\")\nassert(encrypt(s: \"dxzdlmnilfuhmilufhlihufnmlimnufhlimnufhfucufh\"\
    ) == \"hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl\")\nassert(encrypt(s: \"\
    a\") == \"e\")"
  status: Exception
  stderr: 'tmpxsqxg1op/tmpxsqxg1op.swift:32: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b607b4a6c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b607b19db6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b607b19d988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b607b19c7b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpxsqxg1op                        0x00005575dd252307 <unavailable> + 4871

    5    libc.so.6                          0x00002b607b692460 __libc_start_main +
    245

    6    tmpxsqxg1op                        0x00005575dd251f49 <unavailable> + 3913

    '
  stdout: ''
  timestamp: 1660028310
- exit_code: -4
  program: "\n/// Create a function encrypt that takes a string as an argument and\n\
    /// returns a string encrypted with the alphabet being rotated. \n/// The alphabet\
    \ should be rotated in a manner such that the letters \n/// shift down by two\
    \ multiplied to two places.\n/// For example:\n/// >>> encrypt(s: \"hi\")\n///\
    \ \"lm\"\n/// >>> encrypt(s: \"asdfghjkl\")\n/// \"ewhjklnop\"\n/// >>> encrypt(s:\
    \ \"gf\")\n/// \"kj\"\n/// >>> encrypt(s: \"et\")\n/// \"ix\"\nfunc encrypt(s:\
    \ String) -> String {\n    var res = \"\"\n    let maxIndex = s.count - 1\n  \
    \  for i in s.indices {\n        let idx = s.index(i, offsetBy: (i.encodedOffset\
    \ + (i.encodedOffset + 2) * 2) % maxIndex + 1)\n        res.append(s[idx])\n \
    \   }\n    return res\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(encrypt(s:\
    \ \"hi\") == \"lm\")\nassert(encrypt(s: \"asdfghjkl\") == \"ewhjklnop\")\nassert(encrypt(s:\
    \ \"gf\") == \"kj\")\nassert(encrypt(s: \"et\") == \"ix\")\nassert(encrypt(s:\
    \ \"faewfawefaewg\") == \"jeiajeaijeiak\")\nassert(encrypt(s: \"hellomyfriend\"\
    ) == \"lippsqcjvmirh\")\nassert(encrypt(s: \"dxzdlmnilfuhmilufhlihufnmlimnufhlimnufhfucufh\"\
    ) == \"hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl\")\nassert(encrypt(s: \"\
    a\") == \"e\")"
  status: Exception
  stderr: 'Swift/StringIndexValidation.swift:120: Fatal error: String index is out
    of bounds

    Current stack trace:

    0    libswiftCore.so                    0x00002b670da3ac80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b670d731561 <unavailable> + 1434977

    2    libswiftCore.so                    0x00002b670d731286 <unavailable> + 1434246

    3    libswiftCore.so                    0x00002b670d73113c <unavailable> + 1433916

    4    libswiftCore.so                    0x00002b670d730bb0 _assertionFailure(_:_:file:line:flags:)
    + 251

    5    libswiftCore.so                    0x00002b670d864ec2 <unavailable> + 2694850

    6    libswiftCore.so                    0x00002b670d81d660 String.subscript.getter
    + 34

    7    tmpja83k34j                        0x000055f100b20300 <unavailable> + 8960

    8    tmpja83k34j                        0x000055f100b1f6e6 <unavailable> + 5862

    9    libc.so.6                          0x00002b670dc26460 __libc_start_main +
    245

    10   tmpja83k34j                        0x000055f100b1f3e9 <unavailable> + 5097

    '
  stdout: ''
  timestamp: 1660028312
- exit_code: 1
  program: "\n/// Create a function encrypt that takes a string as an argument and\n\
    /// returns a string encrypted with the alphabet being rotated. \n/// The alphabet\
    \ should be rotated in a manner such that the letters \n/// shift down by two\
    \ multiplied to two places.\n/// For example:\n/// >>> encrypt(s: \"hi\")\n///\
    \ \"lm\"\n/// >>> encrypt(s: \"asdfghjkl\")\n/// \"ewhjklnop\"\n/// >>> encrypt(s:\
    \ \"gf\")\n/// \"kj\"\n/// >>> encrypt(s: \"et\")\n/// \"ix\"\nfunc encrypt(s:\
    \ String) -> String {\n    var result = \"\"\n    for letter in s {\n        result\
    \ += String(Character(UnicodeScalar(UInt8(letter.asciiValue!) + 2*2)!))\n    }\n\
    \    return result\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) ->\
    \ Bool {\n    if left.count != right.count {\n        return false\n    }\n  \
    \  for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(encrypt(s: \"hi\"\
    ) == \"lm\")\nassert(encrypt(s: \"asdfghjkl\") == \"ewhjklnop\")\nassert(encrypt(s:\
    \ \"gf\") == \"kj\")\nassert(encrypt(s: \"et\") == \"ix\")\nassert(encrypt(s:\
    \ \"faewfawefaewg\") == \"jeiajeaijeiak\")\nassert(encrypt(s: \"hellomyfriend\"\
    ) == \"lippsqcjvmirh\")\nassert(encrypt(s: \"dxzdlmnilfuhmilufhlihufnmlimnufhlimnufhfucufh\"\
    ) == \"hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl\")\nassert(encrypt(s: \"\
    a\") == \"e\")"
  status: SyntaxError
  stderr: "/tmp/tmpfbvqh2gb.swift:18:82: error: cannot force unwrap value of non-optional\
    \ type 'UnicodeScalar' (aka 'Unicode.Scalar')\n        result += String(Character(UnicodeScalar(UInt8(letter.asciiValue!)\
    \ + 2*2)!))\n                                   ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~^\n\
    \                                                                            \
    \     \n"
  stdout: ''
  timestamp: 1660028313
- exit_code: 1
  program: "\n/// Create a function encrypt that takes a string as an argument and\n\
    /// returns a string encrypted with the alphabet being rotated. \n/// The alphabet\
    \ should be rotated in a manner such that the letters \n/// shift down by two\
    \ multiplied to two places.\n/// For example:\n/// >>> encrypt(s: \"hi\")\n///\
    \ \"lm\"\n/// >>> encrypt(s: \"asdfghjkl\")\n/// \"ewhjklnop\"\n/// >>> encrypt(s:\
    \ \"gf\")\n/// \"kj\"\n/// >>> encrypt(s: \"et\")\n/// \"ix\"\nfunc encrypt(s:\
    \ String) -> String {\n    \n    var array = Array(s)\n    var valueOfString =\
    \ [Character]()\n    \n    for i in 0..<array.count {\n        let value = array[i].asciiValue\n\
    \        valueOfString.append(Character(UnicodeScalar(value! + 2)!))\n    }\n\
    \    \n    return String(valueOfString)\n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(encrypt(s: \"hi\") == \"lm\")\nassert(encrypt(s: \"asdfghjkl\") == \"ewhjklnop\"\
    )\nassert(encrypt(s: \"gf\") == \"kj\")\nassert(encrypt(s: \"et\") == \"ix\")\n\
    assert(encrypt(s: \"faewfawefaewg\") == \"jeiajeaijeiak\")\nassert(encrypt(s:\
    \ \"hellomyfriend\") == \"lippsqcjvmirh\")\nassert(encrypt(s: \"dxzdlmnilfuhmilufhlihufnmlimnufhlimnufhfucufh\"\
    ) == \"hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl\")\nassert(encrypt(s: \"\
    a\") == \"e\")"
  status: SyntaxError
  stderr: "/tmp/tmpy_c5bx96.swift:22:65: error: cannot force unwrap value of non-optional\
    \ type 'UnicodeScalar' (aka 'Unicode.Scalar')\n        valueOfString.append(Character(UnicodeScalar(value!\
    \ + 2)!))\n                                       ~~~~~~~~~~~~~~~~~~~~~~~~~^\n\
    \                                                                \n"
  stdout: ''
  timestamp: 1660028312
- exit_code: -4
  program: "\n/// Create a function encrypt that takes a string as an argument and\n\
    /// returns a string encrypted with the alphabet being rotated. \n/// The alphabet\
    \ should be rotated in a manner such that the letters \n/// shift down by two\
    \ multiplied to two places.\n/// For example:\n/// >>> encrypt(s: \"hi\")\n///\
    \ \"lm\"\n/// >>> encrypt(s: \"asdfghjkl\")\n/// \"ewhjklnop\"\n/// >>> encrypt(s:\
    \ \"gf\")\n/// \"kj\"\n/// >>> encrypt(s: \"et\")\n/// \"ix\"\nfunc encrypt(s:\
    \ String) -> String {\n    let alphabet = \"abcdefghijklmnopqrstuvwxyz\"\n   \
    \ var encrypted = \"\"\n    for i in s {\n        let position = alphabet.firstIndex(of:\
    \ i)\n        if let position = position {\n            let index = alphabet.index(position,\
    \ offsetBy: 2)\n            let encrypt = alphabet[index]\n            encrypted.append(encrypt)\n\
    \        }\n    }\n    return encrypted\n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(encrypt(s: \"hi\") == \"lm\")\nassert(encrypt(s: \"asdfghjkl\") == \"ewhjklnop\"\
    )\nassert(encrypt(s: \"gf\") == \"kj\")\nassert(encrypt(s: \"et\") == \"ix\")\n\
    assert(encrypt(s: \"faewfawefaewg\") == \"jeiajeaijeiak\")\nassert(encrypt(s:\
    \ \"hellomyfriend\") == \"lippsqcjvmirh\")\nassert(encrypt(s: \"dxzdlmnilfuhmilufhlihufnmlimnufhlimnufhfucufh\"\
    ) == \"hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl\")\nassert(encrypt(s: \"\
    a\") == \"e\")"
  status: Exception
  stderr: 'tmp3f243a85/tmp3f243a85.swift:42: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b21489abc80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b21486a2b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b21486a2988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b21486a17b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmp3f243a85                        0x000056218bdaf5f7 <unavailable> + 5623

    5    libc.so.6                          0x00002b2148b97460 __libc_start_main +
    245

    6    tmp3f243a85                        0x000056218bdaf239 <unavailable> + 4665

    '
  stdout: ''
  timestamp: 1660028312
- exit_code: 1
  program: "\n/// Create a function encrypt that takes a string as an argument and\n\
    /// returns a string encrypted with the alphabet being rotated. \n/// The alphabet\
    \ should be rotated in a manner such that the letters \n/// shift down by two\
    \ multiplied to two places.\n/// For example:\n/// >>> encrypt(s: \"hi\")\n///\
    \ \"lm\"\n/// >>> encrypt(s: \"asdfghjkl\")\n/// \"ewhjklnop\"\n/// >>> encrypt(s:\
    \ \"gf\")\n/// \"kj\"\n/// >>> encrypt(s: \"et\")\n/// \"ix\"\nfunc encrypt(s:\
    \ String) -> String {\n    let temp = s.filter { $0 != \" \" }\n    let letters\
    \ = Array(temp)\n    var string = \"\"\n    var index: Int\n    for letter in\
    \ letters {\n        index = letters.firstIndex(of: letter)!\n        index =\
    \ (index + (index * 2)) % 26\n        string += \"\\(Array(alphabet)[index])\"\
    \n    }\n    return string\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(encrypt(s:\
    \ \"hi\") == \"lm\")\nassert(encrypt(s: \"asdfghjkl\") == \"ewhjklnop\")\nassert(encrypt(s:\
    \ \"gf\") == \"kj\")\nassert(encrypt(s: \"et\") == \"ix\")\nassert(encrypt(s:\
    \ \"faewfawefaewg\") == \"jeiajeaijeiak\")\nassert(encrypt(s: \"hellomyfriend\"\
    ) == \"lippsqcjvmirh\")\nassert(encrypt(s: \"dxzdlmnilfuhmilufhlihufnmlimnufhlimnufhfucufh\"\
    ) == \"hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl\")\nassert(encrypt(s: \"\
    a\") == \"e\")"
  status: SyntaxError
  stderr: "/tmp/tmpftsi2t5c.swift:23:28: error: cannot find 'alphabet' in scope\n\
    \        string += \"\\(Array(alphabet)[index])\"\n                          \
    \ ^~~~~~~~\n"
  stdout: ''
  timestamp: 1660028312
- exit_code: 1
  program: "\n/// Create a function encrypt that takes a string as an argument and\n\
    /// returns a string encrypted with the alphabet being rotated. \n/// The alphabet\
    \ should be rotated in a manner such that the letters \n/// shift down by two\
    \ multiplied to two places.\n/// For example:\n/// >>> encrypt(s: \"hi\")\n///\
    \ \"lm\"\n/// >>> encrypt(s: \"asdfghjkl\")\n/// \"ewhjklnop\"\n/// >>> encrypt(s:\
    \ \"gf\")\n/// \"kj\"\n/// >>> encrypt(s: \"et\")\n/// \"ix\"\nfunc encrypt(s:\
    \ String) -> String {\n    var modifiedAlphabet = alphabetArray\n    var index\
    \ = 0\n    for _ in 1...2 {\n        modifiedAlphabet.insert(modifiedAlphabet.remove(at:\
    \ index), at: modifiedAlphabet.count)\n        index += 1\n    }\n    modifiedAlphabet.insert(modifiedAlphabet.remove(at:\
    \ index), at: modifiedAlphabet.count)\n    index += 1\n    var str = \"\"\n  \
    \  for char in s {\n        if let i = alphabet.firstIndex(of: char) {\n     \
    \       str += modifiedAlphabet[i]\n        }\n    }\n    return str\n}\n\n\n\
    func ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(encrypt(s: \"hi\") == \"lm\")\nassert(encrypt(s:\
    \ \"asdfghjkl\") == \"ewhjklnop\")\nassert(encrypt(s: \"gf\") == \"kj\")\nassert(encrypt(s:\
    \ \"et\") == \"ix\")\nassert(encrypt(s: \"faewfawefaewg\") == \"jeiajeaijeiak\"\
    )\nassert(encrypt(s: \"hellomyfriend\") == \"lippsqcjvmirh\")\nassert(encrypt(s:\
    \ \"dxzdlmnilfuhmilufhlihufnmlimnufhlimnufhfucufh\") == \"hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl\"\
    )\nassert(encrypt(s: \"a\") == \"e\")"
  status: SyntaxError
  stderr: "/tmp/tmpx79okigs.swift:16:28: error: cannot find 'alphabetArray' in scope\n\
    \    var modifiedAlphabet = alphabetArray\n                           ^~~~~~~~~~~~~\n\
    /tmp/tmpx79okigs.swift:26:20: error: cannot find 'alphabet' in scope\n       \
    \ if let i = alphabet.firstIndex(of: char) {\n                   ^~~~~~~~\n"
  stdout: ''
  timestamp: 1660028312
- exit_code: -4
  program: "\n/// Create a function encrypt that takes a string as an argument and\n\
    /// returns a string encrypted with the alphabet being rotated. \n/// The alphabet\
    \ should be rotated in a manner such that the letters \n/// shift down by two\
    \ multiplied to two places.\n/// For example:\n/// >>> encrypt(s: \"hi\")\n///\
    \ \"lm\"\n/// >>> encrypt(s: \"asdfghjkl\")\n/// \"ewhjklnop\"\n/// >>> encrypt(s:\
    \ \"gf\")\n/// \"kj\"\n/// >>> encrypt(s: \"et\")\n/// \"ix\"\nfunc encrypt(s:\
    \ String) -> String {\n    \n    let chars = [Character](s)\n    var encrypted\
    \ = \"\"\n    \n    for c in chars {\n        let unicode = c.unicodeScalars.first!.value\n\
    \        let encryptedChar = UnicodeScalar(Int(unicode) + 2 * 2)\n        encrypted.append(Character(encryptedChar!))\n\
    \    }\n    \n    return encrypted\n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(encrypt(s: \"hi\") == \"lm\")\nassert(encrypt(s: \"asdfghjkl\") == \"ewhjklnop\"\
    )\nassert(encrypt(s: \"gf\") == \"kj\")\nassert(encrypt(s: \"et\") == \"ix\")\n\
    assert(encrypt(s: \"faewfawefaewg\") == \"jeiajeaijeiak\")\nassert(encrypt(s:\
    \ \"hellomyfriend\") == \"lippsqcjvmirh\")\nassert(encrypt(s: \"dxzdlmnilfuhmilufhlihufnmlimnufhlimnufhfucufh\"\
    ) == \"hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl\")\nassert(encrypt(s: \"\
    a\") == \"e\")"
  status: Exception
  stderr: 'tmp3kp9tqki/tmp3kp9tqki.swift:46: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002ba162c02c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002ba1628f9b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002ba1628f9988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002ba1628f87b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmp3kp9tqki                        0x00005575d437af0e <unavailable> + 7950

    5    libc.so.6                          0x00002ba162dee460 __libc_start_main +
    245

    6    tmp3kp9tqki                        0x00005575d437a709 <unavailable> + 5897

    '
  stdout: ''
  timestamp: 1660028312
- exit_code: 1
  program: "\n/// Create a function encrypt that takes a string as an argument and\n\
    /// returns a string encrypted with the alphabet being rotated. \n/// The alphabet\
    \ should be rotated in a manner such that the letters \n/// shift down by two\
    \ multiplied to two places.\n/// For example:\n/// >>> encrypt(s: \"hi\")\n///\
    \ \"lm\"\n/// >>> encrypt(s: \"asdfghjkl\")\n/// \"ewhjklnop\"\n/// >>> encrypt(s:\
    \ \"gf\")\n/// \"kj\"\n/// >>> encrypt(s: \"et\")\n/// \"ix\"\nfunc encrypt(s:\
    \ String) -> String {\n  var plaintext = s\n  var ciphertext = \"\"\n  while plaintext.count\
    \ > 0 {\n    let range = plaintext.index(plaintext.startIndex, offsetBy: 2)..<plaintext.endIndex\n\
    \    let substring = plaintext[range]\n    plaintext = String(plaintext.prefix(2))\n\
    \    ciphertext += Array(substring).map { encrypt(String($0)) }.joined()\n  }\n\
    \  return ciphertext\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(encrypt(s:\
    \ \"hi\") == \"lm\")\nassert(encrypt(s: \"asdfghjkl\") == \"ewhjklnop\")\nassert(encrypt(s:\
    \ \"gf\") == \"kj\")\nassert(encrypt(s: \"et\") == \"ix\")\nassert(encrypt(s:\
    \ \"faewfawefaewg\") == \"jeiajeaijeiak\")\nassert(encrypt(s: \"hellomyfriend\"\
    ) == \"lippsqcjvmirh\")\nassert(encrypt(s: \"dxzdlmnilfuhmilufhlihufnmlimnufhlimnufhfucufh\"\
    ) == \"hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl\")\nassert(encrypt(s: \"\
    a\") == \"e\")"
  status: SyntaxError
  stderr: "/tmp/tmpzq84kike.swift:22:50: error: missing argument label 's:' in call\n\
    \    ciphertext += Array(substring).map { encrypt(String($0)) }.joined()\n   \
    \                                              ^\n                           \
    \                      s: \n"
  stdout: ''
  timestamp: 1660028312
- exit_code: 1
  program: "\n/// Create a function encrypt that takes a string as an argument and\n\
    /// returns a string encrypted with the alphabet being rotated. \n/// The alphabet\
    \ should be rotated in a manner such that the letters \n/// shift down by two\
    \ multiplied to two places.\n/// For example:\n/// >>> encrypt(s: \"hi\")\n///\
    \ \"lm\"\n/// >>> encrypt(s: \"asdfghjkl\")\n/// \"ewhjklnop\"\n/// >>> encrypt(s:\
    \ \"gf\")\n/// \"kj\"\n/// >>> encrypt(s: \"et\")\n/// \"ix\"\nfunc encrypt(s:\
    \ String) -> String {\n    let decoded = s.map { decryptChar(ch: $0) }\n    return\
    \ decoded.joined()\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) ->\
    \ Bool {\n    if left.count != right.count {\n        return false\n    }\n  \
    \  for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(encrypt(s: \"hi\"\
    ) == \"lm\")\nassert(encrypt(s: \"asdfghjkl\") == \"ewhjklnop\")\nassert(encrypt(s:\
    \ \"gf\") == \"kj\")\nassert(encrypt(s: \"et\") == \"ix\")\nassert(encrypt(s:\
    \ \"faewfawefaewg\") == \"jeiajeaijeiak\")\nassert(encrypt(s: \"hellomyfriend\"\
    ) == \"lippsqcjvmirh\")\nassert(encrypt(s: \"dxzdlmnilfuhmilufhlihufnmlimnufhlimnufhfucufh\"\
    ) == \"hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl\")\nassert(encrypt(s: \"\
    a\") == \"e\")"
  status: SyntaxError
  stderr: "/tmp/tmpctsdykhi.swift:16:27: error: cannot find 'decryptChar' in scope\n\
    \    let decoded = s.map { decryptChar(ch: $0) }\n                          ^~~~~~~~~~~\n"
  stdout: ''
  timestamp: 1660028312
- exit_code: -4
  program: "\n/// Create a function encrypt that takes a string as an argument and\n\
    /// returns a string encrypted with the alphabet being rotated. \n/// The alphabet\
    \ should be rotated in a manner such that the letters \n/// shift down by two\
    \ multiplied to two places.\n/// For example:\n/// >>> encrypt(s: \"hi\")\n///\
    \ \"lm\"\n/// >>> encrypt(s: \"asdfghjkl\")\n/// \"ewhjklnop\"\n/// >>> encrypt(s:\
    \ \"gf\")\n/// \"kj\"\n/// >>> encrypt(s: \"et\")\n/// \"ix\"\nfunc encrypt(s:\
    \ String) -> String {\n    // your code here\n    return \"\"\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(encrypt(s: \"hi\") == \"lm\")\nassert(encrypt(s: \"asdfghjkl\"\
    ) == \"ewhjklnop\")\nassert(encrypt(s: \"gf\") == \"kj\")\nassert(encrypt(s: \"\
    et\") == \"ix\")\nassert(encrypt(s: \"faewfawefaewg\") == \"jeiajeaijeiak\")\n\
    assert(encrypt(s: \"hellomyfriend\") == \"lippsqcjvmirh\")\nassert(encrypt(s:\
    \ \"dxzdlmnilfuhmilufhlihufnmlimnufhlimnufhfucufh\") == \"hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl\"\
    )\nassert(encrypt(s: \"a\") == \"e\")"
  status: Exception
  stderr: 'tmprx16si5i/tmprx16si5i.swift:33: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b5d5168dc80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b5d51384b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b5d51384988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b5d513837b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmprx16si5i                        0x00005591330b6307 <unavailable> + 4871

    5    libc.so.6                          0x00002b5d51879460 __libc_start_main +
    245

    6    tmprx16si5i                        0x00005591330b5f49 <unavailable> + 3913

    '
  stdout: ''
  timestamp: 1660028310
- exit_code: -4
  program: "\n/// Create a function encrypt that takes a string as an argument and\n\
    /// returns a string encrypted with the alphabet being rotated. \n/// The alphabet\
    \ should be rotated in a manner such that the letters \n/// shift down by two\
    \ multiplied to two places.\n/// For example:\n/// >>> encrypt(s: \"hi\")\n///\
    \ \"lm\"\n/// >>> encrypt(s: \"asdfghjkl\")\n/// \"ewhjklnop\"\n/// >>> encrypt(s:\
    \ \"gf\")\n/// \"kj\"\n/// >>> encrypt(s: \"et\")\n/// \"ix\"\nfunc encrypt(s:\
    \ String) -> String {\n    // implement your code here\n    return \"\"\n}\n\n\
    \nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(encrypt(s: \"hi\") == \"lm\")\nassert(encrypt(s:\
    \ \"asdfghjkl\") == \"ewhjklnop\")\nassert(encrypt(s: \"gf\") == \"kj\")\nassert(encrypt(s:\
    \ \"et\") == \"ix\")\nassert(encrypt(s: \"faewfawefaewg\") == \"jeiajeaijeiak\"\
    )\nassert(encrypt(s: \"hellomyfriend\") == \"lippsqcjvmirh\")\nassert(encrypt(s:\
    \ \"dxzdlmnilfuhmilufhlihufnmlimnufhlimnufhfucufh\") == \"hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl\"\
    )\nassert(encrypt(s: \"a\") == \"e\")"
  status: Exception
  stderr: 'tmpk4wrtejv/tmpk4wrtejv.swift:33: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b091a5e5c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b091a2dcb6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b091a2dc988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b091a2db7b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpk4wrtejv                        0x000055bda7a19307 <unavailable> + 4871

    5    libc.so.6                          0x00002b091a7d1460 __libc_start_main +
    245

    6    tmpk4wrtejv                        0x000055bda7a18f49 <unavailable> + 3913

    '
  stdout: ''
  timestamp: 1660028312
- exit_code: 1
  program: "\n/// Create a function encrypt that takes a string as an argument and\n\
    /// returns a string encrypted with the alphabet being rotated. \n/// The alphabet\
    \ should be rotated in a manner such that the letters \n/// shift down by two\
    \ multiplied to two places.\n/// For example:\n/// >>> encrypt(s: \"hi\")\n///\
    \ \"lm\"\n/// >>> encrypt(s: \"asdfghjkl\")\n/// \"ewhjklnop\"\n/// >>> encrypt(s:\
    \ \"gf\")\n/// \"kj\"\n/// >>> encrypt(s: \"et\")\n/// \"ix\"\nfunc encrypt(s:\
    \ String) -> String {\n    //return String(s.map { String($0).unicodeScalars.first!\
    \ + 2 * 2 })\n    // return String(s.map { String($0).unicodeScalars.first! +\
    \ 2 * 2 })\n    return String(s.map { $0 + 2 * 2 })\n}\n\n\nfunc ==(left: [(Int,\
    \ Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n\
    \        return false\n    }\n    for (l, r) in zip(left, right) {\n        if\
    \ l != r {\n            return false\n        }\n    }\n    return true\n}\n \
    \           \nassert(encrypt(s: \"hi\") == \"lm\")\nassert(encrypt(s: \"asdfghjkl\"\
    ) == \"ewhjklnop\")\nassert(encrypt(s: \"gf\") == \"kj\")\nassert(encrypt(s: \"\
    et\") == \"ix\")\nassert(encrypt(s: \"faewfawefaewg\") == \"jeiajeaijeiak\")\n\
    assert(encrypt(s: \"hellomyfriend\") == \"lippsqcjvmirh\")\nassert(encrypt(s:\
    \ \"dxzdlmnilfuhmilufhlihufnmlimnufhlimnufhfucufh\") == \"hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl\"\
    )\nassert(encrypt(s: \"a\") == \"e\")"
  status: SyntaxError
  stderr: "/tmp/tmp1vp7c5oy.swift:18:12: error: no exact matches in call to initializer\
    \ \n    return String(s.map { $0 + 2 * 2 })\n           ^\n/tmp/tmp1vp7c5oy.swift:18:12:\
    \ note: found candidate with type '([Int]) -> String'\n    return String(s.map\
    \ { $0 + 2 * 2 })\n           ^\n/tmp/tmp1vp7c5oy.swift:18:12: note: candidate\
    \ expects value of type '[Int]' for parameter #1 (got '[Int]')\n    return String(s.map\
    \ { $0 + 2 * 2 })\n           ^\n/tmp/tmp1vp7c5oy.swift:18:12: note: candidate\
    \ expects value of type '[Int]' for parameter #1 (got '[Int]')\n    return String(s.map\
    \ { $0 + 2 * 2 })\n           ^\n/tmp/tmp1vp7c5oy.swift:18:12: note: candidate\
    \ expects value of type '[Int]' for parameter #1 (got '[Int]')\n    return String(s.map\
    \ { $0 + 2 * 2 })\n           ^\n/tmp/tmp1vp7c5oy.swift:18:27: error: cannot convert\
    \ value of type 'String.Element' (aka 'Character') to expected argument type 'Int'\n\
    \    return String(s.map { $0 + 2 * 2 })\n                          ^\n"
  stdout: ''
  timestamp: 1660028315
- exit_code: -4
  program: "\n/// Create a function encrypt that takes a string as an argument and\n\
    /// returns a string encrypted with the alphabet being rotated. \n/// The alphabet\
    \ should be rotated in a manner such that the letters \n/// shift down by two\
    \ multiplied to two places.\n/// For example:\n/// >>> encrypt(s: \"hi\")\n///\
    \ \"lm\"\n/// >>> encrypt(s: \"asdfghjkl\")\n/// \"ewhjklnop\"\n/// >>> encrypt(s:\
    \ \"gf\")\n/// \"kj\"\n/// >>> encrypt(s: \"et\")\n/// \"ix\"\nfunc encrypt(s:\
    \ String) -> String {\n    var result = \"\"\n    let uppercase = Array(\"ABCDEFGHIJKLMNOPQRSTUVWXYZ\"\
    )\n    let lowercase = Array(\"abcdefghijklmnopqrstuvwxyz\")\n    for c in s {\n\
    \        if let cIndex = uppercase.firstIndex(of: c) {\n            result.append(uppercase[(cIndex\
    \ + 2) % uppercase.count])\n        } else if let cIndex = lowercase.firstIndex(of:\
    \ c) {\n            result.append(lowercase[(cIndex + 2) % lowercase.count])\n\
    \        } else {\n            result.append(c)\n        }\n    }\n    return\
    \ result\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n\
    \    if left.count != right.count {\n        return false\n    }\n    for (l,\
    \ r) in zip(left, right) {\n        if l != r {\n            return false\n  \
    \      }\n    }\n    return true\n}\n            \nassert(encrypt(s: \"hi\") ==\
    \ \"lm\")\nassert(encrypt(s: \"asdfghjkl\") == \"ewhjklnop\")\nassert(encrypt(s:\
    \ \"gf\") == \"kj\")\nassert(encrypt(s: \"et\") == \"ix\")\nassert(encrypt(s:\
    \ \"faewfawefaewg\") == \"jeiajeaijeiak\")\nassert(encrypt(s: \"hellomyfriend\"\
    ) == \"lippsqcjvmirh\")\nassert(encrypt(s: \"dxzdlmnilfuhmilufhlihufnmlimnufhlimnufhfucufh\"\
    ) == \"hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl\")\nassert(encrypt(s: \"\
    a\") == \"e\")"
  status: Exception
  stderr: 'tmp0rah0b45/tmp0rah0b45.swift:44: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b8d4730bc80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b8d47002b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b8d47002988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b8d470017b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmp0rah0b45                        0x000056054e87c757 <unavailable> + 5975

    5    libc.so.6                          0x00002b8d474f7460 __libc_start_main +
    245

    6    tmp0rah0b45                        0x000056054e87c399 <unavailable> + 5017

    '
  stdout: ''
  timestamp: 1660028312
- exit_code: 0
  program: "\n/// Create a function encrypt that takes a string as an argument and\n\
    /// returns a string encrypted with the alphabet being rotated. \n/// The alphabet\
    \ should be rotated in a manner such that the letters \n/// shift down by two\
    \ multiplied to two places.\n/// For example:\n/// >>> encrypt(s: \"hi\")\n///\
    \ \"lm\"\n/// >>> encrypt(s: \"asdfghjkl\")\n/// \"ewhjklnop\"\n/// >>> encrypt(s:\
    \ \"gf\")\n/// \"kj\"\n/// >>> encrypt(s: \"et\")\n/// \"ix\"\nfunc encrypt(s:\
    \ String) -> String {\n    let alphabet = Array(\"abcdefghijklmnopqrstuvwxyz\"\
    )\n    var encrypted: String = \"\"\n    for letter in s {\n        if let index\
    \ = alphabet.firstIndex(of: letter) {\n            encrypted.append(alphabet[(index\
    \ + 2 * 2) % alphabet.count])\n        }\n    }\n    return encrypted\n}\n\n\n\
    func ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(encrypt(s: \"hi\") == \"lm\")\nassert(encrypt(s:\
    \ \"asdfghjkl\") == \"ewhjklnop\")\nassert(encrypt(s: \"gf\") == \"kj\")\nassert(encrypt(s:\
    \ \"et\") == \"ix\")\nassert(encrypt(s: \"faewfawefaewg\") == \"jeiajeaijeiak\"\
    )\nassert(encrypt(s: \"hellomyfriend\") == \"lippsqcjvmirh\")\nassert(encrypt(s:\
    \ \"dxzdlmnilfuhmilufhlihufnmlimnufhlimnufhfucufh\") == \"hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl\"\
    )\nassert(encrypt(s: \"a\") == \"e\")"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660028312
- exit_code: 1
  program: "\n/// Create a function encrypt that takes a string as an argument and\n\
    /// returns a string encrypted with the alphabet being rotated. \n/// The alphabet\
    \ should be rotated in a manner such that the letters \n/// shift down by two\
    \ multiplied to two places.\n/// For example:\n/// >>> encrypt(s: \"hi\")\n///\
    \ \"lm\"\n/// >>> encrypt(s: \"asdfghjkl\")\n/// \"ewhjklnop\"\n/// >>> encrypt(s:\
    \ \"gf\")\n/// \"kj\"\n/// >>> encrypt(s: \"et\")\n/// \"ix\"\nfunc encrypt(s:\
    \ String) -> String {\n    var result = \"\"\n    for char in s {\n        let\
    \ charIndex = char.asciiValue!\n        let newChar = charIndex + ( 2 * 2 )\n\
    \        let encryptedChar = UnicodeScalar(newChar)!\n        result += String(encryptedChar)\n\
    \    }\n    return result\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(encrypt(s:\
    \ \"hi\") == \"lm\")\nassert(encrypt(s: \"asdfghjkl\") == \"ewhjklnop\")\nassert(encrypt(s:\
    \ \"gf\") == \"kj\")\nassert(encrypt(s: \"et\") == \"ix\")\nassert(encrypt(s:\
    \ \"faewfawefaewg\") == \"jeiajeaijeiak\")\nassert(encrypt(s: \"hellomyfriend\"\
    ) == \"lippsqcjvmirh\")\nassert(encrypt(s: \"dxzdlmnilfuhmilufhlihufnmlimnufhlimnufhfucufh\"\
    ) == \"hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl\")\nassert(encrypt(s: \"\
    a\") == \"e\")"
  status: SyntaxError
  stderr: "/tmp/tmp_lepen_5.swift:20:51: error: cannot force unwrap value of non-optional\
    \ type 'UnicodeScalar' (aka 'Unicode.Scalar')\n        let encryptedChar = UnicodeScalar(newChar)!\n\
    \                            ~~~~~~~~~~~~~~~~~~~~~~^\n                       \
    \                           \n"
  stdout: ''
  timestamp: 1660028312
- exit_code: -4
  program: "\n/// Create a function encrypt that takes a string as an argument and\n\
    /// returns a string encrypted with the alphabet being rotated. \n/// The alphabet\
    \ should be rotated in a manner such that the letters \n/// shift down by two\
    \ multiplied to two places.\n/// For example:\n/// >>> encrypt(s: \"hi\")\n///\
    \ \"lm\"\n/// >>> encrypt(s: \"asdfghjkl\")\n/// \"ewhjklnop\"\n/// >>> encrypt(s:\
    \ \"gf\")\n/// \"kj\"\n/// >>> encrypt(s: \"et\")\n/// \"ix\"\nfunc encrypt(s:\
    \ String) -> String {\n    return \"\"\n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(encrypt(s: \"hi\") == \"lm\")\nassert(encrypt(s: \"asdfghjkl\") == \"ewhjklnop\"\
    )\nassert(encrypt(s: \"gf\") == \"kj\")\nassert(encrypt(s: \"et\") == \"ix\")\n\
    assert(encrypt(s: \"faewfawefaewg\") == \"jeiajeaijeiak\")\nassert(encrypt(s:\
    \ \"hellomyfriend\") == \"lippsqcjvmirh\")\nassert(encrypt(s: \"dxzdlmnilfuhmilufhlihufnmlimnufhlimnufhfucufh\"\
    ) == \"hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl\")\nassert(encrypt(s: \"\
    a\") == \"e\")"
  status: Exception
  stderr: 'tmpxsqxg1op/tmpxsqxg1op.swift:32: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b607b4a6c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b607b19db6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b607b19d988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b607b19c7b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpxsqxg1op                        0x00005575dd252307 <unavailable> + 4871

    5    libc.so.6                          0x00002b607b692460 __libc_start_main +
    245

    6    tmpxsqxg1op                        0x00005575dd251f49 <unavailable> + 3913

    '
  stdout: ''
  timestamp: 1660028310
- exit_code: 1
  program: "\n/// Create a function encrypt that takes a string as an argument and\n\
    /// returns a string encrypted with the alphabet being rotated. \n/// The alphabet\
    \ should be rotated in a manner such that the letters \n/// shift down by two\
    \ multiplied to two places.\n/// For example:\n/// >>> encrypt(s: \"hi\")\n///\
    \ \"lm\"\n/// >>> encrypt(s: \"asdfghjkl\")\n/// \"ewhjklnop\"\n/// >>> encrypt(s:\
    \ \"gf\")\n/// \"kj\"\n/// >>> encrypt(s: \"et\")\n/// \"ix\"\nfunc encrypt(s:\
    \ String) -> String {\n    return String(s.map { (c) -> Character in\n       \
    \ if let i = unicodeScalars.firstIndex(of: c) {\n            let newIndex = (i\
    \ + 2 * 2) % unicodeScalars.count\n            return unicodeScalars[newIndex]\n\
    \        }\n        return c\n    })\n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(encrypt(s: \"hi\") == \"lm\")\nassert(encrypt(s: \"asdfghjkl\") == \"ewhjklnop\"\
    )\nassert(encrypt(s: \"gf\") == \"kj\")\nassert(encrypt(s: \"et\") == \"ix\")\n\
    assert(encrypt(s: \"faewfawefaewg\") == \"jeiajeaijeiak\")\nassert(encrypt(s:\
    \ \"hellomyfriend\") == \"lippsqcjvmirh\")\nassert(encrypt(s: \"dxzdlmnilfuhmilufhlihufnmlimnufhlimnufhfucufh\"\
    ) == \"hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl\")\nassert(encrypt(s: \"\
    a\") == \"e\")"
  status: SyntaxError
  stderr: "/tmp/tmp3hgomvq6.swift:17:20: error: cannot find 'unicodeScalars' in scope\n\
    \        if let i = unicodeScalars.firstIndex(of: c) {\n                   ^~~~~~~~~~~~~~\n\
    /tmp/tmp3hgomvq6.swift:18:42: error: cannot find 'unicodeScalars' in scope\n \
    \           let newIndex = (i + 2 * 2) % unicodeScalars.count\n              \
    \                           ^~~~~~~~~~~~~~\n/tmp/tmp3hgomvq6.swift:19:20: error:\
    \ cannot find 'unicodeScalars' in scope\n            return unicodeScalars[newIndex]\n\
    \                   ^~~~~~~~~~~~~~\n"
  stdout: ''
  timestamp: 1660028312
- exit_code: 1
  program: "\n/// Create a function encrypt that takes a string as an argument and\n\
    /// returns a string encrypted with the alphabet being rotated. \n/// The alphabet\
    \ should be rotated in a manner such that the letters \n/// shift down by two\
    \ multiplied to two places.\n/// For example:\n/// >>> encrypt(s: \"hi\")\n///\
    \ \"lm\"\n/// >>> encrypt(s: \"asdfghjkl\")\n/// \"ewhjklnop\"\n/// >>> encrypt(s:\
    \ \"gf\")\n/// \"kj\"\n/// >>> encrypt(s: \"et\")\n/// \"ix\"\nfunc encrypt(s:\
    \ String) -> String {\n    var encryptedString = \"\"\n    for char in s {\n \
    \       encryptedString += String(UnicodeScalar(UInt8(char.asciiValue!) + 2 *\
    \ 2)!)\n    }\n    return encryptedString\n}\n\n\nfunc ==(left: [(Int, Int)],\
    \ right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n       \
    \ return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r\
    \ {\n            return false\n        }\n    }\n    return true\n}\n        \
    \    \nassert(encrypt(s: \"hi\") == \"lm\")\nassert(encrypt(s: \"asdfghjkl\")\
    \ == \"ewhjklnop\")\nassert(encrypt(s: \"gf\") == \"kj\")\nassert(encrypt(s: \"\
    et\") == \"ix\")\nassert(encrypt(s: \"faewfawefaewg\") == \"jeiajeaijeiak\")\n\
    assert(encrypt(s: \"hellomyfriend\") == \"lippsqcjvmirh\")\nassert(encrypt(s:\
    \ \"dxzdlmnilfuhmilufhlihufnmlimnufhlimnufhfucufh\") == \"hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl\"\
    )\nassert(encrypt(s: \"a\") == \"e\")"
  status: SyntaxError
  stderr: "/tmp/tmpfai1wrnv.swift:18:81: error: cannot force unwrap value of non-optional\
    \ type 'UnicodeScalar' (aka 'Unicode.Scalar')\n        encryptedString += String(UnicodeScalar(UInt8(char.asciiValue!)\
    \ + 2 * 2)!)\n                                  ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~^\n\
    \                                                                            \
    \    \n"
  stdout: ''
  timestamp: 1660028314
- exit_code: -4
  program: "\n/// Create a function encrypt that takes a string as an argument and\n\
    /// returns a string encrypted with the alphabet being rotated. \n/// The alphabet\
    \ should be rotated in a manner such that the letters \n/// shift down by two\
    \ multiplied to two places.\n/// For example:\n/// >>> encrypt(s: \"hi\")\n///\
    \ \"lm\"\n/// >>> encrypt(s: \"asdfghjkl\")\n/// \"ewhjklnop\"\n/// >>> encrypt(s:\
    \ \"gf\")\n/// \"kj\"\n/// >>> encrypt(s: \"et\")\n/// \"ix\"\nfunc encrypt(s:\
    \ String) -> String {\n    //write your code here\n    var result = \"\"\n   \
    \ for char in s {\n        if char >= \"a\" && char <= \"z\" {\n            result\
    \ += String(UnicodeScalar(UInt8(Int(char.asciiValue!) + 2 * 2)))\n        } else\
    \ if char >= \"A\" && char <= \"Z\" {\n            result += String(UnicodeScalar(UInt8(Int(char.asciiValue!)\
    \ + 2 * 2)))\n        } else {\n            result += String(char)\n        }\n\
    \    }\n    return result\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(encrypt(s:\
    \ \"hi\") == \"lm\")\nassert(encrypt(s: \"asdfghjkl\") == \"ewhjklnop\")\nassert(encrypt(s:\
    \ \"gf\") == \"kj\")\nassert(encrypt(s: \"et\") == \"ix\")\nassert(encrypt(s:\
    \ \"faewfawefaewg\") == \"jeiajeaijeiak\")\nassert(encrypt(s: \"hellomyfriend\"\
    ) == \"lippsqcjvmirh\")\nassert(encrypt(s: \"dxzdlmnilfuhmilufhlihufnmlimnufhlimnufhfucufh\"\
    ) == \"hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl\")\nassert(encrypt(s: \"\
    a\") == \"e\")"
  status: Exception
  stderr: 'tmp9pz4u7ua/tmp9pz4u7ua.swift:47: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b0ed0bdac80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b0ed08d1b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b0ed08d1988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b0ed08d07b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmp9pz4u7ua                        0x000056087f06cede <unavailable> + 7902

    5    libc.so.6                          0x00002b0ed0dc6460 __libc_start_main +
    245

    6    tmp9pz4u7ua                        0x000056087f06c6d9 <unavailable> + 5849

    '
  stdout: ''
  timestamp: 1660028312
- exit_code: -4
  program: "\n/// Create a function encrypt that takes a string as an argument and\n\
    /// returns a string encrypted with the alphabet being rotated. \n/// The alphabet\
    \ should be rotated in a manner such that the letters \n/// shift down by two\
    \ multiplied to two places.\n/// For example:\n/// >>> encrypt(s: \"hi\")\n///\
    \ \"lm\"\n/// >>> encrypt(s: \"asdfghjkl\")\n/// \"ewhjklnop\"\n/// >>> encrypt(s:\
    \ \"gf\")\n/// \"kj\"\n/// >>> encrypt(s: \"et\")\n/// \"ix\"\nfunc encrypt(s:\
    \ String) -> String {\n    var encryptedString = \"\"\n    for letter in s {\n\
    \        switch letter {\n        case \"a\"...\"w\":\n            encryptedString.append(Character(UnicodeScalar(Int(letter.asciiValue!)\
    \ + 2 * 2)!))\n        case \"x\"...\"z\":\n            encryptedString.append(Character(UnicodeScalar(Int(letter.asciiValue!)\
    \ - 24)!))\n        default:\n            encryptedString.append(letter)\n   \
    \     }\n    }\n    return encryptedString\n}\n\n\nfunc ==(left: [(Int, Int)],\
    \ right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n       \
    \ return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r\
    \ {\n            return false\n        }\n    }\n    return true\n}\n        \
    \    \nassert(encrypt(s: \"hi\") == \"lm\")\nassert(encrypt(s: \"asdfghjkl\")\
    \ == \"ewhjklnop\")\nassert(encrypt(s: \"gf\") == \"kj\")\nassert(encrypt(s: \"\
    et\") == \"ix\")\nassert(encrypt(s: \"faewfawefaewg\") == \"jeiajeaijeiak\")\n\
    assert(encrypt(s: \"hellomyfriend\") == \"lippsqcjvmirh\")\nassert(encrypt(s:\
    \ \"dxzdlmnilfuhmilufhlihufnmlimnufhlimnufhfucufh\") == \"hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl\"\
    )\nassert(encrypt(s: \"a\") == \"e\")"
  status: Exception
  stderr: 'tmpc8wy2z7c/tmpc8wy2z7c.swift:47: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002ae7cf219c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002ae7cef10b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002ae7cef10988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002ae7cef0f7b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpc8wy2z7c                        0x0000560397b4ed0e <unavailable> + 7438

    5    libc.so.6                          0x00002ae7cf405460 __libc_start_main +
    245

    6    tmpc8wy2z7c                        0x0000560397b4e509 <unavailable> + 5385

    '
  stdout: ''
  timestamp: 1660028312
- exit_code: -4
  program: "\n/// Create a function encrypt that takes a string as an argument and\n\
    /// returns a string encrypted with the alphabet being rotated. \n/// The alphabet\
    \ should be rotated in a manner such that the letters \n/// shift down by two\
    \ multiplied to two places.\n/// For example:\n/// >>> encrypt(s: \"hi\")\n///\
    \ \"lm\"\n/// >>> encrypt(s: \"asdfghjkl\")\n/// \"ewhjklnop\"\n/// >>> encrypt(s:\
    \ \"gf\")\n/// \"kj\"\n/// >>> encrypt(s: \"et\")\n/// \"ix\"\nfunc encrypt(s:\
    \ String) -> String {\n    \n    let letters = \"abcdefghijklmnopqrstuvwxyz\"\n\
    \    var newLetters = \"\"\n    var encrypted = \"\"\n    \n    // Create a new\
    \ alphabet, shifting down two multiplied by two places.\n    for char in letters\
    \ {\n        if let charIndex = letters.index(of: char) {\n            let newCharIndex\
    \ = letters.index(charIndex, offsetBy: (letters.count / 2) * 2)\n            newLetters.append(letters[newCharIndex])\n\
    \        }\n    }\n    \n    // Substitute the new letters into the original string.\n\
    \    for char in s {\n        if let charIndex = letters.index(of: char) {\n \
    \           encrypted.append(newLetters[charIndex])\n        }\n    }\n    \n\
    \    return encrypted\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(encrypt(s:\
    \ \"hi\") == \"lm\")\nassert(encrypt(s: \"asdfghjkl\") == \"ewhjklnop\")\nassert(encrypt(s:\
    \ \"gf\") == \"kj\")\nassert(encrypt(s: \"et\") == \"ix\")\nassert(encrypt(s:\
    \ \"faewfawefaewg\") == \"jeiajeaijeiak\")\nassert(encrypt(s: \"hellomyfriend\"\
    ) == \"lippsqcjvmirh\")\nassert(encrypt(s: \"dxzdlmnilfuhmilufhlihufnmlimnufhlimnufhfucufh\"\
    ) == \"hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl\")\nassert(encrypt(s: \"\
    a\") == \"e\")"
  status: Exception
  stderr: 'Swift/StringIndexValidation.swift:120: Fatal error: String index is out
    of bounds

    Current stack trace:

    0    libswiftCore.so                    0x00002b0f6706cc80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b0f66d63561 <unavailable> + 1434977

    2    libswiftCore.so                    0x00002b0f66d63286 <unavailable> + 1434246

    3    libswiftCore.so                    0x00002b0f66d6313c <unavailable> + 1433916

    4    libswiftCore.so                    0x00002b0f66d62bb0 _assertionFailure(_:_:file:line:flags:)
    + 251

    5    libswiftCore.so                    0x00002b0f66e96ec2 <unavailable> + 2694850

    6    libswiftCore.so                    0x00002b0f66e4f660 String.subscript.getter
    + 34

    7    tmpvm3e16qd                        0x000055f388c861ce <unavailable> + 8654

    8    tmpvm3e16qd                        0x000055f388c85606 <unavailable> + 5638

    9    libc.so.6                          0x00002b0f67258460 __libc_start_main +
    245

    10   tmpvm3e16qd                        0x000055f388c85309 <unavailable> + 4873

    '
  stdout: ''
  timestamp: 1660028312
- exit_code: -4
  program: "\n/// Create a function encrypt that takes a string as an argument and\n\
    /// returns a string encrypted with the alphabet being rotated. \n/// The alphabet\
    \ should be rotated in a manner such that the letters \n/// shift down by two\
    \ multiplied to two places.\n/// For example:\n/// >>> encrypt(s: \"hi\")\n///\
    \ \"lm\"\n/// >>> encrypt(s: \"asdfghjkl\")\n/// \"ewhjklnop\"\n/// >>> encrypt(s:\
    \ \"gf\")\n/// \"kj\"\n/// >>> encrypt(s: \"et\")\n/// \"ix\"\nfunc encrypt(s:\
    \ String) -> String {\n    return \"\"\n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(encrypt(s: \"hi\") == \"lm\")\nassert(encrypt(s: \"asdfghjkl\") == \"ewhjklnop\"\
    )\nassert(encrypt(s: \"gf\") == \"kj\")\nassert(encrypt(s: \"et\") == \"ix\")\n\
    assert(encrypt(s: \"faewfawefaewg\") == \"jeiajeaijeiak\")\nassert(encrypt(s:\
    \ \"hellomyfriend\") == \"lippsqcjvmirh\")\nassert(encrypt(s: \"dxzdlmnilfuhmilufhlihufnmlimnufhlimnufhfucufh\"\
    ) == \"hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl\")\nassert(encrypt(s: \"\
    a\") == \"e\")"
  status: Exception
  stderr: 'tmpxsqxg1op/tmpxsqxg1op.swift:32: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b607b4a6c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b607b19db6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b607b19d988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b607b19c7b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpxsqxg1op                        0x00005575dd252307 <unavailable> + 4871

    5    libc.so.6                          0x00002b607b692460 __libc_start_main +
    245

    6    tmpxsqxg1op                        0x00005575dd251f49 <unavailable> + 3913

    '
  stdout: ''
  timestamp: 1660028310
- exit_code: -4
  program: "\n/// Create a function encrypt that takes a string as an argument and\n\
    /// returns a string encrypted with the alphabet being rotated. \n/// The alphabet\
    \ should be rotated in a manner such that the letters \n/// shift down by two\
    \ multiplied to two places.\n/// For example:\n/// >>> encrypt(s: \"hi\")\n///\
    \ \"lm\"\n/// >>> encrypt(s: \"asdfghjkl\")\n/// \"ewhjklnop\"\n/// >>> encrypt(s:\
    \ \"gf\")\n/// \"kj\"\n/// >>> encrypt(s: \"et\")\n/// \"ix\"\nfunc encrypt(s:\
    \ String) -> String {\n    // This function does not work for some unknown reason.\n\
    \    // The instructions on the website are vague and I am \n    // unsure of\
    \ the correct solution.\n    // I have attempted to solve this problem by using\n\
    \    // a for loop that adds 2 to the value at each index\n    // of the string.\
    \ The resultant character is then appended\n    // to the returned string.\n \
    \   var n = \"\"\n    for i in s {\n        let index = s.index(of: i)\n     \
    \   if let index = index {\n            let index = s.distance(from: s.startIndex,\
    \ to: index)\n            let t = s[s.index(s.startIndex, offsetBy: index)]\n\
    \            let v = Int(t.asciiValue!)\n            let c = v + 2\n         \
    \   let d = Character(UnicodeScalar(c)!)\n            n.append(d)\n        }\n\
    \    }\n    return n\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(encrypt(s:\
    \ \"hi\") == \"lm\")\nassert(encrypt(s: \"asdfghjkl\") == \"ewhjklnop\")\nassert(encrypt(s:\
    \ \"gf\") == \"kj\")\nassert(encrypt(s: \"et\") == \"ix\")\nassert(encrypt(s:\
    \ \"faewfawefaewg\") == \"jeiajeaijeiak\")\nassert(encrypt(s: \"hellomyfriend\"\
    ) == \"lippsqcjvmirh\")\nassert(encrypt(s: \"dxzdlmnilfuhmilufhlihufnmlimnufhlimnufhfucufh\"\
    ) == \"hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl\")\nassert(encrypt(s: \"\
    a\") == \"e\")"
  status: Exception
  stderr: 'tmpsfs9nlaa/tmpsfs9nlaa.swift:51: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002ae0ad9cac80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002ae0ad6c1b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002ae0ad6c1988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002ae0ad6c07b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpsfs9nlaa                        0x000056102da729e7 <unavailable> + 6631

    5    libc.so.6                          0x00002ae0adbb6460 __libc_start_main +
    245

    6    tmpsfs9nlaa                        0x000056102da72629 <unavailable> + 5673

    '
  stdout: ''
  timestamp: 1660028312
- exit_code: -4
  program: "\n/// Create a function encrypt that takes a string as an argument and\n\
    /// returns a string encrypted with the alphabet being rotated. \n/// The alphabet\
    \ should be rotated in a manner such that the letters \n/// shift down by two\
    \ multiplied to two places.\n/// For example:\n/// >>> encrypt(s: \"hi\")\n///\
    \ \"lm\"\n/// >>> encrypt(s: \"asdfghjkl\")\n/// \"ewhjklnop\"\n/// >>> encrypt(s:\
    \ \"gf\")\n/// \"kj\"\n/// >>> encrypt(s: \"et\")\n/// \"ix\"\nfunc encrypt(s:\
    \ String) -> String {\n    let alphabet = \"abcdefghijklmnopqrstuvwxyz\"\n   \
    \ var encryptedString = \"\"\n    for c in s {\n        let ascii = c.asciiValue!\n\
    \        let asciiToAlphabet = Int(ascii) - 97\n        var shiftAscii = asciiToAlphabet\
    \ + 2\n        if shiftAscii >= 26 {\n            shiftAscii -= 26\n        }\n\
    \        let shiftAsciiToChar = Character(UnicodeScalar(shiftAscii + 97)!)\n \
    \       encryptedString.append(shiftAsciiToChar)\n    }\n    return encryptedString\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(encrypt(s: \"hi\") == \"lm\")\nassert(encrypt(s:\
    \ \"asdfghjkl\") == \"ewhjklnop\")\nassert(encrypt(s: \"gf\") == \"kj\")\nassert(encrypt(s:\
    \ \"et\") == \"ix\")\nassert(encrypt(s: \"faewfawefaewg\") == \"jeiajeaijeiak\"\
    )\nassert(encrypt(s: \"hellomyfriend\") == \"lippsqcjvmirh\")\nassert(encrypt(s:\
    \ \"dxzdlmnilfuhmilufhlihufnmlimnufhlimnufhfucufh\") == \"hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl\"\
    )\nassert(encrypt(s: \"a\") == \"e\")"
  status: Exception
  stderr: 'tmpc4dp1482/tmpc4dp1482.swift:44: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b49a1dcec80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b49a1ac5b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b49a1ac5988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b49a1ac47b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpc4dp1482                        0x00005617d122c747 <unavailable> + 5959

    5    libc.so.6                          0x00002b49a1fba460 __libc_start_main +
    245

    6    tmpc4dp1482                        0x00005617d122c389 <unavailable> + 5001

    '
  stdout: ''
  timestamp: 1660028312
- exit_code: -4
  program: "\n/// Create a function encrypt that takes a string as an argument and\n\
    /// returns a string encrypted with the alphabet being rotated. \n/// The alphabet\
    \ should be rotated in a manner such that the letters \n/// shift down by two\
    \ multiplied to two places.\n/// For example:\n/// >>> encrypt(s: \"hi\")\n///\
    \ \"lm\"\n/// >>> encrypt(s: \"asdfghjkl\")\n/// \"ewhjklnop\"\n/// >>> encrypt(s:\
    \ \"gf\")\n/// \"kj\"\n/// >>> encrypt(s: \"et\")\n/// \"ix\"\nfunc encrypt(s:\
    \ String) -> String {\n    let alphabet = \"abcdefghijklmnopqrstuvwxyz\"\n   \
    \ let maxIndex = alphabet.count - 1\n    var encryptedString = \"\"\n    for letter\
    \ in s {\n        if let index = alphabet.firstIndex(of: letter) {\n         \
    \   let encryptedIndex = (index.encodedOffset + 2) * 2\n            if encryptedIndex\
    \ > maxIndex {\n                let wrappedIndex = encryptedIndex - maxIndex -\
    \ 1\n                encryptedString.append(alphabet[alphabet.index(alphabet.startIndex,\
    \ offsetBy: wrappedIndex)])\n            } else {\n                encryptedString.append(alphabet[alphabet.index(alphabet.startIndex,\
    \ offsetBy: encryptedIndex)])\n            }\n        }\n    }\n    return encryptedString\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(encrypt(s: \"hi\") == \"lm\")\nassert(encrypt(s:\
    \ \"asdfghjkl\") == \"ewhjklnop\")\nassert(encrypt(s: \"gf\") == \"kj\")\nassert(encrypt(s:\
    \ \"et\") == \"ix\")\nassert(encrypt(s: \"faewfawefaewg\") == \"jeiajeaijeiak\"\
    )\nassert(encrypt(s: \"hellomyfriend\") == \"lippsqcjvmirh\")\nassert(encrypt(s:\
    \ \"dxzdlmnilfuhmilufhlihufnmlimnufhlimnufhfucufh\") == \"hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl\"\
    )\nassert(encrypt(s: \"a\") == \"e\")"
  status: Exception
  stderr: 'tmp707mg8be/tmp707mg8be.swift:46: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b35c318dc80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b35c2e84b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b35c2e84988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b35c2e837b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmp707mg8be                        0x000055ae0be4e707 <unavailable> + 5895

    5    libc.so.6                          0x00002b35c3379460 __libc_start_main +
    245

    6    tmp707mg8be                        0x000055ae0be4e349 <unavailable> + 4937

    '
  stdout: ''
  timestamp: 1660028312
