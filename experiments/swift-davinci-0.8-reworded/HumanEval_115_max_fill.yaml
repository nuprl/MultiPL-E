name: HumanEval_115_max_fill
language: swift
prompt: "\n/// You are given a rectangular grid of wells. Each row represents a single\
  \ well,\n/// and each 1 in a row represents a single unit of water.\n/// Each well\
  \ has a corresponding bucket that can be used to extract water from it, \n/// and\
  \ all buckets have the same capacity.\n/// Your task is to use the buckets to empty\
  \ the wells.\n/// Output the number of times you need to lower the buckets.\n///\
  \ Example 1:\n/// >>> max_fill(grid: [[0, 0, 1, 0], [0, 1, 0, 0], [1, 1, 1, 1]],\
  \ capacity: 1)\n/// 6\n/// Example 2:\n/// >>> max_fill(grid: [[0, 0, 1, 1], [0,\
  \ 0, 0, 0], [1, 1, 1, 1], [0, 1, 1, 1]], capacity: 2)\n/// 5\n/// Example 3:\n///\
  \ >>> max_fill(grid: [[0, 0, 0], [0, 0, 0]], capacity: 5)\n/// 0\n/// Constraints:\n\
  /// * all wells have the same length\n/// * 1 <= grid.length <= 10^2\n/// * 1 <=\
  \ grid[:,1].length <= 10^2\n/// * grid[i][j] -> 0 | 1\n/// * 1 <= capacity <= 10\n\
  func max_fill(grid: [[Int]], capacity: Int) -> Int {\n"
tests: "}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if\
  \ left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left,\
  \ right) {\n        if l != r {\n            return false\n        }\n    }\n  \
  \  return true\n}\n            \nassert(max_fill(grid: [[0, 0, 1, 0], [0, 1, 0,\
  \ 0], [1, 1, 1, 1]], capacity: 1) == 6)\nassert(max_fill(grid: [[0, 0, 1, 1], [0,\
  \ 0, 0, 0], [1, 1, 1, 1], [0, 1, 1, 1]], capacity: 2) == 5)\nassert(max_fill(grid:\
  \ [[0, 0, 0], [0, 0, 0]], capacity: 5) == 0)\nassert(max_fill(grid: [[1, 1, 1, 1],\
  \ [1, 1, 1, 1]], capacity: 2) == 4)\nassert(max_fill(grid: [[1, 1, 1, 1], [1, 1,\
  \ 1, 1]], capacity: 9) == 2)"
completions: ["    var counter = 0\n    let row = grid.count\n    let col = grid[0].count\n\
    \    var rowIndex = 0\n    var colIndex = 0\n    while rowIndex < row {\n    \
    \    if colIndex < col {\n            let bucket = grid[rowIndex][colIndex]\n\
    \            if bucket == 1 {\n                counter += capacity\n         \
    \   }\n            colIndex += 1\n        } else {\n            rowIndex += 1\n\
    \            colIndex = 0\n        }\n    }\n    return counter", "    var newGrid\
    \ = grid\n    var amountOfTimes = 0\n    for i in 0..<grid.count {\n        for\
    \ j in 0..<grid[i].count {\n            if grid[i][j] == 1 {\n               \
    \ amountOfTimes += 1\n                newGrid = pour(grid: newGrid, from: (i,\
    \ j), capacity: capacity)\n            }\n        }\n    }\n    return amountOfTimes",
  '    return 0', '    return 0', '  return 0', "    var water = 0\n    var count\
    \ = 0\n    for i in 0..<grid.count {\n        for j in 0..<grid[i].count {\n \
    \           if grid[i][j] == 1 {\n                water += 1\n            }\n\
    \        }\n    }\n    while water > 0 {\n        count += 1\n        water -=\
    \ capacity\n    }\n    return count", "    var max = 0\n    var grid = grid\n\
    \    var b = Array(repeating: 0, count: grid[0].count)\n    for i in 0..<grid.count\
    \ {\n        for j in 0..<grid[i].count {\n            if grid[i][j] == 1 {\n\
    \                b[j] += 1\n            }\n        }\n    }\n    for j in 0..<b.count\
    \ {\n        max += b[j] / capacity\n        if b[j] % capacity != 0 {\n     \
    \       max += 1\n        }\n    }\n    return max", "    // write your code in\
    \ Swift 4.2.1 (Linux)\n    guard grid.count > 0 && grid[0].count > 0 else {\n\
    \        return 0\n    }\n    var grid = grid\n    var max_fill = 0\n    let rows\
    \ = grid.count\n    let cols = grid[0].count\n    for y in 0..<rows {\n      \
    \  for x in 0..<cols {\n            max_fill += max_fill_recursive(grid: &grid,\
    \ x: x, y: y, capacity: capacity)\n        }\n    }\n    return max_fill", " \
    \   var grid = grid\n    var counter = 0\n    while(true) {\n        var filled\
    \ = true\n        for x in 0..<grid.count {\n            if (grid[x].filter({\
    \ $0 == 1 }).count > 0) {\n                filled = false\n                for\
    \ y in 0..<grid[x].count {\n                    if (grid[x][y] == 1) {\n     \
    \                   grid[x][y] = 0\n                        if ((x + 1) < grid.count)\
    \ {\n                            for bucket_y in y..<min(y + capacity, grid[x\
    \ + 1].count) {\n                                grid[x + 1][bucket_y] = 1\n \
    \                           }\n                        }\n                   \
    \     counter += 1\n                        break\n                    }\n   \
    \             }\n            }\n        }\n        if (filled) {\n           \
    \ break\n        }\n    }\n    return counter", "    var count = 0\n    for i\
    \ in 0..<grid.count {\n        for j in 0..<grid[i].count {\n            count\
    \ += max(grid[i][j] - capacity, 0)\n        }\n    }\n    return count", "   \
    \ var counter = 0\n    var currentCapacity = capacity\n    var length = 0\n  \
    \  var lenghtCounter = 0\n    var rowCounter = 0\n    var maxRow = 0\n    var\
    \ prevRowLength = 0\n    if grid.count == 0 {\n        return 0\n    }\n    if\
    \ grid[0].count == 0 {\n        return 0\n    }\n    for row in grid {\n     \
    \   for item in row {\n            if item == 1 {\n                length += 1\n\
    \            }\n        }\n        if length > lenghtCounter {\n            lenghtCounter\
    \ = length\n            maxRow = rowCounter\n        }\n        rowCounter +=\
    \ 1\n        length = 0\n    }\n    if lenghtCounter == 0 {\n        return 0\n\
    \    }\n    for _ in 0...maxRow {\n        for item in grid[maxRow] {\n      \
    \      if item == 1 {\n                prevRowLength += 1\n            }\n   \
    \     }\n        maxRow -= 1\n    }\n    for _ in 0...prevRowLength - 1 {\n  \
    \      if currentCapacity > 0 {\n            currentCapacity -= 1\n        } else\
    \ {\n            currentCapacity = capacity\n            counter += 1\n      \
    \  }\n    }\n    if currentCapacity == capacity {\n        return counter\n  \
    \  } else {\n        return counter + 1\n    }", "    var filled_grid = grid\n\
    \    let rows = grid.count\n    let cols = grid[0].count\n    var row_index =\
    \ 0\n    var col_index = 0\n    var total_water = 0\n    while row_index < rows\
    \ {\n        col_index = 0\n        while col_index < cols {\n            if filled_grid[row_index][col_index]\
    \ == 1 {\n                total_water += capacity\n                filled_grid[row_index][col_index]\
    \ = 0\n            }\n            col_index += 1\n        }\n        row_index\
    \ += 1\n    }\n    return total_water", "    var result = 0\n    for row in grid\
    \ {\n        var water = 0\n        for i in row {\n            water += i\n \
    \           if water == capacity {\n                result += 1\n            \
    \    water = 0\n            }\n        }\n        if water > 0 {\n           \
    \ result += 1\n        }\n    }\n    return result", "    let totalWater = grid.reduce(0)\
    \ { (sum, row) -> Int in\n        sum + row.reduce(0) { (sum, cell) -> Int in\n\
    \            sum + cell\n        }\n    }\n    guard totalWater > 0 else { return\
    \ 0 }\n    var maxFill = 0\n    for row in grid {\n        maxFill += row.reduce(0)\
    \ { (sum, cell) -> Int in\n            sum + (cell == 1 ? capacity : 0)\n    \
    \    }\n    }\n    return maxFill", "    var depth = 0\n    while depth < capacity\
    \ {\n        depth += 1\n        var highest = 0\n        var well = 0\n     \
    \   for (w, wellVals) in grid.enumerated() {\n            let (height, _) = highest_point(input:\
    \ wellVals, height: depth)\n            if height > highest {\n              \
    \  highest = height\n                well = w\n            }\n        }\n    \
    \    grid[well] = fill_well(input: grid[well], height: depth)\n    }\n    return\
    \ count_filled(input: grid)", "    // 1. find max in each column\n    var maxCol\
    \ = [Int]()\n    for i in 0..<grid[0].count {\n        maxCol.append(grid.map{$0[i]}.max()!)\n\
    \    }\n    // 2. find max in maxCol\n    let maxRow = maxCol.max()!\n    // 3.\
    \ multiply maxRow with number of columns\n    return maxRow * grid[0].count",
  "    var max_level = capacity\n    var min_level = 0\n    while max_level - min_level\
    \ > 1 {\n        let middle = (max_level + min_level) / 2\n        if fit(grid:\
    \ grid, capacity: middle) {\n            min_level = middle\n        } else {\n\
    \            max_level = middle\n        }\n    }\n    return min_level", "\t\
    // Required function.\n\treturn 0", "    guard grid.count > 0 else { return 0\
    \ }\n    guard grid[0].count > 0 else { return 0 }\n    var buckets = [Int]()\n\
    \    let rows = grid.count\n    let columns = grid[0].count\n    for column in\
    \ 0..<columns {\n        buckets.append(0)\n    }\n    var days = 0\n    while\
    \ true {\n        days += 1\n        // fill buckets\n        for row in 0..<rows\
    \ {\n            for column in 0..<columns {\n                if grid[row][column]\
    \ == 1 {\n                    buckets[column] += 1\n                }\n      \
    \      }\n        }\n        // dump buckets\n        for column in 0..<columns\
    \ {\n            for _ in 0..<buckets[column] {\n                for row in 0..<rows\
    \ {\n                    if grid[row][column] == 1 {\n                       \
    \ grid[row][column] = 0\n                        break\n                    }\n\
    \                }\n            }\n            buckets[column] = 0\n        }\n\
    \        if grid.allSatisfy({ $0.allSatisfy({ $0 == 0 }) }) {\n            break\n\
    \        }\n    }\n    return days", '    return 0', "    var grid = grid\n  \
    \  var count = 0\n    for col in 0 ..< grid[0].count {\n        var remaining\
    \ = capacity\n        for row in 0 ..< grid.count {\n            let current =\
    \ grid[row][col]\n            if current == 1 {\n                remaining -=\
    \ 1\n                grid[row][col] = 0\n            }\n        }\n        if\
    \ remaining == 0 {\n            count += 1\n        }\n    }\n    return count",
  "\tvar max_fill_count = 0\n\tvar fill_count = 0\n\tvar column_index = 0\n\tvar not_done\
    \ = true\n\tvar current_well = 0\n\tvar bucket = capacity\n\t\n\twhile not_done\
    \ {\n\t\tnot_done = false\n\t\t//walk the wells\n\t\tfor well in grid {\n\t\t\t\
    //is there a 1 in the current well at the current column?\n\t\t\tif well[column_index]\
    \ == 1 {\n\t\t\t\t//is the bucket full?\n\t\t\t\tif bucket == capacity {\n\t\t\
    \t\t\t//fill bucket\n\t\t\t\t\tbucket = capacity\n\t\t\t\t\tfill_count += 1\n\t\
    \t\t\t}\n\t\t\t\t//fill the current well in the current column\n\t\t\t\twell[column_index]\
    \ = 0\n\t\t\t\tbucket -= 1\n\t\t\t\tnot_done = true\n\t\t\t}\n\t\t}\n\t\t//move\
    \ to the next column\n\t\tcolumn_index += 1\n\t\t\n\t\t//did we walk the entire\
    \ grid?\n\t\tif column_index >= grid[0].count {\n\t\t\t//reset the current column\n\
    \t\t\tcolumn_index = 0\n\t\t\t//did we fill any wells?\n\t\t\tif fill_count >\
    \ 0 {\n\t\t\t\t//keep track of the max\n\t\t\t\tmax_fill_count += fill_count\n\
    \t\t\t\t//reset fill count\n\t\t\t\tfill_count = 0\n\t\t\t}\n\t\t}\n\t}\n\treturn\
    \ max_fill_count", "    var filledGrid = grid\n    var totalWater = 0\n    for\
    \ row in filledGrid {\n        for column in row {\n            if column == 1\
    \ {\n                totalWater += 1\n            }\n        }\n    }\n    var\
    \ totalExtracted = 0\n    var currentCapacity = capacity\n    for row in filledGrid\
    \ {\n        for column in row {\n            if column == 1 {\n             \
    \   if currentCapacity == 0 {\n                    currentCapacity = capacity\n\
    \                    totalExtracted += 1\n                }\n                currentCapacity\
    \ -= 1\n            }\n        }\n    }\n    return totalExtracted", "    var\
    \ grid_copy = grid\n    let row_num = grid.count\n    let col_num = grid[0].count\n\
    \    var sum = 0\n    for _ in 0..<row_num {\n        for j in 0..<col_num {\n\
    \            if grid_copy[0][j] == 1 {\n                grid_copy[0][j] = 0\n\
    \                sum += 1\n            }\n        }\n        for i in 1..<row_num\
    \ {\n            for j in 0..<col_num {\n                let water_num = capacity\
    \ - grid_copy[i-1][j]\n                if grid_copy[i][j] == 1 {\n           \
    \         grid_copy[i][j] = 0\n                    sum += 1\n                }\n\
    \                if water_num > 0 {\n                    grid_copy[i][j] += water_num\n\
    \                }\n            }\n        }\n    }\n    return sum", "    var\
    \ operations = 0\n    var min_water = 0\n    for row in grid {\n        for value\
    \ in row {\n            min_water += value\n        }\n    }\n    for row in grid\
    \ {\n        for value in row {\n            if value == 0 {\n               \
    \ let delta = capacity - min_water\n                if delta < 0 {\n         \
    \           return operations\n                }\n                operations +=\
    \ delta\n            }\n        }\n    }\n    return operations", '  // Solution
    goes here...', "    var max_fill = 0\n    let wells = grid.reduce(into: [[Int]](),\
    \ { (result, well) in\n        result.append(well.enumerated().filter { $0.element\
    \ == 1 }.map { $0.offset })\n    })\n    for wells_row in wells {\n        if\
    \ wells_row.count == 0 {\n            continue\n        }\n        let max_bucket_start\
    \ = wells_row.reduce(0, { (result, well) in\n            return max(result, well\
    \ - capacity + 1)\n        })\n        var bucket_start = 0\n        while bucket_start\
    \ <= max_bucket_start {\n            var next_bucket_start = wells_row.reduce(bucket_start,\
    \ { (result, well) in\n                return min(result, well - capacity + 1)\n\
    \            })\n            max_fill += next_bucket_start - bucket_start\n  \
    \          bucket_start = next_bucket_start\n        }\n    }\n    return max_fill",
  '    return 1', "    var total = 0\n    var currentCapacity = capacity\n    var\
    \ bottom = grid.count\n    var top = 0\n    for row in grid {\n        for well\
    \ in row {\n            if well == 1 {\n                total += 1\n         \
    \       currentCapacity -= 1\n            }\n            if currentCapacity ==\
    \ 0 {\n                currentCapacity = capacity\n                total += 1\n\
    \            }\n        }\n        currentCapacity = capacity\n        bottom\
    \ -= 1\n        top += 1\n    }\n    return total", "    // initialize extraction\
    \ variable\n    var num_moves = 0\n    // check for empty grid\n    if grid.count\
    \ == 0 {\n        return num_moves\n    }\n    // iterate through grid rows\n\
    \    for row in grid {\n        // initialize row variables\n        var has_seen_one\
    \ = false\n        var buckets_left = capacity\n        // iterate through row\
    \ columns\n        for col in row {\n            // check for 1, if one is present,\
    \ decrement bucket and update has_seen_one\n            if col == 1 {\n      \
    \          if has_seen_one {\n                    buckets_left -= 1\n        \
    \        } else {\n                    has_seen_one = true\n                }\n\
    \            }\n            // check for 0, if one is present, increment bucket\n\
    \            if col == 0 {\n                buckets_left += 1\n            }\n\
    \            // check for remaining bucket capacity, if none remaining, increment\
    \ num_moves and reset buckets_left\n            if buckets_left == 0 {\n     \
    \           num_moves += 1\n                buckets_left = capacity\n        \
    \    }\n        }\n    }\n    return num_moves", "    // TODO: implement\n   \
    \ return 0", "    let rows = grid.count\n    let cols = grid[0].count\n    var\
    \ arr = Array(repeating: Array(repeating: 0, count: cols), count: rows)\n    var\
    \ count = 0\n    for j in 0..<cols {\n        for i in 0..<rows {\n          \
    \  if grid[i][j] == 1 {\n                if arr[i][j] < capacity {\n         \
    \           arr[i][j] += 1\n                    count += 1\n                }\n\
    \            }\n        }\n    }\n    return count", '    return 0', "    // Initialize\
    \ the depth map\n    var depth_map = [[Int]](repeating: [Int](repeating: 0, count:\
    \ grid[0].count), count: grid.count)\n    var total_fill = 0\n    for _ in 0..<grid.count\
    \ {\n        // Find the max depth of each row\n        var max_depth = 0\n  \
    \      for column in 0..<grid[0].count {\n            max_depth = max(max_depth,\
    \ grid[column][column])\n        }\n        // Fill the wells to max_depth\n \
    \       for row in 0..<grid.count {\n            var depth = max_depth - depth_map[row][row]\n\
    \            while depth > 0 {\n                depth -= capacity\n          \
    \      total_fill += 1\n            }\n            depth_map[row][row] = max_depth\n\
    \        }\n    }\n    return total_fill", "    \n    var grid = grid\n    var\
    \ times = 0\n    \n    for i in 0..<grid.count {\n        for j in 0..<grid[i].count\
    \ {\n            if grid[i][j] == 1 {\n                times += 1\n          \
    \      if i+1 < grid.count {\n                    let waterToGive = min(capacity,\
    \ grid[i+1][j])\n                    grid[i+1][j] -= waterToGive\n           \
    \         grid[i][j] -= waterToGive\n                }\n                if i-1\
    \ >= 0 {\n                    let waterToGive = min(capacity, grid[i-1][j])\n\
    \                    grid[i-1][j] -= waterToGive\n                    grid[i][j]\
    \ -= waterToGive\n                }\n                if j+1 < grid[i].count {\n\
    \                    let waterToGive = min(capacity, grid[i][j+1])\n         \
    \           grid[i][j+1] -= waterToGive\n                    grid[i][j] -= waterToGive\n\
    \                }\n                if j-1 >= 0 {\n                    let waterToGive\
    \ = min(capacity, grid[i][j-1])\n                    grid[i][j-1] -= waterToGive\n\
    \                    grid[i][j] -= waterToGive\n                }\n          \
    \  }\n        }\n    }\n    \n    return times", '  return 0', "    if grid.count\
    \ == 0 {\n        return 0\n    }\n    if grid[0].count == 0 {\n        return\
    \ 0\n    }\n    var m = grid.count\n    var n = grid[0].count\n    var i = 0\n\
    \    var j = 0\n    var water = 0\n    var count = 0\n    while i < m {\n    \
    \    j = 0\n        while j < n {\n            if grid[i][j] == 1 {\n        \
    \        water += 1\n                if water == capacity {\n                \
    \    count += 1\n                    water = 0\n                }\n          \
    \  }\n            j += 1\n        }\n        i += 1\n    }\n    return count",
  "    \n    return 0", '    return 0', "    // Get the number of rows and columns\n\
    \    let rows = grid.count\n    let columns = grid[0].count\n    \n    // Define\
    \ the grid of heights\n    var heights = [[Int]](repeating: [Int](repeating: 0,\
    \ count: columns), count: rows)\n    \n    // Calculate the heights\n    for row\
    \ in 0..<rows {\n        for column in 0..<columns {\n            heights[row][column]\
    \ = grid[row][column]\n            if row > 0 {\n                heights[row][column]\
    \ += heights[row - 1][column]\n            }\n        }\n    }\n    \n    // Count\
    \ the number of filled buckets\n    var count = 0\n    for row in 0..<rows {\n\
    \        for column in 0..<columns {\n            if heights[row][column] == 0\
    \ {\n                continue\n            }\n            count += heights[row][column]\
    \ / capacity\n            heights[row][column] = heights[row][column] % capacity\n\
    \        }\n    }\n    \n    // Calculate the number of times the buckets need\
    \ to be filled or emptied\n    var result = 0\n    while rows > 0 {\n        //\
    \ Remove the first row\n        heights.removeFirst()\n        rows -= 1\n   \
    \     \n        // Check if the number of rows is zero\n        if rows == 0 {\n\
    \            break\n        }\n        \n        // Get the maximum height in\
    \ the first row\n        let max_height = heights[0].max()!\n        \n      \
    \  // If the maximum height is zero, skip the current row\n        if max_height\
    \ == 0 {\n            continue\n        }\n        \n        // Fill the buckets\
    \ in the first row\n        for column in 0..<columns {\n            if heights[0][column]\
    \ == 0 {\n                continue\n            }\n            heights[0][column]\
    \ = max_height\n            result += max_height\n        }\n        \n      \
    \  // Calculate the difference between the first and other rows\n        for row\
    \ in 1..<rows {\n            for column in 0..<columns {\n                if heights[row][column]\
    \ == 0 {\n                    continue\n                }\n                let\
    \ diff = heights[0][column] - heights[row][column]\n                if diff >\
    \ 0", '    return 0', "    let max = grid.map { $0.max() ?? 0 }.max() ?? 0\n \
    \   return grid.map { $0.reduce(0) { $0 + ($1 - max) } }.reduce(0, +)", "    //\
    \ TODO: implement me\n    return 0", '    return 0', "    var fillCount = 0\n\
    \    var grid = grid\n    let rowCount = grid.count\n    let columnCount = grid[0].count\n\
    \    var newRow: [Int] = []\n    for j in 0...(columnCount - 1) {\n        for\
    \ i in 0...(rowCount - 1) {\n            if grid[i][j] == 1 {\n              \
    \  grid[i][j] = capacity\n                fillCount += 1\n            }\n    \
    \    }\n        for i in 0...(rowCount - 1) {\n            if grid[i][j] > 0 {\n\
    \                newRow.append(grid[i][j] - 1)\n            } else {\n       \
    \         newRow.append(0)\n            }\n        }\n        grid.append(newRow)\n\
    \        newRow = []\n    }\n    return fillCount", "    let maxRow = grid.count\
    \ - 1\n    let maxCol = grid[0].count - 1\n    var minHeight = 0\n    var drops\
    \ = 0\n    let grid: [[Int]] = grid.map { row in\n        return row.map { row\
    \ in\n            return row * capacity\n        }\n    }\n    let totalSum =\
    \ grid.map { row in\n        return row.reduce(0, +)\n    }.reduce(0, +)\n   \
    \ while totalSum > 0 {\n        for row in 0...maxRow {\n            for col in\
    \ 0...maxCol {\n                if grid[row][col] > 0 {\n                    grid[row][col]\
    \ -= 1\n                    totalSum -= 1\n                }\n            }\n\
    \        }\n        minHeight += 1\n        drops += 1\n        if minHeight >=\
    \ capacity {\n            minHeight = 0\n            var col = 0\n           \
    \ while col <= maxCol {\n                if col == 0 {\n                    var\
    \ row = 0\n                    while row <= maxRow {\n                       \
    \ if grid[row][col] > 0 {\n                            grid[row][col] -= 1\n \
    \                           totalSum -= 1\n                        }\n       \
    \                 row += 1\n                    }\n                } else if col\
    \ == maxCol {\n                    var row = maxRow\n                    while\
    \ row >= 0 {\n                        if grid[row][col] > 0 {\n              \
    \              grid[row][col] -= 1\n                            totalSum -= 1\n\
    \                        }\n                        row -= 1\n               \
    \     }\n                } else {\n                    var row = 0\n         \
    \           while row <= maxRow {\n                        if grid[row][col] >\
    \ 0 {\n                            grid[row][col] -= 1\n                     \
    \       totalSum -= 1\n                        }\n                        row\
    \ += 1\n                    }\n                }\n                col += 1\n \
    \           }\n            drops += 1\n        }\n    }\n    return drops", " \
    \   // TODO: solve\n    return 0", "    var grid = grid\n    var count = 0\n \
    \   for i in 0..<grid.count {\n        for j in 0..<grid[i].count {\n        \
    \    count += grid[i][j]\n        }\n    }\n    count -= 1\n    var c = 0\n  \
    \  while count > 0 {\n        c += 1\n        for i in 0..<grid.count {\n    \
    \        for j in 0..<grid[i].count {\n                if grid[i][j] == 1 {\n\
    \                    if i == 0 {\n                        grid[i][j] = 0\n   \
    \                     count -= 1\n                    } else if grid[i - 1][j]\
    \ == 0 {\n                        grid[i][j] = 0\n                        count\
    \ -= 1\n                    }\n                }\n            }\n        }\n \
    \   }\n    return c", "    if grid.isEmpty {\n        return 0\n    }\n    let\
    \ total_fill = grid.reduce(0) { $0 + $1.reduce(0) { $0 + $1 } }\n    if total_fill\
    \ == 0 {\n        return 0\n    }\n    if total_fill < capacity {\n        return\
    \ total_fill\n    }\n    let number_of_wells = grid.count\n    let number_of_units\
    \ = grid[0].count\n    let total_units = number_of_wells * number_of_units\n \
    \   if total_units == total_fill {\n        return capacity\n    }\n    let number_of_completions\
    \ = total_fill / capacity\n    let remainder = total_fill % capacity\n    return\
    \ number_of_completions + (remainder > 0 ? 1 : 0)", "    let rows = grid.count\n\
    \    let columns = grid[0].count\n    var max_found = 0\n    var buckets = [Int](repeating:\
    \ 0, count: rows)\n    for column in 0..<columns {\n        var row = 0\n    \
    \    while row < rows {\n            if grid[row][column] == 1 {\n           \
    \     buckets[row] += 1\n                max_found = max(max_found, buckets[row])\n\
    \            }\n            row += 1\n        }\n    }\n    return (max_found\
    \ / capacity) + (max_found % capacity > 0 ? 1 : 0)", "    \n    func isGridEmpty(grid:\
    \ [[Int]]) -> Bool {\n        for row in grid {\n            for well in row {\n\
    \                if well == 1 {\n                    return false\n          \
    \      }\n            }\n        }\n        return true\n    }\n    \n    func\
    \ fillBucket(grid: [[Int]], rowIndex: Int, columnIndex: Int, capacity: Int) ->\
    \ Int {\n        var grid = grid\n        let count = min(grid[rowIndex][columnIndex],\
    \ capacity)\n        grid[rowIndex][columnIndex] -= count\n        return count\n\
    \    }\n    \n    func emptyBucket(grid: [[Int]], rowIndex: Int, columnIndex:\
    \ Int, bucketSize: Int) -> Int {\n        var grid = grid\n        let count =\
    \ min(grid[rowIndex][columnIndex], bucketSize)\n        grid[rowIndex][columnIndex]\
    \ -= count\n        return count\n    }\n    \n    func fillWells(grid: [[Int]],\
    \ rowIndex: Int, columnIndex: Int, capacity: Int) -> [[Int]] {\n        var grid\
    \ = grid\n        var rowIndex = rowIndex\n        var columnIndex = columnIndex\n\
    \        var counter = 0\n        while rowIndex >= 0 {\n            let bucket\
    \ = fillBucket(grid: grid, rowIndex: rowIndex, columnIndex: columnIndex, capacity:\
    \ capacity)\n            rowIndex -= 1\n            columnIndex += 1\n       \
    \     if columnIndex == grid[0].count {\n                break\n            }\n\
    \            let bucketEmpty = emptyBucket(grid: grid, rowIndex: rowIndex, columnIndex:\
    \ columnIndex, bucketSize: bucket)\n            counter += bucketEmpty\n     \
    \   }\n        return grid\n    }\n    \n    var counter = 0\n    var grid = grid\n\
    \    while isGridEmpty(grid: grid) == false {\n        for i in 0..<grid.count\
    \ {\n            grid = fillWells(grid: grid, rowIndex: i, columnIndex: 0, capacity:\
    \ capacity)\n            counter += 1\n        }\n    }\n    return counter",
  "    let rows = grid.count\n    let cols = grid[0].count\n    var water = 0\n  \
    \  for i in 0..<rows {\n        for j in 0..<cols {\n            water += grid[i][j]\n\
    \        }\n    }\n    let maxWater = capacity * cols\n    let reduceBy = min(water,\
    \ maxWater)\n    return maxWater - reduceBy", "    // Your code here!\n    var\
    \ totalTimes = 0\n    let rowCount = grid.count\n    let colCount = grid[0].count\n\
    \    for i in 0..<rowCount {\n        for j in 0..<colCount {\n            let\
    \ bucket = grid[i][j]\n            if bucket == 1 {\n                totalTimes\
    \ += 1\n                for m in i..<rowCount {\n                    for n in\
    \ j..<colCount {\n                        if grid[m][n] != 1 {\n             \
    \               break\n                        }\n                        grid[m][n]\
    \ = 0\n                    }\n                }\n            }\n        }\n  \
    \  }\n    return totalTimes", "    // your code here\n    var total = 0\n    while\
    \ let max = grid.map({ $0.max() ?? 0 }).max() {\n        total += max / capacity\n\
    \        total += max % capacity == 0 ? 0 : 1\n        grid.map { $0.map { $0\
    \ - min($0, capacity) } }\n    }\n    return total", "    let max_row = grid.map\
    \ { $0.reduce(0, +) }.max() ?? 0\n    let max_col = zip(grid[0], grid[1]).map\
    \ { $0.0 + $0.1 }.max() ?? 0\n    let max_diag = zip(grid[0], grid[1]).map { $0.0\
    \ + $0.1 }.max() ?? 0\n    return max(max_row, max_col, max_diag)", '    return
    -1', "    // your code here\n    let w = grid[0].count\n    let d = grid.count\n\
    \    var max_per_row = Array(repeating: 0, count: d)\n    for i in 0..<d {\n \
    \       for j in 0..<w {\n            if grid[i][j] == 1 {\n                max_per_row[i]\
    \ += 1\n            }\n        }\n    }\n    var buckets = Array(repeating: 0,\
    \ count: d)\n    var remaining = capacity\n    var count = 0\n    while remaining\
    \ > 0 {\n        var index = 0\n        var max = 0\n        for i in 0..<d {\n\
    \            if max_per_row[i] > max {\n                max = max_per_row[i]\n\
    \                index = i\n            }\n        }\n        if max == 0 {\n\
    \            break\n        }\n        if buckets[index] < max {\n           \
    \ buckets[index] += 1\n            remaining -= 1\n        }\n        count +=\
    \ 1\n    }\n    return count", '    return 0', "    var totalWater = 0\n    for\
    \ row in grid {\n        for num in row {\n            if num == 1 {\n       \
    \         totalWater += 1\n            }\n        }\n    }\n    return totalWater\
    \ / capacity + (totalWater % capacity > 0 ? 1 : 0)", "    \n    var water = 0\n\
    \    for row in grid {\n        for col in row {\n            if col == 1 {\n\
    \                water += 1\n            }\n        }\n    }\n    \n    if capacity\
    \ > water {\n        return 0\n    }\n    \n    return water / capacity", "  \
    \  var count = 0\n    let grid = grid.map({ $0.map({ $0 * capacity }) })\n   \
    \ var max = 0\n    for row in grid {\n        max = max < row.max()! ? row.max()!\
    \ : max\n    }\n    for _ in 0...max {\n        for i in 0..<grid.count {\n  \
    \          for j in 0..<grid[i].count {\n                if grid[i][j] == 0 {\n\
    \                    if i != 0 {\n                        grid[i - 1][j] = grid[i\
    \ - 1][j] - 1\n                        count += 1\n                    }\n   \
    \                 if i != grid.count - 1 {\n                        grid[i + 1][j]\
    \ = grid[i + 1][j] - 1\n                        count += 1\n                 \
    \   }\n                    if j != 0 {\n                        grid[i][j - 1]\
    \ = grid[i][j - 1] - 1\n                        count += 1\n                 \
    \   }\n                    if j != grid[i].count - 1 {\n                     \
    \   grid[i][j + 1] = grid[i][j + 1] - 1\n                        count += 1\n\
    \                    }\n                }\n            }\n        }\n    }\n \
    \   return count", "    let gridLength = grid.count\n    let gridWidth = grid[0].count\n\
    \    var buckets = Array(repeating: capacity, count: gridWidth)\n    var fill\
    \ = 0\n    for i in 0..<gridLength {\n        let row = grid[i]\n        for j\
    \ in 0..<gridWidth {\n            if buckets[j] >= row[j] {\n                buckets[j]\
    \ -= row[j]\n            } else {\n                let diff = row[j] - buckets[j]\n\
    \                buckets[j] = capacity - diff\n                fill += diff\n\
    \            }\n        }\n    }\n    return fill", "    let sum = grid.map {\
    \ $0.reduce(0, +) }.reduce(0, +)\n    if sum <= capacity {\n        return 0\n\
    \    }\n    let n = grid.count\n    let m = grid[0].count\n    var result = 0\n\
    \    var copied = Array(repeating: Array(repeating: 0, count: m), count: n)\n\
    \    var delta = Array(repeating: Array(repeating: 0, count: m), count: n)\n \
    \   var total = 0\n    while total < sum {\n        for i in 0..<n {\n       \
    \     for j in 0..<m {\n                delta[i][j] = min(grid[i][j], capacity\
    \ - copied[i][j])\n                copied[i][j] += delta[i][j]\n             \
    \   total += delta[i][j]\n            }\n        }\n        result += 1\n    }\n\
    \    return result", "    \n    // Input:\n    //  grid: [[Int]]\n    //  capacity:\
    \ Int\n    // Output:\n    //  Int\n    \n    // Approach:\n    //  1. precompute\
    \ the \"set bits\" in each row of the grid - 0 is a hole, 1 is a well\n    //\
    \  2. scan the columns of the grid and \"fill\" a \"tank\" of the capacity\n \
    \   //  3. repeat until filled (and return the number of operations)\n    \n \
    \   let well_depths = grid.map({\n        // O(n) time complexity\n        $0.reduce(0,\
    \ { result, bit in\n            if bit == 1 {\n                return result +\
    \ 1\n            } else {\n                return result\n            }\n    \
    \    })\n    })\n    \n    // O(n^2) time complexity\n    var tank = 0\n    var\
    \ time = 0\n    while tank < capacity {\n        // O(n) time complexity\n   \
    \     for row in 0..<grid.count {\n            let column = time % grid[row].count\n\
    \            if grid[row][column] == 1 {\n                tank += 1\n        \
    \    }\n            if tank >= capacity {\n                break\n           \
    \ }\n        }\n        time += 1\n    }\n    \n    return time", '    return
    0', "    \n    guard grid.count > 0 else { return 0 }\n    \n    var grid = grid\n\
    \    let num_wells = grid.count\n    let well_len = grid[0].count\n    var num_actions\
    \ = 0\n    \n    for _ in 0..<num_wells {\n        var row_total = 0\n       \
    \ for col in 0..<well_len {\n            if grid[0][col] == 1 {\n            \
    \    row_total += 1\n            }\n        }\n        num_actions += row_total\
    \ / capacity\n        if row_total % capacity != 0 {\n            num_actions\
    \ += 1\n        }\n        grid.removeFirst()\n    }\n    \n    return num_actions",
  "    let rows = grid.count\n    let cols = grid[0].count\n    var curr_row = 0\n\
    \    var curr_col = 0\n    var result = 0\n    while curr_row < rows && curr_col\
    \ < cols {\n        if grid[curr_row][curr_col] != 0 {\n            grid[curr_row][curr_col]\
    \ -= capacity\n            result += 1\n        }\n        // move horizontally\
    \ to the end of the row\n        curr_col += 1\n        if curr_col == cols {\n\
    \            // move horizontally to the beginning of the next row\n         \
    \   curr_col = 0\n            curr_row += 1\n        }\n    }\n    return result",
  "    \n    var wellsCount = 0\n    var fullWellsCount = 0\n    var bucketsCount\
    \ = 0\n    \n    for row in grid {\n        wellsCount += row.count\n        \n\
    \        for well in row {\n            if well == 1 {\n                fullWellsCount\
    \ += 1\n            }\n        }\n    }\n    \n    bucketsCount = wellsCount /\
    \ capacity\n    \n    return fullWellsCount / bucketsCount", "    var grid = grid\n\
    \    var cur = capacity\n    var count = 0\n    for i in 0 ..< grid.count {\n\
    \        if grid[i].contains(1) {\n            cur = cur - grid[i].filter({$0\
    \ == 1}).count\n            if cur < 0 {\n                cur = capacity\n   \
    \             count += 1\n            }\n        }\n    }\n    return count",
  "    let rows = grid.count\n    let cols = grid[0].count\n    var deepestWell =\
    \ 0\n    for i in 0..<rows {\n        let max = grid[i].max()!\n        if max\
    \ > deepestWell {\n            deepestWell = max\n        }\n    }\n    var fillCount\
    \ = 0\n    for depth in 0..<deepestWell {\n        for i in 0..<rows {\n     \
    \       for j in 0..<cols {\n                if grid[i][j] > depth {\n       \
    \             fillCount += 1\n                }\n            }\n        }\n  \
    \  }\n    return fillCount", "    guard grid.count > 0, grid[0].count > 0 else\
    \ { return 0 }\n    var filled_rows = grid.count\n    var filled_columns = grid[0].count\n\
    \    while (filled_rows > 0 && filled_columns > 0) {\n        var filled_rows_copy\
    \ = filled_rows\n        var filled_columns_copy = filled_columns\n        for\
    \ i in 0..<filled_rows {\n            for j in 0..<filled_columns {\n        \
    \        if grid[i][j] != 0 {\n                    filled_rows_copy -= 1\n   \
    \                 break\n                }\n            }\n        }\n       \
    \ for j in 0..<filled_columns {\n            for i in 0..<filled_rows {\n    \
    \            if grid[i][j] != 0 {\n                    filled_columns_copy -=\
    \ 1\n                    break\n                }\n            }\n        }\n\
    \        filled_rows = filled_rows_copy\n        filled_columns = filled_columns_copy\n\
    \    }\n    return (filled_rows+filled_columns)*capacity", '    return 0', " \
    \   if grid.count == 0 {\n        return 0\n    }\n    var result = 0\n    for\
    \ column in grid[0].indices {\n        for row in grid.indices {\n           \
    \ let cell = grid[row][column]\n            if cell == 1 {\n                result\
    \ += 1\n                var buckets = capacity\n                var row_index\
    \ = row\n                while buckets > 0 && row_index >= 0 {\n             \
    \       let current_cell = grid[row_index][column]\n                    if current_cell\
    \ == 1 {\n                        buckets -= 1\n                        grid[row_index][column]\
    \ = 0\n                    }\n                    row_index -= 1\n           \
    \     }\n            }\n        }\n    }\n    return result", "    var fill =\
    \ 0\n    var fill_amount = 0\n    let row_length = grid[0].count\n    for row\
    \ in grid {\n        for block in row {\n            fill_amount += block\n  \
    \          if fill_amount == capacity {\n                fill += 1\n         \
    \       fill_amount = 0\n            }\n        }\n        fill_amount = 0\n \
    \   }\n    return fill", "    // your code goes here\n    let numRows = grid.count,\
    \ numCols = grid[0].count\n    var grid = grid\n    var count = 0\n    for i in\
    \ 0..<numRows {\n        for j in 0..<numCols {\n            if grid[i][j] ==\
    \ 1 {\n                count += 1\n                fillOneCell(grid: &grid, row:\
    \ i, col: j, capacity: capacity)\n            }\n        }\n    }\n    return\
    \ count", "    // edge cases\n    guard grid.count > 0 else { return 0 }\n   \
    \ guard grid[0].count > 0 else { return 0 }\n    \n    var row_sums = [Int]()\n\
    \    var sum = 0\n    for row in grid {\n        for column in row {\n       \
    \     sum += column\n        }\n        row_sums.append(sum)\n        sum = 0\n\
    \    }\n    \n    var times = 0\n    var well_count = grid[0].count\n    var row_count\
    \ = grid.count\n    var x = 0\n    while x < row_count {\n        if row_sums[x]\
    \ > capacity {\n            row_sums[x] -= capacity\n            times += 1\n\
    \        } else {\n            times += row_sums[x]\n            row_sums[x] =\
    \ 0\n        }\n        x += 1\n    }\n    \n    var y = 0\n    while y < well_count\
    \ {\n        var z = 0\n        while z < row_count {\n            if grid[z][y]\
    \ == 1 {\n                if row_sums[z] > capacity {\n                    row_sums[z]\
    \ -= capacity\n                    times += 1\n                } else {\n    \
    \                times += row_sums[z]\n                    row_sums[z] = 0\n \
    \               }\n            }\n            z += 1\n        }\n        y +=\
    \ 1\n    }\n    \n    return times", "    guard grid.count > 0, grid[0].count\
    \ > 0 else { return 0 }\n    let height = grid.count\n    let width = grid[0].count\n\
    \    var currentMax = capacity\n    var current = 0\n    var times = 0\n    for\
    \ row in grid {\n        for column in row {\n            if column == 1 {\n \
    \               current += 1\n            }\n        }\n        if current > currentMax\
    \ {\n            currentMax = current\n            times += 1\n        }\n   \
    \     current = 0\n    }\n    return times", '    return 0', "    var maxFill\
    \ = 0\n    for row in grid {\n        maxFill += max_fill(row: row, capacity:\
    \ capacity)\n    }\n    return maxFill", "  var max_water = 0\n  for i in 0..<grid.count\
    \ {\n    var collected_water = 0\n    for j in 0..<grid[i].count {\n      if grid[i][j]\
    \ == 1 {\n        collected_water += 1\n      }\n    }\n    max_water += min(collected_water,\
    \ capacity)\n  }\n  return max_water", "    // step 1: convert all columns to\
    \ buckets\n    var buckets = [[Int]]()\n    for column in grid {\n        buckets.append(Array(repeating:\
    \ capacity, count: column.count))\n    }\n    // step 2: iterate over the columns\
    \ and test if they are full\n    var operations = 0\n    while true {\n      \
    \  var isFull = true\n        for column in 0..<grid.count {\n            for\
    \ bucket in 0..<grid[column].count {\n                if buckets[column][bucket]\
    \ > 0 {\n                    isFull = false\n                    // fill the bucket\n\
    \                    operations += 1\n                    buckets[column][bucket]\
    \ -= 1\n                }\n            }\n        }\n        if isFull {\n   \
    \         break\n        }\n    }\n    return operations", '    return 0', " \
    \ var buckets = 0\n  var next_fill = capacity\n  while true {\n    let fill_index\
    \ = grid[0].index(of: 1)\n    guard let index = fill_index else { break }\n  \
    \  if index <= next_fill {\n      for i in 0..<grid.count {\n        grid[i].remove(at:\
    \ index)\n      }\n      next_fill = capacity\n      buckets += 1\n    } else\
    \ {\n      next_fill -= 1\n    }\n  }\n  return buckets", "    var result = 0\n\
    \    var localMax = 0\n    for i in 0..<grid.count {\n        localMax = 0\n \
    \       for j in 0..<grid[i].count {\n            if grid[i][j] == 1 {\n     \
    \           localMax += 1\n            }\n        }\n        result += localMax/capacity\n\
    \        localMax = localMax%capacity\n        if i+1 < grid.count {\n       \
    \     for j in 0..<grid[i+1].count {\n                if grid[i+1][j] == 1 {\n\
    \                    localMax += 1\n                }\n            }\n       \
    \     result += localMax/capacity\n            localMax = localMax%capacity\n\
    \        }\n    }\n    return result", "    var grid = grid\n    var buckets =\
    \ Array(repeating: capacity, count: grid[0].count)\n    var steps = 0\n    while\
    \ true {\n        var full_wells = 0\n        for (index, well) in grid.enumerated()\
    \ {\n            for (index2, _) in well.enumerated() {\n                if grid[index][index2]\
    \ > 0 {\n                    full_wells += 1\n                }\n            }\n\
    \        }\n        if full_wells == 0 {\n            break\n        }\n     \
    \   for (index, well) in grid.enumerated() {\n            for (index2, _) in well.enumerated()\
    \ {\n                buckets[index2] = min(capacity, buckets[index2] + grid[index][index2])\n\
    \                if buckets[index2] == capacity {\n                    steps +=\
    \ 1\n                    buckets[index2] = 0\n                    grid[index][index2]\
    \ = 0\n                }\n            }\n        }\n    }\n    return steps",
  "    /// Determine the base on which to calculate the maximum fill.\n    var base\
    \ = 0\n    for i in 0..<grid.count {\n        for j in 0..<grid[i].count {\n \
    \           if grid[i][j] == 1 {\n                base += 1\n            }\n \
    \       }\n    }\n    base *= capacity\n    \n    /// Calculate the maximum fill.\n\
    \    var current = 0\n    var count = 0\n    while current < base {\n        for\
    \ i in 0..<grid.count {\n            for j in 0..<grid[i].count {\n          \
    \      if grid[i][j] == 1 {\n                    if current >= base {\n      \
    \                  return count\n                    }\n                    current\
    \ += 1\n                    count += 1\n                }\n            }\n   \
    \     }\n    }\n    return count", '    return 0', "    var result = 0\n    for\
    \ item in grid {\n        result += max(item.reduce(0, {x, y in x + y}), capacity)\n\
    \    }\n    return result", "    var operations = 0\n    for row in grid {\n \
    \       var currentCapacity = capacity\n        for well in row {\n          \
    \  if well == 1 {\n                if currentCapacity > 0 {\n                \
    \    currentCapacity -= 1\n                } else {\n                    operations\
    \ += 1\n                    currentCapacity = capacity - 1\n                }\n\
    \            }\n        }\n    }\n    return operations", "    var count = 0\n\
    \    for column in grid[0].indices {\n        for row in grid.indices {\n    \
    \        if grid[row][column] == 1 {\n                let bucket_count = (row\
    \ + 1) / capacity\n                if bucket_count != 0 {\n                  \
    \  count += bucket_count\n                }\n            }\n        }\n    }\n\
    \    return count", "    let totalFill = grid.reduce(0) { $0 + $1.reduce(0, +)\
    \ }\n    let bucketFill = capacity * grid.count\n    let passes = totalFill /\
    \ bucketFill\n    var finalFill = totalFill - (passes * bucketFill)\n    let lastPass\
    \ = grid.map {\n        return $0.reduce(0) {$0 + $1}\n    }.sorted().filter {$0\
    \ > 0}\n    for i in 0..<lastPass.count {\n        if finalFill >= capacity {\n\
    \            finalFill -= capacity\n        } else {\n            finalFill =\
    \ lastPass[i] - finalFill\n        }\n    }\n    return totalFill + finalFill",
  "    // your code goes here\n    return 0", "    var max_fill = 0\n    var bucket\
    \ = 0\n    for _ in grid {\n        for i in 0..<grid[0].count {\n           \
    \ if grid[i][0] != 1 {\n                if grid[i][0] != 0 {\n               \
    \     bucket = grid[i][0]\n                }\n                if bucket < capacity\
    \ {\n                    bucket += 1\n                    max_fill += 1\n    \
    \            }\n            }\n        }\n    }\n    return max_fill", '    return
    0', '    return 0', '    // ...', "    var counter = 0\n    var full = false\n\
    \    for i in 0..<grid.count {\n        if (full) {\n            continue\n  \
    \      }\n        full = true\n        for j in 0..<grid[i].count {\n        \
    \    if (grid[i][j] == 1) {\n                counter += 1\n                full\
    \ = false\n            }\n        }\n    }\n    return counter * capacity", " \
    \   let H = grid.count\n    let W = grid[0].count\n    var grid = grid\n    var\
    \ sum = 0\n    for i in 0..<H {\n        var units_to_go = capacity\n        for\
    \ j in 0..<W {\n            if grid[i][j] == 1 {\n                grid[i][j] =\
    \ 0\n                units_to_go -= 1\n            }\n            if units_to_go\
    \ == 0 {\n                break\n            }\n        }\n        sum += capacity\
    \ - units_to_go\n    }\n    return sum", '    // Your code here', "    guard grid.count\
    \ > 0, grid[0].count > 0 else { return 0 }\n    var result = 0\n    for row in\
    \ grid {\n        for (idx, val) in row.enumerated() {\n            if val ==\
    \ 1 {\n                let to_add = min(capacity, idx + 1)\n                result\
    \ += to_add\n            }\n        }\n    }\n    return result", "    let wells\
    \ = getWells(grid: grid)\n    return pour(wells: wells, capacity: capacity)",
  "    var total = 0\n    var temp_row = Array(repeating: 0, count: grid[0].count)\n\
    \    for i in 0..<grid.count {\n        var row = grid[i]\n        var temp_col\
    \ = 0\n        for j in 0..<row.count {\n            if row[j] == 1 {\n      \
    \          total += (capacity - temp_row[j])\n                temp_col += 1\n\
    \            }\n            temp_row[j] = temp_col\n        }\n    }\n    return\
    \ total", '    return 0', "    var wells = [[Int]]()\n    var buckets = [Int]()\n\
    \    var depth = 0\n    var count = 0\n    for i in 0..<grid.count {\n       \
    \ for j in 0..<grid[i].count {\n            if wells.count == 0 {\n          \
    \      wells.append([grid[i][j]])\n                buckets.append(0)\n       \
    \     } else {\n                var newRow = true\n                for k in 0..<wells.count\
    \ {\n                    if wells[k][0] == grid[i][j] {\n                    \
    \    wells[k].append(grid[i][j])\n                        newRow = false\n   \
    \                     break\n                    }\n                }\n      \
    \          if newRow {\n                    wells.append([grid[i][j]])\n     \
    \               buckets.append(0)\n                }\n            }\n        }\n\
    \    }\n    while true {\n        var colMax = 0\n        for well in wells {\n\
    \            var colSum = 0\n            for col in well {\n                colSum\
    \ += col\n            }\n            if colSum > colMax {\n                colMax\
    \ = colSum\n            }\n        }\n        if colMax == 0 {\n            break\n\
    \        }\n        depth += 1\n        for k in 0..<wells.count {\n         \
    \   for j in 0..<wells[k].count {\n                if wells[k][j] == 1 {\n   \
    \                 wells[k][j] = 0\n                    buckets[k] += 1\n     \
    \               count += 1\n                    if buckets[k] == capacity {\n\
    \                        wells[k].remove(at: j)\n                        buckets[k]\
    \ = 0\n                    }\n                    break\n                }\n \
    \           }\n        }\n    }\n    return count", "    var max_fill = 0\n  \
    \  var current_fill = 0\n    for line in grid {\n        for cell in line {\n\
    \            if cell == 1 {\n                current_fill += 1\n            }\n\
    \        }\n        max_fill += current_fill / capacity\n        current_fill\
    \ = current_fill % capacity\n    }\n    return max_fill", "    var moves = 0\n\
    \    for col in grid[0].indices {\n        for row in grid.indices {\n       \
    \     if grid[row][col] == 1 {\n                moves += 1\n                for\
    \ row in (0..<row).reversed() {\n                    moves += 1\n            \
    \        grid[row][col] = 1\n                }\n            }\n        }\n   \
    \ }\n    return moves", "    // TODO: Implement the logic here\n    return -1",
  "    let row_count = grid.count\n    guard let col_count = grid.first?.count else\
    \ {\n        return 0\n    }\n    var column_sums = Array(repeating: 0, count:\
    \ col_count)\n    for row in grid {\n        for i in 0..<col_count {\n      \
    \      column_sums[i] += row[i]\n        }\n    }\n    // find the minimum bucket\
    \ capacity required to fill the row\n    let min_row_bucket_cap = (column_sums.max()\
    \ ?? 0) / capacity\n    // minimum bucket capacity required to fill the rows in\
    \ parallel\n    let min_parallel_bucket_cap = min_row_bucket_cap * row_count\n\
    \    // use minimum row bucket capacity to fill the rows\n    let max_parallel_row_fill\
    \ = min_row_bucket_cap * row_count * capacity\n    // use excess capacity to fill\
    \ the columns\n    let max_col_fill = column_sums.reduce(0) { (acc, next) in\n\
    \        acc + next % capacity\n    }\n    return max_parallel_row_fill + max_col_fill",
  '    return 0', "    let rows = grid.count\n    let cols = grid[0].count\n    //\
    \ answer\n    var ans = 0\n    // transpose the grid.\n    // we want to see the\
    \ grid as columns, not rows\n    var grid_t = [[Int]](repeating: [Int](repeating:\
    \ 0, count: rows), count: cols)\n    for i in 0..<rows {\n        for j in 0..<cols\
    \ {\n            grid_t[j][i] = grid[i][j]\n        }\n    }\n    // water levels\
    \ in each column\n    var levels = [Int](repeating: 0, count: cols)\n    // mark\
    \ all columns that can be filled\n    var cols_to_fill = [Bool](repeating: false,\
    \ count: cols)\n    for col in 0..<cols {\n        // find the first row that\
    \ has water in it\n        var i = 0\n        while i < rows && grid_t[col][i]\
    \ == 0 {\n            i += 1\n        }\n        if i < rows {\n            //\
    \ we can fill this column\n            cols_to_fill[col] = true\n            //\
    \ and the level of water should be at least as high as `i`\n            levels[col]\
    \ = i\n        }\n    }\n    // main loop:\n    // do while there are columns\
    \ to fill\n    while cols_to_fill.contains(true) {\n        // find the highest\
    \ column to fill\n        var max_j = 0\n        var max_value = 0\n        for\
    \ j in 0..<cols {\n            if cols_to_fill[j] && levels[j] > max_value {\n\
    \                max_j = j\n                max_value = levels[j]\n          \
    \  }\n        }\n        // increase the level of the highest column\n       \
    \ levels[max_j] += 1\n        // we need to fill the water in this column into\
    \ the adjacent ones\n        var fill_amount = capacity\n        for j in max_j-1...max_j+1\
    \ {\n            if cols_to_fill[j] {\n                // fill this column as\
    \ much as we can\n                let to_fill = min(levels[j],", "    var max\
    \ = -1\n    for row in grid {\n        let fill = max_fill(row: row, capacity:\
    \ capacity)\n        if fill > max {\n            max = fill\n        }\n    }\n\
    \    return max", "  let heights = grid.map { row in\n    row.reduce(0) { acc,\
    \ fill -> Int in\n      return acc + fill\n    }\n  }\n  var buckets: [Int] =\
    \ []\n  for height in heights {\n    buckets.append(height / capacity)\n    if\
    \ height % capacity != 0 {\n      buckets.append(1)\n    }\n  }\n  return buckets.reduce(0)\
    \ { acc, count -> Int in\n    return acc + count\n  }", "    // Calculate the\
    \ number of columns.\n    let columns = grid[0].count\n    // Convert the 2D array\
    \ into a 1D array.\n    let arr = grid.flatMap { $0 }\n    // Calculate the number\
    \ of rows.\n    let rows = arr.count / columns\n    // Initialize a counter.\n\
    \    var count = 0\n    // Fill the buckets.\n    for _ in arr {\n        // Check\
    \ if the row is full.\n        if arr.filter { $0 == 1 }.count == columns {\n\
    \            // Reset the buckets.\n            arr.map { return $0 == 1 ? 0 :\
    \ $0 }\n            // Increment the counter.\n            count += 1\n      \
    \  }\n        // Fill the buckets.\n        arr.map { return $0 == 0 ? capacity\
    \ : $0 }\n    }\n    // Check if the row is full.\n    if arr.filter { $0 == 1\
    \ }.count == columns {\n        // Reset the buckets.\n        arr.map { return\
    \ $0 == 1 ? 0 : $0 }\n        // Increment the counter.\n        count += 1\n\
    \    }\n    // Calculate the number of rows filled.\n    let rows_filled = arr.filter\
    \ { $0 == 1 }.count / columns\n    // Calculate the number of times you need to\
    \ lower the buckets.\n    return count + capacity * rows_filled", "    var grid\
    \ = grid\n    let length = grid[0].count\n    let numberOfRows = grid.count\n\
    \    let maxLenght = numberOfRows * length\n    var maxDepth = 0\n    var totalFilledCells\
    \ = 0\n    var times: Int = 0\n    while totalFilledCells < maxLenght {\n    \
    \    var maxDepth = 0\n        for i in 0..<numberOfRows {\n            for j\
    \ in 0..<length {\n                if grid[i][j] == 1 {\n                    maxDepth\
    \ += 1\n                } else {\n                    break\n                }\n\
    \            }\n        }\n        for i in 0..<numberOfRows {\n            for\
    \ j in 0..<length {\n                if grid[i][j] == 1 {\n                  \
    \  grid[i][j] = 0\n                    totalFilledCells += 1\n               \
    \ }\n            }\n        }\n        let filled = min(maxDepth, capacity)\n\
    \        for i in (0..<numberOfRows).reversed() {\n            for j in (0..<length).reversed()\
    \ {\n                if filled > 0 {\n                    grid[i][j] = 1\n   \
    \                 filled -= 1\n                }\n            }\n        }\n \
    \       times += 1\n    }\n    return times", "\treturn 0", "    var total = 0\n\
    \    for x in 0..<grid.count {\n        var current = capacity\n        for y\
    \ in 0..<grid[x].count {\n            if grid[x][y] == 1 {\n                if\
    \ current == 0 {\n                    total += 1\n                    current\
    \ = capacity\n                }\n                current -= 1\n            }\n\
    \        }\n        if current != capacity {\n            total += 1\n       \
    \ }\n    }\n    return total", '    // your code here', "    var count = 0\n \
    \   for i in 0..<grid.count {\n        for j in 0..<grid[i].count {\n        \
    \    if grid[i][j] == 1 {\n                if capacity < grid[i].count - j {\n\
    \                    count += 1\n                } else {\n                  \
    \  count += 2\n                }\n            }\n        }\n    }\n    return\
    \ count", '    return 0', "    var result = 0\n    for i in 0..<grid.count {\n\
    \        result += fill(i, grid, capacity)\n    }\n    return result", "    var\
    \ currentLevel = 0\n    var moves = 0\n    while hasLevel(grid: grid, level: currentLevel)\
    \ {\n        print(\"current level: \\(currentLevel)\")\n        for (index, row)\
    \ in grid.enumerated() {\n            if row.contains(currentLevel) {\n      \
    \          moves += 1\n                if index == 0 {\n                    grid[index].replaceSubrange(0...capacity,\
    \ with: repeatElement(0, count: capacity + 1))\n                } else {\n   \
    \                 if index > 0 && grid[index - 1].contains(currentLevel) {\n \
    \                       let lowerCapacity = capacity - currentLevel\n        \
    \                let lowerIndex = grid[index - 1].firstIndex(of: currentLevel)!\n\
    \                        let newIndex = grid[index].lastIndex(of: currentLevel)!\
    \ + 1\n                        grid[index].replaceSubrange(newIndex...newIndex\
    \ + lowerCapacity, with: repeatElement(0, count: lowerCapacity + 1))\n       \
    \                 grid[index - 1].replaceSubrange(lowerIndex...lowerIndex + lowerCapacity,\
    \ with: repeatElement(0, count: lowerCapacity + 1))\n                    } else\
    \ {\n                        let upperCapacity = capacity - currentLevel\n   \
    \                     let upperIndex = grid[index].firstIndex(of: currentLevel)!\n\
    \                        grid[index].replaceSubrange(upperIndex...upperIndex +\
    \ upperCapacity, with: repeatElement(0, count: upperCapacity + 1))\n         \
    \           }\n                }\n            }\n        }\n        currentLevel\
    \ += 1\n    }\n    return moves", "    var total = 0\n    let rowSize = grid.count\n\
    \    let colSize = grid[0].count\n    var wells = grid\n    var maxWater = 0\n\
    \    var rowIndex = 0\n    var colIndex = 0\n    var capacity = capacity\n   \
    \ var n = 1\n    while n > 0 {\n        n = 0\n        for r in 0 ..< rowSize\
    \ {\n            for c in 0 ..< colSize {\n                if wells[r][c] == 1\
    \ {\n                    maxWater = 0\n                    capacity = capacity\
    \ - 1\n                    wells[r][c] = 0\n                    total += 1\n \
    \                   if c > 0 && wells[r][c - 1] == 1 {\n                     \
    \   wells[r][c - 1] = 0\n                        maxWater += 1\n             \
    \       }\n                    if c < colSize - 1 && wells[r][c + 1] == 1 {\n\
    \                        wells[r][c + 1] = 0\n                        maxWater\
    \ += 1\n                    }\n                    if r > 0 && wells[r - 1][c]\
    \ == 1 {\n                        wells[r - 1][c] = 0\n                      \
    \  maxWater += 1\n                    }\n                    if r < rowSize -\
    \ 1 && wells[r + 1][c] == 1 {\n                        wells[r + 1][c] = 0\n \
    \                       maxWater += 1\n                    }\n               \
    \     if maxWater > capacity {\n                        total += maxWater - capacity\n\
    \                        capacity = 0\n                    } else {\n        \
    \                capacity -= maxWater\n                    }\n               \
    \ }\n            }\n        }\n        for r in 0 ..< rowSize {\n            for\
    \ c in 0 ..< colSize {\n                if wells[r][c] == 1 {\n              \
    \      n += 1\n                }\n            }\n        }\n    }\n    return\
    \ total", "    var count: Int = 0\n    var temp = Array(repeating: Array(repeating:\
    \ 0, count: grid[0].count), count: grid.count)\n    while true {\n        let\
    \ new_temp = fill_grid(grid: grid, temp: temp, capacity: capacity)\n        count\
    \ += 1\n        if new_temp == temp {\n            break\n        }\n        temp\
    \ = new_temp\n    }\n    return count", "    var height = Array(repeating: 0,\
    \ count: grid[0].count)\n    var i = 0\n    while i < grid.count {\n        var\
    \ j = 0\n        while j < grid[i].count {\n            if grid[i][j] == 1 {\n\
    \                height[j] += 1\n            }\n            j += 1\n        }\n\
    \        i += 1\n    }\n    var max = capacity\n    i = 0\n    while i < height.count\
    \ {\n        if height[i] > max {\n            max = height[i]\n        }\n  \
    \      i += 1\n    }\n    return max * capacity * grid[0].count", "    if grid.isEmpty\
    \ {\n        return 0\n    }\n    var data = Array(repeating: Array(repeating:\
    \ 0, count: grid[0].count), count: grid.count)\n    var sum = 0\n    for row in\
    \ 0..<grid.count {\n        for column in 0..<grid[row].count {\n            data[row][column]\
    \ = capacity - grid[row][column]\n            sum += data[row][column]\n     \
    \   }\n    }\n    print(data)\n    var n = 1\n    while n < sum + 1 {\n      \
    \  var i = 0\n        while i < data.count {\n            if i % 2 == 0 {\n  \
    \              var j = 0\n                while j < data[i].count {\n        \
    \            if data[i][j] != 0 {\n                        data[i][j] -= 1\n \
    \                       sum -= 1\n                    }\n                    j\
    \ += 1\n                }\n            } else {\n                var j = data[i].count\
    \ - 1\n                while j >= 0 {\n                    if data[i][j] != 0\
    \ {\n                        data[i][j] -= 1\n                        sum -= 1\n\
    \                    }\n                    j -= 1\n                }\n      \
    \      }\n            i += 1\n        }\n        print(data)\n        n += 1\n\
    \    }\n    return n - 1", "    var totalWater = 0\n    for i in 0..<grid.count\
    \ {\n        for j in 0..<grid[i].count {\n            totalWater += grid[i][j]\n\
    \        }\n    }\n    let maxRaises = totalWater / capacity\n    print(maxRaises)\n\
    \    return maxRaises", '    return -1', "    var grid = grid\n    var counter\
    \ = 0\n    while true {\n        var didRemove = false\n        for x in 0..<grid.count\
    \ {\n            for y in 0..<grid[x].count {\n                if grid[x][y] ==\
    \ 1 {\n                    didRemove = true\n                    for z in (0...y).reversed()\
    \ {\n                        if grid[x][z] < capacity {\n                    \
    \        grid[x][z] += 1\n                            counter += 1\n         \
    \               }\n                    }\n                }\n            }\n \
    \       }\n        if !didRemove {\n            break\n        }\n    }\n    return\
    \ counter", '    return 0', "    var water: [[Int]] = grid\n    var iterations\
    \ = 0\n    let n = grid.count\n    let m = grid[0].count\n    while true {\n \
    \       var drained = false\n        for i in 0..<n {\n            for j in 0..<m\
    \ {\n                if water[i][j] == 0 {\n                    continue\n   \
    \             }\n                let left = (j - 1 >= 0) ? water[i][j - 1] : 0\n\
    \                let right = (j + 1 < m) ? water[i][j + 1] : 0\n             \
    \   let bottom = (i + 1 < n) ? water[i + 1][j] : 0\n                let max =\
    \ [left, right, bottom].max() ?? 0\n                if max != 0 && max < capacity\
    \ {\n                    water[i][j] = 0\n                    drained = true\n\
    \                }\n            }\n        }\n        if !drained {\n        \
    \    break\n        }\n        iterations += 1\n    }\n    return iterations",
  "    /// TODO\n    return 0", "    var i = grid.count - 1\n    var j = grid[0].count\
    \ - 1\n    var result = 0\n    while (i >= 0 && j >= 0) {\n        let current\
    \ = grid[i][j]\n        if (current == 0) {\n            result += capacity\n\
    \        }\n        else {\n            result += (capacity - current)\n     \
    \   }\n        i -= 1\n        j -= 1\n    }\n    return result", "    guard grid.count\
    \ != 0 else { return 0 }\n    var total_water = 0\n    let width = grid[0].count\n\
    \    var column_max = [Int](repeating: 0, count: width)\n    for i in (0..<grid.count).reversed()\
    \ {\n        for j in 0..<width {\n            if grid[i][j] == 1 {\n        \
    \        column_max[j] = i\n            }\n        }\n        for j in 0..<width\
    \ {\n            total_water += fill(grid: grid, column_max: column_max, row:\
    \ i, column: j, capacity: capacity)\n        }\n    }\n    return total_water",
  '    return 0', "    var result = 0\n    for index in grid.indices {\n        var\
    \ row = 0\n        for j in grid[index].indices {\n            row += grid[index][j]\n\
    \        }\n        if row != 0 {\n            if capacity < row {\n         \
    \       result += capacity\n            } else {\n                result += row\n\
    \            }\n        }\n    }\n    return result", "    var grid = grid\n \
    \   var count = 0\n    for i in 0..<grid.count {\n        for j in 0..<grid[i].count\
    \ {\n            if grid[i][j] == 1 {\n                for k in i...i+capacity-1\
    \ {\n                    if k < grid.count && grid[k][j] == 1 {\n            \
    \            grid[k][j] = 0\n                    }\n                }\n      \
    \          count += 1\n            }\n        }\n    }\n    return count", "\t\
    var sum = 0\n\tfor row in grid {\n\t\tvar max_water = 0\n\t\tfor c in row {\n\t\
    \t\tmax_water += c\n\t\t}\n\t\tsum += max_water / capacity\n\t\tif max_water %\
    \ capacity != 0 {\n\t\t\tsum += 1\n\t\t}\n\t}\n\treturn sum", '    return 0',
  "    var waterLevel = Array(repeating: Array(repeating: 0, count: grid[0].count),\
    \ count: grid.count)\n    var moves = 0\n    var filledCount = 0\n    for row\
    \ in grid {\n        for column in row {\n            if column == 1 {\n     \
    \           filledCount += 1\n            }\n        }\n    }\n    while filledCount\
    \ > 0 {\n        for row in 0..<grid.count {\n            for column in 0..<grid[row].count\
    \ {\n                var currentRow = row\n                if grid[row][column]\
    \ == 1 {\n                    while currentRow >= 0 && grid[currentRow][column]\
    \ == 0 && waterLevel[currentRow][column] < capacity {\n                      \
    \  waterLevel[currentRow][column] += 1\n                        currentRow -=\
    \ 1\n                    }\n                    grid[row][column] = 0\n      \
    \              filledCount -= 1\n                    moves += 1\n            \
    \    }\n            }\n        }\n    }\n    return moves", "    guard capacity\
    \ != 0 else { return 0 }\n    let all_row_max = grid.map { $0.max() ?? 0 }\n \
    \   let max_per_col = zip(all_row_max.indices, all_row_max).reduce(into: [:])\
    \ { res, next in\n        if res[next.0] == nil {\n            res[next.0] = next.1\n\
    \        } else {\n            res[next.0] = max(res[next.0]!, next.1)\n     \
    \   }\n    }\n    return all_row_max.map { $0 / capacity }.reduce(0, +) + max_per_col.map\
    \ { $0.value / capacity }.reduce(0, +)", "    var numFills = 0\n    let rows =\
    \ grid.count\n    let cols = grid[0].count\n    for i in 0..<rows {\n        for\
    \ j in 0..<cols {\n            if grid[i][j] == 1 {\n                numFills\
    \ += 1\n                _ = fill(grid: &grid, row: i, col: j, capacity: capacity)\n\
    \            }\n        }\n    }\n    return numFills", "    guard grid.count\
    \ > 0 else { return 0 }\n    guard grid[0].count > 0 else { return 0 }\n    guard\
    \ capacity > 0 else { return 0 }\n    \n    var numOfFills = 0\n    var numOfColumns\
    \ = grid[0].count\n    var numOfRows = grid.count\n    var maxRowLevel = [Int](repeating:\
    \ 0, count: numOfColumns)\n    var maxColumnLevel = [Int](repeating: 0, count:\
    \ numOfRows)\n    \n    // Fill the maxRowLevel and maxColumnLevel arrays\n  \
    \  for i in 0..<numOfRows {\n        for j in 0..<numOfColumns {\n           \
    \ if grid[i][j] == 1 {\n                maxRowLevel[j] += 1\n                maxColumnLevel[i]\
    \ += 1\n            }\n        }\n    }\n    \n    // Remove empty columns\n \
    \   let maxRowLevelIndices = maxRowLevel.enumerated().filter({ $0.element > 0\
    \ }).map({ $0.offset })\n    numOfColumns = maxRowLevelIndices.count\n    maxRowLevel\
    \ = maxRowLevelIndices.map({ maxRowLevel[$0] })\n    \n    // Remove empty rows\n\
    \    let maxColumnLevelIndices = maxColumnLevel.enumerated().filter({ $0.element\
    \ > 0 }).map({ $0.offset })\n    numOfRows = maxColumnLevelIndices.count\n   \
    \ maxColumnLevel = maxColumnLevelIndices.map({ maxColumnLevel[$0] })\n    \n \
    \   // Find the row and column with the lowest level of water\n    var lowestLevelIndex\
    \ = 0\n    for (i, level) in maxRowLevel.enumerated() {\n        if level < maxRowLevel[lowestLevelIndex]\
    \ {\n            lowestLevelIndex = i\n        }\n    }\n    for (i, level) in\
    \ maxColumnLevel.enumerated() {\n        if level < maxColumnLevel[lowestLevelIndex]\
    \ {\n            lowestLevelIndex = i\n        }\n    }\n    \n    // Fill the\
    \ bucket\n    while !(maxRowLevel.allSatisfy({ $0 == 0 }) && maxColumnLevel.allSatisfy({\
    \ $0 ==", "    var pass = 0\n    var remaining = 0\n    for i in 0..<grid.count\
    \ {\n        for j in 0..<grid[i].count {\n            remaining += grid[i][j]\n\
    \            if remaining >= capacity {\n                pass += 1\n         \
    \       remaining = 0\n            }\n        }\n        remaining = 0\n    }\n\
    \    return pass", "  let width = grid[0].count\n  var buckets = [Int](repeating:\
    \ 0, count: width)\n  var drops = 0\n  for row in grid {\n    for i in 0..<width\
    \ {\n      if row[i] == 1 {\n        buckets[i] += 1\n      }\n    }\n    var\
    \ is_empty = true\n    for i in 0..<width {\n      if buckets[i] > 0 {\n     \
    \   is_empty = false\n        break\n      }\n    }\n    if is_empty {\n     \
    \ break\n    }\n    drops += 1\n    for i in 0..<width {\n      buckets[i] -=\
    \ min(buckets[i], capacity)\n    }\n  }\n  return drops", "    let grid = grid.filter\
    \ { !$0.isEmpty }\n    guard !grid.isEmpty else { return 0 }\n    var buckets\
    \ = [Int](repeating: 0, count: grid[0].count)\n    var num_empties = 0\n    for\
    \ row in grid {\n        var num_empties_in_row = 0\n        for i in row.indices\
    \ {\n            let num_units = row[i]\n            let bucket_of_well = buckets[i]\n\
    \            if num_units == 0 {\n                num_empties_in_row += 1\n  \
    \          } else if bucket_of_well < capacity {\n                num_empties_in_row\
    \ += 1\n                buckets[i] += 1\n            }\n        }\n        if\
    \ num_empties_in_row > 0 {\n            num_empties += 1\n        }\n    }\n \
    \   return num_empties", "  var total_fill = 0\n\n  for row in grid {\n    total_fill\
    \ += row.filter { $0 == 1 }.count\n  }\n\n  return total_fill / capacity", " \
    \   let rows = grid.count\n    let cols = grid[0].count\n    var processed = grid\n\
    \    var count = 0\n    for j in 0..<cols {\n        for i in 0..<rows {\n   \
    \         if processed[i][j] == 1 {\n                if capacity == 1 {\n    \
    \                count += 1\n                } else {\n                    let\
    \ possibleCapacity = rows - i\n                    let remaining = (possibleCapacity\
    \ <= capacity) ? possibleCapacity : capacity\n                    count += remaining\n\
    \                    for k in i..<i+remaining {\n                        processed[k][j]\
    \ = 0\n                    }\n                }\n            }\n        }\n  \
    \  }\n    return count", "    var solution = 0\n    for i in 0..<grid.count {\n\
    \        var level = grid[i].reduce(0, +)\n        if level > 0 {\n          \
    \  solution += 1\n            let times = level / capacity\n            level\
    \ -= times * capacity\n            solution += times\n        }\n        solution\
    \ += level\n    }\n    return solution", "    if grid.isEmpty {\n        return\
    \ 0\n    }\n    var res = 0\n    for row in grid {\n        var sum = 0\n    \
    \    for column in row {\n            sum += column\n            if sum > capacity\
    \ {\n                res += sum - capacity\n                sum = capacity\n \
    \           }\n        }\n    }\n    return res", "    if grid.allSatisfy({ $0.allSatisfy({\
    \ $0 == 0 }) }) {\n        return 0\n    }\n    if grid.allSatisfy({ $0.allSatisfy({\
    \ $0 == 1 }) }) {\n        return grid.count\n    }\n    let m = grid.count\n\
    \    let n = grid[0].count\n    let target = grid.reduce(0, { $0 + $1.reduce(0,\
    \ +) })\n    let max_capacity = min(capacity, n)\n    var res = 0\n    var filled\
    \ = 0\n    while filled < target {\n        let next = grid.enumerated().map {\
    \ (i, row) -> [Int] in\n            var row = row\n            let wells = row.filter({\
    \ $0 == 1 })\n            if wells.count > max_capacity {\n                row.replaceSubrange(0...max_capacity\
    \ - 1, with: Array(repeating: 1, count: max_capacity))\n            }\n      \
    \      return row\n        }\n        filled = next.reduce(0, { $0 + $1.reduce(0,\
    \ +) })\n        res += 1\n        grid = next\n    }\n    return res", '  return
    1', "  guard grid.count > 0, grid[0].count > 0 else { return 0 }\n  var count\
    \ = 0\n  for i in 0..<grid.count {\n    for j in 0..<grid[i].count {\n      if\
    \ grid[i][j] == 1 {\n        grid[i][j] = 0\n        if i - 1 >= 0 && grid[i -\
    \ 1][j] == 1 {\n          grid[i - 1][j] = 0\n        }\n        if j - 1 >= 0\
    \ && grid[i][j - 1] == 1 {\n          grid[i][j - 1] = 0\n        }\n        count\
    \ += 1\n      }\n    }\n  }\n  return count", "\tvar grid = grid\n\tvar cnt =\
    \ 0\n\tfor column in grid.first!.indices {\n\t\tvar bucket = capacity\n\t\tfor\
    \ row in grid.indices {\n\t\t\tif grid[row][column] == 1 {\n\t\t\t\tif bucket\
    \ > 0 {\n\t\t\t\t\tgrid[row][column] = 0\n\t\t\t\t\tbucket -= 1\n\t\t\t\t} else\
    \ {\n\t\t\t\t\tbucket = capacity\n\t\t\t\t\tcnt += 1\n\t\t\t\t}\n\t\t\t}\n\t\t\
    }\n\t}\n\treturn cnt", "    var actions = 0\n    while grid.reduce(0, { $0 + $1.reduce(0,\
    \ +) }) > 0 {\n        for row in grid {\n            var currentRow = row\n \
    \           for index in currentRow.indices {\n                if currentRow[index]\
    \ > 0 {\n                    if index < currentRow.count - 1 {\n             \
    \           currentRow[index + 1] = min(currentRow[index + 1] + currentRow[index],\
    \ capacity)\n                    }\n                    currentRow[index] = 0\n\
    \                }\n            }\n            grid[grid.firstIndex(of: row)!]\
    \ = currentRow\n        }\n        actions += 1\n    }\n    return actions", " \
    \   guard grid.count > 0 else { return 0 }\n    let length = grid[0].count\n \
    \   var levels = Array(repeating: 0, count: length)\n    var empties = 0\n   \
    \ for i in 0..<grid.count {\n        for j in 0..<length {\n            if grid[i][j]\
    \ == 1 {\n                levels[j] += 1\n            } else {\n             \
    \   empties += 1\n            }\n        }\n    }\n    for _ in 0..<capacity {\n\
    \        var min = Int.max\n        var min_index = -1\n        for i in 0..<length\
    \ {\n            if levels[i] < min {\n                min = levels[i]\n     \
    \           min_index = i\n            }\n        }\n        if min_index == -1\
    \ {\n            break\n        }\n        levels[min_index] += 1\n        empties\
    \ -= 1\n    }\n    return length * capacity - empties", "    var water: Int =\
    \ 0\n    for row in grid {\n        water += row.reduce(0, +)\n    }\n    var\
    \ max_fills: Int = 0\n    while water > 0 {\n        var filled: Int = 0\n   \
    \     for (i, row) in grid.enumerated() {\n            var drops: Int = 0\n  \
    \          while drops < capacity && filled < water {\n                if row[i]\
    \ == 1 {\n                    drops += 1\n                    filled += 1\n  \
    \              }\n            }\n        }\n        water -= filled\n        max_fills\
    \ += 1\n    }\n    return max_fills", "    //TODO: implement this\n    return\
    \ 0", "    let length = grid.first?.count ?? 0\n    guard length > 0 else { return\
    \ 0 }\n    var count = 0\n    var max_idx = 0\n    var min_idx = 0\n    repeat\
    \ {\n        let row = grid[max_idx]\n        var temp_min_idx = min_idx\n   \
    \     for (idx, water) in row.enumerated() {\n            if water == 1 {\n  \
    \              temp_min_idx = idx\n                break\n            }\n    \
    \    }\n        for idx in stride(from: max_idx, to: min_idx - 1, by: -1) {\n\
    \            guard idx > 0 else { break }\n            let row = grid[idx]\n \
    \           if row[temp_min_idx] == 1 {\n                min_idx = idx\n     \
    \           break\n            }\n        }\n        if max_idx - min_idx + 1\
    \ > capacity {\n            count += 1\n            max_idx = min_idx\n      \
    \  } else {\n            max_idx += 1\n        }\n    } while max_idx < length\n\
    \    return count", "  var total = 0\n  let rowCount = grid.count\n  for i in\
    \ 0..<rowCount {\n    for j in 0..<grid[i].count {\n      if grid[i][j] == 1 {\n\
    \        total += capacity\n      }\n    }\n  }\n  return total", "    // your\
    \ code here\n    var queue = [[Int]]()\n    var visited = Set<[Int]>()\n    var\
    \ count = 0\n    for (y, row) in grid.enumerated() {\n        for (x, cell) in\
    \ row.enumerated() {\n            if cell == 1 {\n                queue.append([x,\
    \ y])\n                visited.insert([x, y])\n            }\n        }\n    }\n\
    \    while !queue.isEmpty {\n        let current = queue.removeLast()\n      \
    \  count += 1\n        let dirs = [[0, 1], [0, -1], [1, 0], [-1, 0]]\n       \
    \ for dir in dirs {\n            let x = current[0] + dir[0]\n            let\
    \ y = current[1] + dir[1]\n            if y >= 0 && y < grid.count && x >= 0 &&\
    \ x < grid[0].count && grid[y][x] + 1 <= capacity && !visited.contains([x, y])\
    \ {\n                queue.append([x, y])\n                visited.insert([x,\
    \ y])\n            }\n        }\n    }\n    return count", "    let wellCount\
    \ = grid.count\n    let rowLength = grid[0].count\n    var bucketDepth = 0\n \
    \   var time = 0\n    while bucketDepth < capacity {\n        bucketDepth += wellCount\n\
    \        if bucketDepth > capacity {\n            bucketDepth -= wellCount\n \
    \           break\n        }\n        time += rowLength\n    }\n    for row in\
    \ grid {\n        time += row.filter { $0 == 1 }.count\n    }\n    return time",
  "    let rows = grid.count\n    let columns = grid[0].count\n    let totalWells\
    \ = rows * columns\n    var totalFill = 0\n    var emptyWells = 0\n    var previousColumns\
    \ = [Int]()\n    for row in grid {\n        for (i, well) in row.enumerated()\
    \ {\n            if well == 1 {\n                if i == 0 {\n               \
    \     // Well is the first in a row, determine what to do\n                  \
    \  totalFill += capacity\n                } else {\n                    // Well\
    \ is not the first in a row, determine what to do\n                    if previousColumns[i]\
    \ > capacity {\n                        // Current well is not full and the previous\
    \ one is\n                        totalFill += capacity\n                    }\
    \ else {\n                        // Current well is not full but the previous\
    \ one is\n                        totalFill += capacity - previousColumns[i]\n\
    \                    }\n                }\n            } else {\n            \
    \    emptyWells += 1\n            }\n            previousColumns[i] = well\n \
    \       }\n    }\n    if emptyWells == totalWells {\n        return 0\n    }\n\
    \    return totalFill", "    var bucket = capacity\n    var action = 0\n    for\
    \ row in grid {\n        var prev = 0\n        for cell in row {\n           \
    \ if prev == 0 {\n                if cell == 1 {\n                    prev = bucket\n\
    \                    action += 1\n                }\n            } else {\n  \
    \              if cell == 1 {\n                    if prev < bucket {\n      \
    \                  action += 1\n                    }\n                    prev\
    \ = bucket\n                } else {\n                    prev -= 1\n        \
    \        }\n            }\n        }\n    }\n    return action", "    var queue\
    \ = [Point(x: 0, y: 0)]\n    var grid = grid\n    var visits = Set<Point>()\n\
    \    var count = 0\n    while !queue.isEmpty {\n        var newPoints = [Point]()\n\
    \        while !queue.isEmpty {\n            let current = queue.removeFirst()\n\
    \            if grid[current.y][current.x] == 1 {\n                if grid[current.y][current.x]\
    \ > capacity {\n                    print(\"here\")\n                }\n     \
    \           grid[current.y][current.x] = 0\n                count += 1\n     \
    \       }\n            let neighbors = [Point(x: current.x + 1, y: current.y),\n\
    \                             Point(x: current.x - 1, y: current.y),\n       \
    \                      Point(x: current.x, y: current.y + 1),\n              \
    \               Point(x: current.x, y: current.y - 1)]\n            for neighbor\
    \ in neighbors {\n                if grid.indices.contains(neighbor.y) && grid[neighbor.y].indices.contains(neighbor.x)\
    \ &&\n                    !visits.contains(neighbor) {\n                    newPoints.append(neighbor)\n\
    \                    visits.insert(neighbor)\n                }\n            }\n\
    \        }\n        queue = newPoints\n    }\n    return count", '    return 0',
  "    func moveBucket(bucket: (y: Int, x: Int), water: Int) -> (y: Int, x: Int) {\n\
    \        var bucket = bucket\n        var water = water\n        while bucket.y\
    \ < grid.count {\n            water -= grid[bucket.y][bucket.x]\n            bucket.y\
    \ += 1\n            if water < 0 {\n                bucket.y -= 1\n          \
    \      water += grid[bucket.y][bucket.x]\n                break\n            }\n\
    \        }\n        return bucket\n    }\n    \n    var moves = 0\n    var bucket\
    \ = (y: 0, x: 0)\n    var water = capacity\n    while bucket.y != grid.count {\n\
    \        let start = bucket\n        bucket = moveBucket(bucket: bucket, water:\
    \ water)\n        water = capacity\n        moves += 1\n        if start.y ==\
    \ bucket.y {\n            moves -= 1\n            bucket.x += 1\n            if\
    \ bucket.x == grid[0].count {\n                break\n            }\n        }\n\
    \    }\n    return moves", '    return 0', "    var total = 0\n    for arr in\
    \ grid {\n        let min = arr.min()!\n        if (min < capacity) {\n      \
    \      let _ = arr.map {\n                total += capacity - $0\n           \
    \ }\n        }\n    }\n    return total", "    /// Extract the wells' depths\n\
    \    let depths = grid.map { $0.reduce(0, +) }\n    /// Sorted in descending order\n\
    \    let sortedDepths = depths.sorted { $0 > $1 }\n    /// The final result\n\
    \    var fillCount = 0\n    /// The bucket(s) remaining fill\n    var bucketCapacity\
    \ = capacity\n    /// Cycle through the wells in descending order of depth\n \
    \   for depth in sortedDepths {\n        /// Is the bucket empty?\n        if\
    \ bucketCapacity == 0 {\n            /// Use another bucket\n            bucketCapacity\
    \ = capacity\n            /// Increase the number of buckets used\n          \
    \  fillCount += 1\n        }\n        /// Empty the well\n        bucketCapacity\
    \ -= depth\n    }\n    /// Return the final result\n    return fillCount", " \
    \   var grid = grid\n    var count = 0\n    var rowMax: Int?\n    var colMax:\
    \ Int?\n    var colIndex: Int?\n    var rowIndex: Int?\n    let gridHeight = grid.count\n\
    \    let gridWidth = grid[0].count\n    while true {\n        var firstNonZeroIndex:\
    \ Int?\n        for row in 0..<gridHeight {\n            for col in 0..<gridWidth\
    \ {\n                if grid[row][col] != 0 {\n                    firstNonZeroIndex\
    \ = row\n                    break\n                }\n            }\n       \
    \     if firstNonZeroIndex != nil {\n                break\n            }\n  \
    \      }\n        if firstNonZeroIndex == nil {\n            return count\n  \
    \      }\n        for row in firstNonZeroIndex!..<gridHeight {\n            for\
    \ col in 0..<gridWidth {\n                if grid[row][col] != 0 {\n         \
    \           rowMax = grid[row].max()\n                    colMax = nil\n     \
    \               colIndex = nil\n                    rowIndex = nil\n         \
    \           for col1 in 0..<gridWidth {\n                        if grid[row][col1]\
    \ == rowMax {\n                            colMax = rowMax\n                 \
    \           colIndex = col1\n                            rowIndex = row\n    \
    \                        break\n                        }\n                  \
    \  }\n                    if colMax != nil {\n                        break\n\
    \                    }\n                }\n            }\n            if colMax\
    \ != nil {\n                break\n            }\n        }\n        if colMax\
    \ == nil {\n            return count\n        }\n        count += 1\n        var\
    \ currentRow = rowIndex!\n        var currentCol = colIndex!\n        var current\
    \ = grid[currentRow][currentCol]\n        while current > 0 {\n            if\
    \ current > capacity {\n                let newValue = current - capacity\n  \
    \              grid[currentRow][currentCol] = newValue\n                current\
    \ = newValue\n            } else {\n                grid[currentRow][currentCol]\
    \ = 0\n                current = 0\n            }\n            currentRow += 1\n\
    \            if currentRow == gridHeight {\n                currentRow = 0\n \
    \               currentCol += 1\n                if currentCol == gridWidth {\n\
    \                    currentCol = 0\n                }\n            }\n      \
    \  }\n    }", "    var grid = grid\n    let rows = grid.count\n    let cols =\
    \ grid[0].count\n    var count = 0\n    while true {\n        var max = 0\n  \
    \      var max_i = 0\n        var max_j = 0\n        var min = capacity\n    \
    \    var min_i = 0\n        var min_j = 0\n        var is_empty = true\n     \
    \   for i in 0..<rows {\n            for j in 0..<cols {\n                if grid[i][j]\
    \ == 1 {\n                    is_empty = false\n                    if max < grid[i][j]\
    \ {\n                        max = grid[i][j]\n                        max_i =\
    \ i\n                        max_j = j\n                    }\n              \
    \  } else {\n                    if min > grid[i][j] {\n                     \
    \   min = grid[i][j]\n                        min_i = i\n                    \
    \    min_j = j\n                    }\n                }\n            }\n    \
    \    }\n        if is_empty {\n            break\n        }\n        if max ==\
    \ capacity {\n            // move max to min\n            count += (min_i - max_i).abs()\
    \ + (min_j - max_j).abs()\n            grid[min_i][min_j] = max\n            grid[max_i][max_j]\
    \ = 0\n        } else {\n            // increase max\n            count += 1\n\
    \            grid[max_i][max_j] += 1\n        }\n    }\n    return count", " \
    \   /// Fill in your solution here\n    var matrix = grid\n    let row = grid.count\n\
    \    let col = grid[0].count\n    var ret = 0\n    for i in 0..<row {\n      \
    \  for j in 0..<col {\n            var ele = matrix[i][j]\n            if ele\
    \ != 0 {\n                ele = 1\n                ret += 1\n            }\n \
    \           for k in (j+1)..<col {\n                if ele < capacity {\n    \
    \                ele += matrix[i][k]\n                    matrix[i][k] = 0\n \
    \               }\n            }\n        }\n    }\n    return ret", "  let wells\
    \ = grid.map { $0.map { $0 == 1 ? capacity : 0 } }\n  var to_fill = wells.flatMap\
    \ { $0 }.filter { $0 > 0 }\n  var times = 0\n  while !to_fill.isEmpty {\n    let\
    \ size = to_fill.count\n    var filling = Array(repeating: 0, count: size)\n \
    \   for i in 0..<size {\n      filling[i] = min(capacity, to_fill[i])\n    }\n\
    \    for i in 0..<size {\n      let len = wells.count\n      if i % len < len\
    \ - 1 {\n        filling[i + 1] += filling[i]\n      }\n      if i / len < len\
    \ - 1 {\n        filling[i + len] += filling[i]\n      }\n    }\n    to_fill =\
    \ filling.map { max(0, $0 - capacity) }\n    times += 1\n  }\n  return times -\
    \ 1", "    // Replace the following to finish this function implementation.\n\
    \    return 0", "    // put your code here\n    return 0", "    guard grid.count\
    \ > 0 else { return 0 }\n    guard capacity > 0 else { return 0 }\n    let row_length\
    \ = grid[0].count\n    var max_water = 0\n    for row in grid {\n        guard\
    \ row.count == row_length else { return 0 }\n        for i in 0..<row.count {\n\
    \            if row[i] == 1 {\n                let diff = capacity - row[i]\n\
    \                if diff > 0 {\n                    max_water += diff\n      \
    \          }\n            }\n        }\n    }\n    return max_water", "    guard\
    \ grid.count > 0 else { return 0 }\n    var count = 0\n    let rowCount = grid.count\n\
    \    let colCount = grid[0].count\n    let fillAmount = rowCount * capacity\n\
    \    for col in 0..<colCount {\n        var sum = 0\n        for row in 0..<rowCount\
    \ {\n            sum += grid[row][col]\n        }\n        if sum == 0 { continue\
    \ }\n        let fillCount = (sum + capacity - 1) / capacity\n        count +=\
    \ fillCount\n    }\n    return count", "    // return number of times you need\
    \ to lower the buckets\n    return 0", "    let sums = grid.map { $0.reduce(0,\
    \ +) }\n    var maxFill = 0\n    for sum in sums {\n        maxFill += (sum +\
    \ capacity - 1) / capacity\n    }\n    return maxFill", "    var filled = 0\n\
    \    var buckets_used = 0\n    for i in 0..<grid.count {\n        var extracted\
    \ = 0\n        for j in 0..<grid[i].count {\n            extracted += grid[i][j]\n\
    \            if extracted > capacity {\n                filled += capacity\n \
    \               extracted -= capacity\n                buckets_used += 1\n   \
    \         }\n        }\n        filled += extracted\n        buckets_used += 1\n\
    \    }\n    return buckets_used", '    return 0', "    let n = grid.count\n  \
    \  let m = grid[0].count\n    var buckets = Array(repeating: capacity, count:\
    \ m)\n    var times = 0\n    for row in grid {\n        for (j, item) in row.enumerated()\
    \ {\n            if item == 1 && buckets[j] > 0 {\n                buckets[j]\
    \ -= 1\n                times += 1\n            }\n        }\n    }\n    return\
    \ times", '    return 0', '    return 0', "    let wells = grid.count\n    let\
    \ wellWidth = grid[0].count\n    let statesPerWell = capacity + 1\n    let totalStates\
    \ = statesPerWell * wells\n    var cost: [Int] = Array(repeating: Int.max, count:\
    \ totalStates)\n    let targets = grid.map { row in row.reduce(0, +) }\n    //\
    \ look at the first column and compute the cost to get to it\n    for i in 0..<wells\
    \ {\n        let row = grid[i]\n        for j in 0..<wellWidth {\n           \
    \ if row[j] == 1 {\n                let state = capacity * i + j\n           \
    \     cost[state] = j\n            }\n        }\n    }\n    for i in 0..<wells\
    \ {\n        let row = grid[i]\n        for j in 0..<wellWidth {\n           \
    \ if row[j] == 1 {\n                // compute the cost to reach this well from\
    \ the previous wells\n                let state = capacity * i + j\n         \
    \       let costToReach = cost[state]\n                let target = targets[i]\n\
    \                // a) compute cost to move to the previous well at a lower column\n\
    \                for k in 0..<i {\n                    let targetReached = min(targets[k],\
    \ j)\n                    let prevState = capacity * k + targetReached\n     \
    \               let prevCost = cost[prevState]\n                    if costToReach\
    \ > prevCost {\n                        cost[state] = prevCost\n             \
    \       }\n                }\n                // b) compute cost to move to the\
    \ previous well at a higher column\n                for k in 0..<i {\n       \
    \             let targetReached = min(targets[k], j)\n                    let\
    \ prevState = capacity * k + targetReached\n                    let prevCost =\
    \ cost[prevState]\n                    if costToReach > prevCost {\n         \
    \               cost[state] = prevCost\n                    }\n              \
    \  }\n            }\n        }\n    }\n    let finalCost = grid.last!.reduce(Int.max,\
    \ { min($0, $1) })\n    return finalCost", "    var waterLevels = Array(repeating:\
    \ 0, count: grid[0].count)\n    var numOfOperations = 0\n    while(true) {\n \
    \       numOfOperations += 1\n        for j in 0..<grid[0].count {\n         \
    \   waterLevels[j] += grid[0][j]\n            if(waterLevels[j] > capacity) {\n\
    \                return -1\n            }\n        }\n        if(waterLevels.allSatisfy({\
    \ $0 == capacity })) {\n            return numOfOperations\n        }\n      \
    \  for i in 0..<grid.count-1 {\n            for j in 0..<grid[0].count {\n   \
    \             if(waterLevels[j] > 0) {\n                    waterLevels[j] -=\
    \ 1\n                    grid[i][j] = 0\n                    grid[i+1][j] = 1\n\
    \                }\n            }\n        }\n    }", "    // your code here\n\
    \    return 0", "    let rows = grid.count\n    let cols = grid[0].count\n   \
    \ var turns = 0\n    var filled = 0\n    var filledRows = [Int](repeating: 0,\
    \ count: rows)\n    while true {\n        var full = 0\n        for r in 0..<rows\
    \ {\n            for c in 0..<cols {\n                if grid[r][c] == 1 && filledRows[r]\
    \ < capacity {\n                    filledRows[r] += 1\n                    filled\
    \ += 1\n                }\n                if filledRows[r] == capacity {\n  \
    \                  full += 1\n                }\n            }\n        }\n  \
    \      if full == rows {\n            break\n        }\n        turns += 1\n \
    \   }\n    return turns * capacity - filled", "    precondition(grid.count > 0)\n\
    \    precondition(grid[0].count > 0)\n    precondition(capacity > 0)\n    precondition(grid.count\
    \ <= 100)\n    precondition(grid[0].count <= 100)\n    precondition(capacity <=\
    \ 10)\n    for row in grid {\n        for i in row {\n            precondition(i\
    \ == 0 || i == 1)\n        }\n    }\n    return 0", "\treturn 0", "    if grid.count\
    \ == 0 {\n        return 0\n    }\n    if grid[0].count == 0 {\n        return\
    \ 0\n    }\n    var level = 0\n    var full = 0\n    var next = 0\n    for row\
    \ in grid {\n        for cell in row {\n            if cell == 1 {\n         \
    \       full += 1\n            }\n        }\n    }\n    if full == 0 {\n     \
    \   return 0\n    }\n    var height = 0\n    for _ in 0..<grid.count {\n     \
    \   height += 1\n        level = next\n        next = 0\n        for row in grid\
    \ {\n            for cell in row {\n                if cell == 1 {\n         \
    \           full -= 1\n                }\n            }\n        }\n        if\
    \ full == 0 {\n            return height\n        }\n        if full <= level\
    \ {\n            return height\n        }\n        next = full - level\n    }\n\
    \    return height", "    var wells_data = [Well]()\n    for well in grid {\n\
    \        wells_data.append(Well(water: well, bucket_capacity: capacity))\n   \
    \ }\n    var bucket_passes = 0\n    for well in wells_data {\n        bucket_passes\
    \ += well.bucket_passes\n    }\n    return bucket_passes", '    return 0', " \
    \   precondition(capacity > 0, \"Capacity should be > 0\")\n    precondition(!grid.isEmpty,\
    \ \"Grid can't be empty\")\n    let maxFills = calculateMaxFills(for: grid, with:\
    \ capacity)\n    return reduceNumberOfLowers(for: maxFills)", "    if grid.count\
    \ == 0 {\n        return 0\n    }\n    if grid[0].count == 0 {\n        return\
    \ 0\n    }\n    var new_grid = grid\n    let max = grid.count\n    let full =\
    \ grid[0].count\n    var fill = 0\n    while new_grid.reduce(false, { $0 || $1.reduce(false,\
    \ { $0 || $1 == 1 }) }) {\n        for i in 0..<max {\n            if new_grid[i].reduce(false,\
    \ { $0 || $1 == 1 }) {\n                fill += 1\n                for j in 0..<full\
    \ {\n                    new_grid[i][j] = max(0, new_grid[i][j] - capacity)\n\
    \                }\n            }\n        }\n    }\n    return fill", "    var\
    \ filled = grid.map { _ in [Int](repeating: 0, count: grid[0].count) }\n    var\
    \ fill_count = 0\n    while true {\n        var non_empty_cell_exists = false\n\
    \        for i in 0..<grid.count {\n            for j in 0..<grid[0].count {\n\
    \                if grid[i][j] == 1 {\n                    non_empty_cell_exists\
    \ = true\n                    let fill_count_required = filled[i][j] + 1\n   \
    \                 if fill_count_required > capacity {\n                      \
    \  return fill_count\n                    }\n                    for k in 0..<grid.count\
    \ {\n                        filled[k][j] = fill_count_required\n            \
    \        }\n                }\n            }\n        }\n        if !non_empty_cell_exists\
    \ {\n            return fill_count\n        }\n        fill_count += 1\n    }",
  "    let rowCount = grid.count\n    let colCount = grid[0].count\n    var grid =\
    \ grid\n    var moves = 0\n    for _ in 0..<rowCount {\n        for col in 0..<colCount\
    \ {\n            if grid[0][col] == 1 {\n                moves += 1\n        \
    \        grid[0][col] = 0\n            }\n        }\n        for row in 0..<rowCount-1\
    \ {\n            for col in 0..<colCount {\n                if grid[row][col]\
    \ == capacity {\n                    grid[row][col] = 0\n                    grid[row+1][col]\
    \ = 1\n                }\n            }\n        }\n    }\n    return moves",
  "    var buckets = [Int](repeating: 0, count: grid[0].count)\n    var drops = 0\n\
    \    for i in 0..<grid.count {\n        for j in 0..<grid[i].count {\n       \
    \     let waterInWell = grid[i][j]\n            let waterInBucket = buckets[j]\n\
    \            let availableSpace = capacity - waterInBucket\n            if waterInWell\
    \ > availableSpace {\n                buckets[j] = capacity\n                drops\
    \ += 1\n            } else {\n                buckets[j] += waterInWell\n    \
    \            drops += 1\n            }\n        }\n    }\n    return drops", " \
    \   var max_depth = 0\n    for row in grid {\n        max_depth = max(max_depth,\
    \ row.reduce(0, +))\n    }\n    var iterations = 0\n    while max_depth > 0 {\n\
    \        let fill_count = fill_from_bottom(grid: grid, row_count: grid.count,\
    \ col_count: grid[0].count, depth: max_depth, capacity: capacity)\n        iterations\
    \ += fill_count\n        max_depth -= fill_count\n    }\n    return iterations",
  "    guard grid.count > 0 else { return 0 }\n    guard capacity > 0 else { return\
    \ 0 }\n    let columnsCount = grid[0].count\n    var counter = 0\n    for row\
    \ in grid {\n        var sum = 0\n        for column in row {\n            if\
    \ column == 1 {\n                sum += 1\n            }\n        }\n        var\
    \ cycles = Int(sum / capacity)\n        if sum % capacity != 0 {\n           \
    \ cycles += 1\n        }\n        counter += cycles\n    }\n    return counter\
    \ * capacity"]
stop_tokens:
- "\n}"
