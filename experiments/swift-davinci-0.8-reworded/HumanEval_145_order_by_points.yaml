name: HumanEval_145_order_by_points
language: swift
prompt: "\n/// Write a function which sorts the given array of integers\n/// in ascending\
  \ order according to the sum of their digits.\n/// Note: if there are several items\
  \ with similar sum of their digits,\n/// order them based on their index in original\
  \ array.\n/// For example:\n/// >>> order_by_points(nums: [1, 11, -1, -11, -12])\n\
  /// [-1, -11, 1, -12, 11]\n/// >>> order_by_points(nums: [] as [Int])\n/// [] as\
  \ [Int]\nfunc order_by_points(nums: [Int]) -> [Int] {\n"
tests: "}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if\
  \ left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left,\
  \ right) {\n        if l != r {\n            return false\n        }\n    }\n  \
  \  return true\n}\n            \nassert(order_by_points(nums: [1, 11, -1, -11, -12])\
  \ == [-1, -11, 1, -12, 11])\nassert(order_by_points(nums: [1234, 423, 463, 145,\
  \ 2, 423, 423, 53, 6, 37, 3457, 3, 56, 0, 46]) == [0, 2, 3, 6, 53, 423, 423, 423,\
  \ 1234, 145, 37, 46, 56, 463, 3457])\nassert(order_by_points(nums: [] as [Int])\
  \ == [] as [Int])\nassert(order_by_points(nums: [1, -11, -32, 43, 54, -98, 2, -3])\
  \ == [-3, -32, -98, -11, 1, 2, 43, 54])\nassert(order_by_points(nums: [1, 2, 3,\
  \ 4, 5, 6, 7, 8, 9, 10, 11]) == [1, 10, 2, 11, 3, 4, 5, 6, 7, 8, 9])\nassert(order_by_points(nums:\
  \ [0, 6, 6, -76, -21, 23, 4]) == [-76, -21, 0, 4, 23, 6, 6])"
completions: ["    var digitSum = [Int: Int]()\n    for i in 0..<nums.count {\n  \
    \      digitSum[i] = sum_of_digits(nums[i])\n    }\n    var result = nums\n  \
    \  result.sort { (a, b) -> Bool in\n        if digitSum[a]! > digitSum[b]! {\n\
    \            return false\n        } else if digitSum[a]! < digitSum[b]! {\n \
    \           return true\n        } else {\n            return a < b\n        }\n\
    \    }\n    return result", "    var result: [Int] = []\n    var index: [Int]\
    \ = []\n    var nums = nums\n    while nums.count > 0 {\n        var max_value\
    \ = nums[0]\n        var max_index = 0\n        for (i,value) in nums.enumerated()\
    \ {\n            if value_sum(num: value) > value_sum(num: max_value) {\n    \
    \            max_value = value\n                max_index = i\n            }\n\
    \        }\n        result.append(max_value)\n        index.append(max_index)\n\
    \        nums.remove(at: max_index)\n    }\n    return result", "    var sorted_nums\
    \ = [Int]()\n    let sums = nums.map { $0.sum_of_digits() }\n    var indices =\
    \ 0 ..< nums.count\n    indices.sort { sums[$0] < sums[$1] }\n    for index in\
    \ indices {\n        sorted_nums.append(nums[index])\n    }\n    return sorted_nums",
  "  return nums.sorted(by: { (num1, num2) -> Bool in\n    var num1Copy = num1\n \
    \   var num2Copy = num2\n    var sum1 = 0\n    var sum2 = 0\n    while num1Copy\
    \ != 0 {\n      sum1 += num1Copy % 10\n      num1Copy /= 10\n    }\n    while\
    \ num2Copy != 0 {\n      sum2 += num2Copy % 10\n      num2Copy /= 10\n    }\n\
    \    return sum1 < sum2\n  })", "  let sum = nums.map{ return $0.sumOfDigits()\
    \ }\n  return sum.enumerated().sorted(by: { $0.element < $1.element }).map{ return\
    \ nums[$0.offset] }", "  if nums.isEmpty {\n    return []\n  }\n  return nums.map\
    \ { return ($0, nums.reduce(0, { $0 + $1 })) }\n    .sorted { $0.1 < $1.1 }\n\
    \    .map { $0.0 }", "    var result: [Int] = []\n    var copy_of_nums = nums\n\
    \    while copy_of_nums.count > 0 {\n        var temp_dic = [Int: Int]()\n   \
    \     for j in 0..<copy_of_nums.count {\n            var temp_sum = 0\n      \
    \      for i in String(copy_of_nums[j]) {\n                temp_sum += Int(String(i))!\n\
    \            }\n            temp_dic[copy_of_nums[j]] = temp_sum\n        }\n\
    \        var temp_array = temp_dic.sorted(by: {$0.value < $1.value})\n       \
    \ result.append(temp_array[0].key)\n        copy_of_nums.remove(at: copy_of_nums.index(of:\
    \ temp_array[0].key)!)\n    }\n    return result", "    // your code here\n  \
    \  return nums.sorted { (i, j) -> Bool in\n        sum_of_digits(i) == sum_of_digits(j)\
    \ ? nums.firstIndex(of: i)! < nums.firstIndex(of: j)! : sum_of_digits(i) < sum_of_digits(j)\n\
    \    }", "    // guard nums.count > 0 else { return nums }\n    // return nums.sorted(by:\
    \ { $0.digitsSum == $1.digitsSum ? $0 < $1 : $0.digitsSum < $1.digitsSum })\n\
    \    return nums.sorted(by: { ($0.digitsSum, $0) < ($1.digitsSum, $1) })", '    return
    nums.sorted(by: { sum_of_digits(num: $0) < sum_of_digits(num: $1) })', "    \n\
    \    var result = [Int]()\n    var dict = [Int: Int]()\n    \n    for num in nums\
    \ {\n        dict[num] = num.abs.sum_of_digits()\n    }\n    \n    dict.keys.sorted\
    \ {\n        if dict[$0] == dict[$1] {\n            return nums.firstIndex(of:\
    \ $0)! < nums.firstIndex(of: $1)!\n        }\n        return dict[$0]! < dict[$1]!\n\
    \    }.forEach {\n        result.append($0)\n    }\n    \n    return result",
  "    \n    var nums = nums\n    var sumOfDigits = [Int]()\n    \n    for num in\
    \ nums {\n        var digits = 0\n        var num = num\n        while num !=\
    \ 0 {\n            digits += num % 10\n            num /= 10\n        }\n    \
    \    sumOfDigits.append(digits)\n    }\n    \n    for i in 0..<nums.count {\n\
    \        for j in i+1..<nums.count {\n            if sumOfDigits[i] > sumOfDigits[j]\
    \ {\n                (sumOfDigits[i], sumOfDigits[j]) = (sumOfDigits[j], sumOfDigits[i])\n\
    \                (nums[i], nums[j]) = (nums[j], nums[i])\n            }\n    \
    \    }\n    }\n    \n    return nums", "    return nums.sorted { lhs, rhs in\n\
    \        sumOfDigits(lhs) < sumOfDigits(rhs)\n    }", "    if nums.isEmpty {\n\
    \        return []\n    }\n    else {\n        var arrayOfTuples = [(Int, Int)]()\n\
    \        for item in nums {\n            var count = 0\n            if item <\
    \ 0 {\n                item *= -1\n            }\n            for item2 in String(item)\
    \ {\n                count += Int(String(item2))!\n            }\n           \
    \ arrayOfTuples.append((item, count))\n        }\n        arrayOfTuples.sort {\
    \ $0.1 < $1.1 }\n        var result = [Int]()\n        for item in arrayOfTuples\
    \ {\n            result.append(item.0)\n        }\n        return result\n   \
    \ }", "    // return nums.sorted {\n    //     var a = $0, b = $1\n    //    \
    \ while a > 0 {\n    //         $0 += a % 10\n    //         a /= 10\n    // \
    \    }\n    //     while b > 0 {\n    //         $1 += b % 10\n    //        \
    \ b /= 10\n    //     }\n    //     return $0 < $1\n    // }\n    return nums.sorted\
    \ {\n        var a = 0, b = 0\n        for c in String($0).map({Int(String($0))!})\
    \ {\n            a += c\n        }\n        for c in String($1).map({Int(String($0))!})\
    \ {\n            b += c\n        }\n        return a < b\n    }", "    // TODO:\
    \ Write your solution here\n    return nums", "    return nums.sorted { (a, b)\
    \ -> Bool in\n        var sum_a = 0\n        var sum_b = 0\n        for c in String(a)\
    \ {\n            sum_a += Int(String(c))!\n        }\n        for c in String(b)\
    \ {\n            sum_b += Int(String(c))!\n        }\n        return sum_a < sum_b\n\
    \    }", '    return nums.sorted(by: { sumOfDigits(n: $0) < sumOfDigits(n: $1)
    })', "    return nums.sorted(by: { (a, b) -> Bool in\n        let sum1 = sum_of_digits(num:\
    \ a)\n        let sum2 = sum_of_digits(num: b)\n        if sum1 != sum2 {\n  \
    \          return sum1 < sum2\n        } else {\n            return a < b\n  \
    \      }\n    })", "    \n    //TODO: write your function here\n    return []",
  "    var sum = [(Int, Int)]()\n    for (i, num) in nums.enumerated() {\n       \
    \ sum.append((num, i))\n    }\n    sum.sort { a, b in\n        if a.0 >= 0 {\n\
    \            a.0 % 10 + a.0 / 10 > b.0 % 10 + b.0 / 10\n        } else {\n   \
    \         a.0 % 10 + a.0 / 10 < b.0 % 10 + b.0 / 10\n        }\n    }\n    var\
    \ result = [Int]()\n    for (_, i) in sum {\n        result.append(nums[i])\n\
    \    }\n    return result", "    return nums.sorted(by: {\n        let n1 = $0\
    \ > 0 ? $0 : -$0\n        let n2 = $1 > 0 ? $1 : -$1\n        let (d1, r1) = n1.quotientAndRemainder(dividingBy:\
    \ 10)\n        let (d2, r2) = n2.quotientAndRemainder(dividingBy: 10)\n      \
    \  if (d1 + r1) == (d2 + r2) {\n            return $0 < $1\n        }\n      \
    \  return (d1 + r1) < (d2 + r2)\n    })", "    // your code here\n    return nums.sorted(by:\
    \ {\n        let digits = Array(String($0).map({ Int(String($0))! }))\n      \
    \  let digits2 = Array(String($1).map({ Int(String($0))! }))\n        return digits.reduce(0,\
    \ +) < digits2.reduce(0, +)\n    })", "    var sumOfNumbers = [Int: Int]()\n \
    \   for i in 0..<nums.count {\n        let sum = nums[i].sumDigits()\n       \
    \ sumOfNumbers[i] = sum\n    }\n    let result = sumOfNumbers.sorted { $0.value\
    \ < $1.value }\n    var sortedArray = [Int]()\n    for i in 0..<result.count {\n\
    \        sortedArray.append(nums[result[i].key])\n    }\n    return sortedArray",
  "    var maxDigitSum = 0\n    var sumToIndex = [Int: Int]()\n    var sortedArr =\
    \ [Int]()\n    \n    for (i, num) in nums.enumerated() {\n        var digitSum\
    \ = 0\n        var temp = num\n        while temp != 0 {\n            digitSum\
    \ += temp % 10\n            temp /= 10\n        }\n        sumToIndex[digitSum]\
    \ = i\n        maxDigitSum = max(maxDigitSum, digitSum)\n    }\n    \n    for\
    \ i in 0...maxDigitSum {\n        if let index = sumToIndex[i] {\n           \
    \ sortedArr.append(nums[index])\n        }\n    }\n    \n    return sortedArr",
  "    let newNums = nums.map { toSum($0) }\n    let combo = zip(newNums, nums)\n\
    \    let sorted = combo.sorted { $0.0 < $1.0 }\n    return sorted.map { $0.1 }",
  "    return nums.sorted {\n        if nums.isEmpty {\n            return false\n\
    \        }\n        let first = \"\\($0)\".compactMap { Int(String($0)) }.reduce(0,\
    \ +)\n        let second = \"\\($1)\".compactMap { Int(String($0)) }.reduce(0,\
    \ +)\n        return first < second\n    }", "    let sorted = nums.enumerated().sorted\
    \ { (x, y) -> Bool in\n        let xDigits = String(x.element).compactMap { Int(String($0))\
    \ }\n        let yDigits = String(y.element).compactMap { Int(String($0)) }\n\
    \        return xDigits.reduce(0, +) < yDigits.reduce(0, +)\n    }\n    return\
    \ sorted.map { $0.element }", "    var nums = nums\n    for _ in 0..<nums.count\
    \ {\n        for j in 1..<nums.count {\n            let v1 = sum_of_digits(nums[j\
    \ - 1])\n            let v2 = sum_of_digits(nums[j])\n            if v1 > v2 {\n\
    \                swap(&nums[j - 1], &nums[j])\n            }\n        }\n    }\n\
    \    return nums", "    if nums.isEmpty {\n        return []\n    }\n    return\
    \ nums.sorted { x, y in\n        let a = sum_of_digits(x)\n        let b = sum_of_digits(y)\n\
    \        if a == b {\n            return x < y\n        }\n        return a <\
    \ b\n    }", "    return nums.sorted { (a, b) -> Bool in\n        var aDigits\
    \ = 0\n        var bDigits = 0\n        for i in 0..<numDigits(n: a) {\n     \
    \       aDigits += (a / Int(pow(10, Double(i)))) % 10\n        }\n        for\
    \ i in 0..<numDigits(n: b) {\n            bDigits += (b / Int(pow(10, Double(i))))\
    \ % 10\n        }\n        return aDigits < bDigits\n    }", "    let sorted =\
    \ nums.sorted { (left, right) -> Bool in\n        let leftSum = abs(left).digits.reduce(0,\
    \ +)\n        let rightSum = abs(right).digits.reduce(0, +)\n        return leftSum\
    \ == rightSum ? left < right : leftSum < rightSum\n    }\n    return sorted",
  "    guard nums.count > 0 else { return [] }\n    return nums.sorted { (lhs, rhs)\
    \ -> Bool in\n        let l = lhs.digits.reduce(0, +)\n        let r = rhs.digits.reduce(0,\
    \ +)\n        return l < r\n    }", "    // your code here\n    return []", '    return
    nums.sorted(by: {(a: Int, b: Int) -> Bool in return get_sum_of_digits(a) < get_sum_of_digits(b)})',
  "    if nums.isEmpty {\n        return []\n    }\n    var numsCopy = nums\n    var\
    \ sums: [Int] = []\n    for i in 0..<nums.count {\n        let sum = nums[i].sumOfDigits()\n\
    \        sums.append(sum)\n    }\n    let sortedSums: [Int] = sortArray(nums:\
    \ sums)\n    var sortedArray: [Int] = []\n    var index: Int = 0\n    for j in\
    \ 0..<sortedSums.count {\n        for k in 0..<nums.count {\n            if nums[k].sumOfDigits()\
    \ == sortedSums[j] {\n                sortedArray.append(nums[k])\n          \
    \      index = k\n                break\n            }\n        }\n        numsCopy.remove(at:\
    \ index)\n    }\n    return sortedArray", "    return nums.sorted(by: { (num1,\
    \ num2) -> Bool in\n        let a = abs(num1)\n        let b = abs(num2)\n   \
    \     let sumA = sumDigits(of: a)\n        let sumB = sumDigits(of: b)\n     \
    \   return sumA == sumB ? a < b : sumA < sumB\n    })", "  return nums.sorted\
    \ {\n    var s1 = 0\n    var s2 = 0\n    for char in \"\\($0)\".characters {\n\
    \      s1 += Int(String(char))!\n    }\n    for char in \"\\($1)\".characters\
    \ {\n      s2 += Int(String(char))!\n    }\n    return s1 < s2\n  }", "    var\
    \ nums = nums\n    let sorted = nums.sorted { (a, b) -> Bool in\n        return\
    \ a.digitSum() < b.digitSum()\n    }\n    return sorted", "    return nums.sorted(by:\
    \ {\n        let a = String($0).map({ Int(String($0)) ?? 0 }).reduce(0, +)\n \
    \       let b = String($1).map({ Int(String($0)) ?? 0 }).reduce(0, +)\n      \
    \  return a < b\n    })", "    var result: [Int] = []\n    var sumDict: [Int:\
    \ Int] = [:]\n    for (index, value) in nums.enumerated() {\n        let sum =\
    \ sumDigits(num: value)\n        sumDict[sum] = index\n    }\n    for sum in sumDict.keys.sorted()\
    \ {\n        let index = sumDict[sum]!\n        result.append(nums[index])\n \
    \   }\n    return result", "    let sum_digits = { $0.digits.reduce(0, +) }\n\
    \    return nums.sorted { (sum_digits($0) == sum_digits($1)) ? ($0 < $1) : (sum_digits($0)\
    \ < sum_digits($1)) }", "    \n    return nums.sorted(by: { (left, right) -> Bool\
    \ in\n        let leftSum = left < 0 ? left * -1 : left\n        let rightSum\
    \ = right < 0 ? right * -1 : right\n        return leftSum < rightSum\n    })",
  "    if nums.isEmpty {\n        return []\n    } else {\n        var nums = nums\n\
    \        for i in 0...nums.count - 1 {\n            for j in 0...nums.count -\
    \ 1 {\n                if sumOfDigits(nums[i]) < sumOfDigits(nums[j]) {\n    \
    \                let tmp = nums[i]\n                    nums[i] = nums[j]\n  \
    \                  nums[j] = tmp\n                }\n            }\n        }\n\
    \        return nums\n    }", "    var dict = [Int: [Int]]()\n    for (idx, i)\
    \ in nums.enumerated() {\n        let sum = i < 0 ? -i.digits.reduce(0, +) : i.digits.reduce(0,\
    \ +)\n        if dict[sum] == nil {\n            dict[sum] = [i]\n        } else\
    \ {\n            dict[sum]?.append(i)\n        }\n    }\n    let keys = dict.keys.sorted()\n\
    \    var res = [Int]()\n    for k in keys {\n        res.append(contentsOf: dict[k]!)\n\
    \    }\n    return res", '    return nums.sorted { $0.digits.reduce(0, +) < $1.digits.reduce(0,
    +) }', "    return nums.sorted { (a, b) -> Bool in\n        let aLength = a.description.count\n\
    \        let bLength = b.description.count\n        return aLength < bLength\n\
    \    }", "    // Dictionary to hold (key, value) pairs\n    var dict = [Int: Int]()\n\
    \    // Retrieve the sum of the digits for each integer and store it in dict\n\
    \    for num in nums {\n        dict[num] = sumOfDigits(num: num)\n    }\n   \
    \ // Sort the dictionary from low to high key values\n    let sortedDict = dict.sorted\
    \ { $0.key < $1.key }\n    // Print the sorted dictionary\n    for (key, value)\
    \ in sortedDict {\n        print(\"\\(key): \\(value)\")\n    }\n    // Create\
    \ a new array to hold the sorted values\n    var sortedArray = [Int]()\n    //\
    \ Add the array values to the sortedArray in ascending order by sum of digits\n\
    \    for num in nums {\n        if sumOfDigits(num: num) == sortedDict[0].value\
    \ {\n            sortedArray.append(num)\n        }\n    }\n    // Print the sorted\
    \ array\n    print(sortedArray)\n    return sortedArray", "    if nums.isEmpty\
    \ {\n        return []\n    }\n    var nums = nums\n    var newNums = [Int]()\n\
    \    var sumNums = [Int]()\n    for i in 0..<nums.count {\n        let newNum\
    \ = nums[i]\n        let sumNum = newNum.arrayOfDigits().reduce(0, +)\n      \
    \  sumNums.append(sumNum)\n    }\n    for _ in 0..<nums.count {\n        let index\
    \ = sumNums.firstIndex(of: sumNums.min()!)!\n        newNums.append(nums[index])\n\
    \        sumNums.remove(at: index)\n        nums.remove(at: index)\n    }\n  \
    \  return newNums", "    guard nums.count > 0 else { return nums }\n    return\
    \ nums.sorted(by: {\n        return sum_digits(num: $0) < sum_digits(num: $1)\n\
    \    })", "    if nums.isEmpty {\n        return []\n    }\n    let arr = nums.enumerated().sorted\
    \ { first, second in\n        (getDigitsSum(value: first.element) < getDigitsSum(value:\
    \ second.element))\n            || (getDigitsSum(value: first.element) == getDigitsSum(value:\
    \ second.element) && first.offset < second.offset)\n    }\n    return arr.map\
    \ { $0.element }", "    var numsDict: [Int: Int] = [:]\n    for i in 0..<nums.count\
    \ {\n        let numStr = String(nums[i])\n        var sum = 0\n        for j\
    \ in 0..<numStr.count {\n            sum += Int(String(numStr[numStr.index(numStr.startIndex,\
    \ offsetBy: j)]))!\n        }\n        numsDict[nums[i]] = sum\n    }\n    return\
    \ nums.sorted { numsDict[$0]! < numsDict[$1]! }", "    // FIXME: Implement!\n\
    \    return []", "    var result: [Int] = []\n    var sums: [Int] = []\n    var\
    \ dictionary = [Int: Int]()\n    var sum = 0\n    for (index, num) in nums.enumerated()\
    \ {\n        if num >= 0 {\n            sum = num % 10 + num / 10\n        } else\
    \ {\n            sum = -(num % 10 + num / 10)\n        }\n        sums.append(sum)\n\
    \        dictionary[sum] = index\n    }\n    sums.sort()\n    for sum in sums\
    \ {\n        result.append(nums[dictionary[sum]!])\n    }\n    return result",
  '    return nums.sorted { sum_of_digits(nums: $0) == sum_of_digits(nums: $1) ? $0
    < $1 : sum_of_digits(nums: $0) < sum_of_digits(nums: $1) }', "    return nums.sorted\
    \ {\n        let lhsScore = $0.digits.reduce(0, +)\n        let rhsScore = $1.digits.reduce(0,\
    \ +)\n        if lhsScore == rhsScore {\n            return nums.firstIndex(of:\
    \ $0)! < nums.firstIndex(of: $1)!\n        }\n        return lhsScore < rhsScore\n\
    \    }", "    guard nums.count > 0 else {\n        return []\n    }\n    var result:\
    \ [Int] = []\n    var dict: [Int: [Int]] = [:]\n    var totalSum = 0\n    for\
    \ num in nums {\n        totalSum = 0\n        for char in String(num) {\n   \
    \         let d = Int(String(char))!\n            totalSum += d\n        }\n \
    \       if dict[totalSum] == nil {\n            dict[totalSum] = [num]\n     \
    \   } else {\n            dict[totalSum]?.append(num)\n        }\n    }\n    for\
    \ i in dict.keys.sorted() {\n        let v = dict[i]\n        result.append(contentsOf:\
    \ v!)\n    }\n    return result", "    return nums.sorted(by: {\n        func\
    \ sumDigits(number: Int) -> Int {\n            return String(number).map { Int(String($0))!\
    \ }.reduce(0, +)\n        }\n        return sumDigits(number: $0) < sumDigits(number:\
    \ $1)\n    })", "    let sum = nums.map { Int(String($0).reduce(0, +))! }\n  \
    \  return nums.enumerated().sorted { sum[$0.offset] < sum[$1.offset] }.map { $0.element\
    \ }", '    return nums.sorted(by: { $0.digits.reduce(0, +) < $1.digits.reduce(0,
    +) })', "    return nums.sorted { (first, second) -> Bool in\n        return first.sumOfDigits()\
    \ < second.sumOfDigits()\n    }", "    var nums = nums\n    return nums.sorted\
    \ { (first: Int, second: Int) -> Bool in\n        var i = first, j = second\n\
    \        var sum_i = 0, sum_j = 0\n        while i != 0 {\n            sum_i +=\
    \ i % 10\n            i /= 10\n        }\n        while j != 0 {\n           \
    \ sum_j += j % 10\n            j /= 10\n        }\n        return sum_i < sum_j\n\
    \    }", '    return nums.sorted(by: { digitSum(a: $0) < digitSum(a: $1) })',
  "    return nums.sorted(by: { (i1, i2) -> Bool in\n        return i1.digits.reduce(0,\
    \ +) < i2.digits.reduce(0, +)\n    })", '    return nums.sorted(by: {$0.digits.sum()
    < $1.digits.sum()})', "    var m = [Int: [Int]]()\n    for num in nums {\n   \
    \     let digits = Array(String(num)).map{ Int(String($0))! }\n        let sum\
    \ = digits.reduce(0, +)\n        if m[sum] == nil {\n            m[sum] = [num]\n\
    \        } else {\n            m[sum]!.append(num)\n        }\n    }\n    var\
    \ sums = Array(m.keys)\n    sums.sort()\n    var res = [Int]()\n    for sum in\
    \ sums {\n        m[sum]!.sort()\n        res.append(contentsOf: m[sum]!)\n  \
    \  }\n    return res", '    return []', "    var sorted = nums.enumerated().sorted(by:\
    \ { (arg0, arg1) -> Bool in\n        let (index0, num0) = arg0\n        let (index1,\
    \ num1) = arg1\n        let digitSum0 = digitSum(num: num0)\n        let digitSum1\
    \ = digitSum(num: num1)\n        if digitSum0 == digitSum1 {\n            return\
    \ index0 < index1\n        }\n        return digitSum0 < digitSum1\n    })\n \
    \   return sorted.map { $0.element }", "    return nums.sorted { (first, second)\
    \ -> Bool in\n        if first.digitSum() == second.digitSum() {\n           \
    \ return first < second\n        }\n        return first.digitSum() < second.digitSum()\n\
    \    }", '  return []', "    return nums.sorted {\n        let x = $0.digits.reduce(0,\
    \ +)\n        let y = $1.digits.reduce(0, +)\n        return x < y\n    }", " \
    \   // your code goes here\n    return nums.sorted(by: {\n        let s1 = $0.digits.reduce(0,\
    \ +)\n        let s2 = $1.digits.reduce(0, +)\n        return s1 < s2\n    })",
  "    return nums.sorted { (lhs, rhs) -> Bool in\n        let sumOfDigitsOfLhs =\
    \ lhs.digits.reduce(0, +)\n        let sumOfDigitsOfRhs = rhs.digits.reduce(0,\
    \ +)\n        return sumOfDigitsOfLhs == sumOfDigitsOfRhs ? lhs < rhs : sumOfDigitsOfLhs\
    \ < sumOfDigitsOfRhs\n    }", "    // your code here\n    return []", "    guard\
    \ nums.count > 0 else { return nums }\n    var result = nums\n    let points =\
    \ nums.map { $0.digits.reduce(0, +) }\n    let tuples = zip(points, result)\n\
    \    let sortedTuples = tuples.sorted { $0.0 < $1.0 }\n    for (index, item) in\
    \ sortedTuples.enumerated() {\n        result[index] = item.1\n    }\n    return\
    \ result", "    var newArr = [Int]()\n    var keys = [Int]()\n    var index =\
    \ 0\n    var sum = 0\n    var newDict = [Int: Int]()\n    var sortedDict = [Int:\
    \ Int]()\n    var newDictKeys = [Int]()\n    var newDictValues = [Int]()\n   \
    \ \n    for i in nums {\n        keys.append(i)\n        newDict[i] = 0\n    \
    \    for j in String(i) {\n            if j != \"-\" {\n                sum +=\
    \ Int(String(j))!\n            }\n        }\n        newDict[i] = sum\n      \
    \  sum = 0\n    }\n    \n    sortedDict = newDict.sorted(by: { $0.value < $1.value\
    \ })\n    \n    for (key, _) in sortedDict {\n        newDictKeys.append(key)\n\
    \    }\n    \n    for _ in newDictKeys {\n        newDictValues.append(newDict[newDictKeys[index]]!)\n\
    \        index += 1\n    }\n    \n    for _ in keys {\n        for _ in newDictValues\
    \ {\n            if keys[index] == newDictKeys[index] {\n                newArr.append(keys[index])\n\
    \            }\n        }\n        index += 1\n    }\n    \n    return newArr",
  '    return nums.sorted(by: { sum($0) < sum($1) })', "    // TODO: your code here\n\
    \    return []", "    var list = nums\n    list.sort {(lhs, rhs) -> Bool in\n\
    \        var lhs_digits = digits(num: lhs)\n        var rhs_digits = digits(num:\
    \ rhs)\n        let lhs_total = sum_digits(lhs_digits)\n        let rhs_total\
    \ = sum_digits(rhs_digits)\n        if lhs_total == rhs_total {\n            return\
    \ lhs < rhs\n        }\n        return lhs_total < rhs_total\n    }\n    return\
    \ list", "    var tupleArray: [(value: Int, sum: Int)] = []\n    for num in nums\
    \ {\n        var sum = 0\n        var tempNum = num\n        while tempNum !=\
    \ 0 {\n            sum += tempNum % 10\n            tempNum /= 10\n        }\n\
    \        tupleArray.append((num, sum))\n    }\n    tupleArray.sort {\n       \
    \ if $0.sum == $1.sum {\n            return $0.value < $1.value\n        }\n \
    \       return $0.sum < $1.sum\n    }\n    return tupleArray.map { $0.value }",
  "    return nums.sorted { (a, b) -> Bool in\n        var a_n = abs(a)\n        var\
    \ b_n = abs(b)\n        var a_sum = 0\n        var b_sum = 0\n        while a_n\
    \ > 0 {\n            a_sum += a_n % 10\n            a_n /= 10\n        }\n   \
    \     while b_n > 0 {\n            b_sum += b_n % 10\n            b_n /= 10\n\
    \        }\n        return a_sum < b_sum\n    }", "    let result = nums.enumerated().sorted(by:\
    \ { (a, b) -> Bool in\n        let digitsSumA = a.element.digitsSum()\n      \
    \  let digitsSumB = b.element.digitsSum()\n        return digitsSumA < digitsSumB\
    \ || (digitsSumA == digitsSumB && a.offset < b.offset)\n    })\n    return result.map({\
    \ $0.element })", "    let result = nums.sorted { n1, n2 in\n        let n1Sum\
    \ = sum_of_digits(n1)\n        let n2Sum = sum_of_digits(n2)\n        if n1Sum\
    \ == n2Sum {\n            return n1 < n2\n        }\n        return n1Sum < n2Sum\n\
    \    }\n    return result", "    let sumOfDigits = nums.map{ abs($0) }.map{ $0.digits.reduce(0,\
    \ +) }\n    return zip(nums, sumOfDigits).sorted(by: {$0.1 < $1.1}).map{ $0.0\
    \ }", "    // fill in your code here\n    return nums", "    let digits = nums.map\
    \ { sumOfDigits(int: $0) }\n    var result = [Int]()\n    var i = 0\n    while\
    \ result.count < nums.count {\n        var min = digits[i]\n        var minIndex\
    \ = i\n        for j in i..<digits.count {\n            if digits[j] < min {\n\
    \                min = digits[j]\n                minIndex = j\n            }\n\
    \        }\n        result.append(nums[minIndex])\n        i = minIndex + 1\n\
    \    }\n    return result", "    if nums.isEmpty {\n        return []\n    }\n\
    \    var result = nums\n    for i in 0...result.count-1 {\n        for j in 0...result.count-2\
    \ {\n            if (result[j] < 0 && result[j+1] > 0) || (result[j] < 0 && result[j+1]\
    \ < 0 && sum_of_digits(result[j]) > sum_of_digits(result[j+1])) || (result[j]\
    \ > 0 && result[j+1] > 0 && sum_of_digits(result[j]) > sum_of_digits(result[j+1]))\
    \ {\n                result.swapAt(j, j+1)\n            }\n        }\n    }\n\
    \    return result", "    var dict: [Int: [Int]] = [:]\n    var result: [Int]\
    \ = []\n    var currentSum: Int = 0\n    var currentInt: Int = 0\n    var currentKey:\
    \ Int = 0\n    var key: Int = 0\n    for num in nums {\n        currentSum = 0\n\
    \        currentInt = abs(num)\n        while currentInt != 0 {\n            currentSum\
    \ += currentInt % 10\n            currentInt /= 10\n        }\n        dict[currentSum]\
    \ = []\n    }\n    for num in nums {\n        currentSum = 0\n        currentInt\
    \ = abs(num)\n        while currentInt != 0 {\n            currentSum += currentInt\
    \ % 10\n            currentInt /= 10\n        }\n        dict[currentSum]?.append(num)\n\
    \    }\n    for key in dict.keys.sorted() {\n        result += dict[key]!\n  \
    \  }\n    return result", "    return nums.sorted(by: {\n        if num_digits(num:\
    \ $0) == num_digits(num: $1) {\n            return $0 < $1\n        }\n      \
    \  return num_digits(num: $0) < num_digits(num: $1)\n    })", "    let sums =\
    \ nums.map { $0 < 0 ? abs($0) : $0 }.map { String($0).compactMap { Int(String($0))\
    \ }.reduce(0, +) }\n    var result = nums\n    for i in (0..<result.count).reversed()\
    \ {\n        for j in 1..<i {\n            if sums[j - 1] > sums[j] {\n      \
    \          sums.swapAt(j - 1, j)\n                result.swapAt(j - 1, j)\n  \
    \          }\n        }\n    }\n    return result", "    // Write your code here\n\
    \    return []", "    if nums.isEmpty {\n        return []\n    }\n    var newNums\
    \ = nums\n    for index in 0...newNums.count - 1 {\n        for j in 0...newNums.count\
    \ - 1 - index {\n            if sumDigits(num: newNums[j]) > sumDigits(num: newNums[j\
    \ + 1]) {\n                let temp = newNums[j]\n                newNums[j] =\
    \ newNums[j + 1]\n                newNums[j + 1] = temp\n            }\n     \
    \   }\n    }\n    return newNums", "  return nums.sorted {\n    let firstSum =\
    \ abs($0).digits.reduce(0, +)\n    let secondSum = abs($1).digits.reduce(0, +)\n\
    \    return firstSum == secondSum ? nums.firstIndex(of: $0)! < nums.firstIndex(of:\
    \ $1)! : firstSum < secondSum\n  }", '    return []', "    return nums.sorted\
    \ { (x, y) -> Bool in\n        let sumX = sum_of_digits(num: x)\n        let sumY\
    \ = sum_of_digits(num: y)\n        if sumX == sumY {\n            return nums.firstIndex(of:\
    \ x)! < nums.firstIndex(of: y)!\n        }\n        return sumX < sumY\n    }",
  "    return nums.sorted {\n        return Sum(a: nums[$0]) < Sum(a: nums[$1])\n\
    \    }", "    var temp: [Int] = []\n    for i in nums {\n        temp.append(i)\n\
    \    }\n    return temp.sorted{sum(of: $0) < sum(of: $1)}", "    // Write your\
    \ solution here\n    return nums.sorted { (left, right) -> Bool in\n        let\
    \ leftSum = left.digits.reduce(0, +)\n        let rightSum = right.digits.reduce(0,\
    \ +)\n        return leftSum == rightSum ? left < right : leftSum < rightSum\n\
    \    }", "    return nums.sorted(by: {\n        sum_of_digits(of: $0) < sum_of_digits(of:\
    \ $1)\n    })", '  return []', "    let dict = nums.reduce(into: [Int: Int]())\
    \ { (dict, num) in\n        dict[num] = num.digits.reduce(0, +)\n    }\n    return\
    \ nums.sorted { dict[$0]! < dict[$1]! }", "    // TODO: Solve the challenge here!\n\
    \    return nums", "    // TODO: implement the task\n    return []", "    return\
    \ nums.sorted { (left, right) -> Bool in\n        let left_sum = left.digits.reduce(0,\
    \ +)\n        let right_sum = right.digits.reduce(0, +)\n        return left_sum\
    \ < right_sum\n    }", '    // your code goes here...', "    let sumOfDigits =\
    \ nums.map { (value) -> (Int, Int) in\n        var sum = 0\n        var num =\
    \ value\n        while num != 0 {\n            sum += num % 10\n            num\
    \ /= 10\n        }\n        return (value, sum)\n    }\n    return sumOfDigits.sorted(by:\
    \ { $0.1 < $1.1 }).map { $0.0 }", "    return nums.sorted(by: {\n        var aVal\
    \ = abs(a)\n        var bVal = abs(b)\n        var aSum = 0\n        var bSum\
    \ = 0\n        while aVal > 0 {\n            aSum += aVal % 10\n            aVal\
    \ /= 10\n        }\n        while bVal > 0 {\n            bSum += bVal % 10\n\
    \            bVal /= 10\n        }\n        return aSum < bSum\n    })", "   \
    \ if nums.isEmpty {\n        return []\n    }\n    var numbers = nums\n    numbers.sort\
    \ { a, b in\n        let digitA = Array(String(a)).map { Int(String($0))! }.reduce(0,\
    \ +)\n        let digitB = Array(String(b)).map { Int(String($0))! }.reduce(0,\
    \ +)\n        return digitA < digitB\n    }\n    return numbers", "    return\
    \ nums.sorted {\n        sum_of_digits(num: $0) == sum_of_digits(num: $1) ? $0\
    \ < $1 : sum_of_digits(num: $0) < sum_of_digits(num: $1)\n    }", "    return\
    \ nums.sorted { (a, b) -> Bool in\n        let ad = a.digits.reduce(0, +)\n  \
    \      let bd = b.digits.reduce(0, +)\n        return ad < bd\n    }", "    return\
    \ nums.sorted { lhs, rhs in\n        return Int(String(abs(lhs)).reduce(0, +))\
    \ < Int(String(abs(rhs)).reduce(0, +))\n    }", "    return nums.sorted { (x,\
    \ y) -> Bool in\n        var xSum = 0\n        var ySum = 0\n        for i in\
    \ x.description {\n            guard let xNext = Int(String(i)) else { return\
    \ false }\n            xSum += xNext\n        }\n        for i in y.description\
    \ {\n            guard let yNext = Int(String(i)) else { return false }\n    \
    \        ySum += yNext\n        }\n        return xSum < ySum\n    }", "    return\
    \ nums.sorted {\n        let s1 = String($0)\n        let s2 = String($1)\n  \
    \      let d1 = s1.digits.reduce(0, +)\n        let d2 = s2.digits.reduce(0, +)\n\
    \        return d1 < d2 || (d1 == d2 && s1.compare(s2) == .orderedAscending)\n\
    \    }", "    var mutableNums = nums\n    for i in 0..<mutableNums.count - 1 {\n\
    \        for j in 0..<mutableNums.count - i - 1 {\n            if sumOfDigits(num:\
    \ mutableNums[j]) > sumOfDigits(num: mutableNums[j + 1]) {\n                mutableNums.swapAt(j,\
    \ j + 1)\n            }\n        }\n    }\n    return mutableNums", "    return\
    \ nums.sorted {\n        let left = String($0).reduce(0) { $0 + Int(String($1))!\
    \ }\n        let right = String($1).reduce(0) { $0 + Int(String($1))! }\n    \
    \    return left < right\n    }", "    return nums.sorted { (int1, int2) -> Bool\
    \ in\n        var a = 0\n        var b = 0\n        var num = int1\n        while\
    \ num != 0 {\n            a += num % 10\n            num /= 10\n        }\n  \
    \      num = int2\n        while num != 0 {\n            b += num % 10\n     \
    \       num /= 10\n        }\n        return a < b\n    }", '    return nums.sorted(by:
    { sum_of_digits(n: $0) < sum_of_digits(n: $1) })', "    return nums.sorted { (lhs,\
    \ rhs) -> Bool in\n        sum_of_digits(num: lhs) < sum_of_digits(num: rhs)\n\
    \    }", "    guard nums.count > 0 else {\n        return []\n    }\n    let res\
    \ = nums.enumerated().sorted { (arg0, arg1) -> Bool in\n        let (index1, num1)\
    \ = arg0\n        let (index2, num2) = arg1\n        let num1 = String(abs(num1))\n\
    \        let num2 = String(abs(num2))\n        if num1.reduce(0, {$0 + Int(String($1))!})\
    \ == num2.reduce(0, {$0 + Int(String($1))!}) {\n            return index1 < index2\n\
    \        }\n        return num1.reduce(0, {$0 + Int(String($1))!}) < num2.reduce(0,\
    \ {$0 + Int(String($1))!})\n    }\n    return res.map { $0.element }", "    return\
    \ nums.sorted { lhs, rhs in\n        lhs.digitsSum < rhs.digitsSum\n    }", " \
    \   if nums.isEmpty {\n        return []\n    }\n    let sorted = nums.sorted\
    \ { abs($0) % 10 + abs($0) / 10 < abs($1) % 10 + abs($1) / 10 }\n    return sorted",
  "    var result = nums\n    result.sort { a, b in\n        (a.digits.reduce(0, +)\
    \ > b.digits.reduce(0, +)) || (a.digits.reduce(0, +) == b.digits.reduce(0, +)\
    \ && a < b)\n    }\n    return result", "    var nums = nums\n    for i in 0..<nums.count\
    \ {\n        for j in i..<nums.count {\n            let numsI = Array(String(nums[i]).map{Int(String($0))!})\n\
    \            let numsJ = Array(String(nums[j]).map{Int(String($0))!})\n      \
    \      if numsI.reduce(0, +) > numsJ.reduce(0, +) {\n                nums.swapAt(i,\
    \ j)\n            }\n        }\n    }\n    return nums", '    return nums.sorted(by:
    { sumOfDigits(num: $0) < sumOfDigits(num: $1) })', "  if nums.isEmpty {\n    return\
    \ []\n  }\n  var result: [(Int, Int)] = nums.map { ($0, $0.digits.reduce(0, +))\
    \ }\n  result.sort { (first, second) -> Bool in\n    if first.1 == second.1 {\n\
    \      return first.0 < second.0\n    }\n    return first.1 < second.1\n  }\n\
    \  return result.map { $0.0 }", "    // Your code here\n    return nums.sorted(by:\
    \ {sum_of_digits(num: $0) < sum_of_digits(num: $1)})", "    \n    let sumDigits\
    \ = nums.map { $0.digitsSum }\n    let sortedSumDigits = sumDigits.sorted()\n\
    \    var temp: [Int] = []\n    \n    for i in sortedSumDigits {\n        for j\
    \ in nums {\n            if j.digitsSum == i {\n                temp.append(j)\n\
    \            }\n        }\n    }\n    return temp", "    var nums = nums\n   \
    \ return nums.sorted(by: { (a, b) -> Bool in\n        let l1 = String(a).compactMap{Int(String($0))}.reduce(0,\
    \ +)\n        let l2 = String(b).compactMap{Int(String($0))}.reduce(0, +)\n  \
    \      return l1 < l2\n    })", "    return nums.sorted { (num1, num2) -> Bool\
    \ in\n        sumOfDigits(n: num1) < sumOfDigits(n: num2)\n    }", "    if nums.isEmpty\
    \ {\n        return []\n    }\n    return nums.sorted { (a, b) -> Bool in\n  \
    \      var aSum = 0\n        var bSum = 0\n        a.digits.forEach { aSum +=\
    \ $0 }\n        b.digits.forEach { bSum += $0 }\n        if aSum == bSum {\n \
    \           return a < b\n        }\n        return aSum < bSum\n    }", '    return
    [1, 2, 3]', "    return nums.sorted(by: {\n        var n1 = $0\n        var n2\
    \ = $1\n        var s1 = 0\n        var s2 = 0\n        while n1 != 0 {\n    \
    \        s1 += n1 % 10\n            n1 /= 10\n        }\n        while n2 != 0\
    \ {\n            s2 += n2 % 10\n            n2 /= 10\n        }\n        return\
    \ s1 < s2\n    })", "  guard nums.count > 0 else { return nums }\n  var nums =\
    \ nums\n  return nums.sorted(by: { sum_of_digits(num: $0) < sum_of_digits(num:\
    \ $1) })", "    var result: [Int] = []\n    for number in nums {\n        var\
    \ tempArr: [Int] = []\n        var index = 0\n        for char in String(number)\
    \ {\n            tempArr.append(Int(String(char))!)\n            index += 1\n\
    \        }\n        var sum = 0\n        for number in tempArr {\n           \
    \ sum += number\n        }\n        result.append(sum)\n    }\n    return result",
  "    return nums.sorted { (lhs, rhs) -> Bool in\n        let lhsSum = sumOfDigits(n:\
    \ lhs)\n        let rhsSum = sumOfDigits(n: rhs)\n        return lhsSum < rhsSum\n\
    \    }", "    let sorted = nums.sorted { (first, second) -> Bool in\n        if\
    \ sum_of_digits(number: first) == sum_of_digits(number: second) {\n          \
    \  return first < second\n        }\n        return sum_of_digits(number: first)\
    \ < sum_of_digits(number: second)\n    }\n    return sorted", '    return nums.sorted(by:
    {$0.sumOfDigits() == $1.sumOfDigits() ? $0 < $1 : $0.sumOfDigits() < $1.sumOfDigits()})',
  "    return nums.sorted { (lhs, rhs) -> Bool in\n        lhs.digitsSum() < rhs.digitsSum()\n\
    \    }", "    var nums = nums\n    nums.sort {\n        if sum_of_digits(num:\
    \ $0) == sum_of_digits(num: $1) {\n            return $0 < $1\n        }\n   \
    \     return sum_of_digits(num: $0) < sum_of_digits(num: $1)\n    }\n    return\
    \ nums", "    return nums.sorted { (a, b) -> Bool in\n        return sum_of_digits(n:\
    \ a) < sum_of_digits(n: b)\n    }", '    return nums.sorted(by: { getSum($0) <
    getSum($1) })', "    return nums.sorted {\n        let lhs = $0.sum_of_digits()\n\
    \        let rhs = $1.sum_of_digits()\n        if lhs == rhs {\n            return\
    \ nums.firstIndex(of: $0)! < nums.firstIndex(of: $1)!\n        }\n        return\
    \ lhs < rhs\n    }", "    var nums = nums\n    for i in 0..<nums.count {\n   \
    \     for j in 0..<nums.count {\n            if (sum_of_digits(nums[i]) < sum_of_digits(nums[j]))\
    \ {\n                swap(&nums[i], &nums[j])\n            }\n        }\n    }\n\
    \    return nums", '  return []', "    if nums.isEmpty {\n        return []\n\
    \    }\n    var arr = [(Int, Int)]()\n    for i in 0..<nums.count {\n        arr.append((nums[i],\
    \ getSumOfDigits(num: nums[i])))\n    }\n    return arr.sorted(by: { a, b in\n\
    \        if a.1 == b.1 {\n            return a.0 < b.0\n        }\n        return\
    \ a.1 < b.1\n    }).map { $0.0 }", "    return nums.sorted(by: {\n        let\
    \ num = $0\n        let sum0 = sum_of_digits(num: num)\n        let num1 = $1\n\
    \        let sum1 = sum_of_digits(num: num1)\n        if sum0 != sum1 {\n    \
    \        return sum0 < sum1\n        }\n        return num < num1\n    })", " \
    \   var nums_sort: [Int] = []\n    var points: [Int] = []\n    var all_points:\
    \ [Int] = []\n    var count: Int = 0\n    for i in nums {\n        count = 0\n\
    \        for j in String(i) {\n            if let j = Int(String(j)) {\n     \
    \           count += j\n            }\n        }\n        points.append(count)\n\
    \    }\n    for i in points {\n        var temp: Int = 0\n        var flag: Bool\
    \ = false\n        for j in all_points {\n            if i < j {\n           \
    \     temp = j\n                all_points[all_points.index(of: j)!] = i\n   \
    \             flag = true\n                break\n            }\n        }\n \
    \       if flag {\n            all_points.append(temp)\n        } else {\n   \
    \         all_points.append(i)\n        }\n    }\n    for i in all_points {\n\
    \        for j in points {\n            if i == j {\n                nums_sort.append(nums[points.index(of:\
    \ j)!])\n                points[points.index(of: j)!] = -100000\n            \
    \    break\n            }\n        }\n    }\n    return nums_sort", "    return\
    \ nums.sorted { (num1, num2) -> Bool in\n        let s1 = String(num1).map { String($0)\
    \ }.map { Int($0)! }.reduce(0, +)\n        let s2 = String(num2).map { String($0)\
    \ }.map { Int($0)! }.reduce(0, +)\n        return s1 < s2\n    }", "    // WRITE\
    \ YOUR CODE HERE\n    var sortedDict = [Int: Int]()\n    for num in nums {\n \
    \       var digits = [Int]()\n        var currentNum = num\n        while currentNum\
    \ > 0 {\n            digits.append(currentNum % 10)\n            currentNum /=\
    \ 10\n        }\n        let digitSum = digits.reduce(0, +)\n        sortedDict[num]\
    \ = digitSum\n    }\n    let sorted = sortedDict.sorted(by: { (arg0, arg1) ->\
    \ Bool in\n        let (_, value0) = arg0\n        let (_, value1) = arg1\n  \
    \      return value0 < value1\n    })\n    return sorted.map { $0.key }", "  \
    \  return nums.sorted { (a, b) -> Bool in\n        let aDigits = a.digits\n  \
    \      let bDigits = b.digits\n        return aDigits.reduce(0, +) < bDigits.reduce(0,\
    \ +)\n    }", '    return nums.sorted { get_sum(number: $0) < get_sum(number:
    $1) }', "    var newArray = nums\n    let key = nums.map { abs($0) }.map { $0\
    \ % 10 + $0 / 10 }\n    let zipped = zip(nums, key)\n    let sorted = zipped.sorted\
    \ { $0.1 < $1.1 }\n    newArray = sorted.map { $0.0 }\n    return newArray", " \
    \   let sorted = nums.sorted { (a, b) -> Bool in\n        let aSum = a.digits.reduce(0,\
    \ +)\n        let bSum = b.digits.reduce(0, +)\n        return aSum == bSum ?\
    \ a < b : aSum < bSum\n    }\n    return sorted", "    /// Write your code here.\n\
    \    return []", "    var dict = [Int: [Int]]()\n    for num in nums {\n     \
    \   var num = num\n        var sum = 0\n        while num != 0 {\n           \
    \ sum += num % 10\n            num /= 10\n        }\n        if dict[sum] == nil\
    \ {\n            dict[sum] = [num]\n        } else {\n            dict[sum]?.append(num)\n\
    \        }\n    }\n    var arr = [Int]()\n    let keys = dict.keys.sorted()\n\
    \    for key in keys {\n        for num in dict[key]! {\n            arr.append(num)\n\
    \        }\n    }\n    return arr", "    return nums.sorted { (lhs, rhs) -> Bool\
    \ in\n        var lhsNum = lhs\n        var rhsNum = rhs\n        var lhsSum =\
    \ 0\n        var rhsSum = 0\n        while lhsNum != 0 {\n            lhsSum +=\
    \ lhsNum % 10\n            lhsNum /= 10\n        }\n        while rhsNum != 0\
    \ {\n            rhsSum += rhsNum % 10\n            rhsNum /= 10\n        }\n\
    \        return lhsSum < rhsSum\n    }", "    /// Fill in here\n    return []",
  "    var sortedNums = nums\n    // create a map that stores the sum of the digits\
    \ per number\n    var sumDigitsMap = [Int: Int]()\n    // create a map that stores\
    \ the index per number\n    var idxMap = [Int: Int]()\n    for (idx, num) in nums.enumerated()\
    \ {\n        // calculate the sum of the digits\n        var sum = 0\n       \
    \ var numToCheck = num\n        while numToCheck != 0 {\n            sum += numToCheck\
    \ % 10\n            numToCheck /= 10\n        }\n        // update the maps\n\
    \        sumDigitsMap[num] = sum\n        idxMap[num] = idx\n    }\n    // sort\
    \ the list based on the sum of the digits in ascending order\n    sortedNums.sort\
    \ { (num1, num2) -> Bool in\n        if sumDigitsMap[num1] == sumDigitsMap[num2]\
    \ {\n            return idxMap[num1]! < idxMap[num2]!\n        }\n        return\
    \ sumDigitsMap[num1]! < sumDigitsMap[num2]!\n    }\n    return sortedNums", " \
    \   // Sort the array based on sum of their digits\n    return nums.sorted(by:\
    \ { (lhs, rhs) -> Bool in\n        // Get sum of digits of each item\n       \
    \ let lhsSum = sum_of_digits(num: lhs)\n        let rhsSum = sum_of_digits(num:\
    \ rhs)\n        // Compare sums of each item\n        return lhsSum < rhsSum\n\
    \    })", "    var result: [Int] = []\n    var tmp: [(Int, Int)] = []\n    for\
    \ (index, num) in nums.enumerated() {\n        var sum = 0\n        var number\
    \ = num\n        while number != 0 {\n            sum += number % 10\n       \
    \     number /= 10\n        }\n        tmp.append((sum, index))\n    }\n    tmp.sort\
    \ { (lhs, rhs) -> Bool in\n        if lhs.0 < rhs.0 {\n            return true\n\
    \        } else if lhs.0 == rhs.0 {\n            return lhs.1 < rhs.1\n      \
    \  } else {\n            return false\n        }\n    }\n    for item in tmp {\n\
    \        result.append(nums[item.1])\n    }\n    return result", "    return nums.sorted\
    \ {\n        $0.digitSum == $1.digitSum ? $0 < $1 : $0.digitSum < $1.digitSum\n\
    \    }", "    return nums.sorted { (lhs, rhs) -> Bool in\n        var lhsSum =\
    \ 0\n        var rhsSum = 0\n        for ch in String(lhs) {\n            lhsSum\
    \ += Int(String(ch))!\n        }\n        for ch in String(rhs) {\n          \
    \  rhsSum += Int(String(ch))!\n        }\n        return lhsSum < rhsSum\n   \
    \ }", "  var result = nums\n  result.sort(by: {(x: Int, y: Int) -> Bool in\n \
    \   return sum_of_digits(x) < sum_of_digits(y)\n  })\n  return result", "    return\
    \ nums.sorted(by: {\n        var (a1, b1) = getSumAndNum(a: $0)\n        var (a2,\
    \ b2) = getSumAndNum(a: $1)\n        if a1 < a2 {\n            return true\n \
    \       } else if a1 > a2 {\n            return false\n        } else {\n    \
    \        return b1 < b2\n        }\n    })", '    return nums.sorted(by: {sum_of_digits(num:
    $0) < sum_of_digits(num: $1)})', "  let res = nums.sorted { (lhs, rhs) -> Bool\
    \ in\n    let lhsDigits = lhs.digits\n    let rhsDigits = rhs.digits\n    if lhsDigits.sum()\
    \ == rhsDigits.sum() {\n      return lhs < rhs\n    }\n    return lhsDigits.sum()\
    \ < rhsDigits.sum()\n  }\n  return res", "    var sumDict: [Int: Int] = [:]\n\
    \    var output: [Int] = []\n    var index: Int = 0\n    \n    for number in nums\
    \ {\n        let n = number < 0 ? (number * -1) : number\n        let numSum =\
    \ n.description.reduce(0) { $0 + Int(String($1))! }\n        sumDict[index] =\
    \ numSum\n        index += 1\n    }\n    \n    let sortedDict = sumDict.sorted\
    \ { $0.value < $1.value }\n    for sortedNumber in sortedDict {\n        output.append(nums[sortedNumber.key])\n\
    \    }\n    \n    return output", "    // TODO:\n    return nums", "    return\
    \ nums.sorted {\n        let s1 = String($0).map { String($0) }.map { Int($0)!\
    \ }.reduce(0, +)\n        let s2 = String($1).map { String($0) }.map { Int($0)!\
    \ }.reduce(0, +)\n        return s1 < s2\n    }", '    return nums.sorted(by:
    { Int(String($0))!.digits.reduce(0, +) < Int(String($1))!.digits.reduce(0, +)
    })', "    \n    var arr = nums\n    var aux_arr = [Int]()\n    var sum_arr = [Int]()\n\
    \    \n    var length = nums.count\n    \n    if length == 0 {\n        return\
    \ nums\n    }\n    \n    //Create an array and get the sum of all digits\n   \
    \ for i in 0..<length {\n        var num = nums[i]\n        var sum = 0\n    \
    \    if num < 0 {\n            num = -num\n        }\n        while num > 0 {\n\
    \            var digit = num % 10\n            sum += digit\n            num =\
    \ num / 10\n        }\n        sum_arr.append(sum)\n    }\n    \n    //Sort by\
    \ sum\n    for i in 0..<length {\n        var min = i\n        for j in i+1..<length\
    \ {\n            if sum_arr[j] < sum_arr[min] {\n                min = j\n   \
    \         }\n        }\n        var temp = sum_arr[i]\n        sum_arr[i] = sum_arr[min]\n\
    \        sum_arr[min] = temp\n        \n        temp = arr[i]\n        arr[i]\
    \ = arr[min]\n        arr[min] = temp\n    }\n    \n    return arr", "    return\
    \ nums.sorted {\n        var x = $0\n        var x_sum = 0\n        while x !=\
    \ 0 {\n            x_sum += x % 10\n            x /= 10\n        }\n        var\
    \ y = $1\n        var y_sum = 0\n        while y != 0 {\n            y_sum +=\
    \ y % 10\n            y /= 10\n        }\n        if x_sum == y_sum {\n      \
    \      return $0 < $1\n        }\n        return x_sum < y_sum\n    }", "    var\
    \ array = nums\n    var intToSum = [Int: Int]()\n    var indexToOriginalIndex\
    \ = [Int: Int]()\n    for i in 0..<array.count {\n        var num = array[i]\n\
    \        var sum = 0\n        if (num < 0) {\n            num = num * -1\n   \
    \     }\n        while (num > 0) {\n            sum += num % 10\n            num\
    \ = num / 10\n        }\n        intToSum[array[i]] = sum\n        indexToOriginalIndex[array[i]]\
    \ = i\n    }\n    array.sort(by: { intToSum[$0]! < intToSum[$1]!})\n    array.sort(by:\
    \ { indexToOriginalIndex[$0]! < indexToOriginalIndex[$1]!})\n    return array",
  "    return nums.sorted { first, second in\n        sum_of_digits(num: first) <\
    \ sum_of_digits(num: second)\n    }", "    return nums.sorted { (lhs, rhs) ->\
    \ Bool in\n        return sumOfDigits(value: lhs) < sumOfDigits(value: rhs)\n\
    \    }", "    return nums.sorted { (a, b) -> Bool in\n        let aSum = String(a).reduce(0)\
    \ { $0 + $1.wholeNumberValue! }\n        let bSum = String(b).reduce(0) { $0 +\
    \ $1.wholeNumberValue! }\n        return aSum < bSum\n    }", "  return nums.sorted\
    \ {\n    sumDigits(i: $0) < sumDigits(i: $1)\n  }", "    return nums.sorted {\
    \ lhs, rhs in\n        lhs.digitSum() < rhs.digitSum()\n    }", "    var result\
    \ = [Int]()\n    var dict = [Int: [Int]]()\n    for num in nums {\n        let\
    \ sum = get_sum_of_digits(num: num)\n        if dict[sum] == nil {\n         \
    \   dict[sum] = [num]\n        } else {\n            dict[sum]?.append(num)\n\
    \        }\n    }\n    for i in nums {\n        let sum = get_sum_of_digits(num:\
    \ i)\n        if dict[sum] != nil {\n            if let array = dict[sum] {\n\
    \                for elem in array {\n                    result.append(elem)\n\
    \                }\n            }\n            dict[sum] = nil\n        }\n  \
    \  }\n    return result", "    return nums.sorted(by: { (a, b) -> Bool in\n  \
    \      return sum_of_digits(a) < sum_of_digits(b)\n    })", "    let numsWithPoints\
    \ = nums.map { (num: Int) -> (Int, Int) in\n        var absNum = abs(num)\n  \
    \      var sum = 0\n        while absNum > 0 {\n            sum += absNum % 10\n\
    \            absNum /= 10\n        }\n        return (num, sum)\n    }\n    return\
    \ numsWithPoints.sorted { $0.1 < $1.1 }.map { $0.0 }", "    var nums = nums\n\
    \    nums.sort {\n        if $0.digits.reduce(0, +) == $1.digits.reduce(0, +)\
    \ {\n            return $0 < $1\n        }\n        return $0.digits.reduce(0,\
    \ +) < $1.digits.reduce(0, +)\n    }\n    return nums", "    return nums.sorted\
    \ { (first, second) -> Bool in\n        if sum_of_digits(num: first) == sum_of_digits(num:\
    \ second) {\n            return first < second\n        }\n        return sum_of_digits(num:\
    \ first) < sum_of_digits(num: second)\n    }", "    let result = nums.enumerated().sorted\
    \ { (i1, i2) -> Bool in\n        let (v1, _) = i1\n        let (v2, _) = i2\n\
    \        return sum_of_digits(of: v1) < sum_of_digits(of: v2)\n    }\n    return\
    \ result.map { $0.element }", "    return nums.sorted { (a, b) -> Bool in\n  \
    \      a.sumDigits() < b.sumDigits()\n    }", "    \n    var numbers = [(number:\
    \ Int, sum: Int)]()\n    \n    for (index, i) in nums.enumerated() {\n       \
    \ var sum = 0\n        var num = i\n        while num != 0 {\n            sum\
    \ += num % 10\n            num /= 10\n        }\n        numbers.append((i, sum))\n\
    \    }\n    \n    numbers.sort(by: { $0.sum == $1.sum ? $0.number < $1.number\
    \ : $0.sum < $1.sum })\n    \n    return numbers.map { $0.number }", "    let\
    \ nums_with_sum_of_digits = nums.map { ($0, sum_of_digits(n: $0)) }\n    let sorted_nums_with_sum_of_digits\
    \ = nums_with_sum_of_digits.sorted {\n        (left, right) in\n        if left.1\
    \ != right.1 {\n            return left.1 < right.1\n        } else {\n      \
    \      return left.0 < right.0\n        }\n    }\n    return sorted_nums_with_sum_of_digits.map\
    \ { $0.0 }", "    return nums.sorted { lhs, rhs in\n        lhs.digitSum() < rhs.digitSum()\n\
    \    }", "  return nums.sorted(by: { (lhs, rhs) -> Bool in\n    return lhs.digitsSum()\
    \ < rhs.digitsSum()\n  })", "    let sumOfDigits: (Int) -> Int = {\n        var\
    \ num = $0\n        var sum = 0\n        while num != 0 {\n            sum +=\
    \ num % 10\n            num /= 10\n        }\n        return sum\n    }\n    return\
    \ nums.sorted { a, b in\n        let aSum = sumOfDigits(a)\n        let bSum =\
    \ sumOfDigits(b)\n        if aSum == bSum {\n            return a < b\n      \
    \  }\n        return aSum < bSum\n    }", "    return nums.sorted {\n        let\
    \ sumDigits = { (n: Int) -> Int in\n            return n.digits.reduce(0, +)\n\
    \        }\n        let sum0 = sumDigits($0)\n        let sum1 = sumDigits($1)\n\
    \        if sum0 == sum1 {\n            return nums.firstIndex(of: $0)! < nums.firstIndex(of:\
    \ $1)!\n        }\n        return sum0 < sum1\n    }", "    var dict = [Int: [Int]]()\n\
    \    for n in nums {\n        let key = n.digits.reduce(0, +)\n        if var\
    \ array = dict[key] {\n            array.append(n)\n            dict[key] = array\n\
    \        } else {\n            dict[key] = [n]\n        }\n    }\n    let sortedDict\
    \ = dict.sorted { $0.key < $1.key }\n    return sortedDict.reduce([Int](), { $0\
    \ + $1.value })", '    return nums.sorted(by: {sumOfDigits(number: $0) < sumOfDigits(number:
    $1)})', "    return nums.sorted { num1, num2 in\n        let num1Digits = digits(num:\
    \ num1)\n        let num2Digits = digits(num: num2)\n        return sum(of: num1Digits)\
    \ < sum(of: num2Digits)\n    }", '    return nums.sorted(by: { sum_of_digits(num:
    $0) < sum_of_digits(num: $1) })', "    if nums.isEmpty {\n        return []\n\
    \    }\n    return nums.sorted(by: { (first: Int, second: Int) -> Bool in\n  \
    \      let firstSum = first.digits.reduce(0, +)\n        let secondSum = second.digits.reduce(0,\
    \ +)\n        if firstSum == secondSum {\n            return nums.firstIndex(of:\
    \ first)! < nums.firstIndex(of: second)!\n        }\n        return firstSum <\
    \ secondSum\n    })", "    var nums: [Int] = nums\n    nums.sort {\n        if\
    \ $0.sum_of_digits() == $1.sum_of_digits() {\n            return $0 < $1\n   \
    \     }\n        return $0.sum_of_digits() < $1.sum_of_digits()\n    }\n    return\
    \ nums", "    return nums.sorted(by: { (item1, item2) -> Bool in\n        var\
    \ item1Sum = 0\n        var item2Sum = 0\n        for item in String(item1).unicodeScalars\
    \ {\n            item1Sum += Int(item.value) - 48\n        }\n        for item\
    \ in String(item2).unicodeScalars {\n            item2Sum += Int(item.value) -\
    \ 48\n        }\n        return item1Sum < item2Sum\n    })", "    return nums.sorted\
    \ { (x, y) -> Bool in\n        let xSum = sum_of_digits(num: x)\n        let ySum\
    \ = sum_of_digits(num: y)\n        if xSum == ySum {\n            return nums.firstIndex(of:\
    \ x)! < nums.firstIndex(of: y)!\n        }\n        return xSum < ySum\n    }",
  "    var result: [Int] = []\n    var nums = nums\n    let numsCount = nums.count\n\
    \    for _ in 0..<numsCount {\n        var maxSumDigits: Int = 0\n        var\
    \ index: Int = 0\n        for i in 0..<nums.count {\n            let sum = Int(String(nums[i]).map({Int(String($0))!}).reduce(0,\
    \ +))\n            if sum > maxSumDigits {\n                maxSumDigits = sum\n\
    \                index = i\n            }\n        }\n        result.append(nums[index])\n\
    \        nums.remove(at: index)\n    }\n    return result"]
stop_tokens:
- "\n}"
