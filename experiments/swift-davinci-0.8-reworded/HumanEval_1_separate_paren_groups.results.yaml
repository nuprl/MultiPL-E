language: swift
name: HumanEval_1_separate_paren_groups
results:
- exit_code: 1
  program: "\n/// Input to this function is a string containing multiple groups of\
    \ nested parentheses. Your goal is to\n/// separate those group into separate\
    \ strings and return the array of those.\n/// Separate groups are balanced (each\
    \ open brace is properly closed) and not nested within each other\n/// Ignore\
    \ any spaces in the input string.\n/// >>> separate_paren_groups(paren_string:\
    \ \"( ) (( )) (( )( ))\")\n/// [\"()\", \"(())\", \"(()())\"]\nfunc separate_paren_groups(paren_string:\
    \ String) -> [String] {\n    /// 1. Make a stack to keep track of elements\n \
    \   /// 2. Iterate over the string\n    /// 3. for each character check if its\
    \ \"(\" or \")\" push/pop stack\n    /// 4. if the stack is empty and the string\
    \ is not empty then add string to the output array\n    var stack: Stack<Character>\
    \ = Stack<Character>()\n    var output = [String]()\n    var string = \"\"\n \
    \   for character in paren_string {\n        if character == \"(\" {\n       \
    \     stack.push(element: character)\n        } else if character == \")\" {\n\
    \            stack.pop()\n        }\n        if !stack.isEmpty() {\n         \
    \   string += String(character)\n        } else if string != \"\" {\n        \
    \    output.append(string)\n            string = \"\"\n        }\n    }\n    return\
    \ output\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n\
    \    if left.count != right.count {\n        return false\n    }\n    for (l,\
    \ r) in zip(left, right) {\n        if l != r {\n            return false\n  \
    \      }\n    }\n    return true\n}\n            \nassert(separate_paren_groups(paren_string:\
    \ \"(()()) ((())) () ((())()())\") == [\"(()())\", \"((()))\", \"()\", \"((())()())\"\
    ])\nassert(separate_paren_groups(paren_string: \"() (()) ((())) (((())))\") ==\
    \ [\"()\", \"(())\", \"((()))\", \"(((())))\"])\nassert(separate_paren_groups(paren_string:\
    \ \"(()(())((())))\") == [\"(()(())((())))\"])\nassert(separate_paren_groups(paren_string:\
    \ \"( ) (( )) (( )( ))\") == [\"()\", \"(())\", \"(()())\"])"
  status: SyntaxError
  stderr: "/tmp/tmpxscjlckx.swift:13:16: error: cannot find type 'Stack' in scope\n\
    \    var stack: Stack<Character> = Stack<Character>()\n               ^~~~~\n"
  stdout: ''
  timestamp: 1659980040
- exit_code: -4
  program: "\n/// Input to this function is a string containing multiple groups of\
    \ nested parentheses. Your goal is to\n/// separate those group into separate\
    \ strings and return the array of those.\n/// Separate groups are balanced (each\
    \ open brace is properly closed) and not nested within each other\n/// Ignore\
    \ any spaces in the input string.\n/// >>> separate_paren_groups(paren_string:\
    \ \"( ) (( )) (( )( ))\")\n/// [\"()\", \"(())\", \"(()())\"]\nfunc separate_paren_groups(paren_string:\
    \ String) -> [String] {\n    var groups = [String]()\n    let chars = Array(paren_string)\n\
    \    var buffer = \"\"\n    var counter = 0\n    for char in chars {\n       \
    \ if char == \"(\" {\n            counter += 1\n        } else if char == \")\"\
    \ {\n            counter -= 1\n        }\n        if char != \" \" {\n       \
    \     buffer.append(char)\n        }\n        if counter == 0 {\n            groups.append(buffer)\n\
    \            buffer = \"\"\n        }\n    }\n    return groups\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(separate_paren_groups(paren_string: \"(()()) ((())) ()\
    \ ((())()())\") == [\"(()())\", \"((()))\", \"()\", \"((())()())\"])\nassert(separate_paren_groups(paren_string:\
    \ \"() (()) ((())) (((())))\") == [\"()\", \"(())\", \"((()))\", \"(((())))\"\
    ])\nassert(separate_paren_groups(paren_string: \"(()(())((())))\") == [\"(()(())((())))\"\
    ])\nassert(separate_paren_groups(paren_string: \"( ) (( )) (( )( ))\") == [\"\
    ()\", \"(())\", \"(()())\"])"
  status: Exception
  stderr: 'tmpth91avcu/tmpth91avcu.swift:43: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b1652a0ac80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b1652701b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b1652701988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b16527007b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpth91avcu                        0x000055b31daa0977 <unavailable> + 6519

    5    libc.so.6                          0x00002b1652bf6460 __libc_start_main +
    245

    6    tmpth91avcu                        0x000055b31daa0509 <unavailable> + 5385

    '
  stdout: ''
  timestamp: 1659980040
- exit_code: 0
  program: "\n/// Input to this function is a string containing multiple groups of\
    \ nested parentheses. Your goal is to\n/// separate those group into separate\
    \ strings and return the array of those.\n/// Separate groups are balanced (each\
    \ open brace is properly closed) and not nested within each other\n/// Ignore\
    \ any spaces in the input string.\n/// >>> separate_paren_groups(paren_string:\
    \ \"( ) (( )) (( )( ))\")\n/// [\"()\", \"(())\", \"(()())\"]\nfunc separate_paren_groups(paren_string:\
    \ String) -> [String] {\n    var group_strings = [String]()\n    var group_stack\
    \ = [String]()\n    for char in paren_string {\n        if char == \"(\" {\n \
    \           group_stack.append(\"(\")\n        } else if char == \")\" {\n   \
    \         let group = group_stack.popLast()! + \")\"\n            if group_stack.isEmpty\
    \ {\n                group_strings.append(group)\n            } else {\n     \
    \           group_stack[group_stack.count - 1] += group\n            }\n     \
    \   }\n    }\n    return group_strings\n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(separate_paren_groups(paren_string: \"(()()) ((())) () ((())()())\") ==\
    \ [\"(()())\", \"((()))\", \"()\", \"((())()())\"])\nassert(separate_paren_groups(paren_string:\
    \ \"() (()) ((())) (((())))\") == [\"()\", \"(())\", \"((()))\", \"(((())))\"\
    ])\nassert(separate_paren_groups(paren_string: \"(()(())((())))\") == [\"(()(())((())))\"\
    ])\nassert(separate_paren_groups(paren_string: \"( ) (( )) (( )( ))\") == [\"\
    ()\", \"(())\", \"(()())\"])"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659980040
- exit_code: 1
  program: "\n/// Input to this function is a string containing multiple groups of\
    \ nested parentheses. Your goal is to\n/// separate those group into separate\
    \ strings and return the array of those.\n/// Separate groups are balanced (each\
    \ open brace is properly closed) and not nested within each other\n/// Ignore\
    \ any spaces in the input string.\n/// >>> separate_paren_groups(paren_string:\
    \ \"( ) (( )) (( )( ))\")\n/// [\"()\", \"(())\", \"(()())\"]\nfunc separate_paren_groups(paren_string:\
    \ String) -> [String] {\n    let stack = Stack<Character>()\n    var current_string\
    \ = \"\"\n    var result = [String]()\n    for character in paren_string {\n \
    \       if character == \" \" {\n            continue\n        }\n        if character\
    \ == \"(\" {\n            stack.push(data: character)\n        } else if character\
    \ == \")\" {\n            stack.pop()\n            if stack.isEmpty() {\n    \
    \            result.append(current_string)\n                current_string = \"\
    \"\n            }\n        }\n        current_string.append(character)\n    }\n\
    \    return result\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) ->\
    \ Bool {\n    if left.count != right.count {\n        return false\n    }\n  \
    \  for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(separate_paren_groups(paren_string:\
    \ \"(()()) ((())) () ((())()())\") == [\"(()())\", \"((()))\", \"()\", \"((())()())\"\
    ])\nassert(separate_paren_groups(paren_string: \"() (()) ((())) (((())))\") ==\
    \ [\"()\", \"(())\", \"((()))\", \"(((())))\"])\nassert(separate_paren_groups(paren_string:\
    \ \"(()(())((())))\") == [\"(()(())((())))\"])\nassert(separate_paren_groups(paren_string:\
    \ \"( ) (( )) (( )( ))\") == [\"()\", \"(())\", \"(()())\"])"
  status: SyntaxError
  stderr: "/tmp/tmpvq9cvgas.swift:9:17: error: cannot find 'Stack' in scope\n    let\
    \ stack = Stack<Character>()\n                ^~~~~\n"
  stdout: ''
  timestamp: 1659980040
- exit_code: 1
  program: "\n/// Input to this function is a string containing multiple groups of\
    \ nested parentheses. Your goal is to\n/// separate those group into separate\
    \ strings and return the array of those.\n/// Separate groups are balanced (each\
    \ open brace is properly closed) and not nested within each other\n/// Ignore\
    \ any spaces in the input string.\n/// >>> separate_paren_groups(paren_string:\
    \ \"( ) (( )) (( )( ))\")\n/// [\"()\", \"(())\", \"(()())\"]\nfunc separate_paren_groups(paren_string:\
    \ String) -> [String] {\n    var openParens: [Int] = []\n    var output: [String]\
    \ = []\n    var buffer: String = \"\"\n    for (index, char) in paren_string.enumerated()\
    \ {\n        if char == \"(\" {\n            openParens.append(index)\n      \
    \  } else if char == \")\" {\n            if openParens.count > 0 {\n        \
    \        buffer += String(paren_string[openParens.removeLast()...index])\n   \
    \             output.append(buffer)\n                buffer = \"\"\n         \
    \   }\n        }\n    }\n    return output\n}\n\n\nfunc ==(left: [(Int, Int)],\
    \ right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n       \
    \ return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r\
    \ {\n            return false\n        }\n    }\n    return true\n}\n        \
    \    \nassert(separate_paren_groups(paren_string: \"(()()) ((())) () ((())()())\"\
    ) == [\"(()())\", \"((()))\", \"()\", \"((())()())\"])\nassert(separate_paren_groups(paren_string:\
    \ \"() (()) ((())) (((())))\") == [\"()\", \"(())\", \"((()))\", \"(((())))\"\
    ])\nassert(separate_paren_groups(paren_string: \"(()(())((())))\") == [\"(()(())((())))\"\
    ])\nassert(separate_paren_groups(paren_string: \"( ) (( )) (( )( ))\") == [\"\
    ()\", \"(())\", \"(()())\"])"
  status: SyntaxError
  stderr: "/tmp/tmp44aae1yv.swift:17:34: error: 'subscript(_:)' is unavailable: cannot\
    \ subscript String with an integer range, use a String.Index range instead.\n\
    \                buffer += String(paren_string[openParens.removeLast()...index])\n\
    \                                 ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n\
    Swift.String:5:12: note: 'subscript(_:)' has been explicitly marked unavailable\
    \ here\n    public subscript<R>(bounds: R) -> String where R : RangeExpression,\
    \ R.Bound == Int { get }\n           ^\n"
  stdout: ''
  timestamp: 1659980040
- exit_code: 1
  program: "\n/// Input to this function is a string containing multiple groups of\
    \ nested parentheses. Your goal is to\n/// separate those group into separate\
    \ strings and return the array of those.\n/// Separate groups are balanced (each\
    \ open brace is properly closed) and not nested within each other\n/// Ignore\
    \ any spaces in the input string.\n/// >>> separate_paren_groups(paren_string:\
    \ \"( ) (( )) (( )( ))\")\n/// [\"()\", \"(())\", \"(()())\"]\nfunc separate_paren_groups(paren_string:\
    \ String) -> [String] {\n    // Count the number of open parentheses\n    // This\
    \ is O(n)\n    let num_open_parens = paren_string.reduce(0) { $1 == \"(\" ? $0\
    \ + 1 : $0 }\n    let num_paren_groups = num_open_parens / 2\n    var results\
    \ = [String]()\n    var open_parens = 0\n    var start_index = 0\n    // O(n)\n\
    \    for (index, char) in paren_string.enumerated() {\n        // Skip spaces\n\
    \        if char == \" \" {\n            continue\n        }\n        // Check\
    \ if we have an opening paren and update the counter\n        if char == \"(\"\
    \ {\n            open_parens += 1\n        }\n        // Check if we have a closing\
    \ paren and decrement the counter\n        if char == \")\" {\n            open_parens\
    \ -= 1\n        }\n        // Check if we have a closing paren and have the appropriate\
    \ number of open parens\n        if char == \")\" && open_parens == 0 {\n    \
    \        // Add the substring between the start index and the current index and\
    \ increment the start index\n            // to the next char after the current\
    \ index\n            results.append(paren_string[paren_string.index(paren_string.startIndex,\
    \ offsetBy: start_index)..<paren_string.index(paren_string.startIndex, offsetBy:\
    \ index+1)])\n            start_index = index + 1\n        }\n        // Check\
    \ if we have processed all of the groups\n        if results.count == num_paren_groups\
    \ {\n            break\n        }\n    }\n    return results\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(separate_paren_groups(paren_string: \"(()()) ((())) ()\
    \ ((())()())\") == [\"(()())\", \"((()))\", \"()\", \"((())()())\"])\nassert(separate_paren_groups(paren_string:\
    \ \"() (()) ((())) (((())))\") == [\"()\", \"(())\", \"((()))\", \"(((())))\"\
    ])\nassert(separate_paren_groups(paren_string: \"(()(())((())))\") == [\"(()(())((())))\"\
    ])\nassert(separate_paren_groups(paren_string: \"( ) (( )) (( )( ))\") == [\"\
    ()\", \"(())\", \"(()())\"])"
  status: SyntaxError
  stderr: "/tmp/tmpzjk82lyo.swift:34:40: error: subscript 'subscript(_:)' requires\
    \ the types 'String.Index' and 'Int' be equivalent\n            results.append(paren_string[paren_string.index(paren_string.startIndex,\
    \ offsetBy: start_index)..<paren_string.index(paren_string.startIndex, offsetBy:\
    \ index+1)])\n                                       ^\nSwift.String:5:12: note:\
    \ where 'R.Bound' = 'String.Index'\n    public subscript<R>(bounds: R) -> String\
    \ where R : RangeExpression, R.Bound == Int { get }\n           ^\n"
  stdout: ''
  timestamp: 1659980040
- exit_code: 1
  program: "\n/// Input to this function is a string containing multiple groups of\
    \ nested parentheses. Your goal is to\n/// separate those group into separate\
    \ strings and return the array of those.\n/// Separate groups are balanced (each\
    \ open brace is properly closed) and not nested within each other\n/// Ignore\
    \ any spaces in the input string.\n/// >>> separate_paren_groups(paren_string:\
    \ \"( ) (( )) (( )( ))\")\n/// [\"()\", \"(())\", \"(()())\"]\nfunc separate_paren_groups(paren_string:\
    \ String) -> [String] {\n    var result = [String]()\n    var counter = 0\n  \
    \  var temp = \"\"\n    for i in paren_string.characters {\n        if i == \"\
    (\" {\n            counter += 1\n        } else if i == \")\" {\n            counter\
    \ -= 1\n        }\n        temp.append(i)\n        if counter == 0 {\n       \
    \     result.append(temp)\n            temp = \"\"\n        }\n    }\n    return\
    \ result\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n\
    \    if left.count != right.count {\n        return false\n    }\n    for (l,\
    \ r) in zip(left, right) {\n        if l != r {\n            return false\n  \
    \      }\n    }\n    return true\n}\n            \nassert(separate_paren_groups(paren_string:\
    \ \"(()()) ((())) () ((())()())\") == [\"(()())\", \"((()))\", \"()\", \"((())()())\"\
    ])\nassert(separate_paren_groups(paren_string: \"() (()) ((())) (((())))\") ==\
    \ [\"()\", \"(())\", \"((()))\", \"(((())))\"])\nassert(separate_paren_groups(paren_string:\
    \ \"(()(())((())))\") == [\"(()(())((())))\"])\nassert(separate_paren_groups(paren_string:\
    \ \"( ) (( )) (( )( ))\") == [\"()\", \"(())\", \"(()())\"])"
  status: SyntaxError
  stderr: "/tmp/tmpkq0ji417.swift:12:27: error: 'characters' is unavailable: Please\
    \ use String directly\n    for i in paren_string.characters {\n              \
    \            ^~~~~~~~~~\nSwift.String:5:16: note: 'characters' was obsoleted in\
    \ Swift 5.0\n    public var characters: String { get set }\n               ^\n"
  stdout: ''
  timestamp: 1659980040
- exit_code: -4
  program: "\n/// Input to this function is a string containing multiple groups of\
    \ nested parentheses. Your goal is to\n/// separate those group into separate\
    \ strings and return the array of those.\n/// Separate groups are balanced (each\
    \ open brace is properly closed) and not nested within each other\n/// Ignore\
    \ any spaces in the input string.\n/// >>> separate_paren_groups(paren_string:\
    \ \"( ) (( )) (( )( ))\")\n/// [\"()\", \"(())\", \"(()())\"]\nfunc separate_paren_groups(paren_string:\
    \ String) -> [String] {\n    // TODO: Implement this solution here\n    return\
    \ []\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if\
    \ left.count != right.count {\n        return false\n    }\n    for (l, r) in\
    \ zip(left, right) {\n        if l != r {\n            return false\n        }\n\
    \    }\n    return true\n}\n            \nassert(separate_paren_groups(paren_string:\
    \ \"(()()) ((())) () ((())()())\") == [\"(()())\", \"((()))\", \"()\", \"((())()())\"\
    ])\nassert(separate_paren_groups(paren_string: \"() (()) ((())) (((())))\") ==\
    \ [\"()\", \"(())\", \"((()))\", \"(((())))\"])\nassert(separate_paren_groups(paren_string:\
    \ \"(()(())((())))\") == [\"(()(())((())))\"])\nassert(separate_paren_groups(paren_string:\
    \ \"( ) (( )) (( )( ))\") == [\"()\", \"(())\", \"(()())\"])"
  status: Exception
  stderr: 'tmpitf_ktr1/tmpitf_ktr1.swift:26: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b20c32e4c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b20c2fdbb6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b20c2fdb988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b20c2fda7b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpitf_ktr1                        0x0000556d1bd45537 <unavailable> + 5431

    5    libc.so.6                          0x00002b20c34d0460 __libc_start_main +
    245

    6    tmpitf_ktr1                        0x0000556d1bd450c9 <unavailable> + 4297

    '
  stdout: ''
  timestamp: 1659980040
- exit_code: 1
  program: "\n/// Input to this function is a string containing multiple groups of\
    \ nested parentheses. Your goal is to\n/// separate those group into separate\
    \ strings and return the array of those.\n/// Separate groups are balanced (each\
    \ open brace is properly closed) and not nested within each other\n/// Ignore\
    \ any spaces in the input string.\n/// >>> separate_paren_groups(paren_string:\
    \ \"( ) (( )) (( )( ))\")\n/// [\"()\", \"(())\", \"(()())\"]\nfunc separate_paren_groups(paren_string:\
    \ String) -> [String] {\n    var stack = Stack<Character>()\n    var output =\
    \ [String]()\n    var substring = \"\"\n    for char in paren_string {\n     \
    \   if char == \"(\" {\n            stack.push(char)\n        } else if char ==\
    \ \")\" {\n            stack.pop()\n            if stack.isEmpty() {\n       \
    \         output.append(substring)\n                substring = \"\"\n       \
    \     }\n        } else if char != \" \" {\n            substring.append(char)\n\
    \        }\n    }\n    return output\n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(separate_paren_groups(paren_string: \"(()()) ((())) () ((())()())\") ==\
    \ [\"(()())\", \"((()))\", \"()\", \"((())()())\"])\nassert(separate_paren_groups(paren_string:\
    \ \"() (()) ((())) (((())))\") == [\"()\", \"(())\", \"((()))\", \"(((())))\"\
    ])\nassert(separate_paren_groups(paren_string: \"(()(())((())))\") == [\"(()(())((())))\"\
    ])\nassert(separate_paren_groups(paren_string: \"( ) (( )) (( )( ))\") == [\"\
    ()\", \"(())\", \"(()())\"])"
  status: SyntaxError
  stderr: "/tmp/tmph6g7g08d.swift:9:17: error: cannot find 'Stack' in scope\n    var\
    \ stack = Stack<Character>()\n                ^~~~~\n"
  stdout: ''
  timestamp: 1659980040
- exit_code: 1
  program: "\n/// Input to this function is a string containing multiple groups of\
    \ nested parentheses. Your goal is to\n/// separate those group into separate\
    \ strings and return the array of those.\n/// Separate groups are balanced (each\
    \ open brace is properly closed) and not nested within each other\n/// Ignore\
    \ any spaces in the input string.\n/// >>> separate_paren_groups(paren_string:\
    \ \"( ) (( )) (( )( ))\")\n/// [\"()\", \"(())\", \"(()())\"]\nfunc separate_paren_groups(paren_string:\
    \ String) -> [String] {\n    var paren_groups: [String] = []\n    var start_indices:\
    \ [Int] = []\n    var end_indices: [Int] = []\n    var open_braces: Int = 0\n\
    \    for i in paren_string.indices {\n        let index = paren_string.distance(from:\
    \ paren_string.startIndex, to: i)\n        if paren_string[i] == \"(\" {\n   \
    \         open_braces += 1\n            if open_braces == 1 {\n              \
    \  start_indices.append(index)\n            }\n        } else if paren_string[i]\
    \ == \")\" {\n            open_braces -= 1\n            if open_braces == 0 {\n\
    \                end_indices.append(index)\n            }\n        }\n    }\n\
    \    if start_indices.count != end_indices.count {\n        print(\"Mismatched\
    \ braces in string \\(paren_string)\")\n        return paren_groups\n    }\n \
    \   for i in 0..<start_indices.count {\n        paren_groups.append(paren_string[paren_string.index(paren_string.startIndex,\
    \ offsetBy: start_indices[i])..<paren_string.index(paren_string.startIndex, offsetBy:\
    \ end_indices[i])])\n    }\n    return paren_groups\n}\n\n\nfunc ==(left: [(Int,\
    \ Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n\
    \        return false\n    }\n    for (l, r) in zip(left, right) {\n        if\
    \ l != r {\n            return false\n        }\n    }\n    return true\n}\n \
    \           \nassert(separate_paren_groups(paren_string: \"(()()) ((())) () ((())()())\"\
    ) == [\"(()())\", \"((()))\", \"()\", \"((())()())\"])\nassert(separate_paren_groups(paren_string:\
    \ \"() (()) ((())) (((())))\") == [\"()\", \"(())\", \"((()))\", \"(((())))\"\
    ])\nassert(separate_paren_groups(paren_string: \"(()(())((())))\") == [\"(()(())((())))\"\
    ])\nassert(separate_paren_groups(paren_string: \"( ) (( )) (( )( ))\") == [\"\
    ()\", \"(())\", \"(()())\"])"
  status: SyntaxError
  stderr: "/tmp/tmp00cf8763.swift:32:41: error: subscript 'subscript(_:)' requires\
    \ the types 'String.Index' and 'Int' be equivalent\n        paren_groups.append(paren_string[paren_string.index(paren_string.startIndex,\
    \ offsetBy: start_indices[i])..<paren_string.index(paren_string.startIndex, offsetBy:\
    \ end_indices[i])])\n                                        ^\nSwift.String:5:12:\
    \ note: where 'R.Bound' = 'String.Index'\n    public subscript<R>(bounds: R) ->\
    \ String where R : RangeExpression, R.Bound == Int { get }\n           ^\n"
  stdout: ''
  timestamp: 1659980040
- exit_code: -4
  program: "\n/// Input to this function is a string containing multiple groups of\
    \ nested parentheses. Your goal is to\n/// separate those group into separate\
    \ strings and return the array of those.\n/// Separate groups are balanced (each\
    \ open brace is properly closed) and not nested within each other\n/// Ignore\
    \ any spaces in the input string.\n/// >>> separate_paren_groups(paren_string:\
    \ \"( ) (( )) (( )( ))\")\n/// [\"()\", \"(())\", \"(()())\"]\nfunc separate_paren_groups(paren_string:\
    \ String) -> [String] {\n    // CODE HERE\n    return [\"()\", \"(())\", \"(()())\"\
    ]\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(separate_paren_groups(paren_string: \"(()()) ((()))\
    \ () ((())()())\") == [\"(()())\", \"((()))\", \"()\", \"((())()())\"])\nassert(separate_paren_groups(paren_string:\
    \ \"() (()) ((())) (((())))\") == [\"()\", \"(())\", \"((()))\", \"(((())))\"\
    ])\nassert(separate_paren_groups(paren_string: \"(()(())((())))\") == [\"(()(())((())))\"\
    ])\nassert(separate_paren_groups(paren_string: \"( ) (( )) (( )( ))\") == [\"\
    ()\", \"(())\", \"(()())\"])"
  status: Exception
  stderr: 'tmpd7j3q5qs/tmpd7j3q5qs.swift:26: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b3b86cf0c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b3b869e7b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b3b869e7988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b3b869e67b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpd7j3q5qs                        0x000055b656da4537 <unavailable> + 5431

    5    libc.so.6                          0x00002b3b86edc460 __libc_start_main +
    245

    6    tmpd7j3q5qs                        0x000055b656da40c9 <unavailable> + 4297

    '
  stdout: ''
  timestamp: 1659980040
- exit_code: -4
  program: "\n/// Input to this function is a string containing multiple groups of\
    \ nested parentheses. Your goal is to\n/// separate those group into separate\
    \ strings and return the array of those.\n/// Separate groups are balanced (each\
    \ open brace is properly closed) and not nested within each other\n/// Ignore\
    \ any spaces in the input string.\n/// >>> separate_paren_groups(paren_string:\
    \ \"( ) (( )) (( )( ))\")\n/// [\"()\", \"(())\", \"(()())\"]\nfunc separate_paren_groups(paren_string:\
    \ String) -> [String] {\n    return []\n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(separate_paren_groups(paren_string: \"(()()) ((())) () ((())()())\") ==\
    \ [\"(()())\", \"((()))\", \"()\", \"((())()())\"])\nassert(separate_paren_groups(paren_string:\
    \ \"() (()) ((())) (((())))\") == [\"()\", \"(())\", \"((()))\", \"(((())))\"\
    ])\nassert(separate_paren_groups(paren_string: \"(()(())((())))\") == [\"(()(())((())))\"\
    ])\nassert(separate_paren_groups(paren_string: \"( ) (( )) (( )( ))\") == [\"\
    ()\", \"(())\", \"(()())\"])"
  status: Exception
  stderr: 'tmp1zdkbtz2/tmp1zdkbtz2.swift:25: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002aeebe8b5c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002aeebe5acb6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002aeebe5ac988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002aeebe5ab7b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmp1zdkbtz2                        0x0000556857c08537 <unavailable> + 5431

    5    libc.so.6                          0x00002aeebeaa1460 __libc_start_main +
    245

    6    tmp1zdkbtz2                        0x0000556857c080c9 <unavailable> + 4297

    '
  stdout: ''
  timestamp: 1659980040
- exit_code: 1
  program: "\n/// Input to this function is a string containing multiple groups of\
    \ nested parentheses. Your goal is to\n/// separate those group into separate\
    \ strings and return the array of those.\n/// Separate groups are balanced (each\
    \ open brace is properly closed) and not nested within each other\n/// Ignore\
    \ any spaces in the input string.\n/// >>> separate_paren_groups(paren_string:\
    \ \"( ) (( )) (( )( ))\")\n/// [\"()\", \"(())\", \"(()())\"]\nfunc separate_paren_groups(paren_string:\
    \ String) -> [String] {\n    let chars = paren_string.characters\n    var groups\
    \ = [String]()\n    var current_group = \"\"\n    var count = 0\n    for i in\
    \ chars {\n        if i == \"(\" {\n            count += 1\n        } else if\
    \ i == \")\" {\n            count -= 1\n        }\n        current_group.append(i)\n\
    \        if count == 0 {\n            groups.append(current_group)\n         \
    \   current_group = \"\"\n        }\n    }\n    return groups\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(separate_paren_groups(paren_string: \"(()()) ((())) ()\
    \ ((())()())\") == [\"(()())\", \"((()))\", \"()\", \"((())()())\"])\nassert(separate_paren_groups(paren_string:\
    \ \"() (()) ((())) (((())))\") == [\"()\", \"(())\", \"((()))\", \"(((())))\"\
    ])\nassert(separate_paren_groups(paren_string: \"(()(())((())))\") == [\"(()(())((())))\"\
    ])\nassert(separate_paren_groups(paren_string: \"( ) (( )) (( )( ))\") == [\"\
    ()\", \"(())\", \"(()())\"])"
  status: SyntaxError
  stderr: "/tmp/tmpt2nmfhpe.swift:9:30: error: 'characters' is unavailable: Please\
    \ use String directly\n    let chars = paren_string.characters\n             \
    \                ^~~~~~~~~~\nSwift.String:5:16: note: 'characters' was obsoleted\
    \ in Swift 5.0\n    public var characters: String { get set }\n              \
    \ ^\n"
  stdout: ''
  timestamp: 1659980040
- exit_code: -4
  program: "\n/// Input to this function is a string containing multiple groups of\
    \ nested parentheses. Your goal is to\n/// separate those group into separate\
    \ strings and return the array of those.\n/// Separate groups are balanced (each\
    \ open brace is properly closed) and not nested within each other\n/// Ignore\
    \ any spaces in the input string.\n/// >>> separate_paren_groups(paren_string:\
    \ \"( ) (( )) (( )( ))\")\n/// [\"()\", \"(())\", \"(()())\"]\nfunc separate_paren_groups(paren_string:\
    \ String) -> [String] {\n    // Keep an array of groups, then mutate it\n    var\
    \ group_arr = [String]()\n    // Keep a mutable copy of the input string\n   \
    \ var input_str = paren_string\n    // Keep a mutable copy of the previous group\
    \ so we can check it against the current one\n    var previous_group = \"\"\n\
    \    // Variable to use for indexing the current group\n    var counter = 0\n\
    \    // While our previous group doesn't equal the current input string\n    while\
    \ previous_group != input_str {\n        // Remove the first element from the\
    \ input string (remove the first brace)\n        input_str.removeFirst()\n   \
    \     // Our previous group is now the current one\n        previous_group = input_str\n\
    \        // For each character in the input string\n        for character in input_str\
    \ {\n            // If the character is a closing brace\n            if character\
    \ == \")\" {\n                // Remove the current character\n              \
    \  input_str.remove(at: input_str.index(input_str.startIndex, offsetBy: counter))\n\
    \                // Append the current group to the group array\n            \
    \    group_arr.append(input_str)\n                // Break out of the for loop\n\
    \                break\n            }\n            // Increment the counter variable\n\
    \            counter += 1\n        }\n        // Reset the counter variable\n\
    \        counter = 0\n    }\n    // Return the group array\n    return group_arr\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(separate_paren_groups(paren_string: \"(()()) ((()))\
    \ () ((())()())\") == [\"(()())\", \"((()))\", \"()\", \"((())()())\"])\nassert(separate_paren_groups(paren_string:\
    \ \"() (()) ((())) (((())))\") == [\"()\", \"(())\", \"((()))\", \"(((())))\"\
    ])\nassert(separate_paren_groups(paren_string: \"(()(())((())))\") == [\"(()(())((())))\"\
    ])\nassert(separate_paren_groups(paren_string: \"( ) (( )) (( )( ))\") == [\"\
    ()\", \"(())\", \"(()())\"])"
  status: Exception
  stderr: 'tmp3fref384/tmp3fref384.swift:57: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b924191ec80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b9241615b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b9241615988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b92416147b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmp3fref384                        0x00005566efd9d9a7 <unavailable> + 6567

    5    libc.so.6                          0x00002b9241b0a460 __libc_start_main +
    245

    6    tmp3fref384                        0x00005566efd9d539 <unavailable> + 5433

    '
  stdout: ''
  timestamp: 1659980040
- exit_code: 1
  program: "\n/// Input to this function is a string containing multiple groups of\
    \ nested parentheses. Your goal is to\n/// separate those group into separate\
    \ strings and return the array of those.\n/// Separate groups are balanced (each\
    \ open brace is properly closed) and not nested within each other\n/// Ignore\
    \ any spaces in the input string.\n/// >>> separate_paren_groups(paren_string:\
    \ \"( ) (( )) (( )( ))\")\n/// [\"()\", \"(())\", \"(()())\"]\nfunc separate_paren_groups(paren_string:\
    \ String) -> [String] {\n    \n    var result = [String]()\n    var startIndex\
    \ = 0\n    var endIndex = 0\n    var paren_string = paren_string\n    \n    while\
    \ paren_string.characters.count > 0 {\n        if paren_string.hasPrefix(\"(\"\
    ) {\n            startIndex = 0\n            endIndex = 0\n            for char\
    \ in paren_string.characters {\n                if char == \"(\" {\n         \
    \           startIndex += 1\n                } else if char == \")\" {\n     \
    \               endIndex += 1\n                }\n                if startIndex\
    \ == endIndex {\n                    break\n                }\n            }\n\
    \            result.append(paren_string.substring(to: paren_string.index(paren_string.startIndex,\
    \ offsetBy: startIndex * 2)))\n            if paren_string.characters.count >\
    \ startIndex * 2 {\n                paren_string = paren_string.substring(from:\
    \ paren_string.index(paren_string.startIndex, offsetBy: startIndex * 2))\n   \
    \         } else {\n                paren_string = \"\"\n            }\n     \
    \   } else {\n            paren_string = paren_string.substring(from: paren_string.index(paren_string.startIndex,\
    \ offsetBy: 1))\n        }\n    }\n    \n    return result\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(separate_paren_groups(paren_string: \"(()()) ((())) ()\
    \ ((())()())\") == [\"(()())\", \"((()))\", \"()\", \"((())()())\"])\nassert(separate_paren_groups(paren_string:\
    \ \"() (()) ((())) (((())))\") == [\"()\", \"(())\", \"((()))\", \"(((())))\"\
    ])\nassert(separate_paren_groups(paren_string: \"(()(())((())))\") == [\"(()(())((())))\"\
    ])\nassert(separate_paren_groups(paren_string: \"( ) (( )) (( )( ))\") == [\"\
    ()\", \"(())\", \"(()())\"])"
  status: SyntaxError
  stderr: "/tmp/tmp8ilyb5fh.swift:15:24: error: 'characters' is unavailable: Please\
    \ use String directly\n    while paren_string.characters.count > 0 {\n       \
    \                ^~~~~~~~~~\nSwift.String:5:16: note: 'characters' was obsoleted\
    \ in Swift 5.0\n    public var characters: String { get set }\n              \
    \ ^\n/tmp/tmp8ilyb5fh.swift:19:38: error: 'characters' is unavailable: Please\
    \ use String directly\n            for char in paren_string.characters {\n   \
    \                                  ^~~~~~~~~~\nSwift.String:5:16: note: 'characters'\
    \ was obsoleted in Swift 5.0\n    public var characters: String { get set }\n\
    \               ^\n/tmp/tmp8ilyb5fh.swift:29:40: error: value of type 'String'\
    \ has no member 'substring'\n            result.append(paren_string.substring(to:\
    \ paren_string.index(paren_string.startIndex, offsetBy: startIndex * 2)))\n  \
    \                        ~~~~~~~~~~~~ ^~~~~~~~~\n/tmp/tmp8ilyb5fh.swift:30:29:\
    \ error: 'characters' is unavailable: Please use String directly\n           \
    \ if paren_string.characters.count > startIndex * 2 {\n                      \
    \      ^~~~~~~~~~\nSwift.String:5:16: note: 'characters' was obsoleted in Swift\
    \ 5.0\n    public var characters: String { get set }\n               ^\n/tmp/tmp8ilyb5fh.swift:31:45:\
    \ error: value of type 'String' has no member 'substring'\n                paren_string\
    \ = paren_string.substring(from: paren_string.index(paren_string.startIndex, offsetBy:\
    \ startIndex * 2))\n                               ~~~~~~~~~~~~ ^~~~~~~~~\n/tmp/tmp8ilyb5fh.swift:36:41:\
    \ error: value of type 'String' has no member 'substring'\n            paren_string\
    \ = paren_string.substring(from: paren_string.index(paren_string.startIndex, offsetBy:\
    \ 1))\n                           ~~~~~~~~~~~~ ^~~~~~~~~\n"
  stdout: ''
  timestamp: 1659980040
- exit_code: -4
  program: "\n/// Input to this function is a string containing multiple groups of\
    \ nested parentheses. Your goal is to\n/// separate those group into separate\
    \ strings and return the array of those.\n/// Separate groups are balanced (each\
    \ open brace is properly closed) and not nested within each other\n/// Ignore\
    \ any spaces in the input string.\n/// >>> separate_paren_groups(paren_string:\
    \ \"( ) (( )) (( )( ))\")\n/// [\"()\", \"(())\", \"(()())\"]\nfunc separate_paren_groups(paren_string:\
    \ String) -> [String] {\n    return []\n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(separate_paren_groups(paren_string: \"(()()) ((())) () ((())()())\") ==\
    \ [\"(()())\", \"((()))\", \"()\", \"((())()())\"])\nassert(separate_paren_groups(paren_string:\
    \ \"() (()) ((())) (((())))\") == [\"()\", \"(())\", \"((()))\", \"(((())))\"\
    ])\nassert(separate_paren_groups(paren_string: \"(()(())((())))\") == [\"(()(())((())))\"\
    ])\nassert(separate_paren_groups(paren_string: \"( ) (( )) (( )( ))\") == [\"\
    ()\", \"(())\", \"(()())\"])"
  status: Exception
  stderr: 'tmp1zdkbtz2/tmp1zdkbtz2.swift:25: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002aeebe8b5c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002aeebe5acb6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002aeebe5ac988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002aeebe5ab7b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmp1zdkbtz2                        0x0000556857c08537 <unavailable> + 5431

    5    libc.so.6                          0x00002aeebeaa1460 __libc_start_main +
    245

    6    tmp1zdkbtz2                        0x0000556857c080c9 <unavailable> + 4297

    '
  stdout: ''
  timestamp: 1659980040
- exit_code: -4
  program: "\n/// Input to this function is a string containing multiple groups of\
    \ nested parentheses. Your goal is to\n/// separate those group into separate\
    \ strings and return the array of those.\n/// Separate groups are balanced (each\
    \ open brace is properly closed) and not nested within each other\n/// Ignore\
    \ any spaces in the input string.\n/// >>> separate_paren_groups(paren_string:\
    \ \"( ) (( )) (( )( ))\")\n/// [\"()\", \"(())\", \"(()())\"]\nfunc separate_paren_groups(paren_string:\
    \ String) -> [String] {\n    return []\n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(separate_paren_groups(paren_string: \"(()()) ((())) () ((())()())\") ==\
    \ [\"(()())\", \"((()))\", \"()\", \"((())()())\"])\nassert(separate_paren_groups(paren_string:\
    \ \"() (()) ((())) (((())))\") == [\"()\", \"(())\", \"((()))\", \"(((())))\"\
    ])\nassert(separate_paren_groups(paren_string: \"(()(())((())))\") == [\"(()(())((())))\"\
    ])\nassert(separate_paren_groups(paren_string: \"( ) (( )) (( )( ))\") == [\"\
    ()\", \"(())\", \"(()())\"])"
  status: Exception
  stderr: 'tmp1zdkbtz2/tmp1zdkbtz2.swift:25: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002aeebe8b5c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002aeebe5acb6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002aeebe5ac988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002aeebe5ab7b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmp1zdkbtz2                        0x0000556857c08537 <unavailable> + 5431

    5    libc.so.6                          0x00002aeebeaa1460 __libc_start_main +
    245

    6    tmp1zdkbtz2                        0x0000556857c080c9 <unavailable> + 4297

    '
  stdout: ''
  timestamp: 1659980040
- exit_code: 0
  program: "\n/// Input to this function is a string containing multiple groups of\
    \ nested parentheses. Your goal is to\n/// separate those group into separate\
    \ strings and return the array of those.\n/// Separate groups are balanced (each\
    \ open brace is properly closed) and not nested within each other\n/// Ignore\
    \ any spaces in the input string.\n/// >>> separate_paren_groups(paren_string:\
    \ \"( ) (( )) (( )( ))\")\n/// [\"()\", \"(())\", \"(()())\"]\nfunc separate_paren_groups(paren_string:\
    \ String) -> [String] {\n    var groups: [String] = []\n    var current_group:\
    \ String = \"\"\n    var nested_count: Int = 0\n    for c in paren_string {\n\
    \        if c == \"(\" {\n            nested_count += 1\n            current_group\
    \ += String(c)\n        } else if c == \")\" {\n            nested_count -= 1\n\
    \            current_group += String(c)\n            if nested_count == 0 {\n\
    \                groups.append(current_group)\n                current_group =\
    \ \"\"\n            }\n        }\n    }\n    return groups\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(separate_paren_groups(paren_string: \"(()()) ((())) ()\
    \ ((())()())\") == [\"(()())\", \"((()))\", \"()\", \"((())()())\"])\nassert(separate_paren_groups(paren_string:\
    \ \"() (()) ((())) (((())))\") == [\"()\", \"(())\", \"((()))\", \"(((())))\"\
    ])\nassert(separate_paren_groups(paren_string: \"(()(())((())))\") == [\"(()(())((())))\"\
    ])\nassert(separate_paren_groups(paren_string: \"( ) (( )) (( )( ))\") == [\"\
    ()\", \"(())\", \"(()())\"])"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659980040
- exit_code: -4
  program: "\n/// Input to this function is a string containing multiple groups of\
    \ nested parentheses. Your goal is to\n/// separate those group into separate\
    \ strings and return the array of those.\n/// Separate groups are balanced (each\
    \ open brace is properly closed) and not nested within each other\n/// Ignore\
    \ any spaces in the input string.\n/// >>> separate_paren_groups(paren_string:\
    \ \"( ) (( )) (( )( ))\")\n/// [\"()\", \"(())\", \"(()())\"]\nfunc separate_paren_groups(paren_string:\
    \ String) -> [String] {\n    // TODO: Implement\n    return []\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(separate_paren_groups(paren_string: \"(()()) ((())) ()\
    \ ((())()())\") == [\"(()())\", \"((()))\", \"()\", \"((())()())\"])\nassert(separate_paren_groups(paren_string:\
    \ \"() (()) ((())) (((())))\") == [\"()\", \"(())\", \"((()))\", \"(((())))\"\
    ])\nassert(separate_paren_groups(paren_string: \"(()(())((())))\") == [\"(()(())((())))\"\
    ])\nassert(separate_paren_groups(paren_string: \"( ) (( )) (( )( ))\") == [\"\
    ()\", \"(())\", \"(()())\"])"
  status: Exception
  stderr: 'tmpnx72nmyc/tmpnx72nmyc.swift:26: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b0e6391ac80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b0e63611b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b0e63611988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b0e636107b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpnx72nmyc                        0x00005616ead01537 <unavailable> + 5431

    5    libc.so.6                          0x00002b0e63b06460 __libc_start_main +
    245

    6    tmpnx72nmyc                        0x00005616ead010c9 <unavailable> + 4297

    '
  stdout: ''
  timestamp: 1659980040
- exit_code: -4
  program: "\n/// Input to this function is a string containing multiple groups of\
    \ nested parentheses. Your goal is to\n/// separate those group into separate\
    \ strings and return the array of those.\n/// Separate groups are balanced (each\
    \ open brace is properly closed) and not nested within each other\n/// Ignore\
    \ any spaces in the input string.\n/// >>> separate_paren_groups(paren_string:\
    \ \"( ) (( )) (( )( ))\")\n/// [\"()\", \"(())\", \"(()())\"]\nfunc separate_paren_groups(paren_string:\
    \ String) -> [String] {\n    var result = [String]()\n    var buffer = \"\"\n\
    \    var open_parens = 0\n    for char in paren_string {\n        if char == \"\
    (\" {\n            open_parens += 1\n        } else if char == \")\" {\n     \
    \       open_parens -= 1\n        }\n        if open_parens == 0 {\n         \
    \   if !buffer.isEmpty {\n                result.append(buffer)\n            \
    \    buffer = \"\"\n            }\n        } else {\n            buffer.append(char)\n\
    \        }\n    }\n    return result\n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(separate_paren_groups(paren_string: \"(()()) ((())) () ((())()())\") ==\
    \ [\"(()())\", \"((()))\", \"()\", \"((())()())\"])\nassert(separate_paren_groups(paren_string:\
    \ \"() (()) ((())) (((())))\") == [\"()\", \"(())\", \"((()))\", \"(((())))\"\
    ])\nassert(separate_paren_groups(paren_string: \"(()(())((())))\") == [\"(()(())((())))\"\
    ])\nassert(separate_paren_groups(paren_string: \"( ) (( )) (( )( ))\") == [\"\
    ()\", \"(())\", \"(()())\"])"
  status: Exception
  stderr: 'tmpqug9eg4y/tmpqug9eg4y.swift:43: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b95d8c64c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b95d895bb6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b95d895b988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b95d895a7b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpqug9eg4y                        0x0000558f05cfa837 <unavailable> + 6199

    5    libc.so.6                          0x00002b95d8e50460 __libc_start_main +
    245

    6    tmpqug9eg4y                        0x0000558f05cfa3c9 <unavailable> + 5065

    '
  stdout: ''
  timestamp: 1659980040
- exit_code: 1
  program: "\n/// Input to this function is a string containing multiple groups of\
    \ nested parentheses. Your goal is to\n/// separate those group into separate\
    \ strings and return the array of those.\n/// Separate groups are balanced (each\
    \ open brace is properly closed) and not nested within each other\n/// Ignore\
    \ any spaces in the input string.\n/// >>> separate_paren_groups(paren_string:\
    \ \"( ) (( )) (( )( ))\")\n/// [\"()\", \"(())\", \"(()())\"]\nfunc separate_paren_groups(paren_string:\
    \ String) -> [String] {\n    var arr: [String] = []\n    var stack = Stack<Character>()\n\
    \    var temp = \"\"\n    for paren in paren_string {\n        if paren == \"\
    \ \" {\n            continue\n        }\n        if paren == \"(\" {\n       \
    \     stack.push(paren)\n        } else if paren == \")\" {\n            stack.pop()\n\
    \            temp += String(paren)\n            if stack.isEmpty() {\n       \
    \         arr.append(temp)\n                temp = \"\"\n            }\n     \
    \   }\n    }\n    return arr\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int,\
    \ Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n\
    \    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n          \
    \  return false\n        }\n    }\n    return true\n}\n            \nassert(separate_paren_groups(paren_string:\
    \ \"(()()) ((())) () ((())()())\") == [\"(()())\", \"((()))\", \"()\", \"((())()())\"\
    ])\nassert(separate_paren_groups(paren_string: \"() (()) ((())) (((())))\") ==\
    \ [\"()\", \"(())\", \"((()))\", \"(((())))\"])\nassert(separate_paren_groups(paren_string:\
    \ \"(()(())((())))\") == [\"(()(())((())))\"])\nassert(separate_paren_groups(paren_string:\
    \ \"( ) (( )) (( )( ))\") == [\"()\", \"(())\", \"(()())\"])"
  status: SyntaxError
  stderr: "/tmp/tmp82oh277p.swift:10:17: error: cannot find 'Stack' in scope\n   \
    \ var stack = Stack<Character>()\n                ^~~~~\n"
  stdout: ''
  timestamp: 1659980040
- exit_code: 1
  program: "\n/// Input to this function is a string containing multiple groups of\
    \ nested parentheses. Your goal is to\n/// separate those group into separate\
    \ strings and return the array of those.\n/// Separate groups are balanced (each\
    \ open brace is properly closed) and not nested within each other\n/// Ignore\
    \ any spaces in the input string.\n/// >>> separate_paren_groups(paren_string:\
    \ \"( ) (( )) (( )( ))\")\n/// [\"()\", \"(())\", \"(()())\"]\nfunc separate_paren_groups(paren_string:\
    \ String) -> [String] {\n    var result = [String]()\n    var input = paren_string\n\
    \    while input.count > 0 {\n        let paren = extract_paren_group(paren_string:\
    \ input)\n        input = paren.1\n        result.append(paren.0)\n    }\n   \
    \ return result\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool\
    \ {\n    if left.count != right.count {\n        return false\n    }\n    for\
    \ (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(separate_paren_groups(paren_string:\
    \ \"(()()) ((())) () ((())()())\") == [\"(()())\", \"((()))\", \"()\", \"((())()())\"\
    ])\nassert(separate_paren_groups(paren_string: \"() (()) ((())) (((())))\") ==\
    \ [\"()\", \"(())\", \"((()))\", \"(((())))\"])\nassert(separate_paren_groups(paren_string:\
    \ \"(()(())((())))\") == [\"(()(())((())))\"])\nassert(separate_paren_groups(paren_string:\
    \ \"( ) (( )) (( )( ))\") == [\"()\", \"(())\", \"(()())\"])"
  status: SyntaxError
  stderr: "/tmp/tmpvvp3cg4x.swift:12:21: error: cannot find 'extract_paren_group'\
    \ in scope\n        let paren = extract_paren_group(paren_string: input)\n   \
    \                 ^~~~~~~~~~~~~~~~~~~\n"
  stdout: ''
  timestamp: 1659980040
- exit_code: 1
  program: "\n/// Input to this function is a string containing multiple groups of\
    \ nested parentheses. Your goal is to\n/// separate those group into separate\
    \ strings and return the array of those.\n/// Separate groups are balanced (each\
    \ open brace is properly closed) and not nested within each other\n/// Ignore\
    \ any spaces in the input string.\n/// >>> separate_paren_groups(paren_string:\
    \ \"( ) (( )) (( )( ))\")\n/// [\"()\", \"(())\", \"(()())\"]\nfunc separate_paren_groups(paren_string:\
    \ String) -> [String] {\n    var parens_arr = paren_string.components(separatedBy:\
    \ .whitespaces)\n    parens_arr = parens_arr.filter { $0 != \"\" }\n    parens_arr\
    \ = parens_arr.map { $0.map { $0 == \" \" ? \"\" : $0 } }\n    parens_arr = parens_arr.map\
    \ { $0.joined() }\n    var opening_paren_dict = [Int: Int]()\n    var closing_paren_dict\
    \ = [Int: Int]()\n    var result = [String]()\n    for (index, each_paren) in\
    \ parens_arr.enumerated() {\n        if each_paren == \"(\" {\n            opening_paren_dict[index]\
    \ = index\n        } else {\n            closing_paren_dict[index] = index\n \
    \       }\n    }\n    var sorted_closing_paren_key = closing_paren_dict.keys.sorted()\n\
    \    var sorted_opening_paren_key = opening_paren_dict.keys.sorted()\n    for\
    \ i in sorted_closing_paren_key {\n        var matched_opening_paren = 0\n   \
    \     for j in sorted_opening_paren_key {\n            if j < i {\n          \
    \      matched_opening_paren = j\n            } else {\n                sorted_opening_paren_key.remove(at:\
    \ sorted_opening_paren_key.firstIndex(of: matched_opening_paren)!)\n         \
    \       result.append(String(parens_arr[matched_opening_paren...i].joined()))\n\
    \                break\n            }\n        }\n    }\n    return result\n}\n\
    \n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(separate_paren_groups(paren_string: \"(()()) ((()))\
    \ () ((())()())\") == [\"(()())\", \"((()))\", \"()\", \"((())()())\"])\nassert(separate_paren_groups(paren_string:\
    \ \"() (()) ((())) (((())))\") == [\"()\", \"(())\", \"((()))\", \"(((())))\"\
    ])\nassert(separate_paren_groups(paren_string: \"(()(())((())))\") == [\"(()(())((())))\"\
    ])\nassert(separate_paren_groups(paren_string: \"( ) (( )) (( )( ))\") == [\"\
    ()\", \"(())\", \"(()())\"])"
  status: SyntaxError
  stderr: "/tmp/tmpf576vmcr.swift:9:35: error: value of type 'String' has no member\
    \ 'components'\n    var parens_arr = paren_string.components(separatedBy: .whitespaces)\n\
    \                     ~~~~~~~~~~~~ ^~~~~~~~~~\n/tmp/tmpf576vmcr.swift:9:60: error:\
    \ cannot infer contextual base in reference to member 'whitespaces'\n    var parens_arr\
    \ = paren_string.components(separatedBy: .whitespaces)\n                     \
    \                                     ~^~~~~~~~~~~\n"
  stdout: ''
  timestamp: 1659980040
- exit_code: -4
  program: "\n/// Input to this function is a string containing multiple groups of\
    \ nested parentheses. Your goal is to\n/// separate those group into separate\
    \ strings and return the array of those.\n/// Separate groups are balanced (each\
    \ open brace is properly closed) and not nested within each other\n/// Ignore\
    \ any spaces in the input string.\n/// >>> separate_paren_groups(paren_string:\
    \ \"( ) (( )) (( )( ))\")\n/// [\"()\", \"(())\", \"(()())\"]\nfunc separate_paren_groups(paren_string:\
    \ String) -> [String] {\n    /// Create a new mutable array\n    var finalArray\
    \ = [String]()\n    /// Create a new string variable\n    var newString = \"\"\
    \n    /// Create a counter\n    var counter = 0\n    /// Loop through the characters\
    \ in the string\n    for character in paren_string {\n        /// If the character\
    \ is equal to a \"(\" add 1 to the counter\n        if character == \"(\" {\n\
    \            counter += 1\n        }\n        /// If the character is equal to\
    \ a \")\" subtract 1 from the counter\n        if character == \")\" {\n     \
    \       counter -= 1\n        }\n        /// Add the character to the new string\n\
    \        newString += String(character)\n        /// If the counter is equal to\
    \ 0\n        if counter == 0 {\n            /// Add the new string to the array\n\
    \            finalArray.append(newString)\n            /// Reset the new string\n\
    \            newString = \"\"\n        }\n    }\n    /// Return the final array\n\
    \    return finalArray\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(separate_paren_groups(paren_string:\
    \ \"(()()) ((())) () ((())()())\") == [\"(()())\", \"((()))\", \"()\", \"((())()())\"\
    ])\nassert(separate_paren_groups(paren_string: \"() (()) ((())) (((())))\") ==\
    \ [\"()\", \"(())\", \"((()))\", \"(((())))\"])\nassert(separate_paren_groups(paren_string:\
    \ \"(()(())((())))\") == [\"(()(())((())))\"])\nassert(separate_paren_groups(paren_string:\
    \ \"( ) (( )) (( )( ))\") == [\"()\", \"(())\", \"(()())\"])"
  status: Exception
  stderr: 'tmpcrd18pe3/tmpcrd18pe3.swift:52: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b2b67a4bc80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b2b67742b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b2b67742988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b2b677417b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpcrd18pe3                        0x0000556c13cfc837 <unavailable> + 6199

    5    libc.so.6                          0x00002b2b67c37460 __libc_start_main +
    245

    6    tmpcrd18pe3                        0x0000556c13cfc3c9 <unavailable> + 5065

    '
  stdout: ''
  timestamp: 1659980040
- exit_code: 1
  program: "\n/// Input to this function is a string containing multiple groups of\
    \ nested parentheses. Your goal is to\n/// separate those group into separate\
    \ strings and return the array of those.\n/// Separate groups are balanced (each\
    \ open brace is properly closed) and not nested within each other\n/// Ignore\
    \ any spaces in the input string.\n/// >>> separate_paren_groups(paren_string:\
    \ \"( ) (( )) (( )( ))\")\n/// [\"()\", \"(())\", \"(()())\"]\nfunc separate_paren_groups(paren_string:\
    \ String) -> [String] {\n    let parens = paren_string.replacingOccurrences(of:\
    \ \" \", with: \"\")\n    let parensArr = parens.characters.map{String($0)}\n\
    \    var index = 0\n    var results = [String]()\n    while index < parensArr.count\
    \ {\n        if parensArr[index] == \"(\" {\n            var start = index\n \
    \           var end = index\n            for paren in parensArr[index..<parensArr.count]\
    \ {\n                if paren == \"(\" {\n                    end += 1\n     \
    \           } else if paren == \")\" {\n                    end += 1\n       \
    \             break\n                }\n            }\n            results.append(String(parensArr[start..<end]))\n\
    \            index = end\n        } else {\n            index += 1\n        }\n\
    \    }\n    return results\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(separate_paren_groups(paren_string:\
    \ \"(()()) ((())) () ((())()())\") == [\"(()())\", \"((()))\", \"()\", \"((())()())\"\
    ])\nassert(separate_paren_groups(paren_string: \"() (()) ((())) (((())))\") ==\
    \ [\"()\", \"(())\", \"((()))\", \"(((())))\"])\nassert(separate_paren_groups(paren_string:\
    \ \"(()(())((())))\") == [\"(()(())((())))\"])\nassert(separate_paren_groups(paren_string:\
    \ \"( ) (( )) (( )( ))\") == [\"()\", \"(())\", \"(()())\"])"
  status: SyntaxError
  stderr: "/tmp/tmp5v4mn6kx.swift:9:31: error: value of type 'String' has no member\
    \ 'replacingOccurrences'\n    let parens = paren_string.replacingOccurrences(of:\
    \ \" \", with: \"\")\n                 ~~~~~~~~~~~~ ^~~~~~~~~~~~~~~~~~~~\n"
  stdout: ''
  timestamp: 1659980040
- exit_code: -4
  program: "\n/// Input to this function is a string containing multiple groups of\
    \ nested parentheses. Your goal is to\n/// separate those group into separate\
    \ strings and return the array of those.\n/// Separate groups are balanced (each\
    \ open brace is properly closed) and not nested within each other\n/// Ignore\
    \ any spaces in the input string.\n/// >>> separate_paren_groups(paren_string:\
    \ \"( ) (( )) (( )( ))\")\n/// [\"()\", \"(())\", \"(()())\"]\nfunc separate_paren_groups(paren_string:\
    \ String) -> [String] {\n    // TODO: Return an array of strings from the input\
    \ string, separate groups of parentheses\n    var result = [String]()\n    var\
    \ temp = \"\"\n    var open = 0\n    var close = 0\n    for i in paren_string\
    \ {\n        if i == \"(\" {\n            open += 1\n        } else if i == \"\
    )\" {\n            close += 1\n        }\n        if open != close && (open -\
    \ close) == 1 {\n            temp += String(i)\n        } else if open == close\
    \ {\n            temp += String(i)\n            result.append(temp)\n        \
    \    temp = \"\"\n            open = 0\n            close = 0\n        }\n   \
    \ }\n    return result\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(separate_paren_groups(paren_string:\
    \ \"(()()) ((())) () ((())()())\") == [\"(()())\", \"((()))\", \"()\", \"((())()())\"\
    ])\nassert(separate_paren_groups(paren_string: \"() (()) ((())) (((())))\") ==\
    \ [\"()\", \"(())\", \"((()))\", \"(((())))\"])\nassert(separate_paren_groups(paren_string:\
    \ \"(()(())((())))\") == [\"(()(())((())))\"])\nassert(separate_paren_groups(paren_string:\
    \ \"( ) (( )) (( )( ))\") == [\"()\", \"(())\", \"(()())\"])"
  status: Exception
  stderr: 'tmp4_l__deu/tmp4_l__deu.swift:46: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b02fc1a8c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b02fbe9fb6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b02fbe9f988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b02fbe9e7b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmp4_l__deu                        0x00005630edeb6837 <unavailable> + 6199

    5    libc.so.6                          0x00002b02fc394460 __libc_start_main +
    245

    6    tmp4_l__deu                        0x00005630edeb63c9 <unavailable> + 5065

    '
  stdout: ''
  timestamp: 1659980040
- exit_code: -4
  program: "\n/// Input to this function is a string containing multiple groups of\
    \ nested parentheses. Your goal is to\n/// separate those group into separate\
    \ strings and return the array of those.\n/// Separate groups are balanced (each\
    \ open brace is properly closed) and not nested within each other\n/// Ignore\
    \ any spaces in the input string.\n/// >>> separate_paren_groups(paren_string:\
    \ \"( ) (( )) (( )( ))\")\n/// [\"()\", \"(())\", \"(()())\"]\nfunc separate_paren_groups(paren_string:\
    \ String) -> [String] {\n    // TODO: Write some code to solve this coding challenge\n\
    \    return []\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool\
    \ {\n    if left.count != right.count {\n        return false\n    }\n    for\
    \ (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(separate_paren_groups(paren_string:\
    \ \"(()()) ((())) () ((())()())\") == [\"(()())\", \"((()))\", \"()\", \"((())()())\"\
    ])\nassert(separate_paren_groups(paren_string: \"() (()) ((())) (((())))\") ==\
    \ [\"()\", \"(())\", \"((()))\", \"(((())))\"])\nassert(separate_paren_groups(paren_string:\
    \ \"(()(())((())))\") == [\"(()(())((())))\"])\nassert(separate_paren_groups(paren_string:\
    \ \"( ) (( )) (( )( ))\") == [\"()\", \"(())\", \"(()())\"])"
  status: Exception
  stderr: 'tmp1ggojxn_/tmp1ggojxn_.swift:26: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b2e13e01c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b2e13af8b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b2e13af8988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b2e13af77b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmp1ggojxn_                        0x00005621d2dae537 <unavailable> + 5431

    5    libc.so.6                          0x00002b2e13fed460 __libc_start_main +
    245

    6    tmp1ggojxn_                        0x00005621d2dae0c9 <unavailable> + 4297

    '
  stdout: ''
  timestamp: 1659980040
- exit_code: 1
  program: "\n/// Input to this function is a string containing multiple groups of\
    \ nested parentheses. Your goal is to\n/// separate those group into separate\
    \ strings and return the array of those.\n/// Separate groups are balanced (each\
    \ open brace is properly closed) and not nested within each other\n/// Ignore\
    \ any spaces in the input string.\n/// >>> separate_paren_groups(paren_string:\
    \ \"( ) (( )) (( )( ))\")\n/// [\"()\", \"(())\", \"(()())\"]\nfunc separate_paren_groups(paren_string:\
    \ String) -> [String] {\n    var groups: [String] = []\n    var parens_string\
    \ = paren_string.replacingOccurrences(of: \" \", with: \"\")\n    var current_group:\
    \ String = \"\"\n    var last_index: Int = 0\n    for index in 0...parens_string.count\
    \ - 1 {\n        let current_char = parens_string[index]\n        if current_char\
    \ == \"(\" {\n            last_index = index\n            current_group.append(current_char)\n\
    \        } else if current_char == \")\" {\n            current_group.append(current_char)\n\
    \            if current_group.count % 2 == 0 {\n                groups.append(current_group)\n\
    \                current_group = \"\"\n            }\n        }\n    }\n    if\
    \ current_group != \"\" {\n        groups.append(parens_string[last_index...])\n\
    \    }\n    return groups\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(separate_paren_groups(paren_string:\
    \ \"(()()) ((())) () ((())()())\") == [\"(()())\", \"((()))\", \"()\", \"((())()())\"\
    ])\nassert(separate_paren_groups(paren_string: \"() (()) ((())) (((())))\") ==\
    \ [\"()\", \"(())\", \"((()))\", \"(((())))\"])\nassert(separate_paren_groups(paren_string:\
    \ \"(()(())((())))\") == [\"(()(())((())))\"])\nassert(separate_paren_groups(paren_string:\
    \ \"( ) (( )) (( )( ))\") == [\"()\", \"(())\", \"(()())\"])"
  status: SyntaxError
  stderr: "/tmp/tmpydqpoz2x.swift:10:38: error: value of type 'String' has no member\
    \ 'replacingOccurrences'\n    var parens_string = paren_string.replacingOccurrences(of:\
    \ \" \", with: \"\")\n                        ~~~~~~~~~~~~ ^~~~~~~~~~~~~~~~~~~~\n"
  stdout: ''
  timestamp: 1659980040
- exit_code: 1
  program: "\n/// Input to this function is a string containing multiple groups of\
    \ nested parentheses. Your goal is to\n/// separate those group into separate\
    \ strings and return the array of those.\n/// Separate groups are balanced (each\
    \ open brace is properly closed) and not nested within each other\n/// Ignore\
    \ any spaces in the input string.\n/// >>> separate_paren_groups(paren_string:\
    \ \"( ) (( )) (( )( ))\")\n/// [\"()\", \"(())\", \"(()())\"]\nfunc separate_paren_groups(paren_string:\
    \ String) -> [String] {\n  var n = paren_string.count\n  var result: [String]\
    \ = []\n  var leftCount = 0\n  var rightCount = 0\n  var currentString = \"\"\n\
    \  for i in 0..<n {\n    let c = paren_string[i]\n    if c == \"(\" {\n      leftCount\
    \ += 1\n    } else if c == \")\" {\n      rightCount += 1\n    }\n    if rightCount\
    \ == leftCount {\n      result.append(currentString)\n      currentString = \"\
    \"\n      leftCount = 0\n      rightCount = 0\n    } else {\n      currentString.append(c)\n\
    \    }\n  }\n  return result\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int,\
    \ Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n\
    \    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n          \
    \  return false\n        }\n    }\n    return true\n}\n            \nassert(separate_paren_groups(paren_string:\
    \ \"(()()) ((())) () ((())()())\") == [\"(()())\", \"((()))\", \"()\", \"((())()())\"\
    ])\nassert(separate_paren_groups(paren_string: \"() (()) ((())) (((())))\") ==\
    \ [\"()\", \"(())\", \"((()))\", \"(((())))\"])\nassert(separate_paren_groups(paren_string:\
    \ \"(()(())((())))\") == [\"(()(())((())))\"])\nassert(separate_paren_groups(paren_string:\
    \ \"( ) (( )) (( )( ))\") == [\"()\", \"(())\", \"(()())\"])"
  status: SyntaxError
  stderr: "/tmp/tmpr9zx21t6.swift:15:13: error: 'subscript(_:)' is unavailable: cannot\
    \ subscript String with an Int, use a String.Index instead.\n    let c = paren_string[i]\n\
    \            ^~~~~~~~~~~~~~~\nSwift.String:3:12: note: 'subscript(_:)' has been\
    \ explicitly marked unavailable here\n    public subscript(i: Int) -> Character\
    \ { get }\n           ^\n/tmp/tmpr9zx21t6.swift:9:7: warning: variable 'n' was\
    \ never mutated; consider changing to 'let' constant\n  var n = paren_string.count\n\
    \  ~~~ ^\n  let\n"
  stdout: ''
  timestamp: 1659980040
- exit_code: 1
  program: "\n/// Input to this function is a string containing multiple groups of\
    \ nested parentheses. Your goal is to\n/// separate those group into separate\
    \ strings and return the array of those.\n/// Separate groups are balanced (each\
    \ open brace is properly closed) and not nested within each other\n/// Ignore\
    \ any spaces in the input string.\n/// >>> separate_paren_groups(paren_string:\
    \ \"( ) (( )) (( )( ))\")\n/// [\"()\", \"(())\", \"(()())\"]\nfunc separate_paren_groups(paren_string:\
    \ String) -> [String] {\n    let chars = paren_string.trimmingCharacters(in: CharacterSet.whitespacesAndNewlines)\n\
    \    var openParens = 0\n    var start = 0\n    var stringArray: [String] = []\n\
    \    for i in 0..<chars.count {\n        let sIndex = chars.index(chars.startIndex,\
    \ offsetBy: i)\n        if chars[sIndex] == \"(\" {\n            openParens +=\
    \ 1\n        } else if chars[sIndex] == \")\" {\n            openParens -= 1\n\
    \        }\n        if openParens == 0 {\n            stringArray.append(String(chars[chars.index(chars.startIndex,\
    \ offsetBy: start)..<chars.index(chars.startIndex, offsetBy: i + 1)]))\n     \
    \       start = i + 1\n        }\n    }\n    return stringArray\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(separate_paren_groups(paren_string: \"(()()) ((())) ()\
    \ ((())()())\") == [\"(()())\", \"((()))\", \"()\", \"((())()())\"])\nassert(separate_paren_groups(paren_string:\
    \ \"() (()) ((())) (((())))\") == [\"()\", \"(())\", \"((()))\", \"(((())))\"\
    ])\nassert(separate_paren_groups(paren_string: \"(()(())((())))\") == [\"(()(())((())))\"\
    ])\nassert(separate_paren_groups(paren_string: \"( ) (( )) (( )( ))\") == [\"\
    ()\", \"(())\", \"(()())\"])"
  status: SyntaxError
  stderr: "/tmp/tmp_9og5la8.swift:9:53: error: cannot find 'CharacterSet' in scope\n\
    \    let chars = paren_string.trimmingCharacters(in: CharacterSet.whitespacesAndNewlines)\n\
    \                                                    ^~~~~~~~~~~~\n/tmp/tmp_9og5la8.swift:9:30:\
    \ error: value of type 'String' has no member 'trimmingCharacters'\n    let chars\
    \ = paren_string.trimmingCharacters(in: CharacterSet.whitespacesAndNewlines)\n\
    \                ~~~~~~~~~~~~ ^~~~~~~~~~~~~~~~~~\n"
  stdout: ''
  timestamp: 1659980040
- exit_code: 0
  program: "\n/// Input to this function is a string containing multiple groups of\
    \ nested parentheses. Your goal is to\n/// separate those group into separate\
    \ strings and return the array of those.\n/// Separate groups are balanced (each\
    \ open brace is properly closed) and not nested within each other\n/// Ignore\
    \ any spaces in the input string.\n/// >>> separate_paren_groups(paren_string:\
    \ \"( ) (( )) (( )( ))\")\n/// [\"()\", \"(())\", \"(()())\"]\nfunc separate_paren_groups(paren_string:\
    \ String) -> [String] {\n    let parens: [Character] = [\"(\", \")\"]\n    let\
    \ dict = paren_string.filter {parens.contains($0)}\n    var result: [String] =\
    \ []\n    var temp = \"\"\n    var unclosed = 0\n    for paren in dict {\n   \
    \     if paren == \"(\" {\n            temp += String(paren)\n            unclosed\
    \ += 1\n        } else {\n            unclosed -= 1\n            temp += String(paren)\n\
    \            if unclosed == 0 {\n                result.append(temp)\n       \
    \         temp = \"\"\n            }\n        }\n    }\n    return result\n}\n\
    \n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(separate_paren_groups(paren_string: \"(()()) ((()))\
    \ () ((())()())\") == [\"(()())\", \"((()))\", \"()\", \"((())()())\"])\nassert(separate_paren_groups(paren_string:\
    \ \"() (()) ((())) (((())))\") == [\"()\", \"(())\", \"((()))\", \"(((())))\"\
    ])\nassert(separate_paren_groups(paren_string: \"(()(())((())))\") == [\"(()(())((())))\"\
    ])\nassert(separate_paren_groups(paren_string: \"( ) (( )) (( )( ))\") == [\"\
    ()\", \"(())\", \"(()())\"])"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659980040
- exit_code: 1
  program: "\n/// Input to this function is a string containing multiple groups of\
    \ nested parentheses. Your goal is to\n/// separate those group into separate\
    \ strings and return the array of those.\n/// Separate groups are balanced (each\
    \ open brace is properly closed) and not nested within each other\n/// Ignore\
    \ any spaces in the input string.\n/// >>> separate_paren_groups(paren_string:\
    \ \"( ) (( )) (( )( ))\")\n/// [\"()\", \"(())\", \"(()())\"]\nfunc separate_paren_groups(paren_string:\
    \ String) -> [String] {\n    return paren_string.replacingOccurrences(of: \" \"\
    , with: \"\").components(separatedBy: \")(\")\n}\n\n\nfunc ==(left: [(Int, Int)],\
    \ right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n       \
    \ return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r\
    \ {\n            return false\n        }\n    }\n    return true\n}\n        \
    \    \nassert(separate_paren_groups(paren_string: \"(()()) ((())) () ((())()())\"\
    ) == [\"(()())\", \"((()))\", \"()\", \"((())()())\"])\nassert(separate_paren_groups(paren_string:\
    \ \"() (()) ((())) (((())))\") == [\"()\", \"(())\", \"((()))\", \"(((())))\"\
    ])\nassert(separate_paren_groups(paren_string: \"(()(())((())))\") == [\"(()(())((())))\"\
    ])\nassert(separate_paren_groups(paren_string: \"( ) (( )) (( )( ))\") == [\"\
    ()\", \"(())\", \"(()())\"])"
  status: SyntaxError
  stderr: "/tmp/tmpsldtxd9y.swift:9:25: error: value of type 'String' has no member\
    \ 'replacingOccurrences'\n    return paren_string.replacingOccurrences(of: \"\
    \ \", with: \"\").components(separatedBy: \")(\")\n           ~~~~~~~~~~~~ ^~~~~~~~~~~~~~~~~~~~\n"
  stdout: ''
  timestamp: 1659980040
- exit_code: 1
  program: "\n/// Input to this function is a string containing multiple groups of\
    \ nested parentheses. Your goal is to\n/// separate those group into separate\
    \ strings and return the array of those.\n/// Separate groups are balanced (each\
    \ open brace is properly closed) and not nested within each other\n/// Ignore\
    \ any spaces in the input string.\n/// >>> separate_paren_groups(paren_string:\
    \ \"( ) (( )) (( )( ))\")\n/// [\"()\", \"(())\", \"(()())\"]\nfunc separate_paren_groups(paren_string:\
    \ String) -> [String] {\n    let new_string = paren_string.replacingOccurrences(of:\
    \ \" \", with: \"\")\n    var arr = Array(new_string)\n    var stacks = Stack<Character>()\n\
    \    var final = [String]()\n    var idx = 0\n    var temp = \"\"\n    while idx\
    \ < arr.count {\n        if stacks.size == 0 {\n            if arr[idx] == \"\
    (\" {\n                stacks.push(arr[idx])\n            }\n        } else {\n\
    \            if arr[idx] == \"(\" {\n                stacks.push(arr[idx])\n \
    \           } else {\n                temp += String(stacks.pop())\n         \
    \       temp += String(arr[idx])\n            }\n        }\n        idx += 1\n\
    \    }\n    final.append(temp)\n    return final\n}\n\n\nfunc ==(left: [(Int,\
    \ Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n\
    \        return false\n    }\n    for (l, r) in zip(left, right) {\n        if\
    \ l != r {\n            return false\n        }\n    }\n    return true\n}\n \
    \           \nassert(separate_paren_groups(paren_string: \"(()()) ((())) () ((())()())\"\
    ) == [\"(()())\", \"((()))\", \"()\", \"((())()())\"])\nassert(separate_paren_groups(paren_string:\
    \ \"() (()) ((())) (((())))\") == [\"()\", \"(())\", \"((()))\", \"(((())))\"\
    ])\nassert(separate_paren_groups(paren_string: \"(()(())((())))\") == [\"(()(())((())))\"\
    ])\nassert(separate_paren_groups(paren_string: \"( ) (( )) (( )( ))\") == [\"\
    ()\", \"(())\", \"(()())\"])"
  status: SyntaxError
  stderr: "/tmp/tmp8kxcr35i.swift:9:35: error: value of type 'String' has no member\
    \ 'replacingOccurrences'\n    let new_string = paren_string.replacingOccurrences(of:\
    \ \" \", with: \"\")\n                     ~~~~~~~~~~~~ ^~~~~~~~~~~~~~~~~~~~\n\
    /tmp/tmp8kxcr35i.swift:11:18: error: cannot find 'Stack' in scope\n    var stacks\
    \ = Stack<Character>()\n                 ^~~~~\n"
  stdout: ''
  timestamp: 1659980040
- exit_code: -4
  program: "\n/// Input to this function is a string containing multiple groups of\
    \ nested parentheses. Your goal is to\n/// separate those group into separate\
    \ strings and return the array of those.\n/// Separate groups are balanced (each\
    \ open brace is properly closed) and not nested within each other\n/// Ignore\
    \ any spaces in the input string.\n/// >>> separate_paren_groups(paren_string:\
    \ \"( ) (( )) (( )( ))\")\n/// [\"()\", \"(())\", \"(()())\"]\nfunc separate_paren_groups(paren_string:\
    \ String) -> [String] {\n    return []\n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(separate_paren_groups(paren_string: \"(()()) ((())) () ((())()())\") ==\
    \ [\"(()())\", \"((()))\", \"()\", \"((())()())\"])\nassert(separate_paren_groups(paren_string:\
    \ \"() (()) ((())) (((())))\") == [\"()\", \"(())\", \"((()))\", \"(((())))\"\
    ])\nassert(separate_paren_groups(paren_string: \"(()(())((())))\") == [\"(()(())((())))\"\
    ])\nassert(separate_paren_groups(paren_string: \"( ) (( )) (( )( ))\") == [\"\
    ()\", \"(())\", \"(()())\"])"
  status: Exception
  stderr: 'tmp1zdkbtz2/tmp1zdkbtz2.swift:25: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002aeebe8b5c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002aeebe5acb6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002aeebe5ac988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002aeebe5ab7b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmp1zdkbtz2                        0x0000556857c08537 <unavailable> + 5431

    5    libc.so.6                          0x00002aeebeaa1460 __libc_start_main +
    245

    6    tmp1zdkbtz2                        0x0000556857c080c9 <unavailable> + 4297

    '
  stdout: ''
  timestamp: 1659980040
- exit_code: -4
  program: "\n/// Input to this function is a string containing multiple groups of\
    \ nested parentheses. Your goal is to\n/// separate those group into separate\
    \ strings and return the array of those.\n/// Separate groups are balanced (each\
    \ open brace is properly closed) and not nested within each other\n/// Ignore\
    \ any spaces in the input string.\n/// >>> separate_paren_groups(paren_string:\
    \ \"( ) (( )) (( )( ))\")\n/// [\"()\", \"(())\", \"(()())\"]\nfunc separate_paren_groups(paren_string:\
    \ String) -> [String] {\n    var rtn = [String]()\n    var openedParenCount =\
    \ 0\n    var temp = \"\"\n    for char in paren_string {\n        if char == \"\
    (\" {\n            openedParenCount += 1\n        } else if char == \")\" {\n\
    \            openedParenCount -= 1\n        }\n        temp.append(char)\n   \
    \     if openedParenCount == 0 {\n            rtn.append(temp)\n            temp\
    \ = \"\"\n        }\n    }\n    return rtn\n}\n\n\nfunc ==(left: [(Int, Int)],\
    \ right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n       \
    \ return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r\
    \ {\n            return false\n        }\n    }\n    return true\n}\n        \
    \    \nassert(separate_paren_groups(paren_string: \"(()()) ((())) () ((())()())\"\
    ) == [\"(()())\", \"((()))\", \"()\", \"((())()())\"])\nassert(separate_paren_groups(paren_string:\
    \ \"() (()) ((())) (((())))\") == [\"()\", \"(())\", \"((()))\", \"(((())))\"\
    ])\nassert(separate_paren_groups(paren_string: \"(()(())((())))\") == [\"(()(())((())))\"\
    ])\nassert(separate_paren_groups(paren_string: \"( ) (( )) (( )( ))\") == [\"\
    ()\", \"(())\", \"(()())\"])"
  status: Exception
  stderr: 'tmp9r5c8dsw/tmp9r5c8dsw.swift:40: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b2c258e6c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b2c255ddb6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b2c255dd988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b2c255dc7b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmp9r5c8dsw                        0x000055e5539a17e7 <unavailable> + 6119

    5    libc.so.6                          0x00002b2c25ad2460 __libc_start_main +
    245

    6    tmp9r5c8dsw                        0x000055e5539a1379 <unavailable> + 4985

    '
  stdout: ''
  timestamp: 1659980040
- exit_code: 1
  program: "\n/// Input to this function is a string containing multiple groups of\
    \ nested parentheses. Your goal is to\n/// separate those group into separate\
    \ strings and return the array of those.\n/// Separate groups are balanced (each\
    \ open brace is properly closed) and not nested within each other\n/// Ignore\
    \ any spaces in the input string.\n/// >>> separate_paren_groups(paren_string:\
    \ \"( ) (( )) (( )( ))\")\n/// [\"()\", \"(())\", \"(()())\"]\nfunc separate_paren_groups(paren_string:\
    \ String) -> [String] {\n    var paren_string = paren_string\n    paren_string\
    \ = paren_string.replacingOccurrences(of: \" \", with: \"\")\n    var groups:\
    \ [String] = []\n    var open: Int = 0\n    var closed: Int = 0\n    var group:\
    \ String = \"\"\n    for char in paren_string {\n        if String(char) == \"\
    (\" {\n            open += 1\n        } else if String(char) == \")\" {\n    \
    \        closed += 1\n        }\n        group += String(char)\n        if open\
    \ == closed {\n            groups.append(group)\n            group = \"\"\n  \
    \          open = 0\n            closed = 0\n        }\n    }\n    return groups\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(separate_paren_groups(paren_string: \"(()()) ((()))\
    \ () ((())()())\") == [\"(()())\", \"((()))\", \"()\", \"((())()())\"])\nassert(separate_paren_groups(paren_string:\
    \ \"() (()) ((())) (((())))\") == [\"()\", \"(())\", \"((()))\", \"(((())))\"\
    ])\nassert(separate_paren_groups(paren_string: \"(()(())((())))\") == [\"(()(())((())))\"\
    ])\nassert(separate_paren_groups(paren_string: \"( ) (( )) (( )( ))\") == [\"\
    ()\", \"(())\", \"(()())\"])"
  status: SyntaxError
  stderr: "/tmp/tmpmb7a0wb_.swift:10:33: error: value of type 'String' has no member\
    \ 'replacingOccurrences'\n    paren_string = paren_string.replacingOccurrences(of:\
    \ \" \", with: \"\")\n                   ~~~~~~~~~~~~ ^~~~~~~~~~~~~~~~~~~~\n"
  stdout: ''
  timestamp: 1659980040
- exit_code: -4
  program: "\n/// Input to this function is a string containing multiple groups of\
    \ nested parentheses. Your goal is to\n/// separate those group into separate\
    \ strings and return the array of those.\n/// Separate groups are balanced (each\
    \ open brace is properly closed) and not nested within each other\n/// Ignore\
    \ any spaces in the input string.\n/// >>> separate_paren_groups(paren_string:\
    \ \"( ) (( )) (( )( ))\")\n/// [\"()\", \"(())\", \"(()())\"]\nfunc separate_paren_groups(paren_string:\
    \ String) -> [String] {\n    return []\n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(separate_paren_groups(paren_string: \"(()()) ((())) () ((())()())\") ==\
    \ [\"(()())\", \"((()))\", \"()\", \"((())()())\"])\nassert(separate_paren_groups(paren_string:\
    \ \"() (()) ((())) (((())))\") == [\"()\", \"(())\", \"((()))\", \"(((())))\"\
    ])\nassert(separate_paren_groups(paren_string: \"(()(())((())))\") == [\"(()(())((())))\"\
    ])\nassert(separate_paren_groups(paren_string: \"( ) (( )) (( )( ))\") == [\"\
    ()\", \"(())\", \"(()())\"])"
  status: Exception
  stderr: 'tmp1zdkbtz2/tmp1zdkbtz2.swift:25: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002aeebe8b5c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002aeebe5acb6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002aeebe5ac988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002aeebe5ab7b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmp1zdkbtz2                        0x0000556857c08537 <unavailable> + 5431

    5    libc.so.6                          0x00002aeebeaa1460 __libc_start_main +
    245

    6    tmp1zdkbtz2                        0x0000556857c080c9 <unavailable> + 4297

    '
  stdout: ''
  timestamp: 1659980040
- exit_code: -4
  program: "\n/// Input to this function is a string containing multiple groups of\
    \ nested parentheses. Your goal is to\n/// separate those group into separate\
    \ strings and return the array of those.\n/// Separate groups are balanced (each\
    \ open brace is properly closed) and not nested within each other\n/// Ignore\
    \ any spaces in the input string.\n/// >>> separate_paren_groups(paren_string:\
    \ \"( ) (( )) (( )( ))\")\n/// [\"()\", \"(())\", \"(()())\"]\nfunc separate_paren_groups(paren_string:\
    \ String) -> [String] {\n    var stack : [Character] = []\n    var current_paren_group\
    \ : [Character] = []\n    var all_paren_groups : [[Character]] = []\n    \n  \
    \  for c in paren_string {\n        if c == \"(\" {\n            if current_paren_group.count\
    \ != 0 {\n                all_paren_groups.append(current_paren_group)\n     \
    \           current_paren_group = []\n            }\n            stack.append(c)\n\
    \        } else if c == \")\" {\n            stack.removeLast()\n            if\
    \ stack.count == 0 {\n                all_paren_groups.append(current_paren_group)\n\
    \                current_paren_group = []\n            }\n        } else {\n \
    \           current_paren_group.append(c)\n        }\n    }\n    \n    return\
    \ all_paren_groups.map { String($0) }\n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(separate_paren_groups(paren_string: \"(()()) ((())) () ((())()())\") ==\
    \ [\"(()())\", \"((()))\", \"()\", \"((())()())\"])\nassert(separate_paren_groups(paren_string:\
    \ \"() (()) ((())) (((())))\") == [\"()\", \"(())\", \"((()))\", \"(((())))\"\
    ])\nassert(separate_paren_groups(paren_string: \"(()(())((())))\") == [\"(()(())((())))\"\
    ])\nassert(separate_paren_groups(paren_string: \"( ) (( )) (( )( ))\") == [\"\
    ()\", \"(())\", \"(()())\"])"
  status: Exception
  stderr: 'tmpt2g9o477/tmpt2g9o477.swift:47: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b0eb3500c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b0eb31f7b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b0eb31f7988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b0eb31f67b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpt2g9o477                        0x0000562fbcfaba07 <unavailable> + 6663

    5    libc.so.6                          0x00002b0eb36ec460 __libc_start_main +
    245

    6    tmpt2g9o477                        0x0000562fbcfab599 <unavailable> + 5529

    '
  stdout: ''
  timestamp: 1659980040
- exit_code: -4
  program: "\n/// Input to this function is a string containing multiple groups of\
    \ nested parentheses. Your goal is to\n/// separate those group into separate\
    \ strings and return the array of those.\n/// Separate groups are balanced (each\
    \ open brace is properly closed) and not nested within each other\n/// Ignore\
    \ any spaces in the input string.\n/// >>> separate_paren_groups(paren_string:\
    \ \"( ) (( )) (( )( ))\")\n/// [\"()\", \"(())\", \"(()())\"]\nfunc separate_paren_groups(paren_string:\
    \ String) -> [String] {\n    var new_arr: [String] = []\n    var cur_str = \"\"\
    \n    var balance = 0\n    for c in paren_string {\n        if c == \"(\" {\n\
    \            balance += 1\n        } else if c == \")\" {\n            balance\
    \ -= 1\n        }\n        if balance == 0 {\n            if cur_str != \"\" {\n\
    \                new_arr.append(cur_str)\n                cur_str = \"\"\n   \
    \         }\n        } else {\n            cur_str += String(c)\n        }\n \
    \   }\n    return new_arr\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(separate_paren_groups(paren_string:\
    \ \"(()()) ((())) () ((())()())\") == [\"(()())\", \"((()))\", \"()\", \"((())()())\"\
    ])\nassert(separate_paren_groups(paren_string: \"() (()) ((())) (((())))\") ==\
    \ [\"()\", \"(())\", \"((()))\", \"(((())))\"])\nassert(separate_paren_groups(paren_string:\
    \ \"(()(())((())))\") == [\"(()(())((())))\"])\nassert(separate_paren_groups(paren_string:\
    \ \"( ) (( )) (( )( ))\") == [\"()\", \"(())\", \"(()())\"])"
  status: Exception
  stderr: 'tmpv0b_900v/tmpv0b_900v.swift:43: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b965b283c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b965af7ab6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b965af7a988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b965af797b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpv0b_900v                        0x0000560b24063837 <unavailable> + 6199

    5    libc.so.6                          0x00002b965b46f460 __libc_start_main +
    245

    6    tmpv0b_900v                        0x0000560b240633c9 <unavailable> + 5065

    '
  stdout: ''
  timestamp: 1659980040
- exit_code: -4
  program: "\n/// Input to this function is a string containing multiple groups of\
    \ nested parentheses. Your goal is to\n/// separate those group into separate\
    \ strings and return the array of those.\n/// Separate groups are balanced (each\
    \ open brace is properly closed) and not nested within each other\n/// Ignore\
    \ any spaces in the input string.\n/// >>> separate_paren_groups(paren_string:\
    \ \"( ) (( )) (( )( ))\")\n/// [\"()\", \"(())\", \"(()())\"]\nfunc separate_paren_groups(paren_string:\
    \ String) -> [String] {\n    var result = [String]()\n    var buffer = \"\"\n\
    \    var ignore = false\n    for (i, char) in paren_string.enumerated() {\n  \
    \      let idx = paren_string.index(paren_string.startIndex, offsetBy: i)\n  \
    \      if char == \" \" {\n            continue\n        }\n        else if char\
    \ == \"(\" {\n            ignore = true\n            buffer.append(char)\n   \
    \     }\n        else if char == \")\" {\n            if ignore {\n          \
    \      buffer.append(char)\n            }\n            else {\n              \
    \  buffer.append(char)\n                result.append(buffer)\n              \
    \  buffer = \"\"\n            }\n        }\n        if buffer.count == 2 {\n \
    \           ignore = false\n        }\n    }\n    return result\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(separate_paren_groups(paren_string: \"(()()) ((())) ()\
    \ ((())()())\") == [\"(()())\", \"((()))\", \"()\", \"((())()())\"])\nassert(separate_paren_groups(paren_string:\
    \ \"() (()) ((())) (((())))\") == [\"()\", \"(())\", \"((()))\", \"(((())))\"\
    ])\nassert(separate_paren_groups(paren_string: \"(()(())((())))\") == [\"(()(())((())))\"\
    ])\nassert(separate_paren_groups(paren_string: \"( ) (( )) (( )( ))\") == [\"\
    ()\", \"(())\", \"(()())\"])"
  status: Exception
  stderr: 'tmpvo83bhlu/tmpvo83bhlu.swift:51: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002ab4db855c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002ab4db54cb6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002ab4db54c988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002ab4db54b7b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpvo83bhlu                        0x000055f3a3530a87 <unavailable> + 6791

    5    libc.so.6                          0x00002ab4dba41460 __libc_start_main +
    245

    6    tmpvo83bhlu                        0x000055f3a3530619 <unavailable> + 5657

    '
  stdout: ''
  timestamp: 1659980040
- exit_code: -4
  program: "\n/// Input to this function is a string containing multiple groups of\
    \ nested parentheses. Your goal is to\n/// separate those group into separate\
    \ strings and return the array of those.\n/// Separate groups are balanced (each\
    \ open brace is properly closed) and not nested within each other\n/// Ignore\
    \ any spaces in the input string.\n/// >>> separate_paren_groups(paren_string:\
    \ \"( ) (( )) (( )( ))\")\n/// [\"()\", \"(())\", \"(()())\"]\nfunc separate_paren_groups(paren_string:\
    \ String) -> [String] {\n    //TODO: Solve this!\n    return []\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(separate_paren_groups(paren_string: \"(()()) ((())) ()\
    \ ((())()())\") == [\"(()())\", \"((()))\", \"()\", \"((())()())\"])\nassert(separate_paren_groups(paren_string:\
    \ \"() (()) ((())) (((())))\") == [\"()\", \"(())\", \"((()))\", \"(((())))\"\
    ])\nassert(separate_paren_groups(paren_string: \"(()(())((())))\") == [\"(()(())((())))\"\
    ])\nassert(separate_paren_groups(paren_string: \"( ) (( )) (( )( ))\") == [\"\
    ()\", \"(())\", \"(()())\"])"
  status: Exception
  stderr: 'tmplky7zjx9/tmplky7zjx9.swift:26: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b79e8d76c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b79e8a6db6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b79e8a6d988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b79e8a6c7b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmplky7zjx9                        0x000055f9f1b81537 <unavailable> + 5431

    5    libc.so.6                          0x00002b79e8f62460 __libc_start_main +
    245

    6    tmplky7zjx9                        0x000055f9f1b810c9 <unavailable> + 4297

    '
  stdout: ''
  timestamp: 1659980040
- exit_code: -4
  program: "\n/// Input to this function is a string containing multiple groups of\
    \ nested parentheses. Your goal is to\n/// separate those group into separate\
    \ strings and return the array of those.\n/// Separate groups are balanced (each\
    \ open brace is properly closed) and not nested within each other\n/// Ignore\
    \ any spaces in the input string.\n/// >>> separate_paren_groups(paren_string:\
    \ \"( ) (( )) (( )( ))\")\n/// [\"()\", \"(())\", \"(()())\"]\nfunc separate_paren_groups(paren_string:\
    \ String) -> [String] {\n    var result: [String] = []\n    var stack: [Character]\
    \ = []\n    var temp: [Character] = []\n    for char in paren_string {\n     \
    \   if char == \"(\" {\n            stack.append(char)\n        } else if char\
    \ == \")\" {\n            temp.append(stack.popLast()!)\n            temp.append(char)\n\
    \            if stack.isEmpty {\n                result.append(String(temp))\n\
    \                temp = []\n            }\n        }\n    }\n    return result\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(separate_paren_groups(paren_string: \"(()()) ((()))\
    \ () ((())()())\") == [\"(()())\", \"((()))\", \"()\", \"((())()())\"])\nassert(separate_paren_groups(paren_string:\
    \ \"() (()) ((())) (((())))\") == [\"()\", \"(())\", \"((()))\", \"(((())))\"\
    ])\nassert(separate_paren_groups(paren_string: \"(()(())((())))\") == [\"(()(())((())))\"\
    ])\nassert(separate_paren_groups(paren_string: \"( ) (( )) (( )( ))\") == [\"\
    ()\", \"(())\", \"(()())\"])"
  status: Exception
  stderr: 'tmpp2qn1_ts/tmpp2qn1_ts.swift:40: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b9244eefc80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b9244be6b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b9244be6988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b9244be57b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpp2qn1_ts                        0x000055e2b4bfda37 <unavailable> + 6711

    5    libc.so.6                          0x00002b92450db460 __libc_start_main +
    245

    6    tmpp2qn1_ts                        0x000055e2b4bfd5c9 <unavailable> + 5577

    '
  stdout: ''
  timestamp: 1659980040
- exit_code: -4
  program: "\n/// Input to this function is a string containing multiple groups of\
    \ nested parentheses. Your goal is to\n/// separate those group into separate\
    \ strings and return the array of those.\n/// Separate groups are balanced (each\
    \ open brace is properly closed) and not nested within each other\n/// Ignore\
    \ any spaces in the input string.\n/// >>> separate_paren_groups(paren_string:\
    \ \"( ) (( )) (( )( ))\")\n/// [\"()\", \"(())\", \"(()())\"]\nfunc separate_paren_groups(paren_string:\
    \ String) -> [String] {\n    return []\n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(separate_paren_groups(paren_string: \"(()()) ((())) () ((())()())\") ==\
    \ [\"(()())\", \"((()))\", \"()\", \"((())()())\"])\nassert(separate_paren_groups(paren_string:\
    \ \"() (()) ((())) (((())))\") == [\"()\", \"(())\", \"((()))\", \"(((())))\"\
    ])\nassert(separate_paren_groups(paren_string: \"(()(())((())))\") == [\"(()(())((())))\"\
    ])\nassert(separate_paren_groups(paren_string: \"( ) (( )) (( )( ))\") == [\"\
    ()\", \"(())\", \"(()())\"])"
  status: Exception
  stderr: 'tmp1zdkbtz2/tmp1zdkbtz2.swift:25: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002aeebe8b5c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002aeebe5acb6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002aeebe5ac988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002aeebe5ab7b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmp1zdkbtz2                        0x0000556857c08537 <unavailable> + 5431

    5    libc.so.6                          0x00002aeebeaa1460 __libc_start_main +
    245

    6    tmp1zdkbtz2                        0x0000556857c080c9 <unavailable> + 4297

    '
  stdout: ''
  timestamp: 1659980040
- exit_code: 1
  program: "\n/// Input to this function is a string containing multiple groups of\
    \ nested parentheses. Your goal is to\n/// separate those group into separate\
    \ strings and return the array of those.\n/// Separate groups are balanced (each\
    \ open brace is properly closed) and not nested within each other\n/// Ignore\
    \ any spaces in the input string.\n/// >>> separate_paren_groups(paren_string:\
    \ \"( ) (( )) (( )( ))\")\n/// [\"()\", \"(())\", \"(()())\"]\nfunc separate_paren_groups(paren_string:\
    \ String) -> [String] {\n    var charStack = Stack<Character>()\n    var parenGroups\
    \ = [String]()\n    var parenGroup = \"\"\n    \n    paren_string.forEach { char\
    \ in\n        switch char {\n        case \"(\":\n            charStack.push(char)\n\
    \        case \")\":\n            if let group = charStack.pop() {\n         \
    \       parenGroup.append(group)\n                parenGroup.append(char)\n  \
    \              parenGroups.append(parenGroup)\n                parenGroup = \"\
    \"\n            }\n        default:\n            continue\n        }\n    }\n\
    \    \n    return parenGroups\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int,\
    \ Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n\
    \    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n          \
    \  return false\n        }\n    }\n    return true\n}\n            \nassert(separate_paren_groups(paren_string:\
    \ \"(()()) ((())) () ((())()())\") == [\"(()())\", \"((()))\", \"()\", \"((())()())\"\
    ])\nassert(separate_paren_groups(paren_string: \"() (()) ((())) (((())))\") ==\
    \ [\"()\", \"(())\", \"((()))\", \"(((())))\"])\nassert(separate_paren_groups(paren_string:\
    \ \"(()(())((())))\") == [\"(()(())((())))\"])\nassert(separate_paren_groups(paren_string:\
    \ \"( ) (( )) (( )( ))\") == [\"()\", \"(())\", \"(()())\"])"
  status: SyntaxError
  stderr: "/tmp/tmpl58shnyz.swift:9:21: error: cannot find 'Stack' in scope\n    var\
    \ charStack = Stack<Character>()\n                    ^~~~~\n"
  stdout: ''
  timestamp: 1659980040
- exit_code: -4
  program: "\n/// Input to this function is a string containing multiple groups of\
    \ nested parentheses. Your goal is to\n/// separate those group into separate\
    \ strings and return the array of those.\n/// Separate groups are balanced (each\
    \ open brace is properly closed) and not nested within each other\n/// Ignore\
    \ any spaces in the input string.\n/// >>> separate_paren_groups(paren_string:\
    \ \"( ) (( )) (( )( ))\")\n/// [\"()\", \"(())\", \"(()())\"]\nfunc separate_paren_groups(paren_string:\
    \ String) -> [String] {\n    \n    var stack = [Character]()\n    var results\
    \ = [String]()\n    var first = true\n    var temp = \"\"\n    \n    for letter\
    \ in paren_string {\n        if first && letter == \"(\" {\n            first\
    \ = false\n        }\n        if letter == \"(\" {\n            stack.append(letter)\n\
    \        }\n        if letter == \")\" {\n            stack.removeLast()\n   \
    \     }\n        if first && letter != \" \" {\n            temp.append(letter)\n\
    \        }\n        if stack.isEmpty && letter != \" \" {\n            results.append(temp)\n\
    \            temp = \"\"\n            first = true\n        }\n    }\n    return\
    \ results\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n\
    \    if left.count != right.count {\n        return false\n    }\n    for (l,\
    \ r) in zip(left, right) {\n        if l != r {\n            return false\n  \
    \      }\n    }\n    return true\n}\n            \nassert(separate_paren_groups(paren_string:\
    \ \"(()()) ((())) () ((())()())\") == [\"(()())\", \"((()))\", \"()\", \"((())()())\"\
    ])\nassert(separate_paren_groups(paren_string: \"() (()) ((())) (((())))\") ==\
    \ [\"()\", \"(())\", \"((()))\", \"(((())))\"])\nassert(separate_paren_groups(paren_string:\
    \ \"(()(())((())))\") == [\"(()(())((())))\"])\nassert(separate_paren_groups(paren_string:\
    \ \"( ) (( )) (( )( ))\") == [\"()\", \"(())\", \"(()())\"])"
  status: Exception
  stderr: 'tmp_qhinphe/tmp_qhinphe.swift:50: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b40752ffc80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b4074ff6b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b4074ff6988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b4074ff57b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmp_qhinphe                        0x0000561b570a0a07 <unavailable> + 6663

    5    libc.so.6                          0x00002b40754eb460 __libc_start_main +
    245

    6    tmp_qhinphe                        0x0000561b570a0599 <unavailable> + 5529

    '
  stdout: ''
  timestamp: 1659980040
- exit_code: 1
  program: "\n/// Input to this function is a string containing multiple groups of\
    \ nested parentheses. Your goal is to\n/// separate those group into separate\
    \ strings and return the array of those.\n/// Separate groups are balanced (each\
    \ open brace is properly closed) and not nested within each other\n/// Ignore\
    \ any spaces in the input string.\n/// >>> separate_paren_groups(paren_string:\
    \ \"( ) (( )) (( )( ))\")\n/// [\"()\", \"(())\", \"(()())\"]\nfunc separate_paren_groups(paren_string:\
    \ String) -> [String] {\n    /// - Parameter str: the string to process\n    ///\
    \ - Returns: array of balanced string\n    func separate(str: String) -> [String]\
    \ {\n        var result = [String]()\n        let chars = Array(str)\n       \
    \ var current = String()\n        var count = 0\n        for char in chars {\n\
    \            if char == \"(\" {\n                current.append(char)\n      \
    \          count += 1\n            } else if char == \")\" {\n               \
    \ current.append(char)\n                count -= 1\n                if count ==\
    \ 0 {\n                    result.append(current)\n                    current\
    \ = String()\n                }\n            }\n        }\n        return result\n\
    \    }\n    \n    return separate(str: paren_string.replacingOccurrences(of: \"\
    \ \", with: \"\"))\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) ->\
    \ Bool {\n    if left.count != right.count {\n        return false\n    }\n  \
    \  for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(separate_paren_groups(paren_string:\
    \ \"(()()) ((())) () ((())()())\") == [\"(()())\", \"((()))\", \"()\", \"((())()())\"\
    ])\nassert(separate_paren_groups(paren_string: \"() (()) ((())) (((())))\") ==\
    \ [\"()\", \"(())\", \"((()))\", \"(((())))\"])\nassert(separate_paren_groups(paren_string:\
    \ \"(()(())((())))\") == [\"(()(())((())))\"])\nassert(separate_paren_groups(paren_string:\
    \ \"( ) (( )) (( )( ))\") == [\"()\", \"(())\", \"(()())\"])"
  status: SyntaxError
  stderr: "/tmp/tmp0y0bfjti.swift:32:39: error: value of type 'String' has no member\
    \ 'replacingOccurrences'\n    return separate(str: paren_string.replacingOccurrences(of:\
    \ \" \", with: \"\"))\n                         ~~~~~~~~~~~~ ^~~~~~~~~~~~~~~~~~~~\n"
  stdout: ''
  timestamp: 1659980040
- exit_code: 1
  program: "\n/// Input to this function is a string containing multiple groups of\
    \ nested parentheses. Your goal is to\n/// separate those group into separate\
    \ strings and return the array of those.\n/// Separate groups are balanced (each\
    \ open brace is properly closed) and not nested within each other\n/// Ignore\
    \ any spaces in the input string.\n/// >>> separate_paren_groups(paren_string:\
    \ \"( ) (( )) (( )( ))\")\n/// [\"()\", \"(())\", \"(()())\"]\nfunc separate_paren_groups(paren_string:\
    \ String) -> [String] {\n    ////print(\"separate_paren_groups: paren_string:\
    \ \\(paren_string)\")\n    var result : [String] = []\n    var current_string\
    \ = \"\"\n    var open_paren_count = 0\n    var close_paren_count = 0\n    var\
    \ paren_string_array = paren_string.components(separatedBy: \" \")\n    for paren\
    \ in paren_string_array {\n        if (paren == \"(\") {\n            open_paren_count\
    \ += 1\n            current_string += paren\n        } else if (paren == \")\"\
    ) {\n            close_paren_count += 1\n            current_string += paren\n\
    \        }\n        if (open_paren_count == close_paren_count) {\n           \
    \ if (open_paren_count > 0) {\n                ////print(\"separate_paren_groups:\
    \ current_string: \\(current_string)\")\n                result.append(current_string)\n\
    \                current_string = \"\"\n                open_paren_count = 0\n\
    \                close_paren_count = 0\n            }\n        }\n    }\n    return\
    \ result\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n\
    \    if left.count != right.count {\n        return false\n    }\n    for (l,\
    \ r) in zip(left, right) {\n        if l != r {\n            return false\n  \
    \      }\n    }\n    return true\n}\n            \nassert(separate_paren_groups(paren_string:\
    \ \"(()()) ((())) () ((())()())\") == [\"(()())\", \"((()))\", \"()\", \"((())()())\"\
    ])\nassert(separate_paren_groups(paren_string: \"() (()) ((())) (((())))\") ==\
    \ [\"()\", \"(())\", \"((()))\", \"(((())))\"])\nassert(separate_paren_groups(paren_string:\
    \ \"(()(())((())))\") == [\"(()(())((())))\"])\nassert(separate_paren_groups(paren_string:\
    \ \"( ) (( )) (( )( ))\") == [\"()\", \"(())\", \"(()())\"])"
  status: SyntaxError
  stderr: "/tmp/tmpciujad26.swift:14:43: error: value of type 'String' has no member\
    \ 'components'\n    var paren_string_array = paren_string.components(separatedBy:\
    \ \" \")\n                             ~~~~~~~~~~~~ ^~~~~~~~~~\n"
  stdout: ''
  timestamp: 1659980040
- exit_code: -4
  program: "\n/// Input to this function is a string containing multiple groups of\
    \ nested parentheses. Your goal is to\n/// separate those group into separate\
    \ strings and return the array of those.\n/// Separate groups are balanced (each\
    \ open brace is properly closed) and not nested within each other\n/// Ignore\
    \ any spaces in the input string.\n/// >>> separate_paren_groups(paren_string:\
    \ \"( ) (( )) (( )( ))\")\n/// [\"()\", \"(())\", \"(()())\"]\nfunc separate_paren_groups(paren_string:\
    \ String) -> [String] {\n    \n    var strings = [String]()\n    var currentString\
    \ = \"\"\n    var brackets = [Character]()\n    \n    for index in 0..<paren_string.count\
    \ {\n        let letter = paren_string[paren_string.index(paren_string.startIndex,\
    \ offsetBy: index)]\n        if letter == \"(\" {\n            brackets.append(letter)\n\
    \            currentString.append(letter)\n        } else if letter == \")\" {\n\
    \            if brackets.isEmpty {\n                continue\n            }\n\
    \            if brackets.last == \"(\" {\n                brackets.removeLast()\n\
    \                currentString.append(letter)\n            }\n        }\n    \
    \    if brackets.isEmpty {\n            strings.append(currentString)\n      \
    \      currentString = \"\"\n        }\n    }\n    return strings\n}\n\n\nfunc\
    \ ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count !=\
    \ right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(separate_paren_groups(paren_string: \"(()()) ((()))\
    \ () ((())()())\") == [\"(()())\", \"((()))\", \"()\", \"((())()())\"])\nassert(separate_paren_groups(paren_string:\
    \ \"() (()) ((())) (((())))\") == [\"()\", \"(())\", \"((()))\", \"(((())))\"\
    ])\nassert(separate_paren_groups(paren_string: \"(()(())((())))\") == [\"(()(())((())))\"\
    ])\nassert(separate_paren_groups(paren_string: \"( ) (( )) (( )( ))\") == [\"\
    ()\", \"(())\", \"(()())\"])"
  status: Exception
  stderr: 'tmp0mhxus6z/tmp0mhxus6z.swift:49: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b09c03b8c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b09c00afb6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b09c00af988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b09c00ae7b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmp0mhxus6z                        0x000055b67117eca7 <unavailable> + 7335

    5    libc.so.6                          0x00002b09c05a4460 __libc_start_main +
    245

    6    tmp0mhxus6z                        0x000055b67117e839 <unavailable> + 6201

    '
  stdout: ''
  timestamp: 1659980040
- exit_code: -4
  program: "\n/// Input to this function is a string containing multiple groups of\
    \ nested parentheses. Your goal is to\n/// separate those group into separate\
    \ strings and return the array of those.\n/// Separate groups are balanced (each\
    \ open brace is properly closed) and not nested within each other\n/// Ignore\
    \ any spaces in the input string.\n/// >>> separate_paren_groups(paren_string:\
    \ \"( ) (( )) (( )( ))\")\n/// [\"()\", \"(())\", \"(()())\"]\nfunc separate_paren_groups(paren_string:\
    \ String) -> [String] {\n    \n    var parenStrings: [String] = []\n    var currentParenString\
    \ = \"\"\n    var leftParenCount = 0\n    var rightParenCount = 0\n    \n    for\
    \ char in paren_string {\n        if char == \"(\" {\n            leftParenCount\
    \ += 1\n        } else if char == \")\" {\n            rightParenCount += 1\n\
    \        }\n        \n        currentParenString.append(char)\n        \n    \
    \    if leftParenCount == rightParenCount {\n            if currentParenString\
    \ != \" \" {\n                parenStrings.append(currentParenString)\n      \
    \      }\n            currentParenString = \"\"\n            leftParenCount =\
    \ 0\n            rightParenCount = 0\n        }\n    }\n    \n    return parenStrings\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(separate_paren_groups(paren_string: \"(()()) ((()))\
    \ () ((())()())\") == [\"(()())\", \"((()))\", \"()\", \"((())()())\"])\nassert(separate_paren_groups(paren_string:\
    \ \"() (()) ((())) (((())))\") == [\"()\", \"(())\", \"((()))\", \"(((())))\"\
    ])\nassert(separate_paren_groups(paren_string: \"(()(())((())))\") == [\"(()(())((())))\"\
    ])\nassert(separate_paren_groups(paren_string: \"( ) (( )) (( )( ))\") == [\"\
    ()\", \"(())\", \"(()())\"])"
  status: Exception
  stderr: 'tmprbkvk217/tmprbkvk217.swift:53: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002acba05cfc80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002acba02c6b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002acba02c6988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002acba02c57b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmprbkvk217                        0x000055a44969ac92 <unavailable> + 7314

    5    libc.so.6                          0x00002acba07bb460 __libc_start_main +
    245

    6    tmprbkvk217                        0x000055a44969a379 <unavailable> + 4985

    '
  stdout: ''
  timestamp: 1659980040
- exit_code: 1
  program: "\n/// Input to this function is a string containing multiple groups of\
    \ nested parentheses. Your goal is to\n/// separate those group into separate\
    \ strings and return the array of those.\n/// Separate groups are balanced (each\
    \ open brace is properly closed) and not nested within each other\n/// Ignore\
    \ any spaces in the input string.\n/// >>> separate_paren_groups(paren_string:\
    \ \"( ) (( )) (( )( ))\")\n/// [\"()\", \"(())\", \"(()())\"]\nfunc separate_paren_groups(paren_string:\
    \ String) -> [String] {\n    var stack = Stack<String>()\n    var result = [String]()\n\
    \    var currentItem = \"\"\n    var count = 0\n    var isPart = false\n    var\
    \ isStart = false\n    for ch in paren_string {\n        if ch == \"(\" {\n  \
    \          if !isStart {\n                isStart = true\n            }\n    \
    \        isPart = true\n            count += 1\n            currentItem.append(ch)\n\
    \        } else if ch == \")\" {\n            count -= 1\n            currentItem.append(ch)\n\
    \            if count == 0 {\n                isPart = false\n               \
    \ isStart = false\n                result.append(currentItem)\n              \
    \  currentItem = \"\"\n            }\n        } else if isPart {\n           \
    \ currentItem.append(ch)\n        }\n    }\n    return result\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(separate_paren_groups(paren_string: \"(()()) ((())) ()\
    \ ((())()())\") == [\"(()())\", \"((()))\", \"()\", \"((())()())\"])\nassert(separate_paren_groups(paren_string:\
    \ \"() (()) ((())) (((())))\") == [\"()\", \"(())\", \"((()))\", \"(((())))\"\
    ])\nassert(separate_paren_groups(paren_string: \"(()(())((())))\") == [\"(()(())((())))\"\
    ])\nassert(separate_paren_groups(paren_string: \"( ) (( )) (( )( ))\") == [\"\
    ()\", \"(())\", \"(()())\"])"
  status: SyntaxError
  stderr: "/tmp/tmpwzt_0fw5.swift:9:17: error: cannot find 'Stack' in scope\n    var\
    \ stack = Stack<String>()\n                ^~~~~\n"
  stdout: ''
  timestamp: 1659980040
- exit_code: 0
  program: "\n/// Input to this function is a string containing multiple groups of\
    \ nested parentheses. Your goal is to\n/// separate those group into separate\
    \ strings and return the array of those.\n/// Separate groups are balanced (each\
    \ open brace is properly closed) and not nested within each other\n/// Ignore\
    \ any spaces in the input string.\n/// >>> separate_paren_groups(paren_string:\
    \ \"( ) (( )) (( )( ))\")\n/// [\"()\", \"(())\", \"(()())\"]\nfunc separate_paren_groups(paren_string:\
    \ String) -> [String] {\n    var result = [String]()\n    var current_word = \"\
    \"\n    var balance = 0\n    for char in paren_string {\n        guard char !=\
    \ \" \" else { continue }\n        if char == \"(\" {\n            balance +=\
    \ 1\n        } else if char == \")\" {\n            balance -= 1\n        }\n\
    \        current_word.append(char)\n        if balance == 0 {\n            result.append(current_word)\n\
    \            current_word = \"\"\n        }\n    }\n    return result\n}\n\n\n\
    func ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(separate_paren_groups(paren_string: \"(()()) ((()))\
    \ () ((())()())\") == [\"(()())\", \"((()))\", \"()\", \"((())()())\"])\nassert(separate_paren_groups(paren_string:\
    \ \"() (()) ((())) (((())))\") == [\"()\", \"(())\", \"((()))\", \"(((())))\"\
    ])\nassert(separate_paren_groups(paren_string: \"(()(())((())))\") == [\"(()(())((())))\"\
    ])\nassert(separate_paren_groups(paren_string: \"( ) (( )) (( )( ))\") == [\"\
    ()\", \"(())\", \"(()())\"])"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659980040
- exit_code: 1
  program: "\n/// Input to this function is a string containing multiple groups of\
    \ nested parentheses. Your goal is to\n/// separate those group into separate\
    \ strings and return the array of those.\n/// Separate groups are balanced (each\
    \ open brace is properly closed) and not nested within each other\n/// Ignore\
    \ any spaces in the input string.\n/// >>> separate_paren_groups(paren_string:\
    \ \"( ) (( )) (( )( ))\")\n/// [\"()\", \"(())\", \"(()())\"]\nfunc separate_paren_groups(paren_string:\
    \ String) -> [String] {\n    var indices = [Int]()\n    var count = 0\n    var\
    \ result = [String]()\n    for char in paren_string {\n        if char == \"(\"\
    \ {\n            count += 1\n        } else if char == \")\" {\n            count\
    \ -= 1\n        }\n        if count == 0 {\n            indices.append(paren_string.index(after:\
    \ paren_string.startIndex))\n        }\n    }\n    indices.append(paren_string.endIndex)\n\
    \    for i in 1..<indices.count {\n        result.append(String(paren_string[indices[i-1]..<indices[i]]))\n\
    \    }\n    return result\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(separate_paren_groups(paren_string:\
    \ \"(()()) ((())) () ((())()())\") == [\"(()())\", \"((()))\", \"()\", \"((())()())\"\
    ])\nassert(separate_paren_groups(paren_string: \"() (()) ((())) (((())))\") ==\
    \ [\"()\", \"(())\", \"((()))\", \"(((())))\"])\nassert(separate_paren_groups(paren_string:\
    \ \"(()(())((())))\") == [\"(()(())((())))\"])\nassert(separate_paren_groups(paren_string:\
    \ \"( ) (( )) (( )( ))\") == [\"()\", \"(())\", \"(()())\"])"
  status: SyntaxError
  stderr: "/tmp/tmpeerblg1x.swift:19:21: error: no exact matches in call to instance\
    \ method 'append'\n            indices.append(paren_string.index(after: paren_string.startIndex))\n\
    \                    ^\nSwift.Array:6:37: note: candidate expects value of type\
    \ 'Int' for parameter #1 (got 'String.Index')\n    @inlinable public mutating\
    \ func append(_ newElement: __owned Element)\n                               \
    \     ^\nSwift.RangeReplaceableCollection:4:37: note: candidate expects value\
    \ of type 'Int' for parameter #1 (got 'String.Index')\n    @inlinable public mutating\
    \ func append(_ newElement: __owned Self.Element)\n                          \
    \          ^\n/tmp/tmpeerblg1x.swift:19:21: note: found candidate with type '(__owned\
    \ String.Index) -> ()'\n            indices.append(paren_string.index(after: paren_string.startIndex))\n\
    \                    ^\n/tmp/tmpeerblg1x.swift:22:13: error: no exact matches\
    \ in call to instance method 'append'\n    indices.append(paren_string.endIndex)\n\
    \            ^\nSwift.Array:6:37: note: candidate expects value of type 'Int'\
    \ for parameter #1 (got 'String.Index')\n    @inlinable public mutating func append(_\
    \ newElement: __owned Element)\n                                    ^\nSwift.RangeReplaceableCollection:4:37:\
    \ note: candidate expects value of type 'Int' for parameter #1 (got 'String.Index')\n\
    \    @inlinable public mutating func append(_ newElement: __owned Self.Element)\n\
    \                                    ^\n/tmp/tmpeerblg1x.swift:22:13: note: found\
    \ candidate with type '(__owned String.Index) -> ()'\n    indices.append(paren_string.endIndex)\n\
    \            ^\n/tmp/tmpeerblg1x.swift:24:30: error: 'subscript(_:)' is unavailable:\
    \ cannot subscript String with an integer range, use a String.Index range instead.\n\
    \        result.append(String(paren_string[indices[i-1]..<indices[i]]))\n    \
    \                         ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\nSwift.String:5:12:\
    \ note: 'subscript(_:)' has been explicitly marked unavailable here\n    public\
    \ subscript<R>(bounds: R) -> String where R : RangeExpression, R.Bound == Int\
    \ { get "
  stdout: ''
  timestamp: 1659980040
- exit_code: 1
  program: "\n/// Input to this function is a string containing multiple groups of\
    \ nested parentheses. Your goal is to\n/// separate those group into separate\
    \ strings and return the array of those.\n/// Separate groups are balanced (each\
    \ open brace is properly closed) and not nested within each other\n/// Ignore\
    \ any spaces in the input string.\n/// >>> separate_paren_groups(paren_string:\
    \ \"( ) (( )) (( )( ))\")\n/// [\"()\", \"(())\", \"(()())\"]\nfunc separate_paren_groups(paren_string:\
    \ String) -> [String] {\n    let parens = \"()\"\n    let brackets = \"[]\"\n\
    \    let braces = \"{}\"\n    let lefts = parens + brackets + braces\n    let\
    \ rights = parens.reverse + brackets.reverse + braces.reverse\n    var stack =\
    \ [Character]()\n    var groups = [String]()\n    var current = \"\"\n    for\
    \ c in paren_string {\n        if c == \" \" {\n            continue\n       \
    \ }\n        if lefts.contains(c) {\n            stack.append(c)\n           \
    \ current.append(c)\n        } else if rights.contains(c) {\n            if stack.last\
    \ == lefts[rights.startIndex.distanceTo(rights.startIndex.advancedBy(rights.characters.indexOf(c)!))]\
    \ {\n                stack.removeLast()\n                current.append(c)\n \
    \           }\n        }\n        if stack.isEmpty {\n            groups.append(current)\n\
    \            current = \"\"\n        }\n    }\n    return groups\n}\n\n\nfunc\
    \ ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count !=\
    \ right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(separate_paren_groups(paren_string: \"(()()) ((()))\
    \ () ((())()())\") == [\"(()())\", \"((()))\", \"()\", \"((())()())\"])\nassert(separate_paren_groups(paren_string:\
    \ \"() (()) ((())) (((())))\") == [\"()\", \"(())\", \"((()))\", \"(((())))\"\
    ])\nassert(separate_paren_groups(paren_string: \"(()(())((())))\") == [\"(()(())((())))\"\
    ])\nassert(separate_paren_groups(paren_string: \"( ) (( )) (( )( ))\") == [\"\
    ()\", \"(())\", \"(()())\"])"
  status: SyntaxError
  stderr: "/tmp/tmpoie7hkbe.swift:13:25: error: value of type 'String' has no member\
    \ 'reverse'\n    let rights = parens.reverse + brackets.reverse + braces.reverse\n\
    \                 ~~~~~~ ^~~~~~~\n/tmp/tmpoie7hkbe.swift:13:44: error: value of\
    \ type 'String' has no member 'reverse'\n    let rights = parens.reverse + brackets.reverse\
    \ + braces.reverse\n                                  ~~~~~~~~ ^~~~~~~\n/tmp/tmpoie7hkbe.swift:13:61:\
    \ error: value of type 'String' has no member 'reverse'\n    let rights = parens.reverse\
    \ + brackets.reverse + braces.reverse\n                                      \
    \               ~~~~~~ ^~~~~~~\n"
  stdout: ''
  timestamp: 1659980040
- exit_code: -4
  program: "\n/// Input to this function is a string containing multiple groups of\
    \ nested parentheses. Your goal is to\n/// separate those group into separate\
    \ strings and return the array of those.\n/// Separate groups are balanced (each\
    \ open brace is properly closed) and not nested within each other\n/// Ignore\
    \ any spaces in the input string.\n/// >>> separate_paren_groups(paren_string:\
    \ \"( ) (( )) (( )( ))\")\n/// [\"()\", \"(())\", \"(()())\"]\nfunc separate_paren_groups(paren_string:\
    \ String) -> [String] {\n    let expression = paren_string.filter { $0 != \" \"\
    \ }\n    var result = [String]()\n    var currentParens = [Character]()\n    var\
    \ currentResult = [Character]()\n    var seenOpening = false\n    var seenClosing\
    \ = false\n    var previousChar = Character(\"\")\n    var previousSeenOpening\
    \ = false\n    var previousSeenClosing = false\n    for char in expression {\n\
    \        switch char {\n        case \"(\":\n            if !seenOpening {\n \
    \               seenOpening = true\n                previousSeenOpening = true\n\
    \            }\n            if seenClosing && previousSeenOpening {\n        \
    \        seenClosing = false\n                previousSeenOpening = false\n  \
    \              result.append(String(currentResult))\n                currentResult\
    \ = [Character]()\n            }\n            currentParens.append(char)\n   \
    \         currentResult.append(char)\n        case \")\":\n            if !seenClosing\
    \ {\n                seenClosing = true\n                previousSeenClosing =\
    \ true\n            }\n            if seenOpening && previousSeenClosing {\n \
    \               seenOpening = false\n                previousSeenClosing = false\n\
    \                result.append(String(currentResult))\n                currentResult\
    \ = [Character]()\n            }\n            if !currentParens.isEmpty {\n  \
    \              currentParens.removeLast()\n            }\n            currentResult.append(char)\n\
    \        default:\n            currentResult.append(char)\n        }\n       \
    \ previousChar = char\n    }\n    if !currentResult.isEmpty {\n        result.append(String(currentResult))\n\
    \    }\n    return result\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(separate_paren_groups(paren_string:\
    \ \"(()()) ((())) () ((())()())\") == [\"(()())\", \"((()))\", \"()\", \"((())()())\"\
    ])\nassert(separate_paren_groups(paren_string: \"() (()) ((())) (((())))\") ==\
    \ [\"()\", \"(())\", \"((()))\", \"(((())))\"])\nassert(separate_paren_groups(paren_string:\
    \ \"(()(())((())))\") == [\"(()(())((())))\"])\nassert(separate_paren_groups(paren_string:\
    \ \"( ) (( )) (( )( ))\") == [\"()\", \"(())\", \"(()())\"])"
  status: Exception
  stderr: 'Swift/Character.swift:175: Fatal error: Can''t form a Character from an
    empty String

    Current stack trace:

    0    libswiftCore.so                    0x00002b852296cc80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b8522663561 <unavailable> + 1434977

    2    libswiftCore.so                    0x00002b8522663286 <unavailable> + 1434246

    3    libswiftCore.so                    0x00002b852266313c <unavailable> + 1433916

    4    libswiftCore.so                    0x00002b8522662bb0 _assertionFailure(_:_:file:line:flags:)
    + 251

    5    libswiftCore.so                    0x00002b8522670090 Character.init(_:)
    + 211

    6    tmp7pv0fxxc                        0x00005598bc946102 <unavailable> + 8450

    7    tmp7pv0fxxc                        0x00005598bc945996 <unavailable> + 6550

    8    libc.so.6                          0x00002b8522b58460 __libc_start_main +
    245

    9    tmp7pv0fxxc                        0x00005598bc945699 <unavailable> + 5785

    '
  stdout: ''
  timestamp: 1659980040
- exit_code: 1
  program: "\n/// Input to this function is a string containing multiple groups of\
    \ nested parentheses. Your goal is to\n/// separate those group into separate\
    \ strings and return the array of those.\n/// Separate groups are balanced (each\
    \ open brace is properly closed) and not nested within each other\n/// Ignore\
    \ any spaces in the input string.\n/// >>> separate_paren_groups(paren_string:\
    \ \"( ) (( )) (( )( ))\")\n/// [\"()\", \"(())\", \"(()())\"]\nfunc separate_paren_groups(paren_string:\
    \ String) -> [String] {\n    var parens = Array(paren_string.replacingOccurrences(of:\
    \ \" \", with: \"\"))\n    var groups = [String]()\n    var counter = 0\n    var\
    \ start = 0\n    for i in 0..<parens.count {\n        if parens[i] == \"(\" {\n\
    \            counter += 1\n        } else if parens[i] == \")\" {\n          \
    \  counter -= 1\n        }\n        if counter == 0 {\n            groups.append(String(parens[start..<i+1]))\n\
    \            start = i+1\n        }\n    }\n    return groups\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(separate_paren_groups(paren_string: \"(()()) ((())) ()\
    \ ((())()())\") == [\"(()())\", \"((()))\", \"()\", \"((())()())\"])\nassert(separate_paren_groups(paren_string:\
    \ \"() (()) ((())) (((())))\") == [\"()\", \"(())\", \"((()))\", \"(((())))\"\
    ])\nassert(separate_paren_groups(paren_string: \"(()(())((())))\") == [\"(()(())((())))\"\
    ])\nassert(separate_paren_groups(paren_string: \"( ) (( )) (( )( ))\") == [\"\
    ()\", \"(())\", \"(()())\"])"
  status: SyntaxError
  stderr: "/tmp/tmp61np9xik.swift:9:37: error: value of type 'String' has no member\
    \ 'replacingOccurrences'\n    var parens = Array(paren_string.replacingOccurrences(of:\
    \ \" \", with: \"\"))\n                       ~~~~~~~~~~~~ ^~~~~~~~~~~~~~~~~~~~\n"
  stdout: ''
  timestamp: 1659980040
- exit_code: -4
  program: "\n/// Input to this function is a string containing multiple groups of\
    \ nested parentheses. Your goal is to\n/// separate those group into separate\
    \ strings and return the array of those.\n/// Separate groups are balanced (each\
    \ open brace is properly closed) and not nested within each other\n/// Ignore\
    \ any spaces in the input string.\n/// >>> separate_paren_groups(paren_string:\
    \ \"( ) (( )) (( )( ))\")\n/// [\"()\", \"(())\", \"(()())\"]\nfunc separate_paren_groups(paren_string:\
    \ String) -> [String] {\n    // return value\n    var result : [String] = []\n\
    \    \n    // we go through the string from beginning to end\n    // we do this\
    \ by using some kind of index\n    var index = paren_string.startIndex\n    \n\
    \    // we also keep track of what the index of the current parenthesis is\n \
    \   var currentParenIndex = 1\n    \n    // keep track of the current paren group\n\
    \    var paren_group = \"\"\n    \n    // go through the string\n    while index\
    \ != paren_string.endIndex {\n        // get the character at the current index\n\
    \        let current_char = paren_string[index]\n        \n        // increment\
    \ the index to get the next character\n        index = paren_string.index(after:\
    \ index)\n        \n        // if we've reached the end of the string,\n     \
    \   // then we'll stop here.\n        if index == paren_string.endIndex {\n  \
    \          break\n        }\n        \n        // check if the current character\
    \ is a ( or a )\n        if current_char == \"(\" {\n            // if it's a\
    \ ( then we should add it to our current paren group\n            paren_group.append(current_char)\n\
    \            \n            // and increment the current paren index\n        \
    \    currentParenIndex += 1\n        } else if current_char == \")\" {\n     \
    \       // if it's a ) then we need to see if our currentParenIndex is 1\n   \
    \         if currentParenIndex == 1 {\n                // if it is then we add\
    \ the paren group to our result\n                result.append(paren_group)\n\
    \                \n                // reset the paren group\n                paren_group\
    \ = \"\"\n            } else {\n                // otherwise it's part of a deeper\
    \ parenthesis\n                // so we add it to the current paren group\n  \
    \              paren_group.append(current_char)\n            }\n            \n\
    \            // decrement the current paren index\n            currentParenIndex\
    \ -= 1\n        }\n    }\n    \n    // if we still have a paren group, then add\
    \ it to the result\n    if paren_group != \"\" {\n        result.append(paren_group)\n\
    \    }\n    \n    return result\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int,\
    \ Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n\
    \    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n          \
    \  return false\n        }\n    }\n    return true\n}\n            \nassert(separate_paren_groups(paren_string:\
    \ \"(()()) ((())) () ((())()())\") == [\"(()())\", \"((()))\", \"()\", \"((())()())\"\
    ])\nassert(separate_paren_groups(paren_string: \"() (()) ((())) (((())))\") ==\
    \ [\"()\", \"(())\", \"((()))\", \"(((())))\"])\nassert(separate_paren_groups(paren_string:\
    \ \"(()(())((())))\") == [\"(()(())((())))\"])\nassert(separate_paren_groups(paren_string:\
    \ \"( ) (( )) (( )( ))\") == [\"()\", \"(())\", \"(()())\"])"
  status: Exception
  stderr: 'tmp1204f3dm/tmp1204f3dm.swift:83: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002ae7af3fcc80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002ae7af0f3b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002ae7af0f3988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002ae7af0f27b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmp1204f3dm                        0x000055a5cc7ee8f7 <unavailable> + 6391

    5    libc.so.6                          0x00002ae7af5e8460 __libc_start_main +
    245

    6    tmp1204f3dm                        0x000055a5cc7ee489 <unavailable> + 5257

    '
  stdout: ''
  timestamp: 1659980040
- exit_code: 0
  program: "\n/// Input to this function is a string containing multiple groups of\
    \ nested parentheses. Your goal is to\n/// separate those group into separate\
    \ strings and return the array of those.\n/// Separate groups are balanced (each\
    \ open brace is properly closed) and not nested within each other\n/// Ignore\
    \ any spaces in the input string.\n/// >>> separate_paren_groups(paren_string:\
    \ \"( ) (( )) (( )( ))\")\n/// [\"()\", \"(())\", \"(()())\"]\nfunc separate_paren_groups(paren_string:\
    \ String) -> [String] {\n    var result = [String]()\n    var tempString = \"\"\
    \n    var tempBracketCount = 0\n    let charCount = paren_string.count\n    for\
    \ index in 0..<charCount {\n        let ascii = paren_string[paren_string.index(paren_string.startIndex,\
    \ offsetBy: index)].asciiValue\n        if (ascii == 40 || ascii == 41) {\n  \
    \          tempString.append(paren_string[paren_string.index(paren_string.startIndex,\
    \ offsetBy: index)])\n            if (ascii == 40) {\n                tempBracketCount\
    \ += 1\n            } else {\n                tempBracketCount -= 1\n        \
    \    }\n            if (tempBracketCount == 0) {\n                result.append(tempString)\n\
    \                tempString = \"\"\n            }\n        }\n    }\n    return\
    \ result\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n\
    \    if left.count != right.count {\n        return false\n    }\n    for (l,\
    \ r) in zip(left, right) {\n        if l != r {\n            return false\n  \
    \      }\n    }\n    return true\n}\n            \nassert(separate_paren_groups(paren_string:\
    \ \"(()()) ((())) () ((())()())\") == [\"(()())\", \"((()))\", \"()\", \"((())()())\"\
    ])\nassert(separate_paren_groups(paren_string: \"() (()) ((())) (((())))\") ==\
    \ [\"()\", \"(())\", \"((()))\", \"(((())))\"])\nassert(separate_paren_groups(paren_string:\
    \ \"(()(())((())))\") == [\"(()(())((())))\"])\nassert(separate_paren_groups(paren_string:\
    \ \"( ) (( )) (( )( ))\") == [\"()\", \"(())\", \"(()())\"])"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659980041
- exit_code: -4
  program: "\n/// Input to this function is a string containing multiple groups of\
    \ nested parentheses. Your goal is to\n/// separate those group into separate\
    \ strings and return the array of those.\n/// Separate groups are balanced (each\
    \ open brace is properly closed) and not nested within each other\n/// Ignore\
    \ any spaces in the input string.\n/// >>> separate_paren_groups(paren_string:\
    \ \"( ) (( )) (( )( ))\")\n/// [\"()\", \"(())\", \"(()())\"]\nfunc separate_paren_groups(paren_string:\
    \ String) -> [String] {\n    var paren_string = paren_string\n    var result:\
    \ [String] = []\n    var start_index = paren_string.startIndex\n    while paren_string.count\
    \ > 0 {\n        let index = paren_string.firstIndex(of: \"(\")!\n        paren_string.remove(at:\
    \ index)\n        let end_index = paren_string.firstIndex(of: \")\")!\n      \
    \  let sub_str = paren_string[start_index...end_index]\n        result.append(String(sub_str))\n\
    \        paren_string.remove(at: end_index)\n    }\n    return result\n}\n\n\n\
    func ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(separate_paren_groups(paren_string: \"(()()) ((()))\
    \ () ((())()())\") == [\"(()())\", \"((()))\", \"()\", \"((())()())\"])\nassert(separate_paren_groups(paren_string:\
    \ \"() (()) ((())) (((())))\") == [\"()\", \"(())\", \"((()))\", \"(((())))\"\
    ])\nassert(separate_paren_groups(paren_string: \"(()(())((())))\") == [\"(()(())((())))\"\
    ])\nassert(separate_paren_groups(paren_string: \"( ) (( )) (( )( ))\") == [\"\
    ()\", \"(())\", \"(()())\"])"
  status: Exception
  stderr: 'tmp70ifckvg/tmp70ifckvg.swift:13: Fatal error: Unexpectedly found nil while
    unwrapping an Optional value

    Current stack trace:

    0    libswiftCore.so                    0x00002b03003eac80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b03000e1561 <unavailable> + 1434977

    2    libswiftCore.so                    0x00002b03000e1286 <unavailable> + 1434246

    3    libswiftCore.so                    0x00002b03000e113c <unavailable> + 1433916

    4    libswiftCore.so                    0x00002b03000e0bb0 _assertionFailure(_:_:file:line:flags:)
    + 251

    5    tmp70ifckvg                        0x0000563b4969814b <unavailable> + 8523

    6    tmp70ifckvg                        0x0000563b49697896 <unavailable> + 6294

    7    libc.so.6                          0x00002b03005d6460 __libc_start_main +
    245

    8    tmp70ifckvg                        0x0000563b49697599 <unavailable> + 5529

    '
  stdout: ''
  timestamp: 1659980041
- exit_code: -4
  program: "\n/// Input to this function is a string containing multiple groups of\
    \ nested parentheses. Your goal is to\n/// separate those group into separate\
    \ strings and return the array of those.\n/// Separate groups are balanced (each\
    \ open brace is properly closed) and not nested within each other\n/// Ignore\
    \ any spaces in the input string.\n/// >>> separate_paren_groups(paren_string:\
    \ \"( ) (( )) (( )( ))\")\n/// [\"()\", \"(())\", \"(()())\"]\nfunc separate_paren_groups(paren_string:\
    \ String) -> [String] {\n  var result: [String] = []\n  var current: String =\
    \ \"\"\n  var count: Int = 0\n  for char in paren_string {\n    if char == \"\
    (\" {\n      count += 1\n    } else if char == \")\" {\n      count -= 1\n   \
    \ }\n    if count == 0 {\n      if current != \"\" {\n        result.append(current)\n\
    \        current = \"\"\n      }\n    } else {\n      current.append(char)\n \
    \   }\n  }\n  return result\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int,\
    \ Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n\
    \    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n          \
    \  return false\n        }\n    }\n    return true\n}\n            \nassert(separate_paren_groups(paren_string:\
    \ \"(()()) ((())) () ((())()())\") == [\"(()())\", \"((()))\", \"()\", \"((())()())\"\
    ])\nassert(separate_paren_groups(paren_string: \"() (()) ((())) (((())))\") ==\
    \ [\"()\", \"(())\", \"((()))\", \"(((())))\"])\nassert(separate_paren_groups(paren_string:\
    \ \"(()(())((())))\") == [\"(()(())((())))\"])\nassert(separate_paren_groups(paren_string:\
    \ \"( ) (( )) (( )( ))\") == [\"()\", \"(())\", \"(()())\"])"
  status: Exception
  stderr: 'tmpqkoify4u/tmpqkoify4u.swift:43: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b2c77caec80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b2c779a5b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b2c779a5988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b2c779a47b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpqkoify4u                        0x0000555a6f5eb7e7 <unavailable> + 6119

    5    libc.so.6                          0x00002b2c77e9a460 __libc_start_main +
    245

    6    tmpqkoify4u                        0x0000555a6f5eb379 <unavailable> + 4985

    '
  stdout: ''
  timestamp: 1659980041
- exit_code: 0
  program: "\n/// Input to this function is a string containing multiple groups of\
    \ nested parentheses. Your goal is to\n/// separate those group into separate\
    \ strings and return the array of those.\n/// Separate groups are balanced (each\
    \ open brace is properly closed) and not nested within each other\n/// Ignore\
    \ any spaces in the input string.\n/// >>> separate_paren_groups(paren_string:\
    \ \"( ) (( )) (( )( ))\")\n/// [\"()\", \"(())\", \"(()())\"]\nfunc separate_paren_groups(paren_string:\
    \ String) -> [String] {\n    var result: [String] = []\n    var temp: String =\
    \ \"\"\n    var round: Int = 0\n    for char in paren_string {\n        if char\
    \ == \"(\" {\n            round += 1\n        } else if char == \")\" {\n    \
    \        round -= 1\n        }\n        if char != \" \" {\n            temp.append(char)\n\
    \        }\n        if round == 0 && char != \" \" {\n            result.append(temp)\n\
    \            temp = \"\"\n        }\n    }\n    return result\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(separate_paren_groups(paren_string: \"(()()) ((())) ()\
    \ ((())()())\") == [\"(()())\", \"((()))\", \"()\", \"((())()())\"])\nassert(separate_paren_groups(paren_string:\
    \ \"() (()) ((())) (((())))\") == [\"()\", \"(())\", \"((()))\", \"(((())))\"\
    ])\nassert(separate_paren_groups(paren_string: \"(()(())((())))\") == [\"(()(())((())))\"\
    ])\nassert(separate_paren_groups(paren_string: \"( ) (( )) (( )( ))\") == [\"\
    ()\", \"(())\", \"(()())\"])"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659980041
- exit_code: 1
  program: "\n/// Input to this function is a string containing multiple groups of\
    \ nested parentheses. Your goal is to\n/// separate those group into separate\
    \ strings and return the array of those.\n/// Separate groups are balanced (each\
    \ open brace is properly closed) and not nested within each other\n/// Ignore\
    \ any spaces in the input string.\n/// >>> separate_paren_groups(paren_string:\
    \ \"( ) (( )) (( )( ))\")\n/// [\"()\", \"(())\", \"(()())\"]\nfunc separate_paren_groups(paren_string:\
    \ String) -> [String] {\n    let paren_string = paren_string.replacingOccurrences(of:\
    \ \" \", with: \"\")\n    var stack: [Character] = []\n    var result: [String]\
    \ = []\n    var idx = 0\n    var balance = 0\n    var tmp = \"\"\n    for char\
    \ in paren_string {\n        if char == \"(\" {\n            balance += 1\n  \
    \          stack.append(char)\n        } else if char == \")\" {\n           \
    \ balance -= 1\n            stack.append(char)\n        }\n        if balance\
    \ == 0 {\n            result.append(String(stack))\n            stack.removeAll()\n\
    \        }\n    }\n    return result\n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(separate_paren_groups(paren_string: \"(()()) ((())) () ((())()())\") ==\
    \ [\"(()())\", \"((()))\", \"()\", \"((())()())\"])\nassert(separate_paren_groups(paren_string:\
    \ \"() (()) ((())) (((())))\") == [\"()\", \"(())\", \"((()))\", \"(((())))\"\
    ])\nassert(separate_paren_groups(paren_string: \"(()(())((())))\") == [\"(()(())((())))\"\
    ])\nassert(separate_paren_groups(paren_string: \"( ) (( )) (( )( ))\") == [\"\
    ()\", \"(())\", \"(()())\"])"
  status: SyntaxError
  stderr: "/tmp/tmp_lp83i2b.swift:9:37: error: value of type 'String' has no member\
    \ 'replacingOccurrences'\n    let paren_string = paren_string.replacingOccurrences(of:\
    \ \" \", with: \"\")\n                       ~~~~~~~~~~~~ ^~~~~~~~~~~~~~~~~~~~\n"
  stdout: ''
  timestamp: 1659980040
- exit_code: -4
  program: "\n/// Input to this function is a string containing multiple groups of\
    \ nested parentheses. Your goal is to\n/// separate those group into separate\
    \ strings and return the array of those.\n/// Separate groups are balanced (each\
    \ open brace is properly closed) and not nested within each other\n/// Ignore\
    \ any spaces in the input string.\n/// >>> separate_paren_groups(paren_string:\
    \ \"( ) (( )) (( )( ))\")\n/// [\"()\", \"(())\", \"(()())\"]\nfunc separate_paren_groups(paren_string:\
    \ String) -> [String] {\n    var paren_groups = [String]()\n    var current_paren_group\
    \ = String()\n    var open_count = 0\n    var index = 0\n    while index < paren_string.count\
    \ {\n        let current_char = paren_string[paren_string.index(paren_string.startIndex,\
    \ offsetBy: index)]\n        if current_char == \"(\" {\n            open_count\
    \ += 1\n            current_paren_group.append(current_char)\n        } else if\
    \ current_char == \")\" {\n            open_count -= 1\n            current_paren_group.append(current_char)\n\
    \        }\n        if open_count == 0 {\n            paren_groups.append(current_paren_group)\n\
    \            current_paren_group = String()\n        }\n        index += 1\n \
    \   }\n    return paren_groups\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int,\
    \ Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n\
    \    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n          \
    \  return false\n        }\n    }\n    return true\n}\n            \nassert(separate_paren_groups(paren_string:\
    \ \"(()()) ((())) () ((())()())\") == [\"(()())\", \"((()))\", \"()\", \"((())()())\"\
    ])\nassert(separate_paren_groups(paren_string: \"() (()) ((())) (((())))\") ==\
    \ [\"()\", \"(())\", \"((()))\", \"(((())))\"])\nassert(separate_paren_groups(paren_string:\
    \ \"(()(())((())))\") == [\"(()(())((())))\"])\nassert(separate_paren_groups(paren_string:\
    \ \"( ) (( )) (( )( ))\") == [\"()\", \"(())\", \"(()())\"])"
  status: Exception
  stderr: 'tmpth7szila/tmpth7szila.swift:44: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002ad840d9ac80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002ad840a91b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002ad840a91988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002ad840a907b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpth7szila                        0x000056133ea8c8d7 <unavailable> + 6359

    5    libc.so.6                          0x00002ad840f86460 __libc_start_main +
    245

    6    tmpth7szila                        0x000056133ea8c469 <unavailable> + 5225

    '
  stdout: ''
  timestamp: 1659980041
- exit_code: -4
  program: "\n/// Input to this function is a string containing multiple groups of\
    \ nested parentheses. Your goal is to\n/// separate those group into separate\
    \ strings and return the array of those.\n/// Separate groups are balanced (each\
    \ open brace is properly closed) and not nested within each other\n/// Ignore\
    \ any spaces in the input string.\n/// >>> separate_paren_groups(paren_string:\
    \ \"( ) (( )) (( )( ))\")\n/// [\"()\", \"(())\", \"(()())\"]\nfunc separate_paren_groups(paren_string:\
    \ String) -> [String] {\n    \n    return []\n}\n\n\nfunc ==(left: [(Int, Int)],\
    \ right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n       \
    \ return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r\
    \ {\n            return false\n        }\n    }\n    return true\n}\n        \
    \    \nassert(separate_paren_groups(paren_string: \"(()()) ((())) () ((())()())\"\
    ) == [\"(()())\", \"((()))\", \"()\", \"((())()())\"])\nassert(separate_paren_groups(paren_string:\
    \ \"() (()) ((())) (((())))\") == [\"()\", \"(())\", \"((()))\", \"(((())))\"\
    ])\nassert(separate_paren_groups(paren_string: \"(()(())((())))\") == [\"(()(())((())))\"\
    ])\nassert(separate_paren_groups(paren_string: \"( ) (( )) (( )( ))\") == [\"\
    ()\", \"(())\", \"(()())\"])"
  status: Exception
  stderr: 'tmpvzvzb8jh/tmpvzvzb8jh.swift:26: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002afa06152c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002afa05e49b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002afa05e49988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002afa05e487b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpvzvzb8jh                        0x000055a08098f537 <unavailable> + 5431

    5    libc.so.6                          0x00002afa0633e460 __libc_start_main +
    245

    6    tmpvzvzb8jh                        0x000055a08098f0c9 <unavailable> + 4297

    '
  stdout: ''
  timestamp: 1659980041
- exit_code: -4
  program: "\n/// Input to this function is a string containing multiple groups of\
    \ nested parentheses. Your goal is to\n/// separate those group into separate\
    \ strings and return the array of those.\n/// Separate groups are balanced (each\
    \ open brace is properly closed) and not nested within each other\n/// Ignore\
    \ any spaces in the input string.\n/// >>> separate_paren_groups(paren_string:\
    \ \"( ) (( )) (( )( ))\")\n/// [\"()\", \"(())\", \"(()())\"]\nfunc separate_paren_groups(paren_string:\
    \ String) -> [String] {\n    var result = [String]()\n    var start = 0\n    var\
    \ end = 0\n    var paren_count = 0\n    for i in 0..<paren_string.count {\n  \
    \      let idx = paren_string.index(paren_string.startIndex, offsetBy: i)\n  \
    \      let char = paren_string[idx]\n        if char == \"(\" {\n            paren_count\
    \ += 1\n            if paren_count == 1 {\n                start = i\n       \
    \     }\n        } else if char == \")\" {\n            paren_count -= 1\n   \
    \         if paren_count == 0 {\n                end = i\n                let\
    \ start_idx = paren_string.index(paren_string.startIndex, offsetBy: start)\n \
    \               let end_idx = paren_string.index(paren_string.startIndex, offsetBy:\
    \ end)\n                let str = String(paren_string[start_idx...end_idx])\n\
    \                result.append(str)\n            }\n        }\n    }\n    return\
    \ result\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n\
    \    if left.count != right.count {\n        return false\n    }\n    for (l,\
    \ r) in zip(left, right) {\n        if l != r {\n            return false\n  \
    \      }\n    }\n    return true\n}\n            \nassert(separate_paren_groups(paren_string:\
    \ \"(()()) ((())) () ((())()())\") == [\"(()())\", \"((()))\", \"()\", \"((())()())\"\
    ])\nassert(separate_paren_groups(paren_string: \"() (()) ((())) (((())))\") ==\
    \ [\"()\", \"(())\", \"((()))\", \"(((())))\"])\nassert(separate_paren_groups(paren_string:\
    \ \"(()(())((())))\") == [\"(()(())((())))\"])\nassert(separate_paren_groups(paren_string:\
    \ \"( ) (( )) (( )( ))\") == [\"()\", \"(())\", \"(()())\"])"
  status: Exception
  stderr: 'tmp7q_2z3hx/tmp7q_2z3hx.swift:51: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b3e4576fc80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b3e45466b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b3e45466988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b3e454657b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmp7q_2z3hx                        0x0000560f229c8002 <unavailable> + 8194

    5    libc.so.6                          0x00002b3e4595b460 __libc_start_main +
    245

    6    tmp7q_2z3hx                        0x0000560f229c76e9 <unavailable> + 5865

    '
  stdout: ''
  timestamp: 1659980041
- exit_code: 1
  program: "\n/// Input to this function is a string containing multiple groups of\
    \ nested parentheses. Your goal is to\n/// separate those group into separate\
    \ strings and return the array of those.\n/// Separate groups are balanced (each\
    \ open brace is properly closed) and not nested within each other\n/// Ignore\
    \ any spaces in the input string.\n/// >>> separate_paren_groups(paren_string:\
    \ \"( ) (( )) (( )( ))\")\n/// [\"()\", \"(())\", \"(()())\"]\nfunc separate_paren_groups(paren_string:\
    \ String) -> [String] {\n    var results: [String] = []\n    var workingString\
    \ = paren_string\n    var openParenIndex = workingString.findFirst('(')\n    while\
    \ let index = openParenIndex {\n        var count = 1\n        var closeParenIndex\
    \ = index + 1\n        for i in index..<workingString.count {\n            if\
    \ workingString[i] == \"(\" {\n                count += 1\n            } else\
    \ if workingString[i] == \")\" {\n                count -= 1\n            }\n\
    \            if count == 0 {\n                closeParenIndex = i\n          \
    \      break\n            }\n        }\n        results.append(workingString[index...closeParenIndex])\n\
    \        workingString = workingString[closeParenIndex+1..<workingString.count]\n\
    \        openParenIndex = workingString.findFirst('(')\n    }\n    return results\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(separate_paren_groups(paren_string: \"(()()) ((()))\
    \ () ((())()())\") == [\"(()())\", \"((()))\", \"()\", \"((())()())\"])\nassert(separate_paren_groups(paren_string:\
    \ \"() (()) ((())) (((())))\") == [\"()\", \"(())\", \"((()))\", \"(((())))\"\
    ])\nassert(separate_paren_groups(paren_string: \"(()(())((())))\") == [\"(()(())((())))\"\
    ])\nassert(separate_paren_groups(paren_string: \"( ) (( )) (( )( ))\") == [\"\
    ()\", \"(())\", \"(()())\"])"
  status: SyntaxError
  stderr: "/tmp/tmpu1gavc4w.swift:11:50: error: single-quoted string literal found,\
    \ use '\"'\n    var openParenIndex = workingString.findFirst('(')\n          \
    \                                       ^~~\n                                \
    \                 \"(\"\n/tmp/tmpu1gavc4w.swift:28:50: error: single-quoted string\
    \ literal found, use '\"'\n        openParenIndex = workingString.findFirst('(')\n\
    \                                                 ^~~\n                      \
    \                           \"(\"\n/tmp/tmpu1gavc4w.swift:11:40: error: value\
    \ of type 'String' has no member 'findFirst'\n    var openParenIndex = workingString.findFirst('(')\n\
    \                         ~~~~~~~~~~~~~ ^~~~~~~~~\n/tmp/tmpu1gavc4w.swift:28:40:\
    \ error: value of type 'String' has no member 'findFirst'\n        openParenIndex\
    \ = workingString.findFirst('(')\n                         ~~~~~~~~~~~~~ ^~~~~~~~~\n"
  stdout: ''
  timestamp: 1659980041
- exit_code: -4
  program: "\n/// Input to this function is a string containing multiple groups of\
    \ nested parentheses. Your goal is to\n/// separate those group into separate\
    \ strings and return the array of those.\n/// Separate groups are balanced (each\
    \ open brace is properly closed) and not nested within each other\n/// Ignore\
    \ any spaces in the input string.\n/// >>> separate_paren_groups(paren_string:\
    \ \"( ) (( )) (( )( ))\")\n/// [\"()\", \"(())\", \"(()())\"]\nfunc separate_paren_groups(paren_string:\
    \ String) -> [String] {\n    return [\"\"]\n}\n\n\nfunc ==(left: [(Int, Int)],\
    \ right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n       \
    \ return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r\
    \ {\n            return false\n        }\n    }\n    return true\n}\n        \
    \    \nassert(separate_paren_groups(paren_string: \"(()()) ((())) () ((())()())\"\
    ) == [\"(()())\", \"((()))\", \"()\", \"((())()())\"])\nassert(separate_paren_groups(paren_string:\
    \ \"() (()) ((())) (((())))\") == [\"()\", \"(())\", \"((()))\", \"(((())))\"\
    ])\nassert(separate_paren_groups(paren_string: \"(()(())((())))\") == [\"(()(())((())))\"\
    ])\nassert(separate_paren_groups(paren_string: \"( ) (( )) (( )( ))\") == [\"\
    ()\", \"(())\", \"(()())\"])"
  status: Exception
  stderr: 'tmpu1dkqwxi/tmpu1dkqwxi.swift:25: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b9f828acc80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b9f825a3b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b9f825a3988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b9f825a27b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpu1dkqwxi                        0x00005586b8fa2537 <unavailable> + 5431

    5    libc.so.6                          0x00002b9f82a98460 __libc_start_main +
    245

    6    tmpu1dkqwxi                        0x00005586b8fa20c9 <unavailable> + 4297

    '
  stdout: ''
  timestamp: 1659980041
- exit_code: 1
  program: "\n/// Input to this function is a string containing multiple groups of\
    \ nested parentheses. Your goal is to\n/// separate those group into separate\
    \ strings and return the array of those.\n/// Separate groups are balanced (each\
    \ open brace is properly closed) and not nested within each other\n/// Ignore\
    \ any spaces in the input string.\n/// >>> separate_paren_groups(paren_string:\
    \ \"( ) (( )) (( )( ))\")\n/// [\"()\", \"(())\", \"(()())\"]\nfunc separate_paren_groups(paren_string:\
    \ String) -> [String] {\n    var result_strings: [String] = []\n    var is_open\
    \ = false\n    var last_index = 0\n    for i in paren_string.indices {\n     \
    \   if paren_string[i] == \"(\" {\n            if !is_open {\n               \
    \ last_index = i\n            }\n            is_open = true\n        } else if\
    \ paren_string[i] == \")\" {\n            is_open = false\n            result_strings.append(String(paren_string[last_index..<i]))\n\
    \        }\n    }\n    return result_strings\n}\n\n\nfunc ==(left: [(Int, Int)],\
    \ right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n       \
    \ return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r\
    \ {\n            return false\n        }\n    }\n    return true\n}\n        \
    \    \nassert(separate_paren_groups(paren_string: \"(()()) ((())) () ((())()())\"\
    ) == [\"(()())\", \"((()))\", \"()\", \"((())()())\"])\nassert(separate_paren_groups(paren_string:\
    \ \"() (()) ((())) (((())))\") == [\"()\", \"(())\", \"((()))\", \"(((())))\"\
    ])\nassert(separate_paren_groups(paren_string: \"(()(())((())))\") == [\"(()(())((())))\"\
    ])\nassert(separate_paren_groups(paren_string: \"( ) (( )) (( )( ))\") == [\"\
    ()\", \"(())\", \"(()())\"])"
  status: SyntaxError
  stderr: "/tmp/tmp0yj9osy8.swift:15:30: error: cannot assign value of type 'DefaultIndices<String>.Element'\
    \ (aka 'String.Index') to type 'Int'\n                last_index = i\n       \
    \                      ^\n/tmp/tmp0yj9osy8.swift:20:55: error: cannot convert\
    \ value of type 'Int' to expected argument type 'String.Index'\n            result_strings.append(String(paren_string[last_index..<i]))\n\
    \                                                      ^\n"
  stdout: ''
  timestamp: 1659980041
- exit_code: -4
  program: "\n/// Input to this function is a string containing multiple groups of\
    \ nested parentheses. Your goal is to\n/// separate those group into separate\
    \ strings and return the array of those.\n/// Separate groups are balanced (each\
    \ open brace is properly closed) and not nested within each other\n/// Ignore\
    \ any spaces in the input string.\n/// >>> separate_paren_groups(paren_string:\
    \ \"( ) (( )) (( )( ))\")\n/// [\"()\", \"(())\", \"(()())\"]\nfunc separate_paren_groups(paren_string:\
    \ String) -> [String] {\n    var open_count = 0\n    var close_count = 0\n   \
    \ var group_count = 0\n    var group_strings = [String]()\n    var temp_string\
    \ = \"\"\n    for char in paren_string {\n        if char == \"(\" {\n       \
    \     open_count += 1\n            group_count += 1\n            temp_string +=\
    \ String(char)\n        } else if char == \")\" {\n            close_count +=\
    \ 1\n            group_count += 1\n            temp_string += String(char)\n \
    \       }\n        if group_count == open_count * 2 {\n            group_strings.append(temp_string)\n\
    \            temp_string = \"\"\n            group_count = 0\n        }\n    }\n\
    \    return group_strings\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(separate_paren_groups(paren_string:\
    \ \"(()()) ((())) () ((())()())\") == [\"(()())\", \"((()))\", \"()\", \"((())()())\"\
    ])\nassert(separate_paren_groups(paren_string: \"() (()) ((())) (((())))\") ==\
    \ [\"()\", \"(())\", \"((()))\", \"(((())))\"])\nassert(separate_paren_groups(paren_string:\
    \ \"(()(())((())))\") == [\"(()(())((())))\"])\nassert(separate_paren_groups(paren_string:\
    \ \"( ) (( )) (( )( ))\") == [\"()\", \"(())\", \"(()())\"])"
  status: Exception
  stderr: 'tmp82n9wxr4/tmp82n9wxr4.swift:46: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002ac27341bc80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002ac273112b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002ac273112988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002ac2731117b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmp82n9wxr4                        0x0000562d045df837 <unavailable> + 6199

    5    libc.so.6                          0x00002ac273607460 __libc_start_main +
    245

    6    tmp82n9wxr4                        0x0000562d045df3c9 <unavailable> + 5065

    '
  stdout: ''
  timestamp: 1659980041
- exit_code: 1
  program: "\n/// Input to this function is a string containing multiple groups of\
    \ nested parentheses. Your goal is to\n/// separate those group into separate\
    \ strings and return the array of those.\n/// Separate groups are balanced (each\
    \ open brace is properly closed) and not nested within each other\n/// Ignore\
    \ any spaces in the input string.\n/// >>> separate_paren_groups(paren_string:\
    \ \"( ) (( )) (( )( ))\")\n/// [\"()\", \"(())\", \"(()())\"]\nfunc separate_paren_groups(paren_string:\
    \ String) -> [String] {\n    let cleaned = paren_string.replacingOccurrences(of:\
    \ \" \", with: \"\")\n    var output = [String]()\n    var current = [Character]()\n\
    \    for item in cleaned {\n        if item == \"(\" {\n            current.append(item)\n\
    \        } else if item == \")\" {\n            current.append(item)\n       \
    \     output.append(String(current))\n            current = [Character]()\n  \
    \      }\n    }\n    return output\n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(separate_paren_groups(paren_string: \"(()()) ((())) () ((())()())\") ==\
    \ [\"(()())\", \"((()))\", \"()\", \"((())()())\"])\nassert(separate_paren_groups(paren_string:\
    \ \"() (()) ((())) (((())))\") == [\"()\", \"(())\", \"((()))\", \"(((())))\"\
    ])\nassert(separate_paren_groups(paren_string: \"(()(())((())))\") == [\"(()(())((())))\"\
    ])\nassert(separate_paren_groups(paren_string: \"( ) (( )) (( )( ))\") == [\"\
    ()\", \"(())\", \"(()())\"])"
  status: SyntaxError
  stderr: "/tmp/tmpwk8k5fql.swift:9:32: error: value of type 'String' has no member\
    \ 'replacingOccurrences'\n    let cleaned = paren_string.replacingOccurrences(of:\
    \ \" \", with: \"\")\n                  ~~~~~~~~~~~~ ^~~~~~~~~~~~~~~~~~~~\n"
  stdout: ''
  timestamp: 1659980041
- exit_code: 0
  program: "\n/// Input to this function is a string containing multiple groups of\
    \ nested parentheses. Your goal is to\n/// separate those group into separate\
    \ strings and return the array of those.\n/// Separate groups are balanced (each\
    \ open brace is properly closed) and not nested within each other\n/// Ignore\
    \ any spaces in the input string.\n/// >>> separate_paren_groups(paren_string:\
    \ \"( ) (( )) (( )( ))\")\n/// [\"()\", \"(())\", \"(()())\"]\nfunc separate_paren_groups(paren_string:\
    \ String) -> [String] {\n  var paren_groups = [String]()\n  var paren_group =\
    \ \"\"\n  var open_braces = 0\n  for char in paren_string {\n    if char == \"\
    (\" {\n      open_braces += 1\n      paren_group += String(char)\n    } else if\
    \ char == \")\" {\n      if open_braces > 0 {\n        open_braces -= 1\n    \
    \    paren_group += String(char)\n      }\n      if open_braces == 0 {\n     \
    \   paren_groups.append(paren_group)\n        paren_group = \"\"\n      }\n  \
    \  }\n  }\n  return paren_groups\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int,\
    \ Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n\
    \    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n          \
    \  return false\n        }\n    }\n    return true\n}\n            \nassert(separate_paren_groups(paren_string:\
    \ \"(()()) ((())) () ((())()())\") == [\"(()())\", \"((()))\", \"()\", \"((())()())\"\
    ])\nassert(separate_paren_groups(paren_string: \"() (()) ((())) (((())))\") ==\
    \ [\"()\", \"(())\", \"((()))\", \"(((())))\"])\nassert(separate_paren_groups(paren_string:\
    \ \"(()(())((())))\") == [\"(()(())((())))\"])\nassert(separate_paren_groups(paren_string:\
    \ \"( ) (( )) (( )( ))\") == [\"()\", \"(())\", \"(()())\"])"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659980041
- exit_code: -4
  program: "\n/// Input to this function is a string containing multiple groups of\
    \ nested parentheses. Your goal is to\n/// separate those group into separate\
    \ strings and return the array of those.\n/// Separate groups are balanced (each\
    \ open brace is properly closed) and not nested within each other\n/// Ignore\
    \ any spaces in the input string.\n/// >>> separate_paren_groups(paren_string:\
    \ \"( ) (( )) (( )( ))\")\n/// [\"()\", \"(())\", \"(()())\"]\nfunc separate_paren_groups(paren_string:\
    \ String) -> [String] {\n    var output = [String]()\n    var current_string =\
    \ \"\"\n    var counter = 0\n    for character in paren_string {\n        if character\
    \ == \"(\" {\n            counter += 1\n        } else if character == \")\" {\n\
    \            counter -= 1\n        }\n        if counter == 0 {\n            current_string\
    \ += String(character)\n            output.append(current_string)\n          \
    \  current_string = \"\"\n        } else {\n            current_string += String(character)\n\
    \        }\n    }\n    return output\n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(separate_paren_groups(paren_string: \"(()()) ((())) () ((())()())\") ==\
    \ [\"(()())\", \"((()))\", \"()\", \"((())()())\"])\nassert(separate_paren_groups(paren_string:\
    \ \"() (()) ((())) (((())))\") == [\"()\", \"(())\", \"((()))\", \"(((())))\"\
    ])\nassert(separate_paren_groups(paren_string: \"(()(())((())))\") == [\"(()(())((())))\"\
    ])\nassert(separate_paren_groups(paren_string: \"( ) (( )) (( )( ))\") == [\"\
    ()\", \"(())\", \"(()())\"])"
  status: Exception
  stderr: 'tmpzwwt6mxd/tmpzwwt6mxd.swift:42: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b11a8df9c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b11a8af0b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b11a8af0988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b11a8aef7b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpzwwt6mxd                        0x000055e9d1fda837 <unavailable> + 6199

    5    libc.so.6                          0x00002b11a8fe5460 __libc_start_main +
    245

    6    tmpzwwt6mxd                        0x000055e9d1fda3c9 <unavailable> + 5065

    '
  stdout: ''
  timestamp: 1659980041
- exit_code: -4
  program: "\n/// Input to this function is a string containing multiple groups of\
    \ nested parentheses. Your goal is to\n/// separate those group into separate\
    \ strings and return the array of those.\n/// Separate groups are balanced (each\
    \ open brace is properly closed) and not nested within each other\n/// Ignore\
    \ any spaces in the input string.\n/// >>> separate_paren_groups(paren_string:\
    \ \"( ) (( )) (( )( ))\")\n/// [\"()\", \"(())\", \"(()())\"]\nfunc separate_paren_groups(paren_string:\
    \ String) -> [String] {\n    \n    let charArray = paren_string.map { String($0)\
    \ }\n    var temp = \"\"\n    var result = [String]()\n    \n    for char in charArray\
    \ {\n        if char == \"(\" {\n            temp += char\n        } else if char\
    \ == \")\" {\n            temp += char\n            result.append(temp)\n    \
    \        temp = \"\"\n        }\n    }\n    \n    return result\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(separate_paren_groups(paren_string: \"(()()) ((())) ()\
    \ ((())()())\") == [\"(()())\", \"((()))\", \"()\", \"((())()())\"])\nassert(separate_paren_groups(paren_string:\
    \ \"() (()) ((())) (((())))\") == [\"()\", \"(())\", \"((()))\", \"(((())))\"\
    ])\nassert(separate_paren_groups(paren_string: \"(()(())((())))\") == [\"(()(())((())))\"\
    ])\nassert(separate_paren_groups(paren_string: \"( ) (( )) (( )( ))\") == [\"\
    ()\", \"(())\", \"(()())\"])"
  status: Exception
  stderr: 'tmpqoyjwdns/tmpqoyjwdns.swift:40: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002ae3b899ec80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002ae3b8695b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002ae3b8695988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002ae3b86947b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpqoyjwdns                        0x0000563aba4aa8f7 <unavailable> + 6391

    5    libc.so.6                          0x00002ae3b8b8a460 __libc_start_main +
    245

    6    tmpqoyjwdns                        0x0000563aba4aa489 <unavailable> + 5257

    '
  stdout: ''
  timestamp: 1659980041
- exit_code: 1
  program: "\n/// Input to this function is a string containing multiple groups of\
    \ nested parentheses. Your goal is to\n/// separate those group into separate\
    \ strings and return the array of those.\n/// Separate groups are balanced (each\
    \ open brace is properly closed) and not nested within each other\n/// Ignore\
    \ any spaces in the input string.\n/// >>> separate_paren_groups(paren_string:\
    \ \"( ) (( )) (( )( ))\")\n/// [\"()\", \"(())\", \"(()())\"]\nfunc separate_paren_groups(paren_string:\
    \ String) -> [String] {\n    var i = 0\n    var results = [String]()\n    var\
    \ current = \"\"\n    while i < paren_string.count {\n        if paren_string[i]\
    \ == \"(\" {\n            current += \"(\"\n        } else if paren_string[i]\
    \ == \")\" {\n            current += \")\"\n            results.append(current)\n\
    \            current = \"\"\n        }\n        i += 1\n    }\n    return results\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(separate_paren_groups(paren_string: \"(()()) ((()))\
    \ () ((())()())\") == [\"(()())\", \"((()))\", \"()\", \"((())()())\"])\nassert(separate_paren_groups(paren_string:\
    \ \"() (()) ((())) (((())))\") == [\"()\", \"(())\", \"((()))\", \"(((())))\"\
    ])\nassert(separate_paren_groups(paren_string: \"(()(())((())))\") == [\"(()(())((())))\"\
    ])\nassert(separate_paren_groups(paren_string: \"( ) (( )) (( )( ))\") == [\"\
    ()\", \"(())\", \"(()())\"])"
  status: SyntaxError
  stderr: "/tmp/tmpzjh0w9hn.swift:13:12: error: 'subscript(_:)' is unavailable: cannot\
    \ subscript String with an Int, use a String.Index instead.\n        if paren_string[i]\
    \ == \"(\" {\n           ^~~~~~~~~~~~~~~\nSwift.String:3:12: note: 'subscript(_:)'\
    \ has been explicitly marked unavailable here\n    public subscript(i: Int) ->\
    \ Character { get }\n           ^\n/tmp/tmpzjh0w9hn.swift:15:19: error: 'subscript(_:)'\
    \ is unavailable: cannot subscript String with an Int, use a String.Index instead.\n\
    \        } else if paren_string[i] == \")\" {\n                  ^~~~~~~~~~~~~~~\n\
    Swift.String:3:12: note: 'subscript(_:)' has been explicitly marked unavailable\
    \ here\n    public subscript(i: Int) -> Character { get }\n           ^\n"
  stdout: ''
  timestamp: 1659980041
- exit_code: -4
  program: "\n/// Input to this function is a string containing multiple groups of\
    \ nested parentheses. Your goal is to\n/// separate those group into separate\
    \ strings and return the array of those.\n/// Separate groups are balanced (each\
    \ open brace is properly closed) and not nested within each other\n/// Ignore\
    \ any spaces in the input string.\n/// >>> separate_paren_groups(paren_string:\
    \ \"( ) (( )) (( )( ))\")\n/// [\"()\", \"(())\", \"(()())\"]\nfunc separate_paren_groups(paren_string:\
    \ String) -> [String] {\n    if paren_string.isEmpty {\n        return []\n  \
    \  }\n    \n    var index = 0\n    var result: [String] = []\n    var bracketsCount\
    \ = 0\n    while index < paren_string.count {\n        let char = paren_string[paren_string.index(paren_string.startIndex,\
    \ offsetBy: index)]\n        let begin = paren_string.index(paren_string.startIndex,\
    \ offsetBy: index)\n        let end = paren_string.index(paren_string.startIndex,\
    \ offsetBy: index + 1)\n        let range = begin..<end\n        let substring\
    \ = paren_string[range]\n        if substring == \"(\" {\n            bracketsCount\
    \ += 1\n        } else if substring == \")\" {\n            bracketsCount -= 1\n\
    \        }\n        if char == \" \" {\n            index += 1\n            continue\n\
    \        }\n        if bracketsCount == 0 {\n            let charIndex = paren_string.index(paren_string.startIndex,\
    \ offsetBy: index + 1)\n            result.append(String(paren_string[paren_string.startIndex..<charIndex]))\n\
    \            index += 1\n        } else {\n            index += 1\n        }\n\
    \    }\n    return result\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(separate_paren_groups(paren_string:\
    \ \"(()()) ((())) () ((())()())\") == [\"(()())\", \"((()))\", \"()\", \"((())()())\"\
    ])\nassert(separate_paren_groups(paren_string: \"() (()) ((())) (((())))\") ==\
    \ [\"()\", \"(())\", \"((()))\", \"(((())))\"])\nassert(separate_paren_groups(paren_string:\
    \ \"(()(())((())))\") == [\"(()(())((())))\"])\nassert(separate_paren_groups(paren_string:\
    \ \"( ) (( )) (( )( ))\") == [\"()\", \"(())\", \"(()())\"])"
  status: Exception
  stderr: 'tmpqzo0nt8b/tmpqzo0nt8b.swift:55: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b6dcce52c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b6dccb49b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b6dccb49988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b6dccb487b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpqzo0nt8b                        0x000055cf8787da97 <unavailable> + 6807

    5    libc.so.6                          0x00002b6dcd03e460 __libc_start_main +
    245

    6    tmpqzo0nt8b                        0x000055cf8787d629 <unavailable> + 5673

    '
  stdout: ''
  timestamp: 1659980041
- exit_code: 0
  program: "\n/// Input to this function is a string containing multiple groups of\
    \ nested parentheses. Your goal is to\n/// separate those group into separate\
    \ strings and return the array of those.\n/// Separate groups are balanced (each\
    \ open brace is properly closed) and not nested within each other\n/// Ignore\
    \ any spaces in the input string.\n/// >>> separate_paren_groups(paren_string:\
    \ \"( ) (( )) (( )( ))\")\n/// [\"()\", \"(())\", \"(()())\"]\nfunc separate_paren_groups(paren_string:\
    \ String) -> [String] {\n    var strings = [String]()\n    var next_string = \"\
    \"\n    var nesting_level = 0\n    for c in paren_string {\n        if c == \"\
    \ \" {\n            continue\n        }\n        if c == \"(\" {\n           \
    \ nesting_level += 1\n        }\n        next_string.append(c)\n        if c ==\
    \ \")\" {\n            nesting_level -= 1\n            if nesting_level == 0 {\n\
    \                strings.append(next_string)\n                next_string = \"\
    \"\n            }\n        }\n    }\n    return strings\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(separate_paren_groups(paren_string: \"(()()) ((())) ()\
    \ ((())()())\") == [\"(()())\", \"((()))\", \"()\", \"((())()())\"])\nassert(separate_paren_groups(paren_string:\
    \ \"() (()) ((())) (((())))\") == [\"()\", \"(())\", \"((()))\", \"(((())))\"\
    ])\nassert(separate_paren_groups(paren_string: \"(()(())((())))\") == [\"(()(())((())))\"\
    ])\nassert(separate_paren_groups(paren_string: \"( ) (( )) (( )( ))\") == [\"\
    ()\", \"(())\", \"(()())\"])"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659980041
- exit_code: -4
  program: "\n/// Input to this function is a string containing multiple groups of\
    \ nested parentheses. Your goal is to\n/// separate those group into separate\
    \ strings and return the array of those.\n/// Separate groups are balanced (each\
    \ open brace is properly closed) and not nested within each other\n/// Ignore\
    \ any spaces in the input string.\n/// >>> separate_paren_groups(paren_string:\
    \ \"( ) (( )) (( )( ))\")\n/// [\"()\", \"(())\", \"(()())\"]\nfunc separate_paren_groups(paren_string:\
    \ String) -> [String] {\n    var result = [String]()\n    var temp = \"\"\n  \
    \  var open = 0\n    var close = 0\n    for char in paren_string {\n        if\
    \ char == \"(\" {\n            open += 1\n        } else if char == \")\" {\n\
    \            close += 1\n        }\n        if char != \" \" {\n            temp.append(char)\n\
    \        }\n        if open == close {\n            result.append(temp)\n    \
    \        temp = \"\"\n            open = 0\n            close = 0\n        }\n\
    \    }\n    return result\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(separate_paren_groups(paren_string:\
    \ \"(()()) ((())) () ((())()())\") == [\"(()())\", \"((()))\", \"()\", \"((())()())\"\
    ])\nassert(separate_paren_groups(paren_string: \"() (()) ((())) (((())))\") ==\
    \ [\"()\", \"(())\", \"((()))\", \"(((())))\"])\nassert(separate_paren_groups(paren_string:\
    \ \"(()(())((())))\") == [\"(()(())((())))\"])\nassert(separate_paren_groups(paren_string:\
    \ \"( ) (( )) (( )( ))\") == [\"()\", \"(())\", \"(()())\"])"
  status: Exception
  stderr: 'tmpx3og79qo/tmpx3og79qo.swift:45: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b576b574c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b576b26bb6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b576b26b988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b576b26a7b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpx3og79qo                        0x0000562c781487e7 <unavailable> + 6119

    5    libc.so.6                          0x00002b576b760460 __libc_start_main +
    245

    6    tmpx3og79qo                        0x0000562c78148379 <unavailable> + 4985

    '
  stdout: ''
  timestamp: 1659980041
- exit_code: 1
  program: "\n/// Input to this function is a string containing multiple groups of\
    \ nested parentheses. Your goal is to\n/// separate those group into separate\
    \ strings and return the array of those.\n/// Separate groups are balanced (each\
    \ open brace is properly closed) and not nested within each other\n/// Ignore\
    \ any spaces in the input string.\n/// >>> separate_paren_groups(paren_string:\
    \ \"( ) (( )) (( )( ))\")\n/// [\"()\", \"(())\", \"(()())\"]\nfunc separate_paren_groups(paren_string:\
    \ String) -> [String] {\n    var result: [String] = []\n    var group: String\
    \ = \"\"\n    var braces: String = \"\"\n    var open: Int = 0\n    var close:\
    \ Int = 0\n    var last_closed: Int = 0\n    var last_opened: Int = 0\n    var\
    \ i: Int = 0\n    while i < paren_string.count {\n        let next_char = paren_string[paren_string.index(paren_string.startIndex,\
    \ offsetBy: i)]\n        if next_char == \"(\" {\n            braces += next_char\n\
    \            open += 1\n            last_opened = i\n        } else if next_char\
    \ == \")\" {\n            braces += next_char\n            close += 1\n      \
    \      last_closed = i\n        }\n        if open == close {\n            if\
    \ !braces.isEmpty {\n                result.append(braces)\n                braces\
    \ = \"\"\n                open = 0\n                close = 0\n              \
    \  group = \"\"\n            }\n        }\n        i += 1\n    }\n    return result\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(separate_paren_groups(paren_string: \"(()()) ((()))\
    \ () ((())()())\") == [\"(()())\", \"((()))\", \"()\", \"((())()())\"])\nassert(separate_paren_groups(paren_string:\
    \ \"() (()) ((())) (((())))\") == [\"()\", \"(())\", \"((()))\", \"(((())))\"\
    ])\nassert(separate_paren_groups(paren_string: \"(()(())((())))\") == [\"(()(())((())))\"\
    ])\nassert(separate_paren_groups(paren_string: \"( ) (( )) (( )( ))\") == [\"\
    ()\", \"(())\", \"(()())\"])"
  status: SyntaxError
  stderr: "/tmp/tmp3xhpcom2.swift:20:23: error: cannot convert value of type 'Character'\
    \ to expected argument type 'String'\n            braces += next_char\n      \
    \                ^\n/tmp/tmp3xhpcom2.swift:24:23: error: cannot convert value\
    \ of type 'Character' to expected argument type 'String'\n            braces +=\
    \ next_char\n                      ^\n"
  stdout: ''
  timestamp: 1659980041
- exit_code: -4
  program: "\n/// Input to this function is a string containing multiple groups of\
    \ nested parentheses. Your goal is to\n/// separate those group into separate\
    \ strings and return the array of those.\n/// Separate groups are balanced (each\
    \ open brace is properly closed) and not nested within each other\n/// Ignore\
    \ any spaces in the input string.\n/// >>> separate_paren_groups(paren_string:\
    \ \"( ) (( )) (( )( ))\")\n/// [\"()\", \"(())\", \"(()())\"]\nfunc separate_paren_groups(paren_string:\
    \ String) -> [String] {\n    return [\"\"]\n}\n\n\nfunc ==(left: [(Int, Int)],\
    \ right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n       \
    \ return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r\
    \ {\n            return false\n        }\n    }\n    return true\n}\n        \
    \    \nassert(separate_paren_groups(paren_string: \"(()()) ((())) () ((())()())\"\
    ) == [\"(()())\", \"((()))\", \"()\", \"((())()())\"])\nassert(separate_paren_groups(paren_string:\
    \ \"() (()) ((())) (((())))\") == [\"()\", \"(())\", \"((()))\", \"(((())))\"\
    ])\nassert(separate_paren_groups(paren_string: \"(()(())((())))\") == [\"(()(())((())))\"\
    ])\nassert(separate_paren_groups(paren_string: \"( ) (( )) (( )( ))\") == [\"\
    ()\", \"(())\", \"(()())\"])"
  status: Exception
  stderr: 'tmpu1dkqwxi/tmpu1dkqwxi.swift:25: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b9f828acc80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b9f825a3b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b9f825a3988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b9f825a27b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpu1dkqwxi                        0x00005586b8fa2537 <unavailable> + 5431

    5    libc.so.6                          0x00002b9f82a98460 __libc_start_main +
    245

    6    tmpu1dkqwxi                        0x00005586b8fa20c9 <unavailable> + 4297

    '
  stdout: ''
  timestamp: 1659980041
- exit_code: 0
  program: "\n/// Input to this function is a string containing multiple groups of\
    \ nested parentheses. Your goal is to\n/// separate those group into separate\
    \ strings and return the array of those.\n/// Separate groups are balanced (each\
    \ open brace is properly closed) and not nested within each other\n/// Ignore\
    \ any spaces in the input string.\n/// >>> separate_paren_groups(paren_string:\
    \ \"( ) (( )) (( )( ))\")\n/// [\"()\", \"(())\", \"(()())\"]\nfunc separate_paren_groups(paren_string:\
    \ String) -> [String] {\n    var array_string = [String]()\n    var current_paren_string\
    \ = \"\"\n    var open_paren_counter = 0\n    var close_paren_counter = 0\n  \
    \  for char in paren_string {\n        if char == \"(\" {\n            current_paren_string\
    \ += String(char)\n            open_paren_counter += 1\n        } else if char\
    \ == \")\" {\n            current_paren_string += String(char)\n            close_paren_counter\
    \ += 1\n        }\n        if open_paren_counter > 0 && open_paren_counter ==\
    \ close_paren_counter {\n            array_string.append(current_paren_string)\n\
    \            current_paren_string = \"\"\n            open_paren_counter = 0\n\
    \            close_paren_counter = 0\n        }\n    }\n    return array_string\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(separate_paren_groups(paren_string: \"(()()) ((()))\
    \ () ((())()())\") == [\"(()())\", \"((()))\", \"()\", \"((())()())\"])\nassert(separate_paren_groups(paren_string:\
    \ \"() (()) ((())) (((())))\") == [\"()\", \"(())\", \"((()))\", \"(((())))\"\
    ])\nassert(separate_paren_groups(paren_string: \"(()(())((())))\") == [\"(()(())((())))\"\
    ])\nassert(separate_paren_groups(paren_string: \"( ) (( )) (( )( ))\") == [\"\
    ()\", \"(())\", \"(()())\"])"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659980041
- exit_code: 1
  program: "\n/// Input to this function is a string containing multiple groups of\
    \ nested parentheses. Your goal is to\n/// separate those group into separate\
    \ strings and return the array of those.\n/// Separate groups are balanced (each\
    \ open brace is properly closed) and not nested within each other\n/// Ignore\
    \ any spaces in the input string.\n/// >>> separate_paren_groups(paren_string:\
    \ \"( ) (( )) (( )( ))\")\n/// [\"()\", \"(())\", \"(()())\"]\nfunc separate_paren_groups(paren_string:\
    \ String) -> [String] {\n    // your code here\n    let paren_string = paren_string.replacingOccurrences(of:\
    \ \" \", with: \"\")\n    var result = [String]()\n    var startIdx = 0\n    for\
    \ (idx, paren) in paren_string.enumerated() {\n        if paren == \"(\" {\n \
    \           startIdx = idx\n        } else if paren == \")\" {\n            result.append(paren_string[paren_string.index(paren_string.startIndex,\
    \ offsetBy: startIdx)...paren_string.index(paren_string.startIndex, offsetBy:\
    \ idx)])\n        }\n    }\n    return result\n}\n\n\nfunc ==(left: [(Int, Int)],\
    \ right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n       \
    \ return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r\
    \ {\n            return false\n        }\n    }\n    return true\n}\n        \
    \    \nassert(separate_paren_groups(paren_string: \"(()()) ((())) () ((())()())\"\
    ) == [\"(()())\", \"((()))\", \"()\", \"((())()())\"])\nassert(separate_paren_groups(paren_string:\
    \ \"() (()) ((())) (((())))\") == [\"()\", \"(())\", \"((()))\", \"(((())))\"\
    ])\nassert(separate_paren_groups(paren_string: \"(()(())((())))\") == [\"(()(())((())))\"\
    ])\nassert(separate_paren_groups(paren_string: \"( ) (( )) (( )( ))\") == [\"\
    ()\", \"(())\", \"(()())\"])"
  status: SyntaxError
  stderr: "/tmp/tmpkibf6f9y.swift:10:37: error: value of type 'String' has no member\
    \ 'replacingOccurrences'\n    let paren_string = paren_string.replacingOccurrences(of:\
    \ \" \", with: \"\")\n                       ~~~~~~~~~~~~ ^~~~~~~~~~~~~~~~~~~~\n"
  stdout: ''
  timestamp: 1659980041
- exit_code: 1
  program: "\n/// Input to this function is a string containing multiple groups of\
    \ nested parentheses. Your goal is to\n/// separate those group into separate\
    \ strings and return the array of those.\n/// Separate groups are balanced (each\
    \ open brace is properly closed) and not nested within each other\n/// Ignore\
    \ any spaces in the input string.\n/// >>> separate_paren_groups(paren_string:\
    \ \"( ) (( )) (( )( ))\")\n/// [\"()\", \"(())\", \"(()())\"]\nfunc separate_paren_groups(paren_string:\
    \ String) -> [String] {\n    var stack = Stack<String>()\n    var output = [String]()\n\
    \    for character in paren_string {\n        if character == \"(\" {\n      \
    \      stack.push(String(character))\n        } else if character == \")\" {\n\
    \            var current = stack.pop()!\n            current.append(String(character))\n\
    \            stack.push(current)\n        }\n    }\n    while !stack.isEmpty()\
    \ {\n        output.append(stack.pop()!)\n    }\n    return output\n}\n\n\nfunc\
    \ ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count !=\
    \ right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(separate_paren_groups(paren_string: \"(()()) ((()))\
    \ () ((())()())\") == [\"(()())\", \"((()))\", \"()\", \"((())()())\"])\nassert(separate_paren_groups(paren_string:\
    \ \"() (()) ((())) (((())))\") == [\"()\", \"(())\", \"((()))\", \"(((())))\"\
    ])\nassert(separate_paren_groups(paren_string: \"(()(())((())))\") == [\"(()(())((())))\"\
    ])\nassert(separate_paren_groups(paren_string: \"( ) (( )) (( )( ))\") == [\"\
    ()\", \"(())\", \"(()())\"])"
  status: SyntaxError
  stderr: "/tmp/tmpsfq0l271.swift:9:17: error: cannot find 'Stack' in scope\n    var\
    \ stack = Stack<String>()\n                ^~~~~\n"
  stdout: ''
  timestamp: 1659980041
- exit_code: 1
  program: "\n/// Input to this function is a string containing multiple groups of\
    \ nested parentheses. Your goal is to\n/// separate those group into separate\
    \ strings and return the array of those.\n/// Separate groups are balanced (each\
    \ open brace is properly closed) and not nested within each other\n/// Ignore\
    \ any spaces in the input string.\n/// >>> separate_paren_groups(paren_string:\
    \ \"( ) (( )) (( )( ))\")\n/// [\"()\", \"(())\", \"(()())\"]\nfunc separate_paren_groups(paren_string:\
    \ String) -> [String] {\n    var result: [String] = []\n    let parens = paren_string.filter{$0\
    \ != \" \"}\n    var stack = Stack<Character>()\n    var string = \"\"\n    for\
    \ paren in parens {\n        string.append(paren)\n        if paren == \"(\" {\n\
    \            stack.push(paren)\n        } else {\n            guard stack.pop()\
    \ != nil else { return [] }\n            if stack.isEmpty {\n                result.append(string)\n\
    \                string = \"\"\n            }\n        }\n    }\n    return result\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(separate_paren_groups(paren_string: \"(()()) ((()))\
    \ () ((())()())\") == [\"(()())\", \"((()))\", \"()\", \"((())()())\"])\nassert(separate_paren_groups(paren_string:\
    \ \"() (()) ((())) (((())))\") == [\"()\", \"(())\", \"((()))\", \"(((())))\"\
    ])\nassert(separate_paren_groups(paren_string: \"(()(())((())))\") == [\"(()(())((())))\"\
    ])\nassert(separate_paren_groups(paren_string: \"( ) (( )) (( )( ))\") == [\"\
    ()\", \"(())\", \"(()())\"])"
  status: SyntaxError
  stderr: "/tmp/tmp9281echi.swift:11:17: error: cannot find 'Stack' in scope\n   \
    \ var stack = Stack<Character>()\n                ^~~~~\n"
  stdout: ''
  timestamp: 1659980041
- exit_code: -4
  program: "\n/// Input to this function is a string containing multiple groups of\
    \ nested parentheses. Your goal is to\n/// separate those group into separate\
    \ strings and return the array of those.\n/// Separate groups are balanced (each\
    \ open brace is properly closed) and not nested within each other\n/// Ignore\
    \ any spaces in the input string.\n/// >>> separate_paren_groups(paren_string:\
    \ \"( ) (( )) (( )( ))\")\n/// [\"()\", \"(())\", \"(()())\"]\nfunc separate_paren_groups(paren_string:\
    \ String) -> [String] {\n    return []\n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(separate_paren_groups(paren_string: \"(()()) ((())) () ((())()())\") ==\
    \ [\"(()())\", \"((()))\", \"()\", \"((())()())\"])\nassert(separate_paren_groups(paren_string:\
    \ \"() (()) ((())) (((())))\") == [\"()\", \"(())\", \"((()))\", \"(((())))\"\
    ])\nassert(separate_paren_groups(paren_string: \"(()(())((())))\") == [\"(()(())((())))\"\
    ])\nassert(separate_paren_groups(paren_string: \"( ) (( )) (( )( ))\") == [\"\
    ()\", \"(())\", \"(()())\"])"
  status: Exception
  stderr: 'tmp1zdkbtz2/tmp1zdkbtz2.swift:25: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002aeebe8b5c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002aeebe5acb6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002aeebe5ac988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002aeebe5ab7b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmp1zdkbtz2                        0x0000556857c08537 <unavailable> + 5431

    5    libc.so.6                          0x00002aeebeaa1460 __libc_start_main +
    245

    6    tmp1zdkbtz2                        0x0000556857c080c9 <unavailable> + 4297

    '
  stdout: ''
  timestamp: 1659980040
- exit_code: 0
  program: "\n/// Input to this function is a string containing multiple groups of\
    \ nested parentheses. Your goal is to\n/// separate those group into separate\
    \ strings and return the array of those.\n/// Separate groups are balanced (each\
    \ open brace is properly closed) and not nested within each other\n/// Ignore\
    \ any spaces in the input string.\n/// >>> separate_paren_groups(paren_string:\
    \ \"( ) (( )) (( )( ))\")\n/// [\"()\", \"(())\", \"(()())\"]\nfunc separate_paren_groups(paren_string:\
    \ String) -> [String] {\n    var parenGroups = [String]()\n    var currentParenGroup\
    \ = String()\n    var openParenCount = 0\n    for char in paren_string {\n   \
    \     if char == \"(\" {\n            openParenCount += 1\n            currentParenGroup.append(char)\n\
    \        } else if char == \")\" {\n            openParenCount -= 1\n        \
    \    currentParenGroup.append(char)\n            if openParenCount == 0 {\n  \
    \              parenGroups.append(currentParenGroup)\n                currentParenGroup\
    \ = String()\n            }\n        }\n    }\n    return parenGroups\n}\n\n\n\
    func ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(separate_paren_groups(paren_string: \"(()()) ((()))\
    \ () ((())()())\") == [\"(()())\", \"((()))\", \"()\", \"((())()())\"])\nassert(separate_paren_groups(paren_string:\
    \ \"() (()) ((())) (((())))\") == [\"()\", \"(())\", \"((()))\", \"(((())))\"\
    ])\nassert(separate_paren_groups(paren_string: \"(()(())((())))\") == [\"(()(())((())))\"\
    ])\nassert(separate_paren_groups(paren_string: \"( ) (( )) (( )( ))\") == [\"\
    ()\", \"(())\", \"(()())\"])"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659980041
- exit_code: -4
  program: "\n/// Input to this function is a string containing multiple groups of\
    \ nested parentheses. Your goal is to\n/// separate those group into separate\
    \ strings and return the array of those.\n/// Separate groups are balanced (each\
    \ open brace is properly closed) and not nested within each other\n/// Ignore\
    \ any spaces in the input string.\n/// >>> separate_paren_groups(paren_string:\
    \ \"( ) (( )) (( )( ))\")\n/// [\"()\", \"(())\", \"(()())\"]\nfunc separate_paren_groups(paren_string:\
    \ String) -> [String] {\n    var result = [String]()\n    var current_string =\
    \ \"\"\n    var paren_counter = 0\n    for char in paren_string {\n        if\
    \ char == \"(\" {\n            paren_counter += 1\n        } else if char == \"\
    )\" {\n            paren_counter -= 1\n        }\n        if paren_counter ==\
    \ 0 {\n            if !current_string.isEmpty {\n                result.append(current_string)\n\
    \                current_string = \"\"\n            }\n        } else {\n    \
    \        current_string.append(char)\n        }\n    }\n    return result\n}\n\
    \n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(separate_paren_groups(paren_string: \"(()()) ((()))\
    \ () ((())()())\") == [\"(()())\", \"((()))\", \"()\", \"((())()())\"])\nassert(separate_paren_groups(paren_string:\
    \ \"() (()) ((())) (((())))\") == [\"()\", \"(())\", \"((()))\", \"(((())))\"\
    ])\nassert(separate_paren_groups(paren_string: \"(()(())((())))\") == [\"(()(())((())))\"\
    ])\nassert(separate_paren_groups(paren_string: \"( ) (( )) (( )( ))\") == [\"\
    ()\", \"(())\", \"(()())\"])"
  status: Exception
  stderr: 'tmpsb14cd57/tmpsb14cd57.swift:43: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002ae21f3aac80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002ae21f0a1b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002ae21f0a1988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002ae21f0a07b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpsb14cd57                        0x000055fe3ce2b837 <unavailable> + 6199

    5    libc.so.6                          0x00002ae21f596460 __libc_start_main +
    245

    6    tmpsb14cd57                        0x000055fe3ce2b3c9 <unavailable> + 5065

    '
  stdout: ''
  timestamp: 1659980041
- exit_code: 1
  program: "\n/// Input to this function is a string containing multiple groups of\
    \ nested parentheses. Your goal is to\n/// separate those group into separate\
    \ strings and return the array of those.\n/// Separate groups are balanced (each\
    \ open brace is properly closed) and not nested within each other\n/// Ignore\
    \ any spaces in the input string.\n/// >>> separate_paren_groups(paren_string:\
    \ \"( ) (( )) (( )( ))\")\n/// [\"()\", \"(())\", \"(()())\"]\nfunc separate_paren_groups(paren_string:\
    \ String) -> [String] {\n    let parenArr = paren_string.components(separatedBy:\
    \ \" \")\n    var result = [String]()\n    var tempResult = \"\"\n    var count\
    \ = 0\n    for i in 0...parenArr.count - 1 {\n        if parenArr[i] == \"(\"\
    \ {\n            tempResult += parenArr[i]\n            count += 1\n        }\
    \ else if parenArr[i] == \")\" {\n            tempResult += parenArr[i]\n    \
    \        count -= 1\n            if count == 0 {\n                result.append(tempResult)\n\
    \                tempResult = \"\"\n            }\n        }\n    }\n    return\
    \ result\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n\
    \    if left.count != right.count {\n        return false\n    }\n    for (l,\
    \ r) in zip(left, right) {\n        if l != r {\n            return false\n  \
    \      }\n    }\n    return true\n}\n            \nassert(separate_paren_groups(paren_string:\
    \ \"(()()) ((())) () ((())()())\") == [\"(()())\", \"((()))\", \"()\", \"((())()())\"\
    ])\nassert(separate_paren_groups(paren_string: \"() (()) ((())) (((())))\") ==\
    \ [\"()\", \"(())\", \"((()))\", \"(((())))\"])\nassert(separate_paren_groups(paren_string:\
    \ \"(()(())((())))\") == [\"(()(())((())))\"])\nassert(separate_paren_groups(paren_string:\
    \ \"( ) (( )) (( )( ))\") == [\"()\", \"(())\", \"(()())\"])"
  status: SyntaxError
  stderr: "/tmp/tmp4c6198sx.swift:9:33: error: value of type 'String' has no member\
    \ 'components'\n    let parenArr = paren_string.components(separatedBy: \" \"\
    )\n                   ~~~~~~~~~~~~ ^~~~~~~~~~\n"
  stdout: ''
  timestamp: 1659980041
- exit_code: 1
  program: "\n/// Input to this function is a string containing multiple groups of\
    \ nested parentheses. Your goal is to\n/// separate those group into separate\
    \ strings and return the array of those.\n/// Separate groups are balanced (each\
    \ open brace is properly closed) and not nested within each other\n/// Ignore\
    \ any spaces in the input string.\n/// >>> separate_paren_groups(paren_string:\
    \ \"( ) (( )) (( )( ))\")\n/// [\"()\", \"(())\", \"(()())\"]\nfunc separate_paren_groups(paren_string:\
    \ String) -> [String] {\n    let clean = paren_string.replacingOccurrences(of:\
    \ \" \", with: \"\")\n    var stack = Array<Character>()\n    var groups = Array<String>()\n\
    \    var start = 0\n    for (i, char) in clean.enumerated() {\n        if char\
    \ == \"(\" {\n            stack.append(char)\n        } else if char == \")\"\
    \ {\n            stack.removeLast()\n            if stack.isEmpty {\n        \
    \        groups.append(String(clean[clean.index(clean.startIndex, offsetBy: start)..<clean.index(clean.startIndex,\
    \ offsetBy: i+1)]))\n                start = i+1\n            }\n        }\n \
    \   }\n    return groups\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(separate_paren_groups(paren_string:\
    \ \"(()()) ((())) () ((())()())\") == [\"(()())\", \"((()))\", \"()\", \"((())()())\"\
    ])\nassert(separate_paren_groups(paren_string: \"() (()) ((())) (((())))\") ==\
    \ [\"()\", \"(())\", \"((()))\", \"(((())))\"])\nassert(separate_paren_groups(paren_string:\
    \ \"(()(())((())))\") == [\"(()(())((())))\"])\nassert(separate_paren_groups(paren_string:\
    \ \"( ) (( )) (( )( ))\") == [\"()\", \"(())\", \"(()())\"])"
  status: SyntaxError
  stderr: "/tmp/tmpy5qzsoak.swift:9:30: error: value of type 'String' has no member\
    \ 'replacingOccurrences'\n    let clean = paren_string.replacingOccurrences(of:\
    \ \" \", with: \"\")\n                ~~~~~~~~~~~~ ^~~~~~~~~~~~~~~~~~~~\n"
  stdout: ''
  timestamp: 1659980041
- exit_code: -4
  program: "\n/// Input to this function is a string containing multiple groups of\
    \ nested parentheses. Your goal is to\n/// separate those group into separate\
    \ strings and return the array of those.\n/// Separate groups are balanced (each\
    \ open brace is properly closed) and not nested within each other\n/// Ignore\
    \ any spaces in the input string.\n/// >>> separate_paren_groups(paren_string:\
    \ \"( ) (( )) (( )( ))\")\n/// [\"()\", \"(())\", \"(()())\"]\nfunc separate_paren_groups(paren_string:\
    \ String) -> [String] {\n    var stack: [Character] = []\n    var current: [Character]\
    \ = []\n    var groups: [[Character]] = []\n    var string = paren_string\n  \
    \  string.removeAll { $0 == \" \" }\n    for c in string {\n        if c == \"\
    (\" {\n            stack.append(c)\n        } else if c == \")\" {\n         \
    \   stack.removeLast()\n            current.append(c)\n            if stack.isEmpty\
    \ {\n                groups.append(current)\n                current = []\n  \
    \          }\n        }\n    }\n    return groups.map { String($0) }\n}\n\n\n\
    func ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(separate_paren_groups(paren_string: \"(()()) ((()))\
    \ () ((())()())\") == [\"(()())\", \"((()))\", \"()\", \"((())()())\"])\nassert(separate_paren_groups(paren_string:\
    \ \"() (()) ((())) (((())))\") == [\"()\", \"(())\", \"((()))\", \"(((())))\"\
    ])\nassert(separate_paren_groups(paren_string: \"(()(())((())))\") == [\"(()(())((())))\"\
    ])\nassert(separate_paren_groups(paren_string: \"( ) (( )) (( )( ))\") == [\"\
    ()\", \"(())\", \"(()())\"])"
  status: Exception
  stderr: 'tmp57c5y1ep/tmp57c5y1ep.swift:42: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b686c373c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b686c06ab6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b686c06a988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b686c0697b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmp57c5y1ep                        0x00005586f5832ab7 <unavailable> + 6839

    5    libc.so.6                          0x00002b686c55f460 __libc_start_main +
    245

    6    tmp57c5y1ep                        0x00005586f5832649 <unavailable> + 5705

    '
  stdout: ''
  timestamp: 1659980041
- exit_code: -4
  program: "\n/// Input to this function is a string containing multiple groups of\
    \ nested parentheses. Your goal is to\n/// separate those group into separate\
    \ strings and return the array of those.\n/// Separate groups are balanced (each\
    \ open brace is properly closed) and not nested within each other\n/// Ignore\
    \ any spaces in the input string.\n/// >>> separate_paren_groups(paren_string:\
    \ \"( ) (( )) (( )( ))\")\n/// [\"()\", \"(())\", \"(()())\"]\nfunc separate_paren_groups(paren_string:\
    \ String) -> [String] {\n    if paren_string.isEmpty {\n        return []\n  \
    \  }\n    \n    var stack = [Character]()\n    var result = [String]()\n    var\
    \ current = \"\"\n    \n    for char in paren_string {\n        if char == \"\
    (\" {\n            stack.append(char)\n        } else if char == \")\" {\n   \
    \         if stack.isEmpty {\n                return []\n            }\n     \
    \       stack.removeLast()\n        }\n        \n        current.append(char)\n\
    \        \n        if stack.isEmpty {\n            result.append(current)\n  \
    \          current = \"\"\n        }\n    }\n    \n    return result\n}\n\n\n\
    func ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(separate_paren_groups(paren_string: \"(()()) ((()))\
    \ () ((())()())\") == [\"(()())\", \"((()))\", \"()\", \"((())()())\"])\nassert(separate_paren_groups(paren_string:\
    \ \"() (()) ((())) (((())))\") == [\"()\", \"(())\", \"((()))\", \"(((())))\"\
    ])\nassert(separate_paren_groups(paren_string: \"(()(())((())))\") == [\"(()(())((())))\"\
    ])\nassert(separate_paren_groups(paren_string: \"( ) (( )) (( )( ))\") == [\"\
    ()\", \"(())\", \"(()())\"])"
  status: Exception
  stderr: 'tmpoxbuo3b9/tmpoxbuo3b9.swift:51: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002adc0fe15c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002adc0fb0cb6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002adc0fb0c988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002adc0fb0b7b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpoxbuo3b9                        0x000055b1a6d8ca67 <unavailable> + 6759

    5    libc.so.6                          0x00002adc10001460 __libc_start_main +
    245

    6    tmpoxbuo3b9                        0x000055b1a6d8c5f9 <unavailable> + 5625

    '
  stdout: ''
  timestamp: 1659980041
- exit_code: -4
  program: "\n/// Input to this function is a string containing multiple groups of\
    \ nested parentheses. Your goal is to\n/// separate those group into separate\
    \ strings and return the array of those.\n/// Separate groups are balanced (each\
    \ open brace is properly closed) and not nested within each other\n/// Ignore\
    \ any spaces in the input string.\n/// >>> separate_paren_groups(paren_string:\
    \ \"( ) (( )) (( )( ))\")\n/// [\"()\", \"(())\", \"(()())\"]\nfunc separate_paren_groups(paren_string:\
    \ String) -> [String] {\n    // Your solution here\n    return []\n}\n\n\nfunc\
    \ ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count !=\
    \ right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(separate_paren_groups(paren_string: \"(()()) ((()))\
    \ () ((())()())\") == [\"(()())\", \"((()))\", \"()\", \"((())()())\"])\nassert(separate_paren_groups(paren_string:\
    \ \"() (()) ((())) (((())))\") == [\"()\", \"(())\", \"((()))\", \"(((())))\"\
    ])\nassert(separate_paren_groups(paren_string: \"(()(())((())))\") == [\"(()(())((())))\"\
    ])\nassert(separate_paren_groups(paren_string: \"( ) (( )) (( )( ))\") == [\"\
    ()\", \"(())\", \"(()())\"])"
  status: Exception
  stderr: 'tmpzf16gldx/tmpzf16gldx.swift:26: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b0dc17ddc80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b0dc14d4b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b0dc14d4988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b0dc14d37b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpzf16gldx                        0x000055ba5d1d7537 <unavailable> + 5431

    5    libc.so.6                          0x00002b0dc19c9460 __libc_start_main +
    245

    6    tmpzf16gldx                        0x000055ba5d1d70c9 <unavailable> + 4297

    '
  stdout: ''
  timestamp: 1659980041
- exit_code: -4
  program: "\n/// Input to this function is a string containing multiple groups of\
    \ nested parentheses. Your goal is to\n/// separate those group into separate\
    \ strings and return the array of those.\n/// Separate groups are balanced (each\
    \ open brace is properly closed) and not nested within each other\n/// Ignore\
    \ any spaces in the input string.\n/// >>> separate_paren_groups(paren_string:\
    \ \"( ) (( )) (( )( ))\")\n/// [\"()\", \"(())\", \"(()())\"]\nfunc separate_paren_groups(paren_string:\
    \ String) -> [String] {\n    var output: [String] = []\n    var buffer: String\
    \ = \"\"\n    var balance: Int = 0\n    for char in paren_string {\n        buffer.append(char)\n\
    \        if char == \"(\" {\n            balance += 1\n        } else if char\
    \ == \")\" {\n            balance -= 1\n        }\n        if balance == 0 {\n\
    \            output.append(buffer)\n            buffer = \"\"\n        }\n   \
    \ }\n    return output\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(separate_paren_groups(paren_string:\
    \ \"(()()) ((())) () ((())()())\") == [\"(()())\", \"((()))\", \"()\", \"((())()())\"\
    ])\nassert(separate_paren_groups(paren_string: \"() (()) ((())) (((())))\") ==\
    \ [\"()\", \"(())\", \"((()))\", \"(((())))\"])\nassert(separate_paren_groups(paren_string:\
    \ \"(()(())((())))\") == [\"(()(())((())))\"])\nassert(separate_paren_groups(paren_string:\
    \ \"( ) (( )) (( )( ))\") == [\"()\", \"(())\", \"(()())\"])"
  status: Exception
  stderr: 'tmpah0xb70l/tmpah0xb70l.swift:40: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002ae4ed460c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002ae4ed157b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002ae4ed157988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002ae4ed1567b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpah0xb70l                        0x000055cf630e3787 <unavailable> + 6023

    5    libc.so.6                          0x00002ae4ed64c460 __libc_start_main +
    245

    6    tmpah0xb70l                        0x000055cf630e3319 <unavailable> + 4889

    '
  stdout: ''
  timestamp: 1659980041
- exit_code: 0
  program: "\n/// Input to this function is a string containing multiple groups of\
    \ nested parentheses. Your goal is to\n/// separate those group into separate\
    \ strings and return the array of those.\n/// Separate groups are balanced (each\
    \ open brace is properly closed) and not nested within each other\n/// Ignore\
    \ any spaces in the input string.\n/// >>> separate_paren_groups(paren_string:\
    \ \"( ) (( )) (( )( ))\")\n/// [\"()\", \"(())\", \"(()())\"]\nfunc separate_paren_groups(paren_string:\
    \ String) -> [String] {\n    let parens = paren_string.filter { $0 != \" \" }\n\
    \    var result: [String] = []\n    var temp = \"\"\n    var open = 0\n    for\
    \ paren in parens {\n        if paren == \"(\" {\n            open += 1\n    \
    \    } else {\n            open -= 1\n        }\n        temp.append(paren)\n\
    \        if open == 0 {\n            result.append(temp)\n            temp = \"\
    \"\n        }\n    }\n    return result\n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(separate_paren_groups(paren_string: \"(()()) ((())) () ((())()())\") ==\
    \ [\"(()())\", \"((()))\", \"()\", \"((())()())\"])\nassert(separate_paren_groups(paren_string:\
    \ \"() (()) ((())) (((())))\") == [\"()\", \"(())\", \"((()))\", \"(((())))\"\
    ])\nassert(separate_paren_groups(paren_string: \"(()(())((())))\") == [\"(()(())((())))\"\
    ])\nassert(separate_paren_groups(paren_string: \"( ) (( )) (( )( ))\") == [\"\
    ()\", \"(())\", \"(()())\"])"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659980041
- exit_code: 0
  program: "\n/// Input to this function is a string containing multiple groups of\
    \ nested parentheses. Your goal is to\n/// separate those group into separate\
    \ strings and return the array of those.\n/// Separate groups are balanced (each\
    \ open brace is properly closed) and not nested within each other\n/// Ignore\
    \ any spaces in the input string.\n/// >>> separate_paren_groups(paren_string:\
    \ \"( ) (( )) (( )( ))\")\n/// [\"()\", \"(())\", \"(()())\"]\nfunc separate_paren_groups(paren_string:\
    \ String) -> [String] {\n    var parens = [String]()\n    var temp = \"\"\n  \
    \  var num = 0\n    for c in paren_string {\n        if c == \"(\" {\n       \
    \     temp.append(c)\n            num += 1\n        } else if c == \")\" {\n \
    \           temp.append(c)\n            num -= 1\n            if num == 0 {\n\
    \                parens.append(temp)\n                temp = \"\"\n          \
    \  }\n        }\n    }\n    return parens\n}\n\n\nfunc ==(left: [(Int, Int)],\
    \ right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n       \
    \ return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r\
    \ {\n            return false\n        }\n    }\n    return true\n}\n        \
    \    \nassert(separate_paren_groups(paren_string: \"(()()) ((())) () ((())()())\"\
    ) == [\"(()())\", \"((()))\", \"()\", \"((())()())\"])\nassert(separate_paren_groups(paren_string:\
    \ \"() (()) ((())) (((())))\") == [\"()\", \"(())\", \"((()))\", \"(((())))\"\
    ])\nassert(separate_paren_groups(paren_string: \"(()(())((())))\") == [\"(()(())((())))\"\
    ])\nassert(separate_paren_groups(paren_string: \"( ) (( )) (( )( ))\") == [\"\
    ()\", \"(())\", \"(()())\"])"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659980041
- exit_code: -4
  program: "\n/// Input to this function is a string containing multiple groups of\
    \ nested parentheses. Your goal is to\n/// separate those group into separate\
    \ strings and return the array of those.\n/// Separate groups are balanced (each\
    \ open brace is properly closed) and not nested within each other\n/// Ignore\
    \ any spaces in the input string.\n/// >>> separate_paren_groups(paren_string:\
    \ \"( ) (( )) (( )( ))\")\n/// [\"()\", \"(())\", \"(()())\"]\nfunc separate_paren_groups(paren_string:\
    \ String) -> [String] {\n    // FIXME: Implement\n    return []\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(separate_paren_groups(paren_string: \"(()()) ((())) ()\
    \ ((())()())\") == [\"(()())\", \"((()))\", \"()\", \"((())()())\"])\nassert(separate_paren_groups(paren_string:\
    \ \"() (()) ((())) (((())))\") == [\"()\", \"(())\", \"((()))\", \"(((())))\"\
    ])\nassert(separate_paren_groups(paren_string: \"(()(())((())))\") == [\"(()(())((())))\"\
    ])\nassert(separate_paren_groups(paren_string: \"( ) (( )) (( )( ))\") == [\"\
    ()\", \"(())\", \"(()())\"])"
  status: Exception
  stderr: 'tmp1c_b8iio/tmp1c_b8iio.swift:26: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b8760f3ac80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b8760c31b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b8760c31988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b8760c307b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmp1c_b8iio                        0x00005628d975e537 <unavailable> + 5431

    5    libc.so.6                          0x00002b8761126460 __libc_start_main +
    245

    6    tmp1c_b8iio                        0x00005628d975e0c9 <unavailable> + 4297

    '
  stdout: ''
  timestamp: 1659980041
- exit_code: -4
  program: "\n/// Input to this function is a string containing multiple groups of\
    \ nested parentheses. Your goal is to\n/// separate those group into separate\
    \ strings and return the array of those.\n/// Separate groups are balanced (each\
    \ open brace is properly closed) and not nested within each other\n/// Ignore\
    \ any spaces in the input string.\n/// >>> separate_paren_groups(paren_string:\
    \ \"( ) (( )) (( )( ))\")\n/// [\"()\", \"(())\", \"(()())\"]\nfunc separate_paren_groups(paren_string:\
    \ String) -> [String] {\n    var unclosed_open_parens = 0\n    var groups = [String]()\n\
    \    var accumulated_group = \"\"\n    for character in paren_string {\n     \
    \   if (character == \"(\") {\n            unclosed_open_parens += 1\n       \
    \     accumulated_group += \"(\"\n        } else if (character == \")\") {\n \
    \           unclosed_open_parens -= 1\n            accumulated_group += \")\"\n\
    \        }\n        if (unclosed_open_parens == 0) {\n            groups.append(accumulated_group)\n\
    \            accumulated_group = \"\"\n        }\n    }\n    return groups\n}\n\
    \n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(separate_paren_groups(paren_string: \"(()()) ((()))\
    \ () ((())()())\") == [\"(()())\", \"((()))\", \"()\", \"((())()())\"])\nassert(separate_paren_groups(paren_string:\
    \ \"() (()) ((())) (((())))\") == [\"()\", \"(())\", \"((()))\", \"(((())))\"\
    ])\nassert(separate_paren_groups(paren_string: \"(()(())((())))\") == [\"(()(())((())))\"\
    ])\nassert(separate_paren_groups(paren_string: \"( ) (( )) (( )( ))\") == [\"\
    ()\", \"(())\", \"(()())\"])"
  status: Exception
  stderr: 'tmpf9en3280/tmpf9en3280.swift:41: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002abb2ab2cc80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002abb2a823b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002abb2a823988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002abb2a8227b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpf9en3280                        0x000055e1c7e077e7 <unavailable> + 6119

    5    libc.so.6                          0x00002abb2ad18460 __libc_start_main +
    245

    6    tmpf9en3280                        0x000055e1c7e07379 <unavailable> + 4985

    '
  stdout: ''
  timestamp: 1659980041
- exit_code: -4
  program: "\n/// Input to this function is a string containing multiple groups of\
    \ nested parentheses. Your goal is to\n/// separate those group into separate\
    \ strings and return the array of those.\n/// Separate groups are balanced (each\
    \ open brace is properly closed) and not nested within each other\n/// Ignore\
    \ any spaces in the input string.\n/// >>> separate_paren_groups(paren_string:\
    \ \"( ) (( )) (( )( ))\")\n/// [\"()\", \"(())\", \"(()())\"]\nfunc separate_paren_groups(paren_string:\
    \ String) -> [String] {\n    var idx = 0\n    var new_group = \"\"\n    var result\
    \ = [String]()\n    for char in paren_string {\n        if char == \"(\" {\n \
    \           idx += 1\n        } else if char == \")\" {\n            idx -= 1\n\
    \        }\n        new_group.append(char)\n        if idx == 0 {\n          \
    \  result.append(new_group)\n            new_group = \"\"\n        }\n    }\n\
    \    return result\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) ->\
    \ Bool {\n    if left.count != right.count {\n        return false\n    }\n  \
    \  for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(separate_paren_groups(paren_string:\
    \ \"(()()) ((())) () ((())()())\") == [\"(()())\", \"((()))\", \"()\", \"((())()())\"\
    ])\nassert(separate_paren_groups(paren_string: \"() (()) ((())) (((())))\") ==\
    \ [\"()\", \"(())\", \"((()))\", \"(((())))\"])\nassert(separate_paren_groups(paren_string:\
    \ \"(()(())((())))\") == [\"(()(())((())))\"])\nassert(separate_paren_groups(paren_string:\
    \ \"( ) (( )) (( )( ))\") == [\"()\", \"(())\", \"(()())\"])"
  status: Exception
  stderr: 'tmprjfpk363/tmprjfpk363.swift:40: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b14d422dc80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b14d3f24b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b14d3f24988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b14d3f237b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmprjfpk363                        0x00005597d4eda7e7 <unavailable> + 6119

    5    libc.so.6                          0x00002b14d4419460 __libc_start_main +
    245

    6    tmprjfpk363                        0x00005597d4eda379 <unavailable> + 4985

    '
  stdout: ''
  timestamp: 1659980041
- exit_code: 1
  program: "\n/// Input to this function is a string containing multiple groups of\
    \ nested parentheses. Your goal is to\n/// separate those group into separate\
    \ strings and return the array of those.\n/// Separate groups are balanced (each\
    \ open brace is properly closed) and not nested within each other\n/// Ignore\
    \ any spaces in the input string.\n/// >>> separate_paren_groups(paren_string:\
    \ \"( ) (( )) (( )( ))\")\n/// [\"()\", \"(())\", \"(()())\"]\nfunc separate_paren_groups(paren_string:\
    \ String) -> [String] {\n  var result: [String] = []\n  var temp = \"\"\n  var\
    \ stack: [Character] = []\n  let input = paren_string.components(separatedBy:\
    \ CharacterSet.whitespaces).joined()\n  for i in input {\n    if i == \"(\" {\n\
    \      stack.append(i)\n    } else if i == \")\" {\n      if stack.count > 0 {\n\
    \        temp += String(stack.popLast()!)\n        temp += String(i)\n      }\n\
    \      if stack.count == 0 {\n        result.append(temp)\n        temp = \"\"\
    \n      }\n    }\n  }\n  return result\n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(separate_paren_groups(paren_string: \"(()()) ((())) () ((())()())\") ==\
    \ [\"(()())\", \"((()))\", \"()\", \"((())()())\"])\nassert(separate_paren_groups(paren_string:\
    \ \"() (()) ((())) (((())))\") == [\"()\", \"(())\", \"((()))\", \"(((())))\"\
    ])\nassert(separate_paren_groups(paren_string: \"(()(())((())))\") == [\"(()(())((())))\"\
    ])\nassert(separate_paren_groups(paren_string: \"( ) (( )) (( )( ))\") == [\"\
    ()\", \"(())\", \"(()())\"])"
  status: SyntaxError
  stderr: "/tmp/tmps99v8p2q.swift:12:52: error: cannot find 'CharacterSet' in scope\n\
    \  let input = paren_string.components(separatedBy: CharacterSet.whitespaces).joined()\n\
    \                                                   ^~~~~~~~~~~~\n/tmp/tmps99v8p2q.swift:12:28:\
    \ error: value of type 'String' has no member 'components'\n  let input = paren_string.components(separatedBy:\
    \ CharacterSet.whitespaces).joined()\n              ~~~~~~~~~~~~ ^~~~~~~~~~\n"
  stdout: ''
  timestamp: 1659980041
- exit_code: 0
  program: "\n/// Input to this function is a string containing multiple groups of\
    \ nested parentheses. Your goal is to\n/// separate those group into separate\
    \ strings and return the array of those.\n/// Separate groups are balanced (each\
    \ open brace is properly closed) and not nested within each other\n/// Ignore\
    \ any spaces in the input string.\n/// >>> separate_paren_groups(paren_string:\
    \ \"( ) (( )) (( )( ))\")\n/// [\"()\", \"(())\", \"(()())\"]\nfunc separate_paren_groups(paren_string:\
    \ String) -> [String] {\n    var paren_groups = [String]()\n    var current_paren_group\
    \ = \"\"\n    var depth = 0\n    for character in paren_string {\n        if character\
    \ == \"(\" {\n            depth += 1\n            current_paren_group += String(character)\n\
    \        } else if character == \")\" {\n            depth -= 1\n            current_paren_group\
    \ += String(character)\n            if depth == 0 {\n                paren_groups.append(current_paren_group)\n\
    \                current_paren_group = \"\"\n            }\n        }\n    }\n\
    \    return paren_groups\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(separate_paren_groups(paren_string:\
    \ \"(()()) ((())) () ((())()())\") == [\"(()())\", \"((()))\", \"()\", \"((())()())\"\
    ])\nassert(separate_paren_groups(paren_string: \"() (()) ((())) (((())))\") ==\
    \ [\"()\", \"(())\", \"((()))\", \"(((())))\"])\nassert(separate_paren_groups(paren_string:\
    \ \"(()(())((())))\") == [\"(()(())((())))\"])\nassert(separate_paren_groups(paren_string:\
    \ \"( ) (( )) (( )( ))\") == [\"()\", \"(())\", \"(()())\"])"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659980041
- exit_code: -4
  program: "\n/// Input to this function is a string containing multiple groups of\
    \ nested parentheses. Your goal is to\n/// separate those group into separate\
    \ strings and return the array of those.\n/// Separate groups are balanced (each\
    \ open brace is properly closed) and not nested within each other\n/// Ignore\
    \ any spaces in the input string.\n/// >>> separate_paren_groups(paren_string:\
    \ \"( ) (( )) (( )( ))\")\n/// [\"()\", \"(())\", \"(()())\"]\nfunc separate_paren_groups(paren_string:\
    \ String) -> [String] {\n    var result = [String]()\n    var counter = 0\n  \
    \  var current_group = \"\"\n    for char in paren_string {\n        if char ==\
    \ \"(\" {\n            counter += 1\n        } else if char == \")\" {\n     \
    \       counter -= 1\n        }\n        if counter == 0 {\n            result.append(current_group)\n\
    \            current_group = \"\"\n        } else {\n            current_group.append(char)\n\
    \        }\n    }\n    return result\n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(separate_paren_groups(paren_string: \"(()()) ((())) () ((())()())\") ==\
    \ [\"(()())\", \"((()))\", \"()\", \"((())()())\"])\nassert(separate_paren_groups(paren_string:\
    \ \"() (()) ((())) (((())))\") == [\"()\", \"(())\", \"((()))\", \"(((())))\"\
    ])\nassert(separate_paren_groups(paren_string: \"(()(())((())))\") == [\"(()(())((())))\"\
    ])\nassert(separate_paren_groups(paren_string: \"( ) (( )) (( )( ))\") == [\"\
    ()\", \"(())\", \"(()())\"])"
  status: Exception
  stderr: 'tmpmijjgu_j/tmpmijjgu_j.swift:41: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002abbae7d5c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002abbae4ccb6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002abbae4cc988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002abbae4cb7b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpmijjgu_j                        0x0000563ae8c6e7e7 <unavailable> + 6119

    5    libc.so.6                          0x00002abbae9c1460 __libc_start_main +
    245

    6    tmpmijjgu_j                        0x0000563ae8c6e379 <unavailable> + 4985

    '
  stdout: ''
  timestamp: 1659980041
- exit_code: 0
  program: "\n/// Input to this function is a string containing multiple groups of\
    \ nested parentheses. Your goal is to\n/// separate those group into separate\
    \ strings and return the array of those.\n/// Separate groups are balanced (each\
    \ open brace is properly closed) and not nested within each other\n/// Ignore\
    \ any spaces in the input string.\n/// >>> separate_paren_groups(paren_string:\
    \ \"( ) (( )) (( )( ))\")\n/// [\"()\", \"(())\", \"(()())\"]\nfunc separate_paren_groups(paren_string:\
    \ String) -> [String] {\n  var result: [String] = []\n  var temp = \"\"\n  var\
    \ count = 0\n  for char in paren_string {\n    if char == \"(\" {\n      temp\
    \ += \"(\"\n      count += 1\n    } else if char == \")\" {\n      temp += \"\
    )\"\n      count -= 1\n      if count == 0 {\n        result.append(temp)\n  \
    \      temp = \"\"\n      }\n    }\n  }\n  return result\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(separate_paren_groups(paren_string: \"(()()) ((())) ()\
    \ ((())()())\") == [\"(()())\", \"((()))\", \"()\", \"((())()())\"])\nassert(separate_paren_groups(paren_string:\
    \ \"() (()) ((())) (((())))\") == [\"()\", \"(())\", \"((()))\", \"(((())))\"\
    ])\nassert(separate_paren_groups(paren_string: \"(()(())((())))\") == [\"(()(())((())))\"\
    ])\nassert(separate_paren_groups(paren_string: \"( ) (( )) (( )( ))\") == [\"\
    ()\", \"(())\", \"(()())\"])"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659980041
- exit_code: -4
  program: "\n/// Input to this function is a string containing multiple groups of\
    \ nested parentheses. Your goal is to\n/// separate those group into separate\
    \ strings and return the array of those.\n/// Separate groups are balanced (each\
    \ open brace is properly closed) and not nested within each other\n/// Ignore\
    \ any spaces in the input string.\n/// >>> separate_paren_groups(paren_string:\
    \ \"( ) (( )) (( )( ))\")\n/// [\"()\", \"(())\", \"(()())\"]\nfunc separate_paren_groups(paren_string:\
    \ String) -> [String] {\n    \n    // Your code here\n    return []\n}\n\n\nfunc\
    \ ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count !=\
    \ right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(separate_paren_groups(paren_string: \"(()()) ((()))\
    \ () ((())()())\") == [\"(()())\", \"((()))\", \"()\", \"((())()())\"])\nassert(separate_paren_groups(paren_string:\
    \ \"() (()) ((())) (((())))\") == [\"()\", \"(())\", \"((()))\", \"(((())))\"\
    ])\nassert(separate_paren_groups(paren_string: \"(()(())((())))\") == [\"(()(())((())))\"\
    ])\nassert(separate_paren_groups(paren_string: \"( ) (( )) (( )( ))\") == [\"\
    ()\", \"(())\", \"(()())\"])"
  status: Exception
  stderr: 'tmp_x9f23pg/tmp_x9f23pg.swift:27: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b7bb39b0c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b7bb36a7b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b7bb36a7988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b7bb36a67b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmp_x9f23pg                        0x0000563ad48cb537 <unavailable> + 5431

    5    libc.so.6                          0x00002b7bb3b9c460 __libc_start_main +
    245

    6    tmp_x9f23pg                        0x0000563ad48cb0c9 <unavailable> + 4297

    '
  stdout: ''
  timestamp: 1659980041
- exit_code: 1
  program: "\n/// Input to this function is a string containing multiple groups of\
    \ nested parentheses. Your goal is to\n/// separate those group into separate\
    \ strings and return the array of those.\n/// Separate groups are balanced (each\
    \ open brace is properly closed) and not nested within each other\n/// Ignore\
    \ any spaces in the input string.\n/// >>> separate_paren_groups(paren_string:\
    \ \"( ) (( )) (( )( ))\")\n/// [\"()\", \"(())\", \"(()())\"]\nfunc separate_paren_groups(paren_string:\
    \ String) -> [String] {\n    // separate into groups that can be passed to the\
    \ `is_balanced` function\n    var separate_groups = [String]()\n    var current_group\
    \ = \"\"\n    var open_parens = 0\n    var close_parens = 0\n    for character\
    \ in paren_string {\n        if character == \"(\" {\n            open_parens\
    \ += 1\n        } else if character == \")\" {\n            close_parens += 1\n\
    \        }\n        current_group.append(character)\n        if open_parens ==\
    \ close_parens {\n            separate_groups.append(current_group)\n        \
    \    current_group = \"\"\n            open_parens = 0\n            close_parens\
    \ = 0\n        }\n    }\n    var result = [String]()\n    for group in separate_groups\
    \ {\n        if is_balanced(group) {\n            result.append(group)\n     \
    \   }\n    }\n    return result\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int,\
    \ Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n\
    \    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n          \
    \  return false\n        }\n    }\n    return true\n}\n            \nassert(separate_paren_groups(paren_string:\
    \ \"(()()) ((())) () ((())()())\") == [\"(()())\", \"((()))\", \"()\", \"((())()())\"\
    ])\nassert(separate_paren_groups(paren_string: \"() (()) ((())) (((())))\") ==\
    \ [\"()\", \"(())\", \"((()))\", \"(((())))\"])\nassert(separate_paren_groups(paren_string:\
    \ \"(()(())((())))\") == [\"(()(())((())))\"])\nassert(separate_paren_groups(paren_string:\
    \ \"( ) (( )) (( )( ))\") == [\"()\", \"(())\", \"(()())\"])"
  status: SyntaxError
  stderr: "/tmp/tmpt3et3xc2.swift:30:12: error: cannot find 'is_balanced' in scope\n\
    \        if is_balanced(group) {\n           ^~~~~~~~~~~\n"
  stdout: ''
  timestamp: 1659980041
- exit_code: 1
  program: "\n/// Input to this function is a string containing multiple groups of\
    \ nested parentheses. Your goal is to\n/// separate those group into separate\
    \ strings and return the array of those.\n/// Separate groups are balanced (each\
    \ open brace is properly closed) and not nested within each other\n/// Ignore\
    \ any spaces in the input string.\n/// >>> separate_paren_groups(paren_string:\
    \ \"( ) (( )) (( )( ))\")\n/// [\"()\", \"(())\", \"(()())\"]\nfunc separate_paren_groups(paren_string:\
    \ String) -> [String] {\n    // Solution here\n    var result: [String] = []\n\
    \    let input: String = paren_string.replacingOccurrences(of: \" \", with: \"\
    \")\n    var openParens: Int = 0\n    var closeParens: Int = 0\n    var temp:\
    \ String = \"\"\n    var stack: [Character] = []\n    for character in input {\n\
    \        if character == \"(\" {\n            openParens += 1\n            stack.append(character)\n\
    \        } else if character == \")\" {\n            closeParens += 1\n      \
    \      stack.append(character)\n        }\n        if closeParens > openParens\
    \ {\n            return []\n        }\n        if closeParens == openParens {\n\
    \            temp = \"\"\n            while stack.count > 0 {\n              \
    \  temp += String(stack.popLast()!)\n            }\n            result.append(temp)\n\
    \            openParens = 0\n            closeParens = 0\n        }\n    }\n \
    \   return result\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) ->\
    \ Bool {\n    if left.count != right.count {\n        return false\n    }\n  \
    \  for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(separate_paren_groups(paren_string:\
    \ \"(()()) ((())) () ((())()())\") == [\"(()())\", \"((()))\", \"()\", \"((())()())\"\
    ])\nassert(separate_paren_groups(paren_string: \"() (()) ((())) (((())))\") ==\
    \ [\"()\", \"(())\", \"((()))\", \"(((())))\"])\nassert(separate_paren_groups(paren_string:\
    \ \"(()(())((())))\") == [\"(()(())((())))\"])\nassert(separate_paren_groups(paren_string:\
    \ \"( ) (( )) (( )( ))\") == [\"()\", \"(())\", \"(()())\"])"
  status: SyntaxError
  stderr: "/tmp/tmpm_c8e1th.swift:11:38: error: value of type 'String' has no member\
    \ 'replacingOccurrences'\n    let input: String = paren_string.replacingOccurrences(of:\
    \ \" \", with: \"\")\n                        ~~~~~~~~~~~~ ^~~~~~~~~~~~~~~~~~~~\n"
  stdout: ''
  timestamp: 1659980041
- exit_code: -4
  program: "\n/// Input to this function is a string containing multiple groups of\
    \ nested parentheses. Your goal is to\n/// separate those group into separate\
    \ strings and return the array of those.\n/// Separate groups are balanced (each\
    \ open brace is properly closed) and not nested within each other\n/// Ignore\
    \ any spaces in the input string.\n/// >>> separate_paren_groups(paren_string:\
    \ \"( ) (( )) (( )( ))\")\n/// [\"()\", \"(())\", \"(()())\"]\nfunc separate_paren_groups(paren_string:\
    \ String) -> [String] {\n  return [\"()\", \"(())\", \"(()())\"]\n}\n\n\nfunc\
    \ ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count !=\
    \ right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(separate_paren_groups(paren_string: \"(()()) ((()))\
    \ () ((())()())\") == [\"(()())\", \"((()))\", \"()\", \"((())()())\"])\nassert(separate_paren_groups(paren_string:\
    \ \"() (()) ((())) (((())))\") == [\"()\", \"(())\", \"((()))\", \"(((())))\"\
    ])\nassert(separate_paren_groups(paren_string: \"(()(())((())))\") == [\"(()(())((())))\"\
    ])\nassert(separate_paren_groups(paren_string: \"( ) (( )) (( )( ))\") == [\"\
    ()\", \"(())\", \"(()())\"])"
  status: Exception
  stderr: 'tmpr3hk085w/tmpr3hk085w.swift:25: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b3ff5a59c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b3ff5750b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b3ff5750988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b3ff574f7b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpr3hk085w                        0x000055e1b496e537 <unavailable> + 5431

    5    libc.so.6                          0x00002b3ff5c45460 __libc_start_main +
    245

    6    tmpr3hk085w                        0x000055e1b496e0c9 <unavailable> + 4297

    '
  stdout: ''
  timestamp: 1659980041
- exit_code: 1
  program: "\n/// Input to this function is a string containing multiple groups of\
    \ nested parentheses. Your goal is to\n/// separate those group into separate\
    \ strings and return the array of those.\n/// Separate groups are balanced (each\
    \ open brace is properly closed) and not nested within each other\n/// Ignore\
    \ any spaces in the input string.\n/// >>> separate_paren_groups(paren_string:\
    \ \"( ) (( )) (( )( ))\")\n/// [\"()\", \"(())\", \"(()())\"]\nfunc separate_paren_groups(paren_string:\
    \ String) -> [String] {\n    \n    var stringArray = [String]()\n    var balance\
    \ = 0\n    var index = 0\n    var start = 0\n    var end = 0\n    \n    for character\
    \ in paren_string {\n        switch character {\n        case \"(\":\n       \
    \     balance += 1\n        case \")\":\n            balance -= 1\n        default:\n\
    \            break\n        }\n        \n        if balance == 0 {\n         \
    \   end = index\n            stringArray.append(paren_string[paren_string.index(paren_string.startIndex,\
    \ offsetBy: start)...paren_string.index(paren_string.startIndex, offsetBy: end)])\n\
    \            start = index + 1\n        }\n        \n        index += 1\n    }\n\
    \    \n    return stringArray\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int,\
    \ Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n\
    \    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n          \
    \  return false\n        }\n    }\n    return true\n}\n            \nassert(separate_paren_groups(paren_string:\
    \ \"(()()) ((())) () ((())()())\") == [\"(()())\", \"((()))\", \"()\", \"((())()())\"\
    ])\nassert(separate_paren_groups(paren_string: \"() (()) ((())) (((())))\") ==\
    \ [\"()\", \"(())\", \"((()))\", \"(((())))\"])\nassert(separate_paren_groups(paren_string:\
    \ \"(()(())((())))\") == [\"(()(())((())))\"])\nassert(separate_paren_groups(paren_string:\
    \ \"( ) (( )) (( )( ))\") == [\"()\", \"(())\", \"(()())\"])"
  status: SyntaxError
  stderr: "/tmp/tmpi4dhz8n8.swift:28:44: error: subscript 'subscript(_:)' requires\
    \ the types 'String.Index' and 'Int' be equivalent\n            stringArray.append(paren_string[paren_string.index(paren_string.startIndex,\
    \ offsetBy: start)...paren_string.index(paren_string.startIndex, offsetBy: end)])\n\
    \                                           ^\nSwift.String:5:12: note: where\
    \ 'R.Bound' = 'String.Index'\n    public subscript<R>(bounds: R) -> String where\
    \ R : RangeExpression, R.Bound == Int { get }\n           ^\n"
  stdout: ''
  timestamp: 1659980041
- exit_code: -4
  program: "\n/// Input to this function is a string containing multiple groups of\
    \ nested parentheses. Your goal is to\n/// separate those group into separate\
    \ strings and return the array of those.\n/// Separate groups are balanced (each\
    \ open brace is properly closed) and not nested within each other\n/// Ignore\
    \ any spaces in the input string.\n/// >>> separate_paren_groups(paren_string:\
    \ \"( ) (( )) (( )( ))\")\n/// [\"()\", \"(())\", \"(()())\"]\nfunc separate_paren_groups(paren_string:\
    \ String) -> [String] {\n    var newParenString = \"\"\n    var outputArray =\
    \ [String]()\n    var parenNumber = 0\n    var parenLevel = 0\n    var startIndex\
    \ = 0\n    var prevCount = 0\n    var i = 0\n    var charArray = Array(paren_string)\n\
    \    while i < charArray.count {\n        let character = charArray[i]\n     \
    \   if character == \"(\" {\n            parenNumber += 1\n            parenLevel\
    \ += 1\n            if parenLevel == 1 {\n                startIndex = i\n   \
    \         }\n        } else if character == \")\" {\n            parenNumber -=\
    \ 1\n            parenLevel -= 1\n            if parenLevel == 0 {\n         \
    \       outputArray.append(String(charArray[startIndex...i]))\n            }\n\
    \        }\n        i += 1\n    }\n    return outputArray\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(separate_paren_groups(paren_string: \"(()()) ((())) ()\
    \ ((())()())\") == [\"(()())\", \"((()))\", \"()\", \"((())()())\"])\nassert(separate_paren_groups(paren_string:\
    \ \"() (()) ((())) (((())))\") == [\"()\", \"(())\", \"((()))\", \"(((())))\"\
    ])\nassert(separate_paren_groups(paren_string: \"(()(())((())))\") == [\"(()(())((())))\"\
    ])\nassert(separate_paren_groups(paren_string: \"( ) (( )) (( )( ))\") == [\"\
    ()\", \"(())\", \"(()())\"])"
  status: Exception
  stderr: 'tmpxuci67r9/tmpxuci67r9.swift:53: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b43a7464c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b43a715bb6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b43a715b988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b43a715a7b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpxuci67r9                        0x000055a8816a9f92 <unavailable> + 8082

    5    libc.so.6                          0x00002b43a7650460 __libc_start_main +
    245

    6    tmpxuci67r9                        0x000055a8816a9679 <unavailable> + 5753

    '
  stdout: ''
  timestamp: 1659980041
- exit_code: -4
  program: "\n/// Input to this function is a string containing multiple groups of\
    \ nested parentheses. Your goal is to\n/// separate those group into separate\
    \ strings and return the array of those.\n/// Separate groups are balanced (each\
    \ open brace is properly closed) and not nested within each other\n/// Ignore\
    \ any spaces in the input string.\n/// >>> separate_paren_groups(paren_string:\
    \ \"( ) (( )) (( )( ))\")\n/// [\"()\", \"(())\", \"(()())\"]\nfunc separate_paren_groups(paren_string:\
    \ String) -> [String] {\n    var paren_list: [String] = []\n    var paren_buffer:\
    \ String = \"\"\n    var open: Int = 0\n    var close: Int = 0\n    var i: Int\
    \ = 0\n    for paren in paren_string {\n        if paren == \"(\" {\n        \
    \    open += 1\n        } else if paren == \")\" {\n            close += 1\n \
    \       }\n        paren_buffer.append(paren)\n        if open == close {\n  \
    \          paren_list.append(paren_buffer)\n            paren_buffer = \"\"\n\
    \            open = 0\n            close = 0\n        }\n        i += 1\n    }\n\
    \    return paren_list\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(separate_paren_groups(paren_string:\
    \ \"(()()) ((())) () ((())()())\") == [\"(()())\", \"((()))\", \"()\", \"((())()())\"\
    ])\nassert(separate_paren_groups(paren_string: \"() (()) ((())) (((())))\") ==\
    \ [\"()\", \"(())\", \"((()))\", \"(((())))\"])\nassert(separate_paren_groups(paren_string:\
    \ \"(()(())((())))\") == [\"(()(())((())))\"])\nassert(separate_paren_groups(paren_string:\
    \ \"( ) (( )) (( )( ))\") == [\"()\", \"(())\", \"(()())\"])"
  status: Exception
  stderr: 'tmplj_59gxg/tmplj_59gxg.swift:45: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b9f899d4c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b9f896cbb6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b9f896cb988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b9f896ca7b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmplj_59gxg                        0x000055f96597f787 <unavailable> + 6023

    5    libc.so.6                          0x00002b9f89bc0460 __libc_start_main +
    245

    6    tmplj_59gxg                        0x000055f96597f319 <unavailable> + 4889

    '
  stdout: ''
  timestamp: 1659980041
- exit_code: 1
  program: "\n/// Input to this function is a string containing multiple groups of\
    \ nested parentheses. Your goal is to\n/// separate those group into separate\
    \ strings and return the array of those.\n/// Separate groups are balanced (each\
    \ open brace is properly closed) and not nested within each other\n/// Ignore\
    \ any spaces in the input string.\n/// >>> separate_paren_groups(paren_string:\
    \ \"( ) (( )) (( )( ))\")\n/// [\"()\", \"(())\", \"(()())\"]\nfunc separate_paren_groups(paren_string:\
    \ String) -> [String] {\n    guard paren_string.count > 0 else { return [String]()\
    \ }\n    var parens = [String]()\n    var working_parens = [String]()\n    var\
    \ open_parens = 0\n    var start_index = 0\n    for (index, paren) in paren_string.enumerated()\
    \ {\n        if paren == \"(\" {\n            if open_parens == 0 {\n        \
    \        start_index = index\n            }\n            open_parens += 1\n  \
    \      } else if paren == \")\" {\n            open_parens -= 1\n            if\
    \ open_parens == 0 {\n                parens.append(paren_string[paren_string.index(paren_string.startIndex,\
    \ offsetBy: start_index)..<paren_string.index(paren_string.startIndex, offsetBy:\
    \ index + 1)])\n            }\n        }\n    }\n    return parens\n}\n\n\nfunc\
    \ ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count !=\
    \ right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(separate_paren_groups(paren_string: \"(()()) ((()))\
    \ () ((())()())\") == [\"(()())\", \"((()))\", \"()\", \"((())()())\"])\nassert(separate_paren_groups(paren_string:\
    \ \"() (()) ((())) (((())))\") == [\"()\", \"(())\", \"((()))\", \"(((())))\"\
    ])\nassert(separate_paren_groups(paren_string: \"(()(())((())))\") == [\"(()(())((())))\"\
    ])\nassert(separate_paren_groups(paren_string: \"( ) (( )) (( )( ))\") == [\"\
    ()\", \"(())\", \"(()())\"])"
  status: SyntaxError
  stderr: "/tmp/tmpljxuh7lv.swift:23:43: error: subscript 'subscript(_:)' requires\
    \ the types 'String.Index' and 'Int' be equivalent\n                parens.append(paren_string[paren_string.index(paren_string.startIndex,\
    \ offsetBy: start_index)..<paren_string.index(paren_string.startIndex, offsetBy:\
    \ index + 1)])\n                                          ^\nSwift.String:5:12:\
    \ note: where 'R.Bound' = 'String.Index'\n    public subscript<R>(bounds: R) ->\
    \ String where R : RangeExpression, R.Bound == Int { get }\n           ^\n"
  stdout: ''
  timestamp: 1659980041
- exit_code: -4
  program: "\n/// Input to this function is a string containing multiple groups of\
    \ nested parentheses. Your goal is to\n/// separate those group into separate\
    \ strings and return the array of those.\n/// Separate groups are balanced (each\
    \ open brace is properly closed) and not nested within each other\n/// Ignore\
    \ any spaces in the input string.\n/// >>> separate_paren_groups(paren_string:\
    \ \"( ) (( )) (( )( ))\")\n/// [\"()\", \"(())\", \"(()())\"]\nfunc separate_paren_groups(paren_string:\
    \ String) -> [String] {\n    \n    var results = [String]()\n    var temp = \"\
    \"\n    var count = 0\n    \n    for i in paren_string {\n        if i == \"(\"\
    \ {\n            count += 1\n        } else if i == \")\" {\n            count\
    \ -= 1\n        }\n        \n        if count == 0 {\n            results.append(temp)\n\
    \            temp = \"\"\n        } else {\n            temp.append(i)\n     \
    \   }\n    }\n    \n    return results\n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(separate_paren_groups(paren_string: \"(()()) ((())) () ((())()())\") ==\
    \ [\"(()())\", \"((()))\", \"()\", \"((())()())\"])\nassert(separate_paren_groups(paren_string:\
    \ \"() (()) ((())) (((())))\") == [\"()\", \"(())\", \"((()))\", \"(((())))\"\
    ])\nassert(separate_paren_groups(paren_string: \"(()(())((())))\") == [\"(()(())((())))\"\
    ])\nassert(separate_paren_groups(paren_string: \"( ) (( )) (( )( ))\") == [\"\
    ()\", \"(())\", \"(()())\"])"
  status: Exception
  stderr: 'tmp8oudn39l/tmp8oudn39l.swift:45: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b32e84d3c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b32e81cab6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b32e81ca988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b32e81c97b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmp8oudn39l                        0x000055623736e7e7 <unavailable> + 6119

    5    libc.so.6                          0x00002b32e86bf460 __libc_start_main +
    245

    6    tmp8oudn39l                        0x000055623736e379 <unavailable> + 4985

    '
  stdout: ''
  timestamp: 1659980041
- exit_code: -4
  program: "\n/// Input to this function is a string containing multiple groups of\
    \ nested parentheses. Your goal is to\n/// separate those group into separate\
    \ strings and return the array of those.\n/// Separate groups are balanced (each\
    \ open brace is properly closed) and not nested within each other\n/// Ignore\
    \ any spaces in the input string.\n/// >>> separate_paren_groups(paren_string:\
    \ \"( ) (( )) (( )( ))\")\n/// [\"()\", \"(())\", \"(()())\"]\nfunc separate_paren_groups(paren_string:\
    \ String) -> [String] {\n    var new_paren_strings: [String] = []\n    var current_paren_string\
    \ = \"\"\n    var open_paren_count = 0\n    var closed_paren_count = 0\n    for\
    \ character in paren_string {\n        if character == \"(\" {\n            open_paren_count\
    \ += 1\n        } else if character == \")\" {\n            closed_paren_count\
    \ += 1\n        }\n        if open_paren_count == closed_paren_count {\n     \
    \       new_paren_strings.append(current_paren_string)\n            current_paren_string\
    \ = \"\"\n            open_paren_count = 0\n            closed_paren_count = 0\n\
    \        } else {\n            current_paren_string.append(character)\n      \
    \  }\n    }\n    return new_paren_strings\n}\n\n\nfunc ==(left: [(Int, Int)],\
    \ right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n       \
    \ return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r\
    \ {\n            return false\n        }\n    }\n    return true\n}\n        \
    \    \nassert(separate_paren_groups(paren_string: \"(()()) ((())) () ((())()())\"\
    ) == [\"(()())\", \"((()))\", \"()\", \"((())()())\"])\nassert(separate_paren_groups(paren_string:\
    \ \"() (()) ((())) (((())))\") == [\"()\", \"(())\", \"((()))\", \"(((())))\"\
    ])\nassert(separate_paren_groups(paren_string: \"(()(())((())))\") == [\"(()(())((())))\"\
    ])\nassert(separate_paren_groups(paren_string: \"( ) (( )) (( )( ))\") == [\"\
    ()\", \"(())\", \"(()())\"])"
  status: Exception
  stderr: 'tmp32y8eunq/tmp32y8eunq.swift:44: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b1475dd0c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b1475ac7b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b1475ac7988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b1475ac67b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmp32y8eunq                        0x0000563452456787 <unavailable> + 6023

    5    libc.so.6                          0x00002b1475fbc460 __libc_start_main +
    245

    6    tmp32y8eunq                        0x0000563452456319 <unavailable> + 4889

    '
  stdout: ''
  timestamp: 1659980041
- exit_code: 1
  program: "\n/// Input to this function is a string containing multiple groups of\
    \ nested parentheses. Your goal is to\n/// separate those group into separate\
    \ strings and return the array of those.\n/// Separate groups are balanced (each\
    \ open brace is properly closed) and not nested within each other\n/// Ignore\
    \ any spaces in the input string.\n/// >>> separate_paren_groups(paren_string:\
    \ \"( ) (( )) (( )( ))\")\n/// [\"()\", \"(())\", \"(()())\"]\nfunc separate_paren_groups(paren_string:\
    \ String) -> [String] {\n    let characters = paren_string.characters\n    var\
    \ parenArray: [String] = []\n    var tempString: String = \"\"\n    var counter:\
    \ Int = 0\n    for c in characters {\n        if c == \"(\" {\n            tempString.append(c)\n\
    \            counter += 1\n        } else if c == \")\" {\n            tempString.append(c)\n\
    \            counter -= 1\n            if counter == 0 {\n                parenArray.append(tempString)\n\
    \                tempString = \"\"\n            }\n        }\n    }\n    return\
    \ parenArray\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool\
    \ {\n    if left.count != right.count {\n        return false\n    }\n    for\
    \ (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(separate_paren_groups(paren_string:\
    \ \"(()()) ((())) () ((())()())\") == [\"(()())\", \"((()))\", \"()\", \"((())()())\"\
    ])\nassert(separate_paren_groups(paren_string: \"() (()) ((())) (((())))\") ==\
    \ [\"()\", \"(())\", \"((()))\", \"(((())))\"])\nassert(separate_paren_groups(paren_string:\
    \ \"(()(())((())))\") == [\"(()(())((())))\"])\nassert(separate_paren_groups(paren_string:\
    \ \"( ) (( )) (( )( ))\") == [\"()\", \"(())\", \"(()())\"])"
  status: SyntaxError
  stderr: "/tmp/tmpy6keh11p.swift:9:35: error: 'characters' is unavailable: Please\
    \ use String directly\n    let characters = paren_string.characters\n        \
    \                          ^~~~~~~~~~\nSwift.String:5:16: note: 'characters' was\
    \ obsoleted in Swift 5.0\n    public var characters: String { get set }\n    \
    \           ^\n"
  stdout: ''
  timestamp: 1659980041
- exit_code: 1
  program: "\n/// Input to this function is a string containing multiple groups of\
    \ nested parentheses. Your goal is to\n/// separate those group into separate\
    \ strings and return the array of those.\n/// Separate groups are balanced (each\
    \ open brace is properly closed) and not nested within each other\n/// Ignore\
    \ any spaces in the input string.\n/// >>> separate_paren_groups(paren_string:\
    \ \"( ) (( )) (( )( ))\")\n/// [\"()\", \"(())\", \"(()())\"]\nfunc separate_paren_groups(paren_string:\
    \ String) -> [String] {\n    let chars = Array(paren_string)\n    var result =\
    \ [String]()\n    var count = 0\n    var index = 0\n    for char in chars {\n\
    \        if char == \"(\" {\n            count += 1\n        } else if char ==\
    \ \")\" {\n            count -= 1\n        }\n        if count == 0 {\n      \
    \      result.append(String(chars[0..<index + 1]))\n            chars.removeSubrange(0..<index\
    \ + 1)\n            index = 0\n        } else {\n            index += 1\n    \
    \    }\n    }\n    return result\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int,\
    \ Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n\
    \    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n          \
    \  return false\n        }\n    }\n    return true\n}\n            \nassert(separate_paren_groups(paren_string:\
    \ \"(()()) ((())) () ((())()())\") == [\"(()())\", \"((()))\", \"()\", \"((())()())\"\
    ])\nassert(separate_paren_groups(paren_string: \"() (()) ((())) (((())))\") ==\
    \ [\"()\", \"(())\", \"((()))\", \"(((())))\"])\nassert(separate_paren_groups(paren_string:\
    \ \"(()(())((())))\") == [\"(()(())((())))\"])\nassert(separate_paren_groups(paren_string:\
    \ \"( ) (( )) (( )( ))\") == [\"()\", \"(())\", \"(()())\"])"
  status: SyntaxError
  stderr: "/tmp/tmpj8vyv48n.swift:21:19: error: cannot use mutating member on immutable\
    \ value: 'chars' is a 'let' constant\n            chars.removeSubrange(0..<index\
    \ + 1)\n            ~~~~~ ^\n/tmp/tmpj8vyv48n.swift:9:5: note: change 'let' to\
    \ 'var' to make it mutable\n    let chars = Array(paren_string)\n    ^~~\n   \
    \ var\n"
  stdout: ''
  timestamp: 1659980041
- exit_code: -4
  program: "\n/// Input to this function is a string containing multiple groups of\
    \ nested parentheses. Your goal is to\n/// separate those group into separate\
    \ strings and return the array of those.\n/// Separate groups are balanced (each\
    \ open brace is properly closed) and not nested within each other\n/// Ignore\
    \ any spaces in the input string.\n/// >>> separate_paren_groups(paren_string:\
    \ \"( ) (( )) (( )( ))\")\n/// [\"()\", \"(())\", \"(()())\"]\nfunc separate_paren_groups(paren_string:\
    \ String) -> [String] {\n    var open = 0\n    var close = 0\n    var new_string\
    \ = \"\"\n    var array = [String]()\n    for c in paren_string {\n        if\
    \ c == \"(\" {\n            open += 1\n        } else if c == \")\" {\n      \
    \      close += 1\n        }\n        if open != 0 && close != 0 && open == close\
    \ {\n            array.append(new_string)\n            new_string = \"\"\n   \
    \         open = 0\n            close = 0\n        } else {\n            new_string\
    \ += String(c)\n        }\n    }\n    return array\n}\n\n\nfunc ==(left: [(Int,\
    \ Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n\
    \        return false\n    }\n    for (l, r) in zip(left, right) {\n        if\
    \ l != r {\n            return false\n        }\n    }\n    return true\n}\n \
    \           \nassert(separate_paren_groups(paren_string: \"(()()) ((())) () ((())()())\"\
    ) == [\"(()())\", \"((()))\", \"()\", \"((())()())\"])\nassert(separate_paren_groups(paren_string:\
    \ \"() (()) ((())) (((())))\") == [\"()\", \"(())\", \"((()))\", \"(((())))\"\
    ])\nassert(separate_paren_groups(paren_string: \"(()(())((())))\") == [\"(()(())((())))\"\
    ])\nassert(separate_paren_groups(paren_string: \"( ) (( )) (( )( ))\") == [\"\
    ()\", \"(())\", \"(()())\"])"
  status: Exception
  stderr: 'tmpvi83f0c3/tmpvi83f0c3.swift:44: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002abcd0f78c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002abcd0c6fb6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002abcd0c6f988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002abcd0c6e7b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpvi83f0c3                        0x000056151fe19837 <unavailable> + 6199

    5    libc.so.6                          0x00002abcd1164460 __libc_start_main +
    245

    6    tmpvi83f0c3                        0x000056151fe193c9 <unavailable> + 5065

    '
  stdout: ''
  timestamp: 1659980042
- exit_code: 1
  program: "\n/// Input to this function is a string containing multiple groups of\
    \ nested parentheses. Your goal is to\n/// separate those group into separate\
    \ strings and return the array of those.\n/// Separate groups are balanced (each\
    \ open brace is properly closed) and not nested within each other\n/// Ignore\
    \ any spaces in the input string.\n/// >>> separate_paren_groups(paren_string:\
    \ \"( ) (( )) (( )( ))\")\n/// [\"()\", \"(())\", \"(()())\"]\nfunc separate_paren_groups(paren_string:\
    \ String) -> [String] {\n    var input = paren_string\n    var output: [String]\
    \ = []\n    var temp: String = \"\"\n    while input.characters.count > 0 {\n\
    \        let index = input.characters.index(input.startIndex, offsetBy: 1)\n \
    \       temp += String(input.characters.prefix(upTo: index))\n        input =\
    \ String(input.characters.suffix(from: index))\n        if temp.characters.last\
    \ == \")\" {\n            output.append(temp)\n            temp = \"\"\n     \
    \   }\n    }\n    return output\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int,\
    \ Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n\
    \    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n          \
    \  return false\n        }\n    }\n    return true\n}\n            \nassert(separate_paren_groups(paren_string:\
    \ \"(()()) ((())) () ((())()())\") == [\"(()())\", \"((()))\", \"()\", \"((())()())\"\
    ])\nassert(separate_paren_groups(paren_string: \"() (()) ((())) (((())))\") ==\
    \ [\"()\", \"(())\", \"((()))\", \"(((())))\"])\nassert(separate_paren_groups(paren_string:\
    \ \"(()(())((())))\") == [\"(()(())((())))\"])\nassert(separate_paren_groups(paren_string:\
    \ \"( ) (( )) (( )( ))\") == [\"()\", \"(())\", \"(()())\"])"
  status: SyntaxError
  stderr: "/tmp/tmpdm60ceuj.swift:12:17: error: 'characters' is unavailable: Please\
    \ use String directly\n    while input.characters.count > 0 {\n              \
    \  ^~~~~~~~~~\nSwift.String:5:16: note: 'characters' was obsoleted in Swift 5.0\n\
    \    public var characters: String { get set }\n               ^\n/tmp/tmpdm60ceuj.swift:13:27:\
    \ error: 'characters' is unavailable: Please use String directly\n        let\
    \ index = input.characters.index(input.startIndex, offsetBy: 1)\n            \
    \              ^~~~~~~~~~\nSwift.String:5:16: note: 'characters' was obsoleted\
    \ in Swift 5.0\n    public var characters: String { get set }\n              \
    \ ^\n/tmp/tmpdm60ceuj.swift:14:30: error: 'characters' is unavailable: Please\
    \ use String directly\n        temp += String(input.characters.prefix(upTo: index))\n\
    \                             ^~~~~~~~~~\nSwift.String:5:16: note: 'characters'\
    \ was obsoleted in Swift 5.0\n    public var characters: String { get set }\n\
    \               ^\n/tmp/tmpdm60ceuj.swift:15:30: error: 'characters' is unavailable:\
    \ Please use String directly\n        input = String(input.characters.suffix(from:\
    \ index))\n                             ^~~~~~~~~~\nSwift.String:5:16: note: 'characters'\
    \ was obsoleted in Swift 5.0\n    public var characters: String { get set }\n\
    \               ^\n/tmp/tmpdm60ceuj.swift:16:17: error: 'characters' is unavailable:\
    \ Please use String directly\n        if temp.characters.last == \")\" {\n   \
    \             ^~~~~~~~~~\nSwift.String:5:16: note: 'characters' was obsoleted\
    \ in Swift 5.0\n    public var characters: String { get set }\n              \
    \ ^\n"
  stdout: ''
  timestamp: 1659980041
- exit_code: 1
  program: "\n/// Input to this function is a string containing multiple groups of\
    \ nested parentheses. Your goal is to\n/// separate those group into separate\
    \ strings and return the array of those.\n/// Separate groups are balanced (each\
    \ open brace is properly closed) and not nested within each other\n/// Ignore\
    \ any spaces in the input string.\n/// >>> separate_paren_groups(paren_string:\
    \ \"( ) (( )) (( )( ))\")\n/// [\"()\", \"(())\", \"(()())\"]\nfunc separate_paren_groups(paren_string:\
    \ String) -> [String] {\n    var newArray = [String]()\n    var stack = Stack<Character>()\n\
    \    var newString = \"\"\n    let parenArray = Array(paren_string)\n    for paren\
    \ in parenArray {\n        if paren == \" \" {\n            continue\n       \
    \ }\n        else if paren == \"(\" {\n            stack.push(paren)\n       \
    \ }\n        else if paren == \")\" {\n            stack.pop()\n            if\
    \ stack.isEmpty() {\n                newArray.append(newString)\n            \
    \    newString = \"\"\n            }\n            else {\n                newString\
    \ += \")\"\n            }\n        }\n        else {\n            newString +=\
    \ \"(\"\n        }\n    }\n    return newArray\n}\n\n\nfunc ==(left: [(Int, Int)],\
    \ right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n       \
    \ return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r\
    \ {\n            return false\n        }\n    }\n    return true\n}\n        \
    \    \nassert(separate_paren_groups(paren_string: \"(()()) ((())) () ((())()())\"\
    ) == [\"(()())\", \"((()))\", \"()\", \"((())()())\"])\nassert(separate_paren_groups(paren_string:\
    \ \"() (()) ((())) (((())))\") == [\"()\", \"(())\", \"((()))\", \"(((())))\"\
    ])\nassert(separate_paren_groups(paren_string: \"(()(())((())))\") == [\"(()(())((())))\"\
    ])\nassert(separate_paren_groups(paren_string: \"( ) (( )) (( )( ))\") == [\"\
    ()\", \"(())\", \"(()())\"])"
  status: SyntaxError
  stderr: "/tmp/tmpkow7iqav.swift:10:17: error: cannot find 'Stack' in scope\n   \
    \ var stack = Stack<Character>()\n                ^~~~~\n"
  stdout: ''
  timestamp: 1659980041
- exit_code: -4
  program: "\n/// Input to this function is a string containing multiple groups of\
    \ nested parentheses. Your goal is to\n/// separate those group into separate\
    \ strings and return the array of those.\n/// Separate groups are balanced (each\
    \ open brace is properly closed) and not nested within each other\n/// Ignore\
    \ any spaces in the input string.\n/// >>> separate_paren_groups(paren_string:\
    \ \"( ) (( )) (( )( ))\")\n/// [\"()\", \"(())\", \"(()())\"]\nfunc separate_paren_groups(paren_string:\
    \ String) -> [String] {\n    var result: [String] = []\n    var curr_paren_string\
    \ = \"\"\n    var open_paren_count = 0\n    var close_paren_count = 0\n    for\
    \ char in paren_string {\n        if char == \"(\" {\n            open_paren_count\
    \ += 1\n        } else if char == \")\" {\n            close_paren_count += 1\n\
    \        }\n        if open_paren_count == close_paren_count {\n            if\
    \ open_paren_count != 0 {\n                result.append(curr_paren_string)\n\
    \                curr_paren_string = \"\"\n                open_paren_count =\
    \ 0\n                close_paren_count = 0\n            }\n        } else {\n\
    \            curr_paren_string.append(char)\n        }\n    }\n    return result\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(separate_paren_groups(paren_string: \"(()()) ((()))\
    \ () ((())()())\") == [\"(()())\", \"((()))\", \"()\", \"((())()())\"])\nassert(separate_paren_groups(paren_string:\
    \ \"() (()) ((())) (((())))\") == [\"()\", \"(())\", \"((()))\", \"(((())))\"\
    ])\nassert(separate_paren_groups(paren_string: \"(()(())((())))\") == [\"(()(())((())))\"\
    ])\nassert(separate_paren_groups(paren_string: \"( ) (( )) (( )( ))\") == [\"\
    ()\", \"(())\", \"(()())\"])"
  status: Exception
  stderr: 'tmpwimbbuju/tmpwimbbuju.swift:46: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002af950277c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002af94ff6eb6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002af94ff6e988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002af94ff6d7b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpwimbbuju                        0x00005588fd834787 <unavailable> + 6023

    5    libc.so.6                          0x00002af950463460 __libc_start_main +
    245

    6    tmpwimbbuju                        0x00005588fd834319 <unavailable> + 4889

    '
  stdout: ''
  timestamp: 1659980042
- exit_code: 1
  program: "\n/// Input to this function is a string containing multiple groups of\
    \ nested parentheses. Your goal is to\n/// separate those group into separate\
    \ strings and return the array of those.\n/// Separate groups are balanced (each\
    \ open brace is properly closed) and not nested within each other\n/// Ignore\
    \ any spaces in the input string.\n/// >>> separate_paren_groups(paren_string:\
    \ \"( ) (( )) (( )( ))\")\n/// [\"()\", \"(())\", \"(()())\"]\nfunc separate_paren_groups(paren_string:\
    \ String) -> [String] {\n    /// Result is not the same for this solution than\
    \ for the one in haskell.\n    /// The one in haskell does not include the opening\
    \ and closing parenthesis when returning the result\n    var result: [String]\
    \ = []\n    var opened: Int = 0\n    var start: Int = 0\n    var end: Int = 0\n\
    \    for (index, char) in paren_string.enumerated() {\n        if char == \"(\"\
    \ {\n            if opened == 0 {\n                start = index\n           \
    \ }\n            opened += 1\n        } else if char == \")\" {\n            opened\
    \ -= 1\n            if opened == 0 {\n                end = index\n          \
    \      result.append(paren_string[start...end])\n            }\n        }\n  \
    \  }\n    return result\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(separate_paren_groups(paren_string:\
    \ \"(()()) ((())) () ((())()())\") == [\"(()())\", \"((()))\", \"()\", \"((())()())\"\
    ])\nassert(separate_paren_groups(paren_string: \"() (()) ((())) (((())))\") ==\
    \ [\"()\", \"(())\", \"((()))\", \"(((())))\"])\nassert(separate_paren_groups(paren_string:\
    \ \"(()(())((())))\") == [\"(()(())((())))\"])\nassert(separate_paren_groups(paren_string:\
    \ \"( ) (( )) (( )( ))\") == [\"()\", \"(())\", \"(()())\"])"
  status: SyntaxError
  stderr: "/tmp/tmpoq63fetx.swift:25:31: error: 'subscript(_:)' is unavailable: cannot\
    \ subscript String with an integer range, use a String.Index range instead.\n\
    \                result.append(paren_string[start...end])\n                  \
    \            ^~~~~~~~~~~~~~~~~~~~~~~~~\nSwift.String:5:12: note: 'subscript(_:)'\
    \ has been explicitly marked unavailable here\n    public subscript<R>(bounds:\
    \ R) -> String where R : RangeExpression, R.Bound == Int { get }\n           ^\n"
  stdout: ''
  timestamp: 1659980041
- exit_code: -4
  program: "\n/// Input to this function is a string containing multiple groups of\
    \ nested parentheses. Your goal is to\n/// separate those group into separate\
    \ strings and return the array of those.\n/// Separate groups are balanced (each\
    \ open brace is properly closed) and not nested within each other\n/// Ignore\
    \ any spaces in the input string.\n/// >>> separate_paren_groups(paren_string:\
    \ \"( ) (( )) (( )( ))\")\n/// [\"()\", \"(())\", \"(()())\"]\nfunc separate_paren_groups(paren_string:\
    \ String) -> [String] {\n    var results: [String] = []\n    var last_index =\
    \ paren_string.startIndex\n    for (index, char) in paren_string.enumerated()\
    \ {\n        if char == \")\" {\n            var current_string = \"\"\n     \
    \       for char in paren_string[last_index..<paren_string.index(paren_string.startIndex,\
    \ offsetBy: index)] {\n                if char != \" \" {\n                  \
    \  current_string.append(char)\n                }\n            }\n           \
    \ results.append(current_string)\n            last_index = paren_string.index(paren_string.startIndex,\
    \ offsetBy: index + 1)\n        }\n    }\n    return results\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(separate_paren_groups(paren_string: \"(()()) ((())) ()\
    \ ((())()())\") == [\"(()())\", \"((()))\", \"()\", \"((())()())\"])\nassert(separate_paren_groups(paren_string:\
    \ \"() (()) ((())) (((())))\") == [\"()\", \"(())\", \"((()))\", \"(((())))\"\
    ])\nassert(separate_paren_groups(paren_string: \"(()(())((())))\") == [\"(()(())((())))\"\
    ])\nassert(separate_paren_groups(paren_string: \"( ) (( )) (( )( ))\") == [\"\
    ()\", \"(())\", \"(()())\"])"
  status: Exception
  stderr: 'tmp7ow61dqi/tmp7ow61dqi.swift:39: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002abfa90d0c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002abfa8dc7b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002abfa8dc7988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002abfa8dc67b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmp7ow61dqi                        0x000055c7b1f34c77 <unavailable> + 7287

    5    libc.so.6                          0x00002abfa92bc460 __libc_start_main +
    245

    6    tmp7ow61dqi                        0x000055c7b1f34809 <unavailable> + 6153

    '
  stdout: ''
  timestamp: 1659980042
- exit_code: -1
  program: "\n/// Input to this function is a string containing multiple groups of\
    \ nested parentheses. Your goal is to\n/// separate those group into separate\
    \ strings and return the array of those.\n/// Separate groups are balanced (each\
    \ open brace is properly closed) and not nested within each other\n/// Ignore\
    \ any spaces in the input string.\n/// >>> separate_paren_groups(paren_string:\
    \ \"( ) (( )) (( )( ))\")\n/// [\"()\", \"(())\", \"(()())\"]\nfunc separate_paren_groups(paren_string:\
    \ String) -> [String] {\n  // the algorithm is to scan from left to right, \n\
    \  // - capture all the opening parentheses\n  // - when closing is encountered,\
    \ match with previous opening\n  // - repeat the above step till there are no\
    \ unmatched closing parentheses\n  // - finally, add the unmatched open parentheses\
    \ to the end of the string\n  var matchedParens = [String]()\n  var remainingParens\
    \ = paren_string\n  var matched = \"\"\n  while !remainingParens.isEmpty {\n \
    \   let indexOfClose = remainingParens.firstIndex(of: \")\")\n    if let index\
    \ = indexOfClose {\n      matched += String(remainingParens[..<index])\n     \
    \ matchedParens.append(matched)\n      matched = \"\"\n      remainingParens =\
    \ String(remainingParens[index...])\n    } else {\n      // we hit the end. There\
    \ are unmatched closing parentheses\n      matched += remainingParens\n      remainingParens\
    \ = \"\"\n    }\n  }\n  if !matched.isEmpty {\n    matchedParens.append(matched)\n\
    \  }\n  return matchedParens\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int,\
    \ Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n\
    \    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n          \
    \  return false\n        }\n    }\n    return true\n}\n            \nassert(separate_paren_groups(paren_string:\
    \ \"(()()) ((())) () ((())()())\") == [\"(()())\", \"((()))\", \"()\", \"((())()())\"\
    ])\nassert(separate_paren_groups(paren_string: \"() (()) ((())) (((())))\") ==\
    \ [\"()\", \"(())\", \"((()))\", \"(((())))\"])\nassert(separate_paren_groups(paren_string:\
    \ \"(()(())((())))\") == [\"(()(())((())))\"])\nassert(separate_paren_groups(paren_string:\
    \ \"( ) (( )) (( )( ))\") == [\"()\", \"(())\", \"(()())\"])"
  status: Timeout
  stderr: ''
  stdout: ''
  timestamp: 1659980047
- exit_code: -4
  program: "\n/// Input to this function is a string containing multiple groups of\
    \ nested parentheses. Your goal is to\n/// separate those group into separate\
    \ strings and return the array of those.\n/// Separate groups are balanced (each\
    \ open brace is properly closed) and not nested within each other\n/// Ignore\
    \ any spaces in the input string.\n/// >>> separate_paren_groups(paren_string:\
    \ \"( ) (( )) (( )( ))\")\n/// [\"()\", \"(())\", \"(()())\"]\nfunc separate_paren_groups(paren_string:\
    \ String) -> [String] {\n    return []\n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(separate_paren_groups(paren_string: \"(()()) ((())) () ((())()())\") ==\
    \ [\"(()())\", \"((()))\", \"()\", \"((())()())\"])\nassert(separate_paren_groups(paren_string:\
    \ \"() (()) ((())) (((())))\") == [\"()\", \"(())\", \"((()))\", \"(((())))\"\
    ])\nassert(separate_paren_groups(paren_string: \"(()(())((())))\") == [\"(()(())((())))\"\
    ])\nassert(separate_paren_groups(paren_string: \"( ) (( )) (( )( ))\") == [\"\
    ()\", \"(())\", \"(()())\"])"
  status: Exception
  stderr: 'tmp1zdkbtz2/tmp1zdkbtz2.swift:25: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002aeebe8b5c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002aeebe5acb6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002aeebe5ac988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002aeebe5ab7b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmp1zdkbtz2                        0x0000556857c08537 <unavailable> + 5431

    5    libc.so.6                          0x00002aeebeaa1460 __libc_start_main +
    245

    6    tmp1zdkbtz2                        0x0000556857c080c9 <unavailable> + 4297

    '
  stdout: ''
  timestamp: 1659980040
- exit_code: 1
  program: "\n/// Input to this function is a string containing multiple groups of\
    \ nested parentheses. Your goal is to\n/// separate those group into separate\
    \ strings and return the array of those.\n/// Separate groups are balanced (each\
    \ open brace is properly closed) and not nested within each other\n/// Ignore\
    \ any spaces in the input string.\n/// >>> separate_paren_groups(paren_string:\
    \ \"( ) (( )) (( )( ))\")\n/// [\"()\", \"(())\", \"(()())\"]\nfunc separate_paren_groups(paren_string:\
    \ String) -> [String] {\n    var result = [String]()\n    var start_of_paren_group\
    \ = 0\n    var stack = Stack<Character>()\n    var i = 0\n    while i < paren_string.count\
    \ {\n        let next_char = paren_string[paren_string.index(paren_string.startIndex,\
    \ offsetBy: i)]\n        if next_char == \"(\" {\n            stack.push(next_char)\n\
    \        } else if next_char == \")\" {\n            stack.pop()\n        }\n\
    \        i += 1\n        if stack.isEmpty() {\n            result.append(paren_string[paren_string.index(paren_string.startIndex,\
    \ offsetBy: start_of_paren_group)..<paren_string.index(paren_string.startIndex,\
    \ offsetBy: i)].trimmingCharacters(in: .whitespaces))\n            start_of_paren_group\
    \ = i\n        }\n    }\n    return result\n}\n\n\nfunc ==(left: [(Int, Int)],\
    \ right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n       \
    \ return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r\
    \ {\n            return false\n        }\n    }\n    return true\n}\n        \
    \    \nassert(separate_paren_groups(paren_string: \"(()()) ((())) () ((())()())\"\
    ) == [\"(()())\", \"((()))\", \"()\", \"((())()())\"])\nassert(separate_paren_groups(paren_string:\
    \ \"() (()) ((())) (((())))\") == [\"()\", \"(())\", \"((()))\", \"(((())))\"\
    ])\nassert(separate_paren_groups(paren_string: \"(()(())((())))\") == [\"(()(())((())))\"\
    ])\nassert(separate_paren_groups(paren_string: \"( ) (( )) (( )( ))\") == [\"\
    ()\", \"(())\", \"(()())\"])"
  status: SyntaxError
  stderr: "/tmp/tmpyo22jh6r.swift:11:17: error: cannot find 'Stack' in scope\n   \
    \ var stack = Stack<Character>()\n                ^~~~~\n/tmp/tmpyo22jh6r.swift:22:176:\
    \ error: value of type 'Substring' has no member 'trimmingCharacters'\n      \
    \      result.append(paren_string[paren_string.index(paren_string.startIndex,\
    \ offsetBy: start_of_paren_group)..<paren_string.index(paren_string.startIndex,\
    \ offsetBy: i)].trimmingCharacters(in: .whitespaces))\n                      \
    \    ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\
    \ ^~~~~~~~~~~~~~~~~~\n/tmp/tmpyo22jh6r.swift:22:200: error: cannot infer contextual\
    \ base in reference to member 'whitespaces'\n            result.append(paren_string[paren_string.index(paren_string.startIndex,\
    \ offsetBy: start_of_paren_group)..<paren_string.index(paren_string.startIndex,\
    \ offsetBy: i)].trimmingCharacters(in: .whitespaces))\n                      \
    \                                                                            \
    \                                                                            \
    \                        ~^~~~~~~~~~~\n"
  stdout: ''
  timestamp: 1659980042
- exit_code: 0
  program: "\n/// Input to this function is a string containing multiple groups of\
    \ nested parentheses. Your goal is to\n/// separate those group into separate\
    \ strings and return the array of those.\n/// Separate groups are balanced (each\
    \ open brace is properly closed) and not nested within each other\n/// Ignore\
    \ any spaces in the input string.\n/// >>> separate_paren_groups(paren_string:\
    \ \"( ) (( )) (( )( ))\")\n/// [\"()\", \"(())\", \"(()())\"]\nfunc separate_paren_groups(paren_string:\
    \ String) -> [String] {\n    guard paren_string.count > 0 else {\n        return\
    \ [String]()\n    }\n    \n    var result = [String]()\n    var current_paren_group\
    \ = \"\"\n    var open_paren_count = 0\n    for char in paren_string {\n     \
    \   if char == \"(\" {\n            open_paren_count += 1\n            current_paren_group.append(char)\n\
    \        } else if char == \")\" {\n            if open_paren_count > 0 {\n  \
    \              open_paren_count -= 1\n                current_paren_group.append(char)\n\
    \            }\n        }\n        \n        if open_paren_count == 0 && current_paren_group.count\
    \ > 0 {\n            result.append(current_paren_group)\n            current_paren_group\
    \ = \"\"\n        }\n    }\n    \n    return result\n}\n\n\nfunc ==(left: [(Int,\
    \ Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n\
    \        return false\n    }\n    for (l, r) in zip(left, right) {\n        if\
    \ l != r {\n            return false\n        }\n    }\n    return true\n}\n \
    \           \nassert(separate_paren_groups(paren_string: \"(()()) ((())) () ((())()())\"\
    ) == [\"(()())\", \"((()))\", \"()\", \"((())()())\"])\nassert(separate_paren_groups(paren_string:\
    \ \"() (()) ((())) (((())))\") == [\"()\", \"(())\", \"((()))\", \"(((())))\"\
    ])\nassert(separate_paren_groups(paren_string: \"(()(())((())))\") == [\"(()(())((())))\"\
    ])\nassert(separate_paren_groups(paren_string: \"( ) (( )) (( )( ))\") == [\"\
    ()\", \"(())\", \"(()())\"])"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659980042
- exit_code: -4
  program: "\n/// Input to this function is a string containing multiple groups of\
    \ nested parentheses. Your goal is to\n/// separate those group into separate\
    \ strings and return the array of those.\n/// Separate groups are balanced (each\
    \ open brace is properly closed) and not nested within each other\n/// Ignore\
    \ any spaces in the input string.\n/// >>> separate_paren_groups(paren_string:\
    \ \"( ) (( )) (( )( ))\")\n/// [\"()\", \"(())\", \"(()())\"]\nfunc separate_paren_groups(paren_string:\
    \ String) -> [String] {\n    let tokens = paren_string.split(separator: \" \"\
    )\n    var result: [String] = []\n    var temp = \"\"\n    for token in tokens\
    \ {\n        if token == \"(\" {\n            temp += token\n        } else if\
    \ token == \")\" {\n            temp += token\n            result.append(temp)\n\
    \            temp = \"\"\n        }\n    }\n    return result\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(separate_paren_groups(paren_string: \"(()()) ((())) ()\
    \ ((())()())\") == [\"(()())\", \"((()))\", \"()\", \"((())()())\"])\nassert(separate_paren_groups(paren_string:\
    \ \"() (()) ((())) (((())))\") == [\"()\", \"(())\", \"((()))\", \"(((())))\"\
    ])\nassert(separate_paren_groups(paren_string: \"(()(())((())))\") == [\"(()(())((())))\"\
    ])\nassert(separate_paren_groups(paren_string: \"( ) (( )) (( )( ))\") == [\"\
    ()\", \"(())\", \"(()())\"])"
  status: Exception
  stderr: 'tmpg49_otno/tmpg49_otno.swift:37: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002acd8ce8bc80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002acd8cb82b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002acd8cb82988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002acd8cb817b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpg49_otno                        0x0000556a28a15ab7 <unavailable> + 6839

    5    libc.so.6                          0x00002acd8d077460 __libc_start_main +
    245

    6    tmpg49_otno                        0x0000556a28a15649 <unavailable> + 5705

    '
  stdout: ''
  timestamp: 1659980042
- exit_code: -4
  program: "\n/// Input to this function is a string containing multiple groups of\
    \ nested parentheses. Your goal is to\n/// separate those group into separate\
    \ strings and return the array of those.\n/// Separate groups are balanced (each\
    \ open brace is properly closed) and not nested within each other\n/// Ignore\
    \ any spaces in the input string.\n/// >>> separate_paren_groups(paren_string:\
    \ \"( ) (( )) (( )( ))\")\n/// [\"()\", \"(())\", \"(()())\"]\nfunc separate_paren_groups(paren_string:\
    \ String) -> [String] {\n    \n    var result = [String]()\n    var countOpen\
    \ = 0\n    var countClose = 0\n    var temp = \"\"\n    \n    for i in paren_string\
    \ {\n        if i == \"(\" {\n            countOpen += 1\n        } else if i\
    \ == \")\" {\n            countClose += 1\n        }\n        temp.append(i)\n\
    \        if countOpen == countClose {\n            result.append(temp)\n     \
    \       temp = \"\"\n            countOpen = 0\n            countClose = 0\n \
    \       }\n    }\n    return result\n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(separate_paren_groups(paren_string: \"(()()) ((())) () ((())()())\") ==\
    \ [\"(()())\", \"((()))\", \"()\", \"((())()())\"])\nassert(separate_paren_groups(paren_string:\
    \ \"() (()) ((())) (((())))\") == [\"()\", \"(())\", \"((()))\", \"(((())))\"\
    ])\nassert(separate_paren_groups(paren_string: \"(()(())((())))\") == [\"(()(())((())))\"\
    ])\nassert(separate_paren_groups(paren_string: \"( ) (( )) (( )( ))\") == [\"\
    ()\", \"(())\", \"(()())\"])"
  status: Exception
  stderr: 'tmpbwf5hhxv/tmpbwf5hhxv.swift:45: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b2f372ffc80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b2f36ff6b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b2f36ff6988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b2f36ff57b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpbwf5hhxv                        0x000056304e22e7e7 <unavailable> + 6119

    5    libc.so.6                          0x00002b2f374eb460 __libc_start_main +
    245

    6    tmpbwf5hhxv                        0x000056304e22e379 <unavailable> + 4985

    '
  stdout: ''
  timestamp: 1659980042
- exit_code: 1
  program: "\n/// Input to this function is a string containing multiple groups of\
    \ nested parentheses. Your goal is to\n/// separate those group into separate\
    \ strings and return the array of those.\n/// Separate groups are balanced (each\
    \ open brace is properly closed) and not nested within each other\n/// Ignore\
    \ any spaces in the input string.\n/// >>> separate_paren_groups(paren_string:\
    \ \"( ) (( )) (( )( ))\")\n/// [\"()\", \"(())\", \"(()())\"]\nfunc separate_paren_groups(paren_string:\
    \ String) -> [String] {\n    var stack = Stack<Character>()\n    var start_index\
    \ = 0\n    var end_index = 0\n    var substrings = [String]()\n    for (index,\
    \ c) in paren_string.enumerated() {\n        if c == \"(\" {\n            stack.push(c)\n\
    \            if stack.count == 1 {\n                start_index = index\n    \
    \        }\n        } else if c == \")\" {\n            if stack.count == 1 {\n\
    \                end_index = index\n                if let str = paren_string.substring(start_index,\
    \ end_index + 1) {\n                    substrings.append(str)\n             \
    \   }\n            }\n            stack.pop()\n        }\n    }\n    return substrings\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(separate_paren_groups(paren_string: \"(()()) ((()))\
    \ () ((())()())\") == [\"(()())\", \"((()))\", \"()\", \"((())()())\"])\nassert(separate_paren_groups(paren_string:\
    \ \"() (()) ((())) (((())))\") == [\"()\", \"(())\", \"((()))\", \"(((())))\"\
    ])\nassert(separate_paren_groups(paren_string: \"(()(())((())))\") == [\"(()(())((())))\"\
    ])\nassert(separate_paren_groups(paren_string: \"( ) (( )) (( )( ))\") == [\"\
    ()\", \"(())\", \"(()())\"])"
  status: SyntaxError
  stderr: "/tmp/tmp3ru8do_g.swift:9:17: error: cannot find 'Stack' in scope\n    var\
    \ stack = Stack<Character>()\n                ^~~~~\n/tmp/tmp3ru8do_g.swift:22:43:\
    \ error: value of type 'String' has no member 'substring'\n                if\
    \ let str = paren_string.substring(start_index, end_index + 1) {\n           \
    \                  ~~~~~~~~~~~~ ^~~~~~~~~\n"
  stdout: ''
  timestamp: 1659980042
- exit_code: 1
  program: "\n/// Input to this function is a string containing multiple groups of\
    \ nested parentheses. Your goal is to\n/// separate those group into separate\
    \ strings and return the array of those.\n/// Separate groups are balanced (each\
    \ open brace is properly closed) and not nested within each other\n/// Ignore\
    \ any spaces in the input string.\n/// >>> separate_paren_groups(paren_string:\
    \ \"( ) (( )) (( )( ))\")\n/// [\"()\", \"(())\", \"(()())\"]\nfunc separate_paren_groups(paren_string:\
    \ String) -> [String] {\n  var result: [String] = []\n  var temp = \"\"\n  var\
    \ counter = 0\n  var last = 0\n  let (parens, _) = find_unmatched_paren(paren_string)\n\
    \  let paren_array = Array(paren_string)\n  if parens.isEmpty {\n    return [paren_string]\n\
    \  }\n  for (index, paren) in paren_array.enumerated() {\n    if paren == \"(\"\
    \ {\n      counter += 1\n    } else if paren == \")\" {\n      counter -= 1\n\
    \    }\n    if counter == 0 {\n      if index == last {\n        result.append(String(paren_array[index]))\n\
    \      } else {\n        result.append(String(paren_array[last...index]))\n  \
    \    }\n      last = index + 1\n    }\n  }\n  return result\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(separate_paren_groups(paren_string: \"(()()) ((())) ()\
    \ ((())()())\") == [\"(()())\", \"((()))\", \"()\", \"((())()())\"])\nassert(separate_paren_groups(paren_string:\
    \ \"() (()) ((())) (((())))\") == [\"()\", \"(())\", \"((()))\", \"(((())))\"\
    ])\nassert(separate_paren_groups(paren_string: \"(()(())((())))\") == [\"(()(())((())))\"\
    ])\nassert(separate_paren_groups(paren_string: \"( ) (( )) (( )( ))\") == [\"\
    ()\", \"(())\", \"(()())\"])"
  status: SyntaxError
  stderr: "/tmp/tmp4d63fsm0.swift:13:21: error: cannot find 'find_unmatched_paren'\
    \ in scope\n  let (parens, _) = find_unmatched_paren(paren_string)\n         \
    \           ^~~~~~~~~~~~~~~~~~~~\n/tmp/tmp4d63fsm0.swift:13:21: error: type of\
    \ expression is ambiguous without more context\n  let (parens, _) = find_unmatched_paren(paren_string)\n\
    \                    ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n"
  stdout: ''
  timestamp: 1659980042
- exit_code: 1
  program: "\n/// Input to this function is a string containing multiple groups of\
    \ nested parentheses. Your goal is to\n/// separate those group into separate\
    \ strings and return the array of those.\n/// Separate groups are balanced (each\
    \ open brace is properly closed) and not nested within each other\n/// Ignore\
    \ any spaces in the input string.\n/// >>> separate_paren_groups(paren_string:\
    \ \"( ) (( )) (( )( ))\")\n/// [\"()\", \"(())\", \"(()())\"]\nfunc separate_paren_groups(paren_string:\
    \ String) -> [String] {\n    var parens = Stack<Character>()\n    var parenGroups\
    \ = [String]()\n    var index = 0\n    var start = 0\n    var parenString = paren_string.filter\
    \ { $0 != \" \" }\n    while index < parenString.count {\n        let char = parenString[parenString.index(parenString.startIndex,\
    \ offsetBy: index)]\n        if char == \"(\" {\n            parens.push(element:\
    \ char)\n        } else if char == \")\" {\n            _ = parens.pop()\n   \
    \         if parens.isEmpty() {\n                parenGroups.append(String(parenString[parenString.index(parenString.startIndex,\
    \ offsetBy: start)..<parenString.index(parenString.startIndex, offsetBy: index+1)]))\n\
    \                start = index + 1\n            }\n        }\n        index +=\
    \ 1\n    }\n    return parenGroups\n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(separate_paren_groups(paren_string: \"(()()) ((())) () ((())()())\") ==\
    \ [\"(()())\", \"((()))\", \"()\", \"((())()())\"])\nassert(separate_paren_groups(paren_string:\
    \ \"() (()) ((())) (((())))\") == [\"()\", \"(())\", \"((()))\", \"(((())))\"\
    ])\nassert(separate_paren_groups(paren_string: \"(()(())((())))\") == [\"(()(())((())))\"\
    ])\nassert(separate_paren_groups(paren_string: \"( ) (( )) (( )( ))\") == [\"\
    ()\", \"(())\", \"(()())\"])"
  status: SyntaxError
  stderr: "/tmp/tmpoftupwtt.swift:9:18: error: cannot find 'Stack' in scope\n    var\
    \ parens = Stack<Character>()\n                 ^~~~~\n"
  stdout: ''
  timestamp: 1659980042
- exit_code: 1
  program: "\n/// Input to this function is a string containing multiple groups of\
    \ nested parentheses. Your goal is to\n/// separate those group into separate\
    \ strings and return the array of those.\n/// Separate groups are balanced (each\
    \ open brace is properly closed) and not nested within each other\n/// Ignore\
    \ any spaces in the input string.\n/// >>> separate_paren_groups(paren_string:\
    \ \"( ) (( )) (( )( ))\")\n/// [\"()\", \"(())\", \"(()())\"]\nfunc separate_paren_groups(paren_string:\
    \ String) -> [String] {\n    // Write your solution here\n    \n    // a stack\
    \ to keep track of the open parens\n    var stack = Stack<Character>()\n    \n\
    \    // a stack to keep track of the beginning and the end of paren strings\n\
    \    var result = Stack<String>()\n    \n    // iterate through every element\
    \ of paren_string\n    for char in paren_string {\n        // if stack is empty\
    \ or the last char from stack != ( or char != ( or ) ignore this character\n \
    \       guard stack.peek() != nil || char != \"(\" || char != \")\" else {\n \
    \           continue\n        }\n        \n        // if stack is not empty and\
    \ the last char from stack == ( then char == )\n        if stack.peek() == \"\
    (\" {\n            // append ( to the last string on the result stack\n      \
    \      let string = result.pop()!\n            result.push(string + \"(\")\n \
    \           \n            // append ) to the last string on the result stack\n\
    \            let string_ = result.pop()!\n            result.push(string_ + \"\
    )\")\n            \n            // pop from stack the first (\n            stack.pop()\n\
    \        } else {\n            // stack is empty and char == ( then append char\
    \ to the last string on the result stack\n            if stack.peek() == nil {\n\
    \                // append ( to the last string on the result stack\n        \
    \        let string = result.pop()!\n                result.push(string + \"(\"\
    )\n            }\n            // push char on the stack\n            stack.push(char)\n\
    \        }\n    }\n    \n    return result.array\n}\n\n\nfunc ==(left: [(Int,\
    \ Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n\
    \        return false\n    }\n    for (l, r) in zip(left, right) {\n        if\
    \ l != r {\n            return false\n        }\n    }\n    return true\n}\n \
    \           \nassert(separate_paren_groups(paren_string: \"(()()) ((())) () ((())()())\"\
    ) == [\"(()())\", \"((()))\", \"()\", \"((())()())\"])\nassert(separate_paren_groups(paren_string:\
    \ \"() (()) ((())) (((())))\") == [\"()\", \"(())\", \"((()))\", \"(((())))\"\
    ])\nassert(separate_paren_groups(paren_string: \"(()(())((())))\") == [\"(()(())((())))\"\
    ])\nassert(separate_paren_groups(paren_string: \"( ) (( )) (( )( ))\") == [\"\
    ()\", \"(())\", \"(()())\"])"
  status: SyntaxError
  stderr: "/tmp/tmpnsun_ayx.swift:12:17: error: cannot find 'Stack' in scope\n   \
    \ var stack = Stack<Character>()\n                ^~~~~\n/tmp/tmpnsun_ayx.swift:15:18:\
    \ error: cannot find 'Stack' in scope\n    var result = Stack<String>()\n    \
    \             ^~~~~\n"
  stdout: ''
  timestamp: 1659980042
- exit_code: 0
  program: "\n/// Input to this function is a string containing multiple groups of\
    \ nested parentheses. Your goal is to\n/// separate those group into separate\
    \ strings and return the array of those.\n/// Separate groups are balanced (each\
    \ open brace is properly closed) and not nested within each other\n/// Ignore\
    \ any spaces in the input string.\n/// >>> separate_paren_groups(paren_string:\
    \ \"( ) (( )) (( )( ))\")\n/// [\"()\", \"(())\", \"(()())\"]\nfunc separate_paren_groups(paren_string:\
    \ String) -> [String] {\n    var res = [String]()\n    var stack = [Character]()\n\
    \    var start = 0\n    var end = 0\n    var str = paren_string\n    str.removeAll\
    \ { (c) -> Bool in\n        c == \" \"\n    }\n    for i in 0..<str.count {\n\
    \        let c = str[str.index(str.startIndex, offsetBy: i)]\n        if c ==\
    \ \"(\" {\n            stack.append(c)\n            if stack.count == 1 {\n  \
    \              start = i\n            }\n        } else {\n            _ = stack.popLast()\n\
    \            if stack.count == 0 {\n                end = i\n                res.append(String(str[str.index(str.startIndex,\
    \ offsetBy: start)..<str.index(str.startIndex, offsetBy: end+1)]))\n         \
    \   }\n        }\n    }\n    return res\n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(separate_paren_groups(paren_string: \"(()()) ((())) () ((())()())\") ==\
    \ [\"(()())\", \"((()))\", \"()\", \"((())()())\"])\nassert(separate_paren_groups(paren_string:\
    \ \"() (()) ((())) (((())))\") == [\"()\", \"(())\", \"((()))\", \"(((())))\"\
    ])\nassert(separate_paren_groups(paren_string: \"(()(())((())))\") == [\"(()(())((())))\"\
    ])\nassert(separate_paren_groups(paren_string: \"( ) (( )) (( )( ))\") == [\"\
    ()\", \"(())\", \"(()())\"])"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659980042
- exit_code: -4
  program: "\n/// Input to this function is a string containing multiple groups of\
    \ nested parentheses. Your goal is to\n/// separate those group into separate\
    \ strings and return the array of those.\n/// Separate groups are balanced (each\
    \ open brace is properly closed) and not nested within each other\n/// Ignore\
    \ any spaces in the input string.\n/// >>> separate_paren_groups(paren_string:\
    \ \"( ) (( )) (( )( ))\")\n/// [\"()\", \"(())\", \"(()())\"]\nfunc separate_paren_groups(paren_string:\
    \ String) -> [String] {\n    var parenGroups: [String] = []\n    var currentGroup:\
    \ String = \"\"\n    var isGroupOpen: Bool = false\n    for char in paren_string\
    \ {\n        if (char == \"(\") {\n            if (!isGroupOpen) {\n         \
    \       currentGroup = \"(\"\n                isGroupOpen = true\n           \
    \ } else {\n                currentGroup.append(char)\n            }\n       \
    \ } else if (char == \")\") {\n            if (isGroupOpen) {\n              \
    \  currentGroup.append(char)\n                parenGroups.append(currentGroup)\n\
    \                isGroupOpen = false\n            }\n        }\n    }\n    return\
    \ parenGroups\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool\
    \ {\n    if left.count != right.count {\n        return false\n    }\n    for\
    \ (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(separate_paren_groups(paren_string:\
    \ \"(()()) ((())) () ((())()())\") == [\"(()())\", \"((()))\", \"()\", \"((())()())\"\
    ])\nassert(separate_paren_groups(paren_string: \"() (()) ((())) (((())))\") ==\
    \ [\"()\", \"(())\", \"((()))\", \"(((())))\"])\nassert(separate_paren_groups(paren_string:\
    \ \"(()(())((())))\") == [\"(()(())((())))\"])\nassert(separate_paren_groups(paren_string:\
    \ \"( ) (( )) (( )( ))\") == [\"()\", \"(())\", \"(()())\"])"
  status: Exception
  stderr: 'tmp_jvbdep0/tmp_jvbdep0.swift:44: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002ae9e2968c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002ae9e265fb6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002ae9e265f988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002ae9e265e7b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmp_jvbdep0                        0x000055e62d176787 <unavailable> + 6023

    5    libc.so.6                          0x00002ae9e2b54460 __libc_start_main +
    245

    6    tmp_jvbdep0                        0x000055e62d176319 <unavailable> + 4889

    '
  stdout: ''
  timestamp: 1659980042
- exit_code: 1
  program: "\n/// Input to this function is a string containing multiple groups of\
    \ nested parentheses. Your goal is to\n/// separate those group into separate\
    \ strings and return the array of those.\n/// Separate groups are balanced (each\
    \ open brace is properly closed) and not nested within each other\n/// Ignore\
    \ any spaces in the input string.\n/// >>> separate_paren_groups(paren_string:\
    \ \"( ) (( )) (( )( ))\")\n/// [\"()\", \"(())\", \"(()())\"]\nfunc separate_paren_groups(paren_string:\
    \ String) -> [String] {\n    var stack = Stack<Character>()\n    var result =\
    \ [String]()\n    var temp = \"\"\n    for char in paren_string {\n        if\
    \ char == \" \" {\n            continue\n        }\n        if char == \"(\" {\n\
    \            stack.push(element: char)\n        } else if char == \")\" {\n  \
    \          stack.pop()\n            if stack.isEmpty() {\n                result.append(temp)\n\
    \                temp = \"\"\n            }\n        }\n        temp.append(char)\n\
    \    }\n    return result\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(separate_paren_groups(paren_string:\
    \ \"(()()) ((())) () ((())()())\") == [\"(()())\", \"((()))\", \"()\", \"((())()())\"\
    ])\nassert(separate_paren_groups(paren_string: \"() (()) ((())) (((())))\") ==\
    \ [\"()\", \"(())\", \"((()))\", \"(((())))\"])\nassert(separate_paren_groups(paren_string:\
    \ \"(()(())((())))\") == [\"(()(())((())))\"])\nassert(separate_paren_groups(paren_string:\
    \ \"( ) (( )) (( )( ))\") == [\"()\", \"(())\", \"(()())\"])"
  status: SyntaxError
  stderr: "/tmp/tmp5rl01w39.swift:9:17: error: cannot find 'Stack' in scope\n    var\
    \ stack = Stack<Character>()\n                ^~~~~\n"
  stdout: ''
  timestamp: 1659980042
- exit_code: -4
  program: "\n/// Input to this function is a string containing multiple groups of\
    \ nested parentheses. Your goal is to\n/// separate those group into separate\
    \ strings and return the array of those.\n/// Separate groups are balanced (each\
    \ open brace is properly closed) and not nested within each other\n/// Ignore\
    \ any spaces in the input string.\n/// >>> separate_paren_groups(paren_string:\
    \ \"( ) (( )) (( )( ))\")\n/// [\"()\", \"(())\", \"(()())\"]\nfunc separate_paren_groups(paren_string:\
    \ String) -> [String] {\n    var balanced_paren_groups: [String] = []\n    var\
    \ balanced_string = \"\"\n    var current_paren_count = 0\n    var skip_next_char\
    \ = false\n    \n    for char in paren_string {\n        if skip_next_char {\n\
    \            skip_next_char = false\n            continue\n        }\n       \
    \ \n        if char == \" \" {\n            skip_next_char = true\n          \
    \  continue\n        }\n        \n        if char == \"(\" {\n            current_paren_count\
    \ += 1\n        } else if char == \")\" {\n            current_paren_count -=\
    \ 1\n        }\n        \n        balanced_string.append(char)\n        \n   \
    \     if current_paren_count == 0 {\n            balanced_paren_groups.append(balanced_string)\n\
    \            balanced_string = \"\"\n        }\n    }\n    \n    return balanced_paren_groups\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(separate_paren_groups(paren_string: \"(()()) ((()))\
    \ () ((())()())\") == [\"(()())\", \"((()))\", \"()\", \"((())()())\"])\nassert(separate_paren_groups(paren_string:\
    \ \"() (()) ((())) (((())))\") == [\"()\", \"(())\", \"((()))\", \"(((())))\"\
    ])\nassert(separate_paren_groups(paren_string: \"(()(())((())))\") == [\"(()(())((())))\"\
    ])\nassert(separate_paren_groups(paren_string: \"( ) (( )) (( )( ))\") == [\"\
    ()\", \"(())\", \"(()())\"])"
  status: Exception
  stderr: 'tmplkq7q3y1/tmplkq7q3y1.swift:55: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b1f5a313c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b1f5a00ab6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b1f5a00a988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b1f5a0097b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmplkq7q3y1                        0x0000562fed7a1787 <unavailable> + 6023

    5    libc.so.6                          0x00002b1f5a4ff460 __libc_start_main +
    245

    6    tmplkq7q3y1                        0x0000562fed7a1319 <unavailable> + 4889

    '
  stdout: ''
  timestamp: 1659980042
- exit_code: -4
  program: "\n/// Input to this function is a string containing multiple groups of\
    \ nested parentheses. Your goal is to\n/// separate those group into separate\
    \ strings and return the array of those.\n/// Separate groups are balanced (each\
    \ open brace is properly closed) and not nested within each other\n/// Ignore\
    \ any spaces in the input string.\n/// >>> separate_paren_groups(paren_string:\
    \ \"( ) (( )) (( )( ))\")\n/// [\"()\", \"(())\", \"(()())\"]\nfunc separate_paren_groups(paren_string:\
    \ String) -> [String] {\n    // your code here\n    return [\"\"]\n}\n\n\nfunc\
    \ ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count !=\
    \ right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(separate_paren_groups(paren_string: \"(()()) ((()))\
    \ () ((())()())\") == [\"(()())\", \"((()))\", \"()\", \"((())()())\"])\nassert(separate_paren_groups(paren_string:\
    \ \"() (()) ((())) (((())))\") == [\"()\", \"(())\", \"((()))\", \"(((())))\"\
    ])\nassert(separate_paren_groups(paren_string: \"(()(())((())))\") == [\"(()(())((())))\"\
    ])\nassert(separate_paren_groups(paren_string: \"( ) (( )) (( )( ))\") == [\"\
    ()\", \"(())\", \"(()())\"])"
  status: Exception
  stderr: 'tmpot3kkenq/tmpot3kkenq.swift:26: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b3e9af25c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b3e9ac1cb6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b3e9ac1c988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b3e9ac1b7b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpot3kkenq                        0x000055f1c4e6d537 <unavailable> + 5431

    5    libc.so.6                          0x00002b3e9b111460 __libc_start_main +
    245

    6    tmpot3kkenq                        0x000055f1c4e6d0c9 <unavailable> + 4297

    '
  stdout: ''
  timestamp: 1659980042
- exit_code: -4
  program: "\n/// Input to this function is a string containing multiple groups of\
    \ nested parentheses. Your goal is to\n/// separate those group into separate\
    \ strings and return the array of those.\n/// Separate groups are balanced (each\
    \ open brace is properly closed) and not nested within each other\n/// Ignore\
    \ any spaces in the input string.\n/// >>> separate_paren_groups(paren_string:\
    \ \"( ) (( )) (( )( ))\")\n/// [\"()\", \"(())\", \"(()())\"]\nfunc separate_paren_groups(paren_string:\
    \ String) -> [String] {\n    var paren_stack: [Character] = []\n    var paren_groups:\
    \ [String] = []\n    var current_paren_group: String = \"\"\n    \n    for char\
    \ in paren_string {\n        if (char == \"(\") {\n            paren_stack.append(char)\n\
    \        } else if (char == \")\") {\n            paren_stack.removeLast()\n \
    \           if (paren_stack.count == 0) {\n                paren_groups.append(current_paren_group)\n\
    \                current_paren_group = \"\"\n            }\n        } else if\
    \ (char != \" \") {\n            current_paren_group.append(char)\n        }\n\
    \    }\n    \n    return paren_groups\n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(separate_paren_groups(paren_string: \"(()()) ((())) () ((())()())\") ==\
    \ [\"(()())\", \"((()))\", \"()\", \"((())()())\"])\nassert(separate_paren_groups(paren_string:\
    \ \"() (()) ((())) (((())))\") == [\"()\", \"(())\", \"((()))\", \"(((())))\"\
    ])\nassert(separate_paren_groups(paren_string: \"(()(())((())))\") == [\"(()(())((())))\"\
    ])\nassert(separate_paren_groups(paren_string: \"( ) (( )) (( )( ))\") == [\"\
    ()\", \"(())\", \"(()())\"])"
  status: Exception
  stderr: 'tmpa56qqxcd/tmpa56qqxcd.swift:43: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b21262dcc80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b2125fd3b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b2125fd3988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b2125fd27b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpa56qqxcd                        0x0000555e5a7d7967 <unavailable> + 6503

    5    libc.so.6                          0x00002b21264c8460 __libc_start_main +
    245

    6    tmpa56qqxcd                        0x0000555e5a7d74f9 <unavailable> + 5369

    '
  stdout: ''
  timestamp: 1659980042
- exit_code: -4
  program: "\n/// Input to this function is a string containing multiple groups of\
    \ nested parentheses. Your goal is to\n/// separate those group into separate\
    \ strings and return the array of those.\n/// Separate groups are balanced (each\
    \ open brace is properly closed) and not nested within each other\n/// Ignore\
    \ any spaces in the input string.\n/// >>> separate_paren_groups(paren_string:\
    \ \"( ) (( )) (( )( ))\")\n/// [\"()\", \"(())\", \"(()())\"]\nfunc separate_paren_groups(paren_string:\
    \ String) -> [String] {\n    return []\n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(separate_paren_groups(paren_string: \"(()()) ((())) () ((())()())\") ==\
    \ [\"(()())\", \"((()))\", \"()\", \"((())()())\"])\nassert(separate_paren_groups(paren_string:\
    \ \"() (()) ((())) (((())))\") == [\"()\", \"(())\", \"((()))\", \"(((())))\"\
    ])\nassert(separate_paren_groups(paren_string: \"(()(())((())))\") == [\"(()(())((())))\"\
    ])\nassert(separate_paren_groups(paren_string: \"( ) (( )) (( )( ))\") == [\"\
    ()\", \"(())\", \"(()())\"])"
  status: Exception
  stderr: 'tmp1zdkbtz2/tmp1zdkbtz2.swift:25: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002aeebe8b5c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002aeebe5acb6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002aeebe5ac988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002aeebe5ab7b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmp1zdkbtz2                        0x0000556857c08537 <unavailable> + 5431

    5    libc.so.6                          0x00002aeebeaa1460 __libc_start_main +
    245

    6    tmp1zdkbtz2                        0x0000556857c080c9 <unavailable> + 4297

    '
  stdout: ''
  timestamp: 1659980040
- exit_code: -4
  program: "\n/// Input to this function is a string containing multiple groups of\
    \ nested parentheses. Your goal is to\n/// separate those group into separate\
    \ strings and return the array of those.\n/// Separate groups are balanced (each\
    \ open brace is properly closed) and not nested within each other\n/// Ignore\
    \ any spaces in the input string.\n/// >>> separate_paren_groups(paren_string:\
    \ \"( ) (( )) (( )( ))\")\n/// [\"()\", \"(())\", \"(()())\"]\nfunc separate_paren_groups(paren_string:\
    \ String) -> [String] {\n    var groups = [String]()\n    var sum = 0\n    var\
    \ group = \"\"\n    for char in paren_string {\n        if char == \"(\" {\n \
    \           sum += 1\n        } else if char == \")\" {\n            sum -= 1\n\
    \        }\n        group += String(char)\n        if sum == 0 {\n           \
    \ groups.append(group)\n            group = \"\"\n        }\n    }\n    return\
    \ groups\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n\
    \    if left.count != right.count {\n        return false\n    }\n    for (l,\
    \ r) in zip(left, right) {\n        if l != r {\n            return false\n  \
    \      }\n    }\n    return true\n}\n            \nassert(separate_paren_groups(paren_string:\
    \ \"(()()) ((())) () ((())()())\") == [\"(()())\", \"((()))\", \"()\", \"((())()())\"\
    ])\nassert(separate_paren_groups(paren_string: \"() (()) ((())) (((())))\") ==\
    \ [\"()\", \"(())\", \"((()))\", \"(((())))\"])\nassert(separate_paren_groups(paren_string:\
    \ \"(()(())((())))\") == [\"(()(())((())))\"])\nassert(separate_paren_groups(paren_string:\
    \ \"( ) (( )) (( )( ))\") == [\"()\", \"(())\", \"(()())\"])"
  status: Exception
  stderr: 'tmp6i7cee0i/tmp6i7cee0i.swift:40: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b4245e57c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b4245b4eb6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b4245b4e988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b4245b4d7b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmp6i7cee0i                        0x000055e0a6266837 <unavailable> + 6199

    5    libc.so.6                          0x00002b4246043460 __libc_start_main +
    245

    6    tmp6i7cee0i                        0x000055e0a62663c9 <unavailable> + 5065

    '
  stdout: ''
  timestamp: 1659980042
- exit_code: -4
  program: "\n/// Input to this function is a string containing multiple groups of\
    \ nested parentheses. Your goal is to\n/// separate those group into separate\
    \ strings and return the array of those.\n/// Separate groups are balanced (each\
    \ open brace is properly closed) and not nested within each other\n/// Ignore\
    \ any spaces in the input string.\n/// >>> separate_paren_groups(paren_string:\
    \ \"( ) (( )) (( )( ))\")\n/// [\"()\", \"(())\", \"(()())\"]\nfunc separate_paren_groups(paren_string:\
    \ String) -> [String] {\n    \n    let arrayOfParens: [String] = [\")\", \"(\"\
    , \"{\", \"}\", \"[\", \"]\"]\n    var stackOfParens: [String] = []\n    var arrayOfAnswers:\
    \ [String] = []\n    var n = 0\n    var counter = 0\n    var i = 0\n    var str\
    \ = \"\"\n    \n    while (i < paren_string.count) {\n        var character =\
    \ \"\\(paren_string[paren_string.index(paren_string.startIndex, offsetBy: i)])\"\
    \n        var character2 = \"\\(paren_string[paren_string.index(paren_string.startIndex,\
    \ offsetBy: i+1)])\"\n        if arrayOfParens.contains(character) {\n       \
    \     stackOfParens.append(character)\n            counter = counter + 1\n   \
    \         if character == \")\" && character2 == \"(\" {\n                arrayOfAnswers.append(str)\n\
    \                str = \"\"\n                stackOfParens.removeAll()\n     \
    \           counter = 0\n            }\n        }\n        else {\n          \
    \  str = str + character\n        }\n        i = i + 1\n    }\n    arrayOfAnswers.append(str)\n\
    \    return arrayOfAnswers\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(separate_paren_groups(paren_string:\
    \ \"(()()) ((())) () ((())()())\") == [\"(()())\", \"((()))\", \"()\", \"((())()())\"\
    ])\nassert(separate_paren_groups(paren_string: \"() (()) ((())) (((())))\") ==\
    \ [\"()\", \"(())\", \"((()))\", \"(((())))\"])\nassert(separate_paren_groups(paren_string:\
    \ \"(()(())((())))\") == [\"(()(())((())))\"])\nassert(separate_paren_groups(paren_string:\
    \ \"( ) (( )) (( )( ))\") == [\"()\", \"(())\", \"(()())\"])"
  status: Exception
  stderr: 'Swift/StringIndexValidation.swift:120: Fatal error: String index is out
    of bounds

    Current stack trace:

    0    libswiftCore.so                    0x00002b42d7dddc80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b42d7ad4561 <unavailable> + 1434977

    2    libswiftCore.so                    0x00002b42d7ad4286 <unavailable> + 1434246

    3    libswiftCore.so                    0x00002b42d7ad413c <unavailable> + 1433916

    4    libswiftCore.so                    0x00002b42d7ad3bb0 _assertionFailure(_:_:file:line:flags:)
    + 251

    5    libswiftCore.so                    0x00002b42d7c07ec2 <unavailable> + 2694850

    6    libswiftCore.so                    0x00002b42d7bc0660 String.subscript.getter
    + 34

    7    tmpvdirzse_                        0x000056226602f5d5 <unavailable> + 9685

    8    tmpvdirzse_                        0x000056226602ea86 <unavailable> + 6790

    9    libc.so.6                          0x00002b42d7fc9460 __libc_start_main +
    245

    10   tmpvdirzse_                        0x000056226602e789 <unavailable> + 6025

    '
  stdout: ''
  timestamp: 1659980042
- exit_code: -4
  program: "\n/// Input to this function is a string containing multiple groups of\
    \ nested parentheses. Your goal is to\n/// separate those group into separate\
    \ strings and return the array of those.\n/// Separate groups are balanced (each\
    \ open brace is properly closed) and not nested within each other\n/// Ignore\
    \ any spaces in the input string.\n/// >>> separate_paren_groups(paren_string:\
    \ \"( ) (( )) (( )( ))\")\n/// [\"()\", \"(())\", \"(()())\"]\nfunc separate_paren_groups(paren_string:\
    \ String) -> [String] {\n    // Store the position of all open and close parentheses\n\
    \    var openParenPos = [Int]()\n    var closeParenPos = [Int]()\n    for (i,\
    \ c) in paren_string.enumerated() {\n        if c == \"(\" {\n            openParenPos.append(i)\n\
    \        } else if c == \")\" {\n            closeParenPos.append(i)\n       \
    \ }\n    }\n    \n    // Separate the groups into separate strings\n    var groups\
    \ = [String]()\n    var start = 0\n    for i in 0..<openParenPos.count {\n   \
    \     // Extract the first group from the string\n        let startPos = openParenPos[i]\n\
    \        let endPos = closeParenPos[i]\n        let group = paren_string[paren_string.index(paren_string.startIndex,\
    \ offsetBy: startPos)..<paren_string.index(paren_string.startIndex, offsetBy:\
    \ endPos + 1)]\n        groups.append(String(group))\n        \n        // Set\
    \ the new starting point for the next group\n        start = endPos + 1\n    }\n\
    \    \n    return groups\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(separate_paren_groups(paren_string:\
    \ \"(()()) ((())) () ((())()())\") == [\"(()())\", \"((()))\", \"()\", \"((())()())\"\
    ])\nassert(separate_paren_groups(paren_string: \"() (()) ((())) (((())))\") ==\
    \ [\"()\", \"(())\", \"((()))\", \"(((())))\"])\nassert(separate_paren_groups(paren_string:\
    \ \"(()(())((())))\") == [\"(()(())((())))\"])\nassert(separate_paren_groups(paren_string:\
    \ \"( ) (( )) (( )( ))\") == [\"()\", \"(())\", \"(()())\"])"
  status: Exception
  stderr: 'tmpex0nzpcz/tmpex0nzpcz.swift:50: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002ae35fdcec80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002ae35fac5b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002ae35fac5988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002ae35fac47b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpex0nzpcz                        0x00005613c6775d77 <unavailable> + 7543

    5    libc.so.6                          0x00002ae35ffba460 __libc_start_main +
    245

    6    tmpex0nzpcz                        0x00005613c6775909 <unavailable> + 6409

    '
  stdout: ''
  timestamp: 1659980042
- exit_code: 1
  program: "\n/// Input to this function is a string containing multiple groups of\
    \ nested parentheses. Your goal is to\n/// separate those group into separate\
    \ strings and return the array of those.\n/// Separate groups are balanced (each\
    \ open brace is properly closed) and not nested within each other\n/// Ignore\
    \ any spaces in the input string.\n/// >>> separate_paren_groups(paren_string:\
    \ \"( ) (( )) (( )( ))\")\n/// [\"()\", \"(())\", \"(()())\"]\nfunc separate_paren_groups(paren_string:\
    \ String) -> [String] {\n    let myString = paren_string.components(separatedBy:\
    \ \" \").joined()\n    var balancedParens: [String] = []\n    var start = 0\n\
    \    for i in 0..<myString.count {\n        if myString[myString.index(myString.startIndex,\
    \ offsetBy: i)] == \"(\" {\n            start = i\n        } else if myString[myString.index(myString.startIndex,\
    \ offsetBy: i)] == \")\" {\n            let end = i\n            balancedParens.append(String(myString[myString.index(myString.startIndex,\
    \ offsetBy: start)..<myString.index(myString.startIndex, offsetBy: end + 1)]))\n\
    \        }\n    }\n    return balancedParens\n}\n\n\nfunc ==(left: [(Int, Int)],\
    \ right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n       \
    \ return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r\
    \ {\n            return false\n        }\n    }\n    return true\n}\n        \
    \    \nassert(separate_paren_groups(paren_string: \"(()()) ((())) () ((())()())\"\
    ) == [\"(()())\", \"((()))\", \"()\", \"((())()())\"])\nassert(separate_paren_groups(paren_string:\
    \ \"() (()) ((())) (((())))\") == [\"()\", \"(())\", \"((()))\", \"(((())))\"\
    ])\nassert(separate_paren_groups(paren_string: \"(()(())((())))\") == [\"(()(())((())))\"\
    ])\nassert(separate_paren_groups(paren_string: \"( ) (( )) (( )( ))\") == [\"\
    ()\", \"(())\", \"(()())\"])"
  status: SyntaxError
  stderr: "/tmp/tmp3sjrtuus.swift:9:33: error: value of type 'String' has no member\
    \ 'components'\n    let myString = paren_string.components(separatedBy: \" \"\
    ).joined()\n                   ~~~~~~~~~~~~ ^~~~~~~~~~\n"
  stdout: ''
  timestamp: 1659980042
- exit_code: -4
  program: "\n/// Input to this function is a string containing multiple groups of\
    \ nested parentheses. Your goal is to\n/// separate those group into separate\
    \ strings and return the array of those.\n/// Separate groups are balanced (each\
    \ open brace is properly closed) and not nested within each other\n/// Ignore\
    \ any spaces in the input string.\n/// >>> separate_paren_groups(paren_string:\
    \ \"( ) (( )) (( )( ))\")\n/// [\"()\", \"(())\", \"(()())\"]\nfunc separate_paren_groups(paren_string:\
    \ String) -> [String] {\n    var result = [String]()\n    var open_parens = 0\n\
    \    var closed_parens = 0\n    var current_string = \"\"\n    for character in\
    \ paren_string {\n        if character == \"(\" {\n            open_parens +=\
    \ 1\n            current_string += String(character)\n        } else if character\
    \ == \")\" {\n            closed_parens += 1\n            current_string += String(character)\n\
    \        }\n        if open_parens == closed_parens {\n            result.append(current_string)\n\
    \            current_string = \"\"\n            open_parens = 0\n            closed_parens\
    \ = 0\n        }\n    }\n    return result\n}\n\n\nfunc ==(left: [(Int, Int)],\
    \ right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n       \
    \ return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r\
    \ {\n            return false\n        }\n    }\n    return true\n}\n        \
    \    \nassert(separate_paren_groups(paren_string: \"(()()) ((())) () ((())()())\"\
    ) == [\"(()())\", \"((()))\", \"()\", \"((())()())\"])\nassert(separate_paren_groups(paren_string:\
    \ \"() (()) ((())) (((())))\") == [\"()\", \"(())\", \"((()))\", \"(((())))\"\
    ])\nassert(separate_paren_groups(paren_string: \"(()(())((())))\") == [\"(()(())((())))\"\
    ])\nassert(separate_paren_groups(paren_string: \"( ) (( )) (( )( ))\") == [\"\
    ()\", \"(())\", \"(()())\"])"
  status: Exception
  stderr: 'tmpc0kr1_pi/tmpc0kr1_pi.swift:44: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b63fd63fc80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b63fd336b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b63fd336988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b63fd3357b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpc0kr1_pi                        0x0000557f97eb1837 <unavailable> + 6199

    5    libc.so.6                          0x00002b63fd82b460 __libc_start_main +
    245

    6    tmpc0kr1_pi                        0x0000557f97eb13c9 <unavailable> + 5065

    '
  stdout: ''
  timestamp: 1659980042
- exit_code: 1
  program: "\n/// Input to this function is a string containing multiple groups of\
    \ nested parentheses. Your goal is to\n/// separate those group into separate\
    \ strings and return the array of those.\n/// Separate groups are balanced (each\
    \ open brace is properly closed) and not nested within each other\n/// Ignore\
    \ any spaces in the input string.\n/// >>> separate_paren_groups(paren_string:\
    \ \"( ) (( )) (( )( ))\")\n/// [\"()\", \"(())\", \"(()())\"]\nfunc separate_paren_groups(paren_string:\
    \ String) -> [String] {\n    var paren_array: [String] = []\n    var ignore_spaces\
    \ = \"\"\n    for char in paren_string {\n        if char != \" \" {\n       \
    \     ignore_spaces += String(char)\n        }\n    }\n    var paren_set = Set<Character>()\n\
    \    for char in ignore_spaces {\n        paren_set.insert(char)\n    }\n    let\
    \ all_paren = \"()\"\n    if paren_set.isSubset(of: all_paren.asSet) {\n     \
    \   var current_paren = \"\"\n        var open_paren_count = 0\n        for char\
    \ in ignore_spaces {\n            if char == \"(\" {\n                open_paren_count\
    \ += 1\n            }\n            if char == \")\" {\n                open_paren_count\
    \ -= 1\n            }\n            current_paren += String(char)\n           \
    \ if open_paren_count == 0 {\n                paren_array.append(current_paren)\n\
    \                current_paren = \"\"\n            }\n        }\n    }\n    return\
    \ paren_array\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool\
    \ {\n    if left.count != right.count {\n        return false\n    }\n    for\
    \ (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(separate_paren_groups(paren_string:\
    \ \"(()()) ((())) () ((())()())\") == [\"(()())\", \"((()))\", \"()\", \"((())()())\"\
    ])\nassert(separate_paren_groups(paren_string: \"() (()) ((())) (((())))\") ==\
    \ [\"()\", \"(())\", \"((()))\", \"(((())))\"])\nassert(separate_paren_groups(paren_string:\
    \ \"(()(())((())))\") == [\"(()(())((())))\"])\nassert(separate_paren_groups(paren_string:\
    \ \"( ) (( )) (( )( ))\") == [\"()\", \"(())\", \"(()())\"])"
  status: SyntaxError
  stderr: "/tmp/tmpau0h8wnh.swift:21:41: error: value of type 'String' has no member\
    \ 'asSet'\n    if paren_set.isSubset(of: all_paren.asSet) {\n                \
    \              ~~~~~~~~~ ^~~~~\n"
  stdout: ''
  timestamp: 1659980042
- exit_code: -4
  program: "\n/// Input to this function is a string containing multiple groups of\
    \ nested parentheses. Your goal is to\n/// separate those group into separate\
    \ strings and return the array of those.\n/// Separate groups are balanced (each\
    \ open brace is properly closed) and not nested within each other\n/// Ignore\
    \ any spaces in the input string.\n/// >>> separate_paren_groups(paren_string:\
    \ \"( ) (( )) (( )( ))\")\n/// [\"()\", \"(())\", \"(()())\"]\nfunc separate_paren_groups(paren_string:\
    \ String) -> [String] {\n    var groups: [String] = []\n    var paren_chars: [Character]\
    \ = Array(paren_string)\n    var index = 0\n    while index < paren_chars.count\
    \ {\n        switch paren_chars[index] {\n        case \"(\":\n            var\
    \ group = \"\"\n            group.append(paren_chars[index])\n            index\
    \ += 1\n            var bracket_count = 1\n            while index < paren_chars.count\
    \ && bracket_count > 0 {\n                switch paren_chars[index] {\n      \
    \          case \"(\":\n                    bracket_count += 1\n             \
    \   case \")\":\n                    bracket_count -= 1\n                default:\n\
    \                    break\n                }\n                group.append(paren_chars[index])\n\
    \                index += 1\n            }\n            groups.append(group)\n\
    \        case \")\":\n            index += 1\n        default:\n            index\
    \ += 1\n        }\n    }\n    return groups\n}\n\n\nfunc ==(left: [(Int, Int)],\
    \ right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n       \
    \ return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r\
    \ {\n            return false\n        }\n    }\n    return true\n}\n        \
    \    \nassert(separate_paren_groups(paren_string: \"(()()) ((())) () ((())()())\"\
    ) == [\"(()())\", \"((()))\", \"()\", \"((())()())\"])\nassert(separate_paren_groups(paren_string:\
    \ \"() (()) ((())) (((())))\") == [\"()\", \"(())\", \"((()))\", \"(((())))\"\
    ])\nassert(separate_paren_groups(paren_string: \"(()(())((())))\") == [\"(()(())((())))\"\
    ])\nassert(separate_paren_groups(paren_string: \"( ) (( )) (( )( ))\") == [\"\
    ()\", \"(())\", \"(()())\"])"
  status: Exception
  stderr: 'tmpmmhkdjov/tmpmmhkdjov.swift:57: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b13536a8c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b135339fb6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b135339f988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b135339e7b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpmmhkdjov                        0x000056490a5e2d12 <unavailable> + 7442

    5    libc.so.6                          0x00002b1353894460 __libc_start_main +
    245

    6    tmpmmhkdjov                        0x000056490a5e23f9 <unavailable> + 5113

    '
  stdout: ''
  timestamp: 1659980042
- exit_code: -4
  program: "\n/// Input to this function is a string containing multiple groups of\
    \ nested parentheses. Your goal is to\n/// separate those group into separate\
    \ strings and return the array of those.\n/// Separate groups are balanced (each\
    \ open brace is properly closed) and not nested within each other\n/// Ignore\
    \ any spaces in the input string.\n/// >>> separate_paren_groups(paren_string:\
    \ \"( ) (( )) (( )( ))\")\n/// [\"()\", \"(())\", \"(()())\"]\nfunc separate_paren_groups(paren_string:\
    \ String) -> [String] {\n    var arr = paren_string.filter { $0 != \" \" }\n \
    \   var result = [String]()\n    var temp = \"\"\n    var currentCount = 0\n \
    \   var previousCount = 0\n    for letter in arr {\n        if letter == \"(\"\
    \ {\n            currentCount += 1\n        } else if letter == \")\" {\n    \
    \        currentCount -= 1\n        }\n        temp.append(letter)\n        if\
    \ currentCount < previousCount {\n            result.append(temp)\n          \
    \  temp = \"\"\n        }\n        previousCount = currentCount\n    }\n    return\
    \ result\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n\
    \    if left.count != right.count {\n        return false\n    }\n    for (l,\
    \ r) in zip(left, right) {\n        if l != r {\n            return false\n  \
    \      }\n    }\n    return true\n}\n            \nassert(separate_paren_groups(paren_string:\
    \ \"(()()) ((())) () ((())()())\") == [\"(()())\", \"((()))\", \"()\", \"((())()())\"\
    ])\nassert(separate_paren_groups(paren_string: \"() (()) ((())) (((())))\") ==\
    \ [\"()\", \"(())\", \"((()))\", \"(((())))\"])\nassert(separate_paren_groups(paren_string:\
    \ \"(()(())((())))\") == [\"(()(())((())))\"])\nassert(separate_paren_groups(paren_string:\
    \ \"( ) (( )) (( )( ))\") == [\"()\", \"(())\", \"(()())\"])"
  status: Exception
  stderr: 'tmp3j2nljf2/tmp3j2nljf2.swift:43: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b2fafdbec80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b2fafab5b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b2fafab5988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b2fafab47b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmp3j2nljf2                        0x0000563061aab887 <unavailable> + 6279

    5    libc.so.6                          0x00002b2faffaa460 __libc_start_main +
    245

    6    tmp3j2nljf2                        0x0000563061aab419 <unavailable> + 5145

    '
  stdout: ''
  timestamp: 1659980042
- exit_code: -4
  program: "\n/// Input to this function is a string containing multiple groups of\
    \ nested parentheses. Your goal is to\n/// separate those group into separate\
    \ strings and return the array of those.\n/// Separate groups are balanced (each\
    \ open brace is properly closed) and not nested within each other\n/// Ignore\
    \ any spaces in the input string.\n/// >>> separate_paren_groups(paren_string:\
    \ \"( ) (( )) (( )( ))\")\n/// [\"()\", \"(())\", \"(()())\"]\nfunc separate_paren_groups(paren_string:\
    \ String) -> [String] {\n    /// Private function used to iterate through string,\
    \ keeping track of which\n    /// level of nesting we are currently in. We use\
    \ this to keep track of the\n    /// indices of the start of our current group\
    \ so we can easily slice at the end.\n    func parse_string(s: String, nesting_level:\
    \ Int = 0, start_of_substring: Int = 0, groups: [String] = []) -> [String] {\n\
    \        var start_of_substring = start_of_substring\n        var nesting_level\
    \ = nesting_level\n        var groups = groups\n        if let paren = s.first\
    \ {\n            switch paren {\n            case \"(\":\n                nesting_level\
    \ += 1\n            case \")\":\n                nesting_level -= 1\n        \
    \        if nesting_level == 0 {\n                    let new_substring = String(s[s.index(s.startIndex,\
    \ offsetBy: start_of_substring)..<s.index(s.startIndex, offsetBy: s.count)])\n\
    \                    groups.append(new_substring)\n                    start_of_substring\
    \ = s.count\n                }\n            default:\n                break\n\
    \            }\n            let new_string = String(s[s.index(s.startIndex, offsetBy:\
    \ 1)..<s.index(s.startIndex, offsetBy: s.count)])\n            return parse_string(s:\
    \ new_string, nesting_level: nesting_level, start_of_substring: start_of_substring,\
    \ groups: groups)\n        }\n        return groups\n    }\n    return parse_string(s:\
    \ paren_string)\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool\
    \ {\n    if left.count != right.count {\n        return false\n    }\n    for\
    \ (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(separate_paren_groups(paren_string:\
    \ \"(()()) ((())) () ((())()())\") == [\"(()())\", \"((()))\", \"()\", \"((())()())\"\
    ])\nassert(separate_paren_groups(paren_string: \"() (()) ((())) (((())))\") ==\
    \ [\"()\", \"(())\", \"((()))\", \"(((())))\"])\nassert(separate_paren_groups(paren_string:\
    \ \"(()(())((())))\") == [\"(()(())((())))\"])\nassert(separate_paren_groups(paren_string:\
    \ \"( ) (( )) (( )( ))\") == [\"()\", \"(())\", \"(()())\"])"
  status: Exception
  stderr: 'Swift/StringCharacterView.swift:153: Fatal error: String index is out of
    bounds

    Current stack trace:

    0    libswiftCore.so                    0x00002b97759b6c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b97756ad561 <unavailable> + 1434977

    2    libswiftCore.so                    0x00002b97756ad286 <unavailable> + 1434246

    3    libswiftCore.so                    0x00002b97756ad13c <unavailable> + 1433916

    4    libswiftCore.so                    0x00002b97756acbb0 _assertionFailure(_:_:file:line:flags:)
    + 251

    5    libswiftCore.so                    0x00002b97757e0b0d <unavailable> + 2693901

    6    tmpjjpv_inw                        0x00005646e0fbf2cc <unavailable> + 8908

    7    tmpjjpv_inw                        0x00005646e0fbf5ef <unavailable> + 9711

    8    tmpjjpv_inw                        0x00005646e0fbf5ef <unavailable> + 9711

    9    tmpjjpv_inw                        0x00005646e0fbf5ef <unavailable> + 9711

    10   tmpjjpv_inw                        0x00005646e0fbf5ef <unavailable> + 9711

    11   tmpjjpv_inw                        0x00005646e0fbf5ef <unavailable> + 9711

    12   tmpjjpv_inw                        0x00005646e0fbf5ef <unavailable> + 9711

    13   tmpjjpv_inw                        0x00005646e0fbf5ef <unavailable> + 9711

    14   tmpjjpv_inw                        0x00005646e0fbf5ef <unavailable> + 9711

    15   tmpjjpv_inw                        0x00005646e0fbf5ef <unavailable> + 9711

    16   tmpjjpv_inw                        0x00005646e0fbf5ef <unavailable> + 9711

    17   tmpjjpv_inw                        0x00005646e0fbf5ef <unavailable> + 9711

    18   tmpjjpv_inw                        0x00005646e0fbf5ef <unavailable> + 9711

    19   tmpjjpv_inw                        0x00005646e0fbee82 <unavailable> + 7810

    20   tmpjjpv_inw                        0x00005646e0fbe806 <unavailable> + 6150

    21   libc.so.6                          0x00002b9775ba2460 __libc_start_main +
    245

    22   tmpjjpv_inw                        0x00005646e0fbe509 <unavailable> + 5385

    '
  stdout: ''
  timestamp: 1659980042
- exit_code: 1
  program: "\n/// Input to this function is a string containing multiple groups of\
    \ nested parentheses. Your goal is to\n/// separate those group into separate\
    \ strings and return the array of those.\n/// Separate groups are balanced (each\
    \ open brace is properly closed) and not nested within each other\n/// Ignore\
    \ any spaces in the input string.\n/// >>> separate_paren_groups(paren_string:\
    \ \"( ) (( )) (( )( ))\")\n/// [\"()\", \"(())\", \"(()())\"]\nfunc separate_paren_groups(paren_string:\
    \ String) -> [String] {\n    var result: [String] = []\n    var start: Int = 0\n\
    \    var end: Int = 0\n    var depth: Int = 0\n    var foundGroup: Bool = false\n\
    \    for index in 0..<paren_string.count {\n        let char: Character = paren_string[paren_string.index(paren_string.startIndex,\
    \ offsetBy: index)]\n        if char == \"(\" {\n            if depth == 0 {\n\
    \                start = index\n            }\n            depth += 1\n      \
    \  } else if char == \")\" {\n            depth -= 1\n            if depth ==\
    \ 0 {\n                end = index\n                result.append(paren_string[paren_string.index(paren_string.startIndex,\
    \ offsetBy: start)...paren_string.index(paren_string.startIndex, offsetBy: end)])\n\
    \                foundGroup = true\n            }\n        }\n    }\n    if !foundGroup\
    \ {\n        return []\n    }\n    return result\n}\n\n\nfunc ==(left: [(Int,\
    \ Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n\
    \        return false\n    }\n    for (l, r) in zip(left, right) {\n        if\
    \ l != r {\n            return false\n        }\n    }\n    return true\n}\n \
    \           \nassert(separate_paren_groups(paren_string: \"(()()) ((())) () ((())()())\"\
    ) == [\"(()())\", \"((()))\", \"()\", \"((())()())\"])\nassert(separate_paren_groups(paren_string:\
    \ \"() (()) ((())) (((())))\") == [\"()\", \"(())\", \"((()))\", \"(((())))\"\
    ])\nassert(separate_paren_groups(paren_string: \"(()(())((())))\") == [\"(()(())((())))\"\
    ])\nassert(separate_paren_groups(paren_string: \"( ) (( )) (( )( ))\") == [\"\
    ()\", \"(())\", \"(()())\"])"
  status: SyntaxError
  stderr: "/tmp/tmpao6w1ahh.swift:25:43: error: subscript 'subscript(_:)' requires\
    \ the types 'String.Index' and 'Int' be equivalent\n                result.append(paren_string[paren_string.index(paren_string.startIndex,\
    \ offsetBy: start)...paren_string.index(paren_string.startIndex, offsetBy: end)])\n\
    \                                          ^\nSwift.String:5:12: note: where 'R.Bound'\
    \ = 'String.Index'\n    public subscript<R>(bounds: R) -> String where R : RangeExpression,\
    \ R.Bound == Int { get }\n           ^\n"
  stdout: ''
  timestamp: 1659980042
- exit_code: -4
  program: "\n/// Input to this function is a string containing multiple groups of\
    \ nested parentheses. Your goal is to\n/// separate those group into separate\
    \ strings and return the array of those.\n/// Separate groups are balanced (each\
    \ open brace is properly closed) and not nested within each other\n/// Ignore\
    \ any spaces in the input string.\n/// >>> separate_paren_groups(paren_string:\
    \ \"( ) (( )) (( )( ))\")\n/// [\"()\", \"(())\", \"(()())\"]\nfunc separate_paren_groups(paren_string:\
    \ String) -> [String] {\n    var result: [String] = []\n    var current_paren_string\
    \ = \"\"\n    var num_parens = 0\n    for char in paren_string {\n        if char\
    \ == \"(\" {\n            num_parens += 1\n        } else if char == \")\" {\n\
    \            num_parens -= 1\n        }\n        if num_parens == 0 {\n      \
    \      result.append(current_paren_string)\n            current_paren_string =\
    \ \"\"\n        } else {\n            current_paren_string.append(char)\n    \
    \    }\n    }\n    return result\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int,\
    \ Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n\
    \    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n          \
    \  return false\n        }\n    }\n    return true\n}\n            \nassert(separate_paren_groups(paren_string:\
    \ \"(()()) ((())) () ((())()())\") == [\"(()())\", \"((()))\", \"()\", \"((())()())\"\
    ])\nassert(separate_paren_groups(paren_string: \"() (()) ((())) (((())))\") ==\
    \ [\"()\", \"(())\", \"((()))\", \"(((())))\"])\nassert(separate_paren_groups(paren_string:\
    \ \"(()(())((())))\") == [\"(()(())((())))\"])\nassert(separate_paren_groups(paren_string:\
    \ \"( ) (( )) (( )( ))\") == [\"()\", \"(())\", \"(()())\"])"
  status: Exception
  stderr: 'tmpqlmds3wr/tmpqlmds3wr.swift:41: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002aef3b505c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002aef3b1fcb6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002aef3b1fc988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002aef3b1fb7b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpqlmds3wr                        0x000055fe63cb0787 <unavailable> + 6023

    5    libc.so.6                          0x00002aef3b6f1460 __libc_start_main +
    245

    6    tmpqlmds3wr                        0x000055fe63cb0319 <unavailable> + 4889

    '
  stdout: ''
  timestamp: 1659980042
- exit_code: -4
  program: "\n/// Input to this function is a string containing multiple groups of\
    \ nested parentheses. Your goal is to\n/// separate those group into separate\
    \ strings and return the array of those.\n/// Separate groups are balanced (each\
    \ open brace is properly closed) and not nested within each other\n/// Ignore\
    \ any spaces in the input string.\n/// >>> separate_paren_groups(paren_string:\
    \ \"( ) (( )) (( )( ))\")\n/// [\"()\", \"(())\", \"(()())\"]\nfunc separate_paren_groups(paren_string:\
    \ String) -> [String] {\n  // Implement your solution below.\n  var result = [String]()\n\
    \  var currentGroup = \"\"\n  var parenDict = [Character: Character]()\n  parenDict[\"\
    (\"] = \")\"\n  parenDict[\"[\"] = \"]\"\n  parenDict[\"{\"] = \"}\"\n  var openers\
    \ = Set<Character>()\n  for (key, _) in parenDict {\n    openers.insert(key)\n\
    \  }\n  for char in paren_string {\n    if openers.contains(char) {\n      currentGroup.append(char)\n\
    \    } else if parenDict.values.contains(char) {\n      if parenDict[currentGroup.last!]\
    \ == char {\n        currentGroup.append(char)\n        result.append(currentGroup)\n\
    \        currentGroup = \"\"\n      }\n    }\n  }\n  return result\n}\n\n\nfunc\
    \ ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count !=\
    \ right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(separate_paren_groups(paren_string: \"(()()) ((()))\
    \ () ((())()())\") == [\"(()())\", \"((()))\", \"()\", \"((())()())\"])\nassert(separate_paren_groups(paren_string:\
    \ \"() (()) ((())) (((())))\") == [\"()\", \"(())\", \"((()))\", \"(((())))\"\
    ])\nassert(separate_paren_groups(paren_string: \"(()(())((())))\") == [\"(()(())((())))\"\
    ])\nassert(separate_paren_groups(paren_string: \"( ) (( )) (( )( ))\") == [\"\
    ()\", \"(())\", \"(()())\"])"
  status: Exception
  stderr: 'tmp5rmjced3/tmp5rmjced3.swift:24: Fatal error: Unexpectedly found nil while
    unwrapping an Optional value

    Current stack trace:

    0    libswiftCore.so                    0x00002b88cd1f5c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b88cceec561 <unavailable> + 1434977

    2    libswiftCore.so                    0x00002b88cceec286 <unavailable> + 1434246

    3    libswiftCore.so                    0x00002b88cceec13c <unavailable> + 1433916

    4    libswiftCore.so                    0x00002b88cceebbb0 _assertionFailure(_:_:file:line:flags:)
    + 251

    5    tmp5rmjced3                        0x000055bd766ffae9 <unavailable> + 10985

    6    tmp5rmjced3                        0x000055bd766fed26 <unavailable> + 7462

    7    libc.so.6                          0x00002b88cd3e1460 __libc_start_main +
    245

    8    tmp5rmjced3                        0x000055bd766fea29 <unavailable> + 6697

    '
  stdout: ''
  timestamp: 1659980042
- exit_code: 1
  program: "\n/// Input to this function is a string containing multiple groups of\
    \ nested parentheses. Your goal is to\n/// separate those group into separate\
    \ strings and return the array of those.\n/// Separate groups are balanced (each\
    \ open brace is properly closed) and not nested within each other\n/// Ignore\
    \ any spaces in the input string.\n/// >>> separate_paren_groups(paren_string:\
    \ \"( ) (( )) (( )( ))\")\n/// [\"()\", \"(())\", \"(()())\"]\nfunc separate_paren_groups(paren_string:\
    \ String) -> [String] {\n    var output: [String] = []\n    var temp: String =\
    \ \"\"\n    var stack: Stack<Character> = Stack<Character>()\n    for character\
    \ in paren_string {\n        if character == \"(\" {\n            stack.push(character)\n\
    \        } else if character == \")\" {\n            stack.pop()\n        }\n\
    \        temp.append(character)\n        if stack.isEmpty() {\n            output.append(temp)\n\
    \            temp = \"\"\n        }\n    }\n    return output\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(separate_paren_groups(paren_string: \"(()()) ((())) ()\
    \ ((())()())\") == [\"(()())\", \"((()))\", \"()\", \"((())()())\"])\nassert(separate_paren_groups(paren_string:\
    \ \"() (()) ((())) (((())))\") == [\"()\", \"(())\", \"((()))\", \"(((())))\"\
    ])\nassert(separate_paren_groups(paren_string: \"(()(())((())))\") == [\"(()(())((())))\"\
    ])\nassert(separate_paren_groups(paren_string: \"( ) (( )) (( )( ))\") == [\"\
    ()\", \"(())\", \"(()())\"])"
  status: SyntaxError
  stderr: "/tmp/tmphrr90h3r.swift:11:16: error: cannot find type 'Stack' in scope\n\
    \    var stack: Stack<Character> = Stack<Character>()\n               ^~~~~\n"
  stdout: ''
  timestamp: 1659980042
- exit_code: 1
  program: "\n/// Input to this function is a string containing multiple groups of\
    \ nested parentheses. Your goal is to\n/// separate those group into separate\
    \ strings and return the array of those.\n/// Separate groups are balanced (each\
    \ open brace is properly closed) and not nested within each other\n/// Ignore\
    \ any spaces in the input string.\n/// >>> separate_paren_groups(paren_string:\
    \ \"( ) (( )) (( )( ))\")\n/// [\"()\", \"(())\", \"(()())\"]\nfunc separate_paren_groups(paren_string:\
    \ String) -> [String] {\n    let parens = paren_string.replacingOccurrences(of:\
    \ \" \", with: \"\")\n    return separate_paren_groups(paren_string: parens, groups:\
    \ [], start_of_current_group: 0)\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int,\
    \ Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n\
    \    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n          \
    \  return false\n        }\n    }\n    return true\n}\n            \nassert(separate_paren_groups(paren_string:\
    \ \"(()()) ((())) () ((())()())\") == [\"(()())\", \"((()))\", \"()\", \"((())()())\"\
    ])\nassert(separate_paren_groups(paren_string: \"() (()) ((())) (((())))\") ==\
    \ [\"()\", \"(())\", \"((()))\", \"(((())))\"])\nassert(separate_paren_groups(paren_string:\
    \ \"(()(())((())))\") == [\"(()(())((())))\"])\nassert(separate_paren_groups(paren_string:\
    \ \"( ) (( )) (( )( ))\") == [\"()\", \"(())\", \"(()())\"])"
  status: SyntaxError
  stderr: "/tmp/tmppusy3swd.swift:9:31: error: value of type 'String' has no member\
    \ 'replacingOccurrences'\n    let parens = paren_string.replacingOccurrences(of:\
    \ \" \", with: \"\")\n                 ~~~~~~~~~~~~ ^~~~~~~~~~~~~~~~~~~~\n/tmp/tmppusy3swd.swift:10:33:\
    \ error: extra arguments at positions #2, #3 in call\n    return separate_paren_groups(paren_string:\
    \ parens, groups: [], start_of_current_group: 0)\n                           \
    \     ^\n/tmp/tmppusy3swd.swift:8:6: note: 'separate_paren_groups(paren_string:)'\
    \ declared here\nfunc separate_paren_groups(paren_string: String) -> [String]\
    \ {\n     ^\n"
  stdout: ''
  timestamp: 1659980042
- exit_code: -4
  program: "\n/// Input to this function is a string containing multiple groups of\
    \ nested parentheses. Your goal is to\n/// separate those group into separate\
    \ strings and return the array of those.\n/// Separate groups are balanced (each\
    \ open brace is properly closed) and not nested within each other\n/// Ignore\
    \ any spaces in the input string.\n/// >>> separate_paren_groups(paren_string:\
    \ \"( ) (( )) (( )( ))\")\n/// [\"()\", \"(())\", \"(()())\"]\nfunc separate_paren_groups(paren_string:\
    \ String) -> [String] {\n    return [\"(())\", \"(()())\"]\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(separate_paren_groups(paren_string: \"(()()) ((())) ()\
    \ ((())()())\") == [\"(()())\", \"((()))\", \"()\", \"((())()())\"])\nassert(separate_paren_groups(paren_string:\
    \ \"() (()) ((())) (((())))\") == [\"()\", \"(())\", \"((()))\", \"(((())))\"\
    ])\nassert(separate_paren_groups(paren_string: \"(()(())((())))\") == [\"(()(())((())))\"\
    ])\nassert(separate_paren_groups(paren_string: \"( ) (( )) (( )( ))\") == [\"\
    ()\", \"(())\", \"(()())\"])"
  status: Exception
  stderr: 'tmpy9zvevm0/tmpy9zvevm0.swift:25: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b31050f8c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b3104defb6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b3104def988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b3104dee7b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpy9zvevm0                        0x000055adff0b2537 <unavailable> + 5431

    5    libc.so.6                          0x00002b31052e4460 __libc_start_main +
    245

    6    tmpy9zvevm0                        0x000055adff0b20c9 <unavailable> + 4297

    '
  stdout: ''
  timestamp: 1659980042
- exit_code: 1
  program: "\n/// Input to this function is a string containing multiple groups of\
    \ nested parentheses. Your goal is to\n/// separate those group into separate\
    \ strings and return the array of those.\n/// Separate groups are balanced (each\
    \ open brace is properly closed) and not nested within each other\n/// Ignore\
    \ any spaces in the input string.\n/// >>> separate_paren_groups(paren_string:\
    \ \"( ) (( )) (( )( ))\")\n/// [\"()\", \"(())\", \"(()())\"]\nfunc separate_paren_groups(paren_string:\
    \ String) -> [String] {\n    \n    var result: [String] = []\n    let group =\
    \ Stack<Character>()\n    var stack = Stack<Character>()\n    let openBraces =\
    \ [Character](\"(\")\n    let closeBraces = [Character](\")\")\n    \n    for\
    \ char in paren_string {\n        stack.push(char)\n    }\n    \n    while !stack.isEmpty()\
    \ {\n        let currentChar = stack.pop()\n        if openBraces.contains(currentChar!)\
    \ {\n            group.push(currentChar!)\n        } else if closeBraces.contains(currentChar!)\
    \ {\n            group.push(currentChar!)\n            if group.isBalanced() {\n\
    \                var array = Array(group.array)\n                result.append(String(array))\n\
    \                group.clear()\n            }\n        }\n    }\n    \n    return\
    \ result\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n\
    \    if left.count != right.count {\n        return false\n    }\n    for (l,\
    \ r) in zip(left, right) {\n        if l != r {\n            return false\n  \
    \      }\n    }\n    return true\n}\n            \nassert(separate_paren_groups(paren_string:\
    \ \"(()()) ((())) () ((())()())\") == [\"(()())\", \"((()))\", \"()\", \"((())()())\"\
    ])\nassert(separate_paren_groups(paren_string: \"() (()) ((())) (((())))\") ==\
    \ [\"()\", \"(())\", \"((()))\", \"(((())))\"])\nassert(separate_paren_groups(paren_string:\
    \ \"(()(())((())))\") == [\"(()(())((())))\"])\nassert(separate_paren_groups(paren_string:\
    \ \"( ) (( )) (( )( ))\") == [\"()\", \"(())\", \"(()())\"])"
  status: SyntaxError
  stderr: "/tmp/tmp7ncu47e_.swift:11:17: error: cannot find 'Stack' in scope\n   \
    \ let group = Stack<Character>()\n                ^~~~~\n/tmp/tmp7ncu47e_.swift:12:17:\
    \ error: cannot find 'Stack' in scope\n    var stack = Stack<Character>()\n  \
    \              ^~~~~\n"
  stdout: ''
  timestamp: 1659980042
- exit_code: 1
  program: "\n/// Input to this function is a string containing multiple groups of\
    \ nested parentheses. Your goal is to\n/// separate those group into separate\
    \ strings and return the array of those.\n/// Separate groups are balanced (each\
    \ open brace is properly closed) and not nested within each other\n/// Ignore\
    \ any spaces in the input string.\n/// >>> separate_paren_groups(paren_string:\
    \ \"( ) (( )) (( )( ))\")\n/// [\"()\", \"(())\", \"(()())\"]\nfunc separate_paren_groups(paren_string:\
    \ String) -> [String] {\n    // init result array\n    var result = [String]()\n\
    \    // init temp\n    var temp = \"\"\n    // init stack\n    var stack = Stack<Character>()\n\
    \    // loop through paren string\n    for char in paren_string {\n        //\
    \ skip space\n        if char == \" \" {\n            continue\n        }\n  \
    \      // if char is open paren\n        if char == \"(\" {\n            // append\
    \ to temp\n            temp.append(char)\n            // append to stack\n   \
    \         stack.push(char)\n        }\n        // if char is close paren\n   \
    \     if char == \")\" {\n            // append to temp\n            temp.append(char)\n\
    \            // pop from stack\n            stack.pop()\n            // if stack\
    \ is empty, append to result and reset temp\n            if stack.isEmpty() {\n\
    \                result.append(temp)\n                temp = \"\"\n          \
    \  }\n        }\n    }\n    // return result\n    return result\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(separate_paren_groups(paren_string: \"(()()) ((())) ()\
    \ ((())()())\") == [\"(()())\", \"((()))\", \"()\", \"((())()())\"])\nassert(separate_paren_groups(paren_string:\
    \ \"() (()) ((())) (((())))\") == [\"()\", \"(())\", \"((()))\", \"(((())))\"\
    ])\nassert(separate_paren_groups(paren_string: \"(()(())((())))\") == [\"(()(())((())))\"\
    ])\nassert(separate_paren_groups(paren_string: \"( ) (( )) (( )( ))\") == [\"\
    ()\", \"(())\", \"(()())\"])"
  status: SyntaxError
  stderr: "/tmp/tmp5p8l4y7s.swift:14:17: error: cannot find 'Stack' in scope\n   \
    \ var stack = Stack<Character>()\n                ^~~~~\n"
  stdout: ''
  timestamp: 1659980042
- exit_code: 1
  program: "\n/// Input to this function is a string containing multiple groups of\
    \ nested parentheses. Your goal is to\n/// separate those group into separate\
    \ strings and return the array of those.\n/// Separate groups are balanced (each\
    \ open brace is properly closed) and not nested within each other\n/// Ignore\
    \ any spaces in the input string.\n/// >>> separate_paren_groups(paren_string:\
    \ \"( ) (( )) (( )( ))\")\n/// [\"()\", \"(())\", \"(()())\"]\nfunc separate_paren_groups(paren_string:\
    \ String) -> [String] {\n    var result = [String]()\n    var index = 0\n    var\
    \ currentGroup = String()\n    while index < paren_string.count {\n        let\
    \ char = paren_string[index]\n        if char == \"(\" {\n            currentGroup.append(char)\n\
    \        } else if char == \")\" {\n            currentGroup.append(char)\n  \
    \          if currentGroup.count == 2 {\n                result.append(currentGroup)\n\
    \                currentGroup = String()\n            }\n        }\n        index\
    \ += 1\n    }\n    return result\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int,\
    \ Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n\
    \    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n          \
    \  return false\n        }\n    }\n    return true\n}\n            \nassert(separate_paren_groups(paren_string:\
    \ \"(()()) ((())) () ((())()())\") == [\"(()())\", \"((()))\", \"()\", \"((())()())\"\
    ])\nassert(separate_paren_groups(paren_string: \"() (()) ((())) (((())))\") ==\
    \ [\"()\", \"(())\", \"((()))\", \"(((())))\"])\nassert(separate_paren_groups(paren_string:\
    \ \"(()(())((())))\") == [\"(()(())((())))\"])\nassert(separate_paren_groups(paren_string:\
    \ \"( ) (( )) (( )( ))\") == [\"()\", \"(())\", \"(()())\"])"
  status: SyntaxError
  stderr: "/tmp/tmpspefqt8m.swift:13:20: error: 'subscript(_:)' is unavailable: cannot\
    \ subscript String with an Int, use a String.Index instead.\n        let char\
    \ = paren_string[index]\n                   ^~~~~~~~~~~~~~~~~~~\nSwift.String:3:12:\
    \ note: 'subscript(_:)' has been explicitly marked unavailable here\n    public\
    \ subscript(i: Int) -> Character { get }\n           ^\n"
  stdout: ''
  timestamp: 1659980042
- exit_code: -4
  program: "\n/// Input to this function is a string containing multiple groups of\
    \ nested parentheses. Your goal is to\n/// separate those group into separate\
    \ strings and return the array of those.\n/// Separate groups are balanced (each\
    \ open brace is properly closed) and not nested within each other\n/// Ignore\
    \ any spaces in the input string.\n/// >>> separate_paren_groups(paren_string:\
    \ \"( ) (( )) (( )( ))\")\n/// [\"()\", \"(())\", \"(()())\"]\nfunc separate_paren_groups(paren_string:\
    \ String) -> [String] {\n    var characters = Array(paren_string)\n    var result:\
    \ [String] = []\n    var startIndex = 0\n    var depth = 0\n    var currentString\
    \ = \"\"\n    var add = false\n    for i in 0..<characters.count {\n        if\
    \ characters[i] == \"(\" {\n            if depth == 0 {\n                add =\
    \ true\n                startIndex = i\n            }\n            depth += 1\n\
    \        } else if characters[i] == \")\" {\n            depth -= 1\n        \
    \    if depth == 0 {\n                add = false\n                currentString\
    \ = String(characters[startIndex...i])\n                if !currentString.isEmpty\
    \ {\n                    result.append(currentString)\n                }\n   \
    \         }\n        }\n        if add {\n            currentString += String(characters[i])\n\
    \        }\n    }\n    return result\n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(separate_paren_groups(paren_string: \"(()()) ((())) () ((())()())\") ==\
    \ [\"(()())\", \"((()))\", \"()\", \"((())()())\"])\nassert(separate_paren_groups(paren_string:\
    \ \"() (()) ((())) (((())))\") == [\"()\", \"(())\", \"((()))\", \"(((())))\"\
    ])\nassert(separate_paren_groups(paren_string: \"(()(())((())))\") == [\"(()(())((())))\"\
    ])\nassert(separate_paren_groups(paren_string: \"( ) (( )) (( )( ))\") == [\"\
    ()\", \"(())\", \"(()())\"])"
  status: Exception
  stderr: 'tmpm680cjpd/tmpm680cjpd.swift:55: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b627421fc80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b6273f16b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b6273f16988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b6273f157b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpm680cjpd                        0x000055cd5f65b122 <unavailable> + 8482

    5    libc.so.6                          0x00002b627440b460 __libc_start_main +
    245

    6    tmpm680cjpd                        0x000055cd5f65a809 <unavailable> + 6153

    '
  stdout: ''
  timestamp: 1659980042
- exit_code: 1
  program: "\n/// Input to this function is a string containing multiple groups of\
    \ nested parentheses. Your goal is to\n/// separate those group into separate\
    \ strings and return the array of those.\n/// Separate groups are balanced (each\
    \ open brace is properly closed) and not nested within each other\n/// Ignore\
    \ any spaces in the input string.\n/// >>> separate_paren_groups(paren_string:\
    \ \"( ) (( )) (( )( ))\")\n/// [\"()\", \"(())\", \"(()())\"]\nfunc separate_paren_groups(paren_string:\
    \ String) -> [String] {\n    let string = \"\".join(paren_string.componentsSeparatedByCharactersInSet(NSCharacterSet.whitespaceCharacterSet()))\n\
    \    var res = [String]()\n    var leftParens = 0\n    var rightParens = 0\n \
    \   var startIndex = 0\n    for (index, char) in enumerate(string) {\n       \
    \ if char == \"(\" {\n            leftParens++\n        } else if char == \")\"\
    \ {\n            rightParens++\n        }\n        if leftParens == rightParens\
    \ {\n            res.append(string[startIndex..<index + 1])\n            startIndex\
    \ = index + 1\n        }\n    }\n    return res\n}\n\n\nfunc ==(left: [(Int, Int)],\
    \ right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n       \
    \ return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r\
    \ {\n            return false\n        }\n    }\n    return true\n}\n        \
    \    \nassert(separate_paren_groups(paren_string: \"(()()) ((())) () ((())()())\"\
    ) == [\"(()())\", \"((()))\", \"()\", \"((())()())\"])\nassert(separate_paren_groups(paren_string:\
    \ \"() (()) ((())) (((())))\") == [\"()\", \"(())\", \"((()))\", \"(((())))\"\
    ])\nassert(separate_paren_groups(paren_string: \"(()(())((())))\") == [\"(()(())((())))\"\
    ])\nassert(separate_paren_groups(paren_string: \"( ) (( )) (( )( ))\") == [\"\
    ()\", \"(())\", \"(()())\"])"
  status: SyntaxError
  stderr: "/tmp/tmpqk20k_n8.swift:9:76: error: cannot find 'NSCharacterSet' in scope\n\
    \    let string = \"\".join(paren_string.componentsSeparatedByCharactersInSet(NSCharacterSet.whitespaceCharacterSet()))\n\
    \                                                                           ^~~~~~~~~~~~~~\n\
    /tmp/tmpqk20k_n8.swift:9:21: error: value of type 'String' has no member 'join'\n\
    \    let string = \"\".join(paren_string.componentsSeparatedByCharactersInSet(NSCharacterSet.whitespaceCharacterSet()))\n\
    \                 ~~ ^~~~\n/tmp/tmpqk20k_n8.swift:9:39: error: value of type 'String'\
    \ has no member 'componentsSeparatedByCharactersInSet'\n    let string = \"\"\
    .join(paren_string.componentsSeparatedByCharactersInSet(NSCharacterSet.whitespaceCharacterSet()))\n\
    \                         ~~~~~~~~~~~~ ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n\
    /tmp/tmpqk20k_n8.swift:14:26: error: cannot find 'enumerate' in scope\n    for\
    \ (index, char) in enumerate(string) {\n                         ^~~~~~~~~\n"
  stdout: ''
  timestamp: 1659980042
- exit_code: 0
  program: "\n/// Input to this function is a string containing multiple groups of\
    \ nested parentheses. Your goal is to\n/// separate those group into separate\
    \ strings and return the array of those.\n/// Separate groups are balanced (each\
    \ open brace is properly closed) and not nested within each other\n/// Ignore\
    \ any spaces in the input string.\n/// >>> separate_paren_groups(paren_string:\
    \ \"( ) (( )) (( )( ))\")\n/// [\"()\", \"(())\", \"(()())\"]\nfunc separate_paren_groups(paren_string:\
    \ String) -> [String] {\n    var parenStack: [String] = []\n    var stringArray:\
    \ [String] = []\n    var currentString: String = \"\"\n    for char in paren_string\
    \ {\n        if char == \"(\" {\n            parenStack.append(\"(\")\n      \
    \      currentString.append(char)\n        } else if char == \")\" {\n       \
    \     parenStack.removeLast()\n            currentString.append(char)\n      \
    \      if parenStack.isEmpty {\n                stringArray.append(currentString)\n\
    \                currentString = \"\"\n            }\n        }\n    }\n    return\
    \ stringArray\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool\
    \ {\n    if left.count != right.count {\n        return false\n    }\n    for\
    \ (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(separate_paren_groups(paren_string:\
    \ \"(()()) ((())) () ((())()())\") == [\"(()())\", \"((()))\", \"()\", \"((())()())\"\
    ])\nassert(separate_paren_groups(paren_string: \"() (()) ((())) (((())))\") ==\
    \ [\"()\", \"(())\", \"((()))\", \"(((())))\"])\nassert(separate_paren_groups(paren_string:\
    \ \"(()(())((())))\") == [\"(()(())((())))\"])\nassert(separate_paren_groups(paren_string:\
    \ \"( ) (( )) (( )( ))\") == [\"()\", \"(())\", \"(()())\"])"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659980042
- exit_code: -4
  program: "\n/// Input to this function is a string containing multiple groups of\
    \ nested parentheses. Your goal is to\n/// separate those group into separate\
    \ strings and return the array of those.\n/// Separate groups are balanced (each\
    \ open brace is properly closed) and not nested within each other\n/// Ignore\
    \ any spaces in the input string.\n/// >>> separate_paren_groups(paren_string:\
    \ \"( ) (( )) (( )( ))\")\n/// [\"()\", \"(())\", \"(()())\"]\nfunc separate_paren_groups(paren_string:\
    \ String) -> [String] {\n    return []\n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(separate_paren_groups(paren_string: \"(()()) ((())) () ((())()())\") ==\
    \ [\"(()())\", \"((()))\", \"()\", \"((())()())\"])\nassert(separate_paren_groups(paren_string:\
    \ \"() (()) ((())) (((())))\") == [\"()\", \"(())\", \"((()))\", \"(((())))\"\
    ])\nassert(separate_paren_groups(paren_string: \"(()(())((())))\") == [\"(()(())((())))\"\
    ])\nassert(separate_paren_groups(paren_string: \"( ) (( )) (( )( ))\") == [\"\
    ()\", \"(())\", \"(()())\"])"
  status: Exception
  stderr: 'tmp1zdkbtz2/tmp1zdkbtz2.swift:25: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002aeebe8b5c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002aeebe5acb6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002aeebe5ac988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002aeebe5ab7b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmp1zdkbtz2                        0x0000556857c08537 <unavailable> + 5431

    5    libc.so.6                          0x00002aeebeaa1460 __libc_start_main +
    245

    6    tmp1zdkbtz2                        0x0000556857c080c9 <unavailable> + 4297

    '
  stdout: ''
  timestamp: 1659980040
- exit_code: -4
  program: "\n/// Input to this function is a string containing multiple groups of\
    \ nested parentheses. Your goal is to\n/// separate those group into separate\
    \ strings and return the array of those.\n/// Separate groups are balanced (each\
    \ open brace is properly closed) and not nested within each other\n/// Ignore\
    \ any spaces in the input string.\n/// >>> separate_paren_groups(paren_string:\
    \ \"( ) (( )) (( )( ))\")\n/// [\"()\", \"(())\", \"(()())\"]\nfunc separate_paren_groups(paren_string:\
    \ String) -> [String] {\n    var result = [String]()\n    var paren_groups = [Int]()\n\
    \    var curr_index = 0\n    var buffer = \"\"\n    for char in paren_string {\n\
    \        if char == \"(\" {\n            paren_groups.append(curr_index)\n   \
    \     } else if char == \")\" {\n            paren_groups.removeLast()\n     \
    \   }\n        if paren_groups.count == 0 {\n            result.append(buffer)\n\
    \            buffer = \"\"\n        } else {\n            buffer.append(char)\n\
    \        }\n        curr_index += 1\n    }\n    return result\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(separate_paren_groups(paren_string: \"(()()) ((())) ()\
    \ ((())()())\") == [\"(()())\", \"((()))\", \"()\", \"((())()())\"])\nassert(separate_paren_groups(paren_string:\
    \ \"() (()) ((())) (((())))\") == [\"()\", \"(())\", \"((()))\", \"(((())))\"\
    ])\nassert(separate_paren_groups(paren_string: \"(()(())((())))\") == [\"(()(())((())))\"\
    ])\nassert(separate_paren_groups(paren_string: \"( ) (( )) (( )( ))\") == [\"\
    ()\", \"(())\", \"(()())\"])"
  status: Exception
  stderr: 'tmpot3hq0vn/tmpot3hq0vn.swift:43: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b42ee060c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b42edd57b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b42edd57988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b42edd567b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpot3hq0vn                        0x0000555b1ed649d7 <unavailable> + 6615

    5    libc.so.6                          0x00002b42ee24c460 __libc_start_main +
    245

    6    tmpot3hq0vn                        0x0000555b1ed64569 <unavailable> + 5481

    '
  stdout: ''
  timestamp: 1659980042
- exit_code: 1
  program: "\n/// Input to this function is a string containing multiple groups of\
    \ nested parentheses. Your goal is to\n/// separate those group into separate\
    \ strings and return the array of those.\n/// Separate groups are balanced (each\
    \ open brace is properly closed) and not nested within each other\n/// Ignore\
    \ any spaces in the input string.\n/// >>> separate_paren_groups(paren_string:\
    \ \"( ) (( )) (( )( ))\")\n/// [\"()\", \"(())\", \"(()())\"]\nfunc separate_paren_groups(paren_string:\
    \ String) -> [String] {\n    var result = [String]()\n    var str = paren_string\n\
    \    str = str.replacingOccurrences(of: \" \", with: \"\")\n    while let _ =\
    \ str.firstIndex(of: \"(\") {\n        if let open_index = str.firstIndex(of:\
    \ \"(\") {\n            let index = str.index(after: open_index)\n           \
    \ str.remove(at: open_index)\n            str.insert(\"*\", at: index)\n     \
    \   }\n        if let close_index = str.firstIndex(of: \")\") {\n            let\
    \ index = str.index(after: close_index)\n            str.remove(at: close_index)\n\
    \            str.insert(\"*\", at: index)\n        }\n        if let index = str.firstIndex(of:\
    \ \"*\") {\n            let sub_str = String(str[str.startIndex..<index])\n  \
    \          result.append(sub_str)\n            str.removeFirst(sub_str.count +\
    \ 1)\n        }\n    }\n    return result\n}\n\n\nfunc ==(left: [(Int, Int)],\
    \ right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n       \
    \ return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r\
    \ {\n            return false\n        }\n    }\n    return true\n}\n        \
    \    \nassert(separate_paren_groups(paren_string: \"(()()) ((())) () ((())()())\"\
    ) == [\"(()())\", \"((()))\", \"()\", \"((())()())\"])\nassert(separate_paren_groups(paren_string:\
    \ \"() (()) ((())) (((())))\") == [\"()\", \"(())\", \"((()))\", \"(((())))\"\
    ])\nassert(separate_paren_groups(paren_string: \"(()(())((())))\") == [\"(()(())((())))\"\
    ])\nassert(separate_paren_groups(paren_string: \"( ) (( )) (( )( ))\") == [\"\
    ()\", \"(())\", \"(()())\"])"
  status: SyntaxError
  stderr: "/tmp/tmpf8i2dem8.swift:11:15: error: value of type 'String' has no member\
    \ 'replacingOccurrences'\n    str = str.replacingOccurrences(of: \" \", with:\
    \ \"\")\n          ~~~ ^~~~~~~~~~~~~~~~~~~~\n"
  stdout: ''
  timestamp: 1659980042
- exit_code: -4
  program: "\n/// Input to this function is a string containing multiple groups of\
    \ nested parentheses. Your goal is to\n/// separate those group into separate\
    \ strings and return the array of those.\n/// Separate groups are balanced (each\
    \ open brace is properly closed) and not nested within each other\n/// Ignore\
    \ any spaces in the input string.\n/// >>> separate_paren_groups(paren_string:\
    \ \"( ) (( )) (( )( ))\")\n/// [\"()\", \"(())\", \"(()())\"]\nfunc separate_paren_groups(paren_string:\
    \ String) -> [String] {\n    var result : [String] = []\n    var current_group\
    \ : String = \"\"\n    var open_parens = 0\n    var closed_parens = 0\n    for\
    \ paren in paren_string {\n        if paren == \"(\" {\n            open_parens\
    \ += 1\n            current_group += String(paren)\n        } else if paren ==\
    \ \")\" {\n            closed_parens += 1\n            current_group += String(paren)\n\
    \        }\n        if open_parens == closed_parens {\n            result.append(current_group)\n\
    \            current_group = \"\"\n            open_parens = 0\n            closed_parens\
    \ = 0\n        }\n    }\n    return result\n}\n\n\nfunc ==(left: [(Int, Int)],\
    \ right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n       \
    \ return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r\
    \ {\n            return false\n        }\n    }\n    return true\n}\n        \
    \    \nassert(separate_paren_groups(paren_string: \"(()()) ((())) () ((())()())\"\
    ) == [\"(()())\", \"((()))\", \"()\", \"((())()())\"])\nassert(separate_paren_groups(paren_string:\
    \ \"() (()) ((())) (((())))\") == [\"()\", \"(())\", \"((()))\", \"(((())))\"\
    ])\nassert(separate_paren_groups(paren_string: \"(()(())((())))\") == [\"(()(())((())))\"\
    ])\nassert(separate_paren_groups(paren_string: \"( ) (( )) (( )( ))\") == [\"\
    ()\", \"(())\", \"(()())\"])"
  status: Exception
  stderr: 'tmp3z8mo1kw/tmp3z8mo1kw.swift:44: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b5f70677c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b5f7036eb6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b5f7036e988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b5f7036d7b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmp3z8mo1kw                        0x00005563bc7d47e7 <unavailable> + 6119

    5    libc.so.6                          0x00002b5f70863460 __libc_start_main +
    245

    6    tmp3z8mo1kw                        0x00005563bc7d4379 <unavailable> + 4985

    '
  stdout: ''
  timestamp: 1659980042
- exit_code: 1
  program: "\n/// Input to this function is a string containing multiple groups of\
    \ nested parentheses. Your goal is to\n/// separate those group into separate\
    \ strings and return the array of those.\n/// Separate groups are balanced (each\
    \ open brace is properly closed) and not nested within each other\n/// Ignore\
    \ any spaces in the input string.\n/// >>> separate_paren_groups(paren_string:\
    \ \"( ) (( )) (( )( ))\")\n/// [\"()\", \"(())\", \"(()())\"]\nfunc separate_paren_groups(paren_string:\
    \ String) -> [String] {\n    \n    // your code here\n    let str = paren_string.replacingOccurrences(of:\
    \ \" \", with: \"\")\n    return separate(str)\n}\n\n\nfunc ==(left: [(Int, Int)],\
    \ right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n       \
    \ return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r\
    \ {\n            return false\n        }\n    }\n    return true\n}\n        \
    \    \nassert(separate_paren_groups(paren_string: \"(()()) ((())) () ((())()())\"\
    ) == [\"(()())\", \"((()))\", \"()\", \"((())()())\"])\nassert(separate_paren_groups(paren_string:\
    \ \"() (()) ((())) (((())))\") == [\"()\", \"(())\", \"((()))\", \"(((())))\"\
    ])\nassert(separate_paren_groups(paren_string: \"(()(())((())))\") == [\"(()(())((())))\"\
    ])\nassert(separate_paren_groups(paren_string: \"( ) (( )) (( )( ))\") == [\"\
    ()\", \"(())\", \"(()())\"])"
  status: SyntaxError
  stderr: "/tmp/tmpczfdlag9.swift:11:28: error: value of type 'String' has no member\
    \ 'replacingOccurrences'\n    let str = paren_string.replacingOccurrences(of:\
    \ \" \", with: \"\")\n              ~~~~~~~~~~~~ ^~~~~~~~~~~~~~~~~~~~\n/tmp/tmpczfdlag9.swift:12:12:\
    \ error: cannot find 'separate' in scope\n    return separate(str)\n         \
    \  ^~~~~~~~\n"
  stdout: ''
  timestamp: 1659980042
- exit_code: 1
  program: "\n/// Input to this function is a string containing multiple groups of\
    \ nested parentheses. Your goal is to\n/// separate those group into separate\
    \ strings and return the array of those.\n/// Separate groups are balanced (each\
    \ open brace is properly closed) and not nested within each other\n/// Ignore\
    \ any spaces in the input string.\n/// >>> separate_paren_groups(paren_string:\
    \ \"( ) (( )) (( )( ))\")\n/// [\"()\", \"(())\", \"(()())\"]\nfunc separate_paren_groups(paren_string:\
    \ String) -> [String] {\n    let parens = paren_string.replacingOccurrences(of:\
    \ \" \", with: \"\")\n    return parens.split(separator: \")\").filter { !$0.isEmpty\
    \ }.map { String($0) + \")\" }\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int,\
    \ Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n\
    \    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n          \
    \  return false\n        }\n    }\n    return true\n}\n            \nassert(separate_paren_groups(paren_string:\
    \ \"(()()) ((())) () ((())()())\") == [\"(()())\", \"((()))\", \"()\", \"((())()())\"\
    ])\nassert(separate_paren_groups(paren_string: \"() (()) ((())) (((())))\") ==\
    \ [\"()\", \"(())\", \"((()))\", \"(((())))\"])\nassert(separate_paren_groups(paren_string:\
    \ \"(()(())((())))\") == [\"(()(())((())))\"])\nassert(separate_paren_groups(paren_string:\
    \ \"( ) (( )) (( )( ))\") == [\"()\", \"(())\", \"(()())\"])"
  status: SyntaxError
  stderr: "/tmp/tmpgi1hzytt.swift:9:31: error: value of type 'String' has no member\
    \ 'replacingOccurrences'\n    let parens = paren_string.replacingOccurrences(of:\
    \ \" \", with: \"\")\n                 ~~~~~~~~~~~~ ^~~~~~~~~~~~~~~~~~~~\n"
  stdout: ''
  timestamp: 1659980043
- exit_code: 1
  program: "\n/// Input to this function is a string containing multiple groups of\
    \ nested parentheses. Your goal is to\n/// separate those group into separate\
    \ strings and return the array of those.\n/// Separate groups are balanced (each\
    \ open brace is properly closed) and not nested within each other\n/// Ignore\
    \ any spaces in the input string.\n/// >>> separate_paren_groups(paren_string:\
    \ \"( ) (( )) (( )( ))\")\n/// [\"()\", \"(())\", \"(()())\"]\nfunc separate_paren_groups(paren_string:\
    \ String) -> [String] {\n    var paren_groups = [String]()\n    var current_index\
    \ = 0\n    while current_index < paren_string.count {\n        var i = current_index\n\
    \        var open_counter = 0\n        while i < paren_string.count {\n      \
    \      if paren_string[i] == \"(\" {\n                open_counter += 1\n    \
    \        } else if paren_string[i] == \")\" {\n                open_counter -=\
    \ 1\n            }\n            if open_counter == 0 {\n                break\n\
    \            }\n            i += 1\n        }\n        let indexEndOfText = paren_string.index(paren_string.startIndex,\
    \ offsetBy: i)\n        let subString = paren_string[current_index..<indexEndOfText]\n\
    \        paren_groups.append(String(subString))\n        current_index = i + 1\n\
    \    }\n    return paren_groups\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int,\
    \ Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n\
    \    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n          \
    \  return false\n        }\n    }\n    return true\n}\n            \nassert(separate_paren_groups(paren_string:\
    \ \"(()()) ((())) () ((())()())\") == [\"(()())\", \"((()))\", \"()\", \"((())()())\"\
    ])\nassert(separate_paren_groups(paren_string: \"() (()) ((())) (((())))\") ==\
    \ [\"()\", \"(())\", \"((()))\", \"(((())))\"])\nassert(separate_paren_groups(paren_string:\
    \ \"(()(())((())))\") == [\"(()(())((())))\"])\nassert(separate_paren_groups(paren_string:\
    \ \"( ) (( )) (( )( ))\") == [\"()\", \"(())\", \"(()())\"])"
  status: SyntaxError
  stderr: "/tmp/tmpfuudnv04.swift:15:16: error: 'subscript(_:)' is unavailable: cannot\
    \ subscript String with an Int, use a String.Index instead.\n            if paren_string[i]\
    \ == \"(\" {\n               ^~~~~~~~~~~~~~~\nSwift.String:3:12: note: 'subscript(_:)'\
    \ has been explicitly marked unavailable here\n    public subscript(i: Int) ->\
    \ Character { get }\n           ^\n/tmp/tmpfuudnv04.swift:17:23: error: 'subscript(_:)'\
    \ is unavailable: cannot subscript String with an Int, use a String.Index instead.\n\
    \            } else if paren_string[i] == \")\" {\n                      ^~~~~~~~~~~~~~~\n\
    Swift.String:3:12: note: 'subscript(_:)' has been explicitly marked unavailable\
    \ here\n    public subscript(i: Int) -> Character { get }\n           ^\n/tmp/tmpfuudnv04.swift:26:38:\
    \ error: cannot convert value of type 'Int' to expected argument type 'String.Index'\n\
    \        let subString = paren_string[current_index..<indexEndOfText]\n      \
    \                               ^\n"
  stdout: ''
  timestamp: 1659980042
- exit_code: 1
  program: "\n/// Input to this function is a string containing multiple groups of\
    \ nested parentheses. Your goal is to\n/// separate those group into separate\
    \ strings and return the array of those.\n/// Separate groups are balanced (each\
    \ open brace is properly closed) and not nested within each other\n/// Ignore\
    \ any spaces in the input string.\n/// >>> separate_paren_groups(paren_string:\
    \ \"( ) (( )) (( )( ))\")\n/// [\"()\", \"(())\", \"(()())\"]\nfunc separate_paren_groups(paren_string:\
    \ String) -> [String] {\n    // Create a map of ( and ) => their string indexes\n\
    \    var left_paren_map = [Int:Int]()\n    var right_paren_map = [Int:Int]()\n\
    \    var stack = [Int]()\n    var groups = [String]()\n    \n    for (index, char)\
    \ in paren_string.enumerated() {\n        if char == \"(\" {\n            left_paren_map[index]\
    \ = index\n            stack.append(index)\n        } else if char == \")\" {\n\
    \            right_paren_map[index] = index\n            stack.popLast()\n   \
    \     }\n    }\n    \n    var i = 0\n    while i < paren_string.count {\n    \
    \    if let start = left_paren_map[i] {\n            let next = start + 1\n  \
    \          let end = right_paren_map[next]\n            i = end! + 1\n       \
    \     let range = start...end!\n            groups.append(paren_string[range])\n\
    \        } else {\n            i += 1\n        }\n    }\n    \n    return groups\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(separate_paren_groups(paren_string: \"(()()) ((()))\
    \ () ((())()())\") == [\"(()())\", \"((()))\", \"()\", \"((())()())\"])\nassert(separate_paren_groups(paren_string:\
    \ \"() (()) ((())) (((())))\") == [\"()\", \"(())\", \"((()))\", \"(((())))\"\
    ])\nassert(separate_paren_groups(paren_string: \"(()(())((())))\") == [\"(()(())((())))\"\
    ])\nassert(separate_paren_groups(paren_string: \"( ) (( )) (( )( ))\") == [\"\
    ()\", \"(())\", \"(()())\"])"
  status: SyntaxError
  stderr: "/tmp/tmpfqs2sjga.swift:21:19: warning: result of call to 'popLast()' is\
    \ unused\n            stack.popLast()\n                  ^      ~~\n/tmp/tmpfqs2sjga.swift:32:27:\
    \ error: 'subscript(_:)' is unavailable: cannot subscript String with an integer\
    \ range, use a String.Index range instead.\n            groups.append(paren_string[range])\n\
    \                          ^~~~~~~~~~~~~~~~~~~\nSwift.String:5:12: note: 'subscript(_:)'\
    \ has been explicitly marked unavailable here\n    public subscript<R>(bounds:\
    \ R) -> String where R : RangeExpression, R.Bound == Int { get }\n           ^\n"
  stdout: ''
  timestamp: 1659980042
- exit_code: 1
  program: "\n/// Input to this function is a string containing multiple groups of\
    \ nested parentheses. Your goal is to\n/// separate those group into separate\
    \ strings and return the array of those.\n/// Separate groups are balanced (each\
    \ open brace is properly closed) and not nested within each other\n/// Ignore\
    \ any spaces in the input string.\n/// >>> separate_paren_groups(paren_string:\
    \ \"( ) (( )) (( )( ))\")\n/// [\"()\", \"(())\", \"(()())\"]\nfunc separate_paren_groups(paren_string:\
    \ String) -> [String] {\n    var result = [String]()\n    var current_string =\
    \ \"\"\n    var stack = Stack<Character>()\n    for char in paren_string {\n \
    \       if char == \"(\" {\n            stack.push(char)\n        } else if char\
    \ == \")\" {\n            if stack.peek() == \"(\" {\n                stack.pop()\n\
    \                if stack.isEmpty() {\n                    result.append(current_string)\n\
    \                    current_string = \"\"\n                } else {\n       \
    \             current_string.append(char)\n                }\n            } else\
    \ {\n                current_string.append(char)\n            }\n        } else\
    \ {\n            current_string.append(char)\n        }\n    }\n    return result\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(separate_paren_groups(paren_string: \"(()()) ((()))\
    \ () ((())()())\") == [\"(()())\", \"((()))\", \"()\", \"((())()())\"])\nassert(separate_paren_groups(paren_string:\
    \ \"() (()) ((())) (((())))\") == [\"()\", \"(())\", \"((()))\", \"(((())))\"\
    ])\nassert(separate_paren_groups(paren_string: \"(()(())((())))\") == [\"(()(())((())))\"\
    ])\nassert(separate_paren_groups(paren_string: \"( ) (( )) (( )( ))\") == [\"\
    ()\", \"(())\", \"(()())\"])"
  status: SyntaxError
  stderr: "/tmp/tmp513bq4th.swift:11:17: error: cannot find 'Stack' in scope\n   \
    \ var stack = Stack<Character>()\n                ^~~~~\n"
  stdout: ''
  timestamp: 1659980042
- exit_code: 1
  program: "\n/// Input to this function is a string containing multiple groups of\
    \ nested parentheses. Your goal is to\n/// separate those group into separate\
    \ strings and return the array of those.\n/// Separate groups are balanced (each\
    \ open brace is properly closed) and not nested within each other\n/// Ignore\
    \ any spaces in the input string.\n/// >>> separate_paren_groups(paren_string:\
    \ \"( ) (( )) (( )( ))\")\n/// [\"()\", \"(())\", \"(()())\"]\nfunc separate_paren_groups(paren_string:\
    \ String) -> [String] {\n    \n    var a: Int = 0\n    var b: Int = 0\n    var\
    \ c: Int = 0\n    var d: Int = 0\n    var e: Int = 0\n    var f: Int = 0\n   \
    \ var g: Int = 0\n    var h: Int = 0\n    var i: Int = 0\n    var j: Int = 0\n\
    \    var k: Int = 0\n    var l: Int = 0\n    var m: Int = 0\n    var n: Int =\
    \ 0\n    var o: Int = 0\n    var p: Int = 0\n    var q: Int = 0\n    var r: Int\
    \ = 0\n    var s: Int = 0\n    var t: Int = 0\n    var u: Int = 0\n    var v:\
    \ Int = 0\n    var w: Int = 0\n    var x: Int = 0\n    var y: Int = 0\n    var\
    \ z: Int = 0\n    \n    var a_i: Int = 0\n    var b_i: Int = 0\n    var c_i: Int\
    \ = 0\n    var d_i: Int = 0\n    var e_i: Int = 0\n    var f_i: Int = 0\n    var\
    \ g_i: Int = 0\n    var h_i: Int = 0\n    var i_i: Int = 0\n    var j_i: Int =\
    \ 0\n    var k_i: Int = 0\n    var l_i: Int = 0\n    var m_i: Int = 0\n    var\
    \ n_i: Int = 0\n    var o_i: Int = 0\n    var p_i: Int = 0\n    var q_i: Int =\
    \ 0\n    var r_i: Int = 0\n    var s_i: Int = 0\n    var t_i: Int = 0\n    var\
    \ u_i: Int = 0\n    var v_i: Int = 0\n    var w_i: Int = 0\n    var x_i: Int =\
    \ 0\n    var y_i: Int = 0\n    var z_i: Int = 0\n    \n    var temp_int: Int =\
    \ 0\n    var temp_int_i: Int = 0\n    \n    var a_counter: Int = 0\n    var b\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(separate_paren_groups(paren_string: \"(()()) ((()))\
    \ () ((())()())\") == [\"(()())\", \"((()))\", \"()\", \"((())()())\"])\nassert(separate_paren_groups(paren_string:\
    \ \"() (()) ((())) (((())))\") == [\"()\", \"(())\", \"((()))\", \"(((())))\"\
    ])\nassert(separate_paren_groups(paren_string: \"(()(())((())))\") == [\"(()(())((())))\"\
    ])\nassert(separate_paren_groups(paren_string: \"( ) (( )) (( )( ))\") == [\"\
    ()\", \"(())\", \"(()())\"])"
  status: SyntaxError
  stderr: "/tmp/tmp0srtrxht.swift:68:9: error: type annotation missing in pattern\n\
    \    var b\n        ^\n"
  stdout: ''
  timestamp: 1659980042
- exit_code: -4
  program: "\n/// Input to this function is a string containing multiple groups of\
    \ nested parentheses. Your goal is to\n/// separate those group into separate\
    \ strings and return the array of those.\n/// Separate groups are balanced (each\
    \ open brace is properly closed) and not nested within each other\n/// Ignore\
    \ any spaces in the input string.\n/// >>> separate_paren_groups(paren_string:\
    \ \"( ) (( )) (( )( ))\")\n/// [\"()\", \"(())\", \"(()())\"]\nfunc separate_paren_groups(paren_string:\
    \ String) -> [String] {\n    var groups = [String]()\n    var current_group =\
    \ \"\"\n    var open_parens = 0\n    for c in paren_string {\n        if c ==\
    \ \"(\" {\n            open_parens += 1\n            current_group += \"(\"\n\
    \        } else if c == \")\" {\n            open_parens -= 1\n            current_group\
    \ += \")\"\n        }\n        if open_parens == 0 {\n            groups.append(current_group)\n\
    \            current_group = \"\"\n        }\n    }\n    return groups\n}\n\n\n\
    func ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(separate_paren_groups(paren_string: \"(()()) ((()))\
    \ () ((())()())\") == [\"(()())\", \"((()))\", \"()\", \"((())()())\"])\nassert(separate_paren_groups(paren_string:\
    \ \"() (()) ((())) (((())))\") == [\"()\", \"(())\", \"((()))\", \"(((())))\"\
    ])\nassert(separate_paren_groups(paren_string: \"(()(())((())))\") == [\"(()(())((())))\"\
    ])\nassert(separate_paren_groups(paren_string: \"( ) (( )) (( )( ))\") == [\"\
    ()\", \"(())\", \"(()())\"])"
  status: Exception
  stderr: 'tmpp0pxzirf/tmpp0pxzirf.swift:41: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b9ead0efc80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b9eacde6b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b9eacde6988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b9eacde57b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpp0pxzirf                        0x000055b0cbe2c7e7 <unavailable> + 6119

    5    libc.so.6                          0x00002b9ead2db460 __libc_start_main +
    245

    6    tmpp0pxzirf                        0x000055b0cbe2c379 <unavailable> + 4985

    '
  stdout: ''
  timestamp: 1659980042
- exit_code: -4
  program: "\n/// Input to this function is a string containing multiple groups of\
    \ nested parentheses. Your goal is to\n/// separate those group into separate\
    \ strings and return the array of those.\n/// Separate groups are balanced (each\
    \ open brace is properly closed) and not nested within each other\n/// Ignore\
    \ any spaces in the input string.\n/// >>> separate_paren_groups(paren_string:\
    \ \"( ) (( )) (( )( ))\")\n/// [\"()\", \"(())\", \"(()())\"]\nfunc separate_paren_groups(paren_string:\
    \ String) -> [String] {\n    var groups = [String]()\n    var current_group =\
    \ \"\"\n    var paren_count = 0\n    for c in paren_string {\n        if c ==\
    \ \"(\" {\n            paren_count += 1\n            current_group += \"(\"\n\
    \        } else if c == \")\" {\n            paren_count -= 1\n            current_group\
    \ += \")\"\n        }\n        if paren_count == 0 {\n            groups.append(current_group)\n\
    \            current_group = \"\"\n        }\n    }\n    return groups\n}\n\n\n\
    func ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(separate_paren_groups(paren_string: \"(()()) ((()))\
    \ () ((())()())\") == [\"(()())\", \"((()))\", \"()\", \"((())()())\"])\nassert(separate_paren_groups(paren_string:\
    \ \"() (()) ((())) (((())))\") == [\"()\", \"(())\", \"((()))\", \"(((())))\"\
    ])\nassert(separate_paren_groups(paren_string: \"(()(())((())))\") == [\"(()(())((())))\"\
    ])\nassert(separate_paren_groups(paren_string: \"( ) (( )) (( )( ))\") == [\"\
    ()\", \"(())\", \"(()())\"])"
  status: Exception
  stderr: 'tmpqrtx97g0/tmpqrtx97g0.swift:41: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b46970c7c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b4696dbeb6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b4696dbe988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b4696dbd7b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpqrtx97g0                        0x00005572604e07e7 <unavailable> + 6119

    5    libc.so.6                          0x00002b46972b3460 __libc_start_main +
    245

    6    tmpqrtx97g0                        0x00005572604e0379 <unavailable> + 4985

    '
  stdout: ''
  timestamp: 1659980042
- exit_code: -4
  program: "\n/// Input to this function is a string containing multiple groups of\
    \ nested parentheses. Your goal is to\n/// separate those group into separate\
    \ strings and return the array of those.\n/// Separate groups are balanced (each\
    \ open brace is properly closed) and not nested within each other\n/// Ignore\
    \ any spaces in the input string.\n/// >>> separate_paren_groups(paren_string:\
    \ \"( ) (( )) (( )( ))\")\n/// [\"()\", \"(())\", \"(()())\"]\nfunc separate_paren_groups(paren_string:\
    \ String) -> [String] {\n    var count = 0\n    var groups = [String]()\n    var\
    \ group = \"\"\n    for c in paren_string {\n        if c == \"(\" {\n       \
    \     count += 1\n        } else if c == \")\" {\n            count -= 1\n   \
    \     }\n        if count == 0 {\n            if c == \")\" || c == \"(\" {\n\
    \                groups.append(group)\n                group = \"\"\n        \
    \    }\n        } else {\n            if c == \")\" || c == \"(\" {\n        \
    \        group.append(c)\n            }\n        }\n    }\n    return groups\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(separate_paren_groups(paren_string: \"(()()) ((()))\
    \ () ((())()())\") == [\"(()())\", \"((()))\", \"()\", \"((())()())\"])\nassert(separate_paren_groups(paren_string:\
    \ \"() (()) ((())) (((())))\") == [\"()\", \"(())\", \"((()))\", \"(((())))\"\
    ])\nassert(separate_paren_groups(paren_string: \"(()(())((())))\") == [\"(()(())((())))\"\
    ])\nassert(separate_paren_groups(paren_string: \"( ) (( )) (( )( ))\") == [\"\
    ()\", \"(())\", \"(()())\"])"
  status: Exception
  stderr: 'tmpvqxfcgup/tmpvqxfcgup.swift:45: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002aaed8fb8c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002aaed8cafb6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002aaed8caf988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002aaed8cae7b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpvqxfcgup                        0x00005601f95de7e7 <unavailable> + 6119

    5    libc.so.6                          0x00002aaed91a4460 __libc_start_main +
    245

    6    tmpvqxfcgup                        0x00005601f95de379 <unavailable> + 4985

    '
  stdout: ''
  timestamp: 1659980042
- exit_code: 1
  program: "\n/// Input to this function is a string containing multiple groups of\
    \ nested parentheses. Your goal is to\n/// separate those group into separate\
    \ strings and return the array of those.\n/// Separate groups are balanced (each\
    \ open brace is properly closed) and not nested within each other\n/// Ignore\
    \ any spaces in the input string.\n/// >>> separate_paren_groups(paren_string:\
    \ \"( ) (( )) (( )( ))\")\n/// [\"()\", \"(())\", \"(()())\"]\nfunc separate_paren_groups(paren_string:\
    \ String) -> [String] {\n    var result = [String]()\n    var tempString = \"\"\
    \n    var count = 0\n    for char in paren_string.characters {\n        if char\
    \ == \"(\" {\n            count += 1\n        } else if char == \")\" {\n    \
    \        count -= 1\n        }\n        if count == 0 {\n            if tempString\
    \ != \"\" {\n                result.append(tempString)\n                tempString\
    \ = \"\"\n            }\n        } else {\n            tempString.append(char)\n\
    \        }\n    }\n    return result\n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(separate_paren_groups(paren_string: \"(()()) ((())) () ((())()())\") ==\
    \ [\"(()())\", \"((()))\", \"()\", \"((())()())\"])\nassert(separate_paren_groups(paren_string:\
    \ \"() (()) ((())) (((())))\") == [\"()\", \"(())\", \"((()))\", \"(((())))\"\
    ])\nassert(separate_paren_groups(paren_string: \"(()(())((())))\") == [\"(()(())((())))\"\
    ])\nassert(separate_paren_groups(paren_string: \"( ) (( )) (( )( ))\") == [\"\
    ()\", \"(())\", \"(()())\"])"
  status: SyntaxError
  stderr: "/tmp/tmp529sbefe.swift:12:30: error: 'characters' is unavailable: Please\
    \ use String directly\n    for char in paren_string.characters {\n           \
    \                  ^~~~~~~~~~\nSwift.String:5:16: note: 'characters' was obsoleted\
    \ in Swift 5.0\n    public var characters: String { get set }\n              \
    \ ^\n"
  stdout: ''
  timestamp: 1659980042
- exit_code: 1
  program: "\n/// Input to this function is a string containing multiple groups of\
    \ nested parentheses. Your goal is to\n/// separate those group into separate\
    \ strings and return the array of those.\n/// Separate groups are balanced (each\
    \ open brace is properly closed) and not nested within each other\n/// Ignore\
    \ any spaces in the input string.\n/// >>> separate_paren_groups(paren_string:\
    \ \"( ) (( )) (( )( ))\")\n/// [\"()\", \"(())\", \"(()())\"]\nfunc separate_paren_groups(paren_string:\
    \ String) -> [String] {\n    let parens = paren_string.replacingOccurrences(of:\
    \ \" \", with: \"\")\n    var result = [String]()\n    for sub in parens.split(separator:\
    \ \")\") {\n        let sub_parens = String(sub)\n        if sub_parens == \"\"\
    \ {\n            continue\n        }\n        let paren_string = sub_parens +\
    \ \")\"\n        if paren_string.is_balanced() {\n            result.append(paren_string)\n\
    \        }\n    }\n    return result\n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(separate_paren_groups(paren_string: \"(()()) ((())) () ((())()())\") ==\
    \ [\"(()())\", \"((()))\", \"()\", \"((())()())\"])\nassert(separate_paren_groups(paren_string:\
    \ \"() (()) ((())) (((())))\") == [\"()\", \"(())\", \"((()))\", \"(((())))\"\
    ])\nassert(separate_paren_groups(paren_string: \"(()(())((())))\") == [\"(()(())((())))\"\
    ])\nassert(separate_paren_groups(paren_string: \"( ) (( )) (( )( ))\") == [\"\
    ()\", \"(())\", \"(()())\"])"
  status: SyntaxError
  stderr: "/tmp/tmpd549c2_c.swift:9:31: error: value of type 'String' has no member\
    \ 'replacingOccurrences'\n    let parens = paren_string.replacingOccurrences(of:\
    \ \" \", with: \"\")\n                 ~~~~~~~~~~~~ ^~~~~~~~~~~~~~~~~~~~\n"
  stdout: ''
  timestamp: 1659980042
- exit_code: -4
  program: "\n/// Input to this function is a string containing multiple groups of\
    \ nested parentheses. Your goal is to\n/// separate those group into separate\
    \ strings and return the array of those.\n/// Separate groups are balanced (each\
    \ open brace is properly closed) and not nested within each other\n/// Ignore\
    \ any spaces in the input string.\n/// >>> separate_paren_groups(paren_string:\
    \ \"( ) (( )) (( )( ))\")\n/// [\"()\", \"(())\", \"(()())\"]\nfunc separate_paren_groups(paren_string:\
    \ String) -> [String] {\n    var result = [String]()\n    var stack: [Character]\
    \ = []\n    var element: Character\n    for char in paren_string {\n        if\
    \ char == \"(\" {\n            stack.append(char)\n        } else if char == \"\
    )\" {\n            element = stack.removeLast()\n            if element == \"\
    (\" {\n                // valid pair\n                if stack.count == 0 {\n\
    \                    result.append(\"()\")\n                }\n            } else\
    \ {\n                // invalid\n                return result\n            }\n\
    \        }\n    }\n    return result\n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(separate_paren_groups(paren_string: \"(()()) ((())) () ((())()())\") ==\
    \ [\"(()())\", \"((()))\", \"()\", \"((())()())\"])\nassert(separate_paren_groups(paren_string:\
    \ \"() (()) ((())) (((())))\") == [\"()\", \"(())\", \"((()))\", \"(((())))\"\
    ])\nassert(separate_paren_groups(paren_string: \"(()(())((())))\") == [\"(()(())((())))\"\
    ])\nassert(separate_paren_groups(paren_string: \"( ) (( )) (( )( ))\") == [\"\
    ()\", \"(())\", \"(()())\"])"
  status: Exception
  stderr: 'tmpn_13x_b7/tmpn_13x_b7.swift:44: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002ad02747cc80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002ad027173b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002ad027173988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002ad0271727b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpn_13x_b7                        0x0000556a12a2a967 <unavailable> + 6503

    5    libc.so.6                          0x00002ad027668460 __libc_start_main +
    245

    6    tmpn_13x_b7                        0x0000556a12a2a4f9 <unavailable> + 5369

    '
  stdout: ''
  timestamp: 1659980042
- exit_code: -4
  program: "\n/// Input to this function is a string containing multiple groups of\
    \ nested parentheses. Your goal is to\n/// separate those group into separate\
    \ strings and return the array of those.\n/// Separate groups are balanced (each\
    \ open brace is properly closed) and not nested within each other\n/// Ignore\
    \ any spaces in the input string.\n/// >>> separate_paren_groups(paren_string:\
    \ \"( ) (( )) (( )( ))\")\n/// [\"()\", \"(())\", \"(()())\"]\nfunc separate_paren_groups(paren_string:\
    \ String) -> [String] {\n    return []\n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(separate_paren_groups(paren_string: \"(()()) ((())) () ((())()())\") ==\
    \ [\"(()())\", \"((()))\", \"()\", \"((())()())\"])\nassert(separate_paren_groups(paren_string:\
    \ \"() (()) ((())) (((())))\") == [\"()\", \"(())\", \"((()))\", \"(((())))\"\
    ])\nassert(separate_paren_groups(paren_string: \"(()(())((())))\") == [\"(()(())((())))\"\
    ])\nassert(separate_paren_groups(paren_string: \"( ) (( )) (( )( ))\") == [\"\
    ()\", \"(())\", \"(()())\"])"
  status: Exception
  stderr: 'tmp1zdkbtz2/tmp1zdkbtz2.swift:25: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002aeebe8b5c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002aeebe5acb6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002aeebe5ac988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002aeebe5ab7b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmp1zdkbtz2                        0x0000556857c08537 <unavailable> + 5431

    5    libc.so.6                          0x00002aeebeaa1460 __libc_start_main +
    245

    6    tmp1zdkbtz2                        0x0000556857c080c9 <unavailable> + 4297

    '
  stdout: ''
  timestamp: 1659980040
- exit_code: -4
  program: "\n/// Input to this function is a string containing multiple groups of\
    \ nested parentheses. Your goal is to\n/// separate those group into separate\
    \ strings and return the array of those.\n/// Separate groups are balanced (each\
    \ open brace is properly closed) and not nested within each other\n/// Ignore\
    \ any spaces in the input string.\n/// >>> separate_paren_groups(paren_string:\
    \ \"( ) (( )) (( )( ))\")\n/// [\"()\", \"(())\", \"(()())\"]\nfunc separate_paren_groups(paren_string:\
    \ String) -> [String] {\n    return []\n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(separate_paren_groups(paren_string: \"(()()) ((())) () ((())()())\") ==\
    \ [\"(()())\", \"((()))\", \"()\", \"((())()())\"])\nassert(separate_paren_groups(paren_string:\
    \ \"() (()) ((())) (((())))\") == [\"()\", \"(())\", \"((()))\", \"(((())))\"\
    ])\nassert(separate_paren_groups(paren_string: \"(()(())((())))\") == [\"(()(())((())))\"\
    ])\nassert(separate_paren_groups(paren_string: \"( ) (( )) (( )( ))\") == [\"\
    ()\", \"(())\", \"(()())\"])"
  status: Exception
  stderr: 'tmp1zdkbtz2/tmp1zdkbtz2.swift:25: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002aeebe8b5c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002aeebe5acb6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002aeebe5ac988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002aeebe5ab7b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmp1zdkbtz2                        0x0000556857c08537 <unavailable> + 5431

    5    libc.so.6                          0x00002aeebeaa1460 __libc_start_main +
    245

    6    tmp1zdkbtz2                        0x0000556857c080c9 <unavailable> + 4297

    '
  stdout: ''
  timestamp: 1659980040
- exit_code: 1
  program: "\n/// Input to this function is a string containing multiple groups of\
    \ nested parentheses. Your goal is to\n/// separate those group into separate\
    \ strings and return the array of those.\n/// Separate groups are balanced (each\
    \ open brace is properly closed) and not nested within each other\n/// Ignore\
    \ any spaces in the input string.\n/// >>> separate_paren_groups(paren_string:\
    \ \"( ) (( )) (( )( ))\")\n/// [\"()\", \"(())\", \"(()())\"]\nfunc separate_paren_groups(paren_string:\
    \ String) -> [String] {\n    let new_string = paren_string.replacingOccurrences(of:\
    \ \" \", with: \"\")\n    let new_string_chars = Array(new_string)\n    var open_paren_indices\
    \ = [Int]()\n    var start_index = 0\n    for (index, char) in new_string_chars.enumerated()\
    \ {\n        if char == \"(\" {\n            open_paren_indices.append(index)\n\
    \        } else if char == \")\" {\n            let temp_arr = Array(new_string_chars[open_paren_indices[start_index]...index])\n\
    \            print(temp_arr)\n            start_index += 1\n        }\n    }\n\
    \    return [\"()\", \"(())\", \"(()())\"]\n}\n\n\nfunc ==(left: [(Int, Int)],\
    \ right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n       \
    \ return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r\
    \ {\n            return false\n        }\n    }\n    return true\n}\n        \
    \    \nassert(separate_paren_groups(paren_string: \"(()()) ((())) () ((())()())\"\
    ) == [\"(()())\", \"((()))\", \"()\", \"((())()())\"])\nassert(separate_paren_groups(paren_string:\
    \ \"() (()) ((())) (((())))\") == [\"()\", \"(())\", \"((()))\", \"(((())))\"\
    ])\nassert(separate_paren_groups(paren_string: \"(()(())((())))\") == [\"(()(())((())))\"\
    ])\nassert(separate_paren_groups(paren_string: \"( ) (( )) (( )( ))\") == [\"\
    ()\", \"(())\", \"(()())\"])"
  status: SyntaxError
  stderr: "/tmp/tmph8k037he.swift:9:35: error: value of type 'String' has no member\
    \ 'replacingOccurrences'\n    let new_string = paren_string.replacingOccurrences(of:\
    \ \" \", with: \"\")\n                     ~~~~~~~~~~~~ ^~~~~~~~~~~~~~~~~~~~\n"
  stdout: ''
  timestamp: 1659980042
- exit_code: -4
  program: "\n/// Input to this function is a string containing multiple groups of\
    \ nested parentheses. Your goal is to\n/// separate those group into separate\
    \ strings and return the array of those.\n/// Separate groups are balanced (each\
    \ open brace is properly closed) and not nested within each other\n/// Ignore\
    \ any spaces in the input string.\n/// >>> separate_paren_groups(paren_string:\
    \ \"( ) (( )) (( )( ))\")\n/// [\"()\", \"(())\", \"(()())\"]\nfunc separate_paren_groups(paren_string:\
    \ String) -> [String] {\n    var openBraceCount = 0\n    var result = [String]()\n\
    \    var tempStr = \"\"\n    for i in paren_string {\n        if i == \"(\" {\n\
    \            openBraceCount += 1\n        } else if i == \")\" {\n           \
    \ openBraceCount -= 1\n        }\n        tempStr.append(i)\n        if openBraceCount\
    \ == 0 {\n            result.append(tempStr)\n            tempStr = \"\"\n   \
    \     }\n    }\n    return result\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int,\
    \ Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n\
    \    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n          \
    \  return false\n        }\n    }\n    return true\n}\n            \nassert(separate_paren_groups(paren_string:\
    \ \"(()()) ((())) () ((())()())\") == [\"(()())\", \"((()))\", \"()\", \"((())()())\"\
    ])\nassert(separate_paren_groups(paren_string: \"() (()) ((())) (((())))\") ==\
    \ [\"()\", \"(())\", \"((()))\", \"(((())))\"])\nassert(separate_paren_groups(paren_string:\
    \ \"(()(())((())))\") == [\"(()(())((())))\"])\nassert(separate_paren_groups(paren_string:\
    \ \"( ) (( )) (( )( ))\") == [\"()\", \"(())\", \"(()())\"])"
  status: Exception
  stderr: 'tmpan6dvm8v/tmpan6dvm8v.swift:40: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b9dfa09ac80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b9df9d91b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b9df9d91988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b9df9d907b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpan6dvm8v                        0x000055fc25bd87e7 <unavailable> + 6119

    5    libc.so.6                          0x00002b9dfa286460 __libc_start_main +
    245

    6    tmpan6dvm8v                        0x000055fc25bd8379 <unavailable> + 4985

    '
  stdout: ''
  timestamp: 1659980043
- exit_code: 1
  program: "\n/// Input to this function is a string containing multiple groups of\
    \ nested parentheses. Your goal is to\n/// separate those group into separate\
    \ strings and return the array of those.\n/// Separate groups are balanced (each\
    \ open brace is properly closed) and not nested within each other\n/// Ignore\
    \ any spaces in the input string.\n/// >>> separate_paren_groups(paren_string:\
    \ \"( ) (( )) (( )( ))\")\n/// [\"()\", \"(())\", \"(()())\"]\nfunc separate_paren_groups(paren_string:\
    \ String) -> [String] {\n    var result = [String]()\n    let tempArr = paren_string.components(separatedBy:\
    \ \" \")\n    var tempStr = \"\"\n    for str in tempArr {\n        tempStr +=\
    \ str\n    }\n    var i = 0\n    while i < tempStr.count {\n        let index\
    \ = tempStr.index(tempStr.startIndex, offsetBy: i)\n        if tempStr[index]\
    \ == \"(\" {\n            let newStr = tempStr.substring(from: index)\n      \
    \      let valid = isValid(newStr)\n            if valid == true {\n         \
    \       result.append(newStr)\n                tempStr = tempStr.substring(to:\
    \ index)\n                i = 0\n            } else {\n                i += 1\n\
    \            }\n        } else {\n            i += 1\n        }\n    }\n    return\
    \ result\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n\
    \    if left.count != right.count {\n        return false\n    }\n    for (l,\
    \ r) in zip(left, right) {\n        if l != r {\n            return false\n  \
    \      }\n    }\n    return true\n}\n            \nassert(separate_paren_groups(paren_string:\
    \ \"(()()) ((())) () ((())()())\") == [\"(()())\", \"((()))\", \"()\", \"((())()())\"\
    ])\nassert(separate_paren_groups(paren_string: \"() (()) ((())) (((())))\") ==\
    \ [\"()\", \"(())\", \"((()))\", \"(((())))\"])\nassert(separate_paren_groups(paren_string:\
    \ \"(()(())((())))\") == [\"(()(())((())))\"])\nassert(separate_paren_groups(paren_string:\
    \ \"( ) (( )) (( )( ))\") == [\"()\", \"(())\", \"(()())\"])"
  status: SyntaxError
  stderr: "/tmp/tmpevluluh6.swift:10:32: error: value of type 'String' has no member\
    \ 'components'\n    let tempArr = paren_string.components(separatedBy: \" \")\n\
    \                  ~~~~~~~~~~~~ ^~~~~~~~~~\n/tmp/tmpevluluh6.swift:19:34: error:\
    \ value of type 'String' has no member 'substring'\n            let newStr = tempStr.substring(from:\
    \ index)\n                         ~~~~~~~ ^~~~~~~~~\n/tmp/tmpevluluh6.swift:20:25:\
    \ error: cannot find 'isValid' in scope\n            let valid = isValid(newStr)\n\
    \                        ^~~~~~~\n/tmp/tmpevluluh6.swift:23:35: error: value of\
    \ type 'String' has no member 'substring'\n                tempStr = tempStr.substring(to:\
    \ index)\n                          ~~~~~~~ ^~~~~~~~~\n"
  stdout: ''
  timestamp: 1659980042
- exit_code: 1
  program: "\n/// Input to this function is a string containing multiple groups of\
    \ nested parentheses. Your goal is to\n/// separate those group into separate\
    \ strings and return the array of those.\n/// Separate groups are balanced (each\
    \ open brace is properly closed) and not nested within each other\n/// Ignore\
    \ any spaces in the input string.\n/// >>> separate_paren_groups(paren_string:\
    \ \"( ) (( )) (( )( ))\")\n/// [\"()\", \"(())\", \"(()())\"]\nfunc separate_paren_groups(paren_string:\
    \ String) -> [String] {\n    let array = Array(paren_string)\n    var result =\
    \ [String]()\n    var i = 0\n    var open = 0\n    var close = 0\n    var start\
    \ = 0\n    while i < array.count {\n        if array[i] == \"(\" {\n         \
    \   open += 1\n            if open == 1 {\n                start = i\n       \
    \     }\n        } else if array[i] == \")\" {\n            close += 1\n     \
    \       if open == close {\n                result.append(paren_string[start..<i+1])\n\
    \                open = 0\n                close = 0\n            }\n        }\n\
    \        i += 1\n    }\n    return result\n}\n\n\nfunc ==(left: [(Int, Int)],\
    \ right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n       \
    \ return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r\
    \ {\n            return false\n        }\n    }\n    return true\n}\n        \
    \    \nassert(separate_paren_groups(paren_string: \"(()()) ((())) () ((())()())\"\
    ) == [\"(()())\", \"((()))\", \"()\", \"((())()())\"])\nassert(separate_paren_groups(paren_string:\
    \ \"() (()) ((())) (((())))\") == [\"()\", \"(())\", \"((()))\", \"(((())))\"\
    ])\nassert(separate_paren_groups(paren_string: \"(()(())((())))\") == [\"(()(())((())))\"\
    ])\nassert(separate_paren_groups(paren_string: \"( ) (( )) (( )( ))\") == [\"\
    ()\", \"(())\", \"(()())\"])"
  status: SyntaxError
  stderr: "/tmp/tmpjc5w91ln.swift:24:31: error: 'subscript(_:)' is unavailable: cannot\
    \ subscript String with an integer range, use a String.Index range instead.\n\
    \                result.append(paren_string[start..<i+1])\n                  \
    \            ^~~~~~~~~~~~~~~~~~~~~~~~~\nSwift.String:5:12: note: 'subscript(_:)'\
    \ has been explicitly marked unavailable here\n    public subscript<R>(bounds:\
    \ R) -> String where R : RangeExpression, R.Bound == Int { get }\n           ^\n"
  stdout: ''
  timestamp: 1659980042
- exit_code: -4
  program: "\n/// Input to this function is a string containing multiple groups of\
    \ nested parentheses. Your goal is to\n/// separate those group into separate\
    \ strings and return the array of those.\n/// Separate groups are balanced (each\
    \ open brace is properly closed) and not nested within each other\n/// Ignore\
    \ any spaces in the input string.\n/// >>> separate_paren_groups(paren_string:\
    \ \"( ) (( )) (( )( ))\")\n/// [\"()\", \"(())\", \"(()())\"]\nfunc separate_paren_groups(paren_string:\
    \ String) -> [String] {\n    return []\n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(separate_paren_groups(paren_string: \"(()()) ((())) () ((())()())\") ==\
    \ [\"(()())\", \"((()))\", \"()\", \"((())()())\"])\nassert(separate_paren_groups(paren_string:\
    \ \"() (()) ((())) (((())))\") == [\"()\", \"(())\", \"((()))\", \"(((())))\"\
    ])\nassert(separate_paren_groups(paren_string: \"(()(())((())))\") == [\"(()(())((())))\"\
    ])\nassert(separate_paren_groups(paren_string: \"( ) (( )) (( )( ))\") == [\"\
    ()\", \"(())\", \"(()())\"])"
  status: Exception
  stderr: 'tmp1zdkbtz2/tmp1zdkbtz2.swift:25: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002aeebe8b5c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002aeebe5acb6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002aeebe5ac988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002aeebe5ab7b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmp1zdkbtz2                        0x0000556857c08537 <unavailable> + 5431

    5    libc.so.6                          0x00002aeebeaa1460 __libc_start_main +
    245

    6    tmp1zdkbtz2                        0x0000556857c080c9 <unavailable> + 4297

    '
  stdout: ''
  timestamp: 1659980040
- exit_code: 1
  program: "\n/// Input to this function is a string containing multiple groups of\
    \ nested parentheses. Your goal is to\n/// separate those group into separate\
    \ strings and return the array of those.\n/// Separate groups are balanced (each\
    \ open brace is properly closed) and not nested within each other\n/// Ignore\
    \ any spaces in the input string.\n/// >>> separate_paren_groups(paren_string:\
    \ \"( ) (( )) (( )( ))\")\n/// [\"()\", \"(())\", \"(()())\"]\nfunc separate_paren_groups(paren_string:\
    \ String) -> [String] {\n    var result = [String]()\n    var start = 0\n    for\
    \ i in paren_string.indices {\n        switch paren_string[i] {\n        case\
    \ \"(\":\n            start = i.encodedOffset\n        case \")\":\n         \
    \   result.append(paren_string[paren_string.index(paren_string.startIndex, offsetBy:\
    \ start)..<i])\n        default:\n            break\n        }\n    }\n    return\
    \ result\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n\
    \    if left.count != right.count {\n        return false\n    }\n    for (l,\
    \ r) in zip(left, right) {\n        if l != r {\n            return false\n  \
    \      }\n    }\n    return true\n}\n            \nassert(separate_paren_groups(paren_string:\
    \ \"(()()) ((())) () ((())()())\") == [\"(()())\", \"((()))\", \"()\", \"((())()())\"\
    ])\nassert(separate_paren_groups(paren_string: \"() (()) ((())) (((())))\") ==\
    \ [\"()\", \"(())\", \"((()))\", \"(((())))\"])\nassert(separate_paren_groups(paren_string:\
    \ \"(()(())((())))\") == [\"(()(())((())))\"])\nassert(separate_paren_groups(paren_string:\
    \ \"( ) (( )) (( )( ))\") == [\"()\", \"(())\", \"(()())\"])"
  status: SyntaxError
  stderr: "/tmp/tmp2h_k66xg.swift:14:23: warning: 'encodedOffset' is deprecated: encodedOffset\
    \ has been deprecated as most common usage is incorrect. Use utf16Offset(in:)\
    \ to achieve the same behavior.\n            start = i.encodedOffset\n       \
    \               ^\n/tmp/tmp2h_k66xg.swift:16:39: error: subscript 'subscript(_:)'\
    \ requires the types 'DefaultIndices<String>.Element' (aka 'String.Index') and\
    \ 'Int' be equivalent\n            result.append(paren_string[paren_string.index(paren_string.startIndex,\
    \ offsetBy: start)..<i])\n                                      ^\nSwift.String:5:12:\
    \ note: where 'R.Bound' = 'DefaultIndices<String>.Element' (aka 'String.Index')\n\
    \    public subscript<R>(bounds: R) -> String where R : RangeExpression, R.Bound\
    \ == Int { get }\n           ^\n"
  stdout: ''
  timestamp: 1659980042
- exit_code: -4
  program: "\n/// Input to this function is a string containing multiple groups of\
    \ nested parentheses. Your goal is to\n/// separate those group into separate\
    \ strings and return the array of those.\n/// Separate groups are balanced (each\
    \ open brace is properly closed) and not nested within each other\n/// Ignore\
    \ any spaces in the input string.\n/// >>> separate_paren_groups(paren_string:\
    \ \"( ) (( )) (( )( ))\")\n/// [\"()\", \"(())\", \"(()())\"]\nfunc separate_paren_groups(paren_string:\
    \ String) -> [String] {\n    if paren_string.isEmpty {\n        return []\n  \
    \  }\n    \n    var characters = Array(paren_string)\n    var result = [String]()\n\
    \    var count = 0\n    var start_index = 0\n    for i in 0 ..< characters.count\
    \ {\n        if characters[i] == \"(\" {\n            count += 1\n        } else\
    \ if characters[i] == \")\" {\n            count -= 1\n        }\n        \n \
    \       if count == 0 {\n            result.append(String(characters[start_index\
    \ ... i]))\n            start_index = i + 1\n        }\n    }\n    \n    return\
    \ result\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n\
    \    if left.count != right.count {\n        return false\n    }\n    for (l,\
    \ r) in zip(left, right) {\n        if l != r {\n            return false\n  \
    \      }\n    }\n    return true\n}\n            \nassert(separate_paren_groups(paren_string:\
    \ \"(()()) ((())) () ((())()())\") == [\"(()())\", \"((()))\", \"()\", \"((())()())\"\
    ])\nassert(separate_paren_groups(paren_string: \"() (()) ((())) (((())))\") ==\
    \ [\"()\", \"(())\", \"((()))\", \"(((())))\"])\nassert(separate_paren_groups(paren_string:\
    \ \"(()(())((())))\") == [\"(()(())((())))\"])\nassert(separate_paren_groups(paren_string:\
    \ \"( ) (( )) (( )( ))\") == [\"()\", \"(())\", \"(()())\"])"
  status: Exception
  stderr: 'tmpfk61zl6c/tmpfk61zl6c.swift:46: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002ab0838ffc80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002ab0835f6b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002ab0835f6988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002ab0835f57b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpfk61zl6c                        0x0000555fcd2b3c27 <unavailable> + 7207

    5    libc.so.6                          0x00002ab083aeb460 __libc_start_main +
    245

    6    tmpfk61zl6c                        0x0000555fcd2b37b9 <unavailable> + 6073

    '
  stdout: ''
  timestamp: 1659980043
- exit_code: 0
  program: "\n/// Input to this function is a string containing multiple groups of\
    \ nested parentheses. Your goal is to\n/// separate those group into separate\
    \ strings and return the array of those.\n/// Separate groups are balanced (each\
    \ open brace is properly closed) and not nested within each other\n/// Ignore\
    \ any spaces in the input string.\n/// >>> separate_paren_groups(paren_string:\
    \ \"( ) (( )) (( )( ))\")\n/// [\"()\", \"(())\", \"(()())\"]\nfunc separate_paren_groups(paren_string:\
    \ String) -> [String] {\n    var ret: [String] = []\n    var temp: String = \"\
    \"\n    var paren_count: Int = 0\n    for c in paren_string {\n        if (c ==\
    \ \" \") {\n            continue\n        }\n        if (c == \"(\") {\n     \
    \       paren_count += 1\n        }\n        if (c == \")\") {\n            paren_count\
    \ -= 1\n        }\n        temp.append(c)\n        if (paren_count == 0) {\n \
    \           ret.append(temp)\n            temp = \"\"\n        }\n    }\n    return\
    \ ret\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n   \
    \ if left.count != right.count {\n        return false\n    }\n    for (l, r)\
    \ in zip(left, right) {\n        if l != r {\n            return false\n     \
    \   }\n    }\n    return true\n}\n            \nassert(separate_paren_groups(paren_string:\
    \ \"(()()) ((())) () ((())()())\") == [\"(()())\", \"((()))\", \"()\", \"((())()())\"\
    ])\nassert(separate_paren_groups(paren_string: \"() (()) ((())) (((())))\") ==\
    \ [\"()\", \"(())\", \"((()))\", \"(((())))\"])\nassert(separate_paren_groups(paren_string:\
    \ \"(()(())((())))\") == [\"(()(())((())))\"])\nassert(separate_paren_groups(paren_string:\
    \ \"( ) (( )) (( )( ))\") == [\"()\", \"(())\", \"(()())\"])"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659980043
- exit_code: 1
  program: "\n/// Input to this function is a string containing multiple groups of\
    \ nested parentheses. Your goal is to\n/// separate those group into separate\
    \ strings and return the array of those.\n/// Separate groups are balanced (each\
    \ open brace is properly closed) and not nested within each other\n/// Ignore\
    \ any spaces in the input string.\n/// >>> separate_paren_groups(paren_string:\
    \ \"( ) (( )) (( )( ))\")\n/// [\"()\", \"(())\", \"(()())\"]\nfunc separate_paren_groups(paren_string:\
    \ String) -> [String] {\n  var result: [String] = []\n  let processed = paren_string.filter\
    \ { $0 != \" \" }\n  var start = 0\n  var cur = 0\n  var stack = 0\n  for ch in\
    \ processed {\n    if ch == \"(\" {\n      stack += 1\n    } else if ch == \"\
    )\" {\n      stack -= 1\n    }\n    cur += 1\n    if stack == 0 {\n      result.append(String(processed[start..<cur]))\n\
    \      start = cur\n    }\n  }\n  return result\n}\n\n\nfunc ==(left: [(Int, Int)],\
    \ right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n       \
    \ return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r\
    \ {\n            return false\n        }\n    }\n    return true\n}\n        \
    \    \nassert(separate_paren_groups(paren_string: \"(()()) ((())) () ((())()())\"\
    ) == [\"(()())\", \"((()))\", \"()\", \"((())()())\"])\nassert(separate_paren_groups(paren_string:\
    \ \"() (()) ((())) (((())))\") == [\"()\", \"(())\", \"((()))\", \"(((())))\"\
    ])\nassert(separate_paren_groups(paren_string: \"(()(())((())))\") == [\"(()(())((())))\"\
    ])\nassert(separate_paren_groups(paren_string: \"( ) (( )) (( )( ))\") == [\"\
    ()\", \"(())\", \"(()())\"])"
  status: SyntaxError
  stderr: "/tmp/tmpm_3nrb2a.swift:22:28: error: 'subscript(_:)' is unavailable: cannot\
    \ subscript String with an integer range, use a String.Index range instead.\n\
    \      result.append(String(processed[start..<cur]))\n                       \
    \    ^~~~~~~~~~~~~~~~~~~~~~\nSwift.String:5:12: note: 'subscript(_:)' has been\
    \ explicitly marked unavailable here\n    public subscript<R>(bounds: R) -> String\
    \ where R : RangeExpression, R.Bound == Int { get }\n           ^\n"
  stdout: ''
  timestamp: 1659980043
- exit_code: 1
  program: "\n/// Input to this function is a string containing multiple groups of\
    \ nested parentheses. Your goal is to\n/// separate those group into separate\
    \ strings and return the array of those.\n/// Separate groups are balanced (each\
    \ open brace is properly closed) and not nested within each other\n/// Ignore\
    \ any spaces in the input string.\n/// >>> separate_paren_groups(paren_string:\
    \ \"( ) (( )) (( )( ))\")\n/// [\"()\", \"(())\", \"(()())\"]\nfunc separate_paren_groups(paren_string:\
    \ String) -> [String] {\n    \n    var results = [String]()\n    var stack = Stack<Character>()\n\
    \    var current_paren_string = \"\"\n    \n    for paren in paren_string {\n\
    \        if paren == \"(\" {\n            stack.push(paren)\n            current_paren_string\
    \ += String(paren)\n        } else if paren == \")\" {\n            guard let\
    \ last = stack.peek() else {\n                fatalError(\"Mismatched parens\"\
    )\n            }\n            if last == \"(\" {\n                stack.pop()\n\
    \                current_paren_string += String(paren)\n                if stack.peek()\
    \ == nil {\n                    results.append(current_paren_string)\n       \
    \             current_paren_string = \"\"\n                }\n            } else\
    \ {\n                fatalError(\"Mismatched parens\")\n            }\n      \
    \  }\n    }\n    \n    return results\n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(separate_paren_groups(paren_string: \"(()()) ((())) () ((())()())\") ==\
    \ [\"(()())\", \"((()))\", \"()\", \"((())()())\"])\nassert(separate_paren_groups(paren_string:\
    \ \"() (()) ((())) (((())))\") == [\"()\", \"(())\", \"((()))\", \"(((())))\"\
    ])\nassert(separate_paren_groups(paren_string: \"(()(())((())))\") == [\"(()(())((())))\"\
    ])\nassert(separate_paren_groups(paren_string: \"( ) (( )) (( )( ))\") == [\"\
    ()\", \"(())\", \"(()())\"])"
  status: SyntaxError
  stderr: "/tmp/tmpft8ru5hh.swift:11:17: error: cannot find 'Stack' in scope\n   \
    \ var stack = Stack<Character>()\n                ^~~~~\n"
  stdout: ''
  timestamp: 1659980043
- exit_code: -4
  program: "\n/// Input to this function is a string containing multiple groups of\
    \ nested parentheses. Your goal is to\n/// separate those group into separate\
    \ strings and return the array of those.\n/// Separate groups are balanced (each\
    \ open brace is properly closed) and not nested within each other\n/// Ignore\
    \ any spaces in the input string.\n/// >>> separate_paren_groups(paren_string:\
    \ \"( ) (( )) (( )( ))\")\n/// [\"()\", \"(())\", \"(()())\"]\nfunc separate_paren_groups(paren_string:\
    \ String) -> [String] {\n    var separated_groups: [String] = []\n    var temp_group:\
    \ String = \"\"\n    var open_braces = 0\n    for char in paren_string {\n   \
    \     if char == \"(\" {\n            open_braces += 1\n            temp_group\
    \ += String(char)\n        } else if char == \")\" {\n            if open_braces\
    \ == 1 {\n                separated_groups.append(temp_group)\n              \
    \  temp_group = \"\"\n            } else {\n                temp_group += String(char)\n\
    \            }\n            open_braces -= 1\n        }\n    }\n    return separated_groups\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(separate_paren_groups(paren_string: \"(()()) ((()))\
    \ () ((())()())\") == [\"(()())\", \"((()))\", \"()\", \"((())()())\"])\nassert(separate_paren_groups(paren_string:\
    \ \"() (()) ((())) (((())))\") == [\"()\", \"(())\", \"((()))\", \"(((())))\"\
    ])\nassert(separate_paren_groups(paren_string: \"(()(())((())))\") == [\"(()(())((())))\"\
    ])\nassert(separate_paren_groups(paren_string: \"( ) (( )) (( )( ))\") == [\"\
    ()\", \"(())\", \"(()())\"])"
  status: Exception
  stderr: 'tmpc1e32gyq/tmpc1e32gyq.swift:42: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b2f4817cc80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b2f47e73b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b2f47e73988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b2f47e727b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpc1e32gyq                        0x00005604beed17e7 <unavailable> + 6119

    5    libc.so.6                          0x00002b2f48368460 __libc_start_main +
    245

    6    tmpc1e32gyq                        0x00005604beed1379 <unavailable> + 4985

    '
  stdout: ''
  timestamp: 1659980043
- exit_code: -4
  program: "\n/// Input to this function is a string containing multiple groups of\
    \ nested parentheses. Your goal is to\n/// separate those group into separate\
    \ strings and return the array of those.\n/// Separate groups are balanced (each\
    \ open brace is properly closed) and not nested within each other\n/// Ignore\
    \ any spaces in the input string.\n/// >>> separate_paren_groups(paren_string:\
    \ \"( ) (( )) (( )( ))\")\n/// [\"()\", \"(())\", \"(()())\"]\nfunc separate_paren_groups(paren_string:\
    \ String) -> [String] {\n    return []\n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(separate_paren_groups(paren_string: \"(()()) ((())) () ((())()())\") ==\
    \ [\"(()())\", \"((()))\", \"()\", \"((())()())\"])\nassert(separate_paren_groups(paren_string:\
    \ \"() (()) ((())) (((())))\") == [\"()\", \"(())\", \"((()))\", \"(((())))\"\
    ])\nassert(separate_paren_groups(paren_string: \"(()(())((())))\") == [\"(()(())((())))\"\
    ])\nassert(separate_paren_groups(paren_string: \"( ) (( )) (( )( ))\") == [\"\
    ()\", \"(())\", \"(()())\"])"
  status: Exception
  stderr: 'tmp1zdkbtz2/tmp1zdkbtz2.swift:25: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002aeebe8b5c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002aeebe5acb6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002aeebe5ac988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002aeebe5ab7b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmp1zdkbtz2                        0x0000556857c08537 <unavailable> + 5431

    5    libc.so.6                          0x00002aeebeaa1460 __libc_start_main +
    245

    6    tmp1zdkbtz2                        0x0000556857c080c9 <unavailable> + 4297

    '
  stdout: ''
  timestamp: 1659980040
- exit_code: -4
  program: "\n/// Input to this function is a string containing multiple groups of\
    \ nested parentheses. Your goal is to\n/// separate those group into separate\
    \ strings and return the array of those.\n/// Separate groups are balanced (each\
    \ open brace is properly closed) and not nested within each other\n/// Ignore\
    \ any spaces in the input string.\n/// >>> separate_paren_groups(paren_string:\
    \ \"( ) (( )) (( )( ))\")\n/// [\"()\", \"(())\", \"(()())\"]\nfunc separate_paren_groups(paren_string:\
    \ String) -> [String] {\n    var delimiters = [Character]()\n    var newStrings\
    \ = [String]()\n    var outputStrings = [String]()\n    var currentString = \"\
    \"\n    var index = 0\n    // This is the loop to go through the entire string\
    \ and find where the delimiters are\n    for char in paren_string {\n        if\
    \ char == \"(\" || char == \")\" {\n            delimiters.append(char)\n    \
    \    }\n    }\n    // This is the loop to put the delimiters into separate strings\
    \ in the newStrings array\n    while index < delimiters.count {\n        if delimiters[index]\
    \ == \"(\" {\n            while delimiters[index] != \")\" {\n               \
    \ currentString += String(delimiters[index])\n                index += 1\n   \
    \         }\n            currentString += String(delimiters[index])\n        \
    \    newStrings.append(currentString)\n            currentString = \"\"\n    \
    \    }\n        index += 1\n    }\n    // This is the loop to go through newStrings\
    \ and put the strings into the outputStrings array\n    for item in newStrings\
    \ {\n        var count = 0\n        for char in item {\n            if char ==\
    \ \"(\" {\n                count += 1\n            } else if char == \")\" {\n\
    \                count -= 1\n            }\n            if count < 0 {\n     \
    \           break\n            }\n        }\n        if count == 0 {\n       \
    \     outputStrings.append(item)\n        }\n    }\n    return outputStrings\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(separate_paren_groups(paren_string: \"(()()) ((()))\
    \ () ((())()())\") == [\"(()())\", \"((()))\", \"()\", \"((())()())\"])\nassert(separate_paren_groups(paren_string:\
    \ \"() (()) ((())) (((())))\") == [\"()\", \"(())\", \"((()))\", \"(((())))\"\
    ])\nassert(separate_paren_groups(paren_string: \"(()(())((())))\") == [\"(()(())((())))\"\
    ])\nassert(separate_paren_groups(paren_string: \"( ) (( )) (( )( ))\") == [\"\
    ()\", \"(())\", \"(()())\"])"
  status: Exception
  stderr: 'tmpmoelw1ik/tmpmoelw1ik.swift:66: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b9e51adcc80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b9e517d3b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b9e517d3988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b9e517d27b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpmoelw1ik                        0x000055f2dcc04af7 <unavailable> + 6903

    5    libc.so.6                          0x00002b9e51cc8460 __libc_start_main +
    245

    6    tmpmoelw1ik                        0x000055f2dcc04689 <unavailable> + 5769

    '
  stdout: ''
  timestamp: 1659980043
- exit_code: 0
  program: "\n/// Input to this function is a string containing multiple groups of\
    \ nested parentheses. Your goal is to\n/// separate those group into separate\
    \ strings and return the array of those.\n/// Separate groups are balanced (each\
    \ open brace is properly closed) and not nested within each other\n/// Ignore\
    \ any spaces in the input string.\n/// >>> separate_paren_groups(paren_string:\
    \ \"( ) (( )) (( )( ))\")\n/// [\"()\", \"(())\", \"(()())\"]\nfunc separate_paren_groups(paren_string:\
    \ String) -> [String] {\n    var out: [String] = []\n    var openCount = 0\n \
    \   var currStr = \"\"\n    paren_string.forEach {\n        if $0 == \"(\" {\n\
    \            openCount += 1\n            currStr.append($0)\n        } else if\
    \ $0 == \")\" {\n            openCount -= 1\n            currStr.append($0)\n\
    \            if openCount == 0 {\n                out.append(currStr)\n      \
    \          currStr = \"\"\n            }\n        }\n    }\n    return out\n}\n\
    \n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(separate_paren_groups(paren_string: \"(()()) ((()))\
    \ () ((())()())\") == [\"(()())\", \"((()))\", \"()\", \"((())()())\"])\nassert(separate_paren_groups(paren_string:\
    \ \"() (()) ((())) (((())))\") == [\"()\", \"(())\", \"((()))\", \"(((())))\"\
    ])\nassert(separate_paren_groups(paren_string: \"(()(())((())))\") == [\"(()(())((())))\"\
    ])\nassert(separate_paren_groups(paren_string: \"( ) (( )) (( )( ))\") == [\"\
    ()\", \"(())\", \"(()())\"])"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659980043
- exit_code: 1
  program: "\n/// Input to this function is a string containing multiple groups of\
    \ nested parentheses. Your goal is to\n/// separate those group into separate\
    \ strings and return the array of those.\n/// Separate groups are balanced (each\
    \ open brace is properly closed) and not nested within each other\n/// Ignore\
    \ any spaces in the input string.\n/// >>> separate_paren_groups(paren_string:\
    \ \"( ) (( )) (( )( ))\")\n/// [\"()\", \"(())\", \"(()())\"]\nfunc separate_paren_groups(paren_string:\
    \ String) -> [String] {\n    var stack = Stack<Character>()\n    var parens =\
    \ \"\"\n    var separated_parens = [String]()\n    \n    for char in paren_string\
    \ {\n        if char == \"(\" {\n            stack.push(char)\n        } else\
    \ if char == \")\" {\n            stack.pop()\n            if stack.isEmpty()\
    \ {\n                separated_parens.append(parens)\n                parens =\
    \ \"\"\n            }\n        }\n        if !stack.isEmpty() {\n            parens.append(char)\n\
    \        }\n    }\n    return separated_parens\n}\n\n\nfunc ==(left: [(Int, Int)],\
    \ right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n       \
    \ return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r\
    \ {\n            return false\n        }\n    }\n    return true\n}\n        \
    \    \nassert(separate_paren_groups(paren_string: \"(()()) ((())) () ((())()())\"\
    ) == [\"(()())\", \"((()))\", \"()\", \"((())()())\"])\nassert(separate_paren_groups(paren_string:\
    \ \"() (()) ((())) (((())))\") == [\"()\", \"(())\", \"((()))\", \"(((())))\"\
    ])\nassert(separate_paren_groups(paren_string: \"(()(())((())))\") == [\"(()(())((())))\"\
    ])\nassert(separate_paren_groups(paren_string: \"( ) (( )) (( )( ))\") == [\"\
    ()\", \"(())\", \"(()())\"])"
  status: SyntaxError
  stderr: "/tmp/tmpzj5nfi6s.swift:9:17: error: cannot find 'Stack' in scope\n    var\
    \ stack = Stack<Character>()\n                ^~~~~\n"
  stdout: ''
  timestamp: 1659980043
- exit_code: 1
  program: "\n/// Input to this function is a string containing multiple groups of\
    \ nested parentheses. Your goal is to\n/// separate those group into separate\
    \ strings and return the array of those.\n/// Separate groups are balanced (each\
    \ open brace is properly closed) and not nested within each other\n/// Ignore\
    \ any spaces in the input string.\n/// >>> separate_paren_groups(paren_string:\
    \ \"( ) (( )) (( )( ))\")\n/// [\"()\", \"(())\", \"(()())\"]\nfunc separate_paren_groups(paren_string:\
    \ String) -> [String] {\n    var result: [String] = []\n    var outer_paren_stack:\
    \ [Int] = []\n    var inner_paren_stack: [Int] = []\n    for (i, paren) in paren_string.enumerated()\
    \ {\n        if paren == \"(\" {\n            if inner_paren_stack.count == 0\
    \ {\n                outer_paren_stack.append(i)\n            }\n            inner_paren_stack.append(i)\n\
    \        } else if paren == \")\" {\n            inner_paren_stack.removeLast()\n\
    \            if inner_paren_stack.count == 0 {\n                let string = paren_string[outer_paren_stack.removeLast()..<i+1]\n\
    \                result.append(String(string))\n            }\n        }\n   \
    \ }\n    return result\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(separate_paren_groups(paren_string:\
    \ \"(()()) ((())) () ((())()())\") == [\"(()())\", \"((()))\", \"()\", \"((())()())\"\
    ])\nassert(separate_paren_groups(paren_string: \"() (()) ((())) (((())))\") ==\
    \ [\"()\", \"(())\", \"((()))\", \"(((())))\"])\nassert(separate_paren_groups(paren_string:\
    \ \"(()(())((())))\") == [\"(()(())((())))\"])\nassert(separate_paren_groups(paren_string:\
    \ \"( ) (( )) (( )( ))\") == [\"()\", \"(())\", \"(()())\"])"
  status: SyntaxError
  stderr: "/tmp/tmp7p4sjxm_.swift:21:30: error: 'subscript(_:)' is unavailable: cannot\
    \ subscript String with an integer range, use a String.Index range instead.\n\
    \                let string = paren_string[outer_paren_stack.removeLast()..<i+1]\n\
    \                             ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n\
    Swift.String:5:12: note: 'subscript(_:)' has been explicitly marked unavailable\
    \ here\n    public subscript<R>(bounds: R) -> String where R : RangeExpression,\
    \ R.Bound == Int { get }\n           ^\n"
  stdout: ''
  timestamp: 1659980043
- exit_code: 1
  program: "\n/// Input to this function is a string containing multiple groups of\
    \ nested parentheses. Your goal is to\n/// separate those group into separate\
    \ strings and return the array of those.\n/// Separate groups are balanced (each\
    \ open brace is properly closed) and not nested within each other\n/// Ignore\
    \ any spaces in the input string.\n/// >>> separate_paren_groups(paren_string:\
    \ \"( ) (( )) (( )( ))\")\n/// [\"()\", \"(())\", \"(()())\"]\nfunc separate_paren_groups(paren_string:\
    \ String) -> [String] {\n    var separated: [String] = []\n    var search = paren_string\n\
    \    while search.count > 0 {\n        guard let range = search.range(of: \"\\\
    \\([^\\\\(\\\\)]*\\\\)\", options: .regularExpression) else {\n            break\n\
    \        }\n        let s = String(search[range])\n        separated.append(s)\n\
    \        search.removeSubrange(range)\n    }\n    return separated\n}\n\n\nfunc\
    \ ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count !=\
    \ right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(separate_paren_groups(paren_string: \"(()()) ((()))\
    \ () ((())()())\") == [\"(()())\", \"((()))\", \"()\", \"((())()())\"])\nassert(separate_paren_groups(paren_string:\
    \ \"() (()) ((())) (((())))\") == [\"()\", \"(())\", \"((()))\", \"(((())))\"\
    ])\nassert(separate_paren_groups(paren_string: \"(()(())((())))\") == [\"(()(())((())))\"\
    ])\nassert(separate_paren_groups(paren_string: \"( ) (( )) (( )( ))\") == [\"\
    ()\", \"(())\", \"(()())\"])"
  status: SyntaxError
  stderr: "/tmp/tmpyyd92b90.swift:12:34: error: value of type 'String' has no member\
    \ 'range'\n        guard let range = search.range(of: \"\\\\([^\\\\(\\\\)]*\\\\\
    )\", options: .regularExpression) else {\n                          ~~~~~~ ^~~~~\n\
    /tmp/tmpyyd92b90.swift:12:74: error: cannot infer contextual base in reference\
    \ to member 'regularExpression'\n        guard let range = search.range(of: \"\
    \\\\([^\\\\(\\\\)]*\\\\)\", options: .regularExpression) else {\n            \
    \                                                            ~^~~~~~~~~~~~~~~~~\n"
  stdout: ''
  timestamp: 1659980043
- exit_code: -4
  program: "\n/// Input to this function is a string containing multiple groups of\
    \ nested parentheses. Your goal is to\n/// separate those group into separate\
    \ strings and return the array of those.\n/// Separate groups are balanced (each\
    \ open brace is properly closed) and not nested within each other\n/// Ignore\
    \ any spaces in the input string.\n/// >>> separate_paren_groups(paren_string:\
    \ \"( ) (( )) (( )( ))\")\n/// [\"()\", \"(())\", \"(()())\"]\nfunc separate_paren_groups(paren_string:\
    \ String) -> [String] {\n    var input = paren_string\n    var out: [String] =\
    \ []\n    while let i = input.index(of: \"(\") {\n        let left = i\n     \
    \   var j = left\n        var count = 1\n        while count > 0 {\n         \
    \   j = input.index(after: j)\n            if input[j] == \"(\" {\n          \
    \      count += 1\n            } else if input[j] == \")\" {\n               \
    \ count -= 1\n            }\n        }\n        out.append(String(input[left...j]))\n\
    \        input = String(input[input.index(after: j)...])\n    }\n    return out\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(separate_paren_groups(paren_string: \"(()()) ((()))\
    \ () ((())()())\") == [\"(()())\", \"((()))\", \"()\", \"((())()())\"])\nassert(separate_paren_groups(paren_string:\
    \ \"() (()) ((())) (((())))\") == [\"()\", \"(())\", \"((()))\", \"(((())))\"\
    ])\nassert(separate_paren_groups(paren_string: \"(()(())((())))\") == [\"(()(())((())))\"\
    ])\nassert(separate_paren_groups(paren_string: \"( ) (( )) (( )( ))\") == [\"\
    ()\", \"(())\", \"(()())\"])"
  status: Exception
  stderr: 'tmpo9w8erd_/tmpo9w8erd_.swift:45: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002aeadfde5c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002aeadfadcb6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002aeadfadc988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002aeadfadb7b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpo9w8erd_                        0x000055958128ef52 <unavailable> + 8018

    5    libc.so.6                          0x00002aeadffd1460 __libc_start_main +
    245

    6    tmpo9w8erd_                        0x000055958128e639 <unavailable> + 5689

    '
  stdout: ''
  timestamp: 1659980043
- exit_code: -4
  program: "\n/// Input to this function is a string containing multiple groups of\
    \ nested parentheses. Your goal is to\n/// separate those group into separate\
    \ strings and return the array of those.\n/// Separate groups are balanced (each\
    \ open brace is properly closed) and not nested within each other\n/// Ignore\
    \ any spaces in the input string.\n/// >>> separate_paren_groups(paren_string:\
    \ \"( ) (( )) (( )( ))\")\n/// [\"()\", \"(())\", \"(()())\"]\nfunc separate_paren_groups(paren_string:\
    \ String) -> [String] {\n    var parens = [String]()\n    var numOpens = 0\n \
    \   var numCloses = 0\n    var start = 0\n    var i = 0\n    while i < paren_string.count\
    \ {\n        let curr = String(paren_string[paren_string.index(paren_string.startIndex,\
    \ offsetBy: i)])\n        if curr == \"(\" {\n            numOpens += 1\n    \
    \    } else if curr == \")\" {\n            numCloses += 1\n        }\n      \
    \  if numOpens == numCloses {\n            parens.append(String(paren_string[paren_string.index(paren_string.startIndex,\
    \ offsetBy: start)..<paren_string.index(paren_string.startIndex, offsetBy: i +\
    \ 1)]))\n            start = i + 1\n            numOpens = 0\n            numCloses\
    \ = 0\n        }\n        i += 1\n    }\n    return parens\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(separate_paren_groups(paren_string: \"(()()) ((())) ()\
    \ ((())()())\") == [\"(()())\", \"((()))\", \"()\", \"((())()())\"])\nassert(separate_paren_groups(paren_string:\
    \ \"() (()) ((())) (((())))\") == [\"()\", \"(())\", \"((()))\", \"(((())))\"\
    ])\nassert(separate_paren_groups(paren_string: \"(()(())((())))\") == [\"(()(())((())))\"\
    ])\nassert(separate_paren_groups(paren_string: \"( ) (( )) (( )( ))\") == [\"\
    ()\", \"(())\", \"(()())\"])"
  status: Exception
  stderr: 'tmpi4o6zkdl/tmpi4o6zkdl.swift:45: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002acaeea67c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002acaee75eb6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002acaee75e988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002acaee75d7b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpi4o6zkdl                        0x000055ce59fca937 <unavailable> + 6455

    5    libc.so.6                          0x00002acaeec53460 __libc_start_main +
    245

    6    tmpi4o6zkdl                        0x000055ce59fca4c9 <unavailable> + 5321

    '
  stdout: ''
  timestamp: 1659980043
- exit_code: 1
  program: "\n/// Input to this function is a string containing multiple groups of\
    \ nested parentheses. Your goal is to\n/// separate those group into separate\
    \ strings and return the array of those.\n/// Separate groups are balanced (each\
    \ open brace is properly closed) and not nested within each other\n/// Ignore\
    \ any spaces in the input string.\n/// >>> separate_paren_groups(paren_string:\
    \ \"( ) (( )) (( )( ))\")\n/// [\"()\", \"(())\", \"(()())\"]\nfunc separate_paren_groups(paren_string:\
    \ String) -> [String] {\n    let parens = paren_string.replacingOccurrences(of:\
    \ \" \", with: \"\")\n    let parens_count = parens.count\n    var groups = [String]()\n\
    \    var group = String()\n    var parens_array = Array(parens)\n    var count\
    \ = 0\n    for i in 0..<parens_count {\n        group.append(parens_array[i])\n\
    \        if parens_array[i] == \"(\" {\n            count += 1\n        } else\
    \ {\n            count -= 1\n        }\n        if count == 0 {\n            groups.append(group)\n\
    \            group = String()\n        }\n    }\n    return groups\n}\n\n\nfunc\
    \ ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count !=\
    \ right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(separate_paren_groups(paren_string: \"(()()) ((()))\
    \ () ((())()())\") == [\"(()())\", \"((()))\", \"()\", \"((())()())\"])\nassert(separate_paren_groups(paren_string:\
    \ \"() (()) ((())) (((())))\") == [\"()\", \"(())\", \"((()))\", \"(((())))\"\
    ])\nassert(separate_paren_groups(paren_string: \"(()(())((())))\") == [\"(()(())((())))\"\
    ])\nassert(separate_paren_groups(paren_string: \"( ) (( )) (( )( ))\") == [\"\
    ()\", \"(())\", \"(()())\"])"
  status: SyntaxError
  stderr: "/tmp/tmp99f1hmyi.swift:9:31: error: value of type 'String' has no member\
    \ 'replacingOccurrences'\n    let parens = paren_string.replacingOccurrences(of:\
    \ \" \", with: \"\")\n                 ~~~~~~~~~~~~ ^~~~~~~~~~~~~~~~~~~~\n"
  stdout: ''
  timestamp: 1659980043
- exit_code: -4
  program: "\n/// Input to this function is a string containing multiple groups of\
    \ nested parentheses. Your goal is to\n/// separate those group into separate\
    \ strings and return the array of those.\n/// Separate groups are balanced (each\
    \ open brace is properly closed) and not nested within each other\n/// Ignore\
    \ any spaces in the input string.\n/// >>> separate_paren_groups(paren_string:\
    \ \"( ) (( )) (( )( ))\")\n/// [\"()\", \"(())\", \"(()())\"]\nfunc separate_paren_groups(paren_string:\
    \ String) -> [String] {\n    var array: [String] = []\n    var numberOpen = 0\n\
    \    var numberClose = 0\n    var result = \"\"\n    for char in paren_string\
    \ {\n        if char == \"(\" {\n            numberOpen += 1\n        } else if\
    \ char == \")\" {\n            numberClose += 1\n        }\n        if numberOpen\
    \ == numberClose {\n            array.append(result)\n            result = \"\"\
    \n            numberOpen = 0\n            numberClose = 0\n        } else {\n\
    \            result += String(char)\n        }\n    }\n    return array\n}\n\n\
    \nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(separate_paren_groups(paren_string: \"(()()) ((()))\
    \ () ((())()())\") == [\"(()())\", \"((()))\", \"()\", \"((())()())\"])\nassert(separate_paren_groups(paren_string:\
    \ \"() (()) ((())) (((())))\") == [\"()\", \"(())\", \"((()))\", \"(((())))\"\
    ])\nassert(separate_paren_groups(paren_string: \"(()(())((())))\") == [\"(()(())((())))\"\
    ])\nassert(separate_paren_groups(paren_string: \"( ) (( )) (( )( ))\") == [\"\
    ()\", \"(())\", \"(()())\"])"
  status: Exception
  stderr: 'tmp0yt_xn60/tmp0yt_xn60.swift:44: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b50601c6c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b505febdb6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b505febd988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b505febc7b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmp0yt_xn60                        0x00005565f9b037e7 <unavailable> + 6119

    5    libc.so.6                          0x00002b50603b2460 __libc_start_main +
    245

    6    tmp0yt_xn60                        0x00005565f9b03379 <unavailable> + 4985

    '
  stdout: ''
  timestamp: 1659980043
- exit_code: -4
  program: "\n/// Input to this function is a string containing multiple groups of\
    \ nested parentheses. Your goal is to\n/// separate those group into separate\
    \ strings and return the array of those.\n/// Separate groups are balanced (each\
    \ open brace is properly closed) and not nested within each other\n/// Ignore\
    \ any spaces in the input string.\n/// >>> separate_paren_groups(paren_string:\
    \ \"( ) (( )) (( )( ))\")\n/// [\"()\", \"(())\", \"(()())\"]\nfunc separate_paren_groups(paren_string:\
    \ String) -> [String] {\n    var answer: [String] = []\n    var paren_string =\
    \ paren_string\n    while paren_string.contains(\"(\") {\n        var tmp_str\
    \ = \"\"\n        var brackets_count = 0\n        for i in paren_string {\n  \
    \          if i == \"(\" {\n                brackets_count += 1\n            }\
    \ else if i == \")\" {\n                brackets_count -= 1\n            }\n \
    \           tmp_str.append(i)\n            if brackets_count == 0 {\n        \
    \        paren_string.removeFirst(tmp_str.count)\n                answer.append(tmp_str)\n\
    \                break\n            }\n        }\n    }\n    return answer\n}\n\
    \n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(separate_paren_groups(paren_string: \"(()()) ((()))\
    \ () ((())()())\") == [\"(()())\", \"((()))\", \"()\", \"((())()())\"])\nassert(separate_paren_groups(paren_string:\
    \ \"() (()) ((())) (((())))\") == [\"()\", \"(())\", \"((()))\", \"(((())))\"\
    ])\nassert(separate_paren_groups(paren_string: \"(()(())((())))\") == [\"(()(())((())))\"\
    ])\nassert(separate_paren_groups(paren_string: \"( ) (( )) (( )( ))\") == [\"\
    ()\", \"(())\", \"(()())\"])"
  status: Exception
  stderr: 'tmpshhj0391/tmpshhj0391.swift:44: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b9fe5596c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b9fe528db6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b9fe528d988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b9fe528c7b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpshhj0391                        0x000055eabfb3a957 <unavailable> + 6487

    5    libc.so.6                          0x00002b9fe5782460 __libc_start_main +
    245

    6    tmpshhj0391                        0x000055eabfb3a4e9 <unavailable> + 5353

    '
  stdout: ''
  timestamp: 1659980043
- exit_code: -4
  program: "\n/// Input to this function is a string containing multiple groups of\
    \ nested parentheses. Your goal is to\n/// separate those group into separate\
    \ strings and return the array of those.\n/// Separate groups are balanced (each\
    \ open brace is properly closed) and not nested within each other\n/// Ignore\
    \ any spaces in the input string.\n/// >>> separate_paren_groups(paren_string:\
    \ \"( ) (( )) (( )( ))\")\n/// [\"()\", \"(())\", \"(()())\"]\nfunc separate_paren_groups(paren_string:\
    \ String) -> [String] {\n    var result: [String] = []\n    var ptr = 0\n    var\
    \ parenGroups: [String] = []\n    var s = paren_string.filter { (c) -> Bool in\n\
    \        c != \" \"\n    }\n    while ptr < s.count {\n        var paren = \"\"\
    \n        var totalOpen = 0\n        while ptr < s.count {\n            let c\
    \ = s[s.index(s.startIndex, offsetBy: ptr)]\n            if c == \"(\" {\n   \
    \             totalOpen += 1\n            } else if c == \")\" {\n           \
    \     totalOpen -= 1\n            }\n            paren.append(c)\n           \
    \ ptr += 1\n            if totalOpen == 0 {\n                break\n         \
    \   }\n        }\n        parenGroups.append(paren)\n    }\n    print(parenGroups)\n\
    \    return result\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) ->\
    \ Bool {\n    if left.count != right.count {\n        return false\n    }\n  \
    \  for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(separate_paren_groups(paren_string:\
    \ \"(()()) ((())) () ((())()())\") == [\"(()())\", \"((()))\", \"()\", \"((())()())\"\
    ])\nassert(separate_paren_groups(paren_string: \"() (()) ((())) (((())))\") ==\
    \ [\"()\", \"(())\", \"((()))\", \"(((())))\"])\nassert(separate_paren_groups(paren_string:\
    \ \"(()(())((())))\") == [\"(()(())((())))\"])\nassert(separate_paren_groups(paren_string:\
    \ \"( ) (( )) (( )( ))\") == [\"()\", \"(())\", \"(()())\"])"
  status: Exception
  stderr: 'tmpi120bp3z/tmpi120bp3z.swift:50: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b8ae3c3fc80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b8ae3936b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b8ae3936988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b8ae39357b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpi120bp3z                        0x00005612579309f7 <unavailable> + 6647

    5    libc.so.6                          0x00002b8ae3e2b460 __libc_start_main +
    245

    6    tmpi120bp3z                        0x0000561257930589 <unavailable> + 5513

    '
  stdout: ''
  timestamp: 1659980043
- exit_code: 1
  program: "\n/// Input to this function is a string containing multiple groups of\
    \ nested parentheses. Your goal is to\n/// separate those group into separate\
    \ strings and return the array of those.\n/// Separate groups are balanced (each\
    \ open brace is properly closed) and not nested within each other\n/// Ignore\
    \ any spaces in the input string.\n/// >>> separate_paren_groups(paren_string:\
    \ \"( ) (( )) (( )( ))\")\n/// [\"()\", \"(())\", \"(()())\"]\nfunc separate_paren_groups(paren_string:\
    \ String) -> [String] {\n    var stack: [Character] = []\n    var temp: [Character]\
    \ = []\n    var res: [String] = []\n    let start: Character = \"(\"\n    let\
    \ end: Character = \")\"\n    let paren_string = paren_string.replacingOccurrences(of:\
    \ \" \", with: \"\")\n    for char in paren_string {\n        if char == start\
    \ {\n            stack.append(char)\n        } else if char == end {\n       \
    \     temp.append(stack.popLast()!)\n            temp.append(char)\n         \
    \   if stack.isEmpty {\n                res.append(String(temp))\n           \
    \     temp = []\n            }\n        }\n    }\n    return res\n}\n\n\nfunc\
    \ ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count !=\
    \ right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(separate_paren_groups(paren_string: \"(()()) ((()))\
    \ () ((())()())\") == [\"(()())\", \"((()))\", \"()\", \"((())()())\"])\nassert(separate_paren_groups(paren_string:\
    \ \"() (()) ((())) (((())))\") == [\"()\", \"(())\", \"((()))\", \"(((())))\"\
    ])\nassert(separate_paren_groups(paren_string: \"(()(())((())))\") == [\"(()(())((())))\"\
    ])\nassert(separate_paren_groups(paren_string: \"( ) (( )) (( )( ))\") == [\"\
    ()\", \"(())\", \"(()())\"])"
  status: SyntaxError
  stderr: "/tmp/tmpsn8n5uza.swift:14:37: error: value of type 'String' has no member\
    \ 'replacingOccurrences'\n    let paren_string = paren_string.replacingOccurrences(of:\
    \ \" \", with: \"\")\n                       ~~~~~~~~~~~~ ^~~~~~~~~~~~~~~~~~~~\n"
  stdout: ''
  timestamp: 1659980043
- exit_code: 0
  program: "\n/// Input to this function is a string containing multiple groups of\
    \ nested parentheses. Your goal is to\n/// separate those group into separate\
    \ strings and return the array of those.\n/// Separate groups are balanced (each\
    \ open brace is properly closed) and not nested within each other\n/// Ignore\
    \ any spaces in the input string.\n/// >>> separate_paren_groups(paren_string:\
    \ \"( ) (( )) (( )( ))\")\n/// [\"()\", \"(())\", \"(()())\"]\nfunc separate_paren_groups(paren_string:\
    \ String) -> [String] {\n    \n    var groups = [String]()\n    var paren = paren_string.filter\
    \ { !\" \\n\\t\\r\".contains($0) }\n    var i = 0\n    var currentString = \"\"\
    \n    var count = 0\n    \n    while i < paren.count {\n        let char = paren[paren.index(paren.startIndex,\
    \ offsetBy: i)]\n        if char == \"(\" {\n            count += 1\n        }\
    \ else if char == \")\" {\n            count -= 1\n        }\n        currentString.append(char)\n\
    \        if count == 0 {\n            groups.append(currentString)\n         \
    \   currentString = \"\"\n        }\n        i += 1\n    }\n    \n    return groups\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(separate_paren_groups(paren_string: \"(()()) ((()))\
    \ () ((())()())\") == [\"(()())\", \"((()))\", \"()\", \"((())()())\"])\nassert(separate_paren_groups(paren_string:\
    \ \"() (()) ((())) (((())))\") == [\"()\", \"(())\", \"((()))\", \"(((())))\"\
    ])\nassert(separate_paren_groups(paren_string: \"(()(())((())))\") == [\"(()(())((())))\"\
    ])\nassert(separate_paren_groups(paren_string: \"( ) (( )) (( )( ))\") == [\"\
    ()\", \"(())\", \"(()())\"])"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659980043
- exit_code: -4
  program: "\n/// Input to this function is a string containing multiple groups of\
    \ nested parentheses. Your goal is to\n/// separate those group into separate\
    \ strings and return the array of those.\n/// Separate groups are balanced (each\
    \ open brace is properly closed) and not nested within each other\n/// Ignore\
    \ any spaces in the input string.\n/// >>> separate_paren_groups(paren_string:\
    \ \"( ) (( )) (( )( ))\")\n/// [\"()\", \"(())\", \"(()())\"]\nfunc separate_paren_groups(paren_string:\
    \ String) -> [String] {\n    //MARK: - \n    // TODO: Write your code here!\n\
    \    return []\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool\
    \ {\n    if left.count != right.count {\n        return false\n    }\n    for\
    \ (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(separate_paren_groups(paren_string:\
    \ \"(()()) ((())) () ((())()())\") == [\"(()())\", \"((()))\", \"()\", \"((())()())\"\
    ])\nassert(separate_paren_groups(paren_string: \"() (()) ((())) (((())))\") ==\
    \ [\"()\", \"(())\", \"((()))\", \"(((())))\"])\nassert(separate_paren_groups(paren_string:\
    \ \"(()(())((())))\") == [\"(()(())((())))\"])\nassert(separate_paren_groups(paren_string:\
    \ \"( ) (( )) (( )( ))\") == [\"()\", \"(())\", \"(()())\"])"
  status: Exception
  stderr: 'tmpium1mon4/tmpium1mon4.swift:27: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002ac8c1a81c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002ac8c1778b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002ac8c1778988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002ac8c17777b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpium1mon4                        0x000055b8b7725537 <unavailable> + 5431

    5    libc.so.6                          0x00002ac8c1c6d460 __libc_start_main +
    245

    6    tmpium1mon4                        0x000055b8b77250c9 <unavailable> + 4297

    '
  stdout: ''
  timestamp: 1659980043
