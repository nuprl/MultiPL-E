language: swift
name: HumanEval_161_solve
results:
- exit_code: 1
  program: "\n/// You are given a string s.\n/// if s[i] is a letter, reverse its\
    \ case from lower to upper or vise versa, \n/// otherwise keep it as it is.\n\
    /// If the string contains no letters, reverse the string.\n/// The function should\
    \ return the resulted string.\n/// Examples\n/// >>> solve(s: \"1234\")\n/// \"\
    4321\"\n/// >>> solve(s: \"ab\")\n/// \"AB\"\n/// >>> solve(s: \"#a@C\")\n///\
    \ \"#A@c\"\nfunc solve(s: String) -> String {\n    return String(s.reversed().map\
    \ { $0.isLetter ? String($0).lowercased() == String($0) ? String($0).uppercased()\
    \ : String($0).lowercased() : String($0) })\n}\n\n\nfunc ==(left: [(Int, Int)],\
    \ right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n       \
    \ return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r\
    \ {\n            return false\n        }\n    }\n    return true\n}\n        \
    \    \nassert(solve(s: \"AsDf\") == \"aSdF\")\nassert(solve(s: \"1234\") == \"\
    4321\")\nassert(solve(s: \"ab\") == \"AB\")\nassert(solve(s: \"#a@C\") == \"#A@c\"\
    )\nassert(solve(s: \"#AsdfW^45\") == \"#aSDFw^45\")\nassert(solve(s: \"#6@2\"\
    ) == \"2@6#\")\nassert(solve(s: \"#$a^D\") == \"#$A^d\")\nassert(solve(s: \"#ccc\"\
    ) == \"#CCC\")"
  status: SyntaxError
  stderr: "/tmp/tmpegpuyh65.swift:15:12: error: type of expression is ambiguous without\
    \ more context\n    return String(s.reversed().map { $0.isLetter ? String($0).lowercased()\
    \ == String($0) ? String($0).uppercased() : String($0).lowercased() : String($0)\
    \ })\n           ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n"
  stdout: ''
  timestamp: 1659978812
- exit_code: -4
  program: "\n/// You are given a string s.\n/// if s[i] is a letter, reverse its\
    \ case from lower to upper or vise versa, \n/// otherwise keep it as it is.\n\
    /// If the string contains no letters, reverse the string.\n/// The function should\
    \ return the resulted string.\n/// Examples\n/// >>> solve(s: \"1234\")\n/// \"\
    4321\"\n/// >>> solve(s: \"ab\")\n/// \"AB\"\n/// >>> solve(s: \"#a@C\")\n///\
    \ \"#A@c\"\nfunc solve(s: String) -> String {\n    var str = String()\n    for\
    \ ch in s {\n        if ch.isLetter {\n            if ch.isLowercase {\n     \
    \           str.append(ch.uppercased())\n            } else {\n              \
    \  str.append(ch.lowercased())\n            }\n        } else {\n            str.append(ch)\n\
    \        }\n    }\n    return str.isEmpty ? String(s.reversed()) : str\n}\n\n\n\
    func ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(solve(s: \"AsDf\") == \"aSdF\")\nassert(solve(s:\
    \ \"1234\") == \"4321\")\nassert(solve(s: \"ab\") == \"AB\")\nassert(solve(s:\
    \ \"#a@C\") == \"#A@c\")\nassert(solve(s: \"#AsdfW^45\") == \"#aSDFw^45\")\nassert(solve(s:\
    \ \"#6@2\") == \"2@6#\")\nassert(solve(s: \"#$a^D\") == \"#$A^d\")\nassert(solve(s:\
    \ \"#ccc\") == \"#CCC\")"
  status: Exception
  stderr: 'tmp6_kpryw4/tmp6_kpryw4.swift:44: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b699b0f9c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b699adf0b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b699adf0988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b699adef7b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmp6_kpryw4                        0x0000556aa7e9b937 <unavailable> + 6455

    5    libc.so.6                          0x00002b699b2e5460 __libc_start_main +
    245

    6    tmp6_kpryw4                        0x0000556aa7e9b489 <unavailable> + 5257

    '
  stdout: ''
  timestamp: 1659978811
- exit_code: -4
  program: "\n/// You are given a string s.\n/// if s[i] is a letter, reverse its\
    \ case from lower to upper or vise versa, \n/// otherwise keep it as it is.\n\
    /// If the string contains no letters, reverse the string.\n/// The function should\
    \ return the resulted string.\n/// Examples\n/// >>> solve(s: \"1234\")\n/// \"\
    4321\"\n/// >>> solve(s: \"ab\")\n/// \"AB\"\n/// >>> solve(s: \"#a@C\")\n///\
    \ \"#A@c\"\nfunc solve(s: String) -> String {\n    if s.contains(\"[a-zA-Z]\"\
    ) {\n        return String(s.reversed())\n    } else {\n        return s.lowercased()\n\
    \    }\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n  \
    \  if left.count != right.count {\n        return false\n    }\n    for (l, r)\
    \ in zip(left, right) {\n        if l != r {\n            return false\n     \
    \   }\n    }\n    return true\n}\n            \nassert(solve(s: \"AsDf\") == \"\
    aSdF\")\nassert(solve(s: \"1234\") == \"4321\")\nassert(solve(s: \"ab\") == \"\
    AB\")\nassert(solve(s: \"#a@C\") == \"#A@c\")\nassert(solve(s: \"#AsdfW^45\")\
    \ == \"#aSDFw^45\")\nassert(solve(s: \"#6@2\") == \"2@6#\")\nassert(solve(s: \"\
    #$a^D\") == \"#$A^d\")\nassert(solve(s: \"#ccc\") == \"#CCC\")"
  status: Exception
  stderr: 'tmp6i34fj4h/tmp6i34fj4h.swift:35: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b9a6e07fc80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b9a6dd76b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b9a6dd76988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b9a6dd757b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmp6i34fj4h                        0x000056286dafb5e7 <unavailable> + 5607

    5    libc.so.6                          0x00002b9a6e26b460 __libc_start_main +
    245

    6    tmp6i34fj4h                        0x000056286dafb229 <unavailable> + 4649

    '
  stdout: ''
  timestamp: 1659978811
- exit_code: -4
  program: "\n/// You are given a string s.\n/// if s[i] is a letter, reverse its\
    \ case from lower to upper or vise versa, \n/// otherwise keep it as it is.\n\
    /// If the string contains no letters, reverse the string.\n/// The function should\
    \ return the resulted string.\n/// Examples\n/// >>> solve(s: \"1234\")\n/// \"\
    4321\"\n/// >>> solve(s: \"ab\")\n/// \"AB\"\n/// >>> solve(s: \"#a@C\")\n///\
    \ \"#A@c\"\nfunc solve(s: String) -> String {\n  return \"\"\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(solve(s: \"AsDf\") == \"aSdF\")\nassert(solve(s: \"1234\"\
    ) == \"4321\")\nassert(solve(s: \"ab\") == \"AB\")\nassert(solve(s: \"#a@C\")\
    \ == \"#A@c\")\nassert(solve(s: \"#AsdfW^45\") == \"#aSDFw^45\")\nassert(solve(s:\
    \ \"#6@2\") == \"2@6#\")\nassert(solve(s: \"#$a^D\") == \"#$A^d\")\nassert(solve(s:\
    \ \"#ccc\") == \"#CCC\")"
  status: Exception
  stderr: 'tmp70mw71yg/tmp70mw71yg.swift:31: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002ad3866cbc80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002ad3863c2b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002ad3863c2988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002ad3863c17b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmp70mw71yg                        0x000055b1ec08f307 <unavailable> + 4871

    5    libc.so.6                          0x00002ad3868b7460 __libc_start_main +
    245

    6    tmp70mw71yg                        0x000055b1ec08ef49 <unavailable> + 3913

    '
  stdout: ''
  timestamp: 1659978811
- exit_code: 1
  program: "\n/// You are given a string s.\n/// if s[i] is a letter, reverse its\
    \ case from lower to upper or vise versa, \n/// otherwise keep it as it is.\n\
    /// If the string contains no letters, reverse the string.\n/// The function should\
    \ return the resulted string.\n/// Examples\n/// >>> solve(s: \"1234\")\n/// \"\
    4321\"\n/// >>> solve(s: \"ab\")\n/// \"AB\"\n/// >>> solve(s: \"#a@C\")\n///\
    \ \"#A@c\"\nfunc solve(s: String) -> String {\n    var r = s.reversed()\n    if\
    \ let char = r.first, char.isLetter {\n        r = String(r.map { char in\n  \
    \          if char.isLetter {\n                return char.isUppercase ? Character(char.lowercased())\
    \ : Character(char.uppercased())\n            }\n            return char\n   \
    \     })\n    }\n    return String(r)\n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(solve(s: \"AsDf\") == \"aSdF\")\nassert(solve(s: \"1234\") == \"4321\"\
    )\nassert(solve(s: \"ab\") == \"AB\")\nassert(solve(s: \"#a@C\") == \"#A@c\")\n\
    assert(solve(s: \"#AsdfW^45\") == \"#aSDFw^45\")\nassert(solve(s: \"#6@2\") ==\
    \ \"2@6#\")\nassert(solve(s: \"#$a^D\") == \"#$A^d\")\nassert(solve(s: \"#ccc\"\
    ) == \"#CCC\")"
  status: SyntaxError
  stderr: "/tmp/tmpxe9lfpcv.swift:17:13: error: cannot assign value of type 'String'\
    \ to type 'ReversedCollection<String>'\n        r = String(r.map { char in\n \
    \           ^~~~~~~~~~~~~~~~~~~~~~\n"
  stdout: ''
  timestamp: 1659978811
- exit_code: -4
  program: "\n/// You are given a string s.\n/// if s[i] is a letter, reverse its\
    \ case from lower to upper or vise versa, \n/// otherwise keep it as it is.\n\
    /// If the string contains no letters, reverse the string.\n/// The function should\
    \ return the resulted string.\n/// Examples\n/// >>> solve(s: \"1234\")\n/// \"\
    4321\"\n/// >>> solve(s: \"ab\")\n/// \"AB\"\n/// >>> solve(s: \"#a@C\")\n///\
    \ \"#A@c\"\nfunc solve(s: String) -> String {\n    return String(s.reversed())\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(solve(s: \"AsDf\") == \"aSdF\")\nassert(solve(s:\
    \ \"1234\") == \"4321\")\nassert(solve(s: \"ab\") == \"AB\")\nassert(solve(s:\
    \ \"#a@C\") == \"#A@c\")\nassert(solve(s: \"#AsdfW^45\") == \"#aSDFw^45\")\nassert(solve(s:\
    \ \"#6@2\") == \"2@6#\")\nassert(solve(s: \"#$a^D\") == \"#$A^d\")\nassert(solve(s:\
    \ \"#ccc\") == \"#CCC\")"
  status: Exception
  stderr: 'tmp696wl_20/tmp696wl_20.swift:31: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b50fb546c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b50fb23db6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b50fb23d988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b50fb23c7b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmp696wl_20                        0x000056347238f4e7 <unavailable> + 5351

    5    libc.so.6                          0x00002b50fb732460 __libc_start_main +
    245

    6    tmp696wl_20                        0x000056347238f129 <unavailable> + 4393

    '
  stdout: ''
  timestamp: 1659978811
- exit_code: 0
  program: "\n/// You are given a string s.\n/// if s[i] is a letter, reverse its\
    \ case from lower to upper or vise versa, \n/// otherwise keep it as it is.\n\
    /// If the string contains no letters, reverse the string.\n/// The function should\
    \ return the resulted string.\n/// Examples\n/// >>> solve(s: \"1234\")\n/// \"\
    4321\"\n/// >>> solve(s: \"ab\")\n/// \"AB\"\n/// >>> solve(s: \"#a@C\")\n///\
    \ \"#A@c\"\nfunc solve(s: String) -> String {\n    var s = s\n    var newS = \"\
    \"\n    var letterCount = 0\n    var i = 0\n    while i < s.count {\n        let\
    \ c = s[s.index(s.startIndex, offsetBy: i)]\n        if c.isLetter {\n       \
    \     letterCount += 1\n        }\n        i += 1\n    }\n    if letterCount ==\
    \ 0 {\n        return String(s.reversed())\n    }\n    i = 0\n    while i < s.count\
    \ {\n        let c = s[s.index(s.startIndex, offsetBy: i)]\n        if c.isLetter\
    \ {\n            newS.append(c.isLowercase ? Character(String(c).uppercased())\
    \ : Character(String(c).lowercased()))\n        } else {\n            newS.append(c)\n\
    \        }\n        i += 1\n    }\n    return newS\n}\n\n\nfunc ==(left: [(Int,\
    \ Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n\
    \        return false\n    }\n    for (l, r) in zip(left, right) {\n        if\
    \ l != r {\n            return false\n        }\n    }\n    return true\n}\n \
    \           \nassert(solve(s: \"AsDf\") == \"aSdF\")\nassert(solve(s: \"1234\"\
    ) == \"4321\")\nassert(solve(s: \"ab\") == \"AB\")\nassert(solve(s: \"#a@C\")\
    \ == \"#A@c\")\nassert(solve(s: \"#AsdfW^45\") == \"#aSDFw^45\")\nassert(solve(s:\
    \ \"#6@2\") == \"2@6#\")\nassert(solve(s: \"#$a^D\") == \"#$A^d\")\nassert(solve(s:\
    \ \"#ccc\") == \"#CCC\")"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659978811
- exit_code: 1
  program: "\n/// You are given a string s.\n/// if s[i] is a letter, reverse its\
    \ case from lower to upper or vise versa, \n/// otherwise keep it as it is.\n\
    /// If the string contains no letters, reverse the string.\n/// The function should\
    \ return the resulted string.\n/// Examples\n/// >>> solve(s: \"1234\")\n/// \"\
    4321\"\n/// >>> solve(s: \"ab\")\n/// \"AB\"\n/// >>> solve(s: \"#a@C\")\n///\
    \ \"#A@c\"\nfunc solve(s: String) -> String {\n    // code\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(solve(s: \"AsDf\") == \"aSdF\")\nassert(solve(s: \"1234\"\
    ) == \"4321\")\nassert(solve(s: \"ab\") == \"AB\")\nassert(solve(s: \"#a@C\")\
    \ == \"#A@c\")\nassert(solve(s: \"#AsdfW^45\") == \"#aSDFw^45\")\nassert(solve(s:\
    \ \"#6@2\") == \"2@6#\")\nassert(solve(s: \"#$a^D\") == \"#$A^d\")\nassert(solve(s:\
    \ \"#ccc\") == \"#CCC\")"
  status: SyntaxError
  stderr: '/tmp/tmpf4t3u3lt.swift:16:1: error: missing return in global function expected
    to return ''String''

    }

    ^

    '
  stdout: ''
  timestamp: 1659978811
- exit_code: 1
  program: "\n/// You are given a string s.\n/// if s[i] is a letter, reverse its\
    \ case from lower to upper or vise versa, \n/// otherwise keep it as it is.\n\
    /// If the string contains no letters, reverse the string.\n/// The function should\
    \ return the resulted string.\n/// Examples\n/// >>> solve(s: \"1234\")\n/// \"\
    4321\"\n/// >>> solve(s: \"ab\")\n/// \"AB\"\n/// >>> solve(s: \"#a@C\")\n///\
    \ \"#A@c\"\nfunc solve(s: String) -> String {\n    var array: [Character] = []\n\
    \    for char in s {\n        array.append(char)\n    }\n    var reversed: [Character]\
    \ = []\n    for index in 0..<array.count {\n        if array[index].isLetter {\n\
    \            if array[index].isUppercase {\n                reversed.append(array[index].lowercased())\n\
    \            } else {\n                reversed.append(array[index].uppercased())\n\
    \            }\n        } else {\n            reversed.append(array[index])\n\
    \        }\n    }\n    return String(reversed.reversed())\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(solve(s: \"AsDf\") == \"aSdF\")\nassert(solve(s: \"1234\"\
    ) == \"4321\")\nassert(solve(s: \"ab\") == \"AB\")\nassert(solve(s: \"#a@C\")\
    \ == \"#A@c\")\nassert(solve(s: \"#AsdfW^45\") == \"#aSDFw^45\")\nassert(solve(s:\
    \ \"#6@2\") == \"2@6#\")\nassert(solve(s: \"#$a^D\") == \"#$A^d\")\nassert(solve(s:\
    \ \"#ccc\") == \"#CCC\")"
  status: SyntaxError
  stderr: "/tmp/tmp2dbtpf8_.swift:23:26: error: no exact matches in call to instance\
    \ method 'append'\n                reversed.append(array[index].lowercased())\n\
    \                         ^\nSwift.Array:7:37: note: incorrect labels for candidate\
    \ (have: '(_:)', expected: '(contentsOf:)')\n    @inlinable public mutating func\
    \ append<S>(contentsOf newElements: __owned S) where Element == S.Element, S :\
    \ Sequence\n                                    ^\nSwift.RangeReplaceableCollection:5:37:\
    \ note: incorrect labels for candidate (have: '(_:)', expected: '(contentsOf:)')\n\
    \    @inlinable public mutating func append<S>(contentsOf newElements: __owned\
    \ S) where S : Sequence, Self.Element == S.Element\n                         \
    \           ^\n/tmp/tmp2dbtpf8_.swift:25:26: error: no exact matches in call to\
    \ instance method 'append'\n                reversed.append(array[index].uppercased())\n\
    \                         ^\nSwift.Array:7:37: note: incorrect labels for candidate\
    \ (have: '(_:)', expected: '(contentsOf:)')\n    @inlinable public mutating func\
    \ append<S>(contentsOf newElements: __owned S) where Element == S.Element, S :\
    \ Sequence\n                                    ^\nSwift.RangeReplaceableCollection:5:37:\
    \ note: incorrect labels for candidate (have: '(_:)', expected: '(contentsOf:)')\n\
    \    @inlinable public mutating func append<S>(contentsOf newElements: __owned\
    \ S) where S : Sequence, Self.Element == S.Element\n                         \
    \           ^\n"
  stdout: ''
  timestamp: 1659978811
- exit_code: 1
  program: "\n/// You are given a string s.\n/// if s[i] is a letter, reverse its\
    \ case from lower to upper or vise versa, \n/// otherwise keep it as it is.\n\
    /// If the string contains no letters, reverse the string.\n/// The function should\
    \ return the resulted string.\n/// Examples\n/// >>> solve(s: \"1234\")\n/// \"\
    4321\"\n/// >>> solve(s: \"ab\")\n/// \"AB\"\n/// >>> solve(s: \"#a@C\")\n///\
    \ \"#A@c\"\nfunc solve(s: String) -> String {\n    if(!s.contains(\"a\") && !s.contains(\"\
    b\") && !s.contains(\"c\") && !s.contains(\"d\") && !s.contains(\"e\") && !s.contains(\"\
    f\") && !s.contains(\"g\") && !s.contains(\"h\") && !s.contains(\"i\") && !s.contains(\"\
    j\") && !s.contains(\"k\") && !s.contains(\"l\") && !s.contains(\"m\") && !s.contains(\"\
    n\") && !s.contains(\"o\") && !s.contains(\"p\") && !s.contains(\"q\") && !s.contains(\"\
    r\") && !s.contains(\"s\") && !s.contains(\"t\") && !s.contains(\"u\") && !s.contains(\"\
    v\") && !s.contains(\"w\") && !s.contains(\"x\") && !s.contains(\"y\") && !s.contains(\"\
    z\") && !s.contains(\"A\") && !s.contains(\"B\") && !s.contains(\"C\") && !s.contains(\"\
    D\") && !s.contains(\"E\") && !s.contains(\"F\") && !s.contains(\"G\") && !s.contains(\"\
    H\") && !s.contains(\"I\") && !s.contains(\"J\") && !s.contains(\"K\") && !s.contains(\"\
    L\") && !s.contains(\"M\") && !s.contains(\"N\") && !s.contains(\"O\") && !s.contains(\"\
    P\") && !s.contains(\"Q\") && !s.contains(\"R\") && !s.contains(\"S\") && !s.contains(\"\
    T\") && !s.contains(\"U\") && !s.contains(\"V\") && !s.contains(\"W\") && !s.contains(\"\
    X\") && !s.contains(\"Y\") && !s.contains(\"Z\")){\n        return String(s.reversed())\n\
    \    }else{\n        var sArray = Array(s)\n        for i in 0..<sArray.count{\n\
    \n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(solve(s: \"AsDf\") == \"aSdF\")\nassert(solve(s:\
    \ \"1234\") == \"4321\")\nassert(solve(s: \"ab\") == \"AB\")\nassert(solve(s:\
    \ \"#a@C\") == \"#A@c\")\nassert(solve(s: \"#AsdfW^45\") == \"#aSDFw^45\")\nassert(solve(s:\
    \ \"#6@2\") == \"2@6#\")\nassert(solve(s: \"#$a^D\") == \"#$A^d\")\nassert(solve(s:\
    \ \"#ccc\") == \"#CCC\")"
  status: SyntaxError
  stderr: "/tmp/tmpr_iq375t.swift:43:35: error: expected '}' at end of brace statement\n\
    assert(solve(s: \"#ccc\") == \"#CCC\")\n                                  ^\n\
    /tmp/tmpr_iq375t.swift:17:10: note: to match this opening '{'\n    }else{\n  \
    \       ^\n/tmp/tmpr_iq375t.swift:43:35: error: expected '}' at end of brace statement\n\
    assert(solve(s: \"#ccc\") == \"#CCC\")\n                                  ^\n\
    /tmp/tmpr_iq375t.swift:14:33: note: to match this opening '{'\nfunc solve(s: String)\
    \ -> String {\n                                ^\n/tmp/tmpr_iq375t.swift:24:6:\
    \ error: operator functions can only be declared at global or in type scope\n\
    func ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n     ^\n/tmp/tmpr_iq375t.swift:18:13:\
    \ warning: variable 'sArray' was never mutated; consider changing to 'let' constant\n\
    \        var sArray = Array(s)\n        ~~~ ^\n        let\n/tmp/tmpr_iq375t.swift:19:13:\
    \ warning: immutable value 'i' was never used; consider replacing with '_' or\
    \ removing it\n        for i in 0..<sArray.count{\n            ^\n           \
    \ _\n"
  stdout: ''
  timestamp: 1659978811
- exit_code: 1
  program: "\n/// You are given a string s.\n/// if s[i] is a letter, reverse its\
    \ case from lower to upper or vise versa, \n/// otherwise keep it as it is.\n\
    /// If the string contains no letters, reverse the string.\n/// The function should\
    \ return the resulted string.\n/// Examples\n/// >>> solve(s: \"1234\")\n/// \"\
    4321\"\n/// >>> solve(s: \"ab\")\n/// \"AB\"\n/// >>> solve(s: \"#a@C\")\n///\
    \ \"#A@c\"\nfunc solve(s: String) -> String {\n    guard s.contains(\"[a-zA-Z]\"\
    ) else { return String(s.reversed()) }\n    return s.map { $0.isLetter ? $0.lowercased()\
    \ == $0 ? $0.uppercased() : $0.lowercased() : $0 }\n}\n\n\nfunc ==(left: [(Int,\
    \ Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n\
    \        return false\n    }\n    for (l, r) in zip(left, right) {\n        if\
    \ l != r {\n            return false\n        }\n    }\n    return true\n}\n \
    \           \nassert(solve(s: \"AsDf\") == \"aSdF\")\nassert(solve(s: \"1234\"\
    ) == \"4321\")\nassert(solve(s: \"ab\") == \"AB\")\nassert(solve(s: \"#a@C\")\
    \ == \"#A@c\")\nassert(solve(s: \"#AsdfW^45\") == \"#aSDFw^45\")\nassert(solve(s:\
    \ \"#6@2\") == \"2@6#\")\nassert(solve(s: \"#$a^D\") == \"#$A^d\")\nassert(solve(s:\
    \ \"#ccc\") == \"#CCC\")"
  status: SyntaxError
  stderr: "/tmp/tmps2b61asg.swift:16:50: error: binary operator '==' cannot be applied\
    \ to operands of type 'String' and 'String.Element' (aka 'Character')\n    return\
    \ s.map { $0.isLetter ? $0.lowercased() == $0 ? $0.uppercased() : $0.lowercased()\
    \ : $0 }\n                                 ~~~~~~~~~~~~~~~ ^  ~~\n/tmp/tmps2b61asg.swift:16:50:\
    \ note: overloads for '==' exist with these partially matching parameter lists:\
    \ (Character, Character), (String, String)\n    return s.map { $0.isLetter ? $0.lowercased()\
    \ == $0 ? $0.uppercased() : $0.lowercased() : $0 }\n                         \
    \                        ^\n/tmp/tmps2b61asg.swift:16:14: error: cannot convert\
    \ return expression of type '[String.Element]' (aka 'Array<Character>') to return\
    \ type 'String'\n    return s.map { $0.isLetter ? $0.lowercased() == $0 ? $0.uppercased()\
    \ : $0.lowercased() : $0 }\n           ~~^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n\
    /tmp/tmps2b61asg.swift:16:56: error: result values in '? :' expression have mismatching\
    \ types 'String' and 'String.Element' (aka 'Character')\n    return s.map { $0.isLetter\
    \ ? $0.lowercased() == $0 ? $0.uppercased() : $0.lowercased() : $0 }\n       \
    \                          ~~~~~~~~~~~~~~~~~~~~~~^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n"
  stdout: ''
  timestamp: 1659978811
- exit_code: -4
  program: "\n/// You are given a string s.\n/// if s[i] is a letter, reverse its\
    \ case from lower to upper or vise versa, \n/// otherwise keep it as it is.\n\
    /// If the string contains no letters, reverse the string.\n/// The function should\
    \ return the resulted string.\n/// Examples\n/// >>> solve(s: \"1234\")\n/// \"\
    4321\"\n/// >>> solve(s: \"ab\")\n/// \"AB\"\n/// >>> solve(s: \"#a@C\")\n///\
    \ \"#A@c\"\nfunc solve(s: String) -> String {\n  var res = \"\"\n  for char in\
    \ s {\n    if \"A\"...\"Z\" ~= char {\n      res += String(char).lowercased()\n\
    \    } else if \"a\"...\"z\" ~= char {\n      res += String(char).uppercased()\n\
    \    } else {\n      res += String(char)\n    }\n  }\n  return res.isEmpty ? String(s.reversed())\
    \ : res\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n \
    \   if left.count != right.count {\n        return false\n    }\n    for (l, r)\
    \ in zip(left, right) {\n        if l != r {\n            return false\n     \
    \   }\n    }\n    return true\n}\n            \nassert(solve(s: \"AsDf\") == \"\
    aSdF\")\nassert(solve(s: \"1234\") == \"4321\")\nassert(solve(s: \"ab\") == \"\
    AB\")\nassert(solve(s: \"#a@C\") == \"#A@c\")\nassert(solve(s: \"#AsdfW^45\")\
    \ == \"#aSDFw^45\")\nassert(solve(s: \"#6@2\") == \"2@6#\")\nassert(solve(s: \"\
    #$a^D\") == \"#$A^d\")\nassert(solve(s: \"#ccc\") == \"#CCC\")"
  status: Exception
  stderr: 'tmp9bijkowy/tmp9bijkowy.swift:42: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b0c7403cc80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b0c73d33b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b0c73d33988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b0c73d327b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmp9bijkowy                        0x000056026e217a57 <unavailable> + 6743

    5    libc.so.6                          0x00002b0c74228460 __libc_start_main +
    245

    6    tmp9bijkowy                        0x000056026e2175a9 <unavailable> + 5545

    '
  stdout: ''
  timestamp: 1659978811
- exit_code: 0
  program: "\n/// You are given a string s.\n/// if s[i] is a letter, reverse its\
    \ case from lower to upper or vise versa, \n/// otherwise keep it as it is.\n\
    /// If the string contains no letters, reverse the string.\n/// The function should\
    \ return the resulted string.\n/// Examples\n/// >>> solve(s: \"1234\")\n/// \"\
    4321\"\n/// >>> solve(s: \"ab\")\n/// \"AB\"\n/// >>> solve(s: \"#a@C\")\n///\
    \ \"#A@c\"\nfunc solve(s: String) -> String {\n    if !s.contains(where: { $0.isLetter\
    \ }) {\n        return String(s.reversed())\n    }\n    var result = \"\"\n  \
    \  for char in s {\n        if char.isLetter {\n            result.append(char.isUppercase\
    \ ? char.lowercased() : char.uppercased())\n        } else {\n            result.append(char)\n\
    \        }\n    }\n    return result\n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(solve(s: \"AsDf\") == \"aSdF\")\nassert(solve(s: \"1234\") == \"4321\"\
    )\nassert(solve(s: \"ab\") == \"AB\")\nassert(solve(s: \"#a@C\") == \"#A@c\")\n\
    assert(solve(s: \"#AsdfW^45\") == \"#aSDFw^45\")\nassert(solve(s: \"#6@2\") ==\
    \ \"2@6#\")\nassert(solve(s: \"#$a^D\") == \"#$A^d\")\nassert(solve(s: \"#ccc\"\
    ) == \"#CCC\")"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659978811
- exit_code: 0
  program: "\n/// You are given a string s.\n/// if s[i] is a letter, reverse its\
    \ case from lower to upper or vise versa, \n/// otherwise keep it as it is.\n\
    /// If the string contains no letters, reverse the string.\n/// The function should\
    \ return the resulted string.\n/// Examples\n/// >>> solve(s: \"1234\")\n/// \"\
    4321\"\n/// >>> solve(s: \"ab\")\n/// \"AB\"\n/// >>> solve(s: \"#a@C\")\n///\
    \ \"#A@c\"\nfunc solve(s: String) -> String {\n    guard s.filter({ $0.isLetter\
    \ }).count > 0 else {\n        return String(s.reversed())\n    }\n    return\
    \ String(s.map({ $0.isLetter ? $0.isUppercase ? Character($0.lowercased()) : Character($0.uppercased())\
    \ : $0 }))\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n\
    \    if left.count != right.count {\n        return false\n    }\n    for (l,\
    \ r) in zip(left, right) {\n        if l != r {\n            return false\n  \
    \      }\n    }\n    return true\n}\n            \nassert(solve(s: \"AsDf\") ==\
    \ \"aSdF\")\nassert(solve(s: \"1234\") == \"4321\")\nassert(solve(s: \"ab\") ==\
    \ \"AB\")\nassert(solve(s: \"#a@C\") == \"#A@c\")\nassert(solve(s: \"#AsdfW^45\"\
    ) == \"#aSDFw^45\")\nassert(solve(s: \"#6@2\") == \"2@6#\")\nassert(solve(s: \"\
    #$a^D\") == \"#$A^d\")\nassert(solve(s: \"#ccc\") == \"#CCC\")"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659978811
- exit_code: 1
  program: "\n/// You are given a string s.\n/// if s[i] is a letter, reverse its\
    \ case from lower to upper or vise versa, \n/// otherwise keep it as it is.\n\
    /// If the string contains no letters, reverse the string.\n/// The function should\
    \ return the resulted string.\n/// Examples\n/// >>> solve(s: \"1234\")\n/// \"\
    4321\"\n/// >>> solve(s: \"ab\")\n/// \"AB\"\n/// >>> solve(s: \"#a@C\")\n///\
    \ \"#A@c\"\nfunc solve(s: String) -> String {\n    let uppers = CharacterSet.uppercaseLetters\n\
    \    let lowers = CharacterSet.lowercaseLetters\n    return String(s.reversed().map\
    \ {\n        switch ($0, lowers.contains($0), uppers.contains($0)) {\n       \
    \ case (_, true, _): return Character(String($0).uppercased())\n        case (_,\
    \ _, true): return Character(String($0).lowercased())\n        default: return\
    \ $0\n        }\n    })\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(solve(s: \"\
    AsDf\") == \"aSdF\")\nassert(solve(s: \"1234\") == \"4321\")\nassert(solve(s:\
    \ \"ab\") == \"AB\")\nassert(solve(s: \"#a@C\") == \"#A@c\")\nassert(solve(s:\
    \ \"#AsdfW^45\") == \"#aSDFw^45\")\nassert(solve(s: \"#6@2\") == \"2@6#\")\nassert(solve(s:\
    \ \"#$a^D\") == \"#$A^d\")\nassert(solve(s: \"#ccc\") == \"#CCC\")"
  status: SyntaxError
  stderr: "/tmp/tmptverpji7.swift:15:18: error: cannot find 'CharacterSet' in scope\n\
    \    let uppers = CharacterSet.uppercaseLetters\n                 ^~~~~~~~~~~~\n\
    /tmp/tmptverpji7.swift:16:18: error: cannot find 'CharacterSet' in scope\n   \
    \ let lowers = CharacterSet.lowercaseLetters\n                 ^~~~~~~~~~~~\n"
  stdout: ''
  timestamp: 1659978811
- exit_code: 1
  program: "\n/// You are given a string s.\n/// if s[i] is a letter, reverse its\
    \ case from lower to upper or vise versa, \n/// otherwise keep it as it is.\n\
    /// If the string contains no letters, reverse the string.\n/// The function should\
    \ return the resulted string.\n/// Examples\n/// >>> solve(s: \"1234\")\n/// \"\
    4321\"\n/// >>> solve(s: \"ab\")\n/// \"AB\"\n/// >>> solve(s: \"#a@C\")\n///\
    \ \"#A@c\"\nfunc solve(s: String) -> String {\n    let containsLetter = s.contains\
    \ { $0.isLetter }\n    if containsLetter {\n        let letters = s.map { String($0)\
    \ }\n        let result = letters.map {\n            if $0.isLetter {\n      \
    \          if $0.lowercased() == $0 {\n                    return $0.uppercased()\n\
    \                } else {\n                    return $0.lowercased()\n      \
    \          }\n            } else {\n                return $0\n            }\n\
    \        }\n        return result.joined()\n    } else {\n        return String(s.reversed())\n\
    \    }\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n  \
    \  if left.count != right.count {\n        return false\n    }\n    for (l, r)\
    \ in zip(left, right) {\n        if l != r {\n            return false\n     \
    \   }\n    }\n    return true\n}\n            \nassert(solve(s: \"AsDf\") == \"\
    aSdF\")\nassert(solve(s: \"1234\") == \"4321\")\nassert(solve(s: \"ab\") == \"\
    AB\")\nassert(solve(s: \"#a@C\") == \"#A@c\")\nassert(solve(s: \"#AsdfW^45\")\
    \ == \"#aSDFw^45\")\nassert(solve(s: \"#6@2\") == \"2@6#\")\nassert(solve(s: \"\
    #$a^D\") == \"#$A^d\")\nassert(solve(s: \"#ccc\") == \"#CCC\")"
  status: SyntaxError
  stderr: "/tmp/tmp3t8qxv9w.swift:19:19: error: value of type 'String' has no member\
    \ 'isLetter'\n            if $0.isLetter {\n               ~~ ^~~~~~~~\n"
  stdout: ''
  timestamp: 1659978811
- exit_code: -4
  program: "\n/// You are given a string s.\n/// if s[i] is a letter, reverse its\
    \ case from lower to upper or vise versa, \n/// otherwise keep it as it is.\n\
    /// If the string contains no letters, reverse the string.\n/// The function should\
    \ return the resulted string.\n/// Examples\n/// >>> solve(s: \"1234\")\n/// \"\
    4321\"\n/// >>> solve(s: \"ab\")\n/// \"AB\"\n/// >>> solve(s: \"#a@C\")\n///\
    \ \"#A@c\"\nfunc solve(s: String) -> String {\n    var newString = String()\n\
    \    let lowercased = Set(\"abcdefghijklmnopqrstuvwxyz\")\n    let uppercased\
    \ = Set(\"ABCDEFGHIJKLMNOPQRSTUVWXYZ\")\n    for char in s {\n        if lowercased.contains(char)\
    \ {\n            newString.append(char.uppercased())\n        } else if uppercased.contains(char)\
    \ {\n            newString.append(char.lowercased())\n        } else {\n     \
    \       newString.append(char)\n        }\n    }\n    if newString.contains(\"\
    a\") || newString.contains(\"A\") {\n        return newString\n    } else {\n\
    \        var reverseString = String()\n        for char in newString {\n     \
    \       reverseString.insert(char, at: reverseString.startIndex)\n        }\n\
    \        return reverseString\n    }\n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(solve(s: \"AsDf\") == \"aSdF\")\nassert(solve(s: \"1234\") == \"4321\"\
    )\nassert(solve(s: \"ab\") == \"AB\")\nassert(solve(s: \"#a@C\") == \"#A@c\")\n\
    assert(solve(s: \"#AsdfW^45\") == \"#aSDFw^45\")\nassert(solve(s: \"#6@2\") ==\
    \ \"2@6#\")\nassert(solve(s: \"#$a^D\") == \"#$A^d\")\nassert(solve(s: \"#ccc\"\
    ) == \"#CCC\")"
  status: Exception
  stderr: 'tmpu5dd9w3h/tmpu5dd9w3h.swift:58: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b19fd623c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b19fd31ab6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b19fd31a988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b19fd3197b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpu5dd9w3h                        0x000056229df880a0 <unavailable> + 8352

    5    libc.so.6                          0x00002b19fd80f460 __libc_start_main +
    245

    6    tmpu5dd9w3h                        0x000056229df87539 <unavailable> + 5433

    '
  stdout: ''
  timestamp: 1659978811
- exit_code: 1
  program: "\n/// You are given a string s.\n/// if s[i] is a letter, reverse its\
    \ case from lower to upper or vise versa, \n/// otherwise keep it as it is.\n\
    /// If the string contains no letters, reverse the string.\n/// The function should\
    \ return the resulted string.\n/// Examples\n/// >>> solve(s: \"1234\")\n/// \"\
    4321\"\n/// >>> solve(s: \"ab\")\n/// \"AB\"\n/// >>> solve(s: \"#a@C\")\n///\
    \ \"#A@c\"\nfunc solve(s: String) -> String {\n    var reversed = \"\"\n    for\
    \ char in s {\n        if char.isLetter {\n            if char.isUppercase {\n\
    \                reversed.append(char.lowercased())\n            } else {\n  \
    \              reversed.append(char.uppercased())\n            }\n        } else\
    \ {\n            reversed.append(char)\n        }\n    }\n    return reversed.isEmpty\
    \ ? s.reversed() : reversed\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int,\
    \ Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n\
    \    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n          \
    \  return false\n        }\n    }\n    return true\n}\n            \nassert(solve(s:\
    \ \"AsDf\") == \"aSdF\")\nassert(solve(s: \"1234\") == \"4321\")\nassert(solve(s:\
    \ \"ab\") == \"AB\")\nassert(solve(s: \"#a@C\") == \"#A@c\")\nassert(solve(s:\
    \ \"#AsdfW^45\") == \"#aSDFw^45\")\nassert(solve(s: \"#6@2\") == \"2@6#\")\nassert(solve(s:\
    \ \"#$a^D\") == \"#$A^d\")\nassert(solve(s: \"#ccc\") == \"#CCC\")"
  status: SyntaxError
  stderr: "/tmp/tmpfgygfpuy.swift:27:29: error: cannot convert return expression of\
    \ type 'ReversedCollection<String>' to return type 'String'\n    return reversed.isEmpty\
    \ ? s.reversed() : reversed\n           ~~~~~~~~~~~~~~~~~^~~~~~~~~~~~~~~~~~~~~~~~~\n"
  stdout: ''
  timestamp: 1659978811
- exit_code: 1
  program: "\n/// You are given a string s.\n/// if s[i] is a letter, reverse its\
    \ case from lower to upper or vise versa, \n/// otherwise keep it as it is.\n\
    /// If the string contains no letters, reverse the string.\n/// The function should\
    \ return the resulted string.\n/// Examples\n/// >>> solve(s: \"1234\")\n/// \"\
    4321\"\n/// >>> solve(s: \"ab\")\n/// \"AB\"\n/// >>> solve(s: \"#a@C\")\n///\
    \ \"#A@c\"\nfunc solve(s: String) -> String {\n  // your code\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(solve(s: \"AsDf\") == \"aSdF\")\nassert(solve(s: \"1234\"\
    ) == \"4321\")\nassert(solve(s: \"ab\") == \"AB\")\nassert(solve(s: \"#a@C\")\
    \ == \"#A@c\")\nassert(solve(s: \"#AsdfW^45\") == \"#aSDFw^45\")\nassert(solve(s:\
    \ \"#6@2\") == \"2@6#\")\nassert(solve(s: \"#$a^D\") == \"#$A^d\")\nassert(solve(s:\
    \ \"#ccc\") == \"#CCC\")"
  status: SyntaxError
  stderr: '/tmp/tmp1ay0tyto.swift:16:1: error: missing return in global function expected
    to return ''String''

    }

    ^

    '
  stdout: ''
  timestamp: 1659978811
- exit_code: -4
  program: "\n/// You are given a string s.\n/// if s[i] is a letter, reverse its\
    \ case from lower to upper or vise versa, \n/// otherwise keep it as it is.\n\
    /// If the string contains no letters, reverse the string.\n/// The function should\
    \ return the resulted string.\n/// Examples\n/// >>> solve(s: \"1234\")\n/// \"\
    4321\"\n/// >>> solve(s: \"ab\")\n/// \"AB\"\n/// >>> solve(s: \"#a@C\")\n///\
    \ \"#A@c\"\nfunc solve(s: String) -> String {\n    var arr = Array(s)\n    for\
    \ i in 0..<arr.count {\n        if arr[i].isLetter {\n            if arr[i].isUppercase\
    \ {\n                arr[i] = Character(arr[i].lowercased())\n            } else\
    \ {\n                arr[i] = Character(arr[i].uppercased())\n            }\n\
    \        }\n    }\n    return String(arr)\n}\n\n\nfunc ==(left: [(Int, Int)],\
    \ right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n       \
    \ return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r\
    \ {\n            return false\n        }\n    }\n    return true\n}\n        \
    \    \nassert(solve(s: \"AsDf\") == \"aSdF\")\nassert(solve(s: \"1234\") == \"\
    4321\")\nassert(solve(s: \"ab\") == \"AB\")\nassert(solve(s: \"#a@C\") == \"#A@c\"\
    )\nassert(solve(s: \"#AsdfW^45\") == \"#aSDFw^45\")\nassert(solve(s: \"#6@2\"\
    ) == \"2@6#\")\nassert(solve(s: \"#$a^D\") == \"#$A^d\")\nassert(solve(s: \"#ccc\"\
    ) == \"#CCC\")"
  status: Exception
  stderr: 'tmpkhyn_za4/tmpkhyn_za4.swift:42: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002ac6e2abbc80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002ac6e27b2b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002ac6e27b2988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002ac6e27b17b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpkhyn_za4                        0x000055f64d7259e7 <unavailable> + 6631

    5    libc.so.6                          0x00002ac6e2ca7460 __libc_start_main +
    245

    6    tmpkhyn_za4                        0x000055f64d725539 <unavailable> + 5433

    '
  stdout: ''
  timestamp: 1659978811
- exit_code: 1
  program: "\n/// You are given a string s.\n/// if s[i] is a letter, reverse its\
    \ case from lower to upper or vise versa, \n/// otherwise keep it as it is.\n\
    /// If the string contains no letters, reverse the string.\n/// The function should\
    \ return the resulted string.\n/// Examples\n/// >>> solve(s: \"1234\")\n/// \"\
    4321\"\n/// >>> solve(s: \"ab\")\n/// \"AB\"\n/// >>> solve(s: \"#a@C\")\n///\
    \ \"#A@c\"\nfunc solve(s: String) -> String {\n    var result = s\n    let nonLetterChars\
    \ = CharacterSet.letters.inverted\n    let lettersArray = s.components(separatedBy:\
    \ nonLetterChars)\n    if lettersArray.count == 0 {\n        return String(s.reversed())\n\
    \    }\n    let letterSet = CharacterSet.letters\n    var i = 0\n    for letter\
    \ in s {\n        if letterSet.contains(letter.unicodeScalars.first!) {\n    \
    \        if let index = result.index(of: letter) {\n                result.replaceSubrange(index...index,\
    \ with: String(letter).lowercased())\n            }\n            if let index\
    \ = result.index(of: lettersArray[i].lowercased()) {\n                result.replaceSubrange(index...index,\
    \ with: String(lettersArray[i].lowercased()).uppercased())\n            }\n  \
    \          i += 1\n        }\n    }\n    return result\n}\n\n\nfunc ==(left: [(Int,\
    \ Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n\
    \        return false\n    }\n    for (l, r) in zip(left, right) {\n        if\
    \ l != r {\n            return false\n        }\n    }\n    return true\n}\n \
    \           \nassert(solve(s: \"AsDf\") == \"aSdF\")\nassert(solve(s: \"1234\"\
    ) == \"4321\")\nassert(solve(s: \"ab\") == \"AB\")\nassert(solve(s: \"#a@C\")\
    \ == \"#A@c\")\nassert(solve(s: \"#AsdfW^45\") == \"#aSDFw^45\")\nassert(solve(s:\
    \ \"#6@2\") == \"2@6#\")\nassert(solve(s: \"#$a^D\") == \"#$A^d\")\nassert(solve(s:\
    \ \"#ccc\") == \"#CCC\")"
  status: SyntaxError
  stderr: "/tmp/tmpo583f24d.swift:16:26: error: cannot find 'CharacterSet' in scope\n\
    \    let nonLetterChars = CharacterSet.letters.inverted\n                    \
    \     ^~~~~~~~~~~~\n/tmp/tmpo583f24d.swift:17:26: error: value of type 'String'\
    \ has no member 'components'\n    let lettersArray = s.components(separatedBy:\
    \ nonLetterChars)\n                       ~ ^~~~~~~~~~\n/tmp/tmpo583f24d.swift:21:21:\
    \ error: cannot find 'CharacterSet' in scope\n    let letterSet = CharacterSet.letters\n\
    \                    ^~~~~~~~~~~~\n/tmp/tmpo583f24d.swift:25:35: warning: 'index(of:)'\
    \ is deprecated: renamed to 'firstIndex(of:)'\n            if let index = result.index(of:\
    \ letter) {\n                                  ^\n/tmp/tmpo583f24d.swift:25:35:\
    \ note: use 'firstIndex(of:)' instead\n            if let index = result.index(of:\
    \ letter) {\n                                  ^~~~~\n                       \
    \           firstIndex\n"
  stdout: ''
  timestamp: 1659978811
- exit_code: 1
  program: "\n/// You are given a string s.\n/// if s[i] is a letter, reverse its\
    \ case from lower to upper or vise versa, \n/// otherwise keep it as it is.\n\
    /// If the string contains no letters, reverse the string.\n/// The function should\
    \ return the resulted string.\n/// Examples\n/// >>> solve(s: \"1234\")\n/// \"\
    4321\"\n/// >>> solve(s: \"ab\")\n/// \"AB\"\n/// >>> solve(s: \"#a@C\")\n///\
    \ \"#A@c\"\nfunc solve(s: String) -> String {\n    let temp = s.isEmpty ? \"\"\
    \ : s.filter({ $0.isLetter }).count == 0 ? String(s.reversed()) : s.map({ $0.isLetter\
    \ ? $0.isUppercase ? $0.lowercased() : $0.uppercased() : $0 })\n    return String(temp)\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(solve(s: \"AsDf\") == \"aSdF\")\nassert(solve(s:\
    \ \"1234\") == \"4321\")\nassert(solve(s: \"ab\") == \"AB\")\nassert(solve(s:\
    \ \"#a@C\") == \"#A@c\")\nassert(solve(s: \"#AsdfW^45\") == \"#aSDFw^45\")\nassert(solve(s:\
    \ \"#6@2\") == \"2@6#\")\nassert(solve(s: \"#$a^D\") == \"#$A^d\")\nassert(solve(s:\
    \ \"#ccc\") == \"#CCC\")"
  status: SyntaxError
  stderr: "/tmp/tmpov2exkv3.swift:15:28: error: result values in '? :' expression\
    \ have mismatching types 'String' and '[String.Element]' (aka 'Array<Character>')\n\
    \    let temp = s.isEmpty ? \"\" : s.filter({ $0.isLetter }).count == 0 ? String(s.reversed())\
    \ : s.map({ $0.isLetter ? $0.isUppercase ? $0.lowercased() : $0.uppercased() :\
    \ $0 })\n                           ^~\n/tmp/tmpov2exkv3.swift:15:72: error: result\
    \ values in '? :' expression have mismatching types 'String' and '[String.Element]'\
    \ (aka 'Array<Character>')\n    let temp = s.isEmpty ? \"\" : s.filter({ $0.isLetter\
    \ }).count == 0 ? String(s.reversed()) : s.map({ $0.isLetter ? $0.isUppercase\
    \ ? $0.lowercased() : $0.uppercased() : $0 })\n                              \
    \                                         ^~~~~~~~~~~~~~~~~~~~\n/tmp/tmpov2exkv3.swift:15:132:\
    \ error: result values in '? :' expression have mismatching types 'String' and\
    \ 'String.Element' (aka 'Character')\n    let temp = s.isEmpty ? \"\" : s.filter({\
    \ $0.isLetter }).count == 0 ? String(s.reversed()) : s.map({ $0.isLetter ? $0.isUppercase\
    \ ? $0.lowercased() : $0.uppercased() : $0 })\n                              \
    \                                                                            \
    \          ~~~~~~~~~~~~~~~^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n"
  stdout: ''
  timestamp: 1659978811
- exit_code: 1
  program: "\n/// You are given a string s.\n/// if s[i] is a letter, reverse its\
    \ case from lower to upper or vise versa, \n/// otherwise keep it as it is.\n\
    /// If the string contains no letters, reverse the string.\n/// The function should\
    \ return the resulted string.\n/// Examples\n/// >>> solve(s: \"1234\")\n/// \"\
    4321\"\n/// >>> solve(s: \"ab\")\n/// \"AB\"\n/// >>> solve(s: \"#a@C\")\n///\
    \ \"#A@c\"\nfunc solve(s: String) -> String {\n    var str: String = \"\"\n  \
    \  let set = NSCharacterSet.letters\n    for c in s {\n        if set.contains(UnicodeScalar(String(c))!)\
    \ {\n            if c.isUppercase {\n                str.append(c.lowercased())\n\
    \            } else {\n                str.append(c.uppercased())\n          \
    \  }\n        } else {\n            str.append(c)\n        }\n    }\n    if str.count\
    \ == 0 {\n        str = String(s.reversed())\n    }\n    return str\n}\n\n\nfunc\
    \ ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count !=\
    \ right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(solve(s: \"AsDf\") == \"aSdF\")\nassert(solve(s:\
    \ \"1234\") == \"4321\")\nassert(solve(s: \"ab\") == \"AB\")\nassert(solve(s:\
    \ \"#a@C\") == \"#A@c\")\nassert(solve(s: \"#AsdfW^45\") == \"#aSDFw^45\")\nassert(solve(s:\
    \ \"#6@2\") == \"2@6#\")\nassert(solve(s: \"#$a^D\") == \"#$A^d\")\nassert(solve(s:\
    \ \"#ccc\") == \"#CCC\")"
  status: SyntaxError
  stderr: "/tmp/tmpz7bwuwa9.swift:16:15: error: cannot find 'NSCharacterSet' in scope\n\
    \    let set = NSCharacterSet.letters\n              ^~~~~~~~~~~~~~\n"
  stdout: ''
  timestamp: 1659978811
- exit_code: -4
  program: "\n/// You are given a string s.\n/// if s[i] is a letter, reverse its\
    \ case from lower to upper or vise versa, \n/// otherwise keep it as it is.\n\
    /// If the string contains no letters, reverse the string.\n/// The function should\
    \ return the resulted string.\n/// Examples\n/// >>> solve(s: \"1234\")\n/// \"\
    4321\"\n/// >>> solve(s: \"ab\")\n/// \"AB\"\n/// >>> solve(s: \"#a@C\")\n///\
    \ \"#A@c\"\nfunc solve(s: String) -> String {\n  var newS = \"\"\n  for letter\
    \ in s {\n    if letter.isLetter {\n      newS.append(letter.isLowercase ? String(letter).uppercased()\
    \ : String(letter).lowercased())\n    } else {\n      newS.append(letter)\n  \
    \  }\n  }\n  return newS.isEmpty ? String(s.reversed()) : newS\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(solve(s: \"AsDf\") == \"aSdF\")\nassert(solve(s: \"1234\"\
    ) == \"4321\")\nassert(solve(s: \"ab\") == \"AB\")\nassert(solve(s: \"#a@C\")\
    \ == \"#A@c\")\nassert(solve(s: \"#AsdfW^45\") == \"#aSDFw^45\")\nassert(solve(s:\
    \ \"#6@2\") == \"2@6#\")\nassert(solve(s: \"#$a^D\") == \"#$A^d\")\nassert(solve(s:\
    \ \"#ccc\") == \"#CCC\")"
  status: Exception
  stderr: 'tmpw__5qg0a/tmpw__5qg0a.swift:40: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b7286345c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b728603cb6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b728603c988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b728603b7b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpw__5qg0a                        0x0000555884128937 <unavailable> + 6455

    5    libc.so.6                          0x00002b7286531460 __libc_start_main +
    245

    6    tmpw__5qg0a                        0x0000555884128489 <unavailable> + 5257

    '
  stdout: ''
  timestamp: 1659978811
- exit_code: -4
  program: "\n/// You are given a string s.\n/// if s[i] is a letter, reverse its\
    \ case from lower to upper or vise versa, \n/// otherwise keep it as it is.\n\
    /// If the string contains no letters, reverse the string.\n/// The function should\
    \ return the resulted string.\n/// Examples\n/// >>> solve(s: \"1234\")\n/// \"\
    4321\"\n/// >>> solve(s: \"ab\")\n/// \"AB\"\n/// >>> solve(s: \"#a@C\")\n///\
    \ \"#A@c\"\nfunc solve(s: String) -> String {\n    var result = \"\"\n    for\
    \ c in s {\n        if c.isLetter {\n            result.append(c.isLowercase ?\
    \ c.uppercased() : c.lowercased())\n        } else {\n            result.append(c)\n\
    \        }\n    }\n    return result.isEmpty ? String(s.reversed()) : result\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(solve(s: \"AsDf\") == \"aSdF\")\nassert(solve(s:\
    \ \"1234\") == \"4321\")\nassert(solve(s: \"ab\") == \"AB\")\nassert(solve(s:\
    \ \"#a@C\") == \"#A@c\")\nassert(solve(s: \"#AsdfW^45\") == \"#aSDFw^45\")\nassert(solve(s:\
    \ \"#6@2\") == \"2@6#\")\nassert(solve(s: \"#$a^D\") == \"#$A^d\")\nassert(solve(s:\
    \ \"#ccc\") == \"#CCC\")"
  status: Exception
  stderr: 'tmp3g4mx_o0/tmp3g4mx_o0.swift:40: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b7cd7bf9c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b7cd78f0b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b7cd78f0988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b7cd78ef7b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmp3g4mx_o0                        0x000055a4471848d7 <unavailable> + 6359

    5    libc.so.6                          0x00002b7cd7de5460 __libc_start_main +
    245

    6    tmp3g4mx_o0                        0x000055a447184429 <unavailable> + 5161

    '
  stdout: ''
  timestamp: 1659978811
- exit_code: 1
  program: "\n/// You are given a string s.\n/// if s[i] is a letter, reverse its\
    \ case from lower to upper or vise versa, \n/// otherwise keep it as it is.\n\
    /// If the string contains no letters, reverse the string.\n/// The function should\
    \ return the resulted string.\n/// Examples\n/// >>> solve(s: \"1234\")\n/// \"\
    4321\"\n/// >>> solve(s: \"ab\")\n/// \"AB\"\n/// >>> solve(s: \"#a@C\")\n///\
    \ \"#A@c\"\nfunc solve(s: String) -> String {\n    return s.isEmpty ? s : String(s.compactMap\
    \ { $0.isLetter ? $0.isUppercase ? $0.lowercased() : $0.uppercased() : $0 })\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(solve(s: \"AsDf\") == \"aSdF\")\nassert(solve(s:\
    \ \"1234\") == \"4321\")\nassert(solve(s: \"ab\") == \"AB\")\nassert(solve(s:\
    \ \"#a@C\") == \"#A@c\")\nassert(solve(s: \"#AsdfW^45\") == \"#aSDFw^45\")\nassert(solve(s:\
    \ \"#6@2\") == \"2@6#\")\nassert(solve(s: \"#$a^D\") == \"#$A^d\")\nassert(solve(s:\
    \ \"#ccc\") == \"#CCC\")"
  status: SyntaxError
  stderr: "/tmp/tmp1yespt01.swift:15:79: error: result values in '? :' expression\
    \ have mismatching types 'String' and 'String.Element' (aka 'Character')\n   \
    \ return s.isEmpty ? s : String(s.compactMap { $0.isLetter ? $0.isUppercase ?\
    \ $0.lowercased() : $0.uppercased() : $0 })\n                                \
    \                               ~~~~~~~~~~~~~~~^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n"
  stdout: ''
  timestamp: 1659978811
- exit_code: 1
  program: "\n/// You are given a string s.\n/// if s[i] is a letter, reverse its\
    \ case from lower to upper or vise versa, \n/// otherwise keep it as it is.\n\
    /// If the string contains no letters, reverse the string.\n/// The function should\
    \ return the resulted string.\n/// Examples\n/// >>> solve(s: \"1234\")\n/// \"\
    4321\"\n/// >>> solve(s: \"ab\")\n/// \"AB\"\n/// >>> solve(s: \"#a@C\")\n///\
    \ \"#A@c\"\nfunc solve(s: String) -> String {\n\tlet letters = CharacterSet.letters\n\
    \tvar string = s\n\tfor character in string.characters {\n\t\tif letters.contains(UnicodeScalar(String(character))!)\
    \ {\n\t\t\tif String(character) == String(character).lowercased() {\n\t\t\t\t\
    string = string.replacingOccurrences(of: String(character), with: String(character).uppercased())\n\
    \t\t\t} else {\n\t\t\t\tstring = string.replacingOccurrences(of: String(character),\
    \ with: String(character).lowercased())\n\t\t\t}\n\t\t}\n\t}\n\tif string.characters.contains(where:\
    \ { letters.contains(UnicodeScalar(String($0))!) }) {\n\t\treturn string\n\t}\
    \ else {\n\t\treturn String(string.characters.reversed())\n\t}\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(solve(s: \"AsDf\") == \"aSdF\")\nassert(solve(s: \"1234\"\
    ) == \"4321\")\nassert(solve(s: \"ab\") == \"AB\")\nassert(solve(s: \"#a@C\")\
    \ == \"#A@c\")\nassert(solve(s: \"#AsdfW^45\") == \"#aSDFw^45\")\nassert(solve(s:\
    \ \"#6@2\") == \"2@6#\")\nassert(solve(s: \"#$a^D\") == \"#$A^d\")\nassert(solve(s:\
    \ \"#ccc\") == \"#CCC\")"
  status: SyntaxError
  stderr: "/tmp/tmpg9p46fid.swift:15:16: error: cannot find 'CharacterSet' in scope\n\
    \        let letters = CharacterSet.letters\n                      ^~~~~~~~~~~~\n\
    /tmp/tmpg9p46fid.swift:17:26: error: 'characters' is unavailable: Please use String\
    \ directly\n        for character in string.characters {\n                   \
    \             ^~~~~~~~~~\nSwift.String:5:16: note: 'characters' was obsoleted\
    \ in Swift 5.0\n    public var characters: String { get set }\n              \
    \ ^\n/tmp/tmpg9p46fid.swift:20:21: error: value of type 'String' has no member\
    \ 'replacingOccurrences'\n                                string = string.replacingOccurrences(of:\
    \ String(character), with: String(character).uppercased())\n                 \
    \                        ~~~~~~ ^~~~~~~~~~~~~~~~~~~~\n/tmp/tmpg9p46fid.swift:22:21:\
    \ error: value of type 'String' has no member 'replacingOccurrences'\n       \
    \                         string = string.replacingOccurrences(of: String(character),\
    \ with: String(character).lowercased())\n                                    \
    \     ~~~~~~ ^~~~~~~~~~~~~~~~~~~~\n/tmp/tmpg9p46fid.swift:29:24: error: 'characters'\
    \ is unavailable: Please use String directly\n                return String(string.characters.reversed())\n\
    \                                     ^~~~~~~~~~\nSwift.String:5:16: note: 'characters'\
    \ was obsoleted in Swift 5.0\n    public var characters: String { get set }\n\
    \               ^\n"
  stdout: ''
  timestamp: 1659978811
- exit_code: -4
  program: "\n/// You are given a string s.\n/// if s[i] is a letter, reverse its\
    \ case from lower to upper or vise versa, \n/// otherwise keep it as it is.\n\
    /// If the string contains no letters, reverse the string.\n/// The function should\
    \ return the resulted string.\n/// Examples\n/// >>> solve(s: \"1234\")\n/// \"\
    4321\"\n/// >>> solve(s: \"ab\")\n/// \"AB\"\n/// >>> solve(s: \"#a@C\")\n///\
    \ \"#A@c\"\nfunc solve(s: String) -> String {\n    if s.isEmpty {\n        return\
    \ s\n    }\n    var str = \"\"\n    for i in s {\n        if i.isLetter {\n  \
    \          str += String(i.lowercased() == String(i) ? i.uppercased() : i.lowercased())\n\
    \        } else {\n            str += String(i)\n        }\n    }\n    return\
    \ str\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n   \
    \ if left.count != right.count {\n        return false\n    }\n    for (l, r)\
    \ in zip(left, right) {\n        if l != r {\n            return false\n     \
    \   }\n    }\n    return true\n}\n            \nassert(solve(s: \"AsDf\") == \"\
    aSdF\")\nassert(solve(s: \"1234\") == \"4321\")\nassert(solve(s: \"ab\") == \"\
    AB\")\nassert(solve(s: \"#a@C\") == \"#A@c\")\nassert(solve(s: \"#AsdfW^45\")\
    \ == \"#aSDFw^45\")\nassert(solve(s: \"#6@2\") == \"2@6#\")\nassert(solve(s: \"\
    #$a^D\") == \"#$A^d\")\nassert(solve(s: \"#ccc\") == \"#CCC\")"
  status: Exception
  stderr: 'tmpjvdqbo7d/tmpjvdqbo7d.swift:43: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002ba847cafc80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002ba8479a6b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002ba8479a6988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002ba8479a57b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpjvdqbo7d                        0x000055881834a7f7 <unavailable> + 6135

    5    libc.so.6                          0x00002ba847e9b460 __libc_start_main +
    245

    6    tmpjvdqbo7d                        0x000055881834a349 <unavailable> + 4937

    '
  stdout: ''
  timestamp: 1659978811
- exit_code: 1
  program: "\n/// You are given a string s.\n/// if s[i] is a letter, reverse its\
    \ case from lower to upper or vise versa, \n/// otherwise keep it as it is.\n\
    /// If the string contains no letters, reverse the string.\n/// The function should\
    \ return the resulted string.\n/// Examples\n/// >>> solve(s: \"1234\")\n/// \"\
    4321\"\n/// >>> solve(s: \"ab\")\n/// \"AB\"\n/// >>> solve(s: \"#a@C\")\n///\
    \ \"#A@c\"\nfunc solve(s: String) -> String {\n    if s.isEmpty {\n        return\
    \ \"\"\n    }\n    var temp = [Character]()\n    for item in s {\n        if item.isLetter\
    \ {\n            if item.isUppercase {\n                temp.append(item.lowercased())\n\
    \            } else {\n                temp.append(item.uppercased())\n      \
    \      }\n        } else {\n            temp.append(item)\n        }\n    }\n\
    \    if temp.isEmpty {\n        return String(s.reversed())\n    }\n    return\
    \ String(temp)\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool\
    \ {\n    if left.count != right.count {\n        return false\n    }\n    for\
    \ (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(solve(s: \"AsDf\"\
    ) == \"aSdF\")\nassert(solve(s: \"1234\") == \"4321\")\nassert(solve(s: \"ab\"\
    ) == \"AB\")\nassert(solve(s: \"#a@C\") == \"#A@c\")\nassert(solve(s: \"#AsdfW^45\"\
    ) == \"#aSDFw^45\")\nassert(solve(s: \"#6@2\") == \"2@6#\")\nassert(solve(s: \"\
    #$a^D\") == \"#$A^d\")\nassert(solve(s: \"#ccc\") == \"#CCC\")"
  status: SyntaxError
  stderr: "/tmp/tmpxpgqnfgx.swift:22:22: error: no exact matches in call to instance\
    \ method 'append'\n                temp.append(item.lowercased())\n          \
    \           ^\nSwift.Array:7:37: note: incorrect labels for candidate (have: '(_:)',\
    \ expected: '(contentsOf:)')\n    @inlinable public mutating func append<S>(contentsOf\
    \ newElements: __owned S) where Element == S.Element, S : Sequence\n         \
    \                           ^\nSwift.RangeReplaceableCollection:5:37: note: incorrect\
    \ labels for candidate (have: '(_:)', expected: '(contentsOf:)')\n    @inlinable\
    \ public mutating func append<S>(contentsOf newElements: __owned S) where S :\
    \ Sequence, Self.Element == S.Element\n                                    ^\n\
    /tmp/tmpxpgqnfgx.swift:24:22: error: no exact matches in call to instance method\
    \ 'append'\n                temp.append(item.uppercased())\n                 \
    \    ^\nSwift.Array:7:37: note: incorrect labels for candidate (have: '(_:)',\
    \ expected: '(contentsOf:)')\n    @inlinable public mutating func append<S>(contentsOf\
    \ newElements: __owned S) where Element == S.Element, S : Sequence\n         \
    \                           ^\nSwift.RangeReplaceableCollection:5:37: note: incorrect\
    \ labels for candidate (have: '(_:)', expected: '(contentsOf:)')\n    @inlinable\
    \ public mutating func append<S>(contentsOf newElements: __owned S) where S :\
    \ Sequence, Self.Element == S.Element\n                                    ^\n"
  stdout: ''
  timestamp: 1659978811
- exit_code: -4
  program: "\n/// You are given a string s.\n/// if s[i] is a letter, reverse its\
    \ case from lower to upper or vise versa, \n/// otherwise keep it as it is.\n\
    /// If the string contains no letters, reverse the string.\n/// The function should\
    \ return the resulted string.\n/// Examples\n/// >>> solve(s: \"1234\")\n/// \"\
    4321\"\n/// >>> solve(s: \"ab\")\n/// \"AB\"\n/// >>> solve(s: \"#a@C\")\n///\
    \ \"#A@c\"\nfunc solve(s: String) -> String {\n    return \"\"\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(solve(s: \"AsDf\") == \"aSdF\")\nassert(solve(s: \"1234\"\
    ) == \"4321\")\nassert(solve(s: \"ab\") == \"AB\")\nassert(solve(s: \"#a@C\")\
    \ == \"#A@c\")\nassert(solve(s: \"#AsdfW^45\") == \"#aSDFw^45\")\nassert(solve(s:\
    \ \"#6@2\") == \"2@6#\")\nassert(solve(s: \"#$a^D\") == \"#$A^d\")\nassert(solve(s:\
    \ \"#ccc\") == \"#CCC\")"
  status: Exception
  stderr: 'tmpiark_u6w/tmpiark_u6w.swift:31: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002aca5c89dc80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002aca5c594b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002aca5c594988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002aca5c5937b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpiark_u6w                        0x0000562c1ac34307 <unavailable> + 4871

    5    libc.so.6                          0x00002aca5ca89460 __libc_start_main +
    245

    6    tmpiark_u6w                        0x0000562c1ac33f49 <unavailable> + 3913

    '
  stdout: ''
  timestamp: 1659978811
- exit_code: -4
  program: "\n/// You are given a string s.\n/// if s[i] is a letter, reverse its\
    \ case from lower to upper or vise versa, \n/// otherwise keep it as it is.\n\
    /// If the string contains no letters, reverse the string.\n/// The function should\
    \ return the resulted string.\n/// Examples\n/// >>> solve(s: \"1234\")\n/// \"\
    4321\"\n/// >>> solve(s: \"ab\")\n/// \"AB\"\n/// >>> solve(s: \"#a@C\")\n///\
    \ \"#A@c\"\nfunc solve(s: String) -> String {\n    let reversed = s.reversed()\n\
    \    var result = \"\"\n    for letter in reversed {\n        if letter.isLetter\
    \ {\n            result.append(letter.lowercased())\n        } else {\n      \
    \      result.append(letter)\n        }\n    }\n    return result\n}\n\n\nfunc\
    \ ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count !=\
    \ right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(solve(s: \"AsDf\") == \"aSdF\")\nassert(solve(s:\
    \ \"1234\") == \"4321\")\nassert(solve(s: \"ab\") == \"AB\")\nassert(solve(s:\
    \ \"#a@C\") == \"#A@c\")\nassert(solve(s: \"#AsdfW^45\") == \"#aSDFw^45\")\nassert(solve(s:\
    \ \"#6@2\") == \"2@6#\")\nassert(solve(s: \"#$a^D\") == \"#$A^d\")\nassert(solve(s:\
    \ \"#ccc\") == \"#CCC\")"
  status: Exception
  stderr: 'tmp_qs54b8_/tmp_qs54b8_.swift:40: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b3262f28c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b3262c1fb6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b3262c1f988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b3262c1e7b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmp_qs54b8_                        0x000055c7cceb16c7 <unavailable> + 5831

    5    libc.so.6                          0x00002b3263114460 __libc_start_main +
    245

    6    tmp_qs54b8_                        0x000055c7cceb1309 <unavailable> + 4873

    '
  stdout: ''
  timestamp: 1659978811
- exit_code: 1
  program: "\n/// You are given a string s.\n/// if s[i] is a letter, reverse its\
    \ case from lower to upper or vise versa, \n/// otherwise keep it as it is.\n\
    /// If the string contains no letters, reverse the string.\n/// The function should\
    \ return the resulted string.\n/// Examples\n/// >>> solve(s: \"1234\")\n/// \"\
    4321\"\n/// >>> solve(s: \"ab\")\n/// \"AB\"\n/// >>> solve(s: \"#a@C\")\n///\
    \ \"#A@c\"\nfunc solve(s: String) -> String {\n    var s = s\n    var i = 0\n\
    \    while i < s.count {\n        let c = s[s.index(s.startIndex, offsetBy: i)]\n\
    \        if isLetter(c) {\n            let j = s.index(s.startIndex, offsetBy:\
    \ i)\n            s.replaceSubrange(j...j, with: String(c).lowercased())\n   \
    \     }\n        i += 1\n    }\n    return s\n}\n\n\nfunc ==(left: [(Int, Int)],\
    \ right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n       \
    \ return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r\
    \ {\n            return false\n        }\n    }\n    return true\n}\n        \
    \    \nassert(solve(s: \"AsDf\") == \"aSdF\")\nassert(solve(s: \"1234\") == \"\
    4321\")\nassert(solve(s: \"ab\") == \"AB\")\nassert(solve(s: \"#a@C\") == \"#A@c\"\
    )\nassert(solve(s: \"#AsdfW^45\") == \"#aSDFw^45\")\nassert(solve(s: \"#6@2\"\
    ) == \"2@6#\")\nassert(solve(s: \"#$a^D\") == \"#$A^d\")\nassert(solve(s: \"#ccc\"\
    ) == \"#CCC\")"
  status: SyntaxError
  stderr: "/tmp/tmpqluihn5s.swift:19:12: error: cannot find 'isLetter' in scope\n\
    \        if isLetter(c) {\n           ^~~~~~~~\n"
  stdout: ''
  timestamp: 1659978811
- exit_code: -4
  program: "\n/// You are given a string s.\n/// if s[i] is a letter, reverse its\
    \ case from lower to upper or vise versa, \n/// otherwise keep it as it is.\n\
    /// If the string contains no letters, reverse the string.\n/// The function should\
    \ return the resulted string.\n/// Examples\n/// >>> solve(s: \"1234\")\n/// \"\
    4321\"\n/// >>> solve(s: \"ab\")\n/// \"AB\"\n/// >>> solve(s: \"#a@C\")\n///\
    \ \"#A@c\"\nfunc solve(s: String) -> String {\n    // your code goes here\n  \
    \  let str = Array(s)\n    var output = \"\"\n    var isLetterExist = false\n\
    \    for c in str {\n        if let ch = c.lowercased().first {\n            isLetterExist\
    \ = true\n            if (ch >= \"a\" && ch <= \"z\") {\n                output.append(String(ch).uppercased())\n\
    \            } else {\n                output.append(String(ch).lowercased())\n\
    \            }\n        } else {\n            output.append(c)\n        }\n  \
    \  }\n    if !isLetterExist {\n        output = String(output.reversed())\n  \
    \  }\n    return output\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(solve(s: \"\
    AsDf\") == \"aSdF\")\nassert(solve(s: \"1234\") == \"4321\")\nassert(solve(s:\
    \ \"ab\") == \"AB\")\nassert(solve(s: \"#a@C\") == \"#A@c\")\nassert(solve(s:\
    \ \"#AsdfW^45\") == \"#aSDFw^45\")\nassert(solve(s: \"#6@2\") == \"2@6#\")\nassert(solve(s:\
    \ \"#$a^D\") == \"#$A^d\")\nassert(solve(s: \"#ccc\") == \"#CCC\")"
  status: Exception
  stderr: 'tmpqqhher05/tmpqqhher05.swift:50: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b7f90f5ac80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b7f90c51b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b7f90c51988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b7f90c507b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpqqhher05                        0x0000558cbfd83b97 <unavailable> + 7063

    5    libc.so.6                          0x00002b7f91146460 __libc_start_main +
    245

    6    tmpqqhher05                        0x0000558cbfd837d9 <unavailable> + 6105

    '
  stdout: ''
  timestamp: 1659978811
- exit_code: -4
  program: "\n/// You are given a string s.\n/// if s[i] is a letter, reverse its\
    \ case from lower to upper or vise versa, \n/// otherwise keep it as it is.\n\
    /// If the string contains no letters, reverse the string.\n/// The function should\
    \ return the resulted string.\n/// Examples\n/// >>> solve(s: \"1234\")\n/// \"\
    4321\"\n/// >>> solve(s: \"ab\")\n/// \"AB\"\n/// >>> solve(s: \"#a@C\")\n///\
    \ \"#A@c\"\nfunc solve(s: String) -> String {\n    let uppers = Set(\"ABCDEFGHIJKLMNOPQRSTUVWXYZ\"\
    )\n    let lowers = Set(\"abcdefghijklmnopqrstuvwxyz\")\n    var result = \"\"\
    \n    for c in s {\n        result += uppers.contains(c) ? String(c).lowercased()\
    \ :\n            lowers.contains(c) ? String(c).uppercased() : String(c)\n   \
    \ }\n    return result\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(solve(s: \"\
    AsDf\") == \"aSdF\")\nassert(solve(s: \"1234\") == \"4321\")\nassert(solve(s:\
    \ \"ab\") == \"AB\")\nassert(solve(s: \"#a@C\") == \"#A@c\")\nassert(solve(s:\
    \ \"#AsdfW^45\") == \"#aSDFw^45\")\nassert(solve(s: \"#6@2\") == \"2@6#\")\nassert(solve(s:\
    \ \"#$a^D\") == \"#$A^d\")\nassert(solve(s: \"#ccc\") == \"#CCC\")"
  status: Exception
  stderr: 'tmpouxlws95/tmpouxlws95.swift:39: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b598cadbc80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b598c7d2b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b598c7d2988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b598c7d17b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpouxlws95                        0x0000563c63d717a7 <unavailable> + 6055

    5    libc.so.6                          0x00002b598ccc7460 __libc_start_main +
    245

    6    tmpouxlws95                        0x0000563c63d712f9 <unavailable> + 4857

    '
  stdout: ''
  timestamp: 1659978811
- exit_code: 1
  program: "\n/// You are given a string s.\n/// if s[i] is a letter, reverse its\
    \ case from lower to upper or vise versa, \n/// otherwise keep it as it is.\n\
    /// If the string contains no letters, reverse the string.\n/// The function should\
    \ return the resulted string.\n/// Examples\n/// >>> solve(s: \"1234\")\n/// \"\
    4321\"\n/// >>> solve(s: \"ab\")\n/// \"AB\"\n/// >>> solve(s: \"#a@C\")\n///\
    \ \"#A@c\"\nfunc solve(s: String) -> String {\n    guard s.contains(\"[a-zA-Z]\"\
    ) else { return String(s.reversed()) }\n    return s.components(separatedBy: .whitespaces).map\
    \ { $0.components(separatedBy: .punctuationCharacters).compactMap { $0.rangeOfCharacter(from:\
    \ .letters) != nil ? String($0.reversed()) : nil }.joined() }.joined(separator:\
    \ \" \")\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n\
    \    if left.count != right.count {\n        return false\n    }\n    for (l,\
    \ r) in zip(left, right) {\n        if l != r {\n            return false\n  \
    \      }\n    }\n    return true\n}\n            \nassert(solve(s: \"AsDf\") ==\
    \ \"aSdF\")\nassert(solve(s: \"1234\") == \"4321\")\nassert(solve(s: \"ab\") ==\
    \ \"AB\")\nassert(solve(s: \"#a@C\") == \"#A@c\")\nassert(solve(s: \"#AsdfW^45\"\
    ) == \"#aSDFw^45\")\nassert(solve(s: \"#6@2\") == \"2@6#\")\nassert(solve(s: \"\
    #$a^D\") == \"#$A^d\")\nassert(solve(s: \"#ccc\") == \"#CCC\")"
  status: SyntaxError
  stderr: "/tmp/tmp2n1enzs5.swift:16:14: error: value of type 'String' has no member\
    \ 'components'\n    return s.components(separatedBy: .whitespaces).map { $0.components(separatedBy:\
    \ .punctuationCharacters).compactMap { $0.rangeOfCharacter(from: .letters) !=\
    \ nil ? String($0.reversed()) : nil }.joined() }.joined(separator: \" \")\n  \
    \         ~ ^~~~~~~~~~\n/tmp/tmp2n1enzs5.swift:16:39: error: cannot infer contextual\
    \ base in reference to member 'whitespaces'\n    return s.components(separatedBy:\
    \ .whitespaces).map { $0.components(separatedBy: .punctuationCharacters).compactMap\
    \ { $0.rangeOfCharacter(from: .letters) != nil ? String($0.reversed()) : nil }.joined()\
    \ }.joined(separator: \" \")\n                                     ~^~~~~~~~~~~\n\
    /tmp/tmp2n1enzs5.swift:16:149: error: cannot infer contextual base in reference\
    \ to member 'letters'\n    return s.components(separatedBy: .whitespaces).map\
    \ { $0.components(separatedBy: .punctuationCharacters).compactMap { $0.rangeOfCharacter(from:\
    \ .letters) != nil ? String($0.reversed()) : nil }.joined() }.joined(separator:\
    \ \" \")\n                                                                   \
    \                                                                            \
    \    ~^~~~~~~\n/tmp/tmp2n1enzs5.swift:16:86: error: cannot infer contextual base\
    \ in reference to member 'punctuationCharacters'\n    return s.components(separatedBy:\
    \ .whitespaces).map { $0.components(separatedBy: .punctuationCharacters).compactMap\
    \ { $0.rangeOfCharacter(from: .letters) != nil ? String($0.reversed()) : nil }.joined()\
    \ }.joined(separator: \" \")\n                                               \
    \                                     ~^~~~~~~~~~~~~~~~~~~~~\n"
  stdout: ''
  timestamp: 1659978815
- exit_code: 1
  program: "\n/// You are given a string s.\n/// if s[i] is a letter, reverse its\
    \ case from lower to upper or vise versa, \n/// otherwise keep it as it is.\n\
    /// If the string contains no letters, reverse the string.\n/// The function should\
    \ return the resulted string.\n/// Examples\n/// >>> solve(s: \"1234\")\n/// \"\
    4321\"\n/// >>> solve(s: \"ab\")\n/// \"AB\"\n/// >>> solve(s: \"#a@C\")\n///\
    \ \"#A@c\"\nfunc solve(s: String) -> String {\n    guard s.count != 0 else { return\
    \ s }\n    var solution = \"\"\n    for char in s {\n        if char.isLetter\
    \ {\n            solution.append(char.isUppercase ? char.lowercased() : char.uppercased())\n\
    \        } else {\n            solution.append(char)\n        }\n    }\n    return\
    \ s.containsLetters() ? solution : String(solution.reversed())\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(solve(s: \"AsDf\") == \"aSdF\")\nassert(solve(s: \"1234\"\
    ) == \"4321\")\nassert(solve(s: \"ab\") == \"AB\")\nassert(solve(s: \"#a@C\")\
    \ == \"#A@c\")\nassert(solve(s: \"#AsdfW^45\") == \"#aSDFw^45\")\nassert(solve(s:\
    \ \"#6@2\") == \"2@6#\")\nassert(solve(s: \"#$a^D\") == \"#$A^d\")\nassert(solve(s:\
    \ \"#ccc\") == \"#CCC\")"
  status: SyntaxError
  stderr: "/tmp/tmp59kcppk2.swift:24:14: error: value of type 'String' has no member\
    \ 'containsLetters'\n    return s.containsLetters() ? solution : String(solution.reversed())\n\
    \           ~ ^~~~~~~~~~~~~~~\n"
  stdout: ''
  timestamp: 1659978811
- exit_code: 1
  program: "\n/// You are given a string s.\n/// if s[i] is a letter, reverse its\
    \ case from lower to upper or vise versa, \n/// otherwise keep it as it is.\n\
    /// If the string contains no letters, reverse the string.\n/// The function should\
    \ return the resulted string.\n/// Examples\n/// >>> solve(s: \"1234\")\n/// \"\
    4321\"\n/// >>> solve(s: \"ab\")\n/// \"AB\"\n/// >>> solve(s: \"#a@C\")\n///\
    \ \"#A@c\"\nfunc solve(s: String) -> String {\n    guard s.contains(where: { \"\
    a\"...\"z\" ~= $0 || \"A\"...\"Z\" ~= $0 }) else {\n        return String(s.reversed())\n\
    \    }\n    return String(s.map { $0.isLowercase ? $0.uppercased() : $0.lowercased()\
    \ })\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if\
    \ left.count != right.count {\n        return false\n    }\n    for (l, r) in\
    \ zip(left, right) {\n        if l != r {\n            return false\n        }\n\
    \    }\n    return true\n}\n            \nassert(solve(s: \"AsDf\") == \"aSdF\"\
    )\nassert(solve(s: \"1234\") == \"4321\")\nassert(solve(s: \"ab\") == \"AB\")\n\
    assert(solve(s: \"#a@C\") == \"#A@c\")\nassert(solve(s: \"#AsdfW^45\") == \"#aSDFw^45\"\
    )\nassert(solve(s: \"#6@2\") == \"2@6#\")\nassert(solve(s: \"#$a^D\") == \"#$A^d\"\
    )\nassert(solve(s: \"#ccc\") == \"#CCC\")"
  status: SyntaxError
  stderr: "/tmp/tmp_ioq7rxh.swift:18:12: error: type of expression is ambiguous without\
    \ more context\n    return String(s.map { $0.isLowercase ? $0.uppercased() : $0.lowercased()\
    \ })\n           ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n"
  stdout: ''
  timestamp: 1659978811
- exit_code: -4
  program: "\n/// You are given a string s.\n/// if s[i] is a letter, reverse its\
    \ case from lower to upper or vise versa, \n/// otherwise keep it as it is.\n\
    /// If the string contains no letters, reverse the string.\n/// The function should\
    \ return the resulted string.\n/// Examples\n/// >>> solve(s: \"1234\")\n/// \"\
    4321\"\n/// >>> solve(s: \"ab\")\n/// \"AB\"\n/// >>> solve(s: \"#a@C\")\n///\
    \ \"#A@c\"\nfunc solve(s: String) -> String {\n    if s.count > 0 {\n        var\
    \ newString = \"\"\n        let chars = Array(s)\n        for i in 0..<chars.count\
    \ {\n            let character = String(chars[i])\n            if character ==\
    \ character.uppercased() {\n                newString.append(character.lowercased())\n\
    \            } else if character == character.lowercased() {\n               \
    \ newString.append(character.uppercased())\n            } else {\n           \
    \     newString.append(character)\n            }\n        }\n        return newString\n\
    \    } else {\n        return String(s.reversed())\n    }\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(solve(s: \"AsDf\") == \"aSdF\")\nassert(solve(s: \"1234\"\
    ) == \"4321\")\nassert(solve(s: \"ab\") == \"AB\")\nassert(solve(s: \"#a@C\")\
    \ == \"#A@c\")\nassert(solve(s: \"#AsdfW^45\") == \"#aSDFw^45\")\nassert(solve(s:\
    \ \"#6@2\") == \"2@6#\")\nassert(solve(s: \"#$a^D\") == \"#$A^d\")\nassert(solve(s:\
    \ \"#ccc\") == \"#CCC\")"
  status: Exception
  stderr: 'tmpqyhgj8_9/tmpqyhgj8_9.swift:48: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b690f2a8c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b690ef9fb6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b690ef9f988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b690ef9e7b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpqyhgj8_9                        0x000056150a255a87 <unavailable> + 6791

    5    libc.so.6                          0x00002b690f494460 __libc_start_main +
    245

    6    tmpqyhgj8_9                        0x000056150a2555d9 <unavailable> + 5593

    '
  stdout: ''
  timestamp: 1659978812
- exit_code: 1
  program: "\n/// You are given a string s.\n/// if s[i] is a letter, reverse its\
    \ case from lower to upper or vise versa, \n/// otherwise keep it as it is.\n\
    /// If the string contains no letters, reverse the string.\n/// The function should\
    \ return the resulted string.\n/// Examples\n/// >>> solve(s: \"1234\")\n/// \"\
    4321\"\n/// >>> solve(s: \"ab\")\n/// \"AB\"\n/// >>> solve(s: \"#a@C\")\n///\
    \ \"#A@c\"\nfunc solve(s: String) -> String {\n    var res = \"\"\n    for item\
    \ in s {\n        if item >= \"a\" && item <= \"z\" {\n            res += \"\\\
    (item)\".uppercased()\n        } else if item >= \"A\" && item <= \"Z\" {\n  \
    \          res += \"\\(item)\".lowercased()\n        } else {\n            res\
    \ += \"\\(item)\"\n        }\n    }\n    return s.rangeOfCharacter(from: CharacterSet.letters)\
    \ == nil ? String(res.reversed()) : res\n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(solve(s: \"AsDf\") == \"aSdF\")\nassert(solve(s: \"1234\") == \"4321\"\
    )\nassert(solve(s: \"ab\") == \"AB\")\nassert(solve(s: \"#a@C\") == \"#A@c\")\n\
    assert(solve(s: \"#AsdfW^45\") == \"#aSDFw^45\")\nassert(solve(s: \"#6@2\") ==\
    \ \"2@6#\")\nassert(solve(s: \"#$a^D\") == \"#$A^d\")\nassert(solve(s: \"#ccc\"\
    ) == \"#CCC\")"
  status: SyntaxError
  stderr: "/tmp/tmpofqi75aj.swift:25:37: error: cannot find 'CharacterSet' in scope\n\
    \    return s.rangeOfCharacter(from: CharacterSet.letters) == nil ? String(res.reversed())\
    \ : res\n                                    ^~~~~~~~~~~~\n/tmp/tmpofqi75aj.swift:25:14:\
    \ error: value of type 'String' has no member 'rangeOfCharacter'\n    return s.rangeOfCharacter(from:\
    \ CharacterSet.letters) == nil ? String(res.reversed()) : res\n           ~ ^~~~~~~~~~~~~~~~\n"
  stdout: ''
  timestamp: 1659978811
- exit_code: 1
  program: "\n/// You are given a string s.\n/// if s[i] is a letter, reverse its\
    \ case from lower to upper or vise versa, \n/// otherwise keep it as it is.\n\
    /// If the string contains no letters, reverse the string.\n/// The function should\
    \ return the resulted string.\n/// Examples\n/// >>> solve(s: \"1234\")\n/// \"\
    4321\"\n/// >>> solve(s: \"ab\")\n/// \"AB\"\n/// >>> solve(s: \"#a@C\")\n///\
    \ \"#A@c\"\nfunc solve(s: String) -> String {\n    if s.contains(\"a\") || s.contains(\"\
    A\") {\n        return String(s.reversed()).capitalized\n    } else {\n      \
    \  return String(s.reversed())\n    }\n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(solve(s: \"AsDf\") == \"aSdF\")\nassert(solve(s: \"1234\") == \"4321\"\
    )\nassert(solve(s: \"ab\") == \"AB\")\nassert(solve(s: \"#a@C\") == \"#A@c\")\n\
    assert(solve(s: \"#AsdfW^45\") == \"#aSDFw^45\")\nassert(solve(s: \"#6@2\") ==\
    \ \"2@6#\")\nassert(solve(s: \"#$a^D\") == \"#$A^d\")\nassert(solve(s: \"#ccc\"\
    ) == \"#CCC\")"
  status: SyntaxError
  stderr: "/tmp/tmp4ajc3gcp.swift:16:37: error: value of type 'String' has no member\
    \ 'capitalized'\n        return String(s.reversed()).capitalized\n           \
    \    ~~~~~~~~~~~~~~~~~~~~ ^~~~~~~~~~~\n"
  stdout: ''
  timestamp: 1659978811
- exit_code: 1
  program: "\n/// You are given a string s.\n/// if s[i] is a letter, reverse its\
    \ case from lower to upper or vise versa, \n/// otherwise keep it as it is.\n\
    /// If the string contains no letters, reverse the string.\n/// The function should\
    \ return the resulted string.\n/// Examples\n/// >>> solve(s: \"1234\")\n/// \"\
    4321\"\n/// >>> solve(s: \"ab\")\n/// \"AB\"\n/// >>> solve(s: \"#a@C\")\n///\
    \ \"#A@c\"\nfunc solve(s: String) -> String {\n    var result = \"\"\n    for\
    \ c in s {\n        if (c >= \"a\" && c <= \"z\") || (c >= \"A\" && c <= \"Z\"\
    ) {\n            result.append(c.lowercased() == c ? c.uppercased() : c.lowercased())\n\
    \        } else {\n            result.append(c)\n        }\n    }\n    return\
    \ result.isEmpty ? String(s.reversed()) : result\n}\n\n\nfunc ==(left: [(Int,\
    \ Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n\
    \        return false\n    }\n    for (l, r) in zip(left, right) {\n        if\
    \ l != r {\n            return false\n        }\n    }\n    return true\n}\n \
    \           \nassert(solve(s: \"AsDf\") == \"aSdF\")\nassert(solve(s: \"1234\"\
    ) == \"4321\")\nassert(solve(s: \"ab\") == \"AB\")\nassert(solve(s: \"#a@C\")\
    \ == \"#A@c\")\nassert(solve(s: \"#AsdfW^45\") == \"#aSDFw^45\")\nassert(solve(s:\
    \ \"#6@2\") == \"2@6#\")\nassert(solve(s: \"#$a^D\") == \"#$A^d\")\nassert(solve(s:\
    \ \"#ccc\") == \"#CCC\")"
  status: SyntaxError
  stderr: "/tmp/tmp325nf12u.swift:18:42: error: binary operator '==' cannot be applied\
    \ to operands of type 'String' and 'Character'\n            result.append(c.lowercased()\
    \ == c ? c.uppercased() : c.lowercased())\n                          ~~~~~~~~~~~~~~\
    \ ^  ~\n/tmp/tmp325nf12u.swift:18:42: note: overloads for '==' exist with these\
    \ partially matching parameter lists: (Character, Character), (String, String)\n\
    \            result.append(c.lowercased() == c ? c.uppercased() : c.lowercased())\n\
    \                                         ^\n"
  stdout: ''
  timestamp: 1659978811
- exit_code: 1
  program: "\n/// You are given a string s.\n/// if s[i] is a letter, reverse its\
    \ case from lower to upper or vise versa, \n/// otherwise keep it as it is.\n\
    /// If the string contains no letters, reverse the string.\n/// The function should\
    \ return the resulted string.\n/// Examples\n/// >>> solve(s: \"1234\")\n/// \"\
    4321\"\n/// >>> solve(s: \"ab\")\n/// \"AB\"\n/// >>> solve(s: \"#a@C\")\n///\
    \ \"#A@c\"\nfunc solve(s: String) -> String {\n\tvar result = String()\n\tfor\
    \ char in s {\n\t\tlet c = CharacterSet.letters\n\t\tif c.contains(char.unicodeScalars.first!)\
    \ {\n\t\t\tif (char == char.uppercased()) {\n\t\t\t\tresult.append(char.lowercased())\n\
    \t\t\t} else {\n\t\t\t\tresult.append(char.uppercased())\n\t\t\t}\n\t\t} else\
    \ {\n\t\t\tresult.append(char)\n\t\t}\n\t}\n\tif result.count == 0 {\n\t\treturn\
    \ String(s.reversed())\n\t}\n\treturn result\n}\n\n\nfunc ==(left: [(Int, Int)],\
    \ right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n       \
    \ return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r\
    \ {\n            return false\n        }\n    }\n    return true\n}\n        \
    \    \nassert(solve(s: \"AsDf\") == \"aSdF\")\nassert(solve(s: \"1234\") == \"\
    4321\")\nassert(solve(s: \"ab\") == \"AB\")\nassert(solve(s: \"#a@C\") == \"#A@c\"\
    )\nassert(solve(s: \"#AsdfW^45\") == \"#aSDFw^45\")\nassert(solve(s: \"#6@2\"\
    ) == \"2@6#\")\nassert(solve(s: \"#$a^D\") == \"#$A^d\")\nassert(solve(s: \"#ccc\"\
    ) == \"#CCC\")"
  status: SyntaxError
  stderr: "/tmp/tmpx5785ga4.swift:17:11: error: cannot find 'CharacterSet' in scope\n\
    \                let c = CharacterSet.letters\n                        ^~~~~~~~~~~~\n\
    /tmp/tmpx5785ga4.swift:19:13: error: binary operator '==' cannot be applied to\
    \ operands of type 'Character' and 'String'\n                        if (char\
    \ == char.uppercased()) {\n                            ~~~~ ^  ~~~~~~~~~~~~~~~~~\n\
    /tmp/tmpx5785ga4.swift:19:13: note: overloads for '==' exist with these partially\
    \ matching parameter lists: (Character, Character), (String, String)\n       \
    \                 if (char == char.uppercased()) {\n                         \
    \        ^\n"
  stdout: ''
  timestamp: 1659978811
- exit_code: -4
  program: "\n/// You are given a string s.\n/// if s[i] is a letter, reverse its\
    \ case from lower to upper or vise versa, \n/// otherwise keep it as it is.\n\
    /// If the string contains no letters, reverse the string.\n/// The function should\
    \ return the resulted string.\n/// Examples\n/// >>> solve(s: \"1234\")\n/// \"\
    4321\"\n/// >>> solve(s: \"ab\")\n/// \"AB\"\n/// >>> solve(s: \"#a@C\")\n///\
    \ \"#A@c\"\nfunc solve(s: String) -> String {\n    var str = \"\"\n    for (_,\
    \ char) in s.enumerated() {\n        if char.isUppercase {\n            str.append(char.lowercased())\n\
    \        } else if char.isLowercase {\n            str.append(char.uppercased())\n\
    \        } else {\n            str.append(char)\n        }\n    }\n    return\
    \ str\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n   \
    \ if left.count != right.count {\n        return false\n    }\n    for (l, r)\
    \ in zip(left, right) {\n        if l != r {\n            return false\n     \
    \   }\n    }\n    return true\n}\n            \nassert(solve(s: \"AsDf\") == \"\
    aSdF\")\nassert(solve(s: \"1234\") == \"4321\")\nassert(solve(s: \"ab\") == \"\
    AB\")\nassert(solve(s: \"#a@C\") == \"#A@c\")\nassert(solve(s: \"#AsdfW^45\")\
    \ == \"#aSDFw^45\")\nassert(solve(s: \"#6@2\") == \"2@6#\")\nassert(solve(s: \"\
    #$a^D\") == \"#$A^d\")\nassert(solve(s: \"#ccc\") == \"#CCC\")"
  status: Exception
  stderr: 'tmpf0d0yvxk/tmpf0d0yvxk.swift:42: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b54f96d4c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b54f93cbb6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b54f93cb988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b54f93ca7b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpf0d0yvxk                        0x000055a9661ea887 <unavailable> + 6279

    5    libc.so.6                          0x00002b54f98c0460 __libc_start_main +
    245

    6    tmpf0d0yvxk                        0x000055a9661ea3d9 <unavailable> + 5081

    '
  stdout: ''
  timestamp: 1659978811
- exit_code: -4
  program: "\n/// You are given a string s.\n/// if s[i] is a letter, reverse its\
    \ case from lower to upper or vise versa, \n/// otherwise keep it as it is.\n\
    /// If the string contains no letters, reverse the string.\n/// The function should\
    \ return the resulted string.\n/// Examples\n/// >>> solve(s: \"1234\")\n/// \"\
    4321\"\n/// >>> solve(s: \"ab\")\n/// \"AB\"\n/// >>> solve(s: \"#a@C\")\n///\
    \ \"#A@c\"\nfunc solve(s: String) -> String {\n    let flag = Set(\"abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ\"\
    )\n    var result = \"\"\n    var letters = \"\"\n    for c in s {\n        if\
    \ flag.contains(c) {\n            letters += String(c)\n        } else {\n   \
    \         result += String(c)\n        }\n    }\n    if letters.isEmpty {\n  \
    \      return String(result.reversed())\n    }\n    for c in letters {\n     \
    \   if String(c).uppercased() == String(c) {\n            result += String(c).lowercased()\n\
    \        } else {\n            result += String(c).uppercased()\n        }\n \
    \   }\n    return result\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(solve(s: \"\
    AsDf\") == \"aSdF\")\nassert(solve(s: \"1234\") == \"4321\")\nassert(solve(s:\
    \ \"ab\") == \"AB\")\nassert(solve(s: \"#a@C\") == \"#A@c\")\nassert(solve(s:\
    \ \"#AsdfW^45\") == \"#aSDFw^45\")\nassert(solve(s: \"#6@2\") == \"2@6#\")\nassert(solve(s:\
    \ \"#$a^D\") == \"#$A^d\")\nassert(solve(s: \"#ccc\") == \"#CCC\")"
  status: Exception
  stderr: 'tmpfv0l5mn0/tmpfv0l5mn0.swift:54: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b6ff491ec80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b6ff4615b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b6ff4615988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b6ff46147b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpfv0l5mn0                        0x0000555d83b1cbe1 <unavailable> + 7137

    5    libc.so.6                          0x00002b6ff4b0a460 __libc_start_main +
    245

    6    tmpfv0l5mn0                        0x0000555d83b1c4f9 <unavailable> + 5369

    '
  stdout: ''
  timestamp: 1659978812
- exit_code: -4
  program: "\n/// You are given a string s.\n/// if s[i] is a letter, reverse its\
    \ case from lower to upper or vise versa, \n/// otherwise keep it as it is.\n\
    /// If the string contains no letters, reverse the string.\n/// The function should\
    \ return the resulted string.\n/// Examples\n/// >>> solve(s: \"1234\")\n/// \"\
    4321\"\n/// >>> solve(s: \"ab\")\n/// \"AB\"\n/// >>> solve(s: \"#a@C\")\n///\
    \ \"#A@c\"\nfunc solve(s: String) -> String {\n    return \"\"\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(solve(s: \"AsDf\") == \"aSdF\")\nassert(solve(s: \"1234\"\
    ) == \"4321\")\nassert(solve(s: \"ab\") == \"AB\")\nassert(solve(s: \"#a@C\")\
    \ == \"#A@c\")\nassert(solve(s: \"#AsdfW^45\") == \"#aSDFw^45\")\nassert(solve(s:\
    \ \"#6@2\") == \"2@6#\")\nassert(solve(s: \"#$a^D\") == \"#$A^d\")\nassert(solve(s:\
    \ \"#ccc\") == \"#CCC\")"
  status: Exception
  stderr: 'tmpiark_u6w/tmpiark_u6w.swift:31: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002aca5c89dc80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002aca5c594b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002aca5c594988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002aca5c5937b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpiark_u6w                        0x0000562c1ac34307 <unavailable> + 4871

    5    libc.so.6                          0x00002aca5ca89460 __libc_start_main +
    245

    6    tmpiark_u6w                        0x0000562c1ac33f49 <unavailable> + 3913

    '
  stdout: ''
  timestamp: 1659978811
- exit_code: 1
  program: "\n/// You are given a string s.\n/// if s[i] is a letter, reverse its\
    \ case from lower to upper or vise versa, \n/// otherwise keep it as it is.\n\
    /// If the string contains no letters, reverse the string.\n/// The function should\
    \ return the resulted string.\n/// Examples\n/// >>> solve(s: \"1234\")\n/// \"\
    4321\"\n/// >>> solve(s: \"ab\")\n/// \"AB\"\n/// >>> solve(s: \"#a@C\")\n///\
    \ \"#A@c\"\nfunc solve(s: String) -> String {\n    var letters = [Character]()\n\
    \    for char in s {\n        letters.append(char)\n    }\n    for i in 0..<letters.count\
    \ {\n        if letters[i].isLetter {\n            letters[i].switchCase()\n \
    \       }\n    }\n    return letters.isEmpty ? String(letters.reversed()) : String(letters)\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(solve(s: \"AsDf\") == \"aSdF\")\nassert(solve(s:\
    \ \"1234\") == \"4321\")\nassert(solve(s: \"ab\") == \"AB\")\nassert(solve(s:\
    \ \"#a@C\") == \"#A@c\")\nassert(solve(s: \"#AsdfW^45\") == \"#aSDFw^45\")\nassert(solve(s:\
    \ \"#6@2\") == \"2@6#\")\nassert(solve(s: \"#$a^D\") == \"#$A^d\")\nassert(solve(s:\
    \ \"#ccc\") == \"#CCC\")"
  status: SyntaxError
  stderr: "/tmp/tmpvde61b4a.swift:21:24: error: value of type 'Character' has no member\
    \ 'switchCase'\n            letters[i].switchCase()\n            ~~~~~~~~~~ ^~~~~~~~~~\n"
  stdout: ''
  timestamp: 1659978811
- exit_code: 1
  program: "\n/// You are given a string s.\n/// if s[i] is a letter, reverse its\
    \ case from lower to upper or vise versa, \n/// otherwise keep it as it is.\n\
    /// If the string contains no letters, reverse the string.\n/// The function should\
    \ return the resulted string.\n/// Examples\n/// >>> solve(s: \"1234\")\n/// \"\
    4321\"\n/// >>> solve(s: \"ab\")\n/// \"AB\"\n/// >>> solve(s: \"#a@C\")\n///\
    \ \"#A@c\"\nfunc solve(s: String) -> String {\n    guard s.count > 0 else { return\
    \ s }\n    var output = String()\n    for character in s {\n        let scalars\
    \ = String(character).unicodeScalars\n        let value = scalars[scalars.startIndex].value\n\
    \        if (value > 90 && value < 123) || (value > 64 && value < 91) {\n    \
    \        output.append(Character(unicodeScalar: scalars[scalars.startIndex].value\
    \ ^^ 0x20))\n        } else {\n            output.append(character)\n        }\n\
    \    }\n    return output\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(solve(s: \"\
    AsDf\") == \"aSdF\")\nassert(solve(s: \"1234\") == \"4321\")\nassert(solve(s:\
    \ \"ab\") == \"AB\")\nassert(solve(s: \"#a@C\") == \"#A@c\")\nassert(solve(s:\
    \ \"#AsdfW^45\") == \"#aSDFw^45\")\nassert(solve(s: \"#6@2\") == \"2@6#\")\nassert(solve(s:\
    \ \"#$a^D\") == \"#$A^d\")\nassert(solve(s: \"#ccc\") == \"#CCC\")"
  status: SyntaxError
  stderr: "/tmp/tmp1s92w78r.swift:21:86: error: cannot find operator '^^' in scope\n\
    \            output.append(Character(unicodeScalar: scalars[scalars.startIndex].value\
    \ ^^ 0x20))\n                                                                \
    \                     ^~\n/tmp/tmp1s92w78r.swift:21:27: error: no exact matches\
    \ in call to initializer \n            output.append(Character(unicodeScalar:\
    \ scalars[scalars.startIndex].value ^^ 0x20))\n                          ^\n/tmp/tmp1s92w78r.swift:21:27:\
    \ note: found candidate with type '(Unicode.Scalar) -> Character'\n          \
    \  output.append(Character(unicodeScalar: scalars[scalars.startIndex].value ^^\
    \ 0x20))\n                          ^\n/tmp/tmp1s92w78r.swift:21:27: note: found\
    \ candidate with type '(String) -> Character'\n            output.append(Character(unicodeScalar:\
    \ scalars[scalars.startIndex].value ^^ 0x20))\n                          ^\n"
  stdout: ''
  timestamp: 1659978811
- exit_code: -4
  program: "\n/// You are given a string s.\n/// if s[i] is a letter, reverse its\
    \ case from lower to upper or vise versa, \n/// otherwise keep it as it is.\n\
    /// If the string contains no letters, reverse the string.\n/// The function should\
    \ return the resulted string.\n/// Examples\n/// >>> solve(s: \"1234\")\n/// \"\
    4321\"\n/// >>> solve(s: \"ab\")\n/// \"AB\"\n/// >>> solve(s: \"#a@C\")\n///\
    \ \"#A@c\"\nfunc solve(s: String) -> String {\n    if s.contains(\"a\") || s.contains(\"\
    A\") || s.contains(\"e\") || s.contains(\"E\") || s.contains(\"i\") || s.contains(\"\
    I\") || s.contains(\"o\") || s.contains(\"O\") || s.contains(\"u\") || s.contains(\"\
    U\"){\n        var result = \"\"\n        for i in s{\n            if i == \"\
    a\" || i == \"e\" || i == \"i\" || i == \"o\" || i == \"u\" {\n              \
    \  result.append(String(i).uppercased())\n            } else if i == \"A\" ||\
    \ i == \"E\" || i == \"I\" || i == \"O\" || i == \"U\" {\n                result.append(String(i).lowercased())\n\
    \            } else {\n                result.append(i)\n            }\n     \
    \   }\n        return result\n    } else {\n        var result = \"\"\n      \
    \  for i in s.reversed(){\n            result.append(i)\n        }\n        return\
    \ result\n    }\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool\
    \ {\n    if left.count != right.count {\n        return false\n    }\n    for\
    \ (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(solve(s: \"AsDf\"\
    ) == \"aSdF\")\nassert(solve(s: \"1234\") == \"4321\")\nassert(solve(s: \"ab\"\
    ) == \"AB\")\nassert(solve(s: \"#a@C\") == \"#A@c\")\nassert(solve(s: \"#AsdfW^45\"\
    ) == \"#aSDFw^45\")\nassert(solve(s: \"#6@2\") == \"2@6#\")\nassert(solve(s: \"\
    #$a^D\") == \"#$A^d\")\nassert(solve(s: \"#ccc\") == \"#CCC\")"
  status: Exception
  stderr: 'tmpu8hui9lr/tmpu8hui9lr.swift:49: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b616fd87c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b616fa7eb6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b616fa7e988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b616fa7d7b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpu8hui9lr                        0x000055e3ab41a997 <unavailable> + 6551

    5    libc.so.6                          0x00002b616ff73460 __libc_start_main +
    245

    6    tmpu8hui9lr                        0x000055e3ab41a5d9 <unavailable> + 5593

    '
  stdout: ''
  timestamp: 1659978812
- exit_code: 1
  program: "\n/// You are given a string s.\n/// if s[i] is a letter, reverse its\
    \ case from lower to upper or vise versa, \n/// otherwise keep it as it is.\n\
    /// If the string contains no letters, reverse the string.\n/// The function should\
    \ return the resulted string.\n/// Examples\n/// >>> solve(s: \"1234\")\n/// \"\
    4321\"\n/// >>> solve(s: \"ab\")\n/// \"AB\"\n/// >>> solve(s: \"#a@C\")\n///\
    \ \"#A@c\"\nfunc solve(s: String) -> String {\n    var result = \"\"\n    let\
    \ alphabet = \"ABCDEFGHIJKLMNOPQRSTUVWXYZ\"\n    let lowercase = \"abcdefghijklmnopqrstuvwxyz\"\
    \n    for char in s {\n        if alphabet.contains(char) {\n            let index\
    \ = alphabet.firstIndex(of: char)!\n            result.append(lowercase[index])\n\
    \        } else if lowercase.contains(char) {\n            let index = lowercase.firstIndex(of:\
    \ char)!\n            result.append(alphabet[index])\n        } else {\n     \
    \       result.append(char)\n        }\n    }\n    return result.isEmpty ? s.reversed()\
    \ : result\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n\
    \    if left.count != right.count {\n        return false\n    }\n    for (l,\
    \ r) in zip(left, right) {\n        if l != r {\n            return false\n  \
    \      }\n    }\n    return true\n}\n            \nassert(solve(s: \"AsDf\") ==\
    \ \"aSdF\")\nassert(solve(s: \"1234\") == \"4321\")\nassert(solve(s: \"ab\") ==\
    \ \"AB\")\nassert(solve(s: \"#a@C\") == \"#A@c\")\nassert(solve(s: \"#AsdfW^45\"\
    ) == \"#aSDFw^45\")\nassert(solve(s: \"#6@2\") == \"2@6#\")\nassert(solve(s: \"\
    #$a^D\") == \"#$A^d\")\nassert(solve(s: \"#ccc\") == \"#CCC\")"
  status: SyntaxError
  stderr: "/tmp/tmpya2vrd3k.swift:29:27: error: cannot convert return expression of\
    \ type 'ReversedCollection<String>' to return type 'String'\n    return result.isEmpty\
    \ ? s.reversed() : result\n           ~~~~~~~~~~~~~~~^~~~~~~~~~~~~~~~~~~~~~~\n"
  stdout: ''
  timestamp: 1659978811
- exit_code: 1
  program: "\n/// You are given a string s.\n/// if s[i] is a letter, reverse its\
    \ case from lower to upper or vise versa, \n/// otherwise keep it as it is.\n\
    /// If the string contains no letters, reverse the string.\n/// The function should\
    \ return the resulted string.\n/// Examples\n/// >>> solve(s: \"1234\")\n/// \"\
    4321\"\n/// >>> solve(s: \"ab\")\n/// \"AB\"\n/// >>> solve(s: \"#a@C\")\n///\
    \ \"#A@c\"\nfunc solve(s: String) -> String {\n    // your code goes here\n}\n\
    \n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(solve(s: \"AsDf\") == \"aSdF\")\nassert(solve(s:\
    \ \"1234\") == \"4321\")\nassert(solve(s: \"ab\") == \"AB\")\nassert(solve(s:\
    \ \"#a@C\") == \"#A@c\")\nassert(solve(s: \"#AsdfW^45\") == \"#aSDFw^45\")\nassert(solve(s:\
    \ \"#6@2\") == \"2@6#\")\nassert(solve(s: \"#$a^D\") == \"#$A^d\")\nassert(solve(s:\
    \ \"#ccc\") == \"#CCC\")"
  status: SyntaxError
  stderr: '/tmp/tmpug90yy9m.swift:16:1: error: missing return in global function expected
    to return ''String''

    }

    ^

    '
  stdout: ''
  timestamp: 1659978811
- exit_code: 1
  program: "\n/// You are given a string s.\n/// if s[i] is a letter, reverse its\
    \ case from lower to upper or vise versa, \n/// otherwise keep it as it is.\n\
    /// If the string contains no letters, reverse the string.\n/// The function should\
    \ return the resulted string.\n/// Examples\n/// >>> solve(s: \"1234\")\n/// \"\
    4321\"\n/// >>> solve(s: \"ab\")\n/// \"AB\"\n/// >>> solve(s: \"#a@C\")\n///\
    \ \"#A@c\"\nfunc solve(s: String) -> String {\n    var newStr = \"\"\n    if s.rangeOfCharacter(from:\
    \ CharacterSet.letters) == nil {\n        return String(s.reversed())\n    }\n\
    \    for letter in s {\n        if CharacterSet.lowercaseLetters.contains(letter.unicodeScalars.first!)\
    \ {\n            newStr.append(letter.uppercased())\n        } else if CharacterSet.uppercaseLetters.contains(letter.unicodeScalars.first!)\
    \ {\n            newStr.append(letter.lowercased())\n        } else {\n      \
    \      newStr.append(letter)\n        }\n    }\n    return newStr\n}\n\n\nfunc\
    \ ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count !=\
    \ right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(solve(s: \"AsDf\") == \"aSdF\")\nassert(solve(s:\
    \ \"1234\") == \"4321\")\nassert(solve(s: \"ab\") == \"AB\")\nassert(solve(s:\
    \ \"#a@C\") == \"#A@c\")\nassert(solve(s: \"#AsdfW^45\") == \"#aSDFw^45\")\nassert(solve(s:\
    \ \"#6@2\") == \"2@6#\")\nassert(solve(s: \"#$a^D\") == \"#$A^d\")\nassert(solve(s:\
    \ \"#ccc\") == \"#CCC\")"
  status: SyntaxError
  stderr: "/tmp/tmp377hyjxc.swift:16:33: error: cannot find 'CharacterSet' in scope\n\
    \    if s.rangeOfCharacter(from: CharacterSet.letters) == nil {\n            \
    \                    ^~~~~~~~~~~~\n/tmp/tmp377hyjxc.swift:16:10: error: value\
    \ of type 'String' has no member 'rangeOfCharacter'\n    if s.rangeOfCharacter(from:\
    \ CharacterSet.letters) == nil {\n       ~ ^~~~~~~~~~~~~~~~\n/tmp/tmp377hyjxc.swift:20:12:\
    \ error: cannot find 'CharacterSet' in scope\n        if CharacterSet.lowercaseLetters.contains(letter.unicodeScalars.first!)\
    \ {\n           ^~~~~~~~~~~~\n/tmp/tmp377hyjxc.swift:22:19: error: cannot find\
    \ 'CharacterSet' in scope\n        } else if CharacterSet.uppercaseLetters.contains(letter.unicodeScalars.first!)\
    \ {\n                  ^~~~~~~~~~~~\n"
  stdout: ''
  timestamp: 1659978812
- exit_code: 1
  program: "\n/// You are given a string s.\n/// if s[i] is a letter, reverse its\
    \ case from lower to upper or vise versa, \n/// otherwise keep it as it is.\n\
    /// If the string contains no letters, reverse the string.\n/// The function should\
    \ return the resulted string.\n/// Examples\n/// >>> solve(s: \"1234\")\n/// \"\
    4321\"\n/// >>> solve(s: \"ab\")\n/// \"AB\"\n/// >>> solve(s: \"#a@C\")\n///\
    \ \"#A@c\"\nfunc solve(s: String) -> String {\n    if s.isEmpty {\n        return\
    \ s\n    }\n    let arr = s.map { String($0) }\n    var flag = false\n    for\
    \ i in 0..<arr.count {\n        if arr[i].isLetter {\n            flag = true\n\
    \            break\n        }\n    }\n    if flag {\n        for i in 0..<arr.count\
    \ {\n            if arr[i].isLetter {\n                arr[i] = String(arr[i].lowercased().first!)\n\
    \            }\n        }\n    }\n    var ans = \"\"\n    for i in stride(from:\
    \ arr.count - 1, through: 0, by: -1) {\n        ans += arr[i]\n    }\n    return\
    \ ans\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n   \
    \ if left.count != right.count {\n        return false\n    }\n    for (l, r)\
    \ in zip(left, right) {\n        if l != r {\n            return false\n     \
    \   }\n    }\n    return true\n}\n            \nassert(solve(s: \"AsDf\") == \"\
    aSdF\")\nassert(solve(s: \"1234\") == \"4321\")\nassert(solve(s: \"ab\") == \"\
    AB\")\nassert(solve(s: \"#a@C\") == \"#A@c\")\nassert(solve(s: \"#AsdfW^45\")\
    \ == \"#aSDFw^45\")\nassert(solve(s: \"#6@2\") == \"2@6#\")\nassert(solve(s: \"\
    #$a^D\") == \"#$A^d\")\nassert(solve(s: \"#ccc\") == \"#CCC\")"
  status: SyntaxError
  stderr: "/tmp/tmpgjcod75m.swift:21:19: error: value of type 'String' has no member\
    \ 'isLetter'\n        if arr[i].isLetter {\n           ~~~~~~ ^~~~~~~~\n/tmp/tmpgjcod75m.swift:28:23:\
    \ error: value of type 'String' has no member 'isLetter'\n            if arr[i].isLetter\
    \ {\n               ~~~~~~ ^~~~~~~~\n/tmp/tmpgjcod75m.swift:29:20: error: cannot\
    \ assign through subscript: 'arr' is a 'let' constant\n                arr[i]\
    \ = String(arr[i].lowercased().first!)\n                ~~~^\n/tmp/tmpgjcod75m.swift:18:5:\
    \ note: change 'let' to 'var' to make it mutable\n    let arr = s.map { String($0)\
    \ }\n    ^~~\n    var\n"
  stdout: ''
  timestamp: 1659978812
- exit_code: 1
  program: "\n/// You are given a string s.\n/// if s[i] is a letter, reverse its\
    \ case from lower to upper or vise versa, \n/// otherwise keep it as it is.\n\
    /// If the string contains no letters, reverse the string.\n/// The function should\
    \ return the resulted string.\n/// Examples\n/// >>> solve(s: \"1234\")\n/// \"\
    4321\"\n/// >>> solve(s: \"ab\")\n/// \"AB\"\n/// >>> solve(s: \"#a@C\")\n///\
    \ \"#A@c\"\nfunc solve(s: String) -> String {\n    var output = \"\"\n    let\
    \ isLetter = s.rangeOfCharacter(from: .letters)\n    let isUpper = s.rangeOfCharacter(from:\
    \ .uppercaseLetters)\n    let isLower = s.rangeOfCharacter(from: .lowercaseLetters)\n\
    \    for element in s {\n        if isLetter != nil {\n            if isUpper\
    \ != nil && isLower != nil {\n                output.append(element.lowercased())\n\
    \            } else {\n                output.append(element.uppercased())\n \
    \           }\n        } else {\n            output.append(String(element.asciiValue!))\n\
    \        }\n    }\n    return String(output.reversed())\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(solve(s: \"AsDf\") == \"aSdF\")\nassert(solve(s: \"1234\"\
    ) == \"4321\")\nassert(solve(s: \"ab\") == \"AB\")\nassert(solve(s: \"#a@C\")\
    \ == \"#A@c\")\nassert(solve(s: \"#AsdfW^45\") == \"#aSDFw^45\")\nassert(solve(s:\
    \ \"#6@2\") == \"2@6#\")\nassert(solve(s: \"#$a^D\") == \"#$A^d\")\nassert(solve(s:\
    \ \"#ccc\") == \"#CCC\")"
  status: SyntaxError
  stderr: "/tmp/tmph7gw_0q1.swift:16:22: error: value of type 'String' has no member\
    \ 'rangeOfCharacter'\n    let isLetter = s.rangeOfCharacter(from: .letters)\n\
    \                   ~ ^~~~~~~~~~~~~~~~\n/tmp/tmph7gw_0q1.swift:16:46: error: cannot\
    \ infer contextual base in reference to member 'letters'\n    let isLetter = s.rangeOfCharacter(from:\
    \ .letters)\n                                            ~^~~~~~~\n/tmp/tmph7gw_0q1.swift:17:21:\
    \ error: value of type 'String' has no member 'rangeOfCharacter'\n    let isUpper\
    \ = s.rangeOfCharacter(from: .uppercaseLetters)\n                  ~ ^~~~~~~~~~~~~~~~\n\
    /tmp/tmph7gw_0q1.swift:17:45: error: cannot infer contextual base in reference\
    \ to member 'uppercaseLetters'\n    let isUpper = s.rangeOfCharacter(from: .uppercaseLetters)\n\
    \                                           ~^~~~~~~~~~~~~~~~\n/tmp/tmph7gw_0q1.swift:18:21:\
    \ error: value of type 'String' has no member 'rangeOfCharacter'\n    let isLower\
    \ = s.rangeOfCharacter(from: .lowercaseLetters)\n                  ~ ^~~~~~~~~~~~~~~~\n\
    /tmp/tmph7gw_0q1.swift:18:45: error: cannot infer contextual base in reference\
    \ to member 'lowercaseLetters'\n    let isLower = s.rangeOfCharacter(from: .lowercaseLetters)\n\
    \                                           ~^~~~~~~~~~~~~~~~\n"
  stdout: ''
  timestamp: 1659978812
- exit_code: 0
  program: "\n/// You are given a string s.\n/// if s[i] is a letter, reverse its\
    \ case from lower to upper or vise versa, \n/// otherwise keep it as it is.\n\
    /// If the string contains no letters, reverse the string.\n/// The function should\
    \ return the resulted string.\n/// Examples\n/// >>> solve(s: \"1234\")\n/// \"\
    4321\"\n/// >>> solve(s: \"ab\")\n/// \"AB\"\n/// >>> solve(s: \"#a@C\")\n///\
    \ \"#A@c\"\nfunc solve(s: String) -> String {\n    if !(s.contains(where: { $0.isLetter\
    \ })) {\n        return String(s.reversed())\n    }\n    return String(s.map {\
    \ $0.isLetter ? $0.isUppercase ? Character($0.lowercased()) : Character($0.uppercased())\
    \ : $0 })\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n\
    \    if left.count != right.count {\n        return false\n    }\n    for (l,\
    \ r) in zip(left, right) {\n        if l != r {\n            return false\n  \
    \      }\n    }\n    return true\n}\n            \nassert(solve(s: \"AsDf\") ==\
    \ \"aSdF\")\nassert(solve(s: \"1234\") == \"4321\")\nassert(solve(s: \"ab\") ==\
    \ \"AB\")\nassert(solve(s: \"#a@C\") == \"#A@c\")\nassert(solve(s: \"#AsdfW^45\"\
    ) == \"#aSDFw^45\")\nassert(solve(s: \"#6@2\") == \"2@6#\")\nassert(solve(s: \"\
    #$a^D\") == \"#$A^d\")\nassert(solve(s: \"#ccc\") == \"#CCC\")"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659978812
- exit_code: 0
  program: "\n/// You are given a string s.\n/// if s[i] is a letter, reverse its\
    \ case from lower to upper or vise versa, \n/// otherwise keep it as it is.\n\
    /// If the string contains no letters, reverse the string.\n/// The function should\
    \ return the resulted string.\n/// Examples\n/// >>> solve(s: \"1234\")\n/// \"\
    4321\"\n/// >>> solve(s: \"ab\")\n/// \"AB\"\n/// >>> solve(s: \"#a@C\")\n///\
    \ \"#A@c\"\nfunc solve(s: String) -> String {\n    let chars = Array(s)\n    var\
    \ result = \"\"\n    var hasLetter = false\n    for char in chars {\n        if\
    \ char.isLetter {\n            hasLetter = true\n            result.append(char.isLowercase\
    \ ? Character(char.uppercased()) : Character(char.lowercased()))\n        } else\
    \ {\n            result.append(char)\n        }\n    }\n    return hasLetter ?\
    \ result : String(result.reversed())\n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(solve(s: \"AsDf\") == \"aSdF\")\nassert(solve(s: \"1234\") == \"4321\"\
    )\nassert(solve(s: \"ab\") == \"AB\")\nassert(solve(s: \"#a@C\") == \"#A@c\")\n\
    assert(solve(s: \"#AsdfW^45\") == \"#aSDFw^45\")\nassert(solve(s: \"#6@2\") ==\
    \ \"2@6#\")\nassert(solve(s: \"#$a^D\") == \"#$A^d\")\nassert(solve(s: \"#ccc\"\
    ) == \"#CCC\")"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659978812
- exit_code: 1
  program: "\n/// You are given a string s.\n/// if s[i] is a letter, reverse its\
    \ case from lower to upper or vise versa, \n/// otherwise keep it as it is.\n\
    /// If the string contains no letters, reverse the string.\n/// The function should\
    \ return the resulted string.\n/// Examples\n/// >>> solve(s: \"1234\")\n/// \"\
    4321\"\n/// >>> solve(s: \"ab\")\n/// \"AB\"\n/// >>> solve(s: \"#a@C\")\n///\
    \ \"#A@c\"\nfunc solve(s: String) -> String {\n    var new = \"\"\n    for character\
    \ in s {\n        switch character {\n        case \"a\"...\"z\":\n          \
    \  new.append(character.uppercased())\n        case \"A\"...\"Z\":\n         \
    \   new.append(character.lowercased())\n        default:\n            new.append(character)\n\
    \        }\n    }\n    return new.isEmpty ? s.reversed() : new\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(solve(s: \"AsDf\") == \"aSdF\")\nassert(solve(s: \"1234\"\
    ) == \"4321\")\nassert(solve(s: \"ab\") == \"AB\")\nassert(solve(s: \"#a@C\")\
    \ == \"#A@c\")\nassert(solve(s: \"#AsdfW^45\") == \"#aSDFw^45\")\nassert(solve(s:\
    \ \"#6@2\") == \"2@6#\")\nassert(solve(s: \"#$a^D\") == \"#$A^d\")\nassert(solve(s:\
    \ \"#ccc\") == \"#CCC\")"
  status: SyntaxError
  stderr: "/tmp/tmp1t61ic3e.swift:26:24: error: cannot convert return expression of\
    \ type 'ReversedCollection<String>' to return type 'String'\n    return new.isEmpty\
    \ ? s.reversed() : new\n           ~~~~~~~~~~~~^~~~~~~~~~~~~~~~~~~~\n"
  stdout: ''
  timestamp: 1659978812
- exit_code: -4
  program: "\n/// You are given a string s.\n/// if s[i] is a letter, reverse its\
    \ case from lower to upper or vise versa, \n/// otherwise keep it as it is.\n\
    /// If the string contains no letters, reverse the string.\n/// The function should\
    \ return the resulted string.\n/// Examples\n/// >>> solve(s: \"1234\")\n/// \"\
    4321\"\n/// >>> solve(s: \"ab\")\n/// \"AB\"\n/// >>> solve(s: \"#a@C\")\n///\
    \ \"#A@c\"\nfunc solve(s: String) -> String {\n    let lower = \"abcdefghijklmnopqrstuvwxyz\"\
    \n    let upper = \"ABCDEFGHIJKLMNOPQRSTUVWXYZ\"\n    var newString = \"\"\n \
    \   for c in s {\n        if lower.contains(c) {\n            newString.append(c.uppercased())\n\
    \        } else if upper.contains(c) {\n            newString.append(c.lowercased())\n\
    \        } else {\n            newString.append(c)\n        }\n    }\n    if newString.isEmpty\
    \ {\n        return String(s.reversed())\n    }\n    return newString\n}\n\n\n\
    func ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(solve(s: \"AsDf\") == \"aSdF\")\nassert(solve(s:\
    \ \"1234\") == \"4321\")\nassert(solve(s: \"ab\") == \"AB\")\nassert(solve(s:\
    \ \"#a@C\") == \"#A@c\")\nassert(solve(s: \"#AsdfW^45\") == \"#aSDFw^45\")\nassert(solve(s:\
    \ \"#6@2\") == \"2@6#\")\nassert(solve(s: \"#$a^D\") == \"#$A^d\")\nassert(solve(s:\
    \ \"#ccc\") == \"#CCC\")"
  status: Exception
  stderr: 'tmpkrn6aek9/tmpkrn6aek9.swift:47: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b730a5b2c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b730a2a9b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b730a2a9988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b730a2a87b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpkrn6aek9                        0x000056329242b917 <unavailable> + 6423

    5    libc.so.6                          0x00002b730a79e460 __libc_start_main +
    245

    6    tmpkrn6aek9                        0x000056329242b469 <unavailable> + 5225

    '
  stdout: ''
  timestamp: 1659978812
- exit_code: -4
  program: "\n/// You are given a string s.\n/// if s[i] is a letter, reverse its\
    \ case from lower to upper or vise versa, \n/// otherwise keep it as it is.\n\
    /// If the string contains no letters, reverse the string.\n/// The function should\
    \ return the resulted string.\n/// Examples\n/// >>> solve(s: \"1234\")\n/// \"\
    4321\"\n/// >>> solve(s: \"ab\")\n/// \"AB\"\n/// >>> solve(s: \"#a@C\")\n///\
    \ \"#A@c\"\nfunc solve(s: String) -> String {\n    return \"\";\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(solve(s: \"AsDf\") == \"aSdF\")\nassert(solve(s: \"1234\"\
    ) == \"4321\")\nassert(solve(s: \"ab\") == \"AB\")\nassert(solve(s: \"#a@C\")\
    \ == \"#A@c\")\nassert(solve(s: \"#AsdfW^45\") == \"#aSDFw^45\")\nassert(solve(s:\
    \ \"#6@2\") == \"2@6#\")\nassert(solve(s: \"#$a^D\") == \"#$A^d\")\nassert(solve(s:\
    \ \"#ccc\") == \"#CCC\")"
  status: Exception
  stderr: 'tmpymfk_0re/tmpymfk_0re.swift:31: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b38763f2c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b38760e9b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b38760e9988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b38760e87b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpymfk_0re                        0x0000557ef05fe307 <unavailable> + 4871

    5    libc.so.6                          0x00002b38765de460 __libc_start_main +
    245

    6    tmpymfk_0re                        0x0000557ef05fdf49 <unavailable> + 3913

    '
  stdout: ''
  timestamp: 1659978812
- exit_code: 0
  program: "\n/// You are given a string s.\n/// if s[i] is a letter, reverse its\
    \ case from lower to upper or vise versa, \n/// otherwise keep it as it is.\n\
    /// If the string contains no letters, reverse the string.\n/// The function should\
    \ return the resulted string.\n/// Examples\n/// >>> solve(s: \"1234\")\n/// \"\
    4321\"\n/// >>> solve(s: \"ab\")\n/// \"AB\"\n/// >>> solve(s: \"#a@C\")\n///\
    \ \"#A@c\"\nfunc solve(s: String) -> String {\n\treturn s.contains(where: { $0.isLetter\
    \ }) ? String(s.map({ $0.isLowercase ? Character($0.uppercased()) : Character($0.lowercased())\
    \ })) : String(s.reversed())\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int,\
    \ Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n\
    \    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n          \
    \  return false\n        }\n    }\n    return true\n}\n            \nassert(solve(s:\
    \ \"AsDf\") == \"aSdF\")\nassert(solve(s: \"1234\") == \"4321\")\nassert(solve(s:\
    \ \"ab\") == \"AB\")\nassert(solve(s: \"#a@C\") == \"#A@c\")\nassert(solve(s:\
    \ \"#AsdfW^45\") == \"#aSDFw^45\")\nassert(solve(s: \"#6@2\") == \"2@6#\")\nassert(solve(s:\
    \ \"#$a^D\") == \"#$A^d\")\nassert(solve(s: \"#ccc\") == \"#CCC\")"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659978812
- exit_code: 1
  program: "\n/// You are given a string s.\n/// if s[i] is a letter, reverse its\
    \ case from lower to upper or vise versa, \n/// otherwise keep it as it is.\n\
    /// If the string contains no letters, reverse the string.\n/// The function should\
    \ return the resulted string.\n/// Examples\n/// >>> solve(s: \"1234\")\n/// \"\
    4321\"\n/// >>> solve(s: \"ab\")\n/// \"AB\"\n/// >>> solve(s: \"#a@C\")\n///\
    \ \"#A@c\"\nfunc solve(s: String) -> String {\n  if s.isEmpty { return s }\n \
    \ var tmp = \"\"\n  for char in s {\n    if char.isLetter {\n      tmp.append(char.isUppercase\
    \ ? char.lowercased() : char.uppercased())\n    } else {\n      tmp.append(char)\n\
    \    }\n  }\n  return s.isAllLetters ? String(tmp.reversed()) : tmp\n}\n\n\nfunc\
    \ ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count !=\
    \ right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(solve(s: \"AsDf\") == \"aSdF\")\nassert(solve(s:\
    \ \"1234\") == \"4321\")\nassert(solve(s: \"ab\") == \"AB\")\nassert(solve(s:\
    \ \"#a@C\") == \"#A@c\")\nassert(solve(s: \"#AsdfW^45\") == \"#aSDFw^45\")\nassert(solve(s:\
    \ \"#6@2\") == \"2@6#\")\nassert(solve(s: \"#$a^D\") == \"#$A^d\")\nassert(solve(s:\
    \ \"#ccc\") == \"#CCC\")"
  status: SyntaxError
  stderr: "/tmp/tmpz5q6k1ep.swift:24:12: error: value of type 'String' has no member\
    \ 'isAllLetters'\n  return s.isAllLetters ? String(tmp.reversed()) : tmp\n   \
    \      ~ ^~~~~~~~~~~~\n"
  stdout: ''
  timestamp: 1659978812
- exit_code: 0
  program: "\n/// You are given a string s.\n/// if s[i] is a letter, reverse its\
    \ case from lower to upper or vise versa, \n/// otherwise keep it as it is.\n\
    /// If the string contains no letters, reverse the string.\n/// The function should\
    \ return the resulted string.\n/// Examples\n/// >>> solve(s: \"1234\")\n/// \"\
    4321\"\n/// >>> solve(s: \"ab\")\n/// \"AB\"\n/// >>> solve(s: \"#a@C\")\n///\
    \ \"#A@c\"\nfunc solve(s: String) -> String {\n    var result = \"\"\n    if s.first(where:\
    \ { $0.isLetter }) == nil {\n        for i in stride(from: s.count - 1, through:\
    \ 0, by: -1) {\n            result.append(s[s.index(s.startIndex, offsetBy: i)])\n\
    \        }\n    } else {\n        for i in s {\n            if i.isLetter {\n\
    \                result.append(i.isLowercase ? i.uppercased() : i.lowercased())\n\
    \            } else {\n                result.append(i)\n            }\n     \
    \   }\n    }\n    return result\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int,\
    \ Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n\
    \    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n          \
    \  return false\n        }\n    }\n    return true\n}\n            \nassert(solve(s:\
    \ \"AsDf\") == \"aSdF\")\nassert(solve(s: \"1234\") == \"4321\")\nassert(solve(s:\
    \ \"ab\") == \"AB\")\nassert(solve(s: \"#a@C\") == \"#A@c\")\nassert(solve(s:\
    \ \"#AsdfW^45\") == \"#aSDFw^45\")\nassert(solve(s: \"#6@2\") == \"2@6#\")\nassert(solve(s:\
    \ \"#$a^D\") == \"#$A^d\")\nassert(solve(s: \"#ccc\") == \"#CCC\")"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659978812
- exit_code: 1
  program: "\n/// You are given a string s.\n/// if s[i] is a letter, reverse its\
    \ case from lower to upper or vise versa, \n/// otherwise keep it as it is.\n\
    /// If the string contains no letters, reverse the string.\n/// The function should\
    \ return the resulted string.\n/// Examples\n/// >>> solve(s: \"1234\")\n/// \"\
    4321\"\n/// >>> solve(s: \"ab\")\n/// \"AB\"\n/// >>> solve(s: \"#a@C\")\n///\
    \ \"#A@c\"\nfunc solve(s: String) -> String {\n    if s.contains(\"a\") || s.contains(\"\
    b\") || s.contains(\"c\") || s.contains(\"d\") || s.contains(\"e\") || s.contains(\"\
    f\") || s.contains(\"g\") || s.contains(\"h\") || s.contains(\"i\") || s.contains(\"\
    j\") || s.contains(\"k\") || s.contains(\"l\") || s.contains(\"m\") || s.contains(\"\
    n\") || s.contains(\"o\") || s.contains(\"p\") || s.contains(\"q\") || s.contains(\"\
    r\") || s.contains(\"s\") || s.contains(\"t\") || s.contains(\"u\") || s.contains(\"\
    v\") || s.contains(\"w\") || s.contains(\"x\") || s.contains(\"y\") || s.contains(\"\
    z\") {\n        return String(s.map{ $0.isUppercase ? $0.lowercased() : $0.uppercased()\
    \ })\n    } else {\n        return String(s.reversed())\n    }\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(solve(s: \"AsDf\") == \"aSdF\")\nassert(solve(s: \"1234\"\
    ) == \"4321\")\nassert(solve(s: \"ab\") == \"AB\")\nassert(solve(s: \"#a@C\")\
    \ == \"#A@c\")\nassert(solve(s: \"#AsdfW^45\") == \"#aSDFw^45\")\nassert(solve(s:\
    \ \"#6@2\") == \"2@6#\")\nassert(solve(s: \"#$a^D\") == \"#$A^d\")\nassert(solve(s:\
    \ \"#ccc\") == \"#CCC\")"
  status: SyntaxError
  stderr: "/tmp/tmp_itkn8ue.swift:16:16: error: type of expression is ambiguous without\
    \ more context\n        return String(s.map{ $0.isUppercase ? $0.lowercased()\
    \ : $0.uppercased() })\n               ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n"
  stdout: ''
  timestamp: 1659978812
- exit_code: 0
  program: "\n/// You are given a string s.\n/// if s[i] is a letter, reverse its\
    \ case from lower to upper or vise versa, \n/// otherwise keep it as it is.\n\
    /// If the string contains no letters, reverse the string.\n/// The function should\
    \ return the resulted string.\n/// Examples\n/// >>> solve(s: \"1234\")\n/// \"\
    4321\"\n/// >>> solve(s: \"ab\")\n/// \"AB\"\n/// >>> solve(s: \"#a@C\")\n///\
    \ \"#A@c\"\nfunc solve(s: String) -> String {\n    guard s.contains(where: { $0.isLetter\
    \ }) else {\n        return String(s.reversed())\n    }\n    return String(s.map\
    \ { (ch) -> Character in\n        guard ch.isLetter else {\n            return\
    \ ch\n        }\n        return ch.isUppercase ? ch.lowercased().first! : ch.uppercased().first!\n\
    \    })\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n \
    \   if left.count != right.count {\n        return false\n    }\n    for (l, r)\
    \ in zip(left, right) {\n        if l != r {\n            return false\n     \
    \   }\n    }\n    return true\n}\n            \nassert(solve(s: \"AsDf\") == \"\
    aSdF\")\nassert(solve(s: \"1234\") == \"4321\")\nassert(solve(s: \"ab\") == \"\
    AB\")\nassert(solve(s: \"#a@C\") == \"#A@c\")\nassert(solve(s: \"#AsdfW^45\")\
    \ == \"#aSDFw^45\")\nassert(solve(s: \"#6@2\") == \"2@6#\")\nassert(solve(s: \"\
    #$a^D\") == \"#$A^d\")\nassert(solve(s: \"#ccc\") == \"#CCC\")"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659978812
- exit_code: -4
  program: "\n/// You are given a string s.\n/// if s[i] is a letter, reverse its\
    \ case from lower to upper or vise versa, \n/// otherwise keep it as it is.\n\
    /// If the string contains no letters, reverse the string.\n/// The function should\
    \ return the resulted string.\n/// Examples\n/// >>> solve(s: \"1234\")\n/// \"\
    4321\"\n/// >>> solve(s: \"ab\")\n/// \"AB\"\n/// >>> solve(s: \"#a@C\")\n///\
    \ \"#A@c\"\nfunc solve(s: String) -> String {\n    var result = \"\"\n    for\
    \ item in s {\n        if item.isLetter {\n            result.append(item.isLowercase\
    \ ? item.uppercased() : item.lowercased())\n        } else {\n            result.append(item)\n\
    \        }\n    }\n    return result.isEmpty ? String(s.reversed()) : result\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(solve(s: \"AsDf\") == \"aSdF\")\nassert(solve(s:\
    \ \"1234\") == \"4321\")\nassert(solve(s: \"ab\") == \"AB\")\nassert(solve(s:\
    \ \"#a@C\") == \"#A@c\")\nassert(solve(s: \"#AsdfW^45\") == \"#aSDFw^45\")\nassert(solve(s:\
    \ \"#6@2\") == \"2@6#\")\nassert(solve(s: \"#$a^D\") == \"#$A^d\")\nassert(solve(s:\
    \ \"#ccc\") == \"#CCC\")"
  status: Exception
  stderr: 'tmpmiwbedo5/tmpmiwbedo5.swift:40: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002ba4b30b5c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002ba4b2dacb6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002ba4b2dac988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002ba4b2dab7b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpmiwbedo5                        0x000055be21baf8d7 <unavailable> + 6359

    5    libc.so.6                          0x00002ba4b32a1460 __libc_start_main +
    245

    6    tmpmiwbedo5                        0x000055be21baf429 <unavailable> + 5161

    '
  stdout: ''
  timestamp: 1659978812
- exit_code: 1
  program: "\n/// You are given a string s.\n/// if s[i] is a letter, reverse its\
    \ case from lower to upper or vise versa, \n/// otherwise keep it as it is.\n\
    /// If the string contains no letters, reverse the string.\n/// The function should\
    \ return the resulted string.\n/// Examples\n/// >>> solve(s: \"1234\")\n/// \"\
    4321\"\n/// >>> solve(s: \"ab\")\n/// \"AB\"\n/// >>> solve(s: \"#a@C\")\n///\
    \ \"#A@c\"\nfunc solve(s: String) -> String {\n    if s.rangeOfCharacter(from:\
    \ CharacterSet.letters) == nil {\n        return String(s.reversed())\n    }\n\
    \    var result = \"\"\n    for c in s {\n        let charSet = CharacterSet.init(charactersIn:\
    \ c.lowercased())\n        if charSet.isSubset(of: CharacterSet.letters) {\n \
    \           result += (c.lowercased() == c) ? c.uppercased() : c.lowercased()\n\
    \        } else {\n            result += String(c)\n        }\n    }\n    return\
    \ result\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n\
    \    if left.count != right.count {\n        return false\n    }\n    for (l,\
    \ r) in zip(left, right) {\n        if l != r {\n            return false\n  \
    \      }\n    }\n    return true\n}\n            \nassert(solve(s: \"AsDf\") ==\
    \ \"aSdF\")\nassert(solve(s: \"1234\") == \"4321\")\nassert(solve(s: \"ab\") ==\
    \ \"AB\")\nassert(solve(s: \"#a@C\") == \"#A@c\")\nassert(solve(s: \"#AsdfW^45\"\
    ) == \"#aSDFw^45\")\nassert(solve(s: \"#6@2\") == \"2@6#\")\nassert(solve(s: \"\
    #$a^D\") == \"#$A^d\")\nassert(solve(s: \"#ccc\") == \"#CCC\")"
  status: SyntaxError
  stderr: "/tmp/tmp60f2nb2v.swift:15:33: error: cannot find 'CharacterSet' in scope\n\
    \    if s.rangeOfCharacter(from: CharacterSet.letters) == nil {\n            \
    \                    ^~~~~~~~~~~~\n/tmp/tmp60f2nb2v.swift:15:10: error: value\
    \ of type 'String' has no member 'rangeOfCharacter'\n    if s.rangeOfCharacter(from:\
    \ CharacterSet.letters) == nil {\n       ~ ^~~~~~~~~~~~~~~~\n/tmp/tmp60f2nb2v.swift:20:23:\
    \ error: cannot find 'CharacterSet' in scope\n        let charSet = CharacterSet.init(charactersIn:\
    \ c.lowercased())\n                      ^~~~~~~~~~~~\n/tmp/tmp60f2nb2v.swift:21:33:\
    \ error: cannot find 'CharacterSet' in scope\n        if charSet.isSubset(of:\
    \ CharacterSet.letters) {\n                                ^~~~~~~~~~~~\n/tmp/tmp60f2nb2v.swift:22:39:\
    \ error: binary operator '==' cannot be applied to operands of type 'String' and\
    \ 'Character'\n            result += (c.lowercased() == c) ? c.uppercased() :\
    \ c.lowercased()\n                       ~~~~~~~~~~~~~~ ^  ~\n/tmp/tmp60f2nb2v.swift:22:39:\
    \ note: overloads for '==' exist with these partially matching parameter lists:\
    \ (Character, Character), (String, String)\n            result += (c.lowercased()\
    \ == c) ? c.uppercased() : c.lowercased()\n                                  \
    \    ^\n"
  stdout: ''
  timestamp: 1659978812
- exit_code: 1
  program: "\n/// You are given a string s.\n/// if s[i] is a letter, reverse its\
    \ case from lower to upper or vise versa, \n/// otherwise keep it as it is.\n\
    /// If the string contains no letters, reverse the string.\n/// The function should\
    \ return the resulted string.\n/// Examples\n/// >>> solve(s: \"1234\")\n/// \"\
    4321\"\n/// >>> solve(s: \"ab\")\n/// \"AB\"\n/// >>> solve(s: \"#a@C\")\n///\
    \ \"#A@c\"\nfunc solve(s: String) -> String {\n    if s.rangeOfCharacter(from:\
    \ CharacterSet.letters) == nil {\n        return String(s.reversed())\n    }\n\
    \    var res = \"\"\n    for char in s {\n        if char.isLetter {\n       \
    \     if char.isUppercase {\n                res.append(char.lowercased())\n \
    \           } else {\n                res.append(char.uppercased())\n        \
    \    }\n        } else {\n            res.append(char)\n        }\n    }\n   \
    \ return res\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool\
    \ {\n    if left.count != right.count {\n        return false\n    }\n    for\
    \ (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(solve(s: \"AsDf\"\
    ) == \"aSdF\")\nassert(solve(s: \"1234\") == \"4321\")\nassert(solve(s: \"ab\"\
    ) == \"AB\")\nassert(solve(s: \"#a@C\") == \"#A@c\")\nassert(solve(s: \"#AsdfW^45\"\
    ) == \"#aSDFw^45\")\nassert(solve(s: \"#6@2\") == \"2@6#\")\nassert(solve(s: \"\
    #$a^D\") == \"#$A^d\")\nassert(solve(s: \"#ccc\") == \"#CCC\")"
  status: SyntaxError
  stderr: "/tmp/tmpa24swaa0.swift:15:33: error: cannot find 'CharacterSet' in scope\n\
    \    if s.rangeOfCharacter(from: CharacterSet.letters) == nil {\n            \
    \                    ^~~~~~~~~~~~\n/tmp/tmpa24swaa0.swift:15:10: error: value\
    \ of type 'String' has no member 'rangeOfCharacter'\n    if s.rangeOfCharacter(from:\
    \ CharacterSet.letters) == nil {\n       ~ ^~~~~~~~~~~~~~~~\n"
  stdout: ''
  timestamp: 1659978812
- exit_code: -4
  program: "\n/// You are given a string s.\n/// if s[i] is a letter, reverse its\
    \ case from lower to upper or vise versa, \n/// otherwise keep it as it is.\n\
    /// If the string contains no letters, reverse the string.\n/// The function should\
    \ return the resulted string.\n/// Examples\n/// >>> solve(s: \"1234\")\n/// \"\
    4321\"\n/// >>> solve(s: \"ab\")\n/// \"AB\"\n/// >>> solve(s: \"#a@C\")\n///\
    \ \"#A@c\"\nfunc solve(s: String) -> String {\n    if s.lowercased() == s {\n\
    \        return s.uppercased()\n    } else if s.uppercased() == s {\n        return\
    \ s.lowercased()\n    } else {\n        var rev = \"\"\n        for char in s\
    \ {\n            if char.isLowercase {\n                rev += String(char).uppercased()\n\
    \            } else if char.isUppercase {\n                rev += String(char).lowercased()\n\
    \            } else {\n                rev += String(char)\n            }\n  \
    \      }\n        return rev\n    }\n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(solve(s: \"AsDf\") == \"aSdF\")\nassert(solve(s: \"1234\") == \"4321\"\
    )\nassert(solve(s: \"ab\") == \"AB\")\nassert(solve(s: \"#a@C\") == \"#A@c\")\n\
    assert(solve(s: \"#AsdfW^45\") == \"#aSDFw^45\")\nassert(solve(s: \"#6@2\") ==\
    \ \"2@6#\")\nassert(solve(s: \"#$a^D\") == \"#$A^d\")\nassert(solve(s: \"#ccc\"\
    ) == \"#CCC\")"
  status: Exception
  stderr: 'tmp5uvaidpq/tmp5uvaidpq.swift:48: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b0bf4b26c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b0bf481db6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b0bf481d988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b0bf481c7b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmp5uvaidpq                        0x000055646c5fd6b7 <unavailable> + 5815

    5    libc.so.6                          0x00002b0bf4d12460 __libc_start_main +
    245

    6    tmp5uvaidpq                        0x000055646c5fd209 <unavailable> + 4617

    '
  stdout: ''
  timestamp: 1659978812
- exit_code: 1
  program: "\n/// You are given a string s.\n/// if s[i] is a letter, reverse its\
    \ case from lower to upper or vise versa, \n/// otherwise keep it as it is.\n\
    /// If the string contains no letters, reverse the string.\n/// The function should\
    \ return the resulted string.\n/// Examples\n/// >>> solve(s: \"1234\")\n/// \"\
    4321\"\n/// >>> solve(s: \"ab\")\n/// \"AB\"\n/// >>> solve(s: \"#a@C\")\n///\
    \ \"#A@c\"\nfunc solve(s: String) -> String {\n    var result = \"\"\n    if !s.contains(\"\
    a\"...\"z\") && !s.contains(\"A\"...\"Z\") {\n        for (index, element) in\
    \ s.reversed().enumerated() {\n            result.append(element)\n        }\n\
    \    } else {\n        for (index, element) in s.enumerated() {\n            if\
    \ element.isLetter {\n                if element.isLowercase {\n             \
    \       result.append(element.uppercased())\n                } else {\n      \
    \              result.append(element.lowercased())\n                }\n      \
    \      } else {\n                result.append(element)\n            }\n     \
    \   }\n    }\n    return result\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int,\
    \ Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n\
    \    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n          \
    \  return false\n        }\n    }\n    return true\n}\n            \nassert(solve(s:\
    \ \"AsDf\") == \"aSdF\")\nassert(solve(s: \"1234\") == \"4321\")\nassert(solve(s:\
    \ \"ab\") == \"AB\")\nassert(solve(s: \"#a@C\") == \"#A@c\")\nassert(solve(s:\
    \ \"#AsdfW^45\") == \"#aSDFw^45\")\nassert(solve(s: \"#6@2\") == \"2@6#\")\nassert(solve(s:\
    \ \"#$a^D\") == \"#$A^d\")\nassert(solve(s: \"#ccc\") == \"#CCC\")"
  status: SyntaxError
  stderr: "/tmp/tmp9xt1jhkf.swift:16:23: error: cannot convert value of type 'ClosedRange<String>'\
    \ to expected argument type 'String.Element' (aka 'Character')\n    if !s.contains(\"\
    a\"...\"z\") && !s.contains(\"A\"...\"Z\") {\n                      ^\n/tmp/tmp9xt1jhkf.swift:16:49:\
    \ error: cannot convert value of type 'ClosedRange<String>' to expected argument\
    \ type 'String.Element' (aka 'Character')\n    if !s.contains(\"a\"...\"z\") &&\
    \ !s.contains(\"A\"...\"Z\") {\n                                             \
    \   ^\n"
  stdout: ''
  timestamp: 1659978812
- exit_code: 0
  program: "\n/// You are given a string s.\n/// if s[i] is a letter, reverse its\
    \ case from lower to upper or vise versa, \n/// otherwise keep it as it is.\n\
    /// If the string contains no letters, reverse the string.\n/// The function should\
    \ return the resulted string.\n/// Examples\n/// >>> solve(s: \"1234\")\n/// \"\
    4321\"\n/// >>> solve(s: \"ab\")\n/// \"AB\"\n/// >>> solve(s: \"#a@C\")\n///\
    \ \"#A@c\"\nfunc solve(s: String) -> String {\n    var result = \"\"\n    var\
    \ hasLetter = false\n    for c in s {\n        if c.isLetter {\n            hasLetter\
    \ = true\n            result.append(c.isLowercase ? c.uppercased() : c.lowercased())\n\
    \        } else {\n            result.append(c)\n        }\n    }\n    return\
    \ hasLetter ? result : String(result.reversed())\n}\n\n\nfunc ==(left: [(Int,\
    \ Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n\
    \        return false\n    }\n    for (l, r) in zip(left, right) {\n        if\
    \ l != r {\n            return false\n        }\n    }\n    return true\n}\n \
    \           \nassert(solve(s: \"AsDf\") == \"aSdF\")\nassert(solve(s: \"1234\"\
    ) == \"4321\")\nassert(solve(s: \"ab\") == \"AB\")\nassert(solve(s: \"#a@C\")\
    \ == \"#A@c\")\nassert(solve(s: \"#AsdfW^45\") == \"#aSDFw^45\")\nassert(solve(s:\
    \ \"#6@2\") == \"2@6#\")\nassert(solve(s: \"#$a^D\") == \"#$A^d\")\nassert(solve(s:\
    \ \"#ccc\") == \"#CCC\")"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659978812
- exit_code: -4
  program: "\n/// You are given a string s.\n/// if s[i] is a letter, reverse its\
    \ case from lower to upper or vise versa, \n/// otherwise keep it as it is.\n\
    /// If the string contains no letters, reverse the string.\n/// The function should\
    \ return the resulted string.\n/// Examples\n/// >>> solve(s: \"1234\")\n/// \"\
    4321\"\n/// >>> solve(s: \"ab\")\n/// \"AB\"\n/// >>> solve(s: \"#a@C\")\n///\
    \ \"#A@c\"\nfunc solve(s: String) -> String {\n    var res = String()\n    var\
    \ rev = String()\n    var revs = String()\n    for i in s {\n        if i.isLetter\
    \ {\n            if i.isLowercase {\n                res += String(i).uppercased()\n\
    \            } else {\n                res += String(i).lowercased()\n       \
    \     }\n        } else {\n            res += String(i)\n        }\n    }\n  \
    \  if res.isEmpty {\n        for i in s {\n            rev = String(i) + rev\n\
    \        }\n        return rev\n    }\n    for i in res {\n        revs = String(i)\
    \ + revs\n    }\n    return revs\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int,\
    \ Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n\
    \    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n          \
    \  return false\n        }\n    }\n    return true\n}\n            \nassert(solve(s:\
    \ \"AsDf\") == \"aSdF\")\nassert(solve(s: \"1234\") == \"4321\")\nassert(solve(s:\
    \ \"ab\") == \"AB\")\nassert(solve(s: \"#a@C\") == \"#A@c\")\nassert(solve(s:\
    \ \"#AsdfW^45\") == \"#aSDFw^45\")\nassert(solve(s: \"#6@2\") == \"2@6#\")\nassert(solve(s:\
    \ \"#$a^D\") == \"#$A^d\")\nassert(solve(s: \"#ccc\") == \"#CCC\")"
  status: Exception
  stderr: 'tmpxxbpvh5m/tmpxxbpvh5m.swift:54: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b87689edc80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b87686e4b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b87686e4988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b87686e37b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpxxbpvh5m                        0x00005590f5d416a7 <unavailable> + 5799

    5    libc.so.6                          0x00002b8768bd9460 __libc_start_main +
    245

    6    tmpxxbpvh5m                        0x00005590f5d412e9 <unavailable> + 4841

    '
  stdout: ''
  timestamp: 1659978812
- exit_code: 1
  program: "\n/// You are given a string s.\n/// if s[i] is a letter, reverse its\
    \ case from lower to upper or vise versa, \n/// otherwise keep it as it is.\n\
    /// If the string contains no letters, reverse the string.\n/// The function should\
    \ return the resulted string.\n/// Examples\n/// >>> solve(s: \"1234\")\n/// \"\
    4321\"\n/// >>> solve(s: \"ab\")\n/// \"AB\"\n/// >>> solve(s: \"#a@C\")\n///\
    \ \"#A@c\"\nfunc solve(s: String) -> String {\n    var s = s\n    var letters\
    \ = [Character]()\n    for c in s {\n        if c.isLetter {\n            letters.append(c)\n\
    \        }\n    }\n    if letters.isEmpty {\n        return String(s.reversed())\n\
    \    }\n    var reversed = letters.reversed()\n    var idx = 0\n    for i in 0..<s.count\
    \ {\n        let c = s[s.index(s.startIndex, offsetBy: i)]\n        if c.isLetter\
    \ {\n            s.replaceSubrange(s.index(s.startIndex, offsetBy: i)...s.index(s.startIndex,\
    \ offsetBy: i), with: \"\\(reversed[idx])\")\n            idx += 1\n        }\n\
    \    }\n    return s\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(solve(s: \"\
    AsDf\") == \"aSdF\")\nassert(solve(s: \"1234\") == \"4321\")\nassert(solve(s:\
    \ \"ab\") == \"AB\")\nassert(solve(s: \"#a@C\") == \"#A@c\")\nassert(solve(s:\
    \ \"#AsdfW^45\") == \"#aSDFw^45\")\nassert(solve(s: \"#6@2\") == \"2@6#\")\nassert(solve(s:\
    \ \"#$a^D\") == \"#$A^d\")\nassert(solve(s: \"#ccc\") == \"#CCC\")"
  status: SyntaxError
  stderr: "/tmp/tmp7lzelubx.swift:30:121: error: no exact matches in call to subscript\
    \ \n            s.replaceSubrange(s.index(s.startIndex, offsetBy: i)...s.index(s.startIndex,\
    \ offsetBy: i), with: \"\\(reversed[idx])\")\n                               \
    \                                                                            \
    \             ^\nSwift.ReversedCollection:9:23: note: candidate expects value\
    \ of type 'ReversedCollection<[Character]>.Index' for parameter #1 (got 'Int')\n\
    \    @inlinable public subscript(position: ReversedCollection<Base>.Index) ->\
    \ ReversedCollection<Base>.Element { get }\n                      ^\nSwift.Collection:2:23:\
    \ note: candidate expects value of type 'Range<ReversedCollection<[Character]>.Index>'\
    \ for parameter #1 (got 'Int')\n    @inlinable public subscript(bounds: Range<Self.Index>)\
    \ -> Slice<Self> { get }\n                      ^\nSwift.Collection:3:23: note:\
    \ candidate expects value of type '(UnboundedRange_) -> ()' for parameter #1 (got\
    \ 'Int')\n    @inlinable public subscript(x: (UnboundedRange_) -> ()) -> Self.SubSequence\
    \ { get }\n                      ^\n"
  stdout: ''
  timestamp: 1659978812
- exit_code: 1
  program: "\n/// You are given a string s.\n/// if s[i] is a letter, reverse its\
    \ case from lower to upper or vise versa, \n/// otherwise keep it as it is.\n\
    /// If the string contains no letters, reverse the string.\n/// The function should\
    \ return the resulted string.\n/// Examples\n/// >>> solve(s: \"1234\")\n/// \"\
    4321\"\n/// >>> solve(s: \"ab\")\n/// \"AB\"\n/// >>> solve(s: \"#a@C\")\n///\
    \ \"#A@c\"\nfunc solve(s: String) -> String {\n    var arr = [Character]()\n \
    \   var s = s\n    if s.containsAlphabets(){\n        for i in s.indices{\n  \
    \          if s[i].isLetter {\n                arr.append(s[i].isUppercase ? s[i].lowercased()\
    \ : s[i].uppercased())\n            }else{\n                arr.append(s[i])\n\
    \            }\n        }\n        return String(arr)\n    }else{\n        return\
    \ String(s.reversed())\n    }\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int,\
    \ Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n\
    \    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n          \
    \  return false\n        }\n    }\n    return true\n}\n            \nassert(solve(s:\
    \ \"AsDf\") == \"aSdF\")\nassert(solve(s: \"1234\") == \"4321\")\nassert(solve(s:\
    \ \"ab\") == \"AB\")\nassert(solve(s: \"#a@C\") == \"#A@c\")\nassert(solve(s:\
    \ \"#AsdfW^45\") == \"#aSDFw^45\")\nassert(solve(s: \"#6@2\") == \"2@6#\")\nassert(solve(s:\
    \ \"#$a^D\") == \"#$A^d\")\nassert(solve(s: \"#ccc\") == \"#CCC\")"
  status: SyntaxError
  stderr: "/tmp/tmptk6088t4.swift:17:10: error: value of type 'String' has no member\
    \ 'containsAlphabets'\n    if s.containsAlphabets(){\n       ~ ^~~~~~~~~~~~~~~~~\n\
    /tmp/tmptk6088t4.swift:20:28: error: missing argument label 'contentsOf:' in call\n\
    \                arr.append(s[i].isUppercase ? s[i].lowercased() : s[i].uppercased())\n\
    \                           ^\n                           contentsOf: \n"
  stdout: ''
  timestamp: 1659978812
- exit_code: 1
  program: "\n/// You are given a string s.\n/// if s[i] is a letter, reverse its\
    \ case from lower to upper or vise versa, \n/// otherwise keep it as it is.\n\
    /// If the string contains no letters, reverse the string.\n/// The function should\
    \ return the resulted string.\n/// Examples\n/// >>> solve(s: \"1234\")\n/// \"\
    4321\"\n/// >>> solve(s: \"ab\")\n/// \"AB\"\n/// >>> solve(s: \"#a@C\")\n///\
    \ \"#A@c\"\nfunc solve(s: String) -> String {\n    let lower = CharacterSet.lowercaseLetters\n\
    \    let upper = CharacterSet.uppercaseLetters\n    var s = s\n    for i in s.indices\
    \ {\n        if lower.contains(s[i].unicodeScalars.first!) {\n            s.replaceSubrange(i...i,\
    \ with: String(s[i]).uppercased())\n        } else if upper.contains(s[i].unicodeScalars.first!)\
    \ {\n            s.replaceSubrange(i...i, with: String(s[i]).lowercased())\n \
    \       }\n    }\n    return s\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int,\
    \ Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n\
    \    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n          \
    \  return false\n        }\n    }\n    return true\n}\n            \nassert(solve(s:\
    \ \"AsDf\") == \"aSdF\")\nassert(solve(s: \"1234\") == \"4321\")\nassert(solve(s:\
    \ \"ab\") == \"AB\")\nassert(solve(s: \"#a@C\") == \"#A@c\")\nassert(solve(s:\
    \ \"#AsdfW^45\") == \"#aSDFw^45\")\nassert(solve(s: \"#6@2\") == \"2@6#\")\nassert(solve(s:\
    \ \"#$a^D\") == \"#$A^d\")\nassert(solve(s: \"#ccc\") == \"#CCC\")"
  status: SyntaxError
  stderr: "/tmp/tmpxaodkxsf.swift:15:17: error: cannot find 'CharacterSet' in scope\n\
    \    let lower = CharacterSet.lowercaseLetters\n                ^~~~~~~~~~~~\n\
    /tmp/tmpxaodkxsf.swift:16:17: error: cannot find 'CharacterSet' in scope\n   \
    \ let upper = CharacterSet.uppercaseLetters\n                ^~~~~~~~~~~~\n"
  stdout: ''
  timestamp: 1659978812
- exit_code: -4
  program: "\n/// You are given a string s.\n/// if s[i] is a letter, reverse its\
    \ case from lower to upper or vise versa, \n/// otherwise keep it as it is.\n\
    /// If the string contains no letters, reverse the string.\n/// The function should\
    \ return the resulted string.\n/// Examples\n/// >>> solve(s: \"1234\")\n/// \"\
    4321\"\n/// >>> solve(s: \"ab\")\n/// \"AB\"\n/// >>> solve(s: \"#a@C\")\n///\
    \ \"#A@c\"\nfunc solve(s: String) -> String {\n  var result = \"\"\n  let s =\
    \ Array(s)\n  for char in s {\n    if char.isLetter {\n      result.append(char.isUppercase\
    \ ? char.lowercased() : char.uppercased())\n    } else {\n      result.append(char)\n\
    \    }\n  }\n  return result.isEmpty ? String(s.reversed()) : result\n}\n\n\n\
    func ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(solve(s: \"AsDf\") == \"aSdF\")\nassert(solve(s:\
    \ \"1234\") == \"4321\")\nassert(solve(s: \"ab\") == \"AB\")\nassert(solve(s:\
    \ \"#a@C\") == \"#A@c\")\nassert(solve(s: \"#AsdfW^45\") == \"#aSDFw^45\")\nassert(solve(s:\
    \ \"#6@2\") == \"2@6#\")\nassert(solve(s: \"#$a^D\") == \"#$A^d\")\nassert(solve(s:\
    \ \"#ccc\") == \"#CCC\")"
  status: Exception
  stderr: 'tmpsux2d9z9/tmpsux2d9z9.swift:41: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b22e1088c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b22e0d7fb6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b22e0d7f988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b22e0d7e7b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpsux2d9z9                        0x0000559b9dad5a97 <unavailable> + 6807

    5    libc.so.6                          0x00002b22e1274460 __libc_start_main +
    245

    6    tmpsux2d9z9                        0x0000559b9dad55e9 <unavailable> + 5609

    '
  stdout: ''
  timestamp: 1659978812
- exit_code: -4
  program: "\n/// You are given a string s.\n/// if s[i] is a letter, reverse its\
    \ case from lower to upper or vise versa, \n/// otherwise keep it as it is.\n\
    /// If the string contains no letters, reverse the string.\n/// The function should\
    \ return the resulted string.\n/// Examples\n/// >>> solve(s: \"1234\")\n/// \"\
    4321\"\n/// >>> solve(s: \"ab\")\n/// \"AB\"\n/// >>> solve(s: \"#a@C\")\n///\
    \ \"#A@c\"\nfunc solve(s: String) -> String {\n    var res = \"\"\n    for item\
    \ in s {\n        if item.isLetter {\n            if item.isLowercase {\n    \
    \            res.append(item.uppercased())\n            } else {\n           \
    \     res.append(item.lowercased())\n            }\n        } else {\n       \
    \     res.append(item)\n        }\n    }\n    if res.isEmpty {\n        return\
    \ String(s.reversed())\n    }\n    return res\n}\n\n\nfunc ==(left: [(Int, Int)],\
    \ right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n       \
    \ return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r\
    \ {\n            return false\n        }\n    }\n    return true\n}\n        \
    \    \nassert(solve(s: \"AsDf\") == \"aSdF\")\nassert(solve(s: \"1234\") == \"\
    4321\")\nassert(solve(s: \"ab\") == \"AB\")\nassert(solve(s: \"#a@C\") == \"#A@c\"\
    )\nassert(solve(s: \"#AsdfW^45\") == \"#aSDFw^45\")\nassert(solve(s: \"#6@2\"\
    ) == \"2@6#\")\nassert(solve(s: \"#$a^D\") == \"#$A^d\")\nassert(solve(s: \"#ccc\"\
    ) == \"#CCC\")"
  status: Exception
  stderr: 'tmpb87zl6ky/tmpb87zl6ky.swift:47: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b9042f8ec80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b9042c85b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b9042c85988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b9042c847b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpb87zl6ky                        0x0000556cf942e8d7 <unavailable> + 6359

    5    libc.so.6                          0x00002b904317a460 __libc_start_main +
    245

    6    tmpb87zl6ky                        0x0000556cf942e429 <unavailable> + 5161

    '
  stdout: ''
  timestamp: 1659978812
- exit_code: 1
  program: "\n/// You are given a string s.\n/// if s[i] is a letter, reverse its\
    \ case from lower to upper or vise versa, \n/// otherwise keep it as it is.\n\
    /// If the string contains no letters, reverse the string.\n/// The function should\
    \ return the resulted string.\n/// Examples\n/// >>> solve(s: \"1234\")\n/// \"\
    4321\"\n/// >>> solve(s: \"ab\")\n/// \"AB\"\n/// >>> solve(s: \"#a@C\")\n///\
    \ \"#A@c\"\nfunc solve(s: String) -> String {\n    return s.allSatisfy({ $0.isLetter\
    \ }) ? String(s.reversed()) : s.map({ $0.isLetter ? $0.isUppercase ? Character($0.lowercased())\
    \ : Character($0.uppercased()) : $0 }).joined()\n}\n\n\nfunc ==(left: [(Int, Int)],\
    \ right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n       \
    \ return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r\
    \ {\n            return false\n        }\n    }\n    return true\n}\n        \
    \    \nassert(solve(s: \"AsDf\") == \"aSdF\")\nassert(solve(s: \"1234\") == \"\
    4321\")\nassert(solve(s: \"ab\") == \"AB\")\nassert(solve(s: \"#a@C\") == \"#A@c\"\
    )\nassert(solve(s: \"#AsdfW^45\") == \"#aSDFw^45\")\nassert(solve(s: \"#6@2\"\
    ) == \"2@6#\")\nassert(solve(s: \"#$a^D\") == \"#$A^d\")\nassert(solve(s: \"#ccc\"\
    ) == \"#CCC\")"
  status: SyntaxError
  stderr: "/tmp/tmpf66v3ha8.swift:15:87: error: cannot convert value of type 'String.Element'\
    \ (aka 'Character') to closure result type 'String'\n    return s.allSatisfy({\
    \ $0.isLetter }) ? String(s.reversed()) : s.map({ $0.isLetter ? $0.isUppercase\
    \ ? Character($0.lowercased()) : Character($0.uppercased()) : $0 }).joined()\n\
    \                                                                          ~~~~~~~~~~~~^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n"
  stdout: ''
  timestamp: 1659978812
- exit_code: 1
  program: "\n/// You are given a string s.\n/// if s[i] is a letter, reverse its\
    \ case from lower to upper or vise versa, \n/// otherwise keep it as it is.\n\
    /// If the string contains no letters, reverse the string.\n/// The function should\
    \ return the resulted string.\n/// Examples\n/// >>> solve(s: \"1234\")\n/// \"\
    4321\"\n/// >>> solve(s: \"ab\")\n/// \"AB\"\n/// >>> solve(s: \"#a@C\")\n///\
    \ \"#A@c\"\nfunc solve(s: String) -> String {\n    let isUpper = { \"A\"...\"\
    Z\" ~= $0 }\n    let isLower = { \"a\"...\"z\" ~= $0 }\n    let hasLetters = s.contains(where:\
    \ isUpper) || s.contains(where: isLower)\n    let chars = s.map { isUpper($0)\
    \ ? Character($0.lowercased()) : isLower($0) ? Character($0.uppercased()) : $0\
    \ }\n    return hasLetters ? String(chars) : String(chars.reversed())\n}\n\n\n\
    func ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(solve(s: \"AsDf\") == \"aSdF\")\nassert(solve(s:\
    \ \"1234\") == \"4321\")\nassert(solve(s: \"ab\") == \"AB\")\nassert(solve(s:\
    \ \"#a@C\") == \"#A@c\")\nassert(solve(s: \"#AsdfW^45\") == \"#aSDFw^45\")\nassert(solve(s:\
    \ \"#6@2\") == \"2@6#\")\nassert(solve(s: \"#$a^D\") == \"#$A^d\")\nassert(solve(s:\
    \ \"#ccc\") == \"#CCC\")"
  status: SyntaxError
  stderr: "/tmp/tmptzk7fbyz.swift:17:40: error: cannot convert value of type '(String)\
    \ -> Bool' to expected argument type '(String.Element) throws -> Bool' (aka '(Character)\
    \ throws -> Bool')\n    let hasLetters = s.contains(where: isUpper) || s.contains(where:\
    \ isLower)\n                                       ^\n/tmp/tmptzk7fbyz.swift:17:70:\
    \ error: cannot convert value of type '(String) -> Bool' to expected argument\
    \ type '(String.Element) throws -> Bool' (aka '(Character) throws -> Bool')\n\
    \    let hasLetters = s.contains(where: isUpper) || s.contains(where: isLower)\n\
    \                                                                     ^\n/tmp/tmptzk7fbyz.swift:18:33:\
    \ error: cannot convert value of type 'String.Element' (aka 'Character') to expected\
    \ argument type 'String'\n    let chars = s.map { isUpper($0) ? Character($0.lowercased())\
    \ : isLower($0) ? Character($0.uppercased()) : $0 }\n                        \
    \        ^\n/tmp/tmptzk7fbyz.swift:18:76: error: cannot convert value of type\
    \ 'String.Element' (aka 'Character') to expected argument type 'String'\n    let\
    \ chars = s.map { isUpper($0) ? Character($0.lowercased()) : isLower($0) ? Character($0.uppercased())\
    \ : $0 }\n                                                                   \
    \        ^\n"
  stdout: ''
  timestamp: 1659978812
- exit_code: 1
  program: "\n/// You are given a string s.\n/// if s[i] is a letter, reverse its\
    \ case from lower to upper or vise versa, \n/// otherwise keep it as it is.\n\
    /// If the string contains no letters, reverse the string.\n/// The function should\
    \ return the resulted string.\n/// Examples\n/// >>> solve(s: \"1234\")\n/// \"\
    4321\"\n/// >>> solve(s: \"ab\")\n/// \"AB\"\n/// >>> solve(s: \"#a@C\")\n///\
    \ \"#A@c\"\nfunc solve(s: String) -> String {\n  // Write your code here.\n  //\
    \ I assume that the input string contains only numbers, letters and symbols.\n\
    \  // I assume that the symbols are not letters.\n  // I assume that the returned\
    \ string should not contain any symbols.\n  // I assume that the returned string\
    \ should contain only numbers and/or letters.\n  // I assume that the returned\
    \ string should not contain any spaces.\n  // I assume that the returned string\
    \ should not contain any symbols.\n  // I assume that the returned string should\
    \ not contain any numbers.\n  // I assume that the returned string should be in\
    \ the same order as the input string.\n  // I assume that the case of the returned\
    \ string is the same as the case of the input string.\n  let letters: [Character]\
    \ = [\"a\", \"b\", \"c\", \"d\", \"e\", \"f\", \"g\", \"h\", \"i\", \"j\", \"\
    k\", \"l\", \"m\", \"n\", \"o\", \"p\", \"q\", \"r\", \"s\", \"t\", \"u\", \"\
    v\", \"w\", \"x\", \"y\", \"z\"]\n  let uppercaseLetters: [Character] = [\"A\"\
    , \"B\", \"C\", \"D\", \"E\", \"F\", \"G\", \"H\", \"I\", \"J\", \"K\", \"L\"\
    , \"M\", \"N\", \"O\", \"P\", \"Q\", \"R\", \"S\", \"T\", \"U\", \"V\", \"W\"\
    , \"X\", \"Y\", \"Z\"]\n  let reverseLetters: [Character] = [\"z\", \"y\", \"\
    x\", \"w\", \"v\", \"u\", \"t\", \"s\", \"r\", \"q\", \"p\", \"o\", \"n\", \"\
    m\", \"l\", \"k\", \"j\", \"i\", \"h\", \"g\", \"f\", \"e\", \"d\", \"c\", \"\
    b\", \"a\"]\n  let reverseUppercaseLetters: [Character] = [\"Z\", \"Y\", \"X\"\
    , \"W\", \"V\", \"U\", \"T\", \"S\", \"R\", \"Q\", \"P\", \"O\", \"N\", \"M\"\
    , \"L\", \"K\", \"J\", \"I\", \"H\", \"G\", \"F\", \"E\", \"D\", \"C\", \"\n}\n\
    \n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(solve(s: \"AsDf\") == \"aSdF\")\nassert(solve(s:\
    \ \"1234\") == \"4321\")\nassert(solve(s: \"ab\") == \"AB\")\nassert(solve(s:\
    \ \"#a@C\") == \"#A@c\")\nassert(solve(s: \"#AsdfW^45\") == \"#aSDFw^45\")\nassert(solve(s:\
    \ \"#6@2\") == \"2@6#\")\nassert(solve(s: \"#$a^D\") == \"#$A^d\")\nassert(solve(s:\
    \ \"#ccc\") == \"#CCC\")"
  status: SyntaxError
  stderr: "/tmp/tmpwqlh5et3.swift:28:167: error: unterminated string literal\n  let\
    \ reverseUppercaseLetters: [Character] = [\"Z\", \"Y\", \"X\", \"W\", \"V\", \"\
    U\", \"T\", \"S\", \"R\", \"Q\", \"P\", \"O\", \"N\", \"M\", \"L\", \"K\", \"\
    J\", \"I\", \"H\", \"G\", \"F\", \"E\", \"D\", \"C\", \"\n                   \
    \                                                                            \
    \                                                                       ^\n/tmp/tmpwqlh5et3.swift:25:7:\
    \ warning: immutable value 'letters' was never used; consider replacing with '_'\
    \ or removing it\n  let letters: [Character] = [\"a\", \"b\", \"c\", \"d\", \"\
    e\", \"f\", \"g\", \"h\", \"i\", \"j\", \"k\", \"l\", \"m\", \"n\", \"o\", \"\
    p\", \"q\", \"r\", \"s\", \"t\", \"u\", \"v\", \"w\", \"x\", \"y\", \"z\"]\n \
    \     ^~~~~~~\n      _\n/tmp/tmpwqlh5et3.swift:26:7: warning: immutable value\
    \ 'uppercaseLetters' was never used; consider replacing with '_' or removing it\n\
    \  let uppercaseLetters: [Character] = [\"A\", \"B\", \"C\", \"D\", \"E\", \"\
    F\", \"G\", \"H\", \"I\", \"J\", \"K\", \"L\", \"M\", \"N\", \"O\", \"P\", \"\
    Q\", \"R\", \"S\", \"T\", \"U\", \"V\", \"W\", \"X\", \"Y\", \"Z\"]\n      ^~~~~~~~~~~~~~~~\n\
    \      _\n/tmp/tmpwqlh5et3.swift:27:7: warning: immutable value 'reverseLetters'\
    \ was never used; consider replacing with '_' or removing it\n  let reverseLetters:\
    \ [Character] = [\"z\", \"y\", \"x\", \"w\", \"v\", \"u\", \"t\", \"s\", \"r\"\
    , \"q\", \"p\", \"o\", \"n\", \"m\", \"l\", \"k\", \"j\", \"i\", \"h\", \"g\"\
    , \"f\", \"e\", \"d\", \"c\", \"b\", \"a\"]\n      ^~~~~~~~~~~~~~\n      _\n/tmp/tmpwqlh5et3.swift:28:7:\
    \ warning: immutable value 'reverseUppercaseLetters' was never used; consider\
    \ replacing with '_' or removing it\n  let reverseUppercaseLetters: [Character]\
    \ = [\"Z\", \"Y\", \"X\", \"W\", \"V\", \"U\", \"T\", \"S\", \"R\", \"Q\", \"\
    P\", \"O\", \"N\", \"M\", \"L\", \"K\", \"J\", \"I\", \"H\", \"G\", \"F\", \"\
    E\", \"D\", \"C\", \"\n      ^~~~~~~~~~~~~~~~~~~~~~~\n      _\n"
  stdout: ''
  timestamp: 1659978812
- exit_code: 0
  program: "\n/// You are given a string s.\n/// if s[i] is a letter, reverse its\
    \ case from lower to upper or vise versa, \n/// otherwise keep it as it is.\n\
    /// If the string contains no letters, reverse the string.\n/// The function should\
    \ return the resulted string.\n/// Examples\n/// >>> solve(s: \"1234\")\n/// \"\
    4321\"\n/// >>> solve(s: \"ab\")\n/// \"AB\"\n/// >>> solve(s: \"#a@C\")\n///\
    \ \"#A@c\"\nfunc solve(s: String) -> String {\n    guard s.contains(where: { $0.isLetter\
    \ }) else {\n        return String(s.reversed())\n    }\n    var res = String()\n\
    \    for char in s {\n        if char.isLetter {\n            res.append(char.isUppercase\
    \ ? char.lowercased() : char.uppercased())\n        } else {\n            res.append(char)\n\
    \        }\n    }\n    return res\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int,\
    \ Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n\
    \    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n          \
    \  return false\n        }\n    }\n    return true\n}\n            \nassert(solve(s:\
    \ \"AsDf\") == \"aSdF\")\nassert(solve(s: \"1234\") == \"4321\")\nassert(solve(s:\
    \ \"ab\") == \"AB\")\nassert(solve(s: \"#a@C\") == \"#A@c\")\nassert(solve(s:\
    \ \"#AsdfW^45\") == \"#aSDFw^45\")\nassert(solve(s: \"#6@2\") == \"2@6#\")\nassert(solve(s:\
    \ \"#$a^D\") == \"#$A^d\")\nassert(solve(s: \"#ccc\") == \"#CCC\")"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659978812
- exit_code: 1
  program: "\n/// You are given a string s.\n/// if s[i] is a letter, reverse its\
    \ case from lower to upper or vise versa, \n/// otherwise keep it as it is.\n\
    /// If the string contains no letters, reverse the string.\n/// The function should\
    \ return the resulted string.\n/// Examples\n/// >>> solve(s: \"1234\")\n/// \"\
    4321\"\n/// >>> solve(s: \"ab\")\n/// \"AB\"\n/// >>> solve(s: \"#a@C\")\n///\
    \ \"#A@c\"\nfunc solve(s: String) -> String {\n    if !s.containsLetter {\n  \
    \      return String(s.reversed())\n    }\n    var result = \"\"\n    for c in\
    \ s {\n        if c.isLetter {\n            result.append(c.isUppercase ? c.lowercased()\
    \ : c.uppercased())\n        } else {\n            result.append(c)\n        }\n\
    \    }\n    return result\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(solve(s: \"\
    AsDf\") == \"aSdF\")\nassert(solve(s: \"1234\") == \"4321\")\nassert(solve(s:\
    \ \"ab\") == \"AB\")\nassert(solve(s: \"#a@C\") == \"#A@c\")\nassert(solve(s:\
    \ \"#AsdfW^45\") == \"#aSDFw^45\")\nassert(solve(s: \"#6@2\") == \"2@6#\")\nassert(solve(s:\
    \ \"#$a^D\") == \"#$A^d\")\nassert(solve(s: \"#ccc\") == \"#CCC\")"
  status: SyntaxError
  stderr: "/tmp/tmpb60vsytl.swift:15:11: error: value of type 'String' has no member\
    \ 'containsLetter'\n    if !s.containsLetter {\n        ~ ^~~~~~~~~~~~~~\n"
  stdout: ''
  timestamp: 1659978812
- exit_code: 1
  program: "\n/// You are given a string s.\n/// if s[i] is a letter, reverse its\
    \ case from lower to upper or vise versa, \n/// otherwise keep it as it is.\n\
    /// If the string contains no letters, reverse the string.\n/// The function should\
    \ return the resulted string.\n/// Examples\n/// >>> solve(s: \"1234\")\n/// \"\
    4321\"\n/// >>> solve(s: \"ab\")\n/// \"AB\"\n/// >>> solve(s: \"#a@C\")\n///\
    \ \"#A@c\"\nfunc solve(s: String) -> String {\n\treturn s.filter { $0.isLetter\
    \ }.isEmpty ? String(s.reversed()) : s.map { $0.isLetter ? $0.isUppercase ? Character($0.lowercased())\
    \ : Character($0.uppercased()) : $0 }.joined()\n}\n\n\nfunc ==(left: [(Int, Int)],\
    \ right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n       \
    \ return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r\
    \ {\n            return false\n        }\n    }\n    return true\n}\n        \
    \    \nassert(solve(s: \"AsDf\") == \"aSdF\")\nassert(solve(s: \"1234\") == \"\
    4321\")\nassert(solve(s: \"ab\") == \"AB\")\nassert(solve(s: \"#a@C\") == \"#A@c\"\
    )\nassert(solve(s: \"#AsdfW^45\") == \"#aSDFw^45\")\nassert(solve(s: \"#6@2\"\
    ) == \"2@6#\")\nassert(solve(s: \"#$a^D\") == \"#$A^d\")\nassert(solve(s: \"#ccc\"\
    ) == \"#CCC\")"
  status: SyntaxError
  stderr: "/tmp/tmprcvq3ges.swift:15:87: error: cannot convert value of type 'String.Element'\
    \ (aka 'Character') to closure result type 'String'\n        return s.filter {\
    \ $0.isLetter }.isEmpty ? String(s.reversed()) : s.map { $0.isLetter ? $0.isUppercase\
    \ ? Character($0.lowercased()) : Character($0.uppercased()) : $0 }.joined()\n\
    \                                                                            \
    \     ~~~~~~~~~~~~^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n"
  stdout: ''
  timestamp: 1659978812
- exit_code: 1
  program: "\n/// You are given a string s.\n/// if s[i] is a letter, reverse its\
    \ case from lower to upper or vise versa, \n/// otherwise keep it as it is.\n\
    /// If the string contains no letters, reverse the string.\n/// The function should\
    \ return the resulted string.\n/// Examples\n/// >>> solve(s: \"1234\")\n/// \"\
    4321\"\n/// >>> solve(s: \"ab\")\n/// \"AB\"\n/// >>> solve(s: \"#a@C\")\n///\
    \ \"#A@c\"\nfunc solve(s: String) -> String {\n    return s.replacingOccurrences(of:\
    \ \"[a-zA-Z]\", with: \"$0\".uppercased(), options: .regularExpression)\n}\n\n\
    \nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(solve(s: \"AsDf\") == \"aSdF\")\nassert(solve(s:\
    \ \"1234\") == \"4321\")\nassert(solve(s: \"ab\") == \"AB\")\nassert(solve(s:\
    \ \"#a@C\") == \"#A@c\")\nassert(solve(s: \"#AsdfW^45\") == \"#aSDFw^45\")\nassert(solve(s:\
    \ \"#6@2\") == \"2@6#\")\nassert(solve(s: \"#$a^D\") == \"#$A^d\")\nassert(solve(s:\
    \ \"#ccc\") == \"#CCC\")"
  status: SyntaxError
  stderr: "/tmp/tmpe0quv4qi.swift:15:14: error: value of type 'String' has no member\
    \ 'replacingOccurrences'\n    return s.replacingOccurrences(of: \"[a-zA-Z]\",\
    \ with: \"$0\".uppercased(), options: .regularExpression)\n           ~ ^~~~~~~~~~~~~~~~~~~~\n\
    /tmp/tmpe0quv4qi.swift:15:86: error: cannot infer contextual base in reference\
    \ to member 'regularExpression'\n    return s.replacingOccurrences(of: \"[a-zA-Z]\"\
    , with: \"$0\".uppercased(), options: .regularExpression)\n                  \
    \                                                                  ~^~~~~~~~~~~~~~~~~\n"
  stdout: ''
  timestamp: 1659978812
- exit_code: 1
  program: "\n/// You are given a string s.\n/// if s[i] is a letter, reverse its\
    \ case from lower to upper or vise versa, \n/// otherwise keep it as it is.\n\
    /// If the string contains no letters, reverse the string.\n/// The function should\
    \ return the resulted string.\n/// Examples\n/// >>> solve(s: \"1234\")\n/// \"\
    4321\"\n/// >>> solve(s: \"ab\")\n/// \"AB\"\n/// >>> solve(s: \"#a@C\")\n///\
    \ \"#A@c\"\nfunc solve(s: String) -> String {\n    let letters = s.filter { $0.isLetter\
    \ }\n    guard !letters.isEmpty else { return String(s.reversed()) }\n    return\
    \ s.map { $0.isLetter ? $0.toggled() : $0 }\n}\n\n\nfunc ==(left: [(Int, Int)],\
    \ right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n       \
    \ return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r\
    \ {\n            return false\n        }\n    }\n    return true\n}\n        \
    \    \nassert(solve(s: \"AsDf\") == \"aSdF\")\nassert(solve(s: \"1234\") == \"\
    4321\")\nassert(solve(s: \"ab\") == \"AB\")\nassert(solve(s: \"#a@C\") == \"#A@c\"\
    )\nassert(solve(s: \"#AsdfW^45\") == \"#aSDFw^45\")\nassert(solve(s: \"#6@2\"\
    ) == \"2@6#\")\nassert(solve(s: \"#$a^D\") == \"#$A^d\")\nassert(solve(s: \"#ccc\"\
    ) == \"#CCC\")"
  status: SyntaxError
  stderr: "/tmp/tmpn8k4qhju.swift:17:14: error: cannot convert return expression of\
    \ type '[String.Element]' (aka 'Array<Character>') to return type 'String'\n \
    \   return s.map { $0.isLetter ? $0.toggled() : $0 }\n           ~~^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n\
    /tmp/tmpn8k4qhju.swift:17:37: error: value of type 'String.Element' (aka 'Character')\
    \ has no member 'toggled'\n    return s.map { $0.isLetter ? $0.toggled() : $0\
    \ }\n                                 ~~ ^~~~~~~\n"
  stdout: ''
  timestamp: 1659978812
- exit_code: 1
  program: "\n/// You are given a string s.\n/// if s[i] is a letter, reverse its\
    \ case from lower to upper or vise versa, \n/// otherwise keep it as it is.\n\
    /// If the string contains no letters, reverse the string.\n/// The function should\
    \ return the resulted string.\n/// Examples\n/// >>> solve(s: \"1234\")\n/// \"\
    4321\"\n/// >>> solve(s: \"ab\")\n/// \"AB\"\n/// >>> solve(s: \"#a@C\")\n///\
    \ \"#A@c\"\nfunc solve(s: String) -> String {\n  let letters: Set<Character> =\
    \ [\"a\", \"b\", \"c\", \"d\", \"e\", \"f\", \"g\", \"h\", \"i\", \"j\", \"k\"\
    , \"l\", \"m\", \"n\", \"o\", \"p\", \"q\", \"r\", \"s\", \"t\", \"u\", \"v\"\
    , \"w\", \"x\", \"y\", \"z\"]\n  var result = \"\"\n  for letter in s {\n    if\
    \ letters.contains(letter) {\n      if letter.uppercased() == letter {\n     \
    \   result.append(letter.lowercased())\n      } else {\n        result.append(letter.uppercased())\n\
    \      }\n    } else {\n      result.append(letter)\n    }\n  }\n  if result.count\
    \ == 0 {\n    return String(s.reversed())\n  }\n  return result\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(solve(s: \"AsDf\") == \"aSdF\")\nassert(solve(s: \"1234\"\
    ) == \"4321\")\nassert(solve(s: \"ab\") == \"AB\")\nassert(solve(s: \"#a@C\")\
    \ == \"#A@c\")\nassert(solve(s: \"#AsdfW^45\") == \"#aSDFw^45\")\nassert(solve(s:\
    \ \"#6@2\") == \"2@6#\")\nassert(solve(s: \"#$a^D\") == \"#$A^d\")\nassert(solve(s:\
    \ \"#ccc\") == \"#CCC\")"
  status: SyntaxError
  stderr: "/tmp/tmph6sv2d86.swift:19:30: error: binary operator '==' cannot be applied\
    \ to operands of type 'String' and 'Character'\n      if letter.uppercased() ==\
    \ letter {\n         ~~~~~~~~~~~~~~~~~~~ ^  ~~~~~~\n/tmp/tmph6sv2d86.swift:19:30:\
    \ note: overloads for '==' exist with these partially matching parameter lists:\
    \ (Character, Character), (String, String)\n      if letter.uppercased() == letter\
    \ {\n                             ^\n"
  stdout: ''
  timestamp: 1659978812
- exit_code: 0
  program: "\n/// You are given a string s.\n/// if s[i] is a letter, reverse its\
    \ case from lower to upper or vise versa, \n/// otherwise keep it as it is.\n\
    /// If the string contains no letters, reverse the string.\n/// The function should\
    \ return the resulted string.\n/// Examples\n/// >>> solve(s: \"1234\")\n/// \"\
    4321\"\n/// >>> solve(s: \"ab\")\n/// \"AB\"\n/// >>> solve(s: \"#a@C\")\n///\
    \ \"#A@c\"\nfunc solve(s: String) -> String {\n    return s.isEmpty || !s.contains(where:\
    \ { $0.isLetter }) ? String(s.reversed()) : String(s.map {\n        $0.isLetter\
    \ ? $0.isUppercase ? Character($0.lowercased()) : Character($0.uppercased()) :\
    \ $0\n    })\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool\
    \ {\n    if left.count != right.count {\n        return false\n    }\n    for\
    \ (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(solve(s: \"AsDf\"\
    ) == \"aSdF\")\nassert(solve(s: \"1234\") == \"4321\")\nassert(solve(s: \"ab\"\
    ) == \"AB\")\nassert(solve(s: \"#a@C\") == \"#A@c\")\nassert(solve(s: \"#AsdfW^45\"\
    ) == \"#aSDFw^45\")\nassert(solve(s: \"#6@2\") == \"2@6#\")\nassert(solve(s: \"\
    #$a^D\") == \"#$A^d\")\nassert(solve(s: \"#ccc\") == \"#CCC\")"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659978812
- exit_code: 1
  program: "\n/// You are given a string s.\n/// if s[i] is a letter, reverse its\
    \ case from lower to upper or vise versa, \n/// otherwise keep it as it is.\n\
    /// If the string contains no letters, reverse the string.\n/// The function should\
    \ return the resulted string.\n/// Examples\n/// >>> solve(s: \"1234\")\n/// \"\
    4321\"\n/// >>> solve(s: \"ab\")\n/// \"AB\"\n/// >>> solve(s: \"#a@C\")\n///\
    \ \"#A@c\"\nfunc solve(s: String) -> String {\n    var result = \"\"\n    for\
    \ char in s {\n        if let unicode = UnicodeScalar(String(char)) {\n      \
    \      if CharacterSet.letters.contains(unicode) {\n                if char.isUppercase\
    \ {\n                    result.append(char.lowercased())\n                } else\
    \ {\n                    result.append(char.uppercased())\n                }\n\
    \            } else {\n                result.append(char)\n            }\n  \
    \      }\n    }\n    return result.count == 0 ? String(s.reversed()) : result\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(solve(s: \"AsDf\") == \"aSdF\")\nassert(solve(s:\
    \ \"1234\") == \"4321\")\nassert(solve(s: \"ab\") == \"AB\")\nassert(solve(s:\
    \ \"#a@C\") == \"#A@c\")\nassert(solve(s: \"#AsdfW^45\") == \"#aSDFw^45\")\nassert(solve(s:\
    \ \"#6@2\") == \"2@6#\")\nassert(solve(s: \"#$a^D\") == \"#$A^d\")\nassert(solve(s:\
    \ \"#ccc\") == \"#CCC\")"
  status: SyntaxError
  stderr: "/tmp/tmpjkkn0uyt.swift:18:16: error: cannot find 'CharacterSet' in scope\n\
    \            if CharacterSet.letters.contains(unicode) {\n               ^~~~~~~~~~~~\n"
  stdout: ''
  timestamp: 1659978812
- exit_code: 1
  program: "\n/// You are given a string s.\n/// if s[i] is a letter, reverse its\
    \ case from lower to upper or vise versa, \n/// otherwise keep it as it is.\n\
    /// If the string contains no letters, reverse the string.\n/// The function should\
    \ return the resulted string.\n/// Examples\n/// >>> solve(s: \"1234\")\n/// \"\
    4321\"\n/// >>> solve(s: \"ab\")\n/// \"AB\"\n/// >>> solve(s: \"#a@C\")\n///\
    \ \"#A@c\"\nfunc solve(s: String) -> String {\n    guard s.rangeOfCharacter(from:\
    \ CharacterSet.letters) != nil else {\n        return String(s.reversed())\n \
    \   }\n    var x = Array(s)\n    for i in 0..<x.count {\n        if CharacterSet.letters.contains(x[i].unicodeScalars.first!)\
    \ {\n            if x[i].lowercased() == x[i] {\n                x[i] = Character(x[i].uppercased())\n\
    \            } else {\n                x[i] = Character(x[i].lowercased())\n \
    \           }\n        }\n    }\n    return String(x)\n}\n\n\nfunc ==(left: [(Int,\
    \ Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n\
    \        return false\n    }\n    for (l, r) in zip(left, right) {\n        if\
    \ l != r {\n            return false\n        }\n    }\n    return true\n}\n \
    \           \nassert(solve(s: \"AsDf\") == \"aSdF\")\nassert(solve(s: \"1234\"\
    ) == \"4321\")\nassert(solve(s: \"ab\") == \"AB\")\nassert(solve(s: \"#a@C\")\
    \ == \"#A@c\")\nassert(solve(s: \"#AsdfW^45\") == \"#aSDFw^45\")\nassert(solve(s:\
    \ \"#6@2\") == \"2@6#\")\nassert(solve(s: \"#$a^D\") == \"#$A^d\")\nassert(solve(s:\
    \ \"#ccc\") == \"#CCC\")"
  status: SyntaxError
  stderr: "/tmp/tmpgjz6dy44.swift:15:36: error: cannot find 'CharacterSet' in scope\n\
    \    guard s.rangeOfCharacter(from: CharacterSet.letters) != nil else {\n    \
    \                               ^~~~~~~~~~~~\n/tmp/tmpgjz6dy44.swift:15:13: error:\
    \ value of type 'String' has no member 'rangeOfCharacter'\n    guard s.rangeOfCharacter(from:\
    \ CharacterSet.letters) != nil else {\n          ~ ^~~~~~~~~~~~~~~~\n/tmp/tmpgjz6dy44.swift:20:12:\
    \ error: cannot find 'CharacterSet' in scope\n        if CharacterSet.letters.contains(x[i].unicodeScalars.first!)\
    \ {\n           ^~~~~~~~~~~~\n/tmp/tmpgjz6dy44.swift:21:34: error: binary operator\
    \ '==' cannot be applied to operands of type 'String' and 'String.Element' (aka\
    \ 'Character')\n            if x[i].lowercased() == x[i] {\n               ~~~~~~~~~~~~~~~~~\
    \ ^  ~~~~\n/tmp/tmpgjz6dy44.swift:21:34: note: overloads for '==' exist with these\
    \ partially matching parameter lists: (Character, Character), (String, String)\n\
    \            if x[i].lowercased() == x[i] {\n                                \
    \ ^\n"
  stdout: ''
  timestamp: 1659978812
- exit_code: 1
  program: "\n/// You are given a string s.\n/// if s[i] is a letter, reverse its\
    \ case from lower to upper or vise versa, \n/// otherwise keep it as it is.\n\
    /// If the string contains no letters, reverse the string.\n/// The function should\
    \ return the resulted string.\n/// Examples\n/// >>> solve(s: \"1234\")\n/// \"\
    4321\"\n/// >>> solve(s: \"ab\")\n/// \"AB\"\n/// >>> solve(s: \"#a@C\")\n///\
    \ \"#A@c\"\nfunc solve(s: String) -> String {\n    return s.reduce(\"\") { (a,\
    \ b) in\n        guard CharacterSet.letters.contains(b.unicodeScalars.first!)\
    \ else {\n            return a + String(b)\n        }\n        return a + String(b.unicodeScalars.first!.value\
    \ < 97 ? Character(UnicodeScalar(b.unicodeScalars.first!.value + 32)!) : Character(UnicodeScalar(b.unicodeScalars.first!.value\
    \ - 32)!))\n    }\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) ->\
    \ Bool {\n    if left.count != right.count {\n        return false\n    }\n  \
    \  for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(solve(s: \"AsDf\"\
    ) == \"aSdF\")\nassert(solve(s: \"1234\") == \"4321\")\nassert(solve(s: \"ab\"\
    ) == \"AB\")\nassert(solve(s: \"#a@C\") == \"#A@c\")\nassert(solve(s: \"#AsdfW^45\"\
    ) == \"#aSDFw^45\")\nassert(solve(s: \"#6@2\") == \"2@6#\")\nassert(solve(s: \"\
    #$a^D\") == \"#$A^d\")\nassert(solve(s: \"#ccc\") == \"#CCC\")"
  status: SyntaxError
  stderr: "/tmp/tmph9drm1mf.swift:16:15: error: cannot find 'CharacterSet' in scope\n\
    \        guard CharacterSet.letters.contains(b.unicodeScalars.first!) else {\n\
    \              ^~~~~~~~~~~~\n"
  stdout: ''
  timestamp: 1659978812
- exit_code: 1
  program: "\n/// You are given a string s.\n/// if s[i] is a letter, reverse its\
    \ case from lower to upper or vise versa, \n/// otherwise keep it as it is.\n\
    /// If the string contains no letters, reverse the string.\n/// The function should\
    \ return the resulted string.\n/// Examples\n/// >>> solve(s: \"1234\")\n/// \"\
    4321\"\n/// >>> solve(s: \"ab\")\n/// \"AB\"\n/// >>> solve(s: \"#a@C\")\n///\
    \ \"#A@c\"\nfunc solve(s: String) -> String {\n    let letters = s.filter { $0.isLetter\
    \ }\n    if letters.isEmpty {\n        return String(s.reversed())\n    }\n  \
    \  return String(letters.reversed().map { $0.isUppercase ? $0.lowercased() : $0.uppercased()\
    \ })\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if\
    \ left.count != right.count {\n        return false\n    }\n    for (l, r) in\
    \ zip(left, right) {\n        if l != r {\n            return false\n        }\n\
    \    }\n    return true\n}\n            \nassert(solve(s: \"AsDf\") == \"aSdF\"\
    )\nassert(solve(s: \"1234\") == \"4321\")\nassert(solve(s: \"ab\") == \"AB\")\n\
    assert(solve(s: \"#a@C\") == \"#A@c\")\nassert(solve(s: \"#AsdfW^45\") == \"#aSDFw^45\"\
    )\nassert(solve(s: \"#6@2\") == \"2@6#\")\nassert(solve(s: \"#$a^D\") == \"#$A^d\"\
    )\nassert(solve(s: \"#ccc\") == \"#CCC\")"
  status: SyntaxError
  stderr: "/tmp/tmpgojf9v9x.swift:19:12: error: type of expression is ambiguous without\
    \ more context\n    return String(letters.reversed().map { $0.isUppercase ? $0.lowercased()\
    \ : $0.uppercased() })\n           ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n"
  stdout: ''
  timestamp: 1659978812
- exit_code: 1
  program: "\n/// You are given a string s.\n/// if s[i] is a letter, reverse its\
    \ case from lower to upper or vise versa, \n/// otherwise keep it as it is.\n\
    /// If the string contains no letters, reverse the string.\n/// The function should\
    \ return the resulted string.\n/// Examples\n/// >>> solve(s: \"1234\")\n/// \"\
    4321\"\n/// >>> solve(s: \"ab\")\n/// \"AB\"\n/// >>> solve(s: \"#a@C\")\n///\
    \ \"#A@c\"\nfunc solve(s: String) -> String {\n    //if(s.count == 0) {return\
    \ s}\n    var result: String = \"\"\n    var temp: String = \"\"\n    for ch in\
    \ s {\n        if ch.isLetter {\n            temp = String(ch)\n            result\
    \ += String(temp.lowercased().reversed())\n        } else {\n            result\
    \ += String(ch)\n        }\n    }\n    if(s.count == 0) {return result.reversed()}\n\
    \    return result\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) ->\
    \ Bool {\n    if left.count != right.count {\n        return false\n    }\n  \
    \  for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(solve(s: \"AsDf\"\
    ) == \"aSdF\")\nassert(solve(s: \"1234\") == \"4321\")\nassert(solve(s: \"ab\"\
    ) == \"AB\")\nassert(solve(s: \"#a@C\") == \"#A@c\")\nassert(solve(s: \"#AsdfW^45\"\
    ) == \"#aSDFw^45\")\nassert(solve(s: \"#6@2\") == \"2@6#\")\nassert(solve(s: \"\
    #$a^D\") == \"#$A^d\")\nassert(solve(s: \"#ccc\") == \"#CCC\")"
  status: SyntaxError
  stderr: "/tmp/tmpssguj17n.swift:26:37: error: no 'reversed' candidates produce the\
    \ expected contextual result type 'String'\n    if(s.count == 0) {return result.reversed()}\n\
    \                                    ^\nSwift.Sequence:2:40: note: 'reversed()'\
    \ produces '[String.Element]' (aka 'Array<Character>'), not the expected contextual\
    \ result type 'String'\n    @inlinable public __consuming func reversed() -> [Self.Element]\n\
    \                                       ^\nSwift.BidirectionalCollection:2:40:\
    \ note: 'reversed()' produces 'ReversedCollection<String>', not the expected contextual\
    \ result type 'String'\n    @inlinable public __consuming func reversed() -> ReversedCollection<Self>\n\
    \                                       ^\n"
  stdout: ''
  timestamp: 1659978812
- exit_code: -4
  program: "\n/// You are given a string s.\n/// if s[i] is a letter, reverse its\
    \ case from lower to upper or vise versa, \n/// otherwise keep it as it is.\n\
    /// If the string contains no letters, reverse the string.\n/// The function should\
    \ return the resulted string.\n/// Examples\n/// >>> solve(s: \"1234\")\n/// \"\
    4321\"\n/// >>> solve(s: \"ab\")\n/// \"AB\"\n/// >>> solve(s: \"#a@C\")\n///\
    \ \"#A@c\"\nfunc solve(s: String) -> String {\n    guard !s.isEmpty else { return\
    \ \"\" }\n    var result = \"\"\n    for char in s {\n        if char.isLetter\
    \ {\n            result.append(char.isUppercase ? char.lowercased() : char.uppercased())\n\
    \        } else {\n            result.append(char)\n        }\n    }\n    if result.isEmpty\
    \ {\n        return String(s.reversed())\n    }\n    return result\n}\n\n\nfunc\
    \ ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count !=\
    \ right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(solve(s: \"AsDf\") == \"aSdF\")\nassert(solve(s:\
    \ \"1234\") == \"4321\")\nassert(solve(s: \"ab\") == \"AB\")\nassert(solve(s:\
    \ \"#a@C\") == \"#A@c\")\nassert(solve(s: \"#AsdfW^45\") == \"#aSDFw^45\")\nassert(solve(s:\
    \ \"#6@2\") == \"2@6#\")\nassert(solve(s: \"#$a^D\") == \"#$A^d\")\nassert(solve(s:\
    \ \"#ccc\") == \"#CCC\")"
  status: Exception
  stderr: 'tmpvo03_p9q/tmpvo03_p9q.swift:44: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b13c0ad6c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b13c07cdb6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b13c07cd988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b13c07cc7b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpvo03_p9q                        0x000055b4f0baa8d7 <unavailable> + 6359

    5    libc.so.6                          0x00002b13c0cc2460 __libc_start_main +
    245

    6    tmpvo03_p9q                        0x000055b4f0baa429 <unavailable> + 5161

    '
  stdout: ''
  timestamp: 1659978812
- exit_code: 1
  program: "\n/// You are given a string s.\n/// if s[i] is a letter, reverse its\
    \ case from lower to upper or vise versa, \n/// otherwise keep it as it is.\n\
    /// If the string contains no letters, reverse the string.\n/// The function should\
    \ return the resulted string.\n/// Examples\n/// >>> solve(s: \"1234\")\n/// \"\
    4321\"\n/// >>> solve(s: \"ab\")\n/// \"AB\"\n/// >>> solve(s: \"#a@C\")\n///\
    \ \"#A@c\"\nfunc solve(s: String) -> String {\n  guard !s.isEmpty else { return\
    \ \"\" }\n  var revStr = String()\n  let chars = s.map { String($0) }\n  for i\
    \ in 0..<chars.count {\n    guard chars[i].rangeOfCharacter(from: CharacterSet.letters)\
    \ != nil else {\n      revStr.append(chars[i])\n      continue\n    }\n    revStr.append(chars[i].uppercased()\
    \ == chars[i] ? chars[i].lowercased() : chars[i].uppercased())\n  }\n  return\
    \ revStr\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n\
    \    if left.count != right.count {\n        return false\n    }\n    for (l,\
    \ r) in zip(left, right) {\n        if l != r {\n            return false\n  \
    \      }\n    }\n    return true\n}\n            \nassert(solve(s: \"AsDf\") ==\
    \ \"aSdF\")\nassert(solve(s: \"1234\") == \"4321\")\nassert(solve(s: \"ab\") ==\
    \ \"AB\")\nassert(solve(s: \"#a@C\") == \"#A@c\")\nassert(solve(s: \"#AsdfW^45\"\
    ) == \"#aSDFw^45\")\nassert(solve(s: \"#6@2\") == \"2@6#\")\nassert(solve(s: \"\
    #$a^D\") == \"#$A^d\")\nassert(solve(s: \"#ccc\") == \"#CCC\")"
  status: SyntaxError
  stderr: "/tmp/tmpu8zo82cz.swift:19:43: error: cannot find 'CharacterSet' in scope\n\
    \    guard chars[i].rangeOfCharacter(from: CharacterSet.letters) != nil else {\n\
    \                                          ^~~~~~~~~~~~\n/tmp/tmpu8zo82cz.swift:19:20:\
    \ error: value of type 'String' has no member 'rangeOfCharacter'\n    guard chars[i].rangeOfCharacter(from:\
    \ CharacterSet.letters) != nil else {\n          ~~~~~~~~ ^~~~~~~~~~~~~~~~\n"
  stdout: ''
  timestamp: 1659978812
- exit_code: 1
  program: "\n/// You are given a string s.\n/// if s[i] is a letter, reverse its\
    \ case from lower to upper or vise versa, \n/// otherwise keep it as it is.\n\
    /// If the string contains no letters, reverse the string.\n/// The function should\
    \ return the resulted string.\n/// Examples\n/// >>> solve(s: \"1234\")\n/// \"\
    4321\"\n/// >>> solve(s: \"ab\")\n/// \"AB\"\n/// >>> solve(s: \"#a@C\")\n///\
    \ \"#A@c\"\nfunc solve(s: String) -> String {\n    var result = s\n    for i in\
    \ s.indices {\n        if s[i].isLetter {\n            result.replaceSubrange(i...i,\
    \ with: String(s[i].isUppercase ? s[i].lowercased() : s[i].uppercased()))\n  \
    \      }\n    }\n    return result.reversed()\n}\n\n\nfunc ==(left: [(Int, Int)],\
    \ right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n       \
    \ return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r\
    \ {\n            return false\n        }\n    }\n    return true\n}\n        \
    \    \nassert(solve(s: \"AsDf\") == \"aSdF\")\nassert(solve(s: \"1234\") == \"\
    4321\")\nassert(solve(s: \"ab\") == \"AB\")\nassert(solve(s: \"#a@C\") == \"#A@c\"\
    )\nassert(solve(s: \"#AsdfW^45\") == \"#aSDFw^45\")\nassert(solve(s: \"#6@2\"\
    ) == \"2@6#\")\nassert(solve(s: \"#$a^D\") == \"#$A^d\")\nassert(solve(s: \"#ccc\"\
    ) == \"#CCC\")"
  status: SyntaxError
  stderr: "/tmp/tmpl03i1j54.swift:21:19: error: no 'reversed' candidates produce the\
    \ expected contextual result type 'String'\n    return result.reversed()\n   \
    \               ^\nSwift.Sequence:2:40: note: 'reversed()' produces '[String.Element]'\
    \ (aka 'Array<Character>'), not the expected contextual result type 'String'\n\
    \    @inlinable public __consuming func reversed() -> [Self.Element]\n       \
    \                                ^\nSwift.BidirectionalCollection:2:40: note:\
    \ 'reversed()' produces 'ReversedCollection<String>', not the expected contextual\
    \ result type 'String'\n    @inlinable public __consuming func reversed() -> ReversedCollection<Self>\n\
    \                                       ^\n"
  stdout: ''
  timestamp: 1659978812
- exit_code: -4
  program: "\n/// You are given a string s.\n/// if s[i] is a letter, reverse its\
    \ case from lower to upper or vise versa, \n/// otherwise keep it as it is.\n\
    /// If the string contains no letters, reverse the string.\n/// The function should\
    \ return the resulted string.\n/// Examples\n/// >>> solve(s: \"1234\")\n/// \"\
    4321\"\n/// >>> solve(s: \"ab\")\n/// \"AB\"\n/// >>> solve(s: \"#a@C\")\n///\
    \ \"#A@c\"\nfunc solve(s: String) -> String {\n    return \"\"\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(solve(s: \"AsDf\") == \"aSdF\")\nassert(solve(s: \"1234\"\
    ) == \"4321\")\nassert(solve(s: \"ab\") == \"AB\")\nassert(solve(s: \"#a@C\")\
    \ == \"#A@c\")\nassert(solve(s: \"#AsdfW^45\") == \"#aSDFw^45\")\nassert(solve(s:\
    \ \"#6@2\") == \"2@6#\")\nassert(solve(s: \"#$a^D\") == \"#$A^d\")\nassert(solve(s:\
    \ \"#ccc\") == \"#CCC\")"
  status: Exception
  stderr: 'tmpiark_u6w/tmpiark_u6w.swift:31: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002aca5c89dc80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002aca5c594b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002aca5c594988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002aca5c5937b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpiark_u6w                        0x0000562c1ac34307 <unavailable> + 4871

    5    libc.so.6                          0x00002aca5ca89460 __libc_start_main +
    245

    6    tmpiark_u6w                        0x0000562c1ac33f49 <unavailable> + 3913

    '
  stdout: ''
  timestamp: 1659978811
- exit_code: 1
  program: "\n/// You are given a string s.\n/// if s[i] is a letter, reverse its\
    \ case from lower to upper or vise versa, \n/// otherwise keep it as it is.\n\
    /// If the string contains no letters, reverse the string.\n/// The function should\
    \ return the resulted string.\n/// Examples\n/// >>> solve(s: \"1234\")\n/// \"\
    4321\"\n/// >>> solve(s: \"ab\")\n/// \"AB\"\n/// >>> solve(s: \"#a@C\")\n///\
    \ \"#A@c\"\nfunc solve(s: String) -> String {\n\t\n\tvar result = \"\"\n\tlet\
    \ upper = \"ABCDEFGHIJKLMNOPQRSTUVWXYZ\"\n\tlet lower = \"abcdefghijklmnopqrstuvwxyz\"\
    \n\t\n\tif s.rangeOfCharacter(from: .letters) == nil {\n\t\tfor c in s.reversed()\
    \ {\n\t\t\tresult.append(c)\n\t\t}\n\t} else {\n\t\tfor c in s {\n\t\t\tif let\
    \ index = upper.firstIndex(of: c) {\n\t\t\t\tresult.append(lower[index])\n\t\t\
    \t} else if let index = lower.firstIndex(of: c) {\n\t\t\t\tresult.append(upper[index])\n\
    \t\t\t} else {\n\t\t\t\tresult.append(c)\n\t\t\t}\n\t\t}\n\t}\n\t\n\treturn result\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(solve(s: \"AsDf\") == \"aSdF\")\nassert(solve(s:\
    \ \"1234\") == \"4321\")\nassert(solve(s: \"ab\") == \"AB\")\nassert(solve(s:\
    \ \"#a@C\") == \"#A@c\")\nassert(solve(s: \"#AsdfW^45\") == \"#aSDFw^45\")\nassert(solve(s:\
    \ \"#6@2\") == \"2@6#\")\nassert(solve(s: \"#$a^D\") == \"#$A^d\")\nassert(solve(s:\
    \ \"#ccc\") == \"#CCC\")"
  status: SyntaxError
  stderr: "/tmp/tmpp789e6rb.swift:20:7: error: value of type 'String' has no member\
    \ 'rangeOfCharacter'\n        if s.rangeOfCharacter(from: .letters) == nil {\n\
    \           ~ ^~~~~~~~~~~~~~~~\n/tmp/tmpp789e6rb.swift:20:31: error: cannot infer\
    \ contextual base in reference to member 'letters'\n        if s.rangeOfCharacter(from:\
    \ .letters) == nil {\n                                    ~^~~~~~~\n"
  stdout: ''
  timestamp: 1659978812
- exit_code: 1
  program: "\n/// You are given a string s.\n/// if s[i] is a letter, reverse its\
    \ case from lower to upper or vise versa, \n/// otherwise keep it as it is.\n\
    /// If the string contains no letters, reverse the string.\n/// The function should\
    \ return the resulted string.\n/// Examples\n/// >>> solve(s: \"1234\")\n/// \"\
    4321\"\n/// >>> solve(s: \"ab\")\n/// \"AB\"\n/// >>> solve(s: \"#a@C\")\n///\
    \ \"#A@c\"\nfunc solve(s: String) -> String {\n\tvar result = \"\"\n\tfor char\
    \ in s {\n\t\tif isalpha(char) {\n\t\t\tif isupper(char) {\n\t\t\t\tresult.append(char.lowercased())\n\
    \t\t\t} else {\n\t\t\t\tresult.append(char.uppercased())\n\t\t\t}\n\t\t} else\
    \ {\n\t\t\tresult.append(char)\n\t\t}\n\t}\n\tif isDigit(s: result) {\n\t\treturn\
    \ String(result.reversed())\n\t}\n\treturn result\n}\n\n\nfunc ==(left: [(Int,\
    \ Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n\
    \        return false\n    }\n    for (l, r) in zip(left, right) {\n        if\
    \ l != r {\n            return false\n        }\n    }\n    return true\n}\n \
    \           \nassert(solve(s: \"AsDf\") == \"aSdF\")\nassert(solve(s: \"1234\"\
    ) == \"4321\")\nassert(solve(s: \"ab\") == \"AB\")\nassert(solve(s: \"#a@C\")\
    \ == \"#A@c\")\nassert(solve(s: \"#AsdfW^45\") == \"#aSDFw^45\")\nassert(solve(s:\
    \ \"#6@2\") == \"2@6#\")\nassert(solve(s: \"#$a^D\") == \"#$A^d\")\nassert(solve(s:\
    \ \"#ccc\") == \"#CCC\")"
  status: SyntaxError
  stderr: "/tmp/tmpfj4ca80c.swift:17:6: error: cannot find 'isalpha' in scope\n  \
    \              if isalpha(char) {\n                   ^~~~~~~\n/tmp/tmpfj4ca80c.swift:18:7:\
    \ error: cannot find 'isupper' in scope\n                        if isupper(char)\
    \ {\n                           ^~~~~~~\n/tmp/tmpfj4ca80c.swift:27:5: error: cannot\
    \ find 'isDigit' in scope\n        if isDigit(s: result) {\n           ^~~~~~~\n"
  stdout: ''
  timestamp: 1659978812
- exit_code: 1
  program: "\n/// You are given a string s.\n/// if s[i] is a letter, reverse its\
    \ case from lower to upper or vise versa, \n/// otherwise keep it as it is.\n\
    /// If the string contains no letters, reverse the string.\n/// The function should\
    \ return the resulted string.\n/// Examples\n/// >>> solve(s: \"1234\")\n/// \"\
    4321\"\n/// >>> solve(s: \"ab\")\n/// \"AB\"\n/// >>> solve(s: \"#a@C\")\n///\
    \ \"#A@c\"\nfunc solve(s: String) -> String {\n    guard !s.isEmpty else { return\
    \ s }\n    guard s.rangeOfCharacter(from: CharacterSet.letters) != nil else {\
    \ return String(s.reversed()) }\n    return String(s.map { character -> Character\
    \ in\n        guard let ascii = character.asciiValue else { return character }\n\
    \        if ascii >= 65 && ascii <= 90 { return Character(UnicodeScalar(ascii\
    \ + 32)!) }\n        if ascii >= 97 && ascii <= 122 { return Character(UnicodeScalar(ascii\
    \ - 32)!) }\n        return character\n    })\n}\n\n\nfunc ==(left: [(Int, Int)],\
    \ right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n       \
    \ return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r\
    \ {\n            return false\n        }\n    }\n    return true\n}\n        \
    \    \nassert(solve(s: \"AsDf\") == \"aSdF\")\nassert(solve(s: \"1234\") == \"\
    4321\")\nassert(solve(s: \"ab\") == \"AB\")\nassert(solve(s: \"#a@C\") == \"#A@c\"\
    )\nassert(solve(s: \"#AsdfW^45\") == \"#aSDFw^45\")\nassert(solve(s: \"#6@2\"\
    ) == \"2@6#\")\nassert(solve(s: \"#$a^D\") == \"#$A^d\")\nassert(solve(s: \"#ccc\"\
    ) == \"#CCC\")"
  status: SyntaxError
  stderr: "/tmp/tmplr15d0d8.swift:16:36: error: cannot find 'CharacterSet' in scope\n\
    \    guard s.rangeOfCharacter(from: CharacterSet.letters) != nil else { return\
    \ String(s.reversed()) }\n                                   ^~~~~~~~~~~~\n/tmp/tmplr15d0d8.swift:16:13:\
    \ error: value of type 'String' has no member 'rangeOfCharacter'\n    guard s.rangeOfCharacter(from:\
    \ CharacterSet.letters) != nil else { return String(s.reversed()) }\n        \
    \  ~ ^~~~~~~~~~~~~~~~\n/tmp/tmplr15d0d8.swift:19:83: error: cannot force unwrap\
    \ value of non-optional type 'UnicodeScalar' (aka 'Unicode.Scalar')\n        if\
    \ ascii >= 65 && ascii <= 90 { return Character(UnicodeScalar(ascii + 32)!) }\n\
    \                                                         ~~~~~~~~~~~~~~~~~~~~~~~~~^\n\
    \                                                                            \
    \      \n"
  stdout: ''
  timestamp: 1659978812
- exit_code: -4
  program: "\n/// You are given a string s.\n/// if s[i] is a letter, reverse its\
    \ case from lower to upper or vise versa, \n/// otherwise keep it as it is.\n\
    /// If the string contains no letters, reverse the string.\n/// The function should\
    \ return the resulted string.\n/// Examples\n/// >>> solve(s: \"1234\")\n/// \"\
    4321\"\n/// >>> solve(s: \"ab\")\n/// \"AB\"\n/// >>> solve(s: \"#a@C\")\n///\
    \ \"#A@c\"\nfunc solve(s: String) -> String {\n    return \"\"\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(solve(s: \"AsDf\") == \"aSdF\")\nassert(solve(s: \"1234\"\
    ) == \"4321\")\nassert(solve(s: \"ab\") == \"AB\")\nassert(solve(s: \"#a@C\")\
    \ == \"#A@c\")\nassert(solve(s: \"#AsdfW^45\") == \"#aSDFw^45\")\nassert(solve(s:\
    \ \"#6@2\") == \"2@6#\")\nassert(solve(s: \"#$a^D\") == \"#$A^d\")\nassert(solve(s:\
    \ \"#ccc\") == \"#CCC\")"
  status: Exception
  stderr: 'tmpiark_u6w/tmpiark_u6w.swift:31: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002aca5c89dc80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002aca5c594b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002aca5c594988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002aca5c5937b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpiark_u6w                        0x0000562c1ac34307 <unavailable> + 4871

    5    libc.so.6                          0x00002aca5ca89460 __libc_start_main +
    245

    6    tmpiark_u6w                        0x0000562c1ac33f49 <unavailable> + 3913

    '
  stdout: ''
  timestamp: 1659978811
- exit_code: 1
  program: "\n/// You are given a string s.\n/// if s[i] is a letter, reverse its\
    \ case from lower to upper or vise versa, \n/// otherwise keep it as it is.\n\
    /// If the string contains no letters, reverse the string.\n/// The function should\
    \ return the resulted string.\n/// Examples\n/// >>> solve(s: \"1234\")\n/// \"\
    4321\"\n/// >>> solve(s: \"ab\")\n/// \"AB\"\n/// >>> solve(s: \"#a@C\")\n///\
    \ \"#A@c\"\nfunc solve(s: String) -> String {\n    guard s.isLetter else {\n \
    \       return String(s.reversed())\n    }\n    var result = \"\"\n    for char\
    \ in s {\n        if char.isLetter {\n            result += String(char.isUppercase\
    \ ? char.lowercased() : char.uppercased())\n        } else {\n            result\
    \ += String(char)\n        }\n    }\n    return result\n}\n\n\nfunc ==(left: [(Int,\
    \ Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n\
    \        return false\n    }\n    for (l, r) in zip(left, right) {\n        if\
    \ l != r {\n            return false\n        }\n    }\n    return true\n}\n \
    \           \nassert(solve(s: \"AsDf\") == \"aSdF\")\nassert(solve(s: \"1234\"\
    ) == \"4321\")\nassert(solve(s: \"ab\") == \"AB\")\nassert(solve(s: \"#a@C\")\
    \ == \"#A@c\")\nassert(solve(s: \"#AsdfW^45\") == \"#aSDFw^45\")\nassert(solve(s:\
    \ \"#6@2\") == \"2@6#\")\nassert(solve(s: \"#$a^D\") == \"#$A^d\")\nassert(solve(s:\
    \ \"#ccc\") == \"#CCC\")"
  status: SyntaxError
  stderr: "/tmp/tmprfj5clbx.swift:15:13: error: value of type 'String' has no member\
    \ 'isLetter'\n    guard s.isLetter else {\n          ~ ^~~~~~~~\n"
  stdout: ''
  timestamp: 1659978812
- exit_code: -4
  program: "\n/// You are given a string s.\n/// if s[i] is a letter, reverse its\
    \ case from lower to upper or vise versa, \n/// otherwise keep it as it is.\n\
    /// If the string contains no letters, reverse the string.\n/// The function should\
    \ return the resulted string.\n/// Examples\n/// >>> solve(s: \"1234\")\n/// \"\
    4321\"\n/// >>> solve(s: \"ab\")\n/// \"AB\"\n/// >>> solve(s: \"#a@C\")\n///\
    \ \"#A@c\"\nfunc solve(s: String) -> String {\n    return String(s.map{$0.isLetter\
    \ ? ($0.isLowercase ? Character($0.uppercased()) : Character($0.lowercased()))\
    \ : $0})\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n\
    \    if left.count != right.count {\n        return false\n    }\n    for (l,\
    \ r) in zip(left, right) {\n        if l != r {\n            return false\n  \
    \      }\n    }\n    return true\n}\n            \nassert(solve(s: \"AsDf\") ==\
    \ \"aSdF\")\nassert(solve(s: \"1234\") == \"4321\")\nassert(solve(s: \"ab\") ==\
    \ \"AB\")\nassert(solve(s: \"#a@C\") == \"#A@c\")\nassert(solve(s: \"#AsdfW^45\"\
    ) == \"#aSDFw^45\")\nassert(solve(s: \"#6@2\") == \"2@6#\")\nassert(solve(s: \"\
    #$a^D\") == \"#$A^d\")\nassert(solve(s: \"#ccc\") == \"#CCC\")"
  status: Exception
  stderr: 'tmp6cxumlk5/tmp6cxumlk5.swift:32: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002ae9a23acc80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002ae9a20a3b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002ae9a20a3988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002ae9a20a27b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmp6cxumlk5                        0x000056455f668717 <unavailable> + 5911

    5    libc.so.6                          0x00002ae9a2598460 __libc_start_main +
    245

    6    tmp6cxumlk5                        0x000056455f668269 <unavailable> + 4713

    '
  stdout: ''
  timestamp: 1659978812
- exit_code: 1
  program: "\n/// You are given a string s.\n/// if s[i] is a letter, reverse its\
    \ case from lower to upper or vise versa, \n/// otherwise keep it as it is.\n\
    /// If the string contains no letters, reverse the string.\n/// The function should\
    \ return the resulted string.\n/// Examples\n/// >>> solve(s: \"1234\")\n/// \"\
    4321\"\n/// >>> solve(s: \"ab\")\n/// \"AB\"\n/// >>> solve(s: \"#a@C\")\n///\
    \ \"#A@c\"\nfunc solve(s: String) -> String {\n    return s.isEmpty ? s : s.map{\
    \ $0.isLetter ? $0.isUppercase ? $0.lowercased() : $0.uppercased() : $0 }.joined()\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(solve(s: \"AsDf\") == \"aSdF\")\nassert(solve(s:\
    \ \"1234\") == \"4321\")\nassert(solve(s: \"ab\") == \"AB\")\nassert(solve(s:\
    \ \"#a@C\") == \"#A@c\")\nassert(solve(s: \"#AsdfW^45\") == \"#aSDFw^45\")\nassert(solve(s:\
    \ \"#6@2\") == \"2@6#\")\nassert(solve(s: \"#$a^D\") == \"#$A^d\")\nassert(solve(s:\
    \ \"#ccc\") == \"#CCC\")"
  status: SyntaxError
  stderr: "/tmp/tmpbx2jv3ag.swift:15:47: error: cannot convert value of type 'String.Element'\
    \ (aka 'Character') to closure result type 'String'\n    return s.isEmpty ? s\
    \ : s.map{ $0.isLetter ? $0.isUppercase ? $0.lowercased() : $0.uppercased() :\
    \ $0 }.joined()\n                                  ~~~~~~~~~~~~^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n\
    /tmp/tmpbx2jv3ag.swift:15:64: error: result values in '? :' expression have mismatching\
    \ types 'String' and 'String.Element' (aka 'Character')\n    return s.isEmpty\
    \ ? s : s.map{ $0.isLetter ? $0.isUppercase ? $0.lowercased() : $0.uppercased()\
    \ : $0 }.joined()\n                                                ~~~~~~~~~~~~~~~^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n"
  stdout: ''
  timestamp: 1659978812
- exit_code: -4
  program: "\n/// You are given a string s.\n/// if s[i] is a letter, reverse its\
    \ case from lower to upper or vise versa, \n/// otherwise keep it as it is.\n\
    /// If the string contains no letters, reverse the string.\n/// The function should\
    \ return the resulted string.\n/// Examples\n/// >>> solve(s: \"1234\")\n/// \"\
    4321\"\n/// >>> solve(s: \"ab\")\n/// \"AB\"\n/// >>> solve(s: \"#a@C\")\n///\
    \ \"#A@c\"\nfunc solve(s: String) -> String {\n    var reversed = \"\"\n    for\
    \ ch in s {\n        switch ch {\n        case \"a\"...\"z\":\n            reversed.append(ch.uppercased())\n\
    \        case \"A\"...\"Z\":\n            reversed.append(ch.lowercased())\n \
    \       default:\n            reversed.append(ch)\n        }\n    }\n    return\
    \ String(reversed.reversed())\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int,\
    \ Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n\
    \    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n          \
    \  return false\n        }\n    }\n    return true\n}\n            \nassert(solve(s:\
    \ \"AsDf\") == \"aSdF\")\nassert(solve(s: \"1234\") == \"4321\")\nassert(solve(s:\
    \ \"ab\") == \"AB\")\nassert(solve(s: \"#a@C\") == \"#A@c\")\nassert(solve(s:\
    \ \"#AsdfW^45\") == \"#aSDFw^45\")\nassert(solve(s: \"#6@2\") == \"2@6#\")\nassert(solve(s:\
    \ \"#$a^D\") == \"#$A^d\")\nassert(solve(s: \"#ccc\") == \"#CCC\")"
  status: Exception
  stderr: 'tmp_14mx9na/tmp_14mx9na.swift:42: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b34c2a63c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b34c275ab6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b34c275a988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b34c27597b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmp_14mx9na                        0x000055d17a06b917 <unavailable> + 6423

    5    libc.so.6                          0x00002b34c2c4f460 __libc_start_main +
    245

    6    tmp_14mx9na                        0x000055d17a06b559 <unavailable> + 5465

    '
  stdout: ''
  timestamp: 1659978812
- exit_code: 1
  program: "\n/// You are given a string s.\n/// if s[i] is a letter, reverse its\
    \ case from lower to upper or vise versa, \n/// otherwise keep it as it is.\n\
    /// If the string contains no letters, reverse the string.\n/// The function should\
    \ return the resulted string.\n/// Examples\n/// >>> solve(s: \"1234\")\n/// \"\
    4321\"\n/// >>> solve(s: \"ab\")\n/// \"AB\"\n/// >>> solve(s: \"#a@C\")\n///\
    \ \"#A@c\"\nfunc solve(s: String) -> String {\n  var s = s\n  let l = s.filter\
    \ { $0.isLetter }\n  if l.isEmpty {\n    s = String(s.reversed())\n  } else {\n\
    \    for (i, c) in s.enumerated() {\n      if c.isLetter {\n        let ns = c.isLowercase\
    \ ? c.uppercased() : c.lowercased()\n        s.replaceSubrange(i...i, with: ns)\n\
    \      }\n    }\n  }\n  return s\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int,\
    \ Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n\
    \    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n          \
    \  return false\n        }\n    }\n    return true\n}\n            \nassert(solve(s:\
    \ \"AsDf\") == \"aSdF\")\nassert(solve(s: \"1234\") == \"4321\")\nassert(solve(s:\
    \ \"ab\") == \"AB\")\nassert(solve(s: \"#a@C\") == \"#A@c\")\nassert(solve(s:\
    \ \"#AsdfW^45\") == \"#aSDFw^45\")\nassert(solve(s: \"#6@2\") == \"2@6#\")\nassert(solve(s:\
    \ \"#$a^D\") == \"#$A^d\")\nassert(solve(s: \"#ccc\") == \"#CCC\")"
  status: SyntaxError
  stderr: "/tmp/tmp13fydnj3.swift:23:9: error: instance method 'replaceSubrange(_:with:)'\
    \ requires the types 'String.Index' and 'Int' be equivalent\n        s.replaceSubrange(i...i,\
    \ with: ns)\n        ^\nSwift.RangeReplaceableCollection:2:37: note: where 'Self.Index'\
    \ = 'String.Index', 'R.Bound' = 'Int'\n    @inlinable public mutating func replaceSubrange<C,\
    \ R>(_ subrange: R, with newElements: __owned C) where C : Collection, R : RangeExpression,\
    \ Self.Element == C.Element, Self.Index == R.Bound\n                         \
    \           ^\n"
  stdout: ''
  timestamp: 1659978812
- exit_code: 1
  program: "\n/// You are given a string s.\n/// if s[i] is a letter, reverse its\
    \ case from lower to upper or vise versa, \n/// otherwise keep it as it is.\n\
    /// If the string contains no letters, reverse the string.\n/// The function should\
    \ return the resulted string.\n/// Examples\n/// >>> solve(s: \"1234\")\n/// \"\
    4321\"\n/// >>> solve(s: \"ab\")\n/// \"AB\"\n/// >>> solve(s: \"#a@C\")\n///\
    \ \"#A@c\"\nfunc solve(s: String) -> String {\n    let letters = CharacterSet.letters\n\
    \    let digits = CharacterSet.decimalDigits\n    var result = \"\"\n    for c\
    \ in s {\n        if let _ = String(c).rangeOfCharacter(from: letters) {\n   \
    \         if let _ = String(c).rangeOfCharacter(from: digits) {\n            \
    \    result.append(c)\n            } else {\n                result.append(c.isUppercase\
    \ ? c.lowercased() : c.uppercased())\n            }\n        } else {\n      \
    \      result.append(c)\n        }\n    }\n    return result.isEmpty ? s : String(result.reversed())\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(solve(s: \"AsDf\") == \"aSdF\")\nassert(solve(s:\
    \ \"1234\") == \"4321\")\nassert(solve(s: \"ab\") == \"AB\")\nassert(solve(s:\
    \ \"#a@C\") == \"#A@c\")\nassert(solve(s: \"#AsdfW^45\") == \"#aSDFw^45\")\nassert(solve(s:\
    \ \"#6@2\") == \"2@6#\")\nassert(solve(s: \"#$a^D\") == \"#$A^d\")\nassert(solve(s:\
    \ \"#ccc\") == \"#CCC\")"
  status: SyntaxError
  stderr: "/tmp/tmpv5tmlma9.swift:15:19: error: cannot find 'CharacterSet' in scope\n\
    \    let letters = CharacterSet.letters\n                  ^~~~~~~~~~~~\n/tmp/tmpv5tmlma9.swift:16:18:\
    \ error: cannot find 'CharacterSet' in scope\n    let digits = CharacterSet.decimalDigits\n\
    \                 ^~~~~~~~~~~~\n/tmp/tmpv5tmlma9.swift:19:30: error: value of\
    \ type 'String' has no member 'rangeOfCharacter'\n        if let _ = String(c).rangeOfCharacter(from:\
    \ letters) {\n                   ~~~~~~~~~ ^~~~~~~~~~~~~~~~\n/tmp/tmpv5tmlma9.swift:20:34:\
    \ error: value of type 'String' has no member 'rangeOfCharacter'\n           \
    \ if let _ = String(c).rangeOfCharacter(from: digits) {\n                    \
    \   ~~~~~~~~~ ^~~~~~~~~~~~~~~~\n"
  stdout: ''
  timestamp: 1659978812
- exit_code: -4
  program: "\n/// You are given a string s.\n/// if s[i] is a letter, reverse its\
    \ case from lower to upper or vise versa, \n/// otherwise keep it as it is.\n\
    /// If the string contains no letters, reverse the string.\n/// The function should\
    \ return the resulted string.\n/// Examples\n/// >>> solve(s: \"1234\")\n/// \"\
    4321\"\n/// >>> solve(s: \"ab\")\n/// \"AB\"\n/// >>> solve(s: \"#a@C\")\n///\
    \ \"#A@c\"\nfunc solve(s: String) -> String {\n    var result = String()\n   \
    \ var count = 0\n    for ch in s {\n        if ch.isLetter {\n            if ch.isLowercase\
    \ {\n                result.append(ch.uppercased())\n            } else {\n  \
    \              result.append(ch.lowercased())\n            }\n        } else {\n\
    \            result.append(ch)\n        }\n        count += 1\n    }\n    if count\
    \ == 0 {\n        return String(s.reversed())\n    }\n    return result\n}\n\n\
    \nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(solve(s: \"AsDf\") == \"aSdF\")\nassert(solve(s:\
    \ \"1234\") == \"4321\")\nassert(solve(s: \"ab\") == \"AB\")\nassert(solve(s:\
    \ \"#a@C\") == \"#A@c\")\nassert(solve(s: \"#AsdfW^45\") == \"#aSDFw^45\")\nassert(solve(s:\
    \ \"#6@2\") == \"2@6#\")\nassert(solve(s: \"#$a^D\") == \"#$A^d\")\nassert(solve(s:\
    \ \"#ccc\") == \"#CCC\")"
  status: Exception
  stderr: 'tmpwym45m7a/tmpwym45m7a.swift:49: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b5235127c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b5234e1eb6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b5234e1e988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b5234e1d7b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpwym45m7a                        0x000055f373a568d7 <unavailable> + 6359

    5    libc.so.6                          0x00002b5235313460 __libc_start_main +
    245

    6    tmpwym45m7a                        0x000055f373a56429 <unavailable> + 5161

    '
  stdout: ''
  timestamp: 1659978812
- exit_code: 1
  program: "\n/// You are given a string s.\n/// if s[i] is a letter, reverse its\
    \ case from lower to upper or vise versa, \n/// otherwise keep it as it is.\n\
    /// If the string contains no letters, reverse the string.\n/// The function should\
    \ return the resulted string.\n/// Examples\n/// >>> solve(s: \"1234\")\n/// \"\
    4321\"\n/// >>> solve(s: \"ab\")\n/// \"AB\"\n/// >>> solve(s: \"#a@C\")\n///\
    \ \"#A@c\"\nfunc solve(s: String) -> String {\n    var newString = String()\n\
    \    let letters = s.characters.filter { String($0).rangeOfCharacter(from: CharacterSet.letters)\
    \ != nil }\n    if letters.count > 0 {\n        newString = s.characters.map {\n\
    \            if String($0).rangeOfCharacter(from: CharacterSet.letters) != nil\
    \ {\n                if String($0).lowercased() == String($0) {\n            \
    \        return Character(String($0).uppercased())\n                } else {\n\
    \                    return Character(String($0).lowercased())\n             \
    \   }\n            } else {\n                return $0\n            }\n      \
    \  }.map { String($0) }.joined()\n    } else {\n        newString = String(s.characters.reversed())\n\
    \    }\n    return newString\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int,\
    \ Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n\
    \    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n          \
    \  return false\n        }\n    }\n    return true\n}\n            \nassert(solve(s:\
    \ \"AsDf\") == \"aSdF\")\nassert(solve(s: \"1234\") == \"4321\")\nassert(solve(s:\
    \ \"ab\") == \"AB\")\nassert(solve(s: \"#a@C\") == \"#A@c\")\nassert(solve(s:\
    \ \"#AsdfW^45\") == \"#aSDFw^45\")\nassert(solve(s: \"#6@2\") == \"2@6#\")\nassert(solve(s:\
    \ \"#$a^D\") == \"#$A^d\")\nassert(solve(s: \"#ccc\") == \"#CCC\")"
  status: SyntaxError
  stderr: "/tmp/tmp1lfkp5pm.swift:16:75: error: cannot find 'CharacterSet' in scope\n\
    \    let letters = s.characters.filter { String($0).rangeOfCharacter(from: CharacterSet.letters)\
    \ != nil }\n                                                                 \
    \         ^~~~~~~~~~~~\n/tmp/tmp1lfkp5pm.swift:19:50: error: cannot find 'CharacterSet'\
    \ in scope\n            if String($0).rangeOfCharacter(from: CharacterSet.letters)\
    \ != nil {\n                                                 ^~~~~~~~~~~~\n/tmp/tmp1lfkp5pm.swift:30:30:\
    \ error: 'characters' is unavailable: Please use String directly\n        newString\
    \ = String(s.characters.reversed())\n                             ^~~~~~~~~~\n\
    Swift.String:5:16: note: 'characters' was obsoleted in Swift 5.0\n    public var\
    \ characters: String { get set }\n               ^\n"
  stdout: ''
  timestamp: 1659978812
- exit_code: 1
  program: "\n/// You are given a string s.\n/// if s[i] is a letter, reverse its\
    \ case from lower to upper or vise versa, \n/// otherwise keep it as it is.\n\
    /// If the string contains no letters, reverse the string.\n/// The function should\
    \ return the resulted string.\n/// Examples\n/// >>> solve(s: \"1234\")\n/// \"\
    4321\"\n/// >>> solve(s: \"ab\")\n/// \"AB\"\n/// >>> solve(s: \"#a@C\")\n///\
    \ \"#A@c\"\nfunc solve(s: String) -> String {\n    let letters = s.filter({ $0.isLetter\
    \ })\n    if letters.isEmpty {\n        return String(s.reversed())\n    }\n \
    \   var result = \"\"\n    for char in s {\n        if char.isLetter {\n     \
    \       if let newChar = char.switchedCase() {\n                result.append(newChar)\n\
    \            }\n        } else {\n            result.append(char)\n        }\n\
    \    }\n    return result\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(solve(s: \"\
    AsDf\") == \"aSdF\")\nassert(solve(s: \"1234\") == \"4321\")\nassert(solve(s:\
    \ \"ab\") == \"AB\")\nassert(solve(s: \"#a@C\") == \"#A@c\")\nassert(solve(s:\
    \ \"#AsdfW^45\") == \"#aSDFw^45\")\nassert(solve(s: \"#6@2\") == \"2@6#\")\nassert(solve(s:\
    \ \"#$a^D\") == \"#$A^d\")\nassert(solve(s: \"#ccc\") == \"#CCC\")"
  status: SyntaxError
  stderr: "/tmp/tmpvwx4t19r.swift:22:35: error: value of type 'Character' has no member\
    \ 'switchedCase'\n            if let newChar = char.switchedCase() {\n       \
    \                      ~~~~ ^~~~~~~~~~~~\n"
  stdout: ''
  timestamp: 1659978812
- exit_code: -4
  program: "\n/// You are given a string s.\n/// if s[i] is a letter, reverse its\
    \ case from lower to upper or vise versa, \n/// otherwise keep it as it is.\n\
    /// If the string contains no letters, reverse the string.\n/// The function should\
    \ return the resulted string.\n/// Examples\n/// >>> solve(s: \"1234\")\n/// \"\
    4321\"\n/// >>> solve(s: \"ab\")\n/// \"AB\"\n/// >>> solve(s: \"#a@C\")\n///\
    \ \"#A@c\"\nfunc solve(s: String) -> String {\n  var result = \"\"\n  for char\
    \ in s {\n    if char.isLetter {\n      result.append(char.isUppercase ? char.lowercased()\
    \ : char.uppercased())\n    } else {\n      result.append(char)\n    }\n  }\n\
    \  return result.isEmpty ? String(s.reversed()) : result\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(solve(s: \"AsDf\") == \"aSdF\")\nassert(solve(s: \"1234\"\
    ) == \"4321\")\nassert(solve(s: \"ab\") == \"AB\")\nassert(solve(s: \"#a@C\")\
    \ == \"#A@c\")\nassert(solve(s: \"#AsdfW^45\") == \"#aSDFw^45\")\nassert(solve(s:\
    \ \"#6@2\") == \"2@6#\")\nassert(solve(s: \"#$a^D\") == \"#$A^d\")\nassert(solve(s:\
    \ \"#ccc\") == \"#CCC\")"
  status: Exception
  stderr: 'tmpjt6mh72c/tmpjt6mh72c.swift:40: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002adbcc451c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002adbcc148b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002adbcc148988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002adbcc1477b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpjt6mh72c                        0x0000557a624068d7 <unavailable> + 6359

    5    libc.so.6                          0x00002adbcc63d460 __libc_start_main +
    245

    6    tmpjt6mh72c                        0x0000557a62406429 <unavailable> + 5161

    '
  stdout: ''
  timestamp: 1659978812
- exit_code: -4
  program: "\n/// You are given a string s.\n/// if s[i] is a letter, reverse its\
    \ case from lower to upper or vise versa, \n/// otherwise keep it as it is.\n\
    /// If the string contains no letters, reverse the string.\n/// The function should\
    \ return the resulted string.\n/// Examples\n/// >>> solve(s: \"1234\")\n/// \"\
    4321\"\n/// >>> solve(s: \"ab\")\n/// \"AB\"\n/// >>> solve(s: \"#a@C\")\n///\
    \ \"#A@c\"\nfunc solve(s: String) -> String {\n    return s.contains(\"[a-zA-Z]\"\
    ) ? String(s.reversed()) : String(s.lowercased().reversed().map({$0 == \"#\" ?\
    \ \"0\" : $0 == \"@\" ? \"0\" : $0 == \"a\" ? \"A\" : $0 == \"b\" ? \"B\" : $0\
    \ == \"c\" ? \"C\" : $0 == \"d\" ? \"D\" : $0 == \"e\" ? \"E\" : $0 == \"f\" ?\
    \ \"F\" : $0 == \"g\" ? \"G\" : $0 == \"h\" ? \"H\" : $0 == \"i\" ? \"I\" : $0\
    \ == \"j\" ? \"J\" : $0 == \"k\" ? \"K\" : $0 == \"l\" ? \"L\" : $0 == \"m\" ?\
    \ \"M\" : $0 == \"n\" ? \"N\" : $0 == \"o\" ? \"O\" : $0 == \"p\" ? \"P\" : $0\
    \ == \"q\" ? \"Q\" : $0 == \"r\" ? \"R\" : $0 == \"s\" ? \"S\" : $0 == \"t\" ?\
    \ \"T\" : $0 == \"u\" ? \"U\" : $0 == \"v\" ? \"V\" : $0 == \"w\" ? \"W\" : $0\
    \ == \"x\" ? \"X\" : $0 == \"y\" ? \"Y\" : $0 == \"z\" ? \"Z\" : $0}))\n}\n\n\n\
    func ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(solve(s: \"AsDf\") == \"aSdF\")\nassert(solve(s:\
    \ \"1234\") == \"4321\")\nassert(solve(s: \"ab\") == \"AB\")\nassert(solve(s:\
    \ \"#a@C\") == \"#A@c\")\nassert(solve(s: \"#AsdfW^45\") == \"#aSDFw^45\")\nassert(solve(s:\
    \ \"#6@2\") == \"2@6#\")\nassert(solve(s: \"#$a^D\") == \"#$A^d\")\nassert(solve(s:\
    \ \"#ccc\") == \"#CCC\")"
  status: Exception
  stderr: 'tmpk3j7gktj/tmpk3j7gktj.swift:31: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002ad8b9ba5c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002ad8b989cb6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002ad8b989c988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002ad8b989b7b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpk3j7gktj                        0x000056026f3c67c7 <unavailable> + 6087

    5    libc.so.6                          0x00002ad8b9d91460 __libc_start_main +
    245

    6    tmpk3j7gktj                        0x000056026f3c6409 <unavailable> + 5129

    '
  stdout: ''
  timestamp: 1659978812
- exit_code: 1
  program: "\n/// You are given a string s.\n/// if s[i] is a letter, reverse its\
    \ case from lower to upper or vise versa, \n/// otherwise keep it as it is.\n\
    /// If the string contains no letters, reverse the string.\n/// The function should\
    \ return the resulted string.\n/// Examples\n/// >>> solve(s: \"1234\")\n/// \"\
    4321\"\n/// >>> solve(s: \"ab\")\n/// \"AB\"\n/// >>> solve(s: \"#a@C\")\n///\
    \ \"#A@c\"\nfunc solve(s: String) -> String {\n  var s = Array(s)\n  var index\
    \ = 0\n  while index < s.count {\n    if s[index].isLetter {\n      s[index].toggle()\n\
    \    }\n    index += 1\n  }\n  return String(s)\n}\n\n\nfunc ==(left: [(Int, Int)],\
    \ right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n       \
    \ return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r\
    \ {\n            return false\n        }\n    }\n    return true\n}\n        \
    \    \nassert(solve(s: \"AsDf\") == \"aSdF\")\nassert(solve(s: \"1234\") == \"\
    4321\")\nassert(solve(s: \"ab\") == \"AB\")\nassert(solve(s: \"#a@C\") == \"#A@c\"\
    )\nassert(solve(s: \"#AsdfW^45\") == \"#aSDFw^45\")\nassert(solve(s: \"#6@2\"\
    ) == \"2@6#\")\nassert(solve(s: \"#$a^D\") == \"#$A^d\")\nassert(solve(s: \"#ccc\"\
    ) == \"#CCC\")"
  status: SyntaxError
  stderr: "/tmp/tmpkgtn5plb.swift:19:16: error: value of type 'String.Element' (aka\
    \ 'Character') has no member 'toggle'\n      s[index].toggle()\n      ~~~~~~~~\
    \ ^~~~~~\n"
  stdout: ''
  timestamp: 1659978812
- exit_code: 1
  program: "\n/// You are given a string s.\n/// if s[i] is a letter, reverse its\
    \ case from lower to upper or vise versa, \n/// otherwise keep it as it is.\n\
    /// If the string contains no letters, reverse the string.\n/// The function should\
    \ return the resulted string.\n/// Examples\n/// >>> solve(s: \"1234\")\n/// \"\
    4321\"\n/// >>> solve(s: \"ab\")\n/// \"AB\"\n/// >>> solve(s: \"#a@C\")\n///\
    \ \"#A@c\"\nfunc solve(s: String) -> String {\n    var str = \"\"\n    var flag\
    \ = false\n    for i in s {\n        if i.isLetter {\n            flag = true\n\
    \            if i.lowercased() == i {\n                str.append(i.uppercased())\n\
    \            } else {\n                str.append(i.lowercased())\n          \
    \  }\n        } else {\n            str.append(i)\n        }\n    }\n    if flag\
    \ {\n        return str\n    } else {\n        return String(str.reversed())\n\
    \    }\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n  \
    \  if left.count != right.count {\n        return false\n    }\n    for (l, r)\
    \ in zip(left, right) {\n        if l != r {\n            return false\n     \
    \   }\n    }\n    return true\n}\n            \nassert(solve(s: \"AsDf\") == \"\
    aSdF\")\nassert(solve(s: \"1234\") == \"4321\")\nassert(solve(s: \"ab\") == \"\
    AB\")\nassert(solve(s: \"#a@C\") == \"#A@c\")\nassert(solve(s: \"#AsdfW^45\")\
    \ == \"#aSDFw^45\")\nassert(solve(s: \"#6@2\") == \"2@6#\")\nassert(solve(s: \"\
    #$a^D\") == \"#$A^d\")\nassert(solve(s: \"#ccc\") == \"#CCC\")"
  status: SyntaxError
  stderr: "/tmp/tmpckgmz0va.swift:20:31: error: binary operator '==' cannot be applied\
    \ to operands of type 'String' and 'Character'\n            if i.lowercased()\
    \ == i {\n               ~~~~~~~~~~~~~~ ^  ~\n/tmp/tmpckgmz0va.swift:20:31: note:\
    \ overloads for '==' exist with these partially matching parameter lists: (Character,\
    \ Character), (String, String)\n            if i.lowercased() == i {\n       \
    \                       ^\n"
  stdout: ''
  timestamp: 1659978812
- exit_code: 0
  program: "\n/// You are given a string s.\n/// if s[i] is a letter, reverse its\
    \ case from lower to upper or vise versa, \n/// otherwise keep it as it is.\n\
    /// If the string contains no letters, reverse the string.\n/// The function should\
    \ return the resulted string.\n/// Examples\n/// >>> solve(s: \"1234\")\n/// \"\
    4321\"\n/// >>> solve(s: \"ab\")\n/// \"AB\"\n/// >>> solve(s: \"#a@C\")\n///\
    \ \"#A@c\"\nfunc solve(s: String) -> String {\n    var letters = [Character]()\n\
    \    var nonLetters = [Character]()\n    var string = \"\"\n    var result = \"\
    \"\n    for char in s {\n        if char.isLetter {\n            letters.append(char)\n\
    \        } else {\n            nonLetters.append(char)\n        }\n    }\n   \
    \ if letters.count == 0 {\n        for char in s {\n            result += String(char)\n\
    \        }\n        return String(result.reversed())\n    }\n    for char in letters\
    \ {\n        if char.isUppercase {\n            string += String(char.lowercased())\n\
    \        } else {\n            string += String(char.uppercased())\n        }\n\
    \    }\n    var i = 0\n    var j = 0\n    for char in s {\n        if char.isLetter\
    \ {\n            result += String(string[string.index(string.startIndex, offsetBy:\
    \ i)])\n            i += 1\n        } else {\n            result += String(nonLetters[j])\n\
    \            j += 1\n        }\n    }\n    return result\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(solve(s: \"AsDf\") == \"aSdF\")\nassert(solve(s: \"1234\"\
    ) == \"4321\")\nassert(solve(s: \"ab\") == \"AB\")\nassert(solve(s: \"#a@C\")\
    \ == \"#A@c\")\nassert(solve(s: \"#AsdfW^45\") == \"#aSDFw^45\")\nassert(solve(s:\
    \ \"#6@2\") == \"2@6#\")\nassert(solve(s: \"#$a^D\") == \"#$A^d\")\nassert(solve(s:\
    \ \"#ccc\") == \"#CCC\")"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659978812
- exit_code: 1
  program: "\n/// You are given a string s.\n/// if s[i] is a letter, reverse its\
    \ case from lower to upper or vise versa, \n/// otherwise keep it as it is.\n\
    /// If the string contains no letters, reverse the string.\n/// The function should\
    \ return the resulted string.\n/// Examples\n/// >>> solve(s: \"1234\")\n/// \"\
    4321\"\n/// >>> solve(s: \"ab\")\n/// \"AB\"\n/// >>> solve(s: \"#a@C\")\n///\
    \ \"#A@c\"\nfunc solve(s: String) -> String {\n    guard !s.isEmpty else { return\
    \ s }\n    let upperLetters = s.filter { $0.isLetter && $0.isUppercase }\n   \
    \ guard !upperLetters.isEmpty else { return String(s.reversed()) }\n    return\
    \ String(s.reversed().map { $0.isLetter ? ($0.isUppercase ? $0.lowercased() :\
    \ $0.uppercased()) : $0 })\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(solve(s: \"\
    AsDf\") == \"aSdF\")\nassert(solve(s: \"1234\") == \"4321\")\nassert(solve(s:\
    \ \"ab\") == \"AB\")\nassert(solve(s: \"#a@C\") == \"#A@c\")\nassert(solve(s:\
    \ \"#AsdfW^45\") == \"#aSDFw^45\")\nassert(solve(s: \"#6@2\") == \"2@6#\")\nassert(solve(s:\
    \ \"#$a^D\") == \"#$A^d\")\nassert(solve(s: \"#ccc\") == \"#CCC\")"
  status: SyntaxError
  stderr: "/tmp/tmp2ke728sf.swift:18:68: error: result values in '? :' expression\
    \ have mismatching types 'String' and 'String.Element' (aka 'Character')\n   \
    \ return String(s.reversed().map { $0.isLetter ? ($0.isUppercase ? $0.lowercased()\
    \ : $0.uppercased()) : $0 })\n                                               \
    \    ~~~~~~~~~~~~~~~~^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n"
  stdout: ''
  timestamp: 1659978812
- exit_code: 0
  program: "\n/// You are given a string s.\n/// if s[i] is a letter, reverse its\
    \ case from lower to upper or vise versa, \n/// otherwise keep it as it is.\n\
    /// If the string contains no letters, reverse the string.\n/// The function should\
    \ return the resulted string.\n/// Examples\n/// >>> solve(s: \"1234\")\n/// \"\
    4321\"\n/// >>> solve(s: \"ab\")\n/// \"AB\"\n/// >>> solve(s: \"#a@C\")\n///\
    \ \"#A@c\"\nfunc solve(s: String) -> String {\n    let strArray = Array(s)\n \
    \   var result: String = \"\"\n    var hasLetter = false\n    for c in strArray\
    \ {\n        if c.isLetter {\n            hasLetter = true\n            if c.isLowercase\
    \ {\n                result.append(c.uppercased())\n            } else {\n   \
    \             result.append(c.lowercased())\n            }\n        } else {\n\
    \            result.append(c)\n        }\n    }\n    if !hasLetter {\n       \
    \ result = String(result.reversed())\n    }\n    return result\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(solve(s: \"AsDf\") == \"aSdF\")\nassert(solve(s: \"1234\"\
    ) == \"4321\")\nassert(solve(s: \"ab\") == \"AB\")\nassert(solve(s: \"#a@C\")\
    \ == \"#A@c\")\nassert(solve(s: \"#AsdfW^45\") == \"#aSDFw^45\")\nassert(solve(s:\
    \ \"#6@2\") == \"2@6#\")\nassert(solve(s: \"#$a^D\") == \"#$A^d\")\nassert(solve(s:\
    \ \"#ccc\") == \"#CCC\")"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659978812
- exit_code: 1
  program: "\n/// You are given a string s.\n/// if s[i] is a letter, reverse its\
    \ case from lower to upper or vise versa, \n/// otherwise keep it as it is.\n\
    /// If the string contains no letters, reverse the string.\n/// The function should\
    \ return the resulted string.\n/// Examples\n/// >>> solve(s: \"1234\")\n/// \"\
    4321\"\n/// >>> solve(s: \"ab\")\n/// \"AB\"\n/// >>> solve(s: \"#a@C\")\n///\
    \ \"#A@c\"\nfunc solve(s: String) -> String {\n\tvar newString = \"\"\n\tfor char\
    \ in s {\n\t\tvar newChar = char\n\t\tlet oldValue = char.asciiValue\n\t\tif oldValue\
    \ != nil {\n\t\t\tlet newValue = oldValue! + 32\n\t\t\tnewChar = Character(UnicodeScalar(newValue)!)\n\
    \t\t}\n\t\tnewString.append(newChar)\n\t}\n\treturn newString\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(solve(s: \"AsDf\") == \"aSdF\")\nassert(solve(s: \"1234\"\
    ) == \"4321\")\nassert(solve(s: \"ab\") == \"AB\")\nassert(solve(s: \"#a@C\")\
    \ == \"#A@c\")\nassert(solve(s: \"#AsdfW^45\") == \"#aSDFw^45\")\nassert(solve(s:\
    \ \"#6@2\") == \"2@6#\")\nassert(solve(s: \"#$a^D\") == \"#$A^d\")\nassert(solve(s:\
    \ \"#ccc\") == \"#CCC\")"
  status: SyntaxError
  stderr: "/tmp/tmpri7tyyup.swift:21:47: error: cannot force unwrap value of non-optional\
    \ type 'UnicodeScalar' (aka 'Unicode.Scalar')\n                        newChar\
    \ = Character(UnicodeScalar(newValue)!)\n                                    \
    \        ~~~~~~~~~~~~~~~~~~~~~~~^\n                                          \
    \                         \n"
  stdout: ''
  timestamp: 1659978812
- exit_code: 1
  program: "\n/// You are given a string s.\n/// if s[i] is a letter, reverse its\
    \ case from lower to upper or vise versa, \n/// otherwise keep it as it is.\n\
    /// If the string contains no letters, reverse the string.\n/// The function should\
    \ return the resulted string.\n/// Examples\n/// >>> solve(s: \"1234\")\n/// \"\
    4321\"\n/// >>> solve(s: \"ab\")\n/// \"AB\"\n/// >>> solve(s: \"#a@C\")\n///\
    \ \"#A@c\"\nfunc solve(s: String) -> String {\n    var result = \"\"\n    var\
    \ reversed = \"\"\n    for char in s {\n        let charString = String(char)\n\
    \        if charString.lowercased() == charString.uppercased() {\n           \
    \ reversed += charString\n        } else {\n            result += charString\n\
    \        }\n    }\n    return result.count == 0 ? String(reversed.reversed())\
    \ : result.reversed()\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(solve(s: \"\
    AsDf\") == \"aSdF\")\nassert(solve(s: \"1234\") == \"4321\")\nassert(solve(s:\
    \ \"ab\") == \"AB\")\nassert(solve(s: \"#a@C\") == \"#A@c\")\nassert(solve(s:\
    \ \"#AsdfW^45\") == \"#aSDFw^45\")\nassert(solve(s: \"#6@2\") == \"2@6#\")\nassert(solve(s:\
    \ \"#$a^D\") == \"#$A^d\")\nassert(solve(s: \"#ccc\") == \"#CCC\")"
  status: SyntaxError
  stderr: "/tmp/tmpdfz5s8bh.swift:25:30: error: cannot convert return expression of\
    \ type 'ReversedCollection<String>' to return type 'String'\n    return result.count\
    \ == 0 ? String(reversed.reversed()) : result.reversed()\n           ~~~~~~~~~~~~~~~~~~^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n"
  stdout: ''
  timestamp: 1659978812
- exit_code: -4
  program: "\n/// You are given a string s.\n/// if s[i] is a letter, reverse its\
    \ case from lower to upper or vise versa, \n/// otherwise keep it as it is.\n\
    /// If the string contains no letters, reverse the string.\n/// The function should\
    \ return the resulted string.\n/// Examples\n/// >>> solve(s: \"1234\")\n/// \"\
    4321\"\n/// >>> solve(s: \"ab\")\n/// \"AB\"\n/// >>> solve(s: \"#a@C\")\n///\
    \ \"#A@c\"\nfunc solve(s: String) -> String {\n    var str = \"\"\n    for i in\
    \ s {\n        switch i {\n        case \"a\"...\"z\":\n            str.append(i.uppercased())\n\
    \        case \"A\"...\"Z\":\n            str.append(i.lowercased())\n       \
    \ default:\n            str.append(i)\n        }\n    }\n    return str.count\
    \ > 0 ? str : String(s.reversed())\n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(solve(s: \"AsDf\") == \"aSdF\")\nassert(solve(s: \"1234\") == \"4321\"\
    )\nassert(solve(s: \"ab\") == \"AB\")\nassert(solve(s: \"#a@C\") == \"#A@c\")\n\
    assert(solve(s: \"#AsdfW^45\") == \"#aSDFw^45\")\nassert(solve(s: \"#6@2\") ==\
    \ \"2@6#\")\nassert(solve(s: \"#$a^D\") == \"#$A^d\")\nassert(solve(s: \"#ccc\"\
    ) == \"#CCC\")"
  status: Exception
  stderr: 'tmp4qfc69lo/tmp4qfc69lo.swift:43: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b9d2e9b0c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b9d2e6a7b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b9d2e6a7988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b9d2e6a67b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmp4qfc69lo                        0x0000562bbb73aa57 <unavailable> + 6743

    5    libc.so.6                          0x00002b9d2eb9c460 __libc_start_main +
    245

    6    tmp4qfc69lo                        0x0000562bbb73a5a9 <unavailable> + 5545

    '
  stdout: ''
  timestamp: 1659978812
- exit_code: 0
  program: "\n/// You are given a string s.\n/// if s[i] is a letter, reverse its\
    \ case from lower to upper or vise versa, \n/// otherwise keep it as it is.\n\
    /// If the string contains no letters, reverse the string.\n/// The function should\
    \ return the resulted string.\n/// Examples\n/// >>> solve(s: \"1234\")\n/// \"\
    4321\"\n/// >>> solve(s: \"ab\")\n/// \"AB\"\n/// >>> solve(s: \"#a@C\")\n///\
    \ \"#A@c\"\nfunc solve(s: String) -> String {\n    return s.contains { $0.isLetter\
    \ } ? String(s.map { $0.isLetter ? $0.isUppercase ? Character($0.lowercased())\
    \ : Character($0.uppercased()) : $0 }) : String(s.reversed())\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(solve(s: \"AsDf\") == \"aSdF\")\nassert(solve(s: \"1234\"\
    ) == \"4321\")\nassert(solve(s: \"ab\") == \"AB\")\nassert(solve(s: \"#a@C\")\
    \ == \"#A@c\")\nassert(solve(s: \"#AsdfW^45\") == \"#aSDFw^45\")\nassert(solve(s:\
    \ \"#6@2\") == \"2@6#\")\nassert(solve(s: \"#$a^D\") == \"#$A^d\")\nassert(solve(s:\
    \ \"#ccc\") == \"#CCC\")"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659978812
- exit_code: 1
  program: "\n/// You are given a string s.\n/// if s[i] is a letter, reverse its\
    \ case from lower to upper or vise versa, \n/// otherwise keep it as it is.\n\
    /// If the string contains no letters, reverse the string.\n/// The function should\
    \ return the resulted string.\n/// Examples\n/// >>> solve(s: \"1234\")\n/// \"\
    4321\"\n/// >>> solve(s: \"ab\")\n/// \"AB\"\n/// >>> solve(s: \"#a@C\")\n///\
    \ \"#A@c\"\nfunc solve(s: String) -> String {\n    guard s.rangeOfCharacter(from:\
    \ CharacterSet.letters) != nil else {\n        return String(s.reversed())\n \
    \   }\n    var result = \"\"\n    for ch in s {\n        if ch.isLetter {\n  \
    \          result.append(ch.isUppercase ? Character(ch.lowercased()) : Character(ch.uppercased()))\n\
    \        } else {\n            result.append(ch)\n        }\n    }\n    return\
    \ result\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n\
    \    if left.count != right.count {\n        return false\n    }\n    for (l,\
    \ r) in zip(left, right) {\n        if l != r {\n            return false\n  \
    \      }\n    }\n    return true\n}\n            \nassert(solve(s: \"AsDf\") ==\
    \ \"aSdF\")\nassert(solve(s: \"1234\") == \"4321\")\nassert(solve(s: \"ab\") ==\
    \ \"AB\")\nassert(solve(s: \"#a@C\") == \"#A@c\")\nassert(solve(s: \"#AsdfW^45\"\
    ) == \"#aSDFw^45\")\nassert(solve(s: \"#6@2\") == \"2@6#\")\nassert(solve(s: \"\
    #$a^D\") == \"#$A^d\")\nassert(solve(s: \"#ccc\") == \"#CCC\")"
  status: SyntaxError
  stderr: "/tmp/tmp5nf4g_fp.swift:15:36: error: cannot find 'CharacterSet' in scope\n\
    \    guard s.rangeOfCharacter(from: CharacterSet.letters) != nil else {\n    \
    \                               ^~~~~~~~~~~~\n/tmp/tmp5nf4g_fp.swift:15:13: error:\
    \ value of type 'String' has no member 'rangeOfCharacter'\n    guard s.rangeOfCharacter(from:\
    \ CharacterSet.letters) != nil else {\n          ~ ^~~~~~~~~~~~~~~~\n"
  stdout: ''
  timestamp: 1659978812
- exit_code: -4
  program: "\n/// You are given a string s.\n/// if s[i] is a letter, reverse its\
    \ case from lower to upper or vise versa, \n/// otherwise keep it as it is.\n\
    /// If the string contains no letters, reverse the string.\n/// The function should\
    \ return the resulted string.\n/// Examples\n/// >>> solve(s: \"1234\")\n/// \"\
    4321\"\n/// >>> solve(s: \"ab\")\n/// \"AB\"\n/// >>> solve(s: \"#a@C\")\n///\
    \ \"#A@c\"\nfunc solve(s: String) -> String {\n    return \"\"\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(solve(s: \"AsDf\") == \"aSdF\")\nassert(solve(s: \"1234\"\
    ) == \"4321\")\nassert(solve(s: \"ab\") == \"AB\")\nassert(solve(s: \"#a@C\")\
    \ == \"#A@c\")\nassert(solve(s: \"#AsdfW^45\") == \"#aSDFw^45\")\nassert(solve(s:\
    \ \"#6@2\") == \"2@6#\")\nassert(solve(s: \"#$a^D\") == \"#$A^d\")\nassert(solve(s:\
    \ \"#ccc\") == \"#CCC\")"
  status: Exception
  stderr: 'tmpiark_u6w/tmpiark_u6w.swift:31: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002aca5c89dc80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002aca5c594b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002aca5c594988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002aca5c5937b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpiark_u6w                        0x0000562c1ac34307 <unavailable> + 4871

    5    libc.so.6                          0x00002aca5ca89460 __libc_start_main +
    245

    6    tmpiark_u6w                        0x0000562c1ac33f49 <unavailable> + 3913

    '
  stdout: ''
  timestamp: 1659978811
- exit_code: 1
  program: "\n/// You are given a string s.\n/// if s[i] is a letter, reverse its\
    \ case from lower to upper or vise versa, \n/// otherwise keep it as it is.\n\
    /// If the string contains no letters, reverse the string.\n/// The function should\
    \ return the resulted string.\n/// Examples\n/// >>> solve(s: \"1234\")\n/// \"\
    4321\"\n/// >>> solve(s: \"ab\")\n/// \"AB\"\n/// >>> solve(s: \"#a@C\")\n///\
    \ \"#A@c\"\nfunc solve(s: String) -> String {\n  if s.containsAny(from: .letters)\
    \ {\n    return s.map { $0.isLetter ? $0.changeCase() : $0 }.joined()\n  } else\
    \ {\n    return String(s.reversed())\n  }\n}\n\n\nfunc ==(left: [(Int, Int)],\
    \ right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n       \
    \ return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r\
    \ {\n            return false\n        }\n    }\n    return true\n}\n        \
    \    \nassert(solve(s: \"AsDf\") == \"aSdF\")\nassert(solve(s: \"1234\") == \"\
    4321\")\nassert(solve(s: \"ab\") == \"AB\")\nassert(solve(s: \"#a@C\") == \"#A@c\"\
    )\nassert(solve(s: \"#AsdfW^45\") == \"#aSDFw^45\")\nassert(solve(s: \"#6@2\"\
    ) == \"2@6#\")\nassert(solve(s: \"#$a^D\") == \"#$A^d\")\nassert(solve(s: \"#ccc\"\
    ) == \"#CCC\")"
  status: SyntaxError
  stderr: "/tmp/tmp4gywx77_.swift:15:8: error: value of type 'String' has no member\
    \ 'containsAny'\n  if s.containsAny(from: .letters) {\n     ~ ^~~~~~~~~~~\n/tmp/tmp4gywx77_.swift:15:27:\
    \ error: cannot infer contextual base in reference to member 'letters'\n  if s.containsAny(from:\
    \ .letters) {\n                         ~^~~~~~~\n/tmp/tmp4gywx77_.swift:16:37:\
    \ error: value of type 'String.Element' (aka 'Character') has no member 'changeCase'\n\
    \    return s.map { $0.isLetter ? $0.changeCase() : $0 }.joined()\n          \
    \                       ~~ ^~~~~~~~~~\n/tmp/tmp4gywx77_.swift:16:32: error: cannot\
    \ convert value of type 'String.Element' (aka 'Character') to closure result type\
    \ 'String'\n    return s.map { $0.isLetter ? $0.changeCase() : $0 }.joined()\n\
    \                   ~~~~~~~~~~~~^~~~~~~~~~~~~~~~~~~~~~\n"
  stdout: ''
  timestamp: 1659978812
- exit_code: -4
  program: "\n/// You are given a string s.\n/// if s[i] is a letter, reverse its\
    \ case from lower to upper or vise versa, \n/// otherwise keep it as it is.\n\
    /// If the string contains no letters, reverse the string.\n/// The function should\
    \ return the resulted string.\n/// Examples\n/// >>> solve(s: \"1234\")\n/// \"\
    4321\"\n/// >>> solve(s: \"ab\")\n/// \"AB\"\n/// >>> solve(s: \"#a@C\")\n///\
    \ \"#A@c\"\nfunc solve(s: String) -> String {\n    let letters = Set(\"abcdefghijklmnopqrstuvwxyz\"\
    .uppercased())\n    let numbers = Set(\"0123456789\")\n    var result = \"\"\n\
    \    var reverse = false\n    for c in s {\n        if letters.contains(c) {\n\
    \            reverse = true\n            result.append(c.isUppercase ? c.lowercased()\
    \ : c.uppercased())\n        } else if numbers.contains(c) {\n            reverse\
    \ = true\n            result.append(c)\n        } else {\n            result.append(c)\n\
    \        }\n    }\n    return reverse ? String(result.reversed()) : result\n}\n\
    \n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(solve(s: \"AsDf\") == \"aSdF\")\nassert(solve(s:\
    \ \"1234\") == \"4321\")\nassert(solve(s: \"ab\") == \"AB\")\nassert(solve(s:\
    \ \"#a@C\") == \"#A@c\")\nassert(solve(s: \"#AsdfW^45\") == \"#aSDFw^45\")\nassert(solve(s:\
    \ \"#6@2\") == \"2@6#\")\nassert(solve(s: \"#$a^D\") == \"#$A^d\")\nassert(solve(s:\
    \ \"#ccc\") == \"#CCC\")"
  status: Exception
  stderr: 'tmpz3hrxm92/tmpz3hrxm92.swift:46: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002ba171cc9c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002ba1719c0b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002ba1719c0988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002ba1719bf7b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpz3hrxm92                        0x00005593ba9ac917 <unavailable> + 6423

    5    libc.so.6                          0x00002ba171eb5460 __libc_start_main +
    245

    6    tmpz3hrxm92                        0x00005593ba9ac559 <unavailable> + 5465

    '
  stdout: ''
  timestamp: 1659978812
- exit_code: 1
  program: "\n/// You are given a string s.\n/// if s[i] is a letter, reverse its\
    \ case from lower to upper or vise versa, \n/// otherwise keep it as it is.\n\
    /// If the string contains no letters, reverse the string.\n/// The function should\
    \ return the resulted string.\n/// Examples\n/// >>> solve(s: \"1234\")\n/// \"\
    4321\"\n/// >>> solve(s: \"ab\")\n/// \"AB\"\n/// >>> solve(s: \"#a@C\")\n///\
    \ \"#A@c\"\nfunc solve(s: String) -> String {\n    guard s.count > 0 else { return\
    \ \"\" }\n    guard s.rangeOfCharacter(from: CharacterSet.letters) != nil else\
    \ {\n        return String(s.reversed())\n    }\n    var res = \"\"\n    for ch\
    \ in s {\n        let string = String(ch)\n        if string.rangeOfCharacter(from:\
    \ CharacterSet.letters) != nil {\n            res += (string == string.uppercased())\
    \ ? string.lowercased() : string.uppercased()\n        } else {\n            res\
    \ += string\n        }\n    }\n    return res\n}\n\n\nfunc ==(left: [(Int, Int)],\
    \ right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n       \
    \ return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r\
    \ {\n            return false\n        }\n    }\n    return true\n}\n        \
    \    \nassert(solve(s: \"AsDf\") == \"aSdF\")\nassert(solve(s: \"1234\") == \"\
    4321\")\nassert(solve(s: \"ab\") == \"AB\")\nassert(solve(s: \"#a@C\") == \"#A@c\"\
    )\nassert(solve(s: \"#AsdfW^45\") == \"#aSDFw^45\")\nassert(solve(s: \"#6@2\"\
    ) == \"2@6#\")\nassert(solve(s: \"#$a^D\") == \"#$A^d\")\nassert(solve(s: \"#ccc\"\
    ) == \"#CCC\")"
  status: SyntaxError
  stderr: "/tmp/tmpf9p2hinu.swift:16:36: error: cannot find 'CharacterSet' in scope\n\
    \    guard s.rangeOfCharacter(from: CharacterSet.letters) != nil else {\n    \
    \                               ^~~~~~~~~~~~\n/tmp/tmpf9p2hinu.swift:16:13: error:\
    \ value of type 'String' has no member 'rangeOfCharacter'\n    guard s.rangeOfCharacter(from:\
    \ CharacterSet.letters) != nil else {\n          ~ ^~~~~~~~~~~~~~~~\n/tmp/tmpf9p2hinu.swift:22:42:\
    \ error: cannot find 'CharacterSet' in scope\n        if string.rangeOfCharacter(from:\
    \ CharacterSet.letters) != nil {\n                                         ^~~~~~~~~~~~\n\
    /tmp/tmpf9p2hinu.swift:22:19: error: value of type 'String' has no member 'rangeOfCharacter'\n\
    \        if string.rangeOfCharacter(from: CharacterSet.letters) != nil {\n   \
    \        ~~~~~~ ^~~~~~~~~~~~~~~~\n"
  stdout: ''
  timestamp: 1659978812
- exit_code: 1
  program: "\n/// You are given a string s.\n/// if s[i] is a letter, reverse its\
    \ case from lower to upper or vise versa, \n/// otherwise keep it as it is.\n\
    /// If the string contains no letters, reverse the string.\n/// The function should\
    \ return the resulted string.\n/// Examples\n/// >>> solve(s: \"1234\")\n/// \"\
    4321\"\n/// >>> solve(s: \"ab\")\n/// \"AB\"\n/// >>> solve(s: \"#a@C\")\n///\
    \ \"#A@c\"\nfunc solve(s: String) -> String {\n    var s = s\n    if s.first ==\
    \ nil {\n        return s\n    }\n    if s.first?.isLetter == false {\n      \
    \  s = String(s.reversed())\n    } else {\n        s = s.map { $0.isLetter ? $0.isUppercase\
    \ ? $0.lowercased() : $0.uppercased() : $0 }\n    }\n    return s\n}\n\n\nfunc\
    \ ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count !=\
    \ right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(solve(s: \"AsDf\") == \"aSdF\")\nassert(solve(s:\
    \ \"1234\") == \"4321\")\nassert(solve(s: \"ab\") == \"AB\")\nassert(solve(s:\
    \ \"#a@C\") == \"#A@c\")\nassert(solve(s: \"#AsdfW^45\") == \"#aSDFw^45\")\nassert(solve(s:\
    \ \"#6@2\") == \"2@6#\")\nassert(solve(s: \"#$a^D\") == \"#$A^d\")\nassert(solve(s:\
    \ \"#ccc\") == \"#CCC\")"
  status: SyntaxError
  stderr: "/tmp/tmpprryhush.swift:22:15: error: cannot assign value of type '[String.Element]'\
    \ (aka 'Array<Character>') to type 'String'\n        s = s.map { $0.isLetter ?\
    \ $0.isUppercase ? $0.lowercased() : $0.uppercased() : $0 }\n            ~~^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n\
    /tmp/tmpprryhush.swift:22:50: error: result values in '? :' expression have mismatching\
    \ types 'String' and 'String.Element' (aka 'Character')\n        s = s.map { $0.isLetter\
    \ ? $0.isUppercase ? $0.lowercased() : $0.uppercased() : $0 }\n              \
    \                    ~~~~~~~~~~~~~~~^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n"
  stdout: ''
  timestamp: 1659978812
- exit_code: 1
  program: "\n/// You are given a string s.\n/// if s[i] is a letter, reverse its\
    \ case from lower to upper or vise versa, \n/// otherwise keep it as it is.\n\
    /// If the string contains no letters, reverse the string.\n/// The function should\
    \ return the resulted string.\n/// Examples\n/// >>> solve(s: \"1234\")\n/// \"\
    4321\"\n/// >>> solve(s: \"ab\")\n/// \"AB\"\n/// >>> solve(s: \"#a@C\")\n///\
    \ \"#A@c\"\nfunc solve(s: String) -> String {\n    var temp: String = \"\"\n \
    \   if !s.containsLetters {\n        for i in s.reversed() {\n            temp.append(i)\n\
    \        }\n        return temp\n    }\n    for char in s {\n        if char.isLetter\
    \ {\n            if char.isUppercase {\n                temp.append(char.lowercased())\n\
    \            } else {\n                temp.append(char.uppercased())\n      \
    \      }\n        } else {\n            temp.append(char)\n        }\n    }\n\
    \    return temp\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool\
    \ {\n    if left.count != right.count {\n        return false\n    }\n    for\
    \ (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(solve(s: \"AsDf\"\
    ) == \"aSdF\")\nassert(solve(s: \"1234\") == \"4321\")\nassert(solve(s: \"ab\"\
    ) == \"AB\")\nassert(solve(s: \"#a@C\") == \"#A@c\")\nassert(solve(s: \"#AsdfW^45\"\
    ) == \"#aSDFw^45\")\nassert(solve(s: \"#6@2\") == \"2@6#\")\nassert(solve(s: \"\
    #$a^D\") == \"#$A^d\")\nassert(solve(s: \"#ccc\") == \"#CCC\")"
  status: SyntaxError
  stderr: "/tmp/tmp2sj2ahqj.swift:16:11: error: value of type 'String' has no member\
    \ 'containsLetters'\n    if !s.containsLetters {\n        ~ ^~~~~~~~~~~~~~~\n"
  stdout: ''
  timestamp: 1659978812
- exit_code: 1
  program: "\n/// You are given a string s.\n/// if s[i] is a letter, reverse its\
    \ case from lower to upper or vise versa, \n/// otherwise keep it as it is.\n\
    /// If the string contains no letters, reverse the string.\n/// The function should\
    \ return the resulted string.\n/// Examples\n/// >>> solve(s: \"1234\")\n/// \"\
    4321\"\n/// >>> solve(s: \"ab\")\n/// \"AB\"\n/// >>> solve(s: \"#a@C\")\n///\
    \ \"#A@c\"\nfunc solve(s: String) -> String {\n    let a = Array(s.characters)\n\
    \    var x = \"\"\n    var all = false\n    for i in a {\n        if all {\n \
    \           x += String(i)\n        } else {\n            if i.isLetter {\n  \
    \              if i.isUppercase {\n                    x += String(i).lowercased()\n\
    \                } else {\n                    x += String(i).uppercased()\n \
    \               }\n            } else {\n                all = true\n        \
    \        x += String(i)\n            }\n        }\n    }\n    return String(x.characters.reversed())\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(solve(s: \"AsDf\") == \"aSdF\")\nassert(solve(s:\
    \ \"1234\") == \"4321\")\nassert(solve(s: \"ab\") == \"AB\")\nassert(solve(s:\
    \ \"#a@C\") == \"#A@c\")\nassert(solve(s: \"#AsdfW^45\") == \"#aSDFw^45\")\nassert(solve(s:\
    \ \"#6@2\") == \"2@6#\")\nassert(solve(s: \"#$a^D\") == \"#$A^d\")\nassert(solve(s:\
    \ \"#ccc\") == \"#CCC\")"
  status: SyntaxError
  stderr: "/tmp/tmpipfpkwje.swift:15:21: error: 'characters' is unavailable: Please\
    \ use String directly\n    let a = Array(s.characters)\n                    ^~~~~~~~~~\n\
    Swift.String:5:16: note: 'characters' was obsoleted in Swift 5.0\n    public var\
    \ characters: String { get set }\n               ^\n/tmp/tmpipfpkwje.swift:34:21:\
    \ error: 'characters' is unavailable: Please use String directly\n    return String(x.characters.reversed())\n\
    \                    ^~~~~~~~~~\nSwift.String:5:16: note: 'characters' was obsoleted\
    \ in Swift 5.0\n    public var characters: String { get set }\n              \
    \ ^\n"
  stdout: ''
  timestamp: 1659978812
- exit_code: -4
  program: "\n/// You are given a string s.\n/// if s[i] is a letter, reverse its\
    \ case from lower to upper or vise versa, \n/// otherwise keep it as it is.\n\
    /// If the string contains no letters, reverse the string.\n/// The function should\
    \ return the resulted string.\n/// Examples\n/// >>> solve(s: \"1234\")\n/// \"\
    4321\"\n/// >>> solve(s: \"ab\")\n/// \"AB\"\n/// >>> solve(s: \"#a@C\")\n///\
    \ \"#A@c\"\nfunc solve(s: String) -> String {\n    return \"\"\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(solve(s: \"AsDf\") == \"aSdF\")\nassert(solve(s: \"1234\"\
    ) == \"4321\")\nassert(solve(s: \"ab\") == \"AB\")\nassert(solve(s: \"#a@C\")\
    \ == \"#A@c\")\nassert(solve(s: \"#AsdfW^45\") == \"#aSDFw^45\")\nassert(solve(s:\
    \ \"#6@2\") == \"2@6#\")\nassert(solve(s: \"#$a^D\") == \"#$A^d\")\nassert(solve(s:\
    \ \"#ccc\") == \"#CCC\")"
  status: Exception
  stderr: 'tmpiark_u6w/tmpiark_u6w.swift:31: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002aca5c89dc80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002aca5c594b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002aca5c594988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002aca5c5937b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpiark_u6w                        0x0000562c1ac34307 <unavailable> + 4871

    5    libc.so.6                          0x00002aca5ca89460 __libc_start_main +
    245

    6    tmpiark_u6w                        0x0000562c1ac33f49 <unavailable> + 3913

    '
  stdout: ''
  timestamp: 1659978811
- exit_code: 1
  program: "\n/// You are given a string s.\n/// if s[i] is a letter, reverse its\
    \ case from lower to upper or vise versa, \n/// otherwise keep it as it is.\n\
    /// If the string contains no letters, reverse the string.\n/// The function should\
    \ return the resulted string.\n/// Examples\n/// >>> solve(s: \"1234\")\n/// \"\
    4321\"\n/// >>> solve(s: \"ab\")\n/// \"AB\"\n/// >>> solve(s: \"#a@C\")\n///\
    \ \"#A@c\"\nfunc solve(s: String) -> String {\n    let letters = Set<Character>(\"\
    abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ\")\n    let lettersAndNot\
    \ = s.filter { !letters.contains($0) }\n    if lettersAndNot == s {\n        return\
    \ String(s.reversed())\n    }\n    var result = \"\"\n    for letter in s {\n\
    \        if letters.contains(letter) {\n            result += String(letter.toggled())\n\
    \        } else {\n            result += String(letter)\n        }\n    }\n  \
    \  return result\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool\
    \ {\n    if left.count != right.count {\n        return false\n    }\n    for\
    \ (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(solve(s: \"AsDf\"\
    ) == \"aSdF\")\nassert(solve(s: \"1234\") == \"4321\")\nassert(solve(s: \"ab\"\
    ) == \"AB\")\nassert(solve(s: \"#a@C\") == \"#A@c\")\nassert(solve(s: \"#AsdfW^45\"\
    ) == \"#aSDFw^45\")\nassert(solve(s: \"#6@2\") == \"2@6#\")\nassert(solve(s: \"\
    #$a^D\") == \"#$A^d\")\nassert(solve(s: \"#ccc\") == \"#CCC\")"
  status: SyntaxError
  stderr: "/tmp/tmp_25g9omv.swift:23:37: error: value of type 'Character' has no member\
    \ 'toggled'\n            result += String(letter.toggled())\n                \
    \             ~~~~~~ ^~~~~~~\n"
  stdout: ''
  timestamp: 1659978812
- exit_code: -4
  program: "\n/// You are given a string s.\n/// if s[i] is a letter, reverse its\
    \ case from lower to upper or vise versa, \n/// otherwise keep it as it is.\n\
    /// If the string contains no letters, reverse the string.\n/// The function should\
    \ return the resulted string.\n/// Examples\n/// >>> solve(s: \"1234\")\n/// \"\
    4321\"\n/// >>> solve(s: \"ab\")\n/// \"AB\"\n/// >>> solve(s: \"#a@C\")\n///\
    \ \"#A@c\"\nfunc solve(s: String) -> String {\n\t// your code here\n\treturn \"\
    \"\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if\
    \ left.count != right.count {\n        return false\n    }\n    for (l, r) in\
    \ zip(left, right) {\n        if l != r {\n            return false\n        }\n\
    \    }\n    return true\n}\n            \nassert(solve(s: \"AsDf\") == \"aSdF\"\
    )\nassert(solve(s: \"1234\") == \"4321\")\nassert(solve(s: \"ab\") == \"AB\")\n\
    assert(solve(s: \"#a@C\") == \"#A@c\")\nassert(solve(s: \"#AsdfW^45\") == \"#aSDFw^45\"\
    )\nassert(solve(s: \"#6@2\") == \"2@6#\")\nassert(solve(s: \"#$a^D\") == \"#$A^d\"\
    )\nassert(solve(s: \"#ccc\") == \"#CCC\")"
  status: Exception
  stderr: 'tmpj60304_0/tmpj60304_0.swift:32: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b0c3534ac80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b0c35041b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b0c35041988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b0c350407b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpj60304_0                        0x000055aa08180307 <unavailable> + 4871

    5    libc.so.6                          0x00002b0c35536460 __libc_start_main +
    245

    6    tmpj60304_0                        0x000055aa0817ff49 <unavailable> + 3913

    '
  stdout: ''
  timestamp: 1659978812
- exit_code: -4
  program: "\n/// You are given a string s.\n/// if s[i] is a letter, reverse its\
    \ case from lower to upper or vise versa, \n/// otherwise keep it as it is.\n\
    /// If the string contains no letters, reverse the string.\n/// The function should\
    \ return the resulted string.\n/// Examples\n/// >>> solve(s: \"1234\")\n/// \"\
    4321\"\n/// >>> solve(s: \"ab\")\n/// \"AB\"\n/// >>> solve(s: \"#a@C\")\n///\
    \ \"#A@c\"\nfunc solve(s: String) -> String {\n    var solution: String = \"\"\
    \n    for char in s {\n        if char.isLetter {\n            solution.append(char.isUppercase\
    \ ? char.lowercased() : char.uppercased())\n        } else {\n            solution.append(char)\n\
    \        }\n    }\n    return solution.isEmpty ? String(s.reversed()) : solution\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(solve(s: \"AsDf\") == \"aSdF\")\nassert(solve(s:\
    \ \"1234\") == \"4321\")\nassert(solve(s: \"ab\") == \"AB\")\nassert(solve(s:\
    \ \"#a@C\") == \"#A@c\")\nassert(solve(s: \"#AsdfW^45\") == \"#aSDFw^45\")\nassert(solve(s:\
    \ \"#6@2\") == \"2@6#\")\nassert(solve(s: \"#$a^D\") == \"#$A^d\")\nassert(solve(s:\
    \ \"#ccc\") == \"#CCC\")"
  status: Exception
  stderr: 'tmp68i5gyof/tmp68i5gyof.swift:40: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b22c6248c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b22c5f3fb6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b22c5f3f988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b22c5f3e7b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmp68i5gyof                        0x00005651079538d7 <unavailable> + 6359

    5    libc.so.6                          0x00002b22c6434460 __libc_start_main +
    245

    6    tmp68i5gyof                        0x0000565107953429 <unavailable> + 5161

    '
  stdout: ''
  timestamp: 1659978812
- exit_code: 1
  program: "\n/// You are given a string s.\n/// if s[i] is a letter, reverse its\
    \ case from lower to upper or vise versa, \n/// otherwise keep it as it is.\n\
    /// If the string contains no letters, reverse the string.\n/// The function should\
    \ return the resulted string.\n/// Examples\n/// >>> solve(s: \"1234\")\n/// \"\
    4321\"\n/// >>> solve(s: \"ab\")\n/// \"AB\"\n/// >>> solve(s: \"#a@C\")\n///\
    \ \"#A@c\"\nfunc solve(s: String) -> String {\n    return s.replacingOccurrences(of:\
    \ \"[a-zA-Z]\", with: \"$0\", options: .regularExpression).uppercased()\n}\n\n\
    \nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(solve(s: \"AsDf\") == \"aSdF\")\nassert(solve(s:\
    \ \"1234\") == \"4321\")\nassert(solve(s: \"ab\") == \"AB\")\nassert(solve(s:\
    \ \"#a@C\") == \"#A@c\")\nassert(solve(s: \"#AsdfW^45\") == \"#aSDFw^45\")\nassert(solve(s:\
    \ \"#6@2\") == \"2@6#\")\nassert(solve(s: \"#$a^D\") == \"#$A^d\")\nassert(solve(s:\
    \ \"#ccc\") == \"#CCC\")"
  status: SyntaxError
  stderr: "/tmp/tmpx2gxz9pk.swift:15:14: error: value of type 'String' has no member\
    \ 'replacingOccurrences'\n    return s.replacingOccurrences(of: \"[a-zA-Z]\",\
    \ with: \"$0\", options: .regularExpression).uppercased()\n           ~ ^~~~~~~~~~~~~~~~~~~~\n\
    /tmp/tmpx2gxz9pk.swift:15:73: error: cannot infer contextual base in reference\
    \ to member 'regularExpression'\n    return s.replacingOccurrences(of: \"[a-zA-Z]\"\
    , with: \"$0\", options: .regularExpression).uppercased()\n                  \
    \                                                     ~^~~~~~~~~~~~~~~~~\n"
  stdout: ''
  timestamp: 1659978812
- exit_code: 1
  program: "\n/// You are given a string s.\n/// if s[i] is a letter, reverse its\
    \ case from lower to upper or vise versa, \n/// otherwise keep it as it is.\n\
    /// If the string contains no letters, reverse the string.\n/// The function should\
    \ return the resulted string.\n/// Examples\n/// >>> solve(s: \"1234\")\n/// \"\
    4321\"\n/// >>> solve(s: \"ab\")\n/// \"AB\"\n/// >>> solve(s: \"#a@C\")\n///\
    \ \"#A@c\"\nfunc solve(s: String) -> String {\n    let arr = s.compactMap { \"\
    \\($0)\".unicodeScalars.first?.value }\n    let res = arr.isEmpty ? Array(s.reversed())\
    \ :\n        arr.map { Int($0) > 96 && Int($0) < 123 ? String(UnicodeScalar(Int($0)\
    \ - 32)!) :\n                Int($0) > 64 && Int($0) < 91 ? String(UnicodeScalar(Int($0)\
    \ + 32)!) : \"\\($0)\" }\n    return String(res)\n}\n\n\nfunc ==(left: [(Int,\
    \ Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n\
    \        return false\n    }\n    for (l, r) in zip(left, right) {\n        if\
    \ l != r {\n            return false\n        }\n    }\n    return true\n}\n \
    \           \nassert(solve(s: \"AsDf\") == \"aSdF\")\nassert(solve(s: \"1234\"\
    ) == \"4321\")\nassert(solve(s: \"ab\") == \"AB\")\nassert(solve(s: \"#a@C\")\
    \ == \"#A@c\")\nassert(solve(s: \"#AsdfW^45\") == \"#aSDFw^45\")\nassert(solve(s:\
    \ \"#6@2\") == \"2@6#\")\nassert(solve(s: \"#$a^D\") == \"#$A^d\")\nassert(solve(s:\
    \ \"#ccc\") == \"#CCC\")"
  status: SyntaxError
  stderr: "/tmp/tmp6eu39y1r.swift:17:49: error: cannot convert value of type 'String'\
    \ to closure result type 'ReversedCollection<String>.Element' (aka 'Character')\n\
    \        arr.map { Int($0) > 96 && Int($0) < 123 ? String(UnicodeScalar(Int($0)\
    \ - 32)!) :\n                  ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n"
  stdout: ''
  timestamp: 1659978813
- exit_code: -4
  program: "\n/// You are given a string s.\n/// if s[i] is a letter, reverse its\
    \ case from lower to upper or vise versa, \n/// otherwise keep it as it is.\n\
    /// If the string contains no letters, reverse the string.\n/// The function should\
    \ return the resulted string.\n/// Examples\n/// >>> solve(s: \"1234\")\n/// \"\
    4321\"\n/// >>> solve(s: \"ab\")\n/// \"AB\"\n/// >>> solve(s: \"#a@C\")\n///\
    \ \"#A@c\"\nfunc solve(s: String) -> String {\n    var str = \"\"\n    for char\
    \ in s {\n        if char.isLetter {\n            str.append(char.isLowercase\
    \ ? char.uppercased() : char.lowercased())\n        } else {\n            str.append(char)\n\
    \        }\n    }\n    return str.isEmpty ? String(s.reversed()) : str\n}\n\n\n\
    func ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(solve(s: \"AsDf\") == \"aSdF\")\nassert(solve(s:\
    \ \"1234\") == \"4321\")\nassert(solve(s: \"ab\") == \"AB\")\nassert(solve(s:\
    \ \"#a@C\") == \"#A@c\")\nassert(solve(s: \"#AsdfW^45\") == \"#aSDFw^45\")\nassert(solve(s:\
    \ \"#6@2\") == \"2@6#\")\nassert(solve(s: \"#$a^D\") == \"#$A^d\")\nassert(solve(s:\
    \ \"#ccc\") == \"#CCC\")"
  status: Exception
  stderr: 'tmpms4wv951/tmpms4wv951.swift:40: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b4ff587dc80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b4ff5574b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b4ff5574988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b4ff55737b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpms4wv951                        0x000056536ac8c8d7 <unavailable> + 6359

    5    libc.so.6                          0x00002b4ff5a69460 __libc_start_main +
    245

    6    tmpms4wv951                        0x000056536ac8c429 <unavailable> + 5161

    '
  stdout: ''
  timestamp: 1659978812
- exit_code: 1
  program: "\n/// You are given a string s.\n/// if s[i] is a letter, reverse its\
    \ case from lower to upper or vise versa, \n/// otherwise keep it as it is.\n\
    /// If the string contains no letters, reverse the string.\n/// The function should\
    \ return the resulted string.\n/// Examples\n/// >>> solve(s: \"1234\")\n/// \"\
    4321\"\n/// >>> solve(s: \"ab\")\n/// \"AB\"\n/// >>> solve(s: \"#a@C\")\n///\
    \ \"#A@c\"\nfunc solve(s: String) -> String {\n    let result = s.components(separatedBy:\
    \ [\"0\", \"1\", \"2\", \"3\", \"4\", \"5\", \"6\", \"7\", \"8\", \"9\"]).joined()\n\
    \    var finalString = \"\"\n    for char in result {\n        if char.isLetter\
    \ {\n            finalString.append(char.isUppercase ? char.lowercased() : char.uppercased())\n\
    \        } else {\n            finalString.append(char)\n        }\n    }\n  \
    \  return result.isEmpty ? s.reversed() : finalString\n}\n\n\nfunc ==(left: [(Int,\
    \ Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n\
    \        return false\n    }\n    for (l, r) in zip(left, right) {\n        if\
    \ l != r {\n            return false\n        }\n    }\n    return true\n}\n \
    \           \nassert(solve(s: \"AsDf\") == \"aSdF\")\nassert(solve(s: \"1234\"\
    ) == \"4321\")\nassert(solve(s: \"ab\") == \"AB\")\nassert(solve(s: \"#a@C\")\
    \ == \"#A@c\")\nassert(solve(s: \"#AsdfW^45\") == \"#aSDFw^45\")\nassert(solve(s:\
    \ \"#6@2\") == \"2@6#\")\nassert(solve(s: \"#$a^D\") == \"#$A^d\")\nassert(solve(s:\
    \ \"#ccc\") == \"#CCC\")"
  status: SyntaxError
  stderr: "/tmp/tmpscejf5gl.swift:15:20: error: value of type 'String' has no member\
    \ 'components'\n    let result = s.components(separatedBy: [\"0\", \"1\", \"2\"\
    , \"3\", \"4\", \"5\", \"6\", \"7\", \"8\", \"9\"]).joined()\n               \
    \  ~ ^~~~~~~~~~\n/tmp/tmpscejf5gl.swift:24:27: error: cannot convert return expression\
    \ of type 'ReversedCollection<String>' to return type 'String'\n    return result.isEmpty\
    \ ? s.reversed() : finalString\n           ~~~~~~~~~~~~~~~^~~~~~~~~~~~~~~~~~~~~~~~~~~~\n"
  stdout: ''
  timestamp: 1659978812
- exit_code: 1
  program: "\n/// You are given a string s.\n/// if s[i] is a letter, reverse its\
    \ case from lower to upper or vise versa, \n/// otherwise keep it as it is.\n\
    /// If the string contains no letters, reverse the string.\n/// The function should\
    \ return the resulted string.\n/// Examples\n/// >>> solve(s: \"1234\")\n/// \"\
    4321\"\n/// >>> solve(s: \"ab\")\n/// \"AB\"\n/// >>> solve(s: \"#a@C\")\n///\
    \ \"#A@c\"\nfunc solve(s: String) -> String {\n    var output = s\n    if !s.contains(\"\
    [a-zA-Z]\") {\n        output = String(s.reversed())\n    } else {\n        var\
    \ index = s.startIndex\n        while index < s.endIndex {\n            if s[index].isLetter\
    \ {\n                output.remove(at: index)\n                output.insert(s[index].uppercased(),\
    \ at: index)\n            }\n            index = s.index(after: index)\n     \
    \   }\n    }\n    return output\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int,\
    \ Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n\
    \    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n          \
    \  return false\n        }\n    }\n    return true\n}\n            \nassert(solve(s:\
    \ \"AsDf\") == \"aSdF\")\nassert(solve(s: \"1234\") == \"4321\")\nassert(solve(s:\
    \ \"ab\") == \"AB\")\nassert(solve(s: \"#a@C\") == \"#A@c\")\nassert(solve(s:\
    \ \"#AsdfW^45\") == \"#aSDFw^45\")\nassert(solve(s: \"#6@2\") == \"2@6#\")\nassert(solve(s:\
    \ \"#$a^D\") == \"#$A^d\")\nassert(solve(s: \"#ccc\") == \"#CCC\")"
  status: SyntaxError
  stderr: "/tmp/tmp65ljnq3d.swift:23:24: error: no exact matches in call to instance\
    \ method 'insert'\n                output.insert(s[index].uppercased(), at: index)\n\
    \                       ^\nSwift.String:13:26: note: incorrect labels for candidate\
    \ (have: '(_:at:)', expected: '(contentsOf:at:)')\n    public mutating func insert<S>(contentsOf\
    \ newElements: S, at i: String.Index) where S : Collection, S.Element == Character\n\
    \                         ^\nSwift.RangeReplaceableCollection:7:37: note: incorrect\
    \ labels for candidate (have: '(_:at:)', expected: '(contentsOf:at:)')\n    @inlinable\
    \ public mutating func insert<C>(contentsOf newElements: __owned C, at i: Self.Index)\
    \ where C : Collection, Self.Element == C.Element\n                          \
    \          ^\n"
  stdout: ''
  timestamp: 1659978812
- exit_code: -4
  program: "\n/// You are given a string s.\n/// if s[i] is a letter, reverse its\
    \ case from lower to upper or vise versa, \n/// otherwise keep it as it is.\n\
    /// If the string contains no letters, reverse the string.\n/// The function should\
    \ return the resulted string.\n/// Examples\n/// >>> solve(s: \"1234\")\n/// \"\
    4321\"\n/// >>> solve(s: \"ab\")\n/// \"AB\"\n/// >>> solve(s: \"#a@C\")\n///\
    \ \"#A@c\"\nfunc solve(s: String) -> String {\n    var charArray = [Character]()\n\
    \    let letters = Set(\"abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLKMNOPQRSTUVWXYZ\"\
    )\n    var res = \"\"\n    for char in s {\n        if letters.contains(char)\
    \ {\n            charArray.append(char)\n        }\n    }\n    if charArray.isEmpty\
    \ {\n        for i in s.reversed() {\n            res += String(i)\n        }\n\
    \    } else {\n        charArray = charArray.reversed()\n        var index = 0\n\
    \        for char in s {\n            if letters.contains(char) {\n          \
    \      res += String(charArray[index])\n                index += 1\n         \
    \   } else {\n                res += String(char)\n            }\n        }\n\
    \    }\n    return res\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(solve(s: \"\
    AsDf\") == \"aSdF\")\nassert(solve(s: \"1234\") == \"4321\")\nassert(solve(s:\
    \ \"ab\") == \"AB\")\nassert(solve(s: \"#a@C\") == \"#A@c\")\nassert(solve(s:\
    \ \"#AsdfW^45\") == \"#aSDFw^45\")\nassert(solve(s: \"#6@2\") == \"2@6#\")\nassert(solve(s:\
    \ \"#$a^D\") == \"#$A^d\")\nassert(solve(s: \"#ccc\") == \"#CCC\")"
  status: Exception
  stderr: 'tmp80fruvij/tmp80fruvij.swift:55: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b97ef2dbc80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b97eefd2b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b97eefd2988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b97eefd17b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmp80fruvij                        0x000055d4b8b18a87 <unavailable> + 6791

    5    libc.so.6                          0x00002b97ef4c7460 __libc_start_main +
    245

    6    tmp80fruvij                        0x000055d4b8b186c9 <unavailable> + 5833

    '
  stdout: ''
  timestamp: 1659978812
- exit_code: 1
  program: "\n/// You are given a string s.\n/// if s[i] is a letter, reverse its\
    \ case from lower to upper or vise versa, \n/// otherwise keep it as it is.\n\
    /// If the string contains no letters, reverse the string.\n/// The function should\
    \ return the resulted string.\n/// Examples\n/// >>> solve(s: \"1234\")\n/// \"\
    4321\"\n/// >>> solve(s: \"ab\")\n/// \"AB\"\n/// >>> solve(s: \"#a@C\")\n///\
    \ \"#A@c\"\nfunc solve(s: String) -> String {\n    let letters = CharacterSet.letters\n\
    \    let decimalDigits = CharacterSet.decimalDigits\n    var result = \"\"\n \
    \   var isLettersFound = false\n    var i = s.startIndex\n    while i < s.endIndex\
    \ {\n        let range = s.rangeOfCharacter(from: letters, options: [], range:\
    \ i..<s.endIndex)\n        if let range = range {\n            let letter = s[range]\n\
    \            isLettersFound = true\n            result.append(letter.lowercased()\
    \ == letter ? letter.uppercased() : letter.lowercased())\n            i = range.upperBound\n\
    \        } else {\n            break\n        }\n    }\n    while i < s.endIndex\
    \ {\n        let range = s.rangeOfCharacter(from: decimalDigits, options: [],\
    \ range: i..<s.endIndex)\n        if let range = range {\n            let digit\
    \ = s[range]\n            result.append(digit)\n            i = range.upperBound\n\
    \        } else {\n            break\n        }\n    }\n    return isLettersFound\
    \ ? result : String(result.reversed())\n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(solve(s: \"AsDf\") == \"aSdF\")\nassert(solve(s: \"1234\") == \"4321\"\
    )\nassert(solve(s: \"ab\") == \"AB\")\nassert(solve(s: \"#a@C\") == \"#A@c\")\n\
    assert(solve(s: \"#AsdfW^45\") == \"#aSDFw^45\")\nassert(solve(s: \"#6@2\") ==\
    \ \"2@6#\")\nassert(solve(s: \"#$a^D\") == \"#$A^d\")\nassert(solve(s: \"#ccc\"\
    ) == \"#CCC\")"
  status: SyntaxError
  stderr: "/tmp/tmpq2yfq07_.swift:15:19: error: cannot find 'CharacterSet' in scope\n\
    \    let letters = CharacterSet.letters\n                  ^~~~~~~~~~~~\n/tmp/tmpq2yfq07_.swift:16:25:\
    \ error: cannot find 'CharacterSet' in scope\n    let decimalDigits = CharacterSet.decimalDigits\n\
    \                        ^~~~~~~~~~~~\n/tmp/tmpq2yfq07_.swift:21:23: error: value\
    \ of type 'String' has no member 'rangeOfCharacter'\n        let range = s.rangeOfCharacter(from:\
    \ letters, options: [], range: i..<s.endIndex)\n                    ~ ^~~~~~~~~~~~~~~~\n\
    /tmp/tmpq2yfq07_.swift:32:23: error: value of type 'String' has no member 'rangeOfCharacter'\n\
    \        let range = s.rangeOfCharacter(from: decimalDigits, options: [], range:\
    \ i..<s.endIndex)\n                    ~ ^~~~~~~~~~~~~~~~\n"
  stdout: ''
  timestamp: 1659978812
- exit_code: -4
  program: "\n/// You are given a string s.\n/// if s[i] is a letter, reverse its\
    \ case from lower to upper or vise versa, \n/// otherwise keep it as it is.\n\
    /// If the string contains no letters, reverse the string.\n/// The function should\
    \ return the resulted string.\n/// Examples\n/// >>> solve(s: \"1234\")\n/// \"\
    4321\"\n/// >>> solve(s: \"ab\")\n/// \"AB\"\n/// >>> solve(s: \"#a@C\")\n///\
    \ \"#A@c\"\nfunc solve(s: String) -> String {\n    var str = \"\"\n    for character\
    \ in s {\n        if character.isLetter {\n            if character.isUppercase\
    \ {\n                str.append(character.lowercased())\n            } else {\n\
    \                str.append(character.uppercased())\n            }\n        }\
    \ else {\n            str.append(character)\n        }\n    }\n    return str.isEmpty\
    \ ? String(s.reversed()) : str\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int,\
    \ Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n\
    \    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n          \
    \  return false\n        }\n    }\n    return true\n}\n            \nassert(solve(s:\
    \ \"AsDf\") == \"aSdF\")\nassert(solve(s: \"1234\") == \"4321\")\nassert(solve(s:\
    \ \"ab\") == \"AB\")\nassert(solve(s: \"#a@C\") == \"#A@c\")\nassert(solve(s:\
    \ \"#AsdfW^45\") == \"#aSDFw^45\")\nassert(solve(s: \"#6@2\") == \"2@6#\")\nassert(solve(s:\
    \ \"#$a^D\") == \"#$A^d\")\nassert(solve(s: \"#ccc\") == \"#CCC\")"
  status: Exception
  stderr: 'tmp5n3jaka1/tmp5n3jaka1.swift:44: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b40dda5fc80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b40dd756b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b40dd756988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b40dd7557b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmp5n3jaka1                        0x0000560f5d4458d7 <unavailable> + 6359

    5    libc.so.6                          0x00002b40ddc4b460 __libc_start_main +
    245

    6    tmp5n3jaka1                        0x0000560f5d445429 <unavailable> + 5161

    '
  stdout: ''
  timestamp: 1659978812
- exit_code: 1
  program: "\n/// You are given a string s.\n/// if s[i] is a letter, reverse its\
    \ case from lower to upper or vise versa, \n/// otherwise keep it as it is.\n\
    /// If the string contains no letters, reverse the string.\n/// The function should\
    \ return the resulted string.\n/// Examples\n/// >>> solve(s: \"1234\")\n/// \"\
    4321\"\n/// >>> solve(s: \"ab\")\n/// \"AB\"\n/// >>> solve(s: \"#a@C\")\n///\
    \ \"#A@c\"\nfunc solve(s: String) -> String {\n  return String(\n    s.reversed().map\
    \ { \n      $0.isLetter ? Character($0.unicodeScalars.first!.value ^ 32) : $0\
    \ \n    }\n  )\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool\
    \ {\n    if left.count != right.count {\n        return false\n    }\n    for\
    \ (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(solve(s: \"AsDf\"\
    ) == \"aSdF\")\nassert(solve(s: \"1234\") == \"4321\")\nassert(solve(s: \"ab\"\
    ) == \"AB\")\nassert(solve(s: \"#a@C\") == \"#A@c\")\nassert(solve(s: \"#AsdfW^45\"\
    ) == \"#aSDFw^45\")\nassert(solve(s: \"#6@2\") == \"2@6#\")\nassert(solve(s: \"\
    #$a^D\") == \"#$A^d\")\nassert(solve(s: \"#ccc\") == \"#CCC\")"
  status: SyntaxError
  stderr: "/tmp/tmp9v_la3us.swift:17:21: error: no exact matches in call to initializer\
    \ \n      $0.isLetter ? Character($0.unicodeScalars.first!.value ^ 32) : $0 \n\
    \                    ^\nSwift.Character:2:23: note: candidate expects value of\
    \ type 'Unicode.Scalar' for parameter #1 (got 'UInt32')\n    @inlinable public\
    \ init(_ content: Unicode.Scalar)\n                      ^\nSwift.Character:6:23:\
    \ note: candidate expects value of type 'String' for parameter #1 (got 'UInt32')\n\
    \    @inlinable public init(_ s: String)\n                      ^\n"
  stdout: ''
  timestamp: 1659978812
- exit_code: 1
  program: "\n/// You are given a string s.\n/// if s[i] is a letter, reverse its\
    \ case from lower to upper or vise versa, \n/// otherwise keep it as it is.\n\
    /// If the string contains no letters, reverse the string.\n/// The function should\
    \ return the resulted string.\n/// Examples\n/// >>> solve(s: \"1234\")\n/// \"\
    4321\"\n/// >>> solve(s: \"ab\")\n/// \"AB\"\n/// >>> solve(s: \"#a@C\")\n///\
    \ \"#A@c\"\nfunc solve(s: String) -> String {\n    if s.count == 0 {\n       \
    \ return s\n    }\n    var result = \"\"\n    for i in s {\n        result +=\
    \ \"\\(i.isLetter ? i.lowercased() == i ? i.uppercased() : i.lowercased() : i)\"\
    \n    }\n    return result\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(solve(s: \"\
    AsDf\") == \"aSdF\")\nassert(solve(s: \"1234\") == \"4321\")\nassert(solve(s:\
    \ \"ab\") == \"AB\")\nassert(solve(s: \"#a@C\") == \"#A@c\")\nassert(solve(s:\
    \ \"#AsdfW^45\") == \"#aSDFw^45\")\nassert(solve(s: \"#6@2\") == \"2@6#\")\nassert(solve(s:\
    \ \"#$a^D\") == \"#$A^d\")\nassert(solve(s: \"#ccc\") == \"#CCC\")"
  status: SyntaxError
  stderr: "/tmp/tmp1lwjk219.swift:20:50: error: binary operator '==' cannot be applied\
    \ to operands of type 'String' and 'Character'\n        result += \"\\(i.isLetter\
    \ ? i.lowercased() == i ? i.uppercased() : i.lowercased() : i)\"\n           \
    \                       ~~~~~~~~~~~~~~ ^  ~\n/tmp/tmp1lwjk219.swift:20:50: note:\
    \ overloads for '==' exist with these partially matching parameter lists: (Character,\
    \ Character), (String, String)\n        result += \"\\(i.isLetter ? i.lowercased()\
    \ == i ? i.uppercased() : i.lowercased() : i)\"\n                            \
    \                     ^\n/tmp/tmp1lwjk219.swift:20:55: error: result values in\
    \ '? :' expression have mismatching types 'String' and 'Character'\n        result\
    \ += \"\\(i.isLetter ? i.lowercased() == i ? i.uppercased() : i.lowercased() :\
    \ i)\"\n                                  ~~~~~~~~~~~~~~~~~~~~^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n"
  stdout: ''
  timestamp: 1659978812
- exit_code: -4
  program: "\n/// You are given a string s.\n/// if s[i] is a letter, reverse its\
    \ case from lower to upper or vise versa, \n/// otherwise keep it as it is.\n\
    /// If the string contains no letters, reverse the string.\n/// The function should\
    \ return the resulted string.\n/// Examples\n/// >>> solve(s: \"1234\")\n/// \"\
    4321\"\n/// >>> solve(s: \"ab\")\n/// \"AB\"\n/// >>> solve(s: \"#a@C\")\n///\
    \ \"#A@c\"\nfunc solve(s: String) -> String {\n    // Write your code here.\n\
    \    var reversed = \"\"\n    for char in s {\n        if char.isLetter {\n  \
    \          reversed.append(char.isLowercase ? char.uppercased() : char.lowercased())\n\
    \        } else {\n            reversed.append(char)\n        }\n    }\n    return\
    \ reversed.isEmpty ? String(s.reversed()) : reversed\n}\n\n\nfunc ==(left: [(Int,\
    \ Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n\
    \        return false\n    }\n    for (l, r) in zip(left, right) {\n        if\
    \ l != r {\n            return false\n        }\n    }\n    return true\n}\n \
    \           \nassert(solve(s: \"AsDf\") == \"aSdF\")\nassert(solve(s: \"1234\"\
    ) == \"4321\")\nassert(solve(s: \"ab\") == \"AB\")\nassert(solve(s: \"#a@C\")\
    \ == \"#A@c\")\nassert(solve(s: \"#AsdfW^45\") == \"#aSDFw^45\")\nassert(solve(s:\
    \ \"#6@2\") == \"2@6#\")\nassert(solve(s: \"#$a^D\") == \"#$A^d\")\nassert(solve(s:\
    \ \"#ccc\") == \"#CCC\")"
  status: Exception
  stderr: 'tmpdmtb9meb/tmpdmtb9meb.swift:41: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b5eb08ddc80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b5eb05d4b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b5eb05d4988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b5eb05d37b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpdmtb9meb                        0x00005556334fe8d7 <unavailable> + 6359

    5    libc.so.6                          0x00002b5eb0ac9460 __libc_start_main +
    245

    6    tmpdmtb9meb                        0x00005556334fe429 <unavailable> + 5161

    '
  stdout: ''
  timestamp: 1659978813
- exit_code: 1
  program: "\n/// You are given a string s.\n/// if s[i] is a letter, reverse its\
    \ case from lower to upper or vise versa, \n/// otherwise keep it as it is.\n\
    /// If the string contains no letters, reverse the string.\n/// The function should\
    \ return the resulted string.\n/// Examples\n/// >>> solve(s: \"1234\")\n/// \"\
    4321\"\n/// >>> solve(s: \"ab\")\n/// \"AB\"\n/// >>> solve(s: \"#a@C\")\n///\
    \ \"#A@c\"\nfunc solve(s: String) -> String {\n    guard !s.isEmpty else { return\
    \ s }\n    let letters = CharacterSet.letters\n    let capitalized = CharacterSet.uppercaseLetters\n\
    \    var temp = \"\"\n    for item in s {\n        if letters.contains(item.unicodeScalars.first!)\
    \ {\n            if capitalized.contains(item.unicodeScalars.first!) {\n     \
    \           temp.append(Character(String(item).lowercased()))\n            } else\
    \ {\n                temp.append(Character(String(item).uppercased()))\n     \
    \       }\n        } else {\n            temp.append(item)\n        }\n    }\n\
    \    return String(temp.reversed())\n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(solve(s: \"AsDf\") == \"aSdF\")\nassert(solve(s: \"1234\") == \"4321\"\
    )\nassert(solve(s: \"ab\") == \"AB\")\nassert(solve(s: \"#a@C\") == \"#A@c\")\n\
    assert(solve(s: \"#AsdfW^45\") == \"#aSDFw^45\")\nassert(solve(s: \"#6@2\") ==\
    \ \"2@6#\")\nassert(solve(s: \"#$a^D\") == \"#$A^d\")\nassert(solve(s: \"#ccc\"\
    ) == \"#CCC\")"
  status: SyntaxError
  stderr: "/tmp/tmpr4k8s38h.swift:16:19: error: cannot find 'CharacterSet' in scope\n\
    \    let letters = CharacterSet.letters\n                  ^~~~~~~~~~~~\n/tmp/tmpr4k8s38h.swift:17:23:\
    \ error: cannot find 'CharacterSet' in scope\n    let capitalized = CharacterSet.uppercaseLetters\n\
    \                      ^~~~~~~~~~~~\n"
  stdout: ''
  timestamp: 1659978812
- exit_code: 1
  program: "\n/// You are given a string s.\n/// if s[i] is a letter, reverse its\
    \ case from lower to upper or vise versa, \n/// otherwise keep it as it is.\n\
    /// If the string contains no letters, reverse the string.\n/// The function should\
    \ return the resulted string.\n/// Examples\n/// >>> solve(s: \"1234\")\n/// \"\
    4321\"\n/// >>> solve(s: \"ab\")\n/// \"AB\"\n/// >>> solve(s: \"#a@C\")\n///\
    \ \"#A@c\"\nfunc solve(s: String) -> String {\n    let letterRegex = try! NSRegularExpression(pattern:\
    \ \"[a-zA-Z]\")\n    var result = \"\"\n    for ch in s {\n        if letterRegex.firstMatch(in:\
    \ String(ch), options: [], range: NSRange(location: 0, length: 1)) != nil {\n\
    \            result.append(ch.isLowercase ? Character(ch.uppercased()) : Character(ch.lowercased()))\n\
    \        } else {\n            result.append(ch)\n        }\n    }\n    return\
    \ result.isEmpty ? String(s.reversed()) : result\n}\n\n\nfunc ==(left: [(Int,\
    \ Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n\
    \        return false\n    }\n    for (l, r) in zip(left, right) {\n        if\
    \ l != r {\n            return false\n        }\n    }\n    return true\n}\n \
    \           \nassert(solve(s: \"AsDf\") == \"aSdF\")\nassert(solve(s: \"1234\"\
    ) == \"4321\")\nassert(solve(s: \"ab\") == \"AB\")\nassert(solve(s: \"#a@C\")\
    \ == \"#A@c\")\nassert(solve(s: \"#AsdfW^45\") == \"#aSDFw^45\")\nassert(solve(s:\
    \ \"#6@2\") == \"2@6#\")\nassert(solve(s: \"#$a^D\") == \"#$A^d\")\nassert(solve(s:\
    \ \"#ccc\") == \"#CCC\")"
  status: SyntaxError
  stderr: "/tmp/tmp8zt7kr5o.swift:15:28: error: cannot find 'NSRegularExpression'\
    \ in scope\n    let letterRegex = try! NSRegularExpression(pattern: \"[a-zA-Z]\"\
    )\n                           ^~~~~~~~~~~~~~~~~~~\n/tmp/tmp8zt7kr5o.swift:18:71:\
    \ error: cannot find 'NSRange' in scope\n        if letterRegex.firstMatch(in:\
    \ String(ch), options: [], range: NSRange(location: 0, length: 1)) != nil {\n\
    \                                                                      ^~~~~~~\n"
  stdout: ''
  timestamp: 1659978812
- exit_code: -4
  program: "\n/// You are given a string s.\n/// if s[i] is a letter, reverse its\
    \ case from lower to upper or vise versa, \n/// otherwise keep it as it is.\n\
    /// If the string contains no letters, reverse the string.\n/// The function should\
    \ return the resulted string.\n/// Examples\n/// >>> solve(s: \"1234\")\n/// \"\
    4321\"\n/// >>> solve(s: \"ab\")\n/// \"AB\"\n/// >>> solve(s: \"#a@C\")\n///\
    \ \"#A@c\"\nfunc solve(s: String) -> String {\n    var res = \"\"\n    for ch\
    \ in s {\n        if ch.isLetter {\n            res.append(ch.isLowercase ? ch.uppercased()\
    \ : ch.lowercased())\n        } else {\n            res.append(ch)\n        }\n\
    \    }\n    return res.isEmpty ? String(s.reversed()) : res\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(solve(s: \"AsDf\") == \"aSdF\")\nassert(solve(s: \"1234\"\
    ) == \"4321\")\nassert(solve(s: \"ab\") == \"AB\")\nassert(solve(s: \"#a@C\")\
    \ == \"#A@c\")\nassert(solve(s: \"#AsdfW^45\") == \"#aSDFw^45\")\nassert(solve(s:\
    \ \"#6@2\") == \"2@6#\")\nassert(solve(s: \"#$a^D\") == \"#$A^d\")\nassert(solve(s:\
    \ \"#ccc\") == \"#CCC\")"
  status: Exception
  stderr: 'tmpy1i5s3mx/tmpy1i5s3mx.swift:40: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b31dfeeec80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b31dfbe5b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b31dfbe5988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b31dfbe47b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpy1i5s3mx                        0x0000565371add8d7 <unavailable> + 6359

    5    libc.so.6                          0x00002b31e00da460 __libc_start_main +
    245

    6    tmpy1i5s3mx                        0x0000565371add429 <unavailable> + 5161

    '
  stdout: ''
  timestamp: 1659978813
- exit_code: 1
  program: "\n/// You are given a string s.\n/// if s[i] is a letter, reverse its\
    \ case from lower to upper or vise versa, \n/// otherwise keep it as it is.\n\
    /// If the string contains no letters, reverse the string.\n/// The function should\
    \ return the resulted string.\n/// Examples\n/// >>> solve(s: \"1234\")\n/// \"\
    4321\"\n/// >>> solve(s: \"ab\")\n/// \"AB\"\n/// >>> solve(s: \"#a@C\")\n///\
    \ \"#A@c\"\nfunc solve(s: String) -> String {\n    guard !s.isEmpty else { return\
    \ s }\n    guard s.rangeOfCharacter(from: CharacterSet.letters) != nil else {\
    \ return String(s.reversed()) }\n    var s = s\n    var newStr = \"\"\n    for\
    \ char in s {\n        if char.isLetter {\n            if char.isUppercase {\n\
    \                newStr.append(char.lowercased())\n            } else {\n    \
    \            newStr.append(char.uppercased())\n            }\n        } else {\n\
    \            newStr.append(char)\n        }\n    }\n    return newStr\n}\n\n\n\
    func ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(solve(s: \"AsDf\") == \"aSdF\")\nassert(solve(s:\
    \ \"1234\") == \"4321\")\nassert(solve(s: \"ab\") == \"AB\")\nassert(solve(s:\
    \ \"#a@C\") == \"#A@c\")\nassert(solve(s: \"#AsdfW^45\") == \"#aSDFw^45\")\nassert(solve(s:\
    \ \"#6@2\") == \"2@6#\")\nassert(solve(s: \"#$a^D\") == \"#$A^d\")\nassert(solve(s:\
    \ \"#ccc\") == \"#CCC\")"
  status: SyntaxError
  stderr: "/tmp/tmphdkpogkj.swift:16:36: error: cannot find 'CharacterSet' in scope\n\
    \    guard s.rangeOfCharacter(from: CharacterSet.letters) != nil else { return\
    \ String(s.reversed()) }\n                                   ^~~~~~~~~~~~\n/tmp/tmphdkpogkj.swift:16:13:\
    \ error: value of type 'String' has no member 'rangeOfCharacter'\n    guard s.rangeOfCharacter(from:\
    \ CharacterSet.letters) != nil else { return String(s.reversed()) }\n        \
    \  ~ ^~~~~~~~~~~~~~~~\n"
  stdout: ''
  timestamp: 1659978812
- exit_code: 1
  program: "\n/// You are given a string s.\n/// if s[i] is a letter, reverse its\
    \ case from lower to upper or vise versa, \n/// otherwise keep it as it is.\n\
    /// If the string contains no letters, reverse the string.\n/// The function should\
    \ return the resulted string.\n/// Examples\n/// >>> solve(s: \"1234\")\n/// \"\
    4321\"\n/// >>> solve(s: \"ab\")\n/// \"AB\"\n/// >>> solve(s: \"#a@C\")\n///\
    \ \"#A@c\"\nfunc solve(s: String) -> String {\n    guard s.rangeOfCharacter(from:\
    \ CharacterSet.letters) != nil else {\n        return String(s.reversed())\n \
    \   }\n    var s = s\n    for i in s.indices {\n        let char = s[i]\n    \
    \    if CharacterSet.letters.contains(char.unicodeScalars.first!) {\n        \
    \    let unicodeScalar = Character(s[i]).unicodeScalars.first!.value\n       \
    \     let newChar = (unicodeScalar >= 97 && unicodeScalar <= 122) ? Character(UnicodeScalar(unicodeScalar\
    \ - 32)!) : Character(UnicodeScalar(unicodeScalar + 32)!)\n            s.replaceSubrange(i...i,\
    \ with: String(newChar))\n        }\n    }\n    return s\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(solve(s: \"AsDf\") == \"aSdF\")\nassert(solve(s: \"1234\"\
    ) == \"4321\")\nassert(solve(s: \"ab\") == \"AB\")\nassert(solve(s: \"#a@C\")\
    \ == \"#A@c\")\nassert(solve(s: \"#AsdfW^45\") == \"#aSDFw^45\")\nassert(solve(s:\
    \ \"#6@2\") == \"2@6#\")\nassert(solve(s: \"#$a^D\") == \"#$A^d\")\nassert(solve(s:\
    \ \"#ccc\") == \"#CCC\")"
  status: SyntaxError
  stderr: "/tmp/tmpsk9mjbru.swift:15:36: error: cannot find 'CharacterSet' in scope\n\
    \    guard s.rangeOfCharacter(from: CharacterSet.letters) != nil else {\n    \
    \                               ^~~~~~~~~~~~\n/tmp/tmpsk9mjbru.swift:15:13: error:\
    \ value of type 'String' has no member 'rangeOfCharacter'\n    guard s.rangeOfCharacter(from:\
    \ CharacterSet.letters) != nil else {\n          ~ ^~~~~~~~~~~~~~~~\n/tmp/tmpsk9mjbru.swift:21:12:\
    \ error: cannot find 'CharacterSet' in scope\n        if CharacterSet.letters.contains(char.unicodeScalars.first!)\
    \ {\n           ^~~~~~~~~~~~\n/tmp/tmpsk9mjbru.swift:22:43: error: missing argument\
    \ label 'extendedGraphemeClusterLiteral:' in call\n            let unicodeScalar\
    \ = Character(s[i]).unicodeScalars.first!.value\n                            \
    \              ^\n                                          extendedGraphemeClusterLiteral:\
    \ \n"
  stdout: ''
  timestamp: 1659978812
- exit_code: -4
  program: "\n/// You are given a string s.\n/// if s[i] is a letter, reverse its\
    \ case from lower to upper or vise versa, \n/// otherwise keep it as it is.\n\
    /// If the string contains no letters, reverse the string.\n/// The function should\
    \ return the resulted string.\n/// Examples\n/// >>> solve(s: \"1234\")\n/// \"\
    4321\"\n/// >>> solve(s: \"ab\")\n/// \"AB\"\n/// >>> solve(s: \"#a@C\")\n///\
    \ \"#A@c\"\nfunc solve(s: String) -> String {\n    return \"\"\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(solve(s: \"AsDf\") == \"aSdF\")\nassert(solve(s: \"1234\"\
    ) == \"4321\")\nassert(solve(s: \"ab\") == \"AB\")\nassert(solve(s: \"#a@C\")\
    \ == \"#A@c\")\nassert(solve(s: \"#AsdfW^45\") == \"#aSDFw^45\")\nassert(solve(s:\
    \ \"#6@2\") == \"2@6#\")\nassert(solve(s: \"#$a^D\") == \"#$A^d\")\nassert(solve(s:\
    \ \"#ccc\") == \"#CCC\")"
  status: Exception
  stderr: 'tmpiark_u6w/tmpiark_u6w.swift:31: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002aca5c89dc80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002aca5c594b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002aca5c594988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002aca5c5937b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpiark_u6w                        0x0000562c1ac34307 <unavailable> + 4871

    5    libc.so.6                          0x00002aca5ca89460 __libc_start_main +
    245

    6    tmpiark_u6w                        0x0000562c1ac33f49 <unavailable> + 3913

    '
  stdout: ''
  timestamp: 1659978811
- exit_code: -4
  program: "\n/// You are given a string s.\n/// if s[i] is a letter, reverse its\
    \ case from lower to upper or vise versa, \n/// otherwise keep it as it is.\n\
    /// If the string contains no letters, reverse the string.\n/// The function should\
    \ return the resulted string.\n/// Examples\n/// >>> solve(s: \"1234\")\n/// \"\
    4321\"\n/// >>> solve(s: \"ab\")\n/// \"AB\"\n/// >>> solve(s: \"#a@C\")\n///\
    \ \"#A@c\"\nfunc solve(s: String) -> String {\n    var result: String = \"\"\n\
    \    for i in s {\n        if i.isLetter == true {\n            result += String(i.uppercased()\
    \ == String(i) ? i.lowercased() : i.uppercased())\n        } else {\n        \
    \    result += String(i)\n        }\n    }\n    return result.isEmpty ? String(s.reversed())\
    \ : result\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n\
    \    if left.count != right.count {\n        return false\n    }\n    for (l,\
    \ r) in zip(left, right) {\n        if l != r {\n            return false\n  \
    \      }\n    }\n    return true\n}\n            \nassert(solve(s: \"AsDf\") ==\
    \ \"aSdF\")\nassert(solve(s: \"1234\") == \"4321\")\nassert(solve(s: \"ab\") ==\
    \ \"AB\")\nassert(solve(s: \"#a@C\") == \"#A@c\")\nassert(solve(s: \"#AsdfW^45\"\
    ) == \"#aSDFw^45\")\nassert(solve(s: \"#6@2\") == \"2@6#\")\nassert(solve(s: \"\
    #$a^D\") == \"#$A^d\")\nassert(solve(s: \"#ccc\") == \"#CCC\")"
  status: Exception
  stderr: 'tmpylch76sl/tmpylch76sl.swift:40: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b55997a9c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b55994a0b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b55994a0988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b559949f7b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpylch76sl                        0x000055737dbf4997 <unavailable> + 6551

    5    libc.so.6                          0x00002b5599995460 __libc_start_main +
    245

    6    tmpylch76sl                        0x000055737dbf44e9 <unavailable> + 5353

    '
  stdout: ''
  timestamp: 1659978813
- exit_code: 0
  program: "\n/// You are given a string s.\n/// if s[i] is a letter, reverse its\
    \ case from lower to upper or vise versa, \n/// otherwise keep it as it is.\n\
    /// If the string contains no letters, reverse the string.\n/// The function should\
    \ return the resulted string.\n/// Examples\n/// >>> solve(s: \"1234\")\n/// \"\
    4321\"\n/// >>> solve(s: \"ab\")\n/// \"AB\"\n/// >>> solve(s: \"#a@C\")\n///\
    \ \"#A@c\"\nfunc solve(s: String) -> String {\n    var str = Array(s)\n    var\
    \ isLetter = false\n    var result = \"\"\n    for (i,c) in str.enumerated() {\n\
    \        if c.isLetter {\n            isLetter = true\n            if c.isLowercase\
    \ {\n                str[i] = Character(c.uppercased())\n            } else {\n\
    \                str[i] = Character(c.lowercased())\n            }\n        }\n\
    \    }\n    if isLetter {\n        result = String(str)\n    } else {\n      \
    \  result = String(str.reversed())\n    }\n    return result\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(solve(s: \"AsDf\") == \"aSdF\")\nassert(solve(s: \"1234\"\
    ) == \"4321\")\nassert(solve(s: \"ab\") == \"AB\")\nassert(solve(s: \"#a@C\")\
    \ == \"#A@c\")\nassert(solve(s: \"#AsdfW^45\") == \"#aSDFw^45\")\nassert(solve(s:\
    \ \"#6@2\") == \"2@6#\")\nassert(solve(s: \"#$a^D\") == \"#$A^d\")\nassert(solve(s:\
    \ \"#ccc\") == \"#CCC\")"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659978813
- exit_code: 0
  program: "\n/// You are given a string s.\n/// if s[i] is a letter, reverse its\
    \ case from lower to upper or vise versa, \n/// otherwise keep it as it is.\n\
    /// If the string contains no letters, reverse the string.\n/// The function should\
    \ return the resulted string.\n/// Examples\n/// >>> solve(s: \"1234\")\n/// \"\
    4321\"\n/// >>> solve(s: \"ab\")\n/// \"AB\"\n/// >>> solve(s: \"#a@C\")\n///\
    \ \"#A@c\"\nfunc solve(s: String) -> String {\n    var str = \"\"\n    var ans\
    \ = \"\"\n    for c in s {\n        if !c.isLetter {\n            str += \"\\\
    (c)\"\n        }\n    }\n    if str.count == s.count {\n        return String(s.reversed())\n\
    \    }\n    for c in s {\n        if c.isLetter {\n            ans += c.isUppercase\
    \ ? \"\\(c.lowercased())\" : \"\\(c.uppercased())\"\n        } else {\n      \
    \      ans += \"\\(c)\"\n        }\n    }\n    return ans\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(solve(s: \"AsDf\") == \"aSdF\")\nassert(solve(s: \"1234\"\
    ) == \"4321\")\nassert(solve(s: \"ab\") == \"AB\")\nassert(solve(s: \"#a@C\")\
    \ == \"#A@c\")\nassert(solve(s: \"#AsdfW^45\") == \"#aSDFw^45\")\nassert(solve(s:\
    \ \"#6@2\") == \"2@6#\")\nassert(solve(s: \"#$a^D\") == \"#$A^d\")\nassert(solve(s:\
    \ \"#ccc\") == \"#CCC\")"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659978813
- exit_code: 0
  program: "\n/// You are given a string s.\n/// if s[i] is a letter, reverse its\
    \ case from lower to upper or vise versa, \n/// otherwise keep it as it is.\n\
    /// If the string contains no letters, reverse the string.\n/// The function should\
    \ return the resulted string.\n/// Examples\n/// >>> solve(s: \"1234\")\n/// \"\
    4321\"\n/// >>> solve(s: \"ab\")\n/// \"AB\"\n/// >>> solve(s: \"#a@C\")\n///\
    \ \"#A@c\"\nfunc solve(s: String) -> String {\n    var result = String()\n   \
    \ let letters = s.filter { $0.isLetter }\n    if letters.isEmpty {\n        return\
    \ String(s.reversed())\n    }\n    for c in s {\n        if c.isLetter {\n   \
    \         result.append(c.isUppercase ? c.lowercased() : c.uppercased())\n   \
    \     } else {\n            result.append(c)\n        }\n    }\n    return result\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(solve(s: \"AsDf\") == \"aSdF\")\nassert(solve(s:\
    \ \"1234\") == \"4321\")\nassert(solve(s: \"ab\") == \"AB\")\nassert(solve(s:\
    \ \"#a@C\") == \"#A@c\")\nassert(solve(s: \"#AsdfW^45\") == \"#aSDFw^45\")\nassert(solve(s:\
    \ \"#6@2\") == \"2@6#\")\nassert(solve(s: \"#$a^D\") == \"#$A^d\")\nassert(solve(s:\
    \ \"#ccc\") == \"#CCC\")"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659978813
- exit_code: 1
  program: "\n/// You are given a string s.\n/// if s[i] is a letter, reverse its\
    \ case from lower to upper or vise versa, \n/// otherwise keep it as it is.\n\
    /// If the string contains no letters, reverse the string.\n/// The function should\
    \ return the resulted string.\n/// Examples\n/// >>> solve(s: \"1234\")\n/// \"\
    4321\"\n/// >>> solve(s: \"ab\")\n/// \"AB\"\n/// >>> solve(s: \"#a@C\")\n///\
    \ \"#A@c\"\nfunc solve(s: String) -> String {\n    let s = s.map { $0.isLetter\
    \ ? $0.toggleCase() : $0 }\n    return s.contains(where: { $0.isLetter }) ? String(s)\
    \ : String(s.reversed())\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(solve(s: \"\
    AsDf\") == \"aSdF\")\nassert(solve(s: \"1234\") == \"4321\")\nassert(solve(s:\
    \ \"ab\") == \"AB\")\nassert(solve(s: \"#a@C\") == \"#A@c\")\nassert(solve(s:\
    \ \"#AsdfW^45\") == \"#aSDFw^45\")\nassert(solve(s: \"#6@2\") == \"2@6#\")\nassert(solve(s:\
    \ \"#$a^D\") == \"#$A^d\")\nassert(solve(s: \"#ccc\") == \"#CCC\")"
  status: SyntaxError
  stderr: "/tmp/tmp1ngwg1xj.swift:15:38: error: value of type 'String.Element' (aka\
    \ 'Character') has no member 'toggleCase'\n    let s = s.map { $0.isLetter ? $0.toggleCase()\
    \ : $0 }\n                                  ~~ ^~~~~~~~~~\n"
  stdout: ''
  timestamp: 1659978813
- exit_code: 0
  program: "\n/// You are given a string s.\n/// if s[i] is a letter, reverse its\
    \ case from lower to upper or vise versa, \n/// otherwise keep it as it is.\n\
    /// If the string contains no letters, reverse the string.\n/// The function should\
    \ return the resulted string.\n/// Examples\n/// >>> solve(s: \"1234\")\n/// \"\
    4321\"\n/// >>> solve(s: \"ab\")\n/// \"AB\"\n/// >>> solve(s: \"#a@C\")\n///\
    \ \"#A@c\"\nfunc solve(s: String) -> String {\n    if s.filter({(c: Character)\
    \ -> Bool in c.isLetter}).isEmpty {\n        return String(s.reversed())\n   \
    \ }\n    var ans = \"\"\n    for c in s {\n        if c.isLetter {\n         \
    \   ans.append(c.isUppercase ? c.lowercased() : c.uppercased())\n        } else\
    \ {\n            ans.append(c)\n        }\n    }\n    return ans\n}\n\n\nfunc\
    \ ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count !=\
    \ right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(solve(s: \"AsDf\") == \"aSdF\")\nassert(solve(s:\
    \ \"1234\") == \"4321\")\nassert(solve(s: \"ab\") == \"AB\")\nassert(solve(s:\
    \ \"#a@C\") == \"#A@c\")\nassert(solve(s: \"#AsdfW^45\") == \"#aSDFw^45\")\nassert(solve(s:\
    \ \"#6@2\") == \"2@6#\")\nassert(solve(s: \"#$a^D\") == \"#$A^d\")\nassert(solve(s:\
    \ \"#ccc\") == \"#CCC\")"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659978813
- exit_code: 1
  program: "\n/// You are given a string s.\n/// if s[i] is a letter, reverse its\
    \ case from lower to upper or vise versa, \n/// otherwise keep it as it is.\n\
    /// If the string contains no letters, reverse the string.\n/// The function should\
    \ return the resulted string.\n/// Examples\n/// >>> solve(s: \"1234\")\n/// \"\
    4321\"\n/// >>> solve(s: \"ab\")\n/// \"AB\"\n/// >>> solve(s: \"#a@C\")\n///\
    \ \"#A@c\"\nfunc solve(s: String) -> String {\n    if s.isEmpty {\n        return\
    \ \"\"\n    }\n    let result = s.map {\n        if $0.isLowercase {\n       \
    \     return $0.uppercased()\n        } else if $0.isUppercase {\n           \
    \ return $0.lowercased()\n        } else {\n            return $0\n        }\n\
    \    }\n    return String(result)\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int,\
    \ Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n\
    \    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n          \
    \  return false\n        }\n    }\n    return true\n}\n            \nassert(solve(s:\
    \ \"AsDf\") == \"aSdF\")\nassert(solve(s: \"1234\") == \"4321\")\nassert(solve(s:\
    \ \"ab\") == \"AB\")\nassert(solve(s: \"#a@C\") == \"#A@c\")\nassert(solve(s:\
    \ \"#AsdfW^45\") == \"#aSDFw^45\")\nassert(solve(s: \"#6@2\") == \"2@6#\")\nassert(solve(s:\
    \ \"#$a^D\") == \"#$A^d\")\nassert(solve(s: \"#ccc\") == \"#CCC\")"
  status: SyntaxError
  stderr: "/tmp/tmp2y04twz_.swift:24:20: error: cannot convert return expression of\
    \ type 'String.Element' (aka 'Character') to return type 'String'\n          \
    \  return $0\n                   ^~\n"
  stdout: ''
  timestamp: 1659978813
- exit_code: 1
  program: "\n/// You are given a string s.\n/// if s[i] is a letter, reverse its\
    \ case from lower to upper or vise versa, \n/// otherwise keep it as it is.\n\
    /// If the string contains no letters, reverse the string.\n/// The function should\
    \ return the resulted string.\n/// Examples\n/// >>> solve(s: \"1234\")\n/// \"\
    4321\"\n/// >>> solve(s: \"ab\")\n/// \"AB\"\n/// >>> solve(s: \"#a@C\")\n///\
    \ \"#A@c\"\nfunc solve(s: String) -> String {\n    let result = s.components(separatedBy:\
    \ .letters).reduce(\"\") { (acc, item) -> String in\n        var result = acc\n\
    \        if let char = item.first {\n            if char.isUppercase {\n     \
    \           result += item.lowercased()\n            } else {\n              \
    \  result += item.uppercased()\n            }\n        } else {\n            result\
    \ += item\n        }\n        return result\n    }\n    return String(result.reversed())\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(solve(s: \"AsDf\") == \"aSdF\")\nassert(solve(s:\
    \ \"1234\") == \"4321\")\nassert(solve(s: \"ab\") == \"AB\")\nassert(solve(s:\
    \ \"#a@C\") == \"#A@c\")\nassert(solve(s: \"#AsdfW^45\") == \"#aSDFw^45\")\nassert(solve(s:\
    \ \"#6@2\") == \"2@6#\")\nassert(solve(s: \"#$a^D\") == \"#$A^d\")\nassert(solve(s:\
    \ \"#ccc\") == \"#CCC\")"
  status: SyntaxError
  stderr: "/tmp/tmptb_76fnq.swift:15:20: error: value of type 'String' has no member\
    \ 'components'\n    let result = s.components(separatedBy: .letters).reduce(\"\
    \") { (acc, item) -> String in\n                 ~ ^~~~~~~~~~\n/tmp/tmptb_76fnq.swift:15:45:\
    \ error: cannot infer contextual base in reference to member 'letters'\n    let\
    \ result = s.components(separatedBy: .letters).reduce(\"\") { (acc, item) -> String\
    \ in\n                                           ~^~~~~~~\n"
  stdout: ''
  timestamp: 1659978813
- exit_code: 1
  program: "\n/// You are given a string s.\n/// if s[i] is a letter, reverse its\
    \ case from lower to upper or vise versa, \n/// otherwise keep it as it is.\n\
    /// If the string contains no letters, reverse the string.\n/// The function should\
    \ return the resulted string.\n/// Examples\n/// >>> solve(s: \"1234\")\n/// \"\
    4321\"\n/// >>> solve(s: \"ab\")\n/// \"AB\"\n/// >>> solve(s: \"#a@C\")\n///\
    \ \"#A@c\"\nfunc solve(s: String) -> String {\n    guard s.rangeOfCharacter(from:\
    \ CharacterSet.letters) != nil else {\n        return String(s.reversed())\n \
    \   }\n    var arr: [Character] = []\n    for char in s {\n        if char.isLetter\
    \ {\n            arr.append(char.isUpperCase ? char.lowercased() : char.uppercased())\n\
    \        } else {\n            arr.append(char)\n        }\n    }\n    return\
    \ String(arr)\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool\
    \ {\n    if left.count != right.count {\n        return false\n    }\n    for\
    \ (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(solve(s: \"AsDf\"\
    ) == \"aSdF\")\nassert(solve(s: \"1234\") == \"4321\")\nassert(solve(s: \"ab\"\
    ) == \"AB\")\nassert(solve(s: \"#a@C\") == \"#A@c\")\nassert(solve(s: \"#AsdfW^45\"\
    ) == \"#aSDFw^45\")\nassert(solve(s: \"#6@2\") == \"2@6#\")\nassert(solve(s: \"\
    #$a^D\") == \"#$A^d\")\nassert(solve(s: \"#ccc\") == \"#CCC\")"
  status: SyntaxError
  stderr: "/tmp/tmphz2ro_9g.swift:15:36: error: cannot find 'CharacterSet' in scope\n\
    \    guard s.rangeOfCharacter(from: CharacterSet.letters) != nil else {\n    \
    \                               ^~~~~~~~~~~~\n/tmp/tmphz2ro_9g.swift:15:13: error:\
    \ value of type 'String' has no member 'rangeOfCharacter'\n    guard s.rangeOfCharacter(from:\
    \ CharacterSet.letters) != nil else {\n          ~ ^~~~~~~~~~~~~~~~\n/tmp/tmphz2ro_9g.swift:21:24:\
    \ error: missing argument label 'contentsOf:' in call\n            arr.append(char.isUpperCase\
    \ ? char.lowercased() : char.uppercased())\n                       ^\n       \
    \                contentsOf: \n/tmp/tmphz2ro_9g.swift:21:29: error: value of type\
    \ 'Character' has no member 'isUpperCase'\n            arr.append(char.isUpperCase\
    \ ? char.lowercased() : char.uppercased())\n                       ~~~~ ^~~~~~~~~~~\n"
  stdout: ''
  timestamp: 1659978813
- exit_code: -4
  program: "\n/// You are given a string s.\n/// if s[i] is a letter, reverse its\
    \ case from lower to upper or vise versa, \n/// otherwise keep it as it is.\n\
    /// If the string contains no letters, reverse the string.\n/// The function should\
    \ return the resulted string.\n/// Examples\n/// >>> solve(s: \"1234\")\n/// \"\
    4321\"\n/// >>> solve(s: \"ab\")\n/// \"AB\"\n/// >>> solve(s: \"#a@C\")\n///\
    \ \"#A@c\"\nfunc solve(s: String) -> String {\n    var result = \"\"\n    var\
    \ symbols = \"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz\"\n    for\
    \ char in s {\n        if symbols.contains(char) {\n            var symbol = \"\
    \"\n            for x in symbols {\n                if x == char {\n         \
    \           symbol = String(x)\n                    break\n                }\n\
    \            }\n            if symbol == String(char) {\n                for y\
    \ in symbols {\n                    if String(y) == symbol.uppercased() {\n  \
    \                      result += String(y)\n                        break\n  \
    \                  }\n                }\n            } else {\n              \
    \  for y in symbols {\n                    if String(y) == symbol.lowercased()\
    \ {\n                        result += String(y)\n                        break\n\
    \                    }\n                }\n            }\n        } else {\n \
    \           result += String(char)\n        }\n    }\n    return result.count\
    \ > 0 ? result : String(s.reversed())\n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(solve(s: \"AsDf\") == \"aSdF\")\nassert(solve(s: \"1234\") == \"4321\"\
    )\nassert(solve(s: \"ab\") == \"AB\")\nassert(solve(s: \"#a@C\") == \"#A@c\")\n\
    assert(solve(s: \"#AsdfW^45\") == \"#aSDFw^45\")\nassert(solve(s: \"#6@2\") ==\
    \ \"2@6#\")\nassert(solve(s: \"#$a^D\") == \"#$A^d\")\nassert(solve(s: \"#ccc\"\
    ) == \"#CCC\")"
  status: Exception
  stderr: 'tmpqe09ifvx/tmpqe09ifvx.swift:61: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b77e4ed2c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b77e4bc9b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b77e4bc9988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b77e4bc87b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpqe09ifvx                        0x0000562cfd3ae877 <unavailable> + 6263

    5    libc.so.6                          0x00002b77e50be460 __libc_start_main +
    245

    6    tmpqe09ifvx                        0x0000562cfd3ae4b9 <unavailable> + 5305

    '
  stdout: ''
  timestamp: 1659978813
- exit_code: -4
  program: "\n/// You are given a string s.\n/// if s[i] is a letter, reverse its\
    \ case from lower to upper or vise versa, \n/// otherwise keep it as it is.\n\
    /// If the string contains no letters, reverse the string.\n/// The function should\
    \ return the resulted string.\n/// Examples\n/// >>> solve(s: \"1234\")\n/// \"\
    4321\"\n/// >>> solve(s: \"ab\")\n/// \"AB\"\n/// >>> solve(s: \"#a@C\")\n///\
    \ \"#A@c\"\nfunc solve(s: String) -> String {\n    return String(s.map { char\
    \ in\n        switch char {\n        case \"a\"...\"z\":\n            return Character(char.uppercased())\n\
    \        case \"A\"...\"Z\":\n            return Character(char.lowercased())\n\
    \        default:\n            return char\n        }\n    })\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(solve(s: \"AsDf\") == \"aSdF\")\nassert(solve(s: \"1234\"\
    ) == \"4321\")\nassert(solve(s: \"ab\") == \"AB\")\nassert(solve(s: \"#a@C\")\
    \ == \"#A@c\")\nassert(solve(s: \"#AsdfW^45\") == \"#aSDFw^45\")\nassert(solve(s:\
    \ \"#6@2\") == \"2@6#\")\nassert(solve(s: \"#$a^D\") == \"#$A^d\")\nassert(solve(s:\
    \ \"#ccc\") == \"#CCC\")"
  status: Exception
  stderr: 'tmpo21t2cs_/tmpo21t2cs_.swift:41: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002aba4bf0fc80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002aba4bc06b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002aba4bc06988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002aba4bc057b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpo21t2cs_                        0x0000560832348887 <unavailable> + 6279

    5    libc.so.6                          0x00002aba4c0fb460 __libc_start_main +
    245

    6    tmpo21t2cs_                        0x00005608323483d9 <unavailable> + 5081

    '
  stdout: ''
  timestamp: 1659978813
- exit_code: 1
  program: "\n/// You are given a string s.\n/// if s[i] is a letter, reverse its\
    \ case from lower to upper or vise versa, \n/// otherwise keep it as it is.\n\
    /// If the string contains no letters, reverse the string.\n/// The function should\
    \ return the resulted string.\n/// Examples\n/// >>> solve(s: \"1234\")\n/// \"\
    4321\"\n/// >>> solve(s: \"ab\")\n/// \"AB\"\n/// >>> solve(s: \"#a@C\")\n///\
    \ \"#A@c\"\nfunc solve(s: String) -> String {\n    var result = \"\"\n    if s.count\
    \ == 0 {\n        return result\n    }\n    for i in s {\n        let s = String(i)\n\
    \        if s.isLetter {\n            if s.lowercased() == s {\n             \
    \   result += s.uppercased()\n            } else {\n                result +=\
    \ s.lowercased()\n            }\n        } else {\n            result += s\n \
    \       }\n    }\n    return result.count == 0 ? s : result\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(solve(s: \"AsDf\") == \"aSdF\")\nassert(solve(s: \"1234\"\
    ) == \"4321\")\nassert(solve(s: \"ab\") == \"AB\")\nassert(solve(s: \"#a@C\")\
    \ == \"#A@c\")\nassert(solve(s: \"#AsdfW^45\") == \"#aSDFw^45\")\nassert(solve(s:\
    \ \"#6@2\") == \"2@6#\")\nassert(solve(s: \"#$a^D\") == \"#$A^d\")\nassert(solve(s:\
    \ \"#ccc\") == \"#CCC\")"
  status: SyntaxError
  stderr: "/tmp/tmpc28vsv6s.swift:21:14: error: value of type 'String' has no member\
    \ 'isLetter'\n        if s.isLetter {\n           ~ ^~~~~~~~\n"
  stdout: ''
  timestamp: 1659978813
- exit_code: 1
  program: "\n/// You are given a string s.\n/// if s[i] is a letter, reverse its\
    \ case from lower to upper or vise versa, \n/// otherwise keep it as it is.\n\
    /// If the string contains no letters, reverse the string.\n/// The function should\
    \ return the resulted string.\n/// Examples\n/// >>> solve(s: \"1234\")\n/// \"\
    4321\"\n/// >>> solve(s: \"ab\")\n/// \"AB\"\n/// >>> solve(s: \"#a@C\")\n///\
    \ \"#A@c\"\nfunc solve(s: String) -> String {\n    return s.isEmpty ? s : s.reversed().map\
    \ { $0.isLetter ? $0.isUppercase ? Character($0.lowercased()) : Character($0.uppercased())\
    \ : $0 }.joined()\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) ->\
    \ Bool {\n    if left.count != right.count {\n        return false\n    }\n  \
    \  for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(solve(s: \"AsDf\"\
    ) == \"aSdF\")\nassert(solve(s: \"1234\") == \"4321\")\nassert(solve(s: \"ab\"\
    ) == \"AB\")\nassert(solve(s: \"#a@C\") == \"#A@c\")\nassert(solve(s: \"#AsdfW^45\"\
    ) == \"#aSDFw^45\")\nassert(solve(s: \"#6@2\") == \"2@6#\")\nassert(solve(s: \"\
    #$a^D\") == \"#$A^d\")\nassert(solve(s: \"#ccc\") == \"#CCC\")"
  status: SyntaxError
  stderr: "/tmp/tmp2u9xyq6_.swift:15:59: error: cannot convert value of type 'ReversedCollection<String>.Element'\
    \ (aka 'Character') to closure result type 'String'\n    return s.isEmpty ? s\
    \ : s.reversed().map { $0.isLetter ? $0.isUppercase ? Character($0.lowercased())\
    \ : Character($0.uppercased()) : $0 }.joined()\n                             \
    \                 ~~~~~~~~~~~~^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n"
  stdout: ''
  timestamp: 1659978813
- exit_code: -4
  program: "\n/// You are given a string s.\n/// if s[i] is a letter, reverse its\
    \ case from lower to upper or vise versa, \n/// otherwise keep it as it is.\n\
    /// If the string contains no letters, reverse the string.\n/// The function should\
    \ return the resulted string.\n/// Examples\n/// >>> solve(s: \"1234\")\n/// \"\
    4321\"\n/// >>> solve(s: \"ab\")\n/// \"AB\"\n/// >>> solve(s: \"#a@C\")\n///\
    \ \"#A@c\"\nfunc solve(s: String) -> String {\n    var result = \"\"\n    for\
    \ c in s {\n        if let lowCase = c.lowercased().first, lowCase == c {\n  \
    \          result.append(c.uppercased())\n        } else if let upCase = c.uppercased().first,\
    \ upCase == c {\n            result.append(c.lowercased())\n        } else {\n\
    \            result.append(c)\n        }\n    }\n    return s.contains(\"a\")\
    \ || s.contains(\"A\") ? result : String(result.reversed())\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(solve(s: \"AsDf\") == \"aSdF\")\nassert(solve(s: \"1234\"\
    ) == \"4321\")\nassert(solve(s: \"ab\") == \"AB\")\nassert(solve(s: \"#a@C\")\
    \ == \"#A@c\")\nassert(solve(s: \"#AsdfW^45\") == \"#aSDFw^45\")\nassert(solve(s:\
    \ \"#6@2\") == \"2@6#\")\nassert(solve(s: \"#$a^D\") == \"#$A^d\")\nassert(solve(s:\
    \ \"#ccc\") == \"#CCC\")"
  status: Exception
  stderr: 'tmpook3zux7/tmpook3zux7.swift:48: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002ad3d35f7c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002ad3d32eeb6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002ad3d32ee988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002ad3d32ed7b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpook3zux7                        0x0000557fef9a2100 <unavailable> + 8448

    5    libc.so.6                          0x00002ad3d37e3460 __libc_start_main +
    245

    6    tmpook3zux7                        0x0000557fef9a1599 <unavailable> + 5529

    '
  stdout: ''
  timestamp: 1659978813
- exit_code: 1
  program: "\n/// You are given a string s.\n/// if s[i] is a letter, reverse its\
    \ case from lower to upper or vise versa, \n/// otherwise keep it as it is.\n\
    /// If the string contains no letters, reverse the string.\n/// The function should\
    \ return the resulted string.\n/// Examples\n/// >>> solve(s: \"1234\")\n/// \"\
    4321\"\n/// >>> solve(s: \"ab\")\n/// \"AB\"\n/// >>> solve(s: \"#a@C\")\n///\
    \ \"#A@c\"\nfunc solve(s: String) -> String {\n    // your code\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(solve(s: \"AsDf\") == \"aSdF\")\nassert(solve(s: \"1234\"\
    ) == \"4321\")\nassert(solve(s: \"ab\") == \"AB\")\nassert(solve(s: \"#a@C\")\
    \ == \"#A@c\")\nassert(solve(s: \"#AsdfW^45\") == \"#aSDFw^45\")\nassert(solve(s:\
    \ \"#6@2\") == \"2@6#\")\nassert(solve(s: \"#$a^D\") == \"#$A^d\")\nassert(solve(s:\
    \ \"#ccc\") == \"#CCC\")"
  status: SyntaxError
  stderr: '/tmp/tmp7szcyzvb.swift:16:1: error: missing return in global function expected
    to return ''String''

    }

    ^

    '
  stdout: ''
  timestamp: 1659978813
- exit_code: 0
  program: "\n/// You are given a string s.\n/// if s[i] is a letter, reverse its\
    \ case from lower to upper or vise versa, \n/// otherwise keep it as it is.\n\
    /// If the string contains no letters, reverse the string.\n/// The function should\
    \ return the resulted string.\n/// Examples\n/// >>> solve(s: \"1234\")\n/// \"\
    4321\"\n/// >>> solve(s: \"ab\")\n/// \"AB\"\n/// >>> solve(s: \"#a@C\")\n///\
    \ \"#A@c\"\nfunc solve(s: String) -> String {\n    let lowerLetters = \"abcdefghijklmnopqrstuvwxyz\"\
    \n    let upperLetters = \"ABCDEFGHIJKLMNOPQRSTUVWXYZ\"\n    var reverseString\
    \ = \"\"\n    var hasLetter = false\n    for char in s {\n        if lowerLetters.contains(char)\
    \ {\n            hasLetter = true\n            let idx = lowerLetters.firstIndex(of:\
    \ char)!\n            reverseString.append(upperLetters[idx])\n        } else\
    \ if upperLetters.contains(char) {\n            hasLetter = true\n           \
    \ let idx = upperLetters.firstIndex(of: char)!\n            reverseString.append(lowerLetters[idx])\n\
    \        } else {\n            reverseString.append(char)\n        }\n    }\n\
    \    return hasLetter ? reverseString : String(reverseString.reversed())\n}\n\n\
    \nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(solve(s: \"AsDf\") == \"aSdF\")\nassert(solve(s:\
    \ \"1234\") == \"4321\")\nassert(solve(s: \"ab\") == \"AB\")\nassert(solve(s:\
    \ \"#a@C\") == \"#A@c\")\nassert(solve(s: \"#AsdfW^45\") == \"#aSDFw^45\")\nassert(solve(s:\
    \ \"#6@2\") == \"2@6#\")\nassert(solve(s: \"#$a^D\") == \"#$A^d\")\nassert(solve(s:\
    \ \"#ccc\") == \"#CCC\")"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659978813
- exit_code: 1
  program: "\n/// You are given a string s.\n/// if s[i] is a letter, reverse its\
    \ case from lower to upper or vise versa, \n/// otherwise keep it as it is.\n\
    /// If the string contains no letters, reverse the string.\n/// The function should\
    \ return the resulted string.\n/// Examples\n/// >>> solve(s: \"1234\")\n/// \"\
    4321\"\n/// >>> solve(s: \"ab\")\n/// \"AB\"\n/// >>> solve(s: \"#a@C\")\n///\
    \ \"#A@c\"\nfunc solve(s: String) -> String {\n    let S = s.components(separatedBy:\
    \ .punctuationCharacters).joined()\n    let s = S.components(separatedBy: .whitespaces).joined()\n\
    \    if s.isEmpty {\n        return String(s.reversed())\n    }\n    var res =\
    \ \"\"\n    for c in s {\n        if c.isLetter {\n            res.append(c.isUppercase\
    \ ? c.lowercased() : c.uppercased())\n        } else {\n            res.append(c)\n\
    \        }\n    }\n    return res\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int,\
    \ Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n\
    \    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n          \
    \  return false\n        }\n    }\n    return true\n}\n            \nassert(solve(s:\
    \ \"AsDf\") == \"aSdF\")\nassert(solve(s: \"1234\") == \"4321\")\nassert(solve(s:\
    \ \"ab\") == \"AB\")\nassert(solve(s: \"#a@C\") == \"#A@c\")\nassert(solve(s:\
    \ \"#AsdfW^45\") == \"#aSDFw^45\")\nassert(solve(s: \"#6@2\") == \"2@6#\")\nassert(solve(s:\
    \ \"#$a^D\") == \"#$A^d\")\nassert(solve(s: \"#ccc\") == \"#CCC\")"
  status: SyntaxError
  stderr: "/tmp/tmp31z_4awc.swift:15:15: error: value of type 'String' has no member\
    \ 'components'\n    let S = s.components(separatedBy: .punctuationCharacters).joined()\n\
    \            ~ ^~~~~~~~~~\n/tmp/tmp31z_4awc.swift:15:40: error: cannot infer contextual\
    \ base in reference to member 'punctuationCharacters'\n    let S = s.components(separatedBy:\
    \ .punctuationCharacters).joined()\n                                      ~^~~~~~~~~~~~~~~~~~~~~\n\
    /tmp/tmp31z_4awc.swift:16:40: error: cannot infer contextual base in reference\
    \ to member 'whitespaces'\n    let s = S.components(separatedBy: .whitespaces).joined()\n\
    \                                      ~^~~~~~~~~~~\n"
  stdout: ''
  timestamp: 1659978813
- exit_code: -4
  program: "\n/// You are given a string s.\n/// if s[i] is a letter, reverse its\
    \ case from lower to upper or vise versa, \n/// otherwise keep it as it is.\n\
    /// If the string contains no letters, reverse the string.\n/// The function should\
    \ return the resulted string.\n/// Examples\n/// >>> solve(s: \"1234\")\n/// \"\
    4321\"\n/// >>> solve(s: \"ab\")\n/// \"AB\"\n/// >>> solve(s: \"#a@C\")\n///\
    \ \"#A@c\"\nfunc solve(s: String) -> String {\n    var result: String = \"\"\n\
    \    for char in s {\n        if char.isLetter {\n            if char.isUppercase\
    \ {\n                result.append(char.lowercased())\n            } else {\n\
    \                result.append(char.uppercased())\n            }\n        } else\
    \ {\n            result.append(char)\n        }\n    }\n    return s.isEmpty ||\
    \ !s.contains(\"a\") ? String(s.reversed()) : result\n}\n\n\nfunc ==(left: [(Int,\
    \ Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n\
    \        return false\n    }\n    for (l, r) in zip(left, right) {\n        if\
    \ l != r {\n            return false\n        }\n    }\n    return true\n}\n \
    \           \nassert(solve(s: \"AsDf\") == \"aSdF\")\nassert(solve(s: \"1234\"\
    ) == \"4321\")\nassert(solve(s: \"ab\") == \"AB\")\nassert(solve(s: \"#a@C\")\
    \ == \"#A@c\")\nassert(solve(s: \"#AsdfW^45\") == \"#aSDFw^45\")\nassert(solve(s:\
    \ \"#6@2\") == \"2@6#\")\nassert(solve(s: \"#$a^D\") == \"#$A^d\")\nassert(solve(s:\
    \ \"#ccc\") == \"#CCC\")"
  status: Exception
  stderr: 'tmptd_el5yb/tmptd_el5yb.swift:43: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002afc4d512c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002afc4d209b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002afc4d209988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002afc4d2087b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmptd_el5yb                        0x000055fa18a9e967 <unavailable> + 6503

    5    libc.so.6                          0x00002afc4d6fe460 __libc_start_main +
    245

    6    tmptd_el5yb                        0x000055fa18a9e5a9 <unavailable> + 5545

    '
  stdout: ''
  timestamp: 1659978813
- exit_code: 1
  program: "\n/// You are given a string s.\n/// if s[i] is a letter, reverse its\
    \ case from lower to upper or vise versa, \n/// otherwise keep it as it is.\n\
    /// If the string contains no letters, reverse the string.\n/// The function should\
    \ return the resulted string.\n/// Examples\n/// >>> solve(s: \"1234\")\n/// \"\
    4321\"\n/// >>> solve(s: \"ab\")\n/// \"AB\"\n/// >>> solve(s: \"#a@C\")\n///\
    \ \"#A@c\"\nfunc solve(s: String) -> String {\n    guard s.rangeOfCharacter(from:\
    \ CharacterSet.letters) != nil else {\n        return String(s.reversed())\n \
    \   }\n    var result = \"\"\n    for character in s {\n        if character.isLetter\
    \ {\n            result.append(character.isUppercase ?\n                String(character).lowercased()\
    \ :\n                String(character).uppercased())\n        } else {\n     \
    \       result.append(character)\n        }\n    }\n    return result\n}\n\n\n\
    func ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(solve(s: \"AsDf\") == \"aSdF\")\nassert(solve(s:\
    \ \"1234\") == \"4321\")\nassert(solve(s: \"ab\") == \"AB\")\nassert(solve(s:\
    \ \"#a@C\") == \"#A@c\")\nassert(solve(s: \"#AsdfW^45\") == \"#aSDFw^45\")\nassert(solve(s:\
    \ \"#6@2\") == \"2@6#\")\nassert(solve(s: \"#$a^D\") == \"#$A^d\")\nassert(solve(s:\
    \ \"#ccc\") == \"#CCC\")"
  status: SyntaxError
  stderr: "/tmp/tmpgyd1mh5h.swift:15:36: error: cannot find 'CharacterSet' in scope\n\
    \    guard s.rangeOfCharacter(from: CharacterSet.letters) != nil else {\n    \
    \                               ^~~~~~~~~~~~\n/tmp/tmpgyd1mh5h.swift:15:13: error:\
    \ value of type 'String' has no member 'rangeOfCharacter'\n    guard s.rangeOfCharacter(from:\
    \ CharacterSet.letters) != nil else {\n          ~ ^~~~~~~~~~~~~~~~\n"
  stdout: ''
  timestamp: 1659978813
- exit_code: -4
  program: "\n/// You are given a string s.\n/// if s[i] is a letter, reverse its\
    \ case from lower to upper or vise versa, \n/// otherwise keep it as it is.\n\
    /// If the string contains no letters, reverse the string.\n/// The function should\
    \ return the resulted string.\n/// Examples\n/// >>> solve(s: \"1234\")\n/// \"\
    4321\"\n/// >>> solve(s: \"ab\")\n/// \"AB\"\n/// >>> solve(s: \"#a@C\")\n///\
    \ \"#A@c\"\nfunc solve(s: String) -> String {\n    return \"\"\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(solve(s: \"AsDf\") == \"aSdF\")\nassert(solve(s: \"1234\"\
    ) == \"4321\")\nassert(solve(s: \"ab\") == \"AB\")\nassert(solve(s: \"#a@C\")\
    \ == \"#A@c\")\nassert(solve(s: \"#AsdfW^45\") == \"#aSDFw^45\")\nassert(solve(s:\
    \ \"#6@2\") == \"2@6#\")\nassert(solve(s: \"#$a^D\") == \"#$A^d\")\nassert(solve(s:\
    \ \"#ccc\") == \"#CCC\")"
  status: Exception
  stderr: 'tmpiark_u6w/tmpiark_u6w.swift:31: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002aca5c89dc80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002aca5c594b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002aca5c594988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002aca5c5937b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpiark_u6w                        0x0000562c1ac34307 <unavailable> + 4871

    5    libc.so.6                          0x00002aca5ca89460 __libc_start_main +
    245

    6    tmpiark_u6w                        0x0000562c1ac33f49 <unavailable> + 3913

    '
  stdout: ''
  timestamp: 1659978811
- exit_code: -4
  program: "\n/// You are given a string s.\n/// if s[i] is a letter, reverse its\
    \ case from lower to upper or vise versa, \n/// otherwise keep it as it is.\n\
    /// If the string contains no letters, reverse the string.\n/// The function should\
    \ return the resulted string.\n/// Examples\n/// >>> solve(s: \"1234\")\n/// \"\
    4321\"\n/// >>> solve(s: \"ab\")\n/// \"AB\"\n/// >>> solve(s: \"#a@C\")\n///\
    \ \"#A@c\"\nfunc solve(s: String) -> String {\n    var newS = \"\"\n    for letter\
    \ in s {\n        if letter.isLetter {\n            newS.append(letter.isUppercase\
    \ ? letter.lowercased() : letter.uppercased())\n        } else {\n           \
    \ newS.append(letter)\n        }\n    }\n    return newS.isEmpty ? String(s.reversed())\
    \ : newS\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n\
    \    if left.count != right.count {\n        return false\n    }\n    for (l,\
    \ r) in zip(left, right) {\n        if l != r {\n            return false\n  \
    \      }\n    }\n    return true\n}\n            \nassert(solve(s: \"AsDf\") ==\
    \ \"aSdF\")\nassert(solve(s: \"1234\") == \"4321\")\nassert(solve(s: \"ab\") ==\
    \ \"AB\")\nassert(solve(s: \"#a@C\") == \"#A@c\")\nassert(solve(s: \"#AsdfW^45\"\
    ) == \"#aSDFw^45\")\nassert(solve(s: \"#6@2\") == \"2@6#\")\nassert(solve(s: \"\
    #$a^D\") == \"#$A^d\")\nassert(solve(s: \"#ccc\") == \"#CCC\")"
  status: Exception
  stderr: 'tmpt9fesyvh/tmpt9fesyvh.swift:40: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002afba0786c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002afba047db6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002afba047d988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002afba047c7b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpt9fesyvh                        0x000055bfaadee8d7 <unavailable> + 6359

    5    libc.so.6                          0x00002afba0972460 __libc_start_main +
    245

    6    tmpt9fesyvh                        0x000055bfaadee429 <unavailable> + 5161

    '
  stdout: ''
  timestamp: 1659978813
- exit_code: -4
  program: "\n/// You are given a string s.\n/// if s[i] is a letter, reverse its\
    \ case from lower to upper or vise versa, \n/// otherwise keep it as it is.\n\
    /// If the string contains no letters, reverse the string.\n/// The function should\
    \ return the resulted string.\n/// Examples\n/// >>> solve(s: \"1234\")\n/// \"\
    4321\"\n/// >>> solve(s: \"ab\")\n/// \"AB\"\n/// >>> solve(s: \"#a@C\")\n///\
    \ \"#A@c\"\nfunc solve(s: String) -> String {\n    if s.lowercased() == s {\n\
    \        return s.uppercased()\n    } else if s.uppercased() == s {\n        return\
    \ s.lowercased()\n    } else {\n        var result = \"\"\n        for c in s\
    \ {\n            if c.isLowercase {\n                result.append(c.uppercased())\n\
    \            } else if c.isUppercase {\n                result.append(c.lowercased())\n\
    \            } else {\n                result.append(c)\n            }\n     \
    \   }\n        return result\n    }\n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(solve(s: \"AsDf\") == \"aSdF\")\nassert(solve(s: \"1234\") == \"4321\"\
    )\nassert(solve(s: \"ab\") == \"AB\")\nassert(solve(s: \"#a@C\") == \"#A@c\")\n\
    assert(solve(s: \"#AsdfW^45\") == \"#aSDFw^45\")\nassert(solve(s: \"#6@2\") ==\
    \ \"2@6#\")\nassert(solve(s: \"#$a^D\") == \"#$A^d\")\nassert(solve(s: \"#ccc\"\
    ) == \"#CCC\")"
  status: Exception
  stderr: 'tmprxx4okg6/tmprxx4okg6.swift:48: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b9e87fc7c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b9e87cbeb6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b9e87cbe988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b9e87cbd7b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmprxx4okg6                        0x000055c856ff3757 <unavailable> + 5975

    5    libc.so.6                          0x00002b9e881b3460 __libc_start_main +
    245

    6    tmprxx4okg6                        0x000055c856ff32a9 <unavailable> + 4777

    '
  stdout: ''
  timestamp: 1659978813
- exit_code: -4
  program: "\n/// You are given a string s.\n/// if s[i] is a letter, reverse its\
    \ case from lower to upper or vise versa, \n/// otherwise keep it as it is.\n\
    /// If the string contains no letters, reverse the string.\n/// The function should\
    \ return the resulted string.\n/// Examples\n/// >>> solve(s: \"1234\")\n/// \"\
    4321\"\n/// >>> solve(s: \"ab\")\n/// \"AB\"\n/// >>> solve(s: \"#a@C\")\n///\
    \ \"#A@c\"\nfunc solve(s: String) -> String {\n    var result: String = \"\"\n\
    \    for i in s {\n        if i >= \"a\" && i <= \"z\" {\n            result.append(i.uppercased())\n\
    \        } else if i >= \"A\" && i <= \"Z\" {\n            result.append(i.lowercased())\n\
    \        } else {\n            result.append(i)\n        }\n    }\n    return\
    \ result.count > 0 ? result : String(s.reversed())\n}\n\n\nfunc ==(left: [(Int,\
    \ Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n\
    \        return false\n    }\n    for (l, r) in zip(left, right) {\n        if\
    \ l != r {\n            return false\n        }\n    }\n    return true\n}\n \
    \           \nassert(solve(s: \"AsDf\") == \"aSdF\")\nassert(solve(s: \"1234\"\
    ) == \"4321\")\nassert(solve(s: \"ab\") == \"AB\")\nassert(solve(s: \"#a@C\")\
    \ == \"#A@c\")\nassert(solve(s: \"#AsdfW^45\") == \"#aSDFw^45\")\nassert(solve(s:\
    \ \"#6@2\") == \"2@6#\")\nassert(solve(s: \"#$a^D\") == \"#$A^d\")\nassert(solve(s:\
    \ \"#ccc\") == \"#CCC\")"
  status: Exception
  stderr: 'tmpde6_4k49/tmpde6_4k49.swift:42: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b9c5599cc80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b9c55693b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b9c55693988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b9c556927b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpde6_4k49                        0x000055929f5d39e7 <unavailable> + 6631

    5    libc.so.6                          0x00002b9c55b88460 __libc_start_main +
    245

    6    tmpde6_4k49                        0x000055929f5d3539 <unavailable> + 5433

    '
  stdout: ''
  timestamp: 1659978813
- exit_code: 1
  program: "\n/// You are given a string s.\n/// if s[i] is a letter, reverse its\
    \ case from lower to upper or vise versa, \n/// otherwise keep it as it is.\n\
    /// If the string contains no letters, reverse the string.\n/// The function should\
    \ return the resulted string.\n/// Examples\n/// >>> solve(s: \"1234\")\n/// \"\
    4321\"\n/// >>> solve(s: \"ab\")\n/// \"AB\"\n/// >>> solve(s: \"#a@C\")\n///\
    \ \"#A@c\"\nfunc solve(s: String) -> String {\n    guard s.count > 0 else { return\
    \ s }\n    let letters = Set(\"abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ\"\
    )\n    let reverse = String(s.reversed())\n    var result = \"\"\n    for char\
    \ in reverse {\n        if let uChar = UnicodeScalar(String(char)) {\n       \
    \     if letters.contains(uChar) {\n                result.append(String(unicodeScalarLiteral:\
    \ uChar.value ^ 32))\n            } else {\n                result.append(char)\n\
    \            }\n        }\n    }\n    return result\n}\n\n\nfunc ==(left: [(Int,\
    \ Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n\
    \        return false\n    }\n    for (l, r) in zip(left, right) {\n        if\
    \ l != r {\n            return false\n        }\n    }\n    return true\n}\n \
    \           \nassert(solve(s: \"AsDf\") == \"aSdF\")\nassert(solve(s: \"1234\"\
    ) == \"4321\")\nassert(solve(s: \"ab\") == \"AB\")\nassert(solve(s: \"#a@C\")\
    \ == \"#A@c\")\nassert(solve(s: \"#AsdfW^45\") == \"#aSDFw^45\")\nassert(solve(s:\
    \ \"#6@2\") == \"2@6#\")\nassert(solve(s: \"#$a^D\") == \"#$A^d\")\nassert(solve(s:\
    \ \"#ccc\") == \"#CCC\")"
  status: SyntaxError
  stderr: "/tmp/tmpgtcm5k13.swift:21:16: error: instance method 'contains' requires\
    \ that 'Unicode.Scalar' conform to 'Collection'\n            if letters.contains(uChar)\
    \ {\n               ^\n_StringProcessing.Collection:3:17: note: where 'C' = 'Unicode.Scalar'\n\
    \    public func contains<C>(_ other: C) -> Bool where C : Collection, Self.Element\
    \ == C.Element\n                ^\n/tmp/tmpgtcm5k13.swift:22:72: error: cannot\
    \ convert value of type 'UInt32' to expected argument type 'String'\n        \
    \        result.append(String(unicodeScalarLiteral: uChar.value ^ 32))\n     \
    \                                                                  ^\n"
  stdout: ''
  timestamp: 1659978813
- exit_code: 1
  program: "\n/// You are given a string s.\n/// if s[i] is a letter, reverse its\
    \ case from lower to upper or vise versa, \n/// otherwise keep it as it is.\n\
    /// If the string contains no letters, reverse the string.\n/// The function should\
    \ return the resulted string.\n/// Examples\n/// >>> solve(s: \"1234\")\n/// \"\
    4321\"\n/// >>> solve(s: \"ab\")\n/// \"AB\"\n/// >>> solve(s: \"#a@C\")\n///\
    \ \"#A@c\"\nfunc solve(s: String) -> String {\n    if s.count == 0 {\n       \
    \ return s\n    }\n    var result = \"\"\n    let letters = CharacterSet.letters\n\
    \    for item in s {\n        if letters.contains(item.unicodeScalars.first!)\
    \ {\n            result.append(String(item).lowercased() == String(item) ? String(item).uppercased()\
    \ : String(item).lowercased())\n        } else {\n            result.append(item)\n\
    \        }\n    }\n    return result.count == 0 ? String(s.reversed()) : result\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(solve(s: \"AsDf\") == \"aSdF\")\nassert(solve(s:\
    \ \"1234\") == \"4321\")\nassert(solve(s: \"ab\") == \"AB\")\nassert(solve(s:\
    \ \"#a@C\") == \"#A@c\")\nassert(solve(s: \"#AsdfW^45\") == \"#aSDFw^45\")\nassert(solve(s:\
    \ \"#6@2\") == \"2@6#\")\nassert(solve(s: \"#$a^D\") == \"#$A^d\")\nassert(solve(s:\
    \ \"#ccc\") == \"#CCC\")"
  status: SyntaxError
  stderr: "/tmp/tmpdws6s53z.swift:19:19: error: cannot find 'CharacterSet' in scope\n\
    \    let letters = CharacterSet.letters\n                  ^~~~~~~~~~~~\n"
  stdout: ''
  timestamp: 1659978813
- exit_code: 1
  program: "\n/// You are given a string s.\n/// if s[i] is a letter, reverse its\
    \ case from lower to upper or vise versa, \n/// otherwise keep it as it is.\n\
    /// If the string contains no letters, reverse the string.\n/// The function should\
    \ return the resulted string.\n/// Examples\n/// >>> solve(s: \"1234\")\n/// \"\
    4321\"\n/// >>> solve(s: \"ab\")\n/// \"AB\"\n/// >>> solve(s: \"#a@C\")\n///\
    \ \"#A@c\"\nfunc solve(s: String) -> String {\n    var s = s\n    guard let r\
    \ = s.rangeOfCharacter(from: CharacterSet.letters) else {\n        return String(s.reversed())\n\
    \    }\n    let ns = NSString(string: s)\n    let start = ns.rangeOfCharacter(from:\
    \ CharacterSet.letters, options: [], range: NSRange(location: 0, length: ns.length)).location\n\
    \    let end = ns.rangeOfCharacter(from: CharacterSet.letters, options: .backwards,\
    \ range: NSRange(location: 0, length: ns.length)).location\n    let range = NSRange(location:\
    \ start, length: end - start + 1)\n    let sub = ns.substring(with: range)\n \
    \   let subRev = String(sub.reversed())\n    let subEnum = sub.enumerated()\n\
    \    let subRevEnum = subRev.enumerated()\n    for (i, c) in subEnum {\n     \
    \   let nc = subRevEnum.first(where: { $0.offset == i })!.element\n        s.replaceSubrange(Range(range,\
    \ in: s)!.lowerBound.advanced(by: i), with: String(nc))\n    }\n    return s\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(solve(s: \"AsDf\") == \"aSdF\")\nassert(solve(s:\
    \ \"1234\") == \"4321\")\nassert(solve(s: \"ab\") == \"AB\")\nassert(solve(s:\
    \ \"#a@C\") == \"#A@c\")\nassert(solve(s: \"#AsdfW^45\") == \"#aSDFw^45\")\nassert(solve(s:\
    \ \"#6@2\") == \"2@6#\")\nassert(solve(s: \"#$a^D\") == \"#$A^d\")\nassert(solve(s:\
    \ \"#ccc\") == \"#CCC\")"
  status: SyntaxError
  stderr: "/tmp/tmpnhr84gi9.swift:16:44: error: cannot find 'CharacterSet' in scope\n\
    \    guard let r = s.rangeOfCharacter(from: CharacterSet.letters) else {\n   \
    \                                        ^~~~~~~~~~~~\n/tmp/tmpnhr84gi9.swift:16:21:\
    \ error: value of type 'String' has no member 'rangeOfCharacter'\n    guard let\
    \ r = s.rangeOfCharacter(from: CharacterSet.letters) else {\n                \
    \  ~ ^~~~~~~~~~~~~~~~\n/tmp/tmpnhr84gi9.swift:19:14: error: cannot find 'NSString'\
    \ in scope\n    let ns = NSString(string: s)\n             ^~~~~~~~\n/tmp/tmpnhr84gi9.swift:20:43:\
    \ error: cannot find 'CharacterSet' in scope\n    let start = ns.rangeOfCharacter(from:\
    \ CharacterSet.letters, options: [], range: NSRange(location: 0, length: ns.length)).location\n\
    \                                          ^~~~~~~~~~~~\n/tmp/tmpnhr84gi9.swift:20:85:\
    \ error: cannot find 'NSRange' in scope\n    let start = ns.rangeOfCharacter(from:\
    \ CharacterSet.letters, options: [], range: NSRange(location: 0, length: ns.length)).location\n\
    \                                                                            \
    \        ^~~~~~~\n/tmp/tmpnhr84gi9.swift:21:41: error: cannot find 'CharacterSet'\
    \ in scope\n    let end = ns.rangeOfCharacter(from: CharacterSet.letters, options:\
    \ .backwards, range: NSRange(location: 0, length: ns.length)).location\n     \
    \                                   ^~~~~~~~~~~~\n/tmp/tmpnhr84gi9.swift:21:91:\
    \ error: cannot find 'NSRange' in scope\n    let end = ns.rangeOfCharacter(from:\
    \ CharacterSet.letters, options: .backwards, range: NSRange(location: 0, length:\
    \ ns.length)).location\n                                                     \
    \                                     ^~~~~~~\n/tmp/tmpnhr84gi9.swift:21:73: error:\
    \ cannot infer contextual base in reference to member 'backwards'\n    let end\
    \ = ns.rangeOfCharacter(from: CharacterSet.letters, options: .backwards, range:\
    \ NSRange(location: 0, length: ns.length)).location\n                        \
    \                                               ~^~~~~~~~~\n/tmp/tmpnhr84gi9.swift:22:17:\
    \ error: cannot find 'NSRange' in scope\n  "
  stdout: ''
  timestamp: 1659978813
- exit_code: -4
  program: "\n/// You are given a string s.\n/// if s[i] is a letter, reverse its\
    \ case from lower to upper or vise versa, \n/// otherwise keep it as it is.\n\
    /// If the string contains no letters, reverse the string.\n/// The function should\
    \ return the resulted string.\n/// Examples\n/// >>> solve(s: \"1234\")\n/// \"\
    4321\"\n/// >>> solve(s: \"ab\")\n/// \"AB\"\n/// >>> solve(s: \"#a@C\")\n///\
    \ \"#A@c\"\nfunc solve(s: String) -> String {\n    var result = \"\"\n    for\
    \ char in s {\n        if char.isLetter {\n            if char.isUppercase {\n\
    \                result.append(char.lowercased())\n            } else {\n    \
    \            result.append(char.uppercased())\n            }\n        } else {\n\
    \            result.append(char)\n        }\n    }\n    return result.isEmpty\
    \ ? String(s.reversed()) : result\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int,\
    \ Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n\
    \    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n          \
    \  return false\n        }\n    }\n    return true\n}\n            \nassert(solve(s:\
    \ \"AsDf\") == \"aSdF\")\nassert(solve(s: \"1234\") == \"4321\")\nassert(solve(s:\
    \ \"ab\") == \"AB\")\nassert(solve(s: \"#a@C\") == \"#A@c\")\nassert(solve(s:\
    \ \"#AsdfW^45\") == \"#aSDFw^45\")\nassert(solve(s: \"#6@2\") == \"2@6#\")\nassert(solve(s:\
    \ \"#$a^D\") == \"#$A^d\")\nassert(solve(s: \"#ccc\") == \"#CCC\")"
  status: Exception
  stderr: 'tmpokj3mms0/tmpokj3mms0.swift:44: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b835a56dc80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b835a264b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b835a264988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b835a2637b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpokj3mms0                        0x0000559ec910f8d7 <unavailable> + 6359

    5    libc.so.6                          0x00002b835a759460 __libc_start_main +
    245

    6    tmpokj3mms0                        0x0000559ec910f429 <unavailable> + 5161

    '
  stdout: ''
  timestamp: 1659978813
- exit_code: -4
  program: "\n/// You are given a string s.\n/// if s[i] is a letter, reverse its\
    \ case from lower to upper or vise versa, \n/// otherwise keep it as it is.\n\
    /// If the string contains no letters, reverse the string.\n/// The function should\
    \ return the resulted string.\n/// Examples\n/// >>> solve(s: \"1234\")\n/// \"\
    4321\"\n/// >>> solve(s: \"ab\")\n/// \"AB\"\n/// >>> solve(s: \"#a@C\")\n///\
    \ \"#A@c\"\nfunc solve(s: String) -> String {\n\treturn \"\"\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(solve(s: \"AsDf\") == \"aSdF\")\nassert(solve(s: \"1234\"\
    ) == \"4321\")\nassert(solve(s: \"ab\") == \"AB\")\nassert(solve(s: \"#a@C\")\
    \ == \"#A@c\")\nassert(solve(s: \"#AsdfW^45\") == \"#aSDFw^45\")\nassert(solve(s:\
    \ \"#6@2\") == \"2@6#\")\nassert(solve(s: \"#$a^D\") == \"#$A^d\")\nassert(solve(s:\
    \ \"#ccc\") == \"#CCC\")"
  status: Exception
  stderr: 'tmp35y92jqc/tmp35y92jqc.swift:31: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b6fb34d3c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b6fb31cab6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b6fb31ca988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b6fb31c97b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmp35y92jqc                        0x00005653bdee6307 <unavailable> + 4871

    5    libc.so.6                          0x00002b6fb36bf460 __libc_start_main +
    245

    6    tmp35y92jqc                        0x00005653bdee5f49 <unavailable> + 3913

    '
  stdout: ''
  timestamp: 1659978813
- exit_code: -4
  program: "\n/// You are given a string s.\n/// if s[i] is a letter, reverse its\
    \ case from lower to upper or vise versa, \n/// otherwise keep it as it is.\n\
    /// If the string contains no letters, reverse the string.\n/// The function should\
    \ return the resulted string.\n/// Examples\n/// >>> solve(s: \"1234\")\n/// \"\
    4321\"\n/// >>> solve(s: \"ab\")\n/// \"AB\"\n/// >>> solve(s: \"#a@C\")\n///\
    \ \"#A@c\"\nfunc solve(s: String) -> String {\n    if s.lowercased() == s {\n\
    \        return s.uppercased()\n    } else if s.uppercased() == s {\n        return\
    \ s.lowercased()\n    } else {\n        var output = \"\"\n        for character\
    \ in s {\n            if character.isLetter {\n                output += character.isUppercase\
    \ ? character.lowercased() : character.uppercased()\n            } else {\n  \
    \              output += String(character)\n            }\n        }\n       \
    \ return output\n    }\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(solve(s: \"\
    AsDf\") == \"aSdF\")\nassert(solve(s: \"1234\") == \"4321\")\nassert(solve(s:\
    \ \"ab\") == \"AB\")\nassert(solve(s: \"#a@C\") == \"#A@c\")\nassert(solve(s:\
    \ \"#AsdfW^45\") == \"#aSDFw^45\")\nassert(solve(s: \"#6@2\") == \"2@6#\")\nassert(solve(s:\
    \ \"#$a^D\") == \"#$A^d\")\nassert(solve(s: \"#ccc\") == \"#CCC\")"
  status: Exception
  stderr: 'tmptnqu6qis/tmptnqu6qis.swift:46: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002ab82478ec80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002ab824485b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002ab824485988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002ab8244847b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmptnqu6qis                        0x0000559aec3ea757 <unavailable> + 5975

    5    libc.so.6                          0x00002ab82497a460 __libc_start_main +
    245

    6    tmptnqu6qis                        0x0000559aec3ea2a9 <unavailable> + 4777

    '
  stdout: ''
  timestamp: 1659978813
- exit_code: 1
  program: "\n/// You are given a string s.\n/// if s[i] is a letter, reverse its\
    \ case from lower to upper or vise versa, \n/// otherwise keep it as it is.\n\
    /// If the string contains no letters, reverse the string.\n/// The function should\
    \ return the resulted string.\n/// Examples\n/// >>> solve(s: \"1234\")\n/// \"\
    4321\"\n/// >>> solve(s: \"ab\")\n/// \"AB\"\n/// >>> solve(s: \"#a@C\")\n///\
    \ \"#A@c\"\nfunc solve(s: String) -> String {\n    return s.map { $0.isLetter\
    \ ? $0.isUppercase ? $0.lowercased() : $0.uppercased() : $0 }.joined()\n}\n\n\n\
    func ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(solve(s: \"AsDf\") == \"aSdF\")\nassert(solve(s:\
    \ \"1234\") == \"4321\")\nassert(solve(s: \"ab\") == \"AB\")\nassert(solve(s:\
    \ \"#a@C\") == \"#A@c\")\nassert(solve(s: \"#AsdfW^45\") == \"#aSDFw^45\")\nassert(solve(s:\
    \ \"#6@2\") == \"2@6#\")\nassert(solve(s: \"#$a^D\") == \"#$A^d\")\nassert(solve(s:\
    \ \"#ccc\") == \"#CCC\")"
  status: SyntaxError
  stderr: "/tmp/tmpurm46s8h.swift:15:32: error: cannot convert value of type 'String.Element'\
    \ (aka 'Character') to closure result type 'String'\n    return s.map { $0.isLetter\
    \ ? $0.isUppercase ? $0.lowercased() : $0.uppercased() : $0 }.joined()\n     \
    \              ~~~~~~~~~~~~^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n\
    /tmp/tmpurm46s8h.swift:15:49: error: result values in '? :' expression have mismatching\
    \ types 'String' and 'String.Element' (aka 'Character')\n    return s.map { $0.isLetter\
    \ ? $0.isUppercase ? $0.lowercased() : $0.uppercased() : $0 }.joined()\n     \
    \                            ~~~~~~~~~~~~~~~^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n"
  stdout: ''
  timestamp: 1659978813
- exit_code: -4
  program: "\n/// You are given a string s.\n/// if s[i] is a letter, reverse its\
    \ case from lower to upper or vise versa, \n/// otherwise keep it as it is.\n\
    /// If the string contains no letters, reverse the string.\n/// The function should\
    \ return the resulted string.\n/// Examples\n/// >>> solve(s: \"1234\")\n/// \"\
    4321\"\n/// >>> solve(s: \"ab\")\n/// \"AB\"\n/// >>> solve(s: \"#a@C\")\n///\
    \ \"#A@c\"\nfunc solve(s: String) -> String {\n    var result = \"\"\n    for\
    \ c in s {\n        if c.isLetter {\n            result.append(c.isLowercase ?\
    \ c.uppercased() : c.lowercased())\n        } else {\n            result.append(c)\n\
    \        }\n    }\n    return result.isEmpty ? String(s.reversed()) : result\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(solve(s: \"AsDf\") == \"aSdF\")\nassert(solve(s:\
    \ \"1234\") == \"4321\")\nassert(solve(s: \"ab\") == \"AB\")\nassert(solve(s:\
    \ \"#a@C\") == \"#A@c\")\nassert(solve(s: \"#AsdfW^45\") == \"#aSDFw^45\")\nassert(solve(s:\
    \ \"#6@2\") == \"2@6#\")\nassert(solve(s: \"#$a^D\") == \"#$A^d\")\nassert(solve(s:\
    \ \"#ccc\") == \"#CCC\")"
  status: Exception
  stderr: 'tmp3g4mx_o0/tmp3g4mx_o0.swift:40: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b7cd7bf9c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b7cd78f0b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b7cd78f0988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b7cd78ef7b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmp3g4mx_o0                        0x000055a4471848d7 <unavailable> + 6359

    5    libc.so.6                          0x00002b7cd7de5460 __libc_start_main +
    245

    6    tmp3g4mx_o0                        0x000055a447184429 <unavailable> + 5161

    '
  stdout: ''
  timestamp: 1659978811
- exit_code: -4
  program: "\n/// You are given a string s.\n/// if s[i] is a letter, reverse its\
    \ case from lower to upper or vise versa, \n/// otherwise keep it as it is.\n\
    /// If the string contains no letters, reverse the string.\n/// The function should\
    \ return the resulted string.\n/// Examples\n/// >>> solve(s: \"1234\")\n/// \"\
    4321\"\n/// >>> solve(s: \"ab\")\n/// \"AB\"\n/// >>> solve(s: \"#a@C\")\n///\
    \ \"#A@c\"\nfunc solve(s: String) -> String {\n    guard !s.isEmpty else { return\
    \ \"\" }\n    var result = s\n    for i in 0..<s.count {\n        let index =\
    \ s.index(s.startIndex, offsetBy: i)\n        let value = s[index]\n        if\
    \ let character = value.asciiValue {\n            if character >= 65 && character\
    \ <= 90 {\n                result.replaceSubrange(index...index, with: String(value).lowercased())\n\
    \            } else if character >= 97 && character <= 122 {\n               \
    \ result.replaceSubrange(index...index, with: String(value).uppercased())\n  \
    \          }\n        }\n    }\n    return result\n}\n\n\nfunc ==(left: [(Int,\
    \ Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n\
    \        return false\n    }\n    for (l, r) in zip(left, right) {\n        if\
    \ l != r {\n            return false\n        }\n    }\n    return true\n}\n \
    \           \nassert(solve(s: \"AsDf\") == \"aSdF\")\nassert(solve(s: \"1234\"\
    ) == \"4321\")\nassert(solve(s: \"ab\") == \"AB\")\nassert(solve(s: \"#a@C\")\
    \ == \"#A@c\")\nassert(solve(s: \"#AsdfW^45\") == \"#aSDFw^45\")\nassert(solve(s:\
    \ \"#6@2\") == \"2@6#\")\nassert(solve(s: \"#$a^D\") == \"#$A^d\")\nassert(solve(s:\
    \ \"#ccc\") == \"#CCC\")"
  status: Exception
  stderr: 'tmpk08wvi58/tmpk08wvi58.swift:45: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002afa19734c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002afa1942bb6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002afa1942b988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002afa1942a7b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpk08wvi58                        0x000055d7024bca67 <unavailable> + 6759

    5    libc.so.6                          0x00002afa19920460 __libc_start_main +
    245

    6    tmpk08wvi58                        0x000055d7024bc5b9 <unavailable> + 5561

    '
  stdout: ''
  timestamp: 1659978813
- exit_code: -4
  program: "\n/// You are given a string s.\n/// if s[i] is a letter, reverse its\
    \ case from lower to upper or vise versa, \n/// otherwise keep it as it is.\n\
    /// If the string contains no letters, reverse the string.\n/// The function should\
    \ return the resulted string.\n/// Examples\n/// >>> solve(s: \"1234\")\n/// \"\
    4321\"\n/// >>> solve(s: \"ab\")\n/// \"AB\"\n/// >>> solve(s: \"#a@C\")\n///\
    \ \"#A@c\"\nfunc solve(s: String) -> String {\n    if s.lowercased() == s {\n\
    \        return s.uppercased()\n    } else if s.uppercased() == s {\n        return\
    \ s.lowercased()\n    } else {\n        return String(s.reversed())\n    }\n}\n\
    \n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(solve(s: \"AsDf\") == \"aSdF\")\nassert(solve(s:\
    \ \"1234\") == \"4321\")\nassert(solve(s: \"ab\") == \"AB\")\nassert(solve(s:\
    \ \"#a@C\") == \"#A@c\")\nassert(solve(s: \"#AsdfW^45\") == \"#aSDFw^45\")\nassert(solve(s:\
    \ \"#6@2\") == \"2@6#\")\nassert(solve(s: \"#$a^D\") == \"#$A^d\")\nassert(solve(s:\
    \ \"#ccc\") == \"#CCC\")"
  status: Exception
  stderr: 'tmp69vnmnlj/tmp69vnmnlj.swift:37: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002ae082ac5c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002ae0827bcb6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002ae0827bc988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002ae0827bb7b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmp69vnmnlj                        0x00005620bbb99597 <unavailable> + 5527

    5    libc.so.6                          0x00002ae082cb1460 __libc_start_main +
    245

    6    tmp69vnmnlj                        0x00005620bbb991d9 <unavailable> + 4569

    '
  stdout: ''
  timestamp: 1659978813
- exit_code: -4
  program: "\n/// You are given a string s.\n/// if s[i] is a letter, reverse its\
    \ case from lower to upper or vise versa, \n/// otherwise keep it as it is.\n\
    /// If the string contains no letters, reverse the string.\n/// The function should\
    \ return the resulted string.\n/// Examples\n/// >>> solve(s: \"1234\")\n/// \"\
    4321\"\n/// >>> solve(s: \"ab\")\n/// \"AB\"\n/// >>> solve(s: \"#a@C\")\n///\
    \ \"#A@c\"\nfunc solve(s: String) -> String {\n    var str = \"\"\n    for char\
    \ in s {\n        if char.isLetter {\n            str.append(char.lowercased()\
    \ == String(char) ? String(char).uppercased() : String(char).lowercased())\n \
    \       } else {\n            str.append(char)\n        }\n    }\n    return str.isEmpty\
    \ ? String(s.reversed()) : str\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int,\
    \ Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n\
    \    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n          \
    \  return false\n        }\n    }\n    return true\n}\n            \nassert(solve(s:\
    \ \"AsDf\") == \"aSdF\")\nassert(solve(s: \"1234\") == \"4321\")\nassert(solve(s:\
    \ \"ab\") == \"AB\")\nassert(solve(s: \"#a@C\") == \"#A@c\")\nassert(solve(s:\
    \ \"#AsdfW^45\") == \"#aSDFw^45\")\nassert(solve(s: \"#6@2\") == \"2@6#\")\nassert(solve(s:\
    \ \"#$a^D\") == \"#$A^d\")\nassert(solve(s: \"#ccc\") == \"#CCC\")"
  status: Exception
  stderr: 'tmpdzduqbvv/tmpdzduqbvv.swift:40: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b87af15dc80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b87aee54b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b87aee54988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b87aee537b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpdzduqbvv                        0x000055559c5ce937 <unavailable> + 6455

    5    libc.so.6                          0x00002b87af349460 __libc_start_main +
    245

    6    tmpdzduqbvv                        0x000055559c5ce489 <unavailable> + 5257

    '
  stdout: ''
  timestamp: 1659978813
- exit_code: 1
  program: "\n/// You are given a string s.\n/// if s[i] is a letter, reverse its\
    \ case from lower to upper or vise versa, \n/// otherwise keep it as it is.\n\
    /// If the string contains no letters, reverse the string.\n/// The function should\
    \ return the resulted string.\n/// Examples\n/// >>> solve(s: \"1234\")\n/// \"\
    4321\"\n/// >>> solve(s: \"ab\")\n/// \"AB\"\n/// >>> solve(s: \"#a@C\")\n///\
    \ \"#A@c\"\nfunc solve(s: String) -> String {\n    return s.reversed().map {\n\
    \        if $0.isLetter {\n            return $0.isUppercase ? Character($0.lowercased())\
    \ : Character($0.uppercased())\n        }\n        return $0\n    }.reduce(\"\"\
    , +)\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if\
    \ left.count != right.count {\n        return false\n    }\n    for (l, r) in\
    \ zip(left, right) {\n        if l != r {\n            return false\n        }\n\
    \    }\n    return true\n}\n            \nassert(solve(s: \"AsDf\") == \"aSdF\"\
    )\nassert(solve(s: \"1234\") == \"4321\")\nassert(solve(s: \"ab\") == \"AB\")\n\
    assert(solve(s: \"#a@C\") == \"#A@c\")\nassert(solve(s: \"#AsdfW^45\") == \"#aSDFw^45\"\
    )\nassert(solve(s: \"#6@2\") == \"2@6#\")\nassert(solve(s: \"#$a^D\") == \"#$A^d\"\
    )\nassert(solve(s: \"#ccc\") == \"#CCC\")"
  status: SyntaxError
  stderr: "/tmp/tmp1zgxcymv.swift:17:35: error: cannot convert return expression of\
    \ type 'Character' to return type 'String'\n            return $0.isUppercase\
    \ ? Character($0.lowercased()) : Character($0.uppercased())\n                \
    \   ~~~~~~~~~~~~~~~^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n"
  stdout: ''
  timestamp: 1659978813
- exit_code: 1
  program: "\n/// You are given a string s.\n/// if s[i] is a letter, reverse its\
    \ case from lower to upper or vise versa, \n/// otherwise keep it as it is.\n\
    /// If the string contains no letters, reverse the string.\n/// The function should\
    \ return the resulted string.\n/// Examples\n/// >>> solve(s: \"1234\")\n/// \"\
    4321\"\n/// >>> solve(s: \"ab\")\n/// \"AB\"\n/// >>> solve(s: \"#a@C\")\n///\
    \ \"#A@c\"\nfunc solve(s: String) -> String {\n    var reverseCase = \"\"\n  \
    \  if s.containsOnlyLetters() {\n        for ch in s {\n            if ch.isUppercase()\
    \ {\n                reverseCase += ch.lowercased()\n            } else {\n  \
    \              reverseCase += ch.uppercased()\n            }\n        }\n    }\
    \ else {\n        for ch in s.reversed() {\n            reverseCase += String(ch)\n\
    \        }\n    }\n    return reverseCase\n}\n\n\nfunc ==(left: [(Int, Int)],\
    \ right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n       \
    \ return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r\
    \ {\n            return false\n        }\n    }\n    return true\n}\n        \
    \    \nassert(solve(s: \"AsDf\") == \"aSdF\")\nassert(solve(s: \"1234\") == \"\
    4321\")\nassert(solve(s: \"ab\") == \"AB\")\nassert(solve(s: \"#a@C\") == \"#A@c\"\
    )\nassert(solve(s: \"#AsdfW^45\") == \"#aSDFw^45\")\nassert(solve(s: \"#6@2\"\
    ) == \"2@6#\")\nassert(solve(s: \"#$a^D\") == \"#$A^d\")\nassert(solve(s: \"#ccc\"\
    ) == \"#CCC\")"
  status: SyntaxError
  stderr: "/tmp/tmp9domfe_p.swift:16:10: error: value of type 'String' has no member\
    \ 'containsOnlyLetters'\n    if s.containsOnlyLetters() {\n       ~ ^~~~~~~~~~~~~~~~~~~\n\
    /tmp/tmp9domfe_p.swift:18:19: error: cannot call value of non-function type 'Bool'\n\
    \            if ch.isUppercase() {\n                  ^          ~~\n        \
    \                     \n"
  stdout: ''
  timestamp: 1659978813
- exit_code: 1
  program: "\n/// You are given a string s.\n/// if s[i] is a letter, reverse its\
    \ case from lower to upper or vise versa, \n/// otherwise keep it as it is.\n\
    /// If the string contains no letters, reverse the string.\n/// The function should\
    \ return the resulted string.\n/// Examples\n/// >>> solve(s: \"1234\")\n/// \"\
    4321\"\n/// >>> solve(s: \"ab\")\n/// \"AB\"\n/// >>> solve(s: \"#a@C\")\n///\
    \ \"#A@c\"\nfunc solve(s: String) -> String {\n    if s.isEmpty {\n        return\
    \ \"\"\n    }\n    var result = \"\"\n    for char in s {\n        result += isLetter(char:\
    \ char) ? toogleCase(char: char) : \"\\(char)\"\n    }\n    return result\n}\n\
    \n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(solve(s: \"AsDf\") == \"aSdF\")\nassert(solve(s:\
    \ \"1234\") == \"4321\")\nassert(solve(s: \"ab\") == \"AB\")\nassert(solve(s:\
    \ \"#a@C\") == \"#A@c\")\nassert(solve(s: \"#AsdfW^45\") == \"#aSDFw^45\")\nassert(solve(s:\
    \ \"#6@2\") == \"2@6#\")\nassert(solve(s: \"#$a^D\") == \"#$A^d\")\nassert(solve(s:\
    \ \"#ccc\") == \"#CCC\")"
  status: SyntaxError
  stderr: "/tmp/tmpvsx65w0g.swift:20:19: error: cannot find 'isLetter' in scope\n\
    \        result += isLetter(char: char) ? toogleCase(char: char) : \"\\(char)\"\
    \n                  ^~~~~~~~\n/tmp/tmpvsx65w0g.swift:20:42: error: cannot find\
    \ 'toogleCase' in scope\n        result += isLetter(char: char) ? toogleCase(char:\
    \ char) : \"\\(char)\"\n                                         ^~~~~~~~~~\n"
  stdout: ''
  timestamp: 1659978813
- exit_code: -4
  program: "\n/// You are given a string s.\n/// if s[i] is a letter, reverse its\
    \ case from lower to upper or vise versa, \n/// otherwise keep it as it is.\n\
    /// If the string contains no letters, reverse the string.\n/// The function should\
    \ return the resulted string.\n/// Examples\n/// >>> solve(s: \"1234\")\n/// \"\
    4321\"\n/// >>> solve(s: \"ab\")\n/// \"AB\"\n/// >>> solve(s: \"#a@C\")\n///\
    \ \"#A@c\"\nfunc solve(s: String) -> String {\n  return \"\"\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(solve(s: \"AsDf\") == \"aSdF\")\nassert(solve(s: \"1234\"\
    ) == \"4321\")\nassert(solve(s: \"ab\") == \"AB\")\nassert(solve(s: \"#a@C\")\
    \ == \"#A@c\")\nassert(solve(s: \"#AsdfW^45\") == \"#aSDFw^45\")\nassert(solve(s:\
    \ \"#6@2\") == \"2@6#\")\nassert(solve(s: \"#$a^D\") == \"#$A^d\")\nassert(solve(s:\
    \ \"#ccc\") == \"#CCC\")"
  status: Exception
  stderr: 'tmp70mw71yg/tmp70mw71yg.swift:31: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002ad3866cbc80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002ad3863c2b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002ad3863c2988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002ad3863c17b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmp70mw71yg                        0x000055b1ec08f307 <unavailable> + 4871

    5    libc.so.6                          0x00002ad3868b7460 __libc_start_main +
    245

    6    tmp70mw71yg                        0x000055b1ec08ef49 <unavailable> + 3913

    '
  stdout: ''
  timestamp: 1659978811
- exit_code: 1
  program: "\n/// You are given a string s.\n/// if s[i] is a letter, reverse its\
    \ case from lower to upper or vise versa, \n/// otherwise keep it as it is.\n\
    /// If the string contains no letters, reverse the string.\n/// The function should\
    \ return the resulted string.\n/// Examples\n/// >>> solve(s: \"1234\")\n/// \"\
    4321\"\n/// >>> solve(s: \"ab\")\n/// \"AB\"\n/// >>> solve(s: \"#a@C\")\n///\
    \ \"#A@c\"\nfunc solve(s: String) -> String {\n    var str = s\n    if s.rangeOfCharacter(from:\
    \ CharacterSet.letters) == nil {\n        str = String(s.reversed())\n    } else\
    \ {\n        for i in 0..<s.count {\n            if let j = s.index(s.startIndex,\
    \ offsetBy: i, limitedBy: s.endIndex) {\n                let c = s[j]\n      \
    \          if c.isLetter {\n                    let range = NSRange(location:\
    \ i, length: 1)\n                    str = str.replacingCharacters(in: range,\
    \ with: String(c).uppercased())\n                }\n            }\n        }\n\
    \    }\n    return str\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(solve(s: \"\
    AsDf\") == \"aSdF\")\nassert(solve(s: \"1234\") == \"4321\")\nassert(solve(s:\
    \ \"ab\") == \"AB\")\nassert(solve(s: \"#a@C\") == \"#A@c\")\nassert(solve(s:\
    \ \"#AsdfW^45\") == \"#aSDFw^45\")\nassert(solve(s: \"#6@2\") == \"2@6#\")\nassert(solve(s:\
    \ \"#$a^D\") == \"#$A^d\")\nassert(solve(s: \"#ccc\") == \"#CCC\")"
  status: SyntaxError
  stderr: "/tmp/tmpzfqdkes8.swift:16:33: error: cannot find 'CharacterSet' in scope\n\
    \    if s.rangeOfCharacter(from: CharacterSet.letters) == nil {\n            \
    \                    ^~~~~~~~~~~~\n/tmp/tmpzfqdkes8.swift:16:10: error: value\
    \ of type 'String' has no member 'rangeOfCharacter'\n    if s.rangeOfCharacter(from:\
    \ CharacterSet.letters) == nil {\n       ~ ^~~~~~~~~~~~~~~~\n/tmp/tmpzfqdkes8.swift:23:33:\
    \ error: cannot find 'NSRange' in scope\n                    let range = NSRange(location:\
    \ i, length: 1)\n                                ^~~~~~~\n/tmp/tmpzfqdkes8.swift:24:31:\
    \ error: value of type 'String' has no member 'replacingCharacters'\n        \
    \            str = str.replacingCharacters(in: range, with: String(c).uppercased())\n\
    \                          ~~~ ^~~~~~~~~~~~~~~~~~~\n"
  stdout: ''
  timestamp: 1659978813
- exit_code: 1
  program: "\n/// You are given a string s.\n/// if s[i] is a letter, reverse its\
    \ case from lower to upper or vise versa, \n/// otherwise keep it as it is.\n\
    /// If the string contains no letters, reverse the string.\n/// The function should\
    \ return the resulted string.\n/// Examples\n/// >>> solve(s: \"1234\")\n/// \"\
    4321\"\n/// >>> solve(s: \"ab\")\n/// \"AB\"\n/// >>> solve(s: \"#a@C\")\n///\
    \ \"#A@c\"\nfunc solve(s: String) -> String {\n    var newStr = \"\"\n    let\
    \ characterSet = CharacterSet.letters\n    if s.rangeOfCharacter(from: characterSet)\
    \ == nil {\n        return String(s.reversed())\n    }\n    for char in s {\n\
    \        if char.isUppercase {\n            newStr.append(char.lowercased())\n\
    \        } else if char.isLowercase {\n            newStr.append(char.uppercased())\n\
    \        } else {\n            newStr.append(char)\n        }\n    }\n    return\
    \ newStr\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n\
    \    if left.count != right.count {\n        return false\n    }\n    for (l,\
    \ r) in zip(left, right) {\n        if l != r {\n            return false\n  \
    \      }\n    }\n    return true\n}\n            \nassert(solve(s: \"AsDf\") ==\
    \ \"aSdF\")\nassert(solve(s: \"1234\") == \"4321\")\nassert(solve(s: \"ab\") ==\
    \ \"AB\")\nassert(solve(s: \"#a@C\") == \"#A@c\")\nassert(solve(s: \"#AsdfW^45\"\
    ) == \"#aSDFw^45\")\nassert(solve(s: \"#6@2\") == \"2@6#\")\nassert(solve(s: \"\
    #$a^D\") == \"#$A^d\")\nassert(solve(s: \"#ccc\") == \"#CCC\")"
  status: SyntaxError
  stderr: "/tmp/tmp5nxtggii.swift:16:24: error: cannot find 'CharacterSet' in scope\n\
    \    let characterSet = CharacterSet.letters\n                       ^~~~~~~~~~~~\n\
    /tmp/tmp5nxtggii.swift:17:10: error: value of type 'String' has no member 'rangeOfCharacter'\n\
    \    if s.rangeOfCharacter(from: characterSet) == nil {\n       ~ ^~~~~~~~~~~~~~~~\n"
  stdout: ''
  timestamp: 1659978813
- exit_code: 1
  program: "\n/// You are given a string s.\n/// if s[i] is a letter, reverse its\
    \ case from lower to upper or vise versa, \n/// otherwise keep it as it is.\n\
    /// If the string contains no letters, reverse the string.\n/// The function should\
    \ return the resulted string.\n/// Examples\n/// >>> solve(s: \"1234\")\n/// \"\
    4321\"\n/// >>> solve(s: \"ab\")\n/// \"AB\"\n/// >>> solve(s: \"#a@C\")\n///\
    \ \"#A@c\"\nfunc solve(s: String) -> String {\n    guard s.rangeOfCharacter(from:\
    \ CharacterSet.letters) != nil else {\n        return String(s.reversed())\n \
    \   }\n    return String(s.map { c in\n        if c.isLetter {\n            if\
    \ c.isUppercase {\n                return Character(c.lowercased())\n        \
    \    } else {\n                return Character(c.uppercased())\n            }\n\
    \        } else {\n            return c\n        }\n    })\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(solve(s: \"AsDf\") == \"aSdF\")\nassert(solve(s: \"1234\"\
    ) == \"4321\")\nassert(solve(s: \"ab\") == \"AB\")\nassert(solve(s: \"#a@C\")\
    \ == \"#A@c\")\nassert(solve(s: \"#AsdfW^45\") == \"#aSDFw^45\")\nassert(solve(s:\
    \ \"#6@2\") == \"2@6#\")\nassert(solve(s: \"#$a^D\") == \"#$A^d\")\nassert(solve(s:\
    \ \"#ccc\") == \"#CCC\")"
  status: SyntaxError
  stderr: "/tmp/tmpuc1381t8.swift:15:36: error: cannot find 'CharacterSet' in scope\n\
    \    guard s.rangeOfCharacter(from: CharacterSet.letters) != nil else {\n    \
    \                               ^~~~~~~~~~~~\n/tmp/tmpuc1381t8.swift:15:13: error:\
    \ value of type 'String' has no member 'rangeOfCharacter'\n    guard s.rangeOfCharacter(from:\
    \ CharacterSet.letters) != nil else {\n          ~ ^~~~~~~~~~~~~~~~\n"
  stdout: ''
  timestamp: 1659978813
- exit_code: 1
  program: "\n/// You are given a string s.\n/// if s[i] is a letter, reverse its\
    \ case from lower to upper or vise versa, \n/// otherwise keep it as it is.\n\
    /// If the string contains no letters, reverse the string.\n/// The function should\
    \ return the resulted string.\n/// Examples\n/// >>> solve(s: \"1234\")\n/// \"\
    4321\"\n/// >>> solve(s: \"ab\")\n/// \"AB\"\n/// >>> solve(s: \"#a@C\")\n///\
    \ \"#A@c\"\nfunc solve(s: String) -> String {\n    var result = \"\"\n    var\
    \ string = Array(s)\n    if containsLetters(s: s) {\n        for char in string\
    \ {\n            if char.isLetter {\n                if char.isUppercase {\n \
    \                   result.append(char.lowercased())\n                } else {\n\
    \                    result.append(char.uppercased())\n                }\n   \
    \         } else {\n                result.append(char)\n            }\n     \
    \   }\n    } else {\n        result = String(string.reversed())\n    }\n    return\
    \ result\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n\
    \    if left.count != right.count {\n        return false\n    }\n    for (l,\
    \ r) in zip(left, right) {\n        if l != r {\n            return false\n  \
    \      }\n    }\n    return true\n}\n            \nassert(solve(s: \"AsDf\") ==\
    \ \"aSdF\")\nassert(solve(s: \"1234\") == \"4321\")\nassert(solve(s: \"ab\") ==\
    \ \"AB\")\nassert(solve(s: \"#a@C\") == \"#A@c\")\nassert(solve(s: \"#AsdfW^45\"\
    ) == \"#aSDFw^45\")\nassert(solve(s: \"#6@2\") == \"2@6#\")\nassert(solve(s: \"\
    #$a^D\") == \"#$A^d\")\nassert(solve(s: \"#ccc\") == \"#CCC\")"
  status: SyntaxError
  stderr: "/tmp/tmpm0sxiu9h.swift:17:8: error: cannot find 'containsLetters' in scope\n\
    \    if containsLetters(s: s) {\n       ^~~~~~~~~~~~~~~\n"
  stdout: ''
  timestamp: 1659978813
- exit_code: 1
  program: "\n/// You are given a string s.\n/// if s[i] is a letter, reverse its\
    \ case from lower to upper or vise versa, \n/// otherwise keep it as it is.\n\
    /// If the string contains no letters, reverse the string.\n/// The function should\
    \ return the resulted string.\n/// Examples\n/// >>> solve(s: \"1234\")\n/// \"\
    4321\"\n/// >>> solve(s: \"ab\")\n/// \"AB\"\n/// >>> solve(s: \"#a@C\")\n///\
    \ \"#A@c\"\nfunc solve(s: String) -> String {\n    return s.reversed().map { $0.isLetter\
    \ ? $0.isUppercase ? Character($0.lowercased()) : Character($0.uppercased()) :\
    \ $0 }.joined()\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool\
    \ {\n    if left.count != right.count {\n        return false\n    }\n    for\
    \ (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(solve(s: \"AsDf\"\
    ) == \"aSdF\")\nassert(solve(s: \"1234\") == \"4321\")\nassert(solve(s: \"ab\"\
    ) == \"AB\")\nassert(solve(s: \"#a@C\") == \"#A@c\")\nassert(solve(s: \"#AsdfW^45\"\
    ) == \"#aSDFw^45\")\nassert(solve(s: \"#6@2\") == \"2@6#\")\nassert(solve(s: \"\
    #$a^D\") == \"#$A^d\")\nassert(solve(s: \"#ccc\") == \"#CCC\")"
  status: SyntaxError
  stderr: "/tmp/tmp6nms9h4b.swift:15:43: error: cannot convert value of type 'String.Element'\
    \ (aka 'Character') to closure result type 'String'\n    return s.reversed().map\
    \ { $0.isLetter ? $0.isUppercase ? Character($0.lowercased()) : Character($0.uppercased())\
    \ : $0 }.joined()\n                              ~~~~~~~~~~~~^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n"
  stdout: ''
  timestamp: 1659978813
- exit_code: 0
  program: "\n/// You are given a string s.\n/// if s[i] is a letter, reverse its\
    \ case from lower to upper or vise versa, \n/// otherwise keep it as it is.\n\
    /// If the string contains no letters, reverse the string.\n/// The function should\
    \ return the resulted string.\n/// Examples\n/// >>> solve(s: \"1234\")\n/// \"\
    4321\"\n/// >>> solve(s: \"ab\")\n/// \"AB\"\n/// >>> solve(s: \"#a@C\")\n///\
    \ \"#A@c\"\nfunc solve(s: String) -> String {\n    var chars = Array(s)\n    var\
    \ anyLetter = false\n    for i in 0..<chars.count {\n        let char = chars[i]\n\
    \        if char.isLetter {\n            anyLetter = true\n            if char.isLowercase\
    \ {\n                chars[i] = Character(char.uppercased())\n            } else\
    \ {\n                chars[i] = Character(char.lowercased())\n            }\n\
    \        }\n    }\n    if !anyLetter {\n        chars.reverse()\n    }\n    return\
    \ String(chars)\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool\
    \ {\n    if left.count != right.count {\n        return false\n    }\n    for\
    \ (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(solve(s: \"AsDf\"\
    ) == \"aSdF\")\nassert(solve(s: \"1234\") == \"4321\")\nassert(solve(s: \"ab\"\
    ) == \"AB\")\nassert(solve(s: \"#a@C\") == \"#A@c\")\nassert(solve(s: \"#AsdfW^45\"\
    ) == \"#aSDFw^45\")\nassert(solve(s: \"#6@2\") == \"2@6#\")\nassert(solve(s: \"\
    #$a^D\") == \"#$A^d\")\nassert(solve(s: \"#ccc\") == \"#CCC\")"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659978813
- exit_code: 1
  program: "\n/// You are given a string s.\n/// if s[i] is a letter, reverse its\
    \ case from lower to upper or vise versa, \n/// otherwise keep it as it is.\n\
    /// If the string contains no letters, reverse the string.\n/// The function should\
    \ return the resulted string.\n/// Examples\n/// >>> solve(s: \"1234\")\n/// \"\
    4321\"\n/// >>> solve(s: \"ab\")\n/// \"AB\"\n/// >>> solve(s: \"#a@C\")\n///\
    \ \"#A@c\"\nfunc solve(s: String) -> String {\n    let chars = Array(s.unicodeScalars)\n\
    \    var newChars = [Character]()\n    var letters = false\n    for i in 0..<chars.count\
    \ {\n        if(chars[i].isLetter){\n            letters = true\n            let\
    \ newChar = chars[i].value\n            if(newChar >= 65 && newChar <= 90){\n\
    \                newChars.append(Character(UnicodeScalar(newChar + 32)!))\n  \
    \          }else{\n                newChars.append(Character(UnicodeScalar(newChar\
    \ - 32)!))\n            }\n        }else{\n            newChars.append(Character(chars[i]))\n\
    \        }\n    }\n    if(letters){\n        return String(newChars)\n    }else{\n\
    \        return String(newChars.reversed())\n    }\n}\n\n\nfunc ==(left: [(Int,\
    \ Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n\
    \        return false\n    }\n    for (l, r) in zip(left, right) {\n        if\
    \ l != r {\n            return false\n        }\n    }\n    return true\n}\n \
    \           \nassert(solve(s: \"AsDf\") == \"aSdF\")\nassert(solve(s: \"1234\"\
    ) == \"4321\")\nassert(solve(s: \"ab\") == \"AB\")\nassert(solve(s: \"#a@C\")\
    \ == \"#A@c\")\nassert(solve(s: \"#AsdfW^45\") == \"#aSDFw^45\")\nassert(solve(s:\
    \ \"#6@2\") == \"2@6#\")\nassert(solve(s: \"#$a^D\") == \"#$A^d\")\nassert(solve(s:\
    \ \"#ccc\") == \"#CCC\")"
  status: SyntaxError
  stderr: "/tmp/tmpf7v0gr_k.swift:19:21: error: value of type 'Unicode.Scalar' has\
    \ no member 'isLetter'\n        if(chars[i].isLetter){\n           ~~~~~~~~ ^~~~~~~~\n"
  stdout: ''
  timestamp: 1659978813
- exit_code: -4
  program: "\n/// You are given a string s.\n/// if s[i] is a letter, reverse its\
    \ case from lower to upper or vise versa, \n/// otherwise keep it as it is.\n\
    /// If the string contains no letters, reverse the string.\n/// The function should\
    \ return the resulted string.\n/// Examples\n/// >>> solve(s: \"1234\")\n/// \"\
    4321\"\n/// >>> solve(s: \"ab\")\n/// \"AB\"\n/// >>> solve(s: \"#a@C\")\n///\
    \ \"#A@c\"\nfunc solve(s: String) -> String {\n    return \"\"\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(solve(s: \"AsDf\") == \"aSdF\")\nassert(solve(s: \"1234\"\
    ) == \"4321\")\nassert(solve(s: \"ab\") == \"AB\")\nassert(solve(s: \"#a@C\")\
    \ == \"#A@c\")\nassert(solve(s: \"#AsdfW^45\") == \"#aSDFw^45\")\nassert(solve(s:\
    \ \"#6@2\") == \"2@6#\")\nassert(solve(s: \"#$a^D\") == \"#$A^d\")\nassert(solve(s:\
    \ \"#ccc\") == \"#CCC\")"
  status: Exception
  stderr: 'tmpiark_u6w/tmpiark_u6w.swift:31: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002aca5c89dc80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002aca5c594b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002aca5c594988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002aca5c5937b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpiark_u6w                        0x0000562c1ac34307 <unavailable> + 4871

    5    libc.so.6                          0x00002aca5ca89460 __libc_start_main +
    245

    6    tmpiark_u6w                        0x0000562c1ac33f49 <unavailable> + 3913

    '
  stdout: ''
  timestamp: 1659978811
- exit_code: 1
  program: "\n/// You are given a string s.\n/// if s[i] is a letter, reverse its\
    \ case from lower to upper or vise versa, \n/// otherwise keep it as it is.\n\
    /// If the string contains no letters, reverse the string.\n/// The function should\
    \ return the resulted string.\n/// Examples\n/// >>> solve(s: \"1234\")\n/// \"\
    4321\"\n/// >>> solve(s: \"ab\")\n/// \"AB\"\n/// >>> solve(s: \"#a@C\")\n///\
    \ \"#A@c\"\nfunc solve(s: String) -> String {\n    var str = s\n    if s.isEmpty\
    \ {\n        return \"\"\n    }\n    if s.isNumber {\n        str = s.reverse\n\
    \    } else {\n        var newStr = \"\"\n        for char in s {\n          \
    \  if char.isUppercase {\n                newStr.append(char.lowercased())\n \
    \           } else if char.isLowercase {\n                newStr.append(char.uppercased())\n\
    \            } else {\n                newStr.append(char)\n            }\n  \
    \      }\n        str = newStr\n    }\n    return str\n}\n\n\nfunc ==(left: [(Int,\
    \ Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n\
    \        return false\n    }\n    for (l, r) in zip(left, right) {\n        if\
    \ l != r {\n            return false\n        }\n    }\n    return true\n}\n \
    \           \nassert(solve(s: \"AsDf\") == \"aSdF\")\nassert(solve(s: \"1234\"\
    ) == \"4321\")\nassert(solve(s: \"ab\") == \"AB\")\nassert(solve(s: \"#a@C\")\
    \ == \"#A@c\")\nassert(solve(s: \"#AsdfW^45\") == \"#aSDFw^45\")\nassert(solve(s:\
    \ \"#6@2\") == \"2@6#\")\nassert(solve(s: \"#$a^D\") == \"#$A^d\")\nassert(solve(s:\
    \ \"#ccc\") == \"#CCC\")"
  status: SyntaxError
  stderr: "/tmp/tmpjz9gumfz.swift:19:10: error: value of type 'String' has no member\
    \ 'isNumber'\n    if s.isNumber {\n       ~ ^~~~~~~~\n/tmp/tmpjz9gumfz.swift:20:17:\
    \ error: value of type 'String' has no member 'reverse'\n        str = s.reverse\n\
    \              ~ ^~~~~~~\n"
  stdout: ''
  timestamp: 1659978813
- exit_code: -4
  program: "\n/// You are given a string s.\n/// if s[i] is a letter, reverse its\
    \ case from lower to upper or vise versa, \n/// otherwise keep it as it is.\n\
    /// If the string contains no letters, reverse the string.\n/// The function should\
    \ return the resulted string.\n/// Examples\n/// >>> solve(s: \"1234\")\n/// \"\
    4321\"\n/// >>> solve(s: \"ab\")\n/// \"AB\"\n/// >>> solve(s: \"#a@C\")\n///\
    \ \"#A@c\"\nfunc solve(s: String) -> String {\n    var result = \"\"\n    for\
    \ character in s {\n        if (character.isLetter) {\n            result.append(String(character).lowercased()\
    \ == String(character) ? String(character).uppercased() : String(character).lowercased())\n\
    \        } else {\n            result.append(character)\n        }\n    }\n  \
    \  return result.count > 0 ? result : String(s.reversed())\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(solve(s: \"AsDf\") == \"aSdF\")\nassert(solve(s: \"1234\"\
    ) == \"4321\")\nassert(solve(s: \"ab\") == \"AB\")\nassert(solve(s: \"#a@C\")\
    \ == \"#A@c\")\nassert(solve(s: \"#AsdfW^45\") == \"#aSDFw^45\")\nassert(solve(s:\
    \ \"#6@2\") == \"2@6#\")\nassert(solve(s: \"#$a^D\") == \"#$A^d\")\nassert(solve(s:\
    \ \"#ccc\") == \"#CCC\")"
  status: Exception
  stderr: 'tmp1x_a5jbm/tmp1x_a5jbm.swift:40: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002adaeeabdc80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002adaee7b4b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002adaee7b4988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002adaee7b37b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmp1x_a5jbm                        0x00005646115a88d7 <unavailable> + 6359

    5    libc.so.6                          0x00002adaeeca9460 __libc_start_main +
    245

    6    tmp1x_a5jbm                        0x00005646115a8429 <unavailable> + 5161

    '
  stdout: ''
  timestamp: 1659978813
- exit_code: -4
  program: "\n/// You are given a string s.\n/// if s[i] is a letter, reverse its\
    \ case from lower to upper or vise versa, \n/// otherwise keep it as it is.\n\
    /// If the string contains no letters, reverse the string.\n/// The function should\
    \ return the resulted string.\n/// Examples\n/// >>> solve(s: \"1234\")\n/// \"\
    4321\"\n/// >>> solve(s: \"ab\")\n/// \"AB\"\n/// >>> solve(s: \"#a@C\")\n///\
    \ \"#A@c\"\nfunc solve(s: String) -> String {\n    let letters = s.filter { $0.isLetter\
    \ }\n    guard !letters.isEmpty else { return String(s.reversed()) }\n    let\
    \ result = s.map { $0.isLetter ? Character(String($0).uppercased()) : $0 }\n \
    \   return String(result)\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(solve(s: \"\
    AsDf\") == \"aSdF\")\nassert(solve(s: \"1234\") == \"4321\")\nassert(solve(s:\
    \ \"ab\") == \"AB\")\nassert(solve(s: \"#a@C\") == \"#A@c\")\nassert(solve(s:\
    \ \"#AsdfW^45\") == \"#aSDFw^45\")\nassert(solve(s: \"#6@2\") == \"2@6#\")\nassert(solve(s:\
    \ \"#$a^D\") == \"#$A^d\")\nassert(solve(s: \"#ccc\") == \"#CCC\")"
  status: Exception
  stderr: 'tmph627o9co/tmph627o9co.swift:34: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002ba3250ffc80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002ba324df6b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002ba324df6988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002ba324df57b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmph627o9co                        0x000055664e406847 <unavailable> + 6215

    5    libc.so.6                          0x00002ba3252eb460 __libc_start_main +
    245

    6    tmph627o9co                        0x000055664e406489 <unavailable> + 5257

    '
  stdout: ''
  timestamp: 1659978813
- exit_code: -4
  program: "\n/// You are given a string s.\n/// if s[i] is a letter, reverse its\
    \ case from lower to upper or vise versa, \n/// otherwise keep it as it is.\n\
    /// If the string contains no letters, reverse the string.\n/// The function should\
    \ return the resulted string.\n/// Examples\n/// >>> solve(s: \"1234\")\n/// \"\
    4321\"\n/// >>> solve(s: \"ab\")\n/// \"AB\"\n/// >>> solve(s: \"#a@C\")\n///\
    \ \"#A@c\"\nfunc solve(s: String) -> String {\n    var res = \"\"\n    for c in\
    \ s {\n        let scalars = c.unicodeScalars\n        let char = Character(UnicodeScalar(scalars[scalars.startIndex].value\
    \ ^ 32)!)\n        res.append(char)\n    }\n    return res\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(solve(s: \"AsDf\") == \"aSdF\")\nassert(solve(s: \"1234\"\
    ) == \"4321\")\nassert(solve(s: \"ab\") == \"AB\")\nassert(solve(s: \"#a@C\")\
    \ == \"#A@c\")\nassert(solve(s: \"#AsdfW^45\") == \"#aSDFw^45\")\nassert(solve(s:\
    \ \"#6@2\") == \"2@6#\")\nassert(solve(s: \"#$a^D\") == \"#$A^d\")\nassert(solve(s:\
    \ \"#ccc\") == \"#CCC\")"
  status: Exception
  stderr: 'tmpg66vaqai/tmpg66vaqai.swift:38: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b7e3b0ffc80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b7e3adf6b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b7e3adf6988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b7e3adf57b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpg66vaqai                        0x000055ee5110f817 <unavailable> + 6167

    5    libc.so.6                          0x00002b7e3b2eb460 __libc_start_main +
    245

    6    tmpg66vaqai                        0x000055ee5110f369 <unavailable> + 4969

    '
  stdout: ''
  timestamp: 1659978813
- exit_code: 0
  program: "\n/// You are given a string s.\n/// if s[i] is a letter, reverse its\
    \ case from lower to upper or vise versa, \n/// otherwise keep it as it is.\n\
    /// If the string contains no letters, reverse the string.\n/// The function should\
    \ return the resulted string.\n/// Examples\n/// >>> solve(s: \"1234\")\n/// \"\
    4321\"\n/// >>> solve(s: \"ab\")\n/// \"AB\"\n/// >>> solve(s: \"#a@C\")\n///\
    \ \"#A@c\"\nfunc solve(s: String) -> String {\n\tguard s.contains(where: { $0.isLetter\
    \ }) else {\n\t\treturn String(s.reversed())\n\t}\n\treturn String(s.map {\n\t\
    \t$0.isLetter ? $0.isUppercase ? Character($0.lowercased()) : Character($0.uppercased())\
    \ : $0\n\t})\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool\
    \ {\n    if left.count != right.count {\n        return false\n    }\n    for\
    \ (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(solve(s: \"AsDf\"\
    ) == \"aSdF\")\nassert(solve(s: \"1234\") == \"4321\")\nassert(solve(s: \"ab\"\
    ) == \"AB\")\nassert(solve(s: \"#a@C\") == \"#A@c\")\nassert(solve(s: \"#AsdfW^45\"\
    ) == \"#aSDFw^45\")\nassert(solve(s: \"#6@2\") == \"2@6#\")\nassert(solve(s: \"\
    #$a^D\") == \"#$A^d\")\nassert(solve(s: \"#ccc\") == \"#CCC\")"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659978813
- exit_code: 1
  program: "\n/// You are given a string s.\n/// if s[i] is a letter, reverse its\
    \ case from lower to upper or vise versa, \n/// otherwise keep it as it is.\n\
    /// If the string contains no letters, reverse the string.\n/// The function should\
    \ return the resulted string.\n/// Examples\n/// >>> solve(s: \"1234\")\n/// \"\
    4321\"\n/// >>> solve(s: \"ab\")\n/// \"AB\"\n/// >>> solve(s: \"#a@C\")\n///\
    \ \"#A@c\"\nfunc solve(s: String) -> String {\n  let letters = CharacterSet.letters\n\
    \  let s = s.unicodeScalars\n  var result = \"\"\n  for c in s {\n    if letters.contains(c)\
    \ {\n      result.append(Character(UnicodeScalar(c.value ^ 32)!))\n    } else\
    \ {\n      result.append(Character(c))\n    }\n  }\n  return result\n}\n\n\nfunc\
    \ ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count !=\
    \ right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(solve(s: \"AsDf\") == \"aSdF\")\nassert(solve(s:\
    \ \"1234\") == \"4321\")\nassert(solve(s: \"ab\") == \"AB\")\nassert(solve(s:\
    \ \"#a@C\") == \"#A@c\")\nassert(solve(s: \"#AsdfW^45\") == \"#aSDFw^45\")\nassert(solve(s:\
    \ \"#6@2\") == \"2@6#\")\nassert(solve(s: \"#$a^D\") == \"#$A^d\")\nassert(solve(s:\
    \ \"#ccc\") == \"#CCC\")"
  status: SyntaxError
  stderr: "/tmp/tmpz4hp5rui.swift:15:17: error: cannot find 'CharacterSet' in scope\n\
    \  let letters = CharacterSet.letters\n                ^~~~~~~~~~~~\n"
  stdout: ''
  timestamp: 1659978813
- exit_code: 1
  program: "\n/// You are given a string s.\n/// if s[i] is a letter, reverse its\
    \ case from lower to upper or vise versa, \n/// otherwise keep it as it is.\n\
    /// If the string contains no letters, reverse the string.\n/// The function should\
    \ return the resulted string.\n/// Examples\n/// >>> solve(s: \"1234\")\n/// \"\
    4321\"\n/// >>> solve(s: \"ab\")\n/// \"AB\"\n/// >>> solve(s: \"#a@C\")\n///\
    \ \"#A@c\"\nfunc solve(s: String) -> String {\n    let letters = \"abcdefghijklmnopqrstuvwxyz\"\
    \n    let result = s.reversed().compactMap { char -> Character? in\n        if\
    \ letters.contains(char) {\n            return letters.contains(char.lowercased())\
    \ ? char.uppercased() : char.lowercased()\n        }\n        return char\n  \
    \  }\n    return String(result)\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int,\
    \ Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n\
    \    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n          \
    \  return false\n        }\n    }\n    return true\n}\n            \nassert(solve(s:\
    \ \"AsDf\") == \"aSdF\")\nassert(solve(s: \"1234\") == \"4321\")\nassert(solve(s:\
    \ \"ab\") == \"AB\")\nassert(solve(s: \"#a@C\") == \"#A@c\")\nassert(solve(s:\
    \ \"#AsdfW^45\") == \"#aSDFw^45\")\nassert(solve(s: \"#6@2\") == \"2@6#\")\nassert(solve(s:\
    \ \"#$a^D\") == \"#$A^d\")\nassert(solve(s: \"#ccc\") == \"#CCC\")"
  status: SyntaxError
  stderr: "/tmp/tmppmuq953k.swift:18:56: error: cannot convert return expression of\
    \ type 'String' to return type 'Character?'\n            return letters.contains(char.lowercased())\
    \ ? char.uppercased() : char.lowercased()\n                   ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n"
  stdout: ''
  timestamp: 1659978813
