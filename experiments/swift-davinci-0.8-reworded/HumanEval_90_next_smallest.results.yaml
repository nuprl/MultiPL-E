language: swift
name: HumanEval_90_next_smallest
results:
- exit_code: 0
  program: "\n/// You are given an array of integers.\n/// Write a function next_smallest()\
    \ that returns the 2nd smallest element of the array.\n/// Return nil if there\
    \ is no such element.\n/// >>> next_smallest(lst: [1, 2, 3, 4, 5])\n/// 2\n///\
    \ >>> next_smallest(lst: [5, 1, 4, 3, 2])\n/// 2\n/// >>> next_smallest(lst: []\
    \ as [Int])\n/// nil\n/// >>> next_smallest(lst: [1, 1])\n/// nil\nfunc next_smallest(lst:\
    \ [Int]) -> Int? {\n    guard lst.count > 1 else { return nil }\n    var lst2\
    \ = lst\n    lst2.sort()\n    var previous: Int?\n    for i in lst2 {\n      \
    \  if previous == nil {\n            previous = i\n        } else if previous\
    \ != i {\n            return i\n        }\n    }\n    return nil\n}\n\n\nfunc\
    \ ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count !=\
    \ right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(next_smallest(lst: [1, 2, 3, 4, 5]) == 2)\nassert(next_smallest(lst:\
    \ [5, 1, 4, 3, 2]) == 2)\nassert(next_smallest(lst: [] as [Int]) == nil)\nassert(next_smallest(lst:\
    \ [1, 1]) == nil)\nassert(next_smallest(lst: [1, 1, 1, 1, 0]) == 1)\nassert(next_smallest(lst:\
    \ [1, 1]) == nil)\nassert(next_smallest(lst: [-35, 34, 12, -45]) == -35)"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660013380
- exit_code: 0
  program: "\n/// You are given an array of integers.\n/// Write a function next_smallest()\
    \ that returns the 2nd smallest element of the array.\n/// Return nil if there\
    \ is no such element.\n/// >>> next_smallest(lst: [1, 2, 3, 4, 5])\n/// 2\n///\
    \ >>> next_smallest(lst: [5, 1, 4, 3, 2])\n/// 2\n/// >>> next_smallest(lst: []\
    \ as [Int])\n/// nil\n/// >>> next_smallest(lst: [1, 1])\n/// nil\nfunc next_smallest(lst:\
    \ [Int]) -> Int? {\n    var lst = lst\n    if lst.count == 0 {\n        return\
    \ nil\n    }\n    lst.sort()\n    if lst.count == 1 {\n        return nil\n  \
    \  }\n    for i in 0..<lst.count - 1 {\n        if lst[i] != lst[i + 1] {\n  \
    \          return lst[i + 1]\n        }\n    }\n    return nil\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(next_smallest(lst: [1, 2, 3, 4, 5]) == 2)\nassert(next_smallest(lst:\
    \ [5, 1, 4, 3, 2]) == 2)\nassert(next_smallest(lst: [] as [Int]) == nil)\nassert(next_smallest(lst:\
    \ [1, 1]) == nil)\nassert(next_smallest(lst: [1, 1, 1, 1, 0]) == 1)\nassert(next_smallest(lst:\
    \ [1, 1]) == nil)\nassert(next_smallest(lst: [-35, 34, 12, -45]) == -35)"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660013380
- exit_code: -4
  program: "\n/// You are given an array of integers.\n/// Write a function next_smallest()\
    \ that returns the 2nd smallest element of the array.\n/// Return nil if there\
    \ is no such element.\n/// >>> next_smallest(lst: [1, 2, 3, 4, 5])\n/// 2\n///\
    \ >>> next_smallest(lst: [5, 1, 4, 3, 2])\n/// 2\n/// >>> next_smallest(lst: []\
    \ as [Int])\n/// nil\n/// >>> next_smallest(lst: [1, 1])\n/// nil\nfunc next_smallest(lst:\
    \ [Int]) -> Int? {\n    let lst = lst.sorted()\n    var current = lst[0]\n   \
    \ var previous = lst[0]\n    for i in lst[1...] {\n        if i == previous {\n\
    \            continue\n        }\n        if i > previous {\n            return\
    \ i\n        }\n        current = i\n        previous = i\n    }\n    return nil\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(next_smallest(lst: [1, 2, 3, 4, 5]) == 2)\nassert(next_smallest(lst:\
    \ [5, 1, 4, 3, 2]) == 2)\nassert(next_smallest(lst: [] as [Int]) == nil)\nassert(next_smallest(lst:\
    \ [1, 1]) == nil)\nassert(next_smallest(lst: [1, 1, 1, 1, 0]) == 1)\nassert(next_smallest(lst:\
    \ [1, 1]) == nil)\nassert(next_smallest(lst: [-35, 34, 12, -45]) == -35)"
  status: Exception
  stderr: 'Swift/ContiguousArrayBuffer.swift:600: Fatal error: Index out of range

    Current stack trace:

    0    libswiftCore.so                    0x00002ada85c08c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002ada858ff561 <unavailable> + 1434977

    2    libswiftCore.so                    0x00002ada858ff286 <unavailable> + 1434246

    3    libswiftCore.so                    0x00002ada858ff13c <unavailable> + 1433916

    4    libswiftCore.so                    0x00002ada858febb0 _assertionFailure(_:_:file:line:flags:)
    + 251

    5    libswiftSwiftOnoneSupport.so       0x00002ada856fee83 <unavailable> + 188035

    6    tmp5x_c6j4v                        0x000055ce68e8a0bf <unavailable> + 8383

    7    tmp5x_c6j4v                        0x000055ce68e899b8 <unavailable> + 6584

    8    libc.so.6                          0x00002ada85df4460 __libc_start_main +
    245

    9    tmp5x_c6j4v                        0x000055ce68e89379 <unavailable> + 4985

    '
  stdout: ''
  timestamp: 1660013380
- exit_code: 0
  program: "\n/// You are given an array of integers.\n/// Write a function next_smallest()\
    \ that returns the 2nd smallest element of the array.\n/// Return nil if there\
    \ is no such element.\n/// >>> next_smallest(lst: [1, 2, 3, 4, 5])\n/// 2\n///\
    \ >>> next_smallest(lst: [5, 1, 4, 3, 2])\n/// 2\n/// >>> next_smallest(lst: []\
    \ as [Int])\n/// nil\n/// >>> next_smallest(lst: [1, 1])\n/// nil\nfunc next_smallest(lst:\
    \ [Int]) -> Int? {\n    guard lst.count > 2 else { return nil }\n    var sm1 =\
    \ Int.max\n    var sm2 = Int.max\n    for i in lst {\n        if i < sm1 {\n \
    \           sm2 = sm1\n            sm1 = i\n        } else if i < sm2 {\n    \
    \        sm2 = i\n        }\n    }\n    return sm2 == Int.max ? nil : sm2\n}\n\
    \n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(next_smallest(lst: [1, 2, 3, 4, 5]) == 2)\nassert(next_smallest(lst:\
    \ [5, 1, 4, 3, 2]) == 2)\nassert(next_smallest(lst: [] as [Int]) == nil)\nassert(next_smallest(lst:\
    \ [1, 1]) == nil)\nassert(next_smallest(lst: [1, 1, 1, 1, 0]) == 1)\nassert(next_smallest(lst:\
    \ [1, 1]) == nil)\nassert(next_smallest(lst: [-35, 34, 12, -45]) == -35)"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660013380
- exit_code: 0
  program: "\n/// You are given an array of integers.\n/// Write a function next_smallest()\
    \ that returns the 2nd smallest element of the array.\n/// Return nil if there\
    \ is no such element.\n/// >>> next_smallest(lst: [1, 2, 3, 4, 5])\n/// 2\n///\
    \ >>> next_smallest(lst: [5, 1, 4, 3, 2])\n/// 2\n/// >>> next_smallest(lst: []\
    \ as [Int])\n/// nil\n/// >>> next_smallest(lst: [1, 1])\n/// nil\nfunc next_smallest(lst:\
    \ [Int]) -> Int? {\n    guard lst.count > 1 else { return nil }\n    var lst =\
    \ lst\n    lst.sort()\n    for (i, element) in lst.enumerated() {\n        if\
    \ i + 1 < lst.count && element != lst[i + 1] {\n            return lst[i + 1]\n\
    \        }\n    }\n    return nil\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int,\
    \ Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n\
    \    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n          \
    \  return false\n        }\n    }\n    return true\n}\n            \nassert(next_smallest(lst:\
    \ [1, 2, 3, 4, 5]) == 2)\nassert(next_smallest(lst: [5, 1, 4, 3, 2]) == 2)\nassert(next_smallest(lst:\
    \ [] as [Int]) == nil)\nassert(next_smallest(lst: [1, 1]) == nil)\nassert(next_smallest(lst:\
    \ [1, 1, 1, 1, 0]) == 1)\nassert(next_smallest(lst: [1, 1]) == nil)\nassert(next_smallest(lst:\
    \ [-35, 34, 12, -45]) == -35)"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660013380
- exit_code: 0
  program: "\n/// You are given an array of integers.\n/// Write a function next_smallest()\
    \ that returns the 2nd smallest element of the array.\n/// Return nil if there\
    \ is no such element.\n/// >>> next_smallest(lst: [1, 2, 3, 4, 5])\n/// 2\n///\
    \ >>> next_smallest(lst: [5, 1, 4, 3, 2])\n/// 2\n/// >>> next_smallest(lst: []\
    \ as [Int])\n/// nil\n/// >>> next_smallest(lst: [1, 1])\n/// nil\nfunc next_smallest(lst:\
    \ [Int]) -> Int? {\n    \n    guard lst.count > 1 else { return nil }\n    \n\
    \    var sorted = lst.sorted()\n    var nextSmallest = Int.max\n    \n    while\
    \ sorted.count > 0 {\n        let first = sorted.removeFirst()\n        let second\
    \ = sorted.first\n        \n        if let second = second {\n            if second\
    \ > first {\n                nextSmallest = min(nextSmallest, second)\n      \
    \      }\n        }\n    }\n    \n    if nextSmallest != Int.max {\n        return\
    \ nextSmallest\n    }\n    \n    return nil\n}\n\n\nfunc ==(left: [(Int, Int)],\
    \ right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n       \
    \ return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r\
    \ {\n            return false\n        }\n    }\n    return true\n}\n        \
    \    \nassert(next_smallest(lst: [1, 2, 3, 4, 5]) == 2)\nassert(next_smallest(lst:\
    \ [5, 1, 4, 3, 2]) == 2)\nassert(next_smallest(lst: [] as [Int]) == nil)\nassert(next_smallest(lst:\
    \ [1, 1]) == nil)\nassert(next_smallest(lst: [1, 1, 1, 1, 0]) == 1)\nassert(next_smallest(lst:\
    \ [1, 1]) == nil)\nassert(next_smallest(lst: [-35, 34, 12, -45]) == -35)"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660013380
- exit_code: 0
  program: "\n/// You are given an array of integers.\n/// Write a function next_smallest()\
    \ that returns the 2nd smallest element of the array.\n/// Return nil if there\
    \ is no such element.\n/// >>> next_smallest(lst: [1, 2, 3, 4, 5])\n/// 2\n///\
    \ >>> next_smallest(lst: [5, 1, 4, 3, 2])\n/// 2\n/// >>> next_smallest(lst: []\
    \ as [Int])\n/// nil\n/// >>> next_smallest(lst: [1, 1])\n/// nil\nfunc next_smallest(lst:\
    \ [Int]) -> Int? {\n    guard !lst.isEmpty else { return nil }\n    let sortedList\
    \ = lst.sorted()\n    guard sortedList.first! != sortedList.last! else { return\
    \ nil }\n    return sortedList[1]\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int,\
    \ Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n\
    \    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n          \
    \  return false\n        }\n    }\n    return true\n}\n            \nassert(next_smallest(lst:\
    \ [1, 2, 3, 4, 5]) == 2)\nassert(next_smallest(lst: [5, 1, 4, 3, 2]) == 2)\nassert(next_smallest(lst:\
    \ [] as [Int]) == nil)\nassert(next_smallest(lst: [1, 1]) == nil)\nassert(next_smallest(lst:\
    \ [1, 1, 1, 1, 0]) == 1)\nassert(next_smallest(lst: [1, 1]) == nil)\nassert(next_smallest(lst:\
    \ [-35, 34, 12, -45]) == -35)"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660013380
- exit_code: 0
  program: "\n/// You are given an array of integers.\n/// Write a function next_smallest()\
    \ that returns the 2nd smallest element of the array.\n/// Return nil if there\
    \ is no such element.\n/// >>> next_smallest(lst: [1, 2, 3, 4, 5])\n/// 2\n///\
    \ >>> next_smallest(lst: [5, 1, 4, 3, 2])\n/// 2\n/// >>> next_smallest(lst: []\
    \ as [Int])\n/// nil\n/// >>> next_smallest(lst: [1, 1])\n/// nil\nfunc next_smallest(lst:\
    \ [Int]) -> Int? {\n    if lst.count == 0 {\n        return nil\n    }\n    if\
    \ lst.count == 1 {\n        return nil\n    }\n    if lst.count == 2 {\n     \
    \   if lst[0] == lst[1] {\n            return nil\n        }\n    }\n    var res\
    \ = lst.sorted()\n    for i in 1..<res.count {\n        if res[i] > res[0] {\n\
    \            return res[i]\n        }\n    }\n    return nil\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(next_smallest(lst: [1, 2, 3, 4, 5]) == 2)\nassert(next_smallest(lst:\
    \ [5, 1, 4, 3, 2]) == 2)\nassert(next_smallest(lst: [] as [Int]) == nil)\nassert(next_smallest(lst:\
    \ [1, 1]) == nil)\nassert(next_smallest(lst: [1, 1, 1, 1, 0]) == 1)\nassert(next_smallest(lst:\
    \ [1, 1]) == nil)\nassert(next_smallest(lst: [-35, 34, 12, -45]) == -35)"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660013380
- exit_code: 0
  program: "\n/// You are given an array of integers.\n/// Write a function next_smallest()\
    \ that returns the 2nd smallest element of the array.\n/// Return nil if there\
    \ is no such element.\n/// >>> next_smallest(lst: [1, 2, 3, 4, 5])\n/// 2\n///\
    \ >>> next_smallest(lst: [5, 1, 4, 3, 2])\n/// 2\n/// >>> next_smallest(lst: []\
    \ as [Int])\n/// nil\n/// >>> next_smallest(lst: [1, 1])\n/// nil\nfunc next_smallest(lst:\
    \ [Int]) -> Int? {\n    \n    let num = lst.count\n    var smallest = Int.max\n\
    \    var secondSmallest = Int.max\n    \n    if num <= 1 {\n        return nil\n\
    \    }\n    \n    for i in 0..<num {\n        if lst[i] < smallest {\n       \
    \     secondSmallest = smallest\n            smallest = lst[i]\n        } else\
    \ if lst[i] < secondSmallest && lst[i] != smallest {\n            secondSmallest\
    \ = lst[i]\n        }\n    }\n    \n    if secondSmallest == Int.max {\n     \
    \   return nil\n    }\n    \n    return secondSmallest\n}\n\n\nfunc ==(left: [(Int,\
    \ Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n\
    \        return false\n    }\n    for (l, r) in zip(left, right) {\n        if\
    \ l != r {\n            return false\n        }\n    }\n    return true\n}\n \
    \           \nassert(next_smallest(lst: [1, 2, 3, 4, 5]) == 2)\nassert(next_smallest(lst:\
    \ [5, 1, 4, 3, 2]) == 2)\nassert(next_smallest(lst: [] as [Int]) == nil)\nassert(next_smallest(lst:\
    \ [1, 1]) == nil)\nassert(next_smallest(lst: [1, 1, 1, 1, 0]) == 1)\nassert(next_smallest(lst:\
    \ [1, 1]) == nil)\nassert(next_smallest(lst: [-35, 34, 12, -45]) == -35)"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660013380
- exit_code: -4
  program: "\n/// You are given an array of integers.\n/// Write a function next_smallest()\
    \ that returns the 2nd smallest element of the array.\n/// Return nil if there\
    \ is no such element.\n/// >>> next_smallest(lst: [1, 2, 3, 4, 5])\n/// 2\n///\
    \ >>> next_smallest(lst: [5, 1, 4, 3, 2])\n/// 2\n/// >>> next_smallest(lst: []\
    \ as [Int])\n/// nil\n/// >>> next_smallest(lst: [1, 1])\n/// nil\nfunc next_smallest(lst:\
    \ [Int]) -> Int? {\n    if lst.count == 0 {\n        return nil\n    }\n    if\
    \ lst.count == 1 {\n        return nil\n    }\n    var minimum = lst[0]\n    var\
    \ second_smallest = lst[1]\n    for i in 0..<lst.count {\n        if lst[i] <\
    \ minimum {\n            second_smallest = minimum\n            minimum = lst[i]\n\
    \        } else if lst[i] < second_smallest {\n            second_smallest = lst[i]\n\
    \        }\n    }\n    return second_smallest\n}\n\n\nfunc ==(left: [(Int, Int)],\
    \ right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n       \
    \ return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r\
    \ {\n            return false\n        }\n    }\n    return true\n}\n        \
    \    \nassert(next_smallest(lst: [1, 2, 3, 4, 5]) == 2)\nassert(next_smallest(lst:\
    \ [5, 1, 4, 3, 2]) == 2)\nassert(next_smallest(lst: [] as [Int]) == nil)\nassert(next_smallest(lst:\
    \ [1, 1]) == nil)\nassert(next_smallest(lst: [1, 1, 1, 1, 0]) == 1)\nassert(next_smallest(lst:\
    \ [1, 1]) == nil)\nassert(next_smallest(lst: [-35, 34, 12, -45]) == -35)"
  status: Exception
  stderr: 'tmprvlfo191/tmprvlfo191.swift:46: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002ba9b1bfec80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002ba9b18f5b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002ba9b18f5988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002ba9b18f47b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmprvlfo191                        0x00005654c7a6e621 <unavailable> + 5665

    5    libc.so.6                          0x00002ba9b1dea460 __libc_start_main +
    245

    6    tmprvlfo191                        0x00005654c7a6e1a9 <unavailable> + 4521

    '
  stdout: ''
  timestamp: 1660013380
- exit_code: -4
  program: "\n/// You are given an array of integers.\n/// Write a function next_smallest()\
    \ that returns the 2nd smallest element of the array.\n/// Return nil if there\
    \ is no such element.\n/// >>> next_smallest(lst: [1, 2, 3, 4, 5])\n/// 2\n///\
    \ >>> next_smallest(lst: [5, 1, 4, 3, 2])\n/// 2\n/// >>> next_smallest(lst: []\
    \ as [Int])\n/// nil\n/// >>> next_smallest(lst: [1, 1])\n/// nil\nfunc next_smallest(lst:\
    \ [Int]) -> Int? {\n    if (lst.count == 0) {\n        return nil\n    }\n   \
    \ var current = lst[0]\n    var smallest = lst[0]\n    var secondSmallest = lst[0]\n\
    \    var done = false\n    for item in lst {\n        if (item > smallest) {\n\
    \            secondSmallest = smallest\n            smallest = item\n        \
    \    done = true\n        } else if (item < smallest && item > secondSmallest)\
    \ {\n            secondSmallest = item\n            done = true\n        }\n \
    \   }\n    if (done) {\n        return secondSmallest\n    }\n    return nil\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(next_smallest(lst: [1, 2, 3, 4, 5]) == 2)\nassert(next_smallest(lst:\
    \ [5, 1, 4, 3, 2]) == 2)\nassert(next_smallest(lst: [] as [Int]) == nil)\nassert(next_smallest(lst:\
    \ [1, 1]) == nil)\nassert(next_smallest(lst: [1, 1, 1, 1, 0]) == 1)\nassert(next_smallest(lst:\
    \ [1, 1]) == nil)\nassert(next_smallest(lst: [-35, 34, 12, -45]) == -35)"
  status: Exception
  stderr: 'tmpah7adbte/tmpah7adbte.swift:50: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b0d7571ac80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b0d75411b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b0d75411988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b0d754107b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpah7adbte                        0x000055f1ecd31601 <unavailable> + 5633

    5    libc.so.6                          0x00002b0d75906460 __libc_start_main +
    245

    6    tmpah7adbte                        0x000055f1ecd31189 <unavailable> + 4489

    '
  stdout: ''
  timestamp: 1660013380
- exit_code: 0
  program: "\n/// You are given an array of integers.\n/// Write a function next_smallest()\
    \ that returns the 2nd smallest element of the array.\n/// Return nil if there\
    \ is no such element.\n/// >>> next_smallest(lst: [1, 2, 3, 4, 5])\n/// 2\n///\
    \ >>> next_smallest(lst: [5, 1, 4, 3, 2])\n/// 2\n/// >>> next_smallest(lst: []\
    \ as [Int])\n/// nil\n/// >>> next_smallest(lst: [1, 1])\n/// nil\nfunc next_smallest(lst:\
    \ [Int]) -> Int? {\n    var sortedLst = lst.sorted()\n    var last: Int?\n   \
    \ for item in sortedLst {\n        if let last = last {\n            if item >\
    \ last {\n                return item\n            }\n        }\n        last\
    \ = item\n    }\n    return nil\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int,\
    \ Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n\
    \    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n          \
    \  return false\n        }\n    }\n    return true\n}\n            \nassert(next_smallest(lst:\
    \ [1, 2, 3, 4, 5]) == 2)\nassert(next_smallest(lst: [5, 1, 4, 3, 2]) == 2)\nassert(next_smallest(lst:\
    \ [] as [Int]) == nil)\nassert(next_smallest(lst: [1, 1]) == nil)\nassert(next_smallest(lst:\
    \ [1, 1, 1, 1, 0]) == 1)\nassert(next_smallest(lst: [1, 1]) == nil)\nassert(next_smallest(lst:\
    \ [-35, 34, 12, -45]) == -35)"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660013380
- exit_code: -4
  program: "\n/// You are given an array of integers.\n/// Write a function next_smallest()\
    \ that returns the 2nd smallest element of the array.\n/// Return nil if there\
    \ is no such element.\n/// >>> next_smallest(lst: [1, 2, 3, 4, 5])\n/// 2\n///\
    \ >>> next_smallest(lst: [5, 1, 4, 3, 2])\n/// 2\n/// >>> next_smallest(lst: []\
    \ as [Int])\n/// nil\n/// >>> next_smallest(lst: [1, 1])\n/// nil\nfunc next_smallest(lst:\
    \ [Int]) -> Int? {\n    let sortedLst = lst.sorted()\n    var tmp1 = 0\n    var\
    \ tmp2 = 0\n    for i in sortedLst {\n        if tmp1 == 0 {\n            tmp1\
    \ = i\n        } else if tmp1 != i {\n            tmp2 = i\n            break\n\
    \        }\n    }\n    if tmp1 == tmp2 {\n        return nil\n    }\n    return\
    \ tmp2\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n  \
    \  if left.count != right.count {\n        return false\n    }\n    for (l, r)\
    \ in zip(left, right) {\n        if l != r {\n            return false\n     \
    \   }\n    }\n    return true\n}\n            \nassert(next_smallest(lst: [1,\
    \ 2, 3, 4, 5]) == 2)\nassert(next_smallest(lst: [5, 1, 4, 3, 2]) == 2)\nassert(next_smallest(lst:\
    \ [] as [Int]) == nil)\nassert(next_smallest(lst: [1, 1]) == nil)\nassert(next_smallest(lst:\
    \ [1, 1, 1, 1, 0]) == 1)\nassert(next_smallest(lst: [1, 1]) == nil)\nassert(next_smallest(lst:\
    \ [-35, 34, 12, -45]) == -35)"
  status: Exception
  stderr: 'tmptsps735q/tmptsps735q.swift:47: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002ae7c8ed3c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002ae7c8bcab6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002ae7c8bca988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002ae7c8bc97b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmptsps735q                        0x0000558738e8f97a <unavailable> + 6522

    5    libc.so.6                          0x00002ae7c90bf460 __libc_start_main +
    245

    6    tmptsps735q                        0x0000558738e8f179 <unavailable> + 4473

    '
  stdout: ''
  timestamp: 1660013380
- exit_code: 0
  program: "\n/// You are given an array of integers.\n/// Write a function next_smallest()\
    \ that returns the 2nd smallest element of the array.\n/// Return nil if there\
    \ is no such element.\n/// >>> next_smallest(lst: [1, 2, 3, 4, 5])\n/// 2\n///\
    \ >>> next_smallest(lst: [5, 1, 4, 3, 2])\n/// 2\n/// >>> next_smallest(lst: []\
    \ as [Int])\n/// nil\n/// >>> next_smallest(lst: [1, 1])\n/// nil\nfunc next_smallest(lst:\
    \ [Int]) -> Int? {\n    \n    var sorted = lst.sorted()\n    var i = 0\n    for\
    \ value in sorted {\n        i += 1\n        if i == 1 {\n            if value\
    \ == sorted[i] {\n                return nil\n            }\n        }\n     \
    \   if i == 2 {\n            return value\n        }\n    }\n    return nil\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(next_smallest(lst: [1, 2, 3, 4, 5]) == 2)\nassert(next_smallest(lst:\
    \ [5, 1, 4, 3, 2]) == 2)\nassert(next_smallest(lst: [] as [Int]) == nil)\nassert(next_smallest(lst:\
    \ [1, 1]) == nil)\nassert(next_smallest(lst: [1, 1, 1, 1, 0]) == 1)\nassert(next_smallest(lst:\
    \ [1, 1]) == nil)\nassert(next_smallest(lst: [-35, 34, 12, -45]) == -35)"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660013380
- exit_code: 1
  program: "\n/// You are given an array of integers.\n/// Write a function next_smallest()\
    \ that returns the 2nd smallest element of the array.\n/// Return nil if there\
    \ is no such element.\n/// >>> next_smallest(lst: [1, 2, 3, 4, 5])\n/// 2\n///\
    \ >>> next_smallest(lst: [5, 1, 4, 3, 2])\n/// 2\n/// >>> next_smallest(lst: []\
    \ as [Int])\n/// nil\n/// >>> next_smallest(lst: [1, 1])\n/// nil\nfunc next_smallest(lst:\
    \ [Int]) -> Int? {\n    guard lst.count > 1 else { return nil }\n    var lst =\
    \ lst\n    let smallest = lst.remove(at: lst.minIndex()!)\n    let next_smallest\
    \ = lst.min()\n    if next_smallest == smallest {\n        return nil\n    }\n\
    \    return next_smallest\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(next_smallest(lst:\
    \ [1, 2, 3, 4, 5]) == 2)\nassert(next_smallest(lst: [5, 1, 4, 3, 2]) == 2)\nassert(next_smallest(lst:\
    \ [] as [Int]) == nil)\nassert(next_smallest(lst: [1, 1]) == nil)\nassert(next_smallest(lst:\
    \ [1, 1, 1, 1, 0]) == 1)\nassert(next_smallest(lst: [1, 1]) == nil)\nassert(next_smallest(lst:\
    \ [-35, 34, 12, -45]) == -35)"
  status: SyntaxError
  stderr: "/tmp/tmpayyya518.swift:16:39: error: value of type '[Int]' has no member\
    \ 'minIndex'\n    let smallest = lst.remove(at: lst.minIndex()!)\n           \
    \                       ~~~ ^~~~~~~~\n"
  stdout: ''
  timestamp: 1660013379
- exit_code: 0
  program: "\n/// You are given an array of integers.\n/// Write a function next_smallest()\
    \ that returns the 2nd smallest element of the array.\n/// Return nil if there\
    \ is no such element.\n/// >>> next_smallest(lst: [1, 2, 3, 4, 5])\n/// 2\n///\
    \ >>> next_smallest(lst: [5, 1, 4, 3, 2])\n/// 2\n/// >>> next_smallest(lst: []\
    \ as [Int])\n/// nil\n/// >>> next_smallest(lst: [1, 1])\n/// nil\nfunc next_smallest(lst:\
    \ [Int]) -> Int? {\n    var min = Int.max\n    var nmin = Int.max\n    for i in\
    \ lst {\n        if i < min {\n            nmin = min\n            min = i\n \
    \       } else if i < nmin {\n            nmin = i\n        }\n    }\n    return\
    \ min == nmin ? nil : nmin\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(next_smallest(lst:\
    \ [1, 2, 3, 4, 5]) == 2)\nassert(next_smallest(lst: [5, 1, 4, 3, 2]) == 2)\nassert(next_smallest(lst:\
    \ [] as [Int]) == nil)\nassert(next_smallest(lst: [1, 1]) == nil)\nassert(next_smallest(lst:\
    \ [1, 1, 1, 1, 0]) == 1)\nassert(next_smallest(lst: [1, 1]) == nil)\nassert(next_smallest(lst:\
    \ [-35, 34, 12, -45]) == -35)"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660013380
- exit_code: 1
  program: "\n/// You are given an array of integers.\n/// Write a function next_smallest()\
    \ that returns the 2nd smallest element of the array.\n/// Return nil if there\
    \ is no such element.\n/// >>> next_smallest(lst: [1, 2, 3, 4, 5])\n/// 2\n///\
    \ >>> next_smallest(lst: [5, 1, 4, 3, 2])\n/// 2\n/// >>> next_smallest(lst: []\
    \ as [Int])\n/// nil\n/// >>> next_smallest(lst: [1, 1])\n/// nil\nfunc next_smallest(lst:\
    \ [Int]) -> Int? {\n    return lst.sorted()[safe: 1]\n}\n\n\nfunc ==(left: [(Int,\
    \ Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n\
    \        return false\n    }\n    for (l, r) in zip(left, right) {\n        if\
    \ l != r {\n            return false\n        }\n    }\n    return true\n}\n \
    \           \nassert(next_smallest(lst: [1, 2, 3, 4, 5]) == 2)\nassert(next_smallest(lst:\
    \ [5, 1, 4, 3, 2]) == 2)\nassert(next_smallest(lst: [] as [Int]) == nil)\nassert(next_smallest(lst:\
    \ [1, 1]) == nil)\nassert(next_smallest(lst: [1, 1, 1, 1, 0]) == 1)\nassert(next_smallest(lst:\
    \ [1, 1]) == nil)\nassert(next_smallest(lst: [-35, 34, 12, -45]) == -35)"
  status: SyntaxError
  stderr: "/tmp/tmp4gcy14ib.swift:14:24: error: extraneous argument label 'safe:'\
    \ in subscript\n    return lst.sorted()[safe: 1]\n                       ^~~~~~~\n\
    \                        \n"
  stdout: ''
  timestamp: 1660013379
- exit_code: -4
  program: "\n/// You are given an array of integers.\n/// Write a function next_smallest()\
    \ that returns the 2nd smallest element of the array.\n/// Return nil if there\
    \ is no such element.\n/// >>> next_smallest(lst: [1, 2, 3, 4, 5])\n/// 2\n///\
    \ >>> next_smallest(lst: [5, 1, 4, 3, 2])\n/// 2\n/// >>> next_smallest(lst: []\
    \ as [Int])\n/// nil\n/// >>> next_smallest(lst: [1, 1])\n/// nil\nfunc next_smallest(lst:\
    \ [Int]) -> Int? {\n    return nil\n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(next_smallest(lst: [1, 2, 3, 4, 5]) == 2)\nassert(next_smallest(lst: [5,\
    \ 1, 4, 3, 2]) == 2)\nassert(next_smallest(lst: [] as [Int]) == nil)\nassert(next_smallest(lst:\
    \ [1, 1]) == nil)\nassert(next_smallest(lst: [1, 1, 1, 1, 0]) == 1)\nassert(next_smallest(lst:\
    \ [1, 1]) == nil)\nassert(next_smallest(lst: [-35, 34, 12, -45]) == -35)"
  status: Exception
  stderr: 'tmp2hp7hj7n/tmp2hp7hj7n.swift:30: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002afccf398c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002afccf08fb6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002afccf08f988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002afccf08e7b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmp2hp7hj7n                        0x0000560c9b7333e1 <unavailable> + 5089

    5    libc.so.6                          0x00002afccf584460 __libc_start_main +
    245

    6    tmp2hp7hj7n                        0x0000560c9b732f69 <unavailable> + 3945

    '
  stdout: ''
  timestamp: 1660013380
- exit_code: -4
  program: "\n/// You are given an array of integers.\n/// Write a function next_smallest()\
    \ that returns the 2nd smallest element of the array.\n/// Return nil if there\
    \ is no such element.\n/// >>> next_smallest(lst: [1, 2, 3, 4, 5])\n/// 2\n///\
    \ >>> next_smallest(lst: [5, 1, 4, 3, 2])\n/// 2\n/// >>> next_smallest(lst: []\
    \ as [Int])\n/// nil\n/// >>> next_smallest(lst: [1, 1])\n/// nil\nfunc next_smallest(lst:\
    \ [Int]) -> Int? {\n    return nil\n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(next_smallest(lst: [1, 2, 3, 4, 5]) == 2)\nassert(next_smallest(lst: [5,\
    \ 1, 4, 3, 2]) == 2)\nassert(next_smallest(lst: [] as [Int]) == nil)\nassert(next_smallest(lst:\
    \ [1, 1]) == nil)\nassert(next_smallest(lst: [1, 1, 1, 1, 0]) == 1)\nassert(next_smallest(lst:\
    \ [1, 1]) == nil)\nassert(next_smallest(lst: [-35, 34, 12, -45]) == -35)"
  status: Exception
  stderr: 'tmp2hp7hj7n/tmp2hp7hj7n.swift:30: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002afccf398c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002afccf08fb6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002afccf08f988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002afccf08e7b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmp2hp7hj7n                        0x0000560c9b7333e1 <unavailable> + 5089

    5    libc.so.6                          0x00002afccf584460 __libc_start_main +
    245

    6    tmp2hp7hj7n                        0x0000560c9b732f69 <unavailable> + 3945

    '
  stdout: ''
  timestamp: 1660013380
- exit_code: 1
  program: "\n/// You are given an array of integers.\n/// Write a function next_smallest()\
    \ that returns the 2nd smallest element of the array.\n/// Return nil if there\
    \ is no such element.\n/// >>> next_smallest(lst: [1, 2, 3, 4, 5])\n/// 2\n///\
    \ >>> next_smallest(lst: [5, 1, 4, 3, 2])\n/// 2\n/// >>> next_smallest(lst: []\
    \ as [Int])\n/// nil\n/// >>> next_smallest(lst: [1, 1])\n/// nil\nfunc next_smallest(lst:\
    \ [Int]) -> Int? {\n    guard lst.count > 1 else { return nil }\n    guard let\
    \ min = lst.min() else { return nil }\n    let minIndex = lst.firstIndex(of: min)!\n\
    \    let rLst = Array(lst[minIndex + 1...])\n    return rLst.min()\n}\n\n\nfunc\
    \ ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count !=\
    \ right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(next_smallest(lst: [1, 2, 3, 4, 5]) == 2)\nassert(next_smallest(lst:\
    \ [5, 1, 4, 3, 2]) == 2)\nassert(next_smallest(lst: [] as [Int]) == nil)\nassert(next_smallest(lst:\
    \ [1, 1]) == nil)\nassert(next_smallest(lst: [1, 1, 1, 1, 0]) == 1)\nassert(next_smallest(lst:\
    \ [1, 1]) == nil)\nassert(next_smallest(lst: [-35, 34, 12, -45]) == -35)"
  status: SyntaxError
  stderr: "/tmp/tmpmsh2igd4.swift:17:22: error: missing argument label 'arrayLiteral:'\
    \ in call\n    let rLst = Array(lst[minIndex + 1...])\n                     ^\n\
    \                     arrayLiteral: \n/tmp/tmpmsh2igd4.swift:17:38: error: cannot\
    \ convert value of type 'PartialRangeFrom<Int>' to expected argument type 'Int'\n\
    \    let rLst = Array(lst[minIndex + 1...])\n                                \
    \     ^\n"
  stdout: ''
  timestamp: 1660013380
- exit_code: -4
  program: "\n/// You are given an array of integers.\n/// Write a function next_smallest()\
    \ that returns the 2nd smallest element of the array.\n/// Return nil if there\
    \ is no such element.\n/// >>> next_smallest(lst: [1, 2, 3, 4, 5])\n/// 2\n///\
    \ >>> next_smallest(lst: [5, 1, 4, 3, 2])\n/// 2\n/// >>> next_smallest(lst: []\
    \ as [Int])\n/// nil\n/// >>> next_smallest(lst: [1, 1])\n/// nil\nfunc next_smallest(lst:\
    \ [Int]) -> Int? {\n    var min = lst[0]\n    var secondMin = Int.max\n    for\
    \ x in lst[1..<lst.count] {\n        if x < min {\n            secondMin = min\n\
    \            min = x\n        } else if x < secondMin {\n            secondMin\
    \ = x\n        }\n    }\n    return secondMin == Int.max ? nil : secondMin\n}\n\
    \n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(next_smallest(lst: [1, 2, 3, 4, 5]) == 2)\nassert(next_smallest(lst:\
    \ [5, 1, 4, 3, 2]) == 2)\nassert(next_smallest(lst: [] as [Int]) == nil)\nassert(next_smallest(lst:\
    \ [1, 1]) == nil)\nassert(next_smallest(lst: [1, 1, 1, 1, 0]) == 1)\nassert(next_smallest(lst:\
    \ [1, 1]) == nil)\nassert(next_smallest(lst: [-35, 34, 12, -45]) == -35)"
  status: Exception
  stderr: 'Swift/ContiguousArrayBuffer.swift:600: Fatal error: Index out of range

    Current stack trace:

    0    libswiftCore.so                    0x00002b27e8bc3c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b27e88ba561 <unavailable> + 1434977

    2    libswiftCore.so                    0x00002b27e88ba286 <unavailable> + 1434246

    3    libswiftCore.so                    0x00002b27e88ba13c <unavailable> + 1433916

    4    libswiftCore.so                    0x00002b27e88b9bb0 _assertionFailure(_:_:file:line:flags:)
    + 251

    5    libswiftSwiftOnoneSupport.so       0x00002b27e86b9e83 <unavailable> + 188035

    6    tmpcnyfocvj                        0x000055c1f6e5ffb8 <unavailable> + 8120

    7    tmpcnyfocvj                        0x000055c1f6e5f908 <unavailable> + 6408

    8    libc.so.6                          0x00002b27e8daf460 __libc_start_main +
    245

    9    tmpcnyfocvj                        0x000055c1f6e5f2c9 <unavailable> + 4809

    '
  stdout: ''
  timestamp: 1660013380
- exit_code: 0
  program: "\n/// You are given an array of integers.\n/// Write a function next_smallest()\
    \ that returns the 2nd smallest element of the array.\n/// Return nil if there\
    \ is no such element.\n/// >>> next_smallest(lst: [1, 2, 3, 4, 5])\n/// 2\n///\
    \ >>> next_smallest(lst: [5, 1, 4, 3, 2])\n/// 2\n/// >>> next_smallest(lst: []\
    \ as [Int])\n/// nil\n/// >>> next_smallest(lst: [1, 1])\n/// nil\nfunc next_smallest(lst:\
    \ [Int]) -> Int? {\n    guard lst.count > 1 else { return nil }\n    var lst =\
    \ lst\n    lst.sort()\n    for index in 1..<lst.count {\n        if lst[index]\
    \ != lst[index - 1] {\n            return lst[index]\n        }\n    }\n    return\
    \ nil\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n   \
    \ if left.count != right.count {\n        return false\n    }\n    for (l, r)\
    \ in zip(left, right) {\n        if l != r {\n            return false\n     \
    \   }\n    }\n    return true\n}\n            \nassert(next_smallest(lst: [1,\
    \ 2, 3, 4, 5]) == 2)\nassert(next_smallest(lst: [5, 1, 4, 3, 2]) == 2)\nassert(next_smallest(lst:\
    \ [] as [Int]) == nil)\nassert(next_smallest(lst: [1, 1]) == nil)\nassert(next_smallest(lst:\
    \ [1, 1, 1, 1, 0]) == 1)\nassert(next_smallest(lst: [1, 1]) == nil)\nassert(next_smallest(lst:\
    \ [-35, 34, 12, -45]) == -35)"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660013380
- exit_code: -4
  program: "\n/// You are given an array of integers.\n/// Write a function next_smallest()\
    \ that returns the 2nd smallest element of the array.\n/// Return nil if there\
    \ is no such element.\n/// >>> next_smallest(lst: [1, 2, 3, 4, 5])\n/// 2\n///\
    \ >>> next_smallest(lst: [5, 1, 4, 3, 2])\n/// 2\n/// >>> next_smallest(lst: []\
    \ as [Int])\n/// nil\n/// >>> next_smallest(lst: [1, 1])\n/// nil\nfunc next_smallest(lst:\
    \ [Int]) -> Int? {\n    var min = Int.max\n    var secMin = Int.max\n    for item\
    \ in lst {\n        if item < min {\n            secMin = min\n            min\
    \ = item\n        } else if item < secMin {\n            secMin = item\n     \
    \   }\n    }\n    return secMin == Int.max ? nil : secMin\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(next_smallest(lst: [1, 2, 3, 4, 5]) == 2)\nassert(next_smallest(lst:\
    \ [5, 1, 4, 3, 2]) == 2)\nassert(next_smallest(lst: [] as [Int]) == nil)\nassert(next_smallest(lst:\
    \ [1, 1]) == nil)\nassert(next_smallest(lst: [1, 1, 1, 1, 0]) == 1)\nassert(next_smallest(lst:\
    \ [1, 1]) == nil)\nassert(next_smallest(lst: [-35, 34, 12, -45]) == -35)"
  status: Exception
  stderr: 'tmpcl1qrc21/tmpcl1qrc21.swift:43: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002ae655d20c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002ae655a17b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002ae655a17988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002ae655a167b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpcl1qrc21                        0x000055ac15c5b8da <unavailable> + 6362

    5    libc.so.6                          0x00002ae655f0c460 __libc_start_main +
    245

    6    tmpcl1qrc21                        0x000055ac15c5b0d9 <unavailable> + 4313

    '
  stdout: ''
  timestamp: 1660013380
- exit_code: 0
  program: "\n/// You are given an array of integers.\n/// Write a function next_smallest()\
    \ that returns the 2nd smallest element of the array.\n/// Return nil if there\
    \ is no such element.\n/// >>> next_smallest(lst: [1, 2, 3, 4, 5])\n/// 2\n///\
    \ >>> next_smallest(lst: [5, 1, 4, 3, 2])\n/// 2\n/// >>> next_smallest(lst: []\
    \ as [Int])\n/// nil\n/// >>> next_smallest(lst: [1, 1])\n/// nil\nfunc next_smallest(lst:\
    \ [Int]) -> Int? {\n    guard lst.count > 1 else { return nil }\n    let sortedList\
    \ = lst.sorted()\n    for i in 0..<sortedList.count - 1 {\n        if sortedList[i]\
    \ != sortedList[i + 1] {\n            return sortedList[i + 1]\n        }\n  \
    \  }\n    return nil\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(next_smallest(lst:\
    \ [1, 2, 3, 4, 5]) == 2)\nassert(next_smallest(lst: [5, 1, 4, 3, 2]) == 2)\nassert(next_smallest(lst:\
    \ [] as [Int]) == nil)\nassert(next_smallest(lst: [1, 1]) == nil)\nassert(next_smallest(lst:\
    \ [1, 1, 1, 1, 0]) == 1)\nassert(next_smallest(lst: [1, 1]) == nil)\nassert(next_smallest(lst:\
    \ [-35, 34, 12, -45]) == -35)"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660013380
- exit_code: 0
  program: "\n/// You are given an array of integers.\n/// Write a function next_smallest()\
    \ that returns the 2nd smallest element of the array.\n/// Return nil if there\
    \ is no such element.\n/// >>> next_smallest(lst: [1, 2, 3, 4, 5])\n/// 2\n///\
    \ >>> next_smallest(lst: [5, 1, 4, 3, 2])\n/// 2\n/// >>> next_smallest(lst: []\
    \ as [Int])\n/// nil\n/// >>> next_smallest(lst: [1, 1])\n/// nil\nfunc next_smallest(lst:\
    \ [Int]) -> Int? {\n    guard lst.count > 1 else { return nil }\n    let sortedLst\
    \ = lst.sorted()\n    for i in 0..<sortedLst.count - 1 {\n        if sortedLst[i]\
    \ != sortedLst[i + 1] {\n            return sortedLst[i + 1]\n        }\n    }\n\
    \    return nil\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool\
    \ {\n    if left.count != right.count {\n        return false\n    }\n    for\
    \ (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(next_smallest(lst:\
    \ [1, 2, 3, 4, 5]) == 2)\nassert(next_smallest(lst: [5, 1, 4, 3, 2]) == 2)\nassert(next_smallest(lst:\
    \ [] as [Int]) == nil)\nassert(next_smallest(lst: [1, 1]) == nil)\nassert(next_smallest(lst:\
    \ [1, 1, 1, 1, 0]) == 1)\nassert(next_smallest(lst: [1, 1]) == nil)\nassert(next_smallest(lst:\
    \ [-35, 34, 12, -45]) == -35)"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660013380
- exit_code: -4
  program: "\n/// You are given an array of integers.\n/// Write a function next_smallest()\
    \ that returns the 2nd smallest element of the array.\n/// Return nil if there\
    \ is no such element.\n/// >>> next_smallest(lst: [1, 2, 3, 4, 5])\n/// 2\n///\
    \ >>> next_smallest(lst: [5, 1, 4, 3, 2])\n/// 2\n/// >>> next_smallest(lst: []\
    \ as [Int])\n/// nil\n/// >>> next_smallest(lst: [1, 1])\n/// nil\nfunc next_smallest(lst:\
    \ [Int]) -> Int? {\n    return nil\n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(next_smallest(lst: [1, 2, 3, 4, 5]) == 2)\nassert(next_smallest(lst: [5,\
    \ 1, 4, 3, 2]) == 2)\nassert(next_smallest(lst: [] as [Int]) == nil)\nassert(next_smallest(lst:\
    \ [1, 1]) == nil)\nassert(next_smallest(lst: [1, 1, 1, 1, 0]) == 1)\nassert(next_smallest(lst:\
    \ [1, 1]) == nil)\nassert(next_smallest(lst: [-35, 34, 12, -45]) == -35)"
  status: Exception
  stderr: 'tmp2hp7hj7n/tmp2hp7hj7n.swift:30: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002afccf398c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002afccf08fb6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002afccf08f988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002afccf08e7b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmp2hp7hj7n                        0x0000560c9b7333e1 <unavailable> + 5089

    5    libc.so.6                          0x00002afccf584460 __libc_start_main +
    245

    6    tmp2hp7hj7n                        0x0000560c9b732f69 <unavailable> + 3945

    '
  stdout: ''
  timestamp: 1660013380
- exit_code: -4
  program: "\n/// You are given an array of integers.\n/// Write a function next_smallest()\
    \ that returns the 2nd smallest element of the array.\n/// Return nil if there\
    \ is no such element.\n/// >>> next_smallest(lst: [1, 2, 3, 4, 5])\n/// 2\n///\
    \ >>> next_smallest(lst: [5, 1, 4, 3, 2])\n/// 2\n/// >>> next_smallest(lst: []\
    \ as [Int])\n/// nil\n/// >>> next_smallest(lst: [1, 1])\n/// nil\nfunc next_smallest(lst:\
    \ [Int]) -> Int? {\n    var a = Array(lst)\n    if a.count < 2 {\n        return\
    \ nil\n    }\n    a.sort()\n    return a[1]\n}\n\n\nfunc ==(left: [(Int, Int)],\
    \ right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n       \
    \ return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r\
    \ {\n            return false\n        }\n    }\n    return true\n}\n        \
    \    \nassert(next_smallest(lst: [1, 2, 3, 4, 5]) == 2)\nassert(next_smallest(lst:\
    \ [5, 1, 4, 3, 2]) == 2)\nassert(next_smallest(lst: [] as [Int]) == nil)\nassert(next_smallest(lst:\
    \ [1, 1]) == nil)\nassert(next_smallest(lst: [1, 1, 1, 1, 0]) == 1)\nassert(next_smallest(lst:\
    \ [1, 1]) == nil)\nassert(next_smallest(lst: [-35, 34, 12, -45]) == -35)"
  status: Exception
  stderr: 'tmph2ewix2k/tmph2ewix2k.swift:38: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b316100bc80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b3160d02b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b3160d02988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b3160d017b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmph2ewix2k                        0x000055d1fc8cb9aa <unavailable> + 6570

    5    libc.so.6                          0x00002b31611f7460 __libc_start_main +
    245

    6    tmph2ewix2k                        0x000055d1fc8cb1a9 <unavailable> + 4521

    '
  stdout: ''
  timestamp: 1660013380
- exit_code: 0
  program: "\n/// You are given an array of integers.\n/// Write a function next_smallest()\
    \ that returns the 2nd smallest element of the array.\n/// Return nil if there\
    \ is no such element.\n/// >>> next_smallest(lst: [1, 2, 3, 4, 5])\n/// 2\n///\
    \ >>> next_smallest(lst: [5, 1, 4, 3, 2])\n/// 2\n/// >>> next_smallest(lst: []\
    \ as [Int])\n/// nil\n/// >>> next_smallest(lst: [1, 1])\n/// nil\nfunc next_smallest(lst:\
    \ [Int]) -> Int? {\n    guard lst.count > 1 else { return nil }\n    let sorted\
    \ = lst.sorted()\n    for i in 0..<sorted.count-1 {\n        if sorted[i] != sorted[i+1]\
    \ {\n            return sorted[i+1]\n        }\n    }\n    return nil\n}\n\n\n\
    func ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(next_smallest(lst: [1, 2, 3, 4, 5]) == 2)\nassert(next_smallest(lst:\
    \ [5, 1, 4, 3, 2]) == 2)\nassert(next_smallest(lst: [] as [Int]) == nil)\nassert(next_smallest(lst:\
    \ [1, 1]) == nil)\nassert(next_smallest(lst: [1, 1, 1, 1, 0]) == 1)\nassert(next_smallest(lst:\
    \ [1, 1]) == nil)\nassert(next_smallest(lst: [-35, 34, 12, -45]) == -35)"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660013380
- exit_code: 0
  program: "\n/// You are given an array of integers.\n/// Write a function next_smallest()\
    \ that returns the 2nd smallest element of the array.\n/// Return nil if there\
    \ is no such element.\n/// >>> next_smallest(lst: [1, 2, 3, 4, 5])\n/// 2\n///\
    \ >>> next_smallest(lst: [5, 1, 4, 3, 2])\n/// 2\n/// >>> next_smallest(lst: []\
    \ as [Int])\n/// nil\n/// >>> next_smallest(lst: [1, 1])\n/// nil\nfunc next_smallest(lst:\
    \ [Int]) -> Int? {\n    let sorted = lst.sorted()\n    if sorted.count > 1 {\n\
    \        if sorted[0] != sorted[1] {\n            return sorted[1]\n        }\n\
    \    }\n    return nil\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(next_smallest(lst:\
    \ [1, 2, 3, 4, 5]) == 2)\nassert(next_smallest(lst: [5, 1, 4, 3, 2]) == 2)\nassert(next_smallest(lst:\
    \ [] as [Int]) == nil)\nassert(next_smallest(lst: [1, 1]) == nil)\nassert(next_smallest(lst:\
    \ [1, 1, 1, 1, 0]) == 1)\nassert(next_smallest(lst: [1, 1]) == nil)\nassert(next_smallest(lst:\
    \ [-35, 34, 12, -45]) == -35)"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660013380
- exit_code: -4
  program: "\n/// You are given an array of integers.\n/// Write a function next_smallest()\
    \ that returns the 2nd smallest element of the array.\n/// Return nil if there\
    \ is no such element.\n/// >>> next_smallest(lst: [1, 2, 3, 4, 5])\n/// 2\n///\
    \ >>> next_smallest(lst: [5, 1, 4, 3, 2])\n/// 2\n/// >>> next_smallest(lst: []\
    \ as [Int])\n/// nil\n/// >>> next_smallest(lst: [1, 1])\n/// nil\nfunc next_smallest(lst:\
    \ [Int]) -> Int? {\n    return nil\n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(next_smallest(lst: [1, 2, 3, 4, 5]) == 2)\nassert(next_smallest(lst: [5,\
    \ 1, 4, 3, 2]) == 2)\nassert(next_smallest(lst: [] as [Int]) == nil)\nassert(next_smallest(lst:\
    \ [1, 1]) == nil)\nassert(next_smallest(lst: [1, 1, 1, 1, 0]) == 1)\nassert(next_smallest(lst:\
    \ [1, 1]) == nil)\nassert(next_smallest(lst: [-35, 34, 12, -45]) == -35)"
  status: Exception
  stderr: 'tmp2hp7hj7n/tmp2hp7hj7n.swift:30: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002afccf398c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002afccf08fb6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002afccf08f988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002afccf08e7b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmp2hp7hj7n                        0x0000560c9b7333e1 <unavailable> + 5089

    5    libc.so.6                          0x00002afccf584460 __libc_start_main +
    245

    6    tmp2hp7hj7n                        0x0000560c9b732f69 <unavailable> + 3945

    '
  stdout: ''
  timestamp: 1660013380
- exit_code: 0
  program: "\n/// You are given an array of integers.\n/// Write a function next_smallest()\
    \ that returns the 2nd smallest element of the array.\n/// Return nil if there\
    \ is no such element.\n/// >>> next_smallest(lst: [1, 2, 3, 4, 5])\n/// 2\n///\
    \ >>> next_smallest(lst: [5, 1, 4, 3, 2])\n/// 2\n/// >>> next_smallest(lst: []\
    \ as [Int])\n/// nil\n/// >>> next_smallest(lst: [1, 1])\n/// nil\nfunc next_smallest(lst:\
    \ [Int]) -> Int? {\n    guard lst.count > 1 else { return nil }\n    let min =\
    \ lst.min()\n    return lst.filter { $0 != min }.min()\n}\n\n\nfunc ==(left: [(Int,\
    \ Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n\
    \        return false\n    }\n    for (l, r) in zip(left, right) {\n        if\
    \ l != r {\n            return false\n        }\n    }\n    return true\n}\n \
    \           \nassert(next_smallest(lst: [1, 2, 3, 4, 5]) == 2)\nassert(next_smallest(lst:\
    \ [5, 1, 4, 3, 2]) == 2)\nassert(next_smallest(lst: [] as [Int]) == nil)\nassert(next_smallest(lst:\
    \ [1, 1]) == nil)\nassert(next_smallest(lst: [1, 1, 1, 1, 0]) == 1)\nassert(next_smallest(lst:\
    \ [1, 1]) == nil)\nassert(next_smallest(lst: [-35, 34, 12, -45]) == -35)"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660013380
- exit_code: 0
  program: "\n/// You are given an array of integers.\n/// Write a function next_smallest()\
    \ that returns the 2nd smallest element of the array.\n/// Return nil if there\
    \ is no such element.\n/// >>> next_smallest(lst: [1, 2, 3, 4, 5])\n/// 2\n///\
    \ >>> next_smallest(lst: [5, 1, 4, 3, 2])\n/// 2\n/// >>> next_smallest(lst: []\
    \ as [Int])\n/// nil\n/// >>> next_smallest(lst: [1, 1])\n/// nil\nfunc next_smallest(lst:\
    \ [Int]) -> Int? {\n    var dic = [Int: Int]()\n    for num in lst {\n       \
    \ dic[num] = (dic[num] ?? 0) + 1\n    }\n    var counts = [Int](dic.keys).sorted()\n\
    \    if counts.count == 0 {\n        return nil\n    }\n    if counts.count ==\
    \ 1 || counts[0] == counts[1] {\n        return nil\n    }\n    return counts[1]\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(next_smallest(lst: [1, 2, 3, 4, 5]) == 2)\nassert(next_smallest(lst:\
    \ [5, 1, 4, 3, 2]) == 2)\nassert(next_smallest(lst: [] as [Int]) == nil)\nassert(next_smallest(lst:\
    \ [1, 1]) == nil)\nassert(next_smallest(lst: [1, 1, 1, 1, 0]) == 1)\nassert(next_smallest(lst:\
    \ [1, 1]) == nil)\nassert(next_smallest(lst: [-35, 34, 12, -45]) == -35)"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660013380
- exit_code: -4
  program: "\n/// You are given an array of integers.\n/// Write a function next_smallest()\
    \ that returns the 2nd smallest element of the array.\n/// Return nil if there\
    \ is no such element.\n/// >>> next_smallest(lst: [1, 2, 3, 4, 5])\n/// 2\n///\
    \ >>> next_smallest(lst: [5, 1, 4, 3, 2])\n/// 2\n/// >>> next_smallest(lst: []\
    \ as [Int])\n/// nil\n/// >>> next_smallest(lst: [1, 1])\n/// nil\nfunc next_smallest(lst:\
    \ [Int]) -> Int? {\n    let sorted = lst.sorted()\n    for num in sorted {\n \
    \       if let index = sorted.index(of: num), sorted.indices.contains(index +\
    \ 1) {\n            return sorted[index + 1]\n        }\n    }\n    return nil\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(next_smallest(lst: [1, 2, 3, 4, 5]) == 2)\nassert(next_smallest(lst:\
    \ [5, 1, 4, 3, 2]) == 2)\nassert(next_smallest(lst: [] as [Int]) == nil)\nassert(next_smallest(lst:\
    \ [1, 1]) == nil)\nassert(next_smallest(lst: [1, 1, 1, 1, 0]) == 1)\nassert(next_smallest(lst:\
    \ [1, 1]) == nil)\nassert(next_smallest(lst: [-35, 34, 12, -45]) == -35)"
  status: Exception
  stderr: 'tmpduzgo0bc/tmpduzgo0bc.swift:39: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002af667bc7c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002af6678beb6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002af6678be988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002af6678bd7b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpduzgo0bc                        0x000055db5e1ccb2a <unavailable> + 6954

    5    libc.so.6                          0x00002af667db3460 __libc_start_main +
    245

    6    tmpduzgo0bc                        0x000055db5e1cc329 <unavailable> + 4905

    '
  stdout: ''
  timestamp: 1660013380
- exit_code: 0
  program: "\n/// You are given an array of integers.\n/// Write a function next_smallest()\
    \ that returns the 2nd smallest element of the array.\n/// Return nil if there\
    \ is no such element.\n/// >>> next_smallest(lst: [1, 2, 3, 4, 5])\n/// 2\n///\
    \ >>> next_smallest(lst: [5, 1, 4, 3, 2])\n/// 2\n/// >>> next_smallest(lst: []\
    \ as [Int])\n/// nil\n/// >>> next_smallest(lst: [1, 1])\n/// nil\nfunc next_smallest(lst:\
    \ [Int]) -> Int? {\n    guard lst.count > 1 else { return nil }\n    var copy\
    \ = lst\n    copy.sort()\n    for (i, n) in copy.enumerated() {\n        if i\
    \ > 0 && n != copy[i - 1] {\n            return n\n        }\n    }\n    return\
    \ nil\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n   \
    \ if left.count != right.count {\n        return false\n    }\n    for (l, r)\
    \ in zip(left, right) {\n        if l != r {\n            return false\n     \
    \   }\n    }\n    return true\n}\n            \nassert(next_smallest(lst: [1,\
    \ 2, 3, 4, 5]) == 2)\nassert(next_smallest(lst: [5, 1, 4, 3, 2]) == 2)\nassert(next_smallest(lst:\
    \ [] as [Int]) == nil)\nassert(next_smallest(lst: [1, 1]) == nil)\nassert(next_smallest(lst:\
    \ [1, 1, 1, 1, 0]) == 1)\nassert(next_smallest(lst: [1, 1]) == nil)\nassert(next_smallest(lst:\
    \ [-35, 34, 12, -45]) == -35)"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660013380
- exit_code: -4
  program: "\n/// You are given an array of integers.\n/// Write a function next_smallest()\
    \ that returns the 2nd smallest element of the array.\n/// Return nil if there\
    \ is no such element.\n/// >>> next_smallest(lst: [1, 2, 3, 4, 5])\n/// 2\n///\
    \ >>> next_smallest(lst: [5, 1, 4, 3, 2])\n/// 2\n/// >>> next_smallest(lst: []\
    \ as [Int])\n/// nil\n/// >>> next_smallest(lst: [1, 1])\n/// nil\nfunc next_smallest(lst:\
    \ [Int]) -> Int? {\n    guard lst.count > 1 else { return nil }\n    let sortedList\
    \ = lst.sorted()\n    return sortedList[1]\n}\n\n\nfunc ==(left: [(Int, Int)],\
    \ right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n       \
    \ return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r\
    \ {\n            return false\n        }\n    }\n    return true\n}\n        \
    \    \nassert(next_smallest(lst: [1, 2, 3, 4, 5]) == 2)\nassert(next_smallest(lst:\
    \ [5, 1, 4, 3, 2]) == 2)\nassert(next_smallest(lst: [] as [Int]) == nil)\nassert(next_smallest(lst:\
    \ [1, 1]) == nil)\nassert(next_smallest(lst: [1, 1, 1, 1, 0]) == 1)\nassert(next_smallest(lst:\
    \ [1, 1]) == nil)\nassert(next_smallest(lst: [-35, 34, 12, -45]) == -35)"
  status: Exception
  stderr: 'tmpp7gbgg_t/tmpp7gbgg_t.swift:35: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b82aef71c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b82aec68b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b82aec68988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b82aec677b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpp7gbgg_t                        0x000055897cf538ba <unavailable> + 6330

    5    libc.so.6                          0x00002b82af15d460 __libc_start_main +
    245

    6    tmpp7gbgg_t                        0x000055897cf530b9 <unavailable> + 4281

    '
  stdout: ''
  timestamp: 1660013380
- exit_code: -4
  program: "\n/// You are given an array of integers.\n/// Write a function next_smallest()\
    \ that returns the 2nd smallest element of the array.\n/// Return nil if there\
    \ is no such element.\n/// >>> next_smallest(lst: [1, 2, 3, 4, 5])\n/// 2\n///\
    \ >>> next_smallest(lst: [5, 1, 4, 3, 2])\n/// 2\n/// >>> next_smallest(lst: []\
    \ as [Int])\n/// nil\n/// >>> next_smallest(lst: [1, 1])\n/// nil\nfunc next_smallest(lst:\
    \ [Int]) -> Int? {\n    if lst.count < 2 {\n        return nil\n    }\n    var\
    \ min = lst[0]\n    var s = lst[0]\n    for i in 1..<lst.count {\n        if lst[i]\
    \ < min {\n            s = min\n            min = lst[i]\n        } else if lst[i]\
    \ < s {\n            s = lst[i]\n        }\n    }\n    return s\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(next_smallest(lst: [1, 2, 3, 4, 5]) == 2)\nassert(next_smallest(lst:\
    \ [5, 1, 4, 3, 2]) == 2)\nassert(next_smallest(lst: [] as [Int]) == nil)\nassert(next_smallest(lst:\
    \ [1, 1]) == nil)\nassert(next_smallest(lst: [1, 1, 1, 1, 0]) == 1)\nassert(next_smallest(lst:\
    \ [1, 1]) == nil)\nassert(next_smallest(lst: [-35, 34, 12, -45]) == -35)"
  status: Exception
  stderr: 'tmp21tlowaa/tmp21tlowaa.swift:43: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002aff391c8c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002aff38ebfb6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002aff38ebf988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002aff38ebe7b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmp21tlowaa                        0x0000560c5237c621 <unavailable> + 5665

    5    libc.so.6                          0x00002aff393b4460 __libc_start_main +
    245

    6    tmp21tlowaa                        0x0000560c5237c1a9 <unavailable> + 4521

    '
  stdout: ''
  timestamp: 1660013380
- exit_code: -4
  program: "\n/// You are given an array of integers.\n/// Write a function next_smallest()\
    \ that returns the 2nd smallest element of the array.\n/// Return nil if there\
    \ is no such element.\n/// >>> next_smallest(lst: [1, 2, 3, 4, 5])\n/// 2\n///\
    \ >>> next_smallest(lst: [5, 1, 4, 3, 2])\n/// 2\n/// >>> next_smallest(lst: []\
    \ as [Int])\n/// nil\n/// >>> next_smallest(lst: [1, 1])\n/// nil\nfunc next_smallest(lst:\
    \ [Int]) -> Int? {\n    var smallest = Int.max\n    var second_smallest = Int.max\n\
    \    for i in lst {\n        if i < smallest {\n            second_smallest =\
    \ smallest\n            smallest = i\n        } else if i < second_smallest {\n\
    \            second_smallest = i\n        }\n    }\n    return second_smallest\
    \ == Int.max ? nil : second_smallest\n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(next_smallest(lst: [1, 2, 3, 4, 5]) == 2)\nassert(next_smallest(lst: [5,\
    \ 1, 4, 3, 2]) == 2)\nassert(next_smallest(lst: [] as [Int]) == nil)\nassert(next_smallest(lst:\
    \ [1, 1]) == nil)\nassert(next_smallest(lst: [1, 1, 1, 1, 0]) == 1)\nassert(next_smallest(lst:\
    \ [1, 1]) == nil)\nassert(next_smallest(lst: [-35, 34, 12, -45]) == -35)"
  status: Exception
  stderr: 'tmpenr8iesz/tmpenr8iesz.swift:43: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b46c3021c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b46c2d18b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b46c2d18988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b46c2d177b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpenr8iesz                        0x000055e2dc7568da <unavailable> + 6362

    5    libc.so.6                          0x00002b46c320d460 __libc_start_main +
    245

    6    tmpenr8iesz                        0x000055e2dc7560d9 <unavailable> + 4313

    '
  stdout: ''
  timestamp: 1660013380
- exit_code: 1
  program: "\n/// You are given an array of integers.\n/// Write a function next_smallest()\
    \ that returns the 2nd smallest element of the array.\n/// Return nil if there\
    \ is no such element.\n/// >>> next_smallest(lst: [1, 2, 3, 4, 5])\n/// 2\n///\
    \ >>> next_smallest(lst: [5, 1, 4, 3, 2])\n/// 2\n/// >>> next_smallest(lst: []\
    \ as [Int])\n/// nil\n/// >>> next_smallest(lst: [1, 1])\n/// nil\nfunc next_smallest(lst:\
    \ [Int]) -> Int? {\n    return lst.sorted(by: <)[safe: 1]\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(next_smallest(lst: [1, 2, 3, 4, 5]) == 2)\nassert(next_smallest(lst:\
    \ [5, 1, 4, 3, 2]) == 2)\nassert(next_smallest(lst: [] as [Int]) == nil)\nassert(next_smallest(lst:\
    \ [1, 1]) == nil)\nassert(next_smallest(lst: [1, 1, 1, 1, 0]) == 1)\nassert(next_smallest(lst:\
    \ [1, 1]) == nil)\nassert(next_smallest(lst: [-35, 34, 12, -45]) == -35)"
  status: SyntaxError
  stderr: "/tmp/tmpdql_kfbm.swift:14:29: error: extraneous argument label 'safe:'\
    \ in subscript\n    return lst.sorted(by: <)[safe: 1]\n                      \
    \      ^~~~~~~\n                             \n"
  stdout: ''
  timestamp: 1660013380
- exit_code: -4
  program: "\n/// You are given an array of integers.\n/// Write a function next_smallest()\
    \ that returns the 2nd smallest element of the array.\n/// Return nil if there\
    \ is no such element.\n/// >>> next_smallest(lst: [1, 2, 3, 4, 5])\n/// 2\n///\
    \ >>> next_smallest(lst: [5, 1, 4, 3, 2])\n/// 2\n/// >>> next_smallest(lst: []\
    \ as [Int])\n/// nil\n/// >>> next_smallest(lst: [1, 1])\n/// nil\nfunc next_smallest(lst:\
    \ [Int]) -> Int? {\n    guard lst.count > 1 else { return nil }\n    guard lst.count\
    \ > 2 else { return lst[1] }\n    var min = lst[0]\n    var minIndex = 0\n   \
    \ var secondMin = lst[1]\n    var secondMinIndex = 1\n    var i = 2\n    while\
    \ i < lst.count {\n        if lst[i] < min {\n            secondMin = min\n  \
    \          secondMinIndex = minIndex\n            min = lst[i]\n            minIndex\
    \ = i\n        } else if lst[i] < secondMin {\n            secondMin = lst[i]\n\
    \            secondMinIndex = i\n        }\n        i += 1\n    }\n    return\
    \ minIndex != secondMinIndex ? secondMin : nil\n}\n\n\nfunc ==(left: [(Int, Int)],\
    \ right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n       \
    \ return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r\
    \ {\n            return false\n        }\n    }\n    return true\n}\n        \
    \    \nassert(next_smallest(lst: [1, 2, 3, 4, 5]) == 2)\nassert(next_smallest(lst:\
    \ [5, 1, 4, 3, 2]) == 2)\nassert(next_smallest(lst: [] as [Int]) == nil)\nassert(next_smallest(lst:\
    \ [1, 1]) == nil)\nassert(next_smallest(lst: [1, 1, 1, 1, 0]) == 1)\nassert(next_smallest(lst:\
    \ [1, 1]) == nil)\nassert(next_smallest(lst: [-35, 34, 12, -45]) == -35)"
  status: Exception
  stderr: 'tmpe8tqcac3/tmpe8tqcac3.swift:50: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b2f8bb7fc80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b2f8b876b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b2f8b876988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b2f8b8757b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpe8tqcac3                        0x000055e092873635 <unavailable> + 5685

    5    libc.so.6                          0x00002b2f8bd6b460 __libc_start_main +
    245

    6    tmpe8tqcac3                        0x000055e092873019 <unavailable> + 4121

    '
  stdout: ''
  timestamp: 1660013380
- exit_code: -4
  program: "\n/// You are given an array of integers.\n/// Write a function next_smallest()\
    \ that returns the 2nd smallest element of the array.\n/// Return nil if there\
    \ is no such element.\n/// >>> next_smallest(lst: [1, 2, 3, 4, 5])\n/// 2\n///\
    \ >>> next_smallest(lst: [5, 1, 4, 3, 2])\n/// 2\n/// >>> next_smallest(lst: []\
    \ as [Int])\n/// nil\n/// >>> next_smallest(lst: [1, 1])\n/// nil\nfunc next_smallest(lst:\
    \ [Int]) -> Int? {\n    guard lst.count > 1 else { return nil }\n    var min =\
    \ lst[0]\n    var min2 = lst[1]\n    if min > min2 { swap(&min, &min2) }\n   \
    \ for value in lst[2...] {\n        if value < min {\n            min2 = min\n\
    \            min = value\n        } else if value < min2 {\n            min2 =\
    \ value\n        }\n    }\n    return min2\n}\n\n\nfunc ==(left: [(Int, Int)],\
    \ right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n       \
    \ return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r\
    \ {\n            return false\n        }\n    }\n    return true\n}\n        \
    \    \nassert(next_smallest(lst: [1, 2, 3, 4, 5]) == 2)\nassert(next_smallest(lst:\
    \ [5, 1, 4, 3, 2]) == 2)\nassert(next_smallest(lst: [] as [Int]) == nil)\nassert(next_smallest(lst:\
    \ [1, 1]) == nil)\nassert(next_smallest(lst: [1, 1, 1, 1, 0]) == 1)\nassert(next_smallest(lst:\
    \ [1, 1]) == nil)\nassert(next_smallest(lst: [-35, 34, 12, -45]) == -35)"
  status: Exception
  stderr: 'tmpiet07dtw/tmpiet07dtw.swift:45: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b76791fdc80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b7678ef4b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b7678ef4988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b7678ef37b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpiet07dtw                        0x000055ae5ac41b8a <unavailable> + 7050

    5    libc.so.6                          0x00002b76793e9460 __libc_start_main +
    245

    6    tmpiet07dtw                        0x000055ae5ac41389 <unavailable> + 5001

    '
  stdout: ''
  timestamp: 1660013380
- exit_code: -4
  program: "\n/// You are given an array of integers.\n/// Write a function next_smallest()\
    \ that returns the 2nd smallest element of the array.\n/// Return nil if there\
    \ is no such element.\n/// >>> next_smallest(lst: [1, 2, 3, 4, 5])\n/// 2\n///\
    \ >>> next_smallest(lst: [5, 1, 4, 3, 2])\n/// 2\n/// >>> next_smallest(lst: []\
    \ as [Int])\n/// nil\n/// >>> next_smallest(lst: [1, 1])\n/// nil\nfunc next_smallest(lst:\
    \ [Int]) -> Int? {\n    if lst.count == 0 {\n        return nil\n    }\n    if\
    \ lst.count == 1 {\n        return nil\n    }\n    var lst = lst\n    lst.sort()\n\
    \    var smol = lst[0]\n    var smol2 = lst[1]\n    for number in lst {\n    \
    \    if number == smol {\n            continue\n        }\n        if number ==\
    \ smol2 {\n            return smol\n        }\n        if number < smol2 {\n \
    \           smol = smol2\n            smol2 = number\n        }\n    }\n    return\
    \ nil\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n   \
    \ if left.count != right.count {\n        return false\n    }\n    for (l, r)\
    \ in zip(left, right) {\n        if l != r {\n            return false\n     \
    \   }\n    }\n    return true\n}\n            \nassert(next_smallest(lst: [1,\
    \ 2, 3, 4, 5]) == 2)\nassert(next_smallest(lst: [5, 1, 4, 3, 2]) == 2)\nassert(next_smallest(lst:\
    \ [] as [Int]) == nil)\nassert(next_smallest(lst: [1, 1]) == nil)\nassert(next_smallest(lst:\
    \ [1, 1, 1, 1, 0]) == 1)\nassert(next_smallest(lst: [1, 1]) == nil)\nassert(next_smallest(lst:\
    \ [-35, 34, 12, -45]) == -35)"
  status: Exception
  stderr: 'tmpxqddwi4z/tmpxqddwi4z.swift:52: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b8594e59c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b8594b50b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b8594b50988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b8594b4f7b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpxqddwi4z                        0x00005635ac891721 <unavailable> + 5921

    5    libc.so.6                          0x00002b8595045460 __libc_start_main +
    245

    6    tmpxqddwi4z                        0x00005635ac8912a9 <unavailable> + 4777

    '
  stdout: ''
  timestamp: 1660013380
- exit_code: 0
  program: "\n/// You are given an array of integers.\n/// Write a function next_smallest()\
    \ that returns the 2nd smallest element of the array.\n/// Return nil if there\
    \ is no such element.\n/// >>> next_smallest(lst: [1, 2, 3, 4, 5])\n/// 2\n///\
    \ >>> next_smallest(lst: [5, 1, 4, 3, 2])\n/// 2\n/// >>> next_smallest(lst: []\
    \ as [Int])\n/// nil\n/// >>> next_smallest(lst: [1, 1])\n/// nil\nfunc next_smallest(lst:\
    \ [Int]) -> Int? {\n    guard lst.count > 1 else { return nil }\n    let sortedLst\
    \ = lst.sorted()\n    for i in 1..<sortedLst.count {\n        if sortedLst[i]\
    \ != sortedLst[i - 1] {\n            return sortedLst[i]\n        }\n    }\n \
    \   return nil\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool\
    \ {\n    if left.count != right.count {\n        return false\n    }\n    for\
    \ (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(next_smallest(lst:\
    \ [1, 2, 3, 4, 5]) == 2)\nassert(next_smallest(lst: [5, 1, 4, 3, 2]) == 2)\nassert(next_smallest(lst:\
    \ [] as [Int]) == nil)\nassert(next_smallest(lst: [1, 1]) == nil)\nassert(next_smallest(lst:\
    \ [1, 1, 1, 1, 0]) == 1)\nassert(next_smallest(lst: [1, 1]) == nil)\nassert(next_smallest(lst:\
    \ [-35, 34, 12, -45]) == -35)"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660013380
- exit_code: 0
  program: "\n/// You are given an array of integers.\n/// Write a function next_smallest()\
    \ that returns the 2nd smallest element of the array.\n/// Return nil if there\
    \ is no such element.\n/// >>> next_smallest(lst: [1, 2, 3, 4, 5])\n/// 2\n///\
    \ >>> next_smallest(lst: [5, 1, 4, 3, 2])\n/// 2\n/// >>> next_smallest(lst: []\
    \ as [Int])\n/// nil\n/// >>> next_smallest(lst: [1, 1])\n/// nil\nfunc next_smallest(lst:\
    \ [Int]) -> Int? {\n    \n    if lst.count < 2 {\n        return nil\n    }\n\
    \    \n    if lst.count == 2 {\n        if lst[0] != lst[1] {\n            return\
    \ lst[1]\n        } else {\n            return nil\n        }\n    }\n    \n \
    \   let min = lst.min()!\n    let sortedLst = lst.sorted()\n    for n in sortedLst\
    \ {\n        if n > min {\n            return n\n        }\n    }\n    \n    return\
    \ nil\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n   \
    \ if left.count != right.count {\n        return false\n    }\n    for (l, r)\
    \ in zip(left, right) {\n        if l != r {\n            return false\n     \
    \   }\n    }\n    return true\n}\n            \nassert(next_smallest(lst: [1,\
    \ 2, 3, 4, 5]) == 2)\nassert(next_smallest(lst: [5, 1, 4, 3, 2]) == 2)\nassert(next_smallest(lst:\
    \ [] as [Int]) == nil)\nassert(next_smallest(lst: [1, 1]) == nil)\nassert(next_smallest(lst:\
    \ [1, 1, 1, 1, 0]) == 1)\nassert(next_smallest(lst: [1, 1]) == nil)\nassert(next_smallest(lst:\
    \ [-35, 34, 12, -45]) == -35)"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660013380
- exit_code: 0
  program: "\n/// You are given an array of integers.\n/// Write a function next_smallest()\
    \ that returns the 2nd smallest element of the array.\n/// Return nil if there\
    \ is no such element.\n/// >>> next_smallest(lst: [1, 2, 3, 4, 5])\n/// 2\n///\
    \ >>> next_smallest(lst: [5, 1, 4, 3, 2])\n/// 2\n/// >>> next_smallest(lst: []\
    \ as [Int])\n/// nil\n/// >>> next_smallest(lst: [1, 1])\n/// nil\nfunc next_smallest(lst:\
    \ [Int]) -> Int? {\n    if lst.count == 0 {\n        return nil\n    } else if\
    \ lst.count == 1 {\n        return nil\n    } else {\n        var lst = lst\n\
    \        lst.sort()\n        for i in 1..<lst.count {\n            if lst[i] !=\
    \ lst[i-1] {\n                return lst[i]\n            }\n        }\n      \
    \  return nil\n    }\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(next_smallest(lst:\
    \ [1, 2, 3, 4, 5]) == 2)\nassert(next_smallest(lst: [5, 1, 4, 3, 2]) == 2)\nassert(next_smallest(lst:\
    \ [] as [Int]) == nil)\nassert(next_smallest(lst: [1, 1]) == nil)\nassert(next_smallest(lst:\
    \ [1, 1, 1, 1, 0]) == 1)\nassert(next_smallest(lst: [1, 1]) == nil)\nassert(next_smallest(lst:\
    \ [-35, 34, 12, -45]) == -35)"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660013380
- exit_code: -4
  program: "\n/// You are given an array of integers.\n/// Write a function next_smallest()\
    \ that returns the 2nd smallest element of the array.\n/// Return nil if there\
    \ is no such element.\n/// >>> next_smallest(lst: [1, 2, 3, 4, 5])\n/// 2\n///\
    \ >>> next_smallest(lst: [5, 1, 4, 3, 2])\n/// 2\n/// >>> next_smallest(lst: []\
    \ as [Int])\n/// nil\n/// >>> next_smallest(lst: [1, 1])\n/// nil\nfunc next_smallest(lst:\
    \ [Int]) -> Int? {\n  return lst.sorted().dropFirst().first\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(next_smallest(lst: [1, 2, 3, 4, 5]) == 2)\nassert(next_smallest(lst:\
    \ [5, 1, 4, 3, 2]) == 2)\nassert(next_smallest(lst: [] as [Int]) == nil)\nassert(next_smallest(lst:\
    \ [1, 1]) == nil)\nassert(next_smallest(lst: [1, 1, 1, 1, 0]) == 1)\nassert(next_smallest(lst:\
    \ [1, 1]) == nil)\nassert(next_smallest(lst: [-35, 34, 12, -45]) == -35)"
  status: Exception
  stderr: 'tmpgh5bgug4/tmpgh5bgug4.swift:33: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002affbe442c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002affbe139b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002affbe139988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002affbe1387b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpgh5bgug4                        0x000055a7e6c589aa <unavailable> + 6570

    5    libc.so.6                          0x00002affbe62e460 __libc_start_main +
    245

    6    tmpgh5bgug4                        0x000055a7e6c581a9 <unavailable> + 4521

    '
  stdout: ''
  timestamp: 1660013380
- exit_code: -4
  program: "\n/// You are given an array of integers.\n/// Write a function next_smallest()\
    \ that returns the 2nd smallest element of the array.\n/// Return nil if there\
    \ is no such element.\n/// >>> next_smallest(lst: [1, 2, 3, 4, 5])\n/// 2\n///\
    \ >>> next_smallest(lst: [5, 1, 4, 3, 2])\n/// 2\n/// >>> next_smallest(lst: []\
    \ as [Int])\n/// nil\n/// >>> next_smallest(lst: [1, 1])\n/// nil\nfunc next_smallest(lst:\
    \ [Int]) -> Int? {\n    if lst.count < 2 {\n        return nil\n    }\n    if\
    \ lst.count == 2 {\n        if lst[0] != lst[1] {\n            return lst[1]\n\
    \        } else {\n            return nil\n        }\n    }\n    var m1 = lst[0]\n\
    \    var m2 = lst[1]\n    for x in lst[2..<lst.count] {\n        if x < m1 {\n\
    \            m2 = m1\n            m1 = x\n        } else if x < m2 {\n       \
    \     m2 = x\n        }\n    }\n    return m2\n}\n\n\nfunc ==(left: [(Int, Int)],\
    \ right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n       \
    \ return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r\
    \ {\n            return false\n        }\n    }\n    return true\n}\n        \
    \    \nassert(next_smallest(lst: [1, 2, 3, 4, 5]) == 2)\nassert(next_smallest(lst:\
    \ [5, 1, 4, 3, 2]) == 2)\nassert(next_smallest(lst: [] as [Int]) == nil)\nassert(next_smallest(lst:\
    \ [1, 1]) == nil)\nassert(next_smallest(lst: [1, 1, 1, 1, 0]) == 1)\nassert(next_smallest(lst:\
    \ [1, 1]) == nil)\nassert(next_smallest(lst: [-35, 34, 12, -45]) == -35)"
  status: Exception
  stderr: 'tmpupc7of27/tmpupc7of27.swift:51: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b89b7b16c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b89b780db6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b89b780d988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b89b780c7b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpupc7of27                        0x0000562900af88e5 <unavailable> + 6373

    5    libc.so.6                          0x00002b89b7d02460 __libc_start_main +
    245

    6    tmpupc7of27                        0x0000562900af82c9 <unavailable> + 4809

    '
  stdout: ''
  timestamp: 1660013380
- exit_code: 0
  program: "\n/// You are given an array of integers.\n/// Write a function next_smallest()\
    \ that returns the 2nd smallest element of the array.\n/// Return nil if there\
    \ is no such element.\n/// >>> next_smallest(lst: [1, 2, 3, 4, 5])\n/// 2\n///\
    \ >>> next_smallest(lst: [5, 1, 4, 3, 2])\n/// 2\n/// >>> next_smallest(lst: []\
    \ as [Int])\n/// nil\n/// >>> next_smallest(lst: [1, 1])\n/// nil\nfunc next_smallest(lst:\
    \ [Int]) -> Int? {\n    guard lst.count > 1 else { return nil }\n    let sorted\
    \ = lst.sorted()\n    guard sorted[0] != sorted[1] else { return nil }\n    return\
    \ sorted[1]\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n\
    \    if left.count != right.count {\n        return false\n    }\n    for (l,\
    \ r) in zip(left, right) {\n        if l != r {\n            return false\n  \
    \      }\n    }\n    return true\n}\n            \nassert(next_smallest(lst: [1,\
    \ 2, 3, 4, 5]) == 2)\nassert(next_smallest(lst: [5, 1, 4, 3, 2]) == 2)\nassert(next_smallest(lst:\
    \ [] as [Int]) == nil)\nassert(next_smallest(lst: [1, 1]) == nil)\nassert(next_smallest(lst:\
    \ [1, 1, 1, 1, 0]) == 1)\nassert(next_smallest(lst: [1, 1]) == nil)\nassert(next_smallest(lst:\
    \ [-35, 34, 12, -45]) == -35)"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660013380
- exit_code: 0
  program: "\n/// You are given an array of integers.\n/// Write a function next_smallest()\
    \ that returns the 2nd smallest element of the array.\n/// Return nil if there\
    \ is no such element.\n/// >>> next_smallest(lst: [1, 2, 3, 4, 5])\n/// 2\n///\
    \ >>> next_smallest(lst: [5, 1, 4, 3, 2])\n/// 2\n/// >>> next_smallest(lst: []\
    \ as [Int])\n/// nil\n/// >>> next_smallest(lst: [1, 1])\n/// nil\nfunc next_smallest(lst:\
    \ [Int]) -> Int? {\n    var arr = lst\n    arr.sort()\n    if arr.count <= 1 {\n\
    \        return nil\n    }\n    for i in 0..<arr.count - 1 {\n        if arr[i]\
    \ != arr[i + 1] {\n            return arr[i + 1]\n        }\n    }\n    return\
    \ nil\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n   \
    \ if left.count != right.count {\n        return false\n    }\n    for (l, r)\
    \ in zip(left, right) {\n        if l != r {\n            return false\n     \
    \   }\n    }\n    return true\n}\n            \nassert(next_smallest(lst: [1,\
    \ 2, 3, 4, 5]) == 2)\nassert(next_smallest(lst: [5, 1, 4, 3, 2]) == 2)\nassert(next_smallest(lst:\
    \ [] as [Int]) == nil)\nassert(next_smallest(lst: [1, 1]) == nil)\nassert(next_smallest(lst:\
    \ [1, 1, 1, 1, 0]) == 1)\nassert(next_smallest(lst: [1, 1]) == nil)\nassert(next_smallest(lst:\
    \ [-35, 34, 12, -45]) == -35)"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660013380
- exit_code: 0
  program: "\n/// You are given an array of integers.\n/// Write a function next_smallest()\
    \ that returns the 2nd smallest element of the array.\n/// Return nil if there\
    \ is no such element.\n/// >>> next_smallest(lst: [1, 2, 3, 4, 5])\n/// 2\n///\
    \ >>> next_smallest(lst: [5, 1, 4, 3, 2])\n/// 2\n/// >>> next_smallest(lst: []\
    \ as [Int])\n/// nil\n/// >>> next_smallest(lst: [1, 1])\n/// nil\nfunc next_smallest(lst:\
    \ [Int]) -> Int? {\n    if lst.count < 2 {\n        return nil\n    }\n    var\
    \ sorted = lst.sorted()\n    for i in 1..<sorted.count {\n        if sorted[i]\
    \ != sorted[i - 1] {\n            return sorted[i]\n        }\n    }\n    return\
    \ nil\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n   \
    \ if left.count != right.count {\n        return false\n    }\n    for (l, r)\
    \ in zip(left, right) {\n        if l != r {\n            return false\n     \
    \   }\n    }\n    return true\n}\n            \nassert(next_smallest(lst: [1,\
    \ 2, 3, 4, 5]) == 2)\nassert(next_smallest(lst: [5, 1, 4, 3, 2]) == 2)\nassert(next_smallest(lst:\
    \ [] as [Int]) == nil)\nassert(next_smallest(lst: [1, 1]) == nil)\nassert(next_smallest(lst:\
    \ [1, 1, 1, 1, 0]) == 1)\nassert(next_smallest(lst: [1, 1]) == nil)\nassert(next_smallest(lst:\
    \ [-35, 34, 12, -45]) == -35)"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660013380
- exit_code: -4
  program: "\n/// You are given an array of integers.\n/// Write a function next_smallest()\
    \ that returns the 2nd smallest element of the array.\n/// Return nil if there\
    \ is no such element.\n/// >>> next_smallest(lst: [1, 2, 3, 4, 5])\n/// 2\n///\
    \ >>> next_smallest(lst: [5, 1, 4, 3, 2])\n/// 2\n/// >>> next_smallest(lst: []\
    \ as [Int])\n/// nil\n/// >>> next_smallest(lst: [1, 1])\n/// nil\nfunc next_smallest(lst:\
    \ [Int]) -> Int? {\n    \n    if lst.count < 2 {\n        return nil\n    }\n\
    \    \n    var min1 = lst[0]\n    var min2 = lst[1]\n    \n    for i in 2 ..<\
    \ lst.count {\n        if lst[i] < min1 {\n            min2 = min1\n         \
    \   min1 = lst[i]\n        } else if lst[i] < min2 {\n            min2 = lst[i]\n\
    \        }\n    }\n    \n    return min2\n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(next_smallest(lst: [1, 2, 3, 4, 5]) == 2)\nassert(next_smallest(lst: [5,\
    \ 1, 4, 3, 2]) == 2)\nassert(next_smallest(lst: [] as [Int]) == nil)\nassert(next_smallest(lst:\
    \ [1, 1]) == nil)\nassert(next_smallest(lst: [1, 1, 1, 1, 0]) == 1)\nassert(next_smallest(lst:\
    \ [1, 1]) == nil)\nassert(next_smallest(lst: [-35, 34, 12, -45]) == -35)"
  status: Exception
  stderr: 'tmp9r2r33sj/tmp9r2r33sj.swift:48: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b5be8302c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b5be7ff9b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b5be7ff9988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b5be7ff87b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmp9r2r33sj                        0x00005584a8e077c5 <unavailable> + 6085

    5    libc.so.6                          0x00002b5be84ee460 __libc_start_main +
    245

    6    tmp9r2r33sj                        0x00005584a8e071a9 <unavailable> + 4521

    '
  stdout: ''
  timestamp: 1660013380
- exit_code: 1
  program: "\n/// You are given an array of integers.\n/// Write a function next_smallest()\
    \ that returns the 2nd smallest element of the array.\n/// Return nil if there\
    \ is no such element.\n/// >>> next_smallest(lst: [1, 2, 3, 4, 5])\n/// 2\n///\
    \ >>> next_smallest(lst: [5, 1, 4, 3, 2])\n/// 2\n/// >>> next_smallest(lst: []\
    \ as [Int])\n/// nil\n/// >>> next_smallest(lst: [1, 1])\n/// nil\nfunc next_smallest(lst:\
    \ [Int]) -> Int? {\n    return lst.sorted()[safe: 1]\n}\n\n\nfunc ==(left: [(Int,\
    \ Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n\
    \        return false\n    }\n    for (l, r) in zip(left, right) {\n        if\
    \ l != r {\n            return false\n        }\n    }\n    return true\n}\n \
    \           \nassert(next_smallest(lst: [1, 2, 3, 4, 5]) == 2)\nassert(next_smallest(lst:\
    \ [5, 1, 4, 3, 2]) == 2)\nassert(next_smallest(lst: [] as [Int]) == nil)\nassert(next_smallest(lst:\
    \ [1, 1]) == nil)\nassert(next_smallest(lst: [1, 1, 1, 1, 0]) == 1)\nassert(next_smallest(lst:\
    \ [1, 1]) == nil)\nassert(next_smallest(lst: [-35, 34, 12, -45]) == -35)"
  status: SyntaxError
  stderr: "/tmp/tmp4gcy14ib.swift:14:24: error: extraneous argument label 'safe:'\
    \ in subscript\n    return lst.sorted()[safe: 1]\n                       ^~~~~~~\n\
    \                        \n"
  stdout: ''
  timestamp: 1660013379
- exit_code: 0
  program: "\n/// You are given an array of integers.\n/// Write a function next_smallest()\
    \ that returns the 2nd smallest element of the array.\n/// Return nil if there\
    \ is no such element.\n/// >>> next_smallest(lst: [1, 2, 3, 4, 5])\n/// 2\n///\
    \ >>> next_smallest(lst: [5, 1, 4, 3, 2])\n/// 2\n/// >>> next_smallest(lst: []\
    \ as [Int])\n/// nil\n/// >>> next_smallest(lst: [1, 1])\n/// nil\nfunc next_smallest(lst:\
    \ [Int]) -> Int? {\n    guard lst.count > 1 else { return nil }\n    let sortedList\
    \ = lst.sorted()\n    var set: Set<Int> = []\n    var secondSmallest: Int?\n \
    \   for num in sortedList {\n        if !set.contains(num) {\n            set.insert(num)\n\
    \            if set.count == 2 {\n                secondSmallest = num\n     \
    \           break\n            }\n        }\n    }\n    return secondSmallest\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(next_smallest(lst: [1, 2, 3, 4, 5]) == 2)\nassert(next_smallest(lst:\
    \ [5, 1, 4, 3, 2]) == 2)\nassert(next_smallest(lst: [] as [Int]) == nil)\nassert(next_smallest(lst:\
    \ [1, 1]) == nil)\nassert(next_smallest(lst: [1, 1, 1, 1, 0]) == 1)\nassert(next_smallest(lst:\
    \ [1, 1]) == nil)\nassert(next_smallest(lst: [-35, 34, 12, -45]) == -35)"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660013380
- exit_code: -4
  program: "\n/// You are given an array of integers.\n/// Write a function next_smallest()\
    \ that returns the 2nd smallest element of the array.\n/// Return nil if there\
    \ is no such element.\n/// >>> next_smallest(lst: [1, 2, 3, 4, 5])\n/// 2\n///\
    \ >>> next_smallest(lst: [5, 1, 4, 3, 2])\n/// 2\n/// >>> next_smallest(lst: []\
    \ as [Int])\n/// nil\n/// >>> next_smallest(lst: [1, 1])\n/// nil\nfunc next_smallest(lst:\
    \ [Int]) -> Int? {\n    if lst.count < 2 {\n        return nil\n    }\n    return\
    \ lst.sorted()[1]\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) ->\
    \ Bool {\n    if left.count != right.count {\n        return false\n    }\n  \
    \  for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(next_smallest(lst:\
    \ [1, 2, 3, 4, 5]) == 2)\nassert(next_smallest(lst: [5, 1, 4, 3, 2]) == 2)\nassert(next_smallest(lst:\
    \ [] as [Int]) == nil)\nassert(next_smallest(lst: [1, 1]) == nil)\nassert(next_smallest(lst:\
    \ [1, 1, 1, 1, 0]) == 1)\nassert(next_smallest(lst: [1, 1]) == nil)\nassert(next_smallest(lst:\
    \ [-35, 34, 12, -45]) == -35)"
  status: Exception
  stderr: 'tmp9wqguxap/tmp9wqguxap.swift:36: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b6c3e910c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b6c3e607b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b6c3e607988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b6c3e6067b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmp9wqguxap                        0x0000562ed27688ba <unavailable> + 6330

    5    libc.so.6                          0x00002b6c3eafc460 __libc_start_main +
    245

    6    tmp9wqguxap                        0x0000562ed27680b9 <unavailable> + 4281

    '
  stdout: ''
  timestamp: 1660013380
- exit_code: 0
  program: "\n/// You are given an array of integers.\n/// Write a function next_smallest()\
    \ that returns the 2nd smallest element of the array.\n/// Return nil if there\
    \ is no such element.\n/// >>> next_smallest(lst: [1, 2, 3, 4, 5])\n/// 2\n///\
    \ >>> next_smallest(lst: [5, 1, 4, 3, 2])\n/// 2\n/// >>> next_smallest(lst: []\
    \ as [Int])\n/// nil\n/// >>> next_smallest(lst: [1, 1])\n/// nil\nfunc next_smallest(lst:\
    \ [Int]) -> Int? {\n    guard !lst.isEmpty else { return nil }\n    guard lst.count\
    \ > 1 else { return nil }\n    let result = lst.sorted()\n    for index in 1...result.count-1\
    \ {\n        if result[index] != result[index-1] {\n            return result[index]\n\
    \        }\n    }\n    return nil\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int,\
    \ Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n\
    \    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n          \
    \  return false\n        }\n    }\n    return true\n}\n            \nassert(next_smallest(lst:\
    \ [1, 2, 3, 4, 5]) == 2)\nassert(next_smallest(lst: [5, 1, 4, 3, 2]) == 2)\nassert(next_smallest(lst:\
    \ [] as [Int]) == nil)\nassert(next_smallest(lst: [1, 1]) == nil)\nassert(next_smallest(lst:\
    \ [1, 1, 1, 1, 0]) == 1)\nassert(next_smallest(lst: [1, 1]) == nil)\nassert(next_smallest(lst:\
    \ [-35, 34, 12, -45]) == -35)"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660013380
- exit_code: -4
  program: "\n/// You are given an array of integers.\n/// Write a function next_smallest()\
    \ that returns the 2nd smallest element of the array.\n/// Return nil if there\
    \ is no such element.\n/// >>> next_smallest(lst: [1, 2, 3, 4, 5])\n/// 2\n///\
    \ >>> next_smallest(lst: [5, 1, 4, 3, 2])\n/// 2\n/// >>> next_smallest(lst: []\
    \ as [Int])\n/// nil\n/// >>> next_smallest(lst: [1, 1])\n/// nil\nfunc next_smallest(lst:\
    \ [Int]) -> Int? {\n    var secondMin = 0\n    var min = 0\n    if lst.count <=\
    \ 1 {\n        return nil\n    }\n    if lst[0] > lst[1] {\n        min = lst[1]\n\
    \        secondMin = lst[0]\n    } else {\n        min = lst[0]\n        secondMin\
    \ = lst[1]\n    }\n    for i in 2..<lst.count {\n        if lst[i] < min {\n \
    \           secondMin = min\n            min = lst[i]\n        } else if lst[i]\
    \ < secondMin {\n            secondMin = lst[i]\n        }\n    }\n    return\
    \ secondMin\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n\
    \    if left.count != right.count {\n        return false\n    }\n    for (l,\
    \ r) in zip(left, right) {\n        if l != r {\n            return false\n  \
    \      }\n    }\n    return true\n}\n            \nassert(next_smallest(lst: [1,\
    \ 2, 3, 4, 5]) == 2)\nassert(next_smallest(lst: [5, 1, 4, 3, 2]) == 2)\nassert(next_smallest(lst:\
    \ [] as [Int]) == nil)\nassert(next_smallest(lst: [1, 1]) == nil)\nassert(next_smallest(lst:\
    \ [1, 1, 1, 1, 0]) == 1)\nassert(next_smallest(lst: [1, 1]) == nil)\nassert(next_smallest(lst:\
    \ [-35, 34, 12, -45]) == -35)"
  status: Exception
  stderr: 'tmph0wn9c2i/tmph0wn9c2i.swift:53: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b9909993c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b990968ab6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b990968a988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b99096897b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmph0wn9c2i                        0x00005608e12059aa <unavailable> + 6570

    5    libc.so.6                          0x00002b9909b7f460 __libc_start_main +
    245

    6    tmph0wn9c2i                        0x00005608e12051a9 <unavailable> + 4521

    '
  stdout: ''
  timestamp: 1660013380
- exit_code: 0
  program: "\n/// You are given an array of integers.\n/// Write a function next_smallest()\
    \ that returns the 2nd smallest element of the array.\n/// Return nil if there\
    \ is no such element.\n/// >>> next_smallest(lst: [1, 2, 3, 4, 5])\n/// 2\n///\
    \ >>> next_smallest(lst: [5, 1, 4, 3, 2])\n/// 2\n/// >>> next_smallest(lst: []\
    \ as [Int])\n/// nil\n/// >>> next_smallest(lst: [1, 1])\n/// nil\nfunc next_smallest(lst:\
    \ [Int]) -> Int? {\n    if lst.count < 2 {\n        return nil\n    }\n    var\
    \ sortedList = lst.sorted()\n    for i in 0..<sortedList.count - 1 {\n       \
    \ if sortedList[i] < sortedList[i + 1] {\n            return sortedList[i + 1]\n\
    \        }\n    }\n    return nil\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int,\
    \ Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n\
    \    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n          \
    \  return false\n        }\n    }\n    return true\n}\n            \nassert(next_smallest(lst:\
    \ [1, 2, 3, 4, 5]) == 2)\nassert(next_smallest(lst: [5, 1, 4, 3, 2]) == 2)\nassert(next_smallest(lst:\
    \ [] as [Int]) == nil)\nassert(next_smallest(lst: [1, 1]) == nil)\nassert(next_smallest(lst:\
    \ [1, 1, 1, 1, 0]) == 1)\nassert(next_smallest(lst: [1, 1]) == nil)\nassert(next_smallest(lst:\
    \ [-35, 34, 12, -45]) == -35)"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660013380
- exit_code: 0
  program: "\n/// You are given an array of integers.\n/// Write a function next_smallest()\
    \ that returns the 2nd smallest element of the array.\n/// Return nil if there\
    \ is no such element.\n/// >>> next_smallest(lst: [1, 2, 3, 4, 5])\n/// 2\n///\
    \ >>> next_smallest(lst: [5, 1, 4, 3, 2])\n/// 2\n/// >>> next_smallest(lst: []\
    \ as [Int])\n/// nil\n/// >>> next_smallest(lst: [1, 1])\n/// nil\nfunc next_smallest(lst:\
    \ [Int]) -> Int? {\n    let sorted = lst.sorted()\n    if sorted.count < 2 {\n\
    \        return nil\n    }\n    if sorted[0] == sorted[1] {\n        return nil\n\
    \    }\n    return sorted[1]\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int,\
    \ Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n\
    \    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n          \
    \  return false\n        }\n    }\n    return true\n}\n            \nassert(next_smallest(lst:\
    \ [1, 2, 3, 4, 5]) == 2)\nassert(next_smallest(lst: [5, 1, 4, 3, 2]) == 2)\nassert(next_smallest(lst:\
    \ [] as [Int]) == nil)\nassert(next_smallest(lst: [1, 1]) == nil)\nassert(next_smallest(lst:\
    \ [1, 1, 1, 1, 0]) == 1)\nassert(next_smallest(lst: [1, 1]) == nil)\nassert(next_smallest(lst:\
    \ [-35, 34, 12, -45]) == -35)"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660013380
- exit_code: -4
  program: "\n/// You are given an array of integers.\n/// Write a function next_smallest()\
    \ that returns the 2nd smallest element of the array.\n/// Return nil if there\
    \ is no such element.\n/// >>> next_smallest(lst: [1, 2, 3, 4, 5])\n/// 2\n///\
    \ >>> next_smallest(lst: [5, 1, 4, 3, 2])\n/// 2\n/// >>> next_smallest(lst: []\
    \ as [Int])\n/// nil\n/// >>> next_smallest(lst: [1, 1])\n/// nil\nfunc next_smallest(lst:\
    \ [Int]) -> Int? {\n    guard lst.count > 1 else { return nil }\n    let sorted_lst\
    \ = lst.sorted()\n    return sorted_lst[1]\n}\n\n\nfunc ==(left: [(Int, Int)],\
    \ right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n       \
    \ return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r\
    \ {\n            return false\n        }\n    }\n    return true\n}\n        \
    \    \nassert(next_smallest(lst: [1, 2, 3, 4, 5]) == 2)\nassert(next_smallest(lst:\
    \ [5, 1, 4, 3, 2]) == 2)\nassert(next_smallest(lst: [] as [Int]) == nil)\nassert(next_smallest(lst:\
    \ [1, 1]) == nil)\nassert(next_smallest(lst: [1, 1, 1, 1, 0]) == 1)\nassert(next_smallest(lst:\
    \ [1, 1]) == nil)\nassert(next_smallest(lst: [-35, 34, 12, -45]) == -35)"
  status: Exception
  stderr: 'tmpfe1d43c_/tmpfe1d43c_.swift:35: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b83d72a7c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b83d6f9eb6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b83d6f9e988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b83d6f9d7b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpfe1d43c_                        0x00005637ce21a8ba <unavailable> + 6330

    5    libc.so.6                          0x00002b83d7493460 __libc_start_main +
    245

    6    tmpfe1d43c_                        0x00005637ce21a0b9 <unavailable> + 4281

    '
  stdout: ''
  timestamp: 1660013380
- exit_code: -4
  program: "\n/// You are given an array of integers.\n/// Write a function next_smallest()\
    \ that returns the 2nd smallest element of the array.\n/// Return nil if there\
    \ is no such element.\n/// >>> next_smallest(lst: [1, 2, 3, 4, 5])\n/// 2\n///\
    \ >>> next_smallest(lst: [5, 1, 4, 3, 2])\n/// 2\n/// >>> next_smallest(lst: []\
    \ as [Int])\n/// nil\n/// >>> next_smallest(lst: [1, 1])\n/// nil\nfunc next_smallest(lst:\
    \ [Int]) -> Int? {\n    if lst.count < 2 {\n        return nil\n    }\n    var\
    \ smallest: Int = lst[0]\n    var secondSmallest: Int = lst[1]\n    for i in 2..<lst.count\
    \ {\n        if lst[i] < smallest {\n            secondSmallest = smallest\n \
    \           smallest = lst[i]\n        } else if lst[i] < secondSmallest {\n \
    \           secondSmallest = lst[i]\n        }\n    }\n    return secondSmallest\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(next_smallest(lst: [1, 2, 3, 4, 5]) == 2)\nassert(next_smallest(lst:\
    \ [5, 1, 4, 3, 2]) == 2)\nassert(next_smallest(lst: [] as [Int]) == nil)\nassert(next_smallest(lst:\
    \ [1, 1]) == nil)\nassert(next_smallest(lst: [1, 1, 1, 1, 0]) == 1)\nassert(next_smallest(lst:\
    \ [1, 1]) == nil)\nassert(next_smallest(lst: [-35, 34, 12, -45]) == -35)"
  status: Exception
  stderr: 'tmpy4u17avq/tmpy4u17avq.swift:44: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002ab0619adc80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002ab0616a4b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002ab0616a4988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002ab0616a37b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpy4u17avq                        0x000055d13b1157c5 <unavailable> + 6085

    5    libc.so.6                          0x00002ab061b99460 __libc_start_main +
    245

    6    tmpy4u17avq                        0x000055d13b1151a9 <unavailable> + 4521

    '
  stdout: ''
  timestamp: 1660013380
- exit_code: 0
  program: "\n/// You are given an array of integers.\n/// Write a function next_smallest()\
    \ that returns the 2nd smallest element of the array.\n/// Return nil if there\
    \ is no such element.\n/// >>> next_smallest(lst: [1, 2, 3, 4, 5])\n/// 2\n///\
    \ >>> next_smallest(lst: [5, 1, 4, 3, 2])\n/// 2\n/// >>> next_smallest(lst: []\
    \ as [Int])\n/// nil\n/// >>> next_smallest(lst: [1, 1])\n/// nil\nfunc next_smallest(lst:\
    \ [Int]) -> Int? {\n    if lst.count < 2 {\n        return nil\n    }\n    var\
    \ arr = lst\n    arr.sort()\n    for i in 1..<arr.count {\n        if arr[i] !=\
    \ arr[i - 1] {\n            return arr[i]\n        }\n    }\n    return nil\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(next_smallest(lst: [1, 2, 3, 4, 5]) == 2)\nassert(next_smallest(lst:\
    \ [5, 1, 4, 3, 2]) == 2)\nassert(next_smallest(lst: [] as [Int]) == nil)\nassert(next_smallest(lst:\
    \ [1, 1]) == nil)\nassert(next_smallest(lst: [1, 1, 1, 1, 0]) == 1)\nassert(next_smallest(lst:\
    \ [1, 1]) == nil)\nassert(next_smallest(lst: [-35, 34, 12, -45]) == -35)"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660013380
- exit_code: 0
  program: "\n/// You are given an array of integers.\n/// Write a function next_smallest()\
    \ that returns the 2nd smallest element of the array.\n/// Return nil if there\
    \ is no such element.\n/// >>> next_smallest(lst: [1, 2, 3, 4, 5])\n/// 2\n///\
    \ >>> next_smallest(lst: [5, 1, 4, 3, 2])\n/// 2\n/// >>> next_smallest(lst: []\
    \ as [Int])\n/// nil\n/// >>> next_smallest(lst: [1, 1])\n/// nil\nfunc next_smallest(lst:\
    \ [Int]) -> Int? {\n    guard !lst.isEmpty else { return nil }\n    let sorted\
    \ = lst.sorted()\n    for i in 0..<sorted.count - 1 {\n        if sorted[i] !=\
    \ sorted[i + 1] {\n            return sorted[i + 1]\n        }\n    }\n    return\
    \ nil\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n   \
    \ if left.count != right.count {\n        return false\n    }\n    for (l, r)\
    \ in zip(left, right) {\n        if l != r {\n            return false\n     \
    \   }\n    }\n    return true\n}\n            \nassert(next_smallest(lst: [1,\
    \ 2, 3, 4, 5]) == 2)\nassert(next_smallest(lst: [5, 1, 4, 3, 2]) == 2)\nassert(next_smallest(lst:\
    \ [] as [Int]) == nil)\nassert(next_smallest(lst: [1, 1]) == nil)\nassert(next_smallest(lst:\
    \ [1, 1, 1, 1, 0]) == 1)\nassert(next_smallest(lst: [1, 1]) == nil)\nassert(next_smallest(lst:\
    \ [-35, 34, 12, -45]) == -35)"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660013380
- exit_code: -4
  program: "\n/// You are given an array of integers.\n/// Write a function next_smallest()\
    \ that returns the 2nd smallest element of the array.\n/// Return nil if there\
    \ is no such element.\n/// >>> next_smallest(lst: [1, 2, 3, 4, 5])\n/// 2\n///\
    \ >>> next_smallest(lst: [5, 1, 4, 3, 2])\n/// 2\n/// >>> next_smallest(lst: []\
    \ as [Int])\n/// nil\n/// >>> next_smallest(lst: [1, 1])\n/// nil\nfunc next_smallest(lst:\
    \ [Int]) -> Int? {\n    return nil\n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(next_smallest(lst: [1, 2, 3, 4, 5]) == 2)\nassert(next_smallest(lst: [5,\
    \ 1, 4, 3, 2]) == 2)\nassert(next_smallest(lst: [] as [Int]) == nil)\nassert(next_smallest(lst:\
    \ [1, 1]) == nil)\nassert(next_smallest(lst: [1, 1, 1, 1, 0]) == 1)\nassert(next_smallest(lst:\
    \ [1, 1]) == nil)\nassert(next_smallest(lst: [-35, 34, 12, -45]) == -35)"
  status: Exception
  stderr: 'tmp2hp7hj7n/tmp2hp7hj7n.swift:30: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002afccf398c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002afccf08fb6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002afccf08f988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002afccf08e7b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmp2hp7hj7n                        0x0000560c9b7333e1 <unavailable> + 5089

    5    libc.so.6                          0x00002afccf584460 __libc_start_main +
    245

    6    tmp2hp7hj7n                        0x0000560c9b732f69 <unavailable> + 3945

    '
  stdout: ''
  timestamp: 1660013380
- exit_code: -4
  program: "\n/// You are given an array of integers.\n/// Write a function next_smallest()\
    \ that returns the 2nd smallest element of the array.\n/// Return nil if there\
    \ is no such element.\n/// >>> next_smallest(lst: [1, 2, 3, 4, 5])\n/// 2\n///\
    \ >>> next_smallest(lst: [5, 1, 4, 3, 2])\n/// 2\n/// >>> next_smallest(lst: []\
    \ as [Int])\n/// nil\n/// >>> next_smallest(lst: [1, 1])\n/// nil\nfunc next_smallest(lst:\
    \ [Int]) -> Int? {\n    return lst.count > 1 ? lst.sorted()[1] : nil\n}\n\n\n\
    func ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(next_smallest(lst: [1, 2, 3, 4, 5]) == 2)\nassert(next_smallest(lst:\
    \ [5, 1, 4, 3, 2]) == 2)\nassert(next_smallest(lst: [] as [Int]) == nil)\nassert(next_smallest(lst:\
    \ [1, 1]) == nil)\nassert(next_smallest(lst: [1, 1, 1, 1, 0]) == 1)\nassert(next_smallest(lst:\
    \ [1, 1]) == nil)\nassert(next_smallest(lst: [-35, 34, 12, -45]) == -35)"
  status: Exception
  stderr: 'tmpgqmtxq60/tmpgqmtxq60.swift:33: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002ae4803f3c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002ae4800eab6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002ae4800ea988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002ae4800e97b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpgqmtxq60                        0x00005581dc4428ba <unavailable> + 6330

    5    libc.so.6                          0x00002ae4805df460 __libc_start_main +
    245

    6    tmpgqmtxq60                        0x00005581dc4420b9 <unavailable> + 4281

    '
  stdout: ''
  timestamp: 1660013380
- exit_code: -4
  program: "\n/// You are given an array of integers.\n/// Write a function next_smallest()\
    \ that returns the 2nd smallest element of the array.\n/// Return nil if there\
    \ is no such element.\n/// >>> next_smallest(lst: [1, 2, 3, 4, 5])\n/// 2\n///\
    \ >>> next_smallest(lst: [5, 1, 4, 3, 2])\n/// 2\n/// >>> next_smallest(lst: []\
    \ as [Int])\n/// nil\n/// >>> next_smallest(lst: [1, 1])\n/// nil\nfunc next_smallest(lst:\
    \ [Int]) -> Int? {\n    return nil\n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(next_smallest(lst: [1, 2, 3, 4, 5]) == 2)\nassert(next_smallest(lst: [5,\
    \ 1, 4, 3, 2]) == 2)\nassert(next_smallest(lst: [] as [Int]) == nil)\nassert(next_smallest(lst:\
    \ [1, 1]) == nil)\nassert(next_smallest(lst: [1, 1, 1, 1, 0]) == 1)\nassert(next_smallest(lst:\
    \ [1, 1]) == nil)\nassert(next_smallest(lst: [-35, 34, 12, -45]) == -35)"
  status: Exception
  stderr: 'tmp2hp7hj7n/tmp2hp7hj7n.swift:30: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002afccf398c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002afccf08fb6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002afccf08f988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002afccf08e7b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmp2hp7hj7n                        0x0000560c9b7333e1 <unavailable> + 5089

    5    libc.so.6                          0x00002afccf584460 __libc_start_main +
    245

    6    tmp2hp7hj7n                        0x0000560c9b732f69 <unavailable> + 3945

    '
  stdout: ''
  timestamp: 1660013380
- exit_code: -4
  program: "\n/// You are given an array of integers.\n/// Write a function next_smallest()\
    \ that returns the 2nd smallest element of the array.\n/// Return nil if there\
    \ is no such element.\n/// >>> next_smallest(lst: [1, 2, 3, 4, 5])\n/// 2\n///\
    \ >>> next_smallest(lst: [5, 1, 4, 3, 2])\n/// 2\n/// >>> next_smallest(lst: []\
    \ as [Int])\n/// nil\n/// >>> next_smallest(lst: [1, 1])\n/// nil\nfunc next_smallest(lst:\
    \ [Int]) -> Int? {\n    return nil\n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(next_smallest(lst: [1, 2, 3, 4, 5]) == 2)\nassert(next_smallest(lst: [5,\
    \ 1, 4, 3, 2]) == 2)\nassert(next_smallest(lst: [] as [Int]) == nil)\nassert(next_smallest(lst:\
    \ [1, 1]) == nil)\nassert(next_smallest(lst: [1, 1, 1, 1, 0]) == 1)\nassert(next_smallest(lst:\
    \ [1, 1]) == nil)\nassert(next_smallest(lst: [-35, 34, 12, -45]) == -35)"
  status: Exception
  stderr: 'tmp2hp7hj7n/tmp2hp7hj7n.swift:30: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002afccf398c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002afccf08fb6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002afccf08f988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002afccf08e7b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmp2hp7hj7n                        0x0000560c9b7333e1 <unavailable> + 5089

    5    libc.so.6                          0x00002afccf584460 __libc_start_main +
    245

    6    tmp2hp7hj7n                        0x0000560c9b732f69 <unavailable> + 3945

    '
  stdout: ''
  timestamp: 1660013380
- exit_code: 0
  program: "\n/// You are given an array of integers.\n/// Write a function next_smallest()\
    \ that returns the 2nd smallest element of the array.\n/// Return nil if there\
    \ is no such element.\n/// >>> next_smallest(lst: [1, 2, 3, 4, 5])\n/// 2\n///\
    \ >>> next_smallest(lst: [5, 1, 4, 3, 2])\n/// 2\n/// >>> next_smallest(lst: []\
    \ as [Int])\n/// nil\n/// >>> next_smallest(lst: [1, 1])\n/// nil\nfunc next_smallest(lst:\
    \ [Int]) -> Int? {\n    guard lst.count > 1 else { return nil }\n    let sorted\
    \ = lst.sorted()\n    guard sorted[0] != sorted[1] else { return nil }\n    return\
    \ sorted[1]\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n\
    \    if left.count != right.count {\n        return false\n    }\n    for (l,\
    \ r) in zip(left, right) {\n        if l != r {\n            return false\n  \
    \      }\n    }\n    return true\n}\n            \nassert(next_smallest(lst: [1,\
    \ 2, 3, 4, 5]) == 2)\nassert(next_smallest(lst: [5, 1, 4, 3, 2]) == 2)\nassert(next_smallest(lst:\
    \ [] as [Int]) == nil)\nassert(next_smallest(lst: [1, 1]) == nil)\nassert(next_smallest(lst:\
    \ [1, 1, 1, 1, 0]) == 1)\nassert(next_smallest(lst: [1, 1]) == nil)\nassert(next_smallest(lst:\
    \ [-35, 34, 12, -45]) == -35)"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660013380
- exit_code: -4
  program: "\n/// You are given an array of integers.\n/// Write a function next_smallest()\
    \ that returns the 2nd smallest element of the array.\n/// Return nil if there\
    \ is no such element.\n/// >>> next_smallest(lst: [1, 2, 3, 4, 5])\n/// 2\n///\
    \ >>> next_smallest(lst: [5, 1, 4, 3, 2])\n/// 2\n/// >>> next_smallest(lst: []\
    \ as [Int])\n/// nil\n/// >>> next_smallest(lst: [1, 1])\n/// nil\nfunc next_smallest(lst:\
    \ [Int]) -> Int? {\n    guard lst.count > 2 else {\n        return nil\n    }\n\
    \    var smallest = lst[0]\n    var secondSmallest = lst[1]\n    for i in 2..<lst.count\
    \ {\n        if lst[i] < smallest {\n            secondSmallest = smallest\n \
    \           smallest = lst[i]\n        } else if lst[i] < secondSmallest {\n \
    \           secondSmallest = lst[i]\n        }\n    }\n    return secondSmallest\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(next_smallest(lst: [1, 2, 3, 4, 5]) == 2)\nassert(next_smallest(lst:\
    \ [5, 1, 4, 3, 2]) == 2)\nassert(next_smallest(lst: [] as [Int]) == nil)\nassert(next_smallest(lst:\
    \ [1, 1]) == nil)\nassert(next_smallest(lst: [1, 1, 1, 1, 0]) == 1)\nassert(next_smallest(lst:\
    \ [1, 1]) == nil)\nassert(next_smallest(lst: [-35, 34, 12, -45]) == -35)"
  status: Exception
  stderr: 'tmp1tu3vwsw/tmp1tu3vwsw.swift:44: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b717884fc80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b7178546b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b7178546988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b71785457b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmp1tu3vwsw                        0x00005622848ff7c5 <unavailable> + 6085

    5    libc.so.6                          0x00002b7178a3b460 __libc_start_main +
    245

    6    tmp1tu3vwsw                        0x00005622848ff1a9 <unavailable> + 4521

    '
  stdout: ''
  timestamp: 1660013380
- exit_code: 0
  program: "\n/// You are given an array of integers.\n/// Write a function next_smallest()\
    \ that returns the 2nd smallest element of the array.\n/// Return nil if there\
    \ is no such element.\n/// >>> next_smallest(lst: [1, 2, 3, 4, 5])\n/// 2\n///\
    \ >>> next_smallest(lst: [5, 1, 4, 3, 2])\n/// 2\n/// >>> next_smallest(lst: []\
    \ as [Int])\n/// nil\n/// >>> next_smallest(lst: [1, 1])\n/// nil\nfunc next_smallest(lst:\
    \ [Int]) -> Int? {\n    var lst = lst\n    if lst.count < 2 {\n        return\
    \ nil\n    }\n    lst.sort()\n    if lst[0] == lst[1] {\n        return nil\n\
    \    }\n    return lst[1]\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(next_smallest(lst:\
    \ [1, 2, 3, 4, 5]) == 2)\nassert(next_smallest(lst: [5, 1, 4, 3, 2]) == 2)\nassert(next_smallest(lst:\
    \ [] as [Int]) == nil)\nassert(next_smallest(lst: [1, 1]) == nil)\nassert(next_smallest(lst:\
    \ [1, 1, 1, 1, 0]) == 1)\nassert(next_smallest(lst: [1, 1]) == nil)\nassert(next_smallest(lst:\
    \ [-35, 34, 12, -45]) == -35)"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660013380
- exit_code: -4
  program: "\n/// You are given an array of integers.\n/// Write a function next_smallest()\
    \ that returns the 2nd smallest element of the array.\n/// Return nil if there\
    \ is no such element.\n/// >>> next_smallest(lst: [1, 2, 3, 4, 5])\n/// 2\n///\
    \ >>> next_smallest(lst: [5, 1, 4, 3, 2])\n/// 2\n/// >>> next_smallest(lst: []\
    \ as [Int])\n/// nil\n/// >>> next_smallest(lst: [1, 1])\n/// nil\nfunc next_smallest(lst:\
    \ [Int]) -> Int? {\n    if lst.count < 2 {\n        return nil\n    }\n    return\
    \ lst.sorted()[1]\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) ->\
    \ Bool {\n    if left.count != right.count {\n        return false\n    }\n  \
    \  for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(next_smallest(lst:\
    \ [1, 2, 3, 4, 5]) == 2)\nassert(next_smallest(lst: [5, 1, 4, 3, 2]) == 2)\nassert(next_smallest(lst:\
    \ [] as [Int]) == nil)\nassert(next_smallest(lst: [1, 1]) == nil)\nassert(next_smallest(lst:\
    \ [1, 1, 1, 1, 0]) == 1)\nassert(next_smallest(lst: [1, 1]) == nil)\nassert(next_smallest(lst:\
    \ [-35, 34, 12, -45]) == -35)"
  status: Exception
  stderr: 'tmp9wqguxap/tmp9wqguxap.swift:36: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b6c3e910c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b6c3e607b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b6c3e607988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b6c3e6067b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmp9wqguxap                        0x0000562ed27688ba <unavailable> + 6330

    5    libc.so.6                          0x00002b6c3eafc460 __libc_start_main +
    245

    6    tmp9wqguxap                        0x0000562ed27680b9 <unavailable> + 4281

    '
  stdout: ''
  timestamp: 1660013380
- exit_code: -4
  program: "\n/// You are given an array of integers.\n/// Write a function next_smallest()\
    \ that returns the 2nd smallest element of the array.\n/// Return nil if there\
    \ is no such element.\n/// >>> next_smallest(lst: [1, 2, 3, 4, 5])\n/// 2\n///\
    \ >>> next_smallest(lst: [5, 1, 4, 3, 2])\n/// 2\n/// >>> next_smallest(lst: []\
    \ as [Int])\n/// nil\n/// >>> next_smallest(lst: [1, 1])\n/// nil\nfunc next_smallest(lst:\
    \ [Int]) -> Int? {\n    guard lst.count > 1 else { return nil }\n    var smallest,\
    \ secondSmallest: Int?\n    for i in lst {\n        if smallest == nil {\n   \
    \         smallest = i\n        } else if i < smallest! {\n            secondSmallest\
    \ = smallest\n            smallest = i\n        } else if secondSmallest == nil\
    \ {\n            secondSmallest = i\n        } else if i < secondSmallest! {\n\
    \            secondSmallest = i\n        }\n    }\n    return secondSmallest\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(next_smallest(lst: [1, 2, 3, 4, 5]) == 2)\nassert(next_smallest(lst:\
    \ [5, 1, 4, 3, 2]) == 2)\nassert(next_smallest(lst: [] as [Int]) == nil)\nassert(next_smallest(lst:\
    \ [1, 1]) == nil)\nassert(next_smallest(lst: [1, 1, 1, 1, 0]) == 1)\nassert(next_smallest(lst:\
    \ [1, 1]) == nil)\nassert(next_smallest(lst: [-35, 34, 12, -45]) == -35)"
  status: Exception
  stderr: 'tmpxogaz_5z/tmpxogaz_5z.swift:47: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b476339dc80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b4763094b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b4763094988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b47630937b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpxogaz_5z                        0x0000560440d339ca <unavailable> + 6602

    5    libc.so.6                          0x00002b4763589460 __libc_start_main +
    245

    6    tmpxogaz_5z                        0x0000560440d331c9 <unavailable> + 4553

    '
  stdout: ''
  timestamp: 1660013380
- exit_code: 0
  program: "\n/// You are given an array of integers.\n/// Write a function next_smallest()\
    \ that returns the 2nd smallest element of the array.\n/// Return nil if there\
    \ is no such element.\n/// >>> next_smallest(lst: [1, 2, 3, 4, 5])\n/// 2\n///\
    \ >>> next_smallest(lst: [5, 1, 4, 3, 2])\n/// 2\n/// >>> next_smallest(lst: []\
    \ as [Int])\n/// nil\n/// >>> next_smallest(lst: [1, 1])\n/// nil\nfunc next_smallest(lst:\
    \ [Int]) -> Int? {\n    guard lst.count > 1 else { return nil }\n    var sortedLst\
    \ = lst.sorted()\n    for i in 0..<sortedLst.count - 1 {\n        if sortedLst[i]\
    \ != sortedLst[i + 1] {\n            return sortedLst[i + 1]\n        }\n    }\n\
    \    return nil\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool\
    \ {\n    if left.count != right.count {\n        return false\n    }\n    for\
    \ (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(next_smallest(lst:\
    \ [1, 2, 3, 4, 5]) == 2)\nassert(next_smallest(lst: [5, 1, 4, 3, 2]) == 2)\nassert(next_smallest(lst:\
    \ [] as [Int]) == nil)\nassert(next_smallest(lst: [1, 1]) == nil)\nassert(next_smallest(lst:\
    \ [1, 1, 1, 1, 0]) == 1)\nassert(next_smallest(lst: [1, 1]) == nil)\nassert(next_smallest(lst:\
    \ [-35, 34, 12, -45]) == -35)"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660013380
- exit_code: 0
  program: "\n/// You are given an array of integers.\n/// Write a function next_smallest()\
    \ that returns the 2nd smallest element of the array.\n/// Return nil if there\
    \ is no such element.\n/// >>> next_smallest(lst: [1, 2, 3, 4, 5])\n/// 2\n///\
    \ >>> next_smallest(lst: [5, 1, 4, 3, 2])\n/// 2\n/// >>> next_smallest(lst: []\
    \ as [Int])\n/// nil\n/// >>> next_smallest(lst: [1, 1])\n/// nil\nfunc next_smallest(lst:\
    \ [Int]) -> Int? {\n    guard lst.count > 1 else { return nil }\n    var sorted\
    \ = lst.sorted()\n    for i in 0..<sorted.count-1 {\n        if sorted[i] != sorted[i+1]\
    \ {\n            return sorted[i+1]\n        }\n    }\n    return nil\n}\n\n\n\
    func ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(next_smallest(lst: [1, 2, 3, 4, 5]) == 2)\nassert(next_smallest(lst:\
    \ [5, 1, 4, 3, 2]) == 2)\nassert(next_smallest(lst: [] as [Int]) == nil)\nassert(next_smallest(lst:\
    \ [1, 1]) == nil)\nassert(next_smallest(lst: [1, 1, 1, 1, 0]) == 1)\nassert(next_smallest(lst:\
    \ [1, 1]) == nil)\nassert(next_smallest(lst: [-35, 34, 12, -45]) == -35)"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660013380
- exit_code: 0
  program: "\n/// You are given an array of integers.\n/// Write a function next_smallest()\
    \ that returns the 2nd smallest element of the array.\n/// Return nil if there\
    \ is no such element.\n/// >>> next_smallest(lst: [1, 2, 3, 4, 5])\n/// 2\n///\
    \ >>> next_smallest(lst: [5, 1, 4, 3, 2])\n/// 2\n/// >>> next_smallest(lst: []\
    \ as [Int])\n/// nil\n/// >>> next_smallest(lst: [1, 1])\n/// nil\nfunc next_smallest(lst:\
    \ [Int]) -> Int? {\n    guard lst.count > 2 else {\n        return nil\n    }\n\
    \    let sorted = lst.sorted()\n    if sorted[0] != sorted[1] {\n        return\
    \ sorted[1]\n    }\n    for i in 2..<sorted.count {\n        if sorted[i] != sorted[i\
    \ - 1] {\n            return sorted[i]\n        }\n    }\n    return nil\n}\n\n\
    \nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(next_smallest(lst: [1, 2, 3, 4, 5]) == 2)\nassert(next_smallest(lst:\
    \ [5, 1, 4, 3, 2]) == 2)\nassert(next_smallest(lst: [] as [Int]) == nil)\nassert(next_smallest(lst:\
    \ [1, 1]) == nil)\nassert(next_smallest(lst: [1, 1, 1, 1, 0]) == 1)\nassert(next_smallest(lst:\
    \ [1, 1]) == nil)\nassert(next_smallest(lst: [-35, 34, 12, -45]) == -35)"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660013380
- exit_code: 0
  program: "\n/// You are given an array of integers.\n/// Write a function next_smallest()\
    \ that returns the 2nd smallest element of the array.\n/// Return nil if there\
    \ is no such element.\n/// >>> next_smallest(lst: [1, 2, 3, 4, 5])\n/// 2\n///\
    \ >>> next_smallest(lst: [5, 1, 4, 3, 2])\n/// 2\n/// >>> next_smallest(lst: []\
    \ as [Int])\n/// nil\n/// >>> next_smallest(lst: [1, 1])\n/// nil\nfunc next_smallest(lst:\
    \ [Int]) -> Int? {\n    var list = lst\n    if (list.count < 2) {\n        return\
    \ nil\n    }\n    if (list.count == 2) {\n        return (list[0] == list[1])\
    \ ? nil : list[1]\n    }\n    list.sort()\n    if (list[0] == list[1]) {\n   \
    \     return (list[0] == list[2]) ? nil : list[2]\n    }\n    return list[1]\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(next_smallest(lst: [1, 2, 3, 4, 5]) == 2)\nassert(next_smallest(lst:\
    \ [5, 1, 4, 3, 2]) == 2)\nassert(next_smallest(lst: [] as [Int]) == nil)\nassert(next_smallest(lst:\
    \ [1, 1]) == nil)\nassert(next_smallest(lst: [1, 1, 1, 1, 0]) == 1)\nassert(next_smallest(lst:\
    \ [1, 1]) == nil)\nassert(next_smallest(lst: [-35, 34, 12, -45]) == -35)"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660013380
- exit_code: -4
  program: "\n/// You are given an array of integers.\n/// Write a function next_smallest()\
    \ that returns the 2nd smallest element of the array.\n/// Return nil if there\
    \ is no such element.\n/// >>> next_smallest(lst: [1, 2, 3, 4, 5])\n/// 2\n///\
    \ >>> next_smallest(lst: [5, 1, 4, 3, 2])\n/// 2\n/// >>> next_smallest(lst: []\
    \ as [Int])\n/// nil\n/// >>> next_smallest(lst: [1, 1])\n/// nil\nfunc next_smallest(lst:\
    \ [Int]) -> Int? {\n    if lst.count < 2 {\n        return nil\n    }\n    var\
    \ sorted = lst.sorted()\n    var last: Int? = nil\n    for i in sorted {\n   \
    \     if i != last {\n            return i\n        }\n        last = i\n    }\n\
    \    return nil\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool\
    \ {\n    if left.count != right.count {\n        return false\n    }\n    for\
    \ (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(next_smallest(lst:\
    \ [1, 2, 3, 4, 5]) == 2)\nassert(next_smallest(lst: [5, 1, 4, 3, 2]) == 2)\nassert(next_smallest(lst:\
    \ [] as [Int]) == nil)\nassert(next_smallest(lst: [1, 1]) == nil)\nassert(next_smallest(lst:\
    \ [1, 1, 1, 1, 0]) == 1)\nassert(next_smallest(lst: [1, 1]) == nil)\nassert(next_smallest(lst:\
    \ [-35, 34, 12, -45]) == -35)"
  status: Exception
  stderr: 'tmpodo5wlgt/tmpodo5wlgt.swift:41: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002af1c5193c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002af1c4e8ab6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002af1c4e8a988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002af1c4e897b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpodo5wlgt                        0x00005611c3d0a651 <unavailable> + 5713

    5    libc.so.6                          0x00002af1c537f460 __libc_start_main +
    245

    6    tmpodo5wlgt                        0x00005611c3d0a1d9 <unavailable> + 4569

    '
  stdout: ''
  timestamp: 1660013380
- exit_code: -4
  program: "\n/// You are given an array of integers.\n/// Write a function next_smallest()\
    \ that returns the 2nd smallest element of the array.\n/// Return nil if there\
    \ is no such element.\n/// >>> next_smallest(lst: [1, 2, 3, 4, 5])\n/// 2\n///\
    \ >>> next_smallest(lst: [5, 1, 4, 3, 2])\n/// 2\n/// >>> next_smallest(lst: []\
    \ as [Int])\n/// nil\n/// >>> next_smallest(lst: [1, 1])\n/// nil\nfunc next_smallest(lst:\
    \ [Int]) -> Int? {\n    return nil\n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(next_smallest(lst: [1, 2, 3, 4, 5]) == 2)\nassert(next_smallest(lst: [5,\
    \ 1, 4, 3, 2]) == 2)\nassert(next_smallest(lst: [] as [Int]) == nil)\nassert(next_smallest(lst:\
    \ [1, 1]) == nil)\nassert(next_smallest(lst: [1, 1, 1, 1, 0]) == 1)\nassert(next_smallest(lst:\
    \ [1, 1]) == nil)\nassert(next_smallest(lst: [-35, 34, 12, -45]) == -35)"
  status: Exception
  stderr: 'tmp2hp7hj7n/tmp2hp7hj7n.swift:30: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002afccf398c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002afccf08fb6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002afccf08f988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002afccf08e7b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmp2hp7hj7n                        0x0000560c9b7333e1 <unavailable> + 5089

    5    libc.so.6                          0x00002afccf584460 __libc_start_main +
    245

    6    tmp2hp7hj7n                        0x0000560c9b732f69 <unavailable> + 3945

    '
  stdout: ''
  timestamp: 1660013380
- exit_code: -4
  program: "\n/// You are given an array of integers.\n/// Write a function next_smallest()\
    \ that returns the 2nd smallest element of the array.\n/// Return nil if there\
    \ is no such element.\n/// >>> next_smallest(lst: [1, 2, 3, 4, 5])\n/// 2\n///\
    \ >>> next_smallest(lst: [5, 1, 4, 3, 2])\n/// 2\n/// >>> next_smallest(lst: []\
    \ as [Int])\n/// nil\n/// >>> next_smallest(lst: [1, 1])\n/// nil\nfunc next_smallest(lst:\
    \ [Int]) -> Int? {\n    guard lst.count > 1 else { return nil }\n    return lst.sorted().lazy.dropFirst().min()\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(next_smallest(lst: [1, 2, 3, 4, 5]) == 2)\nassert(next_smallest(lst:\
    \ [5, 1, 4, 3, 2]) == 2)\nassert(next_smallest(lst: [] as [Int]) == nil)\nassert(next_smallest(lst:\
    \ [1, 1]) == nil)\nassert(next_smallest(lst: [1, 1, 1, 1, 0]) == 1)\nassert(next_smallest(lst:\
    \ [1, 1]) == nil)\nassert(next_smallest(lst: [-35, 34, 12, -45]) == -35)"
  status: Exception
  stderr: 'tmpo9xjn713/tmpo9xjn713.swift:34: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002acd8814dc80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002acd87e44b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002acd87e44988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002acd87e437b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpo9xjn713                        0x00005609535e8afa <unavailable> + 6906

    5    libc.so.6                          0x00002acd88339460 __libc_start_main +
    245

    6    tmpo9xjn713                        0x00005609535e82f9 <unavailable> + 4857

    '
  stdout: ''
  timestamp: 1660013380
- exit_code: 0
  program: "\n/// You are given an array of integers.\n/// Write a function next_smallest()\
    \ that returns the 2nd smallest element of the array.\n/// Return nil if there\
    \ is no such element.\n/// >>> next_smallest(lst: [1, 2, 3, 4, 5])\n/// 2\n///\
    \ >>> next_smallest(lst: [5, 1, 4, 3, 2])\n/// 2\n/// >>> next_smallest(lst: []\
    \ as [Int])\n/// nil\n/// >>> next_smallest(lst: [1, 1])\n/// nil\nfunc next_smallest(lst:\
    \ [Int]) -> Int? {\n    guard lst.count > 2 else {\n        return nil\n    }\n\
    \    let sorted = lst.sorted()\n    return sorted[1]\n}\n\n\nfunc ==(left: [(Int,\
    \ Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n\
    \        return false\n    }\n    for (l, r) in zip(left, right) {\n        if\
    \ l != r {\n            return false\n        }\n    }\n    return true\n}\n \
    \           \nassert(next_smallest(lst: [1, 2, 3, 4, 5]) == 2)\nassert(next_smallest(lst:\
    \ [5, 1, 4, 3, 2]) == 2)\nassert(next_smallest(lst: [] as [Int]) == nil)\nassert(next_smallest(lst:\
    \ [1, 1]) == nil)\nassert(next_smallest(lst: [1, 1, 1, 1, 0]) == 1)\nassert(next_smallest(lst:\
    \ [1, 1]) == nil)\nassert(next_smallest(lst: [-35, 34, 12, -45]) == -35)"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660013380
- exit_code: -4
  program: "\n/// You are given an array of integers.\n/// Write a function next_smallest()\
    \ that returns the 2nd smallest element of the array.\n/// Return nil if there\
    \ is no such element.\n/// >>> next_smallest(lst: [1, 2, 3, 4, 5])\n/// 2\n///\
    \ >>> next_smallest(lst: [5, 1, 4, 3, 2])\n/// 2\n/// >>> next_smallest(lst: []\
    \ as [Int])\n/// nil\n/// >>> next_smallest(lst: [1, 1])\n/// nil\nfunc next_smallest(lst:\
    \ [Int]) -> Int? {\n    if lst.count < 2 {\n        return nil\n    }\n    let\
    \ sortedLst = lst.sorted()\n    return sortedLst[1]\n}\n\n\nfunc ==(left: [(Int,\
    \ Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n\
    \        return false\n    }\n    for (l, r) in zip(left, right) {\n        if\
    \ l != r {\n            return false\n        }\n    }\n    return true\n}\n \
    \           \nassert(next_smallest(lst: [1, 2, 3, 4, 5]) == 2)\nassert(next_smallest(lst:\
    \ [5, 1, 4, 3, 2]) == 2)\nassert(next_smallest(lst: [] as [Int]) == nil)\nassert(next_smallest(lst:\
    \ [1, 1]) == nil)\nassert(next_smallest(lst: [1, 1, 1, 1, 0]) == 1)\nassert(next_smallest(lst:\
    \ [1, 1]) == nil)\nassert(next_smallest(lst: [-35, 34, 12, -45]) == -35)"
  status: Exception
  stderr: 'tmpyrq4rzaw/tmpyrq4rzaw.swift:37: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b00434afc80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b00431a6b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b00431a6988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b00431a57b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpyrq4rzaw                        0x000055ac3ca048ba <unavailable> + 6330

    5    libc.so.6                          0x00002b004369b460 __libc_start_main +
    245

    6    tmpyrq4rzaw                        0x000055ac3ca040b9 <unavailable> + 4281

    '
  stdout: ''
  timestamp: 1660013380
- exit_code: 0
  program: "\n/// You are given an array of integers.\n/// Write a function next_smallest()\
    \ that returns the 2nd smallest element of the array.\n/// Return nil if there\
    \ is no such element.\n/// >>> next_smallest(lst: [1, 2, 3, 4, 5])\n/// 2\n///\
    \ >>> next_smallest(lst: [5, 1, 4, 3, 2])\n/// 2\n/// >>> next_smallest(lst: []\
    \ as [Int])\n/// nil\n/// >>> next_smallest(lst: [1, 1])\n/// nil\nfunc next_smallest(lst:\
    \ [Int]) -> Int? {\n    var set = Set<Int>()\n    lst.forEach { set.insert($0)\
    \ }\n    let lst = Array(set).sorted()\n    if lst.count > 1 {\n        return\
    \ lst[1]\n    }\n    return nil\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int,\
    \ Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n\
    \    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n          \
    \  return false\n        }\n    }\n    return true\n}\n            \nassert(next_smallest(lst:\
    \ [1, 2, 3, 4, 5]) == 2)\nassert(next_smallest(lst: [5, 1, 4, 3, 2]) == 2)\nassert(next_smallest(lst:\
    \ [] as [Int]) == nil)\nassert(next_smallest(lst: [1, 1]) == nil)\nassert(next_smallest(lst:\
    \ [1, 1, 1, 1, 0]) == 1)\nassert(next_smallest(lst: [1, 1]) == nil)\nassert(next_smallest(lst:\
    \ [-35, 34, 12, -45]) == -35)"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660013380
- exit_code: -4
  program: "\n/// You are given an array of integers.\n/// Write a function next_smallest()\
    \ that returns the 2nd smallest element of the array.\n/// Return nil if there\
    \ is no such element.\n/// >>> next_smallest(lst: [1, 2, 3, 4, 5])\n/// 2\n///\
    \ >>> next_smallest(lst: [5, 1, 4, 3, 2])\n/// 2\n/// >>> next_smallest(lst: []\
    \ as [Int])\n/// nil\n/// >>> next_smallest(lst: [1, 1])\n/// nil\nfunc next_smallest(lst:\
    \ [Int]) -> Int? {\n    if lst.count == 0 {\n        return nil\n    } else if\
    \ lst.count == 1 {\n        return nil\n    } else {\n        let lst_sorted =\
    \ lst.sorted(by: <)\n        let first_val = lst_sorted[0]\n        var val =\
    \ lst_sorted[1]\n        for i in 1...lst_sorted.count - 1 {\n            if lst_sorted[i]\
    \ != first_val {\n                val = lst_sorted[i]\n                break\n\
    \            }\n        }\n        return val\n    }\n}\n\n\nfunc ==(left: [(Int,\
    \ Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n\
    \        return false\n    }\n    for (l, r) in zip(left, right) {\n        if\
    \ l != r {\n            return false\n        }\n    }\n    return true\n}\n \
    \           \nassert(next_smallest(lst: [1, 2, 3, 4, 5]) == 2)\nassert(next_smallest(lst:\
    \ [5, 1, 4, 3, 2]) == 2)\nassert(next_smallest(lst: [] as [Int]) == nil)\nassert(next_smallest(lst:\
    \ [1, 1]) == nil)\nassert(next_smallest(lst: [1, 1, 1, 1, 0]) == 1)\nassert(next_smallest(lst:\
    \ [1, 1]) == nil)\nassert(next_smallest(lst: [-35, 34, 12, -45]) == -35)"
  status: Exception
  stderr: 'tmpu4z3owjh/tmpu4z3owjh.swift:48: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002ab3d0917c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002ab3d060eb6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002ab3d060e988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002ab3d060d7b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpu4z3owjh                        0x00005570c5418a0a <unavailable> + 6666

    5    libc.so.6                          0x00002ab3d0b03460 __libc_start_main +
    245

    6    tmpu4z3owjh                        0x00005570c5418209 <unavailable> + 4617

    '
  stdout: ''
  timestamp: 1660013381
- exit_code: -4
  program: "\n/// You are given an array of integers.\n/// Write a function next_smallest()\
    \ that returns the 2nd smallest element of the array.\n/// Return nil if there\
    \ is no such element.\n/// >>> next_smallest(lst: [1, 2, 3, 4, 5])\n/// 2\n///\
    \ >>> next_smallest(lst: [5, 1, 4, 3, 2])\n/// 2\n/// >>> next_smallest(lst: []\
    \ as [Int])\n/// nil\n/// >>> next_smallest(lst: [1, 1])\n/// nil\nfunc next_smallest(lst:\
    \ [Int]) -> Int? {\n  guard lst.count > 1 else { return nil }\n  return lst.sorted()[1]\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(next_smallest(lst: [1, 2, 3, 4, 5]) == 2)\nassert(next_smallest(lst:\
    \ [5, 1, 4, 3, 2]) == 2)\nassert(next_smallest(lst: [] as [Int]) == nil)\nassert(next_smallest(lst:\
    \ [1, 1]) == nil)\nassert(next_smallest(lst: [1, 1, 1, 1, 0]) == 1)\nassert(next_smallest(lst:\
    \ [1, 1]) == nil)\nassert(next_smallest(lst: [-35, 34, 12, -45]) == -35)"
  status: Exception
  stderr: 'tmptpi1prh7/tmptpi1prh7.swift:34: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b459c0e7c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b459bddeb6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b459bdde988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b459bddd7b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmptpi1prh7                        0x000055ce900f38ba <unavailable> + 6330

    5    libc.so.6                          0x00002b459c2d3460 __libc_start_main +
    245

    6    tmptpi1prh7                        0x000055ce900f30b9 <unavailable> + 4281

    '
  stdout: ''
  timestamp: 1660013380
- exit_code: -4
  program: "\n/// You are given an array of integers.\n/// Write a function next_smallest()\
    \ that returns the 2nd smallest element of the array.\n/// Return nil if there\
    \ is no such element.\n/// >>> next_smallest(lst: [1, 2, 3, 4, 5])\n/// 2\n///\
    \ >>> next_smallest(lst: [5, 1, 4, 3, 2])\n/// 2\n/// >>> next_smallest(lst: []\
    \ as [Int])\n/// nil\n/// >>> next_smallest(lst: [1, 1])\n/// nil\nfunc next_smallest(lst:\
    \ [Int]) -> Int? {\n    if lst.count < 2 {\n        return nil\n    }\n    var\
    \ lst = lst\n    lst.sort()\n    var result = 0\n    for i in 1..<lst.count {\n\
    \        if lst[i] != lst[i - 1] {\n            result = lst[i]\n            break\n\
    \        }\n    }\n    return result\n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(next_smallest(lst: [1, 2, 3, 4, 5]) == 2)\nassert(next_smallest(lst: [5,\
    \ 1, 4, 3, 2]) == 2)\nassert(next_smallest(lst: [] as [Int]) == nil)\nassert(next_smallest(lst:\
    \ [1, 1]) == nil)\nassert(next_smallest(lst: [1, 1, 1, 1, 0]) == 1)\nassert(next_smallest(lst:\
    \ [1, 1]) == nil)\nassert(next_smallest(lst: [-35, 34, 12, -45]) == -35)"
  status: Exception
  stderr: 'tmpq7l32zgf/tmpq7l32zgf.swift:45: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b18250a7c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b1824d9eb6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b1824d9e988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b1824d9d7b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpq7l32zgf                        0x0000560eb800faca <unavailable> + 6858

    5    libc.so.6                          0x00002b1825293460 __libc_start_main +
    245

    6    tmpq7l32zgf                        0x0000560eb800f2c9 <unavailable> + 4809

    '
  stdout: ''
  timestamp: 1660013381
- exit_code: 0
  program: "\n/// You are given an array of integers.\n/// Write a function next_smallest()\
    \ that returns the 2nd smallest element of the array.\n/// Return nil if there\
    \ is no such element.\n/// >>> next_smallest(lst: [1, 2, 3, 4, 5])\n/// 2\n///\
    \ >>> next_smallest(lst: [5, 1, 4, 3, 2])\n/// 2\n/// >>> next_smallest(lst: []\
    \ as [Int])\n/// nil\n/// >>> next_smallest(lst: [1, 1])\n/// nil\nfunc next_smallest(lst:\
    \ [Int]) -> Int? {\n    var minimum: Int?\n    var minimum2: Int?\n    if lst.count\
    \ > 1 {\n        for item in lst {\n            if minimum == nil {\n        \
    \        minimum = item\n            } else if minimum != nil && item < minimum!\
    \ {\n                minimum2 = minimum\n                minimum = item\n    \
    \        } else if minimum2 == nil && item > minimum! {\n                minimum2\
    \ = item\n            } else if minimum2 != nil && item < minimum2! && item >\
    \ minimum! {\n                minimum2 = item\n            }\n        }\n    }\n\
    \    return minimum2\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(next_smallest(lst:\
    \ [1, 2, 3, 4, 5]) == 2)\nassert(next_smallest(lst: [5, 1, 4, 3, 2]) == 2)\nassert(next_smallest(lst:\
    \ [] as [Int]) == nil)\nassert(next_smallest(lst: [1, 1]) == nil)\nassert(next_smallest(lst:\
    \ [1, 1, 1, 1, 0]) == 1)\nassert(next_smallest(lst: [1, 1]) == nil)\nassert(next_smallest(lst:\
    \ [-35, 34, 12, -45]) == -35)"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660013381
- exit_code: -4
  program: "\n/// You are given an array of integers.\n/// Write a function next_smallest()\
    \ that returns the 2nd smallest element of the array.\n/// Return nil if there\
    \ is no such element.\n/// >>> next_smallest(lst: [1, 2, 3, 4, 5])\n/// 2\n///\
    \ >>> next_smallest(lst: [5, 1, 4, 3, 2])\n/// 2\n/// >>> next_smallest(lst: []\
    \ as [Int])\n/// nil\n/// >>> next_smallest(lst: [1, 1])\n/// nil\nfunc next_smallest(lst:\
    \ [Int]) -> Int? {\n    if lst.count < 2 {\n        return nil\n    }\n    let\
    \ sorted = lst.sorted()\n    var second = sorted[0]\n    for x in sorted[1...]\
    \ {\n        if x != second {\n            return second\n        }\n        second\
    \ = x\n    }\n    return nil\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int,\
    \ Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n\
    \    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n          \
    \  return false\n        }\n    }\n    return true\n}\n            \nassert(next_smallest(lst:\
    \ [1, 2, 3, 4, 5]) == 2)\nassert(next_smallest(lst: [5, 1, 4, 3, 2]) == 2)\nassert(next_smallest(lst:\
    \ [] as [Int]) == nil)\nassert(next_smallest(lst: [1, 1]) == nil)\nassert(next_smallest(lst:\
    \ [1, 1, 1, 1, 0]) == 1)\nassert(next_smallest(lst: [1, 1]) == nil)\nassert(next_smallest(lst:\
    \ [-35, 34, 12, -45]) == -35)"
  status: Exception
  stderr: 'tmpfkpc3o9p/tmpfkpc3o9p.swift:41: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002af7b4c64c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002af7b495bb6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002af7b495b988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002af7b495a7b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpfkpc3o9p                        0x000055b22b266841 <unavailable> + 6209

    5    libc.so.6                          0x00002af7b4e50460 __libc_start_main +
    245

    6    tmpfkpc3o9p                        0x000055b22b2663c9 <unavailable> + 5065

    '
  stdout: ''
  timestamp: 1660013381
- exit_code: -4
  program: "\n/// You are given an array of integers.\n/// Write a function next_smallest()\
    \ that returns the 2nd smallest element of the array.\n/// Return nil if there\
    \ is no such element.\n/// >>> next_smallest(lst: [1, 2, 3, 4, 5])\n/// 2\n///\
    \ >>> next_smallest(lst: [5, 1, 4, 3, 2])\n/// 2\n/// >>> next_smallest(lst: []\
    \ as [Int])\n/// nil\n/// >>> next_smallest(lst: [1, 1])\n/// nil\nfunc next_smallest(lst:\
    \ [Int]) -> Int? {\n    guard lst.count > 1 else { return nil }\n    guard lst.filter({\
    \ $0 == lst.first! }).count != lst.count else { return nil }\n    var res = lst.first\n\
    \    for (i, el) in lst.enumerated() {\n        if i != 0 {\n            if res!\
    \ > el {\n                if res! == lst.first! {\n                    res = el\n\
    \                } else {\n                    break\n                }\n    \
    \        }\n        }\n    }\n    return res\n}\n\n\nfunc ==(left: [(Int, Int)],\
    \ right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n       \
    \ return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r\
    \ {\n            return false\n        }\n    }\n    return true\n}\n        \
    \    \nassert(next_smallest(lst: [1, 2, 3, 4, 5]) == 2)\nassert(next_smallest(lst:\
    \ [5, 1, 4, 3, 2]) == 2)\nassert(next_smallest(lst: [] as [Int]) == nil)\nassert(next_smallest(lst:\
    \ [1, 1]) == nil)\nassert(next_smallest(lst: [1, 1, 1, 1, 0]) == 1)\nassert(next_smallest(lst:\
    \ [1, 1]) == nil)\nassert(next_smallest(lst: [-35, 34, 12, -45]) == -35)"
  status: Exception
  stderr: 'tmpx88hbk2d/tmpx88hbk2d.swift:44: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b9e9940fc80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b9e99106b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b9e99106988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b9e991057b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpx88hbk2d                        0x000055df133c9851 <unavailable> + 6225

    5    libc.so.6                          0x00002b9e995fb460 __libc_start_main +
    245

    6    tmpx88hbk2d                        0x000055df133c93d9 <unavailable> + 5081

    '
  stdout: ''
  timestamp: 1660013381
- exit_code: 0
  program: "\n/// You are given an array of integers.\n/// Write a function next_smallest()\
    \ that returns the 2nd smallest element of the array.\n/// Return nil if there\
    \ is no such element.\n/// >>> next_smallest(lst: [1, 2, 3, 4, 5])\n/// 2\n///\
    \ >>> next_smallest(lst: [5, 1, 4, 3, 2])\n/// 2\n/// >>> next_smallest(lst: []\
    \ as [Int])\n/// nil\n/// >>> next_smallest(lst: [1, 1])\n/// nil\nfunc next_smallest(lst:\
    \ [Int]) -> Int? {\n    if lst.count < 2 {\n        return nil\n    }\n    var\
    \ lst = lst\n    var min = lst[0]\n    var second_min = Int.max\n    for i in\
    \ 0..<lst.count {\n        if lst[i] < min {\n            second_min = min\n \
    \           min = lst[i]\n        } else if lst[i] < second_min && lst[i] != min\
    \ {\n            second_min = lst[i]\n        }\n    }\n    if second_min == Int.max\
    \ {\n        return nil\n    }\n    return second_min\n}\n\n\nfunc ==(left: [(Int,\
    \ Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n\
    \        return false\n    }\n    for (l, r) in zip(left, right) {\n        if\
    \ l != r {\n            return false\n        }\n    }\n    return true\n}\n \
    \           \nassert(next_smallest(lst: [1, 2, 3, 4, 5]) == 2)\nassert(next_smallest(lst:\
    \ [5, 1, 4, 3, 2]) == 2)\nassert(next_smallest(lst: [] as [Int]) == nil)\nassert(next_smallest(lst:\
    \ [1, 1]) == nil)\nassert(next_smallest(lst: [1, 1, 1, 1, 0]) == 1)\nassert(next_smallest(lst:\
    \ [1, 1]) == nil)\nassert(next_smallest(lst: [-35, 34, 12, -45]) == -35)"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660013381
- exit_code: -4
  program: "\n/// You are given an array of integers.\n/// Write a function next_smallest()\
    \ that returns the 2nd smallest element of the array.\n/// Return nil if there\
    \ is no such element.\n/// >>> next_smallest(lst: [1, 2, 3, 4, 5])\n/// 2\n///\
    \ >>> next_smallest(lst: [5, 1, 4, 3, 2])\n/// 2\n/// >>> next_smallest(lst: []\
    \ as [Int])\n/// nil\n/// >>> next_smallest(lst: [1, 1])\n/// nil\nfunc next_smallest(lst:\
    \ [Int]) -> Int? {\n    let sorted = lst.sorted()\n    var nums: [Int] = []\n\
    \    var prev = sorted[0]\n    for item in sorted[1..<sorted.count] {\n      \
    \  if item == prev {\n            continue\n        }\n        nums.append(item)\n\
    \        prev = item\n    }\n    return nums.count < 2 ? nil : nums[1]\n}\n\n\n\
    func ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(next_smallest(lst: [1, 2, 3, 4, 5]) == 2)\nassert(next_smallest(lst:\
    \ [5, 1, 4, 3, 2]) == 2)\nassert(next_smallest(lst: [] as [Int]) == nil)\nassert(next_smallest(lst:\
    \ [1, 1]) == nil)\nassert(next_smallest(lst: [1, 1, 1, 1, 0]) == 1)\nassert(next_smallest(lst:\
    \ [1, 1]) == nil)\nassert(next_smallest(lst: [-35, 34, 12, -45]) == -35)"
  status: Exception
  stderr: 'tmp3uppjtz_/tmp3uppjtz_.swift:40: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b64f5c42c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b64f5939b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b64f5939988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b64f59387b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmp3uppjtz_                        0x00005610fec5f841 <unavailable> + 6209

    5    libc.so.6                          0x00002b64f5e2e460 __libc_start_main +
    245

    6    tmp3uppjtz_                        0x00005610fec5f3c9 <unavailable> + 5065

    '
  stdout: ''
  timestamp: 1660013381
- exit_code: 0
  program: "\n/// You are given an array of integers.\n/// Write a function next_smallest()\
    \ that returns the 2nd smallest element of the array.\n/// Return nil if there\
    \ is no such element.\n/// >>> next_smallest(lst: [1, 2, 3, 4, 5])\n/// 2\n///\
    \ >>> next_smallest(lst: [5, 1, 4, 3, 2])\n/// 2\n/// >>> next_smallest(lst: []\
    \ as [Int])\n/// nil\n/// >>> next_smallest(lst: [1, 1])\n/// nil\nfunc next_smallest(lst:\
    \ [Int]) -> Int? {\n    if lst.count < 2 {\n        return nil\n    }\n    if\
    \ lst.count == 2 {\n        if lst[0] != lst[1] {\n            return lst[1]\n\
    \        } else {\n            return nil\n        }\n    }\n    var sorted =\
    \ lst.sorted()\n    var i = 0\n    while i < sorted.count - 1 {\n        if sorted[i]\
    \ != sorted[i + 1] {\n            return sorted[i + 1]\n        }\n        i +=\
    \ 1\n    }\n    return nil\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(next_smallest(lst:\
    \ [1, 2, 3, 4, 5]) == 2)\nassert(next_smallest(lst: [5, 1, 4, 3, 2]) == 2)\nassert(next_smallest(lst:\
    \ [] as [Int]) == nil)\nassert(next_smallest(lst: [1, 1]) == nil)\nassert(next_smallest(lst:\
    \ [1, 1, 1, 1, 0]) == 1)\nassert(next_smallest(lst: [1, 1]) == nil)\nassert(next_smallest(lst:\
    \ [-35, 34, 12, -45]) == -35)"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660013381
- exit_code: -4
  program: "\n/// You are given an array of integers.\n/// Write a function next_smallest()\
    \ that returns the 2nd smallest element of the array.\n/// Return nil if there\
    \ is no such element.\n/// >>> next_smallest(lst: [1, 2, 3, 4, 5])\n/// 2\n///\
    \ >>> next_smallest(lst: [5, 1, 4, 3, 2])\n/// 2\n/// >>> next_smallest(lst: []\
    \ as [Int])\n/// nil\n/// >>> next_smallest(lst: [1, 1])\n/// nil\nfunc next_smallest(lst:\
    \ [Int]) -> Int? {\n    \n    guard lst.count > 1 else {\n        return nil\n\
    \    }\n    \n    var temp = lst\n    let lowest = temp.removeFirst()\n    var\
    \ nextLowest = temp.removeFirst()\n    \n    if nextLowest == lowest {\n     \
    \   return nil\n    }\n    \n    if nextLowest < lowest {\n        nextLowest\
    \ = lowest\n    }\n    \n    while temp.count > 0 {\n        let nextNum = temp.removeFirst()\n\
    \        if nextNum == lowest {\n            return nil\n        }\n        if\
    \ nextNum < nextLowest {\n            nextLowest = nextNum\n        }\n    }\n\
    \    \n    return nextLowest\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int,\
    \ Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n\
    \    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n          \
    \  return false\n        }\n    }\n    return true\n}\n            \nassert(next_smallest(lst:\
    \ [1, 2, 3, 4, 5]) == 2)\nassert(next_smallest(lst: [5, 1, 4, 3, 2]) == 2)\nassert(next_smallest(lst:\
    \ [] as [Int]) == nil)\nassert(next_smallest(lst: [1, 1]) == nil)\nassert(next_smallest(lst:\
    \ [1, 1, 1, 1, 0]) == 1)\nassert(next_smallest(lst: [1, 1]) == nil)\nassert(next_smallest(lst:\
    \ [-35, 34, 12, -45]) == -35)"
  status: Exception
  stderr: 'tmplhyw9eoh/tmplhyw9eoh.swift:61: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b54f6b1ec80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b54f6815b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b54f6815988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b54f68147b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmplhyw9eoh                        0x000056490b6f8a17 <unavailable> + 6679

    5    libc.so.6                          0x00002b54f6d0a460 __libc_start_main +
    245

    6    tmplhyw9eoh                        0x000056490b6f8069 <unavailable> + 4201

    '
  stdout: ''
  timestamp: 1660013381
- exit_code: 0
  program: "\n/// You are given an array of integers.\n/// Write a function next_smallest()\
    \ that returns the 2nd smallest element of the array.\n/// Return nil if there\
    \ is no such element.\n/// >>> next_smallest(lst: [1, 2, 3, 4, 5])\n/// 2\n///\
    \ >>> next_smallest(lst: [5, 1, 4, 3, 2])\n/// 2\n/// >>> next_smallest(lst: []\
    \ as [Int])\n/// nil\n/// >>> next_smallest(lst: [1, 1])\n/// nil\nfunc next_smallest(lst:\
    \ [Int]) -> Int? {\n    if lst.count == 0 {\n        return nil\n    }\n    let\
    \ sortedLst = lst.sorted()\n    for i in 1..<sortedLst.count {\n        if sortedLst[i]\
    \ != sortedLst[i - 1] {\n            return sortedLst[i]\n        }\n    }\n \
    \   return nil\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool\
    \ {\n    if left.count != right.count {\n        return false\n    }\n    for\
    \ (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(next_smallest(lst:\
    \ [1, 2, 3, 4, 5]) == 2)\nassert(next_smallest(lst: [5, 1, 4, 3, 2]) == 2)\nassert(next_smallest(lst:\
    \ [] as [Int]) == nil)\nassert(next_smallest(lst: [1, 1]) == nil)\nassert(next_smallest(lst:\
    \ [1, 1, 1, 1, 0]) == 1)\nassert(next_smallest(lst: [1, 1]) == nil)\nassert(next_smallest(lst:\
    \ [-35, 34, 12, -45]) == -35)"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660013381
- exit_code: -4
  program: "\n/// You are given an array of integers.\n/// Write a function next_smallest()\
    \ that returns the 2nd smallest element of the array.\n/// Return nil if there\
    \ is no such element.\n/// >>> next_smallest(lst: [1, 2, 3, 4, 5])\n/// 2\n///\
    \ >>> next_smallest(lst: [5, 1, 4, 3, 2])\n/// 2\n/// >>> next_smallest(lst: []\
    \ as [Int])\n/// nil\n/// >>> next_smallest(lst: [1, 1])\n/// nil\nfunc next_smallest(lst:\
    \ [Int]) -> Int? {\n    guard lst.count > 1 else { return nil }\n    var min =\
    \ Int.max\n    var secondMin = Int.max\n    for i in lst {\n        if i < min\
    \ {\n            secondMin = min\n            min = i\n        } else if i < secondMin\
    \ {\n            secondMin = i\n        }\n    }\n    return secondMin == Int.max\
    \ ? nil : secondMin\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) ->\
    \ Bool {\n    if left.count != right.count {\n        return false\n    }\n  \
    \  for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(next_smallest(lst:\
    \ [1, 2, 3, 4, 5]) == 2)\nassert(next_smallest(lst: [5, 1, 4, 3, 2]) == 2)\nassert(next_smallest(lst:\
    \ [] as [Int]) == nil)\nassert(next_smallest(lst: [1, 1]) == nil)\nassert(next_smallest(lst:\
    \ [1, 1, 1, 1, 0]) == 1)\nassert(next_smallest(lst: [1, 1]) == nil)\nassert(next_smallest(lst:\
    \ [-35, 34, 12, -45]) == -35)"
  status: Exception
  stderr: 'tmp75sv9m8b/tmp75sv9m8b.swift:44: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002ba11bc76c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002ba11b96db6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002ba11b96d988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002ba11b96c7b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmp75sv9m8b                        0x0000561b7846792a <unavailable> + 6442

    5    libc.so.6                          0x00002ba11be62460 __libc_start_main +
    245

    6    tmp75sv9m8b                        0x0000561b78467129 <unavailable> + 4393

    '
  stdout: ''
  timestamp: 1660013381
- exit_code: -4
  program: "\n/// You are given an array of integers.\n/// Write a function next_smallest()\
    \ that returns the 2nd smallest element of the array.\n/// Return nil if there\
    \ is no such element.\n/// >>> next_smallest(lst: [1, 2, 3, 4, 5])\n/// 2\n///\
    \ >>> next_smallest(lst: [5, 1, 4, 3, 2])\n/// 2\n/// >>> next_smallest(lst: []\
    \ as [Int])\n/// nil\n/// >>> next_smallest(lst: [1, 1])\n/// nil\nfunc next_smallest(lst:\
    \ [Int]) -> Int? {\n    var current_min = Int.max\n    var current_2nd_min = Int.max\n\
    \    for n in lst {\n        if n < current_min {\n            current_2nd_min\
    \ = current_min\n            current_min = n\n        } else if n < current_2nd_min\
    \ {\n            current_2nd_min = n\n        }\n    }\n    return current_2nd_min\
    \ != Int.max ? current_2nd_min : nil\n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(next_smallest(lst: [1, 2, 3, 4, 5]) == 2)\nassert(next_smallest(lst: [5,\
    \ 1, 4, 3, 2]) == 2)\nassert(next_smallest(lst: [] as [Int]) == nil)\nassert(next_smallest(lst:\
    \ [1, 1]) == nil)\nassert(next_smallest(lst: [1, 1, 1, 1, 0]) == 1)\nassert(next_smallest(lst:\
    \ [1, 1]) == nil)\nassert(next_smallest(lst: [-35, 34, 12, -45]) == -35)"
  status: Exception
  stderr: 'tmpy9t8vyro/tmpy9t8vyro.swift:43: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002ba9da3ecc80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002ba9da0e3b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002ba9da0e3988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002ba9da0e27b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpy9t8vyro                        0x000055fab2fc48da <unavailable> + 6362

    5    libc.so.6                          0x00002ba9da5d8460 __libc_start_main +
    245

    6    tmpy9t8vyro                        0x000055fab2fc40d9 <unavailable> + 4313

    '
  stdout: ''
  timestamp: 1660013381
- exit_code: 0
  program: "\n/// You are given an array of integers.\n/// Write a function next_smallest()\
    \ that returns the 2nd smallest element of the array.\n/// Return nil if there\
    \ is no such element.\n/// >>> next_smallest(lst: [1, 2, 3, 4, 5])\n/// 2\n///\
    \ >>> next_smallest(lst: [5, 1, 4, 3, 2])\n/// 2\n/// >>> next_smallest(lst: []\
    \ as [Int])\n/// nil\n/// >>> next_smallest(lst: [1, 1])\n/// nil\nfunc next_smallest(lst:\
    \ [Int]) -> Int? {\n    guard lst.count > 2 else { return nil }\n    var smallest\
    \ = lst[0]\n    var next_smallest = lst[1]\n    if next_smallest < smallest {\n\
    \        smallest = next_smallest\n        next_smallest = lst[0]\n    }\n   \
    \ for num in lst[2...] {\n        if num < smallest {\n            next_smallest\
    \ = smallest\n            smallest = num\n        } else if num < next_smallest\
    \ {\n            next_smallest = num\n        }\n    }\n    return next_smallest\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(next_smallest(lst: [1, 2, 3, 4, 5]) == 2)\nassert(next_smallest(lst:\
    \ [5, 1, 4, 3, 2]) == 2)\nassert(next_smallest(lst: [] as [Int]) == nil)\nassert(next_smallest(lst:\
    \ [1, 1]) == nil)\nassert(next_smallest(lst: [1, 1, 1, 1, 0]) == 1)\nassert(next_smallest(lst:\
    \ [1, 1]) == nil)\nassert(next_smallest(lst: [-35, 34, 12, -45]) == -35)"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660013381
- exit_code: 0
  program: "\n/// You are given an array of integers.\n/// Write a function next_smallest()\
    \ that returns the 2nd smallest element of the array.\n/// Return nil if there\
    \ is no such element.\n/// >>> next_smallest(lst: [1, 2, 3, 4, 5])\n/// 2\n///\
    \ >>> next_smallest(lst: [5, 1, 4, 3, 2])\n/// 2\n/// >>> next_smallest(lst: []\
    \ as [Int])\n/// nil\n/// >>> next_smallest(lst: [1, 1])\n/// nil\nfunc next_smallest(lst:\
    \ [Int]) -> Int? {\n    let sorted = lst.sorted()\n    if sorted.count < 2 {\n\
    \        return nil\n    }\n    var previous = sorted[0]\n    for index in 1..<sorted.count\
    \ {\n        if sorted[index] != previous {\n            return sorted[index]\n\
    \        }\n        previous = sorted[index]\n    }\n    return nil\n}\n\n\nfunc\
    \ ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count !=\
    \ right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(next_smallest(lst: [1, 2, 3, 4, 5]) == 2)\nassert(next_smallest(lst:\
    \ [5, 1, 4, 3, 2]) == 2)\nassert(next_smallest(lst: [] as [Int]) == nil)\nassert(next_smallest(lst:\
    \ [1, 1]) == nil)\nassert(next_smallest(lst: [1, 1, 1, 1, 0]) == 1)\nassert(next_smallest(lst:\
    \ [1, 1]) == nil)\nassert(next_smallest(lst: [-35, 34, 12, -45]) == -35)"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660013381
- exit_code: -4
  program: "\n/// You are given an array of integers.\n/// Write a function next_smallest()\
    \ that returns the 2nd smallest element of the array.\n/// Return nil if there\
    \ is no such element.\n/// >>> next_smallest(lst: [1, 2, 3, 4, 5])\n/// 2\n///\
    \ >>> next_smallest(lst: [5, 1, 4, 3, 2])\n/// 2\n/// >>> next_smallest(lst: []\
    \ as [Int])\n/// nil\n/// >>> next_smallest(lst: [1, 1])\n/// nil\nfunc next_smallest(lst:\
    \ [Int]) -> Int? {\n    guard lst.count > 1 else { return nil }\n    let sorted\
    \ = lst.sorted()\n    for i in 0..<sorted.count {\n        if sorted[i] != sorted[i+1]\
    \ {\n            return sorted[i+1]\n        }\n    }\n    return nil\n}\n\n\n\
    func ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(next_smallest(lst: [1, 2, 3, 4, 5]) == 2)\nassert(next_smallest(lst:\
    \ [5, 1, 4, 3, 2]) == 2)\nassert(next_smallest(lst: [] as [Int]) == nil)\nassert(next_smallest(lst:\
    \ [1, 1]) == nil)\nassert(next_smallest(lst: [1, 1, 1, 1, 0]) == 1)\nassert(next_smallest(lst:\
    \ [1, 1]) == nil)\nassert(next_smallest(lst: [-35, 34, 12, -45]) == -35)"
  status: Exception
  stderr: 'Swift/ContiguousArrayBuffer.swift:600: Fatal error: Index out of range

    Current stack trace:

    0    libswiftCore.so                    0x00002b260b9fec80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b260b6f5561 <unavailable> + 1434977

    2    libswiftCore.so                    0x00002b260b6f5286 <unavailable> + 1434246

    3    libswiftCore.so                    0x00002b260b6f513c <unavailable> + 1433916

    4    libswiftCore.so                    0x00002b260b6f4bb0 _assertionFailure(_:_:file:line:flags:)
    + 251

    5    libswiftSwiftOnoneSupport.so       0x00002b260b4f4e83 <unavailable> + 188035

    6    tmp7zaudq39                        0x0000560a3f9cf0bf <unavailable> + 8383

    7    tmp7zaudq39                        0x0000560a3f9ce98a <unavailable> + 6538

    8    libc.so.6                          0x00002b260bbea460 __libc_start_main +
    245

    9    tmp7zaudq39                        0x0000560a3f9ce249 <unavailable> + 4681

    '
  stdout: ''
  timestamp: 1660013381
- exit_code: 0
  program: "\n/// You are given an array of integers.\n/// Write a function next_smallest()\
    \ that returns the 2nd smallest element of the array.\n/// Return nil if there\
    \ is no such element.\n/// >>> next_smallest(lst: [1, 2, 3, 4, 5])\n/// 2\n///\
    \ >>> next_smallest(lst: [5, 1, 4, 3, 2])\n/// 2\n/// >>> next_smallest(lst: []\
    \ as [Int])\n/// nil\n/// >>> next_smallest(lst: [1, 1])\n/// nil\nfunc next_smallest(lst:\
    \ [Int]) -> Int? {\n  if lst.count < 2 {\n    return nil\n  }\n  let sorted =\
    \ lst.sorted()\n  var previous: Int?\n  for next in sorted {\n    if let prev\
    \ = previous {\n      if prev != next {\n        return next\n      }\n    }\n\
    \    previous = next\n  }\n  return nil\n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(next_smallest(lst: [1, 2, 3, 4, 5]) == 2)\nassert(next_smallest(lst: [5,\
    \ 1, 4, 3, 2]) == 2)\nassert(next_smallest(lst: [] as [Int]) == nil)\nassert(next_smallest(lst:\
    \ [1, 1]) == nil)\nassert(next_smallest(lst: [1, 1, 1, 1, 0]) == 1)\nassert(next_smallest(lst:\
    \ [1, 1]) == nil)\nassert(next_smallest(lst: [-35, 34, 12, -45]) == -35)"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660013381
- exit_code: 0
  program: "\n/// You are given an array of integers.\n/// Write a function next_smallest()\
    \ that returns the 2nd smallest element of the array.\n/// Return nil if there\
    \ is no such element.\n/// >>> next_smallest(lst: [1, 2, 3, 4, 5])\n/// 2\n///\
    \ >>> next_smallest(lst: [5, 1, 4, 3, 2])\n/// 2\n/// >>> next_smallest(lst: []\
    \ as [Int])\n/// nil\n/// >>> next_smallest(lst: [1, 1])\n/// nil\nfunc next_smallest(lst:\
    \ [Int]) -> Int? {\n    var arr = lst\n    arr.sort()\n    if arr.count == 0 {\n\
    \        return nil\n    }\n    if arr.count == 1 {\n        return nil\n    }\n\
    \    for i in 1..<arr.count {\n        if arr[i] != arr[i-1] {\n            return\
    \ arr[i]\n        }\n    }\n    return nil\n}\n\n\nfunc ==(left: [(Int, Int)],\
    \ right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n       \
    \ return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r\
    \ {\n            return false\n        }\n    }\n    return true\n}\n        \
    \    \nassert(next_smallest(lst: [1, 2, 3, 4, 5]) == 2)\nassert(next_smallest(lst:\
    \ [5, 1, 4, 3, 2]) == 2)\nassert(next_smallest(lst: [] as [Int]) == nil)\nassert(next_smallest(lst:\
    \ [1, 1]) == nil)\nassert(next_smallest(lst: [1, 1, 1, 1, 0]) == 1)\nassert(next_smallest(lst:\
    \ [1, 1]) == nil)\nassert(next_smallest(lst: [-35, 34, 12, -45]) == -35)"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660013381
- exit_code: 0
  program: "\n/// You are given an array of integers.\n/// Write a function next_smallest()\
    \ that returns the 2nd smallest element of the array.\n/// Return nil if there\
    \ is no such element.\n/// >>> next_smallest(lst: [1, 2, 3, 4, 5])\n/// 2\n///\
    \ >>> next_smallest(lst: [5, 1, 4, 3, 2])\n/// 2\n/// >>> next_smallest(lst: []\
    \ as [Int])\n/// nil\n/// >>> next_smallest(lst: [1, 1])\n/// nil\nfunc next_smallest(lst:\
    \ [Int]) -> Int? {\n    guard lst.count > 1 else { return nil }\n    let sorted\
    \ = lst.sorted()\n    var prev: Int?\n    for elem in sorted {\n        guard\
    \ let prevValue = prev else {\n            prev = elem\n            continue\n\
    \        }\n        if elem != prevValue {\n            return elem\n        }\n\
    \    }\n    return nil\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(next_smallest(lst:\
    \ [1, 2, 3, 4, 5]) == 2)\nassert(next_smallest(lst: [5, 1, 4, 3, 2]) == 2)\nassert(next_smallest(lst:\
    \ [] as [Int]) == nil)\nassert(next_smallest(lst: [1, 1]) == nil)\nassert(next_smallest(lst:\
    \ [1, 1, 1, 1, 0]) == 1)\nassert(next_smallest(lst: [1, 1]) == nil)\nassert(next_smallest(lst:\
    \ [-35, 34, 12, -45]) == -35)"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660013381
- exit_code: -4
  program: "\n/// You are given an array of integers.\n/// Write a function next_smallest()\
    \ that returns the 2nd smallest element of the array.\n/// Return nil if there\
    \ is no such element.\n/// >>> next_smallest(lst: [1, 2, 3, 4, 5])\n/// 2\n///\
    \ >>> next_smallest(lst: [5, 1, 4, 3, 2])\n/// 2\n/// >>> next_smallest(lst: []\
    \ as [Int])\n/// nil\n/// >>> next_smallest(lst: [1, 1])\n/// nil\nfunc next_smallest(lst:\
    \ [Int]) -> Int? {\n    var smallest = lst[0]\n    var secondSmallest = lst[0]\n\
    \    var i = 0\n    while i < lst.count {\n        if lst[i] < smallest {\n  \
    \          secondSmallest = smallest\n            smallest = lst[i]\n        }\
    \ else if lst[i] < secondSmallest {\n            secondSmallest = lst[i]\n   \
    \     }\n        i += 1\n    }\n    if smallest == secondSmallest {\n        return\
    \ nil\n    }\n    return secondSmallest\n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(next_smallest(lst: [1, 2, 3, 4, 5]) == 2)\nassert(next_smallest(lst: [5,\
    \ 1, 4, 3, 2]) == 2)\nassert(next_smallest(lst: [] as [Int]) == nil)\nassert(next_smallest(lst:\
    \ [1, 1]) == nil)\nassert(next_smallest(lst: [1, 1, 1, 1, 0]) == 1)\nassert(next_smallest(lst:\
    \ [1, 1]) == nil)\nassert(next_smallest(lst: [-35, 34, 12, -45]) == -35)"
  status: Exception
  stderr: 'tmpm0do0xad/tmpm0do0xad.swift:45: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002adb3de08c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002adb3daffb6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002adb3daff988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002adb3dafe7b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpm0do0xad                        0x0000560ac271a491 <unavailable> + 5265

    5    libc.so.6                          0x00002adb3dff4460 __libc_start_main +
    245

    6    tmpm0do0xad                        0x0000560ac271a019 <unavailable> + 4121

    '
  stdout: ''
  timestamp: 1660013381
- exit_code: -4
  program: "\n/// You are given an array of integers.\n/// Write a function next_smallest()\
    \ that returns the 2nd smallest element of the array.\n/// Return nil if there\
    \ is no such element.\n/// >>> next_smallest(lst: [1, 2, 3, 4, 5])\n/// 2\n///\
    \ >>> next_smallest(lst: [5, 1, 4, 3, 2])\n/// 2\n/// >>> next_smallest(lst: []\
    \ as [Int])\n/// nil\n/// >>> next_smallest(lst: [1, 1])\n/// nil\nfunc next_smallest(lst:\
    \ [Int]) -> Int? {\n    guard lst.count > 1 else { return nil }\n    let sorted\
    \ = lst.sorted()\n    return sorted[1]\n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(next_smallest(lst: [1, 2, 3, 4, 5]) == 2)\nassert(next_smallest(lst: [5,\
    \ 1, 4, 3, 2]) == 2)\nassert(next_smallest(lst: [] as [Int]) == nil)\nassert(next_smallest(lst:\
    \ [1, 1]) == nil)\nassert(next_smallest(lst: [1, 1, 1, 1, 0]) == 1)\nassert(next_smallest(lst:\
    \ [1, 1]) == nil)\nassert(next_smallest(lst: [-35, 34, 12, -45]) == -35)"
  status: Exception
  stderr: 'tmp8y8mztze/tmp8y8mztze.swift:35: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b276daedc80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b276d7e4b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b276d7e4988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b276d7e37b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmp8y8mztze                        0x000055cf36f688ba <unavailable> + 6330

    5    libc.so.6                          0x00002b276dcd9460 __libc_start_main +
    245

    6    tmp8y8mztze                        0x000055cf36f680b9 <unavailable> + 4281

    '
  stdout: ''
  timestamp: 1660013218
- exit_code: -4
  program: "\n/// You are given an array of integers.\n/// Write a function next_smallest()\
    \ that returns the 2nd smallest element of the array.\n/// Return nil if there\
    \ is no such element.\n/// >>> next_smallest(lst: [1, 2, 3, 4, 5])\n/// 2\n///\
    \ >>> next_smallest(lst: [5, 1, 4, 3, 2])\n/// 2\n/// >>> next_smallest(lst: []\
    \ as [Int])\n/// nil\n/// >>> next_smallest(lst: [1, 1])\n/// nil\nfunc next_smallest(lst:\
    \ [Int]) -> Int? {\n    guard lst.count > 1 else { return nil }\n    var sorted\
    \ = lst.sorted()\n    var newList = [Int]()\n    var prev = sorted[0]\n    for\
    \ number in sorted {\n        if number != prev {\n            newList.append(number)\n\
    \        }\n        prev = number\n    }\n    return newList.count > 1 ? newList[1]\
    \ : nil\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n \
    \   if left.count != right.count {\n        return false\n    }\n    for (l, r)\
    \ in zip(left, right) {\n        if l != r {\n            return false\n     \
    \   }\n    }\n    return true\n}\n            \nassert(next_smallest(lst: [1,\
    \ 2, 3, 4, 5]) == 2)\nassert(next_smallest(lst: [5, 1, 4, 3, 2]) == 2)\nassert(next_smallest(lst:\
    \ [] as [Int]) == nil)\nassert(next_smallest(lst: [1, 1]) == nil)\nassert(next_smallest(lst:\
    \ [1, 1, 1, 1, 0]) == 1)\nassert(next_smallest(lst: [1, 1]) == nil)\nassert(next_smallest(lst:\
    \ [-35, 34, 12, -45]) == -35)"
  status: Exception
  stderr: 'tmpl7_zcfq8/tmpl7_zcfq8.swift:40: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b79a5da0c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b79a5a97b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b79a5a97988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b79a5a967b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpl7_zcfq8                        0x00005640f6ec8751 <unavailable> + 5969

    5    libc.so.6                          0x00002b79a5f8c460 __libc_start_main +
    245

    6    tmpl7_zcfq8                        0x00005640f6ec82d9 <unavailable> + 4825

    '
  stdout: ''
  timestamp: 1660013381
- exit_code: 0
  program: "\n/// You are given an array of integers.\n/// Write a function next_smallest()\
    \ that returns the 2nd smallest element of the array.\n/// Return nil if there\
    \ is no such element.\n/// >>> next_smallest(lst: [1, 2, 3, 4, 5])\n/// 2\n///\
    \ >>> next_smallest(lst: [5, 1, 4, 3, 2])\n/// 2\n/// >>> next_smallest(lst: []\
    \ as [Int])\n/// nil\n/// >>> next_smallest(lst: [1, 1])\n/// nil\nfunc next_smallest(lst:\
    \ [Int]) -> Int? {\n    var result = [Int]()\n    guard lst.count > 0 else {\n\
    \        return nil\n    }\n    result = lst.sorted()\n    for (i, v) in result.enumerated()\
    \ {\n        if i == 0 {\n            continue\n        }\n        if result[i]\
    \ != result[i - 1] {\n            return result[i]\n        }\n    }\n    return\
    \ nil\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n   \
    \ if left.count != right.count {\n        return false\n    }\n    for (l, r)\
    \ in zip(left, right) {\n        if l != r {\n            return false\n     \
    \   }\n    }\n    return true\n}\n            \nassert(next_smallest(lst: [1,\
    \ 2, 3, 4, 5]) == 2)\nassert(next_smallest(lst: [5, 1, 4, 3, 2]) == 2)\nassert(next_smallest(lst:\
    \ [] as [Int]) == nil)\nassert(next_smallest(lst: [1, 1]) == nil)\nassert(next_smallest(lst:\
    \ [1, 1, 1, 1, 0]) == 1)\nassert(next_smallest(lst: [1, 1]) == nil)\nassert(next_smallest(lst:\
    \ [-35, 34, 12, -45]) == -35)"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660013381
- exit_code: 0
  program: "\n/// You are given an array of integers.\n/// Write a function next_smallest()\
    \ that returns the 2nd smallest element of the array.\n/// Return nil if there\
    \ is no such element.\n/// >>> next_smallest(lst: [1, 2, 3, 4, 5])\n/// 2\n///\
    \ >>> next_smallest(lst: [5, 1, 4, 3, 2])\n/// 2\n/// >>> next_smallest(lst: []\
    \ as [Int])\n/// nil\n/// >>> next_smallest(lst: [1, 1])\n/// nil\nfunc next_smallest(lst:\
    \ [Int]) -> Int? {\n    guard lst.count > 1 else { return nil }\n    let sortedList\
    \ = lst.sorted()\n    for index in 0..<sortedList.count - 1 {\n        if sortedList[index]\
    \ != sortedList[index + 1] {\n            return sortedList[index + 1]\n     \
    \   }\n    }\n    return nil\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int,\
    \ Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n\
    \    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n          \
    \  return false\n        }\n    }\n    return true\n}\n            \nassert(next_smallest(lst:\
    \ [1, 2, 3, 4, 5]) == 2)\nassert(next_smallest(lst: [5, 1, 4, 3, 2]) == 2)\nassert(next_smallest(lst:\
    \ [] as [Int]) == nil)\nassert(next_smallest(lst: [1, 1]) == nil)\nassert(next_smallest(lst:\
    \ [1, 1, 1, 1, 0]) == 1)\nassert(next_smallest(lst: [1, 1]) == nil)\nassert(next_smallest(lst:\
    \ [-35, 34, 12, -45]) == -35)"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660013381
- exit_code: -4
  program: "\n/// You are given an array of integers.\n/// Write a function next_smallest()\
    \ that returns the 2nd smallest element of the array.\n/// Return nil if there\
    \ is no such element.\n/// >>> next_smallest(lst: [1, 2, 3, 4, 5])\n/// 2\n///\
    \ >>> next_smallest(lst: [5, 1, 4, 3, 2])\n/// 2\n/// >>> next_smallest(lst: []\
    \ as [Int])\n/// nil\n/// >>> next_smallest(lst: [1, 1])\n/// nil\nfunc next_smallest(lst:\
    \ [Int]) -> Int? {\n    if lst.count < 2 {\n        return nil\n    }\n    var\
    \ smallest = Int.max\n    var second_smallest = Int.max\n    for x in lst {\n\
    \        if x < smallest {\n            second_smallest = smallest\n         \
    \   smallest = x\n        } else if x < second_smallest {\n            second_smallest\
    \ = x\n        }\n    }\n    return second_smallest == Int.max ? nil : second_smallest\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(next_smallest(lst: [1, 2, 3, 4, 5]) == 2)\nassert(next_smallest(lst:\
    \ [5, 1, 4, 3, 2]) == 2)\nassert(next_smallest(lst: [] as [Int]) == nil)\nassert(next_smallest(lst:\
    \ [1, 1]) == nil)\nassert(next_smallest(lst: [1, 1, 1, 1, 0]) == 1)\nassert(next_smallest(lst:\
    \ [1, 1]) == nil)\nassert(next_smallest(lst: [-35, 34, 12, -45]) == -35)"
  status: Exception
  stderr: 'tmphwv5xp2l/tmphwv5xp2l.swift:46: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b8fed771c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b8fed468b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b8fed468988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b8fed4677b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmphwv5xp2l                        0x000056477c9ed92a <unavailable> + 6442

    5    libc.so.6                          0x00002b8fed95d460 __libc_start_main +
    245

    6    tmphwv5xp2l                        0x000056477c9ed129 <unavailable> + 4393

    '
  stdout: ''
  timestamp: 1660013381
- exit_code: -4
  program: "\n/// You are given an array of integers.\n/// Write a function next_smallest()\
    \ that returns the 2nd smallest element of the array.\n/// Return nil if there\
    \ is no such element.\n/// >>> next_smallest(lst: [1, 2, 3, 4, 5])\n/// 2\n///\
    \ >>> next_smallest(lst: [5, 1, 4, 3, 2])\n/// 2\n/// >>> next_smallest(lst: []\
    \ as [Int])\n/// nil\n/// >>> next_smallest(lst: [1, 1])\n/// nil\nfunc next_smallest(lst:\
    \ [Int]) -> Int? {\n    var min = Int.max\n    var second = Int.max\n    for elem\
    \ in lst {\n        if elem < min {\n            second = min\n            min\
    \ = elem\n        } else if elem < second {\n            second = elem\n     \
    \   }\n    }\n    return second == Int.max ? nil : second\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(next_smallest(lst: [1, 2, 3, 4, 5]) == 2)\nassert(next_smallest(lst:\
    \ [5, 1, 4, 3, 2]) == 2)\nassert(next_smallest(lst: [] as [Int]) == nil)\nassert(next_smallest(lst:\
    \ [1, 1]) == nil)\nassert(next_smallest(lst: [1, 1, 1, 1, 0]) == 1)\nassert(next_smallest(lst:\
    \ [1, 1]) == nil)\nassert(next_smallest(lst: [-35, 34, 12, -45]) == -35)"
  status: Exception
  stderr: 'tmp3_uz1bq_/tmp3_uz1bq_.swift:43: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002add254b4c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002add251abb6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002add251ab988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002add251aa7b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmp3_uz1bq_                        0x000056150489d8da <unavailable> + 6362

    5    libc.so.6                          0x00002add256a0460 __libc_start_main +
    245

    6    tmp3_uz1bq_                        0x000056150489d0d9 <unavailable> + 4313

    '
  stdout: ''
  timestamp: 1660013381
- exit_code: 0
  program: "\n/// You are given an array of integers.\n/// Write a function next_smallest()\
    \ that returns the 2nd smallest element of the array.\n/// Return nil if there\
    \ is no such element.\n/// >>> next_smallest(lst: [1, 2, 3, 4, 5])\n/// 2\n///\
    \ >>> next_smallest(lst: [5, 1, 4, 3, 2])\n/// 2\n/// >>> next_smallest(lst: []\
    \ as [Int])\n/// nil\n/// >>> next_smallest(lst: [1, 1])\n/// nil\nfunc next_smallest(lst:\
    \ [Int]) -> Int? {\n    guard lst.count > 1 else { return nil }\n    var smallest_value\
    \ = Int.max\n    var second_smallest_value = Int.max\n    for item in lst {\n\
    \        if item < smallest_value {\n            second_smallest_value = smallest_value\n\
    \            smallest_value = item\n        } else if item < second_smallest_value\
    \ {\n            second_smallest_value = item\n        }\n    }\n    return smallest_value\
    \ == second_smallest_value ? nil : second_smallest_value\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(next_smallest(lst: [1, 2, 3, 4, 5]) == 2)\nassert(next_smallest(lst:\
    \ [5, 1, 4, 3, 2]) == 2)\nassert(next_smallest(lst: [] as [Int]) == nil)\nassert(next_smallest(lst:\
    \ [1, 1]) == nil)\nassert(next_smallest(lst: [1, 1, 1, 1, 0]) == 1)\nassert(next_smallest(lst:\
    \ [1, 1]) == nil)\nassert(next_smallest(lst: [-35, 34, 12, -45]) == -35)"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660013381
- exit_code: 0
  program: "\n/// You are given an array of integers.\n/// Write a function next_smallest()\
    \ that returns the 2nd smallest element of the array.\n/// Return nil if there\
    \ is no such element.\n/// >>> next_smallest(lst: [1, 2, 3, 4, 5])\n/// 2\n///\
    \ >>> next_smallest(lst: [5, 1, 4, 3, 2])\n/// 2\n/// >>> next_smallest(lst: []\
    \ as [Int])\n/// nil\n/// >>> next_smallest(lst: [1, 1])\n/// nil\nfunc next_smallest(lst:\
    \ [Int]) -> Int? {\n    if (lst.count == 0) {\n        return nil\n    } else\
    \ if (lst.count == 1) {\n        return nil\n    } else {\n        let sorted\
    \ = lst.sorted()\n        let first = sorted[0]\n        for i in 1..<sorted.count\
    \ {\n            if (sorted[i] != first) {\n                return sorted[i]\n\
    \            }\n        }\n        return nil\n    }\n}\n\n\nfunc ==(left: [(Int,\
    \ Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n\
    \        return false\n    }\n    for (l, r) in zip(left, right) {\n        if\
    \ l != r {\n            return false\n        }\n    }\n    return true\n}\n \
    \           \nassert(next_smallest(lst: [1, 2, 3, 4, 5]) == 2)\nassert(next_smallest(lst:\
    \ [5, 1, 4, 3, 2]) == 2)\nassert(next_smallest(lst: [] as [Int]) == nil)\nassert(next_smallest(lst:\
    \ [1, 1]) == nil)\nassert(next_smallest(lst: [1, 1, 1, 1, 0]) == 1)\nassert(next_smallest(lst:\
    \ [1, 1]) == nil)\nassert(next_smallest(lst: [-35, 34, 12, -45]) == -35)"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660013381
- exit_code: 0
  program: "\n/// You are given an array of integers.\n/// Write a function next_smallest()\
    \ that returns the 2nd smallest element of the array.\n/// Return nil if there\
    \ is no such element.\n/// >>> next_smallest(lst: [1, 2, 3, 4, 5])\n/// 2\n///\
    \ >>> next_smallest(lst: [5, 1, 4, 3, 2])\n/// 2\n/// >>> next_smallest(lst: []\
    \ as [Int])\n/// nil\n/// >>> next_smallest(lst: [1, 1])\n/// nil\nfunc next_smallest(lst:\
    \ [Int]) -> Int? {\n    if lst.count == 0 {\n        return nil\n    }\n    if\
    \ lst.count == 1 {\n        return nil\n    }\n    var sorted = lst.sorted()\n\
    \    var unique = Set(sorted)\n    if unique.count == 1 {\n        return nil\n\
    \    }\n    for i in 1..<sorted.count {\n        if sorted[i] > sorted[0] {\n\
    \            return sorted[i]\n        }\n    }\n    return nil\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(next_smallest(lst: [1, 2, 3, 4, 5]) == 2)\nassert(next_smallest(lst:\
    \ [5, 1, 4, 3, 2]) == 2)\nassert(next_smallest(lst: [] as [Int]) == nil)\nassert(next_smallest(lst:\
    \ [1, 1]) == nil)\nassert(next_smallest(lst: [1, 1, 1, 1, 0]) == 1)\nassert(next_smallest(lst:\
    \ [1, 1]) == nil)\nassert(next_smallest(lst: [-35, 34, 12, -45]) == -35)"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660013381
- exit_code: -4
  program: "\n/// You are given an array of integers.\n/// Write a function next_smallest()\
    \ that returns the 2nd smallest element of the array.\n/// Return nil if there\
    \ is no such element.\n/// >>> next_smallest(lst: [1, 2, 3, 4, 5])\n/// 2\n///\
    \ >>> next_smallest(lst: [5, 1, 4, 3, 2])\n/// 2\n/// >>> next_smallest(lst: []\
    \ as [Int])\n/// nil\n/// >>> next_smallest(lst: [1, 1])\n/// nil\nfunc next_smallest(lst:\
    \ [Int]) -> Int? {\n    guard lst.count > 1 else { return nil }\n    var copiedLst\
    \ = lst\n    copiedLst.sort()\n    var previousValue = Int.min\n    for value\
    \ in copiedLst {\n        if value > previousValue {\n            previousValue\
    \ = value\n            break\n        }\n    }\n    return previousValue\n}\n\n\
    \nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(next_smallest(lst: [1, 2, 3, 4, 5]) == 2)\nassert(next_smallest(lst:\
    \ [5, 1, 4, 3, 2]) == 2)\nassert(next_smallest(lst: [] as [Int]) == nil)\nassert(next_smallest(lst:\
    \ [1, 1]) == nil)\nassert(next_smallest(lst: [1, 1, 1, 1, 0]) == 1)\nassert(next_smallest(lst:\
    \ [1, 1]) == nil)\nassert(next_smallest(lst: [-35, 34, 12, -45]) == -35)"
  status: Exception
  stderr: 'tmp9oo2o0t1/tmp9oo2o0t1.swift:40: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002ae39e4cac80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002ae39e1c1b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002ae39e1c1988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002ae39e1c07b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmp9oo2o0t1                        0x0000555fe05726c1 <unavailable> + 5825

    5    libc.so.6                          0x00002ae39e6b6460 __libc_start_main +
    245

    6    tmp9oo2o0t1                        0x0000555fe0572249 <unavailable> + 4681

    '
  stdout: ''
  timestamp: 1660013381
- exit_code: -4
  program: "\n/// You are given an array of integers.\n/// Write a function next_smallest()\
    \ that returns the 2nd smallest element of the array.\n/// Return nil if there\
    \ is no such element.\n/// >>> next_smallest(lst: [1, 2, 3, 4, 5])\n/// 2\n///\
    \ >>> next_smallest(lst: [5, 1, 4, 3, 2])\n/// 2\n/// >>> next_smallest(lst: []\
    \ as [Int])\n/// nil\n/// >>> next_smallest(lst: [1, 1])\n/// nil\nfunc next_smallest(lst:\
    \ [Int]) -> Int? {\n    \n    guard lst.count >= 2 else { return nil }\n    \n\
    \    let max = lst.count - 1\n    let min = 0\n    \n    var secondSmallest =\
    \ max\n    \n    for i in min..<max {\n        if lst[i] < lst[secondSmallest]\
    \ {\n            secondSmallest = i\n        }\n    }\n    \n    return lst[secondSmallest]\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(next_smallest(lst: [1, 2, 3, 4, 5]) == 2)\nassert(next_smallest(lst:\
    \ [5, 1, 4, 3, 2]) == 2)\nassert(next_smallest(lst: [] as [Int]) == nil)\nassert(next_smallest(lst:\
    \ [1, 1]) == nil)\nassert(next_smallest(lst: [1, 1, 1, 1, 0]) == 1)\nassert(next_smallest(lst:\
    \ [1, 1]) == nil)\nassert(next_smallest(lst: [-35, 34, 12, -45]) == -35)"
  status: Exception
  stderr: 'tmpv7_604a7/tmpv7_604a7.swift:44: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002acb4860dc80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002acb48304b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002acb48304988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002acb483037b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpv7_604a7                        0x000055b545f09621 <unavailable> + 5665

    5    libc.so.6                          0x00002acb487f9460 __libc_start_main +
    245

    6    tmpv7_604a7                        0x000055b545f091a9 <unavailable> + 4521

    '
  stdout: ''
  timestamp: 1660013381
- exit_code: -4
  program: "\n/// You are given an array of integers.\n/// Write a function next_smallest()\
    \ that returns the 2nd smallest element of the array.\n/// Return nil if there\
    \ is no such element.\n/// >>> next_smallest(lst: [1, 2, 3, 4, 5])\n/// 2\n///\
    \ >>> next_smallest(lst: [5, 1, 4, 3, 2])\n/// 2\n/// >>> next_smallest(lst: []\
    \ as [Int])\n/// nil\n/// >>> next_smallest(lst: [1, 1])\n/// nil\nfunc next_smallest(lst:\
    \ [Int]) -> Int? {\n    guard lst.count > 1 else { return nil }\n    var count\
    \ = 0\n    var nextSmallest = lst[0]\n    for i in 1..<lst.count {\n        if\
    \ nextSmallest > lst[i] {\n            nextSmallest = lst[i]\n            count\
    \ += 1\n        }\n    }\n    return count > 0 ? nextSmallest : nil\n}\n\n\nfunc\
    \ ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count !=\
    \ right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(next_smallest(lst: [1, 2, 3, 4, 5]) == 2)\nassert(next_smallest(lst:\
    \ [5, 1, 4, 3, 2]) == 2)\nassert(next_smallest(lst: [] as [Int]) == nil)\nassert(next_smallest(lst:\
    \ [1, 1]) == nil)\nassert(next_smallest(lst: [1, 1, 1, 1, 0]) == 1)\nassert(next_smallest(lst:\
    \ [1, 1]) == nil)\nassert(next_smallest(lst: [-35, 34, 12, -45]) == -35)"
  status: Exception
  stderr: 'tmp4n4bpbnh/tmp4n4bpbnh.swift:39: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002ab44288dc80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002ab442584b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002ab442584988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002ab4425837b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmp4n4bpbnh                        0x000055dac0339621 <unavailable> + 5665

    5    libc.so.6                          0x00002ab442a79460 __libc_start_main +
    245

    6    tmp4n4bpbnh                        0x000055dac03391a9 <unavailable> + 4521

    '
  stdout: ''
  timestamp: 1660013381
- exit_code: 0
  program: "\n/// You are given an array of integers.\n/// Write a function next_smallest()\
    \ that returns the 2nd smallest element of the array.\n/// Return nil if there\
    \ is no such element.\n/// >>> next_smallest(lst: [1, 2, 3, 4, 5])\n/// 2\n///\
    \ >>> next_smallest(lst: [5, 1, 4, 3, 2])\n/// 2\n/// >>> next_smallest(lst: []\
    \ as [Int])\n/// nil\n/// >>> next_smallest(lst: [1, 1])\n/// nil\nfunc next_smallest(lst:\
    \ [Int]) -> Int? {\n    let sorted = lst.sorted()\n    if sorted.count == 0 {\n\
    \        return nil\n    }\n    if sorted.count == 1 {\n        return nil\n \
    \   }\n    if sorted.count == 2 {\n        if sorted[0] == sorted[1] {\n     \
    \       return nil\n        }\n    }\n    for i in 0...sorted.count - 2 {\n  \
    \      if sorted[i] != sorted[i + 1] {\n            return sorted[i + 1]\n   \
    \     }\n    }\n    return nil\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int,\
    \ Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n\
    \    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n          \
    \  return false\n        }\n    }\n    return true\n}\n            \nassert(next_smallest(lst:\
    \ [1, 2, 3, 4, 5]) == 2)\nassert(next_smallest(lst: [5, 1, 4, 3, 2]) == 2)\nassert(next_smallest(lst:\
    \ [] as [Int]) == nil)\nassert(next_smallest(lst: [1, 1]) == nil)\nassert(next_smallest(lst:\
    \ [1, 1, 1, 1, 0]) == 1)\nassert(next_smallest(lst: [1, 1]) == nil)\nassert(next_smallest(lst:\
    \ [-35, 34, 12, -45]) == -35)"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660013381
- exit_code: -4
  program: "\n/// You are given an array of integers.\n/// Write a function next_smallest()\
    \ that returns the 2nd smallest element of the array.\n/// Return nil if there\
    \ is no such element.\n/// >>> next_smallest(lst: [1, 2, 3, 4, 5])\n/// 2\n///\
    \ >>> next_smallest(lst: [5, 1, 4, 3, 2])\n/// 2\n/// >>> next_smallest(lst: []\
    \ as [Int])\n/// nil\n/// >>> next_smallest(lst: [1, 1])\n/// nil\nfunc next_smallest(lst:\
    \ [Int]) -> Int? {\n    var sorted = lst.sorted()\n    if sorted.count > 1 {\n\
    \        for (index, _) in sorted.enumerated() {\n            if index > 0 {\n\
    \                if sorted[index] > sorted[index - 1] {\n                    return\
    \ sorted[index - 1]\n                }\n            }\n        }\n    }\n    return\
    \ nil\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n   \
    \ if left.count != right.count {\n        return false\n    }\n    for (l, r)\
    \ in zip(left, right) {\n        if l != r {\n            return false\n     \
    \   }\n    }\n    return true\n}\n            \nassert(next_smallest(lst: [1,\
    \ 2, 3, 4, 5]) == 2)\nassert(next_smallest(lst: [5, 1, 4, 3, 2]) == 2)\nassert(next_smallest(lst:\
    \ [] as [Int]) == nil)\nassert(next_smallest(lst: [1, 1]) == nil)\nassert(next_smallest(lst:\
    \ [1, 1, 1, 1, 0]) == 1)\nassert(next_smallest(lst: [1, 1]) == nil)\nassert(next_smallest(lst:\
    \ [-35, 34, 12, -45]) == -35)"
  status: Exception
  stderr: 'tmp858ctao1/tmp858ctao1.swift:40: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b646ffc0c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b646fcb7b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b646fcb7988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b646fcb67b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmp858ctao1                        0x000055da2af06741 <unavailable> + 5953

    5    libc.so.6                          0x00002b64701ac460 __libc_start_main +
    245

    6    tmp858ctao1                        0x000055da2af062c9 <unavailable> + 4809

    '
  stdout: ''
  timestamp: 1660013381
- exit_code: 0
  program: "\n/// You are given an array of integers.\n/// Write a function next_smallest()\
    \ that returns the 2nd smallest element of the array.\n/// Return nil if there\
    \ is no such element.\n/// >>> next_smallest(lst: [1, 2, 3, 4, 5])\n/// 2\n///\
    \ >>> next_smallest(lst: [5, 1, 4, 3, 2])\n/// 2\n/// >>> next_smallest(lst: []\
    \ as [Int])\n/// nil\n/// >>> next_smallest(lst: [1, 1])\n/// nil\nfunc next_smallest(lst:\
    \ [Int]) -> Int? {\n    var list = lst\n    list.sort()\n    if list.count > 1\
    \ {\n        var check = list[0]\n        for i in 1..<list.count {\n        \
    \    if list[i] > check {\n                return list[i]\n            }\n   \
    \     }\n    }\n    return nil\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int,\
    \ Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n\
    \    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n          \
    \  return false\n        }\n    }\n    return true\n}\n            \nassert(next_smallest(lst:\
    \ [1, 2, 3, 4, 5]) == 2)\nassert(next_smallest(lst: [5, 1, 4, 3, 2]) == 2)\nassert(next_smallest(lst:\
    \ [] as [Int]) == nil)\nassert(next_smallest(lst: [1, 1]) == nil)\nassert(next_smallest(lst:\
    \ [1, 1, 1, 1, 0]) == 1)\nassert(next_smallest(lst: [1, 1]) == nil)\nassert(next_smallest(lst:\
    \ [-35, 34, 12, -45]) == -35)"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660013381
- exit_code: -4
  program: "\n/// You are given an array of integers.\n/// Write a function next_smallest()\
    \ that returns the 2nd smallest element of the array.\n/// Return nil if there\
    \ is no such element.\n/// >>> next_smallest(lst: [1, 2, 3, 4, 5])\n/// 2\n///\
    \ >>> next_smallest(lst: [5, 1, 4, 3, 2])\n/// 2\n/// >>> next_smallest(lst: []\
    \ as [Int])\n/// nil\n/// >>> next_smallest(lst: [1, 1])\n/// nil\nfunc next_smallest(lst:\
    \ [Int]) -> Int? {\n    return lst.isEmpty ? nil : lst.sorted().count > 1 ? lst.sorted()[1]\
    \ : nil\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n \
    \   if left.count != right.count {\n        return false\n    }\n    for (l, r)\
    \ in zip(left, right) {\n        if l != r {\n            return false\n     \
    \   }\n    }\n    return true\n}\n            \nassert(next_smallest(lst: [1,\
    \ 2, 3, 4, 5]) == 2)\nassert(next_smallest(lst: [5, 1, 4, 3, 2]) == 2)\nassert(next_smallest(lst:\
    \ [] as [Int]) == nil)\nassert(next_smallest(lst: [1, 1]) == nil)\nassert(next_smallest(lst:\
    \ [1, 1, 1, 1, 0]) == 1)\nassert(next_smallest(lst: [1, 1]) == nil)\nassert(next_smallest(lst:\
    \ [-35, 34, 12, -45]) == -35)"
  status: Exception
  stderr: 'tmptb61jwna/tmptb61jwna.swift:33: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b83a4e7fc80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b83a4b76b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b83a4b76988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b83a4b757b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmptb61jwna                        0x000055a644bac94a <unavailable> + 6474

    5    libc.so.6                          0x00002b83a506b460 __libc_start_main +
    245

    6    tmptb61jwna                        0x000055a644bac149 <unavailable> + 4425

    '
  stdout: ''
  timestamp: 1660013381
- exit_code: 0
  program: "\n/// You are given an array of integers.\n/// Write a function next_smallest()\
    \ that returns the 2nd smallest element of the array.\n/// Return nil if there\
    \ is no such element.\n/// >>> next_smallest(lst: [1, 2, 3, 4, 5])\n/// 2\n///\
    \ >>> next_smallest(lst: [5, 1, 4, 3, 2])\n/// 2\n/// >>> next_smallest(lst: []\
    \ as [Int])\n/// nil\n/// >>> next_smallest(lst: [1, 1])\n/// nil\nfunc next_smallest(lst:\
    \ [Int]) -> Int? {\n    guard !lst.isEmpty else { return nil }\n    guard lst.count\
    \ > 1 else { return nil }\n    var dict: [Int: Int] = [:]\n    for (i, val) in\
    \ lst.enumerated() {\n        if dict[val] == nil {\n            dict[val] = i\n\
    \        }\n    }\n    let nums = Array(dict.keys).sorted()\n    guard nums.count\
    \ > 1 else { return nil }\n    return nums[1]\n}\n\n\nfunc ==(left: [(Int, Int)],\
    \ right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n       \
    \ return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r\
    \ {\n            return false\n        }\n    }\n    return true\n}\n        \
    \    \nassert(next_smallest(lst: [1, 2, 3, 4, 5]) == 2)\nassert(next_smallest(lst:\
    \ [5, 1, 4, 3, 2]) == 2)\nassert(next_smallest(lst: [] as [Int]) == nil)\nassert(next_smallest(lst:\
    \ [1, 1]) == nil)\nassert(next_smallest(lst: [1, 1, 1, 1, 0]) == 1)\nassert(next_smallest(lst:\
    \ [1, 1]) == nil)\nassert(next_smallest(lst: [-35, 34, 12, -45]) == -35)"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660013381
- exit_code: -4
  program: "\n/// You are given an array of integers.\n/// Write a function next_smallest()\
    \ that returns the 2nd smallest element of the array.\n/// Return nil if there\
    \ is no such element.\n/// >>> next_smallest(lst: [1, 2, 3, 4, 5])\n/// 2\n///\
    \ >>> next_smallest(lst: [5, 1, 4, 3, 2])\n/// 2\n/// >>> next_smallest(lst: []\
    \ as [Int])\n/// nil\n/// >>> next_smallest(lst: [1, 1])\n/// nil\nfunc next_smallest(lst:\
    \ [Int]) -> Int? {\n    if lst.count < 2 {\n        return nil\n    }\n    var\
    \ second = lst[0]\n    var first = lst[0]\n    for number in lst {\n        if\
    \ number < first {\n            second = first\n            first = number\n \
    \       } else if first < number && number < second {\n            second = number\n\
    \        }\n    }\n    return second\n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(next_smallest(lst: [1, 2, 3, 4, 5]) == 2)\nassert(next_smallest(lst: [5,\
    \ 1, 4, 3, 2]) == 2)\nassert(next_smallest(lst: [] as [Int]) == nil)\nassert(next_smallest(lst:\
    \ [1, 1]) == nil)\nassert(next_smallest(lst: [1, 1, 1, 1, 0]) == 1)\nassert(next_smallest(lst:\
    \ [1, 1]) == nil)\nassert(next_smallest(lst: [-35, 34, 12, -45]) == -35)"
  status: Exception
  stderr: 'tmppktsxj2b/tmppktsxj2b.swift:43: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002ae6015bec80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002ae6012b5b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002ae6012b5988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002ae6012b47b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmppktsxj2b                        0x0000558c8d859601 <unavailable> + 5633

    5    libc.so.6                          0x00002ae6017aa460 __libc_start_main +
    245

    6    tmppktsxj2b                        0x0000558c8d859189 <unavailable> + 4489

    '
  stdout: ''
  timestamp: 1660013381
- exit_code: -4
  program: "\n/// You are given an array of integers.\n/// Write a function next_smallest()\
    \ that returns the 2nd smallest element of the array.\n/// Return nil if there\
    \ is no such element.\n/// >>> next_smallest(lst: [1, 2, 3, 4, 5])\n/// 2\n///\
    \ >>> next_smallest(lst: [5, 1, 4, 3, 2])\n/// 2\n/// >>> next_smallest(lst: []\
    \ as [Int])\n/// nil\n/// >>> next_smallest(lst: [1, 1])\n/// nil\nfunc next_smallest(lst:\
    \ [Int]) -> Int? {\n    guard lst.count > 1 else { return nil }\n    var smallest\
    \ = lst[0]\n    var nextSmallest = nil as Int?\n    for i in 1..<lst.count {\n\
    \        if lst[i] < smallest {\n            nextSmallest = smallest\n       \
    \     smallest = lst[i]\n        } else if nextSmallest == nil || lst[i] < nextSmallest!\
    \ {\n            nextSmallest = lst[i]\n        }\n    }\n    return nextSmallest\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(next_smallest(lst: [1, 2, 3, 4, 5]) == 2)\nassert(next_smallest(lst:\
    \ [5, 1, 4, 3, 2]) == 2)\nassert(next_smallest(lst: [] as [Int]) == nil)\nassert(next_smallest(lst:\
    \ [1, 1]) == nil)\nassert(next_smallest(lst: [1, 1, 1, 1, 0]) == 1)\nassert(next_smallest(lst:\
    \ [1, 1]) == nil)\nassert(next_smallest(lst: [-35, 34, 12, -45]) == -35)"
  status: Exception
  stderr: 'tmpd6sez2vn/tmpd6sez2vn.swift:44: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b6d5de32c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b6d5db29b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b6d5db29988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b6d5db287b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpd6sez2vn                        0x00005573667c69aa <unavailable> + 6570

    5    libc.so.6                          0x00002b6d5e01e460 __libc_start_main +
    245

    6    tmpd6sez2vn                        0x00005573667c61a9 <unavailable> + 4521

    '
  stdout: ''
  timestamp: 1660013381
- exit_code: 0
  program: "\n/// You are given an array of integers.\n/// Write a function next_smallest()\
    \ that returns the 2nd smallest element of the array.\n/// Return nil if there\
    \ is no such element.\n/// >>> next_smallest(lst: [1, 2, 3, 4, 5])\n/// 2\n///\
    \ >>> next_smallest(lst: [5, 1, 4, 3, 2])\n/// 2\n/// >>> next_smallest(lst: []\
    \ as [Int])\n/// nil\n/// >>> next_smallest(lst: [1, 1])\n/// nil\nfunc next_smallest(lst:\
    \ [Int]) -> Int? {\n    let sorted = lst.sorted()\n    var previous: Int?\n  \
    \  for number in sorted {\n        if let previous = previous {\n            if\
    \ number != previous {\n                return number\n            }\n       \
    \ }\n        previous = number\n    }\n    return nil\n}\n\n\nfunc ==(left: [(Int,\
    \ Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n\
    \        return false\n    }\n    for (l, r) in zip(left, right) {\n        if\
    \ l != r {\n            return false\n        }\n    }\n    return true\n}\n \
    \           \nassert(next_smallest(lst: [1, 2, 3, 4, 5]) == 2)\nassert(next_smallest(lst:\
    \ [5, 1, 4, 3, 2]) == 2)\nassert(next_smallest(lst: [] as [Int]) == nil)\nassert(next_smallest(lst:\
    \ [1, 1]) == nil)\nassert(next_smallest(lst: [1, 1, 1, 1, 0]) == 1)\nassert(next_smallest(lst:\
    \ [1, 1]) == nil)\nassert(next_smallest(lst: [-35, 34, 12, -45]) == -35)"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660013381
- exit_code: 0
  program: "\n/// You are given an array of integers.\n/// Write a function next_smallest()\
    \ that returns the 2nd smallest element of the array.\n/// Return nil if there\
    \ is no such element.\n/// >>> next_smallest(lst: [1, 2, 3, 4, 5])\n/// 2\n///\
    \ >>> next_smallest(lst: [5, 1, 4, 3, 2])\n/// 2\n/// >>> next_smallest(lst: []\
    \ as [Int])\n/// nil\n/// >>> next_smallest(lst: [1, 1])\n/// nil\nfunc next_smallest(lst:\
    \ [Int]) -> Int? {\n    var num = lst.sorted()\n    if num.count == 0 || num.count\
    \ == 1 {\n        return nil\n    } else {\n        var i = 0\n        while i\
    \ < num.count - 1 {\n            if num[i] != num[i + 1] {\n                return\
    \ num[i + 1]\n            }\n            i += 1\n        }\n        return nil\n\
    \    }\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n  \
    \  if left.count != right.count {\n        return false\n    }\n    for (l, r)\
    \ in zip(left, right) {\n        if l != r {\n            return false\n     \
    \   }\n    }\n    return true\n}\n            \nassert(next_smallest(lst: [1,\
    \ 2, 3, 4, 5]) == 2)\nassert(next_smallest(lst: [5, 1, 4, 3, 2]) == 2)\nassert(next_smallest(lst:\
    \ [] as [Int]) == nil)\nassert(next_smallest(lst: [1, 1]) == nil)\nassert(next_smallest(lst:\
    \ [1, 1, 1, 1, 0]) == 1)\nassert(next_smallest(lst: [1, 1]) == nil)\nassert(next_smallest(lst:\
    \ [-35, 34, 12, -45]) == -35)"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660013381
- exit_code: -4
  program: "\n/// You are given an array of integers.\n/// Write a function next_smallest()\
    \ that returns the 2nd smallest element of the array.\n/// Return nil if there\
    \ is no such element.\n/// >>> next_smallest(lst: [1, 2, 3, 4, 5])\n/// 2\n///\
    \ >>> next_smallest(lst: [5, 1, 4, 3, 2])\n/// 2\n/// >>> next_smallest(lst: []\
    \ as [Int])\n/// nil\n/// >>> next_smallest(lst: [1, 1])\n/// nil\nfunc next_smallest(lst:\
    \ [Int]) -> Int? {\n    return lst.count > 1 ? Set(lst).sorted()[1] : nil\n}\n\
    \n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(next_smallest(lst: [1, 2, 3, 4, 5]) == 2)\nassert(next_smallest(lst:\
    \ [5, 1, 4, 3, 2]) == 2)\nassert(next_smallest(lst: [] as [Int]) == nil)\nassert(next_smallest(lst:\
    \ [1, 1]) == nil)\nassert(next_smallest(lst: [1, 1, 1, 1, 0]) == 1)\nassert(next_smallest(lst:\
    \ [1, 1]) == nil)\nassert(next_smallest(lst: [-35, 34, 12, -45]) == -35)"
  status: Exception
  stderr: 'Swift/ContiguousArrayBuffer.swift:600: Fatal error: Index out of range

    Current stack trace:

    0    libswiftCore.so                    0x00002aeb224d5c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002aeb221cc561 <unavailable> + 1434977

    2    libswiftCore.so                    0x00002aeb221cc286 <unavailable> + 1434246

    3    libswiftCore.so                    0x00002aeb221cc13c <unavailable> + 1433916

    4    libswiftCore.so                    0x00002aeb221cbbb0 _assertionFailure(_:_:file:line:flags:)
    + 251

    5    libswiftSwiftOnoneSupport.so       0x00002aeb21fcbe83 <unavailable> + 188035

    6    tmp3s95opgu                        0x000056413ab6bef3 <unavailable> + 7923

    7    tmp3s95opgu                        0x000056413ab6b8ea <unavailable> + 6378

    8    libc.so.6                          0x00002aeb226c1460 __libc_start_main +
    245

    9    tmp3s95opgu                        0x000056413ab6b1a9 <unavailable> + 4521

    '
  stdout: ''
  timestamp: 1660013381
- exit_code: -4
  program: "\n/// You are given an array of integers.\n/// Write a function next_smallest()\
    \ that returns the 2nd smallest element of the array.\n/// Return nil if there\
    \ is no such element.\n/// >>> next_smallest(lst: [1, 2, 3, 4, 5])\n/// 2\n///\
    \ >>> next_smallest(lst: [5, 1, 4, 3, 2])\n/// 2\n/// >>> next_smallest(lst: []\
    \ as [Int])\n/// nil\n/// >>> next_smallest(lst: [1, 1])\n/// nil\nfunc next_smallest(lst:\
    \ [Int]) -> Int? {\n    var min = lst[0]\n    var secondMin = Int.max\n    for\
    \ elem in lst {\n        if elem < min {\n            secondMin = min\n      \
    \      min = elem\n        } else if elem < secondMin && elem != min {\n     \
    \       secondMin = elem\n        }\n    }\n    return secondMin == Int.max ?\
    \ nil : secondMin\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) ->\
    \ Bool {\n    if left.count != right.count {\n        return false\n    }\n  \
    \  for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(next_smallest(lst:\
    \ [1, 2, 3, 4, 5]) == 2)\nassert(next_smallest(lst: [5, 1, 4, 3, 2]) == 2)\nassert(next_smallest(lst:\
    \ [] as [Int]) == nil)\nassert(next_smallest(lst: [1, 1]) == nil)\nassert(next_smallest(lst:\
    \ [1, 1, 1, 1, 0]) == 1)\nassert(next_smallest(lst: [1, 1]) == nil)\nassert(next_smallest(lst:\
    \ [-35, 34, 12, -45]) == -35)"
  status: Exception
  stderr: 'Swift/ContiguousArrayBuffer.swift:600: Fatal error: Index out of range

    Current stack trace:

    0    libswiftCore.so                    0x00002b06a6e92c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b06a6b89561 <unavailable> + 1434977

    2    libswiftCore.so                    0x00002b06a6b89286 <unavailable> + 1434246

    3    libswiftCore.so                    0x00002b06a6b8913c <unavailable> + 1433916

    4    libswiftCore.so                    0x00002b06a6b88bb0 _assertionFailure(_:_:file:line:flags:)
    + 251

    5    libswiftSwiftOnoneSupport.so       0x00002b06a6988e83 <unavailable> + 188035

    6    tmp27mjf7dy                        0x000055726973be12 <unavailable> + 7698

    7    tmp27mjf7dy                        0x000055726973b768 <unavailable> + 5992

    8    libc.so.6                          0x00002b06a707e460 __libc_start_main +
    245

    9    tmp27mjf7dy                        0x000055726973b129 <unavailable> + 4393

    '
  stdout: ''
  timestamp: 1660013381
- exit_code: 0
  program: "\n/// You are given an array of integers.\n/// Write a function next_smallest()\
    \ that returns the 2nd smallest element of the array.\n/// Return nil if there\
    \ is no such element.\n/// >>> next_smallest(lst: [1, 2, 3, 4, 5])\n/// 2\n///\
    \ >>> next_smallest(lst: [5, 1, 4, 3, 2])\n/// 2\n/// >>> next_smallest(lst: []\
    \ as [Int])\n/// nil\n/// >>> next_smallest(lst: [1, 1])\n/// nil\nfunc next_smallest(lst:\
    \ [Int]) -> Int? {\n    guard lst.count > 1 else { return nil }\n    guard lst.count\
    \ != 2 else { return lst[0] == lst[1] ? nil : lst[1] }\n    let sortedList = lst.sorted()\n\
    \    return sortedList[1]\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(next_smallest(lst:\
    \ [1, 2, 3, 4, 5]) == 2)\nassert(next_smallest(lst: [5, 1, 4, 3, 2]) == 2)\nassert(next_smallest(lst:\
    \ [] as [Int]) == nil)\nassert(next_smallest(lst: [1, 1]) == nil)\nassert(next_smallest(lst:\
    \ [1, 1, 1, 1, 0]) == 1)\nassert(next_smallest(lst: [1, 1]) == nil)\nassert(next_smallest(lst:\
    \ [-35, 34, 12, -45]) == -35)"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660013381
- exit_code: -4
  program: "\n/// You are given an array of integers.\n/// Write a function next_smallest()\
    \ that returns the 2nd smallest element of the array.\n/// Return nil if there\
    \ is no such element.\n/// >>> next_smallest(lst: [1, 2, 3, 4, 5])\n/// 2\n///\
    \ >>> next_smallest(lst: [5, 1, 4, 3, 2])\n/// 2\n/// >>> next_smallest(lst: []\
    \ as [Int])\n/// nil\n/// >>> next_smallest(lst: [1, 1])\n/// nil\nfunc next_smallest(lst:\
    \ [Int]) -> Int? {\n    guard !lst.isEmpty else { return nil }\n    let sorted\
    \ = lst.sorted()\n    return sorted[1]\n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(next_smallest(lst: [1, 2, 3, 4, 5]) == 2)\nassert(next_smallest(lst: [5,\
    \ 1, 4, 3, 2]) == 2)\nassert(next_smallest(lst: [] as [Int]) == nil)\nassert(next_smallest(lst:\
    \ [1, 1]) == nil)\nassert(next_smallest(lst: [1, 1, 1, 1, 0]) == 1)\nassert(next_smallest(lst:\
    \ [1, 1]) == nil)\nassert(next_smallest(lst: [-35, 34, 12, -45]) == -35)"
  status: Exception
  stderr: 'tmp80nefujy/tmp80nefujy.swift:35: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b1032638c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b103232fb6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b103232f988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b103232e7b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmp80nefujy                        0x00005586057058fa <unavailable> + 6394

    5    libc.so.6                          0x00002b1032824460 __libc_start_main +
    245

    6    tmp80nefujy                        0x00005586057050f9 <unavailable> + 4345

    '
  stdout: ''
  timestamp: 1660013381
- exit_code: 0
  program: "\n/// You are given an array of integers.\n/// Write a function next_smallest()\
    \ that returns the 2nd smallest element of the array.\n/// Return nil if there\
    \ is no such element.\n/// >>> next_smallest(lst: [1, 2, 3, 4, 5])\n/// 2\n///\
    \ >>> next_smallest(lst: [5, 1, 4, 3, 2])\n/// 2\n/// >>> next_smallest(lst: []\
    \ as [Int])\n/// nil\n/// >>> next_smallest(lst: [1, 1])\n/// nil\nfunc next_smallest(lst:\
    \ [Int]) -> Int? {\n    if lst.count < 2 {\n        return nil\n    }\n    let\
    \ sorted = lst.sorted()\n    var smaller = sorted[0]\n    for i in 1..<sorted.count\
    \ {\n        if sorted[i] != smaller {\n            return sorted[i]\n       \
    \ }\n    }\n    return nil\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(next_smallest(lst:\
    \ [1, 2, 3, 4, 5]) == 2)\nassert(next_smallest(lst: [5, 1, 4, 3, 2]) == 2)\nassert(next_smallest(lst:\
    \ [] as [Int]) == nil)\nassert(next_smallest(lst: [1, 1]) == nil)\nassert(next_smallest(lst:\
    \ [1, 1, 1, 1, 0]) == 1)\nassert(next_smallest(lst: [1, 1]) == nil)\nassert(next_smallest(lst:\
    \ [-35, 34, 12, -45]) == -35)"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660013381
- exit_code: -4
  program: "\n/// You are given an array of integers.\n/// Write a function next_smallest()\
    \ that returns the 2nd smallest element of the array.\n/// Return nil if there\
    \ is no such element.\n/// >>> next_smallest(lst: [1, 2, 3, 4, 5])\n/// 2\n///\
    \ >>> next_smallest(lst: [5, 1, 4, 3, 2])\n/// 2\n/// >>> next_smallest(lst: []\
    \ as [Int])\n/// nil\n/// >>> next_smallest(lst: [1, 1])\n/// nil\nfunc next_smallest(lst:\
    \ [Int]) -> Int? {\n    guard lst.count > 1 else { return nil }\n    let min =\
    \ lst.min()!\n    let sorted = lst.sorted()\n    var next = min\n    for number\
    \ in sorted {\n        if number != min {\n            next = number\n       \
    \     break\n        }\n    }\n    return next\n}\n\n\nfunc ==(left: [(Int, Int)],\
    \ right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n       \
    \ return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r\
    \ {\n            return false\n        }\n    }\n    return true\n}\n        \
    \    \nassert(next_smallest(lst: [1, 2, 3, 4, 5]) == 2)\nassert(next_smallest(lst:\
    \ [5, 1, 4, 3, 2]) == 2)\nassert(next_smallest(lst: [] as [Int]) == nil)\nassert(next_smallest(lst:\
    \ [1, 1]) == nil)\nassert(next_smallest(lst: [1, 1, 1, 1, 0]) == 1)\nassert(next_smallest(lst:\
    \ [1, 1]) == nil)\nassert(next_smallest(lst: [-35, 34, 12, -45]) == -35)"
  status: Exception
  stderr: 'tmpoo5z5h2p/tmpoo5z5h2p.swift:43: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b128503dc80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b1284d34b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b1284d34988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b1284d337b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpoo5z5h2p                        0x0000563cd26d9aca <unavailable> + 6858

    5    libc.so.6                          0x00002b1285229460 __libc_start_main +
    245

    6    tmpoo5z5h2p                        0x0000563cd26d92c9 <unavailable> + 4809

    '
  stdout: ''
  timestamp: 1660013381
- exit_code: 0
  program: "\n/// You are given an array of integers.\n/// Write a function next_smallest()\
    \ that returns the 2nd smallest element of the array.\n/// Return nil if there\
    \ is no such element.\n/// >>> next_smallest(lst: [1, 2, 3, 4, 5])\n/// 2\n///\
    \ >>> next_smallest(lst: [5, 1, 4, 3, 2])\n/// 2\n/// >>> next_smallest(lst: []\
    \ as [Int])\n/// nil\n/// >>> next_smallest(lst: [1, 1])\n/// nil\nfunc next_smallest(lst:\
    \ [Int]) -> Int? {\n    guard lst.count > 2 else { return nil }\n    var list\
    \ = lst\n    list.sort()\n    return list[1]\n}\n\n\nfunc ==(left: [(Int, Int)],\
    \ right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n       \
    \ return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r\
    \ {\n            return false\n        }\n    }\n    return true\n}\n        \
    \    \nassert(next_smallest(lst: [1, 2, 3, 4, 5]) == 2)\nassert(next_smallest(lst:\
    \ [5, 1, 4, 3, 2]) == 2)\nassert(next_smallest(lst: [] as [Int]) == nil)\nassert(next_smallest(lst:\
    \ [1, 1]) == nil)\nassert(next_smallest(lst: [1, 1, 1, 1, 0]) == 1)\nassert(next_smallest(lst:\
    \ [1, 1]) == nil)\nassert(next_smallest(lst: [-35, 34, 12, -45]) == -35)"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660013381
- exit_code: -4
  program: "\n/// You are given an array of integers.\n/// Write a function next_smallest()\
    \ that returns the 2nd smallest element of the array.\n/// Return nil if there\
    \ is no such element.\n/// >>> next_smallest(lst: [1, 2, 3, 4, 5])\n/// 2\n///\
    \ >>> next_smallest(lst: [5, 1, 4, 3, 2])\n/// 2\n/// >>> next_smallest(lst: []\
    \ as [Int])\n/// nil\n/// >>> next_smallest(lst: [1, 1])\n/// nil\nfunc next_smallest(lst:\
    \ [Int]) -> Int? {\n    var min1 = lst[0]\n    var min2 = min1\n    for i in 1..<lst.count\
    \ {\n        if lst[i] < min1 {\n            min2 = min1\n            min1 = lst[i]\n\
    \        } else if lst[i] < min2 {\n            min2 = lst[i]\n        }\n   \
    \ }\n    return min2\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(next_smallest(lst:\
    \ [1, 2, 3, 4, 5]) == 2)\nassert(next_smallest(lst: [5, 1, 4, 3, 2]) == 2)\nassert(next_smallest(lst:\
    \ [] as [Int]) == nil)\nassert(next_smallest(lst: [1, 1]) == nil)\nassert(next_smallest(lst:\
    \ [1, 1, 1, 1, 0]) == 1)\nassert(next_smallest(lst: [1, 1]) == nil)\nassert(next_smallest(lst:\
    \ [-35, 34, 12, -45]) == -35)"
  status: Exception
  stderr: 'tmp4a922woq/tmp4a922woq.swift:40: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b23355edc80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b23352e4b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b23352e4988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b23352e37b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmp4a922woq                        0x000055e4d1032621 <unavailable> + 5665

    5    libc.so.6                          0x00002b23357d9460 __libc_start_main +
    245

    6    tmp4a922woq                        0x000055e4d10321a9 <unavailable> + 4521

    '
  stdout: ''
  timestamp: 1660013381
- exit_code: -4
  program: "\n/// You are given an array of integers.\n/// Write a function next_smallest()\
    \ that returns the 2nd smallest element of the array.\n/// Return nil if there\
    \ is no such element.\n/// >>> next_smallest(lst: [1, 2, 3, 4, 5])\n/// 2\n///\
    \ >>> next_smallest(lst: [5, 1, 4, 3, 2])\n/// 2\n/// >>> next_smallest(lst: []\
    \ as [Int])\n/// nil\n/// >>> next_smallest(lst: [1, 1])\n/// nil\nfunc next_smallest(lst:\
    \ [Int]) -> Int? {\n    guard !lst.isEmpty else { return nil }\n    guard lst.count\
    \ > 1 else { return nil }\n    var result = lst[0]\n    for i in 1..<lst.count\
    \ {\n        result = max(result, lst[i])\n    }\n    for i in 0..<lst.count {\n\
    \        if lst[i] < result {\n            result = lst[i]\n            break\n\
    \        }\n    }\n    return result\n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(next_smallest(lst: [1, 2, 3, 4, 5]) == 2)\nassert(next_smallest(lst: [5,\
    \ 1, 4, 3, 2]) == 2)\nassert(next_smallest(lst: [] as [Int]) == nil)\nassert(next_smallest(lst:\
    \ [1, 1]) == nil)\nassert(next_smallest(lst: [1, 1, 1, 1, 0]) == 1)\nassert(next_smallest(lst:\
    \ [1, 1]) == nil)\nassert(next_smallest(lst: [-35, 34, 12, -45]) == -35)"
  status: Exception
  stderr: 'tmpdrel9krj/tmpdrel9krj.swift:42: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002ac09d0d8c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002ac09cdcfb6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002ac09cdcf988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002ac09cdce7b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpdrel9krj                        0x0000564f389c6741 <unavailable> + 5953

    5    libc.so.6                          0x00002ac09d2c4460 __libc_start_main +
    245

    6    tmpdrel9krj                        0x0000564f389c62c9 <unavailable> + 4809

    '
  stdout: ''
  timestamp: 1660013381
- exit_code: -4
  program: "\n/// You are given an array of integers.\n/// Write a function next_smallest()\
    \ that returns the 2nd smallest element of the array.\n/// Return nil if there\
    \ is no such element.\n/// >>> next_smallest(lst: [1, 2, 3, 4, 5])\n/// 2\n///\
    \ >>> next_smallest(lst: [5, 1, 4, 3, 2])\n/// 2\n/// >>> next_smallest(lst: []\
    \ as [Int])\n/// nil\n/// >>> next_smallest(lst: [1, 1])\n/// nil\nfunc next_smallest(lst:\
    \ [Int]) -> Int? {\n  if lst.count < 2 {\n    return nil\n  }\n  var min = lst[0]\n\
    \  var second = lst[1]\n  if second < min {\n    let temp = min\n    min = second\n\
    \    second = temp\n  }\n  for num in lst {\n    if num < min {\n      second\
    \ = min\n      min = num\n    } else if num < second {\n      second = num\n \
    \   }\n  }\n  return second\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int,\
    \ Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n\
    \    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n          \
    \  return false\n        }\n    }\n    return true\n}\n            \nassert(next_smallest(lst:\
    \ [1, 2, 3, 4, 5]) == 2)\nassert(next_smallest(lst: [5, 1, 4, 3, 2]) == 2)\nassert(next_smallest(lst:\
    \ [] as [Int]) == nil)\nassert(next_smallest(lst: [1, 1]) == nil)\nassert(next_smallest(lst:\
    \ [1, 1, 1, 1, 0]) == 1)\nassert(next_smallest(lst: [1, 1]) == nil)\nassert(next_smallest(lst:\
    \ [-35, 34, 12, -45]) == -35)"
  status: Exception
  stderr: 'tmpcthf7is5/tmpcthf7is5.swift:48: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002ad794a62c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002ad794759b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002ad794759988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002ad7947587b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpcthf7is5                        0x00005591d255b601 <unavailable> + 5633

    5    libc.so.6                          0x00002ad794c4e460 __libc_start_main +
    245

    6    tmpcthf7is5                        0x00005591d255b189 <unavailable> + 4489

    '
  stdout: ''
  timestamp: 1660013381
- exit_code: 0
  program: "\n/// You are given an array of integers.\n/// Write a function next_smallest()\
    \ that returns the 2nd smallest element of the array.\n/// Return nil if there\
    \ is no such element.\n/// >>> next_smallest(lst: [1, 2, 3, 4, 5])\n/// 2\n///\
    \ >>> next_smallest(lst: [5, 1, 4, 3, 2])\n/// 2\n/// >>> next_smallest(lst: []\
    \ as [Int])\n/// nil\n/// >>> next_smallest(lst: [1, 1])\n/// nil\nfunc next_smallest(lst:\
    \ [Int]) -> Int? {\n    guard lst.count > 2 else { return nil }\n    return lst.sorted()[1]\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(next_smallest(lst: [1, 2, 3, 4, 5]) == 2)\nassert(next_smallest(lst:\
    \ [5, 1, 4, 3, 2]) == 2)\nassert(next_smallest(lst: [] as [Int]) == nil)\nassert(next_smallest(lst:\
    \ [1, 1]) == nil)\nassert(next_smallest(lst: [1, 1, 1, 1, 0]) == 1)\nassert(next_smallest(lst:\
    \ [1, 1]) == nil)\nassert(next_smallest(lst: [-35, 34, 12, -45]) == -35)"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660013381
- exit_code: -4
  program: "\n/// You are given an array of integers.\n/// Write a function next_smallest()\
    \ that returns the 2nd smallest element of the array.\n/// Return nil if there\
    \ is no such element.\n/// >>> next_smallest(lst: [1, 2, 3, 4, 5])\n/// 2\n///\
    \ >>> next_smallest(lst: [5, 1, 4, 3, 2])\n/// 2\n/// >>> next_smallest(lst: []\
    \ as [Int])\n/// nil\n/// >>> next_smallest(lst: [1, 1])\n/// nil\nfunc next_smallest(lst:\
    \ [Int]) -> Int? {\n    guard !lst.isEmpty else { return nil }\n    var currentMin\
    \ = lst[0]\n    var nextMin = Int.max\n    for i in 1..<lst.count {\n        if\
    \ lst[i] < currentMin {\n            nextMin = currentMin\n            currentMin\
    \ = lst[i]\n        } else if lst[i] < nextMin {\n            nextMin = lst[i]\n\
    \        }\n    }\n    return nextMin != Int.max ? nextMin : nil\n}\n\n\nfunc\
    \ ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count !=\
    \ right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(next_smallest(lst: [1, 2, 3, 4, 5]) == 2)\nassert(next_smallest(lst:\
    \ [5, 1, 4, 3, 2]) == 2)\nassert(next_smallest(lst: [] as [Int]) == nil)\nassert(next_smallest(lst:\
    \ [1, 1]) == nil)\nassert(next_smallest(lst: [1, 1, 1, 1, 0]) == 1)\nassert(next_smallest(lst:\
    \ [1, 1]) == nil)\nassert(next_smallest(lst: [-35, 34, 12, -45]) == -35)"
  status: Exception
  stderr: 'tmpkh_4xw67/tmpkh_4xw67.swift:44: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002ab176450c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002ab176147b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002ab176147988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002ab1761467b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpkh_4xw67                        0x000055e6e8a48a3a <unavailable> + 6714

    5    libc.so.6                          0x00002ab17663c460 __libc_start_main +
    245

    6    tmpkh_4xw67                        0x000055e6e8a48239 <unavailable> + 4665

    '
  stdout: ''
  timestamp: 1660013381
- exit_code: -4
  program: "\n/// You are given an array of integers.\n/// Write a function next_smallest()\
    \ that returns the 2nd smallest element of the array.\n/// Return nil if there\
    \ is no such element.\n/// >>> next_smallest(lst: [1, 2, 3, 4, 5])\n/// 2\n///\
    \ >>> next_smallest(lst: [5, 1, 4, 3, 2])\n/// 2\n/// >>> next_smallest(lst: []\
    \ as [Int])\n/// nil\n/// >>> next_smallest(lst: [1, 1])\n/// nil\nfunc next_smallest(lst:\
    \ [Int]) -> Int? {\n    var secondSmallest = 0\n    var smallest = lst[0]\n  \
    \  var n = 0\n    for i in lst {\n        if i < smallest {\n            secondSmallest\
    \ = smallest\n            smallest = i\n        } else if i < secondSmallest {\n\
    \            secondSmallest = i\n        }\n        n += 1\n    }\n    if n <\
    \ 2 {\n        return nil\n    }\n    return secondSmallest\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(next_smallest(lst: [1, 2, 3, 4, 5]) == 2)\nassert(next_smallest(lst:\
    \ [5, 1, 4, 3, 2]) == 2)\nassert(next_smallest(lst: [] as [Int]) == nil)\nassert(next_smallest(lst:\
    \ [1, 1]) == nil)\nassert(next_smallest(lst: [1, 1, 1, 1, 0]) == 1)\nassert(next_smallest(lst:\
    \ [1, 1]) == nil)\nassert(next_smallest(lst: [-35, 34, 12, -45]) == -35)"
  status: Exception
  stderr: 'tmpclo_k98l/tmpclo_k98l.swift:45: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b37dac00c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b37da8f7b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b37da8f7988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b37da8f67b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpclo_k98l                        0x0000556479cff5a1 <unavailable> + 5537

    5    libc.so.6                          0x00002b37dadec460 __libc_start_main +
    245

    6    tmpclo_k98l                        0x0000556479cff129 <unavailable> + 4393

    '
  stdout: ''
  timestamp: 1660013381
- exit_code: -4
  program: "\n/// You are given an array of integers.\n/// Write a function next_smallest()\
    \ that returns the 2nd smallest element of the array.\n/// Return nil if there\
    \ is no such element.\n/// >>> next_smallest(lst: [1, 2, 3, 4, 5])\n/// 2\n///\
    \ >>> next_smallest(lst: [5, 1, 4, 3, 2])\n/// 2\n/// >>> next_smallest(lst: []\
    \ as [Int])\n/// nil\n/// >>> next_smallest(lst: [1, 1])\n/// nil\nfunc next_smallest(lst:\
    \ [Int]) -> Int? {\n    if lst.count < 2 {\n        return nil\n    }\n    let\
    \ sortedLst = lst.sorted()\n    return sortedLst[1]\n}\n\n\nfunc ==(left: [(Int,\
    \ Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n\
    \        return false\n    }\n    for (l, r) in zip(left, right) {\n        if\
    \ l != r {\n            return false\n        }\n    }\n    return true\n}\n \
    \           \nassert(next_smallest(lst: [1, 2, 3, 4, 5]) == 2)\nassert(next_smallest(lst:\
    \ [5, 1, 4, 3, 2]) == 2)\nassert(next_smallest(lst: [] as [Int]) == nil)\nassert(next_smallest(lst:\
    \ [1, 1]) == nil)\nassert(next_smallest(lst: [1, 1, 1, 1, 0]) == 1)\nassert(next_smallest(lst:\
    \ [1, 1]) == nil)\nassert(next_smallest(lst: [-35, 34, 12, -45]) == -35)"
  status: Exception
  stderr: 'tmpyrq4rzaw/tmpyrq4rzaw.swift:37: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b00434afc80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b00431a6b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b00431a6988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b00431a57b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpyrq4rzaw                        0x000055ac3ca048ba <unavailable> + 6330

    5    libc.so.6                          0x00002b004369b460 __libc_start_main +
    245

    6    tmpyrq4rzaw                        0x000055ac3ca040b9 <unavailable> + 4281

    '
  stdout: ''
  timestamp: 1660013380
- exit_code: -4
  program: "\n/// You are given an array of integers.\n/// Write a function next_smallest()\
    \ that returns the 2nd smallest element of the array.\n/// Return nil if there\
    \ is no such element.\n/// >>> next_smallest(lst: [1, 2, 3, 4, 5])\n/// 2\n///\
    \ >>> next_smallest(lst: [5, 1, 4, 3, 2])\n/// 2\n/// >>> next_smallest(lst: []\
    \ as [Int])\n/// nil\n/// >>> next_smallest(lst: [1, 1])\n/// nil\nfunc next_smallest(lst:\
    \ [Int]) -> Int? {\n    var array = lst\n    array.sort()\n    var idx = 0\n \
    \   var previousValue = array[0]\n    for i in array {\n        if previousValue\
    \ != i {\n            idx += 1\n            if idx > 1 {\n                return\
    \ i\n            }\n        }\n        previousValue = i\n    }\n    return nil\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(next_smallest(lst: [1, 2, 3, 4, 5]) == 2)\nassert(next_smallest(lst:\
    \ [5, 1, 4, 3, 2]) == 2)\nassert(next_smallest(lst: [] as [Int]) == nil)\nassert(next_smallest(lst:\
    \ [1, 1]) == nil)\nassert(next_smallest(lst: [1, 1, 1, 1, 0]) == 1)\nassert(next_smallest(lst:\
    \ [1, 1]) == nil)\nassert(next_smallest(lst: [-35, 34, 12, -45]) == -35)"
  status: Exception
  stderr: 'tmpy8hqwrct/tmpy8hqwrct.swift:43: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002ac939ea0c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002ac939b97b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002ac939b97988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002ac939b967b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpy8hqwrct                        0x000056053c48c6c1 <unavailable> + 5825

    5    libc.so.6                          0x00002ac93a08c460 __libc_start_main +
    245

    6    tmpy8hqwrct                        0x000056053c48c249 <unavailable> + 4681

    '
  stdout: ''
  timestamp: 1660013381
- exit_code: 1
  program: "\n/// You are given an array of integers.\n/// Write a function next_smallest()\
    \ that returns the 2nd smallest element of the array.\n/// Return nil if there\
    \ is no such element.\n/// >>> next_smallest(lst: [1, 2, 3, 4, 5])\n/// 2\n///\
    \ >>> next_smallest(lst: [5, 1, 4, 3, 2])\n/// 2\n/// >>> next_smallest(lst: []\
    \ as [Int])\n/// nil\n/// >>> next_smallest(lst: [1, 1])\n/// nil\nfunc next_smallest(lst:\
    \ [Int]) -> Int? {\n    guard lst.count > 1 else { return nil }\n    return lst.sorted().unique().dropFirst().first\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(next_smallest(lst: [1, 2, 3, 4, 5]) == 2)\nassert(next_smallest(lst:\
    \ [5, 1, 4, 3, 2]) == 2)\nassert(next_smallest(lst: [] as [Int]) == nil)\nassert(next_smallest(lst:\
    \ [1, 1]) == nil)\nassert(next_smallest(lst: [1, 1, 1, 1, 0]) == 1)\nassert(next_smallest(lst:\
    \ [1, 1]) == nil)\nassert(next_smallest(lst: [-35, 34, 12, -45]) == -35)"
  status: SyntaxError
  stderr: "/tmp/tmpc4bp7lot.swift:15:25: error: value of type '[Int]' has no member\
    \ 'unique'\n    return lst.sorted().unique().dropFirst().first\n           ~~~~~~~~~~~~\
    \ ^~~~~~\n"
  stdout: ''
  timestamp: 1660013381
- exit_code: -4
  program: "\n/// You are given an array of integers.\n/// Write a function next_smallest()\
    \ that returns the 2nd smallest element of the array.\n/// Return nil if there\
    \ is no such element.\n/// >>> next_smallest(lst: [1, 2, 3, 4, 5])\n/// 2\n///\
    \ >>> next_smallest(lst: [5, 1, 4, 3, 2])\n/// 2\n/// >>> next_smallest(lst: []\
    \ as [Int])\n/// nil\n/// >>> next_smallest(lst: [1, 1])\n/// nil\nfunc next_smallest(lst:\
    \ [Int]) -> Int? {\n    if lst.count == 0 {\n        return nil\n    } else if\
    \ lst.count == 1 {\n        return nil\n    } else {\n        var smallest = lst[0]\n\
    \        var next_smallest = lst[1]\n        if smallest > next_smallest {\n \
    \           smallest = lst[1]\n            next_smallest = lst[0]\n        }\n\
    \        for i in 2..<lst.count {\n            if lst[i] < smallest {\n      \
    \          next_smallest = smallest\n                smallest = lst[i]\n     \
    \       } else if lst[i] < next_smallest {\n                next_smallest = lst[i]\n\
    \            }\n        }\n        return next_smallest\n    }\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(next_smallest(lst: [1, 2, 3, 4, 5]) == 2)\nassert(next_smallest(lst:\
    \ [5, 1, 4, 3, 2]) == 2)\nassert(next_smallest(lst: [] as [Int]) == nil)\nassert(next_smallest(lst:\
    \ [1, 1]) == nil)\nassert(next_smallest(lst: [1, 1, 1, 1, 0]) == 1)\nassert(next_smallest(lst:\
    \ [1, 1]) == nil)\nassert(next_smallest(lst: [-35, 34, 12, -45]) == -35)"
  status: Exception
  stderr: 'tmp7ak9nohy/tmp7ak9nohy.swift:53: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b425a8fcc80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b425a5f3b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b425a5f3988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b425a5f27b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmp7ak9nohy                        0x0000557773dd79aa <unavailable> + 6570

    5    libc.so.6                          0x00002b425aae8460 __libc_start_main +
    245

    6    tmp7ak9nohy                        0x0000557773dd71a9 <unavailable> + 4521

    '
  stdout: ''
  timestamp: 1660013381
- exit_code: -4
  program: "\n/// You are given an array of integers.\n/// Write a function next_smallest()\
    \ that returns the 2nd smallest element of the array.\n/// Return nil if there\
    \ is no such element.\n/// >>> next_smallest(lst: [1, 2, 3, 4, 5])\n/// 2\n///\
    \ >>> next_smallest(lst: [5, 1, 4, 3, 2])\n/// 2\n/// >>> next_smallest(lst: []\
    \ as [Int])\n/// nil\n/// >>> next_smallest(lst: [1, 1])\n/// nil\nfunc next_smallest(lst:\
    \ [Int]) -> Int? {\n  let sortedLst = lst.sorted()\n  if sortedLst.count <= 1\
    \ {\n    return nil\n  }\n  return sortedLst[1]\n}\n\n\nfunc ==(left: [(Int, Int)],\
    \ right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n       \
    \ return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r\
    \ {\n            return false\n        }\n    }\n    return true\n}\n        \
    \    \nassert(next_smallest(lst: [1, 2, 3, 4, 5]) == 2)\nassert(next_smallest(lst:\
    \ [5, 1, 4, 3, 2]) == 2)\nassert(next_smallest(lst: [] as [Int]) == nil)\nassert(next_smallest(lst:\
    \ [1, 1]) == nil)\nassert(next_smallest(lst: [1, 1, 1, 1, 0]) == 1)\nassert(next_smallest(lst:\
    \ [1, 1]) == nil)\nassert(next_smallest(lst: [-35, 34, 12, -45]) == -35)"
  status: Exception
  stderr: 'tmpd9kioj52/tmpd9kioj52.swift:37: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002accffa29c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002accff720b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002accff720988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002accff71f7b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpd9kioj52                        0x0000562fac7a58ba <unavailable> + 6330

    5    libc.so.6                          0x00002accffc15460 __libc_start_main +
    245

    6    tmpd9kioj52                        0x0000562fac7a50b9 <unavailable> + 4281

    '
  stdout: ''
  timestamp: 1660013381
- exit_code: -4
  program: "\n/// You are given an array of integers.\n/// Write a function next_smallest()\
    \ that returns the 2nd smallest element of the array.\n/// Return nil if there\
    \ is no such element.\n/// >>> next_smallest(lst: [1, 2, 3, 4, 5])\n/// 2\n///\
    \ >>> next_smallest(lst: [5, 1, 4, 3, 2])\n/// 2\n/// >>> next_smallest(lst: []\
    \ as [Int])\n/// nil\n/// >>> next_smallest(lst: [1, 1])\n/// nil\nfunc next_smallest(lst:\
    \ [Int]) -> Int? {\n    guard lst.count > 1 else { return nil }\n    let (sm1,\
    \ sm2) = lst.reduce((lst[0], nil)) { (x: (Int, Int?), y: Int) -> (Int, Int?) in\n\
    \        if y > x.0 {\n            return (x.0, y)\n        } else if x.1 == nil\
    \ || y > x.1! {\n            return (y, x.1)\n        } else {\n            return\
    \ (x.0, x.1)\n        }\n    }\n    return sm2\n}\n\n\nfunc ==(left: [(Int, Int)],\
    \ right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n       \
    \ return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r\
    \ {\n            return false\n        }\n    }\n    return true\n}\n        \
    \    \nassert(next_smallest(lst: [1, 2, 3, 4, 5]) == 2)\nassert(next_smallest(lst:\
    \ [5, 1, 4, 3, 2]) == 2)\nassert(next_smallest(lst: [] as [Int]) == nil)\nassert(next_smallest(lst:\
    \ [1, 1]) == nil)\nassert(next_smallest(lst: [1, 1, 1, 1, 0]) == 1)\nassert(next_smallest(lst:\
    \ [1, 1]) == nil)\nassert(next_smallest(lst: [-35, 34, 12, -45]) == -35)"
  status: Exception
  stderr: 'tmp4t9w95it/tmp4t9w95it.swift:40: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002af2adc96c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002af2ad98db6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002af2ad98d988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002af2ad98c7b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmp4t9w95it                        0x00005566f49265a1 <unavailable> + 5537

    5    libc.so.6                          0x00002af2ade82460 __libc_start_main +
    245

    6    tmp4t9w95it                        0x00005566f4926129 <unavailable> + 4393

    '
  stdout: ''
  timestamp: 1660013381
- exit_code: -4
  program: "\n/// You are given an array of integers.\n/// Write a function next_smallest()\
    \ that returns the 2nd smallest element of the array.\n/// Return nil if there\
    \ is no such element.\n/// >>> next_smallest(lst: [1, 2, 3, 4, 5])\n/// 2\n///\
    \ >>> next_smallest(lst: [5, 1, 4, 3, 2])\n/// 2\n/// >>> next_smallest(lst: []\
    \ as [Int])\n/// nil\n/// >>> next_smallest(lst: [1, 1])\n/// nil\nfunc next_smallest(lst:\
    \ [Int]) -> Int? {\n    var smallest = Int.max\n    var secondSmallest = Int.max\n\
    \    for n in lst {\n        if n < smallest {\n            secondSmallest = smallest\n\
    \            smallest = n\n        } else if n < secondSmallest {\n          \
    \  secondSmallest = n\n        }\n    }\n    return (secondSmallest == Int.max)\
    \ ? nil : secondSmallest\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(next_smallest(lst:\
    \ [1, 2, 3, 4, 5]) == 2)\nassert(next_smallest(lst: [5, 1, 4, 3, 2]) == 2)\nassert(next_smallest(lst:\
    \ [] as [Int]) == nil)\nassert(next_smallest(lst: [1, 1]) == nil)\nassert(next_smallest(lst:\
    \ [1, 1, 1, 1, 0]) == 1)\nassert(next_smallest(lst: [1, 1]) == nil)\nassert(next_smallest(lst:\
    \ [-35, 34, 12, -45]) == -35)"
  status: Exception
  stderr: 'tmpc9hks_0j/tmpc9hks_0j.swift:43: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b7e8867ac80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b7e88371b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b7e88371988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b7e883707b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpc9hks_0j                        0x000055f757c668da <unavailable> + 6362

    5    libc.so.6                          0x00002b7e88866460 __libc_start_main +
    245

    6    tmpc9hks_0j                        0x000055f757c660d9 <unavailable> + 4313

    '
  stdout: ''
  timestamp: 1660013381
- exit_code: -4
  program: "\n/// You are given an array of integers.\n/// Write a function next_smallest()\
    \ that returns the 2nd smallest element of the array.\n/// Return nil if there\
    \ is no such element.\n/// >>> next_smallest(lst: [1, 2, 3, 4, 5])\n/// 2\n///\
    \ >>> next_smallest(lst: [5, 1, 4, 3, 2])\n/// 2\n/// >>> next_smallest(lst: []\
    \ as [Int])\n/// nil\n/// >>> next_smallest(lst: [1, 1])\n/// nil\nfunc next_smallest(lst:\
    \ [Int]) -> Int? {\n    if lst.count < 2 {\n        return nil\n    }\n    var\
    \ min = lst[0]\n    var ret = lst[1]\n    for i in 1..<lst.count {\n        if\
    \ lst[i] < min {\n            ret = min\n            min = lst[i]\n        } else\
    \ if lst[i] < ret {\n            ret = lst[i]\n        }\n    }\n    return ret\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(next_smallest(lst: [1, 2, 3, 4, 5]) == 2)\nassert(next_smallest(lst:\
    \ [5, 1, 4, 3, 2]) == 2)\nassert(next_smallest(lst: [] as [Int]) == nil)\nassert(next_smallest(lst:\
    \ [1, 1]) == nil)\nassert(next_smallest(lst: [1, 1, 1, 1, 0]) == 1)\nassert(next_smallest(lst:\
    \ [1, 1]) == nil)\nassert(next_smallest(lst: [-35, 34, 12, -45]) == -35)"
  status: Exception
  stderr: 'tmpefhu0lur/tmpefhu0lur.swift:46: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b288cb3cc80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b288c833b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b288c833988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b288c8327b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpefhu0lur                        0x0000558e9d4aa9aa <unavailable> + 6570

    5    libc.so.6                          0x00002b288cd28460 __libc_start_main +
    245

    6    tmpefhu0lur                        0x0000558e9d4aa1a9 <unavailable> + 4521

    '
  stdout: ''
  timestamp: 1660013381
- exit_code: -4
  program: "\n/// You are given an array of integers.\n/// Write a function next_smallest()\
    \ that returns the 2nd smallest element of the array.\n/// Return nil if there\
    \ is no such element.\n/// >>> next_smallest(lst: [1, 2, 3, 4, 5])\n/// 2\n///\
    \ >>> next_smallest(lst: [5, 1, 4, 3, 2])\n/// 2\n/// >>> next_smallest(lst: []\
    \ as [Int])\n/// nil\n/// >>> next_smallest(lst: [1, 1])\n/// nil\nfunc next_smallest(lst:\
    \ [Int]) -> Int? {\n    var m: Int? = nil\n    var n: Int? = nil\n    for i in\
    \ lst {\n        if let x = m {\n            if i < x {\n                n = m\n\
    \                m = i\n            } else if i < n ?? x {\n                n\
    \ = i\n            }\n        } else {\n            m = i\n        }\n    }\n\
    \    return n\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool\
    \ {\n    if left.count != right.count {\n        return false\n    }\n    for\
    \ (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(next_smallest(lst:\
    \ [1, 2, 3, 4, 5]) == 2)\nassert(next_smallest(lst: [5, 1, 4, 3, 2]) == 2)\nassert(next_smallest(lst:\
    \ [] as [Int]) == nil)\nassert(next_smallest(lst: [1, 1]) == nil)\nassert(next_smallest(lst:\
    \ [1, 1, 1, 1, 0]) == 1)\nassert(next_smallest(lst: [1, 1]) == nil)\nassert(next_smallest(lst:\
    \ [-35, 34, 12, -45]) == -35)"
  status: Exception
  stderr: 'tmp68hi119w/tmp68hi119w.swift:44: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b828e9f7c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b828e6eeb6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b828e6ee988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b828e6ed7b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmp68hi119w                        0x000055f6f44c3551 <unavailable> + 5457

    5    libc.so.6                          0x00002b828ebe3460 __libc_start_main +
    245

    6    tmp68hi119w                        0x000055f6f44c30d9 <unavailable> + 4313

    '
  stdout: ''
  timestamp: 1660013381
- exit_code: 0
  program: "\n/// You are given an array of integers.\n/// Write a function next_smallest()\
    \ that returns the 2nd smallest element of the array.\n/// Return nil if there\
    \ is no such element.\n/// >>> next_smallest(lst: [1, 2, 3, 4, 5])\n/// 2\n///\
    \ >>> next_smallest(lst: [5, 1, 4, 3, 2])\n/// 2\n/// >>> next_smallest(lst: []\
    \ as [Int])\n/// nil\n/// >>> next_smallest(lst: [1, 1])\n/// nil\nfunc next_smallest(lst:\
    \ [Int]) -> Int? {\n    if lst.count == 0 {\n        return nil\n    }\n    let\
    \ minValue = lst.min()\n    let lstMinusMinValue = lst.filter({ $0 != minValue\
    \ })\n    return lstMinusMinValue.min()\n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(next_smallest(lst: [1, 2, 3, 4, 5]) == 2)\nassert(next_smallest(lst: [5,\
    \ 1, 4, 3, 2]) == 2)\nassert(next_smallest(lst: [] as [Int]) == nil)\nassert(next_smallest(lst:\
    \ [1, 1]) == nil)\nassert(next_smallest(lst: [1, 1, 1, 1, 0]) == 1)\nassert(next_smallest(lst:\
    \ [1, 1]) == nil)\nassert(next_smallest(lst: [-35, 34, 12, -45]) == -35)"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660013381
- exit_code: -4
  program: "\n/// You are given an array of integers.\n/// Write a function next_smallest()\
    \ that returns the 2nd smallest element of the array.\n/// Return nil if there\
    \ is no such element.\n/// >>> next_smallest(lst: [1, 2, 3, 4, 5])\n/// 2\n///\
    \ >>> next_smallest(lst: [5, 1, 4, 3, 2])\n/// 2\n/// >>> next_smallest(lst: []\
    \ as [Int])\n/// nil\n/// >>> next_smallest(lst: [1, 1])\n/// nil\nfunc next_smallest(lst:\
    \ [Int]) -> Int? {\n    return nil\n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(next_smallest(lst: [1, 2, 3, 4, 5]) == 2)\nassert(next_smallest(lst: [5,\
    \ 1, 4, 3, 2]) == 2)\nassert(next_smallest(lst: [] as [Int]) == nil)\nassert(next_smallest(lst:\
    \ [1, 1]) == nil)\nassert(next_smallest(lst: [1, 1, 1, 1, 0]) == 1)\nassert(next_smallest(lst:\
    \ [1, 1]) == nil)\nassert(next_smallest(lst: [-35, 34, 12, -45]) == -35)"
  status: Exception
  stderr: 'tmp2hp7hj7n/tmp2hp7hj7n.swift:30: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002afccf398c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002afccf08fb6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002afccf08f988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002afccf08e7b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmp2hp7hj7n                        0x0000560c9b7333e1 <unavailable> + 5089

    5    libc.so.6                          0x00002afccf584460 __libc_start_main +
    245

    6    tmp2hp7hj7n                        0x0000560c9b732f69 <unavailable> + 3945

    '
  stdout: ''
  timestamp: 1660013380
- exit_code: -4
  program: "\n/// You are given an array of integers.\n/// Write a function next_smallest()\
    \ that returns the 2nd smallest element of the array.\n/// Return nil if there\
    \ is no such element.\n/// >>> next_smallest(lst: [1, 2, 3, 4, 5])\n/// 2\n///\
    \ >>> next_smallest(lst: [5, 1, 4, 3, 2])\n/// 2\n/// >>> next_smallest(lst: []\
    \ as [Int])\n/// nil\n/// >>> next_smallest(lst: [1, 1])\n/// nil\nfunc next_smallest(lst:\
    \ [Int]) -> Int? {\n    guard lst.count > 1 else { return nil }\n    let sorted\
    \ = lst.sorted()\n    return sorted[1]\n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(next_smallest(lst: [1, 2, 3, 4, 5]) == 2)\nassert(next_smallest(lst: [5,\
    \ 1, 4, 3, 2]) == 2)\nassert(next_smallest(lst: [] as [Int]) == nil)\nassert(next_smallest(lst:\
    \ [1, 1]) == nil)\nassert(next_smallest(lst: [1, 1, 1, 1, 0]) == 1)\nassert(next_smallest(lst:\
    \ [1, 1]) == nil)\nassert(next_smallest(lst: [-35, 34, 12, -45]) == -35)"
  status: Exception
  stderr: 'tmp8y8mztze/tmp8y8mztze.swift:35: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b276daedc80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b276d7e4b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b276d7e4988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b276d7e37b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmp8y8mztze                        0x000055cf36f688ba <unavailable> + 6330

    5    libc.so.6                          0x00002b276dcd9460 __libc_start_main +
    245

    6    tmp8y8mztze                        0x000055cf36f680b9 <unavailable> + 4281

    '
  stdout: ''
  timestamp: 1660013218
- exit_code: -4
  program: "\n/// You are given an array of integers.\n/// Write a function next_smallest()\
    \ that returns the 2nd smallest element of the array.\n/// Return nil if there\
    \ is no such element.\n/// >>> next_smallest(lst: [1, 2, 3, 4, 5])\n/// 2\n///\
    \ >>> next_smallest(lst: [5, 1, 4, 3, 2])\n/// 2\n/// >>> next_smallest(lst: []\
    \ as [Int])\n/// nil\n/// >>> next_smallest(lst: [1, 1])\n/// nil\nfunc next_smallest(lst:\
    \ [Int]) -> Int? {\n    let sortedLst = lst.sorted()\n    for i in 1..<sortedLst.count\
    \ {\n        if sortedLst[i - 1] != sortedLst[i] {\n            return sortedLst[i]\n\
    \        }\n    }\n    return nil\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int,\
    \ Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n\
    \    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n          \
    \  return false\n        }\n    }\n    return true\n}\n            \nassert(next_smallest(lst:\
    \ [1, 2, 3, 4, 5]) == 2)\nassert(next_smallest(lst: [5, 1, 4, 3, 2]) == 2)\nassert(next_smallest(lst:\
    \ [] as [Int]) == nil)\nassert(next_smallest(lst: [1, 1]) == nil)\nassert(next_smallest(lst:\
    \ [1, 1, 1, 1, 0]) == 1)\nassert(next_smallest(lst: [1, 1]) == nil)\nassert(next_smallest(lst:\
    \ [-35, 34, 12, -45]) == -35)"
  status: Exception
  stderr: 'Swift/Range.swift:743: Fatal error: Range requires lowerBound <= upperBound

    Current stack trace:

    0    libswiftCore.so                    0x00002ab4ced66c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002ab4cea5d561 <unavailable> + 1434977

    2    libswiftCore.so                    0x00002ab4cea5d286 <unavailable> + 1434246

    3    libswiftCore.so                    0x00002ab4cea5d13c <unavailable> + 1433916

    4    libswiftCore.so                    0x00002ab4cea5cbb0 _assertionFailure(_:_:file:line:flags:)
    + 251

    5    tmpf7eahj0e                        0x000055efabb68004 <unavailable> + 8196

    6    tmpf7eahj0e                        0x000055efabb67888 <unavailable> + 6280

    7    libc.so.6                          0x00002ab4cef52460 __libc_start_main +
    245

    8    tmpf7eahj0e                        0x000055efabb67249 <unavailable> + 4681

    '
  stdout: ''
  timestamp: 1660013381
- exit_code: 0
  program: "\n/// You are given an array of integers.\n/// Write a function next_smallest()\
    \ that returns the 2nd smallest element of the array.\n/// Return nil if there\
    \ is no such element.\n/// >>> next_smallest(lst: [1, 2, 3, 4, 5])\n/// 2\n///\
    \ >>> next_smallest(lst: [5, 1, 4, 3, 2])\n/// 2\n/// >>> next_smallest(lst: []\
    \ as [Int])\n/// nil\n/// >>> next_smallest(lst: [1, 1])\n/// nil\nfunc next_smallest(lst:\
    \ [Int]) -> Int? {\n    var numbers = lst\n    numbers.sort(by: <)\n    let smallest\
    \ = numbers.first\n    var secondSmallest: Int?\n    for number in numbers {\n\
    \        if number > smallest! {\n            secondSmallest = number\n      \
    \      break\n        }\n    }\n    return secondSmallest\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(next_smallest(lst: [1, 2, 3, 4, 5]) == 2)\nassert(next_smallest(lst:\
    \ [5, 1, 4, 3, 2]) == 2)\nassert(next_smallest(lst: [] as [Int]) == nil)\nassert(next_smallest(lst:\
    \ [1, 1]) == nil)\nassert(next_smallest(lst: [1, 1, 1, 1, 0]) == 1)\nassert(next_smallest(lst:\
    \ [1, 1]) == nil)\nassert(next_smallest(lst: [-35, 34, 12, -45]) == -35)"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660013381
- exit_code: 0
  program: "\n/// You are given an array of integers.\n/// Write a function next_smallest()\
    \ that returns the 2nd smallest element of the array.\n/// Return nil if there\
    \ is no such element.\n/// >>> next_smallest(lst: [1, 2, 3, 4, 5])\n/// 2\n///\
    \ >>> next_smallest(lst: [5, 1, 4, 3, 2])\n/// 2\n/// >>> next_smallest(lst: []\
    \ as [Int])\n/// nil\n/// >>> next_smallest(lst: [1, 1])\n/// nil\nfunc next_smallest(lst:\
    \ [Int]) -> Int? {\n    guard lst.count > 1 else { return nil }\n    var sorted\
    \ = lst.sorted()\n    var smallest = sorted.removeFirst()\n    for i in sorted\
    \ {\n        if i != smallest {\n            return i\n        }\n    }\n    return\
    \ nil\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n   \
    \ if left.count != right.count {\n        return false\n    }\n    for (l, r)\
    \ in zip(left, right) {\n        if l != r {\n            return false\n     \
    \   }\n    }\n    return true\n}\n            \nassert(next_smallest(lst: [1,\
    \ 2, 3, 4, 5]) == 2)\nassert(next_smallest(lst: [5, 1, 4, 3, 2]) == 2)\nassert(next_smallest(lst:\
    \ [] as [Int]) == nil)\nassert(next_smallest(lst: [1, 1]) == nil)\nassert(next_smallest(lst:\
    \ [1, 1, 1, 1, 0]) == 1)\nassert(next_smallest(lst: [1, 1]) == nil)\nassert(next_smallest(lst:\
    \ [-35, 34, 12, -45]) == -35)"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660013381
- exit_code: -4
  program: "\n/// You are given an array of integers.\n/// Write a function next_smallest()\
    \ that returns the 2nd smallest element of the array.\n/// Return nil if there\
    \ is no such element.\n/// >>> next_smallest(lst: [1, 2, 3, 4, 5])\n/// 2\n///\
    \ >>> next_smallest(lst: [5, 1, 4, 3, 2])\n/// 2\n/// >>> next_smallest(lst: []\
    \ as [Int])\n/// nil\n/// >>> next_smallest(lst: [1, 1])\n/// nil\nfunc next_smallest(lst:\
    \ [Int]) -> Int? {\n    return nil\n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(next_smallest(lst: [1, 2, 3, 4, 5]) == 2)\nassert(next_smallest(lst: [5,\
    \ 1, 4, 3, 2]) == 2)\nassert(next_smallest(lst: [] as [Int]) == nil)\nassert(next_smallest(lst:\
    \ [1, 1]) == nil)\nassert(next_smallest(lst: [1, 1, 1, 1, 0]) == 1)\nassert(next_smallest(lst:\
    \ [1, 1]) == nil)\nassert(next_smallest(lst: [-35, 34, 12, -45]) == -35)"
  status: Exception
  stderr: 'tmp2hp7hj7n/tmp2hp7hj7n.swift:30: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002afccf398c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002afccf08fb6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002afccf08f988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002afccf08e7b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmp2hp7hj7n                        0x0000560c9b7333e1 <unavailable> + 5089

    5    libc.so.6                          0x00002afccf584460 __libc_start_main +
    245

    6    tmp2hp7hj7n                        0x0000560c9b732f69 <unavailable> + 3945

    '
  stdout: ''
  timestamp: 1660013380
- exit_code: -4
  program: "\n/// You are given an array of integers.\n/// Write a function next_smallest()\
    \ that returns the 2nd smallest element of the array.\n/// Return nil if there\
    \ is no such element.\n/// >>> next_smallest(lst: [1, 2, 3, 4, 5])\n/// 2\n///\
    \ >>> next_smallest(lst: [5, 1, 4, 3, 2])\n/// 2\n/// >>> next_smallest(lst: []\
    \ as [Int])\n/// nil\n/// >>> next_smallest(lst: [1, 1])\n/// nil\nfunc next_smallest(lst:\
    \ [Int]) -> Int? {\n    guard lst.count > 1 else { return nil }\n    var min2\
    \ = lst[0]\n    var min1 = lst[0]\n    for num in lst {\n        if num < min1\
    \ {\n            min2 = min1\n            min1 = num\n        } else if num <\
    \ min2 {\n            min2 = num\n        }\n    }\n    if min1 == min2 {\n  \
    \      return nil\n    }\n    return min2\n}\n\n\nfunc ==(left: [(Int, Int)],\
    \ right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n       \
    \ return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r\
    \ {\n            return false\n        }\n    }\n    return true\n}\n        \
    \    \nassert(next_smallest(lst: [1, 2, 3, 4, 5]) == 2)\nassert(next_smallest(lst:\
    \ [5, 1, 4, 3, 2]) == 2)\nassert(next_smallest(lst: [] as [Int]) == nil)\nassert(next_smallest(lst:\
    \ [1, 1]) == nil)\nassert(next_smallest(lst: [1, 1, 1, 1, 0]) == 1)\nassert(next_smallest(lst:\
    \ [1, 1]) == nil)\nassert(next_smallest(lst: [-35, 34, 12, -45]) == -35)"
  status: Exception
  stderr: 'tmpcko5psvv/tmpcko5psvv.swift:44: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b72a4f44c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b72a4c3bb6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b72a4c3b988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b72a4c3a7b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpcko5psvv                        0x0000561412be0601 <unavailable> + 5633

    5    libc.so.6                          0x00002b72a5130460 __libc_start_main +
    245

    6    tmpcko5psvv                        0x0000561412be0189 <unavailable> + 4489

    '
  stdout: ''
  timestamp: 1660013381
- exit_code: -4
  program: "\n/// You are given an array of integers.\n/// Write a function next_smallest()\
    \ that returns the 2nd smallest element of the array.\n/// Return nil if there\
    \ is no such element.\n/// >>> next_smallest(lst: [1, 2, 3, 4, 5])\n/// 2\n///\
    \ >>> next_smallest(lst: [5, 1, 4, 3, 2])\n/// 2\n/// >>> next_smallest(lst: []\
    \ as [Int])\n/// nil\n/// >>> next_smallest(lst: [1, 1])\n/// nil\nfunc next_smallest(lst:\
    \ [Int]) -> Int? {\n    var minimum = Int.max\n    var secondMinimum = Int.max\n\
    \    for num in lst {\n        if num < minimum {\n            secondMinimum =\
    \ minimum\n            minimum = num\n        } else if num < secondMinimum {\n\
    \            secondMinimum = num\n        }\n    }\n    return secondMinimum ==\
    \ Int.max ? nil : secondMinimum\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int,\
    \ Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n\
    \    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n          \
    \  return false\n        }\n    }\n    return true\n}\n            \nassert(next_smallest(lst:\
    \ [1, 2, 3, 4, 5]) == 2)\nassert(next_smallest(lst: [5, 1, 4, 3, 2]) == 2)\nassert(next_smallest(lst:\
    \ [] as [Int]) == nil)\nassert(next_smallest(lst: [1, 1]) == nil)\nassert(next_smallest(lst:\
    \ [1, 1, 1, 1, 0]) == 1)\nassert(next_smallest(lst: [1, 1]) == nil)\nassert(next_smallest(lst:\
    \ [-35, 34, 12, -45]) == -35)"
  status: Exception
  stderr: 'tmphe1jwrbz/tmphe1jwrbz.swift:43: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b2377f09c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b2377c00b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b2377c00988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b2377bff7b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmphe1jwrbz                        0x0000560fbf2aa8da <unavailable> + 6362

    5    libc.so.6                          0x00002b23780f5460 __libc_start_main +
    245

    6    tmphe1jwrbz                        0x0000560fbf2aa0d9 <unavailable> + 4313

    '
  stdout: ''
  timestamp: 1660013382
- exit_code: 0
  program: "\n/// You are given an array of integers.\n/// Write a function next_smallest()\
    \ that returns the 2nd smallest element of the array.\n/// Return nil if there\
    \ is no such element.\n/// >>> next_smallest(lst: [1, 2, 3, 4, 5])\n/// 2\n///\
    \ >>> next_smallest(lst: [5, 1, 4, 3, 2])\n/// 2\n/// >>> next_smallest(lst: []\
    \ as [Int])\n/// nil\n/// >>> next_smallest(lst: [1, 1])\n/// nil\nfunc next_smallest(lst:\
    \ [Int]) -> Int? {\n    guard lst.count > 1 else { return nil }\n    var smallest\
    \ = Int.max\n    var secondSmallest = Int.max\n    for num in lst {\n        if\
    \ num < smallest {\n            secondSmallest = smallest\n            smallest\
    \ = num\n        } else if num < secondSmallest {\n            secondSmallest\
    \ = num\n        }\n    }\n    return smallest == secondSmallest ? nil : secondSmallest\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(next_smallest(lst: [1, 2, 3, 4, 5]) == 2)\nassert(next_smallest(lst:\
    \ [5, 1, 4, 3, 2]) == 2)\nassert(next_smallest(lst: [] as [Int]) == nil)\nassert(next_smallest(lst:\
    \ [1, 1]) == nil)\nassert(next_smallest(lst: [1, 1, 1, 1, 0]) == 1)\nassert(next_smallest(lst:\
    \ [1, 1]) == nil)\nassert(next_smallest(lst: [-35, 34, 12, -45]) == -35)"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660013382
- exit_code: -4
  program: "\n/// You are given an array of integers.\n/// Write a function next_smallest()\
    \ that returns the 2nd smallest element of the array.\n/// Return nil if there\
    \ is no such element.\n/// >>> next_smallest(lst: [1, 2, 3, 4, 5])\n/// 2\n///\
    \ >>> next_smallest(lst: [5, 1, 4, 3, 2])\n/// 2\n/// >>> next_smallest(lst: []\
    \ as [Int])\n/// nil\n/// >>> next_smallest(lst: [1, 1])\n/// nil\nfunc next_smallest(lst:\
    \ [Int]) -> Int? {\n    var value: Int?\n    if lst.count > 1 {\n        let sorted\
    \ = lst.sorted()\n        value = sorted[1]\n    }\n    return value\n}\n\n\n\
    func ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(next_smallest(lst: [1, 2, 3, 4, 5]) == 2)\nassert(next_smallest(lst:\
    \ [5, 1, 4, 3, 2]) == 2)\nassert(next_smallest(lst: [] as [Int]) == nil)\nassert(next_smallest(lst:\
    \ [1, 1]) == nil)\nassert(next_smallest(lst: [1, 1, 1, 1, 0]) == 1)\nassert(next_smallest(lst:\
    \ [1, 1]) == nil)\nassert(next_smallest(lst: [-35, 34, 12, -45]) == -35)"
  status: Exception
  stderr: 'tmp5hubmbmq/tmp5hubmbmq.swift:38: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b0f68c74c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b0f6896bb6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b0f6896b988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b0f6896a7b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmp5hubmbmq                        0x00005637797718ba <unavailable> + 6330

    5    libc.so.6                          0x00002b0f68e60460 __libc_start_main +
    245

    6    tmp5hubmbmq                        0x00005637797710b9 <unavailable> + 4281

    '
  stdout: ''
  timestamp: 1660013381
- exit_code: 0
  program: "\n/// You are given an array of integers.\n/// Write a function next_smallest()\
    \ that returns the 2nd smallest element of the array.\n/// Return nil if there\
    \ is no such element.\n/// >>> next_smallest(lst: [1, 2, 3, 4, 5])\n/// 2\n///\
    \ >>> next_smallest(lst: [5, 1, 4, 3, 2])\n/// 2\n/// >>> next_smallest(lst: []\
    \ as [Int])\n/// nil\n/// >>> next_smallest(lst: [1, 1])\n/// nil\nfunc next_smallest(lst:\
    \ [Int]) -> Int? {\n    guard lst.count > 1 else { return nil }\n    var newLst\
    \ = lst\n    newLst.sort()\n    if newLst[0] == newLst[1] {\n        return nil\n\
    \    }\n    return newLst[1]\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int,\
    \ Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n\
    \    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n          \
    \  return false\n        }\n    }\n    return true\n}\n            \nassert(next_smallest(lst:\
    \ [1, 2, 3, 4, 5]) == 2)\nassert(next_smallest(lst: [5, 1, 4, 3, 2]) == 2)\nassert(next_smallest(lst:\
    \ [] as [Int]) == nil)\nassert(next_smallest(lst: [1, 1]) == nil)\nassert(next_smallest(lst:\
    \ [1, 1, 1, 1, 0]) == 1)\nassert(next_smallest(lst: [1, 1]) == nil)\nassert(next_smallest(lst:\
    \ [-35, 34, 12, -45]) == -35)"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660013382
- exit_code: -4
  program: "\n/// You are given an array of integers.\n/// Write a function next_smallest()\
    \ that returns the 2nd smallest element of the array.\n/// Return nil if there\
    \ is no such element.\n/// >>> next_smallest(lst: [1, 2, 3, 4, 5])\n/// 2\n///\
    \ >>> next_smallest(lst: [5, 1, 4, 3, 2])\n/// 2\n/// >>> next_smallest(lst: []\
    \ as [Int])\n/// nil\n/// >>> next_smallest(lst: [1, 1])\n/// nil\nfunc next_smallest(lst:\
    \ [Int]) -> Int? {\n    var sortedArray = lst.sorted()\n    if sortedArray.count\
    \ == 0 {\n        return nil\n    }\n    if sortedArray.count == 1 {\n       \
    \ return nil\n    }\n    var min = sortedArray[0]\n    var min2 = sortedArray[1]\n\
    \    for num in sortedArray {\n        if num < min {\n            min2 = min\n\
    \            min = num\n        } else if num < min2 {\n            min2 = num\n\
    \        }\n    }\n    return min2\n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(next_smallest(lst: [1, 2, 3, 4, 5]) == 2)\nassert(next_smallest(lst: [5,\
    \ 1, 4, 3, 2]) == 2)\nassert(next_smallest(lst: [] as [Int]) == nil)\nassert(next_smallest(lst:\
    \ [1, 1]) == nil)\nassert(next_smallest(lst: [1, 1, 1, 1, 0]) == 1)\nassert(next_smallest(lst:\
    \ [1, 1]) == nil)\nassert(next_smallest(lst: [-35, 34, 12, -45]) == -35)"
  status: Exception
  stderr: 'tmpsrfyerkp/tmpsrfyerkp.swift:47: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b83a9f5ec80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b83a9c55b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b83a9c55988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b83a9c547b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpsrfyerkp                        0x00005640ec5ad6a1 <unavailable> + 5793

    5    libc.so.6                          0x00002b83aa14a460 __libc_start_main +
    245

    6    tmpsrfyerkp                        0x00005640ec5ad229 <unavailable> + 4649

    '
  stdout: ''
  timestamp: 1660013382
- exit_code: 0
  program: "\n/// You are given an array of integers.\n/// Write a function next_smallest()\
    \ that returns the 2nd smallest element of the array.\n/// Return nil if there\
    \ is no such element.\n/// >>> next_smallest(lst: [1, 2, 3, 4, 5])\n/// 2\n///\
    \ >>> next_smallest(lst: [5, 1, 4, 3, 2])\n/// 2\n/// >>> next_smallest(lst: []\
    \ as [Int])\n/// nil\n/// >>> next_smallest(lst: [1, 1])\n/// nil\nfunc next_smallest(lst:\
    \ [Int]) -> Int? {\n    guard lst.count > 1 else { return nil }\n    let sortedLst\
    \ = lst.sorted()\n    for i in 1..<sortedLst.count {\n        if sortedLst[i -\
    \ 1] != sortedLst[i] {\n            return sortedLst[i]\n        }\n    }\n  \
    \  return nil\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool\
    \ {\n    if left.count != right.count {\n        return false\n    }\n    for\
    \ (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(next_smallest(lst:\
    \ [1, 2, 3, 4, 5]) == 2)\nassert(next_smallest(lst: [5, 1, 4, 3, 2]) == 2)\nassert(next_smallest(lst:\
    \ [] as [Int]) == nil)\nassert(next_smallest(lst: [1, 1]) == nil)\nassert(next_smallest(lst:\
    \ [1, 1, 1, 1, 0]) == 1)\nassert(next_smallest(lst: [1, 1]) == nil)\nassert(next_smallest(lst:\
    \ [-35, 34, 12, -45]) == -35)"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660013382
- exit_code: -4
  program: "\n/// You are given an array of integers.\n/// Write a function next_smallest()\
    \ that returns the 2nd smallest element of the array.\n/// Return nil if there\
    \ is no such element.\n/// >>> next_smallest(lst: [1, 2, 3, 4, 5])\n/// 2\n///\
    \ >>> next_smallest(lst: [5, 1, 4, 3, 2])\n/// 2\n/// >>> next_smallest(lst: []\
    \ as [Int])\n/// nil\n/// >>> next_smallest(lst: [1, 1])\n/// nil\nfunc next_smallest(lst:\
    \ [Int]) -> Int? {\n    if lst.count == 0 {\n        return nil\n    } else if\
    \ lst.count == 1 {\n        return nil\n    } else {\n        let sorted = lst.sorted()\n\
    \        return sorted[1]\n    }\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int,\
    \ Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n\
    \    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n          \
    \  return false\n        }\n    }\n    return true\n}\n            \nassert(next_smallest(lst:\
    \ [1, 2, 3, 4, 5]) == 2)\nassert(next_smallest(lst: [5, 1, 4, 3, 2]) == 2)\nassert(next_smallest(lst:\
    \ [] as [Int]) == nil)\nassert(next_smallest(lst: [1, 1]) == nil)\nassert(next_smallest(lst:\
    \ [1, 1, 1, 1, 0]) == 1)\nassert(next_smallest(lst: [1, 1]) == nil)\nassert(next_smallest(lst:\
    \ [-35, 34, 12, -45]) == -35)"
  status: Exception
  stderr: 'tmp1potw6y_/tmp1potw6y_.swift:40: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002ad7cadf9c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002ad7caaf0b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002ad7caaf0988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002ad7caaef7b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmp1potw6y_                        0x000055691c7828ba <unavailable> + 6330

    5    libc.so.6                          0x00002ad7cafe5460 __libc_start_main +
    245

    6    tmp1potw6y_                        0x000055691c7820b9 <unavailable> + 4281

    '
  stdout: ''
  timestamp: 1660013382
- exit_code: -4
  program: "\n/// You are given an array of integers.\n/// Write a function next_smallest()\
    \ that returns the 2nd smallest element of the array.\n/// Return nil if there\
    \ is no such element.\n/// >>> next_smallest(lst: [1, 2, 3, 4, 5])\n/// 2\n///\
    \ >>> next_smallest(lst: [5, 1, 4, 3, 2])\n/// 2\n/// >>> next_smallest(lst: []\
    \ as [Int])\n/// nil\n/// >>> next_smallest(lst: [1, 1])\n/// nil\nfunc next_smallest(lst:\
    \ [Int]) -> Int? {\n    guard lst.count > 1 else { return nil }\n    let sortedLst\
    \ = lst.sorted()\n    return sortedLst[1]\n}\n\n\nfunc ==(left: [(Int, Int)],\
    \ right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n       \
    \ return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r\
    \ {\n            return false\n        }\n    }\n    return true\n}\n        \
    \    \nassert(next_smallest(lst: [1, 2, 3, 4, 5]) == 2)\nassert(next_smallest(lst:\
    \ [5, 1, 4, 3, 2]) == 2)\nassert(next_smallest(lst: [] as [Int]) == nil)\nassert(next_smallest(lst:\
    \ [1, 1]) == nil)\nassert(next_smallest(lst: [1, 1, 1, 1, 0]) == 1)\nassert(next_smallest(lst:\
    \ [1, 1]) == nil)\nassert(next_smallest(lst: [-35, 34, 12, -45]) == -35)"
  status: Exception
  stderr: 'tmpr3jnlaj1/tmpr3jnlaj1.swift:35: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002adf91e2fc80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002adf91b26b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002adf91b26988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002adf91b257b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpr3jnlaj1                        0x000056042c3828ba <unavailable> + 6330

    5    libc.so.6                          0x00002adf9201b460 __libc_start_main +
    245

    6    tmpr3jnlaj1                        0x000056042c3820b9 <unavailable> + 4281

    '
  stdout: ''
  timestamp: 1660013219
- exit_code: -4
  program: "\n/// You are given an array of integers.\n/// Write a function next_smallest()\
    \ that returns the 2nd smallest element of the array.\n/// Return nil if there\
    \ is no such element.\n/// >>> next_smallest(lst: [1, 2, 3, 4, 5])\n/// 2\n///\
    \ >>> next_smallest(lst: [5, 1, 4, 3, 2])\n/// 2\n/// >>> next_smallest(lst: []\
    \ as [Int])\n/// nil\n/// >>> next_smallest(lst: [1, 1])\n/// nil\nfunc next_smallest(lst:\
    \ [Int]) -> Int? {\n  if lst.count < 2 {\n    return nil\n  }\n\n  let first =\
    \ lst.first\n  let second = lst.dropFirst().min()\n  let smallest = first! < second!\
    \ ? first! : second!\n\n  return lst.firstIndex(of: smallest) == lst.lastIndex(of:\
    \ smallest) ? nil : smallest\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int,\
    \ Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n\
    \    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n          \
    \  return false\n        }\n    }\n    return true\n}\n            \nassert(next_smallest(lst:\
    \ [1, 2, 3, 4, 5]) == 2)\nassert(next_smallest(lst: [5, 1, 4, 3, 2]) == 2)\nassert(next_smallest(lst:\
    \ [] as [Int]) == nil)\nassert(next_smallest(lst: [1, 1]) == nil)\nassert(next_smallest(lst:\
    \ [1, 1, 1, 1, 0]) == 1)\nassert(next_smallest(lst: [1, 1]) == nil)\nassert(next_smallest(lst:\
    \ [-35, 34, 12, -45]) == -35)"
  status: Exception
  stderr: 'tmpygxfat_1/tmpygxfat_1.swift:38: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b9d34be5c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b9d348dcb6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b9d348dc988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b9d348db7b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpygxfat_1                        0x0000561cafcb9821 <unavailable> + 6177

    5    libc.so.6                          0x00002b9d34dd1460 __libc_start_main +
    245

    6    tmpygxfat_1                        0x0000561cafcb93a9 <unavailable> + 5033

    '
  stdout: ''
  timestamp: 1660013382
- exit_code: 0
  program: "\n/// You are given an array of integers.\n/// Write a function next_smallest()\
    \ that returns the 2nd smallest element of the array.\n/// Return nil if there\
    \ is no such element.\n/// >>> next_smallest(lst: [1, 2, 3, 4, 5])\n/// 2\n///\
    \ >>> next_smallest(lst: [5, 1, 4, 3, 2])\n/// 2\n/// >>> next_smallest(lst: []\
    \ as [Int])\n/// nil\n/// >>> next_smallest(lst: [1, 1])\n/// nil\nfunc next_smallest(lst:\
    \ [Int]) -> Int? {\n    guard lst.count > 1 else { return nil }\n    let set =\
    \ Set(lst)\n    guard set.count > 1 else { return nil }\n    let sorted = set.sorted()\n\
    \    return sorted[1]\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(next_smallest(lst:\
    \ [1, 2, 3, 4, 5]) == 2)\nassert(next_smallest(lst: [5, 1, 4, 3, 2]) == 2)\nassert(next_smallest(lst:\
    \ [] as [Int]) == nil)\nassert(next_smallest(lst: [1, 1]) == nil)\nassert(next_smallest(lst:\
    \ [1, 1, 1, 1, 0]) == 1)\nassert(next_smallest(lst: [1, 1]) == nil)\nassert(next_smallest(lst:\
    \ [-35, 34, 12, -45]) == -35)"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660013382
- exit_code: 0
  program: "\n/// You are given an array of integers.\n/// Write a function next_smallest()\
    \ that returns the 2nd smallest element of the array.\n/// Return nil if there\
    \ is no such element.\n/// >>> next_smallest(lst: [1, 2, 3, 4, 5])\n/// 2\n///\
    \ >>> next_smallest(lst: [5, 1, 4, 3, 2])\n/// 2\n/// >>> next_smallest(lst: []\
    \ as [Int])\n/// nil\n/// >>> next_smallest(lst: [1, 1])\n/// nil\nfunc next_smallest(lst:\
    \ [Int]) -> Int? {\n    let sorted = lst.sorted()\n    for i in 0..<sorted.count\
    \ {\n        if sorted[i] > sorted[0] {\n            return sorted[i]\n      \
    \  }\n    }\n    return nil\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int,\
    \ Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n\
    \    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n          \
    \  return false\n        }\n    }\n    return true\n}\n            \nassert(next_smallest(lst:\
    \ [1, 2, 3, 4, 5]) == 2)\nassert(next_smallest(lst: [5, 1, 4, 3, 2]) == 2)\nassert(next_smallest(lst:\
    \ [] as [Int]) == nil)\nassert(next_smallest(lst: [1, 1]) == nil)\nassert(next_smallest(lst:\
    \ [1, 1, 1, 1, 0]) == 1)\nassert(next_smallest(lst: [1, 1]) == nil)\nassert(next_smallest(lst:\
    \ [-35, 34, 12, -45]) == -35)"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660013382
- exit_code: -4
  program: "\n/// You are given an array of integers.\n/// Write a function next_smallest()\
    \ that returns the 2nd smallest element of the array.\n/// Return nil if there\
    \ is no such element.\n/// >>> next_smallest(lst: [1, 2, 3, 4, 5])\n/// 2\n///\
    \ >>> next_smallest(lst: [5, 1, 4, 3, 2])\n/// 2\n/// >>> next_smallest(lst: []\
    \ as [Int])\n/// nil\n/// >>> next_smallest(lst: [1, 1])\n/// nil\nfunc next_smallest(lst:\
    \ [Int]) -> Int? {\n    if lst.count < 2 {\n        return nil\n    }\n    let\
    \ sortedList = lst.sorted()\n    var result = lst[0]\n    for index in 1..<sortedList.count\
    \ {\n        if sortedList[index] != sortedList[index - 1] {\n            result\
    \ = sortedList[index]\n            break\n        }\n    }\n    return result\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(next_smallest(lst: [1, 2, 3, 4, 5]) == 2)\nassert(next_smallest(lst:\
    \ [5, 1, 4, 3, 2]) == 2)\nassert(next_smallest(lst: [] as [Int]) == nil)\nassert(next_smallest(lst:\
    \ [1, 1]) == nil)\nassert(next_smallest(lst: [1, 1, 1, 1, 0]) == 1)\nassert(next_smallest(lst:\
    \ [1, 1]) == nil)\nassert(next_smallest(lst: [-35, 34, 12, -45]) == -35)"
  status: Exception
  stderr: 'tmplql11u4l/tmplql11u4l.swift:44: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b91d3f2bc80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b91d3c22b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b91d3c22988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b91d3c217b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmplql11u4l                        0x00005620c9595a4a <unavailable> + 6730

    5    libc.so.6                          0x00002b91d4117460 __libc_start_main +
    245

    6    tmplql11u4l                        0x00005620c9595249 <unavailable> + 4681

    '
  stdout: ''
  timestamp: 1660013382
- exit_code: -4
  program: "\n/// You are given an array of integers.\n/// Write a function next_smallest()\
    \ that returns the 2nd smallest element of the array.\n/// Return nil if there\
    \ is no such element.\n/// >>> next_smallest(lst: [1, 2, 3, 4, 5])\n/// 2\n///\
    \ >>> next_smallest(lst: [5, 1, 4, 3, 2])\n/// 2\n/// >>> next_smallest(lst: []\
    \ as [Int])\n/// nil\n/// >>> next_smallest(lst: [1, 1])\n/// nil\nfunc next_smallest(lst:\
    \ [Int]) -> Int? {\n    if lst.count <= 1 {\n        return nil\n    }\n    var\
    \ arr = lst\n    arr.sort()\n    for index in 0..<arr.count {\n        if arr[index]\
    \ != arr[index+1] {\n            return arr[index+1]\n        }\n    }\n    return\
    \ nil\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n   \
    \ if left.count != right.count {\n        return false\n    }\n    for (l, r)\
    \ in zip(left, right) {\n        if l != r {\n            return false\n     \
    \   }\n    }\n    return true\n}\n            \nassert(next_smallest(lst: [1,\
    \ 2, 3, 4, 5]) == 2)\nassert(next_smallest(lst: [5, 1, 4, 3, 2]) == 2)\nassert(next_smallest(lst:\
    \ [] as [Int]) == nil)\nassert(next_smallest(lst: [1, 1]) == nil)\nassert(next_smallest(lst:\
    \ [1, 1, 1, 1, 0]) == 1)\nassert(next_smallest(lst: [1, 1]) == nil)\nassert(next_smallest(lst:\
    \ [-35, 34, 12, -45]) == -35)"
  status: Exception
  stderr: 'Swift/ContiguousArrayBuffer.swift:600: Fatal error: Index out of range

    Current stack trace:

    0    libswiftCore.so                    0x00002b98c9b05c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b98c97fc561 <unavailable> + 1434977

    2    libswiftCore.so                    0x00002b98c97fc286 <unavailable> + 1434246

    3    libswiftCore.so                    0x00002b98c97fc13c <unavailable> + 1433916

    4    libswiftCore.so                    0x00002b98c97fbbb0 _assertionFailure(_:_:file:line:flags:)
    + 251

    5    libswiftSwiftOnoneSupport.so       0x00002b98c95fbe83 <unavailable> + 188035

    6    tmpc2dl8xug                        0x0000557434466184 <unavailable> + 8580

    7    tmpc2dl8xug                        0x0000557434465a0a <unavailable> + 6666

    8    libc.so.6                          0x00002b98c9cf1460 __libc_start_main +
    245

    9    tmpc2dl8xug                        0x00005574344652c9 <unavailable> + 4809

    '
  stdout: ''
  timestamp: 1660013382
- exit_code: -4
  program: "\n/// You are given an array of integers.\n/// Write a function next_smallest()\
    \ that returns the 2nd smallest element of the array.\n/// Return nil if there\
    \ is no such element.\n/// >>> next_smallest(lst: [1, 2, 3, 4, 5])\n/// 2\n///\
    \ >>> next_smallest(lst: [5, 1, 4, 3, 2])\n/// 2\n/// >>> next_smallest(lst: []\
    \ as [Int])\n/// nil\n/// >>> next_smallest(lst: [1, 1])\n/// nil\nfunc next_smallest(lst:\
    \ [Int]) -> Int? {\n    guard lst.count > 1 else { return nil }\n    var minNum\
    \ = lst[0]\n    var nMinNum = lst[1]\n    for i in 2..<lst.count {\n        if\
    \ lst[i] < minNum {\n            nMinNum = minNum\n            minNum = lst[i]\n\
    \        } else if lst[i] < nMinNum {\n            nMinNum = lst[i]\n        }\n\
    \    }\n    return nMinNum\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(next_smallest(lst:\
    \ [1, 2, 3, 4, 5]) == 2)\nassert(next_smallest(lst: [5, 1, 4, 3, 2]) == 2)\nassert(next_smallest(lst:\
    \ [] as [Int]) == nil)\nassert(next_smallest(lst: [1, 1]) == nil)\nassert(next_smallest(lst:\
    \ [1, 1, 1, 1, 0]) == 1)\nassert(next_smallest(lst: [1, 1]) == nil)\nassert(next_smallest(lst:\
    \ [-35, 34, 12, -45]) == -35)"
  status: Exception
  stderr: 'tmp6qhihnw3/tmp6qhihnw3.swift:42: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002afba9e2cc80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002afba9b23b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002afba9b23988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002afba9b227b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmp6qhihnw3                        0x000055c6ebd327c5 <unavailable> + 6085

    5    libc.so.6                          0x00002afbaa018460 __libc_start_main +
    245

    6    tmp6qhihnw3                        0x000055c6ebd321a9 <unavailable> + 4521

    '
  stdout: ''
  timestamp: 1660013382
- exit_code: -4
  program: "\n/// You are given an array of integers.\n/// Write a function next_smallest()\
    \ that returns the 2nd smallest element of the array.\n/// Return nil if there\
    \ is no such element.\n/// >>> next_smallest(lst: [1, 2, 3, 4, 5])\n/// 2\n///\
    \ >>> next_smallest(lst: [5, 1, 4, 3, 2])\n/// 2\n/// >>> next_smallest(lst: []\
    \ as [Int])\n/// nil\n/// >>> next_smallest(lst: [1, 1])\n/// nil\nfunc next_smallest(lst:\
    \ [Int]) -> Int? {\n    var result = Int.max\n    var smallest = Int.max\n   \
    \ for item in lst {\n        if item < smallest {\n            result = smallest\n\
    \            smallest = item\n        } else if item < result {\n            result\
    \ = item\n        }\n    }\n    return result == Int.max ? nil : result\n}\n\n\
    \nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(next_smallest(lst: [1, 2, 3, 4, 5]) == 2)\nassert(next_smallest(lst:\
    \ [5, 1, 4, 3, 2]) == 2)\nassert(next_smallest(lst: [] as [Int]) == nil)\nassert(next_smallest(lst:\
    \ [1, 1]) == nil)\nassert(next_smallest(lst: [1, 1, 1, 1, 0]) == 1)\nassert(next_smallest(lst:\
    \ [1, 1]) == nil)\nassert(next_smallest(lst: [-35, 34, 12, -45]) == -35)"
  status: Exception
  stderr: 'tmp85hf5afr/tmp85hf5afr.swift:43: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b0642d35c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b0642a2cb6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b0642a2c988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b0642a2b7b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmp85hf5afr                        0x00005632081ef8da <unavailable> + 6362

    5    libc.so.6                          0x00002b0642f21460 __libc_start_main +
    245

    6    tmp85hf5afr                        0x00005632081ef0d9 <unavailable> + 4313

    '
  stdout: ''
  timestamp: 1660013382
- exit_code: 0
  program: "\n/// You are given an array of integers.\n/// Write a function next_smallest()\
    \ that returns the 2nd smallest element of the array.\n/// Return nil if there\
    \ is no such element.\n/// >>> next_smallest(lst: [1, 2, 3, 4, 5])\n/// 2\n///\
    \ >>> next_smallest(lst: [5, 1, 4, 3, 2])\n/// 2\n/// >>> next_smallest(lst: []\
    \ as [Int])\n/// nil\n/// >>> next_smallest(lst: [1, 1])\n/// nil\nfunc next_smallest(lst:\
    \ [Int]) -> Int? {\n  guard lst.count > 2 else { return nil }\n  let sortedUnique\
    \ = Set(lst).sorted()\n  return sortedUnique[1]\n}\n\n\nfunc ==(left: [(Int, Int)],\
    \ right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n       \
    \ return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r\
    \ {\n            return false\n        }\n    }\n    return true\n}\n        \
    \    \nassert(next_smallest(lst: [1, 2, 3, 4, 5]) == 2)\nassert(next_smallest(lst:\
    \ [5, 1, 4, 3, 2]) == 2)\nassert(next_smallest(lst: [] as [Int]) == nil)\nassert(next_smallest(lst:\
    \ [1, 1]) == nil)\nassert(next_smallest(lst: [1, 1, 1, 1, 0]) == 1)\nassert(next_smallest(lst:\
    \ [1, 1]) == nil)\nassert(next_smallest(lst: [-35, 34, 12, -45]) == -35)"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660013382
- exit_code: 0
  program: "\n/// You are given an array of integers.\n/// Write a function next_smallest()\
    \ that returns the 2nd smallest element of the array.\n/// Return nil if there\
    \ is no such element.\n/// >>> next_smallest(lst: [1, 2, 3, 4, 5])\n/// 2\n///\
    \ >>> next_smallest(lst: [5, 1, 4, 3, 2])\n/// 2\n/// >>> next_smallest(lst: []\
    \ as [Int])\n/// nil\n/// >>> next_smallest(lst: [1, 1])\n/// nil\nfunc next_smallest(lst:\
    \ [Int]) -> Int? {\n    var smallest = Int.max\n    var s_smallest = Int.max\n\
    \    for i in lst {\n        if i < smallest {\n            s_smallest = smallest\n\
    \            smallest = i\n        } else if i < s_smallest {\n            s_smallest\
    \ = i\n        }\n    }\n    return smallest == s_smallest ? nil : s_smallest\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(next_smallest(lst: [1, 2, 3, 4, 5]) == 2)\nassert(next_smallest(lst:\
    \ [5, 1, 4, 3, 2]) == 2)\nassert(next_smallest(lst: [] as [Int]) == nil)\nassert(next_smallest(lst:\
    \ [1, 1]) == nil)\nassert(next_smallest(lst: [1, 1, 1, 1, 0]) == 1)\nassert(next_smallest(lst:\
    \ [1, 1]) == nil)\nassert(next_smallest(lst: [-35, 34, 12, -45]) == -35)"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660013382
- exit_code: 0
  program: "\n/// You are given an array of integers.\n/// Write a function next_smallest()\
    \ that returns the 2nd smallest element of the array.\n/// Return nil if there\
    \ is no such element.\n/// >>> next_smallest(lst: [1, 2, 3, 4, 5])\n/// 2\n///\
    \ >>> next_smallest(lst: [5, 1, 4, 3, 2])\n/// 2\n/// >>> next_smallest(lst: []\
    \ as [Int])\n/// nil\n/// >>> next_smallest(lst: [1, 1])\n/// nil\nfunc next_smallest(lst:\
    \ [Int]) -> Int? {\n    if lst.count < 2 {\n        return nil\n    }\n    var\
    \ lstCopy = lst\n    lstCopy.sort()\n    if lstCopy[0] == lstCopy[1] {\n     \
    \   return nil\n    }\n    return lstCopy[1]\n}\n\n\nfunc ==(left: [(Int, Int)],\
    \ right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n       \
    \ return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r\
    \ {\n            return false\n        }\n    }\n    return true\n}\n        \
    \    \nassert(next_smallest(lst: [1, 2, 3, 4, 5]) == 2)\nassert(next_smallest(lst:\
    \ [5, 1, 4, 3, 2]) == 2)\nassert(next_smallest(lst: [] as [Int]) == nil)\nassert(next_smallest(lst:\
    \ [1, 1]) == nil)\nassert(next_smallest(lst: [1, 1, 1, 1, 0]) == 1)\nassert(next_smallest(lst:\
    \ [1, 1]) == nil)\nassert(next_smallest(lst: [-35, 34, 12, -45]) == -35)"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660013382
- exit_code: 0
  program: "\n/// You are given an array of integers.\n/// Write a function next_smallest()\
    \ that returns the 2nd smallest element of the array.\n/// Return nil if there\
    \ is no such element.\n/// >>> next_smallest(lst: [1, 2, 3, 4, 5])\n/// 2\n///\
    \ >>> next_smallest(lst: [5, 1, 4, 3, 2])\n/// 2\n/// >>> next_smallest(lst: []\
    \ as [Int])\n/// nil\n/// >>> next_smallest(lst: [1, 1])\n/// nil\nfunc next_smallest(lst:\
    \ [Int]) -> Int? {\n    let sorted = lst.sorted()\n    return sorted.isEmpty ||\
    \ sorted.first == sorted.last ? nil : sorted[1]\n}\n\n\nfunc ==(left: [(Int, Int)],\
    \ right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n       \
    \ return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r\
    \ {\n            return false\n        }\n    }\n    return true\n}\n        \
    \    \nassert(next_smallest(lst: [1, 2, 3, 4, 5]) == 2)\nassert(next_smallest(lst:\
    \ [5, 1, 4, 3, 2]) == 2)\nassert(next_smallest(lst: [] as [Int]) == nil)\nassert(next_smallest(lst:\
    \ [1, 1]) == nil)\nassert(next_smallest(lst: [1, 1, 1, 1, 0]) == 1)\nassert(next_smallest(lst:\
    \ [1, 1]) == nil)\nassert(next_smallest(lst: [-35, 34, 12, -45]) == -35)"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660013382
- exit_code: 0
  program: "\n/// You are given an array of integers.\n/// Write a function next_smallest()\
    \ that returns the 2nd smallest element of the array.\n/// Return nil if there\
    \ is no such element.\n/// >>> next_smallest(lst: [1, 2, 3, 4, 5])\n/// 2\n///\
    \ >>> next_smallest(lst: [5, 1, 4, 3, 2])\n/// 2\n/// >>> next_smallest(lst: []\
    \ as [Int])\n/// nil\n/// >>> next_smallest(lst: [1, 1])\n/// nil\nfunc next_smallest(lst:\
    \ [Int]) -> Int? {\n    guard lst.count > 2 else { return nil }\n    var min =\
    \ Int.max\n    var nextMin = Int.max\n    for n in lst {\n        if n < min {\n\
    \            nextMin = min\n            min = n\n        } else if n < nextMin\
    \ {\n            nextMin = n\n        }\n    }\n    return nextMin == Int.max\
    \ ? nil : nextMin\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) ->\
    \ Bool {\n    if left.count != right.count {\n        return false\n    }\n  \
    \  for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(next_smallest(lst:\
    \ [1, 2, 3, 4, 5]) == 2)\nassert(next_smallest(lst: [5, 1, 4, 3, 2]) == 2)\nassert(next_smallest(lst:\
    \ [] as [Int]) == nil)\nassert(next_smallest(lst: [1, 1]) == nil)\nassert(next_smallest(lst:\
    \ [1, 1, 1, 1, 0]) == 1)\nassert(next_smallest(lst: [1, 1]) == nil)\nassert(next_smallest(lst:\
    \ [-35, 34, 12, -45]) == -35)"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660013382
- exit_code: -4
  program: "\n/// You are given an array of integers.\n/// Write a function next_smallest()\
    \ that returns the 2nd smallest element of the array.\n/// Return nil if there\
    \ is no such element.\n/// >>> next_smallest(lst: [1, 2, 3, 4, 5])\n/// 2\n///\
    \ >>> next_smallest(lst: [5, 1, 4, 3, 2])\n/// 2\n/// >>> next_smallest(lst: []\
    \ as [Int])\n/// nil\n/// >>> next_smallest(lst: [1, 1])\n/// nil\nfunc next_smallest(lst:\
    \ [Int]) -> Int? {\n  return nil\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int,\
    \ Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n\
    \    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n          \
    \  return false\n        }\n    }\n    return true\n}\n            \nassert(next_smallest(lst:\
    \ [1, 2, 3, 4, 5]) == 2)\nassert(next_smallest(lst: [5, 1, 4, 3, 2]) == 2)\nassert(next_smallest(lst:\
    \ [] as [Int]) == nil)\nassert(next_smallest(lst: [1, 1]) == nil)\nassert(next_smallest(lst:\
    \ [1, 1, 1, 1, 0]) == 1)\nassert(next_smallest(lst: [1, 1]) == nil)\nassert(next_smallest(lst:\
    \ [-35, 34, 12, -45]) == -35)"
  status: Exception
  stderr: 'tmpqi9ofhv9/tmpqi9ofhv9.swift:30: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b2e96c67c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b2e9695eb6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b2e9695e988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b2e9695d7b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpqi9ofhv9                        0x000055b59963c3e1 <unavailable> + 5089

    5    libc.so.6                          0x00002b2e96e53460 __libc_start_main +
    245

    6    tmpqi9ofhv9                        0x000055b59963bf69 <unavailable> + 3945

    '
  stdout: ''
  timestamp: 1660013382
- exit_code: -4
  program: "\n/// You are given an array of integers.\n/// Write a function next_smallest()\
    \ that returns the 2nd smallest element of the array.\n/// Return nil if there\
    \ is no such element.\n/// >>> next_smallest(lst: [1, 2, 3, 4, 5])\n/// 2\n///\
    \ >>> next_smallest(lst: [5, 1, 4, 3, 2])\n/// 2\n/// >>> next_smallest(lst: []\
    \ as [Int])\n/// nil\n/// >>> next_smallest(lst: [1, 1])\n/// nil\nfunc next_smallest(lst:\
    \ [Int]) -> Int? {\n    guard lst.count > 1 else { return nil }\n    return lst.sorted().dropFirst().first\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(next_smallest(lst: [1, 2, 3, 4, 5]) == 2)\nassert(next_smallest(lst:\
    \ [5, 1, 4, 3, 2]) == 2)\nassert(next_smallest(lst: [] as [Int]) == nil)\nassert(next_smallest(lst:\
    \ [1, 1]) == nil)\nassert(next_smallest(lst: [1, 1, 1, 1, 0]) == 1)\nassert(next_smallest(lst:\
    \ [1, 1]) == nil)\nassert(next_smallest(lst: [-35, 34, 12, -45]) == -35)"
  status: Exception
  stderr: 'tmp13usd45t/tmp13usd45t.swift:34: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002ab8f57e0c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002ab8f54d7b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002ab8f54d7988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002ab8f54d67b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmp13usd45t                        0x000055ea8d46f9fa <unavailable> + 6650

    5    libc.so.6                          0x00002ab8f59cc460 __libc_start_main +
    245

    6    tmp13usd45t                        0x000055ea8d46f1f9 <unavailable> + 4601

    '
  stdout: ''
  timestamp: 1660013382
- exit_code: 0
  program: "\n/// You are given an array of integers.\n/// Write a function next_smallest()\
    \ that returns the 2nd smallest element of the array.\n/// Return nil if there\
    \ is no such element.\n/// >>> next_smallest(lst: [1, 2, 3, 4, 5])\n/// 2\n///\
    \ >>> next_smallest(lst: [5, 1, 4, 3, 2])\n/// 2\n/// >>> next_smallest(lst: []\
    \ as [Int])\n/// nil\n/// >>> next_smallest(lst: [1, 1])\n/// nil\nfunc next_smallest(lst:\
    \ [Int]) -> Int? {\n    if lst.count < 2 {\n        return nil\n    }\n    if\
    \ lst.count == 2 {\n        if lst[0] == lst[1] {\n            return nil\n  \
    \      }\n        return lst[0] < lst[1] ? lst[0] : lst[1]\n    }\n    let sortedLst\
    \ = lst.sorted()\n    for i in 1 ..< sortedLst.count {\n        if sortedLst[i]\
    \ != sortedLst[i - 1] {\n            return sortedLst[i]\n        }\n    }\n \
    \   return nil\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool\
    \ {\n    if left.count != right.count {\n        return false\n    }\n    for\
    \ (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(next_smallest(lst:\
    \ [1, 2, 3, 4, 5]) == 2)\nassert(next_smallest(lst: [5, 1, 4, 3, 2]) == 2)\nassert(next_smallest(lst:\
    \ [] as [Int]) == nil)\nassert(next_smallest(lst: [1, 1]) == nil)\nassert(next_smallest(lst:\
    \ [1, 1, 1, 1, 0]) == 1)\nassert(next_smallest(lst: [1, 1]) == nil)\nassert(next_smallest(lst:\
    \ [-35, 34, 12, -45]) == -35)"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660013382
- exit_code: 0
  program: "\n/// You are given an array of integers.\n/// Write a function next_smallest()\
    \ that returns the 2nd smallest element of the array.\n/// Return nil if there\
    \ is no such element.\n/// >>> next_smallest(lst: [1, 2, 3, 4, 5])\n/// 2\n///\
    \ >>> next_smallest(lst: [5, 1, 4, 3, 2])\n/// 2\n/// >>> next_smallest(lst: []\
    \ as [Int])\n/// nil\n/// >>> next_smallest(lst: [1, 1])\n/// nil\nfunc next_smallest(lst:\
    \ [Int]) -> Int? {\n    guard lst.count > 1 else { return nil }\n    var lst =\
    \ lst\n    var smallest = lst.removeFirst()\n    var nextSmallest = Int.max\n\
    \    for i in lst {\n        if i < smallest {\n            nextSmallest = smallest\n\
    \            smallest = i\n        } else if i < nextSmallest {\n            nextSmallest\
    \ = i\n        }\n    }\n    return smallest == nextSmallest ? nil : nextSmallest\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(next_smallest(lst: [1, 2, 3, 4, 5]) == 2)\nassert(next_smallest(lst:\
    \ [5, 1, 4, 3, 2]) == 2)\nassert(next_smallest(lst: [] as [Int]) == nil)\nassert(next_smallest(lst:\
    \ [1, 1]) == nil)\nassert(next_smallest(lst: [1, 1, 1, 1, 0]) == 1)\nassert(next_smallest(lst:\
    \ [1, 1]) == nil)\nassert(next_smallest(lst: [-35, 34, 12, -45]) == -35)"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660013382
- exit_code: 0
  program: "\n/// You are given an array of integers.\n/// Write a function next_smallest()\
    \ that returns the 2nd smallest element of the array.\n/// Return nil if there\
    \ is no such element.\n/// >>> next_smallest(lst: [1, 2, 3, 4, 5])\n/// 2\n///\
    \ >>> next_smallest(lst: [5, 1, 4, 3, 2])\n/// 2\n/// >>> next_smallest(lst: []\
    \ as [Int])\n/// nil\n/// >>> next_smallest(lst: [1, 1])\n/// nil\nfunc next_smallest(lst:\
    \ [Int]) -> Int? {\n  var smallest: Int?\n  var second_smallest: Int?\n  for item\
    \ in lst {\n    if smallest == nil {\n      smallest = item\n    } else if item\
    \ < smallest! {\n      second_smallest = smallest\n      smallest = item\n   \
    \ } else if item > smallest! && (second_smallest == nil || item < second_smallest!)\
    \ {\n      second_smallest = item\n    }\n  }\n  return second_smallest\n}\n\n\
    \nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(next_smallest(lst: [1, 2, 3, 4, 5]) == 2)\nassert(next_smallest(lst:\
    \ [5, 1, 4, 3, 2]) == 2)\nassert(next_smallest(lst: [] as [Int]) == nil)\nassert(next_smallest(lst:\
    \ [1, 1]) == nil)\nassert(next_smallest(lst: [1, 1, 1, 1, 0]) == 1)\nassert(next_smallest(lst:\
    \ [1, 1]) == nil)\nassert(next_smallest(lst: [-35, 34, 12, -45]) == -35)"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660013382
- exit_code: -4
  program: "\n/// You are given an array of integers.\n/// Write a function next_smallest()\
    \ that returns the 2nd smallest element of the array.\n/// Return nil if there\
    \ is no such element.\n/// >>> next_smallest(lst: [1, 2, 3, 4, 5])\n/// 2\n///\
    \ >>> next_smallest(lst: [5, 1, 4, 3, 2])\n/// 2\n/// >>> next_smallest(lst: []\
    \ as [Int])\n/// nil\n/// >>> next_smallest(lst: [1, 1])\n/// nil\nfunc next_smallest(lst:\
    \ [Int]) -> Int? {\n    guard lst.count > 1 else { return nil }\n    let sorted\
    \ = lst.sorted()\n    return sorted[1]\n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(next_smallest(lst: [1, 2, 3, 4, 5]) == 2)\nassert(next_smallest(lst: [5,\
    \ 1, 4, 3, 2]) == 2)\nassert(next_smallest(lst: [] as [Int]) == nil)\nassert(next_smallest(lst:\
    \ [1, 1]) == nil)\nassert(next_smallest(lst: [1, 1, 1, 1, 0]) == 1)\nassert(next_smallest(lst:\
    \ [1, 1]) == nil)\nassert(next_smallest(lst: [-35, 34, 12, -45]) == -35)"
  status: Exception
  stderr: 'tmp8y8mztze/tmp8y8mztze.swift:35: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b276daedc80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b276d7e4b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b276d7e4988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b276d7e37b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmp8y8mztze                        0x000055cf36f688ba <unavailable> + 6330

    5    libc.so.6                          0x00002b276dcd9460 __libc_start_main +
    245

    6    tmp8y8mztze                        0x000055cf36f680b9 <unavailable> + 4281

    '
  stdout: ''
  timestamp: 1660013218
- exit_code: 0
  program: "\n/// You are given an array of integers.\n/// Write a function next_smallest()\
    \ that returns the 2nd smallest element of the array.\n/// Return nil if there\
    \ is no such element.\n/// >>> next_smallest(lst: [1, 2, 3, 4, 5])\n/// 2\n///\
    \ >>> next_smallest(lst: [5, 1, 4, 3, 2])\n/// 2\n/// >>> next_smallest(lst: []\
    \ as [Int])\n/// nil\n/// >>> next_smallest(lst: [1, 1])\n/// nil\nfunc next_smallest(lst:\
    \ [Int]) -> Int? {\n    let distinct = Set(lst)\n    let sorted = distinct.sorted()\n\
    \    if sorted.count < 2 {\n        return nil\n    }\n    return sorted[1]\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(next_smallest(lst: [1, 2, 3, 4, 5]) == 2)\nassert(next_smallest(lst:\
    \ [5, 1, 4, 3, 2]) == 2)\nassert(next_smallest(lst: [] as [Int]) == nil)\nassert(next_smallest(lst:\
    \ [1, 1]) == nil)\nassert(next_smallest(lst: [1, 1, 1, 1, 0]) == 1)\nassert(next_smallest(lst:\
    \ [1, 1]) == nil)\nassert(next_smallest(lst: [-35, 34, 12, -45]) == -35)"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660013382
- exit_code: 0
  program: "\n/// You are given an array of integers.\n/// Write a function next_smallest()\
    \ that returns the 2nd smallest element of the array.\n/// Return nil if there\
    \ is no such element.\n/// >>> next_smallest(lst: [1, 2, 3, 4, 5])\n/// 2\n///\
    \ >>> next_smallest(lst: [5, 1, 4, 3, 2])\n/// 2\n/// >>> next_smallest(lst: []\
    \ as [Int])\n/// nil\n/// >>> next_smallest(lst: [1, 1])\n/// nil\nfunc next_smallest(lst:\
    \ [Int]) -> Int? {\n    guard !lst.isEmpty else { return nil }\n    guard lst.count\
    \ > 1 else { return nil }\n    let sortedArr = lst.sorted()\n    for i in 1..<sortedArr.count\
    \ {\n        if sortedArr[i] != sortedArr[i - 1] {\n            return sortedArr[i]\n\
    \        }\n    }\n    return nil\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int,\
    \ Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n\
    \    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n          \
    \  return false\n        }\n    }\n    return true\n}\n            \nassert(next_smallest(lst:\
    \ [1, 2, 3, 4, 5]) == 2)\nassert(next_smallest(lst: [5, 1, 4, 3, 2]) == 2)\nassert(next_smallest(lst:\
    \ [] as [Int]) == nil)\nassert(next_smallest(lst: [1, 1]) == nil)\nassert(next_smallest(lst:\
    \ [1, 1, 1, 1, 0]) == 1)\nassert(next_smallest(lst: [1, 1]) == nil)\nassert(next_smallest(lst:\
    \ [-35, 34, 12, -45]) == -35)"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660013382
- exit_code: 0
  program: "\n/// You are given an array of integers.\n/// Write a function next_smallest()\
    \ that returns the 2nd smallest element of the array.\n/// Return nil if there\
    \ is no such element.\n/// >>> next_smallest(lst: [1, 2, 3, 4, 5])\n/// 2\n///\
    \ >>> next_smallest(lst: [5, 1, 4, 3, 2])\n/// 2\n/// >>> next_smallest(lst: []\
    \ as [Int])\n/// nil\n/// >>> next_smallest(lst: [1, 1])\n/// nil\nfunc next_smallest(lst:\
    \ [Int]) -> Int? {\n    if lst.count == 0 {\n        return nil\n    }\n    if\
    \ lst.count == 1 {\n        return nil\n    }\n    var lstSorted = lst.sorted()\n\
    \    if lstSorted[0] == lstSorted[1] {\n        lstSorted.removeFirst()\n    }\n\
    \    if lstSorted.count == 1 {\n        return nil\n    }\n    return lstSorted[1]\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(next_smallest(lst: [1, 2, 3, 4, 5]) == 2)\nassert(next_smallest(lst:\
    \ [5, 1, 4, 3, 2]) == 2)\nassert(next_smallest(lst: [] as [Int]) == nil)\nassert(next_smallest(lst:\
    \ [1, 1]) == nil)\nassert(next_smallest(lst: [1, 1, 1, 1, 0]) == 1)\nassert(next_smallest(lst:\
    \ [1, 1]) == nil)\nassert(next_smallest(lst: [-35, 34, 12, -45]) == -35)"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660013382
- exit_code: -4
  program: "\n/// You are given an array of integers.\n/// Write a function next_smallest()\
    \ that returns the 2nd smallest element of the array.\n/// Return nil if there\
    \ is no such element.\n/// >>> next_smallest(lst: [1, 2, 3, 4, 5])\n/// 2\n///\
    \ >>> next_smallest(lst: [5, 1, 4, 3, 2])\n/// 2\n/// >>> next_smallest(lst: []\
    \ as [Int])\n/// nil\n/// >>> next_smallest(lst: [1, 1])\n/// nil\nfunc next_smallest(lst:\
    \ [Int]) -> Int? {\n    guard lst.count > 1 else { return nil }\n    let unsortedLst\
    \ = lst.sorted()\n    return unsortedLst[1]\n}\n\n\nfunc ==(left: [(Int, Int)],\
    \ right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n       \
    \ return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r\
    \ {\n            return false\n        }\n    }\n    return true\n}\n        \
    \    \nassert(next_smallest(lst: [1, 2, 3, 4, 5]) == 2)\nassert(next_smallest(lst:\
    \ [5, 1, 4, 3, 2]) == 2)\nassert(next_smallest(lst: [] as [Int]) == nil)\nassert(next_smallest(lst:\
    \ [1, 1]) == nil)\nassert(next_smallest(lst: [1, 1, 1, 1, 0]) == 1)\nassert(next_smallest(lst:\
    \ [1, 1]) == nil)\nassert(next_smallest(lst: [-35, 34, 12, -45]) == -35)"
  status: Exception
  stderr: 'tmpg4oxorne/tmpg4oxorne.swift:35: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b86907cbc80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b86904c2b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b86904c2988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b86904c17b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpg4oxorne                        0x000055fbfffbc8ba <unavailable> + 6330

    5    libc.so.6                          0x00002b86909b7460 __libc_start_main +
    245

    6    tmpg4oxorne                        0x000055fbfffbc0b9 <unavailable> + 4281

    '
  stdout: ''
  timestamp: 1660013382
- exit_code: -4
  program: "\n/// You are given an array of integers.\n/// Write a function next_smallest()\
    \ that returns the 2nd smallest element of the array.\n/// Return nil if there\
    \ is no such element.\n/// >>> next_smallest(lst: [1, 2, 3, 4, 5])\n/// 2\n///\
    \ >>> next_smallest(lst: [5, 1, 4, 3, 2])\n/// 2\n/// >>> next_smallest(lst: []\
    \ as [Int])\n/// nil\n/// >>> next_smallest(lst: [1, 1])\n/// nil\nfunc next_smallest(lst:\
    \ [Int]) -> Int? {\n    var minimum = Int.max\n    var secondMinimum = Int.max\n\
    \    for e in lst {\n        if e < minimum {\n            secondMinimum = minimum\n\
    \            minimum = e\n        } else if e < secondMinimum {\n            secondMinimum\
    \ = e\n        }\n    }\n    return secondMinimum == Int.max ? nil : secondMinimum\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(next_smallest(lst: [1, 2, 3, 4, 5]) == 2)\nassert(next_smallest(lst:\
    \ [5, 1, 4, 3, 2]) == 2)\nassert(next_smallest(lst: [] as [Int]) == nil)\nassert(next_smallest(lst:\
    \ [1, 1]) == nil)\nassert(next_smallest(lst: [1, 1, 1, 1, 0]) == 1)\nassert(next_smallest(lst:\
    \ [1, 1]) == nil)\nassert(next_smallest(lst: [-35, 34, 12, -45]) == -35)"
  status: Exception
  stderr: 'tmpfgkanraw/tmpfgkanraw.swift:43: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b062e4f2c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b062e1e9b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b062e1e9988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b062e1e87b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpfgkanraw                        0x000055579b3fe8da <unavailable> + 6362

    5    libc.so.6                          0x00002b062e6de460 __libc_start_main +
    245

    6    tmpfgkanraw                        0x000055579b3fe0d9 <unavailable> + 4313

    '
  stdout: ''
  timestamp: 1660013382
- exit_code: 0
  program: "\n/// You are given an array of integers.\n/// Write a function next_smallest()\
    \ that returns the 2nd smallest element of the array.\n/// Return nil if there\
    \ is no such element.\n/// >>> next_smallest(lst: [1, 2, 3, 4, 5])\n/// 2\n///\
    \ >>> next_smallest(lst: [5, 1, 4, 3, 2])\n/// 2\n/// >>> next_smallest(lst: []\
    \ as [Int])\n/// nil\n/// >>> next_smallest(lst: [1, 1])\n/// nil\nfunc next_smallest(lst:\
    \ [Int]) -> Int? {\n    let sorted = lst.sorted()\n    if sorted.count < 2 {\n\
    \        return nil\n    }\n    var prev = sorted[0]\n    for current in sorted[1...]\
    \ {\n        if current != prev {\n            return current\n        }\n   \
    \     prev = current\n    }\n    return nil\n}\n\n\nfunc ==(left: [(Int, Int)],\
    \ right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n       \
    \ return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r\
    \ {\n            return false\n        }\n    }\n    return true\n}\n        \
    \    \nassert(next_smallest(lst: [1, 2, 3, 4, 5]) == 2)\nassert(next_smallest(lst:\
    \ [5, 1, 4, 3, 2]) == 2)\nassert(next_smallest(lst: [] as [Int]) == nil)\nassert(next_smallest(lst:\
    \ [1, 1]) == nil)\nassert(next_smallest(lst: [1, 1, 1, 1, 0]) == 1)\nassert(next_smallest(lst:\
    \ [1, 1]) == nil)\nassert(next_smallest(lst: [-35, 34, 12, -45]) == -35)"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660013382
- exit_code: -4
  program: "\n/// You are given an array of integers.\n/// Write a function next_smallest()\
    \ that returns the 2nd smallest element of the array.\n/// Return nil if there\
    \ is no such element.\n/// >>> next_smallest(lst: [1, 2, 3, 4, 5])\n/// 2\n///\
    \ >>> next_smallest(lst: [5, 1, 4, 3, 2])\n/// 2\n/// >>> next_smallest(lst: []\
    \ as [Int])\n/// nil\n/// >>> next_smallest(lst: [1, 1])\n/// nil\nfunc next_smallest(lst:\
    \ [Int]) -> Int? {\n    guard lst.count > 1 else { return nil }\n    return lst.sorted()[1]\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(next_smallest(lst: [1, 2, 3, 4, 5]) == 2)\nassert(next_smallest(lst:\
    \ [5, 1, 4, 3, 2]) == 2)\nassert(next_smallest(lst: [] as [Int]) == nil)\nassert(next_smallest(lst:\
    \ [1, 1]) == nil)\nassert(next_smallest(lst: [1, 1, 1, 1, 0]) == 1)\nassert(next_smallest(lst:\
    \ [1, 1]) == nil)\nassert(next_smallest(lst: [-35, 34, 12, -45]) == -35)"
  status: Exception
  stderr: 'tmp1x1056z1/tmp1x1056z1.swift:34: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b3c07f1bc80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b3c07c12b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b3c07c12988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b3c07c117b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmp1x1056z1                        0x000055f9b45e78ba <unavailable> + 6330

    5    libc.so.6                          0x00002b3c08107460 __libc_start_main +
    245

    6    tmp1x1056z1                        0x000055f9b45e70b9 <unavailable> + 4281

    '
  stdout: ''
  timestamp: 1660013382
- exit_code: 0
  program: "\n/// You are given an array of integers.\n/// Write a function next_smallest()\
    \ that returns the 2nd smallest element of the array.\n/// Return nil if there\
    \ is no such element.\n/// >>> next_smallest(lst: [1, 2, 3, 4, 5])\n/// 2\n///\
    \ >>> next_smallest(lst: [5, 1, 4, 3, 2])\n/// 2\n/// >>> next_smallest(lst: []\
    \ as [Int])\n/// nil\n/// >>> next_smallest(lst: [1, 1])\n/// nil\nfunc next_smallest(lst:\
    \ [Int]) -> Int? {\n    guard lst.count > 1 else { return nil }\n    let sortedLst\
    \ = lst.sorted()\n    if sortedLst[0] == sortedLst[1] {\n        return nil\n\
    \    }\n    return sortedLst[1]\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int,\
    \ Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n\
    \    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n          \
    \  return false\n        }\n    }\n    return true\n}\n            \nassert(next_smallest(lst:\
    \ [1, 2, 3, 4, 5]) == 2)\nassert(next_smallest(lst: [5, 1, 4, 3, 2]) == 2)\nassert(next_smallest(lst:\
    \ [] as [Int]) == nil)\nassert(next_smallest(lst: [1, 1]) == nil)\nassert(next_smallest(lst:\
    \ [1, 1, 1, 1, 0]) == 1)\nassert(next_smallest(lst: [1, 1]) == nil)\nassert(next_smallest(lst:\
    \ [-35, 34, 12, -45]) == -35)"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660013382
- exit_code: 0
  program: "\n/// You are given an array of integers.\n/// Write a function next_smallest()\
    \ that returns the 2nd smallest element of the array.\n/// Return nil if there\
    \ is no such element.\n/// >>> next_smallest(lst: [1, 2, 3, 4, 5])\n/// 2\n///\
    \ >>> next_smallest(lst: [5, 1, 4, 3, 2])\n/// 2\n/// >>> next_smallest(lst: []\
    \ as [Int])\n/// nil\n/// >>> next_smallest(lst: [1, 1])\n/// nil\nfunc next_smallest(lst:\
    \ [Int]) -> Int? {\n    \n    var lst = lst\n    if lst.count < 2 {\n        return\
    \ nil\n    }\n    \n    var n = lst.count\n    var minimum = lst[0]\n    var second_minimum\
    \ = lst[1]\n    \n    for i in 0..<n {\n        if lst[i] < minimum {\n      \
    \      second_minimum = minimum\n            minimum = lst[i]\n        }\n   \
    \     else if lst[i] > minimum && lst[i] < second_minimum {\n            second_minimum\
    \ = lst[i]\n        }\n    }\n    \n    if second_minimum == minimum {\n     \
    \   return nil\n    }\n    \n    return second_minimum\n}\n\n\nfunc ==(left: [(Int,\
    \ Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n\
    \        return false\n    }\n    for (l, r) in zip(left, right) {\n        if\
    \ l != r {\n            return false\n        }\n    }\n    return true\n}\n \
    \           \nassert(next_smallest(lst: [1, 2, 3, 4, 5]) == 2)\nassert(next_smallest(lst:\
    \ [5, 1, 4, 3, 2]) == 2)\nassert(next_smallest(lst: [] as [Int]) == nil)\nassert(next_smallest(lst:\
    \ [1, 1]) == nil)\nassert(next_smallest(lst: [1, 1, 1, 1, 0]) == 1)\nassert(next_smallest(lst:\
    \ [1, 1]) == nil)\nassert(next_smallest(lst: [-35, 34, 12, -45]) == -35)"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660013382
- exit_code: -4
  program: "\n/// You are given an array of integers.\n/// Write a function next_smallest()\
    \ that returns the 2nd smallest element of the array.\n/// Return nil if there\
    \ is no such element.\n/// >>> next_smallest(lst: [1, 2, 3, 4, 5])\n/// 2\n///\
    \ >>> next_smallest(lst: [5, 1, 4, 3, 2])\n/// 2\n/// >>> next_smallest(lst: []\
    \ as [Int])\n/// nil\n/// >>> next_smallest(lst: [1, 1])\n/// nil\nfunc next_smallest(lst:\
    \ [Int]) -> Int? {\n    if lst.count < 2 {\n        return nil\n    }\n\n    var\
    \ smallest = lst[0]\n    var nextSmallest = lst[1]\n\n    for i in 0...lst.count\
    \ - 1 {\n        if lst[i] < smallest {\n            nextSmallest = smallest\n\
    \            smallest = lst[i]\n        } else if lst[i] < nextSmallest {\n  \
    \          nextSmallest = lst[i]\n        }\n    }\n\n    return nextSmallest\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(next_smallest(lst: [1, 2, 3, 4, 5]) == 2)\nassert(next_smallest(lst:\
    \ [5, 1, 4, 3, 2]) == 2)\nassert(next_smallest(lst: [] as [Int]) == nil)\nassert(next_smallest(lst:\
    \ [1, 1]) == nil)\nassert(next_smallest(lst: [1, 1, 1, 1, 0]) == 1)\nassert(next_smallest(lst:\
    \ [1, 1]) == nil)\nassert(next_smallest(lst: [-35, 34, 12, -45]) == -35)"
  status: Exception
  stderr: 'tmpnrxjw3cb/tmpnrxjw3cb.swift:46: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b4e708f4c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b4e705ebb6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b4e705eb988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b4e705ea7b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpnrxjw3cb                        0x00005565a60dd621 <unavailable> + 5665

    5    libc.so.6                          0x00002b4e70ae0460 __libc_start_main +
    245

    6    tmpnrxjw3cb                        0x00005565a60dd1a9 <unavailable> + 4521

    '
  stdout: ''
  timestamp: 1660013382
- exit_code: 0
  program: "\n/// You are given an array of integers.\n/// Write a function next_smallest()\
    \ that returns the 2nd smallest element of the array.\n/// Return nil if there\
    \ is no such element.\n/// >>> next_smallest(lst: [1, 2, 3, 4, 5])\n/// 2\n///\
    \ >>> next_smallest(lst: [5, 1, 4, 3, 2])\n/// 2\n/// >>> next_smallest(lst: []\
    \ as [Int])\n/// nil\n/// >>> next_smallest(lst: [1, 1])\n/// nil\nfunc next_smallest(lst:\
    \ [Int]) -> Int? {\n    guard lst.count > 1 else { return nil }\n    let sortedList\
    \ = lst.sorted()\n    for i in 1..<sortedList.count {\n        if sortedList[i]\
    \ != sortedList[i - 1] {\n            return sortedList[i]\n        }\n    }\n\
    \    return nil\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool\
    \ {\n    if left.count != right.count {\n        return false\n    }\n    for\
    \ (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(next_smallest(lst:\
    \ [1, 2, 3, 4, 5]) == 2)\nassert(next_smallest(lst: [5, 1, 4, 3, 2]) == 2)\nassert(next_smallest(lst:\
    \ [] as [Int]) == nil)\nassert(next_smallest(lst: [1, 1]) == nil)\nassert(next_smallest(lst:\
    \ [1, 1, 1, 1, 0]) == 1)\nassert(next_smallest(lst: [1, 1]) == nil)\nassert(next_smallest(lst:\
    \ [-35, 34, 12, -45]) == -35)"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660013382
- exit_code: 0
  program: "\n/// You are given an array of integers.\n/// Write a function next_smallest()\
    \ that returns the 2nd smallest element of the array.\n/// Return nil if there\
    \ is no such element.\n/// >>> next_smallest(lst: [1, 2, 3, 4, 5])\n/// 2\n///\
    \ >>> next_smallest(lst: [5, 1, 4, 3, 2])\n/// 2\n/// >>> next_smallest(lst: []\
    \ as [Int])\n/// nil\n/// >>> next_smallest(lst: [1, 1])\n/// nil\nfunc next_smallest(lst:\
    \ [Int]) -> Int? {\n    guard lst.count > 1 else { return nil }\n    let sortedLst\
    \ = lst.sorted()\n    guard sortedLst[0] != sortedLst[1] else { return nil }\n\
    \    return sortedLst[1]\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(next_smallest(lst:\
    \ [1, 2, 3, 4, 5]) == 2)\nassert(next_smallest(lst: [5, 1, 4, 3, 2]) == 2)\nassert(next_smallest(lst:\
    \ [] as [Int]) == nil)\nassert(next_smallest(lst: [1, 1]) == nil)\nassert(next_smallest(lst:\
    \ [1, 1, 1, 1, 0]) == 1)\nassert(next_smallest(lst: [1, 1]) == nil)\nassert(next_smallest(lst:\
    \ [-35, 34, 12, -45]) == -35)"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660013382
- exit_code: -4
  program: "\n/// You are given an array of integers.\n/// Write a function next_smallest()\
    \ that returns the 2nd smallest element of the array.\n/// Return nil if there\
    \ is no such element.\n/// >>> next_smallest(lst: [1, 2, 3, 4, 5])\n/// 2\n///\
    \ >>> next_smallest(lst: [5, 1, 4, 3, 2])\n/// 2\n/// >>> next_smallest(lst: []\
    \ as [Int])\n/// nil\n/// >>> next_smallest(lst: [1, 1])\n/// nil\nfunc next_smallest(lst:\
    \ [Int]) -> Int? {\n    guard lst.count > 1 else { return nil }\n    var smallest\
    \ = lst[0]\n    var secondSmallest = lst[1]\n    for num in lst {\n        if\
    \ num < smallest {\n            secondSmallest = smallest\n            smallest\
    \ = num\n        } else if num < secondSmallest {\n            secondSmallest\
    \ = num\n        }\n    }\n    return secondSmallest\n}\n\n\nfunc ==(left: [(Int,\
    \ Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n\
    \        return false\n    }\n    for (l, r) in zip(left, right) {\n        if\
    \ l != r {\n            return false\n        }\n    }\n    return true\n}\n \
    \           \nassert(next_smallest(lst: [1, 2, 3, 4, 5]) == 2)\nassert(next_smallest(lst:\
    \ [5, 1, 4, 3, 2]) == 2)\nassert(next_smallest(lst: [] as [Int]) == nil)\nassert(next_smallest(lst:\
    \ [1, 1]) == nil)\nassert(next_smallest(lst: [1, 1, 1, 1, 0]) == 1)\nassert(next_smallest(lst:\
    \ [1, 1]) == nil)\nassert(next_smallest(lst: [-35, 34, 12, -45]) == -35)"
  status: Exception
  stderr: 'tmpubf1rj8b/tmpubf1rj8b.swift:41: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b0c13652c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b0c13349b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b0c13349988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b0c133487b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpubf1rj8b                        0x00005576498e2601 <unavailable> + 5633

    5    libc.so.6                          0x00002b0c1383e460 __libc_start_main +
    245

    6    tmpubf1rj8b                        0x00005576498e2189 <unavailable> + 4489

    '
  stdout: ''
  timestamp: 1660013382
- exit_code: -4
  program: "\n/// You are given an array of integers.\n/// Write a function next_smallest()\
    \ that returns the 2nd smallest element of the array.\n/// Return nil if there\
    \ is no such element.\n/// >>> next_smallest(lst: [1, 2, 3, 4, 5])\n/// 2\n///\
    \ >>> next_smallest(lst: [5, 1, 4, 3, 2])\n/// 2\n/// >>> next_smallest(lst: []\
    \ as [Int])\n/// nil\n/// >>> next_smallest(lst: [1, 1])\n/// nil\nfunc next_smallest(lst:\
    \ [Int]) -> Int? {\n    guard lst.count > 1 else { return nil }\n    var smallest\
    \ = lst[0]\n    var next_smallest = lst[1]\n    for i in lst {\n        if i >\
    \ smallest {\n            if i < next_smallest {\n                next_smallest\
    \ = i\n            }\n        } else {\n            smallest = i\n        }\n\
    \    }\n    if smallest == next_smallest {\n        return nil\n    }\n    return\
    \ next_smallest\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool\
    \ {\n    if left.count != right.count {\n        return false\n    }\n    for\
    \ (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(next_smallest(lst:\
    \ [1, 2, 3, 4, 5]) == 2)\nassert(next_smallest(lst: [5, 1, 4, 3, 2]) == 2)\nassert(next_smallest(lst:\
    \ [] as [Int]) == nil)\nassert(next_smallest(lst: [1, 1]) == nil)\nassert(next_smallest(lst:\
    \ [1, 1, 1, 1, 0]) == 1)\nassert(next_smallest(lst: [1, 1]) == nil)\nassert(next_smallest(lst:\
    \ [-35, 34, 12, -45]) == -35)"
  status: Exception
  stderr: 'tmp1aay8ajv/tmp1aay8ajv.swift:46: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b6b12b8fc80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b6b12886b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b6b12886988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b6b128857b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmp1aay8ajv                        0x00005646c0f1c7a5 <unavailable> + 6053

    5    libc.so.6                          0x00002b6b12d7b460 __libc_start_main +
    245

    6    tmp1aay8ajv                        0x00005646c0f1c189 <unavailable> + 4489

    '
  stdout: ''
  timestamp: 1660013382
- exit_code: 0
  program: "\n/// You are given an array of integers.\n/// Write a function next_smallest()\
    \ that returns the 2nd smallest element of the array.\n/// Return nil if there\
    \ is no such element.\n/// >>> next_smallest(lst: [1, 2, 3, 4, 5])\n/// 2\n///\
    \ >>> next_smallest(lst: [5, 1, 4, 3, 2])\n/// 2\n/// >>> next_smallest(lst: []\
    \ as [Int])\n/// nil\n/// >>> next_smallest(lst: [1, 1])\n/// nil\nfunc next_smallest(lst:\
    \ [Int]) -> Int? {\n    if lst.count < 2 {\n        return nil\n    }\n    var\
    \ sortedArray = lst.sorted()\n    var i = 0\n    while i < sortedArray.count -\
    \ 1 {\n        if sortedArray[i] != sortedArray[i + 1] {\n            return sortedArray[i\
    \ + 1]\n        }\n        i += 1\n    }\n    return nil\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(next_smallest(lst: [1, 2, 3, 4, 5]) == 2)\nassert(next_smallest(lst:\
    \ [5, 1, 4, 3, 2]) == 2)\nassert(next_smallest(lst: [] as [Int]) == nil)\nassert(next_smallest(lst:\
    \ [1, 1]) == nil)\nassert(next_smallest(lst: [1, 1, 1, 1, 0]) == 1)\nassert(next_smallest(lst:\
    \ [1, 1]) == nil)\nassert(next_smallest(lst: [-35, 34, 12, -45]) == -35)"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660013382
- exit_code: -4
  program: "\n/// You are given an array of integers.\n/// Write a function next_smallest()\
    \ that returns the 2nd smallest element of the array.\n/// Return nil if there\
    \ is no such element.\n/// >>> next_smallest(lst: [1, 2, 3, 4, 5])\n/// 2\n///\
    \ >>> next_smallest(lst: [5, 1, 4, 3, 2])\n/// 2\n/// >>> next_smallest(lst: []\
    \ as [Int])\n/// nil\n/// >>> next_smallest(lst: [1, 1])\n/// nil\nfunc next_smallest(lst:\
    \ [Int]) -> Int? {\n    if lst.count < 2 {\n        return nil\n    }\n    var\
    \ min = lst[0]\n    var sec_min = lst[1]\n    for i in 2..<lst.count {\n     \
    \   if lst[i] < min {\n            sec_min = min\n            min = lst[i]\n \
    \       } else if lst[i] < sec_min {\n            sec_min = lst[i]\n        }\n\
    \    }\n    return sec_min\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(next_smallest(lst:\
    \ [1, 2, 3, 4, 5]) == 2)\nassert(next_smallest(lst: [5, 1, 4, 3, 2]) == 2)\nassert(next_smallest(lst:\
    \ [] as [Int]) == nil)\nassert(next_smallest(lst: [1, 1]) == nil)\nassert(next_smallest(lst:\
    \ [1, 1, 1, 1, 0]) == 1)\nassert(next_smallest(lst: [1, 1]) == nil)\nassert(next_smallest(lst:\
    \ [-35, 34, 12, -45]) == -35)"
  status: Exception
  stderr: 'tmp2xnjhbkk/tmp2xnjhbkk.swift:44: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b6ae3325c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b6ae301cb6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b6ae301c988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b6ae301b7b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmp2xnjhbkk                        0x0000556dc8ee47c5 <unavailable> + 6085

    5    libc.so.6                          0x00002b6ae3511460 __libc_start_main +
    245

    6    tmp2xnjhbkk                        0x0000556dc8ee41a9 <unavailable> + 4521

    '
  stdout: ''
  timestamp: 1660013382
- exit_code: 0
  program: "\n/// You are given an array of integers.\n/// Write a function next_smallest()\
    \ that returns the 2nd smallest element of the array.\n/// Return nil if there\
    \ is no such element.\n/// >>> next_smallest(lst: [1, 2, 3, 4, 5])\n/// 2\n///\
    \ >>> next_smallest(lst: [5, 1, 4, 3, 2])\n/// 2\n/// >>> next_smallest(lst: []\
    \ as [Int])\n/// nil\n/// >>> next_smallest(lst: [1, 1])\n/// nil\nfunc next_smallest(lst:\
    \ [Int]) -> Int? {\n    if lst.count < 2 {\n        return nil\n    }\n    var\
    \ sortedLst = lst.sorted()\n    for i in 0...sortedLst.count - 2 {\n        if\
    \ sortedLst[i] != sortedLst[i + 1] {\n            return sortedLst[i + 1]\n  \
    \      }\n    }\n    return nil\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int,\
    \ Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n\
    \    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n          \
    \  return false\n        }\n    }\n    return true\n}\n            \nassert(next_smallest(lst:\
    \ [1, 2, 3, 4, 5]) == 2)\nassert(next_smallest(lst: [5, 1, 4, 3, 2]) == 2)\nassert(next_smallest(lst:\
    \ [] as [Int]) == nil)\nassert(next_smallest(lst: [1, 1]) == nil)\nassert(next_smallest(lst:\
    \ [1, 1, 1, 1, 0]) == 1)\nassert(next_smallest(lst: [1, 1]) == nil)\nassert(next_smallest(lst:\
    \ [-35, 34, 12, -45]) == -35)"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660013382
- exit_code: -4
  program: "\n/// You are given an array of integers.\n/// Write a function next_smallest()\
    \ that returns the 2nd smallest element of the array.\n/// Return nil if there\
    \ is no such element.\n/// >>> next_smallest(lst: [1, 2, 3, 4, 5])\n/// 2\n///\
    \ >>> next_smallest(lst: [5, 1, 4, 3, 2])\n/// 2\n/// >>> next_smallest(lst: []\
    \ as [Int])\n/// nil\n/// >>> next_smallest(lst: [1, 1])\n/// nil\nfunc next_smallest(lst:\
    \ [Int]) -> Int? {\n    return lst.count < 2 ? nil : lst.sorted()[1]\n}\n\n\n\
    func ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(next_smallest(lst: [1, 2, 3, 4, 5]) == 2)\nassert(next_smallest(lst:\
    \ [5, 1, 4, 3, 2]) == 2)\nassert(next_smallest(lst: [] as [Int]) == nil)\nassert(next_smallest(lst:\
    \ [1, 1]) == nil)\nassert(next_smallest(lst: [1, 1, 1, 1, 0]) == 1)\nassert(next_smallest(lst:\
    \ [1, 1]) == nil)\nassert(next_smallest(lst: [-35, 34, 12, -45]) == -35)"
  status: Exception
  stderr: 'tmp8l03lhdr/tmp8l03lhdr.swift:33: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b67b78f1c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b67b75e8b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b67b75e8988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b67b75e77b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmp8l03lhdr                        0x0000557d6a0cf8ba <unavailable> + 6330

    5    libc.so.6                          0x00002b67b7add460 __libc_start_main +
    245

    6    tmp8l03lhdr                        0x0000557d6a0cf0b9 <unavailable> + 4281

    '
  stdout: ''
  timestamp: 1660013382
- exit_code: -4
  program: "\n/// You are given an array of integers.\n/// Write a function next_smallest()\
    \ that returns the 2nd smallest element of the array.\n/// Return nil if there\
    \ is no such element.\n/// >>> next_smallest(lst: [1, 2, 3, 4, 5])\n/// 2\n///\
    \ >>> next_smallest(lst: [5, 1, 4, 3, 2])\n/// 2\n/// >>> next_smallest(lst: []\
    \ as [Int])\n/// nil\n/// >>> next_smallest(lst: [1, 1])\n/// nil\nfunc next_smallest(lst:\
    \ [Int]) -> Int? {\n    if lst.count < 2 {\n        return nil\n    }\n    var\
    \ n1 = Int.max\n    var n2 = Int.max\n    for n in lst {\n        if n < n1 {\n\
    \            n2 = n1\n            n1 = n\n        } else if n < n2 {\n       \
    \     n2 = n\n        }\n    }\n    return n2\n}\n\n\nfunc ==(left: [(Int, Int)],\
    \ right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n       \
    \ return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r\
    \ {\n            return false\n        }\n    }\n    return true\n}\n        \
    \    \nassert(next_smallest(lst: [1, 2, 3, 4, 5]) == 2)\nassert(next_smallest(lst:\
    \ [5, 1, 4, 3, 2]) == 2)\nassert(next_smallest(lst: [] as [Int]) == nil)\nassert(next_smallest(lst:\
    \ [1, 1]) == nil)\nassert(next_smallest(lst: [1, 1, 1, 1, 0]) == 1)\nassert(next_smallest(lst:\
    \ [1, 1]) == nil)\nassert(next_smallest(lst: [-35, 34, 12, -45]) == -35)"
  status: Exception
  stderr: 'tmpn1s3bhmp/tmpn1s3bhmp.swift:46: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b648b5cdc80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b648b2c4b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b648b2c4988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b648b2c37b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpn1s3bhmp                        0x000055ee1766d92a <unavailable> + 6442

    5    libc.so.6                          0x00002b648b7b9460 __libc_start_main +
    245

    6    tmpn1s3bhmp                        0x000055ee1766d129 <unavailable> + 4393

    '
  stdout: ''
  timestamp: 1660013382
- exit_code: -4
  program: "\n/// You are given an array of integers.\n/// Write a function next_smallest()\
    \ that returns the 2nd smallest element of the array.\n/// Return nil if there\
    \ is no such element.\n/// >>> next_smallest(lst: [1, 2, 3, 4, 5])\n/// 2\n///\
    \ >>> next_smallest(lst: [5, 1, 4, 3, 2])\n/// 2\n/// >>> next_smallest(lst: []\
    \ as [Int])\n/// nil\n/// >>> next_smallest(lst: [1, 1])\n/// nil\nfunc next_smallest(lst:\
    \ [Int]) -> Int? {\n    guard lst.count > 1 else { return nil }\n    let sortedLst\
    \ = lst.sorted()\n    return sortedLst[1]\n}\n\n\nfunc ==(left: [(Int, Int)],\
    \ right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n       \
    \ return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r\
    \ {\n            return false\n        }\n    }\n    return true\n}\n        \
    \    \nassert(next_smallest(lst: [1, 2, 3, 4, 5]) == 2)\nassert(next_smallest(lst:\
    \ [5, 1, 4, 3, 2]) == 2)\nassert(next_smallest(lst: [] as [Int]) == nil)\nassert(next_smallest(lst:\
    \ [1, 1]) == nil)\nassert(next_smallest(lst: [1, 1, 1, 1, 0]) == 1)\nassert(next_smallest(lst:\
    \ [1, 1]) == nil)\nassert(next_smallest(lst: [-35, 34, 12, -45]) == -35)"
  status: Exception
  stderr: 'tmpr3jnlaj1/tmpr3jnlaj1.swift:35: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002adf91e2fc80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002adf91b26b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002adf91b26988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002adf91b257b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpr3jnlaj1                        0x000056042c3828ba <unavailable> + 6330

    5    libc.so.6                          0x00002adf9201b460 __libc_start_main +
    245

    6    tmpr3jnlaj1                        0x000056042c3820b9 <unavailable> + 4281

    '
  stdout: ''
  timestamp: 1660013219
- exit_code: 1
  program: "\n/// You are given an array of integers.\n/// Write a function next_smallest()\
    \ that returns the 2nd smallest element of the array.\n/// Return nil if there\
    \ is no such element.\n/// >>> next_smallest(lst: [1, 2, 3, 4, 5])\n/// 2\n///\
    \ >>> next_smallest(lst: [5, 1, 4, 3, 2])\n/// 2\n/// >>> next_smallest(lst: []\
    \ as [Int])\n/// nil\n/// >>> next_smallest(lst: [1, 1])\n/// nil\nfunc next_smallest(lst:\
    \ [Int]) -> Int? {\n    return lst.sorted()[safe: 1]\n}\n\n\nfunc ==(left: [(Int,\
    \ Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n\
    \        return false\n    }\n    for (l, r) in zip(left, right) {\n        if\
    \ l != r {\n            return false\n        }\n    }\n    return true\n}\n \
    \           \nassert(next_smallest(lst: [1, 2, 3, 4, 5]) == 2)\nassert(next_smallest(lst:\
    \ [5, 1, 4, 3, 2]) == 2)\nassert(next_smallest(lst: [] as [Int]) == nil)\nassert(next_smallest(lst:\
    \ [1, 1]) == nil)\nassert(next_smallest(lst: [1, 1, 1, 1, 0]) == 1)\nassert(next_smallest(lst:\
    \ [1, 1]) == nil)\nassert(next_smallest(lst: [-35, 34, 12, -45]) == -35)"
  status: SyntaxError
  stderr: "/tmp/tmp4gcy14ib.swift:14:24: error: extraneous argument label 'safe:'\
    \ in subscript\n    return lst.sorted()[safe: 1]\n                       ^~~~~~~\n\
    \                        \n"
  stdout: ''
  timestamp: 1660013379
- exit_code: -4
  program: "\n/// You are given an array of integers.\n/// Write a function next_smallest()\
    \ that returns the 2nd smallest element of the array.\n/// Return nil if there\
    \ is no such element.\n/// >>> next_smallest(lst: [1, 2, 3, 4, 5])\n/// 2\n///\
    \ >>> next_smallest(lst: [5, 1, 4, 3, 2])\n/// 2\n/// >>> next_smallest(lst: []\
    \ as [Int])\n/// nil\n/// >>> next_smallest(lst: [1, 1])\n/// nil\nfunc next_smallest(lst:\
    \ [Int]) -> Int? {\n    let array = lst.sorted()\n    var min = array[0]\n   \
    \ for element in array {\n        if min < element {\n            return min\n\
    \        }\n        min = element\n    }\n    return nil\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(next_smallest(lst: [1, 2, 3, 4, 5]) == 2)\nassert(next_smallest(lst:\
    \ [5, 1, 4, 3, 2]) == 2)\nassert(next_smallest(lst: [] as [Int]) == nil)\nassert(next_smallest(lst:\
    \ [1, 1]) == nil)\nassert(next_smallest(lst: [1, 1, 1, 1, 0]) == 1)\nassert(next_smallest(lst:\
    \ [1, 1]) == nil)\nassert(next_smallest(lst: [-35, 34, 12, -45]) == -35)"
  status: Exception
  stderr: 'tmpws8crn4z/tmpws8crn4z.swift:38: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002acd2a8f6c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002acd2a5edb6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002acd2a5ed988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002acd2a5ec7b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpws8crn4z                        0x0000559ce682e651 <unavailable> + 5713

    5    libc.so.6                          0x00002acd2aae2460 __libc_start_main +
    245

    6    tmpws8crn4z                        0x0000559ce682e1d9 <unavailable> + 4569

    '
  stdout: ''
  timestamp: 1660013382
- exit_code: -4
  program: "\n/// You are given an array of integers.\n/// Write a function next_smallest()\
    \ that returns the 2nd smallest element of the array.\n/// Return nil if there\
    \ is no such element.\n/// >>> next_smallest(lst: [1, 2, 3, 4, 5])\n/// 2\n///\
    \ >>> next_smallest(lst: [5, 1, 4, 3, 2])\n/// 2\n/// >>> next_smallest(lst: []\
    \ as [Int])\n/// nil\n/// >>> next_smallest(lst: [1, 1])\n/// nil\nfunc next_smallest(lst:\
    \ [Int]) -> Int? {\n    guard lst.count > 1 else { return nil }\n    var smallest\
    \ = lst[0]\n    var secondSmallest = lst[1]\n    if secondSmallest < smallest\
    \ {\n        smallest = secondSmallest\n        secondSmallest = lst[0]\n    }\n\
    \    for element in lst {\n        if element < smallest {\n            secondSmallest\
    \ = smallest\n            smallest = element\n        } else if element < secondSmallest\
    \ {\n            secondSmallest = element\n        }\n    }\n    return secondSmallest\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(next_smallest(lst: [1, 2, 3, 4, 5]) == 2)\nassert(next_smallest(lst:\
    \ [5, 1, 4, 3, 2]) == 2)\nassert(next_smallest(lst: [] as [Int]) == nil)\nassert(next_smallest(lst:\
    \ [1, 1]) == nil)\nassert(next_smallest(lst: [1, 1, 1, 1, 0]) == 1)\nassert(next_smallest(lst:\
    \ [1, 1]) == nil)\nassert(next_smallest(lst: [-35, 34, 12, -45]) == -35)"
  status: Exception
  stderr: 'tmpc8mx8ir8/tmpc8mx8ir8.swift:45: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b9038898c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b903858fb6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b903858f988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b903858e7b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpc8mx8ir8                        0x000055bc0fd57601 <unavailable> + 5633

    5    libc.so.6                          0x00002b9038a84460 __libc_start_main +
    245

    6    tmpc8mx8ir8                        0x000055bc0fd57189 <unavailable> + 4489

    '
  stdout: ''
  timestamp: 1660013382
