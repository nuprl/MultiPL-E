name: HumanEval_162_string_to_md5
language: swift
prompt: "\n/// Given a string 'text', return its md5 hash equivalent string.\n///\
  \ If 'text' is an empty string, return nil.\n/// >>> string_to_md5(text: \"Hello\
  \ world\")\n/// \"3e25960a79dbc69b674cd4ec67a72c62\"\nfunc string_to_md5(text: String)\
  \ -> String? {\n"
tests: "}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if\
  \ left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left,\
  \ right) {\n        if l != r {\n            return false\n        }\n    }\n  \
  \  return true\n}\n            \nassert(string_to_md5(text: \"Hello world\") ==\
  \ \"3e25960a79dbc69b674cd4ec67a72c62\")\nassert(string_to_md5(text: \"\") == nil)\n\
  assert(string_to_md5(text: \"A B C\") == \"0ef78513b0cb8cef12743f5aeb35f888\")\n\
  assert(string_to_md5(text: \"password\") == \"5f4dcc3b5aa765d61d8327deb882cf99\"\
  )"
completions: ["    guard !text.isEmpty else {\n        return nil\n    }\n    let\
    \ messageData = text.data(using:.utf8)!\n    var digestData = Data(count: Int(CC_MD5_DIGEST_LENGTH))\n\
    \    \n    _ = digestData.withUnsafeMutableBytes {digestBytes in\n        messageData.withUnsafeBytes\
    \ {messageBytes in\n            CC_MD5(messageBytes, CC_LONG(messageData.count),\
    \ digestBytes)\n        }\n    }\n    return digestData.map { String(format: \"\
    %02hhx\", $0) }.joined()", "    if let textData = text.data(using: .utf8) {\n\
    \        return digest_to_md5(digest: textData.md5())?.hex\n    }\n    return\
    \ nil", "  guard text.isEmpty == false else { return nil }\n  let textData = text.data(using:\
    \ .utf8)!\n  var textHash = [UInt8](repeating: 0, count: Int(CC_MD5_DIGEST_LENGTH))\n\
    \  textData.withUnsafeBytes {\n    _ = CC_MD5($0.baseAddress, CC_LONG(textData.count),\
    \ &textHash)\n  }\n  return textHash.map { String(format: \"%02x\", $0) }.joined()",
  "    if text.count > 0 {\n        let messageData = text.data(using:.utf8)!\n  \
    \      var digestData = Data(count: Int(CC_MD5_DIGEST_LENGTH))\n        \n   \
    \     _ = digestData.withUnsafeMutableBytes {digestBytes in\n            messageData.withUnsafeBytes\
    \ {messageBytes in\n                CC_MD5(messageBytes, CC_LONG(messageData.count),\
    \ digestBytes)\n            }\n        }\n        \n        return digestData.map\
    \ { String(format: \"%02hhx\", $0) }.joined()\n    }\n    return nil", "    guard\
    \ !text.isEmpty else {\n        return nil\n    }\n    let length = Int(CC_MD5_DIGEST_LENGTH)\n\
    \    var digest = [UInt8](repeating: 0, count: length)\n    if let d = text.data(using:\
    \ String.Encoding.utf8) {\n        _ = d.withUnsafeBytes { (body: UnsafePointer<UInt8>)\
    \ in\n            CC_MD5(body, CC_LONG(d.count), &digest)\n        }\n    }\n\
    \    return (0..<length).reduce(\"\") {\n        $0 + String(format: \"%02x\"\
    , digest[$1])\n    }", "    guard text.count > 0 else {\n        return nil\n\
    \    }\n    let messageData = text.data(using:.utf8)!\n    var digestData = Data(count:\
    \ Int(CC_MD5_DIGEST_LENGTH))\n    \n    _ = digestData.withUnsafeMutableBytes\
    \ {digestBytes in\n        messageData.withUnsafeBytes {messageBytes in\n    \
    \        CC_MD5(messageBytes, CC_LONG(messageData.count), digestBytes)\n     \
    \   }\n    }\n    return digestData.map { String(format: \"%02hhx\", $0) }.joined()",
  "    guard !text.isEmpty else {\n        return nil\n    }\n    let data = Data(text.utf8)\n\
    \    let md5Data = Insecure.MD5.hash(data: data)\n    return md5Data.map { String(format:\
    \ \"%02hhx\", $0) }.joined()", "    let length = Int(CC_MD5_DIGEST_LENGTH)\n \
    \   var digest = [UInt8](repeating: 0, count: length)\n    \n    if let d = text.data(using:\
    \ String.Encoding.utf8) {\n        _ = d.withUnsafeBytes { (body: UnsafePointer<UInt8>)\
    \ in\n            CC_MD5(body, CC_LONG(d.count), &digest)\n        }\n    }\n\
    \    \n    return (0..<length).reduce(\"\") {\n        $0 + String(format: \"\
    %02x\", digest[$1])\n    }", "    guard !text.isEmpty else {\n        return nil\n\
    \    }\n    let data = text.data(using: .utf8)!\n    let digest = MD5(data).calculate()\n\
    \    return digest.map({\n        String(format: \"%02hhx\", $0)\n    }).joined()",
  "    guard text.count > 0 else {\n        return nil\n    }\n    let data = text.data(using:\
    \ .utf8)!\n    var digest = [UInt8](repeating: 0, count: Int(CC_MD5_DIGEST_LENGTH))\n\
    \    _ = data.withUnsafeBytes { (bytes: UnsafePointer<UInt8>) -> [UInt8] in\n\
    \        CC_MD5(bytes, CC_LONG(data.count), &digest)\n        return digest\n\
    \    }\n    let hexBytes = digest.map { String(format: \"%02hhx\", $0) }\n   \
    \ return hexBytes.joined()", "    if text.isEmpty {\n        return nil\n    }\n\
    \    let messageData = text.data(using:.utf8)!\n    var digestData = Data(count:\
    \ Int(CC_MD5_DIGEST_LENGTH))\n    \n    _ = digestData.withUnsafeMutableBytes\
    \ {digestBytes in\n        messageData.withUnsafeBytes {messageBytes in\n    \
    \        CC_MD5(messageBytes, CC_LONG(messageData.count), digestBytes)\n     \
    \   }\n    }\n    return digestData.map { String(format: \"%02hhx\", $0) }.joined()",
  "    if text.count > 0 {\n        return text.data(using: .utf8)?.md5().hexString\n\
    \    }\n    return nil", "    if text.isEmpty {\n        return nil\n    }\n \
    \   let digestLength = Int(CC_MD5_DIGEST_LENGTH)\n    let md5Buffer = UnsafeMutablePointer<CUnsignedChar>.allocate(capacity:\
    \ digestLength)\n    if let data = text.data(using: String.Encoding.utf8) {\n\
    \        CC_MD5(data.bytes, CC_LONG(data.count), md5Buffer)\n        let output\
    \ = NSMutableString(capacity: Int(CC_MD5_DIGEST_LENGTH * 2))\n        for i in\
    \ 0..<digestLength {\n            output.appendFormat(\"%02x\", md5Buffer[i])\n\
    \        }\n        return String(format: output as String)\n    }\n    return\
    \ nil", "    if text.isEmpty {\n        return nil\n    }\n    let data = Data(text.utf8)\n\
    \    let hash = Insecure.MD5.hash(data: data)\n    let hashString = hash.map {\n\
    \        String(format: \"%02x\", $0)\n    }.joined()\n    return hashString",
  "    guard !text.isEmpty else {\n        return nil\n    }\n    let context = UnsafeMutablePointer<CC_MD5_CTX>.allocate(capacity:\
    \ 1)\n    var digest = Array<UInt8>(repeating:0, count:Int(CC_MD5_DIGEST_LENGTH))\n\
    \    CC_MD5_Init(context)\n    CC_MD5_Update(context, text, CC_LONG(text.lengthOfBytes(using:\
    \ String.Encoding.utf8)))\n    CC_MD5_Final(&digest, context)\n    context.deallocate()\n\
    \    var hexString = \"\"\n    for byte in digest {\n        hexString += String(format:\"\
    %02x\", byte)\n    }\n    return hexString", "    guard text.count > 0 else {\n\
    \        return nil\n    }\n    let length = Int(CC_MD5_DIGEST_LENGTH)\n    var\
    \ digest = [UInt8](repeating: 0, count: length)\n    if let d = text.data(using:\
    \ String.Encoding.utf8) {\n        _ = d.withUnsafeBytes { (body: UnsafePointer<UInt8>)\
    \ in\n            CC_MD5(body, CC_LONG(d.count), &digest)\n        }\n    }\n\
    \    return (0..<length).reduce(\"\") {\n        $0 + String(format: \"%02x\"\
    , digest[$1])\n    }", "    if text.isEmpty {\n        return nil\n    }\n   \
    \ var digest = [UInt8](repeating: 0, count: Int(CC_MD5_DIGEST_LENGTH))\n    if\
    \ let data = text.data(using: String.Encoding.utf8) {\n        let _ = data.withUnsafeBytes\
    \ { (bytes: UnsafePointer<UInt8>) -> Int in\n            CC_MD5(bytes, CC_LONG(data.count),\
    \ &digest)\n            return 0\n        }\n    }\n    return digest.map { String(format:\
    \ \"%02x\", $0) }.joined()", "    guard !text.isEmpty else {\n        return nil\n\
    \    }\n    let data = Data(text.utf8)\n    var hash = [UInt8](repeating: 0, count:\
    \ Int(CC_MD5_DIGEST_LENGTH))\n    data.withUnsafeBytes {\n        _ = CC_MD5($0.baseAddress,\
    \ CC_LONG(data.count), &hash)\n    }\n    return hash.map { String(format: \"\
    %02x\", $0) }.joined()", "    guard !text.isEmpty else {\n        return nil\n\
    \    }\n    return text.md5()", '    return text.data(using: .utf8)?.md5()', " \
    \   if let utf8 = text.cString(using: .utf8) {\n        let data = Data(bytes:\
    \ utf8)\n        return data.md5()\n    }\n    return nil", "    if text.isEmpty\
    \ {\n        return nil\n    }\n    return text.toUtf8().md5", "    guard !text.isEmpty\
    \ else {\n        return nil\n    }\n    let hash = MD5(text)\n    return hash.hexString",
  "\tif text.isEmpty {\n\t\treturn nil\n\t}\n\tif let data = text.data(using: .utf8)\
    \ {\n\t\treturn data_to_md5(data: data)\n\t}\n\treturn nil", "    if text.isEmpty\
    \ {\n        return nil\n    }\n    let data = text.data(using: .utf8)\n    var\
    \ digest = [UInt8](repeating: 0, count: Int(CC_MD5_DIGEST_LENGTH))\n    data?.withUnsafeBytes\
    \ {\n        _ = CC_MD5($0.baseAddress, CC_LONG(data!.count), &digest)\n    }\n\
    \    var md5String = \"\"\n    for byte in digest {\n        md5String += String(format:\"\
    %02x\", UInt8(byte))\n    }\n    return md5String", "    guard text.count > 0\
    \ else {\n        return nil\n    }\n    return text.md5()", "    if text.count\
    \ == 0 {\n        return nil\n    }\n    let context = UnsafeMutablePointer<CC_MD5_CTX>.allocate(capacity:\
    \ 1)\n    var digest = Array<UInt8>(repeating:0, count:Int(CC_MD5_DIGEST_LENGTH))\n\
    \    CC_MD5_Init(context)\n    CC_MD5_Update(context, text, CC_LONG(text.lengthOfBytes(using:\
    \ String.Encoding.utf8)))\n    CC_MD5_Final(&digest, context)\n    context.deallocate()\n\
    \    var hexString = \"\"\n    for byte in digest {\n        hexString += String(format:\"\
    %02x\", byte)\n    }\n    return hexString", "    if text.isEmpty {\n        return\
    \ nil\n    }\n    let md5 = MD5()\n    md5.update(with: text)\n    let digest\
    \ = md5.final()\n    return digest.map { String(format: \"%02hhx\", $0) }.joined()",
  "    guard !text.isEmpty else {\n        return nil\n    }\n    let messageData\
    \ = text.data(using:.utf8)!\n    var digestData = Data(count: Int(CC_MD5_DIGEST_LENGTH))\n\
    \    \n    _ = digestData.withUnsafeMutableBytes {digestBytes in\n        messageData.withUnsafeBytes\
    \ {messageBytes in\n            CC_MD5(messageBytes, CC_LONG(messageData.count),\
    \ digestBytes)\n        }\n    }\n    return digestData.map { String(format: \"\
    %02hhx\", $0) }.joined()", "  guard !text.isEmpty else { return nil }\n  let context\
    \ = UnsafeMutablePointer<CC_MD5_CTX>.allocate(capacity: 1)\n  var digest = Array<UInt8>(repeating:0,\
    \ count:Int(CC_MD5_DIGEST_LENGTH))\n  CC_MD5_Init(context)\n  CC_MD5_Update(context,\
    \ text, CC_LONG(text.lengthOfBytes(using: String.Encoding.utf8)))\n  CC_MD5_Final(&digest,\
    \ context)\n  context.deallocate()\n  var hexString = \"\"\n  for byte in digest\
    \ {\n    hexString += String(format:\"%02x\", byte)\n  }\n  return hexString",
  "    let length = Int(CC_MD5_DIGEST_LENGTH)\n    var digest = [UInt8](repeating:\
    \ 0, count: length)\n    \n    if let d = text.data(using: String.Encoding.utf8)\
    \ {\n        _ = d.withUnsafeBytes { (body: UnsafePointer<UInt8>) in\n       \
    \     CC_MD5(body, CC_LONG(d.count), &digest)\n        }\n    }\n    \n    return\
    \ (0..<length).reduce(\"\") {\n        $0 + String(format: \"%02x\", digest[$1])\n\
    \    }", "    if text.count > 0 {\n        var digest = [UInt8](repeating: 0,\
    \ count: Int(CC_MD5_DIGEST_LENGTH))\n        if let data = text.data(using: String.Encoding.utf8)\
    \ {\n            let _ = data.withUnsafeBytes {\n                CC_MD5($0, CC_LONG(data.count),\
    \ &digest)\n            }\n        }\n        var digestHex = \"\"\n        for\
    \ index in 0..<Int(CC_MD5_DIGEST_LENGTH) {\n            digestHex += String(format:\
    \ \"%02x\", digest[index])\n        }\n        return digestHex\n    }\n    return\
    \ nil", "    guard text.count > 0 else {\n        return nil\n    }\n    let messageData\
    \ = text.data(using:.utf8)!\n    var digestData = Data(count: Int(CC_MD5_DIGEST_LENGTH))\n\
    \    \n    _ = digestData.withUnsafeMutableBytes {digestBytes in\n        messageData.withUnsafeBytes\
    \ {messageBytes in\n            CC_MD5(messageBytes, CC_LONG(messageData.count),\
    \ digestBytes)\n        }\n    }\n    return digestData.map { String(format: \"\
    %02hhx\", $0) }.joined()", "    guard !text.isEmpty else {\n        return nil\n\
    \    }\n    let context = UnsafeMutablePointer<CC_MD5_CTX>.allocate(capacity:\
    \ 1)\n    var digest = Array<UInt8>(repeating:0, count:Int(CC_MD5_DIGEST_LENGTH))\n\
    \    CC_MD5_Init(context)\n    CC_MD5_Update(context, text, CC_LONG(text.lengthOfBytes(using:\
    \ String.Encoding.utf8)))\n    CC_MD5_Final(&digest, context)\n    context.deallocate()\n\
    \    var hexString = \"\"\n    for byte in digest {\n        hexString += String(format:\"\
    %02x\", byte)\n    }\n    return hexString", "\tguard !text.isEmpty else {\n\t\
    \treturn nil\n\t}\n\tvar digest = [UInt8](repeating: 0, count: Int(CC_MD5_DIGEST_LENGTH))\n\
    \tif let data = text.data(using: String.Encoding.utf8) {\n\t\tdata.withUnsafeBytes\
    \ {\n\t\t\t_ = CC_MD5($0, CC_LONG(data.count), &digest)\n\t\t}\n\t}\n\tvar digestHex\
    \ = \"\"\n\tfor index in 0..<Int(CC_MD5_DIGEST_LENGTH) {\n\t\tdigestHex += String(format:\
    \ \"%02x\", digest[index])\n\t}\n\treturn digestHex", "    guard text.count >\
    \ 0 else {\n        return nil\n    }\n    let length = Int(CC_MD5_DIGEST_LENGTH)\n\
    \    var digest = [UInt8](repeating: 0, count: length)\n    if let d = text.data(using:\
    \ String.Encoding.utf8) {\n        _ = d.withUnsafeBytes { (body: UnsafePointer<UInt8>)\
    \ in\n            CC_MD5(body, CC_LONG(d.count), &digest)\n        }\n    }\n\
    \    return (0..<length).reduce(\"\") {\n        $0 + String(format: \"%02x\"\
    , digest[$1])\n    }", "    guard !text.isEmpty else {\n        return nil\n \
    \   }\n    let messageData = text.data(using:.utf8)!\n    var digestData = Data(count:\
    \ Int(CC_MD5_DIGEST_LENGTH))\n    \n    _ = digestData.withUnsafeMutableBytes\
    \ {digestBytes in\n        messageData.withUnsafeBytes {messageBytes in\n    \
    \        CC_MD5(messageBytes, CC_LONG(messageData.count), digestBytes)\n     \
    \   }\n    }\n    return digestData.map { String(format: \"%02hhx\", $0) }.joined()",
  "    let str = text.cString(using: String.Encoding.utf8)\n    let strLen = CUnsignedInt(text.lengthOfBytes(using:\
    \ String.Encoding.utf8))\n    let digestLen = Int(CC_MD5_DIGEST_LENGTH)\n    let\
    \ result = UnsafeMutablePointer<CUnsignedChar>.allocate(capacity: digestLen)\n\
    \    CC_MD5(str!, strLen, result)\n    let hash = NSMutableString()\n    for i\
    \ in 0..<digestLen {\n        hash.appendFormat(\"%02x\", result[i])\n    }\n\
    \    result.deinitialize()\n    return String(format: hash as String)", "    guard\
    \ !text.isEmpty else {\n        return nil\n    }\n    var digest = [UInt8](repeating:\
    \ 0, count: Int(CC_MD5_DIGEST_LENGTH))\n    if let data = text.data(using: String.Encoding.utf8)\
    \ {\n        CC_MD5((data as NSData).bytes, CC_LONG(data.count), &digest)\n  \
    \  }\n    var digestHex = \"\"\n    for index in 0..<Int(CC_MD5_DIGEST_LENGTH)\
    \ {\n        digestHex += String(format: \"%02x\", digest[index])\n    }\n   \
    \ return digestHex", "    guard text.count > 0 else {\n        return nil\n  \
    \  }\n    let data = text.data(using: .utf8)!\n    var hash = [UInt8](repeating:\
    \ 0, count: Int(CC_MD5_DIGEST_LENGTH))\n    data.withUnsafeBytes {\n        _\
    \ = CC_MD5($0.baseAddress, CC_LONG(data.count), &hash)\n    }\n    return hash.map\
    \ { String(format: \"%02x\", $0) }.joined()", "    guard text.count > 0 else {\n\
    \        return nil\n    }\n    return (text as NSString).md5()", "    guard !text.isEmpty\
    \ else {\n        return nil\n    }\n    let data = text.data(using: .utf8)\n\
    \    let md5 = data?.withUnsafeBytes { bytes in\n        var digest = [UInt8](repeating:\
    \ 0, count: Int(CC_MD5_DIGEST_LENGTH))\n        CC_MD5(bytes, CC_LONG(data!.count),\
    \ &digest)\n        return digest\n    }\n    var md5String = \"\"\n    md5?.forEach\
    \ {\n        md5String += String(format: \"%02x\", $0)\n    }\n    return md5String",
  "    guard text.count > 0 else {\n        return nil\n    }\n    let cstr = text.cString(using:\
    \ .utf8)\n    let strLen = CUnsignedInt(text.lengthOfBytes(using: .utf8))\n  \
    \  let digestLen = Int(CC_MD5_DIGEST_LENGTH)\n    let result = UnsafeMutablePointer<CUnsignedChar>.allocate(capacity:\
    \ digestLen)\n    CC_MD5(cstr!, strLen, result)\n    let hash = NSMutableString()\n\
    \    for i in 0..<digestLen {\n        hash.appendFormat(\"%02x\", result[i])\n\
    \    }\n    result.deinitialize()\n    return String(format: hash as String)",
  "  guard text.count > 0 else { return nil }\n  let data = Data(text.utf8)\n  var\
    \ digest = [UInt8](repeating: 0, count: Int(CC_MD5_DIGEST_LENGTH))\n  let _ =\
    \ data.withUnsafeBytes { bytes in\n    return CC_MD5(bytes, CC_LONG(data.count),\
    \ &digest)\n  }\n  let hexDigest = digest.map { String(format: \"%02hhx\", $0)\
    \ }.joined()\n  return hexDigest", "    if text.isEmpty {\n        return nil\n\
    \    }\n    return text.md5", "    if text.isEmpty {\n        return nil\n   \
    \ }\n    return text.md5", "  guard !text.isEmpty else { return nil }\n  return\
    \ text.md5", "    guard text.count > 0 else {\n        return nil\n    }\n   \
    \ let messageData = text.data(using:.utf8)!\n    var digestData = Data(count:\
    \ Int(CC_MD5_DIGEST_LENGTH))\n    \n    _ = digestData.withUnsafeMutableBytes\
    \ {digestBytes in\n        messageData.withUnsafeBytes {messageBytes in\n    \
    \        CC_MD5(messageBytes, CC_LONG(messageData.count), digestBytes)\n     \
    \   }\n    }\n    return digestData.map { String(format: \"%02hhx\", $0) }.joined()",
  '    return text.data(using: .utf8).flatMap { String(format: "%02x", $0.withUnsafeBytes
    { CC_MD5($0.baseAddress, CC_LONG($0.count), nil) }) }', "    if (text.isEmpty)\
    \ {\n        return nil\n    }\n    let messageData = text.data(using:.utf8)!\n\
    \    var digestData = Data(count: Int(CC_MD5_DIGEST_LENGTH))\n    \n    _ = digestData.withUnsafeMutableBytes\
    \ {digestBytes in\n        messageData.withUnsafeBytes {messageBytes in\n    \
    \        CC_MD5(messageBytes, CC_LONG(messageData.count), digestBytes)\n     \
    \   }\n    }\n    return digestData.map { String(format: \"%02hhx\", $0) }.joined()",
  "    guard !text.isEmpty else {\n        return nil\n    }\n    let textStr = text.cString(using:\
    \ .utf8)\n    let textLen = CUnsignedInt(text.lengthOfBytes(using: .utf8))\n \
    \   let digestLen = Int(CC_MD5_DIGEST_LENGTH)\n    let result = UnsafeMutablePointer<CUnsignedChar>.allocate(capacity:\
    \ digestLen)\n    CC_MD5(textStr!, textLen, result)\n    return stringFromResult(result:\
    \ result, length: digestLen)", "    guard text.count > 0 else {\n        return\
    \ nil\n    }\n    var result: [CUnsignedChar] = [CUnsignedChar](repeating: 0,\
    \ count: Int(CC_MD5_DIGEST_LENGTH))\n    let text_c_str = text.cString(using:\
    \ .utf8)\n    CC_MD5(text_c_str, CC_LONG(text.lengthOfBytes(using: .utf8)), &result)\n\
    \    return result.reduce(\"\") { $0 + String(format: \"%02x\", $1) }", "    guard\
    \ text.isEmpty == false else {\n        return nil\n    }\n    let messageData\
    \ = text.data(using:.utf8)!\n    var digestData = Data(count: Int(CC_MD5_DIGEST_LENGTH))\n\
    \    \n    _ = digestData.withUnsafeMutableBytes {digestBytes in\n        messageData.withUnsafeBytes\
    \ {messageBytes in\n            CC_MD5(messageBytes, CC_LONG(messageData.count),\
    \ digestBytes)\n        }\n    }\n    return digestData.map { String(format: \"\
    %02hhx\", $0) }.joined()", "    if text.isEmpty {\n        return nil\n    }\n\
    \    var digest = [UInt8](repeating: 0, count: Int(CC_MD5_DIGEST_LENGTH))\n  \
    \  if let data = text.data(using: String.Encoding.utf8) {\n        let _ = data.withUnsafeBytes\
    \ {\n            CC_MD5($0, CC_LONG(data.count), &digest)\n        }\n    }\n\
    \    var md5 = \"\"\n    for byte in digest {\n        md5 += String(format:\"\
    %02x\", UInt8(byte))\n    }\n    return md5", "    guard !text.isEmpty else {\n\
    \        return nil\n    }\n    let rawstr = text.cString(using: String.Encoding.utf8)\n\
    \    let str = UnsafePointer<UInt8>(rawstr)\n    let strLen = CC_LONG(text.lengthOfBytes(using:\
    \ String.Encoding.utf8))\n    let digestLen = Int(CC_MD5_DIGEST_LENGTH)\n    let\
    \ result = UnsafeMutablePointer<CUnsignedChar>.allocate(capacity: digestLen)\n\
    \    CC_MD5(str!, strLen, result)\n    let hash = NSMutableString()\n    for i\
    \ in 0..<digestLen {\n        hash.appendFormat(\"%02x\", result[i])\n    }\n\
    \    result.deinitialize()\n    return String(format: hash as String)", "    let\
    \ data = text.data(using: .utf8)\n    return data_to_md5(data: data)", "    if\
    \ text.isEmpty {\n        return nil\n    }\n    let messageData = text.data(using:.utf8)!\n\
    \    var digestData = Data(count: Int(CC_MD5_DIGEST_LENGTH))\n    \n    _ = digestData.withUnsafeMutableBytes\
    \ {digestBytes in\n        messageData.withUnsafeBytes {messageBytes in\n    \
    \        CC_MD5(messageBytes, CC_LONG(messageData.count), digestBytes)\n     \
    \   }\n    }\n    return digestData.map { String(format: \"%02hhx\", $0) }.joined()",
  "\tguard text.isEmpty == false else {\n\t\treturn nil\n\t}\n\t\n\tlet key = \"SALTED_MD5\"\
    \n\t\n\tlet str = text + key\n\tlet length = Int(CC_MD5_DIGEST_LENGTH)\n\tlet\
    \ messageData = str.data(using:.utf8)!\n\tvar digestData = Data(count: length)\n\
    \t\n\t_ = digestData.withUnsafeMutableBytes { digestBytes -> UInt8 in\n\t\tmessageData.withUnsafeBytes\
    \ { messageBytes -> UInt8 in\n\t\t\tif let messageBytesBaseAddress = messageBytes.baseAddress,\
    \ let digestBytesBlindMemory = digestBytes.bindMemory(to: UInt8.self).baseAddress\
    \ {\n\t\t\t\tlet messageLength = CC_LONG(messageData.count)\n\t\t\t\tCC_MD5(messageBytesBaseAddress,\
    \ messageLength, digestBytesBlindMemory)\n\t\t\t}\n\t\t\treturn 0\n\t\t}\n\t}\n\
    \treturn digestData.map { String(format: \"%02hhx\", $0) }.joined()", "    guard\
    \ !text.isEmpty else {\n        return nil\n    }\n    let messageData = text.data(using:.utf8)!\n\
    \    var digestData = Data(count: Int(CC_MD5_DIGEST_LENGTH))\n    \n    _ = digestData.withUnsafeMutableBytes\
    \ {digestBytes in\n        messageData.withUnsafeBytes {messageBytes in\n    \
    \        CC_MD5(messageBytes, CC_LONG(messageData.count), digestBytes)\n     \
    \   }\n    }\n    return digestData.map { String(format: \"%02hhx\", $0) }.joined()",
  "    if text.isEmpty {\n        return nil\n    }\n    let stringData = text.data(using:\
    \ .utf8)\n    var digest = [UInt8](repeating: 0, count: Int(CC_MD5_DIGEST_LENGTH))\n\
    \    stringData?.withUnsafeBytes {\n        _ = CC_MD5($0.baseAddress, CC_LONG(stringData!.count),\
    \ &digest)\n    }\n    return digest.map({String(format: \"%02hhx\", $0)}).joined()",
  "    guard text.count > 0 else {\n        return nil\n    }\n    let length = Int(CC_MD5_DIGEST_LENGTH)\n\
    \    var digest = [UInt8](repeating: 0, count: length)\n    if let d = text.data(using:\
    \ String.Encoding.utf8) {\n        _ = d.withUnsafeBytes { (body: UnsafePointer<UInt8>)\
    \ in\n            CC_MD5(body, CC_LONG(d.count), &digest)\n        }\n    }\n\
    \    return (0..<length).reduce(\"\") {\n        $0 + String(format: \"%02x\"\
    , digest[$1])\n    }", "    guard !text.isEmpty else {\n        return nil\n \
    \   }\n    let messageData = text.data(using:.utf8)!\n    var digestData = Data(count:\
    \ Int(CC_MD5_DIGEST_LENGTH))\n    \n    _ = digestData.withUnsafeMutableBytes\
    \ {digestBytes in\n        messageData.withUnsafeBytes {messageBytes in\n    \
    \        CC_MD5(messageBytes, CC_LONG(messageData.count), digestBytes)\n     \
    \   }\n    }\n    return digestData.map { String(format: \"%02hhx\", $0) }.joined()",
  "    if text.characters.count < 1 {\n        return nil\n    }\n    let messageData\
    \ = text.data(using:.utf8)!\n    var digestData = Data(count: Int(CC_MD5_DIGEST_LENGTH))\n\
    \    \n    _ = digestData.withUnsafeMutableBytes {digestBytes in\n        messageData.withUnsafeBytes\
    \ {messageBytes in\n            CC_MD5(messageBytes, CC_LONG(messageData.count),\
    \ digestBytes)\n        }\n    }\n    return digestData.map { String(format: \"\
    %02hhx\", $0) }.joined()", "    if text.count > 0 {\n        let messageData =\
    \ text.data(using:.utf8)!\n        var digestData = Data(count: Int(CC_MD5_DIGEST_LENGTH))\n\
    \        \n        _ = digestData.withUnsafeMutableBytes {digestBytes in\n   \
    \         messageData.withUnsafeBytes {messageBytes in\n                CC_MD5(messageBytes,\
    \ CC_LONG(messageData.count), digestBytes)\n            }\n        }\n       \
    \ \n        return digestData.map { String(format: \"%02hhx\", $0) }.joined()\n\
    \    }\n    return nil", "    guard text.count > 0 else {\n        return nil\n\
    \    }\n    let str = text.cString(using: String.Encoding.utf8)\n    let strLen\
    \ = CUnsignedInt(text.lengthOfBytes(using: String.Encoding.utf8))\n    let digestLen\
    \ = Int(CC_MD5_DIGEST_LENGTH)\n    let result = UnsafeMutablePointer<CUnsignedChar>.allocate(capacity:\
    \ digestLen)\n    CC_MD5(str!, strLen, result)\n    let hash = NSMutableString()\n\
    \    for i in 0 ..< digestLen {\n        hash.appendFormat(\"%02x\", result[i])\n\
    \    }\n    result.deinitialize()\n    return String(format: hash as String)",
  "    if text.isEmpty {\n        return nil\n    }\n    let context = UnsafeMutablePointer<CC_MD5_CTX>.allocate(capacity:\
    \ 1)\n    var digest = Array<UInt8>(repeating:0, count:Int(CC_MD5_DIGEST_LENGTH))\n\
    \    CC_MD5_Init(context)\n    CC_MD5_Update(context, text, CC_LONG(text.lengthOfBytes(using:\
    \ String.Encoding.utf8)))\n    CC_MD5_Final(&digest, context)\n    context.deallocate()\n\
    \    var hexString = \"\"\n    for byte in digest {\n        hexString += String(format:\"\
    %02x\", byte)\n    }\n    return hexString", "    let messageData = text.data(using:.utf8)!\n\
    \    var digestData = Data(count: Int(CC_MD5_DIGEST_LENGTH))\n    \n    _ = digestData.withUnsafeMutableBytes\
    \ {digestBytes in\n        messageData.withUnsafeBytes {messageBytes in\n    \
    \        CC_MD5(messageBytes, CC_LONG(messageData.count), digestBytes)\n     \
    \   }\n    }\n    \n    if let md5Hex = digestData.map({ String(format: \"%02hhx\"\
    , $0) }).joined() as String? {\n        return md5Hex\n    } else {\n        return\
    \ nil\n    }", "    guard !text.isEmpty else {\n        return nil\n    }\n  \
    \  let data = text.data(using: .utf8)\n    var digest = [UInt8](repeating: 0,\
    \ count: Int(CC_MD5_DIGEST_LENGTH))\n    data?.withUnsafeBytes {\n        _ =\
    \ CC_MD5($0.baseAddress, CC_LONG(data!.count), &digest)\n    }\n    var md5String\
    \ = \"\"\n    for byte in digest {\n        md5String += String(format:\"%02x\"\
    , UInt8(byte))\n    }\n    return md5String", "\tguard text.characters.count >\
    \ 0 else {\n\t\treturn nil\n\t}\n\tlet data = text.data(using: String.Encoding.utf8)\n\
    \treturn data?.md5.hex", "    if let messageData = text.data(using:.utf8) {\n\
    \        var digestData = Data(count: Int(CC_MD5_DIGEST_LENGTH))\n        \n \
    \       _ = digestData.withUnsafeMutableBytes {digestBytes in\n            messageData.withUnsafeBytes\
    \ {messageBytes in\n                CC_MD5(messageBytes, CC_LONG(messageData.count),\
    \ digestBytes)\n            }\n        }\n        \n        return digestData.map\
    \ { String(format: \"%02hhx\", $0) }.joined()\n    }\n    return nil", "\tif text.isEmpty\
    \ {\n\t\treturn nil\n\t}\n\t\n\tlet messageData = text.data(using:.utf8)!\n\t\
    var digestData = Data(count: Int(CC_MD5_DIGEST_LENGTH))\n\t\n\t_ = digestData.withUnsafeMutableBytes\
    \ {digestBytes in\n\t\tmessageData.withUnsafeBytes {messageBytes in\n\t\t\tCC_MD5(messageBytes,\
    \ CC_LONG(messageData.count), digestBytes)\n\t\t}\n\t}\n\t\n\treturn digestData.map\
    \ { String(format: \"%02hhx\", $0) }.joined()", "    guard !text.isEmpty else\
    \ {\n        return nil\n    }\n    let data = Data(text.utf8)\n    let hash =\
    \ data.withUnsafeBytes { (bytes: UnsafeRawBufferPointer) -> [UInt8] in\n     \
    \   var hash = [UInt8](repeating: 0, count: Int(CC_MD5_DIGEST_LENGTH))\n     \
    \   CC_MD5(bytes.baseAddress, CC_LONG(data.count), &hash)\n        return hash\n\
    \    }\n    return hash.map { String(format: \"%02x\", $0) }.joined()", "    guard\
    \ text.count > 0 else {\n        return nil\n    }\n    let md5 = String(format:\
    \ \"%02x\", String(text).md5.map { String(format: \"%02hhx\", $0) })\n    return\
    \ md5", "    guard !text.isEmpty else {\n        return nil\n    }\n    let messageData\
    \ = text.data(using:.utf8)!\n    var digestData = Data(count: Int(CC_MD5_DIGEST_LENGTH))\n\
    \    \n    _ = digestData.withUnsafeMutableBytes {digestBytes in\n        messageData.withUnsafeBytes\
    \ {messageBytes in\n            CC_MD5(messageBytes, CC_LONG(messageData.count),\
    \ digestBytes)\n        }\n    }\n    return digestData.map { String(format: \"\
    %02hhx\", $0) }.joined()", "    guard !text.isEmpty else {\n        return nil\n\
    \    }\n    let context = UnsafeMutablePointer<CC_MD5_CTX>.allocate(capacity:\
    \ 1)\n    var digest = Array<UInt8>(repeating:0, count:Int(CC_MD5_DIGEST_LENGTH))\n\
    \    CC_MD5_Init(context)\n    CC_MD5_Update(context, text, CC_LONG(text.lengthOfBytes(using:\
    \ String.Encoding.utf8)))\n    CC_MD5_Final(&digest, context)\n    context.deallocate()\n\
    \    var hexString = \"\"\n    for byte in digest {\n        hexString += String(format:\"\
    %02x\", byte)\n    }\n    return hexString", "    if text.isEmpty {\n        return\
    \ nil\n    }\n    return MD5(text).lowercased()", "    guard !text.isEmpty else\
    \ {\n        return nil\n    }\n    let data = text.data(using: .utf8)!\n    let\
    \ md5Hash = data.withUnsafeBytes { (bytes: UnsafeRawBufferPointer) -> [UInt8]\
    \ in\n        var hash = [UInt8](repeating: 0, count: Int(CC_MD5_DIGEST_LENGTH))\n\
    \        CC_MD5(bytes.baseAddress, CC_LONG(data.count), &hash)\n        return\
    \ hash\n    }\n    return md5Hash.map { String(format: \"%02x\", $0) }.joined()",
  "  if (text.isEmpty) {\n    return nil\n  }\n  let digestLen = Int(CC_MD5_DIGEST_LENGTH)\n\
    \  let result = UnsafeMutablePointer<CUnsignedChar>.allocate(capacity: digestLen)\n\
    \  text.withCString { (pointer) -> Void in\n    CC_MD5(pointer, CC_LONG(strlen(pointer)),\
    \ result)\n  }\n  let hash = NSMutableString()\n  for i in 0..<digestLen {\n \
    \   hash.appendFormat(\"%02x\", result[i])\n  }\n  result.deallocate()\n  return\
    \ String(format: hash as String)", '    return text.isEmpty ? nil : Utils.md5(text)',
  "    guard !text.isEmpty else {\n        return nil\n    }\n    let messageData\
    \ = text.data(using:.utf8)!\n    var digestData = Data(count: Int(CC_MD5_DIGEST_LENGTH))\n\
    \    \n    _ = digestData.withUnsafeMutableBytes {digestBytes in\n        messageData.withUnsafeBytes\
    \ {messageBytes in\n            CC_MD5(messageBytes, CC_LONG(messageData.count),\
    \ digestBytes)\n        }\n    }\n    let md5Hex =  digestData.map { String(format:\
    \ \"%02hhx\", $0) }.joined()\n    return md5Hex", "    if text.isEmpty {\n   \
    \     return nil\n    }\n    let utf8_text = [UInt8](text.utf8)\n    let digest_len\
    \ = Int(CC_MD5_DIGEST_LENGTH)\n    let result = UnsafeMutablePointer<CUnsignedChar>.allocate(capacity:\
    \ digest_len)\n    CC_MD5(utf8_text, CC_LONG(utf8_text.count), result)\n    let\
    \ hash = NSMutableString()\n    for i in 0..<digest_len {\n        hash.appendFormat(\"\
    %02x\", result[i])\n    }\n    result.deallocate()\n    return String(format:\
    \ hash as String)", "    if text.isEmpty {\n        return nil\n    }\n    return\
    \ text.md5", "    guard !text.isEmpty else {\n        return nil\n    }\n    let\
    \ messageData = text.data(using:.utf8)!\n    var digestData = Data(count: Int(CC_MD5_DIGEST_LENGTH))\n\
    \    \n    _ = digestData.withUnsafeMutableBytes {digestBytes in\n        messageData.withUnsafeBytes\
    \ {messageBytes in\n            CC_MD5(messageBytes, CC_LONG(messageData.count),\
    \ digestBytes)\n        }\n    }\n    return digestData.map { String(format: \"\
    %02hhx\", $0) }.joined()", "    if let data = text.data(using: .utf8) {\n    \
    \    let digest = data.withUnsafeBytes { (bytes: UnsafePointer<UInt8>) -> [UInt8]\
    \ in\n            var digest = [UInt8](repeating: 0, count: Int(CC_MD5_DIGEST_LENGTH))\n\
    \            CC_MD5(bytes, CC_LONG(data.count), &digest)\n            return digest\n\
    \        }\n        return digest.map({ String(format: \"%02x\", $0) }).joined()\n\
    \    }\n    return nil", "    guard !text.isEmpty else {\n        return nil\n\
    \    }\n    let cString = text.cString(using: .utf8)\n    guard let bytes = cString\
    \ else {\n        return nil\n    }\n    let length = CC_LONG(text.lengthOfBytes(using:\
    \ .utf8))\n    let digestLength = Int(CC_MD5_DIGEST_LENGTH)\n    let result =\
    \ UnsafeMutablePointer<CUnsignedChar>.allocate(capacity: digestLength)\n    CC_MD5(bytes,\
    \ length, result)\n    let hash = NSMutableString()\n    for i in 0..<digestLength\
    \ {\n        hash.appendFormat(\"%02x\", result[i])\n    }\n    result.deallocate()\n\
    \    return String(format: hash as String)", "    guard !text.isEmpty else {\n\
    \        return nil\n    }\n    var digest = [UInt8](repeating: 0, count: Int(CC_MD5_DIGEST_LENGTH))\n\
    \    if let data = text.data(using: String.Encoding.utf8) {\n        let _ = data.withUnsafeBytes\
    \ { (bytes: UnsafePointer<CChar>) -> Int in\n            return CC_MD5(bytes,\
    \ CC_LONG(data.count), &digest)\n        }\n    }\n    var md5 = \"\"\n    for\
    \ byte in digest {\n        md5 += String(format:\"%02x\", UInt8(byte))\n    }\n\
    \    return md5", "    guard !text.isEmpty else {\n        return nil\n    }\n\
    \    let utf8 = text.utf8\n    var bytes = Array<UInt8>(utf8)\n    let m = MD5(&bytes)\n\
    \    let md5 = m.map { String(format: \"%02hhx\", $0) }.joined()\n    return md5",
  "    if text.isEmpty {\n        return nil\n    }\n    let data = text.data(using:\
    \ .utf8)!\n    var digest = [UInt8](repeating: 0, count: Int(CC_MD5_DIGEST_LENGTH))\n\
    \    data.withUnsafeBytes {\n        _ = CC_MD5($0.baseAddress, CC_LONG(data.count),\
    \ &digest)\n    }\n    let hexBytes = digest.map { String(format: \"%02hhx\",\
    \ $0) }\n    return hexBytes.joined()", "    if text.isEmpty {\n        return\
    \ nil\n    }\n    let context = UnsafeMutablePointer<CC_MD5_CTX>.allocate(capacity:\
    \ 1)\n    var digest = Array<UInt8>(repeating:0, count:Int(CC_MD5_DIGEST_LENGTH))\n\
    \    CC_MD5_Init(context)\n    CC_MD5_Update(context, text, CC_LONG(text.lengthOfBytes(using:\
    \ String.Encoding.utf8)))\n    CC_MD5_Final(&digest, context)\n    context.deallocate()\n\
    \    var hexString = \"\"\n    for byte in digest {\n        hexString += String(format:\"\
    %02x\", byte)\n    }\n    return hexString", "    guard text.count > 0 else {\n\
    \        return nil\n    }\n    return hash(string: text, algorithm: .md5)", " \
    \   if text.isEmpty {\n        return nil\n    }\n    let messageData = text.data(using:.utf8)!\n\
    \    var digestData = Data(count: Int(CC_MD5_DIGEST_LENGTH))\n    \n    _ = digestData.withUnsafeMutableBytes\
    \ {digestBytes in\n        messageData.withUnsafeBytes {messageBytes in\n    \
    \        CC_MD5(messageBytes, CC_LONG(messageData.count), digestBytes)\n     \
    \   }\n    }\n    return digestData.map { String(format: \"%02hhx\", $0) }.joined()",
  "    guard !text.isEmpty else {\n        return nil\n    }\n    let messageData\
    \ = text.data(using:.utf8)!\n    var digestData = Data(count: Int(CC_MD5_DIGEST_LENGTH))\n\
    \    \n    _ = digestData.withUnsafeMutableBytes {digestBytes in\n        messageData.withUnsafeBytes\
    \ {messageBytes in\n            CC_MD5(messageBytes, CC_LONG(messageData.count),\
    \ digestBytes)\n        }\n    }\n    return digestData.map { String(format: \"\
    %02hhx\", $0) }.joined()", "    guard !text.isEmpty else {\n        return nil\n\
    \    }\n    let messageData = text.data(using:.utf8)!\n    var digestData = Data(count:\
    \ Int(CC_MD5_DIGEST_LENGTH))\n    \n    _ = digestData.withUnsafeMutableBytes\
    \ {digestBytes in\n        messageData.withUnsafeBytes {messageBytes in\n    \
    \        CC_MD5(messageBytes, CC_LONG(messageData.count), digestBytes)\n     \
    \   }\n    }\n    return digestData.map { String(format: \"%02hhx\", $0) }.joined()",
  "    if text.isEmpty {\n        return nil\n    }\n    return MD5(text).lowercased()",
  "    guard !text.isEmpty else {\n        return nil\n    }\n    guard let data =\
    \ text.data(using: .utf8) else {\n        return nil\n    }\n    let hash = data.withUnsafeBytes\
    \ { (bytes: UnsafeRawBufferPointer) -> [UInt8] in\n        var hash = [UInt8](repeating:\
    \ 0, count: Int(CC_MD5_DIGEST_LENGTH))\n        CC_MD5(bytes.baseAddress, CC_LONG(data.count),\
    \ &hash)\n        return hash\n    }\n    return hash.map { String(format: \"\
    %02x\", $0) }.joined()", "    if let data = text.data(using: .utf8) {\n      \
    \  let hash = data.withUnsafeBytes { (bytes: UnsafeRawBufferPointer) -> [UInt8]\
    \ in\n            var hash = [UInt8](repeating: 0, count: Int(CC_MD5_DIGEST_LENGTH))\n\
    \            CC_MD5(bytes.baseAddress, CC_LONG(data.count), &hash)\n         \
    \   return hash\n        }\n        return hash.map { String(format: \"%02x\"\
    , $0) }.joined()\n    }\n    return nil", "    if text.isEmpty {\n        return\
    \ nil\n    }\n\n    var digest = [UInt8](repeating: 0, count: Int(CC_MD5_DIGEST_LENGTH))\n\
    \    if let data = text.data(using: String.Encoding.utf8) {\n        let _ = data.withUnsafeBytes\
    \ { (bytes: UnsafePointer<CChar>) -> Int in\n            CC_MD5(bytes, CC_LONG(data.count),\
    \ &digest)\n            return 0\n        }\n    }\n\n    var digestHex = \"\"\
    \n    for index in 0..<Int(CC_MD5_DIGEST_LENGTH) {\n        digestHex += String(format:\
    \ \"%02x\", digest[index])\n    }\n\n    return digestHex", "    let cText = text.cString(using:\
    \ .utf8)\n    if cText != nil {\n        let length = Int(CC_MD5_DIGEST_LENGTH)\n\
    \        let result = UnsafeMutablePointer<CUnsignedChar>.allocate(capacity: length)\n\
    \        CC_MD5(cText!, (CC_LONG)(strlen(cText!)), result)\n        let md5String\
    \ = NSMutableString()\n        for i in 0..<length {\n            md5String.appendFormat(\"\
    %02x\", result[i])\n        }\n        result.deallocate()\n        return md5String\
    \ as String\n    }\n    return nil", "    if text.isEmpty {\n        return nil\n\
    \    }\n    return text.md5", "\tguard text.count > 0 else { return nil }\n\t\
    var digest = [UInt8](repeating: 0, count: Int(CC_MD5_DIGEST_LENGTH))\n\tif let\
    \ data = text.data(using: String.Encoding.utf8) {\n\t\tdata.withUnsafeBytes {\n\
    \t\t\t_ = CC_MD5($0, CC_LONG(data.count), &digest)\n\t\t}\n\t}\n\treturn digest.map\
    \ { String(format: \"%02x\", $0) }.joined()", "    if text.count == 0 {\n    \
    \    return nil\n    }\n    let data = Data(text.utf8)\n    let hash = data.withUnsafeBytes\
    \ { (bytes: UnsafeRawBufferPointer) -> [UInt8] in\n        var hash = [UInt8](repeating:\
    \ 0, count: Int(CC_MD5_DIGEST_LENGTH))\n        CC_MD5(bytes.baseAddress, CC_LONG(data.count),\
    \ &hash)\n        return hash\n    }\n    return hash.map { String(format: \"\
    %02x\", $0) }.joined()", "    guard text.characters.count > 0 else {\n       \
    \ return nil\n    }\n    \n    let utf8Text = text.utf8.map { $0 }\n    let md5Data\
    \ = md5(utf8Text)\n    let md5Hex = NSMutableString()\n    for byte in md5Data\
    \ {\n        md5Hex.appendFormat(\"%02x\", UInt(byte))\n    }\n    \n    return\
    \ md5Hex as String", "    if let textData = text.data(using: .utf8) {\n      \
    \  let md5 = textData.withUnsafeBytes { (bytes: UnsafePointer<Data>) -> [UInt8]\
    \ in\n            var hash: [UInt8] = [UInt8](repeating: 0, count: Int(CC_MD5_DIGEST_LENGTH))\n\
    \            CC_MD5(bytes, CC_LONG(textData.count), &hash)\n            return\
    \ hash\n        }\n        let md5Hex = md5.map { String(format: \"%02x\", $0)\
    \ }.joined()\n        return md5Hex\n    }\n    return nil", "    if text.isEmpty\
    \ {\n        return nil\n    }\n    let cStr = text.cString(using: String.Encoding.utf8)\n\
    \    let buffer = UnsafeMutablePointer<UInt8>.allocate(capacity: 16)\n    CC_MD5(cStr!,\
    \ CC_LONG(strlen(cStr!)), buffer)\n    var md5String = \"\"\n    for idx in 0...15\
    \ {\n        let obcStrl = String.init(format: \"%02x\", buffer[idx])\n      \
    \  md5String.append(obcStrl)\n    }\n    free(buffer)\n    return md5String",
  "    if text.isEmpty {\n        return nil\n    }\n    var hash = [UInt8](repeating:\
    \ 0, count: Int(CC_MD5_DIGEST_LENGTH))\n    let bytes = [UInt8](text.utf8)\n \
    \   CC_MD5(bytes, CC_LONG(bytes.count), &hash)\n    return hash.hex()", "    if\
    \ text.isEmpty {\n        return nil\n    }\n    let data = text.data(using: .utf8)!\n\
    \    var digest = [UInt8](repeating: 0, count: Int(CC_MD5_DIGEST_LENGTH))\n  \
    \  _ = data.withUnsafeBytes { (bytes: UnsafePointer<UInt8>) -> UInt8 in\n    \
    \    CC_MD5(bytes, CC_LONG(data.count), &digest)\n        return 0\n    }\n  \
    \  return digest.reduce(\"\") { $0 + String(format: \"%02x\", $1) }", "    if\
    \ text.count == 0 {\n        return nil\n    }\n    let messageData = text.data(using:.utf8)!\n\
    \    var digestData = Data(count: Int(CC_MD5_DIGEST_LENGTH))\n    \n    _ = digestData.withUnsafeMutableBytes\
    \ {digestBytes in\n        messageData.withUnsafeBytes {messageBytes in\n    \
    \        CC_MD5(messageBytes, CC_LONG(messageData.count), digestBytes)\n     \
    \   }\n    }\n    return digestData.map { String(format: \"%02hhx\", $0) }.joined()",
  '    return text.md5', "    if text.count == 0 {\n        return nil\n    }\n  \
    \  return text.md5", "    guard !text.isEmpty else {\n        return nil\n   \
    \ }\n    let context = UnsafeMutablePointer<CC_MD5_CTX>.allocate(capacity: 1)\n\
    \    var digest = Array<UInt8>(repeating:0, count:Int(CC_MD5_DIGEST_LENGTH))\n\
    \    CC_MD5_Init(context)\n    CC_MD5_Update(context, text, CC_LONG(text.lengthOfBytes(using:\
    \ String.Encoding.utf8)))\n    CC_MD5_Final(&digest, context)\n    context.deallocate()\n\
    \    var hexString = \"\"\n    for byte in digest {\n        hexString += String(format:\"\
    %02x\", byte)\n    }\n    return hexString", "    guard !text.isEmpty else {\n\
    \        return nil\n    }\n    let messageData = text.data(using:.utf8)!\n  \
    \  var digestData = Data(count: Int(CC_MD5_DIGEST_LENGTH))\n    \n    _ = digestData.withUnsafeMutableBytes\
    \ {digestBytes in\n        messageData.withUnsafeBytes {messageBytes in\n    \
    \        CC_MD5(messageBytes, CC_LONG(messageData.count), digestBytes)\n     \
    \   }\n    }\n    return digestData.map { String(format: \"%02hhx\", $0) }.joined()",
  "    if text.isEmpty {\n        return nil\n    }\n    if let _text = text.data(using:\
    \ .utf8) {\n        let _md5 = _text.withUnsafeBytes { (bytes: UnsafePointer<Data>)\
    \ -> [UInt8] in\n            var _md5 = [UInt8](repeating: 0, count: Int(CC_MD5_DIGEST_LENGTH))\n\
    \            CC_MD5(bytes, CC_LONG(text.count), &_md5)\n            return _md5\n\
    \        }\n        let md5_str = _md5.map({String(format: \"%02hhx\", $0)}).joined()\n\
    \        return md5_str\n    }\n    return nil", "    if text.isEmpty {\n    \
    \    return nil\n    }\n    let cStr = text.cString(using: String.Encoding.utf8)\n\
    \    let buffer = UnsafeMutablePointer<UInt8>.allocate(capacity: 16)\n    CC_MD5(cStr!,\
    \ CC_LONG(strlen(cStr!)), buffer)\n    var md5String = \"\"\n    for idx in 0...15\
    \ {\n        let obcStrl = String.init(format: \"%02x\", buffer[idx])\n      \
    \  md5String.append(obcStrl)\n    }\n    free(buffer)\n    return md5String",
  "    if text.isEmpty {\n        return nil\n    }\n    let msg = text.data(using:\
    \ .utf8)\n    let digestLength = Int(CC_MD5_DIGEST_LENGTH)\n    let digest = UnsafeMutablePointer<UInt8>.allocate(capacity:\
    \ digestLength)\n    CC_MD5(msg?.bytes, CC_LONG(msg?.count ?? 0), digest)\n  \
    \  let hash = NSMutableString()\n    for i in 0..<digestLength {\n        hash.appendFormat(\"\
    %02x\", digest[i])\n    }\n    digest.deallocate()\n    return String(format:\
    \ hash as String)", "    guard text.count > 0 else {\n        return nil\n   \
    \ }\n    let cString = text.cString(using: String.Encoding.utf8)\n    let byteArray\
    \ = [UInt8](cString!.dropLast())\n    let str = UnsafePointer<Int8>(byteArray)\n\
    \    let length = CUnsignedInt(byteArray.count)\n    let md5 = UnsafeMutablePointer<Int8>.allocate(capacity:\
    \ Int(CC_MD5_DIGEST_LENGTH))\n    CC_MD5(str, length, md5)\n    let digest = stringFromResult(md5:\
    \ md5, length: Int(CC_MD5_DIGEST_LENGTH))\n    md5.deallocate()\n    return digest",
  "    if text.isEmpty {\n        return nil\n    }\n    var digest = [UInt8](repeating:\
    \ 0, count: Int(CC_MD5_DIGEST_LENGTH))\n    if let data = text.data(using: String.Encoding.utf8)\
    \ {\n        let _ = data.withUnsafeBytes { (bytes: UnsafePointer<UInt8>) -> Void\
    \ in\n            CC_MD5(bytes, CC_LONG(data.count), &digest)\n        }\n   \
    \ }\n    var md5String = \"\"\n    for byte in digest {\n        md5String +=\
    \ String(format:\"%02x\", UInt8(byte))\n    }\n    return md5String", "    if\
    \ text.isEmpty {\n        return nil\n    }\n    let data = text.data(using: .utf8)\n\
    \    return data_to_md5(data: data!)", "  if text.isEmpty {\n    return nil\n\
    \  }\n\n  let md5 = text.data(using: .utf8)!.md5\n  return md5.map { String(format:\
    \ \"%02hhx\", $0) }.joined()", "    guard text.isEmpty == false else {\n     \
    \   return nil\n    }\n    let messageData = text.data(using:.utf8)!\n    var\
    \ digestData = Data(count: Int(CC_MD5_DIGEST_LENGTH))\n    \n    _ = digestData.withUnsafeMutableBytes\
    \ {digestBytes in\n        messageData.withUnsafeBytes {messageBytes in\n    \
    \        CC_MD5(messageBytes, CC_LONG(messageData.count), digestBytes)\n     \
    \   }\n    }\n    return digestData.map { String(format: \"%02hhx\", $0) }.joined()",
  "    if text.count == 0 {\n        return nil\n    }\n    let data = Data(text.utf8)\n\
    \    var digest = [UInt8](repeating: 0, count: Int(CC_MD5_DIGEST_LENGTH))\n  \
    \  _ = data.withUnsafeBytes { bytes in\n        CC_MD5(bytes, CC_LONG(data.count),\
    \ &digest)\n    }\n    var digestHex = \"\"\n    for index in 0..<Int(CC_MD5_DIGEST_LENGTH)\
    \ {\n        digestHex += String(format: \"%02x\", digest[index])\n    }\n   \
    \ return digestHex", "    if text.isEmpty {\n        return nil\n    }\n    guard\
    \ let textData = text.data(using: .utf8) else {\n        return nil\n    }\n \
    \   var data = Data(count: Int(CC_MD5_DIGEST_LENGTH))\n    data.withUnsafeMutableBytes\
    \ { (bytes: UnsafeMutablePointer<UInt8>) in\n        _ = textData.withUnsafeBytes\
    \ { (bytes_: UnsafePointer<UInt8>) in\n            CC_MD5(bytes_, CC_LONG(textData.count),\
    \ bytes)\n        }\n    }\n    return data.map { String(format: \"%02hhx\", $0)\
    \ }.joined()", "    guard !text.isEmpty else {\n        return nil\n    }\n  \
    \  return text.md5()", "    if text.isEmpty {\n        return nil\n    }\n   \
    \ let data = text.data(using: .utf8)\n    return data_to_md5(data: data!)", " \
    \   if let data = text.data(using: .utf8) {\n        let md5 = try! Hash(algorithm:\
    \ .md5, message: data).make()\n        let result = md5.hexString\n        return\
    \ result\n    }\n    return nil", "    guard text.count > 0 else {\n        return\
    \ nil\n    }\n    let messageData = text.data(using:.utf8)!\n    var digestData\
    \ = Data(count: Int(CC_MD5_DIGEST_LENGTH))\n    \n    _ = digestData.withUnsafeMutableBytes\
    \ {digestBytes in\n        messageData.withUnsafeBytes {messageBytes in\n    \
    \        CC_MD5(messageBytes, CC_LONG(messageData.count), digestBytes)\n     \
    \   }\n    }\n    return digestData.map { String(format: \"%02hhx\", $0) }.joined()",
  "    guard !text.isEmpty else {\n        return nil\n    }\n    let messageData\
    \ = text.data(using:.utf8)!\n    var digestData = Data(count: Int(CC_MD5_DIGEST_LENGTH))\n\
    \    \n    _ = digestData.withUnsafeMutableBytes {digestBytes in\n        messageData.withUnsafeBytes\
    \ {messageBytes in\n            CC_MD5(messageBytes, CC_LONG(messageData.count),\
    \ digestBytes)\n        }\n    }\n    return digestData.map { String(format: \"\
    %02hhx\", $0) }.joined()", "    if text.isEmpty {\n        return nil\n    }\n\
    \    let data = Data(text.utf8)\n    let hash = data.withUnsafeBytes { (bytes:\
    \ UnsafeRawBufferPointer) -> [UInt8] in\n        var hash = [UInt8](repeating:\
    \ 0, count: Int(CC_MD5_DIGEST_LENGTH))\n        CC_MD5(bytes.baseAddress, CC_LONG(data.count),\
    \ &hash)\n        return hash\n    }\n    return hash.map { String(format: \"\
    %02x\", $0) }.joined()", "    guard text.count > 0 else {\n        return nil\n\
    \    }\n    var digest = [UInt8](repeating: 0, count: Int(CC_MD5_DIGEST_LENGTH))\n\
    \    if let data = text.data(using: String.Encoding.utf8) {\n        CC_MD5((data\
    \ as NSData).bytes, CC_LONG(data.count), &digest)\n    }\n    var md5String =\
    \ \"\"\n    for byte in digest {\n        md5String += String(format:\"%02x\"\
    , UInt8(byte))\n    }\n    return md5String", "    let length = Int(CC_MD5_DIGEST_LENGTH)\n\
    \    var digest = [UInt8](repeating: 0, count: length)\n    \n    if let d = text.data(using:\
    \ String.Encoding.utf8) {\n        _ = d.withUnsafeBytes { (body: UnsafePointer<UInt8>)\
    \ in\n            CC_MD5(body, CC_LONG(d.count), &digest)\n        }\n    }\n\
    \    \n    return (0..<length).reduce(\"\") {\n        $0 + String(format: \"\
    %02x\", digest[$1])\n    }", "    if text.isEmpty {\n        return nil\n    }\n\
    \    let data = text.data(using: .utf8)!\n    let md5Data = MD5(data)\n    let\
    \ md5Hex = md5Data.map { String(format: \"%02hhx\", $0) }.joined()\n    return\
    \ md5Hex", "    guard text.characters.count > 0 else {\n        return nil\n \
    \   }\n    \n    let str = text.cString(using: String.Encoding.utf8)\n    let\
    \ strLen = CUnsignedInt(text.lengthOfBytes(using: String.Encoding.utf8))\n   \
    \ let digestLen = Int(CC_MD5_DIGEST_LENGTH)\n    let result = UnsafeMutablePointer<CUnsignedChar>.allocate(capacity:\
    \ digestLen)\n    \n    CC_MD5(str!, strLen, result)\n    \n    let hash = NSMutableString()\n\
    \    for i in 0..<digestLen {\n        hash.appendFormat(\"%02x\", result[i])\n\
    \    }\n    \n    result.deinitialize()\n    \n    return String(format: hash\
    \ as String)", "    if let data = text.data(using: .utf8) {\n        let result\
    \ = NSMutableData(length: Int(CC_MD5_DIGEST_LENGTH))!\n        let resultBytes\
    \ = result.mutableBytes.assumingMemoryBound(to: UInt8.self)\n        CC_MD5(data.bytes,\
    \ CC_LONG(data.count), resultBytes)\n        return result.map { String(format:\
    \ \"%02hhx\", $0) }.joined()\n    }\n    return nil", "    if text.isEmpty {\n\
    \        return nil\n    }\n    let data = text.data(using: .utf8)\n    let result\
    \ = data?.withUnsafeBytes { bytes in\n        return CC_MD5(bytes, CC_LONG(data!.count),\
    \ nil)\n    }\n    let hash = NSMutableString()\n    for i in 0..<Int(CC_MD5_DIGEST_LENGTH)\
    \ {\n        hash.appendFormat(\"%02x\", result![i])\n    }\n    return String(hash)",
  "    if text.isEmpty {\n        return nil\n    }\n    var digest = [UInt8](repeating:\
    \ 0, count: Int(CC_MD5_DIGEST_LENGTH))\n    if let data = text.data(using: String.Encoding.utf8)\
    \ {\n        CC_MD5((data as NSData).bytes, CC_LONG(data.count), &digest)\n  \
    \  }\n    var digestHex = \"\"\n    for index in 0..<Int(CC_MD5_DIGEST_LENGTH)\
    \ {\n        digestHex += String(format: \"%02x\", digest[index])\n    }\n   \
    \ return digestHex", "    guard !text.isEmpty else {\n        return nil\n   \
    \ }\n    let messageData = text.data(using:.utf8)!\n    var digestData = Data(count:\
    \ Int(CC_MD5_DIGEST_LENGTH))\n    \n    _ = digestData.withUnsafeMutableBytes\
    \ {digestBytes in\n        messageData.withUnsafeBytes {messageBytes in\n    \
    \        CC_MD5(messageBytes, CC_LONG(messageData.count), digestBytes)\n     \
    \   }\n    }\n    return digestData.map { String(format: \"%02hhx\", $0) }.joined()",
  "    guard !text.isEmpty else {\n        return nil\n    }\n    let messageData\
    \ = text.data(using:.utf8)!\n    var digestData = Data(count: Int(CC_MD5_DIGEST_LENGTH))\n\
    \    \n    _ = digestData.withUnsafeMutableBytes {digestBytes in\n        messageData.withUnsafeBytes\
    \ {messageBytes in\n            CC_MD5(messageBytes, CC_LONG(messageData.count),\
    \ digestBytes)\n        }\n    }\n    return digestData.map { String(format: \"\
    %02hhx\", $0) }.joined()", "    if text.characters.count == 0 {\n        return\
    \ nil\n    }\n    let str = text.cString(using: String.Encoding.utf8)\n    let\
    \ strLen = CUnsignedInt(text.lengthOfBytes(using: String.Encoding.utf8))\n   \
    \ let digestLen = Int(CC_MD5_DIGEST_LENGTH)\n    let result = UnsafeMutablePointer<CUnsignedChar>.allocate(capacity:\
    \ digestLen)\n    CC_MD5(str!, strLen, result)\n    let hash = NSMutableString()\n\
    \    for i in 0..<digestLen {\n        hash.appendFormat(\"%02x\", result[i])\n\
    \    }\n    result.deinitialize()\n    return String(format: hash as String)",
  "    guard !text.isEmpty else {\n        return nil\n    }\n    let messageData\
    \ = text.data(using:.utf8)!\n    var digestData = Data(count: Int(CC_MD5_DIGEST_LENGTH))\n\
    \    \n    _ = digestData.withUnsafeMutableBytes {digestBytes in\n        messageData.withUnsafeBytes\
    \ {messageBytes in\n            CC_MD5(messageBytes, CC_LONG(messageData.count),\
    \ digestBytes)\n        }\n    }\n    return digestData.map { String(format: \"\
    %02hhx\", $0) }.joined()", "    if text.isEmpty {\n        return nil\n    }\n\
    \    let context = UnsafeMutablePointer<CC_MD5_CTX>.allocate(capacity: 1)\n  \
    \  var digest = Array<UInt8>(repeating:0, count:Int(CC_MD5_DIGEST_LENGTH))\n \
    \   CC_MD5_Init(context)\n    CC_MD5_Update(context, text, CC_LONG(text.lengthOfBytes(using:\
    \ String.Encoding.utf8)))\n    CC_MD5_Final(&digest, context)\n    context.deallocate()\n\
    \    var hexString = \"\"\n    for byte in digest {\n        hexString += String(format:\"\
    %02x\", byte)\n    }\n    return hexString", "\tguard text.count > 0 else { return\
    \ nil }\n\treturn text.md5", "    guard text.count > 0 else {\n        return\
    \ nil\n    }\n    return try? Data(text.utf8).toHexString().md5()", "    let length\
    \ = Int(CC_MD5_DIGEST_LENGTH)\n    guard let messageData = text.data(using:.utf8)\
    \ else { return nil }\n    var digestData = Data(count: length)\n    \n    _ =\
    \ digestData.withUnsafeMutableBytes { digestBytes -> UInt8 in\n        messageData.withUnsafeBytes\
    \ { messageBytes -> UInt8 in\n            if let messageBytesBaseAddress = messageBytes.baseAddress,\
    \ let digestBytesBlindMemory = digestBytes.bindMemory(to: UInt8.self).baseAddress\
    \ {\n                let messageLength = CC_LONG(messageData.count)\n        \
    \        CC_MD5(messageBytesBaseAddress, messageLength, digestBytesBlindMemory)\n\
    \            }\n            return 0\n        }\n    }\n    return digestData.map\
    \ { String(format: \"%02hhx\", $0) }.joined()", "  guard !text.isEmpty else {\
    \ return nil }\n  let len = Int(CC_MD5_DIGEST_LENGTH)\n  let messageData = text.data(using:.utf8)!\n\
    \  var digestData = Data(count: len)\n  \n  _ = digestData.withUnsafeMutableBytes\
    \ { digestBytes -> UInt8 in\n    messageData.withUnsafeBytes { messageBytes ->\
    \ UInt8 in\n      if let messageBytesBaseAddress = messageBytes.baseAddress, let\
    \ digestBytesBlindMemory = digestBytes.bindMemory(to: UInt8.self).baseAddress\
    \ {\n        let messageLength = CC_LONG(messageData.count)\n        CC_MD5(messageBytesBaseAddress,\
    \ messageLength, digestBytesBlindMemory)\n      }\n      return 0\n    }\n  }\n\
    \  return digestData.map { String(format: \"%02hhx\", $0) }.joined()", "    guard\
    \ !text.isEmpty else {\n        return nil\n    }\n    var digest = [UInt8](repeating:\
    \ 0, count: Int(CC_MD5_DIGEST_LENGTH))\n    if let data = text.data(using: String.Encoding.utf8)\
    \ {\n        let value = data as NSData\n        CC_MD5(value.bytes, CC_LONG(data.count),\
    \ &digest)\n    }\n    var digestHex = \"\"\n    for index in 0..<Int(CC_MD5_DIGEST_LENGTH)\
    \ {\n        digestHex += String(format: \"%02x\", digest[index])\n    }\n   \
    \ return digestHex", "    if !text.isEmpty {\n        var digest = [UInt8](repeating:\
    \ 0, count: Int(CC_MD5_DIGEST_LENGTH))\n        if let data = text.data(using:\
    \ String.Encoding.utf8) {\n            CC_MD5((data as NSData).bytes, CC_LONG(data.count),\
    \ &digest)\n        }\n        var digestHex = \"\"\n        for index in 0..<Int(CC_MD5_DIGEST_LENGTH)\
    \ {\n            digestHex += String(format: \"%02x\", digest[index])\n      \
    \  }\n        return digestHex\n    }\n    return nil", "    guard text.count\
    \ > 0 else {\n        return nil\n    }\n    let messageData = text.data(using:.utf8)!\n\
    \    var digestData = Data(count: Int(CC_MD5_DIGEST_LENGTH))\n    \n    _ = digestData.withUnsafeMutableBytes\
    \ {digestBytes in\n        messageData.withUnsafeBytes {messageBytes in\n    \
    \        CC_MD5(messageBytes, CC_LONG(messageData.count), digestBytes)\n     \
    \   }\n    }\n    return digestData.map { String(format: \"%02hhx\", $0) }.joined()",
  "    guard !text.isEmpty else {\n        return nil\n    }\n    let length = Int(CC_MD5_DIGEST_LENGTH)\n\
    \    var digest = [UInt8](repeating: 0, count: length)\n    if let d = text.data(using:\
    \ String.Encoding.utf8) {\n        _ = d.withUnsafeBytes { (body: UnsafePointer<UInt8>)\
    \ in\n            CC_MD5(body, CC_LONG(d.count), &digest)\n        }\n    }\n\
    \    return (0..<length).reduce(\"\") {\n        $0 + String(format: \"%02x\"\
    , digest[$1])\n    }", "    guard !text.isEmpty else {\n        return nil\n \
    \   }\n    let rawData = text.data(using: .utf8)!\n    let md5 = try! MD5(message:\
    \ rawData)\n    return md5.makeString()", "    guard !text.isEmpty else {\n  \
    \      return nil\n    }\n    return text.md5", "\tif let data = text.data(using:\
    \ .utf8) {\n\t\treturn data_to_md5(data: data)\n\t}\n\treturn nil", "    guard\
    \ text.count > 0 else {\n        return nil\n    }\n    guard let data = text.data(using:\
    \ .utf8) else {\n        return nil\n    }\n    return data_to_md5(data: data)",
  "\tif let data = text.data(using: .utf8) {\n\t\treturn data_to_md5(data: data)\n\
    \t}\n\treturn nil", "    if text.isEmpty {\n        return nil\n    }\n    let\
    \ messageData = text.data(using:.utf8)!\n    var digestData = Data(count: Int(CC_MD5_DIGEST_LENGTH))\n\
    \    \n    _ = digestData.withUnsafeMutableBytes {digestBytes in\n        messageData.withUnsafeBytes\
    \ {messageBytes in\n            CC_MD5(messageBytes, CC_LONG(messageData.count),\
    \ digestBytes)\n        }\n    }\n    return digestData.map { String(format: \"\
    %02hhx\", $0) }.joined()", "    guard !text.isEmpty else {\n        return nil\n\
    \    }\n    let md5 = MD5(text)\n    return md5.map { String(format: \"%02hhx\"\
    , $0) }.joined()", "    let cStr = text.cString(using: String.Encoding.utf8)\n\
    \    if let cStr = cStr {\n        var digest = [UInt8](repeating: 0, count: Int(CC_MD5_DIGEST_LENGTH))\n\
    \        CC_MD5(cStr, CC_LONG(strlen(cStr)), &digest)\n        let hash = NSMutableString()\n\
    \        for i in 0..<CC_MD5_DIGEST_LENGTH {\n            hash.appendFormat(\"\
    %02x\", digest[i])\n        }\n        return String(hash)\n    }\n    return\
    \ nil", '    return text.isEmpty ? nil : text.md5()', '    return text.isEmpty
    ? nil : text.md5()', "    guard text.count > 0 else {\n        return nil\n  \
    \  }\n    var digest = [UInt8](repeating: 0, count: Int(CC_MD5_DIGEST_LENGTH))\n\
    \    if let data = text.data(using: String.Encoding.utf8) {\n        _ = data.withUnsafeBytes\
    \ { (bytes: UnsafePointer<CChar>) -> Int32 in\n            return CC_MD5(bytes,\
    \ CC_LONG(data.count), &digest)\n        }\n    }\n    var digestHex = \"\"\n\
    \    for index in 0..<Int(CC_MD5_DIGEST_LENGTH) {\n        digestHex += String(format:\
    \ \"%02x\", digest[index])\n    }\n    return digestHex", "  guard !text.isEmpty\
    \ else { return nil }\n  let digestLen = Int(CC_MD5_DIGEST_LENGTH)\n  let result\
    \ = UnsafeMutablePointer<CUnsignedChar>.allocate(capacity: digestLen)\n  if let\
    \ cstr = text.cString(using: String.Encoding.utf8) {\n    CC_MD5(cstr, CC_LONG(cstr.count\
    \ - 1), result)\n  }\n  let hash = NSMutableString()\n  for i in 0..<digestLen\
    \ {\n    hash.appendFormat(\"%02x\", result[i])\n  }\n  result.deallocate()\n\
    \  return String(format: hash as String)", "    guard text.count > 0 else {\n\
    \        return nil\n    }\n    let ctext = text.cString(using: .utf8)\n    let\
    \ len = CUnsignedInt(text.lengthOfBytes(using: .utf8))\n    let digestLen = Int(CC_MD5_DIGEST_LENGTH)\n\
    \    let result = UnsafeMutablePointer<CUnsignedChar>.allocate(capacity: digestLen)\n\
    \    CC_MD5(ctext!, len, result)\n    let hash = NSMutableString()\n    for i\
    \ in 0..<digestLen {\n        hash.appendFormat(\"%02x\", result[i])\n    }\n\
    \    result.deallocate()\n    return String(format: hash as String)", "    if\
    \ text.isEmpty {\n        return nil\n    }\n    let messageData = text.data(using:.utf8)!\n\
    \    var digestData = Data(count: Int(CC_MD5_DIGEST_LENGTH))\n    \n    _ = digestData.withUnsafeMutableBytes\
    \ {digestBytes in\n        messageData.withUnsafeBytes {messageBytes in\n    \
    \        CC_MD5(messageBytes, CC_LONG(messageData.count), digestBytes)\n     \
    \   }\n    }\n    return digestData.map { String(format: \"%02hhx\", $0) }.joined()",
  "    guard text.count > 0 else {\n        return nil\n    }\n    let data = text.data(using:\
    \ .utf8)!\n    let md5 = data.withUnsafeBytes { (bytes: UnsafePointer<Data>) ->\
    \ [UInt8] in\n        var hash: [UInt8] = [UInt8](repeating: 0, count: Int(CC_MD5_DIGEST_LENGTH))\n\
    \        CC_MD5(bytes, CC_LONG(data.count), &hash)\n        return hash\n    }\n\
    \    return md5.map { String(format: \"%02x\", $0) }.joined()", "    guard !text.isEmpty\
    \ else {\n        return nil\n    }\n    let messageData = text.data(using:.utf8)!\n\
    \    var digestData = Data(count: Int(CC_MD5_DIGEST_LENGTH))\n    \n    _ = digestData.withUnsafeMutableBytes\
    \ {digestBytes in\n        messageData.withUnsafeBytes {messageBytes in\n    \
    \        CC_MD5(messageBytes, CC_LONG(messageData.count), digestBytes)\n     \
    \   }\n    }\n    return digestData.map { String(format: \"%02hhx\", $0) }.joined()",
  "    guard !text.isEmpty else {\n        return nil\n    }\n    return text.md5()",
  "    if text.isEmpty {\n        return nil\n    }\n    let md5_data = text.data(using:\
    \ .utf8)!.md5()\n    let md5_text = Data(md5_data).hexEncodedString()\n    return\
    \ md5_text", "    guard !text.isEmpty else {\n        return nil\n    }\n    let\
    \ messageData = text.data(using:.utf8)!\n    var digestData = Data(count: Int(CC_MD5_DIGEST_LENGTH))\n\
    \    \n    _ = digestData.withUnsafeMutableBytes {digestBytes in\n        messageData.withUnsafeBytes\
    \ {messageBytes in\n            CC_MD5(messageBytes, CC_LONG(messageData.count),\
    \ digestBytes)\n        }\n    }\n    return digestData.map { String(format: \"\
    %02hhx\", $0) }.joined()", "    if text.isEmpty {\n        return nil\n    }\n\
    \    var digest = [UInt8](repeating: 0, count: Int(CC_MD5_DIGEST_LENGTH))\n  \
    \  if let data = text.data(using: String.Encoding.utf8) {\n        let _ = data.withUnsafeBytes\
    \ { CC_MD5($0.baseAddress, CC_LONG(data.count), &digest) }\n    }\n    var digestHex\
    \ = \"\"\n    for index in 0..<Int(CC_MD5_DIGEST_LENGTH) {\n        digestHex\
    \ += String(format: \"%02x\", digest[index])\n    }\n    return digestHex", " \
    \   if text.isEmpty {\n        return nil\n    }\n    let messageData = text.data(using:.utf8)!\n\
    \    var digestData = Data(count: Int(CC_MD5_DIGEST_LENGTH))\n    \n    _ = digestData.withUnsafeMutableBytes\
    \ {digestBytes in\n        messageData.withUnsafeBytes {messageBytes in\n    \
    \        CC_MD5(messageBytes, CC_LONG(messageData.count), digestBytes)\n     \
    \   }\n    }\n    return digestData.map { String(format: \"%02hhx\", $0) }.joined()",
  "    if !text.isEmpty {\n        let str = text.cString(using: String.Encoding.utf8)\n\
    \        let strLen = CUnsignedInt(text.lengthOfBytes(using: String.Encoding.utf8))\n\
    \        let digestLen = Int(CC_MD5_DIGEST_LENGTH)\n        let result = UnsafeMutablePointer<CUnsignedChar>.allocate(capacity:\
    \ digestLen)\n        CC_MD5(str!, strLen, result)\n        let hash = NSMutableString()\n\
    \        for i in 0..<digestLen {\n            hash.appendFormat(\"%02x\", result[i])\n\
    \        }\n        result.deinitialize()\n        return String(format: hash\
    \ as String)\n    }\n    return nil", "    guard text.isEmpty == false else {\n\
    \        return nil\n    }\n    var digest = [UInt8](repeating: 0, count: Int(CC_MD5_DIGEST_LENGTH))\n\
    \    if let data = text.data(using: String.Encoding.utf8) {\n        let _ = data.withUnsafeBytes\
    \ { (bytes: UnsafePointer<CChar>) -> Int in\n            CC_MD5(bytes, CC_LONG(data.count),\
    \ &digest)\n            return 0\n        }\n    }\n    return digest.map({ String(format:\
    \ \"%02x\", $0) }).joined()", "    if text.isEmpty {\n        return nil\n   \
    \ }\n    var digest = [UInt8](repeating: 0, count: Int(CC_MD5_DIGEST_LENGTH))\n\
    \    let data = (text as NSString).data(using: String.Encoding.utf8.rawValue)!\
    \ as NSData\n    CC_MD5(data.bytes, CC_LONG(data.length), &digest)\n    var result\
    \ = String()\n    for byte in digest {\n        result += String(format: \"%02x\"\
    , byte)\n    }\n    return result", "    guard text.count > 0 else {\n       \
    \ return nil\n    }\n    let messageData = text.data(using:.utf8)!\n    var digestData\
    \ = Data(count: Int(CC_MD5_DIGEST_LENGTH))\n    \n    _ = digestData.withUnsafeMutableBytes\
    \ {digestBytes in\n        messageData.withUnsafeBytes {messageBytes in\n    \
    \        CC_MD5(messageBytes, CC_LONG(messageData.count), digestBytes)\n     \
    \   }\n    }\n    return digestData.map { String(format: \"%02hhx\", $0) }.joined()",
  "    if text.isEmpty {\n        return nil\n    }\n    let utf8Text = text.data(using:\
    \ .utf8)\n    var md5Result = [UInt8](repeating: 0, count: Int(CC_MD5_DIGEST_LENGTH))\n\
    \    CC_MD5(utf8Text!.bytes, CC_LONG(utf8Text!.count), &md5Result)\n    return\
    \ md5Result.map { String(format: \"%02hhx\", $0) }.joined()", "    guard !text.isEmpty\
    \ else {\n        return nil\n    }\n    let messageData = text.data(using:.utf8)!\n\
    \    var digestData = Data(count: Int(CC_MD5_DIGEST_LENGTH))\n    \n    _ = digestData.withUnsafeMutableBytes\
    \ {digestBytes in\n        messageData.withUnsafeBytes {messageBytes in\n    \
    \        CC_MD5(messageBytes, CC_LONG(messageData.count), digestBytes)\n     \
    \   }\n    }\n    return digestData.map { String(format: \"%02hhx\", $0) }.joined()",
  "    if text.isEmpty {\n        return nil\n    }\n    return text.md5", "    if\
    \ !text.isEmpty {\n        if let data = text.data(using: .utf8) {\n         \
    \   var digest = [UInt8](repeating: 0, count: Int(CC_MD5_DIGEST_LENGTH))\n   \
    \         data.withUnsafeBytes { bytes in\n                _ = CC_MD5(bytes, CC_LONG(data.count),\
    \ &digest)\n            }\n            return digest.map { String(format: \"%02x\"\
    , $0) }.joined()\n        }\n    }\n    return nil", "    guard !text.isEmpty\
    \ else {\n        return nil\n    }\n    let messageData = text.data(using:.utf8)!\n\
    \    var digestData = Data(count: Int(CC_MD5_DIGEST_LENGTH))\n    \n    _ = digestData.withUnsafeMutableBytes\
    \ {digestBytes in\n        messageData.withUnsafeBytes {messageBytes in\n    \
    \        CC_MD5(messageBytes, CC_LONG(messageData.count), digestBytes)\n     \
    \   }\n    }\n    let formattedString = digestData.map { String(format: \"%02hhx\"\
    , $0) }.joined()\n    return formattedString", "    guard text.count > 0 else\
    \ {\n        return nil\n    }\n    let data = text.data(using: .utf8)!\n    let\
    \ res = NSMutableData(length: Int(CC_MD5_DIGEST_LENGTH))!\n    CC_MD5((data as\
    \ NSData).bytes, CC_LONG(data.count), res.mutableBytes.assumingMemoryBound(to:\
    \ UInt8.self))\n    return res.map { String(format: \"%02hhx\", $0) }.joined()",
  "    let length = Int(CC_MD5_DIGEST_LENGTH)\n    guard let data = text.data(using:\
    \ .utf8) else { return nil }\n    var digest = [UInt8](repeating: 0, count: length)\n\
    \    data.withUnsafeBytes { _ = CC_MD5($0.baseAddress, CC_LONG(data.count), &digest)\
    \ }\n    return (0..<length).reduce(\"\") {\n        $0 + String(format: \"%02x\"\
    , digest[$1])\n    }", "    if text.isEmpty {\n        return nil\n    }\n   \
    \ let messageData = text.data(using:.utf8)!\n    var digestData = Data(count:\
    \ Int(CC_MD5_DIGEST_LENGTH))\n    \n    _ = digestData.withUnsafeMutableBytes\
    \ {digestBytes in\n        messageData.withUnsafeBytes {messageBytes in\n    \
    \        CC_MD5(messageBytes, CC_LONG(messageData.count), digestBytes)\n     \
    \   }\n    }\n    let digestStr = digestData.map { String(format: \"%02hhx\",\
    \ $0) }.joined()\n    return digestStr", "    guard text.count > 0 else {\n  \
    \      return nil\n    }\n    let cString = text.cString(using: String.Encoding.utf8)\n\
    \    let length = CUnsignedInt(text.lengthOfBytes(using: String.Encoding.utf8))\n\
    \    let result = UnsafeMutablePointer<CUnsignedChar>.allocate(capacity: Int(CC_MD5_DIGEST_LENGTH))\n\
    \    CC_MD5(cString!, length, result)\n    return String(format: \"%02x%02x%02x%02x%02x%02x%02x%02x%02x%02x%02x%02x%02x%02x%02x%02x\"\
    , result[0], result[1], result[2], result[3], result[4], result[5], result[6],\
    \ result[7], result[8], result[9], result[10], result[11], result[12], result[13],\
    \ result[14], result[15])", "    if text.isEmpty {\n        return nil\n    }\n\
    \    return String(format: \"%02hhx\", Digest.md5(text))", "\tguard text.isEmpty\
    \ == false else {\n\t\treturn nil\n\t}\n\t\n\t// append the string to the  MD5\
    \ context\n\tlet context = UnsafeMutablePointer<CC_MD5_CTX>.allocate(capacity:\
    \ 1)\n\tvar digest = Array<UInt8>(repeating:0, count:Int(CC_MD5_DIGEST_LENGTH))\n\
    \tCC_MD5_Init(context)\n\tCC_MD5_Update(context, text, CC_LONG(text.lengthOfBytes(using:\
    \ String.Encoding.utf8)))\n\tCC_MD5_Final(&digest, context)\n\tcontext.deallocate()\n\
    \t\n\t// convert the digest to a string\n\tvar hexString = \"\"\n\tfor byte in\
    \ digest {\n\t\thexString += String(format:\"%02x\", byte)\n\t}\n\t\n\treturn\
    \ hexString", "  guard !text.isEmpty else { return nil }\n  let length = Int(CC_MD5_DIGEST_LENGTH)\n\
    \  var digest = [UInt8](repeating: 0, count: length)\n  if let d = text.data(using:\
    \ String.Encoding.utf8) {\n    _ = d.withUnsafeBytes { (body: UnsafePointer<UInt8>)\
    \ in\n      CC_MD5(body, CC_LONG(d.count), &digest)\n    }\n  }\n  return (0..<length).reduce(\"\
    \") {\n    $0 + String(format: \"%02x\", digest[$1])\n  }", "  guard !text.isEmpty\
    \ else { return nil }\n  let buffer = [UInt8](text.utf8)\n  let MD5_LENGTH = Int(CC_MD5_DIGEST_LENGTH)\n\
    \  let digest = UnsafeMutablePointer<CUnsignedChar>.allocate(capacity: MD5_LENGTH)\n\
    \  CC_MD5(buffer, CC_LONG(buffer.count), digest)\n  let md5Hex = digest.withMemoryRebound(to:\
    \ CChar.self, capacity: MD5_LENGTH) {\n    return String(cString: $0)\n  }\n \
    \ return md5Hex", "    guard text.count > 0 else {\n        return nil\n    }\n\
    \    let messageData = text.data(using:.utf8)!\n    var digestData = Data(count:\
    \ Int(CC_MD5_DIGEST_LENGTH))\n    \n    _ = digestData.withUnsafeMutableBytes\
    \ {digestBytes in\n        messageData.withUnsafeBytes {messageBytes in\n    \
    \        CC_MD5(messageBytes, CC_LONG(messageData.count), digestBytes)\n     \
    \   }\n    }\n    return digestData.map { String(format: \"%02hhx\", $0) }.joined()",
  "    guard !text.isEmpty else {\n        return nil\n    }\n    let data = text.data(using:\
    \ .utf8)!\n    let hex = data.withUnsafeBytes { (bytes: UnsafePointer<Data>) ->\
    \ String in\n        return bytes.withMemoryRebound(to: UInt8.self, capacity:\
    \ data.count) {\n            $0.map { String(format: \"%02x\", $0) }.joined()\n\
    \        }\n    }\n    return hex", "    guard !text.isEmpty else {\n        return\
    \ nil\n    }\n    return text.to_md5()", "    guard !text.isEmpty else {\n   \
    \     return nil\n    }\n    let messageData = text.data(using:.utf8)!\n    var\
    \ digestData = Data(count: Int(CC_MD5_DIGEST_LENGTH))\n    \n    _ = digestData.withUnsafeMutableBytes\
    \ {digestBytes in\n        messageData.withUnsafeBytes {messageBytes in\n    \
    \        CC_MD5(messageBytes, CC_LONG(messageData.count), digestBytes)\n     \
    \   }\n    }\n    return digestData.map { String(format: \"%02hhx\", $0) }.joined()",
  "    guard !text.isEmpty else {\n        return nil\n    }\n    let str = text.cString(using:\
    \ String.Encoding.utf8)\n    let strLen = CUnsignedInt(text.lengthOfBytes(using:\
    \ String.Encoding.utf8))\n    let digestLen = Int(CC_MD5_DIGEST_LENGTH)\n    let\
    \ result = UnsafeMutablePointer<CUnsignedChar>.allocate(capacity: digestLen)\n\
    \    CC_MD5(str!, strLen, result)\n    let hash = NSMutableString()\n    for i\
    \ in 0..<digestLen {\n        hash.appendFormat(\"%02x\", result[i])\n    }\n\
    \    result.deinitialize()\n    return String(format: hash as String)", "  guard\
    \ !text.isEmpty else { return nil }\n  let digest = text.data(using: .utf8)?.md5()\n\
    \  return digest?.base64EncodedString()", "    if text.isEmpty {\n        return\
    \ nil\n    }\n    let messageData = text.data(using:.utf8)!\n    var digestData\
    \ = Data(count: Int(CC_MD5_DIGEST_LENGTH))\n    \n    _ = digestData.withUnsafeMutableBytes\
    \ {digestBytes in\n        messageData.withUnsafeBytes {messageBytes in\n    \
    \        CC_MD5(messageBytes, CC_LONG(messageData.count), digestBytes)\n     \
    \   }\n    }\n    return digestData.map { String(format: \"%02hhx\", $0) }.joined()",
  "    guard !text.isEmpty else {\n        return nil\n    }\n    var digest = [UInt8](repeating:\
    \ 0, count: Int(CC_MD5_DIGEST_LENGTH))\n    if let data = text.data(using: String.Encoding.utf8)\
    \ {\n        _ = data.withUnsafeBytes { (bytes: UnsafePointer<UInt8>) -> Int in\n\
    \            CC_MD5(bytes, CC_LONG(data.count), &digest)\n            return 0\n\
    \        }\n    }\n    var digestHex = \"\"\n    for index in 0..<Int(CC_MD5_DIGEST_LENGTH)\
    \ {\n        digestHex += String(format: \"%02x\", digest[index])\n    }\n   \
    \ return digestHex", "    if text.isEmpty {\n        return nil\n    }\n    let\
    \ messageData = text.data(using:.utf8)!\n    var digestData = Data(count: Int(CC_MD5_DIGEST_LENGTH))\n\
    \    \n    _ = digestData.withUnsafeMutableBytes {digestBytes in\n        messageData.withUnsafeBytes\
    \ {messageBytes in\n            CC_MD5(messageBytes, CC_LONG(messageData.count),\
    \ digestBytes)\n        }\n    }\n    return digestData.map { String(format: \"\
    %02hhx\", $0) }.joined()", "    let length = Int(CC_MD5_DIGEST_LENGTH)\n    guard\
    \ let messageData = text.data(using: .utf8) else { return nil }\n    var digestData\
    \ = Data(count: length)\n    \n    _ = digestData.withUnsafeMutableBytes { digestBytes\
    \ -> UInt8 in\n        messageData.withUnsafeBytes { messageBytes -> UInt8 in\n\
    \            if let messageBytesBaseAddress = messageBytes.baseAddress, let digestBytesBlindMemory\
    \ = digestBytes.bindMemory(to: UInt8.self).baseAddress {\n                let\
    \ messageLength = CC_LONG(messageData.count)\n                CC_MD5(messageBytesBaseAddress,\
    \ messageLength, digestBytesBlindMemory)\n            }\n            return 0\n\
    \        }\n    }\n    return digestData.map { String(format: \"%02hhx\", $0)\
    \ }.joined()", "    if text.isEmpty {\n        return nil\n    }\n    let data\
    \ = Data(text.utf8)\n    let hash = data.withUnsafeBytes { (bytes: UnsafeRawBufferPointer)\
    \ -> [UInt8] in\n        var hash = [UInt8](repeating: 0, count: Int(CC_MD5_DIGEST_LENGTH))\n\
    \        CC_MD5(bytes.baseAddress, CC_LONG(data.count), &hash)\n        return\
    \ hash\n    }\n    return hash.map { String(format: \"%02x\", $0) }.joined()",
  "    guard !text.isEmpty else {\n        return nil\n    }\n    let value = text.data(using:\
    \ String.Encoding.utf8)\n    var digest = [UInt8](repeating: 0, count: Int(CC_MD5_DIGEST_LENGTH))\n\
    \    _ = value?.withUnsafeBytes {\n        CC_MD5($0, CC_LONG((value?.count)!),\
    \ &digest)\n    }\n    return digest.map { String(format: \"%02x\", $0) }.joined()",
  "    guard text.count > 0 else {\n        return nil\n    }\n    let messageData\
    \ = text.data(using: .utf8)!\n    var digestData = Data(count: Int(CC_MD5_DIGEST_LENGTH))\n\
    \    _ = digestData.withUnsafeMutableBytes { digestBytes -> UInt8 in\n       \
    \ messageData.withUnsafeBytes { messageBytes -> UInt8 in\n            if let messageBytesBaseAddress\
    \ = messageBytes.baseAddress, let digestBytesBlindMemory = digestBytes.bindMemory(to:\
    \ UInt8.self).baseAddress {\n                let messageLength = CC_LONG(messageData.count)\n\
    \                CC_MD5(messageBytesBaseAddress, messageLength, digestBytesBlindMemory)\n\
    \            }\n            return 0\n        }\n    }\n    return digestData.map\
    \ { String(format: \"%02hhx\", $0) }.joined()", "    if !text.isEmpty {\n    \
    \    let inputData = text.data(using: .utf8)!\n        let hashed = MD5(inputData)\n\
    \        return hashed.map { String(format: \"%02hhx\", $0) }.joined()\n    }\n\
    \    return nil", "    guard text.count > 0 else {\n        return nil\n    }\n\
    \    let bytes: Array<UInt8> = Array(text.utf8)\n    return bytes_to_md5(bytes:\
    \ bytes)"]
stop_tokens:
- "\n}"
