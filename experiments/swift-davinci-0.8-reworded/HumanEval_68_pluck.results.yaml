language: swift
name: HumanEval_68_pluck
results:
- exit_code: -4
  program: "\n/// \"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n/// your task is to pluck one of the nodes and return it.\n///\
    \ The plucked node should be the node with the smallest even value.\n/// If multiple\
    \ nodes with the same smallest even value are found return the node that has smallest\
    \ index.\n/// The plucked node should be returned in an array, [ smalest_value,\
    \ its index ],\n/// If there are no even values or the given array is empty, return\
    \ [].\n/// Example 1:\n/// >>> pluck(arr: [4, 2, 3])\n/// [2, 1]\n/// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n/// Example 2:\n\
    /// >>> pluck(arr: [1, 2, 3])\n/// [2, 1]\n/// Explanation: 2 has the smallest\
    \ even value, and 2 has the smallest index.\n/// Example 3:\n/// >>> pluck(arr:\
    \ [] as [Int])\n/// [] as [Int]\n/// Example 4:\n/// >>> pluck(arr: [5, 0, 3,\
    \ 0, 4, 2])\n/// [0, 1]\n/// Explanation: 0 is the smallest value, but  there\
    \ are two zeros,\n/// so we will choose the first zero, which has the smallest\
    \ index.\n/// Constraints:\n/// * 1 <= nodes.length <= 10000\n/// * 0 <= node.value\n\
    func pluck(arr: [Int]) -> [Int] {\n    return [1, 2]\n}\n\n\nfunc ==(left: [(Int,\
    \ Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n\
    \        return false\n    }\n    for (l, r) in zip(left, right) {\n        if\
    \ l != r {\n            return false\n        }\n    }\n    return true\n}\n \
    \           \nassert(pluck(arr: [4, 2, 3]) == [2, 1])\nassert(pluck(arr: [1, 2,\
    \ 3]) == [2, 1])\nassert(pluck(arr: [] as [Int]) == [] as [Int])\nassert(pluck(arr:\
    \ [5, 0, 3, 0, 4, 2]) == [0, 1])\nassert(pluck(arr: [1, 2, 3, 0, 5, 3]) == [0,\
    \ 3])\nassert(pluck(arr: [5, 4, 8, 4, 8]) == [4, 1])\nassert(pluck(arr: [7, 6,\
    \ 7, 1]) == [6, 1])\nassert(pluck(arr: [7, 9, 7, 1]) == [] as [Int])"
  status: Exception
  stderr: 'tmpmj3rlp1j/tmpmj3rlp1j.swift:44: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002abed914ac80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002abed8e41b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002abed8e41988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002abed8e407b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpmj3rlp1j                        0x00005623e88c93bc <unavailable> + 5052

    5    libc.so.6                          0x00002abed9336460 __libc_start_main +
    245

    6    tmpmj3rlp1j                        0x00005623e88c8fc9 <unavailable> + 4041

    '
  stdout: ''
  timestamp: 1660013548
- exit_code: 1
  program: "\n/// \"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n/// your task is to pluck one of the nodes and return it.\n///\
    \ The plucked node should be the node with the smallest even value.\n/// If multiple\
    \ nodes with the same smallest even value are found return the node that has smallest\
    \ index.\n/// The plucked node should be returned in an array, [ smalest_value,\
    \ its index ],\n/// If there are no even values or the given array is empty, return\
    \ [].\n/// Example 1:\n/// >>> pluck(arr: [4, 2, 3])\n/// [2, 1]\n/// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n/// Example 2:\n\
    /// >>> pluck(arr: [1, 2, 3])\n/// [2, 1]\n/// Explanation: 2 has the smallest\
    \ even value, and 2 has the smallest index.\n/// Example 3:\n/// >>> pluck(arr:\
    \ [] as [Int])\n/// [] as [Int]\n/// Example 4:\n/// >>> pluck(arr: [5, 0, 3,\
    \ 0, 4, 2])\n/// [0, 1]\n/// Explanation: 0 is the smallest value, but  there\
    \ are two zeros,\n/// so we will choose the first zero, which has the smallest\
    \ index.\n/// Constraints:\n/// * 1 <= nodes.length <= 10000\n/// * 0 <= node.value\n\
    func pluck(arr: [Int]) -> [Int] {\n    var current = arr.sorted().filter { $0.isEven\
    \ }\n    if current.isEmpty { return [] }\n    return [current.first!, arr.firstIndex(of:\
    \ current.first!)!]\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) ->\
    \ Bool {\n    if left.count != right.count {\n        return false\n    }\n  \
    \  for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(pluck(arr: [4, 2,\
    \ 3]) == [2, 1])\nassert(pluck(arr: [1, 2, 3]) == [2, 1])\nassert(pluck(arr: []\
    \ as [Int]) == [] as [Int])\nassert(pluck(arr: [5, 0, 3, 0, 4, 2]) == [0, 1])\n\
    assert(pluck(arr: [1, 2, 3, 0, 5, 3]) == [0, 3])\nassert(pluck(arr: [5, 4, 8,\
    \ 4, 8]) == [4, 1])\nassert(pluck(arr: [7, 6, 7, 1]) == [6, 1])\nassert(pluck(arr:\
    \ [7, 9, 7, 1]) == [] as [Int])"
  status: SyntaxError
  stderr: "/tmp/tmpqm_mqkq1.swift:28:44: error: value of type 'Int' has no member\
    \ 'isEven'\n    var current = arr.sorted().filter { $0.isEven }\n            \
    \                            ~~ ^~~~~~\n"
  stdout: ''
  timestamp: 1660013548
- exit_code: 0
  program: "\n/// \"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n/// your task is to pluck one of the nodes and return it.\n///\
    \ The plucked node should be the node with the smallest even value.\n/// If multiple\
    \ nodes with the same smallest even value are found return the node that has smallest\
    \ index.\n/// The plucked node should be returned in an array, [ smalest_value,\
    \ its index ],\n/// If there are no even values or the given array is empty, return\
    \ [].\n/// Example 1:\n/// >>> pluck(arr: [4, 2, 3])\n/// [2, 1]\n/// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n/// Example 2:\n\
    /// >>> pluck(arr: [1, 2, 3])\n/// [2, 1]\n/// Explanation: 2 has the smallest\
    \ even value, and 2 has the smallest index.\n/// Example 3:\n/// >>> pluck(arr:\
    \ [] as [Int])\n/// [] as [Int]\n/// Example 4:\n/// >>> pluck(arr: [5, 0, 3,\
    \ 0, 4, 2])\n/// [0, 1]\n/// Explanation: 0 is the smallest value, but  there\
    \ are two zeros,\n/// so we will choose the first zero, which has the smallest\
    \ index.\n/// Constraints:\n/// * 1 <= nodes.length <= 10000\n/// * 0 <= node.value\n\
    func pluck(arr: [Int]) -> [Int] {\n    var minEven: Int?\n    var minEvenIndex:\
    \ Int?\n    for (index, val) in arr.enumerated() {\n        if val % 2 == 0 {\n\
    \            if minEven == nil || val < minEven! {\n                minEven =\
    \ val\n                minEvenIndex = index\n            }\n        }\n    }\n\
    \    return minEven != nil ? [minEven!, minEvenIndex!] : []\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(pluck(arr: [4, 2, 3]) == [2, 1])\nassert(pluck(arr: [1,\
    \ 2, 3]) == [2, 1])\nassert(pluck(arr: [] as [Int]) == [] as [Int])\nassert(pluck(arr:\
    \ [5, 0, 3, 0, 4, 2]) == [0, 1])\nassert(pluck(arr: [1, 2, 3, 0, 5, 3]) == [0,\
    \ 3])\nassert(pluck(arr: [5, 4, 8, 4, 8]) == [4, 1])\nassert(pluck(arr: [7, 6,\
    \ 7, 1]) == [6, 1])\nassert(pluck(arr: [7, 9, 7, 1]) == [] as [Int])"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660013548
- exit_code: 0
  program: "\n/// \"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n/// your task is to pluck one of the nodes and return it.\n///\
    \ The plucked node should be the node with the smallest even value.\n/// If multiple\
    \ nodes with the same smallest even value are found return the node that has smallest\
    \ index.\n/// The plucked node should be returned in an array, [ smalest_value,\
    \ its index ],\n/// If there are no even values or the given array is empty, return\
    \ [].\n/// Example 1:\n/// >>> pluck(arr: [4, 2, 3])\n/// [2, 1]\n/// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n/// Example 2:\n\
    /// >>> pluck(arr: [1, 2, 3])\n/// [2, 1]\n/// Explanation: 2 has the smallest\
    \ even value, and 2 has the smallest index.\n/// Example 3:\n/// >>> pluck(arr:\
    \ [] as [Int])\n/// [] as [Int]\n/// Example 4:\n/// >>> pluck(arr: [5, 0, 3,\
    \ 0, 4, 2])\n/// [0, 1]\n/// Explanation: 0 is the smallest value, but  there\
    \ are two zeros,\n/// so we will choose the first zero, which has the smallest\
    \ index.\n/// Constraints:\n/// * 1 <= nodes.length <= 10000\n/// * 0 <= node.value\n\
    func pluck(arr: [Int]) -> [Int] {\n    let evens = arr.filter { $0 % 2 == 0 }\n\
    \    guard !evens.isEmpty else { return [] }\n    let minEven = evens.min()!\n\
    \    let idx = arr.firstIndex(of: minEven)!\n    return [minEven, idx]\n}\n\n\n\
    func ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(pluck(arr: [4, 2, 3]) == [2, 1])\nassert(pluck(arr:\
    \ [1, 2, 3]) == [2, 1])\nassert(pluck(arr: [] as [Int]) == [] as [Int])\nassert(pluck(arr:\
    \ [5, 0, 3, 0, 4, 2]) == [0, 1])\nassert(pluck(arr: [1, 2, 3, 0, 5, 3]) == [0,\
    \ 3])\nassert(pluck(arr: [5, 4, 8, 4, 8]) == [4, 1])\nassert(pluck(arr: [7, 6,\
    \ 7, 1]) == [6, 1])\nassert(pluck(arr: [7, 9, 7, 1]) == [] as [Int])"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660013548
- exit_code: 1
  program: "\n/// \"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n/// your task is to pluck one of the nodes and return it.\n///\
    \ The plucked node should be the node with the smallest even value.\n/// If multiple\
    \ nodes with the same smallest even value are found return the node that has smallest\
    \ index.\n/// The plucked node should be returned in an array, [ smalest_value,\
    \ its index ],\n/// If there are no even values or the given array is empty, return\
    \ [].\n/// Example 1:\n/// >>> pluck(arr: [4, 2, 3])\n/// [2, 1]\n/// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n/// Example 2:\n\
    /// >>> pluck(arr: [1, 2, 3])\n/// [2, 1]\n/// Explanation: 2 has the smallest\
    \ even value, and 2 has the smallest index.\n/// Example 3:\n/// >>> pluck(arr:\
    \ [] as [Int])\n/// [] as [Int]\n/// Example 4:\n/// >>> pluck(arr: [5, 0, 3,\
    \ 0, 4, 2])\n/// [0, 1]\n/// Explanation: 0 is the smallest value, but  there\
    \ are two zeros,\n/// so we will choose the first zero, which has the smallest\
    \ index.\n/// Constraints:\n/// * 1 <= nodes.length <= 10000\n/// * 0 <= node.value\n\
    func pluck(arr: [Int]) -> [Int] {\n    var answer = [Int]()\n    var minEven =\
    \ 10000\n    var minEvenIndex = 10000\n    for (index, value) in arr.enumerated()\
    \ {\n        if value.isEven && value < minEven {\n            minEven = value\n\
    \            minEvenIndex = index\n        }\n    }\n    if minEven != 10000 {\n\
    \        answer.append(minEven)\n        answer.append(minEvenIndex)\n    }\n\
    \    return answer\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) ->\
    \ Bool {\n    if left.count != right.count {\n        return false\n    }\n  \
    \  for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(pluck(arr: [4, 2,\
    \ 3]) == [2, 1])\nassert(pluck(arr: [1, 2, 3]) == [2, 1])\nassert(pluck(arr: []\
    \ as [Int]) == [] as [Int])\nassert(pluck(arr: [5, 0, 3, 0, 4, 2]) == [0, 1])\n\
    assert(pluck(arr: [1, 2, 3, 0, 5, 3]) == [0, 3])\nassert(pluck(arr: [5, 4, 8,\
    \ 4, 8]) == [4, 1])\nassert(pluck(arr: [7, 6, 7, 1]) == [6, 1])\nassert(pluck(arr:\
    \ [7, 9, 7, 1]) == [] as [Int])"
  status: SyntaxError
  stderr: "/tmp/tmpunt600ry.swift:32:18: error: value of type 'Int' has no member\
    \ 'isEven'\n        if value.isEven && value < minEven {\n           ~~~~~ ^~~~~~\n"
  stdout: ''
  timestamp: 1660013548
- exit_code: 1
  program: "\n/// \"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n/// your task is to pluck one of the nodes and return it.\n///\
    \ The plucked node should be the node with the smallest even value.\n/// If multiple\
    \ nodes with the same smallest even value are found return the node that has smallest\
    \ index.\n/// The plucked node should be returned in an array, [ smalest_value,\
    \ its index ],\n/// If there are no even values or the given array is empty, return\
    \ [].\n/// Example 1:\n/// >>> pluck(arr: [4, 2, 3])\n/// [2, 1]\n/// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n/// Example 2:\n\
    /// >>> pluck(arr: [1, 2, 3])\n/// [2, 1]\n/// Explanation: 2 has the smallest\
    \ even value, and 2 has the smallest index.\n/// Example 3:\n/// >>> pluck(arr:\
    \ [] as [Int])\n/// [] as [Int]\n/// Example 4:\n/// >>> pluck(arr: [5, 0, 3,\
    \ 0, 4, 2])\n/// [0, 1]\n/// Explanation: 0 is the smallest value, but  there\
    \ are two zeros,\n/// so we will choose the first zero, which has the smallest\
    \ index.\n/// Constraints:\n/// * 1 <= nodes.length <= 10000\n/// * 0 <= node.value\n\
    func pluck(arr: [Int]) -> [Int] {\n    return arr.enumerated().filter { $0.element\
    \ % 2 == 0 }.min { $0.element < $1.element }?.map { [$0.element, $0.offset] }\
    \ ?? []\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n \
    \   if left.count != right.count {\n        return false\n    }\n    for (l, r)\
    \ in zip(left, right) {\n        if l != r {\n            return false\n     \
    \   }\n    }\n    return true\n}\n            \nassert(pluck(arr: [4, 2, 3]) ==\
    \ [2, 1])\nassert(pluck(arr: [1, 2, 3]) == [2, 1])\nassert(pluck(arr: [] as [Int])\
    \ == [] as [Int])\nassert(pluck(arr: [5, 0, 3, 0, 4, 2]) == [0, 1])\nassert(pluck(arr:\
    \ [1, 2, 3, 0, 5, 3]) == [0, 3])\nassert(pluck(arr: [5, 4, 8, 4, 8]) == [4, 1])\n\
    assert(pluck(arr: [7, 6, 7, 1]) == [6, 1])\nassert(pluck(arr: [7, 9, 7, 1]) ==\
    \ [] as [Int])"
  status: SyntaxError
  stderr: "/tmp/tmp1d9_hgv3.swift:28:93: error: value of tuple type 'EnumeratedSequence<[Int]>.Iterator.Element'\
    \ (aka '(offset: Int, element: Int)') has no member 'map'\n    return arr.enumerated().filter\
    \ { $0.element % 2 == 0 }.min { $0.element < $1.element }?.map { [$0.element,\
    \ $0.offset] } ?? []\n           ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\
    \ ^~~\n"
  stdout: ''
  timestamp: 1660013364
- exit_code: 0
  program: "\n/// \"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n/// your task is to pluck one of the nodes and return it.\n///\
    \ The plucked node should be the node with the smallest even value.\n/// If multiple\
    \ nodes with the same smallest even value are found return the node that has smallest\
    \ index.\n/// The plucked node should be returned in an array, [ smalest_value,\
    \ its index ],\n/// If there are no even values or the given array is empty, return\
    \ [].\n/// Example 1:\n/// >>> pluck(arr: [4, 2, 3])\n/// [2, 1]\n/// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n/// Example 2:\n\
    /// >>> pluck(arr: [1, 2, 3])\n/// [2, 1]\n/// Explanation: 2 has the smallest\
    \ even value, and 2 has the smallest index.\n/// Example 3:\n/// >>> pluck(arr:\
    \ [] as [Int])\n/// [] as [Int]\n/// Example 4:\n/// >>> pluck(arr: [5, 0, 3,\
    \ 0, 4, 2])\n/// [0, 1]\n/// Explanation: 0 is the smallest value, but  there\
    \ are two zeros,\n/// so we will choose the first zero, which has the smallest\
    \ index.\n/// Constraints:\n/// * 1 <= nodes.length <= 10000\n/// * 0 <= node.value\n\
    func pluck(arr: [Int]) -> [Int] {\n    guard arr.contains(where: { $0 % 2 == 0\
    \ }) else { return [] }\n    var smallestEven = Int.max\n    var smallestEvenIndex\
    \ = -1\n    for (index, value) in arr.enumerated() {\n        if value % 2 ==\
    \ 0 && value < smallestEven {\n            smallestEven = value\n            smallestEvenIndex\
    \ = index\n        }\n    }\n    return [smallestEven, smallestEvenIndex]\n}\n\
    \n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(pluck(arr: [4, 2, 3]) == [2, 1])\nassert(pluck(arr:\
    \ [1, 2, 3]) == [2, 1])\nassert(pluck(arr: [] as [Int]) == [] as [Int])\nassert(pluck(arr:\
    \ [5, 0, 3, 0, 4, 2]) == [0, 1])\nassert(pluck(arr: [1, 2, 3, 0, 5, 3]) == [0,\
    \ 3])\nassert(pluck(arr: [5, 4, 8, 4, 8]) == [4, 1])\nassert(pluck(arr: [7, 6,\
    \ 7, 1]) == [6, 1])\nassert(pluck(arr: [7, 9, 7, 1]) == [] as [Int])"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660013548
- exit_code: -4
  program: "\n/// \"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n/// your task is to pluck one of the nodes and return it.\n///\
    \ The plucked node should be the node with the smallest even value.\n/// If multiple\
    \ nodes with the same smallest even value are found return the node that has smallest\
    \ index.\n/// The plucked node should be returned in an array, [ smalest_value,\
    \ its index ],\n/// If there are no even values or the given array is empty, return\
    \ [].\n/// Example 1:\n/// >>> pluck(arr: [4, 2, 3])\n/// [2, 1]\n/// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n/// Example 2:\n\
    /// >>> pluck(arr: [1, 2, 3])\n/// [2, 1]\n/// Explanation: 2 has the smallest\
    \ even value, and 2 has the smallest index.\n/// Example 3:\n/// >>> pluck(arr:\
    \ [] as [Int])\n/// [] as [Int]\n/// Example 4:\n/// >>> pluck(arr: [5, 0, 3,\
    \ 0, 4, 2])\n/// [0, 1]\n/// Explanation: 0 is the smallest value, but  there\
    \ are two zeros,\n/// so we will choose the first zero, which has the smallest\
    \ index.\n/// Constraints:\n/// * 1 <= nodes.length <= 10000\n/// * 0 <= node.value\n\
    func pluck(arr: [Int]) -> [Int] {\n    let result = arr.filter { $0 % 2 == 0 }.filter\
    \ { $0 != 0 }\n    if result.isEmpty {\n        return []\n    }\n    let smallestEven\
    \ = result.min()!\n    let smallestEvenIndex = arr.firstIndex(of: smallestEven)!\n\
    \    return [smallestEven, smallestEvenIndex]\n}\n\n\nfunc ==(left: [(Int, Int)],\
    \ right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n       \
    \ return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r\
    \ {\n            return false\n        }\n    }\n    return true\n}\n        \
    \    \nassert(pluck(arr: [4, 2, 3]) == [2, 1])\nassert(pluck(arr: [1, 2, 3]) ==\
    \ [2, 1])\nassert(pluck(arr: [] as [Int]) == [] as [Int])\nassert(pluck(arr: [5,\
    \ 0, 3, 0, 4, 2]) == [0, 1])\nassert(pluck(arr: [1, 2, 3, 0, 5, 3]) == [0, 3])\n\
    assert(pluck(arr: [5, 4, 8, 4, 8]) == [4, 1])\nassert(pluck(arr: [7, 6, 7, 1])\
    \ == [6, 1])\nassert(pluck(arr: [7, 9, 7, 1]) == [] as [Int])"
  status: Exception
  stderr: 'tmpnivjrhwy/tmpnivjrhwy.swift:53: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b3590b5ec80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b3590855b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b3590855988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b35908547b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpnivjrhwy                        0x0000555e7a777a24 <unavailable> + 6692

    5    libc.so.6                          0x00002b3590d4a460 __libc_start_main +
    245

    6    tmpnivjrhwy                        0x0000555e7a7772c9 <unavailable> + 4809

    '
  stdout: ''
  timestamp: 1660013548
- exit_code: 0
  program: "\n/// \"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n/// your task is to pluck one of the nodes and return it.\n///\
    \ The plucked node should be the node with the smallest even value.\n/// If multiple\
    \ nodes with the same smallest even value are found return the node that has smallest\
    \ index.\n/// The plucked node should be returned in an array, [ smalest_value,\
    \ its index ],\n/// If there are no even values or the given array is empty, return\
    \ [].\n/// Example 1:\n/// >>> pluck(arr: [4, 2, 3])\n/// [2, 1]\n/// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n/// Example 2:\n\
    /// >>> pluck(arr: [1, 2, 3])\n/// [2, 1]\n/// Explanation: 2 has the smallest\
    \ even value, and 2 has the smallest index.\n/// Example 3:\n/// >>> pluck(arr:\
    \ [] as [Int])\n/// [] as [Int]\n/// Example 4:\n/// >>> pluck(arr: [5, 0, 3,\
    \ 0, 4, 2])\n/// [0, 1]\n/// Explanation: 0 is the smallest value, but  there\
    \ are two zeros,\n/// so we will choose the first zero, which has the smallest\
    \ index.\n/// Constraints:\n/// * 1 <= nodes.length <= 10000\n/// * 0 <= node.value\n\
    func pluck(arr: [Int]) -> [Int] {\n    var (result, index, min) = ([Int](), 0,\
    \ Int.max)\n    for i in 0..<arr.count {\n        if arr[i] % 2 == 0 && arr[i]\
    \ < min {\n            min = arr[i]\n            index = i\n        }\n    }\n\
    \    if min < Int.max {\n        result.append(min)\n        result.append(index)\n\
    \    }\n    return result\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(pluck(arr:\
    \ [4, 2, 3]) == [2, 1])\nassert(pluck(arr: [1, 2, 3]) == [2, 1])\nassert(pluck(arr:\
    \ [] as [Int]) == [] as [Int])\nassert(pluck(arr: [5, 0, 3, 0, 4, 2]) == [0, 1])\n\
    assert(pluck(arr: [1, 2, 3, 0, 5, 3]) == [0, 3])\nassert(pluck(arr: [5, 4, 8,\
    \ 4, 8]) == [4, 1])\nassert(pluck(arr: [7, 6, 7, 1]) == [6, 1])\nassert(pluck(arr:\
    \ [7, 9, 7, 1]) == [] as [Int])"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660013548
- exit_code: -4
  program: "\n/// \"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n/// your task is to pluck one of the nodes and return it.\n///\
    \ The plucked node should be the node with the smallest even value.\n/// If multiple\
    \ nodes with the same smallest even value are found return the node that has smallest\
    \ index.\n/// The plucked node should be returned in an array, [ smalest_value,\
    \ its index ],\n/// If there are no even values or the given array is empty, return\
    \ [].\n/// Example 1:\n/// >>> pluck(arr: [4, 2, 3])\n/// [2, 1]\n/// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n/// Example 2:\n\
    /// >>> pluck(arr: [1, 2, 3])\n/// [2, 1]\n/// Explanation: 2 has the smallest\
    \ even value, and 2 has the smallest index.\n/// Example 3:\n/// >>> pluck(arr:\
    \ [] as [Int])\n/// [] as [Int]\n/// Example 4:\n/// >>> pluck(arr: [5, 0, 3,\
    \ 0, 4, 2])\n/// [0, 1]\n/// Explanation: 0 is the smallest value, but  there\
    \ are two zeros,\n/// so we will choose the first zero, which has the smallest\
    \ index.\n/// Constraints:\n/// * 1 <= nodes.length <= 10000\n/// * 0 <= node.value\n\
    func pluck(arr: [Int]) -> [Int] {\n    var evenValueSet = Set<Int>()\n    var\
    \ evenIndexSet = Set<Int>()\n    for (index, value) in arr.enumerated() {\n  \
    \      if value % 2 == 0 {\n            evenValueSet.insert(value)\n         \
    \   evenIndexSet.insert(index)\n        }\n    }\n    var result: [Int] = []\n\
    \    if evenValueSet.count == 0 {\n        return result\n    }\n    var minValue\
    \ = evenValueSet.first!\n    var minIndex = evenIndexSet.first!\n    evenValueSet.removeFirst()\n\
    \    evenIndexSet.removeFirst()\n    while evenValueSet.count > 0 {\n        let\
    \ nextValue = evenValueSet.first!\n        let nextIndex = evenIndexSet.first!\n\
    \        if nextValue < minValue {\n            minValue = nextValue\n       \
    \     minIndex = nextIndex\n        }\n        evenValueSet.removeFirst()\n  \
    \      evenIndexSet.removeFirst()\n    }\n    result.append(minValue)\n    result.append(minIndex)\n\
    \    return result\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) ->\
    \ Bool {\n    if left.count != right.count {\n        return false\n    }\n  \
    \  for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(pluck(arr: [4, 2,\
    \ 3]) == [2, 1])\nassert(pluck(arr: [1, 2, 3]) == [2, 1])\nassert(pluck(arr: []\
    \ as [Int]) == [] as [Int])\nassert(pluck(arr: [5, 0, 3, 0, 4, 2]) == [0, 1])\n\
    assert(pluck(arr: [1, 2, 3, 0, 5, 3]) == [0, 3])\nassert(pluck(arr: [5, 4, 8,\
    \ 4, 8]) == [4, 1])\nassert(pluck(arr: [7, 6, 7, 1]) == [6, 1])\nassert(pluck(arr:\
    \ [7, 9, 7, 1]) == [] as [Int])"
  status: Exception
  stderr: 'tmptzytn_e6/tmptzytn_e6.swift:77: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002acce7e51c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002acce7b48b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002acce7b48988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002acce7b477b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmptzytn_e6                        0x000055d7887c4f28 <unavailable> + 7976

    5    libc.so.6                          0x00002acce803d460 __libc_start_main +
    245

    6    tmptzytn_e6                        0x000055d7887c4519 <unavailable> + 5401

    '
  stdout: ''
  timestamp: 1660013548
- exit_code: -4
  program: "\n/// \"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n/// your task is to pluck one of the nodes and return it.\n///\
    \ The plucked node should be the node with the smallest even value.\n/// If multiple\
    \ nodes with the same smallest even value are found return the node that has smallest\
    \ index.\n/// The plucked node should be returned in an array, [ smalest_value,\
    \ its index ],\n/// If there are no even values or the given array is empty, return\
    \ [].\n/// Example 1:\n/// >>> pluck(arr: [4, 2, 3])\n/// [2, 1]\n/// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n/// Example 2:\n\
    /// >>> pluck(arr: [1, 2, 3])\n/// [2, 1]\n/// Explanation: 2 has the smallest\
    \ even value, and 2 has the smallest index.\n/// Example 3:\n/// >>> pluck(arr:\
    \ [] as [Int])\n/// [] as [Int]\n/// Example 4:\n/// >>> pluck(arr: [5, 0, 3,\
    \ 0, 4, 2])\n/// [0, 1]\n/// Explanation: 0 is the smallest value, but  there\
    \ are two zeros,\n/// so we will choose the first zero, which has the smallest\
    \ index.\n/// Constraints:\n/// * 1 <= nodes.length <= 10000\n/// * 0 <= node.value\n\
    func pluck(arr: [Int]) -> [Int] {\n    return []\n}\n\n\nfunc ==(left: [(Int,\
    \ Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n\
    \        return false\n    }\n    for (l, r) in zip(left, right) {\n        if\
    \ l != r {\n            return false\n        }\n    }\n    return true\n}\n \
    \           \nassert(pluck(arr: [4, 2, 3]) == [2, 1])\nassert(pluck(arr: [1, 2,\
    \ 3]) == [2, 1])\nassert(pluck(arr: [] as [Int]) == [] as [Int])\nassert(pluck(arr:\
    \ [5, 0, 3, 0, 4, 2]) == [0, 1])\nassert(pluck(arr: [1, 2, 3, 0, 5, 3]) == [0,\
    \ 3])\nassert(pluck(arr: [5, 4, 8, 4, 8]) == [4, 1])\nassert(pluck(arr: [7, 6,\
    \ 7, 1]) == [6, 1])\nassert(pluck(arr: [7, 9, 7, 1]) == [] as [Int])"
  status: Exception
  stderr: 'tmpgh8dpvxh/tmpgh8dpvxh.swift:44: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002ac906ec4c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002ac906bbbb6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002ac906bbb988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002ac906bba7b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpgh8dpvxh                        0x00005578e3d9c3bc <unavailable> + 5052

    5    libc.so.6                          0x00002ac9070b0460 __libc_start_main +
    245

    6    tmpgh8dpvxh                        0x00005578e3d9bfc9 <unavailable> + 4041

    '
  stdout: ''
  timestamp: 1660013365
- exit_code: 0
  program: "\n/// \"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n/// your task is to pluck one of the nodes and return it.\n///\
    \ The plucked node should be the node with the smallest even value.\n/// If multiple\
    \ nodes with the same smallest even value are found return the node that has smallest\
    \ index.\n/// The plucked node should be returned in an array, [ smalest_value,\
    \ its index ],\n/// If there are no even values or the given array is empty, return\
    \ [].\n/// Example 1:\n/// >>> pluck(arr: [4, 2, 3])\n/// [2, 1]\n/// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n/// Example 2:\n\
    /// >>> pluck(arr: [1, 2, 3])\n/// [2, 1]\n/// Explanation: 2 has the smallest\
    \ even value, and 2 has the smallest index.\n/// Example 3:\n/// >>> pluck(arr:\
    \ [] as [Int])\n/// [] as [Int]\n/// Example 4:\n/// >>> pluck(arr: [5, 0, 3,\
    \ 0, 4, 2])\n/// [0, 1]\n/// Explanation: 0 is the smallest value, but  there\
    \ are two zeros,\n/// so we will choose the first zero, which has the smallest\
    \ index.\n/// Constraints:\n/// * 1 <= nodes.length <= 10000\n/// * 0 <= node.value\n\
    func pluck(arr: [Int]) -> [Int] {\n    guard !arr.isEmpty else { return [] }\n\
    \    let evens = arr.filter { $0 % 2 == 0 }\n    guard !evens.isEmpty else { return\
    \ [] }\n    guard let minEven = evens.min() else { return [] }\n    guard let\
    \ index = arr.firstIndex(of: minEven) else { return [] }\n    return [minEven,\
    \ index]\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n\
    \    if left.count != right.count {\n        return false\n    }\n    for (l,\
    \ r) in zip(left, right) {\n        if l != r {\n            return false\n  \
    \      }\n    }\n    return true\n}\n            \nassert(pluck(arr: [4, 2, 3])\
    \ == [2, 1])\nassert(pluck(arr: [1, 2, 3]) == [2, 1])\nassert(pluck(arr: [] as\
    \ [Int]) == [] as [Int])\nassert(pluck(arr: [5, 0, 3, 0, 4, 2]) == [0, 1])\nassert(pluck(arr:\
    \ [1, 2, 3, 0, 5, 3]) == [0, 3])\nassert(pluck(arr: [5, 4, 8, 4, 8]) == [4, 1])\n\
    assert(pluck(arr: [7, 6, 7, 1]) == [6, 1])\nassert(pluck(arr: [7, 9, 7, 1]) ==\
    \ [] as [Int])"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660013548
- exit_code: 0
  program: "\n/// \"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n/// your task is to pluck one of the nodes and return it.\n///\
    \ The plucked node should be the node with the smallest even value.\n/// If multiple\
    \ nodes with the same smallest even value are found return the node that has smallest\
    \ index.\n/// The plucked node should be returned in an array, [ smalest_value,\
    \ its index ],\n/// If there are no even values or the given array is empty, return\
    \ [].\n/// Example 1:\n/// >>> pluck(arr: [4, 2, 3])\n/// [2, 1]\n/// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n/// Example 2:\n\
    /// >>> pluck(arr: [1, 2, 3])\n/// [2, 1]\n/// Explanation: 2 has the smallest\
    \ even value, and 2 has the smallest index.\n/// Example 3:\n/// >>> pluck(arr:\
    \ [] as [Int])\n/// [] as [Int]\n/// Example 4:\n/// >>> pluck(arr: [5, 0, 3,\
    \ 0, 4, 2])\n/// [0, 1]\n/// Explanation: 0 is the smallest value, but  there\
    \ are two zeros,\n/// so we will choose the first zero, which has the smallest\
    \ index.\n/// Constraints:\n/// * 1 <= nodes.length <= 10000\n/// * 0 <= node.value\n\
    func pluck(arr: [Int]) -> [Int] {\n    var results = [Int]()\n    var smallestEven\
    \ = Int.max\n    var smallestEvenIndex = 0\n    for (index, number) in arr.enumerated()\
    \ {\n        if number % 2 == 0 {\n            if number < smallestEven {\n  \
    \              smallestEven = number\n                smallestEvenIndex = index\n\
    \            }\n        }\n    }\n    if smallestEven != Int.max {\n        results.append(smallestEven)\n\
    \        results.append(smallestEvenIndex)\n    }\n    return results\n}\n\n\n\
    func ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(pluck(arr: [4, 2, 3]) == [2, 1])\nassert(pluck(arr:\
    \ [1, 2, 3]) == [2, 1])\nassert(pluck(arr: [] as [Int]) == [] as [Int])\nassert(pluck(arr:\
    \ [5, 0, 3, 0, 4, 2]) == [0, 1])\nassert(pluck(arr: [1, 2, 3, 0, 5, 3]) == [0,\
    \ 3])\nassert(pluck(arr: [5, 4, 8, 4, 8]) == [4, 1])\nassert(pluck(arr: [7, 6,\
    \ 7, 1]) == [6, 1])\nassert(pluck(arr: [7, 9, 7, 1]) == [] as [Int])"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660013548
- exit_code: 0
  program: "\n/// \"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n/// your task is to pluck one of the nodes and return it.\n///\
    \ The plucked node should be the node with the smallest even value.\n/// If multiple\
    \ nodes with the same smallest even value are found return the node that has smallest\
    \ index.\n/// The plucked node should be returned in an array, [ smalest_value,\
    \ its index ],\n/// If there are no even values or the given array is empty, return\
    \ [].\n/// Example 1:\n/// >>> pluck(arr: [4, 2, 3])\n/// [2, 1]\n/// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n/// Example 2:\n\
    /// >>> pluck(arr: [1, 2, 3])\n/// [2, 1]\n/// Explanation: 2 has the smallest\
    \ even value, and 2 has the smallest index.\n/// Example 3:\n/// >>> pluck(arr:\
    \ [] as [Int])\n/// [] as [Int]\n/// Example 4:\n/// >>> pluck(arr: [5, 0, 3,\
    \ 0, 4, 2])\n/// [0, 1]\n/// Explanation: 0 is the smallest value, but  there\
    \ are two zeros,\n/// so we will choose the first zero, which has the smallest\
    \ index.\n/// Constraints:\n/// * 1 <= nodes.length <= 10000\n/// * 0 <= node.value\n\
    func pluck(arr: [Int]) -> [Int] {\n    guard arr.count > 0 else { return [] }\n\
    \    let sortedValues = arr.sorted(by: { $0 < $1 })\n    guard let minEvenValue\
    \ = sortedValues.first(where: { $0 % 2 == 0 }) else { return [] }\n    let minEvenIndex\
    \ = arr.firstIndex(of: minEvenValue)!\n    return [minEvenValue, minEvenIndex]\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(pluck(arr: [4, 2, 3]) == [2, 1])\nassert(pluck(arr:\
    \ [1, 2, 3]) == [2, 1])\nassert(pluck(arr: [] as [Int]) == [] as [Int])\nassert(pluck(arr:\
    \ [5, 0, 3, 0, 4, 2]) == [0, 1])\nassert(pluck(arr: [1, 2, 3, 0, 5, 3]) == [0,\
    \ 3])\nassert(pluck(arr: [5, 4, 8, 4, 8]) == [4, 1])\nassert(pluck(arr: [7, 6,\
    \ 7, 1]) == [6, 1])\nassert(pluck(arr: [7, 9, 7, 1]) == [] as [Int])"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660013548
- exit_code: 0
  program: "\n/// \"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n/// your task is to pluck one of the nodes and return it.\n///\
    \ The plucked node should be the node with the smallest even value.\n/// If multiple\
    \ nodes with the same smallest even value are found return the node that has smallest\
    \ index.\n/// The plucked node should be returned in an array, [ smalest_value,\
    \ its index ],\n/// If there are no even values or the given array is empty, return\
    \ [].\n/// Example 1:\n/// >>> pluck(arr: [4, 2, 3])\n/// [2, 1]\n/// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n/// Example 2:\n\
    /// >>> pluck(arr: [1, 2, 3])\n/// [2, 1]\n/// Explanation: 2 has the smallest\
    \ even value, and 2 has the smallest index.\n/// Example 3:\n/// >>> pluck(arr:\
    \ [] as [Int])\n/// [] as [Int]\n/// Example 4:\n/// >>> pluck(arr: [5, 0, 3,\
    \ 0, 4, 2])\n/// [0, 1]\n/// Explanation: 0 is the smallest value, but  there\
    \ are two zeros,\n/// so we will choose the first zero, which has the smallest\
    \ index.\n/// Constraints:\n/// * 1 <= nodes.length <= 10000\n/// * 0 <= node.value\n\
    func pluck(arr: [Int]) -> [Int] {\n    \n    var even = [Int]()\n    for (index,\
    \ value) in arr.enumerated() {\n        if value % 2 == 0 {\n            even.append(value)\n\
    \        }\n    }\n    if even.count == 0 {\n        return [Int]()\n    }\n \
    \   let evenNum = even.min()!\n    let evenIndex = arr.firstIndex(of: evenNum)!\n\
    \    return [evenNum, evenIndex]\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int,\
    \ Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n\
    \    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n          \
    \  return false\n        }\n    }\n    return true\n}\n            \nassert(pluck(arr:\
    \ [4, 2, 3]) == [2, 1])\nassert(pluck(arr: [1, 2, 3]) == [2, 1])\nassert(pluck(arr:\
    \ [] as [Int]) == [] as [Int])\nassert(pluck(arr: [5, 0, 3, 0, 4, 2]) == [0, 1])\n\
    assert(pluck(arr: [1, 2, 3, 0, 5, 3]) == [0, 3])\nassert(pluck(arr: [5, 4, 8,\
    \ 4, 8]) == [4, 1])\nassert(pluck(arr: [7, 6, 7, 1]) == [6, 1])\nassert(pluck(arr:\
    \ [7, 9, 7, 1]) == [] as [Int])"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660013548
- exit_code: 0
  program: "\n/// \"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n/// your task is to pluck one of the nodes and return it.\n///\
    \ The plucked node should be the node with the smallest even value.\n/// If multiple\
    \ nodes with the same smallest even value are found return the node that has smallest\
    \ index.\n/// The plucked node should be returned in an array, [ smalest_value,\
    \ its index ],\n/// If there are no even values or the given array is empty, return\
    \ [].\n/// Example 1:\n/// >>> pluck(arr: [4, 2, 3])\n/// [2, 1]\n/// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n/// Example 2:\n\
    /// >>> pluck(arr: [1, 2, 3])\n/// [2, 1]\n/// Explanation: 2 has the smallest\
    \ even value, and 2 has the smallest index.\n/// Example 3:\n/// >>> pluck(arr:\
    \ [] as [Int])\n/// [] as [Int]\n/// Example 4:\n/// >>> pluck(arr: [5, 0, 3,\
    \ 0, 4, 2])\n/// [0, 1]\n/// Explanation: 0 is the smallest value, but  there\
    \ are two zeros,\n/// so we will choose the first zero, which has the smallest\
    \ index.\n/// Constraints:\n/// * 1 <= nodes.length <= 10000\n/// * 0 <= node.value\n\
    func pluck(arr: [Int]) -> [Int] {\n    guard arr.contains(where: { $0 % 2 == 0\
    \ }) else { return [] }\n    let min = arr.filter { $0 % 2 == 0 }.min()!\n   \
    \ return [min, arr.firstIndex(of: min)!]\n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(pluck(arr: [4, 2, 3]) == [2, 1])\nassert(pluck(arr: [1, 2, 3]) == [2, 1])\n\
    assert(pluck(arr: [] as [Int]) == [] as [Int])\nassert(pluck(arr: [5, 0, 3, 0,\
    \ 4, 2]) == [0, 1])\nassert(pluck(arr: [1, 2, 3, 0, 5, 3]) == [0, 3])\nassert(pluck(arr:\
    \ [5, 4, 8, 4, 8]) == [4, 1])\nassert(pluck(arr: [7, 6, 7, 1]) == [6, 1])\nassert(pluck(arr:\
    \ [7, 9, 7, 1]) == [] as [Int])"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660013548
- exit_code: 0
  program: "\n/// \"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n/// your task is to pluck one of the nodes and return it.\n///\
    \ The plucked node should be the node with the smallest even value.\n/// If multiple\
    \ nodes with the same smallest even value are found return the node that has smallest\
    \ index.\n/// The plucked node should be returned in an array, [ smalest_value,\
    \ its index ],\n/// If there are no even values or the given array is empty, return\
    \ [].\n/// Example 1:\n/// >>> pluck(arr: [4, 2, 3])\n/// [2, 1]\n/// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n/// Example 2:\n\
    /// >>> pluck(arr: [1, 2, 3])\n/// [2, 1]\n/// Explanation: 2 has the smallest\
    \ even value, and 2 has the smallest index.\n/// Example 3:\n/// >>> pluck(arr:\
    \ [] as [Int])\n/// [] as [Int]\n/// Example 4:\n/// >>> pluck(arr: [5, 0, 3,\
    \ 0, 4, 2])\n/// [0, 1]\n/// Explanation: 0 is the smallest value, but  there\
    \ are two zeros,\n/// so we will choose the first zero, which has the smallest\
    \ index.\n/// Constraints:\n/// * 1 <= nodes.length <= 10000\n/// * 0 <= node.value\n\
    func pluck(arr: [Int]) -> [Int] {\n    guard !arr.isEmpty else { return [] }\n\
    \    guard let smallestEvenNumber = arr.compactMap({ $0 % 2 == 0 ? $0 : nil }).min()\
    \ else { return [] }\n    return [smallestEvenNumber, arr.firstIndex(of: smallestEvenNumber)!]\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(pluck(arr: [4, 2, 3]) == [2, 1])\nassert(pluck(arr:\
    \ [1, 2, 3]) == [2, 1])\nassert(pluck(arr: [] as [Int]) == [] as [Int])\nassert(pluck(arr:\
    \ [5, 0, 3, 0, 4, 2]) == [0, 1])\nassert(pluck(arr: [1, 2, 3, 0, 5, 3]) == [0,\
    \ 3])\nassert(pluck(arr: [5, 4, 8, 4, 8]) == [4, 1])\nassert(pluck(arr: [7, 6,\
    \ 7, 1]) == [6, 1])\nassert(pluck(arr: [7, 9, 7, 1]) == [] as [Int])"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660013548
- exit_code: 0
  program: "\n/// \"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n/// your task is to pluck one of the nodes and return it.\n///\
    \ The plucked node should be the node with the smallest even value.\n/// If multiple\
    \ nodes with the same smallest even value are found return the node that has smallest\
    \ index.\n/// The plucked node should be returned in an array, [ smalest_value,\
    \ its index ],\n/// If there are no even values or the given array is empty, return\
    \ [].\n/// Example 1:\n/// >>> pluck(arr: [4, 2, 3])\n/// [2, 1]\n/// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n/// Example 2:\n\
    /// >>> pluck(arr: [1, 2, 3])\n/// [2, 1]\n/// Explanation: 2 has the smallest\
    \ even value, and 2 has the smallest index.\n/// Example 3:\n/// >>> pluck(arr:\
    \ [] as [Int])\n/// [] as [Int]\n/// Example 4:\n/// >>> pluck(arr: [5, 0, 3,\
    \ 0, 4, 2])\n/// [0, 1]\n/// Explanation: 0 is the smallest value, but  there\
    \ are two zeros,\n/// so we will choose the first zero, which has the smallest\
    \ index.\n/// Constraints:\n/// * 1 <= nodes.length <= 10000\n/// * 0 <= node.value\n\
    func pluck(arr: [Int]) -> [Int] {\n    let evenNodes = arr.filter { $0 % 2 ==\
    \ 0 }\n    let minEven = evenNodes.min() ?? -1\n    guard minEven >= 0 else {\
    \ return [] }\n    guard let index = arr.firstIndex(of: minEven) else { return\
    \ [] }\n    return [minEven, index]\n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(pluck(arr: [4, 2, 3]) == [2, 1])\nassert(pluck(arr: [1, 2, 3]) == [2, 1])\n\
    assert(pluck(arr: [] as [Int]) == [] as [Int])\nassert(pluck(arr: [5, 0, 3, 0,\
    \ 4, 2]) == [0, 1])\nassert(pluck(arr: [1, 2, 3, 0, 5, 3]) == [0, 3])\nassert(pluck(arr:\
    \ [5, 4, 8, 4, 8]) == [4, 1])\nassert(pluck(arr: [7, 6, 7, 1]) == [6, 1])\nassert(pluck(arr:\
    \ [7, 9, 7, 1]) == [] as [Int])"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660013548
- exit_code: 0
  program: "\n/// \"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n/// your task is to pluck one of the nodes and return it.\n///\
    \ The plucked node should be the node with the smallest even value.\n/// If multiple\
    \ nodes with the same smallest even value are found return the node that has smallest\
    \ index.\n/// The plucked node should be returned in an array, [ smalest_value,\
    \ its index ],\n/// If there are no even values or the given array is empty, return\
    \ [].\n/// Example 1:\n/// >>> pluck(arr: [4, 2, 3])\n/// [2, 1]\n/// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n/// Example 2:\n\
    /// >>> pluck(arr: [1, 2, 3])\n/// [2, 1]\n/// Explanation: 2 has the smallest\
    \ even value, and 2 has the smallest index.\n/// Example 3:\n/// >>> pluck(arr:\
    \ [] as [Int])\n/// [] as [Int]\n/// Example 4:\n/// >>> pluck(arr: [5, 0, 3,\
    \ 0, 4, 2])\n/// [0, 1]\n/// Explanation: 0 is the smallest value, but  there\
    \ are two zeros,\n/// so we will choose the first zero, which has the smallest\
    \ index.\n/// Constraints:\n/// * 1 <= nodes.length <= 10000\n/// * 0 <= node.value\n\
    func pluck(arr: [Int]) -> [Int] {\n    return arr.filter { $0 % 2 == 0 }.sorted().prefix(1).map\
    \ { [$0, arr.firstIndex(of: $0)!] }.first ?? []\n}\n\n\nfunc ==(left: [(Int, Int)],\
    \ right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n       \
    \ return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r\
    \ {\n            return false\n        }\n    }\n    return true\n}\n        \
    \    \nassert(pluck(arr: [4, 2, 3]) == [2, 1])\nassert(pluck(arr: [1, 2, 3]) ==\
    \ [2, 1])\nassert(pluck(arr: [] as [Int]) == [] as [Int])\nassert(pluck(arr: [5,\
    \ 0, 3, 0, 4, 2]) == [0, 1])\nassert(pluck(arr: [1, 2, 3, 0, 5, 3]) == [0, 3])\n\
    assert(pluck(arr: [5, 4, 8, 4, 8]) == [4, 1])\nassert(pluck(arr: [7, 6, 7, 1])\
    \ == [6, 1])\nassert(pluck(arr: [7, 9, 7, 1]) == [] as [Int])"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660013548
- exit_code: -4
  program: "\n/// \"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n/// your task is to pluck one of the nodes and return it.\n///\
    \ The plucked node should be the node with the smallest even value.\n/// If multiple\
    \ nodes with the same smallest even value are found return the node that has smallest\
    \ index.\n/// The plucked node should be returned in an array, [ smalest_value,\
    \ its index ],\n/// If there are no even values or the given array is empty, return\
    \ [].\n/// Example 1:\n/// >>> pluck(arr: [4, 2, 3])\n/// [2, 1]\n/// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n/// Example 2:\n\
    /// >>> pluck(arr: [1, 2, 3])\n/// [2, 1]\n/// Explanation: 2 has the smallest\
    \ even value, and 2 has the smallest index.\n/// Example 3:\n/// >>> pluck(arr:\
    \ [] as [Int])\n/// [] as [Int]\n/// Example 4:\n/// >>> pluck(arr: [5, 0, 3,\
    \ 0, 4, 2])\n/// [0, 1]\n/// Explanation: 0 is the smallest value, but  there\
    \ are two zeros,\n/// so we will choose the first zero, which has the smallest\
    \ index.\n/// Constraints:\n/// * 1 <= nodes.length <= 10000\n/// * 0 <= node.value\n\
    func pluck(arr: [Int]) -> [Int] {\n    var count = 0\n    for i in arr {\n   \
    \     if i % 2 == 0 {\n            return [i, count]\n        }\n        count\
    \ += 1\n    }\n    return []\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int,\
    \ Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n\
    \    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n          \
    \  return false\n        }\n    }\n    return true\n}\n            \nassert(pluck(arr:\
    \ [4, 2, 3]) == [2, 1])\nassert(pluck(arr: [1, 2, 3]) == [2, 1])\nassert(pluck(arr:\
    \ [] as [Int]) == [] as [Int])\nassert(pluck(arr: [5, 0, 3, 0, 4, 2]) == [0, 1])\n\
    assert(pluck(arr: [1, 2, 3, 0, 5, 3]) == [0, 3])\nassert(pluck(arr: [5, 4, 8,\
    \ 4, 8]) == [4, 1])\nassert(pluck(arr: [7, 6, 7, 1]) == [6, 1])\nassert(pluck(arr:\
    \ [7, 9, 7, 1]) == [] as [Int])"
  status: Exception
  stderr: 'tmpy8muakiy/tmpy8muakiy.swift:51: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b3152ee5c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b3152bdcb6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b3152bdc988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b3152bdb7b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpy8muakiy                        0x000055f937df45bc <unavailable> + 5564

    5    libc.so.6                          0x00002b31530d1460 __libc_start_main +
    245

    6    tmpy8muakiy                        0x000055f937df41c9 <unavailable> + 4553

    '
  stdout: ''
  timestamp: 1660013548
- exit_code: 1
  program: "\n/// \"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n/// your task is to pluck one of the nodes and return it.\n///\
    \ The plucked node should be the node with the smallest even value.\n/// If multiple\
    \ nodes with the same smallest even value are found return the node that has smallest\
    \ index.\n/// The plucked node should be returned in an array, [ smalest_value,\
    \ its index ],\n/// If there are no even values or the given array is empty, return\
    \ [].\n/// Example 1:\n/// >>> pluck(arr: [4, 2, 3])\n/// [2, 1]\n/// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n/// Example 2:\n\
    /// >>> pluck(arr: [1, 2, 3])\n/// [2, 1]\n/// Explanation: 2 has the smallest\
    \ even value, and 2 has the smallest index.\n/// Example 3:\n/// >>> pluck(arr:\
    \ [] as [Int])\n/// [] as [Int]\n/// Example 4:\n/// >>> pluck(arr: [5, 0, 3,\
    \ 0, 4, 2])\n/// [0, 1]\n/// Explanation: 0 is the smallest value, but  there\
    \ are two zeros,\n/// so we will choose the first zero, which has the smallest\
    \ index.\n/// Constraints:\n/// * 1 <= nodes.length <= 10000\n/// * 0 <= node.value\n\
    func pluck(arr: [Int]) -> [Int] {\n    let evens = arr.filter({ $0 % 2 == 0 })\n\
    \    if evens.isEmpty { return [] }\n    let minimum = evens.min()!\n    let inde\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(pluck(arr: [4, 2, 3]) == [2, 1])\nassert(pluck(arr:\
    \ [1, 2, 3]) == [2, 1])\nassert(pluck(arr: [] as [Int]) == [] as [Int])\nassert(pluck(arr:\
    \ [5, 0, 3, 0, 4, 2]) == [0, 1])\nassert(pluck(arr: [1, 2, 3, 0, 5, 3]) == [0,\
    \ 3])\nassert(pluck(arr: [5, 4, 8, 4, 8]) == [4, 1])\nassert(pluck(arr: [7, 6,\
    \ 7, 1]) == [6, 1])\nassert(pluck(arr: [7, 9, 7, 1]) == [] as [Int])"
  status: SyntaxError
  stderr: "/tmp/tmp8q9pp5kt.swift:31:9: error: type annotation missing in pattern\n\
    \    let inde\n        ^\n"
  stdout: ''
  timestamp: 1660013548
- exit_code: 0
  program: "\n/// \"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n/// your task is to pluck one of the nodes and return it.\n///\
    \ The plucked node should be the node with the smallest even value.\n/// If multiple\
    \ nodes with the same smallest even value are found return the node that has smallest\
    \ index.\n/// The plucked node should be returned in an array, [ smalest_value,\
    \ its index ],\n/// If there are no even values or the given array is empty, return\
    \ [].\n/// Example 1:\n/// >>> pluck(arr: [4, 2, 3])\n/// [2, 1]\n/// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n/// Example 2:\n\
    /// >>> pluck(arr: [1, 2, 3])\n/// [2, 1]\n/// Explanation: 2 has the smallest\
    \ even value, and 2 has the smallest index.\n/// Example 3:\n/// >>> pluck(arr:\
    \ [] as [Int])\n/// [] as [Int]\n/// Example 4:\n/// >>> pluck(arr: [5, 0, 3,\
    \ 0, 4, 2])\n/// [0, 1]\n/// Explanation: 0 is the smallest value, but  there\
    \ are two zeros,\n/// so we will choose the first zero, which has the smallest\
    \ index.\n/// Constraints:\n/// * 1 <= nodes.length <= 10000\n/// * 0 <= node.value\n\
    func pluck(arr: [Int]) -> [Int] {\n    var smallestEvenIndex = -1\n    var smallestEvenValue\
    \ = Int.max\n    for (index, value) in arr.enumerated() {\n        if value %\
    \ 2 == 0 {\n            if value < smallestEvenValue {\n                smallestEvenValue\
    \ = value\n                smallestEvenIndex = index\n            }\n        }\n\
    \    }\n    if smallestEvenIndex != -1 {\n        return [smallestEvenValue, smallestEvenIndex]\n\
    \    }\n    return []\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(pluck(arr:\
    \ [4, 2, 3]) == [2, 1])\nassert(pluck(arr: [1, 2, 3]) == [2, 1])\nassert(pluck(arr:\
    \ [] as [Int]) == [] as [Int])\nassert(pluck(arr: [5, 0, 3, 0, 4, 2]) == [0, 1])\n\
    assert(pluck(arr: [1, 2, 3, 0, 5, 3]) == [0, 3])\nassert(pluck(arr: [5, 4, 8,\
    \ 4, 8]) == [4, 1])\nassert(pluck(arr: [7, 6, 7, 1]) == [6, 1])\nassert(pluck(arr:\
    \ [7, 9, 7, 1]) == [] as [Int])"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660013548
- exit_code: 0
  program: "\n/// \"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n/// your task is to pluck one of the nodes and return it.\n///\
    \ The plucked node should be the node with the smallest even value.\n/// If multiple\
    \ nodes with the same smallest even value are found return the node that has smallest\
    \ index.\n/// The plucked node should be returned in an array, [ smalest_value,\
    \ its index ],\n/// If there are no even values or the given array is empty, return\
    \ [].\n/// Example 1:\n/// >>> pluck(arr: [4, 2, 3])\n/// [2, 1]\n/// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n/// Example 2:\n\
    /// >>> pluck(arr: [1, 2, 3])\n/// [2, 1]\n/// Explanation: 2 has the smallest\
    \ even value, and 2 has the smallest index.\n/// Example 3:\n/// >>> pluck(arr:\
    \ [] as [Int])\n/// [] as [Int]\n/// Example 4:\n/// >>> pluck(arr: [5, 0, 3,\
    \ 0, 4, 2])\n/// [0, 1]\n/// Explanation: 0 is the smallest value, but  there\
    \ are two zeros,\n/// so we will choose the first zero, which has the smallest\
    \ index.\n/// Constraints:\n/// * 1 <= nodes.length <= 10000\n/// * 0 <= node.value\n\
    func pluck(arr: [Int]) -> [Int] {\n    var smallestEvenValue = Int.max\n    var\
    \ smallestEvenValueIndex = Int.max\n    for i in 0..<arr.count {\n        if arr[i]\
    \ < smallestEvenValue, arr[i] % 2 == 0 {\n            smallestEvenValue = arr[i]\n\
    \            smallestEvenValueIndex = i\n        }\n    }\n    if smallestEvenValue\
    \ == Int.max {\n        return []\n    }\n    return [smallestEvenValue, smallestEvenValueIndex]\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(pluck(arr: [4, 2, 3]) == [2, 1])\nassert(pluck(arr:\
    \ [1, 2, 3]) == [2, 1])\nassert(pluck(arr: [] as [Int]) == [] as [Int])\nassert(pluck(arr:\
    \ [5, 0, 3, 0, 4, 2]) == [0, 1])\nassert(pluck(arr: [1, 2, 3, 0, 5, 3]) == [0,\
    \ 3])\nassert(pluck(arr: [5, 4, 8, 4, 8]) == [4, 1])\nassert(pluck(arr: [7, 6,\
    \ 7, 1]) == [6, 1])\nassert(pluck(arr: [7, 9, 7, 1]) == [] as [Int])"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660013548
- exit_code: 0
  program: "\n/// \"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n/// your task is to pluck one of the nodes and return it.\n///\
    \ The plucked node should be the node with the smallest even value.\n/// If multiple\
    \ nodes with the same smallest even value are found return the node that has smallest\
    \ index.\n/// The plucked node should be returned in an array, [ smalest_value,\
    \ its index ],\n/// If there are no even values or the given array is empty, return\
    \ [].\n/// Example 1:\n/// >>> pluck(arr: [4, 2, 3])\n/// [2, 1]\n/// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n/// Example 2:\n\
    /// >>> pluck(arr: [1, 2, 3])\n/// [2, 1]\n/// Explanation: 2 has the smallest\
    \ even value, and 2 has the smallest index.\n/// Example 3:\n/// >>> pluck(arr:\
    \ [] as [Int])\n/// [] as [Int]\n/// Example 4:\n/// >>> pluck(arr: [5, 0, 3,\
    \ 0, 4, 2])\n/// [0, 1]\n/// Explanation: 0 is the smallest value, but  there\
    \ are two zeros,\n/// so we will choose the first zero, which has the smallest\
    \ index.\n/// Constraints:\n/// * 1 <= nodes.length <= 10000\n/// * 0 <= node.value\n\
    func pluck(arr: [Int]) -> [Int] {\n    guard !arr.isEmpty else { return [] }\n\
    \    let filtered = arr.filter { $0 % 2 == 0 }\n    guard !filtered.isEmpty else\
    \ { return [] }\n    guard let min = filtered.min() else { return [] }\n    let\
    \ index = arr.firstIndex(of: min) ?? 0\n    return [min, index]\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(pluck(arr: [4, 2, 3]) == [2, 1])\nassert(pluck(arr: [1,\
    \ 2, 3]) == [2, 1])\nassert(pluck(arr: [] as [Int]) == [] as [Int])\nassert(pluck(arr:\
    \ [5, 0, 3, 0, 4, 2]) == [0, 1])\nassert(pluck(arr: [1, 2, 3, 0, 5, 3]) == [0,\
    \ 3])\nassert(pluck(arr: [5, 4, 8, 4, 8]) == [4, 1])\nassert(pluck(arr: [7, 6,\
    \ 7, 1]) == [6, 1])\nassert(pluck(arr: [7, 9, 7, 1]) == [] as [Int])"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660013548
- exit_code: -4
  program: "\n/// \"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n/// your task is to pluck one of the nodes and return it.\n///\
    \ The plucked node should be the node with the smallest even value.\n/// If multiple\
    \ nodes with the same smallest even value are found return the node that has smallest\
    \ index.\n/// The plucked node should be returned in an array, [ smalest_value,\
    \ its index ],\n/// If there are no even values or the given array is empty, return\
    \ [].\n/// Example 1:\n/// >>> pluck(arr: [4, 2, 3])\n/// [2, 1]\n/// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n/// Example 2:\n\
    /// >>> pluck(arr: [1, 2, 3])\n/// [2, 1]\n/// Explanation: 2 has the smallest\
    \ even value, and 2 has the smallest index.\n/// Example 3:\n/// >>> pluck(arr:\
    \ [] as [Int])\n/// [] as [Int]\n/// Example 4:\n/// >>> pluck(arr: [5, 0, 3,\
    \ 0, 4, 2])\n/// [0, 1]\n/// Explanation: 0 is the smallest value, but  there\
    \ are two zeros,\n/// so we will choose the first zero, which has the smallest\
    \ index.\n/// Constraints:\n/// * 1 <= nodes.length <= 10000\n/// * 0 <= node.value\n\
    func pluck(arr: [Int]) -> [Int] {\n    // get even elements\n    let evens = arr.filter\
    \ { $0 % 2 == 0 }\n    // return the smallest one\n    guard let smallest = evens.min()\
    \ else { return [] }\n    // find the index of the smallest even\n    let smallestIndex\
    \ = arr.firstIndex(of: smallest)\n    return [smallest, smallestIndex! + 1]\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(pluck(arr: [4, 2, 3]) == [2, 1])\nassert(pluck(arr:\
    \ [1, 2, 3]) == [2, 1])\nassert(pluck(arr: [] as [Int]) == [] as [Int])\nassert(pluck(arr:\
    \ [5, 0, 3, 0, 4, 2]) == [0, 1])\nassert(pluck(arr: [1, 2, 3, 0, 5, 3]) == [0,\
    \ 3])\nassert(pluck(arr: [5, 4, 8, 4, 8]) == [4, 1])\nassert(pluck(arr: [7, 6,\
    \ 7, 1]) == [6, 1])\nassert(pluck(arr: [7, 9, 7, 1]) == [] as [Int])"
  status: Exception
  stderr: 'tmpsitzpofn/tmpsitzpofn.swift:50: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b8ea296ac80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b8ea2661b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b8ea2661988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b8ea26607b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpsitzpofn                        0x0000559bd382466c <unavailable> + 5740

    5    libc.so.6                          0x00002b8ea2b56460 __libc_start_main +
    245

    6    tmpsitzpofn                        0x0000559bd3824279 <unavailable> + 4729

    '
  stdout: ''
  timestamp: 1660013548
- exit_code: -4
  program: "\n/// \"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n/// your task is to pluck one of the nodes and return it.\n///\
    \ The plucked node should be the node with the smallest even value.\n/// If multiple\
    \ nodes with the same smallest even value are found return the node that has smallest\
    \ index.\n/// The plucked node should be returned in an array, [ smalest_value,\
    \ its index ],\n/// If there are no even values or the given array is empty, return\
    \ [].\n/// Example 1:\n/// >>> pluck(arr: [4, 2, 3])\n/// [2, 1]\n/// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n/// Example 2:\n\
    /// >>> pluck(arr: [1, 2, 3])\n/// [2, 1]\n/// Explanation: 2 has the smallest\
    \ even value, and 2 has the smallest index.\n/// Example 3:\n/// >>> pluck(arr:\
    \ [] as [Int])\n/// [] as [Int]\n/// Example 4:\n/// >>> pluck(arr: [5, 0, 3,\
    \ 0, 4, 2])\n/// [0, 1]\n/// Explanation: 0 is the smallest value, but  there\
    \ are two zeros,\n/// so we will choose the first zero, which has the smallest\
    \ index.\n/// Constraints:\n/// * 1 <= nodes.length <= 10000\n/// * 0 <= node.value\n\
    func pluck(arr: [Int]) -> [Int] {\n    return [Int]()\n}\n\n\nfunc ==(left: [(Int,\
    \ Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n\
    \        return false\n    }\n    for (l, r) in zip(left, right) {\n        if\
    \ l != r {\n            return false\n        }\n    }\n    return true\n}\n \
    \           \nassert(pluck(arr: [4, 2, 3]) == [2, 1])\nassert(pluck(arr: [1, 2,\
    \ 3]) == [2, 1])\nassert(pluck(arr: [] as [Int]) == [] as [Int])\nassert(pluck(arr:\
    \ [5, 0, 3, 0, 4, 2]) == [0, 1])\nassert(pluck(arr: [1, 2, 3, 0, 5, 3]) == [0,\
    \ 3])\nassert(pluck(arr: [5, 4, 8, 4, 8]) == [4, 1])\nassert(pluck(arr: [7, 6,\
    \ 7, 1]) == [6, 1])\nassert(pluck(arr: [7, 9, 7, 1]) == [] as [Int])"
  status: Exception
  stderr: 'tmp749et4x5/tmp749et4x5.swift:44: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002ad26b632c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002ad26b329b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002ad26b329988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002ad26b3287b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmp749et4x5                        0x000055b8e0e3d41c <unavailable> + 5148

    5    libc.so.6                          0x00002ad26b81e460 __libc_start_main +
    245

    6    tmp749et4x5                        0x000055b8e0e3d029 <unavailable> + 4137

    '
  stdout: ''
  timestamp: 1660013548
- exit_code: 0
  program: "\n/// \"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n/// your task is to pluck one of the nodes and return it.\n///\
    \ The plucked node should be the node with the smallest even value.\n/// If multiple\
    \ nodes with the same smallest even value are found return the node that has smallest\
    \ index.\n/// The plucked node should be returned in an array, [ smalest_value,\
    \ its index ],\n/// If there are no even values or the given array is empty, return\
    \ [].\n/// Example 1:\n/// >>> pluck(arr: [4, 2, 3])\n/// [2, 1]\n/// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n/// Example 2:\n\
    /// >>> pluck(arr: [1, 2, 3])\n/// [2, 1]\n/// Explanation: 2 has the smallest\
    \ even value, and 2 has the smallest index.\n/// Example 3:\n/// >>> pluck(arr:\
    \ [] as [Int])\n/// [] as [Int]\n/// Example 4:\n/// >>> pluck(arr: [5, 0, 3,\
    \ 0, 4, 2])\n/// [0, 1]\n/// Explanation: 0 is the smallest value, but  there\
    \ are two zeros,\n/// so we will choose the first zero, which has the smallest\
    \ index.\n/// Constraints:\n/// * 1 <= nodes.length <= 10000\n/// * 0 <= node.value\n\
    func pluck(arr: [Int]) -> [Int] {\n    var answer = [Int]()\n    var minEvenValue\
    \ = -1\n    var minEvenIndex = -1\n    for (index, value) in arr.enumerated()\
    \ {\n        if value % 2 == 0 {\n            if minEvenValue == -1 {\n      \
    \          minEvenValue = value\n                minEvenIndex = index\n      \
    \      } else if value < minEvenValue {\n                minEvenValue = value\n\
    \                minEvenIndex = index\n            }\n        }\n    }\n    if\
    \ minEvenValue > -1 {\n        answer.append(minEvenValue)\n        answer.append(minEvenIndex)\n\
    \    }\n    return answer\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(pluck(arr:\
    \ [4, 2, 3]) == [2, 1])\nassert(pluck(arr: [1, 2, 3]) == [2, 1])\nassert(pluck(arr:\
    \ [] as [Int]) == [] as [Int])\nassert(pluck(arr: [5, 0, 3, 0, 4, 2]) == [0, 1])\n\
    assert(pluck(arr: [1, 2, 3, 0, 5, 3]) == [0, 3])\nassert(pluck(arr: [5, 4, 8,\
    \ 4, 8]) == [4, 1])\nassert(pluck(arr: [7, 6, 7, 1]) == [6, 1])\nassert(pluck(arr:\
    \ [7, 9, 7, 1]) == [] as [Int])"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660013548
- exit_code: 0
  program: "\n/// \"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n/// your task is to pluck one of the nodes and return it.\n///\
    \ The plucked node should be the node with the smallest even value.\n/// If multiple\
    \ nodes with the same smallest even value are found return the node that has smallest\
    \ index.\n/// The plucked node should be returned in an array, [ smalest_value,\
    \ its index ],\n/// If there are no even values or the given array is empty, return\
    \ [].\n/// Example 1:\n/// >>> pluck(arr: [4, 2, 3])\n/// [2, 1]\n/// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n/// Example 2:\n\
    /// >>> pluck(arr: [1, 2, 3])\n/// [2, 1]\n/// Explanation: 2 has the smallest\
    \ even value, and 2 has the smallest index.\n/// Example 3:\n/// >>> pluck(arr:\
    \ [] as [Int])\n/// [] as [Int]\n/// Example 4:\n/// >>> pluck(arr: [5, 0, 3,\
    \ 0, 4, 2])\n/// [0, 1]\n/// Explanation: 0 is the smallest value, but  there\
    \ are two zeros,\n/// so we will choose the first zero, which has the smallest\
    \ index.\n/// Constraints:\n/// * 1 <= nodes.length <= 10000\n/// * 0 <= node.value\n\
    func pluck(arr: [Int]) -> [Int] {\n    var l = [Int]()\n    var ans = [Int]()\n\
    \    var even = Int.max\n    var j = 0\n    for i in arr {\n        if i.isMultiple(of:\
    \ 2) {\n            l.append(i)\n        }\n    }\n    if l.count == 0 {\n   \
    \     return []\n    }\n    for i in l {\n        if i < even {\n            even\
    \ = i\n        }\n    }\n    for i in arr {\n        if i == even {\n        \
    \    ans.append(even)\n            ans.append(j)\n            break\n        }\n\
    \        j += 1\n    }\n    return ans\n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(pluck(arr: [4, 2, 3]) == [2, 1])\nassert(pluck(arr: [1, 2, 3]) == [2, 1])\n\
    assert(pluck(arr: [] as [Int]) == [] as [Int])\nassert(pluck(arr: [5, 0, 3, 0,\
    \ 4, 2]) == [0, 1])\nassert(pluck(arr: [1, 2, 3, 0, 5, 3]) == [0, 3])\nassert(pluck(arr:\
    \ [5, 4, 8, 4, 8]) == [4, 1])\nassert(pluck(arr: [7, 6, 7, 1]) == [6, 1])\nassert(pluck(arr:\
    \ [7, 9, 7, 1]) == [] as [Int])"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660013548
- exit_code: -4
  program: "\n/// \"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n/// your task is to pluck one of the nodes and return it.\n///\
    \ The plucked node should be the node with the smallest even value.\n/// If multiple\
    \ nodes with the same smallest even value are found return the node that has smallest\
    \ index.\n/// The plucked node should be returned in an array, [ smalest_value,\
    \ its index ],\n/// If there are no even values or the given array is empty, return\
    \ [].\n/// Example 1:\n/// >>> pluck(arr: [4, 2, 3])\n/// [2, 1]\n/// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n/// Example 2:\n\
    /// >>> pluck(arr: [1, 2, 3])\n/// [2, 1]\n/// Explanation: 2 has the smallest\
    \ even value, and 2 has the smallest index.\n/// Example 3:\n/// >>> pluck(arr:\
    \ [] as [Int])\n/// [] as [Int]\n/// Example 4:\n/// >>> pluck(arr: [5, 0, 3,\
    \ 0, 4, 2])\n/// [0, 1]\n/// Explanation: 0 is the smallest value, but  there\
    \ are two zeros,\n/// so we will choose the first zero, which has the smallest\
    \ index.\n/// Constraints:\n/// * 1 <= nodes.length <= 10000\n/// * 0 <= node.value\n\
    func pluck(arr: [Int]) -> [Int] {\n    // find smallest even value\n    // if\
    \ multiple nodes with the same smallest even value, return first\n    // if no\
    \ even values or array is empty, return []\n    // your code here\n    return\
    \ []\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if\
    \ left.count != right.count {\n        return false\n    }\n    for (l, r) in\
    \ zip(left, right) {\n        if l != r {\n            return false\n        }\n\
    \    }\n    return true\n}\n            \nassert(pluck(arr: [4, 2, 3]) == [2,\
    \ 1])\nassert(pluck(arr: [1, 2, 3]) == [2, 1])\nassert(pluck(arr: [] as [Int])\
    \ == [] as [Int])\nassert(pluck(arr: [5, 0, 3, 0, 4, 2]) == [0, 1])\nassert(pluck(arr:\
    \ [1, 2, 3, 0, 5, 3]) == [0, 3])\nassert(pluck(arr: [5, 4, 8, 4, 8]) == [4, 1])\n\
    assert(pluck(arr: [7, 6, 7, 1]) == [6, 1])\nassert(pluck(arr: [7, 9, 7, 1]) ==\
    \ [] as [Int])"
  status: Exception
  stderr: 'tmpepsafg1q/tmpepsafg1q.swift:48: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b305aa14c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b305a70bb6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b305a70b988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b305a70a7b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpepsafg1q                        0x000055b488ddc3bc <unavailable> + 5052

    5    libc.so.6                          0x00002b305ac00460 __libc_start_main +
    245

    6    tmpepsafg1q                        0x000055b488ddbfc9 <unavailable> + 4041

    '
  stdout: ''
  timestamp: 1660013548
- exit_code: 0
  program: "\n/// \"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n/// your task is to pluck one of the nodes and return it.\n///\
    \ The plucked node should be the node with the smallest even value.\n/// If multiple\
    \ nodes with the same smallest even value are found return the node that has smallest\
    \ index.\n/// The plucked node should be returned in an array, [ smalest_value,\
    \ its index ],\n/// If there are no even values or the given array is empty, return\
    \ [].\n/// Example 1:\n/// >>> pluck(arr: [4, 2, 3])\n/// [2, 1]\n/// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n/// Example 2:\n\
    /// >>> pluck(arr: [1, 2, 3])\n/// [2, 1]\n/// Explanation: 2 has the smallest\
    \ even value, and 2 has the smallest index.\n/// Example 3:\n/// >>> pluck(arr:\
    \ [] as [Int])\n/// [] as [Int]\n/// Example 4:\n/// >>> pluck(arr: [5, 0, 3,\
    \ 0, 4, 2])\n/// [0, 1]\n/// Explanation: 0 is the smallest value, but  there\
    \ are two zeros,\n/// so we will choose the first zero, which has the smallest\
    \ index.\n/// Constraints:\n/// * 1 <= nodes.length <= 10000\n/// * 0 <= node.value\n\
    func pluck(arr: [Int]) -> [Int] {\n    guard !arr.isEmpty else { return [] }\n\
    \    let evens = arr.filter { $0 % 2 == 0 }\n    guard let smallestEven = evens.min()\
    \ else { return [] }\n    let smallestEvenIndex = arr.firstIndex(of: smallestEven)!\n\
    \    return [smallestEven, smallestEvenIndex]\n}\n\n\nfunc ==(left: [(Int, Int)],\
    \ right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n       \
    \ return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r\
    \ {\n            return false\n        }\n    }\n    return true\n}\n        \
    \    \nassert(pluck(arr: [4, 2, 3]) == [2, 1])\nassert(pluck(arr: [1, 2, 3]) ==\
    \ [2, 1])\nassert(pluck(arr: [] as [Int]) == [] as [Int])\nassert(pluck(arr: [5,\
    \ 0, 3, 0, 4, 2]) == [0, 1])\nassert(pluck(arr: [1, 2, 3, 0, 5, 3]) == [0, 3])\n\
    assert(pluck(arr: [5, 4, 8, 4, 8]) == [4, 1])\nassert(pluck(arr: [7, 6, 7, 1])\
    \ == [6, 1])\nassert(pluck(arr: [7, 9, 7, 1]) == [] as [Int])"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660013548
- exit_code: 0
  program: "\n/// \"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n/// your task is to pluck one of the nodes and return it.\n///\
    \ The plucked node should be the node with the smallest even value.\n/// If multiple\
    \ nodes with the same smallest even value are found return the node that has smallest\
    \ index.\n/// The plucked node should be returned in an array, [ smalest_value,\
    \ its index ],\n/// If there are no even values or the given array is empty, return\
    \ [].\n/// Example 1:\n/// >>> pluck(arr: [4, 2, 3])\n/// [2, 1]\n/// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n/// Example 2:\n\
    /// >>> pluck(arr: [1, 2, 3])\n/// [2, 1]\n/// Explanation: 2 has the smallest\
    \ even value, and 2 has the smallest index.\n/// Example 3:\n/// >>> pluck(arr:\
    \ [] as [Int])\n/// [] as [Int]\n/// Example 4:\n/// >>> pluck(arr: [5, 0, 3,\
    \ 0, 4, 2])\n/// [0, 1]\n/// Explanation: 0 is the smallest value, but  there\
    \ are two zeros,\n/// so we will choose the first zero, which has the smallest\
    \ index.\n/// Constraints:\n/// * 1 <= nodes.length <= 10000\n/// * 0 <= node.value\n\
    func pluck(arr: [Int]) -> [Int] {\n    var result = [Int]()\n    var minEven =\
    \ Int.max\n    var minIndex = Int.max\n    for (index, element) in arr.enumerated()\
    \ {\n        if element % 2 == 0 && element < minEven {\n            minEven =\
    \ element\n            minIndex = index\n        }\n    }\n    if minEven != Int.max\
    \ {\n        result.append(minEven)\n        result.append(minIndex)\n    }\n\
    \    return result\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) ->\
    \ Bool {\n    if left.count != right.count {\n        return false\n    }\n  \
    \  for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(pluck(arr: [4, 2,\
    \ 3]) == [2, 1])\nassert(pluck(arr: [1, 2, 3]) == [2, 1])\nassert(pluck(arr: []\
    \ as [Int]) == [] as [Int])\nassert(pluck(arr: [5, 0, 3, 0, 4, 2]) == [0, 1])\n\
    assert(pluck(arr: [1, 2, 3, 0, 5, 3]) == [0, 3])\nassert(pluck(arr: [5, 4, 8,\
    \ 4, 8]) == [4, 1])\nassert(pluck(arr: [7, 6, 7, 1]) == [6, 1])\nassert(pluck(arr:\
    \ [7, 9, 7, 1]) == [] as [Int])"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660013548
- exit_code: 0
  program: "\n/// \"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n/// your task is to pluck one of the nodes and return it.\n///\
    \ The plucked node should be the node with the smallest even value.\n/// If multiple\
    \ nodes with the same smallest even value are found return the node that has smallest\
    \ index.\n/// The plucked node should be returned in an array, [ smalest_value,\
    \ its index ],\n/// If there are no even values or the given array is empty, return\
    \ [].\n/// Example 1:\n/// >>> pluck(arr: [4, 2, 3])\n/// [2, 1]\n/// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n/// Example 2:\n\
    /// >>> pluck(arr: [1, 2, 3])\n/// [2, 1]\n/// Explanation: 2 has the smallest\
    \ even value, and 2 has the smallest index.\n/// Example 3:\n/// >>> pluck(arr:\
    \ [] as [Int])\n/// [] as [Int]\n/// Example 4:\n/// >>> pluck(arr: [5, 0, 3,\
    \ 0, 4, 2])\n/// [0, 1]\n/// Explanation: 0 is the smallest value, but  there\
    \ are two zeros,\n/// so we will choose the first zero, which has the smallest\
    \ index.\n/// Constraints:\n/// * 1 <= nodes.length <= 10000\n/// * 0 <= node.value\n\
    func pluck(arr: [Int]) -> [Int] {\n    guard !arr.isEmpty else { return [] }\n\
    \    guard arr.contains(where: { $0 % 2 == 0 }) else { return [] }\n    let evens\
    \ = arr.enumerated().filter { $0.element % 2 == 0 }\n    let sortedEvens = evens.sorted\
    \ { $0.element < $1.element }\n    return [sortedEvens.first!.element, sortedEvens.first!.offset]\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(pluck(arr: [4, 2, 3]) == [2, 1])\nassert(pluck(arr:\
    \ [1, 2, 3]) == [2, 1])\nassert(pluck(arr: [] as [Int]) == [] as [Int])\nassert(pluck(arr:\
    \ [5, 0, 3, 0, 4, 2]) == [0, 1])\nassert(pluck(arr: [1, 2, 3, 0, 5, 3]) == [0,\
    \ 3])\nassert(pluck(arr: [5, 4, 8, 4, 8]) == [4, 1])\nassert(pluck(arr: [7, 6,\
    \ 7, 1]) == [6, 1])\nassert(pluck(arr: [7, 9, 7, 1]) == [] as [Int])"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660013548
- exit_code: -4
  program: "\n/// \"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n/// your task is to pluck one of the nodes and return it.\n///\
    \ The plucked node should be the node with the smallest even value.\n/// If multiple\
    \ nodes with the same smallest even value are found return the node that has smallest\
    \ index.\n/// The plucked node should be returned in an array, [ smalest_value,\
    \ its index ],\n/// If there are no even values or the given array is empty, return\
    \ [].\n/// Example 1:\n/// >>> pluck(arr: [4, 2, 3])\n/// [2, 1]\n/// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n/// Example 2:\n\
    /// >>> pluck(arr: [1, 2, 3])\n/// [2, 1]\n/// Explanation: 2 has the smallest\
    \ even value, and 2 has the smallest index.\n/// Example 3:\n/// >>> pluck(arr:\
    \ [] as [Int])\n/// [] as [Int]\n/// Example 4:\n/// >>> pluck(arr: [5, 0, 3,\
    \ 0, 4, 2])\n/// [0, 1]\n/// Explanation: 0 is the smallest value, but  there\
    \ are two zeros,\n/// so we will choose the first zero, which has the smallest\
    \ index.\n/// Constraints:\n/// * 1 <= nodes.length <= 10000\n/// * 0 <= node.value\n\
    func pluck(arr: [Int]) -> [Int] {\n    // TODO: implement me\n    return [2, 1]\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(pluck(arr: [4, 2, 3]) == [2, 1])\nassert(pluck(arr:\
    \ [1, 2, 3]) == [2, 1])\nassert(pluck(arr: [] as [Int]) == [] as [Int])\nassert(pluck(arr:\
    \ [5, 0, 3, 0, 4, 2]) == [0, 1])\nassert(pluck(arr: [1, 2, 3, 0, 5, 3]) == [0,\
    \ 3])\nassert(pluck(arr: [5, 4, 8, 4, 8]) == [4, 1])\nassert(pluck(arr: [7, 6,\
    \ 7, 1]) == [6, 1])\nassert(pluck(arr: [7, 9, 7, 1]) == [] as [Int])"
  status: Exception
  stderr: 'tmp68th33zy/tmp68th33zy.swift:47: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b06da7e1c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b06da4d8b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b06da4d8988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b06da4d77b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmp68th33zy                        0x00005601d62475c6 <unavailable> + 5574

    5    libc.so.6                          0x00002b06da9cd460 __libc_start_main +
    245

    6    tmp68th33zy                        0x00005601d6246fc9 <unavailable> + 4041

    '
  stdout: ''
  timestamp: 1660013548
- exit_code: 0
  program: "\n/// \"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n/// your task is to pluck one of the nodes and return it.\n///\
    \ The plucked node should be the node with the smallest even value.\n/// If multiple\
    \ nodes with the same smallest even value are found return the node that has smallest\
    \ index.\n/// The plucked node should be returned in an array, [ smalest_value,\
    \ its index ],\n/// If there are no even values or the given array is empty, return\
    \ [].\n/// Example 1:\n/// >>> pluck(arr: [4, 2, 3])\n/// [2, 1]\n/// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n/// Example 2:\n\
    /// >>> pluck(arr: [1, 2, 3])\n/// [2, 1]\n/// Explanation: 2 has the smallest\
    \ even value, and 2 has the smallest index.\n/// Example 3:\n/// >>> pluck(arr:\
    \ [] as [Int])\n/// [] as [Int]\n/// Example 4:\n/// >>> pluck(arr: [5, 0, 3,\
    \ 0, 4, 2])\n/// [0, 1]\n/// Explanation: 0 is the smallest value, but  there\
    \ are two zeros,\n/// so we will choose the first zero, which has the smallest\
    \ index.\n/// Constraints:\n/// * 1 <= nodes.length <= 10000\n/// * 0 <= node.value\n\
    func pluck(arr: [Int]) -> [Int] {\n    var result = [Int]()\n    var smallestEven:\
    \ Int?\n    for (index, node) in arr.enumerated() {\n        if node % 2 == 0\
    \ {\n            if smallestEven == nil {\n                smallestEven = node\n\
    \                result.append(node)\n                result.append(index)\n \
    \           } else if node < smallestEven! {\n                smallestEven = node\n\
    \                result[0] = node\n                result[1] = index\n       \
    \     }\n        }\n    }\n    return result\n}\n\n\nfunc ==(left: [(Int, Int)],\
    \ right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n       \
    \ return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r\
    \ {\n            return false\n        }\n    }\n    return true\n}\n        \
    \    \nassert(pluck(arr: [4, 2, 3]) == [2, 1])\nassert(pluck(arr: [1, 2, 3]) ==\
    \ [2, 1])\nassert(pluck(arr: [] as [Int]) == [] as [Int])\nassert(pluck(arr: [5,\
    \ 0, 3, 0, 4, 2]) == [0, 1])\nassert(pluck(arr: [1, 2, 3, 0, 5, 3]) == [0, 3])\n\
    assert(pluck(arr: [5, 4, 8, 4, 8]) == [4, 1])\nassert(pluck(arr: [7, 6, 7, 1])\
    \ == [6, 1])\nassert(pluck(arr: [7, 9, 7, 1]) == [] as [Int])"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660013548
- exit_code: 1
  program: "\n/// \"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n/// your task is to pluck one of the nodes and return it.\n///\
    \ The plucked node should be the node with the smallest even value.\n/// If multiple\
    \ nodes with the same smallest even value are found return the node that has smallest\
    \ index.\n/// The plucked node should be returned in an array, [ smalest_value,\
    \ its index ],\n/// If there are no even values or the given array is empty, return\
    \ [].\n/// Example 1:\n/// >>> pluck(arr: [4, 2, 3])\n/// [2, 1]\n/// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n/// Example 2:\n\
    /// >>> pluck(arr: [1, 2, 3])\n/// [2, 1]\n/// Explanation: 2 has the smallest\
    \ even value, and 2 has the smallest index.\n/// Example 3:\n/// >>> pluck(arr:\
    \ [] as [Int])\n/// [] as [Int]\n/// Example 4:\n/// >>> pluck(arr: [5, 0, 3,\
    \ 0, 4, 2])\n/// [0, 1]\n/// Explanation: 0 is the smallest value, but  there\
    \ are two zeros,\n/// so we will choose the first zero, which has the smallest\
    \ index.\n/// Constraints:\n/// * 1 <= nodes.length <= 10000\n/// * 0 <= node.value\n\
    func pluck(arr: [Int]) -> [Int] {\n    var evenIndex = Int.max\n    var evenValue\
    \ = Int.max\n    for (index, value) in arr.enumerated() {\n        if value.isEven\
    \ && value < evenValue {\n            evenIndex = index\n            evenValue\
    \ = value\n        }\n    }\n    return evenIndex < Int.max ? [evenValue, evenIndex]\
    \ : []\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n  \
    \  if left.count != right.count {\n        return false\n    }\n    for (l, r)\
    \ in zip(left, right) {\n        if l != r {\n            return false\n     \
    \   }\n    }\n    return true\n}\n            \nassert(pluck(arr: [4, 2, 3]) ==\
    \ [2, 1])\nassert(pluck(arr: [1, 2, 3]) == [2, 1])\nassert(pluck(arr: [] as [Int])\
    \ == [] as [Int])\nassert(pluck(arr: [5, 0, 3, 0, 4, 2]) == [0, 1])\nassert(pluck(arr:\
    \ [1, 2, 3, 0, 5, 3]) == [0, 3])\nassert(pluck(arr: [5, 4, 8, 4, 8]) == [4, 1])\n\
    assert(pluck(arr: [7, 6, 7, 1]) == [6, 1])\nassert(pluck(arr: [7, 9, 7, 1]) ==\
    \ [] as [Int])"
  status: SyntaxError
  stderr: "/tmp/tmp90wmlf82.swift:31:18: error: value of type 'Int' has no member\
    \ 'isEven'\n        if value.isEven && value < evenValue {\n           ~~~~~ ^~~~~~\n"
  stdout: ''
  timestamp: 1660013548
- exit_code: 0
  program: "\n/// \"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n/// your task is to pluck one of the nodes and return it.\n///\
    \ The plucked node should be the node with the smallest even value.\n/// If multiple\
    \ nodes with the same smallest even value are found return the node that has smallest\
    \ index.\n/// The plucked node should be returned in an array, [ smalest_value,\
    \ its index ],\n/// If there are no even values or the given array is empty, return\
    \ [].\n/// Example 1:\n/// >>> pluck(arr: [4, 2, 3])\n/// [2, 1]\n/// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n/// Example 2:\n\
    /// >>> pluck(arr: [1, 2, 3])\n/// [2, 1]\n/// Explanation: 2 has the smallest\
    \ even value, and 2 has the smallest index.\n/// Example 3:\n/// >>> pluck(arr:\
    \ [] as [Int])\n/// [] as [Int]\n/// Example 4:\n/// >>> pluck(arr: [5, 0, 3,\
    \ 0, 4, 2])\n/// [0, 1]\n/// Explanation: 0 is the smallest value, but  there\
    \ are two zeros,\n/// so we will choose the first zero, which has the smallest\
    \ index.\n/// Constraints:\n/// * 1 <= nodes.length <= 10000\n/// * 0 <= node.value\n\
    func pluck(arr: [Int]) -> [Int] {\n    let smallest = arr.filter { $0 % 2 == 0\
    \ }.min()\n    if let smallest = smallest {\n        return [smallest, arr.firstIndex(of:\
    \ smallest)!]\n    }\n    return []\n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(pluck(arr: [4, 2, 3]) == [2, 1])\nassert(pluck(arr: [1, 2, 3]) == [2, 1])\n\
    assert(pluck(arr: [] as [Int]) == [] as [Int])\nassert(pluck(arr: [5, 0, 3, 0,\
    \ 4, 2]) == [0, 1])\nassert(pluck(arr: [1, 2, 3, 0, 5, 3]) == [0, 3])\nassert(pluck(arr:\
    \ [5, 4, 8, 4, 8]) == [4, 1])\nassert(pluck(arr: [7, 6, 7, 1]) == [6, 1])\nassert(pluck(arr:\
    \ [7, 9, 7, 1]) == [] as [Int])"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660013548
- exit_code: 0
  program: "\n/// \"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n/// your task is to pluck one of the nodes and return it.\n///\
    \ The plucked node should be the node with the smallest even value.\n/// If multiple\
    \ nodes with the same smallest even value are found return the node that has smallest\
    \ index.\n/// The plucked node should be returned in an array, [ smalest_value,\
    \ its index ],\n/// If there are no even values or the given array is empty, return\
    \ [].\n/// Example 1:\n/// >>> pluck(arr: [4, 2, 3])\n/// [2, 1]\n/// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n/// Example 2:\n\
    /// >>> pluck(arr: [1, 2, 3])\n/// [2, 1]\n/// Explanation: 2 has the smallest\
    \ even value, and 2 has the smallest index.\n/// Example 3:\n/// >>> pluck(arr:\
    \ [] as [Int])\n/// [] as [Int]\n/// Example 4:\n/// >>> pluck(arr: [5, 0, 3,\
    \ 0, 4, 2])\n/// [0, 1]\n/// Explanation: 0 is the smallest value, but  there\
    \ are two zeros,\n/// so we will choose the first zero, which has the smallest\
    \ index.\n/// Constraints:\n/// * 1 <= nodes.length <= 10000\n/// * 0 <= node.value\n\
    func pluck(arr: [Int]) -> [Int] {\n    guard !arr.isEmpty else { return [] }\n\
    \    guard arr.contains(where: { $0 % 2 == 0 }) else { return [] }\n    let ev\
    \ = arr.filter { $0 % 2 == 0 }.min()!\n    return [ev, arr.firstIndex(of: ev)!]\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(pluck(arr: [4, 2, 3]) == [2, 1])\nassert(pluck(arr:\
    \ [1, 2, 3]) == [2, 1])\nassert(pluck(arr: [] as [Int]) == [] as [Int])\nassert(pluck(arr:\
    \ [5, 0, 3, 0, 4, 2]) == [0, 1])\nassert(pluck(arr: [1, 2, 3, 0, 5, 3]) == [0,\
    \ 3])\nassert(pluck(arr: [5, 4, 8, 4, 8]) == [4, 1])\nassert(pluck(arr: [7, 6,\
    \ 7, 1]) == [6, 1])\nassert(pluck(arr: [7, 9, 7, 1]) == [] as [Int])"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660013548
- exit_code: 0
  program: "\n/// \"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n/// your task is to pluck one of the nodes and return it.\n///\
    \ The plucked node should be the node with the smallest even value.\n/// If multiple\
    \ nodes with the same smallest even value are found return the node that has smallest\
    \ index.\n/// The plucked node should be returned in an array, [ smalest_value,\
    \ its index ],\n/// If there are no even values or the given array is empty, return\
    \ [].\n/// Example 1:\n/// >>> pluck(arr: [4, 2, 3])\n/// [2, 1]\n/// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n/// Example 2:\n\
    /// >>> pluck(arr: [1, 2, 3])\n/// [2, 1]\n/// Explanation: 2 has the smallest\
    \ even value, and 2 has the smallest index.\n/// Example 3:\n/// >>> pluck(arr:\
    \ [] as [Int])\n/// [] as [Int]\n/// Example 4:\n/// >>> pluck(arr: [5, 0, 3,\
    \ 0, 4, 2])\n/// [0, 1]\n/// Explanation: 0 is the smallest value, but  there\
    \ are two zeros,\n/// so we will choose the first zero, which has the smallest\
    \ index.\n/// Constraints:\n/// * 1 <= nodes.length <= 10000\n/// * 0 <= node.value\n\
    func pluck(arr: [Int]) -> [Int] {\n    \n    var smallestValue = [Int]()\n   \
    \ for number in arr {\n        if number % 2 == 0 {\n            smallestValue.append(number)\n\
    \        }\n    }\n    guard let smallest = smallestValue.min() else { return\
    \ [] }\n    let index = arr.firstIndex(of: smallest)\n    return [smallest, index!]\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(pluck(arr: [4, 2, 3]) == [2, 1])\nassert(pluck(arr:\
    \ [1, 2, 3]) == [2, 1])\nassert(pluck(arr: [] as [Int]) == [] as [Int])\nassert(pluck(arr:\
    \ [5, 0, 3, 0, 4, 2]) == [0, 1])\nassert(pluck(arr: [1, 2, 3, 0, 5, 3]) == [0,\
    \ 3])\nassert(pluck(arr: [5, 4, 8, 4, 8]) == [4, 1])\nassert(pluck(arr: [7, 6,\
    \ 7, 1]) == [6, 1])\nassert(pluck(arr: [7, 9, 7, 1]) == [] as [Int])"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660013548
- exit_code: 0
  program: "\n/// \"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n/// your task is to pluck one of the nodes and return it.\n///\
    \ The plucked node should be the node with the smallest even value.\n/// If multiple\
    \ nodes with the same smallest even value are found return the node that has smallest\
    \ index.\n/// The plucked node should be returned in an array, [ smalest_value,\
    \ its index ],\n/// If there are no even values or the given array is empty, return\
    \ [].\n/// Example 1:\n/// >>> pluck(arr: [4, 2, 3])\n/// [2, 1]\n/// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n/// Example 2:\n\
    /// >>> pluck(arr: [1, 2, 3])\n/// [2, 1]\n/// Explanation: 2 has the smallest\
    \ even value, and 2 has the smallest index.\n/// Example 3:\n/// >>> pluck(arr:\
    \ [] as [Int])\n/// [] as [Int]\n/// Example 4:\n/// >>> pluck(arr: [5, 0, 3,\
    \ 0, 4, 2])\n/// [0, 1]\n/// Explanation: 0 is the smallest value, but  there\
    \ are two zeros,\n/// so we will choose the first zero, which has the smallest\
    \ index.\n/// Constraints:\n/// * 1 <= nodes.length <= 10000\n/// * 0 <= node.value\n\
    func pluck(arr: [Int]) -> [Int] {\n    \n    var evenArr: [Int] = []\n    var\
    \ minVal: Int = Int.max\n    var minValIndex: Int = 0\n    \n    for i in 0 ..<\
    \ arr.count {\n        if arr[i] % 2 == 0 {\n            evenArr.append(arr[i])\n\
    \            if arr[i] < minVal {\n                minVal = arr[i]\n         \
    \       minValIndex = i\n            }\n        }\n    }\n    \n    if evenArr.count\
    \ == 0 {\n        return []\n    }\n    \n    return [minVal, minValIndex]\n}\n\
    \n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(pluck(arr: [4, 2, 3]) == [2, 1])\nassert(pluck(arr:\
    \ [1, 2, 3]) == [2, 1])\nassert(pluck(arr: [] as [Int]) == [] as [Int])\nassert(pluck(arr:\
    \ [5, 0, 3, 0, 4, 2]) == [0, 1])\nassert(pluck(arr: [1, 2, 3, 0, 5, 3]) == [0,\
    \ 3])\nassert(pluck(arr: [5, 4, 8, 4, 8]) == [4, 1])\nassert(pluck(arr: [7, 6,\
    \ 7, 1]) == [6, 1])\nassert(pluck(arr: [7, 9, 7, 1]) == [] as [Int])"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660013548
- exit_code: 0
  program: "\n/// \"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n/// your task is to pluck one of the nodes and return it.\n///\
    \ The plucked node should be the node with the smallest even value.\n/// If multiple\
    \ nodes with the same smallest even value are found return the node that has smallest\
    \ index.\n/// The plucked node should be returned in an array, [ smalest_value,\
    \ its index ],\n/// If there are no even values or the given array is empty, return\
    \ [].\n/// Example 1:\n/// >>> pluck(arr: [4, 2, 3])\n/// [2, 1]\n/// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n/// Example 2:\n\
    /// >>> pluck(arr: [1, 2, 3])\n/// [2, 1]\n/// Explanation: 2 has the smallest\
    \ even value, and 2 has the smallest index.\n/// Example 3:\n/// >>> pluck(arr:\
    \ [] as [Int])\n/// [] as [Int]\n/// Example 4:\n/// >>> pluck(arr: [5, 0, 3,\
    \ 0, 4, 2])\n/// [0, 1]\n/// Explanation: 0 is the smallest value, but  there\
    \ are two zeros,\n/// so we will choose the first zero, which has the smallest\
    \ index.\n/// Constraints:\n/// * 1 <= nodes.length <= 10000\n/// * 0 <= node.value\n\
    func pluck(arr: [Int]) -> [Int] {\n    let evenValues = arr.filter { $0 % 2 ==\
    \ 0 }\n    guard let minEvenValue = evenValues.min() else { return [] }\n    guard\
    \ let minEvenValueIndex = arr.firstIndex(of: minEvenValue) else { return [] }\n\
    \    return [minEvenValue, minEvenValueIndex]\n}\n\n\nfunc ==(left: [(Int, Int)],\
    \ right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n       \
    \ return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r\
    \ {\n            return false\n        }\n    }\n    return true\n}\n        \
    \    \nassert(pluck(arr: [4, 2, 3]) == [2, 1])\nassert(pluck(arr: [1, 2, 3]) ==\
    \ [2, 1])\nassert(pluck(arr: [] as [Int]) == [] as [Int])\nassert(pluck(arr: [5,\
    \ 0, 3, 0, 4, 2]) == [0, 1])\nassert(pluck(arr: [1, 2, 3, 0, 5, 3]) == [0, 3])\n\
    assert(pluck(arr: [5, 4, 8, 4, 8]) == [4, 1])\nassert(pluck(arr: [7, 6, 7, 1])\
    \ == [6, 1])\nassert(pluck(arr: [7, 9, 7, 1]) == [] as [Int])"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660013548
- exit_code: -4
  program: "\n/// \"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n/// your task is to pluck one of the nodes and return it.\n///\
    \ The plucked node should be the node with the smallest even value.\n/// If multiple\
    \ nodes with the same smallest even value are found return the node that has smallest\
    \ index.\n/// The plucked node should be returned in an array, [ smalest_value,\
    \ its index ],\n/// If there are no even values or the given array is empty, return\
    \ [].\n/// Example 1:\n/// >>> pluck(arr: [4, 2, 3])\n/// [2, 1]\n/// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n/// Example 2:\n\
    /// >>> pluck(arr: [1, 2, 3])\n/// [2, 1]\n/// Explanation: 2 has the smallest\
    \ even value, and 2 has the smallest index.\n/// Example 3:\n/// >>> pluck(arr:\
    \ [] as [Int])\n/// [] as [Int]\n/// Example 4:\n/// >>> pluck(arr: [5, 0, 3,\
    \ 0, 4, 2])\n/// [0, 1]\n/// Explanation: 0 is the smallest value, but  there\
    \ are two zeros,\n/// so we will choose the first zero, which has the smallest\
    \ index.\n/// Constraints:\n/// * 1 <= nodes.length <= 10000\n/// * 0 <= node.value\n\
    func pluck(arr: [Int]) -> [Int] {\n    // your code here\n    return [0]\n}\n\n\
    \nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(pluck(arr: [4, 2, 3]) == [2, 1])\nassert(pluck(arr:\
    \ [1, 2, 3]) == [2, 1])\nassert(pluck(arr: [] as [Int]) == [] as [Int])\nassert(pluck(arr:\
    \ [5, 0, 3, 0, 4, 2]) == [0, 1])\nassert(pluck(arr: [1, 2, 3, 0, 5, 3]) == [0,\
    \ 3])\nassert(pluck(arr: [5, 4, 8, 4, 8]) == [4, 1])\nassert(pluck(arr: [7, 6,\
    \ 7, 1]) == [6, 1])\nassert(pluck(arr: [7, 9, 7, 1]) == [] as [Int])"
  status: Exception
  stderr: 'tmpytpy1brl/tmpytpy1brl.swift:45: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002ac00c59fc80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002ac00c296b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002ac00c296988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002ac00c2957b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpytpy1brl                        0x000055bccd4e33bc <unavailable> + 5052

    5    libc.so.6                          0x00002ac00c78b460 __libc_start_main +
    245

    6    tmpytpy1brl                        0x000055bccd4e2fc9 <unavailable> + 4041

    '
  stdout: ''
  timestamp: 1660013548
- exit_code: 0
  program: "\n/// \"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n/// your task is to pluck one of the nodes and return it.\n///\
    \ The plucked node should be the node with the smallest even value.\n/// If multiple\
    \ nodes with the same smallest even value are found return the node that has smallest\
    \ index.\n/// The plucked node should be returned in an array, [ smalest_value,\
    \ its index ],\n/// If there are no even values or the given array is empty, return\
    \ [].\n/// Example 1:\n/// >>> pluck(arr: [4, 2, 3])\n/// [2, 1]\n/// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n/// Example 2:\n\
    /// >>> pluck(arr: [1, 2, 3])\n/// [2, 1]\n/// Explanation: 2 has the smallest\
    \ even value, and 2 has the smallest index.\n/// Example 3:\n/// >>> pluck(arr:\
    \ [] as [Int])\n/// [] as [Int]\n/// Example 4:\n/// >>> pluck(arr: [5, 0, 3,\
    \ 0, 4, 2])\n/// [0, 1]\n/// Explanation: 0 is the smallest value, but  there\
    \ are two zeros,\n/// so we will choose the first zero, which has the smallest\
    \ index.\n/// Constraints:\n/// * 1 <= nodes.length <= 10000\n/// * 0 <= node.value\n\
    func pluck(arr: [Int]) -> [Int] {\n    // swiftlint:disable empty_count\n    //\
    \ swiftlint:disable empty_collection\n    guard !arr.isEmpty else { return []\
    \ }\n    // swiftlint:enable empty_count\n    // swiftlint:enable empty_collection\n\
    \    guard let even = arr.filter({ $0 % 2 == 0 }).min() else { return [] }\n \
    \   return [even, arr.firstIndex(of: even)!]\n}\n\n\nfunc ==(left: [(Int, Int)],\
    \ right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n       \
    \ return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r\
    \ {\n            return false\n        }\n    }\n    return true\n}\n        \
    \    \nassert(pluck(arr: [4, 2, 3]) == [2, 1])\nassert(pluck(arr: [1, 2, 3]) ==\
    \ [2, 1])\nassert(pluck(arr: [] as [Int]) == [] as [Int])\nassert(pluck(arr: [5,\
    \ 0, 3, 0, 4, 2]) == [0, 1])\nassert(pluck(arr: [1, 2, 3, 0, 5, 3]) == [0, 3])\n\
    assert(pluck(arr: [5, 4, 8, 4, 8]) == [4, 1])\nassert(pluck(arr: [7, 6, 7, 1])\
    \ == [6, 1])\nassert(pluck(arr: [7, 9, 7, 1]) == [] as [Int])"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660013548
- exit_code: 0
  program: "\n/// \"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n/// your task is to pluck one of the nodes and return it.\n///\
    \ The plucked node should be the node with the smallest even value.\n/// If multiple\
    \ nodes with the same smallest even value are found return the node that has smallest\
    \ index.\n/// The plucked node should be returned in an array, [ smalest_value,\
    \ its index ],\n/// If there are no even values or the given array is empty, return\
    \ [].\n/// Example 1:\n/// >>> pluck(arr: [4, 2, 3])\n/// [2, 1]\n/// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n/// Example 2:\n\
    /// >>> pluck(arr: [1, 2, 3])\n/// [2, 1]\n/// Explanation: 2 has the smallest\
    \ even value, and 2 has the smallest index.\n/// Example 3:\n/// >>> pluck(arr:\
    \ [] as [Int])\n/// [] as [Int]\n/// Example 4:\n/// >>> pluck(arr: [5, 0, 3,\
    \ 0, 4, 2])\n/// [0, 1]\n/// Explanation: 0 is the smallest value, but  there\
    \ are two zeros,\n/// so we will choose the first zero, which has the smallest\
    \ index.\n/// Constraints:\n/// * 1 <= nodes.length <= 10000\n/// * 0 <= node.value\n\
    func pluck(arr: [Int]) -> [Int] {\n    \n    guard !arr.isEmpty else { return\
    \ [] }\n    \n    var result: [Int] = []\n    var smallestEvenValue: Int = 0\n\
    \    var smallestEvenValueIndex: Int = 0\n    \n    for (index, value) in arr.enumerated()\
    \ {\n        if value % 2 == 0 {\n            if result.isEmpty {\n          \
    \      smallestEvenValue = value\n                smallestEvenValueIndex = index\n\
    \                result.append(smallestEvenValue)\n                result.append(smallestEvenValueIndex)\n\
    \            } else {\n                if value < smallestEvenValue {\n      \
    \              smallestEvenValue = value\n                    smallestEvenValueIndex\
    \ = index\n                    result.removeAll()\n                    result.append(smallestEvenValue)\n\
    \                    result.append(smallestEvenValueIndex)\n                }\n\
    \            }\n        }\n    }\n    \n    return result\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(pluck(arr: [4, 2, 3]) == [2, 1])\nassert(pluck(arr: [1,\
    \ 2, 3]) == [2, 1])\nassert(pluck(arr: [] as [Int]) == [] as [Int])\nassert(pluck(arr:\
    \ [5, 0, 3, 0, 4, 2]) == [0, 1])\nassert(pluck(arr: [1, 2, 3, 0, 5, 3]) == [0,\
    \ 3])\nassert(pluck(arr: [5, 4, 8, 4, 8]) == [4, 1])\nassert(pluck(arr: [7, 6,\
    \ 7, 1]) == [6, 1])\nassert(pluck(arr: [7, 9, 7, 1]) == [] as [Int])"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660013548
- exit_code: 0
  program: "\n/// \"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n/// your task is to pluck one of the nodes and return it.\n///\
    \ The plucked node should be the node with the smallest even value.\n/// If multiple\
    \ nodes with the same smallest even value are found return the node that has smallest\
    \ index.\n/// The plucked node should be returned in an array, [ smalest_value,\
    \ its index ],\n/// If there are no even values or the given array is empty, return\
    \ [].\n/// Example 1:\n/// >>> pluck(arr: [4, 2, 3])\n/// [2, 1]\n/// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n/// Example 2:\n\
    /// >>> pluck(arr: [1, 2, 3])\n/// [2, 1]\n/// Explanation: 2 has the smallest\
    \ even value, and 2 has the smallest index.\n/// Example 3:\n/// >>> pluck(arr:\
    \ [] as [Int])\n/// [] as [Int]\n/// Example 4:\n/// >>> pluck(arr: [5, 0, 3,\
    \ 0, 4, 2])\n/// [0, 1]\n/// Explanation: 0 is the smallest value, but  there\
    \ are two zeros,\n/// so we will choose the first zero, which has the smallest\
    \ index.\n/// Constraints:\n/// * 1 <= nodes.length <= 10000\n/// * 0 <= node.value\n\
    func pluck(arr: [Int]) -> [Int] {\n    var minValue: Int?\n    var minIndex: Int?\n\
    \    for (index, value) in arr.enumerated() {\n        if value % 2 == 0 && (minValue\
    \ == nil || value < minValue!) {\n            minValue = value\n            minIndex\
    \ = index\n        }\n    }\n    return minValue == nil ? [] : [minValue!, minIndex!]\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(pluck(arr: [4, 2, 3]) == [2, 1])\nassert(pluck(arr:\
    \ [1, 2, 3]) == [2, 1])\nassert(pluck(arr: [] as [Int]) == [] as [Int])\nassert(pluck(arr:\
    \ [5, 0, 3, 0, 4, 2]) == [0, 1])\nassert(pluck(arr: [1, 2, 3, 0, 5, 3]) == [0,\
    \ 3])\nassert(pluck(arr: [5, 4, 8, 4, 8]) == [4, 1])\nassert(pluck(arr: [7, 6,\
    \ 7, 1]) == [6, 1])\nassert(pluck(arr: [7, 9, 7, 1]) == [] as [Int])"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660013548
- exit_code: 0
  program: "\n/// \"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n/// your task is to pluck one of the nodes and return it.\n///\
    \ The plucked node should be the node with the smallest even value.\n/// If multiple\
    \ nodes with the same smallest even value are found return the node that has smallest\
    \ index.\n/// The plucked node should be returned in an array, [ smalest_value,\
    \ its index ],\n/// If there are no even values or the given array is empty, return\
    \ [].\n/// Example 1:\n/// >>> pluck(arr: [4, 2, 3])\n/// [2, 1]\n/// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n/// Example 2:\n\
    /// >>> pluck(arr: [1, 2, 3])\n/// [2, 1]\n/// Explanation: 2 has the smallest\
    \ even value, and 2 has the smallest index.\n/// Example 3:\n/// >>> pluck(arr:\
    \ [] as [Int])\n/// [] as [Int]\n/// Example 4:\n/// >>> pluck(arr: [5, 0, 3,\
    \ 0, 4, 2])\n/// [0, 1]\n/// Explanation: 0 is the smallest value, but  there\
    \ are two zeros,\n/// so we will choose the first zero, which has the smallest\
    \ index.\n/// Constraints:\n/// * 1 <= nodes.length <= 10000\n/// * 0 <= node.value\n\
    func pluck(arr: [Int]) -> [Int] {\n    let evenIndexes = arr.enumerated().filter\
    \ { $0.element % 2 == 0 }\n    if evenIndexes.isEmpty { return [] }\n    let minEven\
    \ = evenIndexes.min { $0.element < $1.element }\n    return [minEven!.element,\
    \ minEven!.offset]\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) ->\
    \ Bool {\n    if left.count != right.count {\n        return false\n    }\n  \
    \  for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(pluck(arr: [4, 2,\
    \ 3]) == [2, 1])\nassert(pluck(arr: [1, 2, 3]) == [2, 1])\nassert(pluck(arr: []\
    \ as [Int]) == [] as [Int])\nassert(pluck(arr: [5, 0, 3, 0, 4, 2]) == [0, 1])\n\
    assert(pluck(arr: [1, 2, 3, 0, 5, 3]) == [0, 3])\nassert(pluck(arr: [5, 4, 8,\
    \ 4, 8]) == [4, 1])\nassert(pluck(arr: [7, 6, 7, 1]) == [6, 1])\nassert(pluck(arr:\
    \ [7, 9, 7, 1]) == [] as [Int])"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660013548
- exit_code: 0
  program: "\n/// \"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n/// your task is to pluck one of the nodes and return it.\n///\
    \ The plucked node should be the node with the smallest even value.\n/// If multiple\
    \ nodes with the same smallest even value are found return the node that has smallest\
    \ index.\n/// The plucked node should be returned in an array, [ smalest_value,\
    \ its index ],\n/// If there are no even values or the given array is empty, return\
    \ [].\n/// Example 1:\n/// >>> pluck(arr: [4, 2, 3])\n/// [2, 1]\n/// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n/// Example 2:\n\
    /// >>> pluck(arr: [1, 2, 3])\n/// [2, 1]\n/// Explanation: 2 has the smallest\
    \ even value, and 2 has the smallest index.\n/// Example 3:\n/// >>> pluck(arr:\
    \ [] as [Int])\n/// [] as [Int]\n/// Example 4:\n/// >>> pluck(arr: [5, 0, 3,\
    \ 0, 4, 2])\n/// [0, 1]\n/// Explanation: 0 is the smallest value, but  there\
    \ are two zeros,\n/// so we will choose the first zero, which has the smallest\
    \ index.\n/// Constraints:\n/// * 1 <= nodes.length <= 10000\n/// * 0 <= node.value\n\
    func pluck(arr: [Int]) -> [Int] {\n    guard arr.count > 0 else { return [Int]()\
    \ }\n    let evenNodes = arr.filter { $0 % 2 == 0 }\n    guard evenNodes.count\
    \ > 0 else { return [Int]() }\n    let minEvenValue = evenNodes.min()!\n    guard\
    \ let minEvenIndex = arr.firstIndex(of: minEvenValue) else { return [Int]() }\n\
    \    return [minEvenValue, minEvenIndex]\n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(pluck(arr: [4, 2, 3]) == [2, 1])\nassert(pluck(arr: [1, 2, 3]) == [2, 1])\n\
    assert(pluck(arr: [] as [Int]) == [] as [Int])\nassert(pluck(arr: [5, 0, 3, 0,\
    \ 4, 2]) == [0, 1])\nassert(pluck(arr: [1, 2, 3, 0, 5, 3]) == [0, 3])\nassert(pluck(arr:\
    \ [5, 4, 8, 4, 8]) == [4, 1])\nassert(pluck(arr: [7, 6, 7, 1]) == [6, 1])\nassert(pluck(arr:\
    \ [7, 9, 7, 1]) == [] as [Int])"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660013548
- exit_code: 1
  program: "\n/// \"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n/// your task is to pluck one of the nodes and return it.\n///\
    \ The plucked node should be the node with the smallest even value.\n/// If multiple\
    \ nodes with the same smallest even value are found return the node that has smallest\
    \ index.\n/// The plucked node should be returned in an array, [ smalest_value,\
    \ its index ],\n/// If there are no even values or the given array is empty, return\
    \ [].\n/// Example 1:\n/// >>> pluck(arr: [4, 2, 3])\n/// [2, 1]\n/// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n/// Example 2:\n\
    /// >>> pluck(arr: [1, 2, 3])\n/// [2, 1]\n/// Explanation: 2 has the smallest\
    \ even value, and 2 has the smallest index.\n/// Example 3:\n/// >>> pluck(arr:\
    \ [] as [Int])\n/// [] as [Int]\n/// Example 4:\n/// >>> pluck(arr: [5, 0, 3,\
    \ 0, 4, 2])\n/// [0, 1]\n/// Explanation: 0 is the smallest value, but  there\
    \ are two zeros,\n/// so we will choose the first zero, which has the smallest\
    \ index.\n/// Constraints:\n/// * 1 <= nodes.length <= 10000\n/// * 0 <= node.value\n\
    func pluck(arr: [Int]) -> [Int] {\n    var smallest = Int.max\n    var index =\
    \ -1\n    for (i, val) in arr.enumerated() {\n        if val.isEven && val < smallest\
    \ {\n            smallest = val\n            index = i\n        }\n    }\n   \
    \ if index == -1 {\n        return []\n    }\n    return [smallest, index]\n}\n\
    \n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(pluck(arr: [4, 2, 3]) == [2, 1])\nassert(pluck(arr:\
    \ [1, 2, 3]) == [2, 1])\nassert(pluck(arr: [] as [Int]) == [] as [Int])\nassert(pluck(arr:\
    \ [5, 0, 3, 0, 4, 2]) == [0, 1])\nassert(pluck(arr: [1, 2, 3, 0, 5, 3]) == [0,\
    \ 3])\nassert(pluck(arr: [5, 4, 8, 4, 8]) == [4, 1])\nassert(pluck(arr: [7, 6,\
    \ 7, 1]) == [6, 1])\nassert(pluck(arr: [7, 9, 7, 1]) == [] as [Int])"
  status: SyntaxError
  stderr: "/tmp/tmp0oy8q74m.swift:31:16: error: value of type 'Int' has no member\
    \ 'isEven'\n        if val.isEven && val < smallest {\n           ~~~ ^~~~~~\n"
  stdout: ''
  timestamp: 1660013548
- exit_code: 0
  program: "\n/// \"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n/// your task is to pluck one of the nodes and return it.\n///\
    \ The plucked node should be the node with the smallest even value.\n/// If multiple\
    \ nodes with the same smallest even value are found return the node that has smallest\
    \ index.\n/// The plucked node should be returned in an array, [ smalest_value,\
    \ its index ],\n/// If there are no even values or the given array is empty, return\
    \ [].\n/// Example 1:\n/// >>> pluck(arr: [4, 2, 3])\n/// [2, 1]\n/// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n/// Example 2:\n\
    /// >>> pluck(arr: [1, 2, 3])\n/// [2, 1]\n/// Explanation: 2 has the smallest\
    \ even value, and 2 has the smallest index.\n/// Example 3:\n/// >>> pluck(arr:\
    \ [] as [Int])\n/// [] as [Int]\n/// Example 4:\n/// >>> pluck(arr: [5, 0, 3,\
    \ 0, 4, 2])\n/// [0, 1]\n/// Explanation: 0 is the smallest value, but  there\
    \ are two zeros,\n/// so we will choose the first zero, which has the smallest\
    \ index.\n/// Constraints:\n/// * 1 <= nodes.length <= 10000\n/// * 0 <= node.value\n\
    func pluck(arr: [Int]) -> [Int] {\n    guard !arr.isEmpty else { return [] }\n\
    \    let evens = arr.enumerated().filter { $0.element % 2 == 0 }\n    guard !evens.isEmpty\
    \ else { return [] }\n    let min = evens.min { a, b in a.element < b.element\
    \ }\n    return [min!.element, min!.offset]\n}\n\n\nfunc ==(left: [(Int, Int)],\
    \ right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n       \
    \ return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r\
    \ {\n            return false\n        }\n    }\n    return true\n}\n        \
    \    \nassert(pluck(arr: [4, 2, 3]) == [2, 1])\nassert(pluck(arr: [1, 2, 3]) ==\
    \ [2, 1])\nassert(pluck(arr: [] as [Int]) == [] as [Int])\nassert(pluck(arr: [5,\
    \ 0, 3, 0, 4, 2]) == [0, 1])\nassert(pluck(arr: [1, 2, 3, 0, 5, 3]) == [0, 3])\n\
    assert(pluck(arr: [5, 4, 8, 4, 8]) == [4, 1])\nassert(pluck(arr: [7, 6, 7, 1])\
    \ == [6, 1])\nassert(pluck(arr: [7, 9, 7, 1]) == [] as [Int])"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660013548
- exit_code: 0
  program: "\n/// \"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n/// your task is to pluck one of the nodes and return it.\n///\
    \ The plucked node should be the node with the smallest even value.\n/// If multiple\
    \ nodes with the same smallest even value are found return the node that has smallest\
    \ index.\n/// The plucked node should be returned in an array, [ smalest_value,\
    \ its index ],\n/// If there are no even values or the given array is empty, return\
    \ [].\n/// Example 1:\n/// >>> pluck(arr: [4, 2, 3])\n/// [2, 1]\n/// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n/// Example 2:\n\
    /// >>> pluck(arr: [1, 2, 3])\n/// [2, 1]\n/// Explanation: 2 has the smallest\
    \ even value, and 2 has the smallest index.\n/// Example 3:\n/// >>> pluck(arr:\
    \ [] as [Int])\n/// [] as [Int]\n/// Example 4:\n/// >>> pluck(arr: [5, 0, 3,\
    \ 0, 4, 2])\n/// [0, 1]\n/// Explanation: 0 is the smallest value, but  there\
    \ are two zeros,\n/// so we will choose the first zero, which has the smallest\
    \ index.\n/// Constraints:\n/// * 1 <= nodes.length <= 10000\n/// * 0 <= node.value\n\
    func pluck(arr: [Int]) -> [Int] {\n    var result = [Int]()\n    var smallestEvenValue\
    \ = Int.max\n    var minIndex = Int.max\n    for (index, value) in arr.enumerated()\
    \ {\n        if value % 2 == 0 {\n            if value < smallestEvenValue {\n\
    \                smallestEvenValue = value\n                minIndex = index\n\
    \            } else if value == smallestEvenValue {\n                if index\
    \ < minIndex {\n                    minIndex = index\n                }\n    \
    \        }\n        }\n    }\n    if smallestEvenValue != Int.max {\n        result.append(smallestEvenValue)\n\
    \        result.append(minIndex)\n    }\n    return result\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(pluck(arr: [4, 2, 3]) == [2, 1])\nassert(pluck(arr: [1,\
    \ 2, 3]) == [2, 1])\nassert(pluck(arr: [] as [Int]) == [] as [Int])\nassert(pluck(arr:\
    \ [5, 0, 3, 0, 4, 2]) == [0, 1])\nassert(pluck(arr: [1, 2, 3, 0, 5, 3]) == [0,\
    \ 3])\nassert(pluck(arr: [5, 4, 8, 4, 8]) == [4, 1])\nassert(pluck(arr: [7, 6,\
    \ 7, 1]) == [6, 1])\nassert(pluck(arr: [7, 9, 7, 1]) == [] as [Int])"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660013549
- exit_code: 0
  program: "\n/// \"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n/// your task is to pluck one of the nodes and return it.\n///\
    \ The plucked node should be the node with the smallest even value.\n/// If multiple\
    \ nodes with the same smallest even value are found return the node that has smallest\
    \ index.\n/// The plucked node should be returned in an array, [ smalest_value,\
    \ its index ],\n/// If there are no even values or the given array is empty, return\
    \ [].\n/// Example 1:\n/// >>> pluck(arr: [4, 2, 3])\n/// [2, 1]\n/// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n/// Example 2:\n\
    /// >>> pluck(arr: [1, 2, 3])\n/// [2, 1]\n/// Explanation: 2 has the smallest\
    \ even value, and 2 has the smallest index.\n/// Example 3:\n/// >>> pluck(arr:\
    \ [] as [Int])\n/// [] as [Int]\n/// Example 4:\n/// >>> pluck(arr: [5, 0, 3,\
    \ 0, 4, 2])\n/// [0, 1]\n/// Explanation: 0 is the smallest value, but  there\
    \ are two zeros,\n/// so we will choose the first zero, which has the smallest\
    \ index.\n/// Constraints:\n/// * 1 <= nodes.length <= 10000\n/// * 0 <= node.value\n\
    func pluck(arr: [Int]) -> [Int] {\n    // This version is mine\n    //    return\
    \ arr.enumerated().filter { $0.element % 2 == 0 }.sorted { $0.element < $1.element\
    \ }.first ?? []\n    // This is from solution\n    return (arr.indices.filter\
    \ { arr[$0] % 2 == 0 }).sorted { arr[$0] < arr[$1] }.first.map { [arr[$0], $0]\
    \ } ?? []\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n\
    \    if left.count != right.count {\n        return false\n    }\n    for (l,\
    \ r) in zip(left, right) {\n        if l != r {\n            return false\n  \
    \      }\n    }\n    return true\n}\n            \nassert(pluck(arr: [4, 2, 3])\
    \ == [2, 1])\nassert(pluck(arr: [1, 2, 3]) == [2, 1])\nassert(pluck(arr: [] as\
    \ [Int]) == [] as [Int])\nassert(pluck(arr: [5, 0, 3, 0, 4, 2]) == [0, 1])\nassert(pluck(arr:\
    \ [1, 2, 3, 0, 5, 3]) == [0, 3])\nassert(pluck(arr: [5, 4, 8, 4, 8]) == [4, 1])\n\
    assert(pluck(arr: [7, 6, 7, 1]) == [6, 1])\nassert(pluck(arr: [7, 9, 7, 1]) ==\
    \ [] as [Int])"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660013549
- exit_code: 1
  program: "\n/// \"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n/// your task is to pluck one of the nodes and return it.\n///\
    \ The plucked node should be the node with the smallest even value.\n/// If multiple\
    \ nodes with the same smallest even value are found return the node that has smallest\
    \ index.\n/// The plucked node should be returned in an array, [ smalest_value,\
    \ its index ],\n/// If there are no even values or the given array is empty, return\
    \ [].\n/// Example 1:\n/// >>> pluck(arr: [4, 2, 3])\n/// [2, 1]\n/// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n/// Example 2:\n\
    /// >>> pluck(arr: [1, 2, 3])\n/// [2, 1]\n/// Explanation: 2 has the smallest\
    \ even value, and 2 has the smallest index.\n/// Example 3:\n/// >>> pluck(arr:\
    \ [] as [Int])\n/// [] as [Int]\n/// Example 4:\n/// >>> pluck(arr: [5, 0, 3,\
    \ 0, 4, 2])\n/// [0, 1]\n/// Explanation: 0 is the smallest value, but  there\
    \ are two zeros,\n/// so we will choose the first zero, which has the smallest\
    \ index.\n/// Constraints:\n/// * 1 <= nodes.length <= 10000\n/// * 0 <= node.value\n\
    func pluck(arr: [Int]) -> [Int] {\n    if arr.isEmpty {\n        return []\n \
    \   }\n    return arr.enumerated().filter({ $0.element % 2 == 0 }).min(by: { $0.element\
    \ < $1.element })?.reduce([]) { $0 + [$1] } ?? []\n}\n\n\nfunc ==(left: [(Int,\
    \ Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n\
    \        return false\n    }\n    for (l, r) in zip(left, right) {\n        if\
    \ l != r {\n            return false\n        }\n    }\n    return true\n}\n \
    \           \nassert(pluck(arr: [4, 2, 3]) == [2, 1])\nassert(pluck(arr: [1, 2,\
    \ 3]) == [2, 1])\nassert(pluck(arr: [] as [Int]) == [] as [Int])\nassert(pluck(arr:\
    \ [5, 0, 3, 0, 4, 2]) == [0, 1])\nassert(pluck(arr: [1, 2, 3, 0, 5, 3]) == [0,\
    \ 3])\nassert(pluck(arr: [5, 4, 8, 4, 8]) == [4, 1])\nassert(pluck(arr: [7, 6,\
    \ 7, 1]) == [6, 1])\nassert(pluck(arr: [7, 9, 7, 1]) == [] as [Int])"
  status: SyntaxError
  stderr: "/tmp/tmpr5v71a6a.swift:31:99: error: value of tuple type 'EnumeratedSequence<[Int]>.Iterator.Element'\
    \ (aka '(offset: Int, element: Int)') has no member 'reduce'\n    return arr.enumerated().filter({\
    \ $0.element % 2 == 0 }).min(by: { $0.element < $1.element })?.reduce([]) { $0\
    \ + [$1] } ?? []\n           ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\
    \ ^~~~~~\n"
  stdout: ''
  timestamp: 1660013549
- exit_code: 0
  program: "\n/// \"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n/// your task is to pluck one of the nodes and return it.\n///\
    \ The plucked node should be the node with the smallest even value.\n/// If multiple\
    \ nodes with the same smallest even value are found return the node that has smallest\
    \ index.\n/// The plucked node should be returned in an array, [ smalest_value,\
    \ its index ],\n/// If there are no even values or the given array is empty, return\
    \ [].\n/// Example 1:\n/// >>> pluck(arr: [4, 2, 3])\n/// [2, 1]\n/// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n/// Example 2:\n\
    /// >>> pluck(arr: [1, 2, 3])\n/// [2, 1]\n/// Explanation: 2 has the smallest\
    \ even value, and 2 has the smallest index.\n/// Example 3:\n/// >>> pluck(arr:\
    \ [] as [Int])\n/// [] as [Int]\n/// Example 4:\n/// >>> pluck(arr: [5, 0, 3,\
    \ 0, 4, 2])\n/// [0, 1]\n/// Explanation: 0 is the smallest value, but  there\
    \ are two zeros,\n/// so we will choose the first zero, which has the smallest\
    \ index.\n/// Constraints:\n/// * 1 <= nodes.length <= 10000\n/// * 0 <= node.value\n\
    func pluck(arr: [Int]) -> [Int] {\n    var evenArray = [Int]()\n    var indexArray\
    \ = [Int]()\n    var smallestValue = Int.max\n    var smallestIndex = Int.max\n\
    \    for index in 0..<arr.count {\n        if arr[index] % 2 == 0 {\n        \
    \    evenArray.append(arr[index])\n            indexArray.append(index)\n    \
    \    }\n    }\n    if evenArray.count == 0 {\n        return []\n    }\n    for\
    \ index in 0..<evenArray.count {\n        if evenArray[index] < smallestValue\
    \ {\n            smallestValue = evenArray[index]\n            smallestIndex =\
    \ indexArray[index]\n        }\n    }\n    return [smallestValue, smallestIndex]\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(pluck(arr: [4, 2, 3]) == [2, 1])\nassert(pluck(arr:\
    \ [1, 2, 3]) == [2, 1])\nassert(pluck(arr: [] as [Int]) == [] as [Int])\nassert(pluck(arr:\
    \ [5, 0, 3, 0, 4, 2]) == [0, 1])\nassert(pluck(arr: [1, 2, 3, 0, 5, 3]) == [0,\
    \ 3])\nassert(pluck(arr: [5, 4, 8, 4, 8]) == [4, 1])\nassert(pluck(arr: [7, 6,\
    \ 7, 1]) == [6, 1])\nassert(pluck(arr: [7, 9, 7, 1]) == [] as [Int])"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660013549
- exit_code: -4
  program: "\n/// \"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n/// your task is to pluck one of the nodes and return it.\n///\
    \ The plucked node should be the node with the smallest even value.\n/// If multiple\
    \ nodes with the same smallest even value are found return the node that has smallest\
    \ index.\n/// The plucked node should be returned in an array, [ smalest_value,\
    \ its index ],\n/// If there are no even values or the given array is empty, return\
    \ [].\n/// Example 1:\n/// >>> pluck(arr: [4, 2, 3])\n/// [2, 1]\n/// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n/// Example 2:\n\
    /// >>> pluck(arr: [1, 2, 3])\n/// [2, 1]\n/// Explanation: 2 has the smallest\
    \ even value, and 2 has the smallest index.\n/// Example 3:\n/// >>> pluck(arr:\
    \ [] as [Int])\n/// [] as [Int]\n/// Example 4:\n/// >>> pluck(arr: [5, 0, 3,\
    \ 0, 4, 2])\n/// [0, 1]\n/// Explanation: 0 is the smallest value, but  there\
    \ are two zeros,\n/// so we will choose the first zero, which has the smallest\
    \ index.\n/// Constraints:\n/// * 1 <= nodes.length <= 10000\n/// * 0 <= node.value\n\
    func pluck(arr: [Int]) -> [Int] {\n    let arr = arr.filter {$0 % 2 == 0}\n  \
    \  return arr.count == 0 ? [] : [arr.min()!, arr.firstIndex(of: arr.min()!)!]\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(pluck(arr: [4, 2, 3]) == [2, 1])\nassert(pluck(arr:\
    \ [1, 2, 3]) == [2, 1])\nassert(pluck(arr: [] as [Int]) == [] as [Int])\nassert(pluck(arr:\
    \ [5, 0, 3, 0, 4, 2]) == [0, 1])\nassert(pluck(arr: [1, 2, 3, 0, 5, 3]) == [0,\
    \ 3])\nassert(pluck(arr: [5, 4, 8, 4, 8]) == [4, 1])\nassert(pluck(arr: [7, 6,\
    \ 7, 1]) == [6, 1])\nassert(pluck(arr: [7, 9, 7, 1]) == [] as [Int])"
  status: Exception
  stderr: 'tmp8a8kikgw/tmp8a8kikgw.swift:46: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b8a3c761c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b8a3c458b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b8a3c458988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b8a3c4577b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmp8a8kikgw                        0x000055656b6ba7db <unavailable> + 6107

    5    libc.so.6                          0x00002b8a3c94d460 __libc_start_main +
    245

    6    tmp8a8kikgw                        0x000055656b6ba2c9 <unavailable> + 4809

    '
  stdout: ''
  timestamp: 1660013549
- exit_code: 0
  program: "\n/// \"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n/// your task is to pluck one of the nodes and return it.\n///\
    \ The plucked node should be the node with the smallest even value.\n/// If multiple\
    \ nodes with the same smallest even value are found return the node that has smallest\
    \ index.\n/// The plucked node should be returned in an array, [ smalest_value,\
    \ its index ],\n/// If there are no even values or the given array is empty, return\
    \ [].\n/// Example 1:\n/// >>> pluck(arr: [4, 2, 3])\n/// [2, 1]\n/// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n/// Example 2:\n\
    /// >>> pluck(arr: [1, 2, 3])\n/// [2, 1]\n/// Explanation: 2 has the smallest\
    \ even value, and 2 has the smallest index.\n/// Example 3:\n/// >>> pluck(arr:\
    \ [] as [Int])\n/// [] as [Int]\n/// Example 4:\n/// >>> pluck(arr: [5, 0, 3,\
    \ 0, 4, 2])\n/// [0, 1]\n/// Explanation: 0 is the smallest value, but  there\
    \ are two zeros,\n/// so we will choose the first zero, which has the smallest\
    \ index.\n/// Constraints:\n/// * 1 <= nodes.length <= 10000\n/// * 0 <= node.value\n\
    func pluck(arr: [Int]) -> [Int] {\n    let evenNumbers = arr.filter { $0 % 2 ==\
    \ 0 }\n    guard !evenNumbers.isEmpty else { return [] }\n    let smallestEven\
    \ = evenNumbers.min()!\n    let indices = arr.indices.filter { arr[$0] == smallestEven\
    \ }\n    return [smallestEven, indices.min()!]\n}\n\n\nfunc ==(left: [(Int, Int)],\
    \ right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n       \
    \ return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r\
    \ {\n            return false\n        }\n    }\n    return true\n}\n        \
    \    \nassert(pluck(arr: [4, 2, 3]) == [2, 1])\nassert(pluck(arr: [1, 2, 3]) ==\
    \ [2, 1])\nassert(pluck(arr: [] as [Int]) == [] as [Int])\nassert(pluck(arr: [5,\
    \ 0, 3, 0, 4, 2]) == [0, 1])\nassert(pluck(arr: [1, 2, 3, 0, 5, 3]) == [0, 3])\n\
    assert(pluck(arr: [5, 4, 8, 4, 8]) == [4, 1])\nassert(pluck(arr: [7, 6, 7, 1])\
    \ == [6, 1])\nassert(pluck(arr: [7, 9, 7, 1]) == [] as [Int])"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660013549
- exit_code: -4
  program: "\n/// \"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n/// your task is to pluck one of the nodes and return it.\n///\
    \ The plucked node should be the node with the smallest even value.\n/// If multiple\
    \ nodes with the same smallest even value are found return the node that has smallest\
    \ index.\n/// The plucked node should be returned in an array, [ smalest_value,\
    \ its index ],\n/// If there are no even values or the given array is empty, return\
    \ [].\n/// Example 1:\n/// >>> pluck(arr: [4, 2, 3])\n/// [2, 1]\n/// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n/// Example 2:\n\
    /// >>> pluck(arr: [1, 2, 3])\n/// [2, 1]\n/// Explanation: 2 has the smallest\
    \ even value, and 2 has the smallest index.\n/// Example 3:\n/// >>> pluck(arr:\
    \ [] as [Int])\n/// [] as [Int]\n/// Example 4:\n/// >>> pluck(arr: [5, 0, 3,\
    \ 0, 4, 2])\n/// [0, 1]\n/// Explanation: 0 is the smallest value, but  there\
    \ are two zeros,\n/// so we will choose the first zero, which has the smallest\
    \ index.\n/// Constraints:\n/// * 1 <= nodes.length <= 10000\n/// * 0 <= node.value\n\
    func pluck(arr: [Int]) -> [Int] {\n    return []\n}\n\n\nfunc ==(left: [(Int,\
    \ Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n\
    \        return false\n    }\n    for (l, r) in zip(left, right) {\n        if\
    \ l != r {\n            return false\n        }\n    }\n    return true\n}\n \
    \           \nassert(pluck(arr: [4, 2, 3]) == [2, 1])\nassert(pluck(arr: [1, 2,\
    \ 3]) == [2, 1])\nassert(pluck(arr: [] as [Int]) == [] as [Int])\nassert(pluck(arr:\
    \ [5, 0, 3, 0, 4, 2]) == [0, 1])\nassert(pluck(arr: [1, 2, 3, 0, 5, 3]) == [0,\
    \ 3])\nassert(pluck(arr: [5, 4, 8, 4, 8]) == [4, 1])\nassert(pluck(arr: [7, 6,\
    \ 7, 1]) == [6, 1])\nassert(pluck(arr: [7, 9, 7, 1]) == [] as [Int])"
  status: Exception
  stderr: 'tmpgh8dpvxh/tmpgh8dpvxh.swift:44: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002ac906ec4c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002ac906bbbb6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002ac906bbb988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002ac906bba7b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpgh8dpvxh                        0x00005578e3d9c3bc <unavailable> + 5052

    5    libc.so.6                          0x00002ac9070b0460 __libc_start_main +
    245

    6    tmpgh8dpvxh                        0x00005578e3d9bfc9 <unavailable> + 4041

    '
  stdout: ''
  timestamp: 1660013365
- exit_code: -4
  program: "\n/// \"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n/// your task is to pluck one of the nodes and return it.\n///\
    \ The plucked node should be the node with the smallest even value.\n/// If multiple\
    \ nodes with the same smallest even value are found return the node that has smallest\
    \ index.\n/// The plucked node should be returned in an array, [ smalest_value,\
    \ its index ],\n/// If there are no even values or the given array is empty, return\
    \ [].\n/// Example 1:\n/// >>> pluck(arr: [4, 2, 3])\n/// [2, 1]\n/// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n/// Example 2:\n\
    /// >>> pluck(arr: [1, 2, 3])\n/// [2, 1]\n/// Explanation: 2 has the smallest\
    \ even value, and 2 has the smallest index.\n/// Example 3:\n/// >>> pluck(arr:\
    \ [] as [Int])\n/// [] as [Int]\n/// Example 4:\n/// >>> pluck(arr: [5, 0, 3,\
    \ 0, 4, 2])\n/// [0, 1]\n/// Explanation: 0 is the smallest value, but  there\
    \ are two zeros,\n/// so we will choose the first zero, which has the smallest\
    \ index.\n/// Constraints:\n/// * 1 <= nodes.length <= 10000\n/// * 0 <= node.value\n\
    func pluck(arr: [Int]) -> [Int] {\n    return []\n}\n\n\nfunc ==(left: [(Int,\
    \ Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n\
    \        return false\n    }\n    for (l, r) in zip(left, right) {\n        if\
    \ l != r {\n            return false\n        }\n    }\n    return true\n}\n \
    \           \nassert(pluck(arr: [4, 2, 3]) == [2, 1])\nassert(pluck(arr: [1, 2,\
    \ 3]) == [2, 1])\nassert(pluck(arr: [] as [Int]) == [] as [Int])\nassert(pluck(arr:\
    \ [5, 0, 3, 0, 4, 2]) == [0, 1])\nassert(pluck(arr: [1, 2, 3, 0, 5, 3]) == [0,\
    \ 3])\nassert(pluck(arr: [5, 4, 8, 4, 8]) == [4, 1])\nassert(pluck(arr: [7, 6,\
    \ 7, 1]) == [6, 1])\nassert(pluck(arr: [7, 9, 7, 1]) == [] as [Int])"
  status: Exception
  stderr: 'tmpgh8dpvxh/tmpgh8dpvxh.swift:44: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002ac906ec4c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002ac906bbbb6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002ac906bbb988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002ac906bba7b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpgh8dpvxh                        0x00005578e3d9c3bc <unavailable> + 5052

    5    libc.so.6                          0x00002ac9070b0460 __libc_start_main +
    245

    6    tmpgh8dpvxh                        0x00005578e3d9bfc9 <unavailable> + 4041

    '
  stdout: ''
  timestamp: 1660013365
- exit_code: 0
  program: "\n/// \"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n/// your task is to pluck one of the nodes and return it.\n///\
    \ The plucked node should be the node with the smallest even value.\n/// If multiple\
    \ nodes with the same smallest even value are found return the node that has smallest\
    \ index.\n/// The plucked node should be returned in an array, [ smalest_value,\
    \ its index ],\n/// If there are no even values or the given array is empty, return\
    \ [].\n/// Example 1:\n/// >>> pluck(arr: [4, 2, 3])\n/// [2, 1]\n/// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n/// Example 2:\n\
    /// >>> pluck(arr: [1, 2, 3])\n/// [2, 1]\n/// Explanation: 2 has the smallest\
    \ even value, and 2 has the smallest index.\n/// Example 3:\n/// >>> pluck(arr:\
    \ [] as [Int])\n/// [] as [Int]\n/// Example 4:\n/// >>> pluck(arr: [5, 0, 3,\
    \ 0, 4, 2])\n/// [0, 1]\n/// Explanation: 0 is the smallest value, but  there\
    \ are two zeros,\n/// so we will choose the first zero, which has the smallest\
    \ index.\n/// Constraints:\n/// * 1 <= nodes.length <= 10000\n/// * 0 <= node.value\n\
    func pluck(arr: [Int]) -> [Int] {\n    let even = arr.filter { $0 % 2 == 0 }\n\
    \    guard let min = even.min() else { return [] }\n    guard let index = arr.firstIndex(of:\
    \ min) else { return [] }\n    return [min, index]\n}\n\n\nfunc ==(left: [(Int,\
    \ Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n\
    \        return false\n    }\n    for (l, r) in zip(left, right) {\n        if\
    \ l != r {\n            return false\n        }\n    }\n    return true\n}\n \
    \           \nassert(pluck(arr: [4, 2, 3]) == [2, 1])\nassert(pluck(arr: [1, 2,\
    \ 3]) == [2, 1])\nassert(pluck(arr: [] as [Int]) == [] as [Int])\nassert(pluck(arr:\
    \ [5, 0, 3, 0, 4, 2]) == [0, 1])\nassert(pluck(arr: [1, 2, 3, 0, 5, 3]) == [0,\
    \ 3])\nassert(pluck(arr: [5, 4, 8, 4, 8]) == [4, 1])\nassert(pluck(arr: [7, 6,\
    \ 7, 1]) == [6, 1])\nassert(pluck(arr: [7, 9, 7, 1]) == [] as [Int])"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660013549
- exit_code: -4
  program: "\n/// \"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n/// your task is to pluck one of the nodes and return it.\n///\
    \ The plucked node should be the node with the smallest even value.\n/// If multiple\
    \ nodes with the same smallest even value are found return the node that has smallest\
    \ index.\n/// The plucked node should be returned in an array, [ smalest_value,\
    \ its index ],\n/// If there are no even values or the given array is empty, return\
    \ [].\n/// Example 1:\n/// >>> pluck(arr: [4, 2, 3])\n/// [2, 1]\n/// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n/// Example 2:\n\
    /// >>> pluck(arr: [1, 2, 3])\n/// [2, 1]\n/// Explanation: 2 has the smallest\
    \ even value, and 2 has the smallest index.\n/// Example 3:\n/// >>> pluck(arr:\
    \ [] as [Int])\n/// [] as [Int]\n/// Example 4:\n/// >>> pluck(arr: [5, 0, 3,\
    \ 0, 4, 2])\n/// [0, 1]\n/// Explanation: 0 is the smallest value, but  there\
    \ are two zeros,\n/// so we will choose the first zero, which has the smallest\
    \ index.\n/// Constraints:\n/// * 1 <= nodes.length <= 10000\n/// * 0 <= node.value\n\
    func pluck(arr: [Int]) -> [Int] {\n    var evens = [Int]()\n    var minimumEven\
    \ = 10000\n    var result = [Int]()\n    arr.enumerated().forEach {\n        if\
    \ $0.element % 2 == 0 {\n            evens.append($0.element)\n            if\
    \ $0.element < minimumEven {\n                minimumEven = $0.element\n     \
    \       }\n        }\n    }\n    if evens.count == 0 {\n        return result\n\
    \    }\n    arr.enumerated().forEach {\n        if $0.element == minimumEven {\n\
    \            result.append($0.element)\n            result.append($0.offset)\n\
    \            return\n        }\n    }\n    return result\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(pluck(arr: [4, 2, 3]) == [2, 1])\nassert(pluck(arr: [1,\
    \ 2, 3]) == [2, 1])\nassert(pluck(arr: [] as [Int]) == [] as [Int])\nassert(pluck(arr:\
    \ [5, 0, 3, 0, 4, 2]) == [0, 1])\nassert(pluck(arr: [1, 2, 3, 0, 5, 3]) == [0,\
    \ 3])\nassert(pluck(arr: [5, 4, 8, 4, 8]) == [4, 1])\nassert(pluck(arr: [7, 6,\
    \ 7, 1]) == [6, 1])\nassert(pluck(arr: [7, 9, 7, 1]) == [] as [Int])"
  status: Exception
  stderr: 'tmp7vsku5e2/tmp7vsku5e2.swift:68: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002af2ff2a9c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002af2fefa0b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002af2fefa0988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002af2fef9f7b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmp7vsku5e2                        0x000055d277d11a34 <unavailable> + 6708

    5    libc.so.6                          0x00002af2ff495460 __libc_start_main +
    245

    6    tmp7vsku5e2                        0x000055d277d112d9 <unavailable> + 4825

    '
  stdout: ''
  timestamp: 1660013549
- exit_code: 0
  program: "\n/// \"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n/// your task is to pluck one of the nodes and return it.\n///\
    \ The plucked node should be the node with the smallest even value.\n/// If multiple\
    \ nodes with the same smallest even value are found return the node that has smallest\
    \ index.\n/// The plucked node should be returned in an array, [ smalest_value,\
    \ its index ],\n/// If there are no even values or the given array is empty, return\
    \ [].\n/// Example 1:\n/// >>> pluck(arr: [4, 2, 3])\n/// [2, 1]\n/// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n/// Example 2:\n\
    /// >>> pluck(arr: [1, 2, 3])\n/// [2, 1]\n/// Explanation: 2 has the smallest\
    \ even value, and 2 has the smallest index.\n/// Example 3:\n/// >>> pluck(arr:\
    \ [] as [Int])\n/// [] as [Int]\n/// Example 4:\n/// >>> pluck(arr: [5, 0, 3,\
    \ 0, 4, 2])\n/// [0, 1]\n/// Explanation: 0 is the smallest value, but  there\
    \ are two zeros,\n/// so we will choose the first zero, which has the smallest\
    \ index.\n/// Constraints:\n/// * 1 <= nodes.length <= 10000\n/// * 0 <= node.value\n\
    func pluck(arr: [Int]) -> [Int] {\n    \n    var smallestEven = 10000000\n   \
    \ var smallestEvenIndex = 10000000\n    var numberOfTimesToLoop = arr.count\n\
    \    var index = 0\n    \n    while numberOfTimesToLoop > 0 {\n        let currentValue\
    \ = arr[index]\n        if currentValue % 2 == 0 {\n            if currentValue\
    \ < smallestEven {\n                smallestEven = currentValue\n            \
    \    smallestEvenIndex = index\n            }\n        }\n        index += 1\n\
    \        numberOfTimesToLoop -= 1\n    }\n    \n    if smallestEven == 10000000\
    \ {\n        return []\n    }\n    \n    return [smallestEven, smallestEvenIndex]\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(pluck(arr: [4, 2, 3]) == [2, 1])\nassert(pluck(arr:\
    \ [1, 2, 3]) == [2, 1])\nassert(pluck(arr: [] as [Int]) == [] as [Int])\nassert(pluck(arr:\
    \ [5, 0, 3, 0, 4, 2]) == [0, 1])\nassert(pluck(arr: [1, 2, 3, 0, 5, 3]) == [0,\
    \ 3])\nassert(pluck(arr: [5, 4, 8, 4, 8]) == [4, 1])\nassert(pluck(arr: [7, 6,\
    \ 7, 1]) == [6, 1])\nassert(pluck(arr: [7, 9, 7, 1]) == [] as [Int])"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660013549
- exit_code: 0
  program: "\n/// \"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n/// your task is to pluck one of the nodes and return it.\n///\
    \ The plucked node should be the node with the smallest even value.\n/// If multiple\
    \ nodes with the same smallest even value are found return the node that has smallest\
    \ index.\n/// The plucked node should be returned in an array, [ smalest_value,\
    \ its index ],\n/// If there are no even values or the given array is empty, return\
    \ [].\n/// Example 1:\n/// >>> pluck(arr: [4, 2, 3])\n/// [2, 1]\n/// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n/// Example 2:\n\
    /// >>> pluck(arr: [1, 2, 3])\n/// [2, 1]\n/// Explanation: 2 has the smallest\
    \ even value, and 2 has the smallest index.\n/// Example 3:\n/// >>> pluck(arr:\
    \ [] as [Int])\n/// [] as [Int]\n/// Example 4:\n/// >>> pluck(arr: [5, 0, 3,\
    \ 0, 4, 2])\n/// [0, 1]\n/// Explanation: 0 is the smallest value, but  there\
    \ are two zeros,\n/// so we will choose the first zero, which has the smallest\
    \ index.\n/// Constraints:\n/// * 1 <= nodes.length <= 10000\n/// * 0 <= node.value\n\
    func pluck(arr: [Int]) -> [Int] {\n    var result = [Int]()\n    var minEvenValue\
    \ = Int.max\n    for (index, value) in arr.enumerated() {\n        if value %\
    \ 2 == 0 && value < minEvenValue {\n            minEvenValue = value\n       \
    \     result = [value, index]\n        }\n    }\n    return result\n}\n\n\nfunc\
    \ ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count !=\
    \ right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(pluck(arr: [4, 2, 3]) == [2, 1])\nassert(pluck(arr:\
    \ [1, 2, 3]) == [2, 1])\nassert(pluck(arr: [] as [Int]) == [] as [Int])\nassert(pluck(arr:\
    \ [5, 0, 3, 0, 4, 2]) == [0, 1])\nassert(pluck(arr: [1, 2, 3, 0, 5, 3]) == [0,\
    \ 3])\nassert(pluck(arr: [5, 4, 8, 4, 8]) == [4, 1])\nassert(pluck(arr: [7, 6,\
    \ 7, 1]) == [6, 1])\nassert(pluck(arr: [7, 9, 7, 1]) == [] as [Int])"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660013549
- exit_code: 0
  program: "\n/// \"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n/// your task is to pluck one of the nodes and return it.\n///\
    \ The plucked node should be the node with the smallest even value.\n/// If multiple\
    \ nodes with the same smallest even value are found return the node that has smallest\
    \ index.\n/// The plucked node should be returned in an array, [ smalest_value,\
    \ its index ],\n/// If there are no even values or the given array is empty, return\
    \ [].\n/// Example 1:\n/// >>> pluck(arr: [4, 2, 3])\n/// [2, 1]\n/// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n/// Example 2:\n\
    /// >>> pluck(arr: [1, 2, 3])\n/// [2, 1]\n/// Explanation: 2 has the smallest\
    \ even value, and 2 has the smallest index.\n/// Example 3:\n/// >>> pluck(arr:\
    \ [] as [Int])\n/// [] as [Int]\n/// Example 4:\n/// >>> pluck(arr: [5, 0, 3,\
    \ 0, 4, 2])\n/// [0, 1]\n/// Explanation: 0 is the smallest value, but  there\
    \ are two zeros,\n/// so we will choose the first zero, which has the smallest\
    \ index.\n/// Constraints:\n/// * 1 <= nodes.length <= 10000\n/// * 0 <= node.value\n\
    func pluck(arr: [Int]) -> [Int] {\n    \n    var result = [Int]()\n    var minEven\
    \ = Int.max\n    var minEvenIndex = -1\n    \n    for (index, value) in arr.enumerated()\
    \ {\n        if value % 2 == 0 {\n            if value < minEven {\n         \
    \       minEven = value\n                minEvenIndex = index\n            }\n\
    \        }\n    }\n    \n    if minEvenIndex != -1 {\n        result.append(minEven)\n\
    \        result.append(minEvenIndex)\n    }\n    \n    return result\n}\n\n\n\
    func ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(pluck(arr: [4, 2, 3]) == [2, 1])\nassert(pluck(arr:\
    \ [1, 2, 3]) == [2, 1])\nassert(pluck(arr: [] as [Int]) == [] as [Int])\nassert(pluck(arr:\
    \ [5, 0, 3, 0, 4, 2]) == [0, 1])\nassert(pluck(arr: [1, 2, 3, 0, 5, 3]) == [0,\
    \ 3])\nassert(pluck(arr: [5, 4, 8, 4, 8]) == [4, 1])\nassert(pluck(arr: [7, 6,\
    \ 7, 1]) == [6, 1])\nassert(pluck(arr: [7, 9, 7, 1]) == [] as [Int])"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660013549
- exit_code: 0
  program: "\n/// \"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n/// your task is to pluck one of the nodes and return it.\n///\
    \ The plucked node should be the node with the smallest even value.\n/// If multiple\
    \ nodes with the same smallest even value are found return the node that has smallest\
    \ index.\n/// The plucked node should be returned in an array, [ smalest_value,\
    \ its index ],\n/// If there are no even values or the given array is empty, return\
    \ [].\n/// Example 1:\n/// >>> pluck(arr: [4, 2, 3])\n/// [2, 1]\n/// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n/// Example 2:\n\
    /// >>> pluck(arr: [1, 2, 3])\n/// [2, 1]\n/// Explanation: 2 has the smallest\
    \ even value, and 2 has the smallest index.\n/// Example 3:\n/// >>> pluck(arr:\
    \ [] as [Int])\n/// [] as [Int]\n/// Example 4:\n/// >>> pluck(arr: [5, 0, 3,\
    \ 0, 4, 2])\n/// [0, 1]\n/// Explanation: 0 is the smallest value, but  there\
    \ are two zeros,\n/// so we will choose the first zero, which has the smallest\
    \ index.\n/// Constraints:\n/// * 1 <= nodes.length <= 10000\n/// * 0 <= node.value\n\
    func pluck(arr: [Int]) -> [Int] {\n    var result = [Int]()\n    guard arr.count\
    \ > 0 else { return [] }\n    var value = Int.max\n    var idx = -1\n    for (index,\
    \ item) in arr.enumerated() {\n        if item % 2 == 0 {\n            if item\
    \ < value {\n                value = item\n                idx = index\n     \
    \       }\n        }\n    }\n    if idx != -1 {\n        result.append(value)\n\
    \        result.append(idx)\n    }\n    return result\n}\n\n\nfunc ==(left: [(Int,\
    \ Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n\
    \        return false\n    }\n    for (l, r) in zip(left, right) {\n        if\
    \ l != r {\n            return false\n        }\n    }\n    return true\n}\n \
    \           \nassert(pluck(arr: [4, 2, 3]) == [2, 1])\nassert(pluck(arr: [1, 2,\
    \ 3]) == [2, 1])\nassert(pluck(arr: [] as [Int]) == [] as [Int])\nassert(pluck(arr:\
    \ [5, 0, 3, 0, 4, 2]) == [0, 1])\nassert(pluck(arr: [1, 2, 3, 0, 5, 3]) == [0,\
    \ 3])\nassert(pluck(arr: [5, 4, 8, 4, 8]) == [4, 1])\nassert(pluck(arr: [7, 6,\
    \ 7, 1]) == [6, 1])\nassert(pluck(arr: [7, 9, 7, 1]) == [] as [Int])"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660013549
- exit_code: 0
  program: "\n/// \"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n/// your task is to pluck one of the nodes and return it.\n///\
    \ The plucked node should be the node with the smallest even value.\n/// If multiple\
    \ nodes with the same smallest even value are found return the node that has smallest\
    \ index.\n/// The plucked node should be returned in an array, [ smalest_value,\
    \ its index ],\n/// If there are no even values or the given array is empty, return\
    \ [].\n/// Example 1:\n/// >>> pluck(arr: [4, 2, 3])\n/// [2, 1]\n/// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n/// Example 2:\n\
    /// >>> pluck(arr: [1, 2, 3])\n/// [2, 1]\n/// Explanation: 2 has the smallest\
    \ even value, and 2 has the smallest index.\n/// Example 3:\n/// >>> pluck(arr:\
    \ [] as [Int])\n/// [] as [Int]\n/// Example 4:\n/// >>> pluck(arr: [5, 0, 3,\
    \ 0, 4, 2])\n/// [0, 1]\n/// Explanation: 0 is the smallest value, but  there\
    \ are two zeros,\n/// so we will choose the first zero, which has the smallest\
    \ index.\n/// Constraints:\n/// * 1 <= nodes.length <= 10000\n/// * 0 <= node.value\n\
    func pluck(arr: [Int]) -> [Int] {\n    // Good luck!\n    var even = [Int]()\n\
    \    var evenIndex = [Int]()\n    for i in 0..<arr.count {\n        if arr[i]\
    \ % 2 == 0 {\n            even.append(arr[i])\n            evenIndex.append(i)\n\
    \        }\n    }\n    if even.count == 0 {\n        return []\n    }\n    var\
    \ min = even[0]\n    var minIndex = evenIndex[0]\n    for i in 0..<even.count\
    \ {\n        if even[i] < min {\n            min = even[i]\n            minIndex\
    \ = evenIndex[i]\n        }\n    }\n    return [min, minIndex]\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(pluck(arr: [4, 2, 3]) == [2, 1])\nassert(pluck(arr: [1,\
    \ 2, 3]) == [2, 1])\nassert(pluck(arr: [] as [Int]) == [] as [Int])\nassert(pluck(arr:\
    \ [5, 0, 3, 0, 4, 2]) == [0, 1])\nassert(pluck(arr: [1, 2, 3, 0, 5, 3]) == [0,\
    \ 3])\nassert(pluck(arr: [5, 4, 8, 4, 8]) == [4, 1])\nassert(pluck(arr: [7, 6,\
    \ 7, 1]) == [6, 1])\nassert(pluck(arr: [7, 9, 7, 1]) == [] as [Int])"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660013549
- exit_code: 0
  program: "\n/// \"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n/// your task is to pluck one of the nodes and return it.\n///\
    \ The plucked node should be the node with the smallest even value.\n/// If multiple\
    \ nodes with the same smallest even value are found return the node that has smallest\
    \ index.\n/// The plucked node should be returned in an array, [ smalest_value,\
    \ its index ],\n/// If there are no even values or the given array is empty, return\
    \ [].\n/// Example 1:\n/// >>> pluck(arr: [4, 2, 3])\n/// [2, 1]\n/// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n/// Example 2:\n\
    /// >>> pluck(arr: [1, 2, 3])\n/// [2, 1]\n/// Explanation: 2 has the smallest\
    \ even value, and 2 has the smallest index.\n/// Example 3:\n/// >>> pluck(arr:\
    \ [] as [Int])\n/// [] as [Int]\n/// Example 4:\n/// >>> pluck(arr: [5, 0, 3,\
    \ 0, 4, 2])\n/// [0, 1]\n/// Explanation: 0 is the smallest value, but  there\
    \ are two zeros,\n/// so we will choose the first zero, which has the smallest\
    \ index.\n/// Constraints:\n/// * 1 <= nodes.length <= 10000\n/// * 0 <= node.value\n\
    func pluck(arr: [Int]) -> [Int] {\n    // Good luck!\n    guard arr.count > 0\
    \ else {\n        return []\n    }\n    var min = Int.max\n    var minIndex =\
    \ 0\n    for (index, element) in arr.enumerated() {\n        if element % 2 ==\
    \ 0 && element < min {\n            min = element\n            minIndex = index\n\
    \        }\n    }\n    return min == Int.max ? [] : [min, minIndex]\n}\n\n\nfunc\
    \ ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count !=\
    \ right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(pluck(arr: [4, 2, 3]) == [2, 1])\nassert(pluck(arr:\
    \ [1, 2, 3]) == [2, 1])\nassert(pluck(arr: [] as [Int]) == [] as [Int])\nassert(pluck(arr:\
    \ [5, 0, 3, 0, 4, 2]) == [0, 1])\nassert(pluck(arr: [1, 2, 3, 0, 5, 3]) == [0,\
    \ 3])\nassert(pluck(arr: [5, 4, 8, 4, 8]) == [4, 1])\nassert(pluck(arr: [7, 6,\
    \ 7, 1]) == [6, 1])\nassert(pluck(arr: [7, 9, 7, 1]) == [] as [Int])"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660013549
- exit_code: -4
  program: "\n/// \"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n/// your task is to pluck one of the nodes and return it.\n///\
    \ The plucked node should be the node with the smallest even value.\n/// If multiple\
    \ nodes with the same smallest even value are found return the node that has smallest\
    \ index.\n/// The plucked node should be returned in an array, [ smalest_value,\
    \ its index ],\n/// If there are no even values or the given array is empty, return\
    \ [].\n/// Example 1:\n/// >>> pluck(arr: [4, 2, 3])\n/// [2, 1]\n/// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n/// Example 2:\n\
    /// >>> pluck(arr: [1, 2, 3])\n/// [2, 1]\n/// Explanation: 2 has the smallest\
    \ even value, and 2 has the smallest index.\n/// Example 3:\n/// >>> pluck(arr:\
    \ [] as [Int])\n/// [] as [Int]\n/// Example 4:\n/// >>> pluck(arr: [5, 0, 3,\
    \ 0, 4, 2])\n/// [0, 1]\n/// Explanation: 0 is the smallest value, but  there\
    \ are two zeros,\n/// so we will choose the first zero, which has the smallest\
    \ index.\n/// Constraints:\n/// * 1 <= nodes.length <= 10000\n/// * 0 <= node.value\n\
    func pluck(arr: [Int]) -> [Int] {\n    guard !arr.isEmpty else { return [] }\n\
    \    var evens = arr.filter { $0 % 2 == 0 }\n    evens.sort()\n    let smallestEven\
    \ = evens.first!\n    let index = arr.firstIndex(of: smallestEven)!\n    return\
    \ [smallestEven, index]\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(pluck(arr:\
    \ [4, 2, 3]) == [2, 1])\nassert(pluck(arr: [1, 2, 3]) == [2, 1])\nassert(pluck(arr:\
    \ [] as [Int]) == [] as [Int])\nassert(pluck(arr: [5, 0, 3, 0, 4, 2]) == [0, 1])\n\
    assert(pluck(arr: [1, 2, 3, 0, 5, 3]) == [0, 3])\nassert(pluck(arr: [5, 4, 8,\
    \ 4, 8]) == [4, 1])\nassert(pluck(arr: [7, 6, 7, 1]) == [6, 1])\nassert(pluck(arr:\
    \ [7, 9, 7, 1]) == [] as [Int])"
  status: Exception
  stderr: 'tmplfysd21r/tmplfysd21r.swift:31: Fatal error: Unexpectedly found nil while
    unwrapping an Optional value

    Current stack trace:

    0    libswiftCore.so                    0x00002aaaf659bc80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002aaaf6292561 <unavailable> + 1434977

    2    libswiftCore.so                    0x00002aaaf6292286 <unavailable> + 1434246

    3    libswiftCore.so                    0x00002aaaf629213c <unavailable> + 1433916

    4    libswiftCore.so                    0x00002aaaf6291bb0 _assertionFailure(_:_:file:line:flags:)
    + 251

    5    tmplfysd21r                        0x00005556042e1254 <unavailable> + 8788

    6    tmplfysd21r                        0x00005556042e0f58 <unavailable> + 8024

    7    libc.so.6                          0x00002aaaf6787460 __libc_start_main +
    245

    8    tmplfysd21r                        0x00005556042e03a9 <unavailable> + 5033

    '
  stdout: ''
  timestamp: 1660013549
- exit_code: -4
  program: "\n/// \"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n/// your task is to pluck one of the nodes and return it.\n///\
    \ The plucked node should be the node with the smallest even value.\n/// If multiple\
    \ nodes with the same smallest even value are found return the node that has smallest\
    \ index.\n/// The plucked node should be returned in an array, [ smalest_value,\
    \ its index ],\n/// If there are no even values or the given array is empty, return\
    \ [].\n/// Example 1:\n/// >>> pluck(arr: [4, 2, 3])\n/// [2, 1]\n/// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n/// Example 2:\n\
    /// >>> pluck(arr: [1, 2, 3])\n/// [2, 1]\n/// Explanation: 2 has the smallest\
    \ even value, and 2 has the smallest index.\n/// Example 3:\n/// >>> pluck(arr:\
    \ [] as [Int])\n/// [] as [Int]\n/// Example 4:\n/// >>> pluck(arr: [5, 0, 3,\
    \ 0, 4, 2])\n/// [0, 1]\n/// Explanation: 0 is the smallest value, but  there\
    \ are two zeros,\n/// so we will choose the first zero, which has the smallest\
    \ index.\n/// Constraints:\n/// * 1 <= nodes.length <= 10000\n/// * 0 <= node.value\n\
    func pluck(arr: [Int]) -> [Int] {\n    // your code goes here\n    return []\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(pluck(arr: [4, 2, 3]) == [2, 1])\nassert(pluck(arr:\
    \ [1, 2, 3]) == [2, 1])\nassert(pluck(arr: [] as [Int]) == [] as [Int])\nassert(pluck(arr:\
    \ [5, 0, 3, 0, 4, 2]) == [0, 1])\nassert(pluck(arr: [1, 2, 3, 0, 5, 3]) == [0,\
    \ 3])\nassert(pluck(arr: [5, 4, 8, 4, 8]) == [4, 1])\nassert(pluck(arr: [7, 6,\
    \ 7, 1]) == [6, 1])\nassert(pluck(arr: [7, 9, 7, 1]) == [] as [Int])"
  status: Exception
  stderr: 'tmpccl11w_z/tmpccl11w_z.swift:45: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002ab66cf58c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002ab66cc4fb6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002ab66cc4f988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002ab66cc4e7b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpccl11w_z                        0x000055e0b443f3bc <unavailable> + 5052

    5    libc.so.6                          0x00002ab66d144460 __libc_start_main +
    245

    6    tmpccl11w_z                        0x000055e0b443efc9 <unavailable> + 4041

    '
  stdout: ''
  timestamp: 1660013549
- exit_code: 0
  program: "\n/// \"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n/// your task is to pluck one of the nodes and return it.\n///\
    \ The plucked node should be the node with the smallest even value.\n/// If multiple\
    \ nodes with the same smallest even value are found return the node that has smallest\
    \ index.\n/// The plucked node should be returned in an array, [ smalest_value,\
    \ its index ],\n/// If there are no even values or the given array is empty, return\
    \ [].\n/// Example 1:\n/// >>> pluck(arr: [4, 2, 3])\n/// [2, 1]\n/// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n/// Example 2:\n\
    /// >>> pluck(arr: [1, 2, 3])\n/// [2, 1]\n/// Explanation: 2 has the smallest\
    \ even value, and 2 has the smallest index.\n/// Example 3:\n/// >>> pluck(arr:\
    \ [] as [Int])\n/// [] as [Int]\n/// Example 4:\n/// >>> pluck(arr: [5, 0, 3,\
    \ 0, 4, 2])\n/// [0, 1]\n/// Explanation: 0 is the smallest value, but  there\
    \ are two zeros,\n/// so we will choose the first zero, which has the smallest\
    \ index.\n/// Constraints:\n/// * 1 <= nodes.length <= 10000\n/// * 0 <= node.value\n\
    func pluck(arr: [Int]) -> [Int] {\n    var evenVals = [Int]()\n    for num in\
    \ arr {\n        if num % 2 == 0 {\n            evenVals.append(num)\n       \
    \ }\n    }\n    if evenVals.count > 0 {\n        let minNum = evenVals.min()\n\
    \        for num in arr {\n            if num == minNum {\n                return\
    \ [num, arr.firstIndex(of: num)!]\n            }\n        }\n    }\n    return\
    \ []\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if\
    \ left.count != right.count {\n        return false\n    }\n    for (l, r) in\
    \ zip(left, right) {\n        if l != r {\n            return false\n        }\n\
    \    }\n    return true\n}\n            \nassert(pluck(arr: [4, 2, 3]) == [2,\
    \ 1])\nassert(pluck(arr: [1, 2, 3]) == [2, 1])\nassert(pluck(arr: [] as [Int])\
    \ == [] as [Int])\nassert(pluck(arr: [5, 0, 3, 0, 4, 2]) == [0, 1])\nassert(pluck(arr:\
    \ [1, 2, 3, 0, 5, 3]) == [0, 3])\nassert(pluck(arr: [5, 4, 8, 4, 8]) == [4, 1])\n\
    assert(pluck(arr: [7, 6, 7, 1]) == [6, 1])\nassert(pluck(arr: [7, 9, 7, 1]) ==\
    \ [] as [Int])"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660013549
- exit_code: 0
  program: "\n/// \"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n/// your task is to pluck one of the nodes and return it.\n///\
    \ The plucked node should be the node with the smallest even value.\n/// If multiple\
    \ nodes with the same smallest even value are found return the node that has smallest\
    \ index.\n/// The plucked node should be returned in an array, [ smalest_value,\
    \ its index ],\n/// If there are no even values or the given array is empty, return\
    \ [].\n/// Example 1:\n/// >>> pluck(arr: [4, 2, 3])\n/// [2, 1]\n/// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n/// Example 2:\n\
    /// >>> pluck(arr: [1, 2, 3])\n/// [2, 1]\n/// Explanation: 2 has the smallest\
    \ even value, and 2 has the smallest index.\n/// Example 3:\n/// >>> pluck(arr:\
    \ [] as [Int])\n/// [] as [Int]\n/// Example 4:\n/// >>> pluck(arr: [5, 0, 3,\
    \ 0, 4, 2])\n/// [0, 1]\n/// Explanation: 0 is the smallest value, but  there\
    \ are two zeros,\n/// so we will choose the first zero, which has the smallest\
    \ index.\n/// Constraints:\n/// * 1 <= nodes.length <= 10000\n/// * 0 <= node.value\n\
    func pluck(arr: [Int]) -> [Int] {\n    // Guard against empty array and non-positive\
    \ numbers\n    guard !arr.isEmpty, arr.allSatisfy({ $0 >= 0 }) else { return []\
    \ }\n    var evenNumbers = arr.filter({ $0 % 2 == 0 })\n    // If no even numbers\
    \ are found, return empty array\n    guard !evenNumbers.isEmpty else { return\
    \ [] }\n    // Find the smallest even number\n    let smallestNumber = evenNumbers.min()!\n\
    \    // Find the index of the smallest even number\n    let smallestNumberIndex\
    \ = arr.firstIndex(of: smallestNumber)!\n    return [smallestNumber, smallestNumberIndex]\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(pluck(arr: [4, 2, 3]) == [2, 1])\nassert(pluck(arr:\
    \ [1, 2, 3]) == [2, 1])\nassert(pluck(arr: [] as [Int]) == [] as [Int])\nassert(pluck(arr:\
    \ [5, 0, 3, 0, 4, 2]) == [0, 1])\nassert(pluck(arr: [1, 2, 3, 0, 5, 3]) == [0,\
    \ 3])\nassert(pluck(arr: [5, 4, 8, 4, 8]) == [4, 1])\nassert(pluck(arr: [7, 6,\
    \ 7, 1]) == [6, 1])\nassert(pluck(arr: [7, 9, 7, 1]) == [] as [Int])"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660013549
- exit_code: 0
  program: "\n/// \"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n/// your task is to pluck one of the nodes and return it.\n///\
    \ The plucked node should be the node with the smallest even value.\n/// If multiple\
    \ nodes with the same smallest even value are found return the node that has smallest\
    \ index.\n/// The plucked node should be returned in an array, [ smalest_value,\
    \ its index ],\n/// If there are no even values or the given array is empty, return\
    \ [].\n/// Example 1:\n/// >>> pluck(arr: [4, 2, 3])\n/// [2, 1]\n/// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n/// Example 2:\n\
    /// >>> pluck(arr: [1, 2, 3])\n/// [2, 1]\n/// Explanation: 2 has the smallest\
    \ even value, and 2 has the smallest index.\n/// Example 3:\n/// >>> pluck(arr:\
    \ [] as [Int])\n/// [] as [Int]\n/// Example 4:\n/// >>> pluck(arr: [5, 0, 3,\
    \ 0, 4, 2])\n/// [0, 1]\n/// Explanation: 0 is the smallest value, but  there\
    \ are two zeros,\n/// so we will choose the first zero, which has the smallest\
    \ index.\n/// Constraints:\n/// * 1 <= nodes.length <= 10000\n/// * 0 <= node.value\n\
    func pluck(arr: [Int]) -> [Int] {\n    guard !arr.isEmpty else { return [] }\n\
    \    guard let evenVal = arr.filter({ $0 % 2 == 0 }).min() else { return [] }\n\
    \    return [evenVal, arr.firstIndex(of: evenVal)!]\n}\n\n\nfunc ==(left: [(Int,\
    \ Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n\
    \        return false\n    }\n    for (l, r) in zip(left, right) {\n        if\
    \ l != r {\n            return false\n        }\n    }\n    return true\n}\n \
    \           \nassert(pluck(arr: [4, 2, 3]) == [2, 1])\nassert(pluck(arr: [1, 2,\
    \ 3]) == [2, 1])\nassert(pluck(arr: [] as [Int]) == [] as [Int])\nassert(pluck(arr:\
    \ [5, 0, 3, 0, 4, 2]) == [0, 1])\nassert(pluck(arr: [1, 2, 3, 0, 5, 3]) == [0,\
    \ 3])\nassert(pluck(arr: [5, 4, 8, 4, 8]) == [4, 1])\nassert(pluck(arr: [7, 6,\
    \ 7, 1]) == [6, 1])\nassert(pluck(arr: [7, 9, 7, 1]) == [] as [Int])"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660013549
- exit_code: -4
  program: "\n/// \"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n/// your task is to pluck one of the nodes and return it.\n///\
    \ The plucked node should be the node with the smallest even value.\n/// If multiple\
    \ nodes with the same smallest even value are found return the node that has smallest\
    \ index.\n/// The plucked node should be returned in an array, [ smalest_value,\
    \ its index ],\n/// If there are no even values or the given array is empty, return\
    \ [].\n/// Example 1:\n/// >>> pluck(arr: [4, 2, 3])\n/// [2, 1]\n/// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n/// Example 2:\n\
    /// >>> pluck(arr: [1, 2, 3])\n/// [2, 1]\n/// Explanation: 2 has the smallest\
    \ even value, and 2 has the smallest index.\n/// Example 3:\n/// >>> pluck(arr:\
    \ [] as [Int])\n/// [] as [Int]\n/// Example 4:\n/// >>> pluck(arr: [5, 0, 3,\
    \ 0, 4, 2])\n/// [0, 1]\n/// Explanation: 0 is the smallest value, but  there\
    \ are two zeros,\n/// so we will choose the first zero, which has the smallest\
    \ index.\n/// Constraints:\n/// * 1 <= nodes.length <= 10000\n/// * 0 <= node.value\n\
    func pluck(arr: [Int]) -> [Int] {\n    \n    let evens = arr.filter { $0 % 2 ==\
    \ 0 }\n    guard let smallestEven = evens.first else { return [] }\n    let evensMinIndices\
    \ = arr.enumerated().filter { $0.element == smallestEven }\n    guard let smallestEvenIndex\
    \ = evensMinIndices.first?.offset else { return [] }\n    return [smallestEven,\
    \ smallestEvenIndex]\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(pluck(arr:\
    \ [4, 2, 3]) == [2, 1])\nassert(pluck(arr: [1, 2, 3]) == [2, 1])\nassert(pluck(arr:\
    \ [] as [Int]) == [] as [Int])\nassert(pluck(arr: [5, 0, 3, 0, 4, 2]) == [0, 1])\n\
    assert(pluck(arr: [1, 2, 3, 0, 5, 3]) == [0, 3])\nassert(pluck(arr: [5, 4, 8,\
    \ 4, 8]) == [4, 1])\nassert(pluck(arr: [7, 6, 7, 1]) == [6, 1])\nassert(pluck(arr:\
    \ [7, 9, 7, 1]) == [] as [Int])"
  status: Exception
  stderr: 'tmpvfeau9fu/tmpvfeau9fu.swift:49: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002ba509913c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002ba50960ab6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002ba50960a988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002ba5096097b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpvfeau9fu                        0x000056304f2cf72c <unavailable> + 5932

    5    libc.so.6                          0x00002ba509aff460 __libc_start_main +
    245

    6    tmpvfeau9fu                        0x000056304f2cf339 <unavailable> + 4921

    '
  stdout: ''
  timestamp: 1660013549
- exit_code: -4
  program: "\n/// \"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n/// your task is to pluck one of the nodes and return it.\n///\
    \ The plucked node should be the node with the smallest even value.\n/// If multiple\
    \ nodes with the same smallest even value are found return the node that has smallest\
    \ index.\n/// The plucked node should be returned in an array, [ smalest_value,\
    \ its index ],\n/// If there are no even values or the given array is empty, return\
    \ [].\n/// Example 1:\n/// >>> pluck(arr: [4, 2, 3])\n/// [2, 1]\n/// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n/// Example 2:\n\
    /// >>> pluck(arr: [1, 2, 3])\n/// [2, 1]\n/// Explanation: 2 has the smallest\
    \ even value, and 2 has the smallest index.\n/// Example 3:\n/// >>> pluck(arr:\
    \ [] as [Int])\n/// [] as [Int]\n/// Example 4:\n/// >>> pluck(arr: [5, 0, 3,\
    \ 0, 4, 2])\n/// [0, 1]\n/// Explanation: 0 is the smallest value, but  there\
    \ are two zeros,\n/// so we will choose the first zero, which has the smallest\
    \ index.\n/// Constraints:\n/// * 1 <= nodes.length <= 10000\n/// * 0 <= node.value\n\
    func pluck(arr: [Int]) -> [Int] {\n    return [0, 1]\n}\n\n\nfunc ==(left: [(Int,\
    \ Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n\
    \        return false\n    }\n    for (l, r) in zip(left, right) {\n        if\
    \ l != r {\n            return false\n        }\n    }\n    return true\n}\n \
    \           \nassert(pluck(arr: [4, 2, 3]) == [2, 1])\nassert(pluck(arr: [1, 2,\
    \ 3]) == [2, 1])\nassert(pluck(arr: [] as [Int]) == [] as [Int])\nassert(pluck(arr:\
    \ [5, 0, 3, 0, 4, 2]) == [0, 1])\nassert(pluck(arr: [1, 2, 3, 0, 5, 3]) == [0,\
    \ 3])\nassert(pluck(arr: [5, 4, 8, 4, 8]) == [4, 1])\nassert(pluck(arr: [7, 6,\
    \ 7, 1]) == [6, 1])\nassert(pluck(arr: [7, 9, 7, 1]) == [] as [Int])"
  status: Exception
  stderr: 'tmpk0rub24m/tmpk0rub24m.swift:44: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b5d49d14c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b5d49a0bb6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b5d49a0b988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b5d49a0a7b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpk0rub24m                        0x0000563457e7e3bc <unavailable> + 5052

    5    libc.so.6                          0x00002b5d49f00460 __libc_start_main +
    245

    6    tmpk0rub24m                        0x0000563457e7dfc9 <unavailable> + 4041

    '
  stdout: ''
  timestamp: 1660013549
- exit_code: -4
  program: "\n/// \"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n/// your task is to pluck one of the nodes and return it.\n///\
    \ The plucked node should be the node with the smallest even value.\n/// If multiple\
    \ nodes with the same smallest even value are found return the node that has smallest\
    \ index.\n/// The plucked node should be returned in an array, [ smalest_value,\
    \ its index ],\n/// If there are no even values or the given array is empty, return\
    \ [].\n/// Example 1:\n/// >>> pluck(arr: [4, 2, 3])\n/// [2, 1]\n/// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n/// Example 2:\n\
    /// >>> pluck(arr: [1, 2, 3])\n/// [2, 1]\n/// Explanation: 2 has the smallest\
    \ even value, and 2 has the smallest index.\n/// Example 3:\n/// >>> pluck(arr:\
    \ [] as [Int])\n/// [] as [Int]\n/// Example 4:\n/// >>> pluck(arr: [5, 0, 3,\
    \ 0, 4, 2])\n/// [0, 1]\n/// Explanation: 0 is the smallest value, but  there\
    \ are two zeros,\n/// so we will choose the first zero, which has the smallest\
    \ index.\n/// Constraints:\n/// * 1 <= nodes.length <= 10000\n/// * 0 <= node.value\n\
    func pluck(arr: [Int]) -> [Int] {\n    return [0, 0]\n}\n\n\nfunc ==(left: [(Int,\
    \ Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n\
    \        return false\n    }\n    for (l, r) in zip(left, right) {\n        if\
    \ l != r {\n            return false\n        }\n    }\n    return true\n}\n \
    \           \nassert(pluck(arr: [4, 2, 3]) == [2, 1])\nassert(pluck(arr: [1, 2,\
    \ 3]) == [2, 1])\nassert(pluck(arr: [] as [Int]) == [] as [Int])\nassert(pluck(arr:\
    \ [5, 0, 3, 0, 4, 2]) == [0, 1])\nassert(pluck(arr: [1, 2, 3, 0, 5, 3]) == [0,\
    \ 3])\nassert(pluck(arr: [5, 4, 8, 4, 8]) == [4, 1])\nassert(pluck(arr: [7, 6,\
    \ 7, 1]) == [6, 1])\nassert(pluck(arr: [7, 9, 7, 1]) == [] as [Int])"
  status: Exception
  stderr: 'tmpwi4qxf9l/tmpwi4qxf9l.swift:44: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b70c6e43c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b70c6b3ab6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b70c6b3a988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b70c6b397b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpwi4qxf9l                        0x00005583b9af23bc <unavailable> + 5052

    5    libc.so.6                          0x00002b70c702f460 __libc_start_main +
    245

    6    tmpwi4qxf9l                        0x00005583b9af1fc9 <unavailable> + 4041

    '
  stdout: ''
  timestamp: 1660013549
- exit_code: 0
  program: "\n/// \"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n/// your task is to pluck one of the nodes and return it.\n///\
    \ The plucked node should be the node with the smallest even value.\n/// If multiple\
    \ nodes with the same smallest even value are found return the node that has smallest\
    \ index.\n/// The plucked node should be returned in an array, [ smalest_value,\
    \ its index ],\n/// If there are no even values or the given array is empty, return\
    \ [].\n/// Example 1:\n/// >>> pluck(arr: [4, 2, 3])\n/// [2, 1]\n/// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n/// Example 2:\n\
    /// >>> pluck(arr: [1, 2, 3])\n/// [2, 1]\n/// Explanation: 2 has the smallest\
    \ even value, and 2 has the smallest index.\n/// Example 3:\n/// >>> pluck(arr:\
    \ [] as [Int])\n/// [] as [Int]\n/// Example 4:\n/// >>> pluck(arr: [5, 0, 3,\
    \ 0, 4, 2])\n/// [0, 1]\n/// Explanation: 0 is the smallest value, but  there\
    \ are two zeros,\n/// so we will choose the first zero, which has the smallest\
    \ index.\n/// Constraints:\n/// * 1 <= nodes.length <= 10000\n/// * 0 <= node.value\n\
    func pluck(arr: [Int]) -> [Int] {\n    var result = [Int]()\n    var evens = [Int]()\n\
    \    var evensIndex = [Int]()\n    var min = Int.max\n    // \u043D\u0430\u0445\
    \u043E\u0434\u0438\u043C \u043C\u0438\u043D\u0438\u043C\u0430\u043B\u044C\u043D\
    \u043E\u0435 \u0447\u0435\u0442\u043D\u043E\u0435 \u0447\u0438\u0441\u043B\u043E\
    \ \u0438 \u0435\u0433\u043E \u0438\u043D\u0434\u0435\u043A\u0441\n    for i in\
    \ 0..<arr.count {\n        if arr[i] % 2 == 0 {\n            evens.append(arr[i])\n\
    \            evensIndex.append(i)\n            if min > arr[i] {\n           \
    \     min = arr[i]\n            }\n        }\n    }\n    if min == Int.max {\n\
    \        return result\n    }\n    // \u043D\u0430\u0445\u043E\u0434\u0438\u043C\
    \ \u0438\u043D\u0434\u0435\u043A\u0441 \u043C\u0438\u043D\u0438\u043C\u0430\u043B\
    \u044C\u043D\u043E\u0433\u043E \u0447\u0435\u0442\u043D\u043E\u0433\u043E \u0447\
    \u0438\u0441\u043B\u0430\n    let minIndex = evensIndex[evens.firstIndex(of: min)!]\n\
    \    result.append(min)\n    result.append(minIndex)\n    return result\n}\n\n\
    \nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(pluck(arr: [4, 2, 3]) == [2, 1])\nassert(pluck(arr:\
    \ [1, 2, 3]) == [2, 1])\nassert(pluck(arr: [] as [Int]) == [] as [Int])\nassert(pluck(arr:\
    \ [5, 0, 3, 0, 4, 2]) == [0, 1])\nassert(pluck(arr: [1, 2, 3, 0, 5, 3]) == [0,\
    \ 3])\nassert(pluck(arr: [5, 4, 8, 4, 8]) == [4, 1])\nassert(pluck(arr: [7, 6,\
    \ 7, 1]) == [6, 1])\nassert(pluck(arr: [7, 9, 7, 1]) == [] as [Int])"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660013549
- exit_code: 0
  program: "\n/// \"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n/// your task is to pluck one of the nodes and return it.\n///\
    \ The plucked node should be the node with the smallest even value.\n/// If multiple\
    \ nodes with the same smallest even value are found return the node that has smallest\
    \ index.\n/// The plucked node should be returned in an array, [ smalest_value,\
    \ its index ],\n/// If there are no even values or the given array is empty, return\
    \ [].\n/// Example 1:\n/// >>> pluck(arr: [4, 2, 3])\n/// [2, 1]\n/// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n/// Example 2:\n\
    /// >>> pluck(arr: [1, 2, 3])\n/// [2, 1]\n/// Explanation: 2 has the smallest\
    \ even value, and 2 has the smallest index.\n/// Example 3:\n/// >>> pluck(arr:\
    \ [] as [Int])\n/// [] as [Int]\n/// Example 4:\n/// >>> pluck(arr: [5, 0, 3,\
    \ 0, 4, 2])\n/// [0, 1]\n/// Explanation: 0 is the smallest value, but  there\
    \ are two zeros,\n/// so we will choose the first zero, which has the smallest\
    \ index.\n/// Constraints:\n/// * 1 <= nodes.length <= 10000\n/// * 0 <= node.value\n\
    func pluck(arr: [Int]) -> [Int] {\n    let evens = arr.filter { $0 % 2 == 0 }\n\
    \    guard let smallestEven = evens.min() else { return [] }\n    let idx = arr.firstIndex(of:\
    \ smallestEven) ?? 0\n    return [smallestEven, idx]\n}\n\n\nfunc ==(left: [(Int,\
    \ Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n\
    \        return false\n    }\n    for (l, r) in zip(left, right) {\n        if\
    \ l != r {\n            return false\n        }\n    }\n    return true\n}\n \
    \           \nassert(pluck(arr: [4, 2, 3]) == [2, 1])\nassert(pluck(arr: [1, 2,\
    \ 3]) == [2, 1])\nassert(pluck(arr: [] as [Int]) == [] as [Int])\nassert(pluck(arr:\
    \ [5, 0, 3, 0, 4, 2]) == [0, 1])\nassert(pluck(arr: [1, 2, 3, 0, 5, 3]) == [0,\
    \ 3])\nassert(pluck(arr: [5, 4, 8, 4, 8]) == [4, 1])\nassert(pluck(arr: [7, 6,\
    \ 7, 1]) == [6, 1])\nassert(pluck(arr: [7, 9, 7, 1]) == [] as [Int])"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660013549
- exit_code: -4
  program: "\n/// \"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n/// your task is to pluck one of the nodes and return it.\n///\
    \ The plucked node should be the node with the smallest even value.\n/// If multiple\
    \ nodes with the same smallest even value are found return the node that has smallest\
    \ index.\n/// The plucked node should be returned in an array, [ smalest_value,\
    \ its index ],\n/// If there are no even values or the given array is empty, return\
    \ [].\n/// Example 1:\n/// >>> pluck(arr: [4, 2, 3])\n/// [2, 1]\n/// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n/// Example 2:\n\
    /// >>> pluck(arr: [1, 2, 3])\n/// [2, 1]\n/// Explanation: 2 has the smallest\
    \ even value, and 2 has the smallest index.\n/// Example 3:\n/// >>> pluck(arr:\
    \ [] as [Int])\n/// [] as [Int]\n/// Example 4:\n/// >>> pluck(arr: [5, 0, 3,\
    \ 0, 4, 2])\n/// [0, 1]\n/// Explanation: 0 is the smallest value, but  there\
    \ are two zeros,\n/// so we will choose the first zero, which has the smallest\
    \ index.\n/// Constraints:\n/// * 1 <= nodes.length <= 10000\n/// * 0 <= node.value\n\
    func pluck(arr: [Int]) -> [Int] {\n    let evens = arr.enumerated().filter { $0.element\
    \ % 2 == 0 }\n    guard !evens.isEmpty else { return [] }\n    let smallest =\
    \ evens.reduce(evens[0]) { $0.element < $1.element ? $0 : $1 }\n    return [smallest.element,\
    \ smallest.offset]\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) ->\
    \ Bool {\n    if left.count != right.count {\n        return false\n    }\n  \
    \  for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(pluck(arr: [4, 2,\
    \ 3]) == [2, 1])\nassert(pluck(arr: [1, 2, 3]) == [2, 1])\nassert(pluck(arr: []\
    \ as [Int]) == [] as [Int])\nassert(pluck(arr: [5, 0, 3, 0, 4, 2]) == [0, 1])\n\
    assert(pluck(arr: [1, 2, 3, 0, 5, 3]) == [0, 3])\nassert(pluck(arr: [5, 4, 8,\
    \ 4, 8]) == [4, 1])\nassert(pluck(arr: [7, 6, 7, 1]) == [6, 1])\nassert(pluck(arr:\
    \ [7, 9, 7, 1]) == [] as [Int])"
  status: Exception
  stderr: 'tmpedu2dw2m/tmpedu2dw2m.swift:50: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b823e07bc80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b823dd72b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b823dd72988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b823dd717b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpedu2dw2m                        0x000055dbe799aa84 <unavailable> + 6788

    5    libc.so.6                          0x00002b823e267460 __libc_start_main +
    245

    6    tmpedu2dw2m                        0x000055dbe799a329 <unavailable> + 4905

    '
  stdout: ''
  timestamp: 1660013549
- exit_code: 0
  program: "\n/// \"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n/// your task is to pluck one of the nodes and return it.\n///\
    \ The plucked node should be the node with the smallest even value.\n/// If multiple\
    \ nodes with the same smallest even value are found return the node that has smallest\
    \ index.\n/// The plucked node should be returned in an array, [ smalest_value,\
    \ its index ],\n/// If there are no even values or the given array is empty, return\
    \ [].\n/// Example 1:\n/// >>> pluck(arr: [4, 2, 3])\n/// [2, 1]\n/// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n/// Example 2:\n\
    /// >>> pluck(arr: [1, 2, 3])\n/// [2, 1]\n/// Explanation: 2 has the smallest\
    \ even value, and 2 has the smallest index.\n/// Example 3:\n/// >>> pluck(arr:\
    \ [] as [Int])\n/// [] as [Int]\n/// Example 4:\n/// >>> pluck(arr: [5, 0, 3,\
    \ 0, 4, 2])\n/// [0, 1]\n/// Explanation: 0 is the smallest value, but  there\
    \ are two zeros,\n/// so we will choose the first zero, which has the smallest\
    \ index.\n/// Constraints:\n/// * 1 <= nodes.length <= 10000\n/// * 0 <= node.value\n\
    func pluck(arr: [Int]) -> [Int] {\n    guard arr.isEmpty == false else { return\
    \ [] }\n    var res: [Int] = []\n    for i in arr.indices {\n        if arr[i]\
    \ % 2 == 0 {\n            res.append(arr[i])\n        }\n    }\n    guard res.isEmpty\
    \ == false else { return [] }\n    res.sort()\n    return [res[0], arr.firstIndex(of:\
    \ res[0]) ?? 0]\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool\
    \ {\n    if left.count != right.count {\n        return false\n    }\n    for\
    \ (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(pluck(arr: [4, 2,\
    \ 3]) == [2, 1])\nassert(pluck(arr: [1, 2, 3]) == [2, 1])\nassert(pluck(arr: []\
    \ as [Int]) == [] as [Int])\nassert(pluck(arr: [5, 0, 3, 0, 4, 2]) == [0, 1])\n\
    assert(pluck(arr: [1, 2, 3, 0, 5, 3]) == [0, 3])\nassert(pluck(arr: [5, 4, 8,\
    \ 4, 8]) == [4, 1])\nassert(pluck(arr: [7, 6, 7, 1]) == [6, 1])\nassert(pluck(arr:\
    \ [7, 9, 7, 1]) == [] as [Int])"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660013549
- exit_code: 0
  program: "\n/// \"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n/// your task is to pluck one of the nodes and return it.\n///\
    \ The plucked node should be the node with the smallest even value.\n/// If multiple\
    \ nodes with the same smallest even value are found return the node that has smallest\
    \ index.\n/// The plucked node should be returned in an array, [ smalest_value,\
    \ its index ],\n/// If there are no even values or the given array is empty, return\
    \ [].\n/// Example 1:\n/// >>> pluck(arr: [4, 2, 3])\n/// [2, 1]\n/// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n/// Example 2:\n\
    /// >>> pluck(arr: [1, 2, 3])\n/// [2, 1]\n/// Explanation: 2 has the smallest\
    \ even value, and 2 has the smallest index.\n/// Example 3:\n/// >>> pluck(arr:\
    \ [] as [Int])\n/// [] as [Int]\n/// Example 4:\n/// >>> pluck(arr: [5, 0, 3,\
    \ 0, 4, 2])\n/// [0, 1]\n/// Explanation: 0 is the smallest value, but  there\
    \ are two zeros,\n/// so we will choose the first zero, which has the smallest\
    \ index.\n/// Constraints:\n/// * 1 <= nodes.length <= 10000\n/// * 0 <= node.value\n\
    func pluck(arr: [Int]) -> [Int] {\n    var min = Int.max\n    var result = [Int]()\n\
    \    for i in 0..<arr.count {\n        if arr[i] % 2 == 0 {\n            if arr[i]\
    \ < min {\n                min = arr[i]\n                result = [min, i]\n \
    \           }\n        }\n    }\n    return result.isEmpty ? [] : result\n}\n\n\
    \nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(pluck(arr: [4, 2, 3]) == [2, 1])\nassert(pluck(arr:\
    \ [1, 2, 3]) == [2, 1])\nassert(pluck(arr: [] as [Int]) == [] as [Int])\nassert(pluck(arr:\
    \ [5, 0, 3, 0, 4, 2]) == [0, 1])\nassert(pluck(arr: [1, 2, 3, 0, 5, 3]) == [0,\
    \ 3])\nassert(pluck(arr: [5, 4, 8, 4, 8]) == [4, 1])\nassert(pluck(arr: [7, 6,\
    \ 7, 1]) == [6, 1])\nassert(pluck(arr: [7, 9, 7, 1]) == [] as [Int])"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660013549
- exit_code: 1
  program: "\n/// \"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n/// your task is to pluck one of the nodes and return it.\n///\
    \ The plucked node should be the node with the smallest even value.\n/// If multiple\
    \ nodes with the same smallest even value are found return the node that has smallest\
    \ index.\n/// The plucked node should be returned in an array, [ smalest_value,\
    \ its index ],\n/// If there are no even values or the given array is empty, return\
    \ [].\n/// Example 1:\n/// >>> pluck(arr: [4, 2, 3])\n/// [2, 1]\n/// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n/// Example 2:\n\
    /// >>> pluck(arr: [1, 2, 3])\n/// [2, 1]\n/// Explanation: 2 has the smallest\
    \ even value, and 2 has the smallest index.\n/// Example 3:\n/// >>> pluck(arr:\
    \ [] as [Int])\n/// [] as [Int]\n/// Example 4:\n/// >>> pluck(arr: [5, 0, 3,\
    \ 0, 4, 2])\n/// [0, 1]\n/// Explanation: 0 is the smallest value, but  there\
    \ are two zeros,\n/// so we will choose the first zero, which has the smallest\
    \ index.\n/// Constraints:\n/// * 1 <= nodes.length <= 10000\n/// * 0 <= node.value\n\
    func pluck(arr: [Int]) -> [Int] {\n    let evens = arr.enumerated().filter { $0.element\
    \ % 2 == 0 }\n    return evens.isEmpty ? [] : evens.sorted { $0.element < $1.element\
    \ }.first!\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n\
    \    if left.count != right.count {\n        return false\n    }\n    for (l,\
    \ r) in zip(left, right) {\n        if l != r {\n            return false\n  \
    \      }\n    }\n    return true\n}\n            \nassert(pluck(arr: [4, 2, 3])\
    \ == [2, 1])\nassert(pluck(arr: [1, 2, 3]) == [2, 1])\nassert(pluck(arr: [] as\
    \ [Int]) == [] as [Int])\nassert(pluck(arr: [5, 0, 3, 0, 4, 2]) == [0, 1])\nassert(pluck(arr:\
    \ [1, 2, 3, 0, 5, 3]) == [0, 3])\nassert(pluck(arr: [5, 4, 8, 4, 8]) == [4, 1])\n\
    assert(pluck(arr: [7, 6, 7, 1]) == [6, 1])\nassert(pluck(arr: [7, 9, 7, 1]) ==\
    \ [] as [Int])"
  status: SyntaxError
  stderr: "/tmp/tmp4aw14efs.swift:29:26: error: cannot convert return expression of\
    \ type 'EnumeratedSequence<[Int]>.Iterator.Element' (aka '(offset: Int, element:\
    \ Int)') to return type '[Int]'\n    return evens.isEmpty ? [] : evens.sorted\
    \ { $0.element < $1.element }.first!\n           ~~~~~~~~~~~~~~^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n"
  stdout: ''
  timestamp: 1660013549
- exit_code: 0
  program: "\n/// \"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n/// your task is to pluck one of the nodes and return it.\n///\
    \ The plucked node should be the node with the smallest even value.\n/// If multiple\
    \ nodes with the same smallest even value are found return the node that has smallest\
    \ index.\n/// The plucked node should be returned in an array, [ smalest_value,\
    \ its index ],\n/// If there are no even values or the given array is empty, return\
    \ [].\n/// Example 1:\n/// >>> pluck(arr: [4, 2, 3])\n/// [2, 1]\n/// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n/// Example 2:\n\
    /// >>> pluck(arr: [1, 2, 3])\n/// [2, 1]\n/// Explanation: 2 has the smallest\
    \ even value, and 2 has the smallest index.\n/// Example 3:\n/// >>> pluck(arr:\
    \ [] as [Int])\n/// [] as [Int]\n/// Example 4:\n/// >>> pluck(arr: [5, 0, 3,\
    \ 0, 4, 2])\n/// [0, 1]\n/// Explanation: 0 is the smallest value, but  there\
    \ are two zeros,\n/// so we will choose the first zero, which has the smallest\
    \ index.\n/// Constraints:\n/// * 1 <= nodes.length <= 10000\n/// * 0 <= node.value\n\
    func pluck(arr: [Int]) -> [Int] {\n    if arr.count == 0 {\n        return []\n\
    \    }\n\n    var lowestEvenIndex = -1\n    var lowestEvenValue = -1\n    for\
    \ (index, value) in arr.enumerated() {\n        if value % 2 == 0 {\n        \
    \    if lowestEvenIndex == -1 {\n                lowestEvenIndex = index\n   \
    \             lowestEvenValue = value\n            } else if value < lowestEvenValue\
    \ {\n                lowestEvenIndex = index\n                lowestEvenValue\
    \ = value\n            }\n        }\n    }\n\n    return lowestEvenIndex == -1\
    \ ? [] : [lowestEvenValue, lowestEvenIndex]\n}\n\n\nfunc ==(left: [(Int, Int)],\
    \ right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n       \
    \ return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r\
    \ {\n            return false\n        }\n    }\n    return true\n}\n        \
    \    \nassert(pluck(arr: [4, 2, 3]) == [2, 1])\nassert(pluck(arr: [1, 2, 3]) ==\
    \ [2, 1])\nassert(pluck(arr: [] as [Int]) == [] as [Int])\nassert(pluck(arr: [5,\
    \ 0, 3, 0, 4, 2]) == [0, 1])\nassert(pluck(arr: [1, 2, 3, 0, 5, 3]) == [0, 3])\n\
    assert(pluck(arr: [5, 4, 8, 4, 8]) == [4, 1])\nassert(pluck(arr: [7, 6, 7, 1])\
    \ == [6, 1])\nassert(pluck(arr: [7, 9, 7, 1]) == [] as [Int])"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660013549
- exit_code: -4
  program: "\n/// \"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n/// your task is to pluck one of the nodes and return it.\n///\
    \ The plucked node should be the node with the smallest even value.\n/// If multiple\
    \ nodes with the same smallest even value are found return the node that has smallest\
    \ index.\n/// The plucked node should be returned in an array, [ smalest_value,\
    \ its index ],\n/// If there are no even values or the given array is empty, return\
    \ [].\n/// Example 1:\n/// >>> pluck(arr: [4, 2, 3])\n/// [2, 1]\n/// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n/// Example 2:\n\
    /// >>> pluck(arr: [1, 2, 3])\n/// [2, 1]\n/// Explanation: 2 has the smallest\
    \ even value, and 2 has the smallest index.\n/// Example 3:\n/// >>> pluck(arr:\
    \ [] as [Int])\n/// [] as [Int]\n/// Example 4:\n/// >>> pluck(arr: [5, 0, 3,\
    \ 0, 4, 2])\n/// [0, 1]\n/// Explanation: 0 is the smallest value, but  there\
    \ are two zeros,\n/// so we will choose the first zero, which has the smallest\
    \ index.\n/// Constraints:\n/// * 1 <= nodes.length <= 10000\n/// * 0 <= node.value\n\
    func pluck(arr: [Int]) -> [Int] {\n    var values = [Int]()\n    var indexes =\
    \ [Int]()\n    for (index, value) in arr.enumerated() {\n        if value > 0\
    \ && value % 2 == 0 {\n            values.append(value)\n            indexes.append(index)\n\
    \        }\n    }\n    if values.count == 0 {\n        return []\n    }\n    let\
    \ smallestValue = values.min()!\n    let smallestIndex = indexes[values.firstIndex(of:\
    \ smallestValue)!]\n    return [smallestValue, smallestIndex]\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(pluck(arr: [4, 2, 3]) == [2, 1])\nassert(pluck(arr: [1,\
    \ 2, 3]) == [2, 1])\nassert(pluck(arr: [] as [Int]) == [] as [Int])\nassert(pluck(arr:\
    \ [5, 0, 3, 0, 4, 2]) == [0, 1])\nassert(pluck(arr: [1, 2, 3, 0, 5, 3]) == [0,\
    \ 3])\nassert(pluck(arr: [5, 4, 8, 4, 8]) == [4, 1])\nassert(pluck(arr: [7, 6,\
    \ 7, 1]) == [6, 1])\nassert(pluck(arr: [7, 9, 7, 1]) == [] as [Int])"
  status: Exception
  stderr: 'tmpyadv_39p/tmpyadv_39p.swift:60: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002aec62746c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002aec6243db6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002aec6243d988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002aec6243c7b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpyadv_39p                        0x00005594fd7e4c84 <unavailable> + 7300

    5    libc.so.6                          0x00002aec62932460 __libc_start_main +
    245

    6    tmpyadv_39p                        0x00005594fd7e4529 <unavailable> + 5417

    '
  stdout: ''
  timestamp: 1660013549
- exit_code: 0
  program: "\n/// \"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n/// your task is to pluck one of the nodes and return it.\n///\
    \ The plucked node should be the node with the smallest even value.\n/// If multiple\
    \ nodes with the same smallest even value are found return the node that has smallest\
    \ index.\n/// The plucked node should be returned in an array, [ smalest_value,\
    \ its index ],\n/// If there are no even values or the given array is empty, return\
    \ [].\n/// Example 1:\n/// >>> pluck(arr: [4, 2, 3])\n/// [2, 1]\n/// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n/// Example 2:\n\
    /// >>> pluck(arr: [1, 2, 3])\n/// [2, 1]\n/// Explanation: 2 has the smallest\
    \ even value, and 2 has the smallest index.\n/// Example 3:\n/// >>> pluck(arr:\
    \ [] as [Int])\n/// [] as [Int]\n/// Example 4:\n/// >>> pluck(arr: [5, 0, 3,\
    \ 0, 4, 2])\n/// [0, 1]\n/// Explanation: 0 is the smallest value, but  there\
    \ are two zeros,\n/// so we will choose the first zero, which has the smallest\
    \ index.\n/// Constraints:\n/// * 1 <= nodes.length <= 10000\n/// * 0 <= node.value\n\
    func pluck(arr: [Int]) -> [Int] {\n    var min = -1\n    var minIndex = -1\n \
    \   for (index, element) in arr.enumerated() {\n        if element % 2 == 0 {\n\
    \            if min == -1 {\n                min = element\n                minIndex\
    \ = index\n            } else if element < min {\n                min = element\n\
    \                minIndex = index\n            }\n        }\n    }\n    if minIndex\
    \ == -1 {\n        return []\n    }\n    return [min, minIndex]\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(pluck(arr: [4, 2, 3]) == [2, 1])\nassert(pluck(arr: [1,\
    \ 2, 3]) == [2, 1])\nassert(pluck(arr: [] as [Int]) == [] as [Int])\nassert(pluck(arr:\
    \ [5, 0, 3, 0, 4, 2]) == [0, 1])\nassert(pluck(arr: [1, 2, 3, 0, 5, 3]) == [0,\
    \ 3])\nassert(pluck(arr: [5, 4, 8, 4, 8]) == [4, 1])\nassert(pluck(arr: [7, 6,\
    \ 7, 1]) == [6, 1])\nassert(pluck(arr: [7, 9, 7, 1]) == [] as [Int])"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660013549
- exit_code: 0
  program: "\n/// \"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n/// your task is to pluck one of the nodes and return it.\n///\
    \ The plucked node should be the node with the smallest even value.\n/// If multiple\
    \ nodes with the same smallest even value are found return the node that has smallest\
    \ index.\n/// The plucked node should be returned in an array, [ smalest_value,\
    \ its index ],\n/// If there are no even values or the given array is empty, return\
    \ [].\n/// Example 1:\n/// >>> pluck(arr: [4, 2, 3])\n/// [2, 1]\n/// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n/// Example 2:\n\
    /// >>> pluck(arr: [1, 2, 3])\n/// [2, 1]\n/// Explanation: 2 has the smallest\
    \ even value, and 2 has the smallest index.\n/// Example 3:\n/// >>> pluck(arr:\
    \ [] as [Int])\n/// [] as [Int]\n/// Example 4:\n/// >>> pluck(arr: [5, 0, 3,\
    \ 0, 4, 2])\n/// [0, 1]\n/// Explanation: 0 is the smallest value, but  there\
    \ are two zeros,\n/// so we will choose the first zero, which has the smallest\
    \ index.\n/// Constraints:\n/// * 1 <= nodes.length <= 10000\n/// * 0 <= node.value\n\
    func pluck(arr: [Int]) -> [Int] {\n    return arr.filter { $0 % 2 == 0 }.sorted\
    \ { $0 < $1 }.first.map { [$0, arr.firstIndex(of: $0)!] } ?? []\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(pluck(arr: [4, 2, 3]) == [2, 1])\nassert(pluck(arr: [1,\
    \ 2, 3]) == [2, 1])\nassert(pluck(arr: [] as [Int]) == [] as [Int])\nassert(pluck(arr:\
    \ [5, 0, 3, 0, 4, 2]) == [0, 1])\nassert(pluck(arr: [1, 2, 3, 0, 5, 3]) == [0,\
    \ 3])\nassert(pluck(arr: [5, 4, 8, 4, 8]) == [4, 1])\nassert(pluck(arr: [7, 6,\
    \ 7, 1]) == [6, 1])\nassert(pluck(arr: [7, 9, 7, 1]) == [] as [Int])"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660013549
- exit_code: 0
  program: "\n/// \"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n/// your task is to pluck one of the nodes and return it.\n///\
    \ The plucked node should be the node with the smallest even value.\n/// If multiple\
    \ nodes with the same smallest even value are found return the node that has smallest\
    \ index.\n/// The plucked node should be returned in an array, [ smalest_value,\
    \ its index ],\n/// If there are no even values or the given array is empty, return\
    \ [].\n/// Example 1:\n/// >>> pluck(arr: [4, 2, 3])\n/// [2, 1]\n/// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n/// Example 2:\n\
    /// >>> pluck(arr: [1, 2, 3])\n/// [2, 1]\n/// Explanation: 2 has the smallest\
    \ even value, and 2 has the smallest index.\n/// Example 3:\n/// >>> pluck(arr:\
    \ [] as [Int])\n/// [] as [Int]\n/// Example 4:\n/// >>> pluck(arr: [5, 0, 3,\
    \ 0, 4, 2])\n/// [0, 1]\n/// Explanation: 0 is the smallest value, but  there\
    \ are two zeros,\n/// so we will choose the first zero, which has the smallest\
    \ index.\n/// Constraints:\n/// * 1 <= nodes.length <= 10000\n/// * 0 <= node.value\n\
    func pluck(arr: [Int]) -> [Int] {\n    let evens = arr.filter { $0 % 2 == 0 }\n\
    \    if evens.isEmpty { return [] }\n    let smallest = evens.min()!\n    return\
    \ [smallest, arr.firstIndex(of: smallest)!]\n}\n\n\nfunc ==(left: [(Int, Int)],\
    \ right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n       \
    \ return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r\
    \ {\n            return false\n        }\n    }\n    return true\n}\n        \
    \    \nassert(pluck(arr: [4, 2, 3]) == [2, 1])\nassert(pluck(arr: [1, 2, 3]) ==\
    \ [2, 1])\nassert(pluck(arr: [] as [Int]) == [] as [Int])\nassert(pluck(arr: [5,\
    \ 0, 3, 0, 4, 2]) == [0, 1])\nassert(pluck(arr: [1, 2, 3, 0, 5, 3]) == [0, 3])\n\
    assert(pluck(arr: [5, 4, 8, 4, 8]) == [4, 1])\nassert(pluck(arr: [7, 6, 7, 1])\
    \ == [6, 1])\nassert(pluck(arr: [7, 9, 7, 1]) == [] as [Int])"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660013549
- exit_code: 0
  program: "\n/// \"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n/// your task is to pluck one of the nodes and return it.\n///\
    \ The plucked node should be the node with the smallest even value.\n/// If multiple\
    \ nodes with the same smallest even value are found return the node that has smallest\
    \ index.\n/// The plucked node should be returned in an array, [ smalest_value,\
    \ its index ],\n/// If there are no even values or the given array is empty, return\
    \ [].\n/// Example 1:\n/// >>> pluck(arr: [4, 2, 3])\n/// [2, 1]\n/// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n/// Example 2:\n\
    /// >>> pluck(arr: [1, 2, 3])\n/// [2, 1]\n/// Explanation: 2 has the smallest\
    \ even value, and 2 has the smallest index.\n/// Example 3:\n/// >>> pluck(arr:\
    \ [] as [Int])\n/// [] as [Int]\n/// Example 4:\n/// >>> pluck(arr: [5, 0, 3,\
    \ 0, 4, 2])\n/// [0, 1]\n/// Explanation: 0 is the smallest value, but  there\
    \ are two zeros,\n/// so we will choose the first zero, which has the smallest\
    \ index.\n/// Constraints:\n/// * 1 <= nodes.length <= 10000\n/// * 0 <= node.value\n\
    func pluck(arr: [Int]) -> [Int] {\n    if arr.isEmpty {\n        return []\n \
    \   }\n    var min = Int.max\n    var result = [Int]()\n    for (index, value)\
    \ in arr.enumerated() {\n        if value % 2 == 0 && value < min {\n        \
    \    min = value\n            result = [value, index]\n        }\n    }\n    return\
    \ result.isEmpty ? [] : result\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int,\
    \ Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n\
    \    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n          \
    \  return false\n        }\n    }\n    return true\n}\n            \nassert(pluck(arr:\
    \ [4, 2, 3]) == [2, 1])\nassert(pluck(arr: [1, 2, 3]) == [2, 1])\nassert(pluck(arr:\
    \ [] as [Int]) == [] as [Int])\nassert(pluck(arr: [5, 0, 3, 0, 4, 2]) == [0, 1])\n\
    assert(pluck(arr: [1, 2, 3, 0, 5, 3]) == [0, 3])\nassert(pluck(arr: [5, 4, 8,\
    \ 4, 8]) == [4, 1])\nassert(pluck(arr: [7, 6, 7, 1]) == [6, 1])\nassert(pluck(arr:\
    \ [7, 9, 7, 1]) == [] as [Int])"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660013549
- exit_code: 0
  program: "\n/// \"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n/// your task is to pluck one of the nodes and return it.\n///\
    \ The plucked node should be the node with the smallest even value.\n/// If multiple\
    \ nodes with the same smallest even value are found return the node that has smallest\
    \ index.\n/// The plucked node should be returned in an array, [ smalest_value,\
    \ its index ],\n/// If there are no even values or the given array is empty, return\
    \ [].\n/// Example 1:\n/// >>> pluck(arr: [4, 2, 3])\n/// [2, 1]\n/// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n/// Example 2:\n\
    /// >>> pluck(arr: [1, 2, 3])\n/// [2, 1]\n/// Explanation: 2 has the smallest\
    \ even value, and 2 has the smallest index.\n/// Example 3:\n/// >>> pluck(arr:\
    \ [] as [Int])\n/// [] as [Int]\n/// Example 4:\n/// >>> pluck(arr: [5, 0, 3,\
    \ 0, 4, 2])\n/// [0, 1]\n/// Explanation: 0 is the smallest value, but  there\
    \ are two zeros,\n/// so we will choose the first zero, which has the smallest\
    \ index.\n/// Constraints:\n/// * 1 <= nodes.length <= 10000\n/// * 0 <= node.value\n\
    func pluck(arr: [Int]) -> [Int] {\n    var res: [Int] = []\n    var smallestEvenValue:\
    \ Int?\n    for (i, x) in arr.enumerated() {\n        if x % 2 == 0 {\n      \
    \      if smallestEvenValue == nil {\n                smallestEvenValue = x\n\
    \                res = [x, i]\n            } else if x < smallestEvenValue! {\n\
    \                smallestEvenValue = x\n                res = [x, i]\n       \
    \     }\n        }\n    }\n    return res\n}\n\n\nfunc ==(left: [(Int, Int)],\
    \ right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n       \
    \ return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r\
    \ {\n            return false\n        }\n    }\n    return true\n}\n        \
    \    \nassert(pluck(arr: [4, 2, 3]) == [2, 1])\nassert(pluck(arr: [1, 2, 3]) ==\
    \ [2, 1])\nassert(pluck(arr: [] as [Int]) == [] as [Int])\nassert(pluck(arr: [5,\
    \ 0, 3, 0, 4, 2]) == [0, 1])\nassert(pluck(arr: [1, 2, 3, 0, 5, 3]) == [0, 3])\n\
    assert(pluck(arr: [5, 4, 8, 4, 8]) == [4, 1])\nassert(pluck(arr: [7, 6, 7, 1])\
    \ == [6, 1])\nassert(pluck(arr: [7, 9, 7, 1]) == [] as [Int])"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660013549
- exit_code: -4
  program: "\n/// \"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n/// your task is to pluck one of the nodes and return it.\n///\
    \ The plucked node should be the node with the smallest even value.\n/// If multiple\
    \ nodes with the same smallest even value are found return the node that has smallest\
    \ index.\n/// The plucked node should be returned in an array, [ smalest_value,\
    \ its index ],\n/// If there are no even values or the given array is empty, return\
    \ [].\n/// Example 1:\n/// >>> pluck(arr: [4, 2, 3])\n/// [2, 1]\n/// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n/// Example 2:\n\
    /// >>> pluck(arr: [1, 2, 3])\n/// [2, 1]\n/// Explanation: 2 has the smallest\
    \ even value, and 2 has the smallest index.\n/// Example 3:\n/// >>> pluck(arr:\
    \ [] as [Int])\n/// [] as [Int]\n/// Example 4:\n/// >>> pluck(arr: [5, 0, 3,\
    \ 0, 4, 2])\n/// [0, 1]\n/// Explanation: 0 is the smallest value, but  there\
    \ are two zeros,\n/// so we will choose the first zero, which has the smallest\
    \ index.\n/// Constraints:\n/// * 1 <= nodes.length <= 10000\n/// * 0 <= node.value\n\
    func pluck(arr: [Int]) -> [Int] {\n    return []\n}\n\n\nfunc ==(left: [(Int,\
    \ Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n\
    \        return false\n    }\n    for (l, r) in zip(left, right) {\n        if\
    \ l != r {\n            return false\n        }\n    }\n    return true\n}\n \
    \           \nassert(pluck(arr: [4, 2, 3]) == [2, 1])\nassert(pluck(arr: [1, 2,\
    \ 3]) == [2, 1])\nassert(pluck(arr: [] as [Int]) == [] as [Int])\nassert(pluck(arr:\
    \ [5, 0, 3, 0, 4, 2]) == [0, 1])\nassert(pluck(arr: [1, 2, 3, 0, 5, 3]) == [0,\
    \ 3])\nassert(pluck(arr: [5, 4, 8, 4, 8]) == [4, 1])\nassert(pluck(arr: [7, 6,\
    \ 7, 1]) == [6, 1])\nassert(pluck(arr: [7, 9, 7, 1]) == [] as [Int])"
  status: Exception
  stderr: 'tmpgh8dpvxh/tmpgh8dpvxh.swift:44: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002ac906ec4c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002ac906bbbb6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002ac906bbb988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002ac906bba7b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpgh8dpvxh                        0x00005578e3d9c3bc <unavailable> + 5052

    5    libc.so.6                          0x00002ac9070b0460 __libc_start_main +
    245

    6    tmpgh8dpvxh                        0x00005578e3d9bfc9 <unavailable> + 4041

    '
  stdout: ''
  timestamp: 1660013365
- exit_code: 0
  program: "\n/// \"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n/// your task is to pluck one of the nodes and return it.\n///\
    \ The plucked node should be the node with the smallest even value.\n/// If multiple\
    \ nodes with the same smallest even value are found return the node that has smallest\
    \ index.\n/// The plucked node should be returned in an array, [ smalest_value,\
    \ its index ],\n/// If there are no even values or the given array is empty, return\
    \ [].\n/// Example 1:\n/// >>> pluck(arr: [4, 2, 3])\n/// [2, 1]\n/// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n/// Example 2:\n\
    /// >>> pluck(arr: [1, 2, 3])\n/// [2, 1]\n/// Explanation: 2 has the smallest\
    \ even value, and 2 has the smallest index.\n/// Example 3:\n/// >>> pluck(arr:\
    \ [] as [Int])\n/// [] as [Int]\n/// Example 4:\n/// >>> pluck(arr: [5, 0, 3,\
    \ 0, 4, 2])\n/// [0, 1]\n/// Explanation: 0 is the smallest value, but  there\
    \ are two zeros,\n/// so we will choose the first zero, which has the smallest\
    \ index.\n/// Constraints:\n/// * 1 <= nodes.length <= 10000\n/// * 0 <= node.value\n\
    func pluck(arr: [Int]) -> [Int] {\n    var min: Int?\n    var index = Int.max\n\
    \    for (i, n) in arr.enumerated() {\n        if n % 2 == 0 && (min == nil ||\
    \ n < min!) {\n            min = n\n            index = i\n        }\n    }\n\
    \    if min == nil {\n        return []\n    }\n    return [min!, index]\n}\n\n\
    \nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(pluck(arr: [4, 2, 3]) == [2, 1])\nassert(pluck(arr:\
    \ [1, 2, 3]) == [2, 1])\nassert(pluck(arr: [] as [Int]) == [] as [Int])\nassert(pluck(arr:\
    \ [5, 0, 3, 0, 4, 2]) == [0, 1])\nassert(pluck(arr: [1, 2, 3, 0, 5, 3]) == [0,\
    \ 3])\nassert(pluck(arr: [5, 4, 8, 4, 8]) == [4, 1])\nassert(pluck(arr: [7, 6,\
    \ 7, 1]) == [6, 1])\nassert(pluck(arr: [7, 9, 7, 1]) == [] as [Int])"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660013549
- exit_code: 0
  program: "\n/// \"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n/// your task is to pluck one of the nodes and return it.\n///\
    \ The plucked node should be the node with the smallest even value.\n/// If multiple\
    \ nodes with the same smallest even value are found return the node that has smallest\
    \ index.\n/// The plucked node should be returned in an array, [ smalest_value,\
    \ its index ],\n/// If there are no even values or the given array is empty, return\
    \ [].\n/// Example 1:\n/// >>> pluck(arr: [4, 2, 3])\n/// [2, 1]\n/// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n/// Example 2:\n\
    /// >>> pluck(arr: [1, 2, 3])\n/// [2, 1]\n/// Explanation: 2 has the smallest\
    \ even value, and 2 has the smallest index.\n/// Example 3:\n/// >>> pluck(arr:\
    \ [] as [Int])\n/// [] as [Int]\n/// Example 4:\n/// >>> pluck(arr: [5, 0, 3,\
    \ 0, 4, 2])\n/// [0, 1]\n/// Explanation: 0 is the smallest value, but  there\
    \ are two zeros,\n/// so we will choose the first zero, which has the smallest\
    \ index.\n/// Constraints:\n/// * 1 <= nodes.length <= 10000\n/// * 0 <= node.value\n\
    func pluck(arr: [Int]) -> [Int] {\n    return arr.filter { $0 % 2 == 0 }.isEmpty\
    \ ? [] : [arr.filter { $0 % 2 == 0 }.min()!, arr.index(of: arr.filter { $0 % 2\
    \ == 0 }.min()!)!]\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) ->\
    \ Bool {\n    if left.count != right.count {\n        return false\n    }\n  \
    \  for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(pluck(arr: [4, 2,\
    \ 3]) == [2, 1])\nassert(pluck(arr: [1, 2, 3]) == [2, 1])\nassert(pluck(arr: []\
    \ as [Int]) == [] as [Int])\nassert(pluck(arr: [5, 0, 3, 0, 4, 2]) == [0, 1])\n\
    assert(pluck(arr: [1, 2, 3, 0, 5, 3]) == [0, 3])\nassert(pluck(arr: [5, 4, 8,\
    \ 4, 8]) == [4, 1])\nassert(pluck(arr: [7, 6, 7, 1]) == [6, 1])\nassert(pluck(arr:\
    \ [7, 9, 7, 1]) == [] as [Int])"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660013549
- exit_code: -4
  program: "\n/// \"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n/// your task is to pluck one of the nodes and return it.\n///\
    \ The plucked node should be the node with the smallest even value.\n/// If multiple\
    \ nodes with the same smallest even value are found return the node that has smallest\
    \ index.\n/// The plucked node should be returned in an array, [ smalest_value,\
    \ its index ],\n/// If there are no even values or the given array is empty, return\
    \ [].\n/// Example 1:\n/// >>> pluck(arr: [4, 2, 3])\n/// [2, 1]\n/// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n/// Example 2:\n\
    /// >>> pluck(arr: [1, 2, 3])\n/// [2, 1]\n/// Explanation: 2 has the smallest\
    \ even value, and 2 has the smallest index.\n/// Example 3:\n/// >>> pluck(arr:\
    \ [] as [Int])\n/// [] as [Int]\n/// Example 4:\n/// >>> pluck(arr: [5, 0, 3,\
    \ 0, 4, 2])\n/// [0, 1]\n/// Explanation: 0 is the smallest value, but  there\
    \ are two zeros,\n/// so we will choose the first zero, which has the smallest\
    \ index.\n/// Constraints:\n/// * 1 <= nodes.length <= 10000\n/// * 0 <= node.value\n\
    func pluck(arr: [Int]) -> [Int] {\n    guard arr.count > 0 else { return [] }\n\
    \    let minEven = arr.filter({ $0 % 2 == 0 }).min() ?? 0\n    guard minEven >\
    \ 0 else { return [] }\n    return [minEven, arr.firstIndex(of: minEven)!]\n}\n\
    \n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(pluck(arr: [4, 2, 3]) == [2, 1])\nassert(pluck(arr:\
    \ [1, 2, 3]) == [2, 1])\nassert(pluck(arr: [] as [Int]) == [] as [Int])\nassert(pluck(arr:\
    \ [5, 0, 3, 0, 4, 2]) == [0, 1])\nassert(pluck(arr: [1, 2, 3, 0, 5, 3]) == [0,\
    \ 3])\nassert(pluck(arr: [5, 4, 8, 4, 8]) == [4, 1])\nassert(pluck(arr: [7, 6,\
    \ 7, 1]) == [6, 1])\nassert(pluck(arr: [7, 9, 7, 1]) == [] as [Int])"
  status: Exception
  stderr: 'tmpset78xnc/tmpset78xnc.swift:50: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002aff81276c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002aff80f6db6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002aff80f6d988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002aff80f6c7b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpset78xnc                        0x00005628a852ba24 <unavailable> + 6692

    5    libc.so.6                          0x00002aff81462460 __libc_start_main +
    245

    6    tmpset78xnc                        0x00005628a852b2c9 <unavailable> + 4809

    '
  stdout: ''
  timestamp: 1660013549
- exit_code: 0
  program: "\n/// \"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n/// your task is to pluck one of the nodes and return it.\n///\
    \ The plucked node should be the node with the smallest even value.\n/// If multiple\
    \ nodes with the same smallest even value are found return the node that has smallest\
    \ index.\n/// The plucked node should be returned in an array, [ smalest_value,\
    \ its index ],\n/// If there are no even values or the given array is empty, return\
    \ [].\n/// Example 1:\n/// >>> pluck(arr: [4, 2, 3])\n/// [2, 1]\n/// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n/// Example 2:\n\
    /// >>> pluck(arr: [1, 2, 3])\n/// [2, 1]\n/// Explanation: 2 has the smallest\
    \ even value, and 2 has the smallest index.\n/// Example 3:\n/// >>> pluck(arr:\
    \ [] as [Int])\n/// [] as [Int]\n/// Example 4:\n/// >>> pluck(arr: [5, 0, 3,\
    \ 0, 4, 2])\n/// [0, 1]\n/// Explanation: 0 is the smallest value, but  there\
    \ are two zeros,\n/// so we will choose the first zero, which has the smallest\
    \ index.\n/// Constraints:\n/// * 1 <= nodes.length <= 10000\n/// * 0 <= node.value\n\
    func pluck(arr: [Int]) -> [Int] {\n    let evenValues = arr.filter { $0 % 2 ==\
    \ 0 }\n    if evenValues.isEmpty {\n        return []\n    }\n    let smallestEvenValue\
    \ = evenValues.min()!\n    let result = arr.enumerated().filter { $0.element ==\
    \ smallestEvenValue }\n    return [result.first!.element, result.first!.offset]\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(pluck(arr: [4, 2, 3]) == [2, 1])\nassert(pluck(arr:\
    \ [1, 2, 3]) == [2, 1])\nassert(pluck(arr: [] as [Int]) == [] as [Int])\nassert(pluck(arr:\
    \ [5, 0, 3, 0, 4, 2]) == [0, 1])\nassert(pluck(arr: [1, 2, 3, 0, 5, 3]) == [0,\
    \ 3])\nassert(pluck(arr: [5, 4, 8, 4, 8]) == [4, 1])\nassert(pluck(arr: [7, 6,\
    \ 7, 1]) == [6, 1])\nassert(pluck(arr: [7, 9, 7, 1]) == [] as [Int])"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660013549
- exit_code: 0
  program: "\n/// \"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n/// your task is to pluck one of the nodes and return it.\n///\
    \ The plucked node should be the node with the smallest even value.\n/// If multiple\
    \ nodes with the same smallest even value are found return the node that has smallest\
    \ index.\n/// The plucked node should be returned in an array, [ smalest_value,\
    \ its index ],\n/// If there are no even values or the given array is empty, return\
    \ [].\n/// Example 1:\n/// >>> pluck(arr: [4, 2, 3])\n/// [2, 1]\n/// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n/// Example 2:\n\
    /// >>> pluck(arr: [1, 2, 3])\n/// [2, 1]\n/// Explanation: 2 has the smallest\
    \ even value, and 2 has the smallest index.\n/// Example 3:\n/// >>> pluck(arr:\
    \ [] as [Int])\n/// [] as [Int]\n/// Example 4:\n/// >>> pluck(arr: [5, 0, 3,\
    \ 0, 4, 2])\n/// [0, 1]\n/// Explanation: 0 is the smallest value, but  there\
    \ are two zeros,\n/// so we will choose the first zero, which has the smallest\
    \ index.\n/// Constraints:\n/// * 1 <= nodes.length <= 10000\n/// * 0 <= node.value\n\
    func pluck(arr: [Int]) -> [Int] {\n    // Sorted array to find the first even\
    \ index\n    let arrSorted = arr.sorted()\n    var index = 0\n    for value in\
    \ arrSorted {\n        if value % 2 == 0 {\n            return [value, arr.firstIndex(of:\
    \ value)!]\n        }\n        index += 1\n    }\n    return []\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(pluck(arr: [4, 2, 3]) == [2, 1])\nassert(pluck(arr: [1,\
    \ 2, 3]) == [2, 1])\nassert(pluck(arr: [] as [Int]) == [] as [Int])\nassert(pluck(arr:\
    \ [5, 0, 3, 0, 4, 2]) == [0, 1])\nassert(pluck(arr: [1, 2, 3, 0, 5, 3]) == [0,\
    \ 3])\nassert(pluck(arr: [5, 4, 8, 4, 8]) == [4, 1])\nassert(pluck(arr: [7, 6,\
    \ 7, 1]) == [6, 1])\nassert(pluck(arr: [7, 9, 7, 1]) == [] as [Int])"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660013549
- exit_code: -4
  program: "\n/// \"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n/// your task is to pluck one of the nodes and return it.\n///\
    \ The plucked node should be the node with the smallest even value.\n/// If multiple\
    \ nodes with the same smallest even value are found return the node that has smallest\
    \ index.\n/// The plucked node should be returned in an array, [ smalest_value,\
    \ its index ],\n/// If there are no even values or the given array is empty, return\
    \ [].\n/// Example 1:\n/// >>> pluck(arr: [4, 2, 3])\n/// [2, 1]\n/// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n/// Example 2:\n\
    /// >>> pluck(arr: [1, 2, 3])\n/// [2, 1]\n/// Explanation: 2 has the smallest\
    \ even value, and 2 has the smallest index.\n/// Example 3:\n/// >>> pluck(arr:\
    \ [] as [Int])\n/// [] as [Int]\n/// Example 4:\n/// >>> pluck(arr: [5, 0, 3,\
    \ 0, 4, 2])\n/// [0, 1]\n/// Explanation: 0 is the smallest value, but  there\
    \ are two zeros,\n/// so we will choose the first zero, which has the smallest\
    \ index.\n/// Constraints:\n/// * 1 <= nodes.length <= 10000\n/// * 0 <= node.value\n\
    func pluck(arr: [Int]) -> [Int] {\n    return []\n}\n\n\nfunc ==(left: [(Int,\
    \ Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n\
    \        return false\n    }\n    for (l, r) in zip(left, right) {\n        if\
    \ l != r {\n            return false\n        }\n    }\n    return true\n}\n \
    \           \nassert(pluck(arr: [4, 2, 3]) == [2, 1])\nassert(pluck(arr: [1, 2,\
    \ 3]) == [2, 1])\nassert(pluck(arr: [] as [Int]) == [] as [Int])\nassert(pluck(arr:\
    \ [5, 0, 3, 0, 4, 2]) == [0, 1])\nassert(pluck(arr: [1, 2, 3, 0, 5, 3]) == [0,\
    \ 3])\nassert(pluck(arr: [5, 4, 8, 4, 8]) == [4, 1])\nassert(pluck(arr: [7, 6,\
    \ 7, 1]) == [6, 1])\nassert(pluck(arr: [7, 9, 7, 1]) == [] as [Int])"
  status: Exception
  stderr: 'tmpgh8dpvxh/tmpgh8dpvxh.swift:44: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002ac906ec4c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002ac906bbbb6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002ac906bbb988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002ac906bba7b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpgh8dpvxh                        0x00005578e3d9c3bc <unavailable> + 5052

    5    libc.so.6                          0x00002ac9070b0460 __libc_start_main +
    245

    6    tmpgh8dpvxh                        0x00005578e3d9bfc9 <unavailable> + 4041

    '
  stdout: ''
  timestamp: 1660013365
- exit_code: 1
  program: "\n/// \"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n/// your task is to pluck one of the nodes and return it.\n///\
    \ The plucked node should be the node with the smallest even value.\n/// If multiple\
    \ nodes with the same smallest even value are found return the node that has smallest\
    \ index.\n/// The plucked node should be returned in an array, [ smalest_value,\
    \ its index ],\n/// If there are no even values or the given array is empty, return\
    \ [].\n/// Example 1:\n/// >>> pluck(arr: [4, 2, 3])\n/// [2, 1]\n/// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n/// Example 2:\n\
    /// >>> pluck(arr: [1, 2, 3])\n/// [2, 1]\n/// Explanation: 2 has the smallest\
    \ even value, and 2 has the smallest index.\n/// Example 3:\n/// >>> pluck(arr:\
    \ [] as [Int])\n/// [] as [Int]\n/// Example 4:\n/// >>> pluck(arr: [5, 0, 3,\
    \ 0, 4, 2])\n/// [0, 1]\n/// Explanation: 0 is the smallest value, but  there\
    \ are two zeros,\n/// so we will choose the first zero, which has the smallest\
    \ index.\n/// Constraints:\n/// * 1 <= nodes.length <= 10000\n/// * 0 <= node.value\n\
    func pluck(arr: [Int]) -> [Int] {\n    return arr.enumerated().sorted(by: {$0.element\
    \ < $1.element}).filter {$0.element % 2 == 0}.first ?? []\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(pluck(arr: [4, 2, 3]) == [2, 1])\nassert(pluck(arr: [1,\
    \ 2, 3]) == [2, 1])\nassert(pluck(arr: [] as [Int]) == [] as [Int])\nassert(pluck(arr:\
    \ [5, 0, 3, 0, 4, 2]) == [0, 1])\nassert(pluck(arr: [1, 2, 3, 0, 5, 3]) == [0,\
    \ 3])\nassert(pluck(arr: [5, 4, 8, 4, 8]) == [4, 1])\nassert(pluck(arr: [7, 6,\
    \ 7, 1]) == [6, 1])\nassert(pluck(arr: [7, 9, 7, 1]) == [] as [Int])"
  status: SyntaxError
  stderr: "/tmp/tmpkic5nkjg.swift:28:102: error: cannot convert return expression\
    \ of type 'EnumeratedSequence<[Int]>.Iterator.Element' (aka '(offset: Int, element:\
    \ Int)') to return type '[Int]'\n    return arr.enumerated().sorted(by: {$0.element\
    \ < $1.element}).filter {$0.element % 2 == 0}.first ?? []\n           ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~^~~~~\n\
    /tmp/tmpkic5nkjg.swift:28:105: error: cannot convert value of type '[Any]' to\
    \ expected argument type 'EnumeratedSequence<[Int]>.Iterator.Element' (aka '(offset:\
    \ Int, element: Int)')\n    return arr.enumerated().sorted(by: {$0.element < $1.element}).filter\
    \ {$0.element % 2 == 0}.first ?? []\n                                        \
    \                                                                ^\n"
  stdout: ''
  timestamp: 1660013549
- exit_code: -4
  program: "\n/// \"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n/// your task is to pluck one of the nodes and return it.\n///\
    \ The plucked node should be the node with the smallest even value.\n/// If multiple\
    \ nodes with the same smallest even value are found return the node that has smallest\
    \ index.\n/// The plucked node should be returned in an array, [ smalest_value,\
    \ its index ],\n/// If there are no even values or the given array is empty, return\
    \ [].\n/// Example 1:\n/// >>> pluck(arr: [4, 2, 3])\n/// [2, 1]\n/// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n/// Example 2:\n\
    /// >>> pluck(arr: [1, 2, 3])\n/// [2, 1]\n/// Explanation: 2 has the smallest\
    \ even value, and 2 has the smallest index.\n/// Example 3:\n/// >>> pluck(arr:\
    \ [] as [Int])\n/// [] as [Int]\n/// Example 4:\n/// >>> pluck(arr: [5, 0, 3,\
    \ 0, 4, 2])\n/// [0, 1]\n/// Explanation: 0 is the smallest value, but  there\
    \ are two zeros,\n/// so we will choose the first zero, which has the smallest\
    \ index.\n/// Constraints:\n/// * 1 <= nodes.length <= 10000\n/// * 0 <= node.value\n\
    func pluck(arr: [Int]) -> [Int] {\n    var result = [Int]()\n    var temp = [Int]()\n\
    \    var evens = [Int]()\n    var odds = [Int]()\n    var firstFound = false\n\
    \    var flag = false\n    var val = Int.max\n    var minVal = Int.max\n    var\
    \ minValIndex = Int.max\n    for i in 0..<arr.count {\n        var val = arr[i]\n\
    \        if val % 2 == 0 {\n            if evens.count == 0 {\n              \
    \  evens.append(i)\n                temp.append(val)\n            } else {\n \
    \               if temp.count == 0 {\n                    temp.append(val)\n \
    \               } else {\n                    val = temp[0]\n                \
    \    temp.removeAll()\n                    temp.append(val)\n                }\n\
    \                if val < minVal {\n                    minVal = val\n       \
    \             minValIndex = i\n                }\n                if val < minVal\
    \ {\n                    minVal = val\n                    minValIndex = i\n \
    \               }\n                if val == minVal {\n                    if\
    \ i < minValIndex {\n                        minValIndex = i\n               \
    \     }\n                }\n            }\n        } else {\n            odds.append(i)\n\
    \        }\n    }\n    if evens.count == 0 {\n        return result\n    }\n \
    \   result.append(minVal)\n    result.append(minValIndex)\n    return result\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(pluck(arr: [4, 2, 3]) == [2, 1])\nassert(pluck(arr:\
    \ [1, 2, 3]) == [2, 1])\nassert(pluck(arr: [] as [Int]) == [] as [Int])\nassert(pluck(arr:\
    \ [5, 0, 3, 0, 4, 2]) == [0, 1])\nassert(pluck(arr: [1, 2, 3, 0, 5, 3]) == [0,\
    \ 3])\nassert(pluck(arr: [5, 4, 8, 4, 8]) == [4, 1])\nassert(pluck(arr: [7, 6,\
    \ 7, 1]) == [6, 1])\nassert(pluck(arr: [7, 9, 7, 1]) == [] as [Int])"
  status: Exception
  stderr: 'tmpeuz32men/tmpeuz32men.swift:90: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b8d81530c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b8d81227b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b8d81227988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b8d812267b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpeuz32men                        0x000055bb830ba77c <unavailable> + 6012

    5    libc.so.6                          0x00002b8d8171c460 __libc_start_main +
    245

    6    tmpeuz32men                        0x000055bb830ba389 <unavailable> + 5001

    '
  stdout: ''
  timestamp: 1660013549
- exit_code: 0
  program: "\n/// \"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n/// your task is to pluck one of the nodes and return it.\n///\
    \ The plucked node should be the node with the smallest even value.\n/// If multiple\
    \ nodes with the same smallest even value are found return the node that has smallest\
    \ index.\n/// The plucked node should be returned in an array, [ smalest_value,\
    \ its index ],\n/// If there are no even values or the given array is empty, return\
    \ [].\n/// Example 1:\n/// >>> pluck(arr: [4, 2, 3])\n/// [2, 1]\n/// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n/// Example 2:\n\
    /// >>> pluck(arr: [1, 2, 3])\n/// [2, 1]\n/// Explanation: 2 has the smallest\
    \ even value, and 2 has the smallest index.\n/// Example 3:\n/// >>> pluck(arr:\
    \ [] as [Int])\n/// [] as [Int]\n/// Example 4:\n/// >>> pluck(arr: [5, 0, 3,\
    \ 0, 4, 2])\n/// [0, 1]\n/// Explanation: 0 is the smallest value, but  there\
    \ are two zeros,\n/// so we will choose the first zero, which has the smallest\
    \ index.\n/// Constraints:\n/// * 1 <= nodes.length <= 10000\n/// * 0 <= node.value\n\
    func pluck(arr: [Int]) -> [Int] {\n    let evens = arr.enumerated().filter { $0.element\
    \ % 2 == 0 }\n    let smallest = evens.min { $0.element < $1.element }\n    return\
    \ smallest?.element != nil ? [smallest!.element, smallest!.offset] : []\n}\n\n\
    \nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(pluck(arr: [4, 2, 3]) == [2, 1])\nassert(pluck(arr:\
    \ [1, 2, 3]) == [2, 1])\nassert(pluck(arr: [] as [Int]) == [] as [Int])\nassert(pluck(arr:\
    \ [5, 0, 3, 0, 4, 2]) == [0, 1])\nassert(pluck(arr: [1, 2, 3, 0, 5, 3]) == [0,\
    \ 3])\nassert(pluck(arr: [5, 4, 8, 4, 8]) == [4, 1])\nassert(pluck(arr: [7, 6,\
    \ 7, 1]) == [6, 1])\nassert(pluck(arr: [7, 9, 7, 1]) == [] as [Int])"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660013549
- exit_code: 1
  program: "\n/// \"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n/// your task is to pluck one of the nodes and return it.\n///\
    \ The plucked node should be the node with the smallest even value.\n/// If multiple\
    \ nodes with the same smallest even value are found return the node that has smallest\
    \ index.\n/// The plucked node should be returned in an array, [ smalest_value,\
    \ its index ],\n/// If there are no even values or the given array is empty, return\
    \ [].\n/// Example 1:\n/// >>> pluck(arr: [4, 2, 3])\n/// [2, 1]\n/// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n/// Example 2:\n\
    /// >>> pluck(arr: [1, 2, 3])\n/// [2, 1]\n/// Explanation: 2 has the smallest\
    \ even value, and 2 has the smallest index.\n/// Example 3:\n/// >>> pluck(arr:\
    \ [] as [Int])\n/// [] as [Int]\n/// Example 4:\n/// >>> pluck(arr: [5, 0, 3,\
    \ 0, 4, 2])\n/// [0, 1]\n/// Explanation: 0 is the smallest value, but  there\
    \ are two zeros,\n/// so we will choose the first zero, which has the smallest\
    \ index.\n/// Constraints:\n/// * 1 <= nodes.length <= 10000\n/// * 0 <= node.value\n\
    func pluck(arr: [Int]) -> [Int] {\n    guard !arr.isEmpty else { return [] }\n\
    \    var smallest = Int.max\n    var smallestIndex = Int.max\n    for (index,\
    \ value) in arr.enumerated() {\n        if value.isEven && value < smallest {\n\
    \            smallest = value\n            smallestIndex = index\n        }\n\
    \    }\n    return smallest == Int.max ? [] : [smallest, smallestIndex]\n}\n\n\
    \nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(pluck(arr: [4, 2, 3]) == [2, 1])\nassert(pluck(arr:\
    \ [1, 2, 3]) == [2, 1])\nassert(pluck(arr: [] as [Int]) == [] as [Int])\nassert(pluck(arr:\
    \ [5, 0, 3, 0, 4, 2]) == [0, 1])\nassert(pluck(arr: [1, 2, 3, 0, 5, 3]) == [0,\
    \ 3])\nassert(pluck(arr: [5, 4, 8, 4, 8]) == [4, 1])\nassert(pluck(arr: [7, 6,\
    \ 7, 1]) == [6, 1])\nassert(pluck(arr: [7, 9, 7, 1]) == [] as [Int])"
  status: SyntaxError
  stderr: "/tmp/tmpi5sexiy7.swift:32:18: error: value of type 'Int' has no member\
    \ 'isEven'\n        if value.isEven && value < smallest {\n           ~~~~~ ^~~~~~\n"
  stdout: ''
  timestamp: 1660013549
- exit_code: 0
  program: "\n/// \"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n/// your task is to pluck one of the nodes and return it.\n///\
    \ The plucked node should be the node with the smallest even value.\n/// If multiple\
    \ nodes with the same smallest even value are found return the node that has smallest\
    \ index.\n/// The plucked node should be returned in an array, [ smalest_value,\
    \ its index ],\n/// If there are no even values or the given array is empty, return\
    \ [].\n/// Example 1:\n/// >>> pluck(arr: [4, 2, 3])\n/// [2, 1]\n/// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n/// Example 2:\n\
    /// >>> pluck(arr: [1, 2, 3])\n/// [2, 1]\n/// Explanation: 2 has the smallest\
    \ even value, and 2 has the smallest index.\n/// Example 3:\n/// >>> pluck(arr:\
    \ [] as [Int])\n/// [] as [Int]\n/// Example 4:\n/// >>> pluck(arr: [5, 0, 3,\
    \ 0, 4, 2])\n/// [0, 1]\n/// Explanation: 0 is the smallest value, but  there\
    \ are two zeros,\n/// so we will choose the first zero, which has the smallest\
    \ index.\n/// Constraints:\n/// * 1 <= nodes.length <= 10000\n/// * 0 <= node.value\n\
    func pluck(arr: [Int]) -> [Int] {\n    guard !arr.isEmpty else { return [] }\n\
    \    let evens = arr.filter { $0 % 2 == 0 }\n    guard !evens.isEmpty else { return\
    \ [] }\n    let minEven = evens.min()!\n    let minIndex = arr.firstIndex(of:\
    \ minEven)!\n    return [minEven, minIndex]\n}\n\n\nfunc ==(left: [(Int, Int)],\
    \ right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n       \
    \ return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r\
    \ {\n            return false\n        }\n    }\n    return true\n}\n        \
    \    \nassert(pluck(arr: [4, 2, 3]) == [2, 1])\nassert(pluck(arr: [1, 2, 3]) ==\
    \ [2, 1])\nassert(pluck(arr: [] as [Int]) == [] as [Int])\nassert(pluck(arr: [5,\
    \ 0, 3, 0, 4, 2]) == [0, 1])\nassert(pluck(arr: [1, 2, 3, 0, 5, 3]) == [0, 3])\n\
    assert(pluck(arr: [5, 4, 8, 4, 8]) == [4, 1])\nassert(pluck(arr: [7, 6, 7, 1])\
    \ == [6, 1])\nassert(pluck(arr: [7, 9, 7, 1]) == [] as [Int])"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660013549
- exit_code: 0
  program: "\n/// \"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n/// your task is to pluck one of the nodes and return it.\n///\
    \ The plucked node should be the node with the smallest even value.\n/// If multiple\
    \ nodes with the same smallest even value are found return the node that has smallest\
    \ index.\n/// The plucked node should be returned in an array, [ smalest_value,\
    \ its index ],\n/// If there are no even values or the given array is empty, return\
    \ [].\n/// Example 1:\n/// >>> pluck(arr: [4, 2, 3])\n/// [2, 1]\n/// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n/// Example 2:\n\
    /// >>> pluck(arr: [1, 2, 3])\n/// [2, 1]\n/// Explanation: 2 has the smallest\
    \ even value, and 2 has the smallest index.\n/// Example 3:\n/// >>> pluck(arr:\
    \ [] as [Int])\n/// [] as [Int]\n/// Example 4:\n/// >>> pluck(arr: [5, 0, 3,\
    \ 0, 4, 2])\n/// [0, 1]\n/// Explanation: 0 is the smallest value, but  there\
    \ are two zeros,\n/// so we will choose the first zero, which has the smallest\
    \ index.\n/// Constraints:\n/// * 1 <= nodes.length <= 10000\n/// * 0 <= node.value\n\
    func pluck(arr: [Int]) -> [Int] {\n    if let even = arr.filter({ $0 % 2 == 0\
    \ }).min() {\n        return [even, arr.firstIndex(of: even)!]\n    }\n    return\
    \ []\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if\
    \ left.count != right.count {\n        return false\n    }\n    for (l, r) in\
    \ zip(left, right) {\n        if l != r {\n            return false\n        }\n\
    \    }\n    return true\n}\n            \nassert(pluck(arr: [4, 2, 3]) == [2,\
    \ 1])\nassert(pluck(arr: [1, 2, 3]) == [2, 1])\nassert(pluck(arr: [] as [Int])\
    \ == [] as [Int])\nassert(pluck(arr: [5, 0, 3, 0, 4, 2]) == [0, 1])\nassert(pluck(arr:\
    \ [1, 2, 3, 0, 5, 3]) == [0, 3])\nassert(pluck(arr: [5, 4, 8, 4, 8]) == [4, 1])\n\
    assert(pluck(arr: [7, 6, 7, 1]) == [6, 1])\nassert(pluck(arr: [7, 9, 7, 1]) ==\
    \ [] as [Int])"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660013549
- exit_code: 0
  program: "\n/// \"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n/// your task is to pluck one of the nodes and return it.\n///\
    \ The plucked node should be the node with the smallest even value.\n/// If multiple\
    \ nodes with the same smallest even value are found return the node that has smallest\
    \ index.\n/// The plucked node should be returned in an array, [ smalest_value,\
    \ its index ],\n/// If there are no even values or the given array is empty, return\
    \ [].\n/// Example 1:\n/// >>> pluck(arr: [4, 2, 3])\n/// [2, 1]\n/// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n/// Example 2:\n\
    /// >>> pluck(arr: [1, 2, 3])\n/// [2, 1]\n/// Explanation: 2 has the smallest\
    \ even value, and 2 has the smallest index.\n/// Example 3:\n/// >>> pluck(arr:\
    \ [] as [Int])\n/// [] as [Int]\n/// Example 4:\n/// >>> pluck(arr: [5, 0, 3,\
    \ 0, 4, 2])\n/// [0, 1]\n/// Explanation: 0 is the smallest value, but  there\
    \ are two zeros,\n/// so we will choose the first zero, which has the smallest\
    \ index.\n/// Constraints:\n/// * 1 <= nodes.length <= 10000\n/// * 0 <= node.value\n\
    func pluck(arr: [Int]) -> [Int] {\n    if arr.isEmpty {\n        return []\n \
    \   }\n    let evens = arr.filter { $0 % 2 == 0 }\n    if evens.isEmpty {\n  \
    \      return []\n    }\n    let min = evens.min()!\n    let index = arr.firstIndex(of:\
    \ min)!\n    return [min, index]\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int,\
    \ Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n\
    \    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n          \
    \  return false\n        }\n    }\n    return true\n}\n            \nassert(pluck(arr:\
    \ [4, 2, 3]) == [2, 1])\nassert(pluck(arr: [1, 2, 3]) == [2, 1])\nassert(pluck(arr:\
    \ [] as [Int]) == [] as [Int])\nassert(pluck(arr: [5, 0, 3, 0, 4, 2]) == [0, 1])\n\
    assert(pluck(arr: [1, 2, 3, 0, 5, 3]) == [0, 3])\nassert(pluck(arr: [5, 4, 8,\
    \ 4, 8]) == [4, 1])\nassert(pluck(arr: [7, 6, 7, 1]) == [6, 1])\nassert(pluck(arr:\
    \ [7, 9, 7, 1]) == [] as [Int])"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660013549
- exit_code: 0
  program: "\n/// \"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n/// your task is to pluck one of the nodes and return it.\n///\
    \ The plucked node should be the node with the smallest even value.\n/// If multiple\
    \ nodes with the same smallest even value are found return the node that has smallest\
    \ index.\n/// The plucked node should be returned in an array, [ smalest_value,\
    \ its index ],\n/// If there are no even values or the given array is empty, return\
    \ [].\n/// Example 1:\n/// >>> pluck(arr: [4, 2, 3])\n/// [2, 1]\n/// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n/// Example 2:\n\
    /// >>> pluck(arr: [1, 2, 3])\n/// [2, 1]\n/// Explanation: 2 has the smallest\
    \ even value, and 2 has the smallest index.\n/// Example 3:\n/// >>> pluck(arr:\
    \ [] as [Int])\n/// [] as [Int]\n/// Example 4:\n/// >>> pluck(arr: [5, 0, 3,\
    \ 0, 4, 2])\n/// [0, 1]\n/// Explanation: 0 is the smallest value, but  there\
    \ are two zeros,\n/// so we will choose the first zero, which has the smallest\
    \ index.\n/// Constraints:\n/// * 1 <= nodes.length <= 10000\n/// * 0 <= node.value\n\
    func pluck(arr: [Int]) -> [Int] {\n    var smallest = Int.max\n    var smallestIndex\
    \ = -1\n    for (index, value) in arr.enumerated() {\n        if value % 2 ==\
    \ 0 && value < smallest {\n            smallest = value\n            smallestIndex\
    \ = index\n        }\n    }\n    if smallest == Int.max {\n        return []\n\
    \    }\n    return [smallest, smallestIndex]\n}\n\n\nfunc ==(left: [(Int, Int)],\
    \ right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n       \
    \ return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r\
    \ {\n            return false\n        }\n    }\n    return true\n}\n        \
    \    \nassert(pluck(arr: [4, 2, 3]) == [2, 1])\nassert(pluck(arr: [1, 2, 3]) ==\
    \ [2, 1])\nassert(pluck(arr: [] as [Int]) == [] as [Int])\nassert(pluck(arr: [5,\
    \ 0, 3, 0, 4, 2]) == [0, 1])\nassert(pluck(arr: [1, 2, 3, 0, 5, 3]) == [0, 3])\n\
    assert(pluck(arr: [5, 4, 8, 4, 8]) == [4, 1])\nassert(pluck(arr: [7, 6, 7, 1])\
    \ == [6, 1])\nassert(pluck(arr: [7, 9, 7, 1]) == [] as [Int])"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660013549
- exit_code: 1
  program: "\n/// \"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n/// your task is to pluck one of the nodes and return it.\n///\
    \ The plucked node should be the node with the smallest even value.\n/// If multiple\
    \ nodes with the same smallest even value are found return the node that has smallest\
    \ index.\n/// The plucked node should be returned in an array, [ smalest_value,\
    \ its index ],\n/// If there are no even values or the given array is empty, return\
    \ [].\n/// Example 1:\n/// >>> pluck(arr: [4, 2, 3])\n/// [2, 1]\n/// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n/// Example 2:\n\
    /// >>> pluck(arr: [1, 2, 3])\n/// [2, 1]\n/// Explanation: 2 has the smallest\
    \ even value, and 2 has the smallest index.\n/// Example 3:\n/// >>> pluck(arr:\
    \ [] as [Int])\n/// [] as [Int]\n/// Example 4:\n/// >>> pluck(arr: [5, 0, 3,\
    \ 0, 4, 2])\n/// [0, 1]\n/// Explanation: 0 is the smallest value, but  there\
    \ are two zeros,\n/// so we will choose the first zero, which has the smallest\
    \ index.\n/// Constraints:\n/// * 1 <= nodes.length <= 10000\n/// * 0 <= node.value\n\
    func pluck(arr: [Int]) -> [Int] {\n    var minEvenValue = arr.filter { $0.isEven\
    \ }.min()\n    var minEvenIndex = -1\n    for (i, n) in arr.enumerated() {\n \
    \       if n.isEven && (minEvenValue == nil || n < minEvenValue!) {\n        \
    \    minEvenValue = n\n            minEvenIndex = i\n        }\n    }\n    return\
    \ minEvenValue == nil ? [] : [minEvenValue!, minEvenIndex]\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(pluck(arr: [4, 2, 3]) == [2, 1])\nassert(pluck(arr: [1,\
    \ 2, 3]) == [2, 1])\nassert(pluck(arr: [] as [Int]) == [] as [Int])\nassert(pluck(arr:\
    \ [5, 0, 3, 0, 4, 2]) == [0, 1])\nassert(pluck(arr: [1, 2, 3, 0, 5, 3]) == [0,\
    \ 3])\nassert(pluck(arr: [5, 4, 8, 4, 8]) == [4, 1])\nassert(pluck(arr: [7, 6,\
    \ 7, 1]) == [6, 1])\nassert(pluck(arr: [7, 9, 7, 1]) == [] as [Int])"
  status: SyntaxError
  stderr: "/tmp/tmpf1oaw47z.swift:28:40: error: value of type 'Int' has no member\
    \ 'isEven'\n    var minEvenValue = arr.filter { $0.isEven }.min()\n          \
    \                          ~~ ^~~~~~\n/tmp/tmpf1oaw47z.swift:31:14: error: value\
    \ of type 'Int' has no member 'isEven'\n        if n.isEven && (minEvenValue ==\
    \ nil || n < minEvenValue!) {\n           ~ ^~~~~~\n"
  stdout: ''
  timestamp: 1660013549
- exit_code: 0
  program: "\n/// \"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n/// your task is to pluck one of the nodes and return it.\n///\
    \ The plucked node should be the node with the smallest even value.\n/// If multiple\
    \ nodes with the same smallest even value are found return the node that has smallest\
    \ index.\n/// The plucked node should be returned in an array, [ smalest_value,\
    \ its index ],\n/// If there are no even values or the given array is empty, return\
    \ [].\n/// Example 1:\n/// >>> pluck(arr: [4, 2, 3])\n/// [2, 1]\n/// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n/// Example 2:\n\
    /// >>> pluck(arr: [1, 2, 3])\n/// [2, 1]\n/// Explanation: 2 has the smallest\
    \ even value, and 2 has the smallest index.\n/// Example 3:\n/// >>> pluck(arr:\
    \ [] as [Int])\n/// [] as [Int]\n/// Example 4:\n/// >>> pluck(arr: [5, 0, 3,\
    \ 0, 4, 2])\n/// [0, 1]\n/// Explanation: 0 is the smallest value, but  there\
    \ are two zeros,\n/// so we will choose the first zero, which has the smallest\
    \ index.\n/// Constraints:\n/// * 1 <= nodes.length <= 10000\n/// * 0 <= node.value\n\
    func pluck(arr: [Int]) -> [Int] {\n    let even = arr.enumerated().filter { $0.element\
    \ % 2 == 0 }\n    let min = even.min { $0.element < $1.element }\n    return min?.element\
    \ == nil ? [] : [min!.element, min!.offset]\n}\n\n\nfunc ==(left: [(Int, Int)],\
    \ right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n       \
    \ return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r\
    \ {\n            return false\n        }\n    }\n    return true\n}\n        \
    \    \nassert(pluck(arr: [4, 2, 3]) == [2, 1])\nassert(pluck(arr: [1, 2, 3]) ==\
    \ [2, 1])\nassert(pluck(arr: [] as [Int]) == [] as [Int])\nassert(pluck(arr: [5,\
    \ 0, 3, 0, 4, 2]) == [0, 1])\nassert(pluck(arr: [1, 2, 3, 0, 5, 3]) == [0, 3])\n\
    assert(pluck(arr: [5, 4, 8, 4, 8]) == [4, 1])\nassert(pluck(arr: [7, 6, 7, 1])\
    \ == [6, 1])\nassert(pluck(arr: [7, 9, 7, 1]) == [] as [Int])"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660013549
- exit_code: 1
  program: "\n/// \"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n/// your task is to pluck one of the nodes and return it.\n///\
    \ The plucked node should be the node with the smallest even value.\n/// If multiple\
    \ nodes with the same smallest even value are found return the node that has smallest\
    \ index.\n/// The plucked node should be returned in an array, [ smalest_value,\
    \ its index ],\n/// If there are no even values or the given array is empty, return\
    \ [].\n/// Example 1:\n/// >>> pluck(arr: [4, 2, 3])\n/// [2, 1]\n/// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n/// Example 2:\n\
    /// >>> pluck(arr: [1, 2, 3])\n/// [2, 1]\n/// Explanation: 2 has the smallest\
    \ even value, and 2 has the smallest index.\n/// Example 3:\n/// >>> pluck(arr:\
    \ [] as [Int])\n/// [] as [Int]\n/// Example 4:\n/// >>> pluck(arr: [5, 0, 3,\
    \ 0, 4, 2])\n/// [0, 1]\n/// Explanation: 0 is the smallest value, but  there\
    \ are two zeros,\n/// so we will choose the first zero, which has the smallest\
    \ index.\n/// Constraints:\n/// * 1 <= nodes.length <= 10000\n/// * 0 <= node.value\n\
    func pluck(arr: [Int]) -> [Int] {\n    // return solution(&arr, arr.count - 1)\n\
    \    return solution(&arr, arr.count - 1, true)\n}\n\n\nfunc ==(left: [(Int, Int)],\
    \ right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n       \
    \ return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r\
    \ {\n            return false\n        }\n    }\n    return true\n}\n        \
    \    \nassert(pluck(arr: [4, 2, 3]) == [2, 1])\nassert(pluck(arr: [1, 2, 3]) ==\
    \ [2, 1])\nassert(pluck(arr: [] as [Int]) == [] as [Int])\nassert(pluck(arr: [5,\
    \ 0, 3, 0, 4, 2]) == [0, 1])\nassert(pluck(arr: [1, 2, 3, 0, 5, 3]) == [0, 3])\n\
    assert(pluck(arr: [5, 4, 8, 4, 8]) == [4, 1])\nassert(pluck(arr: [7, 6, 7, 1])\
    \ == [6, 1])\nassert(pluck(arr: [7, 9, 7, 1]) == [] as [Int])"
  status: SyntaxError
  stderr: "/tmp/tmpzlzbte16.swift:29:12: error: cannot find 'solution' in scope\n\
    \    return solution(&arr, arr.count - 1, true)\n           ^~~~~~~~\n/tmp/tmpzlzbte16.swift:29:21:\
    \ error: cannot pass immutable value as inout argument: 'arr' is a 'let' constant\n\
    \    return solution(&arr, arr.count - 1, true)\n                    ^~~~\n"
  stdout: ''
  timestamp: 1660013549
- exit_code: -4
  program: "\n/// \"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n/// your task is to pluck one of the nodes and return it.\n///\
    \ The plucked node should be the node with the smallest even value.\n/// If multiple\
    \ nodes with the same smallest even value are found return the node that has smallest\
    \ index.\n/// The plucked node should be returned in an array, [ smalest_value,\
    \ its index ],\n/// If there are no even values or the given array is empty, return\
    \ [].\n/// Example 1:\n/// >>> pluck(arr: [4, 2, 3])\n/// [2, 1]\n/// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n/// Example 2:\n\
    /// >>> pluck(arr: [1, 2, 3])\n/// [2, 1]\n/// Explanation: 2 has the smallest\
    \ even value, and 2 has the smallest index.\n/// Example 3:\n/// >>> pluck(arr:\
    \ [] as [Int])\n/// [] as [Int]\n/// Example 4:\n/// >>> pluck(arr: [5, 0, 3,\
    \ 0, 4, 2])\n/// [0, 1]\n/// Explanation: 0 is the smallest value, but  there\
    \ are two zeros,\n/// so we will choose the first zero, which has the smallest\
    \ index.\n/// Constraints:\n/// * 1 <= nodes.length <= 10000\n/// * 0 <= node.value\n\
    func pluck(arr: [Int]) -> [Int] {\n    // Your code here\n    return []\n}\n\n\
    \nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(pluck(arr: [4, 2, 3]) == [2, 1])\nassert(pluck(arr:\
    \ [1, 2, 3]) == [2, 1])\nassert(pluck(arr: [] as [Int]) == [] as [Int])\nassert(pluck(arr:\
    \ [5, 0, 3, 0, 4, 2]) == [0, 1])\nassert(pluck(arr: [1, 2, 3, 0, 5, 3]) == [0,\
    \ 3])\nassert(pluck(arr: [5, 4, 8, 4, 8]) == [4, 1])\nassert(pluck(arr: [7, 6,\
    \ 7, 1]) == [6, 1])\nassert(pluck(arr: [7, 9, 7, 1]) == [] as [Int])"
  status: Exception
  stderr: 'tmp_7k5pdjo/tmp_7k5pdjo.swift:45: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002ae1971d2c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002ae196ec9b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002ae196ec9988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002ae196ec87b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmp_7k5pdjo                        0x000055762e04f3bc <unavailable> + 5052

    5    libc.so.6                          0x00002ae1973be460 __libc_start_main +
    245

    6    tmp_7k5pdjo                        0x000055762e04efc9 <unavailable> + 4041

    '
  stdout: ''
  timestamp: 1660013549
- exit_code: -4
  program: "\n/// \"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n/// your task is to pluck one of the nodes and return it.\n///\
    \ The plucked node should be the node with the smallest even value.\n/// If multiple\
    \ nodes with the same smallest even value are found return the node that has smallest\
    \ index.\n/// The plucked node should be returned in an array, [ smalest_value,\
    \ its index ],\n/// If there are no even values or the given array is empty, return\
    \ [].\n/// Example 1:\n/// >>> pluck(arr: [4, 2, 3])\n/// [2, 1]\n/// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n/// Example 2:\n\
    /// >>> pluck(arr: [1, 2, 3])\n/// [2, 1]\n/// Explanation: 2 has the smallest\
    \ even value, and 2 has the smallest index.\n/// Example 3:\n/// >>> pluck(arr:\
    \ [] as [Int])\n/// [] as [Int]\n/// Example 4:\n/// >>> pluck(arr: [5, 0, 3,\
    \ 0, 4, 2])\n/// [0, 1]\n/// Explanation: 0 is the smallest value, but  there\
    \ are two zeros,\n/// so we will choose the first zero, which has the smallest\
    \ index.\n/// Constraints:\n/// * 1 <= nodes.length <= 10000\n/// * 0 <= node.value\n\
    func pluck(arr: [Int]) -> [Int] {\n    if arr.count == 0 {\n        return []\n\
    \    }\n    let minEven = arr.filter { $0 % 2 == 0 }.min()\n    let index = arr.firstIndex(of:\
    \ minEven!)!\n    return [minEven!, index]\n}\n\n\nfunc ==(left: [(Int, Int)],\
    \ right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n       \
    \ return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r\
    \ {\n            return false\n        }\n    }\n    return true\n}\n        \
    \    \nassert(pluck(arr: [4, 2, 3]) == [2, 1])\nassert(pluck(arr: [1, 2, 3]) ==\
    \ [2, 1])\nassert(pluck(arr: [] as [Int]) == [] as [Int])\nassert(pluck(arr: [5,\
    \ 0, 3, 0, 4, 2]) == [0, 1])\nassert(pluck(arr: [1, 2, 3, 0, 5, 3]) == [0, 3])\n\
    assert(pluck(arr: [5, 4, 8, 4, 8]) == [4, 1])\nassert(pluck(arr: [7, 6, 7, 1])\
    \ == [6, 1])\nassert(pluck(arr: [7, 9, 7, 1]) == [] as [Int])"
  status: Exception
  stderr: 'tmpmqrsma2d/tmpmqrsma2d.swift:32: Fatal error: Unexpectedly found nil while
    unwrapping an Optional value

    Current stack trace:

    0    libswiftCore.so                    0x00002b1891c23c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b189191a561 <unavailable> + 1434977

    2    libswiftCore.so                    0x00002b189191a286 <unavailable> + 1434246

    3    libswiftCore.so                    0x00002b189191a13c <unavailable> + 1433916

    4    libswiftCore.so                    0x00002b1891919bb0 _assertionFailure(_:_:file:line:flags:)
    + 251

    5    tmpmqrsma2d                        0x00005573df25612f <unavailable> + 8495

    6    tmpmqrsma2d                        0x00005573df255e78 <unavailable> + 7800

    7    libc.so.6                          0x00002b1891e0f460 __libc_start_main +
    245

    8    tmpmqrsma2d                        0x00005573df2552c9 <unavailable> + 4809

    '
  stdout: ''
  timestamp: 1660013549
- exit_code: 0
  program: "\n/// \"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n/// your task is to pluck one of the nodes and return it.\n///\
    \ The plucked node should be the node with the smallest even value.\n/// If multiple\
    \ nodes with the same smallest even value are found return the node that has smallest\
    \ index.\n/// The plucked node should be returned in an array, [ smalest_value,\
    \ its index ],\n/// If there are no even values or the given array is empty, return\
    \ [].\n/// Example 1:\n/// >>> pluck(arr: [4, 2, 3])\n/// [2, 1]\n/// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n/// Example 2:\n\
    /// >>> pluck(arr: [1, 2, 3])\n/// [2, 1]\n/// Explanation: 2 has the smallest\
    \ even value, and 2 has the smallest index.\n/// Example 3:\n/// >>> pluck(arr:\
    \ [] as [Int])\n/// [] as [Int]\n/// Example 4:\n/// >>> pluck(arr: [5, 0, 3,\
    \ 0, 4, 2])\n/// [0, 1]\n/// Explanation: 0 is the smallest value, but  there\
    \ are two zeros,\n/// so we will choose the first zero, which has the smallest\
    \ index.\n/// Constraints:\n/// * 1 <= nodes.length <= 10000\n/// * 0 <= node.value\n\
    func pluck(arr: [Int]) -> [Int] {\n    guard arr.contains(where: { $0 % 2 == 0\
    \ }) else { return [] }\n    let evens = arr.filter({ $0 % 2 == 0 })\n    guard\
    \ let min = evens.min() else { return [] }\n    let minIndex = arr.firstIndex(of:\
    \ min) ?? -1\n    return [min, minIndex]\n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(pluck(arr: [4, 2, 3]) == [2, 1])\nassert(pluck(arr: [1, 2, 3]) == [2, 1])\n\
    assert(pluck(arr: [] as [Int]) == [] as [Int])\nassert(pluck(arr: [5, 0, 3, 0,\
    \ 4, 2]) == [0, 1])\nassert(pluck(arr: [1, 2, 3, 0, 5, 3]) == [0, 3])\nassert(pluck(arr:\
    \ [5, 4, 8, 4, 8]) == [4, 1])\nassert(pluck(arr: [7, 6, 7, 1]) == [6, 1])\nassert(pluck(arr:\
    \ [7, 9, 7, 1]) == [] as [Int])"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660013549
- exit_code: 0
  program: "\n/// \"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n/// your task is to pluck one of the nodes and return it.\n///\
    \ The plucked node should be the node with the smallest even value.\n/// If multiple\
    \ nodes with the same smallest even value are found return the node that has smallest\
    \ index.\n/// The plucked node should be returned in an array, [ smalest_value,\
    \ its index ],\n/// If there are no even values or the given array is empty, return\
    \ [].\n/// Example 1:\n/// >>> pluck(arr: [4, 2, 3])\n/// [2, 1]\n/// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n/// Example 2:\n\
    /// >>> pluck(arr: [1, 2, 3])\n/// [2, 1]\n/// Explanation: 2 has the smallest\
    \ even value, and 2 has the smallest index.\n/// Example 3:\n/// >>> pluck(arr:\
    \ [] as [Int])\n/// [] as [Int]\n/// Example 4:\n/// >>> pluck(arr: [5, 0, 3,\
    \ 0, 4, 2])\n/// [0, 1]\n/// Explanation: 0 is the smallest value, but  there\
    \ are two zeros,\n/// so we will choose the first zero, which has the smallest\
    \ index.\n/// Constraints:\n/// * 1 <= nodes.length <= 10000\n/// * 0 <= node.value\n\
    func pluck(arr: [Int]) -> [Int] {\n    var result = [Int]()\n    guard arr.count\
    \ > 0 else { return result }\n    var smallestValue = Int.max\n    var smallestIndex\
    \ = 0\n    for (index, value) in arr.enumerated() {\n        if value % 2 == 0\
    \ && value < smallestValue {\n            smallestValue = value\n            smallestIndex\
    \ = index\n        }\n    }\n    if smallestValue != Int.max {\n        result.append(smallestValue)\n\
    \        result.append(smallestIndex)\n    }\n    return result\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(pluck(arr: [4, 2, 3]) == [2, 1])\nassert(pluck(arr: [1,\
    \ 2, 3]) == [2, 1])\nassert(pluck(arr: [] as [Int]) == [] as [Int])\nassert(pluck(arr:\
    \ [5, 0, 3, 0, 4, 2]) == [0, 1])\nassert(pluck(arr: [1, 2, 3, 0, 5, 3]) == [0,\
    \ 3])\nassert(pluck(arr: [5, 4, 8, 4, 8]) == [4, 1])\nassert(pluck(arr: [7, 6,\
    \ 7, 1]) == [6, 1])\nassert(pluck(arr: [7, 9, 7, 1]) == [] as [Int])"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660013550
- exit_code: 0
  program: "\n/// \"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n/// your task is to pluck one of the nodes and return it.\n///\
    \ The plucked node should be the node with the smallest even value.\n/// If multiple\
    \ nodes with the same smallest even value are found return the node that has smallest\
    \ index.\n/// The plucked node should be returned in an array, [ smalest_value,\
    \ its index ],\n/// If there are no even values or the given array is empty, return\
    \ [].\n/// Example 1:\n/// >>> pluck(arr: [4, 2, 3])\n/// [2, 1]\n/// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n/// Example 2:\n\
    /// >>> pluck(arr: [1, 2, 3])\n/// [2, 1]\n/// Explanation: 2 has the smallest\
    \ even value, and 2 has the smallest index.\n/// Example 3:\n/// >>> pluck(arr:\
    \ [] as [Int])\n/// [] as [Int]\n/// Example 4:\n/// >>> pluck(arr: [5, 0, 3,\
    \ 0, 4, 2])\n/// [0, 1]\n/// Explanation: 0 is the smallest value, but  there\
    \ are two zeros,\n/// so we will choose the first zero, which has the smallest\
    \ index.\n/// Constraints:\n/// * 1 <= nodes.length <= 10000\n/// * 0 <= node.value\n\
    func pluck(arr: [Int]) -> [Int] {\n    guard !arr.isEmpty else { return [] }\n\
    \    let evens = arr.filter { $0 % 2 == 0 }\n    guard !evens.isEmpty else { return\
    \ [] }\n    var result = [Int]()\n    var min = Int.max\n    for (index, element)\
    \ in arr.enumerated() {\n        if element % 2 == 0 && element < min {\n    \
    \        min = element\n            result = [element, index]\n        }\n   \
    \ }\n    return result\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(pluck(arr:\
    \ [4, 2, 3]) == [2, 1])\nassert(pluck(arr: [1, 2, 3]) == [2, 1])\nassert(pluck(arr:\
    \ [] as [Int]) == [] as [Int])\nassert(pluck(arr: [5, 0, 3, 0, 4, 2]) == [0, 1])\n\
    assert(pluck(arr: [1, 2, 3, 0, 5, 3]) == [0, 3])\nassert(pluck(arr: [5, 4, 8,\
    \ 4, 8]) == [4, 1])\nassert(pluck(arr: [7, 6, 7, 1]) == [6, 1])\nassert(pluck(arr:\
    \ [7, 9, 7, 1]) == [] as [Int])"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660013550
- exit_code: 0
  program: "\n/// \"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n/// your task is to pluck one of the nodes and return it.\n///\
    \ The plucked node should be the node with the smallest even value.\n/// If multiple\
    \ nodes with the same smallest even value are found return the node that has smallest\
    \ index.\n/// The plucked node should be returned in an array, [ smalest_value,\
    \ its index ],\n/// If there are no even values or the given array is empty, return\
    \ [].\n/// Example 1:\n/// >>> pluck(arr: [4, 2, 3])\n/// [2, 1]\n/// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n/// Example 2:\n\
    /// >>> pluck(arr: [1, 2, 3])\n/// [2, 1]\n/// Explanation: 2 has the smallest\
    \ even value, and 2 has the smallest index.\n/// Example 3:\n/// >>> pluck(arr:\
    \ [] as [Int])\n/// [] as [Int]\n/// Example 4:\n/// >>> pluck(arr: [5, 0, 3,\
    \ 0, 4, 2])\n/// [0, 1]\n/// Explanation: 0 is the smallest value, but  there\
    \ are two zeros,\n/// so we will choose the first zero, which has the smallest\
    \ index.\n/// Constraints:\n/// * 1 <= nodes.length <= 10000\n/// * 0 <= node.value\n\
    func pluck(arr: [Int]) -> [Int] {\n    var result = [Int]()\n    if arr.isEmpty\
    \ {\n        return result\n    }\n    var evens = [Int]()\n    var evenIndexes\
    \ = [Int]()\n    for (index, value) in arr.enumerated() {\n        if value.isMultiple(of:\
    \ 2) {\n            evens.append(value)\n            evenIndexes.append(index)\n\
    \        }\n    }\n    if evens.isEmpty {\n        return result\n    }\n    let\
    \ lowestEven = evens.min()!\n    let index = evenIndexes[evens.firstIndex(of:\
    \ lowestEven)!]\n    result.append(lowestEven)\n    result.append(index)\n   \
    \ return result\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool\
    \ {\n    if left.count != right.count {\n        return false\n    }\n    for\
    \ (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(pluck(arr: [4, 2,\
    \ 3]) == [2, 1])\nassert(pluck(arr: [1, 2, 3]) == [2, 1])\nassert(pluck(arr: []\
    \ as [Int]) == [] as [Int])\nassert(pluck(arr: [5, 0, 3, 0, 4, 2]) == [0, 1])\n\
    assert(pluck(arr: [1, 2, 3, 0, 5, 3]) == [0, 3])\nassert(pluck(arr: [5, 4, 8,\
    \ 4, 8]) == [4, 1])\nassert(pluck(arr: [7, 6, 7, 1]) == [6, 1])\nassert(pluck(arr:\
    \ [7, 9, 7, 1]) == [] as [Int])"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660013550
- exit_code: 0
  program: "\n/// \"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n/// your task is to pluck one of the nodes and return it.\n///\
    \ The plucked node should be the node with the smallest even value.\n/// If multiple\
    \ nodes with the same smallest even value are found return the node that has smallest\
    \ index.\n/// The plucked node should be returned in an array, [ smalest_value,\
    \ its index ],\n/// If there are no even values or the given array is empty, return\
    \ [].\n/// Example 1:\n/// >>> pluck(arr: [4, 2, 3])\n/// [2, 1]\n/// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n/// Example 2:\n\
    /// >>> pluck(arr: [1, 2, 3])\n/// [2, 1]\n/// Explanation: 2 has the smallest\
    \ even value, and 2 has the smallest index.\n/// Example 3:\n/// >>> pluck(arr:\
    \ [] as [Int])\n/// [] as [Int]\n/// Example 4:\n/// >>> pluck(arr: [5, 0, 3,\
    \ 0, 4, 2])\n/// [0, 1]\n/// Explanation: 0 is the smallest value, but  there\
    \ are two zeros,\n/// so we will choose the first zero, which has the smallest\
    \ index.\n/// Constraints:\n/// * 1 <= nodes.length <= 10000\n/// * 0 <= node.value\n\
    func pluck(arr: [Int]) -> [Int] {\n    return arr.indices.filter({arr[$0] % 2\
    \ == 0}).min(by: { arr[$0] < arr[$1] }).map({ [arr[$0], $0] }) ?? []\n}\n\n\n\
    func ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(pluck(arr: [4, 2, 3]) == [2, 1])\nassert(pluck(arr:\
    \ [1, 2, 3]) == [2, 1])\nassert(pluck(arr: [] as [Int]) == [] as [Int])\nassert(pluck(arr:\
    \ [5, 0, 3, 0, 4, 2]) == [0, 1])\nassert(pluck(arr: [1, 2, 3, 0, 5, 3]) == [0,\
    \ 3])\nassert(pluck(arr: [5, 4, 8, 4, 8]) == [4, 1])\nassert(pluck(arr: [7, 6,\
    \ 7, 1]) == [6, 1])\nassert(pluck(arr: [7, 9, 7, 1]) == [] as [Int])"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660013550
- exit_code: 0
  program: "\n/// \"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n/// your task is to pluck one of the nodes and return it.\n///\
    \ The plucked node should be the node with the smallest even value.\n/// If multiple\
    \ nodes with the same smallest even value are found return the node that has smallest\
    \ index.\n/// The plucked node should be returned in an array, [ smalest_value,\
    \ its index ],\n/// If there are no even values or the given array is empty, return\
    \ [].\n/// Example 1:\n/// >>> pluck(arr: [4, 2, 3])\n/// [2, 1]\n/// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n/// Example 2:\n\
    /// >>> pluck(arr: [1, 2, 3])\n/// [2, 1]\n/// Explanation: 2 has the smallest\
    \ even value, and 2 has the smallest index.\n/// Example 3:\n/// >>> pluck(arr:\
    \ [] as [Int])\n/// [] as [Int]\n/// Example 4:\n/// >>> pluck(arr: [5, 0, 3,\
    \ 0, 4, 2])\n/// [0, 1]\n/// Explanation: 0 is the smallest value, but  there\
    \ are two zeros,\n/// so we will choose the first zero, which has the smallest\
    \ index.\n/// Constraints:\n/// * 1 <= nodes.length <= 10000\n/// * 0 <= node.value\n\
    func pluck(arr: [Int]) -> [Int] {\n    \n    var evenNumbers: [Int] = []\n   \
    \ var indexArray: [Int] = []\n    \n    for (index, number) in arr.enumerated()\
    \ {\n        if number % 2 == 0 {\n            evenNumbers.append(number)\n  \
    \          indexArray.append(index)\n        }\n    }\n    \n    if evenNumbers.count\
    \ == 0 {\n        return []\n    }\n    \n    var smallestIndex = -1\n    var\
    \ smallestNumber = -1\n    \n    for (index, number) in evenNumbers.enumerated()\
    \ {\n        if smallestNumber == -1 {\n            smallestNumber = number\n\
    \            smallestIndex = index\n        } else if number < smallestNumber\
    \ {\n            smallestNumber = number\n            smallestIndex = index\n\
    \        }\n    }\n    \n    return [smallestNumber, indexArray[smallestIndex]]\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(pluck(arr: [4, 2, 3]) == [2, 1])\nassert(pluck(arr:\
    \ [1, 2, 3]) == [2, 1])\nassert(pluck(arr: [] as [Int]) == [] as [Int])\nassert(pluck(arr:\
    \ [5, 0, 3, 0, 4, 2]) == [0, 1])\nassert(pluck(arr: [1, 2, 3, 0, 5, 3]) == [0,\
    \ 3])\nassert(pluck(arr: [5, 4, 8, 4, 8]) == [4, 1])\nassert(pluck(arr: [7, 6,\
    \ 7, 1]) == [6, 1])\nassert(pluck(arr: [7, 9, 7, 1]) == [] as [Int])"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660013550
- exit_code: 0
  program: "\n/// \"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n/// your task is to pluck one of the nodes and return it.\n///\
    \ The plucked node should be the node with the smallest even value.\n/// If multiple\
    \ nodes with the same smallest even value are found return the node that has smallest\
    \ index.\n/// The plucked node should be returned in an array, [ smalest_value,\
    \ its index ],\n/// If there are no even values or the given array is empty, return\
    \ [].\n/// Example 1:\n/// >>> pluck(arr: [4, 2, 3])\n/// [2, 1]\n/// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n/// Example 2:\n\
    /// >>> pluck(arr: [1, 2, 3])\n/// [2, 1]\n/// Explanation: 2 has the smallest\
    \ even value, and 2 has the smallest index.\n/// Example 3:\n/// >>> pluck(arr:\
    \ [] as [Int])\n/// [] as [Int]\n/// Example 4:\n/// >>> pluck(arr: [5, 0, 3,\
    \ 0, 4, 2])\n/// [0, 1]\n/// Explanation: 0 is the smallest value, but  there\
    \ are two zeros,\n/// so we will choose the first zero, which has the smallest\
    \ index.\n/// Constraints:\n/// * 1 <= nodes.length <= 10000\n/// * 0 <= node.value\n\
    func pluck(arr: [Int]) -> [Int] {\n    guard arr.count > 0 else { return [] }\n\
    \    let evenValues = arr.filter { $0 % 2 == 0 }\n    guard evenValues.count >\
    \ 0 else { return [] }\n    let smallestEven = evenValues.min()!\n    guard let\
    \ index = arr.firstIndex(of: smallestEven) else {\n        fatalError(\"Unexpected\
    \ condition\")\n    }\n    return [smallestEven, index]\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(pluck(arr: [4, 2, 3]) == [2, 1])\nassert(pluck(arr: [1,\
    \ 2, 3]) == [2, 1])\nassert(pluck(arr: [] as [Int]) == [] as [Int])\nassert(pluck(arr:\
    \ [5, 0, 3, 0, 4, 2]) == [0, 1])\nassert(pluck(arr: [1, 2, 3, 0, 5, 3]) == [0,\
    \ 3])\nassert(pluck(arr: [5, 4, 8, 4, 8]) == [4, 1])\nassert(pluck(arr: [7, 6,\
    \ 7, 1]) == [6, 1])\nassert(pluck(arr: [7, 9, 7, 1]) == [] as [Int])"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660013550
- exit_code: -4
  program: "\n/// \"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n/// your task is to pluck one of the nodes and return it.\n///\
    \ The plucked node should be the node with the smallest even value.\n/// If multiple\
    \ nodes with the same smallest even value are found return the node that has smallest\
    \ index.\n/// The plucked node should be returned in an array, [ smalest_value,\
    \ its index ],\n/// If there are no even values or the given array is empty, return\
    \ [].\n/// Example 1:\n/// >>> pluck(arr: [4, 2, 3])\n/// [2, 1]\n/// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n/// Example 2:\n\
    /// >>> pluck(arr: [1, 2, 3])\n/// [2, 1]\n/// Explanation: 2 has the smallest\
    \ even value, and 2 has the smallest index.\n/// Example 3:\n/// >>> pluck(arr:\
    \ [] as [Int])\n/// [] as [Int]\n/// Example 4:\n/// >>> pluck(arr: [5, 0, 3,\
    \ 0, 4, 2])\n/// [0, 1]\n/// Explanation: 0 is the smallest value, but  there\
    \ are two zeros,\n/// so we will choose the first zero, which has the smallest\
    \ index.\n/// Constraints:\n/// * 1 <= nodes.length <= 10000\n/// * 0 <= node.value\n\
    func pluck(arr: [Int]) -> [Int] {\n    //guard arr.isEmpty else { return arr }\n\
    \    let answer: [Int] = arr.filter { $0 % 2 == 0 }.sorted { $0 < $1 }.prefix(1).map\
    \ { $0 }\n    return answer\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int,\
    \ Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n\
    \    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n          \
    \  return false\n        }\n    }\n    return true\n}\n            \nassert(pluck(arr:\
    \ [4, 2, 3]) == [2, 1])\nassert(pluck(arr: [1, 2, 3]) == [2, 1])\nassert(pluck(arr:\
    \ [] as [Int]) == [] as [Int])\nassert(pluck(arr: [5, 0, 3, 0, 4, 2]) == [0, 1])\n\
    assert(pluck(arr: [1, 2, 3, 0, 5, 3]) == [0, 3])\nassert(pluck(arr: [5, 4, 8,\
    \ 4, 8]) == [4, 1])\nassert(pluck(arr: [7, 6, 7, 1]) == [6, 1])\nassert(pluck(arr:\
    \ [7, 9, 7, 1]) == [] as [Int])"
  status: Exception
  stderr: 'tmpwh0i8gi6/tmpwh0i8gi6.swift:46: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002ad6d1ed5c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002ad6d1bccb6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002ad6d1bcc988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002ad6d1bcb7b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpwh0i8gi6                        0x00005619af26572c <unavailable> + 5932

    5    libc.so.6                          0x00002ad6d20c1460 __libc_start_main +
    245

    6    tmpwh0i8gi6                        0x00005619af265339 <unavailable> + 4921

    '
  stdout: ''
  timestamp: 1660013550
- exit_code: -4
  program: "\n/// \"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n/// your task is to pluck one of the nodes and return it.\n///\
    \ The plucked node should be the node with the smallest even value.\n/// If multiple\
    \ nodes with the same smallest even value are found return the node that has smallest\
    \ index.\n/// The plucked node should be returned in an array, [ smalest_value,\
    \ its index ],\n/// If there are no even values or the given array is empty, return\
    \ [].\n/// Example 1:\n/// >>> pluck(arr: [4, 2, 3])\n/// [2, 1]\n/// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n/// Example 2:\n\
    /// >>> pluck(arr: [1, 2, 3])\n/// [2, 1]\n/// Explanation: 2 has the smallest\
    \ even value, and 2 has the smallest index.\n/// Example 3:\n/// >>> pluck(arr:\
    \ [] as [Int])\n/// [] as [Int]\n/// Example 4:\n/// >>> pluck(arr: [5, 0, 3,\
    \ 0, 4, 2])\n/// [0, 1]\n/// Explanation: 0 is the smallest value, but  there\
    \ are two zeros,\n/// so we will choose the first zero, which has the smallest\
    \ index.\n/// Constraints:\n/// * 1 <= nodes.length <= 10000\n/// * 0 <= node.value\n\
    func pluck(arr: [Int]) -> [Int] {\n    // Enter code here\n    return []\n}\n\n\
    \nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(pluck(arr: [4, 2, 3]) == [2, 1])\nassert(pluck(arr:\
    \ [1, 2, 3]) == [2, 1])\nassert(pluck(arr: [] as [Int]) == [] as [Int])\nassert(pluck(arr:\
    \ [5, 0, 3, 0, 4, 2]) == [0, 1])\nassert(pluck(arr: [1, 2, 3, 0, 5, 3]) == [0,\
    \ 3])\nassert(pluck(arr: [5, 4, 8, 4, 8]) == [4, 1])\nassert(pluck(arr: [7, 6,\
    \ 7, 1]) == [6, 1])\nassert(pluck(arr: [7, 9, 7, 1]) == [] as [Int])"
  status: Exception
  stderr: 'tmppl_nr6z9/tmppl_nr6z9.swift:45: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b44f00dac80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b44efdd1b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b44efdd1988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b44efdd07b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmppl_nr6z9                        0x00005582457753bc <unavailable> + 5052

    5    libc.so.6                          0x00002b44f02c6460 __libc_start_main +
    245

    6    tmppl_nr6z9                        0x0000558245774fc9 <unavailable> + 4041

    '
  stdout: ''
  timestamp: 1660013550
- exit_code: 0
  program: "\n/// \"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n/// your task is to pluck one of the nodes and return it.\n///\
    \ The plucked node should be the node with the smallest even value.\n/// If multiple\
    \ nodes with the same smallest even value are found return the node that has smallest\
    \ index.\n/// The plucked node should be returned in an array, [ smalest_value,\
    \ its index ],\n/// If there are no even values or the given array is empty, return\
    \ [].\n/// Example 1:\n/// >>> pluck(arr: [4, 2, 3])\n/// [2, 1]\n/// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n/// Example 2:\n\
    /// >>> pluck(arr: [1, 2, 3])\n/// [2, 1]\n/// Explanation: 2 has the smallest\
    \ even value, and 2 has the smallest index.\n/// Example 3:\n/// >>> pluck(arr:\
    \ [] as [Int])\n/// [] as [Int]\n/// Example 4:\n/// >>> pluck(arr: [5, 0, 3,\
    \ 0, 4, 2])\n/// [0, 1]\n/// Explanation: 0 is the smallest value, but  there\
    \ are two zeros,\n/// so we will choose the first zero, which has the smallest\
    \ index.\n/// Constraints:\n/// * 1 <= nodes.length <= 10000\n/// * 0 <= node.value\n\
    func pluck(arr: [Int]) -> [Int] {\n    var allEvenNodes = [Int]()\n    var evenNodeIndex\
    \ = [Int]()\n    var smallEvenNode: Int?\n    var result = [Int]()\n    \n   \
    \ for (index, node) in arr.enumerated() {\n        if node % 2 == 0 {\n      \
    \      allEvenNodes.append(node)\n            evenNodeIndex.append(index)\n  \
    \      }\n    }\n    \n    if allEvenNodes.count > 0 {\n        smallEvenNode\
    \ = allEvenNodes.min()\n        for index in 0..<allEvenNodes.count {\n      \
    \      if allEvenNodes[index] == smallEvenNode {\n                result.append(smallEvenNode!)\n\
    \                result.append(evenNodeIndex[index])\n                break\n\
    \            }\n        }\n    }\n    \n    return result\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(pluck(arr: [4, 2, 3]) == [2, 1])\nassert(pluck(arr: [1,\
    \ 2, 3]) == [2, 1])\nassert(pluck(arr: [] as [Int]) == [] as [Int])\nassert(pluck(arr:\
    \ [5, 0, 3, 0, 4, 2]) == [0, 1])\nassert(pluck(arr: [1, 2, 3, 0, 5, 3]) == [0,\
    \ 3])\nassert(pluck(arr: [5, 4, 8, 4, 8]) == [4, 1])\nassert(pluck(arr: [7, 6,\
    \ 7, 1]) == [6, 1])\nassert(pluck(arr: [7, 9, 7, 1]) == [] as [Int])"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660013550
- exit_code: -4
  program: "\n/// \"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n/// your task is to pluck one of the nodes and return it.\n///\
    \ The plucked node should be the node with the smallest even value.\n/// If multiple\
    \ nodes with the same smallest even value are found return the node that has smallest\
    \ index.\n/// The plucked node should be returned in an array, [ smalest_value,\
    \ its index ],\n/// If there are no even values or the given array is empty, return\
    \ [].\n/// Example 1:\n/// >>> pluck(arr: [4, 2, 3])\n/// [2, 1]\n/// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n/// Example 2:\n\
    /// >>> pluck(arr: [1, 2, 3])\n/// [2, 1]\n/// Explanation: 2 has the smallest\
    \ even value, and 2 has the smallest index.\n/// Example 3:\n/// >>> pluck(arr:\
    \ [] as [Int])\n/// [] as [Int]\n/// Example 4:\n/// >>> pluck(arr: [5, 0, 3,\
    \ 0, 4, 2])\n/// [0, 1]\n/// Explanation: 0 is the smallest value, but  there\
    \ are two zeros,\n/// so we will choose the first zero, which has the smallest\
    \ index.\n/// Constraints:\n/// * 1 <= nodes.length <= 10000\n/// * 0 <= node.value\n\
    func pluck(arr: [Int]) -> [Int] {\n    return []\n}\n\n\nfunc ==(left: [(Int,\
    \ Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n\
    \        return false\n    }\n    for (l, r) in zip(left, right) {\n        if\
    \ l != r {\n            return false\n        }\n    }\n    return true\n}\n \
    \           \nassert(pluck(arr: [4, 2, 3]) == [2, 1])\nassert(pluck(arr: [1, 2,\
    \ 3]) == [2, 1])\nassert(pluck(arr: [] as [Int]) == [] as [Int])\nassert(pluck(arr:\
    \ [5, 0, 3, 0, 4, 2]) == [0, 1])\nassert(pluck(arr: [1, 2, 3, 0, 5, 3]) == [0,\
    \ 3])\nassert(pluck(arr: [5, 4, 8, 4, 8]) == [4, 1])\nassert(pluck(arr: [7, 6,\
    \ 7, 1]) == [6, 1])\nassert(pluck(arr: [7, 9, 7, 1]) == [] as [Int])"
  status: Exception
  stderr: 'tmpgh8dpvxh/tmpgh8dpvxh.swift:44: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002ac906ec4c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002ac906bbbb6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002ac906bbb988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002ac906bba7b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpgh8dpvxh                        0x00005578e3d9c3bc <unavailable> + 5052

    5    libc.so.6                          0x00002ac9070b0460 __libc_start_main +
    245

    6    tmpgh8dpvxh                        0x00005578e3d9bfc9 <unavailable> + 4041

    '
  stdout: ''
  timestamp: 1660013365
- exit_code: -4
  program: "\n/// \"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n/// your task is to pluck one of the nodes and return it.\n///\
    \ The plucked node should be the node with the smallest even value.\n/// If multiple\
    \ nodes with the same smallest even value are found return the node that has smallest\
    \ index.\n/// The plucked node should be returned in an array, [ smalest_value,\
    \ its index ],\n/// If there are no even values or the given array is empty, return\
    \ [].\n/// Example 1:\n/// >>> pluck(arr: [4, 2, 3])\n/// [2, 1]\n/// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n/// Example 2:\n\
    /// >>> pluck(arr: [1, 2, 3])\n/// [2, 1]\n/// Explanation: 2 has the smallest\
    \ even value, and 2 has the smallest index.\n/// Example 3:\n/// >>> pluck(arr:\
    \ [] as [Int])\n/// [] as [Int]\n/// Example 4:\n/// >>> pluck(arr: [5, 0, 3,\
    \ 0, 4, 2])\n/// [0, 1]\n/// Explanation: 0 is the smallest value, but  there\
    \ are two zeros,\n/// so we will choose the first zero, which has the smallest\
    \ index.\n/// Constraints:\n/// * 1 <= nodes.length <= 10000\n/// * 0 <= node.value\n\
    func pluck(arr: [Int]) -> [Int] {\n    // This can be solved in a one-liner, but\
    \ I'll try to make it as readable as possible\n    // 1) Get all even values\n\
    \    let even = arr.filter { $0 % 2 == 0 }\n    // 2) Get the smallest value from\
    \ even values\n    let smallest = even.min() ?? 0\n    // 3) Get an index of the\
    \ smallest value\n    let smallestIndex = arr.firstIndex(of: smallest) ?? 0\n\
    \    // 4) Return the result\n    return [smallest, smallestIndex]\n}\n\n\nfunc\
    \ ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count !=\
    \ right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(pluck(arr: [4, 2, 3]) == [2, 1])\nassert(pluck(arr:\
    \ [1, 2, 3]) == [2, 1])\nassert(pluck(arr: [] as [Int]) == [] as [Int])\nassert(pluck(arr:\
    \ [5, 0, 3, 0, 4, 2]) == [0, 1])\nassert(pluck(arr: [1, 2, 3, 0, 5, 3]) == [0,\
    \ 3])\nassert(pluck(arr: [5, 4, 8, 4, 8]) == [4, 1])\nassert(pluck(arr: [7, 6,\
    \ 7, 1]) == [6, 1])\nassert(pluck(arr: [7, 9, 7, 1]) == [] as [Int])"
  status: Exception
  stderr: 'tmpmktg1iea/tmpmktg1iea.swift:54: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b32f1fecc80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b32f1ce3b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b32f1ce3988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b32f1ce27b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpmktg1iea                        0x000055ba87a0a876 <unavailable> + 6262

    5    libc.so.6                          0x00002b32f21d8460 __libc_start_main +
    245

    6    tmpmktg1iea                        0x000055ba87a0a279 <unavailable> + 4729

    '
  stdout: ''
  timestamp: 1660013550
- exit_code: -4
  program: "\n/// \"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n/// your task is to pluck one of the nodes and return it.\n///\
    \ The plucked node should be the node with the smallest even value.\n/// If multiple\
    \ nodes with the same smallest even value are found return the node that has smallest\
    \ index.\n/// The plucked node should be returned in an array, [ smalest_value,\
    \ its index ],\n/// If there are no even values or the given array is empty, return\
    \ [].\n/// Example 1:\n/// >>> pluck(arr: [4, 2, 3])\n/// [2, 1]\n/// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n/// Example 2:\n\
    /// >>> pluck(arr: [1, 2, 3])\n/// [2, 1]\n/// Explanation: 2 has the smallest\
    \ even value, and 2 has the smallest index.\n/// Example 3:\n/// >>> pluck(arr:\
    \ [] as [Int])\n/// [] as [Int]\n/// Example 4:\n/// >>> pluck(arr: [5, 0, 3,\
    \ 0, 4, 2])\n/// [0, 1]\n/// Explanation: 0 is the smallest value, but  there\
    \ are two zeros,\n/// so we will choose the first zero, which has the smallest\
    \ index.\n/// Constraints:\n/// * 1 <= nodes.length <= 10000\n/// * 0 <= node.value\n\
    func pluck(arr: [Int]) -> [Int] {\n    if arr.count == 0 {\n        return []\n\
    \    }\n    var smallest = 0\n    var index = 0\n    for (i, v) in arr.enumerated()\
    \ {\n        if v % 2 == 0 {\n            if smallest == 0 {\n               \
    \ smallest = v\n                index = i\n            } else if v < smallest\
    \ {\n                smallest = v\n                index = i\n            }\n\
    \        }\n    }\n    if smallest == 0 {\n        return []\n    }\n    return\
    \ [smallest, index]\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) ->\
    \ Bool {\n    if left.count != right.count {\n        return false\n    }\n  \
    \  for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(pluck(arr: [4, 2,\
    \ 3]) == [2, 1])\nassert(pluck(arr: [1, 2, 3]) == [2, 1])\nassert(pluck(arr: []\
    \ as [Int]) == [] as [Int])\nassert(pluck(arr: [5, 0, 3, 0, 4, 2]) == [0, 1])\n\
    assert(pluck(arr: [1, 2, 3, 0, 5, 3]) == [0, 3])\nassert(pluck(arr: [5, 4, 8,\
    \ 4, 8]) == [4, 1])\nassert(pluck(arr: [7, 6, 7, 1]) == [6, 1])\nassert(pluck(arr:\
    \ [7, 9, 7, 1]) == [] as [Int])"
  status: Exception
  stderr: 'tmpzhswr9qn/tmpzhswr9qn.swift:66: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002afc9874ec80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002afc98445b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002afc98445988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002afc984447b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpzhswr9qn                        0x000056301ced3a24 <unavailable> + 6692

    5    libc.so.6                          0x00002afc9893a460 __libc_start_main +
    245

    6    tmpzhswr9qn                        0x000056301ced32c9 <unavailable> + 4809

    '
  stdout: ''
  timestamp: 1660013550
- exit_code: 0
  program: "\n/// \"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n/// your task is to pluck one of the nodes and return it.\n///\
    \ The plucked node should be the node with the smallest even value.\n/// If multiple\
    \ nodes with the same smallest even value are found return the node that has smallest\
    \ index.\n/// The plucked node should be returned in an array, [ smalest_value,\
    \ its index ],\n/// If there are no even values or the given array is empty, return\
    \ [].\n/// Example 1:\n/// >>> pluck(arr: [4, 2, 3])\n/// [2, 1]\n/// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n/// Example 2:\n\
    /// >>> pluck(arr: [1, 2, 3])\n/// [2, 1]\n/// Explanation: 2 has the smallest\
    \ even value, and 2 has the smallest index.\n/// Example 3:\n/// >>> pluck(arr:\
    \ [] as [Int])\n/// [] as [Int]\n/// Example 4:\n/// >>> pluck(arr: [5, 0, 3,\
    \ 0, 4, 2])\n/// [0, 1]\n/// Explanation: 0 is the smallest value, but  there\
    \ are two zeros,\n/// so we will choose the first zero, which has the smallest\
    \ index.\n/// Constraints:\n/// * 1 <= nodes.length <= 10000\n/// * 0 <= node.value\n\
    func pluck(arr: [Int]) -> [Int] {\n    guard !arr.isEmpty else { return [] }\n\
    \    let evenNumbers = arr.filter { $0 % 2 == 0 }\n    guard !evenNumbers.isEmpty\
    \ else { return [] }\n    let minEvenNumber = evenNumbers.min()!\n    guard let\
    \ minEvenNumberIndex = arr.firstIndex(of: minEvenNumber) else { return [] }\n\
    \    return [minEvenNumber, minEvenNumberIndex]\n}\n\n\nfunc ==(left: [(Int, Int)],\
    \ right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n       \
    \ return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r\
    \ {\n            return false\n        }\n    }\n    return true\n}\n        \
    \    \nassert(pluck(arr: [4, 2, 3]) == [2, 1])\nassert(pluck(arr: [1, 2, 3]) ==\
    \ [2, 1])\nassert(pluck(arr: [] as [Int]) == [] as [Int])\nassert(pluck(arr: [5,\
    \ 0, 3, 0, 4, 2]) == [0, 1])\nassert(pluck(arr: [1, 2, 3, 0, 5, 3]) == [0, 3])\n\
    assert(pluck(arr: [5, 4, 8, 4, 8]) == [4, 1])\nassert(pluck(arr: [7, 6, 7, 1])\
    \ == [6, 1])\nassert(pluck(arr: [7, 9, 7, 1]) == [] as [Int])"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660013550
- exit_code: 0
  program: "\n/// \"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n/// your task is to pluck one of the nodes and return it.\n///\
    \ The plucked node should be the node with the smallest even value.\n/// If multiple\
    \ nodes with the same smallest even value are found return the node that has smallest\
    \ index.\n/// The plucked node should be returned in an array, [ smalest_value,\
    \ its index ],\n/// If there are no even values or the given array is empty, return\
    \ [].\n/// Example 1:\n/// >>> pluck(arr: [4, 2, 3])\n/// [2, 1]\n/// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n/// Example 2:\n\
    /// >>> pluck(arr: [1, 2, 3])\n/// [2, 1]\n/// Explanation: 2 has the smallest\
    \ even value, and 2 has the smallest index.\n/// Example 3:\n/// >>> pluck(arr:\
    \ [] as [Int])\n/// [] as [Int]\n/// Example 4:\n/// >>> pluck(arr: [5, 0, 3,\
    \ 0, 4, 2])\n/// [0, 1]\n/// Explanation: 0 is the smallest value, but  there\
    \ are two zeros,\n/// so we will choose the first zero, which has the smallest\
    \ index.\n/// Constraints:\n/// * 1 <= nodes.length <= 10000\n/// * 0 <= node.value\n\
    func pluck(arr: [Int]) -> [Int] {\n    return arr.enumerated().filter({ $0.element\
    \ % 2 == 0 }).sorted{ $0.element < $1.element }.first.map { [$0.element, $0.offset]\
    \ } ?? []\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n\
    \    if left.count != right.count {\n        return false\n    }\n    for (l,\
    \ r) in zip(left, right) {\n        if l != r {\n            return false\n  \
    \      }\n    }\n    return true\n}\n            \nassert(pluck(arr: [4, 2, 3])\
    \ == [2, 1])\nassert(pluck(arr: [1, 2, 3]) == [2, 1])\nassert(pluck(arr: [] as\
    \ [Int]) == [] as [Int])\nassert(pluck(arr: [5, 0, 3, 0, 4, 2]) == [0, 1])\nassert(pluck(arr:\
    \ [1, 2, 3, 0, 5, 3]) == [0, 3])\nassert(pluck(arr: [5, 4, 8, 4, 8]) == [4, 1])\n\
    assert(pluck(arr: [7, 6, 7, 1]) == [6, 1])\nassert(pluck(arr: [7, 9, 7, 1]) ==\
    \ [] as [Int])"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660013550
- exit_code: 0
  program: "\n/// \"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n/// your task is to pluck one of the nodes and return it.\n///\
    \ The plucked node should be the node with the smallest even value.\n/// If multiple\
    \ nodes with the same smallest even value are found return the node that has smallest\
    \ index.\n/// The plucked node should be returned in an array, [ smalest_value,\
    \ its index ],\n/// If there are no even values or the given array is empty, return\
    \ [].\n/// Example 1:\n/// >>> pluck(arr: [4, 2, 3])\n/// [2, 1]\n/// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n/// Example 2:\n\
    /// >>> pluck(arr: [1, 2, 3])\n/// [2, 1]\n/// Explanation: 2 has the smallest\
    \ even value, and 2 has the smallest index.\n/// Example 3:\n/// >>> pluck(arr:\
    \ [] as [Int])\n/// [] as [Int]\n/// Example 4:\n/// >>> pluck(arr: [5, 0, 3,\
    \ 0, 4, 2])\n/// [0, 1]\n/// Explanation: 0 is the smallest value, but  there\
    \ are two zeros,\n/// so we will choose the first zero, which has the smallest\
    \ index.\n/// Constraints:\n/// * 1 <= nodes.length <= 10000\n/// * 0 <= node.value\n\
    func pluck(arr: [Int]) -> [Int] {\n    let evens = arr.filter { $0 % 2 == 0 }\n\
    \    guard let minEven = evens.min() else { return [] }\n    return [minEven,\
    \ arr.firstIndex(of: minEven)!]\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int,\
    \ Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n\
    \    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n          \
    \  return false\n        }\n    }\n    return true\n}\n            \nassert(pluck(arr:\
    \ [4, 2, 3]) == [2, 1])\nassert(pluck(arr: [1, 2, 3]) == [2, 1])\nassert(pluck(arr:\
    \ [] as [Int]) == [] as [Int])\nassert(pluck(arr: [5, 0, 3, 0, 4, 2]) == [0, 1])\n\
    assert(pluck(arr: [1, 2, 3, 0, 5, 3]) == [0, 3])\nassert(pluck(arr: [5, 4, 8,\
    \ 4, 8]) == [4, 1])\nassert(pluck(arr: [7, 6, 7, 1]) == [6, 1])\nassert(pluck(arr:\
    \ [7, 9, 7, 1]) == [] as [Int])"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660013365
- exit_code: 0
  program: "\n/// \"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n/// your task is to pluck one of the nodes and return it.\n///\
    \ The plucked node should be the node with the smallest even value.\n/// If multiple\
    \ nodes with the same smallest even value are found return the node that has smallest\
    \ index.\n/// The plucked node should be returned in an array, [ smalest_value,\
    \ its index ],\n/// If there are no even values or the given array is empty, return\
    \ [].\n/// Example 1:\n/// >>> pluck(arr: [4, 2, 3])\n/// [2, 1]\n/// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n/// Example 2:\n\
    /// >>> pluck(arr: [1, 2, 3])\n/// [2, 1]\n/// Explanation: 2 has the smallest\
    \ even value, and 2 has the smallest index.\n/// Example 3:\n/// >>> pluck(arr:\
    \ [] as [Int])\n/// [] as [Int]\n/// Example 4:\n/// >>> pluck(arr: [5, 0, 3,\
    \ 0, 4, 2])\n/// [0, 1]\n/// Explanation: 0 is the smallest value, but  there\
    \ are two zeros,\n/// so we will choose the first zero, which has the smallest\
    \ index.\n/// Constraints:\n/// * 1 <= nodes.length <= 10000\n/// * 0 <= node.value\n\
    func pluck(arr: [Int]) -> [Int] {\n    guard arr.contains(where: { $0 % 2 == 0\
    \ }) else { return [] }\n    let evens = arr.enumerated().filter { $0.element\
    \ % 2 == 0 }\n    guard let smallest = evens.min(by: { $0.element < $1.element\
    \ }) else { return [] }\n    return [smallest.element, smallest.offset]\n}\n\n\
    \nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(pluck(arr: [4, 2, 3]) == [2, 1])\nassert(pluck(arr:\
    \ [1, 2, 3]) == [2, 1])\nassert(pluck(arr: [] as [Int]) == [] as [Int])\nassert(pluck(arr:\
    \ [5, 0, 3, 0, 4, 2]) == [0, 1])\nassert(pluck(arr: [1, 2, 3, 0, 5, 3]) == [0,\
    \ 3])\nassert(pluck(arr: [5, 4, 8, 4, 8]) == [4, 1])\nassert(pluck(arr: [7, 6,\
    \ 7, 1]) == [6, 1])\nassert(pluck(arr: [7, 9, 7, 1]) == [] as [Int])"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660013550
- exit_code: 0
  program: "\n/// \"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n/// your task is to pluck one of the nodes and return it.\n///\
    \ The plucked node should be the node with the smallest even value.\n/// If multiple\
    \ nodes with the same smallest even value are found return the node that has smallest\
    \ index.\n/// The plucked node should be returned in an array, [ smalest_value,\
    \ its index ],\n/// If there are no even values or the given array is empty, return\
    \ [].\n/// Example 1:\n/// >>> pluck(arr: [4, 2, 3])\n/// [2, 1]\n/// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n/// Example 2:\n\
    /// >>> pluck(arr: [1, 2, 3])\n/// [2, 1]\n/// Explanation: 2 has the smallest\
    \ even value, and 2 has the smallest index.\n/// Example 3:\n/// >>> pluck(arr:\
    \ [] as [Int])\n/// [] as [Int]\n/// Example 4:\n/// >>> pluck(arr: [5, 0, 3,\
    \ 0, 4, 2])\n/// [0, 1]\n/// Explanation: 0 is the smallest value, but  there\
    \ are two zeros,\n/// so we will choose the first zero, which has the smallest\
    \ index.\n/// Constraints:\n/// * 1 <= nodes.length <= 10000\n/// * 0 <= node.value\n\
    func pluck(arr: [Int]) -> [Int] {\n    let even = arr.filter { $0 % 2 == 0 }\n\
    \    if even.isEmpty { return [] }\n    return [even.min()!, arr.firstIndex(of:\
    \ even.min()!)!]\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool\
    \ {\n    if left.count != right.count {\n        return false\n    }\n    for\
    \ (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(pluck(arr: [4, 2,\
    \ 3]) == [2, 1])\nassert(pluck(arr: [1, 2, 3]) == [2, 1])\nassert(pluck(arr: []\
    \ as [Int]) == [] as [Int])\nassert(pluck(arr: [5, 0, 3, 0, 4, 2]) == [0, 1])\n\
    assert(pluck(arr: [1, 2, 3, 0, 5, 3]) == [0, 3])\nassert(pluck(arr: [5, 4, 8,\
    \ 4, 8]) == [4, 1])\nassert(pluck(arr: [7, 6, 7, 1]) == [6, 1])\nassert(pluck(arr:\
    \ [7, 9, 7, 1]) == [] as [Int])"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660013550
- exit_code: 0
  program: "\n/// \"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n/// your task is to pluck one of the nodes and return it.\n///\
    \ The plucked node should be the node with the smallest even value.\n/// If multiple\
    \ nodes with the same smallest even value are found return the node that has smallest\
    \ index.\n/// The plucked node should be returned in an array, [ smalest_value,\
    \ its index ],\n/// If there are no even values or the given array is empty, return\
    \ [].\n/// Example 1:\n/// >>> pluck(arr: [4, 2, 3])\n/// [2, 1]\n/// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n/// Example 2:\n\
    /// >>> pluck(arr: [1, 2, 3])\n/// [2, 1]\n/// Explanation: 2 has the smallest\
    \ even value, and 2 has the smallest index.\n/// Example 3:\n/// >>> pluck(arr:\
    \ [] as [Int])\n/// [] as [Int]\n/// Example 4:\n/// >>> pluck(arr: [5, 0, 3,\
    \ 0, 4, 2])\n/// [0, 1]\n/// Explanation: 0 is the smallest value, but  there\
    \ are two zeros,\n/// so we will choose the first zero, which has the smallest\
    \ index.\n/// Constraints:\n/// * 1 <= nodes.length <= 10000\n/// * 0 <= node.value\n\
    func pluck(arr: [Int]) -> [Int] {\n    var result = [Int]()\n    if arr.isEmpty\
    \ {\n        return result\n    }\n    var smallestValue = Int.max\n    var smallestIndex\
    \ = 0\n    for i in 0..<arr.count {\n        if arr[i] % 2 == 0 && arr[i] < smallestValue\
    \ {\n            smallestValue = arr[i]\n            smallestIndex = i\n     \
    \   }\n    }\n    if smallestValue == Int.max {\n        return result\n    }\n\
    \    result.append(smallestValue)\n    result.append(smallestIndex)\n    return\
    \ result\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n\
    \    if left.count != right.count {\n        return false\n    }\n    for (l,\
    \ r) in zip(left, right) {\n        if l != r {\n            return false\n  \
    \      }\n    }\n    return true\n}\n            \nassert(pluck(arr: [4, 2, 3])\
    \ == [2, 1])\nassert(pluck(arr: [1, 2, 3]) == [2, 1])\nassert(pluck(arr: [] as\
    \ [Int]) == [] as [Int])\nassert(pluck(arr: [5, 0, 3, 0, 4, 2]) == [0, 1])\nassert(pluck(arr:\
    \ [1, 2, 3, 0, 5, 3]) == [0, 3])\nassert(pluck(arr: [5, 4, 8, 4, 8]) == [4, 1])\n\
    assert(pluck(arr: [7, 6, 7, 1]) == [6, 1])\nassert(pluck(arr: [7, 9, 7, 1]) ==\
    \ [] as [Int])"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660013550
- exit_code: -4
  program: "\n/// \"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n/// your task is to pluck one of the nodes and return it.\n///\
    \ The plucked node should be the node with the smallest even value.\n/// If multiple\
    \ nodes with the same smallest even value are found return the node that has smallest\
    \ index.\n/// The plucked node should be returned in an array, [ smalest_value,\
    \ its index ],\n/// If there are no even values or the given array is empty, return\
    \ [].\n/// Example 1:\n/// >>> pluck(arr: [4, 2, 3])\n/// [2, 1]\n/// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n/// Example 2:\n\
    /// >>> pluck(arr: [1, 2, 3])\n/// [2, 1]\n/// Explanation: 2 has the smallest\
    \ even value, and 2 has the smallest index.\n/// Example 3:\n/// >>> pluck(arr:\
    \ [] as [Int])\n/// [] as [Int]\n/// Example 4:\n/// >>> pluck(arr: [5, 0, 3,\
    \ 0, 4, 2])\n/// [0, 1]\n/// Explanation: 0 is the smallest value, but  there\
    \ are two zeros,\n/// so we will choose the first zero, which has the smallest\
    \ index.\n/// Constraints:\n/// * 1 <= nodes.length <= 10000\n/// * 0 <= node.value\n\
    func pluck(arr: [Int]) -> [Int] {\n    return arr.indices.reduce((Int.max, 0))\
    \ { res, i in\n        if arr[i] == 0 {\n            return res\n        }\n \
    \       if arr[i] & 1 == 0 && arr[i] < res.0 {\n            return (arr[i], i)\n\
    \        }\n        return res\n    }.0 == Int.max ? [] : [arr[1], 1]\n}\n\n\n\
    func ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(pluck(arr: [4, 2, 3]) == [2, 1])\nassert(pluck(arr:\
    \ [1, 2, 3]) == [2, 1])\nassert(pluck(arr: [] as [Int]) == [] as [Int])\nassert(pluck(arr:\
    \ [5, 0, 3, 0, 4, 2]) == [0, 1])\nassert(pluck(arr: [1, 2, 3, 0, 5, 3]) == [0,\
    \ 3])\nassert(pluck(arr: [5, 4, 8, 4, 8]) == [4, 1])\nassert(pluck(arr: [7, 6,\
    \ 7, 1]) == [6, 1])\nassert(pluck(arr: [7, 9, 7, 1]) == [] as [Int])"
  status: Exception
  stderr: 'tmpr1n54zgi/tmpr1n54zgi.swift:56: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002ba614755c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002ba61444cb6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002ba61444c988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002ba61444b7b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpr1n54zgi                        0x00005641dd500ab2 <unavailable> + 6834

    5    libc.so.6                          0x00002ba614941460 __libc_start_main +
    245

    6    tmpr1n54zgi                        0x00005641dd5001f9 <unavailable> + 4601

    '
  stdout: ''
  timestamp: 1660013550
- exit_code: 0
  program: "\n/// \"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n/// your task is to pluck one of the nodes and return it.\n///\
    \ The plucked node should be the node with the smallest even value.\n/// If multiple\
    \ nodes with the same smallest even value are found return the node that has smallest\
    \ index.\n/// The plucked node should be returned in an array, [ smalest_value,\
    \ its index ],\n/// If there are no even values or the given array is empty, return\
    \ [].\n/// Example 1:\n/// >>> pluck(arr: [4, 2, 3])\n/// [2, 1]\n/// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n/// Example 2:\n\
    /// >>> pluck(arr: [1, 2, 3])\n/// [2, 1]\n/// Explanation: 2 has the smallest\
    \ even value, and 2 has the smallest index.\n/// Example 3:\n/// >>> pluck(arr:\
    \ [] as [Int])\n/// [] as [Int]\n/// Example 4:\n/// >>> pluck(arr: [5, 0, 3,\
    \ 0, 4, 2])\n/// [0, 1]\n/// Explanation: 0 is the smallest value, but  there\
    \ are two zeros,\n/// so we will choose the first zero, which has the smallest\
    \ index.\n/// Constraints:\n/// * 1 <= nodes.length <= 10000\n/// * 0 <= node.value\n\
    func pluck(arr: [Int]) -> [Int] {\n    guard arr.isEmpty == false else { return\
    \ [] }\n    guard arr.contains(where: { $0 % 2 == 0 }) else { return [] }\n  \
    \  let evenNumbers = arr.filter({ $0 % 2 == 0 })\n    let minNumber = evenNumbers.min()!\n\
    \    return [minNumber, arr.firstIndex(of: minNumber)!]\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(pluck(arr: [4, 2, 3]) == [2, 1])\nassert(pluck(arr: [1,\
    \ 2, 3]) == [2, 1])\nassert(pluck(arr: [] as [Int]) == [] as [Int])\nassert(pluck(arr:\
    \ [5, 0, 3, 0, 4, 2]) == [0, 1])\nassert(pluck(arr: [1, 2, 3, 0, 5, 3]) == [0,\
    \ 3])\nassert(pluck(arr: [5, 4, 8, 4, 8]) == [4, 1])\nassert(pluck(arr: [7, 6,\
    \ 7, 1]) == [6, 1])\nassert(pluck(arr: [7, 9, 7, 1]) == [] as [Int])"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660013550
- exit_code: 0
  program: "\n/// \"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n/// your task is to pluck one of the nodes and return it.\n///\
    \ The plucked node should be the node with the smallest even value.\n/// If multiple\
    \ nodes with the same smallest even value are found return the node that has smallest\
    \ index.\n/// The plucked node should be returned in an array, [ smalest_value,\
    \ its index ],\n/// If there are no even values or the given array is empty, return\
    \ [].\n/// Example 1:\n/// >>> pluck(arr: [4, 2, 3])\n/// [2, 1]\n/// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n/// Example 2:\n\
    /// >>> pluck(arr: [1, 2, 3])\n/// [2, 1]\n/// Explanation: 2 has the smallest\
    \ even value, and 2 has the smallest index.\n/// Example 3:\n/// >>> pluck(arr:\
    \ [] as [Int])\n/// [] as [Int]\n/// Example 4:\n/// >>> pluck(arr: [5, 0, 3,\
    \ 0, 4, 2])\n/// [0, 1]\n/// Explanation: 0 is the smallest value, but  there\
    \ are two zeros,\n/// so we will choose the first zero, which has the smallest\
    \ index.\n/// Constraints:\n/// * 1 <= nodes.length <= 10000\n/// * 0 <= node.value\n\
    func pluck(arr: [Int]) -> [Int] {\n    var smallestValue = Int.max\n    var smallestIndex\
    \ = -1\n    for (index, value) in arr.enumerated() {\n        if value == 0 {\n\
    \            smallestValue = 0\n            smallestIndex = index\n          \
    \  break\n        }\n        if value < smallestValue && value % 2 == 0 {\n  \
    \          smallestValue = value\n            smallestIndex = index\n        }\n\
    \    }\n    return smallestIndex >= 0 ? [smallestValue, smallestIndex] : []\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(pluck(arr: [4, 2, 3]) == [2, 1])\nassert(pluck(arr:\
    \ [1, 2, 3]) == [2, 1])\nassert(pluck(arr: [] as [Int]) == [] as [Int])\nassert(pluck(arr:\
    \ [5, 0, 3, 0, 4, 2]) == [0, 1])\nassert(pluck(arr: [1, 2, 3, 0, 5, 3]) == [0,\
    \ 3])\nassert(pluck(arr: [5, 4, 8, 4, 8]) == [4, 1])\nassert(pluck(arr: [7, 6,\
    \ 7, 1]) == [6, 1])\nassert(pluck(arr: [7, 9, 7, 1]) == [] as [Int])"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660013550
- exit_code: 0
  program: "\n/// \"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n/// your task is to pluck one of the nodes and return it.\n///\
    \ The plucked node should be the node with the smallest even value.\n/// If multiple\
    \ nodes with the same smallest even value are found return the node that has smallest\
    \ index.\n/// The plucked node should be returned in an array, [ smalest_value,\
    \ its index ],\n/// If there are no even values or the given array is empty, return\
    \ [].\n/// Example 1:\n/// >>> pluck(arr: [4, 2, 3])\n/// [2, 1]\n/// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n/// Example 2:\n\
    /// >>> pluck(arr: [1, 2, 3])\n/// [2, 1]\n/// Explanation: 2 has the smallest\
    \ even value, and 2 has the smallest index.\n/// Example 3:\n/// >>> pluck(arr:\
    \ [] as [Int])\n/// [] as [Int]\n/// Example 4:\n/// >>> pluck(arr: [5, 0, 3,\
    \ 0, 4, 2])\n/// [0, 1]\n/// Explanation: 0 is the smallest value, but  there\
    \ are two zeros,\n/// so we will choose the first zero, which has the smallest\
    \ index.\n/// Constraints:\n/// * 1 <= nodes.length <= 10000\n/// * 0 <= node.value\n\
    func pluck(arr: [Int]) -> [Int] {\n    var evens = [Int]()\n    var index = 0\n\
    \    for i in arr {\n        if i % 2 == 0 {\n            evens.append(i)\n  \
    \      }\n    }\n    if evens.count > 0 {\n        evens.sort()\n        for i\
    \ in arr {\n            if i == evens[0] {\n                return [i, index]\n\
    \            }\n            index += 1\n        }\n    }\n    return []\n}\n\n\
    \nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(pluck(arr: [4, 2, 3]) == [2, 1])\nassert(pluck(arr:\
    \ [1, 2, 3]) == [2, 1])\nassert(pluck(arr: [] as [Int]) == [] as [Int])\nassert(pluck(arr:\
    \ [5, 0, 3, 0, 4, 2]) == [0, 1])\nassert(pluck(arr: [1, 2, 3, 0, 5, 3]) == [0,\
    \ 3])\nassert(pluck(arr: [5, 4, 8, 4, 8]) == [4, 1])\nassert(pluck(arr: [7, 6,\
    \ 7, 1]) == [6, 1])\nassert(pluck(arr: [7, 9, 7, 1]) == [] as [Int])"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660013550
- exit_code: 0
  program: "\n/// \"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n/// your task is to pluck one of the nodes and return it.\n///\
    \ The plucked node should be the node with the smallest even value.\n/// If multiple\
    \ nodes with the same smallest even value are found return the node that has smallest\
    \ index.\n/// The plucked node should be returned in an array, [ smalest_value,\
    \ its index ],\n/// If there are no even values or the given array is empty, return\
    \ [].\n/// Example 1:\n/// >>> pluck(arr: [4, 2, 3])\n/// [2, 1]\n/// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n/// Example 2:\n\
    /// >>> pluck(arr: [1, 2, 3])\n/// [2, 1]\n/// Explanation: 2 has the smallest\
    \ even value, and 2 has the smallest index.\n/// Example 3:\n/// >>> pluck(arr:\
    \ [] as [Int])\n/// [] as [Int]\n/// Example 4:\n/// >>> pluck(arr: [5, 0, 3,\
    \ 0, 4, 2])\n/// [0, 1]\n/// Explanation: 0 is the smallest value, but  there\
    \ are two zeros,\n/// so we will choose the first zero, which has the smallest\
    \ index.\n/// Constraints:\n/// * 1 <= nodes.length <= 10000\n/// * 0 <= node.value\n\
    func pluck(arr: [Int]) -> [Int] {\n    let sortedArr = arr.sorted()\n    let evens\
    \ = sortedArr.filter { $0 % 2 == 0 }\n    guard let smallesEven = evens.first\
    \ else { return [] }\n    return [smallesEven, arr.firstIndex(of: smallesEven)!]\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(pluck(arr: [4, 2, 3]) == [2, 1])\nassert(pluck(arr:\
    \ [1, 2, 3]) == [2, 1])\nassert(pluck(arr: [] as [Int]) == [] as [Int])\nassert(pluck(arr:\
    \ [5, 0, 3, 0, 4, 2]) == [0, 1])\nassert(pluck(arr: [1, 2, 3, 0, 5, 3]) == [0,\
    \ 3])\nassert(pluck(arr: [5, 4, 8, 4, 8]) == [4, 1])\nassert(pluck(arr: [7, 6,\
    \ 7, 1]) == [6, 1])\nassert(pluck(arr: [7, 9, 7, 1]) == [] as [Int])"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660013550
- exit_code: 0
  program: "\n/// \"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n/// your task is to pluck one of the nodes and return it.\n///\
    \ The plucked node should be the node with the smallest even value.\n/// If multiple\
    \ nodes with the same smallest even value are found return the node that has smallest\
    \ index.\n/// The plucked node should be returned in an array, [ smalest_value,\
    \ its index ],\n/// If there are no even values or the given array is empty, return\
    \ [].\n/// Example 1:\n/// >>> pluck(arr: [4, 2, 3])\n/// [2, 1]\n/// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n/// Example 2:\n\
    /// >>> pluck(arr: [1, 2, 3])\n/// [2, 1]\n/// Explanation: 2 has the smallest\
    \ even value, and 2 has the smallest index.\n/// Example 3:\n/// >>> pluck(arr:\
    \ [] as [Int])\n/// [] as [Int]\n/// Example 4:\n/// >>> pluck(arr: [5, 0, 3,\
    \ 0, 4, 2])\n/// [0, 1]\n/// Explanation: 0 is the smallest value, but  there\
    \ are two zeros,\n/// so we will choose the first zero, which has the smallest\
    \ index.\n/// Constraints:\n/// * 1 <= nodes.length <= 10000\n/// * 0 <= node.value\n\
    func pluck(arr: [Int]) -> [Int] {\n    let evenValues = arr.filter { $0 % 2 ==\
    \ 0 }\n    guard let min = evenValues.min() else { return [] }\n    let index\
    \ = arr.index(of: min) ?? 0\n    return [min, index]\n}\n\n\nfunc ==(left: [(Int,\
    \ Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n\
    \        return false\n    }\n    for (l, r) in zip(left, right) {\n        if\
    \ l != r {\n            return false\n        }\n    }\n    return true\n}\n \
    \           \nassert(pluck(arr: [4, 2, 3]) == [2, 1])\nassert(pluck(arr: [1, 2,\
    \ 3]) == [2, 1])\nassert(pluck(arr: [] as [Int]) == [] as [Int])\nassert(pluck(arr:\
    \ [5, 0, 3, 0, 4, 2]) == [0, 1])\nassert(pluck(arr: [1, 2, 3, 0, 5, 3]) == [0,\
    \ 3])\nassert(pluck(arr: [5, 4, 8, 4, 8]) == [4, 1])\nassert(pluck(arr: [7, 6,\
    \ 7, 1]) == [6, 1])\nassert(pluck(arr: [7, 9, 7, 1]) == [] as [Int])"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660013550
- exit_code: 0
  program: "\n/// \"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n/// your task is to pluck one of the nodes and return it.\n///\
    \ The plucked node should be the node with the smallest even value.\n/// If multiple\
    \ nodes with the same smallest even value are found return the node that has smallest\
    \ index.\n/// The plucked node should be returned in an array, [ smalest_value,\
    \ its index ],\n/// If there are no even values or the given array is empty, return\
    \ [].\n/// Example 1:\n/// >>> pluck(arr: [4, 2, 3])\n/// [2, 1]\n/// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n/// Example 2:\n\
    /// >>> pluck(arr: [1, 2, 3])\n/// [2, 1]\n/// Explanation: 2 has the smallest\
    \ even value, and 2 has the smallest index.\n/// Example 3:\n/// >>> pluck(arr:\
    \ [] as [Int])\n/// [] as [Int]\n/// Example 4:\n/// >>> pluck(arr: [5, 0, 3,\
    \ 0, 4, 2])\n/// [0, 1]\n/// Explanation: 0 is the smallest value, but  there\
    \ are two zeros,\n/// so we will choose the first zero, which has the smallest\
    \ index.\n/// Constraints:\n/// * 1 <= nodes.length <= 10000\n/// * 0 <= node.value\n\
    func pluck(arr: [Int]) -> [Int] {\n    var minEven = Int.max\n    var minEvenIndex\
    \ = Int.max\n    for (index, value) in arr.enumerated() {\n        if value %\
    \ 2 == 0 {\n            if value < minEven {\n                minEven = value\n\
    \                minEvenIndex = index\n            }\n        }\n    }\n    return\
    \ minEven == Int.max ? [] : [minEven, minEvenIndex]\n}\n\n\nfunc ==(left: [(Int,\
    \ Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n\
    \        return false\n    }\n    for (l, r) in zip(left, right) {\n        if\
    \ l != r {\n            return false\n        }\n    }\n    return true\n}\n \
    \           \nassert(pluck(arr: [4, 2, 3]) == [2, 1])\nassert(pluck(arr: [1, 2,\
    \ 3]) == [2, 1])\nassert(pluck(arr: [] as [Int]) == [] as [Int])\nassert(pluck(arr:\
    \ [5, 0, 3, 0, 4, 2]) == [0, 1])\nassert(pluck(arr: [1, 2, 3, 0, 5, 3]) == [0,\
    \ 3])\nassert(pluck(arr: [5, 4, 8, 4, 8]) == [4, 1])\nassert(pluck(arr: [7, 6,\
    \ 7, 1]) == [6, 1])\nassert(pluck(arr: [7, 9, 7, 1]) == [] as [Int])"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660013550
- exit_code: 0
  program: "\n/// \"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n/// your task is to pluck one of the nodes and return it.\n///\
    \ The plucked node should be the node with the smallest even value.\n/// If multiple\
    \ nodes with the same smallest even value are found return the node that has smallest\
    \ index.\n/// The plucked node should be returned in an array, [ smalest_value,\
    \ its index ],\n/// If there are no even values or the given array is empty, return\
    \ [].\n/// Example 1:\n/// >>> pluck(arr: [4, 2, 3])\n/// [2, 1]\n/// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n/// Example 2:\n\
    /// >>> pluck(arr: [1, 2, 3])\n/// [2, 1]\n/// Explanation: 2 has the smallest\
    \ even value, and 2 has the smallest index.\n/// Example 3:\n/// >>> pluck(arr:\
    \ [] as [Int])\n/// [] as [Int]\n/// Example 4:\n/// >>> pluck(arr: [5, 0, 3,\
    \ 0, 4, 2])\n/// [0, 1]\n/// Explanation: 0 is the smallest value, but  there\
    \ are two zeros,\n/// so we will choose the first zero, which has the smallest\
    \ index.\n/// Constraints:\n/// * 1 <= nodes.length <= 10000\n/// * 0 <= node.value\n\
    func pluck(arr: [Int]) -> [Int] {\n    let evenValues = arr.filter { $0 % 2 ==\
    \ 0 }\n    guard let minEvenValue = evenValues.min() else { return [] }\n    return\
    \ [minEvenValue, arr.firstIndex(of: minEvenValue)!]\n}\n\n\nfunc ==(left: [(Int,\
    \ Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n\
    \        return false\n    }\n    for (l, r) in zip(left, right) {\n        if\
    \ l != r {\n            return false\n        }\n    }\n    return true\n}\n \
    \           \nassert(pluck(arr: [4, 2, 3]) == [2, 1])\nassert(pluck(arr: [1, 2,\
    \ 3]) == [2, 1])\nassert(pluck(arr: [] as [Int]) == [] as [Int])\nassert(pluck(arr:\
    \ [5, 0, 3, 0, 4, 2]) == [0, 1])\nassert(pluck(arr: [1, 2, 3, 0, 5, 3]) == [0,\
    \ 3])\nassert(pluck(arr: [5, 4, 8, 4, 8]) == [4, 1])\nassert(pluck(arr: [7, 6,\
    \ 7, 1]) == [6, 1])\nassert(pluck(arr: [7, 9, 7, 1]) == [] as [Int])"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660013550
- exit_code: 0
  program: "\n/// \"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n/// your task is to pluck one of the nodes and return it.\n///\
    \ The plucked node should be the node with the smallest even value.\n/// If multiple\
    \ nodes with the same smallest even value are found return the node that has smallest\
    \ index.\n/// The plucked node should be returned in an array, [ smalest_value,\
    \ its index ],\n/// If there are no even values or the given array is empty, return\
    \ [].\n/// Example 1:\n/// >>> pluck(arr: [4, 2, 3])\n/// [2, 1]\n/// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n/// Example 2:\n\
    /// >>> pluck(arr: [1, 2, 3])\n/// [2, 1]\n/// Explanation: 2 has the smallest\
    \ even value, and 2 has the smallest index.\n/// Example 3:\n/// >>> pluck(arr:\
    \ [] as [Int])\n/// [] as [Int]\n/// Example 4:\n/// >>> pluck(arr: [5, 0, 3,\
    \ 0, 4, 2])\n/// [0, 1]\n/// Explanation: 0 is the smallest value, but  there\
    \ are two zeros,\n/// so we will choose the first zero, which has the smallest\
    \ index.\n/// Constraints:\n/// * 1 <= nodes.length <= 10000\n/// * 0 <= node.value\n\
    func pluck(arr: [Int]) -> [Int] {\n    var smallestEvenValue: Int?\n    var smallestEvenValueIndex:\
    \ Int?\n    for (index, value) in arr.enumerated() {\n        if value % 2 ==\
    \ 0 {\n            if smallestEvenValue == nil {\n                smallestEvenValue\
    \ = value\n                smallestEvenValueIndex = index\n            } else\
    \ if value < smallestEvenValue! {\n                smallestEvenValue = value\n\
    \                smallestEvenValueIndex = index\n            }\n        }\n  \
    \  }\n    if smallestEvenValue != nil {\n        return [smallestEvenValue!, smallestEvenValueIndex!]\n\
    \    } else {\n        return []\n    }\n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(pluck(arr: [4, 2, 3]) == [2, 1])\nassert(pluck(arr: [1, 2, 3]) == [2, 1])\n\
    assert(pluck(arr: [] as [Int]) == [] as [Int])\nassert(pluck(arr: [5, 0, 3, 0,\
    \ 4, 2]) == [0, 1])\nassert(pluck(arr: [1, 2, 3, 0, 5, 3]) == [0, 3])\nassert(pluck(arr:\
    \ [5, 4, 8, 4, 8]) == [4, 1])\nassert(pluck(arr: [7, 6, 7, 1]) == [6, 1])\nassert(pluck(arr:\
    \ [7, 9, 7, 1]) == [] as [Int])"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660013550
- exit_code: -4
  program: "\n/// \"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n/// your task is to pluck one of the nodes and return it.\n///\
    \ The plucked node should be the node with the smallest even value.\n/// If multiple\
    \ nodes with the same smallest even value are found return the node that has smallest\
    \ index.\n/// The plucked node should be returned in an array, [ smalest_value,\
    \ its index ],\n/// If there are no even values or the given array is empty, return\
    \ [].\n/// Example 1:\n/// >>> pluck(arr: [4, 2, 3])\n/// [2, 1]\n/// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n/// Example 2:\n\
    /// >>> pluck(arr: [1, 2, 3])\n/// [2, 1]\n/// Explanation: 2 has the smallest\
    \ even value, and 2 has the smallest index.\n/// Example 3:\n/// >>> pluck(arr:\
    \ [] as [Int])\n/// [] as [Int]\n/// Example 4:\n/// >>> pluck(arr: [5, 0, 3,\
    \ 0, 4, 2])\n/// [0, 1]\n/// Explanation: 0 is the smallest value, but  there\
    \ are two zeros,\n/// so we will choose the first zero, which has the smallest\
    \ index.\n/// Constraints:\n/// * 1 <= nodes.length <= 10000\n/// * 0 <= node.value\n\
    func pluck(arr: [Int]) -> [Int] {\n    guard arr.count > 0 else { return [] }\n\
    \    var min = arr[0]\n    var index = 0\n    var isEven = false\n    for i in\
    \ 1..<arr.count {\n        if arr[i] % 2 == 0 {\n            isEven = true\n \
    \           if arr[i] < min {\n                min = arr[i]\n                index\
    \ = i\n            }\n        }\n    }\n    if isEven {\n        return [min,\
    \ index]\n    } else {\n        return []\n    }\n}\n\n\nfunc ==(left: [(Int,\
    \ Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n\
    \        return false\n    }\n    for (l, r) in zip(left, right) {\n        if\
    \ l != r {\n            return false\n        }\n    }\n    return true\n}\n \
    \           \nassert(pluck(arr: [4, 2, 3]) == [2, 1])\nassert(pluck(arr: [1, 2,\
    \ 3]) == [2, 1])\nassert(pluck(arr: [] as [Int]) == [] as [Int])\nassert(pluck(arr:\
    \ [5, 0, 3, 0, 4, 2]) == [0, 1])\nassert(pluck(arr: [1, 2, 3, 0, 5, 3]) == [0,\
    \ 3])\nassert(pluck(arr: [5, 4, 8, 4, 8]) == [4, 1])\nassert(pluck(arr: [7, 6,\
    \ 7, 1]) == [6, 1])\nassert(pluck(arr: [7, 9, 7, 1]) == [] as [Int])"
  status: Exception
  stderr: 'tmpa3twwa7z/tmpa3twwa7z.swift:62: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002aee1972ec80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002aee19425b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002aee19425988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002aee194247b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpa3twwa7z                        0x0000557269c7070b <unavailable> + 5899

    5    libc.so.6                          0x00002aee1991a460 __libc_start_main +
    245

    6    tmpa3twwa7z                        0x0000557269c701f9 <unavailable> + 4601

    '
  stdout: ''
  timestamp: 1660013550
- exit_code: -4
  program: "\n/// \"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n/// your task is to pluck one of the nodes and return it.\n///\
    \ The plucked node should be the node with the smallest even value.\n/// If multiple\
    \ nodes with the same smallest even value are found return the node that has smallest\
    \ index.\n/// The plucked node should be returned in an array, [ smalest_value,\
    \ its index ],\n/// If there are no even values or the given array is empty, return\
    \ [].\n/// Example 1:\n/// >>> pluck(arr: [4, 2, 3])\n/// [2, 1]\n/// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n/// Example 2:\n\
    /// >>> pluck(arr: [1, 2, 3])\n/// [2, 1]\n/// Explanation: 2 has the smallest\
    \ even value, and 2 has the smallest index.\n/// Example 3:\n/// >>> pluck(arr:\
    \ [] as [Int])\n/// [] as [Int]\n/// Example 4:\n/// >>> pluck(arr: [5, 0, 3,\
    \ 0, 4, 2])\n/// [0, 1]\n/// Explanation: 0 is the smallest value, but  there\
    \ are two zeros,\n/// so we will choose the first zero, which has the smallest\
    \ index.\n/// Constraints:\n/// * 1 <= nodes.length <= 10000\n/// * 0 <= node.value\n\
    func pluck(arr: [Int]) -> [Int] {\n    return [Int]()\n}\n\n\nfunc ==(left: [(Int,\
    \ Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n\
    \        return false\n    }\n    for (l, r) in zip(left, right) {\n        if\
    \ l != r {\n            return false\n        }\n    }\n    return true\n}\n \
    \           \nassert(pluck(arr: [4, 2, 3]) == [2, 1])\nassert(pluck(arr: [1, 2,\
    \ 3]) == [2, 1])\nassert(pluck(arr: [] as [Int]) == [] as [Int])\nassert(pluck(arr:\
    \ [5, 0, 3, 0, 4, 2]) == [0, 1])\nassert(pluck(arr: [1, 2, 3, 0, 5, 3]) == [0,\
    \ 3])\nassert(pluck(arr: [5, 4, 8, 4, 8]) == [4, 1])\nassert(pluck(arr: [7, 6,\
    \ 7, 1]) == [6, 1])\nassert(pluck(arr: [7, 9, 7, 1]) == [] as [Int])"
  status: Exception
  stderr: 'tmp749et4x5/tmp749et4x5.swift:44: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002ad26b632c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002ad26b329b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002ad26b329988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002ad26b3287b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmp749et4x5                        0x000055b8e0e3d41c <unavailable> + 5148

    5    libc.so.6                          0x00002ad26b81e460 __libc_start_main +
    245

    6    tmp749et4x5                        0x000055b8e0e3d029 <unavailable> + 4137

    '
  stdout: ''
  timestamp: 1660013548
- exit_code: -4
  program: "\n/// \"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n/// your task is to pluck one of the nodes and return it.\n///\
    \ The plucked node should be the node with the smallest even value.\n/// If multiple\
    \ nodes with the same smallest even value are found return the node that has smallest\
    \ index.\n/// The plucked node should be returned in an array, [ smalest_value,\
    \ its index ],\n/// If there are no even values or the given array is empty, return\
    \ [].\n/// Example 1:\n/// >>> pluck(arr: [4, 2, 3])\n/// [2, 1]\n/// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n/// Example 2:\n\
    /// >>> pluck(arr: [1, 2, 3])\n/// [2, 1]\n/// Explanation: 2 has the smallest\
    \ even value, and 2 has the smallest index.\n/// Example 3:\n/// >>> pluck(arr:\
    \ [] as [Int])\n/// [] as [Int]\n/// Example 4:\n/// >>> pluck(arr: [5, 0, 3,\
    \ 0, 4, 2])\n/// [0, 1]\n/// Explanation: 0 is the smallest value, but  there\
    \ are two zeros,\n/// so we will choose the first zero, which has the smallest\
    \ index.\n/// Constraints:\n/// * 1 <= nodes.length <= 10000\n/// * 0 <= node.value\n\
    func pluck(arr: [Int]) -> [Int] {\n    var result = [Int]()\n    var smallestEven\
    \ = Int.max\n    var smallestEvenIndex = Int.max\n    var hasOdd = false\n   \
    \ for (index, number) in arr.enumerated() {\n        if number % 2 == 0 {\n  \
    \          if number < smallestEven {\n                smallestEven = number\n\
    \                smallestEvenIndex = index\n            }\n        } else {\n\
    \            hasOdd = true\n        }\n    }\n    if !hasOdd {\n        result.append(contentsOf:\
    \ [smallestEven, smallestEvenIndex])\n    }\n    return result\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(pluck(arr: [4, 2, 3]) == [2, 1])\nassert(pluck(arr: [1,\
    \ 2, 3]) == [2, 1])\nassert(pluck(arr: [] as [Int]) == [] as [Int])\nassert(pluck(arr:\
    \ [5, 0, 3, 0, 4, 2]) == [0, 1])\nassert(pluck(arr: [1, 2, 3, 0, 5, 3]) == [0,\
    \ 3])\nassert(pluck(arr: [5, 4, 8, 4, 8]) == [4, 1])\nassert(pluck(arr: [7, 6,\
    \ 7, 1]) == [6, 1])\nassert(pluck(arr: [7, 9, 7, 1]) == [] as [Int])"
  status: Exception
  stderr: 'tmpc3n9g9eb/tmpc3n9g9eb.swift:61: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b05fab22c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b05fa819b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b05fa819988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b05fa8187b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpc3n9g9eb                        0x00005617c0b3d73c <unavailable> + 5948

    5    libc.so.6                          0x00002b05fad0e460 __libc_start_main +
    245

    6    tmpc3n9g9eb                        0x00005617c0b3d349 <unavailable> + 4937

    '
  stdout: ''
  timestamp: 1660013550
- exit_code: 0
  program: "\n/// \"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n/// your task is to pluck one of the nodes and return it.\n///\
    \ The plucked node should be the node with the smallest even value.\n/// If multiple\
    \ nodes with the same smallest even value are found return the node that has smallest\
    \ index.\n/// The plucked node should be returned in an array, [ smalest_value,\
    \ its index ],\n/// If there are no even values or the given array is empty, return\
    \ [].\n/// Example 1:\n/// >>> pluck(arr: [4, 2, 3])\n/// [2, 1]\n/// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n/// Example 2:\n\
    /// >>> pluck(arr: [1, 2, 3])\n/// [2, 1]\n/// Explanation: 2 has the smallest\
    \ even value, and 2 has the smallest index.\n/// Example 3:\n/// >>> pluck(arr:\
    \ [] as [Int])\n/// [] as [Int]\n/// Example 4:\n/// >>> pluck(arr: [5, 0, 3,\
    \ 0, 4, 2])\n/// [0, 1]\n/// Explanation: 0 is the smallest value, but  there\
    \ are two zeros,\n/// so we will choose the first zero, which has the smallest\
    \ index.\n/// Constraints:\n/// * 1 <= nodes.length <= 10000\n/// * 0 <= node.value\n\
    func pluck(arr: [Int]) -> [Int] {\n    var min = 0\n    var minIndex = 0\n   \
    \ var isFound = false\n    for (index, value) in arr.enumerated() {\n        if\
    \ value % 2 == 0 {\n            if !isFound {\n                min = value\n \
    \               minIndex = index\n                isFound = true\n           \
    \ } else {\n                if value < min {\n                    min = value\n\
    \                    minIndex = index\n                }\n            }\n    \
    \    }\n    }\n    if isFound {\n        return [min, minIndex]\n    } else {\n\
    \        return []\n    }\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(pluck(arr:\
    \ [4, 2, 3]) == [2, 1])\nassert(pluck(arr: [1, 2, 3]) == [2, 1])\nassert(pluck(arr:\
    \ [] as [Int]) == [] as [Int])\nassert(pluck(arr: [5, 0, 3, 0, 4, 2]) == [0, 1])\n\
    assert(pluck(arr: [1, 2, 3, 0, 5, 3]) == [0, 3])\nassert(pluck(arr: [5, 4, 8,\
    \ 4, 8]) == [4, 1])\nassert(pluck(arr: [7, 6, 7, 1]) == [6, 1])\nassert(pluck(arr:\
    \ [7, 9, 7, 1]) == [] as [Int])"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660013550
- exit_code: -4
  program: "\n/// \"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n/// your task is to pluck one of the nodes and return it.\n///\
    \ The plucked node should be the node with the smallest even value.\n/// If multiple\
    \ nodes with the same smallest even value are found return the node that has smallest\
    \ index.\n/// The plucked node should be returned in an array, [ smalest_value,\
    \ its index ],\n/// If there are no even values or the given array is empty, return\
    \ [].\n/// Example 1:\n/// >>> pluck(arr: [4, 2, 3])\n/// [2, 1]\n/// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n/// Example 2:\n\
    /// >>> pluck(arr: [1, 2, 3])\n/// [2, 1]\n/// Explanation: 2 has the smallest\
    \ even value, and 2 has the smallest index.\n/// Example 3:\n/// >>> pluck(arr:\
    \ [] as [Int])\n/// [] as [Int]\n/// Example 4:\n/// >>> pluck(arr: [5, 0, 3,\
    \ 0, 4, 2])\n/// [0, 1]\n/// Explanation: 0 is the smallest value, but  there\
    \ are two zeros,\n/// so we will choose the first zero, which has the smallest\
    \ index.\n/// Constraints:\n/// * 1 <= nodes.length <= 10000\n/// * 0 <= node.value\n\
    func pluck(arr: [Int]) -> [Int] {\n    var arr = arr\n    arr.sort(by: { $0 <\
    \ $1 })\n    for (idx, value) in arr.enumerated() {\n        if value % 2 == 0\
    \ {\n            return [value, idx]\n        }\n    }\n    return []\n}\n\n\n\
    func ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(pluck(arr: [4, 2, 3]) == [2, 1])\nassert(pluck(arr:\
    \ [1, 2, 3]) == [2, 1])\nassert(pluck(arr: [] as [Int]) == [] as [Int])\nassert(pluck(arr:\
    \ [5, 0, 3, 0, 4, 2]) == [0, 1])\nassert(pluck(arr: [1, 2, 3, 0, 5, 3]) == [0,\
    \ 3])\nassert(pluck(arr: [5, 4, 8, 4, 8]) == [4, 1])\nassert(pluck(arr: [7, 6,\
    \ 7, 1]) == [6, 1])\nassert(pluck(arr: [7, 9, 7, 1]) == [] as [Int])"
  status: Exception
  stderr: 'tmpmisksst4/tmpmisksst4.swift:51: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b47ef05bc80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b47eed52b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b47eed52988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b47eed517b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpmisksst4                        0x000055a1ab4e66ec <unavailable> + 5868

    5    libc.so.6                          0x00002b47ef247460 __libc_start_main +
    245

    6    tmpmisksst4                        0x000055a1ab4e62f9 <unavailable> + 4857

    '
  stdout: ''
  timestamp: 1660013550
- exit_code: 0
  program: "\n/// \"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n/// your task is to pluck one of the nodes and return it.\n///\
    \ The plucked node should be the node with the smallest even value.\n/// If multiple\
    \ nodes with the same smallest even value are found return the node that has smallest\
    \ index.\n/// The plucked node should be returned in an array, [ smalest_value,\
    \ its index ],\n/// If there are no even values or the given array is empty, return\
    \ [].\n/// Example 1:\n/// >>> pluck(arr: [4, 2, 3])\n/// [2, 1]\n/// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n/// Example 2:\n\
    /// >>> pluck(arr: [1, 2, 3])\n/// [2, 1]\n/// Explanation: 2 has the smallest\
    \ even value, and 2 has the smallest index.\n/// Example 3:\n/// >>> pluck(arr:\
    \ [] as [Int])\n/// [] as [Int]\n/// Example 4:\n/// >>> pluck(arr: [5, 0, 3,\
    \ 0, 4, 2])\n/// [0, 1]\n/// Explanation: 0 is the smallest value, but  there\
    \ are two zeros,\n/// so we will choose the first zero, which has the smallest\
    \ index.\n/// Constraints:\n/// * 1 <= nodes.length <= 10000\n/// * 0 <= node.value\n\
    func pluck(arr: [Int]) -> [Int] {\n    var smallest: Int?\n    var smallestIndex:\
    \ Int?\n    for (index, number) in arr.enumerated() {\n        if number % 2 ==\
    \ 0 {\n            if smallest == nil {\n                smallest = number\n \
    \               smallestIndex = index\n            } else if number < smallest!\
    \ {\n                smallest = number\n                smallestIndex = index\n\
    \            }\n        }\n    }\n    if smallest == nil {\n        return []\n\
    \    }\n    return [smallest!, smallestIndex!]\n}\n\n\nfunc ==(left: [(Int, Int)],\
    \ right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n       \
    \ return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r\
    \ {\n            return false\n        }\n    }\n    return true\n}\n        \
    \    \nassert(pluck(arr: [4, 2, 3]) == [2, 1])\nassert(pluck(arr: [1, 2, 3]) ==\
    \ [2, 1])\nassert(pluck(arr: [] as [Int]) == [] as [Int])\nassert(pluck(arr: [5,\
    \ 0, 3, 0, 4, 2]) == [0, 1])\nassert(pluck(arr: [1, 2, 3, 0, 5, 3]) == [0, 3])\n\
    assert(pluck(arr: [5, 4, 8, 4, 8]) == [4, 1])\nassert(pluck(arr: [7, 6, 7, 1])\
    \ == [6, 1])\nassert(pluck(arr: [7, 9, 7, 1]) == [] as [Int])"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660013550
- exit_code: 0
  program: "\n/// \"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n/// your task is to pluck one of the nodes and return it.\n///\
    \ The plucked node should be the node with the smallest even value.\n/// If multiple\
    \ nodes with the same smallest even value are found return the node that has smallest\
    \ index.\n/// The plucked node should be returned in an array, [ smalest_value,\
    \ its index ],\n/// If there are no even values or the given array is empty, return\
    \ [].\n/// Example 1:\n/// >>> pluck(arr: [4, 2, 3])\n/// [2, 1]\n/// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n/// Example 2:\n\
    /// >>> pluck(arr: [1, 2, 3])\n/// [2, 1]\n/// Explanation: 2 has the smallest\
    \ even value, and 2 has the smallest index.\n/// Example 3:\n/// >>> pluck(arr:\
    \ [] as [Int])\n/// [] as [Int]\n/// Example 4:\n/// >>> pluck(arr: [5, 0, 3,\
    \ 0, 4, 2])\n/// [0, 1]\n/// Explanation: 0 is the smallest value, but  there\
    \ are two zeros,\n/// so we will choose the first zero, which has the smallest\
    \ index.\n/// Constraints:\n/// * 1 <= nodes.length <= 10000\n/// * 0 <= node.value\n\
    func pluck(arr: [Int]) -> [Int] {\n    let evens = arr.filter { $0 % 2 == 0 }\n\
    \    let smallest = evens.min() ?? 0\n    guard let index = arr.firstIndex(of:\
    \ smallest) else { return [] }\n    return [smallest, index]\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(pluck(arr: [4, 2, 3]) == [2, 1])\nassert(pluck(arr: [1,\
    \ 2, 3]) == [2, 1])\nassert(pluck(arr: [] as [Int]) == [] as [Int])\nassert(pluck(arr:\
    \ [5, 0, 3, 0, 4, 2]) == [0, 1])\nassert(pluck(arr: [1, 2, 3, 0, 5, 3]) == [0,\
    \ 3])\nassert(pluck(arr: [5, 4, 8, 4, 8]) == [4, 1])\nassert(pluck(arr: [7, 6,\
    \ 7, 1]) == [6, 1])\nassert(pluck(arr: [7, 9, 7, 1]) == [] as [Int])"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660013550
- exit_code: 0
  program: "\n/// \"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n/// your task is to pluck one of the nodes and return it.\n///\
    \ The plucked node should be the node with the smallest even value.\n/// If multiple\
    \ nodes with the same smallest even value are found return the node that has smallest\
    \ index.\n/// The plucked node should be returned in an array, [ smalest_value,\
    \ its index ],\n/// If there are no even values or the given array is empty, return\
    \ [].\n/// Example 1:\n/// >>> pluck(arr: [4, 2, 3])\n/// [2, 1]\n/// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n/// Example 2:\n\
    /// >>> pluck(arr: [1, 2, 3])\n/// [2, 1]\n/// Explanation: 2 has the smallest\
    \ even value, and 2 has the smallest index.\n/// Example 3:\n/// >>> pluck(arr:\
    \ [] as [Int])\n/// [] as [Int]\n/// Example 4:\n/// >>> pluck(arr: [5, 0, 3,\
    \ 0, 4, 2])\n/// [0, 1]\n/// Explanation: 0 is the smallest value, but  there\
    \ are two zeros,\n/// so we will choose the first zero, which has the smallest\
    \ index.\n/// Constraints:\n/// * 1 <= nodes.length <= 10000\n/// * 0 <= node.value\n\
    func pluck(arr: [Int]) -> [Int] {\n    guard !arr.isEmpty else { return [] }\n\
    \    var indices = [Int]()\n    var minEven: Int?\n    for (i, v) in arr.enumerated()\
    \ {\n        if v % 2 == 0 {\n            if let me = minEven {\n            \
    \    if v < me {\n                    minEven = v\n                    indices\
    \ = [i]\n                } else if v == me {\n                    indices.append(i)\n\
    \                }\n            } else {\n                minEven = v\n      \
    \          indices = [i]\n            }\n        }\n    }\n    if let me = minEven\
    \ {\n        return [me, indices.min()!]\n    }\n    return []\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(pluck(arr: [4, 2, 3]) == [2, 1])\nassert(pluck(arr: [1,\
    \ 2, 3]) == [2, 1])\nassert(pluck(arr: [] as [Int]) == [] as [Int])\nassert(pluck(arr:\
    \ [5, 0, 3, 0, 4, 2]) == [0, 1])\nassert(pluck(arr: [1, 2, 3, 0, 5, 3]) == [0,\
    \ 3])\nassert(pluck(arr: [5, 4, 8, 4, 8]) == [4, 1])\nassert(pluck(arr: [7, 6,\
    \ 7, 1]) == [6, 1])\nassert(pluck(arr: [7, 9, 7, 1]) == [] as [Int])"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660013550
- exit_code: 0
  program: "\n/// \"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n/// your task is to pluck one of the nodes and return it.\n///\
    \ The plucked node should be the node with the smallest even value.\n/// If multiple\
    \ nodes with the same smallest even value are found return the node that has smallest\
    \ index.\n/// The plucked node should be returned in an array, [ smalest_value,\
    \ its index ],\n/// If there are no even values or the given array is empty, return\
    \ [].\n/// Example 1:\n/// >>> pluck(arr: [4, 2, 3])\n/// [2, 1]\n/// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n/// Example 2:\n\
    /// >>> pluck(arr: [1, 2, 3])\n/// [2, 1]\n/// Explanation: 2 has the smallest\
    \ even value, and 2 has the smallest index.\n/// Example 3:\n/// >>> pluck(arr:\
    \ [] as [Int])\n/// [] as [Int]\n/// Example 4:\n/// >>> pluck(arr: [5, 0, 3,\
    \ 0, 4, 2])\n/// [0, 1]\n/// Explanation: 0 is the smallest value, but  there\
    \ are two zeros,\n/// so we will choose the first zero, which has the smallest\
    \ index.\n/// Constraints:\n/// * 1 <= nodes.length <= 10000\n/// * 0 <= node.value\n\
    func pluck(arr: [Int]) -> [Int] {\n    let evens = arr.filter { $0 % 2 == 0 }\n\
    \    guard !evens.isEmpty else { return [] }\n    let sortedEvens = evens.sorted()\n\
    \    guard let minEven = sortedEvens.first else { return [] }\n    let evenIndex\
    \ = arr.firstIndex(of: minEven) ?? 0\n    return [minEven, evenIndex]\n}\n\n\n\
    func ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(pluck(arr: [4, 2, 3]) == [2, 1])\nassert(pluck(arr:\
    \ [1, 2, 3]) == [2, 1])\nassert(pluck(arr: [] as [Int]) == [] as [Int])\nassert(pluck(arr:\
    \ [5, 0, 3, 0, 4, 2]) == [0, 1])\nassert(pluck(arr: [1, 2, 3, 0, 5, 3]) == [0,\
    \ 3])\nassert(pluck(arr: [5, 4, 8, 4, 8]) == [4, 1])\nassert(pluck(arr: [7, 6,\
    \ 7, 1]) == [6, 1])\nassert(pluck(arr: [7, 9, 7, 1]) == [] as [Int])"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660013550
- exit_code: 0
  program: "\n/// \"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n/// your task is to pluck one of the nodes and return it.\n///\
    \ The plucked node should be the node with the smallest even value.\n/// If multiple\
    \ nodes with the same smallest even value are found return the node that has smallest\
    \ index.\n/// The plucked node should be returned in an array, [ smalest_value,\
    \ its index ],\n/// If there are no even values or the given array is empty, return\
    \ [].\n/// Example 1:\n/// >>> pluck(arr: [4, 2, 3])\n/// [2, 1]\n/// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n/// Example 2:\n\
    /// >>> pluck(arr: [1, 2, 3])\n/// [2, 1]\n/// Explanation: 2 has the smallest\
    \ even value, and 2 has the smallest index.\n/// Example 3:\n/// >>> pluck(arr:\
    \ [] as [Int])\n/// [] as [Int]\n/// Example 4:\n/// >>> pluck(arr: [5, 0, 3,\
    \ 0, 4, 2])\n/// [0, 1]\n/// Explanation: 0 is the smallest value, but  there\
    \ are two zeros,\n/// so we will choose the first zero, which has the smallest\
    \ index.\n/// Constraints:\n/// * 1 <= nodes.length <= 10000\n/// * 0 <= node.value\n\
    func pluck(arr: [Int]) -> [Int] {\n    guard arr.count > 0 else { return [] }\n\
    \    var smallestEven = Int.max\n    var smallestEvenIndex = 0\n    for (index,\
    \ element) in arr.enumerated() {\n        if element % 2 == 0 && element < smallestEven\
    \ {\n            smallestEven = element\n            smallestEvenIndex = index\n\
    \        }\n    }\n    return smallestEven == Int.max ? [] : [smallestEven, smallestEvenIndex]\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(pluck(arr: [4, 2, 3]) == [2, 1])\nassert(pluck(arr:\
    \ [1, 2, 3]) == [2, 1])\nassert(pluck(arr: [] as [Int]) == [] as [Int])\nassert(pluck(arr:\
    \ [5, 0, 3, 0, 4, 2]) == [0, 1])\nassert(pluck(arr: [1, 2, 3, 0, 5, 3]) == [0,\
    \ 3])\nassert(pluck(arr: [5, 4, 8, 4, 8]) == [4, 1])\nassert(pluck(arr: [7, 6,\
    \ 7, 1]) == [6, 1])\nassert(pluck(arr: [7, 9, 7, 1]) == [] as [Int])"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660013550
- exit_code: 0
  program: "\n/// \"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n/// your task is to pluck one of the nodes and return it.\n///\
    \ The plucked node should be the node with the smallest even value.\n/// If multiple\
    \ nodes with the same smallest even value are found return the node that has smallest\
    \ index.\n/// The plucked node should be returned in an array, [ smalest_value,\
    \ its index ],\n/// If there are no even values or the given array is empty, return\
    \ [].\n/// Example 1:\n/// >>> pluck(arr: [4, 2, 3])\n/// [2, 1]\n/// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n/// Example 2:\n\
    /// >>> pluck(arr: [1, 2, 3])\n/// [2, 1]\n/// Explanation: 2 has the smallest\
    \ even value, and 2 has the smallest index.\n/// Example 3:\n/// >>> pluck(arr:\
    \ [] as [Int])\n/// [] as [Int]\n/// Example 4:\n/// >>> pluck(arr: [5, 0, 3,\
    \ 0, 4, 2])\n/// [0, 1]\n/// Explanation: 0 is the smallest value, but  there\
    \ are two zeros,\n/// so we will choose the first zero, which has the smallest\
    \ index.\n/// Constraints:\n/// * 1 <= nodes.length <= 10000\n/// * 0 <= node.value\n\
    func pluck(arr: [Int]) -> [Int] {\n    let evens = arr.filter { $0 % 2 == 0 }\n\
    \    guard let minEven = evens.min() else { return [] }\n    guard let minEvenIndex\
    \ = arr.firstIndex(of: minEven) else { return [] }\n    return [minEven, minEvenIndex]\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(pluck(arr: [4, 2, 3]) == [2, 1])\nassert(pluck(arr:\
    \ [1, 2, 3]) == [2, 1])\nassert(pluck(arr: [] as [Int]) == [] as [Int])\nassert(pluck(arr:\
    \ [5, 0, 3, 0, 4, 2]) == [0, 1])\nassert(pluck(arr: [1, 2, 3, 0, 5, 3]) == [0,\
    \ 3])\nassert(pluck(arr: [5, 4, 8, 4, 8]) == [4, 1])\nassert(pluck(arr: [7, 6,\
    \ 7, 1]) == [6, 1])\nassert(pluck(arr: [7, 9, 7, 1]) == [] as [Int])"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660013365
- exit_code: -4
  program: "\n/// \"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n/// your task is to pluck one of the nodes and return it.\n///\
    \ The plucked node should be the node with the smallest even value.\n/// If multiple\
    \ nodes with the same smallest even value are found return the node that has smallest\
    \ index.\n/// The plucked node should be returned in an array, [ smalest_value,\
    \ its index ],\n/// If there are no even values or the given array is empty, return\
    \ [].\n/// Example 1:\n/// >>> pluck(arr: [4, 2, 3])\n/// [2, 1]\n/// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n/// Example 2:\n\
    /// >>> pluck(arr: [1, 2, 3])\n/// [2, 1]\n/// Explanation: 2 has the smallest\
    \ even value, and 2 has the smallest index.\n/// Example 3:\n/// >>> pluck(arr:\
    \ [] as [Int])\n/// [] as [Int]\n/// Example 4:\n/// >>> pluck(arr: [5, 0, 3,\
    \ 0, 4, 2])\n/// [0, 1]\n/// Explanation: 0 is the smallest value, but  there\
    \ are two zeros,\n/// so we will choose the first zero, which has the smallest\
    \ index.\n/// Constraints:\n/// * 1 <= nodes.length <= 10000\n/// * 0 <= node.value\n\
    func pluck(arr: [Int]) -> [Int] {\n    return arr.indices.reduce(into: [Int](),\
    \ {\n        if let first = $0.first, first % 2 == 0 {\n            $0 = [first,\
    \ $0.last!]\n        } else if $1 % 2 == 0 {\n            $0 = [$1, $1]\n    \
    \    }\n    })\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool\
    \ {\n    if left.count != right.count {\n        return false\n    }\n    for\
    \ (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(pluck(arr: [4, 2,\
    \ 3]) == [2, 1])\nassert(pluck(arr: [1, 2, 3]) == [2, 1])\nassert(pluck(arr: []\
    \ as [Int]) == [] as [Int])\nassert(pluck(arr: [5, 0, 3, 0, 4, 2]) == [0, 1])\n\
    assert(pluck(arr: [1, 2, 3, 0, 5, 3]) == [0, 3])\nassert(pluck(arr: [5, 4, 8,\
    \ 4, 8]) == [4, 1])\nassert(pluck(arr: [7, 6, 7, 1]) == [6, 1])\nassert(pluck(arr:\
    \ [7, 9, 7, 1]) == [] as [Int])"
  status: Exception
  stderr: 'tmpqngk7i1c/tmpqngk7i1c.swift:50: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002ac17c6b6c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002ac17c3adb6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002ac17c3ad988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002ac17c3ac7b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpqngk7i1c                        0x000055749fb6e7ac <unavailable> + 6060

    5    libc.so.6                          0x00002ac17c8a2460 __libc_start_main +
    245

    6    tmpqngk7i1c                        0x000055749fb6e3b9 <unavailable> + 5049

    '
  stdout: ''
  timestamp: 1660013550
- exit_code: 0
  program: "\n/// \"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n/// your task is to pluck one of the nodes and return it.\n///\
    \ The plucked node should be the node with the smallest even value.\n/// If multiple\
    \ nodes with the same smallest even value are found return the node that has smallest\
    \ index.\n/// The plucked node should be returned in an array, [ smalest_value,\
    \ its index ],\n/// If there are no even values or the given array is empty, return\
    \ [].\n/// Example 1:\n/// >>> pluck(arr: [4, 2, 3])\n/// [2, 1]\n/// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n/// Example 2:\n\
    /// >>> pluck(arr: [1, 2, 3])\n/// [2, 1]\n/// Explanation: 2 has the smallest\
    \ even value, and 2 has the smallest index.\n/// Example 3:\n/// >>> pluck(arr:\
    \ [] as [Int])\n/// [] as [Int]\n/// Example 4:\n/// >>> pluck(arr: [5, 0, 3,\
    \ 0, 4, 2])\n/// [0, 1]\n/// Explanation: 0 is the smallest value, but  there\
    \ are two zeros,\n/// so we will choose the first zero, which has the smallest\
    \ index.\n/// Constraints:\n/// * 1 <= nodes.length <= 10000\n/// * 0 <= node.value\n\
    func pluck(arr: [Int]) -> [Int] {\n    guard !arr.isEmpty else { return [] }\n\
    \    var evens = [Int]()\n    for num in arr {\n        if num % 2 == 0 {\n  \
    \          evens.append(num)\n        }\n    }\n    guard !evens.isEmpty else\
    \ { return [] }\n    let even = evens.min()!\n    for i in 0..<arr.count {\n \
    \       if arr[i] == even {\n            return [even, i]\n        }\n    }\n\
    \    return []\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool\
    \ {\n    if left.count != right.count {\n        return false\n    }\n    for\
    \ (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(pluck(arr: [4, 2,\
    \ 3]) == [2, 1])\nassert(pluck(arr: [1, 2, 3]) == [2, 1])\nassert(pluck(arr: []\
    \ as [Int]) == [] as [Int])\nassert(pluck(arr: [5, 0, 3, 0, 4, 2]) == [0, 1])\n\
    assert(pluck(arr: [1, 2, 3, 0, 5, 3]) == [0, 3])\nassert(pluck(arr: [5, 4, 8,\
    \ 4, 8]) == [4, 1])\nassert(pluck(arr: [7, 6, 7, 1]) == [6, 1])\nassert(pluck(arr:\
    \ [7, 9, 7, 1]) == [] as [Int])"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660013550
- exit_code: 0
  program: "\n/// \"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n/// your task is to pluck one of the nodes and return it.\n///\
    \ The plucked node should be the node with the smallest even value.\n/// If multiple\
    \ nodes with the same smallest even value are found return the node that has smallest\
    \ index.\n/// The plucked node should be returned in an array, [ smalest_value,\
    \ its index ],\n/// If there are no even values or the given array is empty, return\
    \ [].\n/// Example 1:\n/// >>> pluck(arr: [4, 2, 3])\n/// [2, 1]\n/// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n/// Example 2:\n\
    /// >>> pluck(arr: [1, 2, 3])\n/// [2, 1]\n/// Explanation: 2 has the smallest\
    \ even value, and 2 has the smallest index.\n/// Example 3:\n/// >>> pluck(arr:\
    \ [] as [Int])\n/// [] as [Int]\n/// Example 4:\n/// >>> pluck(arr: [5, 0, 3,\
    \ 0, 4, 2])\n/// [0, 1]\n/// Explanation: 0 is the smallest value, but  there\
    \ are two zeros,\n/// so we will choose the first zero, which has the smallest\
    \ index.\n/// Constraints:\n/// * 1 <= nodes.length <= 10000\n/// * 0 <= node.value\n\
    func pluck(arr: [Int]) -> [Int] {\n    var current: Int?\n    var currentIndex:\
    \ Int?\n    for (index, value) in arr.enumerated() {\n        if value % 2 ==\
    \ 0 && (current == nil || value < current!) {\n            current = value\n \
    \           currentIndex = index\n        }\n    }\n    if let result = current,\
    \ let index = currentIndex {\n        return [result, index]\n    }\n    return\
    \ []\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if\
    \ left.count != right.count {\n        return false\n    }\n    for (l, r) in\
    \ zip(left, right) {\n        if l != r {\n            return false\n        }\n\
    \    }\n    return true\n}\n            \nassert(pluck(arr: [4, 2, 3]) == [2,\
    \ 1])\nassert(pluck(arr: [1, 2, 3]) == [2, 1])\nassert(pluck(arr: [] as [Int])\
    \ == [] as [Int])\nassert(pluck(arr: [5, 0, 3, 0, 4, 2]) == [0, 1])\nassert(pluck(arr:\
    \ [1, 2, 3, 0, 5, 3]) == [0, 3])\nassert(pluck(arr: [5, 4, 8, 4, 8]) == [4, 1])\n\
    assert(pluck(arr: [7, 6, 7, 1]) == [6, 1])\nassert(pluck(arr: [7, 9, 7, 1]) ==\
    \ [] as [Int])"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660013550
- exit_code: 1
  program: "\n/// \"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n/// your task is to pluck one of the nodes and return it.\n///\
    \ The plucked node should be the node with the smallest even value.\n/// If multiple\
    \ nodes with the same smallest even value are found return the node that has smallest\
    \ index.\n/// The plucked node should be returned in an array, [ smalest_value,\
    \ its index ],\n/// If there are no even values or the given array is empty, return\
    \ [].\n/// Example 1:\n/// >>> pluck(arr: [4, 2, 3])\n/// [2, 1]\n/// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n/// Example 2:\n\
    /// >>> pluck(arr: [1, 2, 3])\n/// [2, 1]\n/// Explanation: 2 has the smallest\
    \ even value, and 2 has the smallest index.\n/// Example 3:\n/// >>> pluck(arr:\
    \ [] as [Int])\n/// [] as [Int]\n/// Example 4:\n/// >>> pluck(arr: [5, 0, 3,\
    \ 0, 4, 2])\n/// [0, 1]\n/// Explanation: 0 is the smallest value, but  there\
    \ are two zeros,\n/// so we will choose the first zero, which has the smallest\
    \ index.\n/// Constraints:\n/// * 1 <= nodes.length <= 10000\n/// * 0 <= node.value\n\
    func pluck(arr: [Int]) -> [Int] {\n    // Parameter validations\n    guard arr.count\
    \ > 0 else { return [] }\n    // Sorting arr of Int based on even numbers and\
    \ positions\n    let sortedArr = arr.enumerated().sorted { (left, right) -> Bool\
    \ in\n        if left.element.isEven && right.element.isEven {\n            return\
    \ left.offset < right.offset\n        } else if left.element.isEven {\n      \
    \      return true\n        } else if right.element.isEven {\n            return\
    \ false\n        } else {\n            return false\n        }\n    }\n    //\
    \ Return the first element\n    return sortedArr.first?.element.isEven == true\
    \ ? [sortedArr.first!.element, sortedArr.first!.offset] : []\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(pluck(arr: [4, 2, 3]) == [2, 1])\nassert(pluck(arr: [1,\
    \ 2, 3]) == [2, 1])\nassert(pluck(arr: [] as [Int]) == [] as [Int])\nassert(pluck(arr:\
    \ [5, 0, 3, 0, 4, 2]) == [0, 1])\nassert(pluck(arr: [1, 2, 3, 0, 5, 3]) == [0,\
    \ 3])\nassert(pluck(arr: [5, 4, 8, 4, 8]) == [4, 1])\nassert(pluck(arr: [7, 6,\
    \ 7, 1]) == [6, 1])\nassert(pluck(arr: [7, 9, 7, 1]) == [] as [Int])"
  status: SyntaxError
  stderr: "/tmp/tmpdh7j0ssr.swift:32:25: error: value of type 'Int' has no member\
    \ 'isEven'\n        if left.element.isEven && right.element.isEven {\n       \
    \    ~~~~~~~~~~~~ ^~~~~~\n/tmp/tmpdh7j0ssr.swift:32:49: error: value of type 'Int'\
    \ has no member 'isEven'\n        if left.element.isEven && right.element.isEven\
    \ {\n                                  ~~~~~~~~~~~~~ ^~~~~~\n"
  stdout: ''
  timestamp: 1660013550
- exit_code: 0
  program: "\n/// \"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n/// your task is to pluck one of the nodes and return it.\n///\
    \ The plucked node should be the node with the smallest even value.\n/// If multiple\
    \ nodes with the same smallest even value are found return the node that has smallest\
    \ index.\n/// The plucked node should be returned in an array, [ smalest_value,\
    \ its index ],\n/// If there are no even values or the given array is empty, return\
    \ [].\n/// Example 1:\n/// >>> pluck(arr: [4, 2, 3])\n/// [2, 1]\n/// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n/// Example 2:\n\
    /// >>> pluck(arr: [1, 2, 3])\n/// [2, 1]\n/// Explanation: 2 has the smallest\
    \ even value, and 2 has the smallest index.\n/// Example 3:\n/// >>> pluck(arr:\
    \ [] as [Int])\n/// [] as [Int]\n/// Example 4:\n/// >>> pluck(arr: [5, 0, 3,\
    \ 0, 4, 2])\n/// [0, 1]\n/// Explanation: 0 is the smallest value, but  there\
    \ are two zeros,\n/// so we will choose the first zero, which has the smallest\
    \ index.\n/// Constraints:\n/// * 1 <= nodes.length <= 10000\n/// * 0 <= node.value\n\
    func pluck(arr: [Int]) -> [Int] {\n    // your code here\n    var result: [Int]\
    \ = []\n    if arr.isEmpty {\n        return result\n    }\n    var evenValues:\
    \ [Int] = []\n    for number in arr {\n        if number % 2 == 0 {\n        \
    \    evenValues.append(number)\n        }\n    }\n    if evenValues.isEmpty {\n\
    \        return result\n    }\n    var min = Int.max\n    for value in evenValues\
    \ {\n        if value < min {\n            min = value\n        }\n    }\n   \
    \ var minIndex = 0\n    for (index, value) in arr.enumerated() {\n        if value\
    \ == min {\n            minIndex = index\n            break\n        }\n    }\n\
    \    result.append(min)\n    result.append(minIndex)\n    return result\n}\n\n\
    \nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(pluck(arr: [4, 2, 3]) == [2, 1])\nassert(pluck(arr:\
    \ [1, 2, 3]) == [2, 1])\nassert(pluck(arr: [] as [Int]) == [] as [Int])\nassert(pluck(arr:\
    \ [5, 0, 3, 0, 4, 2]) == [0, 1])\nassert(pluck(arr: [1, 2, 3, 0, 5, 3]) == [0,\
    \ 3])\nassert(pluck(arr: [5, 4, 8, 4, 8]) == [4, 1])\nassert(pluck(arr: [7, 6,\
    \ 7, 1]) == [6, 1])\nassert(pluck(arr: [7, 9, 7, 1]) == [] as [Int])"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660013550
- exit_code: 0
  program: "\n/// \"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n/// your task is to pluck one of the nodes and return it.\n///\
    \ The plucked node should be the node with the smallest even value.\n/// If multiple\
    \ nodes with the same smallest even value are found return the node that has smallest\
    \ index.\n/// The plucked node should be returned in an array, [ smalest_value,\
    \ its index ],\n/// If there are no even values or the given array is empty, return\
    \ [].\n/// Example 1:\n/// >>> pluck(arr: [4, 2, 3])\n/// [2, 1]\n/// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n/// Example 2:\n\
    /// >>> pluck(arr: [1, 2, 3])\n/// [2, 1]\n/// Explanation: 2 has the smallest\
    \ even value, and 2 has the smallest index.\n/// Example 3:\n/// >>> pluck(arr:\
    \ [] as [Int])\n/// [] as [Int]\n/// Example 4:\n/// >>> pluck(arr: [5, 0, 3,\
    \ 0, 4, 2])\n/// [0, 1]\n/// Explanation: 0 is the smallest value, but  there\
    \ are two zeros,\n/// so we will choose the first zero, which has the smallest\
    \ index.\n/// Constraints:\n/// * 1 <= nodes.length <= 10000\n/// * 0 <= node.value\n\
    func pluck(arr: [Int]) -> [Int] {\n    guard !arr.isEmpty else { return [] }\n\
    \    let evenNumbers = arr.filter { $0 % 2 == 0 }\n    guard !evenNumbers.isEmpty\
    \ else { return [] }\n    let smallestEven = evenNumbers.min()!\n    let smallestEvenIndex\
    \ = arr.index(of: smallestEven)!\n    return [smallestEven, smallestEvenIndex]\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(pluck(arr: [4, 2, 3]) == [2, 1])\nassert(pluck(arr:\
    \ [1, 2, 3]) == [2, 1])\nassert(pluck(arr: [] as [Int]) == [] as [Int])\nassert(pluck(arr:\
    \ [5, 0, 3, 0, 4, 2]) == [0, 1])\nassert(pluck(arr: [1, 2, 3, 0, 5, 3]) == [0,\
    \ 3])\nassert(pluck(arr: [5, 4, 8, 4, 8]) == [4, 1])\nassert(pluck(arr: [7, 6,\
    \ 7, 1]) == [6, 1])\nassert(pluck(arr: [7, 9, 7, 1]) == [] as [Int])"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660013550
- exit_code: 0
  program: "\n/// \"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n/// your task is to pluck one of the nodes and return it.\n///\
    \ The plucked node should be the node with the smallest even value.\n/// If multiple\
    \ nodes with the same smallest even value are found return the node that has smallest\
    \ index.\n/// The plucked node should be returned in an array, [ smalest_value,\
    \ its index ],\n/// If there are no even values or the given array is empty, return\
    \ [].\n/// Example 1:\n/// >>> pluck(arr: [4, 2, 3])\n/// [2, 1]\n/// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n/// Example 2:\n\
    /// >>> pluck(arr: [1, 2, 3])\n/// [2, 1]\n/// Explanation: 2 has the smallest\
    \ even value, and 2 has the smallest index.\n/// Example 3:\n/// >>> pluck(arr:\
    \ [] as [Int])\n/// [] as [Int]\n/// Example 4:\n/// >>> pluck(arr: [5, 0, 3,\
    \ 0, 4, 2])\n/// [0, 1]\n/// Explanation: 0 is the smallest value, but  there\
    \ are two zeros,\n/// so we will choose the first zero, which has the smallest\
    \ index.\n/// Constraints:\n/// * 1 <= nodes.length <= 10000\n/// * 0 <= node.value\n\
    func pluck(arr: [Int]) -> [Int] {\n    guard !arr.isEmpty else { return [] }\n\
    \    let evens = arr.filter { $0 % 2 == 0 }\n    guard !evens.isEmpty else { return\
    \ [] }\n    let minEven = evens.min()!\n    return [minEven, arr.firstIndex(of:\
    \ minEven)!]\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool\
    \ {\n    if left.count != right.count {\n        return false\n    }\n    for\
    \ (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(pluck(arr: [4, 2,\
    \ 3]) == [2, 1])\nassert(pluck(arr: [1, 2, 3]) == [2, 1])\nassert(pluck(arr: []\
    \ as [Int]) == [] as [Int])\nassert(pluck(arr: [5, 0, 3, 0, 4, 2]) == [0, 1])\n\
    assert(pluck(arr: [1, 2, 3, 0, 5, 3]) == [0, 3])\nassert(pluck(arr: [5, 4, 8,\
    \ 4, 8]) == [4, 1])\nassert(pluck(arr: [7, 6, 7, 1]) == [6, 1])\nassert(pluck(arr:\
    \ [7, 9, 7, 1]) == [] as [Int])"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660013550
- exit_code: 0
  program: "\n/// \"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n/// your task is to pluck one of the nodes and return it.\n///\
    \ The plucked node should be the node with the smallest even value.\n/// If multiple\
    \ nodes with the same smallest even value are found return the node that has smallest\
    \ index.\n/// The plucked node should be returned in an array, [ smalest_value,\
    \ its index ],\n/// If there are no even values or the given array is empty, return\
    \ [].\n/// Example 1:\n/// >>> pluck(arr: [4, 2, 3])\n/// [2, 1]\n/// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n/// Example 2:\n\
    /// >>> pluck(arr: [1, 2, 3])\n/// [2, 1]\n/// Explanation: 2 has the smallest\
    \ even value, and 2 has the smallest index.\n/// Example 3:\n/// >>> pluck(arr:\
    \ [] as [Int])\n/// [] as [Int]\n/// Example 4:\n/// >>> pluck(arr: [5, 0, 3,\
    \ 0, 4, 2])\n/// [0, 1]\n/// Explanation: 0 is the smallest value, but  there\
    \ are two zeros,\n/// so we will choose the first zero, which has the smallest\
    \ index.\n/// Constraints:\n/// * 1 <= nodes.length <= 10000\n/// * 0 <= node.value\n\
    func pluck(arr: [Int]) -> [Int] {\n    let evens = arr.filter { $0 % 2 == 0 }\n\
    \    guard let minEven = evens.min() else { return [] }\n    return [minEven,\
    \ arr.firstIndex(of: minEven)!]\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int,\
    \ Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n\
    \    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n          \
    \  return false\n        }\n    }\n    return true\n}\n            \nassert(pluck(arr:\
    \ [4, 2, 3]) == [2, 1])\nassert(pluck(arr: [1, 2, 3]) == [2, 1])\nassert(pluck(arr:\
    \ [] as [Int]) == [] as [Int])\nassert(pluck(arr: [5, 0, 3, 0, 4, 2]) == [0, 1])\n\
    assert(pluck(arr: [1, 2, 3, 0, 5, 3]) == [0, 3])\nassert(pluck(arr: [5, 4, 8,\
    \ 4, 8]) == [4, 1])\nassert(pluck(arr: [7, 6, 7, 1]) == [6, 1])\nassert(pluck(arr:\
    \ [7, 9, 7, 1]) == [] as [Int])"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660013365
- exit_code: 1
  program: "\n/// \"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n/// your task is to pluck one of the nodes and return it.\n///\
    \ The plucked node should be the node with the smallest even value.\n/// If multiple\
    \ nodes with the same smallest even value are found return the node that has smallest\
    \ index.\n/// The plucked node should be returned in an array, [ smalest_value,\
    \ its index ],\n/// If there are no even values or the given array is empty, return\
    \ [].\n/// Example 1:\n/// >>> pluck(arr: [4, 2, 3])\n/// [2, 1]\n/// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n/// Example 2:\n\
    /// >>> pluck(arr: [1, 2, 3])\n/// [2, 1]\n/// Explanation: 2 has the smallest\
    \ even value, and 2 has the smallest index.\n/// Example 3:\n/// >>> pluck(arr:\
    \ [] as [Int])\n/// [] as [Int]\n/// Example 4:\n/// >>> pluck(arr: [5, 0, 3,\
    \ 0, 4, 2])\n/// [0, 1]\n/// Explanation: 0 is the smallest value, but  there\
    \ are two zeros,\n/// so we will choose the first zero, which has the smallest\
    \ index.\n/// Constraints:\n/// * 1 <= nodes.length <= 10000\n/// * 0 <= node.value\n\
    func pluck(arr: [Int]) -> [Int] {\n    return arr.enumerated().filter { $0.element\
    \ % 2 == 0 }.min { $0.element < $1.element }?.reversed() ?? []\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(pluck(arr: [4, 2, 3]) == [2, 1])\nassert(pluck(arr: [1,\
    \ 2, 3]) == [2, 1])\nassert(pluck(arr: [] as [Int]) == [] as [Int])\nassert(pluck(arr:\
    \ [5, 0, 3, 0, 4, 2]) == [0, 1])\nassert(pluck(arr: [1, 2, 3, 0, 5, 3]) == [0,\
    \ 3])\nassert(pluck(arr: [5, 4, 8, 4, 8]) == [4, 1])\nassert(pluck(arr: [7, 6,\
    \ 7, 1]) == [6, 1])\nassert(pluck(arr: [7, 9, 7, 1]) == [] as [Int])"
  status: SyntaxError
  stderr: "/tmp/tmp_s2yc6jv.swift:28:93: error: value of tuple type 'EnumeratedSequence<[Int]>.Iterator.Element'\
    \ (aka '(offset: Int, element: Int)') has no member 'reversed'\n    return arr.enumerated().filter\
    \ { $0.element % 2 == 0 }.min { $0.element < $1.element }?.reversed() ?? []\n\
    \           ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\
    \ ^~~~~~~~\n"
  stdout: ''
  timestamp: 1660013364
- exit_code: 0
  program: "\n/// \"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n/// your task is to pluck one of the nodes and return it.\n///\
    \ The plucked node should be the node with the smallest even value.\n/// If multiple\
    \ nodes with the same smallest even value are found return the node that has smallest\
    \ index.\n/// The plucked node should be returned in an array, [ smalest_value,\
    \ its index ],\n/// If there are no even values or the given array is empty, return\
    \ [].\n/// Example 1:\n/// >>> pluck(arr: [4, 2, 3])\n/// [2, 1]\n/// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n/// Example 2:\n\
    /// >>> pluck(arr: [1, 2, 3])\n/// [2, 1]\n/// Explanation: 2 has the smallest\
    \ even value, and 2 has the smallest index.\n/// Example 3:\n/// >>> pluck(arr:\
    \ [] as [Int])\n/// [] as [Int]\n/// Example 4:\n/// >>> pluck(arr: [5, 0, 3,\
    \ 0, 4, 2])\n/// [0, 1]\n/// Explanation: 0 is the smallest value, but  there\
    \ are two zeros,\n/// so we will choose the first zero, which has the smallest\
    \ index.\n/// Constraints:\n/// * 1 <= nodes.length <= 10000\n/// * 0 <= node.value\n\
    func pluck(arr: [Int]) -> [Int] {\n    var result = [Int]()\n    var minEven =\
    \ Int.max\n    var minEvenIndex = -1\n    var minEvenCount = 0\n    for (index,\
    \ element) in arr.enumerated() {\n        if element % 2 == 0 {\n            if\
    \ element < minEven {\n                minEven = element\n                minEvenIndex\
    \ = index\n                minEvenCount = 1\n            } else if element ==\
    \ minEven {\n                minEvenCount += 1\n            }\n        }\n   \
    \ }\n    if minEvenIndex != -1 {\n        result.append(minEven)\n        result.append(minEvenIndex)\n\
    \    }\n    return result\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(pluck(arr:\
    \ [4, 2, 3]) == [2, 1])\nassert(pluck(arr: [1, 2, 3]) == [2, 1])\nassert(pluck(arr:\
    \ [] as [Int]) == [] as [Int])\nassert(pluck(arr: [5, 0, 3, 0, 4, 2]) == [0, 1])\n\
    assert(pluck(arr: [1, 2, 3, 0, 5, 3]) == [0, 3])\nassert(pluck(arr: [5, 4, 8,\
    \ 4, 8]) == [4, 1])\nassert(pluck(arr: [7, 6, 7, 1]) == [6, 1])\nassert(pluck(arr:\
    \ [7, 9, 7, 1]) == [] as [Int])"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660013550
- exit_code: 0
  program: "\n/// \"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n/// your task is to pluck one of the nodes and return it.\n///\
    \ The plucked node should be the node with the smallest even value.\n/// If multiple\
    \ nodes with the same smallest even value are found return the node that has smallest\
    \ index.\n/// The plucked node should be returned in an array, [ smalest_value,\
    \ its index ],\n/// If there are no even values or the given array is empty, return\
    \ [].\n/// Example 1:\n/// >>> pluck(arr: [4, 2, 3])\n/// [2, 1]\n/// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n/// Example 2:\n\
    /// >>> pluck(arr: [1, 2, 3])\n/// [2, 1]\n/// Explanation: 2 has the smallest\
    \ even value, and 2 has the smallest index.\n/// Example 3:\n/// >>> pluck(arr:\
    \ [] as [Int])\n/// [] as [Int]\n/// Example 4:\n/// >>> pluck(arr: [5, 0, 3,\
    \ 0, 4, 2])\n/// [0, 1]\n/// Explanation: 0 is the smallest value, but  there\
    \ are two zeros,\n/// so we will choose the first zero, which has the smallest\
    \ index.\n/// Constraints:\n/// * 1 <= nodes.length <= 10000\n/// * 0 <= node.value\n\
    func pluck(arr: [Int]) -> [Int] {\n    var result = [Int]()\n    guard arr.count\
    \ > 0 else { return result }\n    var minIndex = 0\n    for i in 0..<arr.count\
    \ {\n        if arr[i] % 2 == 0 {\n            if result.count == 0 {\n      \
    \          result.append(arr[i])\n                minIndex = i\n            }\
    \ else {\n                if arr[i] < result[0] {\n                    result[0]\
    \ = arr[i]\n                    minIndex = i\n                }\n            }\n\
    \        }\n    }\n    if result.count > 0 {\n        result.append(minIndex)\n\
    \    }\n    return result\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(pluck(arr:\
    \ [4, 2, 3]) == [2, 1])\nassert(pluck(arr: [1, 2, 3]) == [2, 1])\nassert(pluck(arr:\
    \ [] as [Int]) == [] as [Int])\nassert(pluck(arr: [5, 0, 3, 0, 4, 2]) == [0, 1])\n\
    assert(pluck(arr: [1, 2, 3, 0, 5, 3]) == [0, 3])\nassert(pluck(arr: [5, 4, 8,\
    \ 4, 8]) == [4, 1])\nassert(pluck(arr: [7, 6, 7, 1]) == [6, 1])\nassert(pluck(arr:\
    \ [7, 9, 7, 1]) == [] as [Int])"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660013550
- exit_code: -4
  program: "\n/// \"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n/// your task is to pluck one of the nodes and return it.\n///\
    \ The plucked node should be the node with the smallest even value.\n/// If multiple\
    \ nodes with the same smallest even value are found return the node that has smallest\
    \ index.\n/// The plucked node should be returned in an array, [ smalest_value,\
    \ its index ],\n/// If there are no even values or the given array is empty, return\
    \ [].\n/// Example 1:\n/// >>> pluck(arr: [4, 2, 3])\n/// [2, 1]\n/// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n/// Example 2:\n\
    /// >>> pluck(arr: [1, 2, 3])\n/// [2, 1]\n/// Explanation: 2 has the smallest\
    \ even value, and 2 has the smallest index.\n/// Example 3:\n/// >>> pluck(arr:\
    \ [] as [Int])\n/// [] as [Int]\n/// Example 4:\n/// >>> pluck(arr: [5, 0, 3,\
    \ 0, 4, 2])\n/// [0, 1]\n/// Explanation: 0 is the smallest value, but  there\
    \ are two zeros,\n/// so we will choose the first zero, which has the smallest\
    \ index.\n/// Constraints:\n/// * 1 <= nodes.length <= 10000\n/// * 0 <= node.value\n\
    func pluck(arr: [Int]) -> [Int] {\n    guard arr.contains(where: { $0 % 2 == 0\
    \ }) else { return [] }\n    var result = [Int]()\n    for node in arr.enumerated()\
    \ {\n        if node.element % 2 == 0 {\n            result.append(node.element)\n\
    \            result.append(node.offset)\n            break\n        }\n    }\n\
    \    return result\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) ->\
    \ Bool {\n    if left.count != right.count {\n        return false\n    }\n  \
    \  for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(pluck(arr: [4, 2,\
    \ 3]) == [2, 1])\nassert(pluck(arr: [1, 2, 3]) == [2, 1])\nassert(pluck(arr: []\
    \ as [Int]) == [] as [Int])\nassert(pluck(arr: [5, 0, 3, 0, 4, 2]) == [0, 1])\n\
    assert(pluck(arr: [1, 2, 3, 0, 5, 3]) == [0, 3])\nassert(pluck(arr: [5, 4, 8,\
    \ 4, 8]) == [4, 1])\nassert(pluck(arr: [7, 6, 7, 1]) == [6, 1])\nassert(pluck(arr:\
    \ [7, 9, 7, 1]) == [] as [Int])"
  status: Exception
  stderr: 'tmpgscz0ghr/tmpgscz0ghr.swift:53: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b60c00c6c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b60bfdbdb6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b60bfdbd988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b60bfdbc7b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpgscz0ghr                        0x0000562710d9877c <unavailable> + 6012

    5    libc.so.6                          0x00002b60c02b2460 __libc_start_main +
    245

    6    tmpgscz0ghr                        0x0000562710d98389 <unavailable> + 5001

    '
  stdout: ''
  timestamp: 1660013550
- exit_code: 0
  program: "\n/// \"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n/// your task is to pluck one of the nodes and return it.\n///\
    \ The plucked node should be the node with the smallest even value.\n/// If multiple\
    \ nodes with the same smallest even value are found return the node that has smallest\
    \ index.\n/// The plucked node should be returned in an array, [ smalest_value,\
    \ its index ],\n/// If there are no even values or the given array is empty, return\
    \ [].\n/// Example 1:\n/// >>> pluck(arr: [4, 2, 3])\n/// [2, 1]\n/// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n/// Example 2:\n\
    /// >>> pluck(arr: [1, 2, 3])\n/// [2, 1]\n/// Explanation: 2 has the smallest\
    \ even value, and 2 has the smallest index.\n/// Example 3:\n/// >>> pluck(arr:\
    \ [] as [Int])\n/// [] as [Int]\n/// Example 4:\n/// >>> pluck(arr: [5, 0, 3,\
    \ 0, 4, 2])\n/// [0, 1]\n/// Explanation: 0 is the smallest value, but  there\
    \ are two zeros,\n/// so we will choose the first zero, which has the smallest\
    \ index.\n/// Constraints:\n/// * 1 <= nodes.length <= 10000\n/// * 0 <= node.value\n\
    func pluck(arr: [Int]) -> [Int] {\n    let smallestEven = arr.filter { $0 % 2\
    \ == 0 }.min()\n    guard let smallest = smallestEven else { return [] }\n   \
    \ return [smallest, arr.firstIndex(of: smallest)!]\n}\n\n\nfunc ==(left: [(Int,\
    \ Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n\
    \        return false\n    }\n    for (l, r) in zip(left, right) {\n        if\
    \ l != r {\n            return false\n        }\n    }\n    return true\n}\n \
    \           \nassert(pluck(arr: [4, 2, 3]) == [2, 1])\nassert(pluck(arr: [1, 2,\
    \ 3]) == [2, 1])\nassert(pluck(arr: [] as [Int]) == [] as [Int])\nassert(pluck(arr:\
    \ [5, 0, 3, 0, 4, 2]) == [0, 1])\nassert(pluck(arr: [1, 2, 3, 0, 5, 3]) == [0,\
    \ 3])\nassert(pluck(arr: [5, 4, 8, 4, 8]) == [4, 1])\nassert(pluck(arr: [7, 6,\
    \ 7, 1]) == [6, 1])\nassert(pluck(arr: [7, 9, 7, 1]) == [] as [Int])"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660013550
- exit_code: 0
  program: "\n/// \"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n/// your task is to pluck one of the nodes and return it.\n///\
    \ The plucked node should be the node with the smallest even value.\n/// If multiple\
    \ nodes with the same smallest even value are found return the node that has smallest\
    \ index.\n/// The plucked node should be returned in an array, [ smalest_value,\
    \ its index ],\n/// If there are no even values or the given array is empty, return\
    \ [].\n/// Example 1:\n/// >>> pluck(arr: [4, 2, 3])\n/// [2, 1]\n/// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n/// Example 2:\n\
    /// >>> pluck(arr: [1, 2, 3])\n/// [2, 1]\n/// Explanation: 2 has the smallest\
    \ even value, and 2 has the smallest index.\n/// Example 3:\n/// >>> pluck(arr:\
    \ [] as [Int])\n/// [] as [Int]\n/// Example 4:\n/// >>> pluck(arr: [5, 0, 3,\
    \ 0, 4, 2])\n/// [0, 1]\n/// Explanation: 0 is the smallest value, but  there\
    \ are two zeros,\n/// so we will choose the first zero, which has the smallest\
    \ index.\n/// Constraints:\n/// * 1 <= nodes.length <= 10000\n/// * 0 <= node.value\n\
    func pluck(arr: [Int]) -> [Int] {\n    var output: [Int] = []\n    var minIndex\
    \ = -1\n    var minValue = Int.max\n    arr.enumerated().forEach { i, e in\n \
    \       if e < minValue && e.isMultiple(of: 2) {\n            minValue = e\n \
    \           minIndex = i\n        }\n    }\n    if minIndex > -1 {\n        output.append(minValue)\n\
    \        output.append(minIndex)\n    }\n    return output\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(pluck(arr: [4, 2, 3]) == [2, 1])\nassert(pluck(arr: [1,\
    \ 2, 3]) == [2, 1])\nassert(pluck(arr: [] as [Int]) == [] as [Int])\nassert(pluck(arr:\
    \ [5, 0, 3, 0, 4, 2]) == [0, 1])\nassert(pluck(arr: [1, 2, 3, 0, 5, 3]) == [0,\
    \ 3])\nassert(pluck(arr: [5, 4, 8, 4, 8]) == [4, 1])\nassert(pluck(arr: [7, 6,\
    \ 7, 1]) == [6, 1])\nassert(pluck(arr: [7, 9, 7, 1]) == [] as [Int])"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660013550
- exit_code: 0
  program: "\n/// \"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n/// your task is to pluck one of the nodes and return it.\n///\
    \ The plucked node should be the node with the smallest even value.\n/// If multiple\
    \ nodes with the same smallest even value are found return the node that has smallest\
    \ index.\n/// The plucked node should be returned in an array, [ smalest_value,\
    \ its index ],\n/// If there are no even values or the given array is empty, return\
    \ [].\n/// Example 1:\n/// >>> pluck(arr: [4, 2, 3])\n/// [2, 1]\n/// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n/// Example 2:\n\
    /// >>> pluck(arr: [1, 2, 3])\n/// [2, 1]\n/// Explanation: 2 has the smallest\
    \ even value, and 2 has the smallest index.\n/// Example 3:\n/// >>> pluck(arr:\
    \ [] as [Int])\n/// [] as [Int]\n/// Example 4:\n/// >>> pluck(arr: [5, 0, 3,\
    \ 0, 4, 2])\n/// [0, 1]\n/// Explanation: 0 is the smallest value, but  there\
    \ are two zeros,\n/// so we will choose the first zero, which has the smallest\
    \ index.\n/// Constraints:\n/// * 1 <= nodes.length <= 10000\n/// * 0 <= node.value\n\
    func pluck(arr: [Int]) -> [Int] {\n    var finalArr = [Int]()\n    let evenArr\
    \ = arr.filter { (num) -> Bool in\n        num % 2 == 0\n    }\n    if evenArr.count\
    \ > 0 {\n        let leastEven = evenArr.sorted().first!\n        if let index\
    \ = arr.firstIndex(of: leastEven) {\n            finalArr.append(leastEven)\n\
    \            finalArr.append(index)\n        }\n    }\n    return finalArr\n}\n\
    \n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(pluck(arr: [4, 2, 3]) == [2, 1])\nassert(pluck(arr:\
    \ [1, 2, 3]) == [2, 1])\nassert(pluck(arr: [] as [Int]) == [] as [Int])\nassert(pluck(arr:\
    \ [5, 0, 3, 0, 4, 2]) == [0, 1])\nassert(pluck(arr: [1, 2, 3, 0, 5, 3]) == [0,\
    \ 3])\nassert(pluck(arr: [5, 4, 8, 4, 8]) == [4, 1])\nassert(pluck(arr: [7, 6,\
    \ 7, 1]) == [6, 1])\nassert(pluck(arr: [7, 9, 7, 1]) == [] as [Int])"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660013550
- exit_code: 0
  program: "\n/// \"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n/// your task is to pluck one of the nodes and return it.\n///\
    \ The plucked node should be the node with the smallest even value.\n/// If multiple\
    \ nodes with the same smallest even value are found return the node that has smallest\
    \ index.\n/// The plucked node should be returned in an array, [ smalest_value,\
    \ its index ],\n/// If there are no even values or the given array is empty, return\
    \ [].\n/// Example 1:\n/// >>> pluck(arr: [4, 2, 3])\n/// [2, 1]\n/// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n/// Example 2:\n\
    /// >>> pluck(arr: [1, 2, 3])\n/// [2, 1]\n/// Explanation: 2 has the smallest\
    \ even value, and 2 has the smallest index.\n/// Example 3:\n/// >>> pluck(arr:\
    \ [] as [Int])\n/// [] as [Int]\n/// Example 4:\n/// >>> pluck(arr: [5, 0, 3,\
    \ 0, 4, 2])\n/// [0, 1]\n/// Explanation: 0 is the smallest value, but  there\
    \ are two zeros,\n/// so we will choose the first zero, which has the smallest\
    \ index.\n/// Constraints:\n/// * 1 <= nodes.length <= 10000\n/// * 0 <= node.value\n\
    func pluck(arr: [Int]) -> [Int] {\n    let z = arr.filter { $0 % 2 == 0 }\n  \
    \  guard let r = z.min() else { return [] }\n    return [r, arr.firstIndex(of:\
    \ r)!]\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n  \
    \  if left.count != right.count {\n        return false\n    }\n    for (l, r)\
    \ in zip(left, right) {\n        if l != r {\n            return false\n     \
    \   }\n    }\n    return true\n}\n            \nassert(pluck(arr: [4, 2, 3]) ==\
    \ [2, 1])\nassert(pluck(arr: [1, 2, 3]) == [2, 1])\nassert(pluck(arr: [] as [Int])\
    \ == [] as [Int])\nassert(pluck(arr: [5, 0, 3, 0, 4, 2]) == [0, 1])\nassert(pluck(arr:\
    \ [1, 2, 3, 0, 5, 3]) == [0, 3])\nassert(pluck(arr: [5, 4, 8, 4, 8]) == [4, 1])\n\
    assert(pluck(arr: [7, 6, 7, 1]) == [6, 1])\nassert(pluck(arr: [7, 9, 7, 1]) ==\
    \ [] as [Int])"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660013550
- exit_code: 0
  program: "\n/// \"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n/// your task is to pluck one of the nodes and return it.\n///\
    \ The plucked node should be the node with the smallest even value.\n/// If multiple\
    \ nodes with the same smallest even value are found return the node that has smallest\
    \ index.\n/// The plucked node should be returned in an array, [ smalest_value,\
    \ its index ],\n/// If there are no even values or the given array is empty, return\
    \ [].\n/// Example 1:\n/// >>> pluck(arr: [4, 2, 3])\n/// [2, 1]\n/// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n/// Example 2:\n\
    /// >>> pluck(arr: [1, 2, 3])\n/// [2, 1]\n/// Explanation: 2 has the smallest\
    \ even value, and 2 has the smallest index.\n/// Example 3:\n/// >>> pluck(arr:\
    \ [] as [Int])\n/// [] as [Int]\n/// Example 4:\n/// >>> pluck(arr: [5, 0, 3,\
    \ 0, 4, 2])\n/// [0, 1]\n/// Explanation: 0 is the smallest value, but  there\
    \ are two zeros,\n/// so we will choose the first zero, which has the smallest\
    \ index.\n/// Constraints:\n/// * 1 <= nodes.length <= 10000\n/// * 0 <= node.value\n\
    func pluck(arr: [Int]) -> [Int] {\n    var result = [Int]()\n    var evenNumbers\
    \ = [Int]()\n    var evenNumbersIndices = [Int]()\n    var minEvenValue = Int.max\n\
    \    arr.enumerated().forEach { (index, number) in\n        if number % 2 == 0\
    \ {\n            evenNumbers.append(number)\n            evenNumbersIndices.append(index)\n\
    \            if number < minEvenValue {\n                minEvenValue = number\n\
    \            }\n        }\n    }\n    guard evenNumbers.count > 0 else { return\
    \ [] }\n    for (index, number) in evenNumbers.enumerated() {\n        if number\
    \ == minEvenValue {\n            result.append(minEvenValue)\n            result.append(evenNumbersIndices[index])\n\
    \            break\n        }\n    }\n    return result\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(pluck(arr: [4, 2, 3]) == [2, 1])\nassert(pluck(arr: [1,\
    \ 2, 3]) == [2, 1])\nassert(pluck(arr: [] as [Int]) == [] as [Int])\nassert(pluck(arr:\
    \ [5, 0, 3, 0, 4, 2]) == [0, 1])\nassert(pluck(arr: [1, 2, 3, 0, 5, 3]) == [0,\
    \ 3])\nassert(pluck(arr: [5, 4, 8, 4, 8]) == [4, 1])\nassert(pluck(arr: [7, 6,\
    \ 7, 1]) == [6, 1])\nassert(pluck(arr: [7, 9, 7, 1]) == [] as [Int])"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660013550
- exit_code: 1
  program: "\n/// \"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n/// your task is to pluck one of the nodes and return it.\n///\
    \ The plucked node should be the node with the smallest even value.\n/// If multiple\
    \ nodes with the same smallest even value are found return the node that has smallest\
    \ index.\n/// The plucked node should be returned in an array, [ smalest_value,\
    \ its index ],\n/// If there are no even values or the given array is empty, return\
    \ [].\n/// Example 1:\n/// >>> pluck(arr: [4, 2, 3])\n/// [2, 1]\n/// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n/// Example 2:\n\
    /// >>> pluck(arr: [1, 2, 3])\n/// [2, 1]\n/// Explanation: 2 has the smallest\
    \ even value, and 2 has the smallest index.\n/// Example 3:\n/// >>> pluck(arr:\
    \ [] as [Int])\n/// [] as [Int]\n/// Example 4:\n/// >>> pluck(arr: [5, 0, 3,\
    \ 0, 4, 2])\n/// [0, 1]\n/// Explanation: 0 is the smallest value, but  there\
    \ are two zeros,\n/// so we will choose the first zero, which has the smallest\
    \ index.\n/// Constraints:\n/// * 1 <= nodes.length <= 10000\n/// * 0 <= node.value\n\
    func pluck(arr: [Int]) -> [Int] {\n    guard !arr.isEmpty else { return [] }\n\
    \    return arr.enumerated().filter { $0.element % 2 == 0 }.sorted { $0.element\
    \ < $1.element }.first ?? []\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int,\
    \ Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n\
    \    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n          \
    \  return false\n        }\n    }\n    return true\n}\n            \nassert(pluck(arr:\
    \ [4, 2, 3]) == [2, 1])\nassert(pluck(arr: [1, 2, 3]) == [2, 1])\nassert(pluck(arr:\
    \ [] as [Int]) == [] as [Int])\nassert(pluck(arr: [5, 0, 3, 0, 4, 2]) == [0, 1])\n\
    assert(pluck(arr: [1, 2, 3, 0, 5, 3]) == [0, 3])\nassert(pluck(arr: [5, 4, 8,\
    \ 4, 8]) == [4, 1])\nassert(pluck(arr: [7, 6, 7, 1]) == [6, 1])\nassert(pluck(arr:\
    \ [7, 9, 7, 1]) == [] as [Int])"
  status: SyntaxError
  stderr: "/tmp/tmpech74pt4.swift:29:101: error: cannot convert return expression\
    \ of type 'EnumeratedSequence<[Int]>.Iterator.Element' (aka '(offset: Int, element:\
    \ Int)') to return type '[Int]'\n    return arr.enumerated().filter { $0.element\
    \ % 2 == 0 }.sorted { $0.element < $1.element }.first ?? []\n           ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~^~~~~\n\
    /tmp/tmpech74pt4.swift:29:104: error: cannot convert value of type '[Any]' to\
    \ expected argument type 'EnumeratedSequence<[Int]>.Iterator.Element' (aka '(offset:\
    \ Int, element: Int)')\n    return arr.enumerated().filter { $0.element % 2 ==\
    \ 0 }.sorted { $0.element < $1.element }.first ?? []\n                       \
    \                                                                            \
    \    ^\n"
  stdout: ''
  timestamp: 1660013550
- exit_code: 0
  program: "\n/// \"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n/// your task is to pluck one of the nodes and return it.\n///\
    \ The plucked node should be the node with the smallest even value.\n/// If multiple\
    \ nodes with the same smallest even value are found return the node that has smallest\
    \ index.\n/// The plucked node should be returned in an array, [ smalest_value,\
    \ its index ],\n/// If there are no even values or the given array is empty, return\
    \ [].\n/// Example 1:\n/// >>> pluck(arr: [4, 2, 3])\n/// [2, 1]\n/// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n/// Example 2:\n\
    /// >>> pluck(arr: [1, 2, 3])\n/// [2, 1]\n/// Explanation: 2 has the smallest\
    \ even value, and 2 has the smallest index.\n/// Example 3:\n/// >>> pluck(arr:\
    \ [] as [Int])\n/// [] as [Int]\n/// Example 4:\n/// >>> pluck(arr: [5, 0, 3,\
    \ 0, 4, 2])\n/// [0, 1]\n/// Explanation: 0 is the smallest value, but  there\
    \ are two zeros,\n/// so we will choose the first zero, which has the smallest\
    \ index.\n/// Constraints:\n/// * 1 <= nodes.length <= 10000\n/// * 0 <= node.value\n\
    func pluck(arr: [Int]) -> [Int] {\n    if arr.count == 0 {\n        return []\n\
    \    }\n    let evens = arr.filter({ $0 % 2 == 0 })\n    if evens.count == 0 {\n\
    \        return []\n    }\n    let smallestEven = evens.min()!\n    var smallestEvenIndex:\
    \ Int?\n    for (index, val) in arr.enumerated() {\n        if val == smallestEven\
    \ {\n            smallestEvenIndex = index\n            break\n        }\n   \
    \ }\n    if let smallestEvenIndex = smallestEvenIndex {\n        return [smallestEven,\
    \ smallestEvenIndex]\n    }\n    return []\n}\n\n\nfunc ==(left: [(Int, Int)],\
    \ right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n       \
    \ return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r\
    \ {\n            return false\n        }\n    }\n    return true\n}\n        \
    \    \nassert(pluck(arr: [4, 2, 3]) == [2, 1])\nassert(pluck(arr: [1, 2, 3]) ==\
    \ [2, 1])\nassert(pluck(arr: [] as [Int]) == [] as [Int])\nassert(pluck(arr: [5,\
    \ 0, 3, 0, 4, 2]) == [0, 1])\nassert(pluck(arr: [1, 2, 3, 0, 5, 3]) == [0, 3])\n\
    assert(pluck(arr: [5, 4, 8, 4, 8]) == [4, 1])\nassert(pluck(arr: [7, 6, 7, 1])\
    \ == [6, 1])\nassert(pluck(arr: [7, 9, 7, 1]) == [] as [Int])"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660013550
- exit_code: -4
  program: "\n/// \"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n/// your task is to pluck one of the nodes and return it.\n///\
    \ The plucked node should be the node with the smallest even value.\n/// If multiple\
    \ nodes with the same smallest even value are found return the node that has smallest\
    \ index.\n/// The plucked node should be returned in an array, [ smalest_value,\
    \ its index ],\n/// If there are no even values or the given array is empty, return\
    \ [].\n/// Example 1:\n/// >>> pluck(arr: [4, 2, 3])\n/// [2, 1]\n/// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n/// Example 2:\n\
    /// >>> pluck(arr: [1, 2, 3])\n/// [2, 1]\n/// Explanation: 2 has the smallest\
    \ even value, and 2 has the smallest index.\n/// Example 3:\n/// >>> pluck(arr:\
    \ [] as [Int])\n/// [] as [Int]\n/// Example 4:\n/// >>> pluck(arr: [5, 0, 3,\
    \ 0, 4, 2])\n/// [0, 1]\n/// Explanation: 0 is the smallest value, but  there\
    \ are two zeros,\n/// so we will choose the first zero, which has the smallest\
    \ index.\n/// Constraints:\n/// * 1 <= nodes.length <= 10000\n/// * 0 <= node.value\n\
    func pluck(arr: [Int]) -> [Int] {\n    var evenArr = [Int]()\n    var indexArr\
    \ = [Int]()\n    var smallestEvenIndex = 0\n    var smallestEvenValue = 0\n  \
    \  for (index, element) in arr.enumerated() {\n        if element % 2 == 0 {\n\
    \            evenArr.append(element)\n            indexArr.append(index)\n   \
    \     }\n    }\n    if evenArr.count != 0 {\n        evenArr.sort()\n        indexArr.sort()\n\
    \        smallestEvenValue = evenArr[0]\n        smallestEvenIndex = indexArr[0]\n\
    \    }\n    return [smallestEvenValue, smallestEvenIndex]\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(pluck(arr: [4, 2, 3]) == [2, 1])\nassert(pluck(arr: [1,\
    \ 2, 3]) == [2, 1])\nassert(pluck(arr: [] as [Int]) == [] as [Int])\nassert(pluck(arr:\
    \ [5, 0, 3, 0, 4, 2]) == [0, 1])\nassert(pluck(arr: [1, 2, 3, 0, 5, 3]) == [0,\
    \ 3])\nassert(pluck(arr: [5, 4, 8, 4, 8]) == [4, 1])\nassert(pluck(arr: [7, 6,\
    \ 7, 1]) == [6, 1])\nassert(pluck(arr: [7, 9, 7, 1]) == [] as [Int])"
  status: Exception
  stderr: 'tmpavj0inu4/tmpavj0inu4.swift:60: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b683b02fc80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b683ad26b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b683ad26988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b683ad257b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpavj0inu4                        0x0000555f717718ec <unavailable> + 6380

    5    libc.so.6                          0x00002b683b21b460 __libc_start_main +
    245

    6    tmpavj0inu4                        0x0000555f717714f9 <unavailable> + 5369

    '
  stdout: ''
  timestamp: 1660013550
- exit_code: 0
  program: "\n/// \"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n/// your task is to pluck one of the nodes and return it.\n///\
    \ The plucked node should be the node with the smallest even value.\n/// If multiple\
    \ nodes with the same smallest even value are found return the node that has smallest\
    \ index.\n/// The plucked node should be returned in an array, [ smalest_value,\
    \ its index ],\n/// If there are no even values or the given array is empty, return\
    \ [].\n/// Example 1:\n/// >>> pluck(arr: [4, 2, 3])\n/// [2, 1]\n/// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n/// Example 2:\n\
    /// >>> pluck(arr: [1, 2, 3])\n/// [2, 1]\n/// Explanation: 2 has the smallest\
    \ even value, and 2 has the smallest index.\n/// Example 3:\n/// >>> pluck(arr:\
    \ [] as [Int])\n/// [] as [Int]\n/// Example 4:\n/// >>> pluck(arr: [5, 0, 3,\
    \ 0, 4, 2])\n/// [0, 1]\n/// Explanation: 0 is the smallest value, but  there\
    \ are two zeros,\n/// so we will choose the first zero, which has the smallest\
    \ index.\n/// Constraints:\n/// * 1 <= nodes.length <= 10000\n/// * 0 <= node.value\n\
    func pluck(arr: [Int]) -> [Int] {\n    var evens = arr.filter { $0 % 2 == 0 }\n\
    \    if evens.isEmpty { return [] }\n    evens.sort()\n    let minEven = evens[0]\n\
    \    let index = arr.firstIndex(of: minEven)!\n    return [minEven, index]\n}\n\
    \n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(pluck(arr: [4, 2, 3]) == [2, 1])\nassert(pluck(arr:\
    \ [1, 2, 3]) == [2, 1])\nassert(pluck(arr: [] as [Int]) == [] as [Int])\nassert(pluck(arr:\
    \ [5, 0, 3, 0, 4, 2]) == [0, 1])\nassert(pluck(arr: [1, 2, 3, 0, 5, 3]) == [0,\
    \ 3])\nassert(pluck(arr: [5, 4, 8, 4, 8]) == [4, 1])\nassert(pluck(arr: [7, 6,\
    \ 7, 1]) == [6, 1])\nassert(pluck(arr: [7, 9, 7, 1]) == [] as [Int])"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660013550
- exit_code: 0
  program: "\n/// \"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n/// your task is to pluck one of the nodes and return it.\n///\
    \ The plucked node should be the node with the smallest even value.\n/// If multiple\
    \ nodes with the same smallest even value are found return the node that has smallest\
    \ index.\n/// The plucked node should be returned in an array, [ smalest_value,\
    \ its index ],\n/// If there are no even values or the given array is empty, return\
    \ [].\n/// Example 1:\n/// >>> pluck(arr: [4, 2, 3])\n/// [2, 1]\n/// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n/// Example 2:\n\
    /// >>> pluck(arr: [1, 2, 3])\n/// [2, 1]\n/// Explanation: 2 has the smallest\
    \ even value, and 2 has the smallest index.\n/// Example 3:\n/// >>> pluck(arr:\
    \ [] as [Int])\n/// [] as [Int]\n/// Example 4:\n/// >>> pluck(arr: [5, 0, 3,\
    \ 0, 4, 2])\n/// [0, 1]\n/// Explanation: 0 is the smallest value, but  there\
    \ are two zeros,\n/// so we will choose the first zero, which has the smallest\
    \ index.\n/// Constraints:\n/// * 1 <= nodes.length <= 10000\n/// * 0 <= node.value\n\
    func pluck(arr: [Int]) -> [Int] {\n    var evens = [Int]()\n    for (index, item)\
    \ in arr.enumerated() {\n        if item % 2 == 0 {\n            evens.append(item)\n\
    \        }\n    }\n    guard let smallest = evens.min() else { return [] }\n \
    \   let items = arr.enumerated().filter({ $0.element == smallest })\n    return\
    \ [smallest, items.first!.offset]\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int,\
    \ Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n\
    \    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n          \
    \  return false\n        }\n    }\n    return true\n}\n            \nassert(pluck(arr:\
    \ [4, 2, 3]) == [2, 1])\nassert(pluck(arr: [1, 2, 3]) == [2, 1])\nassert(pluck(arr:\
    \ [] as [Int]) == [] as [Int])\nassert(pluck(arr: [5, 0, 3, 0, 4, 2]) == [0, 1])\n\
    assert(pluck(arr: [1, 2, 3, 0, 5, 3]) == [0, 3])\nassert(pluck(arr: [5, 4, 8,\
    \ 4, 8]) == [4, 1])\nassert(pluck(arr: [7, 6, 7, 1]) == [6, 1])\nassert(pluck(arr:\
    \ [7, 9, 7, 1]) == [] as [Int])"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660013550
- exit_code: 0
  program: "\n/// \"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n/// your task is to pluck one of the nodes and return it.\n///\
    \ The plucked node should be the node with the smallest even value.\n/// If multiple\
    \ nodes with the same smallest even value are found return the node that has smallest\
    \ index.\n/// The plucked node should be returned in an array, [ smalest_value,\
    \ its index ],\n/// If there are no even values or the given array is empty, return\
    \ [].\n/// Example 1:\n/// >>> pluck(arr: [4, 2, 3])\n/// [2, 1]\n/// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n/// Example 2:\n\
    /// >>> pluck(arr: [1, 2, 3])\n/// [2, 1]\n/// Explanation: 2 has the smallest\
    \ even value, and 2 has the smallest index.\n/// Example 3:\n/// >>> pluck(arr:\
    \ [] as [Int])\n/// [] as [Int]\n/// Example 4:\n/// >>> pluck(arr: [5, 0, 3,\
    \ 0, 4, 2])\n/// [0, 1]\n/// Explanation: 0 is the smallest value, but  there\
    \ are two zeros,\n/// so we will choose the first zero, which has the smallest\
    \ index.\n/// Constraints:\n/// * 1 <= nodes.length <= 10000\n/// * 0 <= node.value\n\
    func pluck(arr: [Int]) -> [Int] {\n    guard !arr.isEmpty else { return [] }\n\
    \    guard let smallestEven = arr.sorted().filter({ $0 % 2 == 0 }).first else\
    \ { return [] }\n    return [smallestEven, arr.firstIndex(of: smallestEven)!]\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(pluck(arr: [4, 2, 3]) == [2, 1])\nassert(pluck(arr:\
    \ [1, 2, 3]) == [2, 1])\nassert(pluck(arr: [] as [Int]) == [] as [Int])\nassert(pluck(arr:\
    \ [5, 0, 3, 0, 4, 2]) == [0, 1])\nassert(pluck(arr: [1, 2, 3, 0, 5, 3]) == [0,\
    \ 3])\nassert(pluck(arr: [5, 4, 8, 4, 8]) == [4, 1])\nassert(pluck(arr: [7, 6,\
    \ 7, 1]) == [6, 1])\nassert(pluck(arr: [7, 9, 7, 1]) == [] as [Int])"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660013550
- exit_code: -4
  program: "\n/// \"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n/// your task is to pluck one of the nodes and return it.\n///\
    \ The plucked node should be the node with the smallest even value.\n/// If multiple\
    \ nodes with the same smallest even value are found return the node that has smallest\
    \ index.\n/// The plucked node should be returned in an array, [ smalest_value,\
    \ its index ],\n/// If there are no even values or the given array is empty, return\
    \ [].\n/// Example 1:\n/// >>> pluck(arr: [4, 2, 3])\n/// [2, 1]\n/// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n/// Example 2:\n\
    /// >>> pluck(arr: [1, 2, 3])\n/// [2, 1]\n/// Explanation: 2 has the smallest\
    \ even value, and 2 has the smallest index.\n/// Example 3:\n/// >>> pluck(arr:\
    \ [] as [Int])\n/// [] as [Int]\n/// Example 4:\n/// >>> pluck(arr: [5, 0, 3,\
    \ 0, 4, 2])\n/// [0, 1]\n/// Explanation: 0 is the smallest value, but  there\
    \ are two zeros,\n/// so we will choose the first zero, which has the smallest\
    \ index.\n/// Constraints:\n/// * 1 <= nodes.length <= 10000\n/// * 0 <= node.value\n\
    func pluck(arr: [Int]) -> [Int] {\n    return []\n}\n\n\nfunc ==(left: [(Int,\
    \ Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n\
    \        return false\n    }\n    for (l, r) in zip(left, right) {\n        if\
    \ l != r {\n            return false\n        }\n    }\n    return true\n}\n \
    \           \nassert(pluck(arr: [4, 2, 3]) == [2, 1])\nassert(pluck(arr: [1, 2,\
    \ 3]) == [2, 1])\nassert(pluck(arr: [] as [Int]) == [] as [Int])\nassert(pluck(arr:\
    \ [5, 0, 3, 0, 4, 2]) == [0, 1])\nassert(pluck(arr: [1, 2, 3, 0, 5, 3]) == [0,\
    \ 3])\nassert(pluck(arr: [5, 4, 8, 4, 8]) == [4, 1])\nassert(pluck(arr: [7, 6,\
    \ 7, 1]) == [6, 1])\nassert(pluck(arr: [7, 9, 7, 1]) == [] as [Int])"
  status: Exception
  stderr: 'tmpgh8dpvxh/tmpgh8dpvxh.swift:44: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002ac906ec4c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002ac906bbbb6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002ac906bbb988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002ac906bba7b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpgh8dpvxh                        0x00005578e3d9c3bc <unavailable> + 5052

    5    libc.so.6                          0x00002ac9070b0460 __libc_start_main +
    245

    6    tmpgh8dpvxh                        0x00005578e3d9bfc9 <unavailable> + 4041

    '
  stdout: ''
  timestamp: 1660013365
- exit_code: -4
  program: "\n/// \"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n/// your task is to pluck one of the nodes and return it.\n///\
    \ The plucked node should be the node with the smallest even value.\n/// If multiple\
    \ nodes with the same smallest even value are found return the node that has smallest\
    \ index.\n/// The plucked node should be returned in an array, [ smalest_value,\
    \ its index ],\n/// If there are no even values or the given array is empty, return\
    \ [].\n/// Example 1:\n/// >>> pluck(arr: [4, 2, 3])\n/// [2, 1]\n/// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n/// Example 2:\n\
    /// >>> pluck(arr: [1, 2, 3])\n/// [2, 1]\n/// Explanation: 2 has the smallest\
    \ even value, and 2 has the smallest index.\n/// Example 3:\n/// >>> pluck(arr:\
    \ [] as [Int])\n/// [] as [Int]\n/// Example 4:\n/// >>> pluck(arr: [5, 0, 3,\
    \ 0, 4, 2])\n/// [0, 1]\n/// Explanation: 0 is the smallest value, but  there\
    \ are two zeros,\n/// so we will choose the first zero, which has the smallest\
    \ index.\n/// Constraints:\n/// * 1 <= nodes.length <= 10000\n/// * 0 <= node.value\n\
    func pluck(arr: [Int]) -> [Int] {\n    let even = arr.filter { $0 % 2 == 0 }\n\
    \    if even.isEmpty { return [] }\n    var index = -1\n    let value = even.reduce(arr.first!)\
    \ { if $0 < $1 { return $0 } else { index = arr.firstIndex(of: $1)!; return $1\
    \ } }\n    return [value, index]\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int,\
    \ Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n\
    \    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n          \
    \  return false\n        }\n    }\n    return true\n}\n            \nassert(pluck(arr:\
    \ [4, 2, 3]) == [2, 1])\nassert(pluck(arr: [1, 2, 3]) == [2, 1])\nassert(pluck(arr:\
    \ [] as [Int]) == [] as [Int])\nassert(pluck(arr: [5, 0, 3, 0, 4, 2]) == [0, 1])\n\
    assert(pluck(arr: [1, 2, 3, 0, 5, 3]) == [0, 3])\nassert(pluck(arr: [5, 4, 8,\
    \ 4, 8]) == [4, 1])\nassert(pluck(arr: [7, 6, 7, 1]) == [6, 1])\nassert(pluck(arr:\
    \ [7, 9, 7, 1]) == [] as [Int])"
  status: Exception
  stderr: 'tmpy3i_pre_/tmpy3i_pre_.swift:49: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b29db2a0c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b29daf97b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b29daf97988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b29daf967b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpy3i_pre_                        0x00005597b167a81b <unavailable> + 6171

    5    libc.so.6                          0x00002b29db48c460 __libc_start_main +
    245

    6    tmpy3i_pre_                        0x00005597b167a309 <unavailable> + 4873

    '
  stdout: ''
  timestamp: 1660013550
- exit_code: 1
  program: "\n/// \"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n/// your task is to pluck one of the nodes and return it.\n///\
    \ The plucked node should be the node with the smallest even value.\n/// If multiple\
    \ nodes with the same smallest even value are found return the node that has smallest\
    \ index.\n/// The plucked node should be returned in an array, [ smalest_value,\
    \ its index ],\n/// If there are no even values or the given array is empty, return\
    \ [].\n/// Example 1:\n/// >>> pluck(arr: [4, 2, 3])\n/// [2, 1]\n/// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n/// Example 2:\n\
    /// >>> pluck(arr: [1, 2, 3])\n/// [2, 1]\n/// Explanation: 2 has the smallest\
    \ even value, and 2 has the smallest index.\n/// Example 3:\n/// >>> pluck(arr:\
    \ [] as [Int])\n/// [] as [Int]\n/// Example 4:\n/// >>> pluck(arr: [5, 0, 3,\
    \ 0, 4, 2])\n/// [0, 1]\n/// Explanation: 0 is the smallest value, but  there\
    \ are two zeros,\n/// so we will choose the first zero, which has the smallest\
    \ index.\n/// Constraints:\n/// * 1 <= nodes.length <= 10000\n/// * 0 <= node.value\n\
    func pluck(arr: [Int]) -> [Int] {\n    guard arr.count > 0 else { return [] }\n\
    \    var minEven = Int.max\n    var minEvenIndex = 0\n    var found = false\n\
    \    for (index, value) in arr.enumerated() {\n        if value.isEven && value\
    \ < minEven {\n            minEven = value\n            minEvenIndex = index\n\
    \            found = true\n        }\n    }\n    if found {\n        return [minEven,\
    \ minEvenIndex]\n    } else {\n        return []\n    }\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(pluck(arr: [4, 2, 3]) == [2, 1])\nassert(pluck(arr: [1,\
    \ 2, 3]) == [2, 1])\nassert(pluck(arr: [] as [Int]) == [] as [Int])\nassert(pluck(arr:\
    \ [5, 0, 3, 0, 4, 2]) == [0, 1])\nassert(pluck(arr: [1, 2, 3, 0, 5, 3]) == [0,\
    \ 3])\nassert(pluck(arr: [5, 4, 8, 4, 8]) == [4, 1])\nassert(pluck(arr: [7, 6,\
    \ 7, 1]) == [6, 1])\nassert(pluck(arr: [7, 9, 7, 1]) == [] as [Int])"
  status: SyntaxError
  stderr: "/tmp/tmpk14yaqzl.swift:33:18: error: value of type 'Int' has no member\
    \ 'isEven'\n        if value.isEven && value < minEven {\n           ~~~~~ ^~~~~~\n"
  stdout: ''
  timestamp: 1660013550
- exit_code: 0
  program: "\n/// \"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n/// your task is to pluck one of the nodes and return it.\n///\
    \ The plucked node should be the node with the smallest even value.\n/// If multiple\
    \ nodes with the same smallest even value are found return the node that has smallest\
    \ index.\n/// The plucked node should be returned in an array, [ smalest_value,\
    \ its index ],\n/// If there are no even values or the given array is empty, return\
    \ [].\n/// Example 1:\n/// >>> pluck(arr: [4, 2, 3])\n/// [2, 1]\n/// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n/// Example 2:\n\
    /// >>> pluck(arr: [1, 2, 3])\n/// [2, 1]\n/// Explanation: 2 has the smallest\
    \ even value, and 2 has the smallest index.\n/// Example 3:\n/// >>> pluck(arr:\
    \ [] as [Int])\n/// [] as [Int]\n/// Example 4:\n/// >>> pluck(arr: [5, 0, 3,\
    \ 0, 4, 2])\n/// [0, 1]\n/// Explanation: 0 is the smallest value, but  there\
    \ are two zeros,\n/// so we will choose the first zero, which has the smallest\
    \ index.\n/// Constraints:\n/// * 1 <= nodes.length <= 10000\n/// * 0 <= node.value\n\
    func pluck(arr: [Int]) -> [Int] {\n    guard arr.count > 0 else { return [] }\n\
    \    var result = [Int]()\n    var evens = [Int]()\n    var evenIndex = [Int]()\n\
    \    for (index, item) in arr.enumerated() {\n        if item % 2 == 0 {\n   \
    \         evens.append(item)\n            evenIndex.append(index)\n        }\n\
    \    }\n    if evens.count > 0 {\n        let minEven = evens.min()!\n       \
    \ let minEvenIndex = evenIndex[evens.firstIndex(of: minEven)!]\n        result.append(minEven)\n\
    \        result.append(minEvenIndex)\n    }\n    return result\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(pluck(arr: [4, 2, 3]) == [2, 1])\nassert(pluck(arr: [1,\
    \ 2, 3]) == [2, 1])\nassert(pluck(arr: [] as [Int]) == [] as [Int])\nassert(pluck(arr:\
    \ [5, 0, 3, 0, 4, 2]) == [0, 1])\nassert(pluck(arr: [1, 2, 3, 0, 5, 3]) == [0,\
    \ 3])\nassert(pluck(arr: [5, 4, 8, 4, 8]) == [4, 1])\nassert(pluck(arr: [7, 6,\
    \ 7, 1]) == [6, 1])\nassert(pluck(arr: [7, 9, 7, 1]) == [] as [Int])"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660013550
- exit_code: 0
  program: "\n/// \"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n/// your task is to pluck one of the nodes and return it.\n///\
    \ The plucked node should be the node with the smallest even value.\n/// If multiple\
    \ nodes with the same smallest even value are found return the node that has smallest\
    \ index.\n/// The plucked node should be returned in an array, [ smalest_value,\
    \ its index ],\n/// If there are no even values or the given array is empty, return\
    \ [].\n/// Example 1:\n/// >>> pluck(arr: [4, 2, 3])\n/// [2, 1]\n/// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n/// Example 2:\n\
    /// >>> pluck(arr: [1, 2, 3])\n/// [2, 1]\n/// Explanation: 2 has the smallest\
    \ even value, and 2 has the smallest index.\n/// Example 3:\n/// >>> pluck(arr:\
    \ [] as [Int])\n/// [] as [Int]\n/// Example 4:\n/// >>> pluck(arr: [5, 0, 3,\
    \ 0, 4, 2])\n/// [0, 1]\n/// Explanation: 0 is the smallest value, but  there\
    \ are two zeros,\n/// so we will choose the first zero, which has the smallest\
    \ index.\n/// Constraints:\n/// * 1 <= nodes.length <= 10000\n/// * 0 <= node.value\n\
    func pluck(arr: [Int]) -> [Int] {\n    if arr.isEmpty {\n        return []\n \
    \   }\n    if let smallestEven = arr.filter({ $0 % 2 == 0 }).min() {\n       \
    \ return [smallestEven, arr.firstIndex(of: smallestEven)!]\n    }\n    return\
    \ []\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if\
    \ left.count != right.count {\n        return false\n    }\n    for (l, r) in\
    \ zip(left, right) {\n        if l != r {\n            return false\n        }\n\
    \    }\n    return true\n}\n            \nassert(pluck(arr: [4, 2, 3]) == [2,\
    \ 1])\nassert(pluck(arr: [1, 2, 3]) == [2, 1])\nassert(pluck(arr: [] as [Int])\
    \ == [] as [Int])\nassert(pluck(arr: [5, 0, 3, 0, 4, 2]) == [0, 1])\nassert(pluck(arr:\
    \ [1, 2, 3, 0, 5, 3]) == [0, 3])\nassert(pluck(arr: [5, 4, 8, 4, 8]) == [4, 1])\n\
    assert(pluck(arr: [7, 6, 7, 1]) == [6, 1])\nassert(pluck(arr: [7, 9, 7, 1]) ==\
    \ [] as [Int])"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660013550
- exit_code: 0
  program: "\n/// \"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n/// your task is to pluck one of the nodes and return it.\n///\
    \ The plucked node should be the node with the smallest even value.\n/// If multiple\
    \ nodes with the same smallest even value are found return the node that has smallest\
    \ index.\n/// The plucked node should be returned in an array, [ smalest_value,\
    \ its index ],\n/// If there are no even values or the given array is empty, return\
    \ [].\n/// Example 1:\n/// >>> pluck(arr: [4, 2, 3])\n/// [2, 1]\n/// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n/// Example 2:\n\
    /// >>> pluck(arr: [1, 2, 3])\n/// [2, 1]\n/// Explanation: 2 has the smallest\
    \ even value, and 2 has the smallest index.\n/// Example 3:\n/// >>> pluck(arr:\
    \ [] as [Int])\n/// [] as [Int]\n/// Example 4:\n/// >>> pluck(arr: [5, 0, 3,\
    \ 0, 4, 2])\n/// [0, 1]\n/// Explanation: 0 is the smallest value, but  there\
    \ are two zeros,\n/// so we will choose the first zero, which has the smallest\
    \ index.\n/// Constraints:\n/// * 1 <= nodes.length <= 10000\n/// * 0 <= node.value\n\
    func pluck(arr: [Int]) -> [Int] {\n    let evens = arr.filter { $0 % 2 == 0 }\n\
    \    if let min = evens.min() {\n        let index = arr.firstIndex(of: min) ??\
    \ 0\n        return [min, index]\n    }\n    return []\n}\n\n\nfunc ==(left: [(Int,\
    \ Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n\
    \        return false\n    }\n    for (l, r) in zip(left, right) {\n        if\
    \ l != r {\n            return false\n        }\n    }\n    return true\n}\n \
    \           \nassert(pluck(arr: [4, 2, 3]) == [2, 1])\nassert(pluck(arr: [1, 2,\
    \ 3]) == [2, 1])\nassert(pluck(arr: [] as [Int]) == [] as [Int])\nassert(pluck(arr:\
    \ [5, 0, 3, 0, 4, 2]) == [0, 1])\nassert(pluck(arr: [1, 2, 3, 0, 5, 3]) == [0,\
    \ 3])\nassert(pluck(arr: [5, 4, 8, 4, 8]) == [4, 1])\nassert(pluck(arr: [7, 6,\
    \ 7, 1]) == [6, 1])\nassert(pluck(arr: [7, 9, 7, 1]) == [] as [Int])"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660013550
- exit_code: 0
  program: "\n/// \"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n/// your task is to pluck one of the nodes and return it.\n///\
    \ The plucked node should be the node with the smallest even value.\n/// If multiple\
    \ nodes with the same smallest even value are found return the node that has smallest\
    \ index.\n/// The plucked node should be returned in an array, [ smalest_value,\
    \ its index ],\n/// If there are no even values or the given array is empty, return\
    \ [].\n/// Example 1:\n/// >>> pluck(arr: [4, 2, 3])\n/// [2, 1]\n/// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n/// Example 2:\n\
    /// >>> pluck(arr: [1, 2, 3])\n/// [2, 1]\n/// Explanation: 2 has the smallest\
    \ even value, and 2 has the smallest index.\n/// Example 3:\n/// >>> pluck(arr:\
    \ [] as [Int])\n/// [] as [Int]\n/// Example 4:\n/// >>> pluck(arr: [5, 0, 3,\
    \ 0, 4, 2])\n/// [0, 1]\n/// Explanation: 0 is the smallest value, but  there\
    \ are two zeros,\n/// so we will choose the first zero, which has the smallest\
    \ index.\n/// Constraints:\n/// * 1 <= nodes.length <= 10000\n/// * 0 <= node.value\n\
    func pluck(arr: [Int]) -> [Int] {\n    guard arr.contains(where: { $0 % 2 == 0\
    \ }) else { return [] }\n    var first = 0\n    var second = 0\n    for (i, value)\
    \ in arr.enumerated() {\n        if value % 2 == 0 {\n            first = value\n\
    \            second = i\n            break\n        }\n    }\n    for (i, value)\
    \ in arr.enumerated() {\n        if value % 2 == 0, value < first {\n        \
    \    first = value\n            second = i\n        }\n    }\n    return [first,\
    \ second]\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n\
    \    if left.count != right.count {\n        return false\n    }\n    for (l,\
    \ r) in zip(left, right) {\n        if l != r {\n            return false\n  \
    \      }\n    }\n    return true\n}\n            \nassert(pluck(arr: [4, 2, 3])\
    \ == [2, 1])\nassert(pluck(arr: [1, 2, 3]) == [2, 1])\nassert(pluck(arr: [] as\
    \ [Int]) == [] as [Int])\nassert(pluck(arr: [5, 0, 3, 0, 4, 2]) == [0, 1])\nassert(pluck(arr:\
    \ [1, 2, 3, 0, 5, 3]) == [0, 3])\nassert(pluck(arr: [5, 4, 8, 4, 8]) == [4, 1])\n\
    assert(pluck(arr: [7, 6, 7, 1]) == [6, 1])\nassert(pluck(arr: [7, 9, 7, 1]) ==\
    \ [] as [Int])"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660013550
- exit_code: 0
  program: "\n/// \"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n/// your task is to pluck one of the nodes and return it.\n///\
    \ The plucked node should be the node with the smallest even value.\n/// If multiple\
    \ nodes with the same smallest even value are found return the node that has smallest\
    \ index.\n/// The plucked node should be returned in an array, [ smalest_value,\
    \ its index ],\n/// If there are no even values or the given array is empty, return\
    \ [].\n/// Example 1:\n/// >>> pluck(arr: [4, 2, 3])\n/// [2, 1]\n/// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n/// Example 2:\n\
    /// >>> pluck(arr: [1, 2, 3])\n/// [2, 1]\n/// Explanation: 2 has the smallest\
    \ even value, and 2 has the smallest index.\n/// Example 3:\n/// >>> pluck(arr:\
    \ [] as [Int])\n/// [] as [Int]\n/// Example 4:\n/// >>> pluck(arr: [5, 0, 3,\
    \ 0, 4, 2])\n/// [0, 1]\n/// Explanation: 0 is the smallest value, but  there\
    \ are two zeros,\n/// so we will choose the first zero, which has the smallest\
    \ index.\n/// Constraints:\n/// * 1 <= nodes.length <= 10000\n/// * 0 <= node.value\n\
    func pluck(arr: [Int]) -> [Int] {\n    return arr.enumerated().filter { $0.element\
    \ % 2 == 0 }.min {\n        $0.element < $1.element\n    }.map { [$0.element,\
    \ $0.offset] } ?? []\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(pluck(arr:\
    \ [4, 2, 3]) == [2, 1])\nassert(pluck(arr: [1, 2, 3]) == [2, 1])\nassert(pluck(arr:\
    \ [] as [Int]) == [] as [Int])\nassert(pluck(arr: [5, 0, 3, 0, 4, 2]) == [0, 1])\n\
    assert(pluck(arr: [1, 2, 3, 0, 5, 3]) == [0, 3])\nassert(pluck(arr: [5, 4, 8,\
    \ 4, 8]) == [4, 1])\nassert(pluck(arr: [7, 6, 7, 1]) == [6, 1])\nassert(pluck(arr:\
    \ [7, 9, 7, 1]) == [] as [Int])"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660013550
- exit_code: 0
  program: "\n/// \"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n/// your task is to pluck one of the nodes and return it.\n///\
    \ The plucked node should be the node with the smallest even value.\n/// If multiple\
    \ nodes with the same smallest even value are found return the node that has smallest\
    \ index.\n/// The plucked node should be returned in an array, [ smalest_value,\
    \ its index ],\n/// If there are no even values or the given array is empty, return\
    \ [].\n/// Example 1:\n/// >>> pluck(arr: [4, 2, 3])\n/// [2, 1]\n/// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n/// Example 2:\n\
    /// >>> pluck(arr: [1, 2, 3])\n/// [2, 1]\n/// Explanation: 2 has the smallest\
    \ even value, and 2 has the smallest index.\n/// Example 3:\n/// >>> pluck(arr:\
    \ [] as [Int])\n/// [] as [Int]\n/// Example 4:\n/// >>> pluck(arr: [5, 0, 3,\
    \ 0, 4, 2])\n/// [0, 1]\n/// Explanation: 0 is the smallest value, but  there\
    \ are two zeros,\n/// so we will choose the first zero, which has the smallest\
    \ index.\n/// Constraints:\n/// * 1 <= nodes.length <= 10000\n/// * 0 <= node.value\n\
    func pluck(arr: [Int]) -> [Int] {\n    var smallestNode: [Int] = []\n    for n\
    \ in arr {\n        if n % 2 == 0 && (smallestNode.isEmpty || n < smallestNode[0])\
    \ {\n            smallestNode = [n, arr.firstIndex(of: n)!]\n        }\n    }\n\
    \    return smallestNode\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(pluck(arr:\
    \ [4, 2, 3]) == [2, 1])\nassert(pluck(arr: [1, 2, 3]) == [2, 1])\nassert(pluck(arr:\
    \ [] as [Int]) == [] as [Int])\nassert(pluck(arr: [5, 0, 3, 0, 4, 2]) == [0, 1])\n\
    assert(pluck(arr: [1, 2, 3, 0, 5, 3]) == [0, 3])\nassert(pluck(arr: [5, 4, 8,\
    \ 4, 8]) == [4, 1])\nassert(pluck(arr: [7, 6, 7, 1]) == [6, 1])\nassert(pluck(arr:\
    \ [7, 9, 7, 1]) == [] as [Int])"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660013550
- exit_code: -4
  program: "\n/// \"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n/// your task is to pluck one of the nodes and return it.\n///\
    \ The plucked node should be the node with the smallest even value.\n/// If multiple\
    \ nodes with the same smallest even value are found return the node that has smallest\
    \ index.\n/// The plucked node should be returned in an array, [ smalest_value,\
    \ its index ],\n/// If there are no even values or the given array is empty, return\
    \ [].\n/// Example 1:\n/// >>> pluck(arr: [4, 2, 3])\n/// [2, 1]\n/// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n/// Example 2:\n\
    /// >>> pluck(arr: [1, 2, 3])\n/// [2, 1]\n/// Explanation: 2 has the smallest\
    \ even value, and 2 has the smallest index.\n/// Example 3:\n/// >>> pluck(arr:\
    \ [] as [Int])\n/// [] as [Int]\n/// Example 4:\n/// >>> pluck(arr: [5, 0, 3,\
    \ 0, 4, 2])\n/// [0, 1]\n/// Explanation: 0 is the smallest value, but  there\
    \ are two zeros,\n/// so we will choose the first zero, which has the smallest\
    \ index.\n/// Constraints:\n/// * 1 <= nodes.length <= 10000\n/// * 0 <= node.value\n\
    func pluck(arr: [Int]) -> [Int] {\n    // your code here\n    if arr.count ==\
    \ 0 {\n        return []\n    }\n    if let firstEven = arr.filter({$0 % 2 ==\
    \ 0}).first {\n        let index = arr.firstIndex(of: firstEven)\n        return\
    \ [firstEven, index!]\n    }\n    return []\n}\n\n\nfunc ==(left: [(Int, Int)],\
    \ right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n       \
    \ return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r\
    \ {\n            return false\n        }\n    }\n    return true\n}\n        \
    \    \nassert(pluck(arr: [4, 2, 3]) == [2, 1])\nassert(pluck(arr: [1, 2, 3]) ==\
    \ [2, 1])\nassert(pluck(arr: [] as [Int]) == [] as [Int])\nassert(pluck(arr: [5,\
    \ 0, 3, 0, 4, 2]) == [0, 1])\nassert(pluck(arr: [1, 2, 3, 0, 5, 3]) == [0, 3])\n\
    assert(pluck(arr: [5, 4, 8, 4, 8]) == [4, 1])\nassert(pluck(arr: [7, 6, 7, 1])\
    \ == [6, 1])\nassert(pluck(arr: [7, 9, 7, 1]) == [] as [Int])"
  status: Exception
  stderr: 'tmp238ak5rq/tmp238ak5rq.swift:52: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b40fcbfcc80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b40fc8f3b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b40fc8f3988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b40fc8f27b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmp238ak5rq                        0x0000560b6405968c <unavailable> + 5772

    5    libc.so.6                          0x00002b40fcde8460 __libc_start_main +
    245

    6    tmp238ak5rq                        0x0000560b64059299 <unavailable> + 4761

    '
  stdout: ''
  timestamp: 1660013550
- exit_code: 0
  program: "\n/// \"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n/// your task is to pluck one of the nodes and return it.\n///\
    \ The plucked node should be the node with the smallest even value.\n/// If multiple\
    \ nodes with the same smallest even value are found return the node that has smallest\
    \ index.\n/// The plucked node should be returned in an array, [ smalest_value,\
    \ its index ],\n/// If there are no even values or the given array is empty, return\
    \ [].\n/// Example 1:\n/// >>> pluck(arr: [4, 2, 3])\n/// [2, 1]\n/// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n/// Example 2:\n\
    /// >>> pluck(arr: [1, 2, 3])\n/// [2, 1]\n/// Explanation: 2 has the smallest\
    \ even value, and 2 has the smallest index.\n/// Example 3:\n/// >>> pluck(arr:\
    \ [] as [Int])\n/// [] as [Int]\n/// Example 4:\n/// >>> pluck(arr: [5, 0, 3,\
    \ 0, 4, 2])\n/// [0, 1]\n/// Explanation: 0 is the smallest value, but  there\
    \ are two zeros,\n/// so we will choose the first zero, which has the smallest\
    \ index.\n/// Constraints:\n/// * 1 <= nodes.length <= 10000\n/// * 0 <= node.value\n\
    func pluck(arr: [Int]) -> [Int] {\n    let newArr = arr.filter { $0 % 2 == 0 }\n\
    \    if newArr.isEmpty {\n        return []\n    }\n    let minValue = newArr.min()!\n\
    \    let index = arr.firstIndex(of: minValue)!\n    return [minValue, index]\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(pluck(arr: [4, 2, 3]) == [2, 1])\nassert(pluck(arr:\
    \ [1, 2, 3]) == [2, 1])\nassert(pluck(arr: [] as [Int]) == [] as [Int])\nassert(pluck(arr:\
    \ [5, 0, 3, 0, 4, 2]) == [0, 1])\nassert(pluck(arr: [1, 2, 3, 0, 5, 3]) == [0,\
    \ 3])\nassert(pluck(arr: [5, 4, 8, 4, 8]) == [4, 1])\nassert(pluck(arr: [7, 6,\
    \ 7, 1]) == [6, 1])\nassert(pluck(arr: [7, 9, 7, 1]) == [] as [Int])"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660013551
- exit_code: 1
  program: "\n/// \"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n/// your task is to pluck one of the nodes and return it.\n///\
    \ The plucked node should be the node with the smallest even value.\n/// If multiple\
    \ nodes with the same smallest even value are found return the node that has smallest\
    \ index.\n/// The plucked node should be returned in an array, [ smalest_value,\
    \ its index ],\n/// If there are no even values or the given array is empty, return\
    \ [].\n/// Example 1:\n/// >>> pluck(arr: [4, 2, 3])\n/// [2, 1]\n/// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n/// Example 2:\n\
    /// >>> pluck(arr: [1, 2, 3])\n/// [2, 1]\n/// Explanation: 2 has the smallest\
    \ even value, and 2 has the smallest index.\n/// Example 3:\n/// >>> pluck(arr:\
    \ [] as [Int])\n/// [] as [Int]\n/// Example 4:\n/// >>> pluck(arr: [5, 0, 3,\
    \ 0, 4, 2])\n/// [0, 1]\n/// Explanation: 0 is the smallest value, but  there\
    \ are two zeros,\n/// so we will choose the first zero, which has the smallest\
    \ index.\n/// Constraints:\n/// * 1 <= nodes.length <= 10000\n/// * 0 <= node.value\n\
    func pluck(arr: [Int]) -> [Int] {\n    return arr.enumerated().filter { $0.element\
    \ % 2 == 0 }.min { $0.element < $1.element }?.array ?? []\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(pluck(arr: [4, 2, 3]) == [2, 1])\nassert(pluck(arr: [1,\
    \ 2, 3]) == [2, 1])\nassert(pluck(arr: [] as [Int]) == [] as [Int])\nassert(pluck(arr:\
    \ [5, 0, 3, 0, 4, 2]) == [0, 1])\nassert(pluck(arr: [1, 2, 3, 0, 5, 3]) == [0,\
    \ 3])\nassert(pluck(arr: [5, 4, 8, 4, 8]) == [4, 1])\nassert(pluck(arr: [7, 6,\
    \ 7, 1]) == [6, 1])\nassert(pluck(arr: [7, 9, 7, 1]) == [] as [Int])"
  status: SyntaxError
  stderr: "/tmp/tmphm4zbw3i.swift:28:93: error: value of tuple type 'EnumeratedSequence<[Int]>.Iterator.Element'\
    \ (aka '(offset: Int, element: Int)') has no member 'array'\n    return arr.enumerated().filter\
    \ { $0.element % 2 == 0 }.min { $0.element < $1.element }?.array ?? []\n     \
    \      ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\
    \ ^~~~~\n"
  stdout: ''
  timestamp: 1660013550
- exit_code: 0
  program: "\n/// \"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n/// your task is to pluck one of the nodes and return it.\n///\
    \ The plucked node should be the node with the smallest even value.\n/// If multiple\
    \ nodes with the same smallest even value are found return the node that has smallest\
    \ index.\n/// The plucked node should be returned in an array, [ smalest_value,\
    \ its index ],\n/// If there are no even values or the given array is empty, return\
    \ [].\n/// Example 1:\n/// >>> pluck(arr: [4, 2, 3])\n/// [2, 1]\n/// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n/// Example 2:\n\
    /// >>> pluck(arr: [1, 2, 3])\n/// [2, 1]\n/// Explanation: 2 has the smallest\
    \ even value, and 2 has the smallest index.\n/// Example 3:\n/// >>> pluck(arr:\
    \ [] as [Int])\n/// [] as [Int]\n/// Example 4:\n/// >>> pluck(arr: [5, 0, 3,\
    \ 0, 4, 2])\n/// [0, 1]\n/// Explanation: 0 is the smallest value, but  there\
    \ are two zeros,\n/// so we will choose the first zero, which has the smallest\
    \ index.\n/// Constraints:\n/// * 1 <= nodes.length <= 10000\n/// * 0 <= node.value\n\
    func pluck(arr: [Int]) -> [Int] {\n    var minEven: Int?\n    var minEvenIndex:\
    \ Int?\n    for (index, element) in arr.enumerated() {\n        if element % 2\
    \ == 0 {\n            if minEven == nil || element < minEven! {\n            \
    \    minEven = element\n                minEvenIndex = index\n            }\n\
    \        }\n    }\n    if minEven == nil {\n        return []\n    }\n    return\
    \ [minEven!, minEvenIndex!]\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int,\
    \ Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n\
    \    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n          \
    \  return false\n        }\n    }\n    return true\n}\n            \nassert(pluck(arr:\
    \ [4, 2, 3]) == [2, 1])\nassert(pluck(arr: [1, 2, 3]) == [2, 1])\nassert(pluck(arr:\
    \ [] as [Int]) == [] as [Int])\nassert(pluck(arr: [5, 0, 3, 0, 4, 2]) == [0, 1])\n\
    assert(pluck(arr: [1, 2, 3, 0, 5, 3]) == [0, 3])\nassert(pluck(arr: [5, 4, 8,\
    \ 4, 8]) == [4, 1])\nassert(pluck(arr: [7, 6, 7, 1]) == [6, 1])\nassert(pluck(arr:\
    \ [7, 9, 7, 1]) == [] as [Int])"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660013551
- exit_code: 0
  program: "\n/// \"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n/// your task is to pluck one of the nodes and return it.\n///\
    \ The plucked node should be the node with the smallest even value.\n/// If multiple\
    \ nodes with the same smallest even value are found return the node that has smallest\
    \ index.\n/// The plucked node should be returned in an array, [ smalest_value,\
    \ its index ],\n/// If there are no even values or the given array is empty, return\
    \ [].\n/// Example 1:\n/// >>> pluck(arr: [4, 2, 3])\n/// [2, 1]\n/// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n/// Example 2:\n\
    /// >>> pluck(arr: [1, 2, 3])\n/// [2, 1]\n/// Explanation: 2 has the smallest\
    \ even value, and 2 has the smallest index.\n/// Example 3:\n/// >>> pluck(arr:\
    \ [] as [Int])\n/// [] as [Int]\n/// Example 4:\n/// >>> pluck(arr: [5, 0, 3,\
    \ 0, 4, 2])\n/// [0, 1]\n/// Explanation: 0 is the smallest value, but  there\
    \ are two zeros,\n/// so we will choose the first zero, which has the smallest\
    \ index.\n/// Constraints:\n/// * 1 <= nodes.length <= 10000\n/// * 0 <= node.value\n\
    func pluck(arr: [Int]) -> [Int] {\n    let evens = arr.filter { $0 % 2 == 0 }\n\
    \    guard let min = evens.min() else { return [] }\n    guard let index = arr.firstIndex(of:\
    \ min) else { return [] }\n    return [min, index]\n}\n\n\nfunc ==(left: [(Int,\
    \ Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n\
    \        return false\n    }\n    for (l, r) in zip(left, right) {\n        if\
    \ l != r {\n            return false\n        }\n    }\n    return true\n}\n \
    \           \nassert(pluck(arr: [4, 2, 3]) == [2, 1])\nassert(pluck(arr: [1, 2,\
    \ 3]) == [2, 1])\nassert(pluck(arr: [] as [Int]) == [] as [Int])\nassert(pluck(arr:\
    \ [5, 0, 3, 0, 4, 2]) == [0, 1])\nassert(pluck(arr: [1, 2, 3, 0, 5, 3]) == [0,\
    \ 3])\nassert(pluck(arr: [5, 4, 8, 4, 8]) == [4, 1])\nassert(pluck(arr: [7, 6,\
    \ 7, 1]) == [6, 1])\nassert(pluck(arr: [7, 9, 7, 1]) == [] as [Int])"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660013364
- exit_code: 0
  program: "\n/// \"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n/// your task is to pluck one of the nodes and return it.\n///\
    \ The plucked node should be the node with the smallest even value.\n/// If multiple\
    \ nodes with the same smallest even value are found return the node that has smallest\
    \ index.\n/// The plucked node should be returned in an array, [ smalest_value,\
    \ its index ],\n/// If there are no even values or the given array is empty, return\
    \ [].\n/// Example 1:\n/// >>> pluck(arr: [4, 2, 3])\n/// [2, 1]\n/// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n/// Example 2:\n\
    /// >>> pluck(arr: [1, 2, 3])\n/// [2, 1]\n/// Explanation: 2 has the smallest\
    \ even value, and 2 has the smallest index.\n/// Example 3:\n/// >>> pluck(arr:\
    \ [] as [Int])\n/// [] as [Int]\n/// Example 4:\n/// >>> pluck(arr: [5, 0, 3,\
    \ 0, 4, 2])\n/// [0, 1]\n/// Explanation: 0 is the smallest value, but  there\
    \ are two zeros,\n/// so we will choose the first zero, which has the smallest\
    \ index.\n/// Constraints:\n/// * 1 <= nodes.length <= 10000\n/// * 0 <= node.value\n\
    func pluck(arr: [Int]) -> [Int] {\n    let evenArr = arr.filter { $0 % 2 == 0\
    \ }\n    if evenArr.isEmpty {\n        return []\n    }\n    let smallValue =\
    \ evenArr.min()!\n    let index = arr.firstIndex(of: smallValue)!\n    return\
    \ [smallValue, index]\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(pluck(arr:\
    \ [4, 2, 3]) == [2, 1])\nassert(pluck(arr: [1, 2, 3]) == [2, 1])\nassert(pluck(arr:\
    \ [] as [Int]) == [] as [Int])\nassert(pluck(arr: [5, 0, 3, 0, 4, 2]) == [0, 1])\n\
    assert(pluck(arr: [1, 2, 3, 0, 5, 3]) == [0, 3])\nassert(pluck(arr: [5, 4, 8,\
    \ 4, 8]) == [4, 1])\nassert(pluck(arr: [7, 6, 7, 1]) == [6, 1])\nassert(pluck(arr:\
    \ [7, 9, 7, 1]) == [] as [Int])"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660013551
- exit_code: 0
  program: "\n/// \"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n/// your task is to pluck one of the nodes and return it.\n///\
    \ The plucked node should be the node with the smallest even value.\n/// If multiple\
    \ nodes with the same smallest even value are found return the node that has smallest\
    \ index.\n/// The plucked node should be returned in an array, [ smalest_value,\
    \ its index ],\n/// If there are no even values or the given array is empty, return\
    \ [].\n/// Example 1:\n/// >>> pluck(arr: [4, 2, 3])\n/// [2, 1]\n/// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n/// Example 2:\n\
    /// >>> pluck(arr: [1, 2, 3])\n/// [2, 1]\n/// Explanation: 2 has the smallest\
    \ even value, and 2 has the smallest index.\n/// Example 3:\n/// >>> pluck(arr:\
    \ [] as [Int])\n/// [] as [Int]\n/// Example 4:\n/// >>> pluck(arr: [5, 0, 3,\
    \ 0, 4, 2])\n/// [0, 1]\n/// Explanation: 0 is the smallest value, but  there\
    \ are two zeros,\n/// so we will choose the first zero, which has the smallest\
    \ index.\n/// Constraints:\n/// * 1 <= nodes.length <= 10000\n/// * 0 <= node.value\n\
    func pluck(arr: [Int]) -> [Int] {\n    guard arr.count > 0 else { return [] }\n\
    \    let sortedEvenNodes = arr.filter { $0 % 2 == 0 }.sorted()\n    let smallestEvenValue\
    \ = sortedEvenNodes.first ?? -1\n    guard smallestEvenValue != -1 else { return\
    \ [] }\n    let smallestEvenValueIndex = arr.firstIndex(of: smallestEvenValue)\
    \ ?? -1\n    return [smallestEvenValue, smallestEvenValueIndex]\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(pluck(arr: [4, 2, 3]) == [2, 1])\nassert(pluck(arr: [1,\
    \ 2, 3]) == [2, 1])\nassert(pluck(arr: [] as [Int]) == [] as [Int])\nassert(pluck(arr:\
    \ [5, 0, 3, 0, 4, 2]) == [0, 1])\nassert(pluck(arr: [1, 2, 3, 0, 5, 3]) == [0,\
    \ 3])\nassert(pluck(arr: [5, 4, 8, 4, 8]) == [4, 1])\nassert(pluck(arr: [7, 6,\
    \ 7, 1]) == [6, 1])\nassert(pluck(arr: [7, 9, 7, 1]) == [] as [Int])"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660013551
- exit_code: 0
  program: "\n/// \"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n/// your task is to pluck one of the nodes and return it.\n///\
    \ The plucked node should be the node with the smallest even value.\n/// If multiple\
    \ nodes with the same smallest even value are found return the node that has smallest\
    \ index.\n/// The plucked node should be returned in an array, [ smalest_value,\
    \ its index ],\n/// If there are no even values or the given array is empty, return\
    \ [].\n/// Example 1:\n/// >>> pluck(arr: [4, 2, 3])\n/// [2, 1]\n/// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n/// Example 2:\n\
    /// >>> pluck(arr: [1, 2, 3])\n/// [2, 1]\n/// Explanation: 2 has the smallest\
    \ even value, and 2 has the smallest index.\n/// Example 3:\n/// >>> pluck(arr:\
    \ [] as [Int])\n/// [] as [Int]\n/// Example 4:\n/// >>> pluck(arr: [5, 0, 3,\
    \ 0, 4, 2])\n/// [0, 1]\n/// Explanation: 0 is the smallest value, but  there\
    \ are two zeros,\n/// so we will choose the first zero, which has the smallest\
    \ index.\n/// Constraints:\n/// * 1 <= nodes.length <= 10000\n/// * 0 <= node.value\n\
    func pluck(arr: [Int]) -> [Int] {\n    var smallEven: Int?\n    var index = 0\n\
    \    var result = [Int]()\n    for i in arr {\n        if i % 2 == 0 {\n     \
    \       if smallEven == nil {\n                smallEven = i\n               \
    \ result.append(smallEven!)\n                result.append(index)\n          \
    \  } else if i < smallEven! {\n                smallEven = i\n               \
    \ result.removeAll()\n                result.append(smallEven!)\n            \
    \    result.append(index)\n            }\n        }\n        index += 1\n    }\n\
    \    return result\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) ->\
    \ Bool {\n    if left.count != right.count {\n        return false\n    }\n  \
    \  for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(pluck(arr: [4, 2,\
    \ 3]) == [2, 1])\nassert(pluck(arr: [1, 2, 3]) == [2, 1])\nassert(pluck(arr: []\
    \ as [Int]) == [] as [Int])\nassert(pluck(arr: [5, 0, 3, 0, 4, 2]) == [0, 1])\n\
    assert(pluck(arr: [1, 2, 3, 0, 5, 3]) == [0, 3])\nassert(pluck(arr: [5, 4, 8,\
    \ 4, 8]) == [4, 1])\nassert(pluck(arr: [7, 6, 7, 1]) == [6, 1])\nassert(pluck(arr:\
    \ [7, 9, 7, 1]) == [] as [Int])"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660013551
- exit_code: 0
  program: "\n/// \"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n/// your task is to pluck one of the nodes and return it.\n///\
    \ The plucked node should be the node with the smallest even value.\n/// If multiple\
    \ nodes with the same smallest even value are found return the node that has smallest\
    \ index.\n/// The plucked node should be returned in an array, [ smalest_value,\
    \ its index ],\n/// If there are no even values or the given array is empty, return\
    \ [].\n/// Example 1:\n/// >>> pluck(arr: [4, 2, 3])\n/// [2, 1]\n/// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n/// Example 2:\n\
    /// >>> pluck(arr: [1, 2, 3])\n/// [2, 1]\n/// Explanation: 2 has the smallest\
    \ even value, and 2 has the smallest index.\n/// Example 3:\n/// >>> pluck(arr:\
    \ [] as [Int])\n/// [] as [Int]\n/// Example 4:\n/// >>> pluck(arr: [5, 0, 3,\
    \ 0, 4, 2])\n/// [0, 1]\n/// Explanation: 0 is the smallest value, but  there\
    \ are two zeros,\n/// so we will choose the first zero, which has the smallest\
    \ index.\n/// Constraints:\n/// * 1 <= nodes.length <= 10000\n/// * 0 <= node.value\n\
    func pluck(arr: [Int]) -> [Int] {\n    var results = [Int]()\n    var smallestEvenValue\
    \ = Int.max\n    for (index, value) in arr.enumerated() {\n        if value %\
    \ 2 == 0 && value < smallestEvenValue {\n            smallestEvenValue = value\n\
    \            results = [value, index]\n        }\n    }\n    return results\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(pluck(arr: [4, 2, 3]) == [2, 1])\nassert(pluck(arr:\
    \ [1, 2, 3]) == [2, 1])\nassert(pluck(arr: [] as [Int]) == [] as [Int])\nassert(pluck(arr:\
    \ [5, 0, 3, 0, 4, 2]) == [0, 1])\nassert(pluck(arr: [1, 2, 3, 0, 5, 3]) == [0,\
    \ 3])\nassert(pluck(arr: [5, 4, 8, 4, 8]) == [4, 1])\nassert(pluck(arr: [7, 6,\
    \ 7, 1]) == [6, 1])\nassert(pluck(arr: [7, 9, 7, 1]) == [] as [Int])"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660013551
- exit_code: 0
  program: "\n/// \"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n/// your task is to pluck one of the nodes and return it.\n///\
    \ The plucked node should be the node with the smallest even value.\n/// If multiple\
    \ nodes with the same smallest even value are found return the node that has smallest\
    \ index.\n/// The plucked node should be returned in an array, [ smalest_value,\
    \ its index ],\n/// If there are no even values or the given array is empty, return\
    \ [].\n/// Example 1:\n/// >>> pluck(arr: [4, 2, 3])\n/// [2, 1]\n/// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n/// Example 2:\n\
    /// >>> pluck(arr: [1, 2, 3])\n/// [2, 1]\n/// Explanation: 2 has the smallest\
    \ even value, and 2 has the smallest index.\n/// Example 3:\n/// >>> pluck(arr:\
    \ [] as [Int])\n/// [] as [Int]\n/// Example 4:\n/// >>> pluck(arr: [5, 0, 3,\
    \ 0, 4, 2])\n/// [0, 1]\n/// Explanation: 0 is the smallest value, but  there\
    \ are two zeros,\n/// so we will choose the first zero, which has the smallest\
    \ index.\n/// Constraints:\n/// * 1 <= nodes.length <= 10000\n/// * 0 <= node.value\n\
    func pluck(arr: [Int]) -> [Int] {\n    let even = arr.enumerated().filter { $0.element\
    \ % 2 == 0 }\n    let min = even.min { a, b in a.element < b.element }\n    return\
    \ min.map { [$0.element, $0.offset] } ?? []\n}\n\n\nfunc ==(left: [(Int, Int)],\
    \ right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n       \
    \ return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r\
    \ {\n            return false\n        }\n    }\n    return true\n}\n        \
    \    \nassert(pluck(arr: [4, 2, 3]) == [2, 1])\nassert(pluck(arr: [1, 2, 3]) ==\
    \ [2, 1])\nassert(pluck(arr: [] as [Int]) == [] as [Int])\nassert(pluck(arr: [5,\
    \ 0, 3, 0, 4, 2]) == [0, 1])\nassert(pluck(arr: [1, 2, 3, 0, 5, 3]) == [0, 3])\n\
    assert(pluck(arr: [5, 4, 8, 4, 8]) == [4, 1])\nassert(pluck(arr: [7, 6, 7, 1])\
    \ == [6, 1])\nassert(pluck(arr: [7, 9, 7, 1]) == [] as [Int])"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660013551
- exit_code: 0
  program: "\n/// \"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n/// your task is to pluck one of the nodes and return it.\n///\
    \ The plucked node should be the node with the smallest even value.\n/// If multiple\
    \ nodes with the same smallest even value are found return the node that has smallest\
    \ index.\n/// The plucked node should be returned in an array, [ smalest_value,\
    \ its index ],\n/// If there are no even values or the given array is empty, return\
    \ [].\n/// Example 1:\n/// >>> pluck(arr: [4, 2, 3])\n/// [2, 1]\n/// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n/// Example 2:\n\
    /// >>> pluck(arr: [1, 2, 3])\n/// [2, 1]\n/// Explanation: 2 has the smallest\
    \ even value, and 2 has the smallest index.\n/// Example 3:\n/// >>> pluck(arr:\
    \ [] as [Int])\n/// [] as [Int]\n/// Example 4:\n/// >>> pluck(arr: [5, 0, 3,\
    \ 0, 4, 2])\n/// [0, 1]\n/// Explanation: 0 is the smallest value, but  there\
    \ are two zeros,\n/// so we will choose the first zero, which has the smallest\
    \ index.\n/// Constraints:\n/// * 1 <= nodes.length <= 10000\n/// * 0 <= node.value\n\
    func pluck(arr: [Int]) -> [Int] {\n    guard arr.count > 0 else { return [] }\n\
    \    var evens: [Int] = []\n    for (index, value) in arr.enumerated() {\n   \
    \     if value % 2 == 0 {\n            evens.append(value)\n        }\n    }\n\
    \    guard evens.count > 0 else { return [] }\n    let lowestEven = evens.min()\n\
    \    for (index, value) in arr.enumerated() {\n        if value == lowestEven\
    \ {\n            return [value, index]\n        }\n    }\n    return []\n}\n\n\
    \nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(pluck(arr: [4, 2, 3]) == [2, 1])\nassert(pluck(arr:\
    \ [1, 2, 3]) == [2, 1])\nassert(pluck(arr: [] as [Int]) == [] as [Int])\nassert(pluck(arr:\
    \ [5, 0, 3, 0, 4, 2]) == [0, 1])\nassert(pluck(arr: [1, 2, 3, 0, 5, 3]) == [0,\
    \ 3])\nassert(pluck(arr: [5, 4, 8, 4, 8]) == [4, 1])\nassert(pluck(arr: [7, 6,\
    \ 7, 1]) == [6, 1])\nassert(pluck(arr: [7, 9, 7, 1]) == [] as [Int])"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660013551
- exit_code: 1
  program: "\n/// \"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n/// your task is to pluck one of the nodes and return it.\n///\
    \ The plucked node should be the node with the smallest even value.\n/// If multiple\
    \ nodes with the same smallest even value are found return the node that has smallest\
    \ index.\n/// The plucked node should be returned in an array, [ smalest_value,\
    \ its index ],\n/// If there are no even values or the given array is empty, return\
    \ [].\n/// Example 1:\n/// >>> pluck(arr: [4, 2, 3])\n/// [2, 1]\n/// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n/// Example 2:\n\
    /// >>> pluck(arr: [1, 2, 3])\n/// [2, 1]\n/// Explanation: 2 has the smallest\
    \ even value, and 2 has the smallest index.\n/// Example 3:\n/// >>> pluck(arr:\
    \ [] as [Int])\n/// [] as [Int]\n/// Example 4:\n/// >>> pluck(arr: [5, 0, 3,\
    \ 0, 4, 2])\n/// [0, 1]\n/// Explanation: 0 is the smallest value, but  there\
    \ are two zeros,\n/// so we will choose the first zero, which has the smallest\
    \ index.\n/// Constraints:\n/// * 1 <= nodes.length <= 10000\n/// * 0 <= node.value\n\
    func pluck(arr: [Int]) -> [Int] {\n    \n    return pluck(current: arr, smallestEven:\
    \ Int.max, index: -1)\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(pluck(arr:\
    \ [4, 2, 3]) == [2, 1])\nassert(pluck(arr: [1, 2, 3]) == [2, 1])\nassert(pluck(arr:\
    \ [] as [Int]) == [] as [Int])\nassert(pluck(arr: [5, 0, 3, 0, 4, 2]) == [0, 1])\n\
    assert(pluck(arr: [1, 2, 3, 0, 5, 3]) == [0, 3])\nassert(pluck(arr: [5, 4, 8,\
    \ 4, 8]) == [4, 1])\nassert(pluck(arr: [7, 6, 7, 1]) == [6, 1])\nassert(pluck(arr:\
    \ [7, 9, 7, 1]) == [] as [Int])"
  status: SyntaxError
  stderr: "/tmp/tmpvj6saoar.swift:29:17: error: extra arguments at positions #1, #2,\
    \ #3 in call\n    return pluck(current: arr, smallestEven: Int.max, index: -1)\n\
    \                ^\n/tmp/tmpvj6saoar.swift:27:6: note: 'pluck(arr:)' declared\
    \ here\nfunc pluck(arr: [Int]) -> [Int] {\n     ^\n/tmp/tmpvj6saoar.swift:29:18:\
    \ error: missing argument for parameter 'arr' in call\n    return pluck(current:\
    \ arr, smallestEven: Int.max, index: -1)\n                 ^\n               \
    \  arr: <#[Int]#>, \n/tmp/tmpvj6saoar.swift:27:6: note: 'pluck(arr:)' declared\
    \ here\nfunc pluck(arr: [Int]) -> [Int] {\n     ^\n"
  stdout: ''
  timestamp: 1660013550
- exit_code: 0
  program: "\n/// \"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n/// your task is to pluck one of the nodes and return it.\n///\
    \ The plucked node should be the node with the smallest even value.\n/// If multiple\
    \ nodes with the same smallest even value are found return the node that has smallest\
    \ index.\n/// The plucked node should be returned in an array, [ smalest_value,\
    \ its index ],\n/// If there are no even values or the given array is empty, return\
    \ [].\n/// Example 1:\n/// >>> pluck(arr: [4, 2, 3])\n/// [2, 1]\n/// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n/// Example 2:\n\
    /// >>> pluck(arr: [1, 2, 3])\n/// [2, 1]\n/// Explanation: 2 has the smallest\
    \ even value, and 2 has the smallest index.\n/// Example 3:\n/// >>> pluck(arr:\
    \ [] as [Int])\n/// [] as [Int]\n/// Example 4:\n/// >>> pluck(arr: [5, 0, 3,\
    \ 0, 4, 2])\n/// [0, 1]\n/// Explanation: 0 is the smallest value, but  there\
    \ are two zeros,\n/// so we will choose the first zero, which has the smallest\
    \ index.\n/// Constraints:\n/// * 1 <= nodes.length <= 10000\n/// * 0 <= node.value\n\
    func pluck(arr: [Int]) -> [Int] {\n    return arr.enumerated().filter { $0.element\
    \ % 2 == 0 }.min { $0.element < $1.element }.map { [$0.element, $0.offset] } ??\
    \ []\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if\
    \ left.count != right.count {\n        return false\n    }\n    for (l, r) in\
    \ zip(left, right) {\n        if l != r {\n            return false\n        }\n\
    \    }\n    return true\n}\n            \nassert(pluck(arr: [4, 2, 3]) == [2,\
    \ 1])\nassert(pluck(arr: [1, 2, 3]) == [2, 1])\nassert(pluck(arr: [] as [Int])\
    \ == [] as [Int])\nassert(pluck(arr: [5, 0, 3, 0, 4, 2]) == [0, 1])\nassert(pluck(arr:\
    \ [1, 2, 3, 0, 5, 3]) == [0, 3])\nassert(pluck(arr: [5, 4, 8, 4, 8]) == [4, 1])\n\
    assert(pluck(arr: [7, 6, 7, 1]) == [6, 1])\nassert(pluck(arr: [7, 9, 7, 1]) ==\
    \ [] as [Int])"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660013551
- exit_code: 0
  program: "\n/// \"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n/// your task is to pluck one of the nodes and return it.\n///\
    \ The plucked node should be the node with the smallest even value.\n/// If multiple\
    \ nodes with the same smallest even value are found return the node that has smallest\
    \ index.\n/// The plucked node should be returned in an array, [ smalest_value,\
    \ its index ],\n/// If there are no even values or the given array is empty, return\
    \ [].\n/// Example 1:\n/// >>> pluck(arr: [4, 2, 3])\n/// [2, 1]\n/// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n/// Example 2:\n\
    /// >>> pluck(arr: [1, 2, 3])\n/// [2, 1]\n/// Explanation: 2 has the smallest\
    \ even value, and 2 has the smallest index.\n/// Example 3:\n/// >>> pluck(arr:\
    \ [] as [Int])\n/// [] as [Int]\n/// Example 4:\n/// >>> pluck(arr: [5, 0, 3,\
    \ 0, 4, 2])\n/// [0, 1]\n/// Explanation: 0 is the smallest value, but  there\
    \ are two zeros,\n/// so we will choose the first zero, which has the smallest\
    \ index.\n/// Constraints:\n/// * 1 <= nodes.length <= 10000\n/// * 0 <= node.value\n\
    func pluck(arr: [Int]) -> [Int] {\n    var result = [Int]()\n    if arr.isEmpty\
    \ {\n        return result\n    }\n    var minEven = Int.max\n    var minEvenIndex\
    \ = 0\n    for (index, element) in arr.enumerated() {\n        if element < minEven,\
    \ element % 2 == 0 {\n            minEven = element\n            minEvenIndex\
    \ = index\n        }\n    }\n    if minEven != Int.max {\n        result.append(minEven)\n\
    \        result.append(minEvenIndex)\n    }\n    return result\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(pluck(arr: [4, 2, 3]) == [2, 1])\nassert(pluck(arr: [1,\
    \ 2, 3]) == [2, 1])\nassert(pluck(arr: [] as [Int]) == [] as [Int])\nassert(pluck(arr:\
    \ [5, 0, 3, 0, 4, 2]) == [0, 1])\nassert(pluck(arr: [1, 2, 3, 0, 5, 3]) == [0,\
    \ 3])\nassert(pluck(arr: [5, 4, 8, 4, 8]) == [4, 1])\nassert(pluck(arr: [7, 6,\
    \ 7, 1]) == [6, 1])\nassert(pluck(arr: [7, 9, 7, 1]) == [] as [Int])"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660013551
- exit_code: 0
  program: "\n/// \"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n/// your task is to pluck one of the nodes and return it.\n///\
    \ The plucked node should be the node with the smallest even value.\n/// If multiple\
    \ nodes with the same smallest even value are found return the node that has smallest\
    \ index.\n/// The plucked node should be returned in an array, [ smalest_value,\
    \ its index ],\n/// If there are no even values or the given array is empty, return\
    \ [].\n/// Example 1:\n/// >>> pluck(arr: [4, 2, 3])\n/// [2, 1]\n/// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n/// Example 2:\n\
    /// >>> pluck(arr: [1, 2, 3])\n/// [2, 1]\n/// Explanation: 2 has the smallest\
    \ even value, and 2 has the smallest index.\n/// Example 3:\n/// >>> pluck(arr:\
    \ [] as [Int])\n/// [] as [Int]\n/// Example 4:\n/// >>> pluck(arr: [5, 0, 3,\
    \ 0, 4, 2])\n/// [0, 1]\n/// Explanation: 0 is the smallest value, but  there\
    \ are two zeros,\n/// so we will choose the first zero, which has the smallest\
    \ index.\n/// Constraints:\n/// * 1 <= nodes.length <= 10000\n/// * 0 <= node.value\n\
    func pluck(arr: [Int]) -> [Int] {\n    var result = [Int]()\n    var evens = [Int]()\n\
    \    var minIndex = Int.max\n    var minEven = Int.max\n    var i = 0\n    while\
    \ i < arr.count {\n        if arr[i] % 2 == 0 {\n            evens.append(arr[i])\n\
    \            if arr[i] < minEven {\n                minEven = arr[i]\n       \
    \         minIndex = i\n            }\n        }\n        i += 1\n    }\n    if\
    \ evens.count > 0 {\n        result.append(minEven)\n        result.append(minIndex)\n\
    \    }\n    return result\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(pluck(arr:\
    \ [4, 2, 3]) == [2, 1])\nassert(pluck(arr: [1, 2, 3]) == [2, 1])\nassert(pluck(arr:\
    \ [] as [Int]) == [] as [Int])\nassert(pluck(arr: [5, 0, 3, 0, 4, 2]) == [0, 1])\n\
    assert(pluck(arr: [1, 2, 3, 0, 5, 3]) == [0, 3])\nassert(pluck(arr: [5, 4, 8,\
    \ 4, 8]) == [4, 1])\nassert(pluck(arr: [7, 6, 7, 1]) == [6, 1])\nassert(pluck(arr:\
    \ [7, 9, 7, 1]) == [] as [Int])"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660013551
- exit_code: 0
  program: "\n/// \"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n/// your task is to pluck one of the nodes and return it.\n///\
    \ The plucked node should be the node with the smallest even value.\n/// If multiple\
    \ nodes with the same smallest even value are found return the node that has smallest\
    \ index.\n/// The plucked node should be returned in an array, [ smalest_value,\
    \ its index ],\n/// If there are no even values or the given array is empty, return\
    \ [].\n/// Example 1:\n/// >>> pluck(arr: [4, 2, 3])\n/// [2, 1]\n/// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n/// Example 2:\n\
    /// >>> pluck(arr: [1, 2, 3])\n/// [2, 1]\n/// Explanation: 2 has the smallest\
    \ even value, and 2 has the smallest index.\n/// Example 3:\n/// >>> pluck(arr:\
    \ [] as [Int])\n/// [] as [Int]\n/// Example 4:\n/// >>> pluck(arr: [5, 0, 3,\
    \ 0, 4, 2])\n/// [0, 1]\n/// Explanation: 0 is the smallest value, but  there\
    \ are two zeros,\n/// so we will choose the first zero, which has the smallest\
    \ index.\n/// Constraints:\n/// * 1 <= nodes.length <= 10000\n/// * 0 <= node.value\n\
    func pluck(arr: [Int]) -> [Int] {\n    if arr.isEmpty {\n        return []\n \
    \   }\n    var evenArr = [Int]()\n    var indexArr = [Int]()\n    var minEven\
    \ = Int.max\n    var resultArr = [Int]()\n    for (index, value) in arr.enumerated()\
    \ {\n        if value % 2 == 0 {\n            evenArr.append(value)\n        \
    \    indexArr.append(index)\n        }\n    }\n    if evenArr.isEmpty {\n    \
    \    return []\n    }\n    for number in evenArr {\n        if number < minEven\
    \ {\n            minEven = number\n        }\n    }\n    for (index, number) in\
    \ evenArr.enumerated() {\n        if number == minEven {\n            resultArr.append(number)\n\
    \            resultArr.append(indexArr[index])\n            break\n        }\n\
    \    }\n    return resultArr\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int,\
    \ Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n\
    \    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n          \
    \  return false\n        }\n    }\n    return true\n}\n            \nassert(pluck(arr:\
    \ [4, 2, 3]) == [2, 1])\nassert(pluck(arr: [1, 2, 3]) == [2, 1])\nassert(pluck(arr:\
    \ [] as [Int]) == [] as [Int])\nassert(pluck(arr: [5, 0, 3, 0, 4, 2]) == [0, 1])\n\
    assert(pluck(arr: [1, 2, 3, 0, 5, 3]) == [0, 3])\nassert(pluck(arr: [5, 4, 8,\
    \ 4, 8]) == [4, 1])\nassert(pluck(arr: [7, 6, 7, 1]) == [6, 1])\nassert(pluck(arr:\
    \ [7, 9, 7, 1]) == [] as [Int])"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660013551
- exit_code: -4
  program: "\n/// \"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n/// your task is to pluck one of the nodes and return it.\n///\
    \ The plucked node should be the node with the smallest even value.\n/// If multiple\
    \ nodes with the same smallest even value are found return the node that has smallest\
    \ index.\n/// The plucked node should be returned in an array, [ smalest_value,\
    \ its index ],\n/// If there are no even values or the given array is empty, return\
    \ [].\n/// Example 1:\n/// >>> pluck(arr: [4, 2, 3])\n/// [2, 1]\n/// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n/// Example 2:\n\
    /// >>> pluck(arr: [1, 2, 3])\n/// [2, 1]\n/// Explanation: 2 has the smallest\
    \ even value, and 2 has the smallest index.\n/// Example 3:\n/// >>> pluck(arr:\
    \ [] as [Int])\n/// [] as [Int]\n/// Example 4:\n/// >>> pluck(arr: [5, 0, 3,\
    \ 0, 4, 2])\n/// [0, 1]\n/// Explanation: 0 is the smallest value, but  there\
    \ are two zeros,\n/// so we will choose the first zero, which has the smallest\
    \ index.\n/// Constraints:\n/// * 1 <= nodes.length <= 10000\n/// * 0 <= node.value\n\
    func pluck(arr: [Int]) -> [Int] {\n    // our storage for the result\n    var\
    \ res = [Int]()\n    // our storage for all even numbers\n    var evenArr = [Int]()\n\
    \    // check for empty array and return an empty array\n    if arr.isEmpty {\n\
    \        return res\n    }\n    // get all even numbers from given array and store\
    \ them in evenArr\n    for num in arr {\n        if num % 2 == 0 {\n         \
    \   evenArr.append(num)\n        }\n    }\n    // check if there are no even numbers\
    \ and return an empty array\n    if evenArr.isEmpty {\n        return res\n  \
    \  }\n    // sort given array in descending order\n    let sortedArr = arr.sorted(by:\
    \ >)\n    // get the smallest even number from evenArr\n    let smallestEven =\
    \ evenArr.min()!\n    // get the index of the smallest even number from given\
    \ array\n    let smallestEvenIndex = sortedArr.firstIndex(of: smallestEven)!\n\
    \    // append smallest even number and its index to our result\n    res.append(contentsOf:\
    \ [smallestEven, smallestEvenIndex])\n    // return result\n    return res\n}\n\
    \n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(pluck(arr: [4, 2, 3]) == [2, 1])\nassert(pluck(arr:\
    \ [1, 2, 3]) == [2, 1])\nassert(pluck(arr: [] as [Int]) == [] as [Int])\nassert(pluck(arr:\
    \ [5, 0, 3, 0, 4, 2]) == [0, 1])\nassert(pluck(arr: [1, 2, 3, 0, 5, 3]) == [0,\
    \ 3])\nassert(pluck(arr: [5, 4, 8, 4, 8]) == [4, 1])\nassert(pluck(arr: [7, 6,\
    \ 7, 1]) == [6, 1])\nassert(pluck(arr: [7, 9, 7, 1]) == [] as [Int])"
  status: Exception
  stderr: 'tmpxw_w1st7/tmpxw_w1st7.swift:71: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002abc67d13c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002abc67a0ab6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002abc67a0a988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002abc67a097b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpxw_w1st7                        0x00005589a516d8bc <unavailable> + 6332

    5    libc.so.6                          0x00002abc67eff460 __libc_start_main +
    245

    6    tmpxw_w1st7                        0x00005589a516d4c9 <unavailable> + 5321

    '
  stdout: ''
  timestamp: 1660013551
- exit_code: 1
  program: "\n/// \"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n/// your task is to pluck one of the nodes and return it.\n///\
    \ The plucked node should be the node with the smallest even value.\n/// If multiple\
    \ nodes with the same smallest even value are found return the node that has smallest\
    \ index.\n/// The plucked node should be returned in an array, [ smalest_value,\
    \ its index ],\n/// If there are no even values or the given array is empty, return\
    \ [].\n/// Example 1:\n/// >>> pluck(arr: [4, 2, 3])\n/// [2, 1]\n/// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n/// Example 2:\n\
    /// >>> pluck(arr: [1, 2, 3])\n/// [2, 1]\n/// Explanation: 2 has the smallest\
    \ even value, and 2 has the smallest index.\n/// Example 3:\n/// >>> pluck(arr:\
    \ [] as [Int])\n/// [] as [Int]\n/// Example 4:\n/// >>> pluck(arr: [5, 0, 3,\
    \ 0, 4, 2])\n/// [0, 1]\n/// Explanation: 0 is the smallest value, but  there\
    \ are two zeros,\n/// so we will choose the first zero, which has the smallest\
    \ index.\n/// Constraints:\n/// * 1 <= nodes.length <= 10000\n/// * 0 <= node.value\n\
    func pluck(arr: [Int]) -> [Int] {\n    guard arr.count > 0 else { return [] }\n\
    \    return arr.enumerated().reduce((index: Int.max, value: Int.max)) { (indexAndValue,\
    \ pair) in\n        let (index, value) = pair\n        if value % 2 == 0 && value\
    \ < indexAndValue.value {\n            return (index, value)\n        }\n    \
    \    return indexAndValue\n    }.value == Int.max ? [] : [indexAndValue.value,\
    \ indexAndValue.index]\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(pluck(arr:\
    \ [4, 2, 3]) == [2, 1])\nassert(pluck(arr: [1, 2, 3]) == [2, 1])\nassert(pluck(arr:\
    \ [] as [Int]) == [] as [Int])\nassert(pluck(arr: [5, 0, 3, 0, 4, 2]) == [0, 1])\n\
    assert(pluck(arr: [1, 2, 3, 0, 5, 3]) == [0, 3])\nassert(pluck(arr: [5, 4, 8,\
    \ 4, 8]) == [4, 1])\nassert(pluck(arr: [7, 6, 7, 1]) == [6, 1])\nassert(pluck(arr:\
    \ [7, 9, 7, 1]) == [] as [Int])"
  status: SyntaxError
  stderr: "/tmp/tmpycbv_p2h.swift:35:32: error: cannot find 'indexAndValue' in scope\n\
    \    }.value == Int.max ? [] : [indexAndValue.value, indexAndValue.index]\n  \
    \                             ^~~~~~~~~~~~~\n/tmp/tmpycbv_p2h.swift:35:53: error:\
    \ cannot find 'indexAndValue' in scope\n    }.value == Int.max ? [] : [indexAndValue.value,\
    \ indexAndValue.index]\n                                                    ^~~~~~~~~~~~~\n"
  stdout: ''
  timestamp: 1660013551
- exit_code: 0
  program: "\n/// \"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n/// your task is to pluck one of the nodes and return it.\n///\
    \ The plucked node should be the node with the smallest even value.\n/// If multiple\
    \ nodes with the same smallest even value are found return the node that has smallest\
    \ index.\n/// The plucked node should be returned in an array, [ smalest_value,\
    \ its index ],\n/// If there are no even values or the given array is empty, return\
    \ [].\n/// Example 1:\n/// >>> pluck(arr: [4, 2, 3])\n/// [2, 1]\n/// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n/// Example 2:\n\
    /// >>> pluck(arr: [1, 2, 3])\n/// [2, 1]\n/// Explanation: 2 has the smallest\
    \ even value, and 2 has the smallest index.\n/// Example 3:\n/// >>> pluck(arr:\
    \ [] as [Int])\n/// [] as [Int]\n/// Example 4:\n/// >>> pluck(arr: [5, 0, 3,\
    \ 0, 4, 2])\n/// [0, 1]\n/// Explanation: 0 is the smallest value, but  there\
    \ are two zeros,\n/// so we will choose the first zero, which has the smallest\
    \ index.\n/// Constraints:\n/// * 1 <= nodes.length <= 10000\n/// * 0 <= node.value\n\
    func pluck(arr: [Int]) -> [Int] {\n    guard !arr.isEmpty else { return [] }\n\
    \    guard let minEven = arr.filter({ $0 % 2 == 0 }).min() else { return [] }\n\
    \    guard let minIndex = arr.firstIndex(of: minEven) else { return [] }\n   \
    \ return [minEven, minIndex]\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int,\
    \ Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n\
    \    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n          \
    \  return false\n        }\n    }\n    return true\n}\n            \nassert(pluck(arr:\
    \ [4, 2, 3]) == [2, 1])\nassert(pluck(arr: [1, 2, 3]) == [2, 1])\nassert(pluck(arr:\
    \ [] as [Int]) == [] as [Int])\nassert(pluck(arr: [5, 0, 3, 0, 4, 2]) == [0, 1])\n\
    assert(pluck(arr: [1, 2, 3, 0, 5, 3]) == [0, 3])\nassert(pluck(arr: [5, 4, 8,\
    \ 4, 8]) == [4, 1])\nassert(pluck(arr: [7, 6, 7, 1]) == [6, 1])\nassert(pluck(arr:\
    \ [7, 9, 7, 1]) == [] as [Int])"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660013551
- exit_code: 0
  program: "\n/// \"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n/// your task is to pluck one of the nodes and return it.\n///\
    \ The plucked node should be the node with the smallest even value.\n/// If multiple\
    \ nodes with the same smallest even value are found return the node that has smallest\
    \ index.\n/// The plucked node should be returned in an array, [ smalest_value,\
    \ its index ],\n/// If there are no even values or the given array is empty, return\
    \ [].\n/// Example 1:\n/// >>> pluck(arr: [4, 2, 3])\n/// [2, 1]\n/// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n/// Example 2:\n\
    /// >>> pluck(arr: [1, 2, 3])\n/// [2, 1]\n/// Explanation: 2 has the smallest\
    \ even value, and 2 has the smallest index.\n/// Example 3:\n/// >>> pluck(arr:\
    \ [] as [Int])\n/// [] as [Int]\n/// Example 4:\n/// >>> pluck(arr: [5, 0, 3,\
    \ 0, 4, 2])\n/// [0, 1]\n/// Explanation: 0 is the smallest value, but  there\
    \ are two zeros,\n/// so we will choose the first zero, which has the smallest\
    \ index.\n/// Constraints:\n/// * 1 <= nodes.length <= 10000\n/// * 0 <= node.value\n\
    func pluck(arr: [Int]) -> [Int] {\n    var smallestEven: Int?\n    var smallestEvenIndex:\
    \ Int?\n    for (index, element) in arr.enumerated() {\n        if element % 2\
    \ == 0 {\n            if smallestEven == nil {\n                smallestEven =\
    \ element\n                smallestEvenIndex = index\n            } else if element\
    \ < smallestEven! {\n                smallestEven = element\n                smallestEvenIndex\
    \ = index\n            }\n        }\n    }\n    if smallestEven != nil {\n   \
    \     return [smallestEven!, smallestEvenIndex!]\n    } else {\n        return\
    \ []\n    }\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n\
    \    if left.count != right.count {\n        return false\n    }\n    for (l,\
    \ r) in zip(left, right) {\n        if l != r {\n            return false\n  \
    \      }\n    }\n    return true\n}\n            \nassert(pluck(arr: [4, 2, 3])\
    \ == [2, 1])\nassert(pluck(arr: [1, 2, 3]) == [2, 1])\nassert(pluck(arr: [] as\
    \ [Int]) == [] as [Int])\nassert(pluck(arr: [5, 0, 3, 0, 4, 2]) == [0, 1])\nassert(pluck(arr:\
    \ [1, 2, 3, 0, 5, 3]) == [0, 3])\nassert(pluck(arr: [5, 4, 8, 4, 8]) == [4, 1])\n\
    assert(pluck(arr: [7, 6, 7, 1]) == [6, 1])\nassert(pluck(arr: [7, 9, 7, 1]) ==\
    \ [] as [Int])"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660013551
- exit_code: 0
  program: "\n/// \"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n/// your task is to pluck one of the nodes and return it.\n///\
    \ The plucked node should be the node with the smallest even value.\n/// If multiple\
    \ nodes with the same smallest even value are found return the node that has smallest\
    \ index.\n/// The plucked node should be returned in an array, [ smalest_value,\
    \ its index ],\n/// If there are no even values or the given array is empty, return\
    \ [].\n/// Example 1:\n/// >>> pluck(arr: [4, 2, 3])\n/// [2, 1]\n/// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n/// Example 2:\n\
    /// >>> pluck(arr: [1, 2, 3])\n/// [2, 1]\n/// Explanation: 2 has the smallest\
    \ even value, and 2 has the smallest index.\n/// Example 3:\n/// >>> pluck(arr:\
    \ [] as [Int])\n/// [] as [Int]\n/// Example 4:\n/// >>> pluck(arr: [5, 0, 3,\
    \ 0, 4, 2])\n/// [0, 1]\n/// Explanation: 0 is the smallest value, but  there\
    \ are two zeros,\n/// so we will choose the first zero, which has the smallest\
    \ index.\n/// Constraints:\n/// * 1 <= nodes.length <= 10000\n/// * 0 <= node.value\n\
    func pluck(arr: [Int]) -> [Int] {\n    return arr.filter({$0 % 2 == 0}).sorted()\n\
    \        .map { (n) -> [Int] in [n, arr.index(of: n)!] }.first ?? []\n}\n\n\n\
    func ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(pluck(arr: [4, 2, 3]) == [2, 1])\nassert(pluck(arr:\
    \ [1, 2, 3]) == [2, 1])\nassert(pluck(arr: [] as [Int]) == [] as [Int])\nassert(pluck(arr:\
    \ [5, 0, 3, 0, 4, 2]) == [0, 1])\nassert(pluck(arr: [1, 2, 3, 0, 5, 3]) == [0,\
    \ 3])\nassert(pluck(arr: [5, 4, 8, 4, 8]) == [4, 1])\nassert(pluck(arr: [7, 6,\
    \ 7, 1]) == [6, 1])\nassert(pluck(arr: [7, 9, 7, 1]) == [] as [Int])"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660013551
- exit_code: 0
  program: "\n/// \"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n/// your task is to pluck one of the nodes and return it.\n///\
    \ The plucked node should be the node with the smallest even value.\n/// If multiple\
    \ nodes with the same smallest even value are found return the node that has smallest\
    \ index.\n/// The plucked node should be returned in an array, [ smalest_value,\
    \ its index ],\n/// If there are no even values or the given array is empty, return\
    \ [].\n/// Example 1:\n/// >>> pluck(arr: [4, 2, 3])\n/// [2, 1]\n/// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n/// Example 2:\n\
    /// >>> pluck(arr: [1, 2, 3])\n/// [2, 1]\n/// Explanation: 2 has the smallest\
    \ even value, and 2 has the smallest index.\n/// Example 3:\n/// >>> pluck(arr:\
    \ [] as [Int])\n/// [] as [Int]\n/// Example 4:\n/// >>> pluck(arr: [5, 0, 3,\
    \ 0, 4, 2])\n/// [0, 1]\n/// Explanation: 0 is the smallest value, but  there\
    \ are two zeros,\n/// so we will choose the first zero, which has the smallest\
    \ index.\n/// Constraints:\n/// * 1 <= nodes.length <= 10000\n/// * 0 <= node.value\n\
    func pluck(arr: [Int]) -> [Int] {\n    let evens = arr.filter { $0 % 2 == 0 }\n\
    \    guard let smallestEven = evens.min() else { return [] }\n    guard let index\
    \ = arr.firstIndex(of: smallestEven) else { return [] }\n    return [smallestEven,\
    \ index]\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n\
    \    if left.count != right.count {\n        return false\n    }\n    for (l,\
    \ r) in zip(left, right) {\n        if l != r {\n            return false\n  \
    \      }\n    }\n    return true\n}\n            \nassert(pluck(arr: [4, 2, 3])\
    \ == [2, 1])\nassert(pluck(arr: [1, 2, 3]) == [2, 1])\nassert(pluck(arr: [] as\
    \ [Int]) == [] as [Int])\nassert(pluck(arr: [5, 0, 3, 0, 4, 2]) == [0, 1])\nassert(pluck(arr:\
    \ [1, 2, 3, 0, 5, 3]) == [0, 3])\nassert(pluck(arr: [5, 4, 8, 4, 8]) == [4, 1])\n\
    assert(pluck(arr: [7, 6, 7, 1]) == [6, 1])\nassert(pluck(arr: [7, 9, 7, 1]) ==\
    \ [] as [Int])"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660013364
- exit_code: 1
  program: "\n/// \"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n/// your task is to pluck one of the nodes and return it.\n///\
    \ The plucked node should be the node with the smallest even value.\n/// If multiple\
    \ nodes with the same smallest even value are found return the node that has smallest\
    \ index.\n/// The plucked node should be returned in an array, [ smalest_value,\
    \ its index ],\n/// If there are no even values or the given array is empty, return\
    \ [].\n/// Example 1:\n/// >>> pluck(arr: [4, 2, 3])\n/// [2, 1]\n/// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n/// Example 2:\n\
    /// >>> pluck(arr: [1, 2, 3])\n/// [2, 1]\n/// Explanation: 2 has the smallest\
    \ even value, and 2 has the smallest index.\n/// Example 3:\n/// >>> pluck(arr:\
    \ [] as [Int])\n/// [] as [Int]\n/// Example 4:\n/// >>> pluck(arr: [5, 0, 3,\
    \ 0, 4, 2])\n/// [0, 1]\n/// Explanation: 0 is the smallest value, but  there\
    \ are two zeros,\n/// so we will choose the first zero, which has the smallest\
    \ index.\n/// Constraints:\n/// * 1 <= nodes.length <= 10000\n/// * 0 <= node.value\n\
    func pluck(arr: [Int]) -> [Int] {\n    let evens = arr.enumerated().filter { $0.element\
    \ % 2 == 0 }\n    guard let minEven = evens.map({ $0.element }).min() else { return\
    \ [] }\n    return evens.filter { $0.element == minEven }.min(by: { $0.offset\
    \ < $1.offset })!\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) ->\
    \ Bool {\n    if left.count != right.count {\n        return false\n    }\n  \
    \  for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(pluck(arr: [4, 2,\
    \ 3]) == [2, 1])\nassert(pluck(arr: [1, 2, 3]) == [2, 1])\nassert(pluck(arr: []\
    \ as [Int]) == [] as [Int])\nassert(pluck(arr: [5, 0, 3, 0, 4, 2]) == [0, 1])\n\
    assert(pluck(arr: [1, 2, 3, 0, 5, 3]) == [0, 3])\nassert(pluck(arr: [5, 4, 8,\
    \ 4, 8]) == [4, 1])\nassert(pluck(arr: [7, 6, 7, 1]) == [6, 1])\nassert(pluck(arr:\
    \ [7, 9, 7, 1]) == [] as [Int])"
  status: SyntaxError
  stderr: "/tmp/tmpzd_mjjnj.swift:30:85: error: cannot convert return expression of\
    \ type 'EnumeratedSequence<[Int]>.Iterator.Element' (aka '(offset: Int, element:\
    \ Int)') to return type '[Int]'\n    return evens.filter { $0.element == minEven\
    \ }.min(by: { $0.offset < $1.offset })!\n           ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~^\n"
  stdout: ''
  timestamp: 1660013551
- exit_code: 0
  program: "\n/// \"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n/// your task is to pluck one of the nodes and return it.\n///\
    \ The plucked node should be the node with the smallest even value.\n/// If multiple\
    \ nodes with the same smallest even value are found return the node that has smallest\
    \ index.\n/// The plucked node should be returned in an array, [ smalest_value,\
    \ its index ],\n/// If there are no even values or the given array is empty, return\
    \ [].\n/// Example 1:\n/// >>> pluck(arr: [4, 2, 3])\n/// [2, 1]\n/// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n/// Example 2:\n\
    /// >>> pluck(arr: [1, 2, 3])\n/// [2, 1]\n/// Explanation: 2 has the smallest\
    \ even value, and 2 has the smallest index.\n/// Example 3:\n/// >>> pluck(arr:\
    \ [] as [Int])\n/// [] as [Int]\n/// Example 4:\n/// >>> pluck(arr: [5, 0, 3,\
    \ 0, 4, 2])\n/// [0, 1]\n/// Explanation: 0 is the smallest value, but  there\
    \ are two zeros,\n/// so we will choose the first zero, which has the smallest\
    \ index.\n/// Constraints:\n/// * 1 <= nodes.length <= 10000\n/// * 0 <= node.value\n\
    func pluck(arr: [Int]) -> [Int] {\n    var evens = [Int]()\n    var indexes =\
    \ [Int]()\n    var result = [Int]()\n    var minEven = Int.max\n    var minIndex\
    \ = Int.max\n    for (index, element) in arr.enumerated() {\n        if element\
    \ % 2 == 0 {\n            evens.append(element)\n            indexes.append(index)\n\
    \        }\n    }\n    for (index, element) in evens.enumerated() {\n        if\
    \ element < minEven {\n            minEven = element\n            minIndex = indexes[index]\n\
    \        }\n    }\n    if minEven == Int.max {\n        return []\n    }\n   \
    \ result.append(minEven)\n    result.append(minIndex)\n    return result\n}\n\n\
    \nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(pluck(arr: [4, 2, 3]) == [2, 1])\nassert(pluck(arr:\
    \ [1, 2, 3]) == [2, 1])\nassert(pluck(arr: [] as [Int]) == [] as [Int])\nassert(pluck(arr:\
    \ [5, 0, 3, 0, 4, 2]) == [0, 1])\nassert(pluck(arr: [1, 2, 3, 0, 5, 3]) == [0,\
    \ 3])\nassert(pluck(arr: [5, 4, 8, 4, 8]) == [4, 1])\nassert(pluck(arr: [7, 6,\
    \ 7, 1]) == [6, 1])\nassert(pluck(arr: [7, 9, 7, 1]) == [] as [Int])"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660013551
