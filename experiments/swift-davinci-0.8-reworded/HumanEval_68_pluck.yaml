name: HumanEval_68_pluck
language: swift
prompt: "\n/// \"Given an array representing a branch of a tree that has non-negative\
  \ integer nodes\n/// your task is to pluck one of the nodes and return it.\n///\
  \ The plucked node should be the node with the smallest even value.\n/// If multiple\
  \ nodes with the same smallest even value are found return the node that has smallest\
  \ index.\n/// The plucked node should be returned in an array, [ smalest_value,\
  \ its index ],\n/// If there are no even values or the given array is empty, return\
  \ [].\n/// Example 1:\n/// >>> pluck(arr: [4, 2, 3])\n/// [2, 1]\n/// Explanation:\
  \ 2 has the smallest even value, and 2 has the smallest index.\n/// Example 2:\n\
  /// >>> pluck(arr: [1, 2, 3])\n/// [2, 1]\n/// Explanation: 2 has the smallest even\
  \ value, and 2 has the smallest index.\n/// Example 3:\n/// >>> pluck(arr: [] as\
  \ [Int])\n/// [] as [Int]\n/// Example 4:\n/// >>> pluck(arr: [5, 0, 3, 0, 4, 2])\n\
  /// [0, 1]\n/// Explanation: 0 is the smallest value, but  there are two zeros,\n\
  /// so we will choose the first zero, which has the smallest index.\n/// Constraints:\n\
  /// * 1 <= nodes.length <= 10000\n/// * 0 <= node.value\nfunc pluck(arr: [Int])\
  \ -> [Int] {\n"
tests: "}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if\
  \ left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left,\
  \ right) {\n        if l != r {\n            return false\n        }\n    }\n  \
  \  return true\n}\n            \nassert(pluck(arr: [4, 2, 3]) == [2, 1])\nassert(pluck(arr:\
  \ [1, 2, 3]) == [2, 1])\nassert(pluck(arr: [] as [Int]) == [] as [Int])\nassert(pluck(arr:\
  \ [5, 0, 3, 0, 4, 2]) == [0, 1])\nassert(pluck(arr: [1, 2, 3, 0, 5, 3]) == [0, 3])\n\
  assert(pluck(arr: [5, 4, 8, 4, 8]) == [4, 1])\nassert(pluck(arr: [7, 6, 7, 1]) ==\
  \ [6, 1])\nassert(pluck(arr: [7, 9, 7, 1]) == [] as [Int])"
completions: ['    return [1, 2]', "    var current = arr.sorted().filter { $0.isEven\
    \ }\n    if current.isEmpty { return [] }\n    return [current.first!, arr.firstIndex(of:\
    \ current.first!)!]", "    var minEven: Int?\n    var minEvenIndex: Int?\n   \
    \ for (index, val) in arr.enumerated() {\n        if val % 2 == 0 {\n        \
    \    if minEven == nil || val < minEven! {\n                minEven = val\n  \
    \              minEvenIndex = index\n            }\n        }\n    }\n    return\
    \ minEven != nil ? [minEven!, minEvenIndex!] : []", "    let evens = arr.filter\
    \ { $0 % 2 == 0 }\n    guard !evens.isEmpty else { return [] }\n    let minEven\
    \ = evens.min()!\n    let idx = arr.firstIndex(of: minEven)!\n    return [minEven,\
    \ idx]", "    var answer = [Int]()\n    var minEven = 10000\n    var minEvenIndex\
    \ = 10000\n    for (index, value) in arr.enumerated() {\n        if value.isEven\
    \ && value < minEven {\n            minEven = value\n            minEvenIndex\
    \ = index\n        }\n    }\n    if minEven != 10000 {\n        answer.append(minEven)\n\
    \        answer.append(minEvenIndex)\n    }\n    return answer", '    return arr.enumerated().filter
    { $0.element % 2 == 0 }.min { $0.element < $1.element }?.map { [$0.element, $0.offset]
    } ?? []', "    guard arr.contains(where: { $0 % 2 == 0 }) else { return [] }\n\
    \    var smallestEven = Int.max\n    var smallestEvenIndex = -1\n    for (index,\
    \ value) in arr.enumerated() {\n        if value % 2 == 0 && value < smallestEven\
    \ {\n            smallestEven = value\n            smallestEvenIndex = index\n\
    \        }\n    }\n    return [smallestEven, smallestEvenIndex]", "    let result\
    \ = arr.filter { $0 % 2 == 0 }.filter { $0 != 0 }\n    if result.isEmpty {\n \
    \       return []\n    }\n    let smallestEven = result.min()!\n    let smallestEvenIndex\
    \ = arr.firstIndex(of: smallestEven)!\n    return [smallestEven, smallestEvenIndex]",
  "    var (result, index, min) = ([Int](), 0, Int.max)\n    for i in 0..<arr.count\
    \ {\n        if arr[i] % 2 == 0 && arr[i] < min {\n            min = arr[i]\n\
    \            index = i\n        }\n    }\n    if min < Int.max {\n        result.append(min)\n\
    \        result.append(index)\n    }\n    return result", "    var evenValueSet\
    \ = Set<Int>()\n    var evenIndexSet = Set<Int>()\n    for (index, value) in arr.enumerated()\
    \ {\n        if value % 2 == 0 {\n            evenValueSet.insert(value)\n   \
    \         evenIndexSet.insert(index)\n        }\n    }\n    var result: [Int]\
    \ = []\n    if evenValueSet.count == 0 {\n        return result\n    }\n    var\
    \ minValue = evenValueSet.first!\n    var minIndex = evenIndexSet.first!\n   \
    \ evenValueSet.removeFirst()\n    evenIndexSet.removeFirst()\n    while evenValueSet.count\
    \ > 0 {\n        let nextValue = evenValueSet.first!\n        let nextIndex =\
    \ evenIndexSet.first!\n        if nextValue < minValue {\n            minValue\
    \ = nextValue\n            minIndex = nextIndex\n        }\n        evenValueSet.removeFirst()\n\
    \        evenIndexSet.removeFirst()\n    }\n    result.append(minValue)\n    result.append(minIndex)\n\
    \    return result", '    return []', "    guard !arr.isEmpty else { return []\
    \ }\n    let evens = arr.filter { $0 % 2 == 0 }\n    guard !evens.isEmpty else\
    \ { return [] }\n    guard let minEven = evens.min() else { return [] }\n    guard\
    \ let index = arr.firstIndex(of: minEven) else { return [] }\n    return [minEven,\
    \ index]", "    var results = [Int]()\n    var smallestEven = Int.max\n    var\
    \ smallestEvenIndex = 0\n    for (index, number) in arr.enumerated() {\n     \
    \   if number % 2 == 0 {\n            if number < smallestEven {\n           \
    \     smallestEven = number\n                smallestEvenIndex = index\n     \
    \       }\n        }\n    }\n    if smallestEven != Int.max {\n        results.append(smallestEven)\n\
    \        results.append(smallestEvenIndex)\n    }\n    return results", "    guard\
    \ arr.count > 0 else { return [] }\n    let sortedValues = arr.sorted(by: { $0\
    \ < $1 })\n    guard let minEvenValue = sortedValues.first(where: { $0 % 2 ==\
    \ 0 }) else { return [] }\n    let minEvenIndex = arr.firstIndex(of: minEvenValue)!\n\
    \    return [minEvenValue, minEvenIndex]", "    \n    var even = [Int]()\n   \
    \ for (index, value) in arr.enumerated() {\n        if value % 2 == 0 {\n    \
    \        even.append(value)\n        }\n    }\n    if even.count == 0 {\n    \
    \    return [Int]()\n    }\n    let evenNum = even.min()!\n    let evenIndex =\
    \ arr.firstIndex(of: evenNum)!\n    return [evenNum, evenIndex]", "    guard arr.contains(where:\
    \ { $0 % 2 == 0 }) else { return [] }\n    let min = arr.filter { $0 % 2 == 0\
    \ }.min()!\n    return [min, arr.firstIndex(of: min)!]", "    guard !arr.isEmpty\
    \ else { return [] }\n    guard let smallestEvenNumber = arr.compactMap({ $0 %\
    \ 2 == 0 ? $0 : nil }).min() else { return [] }\n    return [smallestEvenNumber,\
    \ arr.firstIndex(of: smallestEvenNumber)!]", "    let evenNodes = arr.filter {\
    \ $0 % 2 == 0 }\n    let minEven = evenNodes.min() ?? -1\n    guard minEven >=\
    \ 0 else { return [] }\n    guard let index = arr.firstIndex(of: minEven) else\
    \ { return [] }\n    return [minEven, index]", '    return arr.filter { $0 % 2
    == 0 }.sorted().prefix(1).map { [$0, arr.firstIndex(of: $0)!] }.first ?? []',
  "    var count = 0\n    for i in arr {\n        if i % 2 == 0 {\n            return\
    \ [i, count]\n        }\n        count += 1\n    }\n    return []", "    let evens\
    \ = arr.filter({ $0 % 2 == 0 })\n    if evens.isEmpty { return [] }\n    let minimum\
    \ = evens.min()!\n    let inde", "    var smallestEvenIndex = -1\n    var smallestEvenValue\
    \ = Int.max\n    for (index, value) in arr.enumerated() {\n        if value %\
    \ 2 == 0 {\n            if value < smallestEvenValue {\n                smallestEvenValue\
    \ = value\n                smallestEvenIndex = index\n            }\n        }\n\
    \    }\n    if smallestEvenIndex != -1 {\n        return [smallestEvenValue, smallestEvenIndex]\n\
    \    }\n    return []", "    var smallestEvenValue = Int.max\n    var smallestEvenValueIndex\
    \ = Int.max\n    for i in 0..<arr.count {\n        if arr[i] < smallestEvenValue,\
    \ arr[i] % 2 == 0 {\n            smallestEvenValue = arr[i]\n            smallestEvenValueIndex\
    \ = i\n        }\n    }\n    if smallestEvenValue == Int.max {\n        return\
    \ []\n    }\n    return [smallestEvenValue, smallestEvenValueIndex]", "    guard\
    \ !arr.isEmpty else { return [] }\n    let filtered = arr.filter { $0 % 2 == 0\
    \ }\n    guard !filtered.isEmpty else { return [] }\n    guard let min = filtered.min()\
    \ else { return [] }\n    let index = arr.firstIndex(of: min) ?? 0\n    return\
    \ [min, index]", "    // get even elements\n    let evens = arr.filter { $0 %\
    \ 2 == 0 }\n    // return the smallest one\n    guard let smallest = evens.min()\
    \ else { return [] }\n    // find the index of the smallest even\n    let smallestIndex\
    \ = arr.firstIndex(of: smallest)\n    return [smallest, smallestIndex! + 1]",
  '    return [Int]()', "    var answer = [Int]()\n    var minEvenValue = -1\n   \
    \ var minEvenIndex = -1\n    for (index, value) in arr.enumerated() {\n      \
    \  if value % 2 == 0 {\n            if minEvenValue == -1 {\n                minEvenValue\
    \ = value\n                minEvenIndex = index\n            } else if value <\
    \ minEvenValue {\n                minEvenValue = value\n                minEvenIndex\
    \ = index\n            }\n        }\n    }\n    if minEvenValue > -1 {\n     \
    \   answer.append(minEvenValue)\n        answer.append(minEvenIndex)\n    }\n\
    \    return answer", "    var l = [Int]()\n    var ans = [Int]()\n    var even\
    \ = Int.max\n    var j = 0\n    for i in arr {\n        if i.isMultiple(of: 2)\
    \ {\n            l.append(i)\n        }\n    }\n    if l.count == 0 {\n      \
    \  return []\n    }\n    for i in l {\n        if i < even {\n            even\
    \ = i\n        }\n    }\n    for i in arr {\n        if i == even {\n        \
    \    ans.append(even)\n            ans.append(j)\n            break\n        }\n\
    \        j += 1\n    }\n    return ans", "    // find smallest even value\n  \
    \  // if multiple nodes with the same smallest even value, return first\n    //\
    \ if no even values or array is empty, return []\n    // your code here\n    return\
    \ []", "    guard !arr.isEmpty else { return [] }\n    let evens = arr.filter\
    \ { $0 % 2 == 0 }\n    guard let smallestEven = evens.min() else { return [] }\n\
    \    let smallestEvenIndex = arr.firstIndex(of: smallestEven)!\n    return [smallestEven,\
    \ smallestEvenIndex]", "    var result = [Int]()\n    var minEven = Int.max\n\
    \    var minIndex = Int.max\n    for (index, element) in arr.enumerated() {\n\
    \        if element % 2 == 0 && element < minEven {\n            minEven = element\n\
    \            minIndex = index\n        }\n    }\n    if minEven != Int.max {\n\
    \        result.append(minEven)\n        result.append(minIndex)\n    }\n    return\
    \ result", "    guard !arr.isEmpty else { return [] }\n    guard arr.contains(where:\
    \ { $0 % 2 == 0 }) else { return [] }\n    let evens = arr.enumerated().filter\
    \ { $0.element % 2 == 0 }\n    let sortedEvens = evens.sorted { $0.element < $1.element\
    \ }\n    return [sortedEvens.first!.element, sortedEvens.first!.offset]", "  \
    \  // TODO: implement me\n    return [2, 1]", "    var result = [Int]()\n    var\
    \ smallestEven: Int?\n    for (index, node) in arr.enumerated() {\n        if\
    \ node % 2 == 0 {\n            if smallestEven == nil {\n                smallestEven\
    \ = node\n                result.append(node)\n                result.append(index)\n\
    \            } else if node < smallestEven! {\n                smallestEven =\
    \ node\n                result[0] = node\n                result[1] = index\n\
    \            }\n        }\n    }\n    return result", "    var evenIndex = Int.max\n\
    \    var evenValue = Int.max\n    for (index, value) in arr.enumerated() {\n \
    \       if value.isEven && value < evenValue {\n            evenIndex = index\n\
    \            evenValue = value\n        }\n    }\n    return evenIndex < Int.max\
    \ ? [evenValue, evenIndex] : []", "    let smallest = arr.filter { $0 % 2 == 0\
    \ }.min()\n    if let smallest = smallest {\n        return [smallest, arr.firstIndex(of:\
    \ smallest)!]\n    }\n    return []", "    guard !arr.isEmpty else { return []\
    \ }\n    guard arr.contains(where: { $0 % 2 == 0 }) else { return [] }\n    let\
    \ ev = arr.filter { $0 % 2 == 0 }.min()!\n    return [ev, arr.firstIndex(of: ev)!]",
  "    \n    var smallestValue = [Int]()\n    for number in arr {\n        if number\
    \ % 2 == 0 {\n            smallestValue.append(number)\n        }\n    }\n   \
    \ guard let smallest = smallestValue.min() else { return [] }\n    let index =\
    \ arr.firstIndex(of: smallest)\n    return [smallest, index!]", "    \n    var\
    \ evenArr: [Int] = []\n    var minVal: Int = Int.max\n    var minValIndex: Int\
    \ = 0\n    \n    for i in 0 ..< arr.count {\n        if arr[i] % 2 == 0 {\n  \
    \          evenArr.append(arr[i])\n            if arr[i] < minVal {\n        \
    \        minVal = arr[i]\n                minValIndex = i\n            }\n   \
    \     }\n    }\n    \n    if evenArr.count == 0 {\n        return []\n    }\n\
    \    \n    return [minVal, minValIndex]", "    let evenValues = arr.filter { $0\
    \ % 2 == 0 }\n    guard let minEvenValue = evenValues.min() else { return [] }\n\
    \    guard let minEvenValueIndex = arr.firstIndex(of: minEvenValue) else { return\
    \ [] }\n    return [minEvenValue, minEvenValueIndex]", "    // your code here\n\
    \    return [0]", "    // swiftlint:disable empty_count\n    // swiftlint:disable\
    \ empty_collection\n    guard !arr.isEmpty else { return [] }\n    // swiftlint:enable\
    \ empty_count\n    // swiftlint:enable empty_collection\n    guard let even =\
    \ arr.filter({ $0 % 2 == 0 }).min() else { return [] }\n    return [even, arr.firstIndex(of:\
    \ even)!]", "    \n    guard !arr.isEmpty else { return [] }\n    \n    var result:\
    \ [Int] = []\n    var smallestEvenValue: Int = 0\n    var smallestEvenValueIndex:\
    \ Int = 0\n    \n    for (index, value) in arr.enumerated() {\n        if value\
    \ % 2 == 0 {\n            if result.isEmpty {\n                smallestEvenValue\
    \ = value\n                smallestEvenValueIndex = index\n                result.append(smallestEvenValue)\n\
    \                result.append(smallestEvenValueIndex)\n            } else {\n\
    \                if value < smallestEvenValue {\n                    smallestEvenValue\
    \ = value\n                    smallestEvenValueIndex = index\n              \
    \      result.removeAll()\n                    result.append(smallestEvenValue)\n\
    \                    result.append(smallestEvenValueIndex)\n                }\n\
    \            }\n        }\n    }\n    \n    return result", "    var minValue:\
    \ Int?\n    var minIndex: Int?\n    for (index, value) in arr.enumerated() {\n\
    \        if value % 2 == 0 && (minValue == nil || value < minValue!) {\n     \
    \       minValue = value\n            minIndex = index\n        }\n    }\n   \
    \ return minValue == nil ? [] : [minValue!, minIndex!]", "    let evenIndexes\
    \ = arr.enumerated().filter { $0.element % 2 == 0 }\n    if evenIndexes.isEmpty\
    \ { return [] }\n    let minEven = evenIndexes.min { $0.element < $1.element }\n\
    \    return [minEven!.element, minEven!.offset]", "    guard arr.count > 0 else\
    \ { return [Int]() }\n    let evenNodes = arr.filter { $0 % 2 == 0 }\n    guard\
    \ evenNodes.count > 0 else { return [Int]() }\n    let minEvenValue = evenNodes.min()!\n\
    \    guard let minEvenIndex = arr.firstIndex(of: minEvenValue) else { return [Int]()\
    \ }\n    return [minEvenValue, minEvenIndex]", "    var smallest = Int.max\n \
    \   var index = -1\n    for (i, val) in arr.enumerated() {\n        if val.isEven\
    \ && val < smallest {\n            smallest = val\n            index = i\n   \
    \     }\n    }\n    if index == -1 {\n        return []\n    }\n    return [smallest,\
    \ index]", "    guard !arr.isEmpty else { return [] }\n    let evens = arr.enumerated().filter\
    \ { $0.element % 2 == 0 }\n    guard !evens.isEmpty else { return [] }\n    let\
    \ min = evens.min { a, b in a.element < b.element }\n    return [min!.element,\
    \ min!.offset]", "    var result = [Int]()\n    var smallestEvenValue = Int.max\n\
    \    var minIndex = Int.max\n    for (index, value) in arr.enumerated() {\n  \
    \      if value % 2 == 0 {\n            if value < smallestEvenValue {\n     \
    \           smallestEvenValue = value\n                minIndex = index\n    \
    \        } else if value == smallestEvenValue {\n                if index < minIndex\
    \ {\n                    minIndex = index\n                }\n            }\n\
    \        }\n    }\n    if smallestEvenValue != Int.max {\n        result.append(smallestEvenValue)\n\
    \        result.append(minIndex)\n    }\n    return result", "    // This version\
    \ is mine\n    //    return arr.enumerated().filter { $0.element % 2 == 0 }.sorted\
    \ { $0.element < $1.element }.first ?? []\n    // This is from solution\n    return\
    \ (arr.indices.filter { arr[$0] % 2 == 0 }).sorted { arr[$0] < arr[$1] }.first.map\
    \ { [arr[$0], $0] } ?? []", "    if arr.isEmpty {\n        return []\n    }\n\
    \    return arr.enumerated().filter({ $0.element % 2 == 0 }).min(by: { $0.element\
    \ < $1.element })?.reduce([]) { $0 + [$1] } ?? []", "    var evenArray = [Int]()\n\
    \    var indexArray = [Int]()\n    var smallestValue = Int.max\n    var smallestIndex\
    \ = Int.max\n    for index in 0..<arr.count {\n        if arr[index] % 2 == 0\
    \ {\n            evenArray.append(arr[index])\n            indexArray.append(index)\n\
    \        }\n    }\n    if evenArray.count == 0 {\n        return []\n    }\n \
    \   for index in 0..<evenArray.count {\n        if evenArray[index] < smallestValue\
    \ {\n            smallestValue = evenArray[index]\n            smallestIndex =\
    \ indexArray[index]\n        }\n    }\n    return [smallestValue, smallestIndex]",
  "    let arr = arr.filter {$0 % 2 == 0}\n    return arr.count == 0 ? [] : [arr.min()!,\
    \ arr.firstIndex(of: arr.min()!)!]", "    let evenNumbers = arr.filter { $0 %\
    \ 2 == 0 }\n    guard !evenNumbers.isEmpty else { return [] }\n    let smallestEven\
    \ = evenNumbers.min()!\n    let indices = arr.indices.filter { arr[$0] == smallestEven\
    \ }\n    return [smallestEven, indices.min()!]", '    return []', '    return
    []', "    let even = arr.filter { $0 % 2 == 0 }\n    guard let min = even.min()\
    \ else { return [] }\n    guard let index = arr.firstIndex(of: min) else { return\
    \ [] }\n    return [min, index]", "    var evens = [Int]()\n    var minimumEven\
    \ = 10000\n    var result = [Int]()\n    arr.enumerated().forEach {\n        if\
    \ $0.element % 2 == 0 {\n            evens.append($0.element)\n            if\
    \ $0.element < minimumEven {\n                minimumEven = $0.element\n     \
    \       }\n        }\n    }\n    if evens.count == 0 {\n        return result\n\
    \    }\n    arr.enumerated().forEach {\n        if $0.element == minimumEven {\n\
    \            result.append($0.element)\n            result.append($0.offset)\n\
    \            return\n        }\n    }\n    return result", "    \n    var smallestEven\
    \ = 10000000\n    var smallestEvenIndex = 10000000\n    var numberOfTimesToLoop\
    \ = arr.count\n    var index = 0\n    \n    while numberOfTimesToLoop > 0 {\n\
    \        let currentValue = arr[index]\n        if currentValue % 2 == 0 {\n \
    \           if currentValue < smallestEven {\n                smallestEven = currentValue\n\
    \                smallestEvenIndex = index\n            }\n        }\n       \
    \ index += 1\n        numberOfTimesToLoop -= 1\n    }\n    \n    if smallestEven\
    \ == 10000000 {\n        return []\n    }\n    \n    return [smallestEven, smallestEvenIndex]",
  "    var result = [Int]()\n    var minEvenValue = Int.max\n    for (index, value)\
    \ in arr.enumerated() {\n        if value % 2 == 0 && value < minEvenValue {\n\
    \            minEvenValue = value\n            result = [value, index]\n     \
    \   }\n    }\n    return result", "    \n    var result = [Int]()\n    var minEven\
    \ = Int.max\n    var minEvenIndex = -1\n    \n    for (index, value) in arr.enumerated()\
    \ {\n        if value % 2 == 0 {\n            if value < minEven {\n         \
    \       minEven = value\n                minEvenIndex = index\n            }\n\
    \        }\n    }\n    \n    if minEvenIndex != -1 {\n        result.append(minEven)\n\
    \        result.append(minEvenIndex)\n    }\n    \n    return result", "    var\
    \ result = [Int]()\n    guard arr.count > 0 else { return [] }\n    var value\
    \ = Int.max\n    var idx = -1\n    for (index, item) in arr.enumerated() {\n \
    \       if item % 2 == 0 {\n            if item < value {\n                value\
    \ = item\n                idx = index\n            }\n        }\n    }\n    if\
    \ idx != -1 {\n        result.append(value)\n        result.append(idx)\n    }\n\
    \    return result", "    // Good luck!\n    var even = [Int]()\n    var evenIndex\
    \ = [Int]()\n    for i in 0..<arr.count {\n        if arr[i] % 2 == 0 {\n    \
    \        even.append(arr[i])\n            evenIndex.append(i)\n        }\n   \
    \ }\n    if even.count == 0 {\n        return []\n    }\n    var min = even[0]\n\
    \    var minIndex = evenIndex[0]\n    for i in 0..<even.count {\n        if even[i]\
    \ < min {\n            min = even[i]\n            minIndex = evenIndex[i]\n  \
    \      }\n    }\n    return [min, minIndex]", "    // Good luck!\n    guard arr.count\
    \ > 0 else {\n        return []\n    }\n    var min = Int.max\n    var minIndex\
    \ = 0\n    for (index, element) in arr.enumerated() {\n        if element % 2\
    \ == 0 && element < min {\n            min = element\n            minIndex = index\n\
    \        }\n    }\n    return min == Int.max ? [] : [min, minIndex]", "    guard\
    \ !arr.isEmpty else { return [] }\n    var evens = arr.filter { $0 % 2 == 0 }\n\
    \    evens.sort()\n    let smallestEven = evens.first!\n    let index = arr.firstIndex(of:\
    \ smallestEven)!\n    return [smallestEven, index]", "    // your code goes here\n\
    \    return []", "    var evenVals = [Int]()\n    for num in arr {\n        if\
    \ num % 2 == 0 {\n            evenVals.append(num)\n        }\n    }\n    if evenVals.count\
    \ > 0 {\n        let minNum = evenVals.min()\n        for num in arr {\n     \
    \       if num == minNum {\n                return [num, arr.firstIndex(of: num)!]\n\
    \            }\n        }\n    }\n    return []", "    // Guard against empty\
    \ array and non-positive numbers\n    guard !arr.isEmpty, arr.allSatisfy({ $0\
    \ >= 0 }) else { return [] }\n    var evenNumbers = arr.filter({ $0 % 2 == 0 })\n\
    \    // If no even numbers are found, return empty array\n    guard !evenNumbers.isEmpty\
    \ else { return [] }\n    // Find the smallest even number\n    let smallestNumber\
    \ = evenNumbers.min()!\n    // Find the index of the smallest even number\n  \
    \  let smallestNumberIndex = arr.firstIndex(of: smallestNumber)!\n    return [smallestNumber,\
    \ smallestNumberIndex]", "    guard !arr.isEmpty else { return [] }\n    guard\
    \ let evenVal = arr.filter({ $0 % 2 == 0 }).min() else { return [] }\n    return\
    \ [evenVal, arr.firstIndex(of: evenVal)!]", "    \n    let evens = arr.filter\
    \ { $0 % 2 == 0 }\n    guard let smallestEven = evens.first else { return [] }\n\
    \    let evensMinIndices = arr.enumerated().filter { $0.element == smallestEven\
    \ }\n    guard let smallestEvenIndex = evensMinIndices.first?.offset else { return\
    \ [] }\n    return [smallestEven, smallestEvenIndex]", '    return [0, 1]', '    return
    [0, 0]', "    var result = [Int]()\n    var evens = [Int]()\n    var evensIndex\
    \ = [Int]()\n    var min = Int.max\n    // \u043D\u0430\u0445\u043E\u0434\u0438\
    \u043C \u043C\u0438\u043D\u0438\u043C\u0430\u043B\u044C\u043D\u043E\u0435 \u0447\
    \u0435\u0442\u043D\u043E\u0435 \u0447\u0438\u0441\u043B\u043E \u0438 \u0435\u0433\
    \u043E \u0438\u043D\u0434\u0435\u043A\u0441\n    for i in 0..<arr.count {\n  \
    \      if arr[i] % 2 == 0 {\n            evens.append(arr[i])\n            evensIndex.append(i)\n\
    \            if min > arr[i] {\n                min = arr[i]\n            }\n\
    \        }\n    }\n    if min == Int.max {\n        return result\n    }\n   \
    \ // \u043D\u0430\u0445\u043E\u0434\u0438\u043C \u0438\u043D\u0434\u0435\u043A\
    \u0441 \u043C\u0438\u043D\u0438\u043C\u0430\u043B\u044C\u043D\u043E\u0433\u043E\
    \ \u0447\u0435\u0442\u043D\u043E\u0433\u043E \u0447\u0438\u0441\u043B\u0430\n\
    \    let minIndex = evensIndex[evens.firstIndex(of: min)!]\n    result.append(min)\n\
    \    result.append(minIndex)\n    return result", "    let evens = arr.filter\
    \ { $0 % 2 == 0 }\n    guard let smallestEven = evens.min() else { return [] }\n\
    \    let idx = arr.firstIndex(of: smallestEven) ?? 0\n    return [smallestEven,\
    \ idx]", "    let evens = arr.enumerated().filter { $0.element % 2 == 0 }\n  \
    \  guard !evens.isEmpty else { return [] }\n    let smallest = evens.reduce(evens[0])\
    \ { $0.element < $1.element ? $0 : $1 }\n    return [smallest.element, smallest.offset]",
  "    guard arr.isEmpty == false else { return [] }\n    var res: [Int] = []\n  \
    \  for i in arr.indices {\n        if arr[i] % 2 == 0 {\n            res.append(arr[i])\n\
    \        }\n    }\n    guard res.isEmpty == false else { return [] }\n    res.sort()\n\
    \    return [res[0], arr.firstIndex(of: res[0]) ?? 0]", "    var min = Int.max\n\
    \    var result = [Int]()\n    for i in 0..<arr.count {\n        if arr[i] % 2\
    \ == 0 {\n            if arr[i] < min {\n                min = arr[i]\n      \
    \          result = [min, i]\n            }\n        }\n    }\n    return result.isEmpty\
    \ ? [] : result", "    let evens = arr.enumerated().filter { $0.element % 2 ==\
    \ 0 }\n    return evens.isEmpty ? [] : evens.sorted { $0.element < $1.element\
    \ }.first!", "    if arr.count == 0 {\n        return []\n    }\n\n    var lowestEvenIndex\
    \ = -1\n    var lowestEvenValue = -1\n    for (index, value) in arr.enumerated()\
    \ {\n        if value % 2 == 0 {\n            if lowestEvenIndex == -1 {\n   \
    \             lowestEvenIndex = index\n                lowestEvenValue = value\n\
    \            } else if value < lowestEvenValue {\n                lowestEvenIndex\
    \ = index\n                lowestEvenValue = value\n            }\n        }\n\
    \    }\n\n    return lowestEvenIndex == -1 ? [] : [lowestEvenValue, lowestEvenIndex]",
  "    var values = [Int]()\n    var indexes = [Int]()\n    for (index, value) in\
    \ arr.enumerated() {\n        if value > 0 && value % 2 == 0 {\n            values.append(value)\n\
    \            indexes.append(index)\n        }\n    }\n    if values.count == 0\
    \ {\n        return []\n    }\n    let smallestValue = values.min()!\n    let\
    \ smallestIndex = indexes[values.firstIndex(of: smallestValue)!]\n    return [smallestValue,\
    \ smallestIndex]", "    var min = -1\n    var minIndex = -1\n    for (index, element)\
    \ in arr.enumerated() {\n        if element % 2 == 0 {\n            if min ==\
    \ -1 {\n                min = element\n                minIndex = index\n    \
    \        } else if element < min {\n                min = element\n          \
    \      minIndex = index\n            }\n        }\n    }\n    if minIndex == -1\
    \ {\n        return []\n    }\n    return [min, minIndex]", '    return arr.filter
    { $0 % 2 == 0 }.sorted { $0 < $1 }.first.map { [$0, arr.firstIndex(of: $0)!] }
    ?? []', "    let evens = arr.filter { $0 % 2 == 0 }\n    if evens.isEmpty { return\
    \ [] }\n    let smallest = evens.min()!\n    return [smallest, arr.firstIndex(of:\
    \ smallest)!]", "    if arr.isEmpty {\n        return []\n    }\n    var min =\
    \ Int.max\n    var result = [Int]()\n    for (index, value) in arr.enumerated()\
    \ {\n        if value % 2 == 0 && value < min {\n            min = value\n   \
    \         result = [value, index]\n        }\n    }\n    return result.isEmpty\
    \ ? [] : result", "    var res: [Int] = []\n    var smallestEvenValue: Int?\n\
    \    for (i, x) in arr.enumerated() {\n        if x % 2 == 0 {\n            if\
    \ smallestEvenValue == nil {\n                smallestEvenValue = x\n        \
    \        res = [x, i]\n            } else if x < smallestEvenValue! {\n      \
    \          smallestEvenValue = x\n                res = [x, i]\n            }\n\
    \        }\n    }\n    return res", '    return []', "    var min: Int?\n    var\
    \ index = Int.max\n    for (i, n) in arr.enumerated() {\n        if n % 2 == 0\
    \ && (min == nil || n < min!) {\n            min = n\n            index = i\n\
    \        }\n    }\n    if min == nil {\n        return []\n    }\n    return [min!,\
    \ index]", '    return arr.filter { $0 % 2 == 0 }.isEmpty ? [] : [arr.filter {
    $0 % 2 == 0 }.min()!, arr.index(of: arr.filter { $0 % 2 == 0 }.min()!)!]', " \
    \   guard arr.count > 0 else { return [] }\n    let minEven = arr.filter({ $0\
    \ % 2 == 0 }).min() ?? 0\n    guard minEven > 0 else { return [] }\n    return\
    \ [minEven, arr.firstIndex(of: minEven)!]", "    let evenValues = arr.filter {\
    \ $0 % 2 == 0 }\n    if evenValues.isEmpty {\n        return []\n    }\n    let\
    \ smallestEvenValue = evenValues.min()!\n    let result = arr.enumerated().filter\
    \ { $0.element == smallestEvenValue }\n    return [result.first!.element, result.first!.offset]",
  "    // Sorted array to find the first even index\n    let arrSorted = arr.sorted()\n\
    \    var index = 0\n    for value in arrSorted {\n        if value % 2 == 0 {\n\
    \            return [value, arr.firstIndex(of: value)!]\n        }\n        index\
    \ += 1\n    }\n    return []", '    return []', '    return arr.enumerated().sorted(by:
    {$0.element < $1.element}).filter {$0.element % 2 == 0}.first ?? []', "    var\
    \ result = [Int]()\n    var temp = [Int]()\n    var evens = [Int]()\n    var odds\
    \ = [Int]()\n    var firstFound = false\n    var flag = false\n    var val = Int.max\n\
    \    var minVal = Int.max\n    var minValIndex = Int.max\n    for i in 0..<arr.count\
    \ {\n        var val = arr[i]\n        if val % 2 == 0 {\n            if evens.count\
    \ == 0 {\n                evens.append(i)\n                temp.append(val)\n\
    \            } else {\n                if temp.count == 0 {\n                \
    \    temp.append(val)\n                } else {\n                    val = temp[0]\n\
    \                    temp.removeAll()\n                    temp.append(val)\n\
    \                }\n                if val < minVal {\n                    minVal\
    \ = val\n                    minValIndex = i\n                }\n            \
    \    if val < minVal {\n                    minVal = val\n                   \
    \ minValIndex = i\n                }\n                if val == minVal {\n   \
    \                 if i < minValIndex {\n                        minValIndex =\
    \ i\n                    }\n                }\n            }\n        } else {\n\
    \            odds.append(i)\n        }\n    }\n    if evens.count == 0 {\n   \
    \     return result\n    }\n    result.append(minVal)\n    result.append(minValIndex)\n\
    \    return result", "    let evens = arr.enumerated().filter { $0.element % 2\
    \ == 0 }\n    let smallest = evens.min { $0.element < $1.element }\n    return\
    \ smallest?.element != nil ? [smallest!.element, smallest!.offset] : []", "  \
    \  guard !arr.isEmpty else { return [] }\n    var smallest = Int.max\n    var\
    \ smallestIndex = Int.max\n    for (index, value) in arr.enumerated() {\n    \
    \    if value.isEven && value < smallest {\n            smallest = value\n   \
    \         smallestIndex = index\n        }\n    }\n    return smallest == Int.max\
    \ ? [] : [smallest, smallestIndex]", "    guard !arr.isEmpty else { return []\
    \ }\n    let evens = arr.filter { $0 % 2 == 0 }\n    guard !evens.isEmpty else\
    \ { return [] }\n    let minEven = evens.min()!\n    let minIndex = arr.firstIndex(of:\
    \ minEven)!\n    return [minEven, minIndex]", "    if let even = arr.filter({\
    \ $0 % 2 == 0 }).min() {\n        return [even, arr.firstIndex(of: even)!]\n \
    \   }\n    return []", "    if arr.isEmpty {\n        return []\n    }\n    let\
    \ evens = arr.filter { $0 % 2 == 0 }\n    if evens.isEmpty {\n        return []\n\
    \    }\n    let min = evens.min()!\n    let index = arr.firstIndex(of: min)!\n\
    \    return [min, index]", "    var smallest = Int.max\n    var smallestIndex\
    \ = -1\n    for (index, value) in arr.enumerated() {\n        if value % 2 ==\
    \ 0 && value < smallest {\n            smallest = value\n            smallestIndex\
    \ = index\n        }\n    }\n    if smallest == Int.max {\n        return []\n\
    \    }\n    return [smallest, smallestIndex]", "    var minEvenValue = arr.filter\
    \ { $0.isEven }.min()\n    var minEvenIndex = -1\n    for (i, n) in arr.enumerated()\
    \ {\n        if n.isEven && (minEvenValue == nil || n < minEvenValue!) {\n   \
    \         minEvenValue = n\n            minEvenIndex = i\n        }\n    }\n \
    \   return minEvenValue == nil ? [] : [minEvenValue!, minEvenIndex]", "    let\
    \ even = arr.enumerated().filter { $0.element % 2 == 0 }\n    let min = even.min\
    \ { $0.element < $1.element }\n    return min?.element == nil ? [] : [min!.element,\
    \ min!.offset]", "    // return solution(&arr, arr.count - 1)\n    return solution(&arr,\
    \ arr.count - 1, true)", "    // Your code here\n    return []", "    if arr.count\
    \ == 0 {\n        return []\n    }\n    let minEven = arr.filter { $0 % 2 == 0\
    \ }.min()\n    let index = arr.firstIndex(of: minEven!)!\n    return [minEven!,\
    \ index]", "    guard arr.contains(where: { $0 % 2 == 0 }) else { return [] }\n\
    \    let evens = arr.filter({ $0 % 2 == 0 })\n    guard let min = evens.min()\
    \ else { return [] }\n    let minIndex = arr.firstIndex(of: min) ?? -1\n    return\
    \ [min, minIndex]", "    var result = [Int]()\n    guard arr.count > 0 else {\
    \ return result }\n    var smallestValue = Int.max\n    var smallestIndex = 0\n\
    \    for (index, value) in arr.enumerated() {\n        if value % 2 == 0 && value\
    \ < smallestValue {\n            smallestValue = value\n            smallestIndex\
    \ = index\n        }\n    }\n    if smallestValue != Int.max {\n        result.append(smallestValue)\n\
    \        result.append(smallestIndex)\n    }\n    return result", "    guard !arr.isEmpty\
    \ else { return [] }\n    let evens = arr.filter { $0 % 2 == 0 }\n    guard !evens.isEmpty\
    \ else { return [] }\n    var result = [Int]()\n    var min = Int.max\n    for\
    \ (index, element) in arr.enumerated() {\n        if element % 2 == 0 && element\
    \ < min {\n            min = element\n            result = [element, index]\n\
    \        }\n    }\n    return result", "    var result = [Int]()\n    if arr.isEmpty\
    \ {\n        return result\n    }\n    var evens = [Int]()\n    var evenIndexes\
    \ = [Int]()\n    for (index, value) in arr.enumerated() {\n        if value.isMultiple(of:\
    \ 2) {\n            evens.append(value)\n            evenIndexes.append(index)\n\
    \        }\n    }\n    if evens.isEmpty {\n        return result\n    }\n    let\
    \ lowestEven = evens.min()!\n    let index = evenIndexes[evens.firstIndex(of:\
    \ lowestEven)!]\n    result.append(lowestEven)\n    result.append(index)\n   \
    \ return result", '    return arr.indices.filter({arr[$0] % 2 == 0}).min(by: {
    arr[$0] < arr[$1] }).map({ [arr[$0], $0] }) ?? []', "    \n    var evenNumbers:\
    \ [Int] = []\n    var indexArray: [Int] = []\n    \n    for (index, number) in\
    \ arr.enumerated() {\n        if number % 2 == 0 {\n            evenNumbers.append(number)\n\
    \            indexArray.append(index)\n        }\n    }\n    \n    if evenNumbers.count\
    \ == 0 {\n        return []\n    }\n    \n    var smallestIndex = -1\n    var\
    \ smallestNumber = -1\n    \n    for (index, number) in evenNumbers.enumerated()\
    \ {\n        if smallestNumber == -1 {\n            smallestNumber = number\n\
    \            smallestIndex = index\n        } else if number < smallestNumber\
    \ {\n            smallestNumber = number\n            smallestIndex = index\n\
    \        }\n    }\n    \n    return [smallestNumber, indexArray[smallestIndex]]",
  "    guard arr.count > 0 else { return [] }\n    let evenValues = arr.filter { $0\
    \ % 2 == 0 }\n    guard evenValues.count > 0 else { return [] }\n    let smallestEven\
    \ = evenValues.min()!\n    guard let index = arr.firstIndex(of: smallestEven)\
    \ else {\n        fatalError(\"Unexpected condition\")\n    }\n    return [smallestEven,\
    \ index]", "    //guard arr.isEmpty else { return arr }\n    let answer: [Int]\
    \ = arr.filter { $0 % 2 == 0 }.sorted { $0 < $1 }.prefix(1).map { $0 }\n    return\
    \ answer", "    // Enter code here\n    return []", "    var allEvenNodes = [Int]()\n\
    \    var evenNodeIndex = [Int]()\n    var smallEvenNode: Int?\n    var result\
    \ = [Int]()\n    \n    for (index, node) in arr.enumerated() {\n        if node\
    \ % 2 == 0 {\n            allEvenNodes.append(node)\n            evenNodeIndex.append(index)\n\
    \        }\n    }\n    \n    if allEvenNodes.count > 0 {\n        smallEvenNode\
    \ = allEvenNodes.min()\n        for index in 0..<allEvenNodes.count {\n      \
    \      if allEvenNodes[index] == smallEvenNode {\n                result.append(smallEvenNode!)\n\
    \                result.append(evenNodeIndex[index])\n                break\n\
    \            }\n        }\n    }\n    \n    return result", '    return []', " \
    \   // This can be solved in a one-liner, but I'll try to make it as readable\
    \ as possible\n    // 1) Get all even values\n    let even = arr.filter { $0 %\
    \ 2 == 0 }\n    // 2) Get the smallest value from even values\n    let smallest\
    \ = even.min() ?? 0\n    // 3) Get an index of the smallest value\n    let smallestIndex\
    \ = arr.firstIndex(of: smallest) ?? 0\n    // 4) Return the result\n    return\
    \ [smallest, smallestIndex]", "    if arr.count == 0 {\n        return []\n  \
    \  }\n    var smallest = 0\n    var index = 0\n    for (i, v) in arr.enumerated()\
    \ {\n        if v % 2 == 0 {\n            if smallest == 0 {\n               \
    \ smallest = v\n                index = i\n            } else if v < smallest\
    \ {\n                smallest = v\n                index = i\n            }\n\
    \        }\n    }\n    if smallest == 0 {\n        return []\n    }\n    return\
    \ [smallest, index]", "    guard !arr.isEmpty else { return [] }\n    let evenNumbers\
    \ = arr.filter { $0 % 2 == 0 }\n    guard !evenNumbers.isEmpty else { return []\
    \ }\n    let minEvenNumber = evenNumbers.min()!\n    guard let minEvenNumberIndex\
    \ = arr.firstIndex(of: minEvenNumber) else { return [] }\n    return [minEvenNumber,\
    \ minEvenNumberIndex]", '    return arr.enumerated().filter({ $0.element % 2 ==
    0 }).sorted{ $0.element < $1.element }.first.map { [$0.element, $0.offset] } ??
    []', "    let evens = arr.filter { $0 % 2 == 0 }\n    guard let minEven = evens.min()\
    \ else { return [] }\n    return [minEven, arr.firstIndex(of: minEven)!]", " \
    \   guard arr.contains(where: { $0 % 2 == 0 }) else { return [] }\n    let evens\
    \ = arr.enumerated().filter { $0.element % 2 == 0 }\n    guard let smallest =\
    \ evens.min(by: { $0.element < $1.element }) else { return [] }\n    return [smallest.element,\
    \ smallest.offset]", "    let even = arr.filter { $0 % 2 == 0 }\n    if even.isEmpty\
    \ { return [] }\n    return [even.min()!, arr.firstIndex(of: even.min()!)!]",
  "    var result = [Int]()\n    if arr.isEmpty {\n        return result\n    }\n\
    \    var smallestValue = Int.max\n    var smallestIndex = 0\n    for i in 0..<arr.count\
    \ {\n        if arr[i] % 2 == 0 && arr[i] < smallestValue {\n            smallestValue\
    \ = arr[i]\n            smallestIndex = i\n        }\n    }\n    if smallestValue\
    \ == Int.max {\n        return result\n    }\n    result.append(smallestValue)\n\
    \    result.append(smallestIndex)\n    return result", "    return arr.indices.reduce((Int.max,\
    \ 0)) { res, i in\n        if arr[i] == 0 {\n            return res\n        }\n\
    \        if arr[i] & 1 == 0 && arr[i] < res.0 {\n            return (arr[i], i)\n\
    \        }\n        return res\n    }.0 == Int.max ? [] : [arr[1], 1]", "    guard\
    \ arr.isEmpty == false else { return [] }\n    guard arr.contains(where: { $0\
    \ % 2 == 0 }) else { return [] }\n    let evenNumbers = arr.filter({ $0 % 2 ==\
    \ 0 })\n    let minNumber = evenNumbers.min()!\n    return [minNumber, arr.firstIndex(of:\
    \ minNumber)!]", "    var smallestValue = Int.max\n    var smallestIndex = -1\n\
    \    for (index, value) in arr.enumerated() {\n        if value == 0 {\n     \
    \       smallestValue = 0\n            smallestIndex = index\n            break\n\
    \        }\n        if value < smallestValue && value % 2 == 0 {\n           \
    \ smallestValue = value\n            smallestIndex = index\n        }\n    }\n\
    \    return smallestIndex >= 0 ? [smallestValue, smallestIndex] : []", "    var\
    \ evens = [Int]()\n    var index = 0\n    for i in arr {\n        if i % 2 ==\
    \ 0 {\n            evens.append(i)\n        }\n    }\n    if evens.count > 0 {\n\
    \        evens.sort()\n        for i in arr {\n            if i == evens[0] {\n\
    \                return [i, index]\n            }\n            index += 1\n  \
    \      }\n    }\n    return []", "    let sortedArr = arr.sorted()\n    let evens\
    \ = sortedArr.filter { $0 % 2 == 0 }\n    guard let smallesEven = evens.first\
    \ else { return [] }\n    return [smallesEven, arr.firstIndex(of: smallesEven)!]",
  "    let evenValues = arr.filter { $0 % 2 == 0 }\n    guard let min = evenValues.min()\
    \ else { return [] }\n    let index = arr.index(of: min) ?? 0\n    return [min,\
    \ index]", "    var minEven = Int.max\n    var minEvenIndex = Int.max\n    for\
    \ (index, value) in arr.enumerated() {\n        if value % 2 == 0 {\n        \
    \    if value < minEven {\n                minEven = value\n                minEvenIndex\
    \ = index\n            }\n        }\n    }\n    return minEven == Int.max ? []\
    \ : [minEven, minEvenIndex]", "    let evenValues = arr.filter { $0 % 2 == 0 }\n\
    \    guard let minEvenValue = evenValues.min() else { return [] }\n    return\
    \ [minEvenValue, arr.firstIndex(of: minEvenValue)!]", "    var smallestEvenValue:\
    \ Int?\n    var smallestEvenValueIndex: Int?\n    for (index, value) in arr.enumerated()\
    \ {\n        if value % 2 == 0 {\n            if smallestEvenValue == nil {\n\
    \                smallestEvenValue = value\n                smallestEvenValueIndex\
    \ = index\n            } else if value < smallestEvenValue! {\n              \
    \  smallestEvenValue = value\n                smallestEvenValueIndex = index\n\
    \            }\n        }\n    }\n    if smallestEvenValue != nil {\n        return\
    \ [smallestEvenValue!, smallestEvenValueIndex!]\n    } else {\n        return\
    \ []\n    }", "    guard arr.count > 0 else { return [] }\n    var min = arr[0]\n\
    \    var index = 0\n    var isEven = false\n    for i in 1..<arr.count {\n   \
    \     if arr[i] % 2 == 0 {\n            isEven = true\n            if arr[i] <\
    \ min {\n                min = arr[i]\n                index = i\n           \
    \ }\n        }\n    }\n    if isEven {\n        return [min, index]\n    } else\
    \ {\n        return []\n    }", '    return [Int]()', "    var result = [Int]()\n\
    \    var smallestEven = Int.max\n    var smallestEvenIndex = Int.max\n    var\
    \ hasOdd = false\n    for (index, number) in arr.enumerated() {\n        if number\
    \ % 2 == 0 {\n            if number < smallestEven {\n                smallestEven\
    \ = number\n                smallestEvenIndex = index\n            }\n       \
    \ } else {\n            hasOdd = true\n        }\n    }\n    if !hasOdd {\n  \
    \      result.append(contentsOf: [smallestEven, smallestEvenIndex])\n    }\n \
    \   return result", "    var min = 0\n    var minIndex = 0\n    var isFound =\
    \ false\n    for (index, value) in arr.enumerated() {\n        if value % 2 ==\
    \ 0 {\n            if !isFound {\n                min = value\n              \
    \  minIndex = index\n                isFound = true\n            } else {\n  \
    \              if value < min {\n                    min = value\n           \
    \         minIndex = index\n                }\n            }\n        }\n    }\n\
    \    if isFound {\n        return [min, minIndex]\n    } else {\n        return\
    \ []\n    }", "    var arr = arr\n    arr.sort(by: { $0 < $1 })\n    for (idx,\
    \ value) in arr.enumerated() {\n        if value % 2 == 0 {\n            return\
    \ [value, idx]\n        }\n    }\n    return []", "    var smallest: Int?\n  \
    \  var smallestIndex: Int?\n    for (index, number) in arr.enumerated() {\n  \
    \      if number % 2 == 0 {\n            if smallest == nil {\n              \
    \  smallest = number\n                smallestIndex = index\n            } else\
    \ if number < smallest! {\n                smallest = number\n               \
    \ smallestIndex = index\n            }\n        }\n    }\n    if smallest == nil\
    \ {\n        return []\n    }\n    return [smallest!, smallestIndex!]", "    let\
    \ evens = arr.filter { $0 % 2 == 0 }\n    let smallest = evens.min() ?? 0\n  \
    \  guard let index = arr.firstIndex(of: smallest) else { return [] }\n    return\
    \ [smallest, index]", "    guard !arr.isEmpty else { return [] }\n    var indices\
    \ = [Int]()\n    var minEven: Int?\n    for (i, v) in arr.enumerated() {\n   \
    \     if v % 2 == 0 {\n            if let me = minEven {\n                if v\
    \ < me {\n                    minEven = v\n                    indices = [i]\n\
    \                } else if v == me {\n                    indices.append(i)\n\
    \                }\n            } else {\n                minEven = v\n      \
    \          indices = [i]\n            }\n        }\n    }\n    if let me = minEven\
    \ {\n        return [me, indices.min()!]\n    }\n    return []", "    let evens\
    \ = arr.filter { $0 % 2 == 0 }\n    guard !evens.isEmpty else { return [] }\n\
    \    let sortedEvens = evens.sorted()\n    guard let minEven = sortedEvens.first\
    \ else { return [] }\n    let evenIndex = arr.firstIndex(of: minEven) ?? 0\n \
    \   return [minEven, evenIndex]", "    guard arr.count > 0 else { return [] }\n\
    \    var smallestEven = Int.max\n    var smallestEvenIndex = 0\n    for (index,\
    \ element) in arr.enumerated() {\n        if element % 2 == 0 && element < smallestEven\
    \ {\n            smallestEven = element\n            smallestEvenIndex = index\n\
    \        }\n    }\n    return smallestEven == Int.max ? [] : [smallestEven, smallestEvenIndex]",
  "    let evens = arr.filter { $0 % 2 == 0 }\n    guard let minEven = evens.min()\
    \ else { return [] }\n    guard let minEvenIndex = arr.firstIndex(of: minEven)\
    \ else { return [] }\n    return [minEven, minEvenIndex]", "    return arr.indices.reduce(into:\
    \ [Int](), {\n        if let first = $0.first, first % 2 == 0 {\n            $0\
    \ = [first, $0.last!]\n        } else if $1 % 2 == 0 {\n            $0 = [$1,\
    \ $1]\n        }\n    })", "    guard !arr.isEmpty else { return [] }\n    var\
    \ evens = [Int]()\n    for num in arr {\n        if num % 2 == 0 {\n         \
    \   evens.append(num)\n        }\n    }\n    guard !evens.isEmpty else { return\
    \ [] }\n    let even = evens.min()!\n    for i in 0..<arr.count {\n        if\
    \ arr[i] == even {\n            return [even, i]\n        }\n    }\n    return\
    \ []", "    var current: Int?\n    var currentIndex: Int?\n    for (index, value)\
    \ in arr.enumerated() {\n        if value % 2 == 0 && (current == nil || value\
    \ < current!) {\n            current = value\n            currentIndex = index\n\
    \        }\n    }\n    if let result = current, let index = currentIndex {\n \
    \       return [result, index]\n    }\n    return []", "    // Parameter validations\n\
    \    guard arr.count > 0 else { return [] }\n    // Sorting arr of Int based on\
    \ even numbers and positions\n    let sortedArr = arr.enumerated().sorted { (left,\
    \ right) -> Bool in\n        if left.element.isEven && right.element.isEven {\n\
    \            return left.offset < right.offset\n        } else if left.element.isEven\
    \ {\n            return true\n        } else if right.element.isEven {\n     \
    \       return false\n        } else {\n            return false\n        }\n\
    \    }\n    // Return the first element\n    return sortedArr.first?.element.isEven\
    \ == true ? [sortedArr.first!.element, sortedArr.first!.offset] : []", "    //\
    \ your code here\n    var result: [Int] = []\n    if arr.isEmpty {\n        return\
    \ result\n    }\n    var evenValues: [Int] = []\n    for number in arr {\n   \
    \     if number % 2 == 0 {\n            evenValues.append(number)\n        }\n\
    \    }\n    if evenValues.isEmpty {\n        return result\n    }\n    var min\
    \ = Int.max\n    for value in evenValues {\n        if value < min {\n       \
    \     min = value\n        }\n    }\n    var minIndex = 0\n    for (index, value)\
    \ in arr.enumerated() {\n        if value == min {\n            minIndex = index\n\
    \            break\n        }\n    }\n    result.append(min)\n    result.append(minIndex)\n\
    \    return result", "    guard !arr.isEmpty else { return [] }\n    let evenNumbers\
    \ = arr.filter { $0 % 2 == 0 }\n    guard !evenNumbers.isEmpty else { return []\
    \ }\n    let smallestEven = evenNumbers.min()!\n    let smallestEvenIndex = arr.index(of:\
    \ smallestEven)!\n    return [smallestEven, smallestEvenIndex]", "    guard !arr.isEmpty\
    \ else { return [] }\n    let evens = arr.filter { $0 % 2 == 0 }\n    guard !evens.isEmpty\
    \ else { return [] }\n    let minEven = evens.min()!\n    return [minEven, arr.firstIndex(of:\
    \ minEven)!]", "    let evens = arr.filter { $0 % 2 == 0 }\n    guard let minEven\
    \ = evens.min() else { return [] }\n    return [minEven, arr.firstIndex(of: minEven)!]",
  '    return arr.enumerated().filter { $0.element % 2 == 0 }.min { $0.element < $1.element
    }?.reversed() ?? []', "    var result = [Int]()\n    var minEven = Int.max\n \
    \   var minEvenIndex = -1\n    var minEvenCount = 0\n    for (index, element)\
    \ in arr.enumerated() {\n        if element % 2 == 0 {\n            if element\
    \ < minEven {\n                minEven = element\n                minEvenIndex\
    \ = index\n                minEvenCount = 1\n            } else if element ==\
    \ minEven {\n                minEvenCount += 1\n            }\n        }\n   \
    \ }\n    if minEvenIndex != -1 {\n        result.append(minEven)\n        result.append(minEvenIndex)\n\
    \    }\n    return result", "    var result = [Int]()\n    guard arr.count > 0\
    \ else { return result }\n    var minIndex = 0\n    for i in 0..<arr.count {\n\
    \        if arr[i] % 2 == 0 {\n            if result.count == 0 {\n          \
    \      result.append(arr[i])\n                minIndex = i\n            } else\
    \ {\n                if arr[i] < result[0] {\n                    result[0] =\
    \ arr[i]\n                    minIndex = i\n                }\n            }\n\
    \        }\n    }\n    if result.count > 0 {\n        result.append(minIndex)\n\
    \    }\n    return result", "    guard arr.contains(where: { $0 % 2 == 0 }) else\
    \ { return [] }\n    var result = [Int]()\n    for node in arr.enumerated() {\n\
    \        if node.element % 2 == 0 {\n            result.append(node.element)\n\
    \            result.append(node.offset)\n            break\n        }\n    }\n\
    \    return result", "    let smallestEven = arr.filter { $0 % 2 == 0 }.min()\n\
    \    guard let smallest = smallestEven else { return [] }\n    return [smallest,\
    \ arr.firstIndex(of: smallest)!]", "    var output: [Int] = []\n    var minIndex\
    \ = -1\n    var minValue = Int.max\n    arr.enumerated().forEach { i, e in\n \
    \       if e < minValue && e.isMultiple(of: 2) {\n            minValue = e\n \
    \           minIndex = i\n        }\n    }\n    if minIndex > -1 {\n        output.append(minValue)\n\
    \        output.append(minIndex)\n    }\n    return output", "    var finalArr\
    \ = [Int]()\n    let evenArr = arr.filter { (num) -> Bool in\n        num % 2\
    \ == 0\n    }\n    if evenArr.count > 0 {\n        let leastEven = evenArr.sorted().first!\n\
    \        if let index = arr.firstIndex(of: leastEven) {\n            finalArr.append(leastEven)\n\
    \            finalArr.append(index)\n        }\n    }\n    return finalArr", " \
    \   let z = arr.filter { $0 % 2 == 0 }\n    guard let r = z.min() else { return\
    \ [] }\n    return [r, arr.firstIndex(of: r)!]", "    var result = [Int]()\n \
    \   var evenNumbers = [Int]()\n    var evenNumbersIndices = [Int]()\n    var minEvenValue\
    \ = Int.max\n    arr.enumerated().forEach { (index, number) in\n        if number\
    \ % 2 == 0 {\n            evenNumbers.append(number)\n            evenNumbersIndices.append(index)\n\
    \            if number < minEvenValue {\n                minEvenValue = number\n\
    \            }\n        }\n    }\n    guard evenNumbers.count > 0 else { return\
    \ [] }\n    for (index, number) in evenNumbers.enumerated() {\n        if number\
    \ == minEvenValue {\n            result.append(minEvenValue)\n            result.append(evenNumbersIndices[index])\n\
    \            break\n        }\n    }\n    return result", "    guard !arr.isEmpty\
    \ else { return [] }\n    return arr.enumerated().filter { $0.element % 2 == 0\
    \ }.sorted { $0.element < $1.element }.first ?? []", "    if arr.count == 0 {\n\
    \        return []\n    }\n    let evens = arr.filter({ $0 % 2 == 0 })\n    if\
    \ evens.count == 0 {\n        return []\n    }\n    let smallestEven = evens.min()!\n\
    \    var smallestEvenIndex: Int?\n    for (index, val) in arr.enumerated() {\n\
    \        if val == smallestEven {\n            smallestEvenIndex = index\n   \
    \         break\n        }\n    }\n    if let smallestEvenIndex = smallestEvenIndex\
    \ {\n        return [smallestEven, smallestEvenIndex]\n    }\n    return []",
  "    var evenArr = [Int]()\n    var indexArr = [Int]()\n    var smallestEvenIndex\
    \ = 0\n    var smallestEvenValue = 0\n    for (index, element) in arr.enumerated()\
    \ {\n        if element % 2 == 0 {\n            evenArr.append(element)\n    \
    \        indexArr.append(index)\n        }\n    }\n    if evenArr.count != 0 {\n\
    \        evenArr.sort()\n        indexArr.sort()\n        smallestEvenValue =\
    \ evenArr[0]\n        smallestEvenIndex = indexArr[0]\n    }\n    return [smallestEvenValue,\
    \ smallestEvenIndex]", "    var evens = arr.filter { $0 % 2 == 0 }\n    if evens.isEmpty\
    \ { return [] }\n    evens.sort()\n    let minEven = evens[0]\n    let index =\
    \ arr.firstIndex(of: minEven)!\n    return [minEven, index]", "    var evens =\
    \ [Int]()\n    for (index, item) in arr.enumerated() {\n        if item % 2 ==\
    \ 0 {\n            evens.append(item)\n        }\n    }\n    guard let smallest\
    \ = evens.min() else { return [] }\n    let items = arr.enumerated().filter({\
    \ $0.element == smallest })\n    return [smallest, items.first!.offset]", "  \
    \  guard !arr.isEmpty else { return [] }\n    guard let smallestEven = arr.sorted().filter({\
    \ $0 % 2 == 0 }).first else { return [] }\n    return [smallestEven, arr.firstIndex(of:\
    \ smallestEven)!]", '    return []', "    let even = arr.filter { $0 % 2 == 0\
    \ }\n    if even.isEmpty { return [] }\n    var index = -1\n    let value = even.reduce(arr.first!)\
    \ { if $0 < $1 { return $0 } else { index = arr.firstIndex(of: $1)!; return $1\
    \ } }\n    return [value, index]", "    guard arr.count > 0 else { return [] }\n\
    \    var minEven = Int.max\n    var minEvenIndex = 0\n    var found = false\n\
    \    for (index, value) in arr.enumerated() {\n        if value.isEven && value\
    \ < minEven {\n            minEven = value\n            minEvenIndex = index\n\
    \            found = true\n        }\n    }\n    if found {\n        return [minEven,\
    \ minEvenIndex]\n    } else {\n        return []\n    }", "    guard arr.count\
    \ > 0 else { return [] }\n    var result = [Int]()\n    var evens = [Int]()\n\
    \    var evenIndex = [Int]()\n    for (index, item) in arr.enumerated() {\n  \
    \      if item % 2 == 0 {\n            evens.append(item)\n            evenIndex.append(index)\n\
    \        }\n    }\n    if evens.count > 0 {\n        let minEven = evens.min()!\n\
    \        let minEvenIndex = evenIndex[evens.firstIndex(of: minEven)!]\n      \
    \  result.append(minEven)\n        result.append(minEvenIndex)\n    }\n    return\
    \ result", "    if arr.isEmpty {\n        return []\n    }\n    if let smallestEven\
    \ = arr.filter({ $0 % 2 == 0 }).min() {\n        return [smallestEven, arr.firstIndex(of:\
    \ smallestEven)!]\n    }\n    return []", "    let evens = arr.filter { $0 % 2\
    \ == 0 }\n    if let min = evens.min() {\n        let index = arr.firstIndex(of:\
    \ min) ?? 0\n        return [min, index]\n    }\n    return []", "    guard arr.contains(where:\
    \ { $0 % 2 == 0 }) else { return [] }\n    var first = 0\n    var second = 0\n\
    \    for (i, value) in arr.enumerated() {\n        if value % 2 == 0 {\n     \
    \       first = value\n            second = i\n            break\n        }\n\
    \    }\n    for (i, value) in arr.enumerated() {\n        if value % 2 == 0, value\
    \ < first {\n            first = value\n            second = i\n        }\n  \
    \  }\n    return [first, second]", "    return arr.enumerated().filter { $0.element\
    \ % 2 == 0 }.min {\n        $0.element < $1.element\n    }.map { [$0.element,\
    \ $0.offset] } ?? []", "    var smallestNode: [Int] = []\n    for n in arr {\n\
    \        if n % 2 == 0 && (smallestNode.isEmpty || n < smallestNode[0]) {\n  \
    \          smallestNode = [n, arr.firstIndex(of: n)!]\n        }\n    }\n    return\
    \ smallestNode", "    // your code here\n    if arr.count == 0 {\n        return\
    \ []\n    }\n    if let firstEven = arr.filter({$0 % 2 == 0}).first {\n      \
    \  let index = arr.firstIndex(of: firstEven)\n        return [firstEven, index!]\n\
    \    }\n    return []", "    let newArr = arr.filter { $0 % 2 == 0 }\n    if newArr.isEmpty\
    \ {\n        return []\n    }\n    let minValue = newArr.min()!\n    let index\
    \ = arr.firstIndex(of: minValue)!\n    return [minValue, index]", '    return
    arr.enumerated().filter { $0.element % 2 == 0 }.min { $0.element < $1.element
    }?.array ?? []', "    var minEven: Int?\n    var minEvenIndex: Int?\n    for (index,\
    \ element) in arr.enumerated() {\n        if element % 2 == 0 {\n            if\
    \ minEven == nil || element < minEven! {\n                minEven = element\n\
    \                minEvenIndex = index\n            }\n        }\n    }\n    if\
    \ minEven == nil {\n        return []\n    }\n    return [minEven!, minEvenIndex!]",
  "    let evens = arr.filter { $0 % 2 == 0 }\n    guard let min = evens.min() else\
    \ { return [] }\n    guard let index = arr.firstIndex(of: min) else { return []\
    \ }\n    return [min, index]", "    let evenArr = arr.filter { $0 % 2 == 0 }\n\
    \    if evenArr.isEmpty {\n        return []\n    }\n    let smallValue = evenArr.min()!\n\
    \    let index = arr.firstIndex(of: smallValue)!\n    return [smallValue, index]",
  "    guard arr.count > 0 else { return [] }\n    let sortedEvenNodes = arr.filter\
    \ { $0 % 2 == 0 }.sorted()\n    let smallestEvenValue = sortedEvenNodes.first\
    \ ?? -1\n    guard smallestEvenValue != -1 else { return [] }\n    let smallestEvenValueIndex\
    \ = arr.firstIndex(of: smallestEvenValue) ?? -1\n    return [smallestEvenValue,\
    \ smallestEvenValueIndex]", "    var smallEven: Int?\n    var index = 0\n    var\
    \ result = [Int]()\n    for i in arr {\n        if i % 2 == 0 {\n            if\
    \ smallEven == nil {\n                smallEven = i\n                result.append(smallEven!)\n\
    \                result.append(index)\n            } else if i < smallEven! {\n\
    \                smallEven = i\n                result.removeAll()\n         \
    \       result.append(smallEven!)\n                result.append(index)\n    \
    \        }\n        }\n        index += 1\n    }\n    return result", "    var\
    \ results = [Int]()\n    var smallestEvenValue = Int.max\n    for (index, value)\
    \ in arr.enumerated() {\n        if value % 2 == 0 && value < smallestEvenValue\
    \ {\n            smallestEvenValue = value\n            results = [value, index]\n\
    \        }\n    }\n    return results", "    let even = arr.enumerated().filter\
    \ { $0.element % 2 == 0 }\n    let min = even.min { a, b in a.element < b.element\
    \ }\n    return min.map { [$0.element, $0.offset] } ?? []", "    guard arr.count\
    \ > 0 else { return [] }\n    var evens: [Int] = []\n    for (index, value) in\
    \ arr.enumerated() {\n        if value % 2 == 0 {\n            evens.append(value)\n\
    \        }\n    }\n    guard evens.count > 0 else { return [] }\n    let lowestEven\
    \ = evens.min()\n    for (index, value) in arr.enumerated() {\n        if value\
    \ == lowestEven {\n            return [value, index]\n        }\n    }\n    return\
    \ []", "    \n    return pluck(current: arr, smallestEven: Int.max, index: -1)",
  '    return arr.enumerated().filter { $0.element % 2 == 0 }.min { $0.element < $1.element
    }.map { [$0.element, $0.offset] } ?? []', "    var result = [Int]()\n    if arr.isEmpty\
    \ {\n        return result\n    }\n    var minEven = Int.max\n    var minEvenIndex\
    \ = 0\n    for (index, element) in arr.enumerated() {\n        if element < minEven,\
    \ element % 2 == 0 {\n            minEven = element\n            minEvenIndex\
    \ = index\n        }\n    }\n    if minEven != Int.max {\n        result.append(minEven)\n\
    \        result.append(minEvenIndex)\n    }\n    return result", "    var result\
    \ = [Int]()\n    var evens = [Int]()\n    var minIndex = Int.max\n    var minEven\
    \ = Int.max\n    var i = 0\n    while i < arr.count {\n        if arr[i] % 2 ==\
    \ 0 {\n            evens.append(arr[i])\n            if arr[i] < minEven {\n \
    \               minEven = arr[i]\n                minIndex = i\n            }\n\
    \        }\n        i += 1\n    }\n    if evens.count > 0 {\n        result.append(minEven)\n\
    \        result.append(minIndex)\n    }\n    return result", "    if arr.isEmpty\
    \ {\n        return []\n    }\n    var evenArr = [Int]()\n    var indexArr = [Int]()\n\
    \    var minEven = Int.max\n    var resultArr = [Int]()\n    for (index, value)\
    \ in arr.enumerated() {\n        if value % 2 == 0 {\n            evenArr.append(value)\n\
    \            indexArr.append(index)\n        }\n    }\n    if evenArr.isEmpty\
    \ {\n        return []\n    }\n    for number in evenArr {\n        if number\
    \ < minEven {\n            minEven = number\n        }\n    }\n    for (index,\
    \ number) in evenArr.enumerated() {\n        if number == minEven {\n        \
    \    resultArr.append(number)\n            resultArr.append(indexArr[index])\n\
    \            break\n        }\n    }\n    return resultArr", "    // our storage\
    \ for the result\n    var res = [Int]()\n    // our storage for all even numbers\n\
    \    var evenArr = [Int]()\n    // check for empty array and return an empty array\n\
    \    if arr.isEmpty {\n        return res\n    }\n    // get all even numbers\
    \ from given array and store them in evenArr\n    for num in arr {\n        if\
    \ num % 2 == 0 {\n            evenArr.append(num)\n        }\n    }\n    // check\
    \ if there are no even numbers and return an empty array\n    if evenArr.isEmpty\
    \ {\n        return res\n    }\n    // sort given array in descending order\n\
    \    let sortedArr = arr.sorted(by: >)\n    // get the smallest even number from\
    \ evenArr\n    let smallestEven = evenArr.min()!\n    // get the index of the\
    \ smallest even number from given array\n    let smallestEvenIndex = sortedArr.firstIndex(of:\
    \ smallestEven)!\n    // append smallest even number and its index to our result\n\
    \    res.append(contentsOf: [smallestEven, smallestEvenIndex])\n    // return\
    \ result\n    return res", "    guard arr.count > 0 else { return [] }\n    return\
    \ arr.enumerated().reduce((index: Int.max, value: Int.max)) { (indexAndValue,\
    \ pair) in\n        let (index, value) = pair\n        if value % 2 == 0 && value\
    \ < indexAndValue.value {\n            return (index, value)\n        }\n    \
    \    return indexAndValue\n    }.value == Int.max ? [] : [indexAndValue.value,\
    \ indexAndValue.index]", "    guard !arr.isEmpty else { return [] }\n    guard\
    \ let minEven = arr.filter({ $0 % 2 == 0 }).min() else { return [] }\n    guard\
    \ let minIndex = arr.firstIndex(of: minEven) else { return [] }\n    return [minEven,\
    \ minIndex]", "    var smallestEven: Int?\n    var smallestEvenIndex: Int?\n \
    \   for (index, element) in arr.enumerated() {\n        if element % 2 == 0 {\n\
    \            if smallestEven == nil {\n                smallestEven = element\n\
    \                smallestEvenIndex = index\n            } else if element < smallestEven!\
    \ {\n                smallestEven = element\n                smallestEvenIndex\
    \ = index\n            }\n        }\n    }\n    if smallestEven != nil {\n   \
    \     return [smallestEven!, smallestEvenIndex!]\n    } else {\n        return\
    \ []\n    }", "    return arr.filter({$0 % 2 == 0}).sorted()\n        .map { (n)\
    \ -> [Int] in [n, arr.index(of: n)!] }.first ?? []", "    let evens = arr.filter\
    \ { $0 % 2 == 0 }\n    guard let smallestEven = evens.min() else { return [] }\n\
    \    guard let index = arr.firstIndex(of: smallestEven) else { return [] }\n \
    \   return [smallestEven, index]", "    let evens = arr.enumerated().filter {\
    \ $0.element % 2 == 0 }\n    guard let minEven = evens.map({ $0.element }).min()\
    \ else { return [] }\n    return evens.filter { $0.element == minEven }.min(by:\
    \ { $0.offset < $1.offset })!", "    var evens = [Int]()\n    var indexes = [Int]()\n\
    \    var result = [Int]()\n    var minEven = Int.max\n    var minIndex = Int.max\n\
    \    for (index, element) in arr.enumerated() {\n        if element % 2 == 0 {\n\
    \            evens.append(element)\n            indexes.append(index)\n      \
    \  }\n    }\n    for (index, element) in evens.enumerated() {\n        if element\
    \ < minEven {\n            minEven = element\n            minIndex = indexes[index]\n\
    \        }\n    }\n    if minEven == Int.max {\n        return []\n    }\n   \
    \ result.append(minEven)\n    result.append(minIndex)\n    return result"]
stop_tokens:
- "\n}"
