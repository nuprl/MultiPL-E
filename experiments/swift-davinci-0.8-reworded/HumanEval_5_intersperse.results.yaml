language: swift
name: HumanEval_5_intersperse
results:
- exit_code: 0
  program: "\n/// Insert a number 'delimeter' between every two consecutive elements\
    \ of input array `numbers'\n/// >>> intersperse(numbers: [] as [Int], delimeter:\
    \ 4)\n/// [] as [Int]\n/// >>> intersperse(numbers: [1, 2, 3], delimeter: 4)\n\
    /// [1, 4, 2, 4, 3]\nfunc intersperse(numbers: [Int], delimeter: Int) -> [Int]\
    \ {\n    var result: [Int] = []\n    var count = 0\n    while count < numbers.count\
    \ {\n        result.append(numbers[count])\n        if count != numbers.count\
    \ - 1 {\n            result.append(delimeter)\n        }\n        count += 1\n\
    \    }\n    return result\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(intersperse(numbers:\
    \ [] as [Int], delimeter: 7) == [] as [Int])\nassert(intersperse(numbers: [5,\
    \ 6, 3, 2], delimeter: 8) == [5, 8, 6, 8, 3, 8, 2])\nassert(intersperse(numbers:\
    \ [2, 2, 2], delimeter: 2) == [2, 2, 2, 2, 2])"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659978931
- exit_code: 0
  program: "\n/// Insert a number 'delimeter' between every two consecutive elements\
    \ of input array `numbers'\n/// >>> intersperse(numbers: [] as [Int], delimeter:\
    \ 4)\n/// [] as [Int]\n/// >>> intersperse(numbers: [1, 2, 3], delimeter: 4)\n\
    /// [1, 4, 2, 4, 3]\nfunc intersperse(numbers: [Int], delimeter: Int) -> [Int]\
    \ {\n    if numbers.isEmpty {\n        return []\n    }\n    var result = [Int]()\n\
    \    for number in numbers {\n        result.append(number)\n        result.append(delimeter)\n\
    \    }\n    result.removeLast()\n    return result\n}\n\n\nfunc ==(left: [(Int,\
    \ Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n\
    \        return false\n    }\n    for (l, r) in zip(left, right) {\n        if\
    \ l != r {\n            return false\n        }\n    }\n    return true\n}\n \
    \           \nassert(intersperse(numbers: [] as [Int], delimeter: 7) == [] as\
    \ [Int])\nassert(intersperse(numbers: [5, 6, 3, 2], delimeter: 8) == [5, 8, 6,\
    \ 8, 3, 8, 2])\nassert(intersperse(numbers: [2, 2, 2], delimeter: 2) == [2, 2,\
    \ 2, 2, 2])"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659978931
- exit_code: 1
  program: "\n/// Insert a number 'delimeter' between every two consecutive elements\
    \ of input array `numbers'\n/// >>> intersperse(numbers: [] as [Int], delimeter:\
    \ 4)\n/// [] as [Int]\n/// >>> intersperse(numbers: [1, 2, 3], delimeter: 4)\n\
    /// [1, 4, 2, 4, 3]\nfunc intersperse(numbers: [Int], delimeter: Int) -> [Int]\
    \ {\n    if numbers.isEmpty {\n        return []\n    }\n    return intersperse(numbers:\
    \ numbers.dropFirst(), delimeter: delimeter) + [delimeter] + [numbers.first!]\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(intersperse(numbers: [] as [Int], delimeter: 7)\
    \ == [] as [Int])\nassert(intersperse(numbers: [5, 6, 3, 2], delimeter: 8) ==\
    \ [5, 8, 6, 8, 3, 8, 2])\nassert(intersperse(numbers: [2, 2, 2], delimeter: 2)\
    \ == [2, 2, 2, 2, 2])"
  status: SyntaxError
  stderr: "/tmp/tmpybx7kthu.swift:11:41: error: cannot convert value of type 'ArraySlice<Int>'\
    \ to expected argument type '[Int]'\n    return intersperse(numbers: numbers.dropFirst(),\
    \ delimeter: delimeter) + [delimeter] + [numbers.first!]\n                   \
    \                     ^\n"
  stdout: ''
  timestamp: 1659978931
- exit_code: 0
  program: "\n/// Insert a number 'delimeter' between every two consecutive elements\
    \ of input array `numbers'\n/// >>> intersperse(numbers: [] as [Int], delimeter:\
    \ 4)\n/// [] as [Int]\n/// >>> intersperse(numbers: [1, 2, 3], delimeter: 4)\n\
    /// [1, 4, 2, 4, 3]\nfunc intersperse(numbers: [Int], delimeter: Int) -> [Int]\
    \ {\n  let count = numbers.count\n  guard count > 1 else { return numbers }\n\
    \  var result = [Int]()\n  for i in 0..<count-1 {\n    result.append(numbers[i])\n\
    \    result.append(delimeter)\n  }\n  result.append(numbers[count-1])\n  return\
    \ result\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n\
    \    if left.count != right.count {\n        return false\n    }\n    for (l,\
    \ r) in zip(left, right) {\n        if l != r {\n            return false\n  \
    \      }\n    }\n    return true\n}\n            \nassert(intersperse(numbers:\
    \ [] as [Int], delimeter: 7) == [] as [Int])\nassert(intersperse(numbers: [5,\
    \ 6, 3, 2], delimeter: 8) == [5, 8, 6, 8, 3, 8, 2])\nassert(intersperse(numbers:\
    \ [2, 2, 2], delimeter: 2) == [2, 2, 2, 2, 2])"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659978931
- exit_code: 0
  program: "\n/// Insert a number 'delimeter' between every two consecutive elements\
    \ of input array `numbers'\n/// >>> intersperse(numbers: [] as [Int], delimeter:\
    \ 4)\n/// [] as [Int]\n/// >>> intersperse(numbers: [1, 2, 3], delimeter: 4)\n\
    /// [1, 4, 2, 4, 3]\nfunc intersperse(numbers: [Int], delimeter: Int) -> [Int]\
    \ {\n    if numbers.isEmpty {\n        return []\n    } else {\n        var result\
    \ = [Int]()\n        for (index, number) in numbers.enumerated() {\n         \
    \   result.append(number)\n            if index != numbers.count - 1 {\n     \
    \           result.append(delimeter)\n            }\n        }\n        return\
    \ result\n    }\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool\
    \ {\n    if left.count != right.count {\n        return false\n    }\n    for\
    \ (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(intersperse(numbers:\
    \ [] as [Int], delimeter: 7) == [] as [Int])\nassert(intersperse(numbers: [5,\
    \ 6, 3, 2], delimeter: 8) == [5, 8, 6, 8, 3, 8, 2])\nassert(intersperse(numbers:\
    \ [2, 2, 2], delimeter: 2) == [2, 2, 2, 2, 2])"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659978931
- exit_code: 0
  program: "\n/// Insert a number 'delimeter' between every two consecutive elements\
    \ of input array `numbers'\n/// >>> intersperse(numbers: [] as [Int], delimeter:\
    \ 4)\n/// [] as [Int]\n/// >>> intersperse(numbers: [1, 2, 3], delimeter: 4)\n\
    /// [1, 4, 2, 4, 3]\nfunc intersperse(numbers: [Int], delimeter: Int) -> [Int]\
    \ {\n  var result: [Int] = []\n  for index in 0..<numbers.count {\n    result.append(numbers[index])\n\
    \    if index != numbers.count - 1 {\n      result.append(delimeter)\n    }\n\
    \  }\n  return result\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(intersperse(numbers:\
    \ [] as [Int], delimeter: 7) == [] as [Int])\nassert(intersperse(numbers: [5,\
    \ 6, 3, 2], delimeter: 8) == [5, 8, 6, 8, 3, 8, 2])\nassert(intersperse(numbers:\
    \ [2, 2, 2], delimeter: 2) == [2, 2, 2, 2, 2])"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659978931
- exit_code: -4
  program: "\n/// Insert a number 'delimeter' between every two consecutive elements\
    \ of input array `numbers'\n/// >>> intersperse(numbers: [] as [Int], delimeter:\
    \ 4)\n/// [] as [Int]\n/// >>> intersperse(numbers: [1, 2, 3], delimeter: 4)\n\
    /// [1, 4, 2, 4, 3]\nfunc intersperse(numbers: [Int], delimeter: Int) -> [Int]\
    \ {\n    var array = [Int]()\n    for item in numbers {\n        array.append(item)\n\
    \        array.append(delimeter)\n    }\n    array.removeLast()\n    return array\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(intersperse(numbers: [] as [Int], delimeter: 7)\
    \ == [] as [Int])\nassert(intersperse(numbers: [5, 6, 3, 2], delimeter: 8) ==\
    \ [5, 8, 6, 8, 3, 8, 2])\nassert(intersperse(numbers: [2, 2, 2], delimeter: 2)\
    \ == [2, 2, 2, 2, 2])"
  status: Exception
  stderr: 'Swift/RangeReplaceableCollection.swift:870: Fatal error: Can''t remove
    last element from an empty collection

    Current stack trace:

    0    libswiftCore.so                    0x00002ad31a325c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002ad31a01c561 <unavailable> + 1434977

    2    libswiftCore.so                    0x00002ad31a01c286 <unavailable> + 1434246

    3    libswiftCore.so                    0x00002ad31a01c13c <unavailable> + 1433916

    4    libswiftCore.so                    0x00002ad31a01bbb0 _assertionFailure(_:_:file:line:flags:)
    + 251

    5    libswiftCore.so                    0x00002ad31a11dc1d <unavailable> + 2489373

    6    tmpdob6onth                        0x000055df51185ab7 <unavailable> + 6839

    7    tmpdob6onth                        0x000055df511855c2 <unavailable> + 5570

    8    libc.so.6                          0x00002ad31a511460 __libc_start_main +
    245

    9    tmpdob6onth                        0x000055df511852c9 <unavailable> + 4809

    '
  stdout: ''
  timestamp: 1659978931
- exit_code: 1
  program: "\n/// Insert a number 'delimeter' between every two consecutive elements\
    \ of input array `numbers'\n/// >>> intersperse(numbers: [] as [Int], delimeter:\
    \ 4)\n/// [] as [Int]\n/// >>> intersperse(numbers: [1, 2, 3], delimeter: 4)\n\
    /// [1, 4, 2, 4, 3]\nfunc intersperse(numbers: [Int], delimeter: Int) -> [Int]\
    \ {\n    let mappedNumbers = numbers.map { [$0] }\n    let mappedDelimeter = delimeter.map\
    \ { [$0] }\n    return intersperse(arrays: mappedNumbers, delimeter: mappedDelimeter).flatten()\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(intersperse(numbers: [] as [Int], delimeter: 7)\
    \ == [] as [Int])\nassert(intersperse(numbers: [5, 6, 3, 2], delimeter: 8) ==\
    \ [5, 8, 6, 8, 3, 8, 2])\nassert(intersperse(numbers: [2, 2, 2], delimeter: 2)\
    \ == [2, 2, 2, 2, 2])"
  status: SyntaxError
  stderr: "/tmp/tmpznde9nxv.swift:9:37: error: value of type 'Int' has no member 'map'\n\
    \    let mappedDelimeter = delimeter.map { [$0] }\n                          ~~~~~~~~~\
    \ ^~~\n/tmp/tmpznde9nxv.swift:10:23: error: incorrect argument label in call (have\
    \ 'arrays:delimeter:', expected 'numbers:delimeter:')\n    return intersperse(arrays:\
    \ mappedNumbers, delimeter: mappedDelimeter).flatten()\n                     \
    \ ^~~~~~~\n                       numbers\n/tmp/tmpznde9nxv.swift:10:32: error:\
    \ cannot convert value of type '[[Int]]' to expected argument type '[Int]'\n \
    \   return intersperse(arrays: mappedNumbers, delimeter: mappedDelimeter).flatten()\n\
    \                               ^\n/tmp/tmpznde9nxv.swift:10:32: note: arguments\
    \ to generic parameter 'Element' ('[Int]' and 'Int') are expected to be equal\n\
    \    return intersperse(arrays: mappedNumbers, delimeter: mappedDelimeter).flatten()\n\
    \                               ^\n/tmp/tmpznde9nxv.swift:10:75: error: value\
    \ of type '[Int]' has no member 'flatten'\n    return intersperse(arrays: mappedNumbers,\
    \ delimeter: mappedDelimeter).flatten()\n           ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\
    \ ^~~~~~~\n"
  stdout: ''
  timestamp: 1659978931
- exit_code: 0
  program: "\n/// Insert a number 'delimeter' between every two consecutive elements\
    \ of input array `numbers'\n/// >>> intersperse(numbers: [] as [Int], delimeter:\
    \ 4)\n/// [] as [Int]\n/// >>> intersperse(numbers: [1, 2, 3], delimeter: 4)\n\
    /// [1, 4, 2, 4, 3]\nfunc intersperse(numbers: [Int], delimeter: Int) -> [Int]\
    \ {\n    guard numbers.count > 1 else { return numbers }\n    var result = [Int]()\n\
    \    for index in 0 ..< numbers.count {\n        result.append(numbers[index])\n\
    \        if index < numbers.count - 1 {\n            result.append(delimeter)\n\
    \        }\n    }\n    return result\n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(intersperse(numbers: [] as [Int], delimeter: 7) == [] as [Int])\nassert(intersperse(numbers:\
    \ [5, 6, 3, 2], delimeter: 8) == [5, 8, 6, 8, 3, 8, 2])\nassert(intersperse(numbers:\
    \ [2, 2, 2], delimeter: 2) == [2, 2, 2, 2, 2])"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659978931
- exit_code: 0
  program: "\n/// Insert a number 'delimeter' between every two consecutive elements\
    \ of input array `numbers'\n/// >>> intersperse(numbers: [] as [Int], delimeter:\
    \ 4)\n/// [] as [Int]\n/// >>> intersperse(numbers: [1, 2, 3], delimeter: 4)\n\
    /// [1, 4, 2, 4, 3]\nfunc intersperse(numbers: [Int], delimeter: Int) -> [Int]\
    \ {\n    guard !numbers.isEmpty else { return [] }\n    var output = [Int]()\n\
    \    for i in 0 ..< numbers.count - 1 {\n        output.append(numbers[i])\n \
    \       output.append(delimeter)\n    }\n    output.append(numbers.last!)\n  \
    \  return output\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool\
    \ {\n    if left.count != right.count {\n        return false\n    }\n    for\
    \ (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(intersperse(numbers:\
    \ [] as [Int], delimeter: 7) == [] as [Int])\nassert(intersperse(numbers: [5,\
    \ 6, 3, 2], delimeter: 8) == [5, 8, 6, 8, 3, 8, 2])\nassert(intersperse(numbers:\
    \ [2, 2, 2], delimeter: 2) == [2, 2, 2, 2, 2])"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659978931
- exit_code: -4
  program: "\n/// Insert a number 'delimeter' between every two consecutive elements\
    \ of input array `numbers'\n/// >>> intersperse(numbers: [] as [Int], delimeter:\
    \ 4)\n/// [] as [Int]\n/// >>> intersperse(numbers: [1, 2, 3], delimeter: 4)\n\
    /// [1, 4, 2, 4, 3]\nfunc intersperse(numbers: [Int], delimeter: Int) -> [Int]\
    \ {\n    var result: [Int] = []\n    for number in numbers {\n        result.append(number)\n\
    \        result.append(delimeter)\n    }\n    result.removeLast()\n    return\
    \ result\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n\
    \    if left.count != right.count {\n        return false\n    }\n    for (l,\
    \ r) in zip(left, right) {\n        if l != r {\n            return false\n  \
    \      }\n    }\n    return true\n}\n            \nassert(intersperse(numbers:\
    \ [] as [Int], delimeter: 7) == [] as [Int])\nassert(intersperse(numbers: [5,\
    \ 6, 3, 2], delimeter: 8) == [5, 8, 6, 8, 3, 8, 2])\nassert(intersperse(numbers:\
    \ [2, 2, 2], delimeter: 2) == [2, 2, 2, 2, 2])"
  status: Exception
  stderr: 'Swift/RangeReplaceableCollection.swift:870: Fatal error: Can''t remove
    last element from an empty collection

    Current stack trace:

    0    libswiftCore.so                    0x00002b3b4763ec80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b3b47335561 <unavailable> + 1434977

    2    libswiftCore.so                    0x00002b3b47335286 <unavailable> + 1434246

    3    libswiftCore.so                    0x00002b3b4733513c <unavailable> + 1433916

    4    libswiftCore.so                    0x00002b3b47334bb0 _assertionFailure(_:_:file:line:flags:)
    + 251

    5    libswiftCore.so                    0x00002b3b47436c1d <unavailable> + 2489373

    6    tmpx16ziy_q                        0x00005627f8d2ba72 <unavailable> + 6770

    7    tmpx16ziy_q                        0x00005627f8d2b572 <unavailable> + 5490

    8    libc.so.6                          0x00002b3b4782a460 __libc_start_main +
    245

    9    tmpx16ziy_q                        0x00005627f8d2b279 <unavailable> + 4729

    '
  stdout: ''
  timestamp: 1659978931
- exit_code: -4
  program: "\n/// Insert a number 'delimeter' between every two consecutive elements\
    \ of input array `numbers'\n/// >>> intersperse(numbers: [] as [Int], delimeter:\
    \ 4)\n/// [] as [Int]\n/// >>> intersperse(numbers: [1, 2, 3], delimeter: 4)\n\
    /// [1, 4, 2, 4, 3]\nfunc intersperse(numbers: [Int], delimeter: Int) -> [Int]\
    \ {\n    return numbers.reduce([]) { [delimeter] + $0 + [$1] }.dropFirst().dropLast()\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(intersperse(numbers: [] as [Int], delimeter: 7)\
    \ == [] as [Int])\nassert(intersperse(numbers: [5, 6, 3, 2], delimeter: 8) ==\
    \ [5, 8, 6, 8, 3, 8, 2])\nassert(intersperse(numbers: [2, 2, 2], delimeter: 2)\
    \ == [2, 2, 2, 2, 2])"
  status: Exception
  stderr: 'tmpm38szct1/tmpm38szct1.swift:25: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b6eba858c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b6eba54fb6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b6eba54f988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b6eba54e7b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpm38szct1                        0x000055d7ce6e073f <unavailable> + 5951

    5    libc.so.6                          0x00002b6ebaa44460 __libc_start_main +
    245

    6    tmpm38szct1                        0x000055d7ce6e0239 <unavailable> + 4665

    '
  stdout: ''
  timestamp: 1659978931
- exit_code: 0
  program: "\n/// Insert a number 'delimeter' between every two consecutive elements\
    \ of input array `numbers'\n/// >>> intersperse(numbers: [] as [Int], delimeter:\
    \ 4)\n/// [] as [Int]\n/// >>> intersperse(numbers: [1, 2, 3], delimeter: 4)\n\
    /// [1, 4, 2, 4, 3]\nfunc intersperse(numbers: [Int], delimeter: Int) -> [Int]\
    \ {\n    guard let first = numbers.first else { return [] }\n    return [first]\
    \ + numbers.dropFirst().map { [delimeter, $0] }.flatMap { $0 }\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(intersperse(numbers: [] as [Int], delimeter: 7) == []\
    \ as [Int])\nassert(intersperse(numbers: [5, 6, 3, 2], delimeter: 8) == [5, 8,\
    \ 6, 8, 3, 8, 2])\nassert(intersperse(numbers: [2, 2, 2], delimeter: 2) == [2,\
    \ 2, 2, 2, 2])"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659978931
- exit_code: 1
  program: "\n/// Insert a number 'delimeter' between every two consecutive elements\
    \ of input array `numbers'\n/// >>> intersperse(numbers: [] as [Int], delimeter:\
    \ 4)\n/// [] as [Int]\n/// >>> intersperse(numbers: [1, 2, 3], delimeter: 4)\n\
    /// [1, 4, 2, 4, 3]\nfunc intersperse(numbers: [Int], delimeter: Int) -> [Int]\
    \ {\n    let numbers2 = dropFirst(numbers)\n    if numbers2.isEmpty {\n      \
    \  return []\n    } else {\n        return [numbers[0]] + [delimeter] + intersperse(numbers2,\
    \ delimeter: delimeter)\n    }\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int,\
    \ Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n\
    \    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n          \
    \  return false\n        }\n    }\n    return true\n}\n            \nassert(intersperse(numbers:\
    \ [] as [Int], delimeter: 7) == [] as [Int])\nassert(intersperse(numbers: [5,\
    \ 6, 3, 2], delimeter: 8) == [5, 8, 6, 8, 3, 8, 2])\nassert(intersperse(numbers:\
    \ [2, 2, 2], delimeter: 2) == [2, 2, 2, 2, 2])"
  status: SyntaxError
  stderr: "/tmp/tmp8adhyw05.swift:8:20: error: cannot find 'dropFirst' in scope\n\
    \    let numbers2 = dropFirst(numbers)\n                   ^~~~~~~~~\n/tmp/tmp8adhyw05.swift:12:56:\
    \ error: missing argument label 'numbers:' in call\n        return [numbers[0]]\
    \ + [delimeter] + intersperse(numbers2, delimeter: delimeter)\n              \
    \                                         ^\n                                \
    \                        numbers: \n"
  stdout: ''
  timestamp: 1659978931
- exit_code: 0
  program: "\n/// Insert a number 'delimeter' between every two consecutive elements\
    \ of input array `numbers'\n/// >>> intersperse(numbers: [] as [Int], delimeter:\
    \ 4)\n/// [] as [Int]\n/// >>> intersperse(numbers: [1, 2, 3], delimeter: 4)\n\
    /// [1, 4, 2, 4, 3]\nfunc intersperse(numbers: [Int], delimeter: Int) -> [Int]\
    \ {\n    var res = [Int]()\n    guard numbers.count > 1 else {\n        return\
    \ numbers\n    }\n    for i in 0 ..< numbers.count - 1 {\n        res.append(numbers[i])\n\
    \        res.append(delimeter)\n    }\n    res.append(numbers[numbers.count -\
    \ 1])\n    return res\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(intersperse(numbers:\
    \ [] as [Int], delimeter: 7) == [] as [Int])\nassert(intersperse(numbers: [5,\
    \ 6, 3, 2], delimeter: 8) == [5, 8, 6, 8, 3, 8, 2])\nassert(intersperse(numbers:\
    \ [2, 2, 2], delimeter: 2) == [2, 2, 2, 2, 2])"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659978931
- exit_code: 0
  program: "\n/// Insert a number 'delimeter' between every two consecutive elements\
    \ of input array `numbers'\n/// >>> intersperse(numbers: [] as [Int], delimeter:\
    \ 4)\n/// [] as [Int]\n/// >>> intersperse(numbers: [1, 2, 3], delimeter: 4)\n\
    /// [1, 4, 2, 4, 3]\nfunc intersperse(numbers: [Int], delimeter: Int) -> [Int]\
    \ {\n    var interspersed: [Int] = []\n    for i in 0..<numbers.count {\n    \
    \    interspersed.append(numbers[i])\n        if i < numbers.count - 1 {\n   \
    \         interspersed.append(delimeter)\n        }\n    }\n    return interspersed\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(intersperse(numbers: [] as [Int], delimeter: 7)\
    \ == [] as [Int])\nassert(intersperse(numbers: [5, 6, 3, 2], delimeter: 8) ==\
    \ [5, 8, 6, 8, 3, 8, 2])\nassert(intersperse(numbers: [2, 2, 2], delimeter: 2)\
    \ == [2, 2, 2, 2, 2])"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659978931
- exit_code: 0
  program: "\n/// Insert a number 'delimeter' between every two consecutive elements\
    \ of input array `numbers'\n/// >>> intersperse(numbers: [] as [Int], delimeter:\
    \ 4)\n/// [] as [Int]\n/// >>> intersperse(numbers: [1, 2, 3], delimeter: 4)\n\
    /// [1, 4, 2, 4, 3]\nfunc intersperse(numbers: [Int], delimeter: Int) -> [Int]\
    \ {\n    var result: [Int] = []\n    for i in 0 ..< numbers.count {\n        result.append(numbers[i])\n\
    \        if i != numbers.count - 1 {\n            result.append(delimeter)\n \
    \       }\n    }\n    return result\n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(intersperse(numbers: [] as [Int], delimeter: 7) == [] as [Int])\nassert(intersperse(numbers:\
    \ [5, 6, 3, 2], delimeter: 8) == [5, 8, 6, 8, 3, 8, 2])\nassert(intersperse(numbers:\
    \ [2, 2, 2], delimeter: 2) == [2, 2, 2, 2, 2])"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659978931
- exit_code: 0
  program: "\n/// Insert a number 'delimeter' between every two consecutive elements\
    \ of input array `numbers'\n/// >>> intersperse(numbers: [] as [Int], delimeter:\
    \ 4)\n/// [] as [Int]\n/// >>> intersperse(numbers: [1, 2, 3], delimeter: 4)\n\
    /// [1, 4, 2, 4, 3]\nfunc intersperse(numbers: [Int], delimeter: Int) -> [Int]\
    \ {\n\tvar result = [Int]()\n\tlet length = numbers.count\n\tif length == 0 {\n\
    \t\treturn result\n\t} else if length == 1 {\n\t\tresult.append(numbers[0])\n\t\
    \treturn result\n\t}\n\t\n\tresult.append(numbers[0])\n\tfor i in 1 ..< length\
    \ {\n\t\tresult.append(delimeter)\n\t\tresult.append(numbers[i])\n\t}\n\treturn\
    \ result\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n\
    \    if left.count != right.count {\n        return false\n    }\n    for (l,\
    \ r) in zip(left, right) {\n        if l != r {\n            return false\n  \
    \      }\n    }\n    return true\n}\n            \nassert(intersperse(numbers:\
    \ [] as [Int], delimeter: 7) == [] as [Int])\nassert(intersperse(numbers: [5,\
    \ 6, 3, 2], delimeter: 8) == [5, 8, 6, 8, 3, 8, 2])\nassert(intersperse(numbers:\
    \ [2, 2, 2], delimeter: 2) == [2, 2, 2, 2, 2])"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659978931
- exit_code: 0
  program: "\n/// Insert a number 'delimeter' between every two consecutive elements\
    \ of input array `numbers'\n/// >>> intersperse(numbers: [] as [Int], delimeter:\
    \ 4)\n/// [] as [Int]\n/// >>> intersperse(numbers: [1, 2, 3], delimeter: 4)\n\
    /// [1, 4, 2, 4, 3]\nfunc intersperse(numbers: [Int], delimeter: Int) -> [Int]\
    \ {\n    // CHECK\n    if numbers.count <= 1 {\n        return numbers\n    }\n\
    \    // BASE\n    var newNumbers = [Int]()\n    for i in 0 ..< numbers.count -\
    \ 1 {\n        newNumbers.append(numbers[i])\n        newNumbers.append(delimeter)\n\
    \    }\n    newNumbers.append(numbers[numbers.count - 1])\n    return newNumbers\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(intersperse(numbers: [] as [Int], delimeter: 7)\
    \ == [] as [Int])\nassert(intersperse(numbers: [5, 6, 3, 2], delimeter: 8) ==\
    \ [5, 8, 6, 8, 3, 8, 2])\nassert(intersperse(numbers: [2, 2, 2], delimeter: 2)\
    \ == [2, 2, 2, 2, 2])"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659978931
- exit_code: 0
  program: "\n/// Insert a number 'delimeter' between every two consecutive elements\
    \ of input array `numbers'\n/// >>> intersperse(numbers: [] as [Int], delimeter:\
    \ 4)\n/// [] as [Int]\n/// >>> intersperse(numbers: [1, 2, 3], delimeter: 4)\n\
    /// [1, 4, 2, 4, 3]\nfunc intersperse(numbers: [Int], delimeter: Int) -> [Int]\
    \ {\n    return numbers.reduce([]) { (x, y) in x + [y, delimeter] }.dropLast()\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(intersperse(numbers: [] as [Int], delimeter: 7)\
    \ == [] as [Int])\nassert(intersperse(numbers: [5, 6, 3, 2], delimeter: 8) ==\
    \ [5, 8, 6, 8, 3, 8, 2])\nassert(intersperse(numbers: [2, 2, 2], delimeter: 2)\
    \ == [2, 2, 2, 2, 2])"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659978931
- exit_code: 0
  program: "\n/// Insert a number 'delimeter' between every two consecutive elements\
    \ of input array `numbers'\n/// >>> intersperse(numbers: [] as [Int], delimeter:\
    \ 4)\n/// [] as [Int]\n/// >>> intersperse(numbers: [1, 2, 3], delimeter: 4)\n\
    /// [1, 4, 2, 4, 3]\nfunc intersperse(numbers: [Int], delimeter: Int) -> [Int]\
    \ {\n  if numbers.isEmpty {\n    return []\n  }\n  var result = [Int]()\n  result.append(numbers[0])\n\
    \  for n in numbers[1..<numbers.count] {\n    result.append(delimeter)\n    result.append(n)\n\
    \  }\n  return result\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(intersperse(numbers:\
    \ [] as [Int], delimeter: 7) == [] as [Int])\nassert(intersperse(numbers: [5,\
    \ 6, 3, 2], delimeter: 8) == [5, 8, 6, 8, 3, 8, 2])\nassert(intersperse(numbers:\
    \ [2, 2, 2], delimeter: 2) == [2, 2, 2, 2, 2])"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659978931
- exit_code: 0
  program: "\n/// Insert a number 'delimeter' between every two consecutive elements\
    \ of input array `numbers'\n/// >>> intersperse(numbers: [] as [Int], delimeter:\
    \ 4)\n/// [] as [Int]\n/// >>> intersperse(numbers: [1, 2, 3], delimeter: 4)\n\
    /// [1, 4, 2, 4, 3]\nfunc intersperse(numbers: [Int], delimeter: Int) -> [Int]\
    \ {\n    let len = numbers.count\n    guard len > 1 else { return numbers }\n\
    \    var result = [Int]()\n    for i in 0..<len-1 {\n        result.append(numbers[i])\n\
    \        result.append(delimeter)\n    }\n    result.append(numbers[len-1])\n\
    \    return result\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) ->\
    \ Bool {\n    if left.count != right.count {\n        return false\n    }\n  \
    \  for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(intersperse(numbers:\
    \ [] as [Int], delimeter: 7) == [] as [Int])\nassert(intersperse(numbers: [5,\
    \ 6, 3, 2], delimeter: 8) == [5, 8, 6, 8, 3, 8, 2])\nassert(intersperse(numbers:\
    \ [2, 2, 2], delimeter: 2) == [2, 2, 2, 2, 2])"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659978931
- exit_code: 0
  program: "\n/// Insert a number 'delimeter' between every two consecutive elements\
    \ of input array `numbers'\n/// >>> intersperse(numbers: [] as [Int], delimeter:\
    \ 4)\n/// [] as [Int]\n/// >>> intersperse(numbers: [1, 2, 3], delimeter: 4)\n\
    /// [1, 4, 2, 4, 3]\nfunc intersperse(numbers: [Int], delimeter: Int) -> [Int]\
    \ {\n    var result: [Int] = []\n    if numbers.count == 0 {\n        return result\n\
    \    }\n    if numbers.count == 1 {\n        result.append(numbers[0])\n     \
    \   return result\n    }\n    for number in numbers {\n        result.append(number)\n\
    \        result.append(delimeter)\n    }\n    result.removeLast()\n    return\
    \ result\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n\
    \    if left.count != right.count {\n        return false\n    }\n    for (l,\
    \ r) in zip(left, right) {\n        if l != r {\n            return false\n  \
    \      }\n    }\n    return true\n}\n            \nassert(intersperse(numbers:\
    \ [] as [Int], delimeter: 7) == [] as [Int])\nassert(intersperse(numbers: [5,\
    \ 6, 3, 2], delimeter: 8) == [5, 8, 6, 8, 3, 8, 2])\nassert(intersperse(numbers:\
    \ [2, 2, 2], delimeter: 2) == [2, 2, 2, 2, 2])"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659978931
- exit_code: 0
  program: "\n/// Insert a number 'delimeter' between every two consecutive elements\
    \ of input array `numbers'\n/// >>> intersperse(numbers: [] as [Int], delimeter:\
    \ 4)\n/// [] as [Int]\n/// >>> intersperse(numbers: [1, 2, 3], delimeter: 4)\n\
    /// [1, 4, 2, 4, 3]\nfunc intersperse(numbers: [Int], delimeter: Int) -> [Int]\
    \ {\n    var result: [Int] = []\n    for i in 0..<numbers.count {\n        result.append(numbers[i])\n\
    \        if i != numbers.count - 1 {\n            result.append(delimeter)\n \
    \       }\n    }\n    return result\n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(intersperse(numbers: [] as [Int], delimeter: 7) == [] as [Int])\nassert(intersperse(numbers:\
    \ [5, 6, 3, 2], delimeter: 8) == [5, 8, 6, 8, 3, 8, 2])\nassert(intersperse(numbers:\
    \ [2, 2, 2], delimeter: 2) == [2, 2, 2, 2, 2])"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659978931
- exit_code: 0
  program: "\n/// Insert a number 'delimeter' between every two consecutive elements\
    \ of input array `numbers'\n/// >>> intersperse(numbers: [] as [Int], delimeter:\
    \ 4)\n/// [] as [Int]\n/// >>> intersperse(numbers: [1, 2, 3], delimeter: 4)\n\
    /// [1, 4, 2, 4, 3]\nfunc intersperse(numbers: [Int], delimeter: Int) -> [Int]\
    \ {\n    func interspersed(numbers: [Int], delimeter: Int, interspersed: [Int])\
    \ -> [Int] {\n        switch numbers.count {\n        case 0:\n            return\
    \ interspersed\n        case 1:\n            return interspersed + numbers\n \
    \       default:\n            return interspersed + [numbers[0], delimeter] +\
    \ intersperse(numbers: Array(numbers[1..<numbers.count]), delimeter: delimeter)\n\
    \        }\n    }\n    return interspersed(numbers: numbers, delimeter: delimeter,\
    \ interspersed: [])\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) ->\
    \ Bool {\n    if left.count != right.count {\n        return false\n    }\n  \
    \  for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(intersperse(numbers:\
    \ [] as [Int], delimeter: 7) == [] as [Int])\nassert(intersperse(numbers: [5,\
    \ 6, 3, 2], delimeter: 8) == [5, 8, 6, 8, 3, 8, 2])\nassert(intersperse(numbers:\
    \ [2, 2, 2], delimeter: 2) == [2, 2, 2, 2, 2])"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659978931
- exit_code: 0
  program: "\n/// Insert a number 'delimeter' between every two consecutive elements\
    \ of input array `numbers'\n/// >>> intersperse(numbers: [] as [Int], delimeter:\
    \ 4)\n/// [] as [Int]\n/// >>> intersperse(numbers: [1, 2, 3], delimeter: 4)\n\
    /// [1, 4, 2, 4, 3]\nfunc intersperse(numbers: [Int], delimeter: Int) -> [Int]\
    \ {\n    if numbers.isEmpty {\n        return []\n    }\n    else if numbers.count\
    \ == 1 {\n        return numbers\n    }\n    else {\n        var result: [Int]\
    \ = []\n        for i in 0..<numbers.count - 1 {\n            result.append(numbers[i])\n\
    \            result.append(delimeter)\n        }\n        result.append(numbers[numbers.count\
    \ - 1])\n        return result\n    }\n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(intersperse(numbers: [] as [Int], delimeter: 7) == [] as [Int])\nassert(intersperse(numbers:\
    \ [5, 6, 3, 2], delimeter: 8) == [5, 8, 6, 8, 3, 8, 2])\nassert(intersperse(numbers:\
    \ [2, 2, 2], delimeter: 2) == [2, 2, 2, 2, 2])"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659978932
- exit_code: -4
  program: "\n/// Insert a number 'delimeter' between every two consecutive elements\
    \ of input array `numbers'\n/// >>> intersperse(numbers: [] as [Int], delimeter:\
    \ 4)\n/// [] as [Int]\n/// >>> intersperse(numbers: [1, 2, 3], delimeter: 4)\n\
    /// [1, 4, 2, 4, 3]\nfunc intersperse(numbers: [Int], delimeter: Int) -> [Int]\
    \ {\n    if numbers.isEmpty {\n        return []\n    } else {\n        return\
    \ [numbers[0]] + [delimeter] + intersperse(numbers: Array(numbers[1..<numbers.count]),\
    \ delimeter: delimeter)\n    }\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int,\
    \ Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n\
    \    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n          \
    \  return false\n        }\n    }\n    return true\n}\n            \nassert(intersperse(numbers:\
    \ [] as [Int], delimeter: 7) == [] as [Int])\nassert(intersperse(numbers: [5,\
    \ 6, 3, 2], delimeter: 8) == [5, 8, 6, 8, 3, 8, 2])\nassert(intersperse(numbers:\
    \ [2, 2, 2], delimeter: 2) == [2, 2, 2, 2, 2])"
  status: Exception
  stderr: 'tmptiybotqt/tmptiybotqt.swift:29: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b91ce0eec80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b91cdde5b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b91cdde5988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b91cdde47b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmptiybotqt                        0x0000563d4cdcc85f <unavailable> + 6239

    5    libc.so.6                          0x00002b91ce2da460 __libc_start_main +
    245

    6    tmptiybotqt                        0x0000563d4cdcc359 <unavailable> + 4953

    '
  stdout: ''
  timestamp: 1659978932
- exit_code: 1
  program: "\n/// Insert a number 'delimeter' between every two consecutive elements\
    \ of input array `numbers'\n/// >>> intersperse(numbers: [] as [Int], delimeter:\
    \ 4)\n/// [] as [Int]\n/// >>> intersperse(numbers: [1, 2, 3], delimeter: 4)\n\
    /// [1, 4, 2, 4, 3]\nfunc intersperse(numbers: [Int], delimeter: Int) -> [Int]\
    \ {\n    return Array(\n        numbers\n            .map{ Array(repeating: $0,\
    \ count: 2) }\n            .flatMap{ $0 }\n            .dropLast()\n         \
    \   .map{ ($0, delimeter) }\n            .joined()\n    )\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(intersperse(numbers: [] as [Int], delimeter: 7) == []\
    \ as [Int])\nassert(intersperse(numbers: [5, 6, 3, 2], delimeter: 8) == [5, 8,\
    \ 6, 8, 3, 8, 2])\nassert(intersperse(numbers: [2, 2, 2], delimeter: 2) == [2,\
    \ 2, 2, 2, 2])"
  status: SyntaxError
  stderr: "/tmp/tmpyshzkuty.swift:13:14: error: type '(Int, Int)' cannot conform to\
    \ 'Sequence'\n            .map{ ($0, delimeter) }\n             ^\n/tmp/tmpyshzkuty.swift:13:14:\
    \ note: only concrete types such as structs, enums and classes can conform to\
    \ protocols\n            .map{ ($0, delimeter) }\n             ^\n/tmp/tmpyshzkuty.swift:13:14:\
    \ note: required by referencing instance method 'joined()' on 'Sequence' where\
    \ 'Self.Element' = '(Int, Int)'\n            .map{ ($0, delimeter) }\n       \
    \      ^\n"
  stdout: ''
  timestamp: 1659978933
- exit_code: 0
  program: "\n/// Insert a number 'delimeter' between every two consecutive elements\
    \ of input array `numbers'\n/// >>> intersperse(numbers: [] as [Int], delimeter:\
    \ 4)\n/// [] as [Int]\n/// >>> intersperse(numbers: [1, 2, 3], delimeter: 4)\n\
    /// [1, 4, 2, 4, 3]\nfunc intersperse(numbers: [Int], delimeter: Int) -> [Int]\
    \ {\n    if numbers.isEmpty {\n        return []\n    } else {\n        var result\
    \ = [Int]()\n        for index in 0...numbers.count-1 {\n            if index\
    \ != numbers.count-1 {\n                result.append(numbers[index])\n      \
    \          result.append(delimeter)\n            } else {\n                result.append(numbers[index])\n\
    \            }\n        }\n        return result\n    }\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(intersperse(numbers: [] as [Int], delimeter: 7) == []\
    \ as [Int])\nassert(intersperse(numbers: [5, 6, 3, 2], delimeter: 8) == [5, 8,\
    \ 6, 8, 3, 8, 2])\nassert(intersperse(numbers: [2, 2, 2], delimeter: 2) == [2,\
    \ 2, 2, 2, 2])"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659978932
- exit_code: 0
  program: "\n/// Insert a number 'delimeter' between every two consecutive elements\
    \ of input array `numbers'\n/// >>> intersperse(numbers: [] as [Int], delimeter:\
    \ 4)\n/// [] as [Int]\n/// >>> intersperse(numbers: [1, 2, 3], delimeter: 4)\n\
    /// [1, 4, 2, 4, 3]\nfunc intersperse(numbers: [Int], delimeter: Int) -> [Int]\
    \ {\n    return numbers.reduce([]) { acc, n in\n        var acc = acc\n      \
    \  acc.append(n)\n        acc.append(delimeter)\n        return acc\n    }.dropLast()\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(intersperse(numbers: [] as [Int], delimeter: 7)\
    \ == [] as [Int])\nassert(intersperse(numbers: [5, 6, 3, 2], delimeter: 8) ==\
    \ [5, 8, 6, 8, 3, 8, 2])\nassert(intersperse(numbers: [2, 2, 2], delimeter: 2)\
    \ == [2, 2, 2, 2, 2])"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659978932
- exit_code: 0
  program: "\n/// Insert a number 'delimeter' between every two consecutive elements\
    \ of input array `numbers'\n/// >>> intersperse(numbers: [] as [Int], delimeter:\
    \ 4)\n/// [] as [Int]\n/// >>> intersperse(numbers: [1, 2, 3], delimeter: 4)\n\
    /// [1, 4, 2, 4, 3]\nfunc intersperse(numbers: [Int], delimeter: Int) -> [Int]\
    \ {\n  if numbers.isEmpty {\n    return []\n  } else if numbers.count == 1 {\n\
    \    return numbers\n  } else {\n    var result = [Int]()\n    for i in 0..<numbers.count\
    \ {\n      result.append(numbers[i])\n      if i < numbers.count - 1 {\n     \
    \   result.append(delimeter)\n      }\n    }\n    return result\n  }\n}\n\n\n\
    func ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(intersperse(numbers: [] as [Int], delimeter: 7)\
    \ == [] as [Int])\nassert(intersperse(numbers: [5, 6, 3, 2], delimeter: 8) ==\
    \ [5, 8, 6, 8, 3, 8, 2])\nassert(intersperse(numbers: [2, 2, 2], delimeter: 2)\
    \ == [2, 2, 2, 2, 2])"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659978932
- exit_code: 0
  program: "\n/// Insert a number 'delimeter' between every two consecutive elements\
    \ of input array `numbers'\n/// >>> intersperse(numbers: [] as [Int], delimeter:\
    \ 4)\n/// [] as [Int]\n/// >>> intersperse(numbers: [1, 2, 3], delimeter: 4)\n\
    /// [1, 4, 2, 4, 3]\nfunc intersperse(numbers: [Int], delimeter: Int) -> [Int]\
    \ {\n\tif numbers.isEmpty {\n\t\treturn []\n\t}\n\tif numbers.count == 1 {\n\t\
    \treturn numbers\n\t}\n\tvar result = [Int]()\n\tresult.append(numbers[0])\n\t\
    for i in 1 ..< numbers.count {\n\t\tresult.append(delimeter)\n\t\tresult.append(numbers[i])\n\
    \t}\n\treturn result\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(intersperse(numbers:\
    \ [] as [Int], delimeter: 7) == [] as [Int])\nassert(intersperse(numbers: [5,\
    \ 6, 3, 2], delimeter: 8) == [5, 8, 6, 8, 3, 8, 2])\nassert(intersperse(numbers:\
    \ [2, 2, 2], delimeter: 2) == [2, 2, 2, 2, 2])"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659978932
- exit_code: 0
  program: "\n/// Insert a number 'delimeter' between every two consecutive elements\
    \ of input array `numbers'\n/// >>> intersperse(numbers: [] as [Int], delimeter:\
    \ 4)\n/// [] as [Int]\n/// >>> intersperse(numbers: [1, 2, 3], delimeter: 4)\n\
    /// [1, 4, 2, 4, 3]\nfunc intersperse(numbers: [Int], delimeter: Int) -> [Int]\
    \ {\n    if numbers.isEmpty {\n        return []\n    }\n    if numbers.count\
    \ == 1 {\n        return numbers\n    }\n    var result = [Int]()\n    result.append(numbers[0])\n\
    \    for i in 1..<numbers.count {\n        result.append(delimeter)\n        result.append(numbers[i])\n\
    \    }\n    return result\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(intersperse(numbers:\
    \ [] as [Int], delimeter: 7) == [] as [Int])\nassert(intersperse(numbers: [5,\
    \ 6, 3, 2], delimeter: 8) == [5, 8, 6, 8, 3, 8, 2])\nassert(intersperse(numbers:\
    \ [2, 2, 2], delimeter: 2) == [2, 2, 2, 2, 2])"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659978932
- exit_code: 0
  program: "\n/// Insert a number 'delimeter' between every two consecutive elements\
    \ of input array `numbers'\n/// >>> intersperse(numbers: [] as [Int], delimeter:\
    \ 4)\n/// [] as [Int]\n/// >>> intersperse(numbers: [1, 2, 3], delimeter: 4)\n\
    /// [1, 4, 2, 4, 3]\nfunc intersperse(numbers: [Int], delimeter: Int) -> [Int]\
    \ {\n    // validating input parameter\n    guard numbers.count > 0 else {\n \
    \       return []\n    }\n    \n    var items = [Int]()\n    for item in numbers\
    \ {\n        if items.count > 0 {\n            items.append(delimeter)\n     \
    \   }\n        items.append(item)\n    }\n    return items\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(intersperse(numbers: [] as [Int], delimeter: 7) == []\
    \ as [Int])\nassert(intersperse(numbers: [5, 6, 3, 2], delimeter: 8) == [5, 8,\
    \ 6, 8, 3, 8, 2])\nassert(intersperse(numbers: [2, 2, 2], delimeter: 2) == [2,\
    \ 2, 2, 2, 2])"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659978932
- exit_code: 0
  program: "\n/// Insert a number 'delimeter' between every two consecutive elements\
    \ of input array `numbers'\n/// >>> intersperse(numbers: [] as [Int], delimeter:\
    \ 4)\n/// [] as [Int]\n/// >>> intersperse(numbers: [1, 2, 3], delimeter: 4)\n\
    /// [1, 4, 2, 4, 3]\nfunc intersperse(numbers: [Int], delimeter: Int) -> [Int]\
    \ {\n  var newArray = [Int]()\n  let count = numbers.count\n  for index in 0 ..<\
    \ count {\n    newArray.append(numbers[index])\n    if index != count - 1 {\n\
    \      newArray.append(delimeter)\n    }\n  }\n  return newArray\n}\n\n\nfunc\
    \ ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count !=\
    \ right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(intersperse(numbers: [] as [Int], delimeter: 7)\
    \ == [] as [Int])\nassert(intersperse(numbers: [5, 6, 3, 2], delimeter: 8) ==\
    \ [5, 8, 6, 8, 3, 8, 2])\nassert(intersperse(numbers: [2, 2, 2], delimeter: 2)\
    \ == [2, 2, 2, 2, 2])"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659978932
- exit_code: 0
  program: "\n/// Insert a number 'delimeter' between every two consecutive elements\
    \ of input array `numbers'\n/// >>> intersperse(numbers: [] as [Int], delimeter:\
    \ 4)\n/// [] as [Int]\n/// >>> intersperse(numbers: [1, 2, 3], delimeter: 4)\n\
    /// [1, 4, 2, 4, 3]\nfunc intersperse(numbers: [Int], delimeter: Int) -> [Int]\
    \ {\n\tguard numbers.count > 1 else { return numbers }\n\tvar numbersWithDelimeters\
    \ = [Int]()\n\tvar previousNumber = numbers[0]\n\tnumbersWithDelimeters.append(previousNumber)\n\
    \tfor number in numbers[1..<numbers.count] {\n\t\tnumbersWithDelimeters.append(delimeter)\n\
    \t\tnumbersWithDelimeters.append(number)\n\t}\n\treturn numbersWithDelimeters\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(intersperse(numbers: [] as [Int], delimeter: 7)\
    \ == [] as [Int])\nassert(intersperse(numbers: [5, 6, 3, 2], delimeter: 8) ==\
    \ [5, 8, 6, 8, 3, 8, 2])\nassert(intersperse(numbers: [2, 2, 2], delimeter: 2)\
    \ == [2, 2, 2, 2, 2])"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659978932
- exit_code: 0
  program: "\n/// Insert a number 'delimeter' between every two consecutive elements\
    \ of input array `numbers'\n/// >>> intersperse(numbers: [] as [Int], delimeter:\
    \ 4)\n/// [] as [Int]\n/// >>> intersperse(numbers: [1, 2, 3], delimeter: 4)\n\
    /// [1, 4, 2, 4, 3]\nfunc intersperse(numbers: [Int], delimeter: Int) -> [Int]\
    \ {\n    if numbers.isEmpty {\n        return []\n    } else {\n        var copy\
    \ = numbers\n        var result = [Int]()\n        result.append(copy.removeFirst())\n\
    \        for number in copy {\n            result.append(delimeter)\n        \
    \    result.append(number)\n        }\n        return result\n    }\n}\n\n\nfunc\
    \ ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count !=\
    \ right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(intersperse(numbers: [] as [Int], delimeter: 7)\
    \ == [] as [Int])\nassert(intersperse(numbers: [5, 6, 3, 2], delimeter: 8) ==\
    \ [5, 8, 6, 8, 3, 8, 2])\nassert(intersperse(numbers: [2, 2, 2], delimeter: 2)\
    \ == [2, 2, 2, 2, 2])"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659978932
- exit_code: 0
  program: "\n/// Insert a number 'delimeter' between every two consecutive elements\
    \ of input array `numbers'\n/// >>> intersperse(numbers: [] as [Int], delimeter:\
    \ 4)\n/// [] as [Int]\n/// >>> intersperse(numbers: [1, 2, 3], delimeter: 4)\n\
    /// [1, 4, 2, 4, 3]\nfunc intersperse(numbers: [Int], delimeter: Int) -> [Int]\
    \ {\n    var result: [Int] = []\n    for i in numbers.indices {\n        result.append(numbers[i])\n\
    \        if i != numbers.endIndex - 1 {\n            result.append(delimeter)\n\
    \        }\n    }\n    return result\n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(intersperse(numbers: [] as [Int], delimeter: 7) == [] as [Int])\nassert(intersperse(numbers:\
    \ [5, 6, 3, 2], delimeter: 8) == [5, 8, 6, 8, 3, 8, 2])\nassert(intersperse(numbers:\
    \ [2, 2, 2], delimeter: 2) == [2, 2, 2, 2, 2])"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659978932
- exit_code: 0
  program: "\n/// Insert a number 'delimeter' between every two consecutive elements\
    \ of input array `numbers'\n/// >>> intersperse(numbers: [] as [Int], delimeter:\
    \ 4)\n/// [] as [Int]\n/// >>> intersperse(numbers: [1, 2, 3], delimeter: 4)\n\
    /// [1, 4, 2, 4, 3]\nfunc intersperse(numbers: [Int], delimeter: Int) -> [Int]\
    \ {\n    var result: [Int] = []\n    let n = numbers.count\n    if n == 0 {\n\
    \        return []\n    }\n    result.append(numbers[0])\n    for i in 1..<n {\n\
    \        result.append(delimeter)\n        result.append(numbers[i])\n    }\n\
    \    return result\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) ->\
    \ Bool {\n    if left.count != right.count {\n        return false\n    }\n  \
    \  for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(intersperse(numbers:\
    \ [] as [Int], delimeter: 7) == [] as [Int])\nassert(intersperse(numbers: [5,\
    \ 6, 3, 2], delimeter: 8) == [5, 8, 6, 8, 3, 8, 2])\nassert(intersperse(numbers:\
    \ [2, 2, 2], delimeter: 2) == [2, 2, 2, 2, 2])"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659978932
- exit_code: -4
  program: "\n/// Insert a number 'delimeter' between every two consecutive elements\
    \ of input array `numbers'\n/// >>> intersperse(numbers: [] as [Int], delimeter:\
    \ 4)\n/// [] as [Int]\n/// >>> intersperse(numbers: [1, 2, 3], delimeter: 4)\n\
    /// [1, 4, 2, 4, 3]\nfunc intersperse(numbers: [Int], delimeter: Int) -> [Int]\
    \ {\n    if numbers.isEmpty {\n        return []\n    }\n    return numbers.reduce([numbers[0]])\
    \ { sum, num in\n        return sum + [delimeter] + [num]\n    }\n}\n\n\nfunc\
    \ ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count !=\
    \ right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(intersperse(numbers: [] as [Int], delimeter: 7)\
    \ == [] as [Int])\nassert(intersperse(numbers: [5, 6, 3, 2], delimeter: 8) ==\
    \ [5, 8, 6, 8, 3, 8, 2])\nassert(intersperse(numbers: [2, 2, 2], delimeter: 2)\
    \ == [2, 2, 2, 2, 2])"
  status: Exception
  stderr: 'tmp6bkc7gsx/tmp6bkc7gsx.swift:30: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002acf72cb5c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002acf729acb6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002acf729ac988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002acf729ab7b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmp6bkc7gsx                        0x0000555f493df68f <unavailable> + 5775

    5    libc.so.6                          0x00002acf72ea1460 __libc_start_main +
    245

    6    tmp6bkc7gsx                        0x0000555f493df189 <unavailable> + 4489

    '
  stdout: ''
  timestamp: 1659978932
- exit_code: 0
  program: "\n/// Insert a number 'delimeter' between every two consecutive elements\
    \ of input array `numbers'\n/// >>> intersperse(numbers: [] as [Int], delimeter:\
    \ 4)\n/// [] as [Int]\n/// >>> intersperse(numbers: [1, 2, 3], delimeter: 4)\n\
    /// [1, 4, 2, 4, 3]\nfunc intersperse(numbers: [Int], delimeter: Int) -> [Int]\
    \ {\n    //    var res: [Int] = []\n    //    for n in numbers {\n    //     \
    \   res.append(n)\n    //        res.append(delimeter)\n    //    }\n    //  \
    \  return res.dropLast()\n    //\n    //    return numbers.flatMap{[$0, delimeter]}.dropLast()\n\
    \    \n    var res: [Int] = []\n    for (i, n) in numbers.enumerated() {\n   \
    \     res.append(n)\n        if i < numbers.count - 1 {\n            res.append(delimeter)\n\
    \        }\n    }\n    return res\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int,\
    \ Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n\
    \    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n          \
    \  return false\n        }\n    }\n    return true\n}\n            \nassert(intersperse(numbers:\
    \ [] as [Int], delimeter: 7) == [] as [Int])\nassert(intersperse(numbers: [5,\
    \ 6, 3, 2], delimeter: 8) == [5, 8, 6, 8, 3, 8, 2])\nassert(intersperse(numbers:\
    \ [2, 2, 2], delimeter: 2) == [2, 2, 2, 2, 2])"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659978932
- exit_code: 0
  program: "\n/// Insert a number 'delimeter' between every two consecutive elements\
    \ of input array `numbers'\n/// >>> intersperse(numbers: [] as [Int], delimeter:\
    \ 4)\n/// [] as [Int]\n/// >>> intersperse(numbers: [1, 2, 3], delimeter: 4)\n\
    /// [1, 4, 2, 4, 3]\nfunc intersperse(numbers: [Int], delimeter: Int) -> [Int]\
    \ {\n  let count = numbers.count\n  guard count > 1 else { return numbers }\n\
    \  var output = [Int]()\n  for index in 0..<count-1 {\n    output.append(numbers[index])\n\
    \    output.append(delimeter)\n  }\n  output.append(numbers[count-1])\n  return\
    \ output\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n\
    \    if left.count != right.count {\n        return false\n    }\n    for (l,\
    \ r) in zip(left, right) {\n        if l != r {\n            return false\n  \
    \      }\n    }\n    return true\n}\n            \nassert(intersperse(numbers:\
    \ [] as [Int], delimeter: 7) == [] as [Int])\nassert(intersperse(numbers: [5,\
    \ 6, 3, 2], delimeter: 8) == [5, 8, 6, 8, 3, 8, 2])\nassert(intersperse(numbers:\
    \ [2, 2, 2], delimeter: 2) == [2, 2, 2, 2, 2])"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659978932
- exit_code: -4
  program: "\n/// Insert a number 'delimeter' between every two consecutive elements\
    \ of input array `numbers'\n/// >>> intersperse(numbers: [] as [Int], delimeter:\
    \ 4)\n/// [] as [Int]\n/// >>> intersperse(numbers: [1, 2, 3], delimeter: 4)\n\
    /// [1, 4, 2, 4, 3]\nfunc intersperse(numbers: [Int], delimeter: Int) -> [Int]\
    \ {\n    var numbers = numbers\n    var output: [Int] = []\n    for number in\
    \ numbers {\n        output.append(number)\n        output.append(delimeter)\n\
    \    }\n    output.removeLast()\n    return output\n}\n\n\nfunc ==(left: [(Int,\
    \ Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n\
    \        return false\n    }\n    for (l, r) in zip(left, right) {\n        if\
    \ l != r {\n            return false\n        }\n    }\n    return true\n}\n \
    \           \nassert(intersperse(numbers: [] as [Int], delimeter: 7) == [] as\
    \ [Int])\nassert(intersperse(numbers: [5, 6, 3, 2], delimeter: 8) == [5, 8, 6,\
    \ 8, 3, 8, 2])\nassert(intersperse(numbers: [2, 2, 2], delimeter: 2) == [2, 2,\
    \ 2, 2, 2])"
  status: Exception
  stderr: 'Swift/RangeReplaceableCollection.swift:870: Fatal error: Can''t remove
    last element from an empty collection

    Current stack trace:

    0    libswiftCore.so                    0x00002b636c3c0c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b636c0b7561 <unavailable> + 1434977

    2    libswiftCore.so                    0x00002b636c0b7286 <unavailable> + 1434246

    3    libswiftCore.so                    0x00002b636c0b713c <unavailable> + 1433916

    4    libswiftCore.so                    0x00002b636c0b6bb0 _assertionFailure(_:_:file:line:flags:)
    + 251

    5    libswiftCore.so                    0x00002b636c1b8c1d <unavailable> + 2489373

    6    tmp2fylrtk1                        0x000055d234330a9e <unavailable> + 6814

    7    tmp2fylrtk1                        0x000055d234330572 <unavailable> + 5490

    8    libc.so.6                          0x00002b636c5ac460 __libc_start_main +
    245

    9    tmp2fylrtk1                        0x000055d234330279 <unavailable> + 4729

    '
  stdout: ''
  timestamp: 1659978932
- exit_code: 0
  program: "\n/// Insert a number 'delimeter' between every two consecutive elements\
    \ of input array `numbers'\n/// >>> intersperse(numbers: [] as [Int], delimeter:\
    \ 4)\n/// [] as [Int]\n/// >>> intersperse(numbers: [1, 2, 3], delimeter: 4)\n\
    /// [1, 4, 2, 4, 3]\nfunc intersperse(numbers: [Int], delimeter: Int) -> [Int]\
    \ {\n    guard numbers.count > 1 else { return numbers }\n    var buffer = [Int]()\n\
    \    for (i, elem) in numbers.enumerated() {\n        buffer.append(elem)\n  \
    \      if i < numbers.count - 1 {\n            buffer.append(delimeter)\n    \
    \    }\n    }\n    return buffer\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int,\
    \ Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n\
    \    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n          \
    \  return false\n        }\n    }\n    return true\n}\n            \nassert(intersperse(numbers:\
    \ [] as [Int], delimeter: 7) == [] as [Int])\nassert(intersperse(numbers: [5,\
    \ 6, 3, 2], delimeter: 8) == [5, 8, 6, 8, 3, 8, 2])\nassert(intersperse(numbers:\
    \ [2, 2, 2], delimeter: 2) == [2, 2, 2, 2, 2])"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659978932
- exit_code: 0
  program: "\n/// Insert a number 'delimeter' between every two consecutive elements\
    \ of input array `numbers'\n/// >>> intersperse(numbers: [] as [Int], delimeter:\
    \ 4)\n/// [] as [Int]\n/// >>> intersperse(numbers: [1, 2, 3], delimeter: 4)\n\
    /// [1, 4, 2, 4, 3]\nfunc intersperse(numbers: [Int], delimeter: Int) -> [Int]\
    \ {\n    var res = [Int]()\n    guard !numbers.isEmpty else { return res }\n \
    \   res.append(numbers[0])\n    for i in 1..<numbers.count {\n        res.append(delimeter)\n\
    \        res.append(numbers[i])\n    }\n    return res\n}\n\n\nfunc ==(left: [(Int,\
    \ Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n\
    \        return false\n    }\n    for (l, r) in zip(left, right) {\n        if\
    \ l != r {\n            return false\n        }\n    }\n    return true\n}\n \
    \           \nassert(intersperse(numbers: [] as [Int], delimeter: 7) == [] as\
    \ [Int])\nassert(intersperse(numbers: [5, 6, 3, 2], delimeter: 8) == [5, 8, 6,\
    \ 8, 3, 8, 2])\nassert(intersperse(numbers: [2, 2, 2], delimeter: 2) == [2, 2,\
    \ 2, 2, 2])"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659978932
- exit_code: 0
  program: "\n/// Insert a number 'delimeter' between every two consecutive elements\
    \ of input array `numbers'\n/// >>> intersperse(numbers: [] as [Int], delimeter:\
    \ 4)\n/// [] as [Int]\n/// >>> intersperse(numbers: [1, 2, 3], delimeter: 4)\n\
    /// [1, 4, 2, 4, 3]\nfunc intersperse(numbers: [Int], delimeter: Int) -> [Int]\
    \ {\n    var result: [Int] = []\n    for (i, n) in numbers.enumerated() {\n  \
    \      result.append(n)\n        if i < numbers.count - 1 {\n            result.append(delimeter)\n\
    \        }\n    }\n    return result\n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(intersperse(numbers: [] as [Int], delimeter: 7) == [] as [Int])\nassert(intersperse(numbers:\
    \ [5, 6, 3, 2], delimeter: 8) == [5, 8, 6, 8, 3, 8, 2])\nassert(intersperse(numbers:\
    \ [2, 2, 2], delimeter: 2) == [2, 2, 2, 2, 2])"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659978932
- exit_code: 0
  program: "\n/// Insert a number 'delimeter' between every two consecutive elements\
    \ of input array `numbers'\n/// >>> intersperse(numbers: [] as [Int], delimeter:\
    \ 4)\n/// [] as [Int]\n/// >>> intersperse(numbers: [1, 2, 3], delimeter: 4)\n\
    /// [1, 4, 2, 4, 3]\nfunc intersperse(numbers: [Int], delimeter: Int) -> [Int]\
    \ {\n  var result: [Int] = []\n  for (i, n) in numbers.enumerated() {\n    result.append(n)\n\
    \    if i < numbers.count - 1 {\n      result.append(delimeter)\n    }\n  }\n\
    \  return result\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool\
    \ {\n    if left.count != right.count {\n        return false\n    }\n    for\
    \ (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(intersperse(numbers:\
    \ [] as [Int], delimeter: 7) == [] as [Int])\nassert(intersperse(numbers: [5,\
    \ 6, 3, 2], delimeter: 8) == [5, 8, 6, 8, 3, 8, 2])\nassert(intersperse(numbers:\
    \ [2, 2, 2], delimeter: 2) == [2, 2, 2, 2, 2])"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659978932
- exit_code: 0
  program: "\n/// Insert a number 'delimeter' between every two consecutive elements\
    \ of input array `numbers'\n/// >>> intersperse(numbers: [] as [Int], delimeter:\
    \ 4)\n/// [] as [Int]\n/// >>> intersperse(numbers: [1, 2, 3], delimeter: 4)\n\
    /// [1, 4, 2, 4, 3]\nfunc intersperse(numbers: [Int], delimeter: Int) -> [Int]\
    \ {\n    guard numbers.count > 1 else { return numbers }\n    var result = [Int]()\n\
    \    for number in numbers {\n        result.append(number)\n        result.append(delimeter)\n\
    \    }\n    result.removeLast()\n    return result\n}\n\n\nfunc ==(left: [(Int,\
    \ Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n\
    \        return false\n    }\n    for (l, r) in zip(left, right) {\n        if\
    \ l != r {\n            return false\n        }\n    }\n    return true\n}\n \
    \           \nassert(intersperse(numbers: [] as [Int], delimeter: 7) == [] as\
    \ [Int])\nassert(intersperse(numbers: [5, 6, 3, 2], delimeter: 8) == [5, 8, 6,\
    \ 8, 3, 8, 2])\nassert(intersperse(numbers: [2, 2, 2], delimeter: 2) == [2, 2,\
    \ 2, 2, 2])"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659978932
- exit_code: 0
  program: "\n/// Insert a number 'delimeter' between every two consecutive elements\
    \ of input array `numbers'\n/// >>> intersperse(numbers: [] as [Int], delimeter:\
    \ 4)\n/// [] as [Int]\n/// >>> intersperse(numbers: [1, 2, 3], delimeter: 4)\n\
    /// [1, 4, 2, 4, 3]\nfunc intersperse(numbers: [Int], delimeter: Int) -> [Int]\
    \ {\n    guard !numbers.isEmpty else { return [] }\n    guard numbers.count >\
    \ 1 else { return numbers }\n    let input = Array(numbers.dropFirst())\n    let\
    \ first = numbers.first!\n    let result = input.reduce([first]) {\n        let\
    \ number = $1\n        return $0 + [delimeter, number]\n    }\n    return result\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(intersperse(numbers: [] as [Int], delimeter: 7)\
    \ == [] as [Int])\nassert(intersperse(numbers: [5, 6, 3, 2], delimeter: 8) ==\
    \ [5, 8, 6, 8, 3, 8, 2])\nassert(intersperse(numbers: [2, 2, 2], delimeter: 2)\
    \ == [2, 2, 2, 2, 2])"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659978932
- exit_code: 0
  program: "\n/// Insert a number 'delimeter' between every two consecutive elements\
    \ of input array `numbers'\n/// >>> intersperse(numbers: [] as [Int], delimeter:\
    \ 4)\n/// [] as [Int]\n/// >>> intersperse(numbers: [1, 2, 3], delimeter: 4)\n\
    /// [1, 4, 2, 4, 3]\nfunc intersperse(numbers: [Int], delimeter: Int) -> [Int]\
    \ {\n    var interspersedNumbers = [Int]()\n    for i in 0 ..< numbers.count {\n\
    \        interspersedNumbers.append(numbers[i])\n        if i != numbers.count\
    \ - 1 {\n            interspersedNumbers.append(delimeter)\n        }\n    }\n\
    \    return interspersedNumbers\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int,\
    \ Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n\
    \    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n          \
    \  return false\n        }\n    }\n    return true\n}\n            \nassert(intersperse(numbers:\
    \ [] as [Int], delimeter: 7) == [] as [Int])\nassert(intersperse(numbers: [5,\
    \ 6, 3, 2], delimeter: 8) == [5, 8, 6, 8, 3, 8, 2])\nassert(intersperse(numbers:\
    \ [2, 2, 2], delimeter: 2) == [2, 2, 2, 2, 2])"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659978932
- exit_code: -4
  program: "\n/// Insert a number 'delimeter' between every two consecutive elements\
    \ of input array `numbers'\n/// >>> intersperse(numbers: [] as [Int], delimeter:\
    \ 4)\n/// [] as [Int]\n/// >>> intersperse(numbers: [1, 2, 3], delimeter: 4)\n\
    /// [1, 4, 2, 4, 3]\nfunc intersperse(numbers: [Int], delimeter: Int) -> [Int]\
    \ {\n    return []\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) ->\
    \ Bool {\n    if left.count != right.count {\n        return false\n    }\n  \
    \  for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(intersperse(numbers:\
    \ [] as [Int], delimeter: 7) == [] as [Int])\nassert(intersperse(numbers: [5,\
    \ 6, 3, 2], delimeter: 8) == [5, 8, 6, 8, 3, 8, 2])\nassert(intersperse(numbers:\
    \ [2, 2, 2], delimeter: 2) == [2, 2, 2, 2, 2])"
  status: Exception
  stderr: 'tmp0sr70v0j/tmp0sr70v0j.swift:25: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b5f1c432c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b5f1c129b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b5f1c129988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b5f1c1287b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmp0sr70v0j                        0x000055f4032774cf <unavailable> + 5327

    5    libc.so.6                          0x00002b5f1c61e460 __libc_start_main +
    245

    6    tmp0sr70v0j                        0x000055f403276fc9 <unavailable> + 4041

    '
  stdout: ''
  timestamp: 1659978932
- exit_code: 0
  program: "\n/// Insert a number 'delimeter' between every two consecutive elements\
    \ of input array `numbers'\n/// >>> intersperse(numbers: [] as [Int], delimeter:\
    \ 4)\n/// [] as [Int]\n/// >>> intersperse(numbers: [1, 2, 3], delimeter: 4)\n\
    /// [1, 4, 2, 4, 3]\nfunc intersperse(numbers: [Int], delimeter: Int) -> [Int]\
    \ {\n    guard !numbers.isEmpty else { return [] }\n    guard numbers.count >\
    \ 1 else { return numbers }\n    var result = [Int]()\n    for i in 0 ..< numbers.count\
    \ {\n        if i == numbers.count - 1 {\n            result.append(numbers[i])\n\
    \        } else {\n            result.append(numbers[i])\n            result.append(delimeter)\n\
    \        }\n    }\n    return result\n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(intersperse(numbers: [] as [Int], delimeter: 7) == [] as [Int])\nassert(intersperse(numbers:\
    \ [5, 6, 3, 2], delimeter: 8) == [5, 8, 6, 8, 3, 8, 2])\nassert(intersperse(numbers:\
    \ [2, 2, 2], delimeter: 2) == [2, 2, 2, 2, 2])"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659978932
- exit_code: -4
  program: "\n/// Insert a number 'delimeter' between every two consecutive elements\
    \ of input array `numbers'\n/// >>> intersperse(numbers: [] as [Int], delimeter:\
    \ 4)\n/// [] as [Int]\n/// >>> intersperse(numbers: [1, 2, 3], delimeter: 4)\n\
    /// [1, 4, 2, 4, 3]\nfunc intersperse(numbers: [Int], delimeter: Int) -> [Int]\
    \ {\n    var result: [Int] = []\n    for i in 0..<numbers.count - 1 {\n      \
    \  result.append(numbers[i])\n        result.append(delimeter)\n    }\n    result.append(numbers[numbers.count\
    \ - 1])\n    return result\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(intersperse(numbers:\
    \ [] as [Int], delimeter: 7) == [] as [Int])\nassert(intersperse(numbers: [5,\
    \ 6, 3, 2], delimeter: 8) == [5, 8, 6, 8, 3, 8, 2])\nassert(intersperse(numbers:\
    \ [2, 2, 2], delimeter: 2) == [2, 2, 2, 2, 2])"
  status: Exception
  stderr: 'Swift/Range.swift:743: Fatal error: Range requires lowerBound <= upperBound

    Current stack trace:

    0    libswiftCore.so                    0x00002ac9d4ad7c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002ac9d47ce561 <unavailable> + 1434977

    2    libswiftCore.so                    0x00002ac9d47ce286 <unavailable> + 1434246

    3    libswiftCore.so                    0x00002ac9d47ce13c <unavailable> + 1433916

    4    libswiftCore.so                    0x00002ac9d47cdbb0 _assertionFailure(_:_:file:line:flags:)
    + 251

    5    tmpf8oz2_9b                        0x000055aaca376a16 <unavailable> + 6678

    6    tmpf8oz2_9b                        0x000055aaca376552 <unavailable> + 5458

    7    libc.so.6                          0x00002ac9d4cc3460 __libc_start_main +
    245

    8    tmpf8oz2_9b                        0x000055aaca376259 <unavailable> + 4697

    '
  stdout: ''
  timestamp: 1659978932
- exit_code: 1
  program: "\n/// Insert a number 'delimeter' between every two consecutive elements\
    \ of input array `numbers'\n/// >>> intersperse(numbers: [] as [Int], delimeter:\
    \ 4)\n/// [] as [Int]\n/// >>> intersperse(numbers: [1, 2, 3], delimeter: 4)\n\
    /// [1, 4, 2, 4, 3]\nfunc intersperse(numbers: [Int], delimeter: Int) -> [Int]\
    \ {\n    //>>>>>>>>>>>>>>>>>> your code starts here <<<<<<<<<<<<<<<<<<<<<\n  \
    \  if numbers.count <= 1 {\n        return numbers\n    } else {\n        return\
    \ intersperse(numbers: numbers[0...(numbers.count-2)], delimeter: delimeter) +\
    \ [delimeter] + [numbers[numbers.count-1]]\n    }\n    //>>>>>>>>>>>>>>>>>> your\
    \ code ends here <<<<<<<<<<<<<<<<<<<<<\n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(intersperse(numbers: [] as [Int], delimeter: 7) == [] as [Int])\nassert(intersperse(numbers:\
    \ [5, 6, 3, 2], delimeter: 8) == [5, 8, 6, 8, 3, 8, 2])\nassert(intersperse(numbers:\
    \ [2, 2, 2], delimeter: 2) == [2, 2, 2, 2, 2])"
  status: SyntaxError
  stderr: "/tmp/tmpvrvgu3s1.swift:12:44: error: cannot convert value of type 'ArraySlice<Int>'\
    \ to expected argument type '[Int]'\n        return intersperse(numbers: numbers[0...(numbers.count-2)],\
    \ delimeter: delimeter) + [delimeter] + [numbers[numbers.count-1]]\n         \
    \                                  ^\n"
  stdout: ''
  timestamp: 1659978932
- exit_code: 0
  program: "\n/// Insert a number 'delimeter' between every two consecutive elements\
    \ of input array `numbers'\n/// >>> intersperse(numbers: [] as [Int], delimeter:\
    \ 4)\n/// [] as [Int]\n/// >>> intersperse(numbers: [1, 2, 3], delimeter: 4)\n\
    /// [1, 4, 2, 4, 3]\nfunc intersperse(numbers: [Int], delimeter: Int) -> [Int]\
    \ {\n    var result: [Int] = []\n    for (index, number) in numbers.enumerated()\
    \ {\n        result.append(number)\n        if index != numbers.count - 1 {\n\
    \            result.append(delimeter)\n        }\n    }\n    return result\n}\n\
    \n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(intersperse(numbers: [] as [Int], delimeter: 7)\
    \ == [] as [Int])\nassert(intersperse(numbers: [5, 6, 3, 2], delimeter: 8) ==\
    \ [5, 8, 6, 8, 3, 8, 2])\nassert(intersperse(numbers: [2, 2, 2], delimeter: 2)\
    \ == [2, 2, 2, 2, 2])"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659978932
- exit_code: 0
  program: "\n/// Insert a number 'delimeter' between every two consecutive elements\
    \ of input array `numbers'\n/// >>> intersperse(numbers: [] as [Int], delimeter:\
    \ 4)\n/// [] as [Int]\n/// >>> intersperse(numbers: [1, 2, 3], delimeter: 4)\n\
    /// [1, 4, 2, 4, 3]\nfunc intersperse(numbers: [Int], delimeter: Int) -> [Int]\
    \ {\n    var interspersed: [Int] = []\n    for (index, number) in numbers.enumerated()\
    \ {\n        interspersed.append(number)\n        if index != numbers.count -\
    \ 1 {\n            interspersed.append(delimeter)\n        }\n    }\n    return\
    \ interspersed\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool\
    \ {\n    if left.count != right.count {\n        return false\n    }\n    for\
    \ (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(intersperse(numbers:\
    \ [] as [Int], delimeter: 7) == [] as [Int])\nassert(intersperse(numbers: [5,\
    \ 6, 3, 2], delimeter: 8) == [5, 8, 6, 8, 3, 8, 2])\nassert(intersperse(numbers:\
    \ [2, 2, 2], delimeter: 2) == [2, 2, 2, 2, 2])"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659978932
- exit_code: -4
  program: "\n/// Insert a number 'delimeter' between every two consecutive elements\
    \ of input array `numbers'\n/// >>> intersperse(numbers: [] as [Int], delimeter:\
    \ 4)\n/// [] as [Int]\n/// >>> intersperse(numbers: [1, 2, 3], delimeter: 4)\n\
    /// [1, 4, 2, 4, 3]\nfunc intersperse(numbers: [Int], delimeter: Int) -> [Int]\
    \ {\n    if numbers.isEmpty {\n        return []\n    } else {\n        let temp\
    \ = intersperse(numbers: Array(numbers.dropFirst()), delimeter: delimeter)\n \
    \       return [numbers[0]] + [delimeter] + temp\n    }\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(intersperse(numbers: [] as [Int], delimeter: 7) == []\
    \ as [Int])\nassert(intersperse(numbers: [5, 6, 3, 2], delimeter: 8) == [5, 8,\
    \ 6, 8, 3, 8, 2])\nassert(intersperse(numbers: [2, 2, 2], delimeter: 2) == [2,\
    \ 2, 2, 2, 2])"
  status: Exception
  stderr: 'tmpmjn85leh/tmpmjn85leh.swift:30: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002ab35c284c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002ab35bf7bb6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002ab35bf7b988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002ab35bf7a7b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpmjn85leh                        0x0000560d62b2d77f <unavailable> + 6015

    5    libc.so.6                          0x00002ab35c470460 __libc_start_main +
    245

    6    tmpmjn85leh                        0x0000560d62b2d279 <unavailable> + 4729

    '
  stdout: ''
  timestamp: 1659978932
- exit_code: 0
  program: "\n/// Insert a number 'delimeter' between every two consecutive elements\
    \ of input array `numbers'\n/// >>> intersperse(numbers: [] as [Int], delimeter:\
    \ 4)\n/// [] as [Int]\n/// >>> intersperse(numbers: [1, 2, 3], delimeter: 4)\n\
    /// [1, 4, 2, 4, 3]\nfunc intersperse(numbers: [Int], delimeter: Int) -> [Int]\
    \ {\n    var result: [Int] = []\n    for i in 0..<numbers.count {\n        result.append(numbers[i])\n\
    \        if i != numbers.count - 1 {\n            result.append(delimeter)\n \
    \       }\n    }\n    return result\n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(intersperse(numbers: [] as [Int], delimeter: 7) == [] as [Int])\nassert(intersperse(numbers:\
    \ [5, 6, 3, 2], delimeter: 8) == [5, 8, 6, 8, 3, 8, 2])\nassert(intersperse(numbers:\
    \ [2, 2, 2], delimeter: 2) == [2, 2, 2, 2, 2])"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659978931
- exit_code: 1
  program: "\n/// Insert a number 'delimeter' between every two consecutive elements\
    \ of input array `numbers'\n/// >>> intersperse(numbers: [] as [Int], delimeter:\
    \ 4)\n/// [] as [Int]\n/// >>> intersperse(numbers: [1, 2, 3], delimeter: 4)\n\
    /// [1, 4, 2, 4, 3]\nfunc intersperse(numbers: [Int], delimeter: Int) -> [Int]\
    \ {\n    let d = [delimeter]\n    let tmp = numbers.map { [$0] }\n    let ans\
    \ = tmp.flatMap { zip($0, d) }.map { $0 }\n    return ans\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(intersperse(numbers: [] as [Int], delimeter: 7) == []\
    \ as [Int])\nassert(intersperse(numbers: [5, 6, 3, 2], delimeter: 8) == [5, 8,\
    \ 6, 8, 3, 8, 2])\nassert(intersperse(numbers: [2, 2, 2], delimeter: 2) == [2,\
    \ 2, 2, 2, 2])"
  status: SyntaxError
  stderr: "/tmp/tmptng8m4rx.swift:11:12: error: cannot convert return expression of\
    \ type '[(Int, Int)]' to return type '[Int]'\n    return ans\n           ^\n/tmp/tmptng8m4rx.swift:11:12:\
    \ note: arguments to generic parameter 'Element' ('(Int, Int)' and 'Int') are\
    \ expected to be equal\n    return ans\n           ^\n"
  stdout: ''
  timestamp: 1659978932
- exit_code: 0
  program: "\n/// Insert a number 'delimeter' between every two consecutive elements\
    \ of input array `numbers'\n/// >>> intersperse(numbers: [] as [Int], delimeter:\
    \ 4)\n/// [] as [Int]\n/// >>> intersperse(numbers: [1, 2, 3], delimeter: 4)\n\
    /// [1, 4, 2, 4, 3]\nfunc intersperse(numbers: [Int], delimeter: Int) -> [Int]\
    \ {\n    var result: [Int] = []\n    if numbers.count <= 1 {\n        return numbers\n\
    \    }\n    for i in 0..<numbers.count - 1 {\n        result.append(numbers[i])\n\
    \        result.append(delimeter)\n    }\n    result.append(numbers[numbers.count\
    \ - 1])\n    return result\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(intersperse(numbers:\
    \ [] as [Int], delimeter: 7) == [] as [Int])\nassert(intersperse(numbers: [5,\
    \ 6, 3, 2], delimeter: 8) == [5, 8, 6, 8, 3, 8, 2])\nassert(intersperse(numbers:\
    \ [2, 2, 2], delimeter: 2) == [2, 2, 2, 2, 2])"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659978932
- exit_code: 0
  program: "\n/// Insert a number 'delimeter' between every two consecutive elements\
    \ of input array `numbers'\n/// >>> intersperse(numbers: [] as [Int], delimeter:\
    \ 4)\n/// [] as [Int]\n/// >>> intersperse(numbers: [1, 2, 3], delimeter: 4)\n\
    /// [1, 4, 2, 4, 3]\nfunc intersperse(numbers: [Int], delimeter: Int) -> [Int]\
    \ {\n    // YOUR CODE GOES HERE\n    var output = [Int]()\n    var index = 0\n\
    \    while index < numbers.count {\n        output.append(numbers[index])\n  \
    \      if index < numbers.count - 1 {\n            output.append(delimeter)\n\
    \        }\n        index += 1\n    }\n    return output\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(intersperse(numbers: [] as [Int], delimeter: 7) == []\
    \ as [Int])\nassert(intersperse(numbers: [5, 6, 3, 2], delimeter: 8) == [5, 8,\
    \ 6, 8, 3, 8, 2])\nassert(intersperse(numbers: [2, 2, 2], delimeter: 2) == [2,\
    \ 2, 2, 2, 2])"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659978932
- exit_code: 0
  program: "\n/// Insert a number 'delimeter' between every two consecutive elements\
    \ of input array `numbers'\n/// >>> intersperse(numbers: [] as [Int], delimeter:\
    \ 4)\n/// [] as [Int]\n/// >>> intersperse(numbers: [1, 2, 3], delimeter: 4)\n\
    /// [1, 4, 2, 4, 3]\nfunc intersperse(numbers: [Int], delimeter: Int) -> [Int]\
    \ {\n\tguard numbers.count > 1 else { return numbers }\n\t\n\tvar interspersed:\
    \ [Int] = [numbers[0]]\n\tfor number in numbers[1...] {\n\t\tinterspersed.append(delimeter)\n\
    \t\tinterspersed.append(number)\n\t}\n\treturn interspersed\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(intersperse(numbers: [] as [Int], delimeter: 7) == []\
    \ as [Int])\nassert(intersperse(numbers: [5, 6, 3, 2], delimeter: 8) == [5, 8,\
    \ 6, 8, 3, 8, 2])\nassert(intersperse(numbers: [2, 2, 2], delimeter: 2) == [2,\
    \ 2, 2, 2, 2])"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659978932
- exit_code: 0
  program: "\n/// Insert a number 'delimeter' between every two consecutive elements\
    \ of input array `numbers'\n/// >>> intersperse(numbers: [] as [Int], delimeter:\
    \ 4)\n/// [] as [Int]\n/// >>> intersperse(numbers: [1, 2, 3], delimeter: 4)\n\
    /// [1, 4, 2, 4, 3]\nfunc intersperse(numbers: [Int], delimeter: Int) -> [Int]\
    \ {\n  if numbers.isEmpty {\n    return []\n  }\n  if numbers.count == 1 {\n \
    \   return numbers\n  }\n  var result = [Int]()\n  for (i, n) in numbers.enumerated()\
    \ {\n    result.append(n)\n    if i != numbers.count - 1 {\n      result.append(delimeter)\n\
    \    }\n  }\n  return result\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int,\
    \ Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n\
    \    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n          \
    \  return false\n        }\n    }\n    return true\n}\n            \nassert(intersperse(numbers:\
    \ [] as [Int], delimeter: 7) == [] as [Int])\nassert(intersperse(numbers: [5,\
    \ 6, 3, 2], delimeter: 8) == [5, 8, 6, 8, 3, 8, 2])\nassert(intersperse(numbers:\
    \ [2, 2, 2], delimeter: 2) == [2, 2, 2, 2, 2])"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659978932
- exit_code: 0
  program: "\n/// Insert a number 'delimeter' between every two consecutive elements\
    \ of input array `numbers'\n/// >>> intersperse(numbers: [] as [Int], delimeter:\
    \ 4)\n/// [] as [Int]\n/// >>> intersperse(numbers: [1, 2, 3], delimeter: 4)\n\
    /// [1, 4, 2, 4, 3]\nfunc intersperse(numbers: [Int], delimeter: Int) -> [Int]\
    \ {\n    if numbers.isEmpty {\n        return []\n    }\n    var result = [Int]()\n\
    \    var iter = numbers.makeIterator()\n    if let first = iter.next() {\n   \
    \     result.append(first)\n    }\n    while let next = iter.next() {\n      \
    \  result.append(delimeter)\n        result.append(next)\n    }\n    return result\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(intersperse(numbers: [] as [Int], delimeter: 7)\
    \ == [] as [Int])\nassert(intersperse(numbers: [5, 6, 3, 2], delimeter: 8) ==\
    \ [5, 8, 6, 8, 3, 8, 2])\nassert(intersperse(numbers: [2, 2, 2], delimeter: 2)\
    \ == [2, 2, 2, 2, 2])"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659978932
- exit_code: 0
  program: "\n/// Insert a number 'delimeter' between every two consecutive elements\
    \ of input array `numbers'\n/// >>> intersperse(numbers: [] as [Int], delimeter:\
    \ 4)\n/// [] as [Int]\n/// >>> intersperse(numbers: [1, 2, 3], delimeter: 4)\n\
    /// [1, 4, 2, 4, 3]\nfunc intersperse(numbers: [Int], delimeter: Int) -> [Int]\
    \ {\n    var result: [Int] = []\n    for i in 0..<numbers.count {\n        result.append(numbers[i])\n\
    \        if i < numbers.count - 1 {\n            result.append(delimeter)\n  \
    \      }\n    }\n    return result\n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(intersperse(numbers: [] as [Int], delimeter: 7) == [] as [Int])\nassert(intersperse(numbers:\
    \ [5, 6, 3, 2], delimeter: 8) == [5, 8, 6, 8, 3, 8, 2])\nassert(intersperse(numbers:\
    \ [2, 2, 2], delimeter: 2) == [2, 2, 2, 2, 2])"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659978932
- exit_code: 0
  program: "\n/// Insert a number 'delimeter' between every two consecutive elements\
    \ of input array `numbers'\n/// >>> intersperse(numbers: [] as [Int], delimeter:\
    \ 4)\n/// [] as [Int]\n/// >>> intersperse(numbers: [1, 2, 3], delimeter: 4)\n\
    /// [1, 4, 2, 4, 3]\nfunc intersperse(numbers: [Int], delimeter: Int) -> [Int]\
    \ {\n    if numbers.isEmpty {\n        return []\n    }\n    if numbers.count\
    \ == 1 {\n        return numbers\n    }\n    var result = [Int]()\n    for (index,\
    \ element) in numbers.enumerated() {\n        result.append(element)\n       \
    \ if index != numbers.count - 1 {\n            result.append(delimeter)\n    \
    \    }\n    }\n    return result\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int,\
    \ Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n\
    \    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n          \
    \  return false\n        }\n    }\n    return true\n}\n            \nassert(intersperse(numbers:\
    \ [] as [Int], delimeter: 7) == [] as [Int])\nassert(intersperse(numbers: [5,\
    \ 6, 3, 2], delimeter: 8) == [5, 8, 6, 8, 3, 8, 2])\nassert(intersperse(numbers:\
    \ [2, 2, 2], delimeter: 2) == [2, 2, 2, 2, 2])"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659978932
- exit_code: -4
  program: "\n/// Insert a number 'delimeter' between every two consecutive elements\
    \ of input array `numbers'\n/// >>> intersperse(numbers: [] as [Int], delimeter:\
    \ 4)\n/// [] as [Int]\n/// >>> intersperse(numbers: [1, 2, 3], delimeter: 4)\n\
    /// [1, 4, 2, 4, 3]\nfunc intersperse(numbers: [Int], delimeter: Int) -> [Int]\
    \ {\n\tvar ret = [Int]()\n\t\n\t// Go through all elements in numbers, except\
    \ the last one\n\tfor i in 0..<numbers.count - 1 {\n\t\tret.append(numbers[i])\n\
    \t\tret.append(delimeter)\n\t}\n\t\n\t// Add the last element\n\tret.append(numbers[numbers.count\
    \ - 1])\n\t\n\treturn ret\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(intersperse(numbers:\
    \ [] as [Int], delimeter: 7) == [] as [Int])\nassert(intersperse(numbers: [5,\
    \ 6, 3, 2], delimeter: 8) == [5, 8, 6, 8, 3, 8, 2])\nassert(intersperse(numbers:\
    \ [2, 2, 2], delimeter: 2) == [2, 2, 2, 2, 2])"
  status: Exception
  stderr: 'Swift/Range.swift:743: Fatal error: Range requires lowerBound <= upperBound

    Current stack trace:

    0    libswiftCore.so                    0x00002ac2d7036c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002ac2d6d2d561 <unavailable> + 1434977

    2    libswiftCore.so                    0x00002ac2d6d2d286 <unavailable> + 1434246

    3    libswiftCore.so                    0x00002ac2d6d2d13c <unavailable> + 1433916

    4    libswiftCore.so                    0x00002ac2d6d2cbb0 _assertionFailure(_:_:file:line:flags:)
    + 251

    5    tmpnlwoybkx                        0x000055a994408a6b <unavailable> + 6763

    6    tmpnlwoybkx                        0x000055a9944085b2 <unavailable> + 5554

    7    libc.so.6                          0x00002ac2d7222460 __libc_start_main +
    245

    8    tmpnlwoybkx                        0x000055a9944082b9 <unavailable> + 4793

    '
  stdout: ''
  timestamp: 1659978932
- exit_code: 1
  program: "\n/// Insert a number 'delimeter' between every two consecutive elements\
    \ of input array `numbers'\n/// >>> intersperse(numbers: [] as [Int], delimeter:\
    \ 4)\n/// [] as [Int]\n/// >>> intersperse(numbers: [1, 2, 3], delimeter: 4)\n\
    /// [1, 4, 2, 4, 3]\nfunc intersperse(numbers: [Int], delimeter: Int) -> [Int]\
    \ {\n    return numbers.flatMap({[$0, delimeter]})[0..<numbers.count*2]\n}\n\n\
    \nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(intersperse(numbers: [] as [Int], delimeter: 7)\
    \ == [] as [Int])\nassert(intersperse(numbers: [5, 6, 3, 2], delimeter: 8) ==\
    \ [5, 8, 6, 8, 3, 8, 2])\nassert(intersperse(numbers: [2, 2, 2], delimeter: 2)\
    \ == [2, 2, 2, 2, 2])"
  status: SyntaxError
  stderr: "/tmp/tmplsc11ul0.swift:8:46: error: cannot convert return expression of\
    \ type 'ArraySlice<Int>' to return type '[Int]'\n    return numbers.flatMap({[$0,\
    \ delimeter]})[0..<numbers.count*2]\n           ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~^~~~~~~~~~~~~~~~~~~~~\n"
  stdout: ''
  timestamp: 1659978932
- exit_code: 0
  program: "\n/// Insert a number 'delimeter' between every two consecutive elements\
    \ of input array `numbers'\n/// >>> intersperse(numbers: [] as [Int], delimeter:\
    \ 4)\n/// [] as [Int]\n/// >>> intersperse(numbers: [1, 2, 3], delimeter: 4)\n\
    /// [1, 4, 2, 4, 3]\nfunc intersperse(numbers: [Int], delimeter: Int) -> [Int]\
    \ {\n    var result: [Int] = []\n    guard numbers.count > 1 else {\n        return\
    \ numbers\n    }\n    for index in numbers.indices {\n        result.append(numbers[index])\n\
    \        if index != numbers.count - 1 {\n            result.append(delimeter)\n\
    \        }\n    }\n    return result\n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(intersperse(numbers: [] as [Int], delimeter: 7) == [] as [Int])\nassert(intersperse(numbers:\
    \ [5, 6, 3, 2], delimeter: 8) == [5, 8, 6, 8, 3, 8, 2])\nassert(intersperse(numbers:\
    \ [2, 2, 2], delimeter: 2) == [2, 2, 2, 2, 2])"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659978932
- exit_code: -4
  program: "\n/// Insert a number 'delimeter' between every two consecutive elements\
    \ of input array `numbers'\n/// >>> intersperse(numbers: [] as [Int], delimeter:\
    \ 4)\n/// [] as [Int]\n/// >>> intersperse(numbers: [1, 2, 3], delimeter: 4)\n\
    /// [1, 4, 2, 4, 3]\nfunc intersperse(numbers: [Int], delimeter: Int) -> [Int]\
    \ {\n    if numbers.isEmpty {\n        return []\n    }\n    if numbers.count\
    \ == 1 {\n        return numbers\n    }\n    return (0..<numbers.count).map {\
    \ $0 % 2 == 0 ? numbers[$0] : delimeter }\n}\n\n\nfunc ==(left: [(Int, Int)],\
    \ right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n       \
    \ return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r\
    \ {\n            return false\n        }\n    }\n    return true\n}\n        \
    \    \nassert(intersperse(numbers: [] as [Int], delimeter: 7) == [] as [Int])\n\
    assert(intersperse(numbers: [5, 6, 3, 2], delimeter: 8) == [5, 8, 6, 8, 3, 8,\
    \ 2])\nassert(intersperse(numbers: [2, 2, 2], delimeter: 2) == [2, 2, 2, 2, 2])"
  status: Exception
  stderr: 'tmpe77062qw/tmpe77062qw.swift:31: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b75f9db9c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b75f9ab0b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b75f9ab0988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b75f9aaf7b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpe77062qw                        0x000055d8ed90e7df <unavailable> + 6111

    5    libc.so.6                          0x00002b75f9fa5460 __libc_start_main +
    245

    6    tmpe77062qw                        0x000055d8ed90e2d9 <unavailable> + 4825

    '
  stdout: ''
  timestamp: 1659978932
- exit_code: 0
  program: "\n/// Insert a number 'delimeter' between every two consecutive elements\
    \ of input array `numbers'\n/// >>> intersperse(numbers: [] as [Int], delimeter:\
    \ 4)\n/// [] as [Int]\n/// >>> intersperse(numbers: [1, 2, 3], delimeter: 4)\n\
    /// [1, 4, 2, 4, 3]\nfunc intersperse(numbers: [Int], delimeter: Int) -> [Int]\
    \ {\n    guard numbers.count >= 2 else { return numbers }\n    var result = [Int]()\n\
    \    result.append(numbers[0])\n    for i in 1..<numbers.count {\n        result.append(delimeter)\n\
    \        result.append(numbers[i])\n    }\n    return result\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(intersperse(numbers: [] as [Int], delimeter: 7) == []\
    \ as [Int])\nassert(intersperse(numbers: [5, 6, 3, 2], delimeter: 8) == [5, 8,\
    \ 6, 8, 3, 8, 2])\nassert(intersperse(numbers: [2, 2, 2], delimeter: 2) == [2,\
    \ 2, 2, 2, 2])"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659978932
- exit_code: -4
  program: "\n/// Insert a number 'delimeter' between every two consecutive elements\
    \ of input array `numbers'\n/// >>> intersperse(numbers: [] as [Int], delimeter:\
    \ 4)\n/// [] as [Int]\n/// >>> intersperse(numbers: [1, 2, 3], delimeter: 4)\n\
    /// [1, 4, 2, 4, 3]\nfunc intersperse(numbers: [Int], delimeter: Int) -> [Int]\
    \ {\n    if numbers.isEmpty {\n        return []\n    } else {\n        let first\
    \ = numbers[0]\n        let rest = intersperse(numbers: Array(numbers[1..<numbers.count]),\
    \ delimeter: delimeter)\n        var result = [first]\n        result.append(contentsOf:\
    \ rest.flatMap({ [delimeter, $0] }))\n        return result\n    }\n}\n\n\nfunc\
    \ ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count !=\
    \ right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(intersperse(numbers: [] as [Int], delimeter: 7)\
    \ == [] as [Int])\nassert(intersperse(numbers: [5, 6, 3, 2], delimeter: 8) ==\
    \ [5, 8, 6, 8, 3, 8, 2])\nassert(intersperse(numbers: [2, 2, 2], delimeter: 2)\
    \ == [2, 2, 2, 2, 2])"
  status: Exception
  stderr: 'tmpsy46z4e0/tmpsy46z4e0.swift:33: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b6212ef6c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b6212bedb6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b6212bed988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b6212bec7b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpsy46z4e0                        0x000055b699caa8ff <unavailable> + 6399

    5    libc.so.6                          0x00002b62130e2460 __libc_start_main +
    245

    6    tmpsy46z4e0                        0x000055b699caa3f9 <unavailable> + 5113

    '
  stdout: ''
  timestamp: 1659978932
- exit_code: 0
  program: "\n/// Insert a number 'delimeter' between every two consecutive elements\
    \ of input array `numbers'\n/// >>> intersperse(numbers: [] as [Int], delimeter:\
    \ 4)\n/// [] as [Int]\n/// >>> intersperse(numbers: [1, 2, 3], delimeter: 4)\n\
    /// [1, 4, 2, 4, 3]\nfunc intersperse(numbers: [Int], delimeter: Int) -> [Int]\
    \ {\n    if numbers.isEmpty {\n        return []\n    } else {\n        var result\
    \ = [Int]()\n        var idx = 0\n        while idx < numbers.count - 1 {\n  \
    \          result.append(numbers[idx])\n            result.append(delimeter)\n\
    \            idx += 1\n        }\n        result.append(numbers[idx])\n      \
    \  return result\n    }\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(intersperse(numbers:\
    \ [] as [Int], delimeter: 7) == [] as [Int])\nassert(intersperse(numbers: [5,\
    \ 6, 3, 2], delimeter: 8) == [5, 8, 6, 8, 3, 8, 2])\nassert(intersperse(numbers:\
    \ [2, 2, 2], delimeter: 2) == [2, 2, 2, 2, 2])"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659978932
- exit_code: 0
  program: "\n/// Insert a number 'delimeter' between every two consecutive elements\
    \ of input array `numbers'\n/// >>> intersperse(numbers: [] as [Int], delimeter:\
    \ 4)\n/// [] as [Int]\n/// >>> intersperse(numbers: [1, 2, 3], delimeter: 4)\n\
    /// [1, 4, 2, 4, 3]\nfunc intersperse(numbers: [Int], delimeter: Int) -> [Int]\
    \ {\n    if numbers.isEmpty {\n        return []\n    }\n    if numbers.count\
    \ == 1 {\n        return numbers\n    }\n    var result = numbers\n    for i in\
    \ 1..<numbers.count {\n        result.insert(delimeter, at: i * 2 - 1)\n    }\n\
    \    return result\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) ->\
    \ Bool {\n    if left.count != right.count {\n        return false\n    }\n  \
    \  for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(intersperse(numbers:\
    \ [] as [Int], delimeter: 7) == [] as [Int])\nassert(intersperse(numbers: [5,\
    \ 6, 3, 2], delimeter: 8) == [5, 8, 6, 8, 3, 8, 2])\nassert(intersperse(numbers:\
    \ [2, 2, 2], delimeter: 2) == [2, 2, 2, 2, 2])"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659978932
- exit_code: 0
  program: "\n/// Insert a number 'delimeter' between every two consecutive elements\
    \ of input array `numbers'\n/// >>> intersperse(numbers: [] as [Int], delimeter:\
    \ 4)\n/// [] as [Int]\n/// >>> intersperse(numbers: [1, 2, 3], delimeter: 4)\n\
    /// [1, 4, 2, 4, 3]\nfunc intersperse(numbers: [Int], delimeter: Int) -> [Int]\
    \ {\n    return numbers.reduce([]) { $0.isEmpty ? $0 + [$1] : $0 + [delimeter]\
    \ + [$1] }\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n\
    \    if left.count != right.count {\n        return false\n    }\n    for (l,\
    \ r) in zip(left, right) {\n        if l != r {\n            return false\n  \
    \      }\n    }\n    return true\n}\n            \nassert(intersperse(numbers:\
    \ [] as [Int], delimeter: 7) == [] as [Int])\nassert(intersperse(numbers: [5,\
    \ 6, 3, 2], delimeter: 8) == [5, 8, 6, 8, 3, 8, 2])\nassert(intersperse(numbers:\
    \ [2, 2, 2], delimeter: 2) == [2, 2, 2, 2, 2])"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659978933
- exit_code: 0
  program: "\n/// Insert a number 'delimeter' between every two consecutive elements\
    \ of input array `numbers'\n/// >>> intersperse(numbers: [] as [Int], delimeter:\
    \ 4)\n/// [] as [Int]\n/// >>> intersperse(numbers: [1, 2, 3], delimeter: 4)\n\
    /// [1, 4, 2, 4, 3]\nfunc intersperse(numbers: [Int], delimeter: Int) -> [Int]\
    \ {\n    var result: [Int] = []\n    let indexOfLastNumber = numbers.count - 1\n\
    \    for (index, number) in numbers.enumerated() {\n        result.append(number)\n\
    \        if index != indexOfLastNumber {\n            result.append(delimeter)\n\
    \        }\n    }\n    return result\n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(intersperse(numbers: [] as [Int], delimeter: 7) == [] as [Int])\nassert(intersperse(numbers:\
    \ [5, 6, 3, 2], delimeter: 8) == [5, 8, 6, 8, 3, 8, 2])\nassert(intersperse(numbers:\
    \ [2, 2, 2], delimeter: 2) == [2, 2, 2, 2, 2])"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659978932
- exit_code: -4
  program: "\n/// Insert a number 'delimeter' between every two consecutive elements\
    \ of input array `numbers'\n/// >>> intersperse(numbers: [] as [Int], delimeter:\
    \ 4)\n/// [] as [Int]\n/// >>> intersperse(numbers: [1, 2, 3], delimeter: 4)\n\
    /// [1, 4, 2, 4, 3]\nfunc intersperse(numbers: [Int], delimeter: Int) -> [Int]\
    \ {\n    // your code here\n    return []\n}\n\n\nfunc ==(left: [(Int, Int)],\
    \ right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n       \
    \ return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r\
    \ {\n            return false\n        }\n    }\n    return true\n}\n        \
    \    \nassert(intersperse(numbers: [] as [Int], delimeter: 7) == [] as [Int])\n\
    assert(intersperse(numbers: [5, 6, 3, 2], delimeter: 8) == [5, 8, 6, 8, 3, 8,\
    \ 2])\nassert(intersperse(numbers: [2, 2, 2], delimeter: 2) == [2, 2, 2, 2, 2])"
  status: Exception
  stderr: 'tmps_yoo5cr/tmps_yoo5cr.swift:26: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002ac6fd34cc80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002ac6fd043b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002ac6fd043988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002ac6fd0427b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmps_yoo5cr                        0x00005603da6294cf <unavailable> + 5327

    5    libc.so.6                          0x00002ac6fd538460 __libc_start_main +
    245

    6    tmps_yoo5cr                        0x00005603da628fc9 <unavailable> + 4041

    '
  stdout: ''
  timestamp: 1659978932
- exit_code: 0
  program: "\n/// Insert a number 'delimeter' between every two consecutive elements\
    \ of input array `numbers'\n/// >>> intersperse(numbers: [] as [Int], delimeter:\
    \ 4)\n/// [] as [Int]\n/// >>> intersperse(numbers: [1, 2, 3], delimeter: 4)\n\
    /// [1, 4, 2, 4, 3]\nfunc intersperse(numbers: [Int], delimeter: Int) -> [Int]\
    \ {\n    if numbers.isEmpty {\n        return []\n    } else {\n        var result\
    \ = [Int]()\n        for number in numbers {\n            result.append(number)\n\
    \            result.append(delimeter)\n        }\n        result.removeLast()\n\
    \        return result\n    }\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int,\
    \ Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n\
    \    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n          \
    \  return false\n        }\n    }\n    return true\n}\n            \nassert(intersperse(numbers:\
    \ [] as [Int], delimeter: 7) == [] as [Int])\nassert(intersperse(numbers: [5,\
    \ 6, 3, 2], delimeter: 8) == [5, 8, 6, 8, 3, 8, 2])\nassert(intersperse(numbers:\
    \ [2, 2, 2], delimeter: 2) == [2, 2, 2, 2, 2])"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659978932
- exit_code: 0
  program: "\n/// Insert a number 'delimeter' between every two consecutive elements\
    \ of input array `numbers'\n/// >>> intersperse(numbers: [] as [Int], delimeter:\
    \ 4)\n/// [] as [Int]\n/// >>> intersperse(numbers: [1, 2, 3], delimeter: 4)\n\
    /// [1, 4, 2, 4, 3]\nfunc intersperse(numbers: [Int], delimeter: Int) -> [Int]\
    \ {\n    if numbers.isEmpty {\n        return []\n    }\n    var res = [Int]()\n\
    \    for i in 0..<numbers.count {\n        res.append(numbers[i])\n        if\
    \ i != numbers.count - 1 {\n            res.append(delimeter)\n        }\n   \
    \ }\n    return res\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) ->\
    \ Bool {\n    if left.count != right.count {\n        return false\n    }\n  \
    \  for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(intersperse(numbers:\
    \ [] as [Int], delimeter: 7) == [] as [Int])\nassert(intersperse(numbers: [5,\
    \ 6, 3, 2], delimeter: 8) == [5, 8, 6, 8, 3, 8, 2])\nassert(intersperse(numbers:\
    \ [2, 2, 2], delimeter: 2) == [2, 2, 2, 2, 2])"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659978932
- exit_code: 0
  program: "\n/// Insert a number 'delimeter' between every two consecutive elements\
    \ of input array `numbers'\n/// >>> intersperse(numbers: [] as [Int], delimeter:\
    \ 4)\n/// [] as [Int]\n/// >>> intersperse(numbers: [1, 2, 3], delimeter: 4)\n\
    /// [1, 4, 2, 4, 3]\nfunc intersperse(numbers: [Int], delimeter: Int) -> [Int]\
    \ {\n    var result: [Int] = []\n    for (i, n) in numbers.enumerated() {\n  \
    \      result.append(n)\n        if i < numbers.count - 1 {\n            result.append(delimeter)\n\
    \        }\n    }\n    return result\n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(intersperse(numbers: [] as [Int], delimeter: 7) == [] as [Int])\nassert(intersperse(numbers:\
    \ [5, 6, 3, 2], delimeter: 8) == [5, 8, 6, 8, 3, 8, 2])\nassert(intersperse(numbers:\
    \ [2, 2, 2], delimeter: 2) == [2, 2, 2, 2, 2])"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659978932
- exit_code: 0
  program: "\n/// Insert a number 'delimeter' between every two consecutive elements\
    \ of input array `numbers'\n/// >>> intersperse(numbers: [] as [Int], delimeter:\
    \ 4)\n/// [] as [Int]\n/// >>> intersperse(numbers: [1, 2, 3], delimeter: 4)\n\
    /// [1, 4, 2, 4, 3]\nfunc intersperse(numbers: [Int], delimeter: Int) -> [Int]\
    \ {\n    guard numbers.count > 1 else { return numbers }\n    var result = [Int]()\n\
    \    for i in 0..<numbers.count - 1 {\n        result.append(numbers[i])\n   \
    \     result.append(delimeter)\n    }\n    result.append(numbers[numbers.count\
    \ - 1])\n    return result\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(intersperse(numbers:\
    \ [] as [Int], delimeter: 7) == [] as [Int])\nassert(intersperse(numbers: [5,\
    \ 6, 3, 2], delimeter: 8) == [5, 8, 6, 8, 3, 8, 2])\nassert(intersperse(numbers:\
    \ [2, 2, 2], delimeter: 2) == [2, 2, 2, 2, 2])"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659978932
- exit_code: 0
  program: "\n/// Insert a number 'delimeter' between every two consecutive elements\
    \ of input array `numbers'\n/// >>> intersperse(numbers: [] as [Int], delimeter:\
    \ 4)\n/// [] as [Int]\n/// >>> intersperse(numbers: [1, 2, 3], delimeter: 4)\n\
    /// [1, 4, 2, 4, 3]\nfunc intersperse(numbers: [Int], delimeter: Int) -> [Int]\
    \ {\n    if numbers.isEmpty {\n        return []\n    }\n    var interspersed\
    \ = [Int]()\n    for (i, number) in numbers.enumerated() {\n        interspersed.append(number)\n\
    \        if i < numbers.count - 1 {\n            interspersed.append(delimeter)\n\
    \        }\n    }\n    return interspersed\n}\n\n\nfunc ==(left: [(Int, Int)],\
    \ right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n       \
    \ return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r\
    \ {\n            return false\n        }\n    }\n    return true\n}\n        \
    \    \nassert(intersperse(numbers: [] as [Int], delimeter: 7) == [] as [Int])\n\
    assert(intersperse(numbers: [5, 6, 3, 2], delimeter: 8) == [5, 8, 6, 8, 3, 8,\
    \ 2])\nassert(intersperse(numbers: [2, 2, 2], delimeter: 2) == [2, 2, 2, 2, 2])"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659978932
- exit_code: -4
  program: "\n/// Insert a number 'delimeter' between every two consecutive elements\
    \ of input array `numbers'\n/// >>> intersperse(numbers: [] as [Int], delimeter:\
    \ 4)\n/// [] as [Int]\n/// >>> intersperse(numbers: [1, 2, 3], delimeter: 4)\n\
    /// [1, 4, 2, 4, 3]\nfunc intersperse(numbers: [Int], delimeter: Int) -> [Int]\
    \ {\n    if numbers.isEmpty {\n        return []\n    } else {\n        return\
    \ [numbers[0]] + [delimeter] + intersperse(numbers: Array(numbers[1..<numbers.count]),\
    \ delimeter: delimeter)\n    }\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int,\
    \ Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n\
    \    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n          \
    \  return false\n        }\n    }\n    return true\n}\n            \nassert(intersperse(numbers:\
    \ [] as [Int], delimeter: 7) == [] as [Int])\nassert(intersperse(numbers: [5,\
    \ 6, 3, 2], delimeter: 8) == [5, 8, 6, 8, 3, 8, 2])\nassert(intersperse(numbers:\
    \ [2, 2, 2], delimeter: 2) == [2, 2, 2, 2, 2])"
  status: Exception
  stderr: 'tmptiybotqt/tmptiybotqt.swift:29: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b91ce0eec80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b91cdde5b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b91cdde5988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b91cdde47b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmptiybotqt                        0x0000563d4cdcc85f <unavailable> + 6239

    5    libc.so.6                          0x00002b91ce2da460 __libc_start_main +
    245

    6    tmptiybotqt                        0x0000563d4cdcc359 <unavailable> + 4953

    '
  stdout: ''
  timestamp: 1659978932
- exit_code: -4
  program: "\n/// Insert a number 'delimeter' between every two consecutive elements\
    \ of input array `numbers'\n/// >>> intersperse(numbers: [] as [Int], delimeter:\
    \ 4)\n/// [] as [Int]\n/// >>> intersperse(numbers: [1, 2, 3], delimeter: 4)\n\
    /// [1, 4, 2, 4, 3]\nfunc intersperse(numbers: [Int], delimeter: Int) -> [Int]\
    \ {\n    if numbers.isEmpty {\n        return []\n    } else {\n        let first\
    \ = numbers[0]\n        let rest = Array(numbers[1..<numbers.count])\n       \
    \ return [first] + [delimeter] + intersperse(numbers: rest, delimeter: delimeter)\n\
    \    }\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n  \
    \  if left.count != right.count {\n        return false\n    }\n    for (l, r)\
    \ in zip(left, right) {\n        if l != r {\n            return false\n     \
    \   }\n    }\n    return true\n}\n            \nassert(intersperse(numbers: []\
    \ as [Int], delimeter: 7) == [] as [Int])\nassert(intersperse(numbers: [5, 6,\
    \ 3, 2], delimeter: 8) == [5, 8, 6, 8, 3, 8, 2])\nassert(intersperse(numbers:\
    \ [2, 2, 2], delimeter: 2) == [2, 2, 2, 2, 2])"
  status: Exception
  stderr: 'tmptd49am8p/tmptd49am8p.swift:31: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b0d787cbc80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b0d784c2b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b0d784c2988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b0d784c17b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmptd49am8p                        0x00005651cdb7f85f <unavailable> + 6239

    5    libc.so.6                          0x00002b0d789b7460 __libc_start_main +
    245

    6    tmptd49am8p                        0x00005651cdb7f359 <unavailable> + 4953

    '
  stdout: ''
  timestamp: 1659978932
- exit_code: 0
  program: "\n/// Insert a number 'delimeter' between every two consecutive elements\
    \ of input array `numbers'\n/// >>> intersperse(numbers: [] as [Int], delimeter:\
    \ 4)\n/// [] as [Int]\n/// >>> intersperse(numbers: [1, 2, 3], delimeter: 4)\n\
    /// [1, 4, 2, 4, 3]\nfunc intersperse(numbers: [Int], delimeter: Int) -> [Int]\
    \ {\n  if numbers.isEmpty {\n    return []\n  }\n  if numbers.count == 1 {\n \
    \   return numbers\n  }\n  return numbers.reduce([]) { $0 + [$1, delimeter] }.dropLast()\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(intersperse(numbers: [] as [Int], delimeter: 7)\
    \ == [] as [Int])\nassert(intersperse(numbers: [5, 6, 3, 2], delimeter: 8) ==\
    \ [5, 8, 6, 8, 3, 8, 2])\nassert(intersperse(numbers: [2, 2, 2], delimeter: 2)\
    \ == [2, 2, 2, 2, 2])"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659978932
- exit_code: 1
  program: "\n/// Insert a number 'delimeter' between every two consecutive elements\
    \ of input array `numbers'\n/// >>> intersperse(numbers: [] as [Int], delimeter:\
    \ 4)\n/// [] as [Int]\n/// >>> intersperse(numbers: [1, 2, 3], delimeter: 4)\n\
    /// [1, 4, 2, 4, 3]\nfunc intersperse(numbers: [Int], delimeter: Int) -> [Int]\
    \ {\n    var interspersed = [Int]()\n    for (index, number) in numbers.enumerate()\
    \ {\n        interspersed.append(number)\n        if index < numbers.count - 1\
    \ {\n            interspersed.append(delimeter)\n        }\n    }\n    return\
    \ interspersed\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool\
    \ {\n    if left.count != right.count {\n        return false\n    }\n    for\
    \ (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(intersperse(numbers:\
    \ [] as [Int], delimeter: 7) == [] as [Int])\nassert(intersperse(numbers: [5,\
    \ 6, 3, 2], delimeter: 8) == [5, 8, 6, 8, 3, 8, 2])\nassert(intersperse(numbers:\
    \ [2, 2, 2], delimeter: 2) == [2, 2, 2, 2, 2])"
  status: SyntaxError
  stderr: "/tmp/tmpu870l06w.swift:9:36: error: value of type '[Int]' has no member\
    \ 'enumerate'\n    for (index, number) in numbers.enumerate() {\n            \
    \               ~~~~~~~ ^~~~~~~~~\n"
  stdout: ''
  timestamp: 1659978932
- exit_code: 0
  program: "\n/// Insert a number 'delimeter' between every two consecutive elements\
    \ of input array `numbers'\n/// >>> intersperse(numbers: [] as [Int], delimeter:\
    \ 4)\n/// [] as [Int]\n/// >>> intersperse(numbers: [1, 2, 3], delimeter: 4)\n\
    /// [1, 4, 2, 4, 3]\nfunc intersperse(numbers: [Int], delimeter: Int) -> [Int]\
    \ {\n    guard numbers.count > 1 else { return numbers }\n    var result = [Int]()\n\
    \    for i in 0..<numbers.count {\n        result.append(numbers[i])\n       \
    \ if i != numbers.count - 1 {\n            result.append(delimeter)\n        }\n\
    \    }\n    return result\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(intersperse(numbers:\
    \ [] as [Int], delimeter: 7) == [] as [Int])\nassert(intersperse(numbers: [5,\
    \ 6, 3, 2], delimeter: 8) == [5, 8, 6, 8, 3, 8, 2])\nassert(intersperse(numbers:\
    \ [2, 2, 2], delimeter: 2) == [2, 2, 2, 2, 2])"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659978932
- exit_code: -4
  program: "\n/// Insert a number 'delimeter' between every two consecutive elements\
    \ of input array `numbers'\n/// >>> intersperse(numbers: [] as [Int], delimeter:\
    \ 4)\n/// [] as [Int]\n/// >>> intersperse(numbers: [1, 2, 3], delimeter: 4)\n\
    /// [1, 4, 2, 4, 3]\nfunc intersperse(numbers: [Int], delimeter: Int) -> [Int]\
    \ {\n    // your code here\n    return []\n}\n\n\nfunc ==(left: [(Int, Int)],\
    \ right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n       \
    \ return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r\
    \ {\n            return false\n        }\n    }\n    return true\n}\n        \
    \    \nassert(intersperse(numbers: [] as [Int], delimeter: 7) == [] as [Int])\n\
    assert(intersperse(numbers: [5, 6, 3, 2], delimeter: 8) == [5, 8, 6, 8, 3, 8,\
    \ 2])\nassert(intersperse(numbers: [2, 2, 2], delimeter: 2) == [2, 2, 2, 2, 2])"
  status: Exception
  stderr: 'tmps_yoo5cr/tmps_yoo5cr.swift:26: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002ac6fd34cc80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002ac6fd043b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002ac6fd043988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002ac6fd0427b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmps_yoo5cr                        0x00005603da6294cf <unavailable> + 5327

    5    libc.so.6                          0x00002ac6fd538460 __libc_start_main +
    245

    6    tmps_yoo5cr                        0x00005603da628fc9 <unavailable> + 4041

    '
  stdout: ''
  timestamp: 1659978932
- exit_code: 0
  program: "\n/// Insert a number 'delimeter' between every two consecutive elements\
    \ of input array `numbers'\n/// >>> intersperse(numbers: [] as [Int], delimeter:\
    \ 4)\n/// [] as [Int]\n/// >>> intersperse(numbers: [1, 2, 3], delimeter: 4)\n\
    /// [1, 4, 2, 4, 3]\nfunc intersperse(numbers: [Int], delimeter: Int) -> [Int]\
    \ {\n  guard !numbers.isEmpty else { return [] }\n  var result = [Int]()\n  result.append(numbers[0])\n\
    \  for number in numbers[1..<numbers.count] {\n    result.append(delimeter)\n\
    \    result.append(number)\n  }\n  return result\n}\n\n\nfunc ==(left: [(Int,\
    \ Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n\
    \        return false\n    }\n    for (l, r) in zip(left, right) {\n        if\
    \ l != r {\n            return false\n        }\n    }\n    return true\n}\n \
    \           \nassert(intersperse(numbers: [] as [Int], delimeter: 7) == [] as\
    \ [Int])\nassert(intersperse(numbers: [5, 6, 3, 2], delimeter: 8) == [5, 8, 6,\
    \ 8, 3, 8, 2])\nassert(intersperse(numbers: [2, 2, 2], delimeter: 2) == [2, 2,\
    \ 2, 2, 2])"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659978932
- exit_code: 0
  program: "\n/// Insert a number 'delimeter' between every two consecutive elements\
    \ of input array `numbers'\n/// >>> intersperse(numbers: [] as [Int], delimeter:\
    \ 4)\n/// [] as [Int]\n/// >>> intersperse(numbers: [1, 2, 3], delimeter: 4)\n\
    /// [1, 4, 2, 4, 3]\nfunc intersperse(numbers: [Int], delimeter: Int) -> [Int]\
    \ {\n    if (numbers.count <= 1) {\n        return numbers\n    }\n    else {\n\
    \        var result = [Int]()\n        for i in 0...numbers.count-2 {\n      \
    \      result.append(numbers[i])\n            result.append(delimeter)\n     \
    \   }\n        result.append(numbers[numbers.count-1])\n        return result\n\
    \    }\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n  \
    \  if left.count != right.count {\n        return false\n    }\n    for (l, r)\
    \ in zip(left, right) {\n        if l != r {\n            return false\n     \
    \   }\n    }\n    return true\n}\n            \nassert(intersperse(numbers: []\
    \ as [Int], delimeter: 7) == [] as [Int])\nassert(intersperse(numbers: [5, 6,\
    \ 3, 2], delimeter: 8) == [5, 8, 6, 8, 3, 8, 2])\nassert(intersperse(numbers:\
    \ [2, 2, 2], delimeter: 2) == [2, 2, 2, 2, 2])"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659978932
- exit_code: 1
  program: "\n/// Insert a number 'delimeter' between every two consecutive elements\
    \ of input array `numbers'\n/// >>> intersperse(numbers: [] as [Int], delimeter:\
    \ 4)\n/// [] as [Int]\n/// >>> intersperse(numbers: [1, 2, 3], delimeter: 4)\n\
    /// [1, 4, 2, 4, 3]\nfunc intersperse(numbers: [Int], delimeter: Int) -> [Int]\
    \ {\n    return transpose(lists: numbers.map{[$0]}, delimeter: [delimeter])\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(intersperse(numbers: [] as [Int], delimeter: 7)\
    \ == [] as [Int])\nassert(intersperse(numbers: [5, 6, 3, 2], delimeter: 8) ==\
    \ [5, 8, 6, 8, 3, 8, 2])\nassert(intersperse(numbers: [2, 2, 2], delimeter: 2)\
    \ == [2, 2, 2, 2, 2])"
  status: SyntaxError
  stderr: "/tmp/tmpp85wq2vj.swift:8:12: error: cannot find 'transpose' in scope\n\
    \    return transpose(lists: numbers.map{[$0]}, delimeter: [delimeter])\n    \
    \       ^~~~~~~~~\n"
  stdout: ''
  timestamp: 1659978932
- exit_code: 0
  program: "\n/// Insert a number 'delimeter' between every two consecutive elements\
    \ of input array `numbers'\n/// >>> intersperse(numbers: [] as [Int], delimeter:\
    \ 4)\n/// [] as [Int]\n/// >>> intersperse(numbers: [1, 2, 3], delimeter: 4)\n\
    /// [1, 4, 2, 4, 3]\nfunc intersperse(numbers: [Int], delimeter: Int) -> [Int]\
    \ {\n    if numbers.isEmpty {\n        return []\n    }\n    if numbers.count\
    \ == 1 {\n        return numbers\n    }\n    var result = [Int]()\n    for (index,\
    \ number) in numbers.enumerated() {\n        result.append(number)\n        if\
    \ index != numbers.count - 1 {\n            result.append(delimeter)\n       \
    \ }\n    }\n    return result\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int,\
    \ Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n\
    \    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n          \
    \  return false\n        }\n    }\n    return true\n}\n            \nassert(intersperse(numbers:\
    \ [] as [Int], delimeter: 7) == [] as [Int])\nassert(intersperse(numbers: [5,\
    \ 6, 3, 2], delimeter: 8) == [5, 8, 6, 8, 3, 8, 2])\nassert(intersperse(numbers:\
    \ [2, 2, 2], delimeter: 2) == [2, 2, 2, 2, 2])"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659978932
- exit_code: 1
  program: "\n/// Insert a number 'delimeter' between every two consecutive elements\
    \ of input array `numbers'\n/// >>> intersperse(numbers: [] as [Int], delimeter:\
    \ 4)\n/// [] as [Int]\n/// >>> intersperse(numbers: [1, 2, 3], delimeter: 4)\n\
    /// [1, 4, 2, 4, 3]\nfunc intersperse(numbers: [Int], delimeter: Int) -> [Int]\
    \ {\n    if numbers.isEmpty {\n        return []\n    } else {\n        return\
    \ [numbers[0]] + intersperse(numbers: numbers.dropFirst(), delimeter: delimeter).flatMap\
    \ { [delimeter, $0] }\n    }\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int,\
    \ Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n\
    \    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n          \
    \  return false\n        }\n    }\n    return true\n}\n            \nassert(intersperse(numbers:\
    \ [] as [Int], delimeter: 7) == [] as [Int])\nassert(intersperse(numbers: [5,\
    \ 6, 3, 2], delimeter: 8) == [5, 8, 6, 8, 3, 8, 2])\nassert(intersperse(numbers:\
    \ [2, 2, 2], delimeter: 2) == [2, 2, 2, 2, 2])"
  status: SyntaxError
  stderr: "/tmp/tmp43_x5djk.swift:11:60: error: cannot convert value of type 'ArraySlice<Int>'\
    \ to expected argument type '[Int]'\n        return [numbers[0]] + intersperse(numbers:\
    \ numbers.dropFirst(), delimeter: delimeter).flatMap { [delimeter, $0] }\n   \
    \                                                        ^\n"
  stdout: ''
  timestamp: 1659978932
- exit_code: 0
  program: "\n/// Insert a number 'delimeter' between every two consecutive elements\
    \ of input array `numbers'\n/// >>> intersperse(numbers: [] as [Int], delimeter:\
    \ 4)\n/// [] as [Int]\n/// >>> intersperse(numbers: [1, 2, 3], delimeter: 4)\n\
    /// [1, 4, 2, 4, 3]\nfunc intersperse(numbers: [Int], delimeter: Int) -> [Int]\
    \ {\n    guard !numbers.isEmpty else { return [] }\n    var result = [Int]()\n\
    \    for i in 0 ..< numbers.count - 1 {\n        result.append(numbers[i])\n \
    \       result.append(delimeter)\n    }\n    result.append(numbers.last!)\n  \
    \  return result\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool\
    \ {\n    if left.count != right.count {\n        return false\n    }\n    for\
    \ (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(intersperse(numbers:\
    \ [] as [Int], delimeter: 7) == [] as [Int])\nassert(intersperse(numbers: [5,\
    \ 6, 3, 2], delimeter: 8) == [5, 8, 6, 8, 3, 8, 2])\nassert(intersperse(numbers:\
    \ [2, 2, 2], delimeter: 2) == [2, 2, 2, 2, 2])"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659978932
- exit_code: -4
  program: "\n/// Insert a number 'delimeter' between every two consecutive elements\
    \ of input array `numbers'\n/// >>> intersperse(numbers: [] as [Int], delimeter:\
    \ 4)\n/// [] as [Int]\n/// >>> intersperse(numbers: [1, 2, 3], delimeter: 4)\n\
    /// [1, 4, 2, 4, 3]\nfunc intersperse(numbers: [Int], delimeter: Int) -> [Int]\
    \ {\n    if numbers.isEmpty {\n        return []\n    }\n    return [numbers[0]]\
    \ + intersperse(numbers: numbers.dropFirst().map { $0 }, delimeter: delimeter).flatMap\
    \ { [delimeter, $0] }\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(intersperse(numbers:\
    \ [] as [Int], delimeter: 7) == [] as [Int])\nassert(intersperse(numbers: [5,\
    \ 6, 3, 2], delimeter: 8) == [5, 8, 6, 8, 3, 8, 2])\nassert(intersperse(numbers:\
    \ [2, 2, 2], delimeter: 2) == [2, 2, 2, 2, 2])"
  status: Exception
  stderr: 'tmprzstacrm/tmprzstacrm.swift:28: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002ae97f71fc80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002ae97f416b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002ae97f416988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002ae97f4157b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmprzstacrm                        0x000055900ad367ef <unavailable> + 6127

    5    libc.so.6                          0x00002ae97f90b460 __libc_start_main +
    245

    6    tmprzstacrm                        0x000055900ad362e9 <unavailable> + 4841

    '
  stdout: ''
  timestamp: 1659978932
- exit_code: 0
  program: "\n/// Insert a number 'delimeter' between every two consecutive elements\
    \ of input array `numbers'\n/// >>> intersperse(numbers: [] as [Int], delimeter:\
    \ 4)\n/// [] as [Int]\n/// >>> intersperse(numbers: [1, 2, 3], delimeter: 4)\n\
    /// [1, 4, 2, 4, 3]\nfunc intersperse(numbers: [Int], delimeter: Int) -> [Int]\
    \ {\n\tvar res = [Int]()\n\tguard numbers.count > 0 else {\n\t\treturn []\n\t\
    }\n\tfor num in numbers[0..<numbers.count - 1] {\n\t\tres.append(num)\n\t\tres.append(delimeter)\n\
    \t}\n\tres.append(numbers[numbers.count - 1])\n\treturn res\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(intersperse(numbers: [] as [Int], delimeter: 7) == []\
    \ as [Int])\nassert(intersperse(numbers: [5, 6, 3, 2], delimeter: 8) == [5, 8,\
    \ 6, 8, 3, 8, 2])\nassert(intersperse(numbers: [2, 2, 2], delimeter: 2) == [2,\
    \ 2, 2, 2, 2])"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659978932
- exit_code: 0
  program: "\n/// Insert a number 'delimeter' between every two consecutive elements\
    \ of input array `numbers'\n/// >>> intersperse(numbers: [] as [Int], delimeter:\
    \ 4)\n/// [] as [Int]\n/// >>> intersperse(numbers: [1, 2, 3], delimeter: 4)\n\
    /// [1, 4, 2, 4, 3]\nfunc intersperse(numbers: [Int], delimeter: Int) -> [Int]\
    \ {\n  var result: [Int] = []\n  for i in 0..<numbers.count {\n    result.append(numbers[i])\n\
    \    if i != numbers.count - 1 {\n      result.append(delimeter)\n    }\n  }\n\
    \  return result\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool\
    \ {\n    if left.count != right.count {\n        return false\n    }\n    for\
    \ (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(intersperse(numbers:\
    \ [] as [Int], delimeter: 7) == [] as [Int])\nassert(intersperse(numbers: [5,\
    \ 6, 3, 2], delimeter: 8) == [5, 8, 6, 8, 3, 8, 2])\nassert(intersperse(numbers:\
    \ [2, 2, 2], delimeter: 2) == [2, 2, 2, 2, 2])"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659978932
- exit_code: 0
  program: "\n/// Insert a number 'delimeter' between every two consecutive elements\
    \ of input array `numbers'\n/// >>> intersperse(numbers: [] as [Int], delimeter:\
    \ 4)\n/// [] as [Int]\n/// >>> intersperse(numbers: [1, 2, 3], delimeter: 4)\n\
    /// [1, 4, 2, 4, 3]\nfunc intersperse(numbers: [Int], delimeter: Int) -> [Int]\
    \ {\n    if numbers.isEmpty {\n        return []\n    } else {\n        var interspersed:\
    \ [Int] = []\n        for i in 0..<numbers.count - 1 {\n            interspersed.append(numbers[i])\n\
    \            interspersed.append(delimeter)\n        }\n        interspersed.append(numbers[numbers.count\
    \ - 1])\n        return interspersed\n    }\n}\n\n\nfunc ==(left: [(Int, Int)],\
    \ right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n       \
    \ return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r\
    \ {\n            return false\n        }\n    }\n    return true\n}\n        \
    \    \nassert(intersperse(numbers: [] as [Int], delimeter: 7) == [] as [Int])\n\
    assert(intersperse(numbers: [5, 6, 3, 2], delimeter: 8) == [5, 8, 6, 8, 3, 8,\
    \ 2])\nassert(intersperse(numbers: [2, 2, 2], delimeter: 2) == [2, 2, 2, 2, 2])"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659978932
- exit_code: 0
  program: "\n/// Insert a number 'delimeter' between every two consecutive elements\
    \ of input array `numbers'\n/// >>> intersperse(numbers: [] as [Int], delimeter:\
    \ 4)\n/// [] as [Int]\n/// >>> intersperse(numbers: [1, 2, 3], delimeter: 4)\n\
    /// [1, 4, 2, 4, 3]\nfunc intersperse(numbers: [Int], delimeter: Int) -> [Int]\
    \ {\n    var result: [Int] = []\n    for i in 0..<numbers.count {\n        result.append(numbers[i])\n\
    \        if i != numbers.count - 1 {\n            result.append(delimeter)\n \
    \       }\n    }\n    return result\n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(intersperse(numbers: [] as [Int], delimeter: 7) == [] as [Int])\nassert(intersperse(numbers:\
    \ [5, 6, 3, 2], delimeter: 8) == [5, 8, 6, 8, 3, 8, 2])\nassert(intersperse(numbers:\
    \ [2, 2, 2], delimeter: 2) == [2, 2, 2, 2, 2])"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659978931
- exit_code: -4
  program: "\n/// Insert a number 'delimeter' between every two consecutive elements\
    \ of input array `numbers'\n/// >>> intersperse(numbers: [] as [Int], delimeter:\
    \ 4)\n/// [] as [Int]\n/// >>> intersperse(numbers: [1, 2, 3], delimeter: 4)\n\
    /// [1, 4, 2, 4, 3]\nfunc intersperse(numbers: [Int], delimeter: Int) -> [Int]\
    \ {\n    let first = numbers.isEmpty ? [] : [numbers[0]]\n    return first + (1..<numbers.count).flatMap\
    \ { [delimeter, numbers[$0]] }\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int,\
    \ Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n\
    \    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n          \
    \  return false\n        }\n    }\n    return true\n}\n            \nassert(intersperse(numbers:\
    \ [] as [Int], delimeter: 7) == [] as [Int])\nassert(intersperse(numbers: [5,\
    \ 6, 3, 2], delimeter: 8) == [5, 8, 6, 8, 3, 8, 2])\nassert(intersperse(numbers:\
    \ [2, 2, 2], delimeter: 2) == [2, 2, 2, 2, 2])"
  status: Exception
  stderr: 'Swift/Range.swift:743: Fatal error: Range requires lowerBound <= upperBound

    Current stack trace:

    0    libswiftCore.so                    0x00002b22795b7c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b22792ae561 <unavailable> + 1434977

    2    libswiftCore.so                    0x00002b22792ae286 <unavailable> + 1434246

    3    libswiftCore.so                    0x00002b22792ae13c <unavailable> + 1433916

    4    libswiftCore.so                    0x00002b22792adbb0 _assertionFailure(_:_:file:line:flags:)
    + 251

    5    tmp9xe6bgok                        0x000055ece72e2bb8 <unavailable> + 7096

    6    tmp9xe6bgok                        0x000055ece72e2632 <unavailable> + 5682

    7    libc.so.6                          0x00002b22797a3460 __libc_start_main +
    245

    8    tmp9xe6bgok                        0x000055ece72e2339 <unavailable> + 4921

    '
  stdout: ''
  timestamp: 1659978932
- exit_code: -4
  program: "\n/// Insert a number 'delimeter' between every two consecutive elements\
    \ of input array `numbers'\n/// >>> intersperse(numbers: [] as [Int], delimeter:\
    \ 4)\n/// [] as [Int]\n/// >>> intersperse(numbers: [1, 2, 3], delimeter: 4)\n\
    /// [1, 4, 2, 4, 3]\nfunc intersperse(numbers: [Int], delimeter: Int) -> [Int]\
    \ {\n    return []\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) ->\
    \ Bool {\n    if left.count != right.count {\n        return false\n    }\n  \
    \  for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(intersperse(numbers:\
    \ [] as [Int], delimeter: 7) == [] as [Int])\nassert(intersperse(numbers: [5,\
    \ 6, 3, 2], delimeter: 8) == [5, 8, 6, 8, 3, 8, 2])\nassert(intersperse(numbers:\
    \ [2, 2, 2], delimeter: 2) == [2, 2, 2, 2, 2])"
  status: Exception
  stderr: 'tmp0sr70v0j/tmp0sr70v0j.swift:25: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b5f1c432c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b5f1c129b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b5f1c129988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b5f1c1287b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmp0sr70v0j                        0x000055f4032774cf <unavailable> + 5327

    5    libc.so.6                          0x00002b5f1c61e460 __libc_start_main +
    245

    6    tmp0sr70v0j                        0x000055f403276fc9 <unavailable> + 4041

    '
  stdout: ''
  timestamp: 1659978932
- exit_code: 0
  program: "\n/// Insert a number 'delimeter' between every two consecutive elements\
    \ of input array `numbers'\n/// >>> intersperse(numbers: [] as [Int], delimeter:\
    \ 4)\n/// [] as [Int]\n/// >>> intersperse(numbers: [1, 2, 3], delimeter: 4)\n\
    /// [1, 4, 2, 4, 3]\nfunc intersperse(numbers: [Int], delimeter: Int) -> [Int]\
    \ {\n  if numbers.isEmpty {\n    return []\n  } else if numbers.count == 1 {\n\
    \    return numbers\n  }\n  var results = [Int]()\n  for i in 0..<numbers.count\
    \ - 1 {\n    results.append(numbers[i])\n    results.append(delimeter)\n  }\n\
    \  results.append(numbers[numbers.count - 1])\n  return results\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(intersperse(numbers: [] as [Int], delimeter: 7) == []\
    \ as [Int])\nassert(intersperse(numbers: [5, 6, 3, 2], delimeter: 8) == [5, 8,\
    \ 6, 8, 3, 8, 2])\nassert(intersperse(numbers: [2, 2, 2], delimeter: 2) == [2,\
    \ 2, 2, 2, 2])"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659978932
- exit_code: -4
  program: "\n/// Insert a number 'delimeter' between every two consecutive elements\
    \ of input array `numbers'\n/// >>> intersperse(numbers: [] as [Int], delimeter:\
    \ 4)\n/// [] as [Int]\n/// >>> intersperse(numbers: [1, 2, 3], delimeter: 4)\n\
    /// [1, 4, 2, 4, 3]\nfunc intersperse(numbers: [Int], delimeter: Int) -> [Int]\
    \ {\n    let n = numbers.count\n    var result = [Int]()\n    for i in 0..<n-1\
    \ {\n        result.append(numbers[i])\n        result.append(delimeter)\n   \
    \ }\n    if n > 0 {\n        result.append(numbers[n-1])\n    }\n    return result\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(intersperse(numbers: [] as [Int], delimeter: 7)\
    \ == [] as [Int])\nassert(intersperse(numbers: [5, 6, 3, 2], delimeter: 8) ==\
    \ [5, 8, 6, 8, 3, 8, 2])\nassert(intersperse(numbers: [2, 2, 2], delimeter: 2)\
    \ == [2, 2, 2, 2, 2])"
  status: Exception
  stderr: 'Swift/Range.swift:743: Fatal error: Range requires lowerBound <= upperBound

    Current stack trace:

    0    libswiftCore.so                    0x00002b128b5eac80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b128b2e1561 <unavailable> + 1434977

    2    libswiftCore.so                    0x00002b128b2e1286 <unavailable> + 1434246

    3    libswiftCore.so                    0x00002b128b2e113c <unavailable> + 1433916

    4    libswiftCore.so                    0x00002b128b2e0bb0 _assertionFailure(_:_:file:line:flags:)
    + 251

    5    tmpqp1duss6                        0x000055ff7992ca89 <unavailable> + 6793

    6    tmpqp1duss6                        0x000055ff7992c5b2 <unavailable> + 5554

    7    libc.so.6                          0x00002b128b7d6460 __libc_start_main +
    245

    8    tmpqp1duss6                        0x000055ff7992c2b9 <unavailable> + 4793

    '
  stdout: ''
  timestamp: 1659978932
- exit_code: 0
  program: "\n/// Insert a number 'delimeter' between every two consecutive elements\
    \ of input array `numbers'\n/// >>> intersperse(numbers: [] as [Int], delimeter:\
    \ 4)\n/// [] as [Int]\n/// >>> intersperse(numbers: [1, 2, 3], delimeter: 4)\n\
    /// [1, 4, 2, 4, 3]\nfunc intersperse(numbers: [Int], delimeter: Int) -> [Int]\
    \ {\n    if numbers.isEmpty {\n        return []\n    }\n    var result = [Int]()\n\
    \    for number in numbers {\n        result.append(number)\n        result.append(delimeter)\n\
    \    }\n    result.removeLast()\n    return result\n}\n\n\nfunc ==(left: [(Int,\
    \ Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n\
    \        return false\n    }\n    for (l, r) in zip(left, right) {\n        if\
    \ l != r {\n            return false\n        }\n    }\n    return true\n}\n \
    \           \nassert(intersperse(numbers: [] as [Int], delimeter: 7) == [] as\
    \ [Int])\nassert(intersperse(numbers: [5, 6, 3, 2], delimeter: 8) == [5, 8, 6,\
    \ 8, 3, 8, 2])\nassert(intersperse(numbers: [2, 2, 2], delimeter: 2) == [2, 2,\
    \ 2, 2, 2])"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659978931
- exit_code: 0
  program: "\n/// Insert a number 'delimeter' between every two consecutive elements\
    \ of input array `numbers'\n/// >>> intersperse(numbers: [] as [Int], delimeter:\
    \ 4)\n/// [] as [Int]\n/// >>> intersperse(numbers: [1, 2, 3], delimeter: 4)\n\
    /// [1, 4, 2, 4, 3]\nfunc intersperse(numbers: [Int], delimeter: Int) -> [Int]\
    \ {\n    var result: [Int] = []\n    for (index, number) in numbers.enumerated()\
    \ {\n        result.append(number)\n        if index != numbers.count - 1 {\n\
    \            result.append(delimeter)\n        }\n    }\n    return result\n}\n\
    \n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(intersperse(numbers: [] as [Int], delimeter: 7)\
    \ == [] as [Int])\nassert(intersperse(numbers: [5, 6, 3, 2], delimeter: 8) ==\
    \ [5, 8, 6, 8, 3, 8, 2])\nassert(intersperse(numbers: [2, 2, 2], delimeter: 2)\
    \ == [2, 2, 2, 2, 2])"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659978932
- exit_code: 0
  program: "\n/// Insert a number 'delimeter' between every two consecutive elements\
    \ of input array `numbers'\n/// >>> intersperse(numbers: [] as [Int], delimeter:\
    \ 4)\n/// [] as [Int]\n/// >>> intersperse(numbers: [1, 2, 3], delimeter: 4)\n\
    /// [1, 4, 2, 4, 3]\nfunc intersperse(numbers: [Int], delimeter: Int) -> [Int]\
    \ {\n    if numbers.isEmpty {\n        return []\n    }\n    var result = [Int]()\n\
    \    result.append(numbers[0])\n    for i in 1..<numbers.count {\n        result.append(delimeter)\n\
    \        result.append(numbers[i])\n    }\n    return result\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(intersperse(numbers: [] as [Int], delimeter: 7) == []\
    \ as [Int])\nassert(intersperse(numbers: [5, 6, 3, 2], delimeter: 8) == [5, 8,\
    \ 6, 8, 3, 8, 2])\nassert(intersperse(numbers: [2, 2, 2], delimeter: 2) == [2,\
    \ 2, 2, 2, 2])"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659978932
- exit_code: -4
  program: "\n/// Insert a number 'delimeter' between every two consecutive elements\
    \ of input array `numbers'\n/// >>> intersperse(numbers: [] as [Int], delimeter:\
    \ 4)\n/// [] as [Int]\n/// >>> intersperse(numbers: [1, 2, 3], delimeter: 4)\n\
    /// [1, 4, 2, 4, 3]\nfunc intersperse(numbers: [Int], delimeter: Int) -> [Int]\
    \ {\n    var result: [Int] = []\n    for number in numbers {\n        result.append(number)\n\
    \        result.append(delimeter)\n    }\n    result.removeLast()\n    return\
    \ result\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n\
    \    if left.count != right.count {\n        return false\n    }\n    for (l,\
    \ r) in zip(left, right) {\n        if l != r {\n            return false\n  \
    \      }\n    }\n    return true\n}\n            \nassert(intersperse(numbers:\
    \ [] as [Int], delimeter: 7) == [] as [Int])\nassert(intersperse(numbers: [5,\
    \ 6, 3, 2], delimeter: 8) == [5, 8, 6, 8, 3, 8, 2])\nassert(intersperse(numbers:\
    \ [2, 2, 2], delimeter: 2) == [2, 2, 2, 2, 2])"
  status: Exception
  stderr: 'Swift/RangeReplaceableCollection.swift:870: Fatal error: Can''t remove
    last element from an empty collection

    Current stack trace:

    0    libswiftCore.so                    0x00002b3b4763ec80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b3b47335561 <unavailable> + 1434977

    2    libswiftCore.so                    0x00002b3b47335286 <unavailable> + 1434246

    3    libswiftCore.so                    0x00002b3b4733513c <unavailable> + 1433916

    4    libswiftCore.so                    0x00002b3b47334bb0 _assertionFailure(_:_:file:line:flags:)
    + 251

    5    libswiftCore.so                    0x00002b3b47436c1d <unavailable> + 2489373

    6    tmpx16ziy_q                        0x00005627f8d2ba72 <unavailable> + 6770

    7    tmpx16ziy_q                        0x00005627f8d2b572 <unavailable> + 5490

    8    libc.so.6                          0x00002b3b4782a460 __libc_start_main +
    245

    9    tmpx16ziy_q                        0x00005627f8d2b279 <unavailable> + 4729

    '
  stdout: ''
  timestamp: 1659978931
- exit_code: 0
  program: "\n/// Insert a number 'delimeter' between every two consecutive elements\
    \ of input array `numbers'\n/// >>> intersperse(numbers: [] as [Int], delimeter:\
    \ 4)\n/// [] as [Int]\n/// >>> intersperse(numbers: [1, 2, 3], delimeter: 4)\n\
    /// [1, 4, 2, 4, 3]\nfunc intersperse(numbers: [Int], delimeter: Int) -> [Int]\
    \ {\n    var result: [Int] = []\n    var isPreviousElement = false\n    for number\
    \ in numbers {\n        if isPreviousElement {\n            result.append(delimeter)\n\
    \        }\n        result.append(number)\n        isPreviousElement = true\n\
    \    }\n    return result\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(intersperse(numbers:\
    \ [] as [Int], delimeter: 7) == [] as [Int])\nassert(intersperse(numbers: [5,\
    \ 6, 3, 2], delimeter: 8) == [5, 8, 6, 8, 3, 8, 2])\nassert(intersperse(numbers:\
    \ [2, 2, 2], delimeter: 2) == [2, 2, 2, 2, 2])"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659978932
- exit_code: 0
  program: "\n/// Insert a number 'delimeter' between every two consecutive elements\
    \ of input array `numbers'\n/// >>> intersperse(numbers: [] as [Int], delimeter:\
    \ 4)\n/// [] as [Int]\n/// >>> intersperse(numbers: [1, 2, 3], delimeter: 4)\n\
    /// [1, 4, 2, 4, 3]\nfunc intersperse(numbers: [Int], delimeter: Int) -> [Int]\
    \ {\n    var result: [Int] = []\n    var first = true\n    for number in numbers\
    \ {\n        if first {\n            first = false\n        } else {\n       \
    \     result.append(delimeter)\n        }\n        result.append(number)\n   \
    \ }\n    return result\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(intersperse(numbers:\
    \ [] as [Int], delimeter: 7) == [] as [Int])\nassert(intersperse(numbers: [5,\
    \ 6, 3, 2], delimeter: 8) == [5, 8, 6, 8, 3, 8, 2])\nassert(intersperse(numbers:\
    \ [2, 2, 2], delimeter: 2) == [2, 2, 2, 2, 2])"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659978932
- exit_code: 0
  program: "\n/// Insert a number 'delimeter' between every two consecutive elements\
    \ of input array `numbers'\n/// >>> intersperse(numbers: [] as [Int], delimeter:\
    \ 4)\n/// [] as [Int]\n/// >>> intersperse(numbers: [1, 2, 3], delimeter: 4)\n\
    /// [1, 4, 2, 4, 3]\nfunc intersperse(numbers: [Int], delimeter: Int) -> [Int]\
    \ {\n    if numbers.isEmpty {\n        return []\n    } else {\n        var result\
    \ = [Int]()\n        for i in 0..<numbers.count - 1 {\n            result.append(numbers[i])\n\
    \            result.append(delimeter)\n        }\n        result.append(numbers[numbers.count\
    \ - 1])\n        return result\n    }\n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(intersperse(numbers: [] as [Int], delimeter: 7) == [] as [Int])\nassert(intersperse(numbers:\
    \ [5, 6, 3, 2], delimeter: 8) == [5, 8, 6, 8, 3, 8, 2])\nassert(intersperse(numbers:\
    \ [2, 2, 2], delimeter: 2) == [2, 2, 2, 2, 2])"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659978932
- exit_code: 0
  program: "\n/// Insert a number 'delimeter' between every two consecutive elements\
    \ of input array `numbers'\n/// >>> intersperse(numbers: [] as [Int], delimeter:\
    \ 4)\n/// [] as [Int]\n/// >>> intersperse(numbers: [1, 2, 3], delimeter: 4)\n\
    /// [1, 4, 2, 4, 3]\nfunc intersperse(numbers: [Int], delimeter: Int) -> [Int]\
    \ {\n    var result: [Int] = []\n    for n in numbers {\n        result.append(n)\n\
    \        result.append(delimeter)\n    }\n    if result.count > 0 {\n        result.removeLast()\n\
    \    }\n    return result\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(intersperse(numbers:\
    \ [] as [Int], delimeter: 7) == [] as [Int])\nassert(intersperse(numbers: [5,\
    \ 6, 3, 2], delimeter: 8) == [5, 8, 6, 8, 3, 8, 2])\nassert(intersperse(numbers:\
    \ [2, 2, 2], delimeter: 2) == [2, 2, 2, 2, 2])"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659978932
- exit_code: -4
  program: "\n/// Insert a number 'delimeter' between every two consecutive elements\
    \ of input array `numbers'\n/// >>> intersperse(numbers: [] as [Int], delimeter:\
    \ 4)\n/// [] as [Int]\n/// >>> intersperse(numbers: [1, 2, 3], delimeter: 4)\n\
    /// [1, 4, 2, 4, 3]\nfunc intersperse(numbers: [Int], delimeter: Int) -> [Int]\
    \ {\n    if numbers.isEmpty {\n        return []\n    } else {\n        let head\
    \ = numbers[0]\n        let tail = numbers[1..<numbers.count]\n        return\
    \ [head] + [delimeter] + intersperse(numbers: Array(tail), delimeter: delimeter)\n\
    \    }\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n  \
    \  if left.count != right.count {\n        return false\n    }\n    for (l, r)\
    \ in zip(left, right) {\n        if l != r {\n            return false\n     \
    \   }\n    }\n    return true\n}\n            \nassert(intersperse(numbers: []\
    \ as [Int], delimeter: 7) == [] as [Int])\nassert(intersperse(numbers: [5, 6,\
    \ 3, 2], delimeter: 8) == [5, 8, 6, 8, 3, 8, 2])\nassert(intersperse(numbers:\
    \ [2, 2, 2], delimeter: 2) == [2, 2, 2, 2, 2])"
  status: Exception
  stderr: 'tmp710cfktn/tmp710cfktn.swift:31: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b4a8f6b4c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b4a8f3abb6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b4a8f3ab988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b4a8f3aa7b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmp710cfktn                        0x000055fa75dbf85f <unavailable> + 6239

    5    libc.so.6                          0x00002b4a8f8a0460 __libc_start_main +
    245

    6    tmp710cfktn                        0x000055fa75dbf359 <unavailable> + 4953

    '
  stdout: ''
  timestamp: 1659978933
- exit_code: -4
  program: "\n/// Insert a number 'delimeter' between every two consecutive elements\
    \ of input array `numbers'\n/// >>> intersperse(numbers: [] as [Int], delimeter:\
    \ 4)\n/// [] as [Int]\n/// >>> intersperse(numbers: [1, 2, 3], delimeter: 4)\n\
    /// [1, 4, 2, 4, 3]\nfunc intersperse(numbers: [Int], delimeter: Int) -> [Int]\
    \ {\n    // YOUR CODE GOES HERE\n    return []\n}\n\n\nfunc ==(left: [(Int, Int)],\
    \ right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n       \
    \ return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r\
    \ {\n            return false\n        }\n    }\n    return true\n}\n        \
    \    \nassert(intersperse(numbers: [] as [Int], delimeter: 7) == [] as [Int])\n\
    assert(intersperse(numbers: [5, 6, 3, 2], delimeter: 8) == [5, 8, 6, 8, 3, 8,\
    \ 2])\nassert(intersperse(numbers: [2, 2, 2], delimeter: 2) == [2, 2, 2, 2, 2])"
  status: Exception
  stderr: 'tmpl50467vb/tmpl50467vb.swift:26: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b031fae1c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b031f7d8b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b031f7d8988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b031f7d77b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpl50467vb                        0x000055caa192a4cf <unavailable> + 5327

    5    libc.so.6                          0x00002b031fccd460 __libc_start_main +
    245

    6    tmpl50467vb                        0x000055caa1929fc9 <unavailable> + 4041

    '
  stdout: ''
  timestamp: 1659978932
- exit_code: -4
  program: "\n/// Insert a number 'delimeter' between every two consecutive elements\
    \ of input array `numbers'\n/// >>> intersperse(numbers: [] as [Int], delimeter:\
    \ 4)\n/// [] as [Int]\n/// >>> intersperse(numbers: [1, 2, 3], delimeter: 4)\n\
    /// [1, 4, 2, 4, 3]\nfunc intersperse(numbers: [Int], delimeter: Int) -> [Int]\
    \ {\n    var result: [Int] = []\n    var index = 0\n    while index < numbers.count\
    \ - 1 {\n        result.append(numbers[index])\n        result.append(delimeter)\n\
    \        index += 1\n    }\n    result.append(numbers[index])\n    return result\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(intersperse(numbers: [] as [Int], delimeter: 7)\
    \ == [] as [Int])\nassert(intersperse(numbers: [5, 6, 3, 2], delimeter: 8) ==\
    \ [5, 8, 6, 8, 3, 8, 2])\nassert(intersperse(numbers: [2, 2, 2], delimeter: 2)\
    \ == [2, 2, 2, 2, 2])"
  status: Exception
  stderr: 'Swift/ContiguousArrayBuffer.swift:600: Fatal error: Index out of range

    Current stack trace:

    0    libswiftCore.so                    0x00002b5310bccc80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b53108c3561 <unavailable> + 1434977

    2    libswiftCore.so                    0x00002b53108c3286 <unavailable> + 1434246

    3    libswiftCore.so                    0x00002b53108c313c <unavailable> + 1433916

    4    libswiftCore.so                    0x00002b53108c2bb0 _assertionFailure(_:_:file:line:flags:)
    + 251

    5    libswiftSwiftOnoneSupport.so       0x00002b53106c2e83 <unavailable> + 188035

    6    tmpj991n448                        0x000055d9390ad858 <unavailable> + 6232

    7    tmpj991n448                        0x000055d9390ad3d2 <unavailable> + 5074

    8    libc.so.6                          0x00002b5310db8460 __libc_start_main +
    245

    9    tmpj991n448                        0x000055d9390ad0d9 <unavailable> + 4313

    '
  stdout: ''
  timestamp: 1659978933
- exit_code: 0
  program: "\n/// Insert a number 'delimeter' between every two consecutive elements\
    \ of input array `numbers'\n/// >>> intersperse(numbers: [] as [Int], delimeter:\
    \ 4)\n/// [] as [Int]\n/// >>> intersperse(numbers: [1, 2, 3], delimeter: 4)\n\
    /// [1, 4, 2, 4, 3]\nfunc intersperse(numbers: [Int], delimeter: Int) -> [Int]\
    \ {\n    if numbers.isEmpty {\n        return []\n    } else {\n        var result\
    \ = [Int]()\n        for (index, number) in numbers.enumerated() {\n         \
    \   result.append(number)\n            if index != numbers.count - 1 {\n     \
    \           result.append(delimeter)\n            }\n        }\n        return\
    \ result\n    }\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool\
    \ {\n    if left.count != right.count {\n        return false\n    }\n    for\
    \ (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(intersperse(numbers:\
    \ [] as [Int], delimeter: 7) == [] as [Int])\nassert(intersperse(numbers: [5,\
    \ 6, 3, 2], delimeter: 8) == [5, 8, 6, 8, 3, 8, 2])\nassert(intersperse(numbers:\
    \ [2, 2, 2], delimeter: 2) == [2, 2, 2, 2, 2])"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659978931
- exit_code: 0
  program: "\n/// Insert a number 'delimeter' between every two consecutive elements\
    \ of input array `numbers'\n/// >>> intersperse(numbers: [] as [Int], delimeter:\
    \ 4)\n/// [] as [Int]\n/// >>> intersperse(numbers: [1, 2, 3], delimeter: 4)\n\
    /// [1, 4, 2, 4, 3]\nfunc intersperse(numbers: [Int], delimeter: Int) -> [Int]\
    \ {\n    var result: [Int] = []\n    for i in 0..<numbers.count {\n        result.append(numbers[i])\n\
    \        if i != numbers.count - 1 {\n            result.append(delimeter)\n \
    \       }\n    }\n    return result\n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(intersperse(numbers: [] as [Int], delimeter: 7) == [] as [Int])\nassert(intersperse(numbers:\
    \ [5, 6, 3, 2], delimeter: 8) == [5, 8, 6, 8, 3, 8, 2])\nassert(intersperse(numbers:\
    \ [2, 2, 2], delimeter: 2) == [2, 2, 2, 2, 2])"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659978931
- exit_code: 0
  program: "\n/// Insert a number 'delimeter' between every two consecutive elements\
    \ of input array `numbers'\n/// >>> intersperse(numbers: [] as [Int], delimeter:\
    \ 4)\n/// [] as [Int]\n/// >>> intersperse(numbers: [1, 2, 3], delimeter: 4)\n\
    /// [1, 4, 2, 4, 3]\nfunc intersperse(numbers: [Int], delimeter: Int) -> [Int]\
    \ {\n    guard numbers.count > 1 else { return numbers }\n    var result = [Int]()\n\
    \    for i in 0..<numbers.count {\n        result.append(numbers[i])\n       \
    \ if i < numbers.count - 1 {\n            result.append(delimeter)\n        }\n\
    \    }\n    return result\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(intersperse(numbers:\
    \ [] as [Int], delimeter: 7) == [] as [Int])\nassert(intersperse(numbers: [5,\
    \ 6, 3, 2], delimeter: 8) == [5, 8, 6, 8, 3, 8, 2])\nassert(intersperse(numbers:\
    \ [2, 2, 2], delimeter: 2) == [2, 2, 2, 2, 2])"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659978933
- exit_code: 0
  program: "\n/// Insert a number 'delimeter' between every two consecutive elements\
    \ of input array `numbers'\n/// >>> intersperse(numbers: [] as [Int], delimeter:\
    \ 4)\n/// [] as [Int]\n/// >>> intersperse(numbers: [1, 2, 3], delimeter: 4)\n\
    /// [1, 4, 2, 4, 3]\nfunc intersperse(numbers: [Int], delimeter: Int) -> [Int]\
    \ {\n    //var newNumbers = [Int]()\n    //newNumbers.append(numbers[0])\n   \
    \ //\n    //for i in 1..<numbers.count {\n    //    newNumbers.append(delimeter)\n\
    \    //    newNumbers.append(numbers[i])\n    //}\n    //\n    //return newNumbers\n\
    \    \n    var newNumbers = [Int]()\n    \n    if numbers.count == 0 {\n     \
    \   return newNumbers\n    }\n    \n    newNumbers.append(numbers[0])\n    \n\
    \    for i in 1..<numbers.count {\n        newNumbers.append(delimeter)\n    \
    \    newNumbers.append(numbers[i])\n    }\n    \n    return newNumbers\n}\n\n\n\
    func ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(intersperse(numbers: [] as [Int], delimeter: 7)\
    \ == [] as [Int])\nassert(intersperse(numbers: [5, 6, 3, 2], delimeter: 8) ==\
    \ [5, 8, 6, 8, 3, 8, 2])\nassert(intersperse(numbers: [2, 2, 2], delimeter: 2)\
    \ == [2, 2, 2, 2, 2])"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659978933
- exit_code: 0
  program: "\n/// Insert a number 'delimeter' between every two consecutive elements\
    \ of input array `numbers'\n/// >>> intersperse(numbers: [] as [Int], delimeter:\
    \ 4)\n/// [] as [Int]\n/// >>> intersperse(numbers: [1, 2, 3], delimeter: 4)\n\
    /// [1, 4, 2, 4, 3]\nfunc intersperse(numbers: [Int], delimeter: Int) -> [Int]\
    \ {\n    if numbers.isEmpty {\n        return []\n    }\n    var result = [Int]()\n\
    \    for number in numbers {\n        result.append(number)\n        result.append(delimeter)\n\
    \    }\n    result.removeLast()\n    return result\n}\n\n\nfunc ==(left: [(Int,\
    \ Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n\
    \        return false\n    }\n    for (l, r) in zip(left, right) {\n        if\
    \ l != r {\n            return false\n        }\n    }\n    return true\n}\n \
    \           \nassert(intersperse(numbers: [] as [Int], delimeter: 7) == [] as\
    \ [Int])\nassert(intersperse(numbers: [5, 6, 3, 2], delimeter: 8) == [5, 8, 6,\
    \ 8, 3, 8, 2])\nassert(intersperse(numbers: [2, 2, 2], delimeter: 2) == [2, 2,\
    \ 2, 2, 2])"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659978931
- exit_code: 0
  program: "\n/// Insert a number 'delimeter' between every two consecutive elements\
    \ of input array `numbers'\n/// >>> intersperse(numbers: [] as [Int], delimeter:\
    \ 4)\n/// [] as [Int]\n/// >>> intersperse(numbers: [1, 2, 3], delimeter: 4)\n\
    /// [1, 4, 2, 4, 3]\nfunc intersperse(numbers: [Int], delimeter: Int) -> [Int]\
    \ {\n    if numbers.isEmpty {\n        return []\n    }\n    if numbers.count\
    \ == 1 {\n        return numbers\n    }\n    var result = [Int]()\n    var previous\
    \ = numbers[0]\n    result.append(previous)\n    for i in 1 ..< numbers.count\
    \ {\n        let number = numbers[i]\n        result.append(delimeter)\n     \
    \   result.append(number)\n        previous = number\n    }\n    return result\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(intersperse(numbers: [] as [Int], delimeter: 7)\
    \ == [] as [Int])\nassert(intersperse(numbers: [5, 6, 3, 2], delimeter: 8) ==\
    \ [5, 8, 6, 8, 3, 8, 2])\nassert(intersperse(numbers: [2, 2, 2], delimeter: 2)\
    \ == [2, 2, 2, 2, 2])"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659978933
- exit_code: -4
  program: "\n/// Insert a number 'delimeter' between every two consecutive elements\
    \ of input array `numbers'\n/// >>> intersperse(numbers: [] as [Int], delimeter:\
    \ 4)\n/// [] as [Int]\n/// >>> intersperse(numbers: [1, 2, 3], delimeter: 4)\n\
    /// [1, 4, 2, 4, 3]\nfunc intersperse(numbers: [Int], delimeter: Int) -> [Int]\
    \ {\n    var result: [Int] = []\n    for i in 0..<numbers.count - 1 {\n      \
    \  result.append(numbers[i])\n        result.append(delimeter)\n    }\n    result.append(numbers[numbers.count\
    \ - 1])\n    return result\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(intersperse(numbers:\
    \ [] as [Int], delimeter: 7) == [] as [Int])\nassert(intersperse(numbers: [5,\
    \ 6, 3, 2], delimeter: 8) == [5, 8, 6, 8, 3, 8, 2])\nassert(intersperse(numbers:\
    \ [2, 2, 2], delimeter: 2) == [2, 2, 2, 2, 2])"
  status: Exception
  stderr: 'Swift/Range.swift:743: Fatal error: Range requires lowerBound <= upperBound

    Current stack trace:

    0    libswiftCore.so                    0x00002ac9d4ad7c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002ac9d47ce561 <unavailable> + 1434977

    2    libswiftCore.so                    0x00002ac9d47ce286 <unavailable> + 1434246

    3    libswiftCore.so                    0x00002ac9d47ce13c <unavailable> + 1433916

    4    libswiftCore.so                    0x00002ac9d47cdbb0 _assertionFailure(_:_:file:line:flags:)
    + 251

    5    tmpf8oz2_9b                        0x000055aaca376a16 <unavailable> + 6678

    6    tmpf8oz2_9b                        0x000055aaca376552 <unavailable> + 5458

    7    libc.so.6                          0x00002ac9d4cc3460 __libc_start_main +
    245

    8    tmpf8oz2_9b                        0x000055aaca376259 <unavailable> + 4697

    '
  stdout: ''
  timestamp: 1659978932
- exit_code: 0
  program: "\n/// Insert a number 'delimeter' between every two consecutive elements\
    \ of input array `numbers'\n/// >>> intersperse(numbers: [] as [Int], delimeter:\
    \ 4)\n/// [] as [Int]\n/// >>> intersperse(numbers: [1, 2, 3], delimeter: 4)\n\
    /// [1, 4, 2, 4, 3]\nfunc intersperse(numbers: [Int], delimeter: Int) -> [Int]\
    \ {\n    return numbers.reduce([], { (result, elem) in\n        if result.isEmpty\
    \ {\n            return [elem]\n        } else {\n            return result +\
    \ [delimeter] + [elem]\n        }\n    })\n}\n\n\nfunc ==(left: [(Int, Int)],\
    \ right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n       \
    \ return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r\
    \ {\n            return false\n        }\n    }\n    return true\n}\n        \
    \    \nassert(intersperse(numbers: [] as [Int], delimeter: 7) == [] as [Int])\n\
    assert(intersperse(numbers: [5, 6, 3, 2], delimeter: 8) == [5, 8, 6, 8, 3, 8,\
    \ 2])\nassert(intersperse(numbers: [2, 2, 2], delimeter: 2) == [2, 2, 2, 2, 2])"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659978933
- exit_code: 0
  program: "\n/// Insert a number 'delimeter' between every two consecutive elements\
    \ of input array `numbers'\n/// >>> intersperse(numbers: [] as [Int], delimeter:\
    \ 4)\n/// [] as [Int]\n/// >>> intersperse(numbers: [1, 2, 3], delimeter: 4)\n\
    /// [1, 4, 2, 4, 3]\nfunc intersperse(numbers: [Int], delimeter: Int) -> [Int]\
    \ {\n    var result: [Int] = []\n    for i in 0..<numbers.count {\n        result.append(numbers[i])\n\
    \        if i < numbers.count - 1 {\n            result.append(delimeter)\n  \
    \      }\n    }\n    return result\n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(intersperse(numbers: [] as [Int], delimeter: 7) == [] as [Int])\nassert(intersperse(numbers:\
    \ [5, 6, 3, 2], delimeter: 8) == [5, 8, 6, 8, 3, 8, 2])\nassert(intersperse(numbers:\
    \ [2, 2, 2], delimeter: 2) == [2, 2, 2, 2, 2])"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659978932
- exit_code: 0
  program: "\n/// Insert a number 'delimeter' between every two consecutive elements\
    \ of input array `numbers'\n/// >>> intersperse(numbers: [] as [Int], delimeter:\
    \ 4)\n/// [] as [Int]\n/// >>> intersperse(numbers: [1, 2, 3], delimeter: 4)\n\
    /// [1, 4, 2, 4, 3]\nfunc intersperse(numbers: [Int], delimeter: Int) -> [Int]\
    \ {\n\tguard !numbers.isEmpty else { return [] }\n\tvar result = [Int]()\n\tfor\
    \ number in numbers {\n\t\tresult.append(number)\n\t\tresult.append(delimeter)\n\
    \t}\n\tresult.removeLast()\n\treturn result\n}\n\n\nfunc ==(left: [(Int, Int)],\
    \ right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n       \
    \ return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r\
    \ {\n            return false\n        }\n    }\n    return true\n}\n        \
    \    \nassert(intersperse(numbers: [] as [Int], delimeter: 7) == [] as [Int])\n\
    assert(intersperse(numbers: [5, 6, 3, 2], delimeter: 8) == [5, 8, 6, 8, 3, 8,\
    \ 2])\nassert(intersperse(numbers: [2, 2, 2], delimeter: 2) == [2, 2, 2, 2, 2])"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659978933
- exit_code: 0
  program: "\n/// Insert a number 'delimeter' between every two consecutive elements\
    \ of input array `numbers'\n/// >>> intersperse(numbers: [] as [Int], delimeter:\
    \ 4)\n/// [] as [Int]\n/// >>> intersperse(numbers: [1, 2, 3], delimeter: 4)\n\
    /// [1, 4, 2, 4, 3]\nfunc intersperse(numbers: [Int], delimeter: Int) -> [Int]\
    \ {\n    var result: [Int] = []\n    for i in 0 ..< numbers.count {\n        result.append(numbers[i])\n\
    \        if i < numbers.count - 1 {\n            result.append(delimeter)\n  \
    \      }\n    }\n    return result\n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(intersperse(numbers: [] as [Int], delimeter: 7) == [] as [Int])\nassert(intersperse(numbers:\
    \ [5, 6, 3, 2], delimeter: 8) == [5, 8, 6, 8, 3, 8, 2])\nassert(intersperse(numbers:\
    \ [2, 2, 2], delimeter: 2) == [2, 2, 2, 2, 2])"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659978933
- exit_code: 0
  program: "\n/// Insert a number 'delimeter' between every two consecutive elements\
    \ of input array `numbers'\n/// >>> intersperse(numbers: [] as [Int], delimeter:\
    \ 4)\n/// [] as [Int]\n/// >>> intersperse(numbers: [1, 2, 3], delimeter: 4)\n\
    /// [1, 4, 2, 4, 3]\nfunc intersperse(numbers: [Int], delimeter: Int) -> [Int]\
    \ {\n    guard numbers.count > 1 else { return numbers }\n    var result = [Int]()\n\
    \    for i in 0..<numbers.count {\n        result.append(numbers[i])\n       \
    \ if i < numbers.count - 1 {\n            result.append(delimeter)\n        }\n\
    \    }\n    return result\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(intersperse(numbers:\
    \ [] as [Int], delimeter: 7) == [] as [Int])\nassert(intersperse(numbers: [5,\
    \ 6, 3, 2], delimeter: 8) == [5, 8, 6, 8, 3, 8, 2])\nassert(intersperse(numbers:\
    \ [2, 2, 2], delimeter: 2) == [2, 2, 2, 2, 2])"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659978933
- exit_code: -4
  program: "\n/// Insert a number 'delimeter' between every two consecutive elements\
    \ of input array `numbers'\n/// >>> intersperse(numbers: [] as [Int], delimeter:\
    \ 4)\n/// [] as [Int]\n/// >>> intersperse(numbers: [1, 2, 3], delimeter: 4)\n\
    /// [1, 4, 2, 4, 3]\nfunc intersperse(numbers: [Int], delimeter: Int) -> [Int]\
    \ {\n    var result: [Int] = []\n    for num in numbers {\n        result.append(num)\n\
    \        result.append(delimeter)\n    }\n    result.removeLast()\n    return\
    \ result\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n\
    \    if left.count != right.count {\n        return false\n    }\n    for (l,\
    \ r) in zip(left, right) {\n        if l != r {\n            return false\n  \
    \      }\n    }\n    return true\n}\n            \nassert(intersperse(numbers:\
    \ [] as [Int], delimeter: 7) == [] as [Int])\nassert(intersperse(numbers: [5,\
    \ 6, 3, 2], delimeter: 8) == [5, 8, 6, 8, 3, 8, 2])\nassert(intersperse(numbers:\
    \ [2, 2, 2], delimeter: 2) == [2, 2, 2, 2, 2])"
  status: Exception
  stderr: 'Swift/RangeReplaceableCollection.swift:870: Fatal error: Can''t remove
    last element from an empty collection

    Current stack trace:

    0    libswiftCore.so                    0x00002ae7a6abbc80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002ae7a67b2561 <unavailable> + 1434977

    2    libswiftCore.so                    0x00002ae7a67b2286 <unavailable> + 1434246

    3    libswiftCore.so                    0x00002ae7a67b213c <unavailable> + 1433916

    4    libswiftCore.so                    0x00002ae7a67b1bb0 _assertionFailure(_:_:file:line:flags:)
    + 251

    5    libswiftCore.so                    0x00002ae7a68b3c1d <unavailable> + 2489373

    6    tmpw4jy0x_x                        0x000055b721caea72 <unavailable> + 6770

    7    tmpw4jy0x_x                        0x000055b721cae572 <unavailable> + 5490

    8    libc.so.6                          0x00002ae7a6ca7460 __libc_start_main +
    245

    9    tmpw4jy0x_x                        0x000055b721cae279 <unavailable> + 4729

    '
  stdout: ''
  timestamp: 1659978933
- exit_code: -4
  program: "\n/// Insert a number 'delimeter' between every two consecutive elements\
    \ of input array `numbers'\n/// >>> intersperse(numbers: [] as [Int], delimeter:\
    \ 4)\n/// [] as [Int]\n/// >>> intersperse(numbers: [1, 2, 3], delimeter: 4)\n\
    /// [1, 4, 2, 4, 3]\nfunc intersperse(numbers: [Int], delimeter: Int) -> [Int]\
    \ {\n    if numbers.isEmpty {\n        return []\n    }\n    if numbers.count\
    \ == 1 {\n        return numbers\n    }\n    var result = numbers\n    for _ in\
    \ 0...numbers.count-2 {\n        result.insert(delimeter, at: 2)\n    }\n    return\
    \ result\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n\
    \    if left.count != right.count {\n        return false\n    }\n    for (l,\
    \ r) in zip(left, right) {\n        if l != r {\n            return false\n  \
    \      }\n    }\n    return true\n}\n            \nassert(intersperse(numbers:\
    \ [] as [Int], delimeter: 7) == [] as [Int])\nassert(intersperse(numbers: [5,\
    \ 6, 3, 2], delimeter: 8) == [5, 8, 6, 8, 3, 8, 2])\nassert(intersperse(numbers:\
    \ [2, 2, 2], delimeter: 2) == [2, 2, 2, 2, 2])"
  status: Exception
  stderr: 'tmpnrr59ju2/tmpnrr59ju2.swift:35: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b0ab84dec80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b0ab81d5b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b0ab81d5988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b0ab81d47b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpnrr59ju2                        0x000055d34090379f <unavailable> + 6047

    5    libc.so.6                          0x00002b0ab86ca460 __libc_start_main +
    245

    6    tmpnrr59ju2                        0x000055d340903299 <unavailable> + 4761

    '
  stdout: ''
  timestamp: 1659978933
- exit_code: -4
  program: "\n/// Insert a number 'delimeter' between every two consecutive elements\
    \ of input array `numbers'\n/// >>> intersperse(numbers: [] as [Int], delimeter:\
    \ 4)\n/// [] as [Int]\n/// >>> intersperse(numbers: [1, 2, 3], delimeter: 4)\n\
    /// [1, 4, 2, 4, 3]\nfunc intersperse(numbers: [Int], delimeter: Int) -> [Int]\
    \ {\n\tvar result = [Int]()\n\tfor i in 0 ..< numbers.count - 1 {\n\t\tresult.append(numbers[i])\n\
    \t\tresult.append(delimeter)\n\t}\n\tresult.append(numbers[numbers.count - 1])\n\
    \treturn result\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool\
    \ {\n    if left.count != right.count {\n        return false\n    }\n    for\
    \ (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(intersperse(numbers:\
    \ [] as [Int], delimeter: 7) == [] as [Int])\nassert(intersperse(numbers: [5,\
    \ 6, 3, 2], delimeter: 8) == [5, 8, 6, 8, 3, 8, 2])\nassert(intersperse(numbers:\
    \ [2, 2, 2], delimeter: 2) == [2, 2, 2, 2, 2])"
  status: Exception
  stderr: 'Swift/Range.swift:743: Fatal error: Range requires lowerBound <= upperBound

    Current stack trace:

    0    libswiftCore.so                    0x00002acf25ed2c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002acf25bc9561 <unavailable> + 1434977

    2    libswiftCore.so                    0x00002acf25bc9286 <unavailable> + 1434246

    3    libswiftCore.so                    0x00002acf25bc913c <unavailable> + 1433916

    4    libswiftCore.so                    0x00002acf25bc8bb0 _assertionFailure(_:_:file:line:flags:)
    + 251

    5    tmpwo5gvmyd                        0x000055b0e385da6b <unavailable> + 6763

    6    tmpwo5gvmyd                        0x000055b0e385d5b2 <unavailable> + 5554

    7    libc.so.6                          0x00002acf260be460 __libc_start_main +
    245

    8    tmpwo5gvmyd                        0x000055b0e385d2b9 <unavailable> + 4793

    '
  stdout: ''
  timestamp: 1659978933
- exit_code: 0
  program: "\n/// Insert a number 'delimeter' between every two consecutive elements\
    \ of input array `numbers'\n/// >>> intersperse(numbers: [] as [Int], delimeter:\
    \ 4)\n/// [] as [Int]\n/// >>> intersperse(numbers: [1, 2, 3], delimeter: 4)\n\
    /// [1, 4, 2, 4, 3]\nfunc intersperse(numbers: [Int], delimeter: Int) -> [Int]\
    \ {\n    if numbers.isEmpty {\n        return []\n    } else {\n        var newNumbers\
    \ = [Int]()\n        for i in 0..<numbers.count - 1 {\n            newNumbers.append(numbers[i])\n\
    \            newNumbers.append(delimeter)\n        }\n        newNumbers.append(numbers[numbers.count\
    \ - 1])\n        return newNumbers\n    }\n}\n\n\nfunc ==(left: [(Int, Int)],\
    \ right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n       \
    \ return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r\
    \ {\n            return false\n        }\n    }\n    return true\n}\n        \
    \    \nassert(intersperse(numbers: [] as [Int], delimeter: 7) == [] as [Int])\n\
    assert(intersperse(numbers: [5, 6, 3, 2], delimeter: 8) == [5, 8, 6, 8, 3, 8,\
    \ 2])\nassert(intersperse(numbers: [2, 2, 2], delimeter: 2) == [2, 2, 2, 2, 2])"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659978933
- exit_code: 0
  program: "\n/// Insert a number 'delimeter' between every two consecutive elements\
    \ of input array `numbers'\n/// >>> intersperse(numbers: [] as [Int], delimeter:\
    \ 4)\n/// [] as [Int]\n/// >>> intersperse(numbers: [1, 2, 3], delimeter: 4)\n\
    /// [1, 4, 2, 4, 3]\nfunc intersperse(numbers: [Int], delimeter: Int) -> [Int]\
    \ {\n    var result: [Int] = []\n    for (i, number) in numbers.enumerated() {\n\
    \        result.append(number)\n        if i < numbers.count - 1 {\n         \
    \   result.append(delimeter)\n        }\n    }\n    return result\n}\n\n\nfunc\
    \ ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count !=\
    \ right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(intersperse(numbers: [] as [Int], delimeter: 7)\
    \ == [] as [Int])\nassert(intersperse(numbers: [5, 6, 3, 2], delimeter: 8) ==\
    \ [5, 8, 6, 8, 3, 8, 2])\nassert(intersperse(numbers: [2, 2, 2], delimeter: 2)\
    \ == [2, 2, 2, 2, 2])"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659978933
- exit_code: 0
  program: "\n/// Insert a number 'delimeter' between every two consecutive elements\
    \ of input array `numbers'\n/// >>> intersperse(numbers: [] as [Int], delimeter:\
    \ 4)\n/// [] as [Int]\n/// >>> intersperse(numbers: [1, 2, 3], delimeter: 4)\n\
    /// [1, 4, 2, 4, 3]\nfunc intersperse(numbers: [Int], delimeter: Int) -> [Int]\
    \ {\n    if numbers.isEmpty {\n        return []\n    } else {\n        var result\
    \ = [Int]()\n        for i in 0..<numbers.count {\n            result.append(numbers[i])\n\
    \            if i < numbers.count - 1 {\n                result.append(delimeter)\n\
    \            }\n        }\n        return result\n    }\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(intersperse(numbers: [] as [Int], delimeter: 7) == []\
    \ as [Int])\nassert(intersperse(numbers: [5, 6, 3, 2], delimeter: 8) == [5, 8,\
    \ 6, 8, 3, 8, 2])\nassert(intersperse(numbers: [2, 2, 2], delimeter: 2) == [2,\
    \ 2, 2, 2, 2])"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659978933
- exit_code: 0
  program: "\n/// Insert a number 'delimeter' between every two consecutive elements\
    \ of input array `numbers'\n/// >>> intersperse(numbers: [] as [Int], delimeter:\
    \ 4)\n/// [] as [Int]\n/// >>> intersperse(numbers: [1, 2, 3], delimeter: 4)\n\
    /// [1, 4, 2, 4, 3]\nfunc intersperse(numbers: [Int], delimeter: Int) -> [Int]\
    \ {\n    var result: [Int] = []\n    var count = numbers.count\n    for number\
    \ in numbers {\n        count -= 1\n        result.append(number)\n        if\
    \ count > 0 {\n            result.append(delimeter)\n        }\n    }\n    return\
    \ result\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n\
    \    if left.count != right.count {\n        return false\n    }\n    for (l,\
    \ r) in zip(left, right) {\n        if l != r {\n            return false\n  \
    \      }\n    }\n    return true\n}\n            \nassert(intersperse(numbers:\
    \ [] as [Int], delimeter: 7) == [] as [Int])\nassert(intersperse(numbers: [5,\
    \ 6, 3, 2], delimeter: 8) == [5, 8, 6, 8, 3, 8, 2])\nassert(intersperse(numbers:\
    \ [2, 2, 2], delimeter: 2) == [2, 2, 2, 2, 2])"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659978933
- exit_code: 0
  program: "\n/// Insert a number 'delimeter' between every two consecutive elements\
    \ of input array `numbers'\n/// >>> intersperse(numbers: [] as [Int], delimeter:\
    \ 4)\n/// [] as [Int]\n/// >>> intersperse(numbers: [1, 2, 3], delimeter: 4)\n\
    /// [1, 4, 2, 4, 3]\nfunc intersperse(numbers: [Int], delimeter: Int) -> [Int]\
    \ {\n    if numbers.isEmpty {\n        return []\n    } else {\n        var output:\
    \ [Int] = []\n        for number in numbers {\n            output.append(number)\n\
    \            output.append(delimeter)\n        }\n        output.removeLast()\n\
    \        return output\n    }\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int,\
    \ Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n\
    \    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n          \
    \  return false\n        }\n    }\n    return true\n}\n            \nassert(intersperse(numbers:\
    \ [] as [Int], delimeter: 7) == [] as [Int])\nassert(intersperse(numbers: [5,\
    \ 6, 3, 2], delimeter: 8) == [5, 8, 6, 8, 3, 8, 2])\nassert(intersperse(numbers:\
    \ [2, 2, 2], delimeter: 2) == [2, 2, 2, 2, 2])"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659978933
- exit_code: 0
  program: "\n/// Insert a number 'delimeter' between every two consecutive elements\
    \ of input array `numbers'\n/// >>> intersperse(numbers: [] as [Int], delimeter:\
    \ 4)\n/// [] as [Int]\n/// >>> intersperse(numbers: [1, 2, 3], delimeter: 4)\n\
    /// [1, 4, 2, 4, 3]\nfunc intersperse(numbers: [Int], delimeter: Int) -> [Int]\
    \ {\n    let count = numbers.count\n    if count <= 1 {\n        return numbers\n\
    \    }\n    var result = [Int]()\n    for i in 0..<count {\n        if i > 0 {\n\
    \            result.append(delimeter)\n        }\n        result.append(numbers[i])\n\
    \    }\n    return result\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(intersperse(numbers:\
    \ [] as [Int], delimeter: 7) == [] as [Int])\nassert(intersperse(numbers: [5,\
    \ 6, 3, 2], delimeter: 8) == [5, 8, 6, 8, 3, 8, 2])\nassert(intersperse(numbers:\
    \ [2, 2, 2], delimeter: 2) == [2, 2, 2, 2, 2])"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659978933
- exit_code: 0
  program: "\n/// Insert a number 'delimeter' between every two consecutive elements\
    \ of input array `numbers'\n/// >>> intersperse(numbers: [] as [Int], delimeter:\
    \ 4)\n/// [] as [Int]\n/// >>> intersperse(numbers: [1, 2, 3], delimeter: 4)\n\
    /// [1, 4, 2, 4, 3]\nfunc intersperse(numbers: [Int], delimeter: Int) -> [Int]\
    \ {\n    var result: [Int] = []\n    for (i, number) in numbers.enumerated() {\n\
    \        result.append(number)\n        if i != numbers.count - 1 {\n        \
    \    result.append(delimeter)\n        }\n    }\n    return result\n}\n\n\nfunc\
    \ ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count !=\
    \ right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(intersperse(numbers: [] as [Int], delimeter: 7)\
    \ == [] as [Int])\nassert(intersperse(numbers: [5, 6, 3, 2], delimeter: 8) ==\
    \ [5, 8, 6, 8, 3, 8, 2])\nassert(intersperse(numbers: [2, 2, 2], delimeter: 2)\
    \ == [2, 2, 2, 2, 2])"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659978933
- exit_code: 0
  program: "\n/// Insert a number 'delimeter' between every two consecutive elements\
    \ of input array `numbers'\n/// >>> intersperse(numbers: [] as [Int], delimeter:\
    \ 4)\n/// [] as [Int]\n/// >>> intersperse(numbers: [1, 2, 3], delimeter: 4)\n\
    /// [1, 4, 2, 4, 3]\nfunc intersperse(numbers: [Int], delimeter: Int) -> [Int]\
    \ {\n    if numbers.isEmpty {\n        return []\n    } else {\n        var result\
    \ = [Int]()\n        var i = 0\n        for _ in numbers {\n            result.append(numbers[i])\n\
    \            result.append(delimeter)\n            i += 1\n        }\n       \
    \ result.removeLast()\n        return result\n    }\n}\n\n\nfunc ==(left: [(Int,\
    \ Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n\
    \        return false\n    }\n    for (l, r) in zip(left, right) {\n        if\
    \ l != r {\n            return false\n        }\n    }\n    return true\n}\n \
    \           \nassert(intersperse(numbers: [] as [Int], delimeter: 7) == [] as\
    \ [Int])\nassert(intersperse(numbers: [5, 6, 3, 2], delimeter: 8) == [5, 8, 6,\
    \ 8, 3, 8, 2])\nassert(intersperse(numbers: [2, 2, 2], delimeter: 2) == [2, 2,\
    \ 2, 2, 2])"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659978933
- exit_code: 0
  program: "\n/// Insert a number 'delimeter' between every two consecutive elements\
    \ of input array `numbers'\n/// >>> intersperse(numbers: [] as [Int], delimeter:\
    \ 4)\n/// [] as [Int]\n/// >>> intersperse(numbers: [1, 2, 3], delimeter: 4)\n\
    /// [1, 4, 2, 4, 3]\nfunc intersperse(numbers: [Int], delimeter: Int) -> [Int]\
    \ {\n    var newArray = [Int]()\n    if numbers.count == 0 {\n        return newArray\n\
    \    }\n    if numbers.count == 1 {\n        newArray.append(numbers[0])\n   \
    \     return newArray\n    }\n    for i in 0..<numbers.count {\n        if i ==\
    \ numbers.count - 1 {\n            newArray.append(numbers[i])\n        } else\
    \ {\n            newArray.append(numbers[i])\n            newArray.append(delimeter)\n\
    \        }\n    }\n    return newArray\n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(intersperse(numbers: [] as [Int], delimeter: 7) == [] as [Int])\nassert(intersperse(numbers:\
    \ [5, 6, 3, 2], delimeter: 8) == [5, 8, 6, 8, 3, 8, 2])\nassert(intersperse(numbers:\
    \ [2, 2, 2], delimeter: 2) == [2, 2, 2, 2, 2])"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659978933
- exit_code: 0
  program: "\n/// Insert a number 'delimeter' between every two consecutive elements\
    \ of input array `numbers'\n/// >>> intersperse(numbers: [] as [Int], delimeter:\
    \ 4)\n/// [] as [Int]\n/// >>> intersperse(numbers: [1, 2, 3], delimeter: 4)\n\
    /// [1, 4, 2, 4, 3]\nfunc intersperse(numbers: [Int], delimeter: Int) -> [Int]\
    \ {\n    var result: [Int] = []\n    for i in 0 ..< numbers.count {\n        result.append(numbers[i])\n\
    \        if i < numbers.count - 1 {\n            result.append(delimeter)\n  \
    \      }\n    }\n    return result\n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(intersperse(numbers: [] as [Int], delimeter: 7) == [] as [Int])\nassert(intersperse(numbers:\
    \ [5, 6, 3, 2], delimeter: 8) == [5, 8, 6, 8, 3, 8, 2])\nassert(intersperse(numbers:\
    \ [2, 2, 2], delimeter: 2) == [2, 2, 2, 2, 2])"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659978933
- exit_code: 0
  program: "\n/// Insert a number 'delimeter' between every two consecutive elements\
    \ of input array `numbers'\n/// >>> intersperse(numbers: [] as [Int], delimeter:\
    \ 4)\n/// [] as [Int]\n/// >>> intersperse(numbers: [1, 2, 3], delimeter: 4)\n\
    /// [1, 4, 2, 4, 3]\nfunc intersperse(numbers: [Int], delimeter: Int) -> [Int]\
    \ {\n  if numbers.isEmpty {\n    return []\n  } else if numbers.count == 1 {\n\
    \    return numbers\n  } else {\n    var tmp = [Int]()\n    for i in 0..<numbers.count\
    \ - 1 {\n      tmp.append(numbers[i])\n      tmp.append(delimeter)\n    }\n  \
    \  tmp.append(numbers[numbers.count - 1])\n    return tmp\n  }\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(intersperse(numbers: [] as [Int], delimeter: 7) == []\
    \ as [Int])\nassert(intersperse(numbers: [5, 6, 3, 2], delimeter: 8) == [5, 8,\
    \ 6, 8, 3, 8, 2])\nassert(intersperse(numbers: [2, 2, 2], delimeter: 2) == [2,\
    \ 2, 2, 2, 2])"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659978933
- exit_code: -4
  program: "\n/// Insert a number 'delimeter' between every two consecutive elements\
    \ of input array `numbers'\n/// >>> intersperse(numbers: [] as [Int], delimeter:\
    \ 4)\n/// [] as [Int]\n/// >>> intersperse(numbers: [1, 2, 3], delimeter: 4)\n\
    /// [1, 4, 2, 4, 3]\nfunc intersperse(numbers: [Int], delimeter: Int) -> [Int]\
    \ {\n    return []\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) ->\
    \ Bool {\n    if left.count != right.count {\n        return false\n    }\n  \
    \  for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(intersperse(numbers:\
    \ [] as [Int], delimeter: 7) == [] as [Int])\nassert(intersperse(numbers: [5,\
    \ 6, 3, 2], delimeter: 8) == [5, 8, 6, 8, 3, 8, 2])\nassert(intersperse(numbers:\
    \ [2, 2, 2], delimeter: 2) == [2, 2, 2, 2, 2])"
  status: Exception
  stderr: 'tmp0sr70v0j/tmp0sr70v0j.swift:25: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b5f1c432c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b5f1c129b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b5f1c129988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b5f1c1287b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmp0sr70v0j                        0x000055f4032774cf <unavailable> + 5327

    5    libc.so.6                          0x00002b5f1c61e460 __libc_start_main +
    245

    6    tmp0sr70v0j                        0x000055f403276fc9 <unavailable> + 4041

    '
  stdout: ''
  timestamp: 1659978932
- exit_code: -4
  program: "\n/// Insert a number 'delimeter' between every two consecutive elements\
    \ of input array `numbers'\n/// >>> intersperse(numbers: [] as [Int], delimeter:\
    \ 4)\n/// [] as [Int]\n/// >>> intersperse(numbers: [1, 2, 3], delimeter: 4)\n\
    /// [1, 4, 2, 4, 3]\nfunc intersperse(numbers: [Int], delimeter: Int) -> [Int]\
    \ {\n    var numbers = numbers\n    for i in 0..<numbers.count - 1 {\n       \
    \ numbers.insert(delimeter, at: i * 2 + 1)\n    }\n    return numbers\n}\n\n\n\
    func ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(intersperse(numbers: [] as [Int], delimeter: 7)\
    \ == [] as [Int])\nassert(intersperse(numbers: [5, 6, 3, 2], delimeter: 8) ==\
    \ [5, 8, 6, 8, 3, 8, 2])\nassert(intersperse(numbers: [2, 2, 2], delimeter: 2)\
    \ == [2, 2, 2, 2, 2])"
  status: Exception
  stderr: 'Swift/Range.swift:743: Fatal error: Range requires lowerBound <= upperBound

    Current stack trace:

    0    libswiftCore.so                    0x00002b43859e4c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b43856db561 <unavailable> + 1434977

    2    libswiftCore.so                    0x00002b43856db286 <unavailable> + 1434246

    3    libswiftCore.so                    0x00002b43856db13c <unavailable> + 1433916

    4    libswiftCore.so                    0x00002b43856dabb0 _assertionFailure(_:_:file:line:flags:)
    + 251

    5    tmpqmiqvmfl                        0x000056276abf59c3 <unavailable> + 6595

    6    tmpqmiqvmfl                        0x000056276abf5502 <unavailable> + 5378

    7    libc.so.6                          0x00002b4385bd0460 __libc_start_main +
    245

    8    tmpqmiqvmfl                        0x000056276abf5209 <unavailable> + 4617

    '
  stdout: ''
  timestamp: 1659978933
- exit_code: 0
  program: "\n/// Insert a number 'delimeter' between every two consecutive elements\
    \ of input array `numbers'\n/// >>> intersperse(numbers: [] as [Int], delimeter:\
    \ 4)\n/// [] as [Int]\n/// >>> intersperse(numbers: [1, 2, 3], delimeter: 4)\n\
    /// [1, 4, 2, 4, 3]\nfunc intersperse(numbers: [Int], delimeter: Int) -> [Int]\
    \ {\n\treturn numbers.enumerated().reduce([]) { acc, tuple in\n\t\tif tuple.offset\
    \ > 0 {\n\t\t\treturn acc + [delimeter] + [tuple.element]\n\t\t} else {\n\t\t\t\
    return acc + [tuple.element]\n\t\t}\n\t}\n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(intersperse(numbers: [] as [Int], delimeter: 7) == [] as [Int])\nassert(intersperse(numbers:\
    \ [5, 6, 3, 2], delimeter: 8) == [5, 8, 6, 8, 3, 8, 2])\nassert(intersperse(numbers:\
    \ [2, 2, 2], delimeter: 2) == [2, 2, 2, 2, 2])"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659978933
- exit_code: 0
  program: "\n/// Insert a number 'delimeter' between every two consecutive elements\
    \ of input array `numbers'\n/// >>> intersperse(numbers: [] as [Int], delimeter:\
    \ 4)\n/// [] as [Int]\n/// >>> intersperse(numbers: [1, 2, 3], delimeter: 4)\n\
    /// [1, 4, 2, 4, 3]\nfunc intersperse(numbers: [Int], delimeter: Int) -> [Int]\
    \ {\n    var result: [Int] = []\n    var prev_num: Int? = nil\n    for i in numbers\
    \ {\n        if let prev_num = prev_num {\n            result.append(prev_num)\n\
    \            result.append(delimeter)\n        }\n        prev_num = i\n    }\n\
    \    if let prev_num = prev_num {\n        result.append(prev_num)\n    }\n  \
    \  return result\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool\
    \ {\n    if left.count != right.count {\n        return false\n    }\n    for\
    \ (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(intersperse(numbers:\
    \ [] as [Int], delimeter: 7) == [] as [Int])\nassert(intersperse(numbers: [5,\
    \ 6, 3, 2], delimeter: 8) == [5, 8, 6, 8, 3, 8, 2])\nassert(intersperse(numbers:\
    \ [2, 2, 2], delimeter: 2) == [2, 2, 2, 2, 2])"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659978933
- exit_code: 0
  program: "\n/// Insert a number 'delimeter' between every two consecutive elements\
    \ of input array `numbers'\n/// >>> intersperse(numbers: [] as [Int], delimeter:\
    \ 4)\n/// [] as [Int]\n/// >>> intersperse(numbers: [1, 2, 3], delimeter: 4)\n\
    /// [1, 4, 2, 4, 3]\nfunc intersperse(numbers: [Int], delimeter: Int) -> [Int]\
    \ {\n    if numbers.isEmpty {\n        return []\n    } else {\n        var result\
    \ = [Int]()\n        for (index, element) in numbers.enumerated() {\n        \
    \    result.append(element)\n            if index < numbers.count - 1 {\n    \
    \            result.append(delimeter)\n            }\n        }\n        return\
    \ result\n    }\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool\
    \ {\n    if left.count != right.count {\n        return false\n    }\n    for\
    \ (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(intersperse(numbers:\
    \ [] as [Int], delimeter: 7) == [] as [Int])\nassert(intersperse(numbers: [5,\
    \ 6, 3, 2], delimeter: 8) == [5, 8, 6, 8, 3, 8, 2])\nassert(intersperse(numbers:\
    \ [2, 2, 2], delimeter: 2) == [2, 2, 2, 2, 2])"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659978933
- exit_code: 0
  program: "\n/// Insert a number 'delimeter' between every two consecutive elements\
    \ of input array `numbers'\n/// >>> intersperse(numbers: [] as [Int], delimeter:\
    \ 4)\n/// [] as [Int]\n/// >>> intersperse(numbers: [1, 2, 3], delimeter: 4)\n\
    /// [1, 4, 2, 4, 3]\nfunc intersperse(numbers: [Int], delimeter: Int) -> [Int]\
    \ {\n    if numbers.isEmpty {\n        return []\n    }\n    var result = [Int]()\n\
    \    for i in 0 ..< numbers.count - 1 {\n        result.append(numbers[i])\n \
    \       result.append(delimeter)\n    }\n    result.append(numbers[numbers.count\
    \ - 1])\n    return result\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(intersperse(numbers:\
    \ [] as [Int], delimeter: 7) == [] as [Int])\nassert(intersperse(numbers: [5,\
    \ 6, 3, 2], delimeter: 8) == [5, 8, 6, 8, 3, 8, 2])\nassert(intersperse(numbers:\
    \ [2, 2, 2], delimeter: 2) == [2, 2, 2, 2, 2])"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659978933
- exit_code: 0
  program: "\n/// Insert a number 'delimeter' between every two consecutive elements\
    \ of input array `numbers'\n/// >>> intersperse(numbers: [] as [Int], delimeter:\
    \ 4)\n/// [] as [Int]\n/// >>> intersperse(numbers: [1, 2, 3], delimeter: 4)\n\
    /// [1, 4, 2, 4, 3]\nfunc intersperse(numbers: [Int], delimeter: Int) -> [Int]\
    \ {\n    if numbers.isEmpty {\n        return []\n    }\n    if numbers.count\
    \ == 1 {\n        return numbers\n    }\n    var result = [Int]()\n    result.append(numbers[0])\n\
    \    for i in 1..<numbers.count {\n        result.append(delimeter)\n        result.append(numbers[i])\n\
    \    }\n    return result\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(intersperse(numbers:\
    \ [] as [Int], delimeter: 7) == [] as [Int])\nassert(intersperse(numbers: [5,\
    \ 6, 3, 2], delimeter: 8) == [5, 8, 6, 8, 3, 8, 2])\nassert(intersperse(numbers:\
    \ [2, 2, 2], delimeter: 2) == [2, 2, 2, 2, 2])"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659978932
- exit_code: 0
  program: "\n/// Insert a number 'delimeter' between every two consecutive elements\
    \ of input array `numbers'\n/// >>> intersperse(numbers: [] as [Int], delimeter:\
    \ 4)\n/// [] as [Int]\n/// >>> intersperse(numbers: [1, 2, 3], delimeter: 4)\n\
    /// [1, 4, 2, 4, 3]\nfunc intersperse(numbers: [Int], delimeter: Int) -> [Int]\
    \ {\n    var result: [Int] = []\n    for number in numbers {\n        result.append(number)\n\
    \        result.append(delimeter)\n    }\n    if result.count > 0 {\n        result.removeLast()\n\
    \    }\n    return result\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(intersperse(numbers:\
    \ [] as [Int], delimeter: 7) == [] as [Int])\nassert(intersperse(numbers: [5,\
    \ 6, 3, 2], delimeter: 8) == [5, 8, 6, 8, 3, 8, 2])\nassert(intersperse(numbers:\
    \ [2, 2, 2], delimeter: 2) == [2, 2, 2, 2, 2])"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659978933
- exit_code: 0
  program: "\n/// Insert a number 'delimeter' between every two consecutive elements\
    \ of input array `numbers'\n/// >>> intersperse(numbers: [] as [Int], delimeter:\
    \ 4)\n/// [] as [Int]\n/// >>> intersperse(numbers: [1, 2, 3], delimeter: 4)\n\
    /// [1, 4, 2, 4, 3]\nfunc intersperse(numbers: [Int], delimeter: Int) -> [Int]\
    \ {\n    var result: [Int] = []\n    if numbers.count > 0 {\n        result.append(numbers[0])\n\
    \        for i in 1..<numbers.count {\n            result.append(delimeter)\n\
    \            result.append(numbers[i])\n        }\n    }\n    return result\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(intersperse(numbers: [] as [Int], delimeter: 7)\
    \ == [] as [Int])\nassert(intersperse(numbers: [5, 6, 3, 2], delimeter: 8) ==\
    \ [5, 8, 6, 8, 3, 8, 2])\nassert(intersperse(numbers: [2, 2, 2], delimeter: 2)\
    \ == [2, 2, 2, 2, 2])"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659978933
- exit_code: -4
  program: "\n/// Insert a number 'delimeter' between every two consecutive elements\
    \ of input array `numbers'\n/// >>> intersperse(numbers: [] as [Int], delimeter:\
    \ 4)\n/// [] as [Int]\n/// >>> intersperse(numbers: [1, 2, 3], delimeter: 4)\n\
    /// [1, 4, 2, 4, 3]\nfunc intersperse(numbers: [Int], delimeter: Int) -> [Int]\
    \ {\n    var ints: [Int] = []\n    for i in 0 ..< numbers.count - 1 {\n      \
    \  ints.append(numbers[i])\n        ints.append(delimeter)\n    }\n    if numbers.count\
    \ > 0 {\n        ints.append(numbers[numbers.count - 1])\n    }\n    return ints\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(intersperse(numbers: [] as [Int], delimeter: 7)\
    \ == [] as [Int])\nassert(intersperse(numbers: [5, 6, 3, 2], delimeter: 8) ==\
    \ [5, 8, 6, 8, 3, 8, 2])\nassert(intersperse(numbers: [2, 2, 2], delimeter: 2)\
    \ == [2, 2, 2, 2, 2])"
  status: Exception
  stderr: 'Swift/Range.swift:743: Fatal error: Range requires lowerBound <= upperBound

    Current stack trace:

    0    libswiftCore.so                    0x00002b5467e3ac80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b5467b31561 <unavailable> + 1434977

    2    libswiftCore.so                    0x00002b5467b31286 <unavailable> + 1434246

    3    libswiftCore.so                    0x00002b5467b3113c <unavailable> + 1433916

    4    libswiftCore.so                    0x00002b5467b30bb0 _assertionFailure(_:_:file:line:flags:)
    + 251

    5    tmp5y0rxvwz                        0x000055f8b9022a16 <unavailable> + 6678

    6    tmp5y0rxvwz                        0x000055f8b9022552 <unavailable> + 5458

    7    libc.so.6                          0x00002b5468026460 __libc_start_main +
    245

    8    tmp5y0rxvwz                        0x000055f8b9022259 <unavailable> + 4697

    '
  stdout: ''
  timestamp: 1659978933
- exit_code: 0
  program: "\n/// Insert a number 'delimeter' between every two consecutive elements\
    \ of input array `numbers'\n/// >>> intersperse(numbers: [] as [Int], delimeter:\
    \ 4)\n/// [] as [Int]\n/// >>> intersperse(numbers: [1, 2, 3], delimeter: 4)\n\
    /// [1, 4, 2, 4, 3]\nfunc intersperse(numbers: [Int], delimeter: Int) -> [Int]\
    \ {\n    if numbers.isEmpty {\n        return []\n    }\n    if numbers.count\
    \ == 1 {\n        return numbers\n    }\n    var result = [Int]()\n    for i in\
    \ 0..<numbers.count {\n        result.append(numbers[i])\n        if i < numbers.count\
    \ - 1 {\n            result.append(delimeter)\n        }\n    }\n    return result\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(intersperse(numbers: [] as [Int], delimeter: 7)\
    \ == [] as [Int])\nassert(intersperse(numbers: [5, 6, 3, 2], delimeter: 8) ==\
    \ [5, 8, 6, 8, 3, 8, 2])\nassert(intersperse(numbers: [2, 2, 2], delimeter: 2)\
    \ == [2, 2, 2, 2, 2])"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659978933
- exit_code: 0
  program: "\n/// Insert a number 'delimeter' between every two consecutive elements\
    \ of input array `numbers'\n/// >>> intersperse(numbers: [] as [Int], delimeter:\
    \ 4)\n/// [] as [Int]\n/// >>> intersperse(numbers: [1, 2, 3], delimeter: 4)\n\
    /// [1, 4, 2, 4, 3]\nfunc intersperse(numbers: [Int], delimeter: Int) -> [Int]\
    \ {\n    var numbersWithDelimeter = [Int]()\n    if numbers.count == 0 {\n   \
    \     return numbersWithDelimeter\n    }\n    for index in 0...numbers.count -\
    \ 1 {\n        numbersWithDelimeter.append(numbers[index])\n        if index <\
    \ numbers.count - 1 {\n            numbersWithDelimeter.append(delimeter)\n  \
    \      }\n    }\n    return numbersWithDelimeter\n}\n\n\nfunc ==(left: [(Int,\
    \ Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n\
    \        return false\n    }\n    for (l, r) in zip(left, right) {\n        if\
    \ l != r {\n            return false\n        }\n    }\n    return true\n}\n \
    \           \nassert(intersperse(numbers: [] as [Int], delimeter: 7) == [] as\
    \ [Int])\nassert(intersperse(numbers: [5, 6, 3, 2], delimeter: 8) == [5, 8, 6,\
    \ 8, 3, 8, 2])\nassert(intersperse(numbers: [2, 2, 2], delimeter: 2) == [2, 2,\
    \ 2, 2, 2])"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659978933
- exit_code: 0
  program: "\n/// Insert a number 'delimeter' between every two consecutive elements\
    \ of input array `numbers'\n/// >>> intersperse(numbers: [] as [Int], delimeter:\
    \ 4)\n/// [] as [Int]\n/// >>> intersperse(numbers: [1, 2, 3], delimeter: 4)\n\
    /// [1, 4, 2, 4, 3]\nfunc intersperse(numbers: [Int], delimeter: Int) -> [Int]\
    \ {\n    return numbers.reduce([]) {\n        if $0.isEmpty {\n            return\
    \ [$1]\n        } else {\n            return $0 + [delimeter] + [$1]\n       \
    \ }\n    }\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n\
    \    if left.count != right.count {\n        return false\n    }\n    for (l,\
    \ r) in zip(left, right) {\n        if l != r {\n            return false\n  \
    \      }\n    }\n    return true\n}\n            \nassert(intersperse(numbers:\
    \ [] as [Int], delimeter: 7) == [] as [Int])\nassert(intersperse(numbers: [5,\
    \ 6, 3, 2], delimeter: 8) == [5, 8, 6, 8, 3, 8, 2])\nassert(intersperse(numbers:\
    \ [2, 2, 2], delimeter: 2) == [2, 2, 2, 2, 2])"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659978933
- exit_code: -4
  program: "\n/// Insert a number 'delimeter' between every two consecutive elements\
    \ of input array `numbers'\n/// >>> intersperse(numbers: [] as [Int], delimeter:\
    \ 4)\n/// [] as [Int]\n/// >>> intersperse(numbers: [1, 2, 3], delimeter: 4)\n\
    /// [1, 4, 2, 4, 3]\nfunc intersperse(numbers: [Int], delimeter: Int) -> [Int]\
    \ {\n    return []\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) ->\
    \ Bool {\n    if left.count != right.count {\n        return false\n    }\n  \
    \  for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(intersperse(numbers:\
    \ [] as [Int], delimeter: 7) == [] as [Int])\nassert(intersperse(numbers: [5,\
    \ 6, 3, 2], delimeter: 8) == [5, 8, 6, 8, 3, 8, 2])\nassert(intersperse(numbers:\
    \ [2, 2, 2], delimeter: 2) == [2, 2, 2, 2, 2])"
  status: Exception
  stderr: 'tmp0sr70v0j/tmp0sr70v0j.swift:25: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b5f1c432c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b5f1c129b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b5f1c129988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b5f1c1287b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmp0sr70v0j                        0x000055f4032774cf <unavailable> + 5327

    5    libc.so.6                          0x00002b5f1c61e460 __libc_start_main +
    245

    6    tmp0sr70v0j                        0x000055f403276fc9 <unavailable> + 4041

    '
  stdout: ''
  timestamp: 1659978932
- exit_code: -4
  program: "\n/// Insert a number 'delimeter' between every two consecutive elements\
    \ of input array `numbers'\n/// >>> intersperse(numbers: [] as [Int], delimeter:\
    \ 4)\n/// [] as [Int]\n/// >>> intersperse(numbers: [1, 2, 3], delimeter: 4)\n\
    /// [1, 4, 2, 4, 3]\nfunc intersperse(numbers: [Int], delimeter: Int) -> [Int]\
    \ {\n    return []\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) ->\
    \ Bool {\n    if left.count != right.count {\n        return false\n    }\n  \
    \  for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(intersperse(numbers:\
    \ [] as [Int], delimeter: 7) == [] as [Int])\nassert(intersperse(numbers: [5,\
    \ 6, 3, 2], delimeter: 8) == [5, 8, 6, 8, 3, 8, 2])\nassert(intersperse(numbers:\
    \ [2, 2, 2], delimeter: 2) == [2, 2, 2, 2, 2])"
  status: Exception
  stderr: 'tmp0sr70v0j/tmp0sr70v0j.swift:25: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b5f1c432c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b5f1c129b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b5f1c129988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b5f1c1287b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmp0sr70v0j                        0x000055f4032774cf <unavailable> + 5327

    5    libc.so.6                          0x00002b5f1c61e460 __libc_start_main +
    245

    6    tmp0sr70v0j                        0x000055f403276fc9 <unavailable> + 4041

    '
  stdout: ''
  timestamp: 1659978932
- exit_code: 0
  program: "\n/// Insert a number 'delimeter' between every two consecutive elements\
    \ of input array `numbers'\n/// >>> intersperse(numbers: [] as [Int], delimeter:\
    \ 4)\n/// [] as [Int]\n/// >>> intersperse(numbers: [1, 2, 3], delimeter: 4)\n\
    /// [1, 4, 2, 4, 3]\nfunc intersperse(numbers: [Int], delimeter: Int) -> [Int]\
    \ {\n    var newNumbers = [Int]()\n    for i in 0..<numbers.count {\n        newNumbers.append(numbers[i])\n\
    \        if i < numbers.count - 1 {\n            newNumbers.append(delimeter)\n\
    \        }\n    }\n    return newNumbers\n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(intersperse(numbers: [] as [Int], delimeter: 7) == [] as [Int])\nassert(intersperse(numbers:\
    \ [5, 6, 3, 2], delimeter: 8) == [5, 8, 6, 8, 3, 8, 2])\nassert(intersperse(numbers:\
    \ [2, 2, 2], delimeter: 2) == [2, 2, 2, 2, 2])"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659978933
- exit_code: 1
  program: "\n/// Insert a number 'delimeter' between every two consecutive elements\
    \ of input array `numbers'\n/// >>> intersperse(numbers: [] as [Int], delimeter:\
    \ 4)\n/// [] as [Int]\n/// >>> intersperse(numbers: [1, 2, 3], delimeter: 4)\n\
    /// [1, 4, 2, 4, 3]\nfunc intersperse(numbers: [Int], delimeter: Int) -> [Int]\
    \ {\n    if numbers.isEmpty {\n        return []\n    }\n    return [numbers[0]]\
    \ + intersperse(numbers: numbers.dropFirst(), delimeter: delimeter).flatMap {\
    \ [delimeter, $0] }\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) ->\
    \ Bool {\n    if left.count != right.count {\n        return false\n    }\n  \
    \  for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(intersperse(numbers:\
    \ [] as [Int], delimeter: 7) == [] as [Int])\nassert(intersperse(numbers: [5,\
    \ 6, 3, 2], delimeter: 8) == [5, 8, 6, 8, 3, 8, 2])\nassert(intersperse(numbers:\
    \ [2, 2, 2], delimeter: 2) == [2, 2, 2, 2, 2])"
  status: SyntaxError
  stderr: "/tmp/tmp2j6q6o5y.swift:11:56: error: cannot convert value of type 'ArraySlice<Int>'\
    \ to expected argument type '[Int]'\n    return [numbers[0]] + intersperse(numbers:\
    \ numbers.dropFirst(), delimeter: delimeter).flatMap { [delimeter, $0] }\n   \
    \                                                    ^\n"
  stdout: ''
  timestamp: 1659978933
- exit_code: -4
  program: "\n/// Insert a number 'delimeter' between every two consecutive elements\
    \ of input array `numbers'\n/// >>> intersperse(numbers: [] as [Int], delimeter:\
    \ 4)\n/// [] as [Int]\n/// >>> intersperse(numbers: [1, 2, 3], delimeter: 4)\n\
    /// [1, 4, 2, 4, 3]\nfunc intersperse(numbers: [Int], delimeter: Int) -> [Int]\
    \ {\n    var interspersedArray = [Int]()\n    for n in numbers {\n        interspersedArray.append(n)\n\
    \        interspersedArray.append(delimeter)\n    }\n    interspersedArray.removeLast()\n\
    \    return interspersedArray\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int,\
    \ Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n\
    \    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n          \
    \  return false\n        }\n    }\n    return true\n}\n            \nassert(intersperse(numbers:\
    \ [] as [Int], delimeter: 7) == [] as [Int])\nassert(intersperse(numbers: [5,\
    \ 6, 3, 2], delimeter: 8) == [5, 8, 6, 8, 3, 8, 2])\nassert(intersperse(numbers:\
    \ [2, 2, 2], delimeter: 2) == [2, 2, 2, 2, 2])"
  status: Exception
  stderr: 'Swift/RangeReplaceableCollection.swift:870: Fatal error: Can''t remove
    last element from an empty collection

    Current stack trace:

    0    libswiftCore.so                    0x00002ba409009c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002ba408d00561 <unavailable> + 1434977

    2    libswiftCore.so                    0x00002ba408d00286 <unavailable> + 1434246

    3    libswiftCore.so                    0x00002ba408d0013c <unavailable> + 1433916

    4    libswiftCore.so                    0x00002ba408cffbb0 _assertionFailure(_:_:file:line:flags:)
    + 251

    5    libswiftCore.so                    0x00002ba408e01c1d <unavailable> + 2489373

    6    tmpstughhan                        0x0000556d82036ab7 <unavailable> + 6839

    7    tmpstughhan                        0x0000556d820365c2 <unavailable> + 5570

    8    libc.so.6                          0x00002ba4091f5460 __libc_start_main +
    245

    9    tmpstughhan                        0x0000556d820362c9 <unavailable> + 4809

    '
  stdout: ''
  timestamp: 1659978933
- exit_code: 0
  program: "\n/// Insert a number 'delimeter' between every two consecutive elements\
    \ of input array `numbers'\n/// >>> intersperse(numbers: [] as [Int], delimeter:\
    \ 4)\n/// [] as [Int]\n/// >>> intersperse(numbers: [1, 2, 3], delimeter: 4)\n\
    /// [1, 4, 2, 4, 3]\nfunc intersperse(numbers: [Int], delimeter: Int) -> [Int]\
    \ {\n    return numbers.reduce([Int]()) {\n        numbers, number in\n      \
    \  var numbers = numbers\n        numbers.append(number)\n        numbers.append(delimeter)\n\
    \        return numbers\n    }.dropLast()\n}\n\n\nfunc ==(left: [(Int, Int)],\
    \ right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n       \
    \ return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r\
    \ {\n            return false\n        }\n    }\n    return true\n}\n        \
    \    \nassert(intersperse(numbers: [] as [Int], delimeter: 7) == [] as [Int])\n\
    assert(intersperse(numbers: [5, 6, 3, 2], delimeter: 8) == [5, 8, 6, 8, 3, 8,\
    \ 2])\nassert(intersperse(numbers: [2, 2, 2], delimeter: 2) == [2, 2, 2, 2, 2])"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659978933
- exit_code: 1
  program: "\n/// Insert a number 'delimeter' between every two consecutive elements\
    \ of input array `numbers'\n/// >>> intersperse(numbers: [] as [Int], delimeter:\
    \ 4)\n/// [] as [Int]\n/// >>> intersperse(numbers: [1, 2, 3], delimeter: 4)\n\
    /// [1, 4, 2, 4, 3]\nfunc intersperse(numbers: [Int], delimeter: Int) -> [Int]\
    \ {\n\tif numbers.isEmpty {\n\t\treturn []\n\t} else {\n\t\tlet first = numbers[0]\n\
    \t\tlet rest = Array(numbers[1..<numbers.count])\n\t\treturn [first] + [delimeter]\
    \ + intersperse(rest, delimeter: delimeter)\n\t}\n}\n\n\nfunc ==(left: [(Int,\
    \ Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n\
    \        return false\n    }\n    for (l, r) in zip(left, right) {\n        if\
    \ l != r {\n            return false\n        }\n    }\n    return true\n}\n \
    \           \nassert(intersperse(numbers: [] as [Int], delimeter: 7) == [] as\
    \ [Int])\nassert(intersperse(numbers: [5, 6, 3, 2], delimeter: 8) == [5, 8, 6,\
    \ 8, 3, 8, 2])\nassert(intersperse(numbers: [2, 2, 2], delimeter: 2) == [2, 2,\
    \ 2, 2, 2])"
  status: SyntaxError
  stderr: "/tmp/tmp_ytqg4k1.swift:13:45: error: missing argument label 'numbers:'\
    \ in call\n                return [first] + [delimeter] + intersperse(rest, delimeter:\
    \ delimeter)\n                                                          ^\n  \
    \                                                         numbers: \n"
  stdout: ''
  timestamp: 1659978933
- exit_code: 0
  program: "\n/// Insert a number 'delimeter' between every two consecutive elements\
    \ of input array `numbers'\n/// >>> intersperse(numbers: [] as [Int], delimeter:\
    \ 4)\n/// [] as [Int]\n/// >>> intersperse(numbers: [1, 2, 3], delimeter: 4)\n\
    /// [1, 4, 2, 4, 3]\nfunc intersperse(numbers: [Int], delimeter: Int) -> [Int]\
    \ {\n\tvar result = [Int]()\n\tfor num in numbers {\n\t\tresult.append(num)\n\t\
    \tresult.append(delimeter)\n\t}\n\treturn Array(result.dropLast())\n}\n\n\nfunc\
    \ ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count !=\
    \ right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(intersperse(numbers: [] as [Int], delimeter: 7)\
    \ == [] as [Int])\nassert(intersperse(numbers: [5, 6, 3, 2], delimeter: 8) ==\
    \ [5, 8, 6, 8, 3, 8, 2])\nassert(intersperse(numbers: [2, 2, 2], delimeter: 2)\
    \ == [2, 2, 2, 2, 2])"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659978933
- exit_code: -4
  program: "\n/// Insert a number 'delimeter' between every two consecutive elements\
    \ of input array `numbers'\n/// >>> intersperse(numbers: [] as [Int], delimeter:\
    \ 4)\n/// [] as [Int]\n/// >>> intersperse(numbers: [1, 2, 3], delimeter: 4)\n\
    /// [1, 4, 2, 4, 3]\nfunc intersperse(numbers: [Int], delimeter: Int) -> [Int]\
    \ {\n    func helper(numbers: [Int], result: [Int], delimeter: Int) -> [Int] {\n\
    \        if numbers.isEmpty {\n            return result\n        } else {\n \
    \           var result2 = result\n            result2.append(numbers[0])\n   \
    \         result2.append(delimeter)\n            return helper(numbers: Array(numbers[1..<numbers.count]),\
    \ result: result2, delimeter: delimeter)\n        }\n    }\n    return helper(numbers:\
    \ numbers, result: [], delimeter: delimeter)\n}\n\n\nfunc ==(left: [(Int, Int)],\
    \ right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n       \
    \ return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r\
    \ {\n            return false\n        }\n    }\n    return true\n}\n        \
    \    \nassert(intersperse(numbers: [] as [Int], delimeter: 7) == [] as [Int])\n\
    assert(intersperse(numbers: [5, 6, 3, 2], delimeter: 8) == [5, 8, 6, 8, 3, 8,\
    \ 2])\nassert(intersperse(numbers: [2, 2, 2], delimeter: 2) == [2, 2, 2, 2, 2])"
  status: Exception
  stderr: 'tmptz00qxuv/tmptz00qxuv.swift:35: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b1d6ef0ec80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b1d6ec05b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b1d6ec05988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b1d6ec047b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmptz00qxuv                        0x000055f6c7f8985f <unavailable> + 6239

    5    libc.so.6                          0x00002b1d6f0fa460 __libc_start_main +
    245

    6    tmptz00qxuv                        0x000055f6c7f89359 <unavailable> + 4953

    '
  stdout: ''
  timestamp: 1659978933
- exit_code: 0
  program: "\n/// Insert a number 'delimeter' between every two consecutive elements\
    \ of input array `numbers'\n/// >>> intersperse(numbers: [] as [Int], delimeter:\
    \ 4)\n/// [] as [Int]\n/// >>> intersperse(numbers: [1, 2, 3], delimeter: 4)\n\
    /// [1, 4, 2, 4, 3]\nfunc intersperse(numbers: [Int], delimeter: Int) -> [Int]\
    \ {\n    if numbers.isEmpty {\n        return []\n    }\n    return numbers.enumerated().reduce([])\
    \ { (arr, index) -> [Int] in\n        if index.offset == 0 {\n            return\
    \ [index.element]\n        }\n        return arr + [delimeter, index.element]\n\
    \    }\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n  \
    \  if left.count != right.count {\n        return false\n    }\n    for (l, r)\
    \ in zip(left, right) {\n        if l != r {\n            return false\n     \
    \   }\n    }\n    return true\n}\n            \nassert(intersperse(numbers: []\
    \ as [Int], delimeter: 7) == [] as [Int])\nassert(intersperse(numbers: [5, 6,\
    \ 3, 2], delimeter: 8) == [5, 8, 6, 8, 3, 8, 2])\nassert(intersperse(numbers:\
    \ [2, 2, 2], delimeter: 2) == [2, 2, 2, 2, 2])"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659978933
- exit_code: 0
  program: "\n/// Insert a number 'delimeter' between every two consecutive elements\
    \ of input array `numbers'\n/// >>> intersperse(numbers: [] as [Int], delimeter:\
    \ 4)\n/// [] as [Int]\n/// >>> intersperse(numbers: [1, 2, 3], delimeter: 4)\n\
    /// [1, 4, 2, 4, 3]\nfunc intersperse(numbers: [Int], delimeter: Int) -> [Int]\
    \ {\n    let n = numbers.count\n    guard n > 1 else { return numbers }\n    var\
    \ output = [Int]()\n    for i in 0..<n-1 {\n        output.append(numbers[i])\n\
    \        output.append(delimeter)\n    }\n    output.append(numbers[n-1])\n  \
    \  return output\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool\
    \ {\n    if left.count != right.count {\n        return false\n    }\n    for\
    \ (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(intersperse(numbers:\
    \ [] as [Int], delimeter: 7) == [] as [Int])\nassert(intersperse(numbers: [5,\
    \ 6, 3, 2], delimeter: 8) == [5, 8, 6, 8, 3, 8, 2])\nassert(intersperse(numbers:\
    \ [2, 2, 2], delimeter: 2) == [2, 2, 2, 2, 2])"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659978933
- exit_code: 0
  program: "\n/// Insert a number 'delimeter' between every two consecutive elements\
    \ of input array `numbers'\n/// >>> intersperse(numbers: [] as [Int], delimeter:\
    \ 4)\n/// [] as [Int]\n/// >>> intersperse(numbers: [1, 2, 3], delimeter: 4)\n\
    /// [1, 4, 2, 4, 3]\nfunc intersperse(numbers: [Int], delimeter: Int) -> [Int]\
    \ {\n    guard let first = numbers.first else { return [] }\n    guard numbers.count\
    \ > 1 else { return [first] }\n    let rest = Array(numbers.dropFirst())\n   \
    \ return [first] + [delimeter] + intersperse(numbers: rest, delimeter: delimeter)\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(intersperse(numbers: [] as [Int], delimeter: 7)\
    \ == [] as [Int])\nassert(intersperse(numbers: [5, 6, 3, 2], delimeter: 8) ==\
    \ [5, 8, 6, 8, 3, 8, 2])\nassert(intersperse(numbers: [2, 2, 2], delimeter: 2)\
    \ == [2, 2, 2, 2, 2])"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659978933
- exit_code: 0
  program: "\n/// Insert a number 'delimeter' between every two consecutive elements\
    \ of input array `numbers'\n/// >>> intersperse(numbers: [] as [Int], delimeter:\
    \ 4)\n/// [] as [Int]\n/// >>> intersperse(numbers: [1, 2, 3], delimeter: 4)\n\
    /// [1, 4, 2, 4, 3]\nfunc intersperse(numbers: [Int], delimeter: Int) -> [Int]\
    \ {\n    return numbers.reduce([]) { (result, number) in\n        guard !result.isEmpty\
    \ else { return [number] }\n        return result + [delimeter] + [number]\n \
    \   }\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n   \
    \ if left.count != right.count {\n        return false\n    }\n    for (l, r)\
    \ in zip(left, right) {\n        if l != r {\n            return false\n     \
    \   }\n    }\n    return true\n}\n            \nassert(intersperse(numbers: []\
    \ as [Int], delimeter: 7) == [] as [Int])\nassert(intersperse(numbers: [5, 6,\
    \ 3, 2], delimeter: 8) == [5, 8, 6, 8, 3, 8, 2])\nassert(intersperse(numbers:\
    \ [2, 2, 2], delimeter: 2) == [2, 2, 2, 2, 2])"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659978933
- exit_code: 0
  program: "\n/// Insert a number 'delimeter' between every two consecutive elements\
    \ of input array `numbers'\n/// >>> intersperse(numbers: [] as [Int], delimeter:\
    \ 4)\n/// [] as [Int]\n/// >>> intersperse(numbers: [1, 2, 3], delimeter: 4)\n\
    /// [1, 4, 2, 4, 3]\nfunc intersperse(numbers: [Int], delimeter: Int) -> [Int]\
    \ {\n    if numbers.isEmpty {\n        return []\n    }\n    return numbers.reduce([])\
    \ { (result, number) in\n        if result.isEmpty {\n            return [number]\n\
    \        }\n        return result + [delimeter] + [number]\n    }\n}\n\n\nfunc\
    \ ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count !=\
    \ right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(intersperse(numbers: [] as [Int], delimeter: 7)\
    \ == [] as [Int])\nassert(intersperse(numbers: [5, 6, 3, 2], delimeter: 8) ==\
    \ [5, 8, 6, 8, 3, 8, 2])\nassert(intersperse(numbers: [2, 2, 2], delimeter: 2)\
    \ == [2, 2, 2, 2, 2])"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659978933
- exit_code: 0
  program: "\n/// Insert a number 'delimeter' between every two consecutive elements\
    \ of input array `numbers'\n/// >>> intersperse(numbers: [] as [Int], delimeter:\
    \ 4)\n/// [] as [Int]\n/// >>> intersperse(numbers: [1, 2, 3], delimeter: 4)\n\
    /// [1, 4, 2, 4, 3]\nfunc intersperse(numbers: [Int], delimeter: Int) -> [Int]\
    \ {\n    guard !numbers.isEmpty else { return [] }\n    guard numbers.count >\
    \ 1 else { return numbers }\n    var result = [Int]()\n    for i in 0..<numbers.count\
    \ - 1 {\n        result.append(numbers[i])\n        result.append(delimeter)\n\
    \    }\n    result.append(numbers[numbers.count - 1])\n    return result\n}\n\n\
    \nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(intersperse(numbers: [] as [Int], delimeter: 7)\
    \ == [] as [Int])\nassert(intersperse(numbers: [5, 6, 3, 2], delimeter: 8) ==\
    \ [5, 8, 6, 8, 3, 8, 2])\nassert(intersperse(numbers: [2, 2, 2], delimeter: 2)\
    \ == [2, 2, 2, 2, 2])"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659978933
- exit_code: 0
  program: "\n/// Insert a number 'delimeter' between every two consecutive elements\
    \ of input array `numbers'\n/// >>> intersperse(numbers: [] as [Int], delimeter:\
    \ 4)\n/// [] as [Int]\n/// >>> intersperse(numbers: [1, 2, 3], delimeter: 4)\n\
    /// [1, 4, 2, 4, 3]\nfunc intersperse(numbers: [Int], delimeter: Int) -> [Int]\
    \ {\n    if numbers.isEmpty {\n        return []\n    } else {\n        var result\
    \ = [Int]()\n        result.append(numbers[0])\n        for i in 1..<numbers.count\
    \ {\n            result.append(delimeter)\n            result.append(numbers[i])\n\
    \        }\n        return result\n    }\n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(intersperse(numbers: [] as [Int], delimeter: 7) == [] as [Int])\nassert(intersperse(numbers:\
    \ [5, 6, 3, 2], delimeter: 8) == [5, 8, 6, 8, 3, 8, 2])\nassert(intersperse(numbers:\
    \ [2, 2, 2], delimeter: 2) == [2, 2, 2, 2, 2])"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659978933
- exit_code: 0
  program: "\n/// Insert a number 'delimeter' between every two consecutive elements\
    \ of input array `numbers'\n/// >>> intersperse(numbers: [] as [Int], delimeter:\
    \ 4)\n/// [] as [Int]\n/// >>> intersperse(numbers: [1, 2, 3], delimeter: 4)\n\
    /// [1, 4, 2, 4, 3]\nfunc intersperse(numbers: [Int], delimeter: Int) -> [Int]\
    \ {\n    guard !numbers.isEmpty else { return [] }\n    return Array(numbers.dropFirst()).reduce([numbers.first!])\
    \ {\n        (accumulator, element) in accumulator + [delimeter] + [element]\n\
    \    }\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n  \
    \  if left.count != right.count {\n        return false\n    }\n    for (l, r)\
    \ in zip(left, right) {\n        if l != r {\n            return false\n     \
    \   }\n    }\n    return true\n}\n            \nassert(intersperse(numbers: []\
    \ as [Int], delimeter: 7) == [] as [Int])\nassert(intersperse(numbers: [5, 6,\
    \ 3, 2], delimeter: 8) == [5, 8, 6, 8, 3, 8, 2])\nassert(intersperse(numbers:\
    \ [2, 2, 2], delimeter: 2) == [2, 2, 2, 2, 2])"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659978933
- exit_code: -4
  program: "\n/// Insert a number 'delimeter' between every two consecutive elements\
    \ of input array `numbers'\n/// >>> intersperse(numbers: [] as [Int], delimeter:\
    \ 4)\n/// [] as [Int]\n/// >>> intersperse(numbers: [1, 2, 3], delimeter: 4)\n\
    /// [1, 4, 2, 4, 3]\nfunc intersperse(numbers: [Int], delimeter: Int) -> [Int]\
    \ {\n    if numbers.isEmpty {\n        return []\n    } else {\n        return\
    \ [numbers[0]] + intersperse(numbers: Array(numbers[1..<numbers.count]), delimeter:\
    \ delimeter).flatMap { [delimeter, $0] }\n    }\n}\n\n\nfunc ==(left: [(Int, Int)],\
    \ right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n       \
    \ return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r\
    \ {\n            return false\n        }\n    }\n    return true\n}\n        \
    \    \nassert(intersperse(numbers: [] as [Int], delimeter: 7) == [] as [Int])\n\
    assert(intersperse(numbers: [5, 6, 3, 2], delimeter: 8) == [5, 8, 6, 8, 3, 8,\
    \ 2])\nassert(intersperse(numbers: [2, 2, 2], delimeter: 2) == [2, 2, 2, 2, 2])"
  status: Exception
  stderr: 'tmpkvegjivq/tmpkvegjivq.swift:29: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002af83dfcec80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002af83dcc5b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002af83dcc5988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002af83dcc47b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpkvegjivq                        0x000056270733f8df <unavailable> + 6367

    5    libc.so.6                          0x00002af83e1ba460 __libc_start_main +
    245

    6    tmpkvegjivq                        0x000056270733f3d9 <unavailable> + 5081

    '
  stdout: ''
  timestamp: 1659978933
- exit_code: 0
  program: "\n/// Insert a number 'delimeter' between every two consecutive elements\
    \ of input array `numbers'\n/// >>> intersperse(numbers: [] as [Int], delimeter:\
    \ 4)\n/// [] as [Int]\n/// >>> intersperse(numbers: [1, 2, 3], delimeter: 4)\n\
    /// [1, 4, 2, 4, 3]\nfunc intersperse(numbers: [Int], delimeter: Int) -> [Int]\
    \ {\n    if numbers.isEmpty {\n        return []\n    }\n    if numbers.count\
    \ == 1 {\n        return numbers\n    }\n    var newNumbers = [Int]()\n    for\
    \ i in 0 ..< numbers.count {\n        newNumbers.append(numbers[i])\n        if\
    \ i < numbers.count - 1 {\n            newNumbers.append(delimeter)\n        }\n\
    \    }\n    return newNumbers\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int,\
    \ Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n\
    \    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n          \
    \  return false\n        }\n    }\n    return true\n}\n            \nassert(intersperse(numbers:\
    \ [] as [Int], delimeter: 7) == [] as [Int])\nassert(intersperse(numbers: [5,\
    \ 6, 3, 2], delimeter: 8) == [5, 8, 6, 8, 3, 8, 2])\nassert(intersperse(numbers:\
    \ [2, 2, 2], delimeter: 2) == [2, 2, 2, 2, 2])"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659978933
- exit_code: 0
  program: "\n/// Insert a number 'delimeter' between every two consecutive elements\
    \ of input array `numbers'\n/// >>> intersperse(numbers: [] as [Int], delimeter:\
    \ 4)\n/// [] as [Int]\n/// >>> intersperse(numbers: [1, 2, 3], delimeter: 4)\n\
    /// [1, 4, 2, 4, 3]\nfunc intersperse(numbers: [Int], delimeter: Int) -> [Int]\
    \ {\n    if numbers.isEmpty {\n        return []\n    }\n    if numbers.count\
    \ == 1 {\n        return numbers\n    }\n    var result = [Int]()\n    for i in\
    \ 0..<numbers.count - 1 {\n        result.append(numbers[i])\n        result.append(delimeter)\n\
    \    }\n    result.append(numbers[numbers.count - 1])\n    return result\n}\n\n\
    \nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(intersperse(numbers: [] as [Int], delimeter: 7)\
    \ == [] as [Int])\nassert(intersperse(numbers: [5, 6, 3, 2], delimeter: 8) ==\
    \ [5, 8, 6, 8, 3, 8, 2])\nassert(intersperse(numbers: [2, 2, 2], delimeter: 2)\
    \ == [2, 2, 2, 2, 2])"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659978933
- exit_code: -4
  program: "\n/// Insert a number 'delimeter' between every two consecutive elements\
    \ of input array `numbers'\n/// >>> intersperse(numbers: [] as [Int], delimeter:\
    \ 4)\n/// [] as [Int]\n/// >>> intersperse(numbers: [1, 2, 3], delimeter: 4)\n\
    /// [1, 4, 2, 4, 3]\nfunc intersperse(numbers: [Int], delimeter: Int) -> [Int]\
    \ {\n    return []\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) ->\
    \ Bool {\n    if left.count != right.count {\n        return false\n    }\n  \
    \  for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(intersperse(numbers:\
    \ [] as [Int], delimeter: 7) == [] as [Int])\nassert(intersperse(numbers: [5,\
    \ 6, 3, 2], delimeter: 8) == [5, 8, 6, 8, 3, 8, 2])\nassert(intersperse(numbers:\
    \ [2, 2, 2], delimeter: 2) == [2, 2, 2, 2, 2])"
  status: Exception
  stderr: 'tmp0sr70v0j/tmp0sr70v0j.swift:25: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b5f1c432c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b5f1c129b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b5f1c129988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b5f1c1287b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmp0sr70v0j                        0x000055f4032774cf <unavailable> + 5327

    5    libc.so.6                          0x00002b5f1c61e460 __libc_start_main +
    245

    6    tmp0sr70v0j                        0x000055f403276fc9 <unavailable> + 4041

    '
  stdout: ''
  timestamp: 1659978932
- exit_code: 0
  program: "\n/// Insert a number 'delimeter' between every two consecutive elements\
    \ of input array `numbers'\n/// >>> intersperse(numbers: [] as [Int], delimeter:\
    \ 4)\n/// [] as [Int]\n/// >>> intersperse(numbers: [1, 2, 3], delimeter: 4)\n\
    /// [1, 4, 2, 4, 3]\nfunc intersperse(numbers: [Int], delimeter: Int) -> [Int]\
    \ {\n    guard numbers.count > 1 else { return numbers }\n    var result = [Int]()\n\
    \    result.append(numbers[0])\n    for i in 1..<numbers.count {\n        result.append(delimeter)\n\
    \        result.append(numbers[i])\n    }\n    return result\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(intersperse(numbers: [] as [Int], delimeter: 7) == []\
    \ as [Int])\nassert(intersperse(numbers: [5, 6, 3, 2], delimeter: 8) == [5, 8,\
    \ 6, 8, 3, 8, 2])\nassert(intersperse(numbers: [2, 2, 2], delimeter: 2) == [2,\
    \ 2, 2, 2, 2])"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659978933
- exit_code: 0
  program: "\n/// Insert a number 'delimeter' between every two consecutive elements\
    \ of input array `numbers'\n/// >>> intersperse(numbers: [] as [Int], delimeter:\
    \ 4)\n/// [] as [Int]\n/// >>> intersperse(numbers: [1, 2, 3], delimeter: 4)\n\
    /// [1, 4, 2, 4, 3]\nfunc intersperse(numbers: [Int], delimeter: Int) -> [Int]\
    \ {\n    return numbers.reduce([], {res, elem in\n        if res.isEmpty {\n \
    \           return [elem]\n        } else {\n            return res + [delimeter]\
    \ + [elem]\n        }\n    })\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int,\
    \ Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n\
    \    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n          \
    \  return false\n        }\n    }\n    return true\n}\n            \nassert(intersperse(numbers:\
    \ [] as [Int], delimeter: 7) == [] as [Int])\nassert(intersperse(numbers: [5,\
    \ 6, 3, 2], delimeter: 8) == [5, 8, 6, 8, 3, 8, 2])\nassert(intersperse(numbers:\
    \ [2, 2, 2], delimeter: 2) == [2, 2, 2, 2, 2])"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659978933
- exit_code: 0
  program: "\n/// Insert a number 'delimeter' between every two consecutive elements\
    \ of input array `numbers'\n/// >>> intersperse(numbers: [] as [Int], delimeter:\
    \ 4)\n/// [] as [Int]\n/// >>> intersperse(numbers: [1, 2, 3], delimeter: 4)\n\
    /// [1, 4, 2, 4, 3]\nfunc intersperse(numbers: [Int], delimeter: Int) -> [Int]\
    \ {\n    if numbers.isEmpty {\n        return []\n    }\n    if numbers.count\
    \ == 1 {\n        return numbers\n    }\n    var result = [Int]()\n    for i in\
    \ 0..<numbers.count {\n        result.append(numbers[i])\n        if i != numbers.count\
    \ - 1 {\n            result.append(delimeter)\n        }\n    }\n    return result\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(intersperse(numbers: [] as [Int], delimeter: 7)\
    \ == [] as [Int])\nassert(intersperse(numbers: [5, 6, 3, 2], delimeter: 8) ==\
    \ [5, 8, 6, 8, 3, 8, 2])\nassert(intersperse(numbers: [2, 2, 2], delimeter: 2)\
    \ == [2, 2, 2, 2, 2])"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659978933
- exit_code: 1
  program: "\n/// Insert a number 'delimeter' between every two consecutive elements\
    \ of input array `numbers'\n/// >>> intersperse(numbers: [] as [Int], delimeter:\
    \ 4)\n/// [] as [Int]\n/// >>> intersperse(numbers: [1, 2, 3], delimeter: 4)\n\
    /// [1, 4, 2, 4, 3]\nfunc intersperse(numbers: [Int], delimeter: Int) -> [Int]\
    \ {\n    return numbers.reduce([]) { partialResult, element in\n        partialResult\
    \ + [delimeter] + [element]\n    }.dropFirst()\n}\n\n\nfunc ==(left: [(Int, Int)],\
    \ right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n       \
    \ return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r\
    \ {\n            return false\n        }\n    }\n    return true\n}\n        \
    \    \nassert(intersperse(numbers: [] as [Int], delimeter: 7) == [] as [Int])\n\
    assert(intersperse(numbers: [5, 6, 3, 2], delimeter: 8) == [5, 8, 6, 8, 3, 8,\
    \ 2])\nassert(intersperse(numbers: [2, 2, 2], delimeter: 2) == [2, 2, 2, 2, 2])"
  status: SyntaxError
  stderr: "/tmp/tmpjmc1ize1.swift:10:7: error: no 'dropFirst' candidates produce the\
    \ expected contextual result type '[Int]'\n    }.dropFirst()\n      ^\nSwift.Sequence:4:40:\
    \ note: 'dropFirst' produces 'DropFirstSequence<Array<Int>>', not the expected\
    \ contextual result type '[Int]'\n    @inlinable public __consuming func dropFirst(_\
    \ k: Int = 1) -> DropFirstSequence<Self>\n                                   \
    \    ^\nSwift.Collection:3:40: note: 'dropFirst' produces 'ArraySlice<Int>', not\
    \ the expected contextual result type '[Int]'\n    @inlinable public __consuming\
    \ func dropFirst(_ k: Int = 1) -> Self.SubSequence\n                         \
    \              ^\nSwift.Sequence:4:40: note: 'dropFirst' produces 'DropFirstSequence<Array<Int>>',\
    \ not the expected contextual result type '[Int]'\n    @inlinable public __consuming\
    \ func dropFirst(_ k: Int = 1) -> DropFirstSequence<Self>\n                  \
    \                     ^\nSwift.Collection:3:40: note: 'dropFirst' produces 'ArraySlice<Int>',\
    \ not the expected contextual result type '[Int]'\n    @inlinable public __consuming\
    \ func dropFirst(_ k: Int = 1) -> Self.SubSequence\n                         \
    \              ^\nSwift.Sequence:4:40: note: 'dropFirst' produces 'DropFirstSequence<Array<Int>>',\
    \ not the expected contextual result type '[Int]'\n    @inlinable public __consuming\
    \ func dropFirst(_ k: Int = 1) -> DropFirstSequence<Self>\n                  \
    \                     ^\nSwift.Collection:3:40: note: 'dropFirst' produces 'ArraySlice<Int>',\
    \ not the expected contextual result type '[Int]'\n    @inlinable public __consuming\
    \ func dropFirst(_ k: Int = 1) -> Self.SubSequence\n                         \
    \              ^\nSwift.Sequence:4:40: note: 'dropFirst' produces 'DropFirstSequence<Array<Int>>',\
    \ not the expected contextual result type '[Int]'\n    @inlinable public __consuming\
    \ func dropFirst(_ k: Int = 1) -> DropFirstSequence<Self>\n                  \
    \                     ^\nSwift.Collection:3:40: note: 'dropFirst' produces 'ArraySlice<Int>',\
    \ not the expected contextual result type '[Int]'\n    @inlinable public __cons"
  stdout: ''
  timestamp: 1659978934
- exit_code: -4
  program: "\n/// Insert a number 'delimeter' between every two consecutive elements\
    \ of input array `numbers'\n/// >>> intersperse(numbers: [] as [Int], delimeter:\
    \ 4)\n/// [] as [Int]\n/// >>> intersperse(numbers: [1, 2, 3], delimeter: 4)\n\
    /// [1, 4, 2, 4, 3]\nfunc intersperse(numbers: [Int], delimeter: Int) -> [Int]\
    \ {\n    var result: [Int] = []\n    for index in 0..<numbers.count - 1 {\n  \
    \      result.append(numbers[index])\n        result.append(delimeter)\n    }\n\
    \    result.append(numbers[numbers.count - 1])\n    return result\n}\n\n\nfunc\
    \ ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count !=\
    \ right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(intersperse(numbers: [] as [Int], delimeter: 7)\
    \ == [] as [Int])\nassert(intersperse(numbers: [5, 6, 3, 2], delimeter: 8) ==\
    \ [5, 8, 6, 8, 3, 8, 2])\nassert(intersperse(numbers: [2, 2, 2], delimeter: 2)\
    \ == [2, 2, 2, 2, 2])"
  status: Exception
  stderr: 'Swift/Range.swift:743: Fatal error: Range requires lowerBound <= upperBound

    Current stack trace:

    0    libswiftCore.so                    0x00002aae608c3c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002aae605ba561 <unavailable> + 1434977

    2    libswiftCore.so                    0x00002aae605ba286 <unavailable> + 1434246

    3    libswiftCore.so                    0x00002aae605ba13c <unavailable> + 1433916

    4    libswiftCore.so                    0x00002aae605b9bb0 _assertionFailure(_:_:file:line:flags:)
    + 251

    5    tmpv_7ckzpu                        0x00005563a9fa5a16 <unavailable> + 6678

    6    tmpv_7ckzpu                        0x00005563a9fa5552 <unavailable> + 5458

    7    libc.so.6                          0x00002aae60aaf460 __libc_start_main +
    245

    8    tmpv_7ckzpu                        0x00005563a9fa5259 <unavailable> + 4697

    '
  stdout: ''
  timestamp: 1659978933
- exit_code: 0
  program: "\n/// Insert a number 'delimeter' between every two consecutive elements\
    \ of input array `numbers'\n/// >>> intersperse(numbers: [] as [Int], delimeter:\
    \ 4)\n/// [] as [Int]\n/// >>> intersperse(numbers: [1, 2, 3], delimeter: 4)\n\
    /// [1, 4, 2, 4, 3]\nfunc intersperse(numbers: [Int], delimeter: Int) -> [Int]\
    \ {\n    return numbers.reduce([], { (acc, n) in\n        if acc.isEmpty {\n \
    \           return [n]\n        } else {\n            return acc + [delimeter,\
    \ n]\n        }\n    })\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(intersperse(numbers:\
    \ [] as [Int], delimeter: 7) == [] as [Int])\nassert(intersperse(numbers: [5,\
    \ 6, 3, 2], delimeter: 8) == [5, 8, 6, 8, 3, 8, 2])\nassert(intersperse(numbers:\
    \ [2, 2, 2], delimeter: 2) == [2, 2, 2, 2, 2])"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659978933
- exit_code: -4
  program: "\n/// Insert a number 'delimeter' between every two consecutive elements\
    \ of input array `numbers'\n/// >>> intersperse(numbers: [] as [Int], delimeter:\
    \ 4)\n/// [] as [Int]\n/// >>> intersperse(numbers: [1, 2, 3], delimeter: 4)\n\
    /// [1, 4, 2, 4, 3]\nfunc intersperse(numbers: [Int], delimeter: Int) -> [Int]\
    \ {\n    guard !numbers.isEmpty else { return [] }\n    let numsWithoutFirst =\
    \ intersperse(numbers: Array(numbers.dropFirst()), delimeter: delimeter)\n   \
    \ return [numbers.first!] + numsWithoutFirst.flatMap { [delimeter, $0] }\n}\n\n\
    \nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(intersperse(numbers: [] as [Int], delimeter: 7)\
    \ == [] as [Int])\nassert(intersperse(numbers: [5, 6, 3, 2], delimeter: 8) ==\
    \ [5, 8, 6, 8, 3, 8, 2])\nassert(intersperse(numbers: [2, 2, 2], delimeter: 2)\
    \ == [2, 2, 2, 2, 2])"
  status: Exception
  stderr: 'tmpa6pd66jv/tmpa6pd66jv.swift:27: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002aaf0bbc6c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002aaf0b8bdb6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002aaf0b8bd988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002aaf0b8bc7b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpa6pd66jv                        0x000055f67253988f <unavailable> + 6287

    5    libc.so.6                          0x00002aaf0bdb2460 __libc_start_main +
    245

    6    tmpa6pd66jv                        0x000055f672539389 <unavailable> + 5001

    '
  stdout: ''
  timestamp: 1659978933
- exit_code: 0
  program: "\n/// Insert a number 'delimeter' between every two consecutive elements\
    \ of input array `numbers'\n/// >>> intersperse(numbers: [] as [Int], delimeter:\
    \ 4)\n/// [] as [Int]\n/// >>> intersperse(numbers: [1, 2, 3], delimeter: 4)\n\
    /// [1, 4, 2, 4, 3]\nfunc intersperse(numbers: [Int], delimeter: Int) -> [Int]\
    \ {\n    if numbers.isEmpty {\n        return []\n    }\n    var result = [Int]()\n\
    \    for i in 0..<numbers.count - 1 {\n        result.append(numbers[i])\n   \
    \     result.append(delimeter)\n    }\n    result.append(numbers[numbers.count\
    \ - 1])\n    return result\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(intersperse(numbers:\
    \ [] as [Int], delimeter: 7) == [] as [Int])\nassert(intersperse(numbers: [5,\
    \ 6, 3, 2], delimeter: 8) == [5, 8, 6, 8, 3, 8, 2])\nassert(intersperse(numbers:\
    \ [2, 2, 2], delimeter: 2) == [2, 2, 2, 2, 2])"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659978933
- exit_code: 0
  program: "\n/// Insert a number 'delimeter' between every two consecutive elements\
    \ of input array `numbers'\n/// >>> intersperse(numbers: [] as [Int], delimeter:\
    \ 4)\n/// [] as [Int]\n/// >>> intersperse(numbers: [1, 2, 3], delimeter: 4)\n\
    /// [1, 4, 2, 4, 3]\nfunc intersperse(numbers: [Int], delimeter: Int) -> [Int]\
    \ {\n    var newNumbers = [Int]()\n    for i in 0..<numbers.count {\n        newNumbers.append(numbers[i])\n\
    \        if i != numbers.count - 1 {\n            newNumbers.append(delimeter)\n\
    \        }\n    }\n    return newNumbers\n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(intersperse(numbers: [] as [Int], delimeter: 7) == [] as [Int])\nassert(intersperse(numbers:\
    \ [5, 6, 3, 2], delimeter: 8) == [5, 8, 6, 8, 3, 8, 2])\nassert(intersperse(numbers:\
    \ [2, 2, 2], delimeter: 2) == [2, 2, 2, 2, 2])"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659978934
- exit_code: 0
  program: "\n/// Insert a number 'delimeter' between every two consecutive elements\
    \ of input array `numbers'\n/// >>> intersperse(numbers: [] as [Int], delimeter:\
    \ 4)\n/// [] as [Int]\n/// >>> intersperse(numbers: [1, 2, 3], delimeter: 4)\n\
    /// [1, 4, 2, 4, 3]\nfunc intersperse(numbers: [Int], delimeter: Int) -> [Int]\
    \ {\n    var output = [Int]()\n    for i in 0..<numbers.count {\n        output.append(numbers[i])\n\
    \        if i < numbers.count - 1 {\n            output.append(delimeter)\n  \
    \      }\n    }\n    return output\n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(intersperse(numbers: [] as [Int], delimeter: 7) == [] as [Int])\nassert(intersperse(numbers:\
    \ [5, 6, 3, 2], delimeter: 8) == [5, 8, 6, 8, 3, 8, 2])\nassert(intersperse(numbers:\
    \ [2, 2, 2], delimeter: 2) == [2, 2, 2, 2, 2])"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659978933
- exit_code: 0
  program: "\n/// Insert a number 'delimeter' between every two consecutive elements\
    \ of input array `numbers'\n/// >>> intersperse(numbers: [] as [Int], delimeter:\
    \ 4)\n/// [] as [Int]\n/// >>> intersperse(numbers: [1, 2, 3], delimeter: 4)\n\
    /// [1, 4, 2, 4, 3]\nfunc intersperse(numbers: [Int], delimeter: Int) -> [Int]\
    \ {\n    var result: [Int] = []\n    if numbers.count == 0 {\n        return []\n\
    \    } else if numbers.count == 1 {\n        return numbers\n    } else {\n  \
    \      for i in 0...numbers.count - 2 {\n            result.append(numbers[i])\n\
    \            result.append(delimeter)\n        }\n        result.append(numbers[numbers.count\
    \ - 1])\n        return result\n    }\n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(intersperse(numbers: [] as [Int], delimeter: 7) == [] as [Int])\nassert(intersperse(numbers:\
    \ [5, 6, 3, 2], delimeter: 8) == [5, 8, 6, 8, 3, 8, 2])\nassert(intersperse(numbers:\
    \ [2, 2, 2], delimeter: 2) == [2, 2, 2, 2, 2])"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659978933
- exit_code: 0
  program: "\n/// Insert a number 'delimeter' between every two consecutive elements\
    \ of input array `numbers'\n/// >>> intersperse(numbers: [] as [Int], delimeter:\
    \ 4)\n/// [] as [Int]\n/// >>> intersperse(numbers: [1, 2, 3], delimeter: 4)\n\
    /// [1, 4, 2, 4, 3]\nfunc intersperse(numbers: [Int], delimeter: Int) -> [Int]\
    \ {\n    guard numbers.count > 1 else { return numbers }\n    var result = [Int]()\n\
    \    var previous = numbers[0]\n    for current in numbers[1...] {\n        result.append(previous)\n\
    \        result.append(delimeter)\n        previous = current\n    }\n    result.append(previous)\n\
    \    return result\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) ->\
    \ Bool {\n    if left.count != right.count {\n        return false\n    }\n  \
    \  for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(intersperse(numbers:\
    \ [] as [Int], delimeter: 7) == [] as [Int])\nassert(intersperse(numbers: [5,\
    \ 6, 3, 2], delimeter: 8) == [5, 8, 6, 8, 3, 8, 2])\nassert(intersperse(numbers:\
    \ [2, 2, 2], delimeter: 2) == [2, 2, 2, 2, 2])"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659978933
- exit_code: 0
  program: "\n/// Insert a number 'delimeter' between every two consecutive elements\
    \ of input array `numbers'\n/// >>> intersperse(numbers: [] as [Int], delimeter:\
    \ 4)\n/// [] as [Int]\n/// >>> intersperse(numbers: [1, 2, 3], delimeter: 4)\n\
    /// [1, 4, 2, 4, 3]\nfunc intersperse(numbers: [Int], delimeter: Int) -> [Int]\
    \ {\n    let main = numbers.flatMap { [$0, delimeter] }\n    let result = main.dropLast()\n\
    \    return Array(result)\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(intersperse(numbers:\
    \ [] as [Int], delimeter: 7) == [] as [Int])\nassert(intersperse(numbers: [5,\
    \ 6, 3, 2], delimeter: 8) == [5, 8, 6, 8, 3, 8, 2])\nassert(intersperse(numbers:\
    \ [2, 2, 2], delimeter: 2) == [2, 2, 2, 2, 2])"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659978934
- exit_code: 0
  program: "\n/// Insert a number 'delimeter' between every two consecutive elements\
    \ of input array `numbers'\n/// >>> intersperse(numbers: [] as [Int], delimeter:\
    \ 4)\n/// [] as [Int]\n/// >>> intersperse(numbers: [1, 2, 3], delimeter: 4)\n\
    /// [1, 4, 2, 4, 3]\nfunc intersperse(numbers: [Int], delimeter: Int) -> [Int]\
    \ {\n    var result: [Int] = []\n    if numbers.count < 2 {\n        return numbers\n\
    \    }\n    for n in numbers {\n        result.append(n)\n        result.append(delimeter)\n\
    \    }\n    result.removeLast()\n    return result\n}\n\n\nfunc ==(left: [(Int,\
    \ Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n\
    \        return false\n    }\n    for (l, r) in zip(left, right) {\n        if\
    \ l != r {\n            return false\n        }\n    }\n    return true\n}\n \
    \           \nassert(intersperse(numbers: [] as [Int], delimeter: 7) == [] as\
    \ [Int])\nassert(intersperse(numbers: [5, 6, 3, 2], delimeter: 8) == [5, 8, 6,\
    \ 8, 3, 8, 2])\nassert(intersperse(numbers: [2, 2, 2], delimeter: 2) == [2, 2,\
    \ 2, 2, 2])"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659978934
- exit_code: 1
  program: "\n/// Insert a number 'delimeter' between every two consecutive elements\
    \ of input array `numbers'\n/// >>> intersperse(numbers: [] as [Int], delimeter:\
    \ 4)\n/// [] as [Int]\n/// >>> intersperse(numbers: [1, 2, 3], delimeter: 4)\n\
    /// [1, 4, 2, 4, 3]\nfunc intersperse(numbers: [Int], delimeter: Int) -> [Int]\
    \ {\n    return dropLast(reduce(zip(numbers, cycle([delimeter])), []) { $0 + [$1.0,\
    \ $1.1] })\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n\
    \    if left.count != right.count {\n        return false\n    }\n    for (l,\
    \ r) in zip(left, right) {\n        if l != r {\n            return false\n  \
    \      }\n    }\n    return true\n}\n            \nassert(intersperse(numbers:\
    \ [] as [Int], delimeter: 7) == [] as [Int])\nassert(intersperse(numbers: [5,\
    \ 6, 3, 2], delimeter: 8) == [5, 8, 6, 8, 3, 8, 2])\nassert(intersperse(numbers:\
    \ [2, 2, 2], delimeter: 2) == [2, 2, 2, 2, 2])"
  status: SyntaxError
  stderr: "/tmp/tmpbaichwau.swift:8:12: error: cannot find 'dropLast' in scope\n \
    \   return dropLast(reduce(zip(numbers, cycle([delimeter])), []) { $0 + [$1.0,\
    \ $1.1] })\n           ^~~~~~~~\n/tmp/tmpbaichwau.swift:8:21: error: cannot find\
    \ 'reduce' in scope\n    return dropLast(reduce(zip(numbers, cycle([delimeter])),\
    \ []) { $0 + [$1.0, $1.1] })\n                    ^~~~~~\n/tmp/tmpbaichwau.swift:8:41:\
    \ error: cannot find 'cycle' in scope\n    return dropLast(reduce(zip(numbers,\
    \ cycle([delimeter])), []) { $0 + [$1.0, $1.1] })\n                          \
    \              ^~~~~\n"
  stdout: ''
  timestamp: 1659978933
- exit_code: 0
  program: "\n/// Insert a number 'delimeter' between every two consecutive elements\
    \ of input array `numbers'\n/// >>> intersperse(numbers: [] as [Int], delimeter:\
    \ 4)\n/// [] as [Int]\n/// >>> intersperse(numbers: [1, 2, 3], delimeter: 4)\n\
    /// [1, 4, 2, 4, 3]\nfunc intersperse(numbers: [Int], delimeter: Int) -> [Int]\
    \ {\n\tlet length = numbers.count\n\tif length <= 1 {\n\t\treturn numbers\n\t\
    } else {\n\t\tvar result = [Int]()\n\t\tresult.append(numbers[0])\n\t\tfor i in\
    \ 1..<length {\n\t\t\tresult.append(delimeter)\n\t\t\tresult.append(numbers[i])\n\
    \t\t}\n\t\treturn result\n\t}\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int,\
    \ Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n\
    \    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n          \
    \  return false\n        }\n    }\n    return true\n}\n            \nassert(intersperse(numbers:\
    \ [] as [Int], delimeter: 7) == [] as [Int])\nassert(intersperse(numbers: [5,\
    \ 6, 3, 2], delimeter: 8) == [5, 8, 6, 8, 3, 8, 2])\nassert(intersperse(numbers:\
    \ [2, 2, 2], delimeter: 2) == [2, 2, 2, 2, 2])"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659978934
- exit_code: 0
  program: "\n/// Insert a number 'delimeter' between every two consecutive elements\
    \ of input array `numbers'\n/// >>> intersperse(numbers: [] as [Int], delimeter:\
    \ 4)\n/// [] as [Int]\n/// >>> intersperse(numbers: [1, 2, 3], delimeter: 4)\n\
    /// [1, 4, 2, 4, 3]\nfunc intersperse(numbers: [Int], delimeter: Int) -> [Int]\
    \ {\n    if numbers.isEmpty {\n        return []\n    }\n    var result = [Int]()\n\
    \    for i in 0..<numbers.count {\n        result.append(numbers[i])\n       \
    \ if i != numbers.count - 1 {\n            result.append(delimeter)\n        }\n\
    \    }\n    return result\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(intersperse(numbers:\
    \ [] as [Int], delimeter: 7) == [] as [Int])\nassert(intersperse(numbers: [5,\
    \ 6, 3, 2], delimeter: 8) == [5, 8, 6, 8, 3, 8, 2])\nassert(intersperse(numbers:\
    \ [2, 2, 2], delimeter: 2) == [2, 2, 2, 2, 2])"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659978934
- exit_code: 0
  program: "\n/// Insert a number 'delimeter' between every two consecutive elements\
    \ of input array `numbers'\n/// >>> intersperse(numbers: [] as [Int], delimeter:\
    \ 4)\n/// [] as [Int]\n/// >>> intersperse(numbers: [1, 2, 3], delimeter: 4)\n\
    /// [1, 4, 2, 4, 3]\nfunc intersperse(numbers: [Int], delimeter: Int) -> [Int]\
    \ {\n    if numbers.isEmpty {\n        return []\n    } else {\n        var result\
    \ = [Int]()\n        for i in 0..<numbers.count {\n            result.append(numbers[i])\n\
    \            if i < numbers.count - 1 {\n                result.append(delimeter)\n\
    \            }\n        }\n        return result\n    }\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(intersperse(numbers: [] as [Int], delimeter: 7) == []\
    \ as [Int])\nassert(intersperse(numbers: [5, 6, 3, 2], delimeter: 8) == [5, 8,\
    \ 6, 8, 3, 8, 2])\nassert(intersperse(numbers: [2, 2, 2], delimeter: 2) == [2,\
    \ 2, 2, 2, 2])"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659978933
- exit_code: 0
  program: "\n/// Insert a number 'delimeter' between every two consecutive elements\
    \ of input array `numbers'\n/// >>> intersperse(numbers: [] as [Int], delimeter:\
    \ 4)\n/// [] as [Int]\n/// >>> intersperse(numbers: [1, 2, 3], delimeter: 4)\n\
    /// [1, 4, 2, 4, 3]\nfunc intersperse(numbers: [Int], delimeter: Int) -> [Int]\
    \ {\n    if numbers.isEmpty {\n        return []\n    }\n    if numbers.count\
    \ == 1 {\n        return numbers\n    }\n    var result = [Int]()\n    var counter\
    \ = 0\n    while counter < numbers.count - 1 {\n        result.append(numbers[counter])\n\
    \        result.append(delimeter)\n        counter += 1\n    }\n    result.append(numbers[counter])\n\
    \    return result\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) ->\
    \ Bool {\n    if left.count != right.count {\n        return false\n    }\n  \
    \  for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(intersperse(numbers:\
    \ [] as [Int], delimeter: 7) == [] as [Int])\nassert(intersperse(numbers: [5,\
    \ 6, 3, 2], delimeter: 8) == [5, 8, 6, 8, 3, 8, 2])\nassert(intersperse(numbers:\
    \ [2, 2, 2], delimeter: 2) == [2, 2, 2, 2, 2])"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659978934
- exit_code: -4
  program: "\n/// Insert a number 'delimeter' between every two consecutive elements\
    \ of input array `numbers'\n/// >>> intersperse(numbers: [] as [Int], delimeter:\
    \ 4)\n/// [] as [Int]\n/// >>> intersperse(numbers: [1, 2, 3], delimeter: 4)\n\
    /// [1, 4, 2, 4, 3]\nfunc intersperse(numbers: [Int], delimeter: Int) -> [Int]\
    \ {\n    return numbers.reduce([], { [delimeter] + $0 + [$1] })\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(intersperse(numbers: [] as [Int], delimeter: 7) == []\
    \ as [Int])\nassert(intersperse(numbers: [5, 6, 3, 2], delimeter: 8) == [5, 8,\
    \ 6, 8, 3, 8, 2])\nassert(intersperse(numbers: [2, 2, 2], delimeter: 2) == [2,\
    \ 2, 2, 2, 2])"
  status: Exception
  stderr: 'tmpaie0g4xb/tmpaie0g4xb.swift:25: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002ac1ea0a1c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002ac1e9d98b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002ac1e9d98988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002ac1e9d977b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpaie0g4xb                        0x000056190e4c05af <unavailable> + 5551

    5    libc.so.6                          0x00002ac1ea28d460 __libc_start_main +
    245

    6    tmpaie0g4xb                        0x000056190e4c00a9 <unavailable> + 4265

    '
  stdout: ''
  timestamp: 1659978934
- exit_code: 1
  program: "\n/// Insert a number 'delimeter' between every two consecutive elements\
    \ of input array `numbers'\n/// >>> intersperse(numbers: [] as [Int], delimeter:\
    \ 4)\n/// [] as [Int]\n/// >>> intersperse(numbers: [1, 2, 3], delimeter: 4)\n\
    /// [1, 4, 2, 4, 3]\nfunc intersperse(numbers: [Int], delimeter: Int) -> [Int]\
    \ {\n    return (0..<numbers.count).reduce([]) { (var result, next) in\n     \
    \   result.append(numbers[next])\n        if next < numbers.count - 1 {\n    \
    \        result.append(delimeter)\n        }\n        return result\n    }\n}\n\
    \n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(intersperse(numbers: [] as [Int], delimeter: 7)\
    \ == [] as [Int])\nassert(intersperse(numbers: [5, 6, 3, 2], delimeter: 8) ==\
    \ [5, 8, 6, 8, 3, 8, 2])\nassert(intersperse(numbers: [2, 2, 2], delimeter: 2)\
    \ == [2, 2, 2, 2, 2])"
  status: SyntaxError
  stderr: "/tmp/tmp6cx9vc90.swift:8:46: error: closure cannot have keyword arguments\n\
    \    return (0..<numbers.count).reduce([]) { (var result, next) in\n         \
    \                                    ^~~~\n                                  \
    \           \n/tmp/tmp6cx9vc90.swift:9:16: error: cannot use mutating member on\
    \ immutable value: 'result' is a 'let' constant\n        result.append(numbers[next])\n\
    \        ~~~~~~ ^\n"
  stdout: ''
  timestamp: 1659978933
- exit_code: 0
  program: "\n/// Insert a number 'delimeter' between every two consecutive elements\
    \ of input array `numbers'\n/// >>> intersperse(numbers: [] as [Int], delimeter:\
    \ 4)\n/// [] as [Int]\n/// >>> intersperse(numbers: [1, 2, 3], delimeter: 4)\n\
    /// [1, 4, 2, 4, 3]\nfunc intersperse(numbers: [Int], delimeter: Int) -> [Int]\
    \ {\n    guard numbers.count > 1 else { return numbers }\n    var interspersed:\
    \ [Int] = []\n    for index in 0 ..< numbers.count - 1 {\n        interspersed.append(numbers[index])\n\
    \        interspersed.append(delimeter)\n    }\n    interspersed.append(numbers.last!)\n\
    \    return interspersed\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(intersperse(numbers:\
    \ [] as [Int], delimeter: 7) == [] as [Int])\nassert(intersperse(numbers: [5,\
    \ 6, 3, 2], delimeter: 8) == [5, 8, 6, 8, 3, 8, 2])\nassert(intersperse(numbers:\
    \ [2, 2, 2], delimeter: 2) == [2, 2, 2, 2, 2])"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659978934
- exit_code: -4
  program: "\n/// Insert a number 'delimeter' between every two consecutive elements\
    \ of input array `numbers'\n/// >>> intersperse(numbers: [] as [Int], delimeter:\
    \ 4)\n/// [] as [Int]\n/// >>> intersperse(numbers: [1, 2, 3], delimeter: 4)\n\
    /// [1, 4, 2, 4, 3]\nfunc intersperse(numbers: [Int], delimeter: Int) -> [Int]\
    \ {\n    if numbers.isEmpty {\n        return []\n    } else {\n        let first\
    \ = numbers[0]\n        let rest = Array(numbers[1..<numbers.count])\n       \
    \ return [first] + [delimeter] + intersperse(numbers: rest, delimeter: delimeter)\n\
    \    }\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n  \
    \  if left.count != right.count {\n        return false\n    }\n    for (l, r)\
    \ in zip(left, right) {\n        if l != r {\n            return false\n     \
    \   }\n    }\n    return true\n}\n            \nassert(intersperse(numbers: []\
    \ as [Int], delimeter: 7) == [] as [Int])\nassert(intersperse(numbers: [5, 6,\
    \ 3, 2], delimeter: 8) == [5, 8, 6, 8, 3, 8, 2])\nassert(intersperse(numbers:\
    \ [2, 2, 2], delimeter: 2) == [2, 2, 2, 2, 2])"
  status: Exception
  stderr: 'tmptd49am8p/tmptd49am8p.swift:31: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b0d787cbc80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b0d784c2b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b0d784c2988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b0d784c17b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmptd49am8p                        0x00005651cdb7f85f <unavailable> + 6239

    5    libc.so.6                          0x00002b0d789b7460 __libc_start_main +
    245

    6    tmptd49am8p                        0x00005651cdb7f359 <unavailable> + 4953

    '
  stdout: ''
  timestamp: 1659978932
- exit_code: 0
  program: "\n/// Insert a number 'delimeter' between every two consecutive elements\
    \ of input array `numbers'\n/// >>> intersperse(numbers: [] as [Int], delimeter:\
    \ 4)\n/// [] as [Int]\n/// >>> intersperse(numbers: [1, 2, 3], delimeter: 4)\n\
    /// [1, 4, 2, 4, 3]\nfunc intersperse(numbers: [Int], delimeter: Int) -> [Int]\
    \ {\n    var interspersed: [Int] = []\n    for i in 0..<numbers.count {\n    \
    \    if i != 0 {\n            interspersed.append(delimeter)\n        }\n    \
    \    interspersed.append(numbers[i])\n    }\n    return interspersed\n}\n\n\n\
    func ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(intersperse(numbers: [] as [Int], delimeter: 7)\
    \ == [] as [Int])\nassert(intersperse(numbers: [5, 6, 3, 2], delimeter: 8) ==\
    \ [5, 8, 6, 8, 3, 8, 2])\nassert(intersperse(numbers: [2, 2, 2], delimeter: 2)\
    \ == [2, 2, 2, 2, 2])"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659978934
- exit_code: 0
  program: "\n/// Insert a number 'delimeter' between every two consecutive elements\
    \ of input array `numbers'\n/// >>> intersperse(numbers: [] as [Int], delimeter:\
    \ 4)\n/// [] as [Int]\n/// >>> intersperse(numbers: [1, 2, 3], delimeter: 4)\n\
    /// [1, 4, 2, 4, 3]\nfunc intersperse(numbers: [Int], delimeter: Int) -> [Int]\
    \ {\n    if numbers.isEmpty {\n        return []\n    } else {\n        var res:\
    \ [Int] = []\n        for i in 0..<numbers.count - 1 {\n            res.append(numbers[i])\n\
    \            res.append(delimeter)\n        }\n        res.append(numbers[numbers.count\
    \ - 1])\n        return res\n    }\n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(intersperse(numbers: [] as [Int], delimeter: 7) == [] as [Int])\nassert(intersperse(numbers:\
    \ [5, 6, 3, 2], delimeter: 8) == [5, 8, 6, 8, 3, 8, 2])\nassert(intersperse(numbers:\
    \ [2, 2, 2], delimeter: 2) == [2, 2, 2, 2, 2])"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659978934
- exit_code: 0
  program: "\n/// Insert a number 'delimeter' between every two consecutive elements\
    \ of input array `numbers'\n/// >>> intersperse(numbers: [] as [Int], delimeter:\
    \ 4)\n/// [] as [Int]\n/// >>> intersperse(numbers: [1, 2, 3], delimeter: 4)\n\
    /// [1, 4, 2, 4, 3]\nfunc intersperse(numbers: [Int], delimeter: Int) -> [Int]\
    \ {\n    if numbers.isEmpty {\n        return []\n    } else {\n        var result\
    \ = [Int]()\n        for index in 0..<numbers.count {\n            result.append(numbers[index])\n\
    \            if index != numbers.count - 1 {\n                result.append(delimeter)\n\
    \            }\n        }\n        return result\n    }\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(intersperse(numbers: [] as [Int], delimeter: 7) == []\
    \ as [Int])\nassert(intersperse(numbers: [5, 6, 3, 2], delimeter: 8) == [5, 8,\
    \ 6, 8, 3, 8, 2])\nassert(intersperse(numbers: [2, 2, 2], delimeter: 2) == [2,\
    \ 2, 2, 2, 2])"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659978934
