language: swift
name: HumanEval_119_match_parens
results:
- exit_code: 1
  program: "\n/// You are given an array of two strings, both strings consist of open\n\
    /// parentheses '(' or close parentheses ')' only.\n/// Your job is to check if\
    \ it is possible to concatenate the two strings in\n/// some order, that the resulting\
    \ string will be good.\n/// A string S is considered to be good if and only if\
    \ all parentheses in S\n/// are balanced. For example: the string '(())()' is\
    \ good, while the string\n/// '())' is not.\n/// Return 'Yes' if there's a way\
    \ to make a good string, and return 'No' otherwise.\n/// Examples:\n/// >>> match_parens(lst:\
    \ [\"()(\", \")\"])\n/// \"Yes\"\n/// >>> match_parens(lst: [\")\", \")\"])\n\
    /// \"No\"\nfunc match_parens(lst: [String]) -> String {\n    var s1 = lst[0]\n\
    \    var s2 = lst[1]\n    var good_flag = false\n    let l1 = lst[0].count\n \
    \   let l2 = lst[1].count\n    for i in 0..<l1 {\n        for j in 0..<l2 {\n\
    \            var s1i = s1[i]\n            var s2j = s2[j]\n            s1[i] =\
    \ s2[j]\n            s2[j] = s1i\n            if is_balanced(s: s1) && is_balanced(s:\
    \ s2) {\n                good_flag = true\n            }\n            s1[i] =\
    \ s1i\n            s2[j] = s2j\n        }\n    }\n    if good_flag {\n       \
    \ return \"Yes\"\n    } else {\n        return \"No\"\n    }\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(match_parens(lst: [\"()(\", \")\"]) == \"Yes\")\nassert(match_parens(lst:\
    \ [\")\", \")\"]) == \"No\")\nassert(match_parens(lst: [\"(()(())\", \"())())\"\
    ]) == \"No\")\nassert(match_parens(lst: [\")())\", \"(()()(\"]) == \"Yes\")\n\
    assert(match_parens(lst: [\"(())))\", \"(()())((\"]) == \"Yes\")\nassert(match_parens(lst:\
    \ [\"()\", \"())\"]) == \"No\")\nassert(match_parens(lst: [\"(()(\", \"()))()\"\
    ]) == \"Yes\")\nassert(match_parens(lst: [\"((((\", \"((())\"]) == \"No\")\nassert(match_parens(lst:\
    \ [\")(()\", \"(()(\"]) == \"No\")\nassert(match_parens(lst: [\")(\", \")(\"])\
    \ == \"No\")\nassert(match_parens(lst: [\"(\", \")\"]) == \"Yes\")\nassert(match_parens(lst:\
    \ [\")\", \"(\"]) == \"Yes\")"
  status: SyntaxError
  stderr: "/tmp/tmpij2x5omr.swift:23:23: error: 'subscript(_:)' is unavailable: cannot\
    \ subscript String with an Int, use a String.Index instead.\n            var s1i\
    \ = s1[i]\n                      ^~~~~\nSwift.String:3:12: note: 'subscript(_:)'\
    \ has been explicitly marked unavailable here\n    public subscript(i: Int) ->\
    \ Character { get }\n           ^\n/tmp/tmpij2x5omr.swift:24:23: error: 'subscript(_:)'\
    \ is unavailable: cannot subscript String with an Int, use a String.Index instead.\n\
    \            var s2j = s2[j]\n                      ^~~~~\nSwift.String:3:12:\
    \ note: 'subscript(_:)' has been explicitly marked unavailable here\n    public\
    \ subscript(i: Int) -> Character { get }\n           ^\n/tmp/tmpij2x5omr.swift:25:15:\
    \ error: cannot assign through subscript: subscript is get-only\n            s1[i]\
    \ = s2[j]\n            ~~^~~\n/tmp/tmpij2x5omr.swift:26:15: error: cannot assign\
    \ through subscript: subscript is get-only\n            s2[j] = s1i\n        \
    \    ~~^~~\n/tmp/tmpij2x5omr.swift:27:16: error: cannot find 'is_balanced' in\
    \ scope\n            if is_balanced(s: s1) && is_balanced(s: s2) {\n         \
    \      ^~~~~~~~~~~\n/tmp/tmpij2x5omr.swift:27:38: error: cannot find 'is_balanced'\
    \ in scope\n            if is_balanced(s: s1) && is_balanced(s: s2) {\n      \
    \                               ^~~~~~~~~~~\n/tmp/tmpij2x5omr.swift:30:15: error:\
    \ cannot assign through subscript: subscript is get-only\n            s1[i] =\
    \ s1i\n            ~~^~~\n/tmp/tmpij2x5omr.swift:31:15: error: cannot assign through\
    \ subscript: subscript is get-only\n            s2[j] = s2j\n            ~~^~~\n"
  stdout: ''
  timestamp: 1659979531
- exit_code: 1
  program: "\n/// You are given an array of two strings, both strings consist of open\n\
    /// parentheses '(' or close parentheses ')' only.\n/// Your job is to check if\
    \ it is possible to concatenate the two strings in\n/// some order, that the resulting\
    \ string will be good.\n/// A string S is considered to be good if and only if\
    \ all parentheses in S\n/// are balanced. For example: the string '(())()' is\
    \ good, while the string\n/// '())' is not.\n/// Return 'Yes' if there's a way\
    \ to make a good string, and return 'No' otherwise.\n/// Examples:\n/// >>> match_parens(lst:\
    \ [\"()(\", \")\"])\n/// \"Yes\"\n/// >>> match_parens(lst: [\")\", \")\"])\n\
    /// \"No\"\nfunc match_parens(lst: [String]) -> String {\n    if lst.count !=\
    \ 2 { return \"No\" }\n    var first = lst[0], second = lst[1]\n    if first.count\
    \ > second.count {\n        first = lst[1]\n        second = lst[0]\n    }\n \
    \   let count = balance_parens(str: first + second)\n    return count == 0 ? \"\
    Yes\" : \"No\"\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool\
    \ {\n    if left.count != right.count {\n        return false\n    }\n    for\
    \ (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(match_parens(lst:\
    \ [\"()(\", \")\"]) == \"Yes\")\nassert(match_parens(lst: [\")\", \")\"]) == \"\
    No\")\nassert(match_parens(lst: [\"(()(())\", \"())())\"]) == \"No\")\nassert(match_parens(lst:\
    \ [\")())\", \"(()()(\"]) == \"Yes\")\nassert(match_parens(lst: [\"(())))\", \"\
    (()())((\"]) == \"Yes\")\nassert(match_parens(lst: [\"()\", \"())\"]) == \"No\"\
    )\nassert(match_parens(lst: [\"(()(\", \"()))()\"]) == \"Yes\")\nassert(match_parens(lst:\
    \ [\"((((\", \"((())\"]) == \"No\")\nassert(match_parens(lst: [\")(()\", \"(()(\"\
    ]) == \"No\")\nassert(match_parens(lst: [\")(\", \")(\"]) == \"No\")\nassert(match_parens(lst:\
    \ [\"(\", \")\"]) == \"Yes\")\nassert(match_parens(lst: [\")\", \"(\"]) == \"\
    Yes\")"
  status: SyntaxError
  stderr: "/tmp/tmpab6iixmj.swift:22:17: error: cannot find 'balance_parens' in scope\n\
    \    let count = balance_parens(str: first + second)\n                ^~~~~~~~~~~~~~\n"
  stdout: ''
  timestamp: 1659979531
- exit_code: -4
  program: "\n/// You are given an array of two strings, both strings consist of open\n\
    /// parentheses '(' or close parentheses ')' only.\n/// Your job is to check if\
    \ it is possible to concatenate the two strings in\n/// some order, that the resulting\
    \ string will be good.\n/// A string S is considered to be good if and only if\
    \ all parentheses in S\n/// are balanced. For example: the string '(())()' is\
    \ good, while the string\n/// '())' is not.\n/// Return 'Yes' if there's a way\
    \ to make a good string, and return 'No' otherwise.\n/// Examples:\n/// >>> match_parens(lst:\
    \ [\"()(\", \")\"])\n/// \"Yes\"\n/// >>> match_parens(lst: [\")\", \")\"])\n\
    /// \"No\"\nfunc match_parens(lst: [String]) -> String {\n  var cnt = 0\n  for\
    \ s in lst {\n    for c in s {\n      cnt += c == \"(\" ? 1 : -1\n      if cnt\
    \ < 0 { return \"No\" }\n    }\n  }\n  return cnt == 0 ? \"Yes\" : \"No\"\n}\n\
    \n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(match_parens(lst: [\"()(\", \")\"]) == \"Yes\"\
    )\nassert(match_parens(lst: [\")\", \")\"]) == \"No\")\nassert(match_parens(lst:\
    \ [\"(()(())\", \"())())\"]) == \"No\")\nassert(match_parens(lst: [\")())\", \"\
    (()()(\"]) == \"Yes\")\nassert(match_parens(lst: [\"(())))\", \"(()())((\"]) ==\
    \ \"Yes\")\nassert(match_parens(lst: [\"()\", \"())\"]) == \"No\")\nassert(match_parens(lst:\
    \ [\"(()(\", \"()))()\"]) == \"Yes\")\nassert(match_parens(lst: [\"((((\", \"\
    ((())\"]) == \"No\")\nassert(match_parens(lst: [\")(()\", \"(()(\"]) == \"No\"\
    )\nassert(match_parens(lst: [\")(\", \")(\"]) == \"No\")\nassert(match_parens(lst:\
    \ [\"(\", \")\"]) == \"Yes\")\nassert(match_parens(lst: [\")\", \"(\"]) == \"\
    Yes\")"
  status: Exception
  stderr: 'tmpijpbubxy/tmpijpbubxy.swift:42: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b0199283c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b0198f7ab6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b0198f7a988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b0198f797b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpijpbubxy                        0x0000562824d2ac36 <unavailable> + 7222

    5    libc.so.6                          0x00002b019946f460 __libc_start_main +
    245

    6    tmpijpbubxy                        0x0000562824d2a399 <unavailable> + 5017

    '
  stdout: ''
  timestamp: 1659979532
- exit_code: -4
  program: "\n/// You are given an array of two strings, both strings consist of open\n\
    /// parentheses '(' or close parentheses ')' only.\n/// Your job is to check if\
    \ it is possible to concatenate the two strings in\n/// some order, that the resulting\
    \ string will be good.\n/// A string S is considered to be good if and only if\
    \ all parentheses in S\n/// are balanced. For example: the string '(())()' is\
    \ good, while the string\n/// '())' is not.\n/// Return 'Yes' if there's a way\
    \ to make a good string, and return 'No' otherwise.\n/// Examples:\n/// >>> match_parens(lst:\
    \ [\"()(\", \")\"])\n/// \"Yes\"\n/// >>> match_parens(lst: [\")\", \")\"])\n\
    /// \"No\"\nfunc match_parens(lst: [String]) -> String {\n    var str = lst[0]\
    \ + lst[1]\n    var left: Int = 0\n    var right: Int = 0\n    for paren in str\
    \ {\n        if paren == \"(\" {\n            left += 1\n        } else {\n  \
    \          right += 1\n        }\n        if right > left {\n            return\
    \ \"No\"\n        }\n    }\n    if left == right {\n        return \"Yes\"\n \
    \   }\n    return \"No\"\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(match_parens(lst:\
    \ [\"()(\", \")\"]) == \"Yes\")\nassert(match_parens(lst: [\")\", \")\"]) == \"\
    No\")\nassert(match_parens(lst: [\"(()(())\", \"())())\"]) == \"No\")\nassert(match_parens(lst:\
    \ [\")())\", \"(()()(\"]) == \"Yes\")\nassert(match_parens(lst: [\"(())))\", \"\
    (()())((\"]) == \"Yes\")\nassert(match_parens(lst: [\"()\", \"())\"]) == \"No\"\
    )\nassert(match_parens(lst: [\"(()(\", \"()))()\"]) == \"Yes\")\nassert(match_parens(lst:\
    \ [\"((((\", \"((())\"]) == \"No\")\nassert(match_parens(lst: [\")(()\", \"(()(\"\
    ]) == \"No\")\nassert(match_parens(lst: [\")(\", \")(\"]) == \"No\")\nassert(match_parens(lst:\
    \ [\"(\", \")\"]) == \"Yes\")\nassert(match_parens(lst: [\")\", \"(\"]) == \"\
    Yes\")"
  status: Exception
  stderr: 'tmphyetgrfh/tmphyetgrfh.swift:51: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b77ea664c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b77ea35bb6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b77ea35b988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b77ea35a7b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmphyetgrfh                        0x000055d1021c0b76 <unavailable> + 7030

    5    libc.so.6                          0x00002b77ea850460 __libc_start_main +
    245

    6    tmphyetgrfh                        0x000055d1021c02d9 <unavailable> + 4825

    '
  stdout: ''
  timestamp: 1659979532
- exit_code: -4
  program: "\n/// You are given an array of two strings, both strings consist of open\n\
    /// parentheses '(' or close parentheses ')' only.\n/// Your job is to check if\
    \ it is possible to concatenate the two strings in\n/// some order, that the resulting\
    \ string will be good.\n/// A string S is considered to be good if and only if\
    \ all parentheses in S\n/// are balanced. For example: the string '(())()' is\
    \ good, while the string\n/// '())' is not.\n/// Return 'Yes' if there's a way\
    \ to make a good string, and return 'No' otherwise.\n/// Examples:\n/// >>> match_parens(lst:\
    \ [\"()(\", \")\"])\n/// \"Yes\"\n/// >>> match_parens(lst: [\")\", \")\"])\n\
    /// \"No\"\nfunc match_parens(lst: [String]) -> String {\n    var parens = \"\"\
    \n    for parenthesis in lst {\n        parens += parenthesis\n    }\n    var\
    \ sum = 0\n    for char in parens {\n        if char == \"(\" {\n            sum\
    \ += 1\n        } else {\n            sum -= 1\n        }\n        if sum < 0\
    \ {\n            return \"No\"\n        }\n    }\n    return sum == 0 ? \"Yes\"\
    \ : \"No\"\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n\
    \    if left.count != right.count {\n        return false\n    }\n    for (l,\
    \ r) in zip(left, right) {\n        if l != r {\n            return false\n  \
    \      }\n    }\n    return true\n}\n            \nassert(match_parens(lst: [\"\
    ()(\", \")\"]) == \"Yes\")\nassert(match_parens(lst: [\")\", \")\"]) == \"No\"\
    )\nassert(match_parens(lst: [\"(()(())\", \"())())\"]) == \"No\")\nassert(match_parens(lst:\
    \ [\")())\", \"(()()(\"]) == \"Yes\")\nassert(match_parens(lst: [\"(())))\", \"\
    (()())((\"]) == \"Yes\")\nassert(match_parens(lst: [\"()\", \"())\"]) == \"No\"\
    )\nassert(match_parens(lst: [\"(()(\", \"()))()\"]) == \"Yes\")\nassert(match_parens(lst:\
    \ [\"((((\", \"((())\"]) == \"No\")\nassert(match_parens(lst: [\")(()\", \"(()(\"\
    ]) == \"No\")\nassert(match_parens(lst: [\")(\", \")(\"]) == \"No\")\nassert(match_parens(lst:\
    \ [\"(\", \")\"]) == \"Yes\")\nassert(match_parens(lst: [\")\", \"(\"]) == \"\
    Yes\")"
  status: Exception
  stderr: 'tmpdvr70js2/tmpdvr70js2.swift:50: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002ae1c5e1ac80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002ae1c5b11b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002ae1c5b11988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002ae1c5b107b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpdvr70js2                        0x000055f9665c9c96 <unavailable> + 7318

    5    libc.so.6                          0x00002ae1c6006460 __libc_start_main +
    245

    6    tmpdvr70js2                        0x000055f9665c93f9 <unavailable> + 5113

    '
  stdout: ''
  timestamp: 1659979532
- exit_code: 1
  program: "\n/// You are given an array of two strings, both strings consist of open\n\
    /// parentheses '(' or close parentheses ')' only.\n/// Your job is to check if\
    \ it is possible to concatenate the two strings in\n/// some order, that the resulting\
    \ string will be good.\n/// A string S is considered to be good if and only if\
    \ all parentheses in S\n/// are balanced. For example: the string '(())()' is\
    \ good, while the string\n/// '())' is not.\n/// Return 'Yes' if there's a way\
    \ to make a good string, and return 'No' otherwise.\n/// Examples:\n/// >>> match_parens(lst:\
    \ [\"()(\", \")\"])\n/// \"Yes\"\n/// >>> match_parens(lst: [\")\", \")\"])\n\
    /// \"No\"\nfunc match_parens(lst: [String]) -> String {\n    var s = \"\"\n \
    \   for str in lst {\n        s += str\n    }\n    return parens_match(s: s) ?\
    \ \"Yes\" : \"No\"\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) ->\
    \ Bool {\n    if left.count != right.count {\n        return false\n    }\n  \
    \  for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(match_parens(lst:\
    \ [\"()(\", \")\"]) == \"Yes\")\nassert(match_parens(lst: [\")\", \")\"]) == \"\
    No\")\nassert(match_parens(lst: [\"(()(())\", \"())())\"]) == \"No\")\nassert(match_parens(lst:\
    \ [\")())\", \"(()()(\"]) == \"Yes\")\nassert(match_parens(lst: [\"(())))\", \"\
    (()())((\"]) == \"Yes\")\nassert(match_parens(lst: [\"()\", \"())\"]) == \"No\"\
    )\nassert(match_parens(lst: [\"(()(\", \"()))()\"]) == \"Yes\")\nassert(match_parens(lst:\
    \ [\"((((\", \"((())\"]) == \"No\")\nassert(match_parens(lst: [\")(()\", \"(()(\"\
    ]) == \"No\")\nassert(match_parens(lst: [\")(\", \")(\"]) == \"No\")\nassert(match_parens(lst:\
    \ [\"(\", \")\"]) == \"Yes\")\nassert(match_parens(lst: [\")\", \"(\"]) == \"\
    Yes\")"
  status: SyntaxError
  stderr: "/tmp/tmpl_c77lvk.swift:20:12: error: cannot find 'parens_match' in scope\n\
    \    return parens_match(s: s) ? \"Yes\" : \"No\"\n           ^~~~~~~~~~~~\n"
  stdout: ''
  timestamp: 1659979531
- exit_code: -4
  program: "\n/// You are given an array of two strings, both strings consist of open\n\
    /// parentheses '(' or close parentheses ')' only.\n/// Your job is to check if\
    \ it is possible to concatenate the two strings in\n/// some order, that the resulting\
    \ string will be good.\n/// A string S is considered to be good if and only if\
    \ all parentheses in S\n/// are balanced. For example: the string '(())()' is\
    \ good, while the string\n/// '())' is not.\n/// Return 'Yes' if there's a way\
    \ to make a good string, and return 'No' otherwise.\n/// Examples:\n/// >>> match_parens(lst:\
    \ [\"()(\", \")\"])\n/// \"Yes\"\n/// >>> match_parens(lst: [\")\", \")\"])\n\
    /// \"No\"\nfunc match_parens(lst: [String]) -> String {\n    return \"Your solution\
    \ here\"\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n\
    \    if left.count != right.count {\n        return false\n    }\n    for (l,\
    \ r) in zip(left, right) {\n        if l != r {\n            return false\n  \
    \      }\n    }\n    return true\n}\n            \nassert(match_parens(lst: [\"\
    ()(\", \")\"]) == \"Yes\")\nassert(match_parens(lst: [\")\", \")\"]) == \"No\"\
    )\nassert(match_parens(lst: [\"(()(())\", \"())())\"]) == \"No\")\nassert(match_parens(lst:\
    \ [\")())\", \"(()()(\"]) == \"Yes\")\nassert(match_parens(lst: [\"(())))\", \"\
    (()())((\"]) == \"Yes\")\nassert(match_parens(lst: [\"()\", \"())\"]) == \"No\"\
    )\nassert(match_parens(lst: [\"(()(\", \"()))()\"]) == \"Yes\")\nassert(match_parens(lst:\
    \ [\"((((\", \"((())\"]) == \"No\")\nassert(match_parens(lst: [\")(()\", \"(()(\"\
    ]) == \"No\")\nassert(match_parens(lst: [\")(\", \")(\"]) == \"No\")\nassert(match_parens(lst:\
    \ [\"(\", \")\"]) == \"Yes\")\nassert(match_parens(lst: [\")\", \"(\"]) == \"\
    Yes\")"
  status: Exception
  stderr: 'tmprvej47a2/tmprvej47a2.swift:32: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002ba6b97b3c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002ba6b94aab6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002ba6b94aa988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002ba6b94a97b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmprvej47a2                        0x00005592fd7104a6 <unavailable> + 5286

    5    libc.so.6                          0x00002ba6b999f460 __libc_start_main +
    245

    6    tmprvej47a2                        0x00005592fd710089 <unavailable> + 4233

    '
  stdout: ''
  timestamp: 1659979532
- exit_code: -4
  program: "\n/// You are given an array of two strings, both strings consist of open\n\
    /// parentheses '(' or close parentheses ')' only.\n/// Your job is to check if\
    \ it is possible to concatenate the two strings in\n/// some order, that the resulting\
    \ string will be good.\n/// A string S is considered to be good if and only if\
    \ all parentheses in S\n/// are balanced. For example: the string '(())()' is\
    \ good, while the string\n/// '())' is not.\n/// Return 'Yes' if there's a way\
    \ to make a good string, and return 'No' otherwise.\n/// Examples:\n/// >>> match_parens(lst:\
    \ [\"()(\", \")\"])\n/// \"Yes\"\n/// >>> match_parens(lst: [\")\", \")\"])\n\
    /// \"No\"\nfunc match_parens(lst: [String]) -> String {\n  return \"\"\n}\n\n\
    \nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(match_parens(lst: [\"()(\", \")\"]) == \"Yes\"\
    )\nassert(match_parens(lst: [\")\", \")\"]) == \"No\")\nassert(match_parens(lst:\
    \ [\"(()(())\", \"())())\"]) == \"No\")\nassert(match_parens(lst: [\")())\", \"\
    (()()(\"]) == \"Yes\")\nassert(match_parens(lst: [\"(())))\", \"(()())((\"]) ==\
    \ \"Yes\")\nassert(match_parens(lst: [\"()\", \"())\"]) == \"No\")\nassert(match_parens(lst:\
    \ [\"(()(\", \"()))()\"]) == \"Yes\")\nassert(match_parens(lst: [\"((((\", \"\
    ((())\"]) == \"No\")\nassert(match_parens(lst: [\")(()\", \"(()(\"]) == \"No\"\
    )\nassert(match_parens(lst: [\")(\", \")(\"]) == \"No\")\nassert(match_parens(lst:\
    \ [\"(\", \")\"]) == \"Yes\")\nassert(match_parens(lst: [\")\", \"(\"]) == \"\
    Yes\")"
  status: Exception
  stderr: 'tmphakfwh0m/tmphakfwh0m.swift:32: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002ad451e42c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002ad451b39b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002ad451b39988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002ad451b387b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmphakfwh0m                        0x000055b2eb7084a6 <unavailable> + 5286

    5    libc.so.6                          0x00002ad45202e460 __libc_start_main +
    245

    6    tmphakfwh0m                        0x000055b2eb708089 <unavailable> + 4233

    '
  stdout: ''
  timestamp: 1659979532
- exit_code: -4
  program: "\n/// You are given an array of two strings, both strings consist of open\n\
    /// parentheses '(' or close parentheses ')' only.\n/// Your job is to check if\
    \ it is possible to concatenate the two strings in\n/// some order, that the resulting\
    \ string will be good.\n/// A string S is considered to be good if and only if\
    \ all parentheses in S\n/// are balanced. For example: the string '(())()' is\
    \ good, while the string\n/// '())' is not.\n/// Return 'Yes' if there's a way\
    \ to make a good string, and return 'No' otherwise.\n/// Examples:\n/// >>> match_parens(lst:\
    \ [\"()(\", \")\"])\n/// \"Yes\"\n/// >>> match_parens(lst: [\")\", \")\"])\n\
    /// \"No\"\nfunc match_parens(lst: [String]) -> String {\n    let good_chars =\
    \ lst.reduce(\"\", +)\n    let good_chars_count = good_chars.filter { $0 == \"\
    (\" }.count\n    let valid_count = good_chars.count - good_chars_count * 2\n \
    \   return valid_count == 0 ? \"Yes\" : \"No\"\n}\n\n\nfunc ==(left: [(Int, Int)],\
    \ right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n       \
    \ return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r\
    \ {\n            return false\n        }\n    }\n    return true\n}\n        \
    \    \nassert(match_parens(lst: [\"()(\", \")\"]) == \"Yes\")\nassert(match_parens(lst:\
    \ [\")\", \")\"]) == \"No\")\nassert(match_parens(lst: [\"(()(())\", \"())())\"\
    ]) == \"No\")\nassert(match_parens(lst: [\")())\", \"(()()(\"]) == \"Yes\")\n\
    assert(match_parens(lst: [\"(())))\", \"(()())((\"]) == \"Yes\")\nassert(match_parens(lst:\
    \ [\"()\", \"())\"]) == \"No\")\nassert(match_parens(lst: [\"(()(\", \"()))()\"\
    ]) == \"Yes\")\nassert(match_parens(lst: [\"((((\", \"((())\"]) == \"No\")\nassert(match_parens(lst:\
    \ [\")(()\", \"(()(\"]) == \"No\")\nassert(match_parens(lst: [\")(\", \")(\"])\
    \ == \"No\")\nassert(match_parens(lst: [\"(\", \")\"]) == \"Yes\")\nassert(match_parens(lst:\
    \ [\")\", \"(\"]) == \"Yes\")"
  status: Exception
  stderr: 'tmpu6bllrak/tmpu6bllrak.swift:44: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002ac5996d1c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002ac5993c8b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002ac5993c8988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002ac5993c77b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpu6bllrak                        0x00005563db089508 <unavailable> + 9480

    5    libc.so.6                          0x00002ac5998bd460 __libc_start_main +
    245

    6    tmpu6bllrak                        0x00005563db088329 <unavailable> + 4905

    '
  stdout: ''
  timestamp: 1659979532
- exit_code: -4
  program: "\n/// You are given an array of two strings, both strings consist of open\n\
    /// parentheses '(' or close parentheses ')' only.\n/// Your job is to check if\
    \ it is possible to concatenate the two strings in\n/// some order, that the resulting\
    \ string will be good.\n/// A string S is considered to be good if and only if\
    \ all parentheses in S\n/// are balanced. For example: the string '(())()' is\
    \ good, while the string\n/// '())' is not.\n/// Return 'Yes' if there's a way\
    \ to make a good string, and return 'No' otherwise.\n/// Examples:\n/// >>> match_parens(lst:\
    \ [\"()(\", \")\"])\n/// \"Yes\"\n/// >>> match_parens(lst: [\")\", \")\"])\n\
    /// \"No\"\nfunc match_parens(lst: [String]) -> String {\n    // TODO: implement\n\
    \    return \"Yes\"\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) ->\
    \ Bool {\n    if left.count != right.count {\n        return false\n    }\n  \
    \  for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(match_parens(lst:\
    \ [\"()(\", \")\"]) == \"Yes\")\nassert(match_parens(lst: [\")\", \")\"]) == \"\
    No\")\nassert(match_parens(lst: [\"(()(())\", \"())())\"]) == \"No\")\nassert(match_parens(lst:\
    \ [\")())\", \"(()()(\"]) == \"Yes\")\nassert(match_parens(lst: [\"(())))\", \"\
    (()())((\"]) == \"Yes\")\nassert(match_parens(lst: [\"()\", \"())\"]) == \"No\"\
    )\nassert(match_parens(lst: [\"(()(\", \"()))()\"]) == \"Yes\")\nassert(match_parens(lst:\
    \ [\"((((\", \"((())\"]) == \"No\")\nassert(match_parens(lst: [\")(()\", \"(()(\"\
    ]) == \"No\")\nassert(match_parens(lst: [\")(\", \")(\"]) == \"No\")\nassert(match_parens(lst:\
    \ [\"(\", \")\"]) == \"Yes\")\nassert(match_parens(lst: [\")\", \"(\"]) == \"\
    Yes\")"
  status: Exception
  stderr: 'tmpivnbcyur/tmpivnbcyur.swift:34: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b09baccdc80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b09ba9c4b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b09ba9c4988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b09ba9c37b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpivnbcyur                        0x0000558e0edf2610 <unavailable> + 5648

    5    libc.so.6                          0x00002b09baeb9460 __libc_start_main +
    245

    6    tmpivnbcyur                        0x0000558e0edf2089 <unavailable> + 4233

    '
  stdout: ''
  timestamp: 1659979532
- exit_code: 1
  program: "\n/// You are given an array of two strings, both strings consist of open\n\
    /// parentheses '(' or close parentheses ')' only.\n/// Your job is to check if\
    \ it is possible to concatenate the two strings in\n/// some order, that the resulting\
    \ string will be good.\n/// A string S is considered to be good if and only if\
    \ all parentheses in S\n/// are balanced. For example: the string '(())()' is\
    \ good, while the string\n/// '())' is not.\n/// Return 'Yes' if there's a way\
    \ to make a good string, and return 'No' otherwise.\n/// Examples:\n/// >>> match_parens(lst:\
    \ [\"()(\", \")\"])\n/// \"Yes\"\n/// >>> match_parens(lst: [\")\", \")\"])\n\
    /// \"No\"\nfunc match_parens(lst: [String]) -> String {\n    let left: String\
    \ = lst[0]\n    let right: String = lst[1]\n    if (has_matching_parens(string:\
    \ left) && has_matching_parens(string: right)) {\n        return \"Yes\"\n   \
    \ }\n    return \"No\"\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(match_parens(lst:\
    \ [\"()(\", \")\"]) == \"Yes\")\nassert(match_parens(lst: [\")\", \")\"]) == \"\
    No\")\nassert(match_parens(lst: [\"(()(())\", \"())())\"]) == \"No\")\nassert(match_parens(lst:\
    \ [\")())\", \"(()()(\"]) == \"Yes\")\nassert(match_parens(lst: [\"(())))\", \"\
    (()())((\"]) == \"Yes\")\nassert(match_parens(lst: [\"()\", \"())\"]) == \"No\"\
    )\nassert(match_parens(lst: [\"(()(\", \"()))()\"]) == \"Yes\")\nassert(match_parens(lst:\
    \ [\"((((\", \"((())\"]) == \"No\")\nassert(match_parens(lst: [\")(()\", \"(()(\"\
    ]) == \"No\")\nassert(match_parens(lst: [\")(\", \")(\"]) == \"No\")\nassert(match_parens(lst:\
    \ [\"(\", \")\"]) == \"Yes\")\nassert(match_parens(lst: [\")\", \"(\"]) == \"\
    Yes\")"
  status: SyntaxError
  stderr: "/tmp/tmpyk7y1x_5.swift:18:9: error: cannot find 'has_matching_parens' in\
    \ scope\n    if (has_matching_parens(string: left) && has_matching_parens(string:\
    \ right)) {\n        ^~~~~~~~~~~~~~~~~~~\n/tmp/tmpyk7y1x_5.swift:18:46: error:\
    \ cannot find 'has_matching_parens' in scope\n    if (has_matching_parens(string:\
    \ left) && has_matching_parens(string: right)) {\n                           \
    \                  ^~~~~~~~~~~~~~~~~~~\n"
  stdout: ''
  timestamp: 1659979531
- exit_code: 1
  program: "\n/// You are given an array of two strings, both strings consist of open\n\
    /// parentheses '(' or close parentheses ')' only.\n/// Your job is to check if\
    \ it is possible to concatenate the two strings in\n/// some order, that the resulting\
    \ string will be good.\n/// A string S is considered to be good if and only if\
    \ all parentheses in S\n/// are balanced. For example: the string '(())()' is\
    \ good, while the string\n/// '())' is not.\n/// Return 'Yes' if there's a way\
    \ to make a good string, and return 'No' otherwise.\n/// Examples:\n/// >>> match_parens(lst:\
    \ [\"()(\", \")\"])\n/// \"Yes\"\n/// >>> match_parens(lst: [\")\", \")\"])\n\
    /// \"No\"\nfunc match_parens(lst: [String]) -> String {\n    let str1 = lst[0]\n\
    \    let str2 = lst[1]\n    let rightSide = str1 + str2\n    let leftSide = str2\
    \ + str1\n    let okay1 = isGood(parens: rightSide)\n    let okay2 = isGood(parens:\
    \ leftSide)\n    return okay1 || okay2 ? \"Yes\" : \"No\"\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(match_parens(lst: [\"()(\", \")\"]) == \"Yes\")\nassert(match_parens(lst:\
    \ [\")\", \")\"]) == \"No\")\nassert(match_parens(lst: [\"(()(())\", \"())())\"\
    ]) == \"No\")\nassert(match_parens(lst: [\")())\", \"(()()(\"]) == \"Yes\")\n\
    assert(match_parens(lst: [\"(())))\", \"(()())((\"]) == \"Yes\")\nassert(match_parens(lst:\
    \ [\"()\", \"())\"]) == \"No\")\nassert(match_parens(lst: [\"(()(\", \"()))()\"\
    ]) == \"Yes\")\nassert(match_parens(lst: [\"((((\", \"((())\"]) == \"No\")\nassert(match_parens(lst:\
    \ [\")(()\", \"(()(\"]) == \"No\")\nassert(match_parens(lst: [\")(\", \")(\"])\
    \ == \"No\")\nassert(match_parens(lst: [\"(\", \")\"]) == \"Yes\")\nassert(match_parens(lst:\
    \ [\")\", \"(\"]) == \"Yes\")"
  status: SyntaxError
  stderr: "/tmp/tmp6wtg3jm3.swift:20:17: error: cannot find 'isGood' in scope\n  \
    \  let okay1 = isGood(parens: rightSide)\n                ^~~~~~\n/tmp/tmp6wtg3jm3.swift:21:17:\
    \ error: cannot find 'isGood' in scope\n    let okay2 = isGood(parens: leftSide)\n\
    \                ^~~~~~\n"
  stdout: ''
  timestamp: 1659979531
- exit_code: -4
  program: "\n/// You are given an array of two strings, both strings consist of open\n\
    /// parentheses '(' or close parentheses ')' only.\n/// Your job is to check if\
    \ it is possible to concatenate the two strings in\n/// some order, that the resulting\
    \ string will be good.\n/// A string S is considered to be good if and only if\
    \ all parentheses in S\n/// are balanced. For example: the string '(())()' is\
    \ good, while the string\n/// '())' is not.\n/// Return 'Yes' if there's a way\
    \ to make a good string, and return 'No' otherwise.\n/// Examples:\n/// >>> match_parens(lst:\
    \ [\"()(\", \")\"])\n/// \"Yes\"\n/// >>> match_parens(lst: [\")\", \")\"])\n\
    /// \"No\"\nfunc match_parens(lst: [String]) -> String {\n    let (str1, str2)\
    \ = (lst[0], lst[1])\n    if str1.count + str2.count % 2 != 0 {\n        return\
    \ \"No\"\n    }\n    let left = \"(\"\n    let right = \")\"\n    if str1.count\
    \ > str2.count {\n        var count = 0\n        for elem in str1 {\n        \
    \    if elem == Character(left) {\n                count += 1\n            } else\
    \ {\n                count -= 1\n            }\n            if count < 0 {\n \
    \               return \"No\"\n            }\n        }\n        return \"Yes\"\
    \n    } else {\n        var count = 0\n        for elem in str2 {\n          \
    \  if elem == Character(left) {\n                count += 1\n            } else\
    \ {\n                count -= 1\n            }\n            if count < 0 {\n \
    \               return \"No\"\n            }\n        }\n        return \"Yes\"\
    \n    }\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n \
    \   if left.count != right.count {\n        return false\n    }\n    for (l, r)\
    \ in zip(left, right) {\n        if l != r {\n            return false\n     \
    \   }\n    }\n    return true\n}\n            \nassert(match_parens(lst: [\"()(\"\
    , \")\"]) == \"Yes\")\nassert(match_parens(lst: [\")\", \")\"]) == \"No\")\nassert(match_parens(lst:\
    \ [\"(()(())\", \"())())\"]) == \"No\")\nassert(match_parens(lst: [\")())\", \"\
    (()()(\"]) == \"Yes\")\nassert(match_parens(lst: [\"(())))\", \"(()())((\"]) ==\
    \ \"Yes\")\nassert(match_parens(lst: [\"()\", \"())\"]) == \"No\")\nassert(match_parens(lst:\
    \ [\"(()(\", \"()))()\"]) == \"Yes\")\nassert(match_parens(lst: [\"((((\", \"\
    ((())\"]) == \"No\")\nassert(match_parens(lst: [\")(()\", \"(()(\"]) == \"No\"\
    )\nassert(match_parens(lst: [\")(\", \")(\"]) == \"No\")\nassert(match_parens(lst:\
    \ [\"(\", \")\"]) == \"Yes\")\nassert(match_parens(lst: [\")\", \"(\"]) == \"\
    Yes\")"
  status: Exception
  stderr: 'tmp6ki5lgw4/tmp6ki5lgw4.swift:64: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b265da7bc80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b265d772b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b265d772988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b265d7717b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmp6ki5lgw4                        0x00005653f511e736 <unavailable> + 5942

    5    libc.so.6                          0x00002b265dc67460 __libc_start_main +
    245

    6    tmp6ki5lgw4                        0x00005653f511e319 <unavailable> + 4889

    '
  stdout: ''
  timestamp: 1659979532
- exit_code: -4
  program: "\n/// You are given an array of two strings, both strings consist of open\n\
    /// parentheses '(' or close parentheses ')' only.\n/// Your job is to check if\
    \ it is possible to concatenate the two strings in\n/// some order, that the resulting\
    \ string will be good.\n/// A string S is considered to be good if and only if\
    \ all parentheses in S\n/// are balanced. For example: the string '(())()' is\
    \ good, while the string\n/// '())' is not.\n/// Return 'Yes' if there's a way\
    \ to make a good string, and return 'No' otherwise.\n/// Examples:\n/// >>> match_parens(lst:\
    \ [\"()(\", \")\"])\n/// \"Yes\"\n/// >>> match_parens(lst: [\")\", \")\"])\n\
    /// \"No\"\nfunc match_parens(lst: [String]) -> String {\n  var left = 0\n  var\
    \ right = 0\n  for char in lst[0] {\n    if char == \"(\" {\n      left += 1\n\
    \    } else {\n      right += 1\n    }\n  }\n  for char in lst[1] {\n    if char\
    \ == \"(\" {\n      left -= 1\n    } else {\n      right -= 1\n    }\n  }\n  if\
    \ left == 0 && right == 0 {\n    return \"Yes\"\n  }\n  return \"No\"\n}\n\n\n\
    func ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(match_parens(lst: [\"()(\", \")\"]) == \"Yes\"\
    )\nassert(match_parens(lst: [\")\", \")\"]) == \"No\")\nassert(match_parens(lst:\
    \ [\"(()(())\", \"())())\"]) == \"No\")\nassert(match_parens(lst: [\")())\", \"\
    (()()(\"]) == \"Yes\")\nassert(match_parens(lst: [\"(())))\", \"(()())((\"]) ==\
    \ \"Yes\")\nassert(match_parens(lst: [\"()\", \"())\"]) == \"No\")\nassert(match_parens(lst:\
    \ [\"(()(\", \"()))()\"]) == \"Yes\")\nassert(match_parens(lst: [\"((((\", \"\
    ((())\"]) == \"No\")\nassert(match_parens(lst: [\")(()\", \"(()(\"]) == \"No\"\
    )\nassert(match_parens(lst: [\")(\", \")(\"]) == \"No\")\nassert(match_parens(lst:\
    \ [\"(\", \")\"]) == \"Yes\")\nassert(match_parens(lst: [\")\", \"(\"]) == \"\
    Yes\")"
  status: Exception
  stderr: 'tmponkn5337/tmponkn5337.swift:51: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002aba84b1dc80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002aba84814b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002aba84814988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002aba848137b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmponkn5337                        0x000056355b6876a6 <unavailable> + 5798

    5    libc.so.6                          0x00002aba84d09460 __libc_start_main +
    245

    6    tmponkn5337                        0x000056355b687289 <unavailable> + 4745

    '
  stdout: ''
  timestamp: 1659979532
- exit_code: -4
  program: "\n/// You are given an array of two strings, both strings consist of open\n\
    /// parentheses '(' or close parentheses ')' only.\n/// Your job is to check if\
    \ it is possible to concatenate the two strings in\n/// some order, that the resulting\
    \ string will be good.\n/// A string S is considered to be good if and only if\
    \ all parentheses in S\n/// are balanced. For example: the string '(())()' is\
    \ good, while the string\n/// '())' is not.\n/// Return 'Yes' if there's a way\
    \ to make a good string, and return 'No' otherwise.\n/// Examples:\n/// >>> match_parens(lst:\
    \ [\"()(\", \")\"])\n/// \"Yes\"\n/// >>> match_parens(lst: [\")\", \")\"])\n\
    /// \"No\"\nfunc match_parens(lst: [String]) -> String {\n    var count1 = 0\n\
    \    var count2 = 0\n    for char in lst[0] {\n        if char == \"(\" {\n  \
    \          count1 += 1\n        } else {\n            count1 -= 1\n        }\n\
    \    }\n    for char in lst[1] {\n        if char == \"(\" {\n            count2\
    \ += 1\n        } else {\n            count2 -= 1\n        }\n    }\n    if count1\
    \ + count2 < 0 {\n        return \"No\"\n    }\n    return \"Yes\"\n}\n\n\nfunc\
    \ ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count !=\
    \ right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(match_parens(lst: [\"()(\", \")\"]) == \"Yes\"\
    )\nassert(match_parens(lst: [\")\", \")\"]) == \"No\")\nassert(match_parens(lst:\
    \ [\"(()(())\", \"())())\"]) == \"No\")\nassert(match_parens(lst: [\")())\", \"\
    (()()(\"]) == \"Yes\")\nassert(match_parens(lst: [\"(())))\", \"(()())((\"]) ==\
    \ \"Yes\")\nassert(match_parens(lst: [\"()\", \"())\"]) == \"No\")\nassert(match_parens(lst:\
    \ [\"(()(\", \"()))()\"]) == \"Yes\")\nassert(match_parens(lst: [\"((((\", \"\
    ((())\"]) == \"No\")\nassert(match_parens(lst: [\")(()\", \"(()(\"]) == \"No\"\
    )\nassert(match_parens(lst: [\")(\", \")(\"]) == \"No\")\nassert(match_parens(lst:\
    \ [\"(\", \")\"]) == \"Yes\")\nassert(match_parens(lst: [\")\", \"(\"]) == \"\
    Yes\")"
  status: Exception
  stderr: 'tmpg90gu9_x/tmpg90gu9_x.swift:58: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002ae8d5c19c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002ae8d5910b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002ae8d5910988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002ae8d590f7b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpg90gu9_x                        0x000055bfa0c28152 <unavailable> + 8530

    5    libc.so.6                          0x00002ae8d5e05460 __libc_start_main +
    245

    6    tmpg90gu9_x                        0x000055bfa0c27289 <unavailable> + 4745

    '
  stdout: ''
  timestamp: 1659979532
- exit_code: -4
  program: "\n/// You are given an array of two strings, both strings consist of open\n\
    /// parentheses '(' or close parentheses ')' only.\n/// Your job is to check if\
    \ it is possible to concatenate the two strings in\n/// some order, that the resulting\
    \ string will be good.\n/// A string S is considered to be good if and only if\
    \ all parentheses in S\n/// are balanced. For example: the string '(())()' is\
    \ good, while the string\n/// '())' is not.\n/// Return 'Yes' if there's a way\
    \ to make a good string, and return 'No' otherwise.\n/// Examples:\n/// >>> match_parens(lst:\
    \ [\"()(\", \")\"])\n/// \"Yes\"\n/// >>> match_parens(lst: [\")\", \")\"])\n\
    /// \"No\"\nfunc match_parens(lst: [String]) -> String {\n    var s = \"\"\n \
    \   s.append(contentsOf: lst[0])\n    s.append(contentsOf: lst[1])\n    var count\
    \ = 0\n    for c in s {\n        if c == \"(\" {\n            count += 1\n   \
    \     } else {\n            count -= 1\n        }\n        if count < 0 {\n  \
    \          return \"No\"\n        }\n    }\n    return count == 0 ? \"Yes\" :\
    \ \"No\"\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n\
    \    if left.count != right.count {\n        return false\n    }\n    for (l,\
    \ r) in zip(left, right) {\n        if l != r {\n            return false\n  \
    \      }\n    }\n    return true\n}\n            \nassert(match_parens(lst: [\"\
    ()(\", \")\"]) == \"Yes\")\nassert(match_parens(lst: [\")\", \")\"]) == \"No\"\
    )\nassert(match_parens(lst: [\"(()(())\", \"())())\"]) == \"No\")\nassert(match_parens(lst:\
    \ [\")())\", \"(()()(\"]) == \"Yes\")\nassert(match_parens(lst: [\"(())))\", \"\
    (()())((\"]) == \"Yes\")\nassert(match_parens(lst: [\"()\", \"())\"]) == \"No\"\
    )\nassert(match_parens(lst: [\"(()(\", \"()))()\"]) == \"Yes\")\nassert(match_parens(lst:\
    \ [\"((((\", \"((())\"]) == \"No\")\nassert(match_parens(lst: [\")(()\", \"(()(\"\
    ]) == \"No\")\nassert(match_parens(lst: [\")(\", \")(\"]) == \"No\")\nassert(match_parens(lst:\
    \ [\"(\", \")\"]) == \"Yes\")\nassert(match_parens(lst: [\")\", \"(\"]) == \"\
    Yes\")"
  status: Exception
  stderr: 'tmpabtes4k3/tmpabtes4k3.swift:49: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b9cb21c3c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b9cb1ebab6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b9cb1eba988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b9cb1eb97b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpabtes4k3                        0x0000557568a24b86 <unavailable> + 7046

    5    libc.so.6                          0x00002b9cb23af460 __libc_start_main +
    245

    6    tmpabtes4k3                        0x0000557568a242e9 <unavailable> + 4841

    '
  stdout: ''
  timestamp: 1659979532
- exit_code: -4
  program: "\n/// You are given an array of two strings, both strings consist of open\n\
    /// parentheses '(' or close parentheses ')' only.\n/// Your job is to check if\
    \ it is possible to concatenate the two strings in\n/// some order, that the resulting\
    \ string will be good.\n/// A string S is considered to be good if and only if\
    \ all parentheses in S\n/// are balanced. For example: the string '(())()' is\
    \ good, while the string\n/// '())' is not.\n/// Return 'Yes' if there's a way\
    \ to make a good string, and return 'No' otherwise.\n/// Examples:\n/// >>> match_parens(lst:\
    \ [\"()(\", \")\"])\n/// \"Yes\"\n/// >>> match_parens(lst: [\")\", \")\"])\n\
    /// \"No\"\nfunc match_parens(lst: [String]) -> String {\n    var left: Int =\
    \ 0\n    var right: Int = 0\n    for char in lst[0] {\n        if char == \"(\"\
    \ {\n            left += 1\n        } else {\n            right += 1\n       \
    \ }\n    }\n    for char in lst[1] {\n        if char == \"(\" {\n           \
    \ left -= 1\n        } else {\n            right -= 1\n        }\n    }\n    if\
    \ left == 0 && right == 0 {\n        return \"Yes\"\n    }\n    return \"No\"\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(match_parens(lst: [\"()(\", \")\"]) == \"Yes\"\
    )\nassert(match_parens(lst: [\")\", \")\"]) == \"No\")\nassert(match_parens(lst:\
    \ [\"(()(())\", \"())())\"]) == \"No\")\nassert(match_parens(lst: [\")())\", \"\
    (()()(\"]) == \"Yes\")\nassert(match_parens(lst: [\"(())))\", \"(()())((\"]) ==\
    \ \"Yes\")\nassert(match_parens(lst: [\"()\", \"())\"]) == \"No\")\nassert(match_parens(lst:\
    \ [\"(()(\", \"()))()\"]) == \"Yes\")\nassert(match_parens(lst: [\"((((\", \"\
    ((())\"]) == \"No\")\nassert(match_parens(lst: [\")(()\", \"(()(\"]) == \"No\"\
    )\nassert(match_parens(lst: [\")(\", \")(\"]) == \"No\")\nassert(match_parens(lst:\
    \ [\"(\", \")\"]) == \"Yes\")\nassert(match_parens(lst: [\")\", \"(\"]) == \"\
    Yes\")"
  status: Exception
  stderr: 'tmpl89rpard/tmpl89rpard.swift:51: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002afc824b4c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002afc821abb6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002afc821ab988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002afc821aa7b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpl89rpard                        0x0000562ca6b266a6 <unavailable> + 5798

    5    libc.so.6                          0x00002afc826a0460 __libc_start_main +
    245

    6    tmpl89rpard                        0x0000562ca6b26289 <unavailable> + 4745

    '
  stdout: ''
  timestamp: 1659979532
- exit_code: 1
  program: "\n/// You are given an array of two strings, both strings consist of open\n\
    /// parentheses '(' or close parentheses ')' only.\n/// Your job is to check if\
    \ it is possible to concatenate the two strings in\n/// some order, that the resulting\
    \ string will be good.\n/// A string S is considered to be good if and only if\
    \ all parentheses in S\n/// are balanced. For example: the string '(())()' is\
    \ good, while the string\n/// '())' is not.\n/// Return 'Yes' if there's a way\
    \ to make a good string, and return 'No' otherwise.\n/// Examples:\n/// >>> match_parens(lst:\
    \ [\"()(\", \")\"])\n/// \"Yes\"\n/// >>> match_parens(lst: [\")\", \")\"])\n\
    /// \"No\"\nfunc match_parens(lst: [String]) -> String {\n    let s1 = lst[0]\n\
    \    let s2 = lst[1]\n    let s1_prefixes = s1.prefix_array()\n    let s2_suffixes\
    \ = s2.suffix_array()\n    let s1_suffixes = s1.suffix_array()\n    let s2_prefixes\
    \ = s2.prefix_array()\n    if (s1_prefixes[s1.count - 1] + s2_suffixes[0]) % 2\
    \ == 0 {\n        return \"Yes\"\n    }\n    if (s1_suffixes[0] + s2_prefixes[s2.count\
    \ - 1]) % 2 == 0 {\n        return \"Yes\"\n    }\n    return \"No\"\n}\n\n\n\
    func ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(match_parens(lst: [\"()(\", \")\"]) == \"Yes\"\
    )\nassert(match_parens(lst: [\")\", \")\"]) == \"No\")\nassert(match_parens(lst:\
    \ [\"(()(())\", \"())())\"]) == \"No\")\nassert(match_parens(lst: [\")())\", \"\
    (()()(\"]) == \"Yes\")\nassert(match_parens(lst: [\"(())))\", \"(()())((\"]) ==\
    \ \"Yes\")\nassert(match_parens(lst: [\"()\", \"())\"]) == \"No\")\nassert(match_parens(lst:\
    \ [\"(()(\", \"()))()\"]) == \"Yes\")\nassert(match_parens(lst: [\"((((\", \"\
    ((())\"]) == \"No\")\nassert(match_parens(lst: [\")(()\", \"(()(\"]) == \"No\"\
    )\nassert(match_parens(lst: [\")(\", \")(\"]) == \"No\")\nassert(match_parens(lst:\
    \ [\"(\", \")\"]) == \"Yes\")\nassert(match_parens(lst: [\")\", \"(\"]) == \"\
    Yes\")"
  status: SyntaxError
  stderr: "/tmp/tmpsa56sl9r.swift:18:26: error: value of type 'String' has no member\
    \ 'prefix_array'\n    let s1_prefixes = s1.prefix_array()\n                  \
    \    ~~ ^~~~~~~~~~~~\n/tmp/tmpsa56sl9r.swift:19:26: error: value of type 'String'\
    \ has no member 'suffix_array'\n    let s2_suffixes = s2.suffix_array()\n    \
    \                  ~~ ^~~~~~~~~~~~\n/tmp/tmpsa56sl9r.swift:20:26: error: value\
    \ of type 'String' has no member 'suffix_array'\n    let s1_suffixes = s1.suffix_array()\n\
    \                      ~~ ^~~~~~~~~~~~\n/tmp/tmpsa56sl9r.swift:21:26: error: value\
    \ of type 'String' has no member 'prefix_array'\n    let s2_prefixes = s2.prefix_array()\n\
    \                      ~~ ^~~~~~~~~~~~\n"
  stdout: ''
  timestamp: 1659979531
- exit_code: 1
  program: "\n/// You are given an array of two strings, both strings consist of open\n\
    /// parentheses '(' or close parentheses ')' only.\n/// Your job is to check if\
    \ it is possible to concatenate the two strings in\n/// some order, that the resulting\
    \ string will be good.\n/// A string S is considered to be good if and only if\
    \ all parentheses in S\n/// are balanced. For example: the string '(())()' is\
    \ good, while the string\n/// '())' is not.\n/// Return 'Yes' if there's a way\
    \ to make a good string, and return 'No' otherwise.\n/// Examples:\n/// >>> match_parens(lst:\
    \ [\"()(\", \")\"])\n/// \"Yes\"\n/// >>> match_parens(lst: [\")\", \")\"])\n\
    /// \"No\"\nfunc match_parens(lst: [String]) -> String {\n    var parens = lst.reduce(\"\
    \", +)\n    while parens.contains(\"()\") {\n        parens = parens.replacingOccurrences(of:\
    \ \"()\", with: \"\")\n    }\n    return parens.isEmpty ? \"Yes\" : \"No\"\n}\n\
    \n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(match_parens(lst: [\"()(\", \")\"]) == \"Yes\"\
    )\nassert(match_parens(lst: [\")\", \")\"]) == \"No\")\nassert(match_parens(lst:\
    \ [\"(()(())\", \"())())\"]) == \"No\")\nassert(match_parens(lst: [\")())\", \"\
    (()()(\"]) == \"Yes\")\nassert(match_parens(lst: [\"(())))\", \"(()())((\"]) ==\
    \ \"Yes\")\nassert(match_parens(lst: [\"()\", \"())\"]) == \"No\")\nassert(match_parens(lst:\
    \ [\"(()(\", \"()))()\"]) == \"Yes\")\nassert(match_parens(lst: [\"((((\", \"\
    ((())\"]) == \"No\")\nassert(match_parens(lst: [\")(()\", \"(()(\"]) == \"No\"\
    )\nassert(match_parens(lst: [\")(\", \")(\"]) == \"No\")\nassert(match_parens(lst:\
    \ [\"(\", \")\"]) == \"Yes\")\nassert(match_parens(lst: [\")\", \"(\"]) == \"\
    Yes\")"
  status: SyntaxError
  stderr: "/tmp/tmpymnv_3r2.swift:18:25: error: value of type 'String' has no member\
    \ 'replacingOccurrences'\n        parens = parens.replacingOccurrences(of: \"\
    ()\", with: \"\")\n                 ~~~~~~ ^~~~~~~~~~~~~~~~~~~~\n"
  stdout: ''
  timestamp: 1659979531
- exit_code: 1
  program: "\n/// You are given an array of two strings, both strings consist of open\n\
    /// parentheses '(' or close parentheses ')' only.\n/// Your job is to check if\
    \ it is possible to concatenate the two strings in\n/// some order, that the resulting\
    \ string will be good.\n/// A string S is considered to be good if and only if\
    \ all parentheses in S\n/// are balanced. For example: the string '(())()' is\
    \ good, while the string\n/// '())' is not.\n/// Return 'Yes' if there's a way\
    \ to make a good string, and return 'No' otherwise.\n/// Examples:\n/// >>> match_parens(lst:\
    \ [\"()(\", \")\"])\n/// \"Yes\"\n/// >>> match_parens(lst: [\")\", \")\"])\n\
    /// \"No\"\nfunc match_parens(lst: [String]) -> String {\n  let s1 = lst[0]\n\
    \  let s2 = lst[1]\n  // print(\"start \\(s1) - \\(s2)\")\n  if s1.isEmpty {\n\
    \    // print(\"\\(s1) is empty\")\n    return s2.characters.contains(\"(\") ?\
    \ \"No\" : \"Yes\"\n  }\n  if s2.isEmpty {\n    // print(\"\\(s2) is empty\")\n\
    \    return s1.characters.contains(\")\") ? \"No\" : \"Yes\"\n  }\n  if s1.characters.contains(\"\
    (\") && s2.characters.contains(\")\") {\n    // print(\"\\(s1) + \\(s2)\")\n \
    \   return match_parens(lst: [s1.replacingOccurrences(of: \"(\", with: \"\"),\n\
    \                              s2.replacingOccurrences(of: \")\", with: \"\")])\n\
    \  }\n  if s1.characters.contains(\")\") && s2.characters.contains(\"(\") {\n\
    \    // print(\"\\(s2) + \\(s1)\")\n    return match_parens(lst: [s2.replacingOccurrences(of:\
    \ \"(\", with: \"\"),\n                              s1.replacingOccurrences(of:\
    \ \")\", with: \"\")])\n  }\n  // print(\"\\(s1) - \\(s2)\")\n  return \"No\"\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(match_parens(lst: [\"()(\", \")\"]) == \"Yes\"\
    )\nassert(match_parens(lst: [\")\", \")\"]) == \"No\")\nassert(match_parens(lst:\
    \ [\"(()(())\", \"())())\"]) == \"No\")\nassert(match_parens(lst: [\")())\", \"\
    (()()(\"]) == \"Yes\")\nassert(match_parens(lst: [\"(())))\", \"(()())((\"]) ==\
    \ \"Yes\")\nassert(match_parens(lst: [\"()\", \"())\"]) == \"No\")\nassert(match_parens(lst:\
    \ [\"(()(\", \"()))()\"]) == \"Yes\")\nassert(match_parens(lst: [\"((((\", \"\
    ((())\"]) == \"No\")\nassert(match_parens(lst: [\")(()\", \"(()(\"]) == \"No\"\
    )\nassert(match_parens(lst: [\")(\", \")(\"]) == \"No\")\nassert(match_parens(lst:\
    \ [\"(\", \")\"]) == \"Yes\")\nassert(match_parens(lst: [\")\", \"(\"]) == \"\
    Yes\")"
  status: SyntaxError
  stderr: "/tmp/tmp_9c8bhqk.swift:21:15: error: 'characters' is unavailable: Please\
    \ use String directly\n    return s2.characters.contains(\"(\") ? \"No\" : \"\
    Yes\"\n              ^~~~~~~~~~\nSwift.String:5:16: note: 'characters' was obsoleted\
    \ in Swift 5.0\n    public var characters: String { get set }\n              \
    \ ^\n/tmp/tmp_9c8bhqk.swift:25:15: error: 'characters' is unavailable: Please\
    \ use String directly\n    return s1.characters.contains(\")\") ? \"No\" : \"\
    Yes\"\n              ^~~~~~~~~~\nSwift.String:5:16: note: 'characters' was obsoleted\
    \ in Swift 5.0\n    public var characters: String { get set }\n              \
    \ ^\n/tmp/tmp_9c8bhqk.swift:27:9: error: 'characters' is unavailable: Please use\
    \ String directly\n  if s1.characters.contains(\"(\") && s2.characters.contains(\"\
    )\") {\n        ^~~~~~~~~~\nSwift.String:5:16: note: 'characters' was obsoleted\
    \ in Swift 5.0\n    public var characters: String { get set }\n              \
    \ ^\n/tmp/tmp_9c8bhqk.swift:27:40: error: 'characters' is unavailable: Please\
    \ use String directly\n  if s1.characters.contains(\"(\") && s2.characters.contains(\"\
    )\") {\n                                       ^~~~~~~~~~\nSwift.String:5:16:\
    \ note: 'characters' was obsoleted in Swift 5.0\n    public var characters: String\
    \ { get set }\n               ^\n/tmp/tmp_9c8bhqk.swift:29:34: error: value of\
    \ type 'String' has no member 'replacingOccurrences'\n    return match_parens(lst:\
    \ [s1.replacingOccurrences(of: \"(\", with: \"\"),\n                         \
    \     ~~ ^~~~~~~~~~~~~~~~~~~~\n/tmp/tmp_9c8bhqk.swift:30:34: error: value of type\
    \ 'String' has no member 'replacingOccurrences'\n                            \
    \  s2.replacingOccurrences(of: \")\", with: \"\")])\n                        \
    \      ~~ ^~~~~~~~~~~~~~~~~~~~\n/tmp/tmp_9c8bhqk.swift:32:9: error: 'characters'\
    \ is unavailable: Please use String directly\n  if s1.characters.contains(\")\"\
    ) && s2.characters.contains(\"(\") {\n        ^~~~~~~~~~\nSwift.String:5:16: note:\
    \ 'characters' was obsoleted in Swift 5.0\n    public var characters: String {\
    \ get set }\n               ^\n/tmp/tmp_9c8bhqk.swift:32:40: error: 'characters' "
  stdout: ''
  timestamp: 1659979531
- exit_code: 1
  program: "\n/// You are given an array of two strings, both strings consist of open\n\
    /// parentheses '(' or close parentheses ')' only.\n/// Your job is to check if\
    \ it is possible to concatenate the two strings in\n/// some order, that the resulting\
    \ string will be good.\n/// A string S is considered to be good if and only if\
    \ all parentheses in S\n/// are balanced. For example: the string '(())()' is\
    \ good, while the string\n/// '())' is not.\n/// Return 'Yes' if there's a way\
    \ to make a good string, and return 'No' otherwise.\n/// Examples:\n/// >>> match_parens(lst:\
    \ [\"()(\", \")\"])\n/// \"Yes\"\n/// >>> match_parens(lst: [\")\", \")\"])\n\
    /// \"No\"\nfunc match_parens(lst: [String]) -> String {\n    var sum = 0\n  \
    \  for i in 0..<lst.count {\n        sum += check_parens(str: lst[i])\n    }\n\
    \    return sum == 0 ? \"Yes\" : \"No\"\n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(match_parens(lst: [\"()(\", \")\"]) == \"Yes\")\nassert(match_parens(lst:\
    \ [\")\", \")\"]) == \"No\")\nassert(match_parens(lst: [\"(()(())\", \"())())\"\
    ]) == \"No\")\nassert(match_parens(lst: [\")())\", \"(()()(\"]) == \"Yes\")\n\
    assert(match_parens(lst: [\"(())))\", \"(()())((\"]) == \"Yes\")\nassert(match_parens(lst:\
    \ [\"()\", \"())\"]) == \"No\")\nassert(match_parens(lst: [\"(()(\", \"()))()\"\
    ]) == \"Yes\")\nassert(match_parens(lst: [\"((((\", \"((())\"]) == \"No\")\nassert(match_parens(lst:\
    \ [\")(()\", \"(()(\"]) == \"No\")\nassert(match_parens(lst: [\")(\", \")(\"])\
    \ == \"No\")\nassert(match_parens(lst: [\"(\", \")\"]) == \"Yes\")\nassert(match_parens(lst:\
    \ [\")\", \"(\"]) == \"Yes\")"
  status: SyntaxError
  stderr: "/tmp/tmpm_4656pd.swift:18:16: error: cannot find 'check_parens' in scope\n\
    \        sum += check_parens(str: lst[i])\n               ^~~~~~~~~~~~\n"
  stdout: ''
  timestamp: 1659979531
- exit_code: 1
  program: "\n/// You are given an array of two strings, both strings consist of open\n\
    /// parentheses '(' or close parentheses ')' only.\n/// Your job is to check if\
    \ it is possible to concatenate the two strings in\n/// some order, that the resulting\
    \ string will be good.\n/// A string S is considered to be good if and only if\
    \ all parentheses in S\n/// are balanced. For example: the string '(())()' is\
    \ good, while the string\n/// '())' is not.\n/// Return 'Yes' if there's a way\
    \ to make a good string, and return 'No' otherwise.\n/// Examples:\n/// >>> match_parens(lst:\
    \ [\"()(\", \")\"])\n/// \"Yes\"\n/// >>> match_parens(lst: [\")\", \")\"])\n\
    /// \"No\"\nfunc match_parens(lst: [String]) -> String {\n    if lst.count !=\
    \ 2 {\n        return \"No\"\n    }\n    let first_string = lst[0], second_string\
    \ = lst[1]\n    if first_string.characters.count + second_string.characters.count\
    \ % 2 != 0 {\n        return \"No\"\n    }\n    var stack = [Character]()\n  \
    \  for character in first_string.characters {\n        if character == \"(\" {\n\
    \            stack.append(character)\n        } else {\n            if stack.isEmpty\
    \ {\n                stack.append(character)\n            } else {\n         \
    \       stack.removeLast()\n            }\n        }\n    }\n    for character\
    \ in second_string.characters {\n        if character == \"(\" {\n           \
    \ stack.append(character)\n        } else {\n            if stack.isEmpty {\n\
    \                stack.append(character)\n            } else {\n             \
    \   stack.removeLast()\n            }\n        }\n    }\n    if stack.isEmpty\
    \ {\n        return \"Yes\"\n    }\n    return \"No\"\n}\n\n\nfunc ==(left: [(Int,\
    \ Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n\
    \        return false\n    }\n    for (l, r) in zip(left, right) {\n        if\
    \ l != r {\n            return false\n        }\n    }\n    return true\n}\n \
    \           \nassert(match_parens(lst: [\"()(\", \")\"]) == \"Yes\")\nassert(match_parens(lst:\
    \ [\")\", \")\"]) == \"No\")\nassert(match_parens(lst: [\"(()(())\", \"())())\"\
    ]) == \"No\")\nassert(match_parens(lst: [\")())\", \"(()()(\"]) == \"Yes\")\n\
    assert(match_parens(lst: [\"(())))\", \"(()())((\"]) == \"Yes\")\nassert(match_parens(lst:\
    \ [\"()\", \"())\"]) == \"No\")\nassert(match_parens(lst: [\"(()(\", \"()))()\"\
    ]) == \"Yes\")\nassert(match_parens(lst: [\"((((\", \"((())\"]) == \"No\")\nassert(match_parens(lst:\
    \ [\")(()\", \"(()(\"]) == \"No\")\nassert(match_parens(lst: [\")(\", \")(\"])\
    \ == \"No\")\nassert(match_parens(lst: [\"(\", \")\"]) == \"Yes\")\nassert(match_parens(lst:\
    \ [\")\", \"(\"]) == \"Yes\")"
  status: SyntaxError
  stderr: "/tmp/tmpxdv843i4.swift:20:21: error: 'characters' is unavailable: Please\
    \ use String directly\n    if first_string.characters.count + second_string.characters.count\
    \ % 2 != 0 {\n                    ^~~~~~~~~~\nSwift.String:5:16: note: 'characters'\
    \ was obsoleted in Swift 5.0\n    public var characters: String { get set }\n\
    \               ^\n/tmp/tmpxdv843i4.swift:20:54: error: 'characters' is unavailable:\
    \ Please use String directly\n    if first_string.characters.count + second_string.characters.count\
    \ % 2 != 0 {\n                                                     ^~~~~~~~~~\n\
    Swift.String:5:16: note: 'characters' was obsoleted in Swift 5.0\n    public var\
    \ characters: String { get set }\n               ^\n/tmp/tmpxdv843i4.swift:24:35:\
    \ error: 'characters' is unavailable: Please use String directly\n    for character\
    \ in first_string.characters {\n                                  ^~~~~~~~~~\n\
    Swift.String:5:16: note: 'characters' was obsoleted in Swift 5.0\n    public var\
    \ characters: String { get set }\n               ^\n/tmp/tmpxdv843i4.swift:35:36:\
    \ error: 'characters' is unavailable: Please use String directly\n    for character\
    \ in second_string.characters {\n                                   ^~~~~~~~~~\n\
    Swift.String:5:16: note: 'characters' was obsoleted in Swift 5.0\n    public var\
    \ characters: String { get set }\n               ^\n"
  stdout: ''
  timestamp: 1659979531
- exit_code: 1
  program: "\n/// You are given an array of two strings, both strings consist of open\n\
    /// parentheses '(' or close parentheses ')' only.\n/// Your job is to check if\
    \ it is possible to concatenate the two strings in\n/// some order, that the resulting\
    \ string will be good.\n/// A string S is considered to be good if and only if\
    \ all parentheses in S\n/// are balanced. For example: the string '(())()' is\
    \ good, while the string\n/// '())' is not.\n/// Return 'Yes' if there's a way\
    \ to make a good string, and return 'No' otherwise.\n/// Examples:\n/// >>> match_parens(lst:\
    \ [\"()(\", \")\"])\n/// \"Yes\"\n/// >>> match_parens(lst: [\")\", \")\"])\n\
    /// \"No\"\nfunc match_parens(lst: [String]) -> String {\n    let str1 = lst[0]\n\
    \    let str2 = lst[1]\n    if !isGood(str: str1) || !isGood(str: str2) {\n  \
    \      return \"No\"\n    }\n    if str1.count == 0 {\n        return isGood(str:\
    \ str2) ? \"Yes\" : \"No\"\n    }\n    if str2.count == 0 {\n        return isGood(str:\
    \ str1) ? \"Yes\" : \"No\"\n    }\n    if str1.count == 1 {\n        let last\
    \ = str1[str1.startIndex]\n        let s = str2 + String(last)\n        return\
    \ isGood(str: s) ? \"Yes\" : \"No\"\n    }\n    if str2.count == 1 {\n       \
    \ let last = str2[str2.startIndex]\n        let s = str1 + String(last)\n    \
    \    return isGood(str: s) ? \"Yes\" : \"No\"\n    }\n    let last1 = str1[str1.index(before:\
    \ str1.endIndex)]\n    let last2 = str2[str2.index(before: str2.endIndex)]\n \
    \   if last1 == \"(\" && last2 == \")\" {\n        let s1 = str1 + String(last2)\n\
    \        let s2 = str2 + String(last1)\n        return isGood(str: s1) || isGood(str:\
    \ s2) ? \"Yes\" : \"No\"\n    }\n    if last1 == \"(\" {\n        let s = str1\
    \ + String(last2)\n        return isGood(str: s) ? \"Yes\" : \"No\"\n    }\n \
    \   if last2 == \")\" {\n        let s = str2 + String(last1)\n        return\
    \ isGood(str: s) ? \"Yes\" : \"No\"\n    }\n    return \"No\"\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(match_parens(lst: [\"()(\", \")\"]) == \"Yes\")\nassert(match_parens(lst:\
    \ [\")\", \")\"]) == \"No\")\nassert(match_parens(lst: [\"(()(())\", \"())())\"\
    ]) == \"No\")\nassert(match_parens(lst: [\")())\", \"(()()(\"]) == \"Yes\")\n\
    assert(match_parens(lst: [\"(())))\", \"(()())((\"]) == \"Yes\")\nassert(match_parens(lst:\
    \ [\"()\", \"())\"]) == \"No\")\nassert(match_parens(lst: [\"(()(\", \"()))()\"\
    ]) == \"Yes\")\nassert(match_parens(lst: [\"((((\", \"((())\"]) == \"No\")\nassert(match_parens(lst:\
    \ [\")(()\", \"(()(\"]) == \"No\")\nassert(match_parens(lst: [\")(\", \")(\"])\
    \ == \"No\")\nassert(match_parens(lst: [\"(\", \")\"]) == \"Yes\")\nassert(match_parens(lst:\
    \ [\")\", \"(\"]) == \"Yes\")"
  status: SyntaxError
  stderr: "/tmp/tmp8hehh2ni.swift:18:9: error: cannot find 'isGood' in scope\n   \
    \ if !isGood(str: str1) || !isGood(str: str2) {\n        ^~~~~~\n/tmp/tmp8hehh2ni.swift:18:31:\
    \ error: cannot find 'isGood' in scope\n    if !isGood(str: str1) || !isGood(str:\
    \ str2) {\n                              ^~~~~~\n/tmp/tmp8hehh2ni.swift:22:16:\
    \ error: cannot find 'isGood' in scope\n        return isGood(str: str2) ? \"\
    Yes\" : \"No\"\n               ^~~~~~\n/tmp/tmp8hehh2ni.swift:25:16: error: cannot\
    \ find 'isGood' in scope\n        return isGood(str: str1) ? \"Yes\" : \"No\"\n\
    \               ^~~~~~\n/tmp/tmp8hehh2ni.swift:30:16: error: cannot find 'isGood'\
    \ in scope\n        return isGood(str: s) ? \"Yes\" : \"No\"\n               ^~~~~~\n\
    /tmp/tmp8hehh2ni.swift:35:16: error: cannot find 'isGood' in scope\n        return\
    \ isGood(str: s) ? \"Yes\" : \"No\"\n               ^~~~~~\n/tmp/tmp8hehh2ni.swift:42:16:\
    \ error: cannot find 'isGood' in scope\n        return isGood(str: s1) || isGood(str:\
    \ s2) ? \"Yes\" : \"No\"\n               ^~~~~~\n/tmp/tmp8hehh2ni.swift:42:35:\
    \ error: cannot find 'isGood' in scope\n        return isGood(str: s1) || isGood(str:\
    \ s2) ? \"Yes\" : \"No\"\n                                  ^~~~~~\n/tmp/tmp8hehh2ni.swift:46:16:\
    \ error: cannot find 'isGood' in scope\n        return isGood(str: s) ? \"Yes\"\
    \ : \"No\"\n               ^~~~~~\n/tmp/tmp8hehh2ni.swift:50:16: error: cannot\
    \ find 'isGood' in scope\n        return isGood(str: s) ? \"Yes\" : \"No\"\n \
    \              ^~~~~~\n"
  stdout: ''
  timestamp: 1659979531
- exit_code: -4
  program: "\n/// You are given an array of two strings, both strings consist of open\n\
    /// parentheses '(' or close parentheses ')' only.\n/// Your job is to check if\
    \ it is possible to concatenate the two strings in\n/// some order, that the resulting\
    \ string will be good.\n/// A string S is considered to be good if and only if\
    \ all parentheses in S\n/// are balanced. For example: the string '(())()' is\
    \ good, while the string\n/// '())' is not.\n/// Return 'Yes' if there's a way\
    \ to make a good string, and return 'No' otherwise.\n/// Examples:\n/// >>> match_parens(lst:\
    \ [\"()(\", \")\"])\n/// \"Yes\"\n/// >>> match_parens(lst: [\")\", \")\"])\n\
    /// \"No\"\nfunc match_parens(lst: [String]) -> String {\n    var end = 0\n  \
    \  for str in lst {\n        for c in str {\n            if c == \"(\" {\n   \
    \             end += 1\n            } else {\n                end -= 1\n     \
    \       }\n            if end < 0 {\n                return \"No\"\n         \
    \   }\n        }\n    }\n    return end == 0 ? \"Yes\" : \"No\"\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(match_parens(lst: [\"()(\", \")\"]) == \"Yes\")\nassert(match_parens(lst:\
    \ [\")\", \")\"]) == \"No\")\nassert(match_parens(lst: [\"(()(())\", \"())())\"\
    ]) == \"No\")\nassert(match_parens(lst: [\")())\", \"(()()(\"]) == \"Yes\")\n\
    assert(match_parens(lst: [\"(())))\", \"(()())((\"]) == \"Yes\")\nassert(match_parens(lst:\
    \ [\"()\", \"())\"]) == \"No\")\nassert(match_parens(lst: [\"(()(\", \"()))()\"\
    ]) == \"Yes\")\nassert(match_parens(lst: [\"((((\", \"((())\"]) == \"No\")\nassert(match_parens(lst:\
    \ [\")(()\", \"(()(\"]) == \"No\")\nassert(match_parens(lst: [\")(\", \")(\"])\
    \ == \"No\")\nassert(match_parens(lst: [\"(\", \")\"]) == \"Yes\")\nassert(match_parens(lst:\
    \ [\")\", \"(\"]) == \"Yes\")"
  status: Exception
  stderr: 'tmpac1i2vm6/tmpac1i2vm6.swift:48: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b91de109c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b91dde00b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b91dde00988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b91dddff7b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpac1i2vm6                        0x000055756cee3c36 <unavailable> + 7222

    5    libc.so.6                          0x00002b91de2f5460 __libc_start_main +
    245

    6    tmpac1i2vm6                        0x000055756cee3399 <unavailable> + 5017

    '
  stdout: ''
  timestamp: 1659979532
- exit_code: -4
  program: "\n/// You are given an array of two strings, both strings consist of open\n\
    /// parentheses '(' or close parentheses ')' only.\n/// Your job is to check if\
    \ it is possible to concatenate the two strings in\n/// some order, that the resulting\
    \ string will be good.\n/// A string S is considered to be good if and only if\
    \ all parentheses in S\n/// are balanced. For example: the string '(())()' is\
    \ good, while the string\n/// '())' is not.\n/// Return 'Yes' if there's a way\
    \ to make a good string, and return 'No' otherwise.\n/// Examples:\n/// >>> match_parens(lst:\
    \ [\"()(\", \")\"])\n/// \"Yes\"\n/// >>> match_parens(lst: [\")\", \")\"])\n\
    /// \"No\"\nfunc match_parens(lst: [String]) -> String {\n  let s1 = lst[0]\n\
    \  let s2 = lst[1]\n  let s1_arr = Array(s1)\n  let s2_arr = Array(s2)\n  var\
    \ s1_open = 0\n  var s2_open = 0\n  for ch in s1_arr {\n    if ch == \"(\" {\n\
    \      s1_open += 1\n    } else {\n      s1_open -= 1\n    }\n  }\n  for ch in\
    \ s2_arr {\n    if ch == \"(\" {\n      s2_open += 1\n    } else {\n      s2_open\
    \ -= 1\n    }\n  }\n  if s1_open > 0 && s2_open > 0 {\n    return \"No\"\n  }\
    \ else if s1_open < 0 && s2_open < 0 {\n    return \"No\"\n  } else {\n    return\
    \ \"Yes\"\n  }\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool\
    \ {\n    if left.count != right.count {\n        return false\n    }\n    for\
    \ (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(match_parens(lst:\
    \ [\"()(\", \")\"]) == \"Yes\")\nassert(match_parens(lst: [\")\", \")\"]) == \"\
    No\")\nassert(match_parens(lst: [\"(()(())\", \"())())\"]) == \"No\")\nassert(match_parens(lst:\
    \ [\")())\", \"(()()(\"]) == \"Yes\")\nassert(match_parens(lst: [\"(())))\", \"\
    (()())((\"]) == \"Yes\")\nassert(match_parens(lst: [\"()\", \"())\"]) == \"No\"\
    )\nassert(match_parens(lst: [\"(()(\", \"()))()\"]) == \"Yes\")\nassert(match_parens(lst:\
    \ [\"((((\", \"((())\"]) == \"No\")\nassert(match_parens(lst: [\")(()\", \"(()(\"\
    ]) == \"No\")\nassert(match_parens(lst: [\")(\", \")(\"]) == \"No\")\nassert(match_parens(lst:\
    \ [\"(\", \")\"]) == \"Yes\")\nassert(match_parens(lst: [\")\", \"(\"]) == \"\
    Yes\")"
  status: Exception
  stderr: 'tmp03s3p8rq/tmp03s3p8rq.swift:60: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002af079aa1c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002af079798b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002af079798988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002af0797977b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmp03s3p8rq                        0x000055a17df87b2b <unavailable> + 6955

    5    libc.so.6                          0x00002af079c8d460 __libc_start_main +
    245

    6    tmp03s3p8rq                        0x000055a17df87419 <unavailable> + 5145

    '
  stdout: ''
  timestamp: 1659979532
- exit_code: -4
  program: "\n/// You are given an array of two strings, both strings consist of open\n\
    /// parentheses '(' or close parentheses ')' only.\n/// Your job is to check if\
    \ it is possible to concatenate the two strings in\n/// some order, that the resulting\
    \ string will be good.\n/// A string S is considered to be good if and only if\
    \ all parentheses in S\n/// are balanced. For example: the string '(())()' is\
    \ good, while the string\n/// '())' is not.\n/// Return 'Yes' if there's a way\
    \ to make a good string, and return 'No' otherwise.\n/// Examples:\n/// >>> match_parens(lst:\
    \ [\"()(\", \")\"])\n/// \"Yes\"\n/// >>> match_parens(lst: [\")\", \")\"])\n\
    /// \"No\"\nfunc match_parens(lst: [String]) -> String {\n    var openCount =\
    \ 0\n    var closeCount = 0\n    for item in lst {\n        for char in item {\n\
    \            if char == \"(\" {\n                openCount += 1\n            }\
    \ else {\n                closeCount += 1\n            }\n        }\n    }\n \
    \   if openCount == closeCount {\n        return \"Yes\"\n    } else {\n     \
    \   return \"No\"\n    }\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(match_parens(lst:\
    \ [\"()(\", \")\"]) == \"Yes\")\nassert(match_parens(lst: [\")\", \")\"]) == \"\
    No\")\nassert(match_parens(lst: [\"(()(())\", \"())())\"]) == \"No\")\nassert(match_parens(lst:\
    \ [\")())\", \"(()()(\"]) == \"Yes\")\nassert(match_parens(lst: [\"(())))\", \"\
    (()())((\"]) == \"Yes\")\nassert(match_parens(lst: [\"()\", \"())\"]) == \"No\"\
    )\nassert(match_parens(lst: [\"(()(\", \"()))()\"]) == \"Yes\")\nassert(match_parens(lst:\
    \ [\"((((\", \"((())\"]) == \"No\")\nassert(match_parens(lst: [\")(()\", \"(()(\"\
    ]) == \"No\")\nassert(match_parens(lst: [\")(\", \")(\"]) == \"No\")\nassert(match_parens(lst:\
    \ [\"(\", \")\"]) == \"Yes\")\nassert(match_parens(lst: [\")\", \"(\"]) == \"\
    Yes\")"
  status: Exception
  stderr: 'tmp2su552mg/tmp2su552mg.swift:56: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002ac58213cc80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002ac581e33b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002ac581e33988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002ac581e327b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmp2su552mg                        0x0000564635b90578 <unavailable> + 9592

    5    libc.so.6                          0x00002ac582328460 __libc_start_main +
    245

    6    tmp2su552mg                        0x0000564635b8f399 <unavailable> + 5017

    '
  stdout: ''
  timestamp: 1659979532
- exit_code: -4
  program: "\n/// You are given an array of two strings, both strings consist of open\n\
    /// parentheses '(' or close parentheses ')' only.\n/// Your job is to check if\
    \ it is possible to concatenate the two strings in\n/// some order, that the resulting\
    \ string will be good.\n/// A string S is considered to be good if and only if\
    \ all parentheses in S\n/// are balanced. For example: the string '(())()' is\
    \ good, while the string\n/// '())' is not.\n/// Return 'Yes' if there's a way\
    \ to make a good string, and return 'No' otherwise.\n/// Examples:\n/// >>> match_parens(lst:\
    \ [\"()(\", \")\"])\n/// \"Yes\"\n/// >>> match_parens(lst: [\")\", \")\"])\n\
    /// \"No\"\nfunc match_parens(lst: [String]) -> String {\n  return \"\"\n}\n\n\
    \nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(match_parens(lst: [\"()(\", \")\"]) == \"Yes\"\
    )\nassert(match_parens(lst: [\")\", \")\"]) == \"No\")\nassert(match_parens(lst:\
    \ [\"(()(())\", \"())())\"]) == \"No\")\nassert(match_parens(lst: [\")())\", \"\
    (()()(\"]) == \"Yes\")\nassert(match_parens(lst: [\"(())))\", \"(()())((\"]) ==\
    \ \"Yes\")\nassert(match_parens(lst: [\"()\", \"())\"]) == \"No\")\nassert(match_parens(lst:\
    \ [\"(()(\", \"()))()\"]) == \"Yes\")\nassert(match_parens(lst: [\"((((\", \"\
    ((())\"]) == \"No\")\nassert(match_parens(lst: [\")(()\", \"(()(\"]) == \"No\"\
    )\nassert(match_parens(lst: [\")(\", \")(\"]) == \"No\")\nassert(match_parens(lst:\
    \ [\"(\", \")\"]) == \"Yes\")\nassert(match_parens(lst: [\")\", \"(\"]) == \"\
    Yes\")"
  status: Exception
  stderr: 'tmphakfwh0m/tmphakfwh0m.swift:32: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002ad451e42c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002ad451b39b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002ad451b39988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002ad451b387b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmphakfwh0m                        0x000055b2eb7084a6 <unavailable> + 5286

    5    libc.so.6                          0x00002ad45202e460 __libc_start_main +
    245

    6    tmphakfwh0m                        0x000055b2eb708089 <unavailable> + 4233

    '
  stdout: ''
  timestamp: 1659979532
- exit_code: -4
  program: "\n/// You are given an array of two strings, both strings consist of open\n\
    /// parentheses '(' or close parentheses ')' only.\n/// Your job is to check if\
    \ it is possible to concatenate the two strings in\n/// some order, that the resulting\
    \ string will be good.\n/// A string S is considered to be good if and only if\
    \ all parentheses in S\n/// are balanced. For example: the string '(())()' is\
    \ good, while the string\n/// '())' is not.\n/// Return 'Yes' if there's a way\
    \ to make a good string, and return 'No' otherwise.\n/// Examples:\n/// >>> match_parens(lst:\
    \ [\"()(\", \")\"])\n/// \"Yes\"\n/// >>> match_parens(lst: [\")\", \")\"])\n\
    /// \"No\"\nfunc match_parens(lst: [String]) -> String {\n    var openParens =\
    \ 0\n    for parenthesis in lst.joined() {\n        if parenthesis == \"(\" {\n\
    \            openParens += 1\n        } else {\n            openParens -= 1\n\
    \        }\n        if openParens < 0 {\n            return \"No\"\n        }\n\
    \    }\n    return openParens == 0 ? \"Yes\" : \"No\"\n}\n\n\nfunc ==(left: [(Int,\
    \ Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n\
    \        return false\n    }\n    for (l, r) in zip(left, right) {\n        if\
    \ l != r {\n            return false\n        }\n    }\n    return true\n}\n \
    \           \nassert(match_parens(lst: [\"()(\", \")\"]) == \"Yes\")\nassert(match_parens(lst:\
    \ [\")\", \")\"]) == \"No\")\nassert(match_parens(lst: [\"(()(())\", \"())())\"\
    ]) == \"No\")\nassert(match_parens(lst: [\")())\", \"(()()(\"]) == \"Yes\")\n\
    assert(match_parens(lst: [\"(())))\", \"(()())((\"]) == \"Yes\")\nassert(match_parens(lst:\
    \ [\"()\", \"())\"]) == \"No\")\nassert(match_parens(lst: [\"(()(\", \"()))()\"\
    ]) == \"Yes\")\nassert(match_parens(lst: [\"((((\", \"((())\"]) == \"No\")\nassert(match_parens(lst:\
    \ [\")(()\", \"(()(\"]) == \"No\")\nassert(match_parens(lst: [\")(\", \")(\"])\
    \ == \"No\")\nassert(match_parens(lst: [\"(\", \")\"]) == \"Yes\")\nassert(match_parens(lst:\
    \ [\")\", \"(\"]) == \"Yes\")"
  status: Exception
  stderr: 'tmpqy5bw8ag/tmpqy5bw8ag.swift:46: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002ab92f2bdc80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002ab92efb4b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002ab92efb4988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002ab92efb37b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpqy5bw8ag                        0x000055f77e3efb76 <unavailable> + 7030

    5    libc.so.6                          0x00002ab92f4a9460 __libc_start_main +
    245

    6    tmpqy5bw8ag                        0x000055f77e3ef2d9 <unavailable> + 4825

    '
  stdout: ''
  timestamp: 1659979532
- exit_code: 1
  program: "\n/// You are given an array of two strings, both strings consist of open\n\
    /// parentheses '(' or close parentheses ')' only.\n/// Your job is to check if\
    \ it is possible to concatenate the two strings in\n/// some order, that the resulting\
    \ string will be good.\n/// A string S is considered to be good if and only if\
    \ all parentheses in S\n/// are balanced. For example: the string '(())()' is\
    \ good, while the string\n/// '())' is not.\n/// Return 'Yes' if there's a way\
    \ to make a good string, and return 'No' otherwise.\n/// Examples:\n/// >>> match_parens(lst:\
    \ [\"()(\", \")\"])\n/// \"Yes\"\n/// >>> match_parens(lst: [\")\", \")\"])\n\
    /// \"No\"\nfunc match_parens(lst: [String]) -> String {\n    var stack = Stack<Character>()\n\
    \    var output = \"Yes\"\n    var word = \"\"\n    for w in lst {\n        word\
    \ += w\n    }\n    print(word)\n    let char = Array(word)\n    for c in char\
    \ {\n        if c == \"(\" {\n            stack.push(c)\n        } else {\n  \
    \          if stack.peek() == \"(\" {\n                stack.pop()\n         \
    \   } else {\n                output = \"No\"\n            }\n        }\n    }\n\
    \    if !stack.isEmpty() {\n        output = \"No\"\n    }\n    return output\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(match_parens(lst: [\"()(\", \")\"]) == \"Yes\"\
    )\nassert(match_parens(lst: [\")\", \")\"]) == \"No\")\nassert(match_parens(lst:\
    \ [\"(()(())\", \"())())\"]) == \"No\")\nassert(match_parens(lst: [\")())\", \"\
    (()()(\"]) == \"Yes\")\nassert(match_parens(lst: [\"(())))\", \"(()())((\"]) ==\
    \ \"Yes\")\nassert(match_parens(lst: [\"()\", \"())\"]) == \"No\")\nassert(match_parens(lst:\
    \ [\"(()(\", \"()))()\"]) == \"Yes\")\nassert(match_parens(lst: [\"((((\", \"\
    ((())\"]) == \"No\")\nassert(match_parens(lst: [\")(()\", \"(()(\"]) == \"No\"\
    )\nassert(match_parens(lst: [\")(\", \")(\"]) == \"No\")\nassert(match_parens(lst:\
    \ [\"(\", \")\"]) == \"Yes\")\nassert(match_parens(lst: [\")\", \"(\"]) == \"\
    Yes\")"
  status: SyntaxError
  stderr: "/tmp/tmpjq3rufwh.swift:16:17: error: cannot find 'Stack' in scope\n   \
    \ var stack = Stack<Character>()\n                ^~~~~\n"
  stdout: ''
  timestamp: 1659979532
- exit_code: -4
  program: "\n/// You are given an array of two strings, both strings consist of open\n\
    /// parentheses '(' or close parentheses ')' only.\n/// Your job is to check if\
    \ it is possible to concatenate the two strings in\n/// some order, that the resulting\
    \ string will be good.\n/// A string S is considered to be good if and only if\
    \ all parentheses in S\n/// are balanced. For example: the string '(())()' is\
    \ good, while the string\n/// '())' is not.\n/// Return 'Yes' if there's a way\
    \ to make a good string, and return 'No' otherwise.\n/// Examples:\n/// >>> match_parens(lst:\
    \ [\"()(\", \")\"])\n/// \"Yes\"\n/// >>> match_parens(lst: [\")\", \")\"])\n\
    /// \"No\"\nfunc match_parens(lst: [String]) -> String {\n    var count = 0\n\
    \    for char in lst[0] {\n        count += char == \"(\" ? 1 : -1\n        if\
    \ count < 0 {\n            return \"No\"\n        }\n    }\n    count = 0\n  \
    \  for char in lst[1] {\n        count += char == \")\" ? 1 : -1\n        if count\
    \ < 0 {\n            return \"No\"\n        }\n    }\n    return count == 0 ?\
    \ \"Yes\" : \"No\"\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) ->\
    \ Bool {\n    if left.count != right.count {\n        return false\n    }\n  \
    \  for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(match_parens(lst:\
    \ [\"()(\", \")\"]) == \"Yes\")\nassert(match_parens(lst: [\")\", \")\"]) == \"\
    No\")\nassert(match_parens(lst: [\"(()(())\", \"())())\"]) == \"No\")\nassert(match_parens(lst:\
    \ [\")())\", \"(()()(\"]) == \"Yes\")\nassert(match_parens(lst: [\"(())))\", \"\
    (()())((\"]) == \"Yes\")\nassert(match_parens(lst: [\"()\", \"())\"]) == \"No\"\
    )\nassert(match_parens(lst: [\"(()(\", \"()))()\"]) == \"Yes\")\nassert(match_parens(lst:\
    \ [\"((((\", \"((())\"]) == \"No\")\nassert(match_parens(lst: [\")(()\", \"(()(\"\
    ]) == \"No\")\nassert(match_parens(lst: [\")(\", \")(\"]) == \"No\")\nassert(match_parens(lst:\
    \ [\"(\", \")\"]) == \"Yes\")\nassert(match_parens(lst: [\")\", \"(\"]) == \"\
    Yes\")"
  status: Exception
  stderr: 'tmp09igln1j/tmp09igln1j.swift:46: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b78d8f50c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b78d8c47b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b78d8c47988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b78d8c467b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmp09igln1j                        0x00005593788066a6 <unavailable> + 5798

    5    libc.so.6                          0x00002b78d913c460 __libc_start_main +
    245

    6    tmp09igln1j                        0x0000559378806289 <unavailable> + 4745

    '
  stdout: ''
  timestamp: 1659979532
- exit_code: 1
  program: "\n/// You are given an array of two strings, both strings consist of open\n\
    /// parentheses '(' or close parentheses ')' only.\n/// Your job is to check if\
    \ it is possible to concatenate the two strings in\n/// some order, that the resulting\
    \ string will be good.\n/// A string S is considered to be good if and only if\
    \ all parentheses in S\n/// are balanced. For example: the string '(())()' is\
    \ good, while the string\n/// '())' is not.\n/// Return 'Yes' if there's a way\
    \ to make a good string, and return 'No' otherwise.\n/// Examples:\n/// >>> match_parens(lst:\
    \ [\"()(\", \")\"])\n/// \"Yes\"\n/// >>> match_parens(lst: [\")\", \")\"])\n\
    /// \"No\"\nfunc match_parens(lst: [String]) -> String {\n    var tmp = lst.joined()\n\
    \    while tmp.contains(\"()\") {\n        tmp = tmp.replacingOccurrences(of:\
    \ \"()\", with: \"\")\n    }\n    return tmp.isEmpty ? \"Yes\" : \"No\"\n}\n\n\
    \nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(match_parens(lst: [\"()(\", \")\"]) == \"Yes\"\
    )\nassert(match_parens(lst: [\")\", \")\"]) == \"No\")\nassert(match_parens(lst:\
    \ [\"(()(())\", \"())())\"]) == \"No\")\nassert(match_parens(lst: [\")())\", \"\
    (()()(\"]) == \"Yes\")\nassert(match_parens(lst: [\"(())))\", \"(()())((\"]) ==\
    \ \"Yes\")\nassert(match_parens(lst: [\"()\", \"())\"]) == \"No\")\nassert(match_parens(lst:\
    \ [\"(()(\", \"()))()\"]) == \"Yes\")\nassert(match_parens(lst: [\"((((\", \"\
    ((())\"]) == \"No\")\nassert(match_parens(lst: [\")(()\", \"(()(\"]) == \"No\"\
    )\nassert(match_parens(lst: [\")(\", \")(\"]) == \"No\")\nassert(match_parens(lst:\
    \ [\"(\", \")\"]) == \"Yes\")\nassert(match_parens(lst: [\")\", \"(\"]) == \"\
    Yes\")"
  status: SyntaxError
  stderr: "/tmp/tmpv31exoo_.swift:18:19: error: value of type 'String' has no member\
    \ 'replacingOccurrences'\n        tmp = tmp.replacingOccurrences(of: \"()\", with:\
    \ \"\")\n              ~~~ ^~~~~~~~~~~~~~~~~~~~\n"
  stdout: ''
  timestamp: 1659979532
- exit_code: 1
  program: "\n/// You are given an array of two strings, both strings consist of open\n\
    /// parentheses '(' or close parentheses ')' only.\n/// Your job is to check if\
    \ it is possible to concatenate the two strings in\n/// some order, that the resulting\
    \ string will be good.\n/// A string S is considered to be good if and only if\
    \ all parentheses in S\n/// are balanced. For example: the string '(())()' is\
    \ good, while the string\n/// '())' is not.\n/// Return 'Yes' if there's a way\
    \ to make a good string, and return 'No' otherwise.\n/// Examples:\n/// >>> match_parens(lst:\
    \ [\"()(\", \")\"])\n/// \"Yes\"\n/// >>> match_parens(lst: [\")\", \")\"])\n\
    /// \"No\"\nfunc match_parens(lst: [String]) -> String {\n    let s1 = lst[0]\n\
    \    let s2 = lst[1]\n    var s = s1 + s2\n    var tmp: Int\n    while true {\n\
    \        tmp = s.count\n        s = s.replacingOccurrences(of: \"()\", with: \"\
    \")\n        if tmp == s.count {\n            break\n        }\n    }\n    return\
    \ s.count == 0 ? \"Yes\" : \"No\"\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int,\
    \ Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n\
    \    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n          \
    \  return false\n        }\n    }\n    return true\n}\n            \nassert(match_parens(lst:\
    \ [\"()(\", \")\"]) == \"Yes\")\nassert(match_parens(lst: [\")\", \")\"]) == \"\
    No\")\nassert(match_parens(lst: [\"(()(())\", \"())())\"]) == \"No\")\nassert(match_parens(lst:\
    \ [\")())\", \"(()()(\"]) == \"Yes\")\nassert(match_parens(lst: [\"(())))\", \"\
    (()())((\"]) == \"Yes\")\nassert(match_parens(lst: [\"()\", \"())\"]) == \"No\"\
    )\nassert(match_parens(lst: [\"(()(\", \"()))()\"]) == \"Yes\")\nassert(match_parens(lst:\
    \ [\"((((\", \"((())\"]) == \"No\")\nassert(match_parens(lst: [\")(()\", \"(()(\"\
    ]) == \"No\")\nassert(match_parens(lst: [\")(\", \")(\"]) == \"No\")\nassert(match_parens(lst:\
    \ [\"(\", \")\"]) == \"Yes\")\nassert(match_parens(lst: [\")\", \"(\"]) == \"\
    Yes\")"
  status: SyntaxError
  stderr: "/tmp/tmp2z23cryq.swift:22:15: error: value of type 'String' has no member\
    \ 'replacingOccurrences'\n        s = s.replacingOccurrences(of: \"()\", with:\
    \ \"\")\n            ~ ^~~~~~~~~~~~~~~~~~~~\n"
  stdout: ''
  timestamp: 1659979532
- exit_code: -4
  program: "\n/// You are given an array of two strings, both strings consist of open\n\
    /// parentheses '(' or close parentheses ')' only.\n/// Your job is to check if\
    \ it is possible to concatenate the two strings in\n/// some order, that the resulting\
    \ string will be good.\n/// A string S is considered to be good if and only if\
    \ all parentheses in S\n/// are balanced. For example: the string '(())()' is\
    \ good, while the string\n/// '())' is not.\n/// Return 'Yes' if there's a way\
    \ to make a good string, and return 'No' otherwise.\n/// Examples:\n/// >>> match_parens(lst:\
    \ [\"()(\", \")\"])\n/// \"Yes\"\n/// >>> match_parens(lst: [\")\", \")\"])\n\
    /// \"No\"\nfunc match_parens(lst: [String]) -> String {\n    var str1 = lst[0]\n\
    \    var str2 = lst[1]\n    var f1 = str1.filter{$0 == \"(\"}\n    var f2 = str2.filter{$0\
    \ == \"(\"}\n    var f3 = str1.filter{$0 == \")\"}\n    var f4 = str2.filter{$0\
    \ == \")\"}\n    if(f1.count == f3.count && f2.count == f4.count){\n        return\
    \ \"Yes\"\n    }\n    if(f1.count == f4.count && f2.count == f3.count){\n    \
    \    return \"Yes\"\n    }\n    return \"No\"\n}\n\n\nfunc ==(left: [(Int, Int)],\
    \ right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n       \
    \ return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r\
    \ {\n            return false\n        }\n    }\n    return true\n}\n        \
    \    \nassert(match_parens(lst: [\"()(\", \")\"]) == \"Yes\")\nassert(match_parens(lst:\
    \ [\")\", \")\"]) == \"No\")\nassert(match_parens(lst: [\"(()(())\", \"())())\"\
    ]) == \"No\")\nassert(match_parens(lst: [\")())\", \"(()()(\"]) == \"Yes\")\n\
    assert(match_parens(lst: [\"(())))\", \"(()())((\"]) == \"Yes\")\nassert(match_parens(lst:\
    \ [\"()\", \"())\"]) == \"No\")\nassert(match_parens(lst: [\"(()(\", \"()))()\"\
    ]) == \"Yes\")\nassert(match_parens(lst: [\"((((\", \"((())\"]) == \"No\")\nassert(match_parens(lst:\
    \ [\")(()\", \"(()(\"]) == \"No\")\nassert(match_parens(lst: [\")(\", \")(\"])\
    \ == \"No\")\nassert(match_parens(lst: [\"(\", \")\"]) == \"Yes\")\nassert(match_parens(lst:\
    \ [\")\", \"(\"]) == \"Yes\")"
  status: Exception
  stderr: 'tmp36yeppbb/tmp36yeppbb.swift:44: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b455f145c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b455ee3cb6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b455ee3c988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b455ee3b7b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmp36yeppbb                        0x0000555657d586d6 <unavailable> + 5846

    5    libc.so.6                          0x00002b455f331460 __libc_start_main +
    245

    6    tmp36yeppbb                        0x0000555657d582b9 <unavailable> + 4793

    '
  stdout: ''
  timestamp: 1659979532
- exit_code: -4
  program: "\n/// You are given an array of two strings, both strings consist of open\n\
    /// parentheses '(' or close parentheses ')' only.\n/// Your job is to check if\
    \ it is possible to concatenate the two strings in\n/// some order, that the resulting\
    \ string will be good.\n/// A string S is considered to be good if and only if\
    \ all parentheses in S\n/// are balanced. For example: the string '(())()' is\
    \ good, while the string\n/// '())' is not.\n/// Return 'Yes' if there's a way\
    \ to make a good string, and return 'No' otherwise.\n/// Examples:\n/// >>> match_parens(lst:\
    \ [\"()(\", \")\"])\n/// \"Yes\"\n/// >>> match_parens(lst: [\")\", \")\"])\n\
    /// \"No\"\nfunc match_parens(lst: [String]) -> String {\n    var str1 = lst[0]\n\
    \    var str2 = lst[1]\n    var first_str = true\n    while !str1.isEmpty || !str2.isEmpty\
    \ {\n        let f = str1.first\n        let l = str2.last\n        if f == l\
    \ {\n            if f == \"(\" {\n                if first_str {\n           \
    \         str1.removeFirst()\n                } else {\n                    str2.removeLast()\n\
    \                }\n            } else {\n                return \"No\"\n    \
    \        }\n        } else {\n            if first_str {\n                str1.removeFirst()\n\
    \            } else {\n                str2.removeLast()\n            }\n    \
    \        first_str = !first_str\n        }\n    }\n    return \"Yes\"\n}\n\n\n\
    func ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(match_parens(lst: [\"()(\", \")\"]) == \"Yes\"\
    )\nassert(match_parens(lst: [\")\", \")\"]) == \"No\")\nassert(match_parens(lst:\
    \ [\"(()(())\", \"())())\"]) == \"No\")\nassert(match_parens(lst: [\")())\", \"\
    (()()(\"]) == \"Yes\")\nassert(match_parens(lst: [\"(())))\", \"(()())((\"]) ==\
    \ \"Yes\")\nassert(match_parens(lst: [\"()\", \"())\"]) == \"No\")\nassert(match_parens(lst:\
    \ [\"(()(\", \"()))()\"]) == \"Yes\")\nassert(match_parens(lst: [\"((((\", \"\
    ((())\"]) == \"No\")\nassert(match_parens(lst: [\")(()\", \"(()(\"]) == \"No\"\
    )\nassert(match_parens(lst: [\")(\", \")(\"]) == \"No\")\nassert(match_parens(lst:\
    \ [\"(\", \")\"]) == \"Yes\")\nassert(match_parens(lst: [\")\", \"(\"]) == \"\
    Yes\")"
  status: Exception
  stderr: 'tmpryy5cisi/tmpryy5cisi.swift:57: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b1518a16c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b151870db6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b151870d988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b151870c7b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpryy5cisi                        0x000055c8faeb4876 <unavailable> + 6262

    5    libc.so.6                          0x00002b1518c02460 __libc_start_main +
    245

    6    tmpryy5cisi                        0x000055c8faeb4459 <unavailable> + 5209

    '
  stdout: ''
  timestamp: 1659979532
- exit_code: 1
  program: "\n/// You are given an array of two strings, both strings consist of open\n\
    /// parentheses '(' or close parentheses ')' only.\n/// Your job is to check if\
    \ it is possible to concatenate the two strings in\n/// some order, that the resulting\
    \ string will be good.\n/// A string S is considered to be good if and only if\
    \ all parentheses in S\n/// are balanced. For example: the string '(())()' is\
    \ good, while the string\n/// '())' is not.\n/// Return 'Yes' if there's a way\
    \ to make a good string, and return 'No' otherwise.\n/// Examples:\n/// >>> match_parens(lst:\
    \ [\"()(\", \")\"])\n/// \"Yes\"\n/// >>> match_parens(lst: [\")\", \")\"])\n\
    /// \"No\"\nfunc match_parens(lst: [String]) -> String {\n    let (r0, r1) = (lst[0],\
    \ lst[1])\n    let (r0l, r1l) = (r0.count, r1.count)\n    var matches = Array(repeating:\
    \ 0, count: r0l + r1l)\n    var s = 0\n    var m = 0\n    for i in 0..<r0l {\n\
    \        if r0[i] == \"(\" {\n            s += 1\n        } else {\n         \
    \   s -= 1\n        }\n        matches[i] = s\n    }\n    for i in 0..<r1l {\n\
    \        let j = r0l + i\n        if r1[i] == \"(\" {\n            s += 1\n  \
    \      } else {\n            s -= 1\n        }\n        matches[j] = s\n     \
    \   if s == 0 {\n            m += 1\n        }\n    }\n    if m == 0 {\n     \
    \   return \"No\"\n    }\n    for i in 0..<r0l {\n        let j = r0l + i\n  \
    \      if matches[i] < 0 || matches[j] > 0 {\n            continue\n        }\n\
    \        if matches[i] == 0 && matches[j] == 0 {\n            return \"Yes\"\n\
    \        }\n        if matches[i] + matches[j] == 0 {\n            return \"Yes\"\
    \n        }\n    }\n    return \"No\"\n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(match_parens(lst: [\"()(\", \")\"]) == \"Yes\")\nassert(match_parens(lst:\
    \ [\")\", \")\"]) == \"No\")\nassert(match_parens(lst: [\"(()(())\", \"())())\"\
    ]) == \"No\")\nassert(match_parens(lst: [\")())\", \"(()()(\"]) == \"Yes\")\n\
    assert(match_parens(lst: [\"(())))\", \"(()())((\"]) == \"Yes\")\nassert(match_parens(lst:\
    \ [\"()\", \"())\"]) == \"No\")\nassert(match_parens(lst: [\"(()(\", \"()))()\"\
    ]) == \"Yes\")\nassert(match_parens(lst: [\"((((\", \"((())\"]) == \"No\")\nassert(match_parens(lst:\
    \ [\")(()\", \"(()(\"]) == \"No\")\nassert(match_parens(lst: [\")(\", \")(\"])\
    \ == \"No\")\nassert(match_parens(lst: [\"(\", \")\"]) == \"Yes\")\nassert(match_parens(lst:\
    \ [\")\", \"(\"]) == \"Yes\")"
  status: SyntaxError
  stderr: "/tmp/tmpi1z7y6e5.swift:22:12: error: 'subscript(_:)' is unavailable: cannot\
    \ subscript String with an Int, use a String.Index instead.\n        if r0[i]\
    \ == \"(\" {\n           ^~~~~\nSwift.String:3:12: note: 'subscript(_:)' has been\
    \ explicitly marked unavailable here\n    public subscript(i: Int) -> Character\
    \ { get }\n           ^\n/tmp/tmpi1z7y6e5.swift:31:12: error: 'subscript(_:)'\
    \ is unavailable: cannot subscript String with an Int, use a String.Index instead.\n\
    \        if r1[i] == \"(\" {\n           ^~~~~\nSwift.String:3:12: note: 'subscript(_:)'\
    \ has been explicitly marked unavailable here\n    public subscript(i: Int) ->\
    \ Character { get }\n           ^\n"
  stdout: ''
  timestamp: 1659979532
- exit_code: -4
  program: "\n/// You are given an array of two strings, both strings consist of open\n\
    /// parentheses '(' or close parentheses ')' only.\n/// Your job is to check if\
    \ it is possible to concatenate the two strings in\n/// some order, that the resulting\
    \ string will be good.\n/// A string S is considered to be good if and only if\
    \ all parentheses in S\n/// are balanced. For example: the string '(())()' is\
    \ good, while the string\n/// '())' is not.\n/// Return 'Yes' if there's a way\
    \ to make a good string, and return 'No' otherwise.\n/// Examples:\n/// >>> match_parens(lst:\
    \ [\"()(\", \")\"])\n/// \"Yes\"\n/// >>> match_parens(lst: [\")\", \")\"])\n\
    /// \"No\"\nfunc match_parens(lst: [String]) -> String {\n    var count = 0\n\
    \    var result = \"Yes\"\n    lst.joined().forEach {\n        if $0 == \"(\"\
    \ {\n            count += 1\n        } else {\n            count -= 1\n      \
    \  }\n        if count < 0 {\n            result = \"No\"\n        }\n    }\n\
    \    return result\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) ->\
    \ Bool {\n    if left.count != right.count {\n        return false\n    }\n  \
    \  for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(match_parens(lst:\
    \ [\"()(\", \")\"]) == \"Yes\")\nassert(match_parens(lst: [\")\", \")\"]) == \"\
    No\")\nassert(match_parens(lst: [\"(()(())\", \"())())\"]) == \"No\")\nassert(match_parens(lst:\
    \ [\")())\", \"(()()(\"]) == \"Yes\")\nassert(match_parens(lst: [\"(())))\", \"\
    (()())((\"]) == \"Yes\")\nassert(match_parens(lst: [\"()\", \"())\"]) == \"No\"\
    )\nassert(match_parens(lst: [\"(()(\", \"()))()\"]) == \"Yes\")\nassert(match_parens(lst:\
    \ [\"((((\", \"((())\"]) == \"No\")\nassert(match_parens(lst: [\")(()\", \"(()(\"\
    ]) == \"No\")\nassert(match_parens(lst: [\")(\", \")(\"]) == \"No\")\nassert(match_parens(lst:\
    \ [\"(\", \")\"]) == \"Yes\")\nassert(match_parens(lst: [\")\", \"(\"]) == \"\
    Yes\")"
  status: Exception
  stderr: 'tmpg8g5oh68/tmpg8g5oh68.swift:47: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b87f122bc80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b87f0f22b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b87f0f22988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b87f0f217b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpg8g5oh68                        0x00005612b1218b66 <unavailable> + 7014

    5    libc.so.6                          0x00002b87f1417460 __libc_start_main +
    245

    6    tmpg8g5oh68                        0x00005612b12182c9 <unavailable> + 4809

    '
  stdout: ''
  timestamp: 1659979532
- exit_code: -4
  program: "\n/// You are given an array of two strings, both strings consist of open\n\
    /// parentheses '(' or close parentheses ')' only.\n/// Your job is to check if\
    \ it is possible to concatenate the two strings in\n/// some order, that the resulting\
    \ string will be good.\n/// A string S is considered to be good if and only if\
    \ all parentheses in S\n/// are balanced. For example: the string '(())()' is\
    \ good, while the string\n/// '())' is not.\n/// Return 'Yes' if there's a way\
    \ to make a good string, and return 'No' otherwise.\n/// Examples:\n/// >>> match_parens(lst:\
    \ [\"()(\", \")\"])\n/// \"Yes\"\n/// >>> match_parens(lst: [\")\", \")\"])\n\
    /// \"No\"\nfunc match_parens(lst: [String]) -> String {\n    var stack = [Character]()\n\
    \    for i in 0..<lst.count {\n        for c in lst[i] {\n            if c ==\
    \ \"(\" {\n                stack.append(c)\n            } else {\n           \
    \     if stack.count == 0 {\n                    return \"No\"\n             \
    \   }\n                let curr = stack.removeLast()\n                if curr\
    \ != \"(\" {\n                    return \"No\"\n                }\n         \
    \   }\n        }\n    }\n    return \"Yes\"\n}\n\n\nfunc ==(left: [(Int, Int)],\
    \ right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n       \
    \ return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r\
    \ {\n            return false\n        }\n    }\n    return true\n}\n        \
    \    \nassert(match_parens(lst: [\"()(\", \")\"]) == \"Yes\")\nassert(match_parens(lst:\
    \ [\")\", \")\"]) == \"No\")\nassert(match_parens(lst: [\"(()(())\", \"())())\"\
    ]) == \"No\")\nassert(match_parens(lst: [\")())\", \"(()()(\"]) == \"Yes\")\n\
    assert(match_parens(lst: [\"(())))\", \"(()())((\"]) == \"Yes\")\nassert(match_parens(lst:\
    \ [\"()\", \"())\"]) == \"No\")\nassert(match_parens(lst: [\"(()(\", \"()))()\"\
    ]) == \"Yes\")\nassert(match_parens(lst: [\"((((\", \"((())\"]) == \"No\")\nassert(match_parens(lst:\
    \ [\")(()\", \"(()(\"]) == \"No\")\nassert(match_parens(lst: [\")(\", \")(\"])\
    \ == \"No\")\nassert(match_parens(lst: [\"(\", \")\"]) == \"Yes\")\nassert(match_parens(lst:\
    \ [\")\", \"(\"]) == \"Yes\")"
  status: Exception
  stderr: 'tmpbcdeed_8/tmpbcdeed_8.swift:51: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b0f4a712c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b0f4a409b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b0f4a409988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b0f4a4087b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpbcdeed_8                        0x000055c056cd1ee6 <unavailable> + 7910

    5    libc.so.6                          0x00002b0f4a8fe460 __libc_start_main +
    245

    6    tmpbcdeed_8                        0x000055c056cd1649 <unavailable> + 5705

    '
  stdout: ''
  timestamp: 1659979532
- exit_code: 1
  program: "\n/// You are given an array of two strings, both strings consist of open\n\
    /// parentheses '(' or close parentheses ')' only.\n/// Your job is to check if\
    \ it is possible to concatenate the two strings in\n/// some order, that the resulting\
    \ string will be good.\n/// A string S is considered to be good if and only if\
    \ all parentheses in S\n/// are balanced. For example: the string '(())()' is\
    \ good, while the string\n/// '())' is not.\n/// Return 'Yes' if there's a way\
    \ to make a good string, and return 'No' otherwise.\n/// Examples:\n/// >>> match_parens(lst:\
    \ [\"()(\", \")\"])\n/// \"Yes\"\n/// >>> match_parens(lst: [\")\", \")\"])\n\
    /// \"No\"\nfunc match_parens(lst: [String]) -> String {\n    var s1 = lst[0]\n\
    \    var s2 = lst[1]\n    for _ in 0..<2 {\n        let temp = s1 + s2\n     \
    \   if temp.is_good() {\n            return \"Yes\"\n        }\n        s1 = temp.remove_end(amount:\
    \ 1)\n        s2 = temp.remove_start(amount: 1)\n    }\n    return \"No\"\n}\n\
    \n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(match_parens(lst: [\"()(\", \")\"]) == \"Yes\"\
    )\nassert(match_parens(lst: [\")\", \")\"]) == \"No\")\nassert(match_parens(lst:\
    \ [\"(()(())\", \"())())\"]) == \"No\")\nassert(match_parens(lst: [\")())\", \"\
    (()()(\"]) == \"Yes\")\nassert(match_parens(lst: [\"(())))\", \"(()())((\"]) ==\
    \ \"Yes\")\nassert(match_parens(lst: [\"()\", \"())\"]) == \"No\")\nassert(match_parens(lst:\
    \ [\"(()(\", \"()))()\"]) == \"Yes\")\nassert(match_parens(lst: [\"((((\", \"\
    ((())\"]) == \"No\")\nassert(match_parens(lst: [\")(()\", \"(()(\"]) == \"No\"\
    )\nassert(match_parens(lst: [\")(\", \")(\"]) == \"No\")\nassert(match_parens(lst:\
    \ [\"(\", \")\"]) == \"Yes\")\nassert(match_parens(lst: [\")\", \"(\"]) == \"\
    Yes\")"
  status: SyntaxError
  stderr: "/tmp/tmp75roy6kw.swift:20:17: error: value of type 'String' has no member\
    \ 'is_good'\n        if temp.is_good() {\n           ~~~~ ^~~~~~~\n/tmp/tmp75roy6kw.swift:23:19:\
    \ error: value of type 'String' has no member 'remove_end'\n        s1 = temp.remove_end(amount:\
    \ 1)\n             ~~~~ ^~~~~~~~~~\n/tmp/tmp75roy6kw.swift:24:19: error: value\
    \ of type 'String' has no member 'remove_start'\n        s2 = temp.remove_start(amount:\
    \ 1)\n             ~~~~ ^~~~~~~~~~~~\n"
  stdout: ''
  timestamp: 1659979532
- exit_code: 1
  program: "\n/// You are given an array of two strings, both strings consist of open\n\
    /// parentheses '(' or close parentheses ')' only.\n/// Your job is to check if\
    \ it is possible to concatenate the two strings in\n/// some order, that the resulting\
    \ string will be good.\n/// A string S is considered to be good if and only if\
    \ all parentheses in S\n/// are balanced. For example: the string '(())()' is\
    \ good, while the string\n/// '())' is not.\n/// Return 'Yes' if there's a way\
    \ to make a good string, and return 'No' otherwise.\n/// Examples:\n/// >>> match_parens(lst:\
    \ [\"()(\", \")\"])\n/// \"Yes\"\n/// >>> match_parens(lst: [\")\", \")\"])\n\
    /// \"No\"\nfunc match_parens(lst: [String]) -> String {\n    let cnt1 = count_parens(str:\
    \ lst[0])\n    let cnt2 = count_parens(str: lst[1])\n    return cnt1 % 2 == cnt2\
    \ % 2 ? \"Yes\" : \"No\"\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(match_parens(lst:\
    \ [\"()(\", \")\"]) == \"Yes\")\nassert(match_parens(lst: [\")\", \")\"]) == \"\
    No\")\nassert(match_parens(lst: [\"(()(())\", \"())())\"]) == \"No\")\nassert(match_parens(lst:\
    \ [\")())\", \"(()()(\"]) == \"Yes\")\nassert(match_parens(lst: [\"(())))\", \"\
    (()())((\"]) == \"Yes\")\nassert(match_parens(lst: [\"()\", \"())\"]) == \"No\"\
    )\nassert(match_parens(lst: [\"(()(\", \"()))()\"]) == \"Yes\")\nassert(match_parens(lst:\
    \ [\"((((\", \"((())\"]) == \"No\")\nassert(match_parens(lst: [\")(()\", \"(()(\"\
    ]) == \"No\")\nassert(match_parens(lst: [\")(\", \")(\"]) == \"No\")\nassert(match_parens(lst:\
    \ [\"(\", \")\"]) == \"Yes\")\nassert(match_parens(lst: [\")\", \"(\"]) == \"\
    Yes\")"
  status: SyntaxError
  stderr: "/tmp/tmpme9giclu.swift:16:16: error: cannot find 'count_parens' in scope\n\
    \    let cnt1 = count_parens(str: lst[0])\n               ^~~~~~~~~~~~\n/tmp/tmpme9giclu.swift:17:16:\
    \ error: cannot find 'count_parens' in scope\n    let cnt2 = count_parens(str:\
    \ lst[1])\n               ^~~~~~~~~~~~\n"
  stdout: ''
  timestamp: 1659979532
- exit_code: 1
  program: "\n/// You are given an array of two strings, both strings consist of open\n\
    /// parentheses '(' or close parentheses ')' only.\n/// Your job is to check if\
    \ it is possible to concatenate the two strings in\n/// some order, that the resulting\
    \ string will be good.\n/// A string S is considered to be good if and only if\
    \ all parentheses in S\n/// are balanced. For example: the string '(())()' is\
    \ good, while the string\n/// '())' is not.\n/// Return 'Yes' if there's a way\
    \ to make a good string, and return 'No' otherwise.\n/// Examples:\n/// >>> match_parens(lst:\
    \ [\"()(\", \")\"])\n/// \"Yes\"\n/// >>> match_parens(lst: [\")\", \")\"])\n\
    /// \"No\"\nfunc match_parens(lst: [String]) -> String {\n  var result = \"Yes\"\
    \n  let first = lst[0]\n  let second = lst[1]\n  let offset = second.startIndex\n\
    \  var opens = 0\n  var closes = 0\n  for char in first {\n    if char == \"(\"\
    \ {\n      opens += 1\n    } else {\n      closes += 1\n    }\n  }\n  for char\
    \ in second {\n    if char == \"(\" {\n      opens += 1\n    } else {\n      closes\
    \ += 1\n    }\n  }\n  if opens == closes {\n    var new = [String]()\n    var\
    \ newStr = \"\"\n    for char in first {\n      newStr += String(char)\n    }\n\
    \    new.append(newStr)\n    newStr = \"\"\n    for char in second {\n      newStr\
    \ += String(char)\n    }\n    new.append(newStr)\n    if !check_balanced(lst:\
    \ new) {\n      result = \"No\"\n    }\n  } else {\n    result = \"No\"\n  }\n\
    \  return result\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool\
    \ {\n    if left.count != right.count {\n        return false\n    }\n    for\
    \ (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(match_parens(lst:\
    \ [\"()(\", \")\"]) == \"Yes\")\nassert(match_parens(lst: [\")\", \")\"]) == \"\
    No\")\nassert(match_parens(lst: [\"(()(())\", \"())())\"]) == \"No\")\nassert(match_parens(lst:\
    \ [\")())\", \"(()()(\"]) == \"Yes\")\nassert(match_parens(lst: [\"(())))\", \"\
    (()())((\"]) == \"Yes\")\nassert(match_parens(lst: [\"()\", \"())\"]) == \"No\"\
    )\nassert(match_parens(lst: [\"(()(\", \"()))()\"]) == \"Yes\")\nassert(match_parens(lst:\
    \ [\"((((\", \"((())\"]) == \"No\")\nassert(match_parens(lst: [\")(()\", \"(()(\"\
    ]) == \"No\")\nassert(match_parens(lst: [\")(\", \")(\"]) == \"No\")\nassert(match_parens(lst:\
    \ [\"(\", \")\"]) == \"Yes\")\nassert(match_parens(lst: [\")\", \"(\"]) == \"\
    Yes\")"
  status: SyntaxError
  stderr: "/tmp/tmpya9v_uoh.swift:48:9: error: cannot find 'check_balanced' in scope\n\
    \    if !check_balanced(lst: new) {\n        ^~~~~~~~~~~~~~\n"
  stdout: ''
  timestamp: 1659979532
- exit_code: -4
  program: "\n/// You are given an array of two strings, both strings consist of open\n\
    /// parentheses '(' or close parentheses ')' only.\n/// Your job is to check if\
    \ it is possible to concatenate the two strings in\n/// some order, that the resulting\
    \ string will be good.\n/// A string S is considered to be good if and only if\
    \ all parentheses in S\n/// are balanced. For example: the string '(())()' is\
    \ good, while the string\n/// '())' is not.\n/// Return 'Yes' if there's a way\
    \ to make a good string, and return 'No' otherwise.\n/// Examples:\n/// >>> match_parens(lst:\
    \ [\"()(\", \")\"])\n/// \"Yes\"\n/// >>> match_parens(lst: [\")\", \")\"])\n\
    /// \"No\"\nfunc match_parens(lst: [String]) -> String {\n    var par_count =\
    \ 0\n    for c in lst[0] {\n        if c == \"(\" {\n            par_count +=\
    \ 1\n        } else {\n            par_count -= 1\n        }\n    }\n    for c\
    \ in lst[1] {\n        if c == \"(\" {\n            par_count += 1\n        }\
    \ else {\n            par_count -= 1\n        }\n    }\n    return par_count ==\
    \ 0 ? \"Yes\" : \"No\"\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(match_parens(lst:\
    \ [\"()(\", \")\"]) == \"Yes\")\nassert(match_parens(lst: [\")\", \")\"]) == \"\
    No\")\nassert(match_parens(lst: [\"(()(())\", \"())())\"]) == \"No\")\nassert(match_parens(lst:\
    \ [\")())\", \"(()()(\"]) == \"Yes\")\nassert(match_parens(lst: [\"(())))\", \"\
    (()())((\"]) == \"Yes\")\nassert(match_parens(lst: [\"()\", \"())\"]) == \"No\"\
    )\nassert(match_parens(lst: [\"(()(\", \"()))()\"]) == \"Yes\")\nassert(match_parens(lst:\
    \ [\"((((\", \"((())\"]) == \"No\")\nassert(match_parens(lst: [\")(()\", \"(()(\"\
    ]) == \"No\")\nassert(match_parens(lst: [\")(\", \")(\"]) == \"No\")\nassert(match_parens(lst:\
    \ [\"(\", \")\"]) == \"Yes\")\nassert(match_parens(lst: [\")\", \"(\"]) == \"\
    Yes\")"
  status: Exception
  stderr: 'tmpn7sjz5a6/tmpn7sjz5a6.swift:56: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b9e6272ec80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b9e62425b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b9e62425988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b9e624247b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpn7sjz5a6                        0x00005569f596f468 <unavailable> + 9320

    5    libc.so.6                          0x00002b9e6291a460 __libc_start_main +
    245

    6    tmpn7sjz5a6                        0x00005569f596e289 <unavailable> + 4745

    '
  stdout: ''
  timestamp: 1659979532
- exit_code: -4
  program: "\n/// You are given an array of two strings, both strings consist of open\n\
    /// parentheses '(' or close parentheses ')' only.\n/// Your job is to check if\
    \ it is possible to concatenate the two strings in\n/// some order, that the resulting\
    \ string will be good.\n/// A string S is considered to be good if and only if\
    \ all parentheses in S\n/// are balanced. For example: the string '(())()' is\
    \ good, while the string\n/// '())' is not.\n/// Return 'Yes' if there's a way\
    \ to make a good string, and return 'No' otherwise.\n/// Examples:\n/// >>> match_parens(lst:\
    \ [\"()(\", \")\"])\n/// \"Yes\"\n/// >>> match_parens(lst: [\")\", \")\"])\n\
    /// \"No\"\nfunc match_parens(lst: [String]) -> String {\n    return \"No\"\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(match_parens(lst: [\"()(\", \")\"]) == \"Yes\"\
    )\nassert(match_parens(lst: [\")\", \")\"]) == \"No\")\nassert(match_parens(lst:\
    \ [\"(()(())\", \"())())\"]) == \"No\")\nassert(match_parens(lst: [\")())\", \"\
    (()()(\"]) == \"Yes\")\nassert(match_parens(lst: [\"(())))\", \"(()())((\"]) ==\
    \ \"Yes\")\nassert(match_parens(lst: [\"()\", \"())\"]) == \"No\")\nassert(match_parens(lst:\
    \ [\"(()(\", \"()))()\"]) == \"Yes\")\nassert(match_parens(lst: [\"((((\", \"\
    ((())\"]) == \"No\")\nassert(match_parens(lst: [\")(()\", \"(()(\"]) == \"No\"\
    )\nassert(match_parens(lst: [\")(\", \")(\"]) == \"No\")\nassert(match_parens(lst:\
    \ [\"(\", \")\"]) == \"Yes\")\nassert(match_parens(lst: [\")\", \"(\"]) == \"\
    Yes\")"
  status: Exception
  stderr: 'tmpcvhfyhzs/tmpcvhfyhzs.swift:32: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b5b3b60ec80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b5b3b305b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b5b3b305988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b5b3b3047b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpcvhfyhzs                        0x000055701b3de4a6 <unavailable> + 5286

    5    libc.so.6                          0x00002b5b3b7fa460 __libc_start_main +
    245

    6    tmpcvhfyhzs                        0x000055701b3de089 <unavailable> + 4233

    '
  stdout: ''
  timestamp: 1659979532
- exit_code: -4
  program: "\n/// You are given an array of two strings, both strings consist of open\n\
    /// parentheses '(' or close parentheses ')' only.\n/// Your job is to check if\
    \ it is possible to concatenate the two strings in\n/// some order, that the resulting\
    \ string will be good.\n/// A string S is considered to be good if and only if\
    \ all parentheses in S\n/// are balanced. For example: the string '(())()' is\
    \ good, while the string\n/// '())' is not.\n/// Return 'Yes' if there's a way\
    \ to make a good string, and return 'No' otherwise.\n/// Examples:\n/// >>> match_parens(lst:\
    \ [\"()(\", \")\"])\n/// \"Yes\"\n/// >>> match_parens(lst: [\")\", \")\"])\n\
    /// \"No\"\nfunc match_parens(lst: [String]) -> String {\n    var s = lst[0] +\
    \ lst[1]\n    while true {\n        let ch1 = s.index(s.startIndex, offsetBy:\
    \ 0)\n        let ch2 = s.index(s.startIndex, offsetBy: 1)\n        if s[ch1]\
    \ == \")\" && s[ch2] == \"(\" {\n            s.remove(at: ch1)\n            s.remove(at:\
    \ ch2)\n        } else {\n            break\n        }\n    }\n    if s.count\
    \ == 0 {\n        return \"Yes\"\n    } else {\n        return \"No\"\n    }\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(match_parens(lst: [\"()(\", \")\"]) == \"Yes\"\
    )\nassert(match_parens(lst: [\")\", \")\"]) == \"No\")\nassert(match_parens(lst:\
    \ [\"(()(())\", \"())())\"]) == \"No\")\nassert(match_parens(lst: [\")())\", \"\
    (()()(\"]) == \"Yes\")\nassert(match_parens(lst: [\"(())))\", \"(()())((\"]) ==\
    \ \"Yes\")\nassert(match_parens(lst: [\"()\", \"())\"]) == \"No\")\nassert(match_parens(lst:\
    \ [\"(()(\", \"()))()\"]) == \"Yes\")\nassert(match_parens(lst: [\"((((\", \"\
    ((())\"]) == \"No\")\nassert(match_parens(lst: [\")(()\", \"(()(\"]) == \"No\"\
    )\nassert(match_parens(lst: [\")(\", \")(\"]) == \"No\")\nassert(match_parens(lst:\
    \ [\"(\", \")\"]) == \"Yes\")\nassert(match_parens(lst: [\")\", \"(\"]) == \"\
    Yes\")"
  status: Exception
  stderr: 'tmp8_ngtu5z/tmp8_ngtu5z.swift:47: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b7e6c006c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b7e6bcfdb6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b7e6bcfd988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b7e6bcfc7b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmp8_ngtu5z                        0x000055a03aba8806 <unavailable> + 6150

    5    libc.so.6                          0x00002b7e6c1f2460 __libc_start_main +
    245

    6    tmp8_ngtu5z                        0x000055a03aba83e9 <unavailable> + 5097

    '
  stdout: ''
  timestamp: 1659979532
- exit_code: 1
  program: "\n/// You are given an array of two strings, both strings consist of open\n\
    /// parentheses '(' or close parentheses ')' only.\n/// Your job is to check if\
    \ it is possible to concatenate the two strings in\n/// some order, that the resulting\
    \ string will be good.\n/// A string S is considered to be good if and only if\
    \ all parentheses in S\n/// are balanced. For example: the string '(())()' is\
    \ good, while the string\n/// '())' is not.\n/// Return 'Yes' if there's a way\
    \ to make a good string, and return 'No' otherwise.\n/// Examples:\n/// >>> match_parens(lst:\
    \ [\"()(\", \")\"])\n/// \"Yes\"\n/// >>> match_parens(lst: [\")\", \")\"])\n\
    /// \"No\"\nfunc match_parens(lst: [String]) -> String {\n    var open = 0\n \
    \   var close = 0\n    var i = 0\n    while (i < lst[0].count) {\n        if (lst[0][i]\
    \ == \"(\") {\n            open += 1\n        } else {\n            close += 1\n\
    \        }\n        i += 1\n    }\n    if (open == close) {\n        i = 0\n \
    \       while (i < lst[1].count) {\n            if (lst[1][i] == \"(\") {\n  \
    \              open += 1\n            } else {\n                close += 1\n \
    \           }\n            i += 1\n        }\n        if (open == close) {\n \
    \           return \"Yes\"\n        }\n    }\n    return \"No\"\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(match_parens(lst: [\"()(\", \")\"]) == \"Yes\")\nassert(match_parens(lst:\
    \ [\")\", \")\"]) == \"No\")\nassert(match_parens(lst: [\"(()(())\", \"())())\"\
    ]) == \"No\")\nassert(match_parens(lst: [\")())\", \"(()()(\"]) == \"Yes\")\n\
    assert(match_parens(lst: [\"(())))\", \"(()())((\"]) == \"Yes\")\nassert(match_parens(lst:\
    \ [\"()\", \"())\"]) == \"No\")\nassert(match_parens(lst: [\"(()(\", \"()))()\"\
    ]) == \"Yes\")\nassert(match_parens(lst: [\"((((\", \"((())\"]) == \"No\")\nassert(match_parens(lst:\
    \ [\")(()\", \"(()(\"]) == \"No\")\nassert(match_parens(lst: [\")(\", \")(\"])\
    \ == \"No\")\nassert(match_parens(lst: [\"(\", \")\"]) == \"Yes\")\nassert(match_parens(lst:\
    \ [\")\", \"(\"]) == \"Yes\")"
  status: SyntaxError
  stderr: "/tmp/tmp20aneert.swift:20:13: error: 'subscript(_:)' is unavailable: cannot\
    \ subscript String with an Int, use a String.Index instead.\n        if (lst[0][i]\
    \ == \"(\") {\n            ^~~~~~~~~\nSwift.String:3:12: note: 'subscript(_:)'\
    \ has been explicitly marked unavailable here\n    public subscript(i: Int) ->\
    \ Character { get }\n           ^\n/tmp/tmp20aneert.swift:30:17: error: 'subscript(_:)'\
    \ is unavailable: cannot subscript String with an Int, use a String.Index instead.\n\
    \            if (lst[1][i] == \"(\") {\n                ^~~~~~~~~\nSwift.String:3:12:\
    \ note: 'subscript(_:)' has been explicitly marked unavailable here\n    public\
    \ subscript(i: Int) -> Character { get }\n           ^\n"
  stdout: ''
  timestamp: 1659979532
- exit_code: -4
  program: "\n/// You are given an array of two strings, both strings consist of open\n\
    /// parentheses '(' or close parentheses ')' only.\n/// Your job is to check if\
    \ it is possible to concatenate the two strings in\n/// some order, that the resulting\
    \ string will be good.\n/// A string S is considered to be good if and only if\
    \ all parentheses in S\n/// are balanced. For example: the string '(())()' is\
    \ good, while the string\n/// '())' is not.\n/// Return 'Yes' if there's a way\
    \ to make a good string, and return 'No' otherwise.\n/// Examples:\n/// >>> match_parens(lst:\
    \ [\"()(\", \")\"])\n/// \"Yes\"\n/// >>> match_parens(lst: [\")\", \")\"])\n\
    /// \"No\"\nfunc match_parens(lst: [String]) -> String {\n    var leftParens =\
    \ 0\n    var rightParens = 0\n    for char in lst[0] {\n        if char == \"\
    (\" {\n            leftParens += 1\n        } else {\n            rightParens\
    \ += 1\n        }\n    }\n    for char in lst[1] {\n        if char == \"(\" {\n\
    \            leftParens += 1\n        } else {\n            rightParens += 1\n\
    \        }\n    }\n    if leftParens == rightParens {\n        return \"Yes\"\n\
    \    }\n    return \"No\"\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(match_parens(lst:\
    \ [\"()(\", \")\"]) == \"Yes\")\nassert(match_parens(lst: [\")\", \")\"]) == \"\
    No\")\nassert(match_parens(lst: [\"(()(())\", \"())())\"]) == \"No\")\nassert(match_parens(lst:\
    \ [\")())\", \"(()()(\"]) == \"Yes\")\nassert(match_parens(lst: [\"(())))\", \"\
    (()())((\"]) == \"Yes\")\nassert(match_parens(lst: [\"()\", \"())\"]) == \"No\"\
    )\nassert(match_parens(lst: [\"(()(\", \"()))()\"]) == \"Yes\")\nassert(match_parens(lst:\
    \ [\"((((\", \"((())\"]) == \"No\")\nassert(match_parens(lst: [\")(()\", \"(()(\"\
    ]) == \"No\")\nassert(match_parens(lst: [\")(\", \")(\"]) == \"No\")\nassert(match_parens(lst:\
    \ [\"(\", \")\"]) == \"Yes\")\nassert(match_parens(lst: [\")\", \"(\"]) == \"\
    Yes\")"
  status: Exception
  stderr: 'tmpo395ajfy/tmpo395ajfy.swift:60: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002ab01fd7fc80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002ab01fa76b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002ab01fa76988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002ab01fa757b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpo395ajfy                        0x0000564c80d05468 <unavailable> + 9320

    5    libc.so.6                          0x00002ab01ff6b460 __libc_start_main +
    245

    6    tmpo395ajfy                        0x0000564c80d04289 <unavailable> + 4745

    '
  stdout: ''
  timestamp: 1659979532
- exit_code: -4
  program: "\n/// You are given an array of two strings, both strings consist of open\n\
    /// parentheses '(' or close parentheses ')' only.\n/// Your job is to check if\
    \ it is possible to concatenate the two strings in\n/// some order, that the resulting\
    \ string will be good.\n/// A string S is considered to be good if and only if\
    \ all parentheses in S\n/// are balanced. For example: the string '(())()' is\
    \ good, while the string\n/// '())' is not.\n/// Return 'Yes' if there's a way\
    \ to make a good string, and return 'No' otherwise.\n/// Examples:\n/// >>> match_parens(lst:\
    \ [\"()(\", \")\"])\n/// \"Yes\"\n/// >>> match_parens(lst: [\")\", \")\"])\n\
    /// \"No\"\nfunc match_parens(lst: [String]) -> String {\n    if lst.count !=\
    \ 2 {\n        return \"Invalid input\"\n    }\n    var lst = lst\n    let l1\
    \ = lst[0]\n    let l2 = lst[1]\n    let s = l1 + l2\n    var stack = [Character]()\n\
    \    for c in s {\n        if c == \"(\" {\n            stack.append(c)\n    \
    \    } else {\n            if stack.count == 0 {\n                return \"No\"\
    \n            }\n            let p = stack.popLast()!\n            if p != \"\
    (\" {\n                return \"No\"\n            }\n        }\n    }\n    if\
    \ stack.count == 0 {\n        return \"Yes\"\n    }\n    return \"No\"\n}\n\n\n\
    func ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(match_parens(lst: [\"()(\", \")\"]) == \"Yes\"\
    )\nassert(match_parens(lst: [\")\", \")\"]) == \"No\")\nassert(match_parens(lst:\
    \ [\"(()(())\", \"())())\"]) == \"No\")\nassert(match_parens(lst: [\")())\", \"\
    (()()(\"]) == \"Yes\")\nassert(match_parens(lst: [\"(())))\", \"(()())((\"]) ==\
    \ \"Yes\")\nassert(match_parens(lst: [\"()\", \"())\"]) == \"No\")\nassert(match_parens(lst:\
    \ [\"(()(\", \"()))()\"]) == \"Yes\")\nassert(match_parens(lst: [\"((((\", \"\
    ((())\"]) == \"No\")\nassert(match_parens(lst: [\")(()\", \"(()(\"]) == \"No\"\
    )\nassert(match_parens(lst: [\")(\", \")(\"]) == \"No\")\nassert(match_parens(lst:\
    \ [\"(\", \")\"]) == \"Yes\")\nassert(match_parens(lst: [\")\", \"(\"]) == \"\
    Yes\")"
  status: Exception
  stderr: 'tmp3e93dca4/tmp3e93dca4.swift:59: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002abfc2d7cc80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002abfc2a73b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002abfc2a73988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002abfc2a727b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmp3e93dca4                        0x0000562f1bd4ae46 <unavailable> + 7750

    5    libc.so.6                          0x00002abfc2f68460 __libc_start_main +
    245

    6    tmp3e93dca4                        0x0000562f1bd4a5a9 <unavailable> + 5545

    '
  stdout: ''
  timestamp: 1659979532
- exit_code: -4
  program: "\n/// You are given an array of two strings, both strings consist of open\n\
    /// parentheses '(' or close parentheses ')' only.\n/// Your job is to check if\
    \ it is possible to concatenate the two strings in\n/// some order, that the resulting\
    \ string will be good.\n/// A string S is considered to be good if and only if\
    \ all parentheses in S\n/// are balanced. For example: the string '(())()' is\
    \ good, while the string\n/// '())' is not.\n/// Return 'Yes' if there's a way\
    \ to make a good string, and return 'No' otherwise.\n/// Examples:\n/// >>> match_parens(lst:\
    \ [\"()(\", \")\"])\n/// \"Yes\"\n/// >>> match_parens(lst: [\")\", \")\"])\n\
    /// \"No\"\nfunc match_parens(lst: [String]) -> String {\n    var unmatched =\
    \ 0\n    for ch in lst[0] {\n        if ch == \"(\" {\n            unmatched +=\
    \ 1\n        } else {\n            unmatched -= 1\n        }\n    }\n    for ch\
    \ in lst[1] {\n        if ch == \"(\" {\n            unmatched += 1\n        }\
    \ else {\n            unmatched -= 1\n        }\n    }\n    return unmatched ==\
    \ 0 ? \"Yes\" : \"No\"\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(match_parens(lst:\
    \ [\"()(\", \")\"]) == \"Yes\")\nassert(match_parens(lst: [\")\", \")\"]) == \"\
    No\")\nassert(match_parens(lst: [\"(()(())\", \"())())\"]) == \"No\")\nassert(match_parens(lst:\
    \ [\")())\", \"(()()(\"]) == \"Yes\")\nassert(match_parens(lst: [\"(())))\", \"\
    (()())((\"]) == \"Yes\")\nassert(match_parens(lst: [\"()\", \"())\"]) == \"No\"\
    )\nassert(match_parens(lst: [\"(()(\", \"()))()\"]) == \"Yes\")\nassert(match_parens(lst:\
    \ [\"((((\", \"((())\"]) == \"No\")\nassert(match_parens(lst: [\")(()\", \"(()(\"\
    ]) == \"No\")\nassert(match_parens(lst: [\")(\", \")(\"]) == \"No\")\nassert(match_parens(lst:\
    \ [\"(\", \")\"]) == \"Yes\")\nassert(match_parens(lst: [\")\", \"(\"]) == \"\
    Yes\")"
  status: Exception
  stderr: 'tmp_an5f7kc/tmp_an5f7kc.swift:56: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b404d09ec80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b404cd95b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b404cd95988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b404cd947b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmp_an5f7kc                        0x000055dba5fc1468 <unavailable> + 9320

    5    libc.so.6                          0x00002b404d28a460 __libc_start_main +
    245

    6    tmp_an5f7kc                        0x000055dba5fc0289 <unavailable> + 4745

    '
  stdout: ''
  timestamp: 1659979532
- exit_code: 1
  program: "\n/// You are given an array of two strings, both strings consist of open\n\
    /// parentheses '(' or close parentheses ')' only.\n/// Your job is to check if\
    \ it is possible to concatenate the two strings in\n/// some order, that the resulting\
    \ string will be good.\n/// A string S is considered to be good if and only if\
    \ all parentheses in S\n/// are balanced. For example: the string '(())()' is\
    \ good, while the string\n/// '())' is not.\n/// Return 'Yes' if there's a way\
    \ to make a good string, and return 'No' otherwise.\n/// Examples:\n/// >>> match_parens(lst:\
    \ [\"()(\", \")\"])\n/// \"Yes\"\n/// >>> match_parens(lst: [\")\", \")\"])\n\
    /// \"No\"\nfunc match_parens(lst: [String]) -> String {\n    // Don't allow empty\
    \ strings, and non-parenthesis characters\n    if lst.contains(where: { $0.isEmpty\
    \ || !$0.contains(only: \"(\", \")\") }) {\n        return \"No\"\n    }\n   \
    \ // Iterate through the list of strings, concatenating and checking for balance\n\
    \    var balanced = true\n    for str in lst {\n        balanced = balanced &&\
    \ str.is_balanced()\n    }\n    return balanced ? \"Yes\" : \"No\"\n}\n\n\nfunc\
    \ ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count !=\
    \ right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(match_parens(lst: [\"()(\", \")\"]) == \"Yes\"\
    )\nassert(match_parens(lst: [\")\", \")\"]) == \"No\")\nassert(match_parens(lst:\
    \ [\"(()(())\", \"())())\"]) == \"No\")\nassert(match_parens(lst: [\")())\", \"\
    (()()(\"]) == \"Yes\")\nassert(match_parens(lst: [\"(())))\", \"(()())((\"]) ==\
    \ \"Yes\")\nassert(match_parens(lst: [\"()\", \"())\"]) == \"No\")\nassert(match_parens(lst:\
    \ [\"(()(\", \"()))()\"]) == \"Yes\")\nassert(match_parens(lst: [\"((((\", \"\
    ((())\"]) == \"No\")\nassert(match_parens(lst: [\")(()\", \"(()(\"]) == \"No\"\
    )\nassert(match_parens(lst: [\")(\", \")(\"]) == \"No\")\nassert(match_parens(lst:\
    \ [\"(\", \")\"]) == \"Yes\")\nassert(match_parens(lst: [\")\", \"(\"]) == \"\
    Yes\")"
  status: SyntaxError
  stderr: "/tmp/tmpx146k_qi.swift:17:68: error: extra argument in call\n    if lst.contains(where:\
    \ { $0.isEmpty || !$0.contains(only: \"(\", \")\") }) {\n                    \
    \                                   ~~~~~~~~~~~~^~~~\n/tmp/tmpx146k_qi.swift:23:36:\
    \ error: value of type 'String' has no member 'is_balanced'\n        balanced\
    \ = balanced && str.is_balanced()\n                               ~~~ ^~~~~~~~~~~\n"
  stdout: ''
  timestamp: 1659979532
- exit_code: -4
  program: "\n/// You are given an array of two strings, both strings consist of open\n\
    /// parentheses '(' or close parentheses ')' only.\n/// Your job is to check if\
    \ it is possible to concatenate the two strings in\n/// some order, that the resulting\
    \ string will be good.\n/// A string S is considered to be good if and only if\
    \ all parentheses in S\n/// are balanced. For example: the string '(())()' is\
    \ good, while the string\n/// '())' is not.\n/// Return 'Yes' if there's a way\
    \ to make a good string, and return 'No' otherwise.\n/// Examples:\n/// >>> match_parens(lst:\
    \ [\"()(\", \")\"])\n/// \"Yes\"\n/// >>> match_parens(lst: [\")\", \")\"])\n\
    /// \"No\"\nfunc match_parens(lst: [String]) -> String {\n    var ans = \"\"\n\
    \    let str1 = lst[0]\n    let str2 = lst[1]\n    var left_parenthesis = 0\n\
    \    var right_parenthesis = 0\n    for i in str1 {\n        if i == \"(\" {\n\
    \            left_parenthesis += 1\n        } else {\n            right_parenthesis\
    \ += 1\n        }\n    }\n    for i in str2 {\n        if i == \"(\" {\n     \
    \       left_parenthesis += 1\n        } else {\n            right_parenthesis\
    \ += 1\n        }\n    }\n    if left_parenthesis == right_parenthesis {\n   \
    \     ans = \"Yes\"\n    } else {\n        ans = \"No\"\n    }\n    return ans\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(match_parens(lst: [\"()(\", \")\"]) == \"Yes\"\
    )\nassert(match_parens(lst: [\")\", \")\"]) == \"No\")\nassert(match_parens(lst:\
    \ [\"(()(())\", \"())())\"]) == \"No\")\nassert(match_parens(lst: [\")())\", \"\
    (()()(\"]) == \"Yes\")\nassert(match_parens(lst: [\"(())))\", \"(()())((\"]) ==\
    \ \"Yes\")\nassert(match_parens(lst: [\"()\", \"())\"]) == \"No\")\nassert(match_parens(lst:\
    \ [\"(()(\", \"()))()\"]) == \"Yes\")\nassert(match_parens(lst: [\"((((\", \"\
    ((())\"]) == \"No\")\nassert(match_parens(lst: [\")(()\", \"(()(\"]) == \"No\"\
    )\nassert(match_parens(lst: [\")(\", \")(\"]) == \"No\")\nassert(match_parens(lst:\
    \ [\"(\", \")\"]) == \"Yes\")\nassert(match_parens(lst: [\")\", \"(\"]) == \"\
    Yes\")"
  status: Exception
  stderr: 'tmpk4xkn_bn/tmpk4xkn_bn.swift:65: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b5fd7f47c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b5fd7c3eb6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b5fd7c3e988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b5fd7c3d7b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpk4xkn_bn                        0x0000561c61fb7468 <unavailable> + 9320

    5    libc.so.6                          0x00002b5fd8133460 __libc_start_main +
    245

    6    tmpk4xkn_bn                        0x0000561c61fb6289 <unavailable> + 4745

    '
  stdout: ''
  timestamp: 1659979532
- exit_code: -4
  program: "\n/// You are given an array of two strings, both strings consist of open\n\
    /// parentheses '(' or close parentheses ')' only.\n/// Your job is to check if\
    \ it is possible to concatenate the two strings in\n/// some order, that the resulting\
    \ string will be good.\n/// A string S is considered to be good if and only if\
    \ all parentheses in S\n/// are balanced. For example: the string '(())()' is\
    \ good, while the string\n/// '())' is not.\n/// Return 'Yes' if there's a way\
    \ to make a good string, and return 'No' otherwise.\n/// Examples:\n/// >>> match_parens(lst:\
    \ [\"()(\", \")\"])\n/// \"Yes\"\n/// >>> match_parens(lst: [\")\", \")\"])\n\
    /// \"No\"\nfunc match_parens(lst: [String]) -> String {\n    var lst1 = lst[0]\n\
    \    var lst2 = lst[1]\n    var net_balance = 0\n    for char in lst1 {\n    \
    \    net_balance += char == \"(\" ? 1 : -1\n    }\n    for char in lst2 {\n  \
    \      net_balance += char == \"(\" ? 1 : -1\n    }\n    if net_balance != 0 {\n\
    \        return \"No\"\n    }\n    var lst1_balance = 0\n    for char in lst1\
    \ {\n        lst1_balance += char == \"(\" ? 1 : -1\n        if lst1_balance <\
    \ 0 {\n            return \"No\"\n        }\n    }\n    if lst1_balance == 0 {\n\
    \        return \"Yes\"\n    }\n    var lst2_balance = 0\n    for char in lst2\
    \ {\n        lst2_balance += char == \"(\" ? 1 : -1\n        if lst2_balance >\
    \ 0 {\n            return \"No\"\n        }\n    }\n    return \"Yes\"\n}\n\n\n\
    func ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(match_parens(lst: [\"()(\", \")\"]) == \"Yes\"\
    )\nassert(match_parens(lst: [\")\", \")\"]) == \"No\")\nassert(match_parens(lst:\
    \ [\"(()(())\", \"())())\"]) == \"No\")\nassert(match_parens(lst: [\")())\", \"\
    (()()(\"]) == \"Yes\")\nassert(match_parens(lst: [\"(())))\", \"(()())((\"]) ==\
    \ \"Yes\")\nassert(match_parens(lst: [\"()\", \"())\"]) == \"No\")\nassert(match_parens(lst:\
    \ [\"(()(\", \"()))()\"]) == \"Yes\")\nassert(match_parens(lst: [\"((((\", \"\
    ((())\"]) == \"No\")\nassert(match_parens(lst: [\")(()\", \"(()(\"]) == \"No\"\
    )\nassert(match_parens(lst: [\")(\", \")(\"]) == \"No\")\nassert(match_parens(lst:\
    \ [\"(\", \")\"]) == \"Yes\")\nassert(match_parens(lst: [\")\", \"(\"]) == \"\
    Yes\")"
  status: Exception
  stderr: 'tmprjh8m9c5/tmprjh8m9c5.swift:64: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b94bbd8ac80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b94bba81b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b94bba81988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b94bba807b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmprjh8m9c5                        0x0000561756e6eb26 <unavailable> + 6950

    5    libc.so.6                          0x00002b94bbf76460 __libc_start_main +
    245

    6    tmprjh8m9c5                        0x0000561756e6e289 <unavailable> + 4745

    '
  stdout: ''
  timestamp: 1659979532
- exit_code: -4
  program: "\n/// You are given an array of two strings, both strings consist of open\n\
    /// parentheses '(' or close parentheses ')' only.\n/// Your job is to check if\
    \ it is possible to concatenate the two strings in\n/// some order, that the resulting\
    \ string will be good.\n/// A string S is considered to be good if and only if\
    \ all parentheses in S\n/// are balanced. For example: the string '(())()' is\
    \ good, while the string\n/// '())' is not.\n/// Return 'Yes' if there's a way\
    \ to make a good string, and return 'No' otherwise.\n/// Examples:\n/// >>> match_parens(lst:\
    \ [\"()(\", \")\"])\n/// \"Yes\"\n/// >>> match_parens(lst: [\")\", \")\"])\n\
    /// \"No\"\nfunc match_parens(lst: [String]) -> String {\n    var str_lst = lst\n\
    \    var yes_stack = [String]()\n    var no_stack = [String]()\n    for str in\
    \ str_lst {\n        for char in str {\n            if char == \"(\" {\n     \
    \           yes_stack.append(String(char))\n            } else {\n           \
    \     if yes_stack.count > 0 {\n                    yes_stack.removeLast()\n \
    \               } else {\n                    no_stack.append(String(char))\n\
    \                }\n            }\n        }\n    }\n    if no_stack.count > 0\
    \ || yes_stack.count > 0 {\n        return \"No\"\n    } else {\n        return\
    \ \"Yes\"\n    }\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool\
    \ {\n    if left.count != right.count {\n        return false\n    }\n    for\
    \ (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(match_parens(lst:\
    \ [\"()(\", \")\"]) == \"Yes\")\nassert(match_parens(lst: [\")\", \")\"]) == \"\
    No\")\nassert(match_parens(lst: [\"(()(())\", \"())())\"]) == \"No\")\nassert(match_parens(lst:\
    \ [\")())\", \"(()()(\"]) == \"Yes\")\nassert(match_parens(lst: [\"(())))\", \"\
    (()())((\"]) == \"Yes\")\nassert(match_parens(lst: [\"()\", \"())\"]) == \"No\"\
    )\nassert(match_parens(lst: [\"(()(\", \"()))()\"]) == \"Yes\")\nassert(match_parens(lst:\
    \ [\"((((\", \"((())\"]) == \"No\")\nassert(match_parens(lst: [\")(()\", \"(()(\"\
    ]) == \"No\")\nassert(match_parens(lst: [\")(\", \")(\"]) == \"No\")\nassert(match_parens(lst:\
    \ [\"(\", \")\"]) == \"Yes\")\nassert(match_parens(lst: [\")\", \"(\"]) == \"\
    Yes\")"
  status: Exception
  stderr: 'tmpd8pz3d6i/tmpd8pz3d6i.swift:55: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b138d92fc80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b138d626b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b138d626988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b138d6257b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpd8pz3d6i                        0x000055a67f3ade76 <unavailable> + 7798

    5    libc.so.6                          0x00002b138db1b460 __libc_start_main +
    245

    6    tmpd8pz3d6i                        0x000055a67f3ad5d9 <unavailable> + 5593

    '
  stdout: ''
  timestamp: 1659979532
- exit_code: 1
  program: "\n/// You are given an array of two strings, both strings consist of open\n\
    /// parentheses '(' or close parentheses ')' only.\n/// Your job is to check if\
    \ it is possible to concatenate the two strings in\n/// some order, that the resulting\
    \ string will be good.\n/// A string S is considered to be good if and only if\
    \ all parentheses in S\n/// are balanced. For example: the string '(())()' is\
    \ good, while the string\n/// '())' is not.\n/// Return 'Yes' if there's a way\
    \ to make a good string, and return 'No' otherwise.\n/// Examples:\n/// >>> match_parens(lst:\
    \ [\"()(\", \")\"])\n/// \"Yes\"\n/// >>> match_parens(lst: [\")\", \")\"])\n\
    /// \"No\"\nfunc match_parens(lst: [String]) -> String {\n    return solution(lst)\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(match_parens(lst: [\"()(\", \")\"]) == \"Yes\"\
    )\nassert(match_parens(lst: [\")\", \")\"]) == \"No\")\nassert(match_parens(lst:\
    \ [\"(()(())\", \"())())\"]) == \"No\")\nassert(match_parens(lst: [\")())\", \"\
    (()()(\"]) == \"Yes\")\nassert(match_parens(lst: [\"(())))\", \"(()())((\"]) ==\
    \ \"Yes\")\nassert(match_parens(lst: [\"()\", \"())\"]) == \"No\")\nassert(match_parens(lst:\
    \ [\"(()(\", \"()))()\"]) == \"Yes\")\nassert(match_parens(lst: [\"((((\", \"\
    ((())\"]) == \"No\")\nassert(match_parens(lst: [\")(()\", \"(()(\"]) == \"No\"\
    )\nassert(match_parens(lst: [\")(\", \")(\"]) == \"No\")\nassert(match_parens(lst:\
    \ [\"(\", \")\"]) == \"Yes\")\nassert(match_parens(lst: [\")\", \"(\"]) == \"\
    Yes\")"
  status: SyntaxError
  stderr: "/tmp/tmpjgrhpk_l.swift:16:12: error: cannot find 'solution' in scope\n\
    \    return solution(lst)\n           ^~~~~~~~\n"
  stdout: ''
  timestamp: 1659979532
- exit_code: -4
  program: "\n/// You are given an array of two strings, both strings consist of open\n\
    /// parentheses '(' or close parentheses ')' only.\n/// Your job is to check if\
    \ it is possible to concatenate the two strings in\n/// some order, that the resulting\
    \ string will be good.\n/// A string S is considered to be good if and only if\
    \ all parentheses in S\n/// are balanced. For example: the string '(())()' is\
    \ good, while the string\n/// '())' is not.\n/// Return 'Yes' if there's a way\
    \ to make a good string, and return 'No' otherwise.\n/// Examples:\n/// >>> match_parens(lst:\
    \ [\"()(\", \")\"])\n/// \"Yes\"\n/// >>> match_parens(lst: [\")\", \")\"])\n\
    /// \"No\"\nfunc match_parens(lst: [String]) -> String {\n    var openCount =\
    \ 0\n    var closeCount = 0\n    for chars in lst[0] {\n        if chars == \"\
    (\" {\n            openCount += 1\n        } else {\n            closeCount +=\
    \ 1\n        }\n    }\n    for chars in lst[1] {\n        if chars == \"(\" {\n\
    \            openCount += 1\n        } else {\n            closeCount += 1\n \
    \       }\n    }\n    if closeCount == openCount {\n        return \"Yes\"\n \
    \   } else {\n        return \"No\"\n    }\n}\n\n\nfunc ==(left: [(Int, Int)],\
    \ right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n       \
    \ return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r\
    \ {\n            return false\n        }\n    }\n    return true\n}\n        \
    \    \nassert(match_parens(lst: [\"()(\", \")\"]) == \"Yes\")\nassert(match_parens(lst:\
    \ [\")\", \")\"]) == \"No\")\nassert(match_parens(lst: [\"(()(())\", \"())())\"\
    ]) == \"No\")\nassert(match_parens(lst: [\")())\", \"(()()(\"]) == \"Yes\")\n\
    assert(match_parens(lst: [\"(())))\", \"(()())((\"]) == \"Yes\")\nassert(match_parens(lst:\
    \ [\"()\", \"())\"]) == \"No\")\nassert(match_parens(lst: [\"(()(\", \"()))()\"\
    ]) == \"Yes\")\nassert(match_parens(lst: [\"((((\", \"((())\"]) == \"No\")\nassert(match_parens(lst:\
    \ [\")(()\", \"(()(\"]) == \"No\")\nassert(match_parens(lst: [\")(\", \")(\"])\
    \ == \"No\")\nassert(match_parens(lst: [\"(\", \")\"]) == \"Yes\")\nassert(match_parens(lst:\
    \ [\")\", \"(\"]) == \"Yes\")"
  status: Exception
  stderr: 'tmppbqfxp4g/tmppbqfxp4g.swift:61: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b7b7c35fc80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b7b7c056b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b7b7c056988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b7b7c0557b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmppbqfxp4g                        0x00005587910a4468 <unavailable> + 9320

    5    libc.so.6                          0x00002b7b7c54b460 __libc_start_main +
    245

    6    tmppbqfxp4g                        0x00005587910a3289 <unavailable> + 4745

    '
  stdout: ''
  timestamp: 1659979532
- exit_code: 1
  program: "\n/// You are given an array of two strings, both strings consist of open\n\
    /// parentheses '(' or close parentheses ')' only.\n/// Your job is to check if\
    \ it is possible to concatenate the two strings in\n/// some order, that the resulting\
    \ string will be good.\n/// A string S is considered to be good if and only if\
    \ all parentheses in S\n/// are balanced. For example: the string '(())()' is\
    \ good, while the string\n/// '())' is not.\n/// Return 'Yes' if there's a way\
    \ to make a good string, and return 'No' otherwise.\n/// Examples:\n/// >>> match_parens(lst:\
    \ [\"()(\", \")\"])\n/// \"Yes\"\n/// >>> match_parens(lst: [\")\", \")\"])\n\
    /// \"No\"\nfunc match_parens(lst: [String]) -> String {\n    return (lst[0] +\
    \ lst[1]).isBalanced() ? \"Yes\" : \"No\"\n}\n\n\nfunc ==(left: [(Int, Int)],\
    \ right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n       \
    \ return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r\
    \ {\n            return false\n        }\n    }\n    return true\n}\n        \
    \    \nassert(match_parens(lst: [\"()(\", \")\"]) == \"Yes\")\nassert(match_parens(lst:\
    \ [\")\", \")\"]) == \"No\")\nassert(match_parens(lst: [\"(()(())\", \"())())\"\
    ]) == \"No\")\nassert(match_parens(lst: [\")())\", \"(()()(\"]) == \"Yes\")\n\
    assert(match_parens(lst: [\"(())))\", \"(()())((\"]) == \"Yes\")\nassert(match_parens(lst:\
    \ [\"()\", \"())\"]) == \"No\")\nassert(match_parens(lst: [\"(()(\", \"()))()\"\
    ]) == \"Yes\")\nassert(match_parens(lst: [\"((((\", \"((())\"]) == \"No\")\nassert(match_parens(lst:\
    \ [\")(()\", \"(()(\"]) == \"No\")\nassert(match_parens(lst: [\")(\", \")(\"])\
    \ == \"No\")\nassert(match_parens(lst: [\"(\", \")\"]) == \"Yes\")\nassert(match_parens(lst:\
    \ [\")\", \"(\"]) == \"Yes\")"
  status: SyntaxError
  stderr: "/tmp/tmp54oesmdg.swift:16:30: error: value of type 'String' has no member\
    \ 'isBalanced'\n    return (lst[0] + lst[1]).isBalanced() ? \"Yes\" : \"No\"\n\
    \           ~~~~~~~~~~~~~~~~~ ^~~~~~~~~~\n"
  stdout: ''
  timestamp: 1659979532
- exit_code: 1
  program: "\n/// You are given an array of two strings, both strings consist of open\n\
    /// parentheses '(' or close parentheses ')' only.\n/// Your job is to check if\
    \ it is possible to concatenate the two strings in\n/// some order, that the resulting\
    \ string will be good.\n/// A string S is considered to be good if and only if\
    \ all parentheses in S\n/// are balanced. For example: the string '(())()' is\
    \ good, while the string\n/// '())' is not.\n/// Return 'Yes' if there's a way\
    \ to make a good string, and return 'No' otherwise.\n/// Examples:\n/// >>> match_parens(lst:\
    \ [\"()(\", \")\"])\n/// \"Yes\"\n/// >>> match_parens(lst: [\")\", \")\"])\n\
    /// \"No\"\nfunc match_parens(lst: [String]) -> String {\n    let s1 = lst[0]\n\
    \    let s2 = lst[1]\n    return is_good(s: s1 + s2) ? \"Yes\" : \"No\"\n}\n\n\
    \nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(match_parens(lst: [\"()(\", \")\"]) == \"Yes\"\
    )\nassert(match_parens(lst: [\")\", \")\"]) == \"No\")\nassert(match_parens(lst:\
    \ [\"(()(())\", \"())())\"]) == \"No\")\nassert(match_parens(lst: [\")())\", \"\
    (()()(\"]) == \"Yes\")\nassert(match_parens(lst: [\"(())))\", \"(()())((\"]) ==\
    \ \"Yes\")\nassert(match_parens(lst: [\"()\", \"())\"]) == \"No\")\nassert(match_parens(lst:\
    \ [\"(()(\", \"()))()\"]) == \"Yes\")\nassert(match_parens(lst: [\"((((\", \"\
    ((())\"]) == \"No\")\nassert(match_parens(lst: [\")(()\", \"(()(\"]) == \"No\"\
    )\nassert(match_parens(lst: [\")(\", \")(\"]) == \"No\")\nassert(match_parens(lst:\
    \ [\"(\", \")\"]) == \"Yes\")\nassert(match_parens(lst: [\")\", \"(\"]) == \"\
    Yes\")"
  status: SyntaxError
  stderr: "/tmp/tmpx23kba82.swift:18:12: error: cannot find 'is_good' in scope\n \
    \   return is_good(s: s1 + s2) ? \"Yes\" : \"No\"\n           ^~~~~~~\n"
  stdout: ''
  timestamp: 1659979532
- exit_code: -4
  program: "\n/// You are given an array of two strings, both strings consist of open\n\
    /// parentheses '(' or close parentheses ')' only.\n/// Your job is to check if\
    \ it is possible to concatenate the two strings in\n/// some order, that the resulting\
    \ string will be good.\n/// A string S is considered to be good if and only if\
    \ all parentheses in S\n/// are balanced. For example: the string '(())()' is\
    \ good, while the string\n/// '())' is not.\n/// Return 'Yes' if there's a way\
    \ to make a good string, and return 'No' otherwise.\n/// Examples:\n/// >>> match_parens(lst:\
    \ [\"()(\", \")\"])\n/// \"Yes\"\n/// >>> match_parens(lst: [\")\", \")\"])\n\
    /// \"No\"\nfunc match_parens(lst: [String]) -> String {\n    var stack = [Character]()\n\
    \    var str = lst[0] + lst[1]\n    for char in str {\n        if char == \"(\"\
    \ {\n            stack.append(char)\n        } else {\n            if stack.count\
    \ > 0 {\n                stack.removeLast()\n            } else {\n          \
    \      return \"No\"\n            }\n        }\n    }\n    return stack.count\
    \ == 0 ? \"Yes\" : \"No\"\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(match_parens(lst:\
    \ [\"()(\", \")\"]) == \"Yes\")\nassert(match_parens(lst: [\")\", \")\"]) == \"\
    No\")\nassert(match_parens(lst: [\"(()(())\", \"())())\"]) == \"No\")\nassert(match_parens(lst:\
    \ [\")())\", \"(()()(\"]) == \"Yes\")\nassert(match_parens(lst: [\"(())))\", \"\
    (()())((\"]) == \"Yes\")\nassert(match_parens(lst: [\"()\", \"())\"]) == \"No\"\
    )\nassert(match_parens(lst: [\"(()(\", \"()))()\"]) == \"Yes\")\nassert(match_parens(lst:\
    \ [\"((((\", \"((())\"]) == \"No\")\nassert(match_parens(lst: [\")(()\", \"(()(\"\
    ]) == \"No\")\nassert(match_parens(lst: [\")(\", \")(\"]) == \"No\")\nassert(match_parens(lst:\
    \ [\"(\", \")\"]) == \"Yes\")\nassert(match_parens(lst: [\")\", \"(\"]) == \"\
    Yes\")"
  status: Exception
  stderr: 'tmpxlp4_0ly/tmpxlp4_0ly.swift:48: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b2860728c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b286041fb6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b286041f988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b286041e7b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpxlp4_0ly                        0x0000559f4b158d66 <unavailable> + 7526

    5    libc.so.6                          0x00002b2860914460 __libc_start_main +
    245

    6    tmpxlp4_0ly                        0x0000559f4b1584c9 <unavailable> + 5321

    '
  stdout: ''
  timestamp: 1659979532
- exit_code: 1
  program: "\n/// You are given an array of two strings, both strings consist of open\n\
    /// parentheses '(' or close parentheses ')' only.\n/// Your job is to check if\
    \ it is possible to concatenate the two strings in\n/// some order, that the resulting\
    \ string will be good.\n/// A string S is considered to be good if and only if\
    \ all parentheses in S\n/// are balanced. For example: the string '(())()' is\
    \ good, while the string\n/// '())' is not.\n/// Return 'Yes' if there's a way\
    \ to make a good string, and return 'No' otherwise.\n/// Examples:\n/// >>> match_parens(lst:\
    \ [\"()(\", \")\"])\n/// \"Yes\"\n/// >>> match_parens(lst: [\")\", \")\"])\n\
    /// \"No\"\nfunc match_parens(lst: [String]) -> String {\n    let str1 = lst[0]\n\
    \    let str2 = lst[1]\n    let leftBrackets = \"(\".characters.first!\n    let\
    \ rightBrackets = \")\".characters.first!\n    if str1.characters.filter({$0 ==\
    \ leftBrackets}).count >\n        str2.characters.filter({$0 == rightBrackets}).count\
    \ {\n        return \"No\"\n    }\n    if str1.characters.filter({$0 == rightBrackets}).count\
    \ >\n        str2.characters.filter({$0 == leftBrackets}).count {\n        return\
    \ \"No\"\n    }\n    let resultStr = str1 + str2\n    if check_parens(str: resultStr)\
    \ {\n        return \"Yes\"\n    }\n    return \"No\"\n}\n\n\nfunc ==(left: [(Int,\
    \ Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n\
    \        return false\n    }\n    for (l, r) in zip(left, right) {\n        if\
    \ l != r {\n            return false\n        }\n    }\n    return true\n}\n \
    \           \nassert(match_parens(lst: [\"()(\", \")\"]) == \"Yes\")\nassert(match_parens(lst:\
    \ [\")\", \")\"]) == \"No\")\nassert(match_parens(lst: [\"(()(())\", \"())())\"\
    ]) == \"No\")\nassert(match_parens(lst: [\")())\", \"(()()(\"]) == \"Yes\")\n\
    assert(match_parens(lst: [\"(())))\", \"(()())((\"]) == \"Yes\")\nassert(match_parens(lst:\
    \ [\"()\", \"())\"]) == \"No\")\nassert(match_parens(lst: [\"(()(\", \"()))()\"\
    ]) == \"Yes\")\nassert(match_parens(lst: [\"((((\", \"((())\"]) == \"No\")\nassert(match_parens(lst:\
    \ [\")(()\", \"(()(\"]) == \"No\")\nassert(match_parens(lst: [\")(\", \")(\"])\
    \ == \"No\")\nassert(match_parens(lst: [\"(\", \")\"]) == \"Yes\")\nassert(match_parens(lst:\
    \ [\")\", \"(\"]) == \"Yes\")"
  status: SyntaxError
  stderr: "/tmp/tmpxc0zm56_.swift:18:28: error: 'characters' is unavailable: Please\
    \ use String directly\n    let leftBrackets = \"(\".characters.first!\n      \
    \                     ^~~~~~~~~~\nSwift.String:5:16: note: 'characters' was obsoleted\
    \ in Swift 5.0\n    public var characters: String { get set }\n              \
    \ ^\n/tmp/tmpxc0zm56_.swift:19:29: error: 'characters' is unavailable: Please\
    \ use String directly\n    let rightBrackets = \")\".characters.first!\n     \
    \                       ^~~~~~~~~~\nSwift.String:5:16: note: 'characters' was\
    \ obsoleted in Swift 5.0\n    public var characters: String { get set }\n    \
    \           ^\n/tmp/tmpxc0zm56_.swift:20:13: error: 'characters' is unavailable:\
    \ Please use String directly\n    if str1.characters.filter({$0 == leftBrackets}).count\
    \ >\n            ^~~~~~~~~~\nSwift.String:5:16: note: 'characters' was obsoleted\
    \ in Swift 5.0\n    public var characters: String { get set }\n              \
    \ ^\n/tmp/tmpxc0zm56_.swift:21:14: error: 'characters' is unavailable: Please\
    \ use String directly\n        str2.characters.filter({$0 == rightBrackets}).count\
    \ {\n             ^~~~~~~~~~\nSwift.String:5:16: note: 'characters' was obsoleted\
    \ in Swift 5.0\n    public var characters: String { get set }\n              \
    \ ^\n/tmp/tmpxc0zm56_.swift:24:13: error: 'characters' is unavailable: Please\
    \ use String directly\n    if str1.characters.filter({$0 == rightBrackets}).count\
    \ >\n            ^~~~~~~~~~\nSwift.String:5:16: note: 'characters' was obsoleted\
    \ in Swift 5.0\n    public var characters: String { get set }\n              \
    \ ^\n/tmp/tmpxc0zm56_.swift:25:14: error: 'characters' is unavailable: Please\
    \ use String directly\n        str2.characters.filter({$0 == leftBrackets}).count\
    \ {\n             ^~~~~~~~~~\nSwift.String:5:16: note: 'characters' was obsoleted\
    \ in Swift 5.0\n    public var characters: String { get set }\n              \
    \ ^\n/tmp/tmpxc0zm56_.swift:29:8: error: cannot find 'check_parens' in scope\n\
    \    if check_parens(str: resultStr) {\n       ^~~~~~~~~~~~\n"
  stdout: ''
  timestamp: 1659979532
- exit_code: -4
  program: "\n/// You are given an array of two strings, both strings consist of open\n\
    /// parentheses '(' or close parentheses ')' only.\n/// Your job is to check if\
    \ it is possible to concatenate the two strings in\n/// some order, that the resulting\
    \ string will be good.\n/// A string S is considered to be good if and only if\
    \ all parentheses in S\n/// are balanced. For example: the string '(())()' is\
    \ good, while the string\n/// '())' is not.\n/// Return 'Yes' if there's a way\
    \ to make a good string, and return 'No' otherwise.\n/// Examples:\n/// >>> match_parens(lst:\
    \ [\"()(\", \")\"])\n/// \"Yes\"\n/// >>> match_parens(lst: [\")\", \")\"])\n\
    /// \"No\"\nfunc match_parens(lst: [String]) -> String {\n  let s = lst[0] + lst[1]\n\
    \  var open = 0\n  for c in s {\n    if c == \"(\" {\n      open += 1\n    } else\
    \ {\n      open -= 1\n    }\n    if open < 0 {\n      return \"No\"\n    }\n \
    \ }\n  return open == 0 ? \"Yes\" : \"No\"\n}\n\n\nfunc ==(left: [(Int, Int)],\
    \ right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n       \
    \ return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r\
    \ {\n            return false\n        }\n    }\n    return true\n}\n        \
    \    \nassert(match_parens(lst: [\"()(\", \")\"]) == \"Yes\")\nassert(match_parens(lst:\
    \ [\")\", \")\"]) == \"No\")\nassert(match_parens(lst: [\"(()(())\", \"())())\"\
    ]) == \"No\")\nassert(match_parens(lst: [\")())\", \"(()()(\"]) == \"Yes\")\n\
    assert(match_parens(lst: [\"(())))\", \"(()())((\"]) == \"Yes\")\nassert(match_parens(lst:\
    \ [\"()\", \"())\"]) == \"No\")\nassert(match_parens(lst: [\"(()(\", \"()))()\"\
    ]) == \"Yes\")\nassert(match_parens(lst: [\"((((\", \"((())\"]) == \"No\")\nassert(match_parens(lst:\
    \ [\")(()\", \"(()(\"]) == \"No\")\nassert(match_parens(lst: [\")(\", \")(\"])\
    \ == \"No\")\nassert(match_parens(lst: [\"(\", \")\"]) == \"Yes\")\nassert(match_parens(lst:\
    \ [\")\", \"(\"]) == \"Yes\")"
  status: Exception
  stderr: 'tmpvo8jmvi0/tmpvo8jmvi0.swift:47: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002ae446c4dc80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002ae446944b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002ae446944988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002ae4469437b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpvo8jmvi0                        0x000055609cf2bb76 <unavailable> + 7030

    5    libc.so.6                          0x00002ae446e39460 __libc_start_main +
    245

    6    tmpvo8jmvi0                        0x000055609cf2b2d9 <unavailable> + 4825

    '
  stdout: ''
  timestamp: 1659979532
- exit_code: 1
  program: "\n/// You are given an array of two strings, both strings consist of open\n\
    /// parentheses '(' or close parentheses ')' only.\n/// Your job is to check if\
    \ it is possible to concatenate the two strings in\n/// some order, that the resulting\
    \ string will be good.\n/// A string S is considered to be good if and only if\
    \ all parentheses in S\n/// are balanced. For example: the string '(())()' is\
    \ good, while the string\n/// '())' is not.\n/// Return 'Yes' if there's a way\
    \ to make a good string, and return 'No' otherwise.\n/// Examples:\n/// >>> match_parens(lst:\
    \ [\"()(\", \")\"])\n/// \"Yes\"\n/// >>> match_parens(lst: [\")\", \")\"])\n\
    /// \"No\"\nfunc match_parens(lst: [String]) -> String {\n  var parens = lst.joined()\n\
    \  while parens.contains(\"()\") {\n    parens = parens.replacingOccurrences(of:\
    \ \"()\", with: \"\")\n  }\n  return parens.isEmpty ? \"Yes\" : \"No\"\n}\n\n\n\
    func ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(match_parens(lst: [\"()(\", \")\"]) == \"Yes\"\
    )\nassert(match_parens(lst: [\")\", \")\"]) == \"No\")\nassert(match_parens(lst:\
    \ [\"(()(())\", \"())())\"]) == \"No\")\nassert(match_parens(lst: [\")())\", \"\
    (()()(\"]) == \"Yes\")\nassert(match_parens(lst: [\"(())))\", \"(()())((\"]) ==\
    \ \"Yes\")\nassert(match_parens(lst: [\"()\", \"())\"]) == \"No\")\nassert(match_parens(lst:\
    \ [\"(()(\", \"()))()\"]) == \"Yes\")\nassert(match_parens(lst: [\"((((\", \"\
    ((())\"]) == \"No\")\nassert(match_parens(lst: [\")(()\", \"(()(\"]) == \"No\"\
    )\nassert(match_parens(lst: [\")(\", \")(\"]) == \"No\")\nassert(match_parens(lst:\
    \ [\"(\", \")\"]) == \"Yes\")\nassert(match_parens(lst: [\")\", \"(\"]) == \"\
    Yes\")"
  status: SyntaxError
  stderr: "/tmp/tmprs48im3r.swift:18:21: error: value of type 'String' has no member\
    \ 'replacingOccurrences'\n    parens = parens.replacingOccurrences(of: \"()\"\
    , with: \"\")\n             ~~~~~~ ^~~~~~~~~~~~~~~~~~~~\n"
  stdout: ''
  timestamp: 1659979532
- exit_code: -4
  program: "\n/// You are given an array of two strings, both strings consist of open\n\
    /// parentheses '(' or close parentheses ')' only.\n/// Your job is to check if\
    \ it is possible to concatenate the two strings in\n/// some order, that the resulting\
    \ string will be good.\n/// A string S is considered to be good if and only if\
    \ all parentheses in S\n/// are balanced. For example: the string '(())()' is\
    \ good, while the string\n/// '())' is not.\n/// Return 'Yes' if there's a way\
    \ to make a good string, and return 'No' otherwise.\n/// Examples:\n/// >>> match_parens(lst:\
    \ [\"()(\", \")\"])\n/// \"Yes\"\n/// >>> match_parens(lst: [\")\", \")\"])\n\
    /// \"No\"\nfunc match_parens(lst: [String]) -> String {\n    let set = Array(lst.joined())\n\
    \    var stack = [Character]()\n    for (_, char) in set.enumerated() {\n    \
    \    if char == \"(\" {\n            stack.append(char)\n        } else {\n  \
    \          if stack.isEmpty {\n                return \"No\"\n            } else\
    \ {\n                stack.removeLast()\n            }\n        }\n    }\n   \
    \ return stack.isEmpty ? \"Yes\" : \"No\"\n}\n\n\nfunc ==(left: [(Int, Int)],\
    \ right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n       \
    \ return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r\
    \ {\n            return false\n        }\n    }\n    return true\n}\n        \
    \    \nassert(match_parens(lst: [\"()(\", \")\"]) == \"Yes\")\nassert(match_parens(lst:\
    \ [\")\", \")\"]) == \"No\")\nassert(match_parens(lst: [\"(()(())\", \"())())\"\
    ]) == \"No\")\nassert(match_parens(lst: [\")())\", \"(()()(\"]) == \"Yes\")\n\
    assert(match_parens(lst: [\"(())))\", \"(()())((\"]) == \"Yes\")\nassert(match_parens(lst:\
    \ [\"()\", \"())\"]) == \"No\")\nassert(match_parens(lst: [\"(()(\", \"()))()\"\
    ]) == \"Yes\")\nassert(match_parens(lst: [\"((((\", \"((())\"]) == \"No\")\nassert(match_parens(lst:\
    \ [\")(()\", \"(()(\"]) == \"No\")\nassert(match_parens(lst: [\")(\", \")(\"])\
    \ == \"No\")\nassert(match_parens(lst: [\"(\", \")\"]) == \"Yes\")\nassert(match_parens(lst:\
    \ [\")\", \"(\"]) == \"Yes\")"
  status: Exception
  stderr: 'tmp3_3qo5be/tmp3_3qo5be.swift:48: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002ab00f118c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002ab00ee0fb6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002ab00ee0f988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002ab00ee0e7b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmp3_3qo5be                        0x0000556c9fdeefa6 <unavailable> + 8102

    5    libc.so.6                          0x00002ab00f304460 __libc_start_main +
    245

    6    tmp3_3qo5be                        0x0000556c9fdee709 <unavailable> + 5897

    '
  stdout: ''
  timestamp: 1659979532
- exit_code: -4
  program: "\n/// You are given an array of two strings, both strings consist of open\n\
    /// parentheses '(' or close parentheses ')' only.\n/// Your job is to check if\
    \ it is possible to concatenate the two strings in\n/// some order, that the resulting\
    \ string will be good.\n/// A string S is considered to be good if and only if\
    \ all parentheses in S\n/// are balanced. For example: the string '(())()' is\
    \ good, while the string\n/// '())' is not.\n/// Return 'Yes' if there's a way\
    \ to make a good string, and return 'No' otherwise.\n/// Examples:\n/// >>> match_parens(lst:\
    \ [\"()(\", \")\"])\n/// \"Yes\"\n/// >>> match_parens(lst: [\")\", \")\"])\n\
    /// \"No\"\nfunc match_parens(lst: [String]) -> String {\n    // 0. Initialize\
    \ variables\n    let open_parens: Set<Character> = [\"(\", \")\"]\n    var stack\
    \ = [Character]()\n    var result = \"Yes\"\n    \n    // 1. Check that each string\
    \ only contains open or close parentheses\n    for string in lst {\n        let\
    \ chars = string.sorted()\n        if !open_parens.isSuperset(of: chars) {\n \
    \           return \"No\"\n        }\n    }\n    \n    // 2. Concatenate strings,\
    \ iterate through result, push open parentheses\n    // to stack, remove if closed\
    \ parentheses is found\n    var concat = lst[0] + lst[1]\n    for c in concat\
    \ {\n        if c == \"(\" {\n            stack.append(c)\n        } else {\n\
    \            if !stack.isEmpty {\n                stack.removeLast()\n       \
    \     } else {\n                result = \"No\"\n                break\n     \
    \       }\n        }\n    }\n    \n    // 3. Return result\n    return result\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(match_parens(lst: [\"()(\", \")\"]) == \"Yes\"\
    )\nassert(match_parens(lst: [\")\", \")\"]) == \"No\")\nassert(match_parens(lst:\
    \ [\"(()(())\", \"())())\"]) == \"No\")\nassert(match_parens(lst: [\")())\", \"\
    (()()(\"]) == \"Yes\")\nassert(match_parens(lst: [\"(())))\", \"(()())((\"]) ==\
    \ \"Yes\")\nassert(match_parens(lst: [\"()\", \"())\"]) == \"No\")\nassert(match_parens(lst:\
    \ [\"(()(\", \"()))()\"]) == \"Yes\")\nassert(match_parens(lst: [\"((((\", \"\
    ((())\"]) == \"No\")\nassert(match_parens(lst: [\")(()\", \"(()(\"]) == \"No\"\
    )\nassert(match_parens(lst: [\")(\", \")(\"]) == \"No\")\nassert(match_parens(lst:\
    \ [\"(\", \")\"]) == \"Yes\")\nassert(match_parens(lst: [\")\", \"(\"]) == \"\
    Yes\")"
  status: Exception
  stderr: 'tmpra4quv6x/tmpra4quv6x.swift:65: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002aabc804fc80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002aabc7d46b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002aabc7d46988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002aabc7d457b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpra4quv6x                        0x00005565328350f6 <unavailable> + 8438

    5    libc.so.6                          0x00002aabc823b460 __libc_start_main +
    245

    6    tmpra4quv6x                        0x0000556532834859 <unavailable> + 6233

    '
  stdout: ''
  timestamp: 1659979532
- exit_code: -4
  program: "\n/// You are given an array of two strings, both strings consist of open\n\
    /// parentheses '(' or close parentheses ')' only.\n/// Your job is to check if\
    \ it is possible to concatenate the two strings in\n/// some order, that the resulting\
    \ string will be good.\n/// A string S is considered to be good if and only if\
    \ all parentheses in S\n/// are balanced. For example: the string '(())()' is\
    \ good, while the string\n/// '())' is not.\n/// Return 'Yes' if there's a way\
    \ to make a good string, and return 'No' otherwise.\n/// Examples:\n/// >>> match_parens(lst:\
    \ [\"()(\", \")\"])\n/// \"Yes\"\n/// >>> match_parens(lst: [\")\", \")\"])\n\
    /// \"No\"\nfunc match_parens(lst: [String]) -> String {\n    let s1 = lst[0],\
    \ s2 = lst[1]\n    var s = Array(s1 + s2)\n    var stack = [Int]()\n    for i\
    \ in 0..<s.count {\n        if s[i] == \"(\" {\n            stack.append(i)\n\
    \        } else {\n            if stack.isEmpty {\n                return \"No\"\
    \n            }\n            if (s[stack.last!] == \"(\" && s[i] == \")\") {\n\
    \                stack.removeLast()\n            }\n        }\n    }\n    return\
    \ stack.isEmpty ? \"Yes\" : \"No\"\n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(match_parens(lst: [\"()(\", \")\"]) == \"Yes\")\nassert(match_parens(lst:\
    \ [\")\", \")\"]) == \"No\")\nassert(match_parens(lst: [\"(()(())\", \"())())\"\
    ]) == \"No\")\nassert(match_parens(lst: [\")())\", \"(()()(\"]) == \"Yes\")\n\
    assert(match_parens(lst: [\"(())))\", \"(()())((\"]) == \"Yes\")\nassert(match_parens(lst:\
    \ [\"()\", \"())\"]) == \"No\")\nassert(match_parens(lst: [\"(()(\", \"()))()\"\
    ]) == \"Yes\")\nassert(match_parens(lst: [\"((((\", \"((())\"]) == \"No\")\nassert(match_parens(lst:\
    \ [\")(()\", \"(()(\"]) == \"No\")\nassert(match_parens(lst: [\")(\", \")(\"])\
    \ == \"No\")\nassert(match_parens(lst: [\"(\", \")\"]) == \"Yes\")\nassert(match_parens(lst:\
    \ [\")\", \"(\"]) == \"Yes\")"
  status: Exception
  stderr: 'tmp_s2nnsrq/tmp_s2nnsrq.swift:50: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b3f52cc6c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b3f529bdb6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b3f529bd988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b3f529bc7b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmp_s2nnsrq                        0x00005647a1194056 <unavailable> + 8278

    5    libc.so.6                          0x00002b3f52eb2460 __libc_start_main +
    245

    6    tmp_s2nnsrq                        0x00005647a11937b9 <unavailable> + 6073

    '
  stdout: ''
  timestamp: 1659979532
- exit_code: -4
  program: "\n/// You are given an array of two strings, both strings consist of open\n\
    /// parentheses '(' or close parentheses ')' only.\n/// Your job is to check if\
    \ it is possible to concatenate the two strings in\n/// some order, that the resulting\
    \ string will be good.\n/// A string S is considered to be good if and only if\
    \ all parentheses in S\n/// are balanced. For example: the string '(())()' is\
    \ good, while the string\n/// '())' is not.\n/// Return 'Yes' if there's a way\
    \ to make a good string, and return 'No' otherwise.\n/// Examples:\n/// >>> match_parens(lst:\
    \ [\"()(\", \")\"])\n/// \"Yes\"\n/// >>> match_parens(lst: [\")\", \")\"])\n\
    /// \"No\"\nfunc match_parens(lst: [String]) -> String {\n  let left = lst[0]\n\
    \  let right = lst[1]\n  var count = 0\n  for c in left {\n    if c == \"(\" {\n\
    \      count += 1\n    } else {\n      count -= 1\n    }\n  }\n  for c in right\
    \ {\n    if c == \"(\" {\n      count += 1\n    } else {\n      count -= 1\n \
    \   }\n  }\n  if count >= 0 {\n    return \"Yes\"\n  }\n  return \"No\"\n}\n\n\
    \nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(match_parens(lst: [\"()(\", \")\"]) == \"Yes\"\
    )\nassert(match_parens(lst: [\")\", \")\"]) == \"No\")\nassert(match_parens(lst:\
    \ [\"(()(())\", \"())())\"]) == \"No\")\nassert(match_parens(lst: [\")())\", \"\
    (()()(\"]) == \"Yes\")\nassert(match_parens(lst: [\"(())))\", \"(()())((\"]) ==\
    \ \"Yes\")\nassert(match_parens(lst: [\"()\", \"())\"]) == \"No\")\nassert(match_parens(lst:\
    \ [\"(()(\", \"()))()\"]) == \"Yes\")\nassert(match_parens(lst: [\"((((\", \"\
    ((())\"]) == \"No\")\nassert(match_parens(lst: [\")(()\", \"(()(\"]) == \"No\"\
    )\nassert(match_parens(lst: [\")(\", \")(\"]) == \"No\")\nassert(match_parens(lst:\
    \ [\"(\", \")\"]) == \"Yes\")\nassert(match_parens(lst: [\")\", \"(\"]) == \"\
    Yes\")"
  status: Exception
  stderr: 'tmp6g5r0s6x/tmp6g5r0s6x.swift:59: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002ae462a10c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002ae462707b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002ae462707988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002ae4627067b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmp6g5r0s6x                        0x000055fbc54b1152 <unavailable> + 8530

    5    libc.so.6                          0x00002ae462bfc460 __libc_start_main +
    245

    6    tmp6g5r0s6x                        0x000055fbc54b0289 <unavailable> + 4745

    '
  stdout: ''
  timestamp: 1659979532
- exit_code: 1
  program: "\n/// You are given an array of two strings, both strings consist of open\n\
    /// parentheses '(' or close parentheses ')' only.\n/// Your job is to check if\
    \ it is possible to concatenate the two strings in\n/// some order, that the resulting\
    \ string will be good.\n/// A string S is considered to be good if and only if\
    \ all parentheses in S\n/// are balanced. For example: the string '(())()' is\
    \ good, while the string\n/// '())' is not.\n/// Return 'Yes' if there's a way\
    \ to make a good string, and return 'No' otherwise.\n/// Examples:\n/// >>> match_parens(lst:\
    \ [\"()(\", \")\"])\n/// \"Yes\"\n/// >>> match_parens(lst: [\")\", \")\"])\n\
    /// \"No\"\nfunc match_parens(lst: [String]) -> String {\n    if lst.count < 2\
    \ {\n        return \"No\"\n    }\n    let s1 = lst[0]\n    let s2 = lst[1]\n\
    \    if bad(s1) || bad(s2) {\n        return \"No\"\n    }\n    if good(s1) &&\
    \ good(s2) {\n        return \"Yes\"\n    }\n    if good(s1) && s2.contains(\"\
    (\") {\n        return \"Yes\"\n    }\n    if good(s2) && s1.contains(\")\") {\n\
    \        return \"Yes\"\n    }\n    return \"No\"\n}\n\n\nfunc ==(left: [(Int,\
    \ Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n\
    \        return false\n    }\n    for (l, r) in zip(left, right) {\n        if\
    \ l != r {\n            return false\n        }\n    }\n    return true\n}\n \
    \           \nassert(match_parens(lst: [\"()(\", \")\"]) == \"Yes\")\nassert(match_parens(lst:\
    \ [\")\", \")\"]) == \"No\")\nassert(match_parens(lst: [\"(()(())\", \"())())\"\
    ]) == \"No\")\nassert(match_parens(lst: [\")())\", \"(()()(\"]) == \"Yes\")\n\
    assert(match_parens(lst: [\"(())))\", \"(()())((\"]) == \"Yes\")\nassert(match_parens(lst:\
    \ [\"()\", \"())\"]) == \"No\")\nassert(match_parens(lst: [\"(()(\", \"()))()\"\
    ]) == \"Yes\")\nassert(match_parens(lst: [\"((((\", \"((())\"]) == \"No\")\nassert(match_parens(lst:\
    \ [\")(()\", \"(()(\"]) == \"No\")\nassert(match_parens(lst: [\")(\", \")(\"])\
    \ == \"No\")\nassert(match_parens(lst: [\"(\", \")\"]) == \"Yes\")\nassert(match_parens(lst:\
    \ [\")\", \"(\"]) == \"Yes\")"
  status: SyntaxError
  stderr: "/tmp/tmpblg6hzsv.swift:21:8: error: cannot find 'bad' in scope\n    if\
    \ bad(s1) || bad(s2) {\n       ^~~\n/tmp/tmpblg6hzsv.swift:21:19: error: cannot\
    \ find 'bad' in scope\n    if bad(s1) || bad(s2) {\n                  ^~~\n/tmp/tmpblg6hzsv.swift:24:8:\
    \ error: cannot find 'good' in scope\n    if good(s1) && good(s2) {\n       ^~~~\n\
    /tmp/tmpblg6hzsv.swift:24:20: error: cannot find 'good' in scope\n    if good(s1)\
    \ && good(s2) {\n                   ^~~~\n/tmp/tmpblg6hzsv.swift:27:8: error:\
    \ cannot find 'good' in scope\n    if good(s1) && s2.contains(\"(\") {\n     \
    \  ^~~~\n/tmp/tmpblg6hzsv.swift:30:8: error: cannot find 'good' in scope\n   \
    \ if good(s2) && s1.contains(\")\") {\n       ^~~~\n"
  stdout: ''
  timestamp: 1659979532
- exit_code: 1
  program: "\n/// You are given an array of two strings, both strings consist of open\n\
    /// parentheses '(' or close parentheses ')' only.\n/// Your job is to check if\
    \ it is possible to concatenate the two strings in\n/// some order, that the resulting\
    \ string will be good.\n/// A string S is considered to be good if and only if\
    \ all parentheses in S\n/// are balanced. For example: the string '(())()' is\
    \ good, while the string\n/// '())' is not.\n/// Return 'Yes' if there's a way\
    \ to make a good string, and return 'No' otherwise.\n/// Examples:\n/// >>> match_parens(lst:\
    \ [\"()(\", \")\"])\n/// \"Yes\"\n/// >>> match_parens(lst: [\")\", \")\"])\n\
    /// \"No\"\nfunc match_parens(lst: [String]) -> String {\n    let left = lst[0].components(separatedBy:\
    \ \"(\").count\n    let right = lst[0].components(separatedBy: \")\").count\n\
    \    let left_two = lst[1].components(separatedBy: \"(\").count\n    let right_two\
    \ = lst[1].components(separatedBy: \")\").count\n    if left > right && left_two\
    \ > right_two || left == right && left_two == right_two {\n        return \"Yes\"\
    \n    }\n    return \"No\"\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(match_parens(lst:\
    \ [\"()(\", \")\"]) == \"Yes\")\nassert(match_parens(lst: [\")\", \")\"]) == \"\
    No\")\nassert(match_parens(lst: [\"(()(())\", \"())())\"]) == \"No\")\nassert(match_parens(lst:\
    \ [\")())\", \"(()()(\"]) == \"Yes\")\nassert(match_parens(lst: [\"(())))\", \"\
    (()())((\"]) == \"Yes\")\nassert(match_parens(lst: [\"()\", \"())\"]) == \"No\"\
    )\nassert(match_parens(lst: [\"(()(\", \"()))()\"]) == \"Yes\")\nassert(match_parens(lst:\
    \ [\"((((\", \"((())\"]) == \"No\")\nassert(match_parens(lst: [\")(()\", \"(()(\"\
    ]) == \"No\")\nassert(match_parens(lst: [\")(\", \")(\"]) == \"No\")\nassert(match_parens(lst:\
    \ [\"(\", \")\"]) == \"Yes\")\nassert(match_parens(lst: [\")\", \"(\"]) == \"\
    Yes\")"
  status: SyntaxError
  stderr: "/tmp/tmp4hnmzv2r.swift:16:23: error: value of type 'String' has no member\
    \ 'components'\n    let left = lst[0].components(separatedBy: \"(\").count\n \
    \              ~~~~~~ ^~~~~~~~~~\n/tmp/tmp4hnmzv2r.swift:17:24: error: value of\
    \ type 'String' has no member 'components'\n    let right = lst[0].components(separatedBy:\
    \ \")\").count\n                ~~~~~~ ^~~~~~~~~~\n/tmp/tmp4hnmzv2r.swift:18:27:\
    \ error: value of type 'String' has no member 'components'\n    let left_two =\
    \ lst[1].components(separatedBy: \"(\").count\n                   ~~~~~~ ^~~~~~~~~~\n\
    /tmp/tmp4hnmzv2r.swift:19:28: error: value of type 'String' has no member 'components'\n\
    \    let right_two = lst[1].components(separatedBy: \")\").count\n           \
    \         ~~~~~~ ^~~~~~~~~~\n"
  stdout: ''
  timestamp: 1659979533
- exit_code: -4
  program: "\n/// You are given an array of two strings, both strings consist of open\n\
    /// parentheses '(' or close parentheses ')' only.\n/// Your job is to check if\
    \ it is possible to concatenate the two strings in\n/// some order, that the resulting\
    \ string will be good.\n/// A string S is considered to be good if and only if\
    \ all parentheses in S\n/// are balanced. For example: the string '(())()' is\
    \ good, while the string\n/// '())' is not.\n/// Return 'Yes' if there's a way\
    \ to make a good string, and return 'No' otherwise.\n/// Examples:\n/// >>> match_parens(lst:\
    \ [\"()(\", \")\"])\n/// \"Yes\"\n/// >>> match_parens(lst: [\")\", \")\"])\n\
    /// \"No\"\nfunc match_parens(lst: [String]) -> String {\n  let str = lst.joined()\n\
    \  var leftParens = 0\n  var rightParens = 0\n  for i in 0..<str.count {\n   \
    \ let char = str[str.index(str.startIndex, offsetBy: i)]\n    if char == \"(\"\
    \ {\n      leftParens += 1\n    } else {\n      rightParens += 1\n    }\n    if\
    \ rightParens > leftParens {\n      return \"No\"\n    }\n  }\n  return leftParens\
    \ == rightParens ? \"Yes\" : \"No\"\n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(match_parens(lst: [\"()(\", \")\"]) == \"Yes\")\nassert(match_parens(lst:\
    \ [\")\", \")\"]) == \"No\")\nassert(match_parens(lst: [\"(()(())\", \"())())\"\
    ]) == \"No\")\nassert(match_parens(lst: [\")())\", \"(()()(\"]) == \"Yes\")\n\
    assert(match_parens(lst: [\"(())))\", \"(()())((\"]) == \"Yes\")\nassert(match_parens(lst:\
    \ [\"()\", \"())\"]) == \"No\")\nassert(match_parens(lst: [\"(()(\", \"()))()\"\
    ]) == \"Yes\")\nassert(match_parens(lst: [\"((((\", \"((())\"]) == \"No\")\nassert(match_parens(lst:\
    \ [\")(()\", \"(()(\"]) == \"No\")\nassert(match_parens(lst: [\")(\", \")(\"])\
    \ == \"No\")\nassert(match_parens(lst: [\"(\", \")\"]) == \"Yes\")\nassert(match_parens(lst:\
    \ [\")\", \"(\"]) == \"Yes\")"
  status: Exception
  stderr: 'tmpok74fl1v/tmpok74fl1v.swift:49: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002abcdc483c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002abcdc17ab6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002abcdc17a988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002abcdc1797b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpok74fl1v                        0x0000563275d7edb6 <unavailable> + 7606

    5    libc.so.6                          0x00002abcdc66f460 __libc_start_main +
    245

    6    tmpok74fl1v                        0x0000563275d7e519 <unavailable> + 5401

    '
  stdout: ''
  timestamp: 1659979532
- exit_code: -4
  program: "\n/// You are given an array of two strings, both strings consist of open\n\
    /// parentheses '(' or close parentheses ')' only.\n/// Your job is to check if\
    \ it is possible to concatenate the two strings in\n/// some order, that the resulting\
    \ string will be good.\n/// A string S is considered to be good if and only if\
    \ all parentheses in S\n/// are balanced. For example: the string '(())()' is\
    \ good, while the string\n/// '())' is not.\n/// Return 'Yes' if there's a way\
    \ to make a good string, and return 'No' otherwise.\n/// Examples:\n/// >>> match_parens(lst:\
    \ [\"()(\", \")\"])\n/// \"Yes\"\n/// >>> match_parens(lst: [\")\", \")\"])\n\
    /// \"No\"\nfunc match_parens(lst: [String]) -> String {\n    var str_1 = lst[0]\n\
    \    var str_2 = lst[1]\n    if str_1.count > str_2.count {\n        str_1 = lst[1]\n\
    \        str_2 = lst[0]\n    }\n    if str_1.contains(\"(\") && str_2.contains(\"\
    )\") {\n        return \"Yes\"\n    }\n    if str_1.contains(\")\") && str_2.contains(\"\
    (\") {\n        return \"Yes\"\n    }\n    if str_1.contains(\"(\") && str_2.contains(\"\
    (\") {\n        return \"Yes\"\n    }\n    if str_1.contains(\")\") && str_2.contains(\"\
    )\") {\n        return \"Yes\"\n    }\n    return \"No\"\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(match_parens(lst: [\"()(\", \")\"]) == \"Yes\")\nassert(match_parens(lst:\
    \ [\")\", \")\"]) == \"No\")\nassert(match_parens(lst: [\"(()(())\", \"())())\"\
    ]) == \"No\")\nassert(match_parens(lst: [\")())\", \"(()()(\"]) == \"Yes\")\n\
    assert(match_parens(lst: [\"(())))\", \"(()())((\"]) == \"Yes\")\nassert(match_parens(lst:\
    \ [\"()\", \"())\"]) == \"No\")\nassert(match_parens(lst: [\"(()(\", \"()))()\"\
    ]) == \"Yes\")\nassert(match_parens(lst: [\"((((\", \"((())\"]) == \"No\")\nassert(match_parens(lst:\
    \ [\")(()\", \"(()(\"]) == \"No\")\nassert(match_parens(lst: [\")(\", \")(\"])\
    \ == \"No\")\nassert(match_parens(lst: [\"(\", \")\"]) == \"Yes\")\nassert(match_parens(lst:\
    \ [\")\", \"(\"]) == \"Yes\")"
  status: Exception
  stderr: 'tmp9bb1tr_8/tmp9bb1tr_8.swift:51: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b55e87f5c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b55e84ecb6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b55e84ec988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b55e84eb7b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmp9bb1tr_8                        0x000055e9f786a830 <unavailable> + 6192

    5    libc.so.6                          0x00002b55e89e1460 __libc_start_main +
    245

    6    tmp9bb1tr_8                        0x000055e9f786a2a9 <unavailable> + 4777

    '
  stdout: ''
  timestamp: 1659979532
- exit_code: -4
  program: "\n/// You are given an array of two strings, both strings consist of open\n\
    /// parentheses '(' or close parentheses ')' only.\n/// Your job is to check if\
    \ it is possible to concatenate the two strings in\n/// some order, that the resulting\
    \ string will be good.\n/// A string S is considered to be good if and only if\
    \ all parentheses in S\n/// are balanced. For example: the string '(())()' is\
    \ good, while the string\n/// '())' is not.\n/// Return 'Yes' if there's a way\
    \ to make a good string, and return 'No' otherwise.\n/// Examples:\n/// >>> match_parens(lst:\
    \ [\"()(\", \")\"])\n/// \"Yes\"\n/// >>> match_parens(lst: [\")\", \")\"])\n\
    /// \"No\"\nfunc match_parens(lst: [String]) -> String {\n    var count = 0\n\
    \    for s in lst {\n        for c in s {\n            if c == \"(\" {\n     \
    \           count += 1\n            } else {\n                count -= 1\n   \
    \         }\n            if count < 0 {\n                return \"No\"\n     \
    \       }\n        }\n    }\n    return count == 0 ? \"Yes\" : \"No\"\n}\n\n\n\
    func ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(match_parens(lst: [\"()(\", \")\"]) == \"Yes\"\
    )\nassert(match_parens(lst: [\")\", \")\"]) == \"No\")\nassert(match_parens(lst:\
    \ [\"(()(())\", \"())())\"]) == \"No\")\nassert(match_parens(lst: [\")())\", \"\
    (()()(\"]) == \"Yes\")\nassert(match_parens(lst: [\"(())))\", \"(()())((\"]) ==\
    \ \"Yes\")\nassert(match_parens(lst: [\"()\", \"())\"]) == \"No\")\nassert(match_parens(lst:\
    \ [\"(()(\", \"()))()\"]) == \"Yes\")\nassert(match_parens(lst: [\"((((\", \"\
    ((())\"]) == \"No\")\nassert(match_parens(lst: [\")(()\", \"(()(\"]) == \"No\"\
    )\nassert(match_parens(lst: [\")(\", \")(\"]) == \"No\")\nassert(match_parens(lst:\
    \ [\"(\", \")\"]) == \"Yes\")\nassert(match_parens(lst: [\")\", \"(\"]) == \"\
    Yes\")"
  status: Exception
  stderr: 'tmp4buhwsep/tmp4buhwsep.swift:48: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002ad6ebf6fc80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002ad6ebc66b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002ad6ebc66988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002ad6ebc657b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmp4buhwsep                        0x000055734f906c36 <unavailable> + 7222

    5    libc.so.6                          0x00002ad6ec15b460 __libc_start_main +
    245

    6    tmp4buhwsep                        0x000055734f906399 <unavailable> + 5017

    '
  stdout: ''
  timestamp: 1659979532
- exit_code: -4
  program: "\n/// You are given an array of two strings, both strings consist of open\n\
    /// parentheses '(' or close parentheses ')' only.\n/// Your job is to check if\
    \ it is possible to concatenate the two strings in\n/// some order, that the resulting\
    \ string will be good.\n/// A string S is considered to be good if and only if\
    \ all parentheses in S\n/// are balanced. For example: the string '(())()' is\
    \ good, while the string\n/// '())' is not.\n/// Return 'Yes' if there's a way\
    \ to make a good string, and return 'No' otherwise.\n/// Examples:\n/// >>> match_parens(lst:\
    \ [\"()(\", \")\"])\n/// \"Yes\"\n/// >>> match_parens(lst: [\")\", \")\"])\n\
    /// \"No\"\nfunc match_parens(lst: [String]) -> String {\n    var stk = [Character]()\n\
    \    var str1 = lst[0]\n    var str2 = lst[1]\n    for c in str1 {\n        if\
    \ c == \"(\" {\n            stk.append(c)\n        } else {\n            if stk.isEmpty\
    \ {\n                stk.append(c)\n            } else {\n                stk.popLast()\n\
    \            }\n        }\n    }\n    for c in str2 {\n        if c == \"(\" {\n\
    \            stk.append(c)\n        } else {\n            if stk.isEmpty {\n \
    \               stk.append(c)\n            } else {\n                stk.popLast()\n\
    \            }\n        }\n    }\n    if stk.isEmpty {\n        return \"Yes\"\
    \n    } else {\n        return \"No\"\n    }\n}\n\n\nfunc ==(left: [(Int, Int)],\
    \ right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n       \
    \ return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r\
    \ {\n            return false\n        }\n    }\n    return true\n}\n        \
    \    \nassert(match_parens(lst: [\"()(\", \")\"]) == \"Yes\")\nassert(match_parens(lst:\
    \ [\")\", \")\"]) == \"No\")\nassert(match_parens(lst: [\"(()(())\", \"())())\"\
    ]) == \"No\")\nassert(match_parens(lst: [\")())\", \"(()()(\"]) == \"Yes\")\n\
    assert(match_parens(lst: [\"(())))\", \"(()())((\"]) == \"Yes\")\nassert(match_parens(lst:\
    \ [\"()\", \"())\"]) == \"No\")\nassert(match_parens(lst: [\"(()(\", \"()))()\"\
    ]) == \"Yes\")\nassert(match_parens(lst: [\"((((\", \"((())\"]) == \"No\")\nassert(match_parens(lst:\
    \ [\")(()\", \"(()(\"]) == \"No\")\nassert(match_parens(lst: [\")(\", \")(\"])\
    \ == \"No\")\nassert(match_parens(lst: [\"(\", \")\"]) == \"Yes\")\nassert(match_parens(lst:\
    \ [\")\", \"(\"]) == \"Yes\")"
  status: Exception
  stderr: 'tmp5x8yh1_8/tmp5x8yh1_8.swift:62: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002ac605223c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002ac604f1ab6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002ac604f1a988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002ac604f197b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmp5x8yh1_8                        0x0000556520d0ea30 <unavailable> + 6704

    5    libc.so.6                          0x00002ac60540f460 __libc_start_main +
    245

    6    tmp5x8yh1_8                        0x0000556520d0e4a9 <unavailable> + 5289

    '
  stdout: ''
  timestamp: 1659979532
- exit_code: -4
  program: "\n/// You are given an array of two strings, both strings consist of open\n\
    /// parentheses '(' or close parentheses ')' only.\n/// Your job is to check if\
    \ it is possible to concatenate the two strings in\n/// some order, that the resulting\
    \ string will be good.\n/// A string S is considered to be good if and only if\
    \ all parentheses in S\n/// are balanced. For example: the string '(())()' is\
    \ good, while the string\n/// '())' is not.\n/// Return 'Yes' if there's a way\
    \ to make a good string, and return 'No' otherwise.\n/// Examples:\n/// >>> match_parens(lst:\
    \ [\"()(\", \")\"])\n/// \"Yes\"\n/// >>> match_parens(lst: [\")\", \")\"])\n\
    /// \"No\"\nfunc match_parens(lst: [String]) -> String {\n    var lst = lst\n\
    \    lst[0].append(lst[1])\n    var stack = [Character]()\n    for c in lst[0]\
    \ {\n        if c == \"(\" {\n            stack.append(c)\n        } else {\n\
    \            if stack.isEmpty {\n                return \"No\"\n            }\
    \ else {\n                stack.removeLast()\n            }\n        }\n    }\n\
    \    return stack.isEmpty ? \"Yes\" : \"No\"\n}\n\n\nfunc ==(left: [(Int, Int)],\
    \ right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n       \
    \ return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r\
    \ {\n            return false\n        }\n    }\n    return true\n}\n        \
    \    \nassert(match_parens(lst: [\"()(\", \")\"]) == \"Yes\")\nassert(match_parens(lst:\
    \ [\")\", \")\"]) == \"No\")\nassert(match_parens(lst: [\"(()(())\", \"())())\"\
    ]) == \"No\")\nassert(match_parens(lst: [\")())\", \"(()()(\"]) == \"Yes\")\n\
    assert(match_parens(lst: [\"(())))\", \"(()())((\"]) == \"Yes\")\nassert(match_parens(lst:\
    \ [\"()\", \"())\"]) == \"No\")\nassert(match_parens(lst: [\"(()(\", \"()))()\"\
    ]) == \"Yes\")\nassert(match_parens(lst: [\"((((\", \"((())\"]) == \"No\")\nassert(match_parens(lst:\
    \ [\")(()\", \"(()(\"]) == \"No\")\nassert(match_parens(lst: [\")(\", \")(\"])\
    \ == \"No\")\nassert(match_parens(lst: [\"(\", \")\"]) == \"Yes\")\nassert(match_parens(lst:\
    \ [\")\", \"(\"]) == \"Yes\")"
  status: Exception
  stderr: 'tmplwqkl7fz/tmplwqkl7fz.swift:49: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b24c2b36c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b24c282db6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b24c282d988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b24c282c7b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmplwqkl7fz                        0x000055cb780e5df6 <unavailable> + 7670

    5    libc.so.6                          0x00002b24c2d22460 __libc_start_main +
    245

    6    tmplwqkl7fz                        0x000055cb780e5559 <unavailable> + 5465

    '
  stdout: ''
  timestamp: 1659979532
- exit_code: 1
  program: "\n/// You are given an array of two strings, both strings consist of open\n\
    /// parentheses '(' or close parentheses ')' only.\n/// Your job is to check if\
    \ it is possible to concatenate the two strings in\n/// some order, that the resulting\
    \ string will be good.\n/// A string S is considered to be good if and only if\
    \ all parentheses in S\n/// are balanced. For example: the string '(())()' is\
    \ good, while the string\n/// '())' is not.\n/// Return 'Yes' if there's a way\
    \ to make a good string, and return 'No' otherwise.\n/// Examples:\n/// >>> match_parens(lst:\
    \ [\"()(\", \")\"])\n/// \"Yes\"\n/// >>> match_parens(lst: [\")\", \")\"])\n\
    /// \"No\"\nfunc match_parens(lst: [String]) -> String {\n    let open = lst[0].components(separatedBy:\
    \ \"(\").count\n    let close = lst[0].components(separatedBy: \")\").count\n\
    \    if lst[1] == \")\" {\n        if close > 0 {\n            return \"Yes\"\n\
    \        } else {\n            return \"No\"\n        }\n    } else {\n      \
    \  if open > 0 {\n            return \"Yes\"\n        } else {\n            return\
    \ \"No\"\n        }\n    }\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(match_parens(lst:\
    \ [\"()(\", \")\"]) == \"Yes\")\nassert(match_parens(lst: [\")\", \")\"]) == \"\
    No\")\nassert(match_parens(lst: [\"(()(())\", \"())())\"]) == \"No\")\nassert(match_parens(lst:\
    \ [\")())\", \"(()()(\"]) == \"Yes\")\nassert(match_parens(lst: [\"(())))\", \"\
    (()())((\"]) == \"Yes\")\nassert(match_parens(lst: [\"()\", \"())\"]) == \"No\"\
    )\nassert(match_parens(lst: [\"(()(\", \"()))()\"]) == \"Yes\")\nassert(match_parens(lst:\
    \ [\"((((\", \"((())\"]) == \"No\")\nassert(match_parens(lst: [\")(()\", \"(()(\"\
    ]) == \"No\")\nassert(match_parens(lst: [\")(\", \")(\"]) == \"No\")\nassert(match_parens(lst:\
    \ [\"(\", \")\"]) == \"Yes\")\nassert(match_parens(lst: [\")\", \"(\"]) == \"\
    Yes\")"
  status: SyntaxError
  stderr: "/tmp/tmpj1k1ctfk.swift:16:23: error: value of type 'String' has no member\
    \ 'components'\n    let open = lst[0].components(separatedBy: \"(\").count\n \
    \              ~~~~~~ ^~~~~~~~~~\n/tmp/tmpj1k1ctfk.swift:17:24: error: value of\
    \ type 'String' has no member 'components'\n    let close = lst[0].components(separatedBy:\
    \ \")\").count\n                ~~~~~~ ^~~~~~~~~~\n"
  stdout: ''
  timestamp: 1659979532
- exit_code: -4
  program: "\n/// You are given an array of two strings, both strings consist of open\n\
    /// parentheses '(' or close parentheses ')' only.\n/// Your job is to check if\
    \ it is possible to concatenate the two strings in\n/// some order, that the resulting\
    \ string will be good.\n/// A string S is considered to be good if and only if\
    \ all parentheses in S\n/// are balanced. For example: the string '(())()' is\
    \ good, while the string\n/// '())' is not.\n/// Return 'Yes' if there's a way\
    \ to make a good string, and return 'No' otherwise.\n/// Examples:\n/// >>> match_parens(lst:\
    \ [\"()(\", \")\"])\n/// \"Yes\"\n/// >>> match_parens(lst: [\")\", \")\"])\n\
    /// \"No\"\nfunc match_parens(lst: [String]) -> String {\n    // first, get the\
    \ total number of parentheses and build a string of all the\n    // parentheses\n\
    \    let total_parens = lst.reduce(0) { $0 + $1.count }\n    var parens = \"\"\
    \n    for string in lst {\n        parens += string\n    }\n    // if the total\
    \ number of parentheses is odd, then we cannot make the string\n    // balanced\n\
    \    if total_parens % 2 == 1 {\n        return \"No\"\n    }\n    // now we iterate\
    \ through the string, tallying the number of opening\n    // parentheses we've\
    \ seen vs the number of closing parentheses we've seen\n    var open_parens =\
    \ 0\n    var close_parens = 0\n    for paren in parens {\n        if paren ==\
    \ \"(\" {\n            open_parens += 1\n        } else {\n            close_parens\
    \ += 1\n        }\n        // if the number of closing parentheses we've seen\
    \ so far is more than\n        // the number of opening parentheses we've seen\
    \ so far, then we cannot\n        // make a balanced string\n        if close_parens\
    \ > open_parens {\n            return \"No\"\n        }\n    }\n    // by this\
    \ point, we are guaranteed that the number of open parentheses is\n    // greater\
    \ than or equal to the number of closing parentheses, so if those\n    // numbers\
    \ are equal, we have a balanced string\n    if open_parens == close_parens {\n\
    \        return \"Yes\"\n    }\n    // by this point, we've seen more opening\
    \ parentheses than closing\n    // parentheses. if the number of extra opening\
    \ parentheses is equal to the\n    // number of remaining closing parentheses,\
    \ then we can make a balanced\n    // string.\n    if open_parens - close_parens\
    \ == parens.count - total_parens {\n        return \"Yes\"\n    }\n    // by this\
    \ point, the number of opening parentheses is greater than the\n    // number\
    \ of closing parentheses, but the number of extra opening\n    // parentheses\
    \ is not equal to the number of remaining closing parentheses.\n    // this means\
    \ that we cannot make a balanced string\n    return \"No\"\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(match_parens(lst: [\"()(\", \")\"]) == \"Yes\")\nassert(match_parens(lst:\
    \ [\")\", \")\"]) == \"No\")\nassert(match_parens(lst: [\"(()(())\", \"())())\"\
    ]) == \"No\")\nassert(match_parens(lst: [\")())\", \"(()()(\"]) == \"Yes\")\n\
    assert(match_parens(lst: [\"(())))\", \"(()())((\"]) == \"Yes\")\nassert(match_parens(lst:\
    \ [\"()\", \"())\"]) == \"No\")\nassert(match_parens(lst: [\"(()(\", \"()))()\"\
    ]) == \"Yes\")\nassert(match_parens(lst: [\"((((\", \"((())\"]) == \"No\")\nassert(match_parens(lst:\
    \ [\")(()\", \"(()(\"]) == \"No\")\nassert(match_parens(lst: [\")(\", \")(\"])\
    \ == \"No\")\nassert(match_parens(lst: [\"(\", \")\"]) == \"Yes\")\nassert(match_parens(lst:\
    \ [\")\", \"(\"]) == \"Yes\")"
  status: Exception
  stderr: 'tmpkn7iefnk/tmpkn7iefnk.swift:81: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002abef3aaec80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002abef37a5b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002abef37a5988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002abef37a47b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpkn7iefnk                        0x0000561f58c06de6 <unavailable> + 7654

    5    libc.so.6                          0x00002abef3c9a460 __libc_start_main +
    245

    6    tmpkn7iefnk                        0x0000561f58c06549 <unavailable> + 5449

    '
  stdout: ''
  timestamp: 1659979532
- exit_code: -4
  program: "\n/// You are given an array of two strings, both strings consist of open\n\
    /// parentheses '(' or close parentheses ')' only.\n/// Your job is to check if\
    \ it is possible to concatenate the two strings in\n/// some order, that the resulting\
    \ string will be good.\n/// A string S is considered to be good if and only if\
    \ all parentheses in S\n/// are balanced. For example: the string '(())()' is\
    \ good, while the string\n/// '())' is not.\n/// Return 'Yes' if there's a way\
    \ to make a good string, and return 'No' otherwise.\n/// Examples:\n/// >>> match_parens(lst:\
    \ [\"()(\", \")\"])\n/// \"Yes\"\n/// >>> match_parens(lst: [\")\", \")\"])\n\
    /// \"No\"\nfunc match_parens(lst: [String]) -> String {\n    var open = 0\n \
    \   var close = 0\n    for c in lst[0] {\n        if c == \"(\" {\n          \
    \  open += 1\n        } else {\n            close += 1\n        }\n    }\n   \
    \ for c in lst[1] {\n        if c == \"(\" {\n            open += 1\n        }\
    \ else {\n            close += 1\n        }\n    }\n    return open == close ?\
    \ \"Yes\" : \"No\"\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) ->\
    \ Bool {\n    if left.count != right.count {\n        return false\n    }\n  \
    \  for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(match_parens(lst:\
    \ [\"()(\", \")\"]) == \"Yes\")\nassert(match_parens(lst: [\")\", \")\"]) == \"\
    No\")\nassert(match_parens(lst: [\"(()(())\", \"())())\"]) == \"No\")\nassert(match_parens(lst:\
    \ [\")())\", \"(()()(\"]) == \"Yes\")\nassert(match_parens(lst: [\"(())))\", \"\
    (()())((\"]) == \"Yes\")\nassert(match_parens(lst: [\"()\", \"())\"]) == \"No\"\
    )\nassert(match_parens(lst: [\"(()(\", \"()))()\"]) == \"Yes\")\nassert(match_parens(lst:\
    \ [\"((((\", \"((())\"]) == \"No\")\nassert(match_parens(lst: [\")(()\", \"(()(\"\
    ]) == \"No\")\nassert(match_parens(lst: [\")(\", \")(\"]) == \"No\")\nassert(match_parens(lst:\
    \ [\"(\", \")\"]) == \"Yes\")\nassert(match_parens(lst: [\")\", \"(\"]) == \"\
    Yes\")"
  status: Exception
  stderr: 'tmpke5f4s8x/tmpke5f4s8x.swift:57: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b072df04c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b072dbfbb6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b072dbfb988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b072dbfa7b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpke5f4s8x                        0x0000557477915468 <unavailable> + 9320

    5    libc.so.6                          0x00002b072e0f0460 __libc_start_main +
    245

    6    tmpke5f4s8x                        0x0000557477914289 <unavailable> + 4745

    '
  stdout: ''
  timestamp: 1659979532
- exit_code: 1
  program: "\n/// You are given an array of two strings, both strings consist of open\n\
    /// parentheses '(' or close parentheses ')' only.\n/// Your job is to check if\
    \ it is possible to concatenate the two strings in\n/// some order, that the resulting\
    \ string will be good.\n/// A string S is considered to be good if and only if\
    \ all parentheses in S\n/// are balanced. For example: the string '(())()' is\
    \ good, while the string\n/// '())' is not.\n/// Return 'Yes' if there's a way\
    \ to make a good string, and return 'No' otherwise.\n/// Examples:\n/// >>> match_parens(lst:\
    \ [\"()(\", \")\"])\n/// \"Yes\"\n/// >>> match_parens(lst: [\")\", \")\"])\n\
    /// \"No\"\nfunc match_parens(lst: [String]) -> String {\n    let s = lst[0] +\
    \ lst[1]\n    var stack = Stack<Character>()\n    for c in s {\n        if c ==\
    \ \"(\" {\n            stack.push(c)\n        } else {\n            if stack.isEmpty()\
    \ {\n                return \"No\"\n            }\n            stack.pop()\n \
    \       }\n    }\n    return stack.isEmpty() ? \"Yes\" : \"No\"\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(match_parens(lst: [\"()(\", \")\"]) == \"Yes\")\nassert(match_parens(lst:\
    \ [\")\", \")\"]) == \"No\")\nassert(match_parens(lst: [\"(()(())\", \"())())\"\
    ]) == \"No\")\nassert(match_parens(lst: [\")())\", \"(()()(\"]) == \"Yes\")\n\
    assert(match_parens(lst: [\"(())))\", \"(()())((\"]) == \"Yes\")\nassert(match_parens(lst:\
    \ [\"()\", \"())\"]) == \"No\")\nassert(match_parens(lst: [\"(()(\", \"()))()\"\
    ]) == \"Yes\")\nassert(match_parens(lst: [\"((((\", \"((())\"]) == \"No\")\nassert(match_parens(lst:\
    \ [\")(()\", \"(()(\"]) == \"No\")\nassert(match_parens(lst: [\")(\", \")(\"])\
    \ == \"No\")\nassert(match_parens(lst: [\"(\", \")\"]) == \"Yes\")\nassert(match_parens(lst:\
    \ [\")\", \"(\"]) == \"Yes\")"
  status: SyntaxError
  stderr: "/tmp/tmp3lx94ewh.swift:17:17: error: cannot find 'Stack' in scope\n   \
    \ var stack = Stack<Character>()\n                ^~~~~\n"
  stdout: ''
  timestamp: 1659979532
- exit_code: 1
  program: "\n/// You are given an array of two strings, both strings consist of open\n\
    /// parentheses '(' or close parentheses ')' only.\n/// Your job is to check if\
    \ it is possible to concatenate the two strings in\n/// some order, that the resulting\
    \ string will be good.\n/// A string S is considered to be good if and only if\
    \ all parentheses in S\n/// are balanced. For example: the string '(())()' is\
    \ good, while the string\n/// '())' is not.\n/// Return 'Yes' if there's a way\
    \ to make a good string, and return 'No' otherwise.\n/// Examples:\n/// >>> match_parens(lst:\
    \ [\"()(\", \")\"])\n/// \"Yes\"\n/// >>> match_parens(lst: [\")\", \")\"])\n\
    /// \"No\"\nfunc match_parens(lst: [String]) -> String {\n    let (s1, s2) = (lst[0],\
    \ lst[1])\n    let good1 = is_good(string: s1)\n    let good2 = is_good(string:\
    \ s2)\n    return good1 && good2 ? \"Yes\" : \"No\"\n}\n\n\nfunc ==(left: [(Int,\
    \ Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n\
    \        return false\n    }\n    for (l, r) in zip(left, right) {\n        if\
    \ l != r {\n            return false\n        }\n    }\n    return true\n}\n \
    \           \nassert(match_parens(lst: [\"()(\", \")\"]) == \"Yes\")\nassert(match_parens(lst:\
    \ [\")\", \")\"]) == \"No\")\nassert(match_parens(lst: [\"(()(())\", \"())())\"\
    ]) == \"No\")\nassert(match_parens(lst: [\")())\", \"(()()(\"]) == \"Yes\")\n\
    assert(match_parens(lst: [\"(())))\", \"(()())((\"]) == \"Yes\")\nassert(match_parens(lst:\
    \ [\"()\", \"())\"]) == \"No\")\nassert(match_parens(lst: [\"(()(\", \"()))()\"\
    ]) == \"Yes\")\nassert(match_parens(lst: [\"((((\", \"((())\"]) == \"No\")\nassert(match_parens(lst:\
    \ [\")(()\", \"(()(\"]) == \"No\")\nassert(match_parens(lst: [\")(\", \")(\"])\
    \ == \"No\")\nassert(match_parens(lst: [\"(\", \")\"]) == \"Yes\")\nassert(match_parens(lst:\
    \ [\")\", \"(\"]) == \"Yes\")"
  status: SyntaxError
  stderr: "/tmp/tmpe_n685wk.swift:17:17: error: cannot find 'is_good' in scope\n \
    \   let good1 = is_good(string: s1)\n                ^~~~~~~\n/tmp/tmpe_n685wk.swift:18:17:\
    \ error: cannot find 'is_good' in scope\n    let good2 = is_good(string: s2)\n\
    \                ^~~~~~~\n"
  stdout: ''
  timestamp: 1659979532
- exit_code: 1
  program: "\n/// You are given an array of two strings, both strings consist of open\n\
    /// parentheses '(' or close parentheses ')' only.\n/// Your job is to check if\
    \ it is possible to concatenate the two strings in\n/// some order, that the resulting\
    \ string will be good.\n/// A string S is considered to be good if and only if\
    \ all parentheses in S\n/// are balanced. For example: the string '(())()' is\
    \ good, while the string\n/// '())' is not.\n/// Return 'Yes' if there's a way\
    \ to make a good string, and return 'No' otherwise.\n/// Examples:\n/// >>> match_parens(lst:\
    \ [\"()(\", \")\"])\n/// \"Yes\"\n/// >>> match_parens(lst: [\")\", \")\"])\n\
    /// \"No\"\nfunc match_parens(lst: [String]) -> String {\n    return is_valid(s:\
    \ lst[0] + lst[1]) ? \"Yes\" : \"No\"\n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(match_parens(lst: [\"()(\", \")\"]) == \"Yes\")\nassert(match_parens(lst:\
    \ [\")\", \")\"]) == \"No\")\nassert(match_parens(lst: [\"(()(())\", \"())())\"\
    ]) == \"No\")\nassert(match_parens(lst: [\")())\", \"(()()(\"]) == \"Yes\")\n\
    assert(match_parens(lst: [\"(())))\", \"(()())((\"]) == \"Yes\")\nassert(match_parens(lst:\
    \ [\"()\", \"())\"]) == \"No\")\nassert(match_parens(lst: [\"(()(\", \"()))()\"\
    ]) == \"Yes\")\nassert(match_parens(lst: [\"((((\", \"((())\"]) == \"No\")\nassert(match_parens(lst:\
    \ [\")(()\", \"(()(\"]) == \"No\")\nassert(match_parens(lst: [\")(\", \")(\"])\
    \ == \"No\")\nassert(match_parens(lst: [\"(\", \")\"]) == \"Yes\")\nassert(match_parens(lst:\
    \ [\")\", \"(\"]) == \"Yes\")"
  status: SyntaxError
  stderr: "/tmp/tmp95lybdsf.swift:16:12: error: cannot find 'is_valid' in scope\n\
    \    return is_valid(s: lst[0] + lst[1]) ? \"Yes\" : \"No\"\n           ^~~~~~~~\n"
  stdout: ''
  timestamp: 1659979532
- exit_code: -4
  program: "\n/// You are given an array of two strings, both strings consist of open\n\
    /// parentheses '(' or close parentheses ')' only.\n/// Your job is to check if\
    \ it is possible to concatenate the two strings in\n/// some order, that the resulting\
    \ string will be good.\n/// A string S is considered to be good if and only if\
    \ all parentheses in S\n/// are balanced. For example: the string '(())()' is\
    \ good, while the string\n/// '())' is not.\n/// Return 'Yes' if there's a way\
    \ to make a good string, and return 'No' otherwise.\n/// Examples:\n/// >>> match_parens(lst:\
    \ [\"()(\", \")\"])\n/// \"Yes\"\n/// >>> match_parens(lst: [\")\", \")\"])\n\
    /// \"No\"\nfunc match_parens(lst: [String]) -> String {\n    var leftCounter\
    \ = 0\n    var rightCounter = 0\n    for str in lst {\n        for char in str\
    \ {\n            if char == \"(\" {\n                leftCounter += 1\n      \
    \      } else {\n                rightCounter += 1\n            }\n        }\n\
    \    }\n    if leftCounter == rightCounter {\n        return \"Yes\"\n    }\n\
    \    return \"No\"\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) ->\
    \ Bool {\n    if left.count != right.count {\n        return false\n    }\n  \
    \  for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(match_parens(lst:\
    \ [\"()(\", \")\"]) == \"Yes\")\nassert(match_parens(lst: [\")\", \")\"]) == \"\
    No\")\nassert(match_parens(lst: [\"(()(())\", \"())())\"]) == \"No\")\nassert(match_parens(lst:\
    \ [\")())\", \"(()()(\"]) == \"Yes\")\nassert(match_parens(lst: [\"(())))\", \"\
    (()())((\"]) == \"Yes\")\nassert(match_parens(lst: [\"()\", \"())\"]) == \"No\"\
    )\nassert(match_parens(lst: [\"(()(\", \"()))()\"]) == \"Yes\")\nassert(match_parens(lst:\
    \ [\"((((\", \"((())\"]) == \"No\")\nassert(match_parens(lst: [\")(()\", \"(()(\"\
    ]) == \"No\")\nassert(match_parens(lst: [\")(\", \")(\"]) == \"No\")\nassert(match_parens(lst:\
    \ [\"(\", \")\"]) == \"Yes\")\nassert(match_parens(lst: [\")\", \"(\"]) == \"\
    Yes\")"
  status: Exception
  stderr: 'tmpix0mjc57/tmpix0mjc57.swift:55: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002ae5556fcc80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002ae5553f3b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002ae5553f3988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002ae5553f27b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpix0mjc57                        0x000055da2dcd8578 <unavailable> + 9592

    5    libc.so.6                          0x00002ae5558e8460 __libc_start_main +
    245

    6    tmpix0mjc57                        0x000055da2dcd7399 <unavailable> + 5017

    '
  stdout: ''
  timestamp: 1659979532
- exit_code: -4
  program: "\n/// You are given an array of two strings, both strings consist of open\n\
    /// parentheses '(' or close parentheses ')' only.\n/// Your job is to check if\
    \ it is possible to concatenate the two strings in\n/// some order, that the resulting\
    \ string will be good.\n/// A string S is considered to be good if and only if\
    \ all parentheses in S\n/// are balanced. For example: the string '(())()' is\
    \ good, while the string\n/// '())' is not.\n/// Return 'Yes' if there's a way\
    \ to make a good string, and return 'No' otherwise.\n/// Examples:\n/// >>> match_parens(lst:\
    \ [\"()(\", \")\"])\n/// \"Yes\"\n/// >>> match_parens(lst: [\")\", \")\"])\n\
    /// \"No\"\nfunc match_parens(lst: [String]) -> String {\n    var left = [Character]()\n\
    \    var right = [Character]()\n    for ch in lst[0] {\n        if ch == \"(\"\
    \ {\n            left.append(ch)\n        } else {\n            if left.isEmpty\
    \ {\n                return \"No\"\n            }\n            left.removeLast()\n\
    \        }\n    }\n    for ch in lst[1] {\n        if ch == \")\" {\n        \
    \    right.append(ch)\n        } else {\n            if right.isEmpty {\n    \
    \            return \"No\"\n            }\n            right.removeLast()\n  \
    \      }\n    }\n    if left.count == right.count {\n        return \"Yes\"\n\
    \    }\n    return \"No\"\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(match_parens(lst:\
    \ [\"()(\", \")\"]) == \"Yes\")\nassert(match_parens(lst: [\")\", \")\"]) == \"\
    No\")\nassert(match_parens(lst: [\"(()(())\", \"())())\"]) == \"No\")\nassert(match_parens(lst:\
    \ [\")())\", \"(()()(\"]) == \"Yes\")\nassert(match_parens(lst: [\"(())))\", \"\
    (()())((\"]) == \"Yes\")\nassert(match_parens(lst: [\"()\", \"())\"]) == \"No\"\
    )\nassert(match_parens(lst: [\"(()(\", \"()))()\"]) == \"Yes\")\nassert(match_parens(lst:\
    \ [\"((((\", \"((())\"]) == \"No\")\nassert(match_parens(lst: [\")(()\", \"(()(\"\
    ]) == \"No\")\nassert(match_parens(lst: [\")(\", \")(\"]) == \"No\")\nassert(match_parens(lst:\
    \ [\"(\", \")\"]) == \"Yes\")\nassert(match_parens(lst: [\")\", \"(\"]) == \"\
    Yes\")"
  status: Exception
  stderr: 'tmp6x0pcvj6/tmp6x0pcvj6.swift:60: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b5691a3ac80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b5691731b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b5691731988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b56917307b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmp6x0pcvj6                        0x000055c4acdfeda6 <unavailable> + 7590

    5    libc.so.6                          0x00002b5691c26460 __libc_start_main +
    245

    6    tmp6x0pcvj6                        0x000055c4acdfe509 <unavailable> + 5385

    '
  stdout: ''
  timestamp: 1659979532
- exit_code: -4
  program: "\n/// You are given an array of two strings, both strings consist of open\n\
    /// parentheses '(' or close parentheses ')' only.\n/// Your job is to check if\
    \ it is possible to concatenate the two strings in\n/// some order, that the resulting\
    \ string will be good.\n/// A string S is considered to be good if and only if\
    \ all parentheses in S\n/// are balanced. For example: the string '(())()' is\
    \ good, while the string\n/// '())' is not.\n/// Return 'Yes' if there's a way\
    \ to make a good string, and return 'No' otherwise.\n/// Examples:\n/// >>> match_parens(lst:\
    \ [\"()(\", \")\"])\n/// \"Yes\"\n/// >>> match_parens(lst: [\")\", \")\"])\n\
    /// \"No\"\nfunc match_parens(lst: [String]) -> String {\n    var counter: Int\
    \ = 0\n    for str in lst {\n        for char in str {\n            if char ==\
    \ \"(\" {\n                counter += 1\n            } else {\n              \
    \  counter -= 1\n            }\n            if counter < 0 {\n               \
    \ return \"No\"\n            }\n        }\n    }\n    return counter == 0 ? \"\
    Yes\" : \"No\"\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool\
    \ {\n    if left.count != right.count {\n        return false\n    }\n    for\
    \ (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(match_parens(lst:\
    \ [\"()(\", \")\"]) == \"Yes\")\nassert(match_parens(lst: [\")\", \")\"]) == \"\
    No\")\nassert(match_parens(lst: [\"(()(())\", \"())())\"]) == \"No\")\nassert(match_parens(lst:\
    \ [\")())\", \"(()()(\"]) == \"Yes\")\nassert(match_parens(lst: [\"(())))\", \"\
    (()())((\"]) == \"Yes\")\nassert(match_parens(lst: [\"()\", \"())\"]) == \"No\"\
    )\nassert(match_parens(lst: [\"(()(\", \"()))()\"]) == \"Yes\")\nassert(match_parens(lst:\
    \ [\"((((\", \"((())\"]) == \"No\")\nassert(match_parens(lst: [\")(()\", \"(()(\"\
    ]) == \"No\")\nassert(match_parens(lst: [\")(\", \")(\"]) == \"No\")\nassert(match_parens(lst:\
    \ [\"(\", \")\"]) == \"Yes\")\nassert(match_parens(lst: [\")\", \"(\"]) == \"\
    Yes\")"
  status: Exception
  stderr: 'tmp6gaabds7/tmp6gaabds7.swift:48: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b33bae5ac80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b33bab51b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b33bab51988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b33bab507b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmp6gaabds7                        0x000055d4209d8c36 <unavailable> + 7222

    5    libc.so.6                          0x00002b33bb046460 __libc_start_main +
    245

    6    tmp6gaabds7                        0x000055d4209d8399 <unavailable> + 5017

    '
  stdout: ''
  timestamp: 1659979532
- exit_code: -4
  program: "\n/// You are given an array of two strings, both strings consist of open\n\
    /// parentheses '(' or close parentheses ')' only.\n/// Your job is to check if\
    \ it is possible to concatenate the two strings in\n/// some order, that the resulting\
    \ string will be good.\n/// A string S is considered to be good if and only if\
    \ all parentheses in S\n/// are balanced. For example: the string '(())()' is\
    \ good, while the string\n/// '())' is not.\n/// Return 'Yes' if there's a way\
    \ to make a good string, and return 'No' otherwise.\n/// Examples:\n/// >>> match_parens(lst:\
    \ [\"()(\", \")\"])\n/// \"Yes\"\n/// >>> match_parens(lst: [\")\", \")\"])\n\
    /// \"No\"\nfunc match_parens(lst: [String]) -> String {\n    // + 1 for additional\
    \ right parenthesis\n    let total_r_par: Int = lst.reduce(0) { $0 + $1.count\
    \ } + 1\n    // number of left parentheses in the first string\n    let l_par:\
    \ Int = lst[0].count\n    // number of right parentheses in the second string\n\
    \    let r_par: Int = lst[1].count\n    // number of necessary right parentheses\n\
    \    let necessary_r_par: Int = 2 * l_par\n    // if there is at least one right\
    \ parenthesis in the second string\n    // or the number of right parentheses\
    \ is enough to cover all\n    // the left parentheses\n    return (r_par > 0 ||\
    \ total_r_par >= necessary_r_par) ? \"Yes\" : \"No\"\n}\n\n\nfunc ==(left: [(Int,\
    \ Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n\
    \        return false\n    }\n    for (l, r) in zip(left, right) {\n        if\
    \ l != r {\n            return false\n        }\n    }\n    return true\n}\n \
    \           \nassert(match_parens(lst: [\"()(\", \")\"]) == \"Yes\")\nassert(match_parens(lst:\
    \ [\")\", \")\"]) == \"No\")\nassert(match_parens(lst: [\"(()(())\", \"())())\"\
    ]) == \"No\")\nassert(match_parens(lst: [\")())\", \"(()()(\"]) == \"Yes\")\n\
    assert(match_parens(lst: [\"(())))\", \"(()())((\"]) == \"Yes\")\nassert(match_parens(lst:\
    \ [\"()\", \"())\"]) == \"No\")\nassert(match_parens(lst: [\"(()(\", \"()))()\"\
    ]) == \"Yes\")\nassert(match_parens(lst: [\"((((\", \"((())\"]) == \"No\")\nassert(match_parens(lst:\
    \ [\")(()\", \"(()(\"]) == \"No\")\nassert(match_parens(lst: [\")(\", \")(\"])\
    \ == \"No\")\nassert(match_parens(lst: [\"(\", \")\"]) == \"Yes\")\nassert(match_parens(lst:\
    \ [\")\", \"(\"]) == \"Yes\")"
  status: Exception
  stderr: 'tmpvwwrysly/tmpvwwrysly.swift:44: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002ac60d79ac80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002ac60d491b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002ac60d491988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002ac60d4907b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpvwwrysly                        0x000055c371955720 <unavailable> + 5920

    5    libc.so.6                          0x00002ac60d986460 __libc_start_main +
    245

    6    tmpvwwrysly                        0x000055c371955199 <unavailable> + 4505

    '
  stdout: ''
  timestamp: 1659979532
- exit_code: 1
  program: "\n/// You are given an array of two strings, both strings consist of open\n\
    /// parentheses '(' or close parentheses ')' only.\n/// Your job is to check if\
    \ it is possible to concatenate the two strings in\n/// some order, that the resulting\
    \ string will be good.\n/// A string S is considered to be good if and only if\
    \ all parentheses in S\n/// are balanced. For example: the string '(())()' is\
    \ good, while the string\n/// '())' is not.\n/// Return 'Yes' if there's a way\
    \ to make a good string, and return 'No' otherwise.\n/// Examples:\n/// >>> match_parens(lst:\
    \ [\"()(\", \")\"])\n/// \"Yes\"\n/// >>> match_parens(lst: [\")\", \")\"])\n\
    /// \"No\"\nfunc match_parens(lst: [String]) -> String {\n    var lst = lst\n\
    \    for i in 0..<lst.count {\n        lst[i] = lst[i].replacingOccurrences(of:\
    \ \"(\", with: \"+\")\n        lst[i] = lst[i].replacingOccurrences(of: \")\"\
    , with: \"-\")\n    }\n    let sum = lst.joined().split(separator: \"+\").reduce(0)\
    \ { $0 + $1.count }\n    let min = lst.joined().split(separator: \"-\").reduce(0)\
    \ { $0 + $1.count }\n    return sum == min ? \"Yes\" : \"No\"\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(match_parens(lst: [\"()(\", \")\"]) == \"Yes\")\nassert(match_parens(lst:\
    \ [\")\", \")\"]) == \"No\")\nassert(match_parens(lst: [\"(()(())\", \"())())\"\
    ]) == \"No\")\nassert(match_parens(lst: [\")())\", \"(()()(\"]) == \"Yes\")\n\
    assert(match_parens(lst: [\"(())))\", \"(()())((\"]) == \"Yes\")\nassert(match_parens(lst:\
    \ [\"()\", \"())\"]) == \"No\")\nassert(match_parens(lst: [\"(()(\", \"()))()\"\
    ]) == \"Yes\")\nassert(match_parens(lst: [\"((((\", \"((())\"]) == \"No\")\nassert(match_parens(lst:\
    \ [\")(()\", \"(()(\"]) == \"No\")\nassert(match_parens(lst: [\")(\", \")(\"])\
    \ == \"No\")\nassert(match_parens(lst: [\"(\", \")\"]) == \"Yes\")\nassert(match_parens(lst:\
    \ [\")\", \"(\"]) == \"Yes\")"
  status: SyntaxError
  stderr: "/tmp/tmpwqspjumy.swift:18:25: error: value of type 'String' has no member\
    \ 'replacingOccurrences'\n        lst[i] = lst[i].replacingOccurrences(of: \"\
    (\", with: \"+\")\n                 ~~~~~~ ^~~~~~~~~~~~~~~~~~~~\n/tmp/tmpwqspjumy.swift:19:25:\
    \ error: value of type 'String' has no member 'replacingOccurrences'\n       \
    \ lst[i] = lst[i].replacingOccurrences(of: \")\", with: \"-\")\n             \
    \    ~~~~~~ ^~~~~~~~~~~~~~~~~~~~\n"
  stdout: ''
  timestamp: 1659979532
- exit_code: 1
  program: "\n/// You are given an array of two strings, both strings consist of open\n\
    /// parentheses '(' or close parentheses ')' only.\n/// Your job is to check if\
    \ it is possible to concatenate the two strings in\n/// some order, that the resulting\
    \ string will be good.\n/// A string S is considered to be good if and only if\
    \ all parentheses in S\n/// are balanced. For example: the string '(())()' is\
    \ good, while the string\n/// '())' is not.\n/// Return 'Yes' if there's a way\
    \ to make a good string, and return 'No' otherwise.\n/// Examples:\n/// >>> match_parens(lst:\
    \ [\"()(\", \")\"])\n/// \"Yes\"\n/// >>> match_parens(lst: [\")\", \")\"])\n\
    /// \"No\"\nfunc match_parens(lst: [String]) -> String {\n    var stack = Stack<Character>()\n\
    \    for s in lst {\n        for char in s {\n            if char == \"(\" {\n\
    \                stack.push(element: char)\n            } else {\n           \
    \     if !stack.isEmpty {\n                    stack.pop()\n                }\
    \ else {\n                    return \"No\"\n                }\n            }\n\
    \        }\n    }\n    return stack.isEmpty ? \"Yes\" : \"No\"\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(match_parens(lst: [\"()(\", \")\"]) == \"Yes\")\nassert(match_parens(lst:\
    \ [\")\", \")\"]) == \"No\")\nassert(match_parens(lst: [\"(()(())\", \"())())\"\
    ]) == \"No\")\nassert(match_parens(lst: [\")())\", \"(()()(\"]) == \"Yes\")\n\
    assert(match_parens(lst: [\"(())))\", \"(()())((\"]) == \"Yes\")\nassert(match_parens(lst:\
    \ [\"()\", \"())\"]) == \"No\")\nassert(match_parens(lst: [\"(()(\", \"()))()\"\
    ]) == \"Yes\")\nassert(match_parens(lst: [\"((((\", \"((())\"]) == \"No\")\nassert(match_parens(lst:\
    \ [\")(()\", \"(()(\"]) == \"No\")\nassert(match_parens(lst: [\")(\", \")(\"])\
    \ == \"No\")\nassert(match_parens(lst: [\"(\", \")\"]) == \"Yes\")\nassert(match_parens(lst:\
    \ [\")\", \"(\"]) == \"Yes\")"
  status: SyntaxError
  stderr: "/tmp/tmpfkuxwo_3.swift:16:17: error: cannot find 'Stack' in scope\n   \
    \ var stack = Stack<Character>()\n                ^~~~~\n"
  stdout: ''
  timestamp: 1659979532
- exit_code: -4
  program: "\n/// You are given an array of two strings, both strings consist of open\n\
    /// parentheses '(' or close parentheses ')' only.\n/// Your job is to check if\
    \ it is possible to concatenate the two strings in\n/// some order, that the resulting\
    \ string will be good.\n/// A string S is considered to be good if and only if\
    \ all parentheses in S\n/// are balanced. For example: the string '(())()' is\
    \ good, while the string\n/// '())' is not.\n/// Return 'Yes' if there's a way\
    \ to make a good string, and return 'No' otherwise.\n/// Examples:\n/// >>> match_parens(lst:\
    \ [\"()(\", \")\"])\n/// \"Yes\"\n/// >>> match_parens(lst: [\")\", \")\"])\n\
    /// \"No\"\nfunc match_parens(lst: [String]) -> String {\n    let str1 = lst[0]\n\
    \    let str2 = lst[1]\n    let str1_bad = str1.contains(\"(\") && str2.contains(\"\
    )\")\n    let str2_bad = str2.contains(\"(\") && str1.contains(\")\")\n    let\
    \ match = !str1_bad && !str2_bad\n    return match ? \"Yes\" : \"No\"\n}\n\n\n\
    func ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(match_parens(lst: [\"()(\", \")\"]) == \"Yes\"\
    )\nassert(match_parens(lst: [\")\", \")\"]) == \"No\")\nassert(match_parens(lst:\
    \ [\"(()(())\", \"())())\"]) == \"No\")\nassert(match_parens(lst: [\")())\", \"\
    (()()(\"]) == \"Yes\")\nassert(match_parens(lst: [\"(())))\", \"(()())((\"]) ==\
    \ \"Yes\")\nassert(match_parens(lst: [\"()\", \"())\"]) == \"No\")\nassert(match_parens(lst:\
    \ [\"(()(\", \"()))()\"]) == \"Yes\")\nassert(match_parens(lst: [\"((((\", \"\
    ((())\"]) == \"No\")\nassert(match_parens(lst: [\")(()\", \"(()(\"]) == \"No\"\
    )\nassert(match_parens(lst: [\")(\", \")(\"]) == \"No\")\nassert(match_parens(lst:\
    \ [\"(\", \")\"]) == \"Yes\")\nassert(match_parens(lst: [\")\", \"(\"]) == \"\
    Yes\")"
  status: Exception
  stderr: 'tmpnefe_is2/tmpnefe_is2.swift:37: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002ae7cee14c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002ae7ceb0bb6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002ae7ceb0b988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002ae7ceb0a7b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpnefe_is2                        0x0000561f1298e676 <unavailable> + 5750

    5    libc.so.6                          0x00002ae7cf000460 __libc_start_main +
    245

    6    tmpnefe_is2                        0x0000561f1298e259 <unavailable> + 4697

    '
  stdout: ''
  timestamp: 1659979532
- exit_code: -4
  program: "\n/// You are given an array of two strings, both strings consist of open\n\
    /// parentheses '(' or close parentheses ')' only.\n/// Your job is to check if\
    \ it is possible to concatenate the two strings in\n/// some order, that the resulting\
    \ string will be good.\n/// A string S is considered to be good if and only if\
    \ all parentheses in S\n/// are balanced. For example: the string '(())()' is\
    \ good, while the string\n/// '())' is not.\n/// Return 'Yes' if there's a way\
    \ to make a good string, and return 'No' otherwise.\n/// Examples:\n/// >>> match_parens(lst:\
    \ [\"()(\", \")\"])\n/// \"Yes\"\n/// >>> match_parens(lst: [\")\", \")\"])\n\
    /// \"No\"\nfunc match_parens(lst: [String]) -> String {\n    var lhs = 0\n  \
    \  var rhs = 0\n    for letter in lst[0] {\n        if letter == \"(\" {\n   \
    \         lhs += 1\n        } else {\n            rhs += 1\n        }\n    }\n\
    \    for letter in lst[1] {\n        if letter == \"(\" {\n            lhs +=\
    \ 1\n        } else {\n            rhs += 1\n        }\n    }\n    return (lhs\
    \ == rhs) ? \"Yes\" : \"No\"\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int,\
    \ Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n\
    \    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n          \
    \  return false\n        }\n    }\n    return true\n}\n            \nassert(match_parens(lst:\
    \ [\"()(\", \")\"]) == \"Yes\")\nassert(match_parens(lst: [\")\", \")\"]) == \"\
    No\")\nassert(match_parens(lst: [\"(()(())\", \"())())\"]) == \"No\")\nassert(match_parens(lst:\
    \ [\")())\", \"(()()(\"]) == \"Yes\")\nassert(match_parens(lst: [\"(())))\", \"\
    (()())((\"]) == \"Yes\")\nassert(match_parens(lst: [\"()\", \"())\"]) == \"No\"\
    )\nassert(match_parens(lst: [\"(()(\", \"()))()\"]) == \"Yes\")\nassert(match_parens(lst:\
    \ [\"((((\", \"((())\"]) == \"No\")\nassert(match_parens(lst: [\")(()\", \"(()(\"\
    ]) == \"No\")\nassert(match_parens(lst: [\")(\", \")(\"]) == \"No\")\nassert(match_parens(lst:\
    \ [\"(\", \")\"]) == \"Yes\")\nassert(match_parens(lst: [\")\", \"(\"]) == \"\
    Yes\")"
  status: Exception
  stderr: 'tmp4n9qofxy/tmp4n9qofxy.swift:57: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002af74b3fbc80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002af74b0f2b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002af74b0f2988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002af74b0f17b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmp4n9qofxy                        0x000055f0b5836468 <unavailable> + 9320

    5    libc.so.6                          0x00002af74b5e7460 __libc_start_main +
    245

    6    tmp4n9qofxy                        0x000055f0b5835289 <unavailable> + 4745

    '
  stdout: ''
  timestamp: 1659979532
- exit_code: 1
  program: "\n/// You are given an array of two strings, both strings consist of open\n\
    /// parentheses '(' or close parentheses ')' only.\n/// Your job is to check if\
    \ it is possible to concatenate the two strings in\n/// some order, that the resulting\
    \ string will be good.\n/// A string S is considered to be good if and only if\
    \ all parentheses in S\n/// are balanced. For example: the string '(())()' is\
    \ good, while the string\n/// '())' is not.\n/// Return 'Yes' if there's a way\
    \ to make a good string, and return 'No' otherwise.\n/// Examples:\n/// >>> match_parens(lst:\
    \ [\"()(\", \")\"])\n/// \"Yes\"\n/// >>> match_parens(lst: [\")\", \")\"])\n\
    /// \"No\"\nfunc match_parens(lst: [String]) -> String {\n    let l1 = lst[0]\n\
    \    let l2 = lst[1]\n    let c1 = count_parens(l1)\n    let c2 = count_parens(l2)\n\
    \    if c1[0] == c2[0] && c1[1] == c2[1] {\n        return \"Yes\"\n    }\n  \
    \  return \"No\"\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool\
    \ {\n    if left.count != right.count {\n        return false\n    }\n    for\
    \ (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(match_parens(lst:\
    \ [\"()(\", \")\"]) == \"Yes\")\nassert(match_parens(lst: [\")\", \")\"]) == \"\
    No\")\nassert(match_parens(lst: [\"(()(())\", \"())())\"]) == \"No\")\nassert(match_parens(lst:\
    \ [\")())\", \"(()()(\"]) == \"Yes\")\nassert(match_parens(lst: [\"(())))\", \"\
    (()())((\"]) == \"Yes\")\nassert(match_parens(lst: [\"()\", \"())\"]) == \"No\"\
    )\nassert(match_parens(lst: [\"(()(\", \"()))()\"]) == \"Yes\")\nassert(match_parens(lst:\
    \ [\"((((\", \"((())\"]) == \"No\")\nassert(match_parens(lst: [\")(()\", \"(()(\"\
    ]) == \"No\")\nassert(match_parens(lst: [\")(\", \")(\"]) == \"No\")\nassert(match_parens(lst:\
    \ [\"(\", \")\"]) == \"Yes\")\nassert(match_parens(lst: [\")\", \"(\"]) == \"\
    Yes\")"
  status: SyntaxError
  stderr: "/tmp/tmpdc2kgeie.swift:18:14: error: cannot find 'count_parens' in scope\n\
    \    let c1 = count_parens(l1)\n             ^~~~~~~~~~~~\n/tmp/tmpdc2kgeie.swift:19:14:\
    \ error: cannot find 'count_parens' in scope\n    let c2 = count_parens(l2)\n\
    \             ^~~~~~~~~~~~\n"
  stdout: ''
  timestamp: 1659979532
- exit_code: -4
  program: "\n/// You are given an array of two strings, both strings consist of open\n\
    /// parentheses '(' or close parentheses ')' only.\n/// Your job is to check if\
    \ it is possible to concatenate the two strings in\n/// some order, that the resulting\
    \ string will be good.\n/// A string S is considered to be good if and only if\
    \ all parentheses in S\n/// are balanced. For example: the string '(())()' is\
    \ good, while the string\n/// '())' is not.\n/// Return 'Yes' if there's a way\
    \ to make a good string, and return 'No' otherwise.\n/// Examples:\n/// >>> match_parens(lst:\
    \ [\"()(\", \")\"])\n/// \"Yes\"\n/// >>> match_parens(lst: [\")\", \")\"])\n\
    /// \"No\"\nfunc match_parens(lst: [String]) -> String {\n    var count = 0\n\
    \    for i in lst[0] {\n        if i == \"(\" {\n            count += 1\n    \
    \    } else {\n            count -= 1\n        }\n    }\n    for i in lst[1] {\n\
    \        if i == \"(\" {\n            count += 1\n        } else {\n         \
    \   count -= 1\n        }\n    }\n    if count == 0 {\n        return \"Yes\"\n\
    \    } else {\n        return \"No\"\n    }\n}\n\n\nfunc ==(left: [(Int, Int)],\
    \ right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n       \
    \ return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r\
    \ {\n            return false\n        }\n    }\n    return true\n}\n        \
    \    \nassert(match_parens(lst: [\"()(\", \")\"]) == \"Yes\")\nassert(match_parens(lst:\
    \ [\")\", \")\"]) == \"No\")\nassert(match_parens(lst: [\"(()(())\", \"())())\"\
    ]) == \"No\")\nassert(match_parens(lst: [\")())\", \"(()()(\"]) == \"Yes\")\n\
    assert(match_parens(lst: [\"(())))\", \"(()())((\"]) == \"Yes\")\nassert(match_parens(lst:\
    \ [\"()\", \"())\"]) == \"No\")\nassert(match_parens(lst: [\"(()(\", \"()))()\"\
    ]) == \"Yes\")\nassert(match_parens(lst: [\"((((\", \"((())\"]) == \"No\")\nassert(match_parens(lst:\
    \ [\")(()\", \"(()(\"]) == \"No\")\nassert(match_parens(lst: [\")(\", \")(\"])\
    \ == \"No\")\nassert(match_parens(lst: [\"(\", \")\"]) == \"Yes\")\nassert(match_parens(lst:\
    \ [\")\", \"(\"]) == \"Yes\")"
  status: Exception
  stderr: 'tmpd1gwk661/tmpd1gwk661.swift:60: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002ac806bcbc80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002ac8068c2b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002ac8068c2988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002ac8068c17b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpd1gwk661                        0x0000557520b58468 <unavailable> + 9320

    5    libc.so.6                          0x00002ac806db7460 __libc_start_main +
    245

    6    tmpd1gwk661                        0x0000557520b57289 <unavailable> + 4745

    '
  stdout: ''
  timestamp: 1659979532
- exit_code: -4
  program: "\n/// You are given an array of two strings, both strings consist of open\n\
    /// parentheses '(' or close parentheses ')' only.\n/// Your job is to check if\
    \ it is possible to concatenate the two strings in\n/// some order, that the resulting\
    \ string will be good.\n/// A string S is considered to be good if and only if\
    \ all parentheses in S\n/// are balanced. For example: the string '(())()' is\
    \ good, while the string\n/// '())' is not.\n/// Return 'Yes' if there's a way\
    \ to make a good string, and return 'No' otherwise.\n/// Examples:\n/// >>> match_parens(lst:\
    \ [\"()(\", \")\"])\n/// \"Yes\"\n/// >>> match_parens(lst: [\")\", \")\"])\n\
    /// \"No\"\nfunc match_parens(lst: [String]) -> String {\n    var lhs: [Character]\
    \ = [Character]()\n    var rhs: [Character] = [Character]()\n    lhs.append(contentsOf:\
    \ lst[0])\n    rhs.append(contentsOf: lst[1])\n    var lhs_open: Int = 0\n   \
    \ var rhs_open: Int = 0\n    for character in lhs {\n        if character == \"\
    (\" {\n            lhs_open += 1\n        } else {\n            lhs_open -= 1\n\
    \        }\n    }\n    for character in rhs {\n        if character == \"(\" {\n\
    \            rhs_open += 1\n        } else {\n            rhs_open -= 1\n    \
    \    }\n    }\n    if lhs_open > 0 && rhs_open < 0 {\n        return \"Yes\"\n\
    \    } else if lhs_open < 0 && rhs_open > 0 {\n        return \"Yes\"\n    } else\
    \ {\n        return \"No\"\n    }\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int,\
    \ Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n\
    \    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n          \
    \  return false\n        }\n    }\n    return true\n}\n            \nassert(match_parens(lst:\
    \ [\"()(\", \")\"]) == \"Yes\")\nassert(match_parens(lst: [\")\", \")\"]) == \"\
    No\")\nassert(match_parens(lst: [\"(()(())\", \"())())\"]) == \"No\")\nassert(match_parens(lst:\
    \ [\")())\", \"(()()(\"]) == \"Yes\")\nassert(match_parens(lst: [\"(())))\", \"\
    (()())((\"]) == \"Yes\")\nassert(match_parens(lst: [\"()\", \"())\"]) == \"No\"\
    )\nassert(match_parens(lst: [\"(()(\", \"()))()\"]) == \"Yes\")\nassert(match_parens(lst:\
    \ [\"((((\", \"((())\"]) == \"No\")\nassert(match_parens(lst: [\")(()\", \"(()(\"\
    ]) == \"No\")\nassert(match_parens(lst: [\")(\", \")(\"]) == \"No\")\nassert(match_parens(lst:\
    \ [\"(\", \")\"]) == \"Yes\")\nassert(match_parens(lst: [\")\", \"(\"]) == \"\
    Yes\")"
  status: Exception
  stderr: 'tmpu8mm3wn5/tmpu8mm3wn5.swift:60: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b2e69e3ec80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b2e69b35b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b2e69b35988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b2e69b347b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpu8mm3wn5                        0x000056152bb65b4b <unavailable> + 6987

    5    libc.so.6                          0x00002b2e6a02a460 __libc_start_main +
    245

    6    tmpu8mm3wn5                        0x000056152bb65439 <unavailable> + 5177

    '
  stdout: ''
  timestamp: 1659979532
- exit_code: -4
  program: "\n/// You are given an array of two strings, both strings consist of open\n\
    /// parentheses '(' or close parentheses ')' only.\n/// Your job is to check if\
    \ it is possible to concatenate the two strings in\n/// some order, that the resulting\
    \ string will be good.\n/// A string S is considered to be good if and only if\
    \ all parentheses in S\n/// are balanced. For example: the string '(())()' is\
    \ good, while the string\n/// '())' is not.\n/// Return 'Yes' if there's a way\
    \ to make a good string, and return 'No' otherwise.\n/// Examples:\n/// >>> match_parens(lst:\
    \ [\"()(\", \")\"])\n/// \"Yes\"\n/// >>> match_parens(lst: [\")\", \")\"])\n\
    /// \"No\"\nfunc match_parens(lst: [String]) -> String {\n    let str = lst[0]\
    \ + lst[1]\n    var stack = [Character]()\n    for c in str {\n        if c ==\
    \ \"(\" {\n            stack.append(c)\n        } else {\n            if stack.isEmpty\
    \ {\n                return \"No\"\n            }\n            stack.removeLast()\n\
    \        }\n    }\n    return stack.isEmpty ? \"Yes\" : \"No\"\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(match_parens(lst: [\"()(\", \")\"]) == \"Yes\")\nassert(match_parens(lst:\
    \ [\")\", \")\"]) == \"No\")\nassert(match_parens(lst: [\"(()(())\", \"())())\"\
    ]) == \"No\")\nassert(match_parens(lst: [\")())\", \"(()()(\"]) == \"Yes\")\n\
    assert(match_parens(lst: [\"(())))\", \"(()())((\"]) == \"Yes\")\nassert(match_parens(lst:\
    \ [\"()\", \"())\"]) == \"No\")\nassert(match_parens(lst: [\"(()(\", \"()))()\"\
    ]) == \"Yes\")\nassert(match_parens(lst: [\"((((\", \"((())\"]) == \"No\")\nassert(match_parens(lst:\
    \ [\")(()\", \"(()(\"]) == \"No\")\nassert(match_parens(lst: [\")(\", \")(\"])\
    \ == \"No\")\nassert(match_parens(lst: [\"(\", \")\"]) == \"Yes\")\nassert(match_parens(lst:\
    \ [\")\", \"(\"]) == \"Yes\")"
  status: Exception
  stderr: 'tmpjjobb19b/tmpjjobb19b.swift:47: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b5f01c29c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b5f01920b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b5f01920988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b5f0191f7b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpjjobb19b                        0x0000560535210da6 <unavailable> + 7590

    5    libc.so.6                          0x00002b5f01e15460 __libc_start_main +
    245

    6    tmpjjobb19b                        0x0000560535210509 <unavailable> + 5385

    '
  stdout: ''
  timestamp: 1659979533
- exit_code: -4
  program: "\n/// You are given an array of two strings, both strings consist of open\n\
    /// parentheses '(' or close parentheses ')' only.\n/// Your job is to check if\
    \ it is possible to concatenate the two strings in\n/// some order, that the resulting\
    \ string will be good.\n/// A string S is considered to be good if and only if\
    \ all parentheses in S\n/// are balanced. For example: the string '(())()' is\
    \ good, while the string\n/// '())' is not.\n/// Return 'Yes' if there's a way\
    \ to make a good string, and return 'No' otherwise.\n/// Examples:\n/// >>> match_parens(lst:\
    \ [\"()(\", \")\"])\n/// \"Yes\"\n/// >>> match_parens(lst: [\")\", \")\"])\n\
    /// \"No\"\nfunc match_parens(lst: [String]) -> String {\n    return \"\"\n}\n\
    \n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(match_parens(lst: [\"()(\", \")\"]) == \"Yes\"\
    )\nassert(match_parens(lst: [\")\", \")\"]) == \"No\")\nassert(match_parens(lst:\
    \ [\"(()(())\", \"())())\"]) == \"No\")\nassert(match_parens(lst: [\")())\", \"\
    (()()(\"]) == \"Yes\")\nassert(match_parens(lst: [\"(())))\", \"(()())((\"]) ==\
    \ \"Yes\")\nassert(match_parens(lst: [\"()\", \"())\"]) == \"No\")\nassert(match_parens(lst:\
    \ [\"(()(\", \"()))()\"]) == \"Yes\")\nassert(match_parens(lst: [\"((((\", \"\
    ((())\"]) == \"No\")\nassert(match_parens(lst: [\")(()\", \"(()(\"]) == \"No\"\
    )\nassert(match_parens(lst: [\")(\", \")(\"]) == \"No\")\nassert(match_parens(lst:\
    \ [\"(\", \")\"]) == \"Yes\")\nassert(match_parens(lst: [\")\", \"(\"]) == \"\
    Yes\")"
  status: Exception
  stderr: 'tmpfmfu7nkg/tmpfmfu7nkg.swift:32: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b7cd1af6c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b7cd17edb6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b7cd17ed988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b7cd17ec7b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpfmfu7nkg                        0x0000561e620034a6 <unavailable> + 5286

    5    libc.so.6                          0x00002b7cd1ce2460 __libc_start_main +
    245

    6    tmpfmfu7nkg                        0x0000561e62003089 <unavailable> + 4233

    '
  stdout: ''
  timestamp: 1659979532
- exit_code: 1
  program: "\n/// You are given an array of two strings, both strings consist of open\n\
    /// parentheses '(' or close parentheses ')' only.\n/// Your job is to check if\
    \ it is possible to concatenate the two strings in\n/// some order, that the resulting\
    \ string will be good.\n/// A string S is considered to be good if and only if\
    \ all parentheses in S\n/// are balanced. For example: the string '(())()' is\
    \ good, while the string\n/// '())' is not.\n/// Return 'Yes' if there's a way\
    \ to make a good string, and return 'No' otherwise.\n/// Examples:\n/// >>> match_parens(lst:\
    \ [\"()(\", \")\"])\n/// \"Yes\"\n/// >>> match_parens(lst: [\")\", \")\"])\n\
    /// \"No\"\nfunc match_parens(lst: [String]) -> String {\n    var stack = [String]()\n\
    \    var correct = true\n    for i in 0..<lst.count {\n        for j in 0..<lst[i].count\
    \ {\n            if lst[i][j] == \"(\" {\n                stack.append(\"(\")\n\
    \            } else {\n                if stack.isEmpty {\n                  \
    \  correct = false\n                    break\n                } else {\n    \
    \                stack.removeLast()\n                }\n            }\n      \
    \  }\n    }\n    if !stack.isEmpty {\n        correct = false\n    }\n    if correct\
    \ {\n        return \"Yes\"\n    } else {\n        return \"No\"\n    }\n}\n\n\
    \nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(match_parens(lst: [\"()(\", \")\"]) == \"Yes\"\
    )\nassert(match_parens(lst: [\")\", \")\"]) == \"No\")\nassert(match_parens(lst:\
    \ [\"(()(())\", \"())())\"]) == \"No\")\nassert(match_parens(lst: [\")())\", \"\
    (()()(\"]) == \"Yes\")\nassert(match_parens(lst: [\"(())))\", \"(()())((\"]) ==\
    \ \"Yes\")\nassert(match_parens(lst: [\"()\", \"())\"]) == \"No\")\nassert(match_parens(lst:\
    \ [\"(()(\", \"()))()\"]) == \"Yes\")\nassert(match_parens(lst: [\"((((\", \"\
    ((())\"]) == \"No\")\nassert(match_parens(lst: [\")(()\", \"(()(\"]) == \"No\"\
    )\nassert(match_parens(lst: [\")(\", \")(\"]) == \"No\")\nassert(match_parens(lst:\
    \ [\"(\", \")\"]) == \"Yes\")\nassert(match_parens(lst: [\")\", \"(\"]) == \"\
    Yes\")"
  status: SyntaxError
  stderr: "/tmp/tmpg4jwrwn6.swift:20:16: error: 'subscript(_:)' is unavailable: cannot\
    \ subscript String with an Int, use a String.Index instead.\n            if lst[i][j]\
    \ == \"(\" {\n               ^~~~~~~~~\nSwift.String:3:12: note: 'subscript(_:)'\
    \ has been explicitly marked unavailable here\n    public subscript(i: Int) ->\
    \ Character { get }\n           ^\n"
  stdout: ''
  timestamp: 1659979532
- exit_code: -4
  program: "\n/// You are given an array of two strings, both strings consist of open\n\
    /// parentheses '(' or close parentheses ')' only.\n/// Your job is to check if\
    \ it is possible to concatenate the two strings in\n/// some order, that the resulting\
    \ string will be good.\n/// A string S is considered to be good if and only if\
    \ all parentheses in S\n/// are balanced. For example: the string '(())()' is\
    \ good, while the string\n/// '())' is not.\n/// Return 'Yes' if there's a way\
    \ to make a good string, and return 'No' otherwise.\n/// Examples:\n/// >>> match_parens(lst:\
    \ [\"()(\", \")\"])\n/// \"Yes\"\n/// >>> match_parens(lst: [\")\", \")\"])\n\
    /// \"No\"\nfunc match_parens(lst: [String]) -> String {\n    let balanced = String(repeating:\
    \ \"(\", count: lst[0].count + lst[1].count)\n    for i in 0..<lst[0].count {\n\
    \        let str = lst[0].prefix(upTo: lst[0].index(lst[0].startIndex, offsetBy:\
    \ i)) + lst[1]\n        if str == balanced {\n            return \"Yes\"\n   \
    \     }\n    }\n    return \"No\"\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int,\
    \ Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n\
    \    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n          \
    \  return false\n        }\n    }\n    return true\n}\n            \nassert(match_parens(lst:\
    \ [\"()(\", \")\"]) == \"Yes\")\nassert(match_parens(lst: [\")\", \")\"]) == \"\
    No\")\nassert(match_parens(lst: [\"(()(())\", \"())())\"]) == \"No\")\nassert(match_parens(lst:\
    \ [\")())\", \"(()()(\"]) == \"Yes\")\nassert(match_parens(lst: [\"(())))\", \"\
    (()())((\"]) == \"Yes\")\nassert(match_parens(lst: [\"()\", \"())\"]) == \"No\"\
    )\nassert(match_parens(lst: [\"(()(\", \"()))()\"]) == \"Yes\")\nassert(match_parens(lst:\
    \ [\"((((\", \"((())\"]) == \"No\")\nassert(match_parens(lst: [\")(()\", \"(()(\"\
    ]) == \"No\")\nassert(match_parens(lst: [\")(\", \")(\"]) == \"No\")\nassert(match_parens(lst:\
    \ [\"(\", \")\"]) == \"Yes\")\nassert(match_parens(lst: [\")\", \"(\"]) == \"\
    Yes\")"
  status: Exception
  stderr: 'tmpep58_u0f/tmpep58_u0f.swift:39: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b1759378c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b175906fb6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b175906f988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b175906e7b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpep58_u0f                        0x000055e934c21a96 <unavailable> + 6806

    5    libc.so.6                          0x00002b1759564460 __libc_start_main +
    245

    6    tmpep58_u0f                        0x000055e934c21679 <unavailable> + 5753

    '
  stdout: ''
  timestamp: 1659979533
- exit_code: -4
  program: "\n/// You are given an array of two strings, both strings consist of open\n\
    /// parentheses '(' or close parentheses ')' only.\n/// Your job is to check if\
    \ it is possible to concatenate the two strings in\n/// some order, that the resulting\
    \ string will be good.\n/// A string S is considered to be good if and only if\
    \ all parentheses in S\n/// are balanced. For example: the string '(())()' is\
    \ good, while the string\n/// '())' is not.\n/// Return 'Yes' if there's a way\
    \ to make a good string, and return 'No' otherwise.\n/// Examples:\n/// >>> match_parens(lst:\
    \ [\"()(\", \")\"])\n/// \"Yes\"\n/// >>> match_parens(lst: [\")\", \")\"])\n\
    /// \"No\"\nfunc match_parens(lst: [String]) -> String {\n    let s1 = lst[0]\n\
    \    let s2 = lst[1]\n    let s = s1 + s2\n    var count = 0\n    for char in\
    \ s {\n        if char == \"(\" {\n            count += 1\n        } else {\n\
    \            count -= 1\n        }\n        if count < 0 {\n            return\
    \ \"No\"\n        }\n    }\n    return count == 0 ? \"Yes\" : \"No\"\n}\n\n\n\
    func ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(match_parens(lst: [\"()(\", \")\"]) == \"Yes\"\
    )\nassert(match_parens(lst: [\")\", \")\"]) == \"No\")\nassert(match_parens(lst:\
    \ [\"(()(())\", \"())())\"]) == \"No\")\nassert(match_parens(lst: [\")())\", \"\
    (()()(\"]) == \"Yes\")\nassert(match_parens(lst: [\"(())))\", \"(()())((\"]) ==\
    \ \"Yes\")\nassert(match_parens(lst: [\"()\", \"())\"]) == \"No\")\nassert(match_parens(lst:\
    \ [\"(()(\", \"()))()\"]) == \"Yes\")\nassert(match_parens(lst: [\"((((\", \"\
    ((())\"]) == \"No\")\nassert(match_parens(lst: [\")(()\", \"(()(\"]) == \"No\"\
    )\nassert(match_parens(lst: [\")(\", \")(\"]) == \"No\")\nassert(match_parens(lst:\
    \ [\"(\", \")\"]) == \"Yes\")\nassert(match_parens(lst: [\")\", \"(\"]) == \"\
    Yes\")"
  status: Exception
  stderr: 'tmpzv4rn5_w/tmpzv4rn5_w.swift:49: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002ae06da22c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002ae06d719b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002ae06d719988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002ae06d7187b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpzv4rn5_w                        0x000055be27c8ab76 <unavailable> + 7030

    5    libc.so.6                          0x00002ae06dc0e460 __libc_start_main +
    245

    6    tmpzv4rn5_w                        0x000055be27c8a2d9 <unavailable> + 4825

    '
  stdout: ''
  timestamp: 1659979533
- exit_code: -4
  program: "\n/// You are given an array of two strings, both strings consist of open\n\
    /// parentheses '(' or close parentheses ')' only.\n/// Your job is to check if\
    \ it is possible to concatenate the two strings in\n/// some order, that the resulting\
    \ string will be good.\n/// A string S is considered to be good if and only if\
    \ all parentheses in S\n/// are balanced. For example: the string '(())()' is\
    \ good, while the string\n/// '())' is not.\n/// Return 'Yes' if there's a way\
    \ to make a good string, and return 'No' otherwise.\n/// Examples:\n/// >>> match_parens(lst:\
    \ [\"()(\", \")\"])\n/// \"Yes\"\n/// >>> match_parens(lst: [\")\", \")\"])\n\
    /// \"No\"\nfunc match_parens(lst: [String]) -> String {\n    var par_count =\
    \ 0\n    var result = \"\"\n    for i in 0..<2 {\n        for c in lst[i] {\n\
    \            if c == \"(\" {\n                par_count += 1\n            } else\
    \ {\n                par_count -= 1\n            }\n            if par_count <\
    \ 0 {\n                break\n            }\n        }\n        if par_count <\
    \ 0 {\n            break\n        }\n    }\n    if par_count < 0 {\n        result\
    \ = \"No\"\n    } else {\n        result = \"Yes\"\n    }\n    return result\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(match_parens(lst: [\"()(\", \")\"]) == \"Yes\"\
    )\nassert(match_parens(lst: [\")\", \")\"]) == \"No\")\nassert(match_parens(lst:\
    \ [\"(()(())\", \"())())\"]) == \"No\")\nassert(match_parens(lst: [\")())\", \"\
    (()()(\"]) == \"Yes\")\nassert(match_parens(lst: [\"(())))\", \"(()())((\"]) ==\
    \ \"Yes\")\nassert(match_parens(lst: [\"()\", \"())\"]) == \"No\")\nassert(match_parens(lst:\
    \ [\"(()(\", \"()))()\"]) == \"Yes\")\nassert(match_parens(lst: [\"((((\", \"\
    ((())\"]) == \"No\")\nassert(match_parens(lst: [\")(()\", \"(()(\"]) == \"No\"\
    )\nassert(match_parens(lst: [\")(\", \")(\"]) == \"No\")\nassert(match_parens(lst:\
    \ [\"(\", \")\"]) == \"Yes\")\nassert(match_parens(lst: [\")\", \"(\"]) == \"\
    Yes\")"
  status: Exception
  stderr: 'tmpjnvz00sv/tmpjnvz00sv.swift:57: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b2f47e40c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b2f47b37b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b2f47b37988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b2f47b367b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpjnvz00sv                        0x00005604f9c2ac16 <unavailable> + 7190

    5    libc.so.6                          0x00002b2f4802c460 __libc_start_main +
    245

    6    tmpjnvz00sv                        0x00005604f9c2a379 <unavailable> + 4985

    '
  stdout: ''
  timestamp: 1659979533
- exit_code: -4
  program: "\n/// You are given an array of two strings, both strings consist of open\n\
    /// parentheses '(' or close parentheses ')' only.\n/// Your job is to check if\
    \ it is possible to concatenate the two strings in\n/// some order, that the resulting\
    \ string will be good.\n/// A string S is considered to be good if and only if\
    \ all parentheses in S\n/// are balanced. For example: the string '(())()' is\
    \ good, while the string\n/// '())' is not.\n/// Return 'Yes' if there's a way\
    \ to make a good string, and return 'No' otherwise.\n/// Examples:\n/// >>> match_parens(lst:\
    \ [\"()(\", \")\"])\n/// \"Yes\"\n/// >>> match_parens(lst: [\")\", \")\"])\n\
    /// \"No\"\nfunc match_parens(lst: [String]) -> String {\n    var first = lst[0]\n\
    \    var second = lst[1]\n    if first.count > second.count {\n        return\
    \ \"No\"\n    } else if first.count < second.count {\n        second.remove(at:\
    \ second.startIndex)\n        second.remove(at: second.startIndex)\n        return\
    \ match_parens(lst: [first, second])\n    } else {\n        return \"Yes\"\n \
    \   }\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n   \
    \ if left.count != right.count {\n        return false\n    }\n    for (l, r)\
    \ in zip(left, right) {\n        if l != r {\n            return false\n     \
    \   }\n    }\n    return true\n}\n            \nassert(match_parens(lst: [\"()(\"\
    , \")\"]) == \"Yes\")\nassert(match_parens(lst: [\")\", \")\"]) == \"No\")\nassert(match_parens(lst:\
    \ [\"(()(())\", \"())())\"]) == \"No\")\nassert(match_parens(lst: [\")())\", \"\
    (()()(\"]) == \"Yes\")\nassert(match_parens(lst: [\"(())))\", \"(()())((\"]) ==\
    \ \"Yes\")\nassert(match_parens(lst: [\"()\", \"())\"]) == \"No\")\nassert(match_parens(lst:\
    \ [\"(()(\", \"()))()\"]) == \"Yes\")\nassert(match_parens(lst: [\"((((\", \"\
    ((())\"]) == \"No\")\nassert(match_parens(lst: [\")(()\", \"(()(\"]) == \"No\"\
    )\nassert(match_parens(lst: [\")(\", \")(\"]) == \"No\")\nassert(match_parens(lst:\
    \ [\"(\", \")\"]) == \"Yes\")\nassert(match_parens(lst: [\")\", \"(\"]) == \"\
    Yes\")"
  status: Exception
  stderr: 'tmpcicxrgwj/tmpcicxrgwj.swift:42: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b20d3d6bc80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b20d3a62b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b20d3a62988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b20d3a617b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpcicxrgwj                        0x000055ad2aee4606 <unavailable> + 5638

    5    libc.so.6                          0x00002b20d3f57460 __libc_start_main +
    245

    6    tmpcicxrgwj                        0x000055ad2aee41e9 <unavailable> + 4585

    '
  stdout: ''
  timestamp: 1659979533
- exit_code: 1
  program: "\n/// You are given an array of two strings, both strings consist of open\n\
    /// parentheses '(' or close parentheses ')' only.\n/// Your job is to check if\
    \ it is possible to concatenate the two strings in\n/// some order, that the resulting\
    \ string will be good.\n/// A string S is considered to be good if and only if\
    \ all parentheses in S\n/// are balanced. For example: the string '(())()' is\
    \ good, while the string\n/// '())' is not.\n/// Return 'Yes' if there's a way\
    \ to make a good string, and return 'No' otherwise.\n/// Examples:\n/// >>> match_parens(lst:\
    \ [\"()(\", \")\"])\n/// \"Yes\"\n/// >>> match_parens(lst: [\")\", \")\"])\n\
    /// \"No\"\nfunc match_parens(lst: [String]) -> String {\n    return lst.reduce(\"\
    \") { $0 + $1 }.is_parens_balanced() ? \"Yes\" : \"No\"\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(match_parens(lst: [\"()(\", \")\"]) == \"Yes\")\nassert(match_parens(lst:\
    \ [\")\", \")\"]) == \"No\")\nassert(match_parens(lst: [\"(()(())\", \"())())\"\
    ]) == \"No\")\nassert(match_parens(lst: [\")())\", \"(()()(\"]) == \"Yes\")\n\
    assert(match_parens(lst: [\"(())))\", \"(()())((\"]) == \"Yes\")\nassert(match_parens(lst:\
    \ [\"()\", \"())\"]) == \"No\")\nassert(match_parens(lst: [\"(()(\", \"()))()\"\
    ]) == \"Yes\")\nassert(match_parens(lst: [\"((((\", \"((())\"]) == \"No\")\nassert(match_parens(lst:\
    \ [\")(()\", \"(()(\"]) == \"No\")\nassert(match_parens(lst: [\")(\", \")(\"])\
    \ == \"No\")\nassert(match_parens(lst: [\"(\", \")\"]) == \"Yes\")\nassert(match_parens(lst:\
    \ [\")\", \"(\"]) == \"Yes\")"
  status: SyntaxError
  stderr: "/tmp/tmpap5i3351.swift:16:39: error: value of type 'String' has no member\
    \ 'is_parens_balanced'\n    return lst.reduce(\"\") { $0 + $1 }.is_parens_balanced()\
    \ ? \"Yes\" : \"No\"\n           ~~~~~~~~~~~~~~~~~~~~~~~~~~ ^~~~~~~~~~~~~~~~~~\n"
  stdout: ''
  timestamp: 1659979532
- exit_code: -4
  program: "\n/// You are given an array of two strings, both strings consist of open\n\
    /// parentheses '(' or close parentheses ')' only.\n/// Your job is to check if\
    \ it is possible to concatenate the two strings in\n/// some order, that the resulting\
    \ string will be good.\n/// A string S is considered to be good if and only if\
    \ all parentheses in S\n/// are balanced. For example: the string '(())()' is\
    \ good, while the string\n/// '())' is not.\n/// Return 'Yes' if there's a way\
    \ to make a good string, and return 'No' otherwise.\n/// Examples:\n/// >>> match_parens(lst:\
    \ [\"()(\", \")\"])\n/// \"Yes\"\n/// >>> match_parens(lst: [\")\", \")\"])\n\
    /// \"No\"\nfunc match_parens(lst: [String]) -> String {\n    let left: String\
    \ = lst[0]\n    let right: String = lst[1]\n    var res: String = \"\"\n    var\
    \ arr = [Int]()\n    let left_array = Array(left)\n    let right_array = Array(right)\n\
    \    for c in left_array {\n        if (c == \"(\") {\n            arr.append(1)\n\
    \        } else {\n            arr.append(-1)\n        }\n    }\n    for c in\
    \ right_array {\n        if (c == \"(\") {\n            arr.append(1)\n      \
    \  } else {\n            arr.append(-1)\n        }\n    }\n    if (arr.reduce(0,\
    \ +) == 0) {\n        res = \"Yes\"\n    } else {\n        res = \"No\"\n    }\n\
    \    return res\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool\
    \ {\n    if left.count != right.count {\n        return false\n    }\n    for\
    \ (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(match_parens(lst:\
    \ [\"()(\", \")\"]) == \"Yes\")\nassert(match_parens(lst: [\")\", \")\"]) == \"\
    No\")\nassert(match_parens(lst: [\"(()(())\", \"())())\"]) == \"No\")\nassert(match_parens(lst:\
    \ [\")())\", \"(()()(\"]) == \"Yes\")\nassert(match_parens(lst: [\"(())))\", \"\
    (()())((\"]) == \"Yes\")\nassert(match_parens(lst: [\"()\", \"())\"]) == \"No\"\
    )\nassert(match_parens(lst: [\"(()(\", \"()))()\"]) == \"Yes\")\nassert(match_parens(lst:\
    \ [\"((((\", \"((())\"]) == \"No\")\nassert(match_parens(lst: [\")(()\", \"(()(\"\
    ]) == \"No\")\nassert(match_parens(lst: [\")(\", \")(\"]) == \"No\")\nassert(match_parens(lst:\
    \ [\"(\", \")\"]) == \"Yes\")\nassert(match_parens(lst: [\")\", \"(\"]) == \"\
    Yes\")"
  status: Exception
  stderr: 'tmpboyld24l/tmpboyld24l.swift:66: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b0862fd5c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b0862cccb6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b0862ccc988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b0862ccb7b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpboyld24l                        0x00005561a2d23718 <unavailable> + 10008

    5    libc.so.6                          0x00002b08631c1460 __libc_start_main +
    245

    6    tmpboyld24l                        0x00005561a2d22539 <unavailable> + 5433

    '
  stdout: ''
  timestamp: 1659979533
- exit_code: -4
  program: "\n/// You are given an array of two strings, both strings consist of open\n\
    /// parentheses '(' or close parentheses ')' only.\n/// Your job is to check if\
    \ it is possible to concatenate the two strings in\n/// some order, that the resulting\
    \ string will be good.\n/// A string S is considered to be good if and only if\
    \ all parentheses in S\n/// are balanced. For example: the string '(())()' is\
    \ good, while the string\n/// '())' is not.\n/// Return 'Yes' if there's a way\
    \ to make a good string, and return 'No' otherwise.\n/// Examples:\n/// >>> match_parens(lst:\
    \ [\"()(\", \")\"])\n/// \"Yes\"\n/// >>> match_parens(lst: [\")\", \")\"])\n\
    /// \"No\"\nfunc match_parens(lst: [String]) -> String {\n    var dic = [Character:\
    \ Int]()\n    dic[\"(\"] = 1\n    dic[\")\"] = -1\n    var str = lst[0] + lst[1]\n\
    \    var sum = 0\n    for c in str {\n        sum += dic[c]!\n        if sum <\
    \ 0 {\n            return \"No\"\n        }\n    }\n    return sum == 0 ? \"Yes\"\
    \ : \"No\"\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n\
    \    if left.count != right.count {\n        return false\n    }\n    for (l,\
    \ r) in zip(left, right) {\n        if l != r {\n            return false\n  \
    \      }\n    }\n    return true\n}\n            \nassert(match_parens(lst: [\"\
    ()(\", \")\"]) == \"Yes\")\nassert(match_parens(lst: [\")\", \")\"]) == \"No\"\
    )\nassert(match_parens(lst: [\"(()(())\", \"())())\"]) == \"No\")\nassert(match_parens(lst:\
    \ [\")())\", \"(()()(\"]) == \"Yes\")\nassert(match_parens(lst: [\"(())))\", \"\
    (()())((\"]) == \"Yes\")\nassert(match_parens(lst: [\"()\", \"())\"]) == \"No\"\
    )\nassert(match_parens(lst: [\"(()(\", \"()))()\"]) == \"Yes\")\nassert(match_parens(lst:\
    \ [\"((((\", \"((())\"]) == \"No\")\nassert(match_parens(lst: [\")(()\", \"(()(\"\
    ]) == \"No\")\nassert(match_parens(lst: [\")(\", \")(\"]) == \"No\")\nassert(match_parens(lst:\
    \ [\"(\", \")\"]) == \"Yes\")\nassert(match_parens(lst: [\")\", \"(\"]) == \"\
    Yes\")"
  status: Exception
  stderr: 'tmphhuaxnpo/tmphhuaxnpo.swift:46: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b136b381c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b136b078b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b136b078988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b136b0777b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmphhuaxnpo                        0x00005623c367fd16 <unavailable> + 7446

    5    libc.so.6                          0x00002b136b56d460 __libc_start_main +
    245

    6    tmphhuaxnpo                        0x00005623c367f479 <unavailable> + 5241

    '
  stdout: ''
  timestamp: 1659979533
- exit_code: 1
  program: "\n/// You are given an array of two strings, both strings consist of open\n\
    /// parentheses '(' or close parentheses ')' only.\n/// Your job is to check if\
    \ it is possible to concatenate the two strings in\n/// some order, that the resulting\
    \ string will be good.\n/// A string S is considered to be good if and only if\
    \ all parentheses in S\n/// are balanced. For example: the string '(())()' is\
    \ good, while the string\n/// '())' is not.\n/// Return 'Yes' if there's a way\
    \ to make a good string, and return 'No' otherwise.\n/// Examples:\n/// >>> match_parens(lst:\
    \ [\"()(\", \")\"])\n/// \"Yes\"\n/// >>> match_parens(lst: [\")\", \")\"])\n\
    /// \"No\"\nfunc match_parens(lst: [String]) -> String {\n    return lst.joined().parens_balanced()\
    \ ? \"Yes\" : \"No\"\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(match_parens(lst:\
    \ [\"()(\", \")\"]) == \"Yes\")\nassert(match_parens(lst: [\")\", \")\"]) == \"\
    No\")\nassert(match_parens(lst: [\"(()(())\", \"())())\"]) == \"No\")\nassert(match_parens(lst:\
    \ [\")())\", \"(()()(\"]) == \"Yes\")\nassert(match_parens(lst: [\"(())))\", \"\
    (()())((\"]) == \"Yes\")\nassert(match_parens(lst: [\"()\", \"())\"]) == \"No\"\
    )\nassert(match_parens(lst: [\"(()(\", \"()))()\"]) == \"Yes\")\nassert(match_parens(lst:\
    \ [\"((((\", \"((())\"]) == \"No\")\nassert(match_parens(lst: [\")(()\", \"(()(\"\
    ]) == \"No\")\nassert(match_parens(lst: [\")(\", \")(\"]) == \"No\")\nassert(match_parens(lst:\
    \ [\"(\", \")\"]) == \"Yes\")\nassert(match_parens(lst: [\")\", \"(\"]) == \"\
    Yes\")"
  status: SyntaxError
  stderr: "/tmp/tmph_8gbn29.swift:16:25: error: value of type 'String' has no member\
    \ 'parens_balanced'\n    return lst.joined().parens_balanced() ? \"Yes\" : \"\
    No\"\n           ~~~~~~~~~~~~ ^~~~~~~~~~~~~~~\n"
  stdout: ''
  timestamp: 1659979532
- exit_code: 1
  program: "\n/// You are given an array of two strings, both strings consist of open\n\
    /// parentheses '(' or close parentheses ')' only.\n/// Your job is to check if\
    \ it is possible to concatenate the two strings in\n/// some order, that the resulting\
    \ string will be good.\n/// A string S is considered to be good if and only if\
    \ all parentheses in S\n/// are balanced. For example: the string '(())()' is\
    \ good, while the string\n/// '())' is not.\n/// Return 'Yes' if there's a way\
    \ to make a good string, and return 'No' otherwise.\n/// Examples:\n/// >>> match_parens(lst:\
    \ [\"()(\", \")\"])\n/// \"Yes\"\n/// >>> match_parens(lst: [\")\", \")\"])\n\
    /// \"No\"\nfunc match_parens(lst: [String]) -> String {\n    let string_good\
    \ = \"Yes\"\n    let string_bad = \"No\"\n    let str1 = lst[0]\n    let str2\
    \ = lst[1]\n    if !is_good(str: str1) && !is_good(str: str2) {\n        return\
    \ string_bad\n    }\n    var parenthesis_stack = [String]()\n    for c in str1\
    \ {\n        parenthesis_stack.append(String(c))\n    }\n    var cnt = 0\n   \
    \ for c in str2 {\n        if String(c) == \"(\" {\n            parenthesis_stack.append(String(c))\n\
    \        } else {\n            if parenthesis_stack.count == 0 {\n           \
    \     return string_bad\n            }\n            if parenthesis_stack.last\
    \ == \"(\" {\n                parenthesis_stack.removeLast()\n            } else\
    \ {\n                parenthesis_stack.append(String(c))\n            }\n    \
    \    }\n        cnt += 1\n    }\n    if is_good(str: parenthesis_stack.joined())\
    \ {\n        return string_good\n    }\n    return string_bad\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(match_parens(lst: [\"()(\", \")\"]) == \"Yes\")\nassert(match_parens(lst:\
    \ [\")\", \")\"]) == \"No\")\nassert(match_parens(lst: [\"(()(())\", \"())())\"\
    ]) == \"No\")\nassert(match_parens(lst: [\")())\", \"(()()(\"]) == \"Yes\")\n\
    assert(match_parens(lst: [\"(())))\", \"(()())((\"]) == \"Yes\")\nassert(match_parens(lst:\
    \ [\"()\", \"())\"]) == \"No\")\nassert(match_parens(lst: [\"(()(\", \"()))()\"\
    ]) == \"Yes\")\nassert(match_parens(lst: [\"((((\", \"((())\"]) == \"No\")\nassert(match_parens(lst:\
    \ [\")(()\", \"(()(\"]) == \"No\")\nassert(match_parens(lst: [\")(\", \")(\"])\
    \ == \"No\")\nassert(match_parens(lst: [\"(\", \")\"]) == \"Yes\")\nassert(match_parens(lst:\
    \ [\")\", \"(\"]) == \"Yes\")"
  status: SyntaxError
  stderr: "/tmp/tmp4jxi54el.swift:20:9: error: cannot find 'is_good' in scope\n  \
    \  if !is_good(str: str1) && !is_good(str: str2) {\n        ^~~~~~~\n/tmp/tmp4jxi54el.swift:20:32:\
    \ error: cannot find 'is_good' in scope\n    if !is_good(str: str1) && !is_good(str:\
    \ str2) {\n                               ^~~~~~~\n/tmp/tmp4jxi54el.swift:43:8:\
    \ error: cannot find 'is_good' in scope\n    if is_good(str: parenthesis_stack.joined())\
    \ {\n       ^~~~~~~\n"
  stdout: ''
  timestamp: 1659979533
- exit_code: -4
  program: "\n/// You are given an array of two strings, both strings consist of open\n\
    /// parentheses '(' or close parentheses ')' only.\n/// Your job is to check if\
    \ it is possible to concatenate the two strings in\n/// some order, that the resulting\
    \ string will be good.\n/// A string S is considered to be good if and only if\
    \ all parentheses in S\n/// are balanced. For example: the string '(())()' is\
    \ good, while the string\n/// '())' is not.\n/// Return 'Yes' if there's a way\
    \ to make a good string, and return 'No' otherwise.\n/// Examples:\n/// >>> match_parens(lst:\
    \ [\"()(\", \")\"])\n/// \"Yes\"\n/// >>> match_parens(lst: [\")\", \")\"])\n\
    /// \"No\"\nfunc match_parens(lst: [String]) -> String {\n    var balance: Int\
    \ = 0\n    var result: String = \"Yes\"\n    for c in lst[0] {\n        if c ==\
    \ \"(\" {\n            balance += 1\n        } else {\n            balance -=\
    \ 1\n        }\n        if balance < 0 {\n            result = \"No\"\n      \
    \      break\n        }\n    }\n    for c in lst[1] {\n        if c == \"(\" {\n\
    \            balance += 1\n        } else {\n            balance -= 1\n      \
    \  }\n        if balance < 0 {\n            result = \"No\"\n            break\n\
    \        }\n    }\n    if balance != 0 {\n        result = \"No\"\n    }\n   \
    \ return result\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool\
    \ {\n    if left.count != right.count {\n        return false\n    }\n    for\
    \ (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(match_parens(lst:\
    \ [\"()(\", \")\"]) == \"Yes\")\nassert(match_parens(lst: [\")\", \")\"]) == \"\
    No\")\nassert(match_parens(lst: [\"(()(())\", \"())())\"]) == \"No\")\nassert(match_parens(lst:\
    \ [\")())\", \"(()()(\"]) == \"Yes\")\nassert(match_parens(lst: [\"(())))\", \"\
    (()())((\"]) == \"Yes\")\nassert(match_parens(lst: [\"()\", \"())\"]) == \"No\"\
    )\nassert(match_parens(lst: [\"(()(\", \"()))()\"]) == \"Yes\")\nassert(match_parens(lst:\
    \ [\"((((\", \"((())\"]) == \"No\")\nassert(match_parens(lst: [\")(()\", \"(()(\"\
    ]) == \"No\")\nassert(match_parens(lst: [\")(\", \")(\"]) == \"No\")\nassert(match_parens(lst:\
    \ [\"(\", \")\"]) == \"Yes\")\nassert(match_parens(lst: [\")\", \"(\"]) == \"\
    Yes\")"
  status: Exception
  stderr: 'tmpi_47o2b8/tmpi_47o2b8.swift:62: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002aed9735dc80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002aed97054b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002aed97054988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002aed970537b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpi_47o2b8                        0x00005627474b4b26 <unavailable> + 6950

    5    libc.so.6                          0x00002aed97549460 __libc_start_main +
    245

    6    tmpi_47o2b8                        0x00005627474b4289 <unavailable> + 4745

    '
  stdout: ''
  timestamp: 1659979533
- exit_code: 1
  program: "\n/// You are given an array of two strings, both strings consist of open\n\
    /// parentheses '(' or close parentheses ')' only.\n/// Your job is to check if\
    \ it is possible to concatenate the two strings in\n/// some order, that the resulting\
    \ string will be good.\n/// A string S is considered to be good if and only if\
    \ all parentheses in S\n/// are balanced. For example: the string '(())()' is\
    \ good, while the string\n/// '())' is not.\n/// Return 'Yes' if there's a way\
    \ to make a good string, and return 'No' otherwise.\n/// Examples:\n/// >>> match_parens(lst:\
    \ [\"()(\", \")\"])\n/// \"Yes\"\n/// >>> match_parens(lst: [\")\", \")\"])\n\
    /// \"No\"\nfunc match_parens(lst: [String]) -> String {\n    let item1 = lst[0].components(separatedBy:\
    \ \"(\").count - 1\n    let item2 = lst[1].components(separatedBy: \")\").count\
    \ - 1\n    if item1 == item2 {\n        return \"Yes\"\n    }\n    return \"No\"\
    \n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(match_parens(lst: [\"()(\", \")\"]) == \"Yes\"\
    )\nassert(match_parens(lst: [\")\", \")\"]) == \"No\")\nassert(match_parens(lst:\
    \ [\"(()(())\", \"())())\"]) == \"No\")\nassert(match_parens(lst: [\")())\", \"\
    (()()(\"]) == \"Yes\")\nassert(match_parens(lst: [\"(())))\", \"(()())((\"]) ==\
    \ \"Yes\")\nassert(match_parens(lst: [\"()\", \"())\"]) == \"No\")\nassert(match_parens(lst:\
    \ [\"(()(\", \"()))()\"]) == \"Yes\")\nassert(match_parens(lst: [\"((((\", \"\
    ((())\"]) == \"No\")\nassert(match_parens(lst: [\")(()\", \"(()(\"]) == \"No\"\
    )\nassert(match_parens(lst: [\")(\", \")(\"]) == \"No\")\nassert(match_parens(lst:\
    \ [\"(\", \")\"]) == \"Yes\")\nassert(match_parens(lst: [\")\", \"(\"]) == \"\
    Yes\")"
  status: SyntaxError
  stderr: "/tmp/tmpcxbm8clk.swift:16:24: error: value of type 'String' has no member\
    \ 'components'\n    let item1 = lst[0].components(separatedBy: \"(\").count -\
    \ 1\n                ~~~~~~ ^~~~~~~~~~\n/tmp/tmpcxbm8clk.swift:17:24: error: value\
    \ of type 'String' has no member 'components'\n    let item2 = lst[1].components(separatedBy:\
    \ \")\").count - 1\n                ~~~~~~ ^~~~~~~~~~\n"
  stdout: ''
  timestamp: 1659979533
- exit_code: -4
  program: "\n/// You are given an array of two strings, both strings consist of open\n\
    /// parentheses '(' or close parentheses ')' only.\n/// Your job is to check if\
    \ it is possible to concatenate the two strings in\n/// some order, that the resulting\
    \ string will be good.\n/// A string S is considered to be good if and only if\
    \ all parentheses in S\n/// are balanced. For example: the string '(())()' is\
    \ good, while the string\n/// '())' is not.\n/// Return 'Yes' if there's a way\
    \ to make a good string, and return 'No' otherwise.\n/// Examples:\n/// >>> match_parens(lst:\
    \ [\"()(\", \")\"])\n/// \"Yes\"\n/// >>> match_parens(lst: [\")\", \")\"])\n\
    /// \"No\"\nfunc match_parens(lst: [String]) -> String {\n    var str1 = lst[0]\n\
    \    var str2 = lst[1]\n    var is_bad = false\n    while !is_bad && !str1.isEmpty\
    \ && !str2.isEmpty {\n        if str1.last! == \"(\" && str2.first! == \")\" {\n\
    \            str1.removeLast()\n            str2.removeFirst()\n        } else\
    \ if str1.last! == \")\" && str2.first! == \"(\" {\n            str1.removeLast()\n\
    \            str2.removeFirst()\n        } else if str1.last! == \"(\" && str2.first!\
    \ == \"(\" {\n            str1.removeLast()\n            str2.removeFirst()\n\
    \        } else if str1.last! == \")\" && str2.first! == \")\" {\n           \
    \ str1.removeLast()\n            str2.removeFirst()\n        } else {\n      \
    \      is_bad = true\n        }\n    }\n    return is_bad ? \"No\" : \"Yes\"\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(match_parens(lst: [\"()(\", \")\"]) == \"Yes\"\
    )\nassert(match_parens(lst: [\")\", \")\"]) == \"No\")\nassert(match_parens(lst:\
    \ [\"(()(())\", \"())())\"]) == \"No\")\nassert(match_parens(lst: [\")())\", \"\
    (()()(\"]) == \"Yes\")\nassert(match_parens(lst: [\"(())))\", \"(()())((\"]) ==\
    \ \"Yes\")\nassert(match_parens(lst: [\"()\", \"())\"]) == \"No\")\nassert(match_parens(lst:\
    \ [\"(()(\", \"()))()\"]) == \"Yes\")\nassert(match_parens(lst: [\"((((\", \"\
    ((())\"]) == \"No\")\nassert(match_parens(lst: [\")(()\", \"(()(\"]) == \"No\"\
    )\nassert(match_parens(lst: [\")(\", \")(\"]) == \"No\")\nassert(match_parens(lst:\
    \ [\"(\", \")\"]) == \"Yes\")\nassert(match_parens(lst: [\")\", \"(\"]) == \"\
    Yes\")"
  status: Exception
  stderr: 'tmpw1ukh0z0/tmpw1ukh0z0.swift:53: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b01c5e77c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b01c5b6eb6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b01c5b6e988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b01c5b6d7b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpw1ukh0z0                        0x000055cc1805da70 <unavailable> + 6768

    5    libc.so.6                          0x00002b01c6063460 __libc_start_main +
    245

    6    tmpw1ukh0z0                        0x000055cc1805d4e9 <unavailable> + 5353

    '
  stdout: ''
  timestamp: 1659979533
- exit_code: -4
  program: "\n/// You are given an array of two strings, both strings consist of open\n\
    /// parentheses '(' or close parentheses ')' only.\n/// Your job is to check if\
    \ it is possible to concatenate the two strings in\n/// some order, that the resulting\
    \ string will be good.\n/// A string S is considered to be good if and only if\
    \ all parentheses in S\n/// are balanced. For example: the string '(())()' is\
    \ good, while the string\n/// '())' is not.\n/// Return 'Yes' if there's a way\
    \ to make a good string, and return 'No' otherwise.\n/// Examples:\n/// >>> match_parens(lst:\
    \ [\"()(\", \")\"])\n/// \"Yes\"\n/// >>> match_parens(lst: [\")\", \")\"])\n\
    /// \"No\"\nfunc match_parens(lst: [String]) -> String {\n  var lhs = 0\n  var\
    \ rhs = 0\n  for i in lst[0] {\n    if i == \"(\" {\n      lhs += 1\n    } else\
    \ {\n      lhs -= 1\n    }\n  }\n  for i in lst[1] {\n    if i == \"(\" {\n  \
    \    rhs += 1\n    } else {\n      rhs -= 1\n    }\n  }\n  let result = lhs +\
    \ rhs\n  if result == 0 {\n    return \"Yes\"\n  } else {\n    return \"No\"\n\
    \  }\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if\
    \ left.count != right.count {\n        return false\n    }\n    for (l, r) in\
    \ zip(left, right) {\n        if l != r {\n            return false\n        }\n\
    \    }\n    return true\n}\n            \nassert(match_parens(lst: [\"()(\", \"\
    )\"]) == \"Yes\")\nassert(match_parens(lst: [\")\", \")\"]) == \"No\")\nassert(match_parens(lst:\
    \ [\"(()(())\", \"())())\"]) == \"No\")\nassert(match_parens(lst: [\")())\", \"\
    (()()(\"]) == \"Yes\")\nassert(match_parens(lst: [\"(())))\", \"(()())((\"]) ==\
    \ \"Yes\")\nassert(match_parens(lst: [\"()\", \"())\"]) == \"No\")\nassert(match_parens(lst:\
    \ [\"(()(\", \"()))()\"]) == \"Yes\")\nassert(match_parens(lst: [\"((((\", \"\
    ((())\"]) == \"No\")\nassert(match_parens(lst: [\")(()\", \"(()(\"]) == \"No\"\
    )\nassert(match_parens(lst: [\")(\", \")(\"]) == \"No\")\nassert(match_parens(lst:\
    \ [\"(\", \")\"]) == \"Yes\")\nassert(match_parens(lst: [\")\", \"(\"]) == \"\
    Yes\")"
  status: Exception
  stderr: 'tmp55xp_4wg/tmp55xp_4wg.swift:62: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b7606a22c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b7606719b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b7606719988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b76067187b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmp55xp_4wg                        0x00005592497f2468 <unavailable> + 9320

    5    libc.so.6                          0x00002b7606c0e460 __libc_start_main +
    245

    6    tmp55xp_4wg                        0x00005592497f1289 <unavailable> + 4745

    '
  stdout: ''
  timestamp: 1659979533
- exit_code: 1
  program: "\n/// You are given an array of two strings, both strings consist of open\n\
    /// parentheses '(' or close parentheses ')' only.\n/// Your job is to check if\
    \ it is possible to concatenate the two strings in\n/// some order, that the resulting\
    \ string will be good.\n/// A string S is considered to be good if and only if\
    \ all parentheses in S\n/// are balanced. For example: the string '(())()' is\
    \ good, while the string\n/// '())' is not.\n/// Return 'Yes' if there's a way\
    \ to make a good string, and return 'No' otherwise.\n/// Examples:\n/// >>> match_parens(lst:\
    \ [\"()(\", \")\"])\n/// \"Yes\"\n/// >>> match_parens(lst: [\")\", \")\"])\n\
    /// \"No\"\nfunc match_parens(lst: [String]) -> String {\n    let str1 = lst[0]\n\
    \    let str2 = lst[1]\n    return is_good(str: str1 + str2) || is_good(str: str2\
    \ + str1) ? \"Yes\" : \"No\"\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int,\
    \ Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n\
    \    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n          \
    \  return false\n        }\n    }\n    return true\n}\n            \nassert(match_parens(lst:\
    \ [\"()(\", \")\"]) == \"Yes\")\nassert(match_parens(lst: [\")\", \")\"]) == \"\
    No\")\nassert(match_parens(lst: [\"(()(())\", \"())())\"]) == \"No\")\nassert(match_parens(lst:\
    \ [\")())\", \"(()()(\"]) == \"Yes\")\nassert(match_parens(lst: [\"(())))\", \"\
    (()())((\"]) == \"Yes\")\nassert(match_parens(lst: [\"()\", \"())\"]) == \"No\"\
    )\nassert(match_parens(lst: [\"(()(\", \"()))()\"]) == \"Yes\")\nassert(match_parens(lst:\
    \ [\"((((\", \"((())\"]) == \"No\")\nassert(match_parens(lst: [\")(()\", \"(()(\"\
    ]) == \"No\")\nassert(match_parens(lst: [\")(\", \")(\"]) == \"No\")\nassert(match_parens(lst:\
    \ [\"(\", \")\"]) == \"Yes\")\nassert(match_parens(lst: [\")\", \"(\"]) == \"\
    Yes\")"
  status: SyntaxError
  stderr: "/tmp/tmpz93vbjzn.swift:18:12: error: cannot find 'is_good' in scope\n \
    \   return is_good(str: str1 + str2) || is_good(str: str2 + str1) ? \"Yes\" :\
    \ \"No\"\n           ^~~~~~~\n/tmp/tmpz93vbjzn.swift:18:41: error: cannot find\
    \ 'is_good' in scope\n    return is_good(str: str1 + str2) || is_good(str: str2\
    \ + str1) ? \"Yes\" : \"No\"\n                                        ^~~~~~~\n"
  stdout: ''
  timestamp: 1659979533
- exit_code: -4
  program: "\n/// You are given an array of two strings, both strings consist of open\n\
    /// parentheses '(' or close parentheses ')' only.\n/// Your job is to check if\
    \ it is possible to concatenate the two strings in\n/// some order, that the resulting\
    \ string will be good.\n/// A string S is considered to be good if and only if\
    \ all parentheses in S\n/// are balanced. For example: the string '(())()' is\
    \ good, while the string\n/// '())' is not.\n/// Return 'Yes' if there's a way\
    \ to make a good string, and return 'No' otherwise.\n/// Examples:\n/// >>> match_parens(lst:\
    \ [\"()(\", \")\"])\n/// \"Yes\"\n/// >>> match_parens(lst: [\")\", \")\"])\n\
    /// \"No\"\nfunc match_parens(lst: [String]) -> String {\n    var total_parens\
    \ = 0\n    var index = 0\n    var s = \"\"\n    for _ in 0...1 {\n        for\
    \ paren in lst[index] {\n            if paren == \"(\" {\n                total_parens\
    \ += 1\n            } else {\n                total_parens -= 1\n            }\n\
    \            if total_parens < 0 {\n                s = \"No\"\n             \
    \   break\n            }\n        }\n        if total_parens == 0 {\n        \
    \    s = \"Yes\"\n        }\n        index += 1\n    }\n    return s\n}\n\n\n\
    func ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(match_parens(lst: [\"()(\", \")\"]) == \"Yes\"\
    )\nassert(match_parens(lst: [\")\", \")\"]) == \"No\")\nassert(match_parens(lst:\
    \ [\"(()(())\", \"())())\"]) == \"No\")\nassert(match_parens(lst: [\")())\", \"\
    (()()(\"]) == \"Yes\")\nassert(match_parens(lst: [\"(())))\", \"(()())((\"]) ==\
    \ \"Yes\")\nassert(match_parens(lst: [\"()\", \"())\"]) == \"No\")\nassert(match_parens(lst:\
    \ [\"(()(\", \"()))()\"]) == \"Yes\")\nassert(match_parens(lst: [\"((((\", \"\
    ((())\"]) == \"No\")\nassert(match_parens(lst: [\")(()\", \"(()(\"]) == \"No\"\
    )\nassert(match_parens(lst: [\")(\", \")(\"]) == \"No\")\nassert(match_parens(lst:\
    \ [\"(\", \")\"]) == \"Yes\")\nassert(match_parens(lst: [\")\", \"(\"]) == \"\
    Yes\")"
  status: Exception
  stderr: 'tmp0jyxygtv/tmp0jyxygtv.swift:55: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002aea46a11c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002aea46708b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002aea46708988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002aea467077b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmp0jyxygtv                        0x00005555dedb1c16 <unavailable> + 7190

    5    libc.so.6                          0x00002aea46bfd460 __libc_start_main +
    245

    6    tmp0jyxygtv                        0x00005555dedb1379 <unavailable> + 4985

    '
  stdout: ''
  timestamp: 1659979533
- exit_code: 1
  program: "\n/// You are given an array of two strings, both strings consist of open\n\
    /// parentheses '(' or close parentheses ')' only.\n/// Your job is to check if\
    \ it is possible to concatenate the two strings in\n/// some order, that the resulting\
    \ string will be good.\n/// A string S is considered to be good if and only if\
    \ all parentheses in S\n/// are balanced. For example: the string '(())()' is\
    \ good, while the string\n/// '())' is not.\n/// Return 'Yes' if there's a way\
    \ to make a good string, and return 'No' otherwise.\n/// Examples:\n/// >>> match_parens(lst:\
    \ [\"()(\", \")\"])\n/// \"Yes\"\n/// >>> match_parens(lst: [\")\", \")\"])\n\
    /// \"No\"\nfunc match_parens(lst: [String]) -> String {\n    var l = lst[0]\n\
    \    var r = lst[1]\n    if l.starts(with: \")\") && r.starts(with: \")\") {\n\
    \        return \"No\"\n    }\n    let balanced = balance(string: l + r)\n   \
    \ if balanced.isEmpty {\n        return \"Yes\"\n    }\n    let balanced_left\
    \ = balance(string: l)\n    let balanced_right = balance(string: r)\n    if balanced_left.isEmpty\
    \ && balanced_right.isEmpty {\n        return \"Yes\"\n    }\n    return \"No\"\
    \n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(match_parens(lst: [\"()(\", \")\"]) == \"Yes\"\
    )\nassert(match_parens(lst: [\")\", \")\"]) == \"No\")\nassert(match_parens(lst:\
    \ [\"(()(())\", \"())())\"]) == \"No\")\nassert(match_parens(lst: [\")())\", \"\
    (()()(\"]) == \"Yes\")\nassert(match_parens(lst: [\"(())))\", \"(()())((\"]) ==\
    \ \"Yes\")\nassert(match_parens(lst: [\"()\", \"())\"]) == \"No\")\nassert(match_parens(lst:\
    \ [\"(()(\", \"()))()\"]) == \"Yes\")\nassert(match_parens(lst: [\"((((\", \"\
    ((())\"]) == \"No\")\nassert(match_parens(lst: [\")(()\", \"(()(\"]) == \"No\"\
    )\nassert(match_parens(lst: [\")(\", \")(\"]) == \"No\")\nassert(match_parens(lst:\
    \ [\"(\", \")\"]) == \"Yes\")\nassert(match_parens(lst: [\")\", \"(\"]) == \"\
    Yes\")"
  status: SyntaxError
  stderr: "/tmp/tmpnw7oo9xi.swift:21:20: error: cannot find 'balance' in scope\n \
    \   let balanced = balance(string: l + r)\n                   ^~~~~~~\n/tmp/tmpnw7oo9xi.swift:25:25:\
    \ error: cannot find 'balance' in scope\n    let balanced_left = balance(string:\
    \ l)\n                        ^~~~~~~\n/tmp/tmpnw7oo9xi.swift:26:26: error: cannot\
    \ find 'balance' in scope\n    let balanced_right = balance(string: r)\n     \
    \                    ^~~~~~~\n"
  stdout: ''
  timestamp: 1659979533
- exit_code: 1
  program: "\n/// You are given an array of two strings, both strings consist of open\n\
    /// parentheses '(' or close parentheses ')' only.\n/// Your job is to check if\
    \ it is possible to concatenate the two strings in\n/// some order, that the resulting\
    \ string will be good.\n/// A string S is considered to be good if and only if\
    \ all parentheses in S\n/// are balanced. For example: the string '(())()' is\
    \ good, while the string\n/// '())' is not.\n/// Return 'Yes' if there's a way\
    \ to make a good string, and return 'No' otherwise.\n/// Examples:\n/// >>> match_parens(lst:\
    \ [\"()(\", \")\"])\n/// \"Yes\"\n/// >>> match_parens(lst: [\")\", \")\"])\n\
    /// \"No\"\nfunc match_parens(lst: [String]) -> String {\n    var s = lst[0] +\
    \ lst[1]\n    for _ in 0...s.count {\n        s = s.replacingOccurrences(of: \"\
    ()\", with: \"\")\n    }\n    return s.isEmpty ? \"Yes\" : \"No\"\n}\n\n\nfunc\
    \ ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count !=\
    \ right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(match_parens(lst: [\"()(\", \")\"]) == \"Yes\"\
    )\nassert(match_parens(lst: [\")\", \")\"]) == \"No\")\nassert(match_parens(lst:\
    \ [\"(()(())\", \"())())\"]) == \"No\")\nassert(match_parens(lst: [\")())\", \"\
    (()()(\"]) == \"Yes\")\nassert(match_parens(lst: [\"(())))\", \"(()())((\"]) ==\
    \ \"Yes\")\nassert(match_parens(lst: [\"()\", \"())\"]) == \"No\")\nassert(match_parens(lst:\
    \ [\"(()(\", \"()))()\"]) == \"Yes\")\nassert(match_parens(lst: [\"((((\", \"\
    ((())\"]) == \"No\")\nassert(match_parens(lst: [\")(()\", \"(()(\"]) == \"No\"\
    )\nassert(match_parens(lst: [\")(\", \")(\"]) == \"No\")\nassert(match_parens(lst:\
    \ [\"(\", \")\"]) == \"Yes\")\nassert(match_parens(lst: [\")\", \"(\"]) == \"\
    Yes\")"
  status: SyntaxError
  stderr: "/tmp/tmp1nblpmhu.swift:18:15: error: value of type 'String' has no member\
    \ 'replacingOccurrences'\n        s = s.replacingOccurrences(of: \"()\", with:\
    \ \"\")\n            ~ ^~~~~~~~~~~~~~~~~~~~\n"
  stdout: ''
  timestamp: 1659979533
- exit_code: -4
  program: "\n/// You are given an array of two strings, both strings consist of open\n\
    /// parentheses '(' or close parentheses ')' only.\n/// Your job is to check if\
    \ it is possible to concatenate the two strings in\n/// some order, that the resulting\
    \ string will be good.\n/// A string S is considered to be good if and only if\
    \ all parentheses in S\n/// are balanced. For example: the string '(())()' is\
    \ good, while the string\n/// '())' is not.\n/// Return 'Yes' if there's a way\
    \ to make a good string, and return 'No' otherwise.\n/// Examples:\n/// >>> match_parens(lst:\
    \ [\"()(\", \")\"])\n/// \"Yes\"\n/// >>> match_parens(lst: [\")\", \")\"])\n\
    /// \"No\"\nfunc match_parens(lst: [String]) -> String {\n    let n1 = lst[0].count\n\
    \    let n2 = lst[1].count\n    var count1 = 0\n    var count2 = 0\n    var count3\
    \ = 0\n    var count4 = 0\n    var total = 0\n    for c in lst[0] {\n        if\
    \ c == \"(\" {\n            count1 += 1\n        } else {\n            count2\
    \ += 1\n        }\n    }\n    for c in lst[1] {\n        if c == \"(\" {\n   \
    \         count3 += 1\n        } else {\n            count4 += 1\n        }\n\
    \    }\n    total = count1 + count3\n    if total % 2 == 0 {\n        if count2\
    \ == 0 && count4 == 0 {\n            return \"Yes\"\n        } else if count2\
    \ == count4 {\n            return \"Yes\"\n        } else {\n            return\
    \ \"No\"\n        }\n    } else {\n        return \"No\"\n    }\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(match_parens(lst: [\"()(\", \")\"]) == \"Yes\")\nassert(match_parens(lst:\
    \ [\")\", \")\"]) == \"No\")\nassert(match_parens(lst: [\"(()(())\", \"())())\"\
    ]) == \"No\")\nassert(match_parens(lst: [\")())\", \"(()()(\"]) == \"Yes\")\n\
    assert(match_parens(lst: [\"(())))\", \"(()())((\"]) == \"Yes\")\nassert(match_parens(lst:\
    \ [\"()\", \"())\"]) == \"No\")\nassert(match_parens(lst: [\"(()(\", \"()))()\"\
    ]) == \"Yes\")\nassert(match_parens(lst: [\"((((\", \"((())\"]) == \"No\")\nassert(match_parens(lst:\
    \ [\")(()\", \"(()(\"]) == \"No\")\nassert(match_parens(lst: [\")(\", \")(\"])\
    \ == \"No\")\nassert(match_parens(lst: [\"(\", \")\"]) == \"Yes\")\nassert(match_parens(lst:\
    \ [\")\", \"(\"]) == \"Yes\")"
  status: Exception
  stderr: 'tmpwc7cxlcj/tmpwc7cxlcj.swift:65: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002aae8c39bc80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002aae8c092b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002aae8c092988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002aae8c0917b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpwc7cxlcj                        0x00005583349188f0 <unavailable> + 6384

    5    libc.so.6                          0x00002aae8c587460 __libc_start_main +
    245

    6    tmpwc7cxlcj                        0x0000558334918369 <unavailable> + 4969

    '
  stdout: ''
  timestamp: 1659979533
- exit_code: -4
  program: "\n/// You are given an array of two strings, both strings consist of open\n\
    /// parentheses '(' or close parentheses ')' only.\n/// Your job is to check if\
    \ it is possible to concatenate the two strings in\n/// some order, that the resulting\
    \ string will be good.\n/// A string S is considered to be good if and only if\
    \ all parentheses in S\n/// are balanced. For example: the string '(())()' is\
    \ good, while the string\n/// '())' is not.\n/// Return 'Yes' if there's a way\
    \ to make a good string, and return 'No' otherwise.\n/// Examples:\n/// >>> match_parens(lst:\
    \ [\"()(\", \")\"])\n/// \"Yes\"\n/// >>> match_parens(lst: [\")\", \")\"])\n\
    /// \"No\"\nfunc match_parens(lst: [String]) -> String {\n    let matchingString\
    \ = lst.reduce(\"\", +)\n    var openCount = 0\n    var closeCount = 0\n    matchingString.forEach\
    \ {\n        if $0 == \"(\" {\n            openCount += 1\n        } else {\n\
    \            closeCount += 1\n        }\n    }\n    if (openCount + closeCount)\
    \ % 2 != 0 {\n        return \"No\"\n    }\n    if openCount == closeCount {\n\
    \        return \"Yes\"\n    }\n    return \"No\"\n}\n\n\nfunc ==(left: [(Int,\
    \ Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n\
    \        return false\n    }\n    for (l, r) in zip(left, right) {\n        if\
    \ l != r {\n            return false\n        }\n    }\n    return true\n}\n \
    \           \nassert(match_parens(lst: [\"()(\", \")\"]) == \"Yes\")\nassert(match_parens(lst:\
    \ [\")\", \")\"]) == \"No\")\nassert(match_parens(lst: [\"(()(())\", \"())())\"\
    ]) == \"No\")\nassert(match_parens(lst: [\")())\", \"(()()(\"]) == \"Yes\")\n\
    assert(match_parens(lst: [\"(())))\", \"(()())((\"]) == \"Yes\")\nassert(match_parens(lst:\
    \ [\"()\", \"())\"]) == \"No\")\nassert(match_parens(lst: [\"(()(\", \"()))()\"\
    ]) == \"Yes\")\nassert(match_parens(lst: [\"((((\", \"((())\"]) == \"No\")\nassert(match_parens(lst:\
    \ [\")(()\", \"(()(\"]) == \"No\")\nassert(match_parens(lst: [\")(\", \")(\"])\
    \ == \"No\")\nassert(match_parens(lst: [\"(\", \")\"]) == \"Yes\")\nassert(match_parens(lst:\
    \ [\")\", \"(\"]) == \"Yes\")"
  status: Exception
  stderr: 'tmp6sh_n2yw/tmp6sh_n2yw.swift:57: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b22240e6c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b2223dddb6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b2223ddd988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b2223ddc7b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmp6sh_n2yw                        0x0000555a35ad3548 <unavailable> + 9544

    5    libc.so.6                          0x00002b22242d2460 __libc_start_main +
    245

    6    tmp6sh_n2yw                        0x0000555a35ad2369 <unavailable> + 4969

    '
  stdout: ''
  timestamp: 1659979533
- exit_code: -4
  program: "\n/// You are given an array of two strings, both strings consist of open\n\
    /// parentheses '(' or close parentheses ')' only.\n/// Your job is to check if\
    \ it is possible to concatenate the two strings in\n/// some order, that the resulting\
    \ string will be good.\n/// A string S is considered to be good if and only if\
    \ all parentheses in S\n/// are balanced. For example: the string '(())()' is\
    \ good, while the string\n/// '())' is not.\n/// Return 'Yes' if there's a way\
    \ to make a good string, and return 'No' otherwise.\n/// Examples:\n/// >>> match_parens(lst:\
    \ [\"()(\", \")\"])\n/// \"Yes\"\n/// >>> match_parens(lst: [\")\", \")\"])\n\
    /// \"No\"\nfunc match_parens(lst: [String]) -> String {\n    let lst = lst.joined()\n\
    \    var cnt = 0\n    for c in lst {\n        if c == \"(\" {\n            cnt\
    \ += 1\n        } else {\n            cnt -= 1\n        }\n        if cnt < 0\
    \ {\n            return \"No\"\n        }\n    }\n    return cnt == 0 ? \"Yes\"\
    \ : \"No\"\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n\
    \    if left.count != right.count {\n        return false\n    }\n    for (l,\
    \ r) in zip(left, right) {\n        if l != r {\n            return false\n  \
    \      }\n    }\n    return true\n}\n            \nassert(match_parens(lst: [\"\
    ()(\", \")\"]) == \"Yes\")\nassert(match_parens(lst: [\")\", \")\"]) == \"No\"\
    )\nassert(match_parens(lst: [\"(()(())\", \"())())\"]) == \"No\")\nassert(match_parens(lst:\
    \ [\")())\", \"(()()(\"]) == \"Yes\")\nassert(match_parens(lst: [\"(())))\", \"\
    (()())((\"]) == \"Yes\")\nassert(match_parens(lst: [\"()\", \"())\"]) == \"No\"\
    )\nassert(match_parens(lst: [\"(()(\", \"()))()\"]) == \"Yes\")\nassert(match_parens(lst:\
    \ [\"((((\", \"((())\"]) == \"No\")\nassert(match_parens(lst: [\")(()\", \"(()(\"\
    ]) == \"No\")\nassert(match_parens(lst: [\")(\", \")(\"]) == \"No\")\nassert(match_parens(lst:\
    \ [\"(\", \")\"]) == \"Yes\")\nassert(match_parens(lst: [\")\", \"(\"]) == \"\
    Yes\")"
  status: Exception
  stderr: 'tmp9y279gj2/tmp9y279gj2.swift:47: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b5a96420c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b5a96117b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b5a96117988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b5a961167b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmp9y279gj2                        0x0000557b9ae35b76 <unavailable> + 7030

    5    libc.so.6                          0x00002b5a9660c460 __libc_start_main +
    245

    6    tmp9y279gj2                        0x0000557b9ae352d9 <unavailable> + 4825

    '
  stdout: ''
  timestamp: 1659979533
- exit_code: 1
  program: "\n/// You are given an array of two strings, both strings consist of open\n\
    /// parentheses '(' or close parentheses ')' only.\n/// Your job is to check if\
    \ it is possible to concatenate the two strings in\n/// some order, that the resulting\
    \ string will be good.\n/// A string S is considered to be good if and only if\
    \ all parentheses in S\n/// are balanced. For example: the string '(())()' is\
    \ good, while the string\n/// '())' is not.\n/// Return 'Yes' if there's a way\
    \ to make a good string, and return 'No' otherwise.\n/// Examples:\n/// >>> match_parens(lst:\
    \ [\"()(\", \")\"])\n/// \"Yes\"\n/// >>> match_parens(lst: [\")\", \")\"])\n\
    /// \"No\"\nfunc match_parens(lst: [String]) -> String {\n    let s1 = lst[0]\n\
    \    let s2 = lst[1]\n    return check(s1: s1, s2: s2) ? \"Yes\" : \"No\"\n}\n\
    \n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(match_parens(lst: [\"()(\", \")\"]) == \"Yes\"\
    )\nassert(match_parens(lst: [\")\", \")\"]) == \"No\")\nassert(match_parens(lst:\
    \ [\"(()(())\", \"())())\"]) == \"No\")\nassert(match_parens(lst: [\")())\", \"\
    (()()(\"]) == \"Yes\")\nassert(match_parens(lst: [\"(())))\", \"(()())((\"]) ==\
    \ \"Yes\")\nassert(match_parens(lst: [\"()\", \"())\"]) == \"No\")\nassert(match_parens(lst:\
    \ [\"(()(\", \"()))()\"]) == \"Yes\")\nassert(match_parens(lst: [\"((((\", \"\
    ((())\"]) == \"No\")\nassert(match_parens(lst: [\")(()\", \"(()(\"]) == \"No\"\
    )\nassert(match_parens(lst: [\")(\", \")(\"]) == \"No\")\nassert(match_parens(lst:\
    \ [\"(\", \")\"]) == \"Yes\")\nassert(match_parens(lst: [\")\", \"(\"]) == \"\
    Yes\")"
  status: SyntaxError
  stderr: "/tmp/tmpqcjhnha3.swift:18:12: error: cannot find 'check' in scope\n   \
    \ return check(s1: s1, s2: s2) ? \"Yes\" : \"No\"\n           ^~~~~\n"
  stdout: ''
  timestamp: 1659979533
- exit_code: -4
  program: "\n/// You are given an array of two strings, both strings consist of open\n\
    /// parentheses '(' or close parentheses ')' only.\n/// Your job is to check if\
    \ it is possible to concatenate the two strings in\n/// some order, that the resulting\
    \ string will be good.\n/// A string S is considered to be good if and only if\
    \ all parentheses in S\n/// are balanced. For example: the string '(())()' is\
    \ good, while the string\n/// '())' is not.\n/// Return 'Yes' if there's a way\
    \ to make a good string, and return 'No' otherwise.\n/// Examples:\n/// >>> match_parens(lst:\
    \ [\"()(\", \")\"])\n/// \"Yes\"\n/// >>> match_parens(lst: [\")\", \")\"])\n\
    /// \"No\"\nfunc match_parens(lst: [String]) -> String {\n  return \"Yes\"\n}\n\
    \n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(match_parens(lst: [\"()(\", \")\"]) == \"Yes\"\
    )\nassert(match_parens(lst: [\")\", \")\"]) == \"No\")\nassert(match_parens(lst:\
    \ [\"(()(())\", \"())())\"]) == \"No\")\nassert(match_parens(lst: [\")())\", \"\
    (()()(\"]) == \"Yes\")\nassert(match_parens(lst: [\"(())))\", \"(()())((\"]) ==\
    \ \"Yes\")\nassert(match_parens(lst: [\"()\", \"())\"]) == \"No\")\nassert(match_parens(lst:\
    \ [\"(()(\", \"()))()\"]) == \"Yes\")\nassert(match_parens(lst: [\"((((\", \"\
    ((())\"]) == \"No\")\nassert(match_parens(lst: [\")(()\", \"(()(\"]) == \"No\"\
    )\nassert(match_parens(lst: [\")(\", \")(\"]) == \"No\")\nassert(match_parens(lst:\
    \ [\"(\", \")\"]) == \"Yes\")\nassert(match_parens(lst: [\")\", \"(\"]) == \"\
    Yes\")"
  status: Exception
  stderr: 'tmpwtvsz64r/tmpwtvsz64r.swift:33: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b0d693b4c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b0d690abb6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b0d690ab988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b0d690aa7b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpwtvsz64r                        0x000055cd878ad610 <unavailable> + 5648

    5    libc.so.6                          0x00002b0d695a0460 __libc_start_main +
    245

    6    tmpwtvsz64r                        0x000055cd878ad089 <unavailable> + 4233

    '
  stdout: ''
  timestamp: 1659979533
- exit_code: 1
  program: "\n/// You are given an array of two strings, both strings consist of open\n\
    /// parentheses '(' or close parentheses ')' only.\n/// Your job is to check if\
    \ it is possible to concatenate the two strings in\n/// some order, that the resulting\
    \ string will be good.\n/// A string S is considered to be good if and only if\
    \ all parentheses in S\n/// are balanced. For example: the string '(())()' is\
    \ good, while the string\n/// '())' is not.\n/// Return 'Yes' if there's a way\
    \ to make a good string, and return 'No' otherwise.\n/// Examples:\n/// >>> match_parens(lst:\
    \ [\"()(\", \")\"])\n/// \"Yes\"\n/// >>> match_parens(lst: [\")\", \")\"])\n\
    /// \"No\"\nfunc match_parens(lst: [String]) -> String {\n    let str = lst[0]\
    \ + lst[1]\n    let exp = try! NSRegularExpression(pattern: \"\\\\(\\\\)\", options:\
    \ [])\n    var matches = exp.matches(in: str, options: [], range: NSRange(location:\
    \ 0, length: str.count))\n    while !matches.isEmpty {\n        let match = matches.removeLast()\n\
    \        str.replacingCharacters(in: Range(match.range, in: str)!, with: \"\"\
    )\n        matches = exp.matches(in: str, options: [], range: NSRange(location:\
    \ 0, length: str.count))\n    }\n    let exp2 = try! NSRegularExpression(pattern:\
    \ \"\\\\(|\\\\)\", options: [])\n    let matches2 = exp2.matches(in: str, options:\
    \ [], range: NSRange(location: 0, length: str.count))\n    return matches2.isEmpty\
    \ ? \"Yes\" : \"No\"\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(match_parens(lst:\
    \ [\"()(\", \")\"]) == \"Yes\")\nassert(match_parens(lst: [\")\", \")\"]) == \"\
    No\")\nassert(match_parens(lst: [\"(()(())\", \"())())\"]) == \"No\")\nassert(match_parens(lst:\
    \ [\")())\", \"(()()(\"]) == \"Yes\")\nassert(match_parens(lst: [\"(())))\", \"\
    (()())((\"]) == \"Yes\")\nassert(match_parens(lst: [\"()\", \"())\"]) == \"No\"\
    )\nassert(match_parens(lst: [\"(()(\", \"()))()\"]) == \"Yes\")\nassert(match_parens(lst:\
    \ [\"((((\", \"((())\"]) == \"No\")\nassert(match_parens(lst: [\")(()\", \"(()(\"\
    ]) == \"No\")\nassert(match_parens(lst: [\")(\", \")(\"]) == \"No\")\nassert(match_parens(lst:\
    \ [\"(\", \")\"]) == \"Yes\")\nassert(match_parens(lst: [\")\", \"(\"]) == \"\
    Yes\")"
  status: SyntaxError
  stderr: "/tmp/tmpvvn6bz7m.swift:17:20: error: cannot find 'NSRegularExpression'\
    \ in scope\n    let exp = try! NSRegularExpression(pattern: \"\\\\(\\\\)\", options:\
    \ [])\n                   ^~~~~~~~~~~~~~~~~~~\n/tmp/tmpvvn6bz7m.swift:18:60: error:\
    \ cannot find 'NSRange' in scope\n    var matches = exp.matches(in: str, options:\
    \ [], range: NSRange(location: 0, length: str.count))\n                      \
    \                                     ^~~~~~~\n/tmp/tmpvvn6bz7m.swift:21:13: error:\
    \ value of type 'String' has no member 'replacingCharacters'\n        str.replacingCharacters(in:\
    \ Range(match.range, in: str)!, with: \"\")\n        ~~~ ^~~~~~~~~~~~~~~~~~~\n\
    /tmp/tmpvvn6bz7m.swift:21:42: error: initializer expects a single parameter of\
    \ type '(lower: Bound, upper: Bound)' [with Bound = Bound]\n        str.replacingCharacters(in:\
    \ Range(match.range, in: str)!, with: \"\")\n                                \
    \         ^~~~~~~~~~~~~~~~~~~~~~\n                                          (\
    \                   )\n/tmp/tmpvvn6bz7m.swift:21:49: error: cannot convert value\
    \ of type '(_, in: String)' to expected argument type '(lower: Bound, upper: Bound)'\n\
    \        str.replacingCharacters(in: Range(match.range, in: str)!, with: \"\"\
    )\n                                                ^\n/tmp/tmpvvn6bz7m.swift:21:37:\
    \ error: generic parameter 'Bound' could not be inferred\n        str.replacingCharacters(in:\
    \ Range(match.range, in: str)!, with: \"\")\n                                \
    \    ^\n/tmp/tmpvvn6bz7m.swift:21:37: note: explicitly specify the generic arguments\
    \ to fix this issue\n        str.replacingCharacters(in: Range(match.range, in:\
    \ str)!, with: \"\")\n                                    ^\n                \
    \                         <<#Bound: Comparable#>>\n/tmp/tmpvvn6bz7m.swift:21:64:\
    \ error: cannot force unwrap value of non-optional type 'Range<_>'\n        str.replacingCharacters(in:\
    \ Range(match.range, in: str)!, with: \"\")\n                                \
    \    ~~~~~~~~~~~~~~~~~~~~~~~~~~~^\n                                          \
    \                     \n/tmp/tmpvvn6bz7m.swift:22:60: error: ca"
  stdout: ''
  timestamp: 1659979533
- exit_code: -4
  program: "\n/// You are given an array of two strings, both strings consist of open\n\
    /// parentheses '(' or close parentheses ')' only.\n/// Your job is to check if\
    \ it is possible to concatenate the two strings in\n/// some order, that the resulting\
    \ string will be good.\n/// A string S is considered to be good if and only if\
    \ all parentheses in S\n/// are balanced. For example: the string '(())()' is\
    \ good, while the string\n/// '())' is not.\n/// Return 'Yes' if there's a way\
    \ to make a good string, and return 'No' otherwise.\n/// Examples:\n/// >>> match_parens(lst:\
    \ [\"()(\", \")\"])\n/// \"Yes\"\n/// >>> match_parens(lst: [\")\", \")\"])\n\
    /// \"No\"\nfunc match_parens(lst: [String]) -> String {\n    let s = lst[0] +\
    \ lst[1]\n    var depth = 0\n    for c in s {\n        if c == \"(\" {\n     \
    \       depth += 1\n        } else {\n            depth -= 1\n        }\n    \
    \    if depth < 0 {\n            return \"No\"\n        }\n    }\n    return depth\
    \ == 0 ? \"Yes\" : \"No\"\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(match_parens(lst:\
    \ [\"()(\", \")\"]) == \"Yes\")\nassert(match_parens(lst: [\")\", \")\"]) == \"\
    No\")\nassert(match_parens(lst: [\"(()(())\", \"())())\"]) == \"No\")\nassert(match_parens(lst:\
    \ [\")())\", \"(()()(\"]) == \"Yes\")\nassert(match_parens(lst: [\"(())))\", \"\
    (()())((\"]) == \"Yes\")\nassert(match_parens(lst: [\"()\", \"())\"]) == \"No\"\
    )\nassert(match_parens(lst: [\"(()(\", \"()))()\"]) == \"Yes\")\nassert(match_parens(lst:\
    \ [\"((((\", \"((())\"]) == \"No\")\nassert(match_parens(lst: [\")(()\", \"(()(\"\
    ]) == \"No\")\nassert(match_parens(lst: [\")(\", \")(\"]) == \"No\")\nassert(match_parens(lst:\
    \ [\"(\", \")\"]) == \"Yes\")\nassert(match_parens(lst: [\")\", \"(\"]) == \"\
    Yes\")"
  status: Exception
  stderr: 'tmpsrqh2ums/tmpsrqh2ums.swift:47: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b8943f44c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b8943c3bb6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b8943c3b988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b8943c3a7b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpsrqh2ums                        0x0000555d03de1b76 <unavailable> + 7030

    5    libc.so.6                          0x00002b8944130460 __libc_start_main +
    245

    6    tmpsrqh2ums                        0x0000555d03de12d9 <unavailable> + 4825

    '
  stdout: ''
  timestamp: 1659979533
- exit_code: 1
  program: "\n/// You are given an array of two strings, both strings consist of open\n\
    /// parentheses '(' or close parentheses ')' only.\n/// Your job is to check if\
    \ it is possible to concatenate the two strings in\n/// some order, that the resulting\
    \ string will be good.\n/// A string S is considered to be good if and only if\
    \ all parentheses in S\n/// are balanced. For example: the string '(())()' is\
    \ good, while the string\n/// '())' is not.\n/// Return 'Yes' if there's a way\
    \ to make a good string, and return 'No' otherwise.\n/// Examples:\n/// >>> match_parens(lst:\
    \ [\"()(\", \")\"])\n/// \"Yes\"\n/// >>> match_parens(lst: [\")\", \")\"])\n\
    /// \"No\"\nfunc match_parens(lst: [String]) -> String {\n    if lst.count !=\
    \ 2 {\n        return \"No\"\n    }\n    var lst_1 = lst[0]\n    var lst_2 = lst[1]\n\
    \    var lst_3 = \"\"\n    var lst_4 = \"\"\n    for _ in 0..<(lst_1.count + lst_2.count)\
    \ {\n        if lst_1.count > 0 {\n            lst_3.append(lst_1.remove(at: lst_1.startIndex))\n\
    \        }\n        if lst_2.count > 0 {\n            lst_4.append(lst_2.remove(at:\
    \ lst_2.startIndex))\n        }\n    }\n    return is_good(str: lst_3) || is_good(str:\
    \ lst_4) ? \"Yes\" : \"No\"\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int,\
    \ Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n\
    \    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n          \
    \  return false\n        }\n    }\n    return true\n}\n            \nassert(match_parens(lst:\
    \ [\"()(\", \")\"]) == \"Yes\")\nassert(match_parens(lst: [\")\", \")\"]) == \"\
    No\")\nassert(match_parens(lst: [\"(()(())\", \"())())\"]) == \"No\")\nassert(match_parens(lst:\
    \ [\")())\", \"(()()(\"]) == \"Yes\")\nassert(match_parens(lst: [\"(())))\", \"\
    (()())((\"]) == \"Yes\")\nassert(match_parens(lst: [\"()\", \"())\"]) == \"No\"\
    )\nassert(match_parens(lst: [\"(()(\", \"()))()\"]) == \"Yes\")\nassert(match_parens(lst:\
    \ [\"((((\", \"((())\"]) == \"No\")\nassert(match_parens(lst: [\")(()\", \"(()(\"\
    ]) == \"No\")\nassert(match_parens(lst: [\")(\", \")(\"]) == \"No\")\nassert(match_parens(lst:\
    \ [\"(\", \")\"]) == \"Yes\")\nassert(match_parens(lst: [\")\", \"(\"]) == \"\
    Yes\")"
  status: SyntaxError
  stderr: "/tmp/tmp35c5ozhb.swift:31:12: error: cannot find 'is_good' in scope\n \
    \   return is_good(str: lst_3) || is_good(str: lst_4) ? \"Yes\" : \"No\"\n   \
    \        ^~~~~~~\n/tmp/tmp35c5ozhb.swift:31:35: error: cannot find 'is_good' in\
    \ scope\n    return is_good(str: lst_3) || is_good(str: lst_4) ? \"Yes\" : \"\
    No\"\n                                  ^~~~~~~\n"
  stdout: ''
  timestamp: 1659979533
- exit_code: 1
  program: "\n/// You are given an array of two strings, both strings consist of open\n\
    /// parentheses '(' or close parentheses ')' only.\n/// Your job is to check if\
    \ it is possible to concatenate the two strings in\n/// some order, that the resulting\
    \ string will be good.\n/// A string S is considered to be good if and only if\
    \ all parentheses in S\n/// are balanced. For example: the string '(())()' is\
    \ good, while the string\n/// '())' is not.\n/// Return 'Yes' if there's a way\
    \ to make a good string, and return 'No' otherwise.\n/// Examples:\n/// >>> match_parens(lst:\
    \ [\"()(\", \")\"])\n/// \"Yes\"\n/// >>> match_parens(lst: [\")\", \")\"])\n\
    /// \"No\"\nfunc match_parens(lst: [String]) -> String {\n    let string1 = lst[0]\n\
    \    let string2 = lst[1]\n    var arr1 = Array(string1.characters)\n    var arr2\
    \ = Array(string2.characters)\n    var arr3 = [Character]()\n    if (arr1.contains(\"\
    (\") && arr2.contains(\")\")) || (arr1.contains(\")\") && arr2.contains(\"(\"\
    )) {\n        while (arr1.count > 0) && (arr2.count > 0) {\n            if arr1[0]\
    \ == \"(\" {\n                arr3.append(arr1[0])\n                arr1.remove(at:\
    \ 0)\n            } else {\n                arr3.append(arr2[0])\n           \
    \     arr2.remove(at: 0)\n            }\n        }\n        arr3.append(contentsOf:\
    \ arr1)\n        arr3.append(contentsOf: arr2)\n        var i = 0\n        var\
    \ j = 0\n        for c in arr3 {\n            if c == \"(\" {\n              \
    \  i += 1\n            } else {\n                j += 1\n            }\n     \
    \       if j > i {\n                return \"No\"\n            }\n        }\n\
    \        return \"Yes\"\n    } else {\n        return \"No\"\n    }\n}\n\n\nfunc\
    \ ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count !=\
    \ right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(match_parens(lst: [\"()(\", \")\"]) == \"Yes\"\
    )\nassert(match_parens(lst: [\")\", \")\"]) == \"No\")\nassert(match_parens(lst:\
    \ [\"(()(())\", \"())())\"]) == \"No\")\nassert(match_parens(lst: [\")())\", \"\
    (()()(\"]) == \"Yes\")\nassert(match_parens(lst: [\"(())))\", \"(()())((\"]) ==\
    \ \"Yes\")\nassert(match_parens(lst: [\"()\", \"())\"]) == \"No\")\nassert(match_parens(lst:\
    \ [\"(()(\", \"()))()\"]) == \"Yes\")\nassert(match_parens(lst: [\"((((\", \"\
    ((())\"]) == \"No\")\nassert(match_parens(lst: [\")(()\", \"(()(\"]) == \"No\"\
    )\nassert(match_parens(lst: [\")(\", \")(\"]) == \"No\")\nassert(match_parens(lst:\
    \ [\"(\", \")\"]) == \"Yes\")\nassert(match_parens(lst: [\")\", \"(\"]) == \"\
    Yes\")"
  status: SyntaxError
  stderr: "/tmp/tmp1f6umtr6.swift:18:30: error: 'characters' is unavailable: Please\
    \ use String directly\n    var arr1 = Array(string1.characters)\n            \
    \                 ^~~~~~~~~~\nSwift.String:5:16: note: 'characters' was obsoleted\
    \ in Swift 5.0\n    public var characters: String { get set }\n              \
    \ ^\n/tmp/tmp1f6umtr6.swift:19:30: error: 'characters' is unavailable: Please\
    \ use String directly\n    var arr2 = Array(string2.characters)\n            \
    \                 ^~~~~~~~~~\nSwift.String:5:16: note: 'characters' was obsoleted\
    \ in Swift 5.0\n    public var characters: String { get set }\n              \
    \ ^\n"
  stdout: ''
  timestamp: 1659979533
- exit_code: 1
  program: "\n/// You are given an array of two strings, both strings consist of open\n\
    /// parentheses '(' or close parentheses ')' only.\n/// Your job is to check if\
    \ it is possible to concatenate the two strings in\n/// some order, that the resulting\
    \ string will be good.\n/// A string S is considered to be good if and only if\
    \ all parentheses in S\n/// are balanced. For example: the string '(())()' is\
    \ good, while the string\n/// '())' is not.\n/// Return 'Yes' if there's a way\
    \ to make a good string, and return 'No' otherwise.\n/// Examples:\n/// >>> match_parens(lst:\
    \ [\"()(\", \")\"])\n/// \"Yes\"\n/// >>> match_parens(lst: [\")\", \")\"])\n\
    /// \"No\"\nfunc match_parens(lst: [String]) -> String {\n  // your code here\n\
    \    let s = lst[0] + lst[1]\n    var count = 0\n    for ch in s.characters {\n\
    \        if ch == \"(\" {\n            count += 1\n        } else {\n        \
    \    count -= 1\n        }\n        if count < 0 {\n            return \"No\"\n\
    \        }\n    }\n    return count == 0 ? \"Yes\" : \"No\"\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(match_parens(lst: [\"()(\", \")\"]) == \"Yes\")\nassert(match_parens(lst:\
    \ [\")\", \")\"]) == \"No\")\nassert(match_parens(lst: [\"(()(())\", \"())())\"\
    ]) == \"No\")\nassert(match_parens(lst: [\")())\", \"(()()(\"]) == \"Yes\")\n\
    assert(match_parens(lst: [\"(())))\", \"(()())((\"]) == \"Yes\")\nassert(match_parens(lst:\
    \ [\"()\", \"())\"]) == \"No\")\nassert(match_parens(lst: [\"(()(\", \"()))()\"\
    ]) == \"Yes\")\nassert(match_parens(lst: [\"((((\", \"((())\"]) == \"No\")\nassert(match_parens(lst:\
    \ [\")(()\", \"(()(\"]) == \"No\")\nassert(match_parens(lst: [\")(\", \")(\"])\
    \ == \"No\")\nassert(match_parens(lst: [\"(\", \")\"]) == \"Yes\")\nassert(match_parens(lst:\
    \ [\")\", \"(\"]) == \"Yes\")"
  status: SyntaxError
  stderr: "/tmp/tmpo8okxx5f.swift:19:17: error: 'characters' is unavailable: Please\
    \ use String directly\n    for ch in s.characters {\n                ^~~~~~~~~~\n\
    Swift.String:5:16: note: 'characters' was obsoleted in Swift 5.0\n    public var\
    \ characters: String { get set }\n               ^\n"
  stdout: ''
  timestamp: 1659979533
- exit_code: -4
  program: "\n/// You are given an array of two strings, both strings consist of open\n\
    /// parentheses '(' or close parentheses ')' only.\n/// Your job is to check if\
    \ it is possible to concatenate the two strings in\n/// some order, that the resulting\
    \ string will be good.\n/// A string S is considered to be good if and only if\
    \ all parentheses in S\n/// are balanced. For example: the string '(())()' is\
    \ good, while the string\n/// '())' is not.\n/// Return 'Yes' if there's a way\
    \ to make a good string, and return 'No' otherwise.\n/// Examples:\n/// >>> match_parens(lst:\
    \ [\"()(\", \")\"])\n/// \"Yes\"\n/// >>> match_parens(lst: [\")\", \")\"])\n\
    /// \"No\"\nfunc match_parens(lst: [String]) -> String {\n    let str0 = lst[0]\n\
    \    let str1 = lst[1]\n    let is_valid0 = str0.contains(\"(\") && !str0.contains(\"\
    )\")\n    let is_valid1 = str1.contains(\"(\") && !str1.contains(\")\")\n    if\
    \ is_valid0 && is_valid1 {\n        return \"Yes\"\n    }\n    return \"No\"\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(match_parens(lst: [\"()(\", \")\"]) == \"Yes\"\
    )\nassert(match_parens(lst: [\")\", \")\"]) == \"No\")\nassert(match_parens(lst:\
    \ [\"(()(())\", \"())())\"]) == \"No\")\nassert(match_parens(lst: [\")())\", \"\
    (()()(\"]) == \"Yes\")\nassert(match_parens(lst: [\"(())))\", \"(()())((\"]) ==\
    \ \"Yes\")\nassert(match_parens(lst: [\"()\", \"())\"]) == \"No\")\nassert(match_parens(lst:\
    \ [\"(()(\", \"()))()\"]) == \"Yes\")\nassert(match_parens(lst: [\"((((\", \"\
    ((())\"]) == \"No\")\nassert(match_parens(lst: [\")(()\", \"(()(\"]) == \"No\"\
    )\nassert(match_parens(lst: [\")(\", \")(\"]) == \"No\")\nassert(match_parens(lst:\
    \ [\"(\", \")\"]) == \"Yes\")\nassert(match_parens(lst: [\")\", \"(\"]) == \"\
    Yes\")"
  status: Exception
  stderr: 'tmp2gg2ratv/tmp2gg2ratv.swift:39: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002adc9f267c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002adc9ef5eb6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002adc9ef5e988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002adc9ef5d7b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmp2gg2ratv                        0x000055befb580676 <unavailable> + 5750

    5    libc.so.6                          0x00002adc9f453460 __libc_start_main +
    245

    6    tmp2gg2ratv                        0x000055befb580259 <unavailable> + 4697

    '
  stdout: ''
  timestamp: 1659979533
- exit_code: -4
  program: "\n/// You are given an array of two strings, both strings consist of open\n\
    /// parentheses '(' or close parentheses ')' only.\n/// Your job is to check if\
    \ it is possible to concatenate the two strings in\n/// some order, that the resulting\
    \ string will be good.\n/// A string S is considered to be good if and only if\
    \ all parentheses in S\n/// are balanced. For example: the string '(())()' is\
    \ good, while the string\n/// '())' is not.\n/// Return 'Yes' if there's a way\
    \ to make a good string, and return 'No' otherwise.\n/// Examples:\n/// >>> match_parens(lst:\
    \ [\"()(\", \")\"])\n/// \"Yes\"\n/// >>> match_parens(lst: [\")\", \")\"])\n\
    /// \"No\"\nfunc match_parens(lst: [String]) -> String {\n    var stack = \"\"\
    \n    for i in 0..<lst.count {\n        let str = lst[i]\n        if str.isEmpty\
    \ {\n            continue\n        }\n        let first = str.first!\n       \
    \ if first == \")\" {\n            if stack.count == 0 {\n                return\
    \ \"No\"\n            }\n            let last = stack.last!\n            if last\
    \ == \"(\" {\n                stack.removeLast()\n            } else {\n     \
    \           stack.append(first)\n            }\n        } else {\n           \
    \ stack.append(first)\n        }\n    }\n    if stack.count > 0 {\n        return\
    \ \"No\"\n    }\n    return \"Yes\"\n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(match_parens(lst: [\"()(\", \")\"]) == \"Yes\")\nassert(match_parens(lst:\
    \ [\")\", \")\"]) == \"No\")\nassert(match_parens(lst: [\"(()(())\", \"())())\"\
    ]) == \"No\")\nassert(match_parens(lst: [\")())\", \"(()()(\"]) == \"Yes\")\n\
    assert(match_parens(lst: [\"(())))\", \"(()())((\"]) == \"Yes\")\nassert(match_parens(lst:\
    \ [\"()\", \"())\"]) == \"No\")\nassert(match_parens(lst: [\"(()(\", \"()))()\"\
    ]) == \"Yes\")\nassert(match_parens(lst: [\"((((\", \"((())\"]) == \"No\")\nassert(match_parens(lst:\
    \ [\")(()\", \"(()(\"]) == \"No\")\nassert(match_parens(lst: [\")(\", \")(\"])\
    \ == \"No\")\nassert(match_parens(lst: [\"(\", \")\"]) == \"Yes\")\nassert(match_parens(lst:\
    \ [\")\", \"(\"]) == \"Yes\")"
  status: Exception
  stderr: 'tmpc5ob7lxe/tmpc5ob7lxe.swift:59: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002ab20160ec80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002ab201305b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002ab201305988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002ab2013047b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpc5ob7lxe                        0x000055d6c8d1ff16 <unavailable> + 7958

    5    libc.so.6                          0x00002ab2017fa460 __libc_start_main +
    245

    6    tmpc5ob7lxe                        0x000055d6c8d1f679 <unavailable> + 5753

    '
  stdout: ''
  timestamp: 1659979533
- exit_code: 1
  program: "\n/// You are given an array of two strings, both strings consist of open\n\
    /// parentheses '(' or close parentheses ')' only.\n/// Your job is to check if\
    \ it is possible to concatenate the two strings in\n/// some order, that the resulting\
    \ string will be good.\n/// A string S is considered to be good if and only if\
    \ all parentheses in S\n/// are balanced. For example: the string '(())()' is\
    \ good, while the string\n/// '())' is not.\n/// Return 'Yes' if there's a way\
    \ to make a good string, and return 'No' otherwise.\n/// Examples:\n/// >>> match_parens(lst:\
    \ [\"()(\", \")\"])\n/// \"Yes\"\n/// >>> match_parens(lst: [\")\", \")\"])\n\
    /// \"No\"\nfunc match_parens(lst: [String]) -> String {\n    return lst.joined().is_good_parens\
    \ ? \"Yes\" : \"No\"\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(match_parens(lst:\
    \ [\"()(\", \")\"]) == \"Yes\")\nassert(match_parens(lst: [\")\", \")\"]) == \"\
    No\")\nassert(match_parens(lst: [\"(()(())\", \"())())\"]) == \"No\")\nassert(match_parens(lst:\
    \ [\")())\", \"(()()(\"]) == \"Yes\")\nassert(match_parens(lst: [\"(())))\", \"\
    (()())((\"]) == \"Yes\")\nassert(match_parens(lst: [\"()\", \"())\"]) == \"No\"\
    )\nassert(match_parens(lst: [\"(()(\", \"()))()\"]) == \"Yes\")\nassert(match_parens(lst:\
    \ [\"((((\", \"((())\"]) == \"No\")\nassert(match_parens(lst: [\")(()\", \"(()(\"\
    ]) == \"No\")\nassert(match_parens(lst: [\")(\", \")(\"]) == \"No\")\nassert(match_parens(lst:\
    \ [\"(\", \")\"]) == \"Yes\")\nassert(match_parens(lst: [\")\", \"(\"]) == \"\
    Yes\")"
  status: SyntaxError
  stderr: "/tmp/tmp1javneto.swift:16:25: error: value of type 'String' has no member\
    \ 'is_good_parens'\n    return lst.joined().is_good_parens ? \"Yes\" : \"No\"\n\
    \           ~~~~~~~~~~~~ ^~~~~~~~~~~~~~\n"
  stdout: ''
  timestamp: 1659979533
- exit_code: 1
  program: "\n/// You are given an array of two strings, both strings consist of open\n\
    /// parentheses '(' or close parentheses ')' only.\n/// Your job is to check if\
    \ it is possible to concatenate the two strings in\n/// some order, that the resulting\
    \ string will be good.\n/// A string S is considered to be good if and only if\
    \ all parentheses in S\n/// are balanced. For example: the string '(())()' is\
    \ good, while the string\n/// '())' is not.\n/// Return 'Yes' if there's a way\
    \ to make a good string, and return 'No' otherwise.\n/// Examples:\n/// >>> match_parens(lst:\
    \ [\"()(\", \")\"])\n/// \"Yes\"\n/// >>> match_parens(lst: [\")\", \")\"])\n\
    /// \"No\"\nfunc match_parens(lst: [String]) -> String {\n    var stack = Stack<Character>()\n\
    \    for char in lst[0] {\n        if char == \"(\" {\n            stack.push(char)\n\
    \        } else {\n            if stack.count == 0 {\n                return \"\
    No\"\n            }\n            stack.pop()\n        }\n    }\n    for char in\
    \ lst[1] {\n        if char == \"(\" {\n            if stack.count == 0 {\n  \
    \              return \"No\"\n            }\n            stack.pop()\n       \
    \ } else {\n            stack.push(char)\n        }\n    }\n    return stack.count\
    \ == 0 ? \"Yes\" : \"No\"\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(match_parens(lst:\
    \ [\"()(\", \")\"]) == \"Yes\")\nassert(match_parens(lst: [\")\", \")\"]) == \"\
    No\")\nassert(match_parens(lst: [\"(()(())\", \"())())\"]) == \"No\")\nassert(match_parens(lst:\
    \ [\")())\", \"(()()(\"]) == \"Yes\")\nassert(match_parens(lst: [\"(())))\", \"\
    (()())((\"]) == \"Yes\")\nassert(match_parens(lst: [\"()\", \"())\"]) == \"No\"\
    )\nassert(match_parens(lst: [\"(()(\", \"()))()\"]) == \"Yes\")\nassert(match_parens(lst:\
    \ [\"((((\", \"((())\"]) == \"No\")\nassert(match_parens(lst: [\")(()\", \"(()(\"\
    ]) == \"No\")\nassert(match_parens(lst: [\")(\", \")(\"]) == \"No\")\nassert(match_parens(lst:\
    \ [\"(\", \")\"]) == \"Yes\")\nassert(match_parens(lst: [\")\", \"(\"]) == \"\
    Yes\")"
  status: SyntaxError
  stderr: "/tmp/tmpcxuy4hvr.swift:16:17: error: cannot find 'Stack' in scope\n   \
    \ var stack = Stack<Character>()\n                ^~~~~\n"
  stdout: ''
  timestamp: 1659979533
- exit_code: -4
  program: "\n/// You are given an array of two strings, both strings consist of open\n\
    /// parentheses '(' or close parentheses ')' only.\n/// Your job is to check if\
    \ it is possible to concatenate the two strings in\n/// some order, that the resulting\
    \ string will be good.\n/// A string S is considered to be good if and only if\
    \ all parentheses in S\n/// are balanced. For example: the string '(())()' is\
    \ good, while the string\n/// '())' is not.\n/// Return 'Yes' if there's a way\
    \ to make a good string, and return 'No' otherwise.\n/// Examples:\n/// >>> match_parens(lst:\
    \ [\"()(\", \")\"])\n/// \"Yes\"\n/// >>> match_parens(lst: [\")\", \")\"])\n\
    /// \"No\"\nfunc match_parens(lst: [String]) -> String {\n    let s = lst[0] +\
    \ lst[1]\n    var cnt = 0\n    for c in s {\n        if c == \"(\" {\n       \
    \     cnt += 1\n        } else {\n            cnt -= 1\n        }\n        if\
    \ cnt < 0 {\n            return \"No\"\n        }\n    }\n    return cnt == 0\
    \ ? \"Yes\" : \"No\"\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(match_parens(lst:\
    \ [\"()(\", \")\"]) == \"Yes\")\nassert(match_parens(lst: [\")\", \")\"]) == \"\
    No\")\nassert(match_parens(lst: [\"(()(())\", \"())())\"]) == \"No\")\nassert(match_parens(lst:\
    \ [\")())\", \"(()()(\"]) == \"Yes\")\nassert(match_parens(lst: [\"(())))\", \"\
    (()())((\"]) == \"Yes\")\nassert(match_parens(lst: [\"()\", \"())\"]) == \"No\"\
    )\nassert(match_parens(lst: [\"(()(\", \"()))()\"]) == \"Yes\")\nassert(match_parens(lst:\
    \ [\"((((\", \"((())\"]) == \"No\")\nassert(match_parens(lst: [\")(()\", \"(()(\"\
    ]) == \"No\")\nassert(match_parens(lst: [\")(\", \")(\"]) == \"No\")\nassert(match_parens(lst:\
    \ [\"(\", \")\"]) == \"Yes\")\nassert(match_parens(lst: [\")\", \"(\"]) == \"\
    Yes\")"
  status: Exception
  stderr: 'tmpg9ssalll/tmpg9ssalll.swift:47: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b05ecd6dc80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b05eca64b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b05eca64988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b05eca637b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpg9ssalll                        0x000055907395bb76 <unavailable> + 7030

    5    libc.so.6                          0x00002b05ecf59460 __libc_start_main +
    245

    6    tmpg9ssalll                        0x000055907395b2d9 <unavailable> + 4825

    '
  stdout: ''
  timestamp: 1659979533
- exit_code: -4
  program: "\n/// You are given an array of two strings, both strings consist of open\n\
    /// parentheses '(' or close parentheses ')' only.\n/// Your job is to check if\
    \ it is possible to concatenate the two strings in\n/// some order, that the resulting\
    \ string will be good.\n/// A string S is considered to be good if and only if\
    \ all parentheses in S\n/// are balanced. For example: the string '(())()' is\
    \ good, while the string\n/// '())' is not.\n/// Return 'Yes' if there's a way\
    \ to make a good string, and return 'No' otherwise.\n/// Examples:\n/// >>> match_parens(lst:\
    \ [\"()(\", \")\"])\n/// \"Yes\"\n/// >>> match_parens(lst: [\")\", \")\"])\n\
    /// \"No\"\nfunc match_parens(lst: [String]) -> String {\n    var str = \"\"\n\
    \    for s in lst {\n        str += s\n    }\n    var balance = 0\n    for c in\
    \ str {\n        if c == \"(\" {\n            balance += 1\n        } else {\n\
    \            balance -= 1\n        }\n        if balance < 0 {\n            return\
    \ \"No\"\n        }\n    }\n    return balance == 0 ? \"Yes\" : \"No\"\n}\n\n\n\
    func ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(match_parens(lst: [\"()(\", \")\"]) == \"Yes\"\
    )\nassert(match_parens(lst: [\")\", \")\"]) == \"No\")\nassert(match_parens(lst:\
    \ [\"(()(())\", \"())())\"]) == \"No\")\nassert(match_parens(lst: [\")())\", \"\
    (()()(\"]) == \"Yes\")\nassert(match_parens(lst: [\"(())))\", \"(()())((\"]) ==\
    \ \"Yes\")\nassert(match_parens(lst: [\"()\", \"())\"]) == \"No\")\nassert(match_parens(lst:\
    \ [\"(()(\", \"()))()\"]) == \"Yes\")\nassert(match_parens(lst: [\"((((\", \"\
    ((())\"]) == \"No\")\nassert(match_parens(lst: [\")(()\", \"(()(\"]) == \"No\"\
    )\nassert(match_parens(lst: [\")(\", \")(\"]) == \"No\")\nassert(match_parens(lst:\
    \ [\"(\", \")\"]) == \"Yes\")\nassert(match_parens(lst: [\")\", \"(\"]) == \"\
    Yes\")"
  status: Exception
  stderr: 'tmp6xoxw9zv/tmp6xoxw9zv.swift:50: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002ab95f85cc80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002ab95f553b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002ab95f553988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002ab95f5527b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmp6xoxw9zv                        0x0000558c60ee3c96 <unavailable> + 7318

    5    libc.so.6                          0x00002ab95fa48460 __libc_start_main +
    245

    6    tmp6xoxw9zv                        0x0000558c60ee33f9 <unavailable> + 5113

    '
  stdout: ''
  timestamp: 1659979533
- exit_code: -4
  program: "\n/// You are given an array of two strings, both strings consist of open\n\
    /// parentheses '(' or close parentheses ')' only.\n/// Your job is to check if\
    \ it is possible to concatenate the two strings in\n/// some order, that the resulting\
    \ string will be good.\n/// A string S is considered to be good if and only if\
    \ all parentheses in S\n/// are balanced. For example: the string '(())()' is\
    \ good, while the string\n/// '())' is not.\n/// Return 'Yes' if there's a way\
    \ to make a good string, and return 'No' otherwise.\n/// Examples:\n/// >>> match_parens(lst:\
    \ [\"()(\", \")\"])\n/// \"Yes\"\n/// >>> match_parens(lst: [\")\", \")\"])\n\
    /// \"No\"\nfunc match_parens(lst: [String]) -> String {\n    var left = [Character]()\n\
    \    var right = [Character]()\n    for char in lst[0] {\n        left.append(char)\n\
    \    }\n    for char in lst[1] {\n        right.append(char)\n    }\n    var l\
    \ = left.count\n    var r = right.count\n    while l != 0 && r != 0 {\n      \
    \  if (left[l - 1] == \"(\") && (right[r - 1] == \")\") {\n            l -= 1\n\
    \            r -= 1\n        } else if (left[l - 1] == \")\") && (right[r - 1]\
    \ == \"(\") {\n            return \"No\"\n        } else if (left[l - 1] == \"\
    (\") && (right[r - 1] == \"(\") {\n            return \"No\"\n        } else if\
    \ (left[l - 1] == \")\") && (right[r - 1] == \")\") {\n            return \"No\"\
    \n        }\n    }\n    return \"Yes\"\n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(match_parens(lst: [\"()(\", \")\"]) == \"Yes\")\nassert(match_parens(lst:\
    \ [\")\", \")\"]) == \"No\")\nassert(match_parens(lst: [\"(()(())\", \"())())\"\
    ]) == \"No\")\nassert(match_parens(lst: [\")())\", \"(()()(\"]) == \"Yes\")\n\
    assert(match_parens(lst: [\"(())))\", \"(()())((\"]) == \"Yes\")\nassert(match_parens(lst:\
    \ [\"()\", \"())\"]) == \"No\")\nassert(match_parens(lst: [\"(()(\", \"()))()\"\
    ]) == \"Yes\")\nassert(match_parens(lst: [\"((((\", \"((())\"]) == \"No\")\nassert(match_parens(lst:\
    \ [\")(()\", \"(()(\"]) == \"No\")\nassert(match_parens(lst: [\")(\", \")(\"])\
    \ == \"No\")\nassert(match_parens(lst: [\"(\", \")\"]) == \"Yes\")\nassert(match_parens(lst:\
    \ [\")\", \"(\"]) == \"Yes\")"
  status: Exception
  stderr: 'tmpubmfc5fx/tmpubmfc5fx.swift:57: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002ac1bdeb3c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002ac1bdbaab6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002ac1bdbaa988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002ac1bdba97b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpubmfc5fx                        0x000055e3bfe6fc76 <unavailable> + 7286

    5    libc.so.6                          0x00002ac1be09f460 __libc_start_main +
    245

    6    tmpubmfc5fx                        0x000055e3bfe6f3d9 <unavailable> + 5081

    '
  stdout: ''
  timestamp: 1659979533
- exit_code: -4
  program: "\n/// You are given an array of two strings, both strings consist of open\n\
    /// parentheses '(' or close parentheses ')' only.\n/// Your job is to check if\
    \ it is possible to concatenate the two strings in\n/// some order, that the resulting\
    \ string will be good.\n/// A string S is considered to be good if and only if\
    \ all parentheses in S\n/// are balanced. For example: the string '(())()' is\
    \ good, while the string\n/// '())' is not.\n/// Return 'Yes' if there's a way\
    \ to make a good string, and return 'No' otherwise.\n/// Examples:\n/// >>> match_parens(lst:\
    \ [\"()(\", \")\"])\n/// \"Yes\"\n/// >>> match_parens(lst: [\")\", \")\"])\n\
    /// \"No\"\nfunc match_parens(lst: [String]) -> String {\n    let str1 = lst[0]\n\
    \    let str2 = lst[1]\n    var parens = 0\n    for char in str1 {\n        if\
    \ char == \"(\" {\n            parens += 1\n        } else {\n            parens\
    \ -= 1\n        }\n    }\n    for char in str2 {\n        if char == \"(\" {\n\
    \            parens += 1\n        } else {\n            parens -= 1\n        }\n\
    \    }\n    return parens == 0 ? \"Yes\" : \"No\"\n}\n\n\nfunc ==(left: [(Int,\
    \ Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n\
    \        return false\n    }\n    for (l, r) in zip(left, right) {\n        if\
    \ l != r {\n            return false\n        }\n    }\n    return true\n}\n \
    \           \nassert(match_parens(lst: [\"()(\", \")\"]) == \"Yes\")\nassert(match_parens(lst:\
    \ [\")\", \")\"]) == \"No\")\nassert(match_parens(lst: [\"(()(())\", \"())())\"\
    ]) == \"No\")\nassert(match_parens(lst: [\")())\", \"(()()(\"]) == \"Yes\")\n\
    assert(match_parens(lst: [\"(())))\", \"(()())((\"]) == \"Yes\")\nassert(match_parens(lst:\
    \ [\"()\", \"())\"]) == \"No\")\nassert(match_parens(lst: [\"(()(\", \"()))()\"\
    ]) == \"Yes\")\nassert(match_parens(lst: [\"((((\", \"((())\"]) == \"No\")\nassert(match_parens(lst:\
    \ [\")(()\", \"(()(\"]) == \"No\")\nassert(match_parens(lst: [\")(\", \")(\"])\
    \ == \"No\")\nassert(match_parens(lst: [\"(\", \")\"]) == \"Yes\")\nassert(match_parens(lst:\
    \ [\")\", \"(\"]) == \"Yes\")"
  status: Exception
  stderr: 'tmp2mehv1xg/tmp2mehv1xg.swift:58: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002ad9267f5c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002ad9264ecb6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002ad9264ec988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002ad9264eb7b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmp2mehv1xg                        0x000056200a610468 <unavailable> + 9320

    5    libc.so.6                          0x00002ad9269e1460 __libc_start_main +
    245

    6    tmp2mehv1xg                        0x000056200a60f289 <unavailable> + 4745

    '
  stdout: ''
  timestamp: 1659979533
- exit_code: -4
  program: "\n/// You are given an array of two strings, both strings consist of open\n\
    /// parentheses '(' or close parentheses ')' only.\n/// Your job is to check if\
    \ it is possible to concatenate the two strings in\n/// some order, that the resulting\
    \ string will be good.\n/// A string S is considered to be good if and only if\
    \ all parentheses in S\n/// are balanced. For example: the string '(())()' is\
    \ good, while the string\n/// '())' is not.\n/// Return 'Yes' if there's a way\
    \ to make a good string, and return 'No' otherwise.\n/// Examples:\n/// >>> match_parens(lst:\
    \ [\"()(\", \")\"])\n/// \"Yes\"\n/// >>> match_parens(lst: [\")\", \")\"])\n\
    /// \"No\"\nfunc match_parens(lst: [String]) -> String {\n    var sum = 0\n  \
    \  for c in lst[0] {\n        if c == \"(\" {\n            sum += 1\n        }\
    \ else {\n            sum -= 1\n        }\n    }\n    for c in lst[1] {\n    \
    \    if c == \"(\" {\n            sum += 1\n        } else {\n            sum\
    \ -= 1\n        }\n    }\n    return sum == 0 ? \"Yes\" : \"No\"\n}\n\n\nfunc\
    \ ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count !=\
    \ right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(match_parens(lst: [\"()(\", \")\"]) == \"Yes\"\
    )\nassert(match_parens(lst: [\")\", \")\"]) == \"No\")\nassert(match_parens(lst:\
    \ [\"(()(())\", \"())())\"]) == \"No\")\nassert(match_parens(lst: [\")())\", \"\
    (()()(\"]) == \"Yes\")\nassert(match_parens(lst: [\"(())))\", \"(()())((\"]) ==\
    \ \"Yes\")\nassert(match_parens(lst: [\"()\", \"())\"]) == \"No\")\nassert(match_parens(lst:\
    \ [\"(()(\", \"()))()\"]) == \"Yes\")\nassert(match_parens(lst: [\"((((\", \"\
    ((())\"]) == \"No\")\nassert(match_parens(lst: [\")(()\", \"(()(\"]) == \"No\"\
    )\nassert(match_parens(lst: [\")(\", \")(\"]) == \"No\")\nassert(match_parens(lst:\
    \ [\"(\", \")\"]) == \"Yes\")\nassert(match_parens(lst: [\")\", \"(\"]) == \"\
    Yes\")"
  status: Exception
  stderr: 'tmpjr5d8qqu/tmpjr5d8qqu.swift:56: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002ac064f2fc80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002ac064c26b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002ac064c26988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002ac064c257b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpjr5d8qqu                        0x000056028b31a468 <unavailable> + 9320

    5    libc.so.6                          0x00002ac06511b460 __libc_start_main +
    245

    6    tmpjr5d8qqu                        0x000056028b319289 <unavailable> + 4745

    '
  stdout: ''
  timestamp: 1659979533
- exit_code: -4
  program: "\n/// You are given an array of two strings, both strings consist of open\n\
    /// parentheses '(' or close parentheses ')' only.\n/// Your job is to check if\
    \ it is possible to concatenate the two strings in\n/// some order, that the resulting\
    \ string will be good.\n/// A string S is considered to be good if and only if\
    \ all parentheses in S\n/// are balanced. For example: the string '(())()' is\
    \ good, while the string\n/// '())' is not.\n/// Return 'Yes' if there's a way\
    \ to make a good string, and return 'No' otherwise.\n/// Examples:\n/// >>> match_parens(lst:\
    \ [\"()(\", \")\"])\n/// \"Yes\"\n/// >>> match_parens(lst: [\")\", \")\"])\n\
    /// \"No\"\nfunc match_parens(lst: [String]) -> String {\n    // TODO: Implement\
    \ solution\n    return \"\"\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int,\
    \ Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n\
    \    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n          \
    \  return false\n        }\n    }\n    return true\n}\n            \nassert(match_parens(lst:\
    \ [\"()(\", \")\"]) == \"Yes\")\nassert(match_parens(lst: [\")\", \")\"]) == \"\
    No\")\nassert(match_parens(lst: [\"(()(())\", \"())())\"]) == \"No\")\nassert(match_parens(lst:\
    \ [\")())\", \"(()()(\"]) == \"Yes\")\nassert(match_parens(lst: [\"(())))\", \"\
    (()())((\"]) == \"Yes\")\nassert(match_parens(lst: [\"()\", \"())\"]) == \"No\"\
    )\nassert(match_parens(lst: [\"(()(\", \"()))()\"]) == \"Yes\")\nassert(match_parens(lst:\
    \ [\"((((\", \"((())\"]) == \"No\")\nassert(match_parens(lst: [\")(()\", \"(()(\"\
    ]) == \"No\")\nassert(match_parens(lst: [\")(\", \")(\"]) == \"No\")\nassert(match_parens(lst:\
    \ [\"(\", \")\"]) == \"Yes\")\nassert(match_parens(lst: [\")\", \"(\"]) == \"\
    Yes\")"
  status: Exception
  stderr: 'tmpa2ljsqj2/tmpa2ljsqj2.swift:33: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b792f16cc80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b792ee63b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b792ee63988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b792ee627b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpa2ljsqj2                        0x000055a9eebff4a6 <unavailable> + 5286

    5    libc.so.6                          0x00002b792f358460 __libc_start_main +
    245

    6    tmpa2ljsqj2                        0x000055a9eebff089 <unavailable> + 4233

    '
  stdout: ''
  timestamp: 1659979533
- exit_code: -4
  program: "\n/// You are given an array of two strings, both strings consist of open\n\
    /// parentheses '(' or close parentheses ')' only.\n/// Your job is to check if\
    \ it is possible to concatenate the two strings in\n/// some order, that the resulting\
    \ string will be good.\n/// A string S is considered to be good if and only if\
    \ all parentheses in S\n/// are balanced. For example: the string '(())()' is\
    \ good, while the string\n/// '())' is not.\n/// Return 'Yes' if there's a way\
    \ to make a good string, and return 'No' otherwise.\n/// Examples:\n/// >>> match_parens(lst:\
    \ [\"()(\", \")\"])\n/// \"Yes\"\n/// >>> match_parens(lst: [\")\", \")\"])\n\
    /// \"No\"\nfunc match_parens(lst: [String]) -> String {\n    var str = \"\"\n\
    \    var count = 0\n    for s in lst {\n        for ch in s {\n            if\
    \ ch == \"(\" {\n                count += 1\n            } else {\n          \
    \      count -= 1\n            }\n            if count < 0 {\n               \
    \ return \"No\"\n            }\n        }\n        str += s\n    }\n    return\
    \ count == 0 ? \"Yes\" : \"No\"\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int,\
    \ Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n\
    \    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n          \
    \  return false\n        }\n    }\n    return true\n}\n            \nassert(match_parens(lst:\
    \ [\"()(\", \")\"]) == \"Yes\")\nassert(match_parens(lst: [\")\", \")\"]) == \"\
    No\")\nassert(match_parens(lst: [\"(()(())\", \"())())\"]) == \"No\")\nassert(match_parens(lst:\
    \ [\")())\", \"(()()(\"]) == \"Yes\")\nassert(match_parens(lst: [\"(())))\", \"\
    (()())((\"]) == \"Yes\")\nassert(match_parens(lst: [\"()\", \"())\"]) == \"No\"\
    )\nassert(match_parens(lst: [\"(()(\", \"()))()\"]) == \"Yes\")\nassert(match_parens(lst:\
    \ [\"((((\", \"((())\"]) == \"No\")\nassert(match_parens(lst: [\")(()\", \"(()(\"\
    ]) == \"No\")\nassert(match_parens(lst: [\")(\", \")(\"]) == \"No\")\nassert(match_parens(lst:\
    \ [\"(\", \")\"]) == \"Yes\")\nassert(match_parens(lst: [\")\", \"(\"]) == \"\
    Yes\")"
  status: Exception
  stderr: 'tmp_940e2f6/tmp_940e2f6.swift:50: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b47e96e2c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b47e93d9b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b47e93d9988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b47e93d87b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmp_940e2f6                        0x0000564f98fb8c96 <unavailable> + 7318

    5    libc.so.6                          0x00002b47e98ce460 __libc_start_main +
    245

    6    tmp_940e2f6                        0x0000564f98fb83f9 <unavailable> + 5113

    '
  stdout: ''
  timestamp: 1659979533
- exit_code: -4
  program: "\n/// You are given an array of two strings, both strings consist of open\n\
    /// parentheses '(' or close parentheses ')' only.\n/// Your job is to check if\
    \ it is possible to concatenate the two strings in\n/// some order, that the resulting\
    \ string will be good.\n/// A string S is considered to be good if and only if\
    \ all parentheses in S\n/// are balanced. For example: the string '(())()' is\
    \ good, while the string\n/// '())' is not.\n/// Return 'Yes' if there's a way\
    \ to make a good string, and return 'No' otherwise.\n/// Examples:\n/// >>> match_parens(lst:\
    \ [\"()(\", \")\"])\n/// \"Yes\"\n/// >>> match_parens(lst: [\")\", \")\"])\n\
    /// \"No\"\nfunc match_parens(lst: [String]) -> String {\n    if lst.count !=\
    \ 2 { return \"No\" }\n    var lhs = lst[0]\n    var rhs = lst[1]\n    while lhs.count\
    \ > 0 && rhs.count > 0 {\n        if lhs.first! == \"(\" && rhs.first! == \")\"\
    \ {\n            lhs.removeFirst()\n            rhs.removeFirst()\n        } else\
    \ if lhs.first! == \")\" && rhs.first! == \"(\" {\n            lhs.removeFirst()\n\
    \            rhs.removeFirst()\n        } else if lhs.first! == \"(\" && rhs.first!\
    \ == \"(\" {\n            lhs.removeFirst()\n        } else if lhs.first! == \"\
    )\" && rhs.first! == \")\" {\n            rhs.removeFirst()\n        } else {\n\
    \            return \"No\"\n        }\n    }\n    if lhs.count == 0 && rhs.count\
    \ == 0 {\n        return \"Yes\"\n    } else {\n        return \"No\"\n    }\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(match_parens(lst: [\"()(\", \")\"]) == \"Yes\"\
    )\nassert(match_parens(lst: [\")\", \")\"]) == \"No\")\nassert(match_parens(lst:\
    \ [\"(()(())\", \"())())\"]) == \"No\")\nassert(match_parens(lst: [\")())\", \"\
    (()()(\"]) == \"Yes\")\nassert(match_parens(lst: [\"(())))\", \"(()())((\"]) ==\
    \ \"Yes\")\nassert(match_parens(lst: [\"()\", \"())\"]) == \"No\")\nassert(match_parens(lst:\
    \ [\"(()(\", \"()))()\"]) == \"Yes\")\nassert(match_parens(lst: [\"((((\", \"\
    ((())\"]) == \"No\")\nassert(match_parens(lst: [\")(()\", \"(()(\"]) == \"No\"\
    )\nassert(match_parens(lst: [\")(\", \")(\"]) == \"No\")\nassert(match_parens(lst:\
    \ [\"(\", \")\"]) == \"Yes\")\nassert(match_parens(lst: [\")\", \"(\"]) == \"\
    Yes\")"
  status: Exception
  stderr: 'tmpx_8xkjal/tmpx_8xkjal.swift:54: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002ba5d81d5c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002ba5d7eccb6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002ba5d7ecc988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002ba5d7ecb7b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpx_8xkjal                        0x000055ba932a6856 <unavailable> + 6230

    5    libc.so.6                          0x00002ba5d83c1460 __libc_start_main +
    245

    6    tmpx_8xkjal                        0x000055ba932a6439 <unavailable> + 5177

    '
  stdout: ''
  timestamp: 1659979533
- exit_code: -4
  program: "\n/// You are given an array of two strings, both strings consist of open\n\
    /// parentheses '(' or close parentheses ')' only.\n/// Your job is to check if\
    \ it is possible to concatenate the two strings in\n/// some order, that the resulting\
    \ string will be good.\n/// A string S is considered to be good if and only if\
    \ all parentheses in S\n/// are balanced. For example: the string '(())()' is\
    \ good, while the string\n/// '())' is not.\n/// Return 'Yes' if there's a way\
    \ to make a good string, and return 'No' otherwise.\n/// Examples:\n/// >>> match_parens(lst:\
    \ [\"()(\", \")\"])\n/// \"Yes\"\n/// >>> match_parens(lst: [\")\", \")\"])\n\
    /// \"No\"\nfunc match_parens(lst: [String]) -> String {\n  var left: Int = 0\n\
    \  var right: Int = 0\n  for str in lst {\n    for ch in str {\n      if ch ==\
    \ \"(\" {\n        left += 1\n      } else {\n        right += 1\n      }\n  \
    \  }\n  }\n  return left == right ? \"Yes\" : \"No\"\n}\n\n\nfunc ==(left: [(Int,\
    \ Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n\
    \        return false\n    }\n    for (l, r) in zip(left, right) {\n        if\
    \ l != r {\n            return false\n        }\n    }\n    return true\n}\n \
    \           \nassert(match_parens(lst: [\"()(\", \")\"]) == \"Yes\")\nassert(match_parens(lst:\
    \ [\")\", \")\"]) == \"No\")\nassert(match_parens(lst: [\"(()(())\", \"())())\"\
    ]) == \"No\")\nassert(match_parens(lst: [\")())\", \"(()()(\"]) == \"Yes\")\n\
    assert(match_parens(lst: [\"(())))\", \"(()())((\"]) == \"Yes\")\nassert(match_parens(lst:\
    \ [\"()\", \"())\"]) == \"No\")\nassert(match_parens(lst: [\"(()(\", \"()))()\"\
    ]) == \"Yes\")\nassert(match_parens(lst: [\"((((\", \"((())\"]) == \"No\")\nassert(match_parens(lst:\
    \ [\")(()\", \"(()(\"]) == \"No\")\nassert(match_parens(lst: [\")(\", \")(\"])\
    \ == \"No\")\nassert(match_parens(lst: [\"(\", \")\"]) == \"Yes\")\nassert(match_parens(lst:\
    \ [\")\", \"(\"]) == \"Yes\")"
  status: Exception
  stderr: 'tmpu8cpzm95/tmpu8cpzm95.swift:52: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002aafcd919c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002aafcd610b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002aafcd610988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002aafcd60f7b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpu8cpzm95                        0x0000564f7536e578 <unavailable> + 9592

    5    libc.so.6                          0x00002aafcdb05460 __libc_start_main +
    245

    6    tmpu8cpzm95                        0x0000564f7536d399 <unavailable> + 5017

    '
  stdout: ''
  timestamp: 1659979533
- exit_code: -4
  program: "\n/// You are given an array of two strings, both strings consist of open\n\
    /// parentheses '(' or close parentheses ')' only.\n/// Your job is to check if\
    \ it is possible to concatenate the two strings in\n/// some order, that the resulting\
    \ string will be good.\n/// A string S is considered to be good if and only if\
    \ all parentheses in S\n/// are balanced. For example: the string '(())()' is\
    \ good, while the string\n/// '())' is not.\n/// Return 'Yes' if there's a way\
    \ to make a good string, and return 'No' otherwise.\n/// Examples:\n/// >>> match_parens(lst:\
    \ [\"()(\", \")\"])\n/// \"Yes\"\n/// >>> match_parens(lst: [\")\", \")\"])\n\
    /// \"No\"\nfunc match_parens(lst: [String]) -> String {\n    var s = lst[0] +\
    \ lst[1]\n    for c in s {\n        if c == \")\" {\n            if s.last! ==\
    \ \"(\" {\n                let x = s.index(before: s.endIndex)\n             \
    \   let y = s.index(before: x)\n                s.removeSubrange(y...x)\n    \
    \        } else {\n                return \"No\"\n            }\n        }\n \
    \   }\n    return s.isEmpty ? \"Yes\" : \"No\"\n}\n\n\nfunc ==(left: [(Int, Int)],\
    \ right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n       \
    \ return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r\
    \ {\n            return false\n        }\n    }\n    return true\n}\n        \
    \    \nassert(match_parens(lst: [\"()(\", \")\"]) == \"Yes\")\nassert(match_parens(lst:\
    \ [\")\", \")\"]) == \"No\")\nassert(match_parens(lst: [\"(()(())\", \"())())\"\
    ]) == \"No\")\nassert(match_parens(lst: [\")())\", \"(()()(\"]) == \"Yes\")\n\
    assert(match_parens(lst: [\"(())))\", \"(()())((\"]) == \"Yes\")\nassert(match_parens(lst:\
    \ [\"()\", \"())\"]) == \"No\")\nassert(match_parens(lst: [\"(()(\", \"()))()\"\
    ]) == \"Yes\")\nassert(match_parens(lst: [\"((((\", \"((())\"]) == \"No\")\nassert(match_parens(lst:\
    \ [\")(()\", \"(()(\"]) == \"No\")\nassert(match_parens(lst: [\")(\", \")(\"])\
    \ == \"No\")\nassert(match_parens(lst: [\"(\", \")\"]) == \"Yes\")\nassert(match_parens(lst:\
    \ [\")\", \"(\"]) == \"Yes\")"
  status: Exception
  stderr: 'tmpjnf8qkz5/tmpjnf8qkz5.swift:44: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b163ad70c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b163aa67b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b163aa67988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b163aa667b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpjnf8qkz5                        0x0000560e48417a66 <unavailable> + 6758

    5    libc.so.6                          0x00002b163af5c460 __libc_start_main +
    245

    6    tmpjnf8qkz5                        0x0000560e48417649 <unavailable> + 5705

    '
  stdout: ''
  timestamp: 1659979533
- exit_code: 1
  program: "\n/// You are given an array of two strings, both strings consist of open\n\
    /// parentheses '(' or close parentheses ')' only.\n/// Your job is to check if\
    \ it is possible to concatenate the two strings in\n/// some order, that the resulting\
    \ string will be good.\n/// A string S is considered to be good if and only if\
    \ all parentheses in S\n/// are balanced. For example: the string '(())()' is\
    \ good, while the string\n/// '())' is not.\n/// Return 'Yes' if there's a way\
    \ to make a good string, and return 'No' otherwise.\n/// Examples:\n/// >>> match_parens(lst:\
    \ [\"()(\", \")\"])\n/// \"Yes\"\n/// >>> match_parens(lst: [\")\", \")\"])\n\
    /// \"No\"\nfunc match_parens(lst: [String]) -> String {\n    if lst.count ==\
    \ 2 {\n        var s = lst[0] + lst[1]\n        while s.contains(\"()\") {\n \
    \           s = s.replacingOccurrences(of: \"()\", with: \"\")\n        }\n  \
    \      return s.isEmpty ? \"Yes\" : \"No\"\n    }\n    return \"No\"\n}\n\n\n\
    func ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(match_parens(lst: [\"()(\", \")\"]) == \"Yes\"\
    )\nassert(match_parens(lst: [\")\", \")\"]) == \"No\")\nassert(match_parens(lst:\
    \ [\"(()(())\", \"())())\"]) == \"No\")\nassert(match_parens(lst: [\")())\", \"\
    (()()(\"]) == \"Yes\")\nassert(match_parens(lst: [\"(())))\", \"(()())((\"]) ==\
    \ \"Yes\")\nassert(match_parens(lst: [\"()\", \"())\"]) == \"No\")\nassert(match_parens(lst:\
    \ [\"(()(\", \"()))()\"]) == \"Yes\")\nassert(match_parens(lst: [\"((((\", \"\
    ((())\"]) == \"No\")\nassert(match_parens(lst: [\")(()\", \"(()(\"]) == \"No\"\
    )\nassert(match_parens(lst: [\")(\", \")(\"]) == \"No\")\nassert(match_parens(lst:\
    \ [\"(\", \")\"]) == \"Yes\")\nassert(match_parens(lst: [\")\", \"(\"]) == \"\
    Yes\")"
  status: SyntaxError
  stderr: "/tmp/tmp2yf50c_5.swift:19:19: error: value of type 'String' has no member\
    \ 'replacingOccurrences'\n            s = s.replacingOccurrences(of: \"()\", with:\
    \ \"\")\n                ~ ^~~~~~~~~~~~~~~~~~~~\n"
  stdout: ''
  timestamp: 1659979533
- exit_code: -4
  program: "\n/// You are given an array of two strings, both strings consist of open\n\
    /// parentheses '(' or close parentheses ')' only.\n/// Your job is to check if\
    \ it is possible to concatenate the two strings in\n/// some order, that the resulting\
    \ string will be good.\n/// A string S is considered to be good if and only if\
    \ all parentheses in S\n/// are balanced. For example: the string '(())()' is\
    \ good, while the string\n/// '())' is not.\n/// Return 'Yes' if there's a way\
    \ to make a good string, and return 'No' otherwise.\n/// Examples:\n/// >>> match_parens(lst:\
    \ [\"()(\", \")\"])\n/// \"Yes\"\n/// >>> match_parens(lst: [\")\", \")\"])\n\
    /// \"No\"\nfunc match_parens(lst: [String]) -> String {\n    let first = lst[0]\n\
    \    let second = lst[1]\n    if first.count == second.count {\n        return\
    \ \"Yes\"\n    } else {\n        return \"No\"\n    }\n}\n\n\nfunc ==(left: [(Int,\
    \ Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n\
    \        return false\n    }\n    for (l, r) in zip(left, right) {\n        if\
    \ l != r {\n            return false\n        }\n    }\n    return true\n}\n \
    \           \nassert(match_parens(lst: [\"()(\", \")\"]) == \"Yes\")\nassert(match_parens(lst:\
    \ [\")\", \")\"]) == \"No\")\nassert(match_parens(lst: [\"(()(())\", \"())())\"\
    ]) == \"No\")\nassert(match_parens(lst: [\")())\", \"(()()(\"]) == \"Yes\")\n\
    assert(match_parens(lst: [\"(())))\", \"(()())((\"]) == \"Yes\")\nassert(match_parens(lst:\
    \ [\"()\", \"())\"]) == \"No\")\nassert(match_parens(lst: [\"(()(\", \"()))()\"\
    ]) == \"Yes\")\nassert(match_parens(lst: [\"((((\", \"((())\"]) == \"No\")\nassert(match_parens(lst:\
    \ [\")(()\", \"(()(\"]) == \"No\")\nassert(match_parens(lst: [\")(\", \")(\"])\
    \ == \"No\")\nassert(match_parens(lst: [\"(\", \")\"]) == \"Yes\")\nassert(match_parens(lst:\
    \ [\")\", \"(\"]) == \"Yes\")"
  status: Exception
  stderr: 'tmp4w4zbges/tmp4w4zbges.swift:38: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b6b6a0ffc80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b6b69df6b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b6b69df6988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b6b69df57b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmp4w4zbges                        0x000055ed1ceda546 <unavailable> + 5446

    5    libc.so.6                          0x00002b6b6a2eb460 __libc_start_main +
    245

    6    tmp4w4zbges                        0x000055ed1ceda129 <unavailable> + 4393

    '
  stdout: ''
  timestamp: 1659979533
- exit_code: -4
  program: "\n/// You are given an array of two strings, both strings consist of open\n\
    /// parentheses '(' or close parentheses ')' only.\n/// Your job is to check if\
    \ it is possible to concatenate the two strings in\n/// some order, that the resulting\
    \ string will be good.\n/// A string S is considered to be good if and only if\
    \ all parentheses in S\n/// are balanced. For example: the string '(())()' is\
    \ good, while the string\n/// '())' is not.\n/// Return 'Yes' if there's a way\
    \ to make a good string, and return 'No' otherwise.\n/// Examples:\n/// >>> match_parens(lst:\
    \ [\"()(\", \")\"])\n/// \"Yes\"\n/// >>> match_parens(lst: [\")\", \")\"])\n\
    /// \"No\"\nfunc match_parens(lst: [String]) -> String {\n    var result = \"\
    Yes\"\n    var count = 0\n    for item in lst {\n        for char in item {\n\
    \            if char == \"(\" {\n                count += 1\n            } else\
    \ {\n                count -= 1\n            }\n            if count < 0 {\n \
    \               result = \"No\"\n                break\n            }\n      \
    \  }\n    }\n    if count != 0 {\n        result = \"No\"\n    }\n    return result\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(match_parens(lst: [\"()(\", \")\"]) == \"Yes\"\
    )\nassert(match_parens(lst: [\")\", \")\"]) == \"No\")\nassert(match_parens(lst:\
    \ [\"(()(())\", \"())())\"]) == \"No\")\nassert(match_parens(lst: [\")())\", \"\
    (()()(\"]) == \"Yes\")\nassert(match_parens(lst: [\"(())))\", \"(()())((\"]) ==\
    \ \"Yes\")\nassert(match_parens(lst: [\"()\", \"())\"]) == \"No\")\nassert(match_parens(lst:\
    \ [\"(()(\", \"()))()\"]) == \"Yes\")\nassert(match_parens(lst: [\"((((\", \"\
    ((())\"]) == \"No\")\nassert(match_parens(lst: [\")(()\", \"(()(\"]) == \"No\"\
    )\nassert(match_parens(lst: [\")(\", \")(\"]) == \"No\")\nassert(match_parens(lst:\
    \ [\"(\", \")\"]) == \"Yes\")\nassert(match_parens(lst: [\")\", \"(\"]) == \"\
    Yes\")"
  status: Exception
  stderr: 'tmpm18mtqqr/tmpm18mtqqr.swift:53: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b083bc46c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b083b93db6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b083b93d988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b083b93c7b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpm18mtqqr                        0x000055d64ba50c36 <unavailable> + 7222

    5    libc.so.6                          0x00002b083be32460 __libc_start_main +
    245

    6    tmpm18mtqqr                        0x000055d64ba50399 <unavailable> + 5017

    '
  stdout: ''
  timestamp: 1659979533
- exit_code: -4
  program: "\n/// You are given an array of two strings, both strings consist of open\n\
    /// parentheses '(' or close parentheses ')' only.\n/// Your job is to check if\
    \ it is possible to concatenate the two strings in\n/// some order, that the resulting\
    \ string will be good.\n/// A string S is considered to be good if and only if\
    \ all parentheses in S\n/// are balanced. For example: the string '(())()' is\
    \ good, while the string\n/// '())' is not.\n/// Return 'Yes' if there's a way\
    \ to make a good string, and return 'No' otherwise.\n/// Examples:\n/// >>> match_parens(lst:\
    \ [\"()(\", \")\"])\n/// \"Yes\"\n/// >>> match_parens(lst: [\")\", \")\"])\n\
    /// \"No\"\nfunc match_parens(lst: [String]) -> String {\n    let str1 = lst[0]\n\
    \    let str2 = lst[1]\n    var counter1 = 0\n    var counter2 = 0\n    for i\
    \ in str1 {\n        if i == \"(\" {\n            counter1 += 1\n        } else\
    \ {\n            counter1 -= 1\n        }\n    }\n    for i in str2 {\n      \
    \  if i == \"(\" {\n            counter2 += 1\n        } else {\n            counter2\
    \ -= 1\n        }\n    }\n    var balanced = false\n    if counter1 == 0 && counter2\
    \ == 0 {\n        balanced = true\n    }\n    if counter1 >= 0 && counter2 >=\
    \ 0 {\n        balanced = true\n    }\n    if counter1 <= 0 && counter2 <= 0 {\n\
    \        balanced = true\n    }\n    if counter1 >= counter2 {\n        balanced\
    \ = true\n    }\n    if counter1 <= counter2 {\n        balanced = true\n    }\n\
    \    if balanced {\n        return \"Yes\"\n    } else {\n        return \"No\"\
    \n    }\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n \
    \   if left.count != right.count {\n        return false\n    }\n    for (l, r)\
    \ in zip(left, right) {\n        if l != r {\n            return false\n     \
    \   }\n    }\n    return true\n}\n            \nassert(match_parens(lst: [\"()(\"\
    , \")\"]) == \"Yes\")\nassert(match_parens(lst: [\")\", \")\"]) == \"No\")\nassert(match_parens(lst:\
    \ [\"(()(())\", \"())())\"]) == \"No\")\nassert(match_parens(lst: [\")())\", \"\
    (()()(\"]) == \"Yes\")\nassert(match_parens(lst: [\"(())))\", \"(()())((\"]) ==\
    \ \"Yes\")\nassert(match_parens(lst: [\"()\", \"())\"]) == \"No\")\nassert(match_parens(lst:\
    \ [\"(()(\", \"()))()\"]) == \"Yes\")\nassert(match_parens(lst: [\"((((\", \"\
    ((())\"]) == \"No\")\nassert(match_parens(lst: [\")(()\", \"(()(\"]) == \"No\"\
    )\nassert(match_parens(lst: [\")(\", \")(\"]) == \"No\")\nassert(match_parens(lst:\
    \ [\"(\", \")\"]) == \"Yes\")\nassert(match_parens(lst: [\")\", \"(\"]) == \"\
    Yes\")"
  status: Exception
  stderr: 'tmpg57skmb1/tmpg57skmb1.swift:71: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b5a49721c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b5a49418b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b5a49418988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b5a494177b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpg57skmb1                        0x0000562a5db48810 <unavailable> + 6160

    5    libc.so.6                          0x00002b5a4990d460 __libc_start_main +
    245

    6    tmpg57skmb1                        0x0000562a5db48289 <unavailable> + 4745

    '
  stdout: ''
  timestamp: 1659979533
- exit_code: -4
  program: "\n/// You are given an array of two strings, both strings consist of open\n\
    /// parentheses '(' or close parentheses ')' only.\n/// Your job is to check if\
    \ it is possible to concatenate the two strings in\n/// some order, that the resulting\
    \ string will be good.\n/// A string S is considered to be good if and only if\
    \ all parentheses in S\n/// are balanced. For example: the string '(())()' is\
    \ good, while the string\n/// '())' is not.\n/// Return 'Yes' if there's a way\
    \ to make a good string, and return 'No' otherwise.\n/// Examples:\n/// >>> match_parens(lst:\
    \ [\"()(\", \")\"])\n/// \"Yes\"\n/// >>> match_parens(lst: [\")\", \")\"])\n\
    /// \"No\"\nfunc match_parens(lst: [String]) -> String {\n    var r: Int = 0\n\
    \    for ch in lst[0] {\n        if ch == \"(\" {\n            r += 1\n      \
    \  } else {\n            r -= 1\n        }\n    }\n    for ch in lst[1] {\n  \
    \      if ch == \"(\" {\n            r += 1\n        } else {\n            r -=\
    \ 1\n        }\n    }\n    if r == 0 {\n        return \"Yes\"\n    }\n    return\
    \ \"No\"\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n\
    \    if left.count != right.count {\n        return false\n    }\n    for (l,\
    \ r) in zip(left, right) {\n        if l != r {\n            return false\n  \
    \      }\n    }\n    return true\n}\n            \nassert(match_parens(lst: [\"\
    ()(\", \")\"]) == \"Yes\")\nassert(match_parens(lst: [\")\", \")\"]) == \"No\"\
    )\nassert(match_parens(lst: [\"(()(())\", \"())())\"]) == \"No\")\nassert(match_parens(lst:\
    \ [\")())\", \"(()()(\"]) == \"Yes\")\nassert(match_parens(lst: [\"(())))\", \"\
    (()())((\"]) == \"Yes\")\nassert(match_parens(lst: [\"()\", \"())\"]) == \"No\"\
    )\nassert(match_parens(lst: [\"(()(\", \"()))()\"]) == \"Yes\")\nassert(match_parens(lst:\
    \ [\"((((\", \"((())\"]) == \"No\")\nassert(match_parens(lst: [\")(()\", \"(()(\"\
    ]) == \"No\")\nassert(match_parens(lst: [\")(\", \")(\"]) == \"No\")\nassert(match_parens(lst:\
    \ [\"(\", \")\"]) == \"Yes\")\nassert(match_parens(lst: [\")\", \"(\"]) == \"\
    Yes\")"
  status: Exception
  stderr: 'tmpi0j699ht/tmpi0j699ht.swift:59: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b90effb8c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b90efcafb6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b90efcaf988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b90efcae7b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpi0j699ht                        0x000055fb53722468 <unavailable> + 9320

    5    libc.so.6                          0x00002b90f01a4460 __libc_start_main +
    245

    6    tmpi0j699ht                        0x000055fb53721289 <unavailable> + 4745

    '
  stdout: ''
  timestamp: 1659979533
- exit_code: -4
  program: "\n/// You are given an array of two strings, both strings consist of open\n\
    /// parentheses '(' or close parentheses ')' only.\n/// Your job is to check if\
    \ it is possible to concatenate the two strings in\n/// some order, that the resulting\
    \ string will be good.\n/// A string S is considered to be good if and only if\
    \ all parentheses in S\n/// are balanced. For example: the string '(())()' is\
    \ good, while the string\n/// '())' is not.\n/// Return 'Yes' if there's a way\
    \ to make a good string, and return 'No' otherwise.\n/// Examples:\n/// >>> match_parens(lst:\
    \ [\"()(\", \")\"])\n/// \"Yes\"\n/// >>> match_parens(lst: [\")\", \")\"])\n\
    /// \"No\"\nfunc match_parens(lst: [String]) -> String {\n  var s = \"\"\n  for\
    \ str in lst {\n    s += str\n  }\n  var balance = 0\n  for character in s {\n\
    \    if character == \"(\" {\n      balance += 1\n    } else {\n      balance\
    \ -= 1\n    }\n    if balance < 0 {\n      return \"No\"\n    }\n  }\n  return\
    \ \"Yes\"\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n\
    \    if left.count != right.count {\n        return false\n    }\n    for (l,\
    \ r) in zip(left, right) {\n        if l != r {\n            return false\n  \
    \      }\n    }\n    return true\n}\n            \nassert(match_parens(lst: [\"\
    ()(\", \")\"]) == \"Yes\")\nassert(match_parens(lst: [\")\", \")\"]) == \"No\"\
    )\nassert(match_parens(lst: [\"(()(())\", \"())())\"]) == \"No\")\nassert(match_parens(lst:\
    \ [\")())\", \"(()()(\"]) == \"Yes\")\nassert(match_parens(lst: [\"(())))\", \"\
    (()())((\"]) == \"Yes\")\nassert(match_parens(lst: [\"()\", \"())\"]) == \"No\"\
    )\nassert(match_parens(lst: [\"(()(\", \"()))()\"]) == \"Yes\")\nassert(match_parens(lst:\
    \ [\"((((\", \"((())\"]) == \"No\")\nassert(match_parens(lst: [\")(()\", \"(()(\"\
    ]) == \"No\")\nassert(match_parens(lst: [\")(\", \")(\"]) == \"No\")\nassert(match_parens(lst:\
    \ [\"(\", \")\"]) == \"Yes\")\nassert(match_parens(lst: [\")\", \"(\"]) == \"\
    Yes\")"
  status: Exception
  stderr: 'tmpit0f_0h9/tmpit0f_0h9.swift:50: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002aafb9dffc80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002aafb9af6b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002aafb9af6988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002aafb9af57b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpit0f_0h9                        0x000055ebc19f8c96 <unavailable> + 7318

    5    libc.so.6                          0x00002aafb9feb460 __libc_start_main +
    245

    6    tmpit0f_0h9                        0x000055ebc19f83f9 <unavailable> + 5113

    '
  stdout: ''
  timestamp: 1659979533
- exit_code: -1
  program: "\n/// You are given an array of two strings, both strings consist of open\n\
    /// parentheses '(' or close parentheses ')' only.\n/// Your job is to check if\
    \ it is possible to concatenate the two strings in\n/// some order, that the resulting\
    \ string will be good.\n/// A string S is considered to be good if and only if\
    \ all parentheses in S\n/// are balanced. For example: the string '(())()' is\
    \ good, while the string\n/// '())' is not.\n/// Return 'Yes' if there's a way\
    \ to make a good string, and return 'No' otherwise.\n/// Examples:\n/// >>> match_parens(lst:\
    \ [\"()(\", \")\"])\n/// \"Yes\"\n/// >>> match_parens(lst: [\")\", \")\"])\n\
    /// \"No\"\nfunc match_parens(lst: [String]) -> String {\n    var lst = lst\n\
    \    var lst_count = [Int]()\n    while lst.count > 0 {\n        var str = \"\"\
    \n        for ch in lst[0] {\n            if ch == \"(\" {\n                str\
    \ += \")\"\n            } else {\n                str += \"(\"\n            }\n\
    \        }\n        lst.append(str)\n        lst.remove(at: 0)\n        lst_count.append(0)\n\
    \    }\n    for i in lst_count.indices {\n        for j in lst[i].indices {\n\
    \            if lst[i][j] == \"(\" {\n                lst_count[i] += 1\n    \
    \        } else {\n                lst_count[i] -= 1\n            }\n        \
    \    if lst_count[i] < 0 {\n                return \"No\"\n            }\n   \
    \     }\n    }\n    return \"Yes\"\n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(match_parens(lst: [\"()(\", \")\"]) == \"Yes\")\nassert(match_parens(lst:\
    \ [\")\", \")\"]) == \"No\")\nassert(match_parens(lst: [\"(()(())\", \"())())\"\
    ]) == \"No\")\nassert(match_parens(lst: [\")())\", \"(()()(\"]) == \"Yes\")\n\
    assert(match_parens(lst: [\"(())))\", \"(()())((\"]) == \"Yes\")\nassert(match_parens(lst:\
    \ [\"()\", \"())\"]) == \"No\")\nassert(match_parens(lst: [\"(()(\", \"()))()\"\
    ]) == \"Yes\")\nassert(match_parens(lst: [\"((((\", \"((())\"]) == \"No\")\nassert(match_parens(lst:\
    \ [\")(()\", \"(()(\"]) == \"No\")\nassert(match_parens(lst: [\")(\", \")(\"])\
    \ == \"No\")\nassert(match_parens(lst: [\"(\", \")\"]) == \"Yes\")\nassert(match_parens(lst:\
    \ [\")\", \"(\"]) == \"Yes\")"
  status: Timeout
  stderr: ''
  stdout: ''
  timestamp: 1659979538
- exit_code: -4
  program: "\n/// You are given an array of two strings, both strings consist of open\n\
    /// parentheses '(' or close parentheses ')' only.\n/// Your job is to check if\
    \ it is possible to concatenate the two strings in\n/// some order, that the resulting\
    \ string will be good.\n/// A string S is considered to be good if and only if\
    \ all parentheses in S\n/// are balanced. For example: the string '(())()' is\
    \ good, while the string\n/// '())' is not.\n/// Return 'Yes' if there's a way\
    \ to make a good string, and return 'No' otherwise.\n/// Examples:\n/// >>> match_parens(lst:\
    \ [\"()(\", \")\"])\n/// \"Yes\"\n/// >>> match_parens(lst: [\")\", \")\"])\n\
    /// \"No\"\nfunc match_parens(lst: [String]) -> String {\n    let string1 = lst[0]\n\
    \    let string2 = lst[1]\n    var numOpen = 0\n    var numClose = 0\n    for\
    \ i in string1 {\n        if i == \"(\" {\n            numOpen += 1\n        }\
    \ else {\n            numClose += 1\n        }\n    }\n    for i in string2 {\n\
    \        if i == \"(\" {\n            numOpen += 1\n        } else {\n       \
    \     numClose += 1\n        }\n    }\n    if numOpen == numClose {\n        return\
    \ \"Yes\"\n    } else {\n        return \"No\"\n    }\n}\n\n\nfunc ==(left: [(Int,\
    \ Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n\
    \        return false\n    }\n    for (l, r) in zip(left, right) {\n        if\
    \ l != r {\n            return false\n        }\n    }\n    return true\n}\n \
    \           \nassert(match_parens(lst: [\"()(\", \")\"]) == \"Yes\")\nassert(match_parens(lst:\
    \ [\")\", \")\"]) == \"No\")\nassert(match_parens(lst: [\"(()(())\", \"())())\"\
    ]) == \"No\")\nassert(match_parens(lst: [\")())\", \"(()()(\"]) == \"Yes\")\n\
    assert(match_parens(lst: [\"(())))\", \"(()())((\"]) == \"Yes\")\nassert(match_parens(lst:\
    \ [\"()\", \"())\"]) == \"No\")\nassert(match_parens(lst: [\"(()(\", \"()))()\"\
    ]) == \"Yes\")\nassert(match_parens(lst: [\"((((\", \"((())\"]) == \"No\")\nassert(match_parens(lst:\
    \ [\")(()\", \"(()(\"]) == \"No\")\nassert(match_parens(lst: [\")(\", \")(\"])\
    \ == \"No\")\nassert(match_parens(lst: [\"(\", \")\"]) == \"Yes\")\nassert(match_parens(lst:\
    \ [\")\", \"(\"]) == \"Yes\")"
  status: Exception
  stderr: 'tmpgdngmort/tmpgdngmort.swift:63: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b985ae9ec80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b985ab95b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b985ab95988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b985ab947b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpgdngmort                        0x000055d4549df468 <unavailable> + 9320

    5    libc.so.6                          0x00002b985b08a460 __libc_start_main +
    245

    6    tmpgdngmort                        0x000055d4549de289 <unavailable> + 4745

    '
  stdout: ''
  timestamp: 1659979533
- exit_code: -4
  program: "\n/// You are given an array of two strings, both strings consist of open\n\
    /// parentheses '(' or close parentheses ')' only.\n/// Your job is to check if\
    \ it is possible to concatenate the two strings in\n/// some order, that the resulting\
    \ string will be good.\n/// A string S is considered to be good if and only if\
    \ all parentheses in S\n/// are balanced. For example: the string '(())()' is\
    \ good, while the string\n/// '())' is not.\n/// Return 'Yes' if there's a way\
    \ to make a good string, and return 'No' otherwise.\n/// Examples:\n/// >>> match_parens(lst:\
    \ [\"()(\", \")\"])\n/// \"Yes\"\n/// >>> match_parens(lst: [\")\", \")\"])\n\
    /// \"No\"\nfunc match_parens(lst: [String]) -> String {\n    let str1 = lst[0],\
    \ str2 = lst[1]\n    let openParens = Character(\"(\")\n    var openCount = 0\n\
    \    for char in str1 {\n        if char == openParens {\n            openCount\
    \ += 1\n        } else {\n            openCount -= 1\n        }\n    }\n    for\
    \ char in str2 {\n        if char == openParens {\n            openCount += 1\n\
    \        } else {\n            openCount -= 1\n        }\n    }\n    return openCount\
    \ == 0 ? \"Yes\" : \"No\"\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(match_parens(lst:\
    \ [\"()(\", \")\"]) == \"Yes\")\nassert(match_parens(lst: [\")\", \")\"]) == \"\
    No\")\nassert(match_parens(lst: [\"(()(())\", \"())())\"]) == \"No\")\nassert(match_parens(lst:\
    \ [\")())\", \"(()()(\"]) == \"Yes\")\nassert(match_parens(lst: [\"(())))\", \"\
    (()())((\"]) == \"Yes\")\nassert(match_parens(lst: [\"()\", \"())\"]) == \"No\"\
    )\nassert(match_parens(lst: [\"(()(\", \"()))()\"]) == \"Yes\")\nassert(match_parens(lst:\
    \ [\"((((\", \"((())\"]) == \"No\")\nassert(match_parens(lst: [\")(()\", \"(()(\"\
    ]) == \"No\")\nassert(match_parens(lst: [\")(\", \")(\"]) == \"No\")\nassert(match_parens(lst:\
    \ [\"(\", \")\"]) == \"Yes\")\nassert(match_parens(lst: [\")\", \"(\"]) == \"\
    Yes\")"
  status: Exception
  stderr: 'tmp99s_tupq/tmp99s_tupq.swift:58: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002ab32eefcc80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002ab32ebf3b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002ab32ebf3988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002ab32ebf27b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmp99s_tupq                        0x00005643edba6468 <unavailable> + 9320

    5    libc.so.6                          0x00002ab32f0e8460 __libc_start_main +
    245

    6    tmp99s_tupq                        0x00005643edba5289 <unavailable> + 4745

    '
  stdout: ''
  timestamp: 1659979533
- exit_code: 1
  program: "\n/// You are given an array of two strings, both strings consist of open\n\
    /// parentheses '(' or close parentheses ')' only.\n/// Your job is to check if\
    \ it is possible to concatenate the two strings in\n/// some order, that the resulting\
    \ string will be good.\n/// A string S is considered to be good if and only if\
    \ all parentheses in S\n/// are balanced. For example: the string '(())()' is\
    \ good, while the string\n/// '())' is not.\n/// Return 'Yes' if there's a way\
    \ to make a good string, and return 'No' otherwise.\n/// Examples:\n/// >>> match_parens(lst:\
    \ [\"()(\", \")\"])\n/// \"Yes\"\n/// >>> match_parens(lst: [\")\", \")\"])\n\
    /// \"No\"\nfunc match_parens(lst: [String]) -> String {\n  guard lst.count ==\
    \ 2 else { return \"No\" }\n  let str1 = lst[0]\n  let str2 = lst[1]\n  if str1.isGood()\
    \ && str2.isGood() {\n    return \"Yes\"\n  }\n  return \"No\"\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(match_parens(lst: [\"()(\", \")\"]) == \"Yes\")\nassert(match_parens(lst:\
    \ [\")\", \")\"]) == \"No\")\nassert(match_parens(lst: [\"(()(())\", \"())())\"\
    ]) == \"No\")\nassert(match_parens(lst: [\")())\", \"(()()(\"]) == \"Yes\")\n\
    assert(match_parens(lst: [\"(())))\", \"(()())((\"]) == \"Yes\")\nassert(match_parens(lst:\
    \ [\"()\", \"())\"]) == \"No\")\nassert(match_parens(lst: [\"(()(\", \"()))()\"\
    ]) == \"Yes\")\nassert(match_parens(lst: [\"((((\", \"((())\"]) == \"No\")\nassert(match_parens(lst:\
    \ [\")(()\", \"(()(\"]) == \"No\")\nassert(match_parens(lst: [\")(\", \")(\"])\
    \ == \"No\")\nassert(match_parens(lst: [\"(\", \")\"]) == \"Yes\")\nassert(match_parens(lst:\
    \ [\")\", \"(\"]) == \"Yes\")"
  status: SyntaxError
  stderr: "/tmp/tmpp4g9ef1c.swift:19:11: error: value of type 'String' has no member\
    \ 'isGood'\n  if str1.isGood() && str2.isGood() {\n     ~~~~ ^~~~~~\n/tmp/tmpp4g9ef1c.swift:19:28:\
    \ error: value of type 'String' has no member 'isGood'\n  if str1.isGood() &&\
    \ str2.isGood() {\n                      ~~~~ ^~~~~~\n"
  stdout: ''
  timestamp: 1659979533
- exit_code: 1
  program: "\n/// You are given an array of two strings, both strings consist of open\n\
    /// parentheses '(' or close parentheses ')' only.\n/// Your job is to check if\
    \ it is possible to concatenate the two strings in\n/// some order, that the resulting\
    \ string will be good.\n/// A string S is considered to be good if and only if\
    \ all parentheses in S\n/// are balanced. For example: the string '(())()' is\
    \ good, while the string\n/// '())' is not.\n/// Return 'Yes' if there's a way\
    \ to make a good string, and return 'No' otherwise.\n/// Examples:\n/// >>> match_parens(lst:\
    \ [\"()(\", \")\"])\n/// \"Yes\"\n/// >>> match_parens(lst: [\")\", \")\"])\n\
    /// \"No\"\nfunc match_parens(lst: [String]) -> String {\n    return lst.reduce(\"\
    \") { $0 + $1 }.is_balanced ? \"Yes\" : \"No\"\n}\n\n\nfunc ==(left: [(Int, Int)],\
    \ right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n       \
    \ return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r\
    \ {\n            return false\n        }\n    }\n    return true\n}\n        \
    \    \nassert(match_parens(lst: [\"()(\", \")\"]) == \"Yes\")\nassert(match_parens(lst:\
    \ [\")\", \")\"]) == \"No\")\nassert(match_parens(lst: [\"(()(())\", \"())())\"\
    ]) == \"No\")\nassert(match_parens(lst: [\")())\", \"(()()(\"]) == \"Yes\")\n\
    assert(match_parens(lst: [\"(())))\", \"(()())((\"]) == \"Yes\")\nassert(match_parens(lst:\
    \ [\"()\", \"())\"]) == \"No\")\nassert(match_parens(lst: [\"(()(\", \"()))()\"\
    ]) == \"Yes\")\nassert(match_parens(lst: [\"((((\", \"((())\"]) == \"No\")\nassert(match_parens(lst:\
    \ [\")(()\", \"(()(\"]) == \"No\")\nassert(match_parens(lst: [\")(\", \")(\"])\
    \ == \"No\")\nassert(match_parens(lst: [\"(\", \")\"]) == \"Yes\")\nassert(match_parens(lst:\
    \ [\")\", \"(\"]) == \"Yes\")"
  status: SyntaxError
  stderr: "/tmp/tmpk_q2sw6f.swift:16:39: error: value of type 'String' has no member\
    \ 'is_balanced'\n    return lst.reduce(\"\") { $0 + $1 }.is_balanced ? \"Yes\"\
    \ : \"No\"\n           ~~~~~~~~~~~~~~~~~~~~~~~~~~ ^~~~~~~~~~~\n"
  stdout: ''
  timestamp: 1659979533
- exit_code: -4
  program: "\n/// You are given an array of two strings, both strings consist of open\n\
    /// parentheses '(' or close parentheses ')' only.\n/// Your job is to check if\
    \ it is possible to concatenate the two strings in\n/// some order, that the resulting\
    \ string will be good.\n/// A string S is considered to be good if and only if\
    \ all parentheses in S\n/// are balanced. For example: the string '(())()' is\
    \ good, while the string\n/// '())' is not.\n/// Return 'Yes' if there's a way\
    \ to make a good string, and return 'No' otherwise.\n/// Examples:\n/// >>> match_parens(lst:\
    \ [\"()(\", \")\"])\n/// \"Yes\"\n/// >>> match_parens(lst: [\")\", \")\"])\n\
    /// \"No\"\nfunc match_parens(lst: [String]) -> String {\n    return \"No\"\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(match_parens(lst: [\"()(\", \")\"]) == \"Yes\"\
    )\nassert(match_parens(lst: [\")\", \")\"]) == \"No\")\nassert(match_parens(lst:\
    \ [\"(()(())\", \"())())\"]) == \"No\")\nassert(match_parens(lst: [\")())\", \"\
    (()()(\"]) == \"Yes\")\nassert(match_parens(lst: [\"(())))\", \"(()())((\"]) ==\
    \ \"Yes\")\nassert(match_parens(lst: [\"()\", \"())\"]) == \"No\")\nassert(match_parens(lst:\
    \ [\"(()(\", \"()))()\"]) == \"Yes\")\nassert(match_parens(lst: [\"((((\", \"\
    ((())\"]) == \"No\")\nassert(match_parens(lst: [\")(()\", \"(()(\"]) == \"No\"\
    )\nassert(match_parens(lst: [\")(\", \")(\"]) == \"No\")\nassert(match_parens(lst:\
    \ [\"(\", \")\"]) == \"Yes\")\nassert(match_parens(lst: [\")\", \"(\"]) == \"\
    Yes\")"
  status: Exception
  stderr: 'tmpcvhfyhzs/tmpcvhfyhzs.swift:32: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b5b3b60ec80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b5b3b305b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b5b3b305988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b5b3b3047b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpcvhfyhzs                        0x000055701b3de4a6 <unavailable> + 5286

    5    libc.so.6                          0x00002b5b3b7fa460 __libc_start_main +
    245

    6    tmpcvhfyhzs                        0x000055701b3de089 <unavailable> + 4233

    '
  stdout: ''
  timestamp: 1659979532
- exit_code: -4
  program: "\n/// You are given an array of two strings, both strings consist of open\n\
    /// parentheses '(' or close parentheses ')' only.\n/// Your job is to check if\
    \ it is possible to concatenate the two strings in\n/// some order, that the resulting\
    \ string will be good.\n/// A string S is considered to be good if and only if\
    \ all parentheses in S\n/// are balanced. For example: the string '(())()' is\
    \ good, while the string\n/// '())' is not.\n/// Return 'Yes' if there's a way\
    \ to make a good string, and return 'No' otherwise.\n/// Examples:\n/// >>> match_parens(lst:\
    \ [\"()(\", \")\"])\n/// \"Yes\"\n/// >>> match_parens(lst: [\")\", \")\"])\n\
    /// \"No\"\nfunc match_parens(lst: [String]) -> String {\n    var stack = [String]()\n\
    \    for str in lst {\n        for char in str {\n            if char == \"(\"\
    \ {\n                stack.append(\"(\")\n            } else {\n             \
    \   if stack.count == 0 {\n                    return \"No\"\n               \
    \ } else {\n                    stack.removeLast()\n                }\n      \
    \      }\n        }\n    }\n    return stack.count == 0 ? \"Yes\" : \"No\"\n}\n\
    \n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(match_parens(lst: [\"()(\", \")\"]) == \"Yes\"\
    )\nassert(match_parens(lst: [\")\", \")\"]) == \"No\")\nassert(match_parens(lst:\
    \ [\"(()(())\", \"())())\"]) == \"No\")\nassert(match_parens(lst: [\")())\", \"\
    (()()(\"]) == \"Yes\")\nassert(match_parens(lst: [\"(())))\", \"(()())((\"]) ==\
    \ \"Yes\")\nassert(match_parens(lst: [\"()\", \"())\"]) == \"No\")\nassert(match_parens(lst:\
    \ [\"(()(\", \"()))()\"]) == \"Yes\")\nassert(match_parens(lst: [\"((((\", \"\
    ((())\"]) == \"No\")\nassert(match_parens(lst: [\")(()\", \"(()(\"]) == \"No\"\
    )\nassert(match_parens(lst: [\")(\", \")(\"]) == \"No\")\nassert(match_parens(lst:\
    \ [\"(\", \")\"]) == \"Yes\")\nassert(match_parens(lst: [\")\", \"(\"]) == \"\
    Yes\")"
  status: Exception
  stderr: 'tmp_efqikz3/tmp_efqikz3.swift:49: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002ba0aef12c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002ba0aec09b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002ba0aec09988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002ba0aec087b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmp_efqikz3                        0x0000557d8e8cee26 <unavailable> + 7718

    5    libc.so.6                          0x00002ba0af0fe460 __libc_start_main +
    245

    6    tmp_efqikz3                        0x0000557d8e8ce589 <unavailable> + 5513

    '
  stdout: ''
  timestamp: 1659979533
- exit_code: -4
  program: "\n/// You are given an array of two strings, both strings consist of open\n\
    /// parentheses '(' or close parentheses ')' only.\n/// Your job is to check if\
    \ it is possible to concatenate the two strings in\n/// some order, that the resulting\
    \ string will be good.\n/// A string S is considered to be good if and only if\
    \ all parentheses in S\n/// are balanced. For example: the string '(())()' is\
    \ good, while the string\n/// '())' is not.\n/// Return 'Yes' if there's a way\
    \ to make a good string, and return 'No' otherwise.\n/// Examples:\n/// >>> match_parens(lst:\
    \ [\"()(\", \")\"])\n/// \"Yes\"\n/// >>> match_parens(lst: [\")\", \")\"])\n\
    /// \"No\"\nfunc match_parens(lst: [String]) -> String {\n    let firstStr = lst[0]\n\
    \    let secondStr = lst[1]\n    var firstLeft = 0\n    var firstRight = 0\n \
    \   var secondLeft = 0\n    var secondRight = 0\n    for char in firstStr {\n\
    \        if char == \"(\" {\n            firstLeft += 1\n        } else {\n  \
    \          firstRight += 1\n        }\n    }\n    for char in secondStr {\n  \
    \      if char == \"(\" {\n            secondLeft += 1\n        } else {\n   \
    \         secondRight += 1\n        }\n    }\n    let firstDiff = firstLeft -\
    \ firstRight\n    let secondDiff = secondLeft - secondRight\n    if firstDiff\
    \ < 0 && secondDiff < 0 {\n        return \"No\"\n    } else if (firstDiff < 0\
    \ && secondDiff > 0) || (firstDiff > 0 && secondDiff < 0) {\n        return \"\
    Yes\"\n    } else {\n        return \"No\"\n    }\n}\n\n\nfunc ==(left: [(Int,\
    \ Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n\
    \        return false\n    }\n    for (l, r) in zip(left, right) {\n        if\
    \ l != r {\n            return false\n        }\n    }\n    return true\n}\n \
    \           \nassert(match_parens(lst: [\"()(\", \")\"]) == \"Yes\")\nassert(match_parens(lst:\
    \ [\")\", \")\"]) == \"No\")\nassert(match_parens(lst: [\"(()(())\", \"())())\"\
    ]) == \"No\")\nassert(match_parens(lst: [\")())\", \"(()()(\"]) == \"Yes\")\n\
    assert(match_parens(lst: [\"(())))\", \"(()())((\"]) == \"Yes\")\nassert(match_parens(lst:\
    \ [\"()\", \"())\"]) == \"No\")\nassert(match_parens(lst: [\"(()(\", \"()))()\"\
    ]) == \"Yes\")\nassert(match_parens(lst: [\"((((\", \"((())\"]) == \"No\")\nassert(match_parens(lst:\
    \ [\")(()\", \"(()(\"]) == \"No\")\nassert(match_parens(lst: [\")(\", \")(\"])\
    \ == \"No\")\nassert(match_parens(lst: [\"(\", \")\"]) == \"Yes\")\nassert(match_parens(lst:\
    \ [\")\", \"(\"]) == \"Yes\")"
  status: Exception
  stderr: 'tmpd6ynwxv0/tmpd6ynwxv0.swift:62: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b92cbca4c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b92cb99bb6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b92cb99b988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b92cb99a7b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpd6ynwxv0                        0x000055f22855c99b <unavailable> + 6555

    5    libc.so.6                          0x00002b92cbe90460 __libc_start_main +
    245

    6    tmpd6ynwxv0                        0x000055f22855c289 <unavailable> + 4745

    '
  stdout: ''
  timestamp: 1659979533
- exit_code: -4
  program: "\n/// You are given an array of two strings, both strings consist of open\n\
    /// parentheses '(' or close parentheses ')' only.\n/// Your job is to check if\
    \ it is possible to concatenate the two strings in\n/// some order, that the resulting\
    \ string will be good.\n/// A string S is considered to be good if and only if\
    \ all parentheses in S\n/// are balanced. For example: the string '(())()' is\
    \ good, while the string\n/// '())' is not.\n/// Return 'Yes' if there's a way\
    \ to make a good string, and return 'No' otherwise.\n/// Examples:\n/// >>> match_parens(lst:\
    \ [\"()(\", \")\"])\n/// \"Yes\"\n/// >>> match_parens(lst: [\")\", \")\"])\n\
    /// \"No\"\nfunc match_parens(lst: [String]) -> String {\n    var left = 0\n \
    \   var right = 0\n    for i in lst[0] {\n        if i == \"(\" {\n          \
    \  left += 1\n        } else {\n            right += 1\n        }\n    }\n   \
    \ for i in lst[1] {\n        if i == \"(\" {\n            left -= 1\n        }\
    \ else {\n            right -= 1\n        }\n    }\n    if left != 0 || right\
    \ != 0 {\n        return \"No\"\n    }\n    return \"Yes\"\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(match_parens(lst: [\"()(\", \")\"]) == \"Yes\")\nassert(match_parens(lst:\
    \ [\")\", \")\"]) == \"No\")\nassert(match_parens(lst: [\"(()(())\", \"())())\"\
    ]) == \"No\")\nassert(match_parens(lst: [\")())\", \"(()()(\"]) == \"Yes\")\n\
    assert(match_parens(lst: [\"(())))\", \"(()())((\"]) == \"Yes\")\nassert(match_parens(lst:\
    \ [\"()\", \"())\"]) == \"No\")\nassert(match_parens(lst: [\"(()(\", \"()))()\"\
    ]) == \"Yes\")\nassert(match_parens(lst: [\"((((\", \"((())\"]) == \"No\")\nassert(match_parens(lst:\
    \ [\")(()\", \"(()(\"]) == \"No\")\nassert(match_parens(lst: [\")(\", \")(\"])\
    \ == \"No\")\nassert(match_parens(lst: [\"(\", \")\"]) == \"Yes\")\nassert(match_parens(lst:\
    \ [\")\", \"(\"]) == \"Yes\")"
  status: Exception
  stderr: 'tmpsqvvpiwt/tmpsqvvpiwt.swift:51: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b0afdef7c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b0afdbeeb6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b0afdbee988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b0afdbed7b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpsqvvpiwt                        0x0000561ead0196a6 <unavailable> + 5798

    5    libc.so.6                          0x00002b0afe0e3460 __libc_start_main +
    245

    6    tmpsqvvpiwt                        0x0000561ead019289 <unavailable> + 4745

    '
  stdout: ''
  timestamp: 1659979533
- exit_code: 1
  program: "\n/// You are given an array of two strings, both strings consist of open\n\
    /// parentheses '(' or close parentheses ')' only.\n/// Your job is to check if\
    \ it is possible to concatenate the two strings in\n/// some order, that the resulting\
    \ string will be good.\n/// A string S is considered to be good if and only if\
    \ all parentheses in S\n/// are balanced. For example: the string '(())()' is\
    \ good, while the string\n/// '())' is not.\n/// Return 'Yes' if there's a way\
    \ to make a good string, and return 'No' otherwise.\n/// Examples:\n/// >>> match_parens(lst:\
    \ [\"()(\", \")\"])\n/// \"Yes\"\n/// >>> match_parens(lst: [\")\", \")\"])\n\
    /// \"No\"\nfunc match_parens(lst: [String]) -> String {\n    let first = lst[0]\n\
    \    let second = lst[1]\n    // there is a way to make a good string if and only\
    \ if the number of\n    // open parentheses in the first string is the same as\
    \ the number of\n    // closed parentheses in the second string\n    if lst[0].count(of:\
    \ \"(\") == lst[1].count(of: \")\") {\n        return \"Yes\"\n    }\n    return\
    \ \"No\"\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n\
    \    if left.count != right.count {\n        return false\n    }\n    for (l,\
    \ r) in zip(left, right) {\n        if l != r {\n            return false\n  \
    \      }\n    }\n    return true\n}\n            \nassert(match_parens(lst: [\"\
    ()(\", \")\"]) == \"Yes\")\nassert(match_parens(lst: [\")\", \")\"]) == \"No\"\
    )\nassert(match_parens(lst: [\"(()(())\", \"())())\"]) == \"No\")\nassert(match_parens(lst:\
    \ [\")())\", \"(()()(\"]) == \"Yes\")\nassert(match_parens(lst: [\"(())))\", \"\
    (()())((\"]) == \"Yes\")\nassert(match_parens(lst: [\"()\", \"())\"]) == \"No\"\
    )\nassert(match_parens(lst: [\"(()(\", \"()))()\"]) == \"Yes\")\nassert(match_parens(lst:\
    \ [\"((((\", \"((())\"]) == \"No\")\nassert(match_parens(lst: [\")(()\", \"(()(\"\
    ]) == \"No\")\nassert(match_parens(lst: [\")(\", \")(\"]) == \"No\")\nassert(match_parens(lst:\
    \ [\"(\", \")\"]) == \"Yes\")\nassert(match_parens(lst: [\")\", \"(\"]) == \"\
    Yes\")"
  status: SyntaxError
  stderr: "/tmp/tmp5_r1v3nf.swift:21:15: error: cannot call value of non-function\
    \ type 'Int'\n    if lst[0].count(of: \"(\") == lst[1].count(of: \")\") {\n  \
    \            ^\n/tmp/tmp5_r1v3nf.swift:21:40: error: cannot call value of non-function\
    \ type 'Int'\n    if lst[0].count(of: \"(\") == lst[1].count(of: \")\") {\n  \
    \                                     ^\n"
  stdout: ''
  timestamp: 1659979533
- exit_code: -4
  program: "\n/// You are given an array of two strings, both strings consist of open\n\
    /// parentheses '(' or close parentheses ')' only.\n/// Your job is to check if\
    \ it is possible to concatenate the two strings in\n/// some order, that the resulting\
    \ string will be good.\n/// A string S is considered to be good if and only if\
    \ all parentheses in S\n/// are balanced. For example: the string '(())()' is\
    \ good, while the string\n/// '())' is not.\n/// Return 'Yes' if there's a way\
    \ to make a good string, and return 'No' otherwise.\n/// Examples:\n/// >>> match_parens(lst:\
    \ [\"()(\", \")\"])\n/// \"Yes\"\n/// >>> match_parens(lst: [\")\", \")\"])\n\
    /// \"No\"\nfunc match_parens(lst: [String]) -> String {\n  // YOUR CODE HERE\n\
    \  return \"\"\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool\
    \ {\n    if left.count != right.count {\n        return false\n    }\n    for\
    \ (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(match_parens(lst:\
    \ [\"()(\", \")\"]) == \"Yes\")\nassert(match_parens(lst: [\")\", \")\"]) == \"\
    No\")\nassert(match_parens(lst: [\"(()(())\", \"())())\"]) == \"No\")\nassert(match_parens(lst:\
    \ [\")())\", \"(()()(\"]) == \"Yes\")\nassert(match_parens(lst: [\"(())))\", \"\
    (()())((\"]) == \"Yes\")\nassert(match_parens(lst: [\"()\", \"())\"]) == \"No\"\
    )\nassert(match_parens(lst: [\"(()(\", \"()))()\"]) == \"Yes\")\nassert(match_parens(lst:\
    \ [\"((((\", \"((())\"]) == \"No\")\nassert(match_parens(lst: [\")(()\", \"(()(\"\
    ]) == \"No\")\nassert(match_parens(lst: [\")(\", \")(\"]) == \"No\")\nassert(match_parens(lst:\
    \ [\"(\", \")\"]) == \"Yes\")\nassert(match_parens(lst: [\")\", \"(\"]) == \"\
    Yes\")"
  status: Exception
  stderr: 'tmppl3mosyi/tmppl3mosyi.swift:33: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b7590ceac80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b75909e1b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b75909e1988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b75909e07b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmppl3mosyi                        0x0000558fe52834a6 <unavailable> + 5286

    5    libc.so.6                          0x00002b7590ed6460 __libc_start_main +
    245

    6    tmppl3mosyi                        0x0000558fe5283089 <unavailable> + 4233

    '
  stdout: ''
  timestamp: 1659979533
- exit_code: 1
  program: "\n/// You are given an array of two strings, both strings consist of open\n\
    /// parentheses '(' or close parentheses ')' only.\n/// Your job is to check if\
    \ it is possible to concatenate the two strings in\n/// some order, that the resulting\
    \ string will be good.\n/// A string S is considered to be good if and only if\
    \ all parentheses in S\n/// are balanced. For example: the string '(())()' is\
    \ good, while the string\n/// '())' is not.\n/// Return 'Yes' if there's a way\
    \ to make a good string, and return 'No' otherwise.\n/// Examples:\n/// >>> match_parens(lst:\
    \ [\"()(\", \")\"])\n/// \"Yes\"\n/// >>> match_parens(lst: [\")\", \")\"])\n\
    /// \"No\"\nfunc match_parens(lst: [String]) -> String {\n    var s = \"\"\n \
    \   for str in lst {\n        s += str\n    }\n    return is_good(s: s) ? \"Yes\"\
    \ : \"No\"\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n\
    \    if left.count != right.count {\n        return false\n    }\n    for (l,\
    \ r) in zip(left, right) {\n        if l != r {\n            return false\n  \
    \      }\n    }\n    return true\n}\n            \nassert(match_parens(lst: [\"\
    ()(\", \")\"]) == \"Yes\")\nassert(match_parens(lst: [\")\", \")\"]) == \"No\"\
    )\nassert(match_parens(lst: [\"(()(())\", \"())())\"]) == \"No\")\nassert(match_parens(lst:\
    \ [\")())\", \"(()()(\"]) == \"Yes\")\nassert(match_parens(lst: [\"(())))\", \"\
    (()())((\"]) == \"Yes\")\nassert(match_parens(lst: [\"()\", \"())\"]) == \"No\"\
    )\nassert(match_parens(lst: [\"(()(\", \"()))()\"]) == \"Yes\")\nassert(match_parens(lst:\
    \ [\"((((\", \"((())\"]) == \"No\")\nassert(match_parens(lst: [\")(()\", \"(()(\"\
    ]) == \"No\")\nassert(match_parens(lst: [\")(\", \")(\"]) == \"No\")\nassert(match_parens(lst:\
    \ [\"(\", \")\"]) == \"Yes\")\nassert(match_parens(lst: [\")\", \"(\"]) == \"\
    Yes\")"
  status: SyntaxError
  stderr: "/tmp/tmpr0llx5eh.swift:20:12: error: cannot find 'is_good' in scope\n \
    \   return is_good(s: s) ? \"Yes\" : \"No\"\n           ^~~~~~~\n"
  stdout: ''
  timestamp: 1659979533
- exit_code: -4
  program: "\n/// You are given an array of two strings, both strings consist of open\n\
    /// parentheses '(' or close parentheses ')' only.\n/// Your job is to check if\
    \ it is possible to concatenate the two strings in\n/// some order, that the resulting\
    \ string will be good.\n/// A string S is considered to be good if and only if\
    \ all parentheses in S\n/// are balanced. For example: the string '(())()' is\
    \ good, while the string\n/// '())' is not.\n/// Return 'Yes' if there's a way\
    \ to make a good string, and return 'No' otherwise.\n/// Examples:\n/// >>> match_parens(lst:\
    \ [\"()(\", \")\"])\n/// \"Yes\"\n/// >>> match_parens(lst: [\")\", \")\"])\n\
    /// \"No\"\nfunc match_parens(lst: [String]) -> String {\n    var stack = [Character]()\n\
    \    var close_parens = 0\n    for c in lst[0] {\n        if c == \"(\" {\n  \
    \          stack.append(c)\n        } else {\n            if stack.count == 0\
    \ {\n                close_parens += 1\n            } else {\n               \
    \ stack.removeLast()\n            }\n        }\n    }\n    for c in lst[1] {\n\
    \        if c == \"(\" {\n            if close_parens > 0 {\n                close_parens\
    \ -= 1\n            } else {\n                stack.append(c)\n            }\n\
    \        } else {\n            if stack.count == 0 {\n                return \"\
    No\"\n            } else {\n                stack.removeLast()\n            }\n\
    \        }\n    }\n    return \"Yes\"\n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(match_parens(lst: [\"()(\", \")\"]) == \"Yes\")\nassert(match_parens(lst:\
    \ [\")\", \")\"]) == \"No\")\nassert(match_parens(lst: [\"(()(())\", \"())())\"\
    ]) == \"No\")\nassert(match_parens(lst: [\")())\", \"(()()(\"]) == \"Yes\")\n\
    assert(match_parens(lst: [\"(())))\", \"(()())((\"]) == \"Yes\")\nassert(match_parens(lst:\
    \ [\"()\", \"())\"]) == \"No\")\nassert(match_parens(lst: [\"(()(\", \"()))()\"\
    ]) == \"Yes\")\nassert(match_parens(lst: [\"((((\", \"((())\"]) == \"No\")\nassert(match_parens(lst:\
    \ [\")(()\", \"(()(\"]) == \"No\")\nassert(match_parens(lst: [\")(\", \")(\"])\
    \ == \"No\")\nassert(match_parens(lst: [\"(\", \")\"]) == \"Yes\")\nassert(match_parens(lst:\
    \ [\")\", \"(\"]) == \"Yes\")"
  status: Exception
  stderr: 'tmpg14pti9g/tmpg14pti9g.swift:63: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b1cba521c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b1cba218b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b1cba218988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b1cba2177b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpg14pti9g                        0x000055e0dcd0ad06 <unavailable> + 7430

    5    libc.so.6                          0x00002b1cba70d460 __libc_start_main +
    245

    6    tmpg14pti9g                        0x000055e0dcd0a469 <unavailable> + 5225

    '
  stdout: ''
  timestamp: 1659979533
- exit_code: -4
  program: "\n/// You are given an array of two strings, both strings consist of open\n\
    /// parentheses '(' or close parentheses ')' only.\n/// Your job is to check if\
    \ it is possible to concatenate the two strings in\n/// some order, that the resulting\
    \ string will be good.\n/// A string S is considered to be good if and only if\
    \ all parentheses in S\n/// are balanced. For example: the string '(())()' is\
    \ good, while the string\n/// '())' is not.\n/// Return 'Yes' if there's a way\
    \ to make a good string, and return 'No' otherwise.\n/// Examples:\n/// >>> match_parens(lst:\
    \ [\"()(\", \")\"])\n/// \"Yes\"\n/// >>> match_parens(lst: [\")\", \")\"])\n\
    /// \"No\"\nfunc match_parens(lst: [String]) -> String {\n    var open = 0\n \
    \   var close = 0\n    for c in lst[0] {\n        if c == \"(\" {\n          \
    \  open += 1\n        } else {\n            close += 1\n        }\n    }\n   \
    \ for c in lst[1] {\n        if c == \"(\" {\n            open += 1\n        }\
    \ else {\n            close += 1\n        }\n    }\n    if open == close {\n \
    \       return \"Yes\"\n    }\n    return \"No\"\n}\n\n\nfunc ==(left: [(Int,\
    \ Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n\
    \        return false\n    }\n    for (l, r) in zip(left, right) {\n        if\
    \ l != r {\n            return false\n        }\n    }\n    return true\n}\n \
    \           \nassert(match_parens(lst: [\"()(\", \")\"]) == \"Yes\")\nassert(match_parens(lst:\
    \ [\")\", \")\"]) == \"No\")\nassert(match_parens(lst: [\"(()(())\", \"())())\"\
    ]) == \"No\")\nassert(match_parens(lst: [\")())\", \"(()()(\"]) == \"Yes\")\n\
    assert(match_parens(lst: [\"(())))\", \"(()())((\"]) == \"Yes\")\nassert(match_parens(lst:\
    \ [\"()\", \"())\"]) == \"No\")\nassert(match_parens(lst: [\"(()(\", \"()))()\"\
    ]) == \"Yes\")\nassert(match_parens(lst: [\"((((\", \"((())\"]) == \"No\")\nassert(match_parens(lst:\
    \ [\")(()\", \"(()(\"]) == \"No\")\nassert(match_parens(lst: [\")(\", \")(\"])\
    \ == \"No\")\nassert(match_parens(lst: [\"(\", \")\"]) == \"Yes\")\nassert(match_parens(lst:\
    \ [\")\", \"(\"]) == \"Yes\")"
  status: Exception
  stderr: 'tmp47xs14kj/tmp47xs14kj.swift:60: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002af1c10b5c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002af1c0dacb6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002af1c0dac988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002af1c0dab7b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmp47xs14kj                        0x0000562099bc5468 <unavailable> + 9320

    5    libc.so.6                          0x00002af1c12a1460 __libc_start_main +
    245

    6    tmp47xs14kj                        0x0000562099bc4289 <unavailable> + 4745

    '
  stdout: ''
  timestamp: 1659979533
- exit_code: -4
  program: "\n/// You are given an array of two strings, both strings consist of open\n\
    /// parentheses '(' or close parentheses ')' only.\n/// Your job is to check if\
    \ it is possible to concatenate the two strings in\n/// some order, that the resulting\
    \ string will be good.\n/// A string S is considered to be good if and only if\
    \ all parentheses in S\n/// are balanced. For example: the string '(())()' is\
    \ good, while the string\n/// '())' is not.\n/// Return 'Yes' if there's a way\
    \ to make a good string, and return 'No' otherwise.\n/// Examples:\n/// >>> match_parens(lst:\
    \ [\"()(\", \")\"])\n/// \"Yes\"\n/// >>> match_parens(lst: [\")\", \")\"])\n\
    /// \"No\"\nfunc match_parens(lst: [String]) -> String {\n    var remaining_opens\
    \ = 0\n    var answer = \"Yes\"\n    for s in lst {\n        for c in s {\n  \
    \          if c == \"(\" {\n                remaining_opens += 1\n           \
    \ } else {\n                if remaining_opens > 0 {\n                    remaining_opens\
    \ -= 1\n                } else {\n                    answer = \"No\"\n      \
    \          }\n            }\n        }\n    }\n    if remaining_opens > 0 {\n\
    \        answer = \"No\"\n    }\n    return answer\n}\n\n\nfunc ==(left: [(Int,\
    \ Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n\
    \        return false\n    }\n    for (l, r) in zip(left, right) {\n        if\
    \ l != r {\n            return false\n        }\n    }\n    return true\n}\n \
    \           \nassert(match_parens(lst: [\"()(\", \")\"]) == \"Yes\")\nassert(match_parens(lst:\
    \ [\")\", \")\"]) == \"No\")\nassert(match_parens(lst: [\"(()(())\", \"())())\"\
    ]) == \"No\")\nassert(match_parens(lst: [\")())\", \"(()()(\"]) == \"Yes\")\n\
    assert(match_parens(lst: [\"(())))\", \"(()())((\"]) == \"Yes\")\nassert(match_parens(lst:\
    \ [\"()\", \"())\"]) == \"No\")\nassert(match_parens(lst: [\"(()(\", \"()))()\"\
    ]) == \"Yes\")\nassert(match_parens(lst: [\"((((\", \"((())\"]) == \"No\")\nassert(match_parens(lst:\
    \ [\")(()\", \"(()(\"]) == \"No\")\nassert(match_parens(lst: [\")(\", \")(\"])\
    \ == \"No\")\nassert(match_parens(lst: [\"(\", \")\"]) == \"Yes\")\nassert(match_parens(lst:\
    \ [\")\", \"(\"]) == \"Yes\")"
  status: Exception
  stderr: 'tmpsl38rr85/tmpsl38rr85.swift:53: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b63af10bc80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b63aee02b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b63aee02988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b63aee017b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpsl38rr85                        0x0000559d90641c36 <unavailable> + 7222

    5    libc.so.6                          0x00002b63af2f7460 __libc_start_main +
    245

    6    tmpsl38rr85                        0x0000559d90641399 <unavailable> + 5017

    '
  stdout: ''
  timestamp: 1659979533
- exit_code: 1
  program: "\n/// You are given an array of two strings, both strings consist of open\n\
    /// parentheses '(' or close parentheses ')' only.\n/// Your job is to check if\
    \ it is possible to concatenate the two strings in\n/// some order, that the resulting\
    \ string will be good.\n/// A string S is considered to be good if and only if\
    \ all parentheses in S\n/// are balanced. For example: the string '(())()' is\
    \ good, while the string\n/// '())' is not.\n/// Return 'Yes' if there's a way\
    \ to make a good string, and return 'No' otherwise.\n/// Examples:\n/// >>> match_parens(lst:\
    \ [\"()(\", \")\"])\n/// \"Yes\"\n/// >>> match_parens(lst: [\")\", \")\"])\n\
    /// \"No\"\nfunc match_parens(lst: [String]) -> String {\n    return \"\\(canConcat(lst[0],\
    \ lst[1]))\"\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool\
    \ {\n    if left.count != right.count {\n        return false\n    }\n    for\
    \ (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(match_parens(lst:\
    \ [\"()(\", \")\"]) == \"Yes\")\nassert(match_parens(lst: [\")\", \")\"]) == \"\
    No\")\nassert(match_parens(lst: [\"(()(())\", \"())())\"]) == \"No\")\nassert(match_parens(lst:\
    \ [\")())\", \"(()()(\"]) == \"Yes\")\nassert(match_parens(lst: [\"(())))\", \"\
    (()())((\"]) == \"Yes\")\nassert(match_parens(lst: [\"()\", \"())\"]) == \"No\"\
    )\nassert(match_parens(lst: [\"(()(\", \"()))()\"]) == \"Yes\")\nassert(match_parens(lst:\
    \ [\"((((\", \"((())\"]) == \"No\")\nassert(match_parens(lst: [\")(()\", \"(()(\"\
    ]) == \"No\")\nassert(match_parens(lst: [\")(\", \")(\"]) == \"No\")\nassert(match_parens(lst:\
    \ [\"(\", \")\"]) == \"Yes\")\nassert(match_parens(lst: [\")\", \"(\"]) == \"\
    Yes\")"
  status: SyntaxError
  stderr: "/tmp/tmpdyus1wyx.swift:16:15: error: cannot find 'canConcat' in scope\n\
    \    return \"\\(canConcat(lst[0], lst[1]))\"\n              ^~~~~~~~~\n"
  stdout: ''
  timestamp: 1659979533
- exit_code: -4
  program: "\n/// You are given an array of two strings, both strings consist of open\n\
    /// parentheses '(' or close parentheses ')' only.\n/// Your job is to check if\
    \ it is possible to concatenate the two strings in\n/// some order, that the resulting\
    \ string will be good.\n/// A string S is considered to be good if and only if\
    \ all parentheses in S\n/// are balanced. For example: the string '(())()' is\
    \ good, while the string\n/// '())' is not.\n/// Return 'Yes' if there's a way\
    \ to make a good string, and return 'No' otherwise.\n/// Examples:\n/// >>> match_parens(lst:\
    \ [\"()(\", \")\"])\n/// \"Yes\"\n/// >>> match_parens(lst: [\")\", \")\"])\n\
    /// \"No\"\nfunc match_parens(lst: [String]) -> String {\n    let (s1, s2) = (lst[0],\
    \ lst[1])\n    var openers = 0\n    for ch in s1 {\n        if ch == \"(\" {\n\
    \            openers += 1\n        } else {\n            openers -= 1\n      \
    \  }\n    }\n    for ch in s2 {\n        if ch == \"(\" {\n            openers\
    \ += 1\n        } else {\n            openers -= 1\n        }\n    }\n    if openers\
    \ == 0 {\n        return \"Yes\"\n    }\n    return \"No\"\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(match_parens(lst: [\"()(\", \")\"]) == \"Yes\")\nassert(match_parens(lst:\
    \ [\")\", \")\"]) == \"No\")\nassert(match_parens(lst: [\"(()(())\", \"())())\"\
    ]) == \"No\")\nassert(match_parens(lst: [\")())\", \"(()()(\"]) == \"Yes\")\n\
    assert(match_parens(lst: [\"(())))\", \"(()())((\"]) == \"Yes\")\nassert(match_parens(lst:\
    \ [\"()\", \"())\"]) == \"No\")\nassert(match_parens(lst: [\"(()(\", \"()))()\"\
    ]) == \"Yes\")\nassert(match_parens(lst: [\"((((\", \"((())\"]) == \"No\")\nassert(match_parens(lst:\
    \ [\")(()\", \"(()(\"]) == \"No\")\nassert(match_parens(lst: [\")(\", \")(\"])\
    \ == \"No\")\nassert(match_parens(lst: [\"(\", \")\"]) == \"Yes\")\nassert(match_parens(lst:\
    \ [\")\", \"(\"]) == \"Yes\")"
  status: Exception
  stderr: 'tmpsvig1y10/tmpsvig1y10.swift:60: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002aaed57afc80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002aaed54a6b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002aaed54a6988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002aaed54a57b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpsvig1y10                        0x0000564e20176468 <unavailable> + 9320

    5    libc.so.6                          0x00002aaed599b460 __libc_start_main +
    245

    6    tmpsvig1y10                        0x0000564e20175289 <unavailable> + 4745

    '
  stdout: ''
  timestamp: 1659979533
- exit_code: -4
  program: "\n/// You are given an array of two strings, both strings consist of open\n\
    /// parentheses '(' or close parentheses ')' only.\n/// Your job is to check if\
    \ it is possible to concatenate the two strings in\n/// some order, that the resulting\
    \ string will be good.\n/// A string S is considered to be good if and only if\
    \ all parentheses in S\n/// are balanced. For example: the string '(())()' is\
    \ good, while the string\n/// '())' is not.\n/// Return 'Yes' if there's a way\
    \ to make a good string, and return 'No' otherwise.\n/// Examples:\n/// >>> match_parens(lst:\
    \ [\"()(\", \")\"])\n/// \"Yes\"\n/// >>> match_parens(lst: [\")\", \")\"])\n\
    /// \"No\"\nfunc match_parens(lst: [String]) -> String {\n    return \"Yes\"\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(match_parens(lst: [\"()(\", \")\"]) == \"Yes\"\
    )\nassert(match_parens(lst: [\")\", \")\"]) == \"No\")\nassert(match_parens(lst:\
    \ [\"(()(())\", \"())())\"]) == \"No\")\nassert(match_parens(lst: [\")())\", \"\
    (()()(\"]) == \"Yes\")\nassert(match_parens(lst: [\"(())))\", \"(()())((\"]) ==\
    \ \"Yes\")\nassert(match_parens(lst: [\"()\", \"())\"]) == \"No\")\nassert(match_parens(lst:\
    \ [\"(()(\", \"()))()\"]) == \"Yes\")\nassert(match_parens(lst: [\"((((\", \"\
    ((())\"]) == \"No\")\nassert(match_parens(lst: [\")(()\", \"(()(\"]) == \"No\"\
    )\nassert(match_parens(lst: [\")(\", \")(\"]) == \"No\")\nassert(match_parens(lst:\
    \ [\"(\", \")\"]) == \"Yes\")\nassert(match_parens(lst: [\")\", \"(\"]) == \"\
    Yes\")"
  status: Exception
  stderr: 'tmpy58rzaur/tmpy58rzaur.swift:33: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002ab41f279c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002ab41ef70b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002ab41ef70988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002ab41ef6f7b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpy58rzaur                        0x000055a3983f9610 <unavailable> + 5648

    5    libc.so.6                          0x00002ab41f465460 __libc_start_main +
    245

    6    tmpy58rzaur                        0x000055a3983f9089 <unavailable> + 4233

    '
  stdout: ''
  timestamp: 1659979533
- exit_code: -4
  program: "\n/// You are given an array of two strings, both strings consist of open\n\
    /// parentheses '(' or close parentheses ')' only.\n/// Your job is to check if\
    \ it is possible to concatenate the two strings in\n/// some order, that the resulting\
    \ string will be good.\n/// A string S is considered to be good if and only if\
    \ all parentheses in S\n/// are balanced. For example: the string '(())()' is\
    \ good, while the string\n/// '())' is not.\n/// Return 'Yes' if there's a way\
    \ to make a good string, and return 'No' otherwise.\n/// Examples:\n/// >>> match_parens(lst:\
    \ [\"()(\", \")\"])\n/// \"Yes\"\n/// >>> match_parens(lst: [\")\", \")\"])\n\
    /// \"No\"\nfunc match_parens(lst: [String]) -> String {\n    var left = 0\n \
    \   var right = 0\n    for s in lst {\n        left += s.filter { $0 == \"(\"\
    \ }.count\n        right += s.filter { $0 == \")\" }.count\n    }\n    return\
    \ left == right ? \"Yes\" : \"No\"\n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(match_parens(lst: [\"()(\", \")\"]) == \"Yes\")\nassert(match_parens(lst:\
    \ [\")\", \")\"]) == \"No\")\nassert(match_parens(lst: [\"(()(())\", \"())())\"\
    ]) == \"No\")\nassert(match_parens(lst: [\")())\", \"(()()(\"]) == \"Yes\")\n\
    assert(match_parens(lst: [\"(())))\", \"(()())((\"]) == \"Yes\")\nassert(match_parens(lst:\
    \ [\"()\", \"())\"]) == \"No\")\nassert(match_parens(lst: [\"(()(\", \"()))()\"\
    ]) == \"Yes\")\nassert(match_parens(lst: [\"((((\", \"((())\"]) == \"No\")\nassert(match_parens(lst:\
    \ [\")(()\", \"(()(\"]) == \"No\")\nassert(match_parens(lst: [\")(\", \")(\"])\
    \ == \"No\")\nassert(match_parens(lst: [\"(\", \")\"]) == \"Yes\")\nassert(match_parens(lst:\
    \ [\")\", \"(\"]) == \"Yes\")"
  status: Exception
  stderr: 'tmpr9d48c_z/tmpr9d48c_z.swift:47: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b0d4c63cc80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b0d4c333b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b0d4c333988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b0d4c3327b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpr9d48c_z                        0x0000561cc92485b8 <unavailable> + 9656

    5    libc.so.6                          0x00002b0d4c828460 __libc_start_main +
    245

    6    tmpr9d48c_z                        0x0000561cc92473d9 <unavailable> + 5081

    '
  stdout: ''
  timestamp: 1659979534
- exit_code: -4
  program: "\n/// You are given an array of two strings, both strings consist of open\n\
    /// parentheses '(' or close parentheses ')' only.\n/// Your job is to check if\
    \ it is possible to concatenate the two strings in\n/// some order, that the resulting\
    \ string will be good.\n/// A string S is considered to be good if and only if\
    \ all parentheses in S\n/// are balanced. For example: the string '(())()' is\
    \ good, while the string\n/// '())' is not.\n/// Return 'Yes' if there's a way\
    \ to make a good string, and return 'No' otherwise.\n/// Examples:\n/// >>> match_parens(lst:\
    \ [\"()(\", \")\"])\n/// \"Yes\"\n/// >>> match_parens(lst: [\")\", \")\"])\n\
    /// \"No\"\nfunc match_parens(lst: [String]) -> String {\n    var s = lst[0] +\
    \ lst[1]\n    var count = 0\n    for i in s {\n        if i == \"(\" {\n     \
    \       count += 1\n        } else {\n            count -= 1\n        }\n    \
    \    if count < 0 {\n            return \"No\"\n        }\n    }\n    return \"\
    Yes\"\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n   \
    \ if left.count != right.count {\n        return false\n    }\n    for (l, r)\
    \ in zip(left, right) {\n        if l != r {\n            return false\n     \
    \   }\n    }\n    return true\n}\n            \nassert(match_parens(lst: [\"()(\"\
    , \")\"]) == \"Yes\")\nassert(match_parens(lst: [\")\", \")\"]) == \"No\")\nassert(match_parens(lst:\
    \ [\"(()(())\", \"())())\"]) == \"No\")\nassert(match_parens(lst: [\")())\", \"\
    (()()(\"]) == \"Yes\")\nassert(match_parens(lst: [\"(())))\", \"(()())((\"]) ==\
    \ \"Yes\")\nassert(match_parens(lst: [\"()\", \"())\"]) == \"No\")\nassert(match_parens(lst:\
    \ [\"(()(\", \"()))()\"]) == \"Yes\")\nassert(match_parens(lst: [\"((((\", \"\
    ((())\"]) == \"No\")\nassert(match_parens(lst: [\")(()\", \"(()(\"]) == \"No\"\
    )\nassert(match_parens(lst: [\")(\", \")(\"]) == \"No\")\nassert(match_parens(lst:\
    \ [\"(\", \")\"]) == \"Yes\")\nassert(match_parens(lst: [\")\", \"(\"]) == \"\
    Yes\")"
  status: Exception
  stderr: 'tmphh3icsi7/tmphh3icsi7.swift:47: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b42a650fc80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b42a6206b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b42a6206988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b42a62057b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmphh3icsi7                        0x000056470d377b76 <unavailable> + 7030

    5    libc.so.6                          0x00002b42a66fb460 __libc_start_main +
    245

    6    tmphh3icsi7                        0x000056470d3772d9 <unavailable> + 4825

    '
  stdout: ''
  timestamp: 1659979534
- exit_code: 1
  program: "\n/// You are given an array of two strings, both strings consist of open\n\
    /// parentheses '(' or close parentheses ')' only.\n/// Your job is to check if\
    \ it is possible to concatenate the two strings in\n/// some order, that the resulting\
    \ string will be good.\n/// A string S is considered to be good if and only if\
    \ all parentheses in S\n/// are balanced. For example: the string '(())()' is\
    \ good, while the string\n/// '())' is not.\n/// Return 'Yes' if there's a way\
    \ to make a good string, and return 'No' otherwise.\n/// Examples:\n/// >>> match_parens(lst:\
    \ [\"()(\", \")\"])\n/// \"Yes\"\n/// >>> match_parens(lst: [\")\", \")\"])\n\
    /// \"No\"\nfunc match_parens(lst: [String]) -> String {\n    var count: Int =\
    \ 0\n    for i in 0..<lst.count {\n        for j in 0..<lst[i].count {\n     \
    \       if lst[i][j] == \"(\" {\n                count += 1\n            } else\
    \ {\n                count -= 1\n            }\n            if count < 0 {\n \
    \               return \"No\"\n            }\n        }\n    }\n    return count\
    \ == 0 ? \"Yes\" : \"No\"\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(match_parens(lst:\
    \ [\"()(\", \")\"]) == \"Yes\")\nassert(match_parens(lst: [\")\", \")\"]) == \"\
    No\")\nassert(match_parens(lst: [\"(()(())\", \"())())\"]) == \"No\")\nassert(match_parens(lst:\
    \ [\")())\", \"(()()(\"]) == \"Yes\")\nassert(match_parens(lst: [\"(())))\", \"\
    (()())((\"]) == \"Yes\")\nassert(match_parens(lst: [\"()\", \"())\"]) == \"No\"\
    )\nassert(match_parens(lst: [\"(()(\", \"()))()\"]) == \"Yes\")\nassert(match_parens(lst:\
    \ [\"((((\", \"((())\"]) == \"No\")\nassert(match_parens(lst: [\")(()\", \"(()(\"\
    ]) == \"No\")\nassert(match_parens(lst: [\")(\", \")(\"]) == \"No\")\nassert(match_parens(lst:\
    \ [\"(\", \")\"]) == \"Yes\")\nassert(match_parens(lst: [\")\", \"(\"]) == \"\
    Yes\")"
  status: SyntaxError
  stderr: "/tmp/tmp22e5r0qz.swift:19:16: error: 'subscript(_:)' is unavailable: cannot\
    \ subscript String with an Int, use a String.Index instead.\n            if lst[i][j]\
    \ == \"(\" {\n               ^~~~~~~~~\nSwift.String:3:12: note: 'subscript(_:)'\
    \ has been explicitly marked unavailable here\n    public subscript(i: Int) ->\
    \ Character { get }\n           ^\n"
  stdout: ''
  timestamp: 1659979533
- exit_code: 1
  program: "\n/// You are given an array of two strings, both strings consist of open\n\
    /// parentheses '(' or close parentheses ')' only.\n/// Your job is to check if\
    \ it is possible to concatenate the two strings in\n/// some order, that the resulting\
    \ string will be good.\n/// A string S is considered to be good if and only if\
    \ all parentheses in S\n/// are balanced. For example: the string '(())()' is\
    \ good, while the string\n/// '())' is not.\n/// Return 'Yes' if there's a way\
    \ to make a good string, and return 'No' otherwise.\n/// Examples:\n/// >>> match_parens(lst:\
    \ [\"()(\", \")\"])\n/// \"Yes\"\n/// >>> match_parens(lst: [\")\", \")\"])\n\
    /// \"No\"\nfunc match_parens(lst: [String]) -> String {\n    let str1 = lst[0]\n\
    \    let str2 = lst[1]\n    var stack1 = Stack<Character>()\n    var stack2 =\
    \ Stack<Character>()\n    for c in str1 {\n        if c == \"(\" {\n         \
    \   stack1.push(element: c)\n        } else {\n            if stack1.isEmpty()\
    \ {\n                return \"No\"\n            } else {\n                _ =\
    \ stack1.pop()\n            }\n        }\n    }\n    for c in str2 {\n       \
    \ if c == \"(\" {\n            stack2.push(element: c)\n        } else {\n   \
    \         if stack2.isEmpty() {\n                return \"No\"\n            }\
    \ else {\n                _ = stack2.pop()\n            }\n        }\n    }\n\
    \    if stack1.isEmpty() && stack2.isEmpty() {\n        return \"Yes\"\n    }\
    \ else {\n        return \"No\"\n    }\n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(match_parens(lst: [\"()(\", \")\"]) == \"Yes\")\nassert(match_parens(lst:\
    \ [\")\", \")\"]) == \"No\")\nassert(match_parens(lst: [\"(()(())\", \"())())\"\
    ]) == \"No\")\nassert(match_parens(lst: [\")())\", \"(()()(\"]) == \"Yes\")\n\
    assert(match_parens(lst: [\"(())))\", \"(()())((\"]) == \"Yes\")\nassert(match_parens(lst:\
    \ [\"()\", \"())\"]) == \"No\")\nassert(match_parens(lst: [\"(()(\", \"()))()\"\
    ]) == \"Yes\")\nassert(match_parens(lst: [\"((((\", \"((())\"]) == \"No\")\nassert(match_parens(lst:\
    \ [\")(()\", \"(()(\"]) == \"No\")\nassert(match_parens(lst: [\")(\", \")(\"])\
    \ == \"No\")\nassert(match_parens(lst: [\"(\", \")\"]) == \"Yes\")\nassert(match_parens(lst:\
    \ [\")\", \"(\"]) == \"Yes\")"
  status: SyntaxError
  stderr: "/tmp/tmp4t79civh.swift:18:18: error: cannot find 'Stack' in scope\n   \
    \ var stack1 = Stack<Character>()\n                 ^~~~~\n/tmp/tmp4t79civh.swift:19:18:\
    \ error: cannot find 'Stack' in scope\n    var stack2 = Stack<Character>()\n \
    \                ^~~~~\n"
  stdout: ''
  timestamp: 1659979533
- exit_code: 1
  program: "\n/// You are given an array of two strings, both strings consist of open\n\
    /// parentheses '(' or close parentheses ')' only.\n/// Your job is to check if\
    \ it is possible to concatenate the two strings in\n/// some order, that the resulting\
    \ string will be good.\n/// A string S is considered to be good if and only if\
    \ all parentheses in S\n/// are balanced. For example: the string '(())()' is\
    \ good, while the string\n/// '())' is not.\n/// Return 'Yes' if there's a way\
    \ to make a good string, and return 'No' otherwise.\n/// Examples:\n/// >>> match_parens(lst:\
    \ [\"()(\", \")\"])\n/// \"Yes\"\n/// >>> match_parens(lst: [\")\", \")\"])\n\
    /// \"No\"\nfunc match_parens(lst: [String]) -> String {\n    var stack = Stack<Character>()\n\
    \    var concat = lst[0] + lst[1]\n    for c in concat {\n        if c == \"(\"\
    \ {\n            stack.push(c)\n        } else {\n            if stack.isEmpty()\
    \ {\n                return \"No\"\n            } else {\n                stack.pop()\n\
    \            }\n        }\n    }\n    return stack.isEmpty() ? \"Yes\" : \"No\"\
    \n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(match_parens(lst: [\"()(\", \")\"]) == \"Yes\"\
    )\nassert(match_parens(lst: [\")\", \")\"]) == \"No\")\nassert(match_parens(lst:\
    \ [\"(()(())\", \"())())\"]) == \"No\")\nassert(match_parens(lst: [\")())\", \"\
    (()()(\"]) == \"Yes\")\nassert(match_parens(lst: [\"(())))\", \"(()())((\"]) ==\
    \ \"Yes\")\nassert(match_parens(lst: [\"()\", \"())\"]) == \"No\")\nassert(match_parens(lst:\
    \ [\"(()(\", \"()))()\"]) == \"Yes\")\nassert(match_parens(lst: [\"((((\", \"\
    ((())\"]) == \"No\")\nassert(match_parens(lst: [\")(()\", \"(()(\"]) == \"No\"\
    )\nassert(match_parens(lst: [\")(\", \")(\"]) == \"No\")\nassert(match_parens(lst:\
    \ [\"(\", \")\"]) == \"Yes\")\nassert(match_parens(lst: [\")\", \"(\"]) == \"\
    Yes\")"
  status: SyntaxError
  stderr: "/tmp/tmpekzmw94p.swift:16:17: error: cannot find 'Stack' in scope\n   \
    \ var stack = Stack<Character>()\n                ^~~~~\n"
  stdout: ''
  timestamp: 1659979533
- exit_code: -4
  program: "\n/// You are given an array of two strings, both strings consist of open\n\
    /// parentheses '(' or close parentheses ')' only.\n/// Your job is to check if\
    \ it is possible to concatenate the two strings in\n/// some order, that the resulting\
    \ string will be good.\n/// A string S is considered to be good if and only if\
    \ all parentheses in S\n/// are balanced. For example: the string '(())()' is\
    \ good, while the string\n/// '())' is not.\n/// Return 'Yes' if there's a way\
    \ to make a good string, and return 'No' otherwise.\n/// Examples:\n/// >>> match_parens(lst:\
    \ [\"()(\", \")\"])\n/// \"Yes\"\n/// >>> match_parens(lst: [\")\", \")\"])\n\
    /// \"No\"\nfunc match_parens(lst: [String]) -> String {\n    var counter = 0\n\
    \    for i in lst[0] {\n        if i == \"(\" {\n            counter += 1\n  \
    \      } else {\n            counter -= 1\n        }\n    }\n    for i in lst[1]\
    \ {\n        if i == \"(\" {\n            counter += 1\n        } else {\n   \
    \         counter -= 1\n        }\n    }\n    if counter < 0 {\n        return\
    \ \"No\"\n    }\n    return \"Yes\"\n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(match_parens(lst: [\"()(\", \")\"]) == \"Yes\")\nassert(match_parens(lst:\
    \ [\")\", \")\"]) == \"No\")\nassert(match_parens(lst: [\"(()(())\", \"())())\"\
    ]) == \"No\")\nassert(match_parens(lst: [\")())\", \"(()()(\"]) == \"Yes\")\n\
    assert(match_parens(lst: [\"(())))\", \"(()())((\"]) == \"Yes\")\nassert(match_parens(lst:\
    \ [\"()\", \"())\"]) == \"No\")\nassert(match_parens(lst: [\"(()(\", \"()))()\"\
    ]) == \"Yes\")\nassert(match_parens(lst: [\"((((\", \"((())\"]) == \"No\")\nassert(match_parens(lst:\
    \ [\")(()\", \"(()(\"]) == \"No\")\nassert(match_parens(lst: [\")(\", \")(\"])\
    \ == \"No\")\nassert(match_parens(lst: [\"(\", \")\"]) == \"Yes\")\nassert(match_parens(lst:\
    \ [\")\", \"(\"]) == \"Yes\")"
  status: Exception
  stderr: 'tmp_v4ewdnz/tmp_v4ewdnz.swift:57: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002aef3c20fc80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002aef3bf06b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002aef3bf06988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002aef3bf057b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmp_v4ewdnz                        0x00005564ce22e152 <unavailable> + 8530

    5    libc.so.6                          0x00002aef3c3fb460 __libc_start_main +
    245

    6    tmp_v4ewdnz                        0x00005564ce22d289 <unavailable> + 4745

    '
  stdout: ''
  timestamp: 1659979534
- exit_code: -4
  program: "\n/// You are given an array of two strings, both strings consist of open\n\
    /// parentheses '(' or close parentheses ')' only.\n/// Your job is to check if\
    \ it is possible to concatenate the two strings in\n/// some order, that the resulting\
    \ string will be good.\n/// A string S is considered to be good if and only if\
    \ all parentheses in S\n/// are balanced. For example: the string '(())()' is\
    \ good, while the string\n/// '())' is not.\n/// Return 'Yes' if there's a way\
    \ to make a good string, and return 'No' otherwise.\n/// Examples:\n/// >>> match_parens(lst:\
    \ [\"()(\", \")\"])\n/// \"Yes\"\n/// >>> match_parens(lst: [\")\", \")\"])\n\
    /// \"No\"\nfunc match_parens(lst: [String]) -> String {\n    var stack = 0\n\
    \    for str in lst {\n        for ch in str {\n            switch ch {\n    \
    \        case \"(\":\n                stack += 1\n            case \")\":\n  \
    \              stack -= 1\n            default:\n                break\n     \
    \       }\n            if stack < 0 {\n                return \"No\"\n       \
    \     }\n        }\n    }\n    return stack == 0 ? \"Yes\" : \"No\"\n}\n\n\nfunc\
    \ ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count !=\
    \ right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(match_parens(lst: [\"()(\", \")\"]) == \"Yes\"\
    )\nassert(match_parens(lst: [\")\", \")\"]) == \"No\")\nassert(match_parens(lst:\
    \ [\"(()(())\", \"())())\"]) == \"No\")\nassert(match_parens(lst: [\")())\", \"\
    (()()(\"]) == \"Yes\")\nassert(match_parens(lst: [\"(())))\", \"(()())((\"]) ==\
    \ \"Yes\")\nassert(match_parens(lst: [\"()\", \"())\"]) == \"No\")\nassert(match_parens(lst:\
    \ [\"(()(\", \"()))()\"]) == \"Yes\")\nassert(match_parens(lst: [\"((((\", \"\
    ((())\"]) == \"No\")\nassert(match_parens(lst: [\")(()\", \"(()(\"]) == \"No\"\
    )\nassert(match_parens(lst: [\")(\", \")(\"]) == \"No\")\nassert(match_parens(lst:\
    \ [\"(\", \")\"]) == \"Yes\")\nassert(match_parens(lst: [\")\", \"(\"]) == \"\
    Yes\")"
  status: Exception
  stderr: 'tmpcvy_27r8/tmpcvy_27r8.swift:51: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b8476b7ac80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b8476871b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b8476871988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b84768707b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpcvy_27r8                        0x000055e0e9b4ac36 <unavailable> + 7222

    5    libc.so.6                          0x00002b8476d66460 __libc_start_main +
    245

    6    tmpcvy_27r8                        0x000055e0e9b4a399 <unavailable> + 5017

    '
  stdout: ''
  timestamp: 1659979534
- exit_code: 1
  program: "\n/// You are given an array of two strings, both strings consist of open\n\
    /// parentheses '(' or close parentheses ')' only.\n/// Your job is to check if\
    \ it is possible to concatenate the two strings in\n/// some order, that the resulting\
    \ string will be good.\n/// A string S is considered to be good if and only if\
    \ all parentheses in S\n/// are balanced. For example: the string '(())()' is\
    \ good, while the string\n/// '())' is not.\n/// Return 'Yes' if there's a way\
    \ to make a good string, and return 'No' otherwise.\n/// Examples:\n/// >>> match_parens(lst:\
    \ [\"()(\", \")\"])\n/// \"Yes\"\n/// >>> match_parens(lst: [\")\", \")\"])\n\
    /// \"No\"\nfunc match_parens(lst: [String]) -> String {\n    var s = \"\"\n \
    \   for str in lst {\n        s += str\n    }\n    if is_balanced(s: s) {\n  \
    \      return \"Yes\"\n    }\n    return \"No\"\n}\n\n\nfunc ==(left: [(Int, Int)],\
    \ right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n       \
    \ return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r\
    \ {\n            return false\n        }\n    }\n    return true\n}\n        \
    \    \nassert(match_parens(lst: [\"()(\", \")\"]) == \"Yes\")\nassert(match_parens(lst:\
    \ [\")\", \")\"]) == \"No\")\nassert(match_parens(lst: [\"(()(())\", \"())())\"\
    ]) == \"No\")\nassert(match_parens(lst: [\")())\", \"(()()(\"]) == \"Yes\")\n\
    assert(match_parens(lst: [\"(())))\", \"(()())((\"]) == \"Yes\")\nassert(match_parens(lst:\
    \ [\"()\", \"())\"]) == \"No\")\nassert(match_parens(lst: [\"(()(\", \"()))()\"\
    ]) == \"Yes\")\nassert(match_parens(lst: [\"((((\", \"((())\"]) == \"No\")\nassert(match_parens(lst:\
    \ [\")(()\", \"(()(\"]) == \"No\")\nassert(match_parens(lst: [\")(\", \")(\"])\
    \ == \"No\")\nassert(match_parens(lst: [\"(\", \")\"]) == \"Yes\")\nassert(match_parens(lst:\
    \ [\")\", \"(\"]) == \"Yes\")"
  status: SyntaxError
  stderr: "/tmp/tmpfa71l_1_.swift:20:8: error: cannot find 'is_balanced' in scope\n\
    \    if is_balanced(s: s) {\n       ^~~~~~~~~~~\n"
  stdout: ''
  timestamp: 1659979533
- exit_code: -4
  program: "\n/// You are given an array of two strings, both strings consist of open\n\
    /// parentheses '(' or close parentheses ')' only.\n/// Your job is to check if\
    \ it is possible to concatenate the two strings in\n/// some order, that the resulting\
    \ string will be good.\n/// A string S is considered to be good if and only if\
    \ all parentheses in S\n/// are balanced. For example: the string '(())()' is\
    \ good, while the string\n/// '())' is not.\n/// Return 'Yes' if there's a way\
    \ to make a good string, and return 'No' otherwise.\n/// Examples:\n/// >>> match_parens(lst:\
    \ [\"()(\", \")\"])\n/// \"Yes\"\n/// >>> match_parens(lst: [\")\", \")\"])\n\
    /// \"No\"\nfunc match_parens(lst: [String]) -> String {\n    // your code here\n\
    \    return \"\"\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool\
    \ {\n    if left.count != right.count {\n        return false\n    }\n    for\
    \ (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(match_parens(lst:\
    \ [\"()(\", \")\"]) == \"Yes\")\nassert(match_parens(lst: [\")\", \")\"]) == \"\
    No\")\nassert(match_parens(lst: [\"(()(())\", \"())())\"]) == \"No\")\nassert(match_parens(lst:\
    \ [\")())\", \"(()()(\"]) == \"Yes\")\nassert(match_parens(lst: [\"(())))\", \"\
    (()())((\"]) == \"Yes\")\nassert(match_parens(lst: [\"()\", \"())\"]) == \"No\"\
    )\nassert(match_parens(lst: [\"(()(\", \"()))()\"]) == \"Yes\")\nassert(match_parens(lst:\
    \ [\"((((\", \"((())\"]) == \"No\")\nassert(match_parens(lst: [\")(()\", \"(()(\"\
    ]) == \"No\")\nassert(match_parens(lst: [\")(\", \")(\"]) == \"No\")\nassert(match_parens(lst:\
    \ [\"(\", \")\"]) == \"Yes\")\nassert(match_parens(lst: [\")\", \"(\"]) == \"\
    Yes\")"
  status: Exception
  stderr: 'tmphade8tya/tmphade8tya.swift:33: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002acc4729ac80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002acc46f91b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002acc46f91988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002acc46f907b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmphade8tya                        0x000055d9cc9164a6 <unavailable> + 5286

    5    libc.so.6                          0x00002acc47486460 __libc_start_main +
    245

    6    tmphade8tya                        0x000055d9cc916089 <unavailable> + 4233

    '
  stdout: ''
  timestamp: 1659979534
- exit_code: -4
  program: "\n/// You are given an array of two strings, both strings consist of open\n\
    /// parentheses '(' or close parentheses ')' only.\n/// Your job is to check if\
    \ it is possible to concatenate the two strings in\n/// some order, that the resulting\
    \ string will be good.\n/// A string S is considered to be good if and only if\
    \ all parentheses in S\n/// are balanced. For example: the string '(())()' is\
    \ good, while the string\n/// '())' is not.\n/// Return 'Yes' if there's a way\
    \ to make a good string, and return 'No' otherwise.\n/// Examples:\n/// >>> match_parens(lst:\
    \ [\"()(\", \")\"])\n/// \"Yes\"\n/// >>> match_parens(lst: [\")\", \")\"])\n\
    /// \"No\"\nfunc match_parens(lst: [String]) -> String {\n    var lst2 = lst\n\
    \    lst2[0].append(lst2[1])\n    lst2.removeLast()\n    var open = 0\n    for\
    \ i in lst2[0] {\n        if i == \"(\" {\n            open += 1\n        } else\
    \ {\n            open -= 1\n        }\n        if open < 0 {\n            return\
    \ \"No\"\n        }\n    }\n    if open == 0 {\n        return \"Yes\"\n    }\
    \ else {\n        return \"No\"\n    }\n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(match_parens(lst: [\"()(\", \")\"]) == \"Yes\")\nassert(match_parens(lst:\
    \ [\")\", \")\"]) == \"No\")\nassert(match_parens(lst: [\"(()(())\", \"())())\"\
    ]) == \"No\")\nassert(match_parens(lst: [\")())\", \"(()()(\"]) == \"Yes\")\n\
    assert(match_parens(lst: [\"(())))\", \"(()())((\"]) == \"Yes\")\nassert(match_parens(lst:\
    \ [\"()\", \"())\"]) == \"No\")\nassert(match_parens(lst: [\"(()(\", \"()))()\"\
    ]) == \"Yes\")\nassert(match_parens(lst: [\"((((\", \"((())\"]) == \"No\")\nassert(match_parens(lst:\
    \ [\")(()\", \"(()(\"]) == \"No\")\nassert(match_parens(lst: [\")(\", \")(\"])\
    \ == \"No\")\nassert(match_parens(lst: [\"(\", \")\"]) == \"Yes\")\nassert(match_parens(lst:\
    \ [\")\", \"(\"]) == \"Yes\")"
  status: Exception
  stderr: 'tmp3la86tfc/tmp3la86tfc.swift:53: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b8db0c63c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b8db095ab6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b8db095a988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b8db09597b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmp3la86tfc                        0x000056348db87ca6 <unavailable> + 7334

    5    libc.so.6                          0x00002b8db0e4f460 __libc_start_main +
    245

    6    tmp3la86tfc                        0x000056348db87409 <unavailable> + 5129

    '
  stdout: ''
  timestamp: 1659979534
- exit_code: -4
  program: "\n/// You are given an array of two strings, both strings consist of open\n\
    /// parentheses '(' or close parentheses ')' only.\n/// Your job is to check if\
    \ it is possible to concatenate the two strings in\n/// some order, that the resulting\
    \ string will be good.\n/// A string S is considered to be good if and only if\
    \ all parentheses in S\n/// are balanced. For example: the string '(())()' is\
    \ good, while the string\n/// '())' is not.\n/// Return 'Yes' if there's a way\
    \ to make a good string, and return 'No' otherwise.\n/// Examples:\n/// >>> match_parens(lst:\
    \ [\"()(\", \")\"])\n/// \"Yes\"\n/// >>> match_parens(lst: [\")\", \")\"])\n\
    /// \"No\"\nfunc match_parens(lst: [String]) -> String {\n    var first = lst[0]\n\
    \    var second = lst[1]\n    var open_count = 0\n    var close_count = 0\n  \
    \  for ch in first {\n        if ch == \"(\" {\n            open_count += 1\n\
    \        } else {\n            close_count += 1\n        }\n    }\n    if open_count\
    \ == close_count {\n        return \"Yes\"\n    }\n    open_count = 0\n    close_count\
    \ = 0\n    for ch in second {\n        if ch == \"(\" {\n            open_count\
    \ += 1\n        } else {\n            close_count += 1\n        }\n    }\n   \
    \ if open_count == close_count {\n        return \"Yes\"\n    }\n    return \"\
    No\"\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if\
    \ left.count != right.count {\n        return false\n    }\n    for (l, r) in\
    \ zip(left, right) {\n        if l != r {\n            return false\n        }\n\
    \    }\n    return true\n}\n            \nassert(match_parens(lst: [\"()(\", \"\
    )\"]) == \"Yes\")\nassert(match_parens(lst: [\")\", \")\"]) == \"No\")\nassert(match_parens(lst:\
    \ [\"(()(())\", \"())())\"]) == \"No\")\nassert(match_parens(lst: [\")())\", \"\
    (()()(\"]) == \"Yes\")\nassert(match_parens(lst: [\"(())))\", \"(()())((\"]) ==\
    \ \"Yes\")\nassert(match_parens(lst: [\"()\", \"())\"]) == \"No\")\nassert(match_parens(lst:\
    \ [\"(()(\", \"()))()\"]) == \"Yes\")\nassert(match_parens(lst: [\"((((\", \"\
    ((())\"]) == \"No\")\nassert(match_parens(lst: [\")(()\", \"(()(\"]) == \"No\"\
    )\nassert(match_parens(lst: [\")(\", \")(\"]) == \"No\")\nassert(match_parens(lst:\
    \ [\"(\", \")\"]) == \"Yes\")\nassert(match_parens(lst: [\")\", \"(\"]) == \"\
    Yes\")"
  status: Exception
  stderr: 'tmpieeisohj/tmpieeisohj.swift:58: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b1879a9fc80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b1879796b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b1879796988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b18797957b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpieeisohj                        0x000056018a0c16a6 <unavailable> + 5798

    5    libc.so.6                          0x00002b1879c8b460 __libc_start_main +
    245

    6    tmpieeisohj                        0x000056018a0c1289 <unavailable> + 4745

    '
  stdout: ''
  timestamp: 1659979534
- exit_code: 1
  program: "\n/// You are given an array of two strings, both strings consist of open\n\
    /// parentheses '(' or close parentheses ')' only.\n/// Your job is to check if\
    \ it is possible to concatenate the two strings in\n/// some order, that the resulting\
    \ string will be good.\n/// A string S is considered to be good if and only if\
    \ all parentheses in S\n/// are balanced. For example: the string '(())()' is\
    \ good, while the string\n/// '())' is not.\n/// Return 'Yes' if there's a way\
    \ to make a good string, and return 'No' otherwise.\n/// Examples:\n/// >>> match_parens(lst:\
    \ [\"()(\", \")\"])\n/// \"Yes\"\n/// >>> match_parens(lst: [\")\", \")\"])\n\
    /// \"No\"\nfunc match_parens(lst: [String]) -> String {\n    let str = lst[0]\
    \ + lst[1]\n    var i = 0\n    var stack = \"\"\n    while i < str.count {\n \
    \       if str[i] == \"(\" {\n            stack += \"(\"\n        } else {\n \
    \           if stack.count == 0 {\n                return \"No\"\n           \
    \ } else {\n                stack.removeLast()\n            }\n        }\n   \
    \     i += 1\n    }\n    if stack.count == 0 {\n        return \"Yes\"\n    }\
    \ else {\n        return \"No\"\n    }\n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(match_parens(lst: [\"()(\", \")\"]) == \"Yes\")\nassert(match_parens(lst:\
    \ [\")\", \")\"]) == \"No\")\nassert(match_parens(lst: [\"(()(())\", \"())())\"\
    ]) == \"No\")\nassert(match_parens(lst: [\")())\", \"(()()(\"]) == \"Yes\")\n\
    assert(match_parens(lst: [\"(())))\", \"(()())((\"]) == \"Yes\")\nassert(match_parens(lst:\
    \ [\"()\", \"())\"]) == \"No\")\nassert(match_parens(lst: [\"(()(\", \"()))()\"\
    ]) == \"Yes\")\nassert(match_parens(lst: [\"((((\", \"((())\"]) == \"No\")\nassert(match_parens(lst:\
    \ [\")(()\", \"(()(\"]) == \"No\")\nassert(match_parens(lst: [\")(\", \")(\"])\
    \ == \"No\")\nassert(match_parens(lst: [\"(\", \")\"]) == \"Yes\")\nassert(match_parens(lst:\
    \ [\")\", \"(\"]) == \"Yes\")"
  status: SyntaxError
  stderr: "/tmp/tmprnnng5fo.swift:20:12: error: 'subscript(_:)' is unavailable: cannot\
    \ subscript String with an Int, use a String.Index instead.\n        if str[i]\
    \ == \"(\" {\n           ^~~~~~\nSwift.String:3:12: note: 'subscript(_:)' has\
    \ been explicitly marked unavailable here\n    public subscript(i: Int) -> Character\
    \ { get }\n           ^\n"
  stdout: ''
  timestamp: 1659979533
- exit_code: 1
  program: "\n/// You are given an array of two strings, both strings consist of open\n\
    /// parentheses '(' or close parentheses ')' only.\n/// Your job is to check if\
    \ it is possible to concatenate the two strings in\n/// some order, that the resulting\
    \ string will be good.\n/// A string S is considered to be good if and only if\
    \ all parentheses in S\n/// are balanced. For example: the string '(())()' is\
    \ good, while the string\n/// '())' is not.\n/// Return 'Yes' if there's a way\
    \ to make a good string, and return 'No' otherwise.\n/// Examples:\n/// >>> match_parens(lst:\
    \ [\"()(\", \")\"])\n/// \"Yes\"\n/// >>> match_parens(lst: [\")\", \")\"])\n\
    /// \"No\"\nfunc match_parens(lst: [String]) -> String {\n    var str = lst[0]\
    \ + lst[1]\n    var current = 0\n    while current < str.count {\n        if str[current]\
    \ == \")\" {\n            var flag = false\n            for i in 0..<current {\n\
    \                if str[i] == \"(\" {\n                    flag = true\n     \
    \               str.remove(at: i)\n                    str.remove(at: current\
    \ - 1)\n                    current -= 2\n                    break\n        \
    \        }\n            }\n            if !flag {\n                str.remove(at:\
    \ current)\n                current -= 1\n            }\n        }\n        current\
    \ += 1\n    }\n    return str.isEmpty ? \"Yes\" : \"No\"\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(match_parens(lst: [\"()(\", \")\"]) == \"Yes\")\nassert(match_parens(lst:\
    \ [\")\", \")\"]) == \"No\")\nassert(match_parens(lst: [\"(()(())\", \"())())\"\
    ]) == \"No\")\nassert(match_parens(lst: [\")())\", \"(()()(\"]) == \"Yes\")\n\
    assert(match_parens(lst: [\"(())))\", \"(()())((\"]) == \"Yes\")\nassert(match_parens(lst:\
    \ [\"()\", \"())\"]) == \"No\")\nassert(match_parens(lst: [\"(()(\", \"()))()\"\
    ]) == \"Yes\")\nassert(match_parens(lst: [\"((((\", \"((())\"]) == \"No\")\nassert(match_parens(lst:\
    \ [\")(()\", \"(()(\"]) == \"No\")\nassert(match_parens(lst: [\")(\", \")(\"])\
    \ == \"No\")\nassert(match_parens(lst: [\"(\", \")\"]) == \"Yes\")\nassert(match_parens(lst:\
    \ [\")\", \"(\"]) == \"Yes\")"
  status: SyntaxError
  stderr: "/tmp/tmpaxf86hn4.swift:19:12: error: 'subscript(_:)' is unavailable: cannot\
    \ subscript String with an Int, use a String.Index instead.\n        if str[current]\
    \ == \")\" {\n           ^~~~~~~~~~~~\nSwift.String:3:12: note: 'subscript(_:)'\
    \ has been explicitly marked unavailable here\n    public subscript(i: Int) ->\
    \ Character { get }\n           ^\n/tmp/tmpaxf86hn4.swift:22:20: error: 'subscript(_:)'\
    \ is unavailable: cannot subscript String with an Int, use a String.Index instead.\n\
    \                if str[i] == \"(\" {\n                   ^~~~~~\nSwift.String:3:12:\
    \ note: 'subscript(_:)' has been explicitly marked unavailable here\n    public\
    \ subscript(i: Int) -> Character { get }\n           ^\n/tmp/tmpaxf86hn4.swift:24:36:\
    \ error: cannot convert value of type 'Int' to expected argument type 'String.Index'\n\
    \                    str.remove(at: i)\n                                   ^\n\
    /tmp/tmpaxf86hn4.swift:25:44: error: cannot convert value of type 'Int' to expected\
    \ argument type 'String.Index'\n                    str.remove(at: current - 1)\n\
    \                                           ^\n/tmp/tmpaxf86hn4.swift:31:32: error:\
    \ cannot convert value of type 'Int' to expected argument type 'String.Index'\n\
    \                str.remove(at: current)\n                               ^\n"
  stdout: ''
  timestamp: 1659979534
- exit_code: -4
  program: "\n/// You are given an array of two strings, both strings consist of open\n\
    /// parentheses '(' or close parentheses ')' only.\n/// Your job is to check if\
    \ it is possible to concatenate the two strings in\n/// some order, that the resulting\
    \ string will be good.\n/// A string S is considered to be good if and only if\
    \ all parentheses in S\n/// are balanced. For example: the string '(())()' is\
    \ good, while the string\n/// '())' is not.\n/// Return 'Yes' if there's a way\
    \ to make a good string, and return 'No' otherwise.\n/// Examples:\n/// >>> match_parens(lst:\
    \ [\"()(\", \")\"])\n/// \"Yes\"\n/// >>> match_parens(lst: [\")\", \")\"])\n\
    /// \"No\"\nfunc match_parens(lst: [String]) -> String {\n    var lst = lst.joined()\n\
    \    var open = 0\n    var closed = 0\n    for (i, item) in lst.enumerated() {\n\
    \        if item == \"(\" {\n            open += 1\n        } else {\n       \
    \     closed += 1\n        }\n        if closed > open {\n            return \"\
    No\"\n        }\n    }\n    if open == closed {\n        return \"Yes\"\n    }\n\
    \    return \"No\"\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) ->\
    \ Bool {\n    if left.count != right.count {\n        return false\n    }\n  \
    \  for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(match_parens(lst:\
    \ [\"()(\", \")\"]) == \"Yes\")\nassert(match_parens(lst: [\")\", \")\"]) == \"\
    No\")\nassert(match_parens(lst: [\"(()(())\", \"())())\"]) == \"No\")\nassert(match_parens(lst:\
    \ [\")())\", \"(()()(\"]) == \"Yes\")\nassert(match_parens(lst: [\"(())))\", \"\
    (()())((\"]) == \"Yes\")\nassert(match_parens(lst: [\"()\", \"())\"]) == \"No\"\
    )\nassert(match_parens(lst: [\"(()(\", \"()))()\"]) == \"Yes\")\nassert(match_parens(lst:\
    \ [\"((((\", \"((())\"]) == \"No\")\nassert(match_parens(lst: [\")(()\", \"(()(\"\
    ]) == \"No\")\nassert(match_parens(lst: [\")(\", \")(\"]) == \"No\")\nassert(match_parens(lst:\
    \ [\"(\", \")\"]) == \"Yes\")\nassert(match_parens(lst: [\")\", \"(\"]) == \"\
    Yes\")"
  status: Exception
  stderr: 'tmprllsh23h/tmprllsh23h.swift:51: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b1d01638c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b1d0132fb6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b1d0132f988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b1d0132e7b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmprllsh23h                        0x000055ff20febd16 <unavailable> + 7446

    5    libc.so.6                          0x00002b1d01824460 __libc_start_main +
    245

    6    tmprllsh23h                        0x000055ff20feb479 <unavailable> + 5241

    '
  stdout: ''
  timestamp: 1659979534
- exit_code: -4
  program: "\n/// You are given an array of two strings, both strings consist of open\n\
    /// parentheses '(' or close parentheses ')' only.\n/// Your job is to check if\
    \ it is possible to concatenate the two strings in\n/// some order, that the resulting\
    \ string will be good.\n/// A string S is considered to be good if and only if\
    \ all parentheses in S\n/// are balanced. For example: the string '(())()' is\
    \ good, while the string\n/// '())' is not.\n/// Return 'Yes' if there's a way\
    \ to make a good string, and return 'No' otherwise.\n/// Examples:\n/// >>> match_parens(lst:\
    \ [\"()(\", \")\"])\n/// \"Yes\"\n/// >>> match_parens(lst: [\")\", \")\"])\n\
    /// \"No\"\nfunc match_parens(lst: [String]) -> String {\n  // Your code here\n\
    \  return \"\"\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool\
    \ {\n    if left.count != right.count {\n        return false\n    }\n    for\
    \ (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(match_parens(lst:\
    \ [\"()(\", \")\"]) == \"Yes\")\nassert(match_parens(lst: [\")\", \")\"]) == \"\
    No\")\nassert(match_parens(lst: [\"(()(())\", \"())())\"]) == \"No\")\nassert(match_parens(lst:\
    \ [\")())\", \"(()()(\"]) == \"Yes\")\nassert(match_parens(lst: [\"(())))\", \"\
    (()())((\"]) == \"Yes\")\nassert(match_parens(lst: [\"()\", \"())\"]) == \"No\"\
    )\nassert(match_parens(lst: [\"(()(\", \"()))()\"]) == \"Yes\")\nassert(match_parens(lst:\
    \ [\"((((\", \"((())\"]) == \"No\")\nassert(match_parens(lst: [\")(()\", \"(()(\"\
    ]) == \"No\")\nassert(match_parens(lst: [\")(\", \")(\"]) == \"No\")\nassert(match_parens(lst:\
    \ [\"(\", \")\"]) == \"Yes\")\nassert(match_parens(lst: [\")\", \"(\"]) == \"\
    Yes\")"
  status: Exception
  stderr: 'tmp1ezc39l1/tmp1ezc39l1.swift:33: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b0cb39dcc80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b0cb36d3b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b0cb36d3988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b0cb36d27b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmp1ezc39l1                        0x000055ae8e95c4a6 <unavailable> + 5286

    5    libc.so.6                          0x00002b0cb3bc8460 __libc_start_main +
    245

    6    tmp1ezc39l1                        0x000055ae8e95c089 <unavailable> + 4233

    '
  stdout: ''
  timestamp: 1659979534
- exit_code: 1
  program: "\n/// You are given an array of two strings, both strings consist of open\n\
    /// parentheses '(' or close parentheses ')' only.\n/// Your job is to check if\
    \ it is possible to concatenate the two strings in\n/// some order, that the resulting\
    \ string will be good.\n/// A string S is considered to be good if and only if\
    \ all parentheses in S\n/// are balanced. For example: the string '(())()' is\
    \ good, while the string\n/// '())' is not.\n/// Return 'Yes' if there's a way\
    \ to make a good string, and return 'No' otherwise.\n/// Examples:\n/// >>> match_parens(lst:\
    \ [\"()(\", \")\"])\n/// \"Yes\"\n/// >>> match_parens(lst: [\")\", \")\"])\n\
    /// \"No\"\nfunc match_parens(lst: [String]) -> String {\n    var lhs = lst[0]\n\
    \    var rhs = lst[1]\n    var result = \"Yes\"\n    for _ in 0..<lhs.count {\n\
    \        if is_good(str: lhs + rhs) {\n            return result\n        }\n\
    \        if is_good(str: rhs + lhs) {\n            return result\n        }\n\
    \        lhs.append(\"(\")\n        rhs.insert(\"(\", at: rhs.startIndex)\n  \
    \  }\n    result = \"No\"\n    return result\n}\n\n\nfunc ==(left: [(Int, Int)],\
    \ right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n       \
    \ return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r\
    \ {\n            return false\n        }\n    }\n    return true\n}\n        \
    \    \nassert(match_parens(lst: [\"()(\", \")\"]) == \"Yes\")\nassert(match_parens(lst:\
    \ [\")\", \")\"]) == \"No\")\nassert(match_parens(lst: [\"(()(())\", \"())())\"\
    ]) == \"No\")\nassert(match_parens(lst: [\")())\", \"(()()(\"]) == \"Yes\")\n\
    assert(match_parens(lst: [\"(())))\", \"(()())((\"]) == \"Yes\")\nassert(match_parens(lst:\
    \ [\"()\", \"())\"]) == \"No\")\nassert(match_parens(lst: [\"(()(\", \"()))()\"\
    ]) == \"Yes\")\nassert(match_parens(lst: [\"((((\", \"((())\"]) == \"No\")\nassert(match_parens(lst:\
    \ [\")(()\", \"(()(\"]) == \"No\")\nassert(match_parens(lst: [\")(\", \")(\"])\
    \ == \"No\")\nassert(match_parens(lst: [\"(\", \")\"]) == \"Yes\")\nassert(match_parens(lst:\
    \ [\")\", \"(\"]) == \"Yes\")"
  status: SyntaxError
  stderr: "/tmp/tmpntzkluld.swift:20:12: error: cannot find 'is_good' in scope\n \
    \       if is_good(str: lhs + rhs) {\n           ^~~~~~~\n/tmp/tmpntzkluld.swift:23:12:\
    \ error: cannot find 'is_good' in scope\n        if is_good(str: rhs + lhs) {\n\
    \           ^~~~~~~\n"
  stdout: ''
  timestamp: 1659979534
- exit_code: -4
  program: "\n/// You are given an array of two strings, both strings consist of open\n\
    /// parentheses '(' or close parentheses ')' only.\n/// Your job is to check if\
    \ it is possible to concatenate the two strings in\n/// some order, that the resulting\
    \ string will be good.\n/// A string S is considered to be good if and only if\
    \ all parentheses in S\n/// are balanced. For example: the string '(())()' is\
    \ good, while the string\n/// '())' is not.\n/// Return 'Yes' if there's a way\
    \ to make a good string, and return 'No' otherwise.\n/// Examples:\n/// >>> match_parens(lst:\
    \ [\"()(\", \")\"])\n/// \"Yes\"\n/// >>> match_parens(lst: [\")\", \")\"])\n\
    /// \"No\"\nfunc match_parens(lst: [String]) -> String {\n    var s = \"\"\n \
    \   for i in lst {\n        s += i\n    }\n    var open = 0\n    var close = 0\n\
    \    for i in s {\n        if i == \"(\" {\n            open += 1\n        } else\
    \ {\n            close += 1\n        }\n        if close > open {\n          \
    \  return \"No\"\n        }\n    }\n    if open == close {\n        return \"\
    Yes\"\n    }\n    return \"No\"\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int,\
    \ Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n\
    \    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n          \
    \  return false\n        }\n    }\n    return true\n}\n            \nassert(match_parens(lst:\
    \ [\"()(\", \")\"]) == \"Yes\")\nassert(match_parens(lst: [\")\", \")\"]) == \"\
    No\")\nassert(match_parens(lst: [\"(()(())\", \"())())\"]) == \"No\")\nassert(match_parens(lst:\
    \ [\")())\", \"(()()(\"]) == \"Yes\")\nassert(match_parens(lst: [\"(())))\", \"\
    (()())((\"]) == \"Yes\")\nassert(match_parens(lst: [\"()\", \"())\"]) == \"No\"\
    )\nassert(match_parens(lst: [\"(()(\", \"()))()\"]) == \"Yes\")\nassert(match_parens(lst:\
    \ [\"((((\", \"((())\"]) == \"No\")\nassert(match_parens(lst: [\")(()\", \"(()(\"\
    ]) == \"No\")\nassert(match_parens(lst: [\")(\", \")(\"]) == \"No\")\nassert(match_parens(lst:\
    \ [\"(\", \")\"]) == \"Yes\")\nassert(match_parens(lst: [\")\", \"(\"]) == \"\
    Yes\")"
  status: Exception
  stderr: 'tmpsgqzoeal/tmpsgqzoeal.swift:54: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b41652d1c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b4164fc8b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b4164fc8988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b4164fc77b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpsgqzoeal                        0x0000557afac7dc96 <unavailable> + 7318

    5    libc.so.6                          0x00002b41654bd460 __libc_start_main +
    245

    6    tmpsgqzoeal                        0x0000557afac7d3f9 <unavailable> + 5113

    '
  stdout: ''
  timestamp: 1659979534
- exit_code: 1
  program: "\n/// You are given an array of two strings, both strings consist of open\n\
    /// parentheses '(' or close parentheses ')' only.\n/// Your job is to check if\
    \ it is possible to concatenate the two strings in\n/// some order, that the resulting\
    \ string will be good.\n/// A string S is considered to be good if and only if\
    \ all parentheses in S\n/// are balanced. For example: the string '(())()' is\
    \ good, while the string\n/// '())' is not.\n/// Return 'Yes' if there's a way\
    \ to make a good string, and return 'No' otherwise.\n/// Examples:\n/// >>> match_parens(lst:\
    \ [\"()(\", \")\"])\n/// \"Yes\"\n/// >>> match_parens(lst: [\")\", \")\"])\n\
    /// \"No\"\nfunc match_parens(lst: [String]) -> String {\n    let str1 = lst[0]\n\
    \    let str2 = lst[1]\n    return parenthesisChecker(str1 + str2) ? \"Yes\" :\
    \ \"No\"\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n\
    \    if left.count != right.count {\n        return false\n    }\n    for (l,\
    \ r) in zip(left, right) {\n        if l != r {\n            return false\n  \
    \      }\n    }\n    return true\n}\n            \nassert(match_parens(lst: [\"\
    ()(\", \")\"]) == \"Yes\")\nassert(match_parens(lst: [\")\", \")\"]) == \"No\"\
    )\nassert(match_parens(lst: [\"(()(())\", \"())())\"]) == \"No\")\nassert(match_parens(lst:\
    \ [\")())\", \"(()()(\"]) == \"Yes\")\nassert(match_parens(lst: [\"(())))\", \"\
    (()())((\"]) == \"Yes\")\nassert(match_parens(lst: [\"()\", \"())\"]) == \"No\"\
    )\nassert(match_parens(lst: [\"(()(\", \"()))()\"]) == \"Yes\")\nassert(match_parens(lst:\
    \ [\"((((\", \"((())\"]) == \"No\")\nassert(match_parens(lst: [\")(()\", \"(()(\"\
    ]) == \"No\")\nassert(match_parens(lst: [\")(\", \")(\"]) == \"No\")\nassert(match_parens(lst:\
    \ [\"(\", \")\"]) == \"Yes\")\nassert(match_parens(lst: [\")\", \"(\"]) == \"\
    Yes\")"
  status: SyntaxError
  stderr: "/tmp/tmpspjbsbb9.swift:18:12: error: cannot find 'parenthesisChecker' in\
    \ scope\n    return parenthesisChecker(str1 + str2) ? \"Yes\" : \"No\"\n     \
    \      ^~~~~~~~~~~~~~~~~~\n"
  stdout: ''
  timestamp: 1659979534
- exit_code: -4
  program: "\n/// You are given an array of two strings, both strings consist of open\n\
    /// parentheses '(' or close parentheses ')' only.\n/// Your job is to check if\
    \ it is possible to concatenate the two strings in\n/// some order, that the resulting\
    \ string will be good.\n/// A string S is considered to be good if and only if\
    \ all parentheses in S\n/// are balanced. For example: the string '(())()' is\
    \ good, while the string\n/// '())' is not.\n/// Return 'Yes' if there's a way\
    \ to make a good string, and return 'No' otherwise.\n/// Examples:\n/// >>> match_parens(lst:\
    \ [\"()(\", \")\"])\n/// \"Yes\"\n/// >>> match_parens(lst: [\")\", \")\"])\n\
    /// \"No\"\nfunc match_parens(lst: [String]) -> String {\n    let s1 = lst[0]\n\
    \    let s2 = lst[1]\n    var res1 = 0\n    var res2 = 0\n    var res3 = 0\n \
    \   var res4 = 0\n    for c in s1 {\n        if c == \"(\" {\n            res1\
    \ += 1\n        } else {\n            res1 -= 1\n        }\n    }\n    for c in\
    \ s2 {\n        if c == \"(\" {\n            res2 += 1\n        } else {\n   \
    \         res2 -= 1\n        }\n    }\n    if res1 < 0 || res2 < 0 {\n       \
    \ return \"No\"\n    }\n    res3 = res1 + res2\n    if res3 % 2 != 0 {\n     \
    \   return \"No\"\n    }\n    res4 = res3 / 2\n    if s1.count >= res4 && s2.count\
    \ >= res4 {\n        return \"Yes\"\n    }\n    return \"No\"\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(match_parens(lst: [\"()(\", \")\"]) == \"Yes\")\nassert(match_parens(lst:\
    \ [\")\", \")\"]) == \"No\")\nassert(match_parens(lst: [\"(()(())\", \"())())\"\
    ]) == \"No\")\nassert(match_parens(lst: [\")())\", \"(()()(\"]) == \"Yes\")\n\
    assert(match_parens(lst: [\"(())))\", \"(()())((\"]) == \"Yes\")\nassert(match_parens(lst:\
    \ [\"()\", \"())\"]) == \"No\")\nassert(match_parens(lst: [\"(()(\", \"()))()\"\
    ]) == \"Yes\")\nassert(match_parens(lst: [\"((((\", \"((())\"]) == \"No\")\nassert(match_parens(lst:\
    \ [\")(()\", \"(()(\"]) == \"No\")\nassert(match_parens(lst: [\")(\", \")(\"])\
    \ == \"No\")\nassert(match_parens(lst: [\"(\", \")\"]) == \"Yes\")\nassert(match_parens(lst:\
    \ [\")\", \"(\"]) == \"Yes\")"
  status: Exception
  stderr: 'tmp0396u4vf/tmp0396u4vf.swift:63: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002af136fccc80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002af136cc3b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002af136cc3988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002af136cc27b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmp0396u4vf                        0x0000560ccac0c786 <unavailable> + 6022

    5    libc.so.6                          0x00002af1371b8460 __libc_start_main +
    245

    6    tmp0396u4vf                        0x0000560ccac0c369 <unavailable> + 4969

    '
  stdout: ''
  timestamp: 1659979534
- exit_code: -4
  program: "\n/// You are given an array of two strings, both strings consist of open\n\
    /// parentheses '(' or close parentheses ')' only.\n/// Your job is to check if\
    \ it is possible to concatenate the two strings in\n/// some order, that the resulting\
    \ string will be good.\n/// A string S is considered to be good if and only if\
    \ all parentheses in S\n/// are balanced. For example: the string '(())()' is\
    \ good, while the string\n/// '())' is not.\n/// Return 'Yes' if there's a way\
    \ to make a good string, and return 'No' otherwise.\n/// Examples:\n/// >>> match_parens(lst:\
    \ [\"()(\", \")\"])\n/// \"Yes\"\n/// >>> match_parens(lst: [\")\", \")\"])\n\
    /// \"No\"\nfunc match_parens(lst: [String]) -> String {\n    var res: String\
    \ = \"Yes\"\n    var cnt1: Int = 0\n    var cnt2: Int = 0\n    for c in lst[0]\
    \ {\n        if c == \"(\" {\n            cnt1 += 1\n        } else {\n      \
    \      cnt1 -= 1\n        }\n    }\n    for c in lst[1] {\n        if c == \"\
    (\" {\n            cnt2 += 1\n        } else {\n            cnt2 -= 1\n      \
    \  }\n    }\n    if cnt1 < 0 || cnt2 < 0 {\n        res = \"No\"\n    }\n    return\
    \ res\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n   \
    \ if left.count != right.count {\n        return false\n    }\n    for (l, r)\
    \ in zip(left, right) {\n        if l != r {\n            return false\n     \
    \   }\n    }\n    return true\n}\n            \nassert(match_parens(lst: [\"()(\"\
    , \")\"]) == \"Yes\")\nassert(match_parens(lst: [\")\", \")\"]) == \"No\")\nassert(match_parens(lst:\
    \ [\"(()(())\", \"())())\"]) == \"No\")\nassert(match_parens(lst: [\")())\", \"\
    (()()(\"]) == \"Yes\")\nassert(match_parens(lst: [\"(())))\", \"(()())((\"]) ==\
    \ \"Yes\")\nassert(match_parens(lst: [\"()\", \"())\"]) == \"No\")\nassert(match_parens(lst:\
    \ [\"(()(\", \"()))()\"]) == \"Yes\")\nassert(match_parens(lst: [\"((((\", \"\
    ((())\"]) == \"No\")\nassert(match_parens(lst: [\")(()\", \"(()(\"]) == \"No\"\
    )\nassert(match_parens(lst: [\")(\", \")(\"]) == \"No\")\nassert(match_parens(lst:\
    \ [\"(\", \")\"]) == \"Yes\")\nassert(match_parens(lst: [\")\", \"(\"]) == \"\
    Yes\")"
  status: Exception
  stderr: 'tmpo1uazge6/tmpo1uazge6.swift:52: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b5e4e60cc80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b5e4e303b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b5e4e303988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b5e4e3027b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpo1uazge6                        0x00005605a887b6a6 <unavailable> + 5798

    5    libc.so.6                          0x00002b5e4e7f8460 __libc_start_main +
    245

    6    tmpo1uazge6                        0x00005605a887b289 <unavailable> + 4745

    '
  stdout: ''
  timestamp: 1659979534
- exit_code: -4
  program: "\n/// You are given an array of two strings, both strings consist of open\n\
    /// parentheses '(' or close parentheses ')' only.\n/// Your job is to check if\
    \ it is possible to concatenate the two strings in\n/// some order, that the resulting\
    \ string will be good.\n/// A string S is considered to be good if and only if\
    \ all parentheses in S\n/// are balanced. For example: the string '(())()' is\
    \ good, while the string\n/// '())' is not.\n/// Return 'Yes' if there's a way\
    \ to make a good string, and return 'No' otherwise.\n/// Examples:\n/// >>> match_parens(lst:\
    \ [\"()(\", \")\"])\n/// \"Yes\"\n/// >>> match_parens(lst: [\")\", \")\"])\n\
    /// \"No\"\nfunc match_parens(lst: [String]) -> String {\n    let str = lst[0]\
    \ + lst[1]\n    let _ = str.reduce(0) { (count, c) -> Int in\n        if c ==\
    \ \"(\" {\n            return count + 1\n        } else {\n            return\
    \ count - 1\n        }\n    }\n    return \"No\"\n}\n\n\nfunc ==(left: [(Int,\
    \ Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n\
    \        return false\n    }\n    for (l, r) in zip(left, right) {\n        if\
    \ l != r {\n            return false\n        }\n    }\n    return true\n}\n \
    \           \nassert(match_parens(lst: [\"()(\", \")\"]) == \"Yes\")\nassert(match_parens(lst:\
    \ [\")\", \")\"]) == \"No\")\nassert(match_parens(lst: [\"(()(())\", \"())())\"\
    ]) == \"No\")\nassert(match_parens(lst: [\")())\", \"(()()(\"]) == \"Yes\")\n\
    assert(match_parens(lst: [\"(())))\", \"(()())((\"]) == \"Yes\")\nassert(match_parens(lst:\
    \ [\"()\", \"())\"]) == \"No\")\nassert(match_parens(lst: [\"(()(\", \"()))()\"\
    ]) == \"Yes\")\nassert(match_parens(lst: [\"((((\", \"((())\"]) == \"No\")\nassert(match_parens(lst:\
    \ [\")(()\", \"(()(\"]) == \"No\")\nassert(match_parens(lst: [\")(\", \")(\"])\
    \ == \"No\")\nassert(match_parens(lst: [\"(\", \")\"]) == \"Yes\")\nassert(match_parens(lst:\
    \ [\")\", \"(\"]) == \"Yes\")"
  status: Exception
  stderr: 'tmpxuxst0nf/tmpxuxst0nf.swift:40: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b3c767e2c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b3c764d9b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b3c764d9988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b3c764d87b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpxuxst0nf                        0x000055f4401ac6e6 <unavailable> + 5862

    5    libc.so.6                          0x00002b3c769ce460 __libc_start_main +
    245

    6    tmpxuxst0nf                        0x000055f4401ac2c9 <unavailable> + 4809

    '
  stdout: ''
  timestamp: 1659979534
- exit_code: 1
  program: "\n/// You are given an array of two strings, both strings consist of open\n\
    /// parentheses '(' or close parentheses ')' only.\n/// Your job is to check if\
    \ it is possible to concatenate the two strings in\n/// some order, that the resulting\
    \ string will be good.\n/// A string S is considered to be good if and only if\
    \ all parentheses in S\n/// are balanced. For example: the string '(())()' is\
    \ good, while the string\n/// '())' is not.\n/// Return 'Yes' if there's a way\
    \ to make a good string, and return 'No' otherwise.\n/// Examples:\n/// >>> match_parens(lst:\
    \ [\"()(\", \")\"])\n/// \"Yes\"\n/// >>> match_parens(lst: [\")\", \")\"])\n\
    /// \"No\"\nfunc match_parens(lst: [String]) -> String {\n    return String(parens(lst:\
    \ lst) ? \"Yes\" : \"No\")\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(match_parens(lst:\
    \ [\"()(\", \")\"]) == \"Yes\")\nassert(match_parens(lst: [\")\", \")\"]) == \"\
    No\")\nassert(match_parens(lst: [\"(()(())\", \"())())\"]) == \"No\")\nassert(match_parens(lst:\
    \ [\")())\", \"(()()(\"]) == \"Yes\")\nassert(match_parens(lst: [\"(())))\", \"\
    (()())((\"]) == \"Yes\")\nassert(match_parens(lst: [\"()\", \"())\"]) == \"No\"\
    )\nassert(match_parens(lst: [\"(()(\", \"()))()\"]) == \"Yes\")\nassert(match_parens(lst:\
    \ [\"((((\", \"((())\"]) == \"No\")\nassert(match_parens(lst: [\")(()\", \"(()(\"\
    ]) == \"No\")\nassert(match_parens(lst: [\")(\", \")(\"]) == \"No\")\nassert(match_parens(lst:\
    \ [\"(\", \")\"]) == \"Yes\")\nassert(match_parens(lst: [\")\", \"(\"]) == \"\
    Yes\")"
  status: SyntaxError
  stderr: "/tmp/tmpew9kic28.swift:16:19: error: cannot find 'parens' in scope\n  \
    \  return String(parens(lst: lst) ? \"Yes\" : \"No\")\n                  ^~~~~~\n"
  stdout: ''
  timestamp: 1659979534
- exit_code: 1
  program: "\n/// You are given an array of two strings, both strings consist of open\n\
    /// parentheses '(' or close parentheses ')' only.\n/// Your job is to check if\
    \ it is possible to concatenate the two strings in\n/// some order, that the resulting\
    \ string will be good.\n/// A string S is considered to be good if and only if\
    \ all parentheses in S\n/// are balanced. For example: the string '(())()' is\
    \ good, while the string\n/// '())' is not.\n/// Return 'Yes' if there's a way\
    \ to make a good string, and return 'No' otherwise.\n/// Examples:\n/// >>> match_parens(lst:\
    \ [\"()(\", \")\"])\n/// \"Yes\"\n/// >>> match_parens(lst: [\")\", \")\"])\n\
    /// \"No\"\nfunc match_parens(lst: [String]) -> String {\n    var s1 = lst[0]\n\
    \    var s2 = lst[1]\n    var i = 0\n    while i < s1.count {\n        if (s1[i]\
    \ == \")\" && s2[0] == \"(\") {\n            return \"Yes\"\n        }\n     \
    \   s1.remove(at: i)\n    }\n    return \"No\"\n}\n\n\nfunc ==(left: [(Int, Int)],\
    \ right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n       \
    \ return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r\
    \ {\n            return false\n        }\n    }\n    return true\n}\n        \
    \    \nassert(match_parens(lst: [\"()(\", \")\"]) == \"Yes\")\nassert(match_parens(lst:\
    \ [\")\", \")\"]) == \"No\")\nassert(match_parens(lst: [\"(()(())\", \"())())\"\
    ]) == \"No\")\nassert(match_parens(lst: [\")())\", \"(()()(\"]) == \"Yes\")\n\
    assert(match_parens(lst: [\"(())))\", \"(()())((\"]) == \"Yes\")\nassert(match_parens(lst:\
    \ [\"()\", \"())\"]) == \"No\")\nassert(match_parens(lst: [\"(()(\", \"()))()\"\
    ]) == \"Yes\")\nassert(match_parens(lst: [\"((((\", \"((())\"]) == \"No\")\nassert(match_parens(lst:\
    \ [\")(()\", \"(()(\"]) == \"No\")\nassert(match_parens(lst: [\")(\", \")(\"])\
    \ == \"No\")\nassert(match_parens(lst: [\"(\", \")\"]) == \"Yes\")\nassert(match_parens(lst:\
    \ [\")\", \"(\"]) == \"Yes\")"
  status: SyntaxError
  stderr: "/tmp/tmpzthww5l5.swift:20:13: error: 'subscript(_:)' is unavailable: cannot\
    \ subscript String with an Int, use a String.Index instead.\n        if (s1[i]\
    \ == \")\" && s2[0] == \"(\") {\n            ^~~~~\nSwift.String:3:12: note: 'subscript(_:)'\
    \ has been explicitly marked unavailable here\n    public subscript(i: Int) ->\
    \ Character { get }\n           ^\n/tmp/tmpzthww5l5.swift:20:29: error: 'subscript(_:)'\
    \ is unavailable: cannot subscript String with an Int, use a String.Index instead.\n\
    \        if (s1[i] == \")\" && s2[0] == \"(\") {\n                           \
    \ ^~~~~\nSwift.String:3:12: note: 'subscript(_:)' has been explicitly marked unavailable\
    \ here\n    public subscript(i: Int) -> Character { get }\n           ^\n/tmp/tmpzthww5l5.swift:23:23:\
    \ error: cannot convert value of type 'Int' to expected argument type 'String.Index'\n\
    \        s1.remove(at: i)\n                      ^\n"
  stdout: ''
  timestamp: 1659979534
- exit_code: 1
  program: "\n/// You are given an array of two strings, both strings consist of open\n\
    /// parentheses '(' or close parentheses ')' only.\n/// Your job is to check if\
    \ it is possible to concatenate the two strings in\n/// some order, that the resulting\
    \ string will be good.\n/// A string S is considered to be good if and only if\
    \ all parentheses in S\n/// are balanced. For example: the string '(())()' is\
    \ good, while the string\n/// '())' is not.\n/// Return 'Yes' if there's a way\
    \ to make a good string, and return 'No' otherwise.\n/// Examples:\n/// >>> match_parens(lst:\
    \ [\"()(\", \")\"])\n/// \"Yes\"\n/// >>> match_parens(lst: [\")\", \")\"])\n\
    /// \"No\"\nfunc match_parens(lst: [String]) -> String {\n    var s1 = lst[0]\n\
    \    var s2 = lst[1]\n    let len1 = s1.count\n    let len2 = s2.count\n    var\
    \ isMatched = false\n    for _ in 0..<len1 {\n        if isBalanced(s: s1 + s2)\
    \ {\n            isMatched = true\n            break\n        }\n        s1.insert(\"\
    \ \", at: s1.startIndex)\n    }\n    if !isMatched {\n        for _ in 0..<len2\
    \ {\n            if isBalanced(s: s1 + s2) {\n                isMatched = true\n\
    \                break\n            }\n            s2.insert(\" \", at: s2.startIndex)\n\
    \        }\n    }\n    return isMatched ? \"Yes\" : \"No\"\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(match_parens(lst: [\"()(\", \")\"]) == \"Yes\")\nassert(match_parens(lst:\
    \ [\")\", \")\"]) == \"No\")\nassert(match_parens(lst: [\"(()(())\", \"())())\"\
    ]) == \"No\")\nassert(match_parens(lst: [\")())\", \"(()()(\"]) == \"Yes\")\n\
    assert(match_parens(lst: [\"(())))\", \"(()())((\"]) == \"Yes\")\nassert(match_parens(lst:\
    \ [\"()\", \"())\"]) == \"No\")\nassert(match_parens(lst: [\"(()(\", \"()))()\"\
    ]) == \"Yes\")\nassert(match_parens(lst: [\"((((\", \"((())\"]) == \"No\")\nassert(match_parens(lst:\
    \ [\")(()\", \"(()(\"]) == \"No\")\nassert(match_parens(lst: [\")(\", \")(\"])\
    \ == \"No\")\nassert(match_parens(lst: [\"(\", \")\"]) == \"Yes\")\nassert(match_parens(lst:\
    \ [\")\", \"(\"]) == \"Yes\")"
  status: SyntaxError
  stderr: "/tmp/tmptae8r5jn.swift:22:12: error: cannot find 'isBalanced' in scope\n\
    \        if isBalanced(s: s1 + s2) {\n           ^~~~~~~~~~\n/tmp/tmptae8r5jn.swift:30:16:\
    \ error: cannot find 'isBalanced' in scope\n            if isBalanced(s: s1 +\
    \ s2) {\n               ^~~~~~~~~~\n"
  stdout: ''
  timestamp: 1659979534
- exit_code: -4
  program: "\n/// You are given an array of two strings, both strings consist of open\n\
    /// parentheses '(' or close parentheses ')' only.\n/// Your job is to check if\
    \ it is possible to concatenate the two strings in\n/// some order, that the resulting\
    \ string will be good.\n/// A string S is considered to be good if and only if\
    \ all parentheses in S\n/// are balanced. For example: the string '(())()' is\
    \ good, while the string\n/// '())' is not.\n/// Return 'Yes' if there's a way\
    \ to make a good string, and return 'No' otherwise.\n/// Examples:\n/// >>> match_parens(lst:\
    \ [\"()(\", \")\"])\n/// \"Yes\"\n/// >>> match_parens(lst: [\")\", \")\"])\n\
    /// \"No\"\nfunc match_parens(lst: [String]) -> String {\n    let allStr = lst.joined()\n\
    \    var c = 0\n    for i in allStr {\n        if i == \"(\" {\n            c\
    \ += 1\n        } else {\n            c -= 1\n        }\n        if c < 0 {\n\
    \            return \"No\"\n        }\n    }\n    return c == 0 ? \"Yes\" : \"\
    No\"\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if\
    \ left.count != right.count {\n        return false\n    }\n    for (l, r) in\
    \ zip(left, right) {\n        if l != r {\n            return false\n        }\n\
    \    }\n    return true\n}\n            \nassert(match_parens(lst: [\"()(\", \"\
    )\"]) == \"Yes\")\nassert(match_parens(lst: [\")\", \")\"]) == \"No\")\nassert(match_parens(lst:\
    \ [\"(()(())\", \"())())\"]) == \"No\")\nassert(match_parens(lst: [\")())\", \"\
    (()()(\"]) == \"Yes\")\nassert(match_parens(lst: [\"(())))\", \"(()())((\"]) ==\
    \ \"Yes\")\nassert(match_parens(lst: [\"()\", \"())\"]) == \"No\")\nassert(match_parens(lst:\
    \ [\"(()(\", \"()))()\"]) == \"Yes\")\nassert(match_parens(lst: [\"((((\", \"\
    ((())\"]) == \"No\")\nassert(match_parens(lst: [\")(()\", \"(()(\"]) == \"No\"\
    )\nassert(match_parens(lst: [\")(\", \")(\"]) == \"No\")\nassert(match_parens(lst:\
    \ [\"(\", \")\"]) == \"Yes\")\nassert(match_parens(lst: [\")\", \"(\"]) == \"\
    Yes\")"
  status: Exception
  stderr: 'tmpw4hx0q9q/tmpw4hx0q9q.swift:47: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b2186f46c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b2186c3db6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b2186c3d988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b2186c3c7b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpw4hx0q9q                        0x00005634030dab76 <unavailable> + 7030

    5    libc.so.6                          0x00002b2187132460 __libc_start_main +
    245

    6    tmpw4hx0q9q                        0x00005634030da2d9 <unavailable> + 4825

    '
  stdout: ''
  timestamp: 1659979534
- exit_code: -4
  program: "\n/// You are given an array of two strings, both strings consist of open\n\
    /// parentheses '(' or close parentheses ')' only.\n/// Your job is to check if\
    \ it is possible to concatenate the two strings in\n/// some order, that the resulting\
    \ string will be good.\n/// A string S is considered to be good if and only if\
    \ all parentheses in S\n/// are balanced. For example: the string '(())()' is\
    \ good, while the string\n/// '())' is not.\n/// Return 'Yes' if there's a way\
    \ to make a good string, and return 'No' otherwise.\n/// Examples:\n/// >>> match_parens(lst:\
    \ [\"()(\", \")\"])\n/// \"Yes\"\n/// >>> match_parens(lst: [\")\", \")\"])\n\
    /// \"No\"\nfunc match_parens(lst: [String]) -> String {\n    // If first string\
    \ ends with ')' then we always cannot match\n    if lst[0].hasSuffix(\")\") {\n\
    \        return \"No\"\n    }\n    // If first string ends with '(' and second\
    \ string starts with ')' then\n    // we cannot match\n    if lst[0].hasSuffix(\"\
    (\") && lst[1].hasPrefix(\")\") {\n        return \"No\"\n    }\n    // Now we\
    \ just need to check whether both strings are good on their own\n    // and that\
    \ they match\n    let is_good = [lst[0], lst[1]].map {str in\n        // 'balance'\
    \ is the number of open parentheses minus the number of closed\n        // parentheses\
    \ at any given point. If it ever becomes negative we cannot\n        // match\n\
    \        var balance = 0\n        for c in str {\n            balance += (c ==\
    \ \"(\") ? 1 : -1\n            if balance < 0 {\n                return false\n\
    \            }\n        }\n        return balance == 0\n    }\n    return is_good[0]\
    \ && is_good[1] ? \"Yes\" : \"No\"\n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(match_parens(lst: [\"()(\", \")\"]) == \"Yes\")\nassert(match_parens(lst:\
    \ [\")\", \")\"]) == \"No\")\nassert(match_parens(lst: [\"(()(())\", \"())())\"\
    ]) == \"No\")\nassert(match_parens(lst: [\")())\", \"(()()(\"]) == \"Yes\")\n\
    assert(match_parens(lst: [\"(())))\", \"(()())((\"]) == \"Yes\")\nassert(match_parens(lst:\
    \ [\"()\", \"())\"]) == \"No\")\nassert(match_parens(lst: [\"(()(\", \"()))()\"\
    ]) == \"Yes\")\nassert(match_parens(lst: [\"((((\", \"((())\"]) == \"No\")\nassert(match_parens(lst:\
    \ [\")(()\", \"(()(\"]) == \"No\")\nassert(match_parens(lst: [\")(\", \")(\"])\
    \ == \"No\")\nassert(match_parens(lst: [\"(\", \")\"]) == \"Yes\")\nassert(match_parens(lst:\
    \ [\")\", \"(\"]) == \"Yes\")"
  status: Exception
  stderr: 'tmpuqeuiy3t/tmpuqeuiy3t.swift:56: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b3244b27c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b324481eb6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b324481e988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b324481d7b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpuqeuiy3t                        0x0000558679d80876 <unavailable> + 6262

    5    libc.so.6                          0x00002b3244d13460 __libc_start_main +
    245

    6    tmpuqeuiy3t                        0x0000558679d80459 <unavailable> + 5209

    '
  stdout: ''
  timestamp: 1659979534
- exit_code: 1
  program: "\n/// You are given an array of two strings, both strings consist of open\n\
    /// parentheses '(' or close parentheses ')' only.\n/// Your job is to check if\
    \ it is possible to concatenate the two strings in\n/// some order, that the resulting\
    \ string will be good.\n/// A string S is considered to be good if and only if\
    \ all parentheses in S\n/// are balanced. For example: the string '(())()' is\
    \ good, while the string\n/// '())' is not.\n/// Return 'Yes' if there's a way\
    \ to make a good string, and return 'No' otherwise.\n/// Examples:\n/// >>> match_parens(lst:\
    \ [\"()(\", \")\"])\n/// \"Yes\"\n/// >>> match_parens(lst: [\")\", \")\"])\n\
    /// \"No\"\nfunc match_parens(lst: [String]) -> String {\n    var count: Int =\
    \ 0\n    for i in 0..<lst.count {\n        let str = lst[i]\n        for j in\
    \ 0..<str.count {\n            let char = str[j]\n            if char == \"(\"\
    \ {\n                count += 1\n            } else {\n                count -=\
    \ 1\n            }\n            if count < 0 {\n                return \"No\"\n\
    \            }\n        }\n    }\n    return count == 0 ? \"Yes\" : \"No\"\n}\n\
    \n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(match_parens(lst: [\"()(\", \")\"]) == \"Yes\"\
    )\nassert(match_parens(lst: [\")\", \")\"]) == \"No\")\nassert(match_parens(lst:\
    \ [\"(()(())\", \"())())\"]) == \"No\")\nassert(match_parens(lst: [\")())\", \"\
    (()()(\"]) == \"Yes\")\nassert(match_parens(lst: [\"(())))\", \"(()())((\"]) ==\
    \ \"Yes\")\nassert(match_parens(lst: [\"()\", \"())\"]) == \"No\")\nassert(match_parens(lst:\
    \ [\"(()(\", \"()))()\"]) == \"Yes\")\nassert(match_parens(lst: [\"((((\", \"\
    ((())\"]) == \"No\")\nassert(match_parens(lst: [\")(()\", \"(()(\"]) == \"No\"\
    )\nassert(match_parens(lst: [\")(\", \")(\"]) == \"No\")\nassert(match_parens(lst:\
    \ [\"(\", \")\"]) == \"Yes\")\nassert(match_parens(lst: [\")\", \"(\"]) == \"\
    Yes\")"
  status: SyntaxError
  stderr: "/tmp/tmp2273bqib.swift:20:24: error: 'subscript(_:)' is unavailable: cannot\
    \ subscript String with an Int, use a String.Index instead.\n            let char\
    \ = str[j]\n                       ^~~~~~\nSwift.String:3:12: note: 'subscript(_:)'\
    \ has been explicitly marked unavailable here\n    public subscript(i: Int) ->\
    \ Character { get }\n           ^\n"
  stdout: ''
  timestamp: 1659979534
- exit_code: -4
  program: "\n/// You are given an array of two strings, both strings consist of open\n\
    /// parentheses '(' or close parentheses ')' only.\n/// Your job is to check if\
    \ it is possible to concatenate the two strings in\n/// some order, that the resulting\
    \ string will be good.\n/// A string S is considered to be good if and only if\
    \ all parentheses in S\n/// are balanced. For example: the string '(())()' is\
    \ good, while the string\n/// '())' is not.\n/// Return 'Yes' if there's a way\
    \ to make a good string, and return 'No' otherwise.\n/// Examples:\n/// >>> match_parens(lst:\
    \ [\"()(\", \")\"])\n/// \"Yes\"\n/// >>> match_parens(lst: [\")\", \")\"])\n\
    /// \"No\"\nfunc match_parens(lst: [String]) -> String {\n    var lft = [Character]()\n\
    \    var rgt = [Character]()\n    for i in 0..<lst.count {\n        for c in lst[i]\
    \ {\n            if c == \"(\" {\n                lft.append(c)\n            }\
    \ else {\n                rgt.append(c)\n            }\n        }\n    }\n   \
    \ let lftcnt = lft.count\n    let rgtcnt = rgt.count\n    if lftcnt == rgtcnt\
    \ {\n        return \"Yes\"\n    } else if lftcnt > rgtcnt {\n        return \"\
    No\"\n    } else {\n        return \"Yes\"\n    }\n}\n\n\nfunc ==(left: [(Int,\
    \ Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n\
    \        return false\n    }\n    for (l, r) in zip(left, right) {\n        if\
    \ l != r {\n            return false\n        }\n    }\n    return true\n}\n \
    \           \nassert(match_parens(lst: [\"()(\", \")\"]) == \"Yes\")\nassert(match_parens(lst:\
    \ [\")\", \")\"]) == \"No\")\nassert(match_parens(lst: [\"(()(())\", \"())())\"\
    ]) == \"No\")\nassert(match_parens(lst: [\")())\", \"(()()(\"]) == \"Yes\")\n\
    assert(match_parens(lst: [\"(())))\", \"(()())((\"]) == \"Yes\")\nassert(match_parens(lst:\
    \ [\"()\", \"())\"]) == \"No\")\nassert(match_parens(lst: [\"(()(\", \"()))()\"\
    ]) == \"Yes\")\nassert(match_parens(lst: [\"((((\", \"((())\"]) == \"No\")\nassert(match_parens(lst:\
    \ [\")(()\", \"(()(\"]) == \"No\")\nassert(match_parens(lst: [\")(\", \")(\"])\
    \ == \"No\")\nassert(match_parens(lst: [\"(\", \")\"]) == \"Yes\")\nassert(match_parens(lst:\
    \ [\")\", \"(\"]) == \"Yes\")"
  status: Exception
  stderr: 'tmp3wdsin3s/tmp3wdsin3s.swift:52: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b01774fcc80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b01771f3b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b01771f3988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b01771f27b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmp3wdsin3s                        0x000055b10b22caf0 <unavailable> + 6896

    5    libc.so.6                          0x00002b01776e8460 __libc_start_main +
    245

    6    tmp3wdsin3s                        0x000055b10b22c569 <unavailable> + 5481

    '
  stdout: ''
  timestamp: 1659979534
- exit_code: -4
  program: "\n/// You are given an array of two strings, both strings consist of open\n\
    /// parentheses '(' or close parentheses ')' only.\n/// Your job is to check if\
    \ it is possible to concatenate the two strings in\n/// some order, that the resulting\
    \ string will be good.\n/// A string S is considered to be good if and only if\
    \ all parentheses in S\n/// are balanced. For example: the string '(())()' is\
    \ good, while the string\n/// '())' is not.\n/// Return 'Yes' if there's a way\
    \ to make a good string, and return 'No' otherwise.\n/// Examples:\n/// >>> match_parens(lst:\
    \ [\"()(\", \")\"])\n/// \"Yes\"\n/// >>> match_parens(lst: [\")\", \")\"])\n\
    /// \"No\"\nfunc match_parens(lst: [String]) -> String {\n    let first = lst[0]\n\
    \    let second = lst[1]\n    var firstCounter = 0\n    var secondCounter = 0\n\
    \    for a in first {\n        if a == \"(\" {\n            firstCounter += 1\n\
    \        } else {\n            firstCounter -= 1\n        }\n    }\n    for b\
    \ in second {\n        if b == \"(\" {\n            secondCounter += 1\n     \
    \   } else {\n            secondCounter -= 1\n        }\n    }\n    if firstCounter\
    \ >= 0 && secondCounter >= 0 {\n        return \"Yes\"\n    } else if firstCounter\
    \ >= 0 && secondCounter < 0 {\n        return \"No\"\n    } else if firstCounter\
    \ < 0 && secondCounter >= 0 {\n        return \"No\"\n    } else {\n        return\
    \ \"Yes\"\n    }\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool\
    \ {\n    if left.count != right.count {\n        return false\n    }\n    for\
    \ (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(match_parens(lst:\
    \ [\"()(\", \")\"]) == \"Yes\")\nassert(match_parens(lst: [\")\", \")\"]) == \"\
    No\")\nassert(match_parens(lst: [\"(()(())\", \"())())\"]) == \"No\")\nassert(match_parens(lst:\
    \ [\")())\", \"(()()(\"]) == \"Yes\")\nassert(match_parens(lst: [\"(())))\", \"\
    (()())((\"]) == \"Yes\")\nassert(match_parens(lst: [\"()\", \"())\"]) == \"No\"\
    )\nassert(match_parens(lst: [\"(()(\", \"()))()\"]) == \"Yes\")\nassert(match_parens(lst:\
    \ [\"((((\", \"((())\"]) == \"No\")\nassert(match_parens(lst: [\")(()\", \"(()(\"\
    ]) == \"No\")\nassert(match_parens(lst: [\")(\", \")(\"]) == \"No\")\nassert(match_parens(lst:\
    \ [\"(\", \")\"]) == \"Yes\")\nassert(match_parens(lst: [\")\", \"(\"]) == \"\
    Yes\")"
  status: Exception
  stderr: 'tmpr5prurf1/tmpr5prurf1.swift:58: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b7897d29c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b7897a20b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b7897a20988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b7897a1f7b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpr5prurf1                        0x000055f5e43f06a6 <unavailable> + 5798

    5    libc.so.6                          0x00002b7897f15460 __libc_start_main +
    245

    6    tmpr5prurf1                        0x000055f5e43f0289 <unavailable> + 4745

    '
  stdout: ''
  timestamp: 1659979534
- exit_code: 1
  program: "\n/// You are given an array of two strings, both strings consist of open\n\
    /// parentheses '(' or close parentheses ')' only.\n/// Your job is to check if\
    \ it is possible to concatenate the two strings in\n/// some order, that the resulting\
    \ string will be good.\n/// A string S is considered to be good if and only if\
    \ all parentheses in S\n/// are balanced. For example: the string '(())()' is\
    \ good, while the string\n/// '())' is not.\n/// Return 'Yes' if there's a way\
    \ to make a good string, and return 'No' otherwise.\n/// Examples:\n/// >>> match_parens(lst:\
    \ [\"()(\", \")\"])\n/// \"Yes\"\n/// >>> match_parens(lst: [\")\", \")\"])\n\
    /// \"No\"\nfunc match_parens(lst: [String]) -> String {\n    var lst = lst\n\
    \    var s: String = \"\"\n    while lst.count > 0 {\n        s += lst.popLast()!\n\
    \    }\n    if s.isParensGood() {\n        return \"Yes\"\n    }\n    return \"\
    No\"\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if\
    \ left.count != right.count {\n        return false\n    }\n    for (l, r) in\
    \ zip(left, right) {\n        if l != r {\n            return false\n        }\n\
    \    }\n    return true\n}\n            \nassert(match_parens(lst: [\"()(\", \"\
    )\"]) == \"Yes\")\nassert(match_parens(lst: [\")\", \")\"]) == \"No\")\nassert(match_parens(lst:\
    \ [\"(()(())\", \"())())\"]) == \"No\")\nassert(match_parens(lst: [\")())\", \"\
    (()()(\"]) == \"Yes\")\nassert(match_parens(lst: [\"(())))\", \"(()())((\"]) ==\
    \ \"Yes\")\nassert(match_parens(lst: [\"()\", \"())\"]) == \"No\")\nassert(match_parens(lst:\
    \ [\"(()(\", \"()))()\"]) == \"Yes\")\nassert(match_parens(lst: [\"((((\", \"\
    ((())\"]) == \"No\")\nassert(match_parens(lst: [\")(()\", \"(()(\"]) == \"No\"\
    )\nassert(match_parens(lst: [\")(\", \")(\"]) == \"No\")\nassert(match_parens(lst:\
    \ [\"(\", \")\"]) == \"Yes\")\nassert(match_parens(lst: [\")\", \"(\"]) == \"\
    Yes\")"
  status: SyntaxError
  stderr: "/tmp/tmpccy0njxg.swift:21:10: error: value of type 'String' has no member\
    \ 'isParensGood'\n    if s.isParensGood() {\n       ~ ^~~~~~~~~~~~\n"
  stdout: ''
  timestamp: 1659979534
- exit_code: 1
  program: "\n/// You are given an array of two strings, both strings consist of open\n\
    /// parentheses '(' or close parentheses ')' only.\n/// Your job is to check if\
    \ it is possible to concatenate the two strings in\n/// some order, that the resulting\
    \ string will be good.\n/// A string S is considered to be good if and only if\
    \ all parentheses in S\n/// are balanced. For example: the string '(())()' is\
    \ good, while the string\n/// '())' is not.\n/// Return 'Yes' if there's a way\
    \ to make a good string, and return 'No' otherwise.\n/// Examples:\n/// >>> match_parens(lst:\
    \ [\"()(\", \")\"])\n/// \"Yes\"\n/// >>> match_parens(lst: [\")\", \")\"])\n\
    /// \"No\"\nfunc match_parens(lst: [String]) -> String {\n    let first: String\
    \ = lst[0]\n    let second: String = lst[1]\n    var count: Int = 0\n    var balanced:\
    \ Bool = true\n    for c in first.characters {\n        if c == \"(\" {\n    \
    \        count += 1\n        } else {\n            count -= 1\n        }\n   \
    \     if count < 0 {\n            balanced = false\n            break\n      \
    \  }\n    }\n    if balanced {\n        for c in second.characters {\n       \
    \     if c == \"(\" {\n                count += 1\n            } else {\n    \
    \            count -= 1\n            }\n            if count < 0 {\n         \
    \       balanced = false\n                break\n            }\n        }\n  \
    \  }\n    if balanced && count == 0 {\n        return \"Yes\"\n    } else {\n\
    \        return \"No\"\n    }\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int,\
    \ Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n\
    \    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n          \
    \  return false\n        }\n    }\n    return true\n}\n            \nassert(match_parens(lst:\
    \ [\"()(\", \")\"]) == \"Yes\")\nassert(match_parens(lst: [\")\", \")\"]) == \"\
    No\")\nassert(match_parens(lst: [\"(()(())\", \"())())\"]) == \"No\")\nassert(match_parens(lst:\
    \ [\")())\", \"(()()(\"]) == \"Yes\")\nassert(match_parens(lst: [\"(())))\", \"\
    (()())((\"]) == \"Yes\")\nassert(match_parens(lst: [\"()\", \"())\"]) == \"No\"\
    )\nassert(match_parens(lst: [\"(()(\", \"()))()\"]) == \"Yes\")\nassert(match_parens(lst:\
    \ [\"((((\", \"((())\"]) == \"No\")\nassert(match_parens(lst: [\")(()\", \"(()(\"\
    ]) == \"No\")\nassert(match_parens(lst: [\")(\", \")(\"]) == \"No\")\nassert(match_parens(lst:\
    \ [\"(\", \")\"]) == \"Yes\")\nassert(match_parens(lst: [\")\", \"(\"]) == \"\
    Yes\")"
  status: SyntaxError
  stderr: "/tmp/tmp5bw88tpc.swift:20:20: error: 'characters' is unavailable: Please\
    \ use String directly\n    for c in first.characters {\n                   ^~~~~~~~~~\n\
    Swift.String:5:16: note: 'characters' was obsoleted in Swift 5.0\n    public var\
    \ characters: String { get set }\n               ^\n/tmp/tmp5bw88tpc.swift:32:25:\
    \ error: 'characters' is unavailable: Please use String directly\n        for\
    \ c in second.characters {\n                        ^~~~~~~~~~\nSwift.String:5:16:\
    \ note: 'characters' was obsoleted in Swift 5.0\n    public var characters: String\
    \ { get set }\n               ^\n"
  stdout: ''
  timestamp: 1659979534
- exit_code: 1
  program: "\n/// You are given an array of two strings, both strings consist of open\n\
    /// parentheses '(' or close parentheses ')' only.\n/// Your job is to check if\
    \ it is possible to concatenate the two strings in\n/// some order, that the resulting\
    \ string will be good.\n/// A string S is considered to be good if and only if\
    \ all parentheses in S\n/// are balanced. For example: the string '(())()' is\
    \ good, while the string\n/// '())' is not.\n/// Return 'Yes' if there's a way\
    \ to make a good string, and return 'No' otherwise.\n/// Examples:\n/// >>> match_parens(lst:\
    \ [\"()(\", \")\"])\n/// \"Yes\"\n/// >>> match_parens(lst: [\")\", \")\"])\n\
    /// \"No\"\nfunc match_parens(lst: [String]) -> String {\n    let parity = [0,\
    \ 0]\n    for i in 0..<lst.count {\n        for j in 0..<lst[i].count {\n    \
    \        if lst[i][j] == \"(\" {\n                parity[i] += 1\n           \
    \ } else {\n                parity[i] -= 1\n            }\n            if parity[i]\
    \ < 0 {\n                return \"No\"\n            }\n        }\n    }\n    return\
    \ parity[0] == parity[1] ? \"Yes\" : \"No\"\n}\n\n\nfunc ==(left: [(Int, Int)],\
    \ right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n       \
    \ return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r\
    \ {\n            return false\n        }\n    }\n    return true\n}\n        \
    \    \nassert(match_parens(lst: [\"()(\", \")\"]) == \"Yes\")\nassert(match_parens(lst:\
    \ [\")\", \")\"]) == \"No\")\nassert(match_parens(lst: [\"(()(())\", \"())())\"\
    ]) == \"No\")\nassert(match_parens(lst: [\")())\", \"(()()(\"]) == \"Yes\")\n\
    assert(match_parens(lst: [\"(())))\", \"(()())((\"]) == \"Yes\")\nassert(match_parens(lst:\
    \ [\"()\", \"())\"]) == \"No\")\nassert(match_parens(lst: [\"(()(\", \"()))()\"\
    ]) == \"Yes\")\nassert(match_parens(lst: [\"((((\", \"((())\"]) == \"No\")\nassert(match_parens(lst:\
    \ [\")(()\", \"(()(\"]) == \"No\")\nassert(match_parens(lst: [\")(\", \")(\"])\
    \ == \"No\")\nassert(match_parens(lst: [\"(\", \")\"]) == \"Yes\")\nassert(match_parens(lst:\
    \ [\")\", \"(\"]) == \"Yes\")"
  status: SyntaxError
  stderr: "/tmp/tmpi_cyw6ft.swift:19:16: error: 'subscript(_:)' is unavailable: cannot\
    \ subscript String with an Int, use a String.Index instead.\n            if lst[i][j]\
    \ == \"(\" {\n               ^~~~~~~~~\nSwift.String:3:12: note: 'subscript(_:)'\
    \ has been explicitly marked unavailable here\n    public subscript(i: Int) ->\
    \ Character { get }\n           ^\n/tmp/tmpi_cyw6ft.swift:20:27: error: left side\
    \ of mutating operator isn't mutable: 'parity' is a 'let' constant\n         \
    \       parity[i] += 1\n                ~~~~~~    ^\n/tmp/tmpi_cyw6ft.swift:16:5:\
    \ note: change 'let' to 'var' to make it mutable\n    let parity = [0, 0]\n  \
    \  ^~~\n    var\n/tmp/tmpi_cyw6ft.swift:22:27: error: left side of mutating operator\
    \ isn't mutable: 'parity' is a 'let' constant\n                parity[i] -= 1\n\
    \                ~~~~~~    ^\n/tmp/tmpi_cyw6ft.swift:16:5: note: change 'let'\
    \ to 'var' to make it mutable\n    let parity = [0, 0]\n    ^~~\n    var\n"
  stdout: ''
  timestamp: 1659979534
- exit_code: -4
  program: "\n/// You are given an array of two strings, both strings consist of open\n\
    /// parentheses '(' or close parentheses ')' only.\n/// Your job is to check if\
    \ it is possible to concatenate the two strings in\n/// some order, that the resulting\
    \ string will be good.\n/// A string S is considered to be good if and only if\
    \ all parentheses in S\n/// are balanced. For example: the string '(())()' is\
    \ good, while the string\n/// '())' is not.\n/// Return 'Yes' if there's a way\
    \ to make a good string, and return 'No' otherwise.\n/// Examples:\n/// >>> match_parens(lst:\
    \ [\"()(\", \")\"])\n/// \"Yes\"\n/// >>> match_parens(lst: [\")\", \")\"])\n\
    /// \"No\"\nfunc match_parens(lst: [String]) -> String {\n    var arr = [Character]()\n\
    \    for i in 0..<lst.count {\n        for j in 0..<lst[i].count {\n         \
    \   arr.append(lst[i][lst[i].index(lst[i].startIndex, offsetBy: j)])\n       \
    \ }\n    }\n    var count = 0\n    for i in 0..<arr.count {\n        if arr[i]\
    \ == \"(\" {\n            count += 1\n        } else {\n            count -= 1\n\
    \        }\n        if count < 0 {\n            return \"No\"\n        }\n   \
    \ }\n    if count == 0 {\n        return \"Yes\"\n    } else {\n        return\
    \ \"No\"\n    }\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool\
    \ {\n    if left.count != right.count {\n        return false\n    }\n    for\
    \ (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(match_parens(lst:\
    \ [\"()(\", \")\"]) == \"Yes\")\nassert(match_parens(lst: [\")\", \")\"]) == \"\
    No\")\nassert(match_parens(lst: [\"(()(())\", \"())())\"]) == \"No\")\nassert(match_parens(lst:\
    \ [\")())\", \"(()()(\"]) == \"Yes\")\nassert(match_parens(lst: [\"(())))\", \"\
    (()())((\"]) == \"Yes\")\nassert(match_parens(lst: [\"()\", \"())\"]) == \"No\"\
    )\nassert(match_parens(lst: [\"(()(\", \"()))()\"]) == \"Yes\")\nassert(match_parens(lst:\
    \ [\"((((\", \"((())\"]) == \"No\")\nassert(match_parens(lst: [\")(()\", \"(()(\"\
    ]) == \"No\")\nassert(match_parens(lst: [\")(\", \")(\"]) == \"No\")\nassert(match_parens(lst:\
    \ [\"(\", \")\"]) == \"Yes\")\nassert(match_parens(lst: [\")\", \"(\"]) == \"\
    Yes\")"
  status: Exception
  stderr: 'tmpgu68su8i/tmpgu68su8i.swift:56: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b2e200a1c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b2e1fd98b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b2e1fd98988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b2e1fd977b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpgu68su8i                        0x000055d52b83cf06 <unavailable> + 7942

    5    libc.so.6                          0x00002b2e2028d460 __libc_start_main +
    245

    6    tmpgu68su8i                        0x000055d52b83c669 <unavailable> + 5737

    '
  stdout: ''
  timestamp: 1659979534
- exit_code: -4
  program: "\n/// You are given an array of two strings, both strings consist of open\n\
    /// parentheses '(' or close parentheses ')' only.\n/// Your job is to check if\
    \ it is possible to concatenate the two strings in\n/// some order, that the resulting\
    \ string will be good.\n/// A string S is considered to be good if and only if\
    \ all parentheses in S\n/// are balanced. For example: the string '(())()' is\
    \ good, while the string\n/// '())' is not.\n/// Return 'Yes' if there's a way\
    \ to make a good string, and return 'No' otherwise.\n/// Examples:\n/// >>> match_parens(lst:\
    \ [\"()(\", \")\"])\n/// \"Yes\"\n/// >>> match_parens(lst: [\")\", \")\"])\n\
    /// \"No\"\nfunc match_parens(lst: [String]) -> String {\n    let s = lst[0] +\
    \ lst[1]\n    var parens = 0\n    for c in s {\n        if c == \"(\" {\n    \
    \        parens += 1\n        } else {\n            parens -= 1\n        }\n \
    \       if parens < 0 {\n            return \"No\"\n        }\n    }\n    return\
    \ \"Yes\"\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n\
    \    if left.count != right.count {\n        return false\n    }\n    for (l,\
    \ r) in zip(left, right) {\n        if l != r {\n            return false\n  \
    \      }\n    }\n    return true\n}\n            \nassert(match_parens(lst: [\"\
    ()(\", \")\"]) == \"Yes\")\nassert(match_parens(lst: [\")\", \")\"]) == \"No\"\
    )\nassert(match_parens(lst: [\"(()(())\", \"())())\"]) == \"No\")\nassert(match_parens(lst:\
    \ [\")())\", \"(()()(\"]) == \"Yes\")\nassert(match_parens(lst: [\"(())))\", \"\
    (()())((\"]) == \"Yes\")\nassert(match_parens(lst: [\"()\", \"())\"]) == \"No\"\
    )\nassert(match_parens(lst: [\"(()(\", \"()))()\"]) == \"Yes\")\nassert(match_parens(lst:\
    \ [\"((((\", \"((())\"]) == \"No\")\nassert(match_parens(lst: [\")(()\", \"(()(\"\
    ]) == \"No\")\nassert(match_parens(lst: [\")(\", \")(\"]) == \"No\")\nassert(match_parens(lst:\
    \ [\"(\", \")\"]) == \"Yes\")\nassert(match_parens(lst: [\")\", \"(\"]) == \"\
    Yes\")"
  status: Exception
  stderr: 'tmp492u_0j2/tmp492u_0j2.swift:47: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b2542d01c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b25429f8b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b25429f8988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b25429f77b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmp492u_0j2                        0x0000564cc4a2eb76 <unavailable> + 7030

    5    libc.so.6                          0x00002b2542eed460 __libc_start_main +
    245

    6    tmp492u_0j2                        0x0000564cc4a2e2d9 <unavailable> + 4825

    '
  stdout: ''
  timestamp: 1659979534
- exit_code: 1
  program: "\n/// You are given an array of two strings, both strings consist of open\n\
    /// parentheses '(' or close parentheses ')' only.\n/// Your job is to check if\
    \ it is possible to concatenate the two strings in\n/// some order, that the resulting\
    \ string will be good.\n/// A string S is considered to be good if and only if\
    \ all parentheses in S\n/// are balanced. For example: the string '(())()' is\
    \ good, while the string\n/// '())' is not.\n/// Return 'Yes' if there's a way\
    \ to make a good string, and return 'No' otherwise.\n/// Examples:\n/// >>> match_parens(lst:\
    \ [\"()(\", \")\"])\n/// \"Yes\"\n/// >>> match_parens(lst: [\")\", \")\"])\n\
    /// \"No\"\nfunc match_parens(lst: [String]) -> String {\n    let lst = lst.map\
    \ { Array($0) }\n    for first in lst[0] {\n        for second in lst[1] {\n \
    \           if good_string([first, second]) {\n                return \"Yes\"\n\
    \            }\n        }\n    }\n    return \"No\"\n}\n\n\nfunc ==(left: [(Int,\
    \ Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n\
    \        return false\n    }\n    for (l, r) in zip(left, right) {\n        if\
    \ l != r {\n            return false\n        }\n    }\n    return true\n}\n \
    \           \nassert(match_parens(lst: [\"()(\", \")\"]) == \"Yes\")\nassert(match_parens(lst:\
    \ [\")\", \")\"]) == \"No\")\nassert(match_parens(lst: [\"(()(())\", \"())())\"\
    ]) == \"No\")\nassert(match_parens(lst: [\")())\", \"(()()(\"]) == \"Yes\")\n\
    assert(match_parens(lst: [\"(())))\", \"(()())((\"]) == \"Yes\")\nassert(match_parens(lst:\
    \ [\"()\", \"())\"]) == \"No\")\nassert(match_parens(lst: [\"(()(\", \"()))()\"\
    ]) == \"Yes\")\nassert(match_parens(lst: [\"((((\", \"((())\"]) == \"No\")\nassert(match_parens(lst:\
    \ [\")(()\", \"(()(\"]) == \"No\")\nassert(match_parens(lst: [\")(\", \")(\"])\
    \ == \"No\")\nassert(match_parens(lst: [\"(\", \")\"]) == \"Yes\")\nassert(match_parens(lst:\
    \ [\")\", \"(\"]) == \"Yes\")"
  status: SyntaxError
  stderr: "/tmp/tmp_rmfqbj3.swift:19:16: error: cannot find 'good_string' in scope\n\
    \            if good_string([first, second]) {\n               ^~~~~~~~~~~\n"
  stdout: ''
  timestamp: 1659979534
- exit_code: -4
  program: "\n/// You are given an array of two strings, both strings consist of open\n\
    /// parentheses '(' or close parentheses ')' only.\n/// Your job is to check if\
    \ it is possible to concatenate the two strings in\n/// some order, that the resulting\
    \ string will be good.\n/// A string S is considered to be good if and only if\
    \ all parentheses in S\n/// are balanced. For example: the string '(())()' is\
    \ good, while the string\n/// '())' is not.\n/// Return 'Yes' if there's a way\
    \ to make a good string, and return 'No' otherwise.\n/// Examples:\n/// >>> match_parens(lst:\
    \ [\"()(\", \")\"])\n/// \"Yes\"\n/// >>> match_parens(lst: [\")\", \")\"])\n\
    /// \"No\"\nfunc match_parens(lst: [String]) -> String {\n    var count = 0\n\
    \    for str in lst {\n        for c in str {\n            if c == \"(\" {\n \
    \               count += 1\n            } else {\n                count -= 1\n\
    \            }\n            if count < 0 {\n                return \"No\"\n  \
    \          }\n        }\n    }\n    return count == 0 ? \"Yes\" : \"No\"\n}\n\n\
    \nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(match_parens(lst: [\"()(\", \")\"]) == \"Yes\"\
    )\nassert(match_parens(lst: [\")\", \")\"]) == \"No\")\nassert(match_parens(lst:\
    \ [\"(()(())\", \"())())\"]) == \"No\")\nassert(match_parens(lst: [\")())\", \"\
    (()()(\"]) == \"Yes\")\nassert(match_parens(lst: [\"(())))\", \"(()())((\"]) ==\
    \ \"Yes\")\nassert(match_parens(lst: [\"()\", \"())\"]) == \"No\")\nassert(match_parens(lst:\
    \ [\"(()(\", \"()))()\"]) == \"Yes\")\nassert(match_parens(lst: [\"((((\", \"\
    ((())\"]) == \"No\")\nassert(match_parens(lst: [\")(()\", \"(()(\"]) == \"No\"\
    )\nassert(match_parens(lst: [\")(\", \")(\"]) == \"No\")\nassert(match_parens(lst:\
    \ [\"(\", \")\"]) == \"Yes\")\nassert(match_parens(lst: [\")\", \"(\"]) == \"\
    Yes\")"
  status: Exception
  stderr: 'tmpze_0zl2t/tmpze_0zl2t.swift:48: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002ba42106dc80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002ba420d64b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002ba420d64988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002ba420d637b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpze_0zl2t                        0x00005574a74c2c36 <unavailable> + 7222

    5    libc.so.6                          0x00002ba421259460 __libc_start_main +
    245

    6    tmpze_0zl2t                        0x00005574a74c2399 <unavailable> + 5017

    '
  stdout: ''
  timestamp: 1659979534
- exit_code: -4
  program: "\n/// You are given an array of two strings, both strings consist of open\n\
    /// parentheses '(' or close parentheses ')' only.\n/// Your job is to check if\
    \ it is possible to concatenate the two strings in\n/// some order, that the resulting\
    \ string will be good.\n/// A string S is considered to be good if and only if\
    \ all parentheses in S\n/// are balanced. For example: the string '(())()' is\
    \ good, while the string\n/// '())' is not.\n/// Return 'Yes' if there's a way\
    \ to make a good string, and return 'No' otherwise.\n/// Examples:\n/// >>> match_parens(lst:\
    \ [\"()(\", \")\"])\n/// \"Yes\"\n/// >>> match_parens(lst: [\")\", \")\"])\n\
    /// \"No\"\nfunc match_parens(lst: [String]) -> String {\n    var out: [String]\
    \ = []\n    var open: Int = 0\n    var close: Int = 0\n    for item in lst {\n\
    \        for char in item {\n            if char == \"(\" {\n                open\
    \ += 1\n            } else {\n                close += 1\n            }\n    \
    \    }\n        out.append(item)\n    }\n    if open == close {\n        return\
    \ \"Yes\"\n    } else {\n        return \"No\"\n    }\n}\n\n\nfunc ==(left: [(Int,\
    \ Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n\
    \        return false\n    }\n    for (l, r) in zip(left, right) {\n        if\
    \ l != r {\n            return false\n        }\n    }\n    return true\n}\n \
    \           \nassert(match_parens(lst: [\"()(\", \")\"]) == \"Yes\")\nassert(match_parens(lst:\
    \ [\")\", \")\"]) == \"No\")\nassert(match_parens(lst: [\"(()(())\", \"())())\"\
    ]) == \"No\")\nassert(match_parens(lst: [\")())\", \"(()()(\"]) == \"Yes\")\n\
    assert(match_parens(lst: [\"(())))\", \"(()())((\"]) == \"Yes\")\nassert(match_parens(lst:\
    \ [\"()\", \"())\"]) == \"No\")\nassert(match_parens(lst: [\"(()(\", \"()))()\"\
    ]) == \"Yes\")\nassert(match_parens(lst: [\"((((\", \"((())\"]) == \"No\")\nassert(match_parens(lst:\
    \ [\")(()\", \"(()(\"]) == \"No\")\nassert(match_parens(lst: [\")(\", \")(\"])\
    \ == \"No\")\nassert(match_parens(lst: [\"(\", \")\"]) == \"Yes\")\nassert(match_parens(lst:\
    \ [\")\", \"(\"]) == \"Yes\")"
  status: Exception
  stderr: 'tmpw8nllrga/tmpw8nllrga.swift:58: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002acd093dbc80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002acd090d2b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002acd090d2988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002acd090d17b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpw8nllrga                        0x000055f3977fa5d8 <unavailable> + 9688

    5    libc.so.6                          0x00002acd095c7460 __libc_start_main +
    245

    6    tmpw8nllrga                        0x000055f3977f93f9 <unavailable> + 5113

    '
  stdout: ''
  timestamp: 1659979534
- exit_code: -4
  program: "\n/// You are given an array of two strings, both strings consist of open\n\
    /// parentheses '(' or close parentheses ')' only.\n/// Your job is to check if\
    \ it is possible to concatenate the two strings in\n/// some order, that the resulting\
    \ string will be good.\n/// A string S is considered to be good if and only if\
    \ all parentheses in S\n/// are balanced. For example: the string '(())()' is\
    \ good, while the string\n/// '())' is not.\n/// Return 'Yes' if there's a way\
    \ to make a good string, and return 'No' otherwise.\n/// Examples:\n/// >>> match_parens(lst:\
    \ [\"()(\", \")\"])\n/// \"Yes\"\n/// >>> match_parens(lst: [\")\", \")\"])\n\
    /// \"No\"\nfunc match_parens(lst: [String]) -> String {\n    let arr = lst.map\
    \ { Array($0) }\n    let lhs = arr[0]\n    let rhs = arr[1]\n    let open_par\
    \ = lhs.filter { $0 == \"(\" }\n    let close_par = rhs.filter { $0 == \")\" }\n\
    \    return (open_par.count == close_par.count) ? \"Yes\" : \"No\"\n}\n\n\nfunc\
    \ ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count !=\
    \ right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(match_parens(lst: [\"()(\", \")\"]) == \"Yes\"\
    )\nassert(match_parens(lst: [\")\", \")\"]) == \"No\")\nassert(match_parens(lst:\
    \ [\"(()(())\", \"())())\"]) == \"No\")\nassert(match_parens(lst: [\")())\", \"\
    (()()(\"]) == \"Yes\")\nassert(match_parens(lst: [\"(())))\", \"(()())((\"]) ==\
    \ \"Yes\")\nassert(match_parens(lst: [\"()\", \"())\"]) == \"No\")\nassert(match_parens(lst:\
    \ [\"(()(\", \"()))()\"]) == \"Yes\")\nassert(match_parens(lst: [\"((((\", \"\
    ((())\"]) == \"No\")\nassert(match_parens(lst: [\")(()\", \"(()(\"]) == \"No\"\
    )\nassert(match_parens(lst: [\")(\", \")(\"]) == \"No\")\nassert(match_parens(lst:\
    \ [\"(\", \")\"]) == \"Yes\")\nassert(match_parens(lst: [\")\", \"(\"]) == \"\
    Yes\")"
  status: Exception
  stderr: 'tmpyyxasyhb/tmpyyxasyhb.swift:37: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002adbb3437c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002adbb312eb6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002adbb312e988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002adbb312d7b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpyyxasyhb                        0x000055a6f13a8886 <unavailable> + 6278

    5    libc.so.6                          0x00002adbb3623460 __libc_start_main +
    245

    6    tmpyyxasyhb                        0x000055a6f13a8469 <unavailable> + 5225

    '
  stdout: ''
  timestamp: 1659979534
- exit_code: -4
  program: "\n/// You are given an array of two strings, both strings consist of open\n\
    /// parentheses '(' or close parentheses ')' only.\n/// Your job is to check if\
    \ it is possible to concatenate the two strings in\n/// some order, that the resulting\
    \ string will be good.\n/// A string S is considered to be good if and only if\
    \ all parentheses in S\n/// are balanced. For example: the string '(())()' is\
    \ good, while the string\n/// '())' is not.\n/// Return 'Yes' if there's a way\
    \ to make a good string, and return 'No' otherwise.\n/// Examples:\n/// >>> match_parens(lst:\
    \ [\"()(\", \")\"])\n/// \"Yes\"\n/// >>> match_parens(lst: [\")\", \")\"])\n\
    /// \"No\"\nfunc match_parens(lst: [String]) -> String {\n  var revCnt = 0\n \
    \ var openCnt = 0\n  for s in lst {\n    for c in s {\n      if c == \"(\" {\n\
    \        openCnt += 1\n      } else {\n        revCnt += 1\n      }\n    }\n \
    \ }\n  return (revCnt + openCnt) % 2 == 0 ? \"Yes\" : \"No\"\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(match_parens(lst: [\"()(\", \")\"]) == \"Yes\")\nassert(match_parens(lst:\
    \ [\")\", \")\"]) == \"No\")\nassert(match_parens(lst: [\"(()(())\", \"())())\"\
    ]) == \"No\")\nassert(match_parens(lst: [\")())\", \"(()()(\"]) == \"Yes\")\n\
    assert(match_parens(lst: [\"(())))\", \"(()())((\"]) == \"Yes\")\nassert(match_parens(lst:\
    \ [\"()\", \"())\"]) == \"No\")\nassert(match_parens(lst: [\"(()(\", \"()))()\"\
    ]) == \"Yes\")\nassert(match_parens(lst: [\"((((\", \"((())\"]) == \"No\")\nassert(match_parens(lst:\
    \ [\")(()\", \"(()(\"]) == \"No\")\nassert(match_parens(lst: [\")(\", \")(\"])\
    \ == \"No\")\nassert(match_parens(lst: [\"(\", \")\"]) == \"Yes\")\nassert(match_parens(lst:\
    \ [\")\", \"(\"]) == \"Yes\")"
  status: Exception
  stderr: 'tmps1i3wa85/tmps1i3wa85.swift:44: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002ad342132c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002ad341e29b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002ad341e29988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002ad341e287b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmps1i3wa85                        0x0000563e85d769b0 <unavailable> + 6576

    5    libc.so.6                          0x00002ad34231e460 __libc_start_main +
    245

    6    tmps1i3wa85                        0x0000563e85d76429 <unavailable> + 5161

    '
  stdout: ''
  timestamp: 1659979534
- exit_code: 1
  program: "\n/// You are given an array of two strings, both strings consist of open\n\
    /// parentheses '(' or close parentheses ')' only.\n/// Your job is to check if\
    \ it is possible to concatenate the two strings in\n/// some order, that the resulting\
    \ string will be good.\n/// A string S is considered to be good if and only if\
    \ all parentheses in S\n/// are balanced. For example: the string '(())()' is\
    \ good, while the string\n/// '())' is not.\n/// Return 'Yes' if there's a way\
    \ to make a good string, and return 'No' otherwise.\n/// Examples:\n/// >>> match_parens(lst:\
    \ [\"()(\", \")\"])\n/// \"Yes\"\n/// >>> match_parens(lst: [\")\", \")\"])\n\
    /// \"No\"\nfunc match_parens(lst: [String]) -> String {\n    return lst.reduce(\"\
    \") {\n        if is_good_string($0 + $1) {\n            return \"Yes\"\n    \
    \    } else {\n            return \"No\"\n        }\n    }\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(match_parens(lst: [\"()(\", \")\"]) == \"Yes\")\nassert(match_parens(lst:\
    \ [\")\", \")\"]) == \"No\")\nassert(match_parens(lst: [\"(()(())\", \"())())\"\
    ]) == \"No\")\nassert(match_parens(lst: [\")())\", \"(()()(\"]) == \"Yes\")\n\
    assert(match_parens(lst: [\"(())))\", \"(()())((\"]) == \"Yes\")\nassert(match_parens(lst:\
    \ [\"()\", \"())\"]) == \"No\")\nassert(match_parens(lst: [\"(()(\", \"()))()\"\
    ]) == \"Yes\")\nassert(match_parens(lst: [\"((((\", \"((())\"]) == \"No\")\nassert(match_parens(lst:\
    \ [\")(()\", \"(()(\"]) == \"No\")\nassert(match_parens(lst: [\")(\", \")(\"])\
    \ == \"No\")\nassert(match_parens(lst: [\"(\", \")\"]) == \"Yes\")\nassert(match_parens(lst:\
    \ [\")\", \"(\"]) == \"Yes\")"
  status: SyntaxError
  stderr: "/tmp/tmpax2tk6cs.swift:17:12: error: cannot find 'is_good_string' in scope\n\
    \        if is_good_string($0 + $1) {\n           ^~~~~~~~~~~~~~\n"
  stdout: ''
  timestamp: 1659979534
- exit_code: -4
  program: "\n/// You are given an array of two strings, both strings consist of open\n\
    /// parentheses '(' or close parentheses ')' only.\n/// Your job is to check if\
    \ it is possible to concatenate the two strings in\n/// some order, that the resulting\
    \ string will be good.\n/// A string S is considered to be good if and only if\
    \ all parentheses in S\n/// are balanced. For example: the string '(())()' is\
    \ good, while the string\n/// '())' is not.\n/// Return 'Yes' if there's a way\
    \ to make a good string, and return 'No' otherwise.\n/// Examples:\n/// >>> match_parens(lst:\
    \ [\"()(\", \")\"])\n/// \"Yes\"\n/// >>> match_parens(lst: [\")\", \")\"])\n\
    /// \"No\"\nfunc match_parens(lst: [String]) -> String {\n    let left = lst[0]\n\
    \    let right = lst[1]\n    var leftStack = [Character]()\n    for c in left\
    \ {\n        if c == \"(\" {\n            leftStack.append(c)\n        } else\
    \ {\n            leftStack.popLast()\n        }\n    }\n    var rightStack = [Character]()\n\
    \    for c in right {\n        if c == \")\" {\n            rightStack.append(c)\n\
    \        } else {\n            rightStack.popLast()\n        }\n    }\n    while\
    \ leftStack.isEmpty == false && rightStack.isEmpty == false {\n        leftStack.popLast()\n\
    \        rightStack.popLast()\n    }\n    if leftStack.isEmpty && rightStack.isEmpty\
    \ {\n        return \"Yes\"\n    }\n    return \"No\"\n}\n\n\nfunc ==(left: [(Int,\
    \ Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n\
    \        return false\n    }\n    for (l, r) in zip(left, right) {\n        if\
    \ l != r {\n            return false\n        }\n    }\n    return true\n}\n \
    \           \nassert(match_parens(lst: [\"()(\", \")\"]) == \"Yes\")\nassert(match_parens(lst:\
    \ [\")\", \")\"]) == \"No\")\nassert(match_parens(lst: [\"(()(())\", \"())())\"\
    ]) == \"No\")\nassert(match_parens(lst: [\")())\", \"(()()(\"]) == \"Yes\")\n\
    assert(match_parens(lst: [\"(())))\", \"(()())((\"]) == \"Yes\")\nassert(match_parens(lst:\
    \ [\"()\", \"())\"]) == \"No\")\nassert(match_parens(lst: [\"(()(\", \"()))()\"\
    ]) == \"Yes\")\nassert(match_parens(lst: [\"((((\", \"((())\"]) == \"No\")\nassert(match_parens(lst:\
    \ [\")(()\", \"(()(\"]) == \"No\")\nassert(match_parens(lst: [\")(\", \")(\"])\
    \ == \"No\")\nassert(match_parens(lst: [\"(\", \")\"]) == \"Yes\")\nassert(match_parens(lst:\
    \ [\")\", \"(\"]) == \"Yes\")"
  status: Exception
  stderr: 'tmpznnjgi6r/tmpznnjgi6r.swift:63: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002aad4b71fc80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002aad4b416b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002aad4b416988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002aad4b4157b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpznnjgi6r                        0x000056067ce911e7 <unavailable> + 8679

    5    libc.so.6                          0x00002aad4b90b460 __libc_start_main +
    245

    6    tmpznnjgi6r                        0x000056067ce904a9 <unavailable> + 5289

    '
  stdout: ''
  timestamp: 1659979534
- exit_code: 1
  program: "\n/// You are given an array of two strings, both strings consist of open\n\
    /// parentheses '(' or close parentheses ')' only.\n/// Your job is to check if\
    \ it is possible to concatenate the two strings in\n/// some order, that the resulting\
    \ string will be good.\n/// A string S is considered to be good if and only if\
    \ all parentheses in S\n/// are balanced. For example: the string '(())()' is\
    \ good, while the string\n/// '())' is not.\n/// Return 'Yes' if there's a way\
    \ to make a good string, and return 'No' otherwise.\n/// Examples:\n/// >>> match_parens(lst:\
    \ [\"()(\", \")\"])\n/// \"Yes\"\n/// >>> match_parens(lst: [\")\", \")\"])\n\
    /// \"No\"\nfunc match_parens(lst: [String]) -> String {\n    let first: String\
    \ = lst[0]\n    let second: String = lst[1]\n    var all_pairs: [String] = [\"\
    ()\"]\n    var i: Int = 0\n    while i < all_pairs.count {\n        let first_char:\
    \ Character = all_pairs[i][all_pairs[i].startIndex]\n        let second_char:\
    \ Character = all_pairs[i][all_pairs[i].index(after: all_pairs[i].startIndex)]\n\
    \        if first_char == \"(\" && second_char == \")\" {\n            let pair_1:\
    \ String = \"(\\(all_pairs[i]))\"\n            let pair_2: String = \"\\(all_pairs[i])()\"\
    \n            if !all_pairs.contains(pair_1) {\n                all_pairs.append(pair_1)\n\
    \            }\n            if !all_pairs.contains(pair_2) {\n               \
    \ all_pairs.append(pair_2)\n            }\n        }\n        i += 1\n    }\n\
    \    var j: Int = 0\n    while j < all_pairs.count {\n        let first_pair:\
    \ String = all_pairs[j]\n        var k: Int = 0\n        while k < all_pairs.count\
    \ {\n            let second_pair: String = all_pairs[k]\n            let final_string:\
    \ String = \"\\(first_pair)\\(second_pair)\"\n            if balanced_parens(input:\
    \ final_string) {\n                if first == first_pair && second == second_pair\
    \ {\n                    return \"Yes\"\n                }\n                if\
    \ first == second_pair && second == first_pair {\n                    return \"\
    Yes\"\n                }\n            }\n            k += 1\n        }\n     \
    \   j += 1\n    }\n    return \"No\"\n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(match_parens(lst: [\"()(\", \")\"]) == \"Yes\")\nassert(match_parens(lst:\
    \ [\")\", \")\"]) == \"No\")\nassert(match_parens(lst: [\"(()(())\", \"())())\"\
    ]) == \"No\")\nassert(match_parens(lst: [\")())\", \"(()()(\"]) == \"Yes\")\n\
    assert(match_parens(lst: [\"(())))\", \"(()())((\"]) == \"Yes\")\nassert(match_parens(lst:\
    \ [\"()\", \"())\"]) == \"No\")\nassert(match_parens(lst: [\"(()(\", \"()))()\"\
    ]) == \"Yes\")\nassert(match_parens(lst: [\"((((\", \"((())\"]) == \"No\")\nassert(match_parens(lst:\
    \ [\")(()\", \"(()(\"]) == \"No\")\nassert(match_parens(lst: [\")(\", \")(\"])\
    \ == \"No\")\nassert(match_parens(lst: [\"(\", \")\"]) == \"Yes\")\nassert(match_parens(lst:\
    \ [\")\", \"(\"]) == \"Yes\")"
  status: SyntaxError
  stderr: "/tmp/tmpnh9arc57.swift:42:16: error: cannot find 'balanced_parens' in scope\n\
    \            if balanced_parens(input: final_string) {\n               ^~~~~~~~~~~~~~~\n"
  stdout: ''
  timestamp: 1659979534
- exit_code: -4
  program: "\n/// You are given an array of two strings, both strings consist of open\n\
    /// parentheses '(' or close parentheses ')' only.\n/// Your job is to check if\
    \ it is possible to concatenate the two strings in\n/// some order, that the resulting\
    \ string will be good.\n/// A string S is considered to be good if and only if\
    \ all parentheses in S\n/// are balanced. For example: the string '(())()' is\
    \ good, while the string\n/// '())' is not.\n/// Return 'Yes' if there's a way\
    \ to make a good string, and return 'No' otherwise.\n/// Examples:\n/// >>> match_parens(lst:\
    \ [\"()(\", \")\"])\n/// \"Yes\"\n/// >>> match_parens(lst: [\")\", \")\"])\n\
    /// \"No\"\nfunc match_parens(lst: [String]) -> String {\n    // your code here\n\
    \    var count = 0\n    var ans = \"\"\n    if lst[0].first == \")\" && lst[1].first\
    \ == \")\" {\n        return \"No\"\n    }\n    for i in lst[0] {\n        if\
    \ i == \"(\" {\n            count += 1\n        } else {\n            count -=\
    \ 1\n        }\n        if count < 0 {\n            return \"No\"\n        }\n\
    \    }\n    for i in lst[1] {\n        if i == \"(\" {\n            count += 1\n\
    \        } else {\n            count -= 1\n        }\n        if count < 0 {\n\
    \            return \"No\"\n        }\n    }\n    if count == 0 {\n        ans\
    \ = \"Yes\"\n    } else {\n        ans = \"No\"\n    }\n    return ans\n}\n\n\n\
    func ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(match_parens(lst: [\"()(\", \")\"]) == \"Yes\"\
    )\nassert(match_parens(lst: [\")\", \")\"]) == \"No\")\nassert(match_parens(lst:\
    \ [\"(()(())\", \"())())\"]) == \"No\")\nassert(match_parens(lst: [\")())\", \"\
    (()()(\"]) == \"Yes\")\nassert(match_parens(lst: [\"(())))\", \"(()())((\"]) ==\
    \ \"Yes\")\nassert(match_parens(lst: [\"()\", \"())\"]) == \"No\")\nassert(match_parens(lst:\
    \ [\"(()(\", \"()))()\"]) == \"Yes\")\nassert(match_parens(lst: [\"((((\", \"\
    ((())\"]) == \"No\")\nassert(match_parens(lst: [\")(()\", \"(()(\"]) == \"No\"\
    )\nassert(match_parens(lst: [\")(\", \")(\"]) == \"No\")\nassert(match_parens(lst:\
    \ [\"(\", \")\"]) == \"Yes\")\nassert(match_parens(lst: [\")\", \"(\"]) == \"\
    Yes\")"
  status: Exception
  stderr: 'tmpkis2qelb/tmpkis2qelb.swift:66: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002acb653b2c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002acb650a9b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002acb650a9988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002acb650a87b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpkis2qelb                        0x0000560c6b1bebb6 <unavailable> + 7094

    5    libc.so.6                          0x00002acb6559e460 __libc_start_main +
    245

    6    tmpkis2qelb                        0x0000560c6b1be319 <unavailable> + 4889

    '
  stdout: ''
  timestamp: 1659979534
- exit_code: 1
  program: "\n/// You are given an array of two strings, both strings consist of open\n\
    /// parentheses '(' or close parentheses ')' only.\n/// Your job is to check if\
    \ it is possible to concatenate the two strings in\n/// some order, that the resulting\
    \ string will be good.\n/// A string S is considered to be good if and only if\
    \ all parentheses in S\n/// are balanced. For example: the string '(())()' is\
    \ good, while the string\n/// '())' is not.\n/// Return 'Yes' if there's a way\
    \ to make a good string, and return 'No' otherwise.\n/// Examples:\n/// >>> match_parens(lst:\
    \ [\"()(\", \")\"])\n/// \"Yes\"\n/// >>> match_parens(lst: [\")\", \")\"])\n\
    /// \"No\"\nfunc match_parens(lst: [String]) -> String {\n    if lst.count !=\
    \ 2 {\n        return \"No\"\n    }\n    let s1 = lst[0]\n    let s2 = lst[1]\n\
    \    return isGood(s1 + s2) ? \"Yes\" : \"No\"\n}\n\n\nfunc ==(left: [(Int, Int)],\
    \ right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n       \
    \ return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r\
    \ {\n            return false\n        }\n    }\n    return true\n}\n        \
    \    \nassert(match_parens(lst: [\"()(\", \")\"]) == \"Yes\")\nassert(match_parens(lst:\
    \ [\")\", \")\"]) == \"No\")\nassert(match_parens(lst: [\"(()(())\", \"())())\"\
    ]) == \"No\")\nassert(match_parens(lst: [\")())\", \"(()()(\"]) == \"Yes\")\n\
    assert(match_parens(lst: [\"(())))\", \"(()())((\"]) == \"Yes\")\nassert(match_parens(lst:\
    \ [\"()\", \"())\"]) == \"No\")\nassert(match_parens(lst: [\"(()(\", \"()))()\"\
    ]) == \"Yes\")\nassert(match_parens(lst: [\"((((\", \"((())\"]) == \"No\")\nassert(match_parens(lst:\
    \ [\")(()\", \"(()(\"]) == \"No\")\nassert(match_parens(lst: [\")(\", \")(\"])\
    \ == \"No\")\nassert(match_parens(lst: [\"(\", \")\"]) == \"Yes\")\nassert(match_parens(lst:\
    \ [\")\", \"(\"]) == \"Yes\")"
  status: SyntaxError
  stderr: "/tmp/tmph66dny2w.swift:21:12: error: cannot find 'isGood' in scope\n  \
    \  return isGood(s1 + s2) ? \"Yes\" : \"No\"\n           ^~~~~~\n"
  stdout: ''
  timestamp: 1659979534
- exit_code: 1
  program: "\n/// You are given an array of two strings, both strings consist of open\n\
    /// parentheses '(' or close parentheses ')' only.\n/// Your job is to check if\
    \ it is possible to concatenate the two strings in\n/// some order, that the resulting\
    \ string will be good.\n/// A string S is considered to be good if and only if\
    \ all parentheses in S\n/// are balanced. For example: the string '(())()' is\
    \ good, while the string\n/// '())' is not.\n/// Return 'Yes' if there's a way\
    \ to make a good string, and return 'No' otherwise.\n/// Examples:\n/// >>> match_parens(lst:\
    \ [\"()(\", \")\"])\n/// \"Yes\"\n/// >>> match_parens(lst: [\")\", \")\"])\n\
    /// \"No\"\nfunc match_parens(lst: [String]) -> String {\n    var l1 = lst[0].to_chars()\n\
    \    var l2 = lst[1].to_chars()\n    if l1.count == 0 && l2.count == 0 {\n   \
    \     return \"Yes\"\n    }\n    if l1.count == 0 && l2.count > 0 {\n        for\
    \ c in l2 {\n            if c == \")\" {\n                return \"No\"\n    \
    \        }\n        }\n        return \"Yes\"\n    }\n    if l1.count > 0 && l2.count\
    \ == 0 {\n        for c in l1 {\n            if c == \"(\" {\n               \
    \ return \"No\"\n            }\n        }\n        return \"Yes\"\n    }\n   \
    \ var i1 = 0\n    var i2 = 0\n    for c in l1 {\n        if c == \"(\" {\n   \
    \         i1 += 1\n        } else {\n            i1 -= 1\n        }\n    }\n \
    \   for c in l2 {\n        if c == \"(\" {\n            i2 += 1\n        } else\
    \ {\n            i2 -= 1\n        }\n    }\n    if i1 == 0 && i2 == 0 {\n    \
    \    return \"Yes\"\n    }\n    if i1 != 0 && i2 != 0 {\n        return \"No\"\
    \n    }\n    if i1 > 0 {\n        for i in 0..<i1 {\n            l2.insert(\"\
    (\", at: 0)\n        }\n    } else {\n        for i in 0..<i2 {\n            l1.insert(\"\
    )\", at: 0)\n        }\n    }\n    var l = l1 + l2\n    var s = 0\n    for c in\
    \ l {\n        if c == \"(\" {\n            s += 1\n        } else {\n       \
    \     s -= 1\n        }\n        if s < 0 {\n            return \"No\"\n     \
    \   }\n    }\n    return \"Yes\"\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int,\
    \ Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n\
    \    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n          \
    \  return false\n        }\n    }\n    return true\n}\n            \nassert(match_parens(lst:\
    \ [\"()(\", \")\"]) == \"Yes\")\nassert(match_parens(lst: [\")\", \")\"]) == \"\
    No\")\nassert(match_parens(lst: [\"(()(())\", \"())())\"]) == \"No\")\nassert(match_parens(lst:\
    \ [\")())\", \"(()()(\"]) == \"Yes\")\nassert(match_parens(lst: [\"(())))\", \"\
    (()())((\"]) == \"Yes\")\nassert(match_parens(lst: [\"()\", \"())\"]) == \"No\"\
    )\nassert(match_parens(lst: [\"(()(\", \"()))()\"]) == \"Yes\")\nassert(match_parens(lst:\
    \ [\"((((\", \"((())\"]) == \"No\")\nassert(match_parens(lst: [\")(()\", \"(()(\"\
    ]) == \"No\")\nassert(match_parens(lst: [\")(\", \")(\"]) == \"No\")\nassert(match_parens(lst:\
    \ [\"(\", \")\"]) == \"Yes\")\nassert(match_parens(lst: [\")\", \"(\"]) == \"\
    Yes\")"
  status: SyntaxError
  stderr: "/tmp/tmp82envzxx.swift:16:21: error: value of type 'String' has no member\
    \ 'to_chars'\n    var l1 = lst[0].to_chars()\n             ~~~~~~ ^~~~~~~~\n/tmp/tmp82envzxx.swift:17:21:\
    \ error: value of type 'String' has no member 'to_chars'\n    var l2 = lst[1].to_chars()\n\
    \             ~~~~~~ ^~~~~~~~\n"
  stdout: ''
  timestamp: 1659979534
