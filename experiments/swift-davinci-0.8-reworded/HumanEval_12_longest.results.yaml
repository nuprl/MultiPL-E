language: swift
name: HumanEval_12_longest
results:
- exit_code: -4
  program: "\n/// Out of array of strings, return the longest one. Return the first\
    \ one in case of multiple\n/// strings of the same length. Return nil in case\
    \ the input array is empty.\n/// >>> longest(strings: [] as [String])\n/// nil\n\
    /// >>> longest(strings: [\"a\", \"b\", \"c\"])\n/// \"a\"\n/// >>> longest(strings:\
    \ [\"a\", \"bb\", \"ccc\"])\n/// \"ccc\"\nfunc longest(strings: [String]) -> String?\
    \ {\n    return strings.max()\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int,\
    \ Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n\
    \    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n          \
    \  return false\n        }\n    }\n    return true\n}\n            \nassert(longest(strings:\
    \ [] as [String]) == nil)\nassert(longest(strings: [\"x\", \"y\", \"z\"]) == \"\
    x\")\nassert(longest(strings: [\"x\", \"yyy\", \"zzzz\", \"www\", \"kkkk\", \"\
    abc\"]) == \"zzzz\")"
  status: Exception
  stderr: 'tmp71jrbmvf/tmp71jrbmvf.swift:28: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002ad69d142c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002ad69ce39b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002ad69ce39988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002ad69ce387b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmp71jrbmvf                        0x00005616aa89f83a <unavailable> + 6202

    5    libc.so.6                          0x00002ad69d32e460 __libc_start_main +
    245

    6    tmp71jrbmvf                        0x00005616aa89f129 <unavailable> + 4393

    '
  stdout: ''
  timestamp: 1660013860
- exit_code: 0
  program: "\n/// Out of array of strings, return the longest one. Return the first\
    \ one in case of multiple\n/// strings of the same length. Return nil in case\
    \ the input array is empty.\n/// >>> longest(strings: [] as [String])\n/// nil\n\
    /// >>> longest(strings: [\"a\", \"b\", \"c\"])\n/// \"a\"\n/// >>> longest(strings:\
    \ [\"a\", \"bb\", \"ccc\"])\n/// \"ccc\"\nfunc longest(strings: [String]) -> String?\
    \ {\n    if strings.isEmpty {\n        return nil\n    }\n    var long: String\
    \ = strings[0]\n    for i in 1..<strings.count {\n        if strings[i].count\
    \ > long.count {\n            long = strings[i]\n        }\n    }\n    return\
    \ long\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n  \
    \  if left.count != right.count {\n        return false\n    }\n    for (l, r)\
    \ in zip(left, right) {\n        if l != r {\n            return false\n     \
    \   }\n    }\n    return true\n}\n            \nassert(longest(strings: [] as\
    \ [String]) == nil)\nassert(longest(strings: [\"x\", \"y\", \"z\"]) == \"x\")\n\
    assert(longest(strings: [\"x\", \"yyy\", \"zzzz\", \"www\", \"kkkk\", \"abc\"\
    ]) == \"zzzz\")"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660013860
- exit_code: -4
  program: "\n/// Out of array of strings, return the longest one. Return the first\
    \ one in case of multiple\n/// strings of the same length. Return nil in case\
    \ the input array is empty.\n/// >>> longest(strings: [] as [String])\n/// nil\n\
    /// >>> longest(strings: [\"a\", \"b\", \"c\"])\n/// \"a\"\n/// >>> longest(strings:\
    \ [\"a\", \"bb\", \"ccc\"])\n/// \"ccc\"\nfunc longest(strings: [String]) -> String?\
    \ {\n    // TODO: Write some code to get the expected output!\n    return nil\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(longest(strings: [] as [String]) == nil)\nassert(longest(strings:\
    \ [\"x\", \"y\", \"z\"]) == \"x\")\nassert(longest(strings: [\"x\", \"yyy\", \"\
    zzzz\", \"www\", \"kkkk\", \"abc\"]) == \"zzzz\")"
  status: Exception
  stderr: 'tmpbhs8cbim/tmpbhs8cbim.swift:29: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002afd59724c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002afd5941bb6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002afd5941b988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002afd5941a7b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpbhs8cbim                        0x000056282aae879a <unavailable> + 6042

    5    libc.so.6                          0x00002afd59910460 __libc_start_main +
    245

    6    tmpbhs8cbim                        0x000056282aae8089 <unavailable> + 4233

    '
  stdout: ''
  timestamp: 1660013860
- exit_code: 0
  program: "\n/// Out of array of strings, return the longest one. Return the first\
    \ one in case of multiple\n/// strings of the same length. Return nil in case\
    \ the input array is empty.\n/// >>> longest(strings: [] as [String])\n/// nil\n\
    /// >>> longest(strings: [\"a\", \"b\", \"c\"])\n/// \"a\"\n/// >>> longest(strings:\
    \ [\"a\", \"bb\", \"ccc\"])\n/// \"ccc\"\nfunc longest(strings: [String]) -> String?\
    \ {\n  // TODO: Write the body of the function here\n  var longestString: String?\
    \ = nil\n  for string in strings {\n    if let currentLongestString = longestString\
    \ {\n      if string.count > currentLongestString.count {\n        longestString\
    \ = string\n      }\n    } else {\n      longestString = string\n    }\n  }\n\
    \  return longestString\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(longest(strings:\
    \ [] as [String]) == nil)\nassert(longest(strings: [\"x\", \"y\", \"z\"]) == \"\
    x\")\nassert(longest(strings: [\"x\", \"yyy\", \"zzzz\", \"www\", \"kkkk\", \"\
    abc\"]) == \"zzzz\")"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660013860
- exit_code: 0
  program: "\n/// Out of array of strings, return the longest one. Return the first\
    \ one in case of multiple\n/// strings of the same length. Return nil in case\
    \ the input array is empty.\n/// >>> longest(strings: [] as [String])\n/// nil\n\
    /// >>> longest(strings: [\"a\", \"b\", \"c\"])\n/// \"a\"\n/// >>> longest(strings:\
    \ [\"a\", \"bb\", \"ccc\"])\n/// \"ccc\"\nfunc longest(strings: [String]) -> String?\
    \ {\n    guard strings.count > 0 else {\n        return nil\n    }\n    return\
    \ strings.sorted(by: { $0.count > $1.count }).first\n}\n\n\nfunc ==(left: [(Int,\
    \ Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n\
    \        return false\n    }\n    for (l, r) in zip(left, right) {\n        if\
    \ l != r {\n            return false\n        }\n    }\n    return true\n}\n \
    \           \nassert(longest(strings: [] as [String]) == nil)\nassert(longest(strings:\
    \ [\"x\", \"y\", \"z\"]) == \"x\")\nassert(longest(strings: [\"x\", \"yyy\", \"\
    zzzz\", \"www\", \"kkkk\", \"abc\"]) == \"zzzz\")"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660013860
- exit_code: 0
  program: "\n/// Out of array of strings, return the longest one. Return the first\
    \ one in case of multiple\n/// strings of the same length. Return nil in case\
    \ the input array is empty.\n/// >>> longest(strings: [] as [String])\n/// nil\n\
    /// >>> longest(strings: [\"a\", \"b\", \"c\"])\n/// \"a\"\n/// >>> longest(strings:\
    \ [\"a\", \"bb\", \"ccc\"])\n/// \"ccc\"\nfunc longest(strings: [String]) -> String?\
    \ {\n    var result: String? = nil\n    var longest = 0\n    for string in strings\
    \ {\n        if string.count > longest {\n            result = string\n      \
    \      longest = string.count\n        }\n    }\n    return result\n}\n\n\nfunc\
    \ ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count !=\
    \ right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(longest(strings: [] as [String]) == nil)\nassert(longest(strings:\
    \ [\"x\", \"y\", \"z\"]) == \"x\")\nassert(longest(strings: [\"x\", \"yyy\", \"\
    zzzz\", \"www\", \"kkkk\", \"abc\"]) == \"zzzz\")"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660013860
- exit_code: -4
  program: "\n/// Out of array of strings, return the longest one. Return the first\
    \ one in case of multiple\n/// strings of the same length. Return nil in case\
    \ the input array is empty.\n/// >>> longest(strings: [] as [String])\n/// nil\n\
    /// >>> longest(strings: [\"a\", \"b\", \"c\"])\n/// \"a\"\n/// >>> longest(strings:\
    \ [\"a\", \"bb\", \"ccc\"])\n/// \"ccc\"\nfunc longest(strings: [String]) -> String?\
    \ {\n    return strings.reduce(nil) {\n        if let result = $0 {\n        \
    \    return result.count > $1.count ? result : $1\n        } else {\n        \
    \    return $1\n        }\n    }\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int,\
    \ Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n\
    \    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n          \
    \  return false\n        }\n    }\n    return true\n}\n            \nassert(longest(strings:\
    \ [] as [String]) == nil)\nassert(longest(strings: [\"x\", \"y\", \"z\"]) == \"\
    x\")\nassert(longest(strings: [\"x\", \"yyy\", \"zzzz\", \"www\", \"kkkk\", \"\
    abc\"]) == \"zzzz\")"
  status: Exception
  stderr: 'tmp7adsezpi/tmp7adsezpi.swift:34: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b516b6a7c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b516b39eb6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b516b39e988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b516b39d7b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmp7adsezpi                        0x0000564856ba985a <unavailable> + 6234

    5    libc.so.6                          0x00002b516b893460 __libc_start_main +
    245

    6    tmp7adsezpi                        0x0000564856ba9149 <unavailable> + 4425

    '
  stdout: ''
  timestamp: 1660013860
- exit_code: 0
  program: "\n/// Out of array of strings, return the longest one. Return the first\
    \ one in case of multiple\n/// strings of the same length. Return nil in case\
    \ the input array is empty.\n/// >>> longest(strings: [] as [String])\n/// nil\n\
    /// >>> longest(strings: [\"a\", \"b\", \"c\"])\n/// \"a\"\n/// >>> longest(strings:\
    \ [\"a\", \"bb\", \"ccc\"])\n/// \"ccc\"\nfunc longest(strings: [String]) -> String?\
    \ {\n    // FIXME\n    var longestWord = \"\"\n    for word in strings {\n   \
    \     if word.count > longestWord.count {\n            longestWord = word\n  \
    \      }\n    }\n    return longestWord.isEmpty ? nil : longestWord\n}\n\n\nfunc\
    \ ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count !=\
    \ right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(longest(strings: [] as [String]) == nil)\nassert(longest(strings:\
    \ [\"x\", \"y\", \"z\"]) == \"x\")\nassert(longest(strings: [\"x\", \"yyy\", \"\
    zzzz\", \"www\", \"kkkk\", \"abc\"]) == \"zzzz\")"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660013860
- exit_code: 0
  program: "\n/// Out of array of strings, return the longest one. Return the first\
    \ one in case of multiple\n/// strings of the same length. Return nil in case\
    \ the input array is empty.\n/// >>> longest(strings: [] as [String])\n/// nil\n\
    /// >>> longest(strings: [\"a\", \"b\", \"c\"])\n/// \"a\"\n/// >>> longest(strings:\
    \ [\"a\", \"bb\", \"ccc\"])\n/// \"ccc\"\nfunc longest(strings: [String]) -> String?\
    \ {\n    if strings.isEmpty {\n        return nil\n    }\n    let stringsSortedByLength\
    \ = strings.sorted { (str1, str2) -> Bool in\n        return str1.count > str2.count\n\
    \    }\n    return stringsSortedByLength.first\n}\n\n\nfunc ==(left: [(Int, Int)],\
    \ right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n       \
    \ return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r\
    \ {\n            return false\n        }\n    }\n    return true\n}\n        \
    \    \nassert(longest(strings: [] as [String]) == nil)\nassert(longest(strings:\
    \ [\"x\", \"y\", \"z\"]) == \"x\")\nassert(longest(strings: [\"x\", \"yyy\", \"\
    zzzz\", \"www\", \"kkkk\", \"abc\"]) == \"zzzz\")"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660013860
- exit_code: 0
  program: "\n/// Out of array of strings, return the longest one. Return the first\
    \ one in case of multiple\n/// strings of the same length. Return nil in case\
    \ the input array is empty.\n/// >>> longest(strings: [] as [String])\n/// nil\n\
    /// >>> longest(strings: [\"a\", \"b\", \"c\"])\n/// \"a\"\n/// >>> longest(strings:\
    \ [\"a\", \"bb\", \"ccc\"])\n/// \"ccc\"\nfunc longest(strings: [String]) -> String?\
    \ {\n    if strings.isEmpty {\n        return nil\n    }\n    var maxLen: Int\
    \ = 0\n    var maxString: String = \"\"\n    for string in strings {\n       \
    \ if string.count > maxLen {\n            maxLen = string.count\n            maxString\
    \ = string\n        }\n    }\n    return maxString\n}\n\n\nfunc ==(left: [(Int,\
    \ Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n\
    \        return false\n    }\n    for (l, r) in zip(left, right) {\n        if\
    \ l != r {\n            return false\n        }\n    }\n    return true\n}\n \
    \           \nassert(longest(strings: [] as [String]) == nil)\nassert(longest(strings:\
    \ [\"x\", \"y\", \"z\"]) == \"x\")\nassert(longest(strings: [\"x\", \"yyy\", \"\
    zzzz\", \"www\", \"kkkk\", \"abc\"]) == \"zzzz\")"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660013860
- exit_code: 0
  program: "\n/// Out of array of strings, return the longest one. Return the first\
    \ one in case of multiple\n/// strings of the same length. Return nil in case\
    \ the input array is empty.\n/// >>> longest(strings: [] as [String])\n/// nil\n\
    /// >>> longest(strings: [\"a\", \"b\", \"c\"])\n/// \"a\"\n/// >>> longest(strings:\
    \ [\"a\", \"bb\", \"ccc\"])\n/// \"ccc\"\nfunc longest(strings: [String]) -> String?\
    \ {\n    guard !strings.isEmpty else { return nil }\n    return strings.max(by:\
    \ { $0.count < $1.count })!\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int,\
    \ Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n\
    \    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n          \
    \  return false\n        }\n    }\n    return true\n}\n            \nassert(longest(strings:\
    \ [] as [String]) == nil)\nassert(longest(strings: [\"x\", \"y\", \"z\"]) == \"\
    x\")\nassert(longest(strings: [\"x\", \"yyy\", \"zzzz\", \"www\", \"kkkk\", \"\
    abc\"]) == \"zzzz\")"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660013860
- exit_code: 0
  program: "\n/// Out of array of strings, return the longest one. Return the first\
    \ one in case of multiple\n/// strings of the same length. Return nil in case\
    \ the input array is empty.\n/// >>> longest(strings: [] as [String])\n/// nil\n\
    /// >>> longest(strings: [\"a\", \"b\", \"c\"])\n/// \"a\"\n/// >>> longest(strings:\
    \ [\"a\", \"bb\", \"ccc\"])\n/// \"ccc\"\nfunc longest(strings: [String]) -> String?\
    \ {\n    var longestString: String?\n    for s in strings {\n        if longestString\
    \ == nil || s.count > longestString!.count {\n            longestString = s\n\
    \        }\n    }\n    return longestString\n}\n\n\nfunc ==(left: [(Int, Int)],\
    \ right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n       \
    \ return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r\
    \ {\n            return false\n        }\n    }\n    return true\n}\n        \
    \    \nassert(longest(strings: [] as [String]) == nil)\nassert(longest(strings:\
    \ [\"x\", \"y\", \"z\"]) == \"x\")\nassert(longest(strings: [\"x\", \"yyy\", \"\
    zzzz\", \"www\", \"kkkk\", \"abc\"]) == \"zzzz\")"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660013860
- exit_code: -4
  program: "\n/// Out of array of strings, return the longest one. Return the first\
    \ one in case of multiple\n/// strings of the same length. Return nil in case\
    \ the input array is empty.\n/// >>> longest(strings: [] as [String])\n/// nil\n\
    /// >>> longest(strings: [\"a\", \"b\", \"c\"])\n/// \"a\"\n/// >>> longest(strings:\
    \ [\"a\", \"bb\", \"ccc\"])\n/// \"ccc\"\nfunc longest(strings: [String]) -> String?\
    \ {\n    return nil\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) ->\
    \ Bool {\n    if left.count != right.count {\n        return false\n    }\n  \
    \  for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(longest(strings: []\
    \ as [String]) == nil)\nassert(longest(strings: [\"x\", \"y\", \"z\"]) == \"x\"\
    )\nassert(longest(strings: [\"x\", \"yyy\", \"zzzz\", \"www\", \"kkkk\", \"abc\"\
    ]) == \"zzzz\")"
  status: Exception
  stderr: 'tmp8uuaa7yn/tmp8uuaa7yn.swift:28: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b29a4e1ac80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b29a4b11b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b29a4b11988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b29a4b107b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmp8uuaa7yn                        0x00005612f3a6879a <unavailable> + 6042

    5    libc.so.6                          0x00002b29a5006460 __libc_start_main +
    245

    6    tmp8uuaa7yn                        0x00005612f3a68089 <unavailable> + 4233

    '
  stdout: ''
  timestamp: 1660013739
- exit_code: -4
  program: "\n/// Out of array of strings, return the longest one. Return the first\
    \ one in case of multiple\n/// strings of the same length. Return nil in case\
    \ the input array is empty.\n/// >>> longest(strings: [] as [String])\n/// nil\n\
    /// >>> longest(strings: [\"a\", \"b\", \"c\"])\n/// \"a\"\n/// >>> longest(strings:\
    \ [\"a\", \"bb\", \"ccc\"])\n/// \"ccc\"\nfunc longest(strings: [String]) -> String?\
    \ {\n    if strings.isEmpty {\n        return nil\n    }\n    return strings.reduce(strings[0])\
    \ {\n        $0.count > $1.count ? $0 : $1\n    }\n}\n\n\nfunc ==(left: [(Int,\
    \ Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n\
    \        return false\n    }\n    for (l, r) in zip(left, right) {\n        if\
    \ l != r {\n            return false\n        }\n    }\n    return true\n}\n \
    \           \nassert(longest(strings: [] as [String]) == nil)\nassert(longest(strings:\
    \ [\"x\", \"y\", \"z\"]) == \"x\")\nassert(longest(strings: [\"x\", \"yyy\", \"\
    zzzz\", \"www\", \"kkkk\", \"abc\"]) == \"zzzz\")"
  status: Exception
  stderr: 'tmptof6e_f6/tmptof6e_f6.swift:33: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b0232fccc80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b0232cc3b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b0232cc3988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b0232cc27b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmptof6e_f6                        0x0000562a0729394a <unavailable> + 6474

    5    libc.so.6                          0x00002b02331b8460 __libc_start_main +
    245

    6    tmptof6e_f6                        0x0000562a07293239 <unavailable> + 4665

    '
  stdout: ''
  timestamp: 1660013860
- exit_code: 0
  program: "\n/// Out of array of strings, return the longest one. Return the first\
    \ one in case of multiple\n/// strings of the same length. Return nil in case\
    \ the input array is empty.\n/// >>> longest(strings: [] as [String])\n/// nil\n\
    /// >>> longest(strings: [\"a\", \"b\", \"c\"])\n/// \"a\"\n/// >>> longest(strings:\
    \ [\"a\", \"bb\", \"ccc\"])\n/// \"ccc\"\nfunc longest(strings: [String]) -> String?\
    \ {\n    if strings.isEmpty {\n        return nil\n    }\n    var out: String\
    \ = strings[0]\n    for string in strings {\n        if string.count > out.count\
    \ {\n            out = string\n        }\n    }\n    return out\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(longest(strings: [] as [String]) == nil)\nassert(longest(strings:\
    \ [\"x\", \"y\", \"z\"]) == \"x\")\nassert(longest(strings: [\"x\", \"yyy\", \"\
    zzzz\", \"www\", \"kkkk\", \"abc\"]) == \"zzzz\")"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660013860
- exit_code: 1
  program: "\n/// Out of array of strings, return the longest one. Return the first\
    \ one in case of multiple\n/// strings of the same length. Return nil in case\
    \ the input array is empty.\n/// >>> longest(strings: [] as [String])\n/// nil\n\
    /// >>> longest(strings: [\"a\", \"b\", \"c\"])\n/// \"a\"\n/// >>> longest(strings:\
    \ [\"a\", \"bb\", \"ccc\"])\n/// \"ccc\"\nfunc longest(strings: [String]) -> String?\
    \ {\n    var max: String? = nil\n    for string in strings {\n        if max ==\
    \ nil || string.characters.count > max!.characters.count {\n            max =\
    \ string\n        }\n    }\n    return max\n}\n\n\nfunc ==(left: [(Int, Int)],\
    \ right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n       \
    \ return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r\
    \ {\n            return false\n        }\n    }\n    return true\n}\n        \
    \    \nassert(longest(strings: [] as [String]) == nil)\nassert(longest(strings:\
    \ [\"x\", \"y\", \"z\"]) == \"x\")\nassert(longest(strings: [\"x\", \"yyy\", \"\
    zzzz\", \"www\", \"kkkk\", \"abc\"]) == \"zzzz\")"
  status: SyntaxError
  stderr: "/tmp/tmp3jd39xla.swift:13:33: error: 'characters' is unavailable: Please\
    \ use String directly\n        if max == nil || string.characters.count > max!.characters.count\
    \ {\n                                ^~~~~~~~~~\nSwift.String:5:16: note: 'characters'\
    \ was obsoleted in Swift 5.0\n    public var characters: String { get set }\n\
    \               ^\n/tmp/tmp3jd39xla.swift:13:57: error: 'characters' is unavailable:\
    \ Please use String directly\n        if max == nil || string.characters.count\
    \ > max!.characters.count {\n                                                \
    \        ^~~~~~~~~~\nSwift.String:5:16: note: 'characters' was obsoleted in Swift\
    \ 5.0\n    public var characters: String { get set }\n               ^\n"
  stdout: ''
  timestamp: 1660013859
- exit_code: 0
  program: "\n/// Out of array of strings, return the longest one. Return the first\
    \ one in case of multiple\n/// strings of the same length. Return nil in case\
    \ the input array is empty.\n/// >>> longest(strings: [] as [String])\n/// nil\n\
    /// >>> longest(strings: [\"a\", \"b\", \"c\"])\n/// \"a\"\n/// >>> longest(strings:\
    \ [\"a\", \"bb\", \"ccc\"])\n/// \"ccc\"\nfunc longest(strings: [String]) -> String?\
    \ {\n    if strings.isEmpty {\n        return nil\n    }\n    var result = strings[0]\n\
    \    for string in strings {\n        if string.count > result.count {\n     \
    \       result = string\n        }\n    }\n    return result\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(longest(strings: [] as [String]) == nil)\nassert(longest(strings:\
    \ [\"x\", \"y\", \"z\"]) == \"x\")\nassert(longest(strings: [\"x\", \"yyy\", \"\
    zzzz\", \"www\", \"kkkk\", \"abc\"]) == \"zzzz\")"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660013860
- exit_code: 0
  program: "\n/// Out of array of strings, return the longest one. Return the first\
    \ one in case of multiple\n/// strings of the same length. Return nil in case\
    \ the input array is empty.\n/// >>> longest(strings: [] as [String])\n/// nil\n\
    /// >>> longest(strings: [\"a\", \"b\", \"c\"])\n/// \"a\"\n/// >>> longest(strings:\
    \ [\"a\", \"bb\", \"ccc\"])\n/// \"ccc\"\nfunc longest(strings: [String]) -> String?\
    \ {\n    if strings.isEmpty {\n        return nil\n    }\n    var longestString\
    \ = strings[0]\n    for string in strings {\n        if string.count > longestString.count\
    \ {\n            longestString = string\n        }\n    }\n    return longestString\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(longest(strings: [] as [String]) == nil)\nassert(longest(strings:\
    \ [\"x\", \"y\", \"z\"]) == \"x\")\nassert(longest(strings: [\"x\", \"yyy\", \"\
    zzzz\", \"www\", \"kkkk\", \"abc\"]) == \"zzzz\")"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660013739
- exit_code: 1
  program: "\n/// Out of array of strings, return the longest one. Return the first\
    \ one in case of multiple\n/// strings of the same length. Return nil in case\
    \ the input array is empty.\n/// >>> longest(strings: [] as [String])\n/// nil\n\
    /// >>> longest(strings: [\"a\", \"b\", \"c\"])\n/// \"a\"\n/// >>> longest(strings:\
    \ [\"a\", \"bb\", \"ccc\"])\n/// \"ccc\"\nfunc longest(strings: [String]) -> String?\
    \ {\n    var longest: String? = nil\n    var maxLength = 0\n    for str in strings\
    \ {\n        if str.characters.count > maxLength {\n            maxLength = str.characters.count\n\
    \            longest = str\n        }\n    }\n    return longest\n}\n\n\nfunc\
    \ ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count !=\
    \ right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(longest(strings: [] as [String]) == nil)\nassert(longest(strings:\
    \ [\"x\", \"y\", \"z\"]) == \"x\")\nassert(longest(strings: [\"x\", \"yyy\", \"\
    zzzz\", \"www\", \"kkkk\", \"abc\"]) == \"zzzz\")"
  status: SyntaxError
  stderr: "/tmp/tmp6xb8smjl.swift:14:16: error: 'characters' is unavailable: Please\
    \ use String directly\n        if str.characters.count > maxLength {\n       \
    \        ^~~~~~~~~~\nSwift.String:5:16: note: 'characters' was obsoleted in Swift\
    \ 5.0\n    public var characters: String { get set }\n               ^\n/tmp/tmp6xb8smjl.swift:15:29:\
    \ error: 'characters' is unavailable: Please use String directly\n           \
    \ maxLength = str.characters.count\n                            ^~~~~~~~~~\nSwift.String:5:16:\
    \ note: 'characters' was obsoleted in Swift 5.0\n    public var characters: String\
    \ { get set }\n               ^\n"
  stdout: ''
  timestamp: 1660013859
- exit_code: 0
  program: "\n/// Out of array of strings, return the longest one. Return the first\
    \ one in case of multiple\n/// strings of the same length. Return nil in case\
    \ the input array is empty.\n/// >>> longest(strings: [] as [String])\n/// nil\n\
    /// >>> longest(strings: [\"a\", \"b\", \"c\"])\n/// \"a\"\n/// >>> longest(strings:\
    \ [\"a\", \"bb\", \"ccc\"])\n/// \"ccc\"\nfunc longest(strings: [String]) -> String?\
    \ {\n    guard let first = strings.first else { return nil }\n    return strings.reduce(first)\
    \ { (longestString, string) -> String in\n        if string.count > longestString.count\
    \ {\n            return string\n        } else {\n            return longestString\n\
    \        }\n    }\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) ->\
    \ Bool {\n    if left.count != right.count {\n        return false\n    }\n  \
    \  for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(longest(strings: []\
    \ as [String]) == nil)\nassert(longest(strings: [\"x\", \"y\", \"z\"]) == \"x\"\
    )\nassert(longest(strings: [\"x\", \"yyy\", \"zzzz\", \"www\", \"kkkk\", \"abc\"\
    ]) == \"zzzz\")"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660013860
- exit_code: 0
  program: "\n/// Out of array of strings, return the longest one. Return the first\
    \ one in case of multiple\n/// strings of the same length. Return nil in case\
    \ the input array is empty.\n/// >>> longest(strings: [] as [String])\n/// nil\n\
    /// >>> longest(strings: [\"a\", \"b\", \"c\"])\n/// \"a\"\n/// >>> longest(strings:\
    \ [\"a\", \"bb\", \"ccc\"])\n/// \"ccc\"\nfunc longest(strings: [String]) -> String?\
    \ {\n    // Write your implementation here\n    return strings.max(by: {$0.count\
    \ < $1.count})\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool\
    \ {\n    if left.count != right.count {\n        return false\n    }\n    for\
    \ (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(longest(strings: []\
    \ as [String]) == nil)\nassert(longest(strings: [\"x\", \"y\", \"z\"]) == \"x\"\
    )\nassert(longest(strings: [\"x\", \"yyy\", \"zzzz\", \"www\", \"kkkk\", \"abc\"\
    ]) == \"zzzz\")"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660013860
- exit_code: 1
  program: "\n/// Out of array of strings, return the longest one. Return the first\
    \ one in case of multiple\n/// strings of the same length. Return nil in case\
    \ the input array is empty.\n/// >>> longest(strings: [] as [String])\n/// nil\n\
    /// >>> longest(strings: [\"a\", \"b\", \"c\"])\n/// \"a\"\n/// >>> longest(strings:\
    \ [\"a\", \"bb\", \"ccc\"])\n/// \"ccc\"\nfunc longest(strings: [String]) -> String?\
    \ {\n    //    return strings.sort { $0.characters.count > $1.characters.count\
    \ }.first\n    //    return strings.sorted { $0.characters.count > $1.characters.count\
    \ }.first\n    //    return strings.sorted(by: { $0.characters.count > $1.characters.count\
    \ }).first\n    //    return strings.sorted(by: { a, b in a.characters.count >\
    \ b.characters.count }).first\n    //    return strings.sorted(by: { (a, b) in\
    \ a.characters.count > b.characters.count }).first\n    //    return strings.sorted(by:\
    \ { a, b in return a.characters.count > b.characters.count }).first\n    //  \
    \  return strings.sorted(by: { a, b in a.characters.count > b.characters.count\
    \ }).first\n    //    return strings.sorted(by: { (a, b) in return a.characters.count\
    \ > b.characters.count }).first\n    //    return strings.sorted(by: { (a, b)\
    \ in a.characters.count > b.characters.count }).first\n    //    return strings.sorted(by:\
    \ { a, b in return a.characters.count > b.characters.count }).first\n    //  \
    \  return strings.sorted(by: { a, b in a.characters.count > b.characters.count\
    \ }).first\n    //    return strings.sorted(by: { a, b in return a.characters.count\
    \ > b.characters.count }).first\n    //    return strings.sorted(by: { a, b in\
    \ a.characters.count > b.characters.count }).first\n    //    return strings.sorted(by:\
    \ { a, b in return a.characters.count > b.characters.count }).first\n    //  \
    \  return strings.sorted(by: { a, b in a.characters.count > b.characters.count\
    \ }).first\n    //    return strings.sorted(by: { a, b in return a\n}\n\n\nfunc\
    \ ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count !=\
    \ right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(longest(strings: [] as [String]) == nil)\nassert(longest(strings:\
    \ [\"x\", \"y\", \"z\"]) == \"x\")\nassert(longest(strings: [\"x\", \"yyy\", \"\
    zzzz\", \"www\", \"kkkk\", \"abc\"]) == \"zzzz\")"
  status: SyntaxError
  stderr: '/tmp/tmp2j3oc_lg.swift:27:1: error: missing return in global function expected
    to return ''String?''

    }

    ^

    '
  stdout: ''
  timestamp: 1660013859
- exit_code: 0
  program: "\n/// Out of array of strings, return the longest one. Return the first\
    \ one in case of multiple\n/// strings of the same length. Return nil in case\
    \ the input array is empty.\n/// >>> longest(strings: [] as [String])\n/// nil\n\
    /// >>> longest(strings: [\"a\", \"b\", \"c\"])\n/// \"a\"\n/// >>> longest(strings:\
    \ [\"a\", \"bb\", \"ccc\"])\n/// \"ccc\"\nfunc longest(strings: [String]) -> String?\
    \ {\n    if strings.isEmpty {\n        return nil\n    }\n    return strings.sorted(by:\
    \ { $0.count > $1.count }).first\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int,\
    \ Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n\
    \    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n          \
    \  return false\n        }\n    }\n    return true\n}\n            \nassert(longest(strings:\
    \ [] as [String]) == nil)\nassert(longest(strings: [\"x\", \"y\", \"z\"]) == \"\
    x\")\nassert(longest(strings: [\"x\", \"yyy\", \"zzzz\", \"www\", \"kkkk\", \"\
    abc\"]) == \"zzzz\")"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660013860
- exit_code: 0
  program: "\n/// Out of array of strings, return the longest one. Return the first\
    \ one in case of multiple\n/// strings of the same length. Return nil in case\
    \ the input array is empty.\n/// >>> longest(strings: [] as [String])\n/// nil\n\
    /// >>> longest(strings: [\"a\", \"b\", \"c\"])\n/// \"a\"\n/// >>> longest(strings:\
    \ [\"a\", \"bb\", \"ccc\"])\n/// \"ccc\"\nfunc longest(strings: [String]) -> String?\
    \ {\n    if strings.isEmpty {\n        return nil\n    }\n    var longestString\
    \ = strings[0]\n    for string in strings[1..<strings.count] {\n        if string.count\
    \ > longestString.count {\n            longestString = string\n        }\n   \
    \ }\n    return longestString\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int,\
    \ Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n\
    \    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n          \
    \  return false\n        }\n    }\n    return true\n}\n            \nassert(longest(strings:\
    \ [] as [String]) == nil)\nassert(longest(strings: [\"x\", \"y\", \"z\"]) == \"\
    x\")\nassert(longest(strings: [\"x\", \"yyy\", \"zzzz\", \"www\", \"kkkk\", \"\
    abc\"]) == \"zzzz\")"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660013860
- exit_code: 1
  program: "\n/// Out of array of strings, return the longest one. Return the first\
    \ one in case of multiple\n/// strings of the same length. Return nil in case\
    \ the input array is empty.\n/// >>> longest(strings: [] as [String])\n/// nil\n\
    /// >>> longest(strings: [\"a\", \"b\", \"c\"])\n/// \"a\"\n/// >>> longest(strings:\
    \ [\"a\", \"bb\", \"ccc\"])\n/// \"ccc\"\nfunc longest(strings: [String]) -> String?\
    \ {\n    var longest: String? = nil\n    for s in strings {\n        if longest\
    \ == nil || s.characters.count > longest!.characters.count {\n            longest\
    \ = s\n        }\n    }\n    return longest\n}\n\n\nfunc ==(left: [(Int, Int)],\
    \ right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n       \
    \ return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r\
    \ {\n            return false\n        }\n    }\n    return true\n}\n        \
    \    \nassert(longest(strings: [] as [String]) == nil)\nassert(longest(strings:\
    \ [\"x\", \"y\", \"z\"]) == \"x\")\nassert(longest(strings: [\"x\", \"yyy\", \"\
    zzzz\", \"www\", \"kkkk\", \"abc\"]) == \"zzzz\")"
  status: SyntaxError
  stderr: "/tmp/tmp2ngpbnt1.swift:13:32: error: 'characters' is unavailable: Please\
    \ use String directly\n        if longest == nil || s.characters.count > longest!.characters.count\
    \ {\n                               ^~~~~~~~~~\nSwift.String:5:16: note: 'characters'\
    \ was obsoleted in Swift 5.0\n    public var characters: String { get set }\n\
    \               ^\n/tmp/tmp2ngpbnt1.swift:13:60: error: 'characters' is unavailable:\
    \ Please use String directly\n        if longest == nil || s.characters.count\
    \ > longest!.characters.count {\n                                            \
    \               ^~~~~~~~~~\nSwift.String:5:16: note: 'characters' was obsoleted\
    \ in Swift 5.0\n    public var characters: String { get set }\n              \
    \ ^\n"
  stdout: ''
  timestamp: 1660013859
- exit_code: 0
  program: "\n/// Out of array of strings, return the longest one. Return the first\
    \ one in case of multiple\n/// strings of the same length. Return nil in case\
    \ the input array is empty.\n/// >>> longest(strings: [] as [String])\n/// nil\n\
    /// >>> longest(strings: [\"a\", \"b\", \"c\"])\n/// \"a\"\n/// >>> longest(strings:\
    \ [\"a\", \"bb\", \"ccc\"])\n/// \"ccc\"\nfunc longest(strings: [String]) -> String?\
    \ {\n    if strings.isEmpty {\n        return nil\n    } else {\n        var longestString\
    \ = strings[0]\n        for string in strings {\n            if string.count >\
    \ longestString.count {\n                longestString = string\n            }\n\
    \        }\n        return longestString\n    }\n}\n\n\nfunc ==(left: [(Int, Int)],\
    \ right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n       \
    \ return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r\
    \ {\n            return false\n        }\n    }\n    return true\n}\n        \
    \    \nassert(longest(strings: [] as [String]) == nil)\nassert(longest(strings:\
    \ [\"x\", \"y\", \"z\"]) == \"x\")\nassert(longest(strings: [\"x\", \"yyy\", \"\
    zzzz\", \"www\", \"kkkk\", \"abc\"]) == \"zzzz\")"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660013860
- exit_code: 1
  program: "\n/// Out of array of strings, return the longest one. Return the first\
    \ one in case of multiple\n/// strings of the same length. Return nil in case\
    \ the input array is empty.\n/// >>> longest(strings: [] as [String])\n/// nil\n\
    /// >>> longest(strings: [\"a\", \"b\", \"c\"])\n/// \"a\"\n/// >>> longest(strings:\
    \ [\"a\", \"bb\", \"ccc\"])\n/// \"ccc\"\nfunc longest(strings: [String]) -> String?\
    \ {\n    if strings.isEmpty {\n        return nil\n    }\n    else {\n       \
    \ return (strings.sorted(by: { $0.characters.count > $1.characters.count})).first\n\
    \    }\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n  \
    \  if left.count != right.count {\n        return false\n    }\n    for (l, r)\
    \ in zip(left, right) {\n        if l != r {\n            return false\n     \
    \   }\n    }\n    return true\n}\n            \nassert(longest(strings: [] as\
    \ [String]) == nil)\nassert(longest(strings: [\"x\", \"y\", \"z\"]) == \"x\")\n\
    assert(longest(strings: [\"x\", \"yyy\", \"zzzz\", \"www\", \"kkkk\", \"abc\"\
    ]) == \"zzzz\")"
  status: SyntaxError
  stderr: "/tmp/tmpqbykg3f2.swift:15:41: error: 'characters' is unavailable: Please\
    \ use String directly\n        return (strings.sorted(by: { $0.characters.count\
    \ > $1.characters.count})).first\n                                        ^~~~~~~~~~\n\
    Swift.String:5:16: note: 'characters' was obsoleted in Swift 5.0\n    public var\
    \ characters: String { get set }\n               ^\n/tmp/tmpqbykg3f2.swift:15:63:\
    \ error: 'characters' is unavailable: Please use String directly\n        return\
    \ (strings.sorted(by: { $0.characters.count > $1.characters.count})).first\n \
    \                                                             ^~~~~~~~~~\nSwift.String:5:16:\
    \ note: 'characters' was obsoleted in Swift 5.0\n    public var characters: String\
    \ { get set }\n               ^\n"
  stdout: ''
  timestamp: 1660013860
- exit_code: 0
  program: "\n/// Out of array of strings, return the longest one. Return the first\
    \ one in case of multiple\n/// strings of the same length. Return nil in case\
    \ the input array is empty.\n/// >>> longest(strings: [] as [String])\n/// nil\n\
    /// >>> longest(strings: [\"a\", \"b\", \"c\"])\n/// \"a\"\n/// >>> longest(strings:\
    \ [\"a\", \"bb\", \"ccc\"])\n/// \"ccc\"\nfunc longest(strings: [String]) -> String?\
    \ {\n    guard !strings.isEmpty else { return nil }\n    var rtn: String = strings[0]\n\
    \    for s in strings {\n        if s.count > rtn.count {\n            rtn = s\n\
    \        }\n    }\n    return rtn\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int,\
    \ Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n\
    \    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n          \
    \  return false\n        }\n    }\n    return true\n}\n            \nassert(longest(strings:\
    \ [] as [String]) == nil)\nassert(longest(strings: [\"x\", \"y\", \"z\"]) == \"\
    x\")\nassert(longest(strings: [\"x\", \"yyy\", \"zzzz\", \"www\", \"kkkk\", \"\
    abc\"]) == \"zzzz\")"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660013860
- exit_code: 1
  program: "\n/// Out of array of strings, return the longest one. Return the first\
    \ one in case of multiple\n/// strings of the same length. Return nil in case\
    \ the input array is empty.\n/// >>> longest(strings: [] as [String])\n/// nil\n\
    /// >>> longest(strings: [\"a\", \"b\", \"c\"])\n/// \"a\"\n/// >>> longest(strings:\
    \ [\"a\", \"bb\", \"ccc\"])\n/// \"ccc\"\nfunc longest(strings: [String]) -> String?\
    \ {\n    if strings.isEmpty {\n        return nil\n    }\n    let sorted = strings.sorted\
    \ { $0.characters.count > $1.characters.count }\n    return sorted.first\n}\n\n\
    \nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(longest(strings: [] as [String]) == nil)\nassert(longest(strings:\
    \ [\"x\", \"y\", \"z\"]) == \"x\")\nassert(longest(strings: [\"x\", \"yyy\", \"\
    zzzz\", \"www\", \"kkkk\", \"abc\"]) == \"zzzz\")"
  status: SyntaxError
  stderr: "/tmp/tmpr1_jzq4n.swift:14:38: error: 'characters' is unavailable: Please\
    \ use String directly\n    let sorted = strings.sorted { $0.characters.count >\
    \ $1.characters.count }\n                                     ^~~~~~~~~~\nSwift.String:5:16:\
    \ note: 'characters' was obsoleted in Swift 5.0\n    public var characters: String\
    \ { get set }\n               ^\n/tmp/tmpr1_jzq4n.swift:14:60: error: 'characters'\
    \ is unavailable: Please use String directly\n    let sorted = strings.sorted\
    \ { $0.characters.count > $1.characters.count }\n                            \
    \                               ^~~~~~~~~~\nSwift.String:5:16: note: 'characters'\
    \ was obsoleted in Swift 5.0\n    public var characters: String { get set }\n\
    \               ^\n"
  stdout: ''
  timestamp: 1660013860
- exit_code: 0
  program: "\n/// Out of array of strings, return the longest one. Return the first\
    \ one in case of multiple\n/// strings of the same length. Return nil in case\
    \ the input array is empty.\n/// >>> longest(strings: [] as [String])\n/// nil\n\
    /// >>> longest(strings: [\"a\", \"b\", \"c\"])\n/// \"a\"\n/// >>> longest(strings:\
    \ [\"a\", \"bb\", \"ccc\"])\n/// \"ccc\"\nfunc longest(strings: [String]) -> String?\
    \ {\n    var longest: String? = nil\n    for string in strings {\n        if longest\
    \ == nil || string.count > longest!.count {\n            longest = string\n  \
    \      }\n    }\n    return longest\n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(longest(strings: [] as [String]) == nil)\nassert(longest(strings: [\"x\"\
    , \"y\", \"z\"]) == \"x\")\nassert(longest(strings: [\"x\", \"yyy\", \"zzzz\"\
    , \"www\", \"kkkk\", \"abc\"]) == \"zzzz\")"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660013739
- exit_code: 0
  program: "\n/// Out of array of strings, return the longest one. Return the first\
    \ one in case of multiple\n/// strings of the same length. Return nil in case\
    \ the input array is empty.\n/// >>> longest(strings: [] as [String])\n/// nil\n\
    /// >>> longest(strings: [\"a\", \"b\", \"c\"])\n/// \"a\"\n/// >>> longest(strings:\
    \ [\"a\", \"bb\", \"ccc\"])\n/// \"ccc\"\nfunc longest(strings: [String]) -> String?\
    \ {\n    guard !strings.isEmpty else { return nil }\n    return strings.reduce(strings[0])\
    \ { a, b in\n        a.count >= b.count ? a : b\n    }\n}\n\n\nfunc ==(left: [(Int,\
    \ Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n\
    \        return false\n    }\n    for (l, r) in zip(left, right) {\n        if\
    \ l != r {\n            return false\n        }\n    }\n    return true\n}\n \
    \           \nassert(longest(strings: [] as [String]) == nil)\nassert(longest(strings:\
    \ [\"x\", \"y\", \"z\"]) == \"x\")\nassert(longest(strings: [\"x\", \"yyy\", \"\
    zzzz\", \"www\", \"kkkk\", \"abc\"]) == \"zzzz\")"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660013860
- exit_code: 0
  program: "\n/// Out of array of strings, return the longest one. Return the first\
    \ one in case of multiple\n/// strings of the same length. Return nil in case\
    \ the input array is empty.\n/// >>> longest(strings: [] as [String])\n/// nil\n\
    /// >>> longest(strings: [\"a\", \"b\", \"c\"])\n/// \"a\"\n/// >>> longest(strings:\
    \ [\"a\", \"bb\", \"ccc\"])\n/// \"ccc\"\nfunc longest(strings: [String]) -> String?\
    \ {\n    var longestString: String?\n    for aString in strings {\n        if\
    \ longestString == nil || aString.count > longestString!.count {\n           \
    \ longestString = aString\n        }\n    }\n    return longestString\n}\n\n\n\
    func ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(longest(strings: [] as [String]) == nil)\nassert(longest(strings:\
    \ [\"x\", \"y\", \"z\"]) == \"x\")\nassert(longest(strings: [\"x\", \"yyy\", \"\
    zzzz\", \"www\", \"kkkk\", \"abc\"]) == \"zzzz\")"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660013860
- exit_code: 0
  program: "\n/// Out of array of strings, return the longest one. Return the first\
    \ one in case of multiple\n/// strings of the same length. Return nil in case\
    \ the input array is empty.\n/// >>> longest(strings: [] as [String])\n/// nil\n\
    /// >>> longest(strings: [\"a\", \"b\", \"c\"])\n/// \"a\"\n/// >>> longest(strings:\
    \ [\"a\", \"bb\", \"ccc\"])\n/// \"ccc\"\nfunc longest(strings: [String]) -> String?\
    \ {\n    if strings.isEmpty {\n        return nil\n    } else {\n        var longest:\
    \ String = strings[0]\n        for string in strings {\n            if string.count\
    \ > longest.count {\n                longest = string\n            }\n       \
    \ }\n        return longest\n    }\n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(longest(strings: [] as [String]) == nil)\nassert(longest(strings: [\"x\"\
    , \"y\", \"z\"]) == \"x\")\nassert(longest(strings: [\"x\", \"yyy\", \"zzzz\"\
    , \"www\", \"kkkk\", \"abc\"]) == \"zzzz\")"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660013860
- exit_code: 0
  program: "\n/// Out of array of strings, return the longest one. Return the first\
    \ one in case of multiple\n/// strings of the same length. Return nil in case\
    \ the input array is empty.\n/// >>> longest(strings: [] as [String])\n/// nil\n\
    /// >>> longest(strings: [\"a\", \"b\", \"c\"])\n/// \"a\"\n/// >>> longest(strings:\
    \ [\"a\", \"bb\", \"ccc\"])\n/// \"ccc\"\nfunc longest(strings: [String]) -> String?\
    \ {\n    if strings.isEmpty {\n        return nil\n    }\n    var longest = strings[0]\n\
    \    for str in strings {\n        if str.count > longest.count {\n          \
    \  longest = str\n        }\n    }\n    return longest\n}\n\n\nfunc ==(left: [(Int,\
    \ Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n\
    \        return false\n    }\n    for (l, r) in zip(left, right) {\n        if\
    \ l != r {\n            return false\n        }\n    }\n    return true\n}\n \
    \           \nassert(longest(strings: [] as [String]) == nil)\nassert(longest(strings:\
    \ [\"x\", \"y\", \"z\"]) == \"x\")\nassert(longest(strings: [\"x\", \"yyy\", \"\
    zzzz\", \"www\", \"kkkk\", \"abc\"]) == \"zzzz\")"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660013860
- exit_code: -4
  program: "\n/// Out of array of strings, return the longest one. Return the first\
    \ one in case of multiple\n/// strings of the same length. Return nil in case\
    \ the input array is empty.\n/// >>> longest(strings: [] as [String])\n/// nil\n\
    /// >>> longest(strings: [\"a\", \"b\", \"c\"])\n/// \"a\"\n/// >>> longest(strings:\
    \ [\"a\", \"bb\", \"ccc\"])\n/// \"ccc\"\nfunc longest(strings: [String]) -> String?\
    \ {\n    return nil\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) ->\
    \ Bool {\n    if left.count != right.count {\n        return false\n    }\n  \
    \  for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(longest(strings: []\
    \ as [String]) == nil)\nassert(longest(strings: [\"x\", \"y\", \"z\"]) == \"x\"\
    )\nassert(longest(strings: [\"x\", \"yyy\", \"zzzz\", \"www\", \"kkkk\", \"abc\"\
    ]) == \"zzzz\")"
  status: Exception
  stderr: 'tmp8uuaa7yn/tmp8uuaa7yn.swift:28: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b29a4e1ac80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b29a4b11b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b29a4b11988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b29a4b107b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmp8uuaa7yn                        0x00005612f3a6879a <unavailable> + 6042

    5    libc.so.6                          0x00002b29a5006460 __libc_start_main +
    245

    6    tmp8uuaa7yn                        0x00005612f3a68089 <unavailable> + 4233

    '
  stdout: ''
  timestamp: 1660013739
- exit_code: -4
  program: "\n/// Out of array of strings, return the longest one. Return the first\
    \ one in case of multiple\n/// strings of the same length. Return nil in case\
    \ the input array is empty.\n/// >>> longest(strings: [] as [String])\n/// nil\n\
    /// >>> longest(strings: [\"a\", \"b\", \"c\"])\n/// \"a\"\n/// >>> longest(strings:\
    \ [\"a\", \"bb\", \"ccc\"])\n/// \"ccc\"\nfunc longest(strings: [String]) -> String?\
    \ {\n    return nil\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) ->\
    \ Bool {\n    if left.count != right.count {\n        return false\n    }\n  \
    \  for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(longest(strings: []\
    \ as [String]) == nil)\nassert(longest(strings: [\"x\", \"y\", \"z\"]) == \"x\"\
    )\nassert(longest(strings: [\"x\", \"yyy\", \"zzzz\", \"www\", \"kkkk\", \"abc\"\
    ]) == \"zzzz\")"
  status: Exception
  stderr: 'tmp8uuaa7yn/tmp8uuaa7yn.swift:28: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b29a4e1ac80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b29a4b11b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b29a4b11988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b29a4b107b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmp8uuaa7yn                        0x00005612f3a6879a <unavailable> + 6042

    5    libc.so.6                          0x00002b29a5006460 __libc_start_main +
    245

    6    tmp8uuaa7yn                        0x00005612f3a68089 <unavailable> + 4233

    '
  stdout: ''
  timestamp: 1660013739
- exit_code: 1
  program: "\n/// Out of array of strings, return the longest one. Return the first\
    \ one in case of multiple\n/// strings of the same length. Return nil in case\
    \ the input array is empty.\n/// >>> longest(strings: [] as [String])\n/// nil\n\
    /// >>> longest(strings: [\"a\", \"b\", \"c\"])\n/// \"a\"\n/// >>> longest(strings:\
    \ [\"a\", \"bb\", \"ccc\"])\n/// \"ccc\"\nfunc longest(strings: [String]) -> String?\
    \ {\n    var length = 0\n    var str : String?\n    for s in strings {\n     \
    \   if s.characters.count > length {\n            length = s.characters.count\n\
    \            str = s\n        }\n    }\n    return str\n}\n\n\nfunc ==(left: [(Int,\
    \ Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n\
    \        return false\n    }\n    for (l, r) in zip(left, right) {\n        if\
    \ l != r {\n            return false\n        }\n    }\n    return true\n}\n \
    \           \nassert(longest(strings: [] as [String]) == nil)\nassert(longest(strings:\
    \ [\"x\", \"y\", \"z\"]) == \"x\")\nassert(longest(strings: [\"x\", \"yyy\", \"\
    zzzz\", \"www\", \"kkkk\", \"abc\"]) == \"zzzz\")"
  status: SyntaxError
  stderr: "/tmp/tmpdoy3da70.swift:14:14: error: 'characters' is unavailable: Please\
    \ use String directly\n        if s.characters.count > length {\n            \
    \ ^~~~~~~~~~\nSwift.String:5:16: note: 'characters' was obsoleted in Swift 5.0\n\
    \    public var characters: String { get set }\n               ^\n/tmp/tmpdoy3da70.swift:15:24:\
    \ error: 'characters' is unavailable: Please use String directly\n           \
    \ length = s.characters.count\n                       ^~~~~~~~~~\nSwift.String:5:16:\
    \ note: 'characters' was obsoleted in Swift 5.0\n    public var characters: String\
    \ { get set }\n               ^\n"
  stdout: ''
  timestamp: 1660013860
- exit_code: 0
  program: "\n/// Out of array of strings, return the longest one. Return the first\
    \ one in case of multiple\n/// strings of the same length. Return nil in case\
    \ the input array is empty.\n/// >>> longest(strings: [] as [String])\n/// nil\n\
    /// >>> longest(strings: [\"a\", \"b\", \"c\"])\n/// \"a\"\n/// >>> longest(strings:\
    \ [\"a\", \"bb\", \"ccc\"])\n/// \"ccc\"\nfunc longest(strings: [String]) -> String?\
    \ {\n    guard let longestString = strings.sorted(by: {$0.count > $1.count}).first\
    \ else {\n        return nil\n    }\n    return longestString\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(longest(strings: [] as [String]) == nil)\nassert(longest(strings:\
    \ [\"x\", \"y\", \"z\"]) == \"x\")\nassert(longest(strings: [\"x\", \"yyy\", \"\
    zzzz\", \"www\", \"kkkk\", \"abc\"]) == \"zzzz\")"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660013860
- exit_code: 1
  program: "\n/// Out of array of strings, return the longest one. Return the first\
    \ one in case of multiple\n/// strings of the same length. Return nil in case\
    \ the input array is empty.\n/// >>> longest(strings: [] as [String])\n/// nil\n\
    /// >>> longest(strings: [\"a\", \"b\", \"c\"])\n/// \"a\"\n/// >>> longest(strings:\
    \ [\"a\", \"bb\", \"ccc\"])\n/// \"ccc\"\nfunc longest(strings: [String]) -> String?\
    \ {\n    if strings.isEmpty {\n        return nil\n    }\n    return strings.reduce(strings[0])\
    \ { (current: String, string: String) -> String in\n        return current.characters.count\
    \ > string.characters.count ? current : string\n    }\n}\n\n\nfunc ==(left: [(Int,\
    \ Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n\
    \        return false\n    }\n    for (l, r) in zip(left, right) {\n        if\
    \ l != r {\n            return false\n        }\n    }\n    return true\n}\n \
    \           \nassert(longest(strings: [] as [String]) == nil)\nassert(longest(strings:\
    \ [\"x\", \"y\", \"z\"]) == \"x\")\nassert(longest(strings: [\"x\", \"yyy\", \"\
    zzzz\", \"www\", \"kkkk\", \"abc\"]) == \"zzzz\")"
  status: SyntaxError
  stderr: "/tmp/tmps5cngbwp.swift:15:24: error: 'characters' is unavailable: Please\
    \ use String directly\n        return current.characters.count > string.characters.count\
    \ ? current : string\n                       ^~~~~~~~~~\nSwift.String:5:16: note:\
    \ 'characters' was obsoleted in Swift 5.0\n    public var characters: String {\
    \ get set }\n               ^\n/tmp/tmps5cngbwp.swift:15:50: error: 'characters'\
    \ is unavailable: Please use String directly\n        return current.characters.count\
    \ > string.characters.count ? current : string\n                             \
    \                    ^~~~~~~~~~\nSwift.String:5:16: note: 'characters' was obsoleted\
    \ in Swift 5.0\n    public var characters: String { get set }\n              \
    \ ^\n"
  stdout: ''
  timestamp: 1660013860
- exit_code: -4
  program: "\n/// Out of array of strings, return the longest one. Return the first\
    \ one in case of multiple\n/// strings of the same length. Return nil in case\
    \ the input array is empty.\n/// >>> longest(strings: [] as [String])\n/// nil\n\
    /// >>> longest(strings: [\"a\", \"b\", \"c\"])\n/// \"a\"\n/// >>> longest(strings:\
    \ [\"a\", \"bb\", \"ccc\"])\n/// \"ccc\"\nfunc longest(strings: [String]) -> String?\
    \ {\n    return nil\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) ->\
    \ Bool {\n    if left.count != right.count {\n        return false\n    }\n  \
    \  for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(longest(strings: []\
    \ as [String]) == nil)\nassert(longest(strings: [\"x\", \"y\", \"z\"]) == \"x\"\
    )\nassert(longest(strings: [\"x\", \"yyy\", \"zzzz\", \"www\", \"kkkk\", \"abc\"\
    ]) == \"zzzz\")"
  status: Exception
  stderr: 'tmp8uuaa7yn/tmp8uuaa7yn.swift:28: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b29a4e1ac80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b29a4b11b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b29a4b11988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b29a4b107b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmp8uuaa7yn                        0x00005612f3a6879a <unavailable> + 6042

    5    libc.so.6                          0x00002b29a5006460 __libc_start_main +
    245

    6    tmp8uuaa7yn                        0x00005612f3a68089 <unavailable> + 4233

    '
  stdout: ''
  timestamp: 1660013739
- exit_code: 0
  program: "\n/// Out of array of strings, return the longest one. Return the first\
    \ one in case of multiple\n/// strings of the same length. Return nil in case\
    \ the input array is empty.\n/// >>> longest(strings: [] as [String])\n/// nil\n\
    /// >>> longest(strings: [\"a\", \"b\", \"c\"])\n/// \"a\"\n/// >>> longest(strings:\
    \ [\"a\", \"bb\", \"ccc\"])\n/// \"ccc\"\nfunc longest(strings: [String]) -> String?\
    \ {\n    if strings.isEmpty {\n        return nil\n    }\n    var result = strings[0]\n\
    \    for string in strings {\n        if string.count > result.count {\n     \
    \       result = string\n        }\n    }\n    return result\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(longest(strings: [] as [String]) == nil)\nassert(longest(strings:\
    \ [\"x\", \"y\", \"z\"]) == \"x\")\nassert(longest(strings: [\"x\", \"yyy\", \"\
    zzzz\", \"www\", \"kkkk\", \"abc\"]) == \"zzzz\")"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660013860
- exit_code: 0
  program: "\n/// Out of array of strings, return the longest one. Return the first\
    \ one in case of multiple\n/// strings of the same length. Return nil in case\
    \ the input array is empty.\n/// >>> longest(strings: [] as [String])\n/// nil\n\
    /// >>> longest(strings: [\"a\", \"b\", \"c\"])\n/// \"a\"\n/// >>> longest(strings:\
    \ [\"a\", \"bb\", \"ccc\"])\n/// \"ccc\"\nfunc longest(strings: [String]) -> String?\
    \ {\n    if strings.isEmpty {\n        return nil\n    }\n    var result = strings[0]\n\
    \    for string in strings {\n        if string.count > result.count {\n     \
    \       result = string\n        }\n    }\n    return result\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(longest(strings: [] as [String]) == nil)\nassert(longest(strings:\
    \ [\"x\", \"y\", \"z\"]) == \"x\")\nassert(longest(strings: [\"x\", \"yyy\", \"\
    zzzz\", \"www\", \"kkkk\", \"abc\"]) == \"zzzz\")"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660013860
- exit_code: 0
  program: "\n/// Out of array of strings, return the longest one. Return the first\
    \ one in case of multiple\n/// strings of the same length. Return nil in case\
    \ the input array is empty.\n/// >>> longest(strings: [] as [String])\n/// nil\n\
    /// >>> longest(strings: [\"a\", \"b\", \"c\"])\n/// \"a\"\n/// >>> longest(strings:\
    \ [\"a\", \"bb\", \"ccc\"])\n/// \"ccc\"\nfunc longest(strings: [String]) -> String?\
    \ {\n    guard let longestString = strings.max(by: {\n        $0.count < $1.count\n\
    \    }) else {\n        return nil\n    }\n    return longestString\n}\n\n\nfunc\
    \ ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count !=\
    \ right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(longest(strings: [] as [String]) == nil)\nassert(longest(strings:\
    \ [\"x\", \"y\", \"z\"]) == \"x\")\nassert(longest(strings: [\"x\", \"yyy\", \"\
    zzzz\", \"www\", \"kkkk\", \"abc\"]) == \"zzzz\")"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660013860
- exit_code: 0
  program: "\n/// Out of array of strings, return the longest one. Return the first\
    \ one in case of multiple\n/// strings of the same length. Return nil in case\
    \ the input array is empty.\n/// >>> longest(strings: [] as [String])\n/// nil\n\
    /// >>> longest(strings: [\"a\", \"b\", \"c\"])\n/// \"a\"\n/// >>> longest(strings:\
    \ [\"a\", \"bb\", \"ccc\"])\n/// \"ccc\"\nfunc longest(strings: [String]) -> String?\
    \ {\n    guard strings.count > 0 else {\n        return nil\n    }\n    var longest:\
    \ String = strings[0]\n    for string in strings {\n        if string.count >\
    \ longest.count {\n            longest = string\n        }\n    }\n    return\
    \ longest\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n\
    \    if left.count != right.count {\n        return false\n    }\n    for (l,\
    \ r) in zip(left, right) {\n        if l != r {\n            return false\n  \
    \      }\n    }\n    return true\n}\n            \nassert(longest(strings: []\
    \ as [String]) == nil)\nassert(longest(strings: [\"x\", \"y\", \"z\"]) == \"x\"\
    )\nassert(longest(strings: [\"x\", \"yyy\", \"zzzz\", \"www\", \"kkkk\", \"abc\"\
    ]) == \"zzzz\")"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660013860
- exit_code: 0
  program: "\n/// Out of array of strings, return the longest one. Return the first\
    \ one in case of multiple\n/// strings of the same length. Return nil in case\
    \ the input array is empty.\n/// >>> longest(strings: [] as [String])\n/// nil\n\
    /// >>> longest(strings: [\"a\", \"b\", \"c\"])\n/// \"a\"\n/// >>> longest(strings:\
    \ [\"a\", \"bb\", \"ccc\"])\n/// \"ccc\"\nfunc longest(strings: [String]) -> String?\
    \ {\n    guard strings.count > 0 else {\n        return nil\n    }\n    let stringsSorted\
    \ = strings.sorted(by: { $0.count > $1.count })\n    return stringsSorted[0]\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(longest(strings: [] as [String]) == nil)\nassert(longest(strings:\
    \ [\"x\", \"y\", \"z\"]) == \"x\")\nassert(longest(strings: [\"x\", \"yyy\", \"\
    zzzz\", \"www\", \"kkkk\", \"abc\"]) == \"zzzz\")"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660013860
- exit_code: 0
  program: "\n/// Out of array of strings, return the longest one. Return the first\
    \ one in case of multiple\n/// strings of the same length. Return nil in case\
    \ the input array is empty.\n/// >>> longest(strings: [] as [String])\n/// nil\n\
    /// >>> longest(strings: [\"a\", \"b\", \"c\"])\n/// \"a\"\n/// >>> longest(strings:\
    \ [\"a\", \"bb\", \"ccc\"])\n/// \"ccc\"\nfunc longest(strings: [String]) -> String?\
    \ {\n  if strings.isEmpty {\n    return nil\n  }\n  var longest = strings[0]\n\
    \  for string in strings {\n    if string.count > longest.count {\n      longest\
    \ = string\n    }\n  }\n  return longest\n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(longest(strings: [] as [String]) == nil)\nassert(longest(strings: [\"x\"\
    , \"y\", \"z\"]) == \"x\")\nassert(longest(strings: [\"x\", \"yyy\", \"zzzz\"\
    , \"www\", \"kkkk\", \"abc\"]) == \"zzzz\")"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660013860
- exit_code: 0
  program: "\n/// Out of array of strings, return the longest one. Return the first\
    \ one in case of multiple\n/// strings of the same length. Return nil in case\
    \ the input array is empty.\n/// >>> longest(strings: [] as [String])\n/// nil\n\
    /// >>> longest(strings: [\"a\", \"b\", \"c\"])\n/// \"a\"\n/// >>> longest(strings:\
    \ [\"a\", \"bb\", \"ccc\"])\n/// \"ccc\"\nfunc longest(strings: [String]) -> String?\
    \ {\n    var longestString: String?\n    var longestStringLength = 0\n    for\
    \ str in strings {\n        if (str.count > longestStringLength) {\n         \
    \   longestString = str\n            longestStringLength = str.count\n       \
    \ }\n    }\n    return longestString\n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(longest(strings: [] as [String]) == nil)\nassert(longest(strings: [\"x\"\
    , \"y\", \"z\"]) == \"x\")\nassert(longest(strings: [\"x\", \"yyy\", \"zzzz\"\
    , \"www\", \"kkkk\", \"abc\"]) == \"zzzz\")"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660013860
- exit_code: 0
  program: "\n/// Out of array of strings, return the longest one. Return the first\
    \ one in case of multiple\n/// strings of the same length. Return nil in case\
    \ the input array is empty.\n/// >>> longest(strings: [] as [String])\n/// nil\n\
    /// >>> longest(strings: [\"a\", \"b\", \"c\"])\n/// \"a\"\n/// >>> longest(strings:\
    \ [\"a\", \"bb\", \"ccc\"])\n/// \"ccc\"\nfunc longest(strings: [String]) -> String?\
    \ {\n    return strings.reduce(nil) { (memo, element) in\n        if memo == nil\
    \ {\n            return element\n        } else if memo!.count < element.count\
    \ {\n            return element\n        } else {\n            return memo\n \
    \       }\n    }\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool\
    \ {\n    if left.count != right.count {\n        return false\n    }\n    for\
    \ (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(longest(strings: []\
    \ as [String]) == nil)\nassert(longest(strings: [\"x\", \"y\", \"z\"]) == \"x\"\
    )\nassert(longest(strings: [\"x\", \"yyy\", \"zzzz\", \"www\", \"kkkk\", \"abc\"\
    ]) == \"zzzz\")"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660013860
- exit_code: 0
  program: "\n/// Out of array of strings, return the longest one. Return the first\
    \ one in case of multiple\n/// strings of the same length. Return nil in case\
    \ the input array is empty.\n/// >>> longest(strings: [] as [String])\n/// nil\n\
    /// >>> longest(strings: [\"a\", \"b\", \"c\"])\n/// \"a\"\n/// >>> longest(strings:\
    \ [\"a\", \"bb\", \"ccc\"])\n/// \"ccc\"\nfunc longest(strings: [String]) -> String?\
    \ {\n    guard let first = strings.first else { return nil }\n    return strings.reduce(first)\
    \ { $1.count > $0.count ? $1 : $0 }\n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(longest(strings: [] as [String]) == nil)\nassert(longest(strings: [\"x\"\
    , \"y\", \"z\"]) == \"x\")\nassert(longest(strings: [\"x\", \"yyy\", \"zzzz\"\
    , \"www\", \"kkkk\", \"abc\"]) == \"zzzz\")"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660013739
- exit_code: -4
  program: "\n/// Out of array of strings, return the longest one. Return the first\
    \ one in case of multiple\n/// strings of the same length. Return nil in case\
    \ the input array is empty.\n/// >>> longest(strings: [] as [String])\n/// nil\n\
    /// >>> longest(strings: [\"a\", \"b\", \"c\"])\n/// \"a\"\n/// >>> longest(strings:\
    \ [\"a\", \"bb\", \"ccc\"])\n/// \"ccc\"\nfunc longest(strings: [String]) -> String?\
    \ {\n    return nil\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) ->\
    \ Bool {\n    if left.count != right.count {\n        return false\n    }\n  \
    \  for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(longest(strings: []\
    \ as [String]) == nil)\nassert(longest(strings: [\"x\", \"y\", \"z\"]) == \"x\"\
    )\nassert(longest(strings: [\"x\", \"yyy\", \"zzzz\", \"www\", \"kkkk\", \"abc\"\
    ]) == \"zzzz\")"
  status: Exception
  stderr: 'tmp8uuaa7yn/tmp8uuaa7yn.swift:28: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b29a4e1ac80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b29a4b11b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b29a4b11988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b29a4b107b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmp8uuaa7yn                        0x00005612f3a6879a <unavailable> + 6042

    5    libc.so.6                          0x00002b29a5006460 __libc_start_main +
    245

    6    tmp8uuaa7yn                        0x00005612f3a68089 <unavailable> + 4233

    '
  stdout: ''
  timestamp: 1660013739
- exit_code: 1
  program: "\n/// Out of array of strings, return the longest one. Return the first\
    \ one in case of multiple\n/// strings of the same length. Return nil in case\
    \ the input array is empty.\n/// >>> longest(strings: [] as [String])\n/// nil\n\
    /// >>> longest(strings: [\"a\", \"b\", \"c\"])\n/// \"a\"\n/// >>> longest(strings:\
    \ [\"a\", \"bb\", \"ccc\"])\n/// \"ccc\"\nfunc longest(strings: [String]) -> String?\
    \ {\n  var result: String? = nil\n  for str in strings {\n    if result == nil\
    \ || str.characters.count > result!.characters.count {\n      result = str\n \
    \   }\n  }\n  return result\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int,\
    \ Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n\
    \    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n          \
    \  return false\n        }\n    }\n    return true\n}\n            \nassert(longest(strings:\
    \ [] as [String]) == nil)\nassert(longest(strings: [\"x\", \"y\", \"z\"]) == \"\
    x\")\nassert(longest(strings: [\"x\", \"yyy\", \"zzzz\", \"www\", \"kkkk\", \"\
    abc\"]) == \"zzzz\")"
  status: SyntaxError
  stderr: "/tmp/tmp9di88myb.swift:13:29: error: 'characters' is unavailable: Please\
    \ use String directly\n    if result == nil || str.characters.count > result!.characters.count\
    \ {\n                            ^~~~~~~~~~\nSwift.String:5:16: note: 'characters'\
    \ was obsoleted in Swift 5.0\n    public var characters: String { get set }\n\
    \               ^\n/tmp/tmp9di88myb.swift:13:56: error: 'characters' is unavailable:\
    \ Please use String directly\n    if result == nil || str.characters.count > result!.characters.count\
    \ {\n                                                       ^~~~~~~~~~\nSwift.String:5:16:\
    \ note: 'characters' was obsoleted in Swift 5.0\n    public var characters: String\
    \ { get set }\n               ^\n"
  stdout: ''
  timestamp: 1660013860
- exit_code: 0
  program: "\n/// Out of array of strings, return the longest one. Return the first\
    \ one in case of multiple\n/// strings of the same length. Return nil in case\
    \ the input array is empty.\n/// >>> longest(strings: [] as [String])\n/// nil\n\
    /// >>> longest(strings: [\"a\", \"b\", \"c\"])\n/// \"a\"\n/// >>> longest(strings:\
    \ [\"a\", \"bb\", \"ccc\"])\n/// \"ccc\"\nfunc longest(strings: [String]) -> String?\
    \ {\n    guard let longest = strings.max(by: { $0.count < $1.count }) else {\n\
    \        return nil\n    }\n    return longest\n}\n\n\nfunc ==(left: [(Int, Int)],\
    \ right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n       \
    \ return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r\
    \ {\n            return false\n        }\n    }\n    return true\n}\n        \
    \    \nassert(longest(strings: [] as [String]) == nil)\nassert(longest(strings:\
    \ [\"x\", \"y\", \"z\"]) == \"x\")\nassert(longest(strings: [\"x\", \"yyy\", \"\
    zzzz\", \"www\", \"kkkk\", \"abc\"]) == \"zzzz\")"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660013860
- exit_code: 0
  program: "\n/// Out of array of strings, return the longest one. Return the first\
    \ one in case of multiple\n/// strings of the same length. Return nil in case\
    \ the input array is empty.\n/// >>> longest(strings: [] as [String])\n/// nil\n\
    /// >>> longest(strings: [\"a\", \"b\", \"c\"])\n/// \"a\"\n/// >>> longest(strings:\
    \ [\"a\", \"bb\", \"ccc\"])\n/// \"ccc\"\nfunc longest(strings: [String]) -> String?\
    \ {\n    guard !strings.isEmpty else { return nil }\n    return strings.reduce(strings[0])\
    \ { (current, next) in\n        return current.count >= next.count ? current :\
    \ next\n    }\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool\
    \ {\n    if left.count != right.count {\n        return false\n    }\n    for\
    \ (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(longest(strings: []\
    \ as [String]) == nil)\nassert(longest(strings: [\"x\", \"y\", \"z\"]) == \"x\"\
    )\nassert(longest(strings: [\"x\", \"yyy\", \"zzzz\", \"www\", \"kkkk\", \"abc\"\
    ]) == \"zzzz\")"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660013860
- exit_code: 1
  program: "\n/// Out of array of strings, return the longest one. Return the first\
    \ one in case of multiple\n/// strings of the same length. Return nil in case\
    \ the input array is empty.\n/// >>> longest(strings: [] as [String])\n/// nil\n\
    /// >>> longest(strings: [\"a\", \"b\", \"c\"])\n/// \"a\"\n/// >>> longest(strings:\
    \ [\"a\", \"bb\", \"ccc\"])\n/// \"ccc\"\nfunc longest(strings: [String]) -> String?\
    \ {\n    var longestString: String?\n    for s in strings {\n        if let l\
    \ = longestString {\n            if l.characters.count < s.characters.count {\n\
    \                longestString = s\n            }\n        } else {\n        \
    \    longestString = s\n        }\n    }\n    return longestString\n}\n\n\nfunc\
    \ ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count !=\
    \ right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(longest(strings: [] as [String]) == nil)\nassert(longest(strings:\
    \ [\"x\", \"y\", \"z\"]) == \"x\")\nassert(longest(strings: [\"x\", \"yyy\", \"\
    zzzz\", \"www\", \"kkkk\", \"abc\"]) == \"zzzz\")"
  status: SyntaxError
  stderr: "/tmp/tmpxwde1f7c.swift:14:18: error: 'characters' is unavailable: Please\
    \ use String directly\n            if l.characters.count < s.characters.count\
    \ {\n                 ^~~~~~~~~~\nSwift.String:5:16: note: 'characters' was obsoleted\
    \ in Swift 5.0\n    public var characters: String { get set }\n              \
    \ ^\n/tmp/tmpxwde1f7c.swift:14:39: error: 'characters' is unavailable: Please\
    \ use String directly\n            if l.characters.count < s.characters.count\
    \ {\n                                      ^~~~~~~~~~\nSwift.String:5:16: note:\
    \ 'characters' was obsoleted in Swift 5.0\n    public var characters: String {\
    \ get set }\n               ^\n"
  stdout: ''
  timestamp: 1660013860
- exit_code: 0
  program: "\n/// Out of array of strings, return the longest one. Return the first\
    \ one in case of multiple\n/// strings of the same length. Return nil in case\
    \ the input array is empty.\n/// >>> longest(strings: [] as [String])\n/// nil\n\
    /// >>> longest(strings: [\"a\", \"b\", \"c\"])\n/// \"a\"\n/// >>> longest(strings:\
    \ [\"a\", \"bb\", \"ccc\"])\n/// \"ccc\"\nfunc longest(strings: [String]) -> String?\
    \ {\n    guard !strings.isEmpty else { return nil }\n    var longestString = strings[0]\n\
    \    var longestStringLength = longestString.count\n    for string in strings[1..<strings.count]\
    \ {\n        if string.count > longestStringLength {\n            longestString\
    \ = string\n            longestStringLength = string.count\n        }\n    }\n\
    \    return longestString\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(longest(strings:\
    \ [] as [String]) == nil)\nassert(longest(strings: [\"x\", \"y\", \"z\"]) == \"\
    x\")\nassert(longest(strings: [\"x\", \"yyy\", \"zzzz\", \"www\", \"kkkk\", \"\
    abc\"]) == \"zzzz\")"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660013860
- exit_code: 0
  program: "\n/// Out of array of strings, return the longest one. Return the first\
    \ one in case of multiple\n/// strings of the same length. Return nil in case\
    \ the input array is empty.\n/// >>> longest(strings: [] as [String])\n/// nil\n\
    /// >>> longest(strings: [\"a\", \"b\", \"c\"])\n/// \"a\"\n/// >>> longest(strings:\
    \ [\"a\", \"bb\", \"ccc\"])\n/// \"ccc\"\nfunc longest(strings: [String]) -> String?\
    \ {\n    guard strings.count > 0 else {\n        return nil\n    }\n    var result\
    \ = strings[0]\n    for s in strings {\n        if s.count > result.count {\n\
    \            result = s\n        }\n    }\n    return result\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(longest(strings: [] as [String]) == nil)\nassert(longest(strings:\
    \ [\"x\", \"y\", \"z\"]) == \"x\")\nassert(longest(strings: [\"x\", \"yyy\", \"\
    zzzz\", \"www\", \"kkkk\", \"abc\"]) == \"zzzz\")"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660013860
- exit_code: 1
  program: "\n/// Out of array of strings, return the longest one. Return the first\
    \ one in case of multiple\n/// strings of the same length. Return nil in case\
    \ the input array is empty.\n/// >>> longest(strings: [] as [String])\n/// nil\n\
    /// >>> longest(strings: [\"a\", \"b\", \"c\"])\n/// \"a\"\n/// >>> longest(strings:\
    \ [\"a\", \"bb\", \"ccc\"])\n/// \"ccc\"\nfunc longest(strings: [String]) -> String?\
    \ {\n    var longest_string: String? = nil\n    var longest_length = 0\n    for\
    \ string in strings {\n        if longest_length < string.characters.count {\n\
    \            longest_length = string.characters.count\n            longest_string\
    \ = string\n        }\n    }\n    return longest_string\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(longest(strings: [] as [String]) == nil)\nassert(longest(strings:\
    \ [\"x\", \"y\", \"z\"]) == \"x\")\nassert(longest(strings: [\"x\", \"yyy\", \"\
    zzzz\", \"www\", \"kkkk\", \"abc\"]) == \"zzzz\")"
  status: SyntaxError
  stderr: "/tmp/tmpik95i_86.swift:14:36: error: 'characters' is unavailable: Please\
    \ use String directly\n        if longest_length < string.characters.count {\n\
    \                                   ^~~~~~~~~~\nSwift.String:5:16: note: 'characters'\
    \ was obsoleted in Swift 5.0\n    public var characters: String { get set }\n\
    \               ^\n/tmp/tmpik95i_86.swift:15:37: error: 'characters' is unavailable:\
    \ Please use String directly\n            longest_length = string.characters.count\n\
    \                                    ^~~~~~~~~~\nSwift.String:5:16: note: 'characters'\
    \ was obsoleted in Swift 5.0\n    public var characters: String { get set }\n\
    \               ^\n"
  stdout: ''
  timestamp: 1660013860
- exit_code: -4
  program: "\n/// Out of array of strings, return the longest one. Return the first\
    \ one in case of multiple\n/// strings of the same length. Return nil in case\
    \ the input array is empty.\n/// >>> longest(strings: [] as [String])\n/// nil\n\
    /// >>> longest(strings: [\"a\", \"b\", \"c\"])\n/// \"a\"\n/// >>> longest(strings:\
    \ [\"a\", \"bb\", \"ccc\"])\n/// \"ccc\"\nfunc longest(strings: [String]) -> String?\
    \ {\n    // TODO: implement this\n    return nil\n}\n\n\nfunc ==(left: [(Int,\
    \ Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n\
    \        return false\n    }\n    for (l, r) in zip(left, right) {\n        if\
    \ l != r {\n            return false\n        }\n    }\n    return true\n}\n \
    \           \nassert(longest(strings: [] as [String]) == nil)\nassert(longest(strings:\
    \ [\"x\", \"y\", \"z\"]) == \"x\")\nassert(longest(strings: [\"x\", \"yyy\", \"\
    zzzz\", \"www\", \"kkkk\", \"abc\"]) == \"zzzz\")"
  status: Exception
  stderr: 'tmpee9q1911/tmpee9q1911.swift:29: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002ae1d3c62c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002ae1d3959b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002ae1d3959988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002ae1d39587b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpee9q1911                        0x00005626df8c079a <unavailable> + 6042

    5    libc.so.6                          0x00002ae1d3e4e460 __libc_start_main +
    245

    6    tmpee9q1911                        0x00005626df8c0089 <unavailable> + 4233

    '
  stdout: ''
  timestamp: 1660013860
- exit_code: 1
  program: "\n/// Out of array of strings, return the longest one. Return the first\
    \ one in case of multiple\n/// strings of the same length. Return nil in case\
    \ the input array is empty.\n/// >>> longest(strings: [] as [String])\n/// nil\n\
    /// >>> longest(strings: [\"a\", \"b\", \"c\"])\n/// \"a\"\n/// >>> longest(strings:\
    \ [\"a\", \"bb\", \"ccc\"])\n/// \"ccc\"\nfunc longest(strings: [String]) -> String?\
    \ {\n    if strings.isEmpty {\n        return nil\n    }\n    var longest: String\
    \ = strings[0]\n    for string in strings {\n        if string.characters.count\
    \ > longest.characters.count {\n            longest = string\n        }\n    }\n\
    \    return longest\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) ->\
    \ Bool {\n    if left.count != right.count {\n        return false\n    }\n  \
    \  for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(longest(strings: []\
    \ as [String]) == nil)\nassert(longest(strings: [\"x\", \"y\", \"z\"]) == \"x\"\
    )\nassert(longest(strings: [\"x\", \"yyy\", \"zzzz\", \"www\", \"kkkk\", \"abc\"\
    ]) == \"zzzz\")"
  status: SyntaxError
  stderr: "/tmp/tmp6j0rzd_0.swift:16:19: error: 'characters' is unavailable: Please\
    \ use String directly\n        if string.characters.count > longest.characters.count\
    \ {\n                  ^~~~~~~~~~\nSwift.String:5:16: note: 'characters' was obsoleted\
    \ in Swift 5.0\n    public var characters: String { get set }\n              \
    \ ^\n/tmp/tmp6j0rzd_0.swift:16:46: error: 'characters' is unavailable: Please\
    \ use String directly\n        if string.characters.count > longest.characters.count\
    \ {\n                                             ^~~~~~~~~~\nSwift.String:5:16:\
    \ note: 'characters' was obsoleted in Swift 5.0\n    public var characters: String\
    \ { get set }\n               ^\n"
  stdout: ''
  timestamp: 1660013860
- exit_code: 0
  program: "\n/// Out of array of strings, return the longest one. Return the first\
    \ one in case of multiple\n/// strings of the same length. Return nil in case\
    \ the input array is empty.\n/// >>> longest(strings: [] as [String])\n/// nil\n\
    /// >>> longest(strings: [\"a\", \"b\", \"c\"])\n/// \"a\"\n/// >>> longest(strings:\
    \ [\"a\", \"bb\", \"ccc\"])\n/// \"ccc\"\nfunc longest(strings: [String]) -> String?\
    \ {\n    return strings.sorted { $0.count > $1.count }.first\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(longest(strings: [] as [String]) == nil)\nassert(longest(strings:\
    \ [\"x\", \"y\", \"z\"]) == \"x\")\nassert(longest(strings: [\"x\", \"yyy\", \"\
    zzzz\", \"www\", \"kkkk\", \"abc\"]) == \"zzzz\")"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660013739
- exit_code: 0
  program: "\n/// Out of array of strings, return the longest one. Return the first\
    \ one in case of multiple\n/// strings of the same length. Return nil in case\
    \ the input array is empty.\n/// >>> longest(strings: [] as [String])\n/// nil\n\
    /// >>> longest(strings: [\"a\", \"b\", \"c\"])\n/// \"a\"\n/// >>> longest(strings:\
    \ [\"a\", \"bb\", \"ccc\"])\n/// \"ccc\"\nfunc longest(strings: [String]) -> String?\
    \ {\n    if strings.isEmpty {\n        return nil\n    }\n    var longest = strings[0]\n\
    \    for str in strings {\n        if str.count > longest.count {\n          \
    \  longest = str\n        }\n    }\n    return longest\n}\n\n\nfunc ==(left: [(Int,\
    \ Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n\
    \        return false\n    }\n    for (l, r) in zip(left, right) {\n        if\
    \ l != r {\n            return false\n        }\n    }\n    return true\n}\n \
    \           \nassert(longest(strings: [] as [String]) == nil)\nassert(longest(strings:\
    \ [\"x\", \"y\", \"z\"]) == \"x\")\nassert(longest(strings: [\"x\", \"yyy\", \"\
    zzzz\", \"www\", \"kkkk\", \"abc\"]) == \"zzzz\")"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660013860
- exit_code: -4
  program: "\n/// Out of array of strings, return the longest one. Return the first\
    \ one in case of multiple\n/// strings of the same length. Return nil in case\
    \ the input array is empty.\n/// >>> longest(strings: [] as [String])\n/// nil\n\
    /// >>> longest(strings: [\"a\", \"b\", \"c\"])\n/// \"a\"\n/// >>> longest(strings:\
    \ [\"a\", \"bb\", \"ccc\"])\n/// \"ccc\"\nfunc longest(strings: [String]) -> String?\
    \ {\n    return strings.max()\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int,\
    \ Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n\
    \    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n          \
    \  return false\n        }\n    }\n    return true\n}\n            \nassert(longest(strings:\
    \ [] as [String]) == nil)\nassert(longest(strings: [\"x\", \"y\", \"z\"]) == \"\
    x\")\nassert(longest(strings: [\"x\", \"yyy\", \"zzzz\", \"www\", \"kkkk\", \"\
    abc\"]) == \"zzzz\")"
  status: Exception
  stderr: 'tmp71jrbmvf/tmp71jrbmvf.swift:28: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002ad69d142c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002ad69ce39b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002ad69ce39988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002ad69ce387b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmp71jrbmvf                        0x00005616aa89f83a <unavailable> + 6202

    5    libc.so.6                          0x00002ad69d32e460 __libc_start_main +
    245

    6    tmp71jrbmvf                        0x00005616aa89f129 <unavailable> + 4393

    '
  stdout: ''
  timestamp: 1660013860
- exit_code: 0
  program: "\n/// Out of array of strings, return the longest one. Return the first\
    \ one in case of multiple\n/// strings of the same length. Return nil in case\
    \ the input array is empty.\n/// >>> longest(strings: [] as [String])\n/// nil\n\
    /// >>> longest(strings: [\"a\", \"b\", \"c\"])\n/// \"a\"\n/// >>> longest(strings:\
    \ [\"a\", \"bb\", \"ccc\"])\n/// \"ccc\"\nfunc longest(strings: [String]) -> String?\
    \ {\n    if strings.isEmpty {\n        return nil\n    }\n    var longestWord\
    \ = strings[0]\n    for word in strings {\n        if word.count > longestWord.count\
    \ {\n            longestWord = word\n        }\n    }\n    return longestWord\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(longest(strings: [] as [String]) == nil)\nassert(longest(strings:\
    \ [\"x\", \"y\", \"z\"]) == \"x\")\nassert(longest(strings: [\"x\", \"yyy\", \"\
    zzzz\", \"www\", \"kkkk\", \"abc\"]) == \"zzzz\")"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660013860
- exit_code: 0
  program: "\n/// Out of array of strings, return the longest one. Return the first\
    \ one in case of multiple\n/// strings of the same length. Return nil in case\
    \ the input array is empty.\n/// >>> longest(strings: [] as [String])\n/// nil\n\
    /// >>> longest(strings: [\"a\", \"b\", \"c\"])\n/// \"a\"\n/// >>> longest(strings:\
    \ [\"a\", \"bb\", \"ccc\"])\n/// \"ccc\"\nfunc longest(strings: [String]) -> String?\
    \ {\n    guard !strings.isEmpty else { return nil }\n    var longest: String =\
    \ strings[0]\n    for string in strings {\n        if string.count > longest.count\
    \ {\n            longest = string\n        }\n    }\n    return longest\n}\n\n\
    \nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(longest(strings: [] as [String]) == nil)\nassert(longest(strings:\
    \ [\"x\", \"y\", \"z\"]) == \"x\")\nassert(longest(strings: [\"x\", \"yyy\", \"\
    zzzz\", \"www\", \"kkkk\", \"abc\"]) == \"zzzz\")"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660013860
- exit_code: 0
  program: "\n/// Out of array of strings, return the longest one. Return the first\
    \ one in case of multiple\n/// strings of the same length. Return nil in case\
    \ the input array is empty.\n/// >>> longest(strings: [] as [String])\n/// nil\n\
    /// >>> longest(strings: [\"a\", \"b\", \"c\"])\n/// \"a\"\n/// >>> longest(strings:\
    \ [\"a\", \"bb\", \"ccc\"])\n/// \"ccc\"\nfunc longest(strings: [String]) -> String?\
    \ {\n    guard !strings.isEmpty else { return nil }\n    var result = strings[0]\n\
    \    for s in strings[1...] {\n        if s.count > result.count {\n         \
    \   result = s\n        }\n    }\n    return result\n}\n\n\nfunc ==(left: [(Int,\
    \ Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n\
    \        return false\n    }\n    for (l, r) in zip(left, right) {\n        if\
    \ l != r {\n            return false\n        }\n    }\n    return true\n}\n \
    \           \nassert(longest(strings: [] as [String]) == nil)\nassert(longest(strings:\
    \ [\"x\", \"y\", \"z\"]) == \"x\")\nassert(longest(strings: [\"x\", \"yyy\", \"\
    zzzz\", \"www\", \"kkkk\", \"abc\"]) == \"zzzz\")"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660013860
- exit_code: -4
  program: "\n/// Out of array of strings, return the longest one. Return the first\
    \ one in case of multiple\n/// strings of the same length. Return nil in case\
    \ the input array is empty.\n/// >>> longest(strings: [] as [String])\n/// nil\n\
    /// >>> longest(strings: [\"a\", \"b\", \"c\"])\n/// \"a\"\n/// >>> longest(strings:\
    \ [\"a\", \"bb\", \"ccc\"])\n/// \"ccc\"\nfunc longest(strings: [String]) -> String?\
    \ {\n    // TODO: Write implementation here\n    return nil\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(longest(strings: [] as [String]) == nil)\nassert(longest(strings:\
    \ [\"x\", \"y\", \"z\"]) == \"x\")\nassert(longest(strings: [\"x\", \"yyy\", \"\
    zzzz\", \"www\", \"kkkk\", \"abc\"]) == \"zzzz\")"
  status: Exception
  stderr: 'tmp5ri7v98i/tmp5ri7v98i.swift:29: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b9ab4e7ac80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b9ab4b71b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b9ab4b71988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b9ab4b707b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmp5ri7v98i                        0x00005596c9aee79a <unavailable> + 6042

    5    libc.so.6                          0x00002b9ab5066460 __libc_start_main +
    245

    6    tmp5ri7v98i                        0x00005596c9aee089 <unavailable> + 4233

    '
  stdout: ''
  timestamp: 1660013860
- exit_code: -4
  program: "\n/// Out of array of strings, return the longest one. Return the first\
    \ one in case of multiple\n/// strings of the same length. Return nil in case\
    \ the input array is empty.\n/// >>> longest(strings: [] as [String])\n/// nil\n\
    /// >>> longest(strings: [\"a\", \"b\", \"c\"])\n/// \"a\"\n/// >>> longest(strings:\
    \ [\"a\", \"bb\", \"ccc\"])\n/// \"ccc\"\nfunc longest(strings: [String]) -> String?\
    \ {\n    return nil\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) ->\
    \ Bool {\n    if left.count != right.count {\n        return false\n    }\n  \
    \  for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(longest(strings: []\
    \ as [String]) == nil)\nassert(longest(strings: [\"x\", \"y\", \"z\"]) == \"x\"\
    )\nassert(longest(strings: [\"x\", \"yyy\", \"zzzz\", \"www\", \"kkkk\", \"abc\"\
    ]) == \"zzzz\")"
  status: Exception
  stderr: 'tmp8uuaa7yn/tmp8uuaa7yn.swift:28: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b29a4e1ac80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b29a4b11b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b29a4b11988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b29a4b107b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmp8uuaa7yn                        0x00005612f3a6879a <unavailable> + 6042

    5    libc.so.6                          0x00002b29a5006460 __libc_start_main +
    245

    6    tmp8uuaa7yn                        0x00005612f3a68089 <unavailable> + 4233

    '
  stdout: ''
  timestamp: 1660013739
- exit_code: -4
  program: "\n/// Out of array of strings, return the longest one. Return the first\
    \ one in case of multiple\n/// strings of the same length. Return nil in case\
    \ the input array is empty.\n/// >>> longest(strings: [] as [String])\n/// nil\n\
    /// >>> longest(strings: [\"a\", \"b\", \"c\"])\n/// \"a\"\n/// >>> longest(strings:\
    \ [\"a\", \"bb\", \"ccc\"])\n/// \"ccc\"\nfunc longest(strings: [String]) -> String?\
    \ {\n    var count = 0\n    var str = \"\"\n    for string in strings {\n    \
    \    if string.count > count {\n            count = string.count\n           \
    \ str = string\n        }\n    }\n    return str\n}\n\n\nfunc ==(left: [(Int,\
    \ Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n\
    \        return false\n    }\n    for (l, r) in zip(left, right) {\n        if\
    \ l != r {\n            return false\n        }\n    }\n    return true\n}\n \
    \           \nassert(longest(strings: [] as [String]) == nil)\nassert(longest(strings:\
    \ [\"x\", \"y\", \"z\"]) == \"x\")\nassert(longest(strings: [\"x\", \"yyy\", \"\
    zzzz\", \"www\", \"kkkk\", \"abc\"]) == \"zzzz\")"
  status: Exception
  stderr: 'tmptffvc0o5/tmptffvc0o5.swift:35: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b291d4cac80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b291d1c1b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b291d1c1988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b291d1c07b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmptffvc0o5                        0x0000561822b9f628 <unavailable> + 5672

    5    libc.so.6                          0x00002b291d6b6460 __libc_start_main +
    245

    6    tmptffvc0o5                        0x0000561822b9f249 <unavailable> + 4681

    '
  stdout: ''
  timestamp: 1660013860
- exit_code: 0
  program: "\n/// Out of array of strings, return the longest one. Return the first\
    \ one in case of multiple\n/// strings of the same length. Return nil in case\
    \ the input array is empty.\n/// >>> longest(strings: [] as [String])\n/// nil\n\
    /// >>> longest(strings: [\"a\", \"b\", \"c\"])\n/// \"a\"\n/// >>> longest(strings:\
    \ [\"a\", \"bb\", \"ccc\"])\n/// \"ccc\"\nfunc longest(strings: [String]) -> String?\
    \ {\n    var longestString: String?\n    for string in strings {\n        if longestString\
    \ == nil || string.count > longestString!.count {\n            longestString =\
    \ string\n        }\n    }\n    return longestString\n}\n\n\nfunc ==(left: [(Int,\
    \ Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n\
    \        return false\n    }\n    for (l, r) in zip(left, right) {\n        if\
    \ l != r {\n            return false\n        }\n    }\n    return true\n}\n \
    \           \nassert(longest(strings: [] as [String]) == nil)\nassert(longest(strings:\
    \ [\"x\", \"y\", \"z\"]) == \"x\")\nassert(longest(strings: [\"x\", \"yyy\", \"\
    zzzz\", \"www\", \"kkkk\", \"abc\"]) == \"zzzz\")"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660013739
- exit_code: 0
  program: "\n/// Out of array of strings, return the longest one. Return the first\
    \ one in case of multiple\n/// strings of the same length. Return nil in case\
    \ the input array is empty.\n/// >>> longest(strings: [] as [String])\n/// nil\n\
    /// >>> longest(strings: [\"a\", \"b\", \"c\"])\n/// \"a\"\n/// >>> longest(strings:\
    \ [\"a\", \"bb\", \"ccc\"])\n/// \"ccc\"\nfunc longest(strings: [String]) -> String?\
    \ {\n    if strings.isEmpty {\n        return nil\n    }\n    return strings.reduce(strings[0])\
    \ { $1.count > $0.count ? $1 : $0 }\n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(longest(strings: [] as [String]) == nil)\nassert(longest(strings: [\"x\"\
    , \"y\", \"z\"]) == \"x\")\nassert(longest(strings: [\"x\", \"yyy\", \"zzzz\"\
    , \"www\", \"kkkk\", \"abc\"]) == \"zzzz\")"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660013860
- exit_code: -4
  program: "\n/// Out of array of strings, return the longest one. Return the first\
    \ one in case of multiple\n/// strings of the same length. Return nil in case\
    \ the input array is empty.\n/// >>> longest(strings: [] as [String])\n/// nil\n\
    /// >>> longest(strings: [\"a\", \"b\", \"c\"])\n/// \"a\"\n/// >>> longest(strings:\
    \ [\"a\", \"bb\", \"ccc\"])\n/// \"ccc\"\nfunc longest(strings: [String]) -> String?\
    \ {\n    return nil\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) ->\
    \ Bool {\n    if left.count != right.count {\n        return false\n    }\n  \
    \  for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(longest(strings: []\
    \ as [String]) == nil)\nassert(longest(strings: [\"x\", \"y\", \"z\"]) == \"x\"\
    )\nassert(longest(strings: [\"x\", \"yyy\", \"zzzz\", \"www\", \"kkkk\", \"abc\"\
    ]) == \"zzzz\")"
  status: Exception
  stderr: 'tmp8uuaa7yn/tmp8uuaa7yn.swift:28: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b29a4e1ac80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b29a4b11b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b29a4b11988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b29a4b107b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmp8uuaa7yn                        0x00005612f3a6879a <unavailable> + 6042

    5    libc.so.6                          0x00002b29a5006460 __libc_start_main +
    245

    6    tmp8uuaa7yn                        0x00005612f3a68089 <unavailable> + 4233

    '
  stdout: ''
  timestamp: 1660013739
- exit_code: 0
  program: "\n/// Out of array of strings, return the longest one. Return the first\
    \ one in case of multiple\n/// strings of the same length. Return nil in case\
    \ the input array is empty.\n/// >>> longest(strings: [] as [String])\n/// nil\n\
    /// >>> longest(strings: [\"a\", \"b\", \"c\"])\n/// \"a\"\n/// >>> longest(strings:\
    \ [\"a\", \"bb\", \"ccc\"])\n/// \"ccc\"\nfunc longest(strings: [String]) -> String?\
    \ {\n    if strings.isEmpty {\n        return nil\n    }\n    var longestString\
    \ = strings[0]\n    for string in strings[1...] {\n        if string.count > longestString.count\
    \ {\n            longestString = string\n        }\n    }\n    return longestString\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(longest(strings: [] as [String]) == nil)\nassert(longest(strings:\
    \ [\"x\", \"y\", \"z\"]) == \"x\")\nassert(longest(strings: [\"x\", \"yyy\", \"\
    zzzz\", \"www\", \"kkkk\", \"abc\"]) == \"zzzz\")"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660013860
- exit_code: -4
  program: "\n/// Out of array of strings, return the longest one. Return the first\
    \ one in case of multiple\n/// strings of the same length. Return nil in case\
    \ the input array is empty.\n/// >>> longest(strings: [] as [String])\n/// nil\n\
    /// >>> longest(strings: [\"a\", \"b\", \"c\"])\n/// \"a\"\n/// >>> longest(strings:\
    \ [\"a\", \"bb\", \"ccc\"])\n/// \"ccc\"\nfunc longest(strings: [String]) -> String?\
    \ {\n    return nil\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) ->\
    \ Bool {\n    if left.count != right.count {\n        return false\n    }\n  \
    \  for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(longest(strings: []\
    \ as [String]) == nil)\nassert(longest(strings: [\"x\", \"y\", \"z\"]) == \"x\"\
    )\nassert(longest(strings: [\"x\", \"yyy\", \"zzzz\", \"www\", \"kkkk\", \"abc\"\
    ]) == \"zzzz\")"
  status: Exception
  stderr: 'tmp8uuaa7yn/tmp8uuaa7yn.swift:28: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b29a4e1ac80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b29a4b11b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b29a4b11988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b29a4b107b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmp8uuaa7yn                        0x00005612f3a6879a <unavailable> + 6042

    5    libc.so.6                          0x00002b29a5006460 __libc_start_main +
    245

    6    tmp8uuaa7yn                        0x00005612f3a68089 <unavailable> + 4233

    '
  stdout: ''
  timestamp: 1660013739
- exit_code: 0
  program: "\n/// Out of array of strings, return the longest one. Return the first\
    \ one in case of multiple\n/// strings of the same length. Return nil in case\
    \ the input array is empty.\n/// >>> longest(strings: [] as [String])\n/// nil\n\
    /// >>> longest(strings: [\"a\", \"b\", \"c\"])\n/// \"a\"\n/// >>> longest(strings:\
    \ [\"a\", \"bb\", \"ccc\"])\n/// \"ccc\"\nfunc longest(strings: [String]) -> String?\
    \ {\n    if strings.isEmpty {\n        return nil\n    }\n    var longestString\
    \ = strings[0]\n    for string in strings {\n        if string.count > longestString.count\
    \ {\n            longestString = string\n        }\n    }\n    return longestString\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(longest(strings: [] as [String]) == nil)\nassert(longest(strings:\
    \ [\"x\", \"y\", \"z\"]) == \"x\")\nassert(longest(strings: [\"x\", \"yyy\", \"\
    zzzz\", \"www\", \"kkkk\", \"abc\"]) == \"zzzz\")"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660013739
- exit_code: -4
  program: "\n/// Out of array of strings, return the longest one. Return the first\
    \ one in case of multiple\n/// strings of the same length. Return nil in case\
    \ the input array is empty.\n/// >>> longest(strings: [] as [String])\n/// nil\n\
    /// >>> longest(strings: [\"a\", \"b\", \"c\"])\n/// \"a\"\n/// >>> longest(strings:\
    \ [\"a\", \"bb\", \"ccc\"])\n/// \"ccc\"\nfunc longest(strings: [String]) -> String?\
    \ {\n    return nil\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) ->\
    \ Bool {\n    if left.count != right.count {\n        return false\n    }\n  \
    \  for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(longest(strings: []\
    \ as [String]) == nil)\nassert(longest(strings: [\"x\", \"y\", \"z\"]) == \"x\"\
    )\nassert(longest(strings: [\"x\", \"yyy\", \"zzzz\", \"www\", \"kkkk\", \"abc\"\
    ]) == \"zzzz\")"
  status: Exception
  stderr: 'tmp8uuaa7yn/tmp8uuaa7yn.swift:28: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b29a4e1ac80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b29a4b11b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b29a4b11988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b29a4b107b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmp8uuaa7yn                        0x00005612f3a6879a <unavailable> + 6042

    5    libc.so.6                          0x00002b29a5006460 __libc_start_main +
    245

    6    tmp8uuaa7yn                        0x00005612f3a68089 <unavailable> + 4233

    '
  stdout: ''
  timestamp: 1660013739
- exit_code: -4
  program: "\n/// Out of array of strings, return the longest one. Return the first\
    \ one in case of multiple\n/// strings of the same length. Return nil in case\
    \ the input array is empty.\n/// >>> longest(strings: [] as [String])\n/// nil\n\
    /// >>> longest(strings: [\"a\", \"b\", \"c\"])\n/// \"a\"\n/// >>> longest(strings:\
    \ [\"a\", \"bb\", \"ccc\"])\n/// \"ccc\"\nfunc longest(strings: [String]) -> String?\
    \ {\n    guard let first = strings.first else { return nil }\n    return strings.reduce(first)\
    \ { current, next in\n        current.count > next.count ? current : next\n  \
    \  }\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if\
    \ left.count != right.count {\n        return false\n    }\n    for (l, r) in\
    \ zip(left, right) {\n        if l != r {\n            return false\n        }\n\
    \    }\n    return true\n}\n            \nassert(longest(strings: [] as [String])\
    \ == nil)\nassert(longest(strings: [\"x\", \"y\", \"z\"]) == \"x\")\nassert(longest(strings:\
    \ [\"x\", \"yyy\", \"zzzz\", \"www\", \"kkkk\", \"abc\"]) == \"zzzz\")"
  status: Exception
  stderr: 'tmp05d1j1yo/tmp05d1j1yo.swift:31: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b9788f13c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b9788c0ab6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b9788c0a988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b9788c097b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmp05d1j1yo                        0x0000563caf04c8fa <unavailable> + 6394

    5    libc.so.6                          0x00002b97890ff460 __libc_start_main +
    245

    6    tmp05d1j1yo                        0x0000563caf04c1e9 <unavailable> + 4585

    '
  stdout: ''
  timestamp: 1660013860
- exit_code: 0
  program: "\n/// Out of array of strings, return the longest one. Return the first\
    \ one in case of multiple\n/// strings of the same length. Return nil in case\
    \ the input array is empty.\n/// >>> longest(strings: [] as [String])\n/// nil\n\
    /// >>> longest(strings: [\"a\", \"b\", \"c\"])\n/// \"a\"\n/// >>> longest(strings:\
    \ [\"a\", \"bb\", \"ccc\"])\n/// \"ccc\"\nfunc longest(strings: [String]) -> String?\
    \ {\n    if strings.isEmpty {\n        return nil\n    }\n    var longest = strings[0]\n\
    \    for string in strings {\n        if string.count > longest.count {\n    \
    \        longest = string\n        }\n    }\n    return longest\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(longest(strings: [] as [String]) == nil)\nassert(longest(strings:\
    \ [\"x\", \"y\", \"z\"]) == \"x\")\nassert(longest(strings: [\"x\", \"yyy\", \"\
    zzzz\", \"www\", \"kkkk\", \"abc\"]) == \"zzzz\")"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660013739
- exit_code: 0
  program: "\n/// Out of array of strings, return the longest one. Return the first\
    \ one in case of multiple\n/// strings of the same length. Return nil in case\
    \ the input array is empty.\n/// >>> longest(strings: [] as [String])\n/// nil\n\
    /// >>> longest(strings: [\"a\", \"b\", \"c\"])\n/// \"a\"\n/// >>> longest(strings:\
    \ [\"a\", \"bb\", \"ccc\"])\n/// \"ccc\"\nfunc longest(strings: [String]) -> String?\
    \ {\n    var maxString: String? = nil\n    for s in strings {\n        if maxString\
    \ == nil || s.count > maxString!.count {\n            maxString = s\n        }\n\
    \    }\n    return maxString\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int,\
    \ Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n\
    \    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n          \
    \  return false\n        }\n    }\n    return true\n}\n            \nassert(longest(strings:\
    \ [] as [String]) == nil)\nassert(longest(strings: [\"x\", \"y\", \"z\"]) == \"\
    x\")\nassert(longest(strings: [\"x\", \"yyy\", \"zzzz\", \"www\", \"kkkk\", \"\
    abc\"]) == \"zzzz\")"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660013860
- exit_code: -4
  program: "\n/// Out of array of strings, return the longest one. Return the first\
    \ one in case of multiple\n/// strings of the same length. Return nil in case\
    \ the input array is empty.\n/// >>> longest(strings: [] as [String])\n/// nil\n\
    /// >>> longest(strings: [\"a\", \"b\", \"c\"])\n/// \"a\"\n/// >>> longest(strings:\
    \ [\"a\", \"bb\", \"ccc\"])\n/// \"ccc\"\nfunc longest(strings: [String]) -> String?\
    \ {\n    return nil\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) ->\
    \ Bool {\n    if left.count != right.count {\n        return false\n    }\n  \
    \  for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(longest(strings: []\
    \ as [String]) == nil)\nassert(longest(strings: [\"x\", \"y\", \"z\"]) == \"x\"\
    )\nassert(longest(strings: [\"x\", \"yyy\", \"zzzz\", \"www\", \"kkkk\", \"abc\"\
    ]) == \"zzzz\")"
  status: Exception
  stderr: 'tmp8uuaa7yn/tmp8uuaa7yn.swift:28: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b29a4e1ac80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b29a4b11b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b29a4b11988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b29a4b107b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmp8uuaa7yn                        0x00005612f3a6879a <unavailable> + 6042

    5    libc.so.6                          0x00002b29a5006460 __libc_start_main +
    245

    6    tmp8uuaa7yn                        0x00005612f3a68089 <unavailable> + 4233

    '
  stdout: ''
  timestamp: 1660013739
- exit_code: 0
  program: "\n/// Out of array of strings, return the longest one. Return the first\
    \ one in case of multiple\n/// strings of the same length. Return nil in case\
    \ the input array is empty.\n/// >>> longest(strings: [] as [String])\n/// nil\n\
    /// >>> longest(strings: [\"a\", \"b\", \"c\"])\n/// \"a\"\n/// >>> longest(strings:\
    \ [\"a\", \"bb\", \"ccc\"])\n/// \"ccc\"\nfunc longest(strings: [String]) -> String?\
    \ {\n    if strings.isEmpty {\n        return nil\n    }\n    var index = 0\n\
    \    var longest = strings[0]\n    for i in 1..<strings.count {\n        if strings[i].count\
    \ > longest.count {\n            index = i\n            longest = strings[i]\n\
    \        }\n    }\n    return longest\n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(longest(strings: [] as [String]) == nil)\nassert(longest(strings: [\"x\"\
    , \"y\", \"z\"]) == \"x\")\nassert(longest(strings: [\"x\", \"yyy\", \"zzzz\"\
    , \"www\", \"kkkk\", \"abc\"]) == \"zzzz\")"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660013860
- exit_code: 1
  program: "\n/// Out of array of strings, return the longest one. Return the first\
    \ one in case of multiple\n/// strings of the same length. Return nil in case\
    \ the input array is empty.\n/// >>> longest(strings: [] as [String])\n/// nil\n\
    /// >>> longest(strings: [\"a\", \"b\", \"c\"])\n/// \"a\"\n/// >>> longest(strings:\
    \ [\"a\", \"bb\", \"ccc\"])\n/// \"ccc\"\nfunc longest(strings: [String]) -> String?\
    \ {\n    var longest: String? = nil\n    for string in strings {\n        if longest\
    \ == nil || longest!.characters.count < string.characters.count {\n          \
    \  longest = string\n        }\n    }\n    return longest\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(longest(strings: [] as [String]) == nil)\nassert(longest(strings:\
    \ [\"x\", \"y\", \"z\"]) == \"x\")\nassert(longest(strings: [\"x\", \"yyy\", \"\
    zzzz\", \"www\", \"kkkk\", \"abc\"]) == \"zzzz\")"
  status: SyntaxError
  stderr: "/tmp/tmpedbdsn97.swift:13:39: error: 'characters' is unavailable: Please\
    \ use String directly\n        if longest == nil || longest!.characters.count\
    \ < string.characters.count {\n                                      ^~~~~~~~~~\n\
    Swift.String:5:16: note: 'characters' was obsoleted in Swift 5.0\n    public var\
    \ characters: String { get set }\n               ^\n/tmp/tmpedbdsn97.swift:13:65:\
    \ error: 'characters' is unavailable: Please use String directly\n        if longest\
    \ == nil || longest!.characters.count < string.characters.count {\n          \
    \                                                      ^~~~~~~~~~\nSwift.String:5:16:\
    \ note: 'characters' was obsoleted in Swift 5.0\n    public var characters: String\
    \ { get set }\n               ^\n"
  stdout: ''
  timestamp: 1660013860
- exit_code: 1
  program: "\n/// Out of array of strings, return the longest one. Return the first\
    \ one in case of multiple\n/// strings of the same length. Return nil in case\
    \ the input array is empty.\n/// >>> longest(strings: [] as [String])\n/// nil\n\
    /// >>> longest(strings: [\"a\", \"b\", \"c\"])\n/// \"a\"\n/// >>> longest(strings:\
    \ [\"a\", \"bb\", \"ccc\"])\n/// \"ccc\"\nfunc longest(strings: [String]) -> String?\
    \ {\n    if strings.isEmpty {\n        return nil\n    }\n    else {\n       \
    \ var longest = strings[0]\n        for str in strings {\n            if str.characters.count\
    \ > longest.characters.count {\n                longest = str\n            }\n\
    \        }\n        return longest\n    }\n}\n\n\nfunc ==(left: [(Int, Int)],\
    \ right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n       \
    \ return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r\
    \ {\n            return false\n        }\n    }\n    return true\n}\n        \
    \    \nassert(longest(strings: [] as [String]) == nil)\nassert(longest(strings:\
    \ [\"x\", \"y\", \"z\"]) == \"x\")\nassert(longest(strings: [\"x\", \"yyy\", \"\
    zzzz\", \"www\", \"kkkk\", \"abc\"]) == \"zzzz\")"
  status: SyntaxError
  stderr: "/tmp/tmpt_t7iqzl.swift:17:20: error: 'characters' is unavailable: Please\
    \ use String directly\n            if str.characters.count > longest.characters.count\
    \ {\n                   ^~~~~~~~~~\nSwift.String:5:16: note: 'characters' was\
    \ obsoleted in Swift 5.0\n    public var characters: String { get set }\n    \
    \           ^\n/tmp/tmpt_t7iqzl.swift:17:47: error: 'characters' is unavailable:\
    \ Please use String directly\n            if str.characters.count > longest.characters.count\
    \ {\n                                              ^~~~~~~~~~\nSwift.String:5:16:\
    \ note: 'characters' was obsoleted in Swift 5.0\n    public var characters: String\
    \ { get set }\n               ^\n"
  stdout: ''
  timestamp: 1660013860
- exit_code: 0
  program: "\n/// Out of array of strings, return the longest one. Return the first\
    \ one in case of multiple\n/// strings of the same length. Return nil in case\
    \ the input array is empty.\n/// >>> longest(strings: [] as [String])\n/// nil\n\
    /// >>> longest(strings: [\"a\", \"b\", \"c\"])\n/// \"a\"\n/// >>> longest(strings:\
    \ [\"a\", \"bb\", \"ccc\"])\n/// \"ccc\"\nfunc longest(strings: [String]) -> String?\
    \ {\n    var longest: String? = nil\n    for string in strings {\n        if longest\
    \ == nil || longest!.count < string.count {\n            longest = string\n  \
    \      }\n    }\n    return longest\n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(longest(strings: [] as [String]) == nil)\nassert(longest(strings: [\"x\"\
    , \"y\", \"z\"]) == \"x\")\nassert(longest(strings: [\"x\", \"yyy\", \"zzzz\"\
    , \"www\", \"kkkk\", \"abc\"]) == \"zzzz\")"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660013860
- exit_code: 0
  program: "\n/// Out of array of strings, return the longest one. Return the first\
    \ one in case of multiple\n/// strings of the same length. Return nil in case\
    \ the input array is empty.\n/// >>> longest(strings: [] as [String])\n/// nil\n\
    /// >>> longest(strings: [\"a\", \"b\", \"c\"])\n/// \"a\"\n/// >>> longest(strings:\
    \ [\"a\", \"bb\", \"ccc\"])\n/// \"ccc\"\nfunc longest(strings: [String]) -> String?\
    \ {\n    guard !strings.isEmpty else { return nil }\n    var result = strings[0]\n\
    \    for i in 1..<strings.count {\n        let s = strings[i]\n        if s.count\
    \ > result.count {\n            result = s\n        }\n    }\n    return result\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(longest(strings: [] as [String]) == nil)\nassert(longest(strings:\
    \ [\"x\", \"y\", \"z\"]) == \"x\")\nassert(longest(strings: [\"x\", \"yyy\", \"\
    zzzz\", \"www\", \"kkkk\", \"abc\"]) == \"zzzz\")"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660013860
- exit_code: 0
  program: "\n/// Out of array of strings, return the longest one. Return the first\
    \ one in case of multiple\n/// strings of the same length. Return nil in case\
    \ the input array is empty.\n/// >>> longest(strings: [] as [String])\n/// nil\n\
    /// >>> longest(strings: [\"a\", \"b\", \"c\"])\n/// \"a\"\n/// >>> longest(strings:\
    \ [\"a\", \"bb\", \"ccc\"])\n/// \"ccc\"\nfunc longest(strings: [String]) -> String?\
    \ {\n    if strings.isEmpty {\n        return nil\n    }\n    return strings.max(by:\
    \ {\n        $0.count < $1.count\n    })\n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(longest(strings: [] as [String]) == nil)\nassert(longest(strings: [\"x\"\
    , \"y\", \"z\"]) == \"x\")\nassert(longest(strings: [\"x\", \"yyy\", \"zzzz\"\
    , \"www\", \"kkkk\", \"abc\"]) == \"zzzz\")"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660013860
- exit_code: -4
  program: "\n/// Out of array of strings, return the longest one. Return the first\
    \ one in case of multiple\n/// strings of the same length. Return nil in case\
    \ the input array is empty.\n/// >>> longest(strings: [] as [String])\n/// nil\n\
    /// >>> longest(strings: [\"a\", \"b\", \"c\"])\n/// \"a\"\n/// >>> longest(strings:\
    \ [\"a\", \"bb\", \"ccc\"])\n/// \"ccc\"\nfunc longest(strings: [String]) -> String?\
    \ {\n    // TODO\n    var count = 0\n    var longestString = \"\"\n    for string\
    \ in strings {\n        if string.count > count {\n            count = string.count\n\
    \            longestString = string\n        }\n    }\n    return longestString\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(longest(strings: [] as [String]) == nil)\nassert(longest(strings:\
    \ [\"x\", \"y\", \"z\"]) == \"x\")\nassert(longest(strings: [\"x\", \"yyy\", \"\
    zzzz\", \"www\", \"kkkk\", \"abc\"]) == \"zzzz\")"
  status: Exception
  stderr: 'tmps0qcm6tn/tmps0qcm6tn.swift:36: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b0608519c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b0608210b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b0608210988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b060820f7b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmps0qcm6tn                        0x0000556573874628 <unavailable> + 5672

    5    libc.so.6                          0x00002b0608705460 __libc_start_main +
    245

    6    tmps0qcm6tn                        0x0000556573874249 <unavailable> + 4681

    '
  stdout: ''
  timestamp: 1660013860
- exit_code: -4
  program: "\n/// Out of array of strings, return the longest one. Return the first\
    \ one in case of multiple\n/// strings of the same length. Return nil in case\
    \ the input array is empty.\n/// >>> longest(strings: [] as [String])\n/// nil\n\
    /// >>> longest(strings: [\"a\", \"b\", \"c\"])\n/// \"a\"\n/// >>> longest(strings:\
    \ [\"a\", \"bb\", \"ccc\"])\n/// \"ccc\"\nfunc longest(strings: [String]) -> String?\
    \ {\n    // your code here\n    return nil\n}\n\n\nfunc ==(left: [(Int, Int)],\
    \ right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n       \
    \ return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r\
    \ {\n            return false\n        }\n    }\n    return true\n}\n        \
    \    \nassert(longest(strings: [] as [String]) == nil)\nassert(longest(strings:\
    \ [\"x\", \"y\", \"z\"]) == \"x\")\nassert(longest(strings: [\"x\", \"yyy\", \"\
    zzzz\", \"www\", \"kkkk\", \"abc\"]) == \"zzzz\")"
  status: Exception
  stderr: 'tmpichr3o33/tmpichr3o33.swift:29: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002adbe2f13c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002adbe2c0ab6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002adbe2c0a988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002adbe2c097b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpichr3o33                        0x00005639055d679a <unavailable> + 6042

    5    libc.so.6                          0x00002adbe30ff460 __libc_start_main +
    245

    6    tmpichr3o33                        0x00005639055d6089 <unavailable> + 4233

    '
  stdout: ''
  timestamp: 1660013860
- exit_code: 0
  program: "\n/// Out of array of strings, return the longest one. Return the first\
    \ one in case of multiple\n/// strings of the same length. Return nil in case\
    \ the input array is empty.\n/// >>> longest(strings: [] as [String])\n/// nil\n\
    /// >>> longest(strings: [\"a\", \"b\", \"c\"])\n/// \"a\"\n/// >>> longest(strings:\
    \ [\"a\", \"bb\", \"ccc\"])\n/// \"ccc\"\nfunc longest(strings: [String]) -> String?\
    \ {\n    var longestString: String?\n    for string in strings {\n        if longestString\
    \ == nil || string.count > longestString!.count {\n            longestString =\
    \ string\n        }\n    }\n    return longestString\n}\n\n\nfunc ==(left: [(Int,\
    \ Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n\
    \        return false\n    }\n    for (l, r) in zip(left, right) {\n        if\
    \ l != r {\n            return false\n        }\n    }\n    return true\n}\n \
    \           \nassert(longest(strings: [] as [String]) == nil)\nassert(longest(strings:\
    \ [\"x\", \"y\", \"z\"]) == \"x\")\nassert(longest(strings: [\"x\", \"yyy\", \"\
    zzzz\", \"www\", \"kkkk\", \"abc\"]) == \"zzzz\")"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660013739
- exit_code: 0
  program: "\n/// Out of array of strings, return the longest one. Return the first\
    \ one in case of multiple\n/// strings of the same length. Return nil in case\
    \ the input array is empty.\n/// >>> longest(strings: [] as [String])\n/// nil\n\
    /// >>> longest(strings: [\"a\", \"b\", \"c\"])\n/// \"a\"\n/// >>> longest(strings:\
    \ [\"a\", \"bb\", \"ccc\"])\n/// \"ccc\"\nfunc longest(strings: [String]) -> String?\
    \ {\n    guard !strings.isEmpty else { return nil }\n    var result = strings[0]\n\
    \    for string in strings {\n        if string.count > result.count {\n     \
    \       result = string\n        }\n    }\n    return result\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(longest(strings: [] as [String]) == nil)\nassert(longest(strings:\
    \ [\"x\", \"y\", \"z\"]) == \"x\")\nassert(longest(strings: [\"x\", \"yyy\", \"\
    zzzz\", \"www\", \"kkkk\", \"abc\"]) == \"zzzz\")"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660013860
- exit_code: 0
  program: "\n/// Out of array of strings, return the longest one. Return the first\
    \ one in case of multiple\n/// strings of the same length. Return nil in case\
    \ the input array is empty.\n/// >>> longest(strings: [] as [String])\n/// nil\n\
    /// >>> longest(strings: [\"a\", \"b\", \"c\"])\n/// \"a\"\n/// >>> longest(strings:\
    \ [\"a\", \"bb\", \"ccc\"])\n/// \"ccc\"\nfunc longest(strings: [String]) -> String?\
    \ {\n    guard !strings.isEmpty else { return nil }\n    return strings.reduce(strings[0])\
    \ { $1.count > $0.count ? $1 : $0 }\n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(longest(strings: [] as [String]) == nil)\nassert(longest(strings: [\"x\"\
    , \"y\", \"z\"]) == \"x\")\nassert(longest(strings: [\"x\", \"yyy\", \"zzzz\"\
    , \"www\", \"kkkk\", \"abc\"]) == \"zzzz\")"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660013739
- exit_code: 1
  program: "\n/// Out of array of strings, return the longest one. Return the first\
    \ one in case of multiple\n/// strings of the same length. Return nil in case\
    \ the input array is empty.\n/// >>> longest(strings: [] as [String])\n/// nil\n\
    /// >>> longest(strings: [\"a\", \"b\", \"c\"])\n/// \"a\"\n/// >>> longest(strings:\
    \ [\"a\", \"bb\", \"ccc\"])\n/// \"ccc\"\nfunc longest(strings: [String]) -> String?\
    \ {\n    return strings.max { (lhs, rhs) -> Bool in\n        lhs.characters.count\
    \ < rhs.characters.count\n    }\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int,\
    \ Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n\
    \    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n          \
    \  return false\n        }\n    }\n    return true\n}\n            \nassert(longest(strings:\
    \ [] as [String]) == nil)\nassert(longest(strings: [\"x\", \"y\", \"z\"]) == \"\
    x\")\nassert(longest(strings: [\"x\", \"yyy\", \"zzzz\", \"www\", \"kkkk\", \"\
    abc\"]) == \"zzzz\")"
  status: SyntaxError
  stderr: "/tmp/tmp0gxy9kvf.swift:12:13: error: 'characters' is unavailable: Please\
    \ use String directly\n        lhs.characters.count < rhs.characters.count\n \
    \           ^~~~~~~~~~\nSwift.String:5:16: note: 'characters' was obsoleted in\
    \ Swift 5.0\n    public var characters: String { get set }\n               ^\n\
    /tmp/tmp0gxy9kvf.swift:12:36: error: 'characters' is unavailable: Please use String\
    \ directly\n        lhs.characters.count < rhs.characters.count\n            \
    \                       ^~~~~~~~~~\nSwift.String:5:16: note: 'characters' was\
    \ obsoleted in Swift 5.0\n    public var characters: String { get set }\n    \
    \           ^\n"
  stdout: ''
  timestamp: 1660013860
- exit_code: -4
  program: "\n/// Out of array of strings, return the longest one. Return the first\
    \ one in case of multiple\n/// strings of the same length. Return nil in case\
    \ the input array is empty.\n/// >>> longest(strings: [] as [String])\n/// nil\n\
    /// >>> longest(strings: [\"a\", \"b\", \"c\"])\n/// \"a\"\n/// >>> longest(strings:\
    \ [\"a\", \"bb\", \"ccc\"])\n/// \"ccc\"\nfunc longest(strings: [String]) -> String?\
    \ {\n    // Implement function here\n    return nil\n}\n\n\nfunc ==(left: [(Int,\
    \ Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n\
    \        return false\n    }\n    for (l, r) in zip(left, right) {\n        if\
    \ l != r {\n            return false\n        }\n    }\n    return true\n}\n \
    \           \nassert(longest(strings: [] as [String]) == nil)\nassert(longest(strings:\
    \ [\"x\", \"y\", \"z\"]) == \"x\")\nassert(longest(strings: [\"x\", \"yyy\", \"\
    zzzz\", \"www\", \"kkkk\", \"abc\"]) == \"zzzz\")"
  status: Exception
  stderr: 'tmp0png9nq0/tmp0png9nq0.swift:29: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b2b9f307c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b2b9effeb6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b2b9effe988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b2b9effd7b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmp0png9nq0                        0x0000558294b0779a <unavailable> + 6042

    5    libc.so.6                          0x00002b2b9f4f3460 __libc_start_main +
    245

    6    tmp0png9nq0                        0x0000558294b07089 <unavailable> + 4233

    '
  stdout: ''
  timestamp: 1660013860
- exit_code: 0
  program: "\n/// Out of array of strings, return the longest one. Return the first\
    \ one in case of multiple\n/// strings of the same length. Return nil in case\
    \ the input array is empty.\n/// >>> longest(strings: [] as [String])\n/// nil\n\
    /// >>> longest(strings: [\"a\", \"b\", \"c\"])\n/// \"a\"\n/// >>> longest(strings:\
    \ [\"a\", \"bb\", \"ccc\"])\n/// \"ccc\"\nfunc longest(strings: [String]) -> String?\
    \ {\n    return strings.max(by: { $0.count < $1.count })\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(longest(strings: [] as [String]) == nil)\nassert(longest(strings:\
    \ [\"x\", \"y\", \"z\"]) == \"x\")\nassert(longest(strings: [\"x\", \"yyy\", \"\
    zzzz\", \"www\", \"kkkk\", \"abc\"]) == \"zzzz\")"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660013739
- exit_code: 1
  program: "\n/// Out of array of strings, return the longest one. Return the first\
    \ one in case of multiple\n/// strings of the same length. Return nil in case\
    \ the input array is empty.\n/// >>> longest(strings: [] as [String])\n/// nil\n\
    /// >>> longest(strings: [\"a\", \"b\", \"c\"])\n/// \"a\"\n/// >>> longest(strings:\
    \ [\"a\", \"bb\", \"ccc\"])\n/// \"ccc\"\nfunc longest(strings: [String]) -> String?\
    \ {\n    var longest: String? = nil\n    var length = 0\n    for s in strings\
    \ {\n        if s.characters.count > length {\n            length = s.characters.count\n\
    \            longest = s\n        }\n    }\n    return longest\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(longest(strings: [] as [String]) == nil)\nassert(longest(strings:\
    \ [\"x\", \"y\", \"z\"]) == \"x\")\nassert(longest(strings: [\"x\", \"yyy\", \"\
    zzzz\", \"www\", \"kkkk\", \"abc\"]) == \"zzzz\")"
  status: SyntaxError
  stderr: "/tmp/tmpzkgjbrz3.swift:14:14: error: 'characters' is unavailable: Please\
    \ use String directly\n        if s.characters.count > length {\n            \
    \ ^~~~~~~~~~\nSwift.String:5:16: note: 'characters' was obsoleted in Swift 5.0\n\
    \    public var characters: String { get set }\n               ^\n/tmp/tmpzkgjbrz3.swift:15:24:\
    \ error: 'characters' is unavailable: Please use String directly\n           \
    \ length = s.characters.count\n                       ^~~~~~~~~~\nSwift.String:5:16:\
    \ note: 'characters' was obsoleted in Swift 5.0\n    public var characters: String\
    \ { get set }\n               ^\n"
  stdout: ''
  timestamp: 1660013860
- exit_code: 0
  program: "\n/// Out of array of strings, return the longest one. Return the first\
    \ one in case of multiple\n/// strings of the same length. Return nil in case\
    \ the input array is empty.\n/// >>> longest(strings: [] as [String])\n/// nil\n\
    /// >>> longest(strings: [\"a\", \"b\", \"c\"])\n/// \"a\"\n/// >>> longest(strings:\
    \ [\"a\", \"bb\", \"ccc\"])\n/// \"ccc\"\nfunc longest(strings: [String]) -> String?\
    \ {\n    guard strings.count > 0 else {\n        return nil\n    }\n    var longestString\
    \ = strings[0]\n    for str in strings {\n        if str.count > longestString.count\
    \ {\n            longestString = str\n        }\n    }\n    return longestString\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(longest(strings: [] as [String]) == nil)\nassert(longest(strings:\
    \ [\"x\", \"y\", \"z\"]) == \"x\")\nassert(longest(strings: [\"x\", \"yyy\", \"\
    zzzz\", \"www\", \"kkkk\", \"abc\"]) == \"zzzz\")"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660013860
- exit_code: -4
  program: "\n/// Out of array of strings, return the longest one. Return the first\
    \ one in case of multiple\n/// strings of the same length. Return nil in case\
    \ the input array is empty.\n/// >>> longest(strings: [] as [String])\n/// nil\n\
    /// >>> longest(strings: [\"a\", \"b\", \"c\"])\n/// \"a\"\n/// >>> longest(strings:\
    \ [\"a\", \"bb\", \"ccc\"])\n/// \"ccc\"\nfunc longest(strings: [String]) -> String?\
    \ {\n    // TODO: implement me\n    return nil\n}\n\n\nfunc ==(left: [(Int, Int)],\
    \ right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n       \
    \ return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r\
    \ {\n            return false\n        }\n    }\n    return true\n}\n        \
    \    \nassert(longest(strings: [] as [String]) == nil)\nassert(longest(strings:\
    \ [\"x\", \"y\", \"z\"]) == \"x\")\nassert(longest(strings: [\"x\", \"yyy\", \"\
    zzzz\", \"www\", \"kkkk\", \"abc\"]) == \"zzzz\")"
  status: Exception
  stderr: 'tmp4m8p45_q/tmp4m8p45_q.swift:29: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b07a3b78c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b07a386fb6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b07a386f988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b07a386e7b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmp4m8p45_q                        0x000056289941c79a <unavailable> + 6042

    5    libc.so.6                          0x00002b07a3d64460 __libc_start_main +
    245

    6    tmp4m8p45_q                        0x000056289941c089 <unavailable> + 4233

    '
  stdout: ''
  timestamp: 1660013860
- exit_code: 0
  program: "\n/// Out of array of strings, return the longest one. Return the first\
    \ one in case of multiple\n/// strings of the same length. Return nil in case\
    \ the input array is empty.\n/// >>> longest(strings: [] as [String])\n/// nil\n\
    /// >>> longest(strings: [\"a\", \"b\", \"c\"])\n/// \"a\"\n/// >>> longest(strings:\
    \ [\"a\", \"bb\", \"ccc\"])\n/// \"ccc\"\nfunc longest(strings: [String]) -> String?\
    \ {\n    if strings.isEmpty {\n        return nil\n    }\n    var maxLength =\
    \ 0\n    var longestString = \"\"\n    for string in strings {\n        if string.count\
    \ > maxLength {\n            maxLength = string.count\n            longestString\
    \ = string\n        }\n    }\n    return longestString\n}\n\n\nfunc ==(left: [(Int,\
    \ Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n\
    \        return false\n    }\n    for (l, r) in zip(left, right) {\n        if\
    \ l != r {\n            return false\n        }\n    }\n    return true\n}\n \
    \           \nassert(longest(strings: [] as [String]) == nil)\nassert(longest(strings:\
    \ [\"x\", \"y\", \"z\"]) == \"x\")\nassert(longest(strings: [\"x\", \"yyy\", \"\
    zzzz\", \"www\", \"kkkk\", \"abc\"]) == \"zzzz\")"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660013861
- exit_code: 0
  program: "\n/// Out of array of strings, return the longest one. Return the first\
    \ one in case of multiple\n/// strings of the same length. Return nil in case\
    \ the input array is empty.\n/// >>> longest(strings: [] as [String])\n/// nil\n\
    /// >>> longest(strings: [\"a\", \"b\", \"c\"])\n/// \"a\"\n/// >>> longest(strings:\
    \ [\"a\", \"bb\", \"ccc\"])\n/// \"ccc\"\nfunc longest(strings: [String]) -> String?\
    \ {\n    if strings.isEmpty {\n        return nil\n    }\n    var longestString\
    \ = strings[0]\n    for string in strings {\n        if string.count > longestString.count\
    \ {\n            longestString = string\n        }\n    }\n    return longestString\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(longest(strings: [] as [String]) == nil)\nassert(longest(strings:\
    \ [\"x\", \"y\", \"z\"]) == \"x\")\nassert(longest(strings: [\"x\", \"yyy\", \"\
    zzzz\", \"www\", \"kkkk\", \"abc\"]) == \"zzzz\")"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660013739
- exit_code: 0
  program: "\n/// Out of array of strings, return the longest one. Return the first\
    \ one in case of multiple\n/// strings of the same length. Return nil in case\
    \ the input array is empty.\n/// >>> longest(strings: [] as [String])\n/// nil\n\
    /// >>> longest(strings: [\"a\", \"b\", \"c\"])\n/// \"a\"\n/// >>> longest(strings:\
    \ [\"a\", \"bb\", \"ccc\"])\n/// \"ccc\"\nfunc longest(strings: [String]) -> String?\
    \ {\n    if strings.isEmpty {\n        return nil\n    }\n    return strings.reduce(strings[0])\
    \ {\n        (longest, string) in\n        return string.count > longest.count\
    \ ? string : longest\n    }\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int,\
    \ Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n\
    \    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n          \
    \  return false\n        }\n    }\n    return true\n}\n            \nassert(longest(strings:\
    \ [] as [String]) == nil)\nassert(longest(strings: [\"x\", \"y\", \"z\"]) == \"\
    x\")\nassert(longest(strings: [\"x\", \"yyy\", \"zzzz\", \"www\", \"kkkk\", \"\
    abc\"]) == \"zzzz\")"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660013861
- exit_code: 1
  program: "\n/// Out of array of strings, return the longest one. Return the first\
    \ one in case of multiple\n/// strings of the same length. Return nil in case\
    \ the input array is empty.\n/// >>> longest(strings: [] as [String])\n/// nil\n\
    /// >>> longest(strings: [\"a\", \"b\", \"c\"])\n/// \"a\"\n/// >>> longest(strings:\
    \ [\"a\", \"bb\", \"ccc\"])\n/// \"ccc\"\nfunc longest(strings: [String]) -> String?\
    \ {\n    if strings.isEmpty {\n        return nil\n    }\n    var maxLen = 0\n\
    \    var maxLenIndex = 0\n    for i in 0..<strings.count {\n        if strings[i].characters.count\
    \ > maxLen {\n            maxLen = strings[i].characters.count\n            maxLenIndex\
    \ = i\n        }\n    }\n    return strings[maxLenIndex]\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(longest(strings: [] as [String]) == nil)\nassert(longest(strings:\
    \ [\"x\", \"y\", \"z\"]) == \"x\")\nassert(longest(strings: [\"x\", \"yyy\", \"\
    zzzz\", \"www\", \"kkkk\", \"abc\"]) == \"zzzz\")"
  status: SyntaxError
  stderr: "/tmp/tmp8wdh7w0f.swift:17:23: error: 'characters' is unavailable: Please\
    \ use String directly\n        if strings[i].characters.count > maxLen {\n   \
    \                   ^~~~~~~~~~\nSwift.String:5:16: note: 'characters' was obsoleted\
    \ in Swift 5.0\n    public var characters: String { get set }\n              \
    \ ^\n/tmp/tmp8wdh7w0f.swift:18:33: error: 'characters' is unavailable: Please\
    \ use String directly\n            maxLen = strings[i].characters.count\n    \
    \                            ^~~~~~~~~~\nSwift.String:5:16: note: 'characters'\
    \ was obsoleted in Swift 5.0\n    public var characters: String { get set }\n\
    \               ^\n"
  stdout: ''
  timestamp: 1660013860
- exit_code: -4
  program: "\n/// Out of array of strings, return the longest one. Return the first\
    \ one in case of multiple\n/// strings of the same length. Return nil in case\
    \ the input array is empty.\n/// >>> longest(strings: [] as [String])\n/// nil\n\
    /// >>> longest(strings: [\"a\", \"b\", \"c\"])\n/// \"a\"\n/// >>> longest(strings:\
    \ [\"a\", \"bb\", \"ccc\"])\n/// \"ccc\"\nfunc longest(strings: [String]) -> String?\
    \ {\n    return nil\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) ->\
    \ Bool {\n    if left.count != right.count {\n        return false\n    }\n  \
    \  for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(longest(strings: []\
    \ as [String]) == nil)\nassert(longest(strings: [\"x\", \"y\", \"z\"]) == \"x\"\
    )\nassert(longest(strings: [\"x\", \"yyy\", \"zzzz\", \"www\", \"kkkk\", \"abc\"\
    ]) == \"zzzz\")"
  status: Exception
  stderr: 'tmp8uuaa7yn/tmp8uuaa7yn.swift:28: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b29a4e1ac80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b29a4b11b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b29a4b11988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b29a4b107b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmp8uuaa7yn                        0x00005612f3a6879a <unavailable> + 6042

    5    libc.so.6                          0x00002b29a5006460 __libc_start_main +
    245

    6    tmp8uuaa7yn                        0x00005612f3a68089 <unavailable> + 4233

    '
  stdout: ''
  timestamp: 1660013739
- exit_code: 0
  program: "\n/// Out of array of strings, return the longest one. Return the first\
    \ one in case of multiple\n/// strings of the same length. Return nil in case\
    \ the input array is empty.\n/// >>> longest(strings: [] as [String])\n/// nil\n\
    /// >>> longest(strings: [\"a\", \"b\", \"c\"])\n/// \"a\"\n/// >>> longest(strings:\
    \ [\"a\", \"bb\", \"ccc\"])\n/// \"ccc\"\nfunc longest(strings: [String]) -> String?\
    \ {\n    if strings.isEmpty {\n        return nil\n    }\n    var longestString\
    \ = strings[0]\n    for string in strings {\n        if string.count > longestString.count\
    \ {\n            longestString = string\n        }\n    }\n    return longestString\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(longest(strings: [] as [String]) == nil)\nassert(longest(strings:\
    \ [\"x\", \"y\", \"z\"]) == \"x\")\nassert(longest(strings: [\"x\", \"yyy\", \"\
    zzzz\", \"www\", \"kkkk\", \"abc\"]) == \"zzzz\")"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660013739
- exit_code: -4
  program: "\n/// Out of array of strings, return the longest one. Return the first\
    \ one in case of multiple\n/// strings of the same length. Return nil in case\
    \ the input array is empty.\n/// >>> longest(strings: [] as [String])\n/// nil\n\
    /// >>> longest(strings: [\"a\", \"b\", \"c\"])\n/// \"a\"\n/// >>> longest(strings:\
    \ [\"a\", \"bb\", \"ccc\"])\n/// \"ccc\"\nfunc longest(strings: [String]) -> String?\
    \ {\n    return nil\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) ->\
    \ Bool {\n    if left.count != right.count {\n        return false\n    }\n  \
    \  for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(longest(strings: []\
    \ as [String]) == nil)\nassert(longest(strings: [\"x\", \"y\", \"z\"]) == \"x\"\
    )\nassert(longest(strings: [\"x\", \"yyy\", \"zzzz\", \"www\", \"kkkk\", \"abc\"\
    ]) == \"zzzz\")"
  status: Exception
  stderr: 'tmp8uuaa7yn/tmp8uuaa7yn.swift:28: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b29a4e1ac80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b29a4b11b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b29a4b11988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b29a4b107b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmp8uuaa7yn                        0x00005612f3a6879a <unavailable> + 6042

    5    libc.so.6                          0x00002b29a5006460 __libc_start_main +
    245

    6    tmp8uuaa7yn                        0x00005612f3a68089 <unavailable> + 4233

    '
  stdout: ''
  timestamp: 1660013739
- exit_code: 0
  program: "\n/// Out of array of strings, return the longest one. Return the first\
    \ one in case of multiple\n/// strings of the same length. Return nil in case\
    \ the input array is empty.\n/// >>> longest(strings: [] as [String])\n/// nil\n\
    /// >>> longest(strings: [\"a\", \"b\", \"c\"])\n/// \"a\"\n/// >>> longest(strings:\
    \ [\"a\", \"bb\", \"ccc\"])\n/// \"ccc\"\nfunc longest(strings: [String]) -> String?\
    \ {\n    return strings.sorted { $0.count > $1.count }.first\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(longest(strings: [] as [String]) == nil)\nassert(longest(strings:\
    \ [\"x\", \"y\", \"z\"]) == \"x\")\nassert(longest(strings: [\"x\", \"yyy\", \"\
    zzzz\", \"www\", \"kkkk\", \"abc\"]) == \"zzzz\")"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660013739
- exit_code: 0
  program: "\n/// Out of array of strings, return the longest one. Return the first\
    \ one in case of multiple\n/// strings of the same length. Return nil in case\
    \ the input array is empty.\n/// >>> longest(strings: [] as [String])\n/// nil\n\
    /// >>> longest(strings: [\"a\", \"b\", \"c\"])\n/// \"a\"\n/// >>> longest(strings:\
    \ [\"a\", \"bb\", \"ccc\"])\n/// \"ccc\"\nfunc longest(strings: [String]) -> String?\
    \ {\n    guard strings.count > 0 else {\n        return nil\n    }\n    return\
    \ strings.max { (lhs, rhs) -> Bool in\n        return lhs.count < rhs.count\n\
    \    }\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n  \
    \  if left.count != right.count {\n        return false\n    }\n    for (l, r)\
    \ in zip(left, right) {\n        if l != r {\n            return false\n     \
    \   }\n    }\n    return true\n}\n            \nassert(longest(strings: [] as\
    \ [String]) == nil)\nassert(longest(strings: [\"x\", \"y\", \"z\"]) == \"x\")\n\
    assert(longest(strings: [\"x\", \"yyy\", \"zzzz\", \"www\", \"kkkk\", \"abc\"\
    ]) == \"zzzz\")"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660013861
- exit_code: 0
  program: "\n/// Out of array of strings, return the longest one. Return the first\
    \ one in case of multiple\n/// strings of the same length. Return nil in case\
    \ the input array is empty.\n/// >>> longest(strings: [] as [String])\n/// nil\n\
    /// >>> longest(strings: [\"a\", \"b\", \"c\"])\n/// \"a\"\n/// >>> longest(strings:\
    \ [\"a\", \"bb\", \"ccc\"])\n/// \"ccc\"\nfunc longest(strings: [String]) -> String?\
    \ {\n    if strings.isEmpty {\n        return nil\n    }\n    if strings.count\
    \ == 1 {\n        return strings[0]\n    }\n    var result: String = strings[0]\n\
    \    for string in strings {\n        if string.count > result.count {\n     \
    \       result = string\n        }\n    }\n    return result\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(longest(strings: [] as [String]) == nil)\nassert(longest(strings:\
    \ [\"x\", \"y\", \"z\"]) == \"x\")\nassert(longest(strings: [\"x\", \"yyy\", \"\
    zzzz\", \"www\", \"kkkk\", \"abc\"]) == \"zzzz\")"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660013861
- exit_code: 1
  program: "\n/// Out of array of strings, return the longest one. Return the first\
    \ one in case of multiple\n/// strings of the same length. Return nil in case\
    \ the input array is empty.\n/// >>> longest(strings: [] as [String])\n/// nil\n\
    /// >>> longest(strings: [\"a\", \"b\", \"c\"])\n/// \"a\"\n/// >>> longest(strings:\
    \ [\"a\", \"bb\", \"ccc\"])\n/// \"ccc\"\nfunc longest(strings: [String]) -> String?\
    \ {\n    var maxLen: Int = 0\n    var max: String? = nil\n    for s in strings\
    \ {\n        if s.characters.count > maxLen {\n            maxLen = s.characters.count\n\
    \            max = s\n        }\n    }\n    return max\n}\n\n\nfunc ==(left: [(Int,\
    \ Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n\
    \        return false\n    }\n    for (l, r) in zip(left, right) {\n        if\
    \ l != r {\n            return false\n        }\n    }\n    return true\n}\n \
    \           \nassert(longest(strings: [] as [String]) == nil)\nassert(longest(strings:\
    \ [\"x\", \"y\", \"z\"]) == \"x\")\nassert(longest(strings: [\"x\", \"yyy\", \"\
    zzzz\", \"www\", \"kkkk\", \"abc\"]) == \"zzzz\")"
  status: SyntaxError
  stderr: "/tmp/tmp5xwcafj2.swift:14:14: error: 'characters' is unavailable: Please\
    \ use String directly\n        if s.characters.count > maxLen {\n            \
    \ ^~~~~~~~~~\nSwift.String:5:16: note: 'characters' was obsoleted in Swift 5.0\n\
    \    public var characters: String { get set }\n               ^\n/tmp/tmp5xwcafj2.swift:15:24:\
    \ error: 'characters' is unavailable: Please use String directly\n           \
    \ maxLen = s.characters.count\n                       ^~~~~~~~~~\nSwift.String:5:16:\
    \ note: 'characters' was obsoleted in Swift 5.0\n    public var characters: String\
    \ { get set }\n               ^\n"
  stdout: ''
  timestamp: 1660013860
- exit_code: 0
  program: "\n/// Out of array of strings, return the longest one. Return the first\
    \ one in case of multiple\n/// strings of the same length. Return nil in case\
    \ the input array is empty.\n/// >>> longest(strings: [] as [String])\n/// nil\n\
    /// >>> longest(strings: [\"a\", \"b\", \"c\"])\n/// \"a\"\n/// >>> longest(strings:\
    \ [\"a\", \"bb\", \"ccc\"])\n/// \"ccc\"\nfunc longest(strings: [String]) -> String?\
    \ {\n    // insert your code here\n    return strings.max {\n        $0.count\
    \ < $1.count\n    }\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) ->\
    \ Bool {\n    if left.count != right.count {\n        return false\n    }\n  \
    \  for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(longest(strings: []\
    \ as [String]) == nil)\nassert(longest(strings: [\"x\", \"y\", \"z\"]) == \"x\"\
    )\nassert(longest(strings: [\"x\", \"yyy\", \"zzzz\", \"www\", \"kkkk\", \"abc\"\
    ]) == \"zzzz\")"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660013861
- exit_code: 1
  program: "\n/// Out of array of strings, return the longest one. Return the first\
    \ one in case of multiple\n/// strings of the same length. Return nil in case\
    \ the input array is empty.\n/// >>> longest(strings: [] as [String])\n/// nil\n\
    /// >>> longest(strings: [\"a\", \"b\", \"c\"])\n/// \"a\"\n/// >>> longest(strings:\
    \ [\"a\", \"bb\", \"ccc\"])\n/// \"ccc\"\nfunc longest(strings: [String]) -> String?\
    \ {\n    var longestString: String?\n    for string in strings {\n        if longestString\
    \ == nil || string.characters.count > longestString!.characters.count {\n    \
    \        longestString = string\n        }\n    }\n    return longestString\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(longest(strings: [] as [String]) == nil)\nassert(longest(strings:\
    \ [\"x\", \"y\", \"z\"]) == \"x\")\nassert(longest(strings: [\"x\", \"yyy\", \"\
    zzzz\", \"www\", \"kkkk\", \"abc\"]) == \"zzzz\")"
  status: SyntaxError
  stderr: "/tmp/tmpj2f793ff.swift:13:43: error: 'characters' is unavailable: Please\
    \ use String directly\n        if longestString == nil || string.characters.count\
    \ > longestString!.characters.count {\n                                      \
    \    ^~~~~~~~~~\nSwift.String:5:16: note: 'characters' was obsoleted in Swift\
    \ 5.0\n    public var characters: String { get set }\n               ^\n/tmp/tmpj2f793ff.swift:13:77:\
    \ error: 'characters' is unavailable: Please use String directly\n        if longestString\
    \ == nil || string.characters.count > longestString!.characters.count {\n    \
    \                                                                        ^~~~~~~~~~\n\
    Swift.String:5:16: note: 'characters' was obsoleted in Swift 5.0\n    public var\
    \ characters: String { get set }\n               ^\n"
  stdout: ''
  timestamp: 1660013739
- exit_code: 0
  program: "\n/// Out of array of strings, return the longest one. Return the first\
    \ one in case of multiple\n/// strings of the same length. Return nil in case\
    \ the input array is empty.\n/// >>> longest(strings: [] as [String])\n/// nil\n\
    /// >>> longest(strings: [\"a\", \"b\", \"c\"])\n/// \"a\"\n/// >>> longest(strings:\
    \ [\"a\", \"bb\", \"ccc\"])\n/// \"ccc\"\nfunc longest(strings: [String]) -> String?\
    \ {\n    if strings.isEmpty {\n        return nil\n    }\n    var max = strings[0]\n\
    \    for string in strings {\n        if string.count > max.count {\n        \
    \    max = string\n        }\n    }\n    return max\n}\n\n\nfunc ==(left: [(Int,\
    \ Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n\
    \        return false\n    }\n    for (l, r) in zip(left, right) {\n        if\
    \ l != r {\n            return false\n        }\n    }\n    return true\n}\n \
    \           \nassert(longest(strings: [] as [String]) == nil)\nassert(longest(strings:\
    \ [\"x\", \"y\", \"z\"]) == \"x\")\nassert(longest(strings: [\"x\", \"yyy\", \"\
    zzzz\", \"www\", \"kkkk\", \"abc\"]) == \"zzzz\")"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660013861
- exit_code: 0
  program: "\n/// Out of array of strings, return the longest one. Return the first\
    \ one in case of multiple\n/// strings of the same length. Return nil in case\
    \ the input array is empty.\n/// >>> longest(strings: [] as [String])\n/// nil\n\
    /// >>> longest(strings: [\"a\", \"b\", \"c\"])\n/// \"a\"\n/// >>> longest(strings:\
    \ [\"a\", \"bb\", \"ccc\"])\n/// \"ccc\"\nfunc longest(strings: [String]) -> String?\
    \ {\n    var longest: String? = nil\n    for string in strings {\n        if longest\
    \ == nil || string.count > longest!.count {\n            longest = string\n  \
    \      }\n    }\n    return longest\n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(longest(strings: [] as [String]) == nil)\nassert(longest(strings: [\"x\"\
    , \"y\", \"z\"]) == \"x\")\nassert(longest(strings: [\"x\", \"yyy\", \"zzzz\"\
    , \"www\", \"kkkk\", \"abc\"]) == \"zzzz\")"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660013739
- exit_code: 0
  program: "\n/// Out of array of strings, return the longest one. Return the first\
    \ one in case of multiple\n/// strings of the same length. Return nil in case\
    \ the input array is empty.\n/// >>> longest(strings: [] as [String])\n/// nil\n\
    /// >>> longest(strings: [\"a\", \"b\", \"c\"])\n/// \"a\"\n/// >>> longest(strings:\
    \ [\"a\", \"bb\", \"ccc\"])\n/// \"ccc\"\nfunc longest(strings: [String]) -> String?\
    \ {\n    guard !strings.isEmpty else { return nil }\n    return strings.max {\
    \ s1, s2 in s1.count < s2.count }\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int,\
    \ Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n\
    \    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n          \
    \  return false\n        }\n    }\n    return true\n}\n            \nassert(longest(strings:\
    \ [] as [String]) == nil)\nassert(longest(strings: [\"x\", \"y\", \"z\"]) == \"\
    x\")\nassert(longest(strings: [\"x\", \"yyy\", \"zzzz\", \"www\", \"kkkk\", \"\
    abc\"]) == \"zzzz\")"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660013861
- exit_code: -4
  program: "\n/// Out of array of strings, return the longest one. Return the first\
    \ one in case of multiple\n/// strings of the same length. Return nil in case\
    \ the input array is empty.\n/// >>> longest(strings: [] as [String])\n/// nil\n\
    /// >>> longest(strings: [\"a\", \"b\", \"c\"])\n/// \"a\"\n/// >>> longest(strings:\
    \ [\"a\", \"bb\", \"ccc\"])\n/// \"ccc\"\nfunc longest(strings: [String]) -> String?\
    \ {\n    return strings.max()\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int,\
    \ Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n\
    \    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n          \
    \  return false\n        }\n    }\n    return true\n}\n            \nassert(longest(strings:\
    \ [] as [String]) == nil)\nassert(longest(strings: [\"x\", \"y\", \"z\"]) == \"\
    x\")\nassert(longest(strings: [\"x\", \"yyy\", \"zzzz\", \"www\", \"kkkk\", \"\
    abc\"]) == \"zzzz\")"
  status: Exception
  stderr: 'tmp71jrbmvf/tmp71jrbmvf.swift:28: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002ad69d142c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002ad69ce39b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002ad69ce39988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002ad69ce387b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmp71jrbmvf                        0x00005616aa89f83a <unavailable> + 6202

    5    libc.so.6                          0x00002ad69d32e460 __libc_start_main +
    245

    6    tmp71jrbmvf                        0x00005616aa89f129 <unavailable> + 4393

    '
  stdout: ''
  timestamp: 1660013860
- exit_code: 0
  program: "\n/// Out of array of strings, return the longest one. Return the first\
    \ one in case of multiple\n/// strings of the same length. Return nil in case\
    \ the input array is empty.\n/// >>> longest(strings: [] as [String])\n/// nil\n\
    /// >>> longest(strings: [\"a\", \"b\", \"c\"])\n/// \"a\"\n/// >>> longest(strings:\
    \ [\"a\", \"bb\", \"ccc\"])\n/// \"ccc\"\nfunc longest(strings: [String]) -> String?\
    \ {\n    guard !strings.isEmpty else { return nil }\n    return strings.reduce(strings[0])\
    \ { $1.count > $0.count ? $1 : $0 }\n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(longest(strings: [] as [String]) == nil)\nassert(longest(strings: [\"x\"\
    , \"y\", \"z\"]) == \"x\")\nassert(longest(strings: [\"x\", \"yyy\", \"zzzz\"\
    , \"www\", \"kkkk\", \"abc\"]) == \"zzzz\")"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660013739
- exit_code: 0
  program: "\n/// Out of array of strings, return the longest one. Return the first\
    \ one in case of multiple\n/// strings of the same length. Return nil in case\
    \ the input array is empty.\n/// >>> longest(strings: [] as [String])\n/// nil\n\
    /// >>> longest(strings: [\"a\", \"b\", \"c\"])\n/// \"a\"\n/// >>> longest(strings:\
    \ [\"a\", \"bb\", \"ccc\"])\n/// \"ccc\"\nfunc longest(strings: [String]) -> String?\
    \ {\n    guard !strings.isEmpty else { return nil }\n    var result = strings[0]\n\
    \    for string in strings {\n        if string.count > result.count {\n     \
    \       result = string\n        }\n    }\n    return result\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(longest(strings: [] as [String]) == nil)\nassert(longest(strings:\
    \ [\"x\", \"y\", \"z\"]) == \"x\")\nassert(longest(strings: [\"x\", \"yyy\", \"\
    zzzz\", \"www\", \"kkkk\", \"abc\"]) == \"zzzz\")"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660013860
- exit_code: -4
  program: "\n/// Out of array of strings, return the longest one. Return the first\
    \ one in case of multiple\n/// strings of the same length. Return nil in case\
    \ the input array is empty.\n/// >>> longest(strings: [] as [String])\n/// nil\n\
    /// >>> longest(strings: [\"a\", \"b\", \"c\"])\n/// \"a\"\n/// >>> longest(strings:\
    \ [\"a\", \"bb\", \"ccc\"])\n/// \"ccc\"\nfunc longest(strings: [String]) -> String?\
    \ {\n    guard let first = strings.first else { return nil }\n    return strings.reduce(first)\
    \ { current, element in\n        current.count > element.count ? current : element\n\
    \    }\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n  \
    \  if left.count != right.count {\n        return false\n    }\n    for (l, r)\
    \ in zip(left, right) {\n        if l != r {\n            return false\n     \
    \   }\n    }\n    return true\n}\n            \nassert(longest(strings: [] as\
    \ [String]) == nil)\nassert(longest(strings: [\"x\", \"y\", \"z\"]) == \"x\")\n\
    assert(longest(strings: [\"x\", \"yyy\", \"zzzz\", \"www\", \"kkkk\", \"abc\"\
    ]) == \"zzzz\")"
  status: Exception
  stderr: 'tmpskvrmov5/tmpskvrmov5.swift:31: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002af4fe567c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002af4fe25eb6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002af4fe25e988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002af4fe25d7b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpskvrmov5                        0x000055fd84c1a8fa <unavailable> + 6394

    5    libc.so.6                          0x00002af4fe753460 __libc_start_main +
    245

    6    tmpskvrmov5                        0x000055fd84c1a1e9 <unavailable> + 4585

    '
  stdout: ''
  timestamp: 1660013861
- exit_code: 0
  program: "\n/// Out of array of strings, return the longest one. Return the first\
    \ one in case of multiple\n/// strings of the same length. Return nil in case\
    \ the input array is empty.\n/// >>> longest(strings: [] as [String])\n/// nil\n\
    /// >>> longest(strings: [\"a\", \"b\", \"c\"])\n/// \"a\"\n/// >>> longest(strings:\
    \ [\"a\", \"bb\", \"ccc\"])\n/// \"ccc\"\nfunc longest(strings: [String]) -> String?\
    \ {\n    // TODO: write your solution here\n    if strings.isEmpty {\n       \
    \ return nil\n    }\n    var max = strings[0]\n    for str in strings {\n    \
    \    if str.count > max.count {\n            max = str\n        }\n    }\n   \
    \ return max\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool\
    \ {\n    if left.count != right.count {\n        return false\n    }\n    for\
    \ (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(longest(strings: []\
    \ as [String]) == nil)\nassert(longest(strings: [\"x\", \"y\", \"z\"]) == \"x\"\
    )\nassert(longest(strings: [\"x\", \"yyy\", \"zzzz\", \"www\", \"kkkk\", \"abc\"\
    ]) == \"zzzz\")"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660013861
- exit_code: 1
  program: "\n/// Out of array of strings, return the longest one. Return the first\
    \ one in case of multiple\n/// strings of the same length. Return nil in case\
    \ the input array is empty.\n/// >>> longest(strings: [] as [String])\n/// nil\n\
    /// >>> longest(strings: [\"a\", \"b\", \"c\"])\n/// \"a\"\n/// >>> longest(strings:\
    \ [\"a\", \"bb\", \"ccc\"])\n/// \"ccc\"\nfunc longest(strings: [String]) -> String?\
    \ {\n    // ...\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool\
    \ {\n    if left.count != right.count {\n        return false\n    }\n    for\
    \ (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(longest(strings: []\
    \ as [String]) == nil)\nassert(longest(strings: [\"x\", \"y\", \"z\"]) == \"x\"\
    )\nassert(longest(strings: [\"x\", \"yyy\", \"zzzz\", \"www\", \"kkkk\", \"abc\"\
    ]) == \"zzzz\")"
  status: SyntaxError
  stderr: '/tmp/tmpxke9uadj.swift:12:1: error: missing return in global function expected
    to return ''String?''

    }

    ^

    '
  stdout: ''
  timestamp: 1660013861
- exit_code: 0
  program: "\n/// Out of array of strings, return the longest one. Return the first\
    \ one in case of multiple\n/// strings of the same length. Return nil in case\
    \ the input array is empty.\n/// >>> longest(strings: [] as [String])\n/// nil\n\
    /// >>> longest(strings: [\"a\", \"b\", \"c\"])\n/// \"a\"\n/// >>> longest(strings:\
    \ [\"a\", \"bb\", \"ccc\"])\n/// \"ccc\"\nfunc longest(strings: [String]) -> String?\
    \ {\n    var longestString: String?\n    for string in strings {\n        if longestString\
    \ == nil || string.count > longestString!.count {\n            longestString =\
    \ string\n        }\n    }\n    return longestString\n}\n\n\nfunc ==(left: [(Int,\
    \ Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n\
    \        return false\n    }\n    for (l, r) in zip(left, right) {\n        if\
    \ l != r {\n            return false\n        }\n    }\n    return true\n}\n \
    \           \nassert(longest(strings: [] as [String]) == nil)\nassert(longest(strings:\
    \ [\"x\", \"y\", \"z\"]) == \"x\")\nassert(longest(strings: [\"x\", \"yyy\", \"\
    zzzz\", \"www\", \"kkkk\", \"abc\"]) == \"zzzz\")"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660013739
- exit_code: 0
  program: "\n/// Out of array of strings, return the longest one. Return the first\
    \ one in case of multiple\n/// strings of the same length. Return nil in case\
    \ the input array is empty.\n/// >>> longest(strings: [] as [String])\n/// nil\n\
    /// >>> longest(strings: [\"a\", \"b\", \"c\"])\n/// \"a\"\n/// >>> longest(strings:\
    \ [\"a\", \"bb\", \"ccc\"])\n/// \"ccc\"\nfunc longest(strings: [String]) -> String?\
    \ {\n    guard !strings.isEmpty else { return nil }\n    var longest: String =\
    \ strings[0]\n    for string in strings {\n        if string.count > longest.count\
    \ {\n            longest = string\n        }\n    }\n    return longest\n}\n\n\
    \nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(longest(strings: [] as [String]) == nil)\nassert(longest(strings:\
    \ [\"x\", \"y\", \"z\"]) == \"x\")\nassert(longest(strings: [\"x\", \"yyy\", \"\
    zzzz\", \"www\", \"kkkk\", \"abc\"]) == \"zzzz\")"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660013860
- exit_code: 1
  program: "\n/// Out of array of strings, return the longest one. Return the first\
    \ one in case of multiple\n/// strings of the same length. Return nil in case\
    \ the input array is empty.\n/// >>> longest(strings: [] as [String])\n/// nil\n\
    /// >>> longest(strings: [\"a\", \"b\", \"c\"])\n/// \"a\"\n/// >>> longest(strings:\
    \ [\"a\", \"bb\", \"ccc\"])\n/// \"ccc\"\nfunc longest(strings: [String]) -> String?\
    \ {\n    if strings.isEmpty {\n        return nil\n    }\n    var longest = strings[0]\n\
    \    for string in strings {\n        if string.characters.count > longest.characters.count\
    \ {\n            longest = string\n        }\n    }\n    return longest\n}\n\n\
    \nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(longest(strings: [] as [String]) == nil)\nassert(longest(strings:\
    \ [\"x\", \"y\", \"z\"]) == \"x\")\nassert(longest(strings: [\"x\", \"yyy\", \"\
    zzzz\", \"www\", \"kkkk\", \"abc\"]) == \"zzzz\")"
  status: SyntaxError
  stderr: "/tmp/tmpvz8giihz.swift:16:19: error: 'characters' is unavailable: Please\
    \ use String directly\n        if string.characters.count > longest.characters.count\
    \ {\n                  ^~~~~~~~~~\nSwift.String:5:16: note: 'characters' was obsoleted\
    \ in Swift 5.0\n    public var characters: String { get set }\n              \
    \ ^\n/tmp/tmpvz8giihz.swift:16:46: error: 'characters' is unavailable: Please\
    \ use String directly\n        if string.characters.count > longest.characters.count\
    \ {\n                                             ^~~~~~~~~~\nSwift.String:5:16:\
    \ note: 'characters' was obsoleted in Swift 5.0\n    public var characters: String\
    \ { get set }\n               ^\n"
  stdout: ''
  timestamp: 1660013739
- exit_code: 0
  program: "\n/// Out of array of strings, return the longest one. Return the first\
    \ one in case of multiple\n/// strings of the same length. Return nil in case\
    \ the input array is empty.\n/// >>> longest(strings: [] as [String])\n/// nil\n\
    /// >>> longest(strings: [\"a\", \"b\", \"c\"])\n/// \"a\"\n/// >>> longest(strings:\
    \ [\"a\", \"bb\", \"ccc\"])\n/// \"ccc\"\nfunc longest(strings: [String]) -> String?\
    \ {\n    \n    guard !strings.isEmpty else { return nil }\n    \n    var s = strings[0]\n\
    \    \n    for string in strings {\n        if string.count > s.count {\n    \
    \        s = string\n        }\n    }\n    \n    return s\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(longest(strings: [] as [String]) == nil)\nassert(longest(strings:\
    \ [\"x\", \"y\", \"z\"]) == \"x\")\nassert(longest(strings: [\"x\", \"yyy\", \"\
    zzzz\", \"www\", \"kkkk\", \"abc\"]) == \"zzzz\")"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660013861
- exit_code: -4
  program: "\n/// Out of array of strings, return the longest one. Return the first\
    \ one in case of multiple\n/// strings of the same length. Return nil in case\
    \ the input array is empty.\n/// >>> longest(strings: [] as [String])\n/// nil\n\
    /// >>> longest(strings: [\"a\", \"b\", \"c\"])\n/// \"a\"\n/// >>> longest(strings:\
    \ [\"a\", \"bb\", \"ccc\"])\n/// \"ccc\"\nfunc longest(strings: [String]) -> String?\
    \ {\n    if strings.isEmpty {\n        return nil\n    }\n    return strings.reduce(strings[0])\
    \ { acc, x in\n        return acc.count > x.count ? acc : x\n    }\n}\n\n\nfunc\
    \ ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count !=\
    \ right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(longest(strings: [] as [String]) == nil)\nassert(longest(strings:\
    \ [\"x\", \"y\", \"z\"]) == \"x\")\nassert(longest(strings: [\"x\", \"yyy\", \"\
    zzzz\", \"www\", \"kkkk\", \"abc\"]) == \"zzzz\")"
  status: Exception
  stderr: 'tmpvolhq5ux/tmpvolhq5ux.swift:33: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b380b4b5c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b380b1acb6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b380b1ac988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b380b1ab7b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpvolhq5ux                        0x000055cf5a0b494a <unavailable> + 6474

    5    libc.so.6                          0x00002b380b6a1460 __libc_start_main +
    245

    6    tmpvolhq5ux                        0x000055cf5a0b4239 <unavailable> + 4665

    '
  stdout: ''
  timestamp: 1660013861
- exit_code: 1
  program: "\n/// Out of array of strings, return the longest one. Return the first\
    \ one in case of multiple\n/// strings of the same length. Return nil in case\
    \ the input array is empty.\n/// >>> longest(strings: [] as [String])\n/// nil\n\
    /// >>> longest(strings: [\"a\", \"b\", \"c\"])\n/// \"a\"\n/// >>> longest(strings:\
    \ [\"a\", \"bb\", \"ccc\"])\n/// \"ccc\"\nfunc longest(strings: [String]) -> String?\
    \ {\n    if strings.isEmpty {\n        return nil\n    }\n    var i = 0\n    var\
    \ maxIndex = 0\n    var maxLen = 0\n    for str in strings {\n        if str.characters.count\
    \ > maxLen {\n            maxLen = str.characters.count\n            maxIndex\
    \ = i\n        }\n        i += 1\n    }\n    return strings[maxIndex]\n}\n\n\n\
    func ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(longest(strings: [] as [String]) == nil)\nassert(longest(strings:\
    \ [\"x\", \"y\", \"z\"]) == \"x\")\nassert(longest(strings: [\"x\", \"yyy\", \"\
    zzzz\", \"www\", \"kkkk\", \"abc\"]) == \"zzzz\")"
  status: SyntaxError
  stderr: "/tmp/tmpvplf643v.swift:18:16: error: 'characters' is unavailable: Please\
    \ use String directly\n        if str.characters.count > maxLen {\n          \
    \     ^~~~~~~~~~\nSwift.String:5:16: note: 'characters' was obsoleted in Swift\
    \ 5.0\n    public var characters: String { get set }\n               ^\n/tmp/tmpvplf643v.swift:19:26:\
    \ error: 'characters' is unavailable: Please use String directly\n           \
    \ maxLen = str.characters.count\n                         ^~~~~~~~~~\nSwift.String:5:16:\
    \ note: 'characters' was obsoleted in Swift 5.0\n    public var characters: String\
    \ { get set }\n               ^\n"
  stdout: ''
  timestamp: 1660013861
- exit_code: 1
  program: "\n/// Out of array of strings, return the longest one. Return the first\
    \ one in case of multiple\n/// strings of the same length. Return nil in case\
    \ the input array is empty.\n/// >>> longest(strings: [] as [String])\n/// nil\n\
    /// >>> longest(strings: [\"a\", \"b\", \"c\"])\n/// \"a\"\n/// >>> longest(strings:\
    \ [\"a\", \"bb\", \"ccc\"])\n/// \"ccc\"\nfunc longest(strings: [String]) -> String?\
    \ {\n    return strings.max(by: { $0.characters.count < $1.characters.count })\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(longest(strings: [] as [String]) == nil)\nassert(longest(strings:\
    \ [\"x\", \"y\", \"z\"]) == \"x\")\nassert(longest(strings: [\"x\", \"yyy\", \"\
    zzzz\", \"www\", \"kkkk\", \"abc\"]) == \"zzzz\")"
  status: SyntaxError
  stderr: "/tmp/tmp79erwe4q.swift:11:33: error: 'characters' is unavailable: Please\
    \ use String directly\n    return strings.max(by: { $0.characters.count < $1.characters.count\
    \ })\n                                ^~~~~~~~~~\nSwift.String:5:16: note: 'characters'\
    \ was obsoleted in Swift 5.0\n    public var characters: String { get set }\n\
    \               ^\n/tmp/tmp79erwe4q.swift:11:55: error: 'characters' is unavailable:\
    \ Please use String directly\n    return strings.max(by: { $0.characters.count\
    \ < $1.characters.count })\n                                                 \
    \     ^~~~~~~~~~\nSwift.String:5:16: note: 'characters' was obsoleted in Swift\
    \ 5.0\n    public var characters: String { get set }\n               ^\n"
  stdout: ''
  timestamp: 1660013861
- exit_code: 1
  program: "\n/// Out of array of strings, return the longest one. Return the first\
    \ one in case of multiple\n/// strings of the same length. Return nil in case\
    \ the input array is empty.\n/// >>> longest(strings: [] as [String])\n/// nil\n\
    /// >>> longest(strings: [\"a\", \"b\", \"c\"])\n/// \"a\"\n/// >>> longest(strings:\
    \ [\"a\", \"bb\", \"ccc\"])\n/// \"ccc\"\nfunc longest(strings: [String]) -> String?\
    \ {\n    if strings.isEmpty {\n        return nil\n    }\n    var longest = strings[0]\n\
    \    for string in strings {\n        if string.characters.count > longest.characters.count\
    \ {\n            longest = string\n        }\n    }\n    return longest\n}\n\n\
    \nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(longest(strings: [] as [String]) == nil)\nassert(longest(strings:\
    \ [\"x\", \"y\", \"z\"]) == \"x\")\nassert(longest(strings: [\"x\", \"yyy\", \"\
    zzzz\", \"www\", \"kkkk\", \"abc\"]) == \"zzzz\")"
  status: SyntaxError
  stderr: "/tmp/tmpvz8giihz.swift:16:19: error: 'characters' is unavailable: Please\
    \ use String directly\n        if string.characters.count > longest.characters.count\
    \ {\n                  ^~~~~~~~~~\nSwift.String:5:16: note: 'characters' was obsoleted\
    \ in Swift 5.0\n    public var characters: String { get set }\n              \
    \ ^\n/tmp/tmpvz8giihz.swift:16:46: error: 'characters' is unavailable: Please\
    \ use String directly\n        if string.characters.count > longest.characters.count\
    \ {\n                                             ^~~~~~~~~~\nSwift.String:5:16:\
    \ note: 'characters' was obsoleted in Swift 5.0\n    public var characters: String\
    \ { get set }\n               ^\n"
  stdout: ''
  timestamp: 1660013739
- exit_code: 0
  program: "\n/// Out of array of strings, return the longest one. Return the first\
    \ one in case of multiple\n/// strings of the same length. Return nil in case\
    \ the input array is empty.\n/// >>> longest(strings: [] as [String])\n/// nil\n\
    /// >>> longest(strings: [\"a\", \"b\", \"c\"])\n/// \"a\"\n/// >>> longest(strings:\
    \ [\"a\", \"bb\", \"ccc\"])\n/// \"ccc\"\nfunc longest(strings: [String]) -> String?\
    \ {\n    var longerWord = \"\"\n    var longerWordLenght = 0\n    for word in\
    \ strings {\n        if word.count > longerWordLenght {\n            longerWord\
    \ = word\n            longerWordLenght = word.count\n        }\n    }\n    return\
    \ longerWord.isEmpty ? nil : longerWord\n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(longest(strings: [] as [String]) == nil)\nassert(longest(strings: [\"x\"\
    , \"y\", \"z\"]) == \"x\")\nassert(longest(strings: [\"x\", \"yyy\", \"zzzz\"\
    , \"www\", \"kkkk\", \"abc\"]) == \"zzzz\")"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660013861
- exit_code: 0
  program: "\n/// Out of array of strings, return the longest one. Return the first\
    \ one in case of multiple\n/// strings of the same length. Return nil in case\
    \ the input array is empty.\n/// >>> longest(strings: [] as [String])\n/// nil\n\
    /// >>> longest(strings: [\"a\", \"b\", \"c\"])\n/// \"a\"\n/// >>> longest(strings:\
    \ [\"a\", \"bb\", \"ccc\"])\n/// \"ccc\"\nfunc longest(strings: [String]) -> String?\
    \ {\n    var longestWord: String?\n    for string in strings {\n        if longestWord\
    \ == nil || string.count > longestWord!.count {\n            longestWord = string\n\
    \        }\n    }\n    return longestWord\n}\n\n\nfunc ==(left: [(Int, Int)],\
    \ right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n       \
    \ return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r\
    \ {\n            return false\n        }\n    }\n    return true\n}\n        \
    \    \nassert(longest(strings: [] as [String]) == nil)\nassert(longest(strings:\
    \ [\"x\", \"y\", \"z\"]) == \"x\")\nassert(longest(strings: [\"x\", \"yyy\", \"\
    zzzz\", \"www\", \"kkkk\", \"abc\"]) == \"zzzz\")"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660013861
- exit_code: 1
  program: "\n/// Out of array of strings, return the longest one. Return the first\
    \ one in case of multiple\n/// strings of the same length. Return nil in case\
    \ the input array is empty.\n/// >>> longest(strings: [] as [String])\n/// nil\n\
    /// >>> longest(strings: [\"a\", \"b\", \"c\"])\n/// \"a\"\n/// >>> longest(strings:\
    \ [\"a\", \"bb\", \"ccc\"])\n/// \"ccc\"\nfunc longest(strings: [String]) -> String?\
    \ {\n    var longestStr: String? = nil\n    var length: Int = 0\n    for str in\
    \ strings {\n        if str.characters.count > length {\n            length =\
    \ str.characters.count\n            longestStr = str\n        }\n    }\n    return\
    \ longestStr\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool\
    \ {\n    if left.count != right.count {\n        return false\n    }\n    for\
    \ (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(longest(strings: []\
    \ as [String]) == nil)\nassert(longest(strings: [\"x\", \"y\", \"z\"]) == \"x\"\
    )\nassert(longest(strings: [\"x\", \"yyy\", \"zzzz\", \"www\", \"kkkk\", \"abc\"\
    ]) == \"zzzz\")"
  status: SyntaxError
  stderr: "/tmp/tmpuvrtz16j.swift:14:16: error: 'characters' is unavailable: Please\
    \ use String directly\n        if str.characters.count > length {\n          \
    \     ^~~~~~~~~~\nSwift.String:5:16: note: 'characters' was obsoleted in Swift\
    \ 5.0\n    public var characters: String { get set }\n               ^\n/tmp/tmpuvrtz16j.swift:15:26:\
    \ error: 'characters' is unavailable: Please use String directly\n           \
    \ length = str.characters.count\n                         ^~~~~~~~~~\nSwift.String:5:16:\
    \ note: 'characters' was obsoleted in Swift 5.0\n    public var characters: String\
    \ { get set }\n               ^\n"
  stdout: ''
  timestamp: 1660013861
- exit_code: 0
  program: "\n/// Out of array of strings, return the longest one. Return the first\
    \ one in case of multiple\n/// strings of the same length. Return nil in case\
    \ the input array is empty.\n/// >>> longest(strings: [] as [String])\n/// nil\n\
    /// >>> longest(strings: [\"a\", \"b\", \"c\"])\n/// \"a\"\n/// >>> longest(strings:\
    \ [\"a\", \"bb\", \"ccc\"])\n/// \"ccc\"\nfunc longest(strings: [String]) -> String?\
    \ {\n    if strings.isEmpty {\n        return nil\n    } else {\n        var longestString\
    \ = strings[0]\n        for string in strings {\n            if string.count >\
    \ longestString.count {\n                longestString = string\n            }\n\
    \        }\n        return longestString\n    }\n}\n\n\nfunc ==(left: [(Int, Int)],\
    \ right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n       \
    \ return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r\
    \ {\n            return false\n        }\n    }\n    return true\n}\n        \
    \    \nassert(longest(strings: [] as [String]) == nil)\nassert(longest(strings:\
    \ [\"x\", \"y\", \"z\"]) == \"x\")\nassert(longest(strings: [\"x\", \"yyy\", \"\
    zzzz\", \"www\", \"kkkk\", \"abc\"]) == \"zzzz\")"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660013860
- exit_code: 1
  program: "\n/// Out of array of strings, return the longest one. Return the first\
    \ one in case of multiple\n/// strings of the same length. Return nil in case\
    \ the input array is empty.\n/// >>> longest(strings: [] as [String])\n/// nil\n\
    /// >>> longest(strings: [\"a\", \"b\", \"c\"])\n/// \"a\"\n/// >>> longest(strings:\
    \ [\"a\", \"bb\", \"ccc\"])\n/// \"ccc\"\nfunc longest(strings: [String]) -> String?\
    \ {\n    var longestStr: String? = nil\n    for str in strings {\n        if longestStr\
    \ == nil || longestStr!.characters.count < str.characters.count {\n          \
    \  longestStr = str\n        }\n    }\n    return longestStr\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(longest(strings: [] as [String]) == nil)\nassert(longest(strings:\
    \ [\"x\", \"y\", \"z\"]) == \"x\")\nassert(longest(strings: [\"x\", \"yyy\", \"\
    zzzz\", \"www\", \"kkkk\", \"abc\"]) == \"zzzz\")"
  status: SyntaxError
  stderr: "/tmp/tmp43tuke14.swift:13:45: error: 'characters' is unavailable: Please\
    \ use String directly\n        if longestStr == nil || longestStr!.characters.count\
    \ < str.characters.count {\n                                            ^~~~~~~~~~\n\
    Swift.String:5:16: note: 'characters' was obsoleted in Swift 5.0\n    public var\
    \ characters: String { get set }\n               ^\n/tmp/tmp43tuke14.swift:13:68:\
    \ error: 'characters' is unavailable: Please use String directly\n        if longestStr\
    \ == nil || longestStr!.characters.count < str.characters.count {\n          \
    \                                                         ^~~~~~~~~~\nSwift.String:5:16:\
    \ note: 'characters' was obsoleted in Swift 5.0\n    public var characters: String\
    \ { get set }\n               ^\n"
  stdout: ''
  timestamp: 1660013861
- exit_code: 0
  program: "\n/// Out of array of strings, return the longest one. Return the first\
    \ one in case of multiple\n/// strings of the same length. Return nil in case\
    \ the input array is empty.\n/// >>> longest(strings: [] as [String])\n/// nil\n\
    /// >>> longest(strings: [\"a\", \"b\", \"c\"])\n/// \"a\"\n/// >>> longest(strings:\
    \ [\"a\", \"bb\", \"ccc\"])\n/// \"ccc\"\nfunc longest(strings: [String]) -> String?\
    \ {\n    guard strings.count > 0 else {\n        return nil\n    }\n    guard\
    \ strings.count > 1 else {\n        return strings[0]\n    }\n    return strings.sorted(by:\
    \ { $0.count > $1.count })[0]\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int,\
    \ Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n\
    \    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n          \
    \  return false\n        }\n    }\n    return true\n}\n            \nassert(longest(strings:\
    \ [] as [String]) == nil)\nassert(longest(strings: [\"x\", \"y\", \"z\"]) == \"\
    x\")\nassert(longest(strings: [\"x\", \"yyy\", \"zzzz\", \"www\", \"kkkk\", \"\
    abc\"]) == \"zzzz\")"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660013861
- exit_code: 0
  program: "\n/// Out of array of strings, return the longest one. Return the first\
    \ one in case of multiple\n/// strings of the same length. Return nil in case\
    \ the input array is empty.\n/// >>> longest(strings: [] as [String])\n/// nil\n\
    /// >>> longest(strings: [\"a\", \"b\", \"c\"])\n/// \"a\"\n/// >>> longest(strings:\
    \ [\"a\", \"bb\", \"ccc\"])\n/// \"ccc\"\nfunc longest(strings: [String]) -> String?\
    \ {\n    if strings.isEmpty {\n        return nil\n    }\n    let sorted = strings.sorted\
    \ { $0.count > $1.count }\n    return sorted.first\n}\n\n\nfunc ==(left: [(Int,\
    \ Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n\
    \        return false\n    }\n    for (l, r) in zip(left, right) {\n        if\
    \ l != r {\n            return false\n        }\n    }\n    return true\n}\n \
    \           \nassert(longest(strings: [] as [String]) == nil)\nassert(longest(strings:\
    \ [\"x\", \"y\", \"z\"]) == \"x\")\nassert(longest(strings: [\"x\", \"yyy\", \"\
    zzzz\", \"www\", \"kkkk\", \"abc\"]) == \"zzzz\")"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660013861
- exit_code: 0
  program: "\n/// Out of array of strings, return the longest one. Return the first\
    \ one in case of multiple\n/// strings of the same length. Return nil in case\
    \ the input array is empty.\n/// >>> longest(strings: [] as [String])\n/// nil\n\
    /// >>> longest(strings: [\"a\", \"b\", \"c\"])\n/// \"a\"\n/// >>> longest(strings:\
    \ [\"a\", \"bb\", \"ccc\"])\n/// \"ccc\"\nfunc longest(strings: [String]) -> String?\
    \ {\n    if strings.isEmpty {\n        return nil\n    }\n    var maxString =\
    \ strings[0]\n    for string in strings {\n        if string.count > maxString.count\
    \ {\n            maxString = string\n        }\n    }\n    return maxString\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(longest(strings: [] as [String]) == nil)\nassert(longest(strings:\
    \ [\"x\", \"y\", \"z\"]) == \"x\")\nassert(longest(strings: [\"x\", \"yyy\", \"\
    zzzz\", \"www\", \"kkkk\", \"abc\"]) == \"zzzz\")"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660013861
- exit_code: 0
  program: "\n/// Out of array of strings, return the longest one. Return the first\
    \ one in case of multiple\n/// strings of the same length. Return nil in case\
    \ the input array is empty.\n/// >>> longest(strings: [] as [String])\n/// nil\n\
    /// >>> longest(strings: [\"a\", \"b\", \"c\"])\n/// \"a\"\n/// >>> longest(strings:\
    \ [\"a\", \"bb\", \"ccc\"])\n/// \"ccc\"\nfunc longest(strings: [String]) -> String?\
    \ {\n    return strings.max(by: { $0.count < $1.count })\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(longest(strings: [] as [String]) == nil)\nassert(longest(strings:\
    \ [\"x\", \"y\", \"z\"]) == \"x\")\nassert(longest(strings: [\"x\", \"yyy\", \"\
    zzzz\", \"www\", \"kkkk\", \"abc\"]) == \"zzzz\")"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660013739
- exit_code: 0
  program: "\n/// Out of array of strings, return the longest one. Return the first\
    \ one in case of multiple\n/// strings of the same length. Return nil in case\
    \ the input array is empty.\n/// >>> longest(strings: [] as [String])\n/// nil\n\
    /// >>> longest(strings: [\"a\", \"b\", \"c\"])\n/// \"a\"\n/// >>> longest(strings:\
    \ [\"a\", \"bb\", \"ccc\"])\n/// \"ccc\"\nfunc longest(strings: [String]) -> String?\
    \ {\n    // TODO: Write your own code!\n    var maxLength = 0\n    var maxString:\
    \ String? = nil\n    for s in strings {\n        if s.count > maxLength {\n  \
    \          maxLength = s.count\n            maxString = s\n        }\n    }\n\
    \    return maxString\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(longest(strings:\
    \ [] as [String]) == nil)\nassert(longest(strings: [\"x\", \"y\", \"z\"]) == \"\
    x\")\nassert(longest(strings: [\"x\", \"yyy\", \"zzzz\", \"www\", \"kkkk\", \"\
    abc\"]) == \"zzzz\")"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660013861
- exit_code: 0
  program: "\n/// Out of array of strings, return the longest one. Return the first\
    \ one in case of multiple\n/// strings of the same length. Return nil in case\
    \ the input array is empty.\n/// >>> longest(strings: [] as [String])\n/// nil\n\
    /// >>> longest(strings: [\"a\", \"b\", \"c\"])\n/// \"a\"\n/// >>> longest(strings:\
    \ [\"a\", \"bb\", \"ccc\"])\n/// \"ccc\"\nfunc longest(strings: [String]) -> String?\
    \ {\n    if strings.isEmpty {\n        return nil\n    }\n    var longest = strings[0]\n\
    \    for string in strings {\n        if string.count > longest.count {\n    \
    \        longest = string\n        }\n    }\n    return longest\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(longest(strings: [] as [String]) == nil)\nassert(longest(strings:\
    \ [\"x\", \"y\", \"z\"]) == \"x\")\nassert(longest(strings: [\"x\", \"yyy\", \"\
    zzzz\", \"www\", \"kkkk\", \"abc\"]) == \"zzzz\")"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660013739
- exit_code: 1
  program: "\n/// Out of array of strings, return the longest one. Return the first\
    \ one in case of multiple\n/// strings of the same length. Return nil in case\
    \ the input array is empty.\n/// >>> longest(strings: [] as [String])\n/// nil\n\
    /// >>> longest(strings: [\"a\", \"b\", \"c\"])\n/// \"a\"\n/// >>> longest(strings:\
    \ [\"a\", \"bb\", \"ccc\"])\n/// \"ccc\"\nfunc longest(strings: [String]) -> String?\
    \ {\n    if strings.isEmpty {\n        return nil\n    }\n    var result = strings[0]\n\
    \    for string in strings {\n        if string.characters.count > result.characters.count\
    \ {\n            result = string\n        }\n    }\n    return result\n}\n\n\n\
    func ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(longest(strings: [] as [String]) == nil)\nassert(longest(strings:\
    \ [\"x\", \"y\", \"z\"]) == \"x\")\nassert(longest(strings: [\"x\", \"yyy\", \"\
    zzzz\", \"www\", \"kkkk\", \"abc\"]) == \"zzzz\")"
  status: SyntaxError
  stderr: "/tmp/tmpv4zue60f.swift:16:19: error: 'characters' is unavailable: Please\
    \ use String directly\n        if string.characters.count > result.characters.count\
    \ {\n                  ^~~~~~~~~~\nSwift.String:5:16: note: 'characters' was obsoleted\
    \ in Swift 5.0\n    public var characters: String { get set }\n              \
    \ ^\n/tmp/tmpv4zue60f.swift:16:45: error: 'characters' is unavailable: Please\
    \ use String directly\n        if string.characters.count > result.characters.count\
    \ {\n                                            ^~~~~~~~~~\nSwift.String:5:16:\
    \ note: 'characters' was obsoleted in Swift 5.0\n    public var characters: String\
    \ { get set }\n               ^\n"
  stdout: ''
  timestamp: 1660013861
- exit_code: 1
  program: "\n/// Out of array of strings, return the longest one. Return the first\
    \ one in case of multiple\n/// strings of the same length. Return nil in case\
    \ the input array is empty.\n/// >>> longest(strings: [] as [String])\n/// nil\n\
    /// >>> longest(strings: [\"a\", \"b\", \"c\"])\n/// \"a\"\n/// >>> longest(strings:\
    \ [\"a\", \"bb\", \"ccc\"])\n/// \"ccc\"\nfunc longest(strings: [String]) -> String?\
    \ {\n    if strings.isEmpty {\n        return nil\n    }\n    return strings.max\
    \ { $0.characters.count < $1.characters.count }\n}\n\n\nfunc ==(left: [(Int, Int)],\
    \ right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n       \
    \ return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r\
    \ {\n            return false\n        }\n    }\n    return true\n}\n        \
    \    \nassert(longest(strings: [] as [String]) == nil)\nassert(longest(strings:\
    \ [\"x\", \"y\", \"z\"]) == \"x\")\nassert(longest(strings: [\"x\", \"yyy\", \"\
    zzzz\", \"www\", \"kkkk\", \"abc\"]) == \"zzzz\")"
  status: SyntaxError
  stderr: "/tmp/tmpohqso6ev.swift:14:29: error: 'characters' is unavailable: Please\
    \ use String directly\n    return strings.max { $0.characters.count < $1.characters.count\
    \ }\n                            ^~~~~~~~~~\nSwift.String:5:16: note: 'characters'\
    \ was obsoleted in Swift 5.0\n    public var characters: String { get set }\n\
    \               ^\n/tmp/tmpohqso6ev.swift:14:51: error: 'characters' is unavailable:\
    \ Please use String directly\n    return strings.max { $0.characters.count < $1.characters.count\
    \ }\n                                                  ^~~~~~~~~~\nSwift.String:5:16:\
    \ note: 'characters' was obsoleted in Swift 5.0\n    public var characters: String\
    \ { get set }\n               ^\n"
  stdout: ''
  timestamp: 1660013861
- exit_code: 0
  program: "\n/// Out of array of strings, return the longest one. Return the first\
    \ one in case of multiple\n/// strings of the same length. Return nil in case\
    \ the input array is empty.\n/// >>> longest(strings: [] as [String])\n/// nil\n\
    /// >>> longest(strings: [\"a\", \"b\", \"c\"])\n/// \"a\"\n/// >>> longest(strings:\
    \ [\"a\", \"bb\", \"ccc\"])\n/// \"ccc\"\nfunc longest(strings: [String]) -> String?\
    \ {\n    guard strings.count > 0 else {\n        return nil\n    }\n    var longestString\
    \ = strings[0]\n    for str in strings {\n        if str.count > longestString.count\
    \ {\n            longestString = str\n        }\n    }\n    return longestString\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(longest(strings: [] as [String]) == nil)\nassert(longest(strings:\
    \ [\"x\", \"y\", \"z\"]) == \"x\")\nassert(longest(strings: [\"x\", \"yyy\", \"\
    zzzz\", \"www\", \"kkkk\", \"abc\"]) == \"zzzz\")"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660013860
- exit_code: -4
  program: "\n/// Out of array of strings, return the longest one. Return the first\
    \ one in case of multiple\n/// strings of the same length. Return nil in case\
    \ the input array is empty.\n/// >>> longest(strings: [] as [String])\n/// nil\n\
    /// >>> longest(strings: [\"a\", \"b\", \"c\"])\n/// \"a\"\n/// >>> longest(strings:\
    \ [\"a\", \"bb\", \"ccc\"])\n/// \"ccc\"\nfunc longest(strings: [String]) -> String?\
    \ {\n    return \"nil\"\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(longest(strings:\
    \ [] as [String]) == nil)\nassert(longest(strings: [\"x\", \"y\", \"z\"]) == \"\
    x\")\nassert(longest(strings: [\"x\", \"yyy\", \"zzzz\", \"www\", \"kkkk\", \"\
    abc\"]) == \"zzzz\")"
  status: Exception
  stderr: 'tmpz7vmxbrq/tmpz7vmxbrq.swift:27: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b713f8f5c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b713f5ecb6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b713f5ec988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b713f5eb7b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpz7vmxbrq                        0x000056242ef76468 <unavailable> + 5224

    5    libc.so.6                          0x00002b713fae1460 __libc_start_main +
    245

    6    tmpz7vmxbrq                        0x000056242ef76089 <unavailable> + 4233

    '
  stdout: ''
  timestamp: 1660013861
- exit_code: 0
  program: "\n/// Out of array of strings, return the longest one. Return the first\
    \ one in case of multiple\n/// strings of the same length. Return nil in case\
    \ the input array is empty.\n/// >>> longest(strings: [] as [String])\n/// nil\n\
    /// >>> longest(strings: [\"a\", \"b\", \"c\"])\n/// \"a\"\n/// >>> longest(strings:\
    \ [\"a\", \"bb\", \"ccc\"])\n/// \"ccc\"\nfunc longest(strings: [String]) -> String?\
    \ {\n    guard strings.count > 0 else {\n        return nil\n    }\n    var maxlen\
    \ = strings[0].count\n    var result = strings[0]\n    for string in strings {\n\
    \        if string.count > maxlen {\n            maxlen = string.count\n     \
    \       result = string\n        }\n    }\n    return result\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(longest(strings: [] as [String]) == nil)\nassert(longest(strings:\
    \ [\"x\", \"y\", \"z\"]) == \"x\")\nassert(longest(strings: [\"x\", \"yyy\", \"\
    zzzz\", \"www\", \"kkkk\", \"abc\"]) == \"zzzz\")"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660013861
- exit_code: -4
  program: "\n/// Out of array of strings, return the longest one. Return the first\
    \ one in case of multiple\n/// strings of the same length. Return nil in case\
    \ the input array is empty.\n/// >>> longest(strings: [] as [String])\n/// nil\n\
    /// >>> longest(strings: [\"a\", \"b\", \"c\"])\n/// \"a\"\n/// >>> longest(strings:\
    \ [\"a\", \"bb\", \"ccc\"])\n/// \"ccc\"\nfunc longest(strings: [String]) -> String?\
    \ {\n    return nil\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) ->\
    \ Bool {\n    if left.count != right.count {\n        return false\n    }\n  \
    \  for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(longest(strings: []\
    \ as [String]) == nil)\nassert(longest(strings: [\"x\", \"y\", \"z\"]) == \"x\"\
    )\nassert(longest(strings: [\"x\", \"yyy\", \"zzzz\", \"www\", \"kkkk\", \"abc\"\
    ]) == \"zzzz\")"
  status: Exception
  stderr: 'tmp8uuaa7yn/tmp8uuaa7yn.swift:28: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b29a4e1ac80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b29a4b11b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b29a4b11988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b29a4b107b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmp8uuaa7yn                        0x00005612f3a6879a <unavailable> + 6042

    5    libc.so.6                          0x00002b29a5006460 __libc_start_main +
    245

    6    tmp8uuaa7yn                        0x00005612f3a68089 <unavailable> + 4233

    '
  stdout: ''
  timestamp: 1660013739
- exit_code: 0
  program: "\n/// Out of array of strings, return the longest one. Return the first\
    \ one in case of multiple\n/// strings of the same length. Return nil in case\
    \ the input array is empty.\n/// >>> longest(strings: [] as [String])\n/// nil\n\
    /// >>> longest(strings: [\"a\", \"b\", \"c\"])\n/// \"a\"\n/// >>> longest(strings:\
    \ [\"a\", \"bb\", \"ccc\"])\n/// \"ccc\"\nfunc longest(strings: [String]) -> String?\
    \ {\n    if strings.isEmpty {\n        return nil\n    }\n    var l = strings[0]\n\
    \    for s in strings {\n        if l.count < s.count {\n            l = s\n \
    \       }\n    }\n    return l\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int,\
    \ Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n\
    \    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n          \
    \  return false\n        }\n    }\n    return true\n}\n            \nassert(longest(strings:\
    \ [] as [String]) == nil)\nassert(longest(strings: [\"x\", \"y\", \"z\"]) == \"\
    x\")\nassert(longest(strings: [\"x\", \"yyy\", \"zzzz\", \"www\", \"kkkk\", \"\
    abc\"]) == \"zzzz\")"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660013861
- exit_code: 1
  program: "\n/// Out of array of strings, return the longest one. Return the first\
    \ one in case of multiple\n/// strings of the same length. Return nil in case\
    \ the input array is empty.\n/// >>> longest(strings: [] as [String])\n/// nil\n\
    /// >>> longest(strings: [\"a\", \"b\", \"c\"])\n/// \"a\"\n/// >>> longest(strings:\
    \ [\"a\", \"bb\", \"ccc\"])\n/// \"ccc\"\nfunc longest(strings: [String]) -> String?\
    \ {\n  if strings.isEmpty {\n    return nil\n  }\n  var longestSoFar = strings[0]\n\
    \  for str in strings[1..<strings.count] {\n    if str.characters.count > longestSoFar.characters.count\
    \ {\n      longestSoFar = str\n    }\n  }\n  return longestSoFar\n}\n\n\nfunc\
    \ ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count !=\
    \ right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(longest(strings: [] as [String]) == nil)\nassert(longest(strings:\
    \ [\"x\", \"y\", \"z\"]) == \"x\")\nassert(longest(strings: [\"x\", \"yyy\", \"\
    zzzz\", \"www\", \"kkkk\", \"abc\"]) == \"zzzz\")"
  status: SyntaxError
  stderr: "/tmp/tmpwsm60r73.swift:16:12: error: 'characters' is unavailable: Please\
    \ use String directly\n    if str.characters.count > longestSoFar.characters.count\
    \ {\n           ^~~~~~~~~~\nSwift.String:5:16: note: 'characters' was obsoleted\
    \ in Swift 5.0\n    public var characters: String { get set }\n              \
    \ ^\n/tmp/tmpwsm60r73.swift:16:44: error: 'characters' is unavailable: Please\
    \ use String directly\n    if str.characters.count > longestSoFar.characters.count\
    \ {\n                                           ^~~~~~~~~~\nSwift.String:5:16:\
    \ note: 'characters' was obsoleted in Swift 5.0\n    public var characters: String\
    \ { get set }\n               ^\n"
  stdout: ''
  timestamp: 1660013861
- exit_code: 1
  program: "\n/// Out of array of strings, return the longest one. Return the first\
    \ one in case of multiple\n/// strings of the same length. Return nil in case\
    \ the input array is empty.\n/// >>> longest(strings: [] as [String])\n/// nil\n\
    /// >>> longest(strings: [\"a\", \"b\", \"c\"])\n/// \"a\"\n/// >>> longest(strings:\
    \ [\"a\", \"bb\", \"ccc\"])\n/// \"ccc\"\nfunc longest(strings: [String]) -> String?\
    \ {\n    var longest: String? = nil\n    for string in strings {\n        if let\
    \ l = longest {\n            if string.characters.count > l.characters.count {\n\
    \                longest = string\n            }\n        } else {\n         \
    \   longest = string\n        }\n    }\n    return longest\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(longest(strings: [] as [String]) == nil)\nassert(longest(strings:\
    \ [\"x\", \"y\", \"z\"]) == \"x\")\nassert(longest(strings: [\"x\", \"yyy\", \"\
    zzzz\", \"www\", \"kkkk\", \"abc\"]) == \"zzzz\")"
  status: SyntaxError
  stderr: "/tmp/tmpmnw9m_ec.swift:14:23: error: 'characters' is unavailable: Please\
    \ use String directly\n            if string.characters.count > l.characters.count\
    \ {\n                      ^~~~~~~~~~\nSwift.String:5:16: note: 'characters' was\
    \ obsoleted in Swift 5.0\n    public var characters: String { get set }\n    \
    \           ^\n/tmp/tmpmnw9m_ec.swift:14:44: error: 'characters' is unavailable:\
    \ Please use String directly\n            if string.characters.count > l.characters.count\
    \ {\n                                           ^~~~~~~~~~\nSwift.String:5:16:\
    \ note: 'characters' was obsoleted in Swift 5.0\n    public var characters: String\
    \ { get set }\n               ^\n"
  stdout: ''
  timestamp: 1660013861
- exit_code: 0
  program: "\n/// Out of array of strings, return the longest one. Return the first\
    \ one in case of multiple\n/// strings of the same length. Return nil in case\
    \ the input array is empty.\n/// >>> longest(strings: [] as [String])\n/// nil\n\
    /// >>> longest(strings: [\"a\", \"b\", \"c\"])\n/// \"a\"\n/// >>> longest(strings:\
    \ [\"a\", \"bb\", \"ccc\"])\n/// \"ccc\"\nfunc longest(strings: [String]) -> String?\
    \ {\n    guard let longest = strings.max(by: { $0.count < $1.count }) else {\n\
    \        return nil\n    }\n    return longest\n}\n\n\nfunc ==(left: [(Int, Int)],\
    \ right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n       \
    \ return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r\
    \ {\n            return false\n        }\n    }\n    return true\n}\n        \
    \    \nassert(longest(strings: [] as [String]) == nil)\nassert(longest(strings:\
    \ [\"x\", \"y\", \"z\"]) == \"x\")\nassert(longest(strings: [\"x\", \"yyy\", \"\
    zzzz\", \"www\", \"kkkk\", \"abc\"]) == \"zzzz\")"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660013860
- exit_code: 0
  program: "\n/// Out of array of strings, return the longest one. Return the first\
    \ one in case of multiple\n/// strings of the same length. Return nil in case\
    \ the input array is empty.\n/// >>> longest(strings: [] as [String])\n/// nil\n\
    /// >>> longest(strings: [\"a\", \"b\", \"c\"])\n/// \"a\"\n/// >>> longest(strings:\
    \ [\"a\", \"bb\", \"ccc\"])\n/// \"ccc\"\nfunc longest(strings: [String]) -> String?\
    \ {\n    if strings.isEmpty {\n        return nil\n    }\n    var currentLongest:\
    \ String = strings[0]\n    for string in strings {\n        if string.count >\
    \ currentLongest.count {\n            currentLongest = string\n        }\n   \
    \ }\n    return currentLongest\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int,\
    \ Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n\
    \    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n          \
    \  return false\n        }\n    }\n    return true\n}\n            \nassert(longest(strings:\
    \ [] as [String]) == nil)\nassert(longest(strings: [\"x\", \"y\", \"z\"]) == \"\
    x\")\nassert(longest(strings: [\"x\", \"yyy\", \"zzzz\", \"www\", \"kkkk\", \"\
    abc\"]) == \"zzzz\")"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660013861
- exit_code: 0
  program: "\n/// Out of array of strings, return the longest one. Return the first\
    \ one in case of multiple\n/// strings of the same length. Return nil in case\
    \ the input array is empty.\n/// >>> longest(strings: [] as [String])\n/// nil\n\
    /// >>> longest(strings: [\"a\", \"b\", \"c\"])\n/// \"a\"\n/// >>> longest(strings:\
    \ [\"a\", \"bb\", \"ccc\"])\n/// \"ccc\"\nfunc longest(strings: [String]) -> String?\
    \ {\n    if strings.isEmpty {\n        return nil\n    }\n    var longestWord\
    \ = strings[0]\n    for i in 0...strings.count-1 {\n        if strings[i].count\
    \ > longestWord.count {\n            longestWord = strings[i]\n        }\n   \
    \ }\n    return longestWord\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int,\
    \ Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n\
    \    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n          \
    \  return false\n        }\n    }\n    return true\n}\n            \nassert(longest(strings:\
    \ [] as [String]) == nil)\nassert(longest(strings: [\"x\", \"y\", \"z\"]) == \"\
    x\")\nassert(longest(strings: [\"x\", \"yyy\", \"zzzz\", \"www\", \"kkkk\", \"\
    abc\"]) == \"zzzz\")"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660013861
- exit_code: 0
  program: "\n/// Out of array of strings, return the longest one. Return the first\
    \ one in case of multiple\n/// strings of the same length. Return nil in case\
    \ the input array is empty.\n/// >>> longest(strings: [] as [String])\n/// nil\n\
    /// >>> longest(strings: [\"a\", \"b\", \"c\"])\n/// \"a\"\n/// >>> longest(strings:\
    \ [\"a\", \"bb\", \"ccc\"])\n/// \"ccc\"\nfunc longest(strings: [String]) -> String?\
    \ {\n    if strings.isEmpty {\n        return nil\n    }\n    if strings.count\
    \ == 1 {\n        return strings[0]\n    }\n    var longest = strings[0]\n   \
    \ for string in strings {\n        if string.count > longest.count {\n       \
    \     longest = string\n        }\n    }\n    return longest\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(longest(strings: [] as [String]) == nil)\nassert(longest(strings:\
    \ [\"x\", \"y\", \"z\"]) == \"x\")\nassert(longest(strings: [\"x\", \"yyy\", \"\
    zzzz\", \"www\", \"kkkk\", \"abc\"]) == \"zzzz\")"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660013861
- exit_code: 0
  program: "\n/// Out of array of strings, return the longest one. Return the first\
    \ one in case of multiple\n/// strings of the same length. Return nil in case\
    \ the input array is empty.\n/// >>> longest(strings: [] as [String])\n/// nil\n\
    /// >>> longest(strings: [\"a\", \"b\", \"c\"])\n/// \"a\"\n/// >>> longest(strings:\
    \ [\"a\", \"bb\", \"ccc\"])\n/// \"ccc\"\nfunc longest(strings: [String]) -> String?\
    \ {\n    // TODO: Write some code to get the expected result!\n    if strings.isEmpty\
    \ {\n        return nil\n    }\n    var longest = strings[0]\n    for i in 1..<strings.count\
    \ {\n        if strings[i].count > longest.count {\n            longest = strings[i]\n\
    \        }\n    }\n    return longest\n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(longest(strings: [] as [String]) == nil)\nassert(longest(strings: [\"x\"\
    , \"y\", \"z\"]) == \"x\")\nassert(longest(strings: [\"x\", \"yyy\", \"zzzz\"\
    , \"www\", \"kkkk\", \"abc\"]) == \"zzzz\")"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660013861
- exit_code: 0
  program: "\n/// Out of array of strings, return the longest one. Return the first\
    \ one in case of multiple\n/// strings of the same length. Return nil in case\
    \ the input array is empty.\n/// >>> longest(strings: [] as [String])\n/// nil\n\
    /// >>> longest(strings: [\"a\", \"b\", \"c\"])\n/// \"a\"\n/// >>> longest(strings:\
    \ [\"a\", \"bb\", \"ccc\"])\n/// \"ccc\"\nfunc longest(strings: [String]) -> String?\
    \ {\n    // TODO:\n    if strings.isEmpty {\n        return nil\n    }\n    var\
    \ longest = strings[0]\n    for string in strings {\n        if string.count >\
    \ longest.count {\n            longest = string\n        }\n    }\n    return\
    \ longest\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n\
    \    if left.count != right.count {\n        return false\n    }\n    for (l,\
    \ r) in zip(left, right) {\n        if l != r {\n            return false\n  \
    \      }\n    }\n    return true\n}\n            \nassert(longest(strings: []\
    \ as [String]) == nil)\nassert(longest(strings: [\"x\", \"y\", \"z\"]) == \"x\"\
    )\nassert(longest(strings: [\"x\", \"yyy\", \"zzzz\", \"www\", \"kkkk\", \"abc\"\
    ]) == \"zzzz\")"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660013861
- exit_code: -4
  program: "\n/// Out of array of strings, return the longest one. Return the first\
    \ one in case of multiple\n/// strings of the same length. Return nil in case\
    \ the input array is empty.\n/// >>> longest(strings: [] as [String])\n/// nil\n\
    /// >>> longest(strings: [\"a\", \"b\", \"c\"])\n/// \"a\"\n/// >>> longest(strings:\
    \ [\"a\", \"bb\", \"ccc\"])\n/// \"ccc\"\nfunc longest(strings: [String]) -> String?\
    \ {\n    // todo\n    return nil\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int,\
    \ Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n\
    \    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n          \
    \  return false\n        }\n    }\n    return true\n}\n            \nassert(longest(strings:\
    \ [] as [String]) == nil)\nassert(longest(strings: [\"x\", \"y\", \"z\"]) == \"\
    x\")\nassert(longest(strings: [\"x\", \"yyy\", \"zzzz\", \"www\", \"kkkk\", \"\
    abc\"]) == \"zzzz\")"
  status: Exception
  stderr: 'tmp9cme4np7/tmp9cme4np7.swift:29: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b4b62043c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b4b61d3ab6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b4b61d3a988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b4b61d397b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmp9cme4np7                        0x0000558985b1f79a <unavailable> + 6042

    5    libc.so.6                          0x00002b4b6222f460 __libc_start_main +
    245

    6    tmp9cme4np7                        0x0000558985b1f089 <unavailable> + 4233

    '
  stdout: ''
  timestamp: 1660013861
- exit_code: 1
  program: "\n/// Out of array of strings, return the longest one. Return the first\
    \ one in case of multiple\n/// strings of the same length. Return nil in case\
    \ the input array is empty.\n/// >>> longest(strings: [] as [String])\n/// nil\n\
    /// >>> longest(strings: [\"a\", \"b\", \"c\"])\n/// \"a\"\n/// >>> longest(strings:\
    \ [\"a\", \"bb\", \"ccc\"])\n/// \"ccc\"\nfunc longest(strings: [String]) -> String?\
    \ {\n    \n    if strings.isEmpty {\n        return nil\n    }\n    \n    var\
    \ max: Int = 0\n    var maxString: String = \"\"\n    \n    for str in strings\
    \ {\n        if str.characters.count > max {\n            max = str.characters.count\n\
    \            maxString = str\n        }\n    }\n    \n    return maxString\n}\n\
    \n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(longest(strings: [] as [String]) == nil)\nassert(longest(strings:\
    \ [\"x\", \"y\", \"z\"]) == \"x\")\nassert(longest(strings: [\"x\", \"yyy\", \"\
    zzzz\", \"www\", \"kkkk\", \"abc\"]) == \"zzzz\")"
  status: SyntaxError
  stderr: "/tmp/tmp7l5w1akx.swift:20:16: error: 'characters' is unavailable: Please\
    \ use String directly\n        if str.characters.count > max {\n             \
    \  ^~~~~~~~~~\nSwift.String:5:16: note: 'characters' was obsoleted in Swift 5.0\n\
    \    public var characters: String { get set }\n               ^\n/tmp/tmp7l5w1akx.swift:21:23:\
    \ error: 'characters' is unavailable: Please use String directly\n           \
    \ max = str.characters.count\n                      ^~~~~~~~~~\nSwift.String:5:16:\
    \ note: 'characters' was obsoleted in Swift 5.0\n    public var characters: String\
    \ { get set }\n               ^\n"
  stdout: ''
  timestamp: 1660013861
- exit_code: 0
  program: "\n/// Out of array of strings, return the longest one. Return the first\
    \ one in case of multiple\n/// strings of the same length. Return nil in case\
    \ the input array is empty.\n/// >>> longest(strings: [] as [String])\n/// nil\n\
    /// >>> longest(strings: [\"a\", \"b\", \"c\"])\n/// \"a\"\n/// >>> longest(strings:\
    \ [\"a\", \"bb\", \"ccc\"])\n/// \"ccc\"\nfunc longest(strings: [String]) -> String?\
    \ {\n    guard !strings.isEmpty else { return nil }\n    return strings.max {\
    \ $0.count < $1.count }\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(longest(strings:\
    \ [] as [String]) == nil)\nassert(longest(strings: [\"x\", \"y\", \"z\"]) == \"\
    x\")\nassert(longest(strings: [\"x\", \"yyy\", \"zzzz\", \"www\", \"kkkk\", \"\
    abc\"]) == \"zzzz\")"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660013861
- exit_code: 0
  program: "\n/// Out of array of strings, return the longest one. Return the first\
    \ one in case of multiple\n/// strings of the same length. Return nil in case\
    \ the input array is empty.\n/// >>> longest(strings: [] as [String])\n/// nil\n\
    /// >>> longest(strings: [\"a\", \"b\", \"c\"])\n/// \"a\"\n/// >>> longest(strings:\
    \ [\"a\", \"bb\", \"ccc\"])\n/// \"ccc\"\nfunc longest(strings: [String]) -> String?\
    \ {\n    if strings.isEmpty {\n        return nil\n    }\n    var longest = strings[0]\n\
    \    for string in strings {\n        if string.count > longest.count {\n    \
    \        longest = string\n        }\n    }\n    return longest\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(longest(strings: [] as [String]) == nil)\nassert(longest(strings:\
    \ [\"x\", \"y\", \"z\"]) == \"x\")\nassert(longest(strings: [\"x\", \"yyy\", \"\
    zzzz\", \"www\", \"kkkk\", \"abc\"]) == \"zzzz\")"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660013739
- exit_code: -4
  program: "\n/// Out of array of strings, return the longest one. Return the first\
    \ one in case of multiple\n/// strings of the same length. Return nil in case\
    \ the input array is empty.\n/// >>> longest(strings: [] as [String])\n/// nil\n\
    /// >>> longest(strings: [\"a\", \"b\", \"c\"])\n/// \"a\"\n/// >>> longest(strings:\
    \ [\"a\", \"bb\", \"ccc\"])\n/// \"ccc\"\nfunc longest(strings: [String]) -> String?\
    \ {\n    // TODO\n    return nil\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int,\
    \ Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n\
    \    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n          \
    \  return false\n        }\n    }\n    return true\n}\n            \nassert(longest(strings:\
    \ [] as [String]) == nil)\nassert(longest(strings: [\"x\", \"y\", \"z\"]) == \"\
    x\")\nassert(longest(strings: [\"x\", \"yyy\", \"zzzz\", \"www\", \"kkkk\", \"\
    abc\"]) == \"zzzz\")"
  status: Exception
  stderr: 'tmpryhtcqm7/tmpryhtcqm7.swift:29: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b6f48352c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b6f48049b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b6f48049988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b6f480487b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpryhtcqm7                        0x0000559c6329579a <unavailable> + 6042

    5    libc.so.6                          0x00002b6f4853e460 __libc_start_main +
    245

    6    tmpryhtcqm7                        0x0000559c63295089 <unavailable> + 4233

    '
  stdout: ''
  timestamp: 1660013861
- exit_code: 0
  program: "\n/// Out of array of strings, return the longest one. Return the first\
    \ one in case of multiple\n/// strings of the same length. Return nil in case\
    \ the input array is empty.\n/// >>> longest(strings: [] as [String])\n/// nil\n\
    /// >>> longest(strings: [\"a\", \"b\", \"c\"])\n/// \"a\"\n/// >>> longest(strings:\
    \ [\"a\", \"bb\", \"ccc\"])\n/// \"ccc\"\nfunc longest(strings: [String]) -> String?\
    \ {\n    return strings.sorted(by: { $0.count > $1.count }).first\n}\n\n\nfunc\
    \ ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count !=\
    \ right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(longest(strings: [] as [String]) == nil)\nassert(longest(strings:\
    \ [\"x\", \"y\", \"z\"]) == \"x\")\nassert(longest(strings: [\"x\", \"yyy\", \"\
    zzzz\", \"www\", \"kkkk\", \"abc\"]) == \"zzzz\")"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660013861
- exit_code: 0
  program: "\n/// Out of array of strings, return the longest one. Return the first\
    \ one in case of multiple\n/// strings of the same length. Return nil in case\
    \ the input array is empty.\n/// >>> longest(strings: [] as [String])\n/// nil\n\
    /// >>> longest(strings: [\"a\", \"b\", \"c\"])\n/// \"a\"\n/// >>> longest(strings:\
    \ [\"a\", \"bb\", \"ccc\"])\n/// \"ccc\"\nfunc longest(strings: [String]) -> String?\
    \ {\n    guard strings.count > 0 else {\n        return nil\n    }\n    var longestString\
    \ = strings[0]\n    for string in strings {\n        if string.count > longestString.count\
    \ {\n            longestString = string\n        }\n    }\n    return longestString\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(longest(strings: [] as [String]) == nil)\nassert(longest(strings:\
    \ [\"x\", \"y\", \"z\"]) == \"x\")\nassert(longest(strings: [\"x\", \"yyy\", \"\
    zzzz\", \"www\", \"kkkk\", \"abc\"]) == \"zzzz\")"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660013739
- exit_code: 1
  program: "\n/// Out of array of strings, return the longest one. Return the first\
    \ one in case of multiple\n/// strings of the same length. Return nil in case\
    \ the input array is empty.\n/// >>> longest(strings: [] as [String])\n/// nil\n\
    /// >>> longest(strings: [\"a\", \"b\", \"c\"])\n/// \"a\"\n/// >>> longest(strings:\
    \ [\"a\", \"bb\", \"ccc\"])\n/// \"ccc\"\nfunc longest(strings: [String]) -> String?\
    \ {\n    if let firstString = strings.first {\n        return strings.reduce(firstString)\
    \ { currentLongest, nextString in\n            if currentLongest.characters.count\
    \ > nextString.characters.count {\n                return currentLongest\n   \
    \         } else {\n                return nextString\n            }\n       \
    \ }\n    } else {\n        return nil\n    }\n}\n\n\nfunc ==(left: [(Int, Int)],\
    \ right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n       \
    \ return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r\
    \ {\n            return false\n        }\n    }\n    return true\n}\n        \
    \    \nassert(longest(strings: [] as [String]) == nil)\nassert(longest(strings:\
    \ [\"x\", \"y\", \"z\"]) == \"x\")\nassert(longest(strings: [\"x\", \"yyy\", \"\
    zzzz\", \"www\", \"kkkk\", \"abc\"]) == \"zzzz\")"
  status: SyntaxError
  stderr: "/tmp/tmpos0jfehk.swift:13:31: error: 'characters' is unavailable: Please\
    \ use String directly\n            if currentLongest.characters.count > nextString.characters.count\
    \ {\n                              ^~~~~~~~~~\nSwift.String:5:16: note: 'characters'\
    \ was obsoleted in Swift 5.0\n    public var characters: String { get set }\n\
    \               ^\n/tmp/tmpos0jfehk.swift:13:61: error: 'characters' is unavailable:\
    \ Please use String directly\n            if currentLongest.characters.count >\
    \ nextString.characters.count {\n                                            \
    \                ^~~~~~~~~~\nSwift.String:5:16: note: 'characters' was obsoleted\
    \ in Swift 5.0\n    public var characters: String { get set }\n              \
    \ ^\n"
  stdout: ''
  timestamp: 1660013861
- exit_code: 1
  program: "\n/// Out of array of strings, return the longest one. Return the first\
    \ one in case of multiple\n/// strings of the same length. Return nil in case\
    \ the input array is empty.\n/// >>> longest(strings: [] as [String])\n/// nil\n\
    /// >>> longest(strings: [\"a\", \"b\", \"c\"])\n/// \"a\"\n/// >>> longest(strings:\
    \ [\"a\", \"bb\", \"ccc\"])\n/// \"ccc\"\nfunc longest(strings: [String]) -> String?\
    \ {\n    guard !strings.isEmpty else { return nil }\n    return strings.reduce(strings[0])\
    \ { $1.characters.count > $0.characters.count ? $1 : $0 }\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(longest(strings: [] as [String]) == nil)\nassert(longest(strings:\
    \ [\"x\", \"y\", \"z\"]) == \"x\")\nassert(longest(strings: [\"x\", \"yyy\", \"\
    zzzz\", \"www\", \"kkkk\", \"abc\"]) == \"zzzz\")"
  status: SyntaxError
  stderr: "/tmp/tmpspphajt4.swift:12:44: error: 'characters' is unavailable: Please\
    \ use String directly\n    return strings.reduce(strings[0]) { $1.characters.count\
    \ > $0.characters.count ? $1 : $0 }\n                                        \
    \   ^~~~~~~~~~\nSwift.String:5:16: note: 'characters' was obsoleted in Swift 5.0\n\
    \    public var characters: String { get set }\n               ^\n/tmp/tmpspphajt4.swift:12:66:\
    \ error: 'characters' is unavailable: Please use String directly\n    return strings.reduce(strings[0])\
    \ { $1.characters.count > $0.characters.count ? $1 : $0 }\n                  \
    \                                               ^~~~~~~~~~\nSwift.String:5:16:\
    \ note: 'characters' was obsoleted in Swift 5.0\n    public var characters: String\
    \ { get set }\n               ^\n"
  stdout: ''
  timestamp: 1660013861
- exit_code: 0
  program: "\n/// Out of array of strings, return the longest one. Return the first\
    \ one in case of multiple\n/// strings of the same length. Return nil in case\
    \ the input array is empty.\n/// >>> longest(strings: [] as [String])\n/// nil\n\
    /// >>> longest(strings: [\"a\", \"b\", \"c\"])\n/// \"a\"\n/// >>> longest(strings:\
    \ [\"a\", \"bb\", \"ccc\"])\n/// \"ccc\"\nfunc longest(strings: [String]) -> String?\
    \ {\n    guard !strings.isEmpty else { return nil }\n    var maxString: String?\
    \ = nil\n    for string in strings {\n        if maxString == nil || string.count\
    \ > maxString!.count {\n            maxString = string\n        }\n    }\n   \
    \ return maxString\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) ->\
    \ Bool {\n    if left.count != right.count {\n        return false\n    }\n  \
    \  for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(longest(strings: []\
    \ as [String]) == nil)\nassert(longest(strings: [\"x\", \"y\", \"z\"]) == \"x\"\
    )\nassert(longest(strings: [\"x\", \"yyy\", \"zzzz\", \"www\", \"kkkk\", \"abc\"\
    ]) == \"zzzz\")"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660013861
- exit_code: 0
  program: "\n/// Out of array of strings, return the longest one. Return the first\
    \ one in case of multiple\n/// strings of the same length. Return nil in case\
    \ the input array is empty.\n/// >>> longest(strings: [] as [String])\n/// nil\n\
    /// >>> longest(strings: [\"a\", \"b\", \"c\"])\n/// \"a\"\n/// >>> longest(strings:\
    \ [\"a\", \"bb\", \"ccc\"])\n/// \"ccc\"\nfunc longest(strings: [String]) -> String?\
    \ {\n  guard strings.count > 0 else { return nil }\n  var longest: String = strings[0]\n\
    \  for string in strings[1..<strings.count] {\n    if string.count > longest.count\
    \ {\n      longest = string\n    }\n  }\n  return longest\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(longest(strings: [] as [String]) == nil)\nassert(longest(strings:\
    \ [\"x\", \"y\", \"z\"]) == \"x\")\nassert(longest(strings: [\"x\", \"yyy\", \"\
    zzzz\", \"www\", \"kkkk\", \"abc\"]) == \"zzzz\")"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660013861
- exit_code: 1
  program: "\n/// Out of array of strings, return the longest one. Return the first\
    \ one in case of multiple\n/// strings of the same length. Return nil in case\
    \ the input array is empty.\n/// >>> longest(strings: [] as [String])\n/// nil\n\
    /// >>> longest(strings: [\"a\", \"b\", \"c\"])\n/// \"a\"\n/// >>> longest(strings:\
    \ [\"a\", \"bb\", \"ccc\"])\n/// \"ccc\"\nfunc longest(strings: [String]) -> String?\
    \ {\n    return strings.maxElement(by: {\n        $0.characters.count < $1.characters.count\n\
    \    })\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n \
    \   if left.count != right.count {\n        return false\n    }\n    for (l, r)\
    \ in zip(left, right) {\n        if l != r {\n            return false\n     \
    \   }\n    }\n    return true\n}\n            \nassert(longest(strings: [] as\
    \ [String]) == nil)\nassert(longest(strings: [\"x\", \"y\", \"z\"]) == \"x\")\n\
    assert(longest(strings: [\"x\", \"yyy\", \"zzzz\", \"www\", \"kkkk\", \"abc\"\
    ]) == \"zzzz\")"
  status: SyntaxError
  stderr: "/tmp/tmp9zwbsbes.swift:11:20: error: value of type '[String]' has no member\
    \ 'maxElement'\n    return strings.maxElement(by: {\n           ~~~~~~~ ^~~~~~~~~~\n"
  stdout: ''
  timestamp: 1660013861
- exit_code: 0
  program: "\n/// Out of array of strings, return the longest one. Return the first\
    \ one in case of multiple\n/// strings of the same length. Return nil in case\
    \ the input array is empty.\n/// >>> longest(strings: [] as [String])\n/// nil\n\
    /// >>> longest(strings: [\"a\", \"b\", \"c\"])\n/// \"a\"\n/// >>> longest(strings:\
    \ [\"a\", \"bb\", \"ccc\"])\n/// \"ccc\"\nfunc longest(strings: [String]) -> String?\
    \ {\n    var longest: String? = nil\n    for string in strings {\n        if longest\
    \ == nil || string.count > longest!.count {\n            longest = string\n  \
    \      }\n    }\n    return longest\n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(longest(strings: [] as [String]) == nil)\nassert(longest(strings: [\"x\"\
    , \"y\", \"z\"]) == \"x\")\nassert(longest(strings: [\"x\", \"yyy\", \"zzzz\"\
    , \"www\", \"kkkk\", \"abc\"]) == \"zzzz\")"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660013739
- exit_code: 0
  program: "\n/// Out of array of strings, return the longest one. Return the first\
    \ one in case of multiple\n/// strings of the same length. Return nil in case\
    \ the input array is empty.\n/// >>> longest(strings: [] as [String])\n/// nil\n\
    /// >>> longest(strings: [\"a\", \"b\", \"c\"])\n/// \"a\"\n/// >>> longest(strings:\
    \ [\"a\", \"bb\", \"ccc\"])\n/// \"ccc\"\nfunc longest(strings: [String]) -> String?\
    \ {\n    return strings.reduce(nil) {\n        return $0 == nil || $0!.count <\
    \ $1.count ? $1 : $0\n    }\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int,\
    \ Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n\
    \    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n          \
    \  return false\n        }\n    }\n    return true\n}\n            \nassert(longest(strings:\
    \ [] as [String]) == nil)\nassert(longest(strings: [\"x\", \"y\", \"z\"]) == \"\
    x\")\nassert(longest(strings: [\"x\", \"yyy\", \"zzzz\", \"www\", \"kkkk\", \"\
    abc\"]) == \"zzzz\")"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660013861
- exit_code: 1
  program: "\n/// Out of array of strings, return the longest one. Return the first\
    \ one in case of multiple\n/// strings of the same length. Return nil in case\
    \ the input array is empty.\n/// >>> longest(strings: [] as [String])\n/// nil\n\
    /// >>> longest(strings: [\"a\", \"b\", \"c\"])\n/// \"a\"\n/// >>> longest(strings:\
    \ [\"a\", \"bb\", \"ccc\"])\n/// \"ccc\"\nfunc longest(strings: [String]) -> String?\
    \ {\n    // we could use reduce but this is the canonical implementation of reduce\
    \ using for-in:\n    var longest = strings.first\n    for string in strings {\n\
    \        if let longest = longest {\n            longest = (string.count > longest.count)\
    \ ? string : longest\n        } else {\n            longest = string\n       \
    \ }\n    }\n    return longest\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int,\
    \ Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n\
    \    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n          \
    \  return false\n        }\n    }\n    return true\n}\n            \nassert(longest(strings:\
    \ [] as [String]) == nil)\nassert(longest(strings: [\"x\", \"y\", \"z\"]) == \"\
    x\")\nassert(longest(strings: [\"x\", \"yyy\", \"zzzz\", \"www\", \"kkkk\", \"\
    abc\"]) == \"zzzz\")"
  status: SyntaxError
  stderr: "/tmp/tmpb6857wsp.swift:15:13: error: cannot assign to value: 'longest'\
    \ is a 'let' constant\n            longest = (string.count > longest.count) ?\
    \ string : longest\n            ^~~~~~~\n"
  stdout: ''
  timestamp: 1660013861
- exit_code: 0
  program: "\n/// Out of array of strings, return the longest one. Return the first\
    \ one in case of multiple\n/// strings of the same length. Return nil in case\
    \ the input array is empty.\n/// >>> longest(strings: [] as [String])\n/// nil\n\
    /// >>> longest(strings: [\"a\", \"b\", \"c\"])\n/// \"a\"\n/// >>> longest(strings:\
    \ [\"a\", \"bb\", \"ccc\"])\n/// \"ccc\"\nfunc longest(strings: [String]) -> String?\
    \ {\n    if strings.isEmpty {\n        return nil\n    }\n    var maxLength =\
    \ 0\n    var result: String? = nil\n    for string in strings {\n        if string.count\
    \ > maxLength {\n            maxLength = string.count\n            result = string\n\
    \        }\n    }\n    return result\n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(longest(strings: [] as [String]) == nil)\nassert(longest(strings: [\"x\"\
    , \"y\", \"z\"]) == \"x\")\nassert(longest(strings: [\"x\", \"yyy\", \"zzzz\"\
    , \"www\", \"kkkk\", \"abc\"]) == \"zzzz\")"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660013861
- exit_code: 0
  program: "\n/// Out of array of strings, return the longest one. Return the first\
    \ one in case of multiple\n/// strings of the same length. Return nil in case\
    \ the input array is empty.\n/// >>> longest(strings: [] as [String])\n/// nil\n\
    /// >>> longest(strings: [\"a\", \"b\", \"c\"])\n/// \"a\"\n/// >>> longest(strings:\
    \ [\"a\", \"bb\", \"ccc\"])\n/// \"ccc\"\nfunc longest(strings: [String]) -> String?\
    \ {\n    guard strings.count > 0 else {\n        return nil\n    }\n    var longest:\
    \ String = strings[0]\n    for i in 1..<strings.count {\n        if strings[i].count\
    \ > longest.count {\n            longest = strings[i]\n        }\n    }\n    return\
    \ longest\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n\
    \    if left.count != right.count {\n        return false\n    }\n    for (l,\
    \ r) in zip(left, right) {\n        if l != r {\n            return false\n  \
    \      }\n    }\n    return true\n}\n            \nassert(longest(strings: []\
    \ as [String]) == nil)\nassert(longest(strings: [\"x\", \"y\", \"z\"]) == \"x\"\
    )\nassert(longest(strings: [\"x\", \"yyy\", \"zzzz\", \"www\", \"kkkk\", \"abc\"\
    ]) == \"zzzz\")"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660013861
- exit_code: 0
  program: "\n/// Out of array of strings, return the longest one. Return the first\
    \ one in case of multiple\n/// strings of the same length. Return nil in case\
    \ the input array is empty.\n/// >>> longest(strings: [] as [String])\n/// nil\n\
    /// >>> longest(strings: [\"a\", \"b\", \"c\"])\n/// \"a\"\n/// >>> longest(strings:\
    \ [\"a\", \"bb\", \"ccc\"])\n/// \"ccc\"\nfunc longest(strings: [String]) -> String?\
    \ {\n    guard let string = strings.first else {\n        return nil\n    }\n\
    \    var longestString = string\n    var counter = 1\n    while counter < strings.count\
    \ {\n        if longestString.count < strings[counter].count {\n            longestString\
    \ = strings[counter]\n        }\n        counter += 1\n    }\n    return longestString\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(longest(strings: [] as [String]) == nil)\nassert(longest(strings:\
    \ [\"x\", \"y\", \"z\"]) == \"x\")\nassert(longest(strings: [\"x\", \"yyy\", \"\
    zzzz\", \"www\", \"kkkk\", \"abc\"]) == \"zzzz\")"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660013861
- exit_code: 0
  program: "\n/// Out of array of strings, return the longest one. Return the first\
    \ one in case of multiple\n/// strings of the same length. Return nil in case\
    \ the input array is empty.\n/// >>> longest(strings: [] as [String])\n/// nil\n\
    /// >>> longest(strings: [\"a\", \"b\", \"c\"])\n/// \"a\"\n/// >>> longest(strings:\
    \ [\"a\", \"bb\", \"ccc\"])\n/// \"ccc\"\nfunc longest(strings: [String]) -> String?\
    \ {\n  guard let maxElement = strings.max(by: { $0.count < $1.count }) else {\n\
    \    return nil\n  }\n  return maxElement\n}\n\n\nfunc ==(left: [(Int, Int)],\
    \ right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n       \
    \ return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r\
    \ {\n            return false\n        }\n    }\n    return true\n}\n        \
    \    \nassert(longest(strings: [] as [String]) == nil)\nassert(longest(strings:\
    \ [\"x\", \"y\", \"z\"]) == \"x\")\nassert(longest(strings: [\"x\", \"yyy\", \"\
    zzzz\", \"www\", \"kkkk\", \"abc\"]) == \"zzzz\")"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660013861
- exit_code: 0
  program: "\n/// Out of array of strings, return the longest one. Return the first\
    \ one in case of multiple\n/// strings of the same length. Return nil in case\
    \ the input array is empty.\n/// >>> longest(strings: [] as [String])\n/// nil\n\
    /// >>> longest(strings: [\"a\", \"b\", \"c\"])\n/// \"a\"\n/// >>> longest(strings:\
    \ [\"a\", \"bb\", \"ccc\"])\n/// \"ccc\"\nfunc longest(strings: [String]) -> String?\
    \ {\n    var longestString: String?\n    for string in strings {\n        if longestString\
    \ == nil || (string.count > longestString!.count) {\n            longestString\
    \ = string\n        }\n    }\n    return longestString\n}\n\n\nfunc ==(left: [(Int,\
    \ Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n\
    \        return false\n    }\n    for (l, r) in zip(left, right) {\n        if\
    \ l != r {\n            return false\n        }\n    }\n    return true\n}\n \
    \           \nassert(longest(strings: [] as [String]) == nil)\nassert(longest(strings:\
    \ [\"x\", \"y\", \"z\"]) == \"x\")\nassert(longest(strings: [\"x\", \"yyy\", \"\
    zzzz\", \"www\", \"kkkk\", \"abc\"]) == \"zzzz\")"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660013861
- exit_code: 1
  program: "\n/// Out of array of strings, return the longest one. Return the first\
    \ one in case of multiple\n/// strings of the same length. Return nil in case\
    \ the input array is empty.\n/// >>> longest(strings: [] as [String])\n/// nil\n\
    /// >>> longest(strings: [\"a\", \"b\", \"c\"])\n/// \"a\"\n/// >>> longest(strings:\
    \ [\"a\", \"bb\", \"ccc\"])\n/// \"ccc\"\nfunc longest(strings: [String]) -> String?\
    \ {\n    var longestString: String?\n    for string in strings {\n        if let\
    \ longestString = longestString {\n            if longestString.characters.count\
    \ < string.characters.count {\n                longestString = string\n      \
    \      }\n        } else {\n            longestString = string\n        }\n  \
    \  }\n    return longestString\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int,\
    \ Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n\
    \    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n          \
    \  return false\n        }\n    }\n    return true\n}\n            \nassert(longest(strings:\
    \ [] as [String]) == nil)\nassert(longest(strings: [\"x\", \"y\", \"z\"]) == \"\
    x\")\nassert(longest(strings: [\"x\", \"yyy\", \"zzzz\", \"www\", \"kkkk\", \"\
    abc\"]) == \"zzzz\")"
  status: SyntaxError
  stderr: "/tmp/tmpoetp26qo.swift:14:30: error: 'characters' is unavailable: Please\
    \ use String directly\n            if longestString.characters.count < string.characters.count\
    \ {\n                             ^~~~~~~~~~\nSwift.String:5:16: note: 'characters'\
    \ was obsoleted in Swift 5.0\n    public var characters: String { get set }\n\
    \               ^\n/tmp/tmpoetp26qo.swift:14:56: error: 'characters' is unavailable:\
    \ Please use String directly\n            if longestString.characters.count <\
    \ string.characters.count {\n                                                \
    \       ^~~~~~~~~~\nSwift.String:5:16: note: 'characters' was obsoleted in Swift\
    \ 5.0\n    public var characters: String { get set }\n               ^\n/tmp/tmpoetp26qo.swift:15:17:\
    \ error: cannot assign to value: 'longestString' is a 'let' constant\n       \
    \         longestString = string\n                ^~~~~~~~~~~~~\n"
  stdout: ''
  timestamp: 1660013861
- exit_code: -4
  program: "\n/// Out of array of strings, return the longest one. Return the first\
    \ one in case of multiple\n/// strings of the same length. Return nil in case\
    \ the input array is empty.\n/// >>> longest(strings: [] as [String])\n/// nil\n\
    /// >>> longest(strings: [\"a\", \"b\", \"c\"])\n/// \"a\"\n/// >>> longest(strings:\
    \ [\"a\", \"bb\", \"ccc\"])\n/// \"ccc\"\nfunc longest(strings: [String]) -> String?\
    \ {\n    return strings.reduce(nil) { $0 != nil && $0!.count > $1.count ? $0 :\
    \ $1 }\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n  \
    \  if left.count != right.count {\n        return false\n    }\n    for (l, r)\
    \ in zip(left, right) {\n        if l != r {\n            return false\n     \
    \   }\n    }\n    return true\n}\n            \nassert(longest(strings: [] as\
    \ [String]) == nil)\nassert(longest(strings: [\"x\", \"y\", \"z\"]) == \"x\")\n\
    assert(longest(strings: [\"x\", \"yyy\", \"zzzz\", \"www\", \"kkkk\", \"abc\"\
    ]) == \"zzzz\")"
  status: Exception
  stderr: 'tmp76brg56n/tmp76brg56n.swift:28: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b10bed15c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b10bea0cb6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b10bea0c988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b10bea0b7b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmp76brg56n                        0x000056442e69f8ea <unavailable> + 6378

    5    libc.so.6                          0x00002b10bef01460 __libc_start_main +
    245

    6    tmp76brg56n                        0x000056442e69f1d9 <unavailable> + 4569

    '
  stdout: ''
  timestamp: 1660013861
- exit_code: 0
  program: "\n/// Out of array of strings, return the longest one. Return the first\
    \ one in case of multiple\n/// strings of the same length. Return nil in case\
    \ the input array is empty.\n/// >>> longest(strings: [] as [String])\n/// nil\n\
    /// >>> longest(strings: [\"a\", \"b\", \"c\"])\n/// \"a\"\n/// >>> longest(strings:\
    \ [\"a\", \"bb\", \"ccc\"])\n/// \"ccc\"\nfunc longest(strings: [String]) -> String?\
    \ {\n    guard let firstString = strings.first else {\n        return nil\n  \
    \  }\n    return strings.reduce(firstString) { longest, string in\n        if\
    \ string.count > longest.count {\n            return string\n        }\n     \
    \   return longest\n    }\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(longest(strings:\
    \ [] as [String]) == nil)\nassert(longest(strings: [\"x\", \"y\", \"z\"]) == \"\
    x\")\nassert(longest(strings: [\"x\", \"yyy\", \"zzzz\", \"www\", \"kkkk\", \"\
    abc\"]) == \"zzzz\")"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660013861
- exit_code: 1
  program: "\n/// Out of array of strings, return the longest one. Return the first\
    \ one in case of multiple\n/// strings of the same length. Return nil in case\
    \ the input array is empty.\n/// >>> longest(strings: [] as [String])\n/// nil\n\
    /// >>> longest(strings: [\"a\", \"b\", \"c\"])\n/// \"a\"\n/// >>> longest(strings:\
    \ [\"a\", \"bb\", \"ccc\"])\n/// \"ccc\"\nfunc longest(strings: [String]) -> String?\
    \ {\n    var maxLen: Int = 0\n    var result: String? = nil\n    for str in strings\
    \ {\n        if str.characters.count > maxLen {\n            maxLen = str.characters.count\n\
    \            result = str\n        }\n    }\n    return result\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(longest(strings: [] as [String]) == nil)\nassert(longest(strings:\
    \ [\"x\", \"y\", \"z\"]) == \"x\")\nassert(longest(strings: [\"x\", \"yyy\", \"\
    zzzz\", \"www\", \"kkkk\", \"abc\"]) == \"zzzz\")"
  status: SyntaxError
  stderr: "/tmp/tmpk2a15273.swift:14:16: error: 'characters' is unavailable: Please\
    \ use String directly\n        if str.characters.count > maxLen {\n          \
    \     ^~~~~~~~~~\nSwift.String:5:16: note: 'characters' was obsoleted in Swift\
    \ 5.0\n    public var characters: String { get set }\n               ^\n/tmp/tmpk2a15273.swift:15:26:\
    \ error: 'characters' is unavailable: Please use String directly\n           \
    \ maxLen = str.characters.count\n                         ^~~~~~~~~~\nSwift.String:5:16:\
    \ note: 'characters' was obsoleted in Swift 5.0\n    public var characters: String\
    \ { get set }\n               ^\n"
  stdout: ''
  timestamp: 1660013861
- exit_code: -4
  program: "\n/// Out of array of strings, return the longest one. Return the first\
    \ one in case of multiple\n/// strings of the same length. Return nil in case\
    \ the input array is empty.\n/// >>> longest(strings: [] as [String])\n/// nil\n\
    /// >>> longest(strings: [\"a\", \"b\", \"c\"])\n/// \"a\"\n/// >>> longest(strings:\
    \ [\"a\", \"bb\", \"ccc\"])\n/// \"ccc\"\nfunc longest(strings: [String]) -> String?\
    \ {\n  return nil\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) ->\
    \ Bool {\n    if left.count != right.count {\n        return false\n    }\n  \
    \  for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(longest(strings: []\
    \ as [String]) == nil)\nassert(longest(strings: [\"x\", \"y\", \"z\"]) == \"x\"\
    )\nassert(longest(strings: [\"x\", \"yyy\", \"zzzz\", \"www\", \"kkkk\", \"abc\"\
    ]) == \"zzzz\")"
  status: Exception
  stderr: 'tmpwp41rz5z/tmpwp41rz5z.swift:28: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b5933cdfc80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b59339d6b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b59339d6988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b59339d57b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpwp41rz5z                        0x00005644cb20179a <unavailable> + 6042

    5    libc.so.6                          0x00002b5933ecb460 __libc_start_main +
    245

    6    tmpwp41rz5z                        0x00005644cb201089 <unavailable> + 4233

    '
  stdout: ''
  timestamp: 1660013861
- exit_code: -4
  program: "\n/// Out of array of strings, return the longest one. Return the first\
    \ one in case of multiple\n/// strings of the same length. Return nil in case\
    \ the input array is empty.\n/// >>> longest(strings: [] as [String])\n/// nil\n\
    /// >>> longest(strings: [\"a\", \"b\", \"c\"])\n/// \"a\"\n/// >>> longest(strings:\
    \ [\"a\", \"bb\", \"ccc\"])\n/// \"ccc\"\nfunc longest(strings: [String]) -> String?\
    \ {\n    return strings.max()\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int,\
    \ Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n\
    \    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n          \
    \  return false\n        }\n    }\n    return true\n}\n            \nassert(longest(strings:\
    \ [] as [String]) == nil)\nassert(longest(strings: [\"x\", \"y\", \"z\"]) == \"\
    x\")\nassert(longest(strings: [\"x\", \"yyy\", \"zzzz\", \"www\", \"kkkk\", \"\
    abc\"]) == \"zzzz\")"
  status: Exception
  stderr: 'tmp71jrbmvf/tmp71jrbmvf.swift:28: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002ad69d142c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002ad69ce39b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002ad69ce39988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002ad69ce387b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmp71jrbmvf                        0x00005616aa89f83a <unavailable> + 6202

    5    libc.so.6                          0x00002ad69d32e460 __libc_start_main +
    245

    6    tmp71jrbmvf                        0x00005616aa89f129 <unavailable> + 4393

    '
  stdout: ''
  timestamp: 1660013860
- exit_code: 0
  program: "\n/// Out of array of strings, return the longest one. Return the first\
    \ one in case of multiple\n/// strings of the same length. Return nil in case\
    \ the input array is empty.\n/// >>> longest(strings: [] as [String])\n/// nil\n\
    /// >>> longest(strings: [\"a\", \"b\", \"c\"])\n/// \"a\"\n/// >>> longest(strings:\
    \ [\"a\", \"bb\", \"ccc\"])\n/// \"ccc\"\nfunc longest(strings: [String]) -> String?\
    \ {\n    if strings.isEmpty {\n        return nil\n    } else {\n        var longest\
    \ = strings[0]\n        for index in 1..<strings.count {\n            if strings[index].count\
    \ > longest.count {\n                longest = strings[index]\n            }\n\
    \        }\n        return longest\n    }\n}\n\n\nfunc ==(left: [(Int, Int)],\
    \ right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n       \
    \ return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r\
    \ {\n            return false\n        }\n    }\n    return true\n}\n        \
    \    \nassert(longest(strings: [] as [String]) == nil)\nassert(longest(strings:\
    \ [\"x\", \"y\", \"z\"]) == \"x\")\nassert(longest(strings: [\"x\", \"yyy\", \"\
    zzzz\", \"www\", \"kkkk\", \"abc\"]) == \"zzzz\")"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660013861
- exit_code: 0
  program: "\n/// Out of array of strings, return the longest one. Return the first\
    \ one in case of multiple\n/// strings of the same length. Return nil in case\
    \ the input array is empty.\n/// >>> longest(strings: [] as [String])\n/// nil\n\
    /// >>> longest(strings: [\"a\", \"b\", \"c\"])\n/// \"a\"\n/// >>> longest(strings:\
    \ [\"a\", \"bb\", \"ccc\"])\n/// \"ccc\"\nfunc longest(strings: [String]) -> String?\
    \ {\n    if strings.isEmpty {\n        return nil\n    }\n    var longestString\
    \ = strings[0]\n    for string in strings {\n        if string.count > longestString.count\
    \ {\n            longestString = string\n        }\n    }\n    return longestString\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(longest(strings: [] as [String]) == nil)\nassert(longest(strings:\
    \ [\"x\", \"y\", \"z\"]) == \"x\")\nassert(longest(strings: [\"x\", \"yyy\", \"\
    zzzz\", \"www\", \"kkkk\", \"abc\"]) == \"zzzz\")"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660013739
- exit_code: 1
  program: "\n/// Out of array of strings, return the longest one. Return the first\
    \ one in case of multiple\n/// strings of the same length. Return nil in case\
    \ the input array is empty.\n/// >>> longest(strings: [] as [String])\n/// nil\n\
    /// >>> longest(strings: [\"a\", \"b\", \"c\"])\n/// \"a\"\n/// >>> longest(strings:\
    \ [\"a\", \"bb\", \"ccc\"])\n/// \"ccc\"\nfunc longest(strings: [String]) -> String?\
    \ {\n    return strings.sort(by: { $0.count > $1.count }).first\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(longest(strings: [] as [String]) == nil)\nassert(longest(strings:\
    \ [\"x\", \"y\", \"z\"]) == \"x\")\nassert(longest(strings: [\"x\", \"yyy\", \"\
    zzzz\", \"www\", \"kkkk\", \"abc\"]) == \"zzzz\")"
  status: SyntaxError
  stderr: "/tmp/tmp51gdiayo.swift:11:20: error: cannot use mutating member on immutable\
    \ value: 'strings' is a 'let' constant\n    return strings.sort(by: { $0.count\
    \ > $1.count }).first\n           ~~~~~~~ ^\n/tmp/tmp51gdiayo.swift:11:54: error:\
    \ value of tuple type '()' has no member 'first'\n    return strings.sort(by:\
    \ { $0.count > $1.count }).first\n           ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\
    \ ^~~~~\n"
  stdout: ''
  timestamp: 1660013861
- exit_code: 0
  program: "\n/// Out of array of strings, return the longest one. Return the first\
    \ one in case of multiple\n/// strings of the same length. Return nil in case\
    \ the input array is empty.\n/// >>> longest(strings: [] as [String])\n/// nil\n\
    /// >>> longest(strings: [\"a\", \"b\", \"c\"])\n/// \"a\"\n/// >>> longest(strings:\
    \ [\"a\", \"bb\", \"ccc\"])\n/// \"ccc\"\nfunc longest(strings: [String]) -> String?\
    \ {\n    var longestString: String?\n    for string in strings {\n        if longestString\
    \ == nil || string.count > longestString!.count {\n            longestString =\
    \ string\n        }\n    }\n    return longestString\n}\n\n\nfunc ==(left: [(Int,\
    \ Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n\
    \        return false\n    }\n    for (l, r) in zip(left, right) {\n        if\
    \ l != r {\n            return false\n        }\n    }\n    return true\n}\n \
    \           \nassert(longest(strings: [] as [String]) == nil)\nassert(longest(strings:\
    \ [\"x\", \"y\", \"z\"]) == \"x\")\nassert(longest(strings: [\"x\", \"yyy\", \"\
    zzzz\", \"www\", \"kkkk\", \"abc\"]) == \"zzzz\")"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660013739
- exit_code: 0
  program: "\n/// Out of array of strings, return the longest one. Return the first\
    \ one in case of multiple\n/// strings of the same length. Return nil in case\
    \ the input array is empty.\n/// >>> longest(strings: [] as [String])\n/// nil\n\
    /// >>> longest(strings: [\"a\", \"b\", \"c\"])\n/// \"a\"\n/// >>> longest(strings:\
    \ [\"a\", \"bb\", \"ccc\"])\n/// \"ccc\"\nfunc longest(strings: [String]) -> String?\
    \ {\n    guard !strings.isEmpty else { return nil }\n    return strings.reduce(strings[0])\
    \ { (s, a) in a.count > s.count ? a : s }\n}\n\n\nfunc ==(left: [(Int, Int)],\
    \ right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n       \
    \ return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r\
    \ {\n            return false\n        }\n    }\n    return true\n}\n        \
    \    \nassert(longest(strings: [] as [String]) == nil)\nassert(longest(strings:\
    \ [\"x\", \"y\", \"z\"]) == \"x\")\nassert(longest(strings: [\"x\", \"yyy\", \"\
    zzzz\", \"www\", \"kkkk\", \"abc\"]) == \"zzzz\")"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660013861
- exit_code: 0
  program: "\n/// Out of array of strings, return the longest one. Return the first\
    \ one in case of multiple\n/// strings of the same length. Return nil in case\
    \ the input array is empty.\n/// >>> longest(strings: [] as [String])\n/// nil\n\
    /// >>> longest(strings: [\"a\", \"b\", \"c\"])\n/// \"a\"\n/// >>> longest(strings:\
    \ [\"a\", \"bb\", \"ccc\"])\n/// \"ccc\"\nfunc longest(strings: [String]) -> String?\
    \ {\n  //code\n  var longestString: String?\n  for str in strings {\n    if longestString\
    \ == nil {\n      longestString = str\n    } else if str.count > longestString!.count\
    \ {\n      longestString = str\n    }\n  }\n  return longestString\n}\n\n\nfunc\
    \ ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count !=\
    \ right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(longest(strings: [] as [String]) == nil)\nassert(longest(strings:\
    \ [\"x\", \"y\", \"z\"]) == \"x\")\nassert(longest(strings: [\"x\", \"yyy\", \"\
    zzzz\", \"www\", \"kkkk\", \"abc\"]) == \"zzzz\")"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660013861
- exit_code: 0
  program: "\n/// Out of array of strings, return the longest one. Return the first\
    \ one in case of multiple\n/// strings of the same length. Return nil in case\
    \ the input array is empty.\n/// >>> longest(strings: [] as [String])\n/// nil\n\
    /// >>> longest(strings: [\"a\", \"b\", \"c\"])\n/// \"a\"\n/// >>> longest(strings:\
    \ [\"a\", \"bb\", \"ccc\"])\n/// \"ccc\"\nfunc longest(strings: [String]) -> String?\
    \ {\n    guard strings.count > 0 else {\n        return nil\n    }\n    return\
    \ strings.reduce(strings[0]) { $1.count > $0.count ? $1 : $0 }\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(longest(strings: [] as [String]) == nil)\nassert(longest(strings:\
    \ [\"x\", \"y\", \"z\"]) == \"x\")\nassert(longest(strings: [\"x\", \"yyy\", \"\
    zzzz\", \"www\", \"kkkk\", \"abc\"]) == \"zzzz\")"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660013861
- exit_code: 1
  program: "\n/// Out of array of strings, return the longest one. Return the first\
    \ one in case of multiple\n/// strings of the same length. Return nil in case\
    \ the input array is empty.\n/// >>> longest(strings: [] as [String])\n/// nil\n\
    /// >>> longest(strings: [\"a\", \"b\", \"c\"])\n/// \"a\"\n/// >>> longest(strings:\
    \ [\"a\", \"bb\", \"ccc\"])\n/// \"ccc\"\nfunc longest(strings: [String]) -> String?\
    \ {\n    \n    // The output is an optional string, because there might be no\
    \ longest string\n    var longestString: String? = nil\n    \n    // Iterate the\
    \ input array\n    for string in strings {\n        \n        // Check if the\
    \ string is longer than the previous longest string\n        if longestString\
    \ == nil || longestString!.characters.count < string.characters.count {\n    \
    \        \n            // If so, set the new longest string\n            longestString\
    \ = string\n        }\n    }\n    \n    // Return the longest string\n    return\
    \ longestString\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool\
    \ {\n    if left.count != right.count {\n        return false\n    }\n    for\
    \ (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(longest(strings: []\
    \ as [String]) == nil)\nassert(longest(strings: [\"x\", \"y\", \"z\"]) == \"x\"\
    )\nassert(longest(strings: [\"x\", \"yyy\", \"zzzz\", \"www\", \"kkkk\", \"abc\"\
    ]) == \"zzzz\")"
  status: SyntaxError
  stderr: "/tmp/tmptcmys6bg.swift:19:51: error: 'characters' is unavailable: Please\
    \ use String directly\n        if longestString == nil || longestString!.characters.count\
    \ < string.characters.count {\n                                              \
    \    ^~~~~~~~~~\nSwift.String:5:16: note: 'characters' was obsoleted in Swift\
    \ 5.0\n    public var characters: String { get set }\n               ^\n/tmp/tmptcmys6bg.swift:19:77:\
    \ error: 'characters' is unavailable: Please use String directly\n        if longestString\
    \ == nil || longestString!.characters.count < string.characters.count {\n    \
    \                                                                        ^~~~~~~~~~\n\
    Swift.String:5:16: note: 'characters' was obsoleted in Swift 5.0\n    public var\
    \ characters: String { get set }\n               ^\n"
  stdout: ''
  timestamp: 1660013861
- exit_code: 1
  program: "\n/// Out of array of strings, return the longest one. Return the first\
    \ one in case of multiple\n/// strings of the same length. Return nil in case\
    \ the input array is empty.\n/// >>> longest(strings: [] as [String])\n/// nil\n\
    /// >>> longest(strings: [\"a\", \"b\", \"c\"])\n/// \"a\"\n/// >>> longest(strings:\
    \ [\"a\", \"bb\", \"ccc\"])\n/// \"ccc\"\nfunc longest(strings: [String]) -> String?\
    \ {\n    var max: String? = nil\n    for s in strings {\n        if (max == nil\
    \ || s.characters.count > max!.characters.count) {\n            max = s\n    \
    \    }\n    }\n    return max\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int,\
    \ Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n\
    \    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n          \
    \  return false\n        }\n    }\n    return true\n}\n            \nassert(longest(strings:\
    \ [] as [String]) == nil)\nassert(longest(strings: [\"x\", \"y\", \"z\"]) == \"\
    x\")\nassert(longest(strings: [\"x\", \"yyy\", \"zzzz\", \"www\", \"kkkk\", \"\
    abc\"]) == \"zzzz\")"
  status: SyntaxError
  stderr: "/tmp/tmpczqxv6b7.swift:13:29: error: 'characters' is unavailable: Please\
    \ use String directly\n        if (max == nil || s.characters.count > max!.characters.count)\
    \ {\n                            ^~~~~~~~~~\nSwift.String:5:16: note: 'characters'\
    \ was obsoleted in Swift 5.0\n    public var characters: String { get set }\n\
    \               ^\n/tmp/tmpczqxv6b7.swift:13:53: error: 'characters' is unavailable:\
    \ Please use String directly\n        if (max == nil || s.characters.count > max!.characters.count)\
    \ {\n                                                    ^~~~~~~~~~\nSwift.String:5:16:\
    \ note: 'characters' was obsoleted in Swift 5.0\n    public var characters: String\
    \ { get set }\n               ^\n"
  stdout: ''
  timestamp: 1660013861
- exit_code: 1
  program: "\n/// Out of array of strings, return the longest one. Return the first\
    \ one in case of multiple\n/// strings of the same length. Return nil in case\
    \ the input array is empty.\n/// >>> longest(strings: [] as [String])\n/// nil\n\
    /// >>> longest(strings: [\"a\", \"b\", \"c\"])\n/// \"a\"\n/// >>> longest(strings:\
    \ [\"a\", \"bb\", \"ccc\"])\n/// \"ccc\"\nfunc longest(strings: [String]) -> String?\
    \ {\n    guard !strings.isEmpty else { return nil }\n    var maxLength = strings[0].characters.count\n\
    \    var currentString = strings[0]\n    for i in 1..<strings.count {\n      \
    \  if strings[i].characters.count > maxLength {\n            maxLength = strings[i].characters.count\n\
    \            currentString = strings[i]\n        }\n    }\n    return currentString\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(longest(strings: [] as [String]) == nil)\nassert(longest(strings:\
    \ [\"x\", \"y\", \"z\"]) == \"x\")\nassert(longest(strings: [\"x\", \"yyy\", \"\
    zzzz\", \"www\", \"kkkk\", \"abc\"]) == \"zzzz\")"
  status: SyntaxError
  stderr: "/tmp/tmp0wc68vox.swift:12:32: error: 'characters' is unavailable: Please\
    \ use String directly\n    var maxLength = strings[0].characters.count\n     \
    \                          ^~~~~~~~~~\nSwift.String:5:16: note: 'characters' was\
    \ obsoleted in Swift 5.0\n    public var characters: String { get set }\n    \
    \           ^\n/tmp/tmp0wc68vox.swift:15:23: error: 'characters' is unavailable:\
    \ Please use String directly\n        if strings[i].characters.count > maxLength\
    \ {\n                      ^~~~~~~~~~\nSwift.String:5:16: note: 'characters' was\
    \ obsoleted in Swift 5.0\n    public var characters: String { get set }\n    \
    \           ^\n/tmp/tmp0wc68vox.swift:16:36: error: 'characters' is unavailable:\
    \ Please use String directly\n            maxLength = strings[i].characters.count\n\
    \                                   ^~~~~~~~~~\nSwift.String:5:16: note: 'characters'\
    \ was obsoleted in Swift 5.0\n    public var characters: String { get set }\n\
    \               ^\n"
  stdout: ''
  timestamp: 1660013861
- exit_code: 1
  program: "\n/// Out of array of strings, return the longest one. Return the first\
    \ one in case of multiple\n/// strings of the same length. Return nil in case\
    \ the input array is empty.\n/// >>> longest(strings: [] as [String])\n/// nil\n\
    /// >>> longest(strings: [\"a\", \"b\", \"c\"])\n/// \"a\"\n/// >>> longest(strings:\
    \ [\"a\", \"bb\", \"ccc\"])\n/// \"ccc\"\nfunc longest(strings: [String]) -> String?\
    \ {\n    var longestString: String?\n    for string in strings {\n        if let\
    \ longestString = longestString {\n            if string.count > longestString.count\
    \ {\n                longestString = string\n            }\n        } else {\n\
    \            longestString = string\n        }\n    }\n    return longestString\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(longest(strings: [] as [String]) == nil)\nassert(longest(strings:\
    \ [\"x\", \"y\", \"z\"]) == \"x\")\nassert(longest(strings: [\"x\", \"yyy\", \"\
    zzzz\", \"www\", \"kkkk\", \"abc\"]) == \"zzzz\")"
  status: SyntaxError
  stderr: "/tmp/tmpiuliedj6.swift:15:17: error: cannot assign to value: 'longestString'\
    \ is a 'let' constant\n                longestString = string\n              \
    \  ^~~~~~~~~~~~~\n"
  stdout: ''
  timestamp: 1660013739
- exit_code: 1
  program: "\n/// Out of array of strings, return the longest one. Return the first\
    \ one in case of multiple\n/// strings of the same length. Return nil in case\
    \ the input array is empty.\n/// >>> longest(strings: [] as [String])\n/// nil\n\
    /// >>> longest(strings: [\"a\", \"b\", \"c\"])\n/// \"a\"\n/// >>> longest(strings:\
    \ [\"a\", \"bb\", \"ccc\"])\n/// \"ccc\"\nfunc longest(strings: [String]) -> String?\
    \ {\n    var result: String? = nil\n    for string in strings {\n        if result\
    \ == nil || count(string) > count(result!) {\n            result = string\n  \
    \      }\n    }\n    return result\n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(longest(strings: [] as [String]) == nil)\nassert(longest(strings: [\"x\"\
    , \"y\", \"z\"]) == \"x\")\nassert(longest(strings: [\"x\", \"yyy\", \"zzzz\"\
    , \"www\", \"kkkk\", \"abc\"]) == \"zzzz\")"
  status: SyntaxError
  stderr: "/tmp/tmp38h7zvly.swift:13:29: error: cannot find 'count' in scope\n   \
    \     if result == nil || count(string) > count(result!) {\n                 \
    \           ^~~~~\n/tmp/tmp38h7zvly.swift:13:45: error: cannot find 'count' in\
    \ scope\n        if result == nil || count(string) > count(result!) {\n      \
    \                                      ^~~~~\n"
  stdout: ''
  timestamp: 1660013861
- exit_code: 1
  program: "\n/// Out of array of strings, return the longest one. Return the first\
    \ one in case of multiple\n/// strings of the same length. Return nil in case\
    \ the input array is empty.\n/// >>> longest(strings: [] as [String])\n/// nil\n\
    /// >>> longest(strings: [\"a\", \"b\", \"c\"])\n/// \"a\"\n/// >>> longest(strings:\
    \ [\"a\", \"bb\", \"ccc\"])\n/// \"ccc\"\nfunc longest(strings: [String]) -> String?\
    \ {\n    var longest: String? = nil\n    for s in strings {\n        if (longest\
    \ == nil || s.characters.count > longest!.characters.count) {\n            longest\
    \ = s\n        }\n    }\n    return longest\n}\n\n\nfunc ==(left: [(Int, Int)],\
    \ right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n       \
    \ return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r\
    \ {\n            return false\n        }\n    }\n    return true\n}\n        \
    \    \nassert(longest(strings: [] as [String]) == nil)\nassert(longest(strings:\
    \ [\"x\", \"y\", \"z\"]) == \"x\")\nassert(longest(strings: [\"x\", \"yyy\", \"\
    zzzz\", \"www\", \"kkkk\", \"abc\"]) == \"zzzz\")"
  status: SyntaxError
  stderr: "/tmp/tmppfozx64e.swift:13:33: error: 'characters' is unavailable: Please\
    \ use String directly\n        if (longest == nil || s.characters.count > longest!.characters.count)\
    \ {\n                                ^~~~~~~~~~\nSwift.String:5:16: note: 'characters'\
    \ was obsoleted in Swift 5.0\n    public var characters: String { get set }\n\
    \               ^\n/tmp/tmppfozx64e.swift:13:61: error: 'characters' is unavailable:\
    \ Please use String directly\n        if (longest == nil || s.characters.count\
    \ > longest!.characters.count) {\n                                           \
    \                 ^~~~~~~~~~\nSwift.String:5:16: note: 'characters' was obsoleted\
    \ in Swift 5.0\n    public var characters: String { get set }\n              \
    \ ^\n"
  stdout: ''
  timestamp: 1660013861
- exit_code: 0
  program: "\n/// Out of array of strings, return the longest one. Return the first\
    \ one in case of multiple\n/// strings of the same length. Return nil in case\
    \ the input array is empty.\n/// >>> longest(strings: [] as [String])\n/// nil\n\
    /// >>> longest(strings: [\"a\", \"b\", \"c\"])\n/// \"a\"\n/// >>> longest(strings:\
    \ [\"a\", \"bb\", \"ccc\"])\n/// \"ccc\"\nfunc longest(strings: [String]) -> String?\
    \ {\n    if strings.isEmpty {\n        return nil\n    }\n    var ans = strings[0]\n\
    \    for str in strings {\n        if str.count > ans.count {\n            ans\
    \ = str\n        }\n    }\n    return ans\n}\n\n\nfunc ==(left: [(Int, Int)],\
    \ right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n       \
    \ return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r\
    \ {\n            return false\n        }\n    }\n    return true\n}\n        \
    \    \nassert(longest(strings: [] as [String]) == nil)\nassert(longest(strings:\
    \ [\"x\", \"y\", \"z\"]) == \"x\")\nassert(longest(strings: [\"x\", \"yyy\", \"\
    zzzz\", \"www\", \"kkkk\", \"abc\"]) == \"zzzz\")"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660013861
- exit_code: 0
  program: "\n/// Out of array of strings, return the longest one. Return the first\
    \ one in case of multiple\n/// strings of the same length. Return nil in case\
    \ the input array is empty.\n/// >>> longest(strings: [] as [String])\n/// nil\n\
    /// >>> longest(strings: [\"a\", \"b\", \"c\"])\n/// \"a\"\n/// >>> longest(strings:\
    \ [\"a\", \"bb\", \"ccc\"])\n/// \"ccc\"\nfunc longest(strings: [String]) -> String?\
    \ {\n    if strings.isEmpty {\n        return nil\n    }\n    var longestString\
    \ = strings[0]\n    for string in strings {\n        if string.count > longestString.count\
    \ {\n            longestString = string\n        }\n    }\n    return longestString\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(longest(strings: [] as [String]) == nil)\nassert(longest(strings:\
    \ [\"x\", \"y\", \"z\"]) == \"x\")\nassert(longest(strings: [\"x\", \"yyy\", \"\
    zzzz\", \"www\", \"kkkk\", \"abc\"]) == \"zzzz\")"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660013739
- exit_code: -4
  program: "\n/// Out of array of strings, return the longest one. Return the first\
    \ one in case of multiple\n/// strings of the same length. Return nil in case\
    \ the input array is empty.\n/// >>> longest(strings: [] as [String])\n/// nil\n\
    /// >>> longest(strings: [\"a\", \"b\", \"c\"])\n/// \"a\"\n/// >>> longest(strings:\
    \ [\"a\", \"bb\", \"ccc\"])\n/// \"ccc\"\nfunc longest(strings: [String]) -> String?\
    \ {\n    guard !strings.isEmpty else { return nil }\n    return strings.reduce(strings[0])\
    \ {\n        $0.count > $1.count ? $0 : $1\n    }\n}\n\n\nfunc ==(left: [(Int,\
    \ Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n\
    \        return false\n    }\n    for (l, r) in zip(left, right) {\n        if\
    \ l != r {\n            return false\n        }\n    }\n    return true\n}\n \
    \           \nassert(longest(strings: [] as [String]) == nil)\nassert(longest(strings:\
    \ [\"x\", \"y\", \"z\"]) == \"x\")\nassert(longest(strings: [\"x\", \"yyy\", \"\
    zzzz\", \"www\", \"kkkk\", \"abc\"]) == \"zzzz\")"
  status: Exception
  stderr: 'tmpznbtxvko/tmpznbtxvko.swift:31: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002ae58b6dec80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002ae58b3d5b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002ae58b3d5988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002ae58b3d47b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpznbtxvko                        0x0000560dd92f394a <unavailable> + 6474

    5    libc.so.6                          0x00002ae58b8ca460 __libc_start_main +
    245

    6    tmpznbtxvko                        0x0000560dd92f3239 <unavailable> + 4665

    '
  stdout: ''
  timestamp: 1660013862
- exit_code: 1
  program: "\n/// Out of array of strings, return the longest one. Return the first\
    \ one in case of multiple\n/// strings of the same length. Return nil in case\
    \ the input array is empty.\n/// >>> longest(strings: [] as [String])\n/// nil\n\
    /// >>> longest(strings: [\"a\", \"b\", \"c\"])\n/// \"a\"\n/// >>> longest(strings:\
    \ [\"a\", \"bb\", \"ccc\"])\n/// \"ccc\"\nfunc longest(strings: [String]) -> String?\
    \ {\n    var longestString = strings.first\n    for string in strings {\n    \
    \    if let longestString = longestString {\n            if string.count > longestString.count\
    \ {\n                longestString = string\n            }\n        }\n    }\n\
    \    return longestString\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(longest(strings:\
    \ [] as [String]) == nil)\nassert(longest(strings: [\"x\", \"y\", \"z\"]) == \"\
    x\")\nassert(longest(strings: [\"x\", \"yyy\", \"zzzz\", \"www\", \"kkkk\", \"\
    abc\"]) == \"zzzz\")"
  status: SyntaxError
  stderr: "/tmp/tmp7ofejzru.swift:15:17: error: cannot assign to value: 'longestString'\
    \ is a 'let' constant\n                longestString = string\n              \
    \  ^~~~~~~~~~~~~\n"
  stdout: ''
  timestamp: 1660013861
- exit_code: 0
  program: "\n/// Out of array of strings, return the longest one. Return the first\
    \ one in case of multiple\n/// strings of the same length. Return nil in case\
    \ the input array is empty.\n/// >>> longest(strings: [] as [String])\n/// nil\n\
    /// >>> longest(strings: [\"a\", \"b\", \"c\"])\n/// \"a\"\n/// >>> longest(strings:\
    \ [\"a\", \"bb\", \"ccc\"])\n/// \"ccc\"\nfunc longest(strings: [String]) -> String?\
    \ {\n    guard let first = strings.first else { return nil }\n    return strings.reduce(first)\
    \ { longest, next in\n        next.count > longest.count ? next : longest\n  \
    \  }\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if\
    \ left.count != right.count {\n        return false\n    }\n    for (l, r) in\
    \ zip(left, right) {\n        if l != r {\n            return false\n        }\n\
    \    }\n    return true\n}\n            \nassert(longest(strings: [] as [String])\
    \ == nil)\nassert(longest(strings: [\"x\", \"y\", \"z\"]) == \"x\")\nassert(longest(strings:\
    \ [\"x\", \"yyy\", \"zzzz\", \"www\", \"kkkk\", \"abc\"]) == \"zzzz\")"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660013862
- exit_code: 0
  program: "\n/// Out of array of strings, return the longest one. Return the first\
    \ one in case of multiple\n/// strings of the same length. Return nil in case\
    \ the input array is empty.\n/// >>> longest(strings: [] as [String])\n/// nil\n\
    /// >>> longest(strings: [\"a\", \"b\", \"c\"])\n/// \"a\"\n/// >>> longest(strings:\
    \ [\"a\", \"bb\", \"ccc\"])\n/// \"ccc\"\nfunc longest(strings: [String]) -> String?\
    \ {\n    guard strings.count > 0 else {\n        return nil\n    }\n    var longest\
    \ = strings[0]\n    for string in strings {\n        if string.count > longest.count\
    \ {\n            longest = string\n        }\n    }\n    return longest\n}\n\n\
    \nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(longest(strings: [] as [String]) == nil)\nassert(longest(strings:\
    \ [\"x\", \"y\", \"z\"]) == \"x\")\nassert(longest(strings: [\"x\", \"yyy\", \"\
    zzzz\", \"www\", \"kkkk\", \"abc\"]) == \"zzzz\")"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660013739
- exit_code: 0
  program: "\n/// Out of array of strings, return the longest one. Return the first\
    \ one in case of multiple\n/// strings of the same length. Return nil in case\
    \ the input array is empty.\n/// >>> longest(strings: [] as [String])\n/// nil\n\
    /// >>> longest(strings: [\"a\", \"b\", \"c\"])\n/// \"a\"\n/// >>> longest(strings:\
    \ [\"a\", \"bb\", \"ccc\"])\n/// \"ccc\"\nfunc longest(strings: [String]) -> String?\
    \ {\n    guard !strings.isEmpty else { return nil }\n    return strings.max {\
    \ $0.count < $1.count }\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(longest(strings:\
    \ [] as [String]) == nil)\nassert(longest(strings: [\"x\", \"y\", \"z\"]) == \"\
    x\")\nassert(longest(strings: [\"x\", \"yyy\", \"zzzz\", \"www\", \"kkkk\", \"\
    abc\"]) == \"zzzz\")"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660013861
- exit_code: 0
  program: "\n/// Out of array of strings, return the longest one. Return the first\
    \ one in case of multiple\n/// strings of the same length. Return nil in case\
    \ the input array is empty.\n/// >>> longest(strings: [] as [String])\n/// nil\n\
    /// >>> longest(strings: [\"a\", \"b\", \"c\"])\n/// \"a\"\n/// >>> longest(strings:\
    \ [\"a\", \"bb\", \"ccc\"])\n/// \"ccc\"\nfunc longest(strings: [String]) -> String?\
    \ {\n    // Your code here\n    if strings.count == 0 {\n        return nil\n\
    \    }\n    var output = strings[0]\n    for i in 1...strings.count-1 {\n    \
    \    if strings[i].count > output.count {\n            output = strings[i]\n \
    \       }\n    }\n    return output\n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(longest(strings: [] as [String]) == nil)\nassert(longest(strings: [\"x\"\
    , \"y\", \"z\"]) == \"x\")\nassert(longest(strings: [\"x\", \"yyy\", \"zzzz\"\
    , \"www\", \"kkkk\", \"abc\"]) == \"zzzz\")"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660013862
- exit_code: 0
  program: "\n/// Out of array of strings, return the longest one. Return the first\
    \ one in case of multiple\n/// strings of the same length. Return nil in case\
    \ the input array is empty.\n/// >>> longest(strings: [] as [String])\n/// nil\n\
    /// >>> longest(strings: [\"a\", \"b\", \"c\"])\n/// \"a\"\n/// >>> longest(strings:\
    \ [\"a\", \"bb\", \"ccc\"])\n/// \"ccc\"\nfunc longest(strings: [String]) -> String?\
    \ {\n    guard !strings.isEmpty else { return nil }\n    var longest = strings[0]\n\
    \    for string in strings {\n        if string.count > longest.count {\n    \
    \        longest = string\n        }\n    }\n    return longest\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(longest(strings: [] as [String]) == nil)\nassert(longest(strings:\
    \ [\"x\", \"y\", \"z\"]) == \"x\")\nassert(longest(strings: [\"x\", \"yyy\", \"\
    zzzz\", \"www\", \"kkkk\", \"abc\"]) == \"zzzz\")"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660013739
