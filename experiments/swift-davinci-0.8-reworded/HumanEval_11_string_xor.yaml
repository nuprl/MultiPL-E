name: HumanEval_11_string_xor
language: swift
prompt: "\n/// Input are two strings a and b consisting only of 1s and 0s.\n/// Perform\
  \ binary XOR on these inputs and return result also as a string.\n/// >>> string_xor(a:\
  \ \"010\", b: \"110\")\n/// \"100\"\nfunc string_xor(a: String, b: String) -> String\
  \ {\n"
tests: "}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if\
  \ left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left,\
  \ right) {\n        if l != r {\n            return false\n        }\n    }\n  \
  \  return true\n}\n            \nassert(string_xor(a: \"111000\", b: \"101010\"\
  ) == \"010010\")\nassert(string_xor(a: \"1\", b: \"1\") == \"0\")\nassert(string_xor(a:\
  \ \"0101\", b: \"0000\") == \"0101\")"
completions: ["    var result = \"\"\n    for i in 0..<a.characters.count {\n    \
    \    let a_i = a[a.index(a.startIndex, offsetBy: i)]\n        let b_i = b[b.index(b.startIndex,\
    \ offsetBy: i)]\n        if a_i == b_i {\n            result += \"0\"\n      \
    \  } else {\n            result += \"1\"\n        }\n    }\n    return result",
  "    var s = \"\"\n    for (i, ac) in a.characters.enumerated() {\n        let bc\
    \ = b[b.characters.index(b.startIndex, offsetBy: i)]\n        s += String(ac !=\
    \ bc ? \"1\" : \"0\")\n    }\n    return s", "    var a = a, b = b\n    if a.count\
    \ < b.count {\n        let diff = b.count - a.count\n        a = String(repeating:\
    \ \"0\", count: diff) + a\n    } else if a.count > b.count {\n        let diff\
    \ = a.count - b.count\n        b = String(repeating: \"0\", count: diff) + b\n\
    \    }\n    var result = \"\"\n    for i in 0..<a.count {\n        let a_char\
    \ = Array(a)[i]\n        let b_char = Array(b)[i]\n        let a_int = Int(String(a_char))\
    \ ?? 0\n        let b_int = Int(String(b_char)) ?? 0\n        result += String(a_int\
    \ ^ b_int)\n    }\n    return result", "    var result = \"\"\n    for i in 0..<a.count\
    \ {\n        result += a[i] == b[i] ? \"0\" : \"1\"\n    }\n    return result",
  '    return a.binaryXor(b).binaryString', "    if (a.characters.count != b.characters.count)\
    \ {\n        return \"\"\n    }\n    var result = String()\n    for index in 0..<a.characters.count\
    \ {\n        let a_char = a[a.index(a.startIndex, offsetBy: index)]\n        let\
    \ b_char = b[b.index(b.startIndex, offsetBy: index)]\n        result.append(a_char\
    \ == b_char ? \"0\" : \"1\")\n    }\n    return result", "    var result = String()\n\
    \    for (var i = 0; i < a.characters.count; i++) {\n        result.append(a[i]\
    \ == b[i] ? \"0\" : \"1\")\n    }\n    return result", "    var result = \"\"\n\
    \    var i = 0\n    while i < a.count && i < b.count {\n        if a[i] == b[i]\
    \ {\n            result += \"0\"\n        } else {\n            result += \"1\"\
    \n        }\n        i += 1\n    }\n    return result", "    if a.count != b.count\
    \ {\n        return \"invalid arguments\"\n    }\n    var result = \"\"\n    for\
    \ i in 0..<a.count {\n        let a_char = a[a.index(a.startIndex, offsetBy: i)]\n\
    \        let b_char = b[b.index(b.startIndex, offsetBy: i)]\n        if a_char\
    \ == b_char {\n            result += \"0\"\n        } else {\n            result\
    \ += \"1\"\n        }\n    }\n    return result", "    var x = \"\"\n    for (i,\
    \ ch) in a.characters.enumerated() {\n        let ai = ch\n        let bi = b[b.index(b.startIndex,\
    \ offsetBy: i)]\n        x.append(ai == bi ? \"0\" : \"1\")\n    }\n    return\
    \ x", "    if let a1 = a.int8(), let b1 = b.int8() {\n        return (a1 ^ b1).hex()\n\
    \    }\n    return \"ERROR\"", "    var c = \"\"\n    let aArr = a.utf8.map {\
    \ Int($0) }\n    let bArr = b.utf8.map { Int($0) }\n    for i in 0..<max(aArr.count,\
    \ bArr.count) {\n        let x = i < aArr.count ? aArr[i] : 0\n        let y =\
    \ i < bArr.count ? bArr[i] : 0\n        let z = (x + y) % 2\n        c += String(z)\n\
    \    }\n    return c", '    return String(repeating: " ", count: a.count).map
    { $0 }', "    let a = a.utf8.map { UInt8(bitPattern: $0) }\n    let b = b.utf8.map\
    \ { UInt8(bitPattern: $0) }\n    var xor = \"\"\n    for i in 0..<max(a.count,\
    \ b.count) {\n        if i < a.count && i < b.count {\n            xor += String(a[i]\
    \ ^ b[i], radix: 2)\n        } else if i < a.count {\n            xor += String(a[i],\
    \ radix: 2)\n        } else {\n            xor += String(b[i], radix: 2)\n   \
    \     }\n    }\n    return xor", "    if a.count != b.count { return \"\" }\n\
    \    let arrA = Array(a)\n    let arrB = Array(b)\n    var result = \"\"\n   \
    \ for i in 0..<a.count {\n        result += \"\\(Int(String(arrA[i]))! ^ Int(String(arrB[i]))!)\"\
    \n    }\n    return result", "    let a = a.unicodeScalars.map { Int(bitPattern:\
    \ $0.value) }\n    let b = b.unicodeScalars.map { Int(bitPattern: $0.value) }\n\
    \    var c = [Int]()\n    for i in 0..<min(a.count, b.count) {\n        c.append(a[i]\
    \ ^ b[i])\n    }\n    return String(c.map { Character(UnicodeScalar(bitPattern:\
    \ $0)!) })", "    let asciiA = a.unicodeScalars.map { $0.value }\n    let asciiB\
    \ = b.unicodeScalars.map { $0.value }\n    let result = zip(asciiA, asciiB).map\
    \ { $0.0 ^ $0.1 }\n    return String(bytes: result, encoding: String.Encoding.ascii)!",
  "    var chars = zip(a, b).map{ $0 == $1 ? \"0\" : \"1\" }\n    return String(chars)",
  '    return a.string_xor(b)', "    var ret = \"\"\n    var i = 0\n    while i <\
    \ a.count {\n        let a_i = Int(String(a[a.index(a.startIndex, offsetBy: i)]))!\n\
    \        let b_i = Int(String(b[b.index(b.startIndex, offsetBy: i)]))!\n     \
    \   ret += String(a_i ^ b_i)\n        i += 1\n    }\n    return ret", "    var\
    \ xorResult = \"\"\n    var a = a\n    var b = b\n    while a.count > 0 || b.count\
    \ > 0 {\n        if a.count > 0 {\n            let charA = a.removeFirst()\n \
    \           if b.count > 0 {\n                let charB = b.removeFirst()\n  \
    \              if charA == charB {\n                    xorResult.append(\"0\"\
    )\n                } else {\n                    xorResult.append(\"1\")\n   \
    \             }\n            } else {\n                xorResult.append(charA)\n\
    \            }\n        } else {\n            let charB = b.removeFirst()\n  \
    \          xorResult.append(charB)\n        }\n    }\n    return xorResult", " \
    \   let a = Array(a.utf8)\n    let b = Array(b.utf8)\n    let n = a.count\n  \
    \  var res = [UInt8]()\n    for i in 0..<n {\n        res.append(a[i] ^ b[i])\n\
    \    }\n    return String(bytes: res, encoding: .utf8)!", "    // TODO: Implement\
    \ this function.\n    // In case of invalid input, return empty string.\n    return\
    \ \"\"", '    return String(zip(a, b).map(^))', "\tlet a: UInt8 = UInt8(strtoul(a,\
    \ nil, 2))\n\tlet b: UInt8 = UInt8(strtoul(b, nil, 2))\n\tlet result: UInt8 =\
    \ a ^ b\n\treturn String(result, radix: 2)", '    return String(zip(a, b).map
    { $0.0 != $0.1 ? "1" : "0" })', "    var xor = \"\"\n    for i in 0..<a.characters.count\
    \ {\n        let str1 = a.substring(with: a.index(a.startIndex, offsetBy: i)..<a.index(a.startIndex,\
    \ offsetBy: i+1))\n        let str2 = b.substring(with: b.index(b.startIndex,\
    \ offsetBy: i)..<b.index(b.startIndex, offsetBy: i+1))\n        let s = str1 ^\
    \ str2\n        xor.append(s)\n    }\n    return xor", "    var r = String()\n\
    \    for i in 0..<a.characters.count {\n        if a[i] == b[i] {\n          \
    \  r.append(\"0\")\n        } else {\n            r.append(\"1\")\n        }\n\
    \    }\n    return r", "    var ret = \"\"\n    for (index, character) in a.characters.enumerated()\
    \ {\n        let a = String(character)\n        let b = String(b[b.index(b.startIndex,\
    \ offsetBy: index)])\n        ret += xor(a: a, b: b)\n    }\n    return ret",
  "  guard a.characters.count == b.characters.count else { return \"\" }\n  var result\
    \ = \"\"\n  for (i, j) in zip(a.characters, b.characters) {\n    let n = a[a.index(a.startIndex,\
    \ offsetBy: i)]\n    let m = b[b.index(b.startIndex, offsetBy: j)]\n    let c\
    \ = Int(String(n))! ^ Int(String(m))!\n    result += String(c)\n  }\n  return\
    \ result", "    var result = \"\"\n    for (idx, char) in a.characters.enumerated()\
    \ {\n        let int_a = Int(String(char))!\n        let int_b = Int(String(b[b.index(b.startIndex,\
    \ offsetBy: idx)]))!\n        let xor = int_a ^ int_b\n        result.append(String(xor))\n\
    \    }\n    return result", "    let aa = Array(a)\n    let bb = Array(b)\n  \
    \  var result = \"\"\n    for (i, _) in aa.enumerated() {\n        result += String(Int(String(aa[i]))!\
    \ ^ Int(String(bb[i]))!)\n    }\n    return result", "    var res = String()\n\
    \    let l = min(a.count, b.count)\n    for i in 0..<l {\n        res.append(a[i]\
    \ == b[i] ? \"0\" : \"1\")\n    }\n    return res", "    let a_bytes = Array(a.utf8)\n\
    \    let b_bytes = Array(b.utf8)\n    var ret_bytes = [UInt8]()\n    for (a_byte,\
    \ b_byte) in zip(a_bytes, b_bytes) {\n        let xor_byte = UInt8(a_byte) ^ UInt8(b_byte)\n\
    \        ret_bytes.append(xor_byte)\n    }\n    return String(bytes: ret_bytes,\
    \ encoding: .utf8)!", "    var result = \"\"\n    for index in 0..<a.count {\n\
    \        let a_char = a[a.index(a.startIndex, offsetBy: index)]\n        let b_char\
    \ = b[b.index(b.startIndex, offsetBy: index)]\n        let xor = a_char == b_char\
    \ ? \"0\" : \"1\"\n        result += xor\n    }\n    return result", "    let\
    \ bytes1 = a.utf8\n    let bytes2 = b.utf8\n    return bytes1.enumerated().map\
    \ { (i, byte1) -> UInt8 in\n        byte1 ^ bytes2[i]\n    }.map { String($0,\
    \ radix: 2) }.joined()", "    // integer a and b\n    let intA = Int(a, radix:\
    \ 2)!\n    let intB = Int(b, radix: 2)!\n    let intResult = intA ^ intB\n   \
    \ // string result\n    let strResult = String(intResult, radix: 2)\n    return\
    \ strResult", '    return String(zip(a, b).map { $0 != $1 })', "    let result\
    \ = String(a.utf8.enumerated().map { $0.1 ^ b[$0.0] })\n    print(result)\n  \
    \  return result", '    return ""', "    //Prepare the inputs\n    let a = a.map{Int(String($0))!}\n\
    \    let b = b.map{Int(String($0))!}\n    //Perform XOR for each bit\n    let\
    \ xor = zip(a, b).map{$0 ^ $1}\n    //Convert to String\n    return xor.map{String($0)}.joined()",
  "    guard a.count == b.count else {\n        return \"\"\n    }\n    let c = zip(a,\
    \ b).map { Int(String($0))! ^ Int(String($1))! }\n    return c.map { String($0)\
    \ }.joined()", "    let axor = a.utf8.map { UInt8(bitPattern: $0) }\n    let bxor\
    \ = b.utf8.map { UInt8(bitPattern: $0) }\n    var result = [UInt8]()\n    for\
    \ i in 0..<axor.count {\n        result.append(axor[i] ^ bxor[i])\n    }\n   \
    \ let resultxor = result.map { Character(UnicodeScalar(UInt8(bitPattern: $0)))\
    \ }\n    return String(resultxor)", "    var out: [Character] = []\n    var index\
    \ = a.startIndex\n    while index != a.endIndex {\n        let c = a[index]\n\
    \        let d = b[index]\n        out.append(c == d ? \"0\" : \"1\")\n      \
    \  index = a.index(after: index)\n    }\n    return String(out)", "    if a.characters.count\
    \ != b.characters.count {\n        print(\"Strings are not of equal length!\"\
    )\n        return String(0)\n    }\n    var result = String()\n    for i in 0..<a.characters.count\
    \ {\n        if a[i] == b[i] {\n            result.append(\"0\")\n        } else\
    \ {\n            result.append(\"1\")\n        }\n    }\n    return result", " \
    \   if a.count != b.count {\n        return \"\"\n    }\n    let aBits = [Int](a.utf8).map\
    \ { Int($0 - 48) }\n    let bBits = [Int](b.utf8).map { Int($0 - 48) }\n    var\
    \ result = \"\"\n    for i in 0..<a.count {\n        result += \"\\(aBits[i] ^\
    \ bBits[i])\"\n    }\n    return result", "    var ans = \"\"\n    for i in 0..<a.count\
    \ {\n        ans += a[i] == b[i] ? \"0\" : \"1\"\n    }\n    return ans", "  \
    \  let intA = Int(a, radix: 2)!\n    let intB = Int(b, radix: 2)!\n    let result\
    \ = intA ^ intB\n    return String(result, radix: 2)", "    // Get minimum length\
    \ between a and b\n    let length = min(a.count, b.count)\n    var result = \"\
    \"\n    // Iterate through chars in both strings\n    for i in 0 ..< length {\n\
    \        // Append 0 or 1 to result\n        result += String(a[i] ^ b[i])\n \
    \   }\n    return result", '    return String(zip(a, b).map(^))', "    let z =\
    \ zip(a, b)\n    let res = z.map { Int(String($0))! ^ Int(String($1))! }\n   \
    \ return res.map { String($0) }.joined()", "    let a_bin = [UInt8](a.utf8)\n\
    \    let b_bin = [UInt8](b.utf8)\n    var result = \"\"\n    for i in 0..<a_bin.count\
    \ {\n        result += a_bin[i] == b_bin[i] ? \"0\" : \"1\"\n    }\n    return\
    \ result", "    let res = String(zip(a, b).map { String(Int(String($0))! ^ Int(String($1))!)\
    \ })\n    return res", "    let intA = BigUInt(a, radix: 2)!\n    let intB = BigUInt(b,\
    \ radix: 2)!\n    let result = intA ^ intB\n    return String(result, radix: 2)",
  "    var result = \"\"\n    for (index, _) in a.characters.enumerated() {\n    \
    \    let a_bit = a[index]\n        let b_bit = b[index]\n        result += \"\\\
    (a_bit ^ b_bit)\"\n    }\n    return result", '    return ""', "    var result\
    \ = \"\"\n    for i in 0..<a.characters.count {\n        let aChar = a[a.startIndex.advancedBy(i)]\n\
    \        let bChar = b[b.startIndex.advancedBy(i)]\n        if aChar == bChar\
    \ {\n            result.append(\"0\")\n        } else {\n            result.append(\"\
    1\")\n        }\n    }\n    return result", "    if a.count != b.count {\n   \
    \     print(\"lengths of strings are not equal\")\n        return \"Error\"\n\
    \    }\n    var a_nums = [Int]()\n    var b_nums = [Int]()\n    for i in a {\n\
    \        if i == \"0\" {\n            a_nums.append(0)\n        } else if i ==\
    \ \"1\" {\n            a_nums.append(1)\n        } else {\n            print(\"\
    a has a char that is not 0 or 1\")\n            return \"Error\"\n        }\n\
    \    }\n    for i in b {\n        if i == \"0\" {\n            b_nums.append(0)\n\
    \        } else if i == \"1\" {\n            b_nums.append(1)\n        } else\
    \ {\n            print(\"b has a char that is not 0 or 1\")\n            return\
    \ \"Error\"\n        }\n    }\n    var result = [Int]()\n    for i in 0..<a_nums.count\
    \ {\n        if a_nums[i] != b_nums[i] {\n            result.append(1)\n     \
    \   } else {\n            result.append(0)\n        }\n    }\n    var result_string\
    \ = \"\"\n    for i in result {\n        result_string.append(String(i))\n   \
    \ }\n    return result_string", "    let aa = a.unicodeScalars.map { UInt8($0.value)\
    \ }\n    let bb = b.unicodeScalars.map { UInt8($0.value) }\n    let l = zip(aa,\
    \ bb).map { String(Int($0) ^ Int($1)) }\n    return l.joined()", "    var output:\
    \ String = \"\"\n    let a: String = String(a.reversed())\n    let b: String =\
    \ String(b.reversed())\n    for i in 0..<min(a.count, b.count) {\n        if a[i]\
    \ == b[i] {\n            output.append(\"0\")\n        } else {\n            output.append(\"\
    1\")\n        }\n    }\n    if a.count > b.count {\n        for i in b.count..<a.count\
    \ {\n            output.append(a[i])\n        }\n    } else if b.count > a.count\
    \ {\n        for i in a.count..<b.count {\n            output.append(b[i])\n \
    \       }\n    }\n    return String(output.reversed())", "    var result = [Character]()\n\
    \    let arr_a = Array(a)\n    let arr_b = Array(b)\n    for (index, _) in arr_a.enumerated()\
    \ {\n        if arr_a[index] == arr_b[index] {\n            result.append(\"0\"\
    )\n        } else {\n            result.append(\"1\")\n        }\n    }\n    return\
    \ String(result)", "\treturn String(\n\t\tzip(a, b).map { a, b in\n\t\t\treturn\
    \ a == b ? \"0\" : \"1\"\n\t\t})", "    var result = \"\"\n    for i in 0..<a.count\
    \ {\n        result += String(Int(String(a[i]))! ^ Int(String(b[i]))!)\n    }\n\
    \    return result", "\tvar result = \"\"\n\tfor (i,j) in zip(a,b) {\n\t\tlet\
    \ char_a = i.asciiValue! - 48\n\t\tlet char_b = j.asciiValue! - 48\n\t\tresult\
    \ += String(char_a ^ char_b)\n\t}\n\treturn result", "    var output = \"\"\n\
    \    let a = Array(a)\n    let b = Array(b)\n    for index in 0 ..< a.count {\n\
    \        output += a[index] == b[index] ? \"0\" : \"1\"\n    }\n    return output",
  "    guard a.count == b.count else {\n        fatalError(\"Expected inputs to be\
    \ of same length.\")\n    }\n    var result = \"\"\n    for i in 0..<a.count {\n\
    \        if a[i] == b[i] {\n            result += \"0\"\n        } else {\n  \
    \          result += \"1\"\n        }\n    }\n    return result", "    guard a.count\
    \ == b.count else { return \"\" }\n    let aCharSet = Set(a)\n    let bCharSet\
    \ = Set(b)\n    let count = a.count\n    let hasAll1 = aCharSet.contains(\"1\"\
    ) && bCharSet.contains(\"1\")\n    let hasAll0 = aCharSet.contains(\"0\") && bCharSet.contains(\"\
    0\")\n    if hasAll1 {\n        return String(repeating: \"0\", count: count)\n\
    \    } else if hasAll0 {\n        return String(repeating: \"0\", count: count)\n\
    \    } else {\n        var result = \"\"\n        for i in 0..<count {\n     \
    \       let a = String(a[a.index(a.startIndex, offsetBy: i)])\n            let\
    \ b = String(b[b.index(b.startIndex, offsetBy: i)])\n            result += \"\\\
    (Int(a)! ^ Int(b)!)\"\n        }\n        return result\n    }", "    var output\
    \ = \"\"\n    for i in 0..<a.count {\n        let charA = a[i]\n        let charB\
    \ = b[i]\n        let char: Character = charA == charB ? \"0\" : \"1\"\n     \
    \   output.append(char)\n    }\n    return output", "    var result = \"\"\n \
    \   let digits = zip(a, b)\n    for pair in digits {\n        let (a, b) = pair\n\
    \        let a_num = Int(String(a))!\n        let b_num = Int(String(b))!\n  \
    \      result += String(a_num ^ b_num)\n    }\n    return result", "\tlet c =\
    \ zip(a, b).map { $0 == $1 ? \"0\" : \"1\" }\n\treturn String(c)", "    let result\
    \ = zip(a, b).map {\n        switch ($0, $1) {\n        case (\"0\", \"0\"): return\
    \ \"0\"\n        case (\"1\", \"1\"): return \"0\"\n        default: return \"\
    1\"\n        }\n    }\n    return String(result)", "    let aa = a.toIntArray()\n\
    \    let bb = b.toIntArray()\n    return binary_xor(a: aa, b: bb).toBinaryString()",
  "    let x = UInt8(a, radix: 2)!\n    let y = UInt8(b, radix: 2)!\n    let res =\
    \ x ^ y\n    return String(res, radix: 2)", "    let set1 = CharacterSet(charactersIn:\
    \ a)\n    let set2 = CharacterSet(charactersIn: b)\n    let nums = CharacterSet.decimalDigits\n\
    \    let alphabet = CharacterSet.letters\n    let alphanums = CharacterSet.alphanumerics\n\
    \    let a_valid = set1.isSubset(of: nums)\n    let b_valid = set2.isSubset(of:\
    \ nums)\n    if !a_valid || !b_valid {\n        print(\"a and b must be strings\
    \ of 1s and 0s\")\n        return \"\"\n    }\n    let a_len = a.count\n    let\
    \ b_len = b.count\n    if a_len != b_len {\n        print(\"a and b must be the\
    \ same length\")\n        return \"\"\n    }\n    var c = \"\"\n    for i in 0..<a_len\
    \ {\n        if (a[i] == \"0\" && b[i] == \"0\") || (a[i] == \"1\" && b[i] ==\
    \ \"1\") {\n            c += \"0\"\n        } else {\n            c += \"1\"\n\
    \        }\n    }\n    return c", "    //Binary XOR is 0 if a and b are equal,\
    \ 1 otherwise\n    return Array(zip(a, b)).map { $0 == $1 ? \"0\" : \"1\" }.joined()",
  "    var result = \"\"\n    for i in 0..<a.characters.count {\n        let c = a[a.startIndex.advancedBy(i)]\n\
    \        let d = b[b.startIndex.advancedBy(i)]\n        if c == d {\n        \
    \    result += \"0\"\n        } else {\n            result += \"1\"\n        }\n\
    \    }\n    return result", '    return ""', "    if a.count != b.count {\n  \
    \      return \"\"\n    }\n    var result = \"\"\n    for (index, c) in a.enumerated()\
    \ {\n        if c == \"0\" && b[b.index(b.startIndex, offsetBy: index)] == \"\
    0\" {\n            result += \"0\"\n        } else if c == \"1\" && b[b.index(b.startIndex,\
    \ offsetBy: index)] == \"1\" {\n            result += \"0\"\n        } else {\n\
    \            result += \"1\"\n        }\n    }\n    return result", "    guard\
    \ a.count == b.count else { return \"\" }\n    let aInt = a.int\n    let bInt\
    \ = b.int\n    let resultInt = aInt ^ bInt\n    return String(resultInt, radix:\
    \ 2)", '    return String(zip(a, b).map(^))', "    // make sure that a and b are\
    \ both of the same length\n    var a = a\n    var b = b\n    if a.characters.count\
    \ < b.characters.count {\n        let aCount = a.characters.count\n        for\
    \ _ in 0..<b.characters.count - aCount {\n            a = \"0\" + a\n        }\n\
    \    } else if a.characters.count > b.characters.count {\n        let bCount =\
    \ b.characters.count\n        for _ in 0..<a.characters.count - bCount {\n   \
    \         b = \"0\" + b\n        }\n    }\n    // now perform xor\n    var result\
    \ = \"\"\n    for i in 0..<a.characters.count {\n        let aIndex = a.index(a.startIndex,\
    \ offsetBy: i)\n        let bIndex = b.index(b.startIndex, offsetBy: i)\n    \
    \    let aChar = a[aIndex]\n        let bChar = b[bIndex]\n        let aInt =\
    \ String(aChar).toInt()!\n        let bInt = String(bChar).toInt()!\n        let\
    \ resultInt = aInt ^ bInt\n        result += String(resultInt)\n    }\n    return\
    \ result", "  let aBytes = [UInt8](a.utf8)\n  let bBytes = [UInt8](b.utf8)\n \
    \ var resultBytes = [UInt8](repeating: 0, count: Swift.max(aBytes.count, bBytes.count))\n\
    \  for i in 0..<resultBytes.count {\n    if i < aBytes.count {\n      resultBytes[i]\
    \ ^= aBytes[i]\n    }\n    if i < bBytes.count {\n      resultBytes[i] ^= bBytes[i]\n\
    \    }\n  }\n  return String(bytes: resultBytes, encoding: .utf8)!", "    var\
    \ c = \"\"\n    for i in 0..<a.count {\n        let a_bit = a[i]\n        let\
    \ b_bit = b[i]\n        if a_bit == b_bit {\n            c.append(\"0\")\n   \
    \     } else {\n            c.append(\"1\")\n        }\n    }\n    return c",
  "    var result = \"\"\n    for i in 0..<a.count {\n        result += String(Int(String(a[i]))!\
    \ ^ Int(String(b[i]))!)\n    }\n    return result", "    let xor = zip(a, b).map(String.init).map\
    \ {\n        return Int(String($0))! ^ Int(String($1))!\n    }\n    return xor.map(String.init).joined()",
  "    let numbers1 = a.flatMap{ Int(String($0)) }\n    let numbers2 = b.flatMap{\
    \ Int(String($0)) }\n    return zip(numbers1, numbers2).map { $0 ^ $1 }.map{ String($0)\
    \ }.joined()", "    var result = \"\"\n    for (idx, charA) in a.characters.enumerated()\
    \ {\n        let charB = b[b.index(b.startIndex, offsetBy: idx)]\n        result\
    \ += String(charA) == String(charB) ? \"0\" : \"1\"\n    }\n    return result",
  "  if a.count != b.count {\n    fatalError(\"given parameters must have the same\
    \ size\")\n  }\n  let result: String = String(zip(a, b).map { String(Int(String($0))!\
    \ ^ Int(String($1))!) })\n  return result", '    return zip(a, b).map { String(Int(String($0))!
    ^ Int(String($1))!) }.joined()', "    var res = \"\"\n    if a.count == b.count\
    \ {\n        for i in 0..<a.count {\n            res += xor(a[i], b[i])\n    \
    \    }\n    }\n    return res", "    //# write your code here\n    var stringToReturn\
    \ = \"\"\n    if a.count != b.count {\n        return stringToReturn\n    }\n\
    \    for i in 0..<a.count {\n        if a[a.index(a.startIndex, offsetBy: i)]\
    \ == b[b.index(b.startIndex, offsetBy: i)] {\n            stringToReturn.append(\"\
    0\")\n        } else {\n            stringToReturn.append(\"1\")\n        }\n\
    \    }\n    return stringToReturn", "    var result = \"\"\n    for (index, char)\
    \ in a.characters.enumerated() {\n        let left = char\n        let right =\
    \ b[b.index(b.startIndex, offsetBy: index)]\n        result += \"\\(left == right\
    \ ? \"0\" : \"1\")\"\n    }\n    return result", "    if a.count != b.count {\n\
    \        print(\"Invalid input strings\")\n        return \"\"\n    }\n    var\
    \ result = \"\"\n    let a_bytes = Array(a.utf8)\n    let b_bytes = Array(b.utf8)\n\
    \    for i in 0 ..< a.count {\n        let a_byte = a_bytes[i]\n        let b_byte\
    \ = b_bytes[i]\n        if (a_byte == b_byte) {\n            result += \"0\"\n\
    \        } else {\n            result += \"1\"\n        }\n    }\n    return result",
  "    var r = \"\"\n    for (c1, c2) in zip(a, b) {\n        let c = c1 == c2 ? \"\
    0\" : \"1\"\n        r += c\n    }\n    return r", "    let aa = [UInt8](a.utf8)\n\
    \    let bb = [UInt8](b.utf8)\n    let count = aa.count\n    var result = \"\"\
    \n    for i in 0..<count {\n        result += String(aa[i] ^ bb[i])\n    }\n \
    \   return result", "  assert(a.count == b.count)\n  var c = \"\"\n  for i in\
    \ 0..<a.count {\n    let a_val = a[a.index(a.startIndex, offsetBy: i)]\n    let\
    \ b_val = b[b.index(b.startIndex, offsetBy: i)]\n    assert(a_val == \"0\" ||\
    \ a_val == \"1\")\n    assert(b_val == \"0\" || b_val == \"1\")\n    if a_val\
    \ == b_val {\n      c += \"0\"\n    } else {\n      c += \"1\"\n    }\n  }\n \
    \ return c", "    var result = \"\"\n    for i in 0..<max(a.count, b.count) {\n\
    \        let ai = i < a.count ? a[i] : \"0\"\n        let bi = i < b.count ? b[i]\
    \ : \"0\"\n        result += String(Int(ai)! ^ Int(bi)!)\n    }\n    return result",
  "    var result = String()\n    var aString = a\n    var bString = b\n    while\
    \ aString.count < bString.count {\n        aString = \"0\" + aString\n    }\n\
    \    while bString.count < aString.count {\n        bString = \"0\" + bString\n\
    \    }\n    for i in 0..<aString.count {\n        let aChar = aString[aString.index(aString.startIndex,\
    \ offsetBy: i)]\n        let bChar = bString[bString.index(bString.startIndex,\
    \ offsetBy: i)]\n        let aInt = Int(String(aChar))!\n        let bInt = Int(String(bChar))!\n\
    \        let xor = (aInt + bInt) % 2\n        result += String(xor)\n    }\n \
    \   return result", "    var result = \"\"\n    let a = Array(a)\n    let b =\
    \ Array(b)\n    for i in 0..<max(a.count, b.count) {\n        if a[i] == b[i]\
    \ {\n            result.append(\"0\")\n        } else {\n            result.append(\"\
    1\")\n        }\n    }\n    return result", "    var result = \"\"\n    for i\
    \ in 0..<a.count {\n        if a[i] == b[i] {\n            result += \"0\"\n \
    \       } else {\n            result += \"1\"\n        }\n    }\n    return result",
  "    let length = min(a.count, b.count)\n    var result = \"\"\n    for i in 0..<length\
    \ {\n        result += (a[i] == b[i]) ? \"0\" : \"1\"\n    }\n    return result",
  "\tlet string_and = { (a: String, b: String) -> String in\n\t\tvar andString = \"\
    \"\n\t\tlet aChars = Array(a.characters)\n\t\tlet bChars = Array(b.characters)\n\
    \t\tfor index in 0..<aChars.count {\n\t\t\tif aChars[index] == \"1\" && bChars[index]\
    \ == \"1\" {\n\t\t\t\tandString += \"1\"\n\t\t\t} else {\n\t\t\t\tandString +=\
    \ \"0\"\n\t\t\t}\n\t\t}\n\t\treturn andString\n\t}\n\t\n\tlet string_or = { (a:\
    \ String, b: String) -> String in\n\t\tvar orString = \"\"\n\t\tlet aChars = Array(a.characters)\n\
    \t\tlet bChars = Array(b.characters)\n\t\tfor index in 0..<aChars.count {\n\t\t\
    \tif aChars[index] == \"1\" || bChars[index] == \"1\" {\n\t\t\t\torString += \"\
    1\"\n\t\t\t} else {\n\t\t\t\torString += \"0\"\n\t\t\t}\n\t\t}\n\t\treturn orString\n\
    \t}\n\t\n\tlet string_not = { (a: String) -> String in\n\t\tvar notString = \"\
    \"\n\t\tlet aChars = Array(a.characters)\n\t\tfor index in 0..<aChars.count {\n\
    \t\t\tif aChars[index] == \"1\" {\n\t\t\t\tnotString += \"0\"\n\t\t\t} else {\n\
    \t\t\t\tnotString += \"1\"\n\t\t\t}\n\t\t}\n\t\treturn notString\n\t}\n\t\n\t\
    let aNot = string_not(a)\n\tlet bNot = string_not(b)\n\tlet andResult = string_and(aNot,\
    \ b: bNot)\n\tlet orResult = string_or(a, b: b)\n\treturn string_and(andResult,\
    \ b: orResult)", "\tvar diffs = \"\"\n\tlet m = min(a.count, b.count)\n\tfor i\
    \ in 0..<m {\n\t\tdiffs += ((a[i] == b[i]) ? \"0\" : \"1\")\n\t}\n\tlet rest =\
    \ a.count > b.count ? a[m..<a.count] : b[m..<b.count]\n\treturn diffs + rest",
  "    var aInts = [UInt8]()\n    var bInts = [UInt8]()\n    for aChar in a.characters\
    \ {\n        aInts.append(UInt8(String(aChar))!)\n    }\n    for bChar in b.characters\
    \ {\n        bInts.append(UInt8(String(bChar))!)\n    }\n    var result = \"\"\
    \n    for i in 0..<aInts.count {\n        result += String(aInts[i] ^ bInts[i])\n\
    \    }\n    return result", "    let r = zip(a, b).map { $0 != $1 ? \"1\" : \"\
    0\" }\n    return String(r)", "  // TODO\n  return String(1)", "    let xor =\
    \ a.hexlify ^ b.hexlify\n    return String(data: xor, encoding: .utf8)!", "  \
    \  var result = \"\"\n    for i in 0..<a.characters.count {\n        let aIndex\
    \ = a.index(a.startIndex, offsetBy: i)\n        let bIndex = b.index(b.startIndex,\
    \ offsetBy: i)\n        let aString = String(a[aIndex])\n        let bString =\
    \ String(b[bIndex])\n        let aInt = Int(aString)\n        let bInt = Int(bString)\n\
    \        if aInt == bInt {\n            result.append(\"0\")\n        } else {\n\
    \            result.append(\"1\")\n        }\n    }\n    return result", "   \
    \ var z = \"\"\n    for i in 0..<max(a.count, b.count) {\n        let x = Int(a[a.index(a.startIndex,\
    \ offsetBy: i % a.count)..<a.index(a.startIndex, offsetBy: i % a.count + 1)],\
    \ radix: 2) ?? 0\n        let y = Int(b[b.index(b.startIndex, offsetBy: i % b.count)..<b.index(b.startIndex,\
    \ offsetBy: i % b.count + 1)], radix: 2) ?? 0\n        z += String(x ^ y, radix:\
    \ 2)\n    }\n    return z", "    var result = \"\"\n    let length = max(a.count,\
    \ b.count)\n    for i in 0..<length {\n        let a_bit = i < a.count ? String(a[a.index(a.startIndex,\
    \ offsetBy: i)]) : \"0\"\n        let b_bit = i < b.count ? String(b[b.index(b.startIndex,\
    \ offsetBy: i)]) : \"0\"\n        result.append(string_xor(a: a_bit, b: b_bit))\n\
    \    }\n    return result", "    // Check if string lengths are equal.\n    guard\
    \ a.characters.count == b.characters.count else {\n        return String()\n \
    \   }\n    \n    // Assume the two strings are of equal length.\n    var result\
    \ = String()\n    for (char_a, char_b) in zip(a.characters, b.characters) {\n\
    \        // Check if both characters are equal.\n        if char_a == char_b {\n\
    \            result.append(\"0\")\n        } else {\n            result.append(\"\
    1\")\n        }\n    }\n    \n    return result", "    var res = \"\"\n    for\
    \ (i, c) in a.characters.enumerated() {\n        let c2 = b[b.index(b.startIndex,\
    \ offsetBy: i)]\n        if c == c2 {\n            res += \"0\"\n        } else\
    \ {\n            res += \"1\"\n        }\n    }\n    return res", "    var result\
    \ = \"\"\n    for (index, character) in a.characters.enumerated() {\n        result\
    \ += String(Int(String(character))! ^ Int(String(b[b.index(b.startIndex, offsetBy:\
    \ index)]))!)\n    }\n    return result", "    // TODO: your code here\n    let\
    \ arrayA = Array(a)\n    let arrayB = Array(b)\n    var xorResult = \"\"\n   \
    \ for i in 0..<arrayA.count {\n        if arrayA[i] == arrayB[i] {\n         \
    \   xorResult.append(\"0\")\n        } else {\n            xorResult.append(\"\
    1\")\n        }\n    }\n    return xorResult", "    // a.utf8.count is same as\
    \ a.characters.count\n    var result = String()\n    let a_chars = Array(a.utf8)\n\
    \    let b_chars = Array(b.utf8)\n    for i in 0..<a_chars.count {\n        result\
    \ += String(a_chars[i] ^ b_chars[i])\n    }\n    return result", "    let ca =\
    \ Array(a)\n    let cb = Array(b)\n    var res = [Character]()\n    for i in 0..<a.count\
    \ {\n        let cai = ca[i]\n        let cbi = cb[i]\n        var va: UInt8 =\
    \ 0\n        var vb: UInt8 = 0\n        if cai == \"1\" {\n            va = 1\n\
    \        }\n        if cbi == \"1\" {\n            vb = 1\n        }\n       \
    \ if va ^ vb == 1 {\n            res.append(\"1\")\n        } else {\n       \
    \     res.append(\"0\")\n        }\n    }\n    return String(res)", "    let aa\
    \ = [UInt8](a.utf8)\n    let bb = [UInt8](b.utf8)\n    let length = min(aa.count,\
    \ bb.count)\n    var output = [UInt8]()\n    for i in 0..<length {\n        output.append(aa[i]\
    \ ^ bb[i])\n    }\n    return String(bytes: output, encoding: .utf8)!", "    let\
    \ result = zip(a, b).map { $0 != $1 ? \"1\" : \"0\" }\n    return String(result)",
  "  assert(a.characters.count == b.characters.count)\n  var result = \"\"\n  for\
    \ i in 0..<a.characters.count {\n    if a[i] == b[i] {\n      result += \"0\"\n\
    \    } else {\n      result += \"1\"\n    }\n  }\n  return result", "    var str\
    \ = \"\"\n    for i in 0..<a.count {\n        let n1 = (a[i] == \"1\")\n     \
    \   let n2 = (b[i] == \"1\")\n        if n1 != n2 {\n            str += \"1\"\n\
    \        } else {\n            str += \"0\"\n        }\n    }\n    return str",
  "    var xorStr = \"\"\n    for idx in 0..<a.count {\n        xorStr += String(Int(String(a[idx]))!\
    \ ^ Int(String(b[idx]))!)\n    }\n    return xorStr", "    var result = String()\n\
    \    for i in 0..<a.count {\n        let a_char = String(a[a.index(a.startIndex,\
    \ offsetBy: i)])\n        let b_char = String(b[b.index(b.startIndex, offsetBy:\
    \ i)])\n        if a_char == b_char {\n            result.append(\"0\")\n    \
    \    } else {\n            result.append(\"1\")\n        }\n    }\n    return\
    \ result", "    let sum = Array(zip(a, b)).map(^)\n    return String(sum)", " \
    \   let aChars = Array(a.utf8)\n    let bChars = Array(b.utf8)\n    var result\
    \ = String()\n    for i in 0..<aChars.count {\n        if aChars[i] == bChars[i]\
    \ {\n            result.append(\"0\")\n        } else {\n            result.append(\"\
    1\")\n        }\n    }\n    return result", "    let a: UInt8 = UInt8(strtoul(a,\
    \ nil, 2))\n    let b: UInt8 = UInt8(strtoul(b, nil, 2))\n    let c: UInt8 = a\
    \ ^ b\n    return String(c, radix: 2)", "    var result = \"\"\n    for i in 0..<a.count\
    \ {\n        let x = a[i]\n        let y = b[i]\n        result += String(Int(String(x))!\
    \ ^ Int(String(y))!)\n    }\n    return result", "    let a_array = Array(a.characters)\n\
    \    let b_array = Array(b.characters)\n    var res = \"\"\n    for i in 0..<a_array.count\
    \ {\n        res += String(a_array[i] != b_array[i])\n    }\n    return res",
  "    guard a.count == b.count else {\n        preconditionFailure(\"Length of input\
    \ strings are different!\")\n    }\n    var result = \"\"\n    for (c1, c2) in\
    \ zip(a, b) {\n        let i1 = Int(String(c1))!\n        let i2 = Int(String(c2))!\n\
    \        result += \"\\(i1 ^ i2)\"\n    }\n    return result", "    var result\
    \ = \"\"\n    let a_arr = Array(a)\n    let b_arr = Array(b)\n    for i in 0..<a_arr.count\
    \ {\n        if a_arr[i] == b_arr[i] {\n            result += \"0\"\n        }\
    \ else {\n            result += \"1\"\n        }\n    }\n    return result", '    return
    to_bin_string(string_to_int(a) ^ string_to_int(b))', "  var result = \"\"\n  for\
    \ i in 0..<a.characters.count {\n    let index = a.startIndex.advancedBy(i)\n\
    \    let a_digit = a[index]\n    let b_digit = b[index]\n    switch (a_digit,\
    \ b_digit) {\n    case (\"0\", \"0\"):\n      result += \"0\"\n    case (\"0\"\
    , \"1\"):\n      result += \"1\"\n    case (\"1\", \"0\"):\n      result += \"\
    1\"\n    case (\"1\", \"1\"):\n      result += \"0\"\n    default:\n      break\n\
    \    }\n  }\n  return result", "    var output = \"\"\n    for (c, d) in zip(a,\
    \ b) {\n        let c_value = c.wholeNumberValue!\n        let d_value = d.wholeNumberValue!\n\
    \        let xor = c_value ^ d_value\n        output += String(xor)\n    }\n \
    \   return output", "    let a_bits = BitSet(input: a)\n    let b_bits = BitSet(input:\
    \ b)\n    return (a_bits ^ b_bits).description", "    let a_len = a.count\n  \
    \  let b_len = b.count\n    let diff = abs(a_len - b_len)\n    let bits = diff\
    \ + (a_len < b_len ? a_len : b_len)\n    var c = String()\n    for i in 0..<bits\
    \ {\n        let a_ch = i < a_len ? a[a.index(a.startIndex, offsetBy: i)] : \"\
    0\"\n        let b_ch = i < b_len ? b[b.index(b.startIndex, offsetBy: i)] : \"\
    0\"\n        if a_ch == b_ch {\n            c.append(\"0\")\n        } else {\n\
    \            c.append(\"1\")\n        }\n    }\n    return c", "    var result\
    \ = \"\"\n    for i in 0..<a.count {\n        let aChar = a[a.index(a.startIndex,\
    \ offsetBy: i)]\n        let bChar = b[b.index(b.startIndex, offsetBy: i)]\n \
    \       result += (aChar == bChar) ? \"0\" : \"1\"\n    }\n    return result",
  "    let arrayA = Array(a.characters)\n    let arrayB = Array(b.characters)\n  \
    \  var ret = \"\"\n    for i in 0..<arrayA.count {\n        if arrayA[i] == arrayB[i]\
    \ {\n            ret += \"0\"\n        } else {\n            ret += \"1\"\n  \
    \      }\n    }\n    return ret", '    return String(zip(a, b).map(^))', "  var\
    \ result = \"\"\n  for index in a.indices {\n    if a[index] == b[index] {\n \
    \     result.append(\"0\")\n    } else {\n      result.append(\"1\")\n    }\n\
    \  }\n  return result", "    let input_size = a.count\n    let a_bit_map = a.makeBitmap()\n\
    \    let b_bit_map = b.makeBitmap()\n    var output = [UInt8](repeating: 0, count:\
    \ input_size)\n    for index in 0..<input_size {\n        output[index] = a_bit_map[index]\
    \ ^ b_bit_map[index]\n    }\n    return output.map { String($0) }.joined()", " \
    \   let aAsBits = Array(a).map { UInt8(String($0), radix: 2)! }\n    let bAsBits\
    \ = Array(b).map { UInt8(String($0), radix: 2)! }\n    let xorAsBits = zip(aAsBits,\
    \ bAsBits).map { $0 ^ $1 }\n    return xorAsBits.map { String($0, radix: 2) }.joined()",
  "  // IMPLEMENT ME\n  var xor = \"\"\n  let a_arr = Array(a)\n  let b_arr = Array(b)\n\
    \  if a_arr.count != b_arr.count {\n    return xor\n  }\n  for i in 0..<a_arr.count\
    \ {\n    let a_int = Int(String(a_arr[i]))!\n    let b_int = Int(String(b_arr[i]))!\n\
    \    let c_int = a_int ^ b_int\n    xor += String(c_int)\n  }\n  return xor",
  "    let aa = Array(a)\n    let bb = Array(b)\n    let cc = zip(aa, bb).map { $0\
    \ != $1 ? \"1\" : \"0\" }\n    return String(cc)", "    let byteA = Array(a.utf8)\n\
    \    let byteB = Array(b.utf8)\n    if byteA.count != byteB.count {\n        return\
    \ \"\"\n    }\n    var result = String()\n    for i in 0..<byteA.count {\n   \
    \     let res = byteA[i] ^ byteB[i]\n        result += String(res, radix: 2)\n\
    \    }\n    return result", "    var res = String()\n    for i in 0..<a.count\
    \ {\n        if a[i] == b[i] {\n            res.append(\"0\")\n        } else\
    \ {\n            res.append(\"1\")\n        }\n    }\n    return res", "    var\
    \ output = \"\"\n    let aChars = Array(a.characters)\n    let bChars = Array(b.characters)\n\
    \    for i in 0..<aChars.count {\n        output.append(aChars[i] == bChars[i]\
    \ ? \"0\" : \"1\")\n    }\n    return output", "    let l = a.characters.count\
    \ < b.characters.count ? a.characters.count : b.characters.count\n    var s =\
    \ \"\"\n    for i in 0..<l {\n        let a1 = a.characters[a.characters.index(a.startIndex,\
    \ offsetBy: i)]\n        let b1 = b.characters[b.characters.index(b.startIndex,\
    \ offsetBy: i)]\n        let c1 = (Int(String(a1))! ^ Int(String(b1))!)\n    \
    \    s += String(c1)\n    }\n    return s", '    return String(bytes: zip(a.utf8,
    b.utf8).map(^), encoding: .utf8)!', "    if a.count != b.count {\n        return\
    \ \"nil\"\n    }\n    var result = \"\"\n    for i in 0..<a.count {\n        let\
    \ aa = a[i]\n        let bb = b[i]\n        if aa == bb {\n            result\
    \ += \"0\"\n        } else {\n            result += \"1\"\n        }\n    }\n\
    \    return result", "    let ai = a.compactMap { $0.wholeNumberValue }\n    let\
    \ bi = b.compactMap { $0.wholeNumberValue }\n    return String(zip(ai, bi).map\
    \ { $0 ^ $1 })", "    let aChars = Array(a.characters)\n    let bChars = Array(b.characters)\n\
    \    var result = \"\"\n    for i in 0..<aChars.count {\n        result += xor(a:\
    \ Int(String(aChars[i]))!, b: Int(String(bChars[i]))!) ? \"1\" : \"0\"\n    }\n\
    \    return result", "    var r = \"\"\n    for i in 0..<a.characters.count {\n\
    \        r += String(a[i] == b[i] ? \"0\" : \"1\")\n    }\n    return r", "  \
    \  let length = a.characters.count\n    if length != b.characters.count {\n  \
    \      return \"\"\n    }\n    var result = String()\n    var index = 0\n    let\
    \ a = [Character](a.characters)\n    let b = [Character](b.characters)\n    while\
    \ index < length {\n        if a[index] == b[index] {\n            result.append(\"\
    0\")\n        } else {\n            result.append(\"1\")\n        }\n        index\
    \ += 1\n    }\n    return result", "    var result = \"\"\n    for i in 0..<a.characters.count\
    \ {\n        let a = a[a.startIndex.advancedBy(i)]\n        let b = b[b.startIndex.advancedBy(i)]\n\
    \        result += \"\\(Int(String(a))! ^ Int(String(b))!)\"\n    }\n    return\
    \ result", "    var res = \"\"\n    for i in 0..<a.count {\n        if a[i] ==\
    \ b[i] {\n            res += \"0\"\n        } else {\n            res += \"1\"\
    \n        }\n    }\n    return res", "    var a_ = Array(a)\n    var b_ = Array(b)\n\
    \    if a_.count > b_.count {\n        let add = Array(repeating: \"0\", count:\
    \ a_.count - b_.count)\n        b_.insert(contentsOf: add, at: 0)\n    } else\
    \ if a_.count < b_.count {\n        let add = Array(repeating: \"0\", count: b_.count\
    \ - a_.count)\n        a_.insert(contentsOf: add, at: 0)\n    }\n    var result\
    \ = [String]()\n    for i in 0..<a_.count {\n        if a_[i] == b_[i] {\n   \
    \         result.append(\"0\")\n        } else {\n            result.append(\"\
    1\")\n        }\n    }\n    return result.joined()", "    var result = \"\"\n\
    \    for i in 0..<a.characters.count {\n        let ia = Int(String(a[a.index(a.startIndex,\
    \ offsetBy: i)]))!\n        let ib = Int(String(b[b.index(b.startIndex, offsetBy:\
    \ i)]))!\n        result += String(ia ^ ib)\n    }\n    return result", "    let\
    \ x = zip(a, b).map{String(Int(String($0.0))! ^ Int(String($0.1))!)}\n    return\
    \ x.joined()", '    return xor(a.data(using: .utf8)!, b.data(using: .utf8)!).toHex()',
  "    return String(\n        zip(a, b).map {\n            if $0.0 == $0.1 {\n  \
    \              return \"0\"\n            } else {\n                return \"1\"\
    \n            }\n        }\n    )", "    var xored: String = \"\"\n    for i in\
    \ 0..<a.count {\n        xored.append(a[i] == b[i] ? \"0\" : \"1\")\n    }\n \
    \   return xored", "    let aa = [UInt8](a.utf8)\n    let bb = [UInt8](b.utf8)\n\
    \    let zip = zip(aa, bb)\n    let xored = zip.map { $0 ^ $1 }\n    let result\
    \ = String(bytes: xored, encoding: .utf8)!\n    return result", "    let aa =\
    \ parse_string_as_int_array(a)\n    let bb = parse_string_as_int_array(b)\n  \
    \  var result: [Int] = []\n    for i in 0..<aa.count {\n        result.append(aa[i]\
    \ ^ bb[i])\n    }\n    return format_int_array_as_string(result)", "    let length\
    \ = min(a.characters.count, b.characters.count)\n    var result = \"\"\n    for\
    \ i in 0..<length {\n        let a = a[a.startIndex.advancedBy(i)]\n        let\
    \ b = b[b.startIndex.advancedBy(i)]\n        result.append(String(Int(String(a))!\
    \ ^ Int(String(b))!))\n    }\n    return result", "    let count_a = a.count\n\
    \    let count_b = b.count\n    var a_array = [Character]()\n    var b_array =\
    \ [Character]()\n    var xor_array = [Character]()\n    for i in 0..<count_a {\n\
    \        a_array.append(a[a.index(a.startIndex, offsetBy: i)])\n    }\n    for\
    \ i in 0..<count_b {\n        b_array.append(b[b.index(b.startIndex, offsetBy:\
    \ i)])\n    }\n    for i in 0..<count_a {\n        if (a_array[i] == \"0\" &&\
    \ b_array[i] == \"0\") || (a_array[i] == \"1\" && b_array[i] == \"1\") {\n   \
    \         xor_array.append(\"0\")\n        } else {\n            xor_array.append(\"\
    1\")\n        }\n    }\n    return String(xor_array)", "    let aVal = getStringValue(string:\
    \ a)\n    let bVal = getStringValue(string: b)\n    let result = aVal ^ bVal\n\
    \    return convertToBinaryString(val: result)", '    return String(zip(a, b).map
    { String(($0 ^ $1).toUInt8()) }.joined())', "    var result = \"\"\n    for i\
    \ in 0..<a.count {\n        let aChar = a[a.index(a.startIndex, offsetBy: i)]\n\
    \        let bChar = b[b.index(b.startIndex, offsetBy: i)]\n        if aChar ==\
    \ bChar {\n            result += \"0\"\n        } else {\n            result +=\
    \ \"1\"\n        }\n    }\n    return result", "\tvar xors = [String]()\n\tfor\
    \ i in 0..<a.characters.count {\n\t\tlet x = a[i]\n\t\tlet y = b[i]\n\t\tlet xor\
    \ = String(Int(String(x))! ^ Int(String(y))!)\n\t\txors.append(xor)\n\t}\n\treturn\
    \ xors.joined()", "    // Initialize output variable\n    var output = \"\"\n\
    \    \n    // Loop through each element in both strings\n    for i in 0..<a.count\
    \ {\n        // Get the i-th element of a\n        let a_element = a[i]\n    \
    \    \n        // Get the i-th element of b\n        let b_element = b[i]\n  \
    \      \n        // XOR operation on two integers\n        let xored = a_element\
    \ ^ b_element\n        \n        // Append to the output\n        output.append(String(xored))\n\
    \    }\n    \n    // Return output\n    return output", "    var s = \"\"\n  \
    \  var i = 0\n    for c in a.characters {\n        if a[i] == b[i] {\n       \
    \     s += \"0\"\n        } else {\n            s += \"1\"\n        }\n      \
    \  i += 1\n    }\n    return s", "    let aBinary = Array(a.utf8)\n    let bBinary\
    \ = Array(b.utf8)\n    var resultBinary = [UInt8]()\n    for i in 0..<aBinary.count\
    \ {\n        if aBinary[i] == bBinary[i] {\n            resultBinary.append(0)\n\
    \        } else {\n            resultBinary.append(1)\n        }\n    }\n    return\
    \ String(bytes: resultBinary, encoding: .utf8)!", "  let a_uint8 = Array(a.utf8)\n\
    \  let b_uint8 = Array(b.utf8)\n  let c_uint8 = zip(a_uint8, b_uint8).map { $0\
    \ ^ $1 }\n  let c = String(bytes: c_uint8, encoding: .utf8)!\n  return c", " \
    \   let buffer = NSMutableString(capacity: a.count)\n    for (l, r) in zip(a,\
    \ b) {\n        buffer.append(l == r ? \"0\" : \"1\")\n    }\n    return buffer\
    \ as String", "    let a_length = a.characters.count\n    let b_length = b.characters.count\n\
    \    var c = \"\"\n    var j = 0\n    var k = 0\n    if (a_length > b_length)\
    \ {\n        j = a_length\n        k = b_length\n    } else {\n        j = b_length\n\
    \        k = a_length\n    }\n    for i in 0..<j {\n        if (i < k) {\n   \
    \         if (a[i] == b[i]) {\n                c += \"0\"\n            } else\
    \ {\n                c += \"1\"\n            }\n        } else {\n           \
    \ if (a_length > b_length) {\n                c += a[i]\n            } else {\n\
    \                c += b[i]\n            }\n        }\n    }\n    return c", " \
    \   var xored = \"\"\n    for (index, char) in a.characters.enumerated() {\n \
    \       let c = String(char)\n        let b_c = String(b[b.index(b.startIndex,\
    \ offsetBy: index)])\n        if c == b_c {\n            xored.append(\"0\")\n\
    \        } else {\n            xored.append(\"1\")\n        }\n    }\n    return\
    \ xored", "    let a = a.utf8.map{UInt8($0)}\n    let b = b.utf8.map{UInt8($0)}\n\
    \    let c = zip(a, b).map{Int($0) ^ Int($1)}\n    return String(c.map{Character(UnicodeScalar($0))})",
  "    let inputA = a.utf8.map { Int($0) - 48 }\n    let inputB = b.utf8.map { Int($0)\
    \ - 48 }\n    let str = zip(inputA, inputB).map { $0 ^ $1 }.map { String($0) }.joined()\n\
    \    return str", "    // There is no XOR operator in Swift, but we can use bitwise\
    \ functions\n    var result = \"\"\n    // Loop over characters in a\n    for\
    \ (index, char) in a.characters.enumerated() {\n        // Get character in b\
    \ at same position\n        let charB = b[b.characters.index(b.startIndex, offsetBy:\
    \ index)]\n        // Convert to integers and XOR\n        result += String(Int(String(char))!\
    \ ^ Int(String(charB))!)\n    }\n    return result", "    var out = \"\"\n   \
    \ for i in 0..<a.characters.count {\n        let a1 = String(a[a.index(a.startIndex,\
    \ offsetBy: i)])\n        let b1 = String(b[b.index(b.startIndex, offsetBy: i)])\n\
    \        out += string_xor_char(a: a1, b: b1)\n    }\n    return out", "\tvar\
    \ result = \"\"\n\tfor i in 0..<a.characters.count {\n\t\tlet a_char = a[a.startIndex.advancedBy(i)]\n\
    \t\tlet b_char = b[b.startIndex.advancedBy(i)]\n\t\tif a_char == b_char {\n\t\t\
    \tresult.append(\"0\")\n\t\t} else {\n\t\t\tresult.append(\"1\")\n\t\t}\n\t}\n\
    \treturn result", "    var length = min(a.characters.count, b.characters.count)\n\
    \    let achars = a.characters.map { Int(String($0))! }\n    let bchars = b.characters.map\
    \ { Int(String($0))! }\n    var result: [Int] = []\n    for (idx, _) in achars.enumerated()\
    \ {\n        if idx < length {\n            result.append(achars[idx] ^ bchars[idx])\n\
    \        }\n    }\n    return result.map { String($0) }.joined()", '    return
    ""', "    var result = [UInt8]()\n    var aIter = a.makeIterator()\n    var bIter\
    \ = b.makeIterator()\n    while let a = aIter.next(), let b = bIter.next() {\n\
    \        result.append(UInt8(a) ^ UInt8(b))\n    }\n    return String(bytes: result,\
    \ encoding: .utf8)!", '    return String(a.utf8.lazy.map { $0 ^ b.utf8[a.utf8.startIndex]
    })', "    let len = a.characters.count\n    var xor_result = \"\"\n    for i in\
    \ 0..<len {\n        let x = a[a.startIndex.advancedBy(i)]\n        let y = b[b.startIndex.advancedBy(i)]\n\
    \        xor_result += String(Int(String(x))! ^ Int(String(y))!)\n    }\n    return\
    \ xor_result", '    return String(repeating: "1", count: a.count)', "    var result\
    \ = \"\"\n    for (a_char, b_char) in zip(a, b) {\n        if a_char == b_char\
    \ {\n            result.append(\"0\")\n        } else {\n            result.append(\"\
    1\")\n        }\n    }\n    return result", "\tlet charsA = a.characters.map{Int(String($0))!}\n\
    \tlet charsB = b.characters.map{Int(String($0))!}\n\t\n\tvar charsXor = [Int]()\n\
    \t\n\tfor i in 0..<charsA.count {\n\t\tif charsA[i] == 0 && charsB[i] == 0 {\n\
    \t\t\tcharsXor.append(0)\n\t\t} else if charsA[i] == 1 && charsB[i] == 1 {\n\t\
    \t\tcharsXor.append(0)\n\t\t} else {\n\t\t\tcharsXor.append(1)\n\t\t}\n\t}\n\t\
    \n\treturn charsXor.map{String($0)}.reduce(\"\", combine: +)", "    let charsA\
    \ = Array(a.characters)\n    let charsB = Array(b.characters)\n    let count =\
    \ charsA.count\n    assert(charsB.count == count)\n    var result = [Character]()\n\
    \    for i in 0..<count {\n        if charsA[i] == charsB[i] {\n            result.append(\"\
    0\")\n        } else {\n            result.append(\"1\")\n        }\n    }\n \
    \   return String(result)", "    let a = a.utf8\n    let b = b.utf8\n    let c\
    \ = zip(a, b).map {\n        UInt8(($0.0 ^ $0.1).toString, radix: 2)!\n    }\n\
    \    return String(bytes: c, encoding: String.Encoding.utf8)!", '    return a.utf8.lazy.map{
    UInt8(bitPattern: $0) }.map{ Int($0) }.zip(b.utf8.lazy.map{ UInt8(bitPattern:
    $0) }.map{ Int($0) }).map{ $0 == $1 ? "0" : "1" }.reduce("", +)', "    let aa\
    \ = a.to_string_as_array_of_ints()\n    let bb = b.to_string_as_array_of_ints()\n\
    \    let cc = zip(aa, bb).map { $0 ^ $1 }\n    return cc.to_string()", "    let\
    \ arrayA = Array(a)\n    let arrayB = Array(b)\n    var result = [String]()\n\
    \    for (i, char) in arrayA.enumerated() {\n        if char == arrayB[i] {\n\
    \            result.append(\"0\")\n        } else {\n            result.append(\"\
    1\")\n        }\n    }\n    return result.joined()", '    return ""', "    //\
    \ Create an array of UInt8 values then XOR them.\n    let xor = Array(a.utf8).map{\
    \ UInt8($0) }.enumerated().map { $1 ^ Array(b.utf8)[$0] }\n    return String(bytes:\
    \ xor, encoding: .utf8)!", "    var result = \"\"\n    for (chara, charb) in zip(a,\
    \ b) {\n        if chara == charb {\n            result.append(\"0\")\n      \
    \  } else {\n            result.append(\"1\")\n        }\n    }\n    return result",
  "    var output: [Int] = []\n    let a_array = Array(a.utf8).map{ Int($0) - 48 }\n\
    \    let b_array = Array(b.utf8).map{ Int($0) - 48 }\n    for index in 0...a_array.count-1\
    \ {\n        if a_array[index] == b_array[index] {\n            output.append(0)\n\
    \        } else {\n            output.append(1)\n        }\n    }\n    return\
    \ output.map(String.init).joined()", "    var ans = \"\"\n    for i in 0..<a.characters.count\
    \ {\n        if a[i] == b[i] {\n            ans += \"0\"\n        } else {\n \
    \           ans += \"1\"\n        }\n    }\n    return ans", '    return "100"',
  "    let a_bytes = [UInt8](a.utf8)\n    let b_bytes = [UInt8](b.utf8)\n    var answer\
    \ = [UInt8]()\n    var ctr = 0\n    while ctr < a_bytes.count {\n        answer.append(a_bytes[ctr]\
    \ ^ b_bytes[ctr])\n        ctr += 1\n    }\n    return String(bytes: answer, encoding:\
    \ .utf8)!"]
stop_tokens:
- "\n}"
