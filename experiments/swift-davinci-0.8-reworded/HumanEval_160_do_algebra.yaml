name: HumanEval_160_do_algebra
language: swift
prompt: "\n/// Given two arrays operator, and operand. The first array has basic algebra\
  \ operations, and \n/// the second array is an array of integers. Use the two given\
  \ arrays to build the algebric \n/// expression and return the evaluation of this\
  \ expression.\n/// The basic algebra operations:\n/// Addition ( + ) \n/// Subtraction\
  \ ( - ) \n/// Multiplication ( * ) \n/// Floor division ( // ) \n/// Exponentiation\
  \ ( ** ) \n/// Example:\n/// operator['+', '*', '-']\n/// array = [2, 3, 4, 5]\n\
  /// result = 2 + 3 * 4 - 5\n/// => result = 9\n/// Note:\n/// The length of operator\
  \ array is equal to the length of operand array minus one.\n/// Operand is an array\
  \ of of non-negative integers.\n/// Operator array has at least one operator, and\
  \ operand array has at least two operands.\nfunc do_algebra(operator: [String],\
  \ operand: [Int]) -> Int {\n"
tests: "}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if\
  \ left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left,\
  \ right) {\n        if l != r {\n            return false\n        }\n    }\n  \
  \  return true\n}\n            \nassert(do_algebra(operator: [\"**\", \"*\", \"\
  +\"], operand: [2, 3, 4, 5]) == 37)\nassert(do_algebra(operator: [\"+\", \"*\",\
  \ \"-\"], operand: [2, 3, 4, 5]) == 9)\nassert(do_algebra(operator: [\"//\", \"\
  *\"], operand: [7, 3, 4]) == 8)"
completions: ["    var total = operand[0]\n    for i in 0..<operator.count {\n   \
    \     if operator[i] == \"+\" {\n            total += operand[i+1]\n        }\
    \ else if operator[i] == \"-\" {\n            total -= operand[i+1]\n        }\
    \ else if operator[i] == \"*\" {\n            total *= operand[i+1]\n        }\
    \ else if operator[i] == \"//\" {\n            total /= operand[i+1]\n       \
    \ } else if operator[i] == \"**\" {\n            total = Int(pow(Double(total),\
    \ Double(operand[i+1])))\n        }\n    }\n    return total", "    var computed\
    \ = [Int]()\n    var count = 0\n    for index in 0..<operator.count {\n      \
    \  if operator[index] == \"*\" {\n            computed.append(operand[index] *\
    \ operand[index + 1])\n            count += 1\n        } else if operator[index]\
    \ == \"/\" {\n            computed.append(operand[index] / operand[index + 1])\n\
    \            count += 1\n        } else if operator[index] == \"-\" {\n      \
    \      computed.append(operand[index] - operand[index + 1])\n            count\
    \ += 1\n        } else if operator[index] == \"+\" {\n            computed.append(operand[index]\
    \ + operand[index + 1])\n            count += 1\n        } else if operator[index]\
    \ == \"^\" {\n            computed.append(operand[index] ^ operand[index + 1])\n\
    \            count += 1\n        }\n    }\n    var answer = 0\n    var index =\
    \ 0\n    if computed.count == 1 {\n        return computed[0]\n    }\n    while\
    \ count > 0 {\n        answer += computed[index]\n        index += 1\n       \
    \ count -= 1\n    }\n    return answer", "  var result = operand[0]\n  for i in\
    \ 0..<operator.count {\n    switch operator[i] {\n    case \"+\":\n      result\
    \ += operand[i + 1]\n    case \"-\":\n      result -= operand[i + 1]\n    case\
    \ \"*\":\n      result *= operand[i + 1]\n    case \"//\":\n      result /= operand[i\
    \ + 1]\n    case \"**\":\n      result = Int(pow(Double(result), Double(operand[i\
    \ + 1])))\n    default:\n      break\n    }\n  }\n  return result", "    var result\
    \ = operand[0]\n    for i in 0..<operator.count {\n        switch operator[i]\
    \ {\n        case \"+\":\n            result += operand[i + 1]\n        case \"\
    -\":\n            result -= operand[i + 1]\n        case \"*\":\n            result\
    \ *= operand[i + 1]\n        case \"//\":\n            result /= operand[i + 1]\n\
    \        case \"**\":\n            result = Int(pow(Double(result), Double(operand[i\
    \ + 1])))\n        default:\n            break\n        }\n    }\n    return result",
  "    var result = operand[0]\n    for i in 0 ..< operator.count {\n        switch\
    \ operator[i] {\n        case \"+\":\n            result += operand[i + 1]\n \
    \       case \"-\":\n            result -= operand[i + 1]\n        case \"*\"\
    :\n            result *= operand[i + 1]\n        case \"//\":\n            result\
    \ /= operand[i + 1]\n        case \"**\":\n            result = Int(pow(Double(result),\
    \ Double(operand[i + 1])))\n        default:\n            break\n        }\n \
    \   }\n    return result", "    var res = operand[0]\n    for i in 0..<operator.count\
    \ {\n        switch operator[i] {\n        case \"+\":\n            res += operand[i+1]\n\
    \        case \"-\":\n            res -= operand[i+1]\n        case \"*\":\n \
    \           res *= operand[i+1]\n        case \"//\":\n            res /= operand[i+1]\n\
    \        case \"**\":\n            res = Int(pow(Double(res), Double(operand[i+1])))\n\
    \        default:\n            return -1\n        }\n    }\n    return res", " \
    \   var result = operand[0]\n    for index in 0..<operator.count {\n        switch\
    \ operator[index] {\n        case \"+\":\n            result += operand[index\
    \ + 1]\n        case \"-\":\n            result -= operand[index + 1]\n      \
    \  case \"*\":\n            result *= operand[index + 1]\n        case \"//\"\
    :\n            result /= operand[index + 1]\n        case \"**\":\n          \
    \  result = Int(pow(Double(result), Double(operand[index + 1])))\n        default:\n\
    \            break\n        }\n    }\n    return result", "    var operandStack:\
    \ [Int] = []\n    for index in 0..<operand.count {\n        if index == 0 {\n\
    \            operandStack.append(operand[index])\n        } else {\n         \
    \   let result = do_operation(operandStack.removeLast(), operand[index], operator[index\
    \ - 1])\n            operandStack.append(result)\n        }\n    }\n    return\
    \ operandStack.first!", '    return -1', "    var value = operand[0]\n    var\
    \ op_array = operator\n    var num_array = operand\n    while op_array.count >\
    \ 0 {\n        if op_array[0] == \"+\" {\n            value += num_array[1]\n\
    \        } else if op_array[0] == \"-\" {\n            value -= num_array[1]\n\
    \        } else if op_array[0] == \"*\" {\n            value *= num_array[1]\n\
    \        } else if op_array[0] == \"//\" {\n            value /= num_array[1]\n\
    \        } else if op_array[0] == \"**\" {\n            value = Int(pow(Double(value),\
    \ Double(num_array[1])))\n        }\n        op_array.removeFirst()\n        num_array.removeFirst()\n\
    \    }\n    return value", "    guard !operator.isEmpty && !operand.isEmpty else\
    \ { return 0 }\n    guard operator.count + 1 == operand.count else { return 0\
    \ }\n    var result = operand[0]\n    for i in 0..<operator.count {\n        switch\
    \ operator[i] {\n        case \"+\":\n            result += operand[i + 1]\n \
    \       case \"-\":\n            result -= operand[i + 1]\n        case \"*\"\
    :\n            result *= operand[i + 1]\n        case \"//\":\n            result\
    \ /= operand[i + 1]\n        case \"**\":\n            result = Int(pow(Double(result),\
    \ Double(operand[i + 1])))\n        default:\n            break\n        }\n \
    \   }\n    return result", "    var result = operand[0]\n    for i in 0..<operator.count\
    \ {\n        switch operator[i] {\n        case \"+\":\n            result +=\
    \ operand[i + 1]\n        case \"-\":\n            result -= operand[i + 1]\n\
    \        case \"*\":\n            result *= operand[i + 1]\n        case \"//\"\
    :\n            result /= operand[i + 1]\n        case \"**\":\n            result\
    \ = Int(pow(Double(result), Double(operand[i + 1])))\n        default:\n     \
    \       break\n        }\n    }\n    return result", "\t\n\tvar result = operand[0]\n\
    \t\n\tfor i in 0..<operator.count {\n\t\tswitch operator[i] {\n\t\tcase \"+\"\
    :\n\t\t\tresult += operand[i+1]\n\t\tcase \"-\":\n\t\t\tresult -= operand[i+1]\n\
    \t\tcase \"*\":\n\t\t\tresult *= operand[i+1]\n\t\tcase \"//\":\n\t\t\tresult\
    \ /= operand[i+1]\n\t\tcase \"**\":\n\t\t\tresult = Int(pow(Double(result), Double(operand[i+1])))\n\
    \t\tdefault:\n\t\t\tbreak\n\t\t}\n\t}\n\t\n\treturn result", "    if operator.count\
    \ == 0 || operand.count < 2 {\n        return 0\n    }\n    var result = operand[0]\n\
    \    for index in 0..<operator.count {\n        if operator[index] == \"+\" {\n\
    \            result += operand[index + 1]\n        } else if operator[index] ==\
    \ \"-\" {\n            result -= operand[index + 1]\n        } else if operator[index]\
    \ == \"*\" {\n            result *= operand[index + 1]\n        } else if operator[index]\
    \ == \"//\" {\n            result /= operand[index + 1]\n        } else if operator[index]\
    \ == \"**\" {\n            result = Int(pow(Double(result), Double(operand[index\
    \ + 1])))\n        }\n    }\n    return result", "    if operand.count == 0 {\n\
    \        return 0\n    }\n    else if operand.count == 1 {\n        return operand[0]\n\
    \    }\n    else {\n        var result = operand[0]\n        for i in 0..<operator.count\
    \ {\n            switch operator[i] {\n            case \"+\":\n             \
    \   result += operand[i+1]\n            case \"-\":\n                result -=\
    \ operand[i+1]\n            case \"*\":\n                result *= operand[i+1]\n\
    \            case \"//\":\n                result /= operand[i+1]\n          \
    \  case \"**\":\n                result = Int(pow(Double(result), Double(operand[i+1])))\n\
    \            default:\n                break\n            }\n        }\n     \
    \   return result\n    }", "  //TODO: implement your algorithm here\n  return\
    \ -1", "    var result = operand[0]\n    for (index, element) in operand.enumerated()\
    \ {\n        if index == 0 {\n            continue\n        }\n        let operation\
    \ = operator[index - 1]\n        switch operation {\n        case \"+\":\n   \
    \         result += element\n        case \"-\":\n            result -= element\n\
    \        case \"*\":\n            result *= element\n        case \"//\":\n  \
    \          result /= element\n        case \"**\":\n            result = Int(pow(Double(result),\
    \ Double(element)))\n        default:\n            break\n        }\n    }\n \
    \   return result", '    return 0', "    var result = operand[0]\n    var i =\
    \ 0\n    while i < operator.count {\n        switch operator[i] {\n        case\
    \ \"+\":\n            result += operand[i + 1]\n        case \"-\":\n        \
    \    result -= operand[i + 1]\n        case \"*\":\n            result *= operand[i\
    \ + 1]\n        case \"//\":\n            result /= operand[i + 1]\n        case\
    \ \"**\":\n            result = pow(result, operand[i + 1])\n        default:\n\
    \            break\n        }\n        i += 1\n    }\n    return result", "  \
    \  let equations = operand.reduce((0, []) as (Int, [Int]), {\n        (accumulator,\
    \ current) in\n        (current, accumulator.1 + [current])\n    }).1.reduce((0,\
    \ []) as (Int, [Int]), {\n        (accumulator, current) in\n        let operation\
    \ = operator.isEmpty ? \"\" : operator.remove(at: 0)\n        switch operation\
    \ {\n        case \"+\":\n            return (accumulator.0 + current, accumulator.1\
    \ + [accumulator.0 + current])\n        case \"-\":\n            return (accumulator.0\
    \ - current, accumulator.1 + [accumulator.0 - current])\n        case \"*\":\n\
    \            return (accumulator.0 * current, accumulator.1 + [accumulator.0 *\
    \ current])\n        case \"//\":\n            return (accumulator.0 / current,\
    \ accumulator.1 + [accumulator.0 / current])\n        case \"**\":\n         \
    \   return (Int(pow(Double(accumulator.0), Double(current))), accumulator.1 +\
    \ [Int(pow(Double(accumulator.0), Double(current)))])\n        default:\n    \
    \        return (current, accumulator.1 + [current])\n        }\n    }).1.last!\n\
    \    return equations"]
stop_tokens:
- "\n}"
