name: HumanEval_128_prod_signs
language: swift
prompt: "\n/// You are given an array arr of integers and you need to return\n///\
  \ sum of magnitudes of integers multiplied by product of all signs\n/// of each\
  \ number in the array, represented by 1, -1 or 0.\n/// Note: return nil for empty\
  \ arr.\n/// Example:\n/// >>> prod_signs(arr: [1, 2, 2, -4])\n/// 9\n/// >>> prod_signs(arr:\
  \ [0, 1])\n/// 0\n/// >>> prod_signs(arr: [] as [Int])\n/// nil\nfunc prod_signs(arr:\
  \ [Int]) -> Int? {\n"
tests: "}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if\
  \ left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left,\
  \ right) {\n        if l != r {\n            return false\n        }\n    }\n  \
  \  return true\n}\n            \nassert(prod_signs(arr: [1, 2, 2, -4]) == -9)\n\
  assert(prod_signs(arr: [0, 1]) == 0)\nassert(prod_signs(arr: [1, 1, 1, 2, 3, -1,\
  \ 1]) == -10)\nassert(prod_signs(arr: [] as [Int]) == nil)\nassert(prod_signs(arr:\
  \ [2, 4, 1, 2, -1, -1, 9]) == 20)\nassert(prod_signs(arr: [-1, 1, -1, 1]) == 4)\n\
  assert(prod_signs(arr: [-1, 1, 1, 1]) == -4)\nassert(prod_signs(arr: [-1, 1, 1,\
  \ 0]) == 0)"
completions: ["    guard arr.count > 0 else { return nil }\n    let sign_product =\
    \ arr.reduce(1) { $0 * sign_of($1) }\n    let abs_sum = arr.reduce(0) { $0 + abs($1)\
    \ }\n    return sign_product * abs_sum", "    if arr.isEmpty {\n        return\
    \ nil\n    }\n    var prod = 1\n    var magn = 0\n    for num in arr {\n     \
    \   prod *= num > 0 ? 1 : num < 0 ? -1 : 0\n        magn += abs(num)\n    }\n\
    \    return prod * magn", "    guard arr.count > 0 else { return nil }\n    var\
    \ sum = 0\n    var prod = 1\n    for x in arr {\n        if x > 0 {\n        \
    \    sum += x\n            prod *= 1\n        } else if x < 0 {\n            sum\
    \ += -x\n            prod *= -1\n        } else {\n            prod *= 0\n   \
    \     }\n    }\n    return sum * prod", "    guard arr.count > 0 else {\n    \
    \    return nil\n    }\n    var signs = 1\n    var mag = 0\n    for el in arr\
    \ {\n        if el != 0 {\n            signs *= el / abs(el)\n            mag\
    \ += abs(el)\n        }\n    }\n    return signs * mag", "    if arr.isEmpty {\n\
    \        return nil\n    }\n    let signs: [Int] = arr.map { (num) -> Int in\n\
    \        switch num {\n        case _ where num > 0:\n            return 1\n \
    \       case _ where num < 0:\n            return -1\n        default:\n     \
    \       return 0\n        }\n    }\n    let mags: [Int] = arr.map { abs($0) }\n\
    \    let signs_prod = signs.reduce(1, *)\n    let mags_sum = mags.reduce(0, +)\n\
    \    return signs_prod * mags_sum", "    guard arr.count > 0 else { return nil\
    \ }\n    let mags = arr.map { abs($0) }\n    let prods = arr.map { $0 < 0 ? -1\
    \ : ($0 > 0 ? 1 : 0) }\n    let magnitude = mags.reduce(0, +)\n    let prod =\
    \ prods.reduce(1, *)\n    return magnitude * prod", "    if arr.isEmpty {\n  \
    \      return nil\n    }\n    let sign = arr.reduce(1) { $0 * $1.signum() }\n\
    \    let magnitude = arr.reduce(0) { $0 + $1.magnitude }\n    return sign * magnitude",
  "\tlet product = arr.reduce(1) { $0 * ($1 < 0 ? -1 : $1 == 0 ? 0 : 1) }\n\treturn\
    \ product == 0 ? nil : arr.reduce(0) { $0 + $1 * product }", "  if arr.isEmpty\
    \ {\n    return nil\n  }\n\n  let sign = arr.reduce(1) { $0 * ($1 > 0 ? 1 : ($1\
    \ < 0 ? -1 : 0)) }\n  let sum = arr.reduce(0) { abs($0) + abs($1) }\n  return\
    \ sign * sum", "    guard arr.count > 0 else {\n        return nil\n    }\n  \
    \  let signs = arr.map { number in\n        if number == 0 {\n            return\
    \ 0\n        } else if number > 0 {\n            return 1\n        } else {\n\
    \            return -1\n        }\n    }\n    return arr.map { abs($0) }.reduce(1,\
    \ *) * signs.reduce(1, *)", '    return nil', "    if arr.isEmpty {\n        return\
    \ nil\n    }\n    var prod = 1\n    var sum = 0\n    for num in arr {\n      \
    \  prod *= (num > 0 ? 1 : (num < 0 ? -1 : 0))\n        sum += abs(num)\n    }\n\
    \    return prod * sum", "    if arr.isEmpty {\n        return nil\n    }\n  \
    \  else {\n        var prod: Int = 1\n        var sum: Int = 0\n        for item\
    \ in arr {\n            if item < 0 {\n                prod *= -1\n          \
    \  }\n            else if item > 0 {\n                prod *= 1\n            }\n\
    \            else {\n                prod *= 0\n            }\n            sum\
    \ += abs(item)\n        }\n        return sum * prod\n    }", "    if arr.isEmpty\
    \ {\n        return nil\n    } else {\n        var product: Int = 1\n        var\
    \ sum: Int = 0\n        for i in arr {\n            if i > 0 {\n             \
    \   product *= 1\n                sum += i\n            } else if i < 0 {\n  \
    \              product *= -1\n                sum += abs(i)\n            } else\
    \ {\n                product *= 0\n            }\n        }\n        return product\
    \ * sum\n    }", "    if arr.isEmpty {\n        return nil\n    }\n    var sign:\
    \ Int = 1\n    var sum: Int = 0\n    for i in arr {\n        if i == 0 {\n   \
    \         sign = 0\n        } else if i < 0 {\n            sign *= -1\n      \
    \  }\n        sum += abs(i)\n    }\n    return sum * sign", "    guard arr.count\
    \ > 0 else { return nil }\n    let signs = arr.map { sign($0) }\n    let mags\
    \ = arr.map { abs($0) }\n    let prod = signs.reduce(1, *)\n    let sum = mags.reduce(0,\
    \ +)\n    return prod * sum", "    var product: Int = 1\n    var sum: Int = 0\n\
    \    guard arr.count > 0 else { return nil }\n    for i in arr {\n        if i\
    \ == 0 {\n            continue\n        } else if i > 0 {\n            product\
    \ *= 1\n            sum += i\n        } else {\n            product *= -1\n  \
    \          sum += i.magnitude\n        }\n    }\n    return sum * product", " \
    \ if arr.isEmpty {\n    return nil\n  }\n  var product = 1\n  var sum = 0\n  for\
    \ i in arr {\n    if i > 0 {\n      product *= 1\n    } else if i < 0 {\n    \
    \  product *= -1\n    } else {\n      product *= 0\n    }\n    sum += abs(i)\n\
    \  }\n  return sum * product", '    return arr.isEmpty ? nil : arr.map{ abs($0)
    }.reduce(1, *) * arr.map{ $0 == 0 ? 0 : $0 > 0 ? 1 : -1 }.reduce(1, *)', "   \
    \ guard arr.count > 0 else {\n        return nil\n    }\n    let signs = arr.map\
    \ { $0.signum() }\n    let pr = signs.reduce(1, *)\n    let sum = arr.reduce(0,\
    \ +)\n    return abs(sum) * pr", "    var product: Int = 1\n    for number in\
    \ arr {\n        if number < 0 {\n            product *= -1\n        } else if\
    \ number == 0 {\n            return 0\n        }\n    }\n    var sum = 0\n   \
    \ for number in arr {\n        sum += abs(number)\n    }\n    return sum * product",
  "    return (arr.isEmpty) ? nil :\n        Int(arr.filter { $0 < 0 }.count % 2 ==\
    \ 0 ? 1 : -1) *\n        arr.map { abs($0) }.reduce(1, *)", "    var res: Int?\
    \ = nil\n    var product: Int = 1\n    var magnitude: Int = 0\n    for number\
    \ in arr {\n        product *= number.signum()\n        magnitude += number.magnitude\n\
    \    }\n    if magnitude != 0 {\n        res = product * magnitude\n    }\n  \
    \  return res", "    if arr.isEmpty {\n        return nil\n    }\n    var prod\
    \ = 1\n    var sum = 0\n    for value in arr {\n        if value < 0 {\n     \
    \       prod *= -1\n        } else if value > 0 {\n            prod *= 1\n   \
    \     } else {\n            prod *= 0\n        }\n        sum += abs(value)\n\
    \    }\n    return sum * prod", "  let result = arr.map { $0 == 0 ? 1 : $0 < 0\
    \ ? -1 : 1 }.reduce(1, *)\n  return arr.count == 0 ? nil : result * arr.map {\
    \ abs($0) }.reduce(0, +)", "    var result: Int? = nil\n    var product: Int =\
    \ 1\n    var sum: Int = 0\n    if arr.count > 0 {\n        for i in arr {\n  \
    \          let si = sign(num: i)\n            if si == 1 {\n                product\
    \ *= 1\n            } else if si == -1 {\n                product *= -1\n    \
    \        } else {\n                product *= 0\n            }\n            sum\
    \ += abs(i)\n        }\n        result = sum * product\n    }\n    return result",
  "  if arr.isEmpty {\n    return nil\n  }\n  var prod = 1\n  var sum = 0\n  for i\
    \ in arr {\n    prod *= i.signum()\n    sum += i.magnitude\n  }\n  return prod\
    \ * sum", "    guard arr.count > 0 else {\n        return nil\n    }\n    let\
    \ mags = arr.map { abs($0) }\n    let sign = arr.map { $0 == 0 ? 0 : $0 > 0 ?\
    \ 1 : -1 }\n    let prod = sign.reduce(1, *)\n    return mags.reduce(0, +) * prod",
  "  if arr.isEmpty {\n    return nil\n  }\n  var product = 1\n  var sum = 0\n  for\
    \ number in arr {\n    if number == 0 {\n      continue\n    }\n    sum += abs(number)\n\
    \    if number > 0 {\n      product *= 1\n    } else {\n      product *= -1\n\
    \    }\n  }\n  return sum * product", "    guard arr.count > 0 else { return nil\
    \ }\n    var sum = 0\n    var prod = 1\n    for i in arr {\n        if i > 0 {\
    \ sum += i }\n        else if i < 0 { sum += abs(i); prod *= -1 }\n    }\n   \
    \ return sum * prod", "    return arr.reduce((sum: 0, pos: 1, neg: 1), {\n   \
    \     let sign = $1 >= 0 ? 1 : -1\n        let result = $0.sum + abs($1) * ($0.pos\
    \ * sign + $0.neg * (sign * -1))\n        return (result, $0.pos * sign, $0.neg\
    \ * (sign * -1))\n    }).sum", "    if arr.isEmpty {\n        return nil\n   \
    \ }\n    let sum = arr.map { $0 < 0 ? $0 * -1 : $0 }.reduce(0, +)\n    let prod\
    \ = arr.map { $0 < 0 ? -1 : $0 == 0 ? 0 : 1 }.reduce(1, *)\n    return sum * prod",
  "    guard arr.count > 0 else {\n        return nil\n    }\n    let sign_prod =\
    \ arr.reduce(1) { $0 * $1.signum() }\n    let sum = arr.reduce(0) { abs($0) +\
    \ abs($1) }\n    return sum * sign_prod", "    if arr.isEmpty {\n        return\
    \ nil\n    }\n    let prod = arr.map {$0.signum()}.reduce(1, *)\n    let abs_sum\
    \ = arr.map {abs($0)}.reduce(0, +)\n    return prod * abs_sum", "    if arr.isEmpty\
    \ {\n        return nil\n    }\n    return arr.map { ($0 != 0) ? $0 : 1 }.reduce(1,\
    \ *) * arr.map { abs($0) }.reduce(0, +)", '    return arr.count == 0 ? nil : arr.reduce(1)
    { $0 * ($1 > 0 ? 1 : $1 < 0 ? -1 : 0) } * arr.reduce(0) { $0 + abs($1) }', " \
    \   guard arr.count > 0 else {\n        return nil\n    }\n    let signs = arr.map\
    \ {\n        $0 == 0 ? 0 : $0 > 0 ? 1 : -1\n    }\n    let mags = arr.map {\n\
    \        abs($0)\n    }\n    let signProd = signs.reduce(1, *)\n    let sumMags\
    \ = mags.reduce(0, +)\n    return signProd * sumMags", "    let productOfSigns\
    \ = (arr.filter { $0 != 0 }).reduce(1) { $0 * signOf(number: $1) }\n    let sumOfMagnitudes\
    \ = arr.reduce(0) { $0 + magnitudeOf(number: $1) }\n    return arr.isEmpty ? nil\
    \ : productOfSigns * sumOfMagnitudes", "    if arr.isEmpty {\n        return nil\n\
    \    }\n    return arr.reduce(into: (signs: [1], magnitudes: 0)) { (res, num)\
    \ in\n        res.signs.append(num.signum())\n        res.magnitudes += abs(num)\n\
    \    }.signs.reduce(1, *) * res.magnitudes", "    guard arr.count > 0 else { return\
    \ nil }\n    var prod = 1\n    var sum = 0\n    for number in arr {\n        prod\
    \ *= number > 0 ? 1 : number < 0 ? -1 : 0\n        sum += abs(number)\n    }\n\
    \    return prod * sum", "    guard arr.count > 0 else {\n        return nil\n\
    \    }\n    var sign_prod = 1\n    var abs_sum = 0\n    for num in arr {\n   \
    \     sign_prod *= sign(of: num)\n        abs_sum += abs(num)\n    }\n    return\
    \ sign_prod * abs_sum", "    guard arr.count > 0 else { return nil }\n    return\
    \ arr.map { ($0 > 0 ? 1 : -1) * abs($0) }.reduce(1, *)", "    guard arr.count\
    \ > 0 else { return nil }\n    return arr.map({ abs($0) }).reduce(1, *) * arr.map({\
    \ $0 == 0 ? 0 : $0 / abs($0) }).reduce(1, *)", "    var prod = 1\n    var sum\
    \ = 0\n    for i in arr {\n        if i == 0 {\n            continue\n       \
    \ }\n        sum += abs(i)\n        prod *= i > 0 ? 1 : -1\n    }\n    return\
    \ arr.isEmpty ? nil : sum * prod", "  guard !arr.isEmpty else { return nil }\n\
    \  let magnitudes = arr.map { abs($0) }\n  let signs = arr.map { $0 == 0 ? 0 :\
    \ $0 / abs($0) }\n  let total_sign = signs.reduce(1, *)\n  let total_magnitude\
    \ = magnitudes.reduce(0, +)\n  return total_magnitude * total_sign", "    var\
    \ result: Int? = nil\n    var sum: Int = 0\n    var prod: Int = 1\n    for n in\
    \ arr {\n        if n != 0 {\n            sum += n\n            prod *= n < 0\
    \ ? -1 : 1\n        }\n    }\n    if sum != 0 {\n        result = prod * sum\n\
    \    }\n    return result", "    guard arr.count > 0 else { return nil }\n   \
    \ var prod = 0\n    var sum = 0\n    for num in arr {\n        prod += num ==\
    \ 0 ? 0 : (num > 0 ? 1 : -1)\n        sum += abs(num)\n    }\n    return prod\
    \ == 0 ? 0 : prod * sum", "    if arr.isEmpty {\n        return nil\n    }\n \
    \   var prod = 1\n    var sum = 0\n    for item in arr {\n        let sign = item\
    \ < 0 ? -1 : (item > 0 ? 1 : 0)\n        prod *= sign\n        sum += abs(item)\n\
    \    }\n    return sum * prod", "    let prod = arr.reduce(1) { $0 * $1.signum()\
    \ }\n    return arr.map { $0.magnitude }.reduce(0, +) * prod", "    if arr.isEmpty\
    \ {\n        return nil\n    }\n    var sum = 0\n    var mul = 1\n    for i in\
    \ arr {\n        if i == 0 {\n            continue\n        }\n        sum +=\
    \ abs(i)\n        mul *= i > 0 ? 1 : -1\n    }\n    return sum * mul", "\tguard\
    \ !arr.isEmpty else { return nil }\n\treturn arr.map { $0 > 0 ? 1 : $0 < 0 ? -1\
    \ : 0 }.reduce(1, *) * arr.map { abs($0) }.reduce(0, +)", '  return nil', "  \
    \  guard arr.count > 0 else { return nil }\n    let signs = arr.map { $0 == 0\
    \ ? 0 : ($0 > 0 ? 1 : -1) }\n    let nums = arr.map { $0 == 0 ? 0 : abs($0) }\n\
    \    return signs.reduce(1, *) * nums.reduce(0, +)", "    guard arr.count > 0\
    \ else {\n        return nil\n    }\n    return arr.map{ abs($0) }.reduce(1, {\
    \ $0 * $1 }) * arr.map{ $0 > 0 ? 1 : ($0 < 0 ? -1 : 0) }.reduce(1, { $0 * $1 })",
  "    if arr.isEmpty {\n        return nil\n    }\n    let result = arr.reduce(1)\
    \ { (prev, next) -> Int in\n        return prev * next\n    }\n    return result.magnitude",
  "    if arr.isEmpty {\n        return nil\n    }\n    let sum = arr.map { abs($0)\
    \ }.reduce(0, +)\n    let prod = arr.map {\n        if $0 > 0 {\n            return\
    \ 1\n        } else if $0 < 0 {\n            return -1\n        } else {\n   \
    \         return 0\n        }\n    }.reduce(1, *)\n    return sum * prod", " \
    \   if arr.isEmpty {\n        return nil\n    } else {\n        let signs = arr.map\
    \ { x in (x == 0) ? 0 : (x > 0) ? 1 : -1 }\n        let mags = arr.map { abs($0)\
    \ }\n        return (signs.reduce(1, *)) * (mags.reduce(0, +))\n    }", "    guard\
    \ arr.count > 0 else { return nil }\n    let sign = arr.map { $0 > 0 ? 1 : $0\
    \ < 0 ? -1 : 0 }\n    let mag = arr.map { abs($0) }\n    return sign.reduce(1,\
    \ *) * mag.reduce(0, +)", '    return nil', "    if arr.isEmpty {\n        return\
    \ nil\n    }\n    let signs: [Int] = arr.map {\n        if $0 == 0 {\n       \
    \     return 0\n        } else if $0 > 0 {\n            return 1\n        } else\
    \ {\n            return -1\n        }\n    }\n    let signProduct = signs.reduce(1,\
    \ *)\n    let mags = arr.map { abs($0) }\n    let magSum = mags.reduce(0, +)\n\
    \    return magSum * signProduct", "    if arr.isEmpty {\n        return nil\n\
    \    }\n    return arr.reduce(into: 0) { $0 += $1 < 0 ? -1 : ($1 > 0 ? 1 : 0)\
    \ } *\n        arr.reduce(into: 1) { $0 *= $1 < 0 ? -$1 : $1 }", "    guard arr.count\
    \ > 0 else {\n        return nil\n    }\n    var multi = 1\n    var sum = 0\n\
    \    for i in arr {\n        if i > 0 {\n            multi *= 1\n        } else\
    \ if i < 0 {\n            multi *= -1\n        } else {\n            multi *=\
    \ 0\n        }\n        sum += abs(i)\n    }\n    return sum * multi", '    return
    arr.isEmpty ? nil : arr.map { abs($0) }.reduce(1, *) * arr.map { $0 < 0 ? -1 :
    $0 > 0 ? 1 : 0 }.reduce(1, *)', "    guard arr.count > 0 else {\n        return\
    \ nil\n    }\n    var sum = 0\n    var prod = 1\n    for element in arr {\n  \
    \      if element == 0 {\n            prod = 0\n            break\n        }\n\
    \        else if element > 0 {\n            sum += element\n        }\n      \
    \  else {\n            sum -= element\n            prod *= -1\n        }\n   \
    \ }\n    return sum * prod", "    guard arr.count > 0 else { return nil }\n  \
    \  var _arr = arr\n    var prod = _arr.removeFirst()\n    for idx in 0..<_arr.count\
    \ {\n        prod *= _arr[idx] > 0 ? 1 : -1\n    }\n    return arr.reduce(0, {\
    \ $0 + abs($1) }) * prod", "    let arr_magnitudes = arr.map { $0 >= 0 ? $0 :\
    \ -$0 }\n    let arr_signs = arr.map { $0 == 0 ? 0 : $0 > 0 ? 1 : -1 }\n    guard\
    \ arr_magnitudes.count > 0 else { return nil }\n    let sum_magnitudes = arr_magnitudes.reduce(0,\
    \ +)\n    let prod_signs = arr_signs.reduce(1, *)\n    return sum_magnitudes *\
    \ prod_signs", "    if arr.isEmpty {\n        return nil\n    }\n    let product\
    \ = arr.filter {$0 != 0}.reduce(1) {$0 * ($1 / abs($1))}\n    let sum = arr.reduce(0)\
    \ {$0 + abs($1)}\n    return product * sum", "    var result: Int? = nil\n   \
    \ if arr.count > 0 {\n        result = 0\n        var prod: Int = 1\n        for\
    \ num in arr {\n            result! += abs(num)\n            prod *= sign_int(num:\
    \ num)\n        }\n        result! *= prod\n    }\n    return result", "  guard\
    \ !arr.isEmpty else { return nil }\n  var signs: Int = 1\n  var sum: Int = 0\n\
    \  for el in arr {\n    if el == 0 {\n      continue\n    }\n    sum += abs(el)\n\
    \    signs *= el > 0 ? 1 : -1\n  }\n  return sum * signs", "    if arr.isEmpty\
    \ {\n        return nil\n    }\n    var sum = 0\n    for i in arr {\n        sum\
    \ += abs(i)\n    }\n    var prod = 1\n    for i in arr {\n        prod *= i >=\
    \ 0 ? 1 : -1\n    }\n    return sum * prod", '    return nil', "    return arr.isEmpty\
    \ ? nil :\n        arr.reduce(1) { $0 * $1.signum() } *\n        arr.reduce(0)\
    \ { $0 + abs($1) }", "    guard arr.count > 0 else { return nil }\n    var prod\
    \ = 1\n    var sum = 0\n    for n in arr {\n        prod *= sign(n)\n        sum\
    \ += abs(n)\n    }\n    return prod * sum", "    guard arr.count > 0 else {\n\
    \        return nil\n    }\n    var product = 1\n    var result = 0\n    for i\
    \ in arr {\n        if i == 0 {\n            continue\n        }\n        result\
    \ += abs(i)\n        product *= i / abs(i)\n    }\n    return result * product",
  "    guard arr.count > 0 else { return nil }\n    var sum = 0\n    var product =\
    \ 1\n    for element in arr {\n        sum += abs(element)\n        product *=\
    \ signum(element)\n    }\n    return sum * product", "    let empty = arr.count\
    \ == 0\n    if empty {\n        return nil\n    }\n    let signs = arr.map({\n\
    \        if $0 > 0 {\n            return 1\n        } else if $0 < 0 {\n     \
    \       return -1\n        } else {\n            return 0\n        }\n    })\n\
    \    let sum_signs = signs.reduce(1, *)\n    let sum_magnitudes = arr.map { abs($0)\
    \ }.reduce(0, +)\n    return sum_magnitudes * sum_signs", "    guard arr.count\
    \ > 0 else {\n        return nil\n    }\n    var prod: Int = 1\n    var sum: Int\
    \ = 0\n    for i in arr {\n        prod *= i / abs(i)\n        sum += abs(i)\n\
    \    }\n    return sum * prod", "    if arr.isEmpty {\n        return nil\n  \
    \  }\n    var sum = 0\n    var prod = 1\n    for val in arr {\n        prod *=\
    \ val >= 0 ? 1 : -1\n        sum += abs(val)\n    }\n    return sum * prod", " \
    \   var prod = 1\n    var sum = 0\n    for num in arr {\n        if num > 0 {\n\
    \            prod *= 1\n        } else if num < 0 {\n            prod *= -1\n\
    \        } else {\n            prod *= 0\n        }\n        sum += num\n    }\n\
    \    return sum * prod", '    return nil', "    if arr.isEmpty {\n        return\
    \ nil\n    }\n    var sign = 1\n    var sum = 0\n    for num in arr {\n      \
    \  if num == 0 {\n            continue\n        }\n        sign *= num > 0 ? 1\
    \ : -1\n        sum += abs(num)\n    }\n    return sum * sign", '    return arr.isEmpty
    ? nil : arr.map {$0.signum()}.reduce(1, *) * arr.map {abs($0)}.reduce(0, +)',
  "    guard arr.count > 0 else { return nil }\n    var sum_of_magnitudes = 0\n  \
    \  var product_of_signs = 1\n    for element in arr {\n        sum_of_magnitudes\
    \ += abs(element)\n        switch element {\n        case 1: product_of_signs\
    \ *= 1\n        case 0: product_of_signs *= 0\n        default: product_of_signs\
    \ *= -1\n        }\n    }\n    return sum_of_magnitudes * product_of_signs", " \
    \   if arr.isEmpty {\n        return nil\n    }\n    var prod = 1\n    var sum\
    \ = 0\n    for i in arr {\n        if i < 0 {\n            prod *= -1\n      \
    \  } else if i > 0 {\n            prod *= 1\n        } else {\n            prod\
    \ *= 0\n        }\n        sum += abs(i)\n    }\n    return sum * prod", "   \
    \ var product = 1\n    var sum = 0\n    for num in arr {\n        if num < 0 {\n\
    \            product *= -1\n        } else if num > 0 {\n            product *=\
    \ 1\n        } else {\n            product *= 0\n        }\n        sum += abs(num)\n\
    \    }\n    return product * sum", '    return arr.isEmpty ? nil : prod_signs_helper(arr:
    arr, prod: 1, sum: 0)', "    var count = 0\n    for n in arr {\n        if n >\
    \ 0 {\n            count += 1\n        } else if n < 0 {\n            count -=\
    \ 1\n        }\n    }\n    if count == 0 {\n        return 0\n    }\n    return\
    \ arr.map { abs($0) }.reduce(1, *) * count / abs(count)", "    var sum = 0\n \
    \   var total = 1\n    for num in arr {\n        if num > 0 {\n            sum\
    \ += num\n            total *= 1\n        } else if num < 0 {\n            sum\
    \ += num\n            total *= -1\n        } else {\n            total *= 0\n\
    \        }\n    }\n    if total == 0 {\n        return nil\n    }\n    return\
    \ sum * total", "    if arr.isEmpty {\n        return nil\n    }\n    var sum\
    \ = 0\n    var prod = 1\n    for num in arr {\n        prod *= num.signum()\n\
    \        sum += abs(num)\n    }\n    return sum * prod", '  return nil', "   \
    \ let magnitudes = arr.map { abs($0) }\n    guard !magnitudes.isEmpty else { return\
    \ nil }\n    let signs = arr.map { sign($0) }\n    return magnitudes.reduce(1,\
    \ *) * signs.reduce(1, *)", "    var prod = 1\n    var sum = 0\n    if arr.count\
    \ == 0 {\n        return nil\n    }\n    for i in arr {\n        prod *= i < 0\
    \ ? -1 : (i == 0 ? 0 : 1)\n        sum += abs(i)\n    }\n    return prod * sum",
  "  if arr.isEmpty {\n    return nil\n  }\n  let signProd = arr.map { s in s < 0\
    \ ? -1 : s > 0 ? 1 : 0 }.reduce(1, *)\n  let magnitudes = arr.map { abs($0) }\n\
    \  return magnitudes.reduce(0, +) * signProd", "    var res = 0\n    var prod\
    \ = 1\n    var empty = true\n    for i in arr {\n        if i == 0 {\n       \
    \     continue\n        }\n        empty = false\n        if i > 0 {\n       \
    \     res += i\n        } else {\n            res -= i\n            prod *= -1\n\
    \        }\n    }\n    return empty ? nil : res * prod", "    guard arr.count\
    \ > 0 else { return nil }\n    let sign_product = arr.reduce(1) {\n        if\
    \ $1 > 0 { return $0 * 1 }\n        else if $1 < 0 { return $0 * -1 }\n      \
    \  else { return $0 * 0 }\n    }\n    let arr_abs = arr.map { abs($0) }\n    let\
    \ abs_sum = arr_abs.reduce(0, +)\n    return abs_sum * sign_product", "  if arr.isEmpty\
    \ {\n    return nil\n  }\n  var sum = 0\n  var product = 1\n  for i in arr {\n\
    \    sum += i\n    if i > 0 {\n      product *= 1\n    } else if i < 0 {\n   \
    \   product *= -1\n    } else {\n      product *= 0\n    }\n  }\n  return sum\
    \ * product", "    if arr.isEmpty {\n        return nil\n    }\n    var sum =\
    \ 0\n    var prod = 1\n    for i in arr {\n        sum += abs(i)\n        prod\
    \ *= i > 0 ? 1 : (i < 0 ? -1 : 0)\n    }\n    return sum * prod", '    return
    nil', "    if arr.isEmpty {\n        return nil\n    }\n    let signs = arr.map\
    \ { (x: Int) -> Int in\n        if x == 0 {\n            return 0\n        } else\
    \ if x > 0 {\n            return 1\n        } else {\n            return -1\n\
    \        }\n    }\n    let prod = signs.reduce(1, *)\n    let abs = arr.map {\
    \ abs($0) }\n    let result = abs.reduce(0, +)\n    return result * prod", " \
    \   if arr.isEmpty {\n        return nil\n    }\n    let prod = arr.map { $0 <\
    \ 0 ? -1 : $0 > 0 ? 1 : 0 }.reduce(1, *)\n    let sum = arr.map { abs($0) }.reduce(0,\
    \ +)\n    return sum * prod", "\tguard arr.count > 0 else { return nil }\n\tlet\
    \ signOf = { (num: Int) -> Int in\n\t\tif num == 0 { return 0 }\n\t\treturn (num\
    \ > 0) ? 1 : -1\n\t}\n\tvar prod = 1\n\tvar sum = 0\n\tfor n in arr {\n\t\tlet\
    \ s = signOf(n)\n\t\tprod *= s\n\t\tsum += (n * s)\n\t}\n\treturn sum * prod",
  "    var prod = 1\n    var total = 0\n    for number in arr {\n        if number\
    \ > 0 {\n            prod *= 1\n        } else if number < 0 {\n            prod\
    \ *= -1\n        } else {\n            prod *= 0\n        }\n        total +=\
    \ abs(number)\n    }\n    return total * prod", "    guard arr.count > 0 else\
    \ { return nil }\n    let prod = arr.map { $0 == 0 ? 0 : $0 > 0 ? 1 : -1 }.reduce(1,\
    \ *)\n    let sum = arr.map { abs($0) }.reduce(0, +)\n    return sum * prod",
  "    var sum = 0\n    var product = 1\n    for el in arr {\n        sum += abs(el)\n\
    \        if el < 0 {\n            product *= -1\n        } else if el > 0 {\n\
    \            product *= 1\n        }\n    }\n    if product == 0 {\n        return\
    \ nil\n    }\n    return sum * product", "    guard arr.count > 0 else {\n   \
    \     return nil\n    }\n    var product = 1\n    var sum = 0\n    for i in arr\
    \ {\n        product *= sign_num(i)\n        sum += abs(i)\n    }\n    return\
    \ product * sum", "    guard arr.count > 0 else { return nil }\n    var prod =\
    \ 1\n    var sums = 0\n    for i in arr {\n        prod *= i > 0 ? 1 : (i < 0\
    \ ? -1 : 0)\n        sums += abs(i)\n    }\n    return prod * sums", "    guard\
    \ arr.count > 0 else {\n        return nil\n    }\n    let prod = arr.reduce(1)\
    \ {$0 * $1.signum()}\n    let sum = arr.reduce(0) {$0 + abs($1)}\n    return prod\
    \ * sum", "    if arr.isEmpty {\n        return nil\n    }\n    var prodSigns\
    \ = 1\n    var sumMagnitude = 0\n    for num in arr {\n        prodSigns *= sign(num)\n\
    \        sumMagnitude += magnitude(num)\n    }\n    return prodSigns * sumMagnitude",
  "    var sum = 0\n    var prod = 1\n    for i in arr {\n        if i > 0 {\n   \
    \         sum += i\n            prod *= 1\n        } else if i < 0 {\n       \
    \     sum += -i\n            prod *= -1\n        } else {\n            sum +=\
    \ 0\n            prod *= 0\n        }\n    }\n    return sum * prod", "    guard\
    \ arr.count > 0 else {\n        return nil\n    }\n    var prod: Int = 1\n   \
    \ var sum: Int = 0\n    for elem in arr {\n        if elem > 0 {\n           \
    \ prod *= 1\n        } else if elem < 0 {\n            prod *= -1\n        } else\
    \ {\n            prod *= 0\n        }\n        sum += abs(elem)\n    }\n    return\
    \ sum * prod", "    guard arr.count > 0 else { return nil }\n    let a = arr.map({\
    \ $0 > 0 ? 1 : ($0 < 0 ? -1 : 0) })\n    return a.reduce(1, *) * arr.map({ abs($0)\
    \ }).reduce(0, +)", "    var pr = 0\n    var su = 0\n    for i in arr {\n    \
    \    su += abs(i)\n        if i > 0 {\n            pr += 1\n        } else if\
    \ i < 0 {\n            pr -= 1\n        }\n    }\n    if arr.count == 0 {\n  \
    \      return nil\n    }\n    return su * pr", "    if arr.isEmpty {\n       \
    \ return nil\n    }\n    return arr.map { ($0 >= 0 ? 1 : -1) * abs($0) }.reduce(1,\
    \ *)", "    if arr.isEmpty {\n        return nil\n    }\n    var sum = 0\n   \
    \ var product = 1\n    for number in arr {\n        sum += abs(number)\n     \
    \   product *= number < 0 ? -1 : number == 0 ? 0 : 1\n    }\n    return sum *\
    \ product", "    guard arr.count > 0 else {\n        return nil\n    }\n    let\
    \ prods = arr.map { (i: Int) -> Int in\n        return i > 0 ? 1 : i < 0 ? -1\
    \ : 0\n    }\n    let signs = prods.reduce(1, *)\n    let mags = arr.map { (i:\
    \ Int) -> Int in\n        return abs(i)\n    }\n    let total = mags.reduce(0,\
    \ +)\n    return total * signs", "    if arr.isEmpty {\n        return nil\n \
    \   }\n    return arr.reduce(1) { a, b in\n        a * b * sign(b)\n    }", " \
    \   if arr.isEmpty {\n        return nil\n    }\n    var sum = 0\n    var sign\
    \ = 1\n    for num in arr {\n        sum += abs(num)\n        if num != 0 {\n\
    \            sign *= num > 0 ? 1 : -1\n        }\n    }\n    return sum * sign",
  "    guard arr.count > 0 else { return nil }\n    let signs = arr.compactMap { $0\
    \ > 0 ? 1 : $0 < 0 ? -1 : 0 }\n    return signs.reduce(1, *) * arr.reduce(0, {\
    \ $0 + abs($1) })", "    guard arr.count > 0 else { return nil }\n    let a =\
    \ arr.map { $0 < 0 ? -1 : $0 > 0 ? 1 : 0 }\n    let b = arr.map { abs($0) }\n\
    \    let p = a.reduce(1, *)\n    let s = b.reduce(0, +)\n    return p * s", "\t\
    guard arr.count > 0 else {\n\t\treturn nil\n\t}\n\tvar prod = 1\n\tfor num in\
    \ arr {\n\t\tif num == 0 {\n\t\t\tcontinue\n\t\t}\n\t\tprod *= num > 0 ? 1 : -1\n\
    \t}\n\treturn arr.map { abs($0) }.reduce(0, +) * prod", "    let isEmpty = arr.isEmpty\n\
    \    guard !isEmpty else { return nil }\n    let signs = arr.map { (number) ->\
    \ Int in\n        if number > 0 {\n            return 1\n        } else if number\
    \ < 0 {\n            return -1\n        } else {\n            return 0\n     \
    \   }\n    }\n    let product = signs.reduce(1, *)\n    let absoluteNumbers =\
    \ arr.map { abs($0) }\n    let sum = absoluteNumbers.reduce(0, +)\n    return\
    \ sum * product", "    var result: Int? = nil\n    if !arr.isEmpty {\n       \
    \ result = 0\n        var product = 1\n        for num in arr {\n            if\
    \ num > 0 {\n                result! += num\n            } else if num < 0 {\n\
    \                result! += -num\n                product *= -1\n            }\n\
    \        }\n        result! *= product\n    }\n    return result", '  return nil',
  "    let product = arr.reduce(1) { result, next in\n        result * (next == 0\
    \ ? 1 : next > 0 ? 1 : -1)\n    }\n    let sum = arr.reduce(0) { result, next\
    \ in\n        result + abs(next)\n    }\n    return sum * product", "  guard !arr.isEmpty\
    \ else { return nil }\n  var sign = 1\n  var sum = 0\n  for num in arr {\n   \
    \ if num < 0 {\n      sign *= -1\n    }\n    sum += abs(num)\n  }\n  return sum\
    \ * sign", '    return nil', "    guard arr.count > 0 else { return nil }\n  \
    \  return arr.reduce(1) { $0 * ($1 > 0 ? 1 : $1 < 0 ? -1 : 0) } * arr.reduce(0)\
    \ { $0 + abs($1) }", "    var sum = 0\n    var prod = 1\n    for num in arr {\n\
    \        sum += abs(num)\n        prod *= sign(num)\n    }\n    return sum * prod",
  "    var result: Int = 0\n    var count: Int = 0\n    for num in arr {\n       \
    \ if num > 0 {\n            result += num\n            count += 1\n        } else\
    \ if num < 0 {\n            result += num\n            count -= 1\n        }\n\
    \    }\n    if arr.count == 0 {\n        return nil\n    }\n    return result\
    \ * count", "    guard arr.count > 0 else {\n        return nil\n    }\n    return\
    \ arr.reduce(1) { (acc, n) in\n        acc * (n < 0 ? -1 : n > 0 ? 1 : 0) * abs(n)\n\
    \    }", '    return arr.isEmpty ? nil : arr.map { $0 > 0 ? 1 : $0 < 0 ? -1 :
    0 }.reduce(1, *) * arr.map { abs($0) }.reduce(0, +)', "    if arr.isEmpty {\n\
    \        return nil\n    }\n    let signs = arr.map { $0 == 0 ? 0 : $0 > 0 ? 1\
    \ : -1 }\n    let sum = arr.map { abs($0) }.reduce(0, +)\n    let sign = signs.reduce(1,\
    \ *)\n    return sum * sign", "    guard arr.count > 0 else { return nil }\n \
    \   var output = 0\n    for i in arr {\n        output += i > 0 ? 1 : i < 0 ?\
    \ -1 : 0\n    }\n    for i in arr {\n        output *= i > 0 ? 1 : i < 0 ? -1\
    \ : 0\n    }\n    return output", '    return arr.count > 0 ? arr.map{ $0 >= 0
    ? 1 : -1 }.reduce(1, *) * arr.map{ abs($0) }.reduce(0, +) : nil', "    guard arr.count\
    \ > 0 else {\n        return nil\n    }\n    var product = 1\n    var sum = 0\n\
    \    for num in arr {\n        product *= num > 0 ? 1 : num < 0 ? -1 : 0\n   \
    \     sum += abs(num)\n    }\n    return product * sum", "    if arr.isEmpty {\n\
    \        return nil\n    }\n    var magnitudeSum = 0\n    var signProduct = 1\n\
    \    for num in arr {\n        magnitudeSum += abs(num)\n        signProduct *=\
    \ num != 0 ? num / abs(num) : 1\n    }\n    return magnitudeSum * signProduct",
  "    guard arr.count > 0 else { return nil }\n    let productOfSings = arr.map {\
    \ $0 == 0 ? 0 : ($0 > 0 ? 1 : -1) }.reduce(1, *)\n    let sumOfMagnitudes = arr.map\
    \ { abs($0) }.reduce(0, +)\n    return sumOfMagnitudes * productOfSings", "  \
    \  guard arr.count > 0 else { return nil }\n    return arr.map { abs($0) }.reduce(1,\
    \ *) * arr.map { $0 > 0 ? 1 : ($0 < 0 ? -1 : 0) }.reduce(1, *)", "    var mags:\
    \ [Int] = []\n    var signs: [Int] = []\n    for x in arr {\n        mags.append(abs(x))\n\
    \        signs.append(x == 0 ? 0 : x / abs(x))\n    }\n    return mags.isEmpty\
    \ ? nil : mags.reduce(1, *) * signs.reduce(1, *)", "    let filter_zero = arr.filter\
    \ { $0 != 0 }\n    let filter_one = filter_zero.filter { $0 != 1 }\n    var sum_magnitude\
    \ = filter_zero.filter { $0 == 1 }.count + filter_one.map { abs($0) }.reduce(0,\
    \ +)\n    if filter_zero.count != arr.count {\n        sum_magnitude += (arr.contains(0)\
    \ ? 0 : 1)\n    }\n    return sum_magnitude", "    if arr.isEmpty {\n        return\
    \ nil\n    }\n    let signs = arr.map { $0 > 0 ? 1 : $0 < 0 ? -1 : 0 }\n    let\
    \ product = signs.reduce(1, *)\n    let magnitudes = arr.map { abs($0) }\n   \
    \ let sum = magnitudes.reduce(0, +)\n    return product * sum", "    var result:\
    \ Int = 0\n    var neg: Int = 1\n    var pos: Int = 1\n    var zer: Int = 1\n\
    \    if arr.count == 0 {\n        return nil\n    }\n    for i in arr {\n    \
    \    if i < 0 {\n            neg *= -1\n            result += abs(i)\n       \
    \ } else if i > 0 {\n            pos *= 1\n            result += abs(i)\n    \
    \    } else {\n            zer *= 0\n        }\n    }\n    return result * (neg\
    \ * pos * zer)", "    guard arr.count > 0 else {\n        return nil\n    }\n\
    \    var prod_1_or_neg_1 = 1 // -1\n    var magnitudes_sum = 0\n    for el in\
    \ arr {\n        switch el {\n        case let x where x > 0:\n            prod_1_or_neg_1\
    \ *= 1\n            magnitudes_sum += x\n        case let x where x < 0:\n   \
    \         prod_1_or_neg_1 *= -1\n            magnitudes_sum += -x\n        default:\n\
    \            continue\n        }\n    }\n    return prod_1_or_neg_1 * magnitudes_sum",
  '    return nil', "    guard arr.count > 0 else { return nil }\n    return arr.map{\
    \ $0 > 0 ? 1 : $0 < 0 ? -1 : 0 }.reduce(1, *) * arr.map{ abs($0) }.reduce(0, +)",
  "    if arr.isEmpty {\n        return nil\n    }\n    var sumOfMagnitudes = 0\n\
    \    var productOfSigns = 1\n    for num in arr {\n        sumOfMagnitudes +=\
    \ abs(num)\n        productOfSigns *= num < 0 ? -1 : (num > 0 ? 1 : 0)\n    }\n\
    \    return sumOfMagnitudes * productOfSigns", "\tguard arr.count > 0 else {\n\
    \t\treturn nil\n\t}\n\tvar mult = 1\n\tvar sum = 0\n\tfor i in arr {\n\t\tif i\
    \ != 0 {\n\t\t\tif i < 0 {\n\t\t\t\tmult *= -1\n\t\t\t}\n\t\t\tsum += abs(i)\n\
    \t\t}\n\t}\n\treturn sum * mult", "  var sum = 0\n  var prod = 1\n  for el in\
    \ arr {\n    if el != 0 {\n      sum += abs(el)\n      prod *= sign(el)\n    }\n\
    \  }\n  if prod == 0 {\n    return nil\n  }\n  return sum * prod", "    if arr.isEmpty\
    \ {\n        return nil\n    }\n    return arr.map{ $0 >= 0 ? 1 : -1 }.reduce(1,\
    \ *) * arr.map{ abs($0) }.reduce(0, +)", '    return nil', "\tguard arr.count\
    \ > 0 else { return nil }\n\tlet prods = arr.map { ($0 > 0 ? 1 : $0 < 0 ? -1 :\
    \ 0) }\n\tlet sum = arr.map { abs($0) }.reduce(0, +)\n\treturn prods.reduce(1,\
    \ *) * sum", "    var result: Int = 0\n    var sign: Int = 1\n    for i in arr\
    \ {\n        if i > 0 {\n            result += i\n        } else if i < 0 {\n\
    \            result += -i\n            sign *= -1\n        }\n    }\n    return\
    \ result * sign", "    if arr.isEmpty {\n        return nil\n    }\n    let res\
    \ = arr.map { abs($0) }.reduce(1, *) * arr.map { $0 < 0 ? -1 : ($0 > 0 ? 1 : 0)\
    \ }.reduce(1, *)\n    return res", "    guard arr.count > 0 else {\n        return\
    \ nil\n    }\n    var signs = 1\n    var sum = 0\n    for num in arr {\n     \
    \   switch num {\n        case _ where num < 0:\n            signs *= -1\n   \
    \         sum += abs(num)\n        case _ where num > 0:\n            sum += num\n\
    \        default:\n            break\n        }\n    }\n    return sum * signs",
  "  guard arr.count > 0 else { return nil }\n  var productOfSigns = 1\n  var sumOfMagnitudes\
    \ = 0\n  for elem in arr {\n    let magnitude = abs(elem)\n    sumOfMagnitudes\
    \ += magnitude\n    let sign = (elem > 0) ? 1 : ((elem < 0) ? -1 : 0)\n    productOfSigns\
    \ *= sign\n  }\n  return sumOfMagnitudes * productOfSigns", "    if arr.isEmpty\
    \ {\n        return nil\n    }\n    var product = 1\n    var sum = 0\n    for\
    \ a in arr {\n        if a > 0 {\n            product *= 1\n        } else if\
    \ a < 0 {\n            product *= -1\n        } else {\n            product *=\
    \ 0\n        }\n        sum += abs(a)\n    }\n    return sum * product", "   \
    \ guard arr.count > 0 else {\n        return nil\n    }\n    var signsProd = 1\n\
    \    var magnitudesSum = 0\n    for num in arr {\n        let sign = num < 0 ?\
    \ -1 : num > 0 ? 1 : 0\n        signsProd *= sign\n        magnitudesSum += abs(num)\n\
    \    }\n    return signsProd * magnitudesSum", "    if arr.isEmpty {\n       \
    \ return nil\n    }\n    return arr.map { abs($0) }.reduce(1, *) * arr.map { $0\
    \ > 0 ? 1 : ($0 < 0 ? -1 : 0) }.reduce(1, *)", "  let size = arr.count\n  var\
    \ product = 1\n  var sum = 0\n  if size == 0 {\n    return nil\n  }\n  for i in\
    \ 0..<size {\n    if arr[i] < 0 {\n      product *= -1\n    } else if arr[i] >\
    \ 0 {\n      product *= 1\n    } else {\n      product *= 0\n    }\n    sum +=\
    \ abs(arr[i])\n  }\n  return sum * product", "    guard arr.count > 0 else { return\
    \ nil }\n    var prod = 1\n    var sum = 0\n    for el in arr {\n        if el\
    \ > 0 {\n            prod *= 1\n        } else if el < 0 {\n            prod *=\
    \ -1\n        } else {\n            prod *= 0\n        }\n        sum += abs(el)\n\
    \    }\n    return sum * prod", "    let arrMagnitude = arr.map{ abs($0) }\n \
    \   let arrSign = arr.map{ $0 > 0 ? 1 : ($0 < 0 ? -1 : 0) }\n    guard !arrMagnitude.isEmpty\
    \ else { return nil }\n    return arrMagnitude.reduce(1, *) * arrSign.reduce(1,\
    \ *)", "    var prod = 1\n    var sum = 0\n    if arr.count == 0 {\n        return\
    \ nil\n    }\n    for num in arr {\n        if num > 0 {\n            prod *=\
    \ 1\n        } else if num < 0 {\n            prod *= -1\n        } else {\n \
    \           prod *= 0\n        }\n        sum += abs(num)\n    }\n    return sum\
    \ * prod", "    guard arr.count > 0 else { return nil }\n    var signs = [Int]()\n\
    \    for num in arr {\n        if num == 0 {\n            signs.append(0)\n  \
    \      } else if num > 0 {\n            signs.append(1)\n        } else {\n  \
    \          signs.append(-1)\n        }\n    }\n    var sum = 0\n    var prod =\
    \ 1\n    for sign in signs {\n        sum += sign\n        prod *= sign\n    }\n\
    \    if sum > 0 {\n        return sum * prod\n    } else {\n        return 0\n\
    \    }", "  if arr.isEmpty {\n    return nil\n  }\n  let sign_prod = arr.reduce(1)\
    \ { $0 * $1.signum() }\n  let sum = arr.reduce(0) { $0 + abs($1) }\n  return sum\
    \ * sign_prod", "    guard arr.count > 0 else { return nil }\n    var sum = 0\n\
    \    var sign = 1\n    for num in arr {\n        if num < 0 {\n            sign\
    \ *= -1\n        }\n        sum += abs(num)\n    }\n    return sum * sign", " \
    \   guard arr.count > 0 else {\n        return nil\n    }\n    let sign_prod =\
    \ arr.reduce(1) { (result, element) -> Int in\n        if element > 0 {\n    \
    \        return result * 1\n        } else if element < 0 {\n            return\
    \ result * -1\n        } else {\n            return result * 0\n        }\n  \
    \  }\n    let mag_sum = arr.reduce(0) { (result, element) -> Int in\n        return\
    \ result + abs(element)\n    }\n    return mag_sum * sign_prod", "    guard arr.count\
    \ > 0 else { return nil }\n    var signProduct = 1\n    var sum = 0\n    for i\
    \ in arr {\n        if i > 0 {\n            signProduct *= 1\n        } else if\
    \ i < 0 {\n            signProduct *= -1\n        } else {\n            signProduct\
    \ *= 0\n        }\n        sum += abs(i)\n    }\n    return sum * signProduct",
  "    if arr.isEmpty {\n        return nil\n    }\n    let sum = arr.reduce(0) {\
    \ $0 + $1.magnitude }\n    var prod = 1\n    for num in arr {\n        if num\
    \ < 0 {\n            prod *= -1\n        } else if num > 0 {\n            prod\
    \ *= 1\n        } else {\n            return 0\n        }\n    }\n    return sum\
    \ * prod", "    guard arr.count > 0 else { return nil }\n    return arr.map {\
    \ $0 < 0 ? -1 : $0 > 0 ? 1 : 0 }.reduce(1, *) * arr.map { abs($0) }.reduce(0,\
    \ +)", "  guard arr.count > 0 else { return nil }\n  let count = arr.count\n \
    \ var total = 1\n  var sum = 0\n  for i in 0..<count {\n    if arr[i] > 0 {\n\
    \      total *= 1\n    } else if arr[i] < 0 {\n      total *= -1\n    } else {\n\
    \      total *= 0\n    }\n    sum += abs(arr[i])\n  }\n  return total * sum",
  "    if arr.isEmpty {\n        return nil\n    }\n    var prod = 1\n    var sum\
    \ = 0\n    for i in arr {\n        prod *= i > 0 ? 1 : i < 0 ? -1 : 0\n      \
    \  sum += abs(i)\n    }\n    return prod * sum", "    if arr.isEmpty {\n     \
    \   return nil\n    }\n    var prod = 1\n    var sum = 0\n    for e in arr {\n\
    \        if e < 0 {\n            prod *= -1\n        } else if e > 0 {\n     \
    \       prod *= 1\n        } else {\n            prod *= 0\n        }\n      \
    \  sum += abs(e)\n    }\n    return sum * prod", "    guard arr.count > 0 else\
    \ { return nil }\n    let sign: Int = {\n        var sign: Int = 1\n        for\
    \ x in arr {\n            if x < 0 {\n                sign *= -1\n           \
    \ }\n        }\n        return sign\n    }()\n    return arr.map({ abs($0) }).reduce(1,\
    \ { $0 * $1 }) * sign", "    let signs = arr.map { $0 == 0 ? 0 : $0 > 0 ? 1 :\
    \ -1 }\n    let prods = signs.reduce(1, *)\n    let sums = arr.map{ abs($0) }.reduce(0,\
    \ +)\n    return prods * sums", "    if arr.isEmpty {\n        return nil\n  \
    \  }\n    let result = arr.reduce(1) {$0 * $1}\n    return arr.reduce(0) {$0 +\
    \ abs($1) * result}", "    if arr.isEmpty {\n        return nil\n    }\n    let\
    \ sum = arr.reduce(0) { $0 + abs($1) }\n    let sign = arr.reduce(1) { x, y in\
    \ x * (y > 0 ? 1 : y < 0 ? -1 : 0) }\n    return sum * sign", "    if arr.isEmpty\
    \ {\n        return nil\n    }\n    var product: Int = 1\n    var sum: Int = 0\n\
    \    for num in arr {\n        product *= (num > 0 ? 1 : (num < 0 ? -1 : 0))\n\
    \        sum += abs(num)\n    }\n    return product * sum", "    guard arr.count\
    \ > 0 else { return nil }\n    return arr.reduce(0) {\n        let sign = $1 >\
    \ 0 ? 1 : $1 < 0 ? -1 : 0\n        return sign != 0 ? $0 + abs($1) * sign : $0\n\
    \    }", "    guard arr.count > 0 else { return nil }\n    return arr.map { $0\
    \ < 0 ? -1 : $0 > 0 ? 1 : 0 }.reduce(1, *) * arr.map { abs($0) }.reduce(0, +)",
  "    return arr.reduce((product: 1, sum: 0)) {\n        (partial, element) in\n\
    \        let sign = element == 0 ? 0 : element < 0 ? -1 : 1\n        return (partial.product\
    \ * sign, partial.sum + abs(element))\n    }.sum", "    guard arr.count > 0 else\
    \ { return nil }\n    var p = 1\n    var s = 0\n    for n in arr {\n        p\
    \ *= (n == 0 ? 1 : n < 0 ? -1 : 1)\n        s += (n == 0 ? 0 : abs(n))\n    }\n\
    \    return p * s", "    guard arr.count > 0 else {\n        return nil\n    }\n\
    \    let sign = arr.map({abs($0) > 0 ? $0 < 0 ? -1 : 1 : 0})\n    let sum = arr.map({abs($0)}).reduce(0,\
    \ +)\n    return sign.reduce(1, *) * sum", "    let signProd = arr.reduce(1) {\
    \ $0 * ($1 > 0 ? 1 : $1 < 0 ? -1 : 0) }\n    return arr.reduce(0) { $0 + abs($1)\
    \ } * signProd", "    if arr.isEmpty {\n        return nil\n    }\n    var result\
    \ = 1\n    var sum = 0\n    for num in arr {\n        if num == 0 {\n        \
    \    continue\n        }\n        result *= num > 0 ? 1 : -1\n        sum += abs(num)\n\
    \    }\n    return result * sum", "    guard arr.count > 0 else { return nil }\n\
    \    var sum = 0\n    var product = 1\n    for num in arr {\n        sum += abs(num)\n\
    \        product *= num == 0 ? 1 : num / abs(num)\n    }\n    return sum * product",
  "    guard arr.count > 0 else { return nil }\n    var prod = 1\n    var sum = 0\n\
    \    for n in arr {\n        if n == 0 { continue }\n        prod *= n.signum()\n\
    \        sum += n.magnitude\n    }\n    return prod * sum", "    guard arr.count\
    \ > 0 else {\n        return nil\n    }\n    let signs = arr.map {\n        if\
    \ $0 == 0 {\n            return 0\n        } else if $0 > 0 {\n            return\
    \ 1\n        } else {\n            return -1\n        }\n    }\n    let signProd\
    \ = signs.reduce(1, *)\n    let magnitudes = arr.map { abs($0) }\n    let magnitudeSum\
    \ = magnitudes.reduce(0, +)\n    return signProd * magnitudeSum", "  if arr.isEmpty\
    \ {\n    return nil\n  }\n  var prod = 1\n  var sum = 0\n  for n in arr {\n  \
    \  prod *= (n < 0 ? -1 : n == 0 ? 0 : 1)\n    sum += abs(n)\n  }\n  return prod\
    \ * sum", "    guard arr.count > 0 else {\n        return nil\n    }\n    let\
    \ signs = arr.map { $0 > 0 ? 1 : ($0 < 0 ? -1 : 0) }\n    let signs_prod = signs.reduce(1,\
    \ *)\n    let abs = arr.map { $0 * $0 }\n    let sum = abs.reduce(0, +)\n    return\
    \ sum * signs_prod", "    guard arr.count > 0 else { return nil }\n    let mult\
    \ = arr.map { sign_of(num: $0) }.reduce(1, *)\n    let sum = arr.map { abs($0)\
    \ }.reduce(0, +)\n    return mult * sum", "    if arr.isEmpty {\n        return\
    \ nil\n    } else {\n        let prod = arr.map { abs($0) }.reduce(1, *)\n   \
    \     let sum = arr.reduce(0) { $0 + ($1 > 0 ? 1 : $1 < 0 ? -1 : 0) }\n      \
    \  return prod * sum\n    }", "    guard arr.count > 0 else { return nil }\n \
    \   var sum = 0\n    for num in arr {\n        sum += abs(num) * arr.compactMap\
    \ { $0 == 0 ? 0 : $0 / abs($0) }.reduce(1, *)\n    }\n    return sum", "    if\
    \ arr.isEmpty {\n        return nil\n    }\n    let prod = arr.reduce(1) { $0\
    \ * sign(n: $1) }\n    return arr.reduce(0) { $0 + abs($1) } * prod", "    guard\
    \ arr.count > 0 else { return nil }\n    let signs = arr.map({ $0 == 0 ? 0 : $0\
    \ > 0 ? 1 : -1 })\n    let mult = signs.reduce(1, *)\n    let res = arr.map({\
    \ $0 < 0 ? $0 * -1 : $0 }).reduce(0, +)\n    return res * mult", "    if arr.isEmpty\
    \ {\n        return nil\n    }\n    var total = 0\n    var product = 1\n    for\
    \ i in arr {\n        if i > 0 {\n            total += i\n            product\
    \ *= 1\n        } else if i < 0 {\n            total += abs(i)\n            product\
    \ *= -1\n        } else {\n            product *= 0\n        }\n    }\n    return\
    \ total * product", "    if arr.isEmpty {\n        return nil\n    }\n    let\
    \ signs: [Int] = arr.map({ Int(pow(Double($0.signum()), 2.0)) })\n    let magnitudes:\
    \ [Int] = arr.map({ abs($0) })\n    return magnitudes.reduce(1, *) * signs.reduce(1,\
    \ *)", "    if arr.isEmpty {\n        return nil\n    }\n    let signs = arr.map\
    \ { (number) -> Int in\n        if number == 0 {\n            return 0\n     \
    \   } else if number > 0 {\n            return 1\n        } else {\n         \
    \   return -1\n        }\n    }\n    let product = signs.reduce(1, *)\n    let\
    \ magnitudes = arr.map { (number) -> Int in\n        return number.magnitude\n\
    \    }\n    let sum = magnitudes.reduce(0, +)\n    return sum * product", "  \
    \  if arr.isEmpty {\n        return nil\n    }\n    let signs = arr.map { $0 >=\
    \ 0 ? 1 : -1 }\n    let prod = signs.reduce(1, *)\n    let sum = arr.reduce(0)\
    \ { $0 + abs($1) }\n    return prod * sum", "    var product = 0\n    var sum\
    \ = 0\n    for value in arr {\n        sum += abs(value)\n        product += value.signum()\n\
    \    }\n    if arr.isEmpty {\n        return nil\n    }\n    return sum * product",
  "    guard arr.count > 0 else {\n        return nil\n    }\n    var signProd = 1\n\
    \    var sumMagnitudes = 0\n    for num in arr {\n        let sign = sgn(num)\n\
    \        signProd *= sign\n        sumMagnitudes += abs(num)\n    }\n    return\
    \ signProd * sumMagnitudes"]
stop_tokens:
- "\n}"
