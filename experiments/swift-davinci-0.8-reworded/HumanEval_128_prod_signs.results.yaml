language: swift
name: HumanEval_128_prod_signs
results:
- exit_code: 1
  program: "\n/// You are given an array arr of integers and you need to return\n\
    /// sum of magnitudes of integers multiplied by product of all signs\n/// of each\
    \ number in the array, represented by 1, -1 or 0.\n/// Note: return nil for empty\
    \ arr.\n/// Example:\n/// >>> prod_signs(arr: [1, 2, 2, -4])\n/// 9\n/// >>> prod_signs(arr:\
    \ [0, 1])\n/// 0\n/// >>> prod_signs(arr: [] as [Int])\n/// nil\nfunc prod_signs(arr:\
    \ [Int]) -> Int? {\n    guard arr.count > 0 else { return nil }\n    let sign_product\
    \ = arr.reduce(1) { $0 * sign_of($1) }\n    let abs_sum = arr.reduce(0) { $0 +\
    \ abs($1) }\n    return sign_product * abs_sum\n}\n\n\nfunc ==(left: [(Int, Int)],\
    \ right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n       \
    \ return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r\
    \ {\n            return false\n        }\n    }\n    return true\n}\n        \
    \    \nassert(prod_signs(arr: [1, 2, 2, -4]) == -9)\nassert(prod_signs(arr: [0,\
    \ 1]) == 0)\nassert(prod_signs(arr: [1, 1, 1, 2, 3, -1, 1]) == -10)\nassert(prod_signs(arr:\
    \ [] as [Int]) == nil)\nassert(prod_signs(arr: [2, 4, 1, 2, -1, -1, 9]) == 20)\n\
    assert(prod_signs(arr: [-1, 1, -1, 1]) == 4)\nassert(prod_signs(arr: [-1, 1, 1,\
    \ 1]) == -4)\nassert(prod_signs(arr: [-1, 1, 1, 0]) == 0)"
  status: SyntaxError
  stderr: "/tmp/tmpg8m7z3fd.swift:15:45: error: cannot find 'sign_of' in scope\n \
    \   let sign_product = arr.reduce(1) { $0 * sign_of($1) }\n                  \
    \                          ^~~~~~~\n"
  stdout: ''
  timestamp: 1659979791
- exit_code: 0
  program: "\n/// You are given an array arr of integers and you need to return\n\
    /// sum of magnitudes of integers multiplied by product of all signs\n/// of each\
    \ number in the array, represented by 1, -1 or 0.\n/// Note: return nil for empty\
    \ arr.\n/// Example:\n/// >>> prod_signs(arr: [1, 2, 2, -4])\n/// 9\n/// >>> prod_signs(arr:\
    \ [0, 1])\n/// 0\n/// >>> prod_signs(arr: [] as [Int])\n/// nil\nfunc prod_signs(arr:\
    \ [Int]) -> Int? {\n    if arr.isEmpty {\n        return nil\n    }\n    var prod\
    \ = 1\n    var magn = 0\n    for num in arr {\n        prod *= num > 0 ? 1 : num\
    \ < 0 ? -1 : 0\n        magn += abs(num)\n    }\n    return prod * magn\n}\n\n\
    \nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(prod_signs(arr: [1, 2, 2, -4]) == -9)\nassert(prod_signs(arr:\
    \ [0, 1]) == 0)\nassert(prod_signs(arr: [1, 1, 1, 2, 3, -1, 1]) == -10)\nassert(prod_signs(arr:\
    \ [] as [Int]) == nil)\nassert(prod_signs(arr: [2, 4, 1, 2, -1, -1, 9]) == 20)\n\
    assert(prod_signs(arr: [-1, 1, -1, 1]) == 4)\nassert(prod_signs(arr: [-1, 1, 1,\
    \ 1]) == -4)\nassert(prod_signs(arr: [-1, 1, 1, 0]) == 0)"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659979791
- exit_code: 0
  program: "\n/// You are given an array arr of integers and you need to return\n\
    /// sum of magnitudes of integers multiplied by product of all signs\n/// of each\
    \ number in the array, represented by 1, -1 or 0.\n/// Note: return nil for empty\
    \ arr.\n/// Example:\n/// >>> prod_signs(arr: [1, 2, 2, -4])\n/// 9\n/// >>> prod_signs(arr:\
    \ [0, 1])\n/// 0\n/// >>> prod_signs(arr: [] as [Int])\n/// nil\nfunc prod_signs(arr:\
    \ [Int]) -> Int? {\n    guard arr.count > 0 else { return nil }\n    var sum =\
    \ 0\n    var prod = 1\n    for x in arr {\n        if x > 0 {\n            sum\
    \ += x\n            prod *= 1\n        } else if x < 0 {\n            sum += -x\n\
    \            prod *= -1\n        } else {\n            prod *= 0\n        }\n\
    \    }\n    return sum * prod\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int,\
    \ Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n\
    \    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n          \
    \  return false\n        }\n    }\n    return true\n}\n            \nassert(prod_signs(arr:\
    \ [1, 2, 2, -4]) == -9)\nassert(prod_signs(arr: [0, 1]) == 0)\nassert(prod_signs(arr:\
    \ [1, 1, 1, 2, 3, -1, 1]) == -10)\nassert(prod_signs(arr: [] as [Int]) == nil)\n\
    assert(prod_signs(arr: [2, 4, 1, 2, -1, -1, 9]) == 20)\nassert(prod_signs(arr:\
    \ [-1, 1, -1, 1]) == 4)\nassert(prod_signs(arr: [-1, 1, 1, 1]) == -4)\nassert(prod_signs(arr:\
    \ [-1, 1, 1, 0]) == 0)"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659979791
- exit_code: -4
  program: "\n/// You are given an array arr of integers and you need to return\n\
    /// sum of magnitudes of integers multiplied by product of all signs\n/// of each\
    \ number in the array, represented by 1, -1 or 0.\n/// Note: return nil for empty\
    \ arr.\n/// Example:\n/// >>> prod_signs(arr: [1, 2, 2, -4])\n/// 9\n/// >>> prod_signs(arr:\
    \ [0, 1])\n/// 0\n/// >>> prod_signs(arr: [] as [Int])\n/// nil\nfunc prod_signs(arr:\
    \ [Int]) -> Int? {\n    guard arr.count > 0 else {\n        return nil\n    }\n\
    \    var signs = 1\n    var mag = 0\n    for el in arr {\n        if el != 0 {\n\
    \            signs *= el / abs(el)\n            mag += abs(el)\n        }\n  \
    \  }\n    return signs * mag\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int,\
    \ Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n\
    \    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n          \
    \  return false\n        }\n    }\n    return true\n}\n            \nassert(prod_signs(arr:\
    \ [1, 2, 2, -4]) == -9)\nassert(prod_signs(arr: [0, 1]) == 0)\nassert(prod_signs(arr:\
    \ [1, 1, 1, 2, 3, -1, 1]) == -10)\nassert(prod_signs(arr: [] as [Int]) == nil)\n\
    assert(prod_signs(arr: [2, 4, 1, 2, -1, -1, 9]) == 20)\nassert(prod_signs(arr:\
    \ [-1, 1, -1, 1]) == 4)\nassert(prod_signs(arr: [-1, 1, 1, 1]) == -4)\nassert(prod_signs(arr:\
    \ [-1, 1, 1, 0]) == 0)"
  status: Exception
  stderr: 'tmp2p59xvi2/tmp2p59xvi2.swift:42: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b7efcaabc80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b7efc7a2b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b7efc7a2988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b7efc7a17b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmp2p59xvi2                        0x000055692e90f8a5 <unavailable> + 6309

    5    libc.so.6                          0x00002b7efcc97460 __libc_start_main +
    245

    6    tmp2p59xvi2                        0x000055692e90f2a9 <unavailable> + 4777

    '
  stdout: ''
  timestamp: 1659979791
- exit_code: 0
  program: "\n/// You are given an array arr of integers and you need to return\n\
    /// sum of magnitudes of integers multiplied by product of all signs\n/// of each\
    \ number in the array, represented by 1, -1 or 0.\n/// Note: return nil for empty\
    \ arr.\n/// Example:\n/// >>> prod_signs(arr: [1, 2, 2, -4])\n/// 9\n/// >>> prod_signs(arr:\
    \ [0, 1])\n/// 0\n/// >>> prod_signs(arr: [] as [Int])\n/// nil\nfunc prod_signs(arr:\
    \ [Int]) -> Int? {\n    if arr.isEmpty {\n        return nil\n    }\n    let signs:\
    \ [Int] = arr.map { (num) -> Int in\n        switch num {\n        case _ where\
    \ num > 0:\n            return 1\n        case _ where num < 0:\n            return\
    \ -1\n        default:\n            return 0\n        }\n    }\n    let mags:\
    \ [Int] = arr.map { abs($0) }\n    let signs_prod = signs.reduce(1, *)\n    let\
    \ mags_sum = mags.reduce(0, +)\n    return signs_prod * mags_sum\n}\n\n\nfunc\
    \ ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count !=\
    \ right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(prod_signs(arr: [1, 2, 2, -4]) == -9)\nassert(prod_signs(arr:\
    \ [0, 1]) == 0)\nassert(prod_signs(arr: [1, 1, 1, 2, 3, -1, 1]) == -10)\nassert(prod_signs(arr:\
    \ [] as [Int]) == nil)\nassert(prod_signs(arr: [2, 4, 1, 2, -1, -1, 9]) == 20)\n\
    assert(prod_signs(arr: [-1, 1, -1, 1]) == 4)\nassert(prod_signs(arr: [-1, 1, 1,\
    \ 1]) == -4)\nassert(prod_signs(arr: [-1, 1, 1, 0]) == 0)"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659979791
- exit_code: 0
  program: "\n/// You are given an array arr of integers and you need to return\n\
    /// sum of magnitudes of integers multiplied by product of all signs\n/// of each\
    \ number in the array, represented by 1, -1 or 0.\n/// Note: return nil for empty\
    \ arr.\n/// Example:\n/// >>> prod_signs(arr: [1, 2, 2, -4])\n/// 9\n/// >>> prod_signs(arr:\
    \ [0, 1])\n/// 0\n/// >>> prod_signs(arr: [] as [Int])\n/// nil\nfunc prod_signs(arr:\
    \ [Int]) -> Int? {\n    guard arr.count > 0 else { return nil }\n    let mags\
    \ = arr.map { abs($0) }\n    let prods = arr.map { $0 < 0 ? -1 : ($0 > 0 ? 1 :\
    \ 0) }\n    let magnitude = mags.reduce(0, +)\n    let prod = prods.reduce(1,\
    \ *)\n    return magnitude * prod\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int,\
    \ Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n\
    \    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n          \
    \  return false\n        }\n    }\n    return true\n}\n            \nassert(prod_signs(arr:\
    \ [1, 2, 2, -4]) == -9)\nassert(prod_signs(arr: [0, 1]) == 0)\nassert(prod_signs(arr:\
    \ [1, 1, 1, 2, 3, -1, 1]) == -10)\nassert(prod_signs(arr: [] as [Int]) == nil)\n\
    assert(prod_signs(arr: [2, 4, 1, 2, -1, -1, 9]) == 20)\nassert(prod_signs(arr:\
    \ [-1, 1, -1, 1]) == 4)\nassert(prod_signs(arr: [-1, 1, 1, 1]) == -4)\nassert(prod_signs(arr:\
    \ [-1, 1, 1, 0]) == 0)"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659979791
- exit_code: 1
  program: "\n/// You are given an array arr of integers and you need to return\n\
    /// sum of magnitudes of integers multiplied by product of all signs\n/// of each\
    \ number in the array, represented by 1, -1 or 0.\n/// Note: return nil for empty\
    \ arr.\n/// Example:\n/// >>> prod_signs(arr: [1, 2, 2, -4])\n/// 9\n/// >>> prod_signs(arr:\
    \ [0, 1])\n/// 0\n/// >>> prod_signs(arr: [] as [Int])\n/// nil\nfunc prod_signs(arr:\
    \ [Int]) -> Int? {\n    if arr.isEmpty {\n        return nil\n    }\n    let sign\
    \ = arr.reduce(1) { $0 * $1.signum() }\n    let magnitude = arr.reduce(0) { $0\
    \ + $1.magnitude }\n    return sign * magnitude\n}\n\n\nfunc ==(left: [(Int, Int)],\
    \ right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n       \
    \ return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r\
    \ {\n            return false\n        }\n    }\n    return true\n}\n        \
    \    \nassert(prod_signs(arr: [1, 2, 2, -4]) == -9)\nassert(prod_signs(arr: [0,\
    \ 1]) == 0)\nassert(prod_signs(arr: [1, 1, 1, 2, 3, -1, 1]) == -10)\nassert(prod_signs(arr:\
    \ [] as [Int]) == nil)\nassert(prod_signs(arr: [2, 4, 1, 2, -1, -1, 9]) == 20)\n\
    assert(prod_signs(arr: [-1, 1, -1, 1]) == 4)\nassert(prod_signs(arr: [-1, 1, 1,\
    \ 1]) == -4)\nassert(prod_signs(arr: [-1, 1, 1, 0]) == 0)"
  status: SyntaxError
  stderr: "/tmp/tmplve4bg95.swift:19:19: error: cannot convert value of type 'UInt'\
    \ to expected argument type 'Int'\n    return sign * magnitude\n             \
    \     ^\n                  Int(     )\n"
  stdout: ''
  timestamp: 1659979791
- exit_code: -4
  program: "\n/// You are given an array arr of integers and you need to return\n\
    /// sum of magnitudes of integers multiplied by product of all signs\n/// of each\
    \ number in the array, represented by 1, -1 or 0.\n/// Note: return nil for empty\
    \ arr.\n/// Example:\n/// >>> prod_signs(arr: [1, 2, 2, -4])\n/// 9\n/// >>> prod_signs(arr:\
    \ [0, 1])\n/// 0\n/// >>> prod_signs(arr: [] as [Int])\n/// nil\nfunc prod_signs(arr:\
    \ [Int]) -> Int? {\n\tlet product = arr.reduce(1) { $0 * ($1 < 0 ? -1 : $1 ==\
    \ 0 ? 0 : 1) }\n\treturn product == 0 ? nil : arr.reduce(0) { $0 + $1 * product\
    \ }\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if\
    \ left.count != right.count {\n        return false\n    }\n    for (l, r) in\
    \ zip(left, right) {\n        if l != r {\n            return false\n        }\n\
    \    }\n    return true\n}\n            \nassert(prod_signs(arr: [1, 2, 2, -4])\
    \ == -9)\nassert(prod_signs(arr: [0, 1]) == 0)\nassert(prod_signs(arr: [1, 1,\
    \ 1, 2, 3, -1, 1]) == -10)\nassert(prod_signs(arr: [] as [Int]) == nil)\nassert(prod_signs(arr:\
    \ [2, 4, 1, 2, -1, -1, 9]) == 20)\nassert(prod_signs(arr: [-1, 1, -1, 1]) == 4)\n\
    assert(prod_signs(arr: [-1, 1, 1, 1]) == -4)\nassert(prod_signs(arr: [-1, 1, 1,\
    \ 0]) == 0)"
  status: Exception
  stderr: 'tmpleev_aw2/tmpleev_aw2.swift:31: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b2f53396c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b2f5308db6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b2f5308d988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b2f5308c7b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpleev_aw2                        0x0000564518bcc459 <unavailable> + 5209

    5    libc.so.6                          0x00002b2f53582460 __libc_start_main +
    245

    6    tmpleev_aw2                        0x0000564518bcbfe9 <unavailable> + 4073

    '
  stdout: ''
  timestamp: 1659979791
- exit_code: 0
  program: "\n/// You are given an array arr of integers and you need to return\n\
    /// sum of magnitudes of integers multiplied by product of all signs\n/// of each\
    \ number in the array, represented by 1, -1 or 0.\n/// Note: return nil for empty\
    \ arr.\n/// Example:\n/// >>> prod_signs(arr: [1, 2, 2, -4])\n/// 9\n/// >>> prod_signs(arr:\
    \ [0, 1])\n/// 0\n/// >>> prod_signs(arr: [] as [Int])\n/// nil\nfunc prod_signs(arr:\
    \ [Int]) -> Int? {\n  if arr.isEmpty {\n    return nil\n  }\n\n  let sign = arr.reduce(1)\
    \ { $0 * ($1 > 0 ? 1 : ($1 < 0 ? -1 : 0)) }\n  let sum = arr.reduce(0) { abs($0)\
    \ + abs($1) }\n  return sign * sum\n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(prod_signs(arr: [1, 2, 2, -4]) == -9)\nassert(prod_signs(arr: [0, 1]) ==\
    \ 0)\nassert(prod_signs(arr: [1, 1, 1, 2, 3, -1, 1]) == -10)\nassert(prod_signs(arr:\
    \ [] as [Int]) == nil)\nassert(prod_signs(arr: [2, 4, 1, 2, -1, -1, 9]) == 20)\n\
    assert(prod_signs(arr: [-1, 1, -1, 1]) == 4)\nassert(prod_signs(arr: [-1, 1, 1,\
    \ 1]) == -4)\nassert(prod_signs(arr: [-1, 1, 1, 0]) == 0)"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659979791
- exit_code: -4
  program: "\n/// You are given an array arr of integers and you need to return\n\
    /// sum of magnitudes of integers multiplied by product of all signs\n/// of each\
    \ number in the array, represented by 1, -1 or 0.\n/// Note: return nil for empty\
    \ arr.\n/// Example:\n/// >>> prod_signs(arr: [1, 2, 2, -4])\n/// 9\n/// >>> prod_signs(arr:\
    \ [0, 1])\n/// 0\n/// >>> prod_signs(arr: [] as [Int])\n/// nil\nfunc prod_signs(arr:\
    \ [Int]) -> Int? {\n    guard arr.count > 0 else {\n        return nil\n    }\n\
    \    let signs = arr.map { number in\n        if number == 0 {\n            return\
    \ 0\n        } else if number > 0 {\n            return 1\n        } else {\n\
    \            return -1\n        }\n    }\n    return arr.map { abs($0) }.reduce(1,\
    \ *) * signs.reduce(1, *)\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(prod_signs(arr:\
    \ [1, 2, 2, -4]) == -9)\nassert(prod_signs(arr: [0, 1]) == 0)\nassert(prod_signs(arr:\
    \ [1, 1, 1, 2, 3, -1, 1]) == -10)\nassert(prod_signs(arr: [] as [Int]) == nil)\n\
    assert(prod_signs(arr: [2, 4, 1, 2, -1, -1, 9]) == 20)\nassert(prod_signs(arr:\
    \ [-1, 1, -1, 1]) == 4)\nassert(prod_signs(arr: [-1, 1, 1, 1]) == -4)\nassert(prod_signs(arr:\
    \ [-1, 1, 1, 0]) == 0)"
  status: Exception
  stderr: 'tmphew9dtdp/tmphew9dtdp.swift:42: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b02ab40cc80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b02ab103b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b02ab103988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b02ab1027b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmphew9dtdp                        0x000055a1bc103649 <unavailable> + 5705

    5    libc.so.6                          0x00002b02ab5f8460 __libc_start_main +
    245

    6    tmphew9dtdp                        0x000055a1bc1031d9 <unavailable> + 4569

    '
  stdout: ''
  timestamp: 1659979791
- exit_code: -4
  program: "\n/// You are given an array arr of integers and you need to return\n\
    /// sum of magnitudes of integers multiplied by product of all signs\n/// of each\
    \ number in the array, represented by 1, -1 or 0.\n/// Note: return nil for empty\
    \ arr.\n/// Example:\n/// >>> prod_signs(arr: [1, 2, 2, -4])\n/// 9\n/// >>> prod_signs(arr:\
    \ [0, 1])\n/// 0\n/// >>> prod_signs(arr: [] as [Int])\n/// nil\nfunc prod_signs(arr:\
    \ [Int]) -> Int? {\n    return nil\n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(prod_signs(arr: [1, 2, 2, -4]) == -9)\nassert(prod_signs(arr: [0, 1]) ==\
    \ 0)\nassert(prod_signs(arr: [1, 1, 1, 2, 3, -1, 1]) == -10)\nassert(prod_signs(arr:\
    \ [] as [Int]) == nil)\nassert(prod_signs(arr: [2, 4, 1, 2, -1, -1, 9]) == 20)\n\
    assert(prod_signs(arr: [-1, 1, -1, 1]) == 4)\nassert(prod_signs(arr: [-1, 1, 1,\
    \ 1]) == -4)\nassert(prod_signs(arr: [-1, 1, 1, 0]) == 0)"
  status: Exception
  stderr: 'tmp1rt4wv_3/tmp1rt4wv_3.swift:30: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b2a15132c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b2a14e29b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b2a14e29988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b2a14e287b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmp1rt4wv_3                        0x00005652a02c73d9 <unavailable> + 5081

    5    libc.so.6                          0x00002b2a1531e460 __libc_start_main +
    245

    6    tmp1rt4wv_3                        0x00005652a02c6f69 <unavailable> + 3945

    '
  stdout: ''
  timestamp: 1659979791
- exit_code: 0
  program: "\n/// You are given an array arr of integers and you need to return\n\
    /// sum of magnitudes of integers multiplied by product of all signs\n/// of each\
    \ number in the array, represented by 1, -1 or 0.\n/// Note: return nil for empty\
    \ arr.\n/// Example:\n/// >>> prod_signs(arr: [1, 2, 2, -4])\n/// 9\n/// >>> prod_signs(arr:\
    \ [0, 1])\n/// 0\n/// >>> prod_signs(arr: [] as [Int])\n/// nil\nfunc prod_signs(arr:\
    \ [Int]) -> Int? {\n    if arr.isEmpty {\n        return nil\n    }\n    var prod\
    \ = 1\n    var sum = 0\n    for num in arr {\n        prod *= (num > 0 ? 1 : (num\
    \ < 0 ? -1 : 0))\n        sum += abs(num)\n    }\n    return prod * sum\n}\n\n\
    \nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(prod_signs(arr: [1, 2, 2, -4]) == -9)\nassert(prod_signs(arr:\
    \ [0, 1]) == 0)\nassert(prod_signs(arr: [1, 1, 1, 2, 3, -1, 1]) == -10)\nassert(prod_signs(arr:\
    \ [] as [Int]) == nil)\nassert(prod_signs(arr: [2, 4, 1, 2, -1, -1, 9]) == 20)\n\
    assert(prod_signs(arr: [-1, 1, -1, 1]) == 4)\nassert(prod_signs(arr: [-1, 1, 1,\
    \ 1]) == -4)\nassert(prod_signs(arr: [-1, 1, 1, 0]) == 0)"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659979791
- exit_code: 0
  program: "\n/// You are given an array arr of integers and you need to return\n\
    /// sum of magnitudes of integers multiplied by product of all signs\n/// of each\
    \ number in the array, represented by 1, -1 or 0.\n/// Note: return nil for empty\
    \ arr.\n/// Example:\n/// >>> prod_signs(arr: [1, 2, 2, -4])\n/// 9\n/// >>> prod_signs(arr:\
    \ [0, 1])\n/// 0\n/// >>> prod_signs(arr: [] as [Int])\n/// nil\nfunc prod_signs(arr:\
    \ [Int]) -> Int? {\n    if arr.isEmpty {\n        return nil\n    }\n    else\
    \ {\n        var prod: Int = 1\n        var sum: Int = 0\n        for item in\
    \ arr {\n            if item < 0 {\n                prod *= -1\n            }\n\
    \            else if item > 0 {\n                prod *= 1\n            }\n  \
    \          else {\n                prod *= 0\n            }\n            sum +=\
    \ abs(item)\n        }\n        return sum * prod\n    }\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(prod_signs(arr: [1, 2, 2, -4]) == -9)\nassert(prod_signs(arr:\
    \ [0, 1]) == 0)\nassert(prod_signs(arr: [1, 1, 1, 2, 3, -1, 1]) == -10)\nassert(prod_signs(arr:\
    \ [] as [Int]) == nil)\nassert(prod_signs(arr: [2, 4, 1, 2, -1, -1, 9]) == 20)\n\
    assert(prod_signs(arr: [-1, 1, -1, 1]) == 4)\nassert(prod_signs(arr: [-1, 1, 1,\
    \ 1]) == -4)\nassert(prod_signs(arr: [-1, 1, 1, 0]) == 0)"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659979791
- exit_code: 0
  program: "\n/// You are given an array arr of integers and you need to return\n\
    /// sum of magnitudes of integers multiplied by product of all signs\n/// of each\
    \ number in the array, represented by 1, -1 or 0.\n/// Note: return nil for empty\
    \ arr.\n/// Example:\n/// >>> prod_signs(arr: [1, 2, 2, -4])\n/// 9\n/// >>> prod_signs(arr:\
    \ [0, 1])\n/// 0\n/// >>> prod_signs(arr: [] as [Int])\n/// nil\nfunc prod_signs(arr:\
    \ [Int]) -> Int? {\n    if arr.isEmpty {\n        return nil\n    } else {\n \
    \       var product: Int = 1\n        var sum: Int = 0\n        for i in arr {\n\
    \            if i > 0 {\n                product *= 1\n                sum +=\
    \ i\n            } else if i < 0 {\n                product *= -1\n          \
    \      sum += abs(i)\n            } else {\n                product *= 0\n   \
    \         }\n        }\n        return product * sum\n    }\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(prod_signs(arr: [1, 2, 2, -4]) == -9)\nassert(prod_signs(arr:\
    \ [0, 1]) == 0)\nassert(prod_signs(arr: [1, 1, 1, 2, 3, -1, 1]) == -10)\nassert(prod_signs(arr:\
    \ [] as [Int]) == nil)\nassert(prod_signs(arr: [2, 4, 1, 2, -1, -1, 9]) == 20)\n\
    assert(prod_signs(arr: [-1, 1, -1, 1]) == 4)\nassert(prod_signs(arr: [-1, 1, 1,\
    \ 1]) == -4)\nassert(prod_signs(arr: [-1, 1, 1, 0]) == 0)"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659979791
- exit_code: 0
  program: "\n/// You are given an array arr of integers and you need to return\n\
    /// sum of magnitudes of integers multiplied by product of all signs\n/// of each\
    \ number in the array, represented by 1, -1 or 0.\n/// Note: return nil for empty\
    \ arr.\n/// Example:\n/// >>> prod_signs(arr: [1, 2, 2, -4])\n/// 9\n/// >>> prod_signs(arr:\
    \ [0, 1])\n/// 0\n/// >>> prod_signs(arr: [] as [Int])\n/// nil\nfunc prod_signs(arr:\
    \ [Int]) -> Int? {\n    if arr.isEmpty {\n        return nil\n    }\n    var sign:\
    \ Int = 1\n    var sum: Int = 0\n    for i in arr {\n        if i == 0 {\n   \
    \         sign = 0\n        } else if i < 0 {\n            sign *= -1\n      \
    \  }\n        sum += abs(i)\n    }\n    return sum * sign\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(prod_signs(arr: [1, 2, 2, -4]) == -9)\nassert(prod_signs(arr:\
    \ [0, 1]) == 0)\nassert(prod_signs(arr: [1, 1, 1, 2, 3, -1, 1]) == -10)\nassert(prod_signs(arr:\
    \ [] as [Int]) == nil)\nassert(prod_signs(arr: [2, 4, 1, 2, -1, -1, 9]) == 20)\n\
    assert(prod_signs(arr: [-1, 1, -1, 1]) == 4)\nassert(prod_signs(arr: [-1, 1, 1,\
    \ 1]) == -4)\nassert(prod_signs(arr: [-1, 1, 1, 0]) == 0)"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659979791
- exit_code: 1
  program: "\n/// You are given an array arr of integers and you need to return\n\
    /// sum of magnitudes of integers multiplied by product of all signs\n/// of each\
    \ number in the array, represented by 1, -1 or 0.\n/// Note: return nil for empty\
    \ arr.\n/// Example:\n/// >>> prod_signs(arr: [1, 2, 2, -4])\n/// 9\n/// >>> prod_signs(arr:\
    \ [0, 1])\n/// 0\n/// >>> prod_signs(arr: [] as [Int])\n/// nil\nfunc prod_signs(arr:\
    \ [Int]) -> Int? {\n    guard arr.count > 0 else { return nil }\n    let signs\
    \ = arr.map { sign($0) }\n    let mags = arr.map { abs($0) }\n    let prod = signs.reduce(1,\
    \ *)\n    let sum = mags.reduce(0, +)\n    return prod * sum\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(prod_signs(arr: [1, 2, 2, -4]) == -9)\nassert(prod_signs(arr:\
    \ [0, 1]) == 0)\nassert(prod_signs(arr: [1, 1, 1, 2, 3, -1, 1]) == -10)\nassert(prod_signs(arr:\
    \ [] as [Int]) == nil)\nassert(prod_signs(arr: [2, 4, 1, 2, -1, -1, 9]) == 20)\n\
    assert(prod_signs(arr: [-1, 1, -1, 1]) == 4)\nassert(prod_signs(arr: [-1, 1, 1,\
    \ 1]) == -4)\nassert(prod_signs(arr: [-1, 1, 1, 0]) == 0)"
  status: SyntaxError
  stderr: "/tmp/tmpv036g4t_.swift:15:27: error: cannot find 'sign' in scope\n    let\
    \ signs = arr.map { sign($0) }\n                          ^~~~\n"
  stdout: ''
  timestamp: 1659979791
- exit_code: 1
  program: "\n/// You are given an array arr of integers and you need to return\n\
    /// sum of magnitudes of integers multiplied by product of all signs\n/// of each\
    \ number in the array, represented by 1, -1 or 0.\n/// Note: return nil for empty\
    \ arr.\n/// Example:\n/// >>> prod_signs(arr: [1, 2, 2, -4])\n/// 9\n/// >>> prod_signs(arr:\
    \ [0, 1])\n/// 0\n/// >>> prod_signs(arr: [] as [Int])\n/// nil\nfunc prod_signs(arr:\
    \ [Int]) -> Int? {\n    var product: Int = 1\n    var sum: Int = 0\n    guard\
    \ arr.count > 0 else { return nil }\n    for i in arr {\n        if i == 0 {\n\
    \            continue\n        } else if i > 0 {\n            product *= 1\n \
    \           sum += i\n        } else {\n            product *= -1\n          \
    \  sum += i.magnitude\n        }\n    }\n    return sum * product\n}\n\n\nfunc\
    \ ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count !=\
    \ right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(prod_signs(arr: [1, 2, 2, -4]) == -9)\nassert(prod_signs(arr:\
    \ [0, 1]) == 0)\nassert(prod_signs(arr: [1, 1, 1, 2, 3, -1, 1]) == -10)\nassert(prod_signs(arr:\
    \ [] as [Int]) == nil)\nassert(prod_signs(arr: [2, 4, 1, 2, -1, -1, 9]) == 20)\n\
    assert(prod_signs(arr: [-1, 1, -1, 1]) == 4)\nassert(prod_signs(arr: [-1, 1, 1,\
    \ 1]) == -4)\nassert(prod_signs(arr: [-1, 1, 1, 0]) == 0)"
  status: SyntaxError
  stderr: "/tmp/tmph5m26gep.swift:25:22: error: cannot convert value of type 'UInt'\
    \ to expected argument type 'Int'\n            sum += i.magnitude\n          \
    \           ^\n                   Int(       )\n"
  stdout: ''
  timestamp: 1659979791
- exit_code: 0
  program: "\n/// You are given an array arr of integers and you need to return\n\
    /// sum of magnitudes of integers multiplied by product of all signs\n/// of each\
    \ number in the array, represented by 1, -1 or 0.\n/// Note: return nil for empty\
    \ arr.\n/// Example:\n/// >>> prod_signs(arr: [1, 2, 2, -4])\n/// 9\n/// >>> prod_signs(arr:\
    \ [0, 1])\n/// 0\n/// >>> prod_signs(arr: [] as [Int])\n/// nil\nfunc prod_signs(arr:\
    \ [Int]) -> Int? {\n  if arr.isEmpty {\n    return nil\n  }\n  var product = 1\n\
    \  var sum = 0\n  for i in arr {\n    if i > 0 {\n      product *= 1\n    } else\
    \ if i < 0 {\n      product *= -1\n    } else {\n      product *= 0\n    }\n \
    \   sum += abs(i)\n  }\n  return sum * product\n}\n\n\nfunc ==(left: [(Int, Int)],\
    \ right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n       \
    \ return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r\
    \ {\n            return false\n        }\n    }\n    return true\n}\n        \
    \    \nassert(prod_signs(arr: [1, 2, 2, -4]) == -9)\nassert(prod_signs(arr: [0,\
    \ 1]) == 0)\nassert(prod_signs(arr: [1, 1, 1, 2, 3, -1, 1]) == -10)\nassert(prod_signs(arr:\
    \ [] as [Int]) == nil)\nassert(prod_signs(arr: [2, 4, 1, 2, -1, -1, 9]) == 20)\n\
    assert(prod_signs(arr: [-1, 1, -1, 1]) == 4)\nassert(prod_signs(arr: [-1, 1, 1,\
    \ 1]) == -4)\nassert(prod_signs(arr: [-1, 1, 1, 0]) == 0)"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659979791
- exit_code: -4
  program: "\n/// You are given an array arr of integers and you need to return\n\
    /// sum of magnitudes of integers multiplied by product of all signs\n/// of each\
    \ number in the array, represented by 1, -1 or 0.\n/// Note: return nil for empty\
    \ arr.\n/// Example:\n/// >>> prod_signs(arr: [1, 2, 2, -4])\n/// 9\n/// >>> prod_signs(arr:\
    \ [0, 1])\n/// 0\n/// >>> prod_signs(arr: [] as [Int])\n/// nil\nfunc prod_signs(arr:\
    \ [Int]) -> Int? {\n    return arr.isEmpty ? nil : arr.map{ abs($0) }.reduce(1,\
    \ *) * arr.map{ $0 == 0 ? 0 : $0 > 0 ? 1 : -1 }.reduce(1, *)\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(prod_signs(arr: [1, 2, 2, -4]) == -9)\nassert(prod_signs(arr:\
    \ [0, 1]) == 0)\nassert(prod_signs(arr: [1, 1, 1, 2, 3, -1, 1]) == -10)\nassert(prod_signs(arr:\
    \ [] as [Int]) == nil)\nassert(prod_signs(arr: [2, 4, 1, 2, -1, -1, 9]) == 20)\n\
    assert(prod_signs(arr: [-1, 1, -1, 1]) == 4)\nassert(prod_signs(arr: [-1, 1, 1,\
    \ 1]) == -4)\nassert(prod_signs(arr: [-1, 1, 1, 0]) == 0)"
  status: Exception
  stderr: 'tmp3xx6y28k/tmp3xx6y28k.swift:30: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b1e4e268c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b1e4df5fb6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b1e4df5f988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b1e4df5e7b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmp3xx6y28k                        0x000056421ba38639 <unavailable> + 5689

    5    libc.so.6                          0x00002b1e4e454460 __libc_start_main +
    245

    6    tmp3xx6y28k                        0x000056421ba381c9 <unavailable> + 4553

    '
  stdout: ''
  timestamp: 1659979791
- exit_code: -4
  program: "\n/// You are given an array arr of integers and you need to return\n\
    /// sum of magnitudes of integers multiplied by product of all signs\n/// of each\
    \ number in the array, represented by 1, -1 or 0.\n/// Note: return nil for empty\
    \ arr.\n/// Example:\n/// >>> prod_signs(arr: [1, 2, 2, -4])\n/// 9\n/// >>> prod_signs(arr:\
    \ [0, 1])\n/// 0\n/// >>> prod_signs(arr: [] as [Int])\n/// nil\nfunc prod_signs(arr:\
    \ [Int]) -> Int? {\n    guard arr.count > 0 else {\n        return nil\n    }\n\
    \    let signs = arr.map { $0.signum() }\n    let pr = signs.reduce(1, *)\n  \
    \  let sum = arr.reduce(0, +)\n    return abs(sum) * pr\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(prod_signs(arr: [1, 2, 2, -4]) == -9)\nassert(prod_signs(arr:\
    \ [0, 1]) == 0)\nassert(prod_signs(arr: [1, 1, 1, 2, 3, -1, 1]) == -10)\nassert(prod_signs(arr:\
    \ [] as [Int]) == nil)\nassert(prod_signs(arr: [2, 4, 1, 2, -1, -1, 9]) == 20)\n\
    assert(prod_signs(arr: [-1, 1, -1, 1]) == 4)\nassert(prod_signs(arr: [-1, 1, 1,\
    \ 1]) == -4)\nassert(prod_signs(arr: [-1, 1, 1, 0]) == 0)"
  status: Exception
  stderr: 'tmphr1cr2s4/tmphr1cr2s4.swift:36: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002affcad68c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002affcaa5fb6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002affcaa5f988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002affcaa5e7b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmphr1cr2s4                        0x0000555dbdca3699 <unavailable> + 5785

    5    libc.so.6                          0x00002affcaf54460 __libc_start_main +
    245

    6    tmphr1cr2s4                        0x0000555dbdca3229 <unavailable> + 4649

    '
  stdout: ''
  timestamp: 1659979791
- exit_code: -4
  program: "\n/// You are given an array arr of integers and you need to return\n\
    /// sum of magnitudes of integers multiplied by product of all signs\n/// of each\
    \ number in the array, represented by 1, -1 or 0.\n/// Note: return nil for empty\
    \ arr.\n/// Example:\n/// >>> prod_signs(arr: [1, 2, 2, -4])\n/// 9\n/// >>> prod_signs(arr:\
    \ [0, 1])\n/// 0\n/// >>> prod_signs(arr: [] as [Int])\n/// nil\nfunc prod_signs(arr:\
    \ [Int]) -> Int? {\n    var product: Int = 1\n    for number in arr {\n      \
    \  if number < 0 {\n            product *= -1\n        } else if number == 0 {\n\
    \            return 0\n        }\n    }\n    var sum = 0\n    for number in arr\
    \ {\n        sum += abs(number)\n    }\n    return sum * product\n}\n\n\nfunc\
    \ ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count !=\
    \ right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(prod_signs(arr: [1, 2, 2, -4]) == -9)\nassert(prod_signs(arr:\
    \ [0, 1]) == 0)\nassert(prod_signs(arr: [1, 1, 1, 2, 3, -1, 1]) == -10)\nassert(prod_signs(arr:\
    \ [] as [Int]) == nil)\nassert(prod_signs(arr: [2, 4, 1, 2, -1, -1, 9]) == 20)\n\
    assert(prod_signs(arr: [-1, 1, -1, 1]) == 4)\nassert(prod_signs(arr: [-1, 1, 1,\
    \ 1]) == -4)\nassert(prod_signs(arr: [-1, 1, 1, 0]) == 0)"
  status: Exception
  stderr: 'tmpb31xmzuz/tmpb31xmzuz.swift:45: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b41a087fc80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b41a0576b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b41a0576988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b41a05757b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpb31xmzuz                        0x0000558cd7387a5c <unavailable> + 6748

    5    libc.so.6                          0x00002b41a0a6b460 __libc_start_main +
    245

    6    tmpb31xmzuz                        0x0000558cd73871c9 <unavailable> + 4553

    '
  stdout: ''
  timestamp: 1659979791
- exit_code: -4
  program: "\n/// You are given an array arr of integers and you need to return\n\
    /// sum of magnitudes of integers multiplied by product of all signs\n/// of each\
    \ number in the array, represented by 1, -1 or 0.\n/// Note: return nil for empty\
    \ arr.\n/// Example:\n/// >>> prod_signs(arr: [1, 2, 2, -4])\n/// 9\n/// >>> prod_signs(arr:\
    \ [0, 1])\n/// 0\n/// >>> prod_signs(arr: [] as [Int])\n/// nil\nfunc prod_signs(arr:\
    \ [Int]) -> Int? {\n    return (arr.isEmpty) ? nil :\n        Int(arr.filter {\
    \ $0 < 0 }.count % 2 == 0 ? 1 : -1) *\n        arr.map { abs($0) }.reduce(1, *)\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(prod_signs(arr: [1, 2, 2, -4]) == -9)\nassert(prod_signs(arr:\
    \ [0, 1]) == 0)\nassert(prod_signs(arr: [1, 1, 1, 2, 3, -1, 1]) == -10)\nassert(prod_signs(arr:\
    \ [] as [Int]) == nil)\nassert(prod_signs(arr: [2, 4, 1, 2, -1, -1, 9]) == 20)\n\
    assert(prod_signs(arr: [-1, 1, -1, 1]) == 4)\nassert(prod_signs(arr: [-1, 1, 1,\
    \ 1]) == -4)\nassert(prod_signs(arr: [-1, 1, 1, 0]) == 0)"
  status: Exception
  stderr: 'tmpd0ntl6rt/tmpd0ntl6rt.swift:32: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b90980b5c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b9097dacb6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b9097dac988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b9097dab7b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpd0ntl6rt                        0x000055a330406929 <unavailable> + 6441

    5    libc.so.6                          0x00002b90982a1460 __libc_start_main +
    245

    6    tmpd0ntl6rt                        0x000055a3304064b9 <unavailable> + 5305

    '
  stdout: ''
  timestamp: 1659979791
- exit_code: 1
  program: "\n/// You are given an array arr of integers and you need to return\n\
    /// sum of magnitudes of integers multiplied by product of all signs\n/// of each\
    \ number in the array, represented by 1, -1 or 0.\n/// Note: return nil for empty\
    \ arr.\n/// Example:\n/// >>> prod_signs(arr: [1, 2, 2, -4])\n/// 9\n/// >>> prod_signs(arr:\
    \ [0, 1])\n/// 0\n/// >>> prod_signs(arr: [] as [Int])\n/// nil\nfunc prod_signs(arr:\
    \ [Int]) -> Int? {\n    var res: Int? = nil\n    var product: Int = 1\n    var\
    \ magnitude: Int = 0\n    for number in arr {\n        product *= number.signum()\n\
    \        magnitude += number.magnitude\n    }\n    if magnitude != 0 {\n     \
    \   res = product * magnitude\n    }\n    return res\n}\n\n\nfunc ==(left: [(Int,\
    \ Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n\
    \        return false\n    }\n    for (l, r) in zip(left, right) {\n        if\
    \ l != r {\n            return false\n        }\n    }\n    return true\n}\n \
    \           \nassert(prod_signs(arr: [1, 2, 2, -4]) == -9)\nassert(prod_signs(arr:\
    \ [0, 1]) == 0)\nassert(prod_signs(arr: [1, 1, 1, 2, 3, -1, 1]) == -10)\nassert(prod_signs(arr:\
    \ [] as [Int]) == nil)\nassert(prod_signs(arr: [2, 4, 1, 2, -1, -1, 9]) == 20)\n\
    assert(prod_signs(arr: [-1, 1, -1, 1]) == 4)\nassert(prod_signs(arr: [-1, 1, 1,\
    \ 1]) == -4)\nassert(prod_signs(arr: [-1, 1, 1, 0]) == 0)"
  status: SyntaxError
  stderr: "/tmp/tmpj3w8wz2g.swift:19:29: error: cannot convert value of type 'UInt'\
    \ to expected argument type 'Int'\n        magnitude += number.magnitude\n   \
    \                         ^\n                     Int(            )\n"
  stdout: ''
  timestamp: 1659979791
- exit_code: 0
  program: "\n/// You are given an array arr of integers and you need to return\n\
    /// sum of magnitudes of integers multiplied by product of all signs\n/// of each\
    \ number in the array, represented by 1, -1 or 0.\n/// Note: return nil for empty\
    \ arr.\n/// Example:\n/// >>> prod_signs(arr: [1, 2, 2, -4])\n/// 9\n/// >>> prod_signs(arr:\
    \ [0, 1])\n/// 0\n/// >>> prod_signs(arr: [] as [Int])\n/// nil\nfunc prod_signs(arr:\
    \ [Int]) -> Int? {\n    if arr.isEmpty {\n        return nil\n    }\n    var prod\
    \ = 1\n    var sum = 0\n    for value in arr {\n        if value < 0 {\n     \
    \       prod *= -1\n        } else if value > 0 {\n            prod *= 1\n   \
    \     } else {\n            prod *= 0\n        }\n        sum += abs(value)\n\
    \    }\n    return sum * prod\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int,\
    \ Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n\
    \    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n          \
    \  return false\n        }\n    }\n    return true\n}\n            \nassert(prod_signs(arr:\
    \ [1, 2, 2, -4]) == -9)\nassert(prod_signs(arr: [0, 1]) == 0)\nassert(prod_signs(arr:\
    \ [1, 1, 1, 2, 3, -1, 1]) == -10)\nassert(prod_signs(arr: [] as [Int]) == nil)\n\
    assert(prod_signs(arr: [2, 4, 1, 2, -1, -1, 9]) == 20)\nassert(prod_signs(arr:\
    \ [-1, 1, -1, 1]) == 4)\nassert(prod_signs(arr: [-1, 1, 1, 1]) == -4)\nassert(prod_signs(arr:\
    \ [-1, 1, 1, 0]) == 0)"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659979791
- exit_code: -4
  program: "\n/// You are given an array arr of integers and you need to return\n\
    /// sum of magnitudes of integers multiplied by product of all signs\n/// of each\
    \ number in the array, represented by 1, -1 or 0.\n/// Note: return nil for empty\
    \ arr.\n/// Example:\n/// >>> prod_signs(arr: [1, 2, 2, -4])\n/// 9\n/// >>> prod_signs(arr:\
    \ [0, 1])\n/// 0\n/// >>> prod_signs(arr: [] as [Int])\n/// nil\nfunc prod_signs(arr:\
    \ [Int]) -> Int? {\n  let result = arr.map { $0 == 0 ? 1 : $0 < 0 ? -1 : 1 }.reduce(1,\
    \ *)\n  return arr.count == 0 ? nil : result * arr.map { abs($0) }.reduce(0, +)\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(prod_signs(arr: [1, 2, 2, -4]) == -9)\nassert(prod_signs(arr:\
    \ [0, 1]) == 0)\nassert(prod_signs(arr: [1, 1, 1, 2, 3, -1, 1]) == -10)\nassert(prod_signs(arr:\
    \ [] as [Int]) == nil)\nassert(prod_signs(arr: [2, 4, 1, 2, -1, -1, 9]) == 20)\n\
    assert(prod_signs(arr: [-1, 1, -1, 1]) == 4)\nassert(prod_signs(arr: [-1, 1, 1,\
    \ 1]) == -4)\nassert(prod_signs(arr: [-1, 1, 1, 0]) == 0)"
  status: Exception
  stderr: 'tmp_gvzuroa/tmp_gvzuroa.swift:32: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b7512ed9c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b7512bd0b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b7512bd0988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b7512bcf7b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmp_gvzuroa                        0x000055a1e61cf7d5 <unavailable> + 6101

    5    libc.so.6                          0x00002b75130c5460 __libc_start_main +
    245

    6    tmp_gvzuroa                        0x000055a1e61cf1d9 <unavailable> + 4569

    '
  stdout: ''
  timestamp: 1659979791
- exit_code: 1
  program: "\n/// You are given an array arr of integers and you need to return\n\
    /// sum of magnitudes of integers multiplied by product of all signs\n/// of each\
    \ number in the array, represented by 1, -1 or 0.\n/// Note: return nil for empty\
    \ arr.\n/// Example:\n/// >>> prod_signs(arr: [1, 2, 2, -4])\n/// 9\n/// >>> prod_signs(arr:\
    \ [0, 1])\n/// 0\n/// >>> prod_signs(arr: [] as [Int])\n/// nil\nfunc prod_signs(arr:\
    \ [Int]) -> Int? {\n    var result: Int? = nil\n    var product: Int = 1\n   \
    \ var sum: Int = 0\n    if arr.count > 0 {\n        for i in arr {\n         \
    \   let si = sign(num: i)\n            if si == 1 {\n                product *=\
    \ 1\n            } else if si == -1 {\n                product *= -1\n       \
    \     } else {\n                product *= 0\n            }\n            sum +=\
    \ abs(i)\n        }\n        result = sum * product\n    }\n    return result\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(prod_signs(arr: [1, 2, 2, -4]) == -9)\nassert(prod_signs(arr:\
    \ [0, 1]) == 0)\nassert(prod_signs(arr: [1, 1, 1, 2, 3, -1, 1]) == -10)\nassert(prod_signs(arr:\
    \ [] as [Int]) == nil)\nassert(prod_signs(arr: [2, 4, 1, 2, -1, -1, 9]) == 20)\n\
    assert(prod_signs(arr: [-1, 1, -1, 1]) == 4)\nassert(prod_signs(arr: [-1, 1, 1,\
    \ 1]) == -4)\nassert(prod_signs(arr: [-1, 1, 1, 0]) == 0)"
  status: SyntaxError
  stderr: "/tmp/tmpl47baicy.swift:19:22: error: cannot find 'sign' in scope\n    \
    \        let si = sign(num: i)\n                     ^~~~\n"
  stdout: ''
  timestamp: 1659979791
- exit_code: 1
  program: "\n/// You are given an array arr of integers and you need to return\n\
    /// sum of magnitudes of integers multiplied by product of all signs\n/// of each\
    \ number in the array, represented by 1, -1 or 0.\n/// Note: return nil for empty\
    \ arr.\n/// Example:\n/// >>> prod_signs(arr: [1, 2, 2, -4])\n/// 9\n/// >>> prod_signs(arr:\
    \ [0, 1])\n/// 0\n/// >>> prod_signs(arr: [] as [Int])\n/// nil\nfunc prod_signs(arr:\
    \ [Int]) -> Int? {\n  if arr.isEmpty {\n    return nil\n  }\n  var prod = 1\n\
    \  var sum = 0\n  for i in arr {\n    prod *= i.signum()\n    sum += i.magnitude\n\
    \  }\n  return prod * sum\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(prod_signs(arr:\
    \ [1, 2, 2, -4]) == -9)\nassert(prod_signs(arr: [0, 1]) == 0)\nassert(prod_signs(arr:\
    \ [1, 1, 1, 2, 3, -1, 1]) == -10)\nassert(prod_signs(arr: [] as [Int]) == nil)\n\
    assert(prod_signs(arr: [2, 4, 1, 2, -1, -1, 9]) == 20)\nassert(prod_signs(arr:\
    \ [-1, 1, -1, 1]) == 4)\nassert(prod_signs(arr: [-1, 1, 1, 1]) == -4)\nassert(prod_signs(arr:\
    \ [-1, 1, 1, 0]) == 0)"
  status: SyntaxError
  stderr: "/tmp/tmpk6pcdn7w.swift:21:14: error: cannot convert value of type 'UInt'\
    \ to expected argument type 'Int'\n    sum += i.magnitude\n             ^\n  \
    \         Int(       )\n"
  stdout: ''
  timestamp: 1659979791
- exit_code: 0
  program: "\n/// You are given an array arr of integers and you need to return\n\
    /// sum of magnitudes of integers multiplied by product of all signs\n/// of each\
    \ number in the array, represented by 1, -1 or 0.\n/// Note: return nil for empty\
    \ arr.\n/// Example:\n/// >>> prod_signs(arr: [1, 2, 2, -4])\n/// 9\n/// >>> prod_signs(arr:\
    \ [0, 1])\n/// 0\n/// >>> prod_signs(arr: [] as [Int])\n/// nil\nfunc prod_signs(arr:\
    \ [Int]) -> Int? {\n    guard arr.count > 0 else {\n        return nil\n    }\n\
    \    let mags = arr.map { abs($0) }\n    let sign = arr.map { $0 == 0 ? 0 : $0\
    \ > 0 ? 1 : -1 }\n    let prod = sign.reduce(1, *)\n    return mags.reduce(0,\
    \ +) * prod\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n\
    \    if left.count != right.count {\n        return false\n    }\n    for (l,\
    \ r) in zip(left, right) {\n        if l != r {\n            return false\n  \
    \      }\n    }\n    return true\n}\n            \nassert(prod_signs(arr: [1,\
    \ 2, 2, -4]) == -9)\nassert(prod_signs(arr: [0, 1]) == 0)\nassert(prod_signs(arr:\
    \ [1, 1, 1, 2, 3, -1, 1]) == -10)\nassert(prod_signs(arr: [] as [Int]) == nil)\n\
    assert(prod_signs(arr: [2, 4, 1, 2, -1, -1, 9]) == 20)\nassert(prod_signs(arr:\
    \ [-1, 1, -1, 1]) == 4)\nassert(prod_signs(arr: [-1, 1, 1, 1]) == -4)\nassert(prod_signs(arr:\
    \ [-1, 1, 1, 0]) == 0)"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659979791
- exit_code: -4
  program: "\n/// You are given an array arr of integers and you need to return\n\
    /// sum of magnitudes of integers multiplied by product of all signs\n/// of each\
    \ number in the array, represented by 1, -1 or 0.\n/// Note: return nil for empty\
    \ arr.\n/// Example:\n/// >>> prod_signs(arr: [1, 2, 2, -4])\n/// 9\n/// >>> prod_signs(arr:\
    \ [0, 1])\n/// 0\n/// >>> prod_signs(arr: [] as [Int])\n/// nil\nfunc prod_signs(arr:\
    \ [Int]) -> Int? {\n  if arr.isEmpty {\n    return nil\n  }\n  var product = 1\n\
    \  var sum = 0\n  for number in arr {\n    if number == 0 {\n      continue\n\
    \    }\n    sum += abs(number)\n    if number > 0 {\n      product *= 1\n    }\
    \ else {\n      product *= -1\n    }\n  }\n  return sum * product\n}\n\n\nfunc\
    \ ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count !=\
    \ right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(prod_signs(arr: [1, 2, 2, -4]) == -9)\nassert(prod_signs(arr:\
    \ [0, 1]) == 0)\nassert(prod_signs(arr: [1, 1, 1, 2, 3, -1, 1]) == -10)\nassert(prod_signs(arr:\
    \ [] as [Int]) == nil)\nassert(prod_signs(arr: [2, 4, 1, 2, -1, -1, 9]) == 20)\n\
    assert(prod_signs(arr: [-1, 1, -1, 1]) == 4)\nassert(prod_signs(arr: [-1, 1, 1,\
    \ 1]) == -4)\nassert(prod_signs(arr: [-1, 1, 1, 0]) == 0)"
  status: Exception
  stderr: 'tmph6wv7niz/tmph6wv7niz.swift:47: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002ab8e92c3c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002ab8e8fbab6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002ab8e8fba988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002ab8e8fb97b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmph6wv7niz                        0x0000558f037de815 <unavailable> + 6165

    5    libc.so.6                          0x00002ab8e94af460 __libc_start_main +
    245

    6    tmph6wv7niz                        0x0000558f037de219 <unavailable> + 4633

    '
  stdout: ''
  timestamp: 1659979792
- exit_code: -4
  program: "\n/// You are given an array arr of integers and you need to return\n\
    /// sum of magnitudes of integers multiplied by product of all signs\n/// of each\
    \ number in the array, represented by 1, -1 or 0.\n/// Note: return nil for empty\
    \ arr.\n/// Example:\n/// >>> prod_signs(arr: [1, 2, 2, -4])\n/// 9\n/// >>> prod_signs(arr:\
    \ [0, 1])\n/// 0\n/// >>> prod_signs(arr: [] as [Int])\n/// nil\nfunc prod_signs(arr:\
    \ [Int]) -> Int? {\n    guard arr.count > 0 else { return nil }\n    var sum =\
    \ 0\n    var prod = 1\n    for i in arr {\n        if i > 0 { sum += i }\n   \
    \     else if i < 0 { sum += abs(i); prod *= -1 }\n    }\n    return sum * prod\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(prod_signs(arr: [1, 2, 2, -4]) == -9)\nassert(prod_signs(arr:\
    \ [0, 1]) == 0)\nassert(prod_signs(arr: [1, 1, 1, 2, 3, -1, 1]) == -10)\nassert(prod_signs(arr:\
    \ [] as [Int]) == nil)\nassert(prod_signs(arr: [2, 4, 1, 2, -1, -1, 9]) == 20)\n\
    assert(prod_signs(arr: [-1, 1, -1, 1]) == 4)\nassert(prod_signs(arr: [-1, 1, 1,\
    \ 1]) == -4)\nassert(prod_signs(arr: [-1, 1, 1, 0]) == 0)"
  status: Exception
  stderr: 'tmpobfeaxy1/tmpobfeaxy1.swift:38: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b936dbbfc80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b936d8b6b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b936d8b6988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b936d8b57b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpobfeaxy1                        0x000055cf6aa2e815 <unavailable> + 6165

    5    libc.so.6                          0x00002b936ddab460 __libc_start_main +
    245

    6    tmpobfeaxy1                        0x000055cf6aa2e219 <unavailable> + 4633

    '
  stdout: ''
  timestamp: 1659979792
- exit_code: -4
  program: "\n/// You are given an array arr of integers and you need to return\n\
    /// sum of magnitudes of integers multiplied by product of all signs\n/// of each\
    \ number in the array, represented by 1, -1 or 0.\n/// Note: return nil for empty\
    \ arr.\n/// Example:\n/// >>> prod_signs(arr: [1, 2, 2, -4])\n/// 9\n/// >>> prod_signs(arr:\
    \ [0, 1])\n/// 0\n/// >>> prod_signs(arr: [] as [Int])\n/// nil\nfunc prod_signs(arr:\
    \ [Int]) -> Int? {\n    return arr.reduce((sum: 0, pos: 1, neg: 1), {\n      \
    \  let sign = $1 >= 0 ? 1 : -1\n        let result = $0.sum + abs($1) * ($0.pos\
    \ * sign + $0.neg * (sign * -1))\n        return (result, $0.pos * sign, $0.neg\
    \ * (sign * -1))\n    }).sum\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int,\
    \ Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n\
    \    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n          \
    \  return false\n        }\n    }\n    return true\n}\n            \nassert(prod_signs(arr:\
    \ [1, 2, 2, -4]) == -9)\nassert(prod_signs(arr: [0, 1]) == 0)\nassert(prod_signs(arr:\
    \ [1, 1, 1, 2, 3, -1, 1]) == -10)\nassert(prod_signs(arr: [] as [Int]) == nil)\n\
    assert(prod_signs(arr: [2, 4, 1, 2, -1, -1, 9]) == 20)\nassert(prod_signs(arr:\
    \ [-1, 1, -1, 1]) == 4)\nassert(prod_signs(arr: [-1, 1, 1, 1]) == -4)\nassert(prod_signs(arr:\
    \ [-1, 1, 1, 0]) == 0)"
  status: Exception
  stderr: 'tmp16udh5eq/tmp16udh5eq.swift:34: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b52130eac80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b5212de1b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b5212de1988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b5212de07b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmp16udh5eq                        0x0000560c530d0539 <unavailable> + 5433

    5    libc.so.6                          0x00002b52132d6460 __libc_start_main +
    245

    6    tmp16udh5eq                        0x0000560c530d00c9 <unavailable> + 4297

    '
  stdout: ''
  timestamp: 1659979792
- exit_code: 0
  program: "\n/// You are given an array arr of integers and you need to return\n\
    /// sum of magnitudes of integers multiplied by product of all signs\n/// of each\
    \ number in the array, represented by 1, -1 or 0.\n/// Note: return nil for empty\
    \ arr.\n/// Example:\n/// >>> prod_signs(arr: [1, 2, 2, -4])\n/// 9\n/// >>> prod_signs(arr:\
    \ [0, 1])\n/// 0\n/// >>> prod_signs(arr: [] as [Int])\n/// nil\nfunc prod_signs(arr:\
    \ [Int]) -> Int? {\n    if arr.isEmpty {\n        return nil\n    }\n    let sum\
    \ = arr.map { $0 < 0 ? $0 * -1 : $0 }.reduce(0, +)\n    let prod = arr.map { $0\
    \ < 0 ? -1 : $0 == 0 ? 0 : 1 }.reduce(1, *)\n    return sum * prod\n}\n\n\nfunc\
    \ ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count !=\
    \ right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(prod_signs(arr: [1, 2, 2, -4]) == -9)\nassert(prod_signs(arr:\
    \ [0, 1]) == 0)\nassert(prod_signs(arr: [1, 1, 1, 2, 3, -1, 1]) == -10)\nassert(prod_signs(arr:\
    \ [] as [Int]) == nil)\nassert(prod_signs(arr: [2, 4, 1, 2, -1, -1, 9]) == 20)\n\
    assert(prod_signs(arr: [-1, 1, -1, 1]) == 4)\nassert(prod_signs(arr: [-1, 1, 1,\
    \ 1]) == -4)\nassert(prod_signs(arr: [-1, 1, 1, 0]) == 0)"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659979792
- exit_code: 0
  program: "\n/// You are given an array arr of integers and you need to return\n\
    /// sum of magnitudes of integers multiplied by product of all signs\n/// of each\
    \ number in the array, represented by 1, -1 or 0.\n/// Note: return nil for empty\
    \ arr.\n/// Example:\n/// >>> prod_signs(arr: [1, 2, 2, -4])\n/// 9\n/// >>> prod_signs(arr:\
    \ [0, 1])\n/// 0\n/// >>> prod_signs(arr: [] as [Int])\n/// nil\nfunc prod_signs(arr:\
    \ [Int]) -> Int? {\n    guard arr.count > 0 else {\n        return nil\n    }\n\
    \    let sign_prod = arr.reduce(1) { $0 * $1.signum() }\n    let sum = arr.reduce(0)\
    \ { abs($0) + abs($1) }\n    return sum * sign_prod\n}\n\n\nfunc ==(left: [(Int,\
    \ Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n\
    \        return false\n    }\n    for (l, r) in zip(left, right) {\n        if\
    \ l != r {\n            return false\n        }\n    }\n    return true\n}\n \
    \           \nassert(prod_signs(arr: [1, 2, 2, -4]) == -9)\nassert(prod_signs(arr:\
    \ [0, 1]) == 0)\nassert(prod_signs(arr: [1, 1, 1, 2, 3, -1, 1]) == -10)\nassert(prod_signs(arr:\
    \ [] as [Int]) == nil)\nassert(prod_signs(arr: [2, 4, 1, 2, -1, -1, 9]) == 20)\n\
    assert(prod_signs(arr: [-1, 1, -1, 1]) == 4)\nassert(prod_signs(arr: [-1, 1, 1,\
    \ 1]) == -4)\nassert(prod_signs(arr: [-1, 1, 1, 0]) == 0)"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659979792
- exit_code: 0
  program: "\n/// You are given an array arr of integers and you need to return\n\
    /// sum of magnitudes of integers multiplied by product of all signs\n/// of each\
    \ number in the array, represented by 1, -1 or 0.\n/// Note: return nil for empty\
    \ arr.\n/// Example:\n/// >>> prod_signs(arr: [1, 2, 2, -4])\n/// 9\n/// >>> prod_signs(arr:\
    \ [0, 1])\n/// 0\n/// >>> prod_signs(arr: [] as [Int])\n/// nil\nfunc prod_signs(arr:\
    \ [Int]) -> Int? {\n    if arr.isEmpty {\n        return nil\n    }\n    let prod\
    \ = arr.map {$0.signum()}.reduce(1, *)\n    let abs_sum = arr.map {abs($0)}.reduce(0,\
    \ +)\n    return prod * abs_sum\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int,\
    \ Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n\
    \    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n          \
    \  return false\n        }\n    }\n    return true\n}\n            \nassert(prod_signs(arr:\
    \ [1, 2, 2, -4]) == -9)\nassert(prod_signs(arr: [0, 1]) == 0)\nassert(prod_signs(arr:\
    \ [1, 1, 1, 2, 3, -1, 1]) == -10)\nassert(prod_signs(arr: [] as [Int]) == nil)\n\
    assert(prod_signs(arr: [2, 4, 1, 2, -1, -1, 9]) == 20)\nassert(prod_signs(arr:\
    \ [-1, 1, -1, 1]) == 4)\nassert(prod_signs(arr: [-1, 1, 1, 1]) == -4)\nassert(prod_signs(arr:\
    \ [-1, 1, 1, 0]) == 0)"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659979792
- exit_code: -4
  program: "\n/// You are given an array arr of integers and you need to return\n\
    /// sum of magnitudes of integers multiplied by product of all signs\n/// of each\
    \ number in the array, represented by 1, -1 or 0.\n/// Note: return nil for empty\
    \ arr.\n/// Example:\n/// >>> prod_signs(arr: [1, 2, 2, -4])\n/// 9\n/// >>> prod_signs(arr:\
    \ [0, 1])\n/// 0\n/// >>> prod_signs(arr: [] as [Int])\n/// nil\nfunc prod_signs(arr:\
    \ [Int]) -> Int? {\n    if arr.isEmpty {\n        return nil\n    }\n    return\
    \ arr.map { ($0 != 0) ? $0 : 1 }.reduce(1, *) * arr.map { abs($0) }.reduce(0,\
    \ +)\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if\
    \ left.count != right.count {\n        return false\n    }\n    for (l, r) in\
    \ zip(left, right) {\n        if l != r {\n            return false\n        }\n\
    \    }\n    return true\n}\n            \nassert(prod_signs(arr: [1, 2, 2, -4])\
    \ == -9)\nassert(prod_signs(arr: [0, 1]) == 0)\nassert(prod_signs(arr: [1, 1,\
    \ 1, 2, 3, -1, 1]) == -10)\nassert(prod_signs(arr: [] as [Int]) == nil)\nassert(prod_signs(arr:\
    \ [2, 4, 1, 2, -1, -1, 9]) == 20)\nassert(prod_signs(arr: [-1, 1, -1, 1]) == 4)\n\
    assert(prod_signs(arr: [-1, 1, 1, 1]) == -4)\nassert(prod_signs(arr: [-1, 1, 1,\
    \ 0]) == 0)"
  status: Exception
  stderr: 'tmpvh6c4426/tmpvh6c4426.swift:33: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002ac79183fc80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002ac791536b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002ac791536988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002ac7915357b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpvh6c4426                        0x0000558b7c1db639 <unavailable> + 5689

    5    libc.so.6                          0x00002ac791a2b460 __libc_start_main +
    245

    6    tmpvh6c4426                        0x0000558b7c1db1c9 <unavailable> + 4553

    '
  stdout: ''
  timestamp: 1659979792
- exit_code: 0
  program: "\n/// You are given an array arr of integers and you need to return\n\
    /// sum of magnitudes of integers multiplied by product of all signs\n/// of each\
    \ number in the array, represented by 1, -1 or 0.\n/// Note: return nil for empty\
    \ arr.\n/// Example:\n/// >>> prod_signs(arr: [1, 2, 2, -4])\n/// 9\n/// >>> prod_signs(arr:\
    \ [0, 1])\n/// 0\n/// >>> prod_signs(arr: [] as [Int])\n/// nil\nfunc prod_signs(arr:\
    \ [Int]) -> Int? {\n    return arr.count == 0 ? nil : arr.reduce(1) { $0 * ($1\
    \ > 0 ? 1 : $1 < 0 ? -1 : 0) } * arr.reduce(0) { $0 + abs($1) }\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(prod_signs(arr: [1, 2, 2, -4]) == -9)\nassert(prod_signs(arr:\
    \ [0, 1]) == 0)\nassert(prod_signs(arr: [1, 1, 1, 2, 3, -1, 1]) == -10)\nassert(prod_signs(arr:\
    \ [] as [Int]) == nil)\nassert(prod_signs(arr: [2, 4, 1, 2, -1, -1, 9]) == 20)\n\
    assert(prod_signs(arr: [-1, 1, -1, 1]) == 4)\nassert(prod_signs(arr: [-1, 1, 1,\
    \ 1]) == -4)\nassert(prod_signs(arr: [-1, 1, 1, 0]) == 0)"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659979792
- exit_code: 0
  program: "\n/// You are given an array arr of integers and you need to return\n\
    /// sum of magnitudes of integers multiplied by product of all signs\n/// of each\
    \ number in the array, represented by 1, -1 or 0.\n/// Note: return nil for empty\
    \ arr.\n/// Example:\n/// >>> prod_signs(arr: [1, 2, 2, -4])\n/// 9\n/// >>> prod_signs(arr:\
    \ [0, 1])\n/// 0\n/// >>> prod_signs(arr: [] as [Int])\n/// nil\nfunc prod_signs(arr:\
    \ [Int]) -> Int? {\n    guard arr.count > 0 else {\n        return nil\n    }\n\
    \    let signs = arr.map {\n        $0 == 0 ? 0 : $0 > 0 ? 1 : -1\n    }\n   \
    \ let mags = arr.map {\n        abs($0)\n    }\n    let signProd = signs.reduce(1,\
    \ *)\n    let sumMags = mags.reduce(0, +)\n    return signProd * sumMags\n}\n\n\
    \nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(prod_signs(arr: [1, 2, 2, -4]) == -9)\nassert(prod_signs(arr:\
    \ [0, 1]) == 0)\nassert(prod_signs(arr: [1, 1, 1, 2, 3, -1, 1]) == -10)\nassert(prod_signs(arr:\
    \ [] as [Int]) == nil)\nassert(prod_signs(arr: [2, 4, 1, 2, -1, -1, 9]) == 20)\n\
    assert(prod_signs(arr: [-1, 1, -1, 1]) == 4)\nassert(prod_signs(arr: [-1, 1, 1,\
    \ 1]) == -4)\nassert(prod_signs(arr: [-1, 1, 1, 0]) == 0)"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659979792
- exit_code: 1
  program: "\n/// You are given an array arr of integers and you need to return\n\
    /// sum of magnitudes of integers multiplied by product of all signs\n/// of each\
    \ number in the array, represented by 1, -1 or 0.\n/// Note: return nil for empty\
    \ arr.\n/// Example:\n/// >>> prod_signs(arr: [1, 2, 2, -4])\n/// 9\n/// >>> prod_signs(arr:\
    \ [0, 1])\n/// 0\n/// >>> prod_signs(arr: [] as [Int])\n/// nil\nfunc prod_signs(arr:\
    \ [Int]) -> Int? {\n    let productOfSigns = (arr.filter { $0 != 0 }).reduce(1)\
    \ { $0 * signOf(number: $1) }\n    let sumOfMagnitudes = arr.reduce(0) { $0 +\
    \ magnitudeOf(number: $1) }\n    return arr.isEmpty ? nil : productOfSigns * sumOfMagnitudes\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(prod_signs(arr: [1, 2, 2, -4]) == -9)\nassert(prod_signs(arr:\
    \ [0, 1]) == 0)\nassert(prod_signs(arr: [1, 1, 1, 2, 3, -1, 1]) == -10)\nassert(prod_signs(arr:\
    \ [] as [Int]) == nil)\nassert(prod_signs(arr: [2, 4, 1, 2, -1, -1, 9]) == 20)\n\
    assert(prod_signs(arr: [-1, 1, -1, 1]) == 4)\nassert(prod_signs(arr: [-1, 1, 1,\
    \ 1]) == -4)\nassert(prod_signs(arr: [-1, 1, 1, 0]) == 0)"
  status: SyntaxError
  stderr: "/tmp/tmp0f0ics6f.swift:14:68: error: cannot find 'signOf' in scope\n  \
    \  let productOfSigns = (arr.filter { $0 != 0 }).reduce(1) { $0 * signOf(number:\
    \ $1) }\n                                                                   ^~~~~~\n\
    /tmp/tmp0f0ics6f.swift:15:48: error: cannot find 'magnitudeOf' in scope\n    let\
    \ sumOfMagnitudes = arr.reduce(0) { $0 + magnitudeOf(number: $1) }\n         \
    \                                      ^~~~~~~~~~~\n/tmp/tmp0f0ics6f.swift:16:24:\
    \ error: cannot convert return expression of type 'Duration' to return type 'Int?'\n\
    \    return arr.isEmpty ? nil : productOfSigns * sumOfMagnitudes\n           ~~~~~~~~~~~~^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n"
  stdout: ''
  timestamp: 1659979791
- exit_code: 1
  program: "\n/// You are given an array arr of integers and you need to return\n\
    /// sum of magnitudes of integers multiplied by product of all signs\n/// of each\
    \ number in the array, represented by 1, -1 or 0.\n/// Note: return nil for empty\
    \ arr.\n/// Example:\n/// >>> prod_signs(arr: [1, 2, 2, -4])\n/// 9\n/// >>> prod_signs(arr:\
    \ [0, 1])\n/// 0\n/// >>> prod_signs(arr: [] as [Int])\n/// nil\nfunc prod_signs(arr:\
    \ [Int]) -> Int? {\n    if arr.isEmpty {\n        return nil\n    }\n    return\
    \ arr.reduce(into: (signs: [1], magnitudes: 0)) { (res, num) in\n        res.signs.append(num.signum())\n\
    \        res.magnitudes += abs(num)\n    }.signs.reduce(1, *) * res.magnitudes\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(prod_signs(arr: [1, 2, 2, -4]) == -9)\nassert(prod_signs(arr:\
    \ [0, 1]) == 0)\nassert(prod_signs(arr: [1, 1, 1, 2, 3, -1, 1]) == -10)\nassert(prod_signs(arr:\
    \ [] as [Int]) == nil)\nassert(prod_signs(arr: [2, 4, 1, 2, -1, -1, 9]) == 20)\n\
    assert(prod_signs(arr: [-1, 1, -1, 1]) == 4)\nassert(prod_signs(arr: [-1, 1, 1,\
    \ 1]) == -4)\nassert(prod_signs(arr: [-1, 1, 1, 0]) == 0)"
  status: SyntaxError
  stderr: "/tmp/tmp7ns5r5fx.swift:20:28: error: cannot find 'res' in scope\n    }.signs.reduce(1,\
    \ *) * res.magnitudes\n                           ^~~\n"
  stdout: ''
  timestamp: 1659979792
- exit_code: 0
  program: "\n/// You are given an array arr of integers and you need to return\n\
    /// sum of magnitudes of integers multiplied by product of all signs\n/// of each\
    \ number in the array, represented by 1, -1 or 0.\n/// Note: return nil for empty\
    \ arr.\n/// Example:\n/// >>> prod_signs(arr: [1, 2, 2, -4])\n/// 9\n/// >>> prod_signs(arr:\
    \ [0, 1])\n/// 0\n/// >>> prod_signs(arr: [] as [Int])\n/// nil\nfunc prod_signs(arr:\
    \ [Int]) -> Int? {\n    guard arr.count > 0 else { return nil }\n    var prod\
    \ = 1\n    var sum = 0\n    for number in arr {\n        prod *= number > 0 ?\
    \ 1 : number < 0 ? -1 : 0\n        sum += abs(number)\n    }\n    return prod\
    \ * sum\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n \
    \   if left.count != right.count {\n        return false\n    }\n    for (l, r)\
    \ in zip(left, right) {\n        if l != r {\n            return false\n     \
    \   }\n    }\n    return true\n}\n            \nassert(prod_signs(arr: [1, 2,\
    \ 2, -4]) == -9)\nassert(prod_signs(arr: [0, 1]) == 0)\nassert(prod_signs(arr:\
    \ [1, 1, 1, 2, 3, -1, 1]) == -10)\nassert(prod_signs(arr: [] as [Int]) == nil)\n\
    assert(prod_signs(arr: [2, 4, 1, 2, -1, -1, 9]) == 20)\nassert(prod_signs(arr:\
    \ [-1, 1, -1, 1]) == 4)\nassert(prod_signs(arr: [-1, 1, 1, 1]) == -4)\nassert(prod_signs(arr:\
    \ [-1, 1, 1, 0]) == 0)"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659979792
- exit_code: 1
  program: "\n/// You are given an array arr of integers and you need to return\n\
    /// sum of magnitudes of integers multiplied by product of all signs\n/// of each\
    \ number in the array, represented by 1, -1 or 0.\n/// Note: return nil for empty\
    \ arr.\n/// Example:\n/// >>> prod_signs(arr: [1, 2, 2, -4])\n/// 9\n/// >>> prod_signs(arr:\
    \ [0, 1])\n/// 0\n/// >>> prod_signs(arr: [] as [Int])\n/// nil\nfunc prod_signs(arr:\
    \ [Int]) -> Int? {\n    guard arr.count > 0 else {\n        return nil\n    }\n\
    \    var sign_prod = 1\n    var abs_sum = 0\n    for num in arr {\n        sign_prod\
    \ *= sign(of: num)\n        abs_sum += abs(num)\n    }\n    return sign_prod *\
    \ abs_sum\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n\
    \    if left.count != right.count {\n        return false\n    }\n    for (l,\
    \ r) in zip(left, right) {\n        if l != r {\n            return false\n  \
    \      }\n    }\n    return true\n}\n            \nassert(prod_signs(arr: [1,\
    \ 2, 2, -4]) == -9)\nassert(prod_signs(arr: [0, 1]) == 0)\nassert(prod_signs(arr:\
    \ [1, 1, 1, 2, 3, -1, 1]) == -10)\nassert(prod_signs(arr: [] as [Int]) == nil)\n\
    assert(prod_signs(arr: [2, 4, 1, 2, -1, -1, 9]) == 20)\nassert(prod_signs(arr:\
    \ [-1, 1, -1, 1]) == 4)\nassert(prod_signs(arr: [-1, 1, 1, 1]) == -4)\nassert(prod_signs(arr:\
    \ [-1, 1, 1, 0]) == 0)"
  status: SyntaxError
  stderr: "/tmp/tmpxewzuq95.swift:20:22: error: cannot find 'sign' in scope\n    \
    \    sign_prod *= sign(of: num)\n                     ^~~~\n"
  stdout: ''
  timestamp: 1659979791
- exit_code: -4
  program: "\n/// You are given an array arr of integers and you need to return\n\
    /// sum of magnitudes of integers multiplied by product of all signs\n/// of each\
    \ number in the array, represented by 1, -1 or 0.\n/// Note: return nil for empty\
    \ arr.\n/// Example:\n/// >>> prod_signs(arr: [1, 2, 2, -4])\n/// 9\n/// >>> prod_signs(arr:\
    \ [0, 1])\n/// 0\n/// >>> prod_signs(arr: [] as [Int])\n/// nil\nfunc prod_signs(arr:\
    \ [Int]) -> Int? {\n    guard arr.count > 0 else { return nil }\n    return arr.map\
    \ { ($0 > 0 ? 1 : -1) * abs($0) }.reduce(1, *)\n}\n\n\nfunc ==(left: [(Int, Int)],\
    \ right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n       \
    \ return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r\
    \ {\n            return false\n        }\n    }\n    return true\n}\n        \
    \    \nassert(prod_signs(arr: [1, 2, 2, -4]) == -9)\nassert(prod_signs(arr: [0,\
    \ 1]) == 0)\nassert(prod_signs(arr: [1, 1, 1, 2, 3, -1, 1]) == -10)\nassert(prod_signs(arr:\
    \ [] as [Int]) == nil)\nassert(prod_signs(arr: [2, 4, 1, 2, -1, -1, 9]) == 20)\n\
    assert(prod_signs(arr: [-1, 1, -1, 1]) == 4)\nassert(prod_signs(arr: [-1, 1, 1,\
    \ 1]) == -4)\nassert(prod_signs(arr: [-1, 1, 1, 0]) == 0)"
  status: Exception
  stderr: 'tmp7gpn0lgm/tmp7gpn0lgm.swift:31: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b56ad9e5c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b56ad6dcb6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b56ad6dc988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b56ad6db7b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmp7gpn0lgm                        0x000055f3bac78649 <unavailable> + 5705

    5    libc.so.6                          0x00002b56adbd1460 __libc_start_main +
    245

    6    tmp7gpn0lgm                        0x000055f3bac781d9 <unavailable> + 4569

    '
  stdout: ''
  timestamp: 1659979792
- exit_code: -4
  program: "\n/// You are given an array arr of integers and you need to return\n\
    /// sum of magnitudes of integers multiplied by product of all signs\n/// of each\
    \ number in the array, represented by 1, -1 or 0.\n/// Note: return nil for empty\
    \ arr.\n/// Example:\n/// >>> prod_signs(arr: [1, 2, 2, -4])\n/// 9\n/// >>> prod_signs(arr:\
    \ [0, 1])\n/// 0\n/// >>> prod_signs(arr: [] as [Int])\n/// nil\nfunc prod_signs(arr:\
    \ [Int]) -> Int? {\n    guard arr.count > 0 else { return nil }\n    return arr.map({\
    \ abs($0) }).reduce(1, *) * arr.map({ $0 == 0 ? 0 : $0 / abs($0) }).reduce(1,\
    \ *)\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if\
    \ left.count != right.count {\n        return false\n    }\n    for (l, r) in\
    \ zip(left, right) {\n        if l != r {\n            return false\n        }\n\
    \    }\n    return true\n}\n            \nassert(prod_signs(arr: [1, 2, 2, -4])\
    \ == -9)\nassert(prod_signs(arr: [0, 1]) == 0)\nassert(prod_signs(arr: [1, 1,\
    \ 1, 2, 3, -1, 1]) == -10)\nassert(prod_signs(arr: [] as [Int]) == nil)\nassert(prod_signs(arr:\
    \ [2, 4, 1, 2, -1, -1, 9]) == 20)\nassert(prod_signs(arr: [-1, 1, -1, 1]) == 4)\n\
    assert(prod_signs(arr: [-1, 1, 1, 1]) == -4)\nassert(prod_signs(arr: [-1, 1, 1,\
    \ 0]) == 0)"
  status: Exception
  stderr: 'tmpchezr0od/tmpchezr0od.swift:31: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b221e5abc80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b221e2a2b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b221e2a2988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b221e2a17b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpchezr0od                        0x0000559a2ad3e6d9 <unavailable> + 5849

    5    libc.so.6                          0x00002b221e797460 __libc_start_main +
    245

    6    tmpchezr0od                        0x0000559a2ad3e269 <unavailable> + 4713

    '
  stdout: ''
  timestamp: 1659979792
- exit_code: -4
  program: "\n/// You are given an array arr of integers and you need to return\n\
    /// sum of magnitudes of integers multiplied by product of all signs\n/// of each\
    \ number in the array, represented by 1, -1 or 0.\n/// Note: return nil for empty\
    \ arr.\n/// Example:\n/// >>> prod_signs(arr: [1, 2, 2, -4])\n/// 9\n/// >>> prod_signs(arr:\
    \ [0, 1])\n/// 0\n/// >>> prod_signs(arr: [] as [Int])\n/// nil\nfunc prod_signs(arr:\
    \ [Int]) -> Int? {\n    var prod = 1\n    var sum = 0\n    for i in arr {\n  \
    \      if i == 0 {\n            continue\n        }\n        sum += abs(i)\n \
    \       prod *= i > 0 ? 1 : -1\n    }\n    return arr.isEmpty ? nil : sum * prod\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(prod_signs(arr: [1, 2, 2, -4]) == -9)\nassert(prod_signs(arr:\
    \ [0, 1]) == 0)\nassert(prod_signs(arr: [1, 1, 1, 2, 3, -1, 1]) == -10)\nassert(prod_signs(arr:\
    \ [] as [Int]) == nil)\nassert(prod_signs(arr: [2, 4, 1, 2, -1, -1, 9]) == 20)\n\
    assert(prod_signs(arr: [-1, 1, -1, 1]) == 4)\nassert(prod_signs(arr: [-1, 1, 1,\
    \ 1]) == -4)\nassert(prod_signs(arr: [-1, 1, 1, 0]) == 0)"
  status: Exception
  stderr: 'tmpuc1r_1_e/tmpuc1r_1_e.swift:40: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b9bc4cacc80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b9bc49a3b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b9bc49a3988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b9bc49a27b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpuc1r_1_e                        0x00005602297e6815 <unavailable> + 6165

    5    libc.so.6                          0x00002b9bc4e98460 __libc_start_main +
    245

    6    tmpuc1r_1_e                        0x00005602297e6219 <unavailable> + 4633

    '
  stdout: ''
  timestamp: 1659979792
- exit_code: 0
  program: "\n/// You are given an array arr of integers and you need to return\n\
    /// sum of magnitudes of integers multiplied by product of all signs\n/// of each\
    \ number in the array, represented by 1, -1 or 0.\n/// Note: return nil for empty\
    \ arr.\n/// Example:\n/// >>> prod_signs(arr: [1, 2, 2, -4])\n/// 9\n/// >>> prod_signs(arr:\
    \ [0, 1])\n/// 0\n/// >>> prod_signs(arr: [] as [Int])\n/// nil\nfunc prod_signs(arr:\
    \ [Int]) -> Int? {\n  guard !arr.isEmpty else { return nil }\n  let magnitudes\
    \ = arr.map { abs($0) }\n  let signs = arr.map { $0 == 0 ? 0 : $0 / abs($0) }\n\
    \  let total_sign = signs.reduce(1, *)\n  let total_magnitude = magnitudes.reduce(0,\
    \ +)\n  return total_magnitude * total_sign\n}\n\n\nfunc ==(left: [(Int, Int)],\
    \ right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n       \
    \ return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r\
    \ {\n            return false\n        }\n    }\n    return true\n}\n        \
    \    \nassert(prod_signs(arr: [1, 2, 2, -4]) == -9)\nassert(prod_signs(arr: [0,\
    \ 1]) == 0)\nassert(prod_signs(arr: [1, 1, 1, 2, 3, -1, 1]) == -10)\nassert(prod_signs(arr:\
    \ [] as [Int]) == nil)\nassert(prod_signs(arr: [2, 4, 1, 2, -1, -1, 9]) == 20)\n\
    assert(prod_signs(arr: [-1, 1, -1, 1]) == 4)\nassert(prod_signs(arr: [-1, 1, 1,\
    \ 1]) == -4)\nassert(prod_signs(arr: [-1, 1, 1, 0]) == 0)"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659979792
- exit_code: -4
  program: "\n/// You are given an array arr of integers and you need to return\n\
    /// sum of magnitudes of integers multiplied by product of all signs\n/// of each\
    \ number in the array, represented by 1, -1 or 0.\n/// Note: return nil for empty\
    \ arr.\n/// Example:\n/// >>> prod_signs(arr: [1, 2, 2, -4])\n/// 9\n/// >>> prod_signs(arr:\
    \ [0, 1])\n/// 0\n/// >>> prod_signs(arr: [] as [Int])\n/// nil\nfunc prod_signs(arr:\
    \ [Int]) -> Int? {\n    var result: Int? = nil\n    var sum: Int = 0\n    var\
    \ prod: Int = 1\n    for n in arr {\n        if n != 0 {\n            sum += n\n\
    \            prod *= n < 0 ? -1 : 1\n        }\n    }\n    if sum != 0 {\n   \
    \     result = prod * sum\n    }\n    return result\n}\n\n\nfunc ==(left: [(Int,\
    \ Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n\
    \        return false\n    }\n    for (l, r) in zip(left, right) {\n        if\
    \ l != r {\n            return false\n        }\n    }\n    return true\n}\n \
    \           \nassert(prod_signs(arr: [1, 2, 2, -4]) == -9)\nassert(prod_signs(arr:\
    \ [0, 1]) == 0)\nassert(prod_signs(arr: [1, 1, 1, 2, 3, -1, 1]) == -10)\nassert(prod_signs(arr:\
    \ [] as [Int]) == nil)\nassert(prod_signs(arr: [2, 4, 1, 2, -1, -1, 9]) == 20)\n\
    assert(prod_signs(arr: [-1, 1, -1, 1]) == 4)\nassert(prod_signs(arr: [-1, 1, 1,\
    \ 1]) == -4)\nassert(prod_signs(arr: [-1, 1, 1, 0]) == 0)"
  status: Exception
  stderr: 'tmp4hhiy9ql/tmp4hhiy9ql.swift:42: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002ba0b5862c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002ba0b5559b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002ba0b5559988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002ba0b55587b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmp4hhiy9ql                        0x00005650926be549 <unavailable> + 5449

    5    libc.so.6                          0x00002ba0b5a4e460 __libc_start_main +
    245

    6    tmp4hhiy9ql                        0x00005650926be0d9 <unavailable> + 4313

    '
  stdout: ''
  timestamp: 1659979792
- exit_code: -4
  program: "\n/// You are given an array arr of integers and you need to return\n\
    /// sum of magnitudes of integers multiplied by product of all signs\n/// of each\
    \ number in the array, represented by 1, -1 or 0.\n/// Note: return nil for empty\
    \ arr.\n/// Example:\n/// >>> prod_signs(arr: [1, 2, 2, -4])\n/// 9\n/// >>> prod_signs(arr:\
    \ [0, 1])\n/// 0\n/// >>> prod_signs(arr: [] as [Int])\n/// nil\nfunc prod_signs(arr:\
    \ [Int]) -> Int? {\n    guard arr.count > 0 else { return nil }\n    var prod\
    \ = 0\n    var sum = 0\n    for num in arr {\n        prod += num == 0 ? 0 : (num\
    \ > 0 ? 1 : -1)\n        sum += abs(num)\n    }\n    return prod == 0 ? 0 : prod\
    \ * sum\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n \
    \   if left.count != right.count {\n        return false\n    }\n    for (l, r)\
    \ in zip(left, right) {\n        if l != r {\n            return false\n     \
    \   }\n    }\n    return true\n}\n            \nassert(prod_signs(arr: [1, 2,\
    \ 2, -4]) == -9)\nassert(prod_signs(arr: [0, 1]) == 0)\nassert(prod_signs(arr:\
    \ [1, 1, 1, 2, 3, -1, 1]) == -10)\nassert(prod_signs(arr: [] as [Int]) == nil)\n\
    assert(prod_signs(arr: [2, 4, 1, 2, -1, -1, 9]) == 20)\nassert(prod_signs(arr:\
    \ [-1, 1, -1, 1]) == 4)\nassert(prod_signs(arr: [-1, 1, 1, 1]) == -4)\nassert(prod_signs(arr:\
    \ [-1, 1, 1, 0]) == 0)"
  status: Exception
  stderr: 'tmpkihdsfcp/tmpkihdsfcp.swift:37: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b9c73a20c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b9c73717b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b9c73717988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b9c737167b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpkihdsfcp                        0x0000559c24a09689 <unavailable> + 5769

    5    libc.so.6                          0x00002b9c73c0c460 __libc_start_main +
    245

    6    tmpkihdsfcp                        0x0000559c24a09219 <unavailable> + 4633

    '
  stdout: ''
  timestamp: 1659979792
- exit_code: 0
  program: "\n/// You are given an array arr of integers and you need to return\n\
    /// sum of magnitudes of integers multiplied by product of all signs\n/// of each\
    \ number in the array, represented by 1, -1 or 0.\n/// Note: return nil for empty\
    \ arr.\n/// Example:\n/// >>> prod_signs(arr: [1, 2, 2, -4])\n/// 9\n/// >>> prod_signs(arr:\
    \ [0, 1])\n/// 0\n/// >>> prod_signs(arr: [] as [Int])\n/// nil\nfunc prod_signs(arr:\
    \ [Int]) -> Int? {\n    if arr.isEmpty {\n        return nil\n    }\n    var prod\
    \ = 1\n    var sum = 0\n    for item in arr {\n        let sign = item < 0 ? -1\
    \ : (item > 0 ? 1 : 0)\n        prod *= sign\n        sum += abs(item)\n    }\n\
    \    return sum * prod\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(prod_signs(arr:\
    \ [1, 2, 2, -4]) == -9)\nassert(prod_signs(arr: [0, 1]) == 0)\nassert(prod_signs(arr:\
    \ [1, 1, 1, 2, 3, -1, 1]) == -10)\nassert(prod_signs(arr: [] as [Int]) == nil)\n\
    assert(prod_signs(arr: [2, 4, 1, 2, -1, -1, 9]) == 20)\nassert(prod_signs(arr:\
    \ [-1, 1, -1, 1]) == 4)\nassert(prod_signs(arr: [-1, 1, 1, 1]) == -4)\nassert(prod_signs(arr:\
    \ [-1, 1, 1, 0]) == 0)"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659979792
- exit_code: 1
  program: "\n/// You are given an array arr of integers and you need to return\n\
    /// sum of magnitudes of integers multiplied by product of all signs\n/// of each\
    \ number in the array, represented by 1, -1 or 0.\n/// Note: return nil for empty\
    \ arr.\n/// Example:\n/// >>> prod_signs(arr: [1, 2, 2, -4])\n/// 9\n/// >>> prod_signs(arr:\
    \ [0, 1])\n/// 0\n/// >>> prod_signs(arr: [] as [Int])\n/// nil\nfunc prod_signs(arr:\
    \ [Int]) -> Int? {\n    let prod = arr.reduce(1) { $0 * $1.signum() }\n    return\
    \ arr.map { $0.magnitude }.reduce(0, +) * prod\n}\n\n\nfunc ==(left: [(Int, Int)],\
    \ right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n       \
    \ return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r\
    \ {\n            return false\n        }\n    }\n    return true\n}\n        \
    \    \nassert(prod_signs(arr: [1, 2, 2, -4]) == -9)\nassert(prod_signs(arr: [0,\
    \ 1]) == 0)\nassert(prod_signs(arr: [1, 1, 1, 2, 3, -1, 1]) == -10)\nassert(prod_signs(arr:\
    \ [] as [Int]) == nil)\nassert(prod_signs(arr: [2, 4, 1, 2, -1, -1, 9]) == 20)\n\
    assert(prod_signs(arr: [-1, 1, -1, 1]) == 4)\nassert(prod_signs(arr: [-1, 1, 1,\
    \ 1]) == -4)\nassert(prod_signs(arr: [-1, 1, 1, 0]) == 0)"
  status: SyntaxError
  stderr: "/tmp/tmpta_9q2zd.swift:15:25: error: cannot convert value of type 'UInt'\
    \ to closure result type 'Int'\n    return arr.map { $0.magnitude }.reduce(0,\
    \ +) * prod\n                     ~~~^~~~~~~~~\n                     Int(    \
    \    )\n"
  stdout: ''
  timestamp: 1659979792
- exit_code: -4
  program: "\n/// You are given an array arr of integers and you need to return\n\
    /// sum of magnitudes of integers multiplied by product of all signs\n/// of each\
    \ number in the array, represented by 1, -1 or 0.\n/// Note: return nil for empty\
    \ arr.\n/// Example:\n/// >>> prod_signs(arr: [1, 2, 2, -4])\n/// 9\n/// >>> prod_signs(arr:\
    \ [0, 1])\n/// 0\n/// >>> prod_signs(arr: [] as [Int])\n/// nil\nfunc prod_signs(arr:\
    \ [Int]) -> Int? {\n    if arr.isEmpty {\n        return nil\n    }\n    var sum\
    \ = 0\n    var mul = 1\n    for i in arr {\n        if i == 0 {\n            continue\n\
    \        }\n        sum += abs(i)\n        mul *= i > 0 ? 1 : -1\n    }\n    return\
    \ sum * mul\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n\
    \    if left.count != right.count {\n        return false\n    }\n    for (l,\
    \ r) in zip(left, right) {\n        if l != r {\n            return false\n  \
    \      }\n    }\n    return true\n}\n            \nassert(prod_signs(arr: [1,\
    \ 2, 2, -4]) == -9)\nassert(prod_signs(arr: [0, 1]) == 0)\nassert(prod_signs(arr:\
    \ [1, 1, 1, 2, 3, -1, 1]) == -10)\nassert(prod_signs(arr: [] as [Int]) == nil)\n\
    assert(prod_signs(arr: [2, 4, 1, 2, -1, -1, 9]) == 20)\nassert(prod_signs(arr:\
    \ [-1, 1, -1, 1]) == 4)\nassert(prod_signs(arr: [-1, 1, 1, 1]) == -4)\nassert(prod_signs(arr:\
    \ [-1, 1, 1, 0]) == 0)"
  status: Exception
  stderr: 'tmphq517r3n/tmphq517r3n.swift:43: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b38dc8e1c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b38dc5d8b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b38dc5d8988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b38dc5d77b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmphq517r3n                        0x0000555ea4195815 <unavailable> + 6165

    5    libc.so.6                          0x00002b38dcacd460 __libc_start_main +
    245

    6    tmphq517r3n                        0x0000555ea4195219 <unavailable> + 4633

    '
  stdout: ''
  timestamp: 1659979792
- exit_code: 0
  program: "\n/// You are given an array arr of integers and you need to return\n\
    /// sum of magnitudes of integers multiplied by product of all signs\n/// of each\
    \ number in the array, represented by 1, -1 or 0.\n/// Note: return nil for empty\
    \ arr.\n/// Example:\n/// >>> prod_signs(arr: [1, 2, 2, -4])\n/// 9\n/// >>> prod_signs(arr:\
    \ [0, 1])\n/// 0\n/// >>> prod_signs(arr: [] as [Int])\n/// nil\nfunc prod_signs(arr:\
    \ [Int]) -> Int? {\n\tguard !arr.isEmpty else { return nil }\n\treturn arr.map\
    \ { $0 > 0 ? 1 : $0 < 0 ? -1 : 0 }.reduce(1, *) * arr.map { abs($0) }.reduce(0,\
    \ +)\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if\
    \ left.count != right.count {\n        return false\n    }\n    for (l, r) in\
    \ zip(left, right) {\n        if l != r {\n            return false\n        }\n\
    \    }\n    return true\n}\n            \nassert(prod_signs(arr: [1, 2, 2, -4])\
    \ == -9)\nassert(prod_signs(arr: [0, 1]) == 0)\nassert(prod_signs(arr: [1, 1,\
    \ 1, 2, 3, -1, 1]) == -10)\nassert(prod_signs(arr: [] as [Int]) == nil)\nassert(prod_signs(arr:\
    \ [2, 4, 1, 2, -1, -1, 9]) == 20)\nassert(prod_signs(arr: [-1, 1, -1, 1]) == 4)\n\
    assert(prod_signs(arr: [-1, 1, 1, 1]) == -4)\nassert(prod_signs(arr: [-1, 1, 1,\
    \ 0]) == 0)"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659979792
- exit_code: -4
  program: "\n/// You are given an array arr of integers and you need to return\n\
    /// sum of magnitudes of integers multiplied by product of all signs\n/// of each\
    \ number in the array, represented by 1, -1 or 0.\n/// Note: return nil for empty\
    \ arr.\n/// Example:\n/// >>> prod_signs(arr: [1, 2, 2, -4])\n/// 9\n/// >>> prod_signs(arr:\
    \ [0, 1])\n/// 0\n/// >>> prod_signs(arr: [] as [Int])\n/// nil\nfunc prod_signs(arr:\
    \ [Int]) -> Int? {\n  return nil\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int,\
    \ Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n\
    \    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n          \
    \  return false\n        }\n    }\n    return true\n}\n            \nassert(prod_signs(arr:\
    \ [1, 2, 2, -4]) == -9)\nassert(prod_signs(arr: [0, 1]) == 0)\nassert(prod_signs(arr:\
    \ [1, 1, 1, 2, 3, -1, 1]) == -10)\nassert(prod_signs(arr: [] as [Int]) == nil)\n\
    assert(prod_signs(arr: [2, 4, 1, 2, -1, -1, 9]) == 20)\nassert(prod_signs(arr:\
    \ [-1, 1, -1, 1]) == 4)\nassert(prod_signs(arr: [-1, 1, 1, 1]) == -4)\nassert(prod_signs(arr:\
    \ [-1, 1, 1, 0]) == 0)"
  status: Exception
  stderr: 'tmpy4xc0hy9/tmpy4xc0hy9.swift:30: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b84f78ddc80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b84f75d4b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b84f75d4988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b84f75d37b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpy4xc0hy9                        0x000055a66892d3d9 <unavailable> + 5081

    5    libc.so.6                          0x00002b84f7ac9460 __libc_start_main +
    245

    6    tmpy4xc0hy9                        0x000055a66892cf69 <unavailable> + 3945

    '
  stdout: ''
  timestamp: 1659979792
- exit_code: 0
  program: "\n/// You are given an array arr of integers and you need to return\n\
    /// sum of magnitudes of integers multiplied by product of all signs\n/// of each\
    \ number in the array, represented by 1, -1 or 0.\n/// Note: return nil for empty\
    \ arr.\n/// Example:\n/// >>> prod_signs(arr: [1, 2, 2, -4])\n/// 9\n/// >>> prod_signs(arr:\
    \ [0, 1])\n/// 0\n/// >>> prod_signs(arr: [] as [Int])\n/// nil\nfunc prod_signs(arr:\
    \ [Int]) -> Int? {\n    guard arr.count > 0 else { return nil }\n    let signs\
    \ = arr.map { $0 == 0 ? 0 : ($0 > 0 ? 1 : -1) }\n    let nums = arr.map { $0 ==\
    \ 0 ? 0 : abs($0) }\n    return signs.reduce(1, *) * nums.reduce(0, +)\n}\n\n\n\
    func ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(prod_signs(arr: [1, 2, 2, -4]) == -9)\nassert(prod_signs(arr:\
    \ [0, 1]) == 0)\nassert(prod_signs(arr: [1, 1, 1, 2, 3, -1, 1]) == -10)\nassert(prod_signs(arr:\
    \ [] as [Int]) == nil)\nassert(prod_signs(arr: [2, 4, 1, 2, -1, -1, 9]) == 20)\n\
    assert(prod_signs(arr: [-1, 1, -1, 1]) == 4)\nassert(prod_signs(arr: [-1, 1, 1,\
    \ 1]) == -4)\nassert(prod_signs(arr: [-1, 1, 1, 0]) == 0)"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659979792
- exit_code: -4
  program: "\n/// You are given an array arr of integers and you need to return\n\
    /// sum of magnitudes of integers multiplied by product of all signs\n/// of each\
    \ number in the array, represented by 1, -1 or 0.\n/// Note: return nil for empty\
    \ arr.\n/// Example:\n/// >>> prod_signs(arr: [1, 2, 2, -4])\n/// 9\n/// >>> prod_signs(arr:\
    \ [0, 1])\n/// 0\n/// >>> prod_signs(arr: [] as [Int])\n/// nil\nfunc prod_signs(arr:\
    \ [Int]) -> Int? {\n    guard arr.count > 0 else {\n        return nil\n    }\n\
    \    return arr.map{ abs($0) }.reduce(1, { $0 * $1 }) * arr.map{ $0 > 0 ? 1 :\
    \ ($0 < 0 ? -1 : 0) }.reduce(1, { $0 * $1 })\n}\n\n\nfunc ==(left: [(Int, Int)],\
    \ right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n       \
    \ return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r\
    \ {\n            return false\n        }\n    }\n    return true\n}\n        \
    \    \nassert(prod_signs(arr: [1, 2, 2, -4]) == -9)\nassert(prod_signs(arr: [0,\
    \ 1]) == 0)\nassert(prod_signs(arr: [1, 1, 1, 2, 3, -1, 1]) == -10)\nassert(prod_signs(arr:\
    \ [] as [Int]) == nil)\nassert(prod_signs(arr: [2, 4, 1, 2, -1, -1, 9]) == 20)\n\
    assert(prod_signs(arr: [-1, 1, -1, 1]) == 4)\nassert(prod_signs(arr: [-1, 1, 1,\
    \ 1]) == -4)\nassert(prod_signs(arr: [-1, 1, 1, 0]) == 0)"
  status: Exception
  stderr: 'tmpn69v8ydx/tmpn69v8ydx.swift:33: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b3bb46f6c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b3bb43edb6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b3bb43ed988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b3bb43ec7b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpn69v8ydx                        0x000055b88cb77649 <unavailable> + 5705

    5    libc.so.6                          0x00002b3bb48e2460 __libc_start_main +
    245

    6    tmpn69v8ydx                        0x000055b88cb771d9 <unavailable> + 4569

    '
  stdout: ''
  timestamp: 1659979792
- exit_code: 1
  program: "\n/// You are given an array arr of integers and you need to return\n\
    /// sum of magnitudes of integers multiplied by product of all signs\n/// of each\
    \ number in the array, represented by 1, -1 or 0.\n/// Note: return nil for empty\
    \ arr.\n/// Example:\n/// >>> prod_signs(arr: [1, 2, 2, -4])\n/// 9\n/// >>> prod_signs(arr:\
    \ [0, 1])\n/// 0\n/// >>> prod_signs(arr: [] as [Int])\n/// nil\nfunc prod_signs(arr:\
    \ [Int]) -> Int? {\n    if arr.isEmpty {\n        return nil\n    }\n    let result\
    \ = arr.reduce(1) { (prev, next) -> Int in\n        return prev * next\n    }\n\
    \    return result.magnitude\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int,\
    \ Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n\
    \    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n          \
    \  return false\n        }\n    }\n    return true\n}\n            \nassert(prod_signs(arr:\
    \ [1, 2, 2, -4]) == -9)\nassert(prod_signs(arr: [0, 1]) == 0)\nassert(prod_signs(arr:\
    \ [1, 1, 1, 2, 3, -1, 1]) == -10)\nassert(prod_signs(arr: [] as [Int]) == nil)\n\
    assert(prod_signs(arr: [2, 4, 1, 2, -1, -1, 9]) == 20)\nassert(prod_signs(arr:\
    \ [-1, 1, -1, 1]) == 4)\nassert(prod_signs(arr: [-1, 1, 1, 1]) == -4)\nassert(prod_signs(arr:\
    \ [-1, 1, 1, 0]) == 0)"
  status: SyntaxError
  stderr: "/tmp/tmpanft_vbl.swift:20:19: error: cannot convert return expression of\
    \ type 'UInt' to return type 'Int?'\n    return result.magnitude\n           ~~~~~~~^~~~~~~~~\n"
  stdout: ''
  timestamp: 1659979792
- exit_code: 0
  program: "\n/// You are given an array arr of integers and you need to return\n\
    /// sum of magnitudes of integers multiplied by product of all signs\n/// of each\
    \ number in the array, represented by 1, -1 or 0.\n/// Note: return nil for empty\
    \ arr.\n/// Example:\n/// >>> prod_signs(arr: [1, 2, 2, -4])\n/// 9\n/// >>> prod_signs(arr:\
    \ [0, 1])\n/// 0\n/// >>> prod_signs(arr: [] as [Int])\n/// nil\nfunc prod_signs(arr:\
    \ [Int]) -> Int? {\n    if arr.isEmpty {\n        return nil\n    }\n    let sum\
    \ = arr.map { abs($0) }.reduce(0, +)\n    let prod = arr.map {\n        if $0\
    \ > 0 {\n            return 1\n        } else if $0 < 0 {\n            return\
    \ -1\n        } else {\n            return 0\n        }\n    }.reduce(1, *)\n\
    \    return sum * prod\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(prod_signs(arr:\
    \ [1, 2, 2, -4]) == -9)\nassert(prod_signs(arr: [0, 1]) == 0)\nassert(prod_signs(arr:\
    \ [1, 1, 1, 2, 3, -1, 1]) == -10)\nassert(prod_signs(arr: [] as [Int]) == nil)\n\
    assert(prod_signs(arr: [2, 4, 1, 2, -1, -1, 9]) == 20)\nassert(prod_signs(arr:\
    \ [-1, 1, -1, 1]) == 4)\nassert(prod_signs(arr: [-1, 1, 1, 1]) == -4)\nassert(prod_signs(arr:\
    \ [-1, 1, 1, 0]) == 0)"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659979792
- exit_code: 0
  program: "\n/// You are given an array arr of integers and you need to return\n\
    /// sum of magnitudes of integers multiplied by product of all signs\n/// of each\
    \ number in the array, represented by 1, -1 or 0.\n/// Note: return nil for empty\
    \ arr.\n/// Example:\n/// >>> prod_signs(arr: [1, 2, 2, -4])\n/// 9\n/// >>> prod_signs(arr:\
    \ [0, 1])\n/// 0\n/// >>> prod_signs(arr: [] as [Int])\n/// nil\nfunc prod_signs(arr:\
    \ [Int]) -> Int? {\n    if arr.isEmpty {\n        return nil\n    } else {\n \
    \       let signs = arr.map { x in (x == 0) ? 0 : (x > 0) ? 1 : -1 }\n       \
    \ let mags = arr.map { abs($0) }\n        return (signs.reduce(1, *)) * (mags.reduce(0,\
    \ +))\n    }\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool\
    \ {\n    if left.count != right.count {\n        return false\n    }\n    for\
    \ (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(prod_signs(arr: [1,\
    \ 2, 2, -4]) == -9)\nassert(prod_signs(arr: [0, 1]) == 0)\nassert(prod_signs(arr:\
    \ [1, 1, 1, 2, 3, -1, 1]) == -10)\nassert(prod_signs(arr: [] as [Int]) == nil)\n\
    assert(prod_signs(arr: [2, 4, 1, 2, -1, -1, 9]) == 20)\nassert(prod_signs(arr:\
    \ [-1, 1, -1, 1]) == 4)\nassert(prod_signs(arr: [-1, 1, 1, 1]) == -4)\nassert(prod_signs(arr:\
    \ [-1, 1, 1, 0]) == 0)"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659979792
- exit_code: 0
  program: "\n/// You are given an array arr of integers and you need to return\n\
    /// sum of magnitudes of integers multiplied by product of all signs\n/// of each\
    \ number in the array, represented by 1, -1 or 0.\n/// Note: return nil for empty\
    \ arr.\n/// Example:\n/// >>> prod_signs(arr: [1, 2, 2, -4])\n/// 9\n/// >>> prod_signs(arr:\
    \ [0, 1])\n/// 0\n/// >>> prod_signs(arr: [] as [Int])\n/// nil\nfunc prod_signs(arr:\
    \ [Int]) -> Int? {\n    guard arr.count > 0 else { return nil }\n    let sign\
    \ = arr.map { $0 > 0 ? 1 : $0 < 0 ? -1 : 0 }\n    let mag = arr.map { abs($0)\
    \ }\n    return sign.reduce(1, *) * mag.reduce(0, +)\n}\n\n\nfunc ==(left: [(Int,\
    \ Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n\
    \        return false\n    }\n    for (l, r) in zip(left, right) {\n        if\
    \ l != r {\n            return false\n        }\n    }\n    return true\n}\n \
    \           \nassert(prod_signs(arr: [1, 2, 2, -4]) == -9)\nassert(prod_signs(arr:\
    \ [0, 1]) == 0)\nassert(prod_signs(arr: [1, 1, 1, 2, 3, -1, 1]) == -10)\nassert(prod_signs(arr:\
    \ [] as [Int]) == nil)\nassert(prod_signs(arr: [2, 4, 1, 2, -1, -1, 9]) == 20)\n\
    assert(prod_signs(arr: [-1, 1, -1, 1]) == 4)\nassert(prod_signs(arr: [-1, 1, 1,\
    \ 1]) == -4)\nassert(prod_signs(arr: [-1, 1, 1, 0]) == 0)"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659979792
- exit_code: -4
  program: "\n/// You are given an array arr of integers and you need to return\n\
    /// sum of magnitudes of integers multiplied by product of all signs\n/// of each\
    \ number in the array, represented by 1, -1 or 0.\n/// Note: return nil for empty\
    \ arr.\n/// Example:\n/// >>> prod_signs(arr: [1, 2, 2, -4])\n/// 9\n/// >>> prod_signs(arr:\
    \ [0, 1])\n/// 0\n/// >>> prod_signs(arr: [] as [Int])\n/// nil\nfunc prod_signs(arr:\
    \ [Int]) -> Int? {\n    return nil\n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(prod_signs(arr: [1, 2, 2, -4]) == -9)\nassert(prod_signs(arr: [0, 1]) ==\
    \ 0)\nassert(prod_signs(arr: [1, 1, 1, 2, 3, -1, 1]) == -10)\nassert(prod_signs(arr:\
    \ [] as [Int]) == nil)\nassert(prod_signs(arr: [2, 4, 1, 2, -1, -1, 9]) == 20)\n\
    assert(prod_signs(arr: [-1, 1, -1, 1]) == 4)\nassert(prod_signs(arr: [-1, 1, 1,\
    \ 1]) == -4)\nassert(prod_signs(arr: [-1, 1, 1, 0]) == 0)"
  status: Exception
  stderr: 'tmp1rt4wv_3/tmp1rt4wv_3.swift:30: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b2a15132c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b2a14e29b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b2a14e29988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b2a14e287b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmp1rt4wv_3                        0x00005652a02c73d9 <unavailable> + 5081

    5    libc.so.6                          0x00002b2a1531e460 __libc_start_main +
    245

    6    tmp1rt4wv_3                        0x00005652a02c6f69 <unavailable> + 3945

    '
  stdout: ''
  timestamp: 1659979791
- exit_code: 0
  program: "\n/// You are given an array arr of integers and you need to return\n\
    /// sum of magnitudes of integers multiplied by product of all signs\n/// of each\
    \ number in the array, represented by 1, -1 or 0.\n/// Note: return nil for empty\
    \ arr.\n/// Example:\n/// >>> prod_signs(arr: [1, 2, 2, -4])\n/// 9\n/// >>> prod_signs(arr:\
    \ [0, 1])\n/// 0\n/// >>> prod_signs(arr: [] as [Int])\n/// nil\nfunc prod_signs(arr:\
    \ [Int]) -> Int? {\n    if arr.isEmpty {\n        return nil\n    }\n    let signs:\
    \ [Int] = arr.map {\n        if $0 == 0 {\n            return 0\n        } else\
    \ if $0 > 0 {\n            return 1\n        } else {\n            return -1\n\
    \        }\n    }\n    let signProduct = signs.reduce(1, *)\n    let mags = arr.map\
    \ { abs($0) }\n    let magSum = mags.reduce(0, +)\n    return magSum * signProduct\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(prod_signs(arr: [1, 2, 2, -4]) == -9)\nassert(prod_signs(arr:\
    \ [0, 1]) == 0)\nassert(prod_signs(arr: [1, 1, 1, 2, 3, -1, 1]) == -10)\nassert(prod_signs(arr:\
    \ [] as [Int]) == nil)\nassert(prod_signs(arr: [2, 4, 1, 2, -1, -1, 9]) == 20)\n\
    assert(prod_signs(arr: [-1, 1, -1, 1]) == 4)\nassert(prod_signs(arr: [-1, 1, 1,\
    \ 1]) == -4)\nassert(prod_signs(arr: [-1, 1, 1, 0]) == 0)"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659979792
- exit_code: -4
  program: "\n/// You are given an array arr of integers and you need to return\n\
    /// sum of magnitudes of integers multiplied by product of all signs\n/// of each\
    \ number in the array, represented by 1, -1 or 0.\n/// Note: return nil for empty\
    \ arr.\n/// Example:\n/// >>> prod_signs(arr: [1, 2, 2, -4])\n/// 9\n/// >>> prod_signs(arr:\
    \ [0, 1])\n/// 0\n/// >>> prod_signs(arr: [] as [Int])\n/// nil\nfunc prod_signs(arr:\
    \ [Int]) -> Int? {\n    if arr.isEmpty {\n        return nil\n    }\n    return\
    \ arr.reduce(into: 0) { $0 += $1 < 0 ? -1 : ($1 > 0 ? 1 : 0) } *\n        arr.reduce(into:\
    \ 1) { $0 *= $1 < 0 ? -$1 : $1 }\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int,\
    \ Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n\
    \    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n          \
    \  return false\n        }\n    }\n    return true\n}\n            \nassert(prod_signs(arr:\
    \ [1, 2, 2, -4]) == -9)\nassert(prod_signs(arr: [0, 1]) == 0)\nassert(prod_signs(arr:\
    \ [1, 1, 1, 2, 3, -1, 1]) == -10)\nassert(prod_signs(arr: [] as [Int]) == nil)\n\
    assert(prod_signs(arr: [2, 4, 1, 2, -1, -1, 9]) == 20)\nassert(prod_signs(arr:\
    \ [-1, 1, -1, 1]) == 4)\nassert(prod_signs(arr: [-1, 1, 1, 1]) == -4)\nassert(prod_signs(arr:\
    \ [-1, 1, 1, 0]) == 0)"
  status: Exception
  stderr: 'tmptdnma8pg/tmptdnma8pg.swift:34: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b8085af3c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b80857eab6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b80857ea988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b80857e97b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmptdnma8pg                        0x000055b9a5de14e9 <unavailable> + 5353

    5    libc.so.6                          0x00002b8085cdf460 __libc_start_main +
    245

    6    tmptdnma8pg                        0x000055b9a5de1079 <unavailable> + 4217

    '
  stdout: ''
  timestamp: 1659979792
- exit_code: 0
  program: "\n/// You are given an array arr of integers and you need to return\n\
    /// sum of magnitudes of integers multiplied by product of all signs\n/// of each\
    \ number in the array, represented by 1, -1 or 0.\n/// Note: return nil for empty\
    \ arr.\n/// Example:\n/// >>> prod_signs(arr: [1, 2, 2, -4])\n/// 9\n/// >>> prod_signs(arr:\
    \ [0, 1])\n/// 0\n/// >>> prod_signs(arr: [] as [Int])\n/// nil\nfunc prod_signs(arr:\
    \ [Int]) -> Int? {\n    guard arr.count > 0 else {\n        return nil\n    }\n\
    \    var multi = 1\n    var sum = 0\n    for i in arr {\n        if i > 0 {\n\
    \            multi *= 1\n        } else if i < 0 {\n            multi *= -1\n\
    \        } else {\n            multi *= 0\n        }\n        sum += abs(i)\n\
    \    }\n    return sum * multi\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int,\
    \ Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n\
    \    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n          \
    \  return false\n        }\n    }\n    return true\n}\n            \nassert(prod_signs(arr:\
    \ [1, 2, 2, -4]) == -9)\nassert(prod_signs(arr: [0, 1]) == 0)\nassert(prod_signs(arr:\
    \ [1, 1, 1, 2, 3, -1, 1]) == -10)\nassert(prod_signs(arr: [] as [Int]) == nil)\n\
    assert(prod_signs(arr: [2, 4, 1, 2, -1, -1, 9]) == 20)\nassert(prod_signs(arr:\
    \ [-1, 1, -1, 1]) == 4)\nassert(prod_signs(arr: [-1, 1, 1, 1]) == -4)\nassert(prod_signs(arr:\
    \ [-1, 1, 1, 0]) == 0)"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659979792
- exit_code: -4
  program: "\n/// You are given an array arr of integers and you need to return\n\
    /// sum of magnitudes of integers multiplied by product of all signs\n/// of each\
    \ number in the array, represented by 1, -1 or 0.\n/// Note: return nil for empty\
    \ arr.\n/// Example:\n/// >>> prod_signs(arr: [1, 2, 2, -4])\n/// 9\n/// >>> prod_signs(arr:\
    \ [0, 1])\n/// 0\n/// >>> prod_signs(arr: [] as [Int])\n/// nil\nfunc prod_signs(arr:\
    \ [Int]) -> Int? {\n    return arr.isEmpty ? nil : arr.map { abs($0) }.reduce(1,\
    \ *) * arr.map { $0 < 0 ? -1 : $0 > 0 ? 1 : 0 }.reduce(1, *)\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(prod_signs(arr: [1, 2, 2, -4]) == -9)\nassert(prod_signs(arr:\
    \ [0, 1]) == 0)\nassert(prod_signs(arr: [1, 1, 1, 2, 3, -1, 1]) == -10)\nassert(prod_signs(arr:\
    \ [] as [Int]) == nil)\nassert(prod_signs(arr: [2, 4, 1, 2, -1, -1, 9]) == 20)\n\
    assert(prod_signs(arr: [-1, 1, -1, 1]) == 4)\nassert(prod_signs(arr: [-1, 1, 1,\
    \ 1]) == -4)\nassert(prod_signs(arr: [-1, 1, 1, 0]) == 0)"
  status: Exception
  stderr: 'tmpjslyx_zb/tmpjslyx_zb.swift:30: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b8a01ecdc80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b8a01bc4b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b8a01bc4988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b8a01bc37b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpjslyx_zb                        0x000055989ded2639 <unavailable> + 5689

    5    libc.so.6                          0x00002b8a020b9460 __libc_start_main +
    245

    6    tmpjslyx_zb                        0x000055989ded21c9 <unavailable> + 4553

    '
  stdout: ''
  timestamp: 1659979792
- exit_code: 0
  program: "\n/// You are given an array arr of integers and you need to return\n\
    /// sum of magnitudes of integers multiplied by product of all signs\n/// of each\
    \ number in the array, represented by 1, -1 or 0.\n/// Note: return nil for empty\
    \ arr.\n/// Example:\n/// >>> prod_signs(arr: [1, 2, 2, -4])\n/// 9\n/// >>> prod_signs(arr:\
    \ [0, 1])\n/// 0\n/// >>> prod_signs(arr: [] as [Int])\n/// nil\nfunc prod_signs(arr:\
    \ [Int]) -> Int? {\n    guard arr.count > 0 else {\n        return nil\n    }\n\
    \    var sum = 0\n    var prod = 1\n    for element in arr {\n        if element\
    \ == 0 {\n            prod = 0\n            break\n        }\n        else if\
    \ element > 0 {\n            sum += element\n        }\n        else {\n     \
    \       sum -= element\n            prod *= -1\n        }\n    }\n    return sum\
    \ * prod\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n\
    \    if left.count != right.count {\n        return false\n    }\n    for (l,\
    \ r) in zip(left, right) {\n        if l != r {\n            return false\n  \
    \      }\n    }\n    return true\n}\n            \nassert(prod_signs(arr: [1,\
    \ 2, 2, -4]) == -9)\nassert(prod_signs(arr: [0, 1]) == 0)\nassert(prod_signs(arr:\
    \ [1, 1, 1, 2, 3, -1, 1]) == -10)\nassert(prod_signs(arr: [] as [Int]) == nil)\n\
    assert(prod_signs(arr: [2, 4, 1, 2, -1, -1, 9]) == 20)\nassert(prod_signs(arr:\
    \ [-1, 1, -1, 1]) == 4)\nassert(prod_signs(arr: [-1, 1, 1, 1]) == -4)\nassert(prod_signs(arr:\
    \ [-1, 1, 1, 0]) == 0)"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659979792
- exit_code: -4
  program: "\n/// You are given an array arr of integers and you need to return\n\
    /// sum of magnitudes of integers multiplied by product of all signs\n/// of each\
    \ number in the array, represented by 1, -1 or 0.\n/// Note: return nil for empty\
    \ arr.\n/// Example:\n/// >>> prod_signs(arr: [1, 2, 2, -4])\n/// 9\n/// >>> prod_signs(arr:\
    \ [0, 1])\n/// 0\n/// >>> prod_signs(arr: [] as [Int])\n/// nil\nfunc prod_signs(arr:\
    \ [Int]) -> Int? {\n    guard arr.count > 0 else { return nil }\n    var _arr\
    \ = arr\n    var prod = _arr.removeFirst()\n    for idx in 0..<_arr.count {\n\
    \        prod *= _arr[idx] > 0 ? 1 : -1\n    }\n    return arr.reduce(0, { $0\
    \ + abs($1) }) * prod\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(prod_signs(arr:\
    \ [1, 2, 2, -4]) == -9)\nassert(prod_signs(arr: [0, 1]) == 0)\nassert(prod_signs(arr:\
    \ [1, 1, 1, 2, 3, -1, 1]) == -10)\nassert(prod_signs(arr: [] as [Int]) == nil)\n\
    assert(prod_signs(arr: [2, 4, 1, 2, -1, -1, 9]) == 20)\nassert(prod_signs(arr:\
    \ [-1, 1, -1, 1]) == 4)\nassert(prod_signs(arr: [-1, 1, 1, 1]) == -4)\nassert(prod_signs(arr:\
    \ [-1, 1, 1, 0]) == 0)"
  status: Exception
  stderr: 'tmp2382yhms/tmp2382yhms.swift:40: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b6598440c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b6598137b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b6598137988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b65981367b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmp2382yhms                        0x0000560fd1a30e02 <unavailable> + 7682

    5    libc.so.6                          0x00002b659862c460 __libc_start_main +
    245

    6    tmp2382yhms                        0x0000560fd1a303a9 <unavailable> + 5033

    '
  stdout: ''
  timestamp: 1659979792
- exit_code: 0
  program: "\n/// You are given an array arr of integers and you need to return\n\
    /// sum of magnitudes of integers multiplied by product of all signs\n/// of each\
    \ number in the array, represented by 1, -1 or 0.\n/// Note: return nil for empty\
    \ arr.\n/// Example:\n/// >>> prod_signs(arr: [1, 2, 2, -4])\n/// 9\n/// >>> prod_signs(arr:\
    \ [0, 1])\n/// 0\n/// >>> prod_signs(arr: [] as [Int])\n/// nil\nfunc prod_signs(arr:\
    \ [Int]) -> Int? {\n    let arr_magnitudes = arr.map { $0 >= 0 ? $0 : -$0 }\n\
    \    let arr_signs = arr.map { $0 == 0 ? 0 : $0 > 0 ? 1 : -1 }\n    guard arr_magnitudes.count\
    \ > 0 else { return nil }\n    let sum_magnitudes = arr_magnitudes.reduce(0, +)\n\
    \    let prod_signs = arr_signs.reduce(1, *)\n    return sum_magnitudes * prod_signs\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(prod_signs(arr: [1, 2, 2, -4]) == -9)\nassert(prod_signs(arr:\
    \ [0, 1]) == 0)\nassert(prod_signs(arr: [1, 1, 1, 2, 3, -1, 1]) == -10)\nassert(prod_signs(arr:\
    \ [] as [Int]) == nil)\nassert(prod_signs(arr: [2, 4, 1, 2, -1, -1, 9]) == 20)\n\
    assert(prod_signs(arr: [-1, 1, -1, 1]) == 4)\nassert(prod_signs(arr: [-1, 1, 1,\
    \ 1]) == -4)\nassert(prod_signs(arr: [-1, 1, 1, 0]) == 0)"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659979792
- exit_code: -4
  program: "\n/// You are given an array arr of integers and you need to return\n\
    /// sum of magnitudes of integers multiplied by product of all signs\n/// of each\
    \ number in the array, represented by 1, -1 or 0.\n/// Note: return nil for empty\
    \ arr.\n/// Example:\n/// >>> prod_signs(arr: [1, 2, 2, -4])\n/// 9\n/// >>> prod_signs(arr:\
    \ [0, 1])\n/// 0\n/// >>> prod_signs(arr: [] as [Int])\n/// nil\nfunc prod_signs(arr:\
    \ [Int]) -> Int? {\n    if arr.isEmpty {\n        return nil\n    }\n    let product\
    \ = arr.filter {$0 != 0}.reduce(1) {$0 * ($1 / abs($1))}\n    let sum = arr.reduce(0)\
    \ {$0 + abs($1)}\n    return product * sum\n}\n\n\nfunc ==(left: [(Int, Int)],\
    \ right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n       \
    \ return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r\
    \ {\n            return false\n        }\n    }\n    return true\n}\n        \
    \    \nassert(prod_signs(arr: [1, 2, 2, -4]) == -9)\nassert(prod_signs(arr: [0,\
    \ 1]) == 0)\nassert(prod_signs(arr: [1, 1, 1, 2, 3, -1, 1]) == -10)\nassert(prod_signs(arr:\
    \ [] as [Int]) == nil)\nassert(prod_signs(arr: [2, 4, 1, 2, -1, -1, 9]) == 20)\n\
    assert(prod_signs(arr: [-1, 1, -1, 1]) == 4)\nassert(prod_signs(arr: [-1, 1, 1,\
    \ 1]) == -4)\nassert(prod_signs(arr: [-1, 1, 1, 0]) == 0)"
  status: Exception
  stderr: 'tmpyvlmetrf/tmpyvlmetrf.swift:36: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002af35ff95c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002af35fc8cb6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002af35fc8c988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002af35fc8b7b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpyvlmetrf                        0x000055a565f478b5 <unavailable> + 6325

    5    libc.so.6                          0x00002af360181460 __libc_start_main +
    245

    6    tmpyvlmetrf                        0x000055a565f472b9 <unavailable> + 4793

    '
  stdout: ''
  timestamp: 1659979792
- exit_code: 1
  program: "\n/// You are given an array arr of integers and you need to return\n\
    /// sum of magnitudes of integers multiplied by product of all signs\n/// of each\
    \ number in the array, represented by 1, -1 or 0.\n/// Note: return nil for empty\
    \ arr.\n/// Example:\n/// >>> prod_signs(arr: [1, 2, 2, -4])\n/// 9\n/// >>> prod_signs(arr:\
    \ [0, 1])\n/// 0\n/// >>> prod_signs(arr: [] as [Int])\n/// nil\nfunc prod_signs(arr:\
    \ [Int]) -> Int? {\n    var result: Int? = nil\n    if arr.count > 0 {\n     \
    \   result = 0\n        var prod: Int = 1\n        for num in arr {\n        \
    \    result! += abs(num)\n            prod *= sign_int(num: num)\n        }\n\
    \        result! *= prod\n    }\n    return result\n}\n\n\nfunc ==(left: [(Int,\
    \ Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n\
    \        return false\n    }\n    for (l, r) in zip(left, right) {\n        if\
    \ l != r {\n            return false\n        }\n    }\n    return true\n}\n \
    \           \nassert(prod_signs(arr: [1, 2, 2, -4]) == -9)\nassert(prod_signs(arr:\
    \ [0, 1]) == 0)\nassert(prod_signs(arr: [1, 1, 1, 2, 3, -1, 1]) == -10)\nassert(prod_signs(arr:\
    \ [] as [Int]) == nil)\nassert(prod_signs(arr: [2, 4, 1, 2, -1, -1, 9]) == 20)\n\
    assert(prod_signs(arr: [-1, 1, -1, 1]) == 4)\nassert(prod_signs(arr: [-1, 1, 1,\
    \ 1]) == -4)\nassert(prod_signs(arr: [-1, 1, 1, 0]) == 0)"
  status: SyntaxError
  stderr: "/tmp/tmphbhgdz24.swift:20:21: error: cannot find 'sign_int' in scope\n\
    \            prod *= sign_int(num: num)\n                    ^~~~~~~~\n"
  stdout: ''
  timestamp: 1659979792
- exit_code: -4
  program: "\n/// You are given an array arr of integers and you need to return\n\
    /// sum of magnitudes of integers multiplied by product of all signs\n/// of each\
    \ number in the array, represented by 1, -1 or 0.\n/// Note: return nil for empty\
    \ arr.\n/// Example:\n/// >>> prod_signs(arr: [1, 2, 2, -4])\n/// 9\n/// >>> prod_signs(arr:\
    \ [0, 1])\n/// 0\n/// >>> prod_signs(arr: [] as [Int])\n/// nil\nfunc prod_signs(arr:\
    \ [Int]) -> Int? {\n  guard !arr.isEmpty else { return nil }\n  var signs: Int\
    \ = 1\n  var sum: Int = 0\n  for el in arr {\n    if el == 0 {\n      continue\n\
    \    }\n    sum += abs(el)\n    signs *= el > 0 ? 1 : -1\n  }\n  return sum *\
    \ signs\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n \
    \   if left.count != right.count {\n        return false\n    }\n    for (l, r)\
    \ in zip(left, right) {\n        if l != r {\n            return false\n     \
    \   }\n    }\n    return true\n}\n            \nassert(prod_signs(arr: [1, 2,\
    \ 2, -4]) == -9)\nassert(prod_signs(arr: [0, 1]) == 0)\nassert(prod_signs(arr:\
    \ [1, 1, 1, 2, 3, -1, 1]) == -10)\nassert(prod_signs(arr: [] as [Int]) == nil)\n\
    assert(prod_signs(arr: [2, 4, 1, 2, -1, -1, 9]) == 20)\nassert(prod_signs(arr:\
    \ [-1, 1, -1, 1]) == 4)\nassert(prod_signs(arr: [-1, 1, 1, 1]) == -4)\nassert(prod_signs(arr:\
    \ [-1, 1, 1, 0]) == 0)"
  status: Exception
  stderr: 'tmp2fzgzwoy/tmp2fzgzwoy.swift:41: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002ab6f4d36c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002ab6f4a2db6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002ab6f4a2d988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002ab6f4a2c7b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmp2fzgzwoy                        0x00005649618aa815 <unavailable> + 6165

    5    libc.so.6                          0x00002ab6f4f22460 __libc_start_main +
    245

    6    tmp2fzgzwoy                        0x00005649618aa219 <unavailable> + 4633

    '
  stdout: ''
  timestamp: 1659979792
- exit_code: -4
  program: "\n/// You are given an array arr of integers and you need to return\n\
    /// sum of magnitudes of integers multiplied by product of all signs\n/// of each\
    \ number in the array, represented by 1, -1 or 0.\n/// Note: return nil for empty\
    \ arr.\n/// Example:\n/// >>> prod_signs(arr: [1, 2, 2, -4])\n/// 9\n/// >>> prod_signs(arr:\
    \ [0, 1])\n/// 0\n/// >>> prod_signs(arr: [] as [Int])\n/// nil\nfunc prod_signs(arr:\
    \ [Int]) -> Int? {\n    if arr.isEmpty {\n        return nil\n    }\n    var sum\
    \ = 0\n    for i in arr {\n        sum += abs(i)\n    }\n    var prod = 1\n  \
    \  for i in arr {\n        prod *= i >= 0 ? 1 : -1\n    }\n    return sum * prod\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(prod_signs(arr: [1, 2, 2, -4]) == -9)\nassert(prod_signs(arr:\
    \ [0, 1]) == 0)\nassert(prod_signs(arr: [1, 1, 1, 2, 3, -1, 1]) == -10)\nassert(prod_signs(arr:\
    \ [] as [Int]) == nil)\nassert(prod_signs(arr: [2, 4, 1, 2, -1, -1, 9]) == 20)\n\
    assert(prod_signs(arr: [-1, 1, -1, 1]) == 4)\nassert(prod_signs(arr: [-1, 1, 1,\
    \ 1]) == -4)\nassert(prod_signs(arr: [-1, 1, 1, 0]) == 0)"
  status: Exception
  stderr: 'tmp6kh5dvf7/tmp6kh5dvf7.swift:42: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b57b9097c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b57b8d8eb6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b57b8d8e988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b57b8d8d7b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmp6kh5dvf7                        0x00005619a6115815 <unavailable> + 6165

    5    libc.so.6                          0x00002b57b9283460 __libc_start_main +
    245

    6    tmp6kh5dvf7                        0x00005619a6115219 <unavailable> + 4633

    '
  stdout: ''
  timestamp: 1659979792
- exit_code: -4
  program: "\n/// You are given an array arr of integers and you need to return\n\
    /// sum of magnitudes of integers multiplied by product of all signs\n/// of each\
    \ number in the array, represented by 1, -1 or 0.\n/// Note: return nil for empty\
    \ arr.\n/// Example:\n/// >>> prod_signs(arr: [1, 2, 2, -4])\n/// 9\n/// >>> prod_signs(arr:\
    \ [0, 1])\n/// 0\n/// >>> prod_signs(arr: [] as [Int])\n/// nil\nfunc prod_signs(arr:\
    \ [Int]) -> Int? {\n    return nil\n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(prod_signs(arr: [1, 2, 2, -4]) == -9)\nassert(prod_signs(arr: [0, 1]) ==\
    \ 0)\nassert(prod_signs(arr: [1, 1, 1, 2, 3, -1, 1]) == -10)\nassert(prod_signs(arr:\
    \ [] as [Int]) == nil)\nassert(prod_signs(arr: [2, 4, 1, 2, -1, -1, 9]) == 20)\n\
    assert(prod_signs(arr: [-1, 1, -1, 1]) == 4)\nassert(prod_signs(arr: [-1, 1, 1,\
    \ 1]) == -4)\nassert(prod_signs(arr: [-1, 1, 1, 0]) == 0)"
  status: Exception
  stderr: 'tmp1rt4wv_3/tmp1rt4wv_3.swift:30: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b2a15132c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b2a14e29b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b2a14e29988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b2a14e287b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmp1rt4wv_3                        0x00005652a02c73d9 <unavailable> + 5081

    5    libc.so.6                          0x00002b2a1531e460 __libc_start_main +
    245

    6    tmp1rt4wv_3                        0x00005652a02c6f69 <unavailable> + 3945

    '
  stdout: ''
  timestamp: 1659979791
- exit_code: 0
  program: "\n/// You are given an array arr of integers and you need to return\n\
    /// sum of magnitudes of integers multiplied by product of all signs\n/// of each\
    \ number in the array, represented by 1, -1 or 0.\n/// Note: return nil for empty\
    \ arr.\n/// Example:\n/// >>> prod_signs(arr: [1, 2, 2, -4])\n/// 9\n/// >>> prod_signs(arr:\
    \ [0, 1])\n/// 0\n/// >>> prod_signs(arr: [] as [Int])\n/// nil\nfunc prod_signs(arr:\
    \ [Int]) -> Int? {\n    return arr.isEmpty ? nil :\n        arr.reduce(1) { $0\
    \ * $1.signum() } *\n        arr.reduce(0) { $0 + abs($1) }\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(prod_signs(arr: [1, 2, 2, -4]) == -9)\nassert(prod_signs(arr:\
    \ [0, 1]) == 0)\nassert(prod_signs(arr: [1, 1, 1, 2, 3, -1, 1]) == -10)\nassert(prod_signs(arr:\
    \ [] as [Int]) == nil)\nassert(prod_signs(arr: [2, 4, 1, 2, -1, -1, 9]) == 20)\n\
    assert(prod_signs(arr: [-1, 1, -1, 1]) == 4)\nassert(prod_signs(arr: [-1, 1, 1,\
    \ 1]) == -4)\nassert(prod_signs(arr: [-1, 1, 1, 0]) == 0)"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659979792
- exit_code: 1
  program: "\n/// You are given an array arr of integers and you need to return\n\
    /// sum of magnitudes of integers multiplied by product of all signs\n/// of each\
    \ number in the array, represented by 1, -1 or 0.\n/// Note: return nil for empty\
    \ arr.\n/// Example:\n/// >>> prod_signs(arr: [1, 2, 2, -4])\n/// 9\n/// >>> prod_signs(arr:\
    \ [0, 1])\n/// 0\n/// >>> prod_signs(arr: [] as [Int])\n/// nil\nfunc prod_signs(arr:\
    \ [Int]) -> Int? {\n    guard arr.count > 0 else { return nil }\n    var prod\
    \ = 1\n    var sum = 0\n    for n in arr {\n        prod *= sign(n)\n        sum\
    \ += abs(n)\n    }\n    return prod * sum\n}\n\n\nfunc ==(left: [(Int, Int)],\
    \ right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n       \
    \ return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r\
    \ {\n            return false\n        }\n    }\n    return true\n}\n        \
    \    \nassert(prod_signs(arr: [1, 2, 2, -4]) == -9)\nassert(prod_signs(arr: [0,\
    \ 1]) == 0)\nassert(prod_signs(arr: [1, 1, 1, 2, 3, -1, 1]) == -10)\nassert(prod_signs(arr:\
    \ [] as [Int]) == nil)\nassert(prod_signs(arr: [2, 4, 1, 2, -1, -1, 9]) == 20)\n\
    assert(prod_signs(arr: [-1, 1, -1, 1]) == 4)\nassert(prod_signs(arr: [-1, 1, 1,\
    \ 1]) == -4)\nassert(prod_signs(arr: [-1, 1, 1, 0]) == 0)"
  status: SyntaxError
  stderr: "/tmp/tmp9uur0tdk.swift:18:17: error: cannot find 'sign' in scope\n    \
    \    prod *= sign(n)\n                ^~~~\n"
  stdout: ''
  timestamp: 1659979792
- exit_code: -4
  program: "\n/// You are given an array arr of integers and you need to return\n\
    /// sum of magnitudes of integers multiplied by product of all signs\n/// of each\
    \ number in the array, represented by 1, -1 or 0.\n/// Note: return nil for empty\
    \ arr.\n/// Example:\n/// >>> prod_signs(arr: [1, 2, 2, -4])\n/// 9\n/// >>> prod_signs(arr:\
    \ [0, 1])\n/// 0\n/// >>> prod_signs(arr: [] as [Int])\n/// nil\nfunc prod_signs(arr:\
    \ [Int]) -> Int? {\n    guard arr.count > 0 else {\n        return nil\n    }\n\
    \    var product = 1\n    var result = 0\n    for i in arr {\n        if i ==\
    \ 0 {\n            continue\n        }\n        result += abs(i)\n        product\
    \ *= i / abs(i)\n    }\n    return result * product\n}\n\n\nfunc ==(left: [(Int,\
    \ Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n\
    \        return false\n    }\n    for (l, r) in zip(left, right) {\n        if\
    \ l != r {\n            return false\n        }\n    }\n    return true\n}\n \
    \           \nassert(prod_signs(arr: [1, 2, 2, -4]) == -9)\nassert(prod_signs(arr:\
    \ [0, 1]) == 0)\nassert(prod_signs(arr: [1, 1, 1, 2, 3, -1, 1]) == -10)\nassert(prod_signs(arr:\
    \ [] as [Int]) == nil)\nassert(prod_signs(arr: [2, 4, 1, 2, -1, -1, 9]) == 20)\n\
    assert(prod_signs(arr: [-1, 1, -1, 1]) == 4)\nassert(prod_signs(arr: [-1, 1, 1,\
    \ 1]) == -4)\nassert(prod_signs(arr: [-1, 1, 1, 0]) == 0)"
  status: Exception
  stderr: 'tmpm1ssd1ww/tmpm1ssd1ww.swift:43: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002ab82bb4cc80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002ab82b843b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002ab82b843988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002ab82b8427b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpm1ssd1ww                        0x0000556dce9328a5 <unavailable> + 6309

    5    libc.so.6                          0x00002ab82bd38460 __libc_start_main +
    245

    6    tmpm1ssd1ww                        0x0000556dce9322a9 <unavailable> + 4777

    '
  stdout: ''
  timestamp: 1659979792
- exit_code: 1
  program: "\n/// You are given an array arr of integers and you need to return\n\
    /// sum of magnitudes of integers multiplied by product of all signs\n/// of each\
    \ number in the array, represented by 1, -1 or 0.\n/// Note: return nil for empty\
    \ arr.\n/// Example:\n/// >>> prod_signs(arr: [1, 2, 2, -4])\n/// 9\n/// >>> prod_signs(arr:\
    \ [0, 1])\n/// 0\n/// >>> prod_signs(arr: [] as [Int])\n/// nil\nfunc prod_signs(arr:\
    \ [Int]) -> Int? {\n    guard arr.count > 0 else { return nil }\n    var sum =\
    \ 0\n    var product = 1\n    for element in arr {\n        sum += abs(element)\n\
    \        product *= signum(element)\n    }\n    return sum * product\n}\n\n\n\
    func ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(prod_signs(arr: [1, 2, 2, -4]) == -9)\nassert(prod_signs(arr:\
    \ [0, 1]) == 0)\nassert(prod_signs(arr: [1, 1, 1, 2, 3, -1, 1]) == -10)\nassert(prod_signs(arr:\
    \ [] as [Int]) == nil)\nassert(prod_signs(arr: [2, 4, 1, 2, -1, -1, 9]) == 20)\n\
    assert(prod_signs(arr: [-1, 1, -1, 1]) == 4)\nassert(prod_signs(arr: [-1, 1, 1,\
    \ 1]) == -4)\nassert(prod_signs(arr: [-1, 1, 1, 0]) == 0)"
  status: SyntaxError
  stderr: "/tmp/tmp510pwvdr.swift:19:20: error: cannot find 'signum' in scope\n  \
    \      product *= signum(element)\n                   ^~~~~~\n"
  stdout: ''
  timestamp: 1659979792
- exit_code: 0
  program: "\n/// You are given an array arr of integers and you need to return\n\
    /// sum of magnitudes of integers multiplied by product of all signs\n/// of each\
    \ number in the array, represented by 1, -1 or 0.\n/// Note: return nil for empty\
    \ arr.\n/// Example:\n/// >>> prod_signs(arr: [1, 2, 2, -4])\n/// 9\n/// >>> prod_signs(arr:\
    \ [0, 1])\n/// 0\n/// >>> prod_signs(arr: [] as [Int])\n/// nil\nfunc prod_signs(arr:\
    \ [Int]) -> Int? {\n    let empty = arr.count == 0\n    if empty {\n        return\
    \ nil\n    }\n    let signs = arr.map({\n        if $0 > 0 {\n            return\
    \ 1\n        } else if $0 < 0 {\n            return -1\n        } else {\n   \
    \         return 0\n        }\n    })\n    let sum_signs = signs.reduce(1, *)\n\
    \    let sum_magnitudes = arr.map { abs($0) }.reduce(0, +)\n    return sum_magnitudes\
    \ * sum_signs\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool\
    \ {\n    if left.count != right.count {\n        return false\n    }\n    for\
    \ (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(prod_signs(arr: [1,\
    \ 2, 2, -4]) == -9)\nassert(prod_signs(arr: [0, 1]) == 0)\nassert(prod_signs(arr:\
    \ [1, 1, 1, 2, 3, -1, 1]) == -10)\nassert(prod_signs(arr: [] as [Int]) == nil)\n\
    assert(prod_signs(arr: [2, 4, 1, 2, -1, -1, 9]) == 20)\nassert(prod_signs(arr:\
    \ [-1, 1, -1, 1]) == 4)\nassert(prod_signs(arr: [-1, 1, 1, 1]) == -4)\nassert(prod_signs(arr:\
    \ [-1, 1, 1, 0]) == 0)"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659979792
- exit_code: -4
  program: "\n/// You are given an array arr of integers and you need to return\n\
    /// sum of magnitudes of integers multiplied by product of all signs\n/// of each\
    \ number in the array, represented by 1, -1 or 0.\n/// Note: return nil for empty\
    \ arr.\n/// Example:\n/// >>> prod_signs(arr: [1, 2, 2, -4])\n/// 9\n/// >>> prod_signs(arr:\
    \ [0, 1])\n/// 0\n/// >>> prod_signs(arr: [] as [Int])\n/// nil\nfunc prod_signs(arr:\
    \ [Int]) -> Int? {\n    guard arr.count > 0 else {\n        return nil\n    }\n\
    \    var prod: Int = 1\n    var sum: Int = 0\n    for i in arr {\n        prod\
    \ *= i / abs(i)\n        sum += abs(i)\n    }\n    return sum * prod\n}\n\n\n\
    func ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(prod_signs(arr: [1, 2, 2, -4]) == -9)\nassert(prod_signs(arr:\
    \ [0, 1]) == 0)\nassert(prod_signs(arr: [1, 1, 1, 2, 3, -1, 1]) == -10)\nassert(prod_signs(arr:\
    \ [] as [Int]) == nil)\nassert(prod_signs(arr: [2, 4, 1, 2, -1, -1, 9]) == 20)\n\
    assert(prod_signs(arr: [-1, 1, -1, 1]) == 4)\nassert(prod_signs(arr: [-1, 1, 1,\
    \ 1]) == -4)\nassert(prod_signs(arr: [-1, 1, 1, 0]) == 0)"
  status: Exception
  stderr: 'Swift/IntegerTypes.swift:14137: Fatal error: Division by zero

    Current stack trace:

    0    libswiftCore.so                    0x00002b228de1cc80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b228db13561 <unavailable> + 1434977

    2    libswiftCore.so                    0x00002b228db13286 <unavailable> + 1434246

    3    libswiftCore.so                    0x00002b228db1313c <unavailable> + 1433916

    4    libswiftCore.so                    0x00002b228db12bb0 _assertionFailure(_:_:file:line:flags:)
    + 251

    5    tmp0etwjdkn                        0x0000562b85a94406 <unavailable> + 9222

    6    tmp0etwjdkn                        0x0000562b85a9375b <unavailable> + 5979

    7    libc.so.6                          0x00002b228e008460 __libc_start_main +
    245

    8    tmp0etwjdkn                        0x0000562b85a932a9 <unavailable> + 4777

    '
  stdout: ''
  timestamp: 1659979792
- exit_code: -4
  program: "\n/// You are given an array arr of integers and you need to return\n\
    /// sum of magnitudes of integers multiplied by product of all signs\n/// of each\
    \ number in the array, represented by 1, -1 or 0.\n/// Note: return nil for empty\
    \ arr.\n/// Example:\n/// >>> prod_signs(arr: [1, 2, 2, -4])\n/// 9\n/// >>> prod_signs(arr:\
    \ [0, 1])\n/// 0\n/// >>> prod_signs(arr: [] as [Int])\n/// nil\nfunc prod_signs(arr:\
    \ [Int]) -> Int? {\n    if arr.isEmpty {\n        return nil\n    }\n    var sum\
    \ = 0\n    var prod = 1\n    for val in arr {\n        prod *= val >= 0 ? 1 :\
    \ -1\n        sum += abs(val)\n    }\n    return sum * prod\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(prod_signs(arr: [1, 2, 2, -4]) == -9)\nassert(prod_signs(arr:\
    \ [0, 1]) == 0)\nassert(prod_signs(arr: [1, 1, 1, 2, 3, -1, 1]) == -10)\nassert(prod_signs(arr:\
    \ [] as [Int]) == nil)\nassert(prod_signs(arr: [2, 4, 1, 2, -1, -1, 9]) == 20)\n\
    assert(prod_signs(arr: [-1, 1, -1, 1]) == 4)\nassert(prod_signs(arr: [-1, 1, 1,\
    \ 1]) == -4)\nassert(prod_signs(arr: [-1, 1, 1, 0]) == 0)"
  status: Exception
  stderr: 'tmpo2ie8r_4/tmpo2ie8r_4.swift:40: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b484e855c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b484e54cb6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b484e54c988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b484e54b7b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpo2ie8r_4                        0x0000562bd9088815 <unavailable> + 6165

    5    libc.so.6                          0x00002b484ea41460 __libc_start_main +
    245

    6    tmpo2ie8r_4                        0x0000562bd9088219 <unavailable> + 4633

    '
  stdout: ''
  timestamp: 1659979792
- exit_code: -4
  program: "\n/// You are given an array arr of integers and you need to return\n\
    /// sum of magnitudes of integers multiplied by product of all signs\n/// of each\
    \ number in the array, represented by 1, -1 or 0.\n/// Note: return nil for empty\
    \ arr.\n/// Example:\n/// >>> prod_signs(arr: [1, 2, 2, -4])\n/// 9\n/// >>> prod_signs(arr:\
    \ [0, 1])\n/// 0\n/// >>> prod_signs(arr: [] as [Int])\n/// nil\nfunc prod_signs(arr:\
    \ [Int]) -> Int? {\n    var prod = 1\n    var sum = 0\n    for num in arr {\n\
    \        if num > 0 {\n            prod *= 1\n        } else if num < 0 {\n  \
    \          prod *= -1\n        } else {\n            prod *= 0\n        }\n  \
    \      sum += num\n    }\n    return sum * prod\n}\n\n\nfunc ==(left: [(Int, Int)],\
    \ right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n       \
    \ return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r\
    \ {\n            return false\n        }\n    }\n    return true\n}\n        \
    \    \nassert(prod_signs(arr: [1, 2, 2, -4]) == -9)\nassert(prod_signs(arr: [0,\
    \ 1]) == 0)\nassert(prod_signs(arr: [1, 1, 1, 2, 3, -1, 1]) == -10)\nassert(prod_signs(arr:\
    \ [] as [Int]) == nil)\nassert(prod_signs(arr: [2, 4, 1, 2, -1, -1, 9]) == 20)\n\
    assert(prod_signs(arr: [-1, 1, -1, 1]) == 4)\nassert(prod_signs(arr: [-1, 1, 1,\
    \ 1]) == -4)\nassert(prod_signs(arr: [-1, 1, 1, 0]) == 0)"
  status: Exception
  stderr: 'tmpqfivu1ef/tmpqfivu1ef.swift:42: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b359eeffc80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b359ebf6b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b359ebf6988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b359ebf57b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpqfivu1ef                        0x00005613d165c549 <unavailable> + 5449

    5    libc.so.6                          0x00002b359f0eb460 __libc_start_main +
    245

    6    tmpqfivu1ef                        0x00005613d165c0d9 <unavailable> + 4313

    '
  stdout: ''
  timestamp: 1659979792
- exit_code: -4
  program: "\n/// You are given an array arr of integers and you need to return\n\
    /// sum of magnitudes of integers multiplied by product of all signs\n/// of each\
    \ number in the array, represented by 1, -1 or 0.\n/// Note: return nil for empty\
    \ arr.\n/// Example:\n/// >>> prod_signs(arr: [1, 2, 2, -4])\n/// 9\n/// >>> prod_signs(arr:\
    \ [0, 1])\n/// 0\n/// >>> prod_signs(arr: [] as [Int])\n/// nil\nfunc prod_signs(arr:\
    \ [Int]) -> Int? {\n    return nil\n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(prod_signs(arr: [1, 2, 2, -4]) == -9)\nassert(prod_signs(arr: [0, 1]) ==\
    \ 0)\nassert(prod_signs(arr: [1, 1, 1, 2, 3, -1, 1]) == -10)\nassert(prod_signs(arr:\
    \ [] as [Int]) == nil)\nassert(prod_signs(arr: [2, 4, 1, 2, -1, -1, 9]) == 20)\n\
    assert(prod_signs(arr: [-1, 1, -1, 1]) == 4)\nassert(prod_signs(arr: [-1, 1, 1,\
    \ 1]) == -4)\nassert(prod_signs(arr: [-1, 1, 1, 0]) == 0)"
  status: Exception
  stderr: 'tmp1rt4wv_3/tmp1rt4wv_3.swift:30: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b2a15132c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b2a14e29b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b2a14e29988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b2a14e287b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmp1rt4wv_3                        0x00005652a02c73d9 <unavailable> + 5081

    5    libc.so.6                          0x00002b2a1531e460 __libc_start_main +
    245

    6    tmp1rt4wv_3                        0x00005652a02c6f69 <unavailable> + 3945

    '
  stdout: ''
  timestamp: 1659979791
- exit_code: -4
  program: "\n/// You are given an array arr of integers and you need to return\n\
    /// sum of magnitudes of integers multiplied by product of all signs\n/// of each\
    \ number in the array, represented by 1, -1 or 0.\n/// Note: return nil for empty\
    \ arr.\n/// Example:\n/// >>> prod_signs(arr: [1, 2, 2, -4])\n/// 9\n/// >>> prod_signs(arr:\
    \ [0, 1])\n/// 0\n/// >>> prod_signs(arr: [] as [Int])\n/// nil\nfunc prod_signs(arr:\
    \ [Int]) -> Int? {\n    if arr.isEmpty {\n        return nil\n    }\n    var sign\
    \ = 1\n    var sum = 0\n    for num in arr {\n        if num == 0 {\n        \
    \    continue\n        }\n        sign *= num > 0 ? 1 : -1\n        sum += abs(num)\n\
    \    }\n    return sum * sign\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int,\
    \ Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n\
    \    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n          \
    \  return false\n        }\n    }\n    return true\n}\n            \nassert(prod_signs(arr:\
    \ [1, 2, 2, -4]) == -9)\nassert(prod_signs(arr: [0, 1]) == 0)\nassert(prod_signs(arr:\
    \ [1, 1, 1, 2, 3, -1, 1]) == -10)\nassert(prod_signs(arr: [] as [Int]) == nil)\n\
    assert(prod_signs(arr: [2, 4, 1, 2, -1, -1, 9]) == 20)\nassert(prod_signs(arr:\
    \ [-1, 1, -1, 1]) == 4)\nassert(prod_signs(arr: [-1, 1, 1, 1]) == -4)\nassert(prod_signs(arr:\
    \ [-1, 1, 1, 0]) == 0)"
  status: Exception
  stderr: 'tmpi08uupln/tmpi08uupln.swift:43: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002ab8a6db0c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002ab8a6aa7b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002ab8a6aa7988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002ab8a6aa67b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpi08uupln                        0x0000562c408db815 <unavailable> + 6165

    5    libc.so.6                          0x00002ab8a6f9c460 __libc_start_main +
    245

    6    tmpi08uupln                        0x0000562c408db219 <unavailable> + 4633

    '
  stdout: ''
  timestamp: 1659979792
- exit_code: 0
  program: "\n/// You are given an array arr of integers and you need to return\n\
    /// sum of magnitudes of integers multiplied by product of all signs\n/// of each\
    \ number in the array, represented by 1, -1 or 0.\n/// Note: return nil for empty\
    \ arr.\n/// Example:\n/// >>> prod_signs(arr: [1, 2, 2, -4])\n/// 9\n/// >>> prod_signs(arr:\
    \ [0, 1])\n/// 0\n/// >>> prod_signs(arr: [] as [Int])\n/// nil\nfunc prod_signs(arr:\
    \ [Int]) -> Int? {\n    return arr.isEmpty ? nil : arr.map {$0.signum()}.reduce(1,\
    \ *) * arr.map {abs($0)}.reduce(0, +)\n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(prod_signs(arr: [1, 2, 2, -4]) == -9)\nassert(prod_signs(arr: [0, 1]) ==\
    \ 0)\nassert(prod_signs(arr: [1, 1, 1, 2, 3, -1, 1]) == -10)\nassert(prod_signs(arr:\
    \ [] as [Int]) == nil)\nassert(prod_signs(arr: [2, 4, 1, 2, -1, -1, 9]) == 20)\n\
    assert(prod_signs(arr: [-1, 1, -1, 1]) == 4)\nassert(prod_signs(arr: [-1, 1, 1,\
    \ 1]) == -4)\nassert(prod_signs(arr: [-1, 1, 1, 0]) == 0)"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659979792
- exit_code: 0
  program: "\n/// You are given an array arr of integers and you need to return\n\
    /// sum of magnitudes of integers multiplied by product of all signs\n/// of each\
    \ number in the array, represented by 1, -1 or 0.\n/// Note: return nil for empty\
    \ arr.\n/// Example:\n/// >>> prod_signs(arr: [1, 2, 2, -4])\n/// 9\n/// >>> prod_signs(arr:\
    \ [0, 1])\n/// 0\n/// >>> prod_signs(arr: [] as [Int])\n/// nil\nfunc prod_signs(arr:\
    \ [Int]) -> Int? {\n    guard arr.count > 0 else { return nil }\n    var sum_of_magnitudes\
    \ = 0\n    var product_of_signs = 1\n    for element in arr {\n        sum_of_magnitudes\
    \ += abs(element)\n        switch element {\n        case 1: product_of_signs\
    \ *= 1\n        case 0: product_of_signs *= 0\n        default: product_of_signs\
    \ *= -1\n        }\n    }\n    return sum_of_magnitudes * product_of_signs\n}\n\
    \n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(prod_signs(arr: [1, 2, 2, -4]) == -9)\nassert(prod_signs(arr:\
    \ [0, 1]) == 0)\nassert(prod_signs(arr: [1, 1, 1, 2, 3, -1, 1]) == -10)\nassert(prod_signs(arr:\
    \ [] as [Int]) == nil)\nassert(prod_signs(arr: [2, 4, 1, 2, -1, -1, 9]) == 20)\n\
    assert(prod_signs(arr: [-1, 1, -1, 1]) == 4)\nassert(prod_signs(arr: [-1, 1, 1,\
    \ 1]) == -4)\nassert(prod_signs(arr: [-1, 1, 1, 0]) == 0)"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659979792
- exit_code: 0
  program: "\n/// You are given an array arr of integers and you need to return\n\
    /// sum of magnitudes of integers multiplied by product of all signs\n/// of each\
    \ number in the array, represented by 1, -1 or 0.\n/// Note: return nil for empty\
    \ arr.\n/// Example:\n/// >>> prod_signs(arr: [1, 2, 2, -4])\n/// 9\n/// >>> prod_signs(arr:\
    \ [0, 1])\n/// 0\n/// >>> prod_signs(arr: [] as [Int])\n/// nil\nfunc prod_signs(arr:\
    \ [Int]) -> Int? {\n    if arr.isEmpty {\n        return nil\n    }\n    var prod\
    \ = 1\n    var sum = 0\n    for i in arr {\n        if i < 0 {\n            prod\
    \ *= -1\n        } else if i > 0 {\n            prod *= 1\n        } else {\n\
    \            prod *= 0\n        }\n        sum += abs(i)\n    }\n    return sum\
    \ * prod\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n\
    \    if left.count != right.count {\n        return false\n    }\n    for (l,\
    \ r) in zip(left, right) {\n        if l != r {\n            return false\n  \
    \      }\n    }\n    return true\n}\n            \nassert(prod_signs(arr: [1,\
    \ 2, 2, -4]) == -9)\nassert(prod_signs(arr: [0, 1]) == 0)\nassert(prod_signs(arr:\
    \ [1, 1, 1, 2, 3, -1, 1]) == -10)\nassert(prod_signs(arr: [] as [Int]) == nil)\n\
    assert(prod_signs(arr: [2, 4, 1, 2, -1, -1, 9]) == 20)\nassert(prod_signs(arr:\
    \ [-1, 1, -1, 1]) == 4)\nassert(prod_signs(arr: [-1, 1, 1, 1]) == -4)\nassert(prod_signs(arr:\
    \ [-1, 1, 1, 0]) == 0)"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659979792
- exit_code: -4
  program: "\n/// You are given an array arr of integers and you need to return\n\
    /// sum of magnitudes of integers multiplied by product of all signs\n/// of each\
    \ number in the array, represented by 1, -1 or 0.\n/// Note: return nil for empty\
    \ arr.\n/// Example:\n/// >>> prod_signs(arr: [1, 2, 2, -4])\n/// 9\n/// >>> prod_signs(arr:\
    \ [0, 1])\n/// 0\n/// >>> prod_signs(arr: [] as [Int])\n/// nil\nfunc prod_signs(arr:\
    \ [Int]) -> Int? {\n    var product = 1\n    var sum = 0\n    for num in arr {\n\
    \        if num < 0 {\n            product *= -1\n        } else if num > 0 {\n\
    \            product *= 1\n        } else {\n            product *= 0\n      \
    \  }\n        sum += abs(num)\n    }\n    return product * sum\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(prod_signs(arr: [1, 2, 2, -4]) == -9)\nassert(prod_signs(arr:\
    \ [0, 1]) == 0)\nassert(prod_signs(arr: [1, 1, 1, 2, 3, -1, 1]) == -10)\nassert(prod_signs(arr:\
    \ [] as [Int]) == nil)\nassert(prod_signs(arr: [2, 4, 1, 2, -1, -1, 9]) == 20)\n\
    assert(prod_signs(arr: [-1, 1, -1, 1]) == 4)\nassert(prod_signs(arr: [-1, 1, 1,\
    \ 1]) == -4)\nassert(prod_signs(arr: [-1, 1, 1, 0]) == 0)"
  status: Exception
  stderr: 'tmpb9inw2k6/tmpb9inw2k6.swift:45: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002aef03cd0c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002aef039c7b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002aef039c7988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002aef039c67b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpb9inw2k6                        0x000055d8b1ff1a5c <unavailable> + 6748

    5    libc.so.6                          0x00002aef03ebc460 __libc_start_main +
    245

    6    tmpb9inw2k6                        0x000055d8b1ff11c9 <unavailable> + 4553

    '
  stdout: ''
  timestamp: 1659979792
- exit_code: 1
  program: "\n/// You are given an array arr of integers and you need to return\n\
    /// sum of magnitudes of integers multiplied by product of all signs\n/// of each\
    \ number in the array, represented by 1, -1 or 0.\n/// Note: return nil for empty\
    \ arr.\n/// Example:\n/// >>> prod_signs(arr: [1, 2, 2, -4])\n/// 9\n/// >>> prod_signs(arr:\
    \ [0, 1])\n/// 0\n/// >>> prod_signs(arr: [] as [Int])\n/// nil\nfunc prod_signs(arr:\
    \ [Int]) -> Int? {\n    return arr.isEmpty ? nil : prod_signs_helper(arr: arr,\
    \ prod: 1, sum: 0)\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) ->\
    \ Bool {\n    if left.count != right.count {\n        return false\n    }\n  \
    \  for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(prod_signs(arr: [1,\
    \ 2, 2, -4]) == -9)\nassert(prod_signs(arr: [0, 1]) == 0)\nassert(prod_signs(arr:\
    \ [1, 1, 1, 2, 3, -1, 1]) == -10)\nassert(prod_signs(arr: [] as [Int]) == nil)\n\
    assert(prod_signs(arr: [2, 4, 1, 2, -1, -1, 9]) == 20)\nassert(prod_signs(arr:\
    \ [-1, 1, -1, 1]) == 4)\nassert(prod_signs(arr: [-1, 1, 1, 1]) == -4)\nassert(prod_signs(arr:\
    \ [-1, 1, 1, 0]) == 0)"
  status: SyntaxError
  stderr: "/tmp/tmptiresg4y.swift:14:32: error: cannot find 'prod_signs_helper' in\
    \ scope\n    return arr.isEmpty ? nil : prod_signs_helper(arr: arr, prod: 1, sum:\
    \ 0)\n                               ^~~~~~~~~~~~~~~~~\n"
  stdout: ''
  timestamp: 1659979792
- exit_code: -4
  program: "\n/// You are given an array arr of integers and you need to return\n\
    /// sum of magnitudes of integers multiplied by product of all signs\n/// of each\
    \ number in the array, represented by 1, -1 or 0.\n/// Note: return nil for empty\
    \ arr.\n/// Example:\n/// >>> prod_signs(arr: [1, 2, 2, -4])\n/// 9\n/// >>> prod_signs(arr:\
    \ [0, 1])\n/// 0\n/// >>> prod_signs(arr: [] as [Int])\n/// nil\nfunc prod_signs(arr:\
    \ [Int]) -> Int? {\n    var count = 0\n    for n in arr {\n        if n > 0 {\n\
    \            count += 1\n        } else if n < 0 {\n            count -= 1\n \
    \       }\n    }\n    if count == 0 {\n        return 0\n    }\n    return arr.map\
    \ { abs($0) }.reduce(1, *) * count / abs(count)\n}\n\n\nfunc ==(left: [(Int, Int)],\
    \ right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n       \
    \ return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r\
    \ {\n            return false\n        }\n    }\n    return true\n}\n        \
    \    \nassert(prod_signs(arr: [1, 2, 2, -4]) == -9)\nassert(prod_signs(arr: [0,\
    \ 1]) == 0)\nassert(prod_signs(arr: [1, 1, 1, 2, 3, -1, 1]) == -10)\nassert(prod_signs(arr:\
    \ [] as [Int]) == nil)\nassert(prod_signs(arr: [2, 4, 1, 2, -1, -1, 9]) == 20)\n\
    assert(prod_signs(arr: [-1, 1, -1, 1]) == 4)\nassert(prod_signs(arr: [-1, 1, 1,\
    \ 1]) == -4)\nassert(prod_signs(arr: [-1, 1, 1, 0]) == 0)"
  status: Exception
  stderr: 'tmpj4wjqziq/tmpj4wjqziq.swift:41: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b5e3cba5c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b5e3c89cb6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b5e3c89c988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b5e3c89b7b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpj4wjqziq                        0x000055828ea4e7a9 <unavailable> + 6057

    5    libc.so.6                          0x00002b5e3cd91460 __libc_start_main +
    245

    6    tmpj4wjqziq                        0x000055828ea4e339 <unavailable> + 4921

    '
  stdout: ''
  timestamp: 1659979792
- exit_code: -4
  program: "\n/// You are given an array arr of integers and you need to return\n\
    /// sum of magnitudes of integers multiplied by product of all signs\n/// of each\
    \ number in the array, represented by 1, -1 or 0.\n/// Note: return nil for empty\
    \ arr.\n/// Example:\n/// >>> prod_signs(arr: [1, 2, 2, -4])\n/// 9\n/// >>> prod_signs(arr:\
    \ [0, 1])\n/// 0\n/// >>> prod_signs(arr: [] as [Int])\n/// nil\nfunc prod_signs(arr:\
    \ [Int]) -> Int? {\n    var sum = 0\n    var total = 1\n    for num in arr {\n\
    \        if num > 0 {\n            sum += num\n            total *= 1\n      \
    \  } else if num < 0 {\n            sum += num\n            total *= -1\n    \
    \    } else {\n            total *= 0\n        }\n    }\n    if total == 0 {\n\
    \        return nil\n    }\n    return sum * total\n}\n\n\nfunc ==(left: [(Int,\
    \ Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n\
    \        return false\n    }\n    for (l, r) in zip(left, right) {\n        if\
    \ l != r {\n            return false\n        }\n    }\n    return true\n}\n \
    \           \nassert(prod_signs(arr: [1, 2, 2, -4]) == -9)\nassert(prod_signs(arr:\
    \ [0, 1]) == 0)\nassert(prod_signs(arr: [1, 1, 1, 2, 3, -1, 1]) == -10)\nassert(prod_signs(arr:\
    \ [] as [Int]) == nil)\nassert(prod_signs(arr: [2, 4, 1, 2, -1, -1, 9]) == 20)\n\
    assert(prod_signs(arr: [-1, 1, -1, 1]) == 4)\nassert(prod_signs(arr: [-1, 1, 1,\
    \ 1]) == -4)\nassert(prod_signs(arr: [-1, 1, 1, 0]) == 0)"
  status: Exception
  stderr: 'tmp0ltg25xi/tmp0ltg25xi.swift:46: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002aec0bee7c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002aec0bbdeb6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002aec0bbde988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002aec0bbdd7b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmp0ltg25xi                        0x0000555c73872549 <unavailable> + 5449

    5    libc.so.6                          0x00002aec0c0d3460 __libc_start_main +
    245

    6    tmp0ltg25xi                        0x0000555c738720d9 <unavailable> + 4313

    '
  stdout: ''
  timestamp: 1659979792
- exit_code: 0
  program: "\n/// You are given an array arr of integers and you need to return\n\
    /// sum of magnitudes of integers multiplied by product of all signs\n/// of each\
    \ number in the array, represented by 1, -1 or 0.\n/// Note: return nil for empty\
    \ arr.\n/// Example:\n/// >>> prod_signs(arr: [1, 2, 2, -4])\n/// 9\n/// >>> prod_signs(arr:\
    \ [0, 1])\n/// 0\n/// >>> prod_signs(arr: [] as [Int])\n/// nil\nfunc prod_signs(arr:\
    \ [Int]) -> Int? {\n    if arr.isEmpty {\n        return nil\n    }\n    var sum\
    \ = 0\n    var prod = 1\n    for num in arr {\n        prod *= num.signum()\n\
    \        sum += abs(num)\n    }\n    return sum * prod\n}\n\n\nfunc ==(left: [(Int,\
    \ Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n\
    \        return false\n    }\n    for (l, r) in zip(left, right) {\n        if\
    \ l != r {\n            return false\n        }\n    }\n    return true\n}\n \
    \           \nassert(prod_signs(arr: [1, 2, 2, -4]) == -9)\nassert(prod_signs(arr:\
    \ [0, 1]) == 0)\nassert(prod_signs(arr: [1, 1, 1, 2, 3, -1, 1]) == -10)\nassert(prod_signs(arr:\
    \ [] as [Int]) == nil)\nassert(prod_signs(arr: [2, 4, 1, 2, -1, -1, 9]) == 20)\n\
    assert(prod_signs(arr: [-1, 1, -1, 1]) == 4)\nassert(prod_signs(arr: [-1, 1, 1,\
    \ 1]) == -4)\nassert(prod_signs(arr: [-1, 1, 1, 0]) == 0)"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659979792
- exit_code: -4
  program: "\n/// You are given an array arr of integers and you need to return\n\
    /// sum of magnitudes of integers multiplied by product of all signs\n/// of each\
    \ number in the array, represented by 1, -1 or 0.\n/// Note: return nil for empty\
    \ arr.\n/// Example:\n/// >>> prod_signs(arr: [1, 2, 2, -4])\n/// 9\n/// >>> prod_signs(arr:\
    \ [0, 1])\n/// 0\n/// >>> prod_signs(arr: [] as [Int])\n/// nil\nfunc prod_signs(arr:\
    \ [Int]) -> Int? {\n  return nil\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int,\
    \ Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n\
    \    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n          \
    \  return false\n        }\n    }\n    return true\n}\n            \nassert(prod_signs(arr:\
    \ [1, 2, 2, -4]) == -9)\nassert(prod_signs(arr: [0, 1]) == 0)\nassert(prod_signs(arr:\
    \ [1, 1, 1, 2, 3, -1, 1]) == -10)\nassert(prod_signs(arr: [] as [Int]) == nil)\n\
    assert(prod_signs(arr: [2, 4, 1, 2, -1, -1, 9]) == 20)\nassert(prod_signs(arr:\
    \ [-1, 1, -1, 1]) == 4)\nassert(prod_signs(arr: [-1, 1, 1, 1]) == -4)\nassert(prod_signs(arr:\
    \ [-1, 1, 1, 0]) == 0)"
  status: Exception
  stderr: 'tmpy4xc0hy9/tmpy4xc0hy9.swift:30: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b84f78ddc80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b84f75d4b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b84f75d4988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b84f75d37b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpy4xc0hy9                        0x000055a66892d3d9 <unavailable> + 5081

    5    libc.so.6                          0x00002b84f7ac9460 __libc_start_main +
    245

    6    tmpy4xc0hy9                        0x000055a66892cf69 <unavailable> + 3945

    '
  stdout: ''
  timestamp: 1659979792
- exit_code: 1
  program: "\n/// You are given an array arr of integers and you need to return\n\
    /// sum of magnitudes of integers multiplied by product of all signs\n/// of each\
    \ number in the array, represented by 1, -1 or 0.\n/// Note: return nil for empty\
    \ arr.\n/// Example:\n/// >>> prod_signs(arr: [1, 2, 2, -4])\n/// 9\n/// >>> prod_signs(arr:\
    \ [0, 1])\n/// 0\n/// >>> prod_signs(arr: [] as [Int])\n/// nil\nfunc prod_signs(arr:\
    \ [Int]) -> Int? {\n    let magnitudes = arr.map { abs($0) }\n    guard !magnitudes.isEmpty\
    \ else { return nil }\n    let signs = arr.map { sign($0) }\n    return magnitudes.reduce(1,\
    \ *) * signs.reduce(1, *)\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(prod_signs(arr:\
    \ [1, 2, 2, -4]) == -9)\nassert(prod_signs(arr: [0, 1]) == 0)\nassert(prod_signs(arr:\
    \ [1, 1, 1, 2, 3, -1, 1]) == -10)\nassert(prod_signs(arr: [] as [Int]) == nil)\n\
    assert(prod_signs(arr: [2, 4, 1, 2, -1, -1, 9]) == 20)\nassert(prod_signs(arr:\
    \ [-1, 1, -1, 1]) == 4)\nassert(prod_signs(arr: [-1, 1, 1, 1]) == -4)\nassert(prod_signs(arr:\
    \ [-1, 1, 1, 0]) == 0)"
  status: SyntaxError
  stderr: "/tmp/tmpfff_7gu5.swift:16:27: error: cannot find 'sign' in scope\n    let\
    \ signs = arr.map { sign($0) }\n                          ^~~~\n"
  stdout: ''
  timestamp: 1659979793
- exit_code: 0
  program: "\n/// You are given an array arr of integers and you need to return\n\
    /// sum of magnitudes of integers multiplied by product of all signs\n/// of each\
    \ number in the array, represented by 1, -1 or 0.\n/// Note: return nil for empty\
    \ arr.\n/// Example:\n/// >>> prod_signs(arr: [1, 2, 2, -4])\n/// 9\n/// >>> prod_signs(arr:\
    \ [0, 1])\n/// 0\n/// >>> prod_signs(arr: [] as [Int])\n/// nil\nfunc prod_signs(arr:\
    \ [Int]) -> Int? {\n    var prod = 1\n    var sum = 0\n    if arr.count == 0 {\n\
    \        return nil\n    }\n    for i in arr {\n        prod *= i < 0 ? -1 : (i\
    \ == 0 ? 0 : 1)\n        sum += abs(i)\n    }\n    return prod * sum\n}\n\n\n\
    func ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(prod_signs(arr: [1, 2, 2, -4]) == -9)\nassert(prod_signs(arr:\
    \ [0, 1]) == 0)\nassert(prod_signs(arr: [1, 1, 1, 2, 3, -1, 1]) == -10)\nassert(prod_signs(arr:\
    \ [] as [Int]) == nil)\nassert(prod_signs(arr: [2, 4, 1, 2, -1, -1, 9]) == 20)\n\
    assert(prod_signs(arr: [-1, 1, -1, 1]) == 4)\nassert(prod_signs(arr: [-1, 1, 1,\
    \ 1]) == -4)\nassert(prod_signs(arr: [-1, 1, 1, 0]) == 0)"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659979792
- exit_code: 0
  program: "\n/// You are given an array arr of integers and you need to return\n\
    /// sum of magnitudes of integers multiplied by product of all signs\n/// of each\
    \ number in the array, represented by 1, -1 or 0.\n/// Note: return nil for empty\
    \ arr.\n/// Example:\n/// >>> prod_signs(arr: [1, 2, 2, -4])\n/// 9\n/// >>> prod_signs(arr:\
    \ [0, 1])\n/// 0\n/// >>> prod_signs(arr: [] as [Int])\n/// nil\nfunc prod_signs(arr:\
    \ [Int]) -> Int? {\n  if arr.isEmpty {\n    return nil\n  }\n  let signProd =\
    \ arr.map { s in s < 0 ? -1 : s > 0 ? 1 : 0 }.reduce(1, *)\n  let magnitudes =\
    \ arr.map { abs($0) }\n  return magnitudes.reduce(0, +) * signProd\n}\n\n\nfunc\
    \ ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count !=\
    \ right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(prod_signs(arr: [1, 2, 2, -4]) == -9)\nassert(prod_signs(arr:\
    \ [0, 1]) == 0)\nassert(prod_signs(arr: [1, 1, 1, 2, 3, -1, 1]) == -10)\nassert(prod_signs(arr:\
    \ [] as [Int]) == nil)\nassert(prod_signs(arr: [2, 4, 1, 2, -1, -1, 9]) == 20)\n\
    assert(prod_signs(arr: [-1, 1, -1, 1]) == 4)\nassert(prod_signs(arr: [-1, 1, 1,\
    \ 1]) == -4)\nassert(prod_signs(arr: [-1, 1, 1, 0]) == 0)"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659979792
- exit_code: -4
  program: "\n/// You are given an array arr of integers and you need to return\n\
    /// sum of magnitudes of integers multiplied by product of all signs\n/// of each\
    \ number in the array, represented by 1, -1 or 0.\n/// Note: return nil for empty\
    \ arr.\n/// Example:\n/// >>> prod_signs(arr: [1, 2, 2, -4])\n/// 9\n/// >>> prod_signs(arr:\
    \ [0, 1])\n/// 0\n/// >>> prod_signs(arr: [] as [Int])\n/// nil\nfunc prod_signs(arr:\
    \ [Int]) -> Int? {\n    var res = 0\n    var prod = 1\n    var empty = true\n\
    \    for i in arr {\n        if i == 0 {\n            continue\n        }\n  \
    \      empty = false\n        if i > 0 {\n            res += i\n        } else\
    \ {\n            res -= i\n            prod *= -1\n        }\n    }\n    return\
    \ empty ? nil : res * prod\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(prod_signs(arr:\
    \ [1, 2, 2, -4]) == -9)\nassert(prod_signs(arr: [0, 1]) == 0)\nassert(prod_signs(arr:\
    \ [1, 1, 1, 2, 3, -1, 1]) == -10)\nassert(prod_signs(arr: [] as [Int]) == nil)\n\
    assert(prod_signs(arr: [2, 4, 1, 2, -1, -1, 9]) == 20)\nassert(prod_signs(arr:\
    \ [-1, 1, -1, 1]) == 4)\nassert(prod_signs(arr: [-1, 1, 1, 1]) == -4)\nassert(prod_signs(arr:\
    \ [-1, 1, 1, 0]) == 0)"
  status: Exception
  stderr: 'tmpj1twkcu_/tmpj1twkcu_.swift:46: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b28ad7a5c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b28ad49cb6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b28ad49c988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b28ad49b7b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpj1twkcu_                        0x000056510cec26d5 <unavailable> + 5845

    5    libc.so.6                          0x00002b28ad991460 __libc_start_main +
    245

    6    tmpj1twkcu_                        0x000056510cec20d9 <unavailable> + 4313

    '
  stdout: ''
  timestamp: 1659979792
- exit_code: 0
  program: "\n/// You are given an array arr of integers and you need to return\n\
    /// sum of magnitudes of integers multiplied by product of all signs\n/// of each\
    \ number in the array, represented by 1, -1 or 0.\n/// Note: return nil for empty\
    \ arr.\n/// Example:\n/// >>> prod_signs(arr: [1, 2, 2, -4])\n/// 9\n/// >>> prod_signs(arr:\
    \ [0, 1])\n/// 0\n/// >>> prod_signs(arr: [] as [Int])\n/// nil\nfunc prod_signs(arr:\
    \ [Int]) -> Int? {\n    guard arr.count > 0 else { return nil }\n    let sign_product\
    \ = arr.reduce(1) {\n        if $1 > 0 { return $0 * 1 }\n        else if $1 <\
    \ 0 { return $0 * -1 }\n        else { return $0 * 0 }\n    }\n    let arr_abs\
    \ = arr.map { abs($0) }\n    let abs_sum = arr_abs.reduce(0, +)\n    return abs_sum\
    \ * sign_product\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool\
    \ {\n    if left.count != right.count {\n        return false\n    }\n    for\
    \ (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(prod_signs(arr: [1,\
    \ 2, 2, -4]) == -9)\nassert(prod_signs(arr: [0, 1]) == 0)\nassert(prod_signs(arr:\
    \ [1, 1, 1, 2, 3, -1, 1]) == -10)\nassert(prod_signs(arr: [] as [Int]) == nil)\n\
    assert(prod_signs(arr: [2, 4, 1, 2, -1, -1, 9]) == 20)\nassert(prod_signs(arr:\
    \ [-1, 1, -1, 1]) == 4)\nassert(prod_signs(arr: [-1, 1, 1, 1]) == -4)\nassert(prod_signs(arr:\
    \ [-1, 1, 1, 0]) == 0)"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659979792
- exit_code: -4
  program: "\n/// You are given an array arr of integers and you need to return\n\
    /// sum of magnitudes of integers multiplied by product of all signs\n/// of each\
    \ number in the array, represented by 1, -1 or 0.\n/// Note: return nil for empty\
    \ arr.\n/// Example:\n/// >>> prod_signs(arr: [1, 2, 2, -4])\n/// 9\n/// >>> prod_signs(arr:\
    \ [0, 1])\n/// 0\n/// >>> prod_signs(arr: [] as [Int])\n/// nil\nfunc prod_signs(arr:\
    \ [Int]) -> Int? {\n  if arr.isEmpty {\n    return nil\n  }\n  var sum = 0\n \
    \ var product = 1\n  for i in arr {\n    sum += i\n    if i > 0 {\n      product\
    \ *= 1\n    } else if i < 0 {\n      product *= -1\n    } else {\n      product\
    \ *= 0\n    }\n  }\n  return sum * product\n}\n\n\nfunc ==(left: [(Int, Int)],\
    \ right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n       \
    \ return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r\
    \ {\n            return false\n        }\n    }\n    return true\n}\n        \
    \    \nassert(prod_signs(arr: [1, 2, 2, -4]) == -9)\nassert(prod_signs(arr: [0,\
    \ 1]) == 0)\nassert(prod_signs(arr: [1, 1, 1, 2, 3, -1, 1]) == -10)\nassert(prod_signs(arr:\
    \ [] as [Int]) == nil)\nassert(prod_signs(arr: [2, 4, 1, 2, -1, -1, 9]) == 20)\n\
    assert(prod_signs(arr: [-1, 1, -1, 1]) == 4)\nassert(prod_signs(arr: [-1, 1, 1,\
    \ 1]) == -4)\nassert(prod_signs(arr: [-1, 1, 1, 0]) == 0)"
  status: Exception
  stderr: 'tmpih4x7gvb/tmpih4x7gvb.swift:45: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b93c176bc80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b93c1462b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b93c1462988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b93c14617b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpih4x7gvb                        0x0000559d79d20599 <unavailable> + 5529

    5    libc.so.6                          0x00002b93c1957460 __libc_start_main +
    245

    6    tmpih4x7gvb                        0x0000559d79d20129 <unavailable> + 4393

    '
  stdout: ''
  timestamp: 1659979792
- exit_code: 0
  program: "\n/// You are given an array arr of integers and you need to return\n\
    /// sum of magnitudes of integers multiplied by product of all signs\n/// of each\
    \ number in the array, represented by 1, -1 or 0.\n/// Note: return nil for empty\
    \ arr.\n/// Example:\n/// >>> prod_signs(arr: [1, 2, 2, -4])\n/// 9\n/// >>> prod_signs(arr:\
    \ [0, 1])\n/// 0\n/// >>> prod_signs(arr: [] as [Int])\n/// nil\nfunc prod_signs(arr:\
    \ [Int]) -> Int? {\n    if arr.isEmpty {\n        return nil\n    }\n    var sum\
    \ = 0\n    var prod = 1\n    for i in arr {\n        sum += abs(i)\n        prod\
    \ *= i > 0 ? 1 : (i < 0 ? -1 : 0)\n    }\n    return sum * prod\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(prod_signs(arr: [1, 2, 2, -4]) == -9)\nassert(prod_signs(arr:\
    \ [0, 1]) == 0)\nassert(prod_signs(arr: [1, 1, 1, 2, 3, -1, 1]) == -10)\nassert(prod_signs(arr:\
    \ [] as [Int]) == nil)\nassert(prod_signs(arr: [2, 4, 1, 2, -1, -1, 9]) == 20)\n\
    assert(prod_signs(arr: [-1, 1, -1, 1]) == 4)\nassert(prod_signs(arr: [-1, 1, 1,\
    \ 1]) == -4)\nassert(prod_signs(arr: [-1, 1, 1, 0]) == 0)"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659979792
- exit_code: -4
  program: "\n/// You are given an array arr of integers and you need to return\n\
    /// sum of magnitudes of integers multiplied by product of all signs\n/// of each\
    \ number in the array, represented by 1, -1 or 0.\n/// Note: return nil for empty\
    \ arr.\n/// Example:\n/// >>> prod_signs(arr: [1, 2, 2, -4])\n/// 9\n/// >>> prod_signs(arr:\
    \ [0, 1])\n/// 0\n/// >>> prod_signs(arr: [] as [Int])\n/// nil\nfunc prod_signs(arr:\
    \ [Int]) -> Int? {\n    return nil\n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(prod_signs(arr: [1, 2, 2, -4]) == -9)\nassert(prod_signs(arr: [0, 1]) ==\
    \ 0)\nassert(prod_signs(arr: [1, 1, 1, 2, 3, -1, 1]) == -10)\nassert(prod_signs(arr:\
    \ [] as [Int]) == nil)\nassert(prod_signs(arr: [2, 4, 1, 2, -1, -1, 9]) == 20)\n\
    assert(prod_signs(arr: [-1, 1, -1, 1]) == 4)\nassert(prod_signs(arr: [-1, 1, 1,\
    \ 1]) == -4)\nassert(prod_signs(arr: [-1, 1, 1, 0]) == 0)"
  status: Exception
  stderr: 'tmp1rt4wv_3/tmp1rt4wv_3.swift:30: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b2a15132c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b2a14e29b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b2a14e29988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b2a14e287b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmp1rt4wv_3                        0x00005652a02c73d9 <unavailable> + 5081

    5    libc.so.6                          0x00002b2a1531e460 __libc_start_main +
    245

    6    tmp1rt4wv_3                        0x00005652a02c6f69 <unavailable> + 3945

    '
  stdout: ''
  timestamp: 1659979791
- exit_code: 1
  program: "\n/// You are given an array arr of integers and you need to return\n\
    /// sum of magnitudes of integers multiplied by product of all signs\n/// of each\
    \ number in the array, represented by 1, -1 or 0.\n/// Note: return nil for empty\
    \ arr.\n/// Example:\n/// >>> prod_signs(arr: [1, 2, 2, -4])\n/// 9\n/// >>> prod_signs(arr:\
    \ [0, 1])\n/// 0\n/// >>> prod_signs(arr: [] as [Int])\n/// nil\nfunc prod_signs(arr:\
    \ [Int]) -> Int? {\n    if arr.isEmpty {\n        return nil\n    }\n    let signs\
    \ = arr.map { (x: Int) -> Int in\n        if x == 0 {\n            return 0\n\
    \        } else if x > 0 {\n            return 1\n        } else {\n         \
    \   return -1\n        }\n    }\n    let prod = signs.reduce(1, *)\n    let abs\
    \ = arr.map { abs($0) }\n    let result = abs.reduce(0, +)\n    return result\
    \ * prod\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n\
    \    if left.count != right.count {\n        return false\n    }\n    for (l,\
    \ r) in zip(left, right) {\n        if l != r {\n            return false\n  \
    \      }\n    }\n    return true\n}\n            \nassert(prod_signs(arr: [1,\
    \ 2, 2, -4]) == -9)\nassert(prod_signs(arr: [0, 1]) == 0)\nassert(prod_signs(arr:\
    \ [1, 1, 1, 2, 3, -1, 1]) == -10)\nassert(prod_signs(arr: [] as [Int]) == nil)\n\
    assert(prod_signs(arr: [2, 4, 1, 2, -1, -1, 9]) == 20)\nassert(prod_signs(arr:\
    \ [-1, 1, -1, 1]) == 4)\nassert(prod_signs(arr: [-1, 1, 1, 1]) == -4)\nassert(prod_signs(arr:\
    \ [-1, 1, 1, 0]) == 0)"
  status: SyntaxError
  stderr: "/tmp/tmpq3oh74ap.swift:27:25: error: cannot call value of non-function\
    \ type '[T]'\n    let abs = arr.map { abs($0) }\n                        ^\n"
  stdout: ''
  timestamp: 1659979792
- exit_code: 0
  program: "\n/// You are given an array arr of integers and you need to return\n\
    /// sum of magnitudes of integers multiplied by product of all signs\n/// of each\
    \ number in the array, represented by 1, -1 or 0.\n/// Note: return nil for empty\
    \ arr.\n/// Example:\n/// >>> prod_signs(arr: [1, 2, 2, -4])\n/// 9\n/// >>> prod_signs(arr:\
    \ [0, 1])\n/// 0\n/// >>> prod_signs(arr: [] as [Int])\n/// nil\nfunc prod_signs(arr:\
    \ [Int]) -> Int? {\n    if arr.isEmpty {\n        return nil\n    }\n    let prod\
    \ = arr.map { $0 < 0 ? -1 : $0 > 0 ? 1 : 0 }.reduce(1, *)\n    let sum = arr.map\
    \ { abs($0) }.reduce(0, +)\n    return sum * prod\n}\n\n\nfunc ==(left: [(Int,\
    \ Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n\
    \        return false\n    }\n    for (l, r) in zip(left, right) {\n        if\
    \ l != r {\n            return false\n        }\n    }\n    return true\n}\n \
    \           \nassert(prod_signs(arr: [1, 2, 2, -4]) == -9)\nassert(prod_signs(arr:\
    \ [0, 1]) == 0)\nassert(prod_signs(arr: [1, 1, 1, 2, 3, -1, 1]) == -10)\nassert(prod_signs(arr:\
    \ [] as [Int]) == nil)\nassert(prod_signs(arr: [2, 4, 1, 2, -1, -1, 9]) == 20)\n\
    assert(prod_signs(arr: [-1, 1, -1, 1]) == 4)\nassert(prod_signs(arr: [-1, 1, 1,\
    \ 1]) == -4)\nassert(prod_signs(arr: [-1, 1, 1, 0]) == 0)"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659979792
- exit_code: 0
  program: "\n/// You are given an array arr of integers and you need to return\n\
    /// sum of magnitudes of integers multiplied by product of all signs\n/// of each\
    \ number in the array, represented by 1, -1 or 0.\n/// Note: return nil for empty\
    \ arr.\n/// Example:\n/// >>> prod_signs(arr: [1, 2, 2, -4])\n/// 9\n/// >>> prod_signs(arr:\
    \ [0, 1])\n/// 0\n/// >>> prod_signs(arr: [] as [Int])\n/// nil\nfunc prod_signs(arr:\
    \ [Int]) -> Int? {\n\tguard arr.count > 0 else { return nil }\n\tlet signOf =\
    \ { (num: Int) -> Int in\n\t\tif num == 0 { return 0 }\n\t\treturn (num > 0) ?\
    \ 1 : -1\n\t}\n\tvar prod = 1\n\tvar sum = 0\n\tfor n in arr {\n\t\tlet s = signOf(n)\n\
    \t\tprod *= s\n\t\tsum += (n * s)\n\t}\n\treturn sum * prod\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(prod_signs(arr: [1, 2, 2, -4]) == -9)\nassert(prod_signs(arr:\
    \ [0, 1]) == 0)\nassert(prod_signs(arr: [1, 1, 1, 2, 3, -1, 1]) == -10)\nassert(prod_signs(arr:\
    \ [] as [Int]) == nil)\nassert(prod_signs(arr: [2, 4, 1, 2, -1, -1, 9]) == 20)\n\
    assert(prod_signs(arr: [-1, 1, -1, 1]) == 4)\nassert(prod_signs(arr: [-1, 1, 1,\
    \ 1]) == -4)\nassert(prod_signs(arr: [-1, 1, 1, 0]) == 0)"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659979792
- exit_code: -4
  program: "\n/// You are given an array arr of integers and you need to return\n\
    /// sum of magnitudes of integers multiplied by product of all signs\n/// of each\
    \ number in the array, represented by 1, -1 or 0.\n/// Note: return nil for empty\
    \ arr.\n/// Example:\n/// >>> prod_signs(arr: [1, 2, 2, -4])\n/// 9\n/// >>> prod_signs(arr:\
    \ [0, 1])\n/// 0\n/// >>> prod_signs(arr: [] as [Int])\n/// nil\nfunc prod_signs(arr:\
    \ [Int]) -> Int? {\n    var prod = 1\n    var total = 0\n    for number in arr\
    \ {\n        if number > 0 {\n            prod *= 1\n        } else if number\
    \ < 0 {\n            prod *= -1\n        } else {\n            prod *= 0\n   \
    \     }\n        total += abs(number)\n    }\n    return total * prod\n}\n\n\n\
    func ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(prod_signs(arr: [1, 2, 2, -4]) == -9)\nassert(prod_signs(arr:\
    \ [0, 1]) == 0)\nassert(prod_signs(arr: [1, 1, 1, 2, 3, -1, 1]) == -10)\nassert(prod_signs(arr:\
    \ [] as [Int]) == nil)\nassert(prod_signs(arr: [2, 4, 1, 2, -1, -1, 9]) == 20)\n\
    assert(prod_signs(arr: [-1, 1, -1, 1]) == 4)\nassert(prod_signs(arr: [-1, 1, 1,\
    \ 1]) == -4)\nassert(prod_signs(arr: [-1, 1, 1, 0]) == 0)"
  status: Exception
  stderr: 'tmpyi533qzh/tmpyi533qzh.swift:45: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b9ef0666c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b9ef035db6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b9ef035d988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b9ef035c7b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpyi533qzh                        0x00005624f3dc2a5c <unavailable> + 6748

    5    libc.so.6                          0x00002b9ef0852460 __libc_start_main +
    245

    6    tmpyi533qzh                        0x00005624f3dc21c9 <unavailable> + 4553

    '
  stdout: ''
  timestamp: 1659979793
- exit_code: 0
  program: "\n/// You are given an array arr of integers and you need to return\n\
    /// sum of magnitudes of integers multiplied by product of all signs\n/// of each\
    \ number in the array, represented by 1, -1 or 0.\n/// Note: return nil for empty\
    \ arr.\n/// Example:\n/// >>> prod_signs(arr: [1, 2, 2, -4])\n/// 9\n/// >>> prod_signs(arr:\
    \ [0, 1])\n/// 0\n/// >>> prod_signs(arr: [] as [Int])\n/// nil\nfunc prod_signs(arr:\
    \ [Int]) -> Int? {\n    guard arr.count > 0 else { return nil }\n    let prod\
    \ = arr.map { $0 == 0 ? 0 : $0 > 0 ? 1 : -1 }.reduce(1, *)\n    let sum = arr.map\
    \ { abs($0) }.reduce(0, +)\n    return sum * prod\n}\n\n\nfunc ==(left: [(Int,\
    \ Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n\
    \        return false\n    }\n    for (l, r) in zip(left, right) {\n        if\
    \ l != r {\n            return false\n        }\n    }\n    return true\n}\n \
    \           \nassert(prod_signs(arr: [1, 2, 2, -4]) == -9)\nassert(prod_signs(arr:\
    \ [0, 1]) == 0)\nassert(prod_signs(arr: [1, 1, 1, 2, 3, -1, 1]) == -10)\nassert(prod_signs(arr:\
    \ [] as [Int]) == nil)\nassert(prod_signs(arr: [2, 4, 1, 2, -1, -1, 9]) == 20)\n\
    assert(prod_signs(arr: [-1, 1, -1, 1]) == 4)\nassert(prod_signs(arr: [-1, 1, 1,\
    \ 1]) == -4)\nassert(prod_signs(arr: [-1, 1, 1, 0]) == 0)"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659979793
- exit_code: -4
  program: "\n/// You are given an array arr of integers and you need to return\n\
    /// sum of magnitudes of integers multiplied by product of all signs\n/// of each\
    \ number in the array, represented by 1, -1 or 0.\n/// Note: return nil for empty\
    \ arr.\n/// Example:\n/// >>> prod_signs(arr: [1, 2, 2, -4])\n/// 9\n/// >>> prod_signs(arr:\
    \ [0, 1])\n/// 0\n/// >>> prod_signs(arr: [] as [Int])\n/// nil\nfunc prod_signs(arr:\
    \ [Int]) -> Int? {\n    var sum = 0\n    var product = 1\n    for el in arr {\n\
    \        sum += abs(el)\n        if el < 0 {\n            product *= -1\n    \
    \    } else if el > 0 {\n            product *= 1\n        }\n    }\n    if product\
    \ == 0 {\n        return nil\n    }\n    return sum * product\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(prod_signs(arr: [1, 2, 2, -4]) == -9)\nassert(prod_signs(arr:\
    \ [0, 1]) == 0)\nassert(prod_signs(arr: [1, 1, 1, 2, 3, -1, 1]) == -10)\nassert(prod_signs(arr:\
    \ [] as [Int]) == nil)\nassert(prod_signs(arr: [2, 4, 1, 2, -1, -1, 9]) == 20)\n\
    assert(prod_signs(arr: [-1, 1, -1, 1]) == 4)\nassert(prod_signs(arr: [-1, 1, 1,\
    \ 1]) == -4)\nassert(prod_signs(arr: [-1, 1, 1, 0]) == 0)"
  status: Exception
  stderr: 'tmpcu2g9pk8/tmpcu2g9pk8.swift:44: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b055f3f2c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b055f0e9b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b055f0e9988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b055f0e87b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpcu2g9pk8                        0x0000561abfe0c7c5 <unavailable> + 6085

    5    libc.so.6                          0x00002b055f5de460 __libc_start_main +
    245

    6    tmpcu2g9pk8                        0x0000561abfe0c1c9 <unavailable> + 4553

    '
  stdout: ''
  timestamp: 1659979793
- exit_code: 1
  program: "\n/// You are given an array arr of integers and you need to return\n\
    /// sum of magnitudes of integers multiplied by product of all signs\n/// of each\
    \ number in the array, represented by 1, -1 or 0.\n/// Note: return nil for empty\
    \ arr.\n/// Example:\n/// >>> prod_signs(arr: [1, 2, 2, -4])\n/// 9\n/// >>> prod_signs(arr:\
    \ [0, 1])\n/// 0\n/// >>> prod_signs(arr: [] as [Int])\n/// nil\nfunc prod_signs(arr:\
    \ [Int]) -> Int? {\n    guard arr.count > 0 else {\n        return nil\n    }\n\
    \    var product = 1\n    var sum = 0\n    for i in arr {\n        product *=\
    \ sign_num(i)\n        sum += abs(i)\n    }\n    return product * sum\n}\n\n\n\
    func ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(prod_signs(arr: [1, 2, 2, -4]) == -9)\nassert(prod_signs(arr:\
    \ [0, 1]) == 0)\nassert(prod_signs(arr: [1, 1, 1, 2, 3, -1, 1]) == -10)\nassert(prod_signs(arr:\
    \ [] as [Int]) == nil)\nassert(prod_signs(arr: [2, 4, 1, 2, -1, -1, 9]) == 20)\n\
    assert(prod_signs(arr: [-1, 1, -1, 1]) == 4)\nassert(prod_signs(arr: [-1, 1, 1,\
    \ 1]) == -4)\nassert(prod_signs(arr: [-1, 1, 1, 0]) == 0)"
  status: SyntaxError
  stderr: "/tmp/tmpwjkbt1j9.swift:20:20: error: cannot find 'sign_num' in scope\n\
    \        product *= sign_num(i)\n                   ^~~~~~~~\n"
  stdout: ''
  timestamp: 1659979792
- exit_code: 0
  program: "\n/// You are given an array arr of integers and you need to return\n\
    /// sum of magnitudes of integers multiplied by product of all signs\n/// of each\
    \ number in the array, represented by 1, -1 or 0.\n/// Note: return nil for empty\
    \ arr.\n/// Example:\n/// >>> prod_signs(arr: [1, 2, 2, -4])\n/// 9\n/// >>> prod_signs(arr:\
    \ [0, 1])\n/// 0\n/// >>> prod_signs(arr: [] as [Int])\n/// nil\nfunc prod_signs(arr:\
    \ [Int]) -> Int? {\n    guard arr.count > 0 else { return nil }\n    var prod\
    \ = 1\n    var sums = 0\n    for i in arr {\n        prod *= i > 0 ? 1 : (i <\
    \ 0 ? -1 : 0)\n        sums += abs(i)\n    }\n    return prod * sums\n}\n\n\n\
    func ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(prod_signs(arr: [1, 2, 2, -4]) == -9)\nassert(prod_signs(arr:\
    \ [0, 1]) == 0)\nassert(prod_signs(arr: [1, 1, 1, 2, 3, -1, 1]) == -10)\nassert(prod_signs(arr:\
    \ [] as [Int]) == nil)\nassert(prod_signs(arr: [2, 4, 1, 2, -1, -1, 9]) == 20)\n\
    assert(prod_signs(arr: [-1, 1, -1, 1]) == 4)\nassert(prod_signs(arr: [-1, 1, 1,\
    \ 1]) == -4)\nassert(prod_signs(arr: [-1, 1, 1, 0]) == 0)"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659979793
- exit_code: 0
  program: "\n/// You are given an array arr of integers and you need to return\n\
    /// sum of magnitudes of integers multiplied by product of all signs\n/// of each\
    \ number in the array, represented by 1, -1 or 0.\n/// Note: return nil for empty\
    \ arr.\n/// Example:\n/// >>> prod_signs(arr: [1, 2, 2, -4])\n/// 9\n/// >>> prod_signs(arr:\
    \ [0, 1])\n/// 0\n/// >>> prod_signs(arr: [] as [Int])\n/// nil\nfunc prod_signs(arr:\
    \ [Int]) -> Int? {\n    guard arr.count > 0 else {\n        return nil\n    }\n\
    \    let prod = arr.reduce(1) {$0 * $1.signum()}\n    let sum = arr.reduce(0)\
    \ {$0 + abs($1)}\n    return prod * sum\n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(prod_signs(arr: [1, 2, 2, -4]) == -9)\nassert(prod_signs(arr: [0, 1]) ==\
    \ 0)\nassert(prod_signs(arr: [1, 1, 1, 2, 3, -1, 1]) == -10)\nassert(prod_signs(arr:\
    \ [] as [Int]) == nil)\nassert(prod_signs(arr: [2, 4, 1, 2, -1, -1, 9]) == 20)\n\
    assert(prod_signs(arr: [-1, 1, -1, 1]) == 4)\nassert(prod_signs(arr: [-1, 1, 1,\
    \ 1]) == -4)\nassert(prod_signs(arr: [-1, 1, 1, 0]) == 0)"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659979793
- exit_code: 1
  program: "\n/// You are given an array arr of integers and you need to return\n\
    /// sum of magnitudes of integers multiplied by product of all signs\n/// of each\
    \ number in the array, represented by 1, -1 or 0.\n/// Note: return nil for empty\
    \ arr.\n/// Example:\n/// >>> prod_signs(arr: [1, 2, 2, -4])\n/// 9\n/// >>> prod_signs(arr:\
    \ [0, 1])\n/// 0\n/// >>> prod_signs(arr: [] as [Int])\n/// nil\nfunc prod_signs(arr:\
    \ [Int]) -> Int? {\n    if arr.isEmpty {\n        return nil\n    }\n    var prodSigns\
    \ = 1\n    var sumMagnitude = 0\n    for num in arr {\n        prodSigns *= sign(num)\n\
    \        sumMagnitude += magnitude(num)\n    }\n    return prodSigns * sumMagnitude\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(prod_signs(arr: [1, 2, 2, -4]) == -9)\nassert(prod_signs(arr:\
    \ [0, 1]) == 0)\nassert(prod_signs(arr: [1, 1, 1, 2, 3, -1, 1]) == -10)\nassert(prod_signs(arr:\
    \ [] as [Int]) == nil)\nassert(prod_signs(arr: [2, 4, 1, 2, -1, -1, 9]) == 20)\n\
    assert(prod_signs(arr: [-1, 1, -1, 1]) == 4)\nassert(prod_signs(arr: [-1, 1, 1,\
    \ 1]) == -4)\nassert(prod_signs(arr: [-1, 1, 1, 0]) == 0)"
  status: SyntaxError
  stderr: "/tmp/tmpbz475blr.swift:20:22: error: cannot find 'sign' in scope\n    \
    \    prodSigns *= sign(num)\n                     ^~~~\n/tmp/tmpbz475blr.swift:21:25:\
    \ error: cannot find 'magnitude' in scope\n        sumMagnitude += magnitude(num)\n\
    \                        ^~~~~~~~~\n"
  stdout: ''
  timestamp: 1659979792
- exit_code: -4
  program: "\n/// You are given an array arr of integers and you need to return\n\
    /// sum of magnitudes of integers multiplied by product of all signs\n/// of each\
    \ number in the array, represented by 1, -1 or 0.\n/// Note: return nil for empty\
    \ arr.\n/// Example:\n/// >>> prod_signs(arr: [1, 2, 2, -4])\n/// 9\n/// >>> prod_signs(arr:\
    \ [0, 1])\n/// 0\n/// >>> prod_signs(arr: [] as [Int])\n/// nil\nfunc prod_signs(arr:\
    \ [Int]) -> Int? {\n    var sum = 0\n    var prod = 1\n    for i in arr {\n  \
    \      if i > 0 {\n            sum += i\n            prod *= 1\n        } else\
    \ if i < 0 {\n            sum += -i\n            prod *= -1\n        } else {\n\
    \            sum += 0\n            prod *= 0\n        }\n    }\n    return sum\
    \ * prod\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n\
    \    if left.count != right.count {\n        return false\n    }\n    for (l,\
    \ r) in zip(left, right) {\n        if l != r {\n            return false\n  \
    \      }\n    }\n    return true\n}\n            \nassert(prod_signs(arr: [1,\
    \ 2, 2, -4]) == -9)\nassert(prod_signs(arr: [0, 1]) == 0)\nassert(prod_signs(arr:\
    \ [1, 1, 1, 2, 3, -1, 1]) == -10)\nassert(prod_signs(arr: [] as [Int]) == nil)\n\
    assert(prod_signs(arr: [2, 4, 1, 2, -1, -1, 9]) == 20)\nassert(prod_signs(arr:\
    \ [-1, 1, -1, 1]) == 4)\nassert(prod_signs(arr: [-1, 1, 1, 1]) == -4)\nassert(prod_signs(arr:\
    \ [-1, 1, 1, 0]) == 0)"
  status: Exception
  stderr: 'tmpsgpj7p7w/tmpsgpj7p7w.swift:47: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002afdbd3b1c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002afdbd0a8b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002afdbd0a8988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002afdbd0a77b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpsgpj7p7w                        0x0000560fd0bb696c <unavailable> + 6508

    5    libc.so.6                          0x00002afdbd59d460 __libc_start_main +
    245

    6    tmpsgpj7p7w                        0x0000560fd0bb60d9 <unavailable> + 4313

    '
  stdout: ''
  timestamp: 1659979793
- exit_code: 0
  program: "\n/// You are given an array arr of integers and you need to return\n\
    /// sum of magnitudes of integers multiplied by product of all signs\n/// of each\
    \ number in the array, represented by 1, -1 or 0.\n/// Note: return nil for empty\
    \ arr.\n/// Example:\n/// >>> prod_signs(arr: [1, 2, 2, -4])\n/// 9\n/// >>> prod_signs(arr:\
    \ [0, 1])\n/// 0\n/// >>> prod_signs(arr: [] as [Int])\n/// nil\nfunc prod_signs(arr:\
    \ [Int]) -> Int? {\n    guard arr.count > 0 else {\n        return nil\n    }\n\
    \    var prod: Int = 1\n    var sum: Int = 0\n    for elem in arr {\n        if\
    \ elem > 0 {\n            prod *= 1\n        } else if elem < 0 {\n          \
    \  prod *= -1\n        } else {\n            prod *= 0\n        }\n        sum\
    \ += abs(elem)\n    }\n    return sum * prod\n}\n\n\nfunc ==(left: [(Int, Int)],\
    \ right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n       \
    \ return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r\
    \ {\n            return false\n        }\n    }\n    return true\n}\n        \
    \    \nassert(prod_signs(arr: [1, 2, 2, -4]) == -9)\nassert(prod_signs(arr: [0,\
    \ 1]) == 0)\nassert(prod_signs(arr: [1, 1, 1, 2, 3, -1, 1]) == -10)\nassert(prod_signs(arr:\
    \ [] as [Int]) == nil)\nassert(prod_signs(arr: [2, 4, 1, 2, -1, -1, 9]) == 20)\n\
    assert(prod_signs(arr: [-1, 1, -1, 1]) == 4)\nassert(prod_signs(arr: [-1, 1, 1,\
    \ 1]) == -4)\nassert(prod_signs(arr: [-1, 1, 1, 0]) == 0)"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659979793
- exit_code: 0
  program: "\n/// You are given an array arr of integers and you need to return\n\
    /// sum of magnitudes of integers multiplied by product of all signs\n/// of each\
    \ number in the array, represented by 1, -1 or 0.\n/// Note: return nil for empty\
    \ arr.\n/// Example:\n/// >>> prod_signs(arr: [1, 2, 2, -4])\n/// 9\n/// >>> prod_signs(arr:\
    \ [0, 1])\n/// 0\n/// >>> prod_signs(arr: [] as [Int])\n/// nil\nfunc prod_signs(arr:\
    \ [Int]) -> Int? {\n    guard arr.count > 0 else { return nil }\n    let a = arr.map({\
    \ $0 > 0 ? 1 : ($0 < 0 ? -1 : 0) })\n    return a.reduce(1, *) * arr.map({ abs($0)\
    \ }).reduce(0, +)\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) ->\
    \ Bool {\n    if left.count != right.count {\n        return false\n    }\n  \
    \  for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(prod_signs(arr: [1,\
    \ 2, 2, -4]) == -9)\nassert(prod_signs(arr: [0, 1]) == 0)\nassert(prod_signs(arr:\
    \ [1, 1, 1, 2, 3, -1, 1]) == -10)\nassert(prod_signs(arr: [] as [Int]) == nil)\n\
    assert(prod_signs(arr: [2, 4, 1, 2, -1, -1, 9]) == 20)\nassert(prod_signs(arr:\
    \ [-1, 1, -1, 1]) == 4)\nassert(prod_signs(arr: [-1, 1, 1, 1]) == -4)\nassert(prod_signs(arr:\
    \ [-1, 1, 1, 0]) == 0)"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659979793
- exit_code: -4
  program: "\n/// You are given an array arr of integers and you need to return\n\
    /// sum of magnitudes of integers multiplied by product of all signs\n/// of each\
    \ number in the array, represented by 1, -1 or 0.\n/// Note: return nil for empty\
    \ arr.\n/// Example:\n/// >>> prod_signs(arr: [1, 2, 2, -4])\n/// 9\n/// >>> prod_signs(arr:\
    \ [0, 1])\n/// 0\n/// >>> prod_signs(arr: [] as [Int])\n/// nil\nfunc prod_signs(arr:\
    \ [Int]) -> Int? {\n    var pr = 0\n    var su = 0\n    for i in arr {\n     \
    \   su += abs(i)\n        if i > 0 {\n            pr += 1\n        } else if i\
    \ < 0 {\n            pr -= 1\n        }\n    }\n    if arr.count == 0 {\n    \
    \    return nil\n    }\n    return su * pr\n}\n\n\nfunc ==(left: [(Int, Int)],\
    \ right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n       \
    \ return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r\
    \ {\n            return false\n        }\n    }\n    return true\n}\n        \
    \    \nassert(prod_signs(arr: [1, 2, 2, -4]) == -9)\nassert(prod_signs(arr: [0,\
    \ 1]) == 0)\nassert(prod_signs(arr: [1, 1, 1, 2, 3, -1, 1]) == -10)\nassert(prod_signs(arr:\
    \ [] as [Int]) == nil)\nassert(prod_signs(arr: [2, 4, 1, 2, -1, -1, 9]) == 20)\n\
    assert(prod_signs(arr: [-1, 1, -1, 1]) == 4)\nassert(prod_signs(arr: [-1, 1, 1,\
    \ 1]) == -4)\nassert(prod_signs(arr: [-1, 1, 1, 0]) == 0)"
  status: Exception
  stderr: 'tmp8q5a3p44/tmp8q5a3p44.swift:43: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002ae649a08c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002ae6496ffb6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002ae6496ff988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002ae6496fe7b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmp8q5a3p44                        0x0000563701253689 <unavailable> + 5769

    5    libc.so.6                          0x00002ae649bf4460 __libc_start_main +
    245

    6    tmp8q5a3p44                        0x0000563701253219 <unavailable> + 4633

    '
  stdout: ''
  timestamp: 1659979793
- exit_code: -4
  program: "\n/// You are given an array arr of integers and you need to return\n\
    /// sum of magnitudes of integers multiplied by product of all signs\n/// of each\
    \ number in the array, represented by 1, -1 or 0.\n/// Note: return nil for empty\
    \ arr.\n/// Example:\n/// >>> prod_signs(arr: [1, 2, 2, -4])\n/// 9\n/// >>> prod_signs(arr:\
    \ [0, 1])\n/// 0\n/// >>> prod_signs(arr: [] as [Int])\n/// nil\nfunc prod_signs(arr:\
    \ [Int]) -> Int? {\n    if arr.isEmpty {\n        return nil\n    }\n    return\
    \ arr.map { ($0 >= 0 ? 1 : -1) * abs($0) }.reduce(1, *)\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(prod_signs(arr: [1, 2, 2, -4]) == -9)\nassert(prod_signs(arr:\
    \ [0, 1]) == 0)\nassert(prod_signs(arr: [1, 1, 1, 2, 3, -1, 1]) == -10)\nassert(prod_signs(arr:\
    \ [] as [Int]) == nil)\nassert(prod_signs(arr: [2, 4, 1, 2, -1, -1, 9]) == 20)\n\
    assert(prod_signs(arr: [-1, 1, -1, 1]) == 4)\nassert(prod_signs(arr: [-1, 1, 1,\
    \ 1]) == -4)\nassert(prod_signs(arr: [-1, 1, 1, 0]) == 0)"
  status: Exception
  stderr: 'tmpkk2xecgv/tmpkk2xecgv.swift:33: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b9515d54c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b9515a4bb6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b9515a4b988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b9515a4a7b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpkk2xecgv                        0x0000562c47736639 <unavailable> + 5689

    5    libc.so.6                          0x00002b9515f40460 __libc_start_main +
    245

    6    tmpkk2xecgv                        0x0000562c477361c9 <unavailable> + 4553

    '
  stdout: ''
  timestamp: 1659979793
- exit_code: 0
  program: "\n/// You are given an array arr of integers and you need to return\n\
    /// sum of magnitudes of integers multiplied by product of all signs\n/// of each\
    \ number in the array, represented by 1, -1 or 0.\n/// Note: return nil for empty\
    \ arr.\n/// Example:\n/// >>> prod_signs(arr: [1, 2, 2, -4])\n/// 9\n/// >>> prod_signs(arr:\
    \ [0, 1])\n/// 0\n/// >>> prod_signs(arr: [] as [Int])\n/// nil\nfunc prod_signs(arr:\
    \ [Int]) -> Int? {\n    if arr.isEmpty {\n        return nil\n    }\n    var sum\
    \ = 0\n    var product = 1\n    for number in arr {\n        sum += abs(number)\n\
    \        product *= number < 0 ? -1 : number == 0 ? 0 : 1\n    }\n    return sum\
    \ * product\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n\
    \    if left.count != right.count {\n        return false\n    }\n    for (l,\
    \ r) in zip(left, right) {\n        if l != r {\n            return false\n  \
    \      }\n    }\n    return true\n}\n            \nassert(prod_signs(arr: [1,\
    \ 2, 2, -4]) == -9)\nassert(prod_signs(arr: [0, 1]) == 0)\nassert(prod_signs(arr:\
    \ [1, 1, 1, 2, 3, -1, 1]) == -10)\nassert(prod_signs(arr: [] as [Int]) == nil)\n\
    assert(prod_signs(arr: [2, 4, 1, 2, -1, -1, 9]) == 20)\nassert(prod_signs(arr:\
    \ [-1, 1, -1, 1]) == 4)\nassert(prod_signs(arr: [-1, 1, 1, 1]) == -4)\nassert(prod_signs(arr:\
    \ [-1, 1, 1, 0]) == 0)"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659979793
- exit_code: 0
  program: "\n/// You are given an array arr of integers and you need to return\n\
    /// sum of magnitudes of integers multiplied by product of all signs\n/// of each\
    \ number in the array, represented by 1, -1 or 0.\n/// Note: return nil for empty\
    \ arr.\n/// Example:\n/// >>> prod_signs(arr: [1, 2, 2, -4])\n/// 9\n/// >>> prod_signs(arr:\
    \ [0, 1])\n/// 0\n/// >>> prod_signs(arr: [] as [Int])\n/// nil\nfunc prod_signs(arr:\
    \ [Int]) -> Int? {\n    guard arr.count > 0 else {\n        return nil\n    }\n\
    \    let prods = arr.map { (i: Int) -> Int in\n        return i > 0 ? 1 : i <\
    \ 0 ? -1 : 0\n    }\n    let signs = prods.reduce(1, *)\n    let mags = arr.map\
    \ { (i: Int) -> Int in\n        return abs(i)\n    }\n    let total = mags.reduce(0,\
    \ +)\n    return total * signs\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int,\
    \ Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n\
    \    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n          \
    \  return false\n        }\n    }\n    return true\n}\n            \nassert(prod_signs(arr:\
    \ [1, 2, 2, -4]) == -9)\nassert(prod_signs(arr: [0, 1]) == 0)\nassert(prod_signs(arr:\
    \ [1, 1, 1, 2, 3, -1, 1]) == -10)\nassert(prod_signs(arr: [] as [Int]) == nil)\n\
    assert(prod_signs(arr: [2, 4, 1, 2, -1, -1, 9]) == 20)\nassert(prod_signs(arr:\
    \ [-1, 1, -1, 1]) == 4)\nassert(prod_signs(arr: [-1, 1, 1, 1]) == -4)\nassert(prod_signs(arr:\
    \ [-1, 1, 1, 0]) == 0)"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659979793
- exit_code: 1
  program: "\n/// You are given an array arr of integers and you need to return\n\
    /// sum of magnitudes of integers multiplied by product of all signs\n/// of each\
    \ number in the array, represented by 1, -1 or 0.\n/// Note: return nil for empty\
    \ arr.\n/// Example:\n/// >>> prod_signs(arr: [1, 2, 2, -4])\n/// 9\n/// >>> prod_signs(arr:\
    \ [0, 1])\n/// 0\n/// >>> prod_signs(arr: [] as [Int])\n/// nil\nfunc prod_signs(arr:\
    \ [Int]) -> Int? {\n    if arr.isEmpty {\n        return nil\n    }\n    return\
    \ arr.reduce(1) { a, b in\n        a * b * sign(b)\n    }\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(prod_signs(arr: [1, 2, 2, -4]) == -9)\nassert(prod_signs(arr:\
    \ [0, 1]) == 0)\nassert(prod_signs(arr: [1, 1, 1, 2, 3, -1, 1]) == -10)\nassert(prod_signs(arr:\
    \ [] as [Int]) == nil)\nassert(prod_signs(arr: [2, 4, 1, 2, -1, -1, 9]) == 20)\n\
    assert(prod_signs(arr: [-1, 1, -1, 1]) == 4)\nassert(prod_signs(arr: [-1, 1, 1,\
    \ 1]) == -4)\nassert(prod_signs(arr: [-1, 1, 1, 0]) == 0)"
  status: SyntaxError
  stderr: "/tmp/tmp1nv6kgjs.swift:18:17: error: cannot find 'sign' in scope\n    \
    \    a * b * sign(b)\n                ^~~~\n"
  stdout: ''
  timestamp: 1659979793
- exit_code: -4
  program: "\n/// You are given an array arr of integers and you need to return\n\
    /// sum of magnitudes of integers multiplied by product of all signs\n/// of each\
    \ number in the array, represented by 1, -1 or 0.\n/// Note: return nil for empty\
    \ arr.\n/// Example:\n/// >>> prod_signs(arr: [1, 2, 2, -4])\n/// 9\n/// >>> prod_signs(arr:\
    \ [0, 1])\n/// 0\n/// >>> prod_signs(arr: [] as [Int])\n/// nil\nfunc prod_signs(arr:\
    \ [Int]) -> Int? {\n    if arr.isEmpty {\n        return nil\n    }\n    var sum\
    \ = 0\n    var sign = 1\n    for num in arr {\n        sum += abs(num)\n     \
    \   if num != 0 {\n            sign *= num > 0 ? 1 : -1\n        }\n    }\n  \
    \  return sum * sign\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(prod_signs(arr:\
    \ [1, 2, 2, -4]) == -9)\nassert(prod_signs(arr: [0, 1]) == 0)\nassert(prod_signs(arr:\
    \ [1, 1, 1, 2, 3, -1, 1]) == -10)\nassert(prod_signs(arr: [] as [Int]) == nil)\n\
    assert(prod_signs(arr: [2, 4, 1, 2, -1, -1, 9]) == 20)\nassert(prod_signs(arr:\
    \ [-1, 1, -1, 1]) == 4)\nassert(prod_signs(arr: [-1, 1, 1, 1]) == -4)\nassert(prod_signs(arr:\
    \ [-1, 1, 1, 0]) == 0)"
  status: Exception
  stderr: 'tmpvpj5utd0/tmpvpj5utd0.swift:42: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b1a89c10c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b1a89907b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b1a89907988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b1a899067b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpvpj5utd0                        0x000055b36a894815 <unavailable> + 6165

    5    libc.so.6                          0x00002b1a89dfc460 __libc_start_main +
    245

    6    tmpvpj5utd0                        0x000055b36a894219 <unavailable> + 4633

    '
  stdout: ''
  timestamp: 1659979793
- exit_code: 0
  program: "\n/// You are given an array arr of integers and you need to return\n\
    /// sum of magnitudes of integers multiplied by product of all signs\n/// of each\
    \ number in the array, represented by 1, -1 or 0.\n/// Note: return nil for empty\
    \ arr.\n/// Example:\n/// >>> prod_signs(arr: [1, 2, 2, -4])\n/// 9\n/// >>> prod_signs(arr:\
    \ [0, 1])\n/// 0\n/// >>> prod_signs(arr: [] as [Int])\n/// nil\nfunc prod_signs(arr:\
    \ [Int]) -> Int? {\n    guard arr.count > 0 else { return nil }\n    let signs\
    \ = arr.compactMap { $0 > 0 ? 1 : $0 < 0 ? -1 : 0 }\n    return signs.reduce(1,\
    \ *) * arr.reduce(0, { $0 + abs($1) })\n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(prod_signs(arr: [1, 2, 2, -4]) == -9)\nassert(prod_signs(arr: [0, 1]) ==\
    \ 0)\nassert(prod_signs(arr: [1, 1, 1, 2, 3, -1, 1]) == -10)\nassert(prod_signs(arr:\
    \ [] as [Int]) == nil)\nassert(prod_signs(arr: [2, 4, 1, 2, -1, -1, 9]) == 20)\n\
    assert(prod_signs(arr: [-1, 1, -1, 1]) == 4)\nassert(prod_signs(arr: [-1, 1, 1,\
    \ 1]) == -4)\nassert(prod_signs(arr: [-1, 1, 1, 0]) == 0)"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659979793
- exit_code: 0
  program: "\n/// You are given an array arr of integers and you need to return\n\
    /// sum of magnitudes of integers multiplied by product of all signs\n/// of each\
    \ number in the array, represented by 1, -1 or 0.\n/// Note: return nil for empty\
    \ arr.\n/// Example:\n/// >>> prod_signs(arr: [1, 2, 2, -4])\n/// 9\n/// >>> prod_signs(arr:\
    \ [0, 1])\n/// 0\n/// >>> prod_signs(arr: [] as [Int])\n/// nil\nfunc prod_signs(arr:\
    \ [Int]) -> Int? {\n    guard arr.count > 0 else { return nil }\n    let a = arr.map\
    \ { $0 < 0 ? -1 : $0 > 0 ? 1 : 0 }\n    let b = arr.map { abs($0) }\n    let p\
    \ = a.reduce(1, *)\n    let s = b.reduce(0, +)\n    return p * s\n}\n\n\nfunc\
    \ ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count !=\
    \ right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(prod_signs(arr: [1, 2, 2, -4]) == -9)\nassert(prod_signs(arr:\
    \ [0, 1]) == 0)\nassert(prod_signs(arr: [1, 1, 1, 2, 3, -1, 1]) == -10)\nassert(prod_signs(arr:\
    \ [] as [Int]) == nil)\nassert(prod_signs(arr: [2, 4, 1, 2, -1, -1, 9]) == 20)\n\
    assert(prod_signs(arr: [-1, 1, -1, 1]) == 4)\nassert(prod_signs(arr: [-1, 1, 1,\
    \ 1]) == -4)\nassert(prod_signs(arr: [-1, 1, 1, 0]) == 0)"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659979793
- exit_code: -4
  program: "\n/// You are given an array arr of integers and you need to return\n\
    /// sum of magnitudes of integers multiplied by product of all signs\n/// of each\
    \ number in the array, represented by 1, -1 or 0.\n/// Note: return nil for empty\
    \ arr.\n/// Example:\n/// >>> prod_signs(arr: [1, 2, 2, -4])\n/// 9\n/// >>> prod_signs(arr:\
    \ [0, 1])\n/// 0\n/// >>> prod_signs(arr: [] as [Int])\n/// nil\nfunc prod_signs(arr:\
    \ [Int]) -> Int? {\n\tguard arr.count > 0 else {\n\t\treturn nil\n\t}\n\tvar prod\
    \ = 1\n\tfor num in arr {\n\t\tif num == 0 {\n\t\t\tcontinue\n\t\t}\n\t\tprod\
    \ *= num > 0 ? 1 : -1\n\t}\n\treturn arr.map { abs($0) }.reduce(0, +) * prod\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(prod_signs(arr: [1, 2, 2, -4]) == -9)\nassert(prod_signs(arr:\
    \ [0, 1]) == 0)\nassert(prod_signs(arr: [1, 1, 1, 2, 3, -1, 1]) == -10)\nassert(prod_signs(arr:\
    \ [] as [Int]) == nil)\nassert(prod_signs(arr: [2, 4, 1, 2, -1, -1, 9]) == 20)\n\
    assert(prod_signs(arr: [-1, 1, -1, 1]) == 4)\nassert(prod_signs(arr: [-1, 1, 1,\
    \ 1]) == -4)\nassert(prod_signs(arr: [-1, 1, 1, 0]) == 0)"
  status: Exception
  stderr: 'tmpbbuv_gcv/tmpbbuv_gcv.swift:41: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b5846bdac80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b58468d1b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b58468d1988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b58468d07b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpbbuv_gcv                        0x0000559df966e8f5 <unavailable> + 6389

    5    libc.so.6                          0x00002b5846dc6460 __libc_start_main +
    245

    6    tmpbbuv_gcv                        0x0000559df966e2f9 <unavailable> + 4857

    '
  stdout: ''
  timestamp: 1659979793
- exit_code: 0
  program: "\n/// You are given an array arr of integers and you need to return\n\
    /// sum of magnitudes of integers multiplied by product of all signs\n/// of each\
    \ number in the array, represented by 1, -1 or 0.\n/// Note: return nil for empty\
    \ arr.\n/// Example:\n/// >>> prod_signs(arr: [1, 2, 2, -4])\n/// 9\n/// >>> prod_signs(arr:\
    \ [0, 1])\n/// 0\n/// >>> prod_signs(arr: [] as [Int])\n/// nil\nfunc prod_signs(arr:\
    \ [Int]) -> Int? {\n    let isEmpty = arr.isEmpty\n    guard !isEmpty else { return\
    \ nil }\n    let signs = arr.map { (number) -> Int in\n        if number > 0 {\n\
    \            return 1\n        } else if number < 0 {\n            return -1\n\
    \        } else {\n            return 0\n        }\n    }\n    let product = signs.reduce(1,\
    \ *)\n    let absoluteNumbers = arr.map { abs($0) }\n    let sum = absoluteNumbers.reduce(0,\
    \ +)\n    return sum * product\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int,\
    \ Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n\
    \    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n          \
    \  return false\n        }\n    }\n    return true\n}\n            \nassert(prod_signs(arr:\
    \ [1, 2, 2, -4]) == -9)\nassert(prod_signs(arr: [0, 1]) == 0)\nassert(prod_signs(arr:\
    \ [1, 1, 1, 2, 3, -1, 1]) == -10)\nassert(prod_signs(arr: [] as [Int]) == nil)\n\
    assert(prod_signs(arr: [2, 4, 1, 2, -1, -1, 9]) == 20)\nassert(prod_signs(arr:\
    \ [-1, 1, -1, 1]) == 4)\nassert(prod_signs(arr: [-1, 1, 1, 1]) == -4)\nassert(prod_signs(arr:\
    \ [-1, 1, 1, 0]) == 0)"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659979793
- exit_code: -4
  program: "\n/// You are given an array arr of integers and you need to return\n\
    /// sum of magnitudes of integers multiplied by product of all signs\n/// of each\
    \ number in the array, represented by 1, -1 or 0.\n/// Note: return nil for empty\
    \ arr.\n/// Example:\n/// >>> prod_signs(arr: [1, 2, 2, -4])\n/// 9\n/// >>> prod_signs(arr:\
    \ [0, 1])\n/// 0\n/// >>> prod_signs(arr: [] as [Int])\n/// nil\nfunc prod_signs(arr:\
    \ [Int]) -> Int? {\n    var result: Int? = nil\n    if !arr.isEmpty {\n      \
    \  result = 0\n        var product = 1\n        for num in arr {\n           \
    \ if num > 0 {\n                result! += num\n            } else if num < 0\
    \ {\n                result! += -num\n                product *= -1\n        \
    \    }\n        }\n        result! *= product\n    }\n    return result\n}\n\n\
    \nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(prod_signs(arr: [1, 2, 2, -4]) == -9)\nassert(prod_signs(arr:\
    \ [0, 1]) == 0)\nassert(prod_signs(arr: [1, 1, 1, 2, 3, -1, 1]) == -10)\nassert(prod_signs(arr:\
    \ [] as [Int]) == nil)\nassert(prod_signs(arr: [2, 4, 1, 2, -1, -1, 9]) == 20)\n\
    assert(prod_signs(arr: [-1, 1, -1, 1]) == 4)\nassert(prod_signs(arr: [-1, 1, 1,\
    \ 1]) == -4)\nassert(prod_signs(arr: [-1, 1, 1, 0]) == 0)"
  status: Exception
  stderr: 'tmpdadsat2r/tmpdadsat2r.swift:45: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b54bdcaec80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b54bd9a5b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b54bd9a5988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b54bd9a47b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpdadsat2r                        0x00005605ecb857b5 <unavailable> + 6069

    5    libc.so.6                          0x00002b54bde9a460 __libc_start_main +
    245

    6    tmpdadsat2r                        0x00005605ecb851b9 <unavailable> + 4537

    '
  stdout: ''
  timestamp: 1659979793
- exit_code: -4
  program: "\n/// You are given an array arr of integers and you need to return\n\
    /// sum of magnitudes of integers multiplied by product of all signs\n/// of each\
    \ number in the array, represented by 1, -1 or 0.\n/// Note: return nil for empty\
    \ arr.\n/// Example:\n/// >>> prod_signs(arr: [1, 2, 2, -4])\n/// 9\n/// >>> prod_signs(arr:\
    \ [0, 1])\n/// 0\n/// >>> prod_signs(arr: [] as [Int])\n/// nil\nfunc prod_signs(arr:\
    \ [Int]) -> Int? {\n  return nil\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int,\
    \ Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n\
    \    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n          \
    \  return false\n        }\n    }\n    return true\n}\n            \nassert(prod_signs(arr:\
    \ [1, 2, 2, -4]) == -9)\nassert(prod_signs(arr: [0, 1]) == 0)\nassert(prod_signs(arr:\
    \ [1, 1, 1, 2, 3, -1, 1]) == -10)\nassert(prod_signs(arr: [] as [Int]) == nil)\n\
    assert(prod_signs(arr: [2, 4, 1, 2, -1, -1, 9]) == 20)\nassert(prod_signs(arr:\
    \ [-1, 1, -1, 1]) == 4)\nassert(prod_signs(arr: [-1, 1, 1, 1]) == -4)\nassert(prod_signs(arr:\
    \ [-1, 1, 1, 0]) == 0)"
  status: Exception
  stderr: 'tmpy4xc0hy9/tmpy4xc0hy9.swift:30: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b84f78ddc80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b84f75d4b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b84f75d4988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b84f75d37b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpy4xc0hy9                        0x000055a66892d3d9 <unavailable> + 5081

    5    libc.so.6                          0x00002b84f7ac9460 __libc_start_main +
    245

    6    tmpy4xc0hy9                        0x000055a66892cf69 <unavailable> + 3945

    '
  stdout: ''
  timestamp: 1659979792
- exit_code: -4
  program: "\n/// You are given an array arr of integers and you need to return\n\
    /// sum of magnitudes of integers multiplied by product of all signs\n/// of each\
    \ number in the array, represented by 1, -1 or 0.\n/// Note: return nil for empty\
    \ arr.\n/// Example:\n/// >>> prod_signs(arr: [1, 2, 2, -4])\n/// 9\n/// >>> prod_signs(arr:\
    \ [0, 1])\n/// 0\n/// >>> prod_signs(arr: [] as [Int])\n/// nil\nfunc prod_signs(arr:\
    \ [Int]) -> Int? {\n    let product = arr.reduce(1) { result, next in\n      \
    \  result * (next == 0 ? 1 : next > 0 ? 1 : -1)\n    }\n    let sum = arr.reduce(0)\
    \ { result, next in\n        result + abs(next)\n    }\n    return sum * product\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(prod_signs(arr: [1, 2, 2, -4]) == -9)\nassert(prod_signs(arr:\
    \ [0, 1]) == 0)\nassert(prod_signs(arr: [1, 1, 1, 2, 3, -1, 1]) == -10)\nassert(prod_signs(arr:\
    \ [] as [Int]) == nil)\nassert(prod_signs(arr: [2, 4, 1, 2, -1, -1, 9]) == 20)\n\
    assert(prod_signs(arr: [-1, 1, -1, 1]) == 4)\nassert(prod_signs(arr: [-1, 1, 1,\
    \ 1]) == -4)\nassert(prod_signs(arr: [-1, 1, 1, 0]) == 0)"
  status: Exception
  stderr: 'tmpoee2e4n4/tmpoee2e4n4.swift:37: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b6dfe18cc80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b6dfde83b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b6dfde83988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b6dfde827b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpoee2e4n4                        0x000055ccdba576c5 <unavailable> + 5829

    5    libc.so.6                          0x00002b6dfe378460 __libc_start_main +
    245

    6    tmpoee2e4n4                        0x000055ccdba570c9 <unavailable> + 4297

    '
  stdout: ''
  timestamp: 1659979793
- exit_code: -4
  program: "\n/// You are given an array arr of integers and you need to return\n\
    /// sum of magnitudes of integers multiplied by product of all signs\n/// of each\
    \ number in the array, represented by 1, -1 or 0.\n/// Note: return nil for empty\
    \ arr.\n/// Example:\n/// >>> prod_signs(arr: [1, 2, 2, -4])\n/// 9\n/// >>> prod_signs(arr:\
    \ [0, 1])\n/// 0\n/// >>> prod_signs(arr: [] as [Int])\n/// nil\nfunc prod_signs(arr:\
    \ [Int]) -> Int? {\n  guard !arr.isEmpty else { return nil }\n  var sign = 1\n\
    \  var sum = 0\n  for num in arr {\n    if num < 0 {\n      sign *= -1\n    }\n\
    \    sum += abs(num)\n  }\n  return sum * sign\n}\n\n\nfunc ==(left: [(Int, Int)],\
    \ right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n       \
    \ return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r\
    \ {\n            return false\n        }\n    }\n    return true\n}\n        \
    \    \nassert(prod_signs(arr: [1, 2, 2, -4]) == -9)\nassert(prod_signs(arr: [0,\
    \ 1]) == 0)\nassert(prod_signs(arr: [1, 1, 1, 2, 3, -1, 1]) == -10)\nassert(prod_signs(arr:\
    \ [] as [Int]) == nil)\nassert(prod_signs(arr: [2, 4, 1, 2, -1, -1, 9]) == 20)\n\
    assert(prod_signs(arr: [-1, 1, -1, 1]) == 4)\nassert(prod_signs(arr: [-1, 1, 1,\
    \ 1]) == -4)\nassert(prod_signs(arr: [-1, 1, 1, 0]) == 0)"
  status: Exception
  stderr: 'tmp1hiix1de/tmp1hiix1de.swift:40: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b3e16d5bc80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b3e16a52b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b3e16a52988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b3e16a517b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmp1hiix1de                        0x000055bc67f5f815 <unavailable> + 6165

    5    libc.so.6                          0x00002b3e16f47460 __libc_start_main +
    245

    6    tmp1hiix1de                        0x000055bc67f5f219 <unavailable> + 4633

    '
  stdout: ''
  timestamp: 1659979793
- exit_code: -4
  program: "\n/// You are given an array arr of integers and you need to return\n\
    /// sum of magnitudes of integers multiplied by product of all signs\n/// of each\
    \ number in the array, represented by 1, -1 or 0.\n/// Note: return nil for empty\
    \ arr.\n/// Example:\n/// >>> prod_signs(arr: [1, 2, 2, -4])\n/// 9\n/// >>> prod_signs(arr:\
    \ [0, 1])\n/// 0\n/// >>> prod_signs(arr: [] as [Int])\n/// nil\nfunc prod_signs(arr:\
    \ [Int]) -> Int? {\n    return nil\n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(prod_signs(arr: [1, 2, 2, -4]) == -9)\nassert(prod_signs(arr: [0, 1]) ==\
    \ 0)\nassert(prod_signs(arr: [1, 1, 1, 2, 3, -1, 1]) == -10)\nassert(prod_signs(arr:\
    \ [] as [Int]) == nil)\nassert(prod_signs(arr: [2, 4, 1, 2, -1, -1, 9]) == 20)\n\
    assert(prod_signs(arr: [-1, 1, -1, 1]) == 4)\nassert(prod_signs(arr: [-1, 1, 1,\
    \ 1]) == -4)\nassert(prod_signs(arr: [-1, 1, 1, 0]) == 0)"
  status: Exception
  stderr: 'tmp1rt4wv_3/tmp1rt4wv_3.swift:30: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b2a15132c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b2a14e29b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b2a14e29988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b2a14e287b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmp1rt4wv_3                        0x00005652a02c73d9 <unavailable> + 5081

    5    libc.so.6                          0x00002b2a1531e460 __libc_start_main +
    245

    6    tmp1rt4wv_3                        0x00005652a02c6f69 <unavailable> + 3945

    '
  stdout: ''
  timestamp: 1659979791
- exit_code: 0
  program: "\n/// You are given an array arr of integers and you need to return\n\
    /// sum of magnitudes of integers multiplied by product of all signs\n/// of each\
    \ number in the array, represented by 1, -1 or 0.\n/// Note: return nil for empty\
    \ arr.\n/// Example:\n/// >>> prod_signs(arr: [1, 2, 2, -4])\n/// 9\n/// >>> prod_signs(arr:\
    \ [0, 1])\n/// 0\n/// >>> prod_signs(arr: [] as [Int])\n/// nil\nfunc prod_signs(arr:\
    \ [Int]) -> Int? {\n    guard arr.count > 0 else { return nil }\n    return arr.reduce(1)\
    \ { $0 * ($1 > 0 ? 1 : $1 < 0 ? -1 : 0) } * arr.reduce(0) { $0 + abs($1) }\n}\n\
    \n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(prod_signs(arr: [1, 2, 2, -4]) == -9)\nassert(prod_signs(arr:\
    \ [0, 1]) == 0)\nassert(prod_signs(arr: [1, 1, 1, 2, 3, -1, 1]) == -10)\nassert(prod_signs(arr:\
    \ [] as [Int]) == nil)\nassert(prod_signs(arr: [2, 4, 1, 2, -1, -1, 9]) == 20)\n\
    assert(prod_signs(arr: [-1, 1, -1, 1]) == 4)\nassert(prod_signs(arr: [-1, 1, 1,\
    \ 1]) == -4)\nassert(prod_signs(arr: [-1, 1, 1, 0]) == 0)"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659979793
- exit_code: 1
  program: "\n/// You are given an array arr of integers and you need to return\n\
    /// sum of magnitudes of integers multiplied by product of all signs\n/// of each\
    \ number in the array, represented by 1, -1 or 0.\n/// Note: return nil for empty\
    \ arr.\n/// Example:\n/// >>> prod_signs(arr: [1, 2, 2, -4])\n/// 9\n/// >>> prod_signs(arr:\
    \ [0, 1])\n/// 0\n/// >>> prod_signs(arr: [] as [Int])\n/// nil\nfunc prod_signs(arr:\
    \ [Int]) -> Int? {\n    var sum = 0\n    var prod = 1\n    for num in arr {\n\
    \        sum += abs(num)\n        prod *= sign(num)\n    }\n    return sum * prod\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(prod_signs(arr: [1, 2, 2, -4]) == -9)\nassert(prod_signs(arr:\
    \ [0, 1]) == 0)\nassert(prod_signs(arr: [1, 1, 1, 2, 3, -1, 1]) == -10)\nassert(prod_signs(arr:\
    \ [] as [Int]) == nil)\nassert(prod_signs(arr: [2, 4, 1, 2, -1, -1, 9]) == 20)\n\
    assert(prod_signs(arr: [-1, 1, -1, 1]) == 4)\nassert(prod_signs(arr: [-1, 1, 1,\
    \ 1]) == -4)\nassert(prod_signs(arr: [-1, 1, 1, 0]) == 0)"
  status: SyntaxError
  stderr: "/tmp/tmpxc5vab3g.swift:18:17: error: cannot find 'sign' in scope\n    \
    \    prod *= sign(num)\n                ^~~~\n"
  stdout: ''
  timestamp: 1659979793
- exit_code: -4
  program: "\n/// You are given an array arr of integers and you need to return\n\
    /// sum of magnitudes of integers multiplied by product of all signs\n/// of each\
    \ number in the array, represented by 1, -1 or 0.\n/// Note: return nil for empty\
    \ arr.\n/// Example:\n/// >>> prod_signs(arr: [1, 2, 2, -4])\n/// 9\n/// >>> prod_signs(arr:\
    \ [0, 1])\n/// 0\n/// >>> prod_signs(arr: [] as [Int])\n/// nil\nfunc prod_signs(arr:\
    \ [Int]) -> Int? {\n    var result: Int = 0\n    var count: Int = 0\n    for num\
    \ in arr {\n        if num > 0 {\n            result += num\n            count\
    \ += 1\n        } else if num < 0 {\n            result += num\n            count\
    \ -= 1\n        }\n    }\n    if arr.count == 0 {\n        return nil\n    }\n\
    \    return result * count\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(prod_signs(arr:\
    \ [1, 2, 2, -4]) == -9)\nassert(prod_signs(arr: [0, 1]) == 0)\nassert(prod_signs(arr:\
    \ [1, 1, 1, 2, 3, -1, 1]) == -10)\nassert(prod_signs(arr: [] as [Int]) == nil)\n\
    assert(prod_signs(arr: [2, 4, 1, 2, -1, -1, 9]) == 20)\nassert(prod_signs(arr:\
    \ [-1, 1, -1, 1]) == 4)\nassert(prod_signs(arr: [-1, 1, 1, 1]) == -4)\nassert(prod_signs(arr:\
    \ [-1, 1, 1, 0]) == 0)"
  status: Exception
  stderr: 'tmpkqkbv_y7/tmpkqkbv_y7.swift:44: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002ba5778b0c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002ba5775a7b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002ba5775a7988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002ba5775a67b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpkqkbv_y7                        0x0000564cf1979599 <unavailable> + 5529

    5    libc.so.6                          0x00002ba577a9c460 __libc_start_main +
    245

    6    tmpkqkbv_y7                        0x0000564cf1979129 <unavailable> + 4393

    '
  stdout: ''
  timestamp: 1659979793
- exit_code: -4
  program: "\n/// You are given an array arr of integers and you need to return\n\
    /// sum of magnitudes of integers multiplied by product of all signs\n/// of each\
    \ number in the array, represented by 1, -1 or 0.\n/// Note: return nil for empty\
    \ arr.\n/// Example:\n/// >>> prod_signs(arr: [1, 2, 2, -4])\n/// 9\n/// >>> prod_signs(arr:\
    \ [0, 1])\n/// 0\n/// >>> prod_signs(arr: [] as [Int])\n/// nil\nfunc prod_signs(arr:\
    \ [Int]) -> Int? {\n    guard arr.count > 0 else {\n        return nil\n    }\n\
    \    return arr.reduce(1) { (acc, n) in\n        acc * (n < 0 ? -1 : n > 0 ? 1\
    \ : 0) * abs(n)\n    }\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(prod_signs(arr:\
    \ [1, 2, 2, -4]) == -9)\nassert(prod_signs(arr: [0, 1]) == 0)\nassert(prod_signs(arr:\
    \ [1, 1, 1, 2, 3, -1, 1]) == -10)\nassert(prod_signs(arr: [] as [Int]) == nil)\n\
    assert(prod_signs(arr: [2, 4, 1, 2, -1, -1, 9]) == 20)\nassert(prod_signs(arr:\
    \ [-1, 1, -1, 1]) == 4)\nassert(prod_signs(arr: [-1, 1, 1, 1]) == -4)\nassert(prod_signs(arr:\
    \ [-1, 1, 1, 0]) == 0)"
  status: Exception
  stderr: 'tmpkzz0qo01/tmpkzz0qo01.swift:35: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b1da80adc80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b1da7da4b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b1da7da4988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b1da7da37b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpkzz0qo01                        0x00005647237fd599 <unavailable> + 5529

    5    libc.so.6                          0x00002b1da8299460 __libc_start_main +
    245

    6    tmpkzz0qo01                        0x00005647237fd129 <unavailable> + 4393

    '
  stdout: ''
  timestamp: 1659979793
- exit_code: 0
  program: "\n/// You are given an array arr of integers and you need to return\n\
    /// sum of magnitudes of integers multiplied by product of all signs\n/// of each\
    \ number in the array, represented by 1, -1 or 0.\n/// Note: return nil for empty\
    \ arr.\n/// Example:\n/// >>> prod_signs(arr: [1, 2, 2, -4])\n/// 9\n/// >>> prod_signs(arr:\
    \ [0, 1])\n/// 0\n/// >>> prod_signs(arr: [] as [Int])\n/// nil\nfunc prod_signs(arr:\
    \ [Int]) -> Int? {\n    return arr.isEmpty ? nil : arr.map { $0 > 0 ? 1 : $0 <\
    \ 0 ? -1 : 0 }.reduce(1, *) * arr.map { abs($0) }.reduce(0, +)\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(prod_signs(arr: [1, 2, 2, -4]) == -9)\nassert(prod_signs(arr:\
    \ [0, 1]) == 0)\nassert(prod_signs(arr: [1, 1, 1, 2, 3, -1, 1]) == -10)\nassert(prod_signs(arr:\
    \ [] as [Int]) == nil)\nassert(prod_signs(arr: [2, 4, 1, 2, -1, -1, 9]) == 20)\n\
    assert(prod_signs(arr: [-1, 1, -1, 1]) == 4)\nassert(prod_signs(arr: [-1, 1, 1,\
    \ 1]) == -4)\nassert(prod_signs(arr: [-1, 1, 1, 0]) == 0)"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659979793
- exit_code: 0
  program: "\n/// You are given an array arr of integers and you need to return\n\
    /// sum of magnitudes of integers multiplied by product of all signs\n/// of each\
    \ number in the array, represented by 1, -1 or 0.\n/// Note: return nil for empty\
    \ arr.\n/// Example:\n/// >>> prod_signs(arr: [1, 2, 2, -4])\n/// 9\n/// >>> prod_signs(arr:\
    \ [0, 1])\n/// 0\n/// >>> prod_signs(arr: [] as [Int])\n/// nil\nfunc prod_signs(arr:\
    \ [Int]) -> Int? {\n    if arr.isEmpty {\n        return nil\n    }\n    let signs\
    \ = arr.map { $0 == 0 ? 0 : $0 > 0 ? 1 : -1 }\n    let sum = arr.map { abs($0)\
    \ }.reduce(0, +)\n    let sign = signs.reduce(1, *)\n    return sum * sign\n}\n\
    \n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(prod_signs(arr: [1, 2, 2, -4]) == -9)\nassert(prod_signs(arr:\
    \ [0, 1]) == 0)\nassert(prod_signs(arr: [1, 1, 1, 2, 3, -1, 1]) == -10)\nassert(prod_signs(arr:\
    \ [] as [Int]) == nil)\nassert(prod_signs(arr: [2, 4, 1, 2, -1, -1, 9]) == 20)\n\
    assert(prod_signs(arr: [-1, 1, -1, 1]) == 4)\nassert(prod_signs(arr: [-1, 1, 1,\
    \ 1]) == -4)\nassert(prod_signs(arr: [-1, 1, 1, 0]) == 0)"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659979793
- exit_code: -4
  program: "\n/// You are given an array arr of integers and you need to return\n\
    /// sum of magnitudes of integers multiplied by product of all signs\n/// of each\
    \ number in the array, represented by 1, -1 or 0.\n/// Note: return nil for empty\
    \ arr.\n/// Example:\n/// >>> prod_signs(arr: [1, 2, 2, -4])\n/// 9\n/// >>> prod_signs(arr:\
    \ [0, 1])\n/// 0\n/// >>> prod_signs(arr: [] as [Int])\n/// nil\nfunc prod_signs(arr:\
    \ [Int]) -> Int? {\n    guard arr.count > 0 else { return nil }\n    var output\
    \ = 0\n    for i in arr {\n        output += i > 0 ? 1 : i < 0 ? -1 : 0\n    }\n\
    \    for i in arr {\n        output *= i > 0 ? 1 : i < 0 ? -1 : 0\n    }\n   \
    \ return output\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool\
    \ {\n    if left.count != right.count {\n        return false\n    }\n    for\
    \ (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(prod_signs(arr: [1,\
    \ 2, 2, -4]) == -9)\nassert(prod_signs(arr: [0, 1]) == 0)\nassert(prod_signs(arr:\
    \ [1, 1, 1, 2, 3, -1, 1]) == -10)\nassert(prod_signs(arr: [] as [Int]) == nil)\n\
    assert(prod_signs(arr: [2, 4, 1, 2, -1, -1, 9]) == 20)\nassert(prod_signs(arr:\
    \ [-1, 1, -1, 1]) == 4)\nassert(prod_signs(arr: [-1, 1, 1, 1]) == -4)\nassert(prod_signs(arr:\
    \ [-1, 1, 1, 0]) == 0)"
  status: Exception
  stderr: 'tmpamzoydg0/tmpamzoydg0.swift:38: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b25d6d42c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b25d6a39b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b25d6a39988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b25d6a387b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpamzoydg0                        0x000056532c434599 <unavailable> + 5529

    5    libc.so.6                          0x00002b25d6f2e460 __libc_start_main +
    245

    6    tmpamzoydg0                        0x000056532c434129 <unavailable> + 4393

    '
  stdout: ''
  timestamp: 1659979793
- exit_code: -4
  program: "\n/// You are given an array arr of integers and you need to return\n\
    /// sum of magnitudes of integers multiplied by product of all signs\n/// of each\
    \ number in the array, represented by 1, -1 or 0.\n/// Note: return nil for empty\
    \ arr.\n/// Example:\n/// >>> prod_signs(arr: [1, 2, 2, -4])\n/// 9\n/// >>> prod_signs(arr:\
    \ [0, 1])\n/// 0\n/// >>> prod_signs(arr: [] as [Int])\n/// nil\nfunc prod_signs(arr:\
    \ [Int]) -> Int? {\n    return arr.count > 0 ? arr.map{ $0 >= 0 ? 1 : -1 }.reduce(1,\
    \ *) * arr.map{ abs($0) }.reduce(0, +) : nil\n}\n\n\nfunc ==(left: [(Int, Int)],\
    \ right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n       \
    \ return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r\
    \ {\n            return false\n        }\n    }\n    return true\n}\n        \
    \    \nassert(prod_signs(arr: [1, 2, 2, -4]) == -9)\nassert(prod_signs(arr: [0,\
    \ 1]) == 0)\nassert(prod_signs(arr: [1, 1, 1, 2, 3, -1, 1]) == -10)\nassert(prod_signs(arr:\
    \ [] as [Int]) == nil)\nassert(prod_signs(arr: [2, 4, 1, 2, -1, -1, 9]) == 20)\n\
    assert(prod_signs(arr: [-1, 1, -1, 1]) == 4)\nassert(prod_signs(arr: [-1, 1, 1,\
    \ 1]) == -4)\nassert(prod_signs(arr: [-1, 1, 1, 0]) == 0)"
  status: Exception
  stderr: 'tmp2bth9f61/tmp2bth9f61.swift:31: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b0d34bedc80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b0d348e4b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b0d348e4988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b0d348e37b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmp2bth9f61                        0x000055642bc0a7d5 <unavailable> + 6101

    5    libc.so.6                          0x00002b0d34dd9460 __libc_start_main +
    245

    6    tmp2bth9f61                        0x000055642bc0a1d9 <unavailable> + 4569

    '
  stdout: ''
  timestamp: 1659979793
- exit_code: 0
  program: "\n/// You are given an array arr of integers and you need to return\n\
    /// sum of magnitudes of integers multiplied by product of all signs\n/// of each\
    \ number in the array, represented by 1, -1 or 0.\n/// Note: return nil for empty\
    \ arr.\n/// Example:\n/// >>> prod_signs(arr: [1, 2, 2, -4])\n/// 9\n/// >>> prod_signs(arr:\
    \ [0, 1])\n/// 0\n/// >>> prod_signs(arr: [] as [Int])\n/// nil\nfunc prod_signs(arr:\
    \ [Int]) -> Int? {\n    guard arr.count > 0 else {\n        return nil\n    }\n\
    \    var product = 1\n    var sum = 0\n    for num in arr {\n        product *=\
    \ num > 0 ? 1 : num < 0 ? -1 : 0\n        sum += abs(num)\n    }\n    return product\
    \ * sum\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n \
    \   if left.count != right.count {\n        return false\n    }\n    for (l, r)\
    \ in zip(left, right) {\n        if l != r {\n            return false\n     \
    \   }\n    }\n    return true\n}\n            \nassert(prod_signs(arr: [1, 2,\
    \ 2, -4]) == -9)\nassert(prod_signs(arr: [0, 1]) == 0)\nassert(prod_signs(arr:\
    \ [1, 1, 1, 2, 3, -1, 1]) == -10)\nassert(prod_signs(arr: [] as [Int]) == nil)\n\
    assert(prod_signs(arr: [2, 4, 1, 2, -1, -1, 9]) == 20)\nassert(prod_signs(arr:\
    \ [-1, 1, -1, 1]) == 4)\nassert(prod_signs(arr: [-1, 1, 1, 1]) == -4)\nassert(prod_signs(arr:\
    \ [-1, 1, 1, 0]) == 0)"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659979793
- exit_code: -4
  program: "\n/// You are given an array arr of integers and you need to return\n\
    /// sum of magnitudes of integers multiplied by product of all signs\n/// of each\
    \ number in the array, represented by 1, -1 or 0.\n/// Note: return nil for empty\
    \ arr.\n/// Example:\n/// >>> prod_signs(arr: [1, 2, 2, -4])\n/// 9\n/// >>> prod_signs(arr:\
    \ [0, 1])\n/// 0\n/// >>> prod_signs(arr: [] as [Int])\n/// nil\nfunc prod_signs(arr:\
    \ [Int]) -> Int? {\n    if arr.isEmpty {\n        return nil\n    }\n    var magnitudeSum\
    \ = 0\n    var signProduct = 1\n    for num in arr {\n        magnitudeSum +=\
    \ abs(num)\n        signProduct *= num != 0 ? num / abs(num) : 1\n    }\n    return\
    \ magnitudeSum * signProduct\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int,\
    \ Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n\
    \    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n          \
    \  return false\n        }\n    }\n    return true\n}\n            \nassert(prod_signs(arr:\
    \ [1, 2, 2, -4]) == -9)\nassert(prod_signs(arr: [0, 1]) == 0)\nassert(prod_signs(arr:\
    \ [1, 1, 1, 2, 3, -1, 1]) == -10)\nassert(prod_signs(arr: [] as [Int]) == nil)\n\
    assert(prod_signs(arr: [2, 4, 1, 2, -1, -1, 9]) == 20)\nassert(prod_signs(arr:\
    \ [-1, 1, -1, 1]) == 4)\nassert(prod_signs(arr: [-1, 1, 1, 1]) == -4)\nassert(prod_signs(arr:\
    \ [-1, 1, 1, 0]) == 0)"
  status: Exception
  stderr: 'tmp2nt7mxop/tmp2nt7mxop.swift:40: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b2fadeb6c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b2fadbadb6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b2fadbad988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b2fadbac7b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmp2nt7mxop                        0x0000558a0c9768a5 <unavailable> + 6309

    5    libc.so.6                          0x00002b2fae0a2460 __libc_start_main +
    245

    6    tmp2nt7mxop                        0x0000558a0c9762a9 <unavailable> + 4777

    '
  stdout: ''
  timestamp: 1659979793
- exit_code: 0
  program: "\n/// You are given an array arr of integers and you need to return\n\
    /// sum of magnitudes of integers multiplied by product of all signs\n/// of each\
    \ number in the array, represented by 1, -1 or 0.\n/// Note: return nil for empty\
    \ arr.\n/// Example:\n/// >>> prod_signs(arr: [1, 2, 2, -4])\n/// 9\n/// >>> prod_signs(arr:\
    \ [0, 1])\n/// 0\n/// >>> prod_signs(arr: [] as [Int])\n/// nil\nfunc prod_signs(arr:\
    \ [Int]) -> Int? {\n    guard arr.count > 0 else { return nil }\n    let productOfSings\
    \ = arr.map { $0 == 0 ? 0 : ($0 > 0 ? 1 : -1) }.reduce(1, *)\n    let sumOfMagnitudes\
    \ = arr.map { abs($0) }.reduce(0, +)\n    return sumOfMagnitudes * productOfSings\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(prod_signs(arr: [1, 2, 2, -4]) == -9)\nassert(prod_signs(arr:\
    \ [0, 1]) == 0)\nassert(prod_signs(arr: [1, 1, 1, 2, 3, -1, 1]) == -10)\nassert(prod_signs(arr:\
    \ [] as [Int]) == nil)\nassert(prod_signs(arr: [2, 4, 1, 2, -1, -1, 9]) == 20)\n\
    assert(prod_signs(arr: [-1, 1, -1, 1]) == 4)\nassert(prod_signs(arr: [-1, 1, 1,\
    \ 1]) == -4)\nassert(prod_signs(arr: [-1, 1, 1, 0]) == 0)"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659979793
- exit_code: -4
  program: "\n/// You are given an array arr of integers and you need to return\n\
    /// sum of magnitudes of integers multiplied by product of all signs\n/// of each\
    \ number in the array, represented by 1, -1 or 0.\n/// Note: return nil for empty\
    \ arr.\n/// Example:\n/// >>> prod_signs(arr: [1, 2, 2, -4])\n/// 9\n/// >>> prod_signs(arr:\
    \ [0, 1])\n/// 0\n/// >>> prod_signs(arr: [] as [Int])\n/// nil\nfunc prod_signs(arr:\
    \ [Int]) -> Int? {\n    guard arr.count > 0 else { return nil }\n    return arr.map\
    \ { abs($0) }.reduce(1, *) * arr.map { $0 > 0 ? 1 : ($0 < 0 ? -1 : 0) }.reduce(1,\
    \ *)\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if\
    \ left.count != right.count {\n        return false\n    }\n    for (l, r) in\
    \ zip(left, right) {\n        if l != r {\n            return false\n        }\n\
    \    }\n    return true\n}\n            \nassert(prod_signs(arr: [1, 2, 2, -4])\
    \ == -9)\nassert(prod_signs(arr: [0, 1]) == 0)\nassert(prod_signs(arr: [1, 1,\
    \ 1, 2, 3, -1, 1]) == -10)\nassert(prod_signs(arr: [] as [Int]) == nil)\nassert(prod_signs(arr:\
    \ [2, 4, 1, 2, -1, -1, 9]) == 20)\nassert(prod_signs(arr: [-1, 1, -1, 1]) == 4)\n\
    assert(prod_signs(arr: [-1, 1, 1, 1]) == -4)\nassert(prod_signs(arr: [-1, 1, 1,\
    \ 0]) == 0)"
  status: Exception
  stderr: 'tmp1dxdxu15/tmp1dxdxu15.swift:31: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002abeeaca4c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002abeea99bb6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002abeea99b988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002abeea99a7b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmp1dxdxu15                        0x0000555b86fa6649 <unavailable> + 5705

    5    libc.so.6                          0x00002abeeae90460 __libc_start_main +
    245

    6    tmp1dxdxu15                        0x0000555b86fa61d9 <unavailable> + 4569

    '
  stdout: ''
  timestamp: 1659979793
- exit_code: -4
  program: "\n/// You are given an array arr of integers and you need to return\n\
    /// sum of magnitudes of integers multiplied by product of all signs\n/// of each\
    \ number in the array, represented by 1, -1 or 0.\n/// Note: return nil for empty\
    \ arr.\n/// Example:\n/// >>> prod_signs(arr: [1, 2, 2, -4])\n/// 9\n/// >>> prod_signs(arr:\
    \ [0, 1])\n/// 0\n/// >>> prod_signs(arr: [] as [Int])\n/// nil\nfunc prod_signs(arr:\
    \ [Int]) -> Int? {\n    var mags: [Int] = []\n    var signs: [Int] = []\n    for\
    \ x in arr {\n        mags.append(abs(x))\n        signs.append(x == 0 ? 0 : x\
    \ / abs(x))\n    }\n    return mags.isEmpty ? nil : mags.reduce(1, *) * signs.reduce(1,\
    \ *)\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if\
    \ left.count != right.count {\n        return false\n    }\n    for (l, r) in\
    \ zip(left, right) {\n        if l != r {\n            return false\n        }\n\
    \    }\n    return true\n}\n            \nassert(prod_signs(arr: [1, 2, 2, -4])\
    \ == -9)\nassert(prod_signs(arr: [0, 1]) == 0)\nassert(prod_signs(arr: [1, 1,\
    \ 1, 2, 3, -1, 1]) == -10)\nassert(prod_signs(arr: [] as [Int]) == nil)\nassert(prod_signs(arr:\
    \ [2, 4, 1, 2, -1, -1, 9]) == 20)\nassert(prod_signs(arr: [-1, 1, -1, 1]) == 4)\n\
    assert(prod_signs(arr: [-1, 1, 1, 1]) == -4)\nassert(prod_signs(arr: [-1, 1, 1,\
    \ 0]) == 0)"
  status: Exception
  stderr: 'tmpyd0er6by/tmpyd0er6by.swift:36: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b183bbc5c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b183b8bcb6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b183b8bc988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b183b8bb7b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpyd0er6by                        0x000055e9d66987e9 <unavailable> + 6121

    5    libc.so.6                          0x00002b183bdb1460 __libc_start_main +
    245

    6    tmpyd0er6by                        0x000055e9d6698379 <unavailable> + 4985

    '
  stdout: ''
  timestamp: 1659979793
- exit_code: -4
  program: "\n/// You are given an array arr of integers and you need to return\n\
    /// sum of magnitudes of integers multiplied by product of all signs\n/// of each\
    \ number in the array, represented by 1, -1 or 0.\n/// Note: return nil for empty\
    \ arr.\n/// Example:\n/// >>> prod_signs(arr: [1, 2, 2, -4])\n/// 9\n/// >>> prod_signs(arr:\
    \ [0, 1])\n/// 0\n/// >>> prod_signs(arr: [] as [Int])\n/// nil\nfunc prod_signs(arr:\
    \ [Int]) -> Int? {\n    let filter_zero = arr.filter { $0 != 0 }\n    let filter_one\
    \ = filter_zero.filter { $0 != 1 }\n    var sum_magnitude = filter_zero.filter\
    \ { $0 == 1 }.count + filter_one.map { abs($0) }.reduce(0, +)\n    if filter_zero.count\
    \ != arr.count {\n        sum_magnitude += (arr.contains(0) ? 0 : 1)\n    }\n\
    \    return sum_magnitude\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(prod_signs(arr:\
    \ [1, 2, 2, -4]) == -9)\nassert(prod_signs(arr: [0, 1]) == 0)\nassert(prod_signs(arr:\
    \ [1, 1, 1, 2, 3, -1, 1]) == -10)\nassert(prod_signs(arr: [] as [Int]) == nil)\n\
    assert(prod_signs(arr: [2, 4, 1, 2, -1, -1, 9]) == 20)\nassert(prod_signs(arr:\
    \ [-1, 1, -1, 1]) == 4)\nassert(prod_signs(arr: [-1, 1, 1, 1]) == -4)\nassert(prod_signs(arr:\
    \ [-1, 1, 1, 0]) == 0)"
  status: Exception
  stderr: 'tmpwfew8q1o/tmpwfew8q1o.swift:36: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002ac0a57e8c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002ac0a54dfb6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002ac0a54df988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002ac0a54de7b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpwfew8q1o                        0x000055a1ef1cf769 <unavailable> + 5993

    5    libc.so.6                          0x00002ac0a59d4460 __libc_start_main +
    245

    6    tmpwfew8q1o                        0x000055a1ef1cf2f9 <unavailable> + 4857

    '
  stdout: ''
  timestamp: 1659979793
- exit_code: 0
  program: "\n/// You are given an array arr of integers and you need to return\n\
    /// sum of magnitudes of integers multiplied by product of all signs\n/// of each\
    \ number in the array, represented by 1, -1 or 0.\n/// Note: return nil for empty\
    \ arr.\n/// Example:\n/// >>> prod_signs(arr: [1, 2, 2, -4])\n/// 9\n/// >>> prod_signs(arr:\
    \ [0, 1])\n/// 0\n/// >>> prod_signs(arr: [] as [Int])\n/// nil\nfunc prod_signs(arr:\
    \ [Int]) -> Int? {\n    if arr.isEmpty {\n        return nil\n    }\n    let signs\
    \ = arr.map { $0 > 0 ? 1 : $0 < 0 ? -1 : 0 }\n    let product = signs.reduce(1,\
    \ *)\n    let magnitudes = arr.map { abs($0) }\n    let sum = magnitudes.reduce(0,\
    \ +)\n    return product * sum\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int,\
    \ Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n\
    \    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n          \
    \  return false\n        }\n    }\n    return true\n}\n            \nassert(prod_signs(arr:\
    \ [1, 2, 2, -4]) == -9)\nassert(prod_signs(arr: [0, 1]) == 0)\nassert(prod_signs(arr:\
    \ [1, 1, 1, 2, 3, -1, 1]) == -10)\nassert(prod_signs(arr: [] as [Int]) == nil)\n\
    assert(prod_signs(arr: [2, 4, 1, 2, -1, -1, 9]) == 20)\nassert(prod_signs(arr:\
    \ [-1, 1, -1, 1]) == 4)\nassert(prod_signs(arr: [-1, 1, 1, 1]) == -4)\nassert(prod_signs(arr:\
    \ [-1, 1, 1, 0]) == 0)"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659979793
- exit_code: 0
  program: "\n/// You are given an array arr of integers and you need to return\n\
    /// sum of magnitudes of integers multiplied by product of all signs\n/// of each\
    \ number in the array, represented by 1, -1 or 0.\n/// Note: return nil for empty\
    \ arr.\n/// Example:\n/// >>> prod_signs(arr: [1, 2, 2, -4])\n/// 9\n/// >>> prod_signs(arr:\
    \ [0, 1])\n/// 0\n/// >>> prod_signs(arr: [] as [Int])\n/// nil\nfunc prod_signs(arr:\
    \ [Int]) -> Int? {\n    var result: Int = 0\n    var neg: Int = 1\n    var pos:\
    \ Int = 1\n    var zer: Int = 1\n    if arr.count == 0 {\n        return nil\n\
    \    }\n    for i in arr {\n        if i < 0 {\n            neg *= -1\n      \
    \      result += abs(i)\n        } else if i > 0 {\n            pos *= 1\n   \
    \         result += abs(i)\n        } else {\n            zer *= 0\n        }\n\
    \    }\n    return result * (neg * pos * zer)\n}\n\n\nfunc ==(left: [(Int, Int)],\
    \ right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n       \
    \ return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r\
    \ {\n            return false\n        }\n    }\n    return true\n}\n        \
    \    \nassert(prod_signs(arr: [1, 2, 2, -4]) == -9)\nassert(prod_signs(arr: [0,\
    \ 1]) == 0)\nassert(prod_signs(arr: [1, 1, 1, 2, 3, -1, 1]) == -10)\nassert(prod_signs(arr:\
    \ [] as [Int]) == nil)\nassert(prod_signs(arr: [2, 4, 1, 2, -1, -1, 9]) == 20)\n\
    assert(prod_signs(arr: [-1, 1, -1, 1]) == 4)\nassert(prod_signs(arr: [-1, 1, 1,\
    \ 1]) == -4)\nassert(prod_signs(arr: [-1, 1, 1, 0]) == 0)"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659979793
- exit_code: -4
  program: "\n/// You are given an array arr of integers and you need to return\n\
    /// sum of magnitudes of integers multiplied by product of all signs\n/// of each\
    \ number in the array, represented by 1, -1 or 0.\n/// Note: return nil for empty\
    \ arr.\n/// Example:\n/// >>> prod_signs(arr: [1, 2, 2, -4])\n/// 9\n/// >>> prod_signs(arr:\
    \ [0, 1])\n/// 0\n/// >>> prod_signs(arr: [] as [Int])\n/// nil\nfunc prod_signs(arr:\
    \ [Int]) -> Int? {\n    guard arr.count > 0 else {\n        return nil\n    }\n\
    \    var prod_1_or_neg_1 = 1 // -1\n    var magnitudes_sum = 0\n    for el in\
    \ arr {\n        switch el {\n        case let x where x > 0:\n            prod_1_or_neg_1\
    \ *= 1\n            magnitudes_sum += x\n        case let x where x < 0:\n   \
    \         prod_1_or_neg_1 *= -1\n            magnitudes_sum += -x\n        default:\n\
    \            continue\n        }\n    }\n    return prod_1_or_neg_1 * magnitudes_sum\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(prod_signs(arr: [1, 2, 2, -4]) == -9)\nassert(prod_signs(arr:\
    \ [0, 1]) == 0)\nassert(prod_signs(arr: [1, 1, 1, 2, 3, -1, 1]) == -10)\nassert(prod_signs(arr:\
    \ [] as [Int]) == nil)\nassert(prod_signs(arr: [2, 4, 1, 2, -1, -1, 9]) == 20)\n\
    assert(prod_signs(arr: [-1, 1, -1, 1]) == 4)\nassert(prod_signs(arr: [-1, 1, 1,\
    \ 1]) == -4)\nassert(prod_signs(arr: [-1, 1, 1, 0]) == 0)"
  status: Exception
  stderr: 'tmplinv8jxl/tmplinv8jxl.swift:48: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b65beee0c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b65bebd7b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b65bebd7988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b65bebd67b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmplinv8jxl                        0x000055b4bddc8725 <unavailable> + 5925

    5    libc.so.6                          0x00002b65bf0cc460 __libc_start_main +
    245

    6    tmplinv8jxl                        0x000055b4bddc8129 <unavailable> + 4393

    '
  stdout: ''
  timestamp: 1659979793
- exit_code: -4
  program: "\n/// You are given an array arr of integers and you need to return\n\
    /// sum of magnitudes of integers multiplied by product of all signs\n/// of each\
    \ number in the array, represented by 1, -1 or 0.\n/// Note: return nil for empty\
    \ arr.\n/// Example:\n/// >>> prod_signs(arr: [1, 2, 2, -4])\n/// 9\n/// >>> prod_signs(arr:\
    \ [0, 1])\n/// 0\n/// >>> prod_signs(arr: [] as [Int])\n/// nil\nfunc prod_signs(arr:\
    \ [Int]) -> Int? {\n    return nil\n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(prod_signs(arr: [1, 2, 2, -4]) == -9)\nassert(prod_signs(arr: [0, 1]) ==\
    \ 0)\nassert(prod_signs(arr: [1, 1, 1, 2, 3, -1, 1]) == -10)\nassert(prod_signs(arr:\
    \ [] as [Int]) == nil)\nassert(prod_signs(arr: [2, 4, 1, 2, -1, -1, 9]) == 20)\n\
    assert(prod_signs(arr: [-1, 1, -1, 1]) == 4)\nassert(prod_signs(arr: [-1, 1, 1,\
    \ 1]) == -4)\nassert(prod_signs(arr: [-1, 1, 1, 0]) == 0)"
  status: Exception
  stderr: 'tmp1rt4wv_3/tmp1rt4wv_3.swift:30: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b2a15132c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b2a14e29b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b2a14e29988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b2a14e287b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmp1rt4wv_3                        0x00005652a02c73d9 <unavailable> + 5081

    5    libc.so.6                          0x00002b2a1531e460 __libc_start_main +
    245

    6    tmp1rt4wv_3                        0x00005652a02c6f69 <unavailable> + 3945

    '
  stdout: ''
  timestamp: 1659979791
- exit_code: 0
  program: "\n/// You are given an array arr of integers and you need to return\n\
    /// sum of magnitudes of integers multiplied by product of all signs\n/// of each\
    \ number in the array, represented by 1, -1 or 0.\n/// Note: return nil for empty\
    \ arr.\n/// Example:\n/// >>> prod_signs(arr: [1, 2, 2, -4])\n/// 9\n/// >>> prod_signs(arr:\
    \ [0, 1])\n/// 0\n/// >>> prod_signs(arr: [] as [Int])\n/// nil\nfunc prod_signs(arr:\
    \ [Int]) -> Int? {\n    guard arr.count > 0 else { return nil }\n    return arr.map{\
    \ $0 > 0 ? 1 : $0 < 0 ? -1 : 0 }.reduce(1, *) * arr.map{ abs($0) }.reduce(0, +)\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(prod_signs(arr: [1, 2, 2, -4]) == -9)\nassert(prod_signs(arr:\
    \ [0, 1]) == 0)\nassert(prod_signs(arr: [1, 1, 1, 2, 3, -1, 1]) == -10)\nassert(prod_signs(arr:\
    \ [] as [Int]) == nil)\nassert(prod_signs(arr: [2, 4, 1, 2, -1, -1, 9]) == 20)\n\
    assert(prod_signs(arr: [-1, 1, -1, 1]) == 4)\nassert(prod_signs(arr: [-1, 1, 1,\
    \ 1]) == -4)\nassert(prod_signs(arr: [-1, 1, 1, 0]) == 0)"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659979793
- exit_code: 0
  program: "\n/// You are given an array arr of integers and you need to return\n\
    /// sum of magnitudes of integers multiplied by product of all signs\n/// of each\
    \ number in the array, represented by 1, -1 or 0.\n/// Note: return nil for empty\
    \ arr.\n/// Example:\n/// >>> prod_signs(arr: [1, 2, 2, -4])\n/// 9\n/// >>> prod_signs(arr:\
    \ [0, 1])\n/// 0\n/// >>> prod_signs(arr: [] as [Int])\n/// nil\nfunc prod_signs(arr:\
    \ [Int]) -> Int? {\n    if arr.isEmpty {\n        return nil\n    }\n    var sumOfMagnitudes\
    \ = 0\n    var productOfSigns = 1\n    for num in arr {\n        sumOfMagnitudes\
    \ += abs(num)\n        productOfSigns *= num < 0 ? -1 : (num > 0 ? 1 : 0)\n  \
    \  }\n    return sumOfMagnitudes * productOfSigns\n}\n\n\nfunc ==(left: [(Int,\
    \ Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n\
    \        return false\n    }\n    for (l, r) in zip(left, right) {\n        if\
    \ l != r {\n            return false\n        }\n    }\n    return true\n}\n \
    \           \nassert(prod_signs(arr: [1, 2, 2, -4]) == -9)\nassert(prod_signs(arr:\
    \ [0, 1]) == 0)\nassert(prod_signs(arr: [1, 1, 1, 2, 3, -1, 1]) == -10)\nassert(prod_signs(arr:\
    \ [] as [Int]) == nil)\nassert(prod_signs(arr: [2, 4, 1, 2, -1, -1, 9]) == 20)\n\
    assert(prod_signs(arr: [-1, 1, -1, 1]) == 4)\nassert(prod_signs(arr: [-1, 1, 1,\
    \ 1]) == -4)\nassert(prod_signs(arr: [-1, 1, 1, 0]) == 0)"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659979793
- exit_code: -4
  program: "\n/// You are given an array arr of integers and you need to return\n\
    /// sum of magnitudes of integers multiplied by product of all signs\n/// of each\
    \ number in the array, represented by 1, -1 or 0.\n/// Note: return nil for empty\
    \ arr.\n/// Example:\n/// >>> prod_signs(arr: [1, 2, 2, -4])\n/// 9\n/// >>> prod_signs(arr:\
    \ [0, 1])\n/// 0\n/// >>> prod_signs(arr: [] as [Int])\n/// nil\nfunc prod_signs(arr:\
    \ [Int]) -> Int? {\n\tguard arr.count > 0 else {\n\t\treturn nil\n\t}\n\tvar mult\
    \ = 1\n\tvar sum = 0\n\tfor i in arr {\n\t\tif i != 0 {\n\t\t\tif i < 0 {\n\t\t\
    \t\tmult *= -1\n\t\t\t}\n\t\t\tsum += abs(i)\n\t\t}\n\t}\n\treturn sum * mult\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(prod_signs(arr: [1, 2, 2, -4]) == -9)\nassert(prod_signs(arr:\
    \ [0, 1]) == 0)\nassert(prod_signs(arr: [1, 1, 1, 2, 3, -1, 1]) == -10)\nassert(prod_signs(arr:\
    \ [] as [Int]) == nil)\nassert(prod_signs(arr: [2, 4, 1, 2, -1, -1, 9]) == 20)\n\
    assert(prod_signs(arr: [-1, 1, -1, 1]) == 4)\nassert(prod_signs(arr: [-1, 1, 1,\
    \ 1]) == -4)\nassert(prod_signs(arr: [-1, 1, 1, 0]) == 0)"
  status: Exception
  stderr: 'tmp_q0rfvz7/tmp_q0rfvz7.swift:44: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b37973cbc80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b37970c2b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b37970c2988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b37970c17b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmp_q0rfvz7                        0x000055d77661b815 <unavailable> + 6165

    5    libc.so.6                          0x00002b37975b7460 __libc_start_main +
    245

    6    tmp_q0rfvz7                        0x000055d77661b219 <unavailable> + 4633

    '
  stdout: ''
  timestamp: 1659979793
- exit_code: 1
  program: "\n/// You are given an array arr of integers and you need to return\n\
    /// sum of magnitudes of integers multiplied by product of all signs\n/// of each\
    \ number in the array, represented by 1, -1 or 0.\n/// Note: return nil for empty\
    \ arr.\n/// Example:\n/// >>> prod_signs(arr: [1, 2, 2, -4])\n/// 9\n/// >>> prod_signs(arr:\
    \ [0, 1])\n/// 0\n/// >>> prod_signs(arr: [] as [Int])\n/// nil\nfunc prod_signs(arr:\
    \ [Int]) -> Int? {\n  var sum = 0\n  var prod = 1\n  for el in arr {\n    if el\
    \ != 0 {\n      sum += abs(el)\n      prod *= sign(el)\n    }\n  }\n  if prod\
    \ == 0 {\n    return nil\n  }\n  return sum * prod\n}\n\n\nfunc ==(left: [(Int,\
    \ Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n\
    \        return false\n    }\n    for (l, r) in zip(left, right) {\n        if\
    \ l != r {\n            return false\n        }\n    }\n    return true\n}\n \
    \           \nassert(prod_signs(arr: [1, 2, 2, -4]) == -9)\nassert(prod_signs(arr:\
    \ [0, 1]) == 0)\nassert(prod_signs(arr: [1, 1, 1, 2, 3, -1, 1]) == -10)\nassert(prod_signs(arr:\
    \ [] as [Int]) == nil)\nassert(prod_signs(arr: [2, 4, 1, 2, -1, -1, 9]) == 20)\n\
    assert(prod_signs(arr: [-1, 1, -1, 1]) == 4)\nassert(prod_signs(arr: [-1, 1, 1,\
    \ 1]) == -4)\nassert(prod_signs(arr: [-1, 1, 1, 0]) == 0)"
  status: SyntaxError
  stderr: "/tmp/tmpoc1c7ak_.swift:19:15: error: cannot find 'sign' in scope\n    \
    \  prod *= sign(el)\n              ^~~~\n"
  stdout: ''
  timestamp: 1659979793
- exit_code: -4
  program: "\n/// You are given an array arr of integers and you need to return\n\
    /// sum of magnitudes of integers multiplied by product of all signs\n/// of each\
    \ number in the array, represented by 1, -1 or 0.\n/// Note: return nil for empty\
    \ arr.\n/// Example:\n/// >>> prod_signs(arr: [1, 2, 2, -4])\n/// 9\n/// >>> prod_signs(arr:\
    \ [0, 1])\n/// 0\n/// >>> prod_signs(arr: [] as [Int])\n/// nil\nfunc prod_signs(arr:\
    \ [Int]) -> Int? {\n    if arr.isEmpty {\n        return nil\n    }\n    return\
    \ arr.map{ $0 >= 0 ? 1 : -1 }.reduce(1, *) * arr.map{ abs($0) }.reduce(0, +)\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(prod_signs(arr: [1, 2, 2, -4]) == -9)\nassert(prod_signs(arr:\
    \ [0, 1]) == 0)\nassert(prod_signs(arr: [1, 1, 1, 2, 3, -1, 1]) == -10)\nassert(prod_signs(arr:\
    \ [] as [Int]) == nil)\nassert(prod_signs(arr: [2, 4, 1, 2, -1, -1, 9]) == 20)\n\
    assert(prod_signs(arr: [-1, 1, -1, 1]) == 4)\nassert(prod_signs(arr: [-1, 1, 1,\
    \ 1]) == -4)\nassert(prod_signs(arr: [-1, 1, 1, 0]) == 0)"
  status: Exception
  stderr: 'tmpcz3ckzp6/tmpcz3ckzp6.swift:34: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002ab9df827c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002ab9df51eb6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002ab9df51e988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002ab9df51d7b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpcz3ckzp6                        0x000055dc7318b7c5 <unavailable> + 6085

    5    libc.so.6                          0x00002ab9dfa13460 __libc_start_main +
    245

    6    tmpcz3ckzp6                        0x000055dc7318b1c9 <unavailable> + 4553

    '
  stdout: ''
  timestamp: 1659979793
- exit_code: -4
  program: "\n/// You are given an array arr of integers and you need to return\n\
    /// sum of magnitudes of integers multiplied by product of all signs\n/// of each\
    \ number in the array, represented by 1, -1 or 0.\n/// Note: return nil for empty\
    \ arr.\n/// Example:\n/// >>> prod_signs(arr: [1, 2, 2, -4])\n/// 9\n/// >>> prod_signs(arr:\
    \ [0, 1])\n/// 0\n/// >>> prod_signs(arr: [] as [Int])\n/// nil\nfunc prod_signs(arr:\
    \ [Int]) -> Int? {\n    return nil\n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(prod_signs(arr: [1, 2, 2, -4]) == -9)\nassert(prod_signs(arr: [0, 1]) ==\
    \ 0)\nassert(prod_signs(arr: [1, 1, 1, 2, 3, -1, 1]) == -10)\nassert(prod_signs(arr:\
    \ [] as [Int]) == nil)\nassert(prod_signs(arr: [2, 4, 1, 2, -1, -1, 9]) == 20)\n\
    assert(prod_signs(arr: [-1, 1, -1, 1]) == 4)\nassert(prod_signs(arr: [-1, 1, 1,\
    \ 1]) == -4)\nassert(prod_signs(arr: [-1, 1, 1, 0]) == 0)"
  status: Exception
  stderr: 'tmp1rt4wv_3/tmp1rt4wv_3.swift:30: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b2a15132c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b2a14e29b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b2a14e29988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b2a14e287b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmp1rt4wv_3                        0x00005652a02c73d9 <unavailable> + 5081

    5    libc.so.6                          0x00002b2a1531e460 __libc_start_main +
    245

    6    tmp1rt4wv_3                        0x00005652a02c6f69 <unavailable> + 3945

    '
  stdout: ''
  timestamp: 1659979791
- exit_code: 0
  program: "\n/// You are given an array arr of integers and you need to return\n\
    /// sum of magnitudes of integers multiplied by product of all signs\n/// of each\
    \ number in the array, represented by 1, -1 or 0.\n/// Note: return nil for empty\
    \ arr.\n/// Example:\n/// >>> prod_signs(arr: [1, 2, 2, -4])\n/// 9\n/// >>> prod_signs(arr:\
    \ [0, 1])\n/// 0\n/// >>> prod_signs(arr: [] as [Int])\n/// nil\nfunc prod_signs(arr:\
    \ [Int]) -> Int? {\n\tguard arr.count > 0 else { return nil }\n\tlet prods = arr.map\
    \ { ($0 > 0 ? 1 : $0 < 0 ? -1 : 0) }\n\tlet sum = arr.map { abs($0) }.reduce(0,\
    \ +)\n\treturn prods.reduce(1, *) * sum\n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(prod_signs(arr: [1, 2, 2, -4]) == -9)\nassert(prod_signs(arr: [0, 1]) ==\
    \ 0)\nassert(prod_signs(arr: [1, 1, 1, 2, 3, -1, 1]) == -10)\nassert(prod_signs(arr:\
    \ [] as [Int]) == nil)\nassert(prod_signs(arr: [2, 4, 1, 2, -1, -1, 9]) == 20)\n\
    assert(prod_signs(arr: [-1, 1, -1, 1]) == 4)\nassert(prod_signs(arr: [-1, 1, 1,\
    \ 1]) == -4)\nassert(prod_signs(arr: [-1, 1, 1, 0]) == 0)"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659979793
- exit_code: -4
  program: "\n/// You are given an array arr of integers and you need to return\n\
    /// sum of magnitudes of integers multiplied by product of all signs\n/// of each\
    \ number in the array, represented by 1, -1 or 0.\n/// Note: return nil for empty\
    \ arr.\n/// Example:\n/// >>> prod_signs(arr: [1, 2, 2, -4])\n/// 9\n/// >>> prod_signs(arr:\
    \ [0, 1])\n/// 0\n/// >>> prod_signs(arr: [] as [Int])\n/// nil\nfunc prod_signs(arr:\
    \ [Int]) -> Int? {\n    var result: Int = 0\n    var sign: Int = 1\n    for i\
    \ in arr {\n        if i > 0 {\n            result += i\n        } else if i <\
    \ 0 {\n            result += -i\n            sign *= -1\n        }\n    }\n  \
    \  return result * sign\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(prod_signs(arr:\
    \ [1, 2, 2, -4]) == -9)\nassert(prod_signs(arr: [0, 1]) == 0)\nassert(prod_signs(arr:\
    \ [1, 1, 1, 2, 3, -1, 1]) == -10)\nassert(prod_signs(arr: [] as [Int]) == nil)\n\
    assert(prod_signs(arr: [2, 4, 1, 2, -1, -1, 9]) == 20)\nassert(prod_signs(arr:\
    \ [-1, 1, -1, 1]) == 4)\nassert(prod_signs(arr: [-1, 1, 1, 1]) == -4)\nassert(prod_signs(arr:\
    \ [-1, 1, 1, 0]) == 0)"
  status: Exception
  stderr: 'tmp6rkxyak4/tmp6rkxyak4.swift:41: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b518b41bc80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b518b112b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b518b112988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b518b1117b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmp6rkxyak4                        0x000055b6a47336d5 <unavailable> + 5845

    5    libc.so.6                          0x00002b518b607460 __libc_start_main +
    245

    6    tmp6rkxyak4                        0x000055b6a47330d9 <unavailable> + 4313

    '
  stdout: ''
  timestamp: 1659979793
- exit_code: -4
  program: "\n/// You are given an array arr of integers and you need to return\n\
    /// sum of magnitudes of integers multiplied by product of all signs\n/// of each\
    \ number in the array, represented by 1, -1 or 0.\n/// Note: return nil for empty\
    \ arr.\n/// Example:\n/// >>> prod_signs(arr: [1, 2, 2, -4])\n/// 9\n/// >>> prod_signs(arr:\
    \ [0, 1])\n/// 0\n/// >>> prod_signs(arr: [] as [Int])\n/// nil\nfunc prod_signs(arr:\
    \ [Int]) -> Int? {\n    if arr.isEmpty {\n        return nil\n    }\n    let res\
    \ = arr.map { abs($0) }.reduce(1, *) * arr.map { $0 < 0 ? -1 : ($0 > 0 ? 1 : 0)\
    \ }.reduce(1, *)\n    return res\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int,\
    \ Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n\
    \    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n          \
    \  return false\n        }\n    }\n    return true\n}\n            \nassert(prod_signs(arr:\
    \ [1, 2, 2, -4]) == -9)\nassert(prod_signs(arr: [0, 1]) == 0)\nassert(prod_signs(arr:\
    \ [1, 1, 1, 2, 3, -1, 1]) == -10)\nassert(prod_signs(arr: [] as [Int]) == nil)\n\
    assert(prod_signs(arr: [2, 4, 1, 2, -1, -1, 9]) == 20)\nassert(prod_signs(arr:\
    \ [-1, 1, -1, 1]) == 4)\nassert(prod_signs(arr: [-1, 1, 1, 1]) == -4)\nassert(prod_signs(arr:\
    \ [-1, 1, 1, 0]) == 0)"
  status: Exception
  stderr: 'tmpv9f0ybb1/tmpv9f0ybb1.swift:34: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b7771c97c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b777198eb6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b777198e988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b777198d7b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpv9f0ybb1                        0x000056237e1c9639 <unavailable> + 5689

    5    libc.so.6                          0x00002b7771e83460 __libc_start_main +
    245

    6    tmpv9f0ybb1                        0x000056237e1c91c9 <unavailable> + 4553

    '
  stdout: ''
  timestamp: 1659979793
- exit_code: -4
  program: "\n/// You are given an array arr of integers and you need to return\n\
    /// sum of magnitudes of integers multiplied by product of all signs\n/// of each\
    \ number in the array, represented by 1, -1 or 0.\n/// Note: return nil for empty\
    \ arr.\n/// Example:\n/// >>> prod_signs(arr: [1, 2, 2, -4])\n/// 9\n/// >>> prod_signs(arr:\
    \ [0, 1])\n/// 0\n/// >>> prod_signs(arr: [] as [Int])\n/// nil\nfunc prod_signs(arr:\
    \ [Int]) -> Int? {\n    guard arr.count > 0 else {\n        return nil\n    }\n\
    \    var signs = 1\n    var sum = 0\n    for num in arr {\n        switch num\
    \ {\n        case _ where num < 0:\n            signs *= -1\n            sum +=\
    \ abs(num)\n        case _ where num > 0:\n            sum += num\n        default:\n\
    \            break\n        }\n    }\n    return sum * signs\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(prod_signs(arr: [1, 2, 2, -4]) == -9)\nassert(prod_signs(arr:\
    \ [0, 1]) == 0)\nassert(prod_signs(arr: [1, 1, 1, 2, 3, -1, 1]) == -10)\nassert(prod_signs(arr:\
    \ [] as [Int]) == nil)\nassert(prod_signs(arr: [2, 4, 1, 2, -1, -1, 9]) == 20)\n\
    assert(prod_signs(arr: [-1, 1, -1, 1]) == 4)\nassert(prod_signs(arr: [-1, 1, 1,\
    \ 1]) == -4)\nassert(prod_signs(arr: [-1, 1, 1, 0]) == 0)"
  status: Exception
  stderr: 'tmpg71rrefi/tmpg71rrefi.swift:47: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b80ae865c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b80ae55cb6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b80ae55c988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b80ae55b7b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpg71rrefi                        0x00005557dcf04815 <unavailable> + 6165

    5    libc.so.6                          0x00002b80aea51460 __libc_start_main +
    245

    6    tmpg71rrefi                        0x00005557dcf04219 <unavailable> + 4633

    '
  stdout: ''
  timestamp: 1659979793
- exit_code: 0
  program: "\n/// You are given an array arr of integers and you need to return\n\
    /// sum of magnitudes of integers multiplied by product of all signs\n/// of each\
    \ number in the array, represented by 1, -1 or 0.\n/// Note: return nil for empty\
    \ arr.\n/// Example:\n/// >>> prod_signs(arr: [1, 2, 2, -4])\n/// 9\n/// >>> prod_signs(arr:\
    \ [0, 1])\n/// 0\n/// >>> prod_signs(arr: [] as [Int])\n/// nil\nfunc prod_signs(arr:\
    \ [Int]) -> Int? {\n  guard arr.count > 0 else { return nil }\n  var productOfSigns\
    \ = 1\n  var sumOfMagnitudes = 0\n  for elem in arr {\n    let magnitude = abs(elem)\n\
    \    sumOfMagnitudes += magnitude\n    let sign = (elem > 0) ? 1 : ((elem < 0)\
    \ ? -1 : 0)\n    productOfSigns *= sign\n  }\n  return sumOfMagnitudes * productOfSigns\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(prod_signs(arr: [1, 2, 2, -4]) == -9)\nassert(prod_signs(arr:\
    \ [0, 1]) == 0)\nassert(prod_signs(arr: [1, 1, 1, 2, 3, -1, 1]) == -10)\nassert(prod_signs(arr:\
    \ [] as [Int]) == nil)\nassert(prod_signs(arr: [2, 4, 1, 2, -1, -1, 9]) == 20)\n\
    assert(prod_signs(arr: [-1, 1, -1, 1]) == 4)\nassert(prod_signs(arr: [-1, 1, 1,\
    \ 1]) == -4)\nassert(prod_signs(arr: [-1, 1, 1, 0]) == 0)"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659979793
- exit_code: 0
  program: "\n/// You are given an array arr of integers and you need to return\n\
    /// sum of magnitudes of integers multiplied by product of all signs\n/// of each\
    \ number in the array, represented by 1, -1 or 0.\n/// Note: return nil for empty\
    \ arr.\n/// Example:\n/// >>> prod_signs(arr: [1, 2, 2, -4])\n/// 9\n/// >>> prod_signs(arr:\
    \ [0, 1])\n/// 0\n/// >>> prod_signs(arr: [] as [Int])\n/// nil\nfunc prod_signs(arr:\
    \ [Int]) -> Int? {\n    if arr.isEmpty {\n        return nil\n    }\n    var product\
    \ = 1\n    var sum = 0\n    for a in arr {\n        if a > 0 {\n            product\
    \ *= 1\n        } else if a < 0 {\n            product *= -1\n        } else {\n\
    \            product *= 0\n        }\n        sum += abs(a)\n    }\n    return\
    \ sum * product\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool\
    \ {\n    if left.count != right.count {\n        return false\n    }\n    for\
    \ (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(prod_signs(arr: [1,\
    \ 2, 2, -4]) == -9)\nassert(prod_signs(arr: [0, 1]) == 0)\nassert(prod_signs(arr:\
    \ [1, 1, 1, 2, 3, -1, 1]) == -10)\nassert(prod_signs(arr: [] as [Int]) == nil)\n\
    assert(prod_signs(arr: [2, 4, 1, 2, -1, -1, 9]) == 20)\nassert(prod_signs(arr:\
    \ [-1, 1, -1, 1]) == 4)\nassert(prod_signs(arr: [-1, 1, 1, 1]) == -4)\nassert(prod_signs(arr:\
    \ [-1, 1, 1, 0]) == 0)"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659979793
- exit_code: 0
  program: "\n/// You are given an array arr of integers and you need to return\n\
    /// sum of magnitudes of integers multiplied by product of all signs\n/// of each\
    \ number in the array, represented by 1, -1 or 0.\n/// Note: return nil for empty\
    \ arr.\n/// Example:\n/// >>> prod_signs(arr: [1, 2, 2, -4])\n/// 9\n/// >>> prod_signs(arr:\
    \ [0, 1])\n/// 0\n/// >>> prod_signs(arr: [] as [Int])\n/// nil\nfunc prod_signs(arr:\
    \ [Int]) -> Int? {\n    guard arr.count > 0 else {\n        return nil\n    }\n\
    \    var signsProd = 1\n    var magnitudesSum = 0\n    for num in arr {\n    \
    \    let sign = num < 0 ? -1 : num > 0 ? 1 : 0\n        signsProd *= sign\n  \
    \      magnitudesSum += abs(num)\n    }\n    return signsProd * magnitudesSum\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(prod_signs(arr: [1, 2, 2, -4]) == -9)\nassert(prod_signs(arr:\
    \ [0, 1]) == 0)\nassert(prod_signs(arr: [1, 1, 1, 2, 3, -1, 1]) == -10)\nassert(prod_signs(arr:\
    \ [] as [Int]) == nil)\nassert(prod_signs(arr: [2, 4, 1, 2, -1, -1, 9]) == 20)\n\
    assert(prod_signs(arr: [-1, 1, -1, 1]) == 4)\nassert(prod_signs(arr: [-1, 1, 1,\
    \ 1]) == -4)\nassert(prod_signs(arr: [-1, 1, 1, 0]) == 0)"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659979793
- exit_code: -4
  program: "\n/// You are given an array arr of integers and you need to return\n\
    /// sum of magnitudes of integers multiplied by product of all signs\n/// of each\
    \ number in the array, represented by 1, -1 or 0.\n/// Note: return nil for empty\
    \ arr.\n/// Example:\n/// >>> prod_signs(arr: [1, 2, 2, -4])\n/// 9\n/// >>> prod_signs(arr:\
    \ [0, 1])\n/// 0\n/// >>> prod_signs(arr: [] as [Int])\n/// nil\nfunc prod_signs(arr:\
    \ [Int]) -> Int? {\n    if arr.isEmpty {\n        return nil\n    }\n    return\
    \ arr.map { abs($0) }.reduce(1, *) * arr.map { $0 > 0 ? 1 : ($0 < 0 ? -1 : 0)\
    \ }.reduce(1, *)\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool\
    \ {\n    if left.count != right.count {\n        return false\n    }\n    for\
    \ (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(prod_signs(arr: [1,\
    \ 2, 2, -4]) == -9)\nassert(prod_signs(arr: [0, 1]) == 0)\nassert(prod_signs(arr:\
    \ [1, 1, 1, 2, 3, -1, 1]) == -10)\nassert(prod_signs(arr: [] as [Int]) == nil)\n\
    assert(prod_signs(arr: [2, 4, 1, 2, -1, -1, 9]) == 20)\nassert(prod_signs(arr:\
    \ [-1, 1, -1, 1]) == 4)\nassert(prod_signs(arr: [-1, 1, 1, 1]) == -4)\nassert(prod_signs(arr:\
    \ [-1, 1, 1, 0]) == 0)"
  status: Exception
  stderr: 'tmprwx6xu7r/tmprwx6xu7r.swift:33: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002ab78da2ec80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002ab78d725b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002ab78d725988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002ab78d7247b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmprwx6xu7r                        0x000055be72472639 <unavailable> + 5689

    5    libc.so.6                          0x00002ab78dc1a460 __libc_start_main +
    245

    6    tmprwx6xu7r                        0x000055be724721c9 <unavailable> + 4553

    '
  stdout: ''
  timestamp: 1659979793
- exit_code: 0
  program: "\n/// You are given an array arr of integers and you need to return\n\
    /// sum of magnitudes of integers multiplied by product of all signs\n/// of each\
    \ number in the array, represented by 1, -1 or 0.\n/// Note: return nil for empty\
    \ arr.\n/// Example:\n/// >>> prod_signs(arr: [1, 2, 2, -4])\n/// 9\n/// >>> prod_signs(arr:\
    \ [0, 1])\n/// 0\n/// >>> prod_signs(arr: [] as [Int])\n/// nil\nfunc prod_signs(arr:\
    \ [Int]) -> Int? {\n  let size = arr.count\n  var product = 1\n  var sum = 0\n\
    \  if size == 0 {\n    return nil\n  }\n  for i in 0..<size {\n    if arr[i] <\
    \ 0 {\n      product *= -1\n    } else if arr[i] > 0 {\n      product *= 1\n \
    \   } else {\n      product *= 0\n    }\n    sum += abs(arr[i])\n  }\n  return\
    \ sum * product\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool\
    \ {\n    if left.count != right.count {\n        return false\n    }\n    for\
    \ (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(prod_signs(arr: [1,\
    \ 2, 2, -4]) == -9)\nassert(prod_signs(arr: [0, 1]) == 0)\nassert(prod_signs(arr:\
    \ [1, 1, 1, 2, 3, -1, 1]) == -10)\nassert(prod_signs(arr: [] as [Int]) == nil)\n\
    assert(prod_signs(arr: [2, 4, 1, 2, -1, -1, 9]) == 20)\nassert(prod_signs(arr:\
    \ [-1, 1, -1, 1]) == 4)\nassert(prod_signs(arr: [-1, 1, 1, 1]) == -4)\nassert(prod_signs(arr:\
    \ [-1, 1, 1, 0]) == 0)"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659979793
- exit_code: 0
  program: "\n/// You are given an array arr of integers and you need to return\n\
    /// sum of magnitudes of integers multiplied by product of all signs\n/// of each\
    \ number in the array, represented by 1, -1 or 0.\n/// Note: return nil for empty\
    \ arr.\n/// Example:\n/// >>> prod_signs(arr: [1, 2, 2, -4])\n/// 9\n/// >>> prod_signs(arr:\
    \ [0, 1])\n/// 0\n/// >>> prod_signs(arr: [] as [Int])\n/// nil\nfunc prod_signs(arr:\
    \ [Int]) -> Int? {\n    guard arr.count > 0 else { return nil }\n    var prod\
    \ = 1\n    var sum = 0\n    for el in arr {\n        if el > 0 {\n           \
    \ prod *= 1\n        } else if el < 0 {\n            prod *= -1\n        } else\
    \ {\n            prod *= 0\n        }\n        sum += abs(el)\n    }\n    return\
    \ sum * prod\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool\
    \ {\n    if left.count != right.count {\n        return false\n    }\n    for\
    \ (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(prod_signs(arr: [1,\
    \ 2, 2, -4]) == -9)\nassert(prod_signs(arr: [0, 1]) == 0)\nassert(prod_signs(arr:\
    \ [1, 1, 1, 2, 3, -1, 1]) == -10)\nassert(prod_signs(arr: [] as [Int]) == nil)\n\
    assert(prod_signs(arr: [2, 4, 1, 2, -1, -1, 9]) == 20)\nassert(prod_signs(arr:\
    \ [-1, 1, -1, 1]) == 4)\nassert(prod_signs(arr: [-1, 1, 1, 1]) == -4)\nassert(prod_signs(arr:\
    \ [-1, 1, 1, 0]) == 0)"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659979793
- exit_code: -4
  program: "\n/// You are given an array arr of integers and you need to return\n\
    /// sum of magnitudes of integers multiplied by product of all signs\n/// of each\
    \ number in the array, represented by 1, -1 or 0.\n/// Note: return nil for empty\
    \ arr.\n/// Example:\n/// >>> prod_signs(arr: [1, 2, 2, -4])\n/// 9\n/// >>> prod_signs(arr:\
    \ [0, 1])\n/// 0\n/// >>> prod_signs(arr: [] as [Int])\n/// nil\nfunc prod_signs(arr:\
    \ [Int]) -> Int? {\n    let arrMagnitude = arr.map{ abs($0) }\n    let arrSign\
    \ = arr.map{ $0 > 0 ? 1 : ($0 < 0 ? -1 : 0) }\n    guard !arrMagnitude.isEmpty\
    \ else { return nil }\n    return arrMagnitude.reduce(1, *) * arrSign.reduce(1,\
    \ *)\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if\
    \ left.count != right.count {\n        return false\n    }\n    for (l, r) in\
    \ zip(left, right) {\n        if l != r {\n            return false\n        }\n\
    \    }\n    return true\n}\n            \nassert(prod_signs(arr: [1, 2, 2, -4])\
    \ == -9)\nassert(prod_signs(arr: [0, 1]) == 0)\nassert(prod_signs(arr: [1, 1,\
    \ 1, 2, 3, -1, 1]) == -10)\nassert(prod_signs(arr: [] as [Int]) == nil)\nassert(prod_signs(arr:\
    \ [2, 4, 1, 2, -1, -1, 9]) == 20)\nassert(prod_signs(arr: [-1, 1, -1, 1]) == 4)\n\
    assert(prod_signs(arr: [-1, 1, 1, 1]) == -4)\nassert(prod_signs(arr: [-1, 1, 1,\
    \ 0]) == 0)"
  status: Exception
  stderr: 'tmpm1b3ev6t/tmpm1b3ev6t.swift:33: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b772cf01c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b772cbf8b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b772cbf8988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b772cbf77b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpm1b3ev6t                        0x000055999cc00639 <unavailable> + 5689

    5    libc.so.6                          0x00002b772d0ed460 __libc_start_main +
    245

    6    tmpm1b3ev6t                        0x000055999cc001c9 <unavailable> + 4553

    '
  stdout: ''
  timestamp: 1659979793
- exit_code: 0
  program: "\n/// You are given an array arr of integers and you need to return\n\
    /// sum of magnitudes of integers multiplied by product of all signs\n/// of each\
    \ number in the array, represented by 1, -1 or 0.\n/// Note: return nil for empty\
    \ arr.\n/// Example:\n/// >>> prod_signs(arr: [1, 2, 2, -4])\n/// 9\n/// >>> prod_signs(arr:\
    \ [0, 1])\n/// 0\n/// >>> prod_signs(arr: [] as [Int])\n/// nil\nfunc prod_signs(arr:\
    \ [Int]) -> Int? {\n    var prod = 1\n    var sum = 0\n    if arr.count == 0 {\n\
    \        return nil\n    }\n    for num in arr {\n        if num > 0 {\n     \
    \       prod *= 1\n        } else if num < 0 {\n            prod *= -1\n     \
    \   } else {\n            prod *= 0\n        }\n        sum += abs(num)\n    }\n\
    \    return sum * prod\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(prod_signs(arr:\
    \ [1, 2, 2, -4]) == -9)\nassert(prod_signs(arr: [0, 1]) == 0)\nassert(prod_signs(arr:\
    \ [1, 1, 1, 2, 3, -1, 1]) == -10)\nassert(prod_signs(arr: [] as [Int]) == nil)\n\
    assert(prod_signs(arr: [2, 4, 1, 2, -1, -1, 9]) == 20)\nassert(prod_signs(arr:\
    \ [-1, 1, -1, 1]) == 4)\nassert(prod_signs(arr: [-1, 1, 1, 1]) == -4)\nassert(prod_signs(arr:\
    \ [-1, 1, 1, 0]) == 0)"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659979793
- exit_code: -4
  program: "\n/// You are given an array arr of integers and you need to return\n\
    /// sum of magnitudes of integers multiplied by product of all signs\n/// of each\
    \ number in the array, represented by 1, -1 or 0.\n/// Note: return nil for empty\
    \ arr.\n/// Example:\n/// >>> prod_signs(arr: [1, 2, 2, -4])\n/// 9\n/// >>> prod_signs(arr:\
    \ [0, 1])\n/// 0\n/// >>> prod_signs(arr: [] as [Int])\n/// nil\nfunc prod_signs(arr:\
    \ [Int]) -> Int? {\n    guard arr.count > 0 else { return nil }\n    var signs\
    \ = [Int]()\n    for num in arr {\n        if num == 0 {\n            signs.append(0)\n\
    \        } else if num > 0 {\n            signs.append(1)\n        } else {\n\
    \            signs.append(-1)\n        }\n    }\n    var sum = 0\n    var prod\
    \ = 1\n    for sign in signs {\n        sum += sign\n        prod *= sign\n  \
    \  }\n    if sum > 0 {\n        return sum * prod\n    } else {\n        return\
    \ 0\n    }\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n\
    \    if left.count != right.count {\n        return false\n    }\n    for (l,\
    \ r) in zip(left, right) {\n        if l != r {\n            return false\n  \
    \      }\n    }\n    return true\n}\n            \nassert(prod_signs(arr: [1,\
    \ 2, 2, -4]) == -9)\nassert(prod_signs(arr: [0, 1]) == 0)\nassert(prod_signs(arr:\
    \ [1, 1, 1, 2, 3, -1, 1]) == -10)\nassert(prod_signs(arr: [] as [Int]) == nil)\n\
    assert(prod_signs(arr: [2, 4, 1, 2, -1, -1, 9]) == 20)\nassert(prod_signs(arr:\
    \ [-1, 1, -1, 1]) == 4)\nassert(prod_signs(arr: [-1, 1, 1, 1]) == -4)\nassert(prod_signs(arr:\
    \ [-1, 1, 1, 0]) == 0)"
  status: Exception
  stderr: 'tmp1dqmhymy/tmp1dqmhymy.swift:51: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b8877c13c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b887790ab6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b887790a988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b88779097b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmp1dqmhymy                        0x000055bcb50ae659 <unavailable> + 5721

    5    libc.so.6                          0x00002b8877dff460 __libc_start_main +
    245

    6    tmp1dqmhymy                        0x000055bcb50ae1e9 <unavailable> + 4585

    '
  stdout: ''
  timestamp: 1659979793
- exit_code: 0
  program: "\n/// You are given an array arr of integers and you need to return\n\
    /// sum of magnitudes of integers multiplied by product of all signs\n/// of each\
    \ number in the array, represented by 1, -1 or 0.\n/// Note: return nil for empty\
    \ arr.\n/// Example:\n/// >>> prod_signs(arr: [1, 2, 2, -4])\n/// 9\n/// >>> prod_signs(arr:\
    \ [0, 1])\n/// 0\n/// >>> prod_signs(arr: [] as [Int])\n/// nil\nfunc prod_signs(arr:\
    \ [Int]) -> Int? {\n  if arr.isEmpty {\n    return nil\n  }\n  let sign_prod =\
    \ arr.reduce(1) { $0 * $1.signum() }\n  let sum = arr.reduce(0) { $0 + abs($1)\
    \ }\n  return sum * sign_prod\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int,\
    \ Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n\
    \    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n          \
    \  return false\n        }\n    }\n    return true\n}\n            \nassert(prod_signs(arr:\
    \ [1, 2, 2, -4]) == -9)\nassert(prod_signs(arr: [0, 1]) == 0)\nassert(prod_signs(arr:\
    \ [1, 1, 1, 2, 3, -1, 1]) == -10)\nassert(prod_signs(arr: [] as [Int]) == nil)\n\
    assert(prod_signs(arr: [2, 4, 1, 2, -1, -1, 9]) == 20)\nassert(prod_signs(arr:\
    \ [-1, 1, -1, 1]) == 4)\nassert(prod_signs(arr: [-1, 1, 1, 1]) == -4)\nassert(prod_signs(arr:\
    \ [-1, 1, 1, 0]) == 0)"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659979793
- exit_code: -4
  program: "\n/// You are given an array arr of integers and you need to return\n\
    /// sum of magnitudes of integers multiplied by product of all signs\n/// of each\
    \ number in the array, represented by 1, -1 or 0.\n/// Note: return nil for empty\
    \ arr.\n/// Example:\n/// >>> prod_signs(arr: [1, 2, 2, -4])\n/// 9\n/// >>> prod_signs(arr:\
    \ [0, 1])\n/// 0\n/// >>> prod_signs(arr: [] as [Int])\n/// nil\nfunc prod_signs(arr:\
    \ [Int]) -> Int? {\n    guard arr.count > 0 else { return nil }\n    var sum =\
    \ 0\n    var sign = 1\n    for num in arr {\n        if num < 0 {\n          \
    \  sign *= -1\n        }\n        sum += abs(num)\n    }\n    return sum * sign\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(prod_signs(arr: [1, 2, 2, -4]) == -9)\nassert(prod_signs(arr:\
    \ [0, 1]) == 0)\nassert(prod_signs(arr: [1, 1, 1, 2, 3, -1, 1]) == -10)\nassert(prod_signs(arr:\
    \ [] as [Int]) == nil)\nassert(prod_signs(arr: [2, 4, 1, 2, -1, -1, 9]) == 20)\n\
    assert(prod_signs(arr: [-1, 1, -1, 1]) == 4)\nassert(prod_signs(arr: [-1, 1, 1,\
    \ 1]) == -4)\nassert(prod_signs(arr: [-1, 1, 1, 0]) == 0)"
  status: Exception
  stderr: 'tmpkt92tps7/tmpkt92tps7.swift:40: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b27a9fb7c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b27a9caeb6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b27a9cae988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b27a9cad7b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpkt92tps7                        0x0000563648f5a815 <unavailable> + 6165

    5    libc.so.6                          0x00002b27aa1a3460 __libc_start_main +
    245

    6    tmpkt92tps7                        0x0000563648f5a219 <unavailable> + 4633

    '
  stdout: ''
  timestamp: 1659979793
- exit_code: 0
  program: "\n/// You are given an array arr of integers and you need to return\n\
    /// sum of magnitudes of integers multiplied by product of all signs\n/// of each\
    \ number in the array, represented by 1, -1 or 0.\n/// Note: return nil for empty\
    \ arr.\n/// Example:\n/// >>> prod_signs(arr: [1, 2, 2, -4])\n/// 9\n/// >>> prod_signs(arr:\
    \ [0, 1])\n/// 0\n/// >>> prod_signs(arr: [] as [Int])\n/// nil\nfunc prod_signs(arr:\
    \ [Int]) -> Int? {\n    guard arr.count > 0 else {\n        return nil\n    }\n\
    \    let sign_prod = arr.reduce(1) { (result, element) -> Int in\n        if element\
    \ > 0 {\n            return result * 1\n        } else if element < 0 {\n    \
    \        return result * -1\n        } else {\n            return result * 0\n\
    \        }\n    }\n    let mag_sum = arr.reduce(0) { (result, element) -> Int\
    \ in\n        return result + abs(element)\n    }\n    return mag_sum * sign_prod\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(prod_signs(arr: [1, 2, 2, -4]) == -9)\nassert(prod_signs(arr:\
    \ [0, 1]) == 0)\nassert(prod_signs(arr: [1, 1, 1, 2, 3, -1, 1]) == -10)\nassert(prod_signs(arr:\
    \ [] as [Int]) == nil)\nassert(prod_signs(arr: [2, 4, 1, 2, -1, -1, 9]) == 20)\n\
    assert(prod_signs(arr: [-1, 1, -1, 1]) == 4)\nassert(prod_signs(arr: [-1, 1, 1,\
    \ 1]) == -4)\nassert(prod_signs(arr: [-1, 1, 1, 0]) == 0)"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659979793
- exit_code: 0
  program: "\n/// You are given an array arr of integers and you need to return\n\
    /// sum of magnitudes of integers multiplied by product of all signs\n/// of each\
    \ number in the array, represented by 1, -1 or 0.\n/// Note: return nil for empty\
    \ arr.\n/// Example:\n/// >>> prod_signs(arr: [1, 2, 2, -4])\n/// 9\n/// >>> prod_signs(arr:\
    \ [0, 1])\n/// 0\n/// >>> prod_signs(arr: [] as [Int])\n/// nil\nfunc prod_signs(arr:\
    \ [Int]) -> Int? {\n    guard arr.count > 0 else { return nil }\n    var signProduct\
    \ = 1\n    var sum = 0\n    for i in arr {\n        if i > 0 {\n            signProduct\
    \ *= 1\n        } else if i < 0 {\n            signProduct *= -1\n        } else\
    \ {\n            signProduct *= 0\n        }\n        sum += abs(i)\n    }\n \
    \   return sum * signProduct\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int,\
    \ Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n\
    \    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n          \
    \  return false\n        }\n    }\n    return true\n}\n            \nassert(prod_signs(arr:\
    \ [1, 2, 2, -4]) == -9)\nassert(prod_signs(arr: [0, 1]) == 0)\nassert(prod_signs(arr:\
    \ [1, 1, 1, 2, 3, -1, 1]) == -10)\nassert(prod_signs(arr: [] as [Int]) == nil)\n\
    assert(prod_signs(arr: [2, 4, 1, 2, -1, -1, 9]) == 20)\nassert(prod_signs(arr:\
    \ [-1, 1, -1, 1]) == 4)\nassert(prod_signs(arr: [-1, 1, 1, 1]) == -4)\nassert(prod_signs(arr:\
    \ [-1, 1, 1, 0]) == 0)"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659979793
- exit_code: 1
  program: "\n/// You are given an array arr of integers and you need to return\n\
    /// sum of magnitudes of integers multiplied by product of all signs\n/// of each\
    \ number in the array, represented by 1, -1 or 0.\n/// Note: return nil for empty\
    \ arr.\n/// Example:\n/// >>> prod_signs(arr: [1, 2, 2, -4])\n/// 9\n/// >>> prod_signs(arr:\
    \ [0, 1])\n/// 0\n/// >>> prod_signs(arr: [] as [Int])\n/// nil\nfunc prod_signs(arr:\
    \ [Int]) -> Int? {\n    if arr.isEmpty {\n        return nil\n    }\n    let sum\
    \ = arr.reduce(0) { $0 + $1.magnitude }\n    var prod = 1\n    for num in arr\
    \ {\n        if num < 0 {\n            prod *= -1\n        } else if num > 0 {\n\
    \            prod *= 1\n        } else {\n            return 0\n        }\n  \
    \  }\n    return sum * prod\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int,\
    \ Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n\
    \    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n          \
    \  return false\n        }\n    }\n    return true\n}\n            \nassert(prod_signs(arr:\
    \ [1, 2, 2, -4]) == -9)\nassert(prod_signs(arr: [0, 1]) == 0)\nassert(prod_signs(arr:\
    \ [1, 1, 1, 2, 3, -1, 1]) == -10)\nassert(prod_signs(arr: [] as [Int]) == nil)\n\
    assert(prod_signs(arr: [2, 4, 1, 2, -1, -1, 9]) == 20)\nassert(prod_signs(arr:\
    \ [-1, 1, -1, 1]) == 4)\nassert(prod_signs(arr: [-1, 1, 1, 1]) == -4)\nassert(prod_signs(arr:\
    \ [-1, 1, 1, 0]) == 0)"
  status: SyntaxError
  stderr: "/tmp/tmpo37_7zvo.swift:28:12: error: cannot convert value of type 'UInt'\
    \ to expected argument type 'Int'\n    return sum * prod\n           ^\n     \
    \      Int( )\n"
  stdout: ''
  timestamp: 1659979793
- exit_code: 0
  program: "\n/// You are given an array arr of integers and you need to return\n\
    /// sum of magnitudes of integers multiplied by product of all signs\n/// of each\
    \ number in the array, represented by 1, -1 or 0.\n/// Note: return nil for empty\
    \ arr.\n/// Example:\n/// >>> prod_signs(arr: [1, 2, 2, -4])\n/// 9\n/// >>> prod_signs(arr:\
    \ [0, 1])\n/// 0\n/// >>> prod_signs(arr: [] as [Int])\n/// nil\nfunc prod_signs(arr:\
    \ [Int]) -> Int? {\n    guard arr.count > 0 else { return nil }\n    return arr.map\
    \ { $0 < 0 ? -1 : $0 > 0 ? 1 : 0 }.reduce(1, *) * arr.map { abs($0) }.reduce(0,\
    \ +)\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if\
    \ left.count != right.count {\n        return false\n    }\n    for (l, r) in\
    \ zip(left, right) {\n        if l != r {\n            return false\n        }\n\
    \    }\n    return true\n}\n            \nassert(prod_signs(arr: [1, 2, 2, -4])\
    \ == -9)\nassert(prod_signs(arr: [0, 1]) == 0)\nassert(prod_signs(arr: [1, 1,\
    \ 1, 2, 3, -1, 1]) == -10)\nassert(prod_signs(arr: [] as [Int]) == nil)\nassert(prod_signs(arr:\
    \ [2, 4, 1, 2, -1, -1, 9]) == 20)\nassert(prod_signs(arr: [-1, 1, -1, 1]) == 4)\n\
    assert(prod_signs(arr: [-1, 1, 1, 1]) == -4)\nassert(prod_signs(arr: [-1, 1, 1,\
    \ 0]) == 0)"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659979794
- exit_code: 0
  program: "\n/// You are given an array arr of integers and you need to return\n\
    /// sum of magnitudes of integers multiplied by product of all signs\n/// of each\
    \ number in the array, represented by 1, -1 or 0.\n/// Note: return nil for empty\
    \ arr.\n/// Example:\n/// >>> prod_signs(arr: [1, 2, 2, -4])\n/// 9\n/// >>> prod_signs(arr:\
    \ [0, 1])\n/// 0\n/// >>> prod_signs(arr: [] as [Int])\n/// nil\nfunc prod_signs(arr:\
    \ [Int]) -> Int? {\n  guard arr.count > 0 else { return nil }\n  let count = arr.count\n\
    \  var total = 1\n  var sum = 0\n  for i in 0..<count {\n    if arr[i] > 0 {\n\
    \      total *= 1\n    } else if arr[i] < 0 {\n      total *= -1\n    } else {\n\
    \      total *= 0\n    }\n    sum += abs(arr[i])\n  }\n  return total * sum\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(prod_signs(arr: [1, 2, 2, -4]) == -9)\nassert(prod_signs(arr:\
    \ [0, 1]) == 0)\nassert(prod_signs(arr: [1, 1, 1, 2, 3, -1, 1]) == -10)\nassert(prod_signs(arr:\
    \ [] as [Int]) == nil)\nassert(prod_signs(arr: [2, 4, 1, 2, -1, -1, 9]) == 20)\n\
    assert(prod_signs(arr: [-1, 1, -1, 1]) == 4)\nassert(prod_signs(arr: [-1, 1, 1,\
    \ 1]) == -4)\nassert(prod_signs(arr: [-1, 1, 1, 0]) == 0)"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659979794
- exit_code: 0
  program: "\n/// You are given an array arr of integers and you need to return\n\
    /// sum of magnitudes of integers multiplied by product of all signs\n/// of each\
    \ number in the array, represented by 1, -1 or 0.\n/// Note: return nil for empty\
    \ arr.\n/// Example:\n/// >>> prod_signs(arr: [1, 2, 2, -4])\n/// 9\n/// >>> prod_signs(arr:\
    \ [0, 1])\n/// 0\n/// >>> prod_signs(arr: [] as [Int])\n/// nil\nfunc prod_signs(arr:\
    \ [Int]) -> Int? {\n    if arr.isEmpty {\n        return nil\n    }\n    var prod\
    \ = 1\n    var sum = 0\n    for i in arr {\n        prod *= i > 0 ? 1 : i < 0\
    \ ? -1 : 0\n        sum += abs(i)\n    }\n    return prod * sum\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(prod_signs(arr: [1, 2, 2, -4]) == -9)\nassert(prod_signs(arr:\
    \ [0, 1]) == 0)\nassert(prod_signs(arr: [1, 1, 1, 2, 3, -1, 1]) == -10)\nassert(prod_signs(arr:\
    \ [] as [Int]) == nil)\nassert(prod_signs(arr: [2, 4, 1, 2, -1, -1, 9]) == 20)\n\
    assert(prod_signs(arr: [-1, 1, -1, 1]) == 4)\nassert(prod_signs(arr: [-1, 1, 1,\
    \ 1]) == -4)\nassert(prod_signs(arr: [-1, 1, 1, 0]) == 0)"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659979794
- exit_code: 0
  program: "\n/// You are given an array arr of integers and you need to return\n\
    /// sum of magnitudes of integers multiplied by product of all signs\n/// of each\
    \ number in the array, represented by 1, -1 or 0.\n/// Note: return nil for empty\
    \ arr.\n/// Example:\n/// >>> prod_signs(arr: [1, 2, 2, -4])\n/// 9\n/// >>> prod_signs(arr:\
    \ [0, 1])\n/// 0\n/// >>> prod_signs(arr: [] as [Int])\n/// nil\nfunc prod_signs(arr:\
    \ [Int]) -> Int? {\n    if arr.isEmpty {\n        return nil\n    }\n    var prod\
    \ = 1\n    var sum = 0\n    for e in arr {\n        if e < 0 {\n            prod\
    \ *= -1\n        } else if e > 0 {\n            prod *= 1\n        } else {\n\
    \            prod *= 0\n        }\n        sum += abs(e)\n    }\n    return sum\
    \ * prod\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n\
    \    if left.count != right.count {\n        return false\n    }\n    for (l,\
    \ r) in zip(left, right) {\n        if l != r {\n            return false\n  \
    \      }\n    }\n    return true\n}\n            \nassert(prod_signs(arr: [1,\
    \ 2, 2, -4]) == -9)\nassert(prod_signs(arr: [0, 1]) == 0)\nassert(prod_signs(arr:\
    \ [1, 1, 1, 2, 3, -1, 1]) == -10)\nassert(prod_signs(arr: [] as [Int]) == nil)\n\
    assert(prod_signs(arr: [2, 4, 1, 2, -1, -1, 9]) == 20)\nassert(prod_signs(arr:\
    \ [-1, 1, -1, 1]) == 4)\nassert(prod_signs(arr: [-1, 1, 1, 1]) == -4)\nassert(prod_signs(arr:\
    \ [-1, 1, 1, 0]) == 0)"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659979794
- exit_code: -4
  program: "\n/// You are given an array arr of integers and you need to return\n\
    /// sum of magnitudes of integers multiplied by product of all signs\n/// of each\
    \ number in the array, represented by 1, -1 or 0.\n/// Note: return nil for empty\
    \ arr.\n/// Example:\n/// >>> prod_signs(arr: [1, 2, 2, -4])\n/// 9\n/// >>> prod_signs(arr:\
    \ [0, 1])\n/// 0\n/// >>> prod_signs(arr: [] as [Int])\n/// nil\nfunc prod_signs(arr:\
    \ [Int]) -> Int? {\n    guard arr.count > 0 else { return nil }\n    let sign:\
    \ Int = {\n        var sign: Int = 1\n        for x in arr {\n            if x\
    \ < 0 {\n                sign *= -1\n            }\n        }\n        return\
    \ sign\n    }()\n    return arr.map({ abs($0) }).reduce(1, { $0 * $1 }) * sign\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(prod_signs(arr: [1, 2, 2, -4]) == -9)\nassert(prod_signs(arr:\
    \ [0, 1]) == 0)\nassert(prod_signs(arr: [1, 1, 1, 2, 3, -1, 1]) == -10)\nassert(prod_signs(arr:\
    \ [] as [Int]) == nil)\nassert(prod_signs(arr: [2, 4, 1, 2, -1, -1, 9]) == 20)\n\
    assert(prod_signs(arr: [-1, 1, -1, 1]) == 4)\nassert(prod_signs(arr: [-1, 1, 1,\
    \ 1]) == -4)\nassert(prod_signs(arr: [-1, 1, 1, 0]) == 0)"
  status: Exception
  stderr: 'tmpk1uma1rh/tmpk1uma1rh.swift:40: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b1fda687c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b1fda37eb6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b1fda37e988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b1fda37d7b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpk1uma1rh                        0x00005614434a5769 <unavailable> + 5993

    5    libc.so.6                          0x00002b1fda873460 __libc_start_main +
    245

    6    tmpk1uma1rh                        0x00005614434a52f9 <unavailable> + 4857

    '
  stdout: ''
  timestamp: 1659979794
- exit_code: -4
  program: "\n/// You are given an array arr of integers and you need to return\n\
    /// sum of magnitudes of integers multiplied by product of all signs\n/// of each\
    \ number in the array, represented by 1, -1 or 0.\n/// Note: return nil for empty\
    \ arr.\n/// Example:\n/// >>> prod_signs(arr: [1, 2, 2, -4])\n/// 9\n/// >>> prod_signs(arr:\
    \ [0, 1])\n/// 0\n/// >>> prod_signs(arr: [] as [Int])\n/// nil\nfunc prod_signs(arr:\
    \ [Int]) -> Int? {\n    let signs = arr.map { $0 == 0 ? 0 : $0 > 0 ? 1 : -1 }\n\
    \    let prods = signs.reduce(1, *)\n    let sums = arr.map{ abs($0) }.reduce(0,\
    \ +)\n    return prods * sums\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int,\
    \ Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n\
    \    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n          \
    \  return false\n        }\n    }\n    return true\n}\n            \nassert(prod_signs(arr:\
    \ [1, 2, 2, -4]) == -9)\nassert(prod_signs(arr: [0, 1]) == 0)\nassert(prod_signs(arr:\
    \ [1, 1, 1, 2, 3, -1, 1]) == -10)\nassert(prod_signs(arr: [] as [Int]) == nil)\n\
    assert(prod_signs(arr: [2, 4, 1, 2, -1, -1, 9]) == 20)\nassert(prod_signs(arr:\
    \ [-1, 1, -1, 1]) == 4)\nassert(prod_signs(arr: [-1, 1, 1, 1]) == -4)\nassert(prod_signs(arr:\
    \ [-1, 1, 1, 0]) == 0)"
  status: Exception
  stderr: 'tmpif3jqvfk/tmpif3jqvfk.swift:36: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002af2866bac80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002af2863b1b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002af2863b1988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002af2863b07b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpif3jqvfk                        0x00005643e0399a0c <unavailable> + 6668

    5    libc.so.6                          0x00002af2868a6460 __libc_start_main +
    245

    6    tmpif3jqvfk                        0x00005643e0399179 <unavailable> + 4473

    '
  stdout: ''
  timestamp: 1659979794
- exit_code: -4
  program: "\n/// You are given an array arr of integers and you need to return\n\
    /// sum of magnitudes of integers multiplied by product of all signs\n/// of each\
    \ number in the array, represented by 1, -1 or 0.\n/// Note: return nil for empty\
    \ arr.\n/// Example:\n/// >>> prod_signs(arr: [1, 2, 2, -4])\n/// 9\n/// >>> prod_signs(arr:\
    \ [0, 1])\n/// 0\n/// >>> prod_signs(arr: [] as [Int])\n/// nil\nfunc prod_signs(arr:\
    \ [Int]) -> Int? {\n    if arr.isEmpty {\n        return nil\n    }\n    let result\
    \ = arr.reduce(1) {$0 * $1}\n    return arr.reduce(0) {$0 + abs($1) * result}\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(prod_signs(arr: [1, 2, 2, -4]) == -9)\nassert(prod_signs(arr:\
    \ [0, 1]) == 0)\nassert(prod_signs(arr: [1, 1, 1, 2, 3, -1, 1]) == -10)\nassert(prod_signs(arr:\
    \ [] as [Int]) == nil)\nassert(prod_signs(arr: [2, 4, 1, 2, -1, -1, 9]) == 20)\n\
    assert(prod_signs(arr: [-1, 1, -1, 1]) == 4)\nassert(prod_signs(arr: [-1, 1, 1,\
    \ 1]) == -4)\nassert(prod_signs(arr: [-1, 1, 1, 0]) == 0)"
  status: Exception
  stderr: 'tmp9yfp9_h_/tmp9yfp9_h_.swift:34: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b464ed85c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b464ea7cb6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b464ea7c988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b464ea7b7b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmp9yfp9_h_                        0x00005647999675c9 <unavailable> + 5577

    5    libc.so.6                          0x00002b464ef71460 __libc_start_main +
    245

    6    tmp9yfp9_h_                        0x0000564799967159 <unavailable> + 4441

    '
  stdout: ''
  timestamp: 1659979794
- exit_code: 0
  program: "\n/// You are given an array arr of integers and you need to return\n\
    /// sum of magnitudes of integers multiplied by product of all signs\n/// of each\
    \ number in the array, represented by 1, -1 or 0.\n/// Note: return nil for empty\
    \ arr.\n/// Example:\n/// >>> prod_signs(arr: [1, 2, 2, -4])\n/// 9\n/// >>> prod_signs(arr:\
    \ [0, 1])\n/// 0\n/// >>> prod_signs(arr: [] as [Int])\n/// nil\nfunc prod_signs(arr:\
    \ [Int]) -> Int? {\n    if arr.isEmpty {\n        return nil\n    }\n    let sum\
    \ = arr.reduce(0) { $0 + abs($1) }\n    let sign = arr.reduce(1) { x, y in x *\
    \ (y > 0 ? 1 : y < 0 ? -1 : 0) }\n    return sum * sign\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(prod_signs(arr: [1, 2, 2, -4]) == -9)\nassert(prod_signs(arr:\
    \ [0, 1]) == 0)\nassert(prod_signs(arr: [1, 1, 1, 2, 3, -1, 1]) == -10)\nassert(prod_signs(arr:\
    \ [] as [Int]) == nil)\nassert(prod_signs(arr: [2, 4, 1, 2, -1, -1, 9]) == 20)\n\
    assert(prod_signs(arr: [-1, 1, -1, 1]) == 4)\nassert(prod_signs(arr: [-1, 1, 1,\
    \ 1]) == -4)\nassert(prod_signs(arr: [-1, 1, 1, 0]) == 0)"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659979794
- exit_code: 0
  program: "\n/// You are given an array arr of integers and you need to return\n\
    /// sum of magnitudes of integers multiplied by product of all signs\n/// of each\
    \ number in the array, represented by 1, -1 or 0.\n/// Note: return nil for empty\
    \ arr.\n/// Example:\n/// >>> prod_signs(arr: [1, 2, 2, -4])\n/// 9\n/// >>> prod_signs(arr:\
    \ [0, 1])\n/// 0\n/// >>> prod_signs(arr: [] as [Int])\n/// nil\nfunc prod_signs(arr:\
    \ [Int]) -> Int? {\n    if arr.isEmpty {\n        return nil\n    }\n    var product:\
    \ Int = 1\n    var sum: Int = 0\n    for num in arr {\n        product *= (num\
    \ > 0 ? 1 : (num < 0 ? -1 : 0))\n        sum += abs(num)\n    }\n    return product\
    \ * sum\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n \
    \   if left.count != right.count {\n        return false\n    }\n    for (l, r)\
    \ in zip(left, right) {\n        if l != r {\n            return false\n     \
    \   }\n    }\n    return true\n}\n            \nassert(prod_signs(arr: [1, 2,\
    \ 2, -4]) == -9)\nassert(prod_signs(arr: [0, 1]) == 0)\nassert(prod_signs(arr:\
    \ [1, 1, 1, 2, 3, -1, 1]) == -10)\nassert(prod_signs(arr: [] as [Int]) == nil)\n\
    assert(prod_signs(arr: [2, 4, 1, 2, -1, -1, 9]) == 20)\nassert(prod_signs(arr:\
    \ [-1, 1, -1, 1]) == 4)\nassert(prod_signs(arr: [-1, 1, 1, 1]) == -4)\nassert(prod_signs(arr:\
    \ [-1, 1, 1, 0]) == 0)"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659979794
- exit_code: -4
  program: "\n/// You are given an array arr of integers and you need to return\n\
    /// sum of magnitudes of integers multiplied by product of all signs\n/// of each\
    \ number in the array, represented by 1, -1 or 0.\n/// Note: return nil for empty\
    \ arr.\n/// Example:\n/// >>> prod_signs(arr: [1, 2, 2, -4])\n/// 9\n/// >>> prod_signs(arr:\
    \ [0, 1])\n/// 0\n/// >>> prod_signs(arr: [] as [Int])\n/// nil\nfunc prod_signs(arr:\
    \ [Int]) -> Int? {\n    guard arr.count > 0 else { return nil }\n    return arr.reduce(0)\
    \ {\n        let sign = $1 > 0 ? 1 : $1 < 0 ? -1 : 0\n        return sign != 0\
    \ ? $0 + abs($1) * sign : $0\n    }\n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(prod_signs(arr: [1, 2, 2, -4]) == -9)\nassert(prod_signs(arr: [0, 1]) ==\
    \ 0)\nassert(prod_signs(arr: [1, 1, 1, 2, 3, -1, 1]) == -10)\nassert(prod_signs(arr:\
    \ [] as [Int]) == nil)\nassert(prod_signs(arr: [2, 4, 1, 2, -1, -1, 9]) == 20)\n\
    assert(prod_signs(arr: [-1, 1, -1, 1]) == 4)\nassert(prod_signs(arr: [-1, 1, 1,\
    \ 1]) == -4)\nassert(prod_signs(arr: [-1, 1, 1, 0]) == 0)"
  status: Exception
  stderr: 'tmpfgt1w5ax/tmpfgt1w5ax.swift:34: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b976efb2c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b976eca9b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b976eca9988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b976eca87b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpfgt1w5ax                        0x0000557a1670a599 <unavailable> + 5529

    5    libc.so.6                          0x00002b976f19e460 __libc_start_main +
    245

    6    tmpfgt1w5ax                        0x0000557a1670a129 <unavailable> + 4393

    '
  stdout: ''
  timestamp: 1659979794
- exit_code: 0
  program: "\n/// You are given an array arr of integers and you need to return\n\
    /// sum of magnitudes of integers multiplied by product of all signs\n/// of each\
    \ number in the array, represented by 1, -1 or 0.\n/// Note: return nil for empty\
    \ arr.\n/// Example:\n/// >>> prod_signs(arr: [1, 2, 2, -4])\n/// 9\n/// >>> prod_signs(arr:\
    \ [0, 1])\n/// 0\n/// >>> prod_signs(arr: [] as [Int])\n/// nil\nfunc prod_signs(arr:\
    \ [Int]) -> Int? {\n    guard arr.count > 0 else { return nil }\n    return arr.map\
    \ { $0 < 0 ? -1 : $0 > 0 ? 1 : 0 }.reduce(1, *) * arr.map { abs($0) }.reduce(0,\
    \ +)\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if\
    \ left.count != right.count {\n        return false\n    }\n    for (l, r) in\
    \ zip(left, right) {\n        if l != r {\n            return false\n        }\n\
    \    }\n    return true\n}\n            \nassert(prod_signs(arr: [1, 2, 2, -4])\
    \ == -9)\nassert(prod_signs(arr: [0, 1]) == 0)\nassert(prod_signs(arr: [1, 1,\
    \ 1, 2, 3, -1, 1]) == -10)\nassert(prod_signs(arr: [] as [Int]) == nil)\nassert(prod_signs(arr:\
    \ [2, 4, 1, 2, -1, -1, 9]) == 20)\nassert(prod_signs(arr: [-1, 1, -1, 1]) == 4)\n\
    assert(prod_signs(arr: [-1, 1, 1, 1]) == -4)\nassert(prod_signs(arr: [-1, 1, 1,\
    \ 0]) == 0)"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659979794
- exit_code: -4
  program: "\n/// You are given an array arr of integers and you need to return\n\
    /// sum of magnitudes of integers multiplied by product of all signs\n/// of each\
    \ number in the array, represented by 1, -1 or 0.\n/// Note: return nil for empty\
    \ arr.\n/// Example:\n/// >>> prod_signs(arr: [1, 2, 2, -4])\n/// 9\n/// >>> prod_signs(arr:\
    \ [0, 1])\n/// 0\n/// >>> prod_signs(arr: [] as [Int])\n/// nil\nfunc prod_signs(arr:\
    \ [Int]) -> Int? {\n    return arr.reduce((product: 1, sum: 0)) {\n        (partial,\
    \ element) in\n        let sign = element == 0 ? 0 : element < 0 ? -1 : 1\n  \
    \      return (partial.product * sign, partial.sum + abs(element))\n    }.sum\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(prod_signs(arr: [1, 2, 2, -4]) == -9)\nassert(prod_signs(arr:\
    \ [0, 1]) == 0)\nassert(prod_signs(arr: [1, 1, 1, 2, 3, -1, 1]) == -10)\nassert(prod_signs(arr:\
    \ [] as [Int]) == nil)\nassert(prod_signs(arr: [2, 4, 1, 2, -1, -1, 9]) == 20)\n\
    assert(prod_signs(arr: [-1, 1, -1, 1]) == 4)\nassert(prod_signs(arr: [-1, 1, 1,\
    \ 1]) == -4)\nassert(prod_signs(arr: [-1, 1, 1, 0]) == 0)"
  status: Exception
  stderr: 'tmp1uh8o4_g/tmp1uh8o4_g.swift:34: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002aac003b2c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002aac000a9b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002aac000a9988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002aac000a87b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmp1uh8o4_g                        0x0000555aab6e5539 <unavailable> + 5433

    5    libc.so.6                          0x00002aac0059e460 __libc_start_main +
    245

    6    tmp1uh8o4_g                        0x0000555aab6e50c9 <unavailable> + 4297

    '
  stdout: ''
  timestamp: 1659979794
- exit_code: -4
  program: "\n/// You are given an array arr of integers and you need to return\n\
    /// sum of magnitudes of integers multiplied by product of all signs\n/// of each\
    \ number in the array, represented by 1, -1 or 0.\n/// Note: return nil for empty\
    \ arr.\n/// Example:\n/// >>> prod_signs(arr: [1, 2, 2, -4])\n/// 9\n/// >>> prod_signs(arr:\
    \ [0, 1])\n/// 0\n/// >>> prod_signs(arr: [] as [Int])\n/// nil\nfunc prod_signs(arr:\
    \ [Int]) -> Int? {\n    guard arr.count > 0 else { return nil }\n    var p = 1\n\
    \    var s = 0\n    for n in arr {\n        p *= (n == 0 ? 1 : n < 0 ? -1 : 1)\n\
    \        s += (n == 0 ? 0 : abs(n))\n    }\n    return p * s\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(prod_signs(arr: [1, 2, 2, -4]) == -9)\nassert(prod_signs(arr:\
    \ [0, 1]) == 0)\nassert(prod_signs(arr: [1, 1, 1, 2, 3, -1, 1]) == -10)\nassert(prod_signs(arr:\
    \ [] as [Int]) == nil)\nassert(prod_signs(arr: [2, 4, 1, 2, -1, -1, 9]) == 20)\n\
    assert(prod_signs(arr: [-1, 1, -1, 1]) == 4)\nassert(prod_signs(arr: [-1, 1, 1,\
    \ 1]) == -4)\nassert(prod_signs(arr: [-1, 1, 1, 0]) == 0)"
  status: Exception
  stderr: 'tmp6igljsth/tmp6igljsth.swift:38: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b5806a86c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b580677db6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b580677d988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b580677c7b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmp6igljsth                        0x00005581a9c23815 <unavailable> + 6165

    5    libc.so.6                          0x00002b5806c72460 __libc_start_main +
    245

    6    tmp6igljsth                        0x00005581a9c23219 <unavailable> + 4633

    '
  stdout: ''
  timestamp: 1659979794
- exit_code: 0
  program: "\n/// You are given an array arr of integers and you need to return\n\
    /// sum of magnitudes of integers multiplied by product of all signs\n/// of each\
    \ number in the array, represented by 1, -1 or 0.\n/// Note: return nil for empty\
    \ arr.\n/// Example:\n/// >>> prod_signs(arr: [1, 2, 2, -4])\n/// 9\n/// >>> prod_signs(arr:\
    \ [0, 1])\n/// 0\n/// >>> prod_signs(arr: [] as [Int])\n/// nil\nfunc prod_signs(arr:\
    \ [Int]) -> Int? {\n    guard arr.count > 0 else {\n        return nil\n    }\n\
    \    let sign = arr.map({abs($0) > 0 ? $0 < 0 ? -1 : 1 : 0})\n    let sum = arr.map({abs($0)}).reduce(0,\
    \ +)\n    return sign.reduce(1, *) * sum\n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(prod_signs(arr: [1, 2, 2, -4]) == -9)\nassert(prod_signs(arr: [0, 1]) ==\
    \ 0)\nassert(prod_signs(arr: [1, 1, 1, 2, 3, -1, 1]) == -10)\nassert(prod_signs(arr:\
    \ [] as [Int]) == nil)\nassert(prod_signs(arr: [2, 4, 1, 2, -1, -1, 9]) == 20)\n\
    assert(prod_signs(arr: [-1, 1, -1, 1]) == 4)\nassert(prod_signs(arr: [-1, 1, 1,\
    \ 1]) == -4)\nassert(prod_signs(arr: [-1, 1, 1, 0]) == 0)"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659979794
- exit_code: -4
  program: "\n/// You are given an array arr of integers and you need to return\n\
    /// sum of magnitudes of integers multiplied by product of all signs\n/// of each\
    \ number in the array, represented by 1, -1 or 0.\n/// Note: return nil for empty\
    \ arr.\n/// Example:\n/// >>> prod_signs(arr: [1, 2, 2, -4])\n/// 9\n/// >>> prod_signs(arr:\
    \ [0, 1])\n/// 0\n/// >>> prod_signs(arr: [] as [Int])\n/// nil\nfunc prod_signs(arr:\
    \ [Int]) -> Int? {\n    let signProd = arr.reduce(1) { $0 * ($1 > 0 ? 1 : $1 <\
    \ 0 ? -1 : 0) }\n    return arr.reduce(0) { $0 + abs($1) } * signProd\n}\n\n\n\
    func ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(prod_signs(arr: [1, 2, 2, -4]) == -9)\nassert(prod_signs(arr:\
    \ [0, 1]) == 0)\nassert(prod_signs(arr: [1, 1, 1, 2, 3, -1, 1]) == -10)\nassert(prod_signs(arr:\
    \ [] as [Int]) == nil)\nassert(prod_signs(arr: [2, 4, 1, 2, -1, -1, 9]) == 20)\n\
    assert(prod_signs(arr: [-1, 1, -1, 1]) == 4)\nassert(prod_signs(arr: [-1, 1, 1,\
    \ 1]) == -4)\nassert(prod_signs(arr: [-1, 1, 1, 0]) == 0)"
  status: Exception
  stderr: 'tmp2n_e3wdt/tmp2n_e3wdt.swift:34: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b7132a32c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b7132729b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b7132729988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b71327287b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmp2n_e3wdt                        0x00005596ec33d95c <unavailable> + 6492

    5    libc.so.6                          0x00002b7132c1e460 __libc_start_main +
    245

    6    tmp2n_e3wdt                        0x00005596ec33d0c9 <unavailable> + 4297

    '
  stdout: ''
  timestamp: 1659979794
- exit_code: -4
  program: "\n/// You are given an array arr of integers and you need to return\n\
    /// sum of magnitudes of integers multiplied by product of all signs\n/// of each\
    \ number in the array, represented by 1, -1 or 0.\n/// Note: return nil for empty\
    \ arr.\n/// Example:\n/// >>> prod_signs(arr: [1, 2, 2, -4])\n/// 9\n/// >>> prod_signs(arr:\
    \ [0, 1])\n/// 0\n/// >>> prod_signs(arr: [] as [Int])\n/// nil\nfunc prod_signs(arr:\
    \ [Int]) -> Int? {\n    if arr.isEmpty {\n        return nil\n    }\n    var result\
    \ = 1\n    var sum = 0\n    for num in arr {\n        if num == 0 {\n        \
    \    continue\n        }\n        result *= num > 0 ? 1 : -1\n        sum += abs(num)\n\
    \    }\n    return result * sum\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int,\
    \ Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n\
    \    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n          \
    \  return false\n        }\n    }\n    return true\n}\n            \nassert(prod_signs(arr:\
    \ [1, 2, 2, -4]) == -9)\nassert(prod_signs(arr: [0, 1]) == 0)\nassert(prod_signs(arr:\
    \ [1, 1, 1, 2, 3, -1, 1]) == -10)\nassert(prod_signs(arr: [] as [Int]) == nil)\n\
    assert(prod_signs(arr: [2, 4, 1, 2, -1, -1, 9]) == 20)\nassert(prod_signs(arr:\
    \ [-1, 1, -1, 1]) == 4)\nassert(prod_signs(arr: [-1, 1, 1, 1]) == -4)\nassert(prod_signs(arr:\
    \ [-1, 1, 1, 0]) == 0)"
  status: Exception
  stderr: 'tmp1sz2pgno/tmp1sz2pgno.swift:43: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b350d5acc80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b350d2a3b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b350d2a3988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b350d2a27b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmp1sz2pgno                        0x0000558ce415f815 <unavailable> + 6165

    5    libc.so.6                          0x00002b350d798460 __libc_start_main +
    245

    6    tmp1sz2pgno                        0x0000558ce415f219 <unavailable> + 4633

    '
  stdout: ''
  timestamp: 1659979794
- exit_code: -4
  program: "\n/// You are given an array arr of integers and you need to return\n\
    /// sum of magnitudes of integers multiplied by product of all signs\n/// of each\
    \ number in the array, represented by 1, -1 or 0.\n/// Note: return nil for empty\
    \ arr.\n/// Example:\n/// >>> prod_signs(arr: [1, 2, 2, -4])\n/// 9\n/// >>> prod_signs(arr:\
    \ [0, 1])\n/// 0\n/// >>> prod_signs(arr: [] as [Int])\n/// nil\nfunc prod_signs(arr:\
    \ [Int]) -> Int? {\n    guard arr.count > 0 else { return nil }\n    var sum =\
    \ 0\n    var product = 1\n    for num in arr {\n        sum += abs(num)\n    \
    \    product *= num == 0 ? 1 : num / abs(num)\n    }\n    return sum * product\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(prod_signs(arr: [1, 2, 2, -4]) == -9)\nassert(prod_signs(arr:\
    \ [0, 1]) == 0)\nassert(prod_signs(arr: [1, 1, 1, 2, 3, -1, 1]) == -10)\nassert(prod_signs(arr:\
    \ [] as [Int]) == nil)\nassert(prod_signs(arr: [2, 4, 1, 2, -1, -1, 9]) == 20)\n\
    assert(prod_signs(arr: [-1, 1, -1, 1]) == 4)\nassert(prod_signs(arr: [-1, 1, 1,\
    \ 1]) == -4)\nassert(prod_signs(arr: [-1, 1, 1, 0]) == 0)"
  status: Exception
  stderr: 'tmps1n60pdd/tmps1n60pdd.swift:38: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002abc2d486c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002abc2d17db6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002abc2d17d988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002abc2d17c7b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmps1n60pdd                        0x000055d6e94f98a5 <unavailable> + 6309

    5    libc.so.6                          0x00002abc2d672460 __libc_start_main +
    245

    6    tmps1n60pdd                        0x000055d6e94f92a9 <unavailable> + 4777

    '
  stdout: ''
  timestamp: 1659979794
- exit_code: 1
  program: "\n/// You are given an array arr of integers and you need to return\n\
    /// sum of magnitudes of integers multiplied by product of all signs\n/// of each\
    \ number in the array, represented by 1, -1 or 0.\n/// Note: return nil for empty\
    \ arr.\n/// Example:\n/// >>> prod_signs(arr: [1, 2, 2, -4])\n/// 9\n/// >>> prod_signs(arr:\
    \ [0, 1])\n/// 0\n/// >>> prod_signs(arr: [] as [Int])\n/// nil\nfunc prod_signs(arr:\
    \ [Int]) -> Int? {\n    guard arr.count > 0 else { return nil }\n    var prod\
    \ = 1\n    var sum = 0\n    for n in arr {\n        if n == 0 { continue }\n \
    \       prod *= n.signum()\n        sum += n.magnitude\n    }\n    return prod\
    \ * sum\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n \
    \   if left.count != right.count {\n        return false\n    }\n    for (l, r)\
    \ in zip(left, right) {\n        if l != r {\n            return false\n     \
    \   }\n    }\n    return true\n}\n            \nassert(prod_signs(arr: [1, 2,\
    \ 2, -4]) == -9)\nassert(prod_signs(arr: [0, 1]) == 0)\nassert(prod_signs(arr:\
    \ [1, 1, 1, 2, 3, -1, 1]) == -10)\nassert(prod_signs(arr: [] as [Int]) == nil)\n\
    assert(prod_signs(arr: [2, 4, 1, 2, -1, -1, 9]) == 20)\nassert(prod_signs(arr:\
    \ [-1, 1, -1, 1]) == 4)\nassert(prod_signs(arr: [-1, 1, 1, 1]) == -4)\nassert(prod_signs(arr:\
    \ [-1, 1, 1, 0]) == 0)"
  status: SyntaxError
  stderr: "/tmp/tmp322l6knk.swift:20:18: error: cannot convert value of type 'UInt'\
    \ to expected argument type 'Int'\n        sum += n.magnitude\n              \
    \   ^\n               Int(       )\n"
  stdout: ''
  timestamp: 1659979794
- exit_code: 0
  program: "\n/// You are given an array arr of integers and you need to return\n\
    /// sum of magnitudes of integers multiplied by product of all signs\n/// of each\
    \ number in the array, represented by 1, -1 or 0.\n/// Note: return nil for empty\
    \ arr.\n/// Example:\n/// >>> prod_signs(arr: [1, 2, 2, -4])\n/// 9\n/// >>> prod_signs(arr:\
    \ [0, 1])\n/// 0\n/// >>> prod_signs(arr: [] as [Int])\n/// nil\nfunc prod_signs(arr:\
    \ [Int]) -> Int? {\n    guard arr.count > 0 else {\n        return nil\n    }\n\
    \    let signs = arr.map {\n        if $0 == 0 {\n            return 0\n     \
    \   } else if $0 > 0 {\n            return 1\n        } else {\n            return\
    \ -1\n        }\n    }\n    let signProd = signs.reduce(1, *)\n    let magnitudes\
    \ = arr.map { abs($0) }\n    let magnitudeSum = magnitudes.reduce(0, +)\n    return\
    \ signProd * magnitudeSum\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(prod_signs(arr:\
    \ [1, 2, 2, -4]) == -9)\nassert(prod_signs(arr: [0, 1]) == 0)\nassert(prod_signs(arr:\
    \ [1, 1, 1, 2, 3, -1, 1]) == -10)\nassert(prod_signs(arr: [] as [Int]) == nil)\n\
    assert(prod_signs(arr: [2, 4, 1, 2, -1, -1, 9]) == 20)\nassert(prod_signs(arr:\
    \ [-1, 1, -1, 1]) == 4)\nassert(prod_signs(arr: [-1, 1, 1, 1]) == -4)\nassert(prod_signs(arr:\
    \ [-1, 1, 1, 0]) == 0)"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659979794
- exit_code: 0
  program: "\n/// You are given an array arr of integers and you need to return\n\
    /// sum of magnitudes of integers multiplied by product of all signs\n/// of each\
    \ number in the array, represented by 1, -1 or 0.\n/// Note: return nil for empty\
    \ arr.\n/// Example:\n/// >>> prod_signs(arr: [1, 2, 2, -4])\n/// 9\n/// >>> prod_signs(arr:\
    \ [0, 1])\n/// 0\n/// >>> prod_signs(arr: [] as [Int])\n/// nil\nfunc prod_signs(arr:\
    \ [Int]) -> Int? {\n  if arr.isEmpty {\n    return nil\n  }\n  var prod = 1\n\
    \  var sum = 0\n  for n in arr {\n    prod *= (n < 0 ? -1 : n == 0 ? 0 : 1)\n\
    \    sum += abs(n)\n  }\n  return prod * sum\n}\n\n\nfunc ==(left: [(Int, Int)],\
    \ right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n       \
    \ return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r\
    \ {\n            return false\n        }\n    }\n    return true\n}\n        \
    \    \nassert(prod_signs(arr: [1, 2, 2, -4]) == -9)\nassert(prod_signs(arr: [0,\
    \ 1]) == 0)\nassert(prod_signs(arr: [1, 1, 1, 2, 3, -1, 1]) == -10)\nassert(prod_signs(arr:\
    \ [] as [Int]) == nil)\nassert(prod_signs(arr: [2, 4, 1, 2, -1, -1, 9]) == 20)\n\
    assert(prod_signs(arr: [-1, 1, -1, 1]) == 4)\nassert(prod_signs(arr: [-1, 1, 1,\
    \ 1]) == -4)\nassert(prod_signs(arr: [-1, 1, 1, 0]) == 0)"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659979794
- exit_code: -4
  program: "\n/// You are given an array arr of integers and you need to return\n\
    /// sum of magnitudes of integers multiplied by product of all signs\n/// of each\
    \ number in the array, represented by 1, -1 or 0.\n/// Note: return nil for empty\
    \ arr.\n/// Example:\n/// >>> prod_signs(arr: [1, 2, 2, -4])\n/// 9\n/// >>> prod_signs(arr:\
    \ [0, 1])\n/// 0\n/// >>> prod_signs(arr: [] as [Int])\n/// nil\nfunc prod_signs(arr:\
    \ [Int]) -> Int? {\n    guard arr.count > 0 else {\n        return nil\n    }\n\
    \    let signs = arr.map { $0 > 0 ? 1 : ($0 < 0 ? -1 : 0) }\n    let signs_prod\
    \ = signs.reduce(1, *)\n    let abs = arr.map { $0 * $0 }\n    let sum = abs.reduce(0,\
    \ +)\n    return sum * signs_prod\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int,\
    \ Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n\
    \    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n          \
    \  return false\n        }\n    }\n    return true\n}\n            \nassert(prod_signs(arr:\
    \ [1, 2, 2, -4]) == -9)\nassert(prod_signs(arr: [0, 1]) == 0)\nassert(prod_signs(arr:\
    \ [1, 1, 1, 2, 3, -1, 1]) == -10)\nassert(prod_signs(arr: [] as [Int]) == nil)\n\
    assert(prod_signs(arr: [2, 4, 1, 2, -1, -1, 9]) == 20)\nassert(prod_signs(arr:\
    \ [-1, 1, -1, 1]) == 4)\nassert(prod_signs(arr: [-1, 1, 1, 1]) == -4)\nassert(prod_signs(arr:\
    \ [-1, 1, 1, 0]) == 0)"
  status: Exception
  stderr: 'tmpsmdikc9_/tmpsmdikc9_.swift:37: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002aaafb138c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002aaafae2fb6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002aaafae2f988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002aaafae2e7b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpsmdikc9_                        0x0000563060a32559 <unavailable> + 5465

    5    libc.so.6                          0x00002aaafb324460 __libc_start_main +
    245

    6    tmpsmdikc9_                        0x0000563060a320e9 <unavailable> + 4329

    '
  stdout: ''
  timestamp: 1659979794
- exit_code: 1
  program: "\n/// You are given an array arr of integers and you need to return\n\
    /// sum of magnitudes of integers multiplied by product of all signs\n/// of each\
    \ number in the array, represented by 1, -1 or 0.\n/// Note: return nil for empty\
    \ arr.\n/// Example:\n/// >>> prod_signs(arr: [1, 2, 2, -4])\n/// 9\n/// >>> prod_signs(arr:\
    \ [0, 1])\n/// 0\n/// >>> prod_signs(arr: [] as [Int])\n/// nil\nfunc prod_signs(arr:\
    \ [Int]) -> Int? {\n    guard arr.count > 0 else { return nil }\n    let mult\
    \ = arr.map { sign_of(num: $0) }.reduce(1, *)\n    let sum = arr.map { abs($0)\
    \ }.reduce(0, +)\n    return mult * sum\n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(prod_signs(arr: [1, 2, 2, -4]) == -9)\nassert(prod_signs(arr: [0, 1]) ==\
    \ 0)\nassert(prod_signs(arr: [1, 1, 1, 2, 3, -1, 1]) == -10)\nassert(prod_signs(arr:\
    \ [] as [Int]) == nil)\nassert(prod_signs(arr: [2, 4, 1, 2, -1, -1, 9]) == 20)\n\
    assert(prod_signs(arr: [-1, 1, -1, 1]) == 4)\nassert(prod_signs(arr: [-1, 1, 1,\
    \ 1]) == -4)\nassert(prod_signs(arr: [-1, 1, 1, 0]) == 0)"
  status: SyntaxError
  stderr: "/tmp/tmpub15chj8.swift:15:26: error: cannot find 'sign_of' in scope\n \
    \   let mult = arr.map { sign_of(num: $0) }.reduce(1, *)\n                   \
    \      ^~~~~~~\n"
  stdout: ''
  timestamp: 1659979794
- exit_code: -4
  program: "\n/// You are given an array arr of integers and you need to return\n\
    /// sum of magnitudes of integers multiplied by product of all signs\n/// of each\
    \ number in the array, represented by 1, -1 or 0.\n/// Note: return nil for empty\
    \ arr.\n/// Example:\n/// >>> prod_signs(arr: [1, 2, 2, -4])\n/// 9\n/// >>> prod_signs(arr:\
    \ [0, 1])\n/// 0\n/// >>> prod_signs(arr: [] as [Int])\n/// nil\nfunc prod_signs(arr:\
    \ [Int]) -> Int? {\n    if arr.isEmpty {\n        return nil\n    } else {\n \
    \       let prod = arr.map { abs($0) }.reduce(1, *)\n        let sum = arr.reduce(0)\
    \ { $0 + ($1 > 0 ? 1 : $1 < 0 ? -1 : 0) }\n        return prod * sum\n    }\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(prod_signs(arr: [1, 2, 2, -4]) == -9)\nassert(prod_signs(arr:\
    \ [0, 1]) == 0)\nassert(prod_signs(arr: [1, 1, 1, 2, 3, -1, 1]) == -10)\nassert(prod_signs(arr:\
    \ [] as [Int]) == nil)\nassert(prod_signs(arr: [2, 4, 1, 2, -1, -1, 9]) == 20)\n\
    assert(prod_signs(arr: [-1, 1, -1, 1]) == 4)\nassert(prod_signs(arr: [-1, 1, 1,\
    \ 1]) == -4)\nassert(prod_signs(arr: [-1, 1, 1, 0]) == 0)"
  status: Exception
  stderr: 'tmpf6vp25pf/tmpf6vp25pf.swift:36: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002ac4bc8cfc80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002ac4bc5c6b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002ac4bc5c6988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002ac4bc5c57b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpf6vp25pf                        0x00005566265ad639 <unavailable> + 5689

    5    libc.so.6                          0x00002ac4bcabb460 __libc_start_main +
    245

    6    tmpf6vp25pf                        0x00005566265ad1c9 <unavailable> + 4553

    '
  stdout: ''
  timestamp: 1659979794
- exit_code: 0
  program: "\n/// You are given an array arr of integers and you need to return\n\
    /// sum of magnitudes of integers multiplied by product of all signs\n/// of each\
    \ number in the array, represented by 1, -1 or 0.\n/// Note: return nil for empty\
    \ arr.\n/// Example:\n/// >>> prod_signs(arr: [1, 2, 2, -4])\n/// 9\n/// >>> prod_signs(arr:\
    \ [0, 1])\n/// 0\n/// >>> prod_signs(arr: [] as [Int])\n/// nil\nfunc prod_signs(arr:\
    \ [Int]) -> Int? {\n    guard arr.count > 0 else { return nil }\n    var sum =\
    \ 0\n    for num in arr {\n        sum += abs(num) * arr.compactMap { $0 == 0\
    \ ? 0 : $0 / abs($0) }.reduce(1, *)\n    }\n    return sum\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(prod_signs(arr: [1, 2, 2, -4]) == -9)\nassert(prod_signs(arr:\
    \ [0, 1]) == 0)\nassert(prod_signs(arr: [1, 1, 1, 2, 3, -1, 1]) == -10)\nassert(prod_signs(arr:\
    \ [] as [Int]) == nil)\nassert(prod_signs(arr: [2, 4, 1, 2, -1, -1, 9]) == 20)\n\
    assert(prod_signs(arr: [-1, 1, -1, 1]) == 4)\nassert(prod_signs(arr: [-1, 1, 1,\
    \ 1]) == -4)\nassert(prod_signs(arr: [-1, 1, 1, 0]) == 0)"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659979794
- exit_code: 1
  program: "\n/// You are given an array arr of integers and you need to return\n\
    /// sum of magnitudes of integers multiplied by product of all signs\n/// of each\
    \ number in the array, represented by 1, -1 or 0.\n/// Note: return nil for empty\
    \ arr.\n/// Example:\n/// >>> prod_signs(arr: [1, 2, 2, -4])\n/// 9\n/// >>> prod_signs(arr:\
    \ [0, 1])\n/// 0\n/// >>> prod_signs(arr: [] as [Int])\n/// nil\nfunc prod_signs(arr:\
    \ [Int]) -> Int? {\n    if arr.isEmpty {\n        return nil\n    }\n    let prod\
    \ = arr.reduce(1) { $0 * sign(n: $1) }\n    return arr.reduce(0) { $0 + abs($1)\
    \ } * prod\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n\
    \    if left.count != right.count {\n        return false\n    }\n    for (l,\
    \ r) in zip(left, right) {\n        if l != r {\n            return false\n  \
    \      }\n    }\n    return true\n}\n            \nassert(prod_signs(arr: [1,\
    \ 2, 2, -4]) == -9)\nassert(prod_signs(arr: [0, 1]) == 0)\nassert(prod_signs(arr:\
    \ [1, 1, 1, 2, 3, -1, 1]) == -10)\nassert(prod_signs(arr: [] as [Int]) == nil)\n\
    assert(prod_signs(arr: [2, 4, 1, 2, -1, -1, 9]) == 20)\nassert(prod_signs(arr:\
    \ [-1, 1, -1, 1]) == 4)\nassert(prod_signs(arr: [-1, 1, 1, 1]) == -4)\nassert(prod_signs(arr:\
    \ [-1, 1, 1, 0]) == 0)"
  status: SyntaxError
  stderr: "/tmp/tmpgvz3sw45.swift:17:37: error: cannot find 'sign' in scope\n    let\
    \ prod = arr.reduce(1) { $0 * sign(n: $1) }\n                                \
    \    ^~~~\n"
  stdout: ''
  timestamp: 1659979794
- exit_code: 0
  program: "\n/// You are given an array arr of integers and you need to return\n\
    /// sum of magnitudes of integers multiplied by product of all signs\n/// of each\
    \ number in the array, represented by 1, -1 or 0.\n/// Note: return nil for empty\
    \ arr.\n/// Example:\n/// >>> prod_signs(arr: [1, 2, 2, -4])\n/// 9\n/// >>> prod_signs(arr:\
    \ [0, 1])\n/// 0\n/// >>> prod_signs(arr: [] as [Int])\n/// nil\nfunc prod_signs(arr:\
    \ [Int]) -> Int? {\n    guard arr.count > 0 else { return nil }\n    let signs\
    \ = arr.map({ $0 == 0 ? 0 : $0 > 0 ? 1 : -1 })\n    let mult = signs.reduce(1,\
    \ *)\n    let res = arr.map({ $0 < 0 ? $0 * -1 : $0 }).reduce(0, +)\n    return\
    \ res * mult\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool\
    \ {\n    if left.count != right.count {\n        return false\n    }\n    for\
    \ (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(prod_signs(arr: [1,\
    \ 2, 2, -4]) == -9)\nassert(prod_signs(arr: [0, 1]) == 0)\nassert(prod_signs(arr:\
    \ [1, 1, 1, 2, 3, -1, 1]) == -10)\nassert(prod_signs(arr: [] as [Int]) == nil)\n\
    assert(prod_signs(arr: [2, 4, 1, 2, -1, -1, 9]) == 20)\nassert(prod_signs(arr:\
    \ [-1, 1, -1, 1]) == 4)\nassert(prod_signs(arr: [-1, 1, 1, 1]) == -4)\nassert(prod_signs(arr:\
    \ [-1, 1, 1, 0]) == 0)"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659979794
- exit_code: 0
  program: "\n/// You are given an array arr of integers and you need to return\n\
    /// sum of magnitudes of integers multiplied by product of all signs\n/// of each\
    \ number in the array, represented by 1, -1 or 0.\n/// Note: return nil for empty\
    \ arr.\n/// Example:\n/// >>> prod_signs(arr: [1, 2, 2, -4])\n/// 9\n/// >>> prod_signs(arr:\
    \ [0, 1])\n/// 0\n/// >>> prod_signs(arr: [] as [Int])\n/// nil\nfunc prod_signs(arr:\
    \ [Int]) -> Int? {\n    if arr.isEmpty {\n        return nil\n    }\n    var total\
    \ = 0\n    var product = 1\n    for i in arr {\n        if i > 0 {\n         \
    \   total += i\n            product *= 1\n        } else if i < 0 {\n        \
    \    total += abs(i)\n            product *= -1\n        } else {\n          \
    \  product *= 0\n        }\n    }\n    return total * product\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(prod_signs(arr: [1, 2, 2, -4]) == -9)\nassert(prod_signs(arr:\
    \ [0, 1]) == 0)\nassert(prod_signs(arr: [1, 1, 1, 2, 3, -1, 1]) == -10)\nassert(prod_signs(arr:\
    \ [] as [Int]) == nil)\nassert(prod_signs(arr: [2, 4, 1, 2, -1, -1, 9]) == 20)\n\
    assert(prod_signs(arr: [-1, 1, -1, 1]) == 4)\nassert(prod_signs(arr: [-1, 1, 1,\
    \ 1]) == -4)\nassert(prod_signs(arr: [-1, 1, 1, 0]) == 0)"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659979794
- exit_code: 1
  program: "\n/// You are given an array arr of integers and you need to return\n\
    /// sum of magnitudes of integers multiplied by product of all signs\n/// of each\
    \ number in the array, represented by 1, -1 or 0.\n/// Note: return nil for empty\
    \ arr.\n/// Example:\n/// >>> prod_signs(arr: [1, 2, 2, -4])\n/// 9\n/// >>> prod_signs(arr:\
    \ [0, 1])\n/// 0\n/// >>> prod_signs(arr: [] as [Int])\n/// nil\nfunc prod_signs(arr:\
    \ [Int]) -> Int? {\n    if arr.isEmpty {\n        return nil\n    }\n    let signs:\
    \ [Int] = arr.map({ Int(pow(Double($0.signum()), 2.0)) })\n    let magnitudes:\
    \ [Int] = arr.map({ abs($0) })\n    return magnitudes.reduce(1, *) * signs.reduce(1,\
    \ *)\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if\
    \ left.count != right.count {\n        return false\n    }\n    for (l, r) in\
    \ zip(left, right) {\n        if l != r {\n            return false\n        }\n\
    \    }\n    return true\n}\n            \nassert(prod_signs(arr: [1, 2, 2, -4])\
    \ == -9)\nassert(prod_signs(arr: [0, 1]) == 0)\nassert(prod_signs(arr: [1, 1,\
    \ 1, 2, 3, -1, 1]) == -10)\nassert(prod_signs(arr: [] as [Int]) == nil)\nassert(prod_signs(arr:\
    \ [2, 4, 1, 2, -1, -1, 9]) == 20)\nassert(prod_signs(arr: [-1, 1, -1, 1]) == 4)\n\
    assert(prod_signs(arr: [-1, 1, 1, 1]) == -4)\nassert(prod_signs(arr: [-1, 1, 1,\
    \ 0]) == 0)"
  status: SyntaxError
  stderr: "/tmp/tmpzppg1aa8.swift:17:38: error: cannot find 'pow' in scope\n    let\
    \ signs: [Int] = arr.map({ Int(pow(Double($0.signum()), 2.0)) })\n           \
    \                          ^~~\n"
  stdout: ''
  timestamp: 1659979794
- exit_code: 1
  program: "\n/// You are given an array arr of integers and you need to return\n\
    /// sum of magnitudes of integers multiplied by product of all signs\n/// of each\
    \ number in the array, represented by 1, -1 or 0.\n/// Note: return nil for empty\
    \ arr.\n/// Example:\n/// >>> prod_signs(arr: [1, 2, 2, -4])\n/// 9\n/// >>> prod_signs(arr:\
    \ [0, 1])\n/// 0\n/// >>> prod_signs(arr: [] as [Int])\n/// nil\nfunc prod_signs(arr:\
    \ [Int]) -> Int? {\n    if arr.isEmpty {\n        return nil\n    }\n    let signs\
    \ = arr.map { (number) -> Int in\n        if number == 0 {\n            return\
    \ 0\n        } else if number > 0 {\n            return 1\n        } else {\n\
    \            return -1\n        }\n    }\n    let product = signs.reduce(1, *)\n\
    \    let magnitudes = arr.map { (number) -> Int in\n        return number.magnitude\n\
    \    }\n    let sum = magnitudes.reduce(0, +)\n    return sum * product\n}\n\n\
    \nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(prod_signs(arr: [1, 2, 2, -4]) == -9)\nassert(prod_signs(arr:\
    \ [0, 1]) == 0)\nassert(prod_signs(arr: [1, 1, 1, 2, 3, -1, 1]) == -10)\nassert(prod_signs(arr:\
    \ [] as [Int]) == nil)\nassert(prod_signs(arr: [2, 4, 1, 2, -1, -1, 9]) == 20)\n\
    assert(prod_signs(arr: [-1, 1, -1, 1]) == 4)\nassert(prod_signs(arr: [-1, 1, 1,\
    \ 1]) == -4)\nassert(prod_signs(arr: [-1, 1, 1, 0]) == 0)"
  status: SyntaxError
  stderr: "/tmp/tmplihjfc_a.swift:27:44: error: declared closure result 'Int' is incompatible\
    \ with return type 'UInt'\n    let magnitudes = arr.map { (number) -> Int in\n\
    \                                           ^~~\n                            \
    \               UInt\n"
  stdout: ''
  timestamp: 1659979794
- exit_code: -4
  program: "\n/// You are given an array arr of integers and you need to return\n\
    /// sum of magnitudes of integers multiplied by product of all signs\n/// of each\
    \ number in the array, represented by 1, -1 or 0.\n/// Note: return nil for empty\
    \ arr.\n/// Example:\n/// >>> prod_signs(arr: [1, 2, 2, -4])\n/// 9\n/// >>> prod_signs(arr:\
    \ [0, 1])\n/// 0\n/// >>> prod_signs(arr: [] as [Int])\n/// nil\nfunc prod_signs(arr:\
    \ [Int]) -> Int? {\n    if arr.isEmpty {\n        return nil\n    }\n    let signs\
    \ = arr.map { $0 >= 0 ? 1 : -1 }\n    let prod = signs.reduce(1, *)\n    let sum\
    \ = arr.reduce(0) { $0 + abs($1) }\n    return prod * sum\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(prod_signs(arr: [1, 2, 2, -4]) == -9)\nassert(prod_signs(arr:\
    \ [0, 1]) == 0)\nassert(prod_signs(arr: [1, 1, 1, 2, 3, -1, 1]) == -10)\nassert(prod_signs(arr:\
    \ [] as [Int]) == nil)\nassert(prod_signs(arr: [2, 4, 1, 2, -1, -1, 9]) == 20)\n\
    assert(prod_signs(arr: [-1, 1, -1, 1]) == 4)\nassert(prod_signs(arr: [-1, 1, 1,\
    \ 1]) == -4)\nassert(prod_signs(arr: [-1, 1, 1, 0]) == 0)"
  status: Exception
  stderr: 'tmp6mvumlrd/tmp6mvumlrd.swift:37: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b71e0d3fc80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b71e0a36b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b71e0a36988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b71e0a357b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmp6mvumlrd                        0x000055d1113d07c5 <unavailable> + 6085

    5    libc.so.6                          0x00002b71e0f2b460 __libc_start_main +
    245

    6    tmp6mvumlrd                        0x000055d1113d01c9 <unavailable> + 4553

    '
  stdout: ''
  timestamp: 1659979794
- exit_code: -4
  program: "\n/// You are given an array arr of integers and you need to return\n\
    /// sum of magnitudes of integers multiplied by product of all signs\n/// of each\
    \ number in the array, represented by 1, -1 or 0.\n/// Note: return nil for empty\
    \ arr.\n/// Example:\n/// >>> prod_signs(arr: [1, 2, 2, -4])\n/// 9\n/// >>> prod_signs(arr:\
    \ [0, 1])\n/// 0\n/// >>> prod_signs(arr: [] as [Int])\n/// nil\nfunc prod_signs(arr:\
    \ [Int]) -> Int? {\n    var product = 0\n    var sum = 0\n    for value in arr\
    \ {\n        sum += abs(value)\n        product += value.signum()\n    }\n   \
    \ if arr.isEmpty {\n        return nil\n    }\n    return sum * product\n}\n\n\
    \nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(prod_signs(arr: [1, 2, 2, -4]) == -9)\nassert(prod_signs(arr:\
    \ [0, 1]) == 0)\nassert(prod_signs(arr: [1, 1, 1, 2, 3, -1, 1]) == -10)\nassert(prod_signs(arr:\
    \ [] as [Int]) == nil)\nassert(prod_signs(arr: [2, 4, 1, 2, -1, -1, 9]) == 20)\n\
    assert(prod_signs(arr: [-1, 1, -1, 1]) == 4)\nassert(prod_signs(arr: [-1, 1, 1,\
    \ 1]) == -4)\nassert(prod_signs(arr: [-1, 1, 1, 0]) == 0)"
  status: Exception
  stderr: 'tmpkm2gufdg/tmpkm2gufdg.swift:39: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002aeac4ee3c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002aeac4bdab6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002aeac4bda988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002aeac4bd97b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpkm2gufdg                        0x0000563079e696d9 <unavailable> + 5849

    5    libc.so.6                          0x00002aeac50cf460 __libc_start_main +
    245

    6    tmpkm2gufdg                        0x0000563079e69269 <unavailable> + 4713

    '
  stdout: ''
  timestamp: 1659979794
- exit_code: 1
  program: "\n/// You are given an array arr of integers and you need to return\n\
    /// sum of magnitudes of integers multiplied by product of all signs\n/// of each\
    \ number in the array, represented by 1, -1 or 0.\n/// Note: return nil for empty\
    \ arr.\n/// Example:\n/// >>> prod_signs(arr: [1, 2, 2, -4])\n/// 9\n/// >>> prod_signs(arr:\
    \ [0, 1])\n/// 0\n/// >>> prod_signs(arr: [] as [Int])\n/// nil\nfunc prod_signs(arr:\
    \ [Int]) -> Int? {\n    guard arr.count > 0 else {\n        return nil\n    }\n\
    \    var signProd = 1\n    var sumMagnitudes = 0\n    for num in arr {\n     \
    \   let sign = sgn(num)\n        signProd *= sign\n        sumMagnitudes += abs(num)\n\
    \    }\n    return signProd * sumMagnitudes\n}\n\n\nfunc ==(left: [(Int, Int)],\
    \ right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n       \
    \ return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r\
    \ {\n            return false\n        }\n    }\n    return true\n}\n        \
    \    \nassert(prod_signs(arr: [1, 2, 2, -4]) == -9)\nassert(prod_signs(arr: [0,\
    \ 1]) == 0)\nassert(prod_signs(arr: [1, 1, 1, 2, 3, -1, 1]) == -10)\nassert(prod_signs(arr:\
    \ [] as [Int]) == nil)\nassert(prod_signs(arr: [2, 4, 1, 2, -1, -1, 9]) == 20)\n\
    assert(prod_signs(arr: [-1, 1, -1, 1]) == 4)\nassert(prod_signs(arr: [-1, 1, 1,\
    \ 1]) == -4)\nassert(prod_signs(arr: [-1, 1, 1, 0]) == 0)"
  status: SyntaxError
  stderr: "/tmp/tmpeq22thlj.swift:20:20: error: cannot find 'sgn' in scope\n     \
    \   let sign = sgn(num)\n                   ^~~\n"
  stdout: ''
  timestamp: 1659979794
