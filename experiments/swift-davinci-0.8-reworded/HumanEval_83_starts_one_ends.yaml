name: HumanEval_83_starts_one_ends
language: swift
prompt: "\n/// Given a positive integer n, return the count of the numbers of n-digit\n\
  /// positive integers that start or end with 1.\nfunc starts_one_ends(n: Int) ->\
  \ Int {\n"
tests: "}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if\
  \ left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left,\
  \ right) {\n        if l != r {\n            return false\n        }\n    }\n  \
  \  return true\n}\n            \nassert(starts_one_ends(n: 1) == 1)\nassert(starts_one_ends(n:\
  \ 2) == 18)\nassert(starts_one_ends(n: 3) == 180)\nassert(starts_one_ends(n: 4)\
  \ == 1800)\nassert(starts_one_ends(n: 5) == 18000)"
completions: ['  return Int(Math.pow(10, Double(n - 1))) - 1', "    guard n >= 1 else\
    \ { return 0 }\n    guard n > 1 else { return 10 }\n\n    var result = 10\n  \
    \  var digits = [Int](count: n, repeatedValue: 0)\n    fill(digits, start: 1,\
    \ result: &result)\n    return result", "    let dp = Array(count: n + 1, repeatedValue:\
    \ Array(count: 2, repeatedValue: 0))\n    dp[1][0] = dp[1][1] = 1\n    for i in\
    \ 2...n {\n        dp[i][0] = dp[i - 1][0] + dp[i - 1][1]\n        dp[i][1] =\
    \ dp[i - 1][0]\n    }\n    return dp[n][0] + dp[n][1]", "    if n <= 0 {\n   \
    \     return 0\n    }\n    let dp = Array(count: n + 1, repeatedValue: 0)\n  \
    \  dp[1] = 1\n    for i in 2...n {\n        dp[i] = dp[i - 1] * 9 + 10.pow(i -\
    \ 1)\n    }\n    return dp[n]", '    return 1 + starts_one_ends_aux(n: n)', " \
    \   if n == 1 {\n        return 1\n    }\n    let result = starts_one_ends(n -\
    \ 1)\n    return result * 9 + 1", "    var count = 0\n    for i in 0..<n {\n \
    \       count += 11.to_the(i)\n    }\n    return count", "    let prefix: [[Int]]\
    \ = [\n        [1, 2, 3, 4, 5, 6, 7, 8, 9],\n        [10, 11, 12, 13, 14, 15,\
    \ 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26, 27, 28, 29, 30, 31, 32, 33, 34,\
    \ 35, 36, 37, 38, 39, 40, 41, 42, 43, 44, 45, 46, 47, 48, 49, 50, 51, 52, 53,\
    \ 54, 55, 56, 57, 58, 59, 60, 61, 62, 63, 64, 65, 66, 67, 68, 69, 70, 71, 72,\
    \ 73, 74, 75, 76, 77, 78, 79, 80, 81, 82, 83, 84, 85, 86, 87, 88, 89, 90, 91,\
    \ 92, 93, 94, 95, 96, 97, 98, 99],\n        [100, 101, 110, 111, 200, 201, 210,\
    \ 211, 300, 301, 310, 311, 400, 401, 410, 411, 500, 501, 510, 511, 600, 601, 610,\
    \ 611, 700, 701, 710, 711, 800, 801, 810, 811, 900, 901, 910, 911]\n    ]\n  \
    \  let suffix: [[Int]] = [\n        [1, 10, 100, 1000, 10000, 100000, 1000000,\
    \ 10000000, 100000000, 1000000000],\n        [1, 1, 2, 2, 3, 3, 4, 4, 5, 5, 6,\
    \ 6, 7, 7, 8, 8, 9, 9, 10, 10, 11, 11, 12, 12, 13, 13, 14, 14, 15, 15, 16, 16,\
    \ 17, 17, 18, 18, 19, 19, 20, 20, 21, 21, 22, 22, 23, 23, 24, 24, 25, 25, 26,\
    \ 26, 27, 27, 28, 28, 29, 29, 30, 30, 31, 31, 32, 32, 33, 33, 34, 34, 35, 35,\
    \ 36, 36, 37, 37, 38, 38, 39, 39, 40, 40, 41, 41, 42, 42, 43,", "    let x: Int\
    \ = pow(2, n - 1)\n    return x * (x - 1)", "  let dp = Array(count: n+1, repeatedValue:\
    \ Array(count: 2, repeatedValue: 0))\n  dp[1][0] = 1\n  dp[1][1] = 1\n  for var\
    \ i = 2; i <= n; i++ {\n    dp[i][0] = 10 * dp[i-1][0] + (1 - pow(10, -i+1))\n\
    \    dp[i][1] = 10 * dp[i-1][1] + pow(10, -i+1)\n  }\n  return dp[n][0] + dp[n][1]",
  "  var result = 0\n  var current = 1\n  for i in 0..<n {\n    result += current\n\
    \    current *= 10\n  }\n  return result", "    var count = 0\n    for i in 1..<n\
    \ {\n        count += pow(2, i - 1)\n    }\n    return count * 9 + 1", "    //\
    \ If 1 is the first digit, then there can be `(n-1)` digits after the first\n\
    \    // digit. Each of those can be [0, 9], so there are `(n-1) * 10^(n-1)`\n\
    \    // possible numbers.\n    // If 1 is the last digit, then there can be `(n-1)`\
    \ digits before the last\n    // digit. Each of those can be [0, 9], so there\
    \ are `(n-1) * 10^(n-1)`\n    // possible numbers.\n    return 2 * (n-1) * pow(10,\
    \ n-1)", "    precondition(n > 0)\n    return n * 9 * Int(pow(10.0, Double(n -\
    \ 1)))", "    if n == 1 {\n        return 2\n    }\n    if n == 2 {\n        return\
    \ 3\n    }\n    var answer = 1 // one digit ends with one.\n    var s = 0\n  \
    \  for _ in 0..<n-1 {\n        s += (9 * answer)\n        answer = s\n    }\n\
    \    return s + 1", "  var a = [1, 1, 1]\n  for i in 3...n {\n    a[i % 3] = a[(i\
    \ - 1) % 3] + a[(i - 2) % 3]\n  }\n  return a[n % 3]", '    return 10*count_digit_no_zero(n:
    n-1)', "    if n == 1 {\n        return 1\n    }\n    return 9 * ndigit_integers(n:\
    \ n - 1)", '    return num_digits(n-1) + num_digits(n-2)', "    var nums = 1\n\
    \    var numbers = [Int]()\n    var digits = [Int]()\n    while (nums < pow(10,\
    \ Double(n))) {\n        digits = digitize(nums)\n        if (digits[0] == 1 ||\
    \ digits[digits.count - 1] == 1) {\n            numbers.append(nums)\n       \
    \ }\n        nums++\n    }\n    return numbers.count"]
stop_tokens:
- "\n}"
