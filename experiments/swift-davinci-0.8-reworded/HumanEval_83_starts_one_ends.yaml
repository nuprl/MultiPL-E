name: HumanEval_83_starts_one_ends
language: swift
prompt: "\n/// Given a positive integer n, return the count of the numbers of n-digit\n\
  /// positive integers that start or end with 1.\nfunc starts_one_ends(n: Int) ->\
  \ Int {\n"
tests: "}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if\
  \ left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left,\
  \ right) {\n        if l != r {\n            return false\n        }\n    }\n  \
  \  return true\n}\n            \nassert(starts_one_ends(n: 1) == 1)\nassert(starts_one_ends(n:\
  \ 2) == 18)\nassert(starts_one_ends(n: 3) == 180)\nassert(starts_one_ends(n: 4)\
  \ == 1800)\nassert(starts_one_ends(n: 5) == 18000)"
completions: ['  return Int(Math.pow(10, Double(n - 1))) - 1', "    guard n >= 1 else\
    \ { return 0 }\n    guard n > 1 else { return 10 }\n\n    var result = 10\n  \
    \  var digits = [Int](count: n, repeatedValue: 0)\n    fill(digits, start: 1,\
    \ result: &result)\n    return result", "    let dp = Array(count: n + 1, repeatedValue:\
    \ Array(count: 2, repeatedValue: 0))\n    dp[1][0] = dp[1][1] = 1\n    for i in\
    \ 2...n {\n        dp[i][0] = dp[i - 1][0] + dp[i - 1][1]\n        dp[i][1] =\
    \ dp[i - 1][0]\n    }\n    return dp[n][0] + dp[n][1]", "    if n <= 0 {\n   \
    \     return 0\n    }\n    let dp = Array(count: n + 1, repeatedValue: 0)\n  \
    \  dp[1] = 1\n    for i in 2...n {\n        dp[i] = dp[i - 1] * 9 + 10.pow(i -\
    \ 1)\n    }\n    return dp[n]", '    return 1 + starts_one_ends_aux(n: n)', " \
    \   if n == 1 {\n        return 1\n    }\n    let result = starts_one_ends(n -\
    \ 1)\n    return result * 9 + 1", "    var count = 0\n    for i in 0..<n {\n \
    \       count += 11.to_the(i)\n    }\n    return count", "    let prefix: [[Int]]\
    \ = [\n        [1, 2, 3, 4, 5, 6, 7, 8, 9],\n        [10, 11, 12, 13, 14, 15,\
    \ 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26, 27, 28, 29, 30, 31, 32, 33, 34,\
    \ 35, 36, 37, 38, 39, 40, 41, 42, 43, 44, 45, 46, 47, 48, 49, 50, 51, 52, 53,\
    \ 54, 55, 56, 57, 58, 59, 60, 61, 62, 63, 64, 65, 66, 67, 68, 69, 70, 71, 72,\
    \ 73, 74, 75, 76, 77, 78, 79, 80, 81, 82, 83, 84, 85, 86, 87, 88, 89, 90, 91,\
    \ 92, 93, 94, 95, 96, 97, 98, 99],\n        [100, 101, 110, 111, 200, 201, 210,\
    \ 211, 300, 301, 310, 311, 400, 401, 410, 411, 500, 501, 510, 511, 600, 601, 610,\
    \ 611, 700, 701, 710, 711, 800, 801, 810, 811, 900, 901, 910, 911]\n    ]\n  \
    \  let suffix: [[Int]] = [\n        [1, 10, 100, 1000, 10000, 100000, 1000000,\
    \ 10000000, 100000000, 1000000000],\n        [1, 1, 2, 2, 3, 3, 4, 4, 5, 5, 6,\
    \ 6, 7, 7, 8, 8, 9, 9, 10, 10, 11, 11, 12, 12, 13, 13, 14, 14, 15, 15, 16, 16,\
    \ 17, 17, 18, 18, 19, 19, 20, 20, 21, 21, 22, 22, 23, 23, 24, 24, 25, 25, 26,\
    \ 26, 27, 27, 28, 28, 29, 29, 30, 30, 31, 31, 32, 32, 33, 33, 34, 34, 35, 35,\
    \ 36, 36, 37, 37, 38, 38, 39, 39, 40, 40, 41, 41, 42, 42, 43,", "    let x: Int\
    \ = pow(2, n - 1)\n    return x * (x - 1)", "  let dp = Array(count: n+1, repeatedValue:\
    \ Array(count: 2, repeatedValue: 0))\n  dp[1][0] = 1\n  dp[1][1] = 1\n  for var\
    \ i = 2; i <= n; i++ {\n    dp[i][0] = 10 * dp[i-1][0] + (1 - pow(10, -i+1))\n\
    \    dp[i][1] = 10 * dp[i-1][1] + pow(10, -i+1)\n  }\n  return dp[n][0] + dp[n][1]",
  "  var result = 0\n  var current = 1\n  for i in 0..<n {\n    result += current\n\
    \    current *= 10\n  }\n  return result", "    var count = 0\n    for i in 1..<n\
    \ {\n        count += pow(2, i - 1)\n    }\n    return count * 9 + 1", "    //\
    \ If 1 is the first digit, then there can be `(n-1)` digits after the first\n\
    \    // digit. Each of those can be [0, 9], so there are `(n-1) * 10^(n-1)`\n\
    \    // possible numbers.\n    // If 1 is the last digit, then there can be `(n-1)`\
    \ digits before the last\n    // digit. Each of those can be [0, 9], so there\
    \ are `(n-1) * 10^(n-1)`\n    // possible numbers.\n    return 2 * (n-1) * pow(10,\
    \ n-1)", "    precondition(n > 0)\n    return n * 9 * Int(pow(10.0, Double(n -\
    \ 1)))", "    if n == 1 {\n        return 2\n    }\n    if n == 2 {\n        return\
    \ 3\n    }\n    var answer = 1 // one digit ends with one.\n    var s = 0\n  \
    \  for _ in 0..<n-1 {\n        s += (9 * answer)\n        answer = s\n    }\n\
    \    return s + 1", "  var a = [1, 1, 1]\n  for i in 3...n {\n    a[i % 3] = a[(i\
    \ - 1) % 3] + a[(i - 2) % 3]\n  }\n  return a[n % 3]", '    return 10*count_digit_no_zero(n:
    n-1)', "    if n == 1 {\n        return 1\n    }\n    return 9 * ndigit_integers(n:\
    \ n - 1)", '    return num_digits(n-1) + num_digits(n-2)', "    var nums = 1\n\
    \    var numbers = [Int]()\n    var digits = [Int]()\n    while (nums < pow(10,\
    \ Double(n))) {\n        digits = digitize(nums)\n        if (digits[0] == 1 ||\
    \ digits[digits.count - 1] == 1) {\n            numbers.append(nums)\n       \
    \ }\n        nums++\n    }\n    return numbers.count", '    return starts_one_ends_dp(n)',
  "    // From the book, this is a dynamic programming problem and we \n    // let\
    \ d(i) be the number of i-digit positive integers that start \n    // or end with\
    \ 1. We then have a recurrence of the form d(i) = d(i - 1) \n    // + d(i - 2).\
    \ We then get an explicit formula as given below.\n    if n == 1 {\n        return\
    \ 2\n    }\n    else if n == 2 {\n        return 4\n    }\n    else {\n      \
    \  return 2 * starts_one_ends(n - 1) - starts_one_ends(n - 3)\n    }", "    var\
    \ result = 1\n    if n > 1 {\n        result += 1\n    }\n    if n > 2 {\n   \
    \     result += 9\n    }\n    if n > 3 {\n        result += 9\n    }\n    return\
    \ result", "    var j = Int(pow(Double(10), Double(n - 1)))\n    var count = 0\n\
    \    while j < Int(pow(Double(10), Double(n))) {\n        if j % 10 == 1 {\n \
    \           count += 1\n        }\n        j += 1\n    }\n    return count", " \
    \   // return zero for one-digit numbers\n    if n == 1 {\n        return 0\n\
    \    }\n    // return the count of all numbers if the number of digits is not\
    \ one\n    return pow(10, n - 1)", "    if n == 1 {\n        return 2\n    } else\
    \ if n == 2 {\n        return 4\n    } else {\n        return starts_one_ends(n-1)\
    \ + starts_one_ends(n-2)\n    }", "    precondition(n > 0)\n    var last_row =\
    \ [1]\n    var current_row = [1]\n    for _ in 1..<n {\n        current_row =\
    \ [1]\n        for i in 1..<last_row.count {\n            current_row.append(last_row[i-1]\
    \ + last_row[i])\n        }\n        current_row.append(1)\n        last_row =\
    \ current_row\n    }\n    return current_row.reduce(0, combine: +)", "    if n\
    \ == 1 {\n        return 1\n    }\n    if n == 2 {\n        return 10\n    }\n\
    \    var res = 10\n    for _ in 1..<n {\n        res *= 9\n    }\n    return res",
  "    if n <= 0 {\n        return 0\n    }\n    if n == 1 {\n        return 1\n \
    \   }\n    if n == 2 {\n        return 9\n    }\n    let ten = Int.ten_power(n\
    \ - 1)\n    return starts_one_ends(n - 1) + 9 * (n - 1) * ten", "    let count\
    \ = Int(pow(Double(10), Double(n-1)))\n    return count * 9 + 1", "    var dp\
    \ = [1, 1]\n    for i in 2...n {\n        var num = 2\n        if i > 2 {\n  \
    \          num = 2 * dp[i - 2]\n        }\n        dp.append(num + 2 * (num -\
    \ dp[i - 1]))\n    }\n    return dp[n]", "    if n == 1 {\n        return 2\n\
    \    }\n    let tens = Int(pow(10, Double(n-1)))\n    let last_digits = starts_one_ends(n-1)\n\
    \    let first_digits = nonzero_digits(n-1)\n    return tens - last_digits + first_digits",
  "    var start_one = 0\n    var end_one = 0\n    var zero_one = 0\n    var one_zero\
    \ = 0\n    if n == 1 {\n        return 2\n    } else if n == 2 {\n        return\
    \ 4\n    } else {\n        start_one = starts_one_ends(n-1)\n        end_one =\
    \ starts_one_ends(n-2)\n        zero_one = start_one + end_one\n        one_zero\
    \ = end_one\n        return zero_one + one_zero\n    }", "    var count = 0\n\
    \    for i in 1..<(n-1) {\n        count += counts_beginning_one(n: i) * counts_ending_one(n:\
    \ n-i)\n    }\n    return count", "    if n == 1 {\n        return 2\n    }\n\
    \    let m = n - 1\n    return 9 * pow(10, m)", "    var result = 0\n    var multiple\
    \ = 1\n    if n > 1 {\n        for i in 1...n-1 {\n            multiple *= 10\n\
    \        }\n        result += multiple\n    }\n    result += 10\n    if n > 2\
    \ {\n        var last_digit = 10\n        for i in 2...n-1 {\n            last_digit\
    \ += multiple\n            result += last_digit * 9\n            multiple /= 10\n\
    \        }\n    }\n    return result", "    let all_num = (Int(pow(Double(10),\
    \ Double(n))) - 1) -\n        Int(pow(Double(10), Double(n - 1))) + 1\n    let\
    \ num_without_ones = Int(pow(Double(9), Double(n))) -\n        Int(pow(Double(9),\
    \ Double(n - 1)))\n    return all_num - num_without_ones", "    if n == 1 {\n\
    \        return 1\n    } else {\n        return starts_one_ends(n - 1) + 9 * Int(pow(Double(10),\
    \ Double(n - 2)))\n    }", "    var first_digit_ends_one: Int\n    if n == 1 {\n\
    \        first_digit_ends_one = 1\n    } else {\n        first_digit_ends_one\
    \ = 9*power(10, n-1)\n    }\n    var last_digit_starts_one: Int\n    if n == 1\
    \ {\n        last_digit_starts_one = 1\n    } else {\n        last_digit_starts_one\
    \ = 9*power(10, n-2)\n    }\n    return first_digit_ends_one + last_digit_starts_one",
  "    let dp = Array<Int>(repeating: 0, count: n + 1)\n    dp[1] = 1\n    for i in\
    \ 2...n {\n        dp[i] = dp[i - 1] * 10 + pow10(i - 1)\n    }\n    return dp[n]",
  "  if n == 1 {\n    return 1\n  }\n  if n == 2 {\n    return 1\n  }\n  return starts_one_ends(n\
    \ - 1) + starts_one_ends(n - 2)", "    assert(n > 0, \"n has to be positive\"\
    )\n    if n == 1 {\n        return 1\n    }\n    if n == 2 {\n        return 2\n\
    \    }\n    var count = 2\n    for i in 2..<n {\n        count += 9 * Int(pow(Double(10),\
    \ Double(i - 1)))\n    }\n    return count", "    var nums = Array(repeating:\
    \ 0, count: n + 1)\n    nums[1] = 1\n    for i in 2...n {\n        nums[i] = nums[i\
    \ - 1] + 10.power(i - 1)\n    }\n    return nums[n]", "  var dp = [Int](count:\
    \ n+1, repeatedValue: 0)\n  dp[1] = 1\n  dp[2] = 2\n  for i in 3...n {\n    dp[i]\
    \ = dp[i-1] + dp[i-2]\n  }\n  return 2*dp[n-1] + dp[n]", "    if n == 1 {\n  \
    \      return 1\n    }\n    return 9 * pow10[n - 1] + starts_one_ends(n - 1)",
  "    var result = 0\n    for i in 1..<n {\n        result += Int(pow(10, Double(i)))\n\
    \    }\n    return result", "    if n == 1 {\n        return 2\n    } else if\
    \ n == 2 {\n        return 4\n    }\n    return starts_one_ends(n - 1) + starts_one_ends(n\
    \ - 2)", "    // Base case: 1 digit\n    if n == 1 {\n        return 2\n    }\n\
    \    // Recursive case: n digits\n    // For a number that starts with 1 and has\
    \ n digits, the remaining digits\n    // can be anything. The number of ways to\
    \ do that is `starts_one_ends(n-1)`.\n    // For a number that ends with 1 and\
    \ has n digits, the first digit can be\n    // anything and the remaining digits\
    \ can be anything except 1.  There are\n    // 9 choices for the first digit and\
    \ `starts_one_ends(n-1) - 1` choices for\n    // the remaining digits.\n    return\
    \ starts_one_ends(n-1) + 9 * (starts_one_ends(n-1) - 1)", "    if n == 1 {\n \
    \       return 2\n    }\n    if n == 2 {\n        return 2 * 3\n    }\n    return\
    \ starts_one_ends(n - 1) + 2 * (n - 1) * starts_one_ends(n - 2)", "    if n ==\
    \ 1 {\n        return 2\n    }\n    if n == 2 {\n        return 4\n    }\n   \
    \ return 2 * starts_one_ends(n-1)", "    if n <= 1 {\n        return 0\n    }\n\
    \    var c = 0\n    for k in 1..<n {\n        c += starts_one_ends(n: k)\n   \
    \ }\n    if n >= 2 {\n        c += 9\n    }\n    return c", "    let s_pow10:\
    \ [Int] = [0, 0, 3, 3, 3, 3, 3, 3, 3, 3]\n    let e_pow10: [Int] = [0, 0, 3, 3,\
    \ 3, 3, 3, 3, 3, 3]\n    let o_pow10: [Int] = [0, 0, 0, 0, 0, 0, 0, 0, 0, 0]\n\
    \    let t_pow10: [Int] = [0, 0, 0, 0, 0, 0, 0, 0, 0, 0]\n    let pow10: [[Int]]\
    \ = [s_pow10, e_pow10, o_pow10, t_pow10]\n    var res = 0\n    for i in 0..<4\
    \ {\n        if pow10[i][n] > 0 {\n            res += pow10[i][n] * (n - 1) *\
    \ pow(10, n - 2)\n        }\n    }\n    return res", "    if n == 1 {\n      \
    \  return 1\n    } else {\n        return 2 * starts_one_ends(n-1) + (9-1)*power(10,\
    \ n-2)\n    }", "    precondition(n > 0)\n    return starts_one_ends(n, true)",
  "    if n == 1 {\n        return 2\n    }\n    var ways = [1, 1]\n    for _ in 1..<n\
    \ {\n        ways = [ways[1], sum(ways)]\n    }\n    return sum(ways)", "    let\
    \ sqrt_n = sqrt(Double(n))\n    var s = n + 1\n    for i in 2..<Int(sqrt_n)+1\
    \ {\n        let j = n / i\n        s += i*j + (n % i > 0 ? 1 : 0)\n    }\n  \
    \  return s", "    precondition(n > 0)\n    return 0", "    if n <= 0 {\n    \
    \    return 0\n    }\n    var previous = 1\n    var current = 1\n    for _ in\
    \ 1 ..< n {\n        let tmp = current\n        current = current + previous\n\
    \        previous = tmp\n    }\n    return 2 * current", "    var count = 0\n\n\
    \    if n == 1 {\n        return 10\n    }\n\n    for d in 1...9 {\n        count\
    \ += all_n_digit_positive_ints(d: d, n: n)\n    }\n\n    return count", "  assert(n\
    \ > 0)\n  // We're going to count up to 2 ^ n - 1.\n  var count = 0\n  var value\
    \ = 0\n  while value < (1 << n) {\n    // See if the ones digit is 1.\n    if\
    \ (value & 1) == 1 {\n      count += 1\n    }\n    // See if the most significant\
    \ digit is 1.\n    if value & (1 << (n - 1)) != 0 {\n      count += 1\n    }\n\
    \    value += 1\n  }\n  return count", "    precondition(n > 0)\n    if n == 1\
    \ {\n        return 2\n    }\n    return 9 * starts_one_ends(n: n - 1)", '    return
    0', "    // See https://en.wikipedia.org/wiki/Harshad_number#Non-trivial_Harshad_numbers.\n\
    \    let power = Int(pow(10.0, Double(n)))\n    let min = Int(pow(10.0, Double(n\
    \ - 1)))\n    var count = 0\n    for i in min..<power {\n        let s = String(i)\n\
    \        if Int(s)! % sum_digits(i) == 0 {\n            if s.hasPrefix(\"1\")\
    \ || s.hasSuffix(\"1\") {\n                count += 1\n            }\n       \
    \ }\n    }\n    return count", "  var count = 0\n  for i in 1..<n {\n    count\
    \ += Int(pow(Double(10), Double(i)))\n  }\n  count *= 2\n  if n > 1 {\n    count\
    \ += 9 * Int(pow(Double(10), Double(n - 1)))\n  }\n  return count", "    if n\
    \ == 1 {\n        return 2\n    }\n    if n == 2 {\n        return 3\n    }\n\
    \    return starts_one_ends(n - 1) + starts_one_ends(n - 2)", "  if n == 1 {\n\
    \    return 1\n  }\n  return (n - 1) * 9", "    // Let F(k) denote the count of\
    \ the numbers of k-digit positive integers\n    // that start or end with 1. Then\
    \ F(1) = 1, F(2) = 2, F(3) = 3, F(4) = 4,\n    // F(5) = 6, F(6) = 8, F(7) = 11,\
    \ F(8) = 16, F(9) = 23, F(10) = 32, ...\n    //\n    // Let's find a recurrence\
    \ relationship.\n    //\n    // F(k) = 10^(k-1) + 9 * F(k-1)\n    // F(k) - 9\
    \ * F(k-1) = 10^(k-1)\n    //\n    // Let's do some simplifications to make this\
    \ more computationally efficient.\n    //\n    // F(k) - 9 * F(k-1) = 10^(k-1)\n\
    \    // (10^(k-1) - 9 * F(k-1)) / 9 = F(k-1)\n    // F(k-1) = (10^(k-1) - 9 *\
    \ F(k-1)) / 9\n    // F(k-1) = (10^(k-1) - 9 * F(k-1)) / 9\n    // F(k-1) = (10^(k-1)\
    \ - 9 * (10^(k-2) - 9 * F(k-2))) / 9\n    // F(k-1) = (10^(k-1) - 10^(k-2) + 9\
    \ * F(k-2)) / 9\n    //\n    // Let's do some more simplifications...\n    //\n\
    \    // F(k-1) = (10^(k-1) - 10^(k-2) + 9 * F(k-2)) / 9\n    // F(k-1) = (10^(k-1)\
    \ - 10^(k-2) + 9 * (10^(k-3) - 9 * F(k-3))) / 9\n    // F(k-1) = (10^(k-1) - 10^(k-2)\
    \ + 10^", "    if n == 1 {\n        return 2\n    }\n    if n == 2 {\n       \
    \ return 4\n    }\n    let base = 9 * pow(10, (n - 2))\n    return base * 2 +\
    \ starts_one_ends(n - 1)", "    // After a lot of thought, the only way I can\
    \ think of to find the\n    // number of starts or ends 1s in the current level\
    \ is to check how\n    // many starts or ends 1s in the previous level.\n    if\
    \ n == 1 {\n        return 2\n    }\n    var prev_level_starts = 1\n    var prev_level_ends\
    \ = 1\n    var curr_level_starts = 2\n    var curr_level_ends = 2\n    for _ in\
    \ 2..<n {\n        let temp = curr_level_starts\n        curr_level_starts = curr_level_starts\
    \ + prev_level_starts\n        prev_level_starts = temp\n        curr_level_ends\
    \ = curr_level_ends + prev_level_ends\n        prev_level_ends = curr_level_ends\n\
    \    }\n    return curr_level_starts + curr_level_ends", "  let digits = n - 1\n\
    \  return (1...digits).reduce(0) { count, d in\n    count + _starts_one_ends(n:\
    \ d)\n  }", "    if n == 1 {\n        return 2\n    } else if n == 2 {\n     \
    \   return 4\n    } else {\n        let exp = pow(10, n - 1)\n        return Int(9\
    \ * exp + exp / 9 * 8)\n    }", '  return solve(n, 0, false, false)', "    if\
    \ n <= 1 {\n        return n\n    }\n    let digits = 10i.pow(n - 1)\n    let\
    \ d = 9 * digits\n    return 2 * d + starts_one_ends(n - 1)", "    var count =\
    \ 0\n    for i in 1..<n {\n        count += count_x(x: i, y: 0)\n    }\n    return\
    \ count", "    // Write your solution here...\n    return 0", "    if n == 1 {\n\
    \        return 1\n    } else {\n        return starts_one_ends(n - 1) + starts_one_ends(n\
    \ - 2)\n    }", '    return 0', "    if n == 1 {\n        return 1\n    } else\
    \ {\n        return (1...9).map({ digits($0) })\n            .reduce(0, combine:\
    \ +) * Int(pow(10, Double(n - 1))) + starts_one_ends(n - 1)\n    }", "    // n\
    \ = 1: 1\n    // n = 2: 11, 91\n    // n = 3: 111, 911, 191, 991\n    // n = 4:\
    \ 1111, 9111, 1191, 9911, 1911, 9901, 1199, 9919, 9191, 9901, 9999\n    // The\
    \ pattern is immediately obvious:\n    // start_one = 9(10^(n-1))\n    // end_one\
    \ = 9(10^(n-1))\n    return 9 * pow(10, n-1) * 2", "    var res = 0\n    var start_from\
    \ = 0\n    var end_to = 0\n    if n == 1 {\n        return 1\n    }\n    if n\
    \ == 2 {\n        return 10\n    }\n    for _ in 0..<n-1 {\n        start_from\
    \ = start_from * 10 + 1\n        end_to = end_to * 10 + 9\n    }\n    var tmp\
    \ = 0\n    for i in start_from...end_to {\n        tmp = i\n        while tmp\
    \ > 0 {\n            if tmp % 10 == 1 {\n                res += 1\n          \
    \  }\n            tmp /= 10\n        }\n    }\n    return res", "    // The problem\
    \ could be transformed to: how many n-digit positive integers\n    // are there\
    \ that end with 1?\n    var count = 0;\n    var a: Int = 1;\n    for _ in 1...n-1\
    \ {\n        a *= 10;\n    }\n    for var i = a; i < a*10; i++ {\n        let\
    \ last = i % 10;\n        if last == 1 {\n            count++;\n        }\n  \
    \  }\n    return count;", "    if n == 1 {\n        return 2\n    }\n    if n\
    \ == 2 {\n        return 3\n    }\n    return starts_one_ends(n - 1) + starts_one_ends(n\
    \ - 2)", "    var table = [Int](count: n + 1, repeatedValue: 0)\n    table[1]\
    \ = 1\n    table[2] = 10\n    table[3] = 100\n    for var i = 4; i <= n; i++ {\n\
    \        table[i] = 10 * table[i - 1] + Int(pow(Double(10), Double(i - 2)))\n\
    \    }\n    return table[n]", "    let n_str = n.description\n    if n_str[n_str.startIndex]\
    \ == \"1\" {\n        return Int(pow(10, n - 1))\n    }\n    return Int(pow(10,\
    \ n - 2))", '    return 0', "    assert(n > 0, \"n must be positive\")\n    var\
    \ dp = [Int](count: n + 1, repeatedValue: 0)\n    dp[1] = 2\n    dp[2] = 3\n \
    \   for i in 3...n {\n        dp[i] = dp[i - 1] + dp[i - 2]\n    }\n    return\
    \ dp[n]", '  // Fill in your answer here', "  var index = [1, 1, 1, 1, 1, 1, 1,\
    \ 1, 1, 1]\n  for _ in 0..<n-1 {\n    var temp = [Int](repeating: 0, count: 10)\n\
    \    for i in 0..<10 {\n      if i != 0 {\n        temp[i] += index[i]\n     \
    \ }\n      if i != 9 {\n        temp[i] += index[i+1]\n      }\n    }\n    index\
    \ = temp\n  }\n  return index[1] + index[0]", "  // Solve this problem recursively.\n\
    \  precondition(n > 0)\n  return starts_one_ends_recursive(n: n)", "    var total\
    \ = 0\n\n    for i in 0..<n {\n        total += base_ten_to_power(n: i)\n    }\n\
    \n    return 2 * total", "    if n == 1 {\n        return 1\n    }\n    if n ==\
    \ 2 {\n        return 11\n    }\n    var ret: [Int] = Array(repeating: 0, count:\
    \ n + 1)\n    ret[1] = 1\n    ret[2] = 11\n    for i in 3...n {\n        ret[i]\
    \ = 9\n        for j in 1..<i {\n            ret[i] += ret[j] * 9\n        }\n\
    \    }\n    return ret[n]", "    if n == 1 {\n        return 2\n    } else if\
    \ n == 2 {\n        return 11\n    } else {\n        var ends_with = 1\n     \
    \   var ends_with_2 = 9\n        var ends_with_3 = 9\n        for _ in 2..<n {\n\
    \            ends_with_3 = ends_with_2\n            ends_with_2 = ends_with\n\
    \            ends_with = 10 * ends_with_2 + ends_with_3\n        }\n        return\
    \ ends_with + ends_with_2 + ends_with_3\n    }", "    // See my previous solution.\n\
    \    var count = 1\n    for _ in 1..<n {\n        count *= 2\n    }\n    return\
    \ count", "  if n == 1 {\n    return 1\n  }\n  var result = 9 * pow(10, n - 1)\n\
    \  result += starts_one_ends(n - 1)\n  return result", "  var n = n\n  var result\
    \ = 0\n  var power = Int(pow(10.0, Double(n - 1)))\n  while n > 0 {\n    result\
    \ += 9 * power\n    power /= 10\n    n -= 1\n  }\n  return result", "    // f(n)\
    \ = 9 * 10^(n-1) - f(n-1) = 9 * 10^(n-1) - f(n-2)\n    var f1 = 1\n    var f2\
    \ = 1\n    var f3 = 1\n    for _ in 1...n {\n        f3 = 9 * pow(10, f1-1) -\
    \ f2\n        f1 = f2\n        f2 = f3\n    }\n    return f3", "    if n == 1\
    \ {\n        return 1\n    }\n    if n == 2 {\n        return 11\n    }\n    var\
    \ result = 0\n    var previous_start = 1\n    var previous_end = 11\n    var current_start\
    \ = 10\n    var current_end = 9\n    for i in 2...n {\n        result = previous_start\
    \ + previous_end + current_start + current_end\n        previous_start = current_start\n\
    \        previous_end = current_end\n        current_start = previous_start *\
    \ 9\n        current_end = previous_end * 10\n    }\n    return result", "   \
    \ let min = 1 * Int(pow(10.0, Double(n - 1)))\n    let max = 9 * Int(pow(10.0,\
    \ Double(n - 1)))\n    return max - min + 1", "    if n == 1 {\n        return\
    \ 1\n    } else {\n        let twos = pow(2, n-1)\n        return twos + twos\
    \ - 2\n    }", "    if n == 1 {\n        return 2\n    } else if n == 2 {\n  \
    \      return 4\n    }\n    return starts_one_ends(n - 1) + starts_one_ends(n\
    \ - 2)", "    // TODO: implement\n    return 0", "  let digits = String(repeating:\
    \ \"*\", count: n).split(separator: \"\")\n  var result = 0\n  func recur(idx:\
    \ Int) {\n    if idx == n {\n      result += 1\n      return\n    }\n    if idx\
    \ == 0 || idx == n - 1 {\n      for d in 1...9 {\n        digits[idx] = String(d)\n\
    \        recur(idx: idx + 1)\n      }\n    } else {\n      for d in 0...9 {\n\
    \        digits[idx] = String(d)\n        recur(idx: idx + 1)\n      }\n    }\n\
    \  }\n  recur(idx: 0)\n  return result", "    var count = 0\n    if n <= 1 {\n\
    \        return 1\n    }\n    for i in 1..<n {\n        if i == 1 {\n        \
    \    count += 10\n        } else {\n            count += pow(10, i - 1)\n    \
    \    }\n    }\n    return count + 1", "    if n == 1 {\n        return 1\n   \
    \ } else {\n        return 10 - 2 + starts_one_ends(n - 1)\n    }", "  precondition(n\
    \ > 0)\n  var cnt = 0\n  for i in 1...n {\n    let i_digits = digits(i)\n    var\
    \ prefix_one = false\n    var suffix_one = false\n    for d in i_digits {\n  \
    \    if d == 1 {\n        suffix_one = true\n      } else {\n        suffix_one\
    \ = false\n      }\n      if prefix_one || suffix_one {\n        cnt += 1\n  \
    \    }\n      prefix_one = suffix_one\n    }\n  }\n  return cnt", "    guard n\
    \ > 1 else { return n }\n    var dp = Array(repeating: 0, count: n + 1)\n    dp[1]\
    \ = 1\n    for i in 2...n {\n        dp[i] = dp[i - 1] * 10 - dp[i - 2]\n    }\n\
    \    return dp[n]", "  return (1...9).reduce(0) { sum, d in\n    let s = String(d)\n\
    \    let ln = n - 1\n    let reg = \"^\\(s)\\\\d\\(ln)$|^\\\\d\\(ln)\\(s)$\"\n\
    \    var matcher = Regexp(reg)\n    let matched = (1...9).reduce(0) { s, i in\n\
    \      let m = matcher.match(\"\\(i)\")\n      return m ? s + 1 : s\n    }\n \
    \   return sum + matched\n  }", "    if n == 1 {\n        return 2\n    } else\
    \ if n == 2 {\n        return 4\n    }\n    return starts_one_ends(n - 1) + starts_one_ends(n\
    \ - 2)", "    // first digit: 1 \n    // last digit: 1\n    // n-2 in the middle\
    \ to have n digits\n    return 9 * pow(10, n-2)", "    var result = 0\n    var\
    \ k = 1\n    var i = 1\n    while i <= n {\n        result += 10 * k\n       \
    \ k = 10 * k + 1\n        i += 1\n    }\n    return result", '    return 0', '    return
    0', "    // i: length of (n - 1) digit integers that start with 1\n    // j: length\
    \ of (n - 1) digit integers that end with 1\n    var i = 1, j = 1\n    for _ in\
    \ 2...n {\n        let prev_i = i\n        i = j\n        j = prev_i + j\n   \
    \ }\n    return i + j", "    assert(n > 0, \"n must be a positive integer\")\n\
    \    var count = 0\n    for i in 1...n {\n        count += f(i)\n    }\n    return\
    \ count", '  return starts_one_ends_recur(n: n, first: true)', "    if n == 1\
    \ {\n        return 1\n    }\n    let dp = Array(repeating: Array(repeating: 0,\
    \ count: 2), count: n)\n    dp[0][0] = 0\n    dp[0][1] = 1\n    for i in 1..<n\
    \ {\n        for j in 0..<2 {\n            for k in 0..<10 {\n               \
    \ if j == 0 && k == 0 {\n                    continue\n                }\n   \
    \             dp[i][j] += dp[i - 1][j]\n            }\n        }\n    }\n    return\
    \ dp[n - 1][0] + dp[n - 1][1]", "    var prev: Int = 1\n    var curr: Int = 1\n\
    \    for _ in 2...n {\n        let oldcurr = curr\n        curr = 9 * curr\n \
    \       prev = oldcurr + curr\n    }\n    return prev", "    var count = 0\n \
    \   for i in 1..<n {\n        count += 9 * pow_10(i)\n    }\n    count += pow_10(n\
    \ - 1)\n    return count", '    return -1', "    //return count_all_n_digits(n:\
    \ n) - count_n_digits_no_end_one(n: n)\n    return count_n_digits_ending_one(n:\
    \ n)", "    if n == 1 {\n        return 2\n    } else if n == 2 {\n        return\
    \ 2\n    }\n    return starts_one_ends(n-1) + starts_one_ends(n-2)", "    precondition(n\
    \ > 0)\n    if n == 1 {\n        return 2\n    }\n    if n == 2 {\n        return\
    \ 4\n    }\n    let m = n - 1\n    var dp = [Int](count: m, repeatedValue: 0)\n\
    \    var dp1 = [Int](count: m, repeatedValue: 0)\n    dp[0] = 2\n    dp1[0] =\
    \ 1\n    dp[1] = 3\n    dp1[1] = 2\n    for i in 2..<m {\n        dp[i] = dp[i\
    \ - 1] + dp1[i - 1]\n        dp1[i] = dp[i - 1]\n    }\n    return dp[m - 1] +\
    \ dp1[m - 1]", "  // How many numbers starting with one.\n  var count = 1\n  for\
    \ _ in 1..<n {\n    count *= 10\n  }\n  // How many numbers ending with one.\n\
    \  count += n\n  return count", "  if n == 1 {\n    return 1\n  }\n\n  let count\
    \ = starts_one_ends(n-1)\n  let without_one = pow(9, n-1)\n\n  return count +\
    \ count - without_one", "    guard n > 1 else { return n }\n    var dp = [Int](repeating:\
    \ 0, count: n + 1)\n    dp[1] = 1\n    dp[2] = 10\n    for i in 3...n {\n    \
    \    dp[i] = dp[i - 1] + (dp[i - 1] - dp[i - 2]) * 9\n    }\n    return dp[n]",
  "    let numbers = (n - 1) * 9\n    let rest = starts_one_ends(n - 1)\n    return\
    \ numbers + rest", "    if n == 1 {\n        return 2\n    }\n    return other_nums(n-1)\
    \ + 1", "    if n == 1 {\n        return 2\n    } else if n < 1 {\n        return\
    \ 0\n    }\n    return others(n - 1) + starts_one_ends(n - 1)", "    // Indices\
    \ for possible digits.\n    let f_idx = 0\n    let g_idx = 1\n    let i_idx =\
    \ 2\n    let j_idx = 3\n    let n_idx = 4\n    let one_idx = 5\n    let zero_idx\
    \ = 6\n\n    let exp = (1...n).fold(1, combine: *)\n    var mods = Array(count:\
    \ n, repeatedValue: Array(count: 7, repeatedValue: 0))\n    mods[0][one_idx] =\
    \ 1\n    mods[0][zero_idx] = 1\n    mods[0][n_idx] = 1\n\n    for i in 1..<n {\n\
    \        mods[i][f_idx] = mods[i - 1][g_idx]\n        mods[i][g_idx] = (mods[i\
    \ - 1][f_idx] + mods[i - 1][i_idx] + mods[i - 1][j_idx]) % exp\n        mods[i][i_idx]\
    \ = (mods[i - 1][f_idx] + mods[i - 1][g_idx] + mods[i - 1][n_idx]) % exp\n   \
    \     mods[i][j_idx] = (mods[i - 1][g_idx] + mods[i - 1][n_idx]) % exp\n     \
    \   mods[i][n_idx] = (mods[i - 1][f_idx] + mods[i - 1][g_idx] + mods[i - 1][i_idx]\
    \ + mods[i - 1][j_idx]) % exp\n        mods[i][one_idx] = (mods[i - 1][one_idx]\
    \ + mods[i - 1][n_idx]) % exp\n        mods[i][zero_idx] = (mods[i - 1][zero_idx]\
    \ + mods[i - 1][n_idx]) % exp\n    }\n\n    return (mods[n - 1][one_idx] + mods[n\
    \ - 1][zero_idx]) % exp", "    if n == 1 {\n        return 10\n    } else if n\
    \ == 2 {\n        return 100\n    } else {\n        let leading_ones = 9 * (1..<n).reduce(1,\
    \ combine: { $0 * 10 })\n        let ending_ones = 9 * (1..<n).reduce(1, combine:\
    \ { $0 * 10 }) + 1\n        return leading_ones + ending_ones\n    }", "  if n\
    \ == 1 {\n    return 2\n  }\n  if n == 2 {\n    return 4\n  }\n  return 1 + starts_one_ends(n-1)\
    \ + starts_one_ends(n-2)", '    return ends_one_starts(n: n)', '  return n * n
    * n * n * n', "    // for n = 1, we have 1 one-digit positive integer that starts\
    \ or ends with 1\n    // for n = 2, we have the two-digit positive integers of\
    \ the form '1x' and 'x1',\n    // where x is any of the 9 other integers.\n  \
    \  // for n = 3, we have the three-digit positive integers of the form '1xx',\
    \ 'x1x',\n    // and 'xx1', where x is any of the 9 other integers.\n    // for\
    \ n = 4, we have the four-digit positive integers of the form '1xxx', 'x1xx',\n\
    \    // 'xx1x', and 'xxx1', where x is any of the 9 other integers.\n    // ...\n\
    \    //\n    // so we can see that the count is the sum of the series 9 * 10 ^\
    \ (i - 1), i = 1, 2, ..., n.\n    var s = 0\n    for i in 1...n {\n        s +=\
    \ 9 * Int(pow(10.0, Double(i - 1)))\n    }\n    return s", "    var result = n\n\
    \    for i in 1 ..< n {\n        result += Int(pow(Double(10), Double(i)))\n \
    \   }\n    return result", "    var i: Int = 1\n    var count: Int = 0\n    while\
    \ i <= n {\n        count += (power_mod(10, n: i - 1, mod: 1000000007) * 9) %\
    \ 1000000007\n        i += 1\n    }\n    count += (power_mod(10, n: n - 1, mod:\
    \ 1000000007) - 1) % 1000000007\n    return count % 1000000007", "    if n ==\
    \ 1 {\n        return 2\n    } else if n == 2 {\n        return 4\n    }\n   \
    \ var n = n\n    var digits = [1]\n    var count = 0\n    repeat {\n        digits.append(1)\n\
    \        count += 1\n        n -= 1\n    } while n > 2\n    count += Int(pow(10,\
    \ Double(n - 1))) * 2\n    return count", "  if n == 1 {\n    return 2\n  }\n\
    \  var digits = n-1\n  var result = 0\n  while digits > 0 {\n    result += nDigit(digits)*2\n\
    \    digits -= 1\n  }\n  return result + 2", "    // numbers that start with 1\n\
    \    var s = 1\n\n    for i in 1...n {\n        s *= 9\n    }\n\n    // number\
    \ that end with 1\n    var e = 1\n\n    for i in 1...n {\n        e *= 9\n   \
    \ }\n\n    e -= 9\n\n    // duplicates\n    var d = 1\n\n    for i in 1...n {\n\
    \        d *= 10\n    }\n\n    d -= (n + 1)\n\n    return s + e - d", '    return
    0', "  let result = Array(0...9).reduce(0) { $0 + ends_one($1, n) }\n\n  return\
    \ result", "    if n == 1 {\n        return 1\n    }\n    var (a, b) = (0, 0)\n\
    \    for i in 2...n {\n        (a, b) = (a + b, a)\n    }\n    return a + b +\
    \ 1", "    var cache = Array(repeating: Array(repeating: Int(), count: 2), count:\
    \ n)\n    return starts_one_ends(n: n, start: 1, end: 1, &cache)", '    return
    (1..<n).map { (1..<10).map { $0 * pow(10, $0.predecessor()) }.reduce(0, combine:
    +) }.reduce(0, combine: +) + 10', "  return count_n_digit_integers(\n    pred:\
    \ { $0 >= 1 },\n    succ: { $0 >= 1 },\n    start: 1,\n    end:   10,\n    n:\
    \     n)", "    var count = 0\n\n    for i in 1..<10 {\n        count += count_start_one(n,\
    \ i)\n    }\n\n    return count", "    if n <= 0 {\n        return 0\n    }\n\
    \    if n == 1 {\n        return 1\n    }\n    return starts_one_ends(n - 1) +\
    \ 9 * starts_one_ends(n - 2)", "    var (result, d, pd) = (0, 1, 1)\n    for i\
    \ in 2...n {\n        (result, d, pd) = (pd + d + result, pd, result)\n    }\n\
    \    return result + d", "    if n == 1 {\n        return 2\n    }\n    var v1\
    \ = 0, v2 = 0\n    for var i = 0; i < n; i++ {\n        if i == 0 {\n        \
    \    v1 = 1\n            v2 = 1\n        } else {\n            let tmp = v1\n\
    \            v1 = v1 + v2\n            v2 = tmp * 9\n        }\n    }\n    return\
    \ v1 + v2", '    return 0', '    return count_n_digits(n) - count_no_one(n)',
  "    // The counts for the beginning and end numbers\n    var starts_one = 0\n \
    \   var ends_one = 0\n    \n    if n == 1 {\n        // If there is only one digit,\
    \ we can only return 1\n        return 1\n    }\n    \n    // The counts for the\
    \ number of numbers of n-digit positive integers that\n    // contain one or not.\
    \ We use 1 for \"contains one\" and 0 for \"doesn't\n    // contain one\"\n  \
    \  var with_one = 0\n    var without_one = 0\n    \n    // If we have two digits,\
    \ we have 2 starting with 1, and 0 ending with 1\n    starts_one = 2\n    ends_one\
    \ = 0\n    \n    // If we have 3 digits, we have 0 starting with 1, and 2 ending\
    \ with 1\n    with_one = 2\n    without_one = 0\n    \n    // For the rest of\
    \ the digits, we have the same formula\n    for _ in 2..<n {\n        starts_one,\
    \ with_one = with_one, with_one + with_one + without_one\n        ends_one, without_one\
    \ = without_one, with_one + without_one\n    }\n    \n    // Return the sum of\
    \ the counts\n    return starts_one + ends_one", "    guard n > 1 else { return\
    \ 0 }\n    return ((1..<9).map { ten_power($0) } + (1..<n-1).map { nine_power($0)\
    \ }).reduce(0, combine: +)", '    return Int(pow(Double(10), Double(n-1))) - Int(pow(Double(9),
    Double(n-1)))', '    return count_n_digit_numbers(n, 0, 1)', "    precondition(n\
    \ > 0)\n    if n == 1 {\n        return 1\n    }\n    return fib(n) + fib(n -\
    \ 1) - 1", "    if n == 1 {\n        return 1\n    } else {\n        return Int(pow(10,\
    \ n - 1)) - Int(pow(9, n - 1))\n    }", '  return count_digits(number: 10, length:
    n)', "    var count = 0\n    // count 1-digit numbers\n    count += 1\n    var\
    \ i = 1\n    // count 2-digit numbers\n    i = 2\n    count += 10\n    while i\
    \ < n {\n        count += 1\n        count += 9 * pow(10, i - 1)\n        i +=\
    \ 1\n    }\n    return count", "    if n <= 0 {\n        return 0\n    }\n\n \
    \   if n == 1 {\n        return 1\n    }\n\n    var count = 0\n    var i = 1\n\
    \    while i < n {\n        count += pow(10, Double(i))\n        i += 1\n    }\n\
    \n    count += 1\n    return count", "  if n == 1 {\n    return 1\n  }\n  let\
    \ max: Int = Int(pow(10, Double(n)) - 1)\n  let min: Int = Int(pow(10, Double(n\
    \ - 1)))\n  var count: Int = 0\n  for i in min...max {\n    if \"\\(i)\".hasPrefix(\"\
    1\") || \"\\(i)\".hasSuffix(\"1\") {\n      count += 1\n    }\n  }\n  return count",
  "    var str = String(n)\n    var cnt = 0\n    for _ in 0..<(str.count - 1) {\n\
    \        str.removeFirst()\n        if str.first == \"1\" {\n            cnt +=\
    \ 1\n        }\n    }\n    return cnt", '    return 0', "    // TODO: add code\n\
    \    return 0", "    var s = 0\n    let e = 10.pow(n)\n    for i in 1..<e {\n\
    \        if (i / e) % 10 == 1 || i % 10 == 1 {\n            s += 1\n        }\n\
    \    }\n    return s", "    if n == 1 {\n        return 2\n    } else if n ==\
    \ 2 {\n        return 9\n    } else {\n        return starts_one_ends(n-1) + 10*(n-1)\n\
    \    }", '    return n == 1 ? 1 : starts_one_ends(n - 1) + n - 1', "    let ranges\
    \ = Int(pow(10, Double(n)))\n    let ones = Int(pow(10, Double(n - 1)))\n    let\
    \ no_ones = Int(pow(10, Double(n - 2)))\n    return ranges - ones - no_ones",
  "    if n == 1 {\n        return 2\n    }\n    var s = 0\n    var f = 1\n    var\
    \ p = 1\n    for _ in 1...n {\n        s += f\n        p *= 10\n        f = p\
    \ - f\n    }\n    return s", '    return 0', "    if n == 1 {\n        return\
    \ 2\n    }\n    return starts_one_ends(n - 1) + nine(n - 1)", "  if n <= 1 {\n\
    \    return 0\n  }\n  if n == 2 {\n    return 9\n  }\n  var sum = 9\n  var high\
    \ = 1\n  for _ in 1..<n {\n    high *= 10\n    sum += 10 * high\n  }\n  return\
    \ sum", "    var total = 0\n    for i in 1...n {\n        total += ends_one(n:\
    \ i)\n    }\n    return total", "    precondition(n > 0)\n    if n == 1 {\n  \
    \      return 1\n    }\n    var dp = [1, 1]\n    for i in 2...n {\n        dp.append(dp[i\
    \ - 1] + dp[i - 2])\n    }\n    return dp[n]", "  if n == 1 {\n    return 1\n\
    \  }\n  let r = starts_one_ends(n - 1)\n  return r + 9 * r", "    // n = 1, only\
    \ 1.\n    // n = 2, 10 and 11, total 2.\n    // n = 3, 100, 101, 110, 111, total\
    \ 4.\n    // n = 4, 1000, 1001, 1010, 1011, 1100, 1101, 1110, 1111, total 8.\n\
    \    // so f(n) = f(n-1) + f(n-2)\n    if n == 1 {\n        return 1\n    }\n\
    \    if n == 2 {\n        return 2\n    }\n    var ans = 0\n    var prev = 2,\
    \ prev_prev = 1\n    for _ in 3...n {\n        ans = prev + prev_prev\n      \
    \  prev_prev = prev\n        prev = ans\n    }\n    return ans", "  if n <= 1\
    \ {\n    return 0\n  }\n  // It is obvious that for n > 1, the answer is 10^(n-1)\
    \ - 9^(n-1).\n  return power_int(10, n-1) - power_int(9, n-1)", "    let digits\
    \ = count_digits(n)\n    return (n - digits) * count_digits(n - 1)", "    if n\
    \ == 1 {\n        return 1\n    } else {\n        return starts_one_ends(n - 1)\
    \ + 9 * pow(10, n - 2)\n    }", '    return starts_one_ends_helper(n: n, contains_one:
    true)', "    var count = 0\n    var a: [Int] = Array(repeating: 0, count: n +\
    \ 1)\n    var b: [Int] = Array(repeating: 0, count: n + 1)\n    a[1] = b[1] =\
    \ 1\n    for i in 2...n {\n        a[i] = a[i - 1] + b[i - 1]\n        b[i] =\
    \ a[i - 1]\n    }\n    return a[n] + b[n]", '    return 10 * count_nums(n - 1)
    + 9', "    // count in base 2, then convert to base 10\n    if n == 1 {\n    \
    \    return 2\n    }\n    return Int(pow(2, Double(n - 1)))", "    // TODO\n \
    \   return 0", "    if n == 1 {\n        return 10\n    } else if n == 2 {\n \
    \       return 100\n    } else {\n        return 9 * Int(pow(10.0, Float(n - 1)))\n\
    \    }", '    return fn_cache(n)', "    if n == 1 {\n        return 2\n    }\n\
    \    return ends_one_ends(n: n - 1) + starts_one_ends(n: n - 1)", "    if n ==\
    \ 1 {\n        return 2\n    }\n    return 10 * starts_one_ends(n - 1) - (9 *\
    \ starts_one_ends(n - 2))", "    var dp = Array(repeating: 0, count: n + 1)\n\
    \    for i in 1...n {\n        dp[i] = pow(10, i - 1)\n        if i > 1 {\n  \
    \          dp[i] += dp[i - 1] * 9\n        }\n    }\n    return dp[n]", "    if\
    \ n == 1 {\n        return 2\n    }\n    if n == 2 {\n        return 4\n    }\n\
    \    let a = starts_one_ends(n - 1)\n    let b = starts_one_ends(n - 2)\n    return\
    \ a + b", "  if n <= 1 {\n    return 1\n  }\n\n  var f0 = 1\n  var f1 = 1\n  var\
    \ f2 = 1\n  for _ in 2..<n {\n    f2 = f1 + f0\n    f0 = f1\n    f1 = f2\n  }\n\
    \  return f2 + f0", "    guard n > 1 else { return 0 }\n    return 10 * starts_one_ends(n:\
    \ n - 1) + 9", "    precondition(n > 0)\n    if n == 1 {\n        return 2\n \
    \   }\n    let nMinusOne = starts_one_ends(n: n - 1)\n    let nMinusTwo = starts_one_ends(n:\
    \ n - 2)\n    return nMinusOne + nMinusTwo", '    return 1', "    if n == 1 {\n\
    \        return 2\n    } else if n == 2 {\n        return 3\n    } else {\n  \
    \      return starts_one_ends(n-1) + starts_one_ends(n-2)\n    }", '    return
    ends_one_ends(n) + ends_zero_ends(n)', "    var dp = Array(count: n + 1, repeatedValue:\
    \ 0)\n    var c = 1\n    dp[0] = 0\n    dp[1] = 1\n    dp[2] = 10\n    for i in\
    \ 3...n {\n        c *= 10\n        dp[i] = dp[i - 1] * 9 + c\n    }\n    return\
    \ dp[n]", "    if n == 1 {\n        return 1\n    }\n    if n == 2 {\n       \
    \ return 2\n    }\n    var nums = [Int](repeating: 0, count: n + 1)\n    nums[1]\
    \ = 1\n    nums[2] = 2\n    for i in 3...n {\n        nums[i] = nums[i - 1] +\
    \ nums[i - 2]\n    }\n    return nums[n]", "    var res = 0\n    for len in 1...n\
    \ {\n        res += starts_one_ends(n: n, len: len)\n    }\n    return res", " \
    \   assert(n > 0, \"Unsupported size\")\n    let count = pow(10, Double(n)) -\
    \ pow(9, Double(n))\n    return Int(count)"]
stop_tokens:
- "\n}"
