name: HumanEval_41_car_race_collision
language: swift
prompt: "\n/// Imagine a road that's a perfectly straight infinitely long line.\n\
  /// n cars are driving left to right;  simultaneously, a different set of n cars\n\
  /// are driving right to left.   The two sets of cars start out being very far from\n\
  /// each other.  All cars move in the same speed.  Two cars are said to collide\n\
  /// when a car that's moving left to right hits a car that's moving right to left.\n\
  /// However, the cars are infinitely sturdy and strong; as a result, they continue\
  \ moving\n/// in their trajectory as if they did not collide.\n/// This function\
  \ outputs the number of such collisions.\nfunc car_race_collision(n: Int) -> Int\
  \ {\n"
tests: "}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if\
  \ left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left,\
  \ right) {\n        if l != r {\n            return false\n        }\n    }\n  \
  \  return true\n}\n            \nassert(car_race_collision(n: 2) == 4)\nassert(car_race_collision(n:\
  \ 3) == 9)\nassert(car_race_collision(n: 4) == 16)\nassert(car_race_collision(n:\
  \ 8) == 64)\nassert(car_race_collision(n: 10) == 100)"
completions: ["    var cars_left = [Int](1...n)\n    var cars_right = [Int](1...n)\n\
    \    var collisions = 0\n    while !cars_left.isEmpty {\n        let car_left\
    \ = cars_left.removeFirst()\n        if let index = cars_right.index(of: car_left)\
    \ {\n            cars_right.remove(at: index)\n            collisions += 1\n \
    \       }\n    }\n    return collisions", "    \n    var m = n\n    var sum =\
    \ 0\n    while (m != 0) {\n        sum += m\n        m -= 1\n    }\n    return\
    \ sum", "    var car = [Int](0..<n)\n    var count = 0\n    for i in 0..<n {\n\
    \        for j in 0..<n {\n            if car[i] > car[j] {\n                swap(&car[i],\
    \ &car[j])\n                count += 1\n            }\n        }\n    }\n    return\
    \ count", '    return n*(n-1)/2', "    var road = Array(repeating: 0, count: n)\n\
    \    var cars = Array(repeating: 0, count: n)\n    for i in 0..<n {\n        cars[i]\
    \ = Int.random(in: 1...100)\n    }\n    cars.sort()\n    var collisions = 0\n\
    \    var j = n - 1\n    for i in 0..<n {\n        while j >= 0 && cars[i] - cars[j]\
    \ < 0 {\n            collisions += 1\n            j -= 1\n        }\n    }\n \
    \   return collisions", "    // The answer is that there is a pattern.\n    //\n\
    \    // When the first car in the right-to-left lane is closest to the median,\n\
    \    // the first car in the left-to-right lane (i.e. the car that started first)\
    \ is the\n    // one that's going to collide with it.\n    //\n    // When the\
    \ second car in the right-to-left lane is closest to the median,\n    // the second\
    \ car in the left-to-right lane (i.e. the car that started second) is the\n  \
    \  // one that's going to collide with it.\n    //\n    // and so on.\n    //\n\
    \    // So, the answer is n.\n    return n", "    var collisions = 0\n    if n\
    \ > 0 {\n        for i in 1...n {\n            for j in i+1...n {\n          \
    \      collisions += 1\n            }\n        }\n    }\n    return collisions",
  "    var i = 0\n    var j = n-1\n    var counter = 0\n    while i < n-1 && j > 0\
    \ {\n        if i == j {\n            break\n        }\n        if j < i {\n \
    \           counter += 1\n            j -= 1\n        } else {\n            i\
    \ += 1\n        }\n    }\n    return counter", "    return (1..<n).reduce(0, {\
    \ (acc: Int, curr: Int) -> Int in\n        return acc + curr\n    })", '    return
    n * (n - 1) / 2', "    let n = n\n    var numCollisions = 0\n    let speed = Array(1...n)\n\
    \    var leftToRight: [Int] = []\n    var rightToLeft: [Int] = []\n    var stack:\
    \ [Int] = []\n    if n <= 1 {\n        return 0\n    }\n    if n == 2 {\n    \
    \    return 1\n    }\n    for index in 0..<n {\n        leftToRight.append(speed[index])\n\
    \        rightToLeft.append(speed[n - 1 - index])\n    }\n    while stack.count\
    \ < n {\n        if leftToRight.count > 0 && rightToLeft.count > 0 {\n       \
    \     if leftToRight[0] > rightToLeft[0] {\n                rightToLeft.remove(at:\
    \ 0)\n                stack.append(leftToRight[0])\n                leftToRight.remove(at:\
    \ 0)\n            } else {\n                numCollisions += 1\n             \
    \   leftToRight.remove(at: 0)\n                rightToLeft.remove(at: 0)\n   \
    \         }\n        } else if leftToRight.count > 0 {\n            stack.append(leftToRight[0])\n\
    \            leftToRight.remove(at: 0)\n        } else if rightToLeft.count >\
    \ 0 {\n            stack.append(rightToLeft[0])\n            rightToLeft.remove(at:\
    \ 0)\n        }\n    }\n    return numCollisions", "    var matches = 0\n    var\
    \ no_matches = 0\n    var left_cars = Array(repeating: 0, count: n)\n    var right_cars\
    \ = Array(repeating: 0, count: n)\n    for i in 0..<n {\n        left_cars[i]\
    \ = i\n        right_cars[i] = i\n    }\n    for i in 0..<n {\n        for j in\
    \ 0..<n {\n            if left_cars[i] == right_cars[j] {\n                matches\
    \ += 1\n            } else {\n                no_matches += 1\n            }\n\
    \        }\n    }\n    return matches", "    var leftToRight: Array<Int> = Array(1...n)\n\
    \    var rightToLeft: Array<Int> = Array(1...n)\n    leftToRight.sortInPlace({\
    \ _,_ in return arc4random() % 2 == 0 })\n    rightToLeft.sortInPlace({ _,_ in\
    \ return arc4random() % 2 == 0 })\n    var totalCollisions = 0\n    for left in\
    \ leftToRight {\n        for right in rightToLeft {\n            if left == right\
    \ {\n                totalCollisions += 1\n            }\n        }\n    }\n \
    \   return totalCollisions", "    if n == 0 {\n        return 0\n    }\n    var\
    \ collision_number = 0\n    var left_to_right = [Int](1...n)\n    var right_to_left\
    \ = [Int](1...n)\n    while !right_to_left.isEmpty && !left_to_right.isEmpty {\n\
    \        var left_to_right_car = left_to_right.removeLast()\n        var right_to_left_car\
    \ = right_to_left.removeLast()\n        if left_to_right_car == right_to_left_car\
    \ {\n            collision_number += 1\n        } else {\n            if left_to_right_car\
    \ > right_to_left_car {\n                left_to_right.append(left_to_right_car)\n\
    \            } else {\n                right_to_left.append(right_to_left_car)\n\
    \            }\n        }\n    }\n    return collision_number", "    var array\
    \ = Array(repeating: 0, count: n)\n    var array2 = Array(repeating: 0, count:\
    \ n)\n    for i in 0..<n {\n        array[i] = i\n        array2[i] = i + n\n\
    \    }\n    var collisions = 0\n    for (i,a) in array.enumerated() {\n      \
    \  for (j,b) in array2.enumerated() {\n            if a == b {\n             \
    \   collisions += 1\n                array2.remove(at: j)\n                break\n\
    \            }\n        }\n    }\n    return collisions", "    var first_arr:\
    \ [Int] = []\n    var second_arr: [Int] = []\n    var first_i = 0\n    var second_i\
    \ = 0\n    var collision = 0\n    for _ in 0..<n {\n        first_arr.append(Int.random(in:\
    \ 1...100))\n        second_arr.append(Int.random(in: 1...100))\n    }\n    first_arr.sort()\n\
    \    second_arr.sort()\n    while first_i < n && second_i < n {\n        if first_arr[first_i]\
    \ < second_arr[second_i] {\n            collision += n - second_i\n          \
    \  first_i += 1\n        } else {\n            second_i += 1\n        }\n    }\n\
    \    return collision", "    var carsLeft = (1...n).map{Car(id: $0, direction:\
    \ .left)}\n    var carsRight = (1...n).map{Car(id: $0, direction: .right)}\n \
    \   var collisions = 0\n    while !carsLeft.isEmpty {\n        let left = carsLeft.removeLast()\n\
    \        let right = carsRight.removeLast()\n        if left.id == right.id {\n\
    \            collisions += 1\n        }\n    }\n    return collisions", "    var\
    \ (leftToRightCollisions,rightToLeftCollisions) = (0,0)\n    // at any time, the\
    \ number of collisions is the product of the number of cars in the road\n    //\
    \ we could also have a function that outputs the number of cars in the road\n\
    \    // and a function that outputs the number of collisions\n    // this code\
    \ here will be efficient enough to solve the problem\n    for i in (1...n) {\n\
    \        leftToRightCollisions += i\n        rightToLeftCollisions += n - i +\
    \ 1\n    }\n    return leftToRightCollisions * rightToLeftCollisions", '    return
    n * (n - 1) / 2', "    let x = Array(0..<n)\n    let y = Array(0..<n).reversed()\n\
    \    var collisions = 0\n    for i in 0..<n {\n        for j in 0..<n {\n    \
    \        if x[i] < y[j] {\n                collisions += 1\n            }\n  \
    \      }\n    }\n    return collisions", '    return (n * (n - 1)) / 2', "   \
    \ var c = 0\n    for _ in 1...n {\n        c += n\n    }\n    return c", "   \
    \ var l = 0 // left to right\n    var r = n - 1 // right to left\n    var count\
    \ = 0\n    var car = [Int](repeating: 0, count: n)\n    for i in 0..<n {\n   \
    \     car[i] = Int.random(in: 0..<n)\n    }\n    car.sort()\n    for i in 0..<n\
    \ {\n        if car[i] > l {\n            count += 1\n            l += 1\n   \
    \     } else {\n            count += 1\n            r -= 1\n        }\n    }\n\
    \    return count", "  let n = n/2\n  //let n = n/2 + 1\n  var ret = 0\n  for\
    \ i in 1...n {\n    for j in i+1...n {\n      ret += 2 * i * j\n    }\n  }\n \
    \ return ret", '    return n', "    var left  = [Int](1...n)\n    var right =\
    \ [Int](1...n)\n    return left.reduce(0) { $0 + right.reduce(0) { $0 + ($1 ==\
    \ $2 ? 1 : 0) } }", "    \n    // If a car starts at x_0 and moves with speed\
    \ v, then after time t it's at x_0 + t * v.\n    // If two cars moving at different\
    \ directions collide, then their respective positions\n    // are equal at that\
    \ time.  So let's sort the cars by position, and for each pair\n    // (a, b)\
    \ of cars that are neighbors in the sorted list, if a is moving left to right\
    \ and\n    // b is moving right to left, and the cars haven't yet collided, then\
    \ the time of collision\n    // is given by (b.pos - a.pos) / (a.vel - b.vel).\
    \  We can now compute the time of collision,\n    // and then advance the car\
    \ positions to that time.  If after advancing the cars,\n    // a car is still\
    \ \"in front\" of the other car, then there is another collision.\n    // We can\
    \ detect that case by checking whether the positions of a and b are now equal.\n\
    \    // And so on, until there are no collisions.\n    \n    // In practice, it's\
    \ simpler and more efficient not to explicitly sort the cars\n    // by position,\
    \ but rather keep a min-heap on the left-to-right cars and\n    // a max-heap\
    \ on the right-to-left cars.  That way we can always easily find\n    // the next\
    \ pair of cars that may collide.\n    \n    // We can do this in O(n * log n)\
    \ time with O(n) space.\n    \n    // This is a little tricky to do:  left-to-right\
    \ cars will be inserted into the min-heap,\n    // and the min-heap's compare\
    \ predicate must take into account their position *and* their velocity.\n    //\
    \ The reason is that two different cars may have the same position at time 0,\
    \ and we must\n    // be able to distinguish between them.  Similarly, right-to-left\
    \ cars will be inserted into\n    // the max-heap, and the max-heap's compare\
    \ predicate must also take into account their position\n    // *and* their velocity.\n\
    \    \n    // It's possible to implement a min-heap that uses a compare predicate\
    \ that takes into account\n    // multiple fields in the element.  The compare\
    \ predicate would return -1", '    return n * (n - 1)', "    var right = Array(0..<n).map\
    \ {(x: $0, y: true)}\n    var left = Array(0..<n).map {(x: $0, y: false)}\n  \
    \  var output = 0\n    while !right.isEmpty {\n        let cur = right.removeFirst()\n\
    \        while let idx = left.index(where: {$0.x == cur.x}) {\n            left.remove(at:\
    \ idx)\n            output += 1\n        }\n    }\n    return output", "    //\
    \ The trick is to imagine that each car takes up a range of space.  Specifically,\n\
    \    // a car coming from the left starts at left_start, and ends at left_end,\
    \ where\n    // left_start is 0, and left_end is left_start - n.  Similarly, a\
    \ car coming from\n    // the right starts at right_start, and ends at right_end,\
    \ where right_start is \n    // n and right_end is right_start + n.\n    //\n\
    \    // With this in mind, we can see that a collision happens when left_start\
    \ is \n    // in the range [right_start, right_end], or right_start is in the\
    \ range\n    // [left_start, left_end].  To compute the number of collisions,\
    \ we simply\n    // note that the number of collisions is the number of iterations\
    \ in which\n    // left_start is in the range [right_start, right_end].  Similarly,\
    \ we note\n    // that the number of collisions is the number of iterations in\
    \ which\n    // right_start is in the range [left_start, left_end].  So we add\
    \ both of these\n    // numbers together.  One could also simply note that the\
    \ number of collisions\n    // is the number of iterations in which left_start\
    \ = right_start.\n    var left_start = 0\n    var right_start = n\n    var collisions\
    \ = 0\n    // The first 2 for loops do the job of the 2 checks in the previous\
    \ paragraph.\n    for _ in 0..<n {\n        if left_start >= right_start && left_start\
    \ <= right_start + n {\n            collisions += 1\n        }\n        left_start\
    \ -= 1\n    }\n    for _ in 0..<n {\n        if right_start >= left_start && right_start\
    \ <= left_start + n {\n            collisions += 1\n        }\n        right_start\
    \ += 1\n    }\n    return collisions", "  // TODO\n  return 0", "    let l = Array(0..<n)\n\
    \    let r = Array(0..<n).reversed()\n    var collisions = 0\n    for i in 0..<n\
    \ {\n        for j in 0..<n {\n            if l[i] == r[j] {\n               \
    \ collisions += 1\n            }\n        }\n    }\n    return collisions", " \
    \   var left_to_right_times: [Int] = []\n    var right_to_left_times: [Int] =\
    \ []\n    for i in 1 ... n {\n        left_to_right_times.append(i)\n        right_to_left_times.append(n\
    \ + 1 - i)\n    }\n    return counting_sort(input: left_to_right_times + right_to_left_times)",
  "    var car_positions: [Int] = []\n    var car_movements: [Int] = []\n    var car_movement_indexes:\
    \ [Int] = []\n    var collision_count = 0\n    \n    for i in 0..<n {\n      \
    \  car_positions.append(i)\n        car_movements.append(1)\n        car_movement_indexes.append(i)\n\
    \    }\n    \n    for i in 0..<n {\n        car_positions.append(i)\n        car_movements.append(-1)\n\
    \        car_movement_indexes.append(i + n)\n    }\n    \n    for i in 0..<car_positions.count\
    \ {\n        for j in 0..<car_positions.count {\n            if car_movements[i]\
    \ != car_movements[j] && car_positions[i] == car_positions[j] {\n            \
    \    car_movement_indexes[i] = j\n                car_movement_indexes[j] = i\n\
    \            }\n        }\n    }\n    \n    for i in 0..<car_positions.count {\n\
    \        let index = car_movement_indexes[i]\n        car_positions[index] +=\
    \ car_movements[index]\n        if car_positions[index] == car_positions[i] {\n\
    \            collision_count += 1\n        }\n    }\n    \n    return collision_count",
  "    let n = n\n    var n1:Int = 0\n    var n2:Int = 0\n    var left:[Int] = []\n\
    \    var right:[Int] = []\n    let max1 = Int.random(in: 1..<n)\n    let max2\
    \ = Int.random(in: 1..<n)\n    for _ in 0..<max1 {\n        left.append(Int.random(in:\
    \ 0..<n))\n    }\n    for _ in 0..<max2 {\n        right.append(Int.random(in:\
    \ 0..<n))\n    }\n    for i in 0..<max1 {\n        for j in 0..<max2 {\n     \
    \       if(left[i]>right[j]){\n                n1 += 1\n            }\n      \
    \  }\n    }\n    for i in 0..<max1 {\n        for j in 0..<max2 {\n          \
    \  if(left[i]<right[j]){\n                n2 += 1\n            }\n        }\n\
    \    }\n    return n1+n2", "    let m = (1...n).map { (i: Int) -> [Int] in [i]\
    \ }\n    return rec_car_race_collision(l: m, r: m)", "    // number of cars travelling\
    \ from left to right\n    // number of cars travelling from right to left\n  \
    \  var num_left_right = n\n    var num_right_left = n\n    var counter = 0\n \
    \   // We can use the n's as an index\n    while (num_left_right > 0 && num_right_left\
    \ > 0) {\n        if (num_left_right == num_right_left) {\n            counter\
    \ += num_left_right\n            num_left_right -= 1\n            num_right_left\
    \ -= 1\n        } else if (num_left_right > num_right_left) {\n            counter\
    \ += num_right_left\n            num_left_right -= num_right_left\n        } else\
    \ {\n            counter += num_left_right\n            num_right_left -= num_left_right\n\
    \        }\n    }\n    return counter", "  let leftToRightCars = getCars(direction:\
    \ .leftToRight, count: n)\n  let rightToLeftCars = getCars(direction: .rightToLeft,\
    \ count: n)\n  var collisions: Int = 0\n  for i in 0..<n {\n    let rtlCar = rightToLeftCars[i]\n\
    \    let ltrCar = leftToRightCars[i]\n    if rtlCar.hit(ltrCar) {\n      collisions\
    \ += 1\n    }\n  }\n  return collisions", '  return 0', "    if n < 2 {\n    \
    \    return 0\n    }\n    var collidingCars = 0\n    // First, sort the left-to-right\
    \ cars according to their starting position\n    var leftToRightCars: [Int] =\
    \ (0..<n).map { _ in Int.random(in: 0..<100000) }\n    leftToRightCars.sort()\n\
    \    // Second, sort the right-to-left cars according to their starting position\n\
    \    var rightToLeftCars: [Int] = (0..<n).map { _ in Int.random(in: 0..<100000)\
    \ }\n    rightToLeftCars.sort()\n    // Third, loop through each pair of cars.\
    \  For each pair, find the collision time.\n    // Increment the count of colliding\
    \ cars by 1 if the collision time is positive.\n    for idx in 0..<n {\n     \
    \   let collisionTime = (leftToRightCars[idx] - rightToLeftCars[idx]) / 2\n  \
    \      if collisionTime > 0 {\n            collidingCars += 1\n        }\n   \
    \ }\n    return collidingCars", "    let y_coordinate = Array<Double>(repeating:\
    \ 0, count: n)\n    let x_coordinate = Array<Double>(repeating: 0, count: n)\n\
    \    for i in 0..<n {\n        y_coordinate[i] = Double(i)\n        x_coordinate[i]\
    \ = pow(Double(i+1), 2)\n    }\n    return collision(y_coordinate: y_coordinate,\
    \ x_coordinate: x_coordinate)", "    var first_car_positions = [Int]()\n    var\
    \ second_car_positions = [Int]()\n    for i in 0...n-1 {\n        first_car_positions.append(i)\n\
    \        second_car_positions.append(i+n)\n    }\n    var count = 0\n    var first_index\
    \ = 0\n    var second_index = n-1\n    while first_index < n && second_index >=\
    \ 0 {\n        if first_car_positions[first_index] < second_car_positions[second_index]\
    \ {\n            count += 1\n            first_index += 1\n        } else {\n\
    \            second_index -= 1\n        }\n    }\n    return count", '    return
    (n * (n - 1)) / 2', '    return 0', "    var rightToLeft = [Int]()\n    var leftToRight\
    \ = [Int]()\n    var collisionCount = 0\n    \n    // Generate n random numbers\
    \ between 0 and n-1\n    for _ in 0..<n {\n        rightToLeft.append(Int.random(in:\
    \ 0..<n))\n        leftToRight.append(Int.random(in: 0..<n))\n    }\n    \n  \
    \  // Sort both arrays\n    leftToRight.sort()\n    rightToLeft.sort()\n    \n\
    \    // Find the intersection\n    var leftIndex = 0\n    var rightIndex = 0\n\
    \    var leftCount = leftToRight.count\n    var rightCount = rightToLeft.count\n\
    \    \n    while leftIndex < leftCount && rightIndex < rightCount {\n        if\
    \ leftToRight[leftIndex] == rightToLeft[rightIndex] {\n            collisionCount\
    \ += 1\n            leftIndex += 1\n            rightIndex += 1\n        } else\
    \ if leftToRight[leftIndex] < rightToLeft[rightIndex] {\n            leftIndex\
    \ += 1\n        } else {\n            rightIndex += 1\n        }\n    }\n    \n\
    \    return collisionCount", "    var car_collisions = 0\n    var left_car_pos\
    \ = Array(repeating: 0, count: n)\n    var right_car_pos = Array(repeating: 0,\
    \ count: n)\n    for i in 0..<n {\n        left_car_pos[i] = i\n        right_car_pos[i]\
    \ = n - i - 1\n    }\n    var right_index = 0\n    for i in 0..<n {\n        while\
    \ right_index < n && right_car_pos[right_index] <= left_car_pos[i] {\n       \
    \     right_index += 1\n        }\n        car_collisions += right_index - i -\
    \ 1\n    }\n    return car_collisions", "    var collisions = 0\n    for i in\
    \ 0..<n {\n        for j in (i+1)..<n {\n            if i < j {\n            \
    \    collisions += 1\n            }\n        }\n    }\n    return collisions",
  "    if n < 2 {\n        return 0\n    }\n    return n * (n - 1)", "    var car_left\
    \ = 1\n    var car_right = n\n    var direction = 1\n    var collision = 0\n \
    \   while car_left <= n && car_right >= 1 {\n        if direction == 1 {\n   \
    \         car_left += 1\n            if car_left == car_right {\n            \
    \    collision += 1\n            }\n        } else {\n            car_right -=\
    \ 1\n            if car_left == car_right {\n                collision += 1\n\
    \            }\n        }\n        direction *= -1\n    }\n    return collision",
  "    \n    return n * (n - 1) / 2", "    if n == 0 {\n        return 0\n    }\n\
    \    let arr = Array(repeating: 1, count: n)\n    return arr.count / 2", "   \
    \ var result = 0\n    var left = 0\n    var right = n - 1\n    var leftCar = Array(repeating:\
    \ 0, count: n)\n    var rightCar = Array(repeating: 0, count: n)\n    for i in\
    \ 0..<n {\n        leftCar[i] = i\n        rightCar[i] = n - 1 - i\n    }\n  \
    \  while left <= right {\n        if leftCar[left] < rightCar[right] {\n     \
    \       result += right - left\n            left += 1\n        } else {\n    \
    \        right -= 1\n        }\n    }\n    return result", "    assert(n >= 0)\n\
    \    if n == 0 {\n        return 0\n    }\n    var left = [Int]()\n    var right\
    \ = [Int]()\n    for i in 1...n {\n        left.append(i)\n        right.append(n\
    \ + 1 - i)\n    }\n    return car_race_collision(left, right: right)", "    var\
    \ collisions = 0\n    for i in 0..<n {\n        for j in 0..<n {\n           \
    \ if i < j {\n                collisions += 1\n            }\n        }\n    }\n\
    \    return collisions", "    \n    if n <= 0 {\n        return 0\n    }\n   \
    \ \n    if n % 2 == 0 {\n        return n * (n - 2)\n    } else {\n        return\
    \ n * (n - 1)\n    }", "    var i: Int = 0\n    var j: Int = n-1\n    var collision_count:\
    \ Int = 0\n    while i < n && j >= 0 {\n        if i != j {\n            collision_count\
    \ += 1\n        }\n        i += 1\n        j -= 1\n    }\n    return collision_count",
  "    let m = Int(sqrt(Double(n * n + n) / 2.0))\n    var coll = 0\n    for i in\
    \ 1...m {\n        coll += (n - i)\n    }\n    return coll", "    var left = [Int]()\n\
    \    var right = [Int]()\n    for i in 0..<n {\n        left.append(i)\n     \
    \   right.append(n-i-1)\n    }\n    var collisions = 0\n    for i in 0..<n {\n\
    \        for j in 0..<n {\n            if (left[i] < right[j]) {\n           \
    \     collisions += 1\n            }\n        }\n    }\n    return collisions",
  "    var collisions = 0\n    var leftToRight = Array(repeating: true, count: n)\n\
    \    var rightToLeft = Array(repeating: false, count: n)\n    for index in 0..<n\
    \ {\n        for innerIndex in 0..<n {\n            if leftToRight[index] == rightToLeft[innerIndex]\
    \ {\n                collisions += 1\n            }\n        }\n    }\n    return\
    \ collisions", "    \n    var collisions = 0\n    \n    // n cars are moving left\
    \ to right\n    // n cars are moving right to left\n    // check for collisions\
    \ among these two sets of cars\n    // collision is possible if left car's position\
    \ is less than right car's position\n    // once collision is detected, the left\
    \ car position needs to move to a higher position\n    // but the right car position\
    \ can remain the same; this will prevent a future collision\n    // from being\
    \ detected\n    \n    var lc = [Int](repeating: 0, count: n)\n    var rc = [Int](repeating:\
    \ 0, count: n)\n    \n    for i in 0 ..< n {\n        lc[i] = i + 1\n        rc[i]\
    \ = i + 1\n    }\n    \n    // NOTE:  each time we go through the loop, we remove\
    \ one car from the right side\n    // since we're done with it; on the left side,\
    \ cars are still waiting to race\n    // so we need to keep track of the array\
    \ length we are working with\n    // and remove the cars that have passed by\n\
    \    var len_l = n\n    var len_r = n\n    \n    while len_r > 0 {\n        //\
    \ check for collisions\n        for i in 0 ..< len_l {\n            for j in 0\
    \ ..< len_r {\n                if lc[i] < rc[j] {\n                    collisions\
    \ += 1\n                    // remove the right car from the array\n         \
    \           // so we don't count it twice\n                    rc.remove(at: j)\n\
    \                    len_r -= 1\n                    break\n                }\n\
    \            }\n        }\n        // we are done with the left car; remove it\n\
    \        lc.remove(at: 0)\n        len_l -= 1\n    }\n    \n    return collisions",
  "    if n == 0 {\n        return 0\n    }\n    return n-1 + car_race_collision(n-1)",
  "    var collisions = 0\n    var left_to_right = [Int](1...n)\n    var right_to_left\
    \ = [Int](1...n)\n    right_to_left.reverse()\n    for i in 0..<n {\n        for\
    \ j in 0..<n {\n            if left_to_right[i] == right_to_left[j] {\n      \
    \          collisions += 1\n            }\n        }\n    }\n    return collisions",
  "    var result = 0\n    var leftToRight = [Int](repeating: 0, count: n)\n    var\
    \ rightToLeft = [Int](repeating: 0, count: n)\n    for i in 0..<n {\n        leftToRight[i]\
    \ = i\n        rightToLeft[i] = n - i - 1\n    }\n    for i in 0..<n {\n     \
    \   for j in 0..<n {\n            if leftToRight[i] == rightToLeft[j] {\n    \
    \            result += 1\n            }\n        }\n    }\n    return result",
  '    return 0', "    var collisions = 0\n    for i in 0..<n {\n        for j in\
    \ (i+1)..<n {\n            collisions += 1\n        }\n    }\n    return collisions",
  "    var ltoR: Array<Int> = []\n    var rtoL: Array<Int> = []\n    var t: Int =\
    \ 0\n    var collision: Int = 0\n    var index: Int = 0\n    while (ltoR.count\
    \ != n) {\n        var temp: Int = Int(arc4random_uniform(50))\n        if (!ltoR.contains(temp))\
    \ {\n            ltoR.append(temp)\n        }\n    }\n    while (rtoL.count !=\
    \ n) {\n        var temp: Int = Int(arc4random_uniform(50))\n        if (!rtoL.contains(temp))\
    \ {\n            rtoL.append(temp)\n        }\n    }\n    ltoR.sortInPlace()\n\
    \    rtoL.sortInPlace()\n    while (t < ltoR[n-1]) {\n        while (index < n\
    \ && ltoR[index] == t) {\n            if (rtoL.contains(t)) {\n              \
    \  collision += 1\n            }\n            index += 1\n        }\n        t\
    \ += 1\n    }\n    return collision", '    return n * (n - 1) / 2', "    var collisions\
    \ = 0\n    /// The loop tracks the number of cars moving left to right.\n    ///\
    \ Each pass through the loop corresponds to a new car moving left to right.\n\
    \    for i in 0..<n {\n        collisions += i\n    }\n    return collisions",
  '    return n + n - 1', "    let sortedR = [Int](1...n).sorted { x, y in x > y }\n\
    \    let sortedL = [Int](1...n).sorted { x, y in x < y }\n    var lIndex = 0\n\
    \    var rIndex = 0\n    var collisions = 0\n    while lIndex < n && rIndex <\
    \ n {\n        if sortedL[lIndex] < sortedR[rIndex] {\n            collisions\
    \ += n - rIndex\n            lIndex += 1\n        } else {\n            rIndex\
    \ += 1\n        }\n    }\n    return collisions", "    // YOUR CODE GOES HERE\n\
    \    var numCollision = 0\n    var iter = 0\n    while iter < n {\n        var\
    \ temp = iter\n        iter += 1\n        while temp < n {\n            numCollision\
    \ += 1\n            temp += 1\n        }\n    }\n    return numCollision", " \
    \   var left_cars = Array(0..<n)\n    var right_cars = Array(0..<n)\n    var collisions\
    \ = 0\n    while !right_cars.isEmpty {\n        let left_car = left_cars.removeFirst()\n\
    \        let right_car = right_cars.removeFirst()\n        if left_car == right_car\
    \ {\n            collisions += 1\n        } else {\n            left_cars.append(left_car)\n\
    \            right_cars.append(right_car)\n        }\n    }\n    return collisions",
  "    if n < 2 {\n        return 0\n    }\n    let half1 = n / 2\n    let half2 =\
    \ n - half1\n    return car_race_collision(n: half1) + car_race_collision(n: half2)\
    \ + half1 * half2", "    /// Assume cars are labeled 1 through n.\n    /// We\
    \ want to label the cars going left to right as 1..<n and the cars\n    /// going\
    \ right to left as n+1..<2n\n    /// We also want to label the cars with the same\
    \ label as their initial position\n    var cars_left_to_right = Array(1...n)\n\
    \    var cars_right_to_left = Array(n...2*n).reversed()\n    /// assert that the\
    \ two sets of cars have the same labels.\n    assert(cars_left_to_right == cars_right_to_left)\n\
    \    /// car_crossings[c] is a list of the cars at the same position as car c.\n\
    \    var car_crossings: [Int: [Int]] = [:]\n    /// add the crossings that are\
    \ already happening\n    for c in cars_left_to_right {\n        car_crossings[c]\
    \ = [c]\n    }\n    /// determine the collisions by looking at the crossings\n\
    \    var collisions = 0\n    for c in cars_left_to_right {\n        /// the cars\
    \ that are at the same position as car c\n        let cars_crossing = car_crossings[c]!\n\
    \        /// assert that car c is in this list\n        assert(cars_crossing.contains(c))\n\
    \        /// car c is going left to right\n        let cars_left_to_right_crossing\
    \ = cars_crossing.filter{$0 <= n}\n        /// car c is going right to left\n\
    \        let cars_right_to_left_crossing = cars_crossing.filter{$0 > n}\n    \
    \    /// assert that the cars in the crossing are all the cars going left to right\
    \ and the cars going right to left\n        assert(cars_left_to_right_crossing\
    \ == cars_left_to_right_crossing)\n        assert(cars_right_to_left_crossing\
    \ == cars_right_to_left_crossing)\n        /// count the collisions\n        collisions\
    \ += cars_left_to_right_crossing.count * cars_right_to_left_crossing.count\n \
    \   }\n    return collisions", '    return 2 * n - 1', "    \n    /// Given an\
    \ array of n numbers, count the number of unique\n    /// pairs of numbers whose\
    \ sum is zero.\n    func count_zero_sum_pairs(num: [Int]) -> Int {\n        var\
    \ num = num\n        num.sort()\n        var z = 0\n        var i = 0\n      \
    \  var j = num.count - 1\n        while i < j {\n            let s = num[i] +\
    \ num[j]\n            if s == 0 {\n                z += 1\n                i +=\
    \ 1\n                j -= 1\n            } else if s < 0 {\n                i\
    \ += 1\n            } else {\n                j -= 1\n            }\n        }\n\
    \        return z\n    }\n    \n    return count_zero_sum_pairs(num: Array(0..<n)\
    \ + Array(-n..<0))", '    return n', "    \n    var left_to_right: [Int] = []\n\
    \    var right_to_left: [Int] = []\n    \n    for i in 0..<n {\n        left_to_right.append(i)\n\
    \        right_to_left.append(i)\n    }\n    \n    var count = 0\n    \n    while\
    \ !left_to_right.isEmpty && !right_to_left.isEmpty {\n        if left_to_right.first!\
    \ < right_to_left.first! {\n            left_to_right.removeFirst()\n        }\
    \ else if left_to_right.first! > right_to_left.first! {\n            right_to_left.removeFirst()\n\
    \        } else {\n            count += 1\n            left_to_right.removeFirst()\n\
    \            right_to_left.removeFirst()\n        }\n    }\n    \n    return count",
  '  return 0', "    if n == 0 {\n        return 0\n    }\n    return 2 * n - 1",
  "    \n    var collision = 0\n    \n    let mid = n * n * 3\n    \n    var l = (0...mid).map\
    \ { _ in arc4random_uniform(UInt32(mid)) + UInt32(n) }\n    var r = (0...mid).map\
    \ { _ in arc4random_uniform(UInt32(mid)) + UInt32(n) }\n    \n    l.sort()\n \
    \   r.sort()\n    \n    print(l)\n    print(r)\n    \n    for i in 0..<n {\n \
    \       collision += n - (l[i] > r[i] ? i : i + 1)\n    }\n    \n    return collision",
  "    var right = [Int]()\n    var left = [Int]()\n    for i in 0..<n {\n       \
    \ right.append(i)\n        left.append(n+i)\n    }\n    var r = 0\n    var l =\
    \ n-1\n    var collisions = 0\n    while r <= l {\n        if right[r] > left[l]\
    \ {\n            collisions += 1\n            r += 1\n            l -= 1\n   \
    \     } else {\n            r += 1\n        }\n    }\n    return collisions",
  "    var left_to_right = [Int](1...n)\n    var right_to_left = [Int](1...n)\n  \
    \  var collisions = 0\n    while left_to_right.count > 0 && right_to_left.count\
    \ > 0 {\n        if left_to_right[0] == right_to_left[0] {\n            collisions\
    \ += 1\n            left_to_right.remove(at: 0)\n            right_to_left.remove(at:\
    \ 0)\n        } else if left_to_right[0] < right_to_left[0] {\n            left_to_right.remove(at:\
    \ 0)\n        } else {\n            right_to_left.remove(at: 0)\n        }\n \
    \   }\n    return collisions", "    var count = 0\n    for i in 0..<n {\n    \
    \    for j in (i+1)..<n {\n            count += 1\n        }\n    }\n    return\
    \ count", "    var coll = 0\n    for i in 0..<n {\n        for j in 0..<n {\n\
    \            if i<j {\n                coll += 1\n            }\n        }\n \
    \   }\n    return coll", "    var leftToRightCars: [Int] = []\n    var rightToLeftCars:\
    \ [Int] = []\n    var collisionCount = 0\n    \n    // Creates n cars which start\
    \ at different positions\n    for i in 1...n {\n        leftToRightCars.append(i)\n\
    \        rightToLeftCars.append(2*n - i)\n    }\n    \n    var leftCar = 0\n \
    \   var rightCar = 0\n    \n    // Cars drives at the same speed\n    while leftCar\
    \ < n && rightCar < n {\n        // There is a collision\n        if leftToRightCars[leftCar]\
    \ == rightToLeftCars[rightCar] {\n            collisionCount += 1\n          \
    \  leftCar += 1\n            rightCar += 1\n        }\n        // If left car\
    \ is faster\n        else if leftToRightCars[leftCar] < rightToLeftCars[rightCar]\
    \ {\n            leftCar += 1\n        }\n        // If right car is faster\n\
    \        else {\n            rightCar += 1\n        }\n    }\n    \n    return\
    \ collisionCount", '    return 0', "    var car_direction: [Int] = [Int](repeating:\
    \ 0, count: n * 2)\n    var car_index: [Int] = [Int](repeating: 0, count: n *\
    \ 2)\n    for i in 0..<n {\n        car_direction[i] = 1\n        car_index[i]\
    \ = i\n    }\n    for i in n..<n * 2 {\n        car_direction[i] = -1\n      \
    \  car_index[i] = i\n    }\n    //print(car_direction)\n    //print(car_index)\n\
    \    return merge_sort_count(arr: &car_index, low: 0, high: n * 2 - 1, direction:\
    \ &car_direction)", "    var collision = 0\n    var left_cars = [Int]()\n    var\
    \ right_cars = [Int]()\n    for i in 1...n {\n        left_cars.append(i)\n  \
    \      right_cars.append(n + i)\n    }\n    for l in left_cars {\n        for\
    \ r in right_cars {\n            if l == r {\n                collision += 1\n\
    \            }\n        }\n    }\n    return collision", "    // first we will\
    \ model the infinite line as a finite line of length n\n    // we will make all\
    \ the cars driving right to left to appear on the negative line,\n    // and make\
    \ all the cars driving left to right to appear on the positive line.\n    var\
    \ freq = Array(repeating: 0, count: n)\n    // freq[i] will store the frequency\
    \ of the number i in the array.\n    for i in 0..<n {\n        freq[n - i - 1]\
    \ += 1\n        freq[i] += 1\n    }\n    var res = 0\n    for f in freq {\n  \
    \      res += f * (f - 1) / 2\n    }\n    return res", '    return 0', "    guard\
    \ n > 0 else {\n        return 0\n    }\n    var set = Set<Int>()\n    for i in\
    \ 1...n {\n        set.insert(i)\n    }\n    return car_race_collision(n: n, pos:\
    \ 1, set: set)", "    var count = 0\n    let s: Set<Int> = Set(1...n)\n    for\
    \ x in s {\n        let y = n+1-x\n        if s.contains(y) {\n            count\
    \ += 1\n        }\n    }\n    return count", "    var n1 = 0\n    var n2 = n-1\n\
    \    var result = 0\n    while n1 < n {\n        if n1 == n2 {\n            result\
    \ += 1\n        } else if n1 > n2 {\n            result += 2\n        }\n    \
    \    n1 += 1\n        n2 -= 1\n    }\n    return result", "    \n    var car_queue\
    \ = Queue<Int>()\n    for car in 1...n {\n        car_queue.enqueue(car)\n   \
    \ }\n    \n    var collision_count = 0\n    var car_buffer = Array<Int>()\n  \
    \  \n    while !car_queue.isEmpty() {\n        let dequeued_car = car_queue.dequeue()!\n\
    \        car_buffer.append(dequeued_car)\n        \n        while !car_buffer.isEmpty()\
    \ {\n            if car_buffer.first! == dequeued_car {\n                car_buffer.removeFirst()\n\
    \            } else {\n                collision_count += 1\n                car_buffer.removeFirst()\n\
    \            }\n        }\n    }\n    \n    return collision_count", "    var\
    \ num_collisions = 0\n    for i in 0..<n {\n        for j in (i+1)..<n {\n   \
    \         num_collisions += 1\n        }\n    }\n    return num_collisions", " \
    \   // TODO: implement me\n    return 0", '    return n * (n - 1)', "    var cars\
    \ = Array(repeating: Array(repeating: 0, count: n), count: n)\n    var x = 0\n\
    \    var y = 0\n    var dirX = 1\n    var dirY = 1\n    var total = 0\n    while\
    \ (x >= 0 && x < n && y >= 0 && y < n) {\n        if cars[x][y] != 0 {\n     \
    \       total += 1\n        }\n        cars[x][y] += 1\n        x += dirX\n  \
    \      y += dirY\n        if x == n - 1 {\n            dirX = -1\n        }\n\
    \        if x == 0 {\n            dirX = 1\n        }\n        if y == n - 1 {\n\
    \            dirY = -1\n        }\n        if y == 0 {\n            dirY = 1\n\
    \        }\n    }\n    return total", "    var leftToRight: [Bool] = Array(repeating:\
    \ true, count: n)\n    var rightToLeft: [Bool] = Array(repeating: false, count:\
    \ n)\n    var i = 0\n    var collision = 0\n    while i < n {\n        leftToRight[i]\
    \ = true\n        rightToLeft[i] = false\n        if leftToRight[i] == rightToLeft[i]\
    \ {\n            collision += 1\n        }\n        i += 1\n    }\n    return\
    \ collision", "    // your code here\n    var amount = 0\n    for x in 1...n {\n\
    \        for y in 1...n {\n            if (x < y) {\n                amount +=\
    \ 1\n            }\n        }\n    }\n    return amount", "    \n    return 0",
  "    if n <= 1 {\n        return 0\n    }\n    var right_to_left = [(Int, Int)]()\n\
    \    var left_to_right = [(Int, Int)]()\n    for i in 0..<n {\n        right_to_left.append((n\
    \ - i, n + i))\n        left_to_right.append((i, n - i))\n    }\n    let rtl_sorted\
    \ = right_to_left.sorted { (t1, t2) -> Bool in\n        t1.0 < t2.0\n    }\n \
    \   let ltr_sorted = left_to_right.sorted { (t1, t2) -> Bool in\n        t1.0\
    \ < t2.0\n    }\n    var p1 = 0\n    var p2 = 0\n    var result = 0\n    while\
    \ p1 < n && p2 < n {\n        if rtl_sorted[p1].0 < ltr_sorted[p2].0 {\n     \
    \       p1 += 1\n        } else if rtl_sorted[p1].0 > ltr_sorted[p2].0 {\n   \
    \         p2 += 1\n        } else {\n            p1 += 1\n            p2 += 1\n\
    \            result += 1\n        }\n    }\n    return result", "    var count\
    \ = 0\n    var left = Set<Int>()\n    var right = Set<Int>()\n    for i in 0..<n\
    \ {\n        left.insert(i)\n        right.insert(i)\n    }\n    while !left.isEmpty\
    \ {\n        let c = left.removeFirst()\n        if right.contains(c) {\n    \
    \        count += 1\n            right.remove(c)\n        }\n    }\n    return\
    \ count", "    var left_to_right_driving_cars: [Double] = []\n    var right_to_left_driving_cars:\
    \ [Double] = []\n    for _ in 0..<n {\n        left_to_right_driving_cars.append(Double.random(in:\
    \ 0...1000))\n        right_to_left_driving_cars.append(Double.random(in: 0...1000))\n\
    \    }\n    left_to_right_driving_cars.sort()\n    right_to_left_driving_cars.sort()\n\
    \    var num_collisions = 0\n    var i = 0\n    var j = 0\n    var i_max = n\n\
    \    var j_max = n\n    while i < i_max && j < j_max {\n        let c1 = left_to_right_driving_cars[i]\n\
    \        let c2 = right_to_left_driving_cars[j]\n        if c1 > c2 {\n      \
    \      num_collisions += 1\n            j += 1\n            j_max -= 1\n     \
    \   } else {\n            i += 1\n            i_max -= 1\n        }\n    }\n \
    \   return num_collisions", '    return n * (n - 1) / 2', "    /// Two cars are\
    \ said to collide iff they are at the same position\n    /// at some point in\
    \ time; since they continue moving, they are at different\n    /// positions at\
    \ a different point in time.\n    /// Note, to ensure we don't count a collision\
    \ more than once,\n    /// it suffices to only consider one car moving left to\
    \ right in\n    /// a single collision.\n    /// Given a car moving left to right,\
    \ at time t, it is located at position t.\n    /// Given a car moving right to\
    \ left, at time t, it is located at position -t.\n    /// So, a collision happens\
    \ when the location of the left-to-right car equals\n    /// the location of the\
    \ right-to-left car.\n    /// In other words, a collision happens when t equals\
    \ -t, i.e., when t = 0.\n    /// This means that there is only one collision.\n\
    \    return 1", '    return n*(n-1)/2', '    return (n-1)*n/2', "    \n    if\
    \ n <= 1 {\n        return 0\n    }\n    \n    var i = 1\n    var collision =\
    \ 0\n    \n    while i <= n {\n        collision += i\n        i *= 2\n    }\n\
    \    \n    return collision", "    var s = 0\n    for i in 1...n {\n        for\
    \ j in 1...n {\n            if i % j == 0 && i / j > 1 {\n                s +=\
    \ 1\n            }\n        }\n    }\n    return s", "    var left: [Int] = []\n\
    \    var right: [Int] = []\n    var i = 0\n    var j = 0\n    var collision_count\
    \ = 0\n    while i < n && j < n {\n        if left[i] < right[j] {\n         \
    \   collision_count += j\n            i += 1\n        } else {\n            j\
    \ += 1\n        }\n    }\n    return collision_count", "    var left_to_right\
    \ = [Int](repeating: 0, count: n)\n    var right_to_left = [Int](repeating: 0,\
    \ count: n)\n    for i in 0..<n {\n        left_to_right[i] = i\n        right_to_left[i]\
    \ = n - i - 1\n    }\n    return 0", "    let m = n/2\n    return m + m * (m -\
    \ 1)", "    var count = 0\n    var cars = [Int](repeating: 0, count: n)\n    for\
    \ i in 0..<n {\n        for j in 0..<n {\n            if cars[i] == cars[j] {\n\
    \                count += 1\n            }\n        }\n        cars[i] += 1\n\
    \    }\n    return count", "  // FILL ME IN\n  return -1", "    let left_to_right_cars:\
    \ [Int] = [Int](repeating: 1, count: n)\n    let right_to_left_cars: [Int] = [Int](repeating:\
    \ -1, count: n)\n    var pos = 0\n    var collisions = 0\n    for (i, v) in left_to_right_cars.enumerated()\
    \ {\n        pos += v\n        if right_to_left_cars[i] < 0 && pos == 0 {\n  \
    \          collisions += 1\n        }\n    }\n    return collisions", "    var\
    \ left_to_right = [Int](repeating: 0, count: n)\n    var right_to_left = [Int](repeating:\
    \ 0, count: n)\n    for i in 0..<n {\n        left_to_right[i] = i\n        right_to_left[i]\
    \ = n - i - 1\n    }\n    let distance_to_start = abs(left_to_right[0] - right_to_left[0])\n\
    \    var collision_count = 0\n    while left_to_right.count > 0 && right_to_left.count\
    \ > 0 {\n        var i = 0\n        while i < left_to_right.count {\n        \
    \    let colliding_car = right_to_left[0]\n            if left_to_right[i] < colliding_car\
    \ {\n                // The left car crosses the line, meaning the right car is\
    \ behind the left car.\n                // No collision.\n                left_to_right.remove(at:\
    \ i)\n            } else if left_to_right[i] == colliding_car {\n            \
    \    collision_count += 1\n                // The left car crosses the line, meaning\
    \ the right car is behind the left car.\n                // No collision.\n  \
    \              left_to_right.remove(at: i)\n                right_to_left.remove(at:\
    \ 0)\n            } else {\n                // The right car crosses the line,\
    \ meaning the left car is behind the right car.\n                // No collision.\n\
    \                right_to_left.remove(at: 0)\n            }\n        }\n    }\n\
    \    return collision_count", "    // **** sort the cars left to right ****\n\
    \    //\n    // **** sort the cars right to left ****\n    //\n    // **** determine\
    \ the number of collisions ****\n    //\n    // **** return the number of collisions\
    \ ****\n    return 0", "    var curr = 0\n    var total = 0\n    while curr <\
    \ n {\n        total += curr\n        curr += 1\n    }\n    return total", " \
    \   var i = 1, j = n, count = 0\n    while i < j {\n        if i == j {\n    \
    \        return count\n        }\n        if i < j {\n            i += 1\n   \
    \         j -= 1\n            count += 1\n        }\n    }\n    return count",
  "    var cars_left_to_right: [Int] = []\n    var cars_right_to_left: [Int] = []\n\
    \    for i in 1...n {\n        cars_left_to_right.append(n - i)\n        cars_right_to_left.append(i)\n\
    \    }\n    var collide_count = 0\n    for i in 0..<n {\n        if cars_left_to_right[i]\
    \ == cars_right_to_left[i] {\n            collide_count += 1\n        }\n    }\n\
    \    return collide_count", "    // Still have to figure out a test case\n   \
    \ var cars = [Car]()\n    var cars_moving_left = [Car]()\n    var cars_moving_right\
    \ = [Car]()\n    var cars_colliding = [Car]()\n    var count = 0\n    \n    //\
    \ Create n cars moving left to right\n    for i in 1...n {\n        let car =\
    \ Car(distance: i, speed: 1, direction: 1)\n        cars.append(car)\n       \
    \ cars_moving_left.append(car)\n    }\n    \n    // Create n cars moving right\
    \ to left\n    for i in 1...n {\n        let car = Car(distance: i, speed: 1,\
    \ direction: -1)\n        cars.append(car)\n        cars_moving_right.append(car)\n\
    \    }\n    \n    // Cars are moving\n    for i in 1...50 {\n        print(\"\
    Time = \\(i)\")\n        for car in cars {\n            car.distance += car.speed\
    \ * car.direction\n            print(\"Car traveling \\(car.direction) at distance\
    \ \\(car.distance)\")\n        }\n        cars_colliding = cars_moving_left.filter\
    \ { cars_moving_right.contains($0) }\n        print(\"cars_colliding = \\(cars_colliding)\"\
    )\n        count += cars_colliding.count\n    }\n    \n    return count", '  return
    0', "    \n    var lcarIndex = n\n    var rcarIndex = n\n    var lcarArray = [Int](count:\
    \ n, repeatedValue: n-1)\n    var rcarArray = [Int](count: n, repeatedValue: n-1)\n\
    \    var collisionCounter = 0\n    \n    // Initialize the array with values of\
    \ the cars in opposite directions\n    for var index = n; index > 0; index-- {\n\
    \        lcarArray[index-1] = index-1\n        rcarArray[index-1] = index-1\n\
    \    }\n    \n    while (lcarIndex >= 0) && (rcarIndex >= 0) {\n        if lcarArray[lcarIndex]\
    \ == rcarArray[rcarIndex] {\n            collisionCounter++\n            lcarIndex--\n\
    \            rcarIndex--\n        } else if lcarArray[lcarIndex] > rcarArray[rcarIndex]\
    \ {\n            lcarIndex--\n        } else {\n            rcarIndex--\n    \
    \    }\n    }\n    \n    return collisionCounter", "    var cars_1 = Array(repeating:\
    \ 0, count: n)\n    var cars_2 = Array(repeating: n, count: n)\n    var cnt =\
    \ 0\n    for i in 0..<n {\n        cars_1[i] = i\n        cars_2[i] = n - i -\
    \ 1\n    }\n    for i in 0..<n {\n        for j in 0..<n {\n            if cars_1[i]\
    \ == cars_2[j] {\n                cnt += 1\n            }\n        }\n    }\n\
    \    return cnt", "    let cars = Array(0..<n)\n    let leftToRight: [Int] = cars.shuffled()\n\
    \    let rightToLeft: [Int] = cars.shuffled()\n    var count = 0\n    for i in\
    \ 0..<n {\n        if leftToRight[i] == rightToLeft[i] {\n            count +=\
    \ 1\n        }\n    }\n    return count", "    var left_to_right_cars = [Int](0..<n)\n\
    \    var right_to_left_cars = [Int](0..<n)\n    var num_collisions = 0\n    for\
    \ i in 0..<n {\n        for j in 0..<n {\n            let left_to_right_car =\
    \ left_to_right_cars[i]\n            let right_to_left_car = right_to_left_cars[j]\n\
    \            if left_to_right_car == right_to_left_car {\n                num_collisions\
    \ += 1\n            }\n        }\n    }\n    return num_collisions", "    var\
    \ dict: [Int: Int] = [:]\n    var res = 0\n    for i in 0..<n {\n        if let\
    \ val = dict[i + 1] {\n            res += val\n        }\n        dict[i + 1]\
    \ = dict[i + 1, default: 0] + 1\n    }\n    return res", "    let left = Array(1...n)\n\
    \    let right = Array(1...n).reversed()\n    var collisions = 0\n    var leftIdx\
    \ = 0\n    var rightIdx = 0\n    while leftIdx < left.count && rightIdx < right.count\
    \ {\n        if left[leftIdx] == right[rightIdx] {\n            collisions +=\
    \ 1\n            leftIdx += 1\n            rightIdx += 1\n        } else if left[leftIdx]\
    \ < right[rightIdx] {\n            leftIdx += 1\n        } else {\n          \
    \  rightIdx += 1\n        }\n    }\n    return collisions", "    var x: [Int]\
    \ = [Int](repeating: -1, count: n)\n    var y: [Int] = [Int](repeating: -1, count:\
    \ n)\n    for i in 0..<n {\n        x[i] = Int.random(in: 1...1000)\n        y[i]\
    \ = Int.random(in: 1...1000)\n    }\n    var len_x = n, len_y = n\n    while len_x\
    \ > 0 && len_y > 0 {\n        if x[len_x - 1] == y[len_y - 1] {\n            len_x\
    \ -= 1\n            len_y -= 1\n        } else if x[len_x - 1] > y[len_y - 1]\
    \ {\n            len_x -= 1\n        } else {\n            len_y -= 1\n      \
    \  }\n    }\n    return len_x + len_y", "    // (1) index is car number, value\
    \ is car's position\n    var lto_r = Array(repeating: 0, count: n) // 0..<n\n\
    \    var rto_l = Array(repeating: 0, count: n) // 0..<n\n    // (2) time starts\n\
    \    for t in 1...n {\n        // (3) pick a car number\n        for i in 0..<n\
    \ {\n            // (4) note the car's position\n            lto_r[i] = t\n  \
    \          rto_l[i] = n - t\n        }\n        // (5) check for collision\n \
    \       for i in 0..<n {\n            for j in 0..<n {\n                if lto_r[i]\
    \ == rto_l[j] {\n                    // collision\n                    print(\"\
    collision at time \\(t)\")\n                }\n            }\n        }\n    }\n\
    \    return 0", "    var count = 0\n    let queue = LinkedListQueue<Int>()\n \
    \   var car = 0\n    while car < n {\n        // the car entering the intersection\
    \ is either:\n        // - an out-going car, or\n        // - a in-coming car\
    \ that has not yet collided with any out-going car.\n        if (queue.isEmpty()\
    \ || car != queue.dequeue()!) {\n            queue.enqueue(car)\n        } else\
    \ {\n            count += 1\n        }\n        car += 1\n    }\n    return count",
  '    return -1;', "    let l2r = Array<Bool>(count: n, repeatedValue: true)\n  \
    \  let r2l = Array<Bool>(count: n, repeatedValue: false)\n    return resolve_collision(l2r\
    \ + r2l)", "    var collisions = 0\n    /// We use two one-dimensional arrays\
    \ to represent the cars driving left to right and\n    /// right to left.  Since\
    \ the cars are infinitely strong, we never need to remove\n    /// any car from\
    \ the array.\n    var cars_left_to_right: [Int] = []\n    var cars_right_to_left:\
    \ [Int] = []\n    /// cars_left_to_right is sorted in increasing order.  cars_right_to_left\
    \ is sorted\n    /// in decreasing order.\n    func insert_into_right_to_left(car:\
    \ Int) {\n        if cars_right_to_left.count == 0 {\n            cars_right_to_left.append(car)\n\
    \            return\n        }\n        /// We do binary search to find the place\
    \ where we need to insert the car.\n        var low = 0\n        var high = cars_right_to_left.count\
    \ - 1\n        while low <= high {\n            let mid = (low + high) / 2\n \
    \           if cars_right_to_left[mid] > car {\n                low = mid + 1\n\
    \            } else {\n                high = mid - 1\n            }\n       \
    \ }\n        cars_right_to_left.insert(car, at: low)\n    }\n    func insert_into_left_to_right(car:\
    \ Int) {\n        if cars_left_to_right.count == 0 {\n            cars_left_to_right.append(car)\n\
    \            return\n        }\n        /// We do binary search to find the place\
    \ where we need to insert the car.\n        var low = 0\n        var high = cars_left_to_right.count\
    \ - 1\n        while low <= high {\n            let mid = (low + high) / 2\n \
    \           if cars_left_to_right[mid] < car {\n                low = mid + 1\n\
    \            } else {\n                high = mid - 1\n            }\n       \
    \ }\n        cars_left_to_right.insert(car, at: low)\n    }\n    for i in 0..<n\
    \ {\n        insert_into_right_to_left(car: i)\n        insert_into_left_to_right(car:\
    \ n + i", "    // Placing cars in two arrays, one moving left to right, other\
    \ right to left\n    // Each car is represented by an integer in the array\n \
    \   // For example, array of size 4 [1, 2, 4, 7] means 4 cars\n    // Cars 1,\
    \ 2, 4, 7 are driving left to right\n    // Cars 8-n are driving right to left\n\
    \    var cars_left_to_right = [Int]()\n    var cars_right_to_left = [Int]()\n\
    \    for i in 1...n {\n        cars_left_to_right.append(i)\n        cars_right_to_left.append(n\
    \ + i)\n    }\n    \n    // For each car moving left to right, the car needs to\
    \ \"move\" a distance from the car in front of it\n    // For example, a car 2\
    \ needs to move 2 spots forward since car 1 is in front of it\n    // If the next\
    \ spot is occupied by a car in the opposite direction, there is a collision\n\
    \    // Once a collision is detected, replace the car in the current spot with\
    \ the car that collided with it\n    //\n    // Stop when the first car (car 1)\
    \ is at the end of the array\n    var collisions = 0\n    while cars_left_to_right[0]\
    \ != 1 {\n        var i = 1\n        while i < cars_left_to_right.count {\n  \
    \          let forward_distance = cars_left_to_right[i] - cars_left_to_right[i\
    \ - 1]\n            let next_index = i + forward_distance\n            if next_index\
    \ < cars_left_to_right.count {\n                if cars_left_to_right[next_index]\
    \ > n {\n                    collisions += 1\n                    cars_left_to_right[next_index]\
    \ = cars_left_to_right[i]\n                }\n            }\n            i +=\
    \ 1\n        }\n    }\n    return collisions", "    var cars: [[Int]] = Array(repeating:\
    \ [], count: n)\n    for i in 0..<n {\n        cars[i] = [Int.random(in: 0..<n),\
    \ 0]\n    }\n    for _ in 0..<n {\n        for i in 0..<n {\n            for j\
    \ in 0..<n {\n                if i != j && cars[i][0] == cars[j][0] {\n      \
    \              cars[i][1] += 1\n                    cars[j][1] += 1\n        \
    \        }\n            }\n        }\n        for i in 0..<n {\n            cars[i][0]\
    \ = (cars[i][0] + 1) % n\n        }\n    }\n    return cars.map({$0[1]}).reduce(0,\
    \ +)", "    var race = 0\n    for i in 0..<n {\n        race += i\n    }\n   \
    \ return race", '    return 0', "    \n    /// 0 <= n <= 100000\n    /// This\
    \ is a horrible upper bound on the number of input digits.\n    /// It's possible\
    \ to implement this with a fixed-length array.\n    /// (This was my first implementation.)\n\
    \    /// In practice, however, in production you have to treat your algorithms\
    \ as\n    /// \"black boxes\".  You can't predict what inputs you'll have.\n \
    \   /// So I'll implement this with a dictionary.\n    var left_to_right = [Int:Int]()\n\
    \    var right_to_left = [Int:Int]()\n    \n    /// 0 <= speed <= 1000000\n  \
    \  /// the maximum number of digits in the input integers\n    var a: [Int] =\
    \ [Int]()\n    /// the maximum number of digits in the input integers\n    var\
    \ b: [Int] = [Int]()\n    \n    for _ in 0..<n {\n        a.append(Int(readLine()!)!)\n\
    \    }\n    for _ in 0..<n {\n        b.append(Int(readLine()!)!)\n    }\n   \
    \ \n    /// first car starts at 0\n    /// second car starts at a[0]\n    left_to_right[0]\
    \ = a[0]\n    right_to_left[a[0]] = 0\n    \n    /// car starts at b[i]\n    ///\
    \ car moves at speed b[i]\n    /// car arrives at 0\n    /// car must collide\
    \ with another car\n    for i in 1..<n {\n        let next_start = left_to_right[0]!\
    \ + a[i]\n        left_to_right[0] = next_start\n        right_to_left[next_start]\
    \ = 0\n    }\n    \n    /// car starts at a[i]\n    /// car moves at speed a[i]\n\
    \    /// car arrives at b[i]\n    /// car must collide with another car\n    for\
    \ i in 1..<n {\n        let next_start = right_to_left[b[i]]! + a[i]\n       \
    \ right_to_left[b[i]] = next_start\n        left_to_right[next_start] = b[i]\n\
    \    }\n    \n    ///", "    var cars = [Int](repeating: 0, count: n)\n    for\
    \ i in 0..<n {\n        cars[i] = i\n    }\n    var already_collided = [Bool](repeating:\
    \ false, count: n)\n    var left_to_right_pos = 0\n    var right_to_left_pos =\
    \ n - 1\n    var collision_counter = 0\n    for _ in 0..<n {\n        if !already_collided[left_to_right_pos]\
    \ && !already_collided[right_to_left_pos] {\n            if left_to_right_pos\
    \ == right_to_left_pos {\n                collision_counter += 1\n           \
    \     already_collided[left_to_right_pos] = true\n            }\n        }\n \
    \       left_to_right_pos += 1\n        right_to_left_pos -= 1\n    }\n    return\
    \ collision_counter", "    let cars_1 = (0...n-1).map{_ in Int.random(in: 1...10)}\n\
    \    let cars_2 = (0...n-1).map{_ in Int.random(in: 1...10)}\n    print(\"Cars\
    \ 1 \", cars_1)\n    print(\"Cars 2 \", cars_2)\n    var collisions = 0\n    for\
    \ i in 0..<n {\n        let j = n - i - 1\n        if cars_1[i] < cars_2[j] {\n\
    \            collisions += 1\n        }\n    }\n    return collisions", "    var\
    \ left: [Int] = []\n    var right: [Int] = []\n    for index in 1...n {\n    \
    \    left.append(index)\n        right.append(n+1-index)\n    }\n    var count\
    \ = 0\n    while left.count > 0 && right.count > 0 {\n        if left[0] < right[0]\
    \ {\n            count += 1\n            left.remove(at: 0)\n            right.remove(at:\
    \ 0)\n        } else {\n            left.remove(at: 0)\n            right.remove(at:\
    \ 0)\n        }\n    }\n    return count", "    var left_to_right = [Int](repeating:\
    \ 0, count: n)\n    var right_to_left = [Int](repeating: 0, count: n)\n    var\
    \ collisions = 0\n    let min_collision_dist = 100\n    var current_dist = 1\n\
    \    var right_index = 0\n    var left_index = 0\n    while right_index < n &&\
    \ left_index < n {\n        right_to_left[right_index] = current_dist\n      \
    \  left_to_right[left_index] = current_dist\n        while right_index < n &&\
    \ right_to_left[right_index] <= current_dist {\n            right_index += 1\n\
    \        }\n        while left_index < n && left_to_right[left_index] <= current_dist\
    \ {\n            left_index += 1\n        }\n        if right_index >= n || left_index\
    \ >= n {\n            break\n        }\n        current_dist += 1\n        right_to_left[right_index]\
    \ = current_dist\n        left_to_right[left_index] = current_dist\n        while\
    \ right_index < n && right_to_left[right_index] <= current_dist {\n          \
    \  right_index += 1\n        }\n        while left_index < n && left_to_right[left_index]\
    \ <= current_dist {\n            left_index += 1\n        }\n        if right_index\
    \ >= n || left_index >= n {\n            break\n        }\n        current_dist\
    \ += 1\n        if left_to_right[left_index] < right_to_left[right_index] {\n\
    \            collisions += 1\n            current_dist = max(current_dist, right_to_left[right_index]\
    \ + min_collision_dist)\n        } else {\n            collisions += 1\n     \
    \       current_dist = max(current_dist, left_to_right[left_index] + min_collision_dist)\n\
    \        }\n    }\n    return collisions", "    if n <= 1 {\n        return 0\n\
    \    }\n    var result = 0\n    var i = 0\n    var j = n - 1\n    while i < j\
    \ {\n        result += (j - i)\n        i += 1\n        j -= 1\n    }\n    return\
    \ result", "    if n <= 1 {\n        return 0\n    }\n    var total = 0\n    for\
    \ i in 1...n {\n        total += i\n    }\n    return total", '    return n *
    (n - 1) / 2', "    // initialize variables\n    var collisions = 0\n    var left\
    \ = [Int](0...n-1)\n    var right = [Int](0...n-1)\n    // indices of cars moving\
    \ left to right\n    var left_i = 0\n    // indices of cars moving right to left\n\
    \    var right_i = n-1\n    // sort cars moving left to right in descending order\n\
    \    left.sort(by: >)\n    // sort cars moving right to left in ascending order\n\
    \    right.sort(by: <)\n    // all cars move at the same speed\n    // increment\
    \ left and right indices by 1\n    // until they reach the other side\n    while(left_i\
    \ < n && right_i >= 0) {\n        // if the right car is faster\n        // cars\
    \ on the right side will reach the end first\n        if(left[left_i] < right[right_i])\
    \ {\n            // both indices increment by 1\n            // 1 collision\n\
    \            collisions += 1\n            left_i += 1\n            right_i +=\
    \ 1\n        }\n        // else, cars on the left side will reach the end first\n\
    \        else {\n            // only left index increments by 1\n            left_i\
    \ += 1\n        }\n    }\n    return collisions", "    var collisions = 0\n  \
    \  let cars = Array(repeating: Array(repeating: false, count: 2*n), count: 2*n)\n\
    \    for i in 0..<2*n {\n        for j in 0..<2*n {\n            if i == j { continue\
    \ }\n            if cars[i][j] { continue }\n            cars[i][j] = true\n \
    \           collisions += 1\n        }\n    }\n    return collisions", "    var\
    \ b = 0;\n    var d = 0;\n    var a = n;\n    while(a > 0) {\n        b += a;\n\
    \        d += a;\n        a -= 1;\n    }\n    return (b * d) / 2;", "    var answer\
    \ = 0\n    for i in 0..<n {\n        for j in 0..<n {\n            // I can figure\
    \ out if cars i and j collide or not by\n            // looking at the value of\
    \ i-j.\n            // If i > j, then car i is moving right to left\n        \
    \    // and car j is moving left to right.\n            // If i < j, then car\
    \ i is moving left to right\n            // and car j is moving right to left.\n\
    \            // If i = j, then car i and car j are both moving\n            //\
    \ in the same direction and so do not collide.\n            if i-j != 0 {\n  \
    \              answer += 1\n            }\n        }\n    }\n    return answer",
  "    var coll = 0\n    var pos = [Int]()\n    var neg = [Int]()\n    for _ in 0..<n\
    \ {\n        pos.append(Int.random(in: 1...100))\n        neg.append(Int.random(in:\
    \ -100...(-1)))\n    }\n    pos.sort()\n    neg.sort()\n    var i = 0\n    var\
    \ j = 0\n    while i < n && j < n {\n        if pos[i] < (-neg[j]) {\n       \
    \     coll += j\n            i += 1\n        } else {\n            j += 1\n  \
    \      }\n    }\n    coll += (n - i) * j\n    return coll", "    var leftMoving\
    \ = [Int](0..<n)\n    var rightMoving = [Int](0..<n)\n    var collisionCount =\
    \ 0\n    // TODO: Implement.\n    return collisionCount", "    if n < 2 {\n  \
    \      return 0\n    }\n    var output = 0\n    for i in 1..<n {\n        output\
    \ += i\n    }\n    return output", "    if n == 0 {\n        return 0\n    }\n\
    \    var l2r: Int = 0\n    var r2l: Int = n - 1\n    var collisions: Int = 0\n\
    \    while l2r < r2l {\n        l2r += 1\n        r2l -= 1\n        collisions\
    \ += 1\n    }\n    return collisions", "    let left = Array(1...n)\n    let right\
    \ = Array(1...n).reversed()\n    var collisions = 0\n    for (_, (x, y)) in zip(left,\
    \ right).enumerated() {\n        if x > y {\n            collisions += 1\n   \
    \     }\n    }\n    return collisions", "  var number_of_collisions = 0\n  var\
    \ cars_moving_right_to_left = [Int]()\n  cars_moving_right_to_left.reserveCapacity(n)\n\
    \  for i in 0..<n {\n    cars_moving_right_to_left.append(i)\n  }\n  for i in\
    \ 0..<n {\n    for j in 0..<n {\n      if i == cars_moving_right_to_left[j] {\n\
    \        number_of_collisions += 1\n      }\n    }\n  }\n  return number_of_collisions",
  '  return n * (n - 1)', '    return 0', "    var cars: [Int] = []\n    var othrCars:\
    \ [Int] = []\n    var collisions = 0\n    var i = 0\n    while i < n {\n     \
    \   cars.append(i)\n        othrCars.append(i + n)\n        i += 1\n    }\n  \
    \  i = 0\n    var j = 0\n    while i < n {\n        while j < n {\n          \
    \  if cars[i] == othrCars[j] {\n                collisions += 1\n            }\n\
    \            j += 1\n        }\n        i += 1\n    }\n    return collisions",
  '    return 0', '    return n * (n - 1) / 2', "    var left = 0\n    var right =\
    \ 0\n    var result = 0\n    while left < n && right < n {\n        if left >=\
    \ right {\n            result += 1\n            right += 1\n        } else {\n\
    \            left += 1\n        }\n    }\n    return result", "    var arr1 =\
    \ Array(1...n)\n    var arr2 = Array(1...n)\n    arr1.reverse()\n    return compare(arr1,\
    \ arr2)", "    var left_to_right = [Int](repeating: 0, count: n)\n    var right_to_left\
    \ = [Int](repeating: 0, count: n)\n    var collision = 0\n    for i in 0..<n {\n\
    \        left_to_right[i] = i\n        right_to_left[i] = n - i - 1\n    }\n \
    \   for i in 0..<n {\n        for j in 0..<n {\n            if left_to_right[i]\
    \ > right_to_left[j] {\n                collision += 1\n            }\n      \
    \  }\n    }\n    return collision", "    let m = n / 2\n    var k = 0\n    for\
    \ i in 1...m {\n        k += i\n    }\n    return k", "  var i = 1\n  var j =\
    \ 1\n  var c = 0\n  while i <= n {\n    while j <= n {\n      if i == j {\n  \
    \      i += 1\n        j = 1\n        continue\n      }\n      if i < j {\n  \
    \      c += 1\n      }\n      j += 1\n    }\n    i += 1\n    j = 1\n  }\n  return\
    \ c", "    if n <= 0 {\n        return 0\n    }\n    var left_cars: [Int] = []\n\
    \    var right_cars: [Int] = []\n    for index in 0..<n {\n        left_cars.append(index)\n\
    \        right_cars.append(n - index - 1)\n    }\n    var collisions = 0\n   \
    \ var i = 0\n    var j = 0\n    while i < n && j < n {\n        if left_cars[i]\
    \ < right_cars[j] {\n            collisions += j\n            i += 1\n       \
    \ } else {\n            j += 1\n        }\n    }\n    collisions += j * (n - i)\n\
    \    return collisions", '    return 0', "    return collision_count(cars: (0..<n).map\
    \ { (i: Int) -> Car in .leftToRight(position: i) }\n        + (0..<n).map { (i:\
    \ Int) -> Car in .rightToLeft(position: i) })", '    return n * (n-1)', "    \n\
    \    var count = 0\n    var left: [Bool] = Array(repeating: true, count: n)\n\
    \    var right: [Bool] = Array(repeating: true, count: n)\n    \n    for _ in\
    \ 0...100 {\n        let l = Int.random(in: 0..<n)\n        let r = Int.random(in:\
    \ 0..<n)\n        \n        if left[l] && right[r] {\n            count += 1\n\
    \            left[l] = false\n            right[r] = false\n        }\n    }\n\
    \    \n    return count", "    var left_to_right = Array(0..<n)\n    var right_to_left\
    \ = Array(0..<n)\n    left_to_right.sortInPlace {\n        $0 > $1\n    }\n  \
    \  right_to_left.sortInPlace {\n        $0 < $1\n    }\n    var count = 0\n  \
    \  var i = 0\n    var j = 0\n    while i < n && j < n {\n        if left_to_right[i]\
    \ > right_to_left[j] {\n            count += 1\n            i += 1\n         \
    \   j += 1\n        } else {\n            i += 1\n        }\n    }\n    return\
    \ count", "    var result = 0\n    for i in 1...n {\n        result += (i-1) *\
    \ i\n    }\n    return result", "    let left_to_right_cars = Array(0..<n)\n \
    \   let right_to_left_cars = Array(0..<n).reversed()\n    var count = 0\n    for\
    \ i in 0..<n {\n        for j in 0..<n {\n            if left_to_right_cars[i]\
    \ == right_to_left_cars[j] {\n                count += 1\n            }\n    \
    \    }\n    }\n    return count", "    var rr = [Int](repeating: 0, count: n)\n\
    \    var ll = [Int](repeating: 0, count: n)\n    for i in 0..<n {\n        rr[i]\
    \ = i\n        ll[i] = n + i\n    }\n    var coll = 0\n    for i in 0..<n {\n\
    \        for j in 0..<n {\n            if rr[i] == ll[j] {\n                coll\
    \ += 1\n            }\n        }\n    }\n    return coll", "    var dict = [Int:\
    \ Int]()\n    var collisions = 0\n    for i in 0..<n {\n        dict[i] = i\n\
    \    }\n    for i in 0..<n {\n        if let value = dict[i] {\n            collisions\
    \ += value\n        }\n    }\n    for i in 0..<n {\n        if let value = dict[i]\
    \ {\n            collisions += value\n        }\n    }\n    return collisions",
  "    var right_to_left = Array(1...n)\n    var left_to_right = Array(1...n)\n  \
    \  var collision_count = 0\n    while right_to_left.count > 0 && left_to_right.count\
    \ > 0 {\n        let right = right_to_left.first!\n        let left = left_to_right.first!\n\
    \        if right < left {\n            right_to_left.removeFirst()\n        }\
    \ else if left < right {\n            left_to_right.removeFirst()\n        } else\
    \ {\n            collision_count += 1\n            right_to_left.removeFirst()\n\
    \            left_to_right.removeFirst()\n        }\n    }\n    return collision_count",
  "    //there is no such thing as a collision for n < 2\n    guard n > 1 else { return\
    \ 0 }\n    \n    //there are always n-1 collisions for even n\n    if n % 2 ==\
    \ 0 { return n - 1 }\n    \n    //there are always n collisions for odd n\n  \
    \  return n", '    return 0', "    // Assume that n is a positive integer\n  \
    \  if n <= 0 {\n        return 0\n    }\n    // Save the current position of each\
    \ car\n    var left_cars = Array(repeating: 0, count: n)\n    var right_cars =\
    \ Array(repeating: 0, count: n)\n    // Create a counter for the number of collisions\n\
    \    var collision_counter = 0\n    // For each car on the left\n    for i in\
    \ 0..<n {\n        // Move the car one step\n        left_cars[i] += 1\n     \
    \   // If the car has collided with any car on the right,\n        // remove the\
    \ car on the right from the list of cars that\n        // are still on the road\
    \ and increment the collision counter\n        for j in (0..<right_cars.count).reversed()\
    \ {\n            if left_cars[i] >= right_cars[j] {\n                right_cars.remove(at:\
    \ j)\n                collision_counter += 1\n            }\n        }\n    }\n\
    \    // Return the number of collisions\n    return collision_counter", '    return
    Int(floor(sqrt(pow(Double(n), 2) * 2)))', "    var leftToRight = [Int](repeating:\
    \ 0, count: n)\n    var rightToLeft = [Int](repeating: 0, count: n)\n    for i\
    \ in 0..<n {\n        leftToRight[i] = i\n        rightToLeft[i] = n-i-1\n   \
    \ }\n    var result = 0\n    var i = 0\n    var j = 0\n    while (i < n && j <\
    \ n) {\n        if (leftToRight[i] < rightToLeft[j]) {\n            i += 1\n \
    \       } else if (leftToRight[i] > rightToLeft[j]) {\n            j += 1\n  \
    \      } else {\n            result += 1\n            i += 1\n            j +=\
    \ 1\n        }\n    }\n    return result", '    return n * (n - 1) / 2', "   \
    \ var left_to_right_queue = PriorityQueue<Int>()\n    var right_to_left_queue\
    \ = PriorityQueue<Int>()\n    for i in 0..<n {\n        left_to_right_queue.insert(i)\n\
    \        right_to_left_queue.insert(i)\n    }\n    var result = 0\n    while !left_to_right_queue.isEmpty\
    \ && !right_to_left_queue.isEmpty {\n        let left_to_right_car = left_to_right_queue.deleteMin()\n\
    \        let right_to_left_car = right_to_left_queue.deleteMin()\n        if left_to_right_car\
    \ == right_to_left_car {\n            result += 1\n        }\n    }\n    return\
    \ result", "    // car[i] gives the time it takes car i to reach the middle point\
    \ of the road\n    var car = [Int](repeating: 0, count: n)\n    // leftcar[i]\
    \ gives the index of the leftmost car that collides with the car\n    // moving\
    \ right to left that finishes i-th.\n    var leftcar = [Int](repeating: 0, count:\
    \ n)\n    // rightcar[i] gives the index of the rightmost car that collides with\
    \ the car\n    // moving left to right that finishes i-th.\n    var rightcar =\
    \ [Int](repeating: 0, count: n)\n    for i in 0..<n {\n        car[i] = Int(arc4random())\
    \ % n + 1\n    }\n    // sort the cars by their arrival time in the middle\n \
    \   car.sort()\n    // Go through the cars,  and determine which other cars they\
    \ collide with\n    for i in 0..<n {\n        var left = 0\n        var right\
    \ = n - 1\n        while right > left {\n            let mid = (left + right)\
    \ / 2\n            if car[mid] > car[i] {\n                right = mid - 1\n \
    \           } else {\n                left = mid + 1\n            }\n        }\n\
    \        leftcar[i] = left\n        rightcar[n - i - 1] = n - right - 1\n    }\n\
    \    // count the total number of collisions\n    var result = 0\n    for i in\
    \ 0..<n {\n        // for each car (i), count how many collisions the car has\
    \ on the left\n        var left = leftcar[i]\n        // for each car (n-i-1),\
    \ count how many collisions the car has on the right\n        var right = rightcar[n\
    \ - i - 1]\n        // the collisions of a car on the left and the collisions\
    \ of the same car on the right\n        // all count as the same collision, so\
    \ we need to subtract 1 to avoid double counting\n        // this is the step\
    \ where we get the actual result\n        result += left + right - 1\n    }\n\
    \    return result", "    \n    var left: [Int] = Array(0...n-1)\n    var right:\
    \ [Int] = Array(0...n-1)\n    right.reverse()\n    \n    var collision: Int =\
    \ 0\n    \n    for i in 0...n-1 {\n        for j in 0...n-1 {\n            if\
    \ left[i] == right[j] {\n                collision += 1\n            }\n     \
    \   }\n    }\n    \n    return collision", '    return 3', "    var cars_left_to_right:\
    \ [Car] = []\n    var cars_right_to_left: [Car] = []\n    var collisions = 0\n\
    \    \n    for _ in 0..<n {\n        let car_left_to_right = Car(position: 0,\
    \ velocity: 1)\n        let car_right_to_left = Car(position: 0, velocity: -1)\n\
    \        cars_left_to_right.append(car_left_to_right)\n        cars_right_to_left.append(car_right_to_left)\n\
    \    }\n    \n    var current_time = 0\n    while (cars_left_to_right.count >\
    \ 0 && cars_right_to_left.count > 0) {\n        let left_to_right_car = cars_left_to_right.removeFirst()\n\
    \        let right_to_left_car = cars_right_to_left.removeFirst()\n        \n\
    \        // Give both cars enough time to get to the same position\n        current_time\
    \ += abs(left_to_right_car.position - right_to_left_car.position)\n        \n\
    \        if (left_to_right_car.position == right_to_left_car.position) {\n   \
    \         // The cars have collided, but they continue moving in their respective\n\
    \            // trajectory as if they didn't collide.\n            collisions\
    \ += 1\n        }\n        \n        // The cars have not collided.  Let them\
    \ move a little bit more.\n        left_to_right_car.position += left_to_right_car.velocity\n\
    \        right_to_left_car.position += right_to_left_car.velocity\n        \n\
    \        cars_left_to_right.append(left_to_right_car)\n        cars_right_to_left.append(right_to_left_car)\n\
    \    }\n    \n    return collisions", "    var c1 = [Int](repeating: 0, count:\
    \ n)\n    var c2 = [Int](repeating: 0, count: n)\n    for (i, _) in c1.enumerated()\
    \ {\n        c1[i] = i + 1\n    }\n    for (i, _) in c2.enumerated() {\n     \
    \   c2[i] = n - i\n    }\n    var pos = 0\n    var step = 2\n    var count = 0\n\
    \    while pos < n {\n        if c1[pos] == c2[pos] {\n            count += 1\n\
    \        }\n        if pos + step >= n {\n            step = 1\n        }\n  \
    \      pos += step\n    }\n    return count", '  return n * (n - 1) / 2;', " \
    \   var n = n\n    if n < 2 {\n        return 0\n    }\n    var i = 0\n    var\
    \ j = n - 1\n    var cars = Array(repeating: 1, count: n)\n    var num = 0\n \
    \   while i < j {\n        if cars[i] + cars[j] == 2 {\n            num += 1\n\
    \            cars[i] = 0\n            cars[j] = 0\n            i += 1\n      \
    \      j -= 1\n        } else if cars[i] + cars[j] == 0 {\n            i += 1\n\
    \            j -= 1\n        } else if cars[i] == 1 {\n            i += 1\n  \
    \      } else {\n            j -= 1\n        }\n    }\n    return num", "    var\
    \ (c1, c2) = ([Int](), [Int]())\n    for i in 0...n {\n        c1.append(n - i)\n\
    \        c2.append(i)\n    }\n    return merge(c1, c2, n)", "    var left_to_right_cars:\
    \ [Int] = []\n    var right_to_left_cars: [Int] = []\n    for i in 0..<n {\n \
    \       left_to_right_cars.append(i)\n        right_to_left_cars.append(n - i\
    \ - 1)\n    }\n    var num_collisions = 0\n    var done = false\n    var i = 0\n\
    \    var j = 0\n    while !done {\n        if left_to_right_cars[i] < right_to_left_cars[j]\
    \ {\n            num_collisions += 1\n            j += 1\n        } else {\n \
    \           i += 1\n        }\n        if i == n || j == n {\n            done\
    \ = true\n        }\n    }\n    return num_collisions", "    var carLeft = 0\n\
    \    var carRight = n-1\n    var collisions = 0\n    while carLeft < carRight\
    \ {\n        if carLeft == carRight {\n            collisions += 1\n        }\n\
    \        carLeft += 1\n        carRight -= 1\n    }\n    return collisions", " \
    \   var result = 0\n    var right_to_left = Array(repeating: 0, count: n)\n  \
    \  var left_to_right = Array(repeating: 0, count: n)\n    for i in 0..<n {\n \
    \       left_to_right[i] = i\n        right_to_left[i] = i\n    }\n    for i in\
    \ 0..<n {\n        for j in 0..<n {\n            if left_to_right[i] < right_to_left[j]\
    \ {\n                result += 1\n            }\n        }\n    }\n    return\
    \ result", "    \n    var cars1 = (0..<n).map { Car(pos: $0, dir: .left) }\n \
    \   var cars2 = (0..<n).map { Car(pos: $0, dir: .right) }\n    \n    var count\
    \ = 0\n    \n    while cars1.count > 0 && cars2.count > 0 {\n        var c1 =\
    \ cars1.removeFirst()\n        var c2 = cars2.removeFirst()\n        \n      \
    \  if c1.is_colliding(with: c2) {\n            count += 1\n            cars1.append(c1)\n\
    \            cars2.append(c2)\n        } else {\n            cars1.append(c1)\n\
    \            cars2.append(c2)\n        }\n    }\n    \n    return count", "  \
    \  let cars : [Car] = (0..<n).map{ Car(pos: Double($0)) }\n    let cars2 : [Car]\
    \ = (0..<n).map{ Car(pos: Double($0)) }\n    var collisions = 0\n    for i in\
    \ 0..<cars.count {\n        for j in i..<cars2.count {\n            let c1 = cars[i]\n\
    \            let c2 = cars2[j]\n            if c1.compare(c2) == .orderedAscending\
    \ {\n                collisions += 1\n            }\n        }\n    }\n    return\
    \ collisions", "    var left_to_right = [Int]()\n    var right_to_left = [Int]()\n\
    \    var i = 1\n    while i <= n {\n        left_to_right.append(i)\n        right_to_left.append(n\
    \ - i + 1)\n        i += 1\n    }\n    var collisions = 0\n    var l = 0\n   \
    \ var r = n - 1\n    while l < n && r >= 0 {\n        if left_to_right[l] > right_to_left[r]\
    \ {\n            collisions += 1\n            l += 1\n            r -= 1\n   \
    \     } else {\n            break\n        }\n    }\n    return collisions"]
stop_tokens:
- "\n}"
