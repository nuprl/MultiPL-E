name: HumanEval_21_rescale_to_unit
language: swift
prompt: "\n/// Given array of numbers (of at least two elements), apply a linear transform\
  \ to that array,\n/// such that the smallest number will become 0 and the largest\
  \ will become 1\n/// >>> rescale_to_unit(numbers: [1.0, 2.0, 3.0, 4.0, 5.0])\n///\
  \ [0.0, 0.25, 0.5, 0.75, 1.0]\nfunc rescale_to_unit(numbers: [Double]) -> [Double]\
  \ {\n"
tests: "}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if\
  \ left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left,\
  \ right) {\n        if l != r {\n            return false\n        }\n    }\n  \
  \  return true\n}\n            \nassert(rescale_to_unit(numbers: [2.0, 49.9]) ==\
  \ [0.0, 1.0])\nassert(rescale_to_unit(numbers: [100.0, 49.9]) == [1.0, 0.0])\nassert(rescale_to_unit(numbers:\
  \ [1.0, 2.0, 3.0, 4.0, 5.0]) == [0.0, 0.25, 0.5, 0.75, 1.0])\nassert(rescale_to_unit(numbers:\
  \ [2.0, 1.0, 5.0, 3.0, 4.0]) == [0.25, 0.0, 1.0, 0.5, 0.75])\nassert(rescale_to_unit(numbers:\
  \ [12.0, 11.0, 15.0, 13.0, 14.0]) == [0.25, 0.0, 1.0, 0.5, 0.75])"
completions: ["    guard numbers.count > 1 else {\n        return numbers\n    }\n\
    \    let minimum = numbers.min()!\n    let maximum = numbers.max()!\n    return\
    \ numbers.map { (x: Double) -> Double in\n        return (x - minimum) / (maximum\
    \ - minimum)\n    }", "    var numerators = numbers.map { $0 - numbers.min()!\
    \ }\n    let denominator = numbers.max()! - numbers.min()!\n    return numerators.map\
    \ { $0 / denominator }", "  let min_x = numbers.min()!\n  let max_x = numbers.max()!\n\
    \  let scale = 1.0 / (max_x - min_x)\n  let result = numbers.map { (x: Double)\
    \ -> Double in\n    return (x - min_x) * scale\n  }\n  return result", "    var\
    \ rescaled: [Double] = []\n    let min_value = numbers.min()!\n    let max_value\
    \ = numbers.max()!\n    for number in numbers {\n        rescaled.append((number\
    \ - min_value) / (max_value - min_value))\n    }\n    return rescaled", "    guard\
    \ numbers.count > 1 else { return numbers }\n    let min = numbers.min()!\n  \
    \  let max = numbers.max()!\n    return numbers.map {($0 - min) / (max - min)}",
  "    let min = numbers.min()!\n    let max = numbers.max()!\n    let diff = max\
    \ - min\n    let rescaled = numbers.map { ($0 - min) / diff }\n    return rescaled",
  "    guard numbers.count > 1 else { return numbers }\n    let min = numbers.min()!\n\
    \    let max = numbers.max()!\n    guard min != max else { return numbers }\n\n\
    \    return numbers.map { (number) -> Double in\n        return (number - min)\
    \ / (max - min)\n    }", "    \n    // If the array has 0 or 1 elements, there\
    \ is nothing to rescale\n    if numbers.count < 2 {\n        return numbers\n\
    \    }\n    \n    // Get the minimum and maximum value from the array\n    let\
    \ min_val = numbers.min()!\n    let max_val = numbers.max()!\n    \n    // Return\
    \ the original array, with each element rescaled to be between 0 and 1\n    return\
    \ numbers.map { (($0 - min_val) / (max_val - min_val)) }", "    guard numbers.count\
    \ > 1 else {\n        return numbers\n    }\n    let min_val = numbers.min()!\n\
    \    let max_val = numbers.max()!\n    let diff = max_val - min_val\n    return\
    \ numbers.map({ ($0 - min_val) / diff })", "    let min = numbers.min()!\n   \
    \ let max = numbers.max()!\n    let factor = 1.0 / (max - min)\n    return numbers.map\
    \ { (factor * ($0 - min)) }", "    let smallest = numbers.min()!\n    let largest\
    \ = numbers.max()!\n    let delta = largest - smallest\n    return numbers.map\
    \ { ($0 - smallest) / delta }", "    let min = numbers.min()!\n    let max = numbers.max()!\n\
    \    let scale = max - min\n    return numbers.map { ($0 - min) / scale }", " \
    \   let min_value = numbers.min()!\n    let max_value = numbers.max()!\n    let\
    \ scalar = 1.0 / (max_value - min_value)\n    return numbers.map { (n: Double)\
    \ -> Double in\n        (n - min_value) * scalar\n    }", "    let min = numbers.min()!\n\
    \    let max = numbers.max()!\n    let diff = max - min\n    return numbers.map\
    \ { ($0 - min) / diff }", "    var result = [Double]()\n    let step = 1.0 / Double(numbers.count\
    \ - 1)\n    for (i, x) in numbers.enumerated() {\n        result.append(step *\
    \ Double(i))\n    }\n    return result", "    let min = numbers.min()!\n    let\
    \ max = numbers.max()!\n    let factor = 1.0 / (max - min)\n    return numbers.map\
    \ { (number) -> Double in\n        return (number - min) * factor\n    }", " \
    \   let (min_value, max_value) = get_min_max(numbers: numbers)\n    var result\
    \ = numbers\n    result = result.map({ (value) -> Double in\n        return (value\
    \ - min_value) / (max_value - min_value)\n    })\n    return result", "    precondition(numbers.count\
    \ > 1)\n    var min: Double = numbers[0]\n    var max: Double = numbers[0]\n \
    \   for number in numbers {\n        if number < min {\n            min = number\n\
    \        }\n        if number > max {\n            max = number\n        }\n \
    \   }\n    let denominator = max - min\n    return numbers.map { (number) -> Double\
    \ in\n        return (number - min) / denominator\n    }", "    let minimum =\
    \ numbers.min()!\n    let maximum = numbers.max()!\n    return numbers.map({($0\
    \ - minimum) / (maximum - minimum)})", "    assert(numbers.count > 1)\n    let\
    \ smallest = numbers.min()!\n    let largest = numbers.max()!\n    let diff =\
    \ largest - smallest\n    return numbers.map { (x: Double) -> Double in\n    \
    \    return (x - smallest) / diff\n    }", "    if numbers.count < 2 {\n     \
    \   fatalError(\"rescale_to_unit can not be applied to array of less than 2 elements.\"\
    )\n    }\n    let min = numbers.min()!\n    let max = numbers.max()!\n    let\
    \ delta = max - min\n    return numbers.map { ($0 - min) / delta }", "    var\
    \ m = Double.greatestFiniteMagnitude\n    var M = Double.leastNormalMagnitude\n\
    \    for number in numbers {\n        if number < m {\n            m = number\n\
    \        }\n        if number > M {\n            M = number\n        }\n    }\n\
    \    let transform = { (x: Double) -> Double in\n        (x - m) / (M - m)\n \
    \   }\n    return numbers.map(transform)", "    let min = numbers.min()!\n   \
    \ let max = numbers.max()!\n    let diff = max - min\n    let range = numbers.map\
    \ { ($0 - min) / diff }\n    return range", "    let max = numbers.max()!\n  \
    \  let min = numbers.min()!\n    let factor = 1.0 / (max - min)\n    return numbers.map\
    \ { x in (x - min) * factor }", "    var result = [Double]()\n    let (min, max)\
    \ = numbers.minmax\n    for number in numbers {\n        let transformed = (number\
    \ - min) / (max - min)\n        result.append(transformed)\n    }\n    return\
    \ result", "    precondition(numbers.count > 1)\n    let min_value = numbers.min()!\n\
    \    let max_value = numbers.max()!\n    return numbers.map { ($0 - min_value)\
    \ / (max_value - min_value) }", "    guard let min = numbers.min(), let max =\
    \ numbers.max() else {\n        return []\n    }\n    let dif = max - min\n  \
    \  return numbers.map { ($0 - min) / dif }", "    let max_value = numbers.max()\n\
    \    let min_value = numbers.min()\n    let range = max_value! - min_value!\n\
    \    let rescaled = numbers.map { ($0 - min_value!) / range }\n    return rescaled",
  "    guard !numbers.isEmpty else { return [] }\n    let sorted = numbers.sorted()\n\
    \    let min = sorted.first!\n    let max = sorted.last!\n    let range = max\
    \ - min\n    guard range > 0 else { return Array(repeating: 0.0, count: numbers.count)\
    \ }\n    return numbers.map { (val) -> Double in (val - min) / range }", "   \
    \ var min_val = numbers[0]\n    var max_val = numbers[0]\n    for value in numbers\
    \ {\n        if value < min_val {\n            min_val = value\n        }\n  \
    \      if value > max_val {\n            max_val = value\n        }\n    }\n \
    \   return numbers.map { (($0 - min_val) / (max_val - min_val)) }", "    let min\
    \ = numbers.min()!\n    let max = numbers.max()!\n    let range = max - min\n\
    \    return numbers.map { ($0 - min) / range }", "    var ret: [Double] = []\n\
    \    let (min, max) = (numbers.minElement()!, numbers.maxElement()!)\n    for\
    \ n in numbers {\n        let rescaled = (n - min) / (max - min)\n        ret.append(rescaled)\n\
    \    }\n    return ret", "    assert(numbers.count > 1)\n    let min = numbers.min()!\n\
    \    let max = numbers.max()!\n    let scaled = numbers.map { ($0 - min) / (max\
    \ - min) }\n    return scaled", "    guard numbers.count > 1 else { return numbers\
    \ }\n    let max = numbers.max()!\n    let min = numbers.min()!\n    var result\
    \ = [Double]()\n    for num in numbers {\n        result.append((num - min) /\
    \ (max - min))\n    }\n    return result", "    guard numbers.count > 1 else {\
    \ return numbers }\n    let max_number = numbers.max()!\n    let min_number =\
    \ numbers.min()!\n    return numbers.map { ($0 - min_number) / (max_number - min_number)\
    \ }", "    // Check that there are numbers to scale\n    guard numbers.count >\
    \ 1 else {\n        return numbers\n    }\n    \n    // Find largest and smallest\n\
    \    let (smallest, largest) = (numbers.min()!, numbers.max()!)\n    \n    //\
    \ Do the rescaling\n    return numbers.map { (value: Double) -> Double in\n  \
    \      (value - smallest) / (largest - smallest)\n    }", "    let minimum_number\
    \ = numbers.min()!\n    let maximum_number = numbers.max()!\n    let delta = maximum_number\
    \ - minimum_number\n    return numbers.map { ($0 - minimum_number) / delta }",
  "    let max = numbers.max()!\n    let min = numbers.min()!\n    return numbers.map\
    \ {($0 - min) / (max - min)}", "    \n    var min_element = numbers[0]\n    var\
    \ max_element = numbers[0]\n    \n    for element in numbers {\n        if element\
    \ < min_element {\n            min_element = element\n        }\n        if element\
    \ > max_element {\n            max_element = element\n        }\n    }\n    \n\
    \    let range = max_element - min_element\n    \n    var scaled_numbers = [Double]()\n\
    \    \n    for element in numbers {\n        scaled_numbers.append((element -\
    \ min_element) / range)\n    }\n    \n    return scaled_numbers", "    let min_number\
    \ = numbers.min()!\n    let max_number = numbers.max()!\n    return numbers.map\
    \ { ($0 - min_number) / (max_number - min_number) }", "    let min = numbers.min()!\n\
    \    let max = numbers.max()!\n    let range = max - min\n    return numbers.map({\
    \ (x: Double) -> Double in (x - min) / range })", "    let min = numbers.min()!\n\
    \    let max = numbers.max()!\n    var result = [Double]()\n    for number in\
    \ numbers {\n        result.append((number - min) / (max - min))\n    }\n    return\
    \ result", "    guard numbers.count > 1 else { return numbers }\n    let min_value\
    \ = numbers.min()!\n    let max_value = numbers.max()!\n    let range = max_value\
    \ - min_value\n    return numbers.map { ($0 - min_value) / range }", "    // apply\
    \ linear transform to numbers, such that largest number will become 1.0 and smallest\
    \ 0.0\n    let max = numbers.max()!\n    let min = numbers.min()!\n    return\
    \ numbers.map { (x: Double) -> Double in (x - min) / (max - min) }", "    var\
    \ max = numbers[0]\n    var min = numbers[0]\n    for n in numbers {\n       \
    \ if n > max {\n            max = n\n        }\n        if n < min {\n       \
    \     min = n\n        }\n    }\n    let diff = max - min\n    return numbers.map({\
    \ (n) -> Double in\n        return (n - min) / diff\n    })", "    precondition(numbers.count\
    \ > 1)\n    let min = numbers.min()!\n    let max = numbers.max()!\n    return\
    \ numbers.map { (number) -> Double in\n        return (number - min) / (max -\
    \ min)\n    }", "    let min = numbers.min()!\n    let max = numbers.max()!\n\
    \    return numbers.map { ($0 - min) / (max - min) }", "  let minimum = numbers.min()!\n\
    \  let maximum = numbers.max()!\n  return numbers.map({ (number) -> Double in\n\
    \    let interval = maximum - minimum\n    return (number - minimum) / interval\n\
    \  })", "    guard let min = numbers.min(), let max = numbers.max() else { return\
    \ numbers }\n    return numbers.map { (n: Double) -> Double in (n - min) / (max\
    \ - min) }", "    precondition(numbers.count > 1)\n    let min_value = numbers.min()!\n\
    \    let max_value = numbers.max()!\n    let range = max_value - min_value\n \
    \   return numbers.map { ($0 - min_value) / range }", "    assert(numbers.count\
    \ > 1)\n    let max = numbers.max()!\n    let min = numbers.min()!\n    let range\
    \ = max - min\n    let rescaled_numbers = numbers.map({ (n: Double) -> Double\
    \ in\n        (n - min) / range\n    })\n    return rescaled_numbers", "    \n\
    \    /// find max and min elements in array\n    var max = Double.min\n    var\
    \ min = Double.max\n    for number in numbers {\n        if number > max {\n \
    \           max = number\n        }\n        if number < min {\n            min\
    \ = number\n        }\n    }\n    \n    /// subtract minimum from each element,\
    \ then divide by max-min\n    let result = numbers.map({ (number) -> Double in\n\
    \        return (number - min) / (max - min)\n    })\n    \n    return result",
  "    guard !numbers.isEmpty else {\n        return []\n    }\n    let min = numbers.min()!\n\
    \    let max = numbers.max()!\n    let spread = max - min\n    return numbers.map\
    \ { (num) -> Double in\n        (num - min) / spread\n    }", "    guard let minValue\
    \ = numbers.min(), let maxValue = numbers.max() else { return numbers }\n    let\
    \ zeroBasedRange = maxValue - minValue\n    return numbers.map { ($0 - minValue)\
    \ / zeroBasedRange }", "    if numbers.count < 2 {\n        return numbers\n \
    \   }\n    let max = numbers.max()!\n    let min = numbers.min()!\n    let range\
    \ = max - min\n    return numbers.map { ($0 - min) / range }", "    let (min,\
    \ max) = (numbers.min()!, numbers.max()!)\n    let range = max - min\n    return\
    \ numbers.map { ($0 - min) / range }", "    let min = numbers.min()!\n    let\
    \ max = numbers.max()!\n    return numbers.map { $0.scaled(min: min, max: max)\
    \ }", "    var numbers = numbers\n    let max = numbers.max()!\n    let min =\
    \ numbers.min()!\n    let scale = max - min\n    let r = 1.0 / scale\n    numbers\
    \ = numbers.map({ (v) -> Double in\n        return r * (v - min)\n    })\n   \
    \ return numbers", "    // TODO: Add implementation\n    var min_val = numbers[0]\n\
    \    var max_val = numbers[0]\n    for i in numbers {\n        if min_val > i\
    \ {\n            min_val = i\n        }\n        if max_val < i {\n          \
    \  max_val = i\n        }\n    }\n    let normalized = numbers.map { ($0 - min_val)\
    \ / (max_val - min_val) }\n    return normalized", "    let min = numbers.min()!\n\
    \    let max = numbers.max()!\n    return numbers.map { ($0 - min) / (max - min)\
    \ }", "    \n    // ensure array is not empty\n    assert(numbers.count > 0)\n\
    \    \n    // find smallest and largest number\n    var smallest = numbers[0]\n\
    \    var largest = numbers[0]\n    for number in numbers {\n        if number\
    \ < smallest {\n            smallest = number\n        }\n        if number >\
    \ largest {\n            largest = number\n        }\n    }\n    \n    // find\
    \ total range of numbers\n    let range = largest - smallest\n    \n    // if\
    \ range is 0, all numbers are the same, return array of all 0's\n    if range\
    \ == 0 {\n        return Array(repeating: 0.0, count: numbers.count)\n    }\n\
    \    \n    // rescale to be between 0 and 1\n    return numbers.map {\n      \
    \  ($0 - smallest) / range\n    }", "    // find min and max value\n    let minmax\
    \ = minmax_element(numbers)\n    let min = minmax.min\n    let max = minmax.max\n\
    \    let range = max - min\n    let step = 1.0 / Double(numbers.count - 1)\n \
    \   let rescaled = numbers.map { (x: Double) -> Double in\n        let r = (x\
    \ - min) / range\n        return r\n    }\n    return rescaled", "    let min\
    \ = numbers.min()!\n    let max = numbers.max()!\n    return numbers.map { ($0\
    \ - min) / (max - min) }", "    var min = Double.infinity\n    var max = -Double.infinity\n\
    \    for i in numbers {\n        if i < min {\n            min = i\n        }\n\
    \        if i > max {\n            max = i\n        }\n    }\n    let delta =\
    \ max - min\n    return numbers.map({ (n) -> Double in\n        return (n - min)\
    \ / delta\n    })", "    var new = numbers\n    let min = new.min()!\n    let\
    \ max = new.max()!\n    for i in 0..<new.count {\n        new[i] = new[i].rescale(min:\
    \ min, max: max)\n    }\n    return new", "    // \"var\" makes the variable mutable\n\
    \    var min = numbers[0]\n    var max = numbers[0]\n    for num in numbers {\n\
    \        if num < min {\n            min = num\n        }\n        if num > max\
    \ {\n            max = num\n        }\n    }\n    var result = [Double]()\n  \
    \  for num in numbers {\n        result.append((num - min) / (max - min))\n  \
    \  }\n    return result", "    let minVal = numbers.min()!\n    let maxVal = numbers.max()!\n\
    \    let nums = numbers.map { return ($0 - minVal) / (maxVal - minVal) }\n   \
    \ return nums", "    var retval = [Double]()\n    let min = numbers.min()!\n \
    \   let max = numbers.max()!\n    let diff = max - min\n    for n in numbers {\n\
    \        retval.append((n - min) / diff)\n    }\n    return retval", "    let\
    \ min = numbers.min()!\n    let max = numbers.max()!\n    return numbers.map({\
    \ (x: Double) -> Double in\n        if max - min == 0 {\n            return 0\n\
    \        } else {\n            return (x - min) / (max - min)\n        }\n   \
    \ })", "    precondition(numbers.count > 1)\n    let min = numbers.min()!\n  \
    \  let max = numbers.max()!\n    return numbers.map { ($0 - min) / (max - min)\
    \ }", "    let min_number = numbers.min() ?? 0.0\n    let max_number = numbers.max()\
    \ ?? 1.0\n    return numbers.map({($0 - min_number) / (max_number - min_number)})",
  "    let min = numbers.min()!\n    let max = numbers.max()!\n    let range = max\
    \ - min\n    return numbers.map { ($0 - min) / range }", "    assert(numbers.count\
    \ > 1)\n    let factor = 1.0 / (numbers.max()! - numbers.min()!)\n    let offset\
    \ = numbers.min()!\n    return numbers.map({ factor * ($0 - offset) })", "   \
    \ var n = numbers\n    // get the minimum\n    let minimum = n.min()!\n    //\
    \ subtract the minimum from each element of the array\n    // in-place using map\n\
    \    n = n.map({ $0 - minimum })\n    // get the maximum\n    let maximum = n.max()!\n\
    \    // divide each element of the array by the maximum and return the result\n\
    \    return n.map({ $0 / maximum })", "    let minmax = minmax_element(numbers)\n\
    \    return transform_linearly(numbers, 0.0, 1.0, minmax.0, minmax.1)", "    let\
    \ min = numbers.min()!\n    let max = numbers.max()!\n    return numbers.map {\
    \ ($0 - min) / (max - min) }", "    var result = [Double]()\n    let max_number\
    \ = numbers.max()!\n    let min_number = numbers.min()!\n    for number in numbers\
    \ {\n        result.append((number - min_number) / (max_number - min_number))\n\
    \    }\n    return result", "    assert(numbers.count > 1)\n    let smallest =\
    \ numbers.min()!\n    let largest = numbers.max()!\n    let span = largest - smallest\n\
    \    return numbers.map { ($0 - smallest) / span }", "    var result = [Double]()\n\
    \    let min = numbers.min()!\n    let max = numbers.max()!\n    let range = max\
    \ - min\n    result = numbers.map { ($0 - min) / range }\n    return result",
  "    let min_value = numbers.min()!\n    let max_value = numbers.max()!\n    let\
    \ delta = max_value - min_value\n    return numbers.map { ($0 - min_value) / delta\
    \ }", "    let max = numbers.max()!\n    let min = numbers.min()!\n    let span\
    \ = max - min\n    return numbers.map { (number) -> Double in\n        return\
    \ (number - min) / span\n    }", "    let min = numbers.min()!\n    let max =\
    \ numbers.max()!\n    let sum = max - min\n    return numbers.map { ($0 - min)\
    \ / sum }", "    let (min, max) = (numbers.minElement()!, numbers.maxElement()!)\n\
    \    let rescaled = numbers.map { (n: Double) -> Double in\n        (n - min)\
    \ / (max - min)\n    }\n    return rescaled", "    let min = numbers.min() ??\
    \ 0.0\n    let max = numbers.max() ?? 1.0\n    let range = max - min\n    guard\
    \ range > 0.0 else {\n        return numbers\n    }\n    return numbers.map {\
    \ (number) -> Double in\n        return (number - min) / range\n    }", "    if\
    \ numbers.count == 0 {\n        return []\n    }\n\n    let min_val = numbers.min()!\n\
    \    let max_val = numbers.max()!\n    if min_val == max_val {\n        return\
    \ Array(repeating: 0.0, count: numbers.count)\n    }\n    let delta = max_val\
    \ - min_val\n    return numbers.map { ($0 - min_val) / delta }", "    // TODO:\
    \ Complete implementation\n    return numbers", "    let min = numbers.min()!\n\
    \    let max = numbers.max()!\n    return numbers.map { ($0 - min) / (max - min)\
    \ }", "    \n    /// Having at least two numbers...\n    if numbers.count > 1\
    \ {\n        \n        /// Get the minimum number, and the range\n        let\
    \ min_num = numbers.min()!\n        let range_num = numbers.max()! - min_num\n\
    \        \n        /// Apply linear transformation\n        return numbers.map\
    \ {\n            return ($0 - min_num) / range_num\n        }\n    }\n    \n \
    \   /// Return input if it has fewer than two elements\n    return numbers", " \
    \   var unit_scaled_numbers = numbers\n    var min = numbers[0]\n    var max =\
    \ numbers[0]\n    for i in 1..<numbers.count {\n        if numbers[i] < min {\n\
    \            min = numbers[i]\n        }\n        if numbers[i] > max {\n    \
    \        max = numbers[i]\n        }\n    }\n    for i in 0..<numbers.count {\n\
    \        unit_scaled_numbers[i] = (numbers[i] - min) / (max - min)\n    }\n  \
    \  return unit_scaled_numbers", "    let arr = numbers\n    var newArr = [Double]()\n\
    \    let max = arr.max()\n    let min = arr.min()\n    for num in arr {\n    \
    \    newArr.append((num - min!) / (max! - min!))\n    }\n    return newArr", " \
    \ let minimum = numbers.min()!\n  let maximum = numbers.max()!\n  var result =\
    \ [Double]()\n  for number in numbers {\n    result.append((number - minimum)\
    \ / (maximum - minimum))\n  }\n  return result", "    let smallest_number = numbers.min()!\n\
    \    let largest_number = numbers.max()!\n    let scaling_factor = largest_number\
    \ - smallest_number\n    return numbers.map { ($0 - smallest_number) / scaling_factor\
    \ }", "    let min_value = numbers.min()!\n    let max_value = numbers.max()!\n\
    \    let x: [Double] = numbers.map { (y: Double) -> Double in\n        let temp\
    \ = (y - min_value) / (max_value - min_value)\n        return temp\n    }\n  \
    \  return x", "    guard let min = numbers.min(), let max = numbers.max() else\
    \ {\n        return []\n    }\n    return numbers.map { ($0 - min) / (max - min)\
    \ }", "  var rescaled = [Double]()\n  let min = numbers.min()!\n  let max = numbers.max()!\n\
    \  let scale = max - min\n  for number in numbers {\n    rescaled.append((number\
    \ - min) / scale)\n  }\n  return rescaled", "    guard numbers.count > 1 else\
    \ { return numbers }\n    let normalized_numbers = (numbers - numbers.min()!)\
    \ / (numbers.max()! - numbers.min()!)\n    return normalized_numbers", "    assert(numbers.count\
    \ > 1)\n    var result = [Double]()\n    let min_number = numbers.min()!\n   \
    \ let max_number = numbers.max()!\n    for number in numbers {\n        result.append((number\
    \ - min_number) / (max_number - min_number))\n    }\n    return result", "   \
    \ var min_n = numbers[0]\n    var max_n = numbers[0]\n    for n in numbers {\n\
    \        if n < min_n {\n            min_n = n\n        }\n        if n > max_n\
    \ {\n            max_n = n\n        }\n    }\n    var result = [Double]()\n  \
    \  for n in numbers {\n        let result_elem = (n - min_n) / (max_n - min_n)\n\
    \        result.append(result_elem)\n    }\n    return result", "    guard numbers.count\
    \ > 1 else {\n        return numbers\n    }\n    let max = numbers.max()!\n  \
    \  let min = numbers.min()!\n    let difference = max - min\n    return numbers.map\
    \ {\n        return ($0 - min) / difference\n    }", "    var scaled_numbers =\
    \ numbers\n    let min = numbers.min()!\n    let max = numbers.max()!\n    let\
    \ range = max - min\n    scaled_numbers = scaled_numbers.map { (($0 - min) / range)\
    \ }\n    return scaled_numbers", "    guard let min = numbers.min(), let max =\
    \ numbers.max() else { return [] }\n    let range = max - min\n    return numbers.map\
    \ { ($0 - min) / range }", "  guard let min = numbers.min(), let max = numbers.max()\
    \ else {\n    return numbers\n  }\n  let range = max - min\n  return numbers.map\
    \ { ($0 - min) / range }", "    assert(numbers.count > 1)\n    let minimum = numbers.min()!\n\
    \    let delta = numbers.max()! - minimum\n    return numbers.map { ($0 - minimum)\
    \ / delta }", "    let max_value = numbers.max()!\n    let min_value = numbers.min()!\n\
    \    return numbers.map({\n        ($0 - min_value) / (max_value - min_value)\n\
    \    })", "    let min = numbers.min()!\n    let max = numbers.max()!\n    let\
    \ delta = max - min\n    if delta == 0 {\n        return numbers\n    }\n    let\
    \ result = numbers.map { (n) -> Double in\n        (n - min) / delta\n    }\n\
    \    return result", "    let min = numbers.min()!\n    let max = numbers.max()!\n\
    \    let divisor = max - min\n    return numbers.map { (number) -> Double in\n\
    \        (number - min) / divisor\n    }", "    let min = numbers.min()!\n   \
    \ let max = numbers.max()!\n    let max_min = max - min\n    let r = numbers.map\
    \ { ($0 - min) / max_min }\n    return r", "    guard numbers.count > 1 else {\
    \ return numbers }\n    let min = numbers.min()!\n    let max = numbers.max()!\n\
    \    let factor = 1.0 / (max - min)\n    return numbers.map { (element) -> Double\
    \ in\n        return (element - min) * factor\n    }", "    guard numbers.count\
    \ > 1 else {\n        return numbers\n    }\n    let min_number = numbers.min()\
    \ ?? 0.0\n    let max_number = numbers.max() ?? 1.0\n    return numbers.map {\
    \ (number) -> Double in\n        guard max_number != min_number else {\n     \
    \       return 0.0\n        }\n        return (number - min_number) / (max_number\
    \ - min_number)\n    }", "    let min_value = numbers.min()!\n    let max_value\
    \ = numbers.max()!\n    return numbers.map { ($0 - min_value) / (max_value - min_value)\
    \ }", "    let min = numbers.min() ?? 0.0\n    let max = numbers.max() ?? 1.0\n\
    \    let span = max - min\n    return numbers.map { ($0 - min) / span }", "  \
    \  assert(numbers.count > 1)\n    let max = numbers.max()!\n    let min = numbers.min()!\n\
    \    let range = max - min\n    let range_padding = range * 0.02\n    let rescaled\
    \ = numbers.map { (x: Double) -> Double in\n        (x - min + range_padding)\
    \ / (range + range_padding)\n    }\n    return rescaled", "    precondition(numbers.count\
    \ > 1)\n    let min_number = numbers.min()!\n    let max_number = numbers.max()!\n\
    \    let range = max_number - min_number\n    return numbers.map { (number) ->\
    \ Double in\n        if range == 0 {\n            return 0\n        } else {\n\
    \            return (number - min_number) / range\n        }\n    }", "    assert(numbers.count\
    \ > 1)\n    let min_value = numbers.min()!\n    let max_value = numbers.max()!\n\
    \    let range = max_value - min_value\n    return numbers.map { ($0 - min_value)\
    \ / range }", "    let min = numbers.min() ?? 0.0\n    let max = numbers.max()\
    \ ?? 1.0\n    let delta = max - min\n    if delta == 0.0 {\n        return numbers\n\
    \    }\n    return numbers.map {\n        ($0 - min) / delta\n    }", "    var\
    \ result = numbers\n    for i in 0..<numbers.count {\n        result[i] = (numbers[i]\
    \ - numbers.min()!) / (numbers.max()! - numbers.min()!)\n    }\n    return result",
  "    guard numbers.count > 1 else {\n        return numbers\n    }\n    let min\
    \ = numbers.min()!\n    let max = numbers.max()!\n    return numbers.map { (($0\
    \ - min) / (max - min)) }", "    guard let (min_number, max_number) = extremes(numbers:\
    \ numbers) else {\n        return []\n    }\n    return numbers.map {\n      \
    \  (number: Double) -> Double in\n        if max_number == min_number {\n    \
    \        return 0.0\n        }\n        return (number - min_number) / (max_number\
    \ - min_number)\n    }", "    let min = numbers.min()!\n    let max = numbers.max()!\n\
    \    var result = [Double]()\n    for number in numbers {\n        result.append((number\
    \ - min) / (max - min))\n    }\n    return result", "    guard !numbers.isEmpty\
    \ else {\n        fatalError(\"Can't rescale empty list\")\n    }\n    guard numbers.count\
    \ > 1 else {\n        return [1.0]\n    }\n    let smallest = numbers.min()!\n\
    \    let largest = numbers.max()!\n    return numbers.map({ (value: Double) ->\
    \ Double in\n        (value - smallest) / (largest - smallest)\n    })", "   \
    \ let min_value = numbers.min()!\n    let max_value = numbers.max()!\n    let\
    \ current_range = max_value - min_value\n    let rescaled_numbers = numbers.map({\
    \ (n: Double) -> Double in\n        return (n - min_value) / current_range\n \
    \   })\n    return rescaled_numbers", "    var mn = Double.infinity\n    var mx\
    \ = -Double.infinity\n    for i in numbers {\n        mn = min(mn, i)\n      \
    \  mx = max(mx, i)\n    }\n    let rate = 1.0 / (mx - mn)\n    var result = [Double]()\n\
    \    for i in numbers {\n        result.append((i - mn) * rate)\n    }\n    return\
    \ result", "    var result = numbers\n    let min = numbers.min()!\n    let max\
    \ = numbers.max()!\n    for i in 0..<numbers.count {\n        result[i] = (result[i]\
    \ - min) / (max - min)\n    }\n    return result", "    let largest = numbers.max()!\n\
    \    let smallest = numbers.min()!\n    let diff = largest - smallest\n    return\
    \ numbers.map { ($0 - smallest) / diff }", "    precondition(numbers.count > 1)\n\
    \    let min = numbers.min()!\n    let max = numbers.max()!\n    return numbers.map\
    \ {\n        ($0 - min) / (max - min)\n    }", "    let min = numbers.min()!\n\
    \    let max = numbers.max()!\n    return numbers.map { ($0 - min) / (max - min)\
    \ }", "    let min_value = numbers.min()!\n    let max_value = numbers.max()!\n\
    \    let transform = numbers.map { ($0 - min_value) / (max_value - min_value)\
    \ }\n    return transform", "    if numbers.count < 2 {\n        return numbers\n\
    \    }\n    let min = numbers.min()!\n    let max = numbers.max()!\n    let diff\
    \ = max - min\n    return numbers.map {\n        if diff > 0 {\n            return\
    \ ($0 - min) / diff\n        } else {\n            return 0.0\n        }\n   \
    \ }", "    var rescaled_numbers = numbers\n    let max = numbers.max()\n    let\
    \ min = numbers.min()\n    for i in 0 ..< numbers.count {\n        let current_value\
    \ = numbers[i]\n        let rescaled_value = (current_value - min!) / (max! -\
    \ min!)\n        rescaled_numbers[i] = rescaled_value\n    }\n    return rescaled_numbers",
  "    let min_number = numbers.min()!\n    let max_number = numbers.max()!\n    let\
    \ size = max_number - min_number\n    return numbers.map { ($0 - min_number) /\
    \ size }", "    if numbers.count < 2 {\n        fatalError(\"`numbers` must contain\
    \ at least two elements\")\n    }\n    let max = numbers.max()!\n    let min =\
    \ numbers.min()!\n    let delta = max - min\n    if delta == 0 {\n        fatalError(\"\
    The range of numbers is zero\")\n    }\n    let rescaled = numbers.map { ($0 -\
    \ min) / delta }\n    return rescaled", "    let max = numbers.max()\n    let\
    \ min = numbers.min()\n    return numbers.map { $0 / (max! - min!) }", "    let\
    \ min = numbers.min()!\n    let max = numbers.max()!\n    let size = max - min\n\
    \    let result = numbers.map({ ($0 - min) / size })\n    return result", "  \
    \  let minimum = numbers.min()!\n    let maximum = numbers.max()!\n    let range\
    \ = maximum - minimum\n    return numbers.map { ($0 - minimum) / range }", " \
    \   var result = [Double]()\n    var max_value = numbers[0]\n    var min_value\
    \ = numbers[0]\n    for number in numbers {\n        if number > max_value {\n\
    \            max_value = number\n        }\n        if number < min_value {\n\
    \            min_value = number\n        }\n    }\n    for number in numbers {\n\
    \        result.append((number - min_value) / (max_value - min_value))\n    }\n\
    \    return result", "    let min = numbers.min()!\n    let max = numbers.max()!\n\
    \    return numbers.map { (x: Double) -> Double in\n        (x - min) / (max -\
    \ min)\n    }", "    guard numbers.count > 1 else {\n        return numbers\n\
    \    }\n    let extent = numbers.extent()\n    guard extent.lower != extent.upper\
    \ else {\n        return numbers\n    }\n    let factor = 1.0 / (extent.upper\
    \ - extent.lower)\n    return numbers.map { $0 * factor }", "    let smallest\
    \ = numbers.min()!\n    let largest = numbers.max()!\n    let distance = largest\
    \ - smallest\n    return numbers.map { (number) -> Double in\n        return (number\
    \ - smallest) / distance\n    }", "    precondition(numbers.count > 1)\n    let\
    \ largest = numbers.max()\n    let smallest = numbers.min()\n    let range = largest!\
    \ - smallest!\n    let rescaled = numbers.map {($0 - smallest!) / range}\n   \
    \ return rescaled", "    let max = numbers.max()!\n    let min = numbers.min()!\n\
    \    let range = max - min\n    return numbers.map { (($0 - min) / range) }",
  "    let min = numbers.min()!\n    let max = numbers.max()!\n    let range = max\
    \ - min\n    return numbers.map { ($0 - min) / range }", "    let max = numbers.max()!\n\
    \    let min = numbers.min()!\n    let difference = max - min\n    return numbers.map\
    \ { ($0 - min) / difference }", "    guard numbers.count > 1 else { return numbers\
    \ }\n    guard let min = numbers.min(), let max = numbers.max() else { return\
    \ numbers }\n    let delta = max - min\n    return numbers.map { ($0 - min) /\
    \ delta }", '  // TODO: write your code here!', "    guard numbers.count > 1 else\
    \ {\n        return numbers\n    }\n    let min = numbers.min()!\n    let max\
    \ = numbers.max()!\n    let diff = max - min\n    return numbers.map { ($0 - min)\
    \ / diff }", "    assert(numbers.count > 1)\n    guard let min = numbers.min(),\
    \ let max = numbers.max() else { return [] }\n    return numbers.map({ $0 - min\
    \ }).map({ $0 / (max - min) })", "    // Find min and max\n    let min = numbers.min()!\n\
    \    let max = numbers.max()!\n    \n    // Find the range, and rescale each number\n\
    \    let range = max - min\n    return numbers.map { ($0 - min) / range }", " \
    \   let min_number = numbers.min() ?? 0.0\n    let max_number = numbers.max()\
    \ ?? 1.0\n    let rescaled = numbers.map { (value) -> Double in\n        (value\
    \ - min_number) / (max_number - min_number)\n    }\n    return rescaled", "  \
    \  precondition(numbers.count > 1)\n    let min_ = numbers.min()!\n    let max_\
    \ = numbers.max()!\n    let scale = 1.0 / (max_ - min_)\n    return numbers.map\
    \ { (scale * ($0 - min_)) }", "    var min: Double = numbers[0]\n    var max:\
    \ Double = numbers[0]\n    var rescaled_numbers: [Double] = []\n    \n    for\
    \ n in numbers {\n        if n < min {\n            min = n\n        }\n     \
    \   if n > max {\n            max = n\n        }\n    }\n    \n    let scale:\
    \ Double = 1 / (max - min)\n    \n    for n in numbers {\n        rescaled_numbers.append((n\
    \ - min) * scale)\n    }\n    \n    return rescaled_numbers", "    let range =\
    \ max(numbers) - min(numbers)\n    return numbers.map { (elem: Double) -> Double\
    \ in\n        if range == 0 {\n            return 0\n        } else {\n      \
    \      return (elem - min(numbers)) / range\n        }\n    }", "    let min_number\
    \ = numbers.min()!\n    let max_number = numbers.max()!\n    return numbers.map\
    \ { $0.rescale(from_min: min_number, from_max: max_number, to_min: 0.0, to_max:\
    \ 1.0) }", "    let min_element = numbers.min()!\n    let max_element = numbers.max()!\n\
    \    let range = max_element - min_element\n    return numbers.map({ (x: Double)\
    \ -> Double in\n        return (x - min_element) / range\n    })", "    guard\
    \ numbers.count > 1 else {\n        return numbers\n    }\n    let n_min = numbers.min()!\n\
    \    let n_max = numbers.max()!\n    let n_range = n_max - n_min\n    return numbers.map\
    \ { (n) -> Double in\n        (n - n_min) / n_range\n    }", "    // TODO: think\
    \ a way to make this pure function\n    let maximum = numbers.max()!\n    let\
    \ minimum = numbers.min()!\n    return numbers.map { ($0 - minimum) / (maximum\
    \ - minimum) }", "    var rescaled = numbers\n    let max = rescaled.max()\n \
    \   let min = rescaled.min()\n    let denom = max! - min!\n    if denom == 0 {\
    \ return Array(repeating: 0.0, count: numbers.count) }\n    for i in 0..<rescaled.count\
    \ {\n        rescaled[i] = (rescaled[i] - min!) / denom\n    }\n    return rescaled",
  "    var min: Double = numbers[0]\n    var max: Double = numbers[0]\n    for number\
    \ in numbers {\n        if number < min {\n            min = number\n        }\n\
    \        if number > max {\n            max = number\n        }\n    }\n    return\
    \ numbers.map { (number) -> Double in\n        return (number - min) / (max -\
    \ min)\n    }", "    guard let min = numbers.min(), let max = numbers.max() else\
    \ { return [] }\n    return numbers.map { $0.rescale(min: min, max: max) }", " \
    \   var minimum: Double = Double.infinity\n    var maximum: Double = -Double.infinity\n\
    \    for n in numbers {\n        if n < minimum {\n            minimum = n\n \
    \       }\n        if n > maximum {\n            maximum = n\n        }\n    }\n\
    \    let transform = LinearTransform(from_min: minimum, from_max: maximum, to_min:\
    \ 0.0, to_max: 1.0)\n    return numbers.map(transform.transformed)", "    let\
    \ min = numbers.min()!\n    let max = numbers.max()!\n    return numbers.map {\
    \ ($0 - min) / (max - min) }", "    let max = numbers.max()\n    let min = numbers.min()\n\
    \    let divisor = max! - min!\n    return numbers.map({ (n) -> Double in\n  \
    \      return (n - min!) / divisor\n    })", "    var scaled: [Double] = []\n\
    \    let min = numbers.min()!\n    let max = numbers.max()!\n    let range = max\
    \ - min\n    for number in numbers {\n        scaled.append((number - min) / range)\n\
    \    }\n    return scaled", "    let smallest = numbers.min()!\n    let largest\
    \ = numbers.max()!\n    return numbers.map { ($0 - smallest) / (largest - smallest)\
    \ }", "    guard numbers.count > 1 else { return numbers }\n    let min = numbers.min()!\n\
    \    let max = numbers.max()!\n    return numbers.map { ($0 - min) / (max - min)\
    \ }", "    guard numbers.count > 1 else { return numbers }\n    let min_ = numbers.min()!\n\
    \    let max_ = numbers.max()!\n    let scale = max_ - min_\n    return numbers.map\
    \ { (x: Double) -> Double in (x - min_) / scale }", "    var result = [Double]()\n\
    \    if let max = numbers.max(), let min = numbers.min() {\n        for num in\
    \ numbers {\n            result.append((num - min) / (max - min))\n        }\n\
    \    }\n    return result", "    precondition(numbers.count > 1)\n    let a =\
    \ numbers.min()!\n    let b = numbers.max()!\n    return numbers.map { (b - a)\
    \ * $0 + a }", "    guard let min = numbers.minElement(), let max = numbers.maxElement()\
    \ else {\n        return []\n    }\n    return numbers.map { (value) -> Double\
    \ in\n        return (value - min) / (max - min)\n    }", "    let min_max = min_max_in_array(array:\
    \ numbers)\n    let min_value = min_max.0\n    let max_value = min_max.1\n   \
    \ let rescaled_numbers = numbers.map({ (x: Double) -> Double in\n        (x -\
    \ min_value) / (max_value - min_value)\n    })\n    return rescaled_numbers",
  "    let smallest = numbers.min()!\n    let largest = numbers.max()!\n    return\
    \ numbers.map { x in\n        (x - smallest) / (largest - smallest)\n    }", " \
    \   let min = numbers.min()!\n    let max = numbers.max()!\n    let range = max\
    \ - min\n    return numbers.map { ($0 - min) / range }", "    let maxNumber =\
    \ numbers.max()\n    let minNumber = numbers.min()\n    return numbers.map { number\
    \ in (number - minNumber!) / (maxNumber! - minNumber!) }", "    let min = numbers.min()!\n\
    \    let max = numbers.max()!\n    let delta = max - min\n    return numbers.map\
    \ { (value) -> Double in\n        return (value - min) / delta\n    }", "    let\
    \ x_min = numbers.min()!\n    let x_max = numbers.max()!\n    let array = numbers.map\
    \ { ($0 - x_min) / (x_max - x_min) }\n    return array", "    let min = numbers.min()!\n\
    \    let max = numbers.max()!\n    let range = max - min\n    let scaled = numbers.map\
    \ {\n        return ($0 - min) / range\n    }\n    return scaled", "    guard\
    \ numbers.count > 1 else { return numbers }\n    let min = numbers.min()!\n  \
    \  let max = numbers.max()!\n    let range = max - min\n    return numbers.map\
    \ { ($0 - min) / range }", "    if numbers.count == 0 {\n        return []\n \
    \   }\n    if numbers.count == 1 {\n        return [0.0]\n    }\n    let min_value\
    \ = numbers.min()!\n    let max_value = numbers.max()!\n    if min_value == max_value\
    \ {\n        return Array(repeating: 0.0, count: numbers.count)\n    }\n    let\
    \ numbers_float: [Float] = numbers.map { Float($0) }\n    let normalized = stride(from:\
    \ 0, to: numbers_float.count, by: 1).map { (i: Int) -> Float in\n        return\
    \ ((numbers_float[i] - min_value) / (max_value - min_value))\n    }\n    return\
    \ normalized.map { Double($0) }", "    // Require at least two elements\n    assert(numbers.count\
    \ >= 2)\n    \n    let max = numbers.max()!\n    let min = numbers.min()!\n  \
    \  \n    let range = max - min\n    \n    return numbers.map { ($0 - min) / range\
    \ }", "  let min_value = numbers.min() ?? 0.0\n  let max_value = numbers.max()\
    \ ?? 1.0\n  let scale = 1.0 / (max_value - min_value)\n  return numbers.map {\
    \ (value) -> Double in\n    (value - min_value) * scale\n  }", "    var numbers\
    \ = numbers\n    let lowest = numbers.min()!\n    numbers = numbers.map({ $0 -\
    \ lowest })\n    let highest = numbers.max()!\n    return numbers.map({ $0 / highest\
    \ })", "    let max = numbers.max()!\n    let min = numbers.min()!\n    let scale\
    \ = 1.0 / (max - min)\n    let result = numbers.map { ($0 - min) * scale }\n \
    \   return result", "    guard numbers.count > 0 else { return numbers }\n   \
    \ let min = numbers.min()!\n    let max = numbers.max()!\n    let scale = 1.0\
    \ / (max - min)\n    return numbers.map { (n) -> Double in\n        return scale\
    \ * (n - min)\n    }", "    guard numbers.count > 0 else {\n        return numbers\n\
    \    }\n    let min = numbers.min()!\n    let max = numbers.max()!\n    let spread\
    \ = max - min\n    return numbers.map { (n) -> Double in\n        if spread ==\
    \ 0 {\n            return 0\n        }\n        return (n - min) / spread\n  \
    \  }", "    let min_val = numbers.min()!\n    let max_val = numbers.max()!\n \
    \   let result = numbers.map({ ($0 - min_val) / (max_val - min_val) })\n    return\
    \ result", "    let min = numbers.min()!\n    let max = numbers.max()!\n    return\
    \ numbers.map { ($0 - min) / (max - min) }", "    guard numbers.count > 1 else\
    \ {\n        print(\"rescale_to_unit: not enough numbers provided\")\n       \
    \ return numbers\n    }\n    let min = numbers.min()!\n    let max = numbers.max()!\n\
    \    let delta = max - min\n    if delta == 0 {\n        return numbers\n    }\n\
    \    return numbers.map { (x) -> Double in\n        (x - min) / delta\n    }",
  "    // Naive implementation\n    let sorted = numbers.sorted()\n    let min = sorted.first!\n\
    \    let max = sorted.last!\n    let diff = max - min\n    let result = numbers.map\
    \ { ($0 - min) / diff }\n    return result", "    guard numbers.count > 1 else\
    \ { return numbers }\n    let min = numbers.min() ?? 0.0\n    let max = numbers.max()\
    \ ?? 1.0\n    return numbers.map { ($0 - min) / (max - min) }", "    precondition(numbers.count\
    \ > 1)\n    let min = numbers.min()!\n    let max = numbers.max()!\n    return\
    \ numbers.map { ($0 - min) / (max - min) }", "  guard let (min_value, max_value)\
    \ = min_max(numbers: numbers) else {\n    return []\n  }\n  let range = max_value\
    \ - min_value\n  return numbers.map { (number) -> Double in\n    (number - min_value)\
    \ / range\n  }", "    let min_value = min(numbers)\n    let max_value = max(numbers)\n\
    \    let range = max_value - min_value\n    return numbers.map { ($0 - min_value)\
    \ / range }", "    guard numbers.count > 1 else {\n        return numbers\n  \
    \  }\n    let smallest = numbers.min()!\n    let largest = numbers.max()!\n  \
    \  let range = largest - smallest\n    return numbers.map({ (n: Double) -> Double\
    \ in\n        return (n - smallest) / range\n    })", "    var numbers = numbers\n\
    \    numbers.sortInPlace()\n    let (min, max) = (numbers.first!, numbers.last!)\n\
    \    return numbers.map { ($0 - min) / (max - min) }", "    guard !numbers.isEmpty\
    \ else {\n        return []\n    }\n    let min_max = numbers.minmax()\n    let\
    \ min = min_max.min\n    let max = min_max.max\n    if max - min == 0 {\n    \
    \    return Array(repeating: 1.0, count: numbers.count)\n    }\n    return numbers.map\
    \ {\n        return ($0 - min) / (max - min)\n    }", "    guard let (min, max)\
    \ = minmax(numbers) else {\n        return numbers\n    }\n    return numbers.map\
    \ {\n        0.0 + ($0 - min) * (1.0 - 0.0) / (max - min)\n    }", "    var max\
    \ = -Double.infinity\n    var min = Double.infinity\n    for number in numbers\
    \ {\n        if number > max {\n            max = number\n        }\n        if\
    \ number < min {\n            min = number\n        }\n    }\n    return numbers.map\
    \ { return minmax_scale(value: $0, min: min, max: max) }", "    assert(numbers.count\
    \ > 1)\n    let min = numbers.min()!\n    let max = numbers.max()!\n    return\
    \ numbers.map { ($0 - min) / (max - min) }", "    guard let min = numbers.min(),\
    \ let max = numbers.max() else {\n        return numbers\n    }\n    return numbers.map({\
    \ $0 - min })\n        .map({ $0 / (max - min) })", "    let min_value = numbers.min()!\n\
    \    let max_value = numbers.max()!\n    let denominator = max_value - min_value\n\
    \    return numbers.map { ($0 - min_value) / denominator }", "    precondition(numbers.count\
    \ > 1)\n    let minmax = minmax_of(numbers: numbers)\n    let offset = minmax.min\n\
    \    let scale = minmax.max - minmax.min\n    return numbers.map({ ($0 - offset)\
    \ / scale })"]
stop_tokens:
- "\n}"
