language: swift
name: HumanEval_118_get_closest_vowel
results:
- exit_code: 1
  program: "\n/// You are given a word. Your task is to find the closest vowel that\
    \ stands between \n/// two consonants from the right side of the word (case sensitive).\n\
    /// Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n/// find any vowel met the above condition. \n/// You may assume that\
    \ the given string contains English letter only.\n/// Example:\n/// >>> get_closest_vowel(word:\
    \ \"yogurt\")\n/// \"u\"\n/// >>> get_closest_vowel(word: \"FULL\")\n/// \"U\"\
    \n/// >>> get_closest_vowel(word: \"quick\")\n/// \"\"\n/// >>> get_closest_vowel(word:\
    \ \"ab\")\n/// \"\"\nfunc get_closest_vowel(word: String) -> String {\n    let\
    \ vowels = \"aeiou\"\n    let consonants = \"bcdfghjklmnpqrstvwxyz\"\n    var\
    \ count = word.count - 1\n    var word = word\n    var word2 = String(word.reversed())\n\
    \    var i = 0\n    while i < word2.count {\n        let c = word2[i]\n      \
    \  let d = word2[i+1]\n        if consonants.contains(c) && vowels.contains(d)\
    \ {\n            return String(d)\n        }\n        i += 1\n    }\n    return\
    \ \"\"\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n  \
    \  if left.count != right.count {\n        return false\n    }\n    for (l, r)\
    \ in zip(left, right) {\n        if l != r {\n            return false\n     \
    \   }\n    }\n    return true\n}\n            \nassert(get_closest_vowel(word:\
    \ \"yogurt\") == \"u\")\nassert(get_closest_vowel(word: \"full\") == \"u\")\n\
    assert(get_closest_vowel(word: \"easy\") == \"\")\nassert(get_closest_vowel(word:\
    \ \"eAsy\") == \"\")\nassert(get_closest_vowel(word: \"ali\") == \"\")\nassert(get_closest_vowel(word:\
    \ \"bad\") == \"a\")\nassert(get_closest_vowel(word: \"most\") == \"o\")\nassert(get_closest_vowel(word:\
    \ \"ab\") == \"\")\nassert(get_closest_vowel(word: \"ba\") == \"\")\nassert(get_closest_vowel(word:\
    \ \"quick\") == \"\")\nassert(get_closest_vowel(word: \"anime\") == \"i\")\nassert(get_closest_vowel(word:\
    \ \"Asia\") == \"\")\nassert(get_closest_vowel(word: \"Above\") == \"o\")"
  status: SyntaxError
  stderr: "/tmp/tmpk7iu4_jp.swift:24:17: error: 'subscript(_:)' is unavailable: cannot\
    \ subscript String with an Int, use a String.Index instead.\n        let c = word2[i]\n\
    \                ^~~~~~~~\nSwift.String:3:12: note: 'subscript(_:)' has been explicitly\
    \ marked unavailable here\n    public subscript(i: Int) -> Character { get }\n\
    \           ^\n/tmp/tmpk7iu4_jp.swift:25:17: error: 'subscript(_:)' is unavailable:\
    \ cannot subscript String with an Int, use a String.Index instead.\n        let\
    \ d = word2[i+1]\n                ^~~~~~~~~~\nSwift.String:3:12: note: 'subscript(_:)'\
    \ has been explicitly marked unavailable here\n    public subscript(i: Int) ->\
    \ Character { get }\n           ^\n/tmp/tmpk7iu4_jp.swift:19:9: warning: initialization\
    \ of variable 'count' was never used; consider replacing with assignment to '_'\
    \ or removing it\n    var count = word.count - 1\n    ~~~~^~~~~\n    _\n/tmp/tmpk7iu4_jp.swift:20:9:\
    \ warning: variable 'word' was never mutated; consider changing to 'let' constant\n\
    \    var word = word\n    ~~~ ^\n    let\n/tmp/tmpk7iu4_jp.swift:21:9: warning:\
    \ variable 'word2' was never mutated; consider changing to 'let' constant\n  \
    \  var word2 = String(word.reversed())\n    ~~~ ^\n    let\n"
  stdout: ''
  timestamp: 1660013566
- exit_code: 1
  program: "\n/// You are given a word. Your task is to find the closest vowel that\
    \ stands between \n/// two consonants from the right side of the word (case sensitive).\n\
    /// Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n/// find any vowel met the above condition. \n/// You may assume that\
    \ the given string contains English letter only.\n/// Example:\n/// >>> get_closest_vowel(word:\
    \ \"yogurt\")\n/// \"u\"\n/// >>> get_closest_vowel(word: \"FULL\")\n/// \"U\"\
    \n/// >>> get_closest_vowel(word: \"quick\")\n/// \"\"\n/// >>> get_closest_vowel(word:\
    \ \"ab\")\n/// \"\"\nfunc get_closest_vowel(word: String) -> String {\n    if\
    \ word.count < 3 {\n        return \"\"\n    }\n    let consonants = \"bcdfghjklmnpqrstvwxyzBCDFGHJKLMNPQRSTVWXYZ\"\
    \n    let vowels = \"aeiouAEIOU\"\n    var i = word.count - 1\n    var last_vowel\
    \ = -1\n    var last_consonant = -1\n    while i >= 0 {\n        if let _ = vowels.range(of:\
    \ String(word[word.index(word.startIndex, offsetBy: i)])) {\n            last_vowel\
    \ = i\n        } else if let _ = consonants.range(of: String(word[word.index(word.startIndex,\
    \ offsetBy: i)])) {\n            last_consonant = i\n            break\n     \
    \   }\n        i -= 1\n    }\n    if last_vowel == -1 || last_consonant == -1\
    \ {\n        return \"\"\n    }\n    i = last_consonant - 1\n    while i >= 0\
    \ {\n        if let _ = vowels.range(of: String(word[word.index(word.startIndex,\
    \ offsetBy: i)])) {\n            last_vowel = i\n            break\n        }\
    \ else if let _ = consonants.range(of: String(word[word.index(word.startIndex,\
    \ offsetBy: i)])) {\n            last_consonant = i\n        }\n        i -= 1\n\
    \    }\n    if last_vowel == -1 || last_consonant == -1 {\n        return \"\"\
    \n    }\n    if last_vowel > last_consonant {\n        return String(word[word.index(word.startIndex,\
    \ offsetBy: last_vowel)])\n    }\n    return \"\"\n}\n\n\nfunc ==(left: [(Int,\
    \ Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n\
    \        return false\n    }\n    for (l, r) in zip(left, right) {\n        if\
    \ l != r {\n            return false\n        }\n    }\n    return true\n}\n \
    \           \nassert(get_closest_vowel(word: \"yogurt\") == \"u\")\nassert(get_closest_vowel(word:\
    \ \"full\") == \"u\")\nassert(get_closest_vowel(word: \"easy\") == \"\")\nassert(get_closest_vowel(word:\
    \ \"eAsy\") == \"\")\nassert(get_closest_vowel(word: \"ali\") == \"\")\nassert(get_closest_vowel(word:\
    \ \"bad\") == \"a\")\nassert(get_closest_vowel(word: \"most\") == \"o\")\nassert(get_closest_vowel(word:\
    \ \"ab\") == \"\")\nassert(get_closest_vowel(word: \"ba\") == \"\")\nassert(get_closest_vowel(word:\
    \ \"quick\") == \"\")\nassert(get_closest_vowel(word: \"anime\") == \"i\")\nassert(get_closest_vowel(word:\
    \ \"Asia\") == \"\")\nassert(get_closest_vowel(word: \"Above\") == \"o\")"
  status: SyntaxError
  stderr: "/tmp/tmpfsh4923l.swift:26:27: error: value of type 'String' has no member\
    \ 'range'\n        if let _ = vowels.range(of: String(word[word.index(word.startIndex,\
    \ offsetBy: i)])) {\n                   ~~~~~~ ^~~~~\n/tmp/tmpfsh4923l.swift:28:38:\
    \ error: value of type 'String' has no member 'range'\n        } else if let _\
    \ = consonants.range(of: String(word[word.index(word.startIndex, offsetBy: i)]))\
    \ {\n                          ~~~~~~~~~~ ^~~~~\n/tmp/tmpfsh4923l.swift:39:27:\
    \ error: value of type 'String' has no member 'range'\n        if let _ = vowels.range(of:\
    \ String(word[word.index(word.startIndex, offsetBy: i)])) {\n                \
    \   ~~~~~~ ^~~~~\n/tmp/tmpfsh4923l.swift:42:38: error: value of type 'String'\
    \ has no member 'range'\n        } else if let _ = consonants.range(of: String(word[word.index(word.startIndex,\
    \ offsetBy: i)])) {\n                          ~~~~~~~~~~ ^~~~~\n"
  stdout: ''
  timestamp: 1660013566
- exit_code: 1
  program: "\n/// You are given a word. Your task is to find the closest vowel that\
    \ stands between \n/// two consonants from the right side of the word (case sensitive).\n\
    /// Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n/// find any vowel met the above condition. \n/// You may assume that\
    \ the given string contains English letter only.\n/// Example:\n/// >>> get_closest_vowel(word:\
    \ \"yogurt\")\n/// \"u\"\n/// >>> get_closest_vowel(word: \"FULL\")\n/// \"U\"\
    \n/// >>> get_closest_vowel(word: \"quick\")\n/// \"\"\n/// >>> get_closest_vowel(word:\
    \ \"ab\")\n/// \"\"\nfunc get_closest_vowel(word: String) -> String {\n    var\
    \ vowels = [\"a\", \"e\", \"i\", \"o\", \"u\"]\n    var first_vowel = \"\"\n \
    \   var second_vowel = \"\"\n    for character in word.characters {\n        if\
    \ vowels.contains(String(character)) && first_vowel == \"\" {\n            first_vowel\
    \ = String(character)\n        } else if vowels.contains(String(character)) &&\
    \ first_vowel != \"\" {\n            second_vowel = String(character)\n      \
    \  }\n    }\n    return second_vowel\n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(get_closest_vowel(word: \"yogurt\") == \"u\")\nassert(get_closest_vowel(word:\
    \ \"full\") == \"u\")\nassert(get_closest_vowel(word: \"easy\") == \"\")\nassert(get_closest_vowel(word:\
    \ \"eAsy\") == \"\")\nassert(get_closest_vowel(word: \"ali\") == \"\")\nassert(get_closest_vowel(word:\
    \ \"bad\") == \"a\")\nassert(get_closest_vowel(word: \"most\") == \"o\")\nassert(get_closest_vowel(word:\
    \ \"ab\") == \"\")\nassert(get_closest_vowel(word: \"ba\") == \"\")\nassert(get_closest_vowel(word:\
    \ \"quick\") == \"\")\nassert(get_closest_vowel(word: \"anime\") == \"i\")\nassert(get_closest_vowel(word:\
    \ \"Asia\") == \"\")\nassert(get_closest_vowel(word: \"Above\") == \"o\")"
  status: SyntaxError
  stderr: "/tmp/tmptpt0beum.swift:20:27: error: 'characters' is unavailable: Please\
    \ use String directly\n    for character in word.characters {\n              \
    \            ^~~~~~~~~~\nSwift.String:5:16: note: 'characters' was obsoleted in\
    \ Swift 5.0\n    public var characters: String { get set }\n               ^\n\
    /tmp/tmptpt0beum.swift:17:9: warning: variable 'vowels' was never mutated; consider\
    \ changing to 'let' constant\n    var vowels = [\"a\", \"e\", \"i\", \"o\", \"\
    u\"]\n    ~~~ ^\n    let\n"
  stdout: ''
  timestamp: 1660013566
- exit_code: -4
  program: "\n/// You are given a word. Your task is to find the closest vowel that\
    \ stands between \n/// two consonants from the right side of the word (case sensitive).\n\
    /// Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n/// find any vowel met the above condition. \n/// You may assume that\
    \ the given string contains English letter only.\n/// Example:\n/// >>> get_closest_vowel(word:\
    \ \"yogurt\")\n/// \"u\"\n/// >>> get_closest_vowel(word: \"FULL\")\n/// \"U\"\
    \n/// >>> get_closest_vowel(word: \"quick\")\n/// \"\"\n/// >>> get_closest_vowel(word:\
    \ \"ab\")\n/// \"\"\nfunc get_closest_vowel(word: String) -> String {\n    //\
    \ TODO: Write implementation here\n    return \"\"\n}\n\n\nfunc ==(left: [(Int,\
    \ Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n\
    \        return false\n    }\n    for (l, r) in zip(left, right) {\n        if\
    \ l != r {\n            return false\n        }\n    }\n    return true\n}\n \
    \           \nassert(get_closest_vowel(word: \"yogurt\") == \"u\")\nassert(get_closest_vowel(word:\
    \ \"full\") == \"u\")\nassert(get_closest_vowel(word: \"easy\") == \"\")\nassert(get_closest_vowel(word:\
    \ \"eAsy\") == \"\")\nassert(get_closest_vowel(word: \"ali\") == \"\")\nassert(get_closest_vowel(word:\
    \ \"bad\") == \"a\")\nassert(get_closest_vowel(word: \"most\") == \"o\")\nassert(get_closest_vowel(word:\
    \ \"ab\") == \"\")\nassert(get_closest_vowel(word: \"ba\") == \"\")\nassert(get_closest_vowel(word:\
    \ \"quick\") == \"\")\nassert(get_closest_vowel(word: \"anime\") == \"i\")\nassert(get_closest_vowel(word:\
    \ \"Asia\") == \"\")\nassert(get_closest_vowel(word: \"Above\") == \"o\")"
  status: Exception
  stderr: 'tmpttcqdqg3/tmpttcqdqg3.swift:34: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b1d03570c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b1d03267b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b1d03267988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b1d032667b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpttcqdqg3                        0x000055ea4bc33307 <unavailable> + 4871

    5    libc.so.6                          0x00002b1d0375c460 __libc_start_main +
    245

    6    tmpttcqdqg3                        0x000055ea4bc32f49 <unavailable> + 3913

    '
  stdout: ''
  timestamp: 1660013566
- exit_code: -4
  program: "\n/// You are given a word. Your task is to find the closest vowel that\
    \ stands between \n/// two consonants from the right side of the word (case sensitive).\n\
    /// Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n/// find any vowel met the above condition. \n/// You may assume that\
    \ the given string contains English letter only.\n/// Example:\n/// >>> get_closest_vowel(word:\
    \ \"yogurt\")\n/// \"u\"\n/// >>> get_closest_vowel(word: \"FULL\")\n/// \"U\"\
    \n/// >>> get_closest_vowel(word: \"quick\")\n/// \"\"\n/// >>> get_closest_vowel(word:\
    \ \"ab\")\n/// \"\"\nfunc get_closest_vowel(word: String) -> String {\n    let\
    \ vowels = \"aeiou\"\n    let consonants = \"bcdfghjklmnpqrstvwxyz\"\n    let\
    \ characterWord = Array(word)\n    var index = 0\n    var result = \"\"\n    while\
    \ index < characterWord.count {\n        if vowels.contains(characterWord[index])\
    \ {\n            if index < characterWord.count - 1 {\n                if consonants.contains(characterWord[index\
    \ + 1]) {\n                    result = String(characterWord[index])\n       \
    \             break\n                }\n            }\n        }\n        index\
    \ += 1\n    }\n    return result\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int,\
    \ Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n\
    \    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n          \
    \  return false\n        }\n    }\n    return true\n}\n            \nassert(get_closest_vowel(word:\
    \ \"yogurt\") == \"u\")\nassert(get_closest_vowel(word: \"full\") == \"u\")\n\
    assert(get_closest_vowel(word: \"easy\") == \"\")\nassert(get_closest_vowel(word:\
    \ \"eAsy\") == \"\")\nassert(get_closest_vowel(word: \"ali\") == \"\")\nassert(get_closest_vowel(word:\
    \ \"bad\") == \"a\")\nassert(get_closest_vowel(word: \"most\") == \"o\")\nassert(get_closest_vowel(word:\
    \ \"ab\") == \"\")\nassert(get_closest_vowel(word: \"ba\") == \"\")\nassert(get_closest_vowel(word:\
    \ \"quick\") == \"\")\nassert(get_closest_vowel(word: \"anime\") == \"i\")\nassert(get_closest_vowel(word:\
    \ \"Asia\") == \"\")\nassert(get_closest_vowel(word: \"Above\") == \"o\")"
  status: Exception
  stderr: 'tmpx9oryc2t/tmpx9oryc2t.swift:49: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b6add240c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b6adcf37b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b6adcf37988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b6adcf367b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpx9oryc2t                        0x0000564e46d8e5b7 <unavailable> + 5559

    5    libc.so.6                          0x00002b6add42c460 __libc_start_main +
    245

    6    tmpx9oryc2t                        0x0000564e46d8e1f9 <unavailable> + 4601

    '
  stdout: ''
  timestamp: 1660013566
- exit_code: -4
  program: "\n/// You are given a word. Your task is to find the closest vowel that\
    \ stands between \n/// two consonants from the right side of the word (case sensitive).\n\
    /// Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n/// find any vowel met the above condition. \n/// You may assume that\
    \ the given string contains English letter only.\n/// Example:\n/// >>> get_closest_vowel(word:\
    \ \"yogurt\")\n/// \"u\"\n/// >>> get_closest_vowel(word: \"FULL\")\n/// \"U\"\
    \n/// >>> get_closest_vowel(word: \"quick\")\n/// \"\"\n/// >>> get_closest_vowel(word:\
    \ \"ab\")\n/// \"\"\nfunc get_closest_vowel(word: String) -> String {\n    let\
    \ vowels = \"AEIOU\"\n    let consonants = \"BCDFGHJKLMNPQRSTVWXYZ\"\n    var\
    \ index: String.Index?\n    var index1: String.Index?\n    var last_index: String.Index?\n\
    \    var i = 0\n    while i < word.count {\n        let index_word = word.index(word.startIndex,\
    \ offsetBy: i)\n        if consonants.contains(word[index_word]) {\n         \
    \   if index == nil {\n                index = index_word\n            } else\
    \ {\n                index1 = index_word\n                break\n            }\n\
    \        }\n        last_index = index_word\n        i += 1\n    }\n    if index\
    \ == nil {\n        return \"\"\n    }\n    if index1 == nil {\n        index1\
    \ = last_index!\n    }\n    i = 0\n    var index_word = index!\n    var l = 1\n\
    \    while i < word.count {\n        index_word = word.index(index!, offsetBy:\
    \ l)\n        if vowels.contains(word[index_word]) {\n            break\n    \
    \    }\n        index_word = word.index(index!, offsetBy: -l)\n        if vowels.contains(word[index_word])\
    \ {\n            break\n        }\n        i += 1\n        l += 1\n    }\n   \
    \ if word.distance(from: index_word, to: index1!) > word.distance(from: index_word,\
    \ to: index!) {\n        return \"\"\n    }\n    return String(word[index_word])\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(get_closest_vowel(word: \"yogurt\") == \"u\")\n\
    assert(get_closest_vowel(word: \"full\") == \"u\")\nassert(get_closest_vowel(word:\
    \ \"easy\") == \"\")\nassert(get_closest_vowel(word: \"eAsy\") == \"\")\nassert(get_closest_vowel(word:\
    \ \"ali\") == \"\")\nassert(get_closest_vowel(word: \"bad\") == \"a\")\nassert(get_closest_vowel(word:\
    \ \"most\") == \"o\")\nassert(get_closest_vowel(word: \"ab\") == \"\")\nassert(get_closest_vowel(word:\
    \ \"ba\") == \"\")\nassert(get_closest_vowel(word: \"quick\") == \"\")\nassert(get_closest_vowel(word:\
    \ \"anime\") == \"i\")\nassert(get_closest_vowel(word: \"Asia\") == \"\")\nassert(get_closest_vowel(word:\
    \ \"Above\") == \"o\")"
  status: Exception
  stderr: 'tmpmexdaflb/tmpmexdaflb.swift:76: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002adc77d9bc80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002adc77a92b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002adc77a92988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002adc77a917b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpmexdaflb                        0x00005654e78056c7 <unavailable> + 5831

    5    libc.so.6                          0x00002adc77f87460 __libc_start_main +
    245

    6    tmpmexdaflb                        0x00005654e7805309 <unavailable> + 4873

    '
  stdout: ''
  timestamp: 1660013566
- exit_code: -4
  program: "\n/// You are given a word. Your task is to find the closest vowel that\
    \ stands between \n/// two consonants from the right side of the word (case sensitive).\n\
    /// Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n/// find any vowel met the above condition. \n/// You may assume that\
    \ the given string contains English letter only.\n/// Example:\n/// >>> get_closest_vowel(word:\
    \ \"yogurt\")\n/// \"u\"\n/// >>> get_closest_vowel(word: \"FULL\")\n/// \"U\"\
    \n/// >>> get_closest_vowel(word: \"quick\")\n/// \"\"\n/// >>> get_closest_vowel(word:\
    \ \"ab\")\n/// \"\"\nfunc get_closest_vowel(word: String) -> String {\n    let\
    \ chars = Array(word)\n    let vowels = [\"a\", \"e\", \"i\", \"o\", \"u\"]\n\
    \    var vowel = \"\"\n    var cons = 0\n    var con = 0\n    for i in chars.indices\
    \ {\n        if vowels.contains(String(chars[i])) {\n            cons = cons +\
    \ 1\n            if cons == 2 {\n                vowel = String(chars[i-1])\n\
    \                break\n            }\n        } else {\n            con = con\
    \ + 1\n        }\n    }\n    if vowel == \"\" {\n        return \"\"\n    } else\
    \ {\n        return vowel\n    }\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int,\
    \ Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n\
    \    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n          \
    \  return false\n        }\n    }\n    return true\n}\n            \nassert(get_closest_vowel(word:\
    \ \"yogurt\") == \"u\")\nassert(get_closest_vowel(word: \"full\") == \"u\")\n\
    assert(get_closest_vowel(word: \"easy\") == \"\")\nassert(get_closest_vowel(word:\
    \ \"eAsy\") == \"\")\nassert(get_closest_vowel(word: \"ali\") == \"\")\nassert(get_closest_vowel(word:\
    \ \"bad\") == \"a\")\nassert(get_closest_vowel(word: \"most\") == \"o\")\nassert(get_closest_vowel(word:\
    \ \"ab\") == \"\")\nassert(get_closest_vowel(word: \"ba\") == \"\")\nassert(get_closest_vowel(word:\
    \ \"quick\") == \"\")\nassert(get_closest_vowel(word: \"anime\") == \"i\")\nassert(get_closest_vowel(word:\
    \ \"Asia\") == \"\")\nassert(get_closest_vowel(word: \"Above\") == \"o\")"
  status: Exception
  stderr: 'tmpprzcbb97/tmpprzcbb97.swift:53: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b4a0293cc80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b4a02633b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b4a02633988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b4a026327b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpprzcbb97                        0x000055692d5b07e7 <unavailable> + 6119

    5    libc.so.6                          0x00002b4a02b28460 __libc_start_main +
    245

    6    tmpprzcbb97                        0x000055692d5b0429 <unavailable> + 5161

    '
  stdout: ''
  timestamp: 1660013566
- exit_code: 1
  program: "\n/// You are given a word. Your task is to find the closest vowel that\
    \ stands between \n/// two consonants from the right side of the word (case sensitive).\n\
    /// Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n/// find any vowel met the above condition. \n/// You may assume that\
    \ the given string contains English letter only.\n/// Example:\n/// >>> get_closest_vowel(word:\
    \ \"yogurt\")\n/// \"u\"\n/// >>> get_closest_vowel(word: \"FULL\")\n/// \"U\"\
    \n/// >>> get_closest_vowel(word: \"quick\")\n/// \"\"\n/// >>> get_closest_vowel(word:\
    \ \"ab\")\n/// \"\"\nfunc get_closest_vowel(word: String) -> String {\n\tlet vowels\
    \ = \"aeiou\"\n\tlet result = word.characters.enumerated().reversed().reduce(\"\
    \") { (res, arg1) -> String in\n\t\tlet (index, char) = arg1\n\t\tlet isConsonant\
    \ = !vowels.contains(char)\n\t\treturn res != \"\" ? res : isConsonant ? \"\"\
    \ : word.substring(with: word.index(word.startIndex, offsetBy: index)..<word.index(word.startIndex,\
    \ offsetBy: index + 1))\n\t}\n\treturn result\n}\n\n\nfunc ==(left: [(Int, Int)],\
    \ right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n       \
    \ return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r\
    \ {\n            return false\n        }\n    }\n    return true\n}\n        \
    \    \nassert(get_closest_vowel(word: \"yogurt\") == \"u\")\nassert(get_closest_vowel(word:\
    \ \"full\") == \"u\")\nassert(get_closest_vowel(word: \"easy\") == \"\")\nassert(get_closest_vowel(word:\
    \ \"eAsy\") == \"\")\nassert(get_closest_vowel(word: \"ali\") == \"\")\nassert(get_closest_vowel(word:\
    \ \"bad\") == \"a\")\nassert(get_closest_vowel(word: \"most\") == \"o\")\nassert(get_closest_vowel(word:\
    \ \"ab\") == \"\")\nassert(get_closest_vowel(word: \"ba\") == \"\")\nassert(get_closest_vowel(word:\
    \ \"quick\") == \"\")\nassert(get_closest_vowel(word: \"anime\") == \"i\")\nassert(get_closest_vowel(word:\
    \ \"Asia\") == \"\")\nassert(get_closest_vowel(word: \"Above\") == \"o\")"
  status: SyntaxError
  stderr: "/tmp/tmplurzup_m.swift:21:52: error: value of type 'String' has no member\
    \ 'substring'\n                return res != \"\" ? res : isConsonant ? \"\" :\
    \ word.substring(with: word.index(word.startIndex, offsetBy: index)..<word.index(word.startIndex,\
    \ offsetBy: index + 1))\n                                                    \
    \        ~~~~ ^~~~~~~~~\n"
  stdout: ''
  timestamp: 1660013566
- exit_code: -4
  program: "\n/// You are given a word. Your task is to find the closest vowel that\
    \ stands between \n/// two consonants from the right side of the word (case sensitive).\n\
    /// Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n/// find any vowel met the above condition. \n/// You may assume that\
    \ the given string contains English letter only.\n/// Example:\n/// >>> get_closest_vowel(word:\
    \ \"yogurt\")\n/// \"u\"\n/// >>> get_closest_vowel(word: \"FULL\")\n/// \"U\"\
    \n/// >>> get_closest_vowel(word: \"quick\")\n/// \"\"\n/// >>> get_closest_vowel(word:\
    \ \"ab\")\n/// \"\"\nfunc get_closest_vowel(word: String) -> String {\n    //\
    \ Your code here\n    var result = \"\"\n    let vowels = \"AEIOU\"\n    var vowelIndex\
    \ = -1\n    var consonantIndex = -1\n    for i in word.indices.reversed() {\n\
    \        let char = word[i]\n        if consonantIndex < 0 {\n            if vowels.contains(char)\
    \ {\n                vowelIndex = i.encodedOffset\n            }\n        } else\
    \ {\n            if !vowels.contains(char) {\n                consonantIndex =\
    \ i.encodedOffset\n                if vowelIndex - consonantIndex > 1 {\n    \
    \                result = String(word[word.index(word.startIndex, offsetBy: vowelIndex)])\n\
    \                    break\n                }\n            }\n        }\n    }\n\
    \    return result\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) ->\
    \ Bool {\n    if left.count != right.count {\n        return false\n    }\n  \
    \  for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(get_closest_vowel(word:\
    \ \"yogurt\") == \"u\")\nassert(get_closest_vowel(word: \"full\") == \"u\")\n\
    assert(get_closest_vowel(word: \"easy\") == \"\")\nassert(get_closest_vowel(word:\
    \ \"eAsy\") == \"\")\nassert(get_closest_vowel(word: \"ali\") == \"\")\nassert(get_closest_vowel(word:\
    \ \"bad\") == \"a\")\nassert(get_closest_vowel(word: \"most\") == \"o\")\nassert(get_closest_vowel(word:\
    \ \"ab\") == \"\")\nassert(get_closest_vowel(word: \"ba\") == \"\")\nassert(get_closest_vowel(word:\
    \ \"quick\") == \"\")\nassert(get_closest_vowel(word: \"anime\") == \"i\")\nassert(get_closest_vowel(word:\
    \ \"Asia\") == \"\")\nassert(get_closest_vowel(word: \"Above\") == \"o\")"
  status: Exception
  stderr: 'tmpw2ida7d3/tmpw2ida7d3.swift:54: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b3b72dfbc80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b3b72af2b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b3b72af2988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b3b72af17b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpw2ida7d3                        0x000055c3a4e5f907 <unavailable> + 6407

    5    libc.so.6                          0x00002b3b72fe7460 __libc_start_main +
    245

    6    tmpw2ida7d3                        0x000055c3a4e5f549 <unavailable> + 5449

    '
  stdout: ''
  timestamp: 1660013566
- exit_code: -4
  program: "\n/// You are given a word. Your task is to find the closest vowel that\
    \ stands between \n/// two consonants from the right side of the word (case sensitive).\n\
    /// Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n/// find any vowel met the above condition. \n/// You may assume that\
    \ the given string contains English letter only.\n/// Example:\n/// >>> get_closest_vowel(word:\
    \ \"yogurt\")\n/// \"u\"\n/// >>> get_closest_vowel(word: \"FULL\")\n/// \"U\"\
    \n/// >>> get_closest_vowel(word: \"quick\")\n/// \"\"\n/// >>> get_closest_vowel(word:\
    \ \"ab\")\n/// \"\"\nfunc get_closest_vowel(word: String) -> String {\n    let\
    \ vowels = [\"a\", \"e\", \"i\", \"o\", \"u\"]\n    let consonants = [\"b\", \"\
    c\", \"d\", \"f\", \"g\", \"h\", \"j\", \"k\", \"l\", \"m\", \"n\", \"p\", \"\
    q\", \"r\", \"s\", \"t\", \"v\", \"w\", \"x\", \"y\", \"z\"]\n    if word.count\
    \ < 3 {\n        return \"\"\n    }\n    var closest_vowel: String = \"\"\n  \
    \  var diff: Int = 0\n    var temp: Int = 0\n    for i in (0..<word.count-1).reversed()\
    \ {\n        if consonants.contains(String(word[word.index(word.startIndex, offsetBy:\
    \ i)])) && consonants.contains(String(word[word.index(word.startIndex, offsetBy:\
    \ i+1)])) {\n            for j in i+1..<word.count {\n                if vowels.contains(String(word[word.index(word.startIndex,\
    \ offsetBy: j)])) {\n                    temp = j - i\n                    if\
    \ temp < diff || diff == 0 {\n                        diff = temp\n          \
    \              closest_vowel = String(word[word.index(word.startIndex, offsetBy:\
    \ j)])\n                    }\n                }\n            }\n        }\n \
    \   }\n    return closest_vowel\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int,\
    \ Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n\
    \    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n          \
    \  return false\n        }\n    }\n    return true\n}\n            \nassert(get_closest_vowel(word:\
    \ \"yogurt\") == \"u\")\nassert(get_closest_vowel(word: \"full\") == \"u\")\n\
    assert(get_closest_vowel(word: \"easy\") == \"\")\nassert(get_closest_vowel(word:\
    \ \"eAsy\") == \"\")\nassert(get_closest_vowel(word: \"ali\") == \"\")\nassert(get_closest_vowel(word:\
    \ \"bad\") == \"a\")\nassert(get_closest_vowel(word: \"most\") == \"o\")\nassert(get_closest_vowel(word:\
    \ \"ab\") == \"\")\nassert(get_closest_vowel(word: \"ba\") == \"\")\nassert(get_closest_vowel(word:\
    \ \"quick\") == \"\")\nassert(get_closest_vowel(word: \"anime\") == \"i\")\nassert(get_closest_vowel(word:\
    \ \"Asia\") == \"\")\nassert(get_closest_vowel(word: \"Above\") == \"o\")"
  status: Exception
  stderr: 'tmpc7k6ghu_/tmpc7k6ghu_.swift:54: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002aba52094c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002aba51d8bb6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002aba51d8b988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002aba51d8a7b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpc7k6ghu_                        0x000055f23e6edae7 <unavailable> + 6887

    5    libc.so.6                          0x00002aba52280460 __libc_start_main +
    245

    6    tmpc7k6ghu_                        0x000055f23e6ed729 <unavailable> + 5929

    '
  stdout: ''
  timestamp: 1660013566
- exit_code: 1
  program: "\n/// You are given a word. Your task is to find the closest vowel that\
    \ stands between \n/// two consonants from the right side of the word (case sensitive).\n\
    /// Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n/// find any vowel met the above condition. \n/// You may assume that\
    \ the given string contains English letter only.\n/// Example:\n/// >>> get_closest_vowel(word:\
    \ \"yogurt\")\n/// \"u\"\n/// >>> get_closest_vowel(word: \"FULL\")\n/// \"U\"\
    \n/// >>> get_closest_vowel(word: \"quick\")\n/// \"\"\n/// >>> get_closest_vowel(word:\
    \ \"ab\")\n/// \"\"\nfunc get_closest_vowel(word: String) -> String {\n    guard\
    \ word.count > 1 else { return \"\" }\n    guard word.count > 2 else { return\
    \ word.is_vowel ? word : \"\" }\n    var vowels = \"\"\n    var consonants = \"\
    \"\n    for character in word {\n        if character.is_vowel {\n           \
    \ vowels.append(character)\n        } else {\n            consonants.append(character)\n\
    \        }\n    }\n    for character in consonants.reversed() {\n        if let\
    \ vowelIndex = vowels.lastIndex(of: character) {\n            return String(vowels[vowelIndex])\n\
    \        }\n    }\n    return \"\"\n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(get_closest_vowel(word: \"yogurt\") == \"u\")\nassert(get_closest_vowel(word:\
    \ \"full\") == \"u\")\nassert(get_closest_vowel(word: \"easy\") == \"\")\nassert(get_closest_vowel(word:\
    \ \"eAsy\") == \"\")\nassert(get_closest_vowel(word: \"ali\") == \"\")\nassert(get_closest_vowel(word:\
    \ \"bad\") == \"a\")\nassert(get_closest_vowel(word: \"most\") == \"o\")\nassert(get_closest_vowel(word:\
    \ \"ab\") == \"\")\nassert(get_closest_vowel(word: \"ba\") == \"\")\nassert(get_closest_vowel(word:\
    \ \"quick\") == \"\")\nassert(get_closest_vowel(word: \"anime\") == \"i\")\nassert(get_closest_vowel(word:\
    \ \"Asia\") == \"\")\nassert(get_closest_vowel(word: \"Above\") == \"o\")"
  status: SyntaxError
  stderr: "/tmp/tmpockzmtro.swift:18:45: error: value of type 'String' has no member\
    \ 'is_vowel'\n    guard word.count > 2 else { return word.is_vowel ? word : \"\
    \" }\n                                       ~~~~ ^~~~~~~~\n/tmp/tmpockzmtro.swift:22:22:\
    \ error: value of type 'Character' has no member 'is_vowel'\n        if character.is_vowel\
    \ {\n           ~~~~~~~~~ ^~~~~~~~\n"
  stdout: ''
  timestamp: 1660013566
- exit_code: 1
  program: "\n/// You are given a word. Your task is to find the closest vowel that\
    \ stands between \n/// two consonants from the right side of the word (case sensitive).\n\
    /// Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n/// find any vowel met the above condition. \n/// You may assume that\
    \ the given string contains English letter only.\n/// Example:\n/// >>> get_closest_vowel(word:\
    \ \"yogurt\")\n/// \"u\"\n/// >>> get_closest_vowel(word: \"FULL\")\n/// \"U\"\
    \n/// >>> get_closest_vowel(word: \"quick\")\n/// \"\"\n/// >>> get_closest_vowel(word:\
    \ \"ab\")\n/// \"\"\nfunc get_closest_vowel(word: String) -> String {\n    let\
    \ vowels = [\"a\", \"e\", \"i\", \"o\", \"u\"]\n    let letters = word.characters.map\
    \ { String($0) }\n    var closest_vowel = \"\"\n    for i in (0..<letters.count).reversed()\
    \ {\n        if vowels.contains(letters[i]) {\n            closest_vowel = letters[i]\n\
    \            if i+1 < letters.count && !vowels.contains(letters[i+1]) {\n    \
    \            break\n            }\n        }\n    }\n    return closest_vowel\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(get_closest_vowel(word: \"yogurt\") == \"u\")\n\
    assert(get_closest_vowel(word: \"full\") == \"u\")\nassert(get_closest_vowel(word:\
    \ \"easy\") == \"\")\nassert(get_closest_vowel(word: \"eAsy\") == \"\")\nassert(get_closest_vowel(word:\
    \ \"ali\") == \"\")\nassert(get_closest_vowel(word: \"bad\") == \"a\")\nassert(get_closest_vowel(word:\
    \ \"most\") == \"o\")\nassert(get_closest_vowel(word: \"ab\") == \"\")\nassert(get_closest_vowel(word:\
    \ \"ba\") == \"\")\nassert(get_closest_vowel(word: \"quick\") == \"\")\nassert(get_closest_vowel(word:\
    \ \"anime\") == \"i\")\nassert(get_closest_vowel(word: \"Asia\") == \"\")\nassert(get_closest_vowel(word:\
    \ \"Above\") == \"o\")"
  status: SyntaxError
  stderr: "/tmp/tmplr_3q5iy.swift:18:24: error: 'characters' is unavailable: Please\
    \ use String directly\n    let letters = word.characters.map { String($0) }\n\
    \                       ^~~~~~~~~~\nSwift.String:5:16: note: 'characters' was\
    \ obsoleted in Swift 5.0\n    public var characters: String { get set }\n    \
    \           ^\n"
  stdout: ''
  timestamp: 1660013566
- exit_code: -4
  program: "\n/// You are given a word. Your task is to find the closest vowel that\
    \ stands between \n/// two consonants from the right side of the word (case sensitive).\n\
    /// Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n/// find any vowel met the above condition. \n/// You may assume that\
    \ the given string contains English letter only.\n/// Example:\n/// >>> get_closest_vowel(word:\
    \ \"yogurt\")\n/// \"u\"\n/// >>> get_closest_vowel(word: \"FULL\")\n/// \"U\"\
    \n/// >>> get_closest_vowel(word: \"quick\")\n/// \"\"\n/// >>> get_closest_vowel(word:\
    \ \"ab\")\n/// \"\"\nfunc get_closest_vowel(word: String) -> String {\n    //\
    \ your code here\n    return \"\"\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int,\
    \ Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n\
    \    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n          \
    \  return false\n        }\n    }\n    return true\n}\n            \nassert(get_closest_vowel(word:\
    \ \"yogurt\") == \"u\")\nassert(get_closest_vowel(word: \"full\") == \"u\")\n\
    assert(get_closest_vowel(word: \"easy\") == \"\")\nassert(get_closest_vowel(word:\
    \ \"eAsy\") == \"\")\nassert(get_closest_vowel(word: \"ali\") == \"\")\nassert(get_closest_vowel(word:\
    \ \"bad\") == \"a\")\nassert(get_closest_vowel(word: \"most\") == \"o\")\nassert(get_closest_vowel(word:\
    \ \"ab\") == \"\")\nassert(get_closest_vowel(word: \"ba\") == \"\")\nassert(get_closest_vowel(word:\
    \ \"quick\") == \"\")\nassert(get_closest_vowel(word: \"anime\") == \"i\")\nassert(get_closest_vowel(word:\
    \ \"Asia\") == \"\")\nassert(get_closest_vowel(word: \"Above\") == \"o\")"
  status: Exception
  stderr: 'tmpa6wfme3m/tmpa6wfme3m.swift:34: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002ba5af6cec80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002ba5af3c5b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002ba5af3c5988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002ba5af3c47b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpa6wfme3m                        0x000055734e3d0307 <unavailable> + 4871

    5    libc.so.6                          0x00002ba5af8ba460 __libc_start_main +
    245

    6    tmpa6wfme3m                        0x000055734e3cff49 <unavailable> + 3913

    '
  stdout: ''
  timestamp: 1660013566
- exit_code: -4
  program: "\n/// You are given a word. Your task is to find the closest vowel that\
    \ stands between \n/// two consonants from the right side of the word (case sensitive).\n\
    /// Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n/// find any vowel met the above condition. \n/// You may assume that\
    \ the given string contains English letter only.\n/// Example:\n/// >>> get_closest_vowel(word:\
    \ \"yogurt\")\n/// \"u\"\n/// >>> get_closest_vowel(word: \"FULL\")\n/// \"U\"\
    \n/// >>> get_closest_vowel(word: \"quick\")\n/// \"\"\n/// >>> get_closest_vowel(word:\
    \ \"ab\")\n/// \"\"\nfunc get_closest_vowel(word: String) -> String {\n    return\
    \ \"\"\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n  \
    \  if left.count != right.count {\n        return false\n    }\n    for (l, r)\
    \ in zip(left, right) {\n        if l != r {\n            return false\n     \
    \   }\n    }\n    return true\n}\n            \nassert(get_closest_vowel(word:\
    \ \"yogurt\") == \"u\")\nassert(get_closest_vowel(word: \"full\") == \"u\")\n\
    assert(get_closest_vowel(word: \"easy\") == \"\")\nassert(get_closest_vowel(word:\
    \ \"eAsy\") == \"\")\nassert(get_closest_vowel(word: \"ali\") == \"\")\nassert(get_closest_vowel(word:\
    \ \"bad\") == \"a\")\nassert(get_closest_vowel(word: \"most\") == \"o\")\nassert(get_closest_vowel(word:\
    \ \"ab\") == \"\")\nassert(get_closest_vowel(word: \"ba\") == \"\")\nassert(get_closest_vowel(word:\
    \ \"quick\") == \"\")\nassert(get_closest_vowel(word: \"anime\") == \"i\")\nassert(get_closest_vowel(word:\
    \ \"Asia\") == \"\")\nassert(get_closest_vowel(word: \"Above\") == \"o\")"
  status: Exception
  stderr: 'tmpvf1hzub_/tmpvf1hzub_.swift:33: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002ba694399c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002ba694090b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002ba694090988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002ba69408f7b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpvf1hzub_                        0x00005567315f8307 <unavailable> + 4871

    5    libc.so.6                          0x00002ba694585460 __libc_start_main +
    245

    6    tmpvf1hzub_                        0x00005567315f7f49 <unavailable> + 3913

    '
  stdout: ''
  timestamp: 1660013566
- exit_code: -4
  program: "\n/// You are given a word. Your task is to find the closest vowel that\
    \ stands between \n/// two consonants from the right side of the word (case sensitive).\n\
    /// Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n/// find any vowel met the above condition. \n/// You may assume that\
    \ the given string contains English letter only.\n/// Example:\n/// >>> get_closest_vowel(word:\
    \ \"yogurt\")\n/// \"u\"\n/// >>> get_closest_vowel(word: \"FULL\")\n/// \"U\"\
    \n/// >>> get_closest_vowel(word: \"quick\")\n/// \"\"\n/// >>> get_closest_vowel(word:\
    \ \"ab\")\n/// \"\"\nfunc get_closest_vowel(word: String) -> String {\n    var\
    \ vowels = Set<Character>()\n    vowels.insert(\"a\")\n    vowels.insert(\"e\"\
    )\n    vowels.insert(\"i\")\n    vowels.insert(\"o\")\n    vowels.insert(\"u\"\
    )\n    vowels.insert(\"A\")\n    vowels.insert(\"E\")\n    vowels.insert(\"I\"\
    )\n    vowels.insert(\"O\")\n    vowels.insert(\"U\")\n    var strArray = Array(word)\n\
    \    var index = strArray.count - 1\n    var flag = false\n    var indexVowel\
    \ = 0\n    for char in strArray {\n        if vowels.contains(char) {\n      \
    \      if flag {\n                return String(char)\n            }\n       \
    \     indexVowel = index\n        } else {\n            if indexVowel != 0 {\n\
    \                flag = true\n            }\n        }\n        index -= 1\n \
    \   }\n    return \"\"\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(get_closest_vowel(word:\
    \ \"yogurt\") == \"u\")\nassert(get_closest_vowel(word: \"full\") == \"u\")\n\
    assert(get_closest_vowel(word: \"easy\") == \"\")\nassert(get_closest_vowel(word:\
    \ \"eAsy\") == \"\")\nassert(get_closest_vowel(word: \"ali\") == \"\")\nassert(get_closest_vowel(word:\
    \ \"bad\") == \"a\")\nassert(get_closest_vowel(word: \"most\") == \"o\")\nassert(get_closest_vowel(word:\
    \ \"ab\") == \"\")\nassert(get_closest_vowel(word: \"ba\") == \"\")\nassert(get_closest_vowel(word:\
    \ \"quick\") == \"\")\nassert(get_closest_vowel(word: \"anime\") == \"i\")\nassert(get_closest_vowel(word:\
    \ \"Asia\") == \"\")\nassert(get_closest_vowel(word: \"Above\") == \"o\")"
  status: Exception
  stderr: 'tmp_33jfv7a/tmp_33jfv7a.swift:62: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b939cc6cc80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b939c963b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b939c963988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b939c9627b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmp_33jfv7a                        0x000055b0ac3fc957 <unavailable> + 6487

    5    libc.so.6                          0x00002b939ce58460 __libc_start_main +
    245

    6    tmp_33jfv7a                        0x000055b0ac3fc4a9 <unavailable> + 5289

    '
  stdout: ''
  timestamp: 1660013566
- exit_code: 1
  program: "\n/// You are given a word. Your task is to find the closest vowel that\
    \ stands between \n/// two consonants from the right side of the word (case sensitive).\n\
    /// Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n/// find any vowel met the above condition. \n/// You may assume that\
    \ the given string contains English letter only.\n/// Example:\n/// >>> get_closest_vowel(word:\
    \ \"yogurt\")\n/// \"u\"\n/// >>> get_closest_vowel(word: \"FULL\")\n/// \"U\"\
    \n/// >>> get_closest_vowel(word: \"quick\")\n/// \"\"\n/// >>> get_closest_vowel(word:\
    \ \"ab\")\n/// \"\"\nfunc get_closest_vowel(word: String) -> String {\n    let\
    \ vowels = \"aeiou\"\n    let consonants = \"bcdfghjklmnpqrstvwxyz\"\n    let\
    \ word = word.lowercased()\n    var vowel_count = 0\n    for character in word\
    \ {\n        if vowels.contains(character) {\n            vowel_count += 1\n \
    \       }\n    }\n    if vowel_count == 0 {\n        return \"\"\n    }\n    for\
    \ i in stride(from: (word.count - 1), through: 0, by: -1) {\n        if consonants.contains(word[i])\
    \ {\n            for j in stride(from: (i - 1), through: 0, by: -1) {\n      \
    \          if vowels.contains(word[j]) {\n                    return String(word[j])\n\
    \                }\n            }\n        }\n    }\n    return \"\"\n}\n\n\n\
    func ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(get_closest_vowel(word: \"yogurt\") == \"u\")\n\
    assert(get_closest_vowel(word: \"full\") == \"u\")\nassert(get_closest_vowel(word:\
    \ \"easy\") == \"\")\nassert(get_closest_vowel(word: \"eAsy\") == \"\")\nassert(get_closest_vowel(word:\
    \ \"ali\") == \"\")\nassert(get_closest_vowel(word: \"bad\") == \"a\")\nassert(get_closest_vowel(word:\
    \ \"most\") == \"o\")\nassert(get_closest_vowel(word: \"ab\") == \"\")\nassert(get_closest_vowel(word:\
    \ \"ba\") == \"\")\nassert(get_closest_vowel(word: \"quick\") == \"\")\nassert(get_closest_vowel(word:\
    \ \"anime\") == \"i\")\nassert(get_closest_vowel(word: \"Asia\") == \"\")\nassert(get_closest_vowel(word:\
    \ \"Above\") == \"o\")"
  status: SyntaxError
  stderr: "/tmp/tmpfa9aw63f.swift:30:32: error: 'subscript(_:)' is unavailable: cannot\
    \ subscript String with an Int, use a String.Index instead.\n        if consonants.contains(word[i])\
    \ {\n                               ^~~~~~~\nSwift.String:3:12: note: 'subscript(_:)'\
    \ has been explicitly marked unavailable here\n    public subscript(i: Int) ->\
    \ Character { get }\n           ^\n/tmp/tmpfa9aw63f.swift:32:36: error: 'subscript(_:)'\
    \ is unavailable: cannot subscript String with an Int, use a String.Index instead.\n\
    \                if vowels.contains(word[j]) {\n                             \
    \      ^~~~~~~\nSwift.String:3:12: note: 'subscript(_:)' has been explicitly marked\
    \ unavailable here\n    public subscript(i: Int) -> Character { get }\n      \
    \     ^\n/tmp/tmpfa9aw63f.swift:33:35: error: 'subscript(_:)' is unavailable:\
    \ cannot subscript String with an Int, use a String.Index instead.\n         \
    \           return String(word[j])\n                                  ^~~~~~~\n\
    Swift.String:3:12: note: 'subscript(_:)' has been explicitly marked unavailable\
    \ here\n    public subscript(i: Int) -> Character { get }\n           ^\n"
  stdout: ''
  timestamp: 1660013566
- exit_code: 1
  program: "\n/// You are given a word. Your task is to find the closest vowel that\
    \ stands between \n/// two consonants from the right side of the word (case sensitive).\n\
    /// Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n/// find any vowel met the above condition. \n/// You may assume that\
    \ the given string contains English letter only.\n/// Example:\n/// >>> get_closest_vowel(word:\
    \ \"yogurt\")\n/// \"u\"\n/// >>> get_closest_vowel(word: \"FULL\")\n/// \"U\"\
    \n/// >>> get_closest_vowel(word: \"quick\")\n/// \"\"\n/// >>> get_closest_vowel(word:\
    \ \"ab\")\n/// \"\"\nfunc get_closest_vowel(word: String) -> String {\n    var\
    \ vowels = Set<Character>()\n    vowels.insert(\"a\")\n    vowels.insert(\"e\"\
    )\n    vowels.insert(\"i\")\n    vowels.insert(\"o\")\n    vowels.insert(\"u\"\
    )\n    vowels.insert(\"A\")\n    vowels.insert(\"E\")\n    vowels.insert(\"I\"\
    )\n    vowels.insert(\"O\")\n    vowels.insert(\"U\")\n    for char in word.characters.reversed()\
    \ {\n        if vowels.contains(char) {\n            return String(char)\n   \
    \     }\n    }\n    return \"\"\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int,\
    \ Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n\
    \    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n          \
    \  return false\n        }\n    }\n    return true\n}\n            \nassert(get_closest_vowel(word:\
    \ \"yogurt\") == \"u\")\nassert(get_closest_vowel(word: \"full\") == \"u\")\n\
    assert(get_closest_vowel(word: \"easy\") == \"\")\nassert(get_closest_vowel(word:\
    \ \"eAsy\") == \"\")\nassert(get_closest_vowel(word: \"ali\") == \"\")\nassert(get_closest_vowel(word:\
    \ \"bad\") == \"a\")\nassert(get_closest_vowel(word: \"most\") == \"o\")\nassert(get_closest_vowel(word:\
    \ \"ab\") == \"\")\nassert(get_closest_vowel(word: \"ba\") == \"\")\nassert(get_closest_vowel(word:\
    \ \"quick\") == \"\")\nassert(get_closest_vowel(word: \"anime\") == \"i\")\nassert(get_closest_vowel(word:\
    \ \"Asia\") == \"\")\nassert(get_closest_vowel(word: \"Above\") == \"o\")"
  status: SyntaxError
  stderr: "/tmp/tmpe76i_drc.swift:28:22: error: 'characters' is unavailable: Please\
    \ use String directly\n    for char in word.characters.reversed() {\n        \
    \             ^~~~~~~~~~\nSwift.String:5:16: note: 'characters' was obsoleted\
    \ in Swift 5.0\n    public var characters: String { get set }\n              \
    \ ^\n"
  stdout: ''
  timestamp: 1660013566
- exit_code: 1
  program: "\n/// You are given a word. Your task is to find the closest vowel that\
    \ stands between \n/// two consonants from the right side of the word (case sensitive).\n\
    /// Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n/// find any vowel met the above condition. \n/// You may assume that\
    \ the given string contains English letter only.\n/// Example:\n/// >>> get_closest_vowel(word:\
    \ \"yogurt\")\n/// \"u\"\n/// >>> get_closest_vowel(word: \"FULL\")\n/// \"U\"\
    \n/// >>> get_closest_vowel(word: \"quick\")\n/// \"\"\n/// >>> get_closest_vowel(word:\
    \ \"ab\")\n/// \"\"\nfunc get_closest_vowel(word: String) -> String {\n\tvar first_consonant\
    \ = false, closest_vowel: Character? = nil, closest_index = 0\n\tlet vowels =\
    \ [\"a\", \"e\", \"i\", \"o\", \"u\"]\n\tfor (index, character) in word.reversed().enumerated()\
    \ {\n\t\tif !vowels.contains(String(character).lowercased()) {\n\t\t\tif !first_consonant\
    \ {\n\t\t\t\tfirst_consonant = true\n\t\t\t} else {\n\t\t\t\tbreak\n\t\t\t}\n\t\
    \t} else {\n\t\t\tif first_consonant {\n\t\t\t\tclosest_vowel = character\n\t\t\
    \t\tclosest_index = index\n\t\t\t}\n\t\t}\n\t}\n\treturn String(closest_vowel\
    \ ?? \"\")\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n\
    \    if left.count != right.count {\n        return false\n    }\n    for (l,\
    \ r) in zip(left, right) {\n        if l != r {\n            return false\n  \
    \      }\n    }\n    return true\n}\n            \nassert(get_closest_vowel(word:\
    \ \"yogurt\") == \"u\")\nassert(get_closest_vowel(word: \"full\") == \"u\")\n\
    assert(get_closest_vowel(word: \"easy\") == \"\")\nassert(get_closest_vowel(word:\
    \ \"eAsy\") == \"\")\nassert(get_closest_vowel(word: \"ali\") == \"\")\nassert(get_closest_vowel(word:\
    \ \"bad\") == \"a\")\nassert(get_closest_vowel(word: \"most\") == \"o\")\nassert(get_closest_vowel(word:\
    \ \"ab\") == \"\")\nassert(get_closest_vowel(word: \"ba\") == \"\")\nassert(get_closest_vowel(word:\
    \ \"quick\") == \"\")\nassert(get_closest_vowel(word: \"anime\") == \"i\")\nassert(get_closest_vowel(word:\
    \ \"Asia\") == \"\")\nassert(get_closest_vowel(word: \"Above\") == \"o\")"
  status: SyntaxError
  stderr: "/tmp/tmpejp2lze0.swift:33:33: error: cannot convert value of type 'String'\
    \ to expected argument type 'Character'\n        return String(closest_vowel ??\
    \ \"\")\n                                       ^\n"
  stdout: ''
  timestamp: 1660013566
- exit_code: -4
  program: "\n/// You are given a word. Your task is to find the closest vowel that\
    \ stands between \n/// two consonants from the right side of the word (case sensitive).\n\
    /// Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n/// find any vowel met the above condition. \n/// You may assume that\
    \ the given string contains English letter only.\n/// Example:\n/// >>> get_closest_vowel(word:\
    \ \"yogurt\")\n/// \"u\"\n/// >>> get_closest_vowel(word: \"FULL\")\n/// \"U\"\
    \n/// >>> get_closest_vowel(word: \"quick\")\n/// \"\"\n/// >>> get_closest_vowel(word:\
    \ \"ab\")\n/// \"\"\nfunc get_closest_vowel(word: String) -> String {\n    return\
    \ \"\"\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n  \
    \  if left.count != right.count {\n        return false\n    }\n    for (l, r)\
    \ in zip(left, right) {\n        if l != r {\n            return false\n     \
    \   }\n    }\n    return true\n}\n            \nassert(get_closest_vowel(word:\
    \ \"yogurt\") == \"u\")\nassert(get_closest_vowel(word: \"full\") == \"u\")\n\
    assert(get_closest_vowel(word: \"easy\") == \"\")\nassert(get_closest_vowel(word:\
    \ \"eAsy\") == \"\")\nassert(get_closest_vowel(word: \"ali\") == \"\")\nassert(get_closest_vowel(word:\
    \ \"bad\") == \"a\")\nassert(get_closest_vowel(word: \"most\") == \"o\")\nassert(get_closest_vowel(word:\
    \ \"ab\") == \"\")\nassert(get_closest_vowel(word: \"ba\") == \"\")\nassert(get_closest_vowel(word:\
    \ \"quick\") == \"\")\nassert(get_closest_vowel(word: \"anime\") == \"i\")\nassert(get_closest_vowel(word:\
    \ \"Asia\") == \"\")\nassert(get_closest_vowel(word: \"Above\") == \"o\")"
  status: Exception
  stderr: 'tmpvf1hzub_/tmpvf1hzub_.swift:33: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002ba694399c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002ba694090b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002ba694090988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002ba69408f7b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpvf1hzub_                        0x00005567315f8307 <unavailable> + 4871

    5    libc.so.6                          0x00002ba694585460 __libc_start_main +
    245

    6    tmpvf1hzub_                        0x00005567315f7f49 <unavailable> + 3913

    '
  stdout: ''
  timestamp: 1660013566
- exit_code: -4
  program: "\n/// You are given a word. Your task is to find the closest vowel that\
    \ stands between \n/// two consonants from the right side of the word (case sensitive).\n\
    /// Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n/// find any vowel met the above condition. \n/// You may assume that\
    \ the given string contains English letter only.\n/// Example:\n/// >>> get_closest_vowel(word:\
    \ \"yogurt\")\n/// \"u\"\n/// >>> get_closest_vowel(word: \"FULL\")\n/// \"U\"\
    \n/// >>> get_closest_vowel(word: \"quick\")\n/// \"\"\n/// >>> get_closest_vowel(word:\
    \ \"ab\")\n/// \"\"\nfunc get_closest_vowel(word: String) -> String {\n    var\
    \ result = \"\"\n    let vowels: Set<Character> = [\"a\", \"e\", \"i\", \"o\"\
    , \"u\"]\n    var consonants: Set<Character> = []\n    for char in word {\n  \
    \      if !vowels.contains(char) {\n            consonants.insert(char)\n    \
    \    }\n    }\n    var pvowel = \"\"\n    var nvowel = \"\"\n    var pcon = \"\
    \"\n    var ncon = \"\"\n    for char in word {\n        if consonants.contains(char)\
    \ {\n            if pvowel != \"\" {\n                ncon = String(char)\n  \
    \              break\n            }\n            pcon = String(char)\n       \
    \ } else {\n            if pcon != \"\" {\n                pvowel = String(char)\n\
    \            }\n        }\n    }\n    if pvowel != \"\" && ncon != \"\" {\n  \
    \      result = pvowel\n    }\n    return result\n}\n\n\nfunc ==(left: [(Int,\
    \ Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n\
    \        return false\n    }\n    for (l, r) in zip(left, right) {\n        if\
    \ l != r {\n            return false\n        }\n    }\n    return true\n}\n \
    \           \nassert(get_closest_vowel(word: \"yogurt\") == \"u\")\nassert(get_closest_vowel(word:\
    \ \"full\") == \"u\")\nassert(get_closest_vowel(word: \"easy\") == \"\")\nassert(get_closest_vowel(word:\
    \ \"eAsy\") == \"\")\nassert(get_closest_vowel(word: \"ali\") == \"\")\nassert(get_closest_vowel(word:\
    \ \"bad\") == \"a\")\nassert(get_closest_vowel(word: \"most\") == \"o\")\nassert(get_closest_vowel(word:\
    \ \"ab\") == \"\")\nassert(get_closest_vowel(word: \"ba\") == \"\")\nassert(get_closest_vowel(word:\
    \ \"quick\") == \"\")\nassert(get_closest_vowel(word: \"anime\") == \"i\")\nassert(get_closest_vowel(word:\
    \ \"Asia\") == \"\")\nassert(get_closest_vowel(word: \"Above\") == \"o\")"
  status: Exception
  stderr: 'tmpr2_10e56/tmpr2_10e56.swift:61: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002aeef349bc80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002aeef3192b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002aeef3192988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002aeef31917b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpr2_10e56                        0x00005574e4899747 <unavailable> + 5959

    5    libc.so.6                          0x00002aeef3687460 __libc_start_main +
    245

    6    tmpr2_10e56                        0x00005574e4899389 <unavailable> + 5001

    '
  stdout: ''
  timestamp: 1660013566
- exit_code: -4
  program: "\n/// You are given a word. Your task is to find the closest vowel that\
    \ stands between \n/// two consonants from the right side of the word (case sensitive).\n\
    /// Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n/// find any vowel met the above condition. \n/// You may assume that\
    \ the given string contains English letter only.\n/// Example:\n/// >>> get_closest_vowel(word:\
    \ \"yogurt\")\n/// \"u\"\n/// >>> get_closest_vowel(word: \"FULL\")\n/// \"U\"\
    \n/// >>> get_closest_vowel(word: \"quick\")\n/// \"\"\n/// >>> get_closest_vowel(word:\
    \ \"ab\")\n/// \"\"\nfunc get_closest_vowel(word: String) -> String {\n    let\
    \ vowel_set = Set(\"aeiouAEIOU\")\n    let consonant_set = Set(\"bcdfghjklmnpqrstvwxyzBCDFGHJKLMNPQRSTVWXYZ\"\
    )\n    let char_arr = Array(word)\n    for i in (0...char_arr.count-1).reversed()\
    \ {\n        if i != 0 && vowel_set.contains(char_arr[i]) && consonant_set.contains(char_arr[i-1])\
    \ {\n            return String(char_arr[i])\n        }\n    }\n    return \"\"\
    \n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(get_closest_vowel(word: \"yogurt\") == \"u\")\n\
    assert(get_closest_vowel(word: \"full\") == \"u\")\nassert(get_closest_vowel(word:\
    \ \"easy\") == \"\")\nassert(get_closest_vowel(word: \"eAsy\") == \"\")\nassert(get_closest_vowel(word:\
    \ \"ali\") == \"\")\nassert(get_closest_vowel(word: \"bad\") == \"a\")\nassert(get_closest_vowel(word:\
    \ \"most\") == \"o\")\nassert(get_closest_vowel(word: \"ab\") == \"\")\nassert(get_closest_vowel(word:\
    \ \"ba\") == \"\")\nassert(get_closest_vowel(word: \"quick\") == \"\")\nassert(get_closest_vowel(word:\
    \ \"anime\") == \"i\")\nassert(get_closest_vowel(word: \"Asia\") == \"\")\nassert(get_closest_vowel(word:\
    \ \"Above\") == \"o\")"
  status: Exception
  stderr: 'tmpzy7tyr52/tmpzy7tyr52.swift:45: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b42bca02c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b42bc6f9b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b42bc6f9988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b42bc6f87b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpzy7tyr52                        0x00005612f583ee0b <unavailable> + 7691

    5    libc.so.6                          0x00002b42bcbee460 __libc_start_main +
    245

    6    tmpzy7tyr52                        0x00005612f583e609 <unavailable> + 5641

    '
  stdout: ''
  timestamp: 1660013566
- exit_code: -4
  program: "\n/// You are given a word. Your task is to find the closest vowel that\
    \ stands between \n/// two consonants from the right side of the word (case sensitive).\n\
    /// Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n/// find any vowel met the above condition. \n/// You may assume that\
    \ the given string contains English letter only.\n/// Example:\n/// >>> get_closest_vowel(word:\
    \ \"yogurt\")\n/// \"u\"\n/// >>> get_closest_vowel(word: \"FULL\")\n/// \"U\"\
    \n/// >>> get_closest_vowel(word: \"quick\")\n/// \"\"\n/// >>> get_closest_vowel(word:\
    \ \"ab\")\n/// \"\"\nfunc get_closest_vowel(word: String) -> String {\n    var\
    \ vowels: Set<Character> = [\"a\", \"e\", \"i\", \"o\", \"u\"]\n    var vowelFinder:\
    \ String = \"\"\n    var vowelsArray: [Character] = []\n    for (index, char)\
    \ in word.enumerated() {\n        if vowels.contains(char) {\n            vowelFinder\
    \ = \"\\(char)\"\n            vowelsArray.append(char)\n        }\n    }\n   \
    \ if vowelFinder == \"\" {\n        return \"\"\n    }\n    else {\n        return\
    \ String(vowelsArray.last!)\n    }\n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(get_closest_vowel(word: \"yogurt\") == \"u\")\nassert(get_closest_vowel(word:\
    \ \"full\") == \"u\")\nassert(get_closest_vowel(word: \"easy\") == \"\")\nassert(get_closest_vowel(word:\
    \ \"eAsy\") == \"\")\nassert(get_closest_vowel(word: \"ali\") == \"\")\nassert(get_closest_vowel(word:\
    \ \"bad\") == \"a\")\nassert(get_closest_vowel(word: \"most\") == \"o\")\nassert(get_closest_vowel(word:\
    \ \"ab\") == \"\")\nassert(get_closest_vowel(word: \"ba\") == \"\")\nassert(get_closest_vowel(word:\
    \ \"quick\") == \"\")\nassert(get_closest_vowel(word: \"anime\") == \"i\")\nassert(get_closest_vowel(word:\
    \ \"Asia\") == \"\")\nassert(get_closest_vowel(word: \"Above\") == \"o\")"
  status: Exception
  stderr: 'tmpi1i9bllf/tmpi1i9bllf.swift:49: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b8af4b07c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b8af47feb6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b8af47fe988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b8af47fd7b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpi1i9bllf                        0x0000560d6feabf03 <unavailable> + 7939

    5    libc.so.6                          0x00002b8af4cf3460 __libc_start_main +
    245

    6    tmpi1i9bllf                        0x0000560d6feab939 <unavailable> + 6457

    '
  stdout: ''
  timestamp: 1660013566
- exit_code: -4
  program: "\n/// You are given a word. Your task is to find the closest vowel that\
    \ stands between \n/// two consonants from the right side of the word (case sensitive).\n\
    /// Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n/// find any vowel met the above condition. \n/// You may assume that\
    \ the given string contains English letter only.\n/// Example:\n/// >>> get_closest_vowel(word:\
    \ \"yogurt\")\n/// \"u\"\n/// >>> get_closest_vowel(word: \"FULL\")\n/// \"U\"\
    \n/// >>> get_closest_vowel(word: \"quick\")\n/// \"\"\n/// >>> get_closest_vowel(word:\
    \ \"ab\")\n/// \"\"\nfunc get_closest_vowel(word: String) -> String {\n    //\
    \ your code here\n    let vowels = [\"a\", \"e\", \"i\", \"o\", \"u\"]\n    var\
    \ left: String?\n    var right: String?\n    var vowel = \"\"\n    for char in\
    \ word.reversed() {\n        if let idx = vowels.firstIndex(of: String(char))\
    \ {\n            vowel = String(char)\n            break\n        }\n        if\
    \ left == nil {\n            left = String(char)\n        } else {\n         \
    \   right = left\n            left = String(char)\n        }\n    }\n    if left\
    \ == nil || right == nil {\n        return \"\"\n    }\n    return vowel\n}\n\n\
    \nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(get_closest_vowel(word: \"yogurt\") == \"u\")\n\
    assert(get_closest_vowel(word: \"full\") == \"u\")\nassert(get_closest_vowel(word:\
    \ \"easy\") == \"\")\nassert(get_closest_vowel(word: \"eAsy\") == \"\")\nassert(get_closest_vowel(word:\
    \ \"ali\") == \"\")\nassert(get_closest_vowel(word: \"bad\") == \"a\")\nassert(get_closest_vowel(word:\
    \ \"most\") == \"o\")\nassert(get_closest_vowel(word: \"ab\") == \"\")\nassert(get_closest_vowel(word:\
    \ \"ba\") == \"\")\nassert(get_closest_vowel(word: \"quick\") == \"\")\nassert(get_closest_vowel(word:\
    \ \"anime\") == \"i\")\nassert(get_closest_vowel(word: \"Asia\") == \"\")\nassert(get_closest_vowel(word:\
    \ \"Above\") == \"o\")"
  status: Exception
  stderr: 'tmpxy13yg8c/tmpxy13yg8c.swift:55: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b88567d4c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b88564cbb6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b88564cb988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b88564ca7b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpxy13yg8c                        0x000055a0209f59c3 <unavailable> + 6595

    5    libc.so.6                          0x00002b88569c0460 __libc_start_main +
    245

    6    tmpxy13yg8c                        0x000055a0209f53f9 <unavailable> + 5113

    '
  stdout: ''
  timestamp: 1660013566
- exit_code: -4
  program: "\n/// You are given a word. Your task is to find the closest vowel that\
    \ stands between \n/// two consonants from the right side of the word (case sensitive).\n\
    /// Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n/// find any vowel met the above condition. \n/// You may assume that\
    \ the given string contains English letter only.\n/// Example:\n/// >>> get_closest_vowel(word:\
    \ \"yogurt\")\n/// \"u\"\n/// >>> get_closest_vowel(word: \"FULL\")\n/// \"U\"\
    \n/// >>> get_closest_vowel(word: \"quick\")\n/// \"\"\n/// >>> get_closest_vowel(word:\
    \ \"ab\")\n/// \"\"\nfunc get_closest_vowel(word: String) -> String {\n    let\
    \ vowels = \"AEIOUaeiou\"\n    var counter = word.count - 1\n    var result =\
    \ \"\"\n    while counter > 0 {\n        let index = word.index(word.startIndex,\
    \ offsetBy: counter)\n        let char = word[index]\n        if vowels.contains(char)\
    \ {\n            result = String(char)\n            break\n        }\n       \
    \ counter -= 1\n    }\n    return result\n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(get_closest_vowel(word: \"yogurt\") == \"u\")\nassert(get_closest_vowel(word:\
    \ \"full\") == \"u\")\nassert(get_closest_vowel(word: \"easy\") == \"\")\nassert(get_closest_vowel(word:\
    \ \"eAsy\") == \"\")\nassert(get_closest_vowel(word: \"ali\") == \"\")\nassert(get_closest_vowel(word:\
    \ \"bad\") == \"a\")\nassert(get_closest_vowel(word: \"most\") == \"o\")\nassert(get_closest_vowel(word:\
    \ \"ab\") == \"\")\nassert(get_closest_vowel(word: \"ba\") == \"\")\nassert(get_closest_vowel(word:\
    \ \"quick\") == \"\")\nassert(get_closest_vowel(word: \"anime\") == \"i\")\nassert(get_closest_vowel(word:\
    \ \"Asia\") == \"\")\nassert(get_closest_vowel(word: \"Above\") == \"o\")"
  status: Exception
  stderr: 'tmphyinyi57/tmphyinyi57.swift:47: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002aaeeea4ac80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002aaeee741b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002aaeee741988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002aaeee7407b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmphyinyi57                        0x000056539ed1c7e3 <unavailable> + 6115

    5    libc.so.6                          0x00002aaeeec36460 __libc_start_main +
    245

    6    tmphyinyi57                        0x000056539ed1c219 <unavailable> + 4633

    '
  stdout: ''
  timestamp: 1660013566
- exit_code: -4
  program: "\n/// You are given a word. Your task is to find the closest vowel that\
    \ stands between \n/// two consonants from the right side of the word (case sensitive).\n\
    /// Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n/// find any vowel met the above condition. \n/// You may assume that\
    \ the given string contains English letter only.\n/// Example:\n/// >>> get_closest_vowel(word:\
    \ \"yogurt\")\n/// \"u\"\n/// >>> get_closest_vowel(word: \"FULL\")\n/// \"U\"\
    \n/// >>> get_closest_vowel(word: \"quick\")\n/// \"\"\n/// >>> get_closest_vowel(word:\
    \ \"ab\")\n/// \"\"\nfunc get_closest_vowel(word: String) -> String {\n    let\
    \ vowels = [\"a\", \"e\", \"i\", \"o\", \"u\"]\n    let word = word.lowercased()\n\
    \    for (index, character) in word.enumerated() {\n        if (index == word.count\
    \ - 1) {\n            return \"\"\n        }\n        if (vowels.contains(String(character)))\
    \ {\n            if (vowels.contains(String(word[word.index(word.startIndex, offsetBy:\
    \ index - 1)]))) {\n                return \"\"\n            }\n            return\
    \ String(character)\n        }\n    }\n    return \"\"\n}\n\n\nfunc ==(left: [(Int,\
    \ Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n\
    \        return false\n    }\n    for (l, r) in zip(left, right) {\n        if\
    \ l != r {\n            return false\n        }\n    }\n    return true\n}\n \
    \           \nassert(get_closest_vowel(word: \"yogurt\") == \"u\")\nassert(get_closest_vowel(word:\
    \ \"full\") == \"u\")\nassert(get_closest_vowel(word: \"easy\") == \"\")\nassert(get_closest_vowel(word:\
    \ \"eAsy\") == \"\")\nassert(get_closest_vowel(word: \"ali\") == \"\")\nassert(get_closest_vowel(word:\
    \ \"bad\") == \"a\")\nassert(get_closest_vowel(word: \"most\") == \"o\")\nassert(get_closest_vowel(word:\
    \ \"ab\") == \"\")\nassert(get_closest_vowel(word: \"ba\") == \"\")\nassert(get_closest_vowel(word:\
    \ \"quick\") == \"\")\nassert(get_closest_vowel(word: \"anime\") == \"i\")\nassert(get_closest_vowel(word:\
    \ \"Asia\") == \"\")\nassert(get_closest_vowel(word: \"Above\") == \"o\")"
  status: Exception
  stderr: 'tmpq4ky73v8/tmpq4ky73v8.swift:46: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b86e8d8ac80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b86e8a81b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b86e8a81988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b86e8a807b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpq4ky73v8                        0x000056466e15d947 <unavailable> + 6471

    5    libc.so.6                          0x00002b86e8f76460 __libc_start_main +
    245

    6    tmpq4ky73v8                        0x000056466e15d589 <unavailable> + 5513

    '
  stdout: ''
  timestamp: 1660013566
- exit_code: -4
  program: "\n/// You are given a word. Your task is to find the closest vowel that\
    \ stands between \n/// two consonants from the right side of the word (case sensitive).\n\
    /// Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n/// find any vowel met the above condition. \n/// You may assume that\
    \ the given string contains English letter only.\n/// Example:\n/// >>> get_closest_vowel(word:\
    \ \"yogurt\")\n/// \"u\"\n/// >>> get_closest_vowel(word: \"FULL\")\n/// \"U\"\
    \n/// >>> get_closest_vowel(word: \"quick\")\n/// \"\"\n/// >>> get_closest_vowel(word:\
    \ \"ab\")\n/// \"\"\nfunc get_closest_vowel(word: String) -> String {\n    let\
    \ vowels = [\"a\", \"e\", \"i\", \"o\", \"u\"]\n    if vowels.contains(word) {\n\
    \        return \"\"\n    }\n    var word = word\n    while word.count > 0 {\n\
    \        let lastChar = word.last!\n        word.removeLast()\n        if vowels.contains(String(lastChar))\
    \ {\n            return \"\"\n        }\n        let n = word.count\n        for\
    \ i in 0..<n {\n            let char = word[word.index(word.startIndex, offsetBy:\
    \ i)]\n            if vowels.contains(String(char)) {\n                return\
    \ String(char)\n            }\n        }\n    }\n    return \"\"\n}\n\n\nfunc\
    \ ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count !=\
    \ right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(get_closest_vowel(word: \"yogurt\") == \"u\")\n\
    assert(get_closest_vowel(word: \"full\") == \"u\")\nassert(get_closest_vowel(word:\
    \ \"easy\") == \"\")\nassert(get_closest_vowel(word: \"eAsy\") == \"\")\nassert(get_closest_vowel(word:\
    \ \"ali\") == \"\")\nassert(get_closest_vowel(word: \"bad\") == \"a\")\nassert(get_closest_vowel(word:\
    \ \"most\") == \"o\")\nassert(get_closest_vowel(word: \"ab\") == \"\")\nassert(get_closest_vowel(word:\
    \ \"ba\") == \"\")\nassert(get_closest_vowel(word: \"quick\") == \"\")\nassert(get_closest_vowel(word:\
    \ \"anime\") == \"i\")\nassert(get_closest_vowel(word: \"Asia\") == \"\")\nassert(get_closest_vowel(word:\
    \ \"Above\") == \"o\")"
  status: Exception
  stderr: 'tmpdikv4w32/tmpdikv4w32.swift:52: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b0d7039fc80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b0d70096b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b0d70096988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b0d700957b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpdikv4w32                        0x0000562bdccc4967 <unavailable> + 6503

    5    libc.so.6                          0x00002b0d7058b460 __libc_start_main +
    245

    6    tmpdikv4w32                        0x0000562bdccc45a9 <unavailable> + 5545

    '
  stdout: ''
  timestamp: 1660013566
- exit_code: -4
  program: "\n/// You are given a word. Your task is to find the closest vowel that\
    \ stands between \n/// two consonants from the right side of the word (case sensitive).\n\
    /// Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n/// find any vowel met the above condition. \n/// You may assume that\
    \ the given string contains English letter only.\n/// Example:\n/// >>> get_closest_vowel(word:\
    \ \"yogurt\")\n/// \"u\"\n/// >>> get_closest_vowel(word: \"FULL\")\n/// \"U\"\
    \n/// >>> get_closest_vowel(word: \"quick\")\n/// \"\"\n/// >>> get_closest_vowel(word:\
    \ \"ab\")\n/// \"\"\nfunc get_closest_vowel(word: String) -> String {\n    let\
    \ vowels = [\"a\", \"e\", \"i\", \"o\", \"u\"]\n    let cons = [\"b\", \"c\",\
    \ \"d\", \"f\", \"g\", \"h\", \"j\", \"k\", \"l\", \"m\", \"n\", \"p\", \"q\"\
    , \"r\", \"s\", \"t\", \"v\", \"w\", \"x\", \"y\", \"z\"]\n    var vowel = \"\"\
    \n    var counter = word.count - 1\n    while counter >= 0 {\n        let char\
    \ = String(word[word.index(word.startIndex, offsetBy: counter)])\n        if !vowels.contains(char)\
    \ && !cons.contains(char) {\n            counter -= 1\n            continue\n\
    \        }\n        if cons.contains(char) {\n            for i in (0...counter).reversed()\
    \ {\n                let char = String(word[word.index(word.startIndex, offsetBy:\
    \ i)])\n                if vowels.contains(char) {\n                    vowel\
    \ = char\n                    break\n                }\n            }\n      \
    \      break\n        }\n        counter -= 1\n    }\n    return vowel\n}\n\n\n\
    func ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(get_closest_vowel(word: \"yogurt\") == \"u\")\n\
    assert(get_closest_vowel(word: \"full\") == \"u\")\nassert(get_closest_vowel(word:\
    \ \"easy\") == \"\")\nassert(get_closest_vowel(word: \"eAsy\") == \"\")\nassert(get_closest_vowel(word:\
    \ \"ali\") == \"\")\nassert(get_closest_vowel(word: \"bad\") == \"a\")\nassert(get_closest_vowel(word:\
    \ \"most\") == \"o\")\nassert(get_closest_vowel(word: \"ab\") == \"\")\nassert(get_closest_vowel(word:\
    \ \"ba\") == \"\")\nassert(get_closest_vowel(word: \"quick\") == \"\")\nassert(get_closest_vowel(word:\
    \ \"anime\") == \"i\")\nassert(get_closest_vowel(word: \"Asia\") == \"\")\nassert(get_closest_vowel(word:\
    \ \"Above\") == \"o\")"
  status: Exception
  stderr: 'tmp1hb0eu9t/tmp1hb0eu9t.swift:57: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b72b4f79c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b72b4c70b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b72b4c70988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b72b4c6f7b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmp1hb0eu9t                        0x0000563d3a484c03 <unavailable> + 7171

    5    libc.so.6                          0x00002b72b5165460 __libc_start_main +
    245

    6    tmp1hb0eu9t                        0x0000563d3a484639 <unavailable> + 5689

    '
  stdout: ''
  timestamp: 1660013566
- exit_code: -4
  program: "\n/// You are given a word. Your task is to find the closest vowel that\
    \ stands between \n/// two consonants from the right side of the word (case sensitive).\n\
    /// Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n/// find any vowel met the above condition. \n/// You may assume that\
    \ the given string contains English letter only.\n/// Example:\n/// >>> get_closest_vowel(word:\
    \ \"yogurt\")\n/// \"u\"\n/// >>> get_closest_vowel(word: \"FULL\")\n/// \"U\"\
    \n/// >>> get_closest_vowel(word: \"quick\")\n/// \"\"\n/// >>> get_closest_vowel(word:\
    \ \"ab\")\n/// \"\"\nfunc get_closest_vowel(word: String) -> String {\n    var\
    \ vowel_list = [\"a\", \"e\", \"i\", \"o\", \"u\"]\n    let word_list = Array(word)\n\
    \    var vowel = \"\"\n    for i in 0..<word_list.count {\n        if (vowel_list.contains(String(word_list[i])))\
    \ {\n            if (i == 0) {\n                continue\n            }\n    \
    \        if (i == word_list.count - 1) {\n                if (!vowel_list.contains(String(word_list[i\
    \ - 1]))) {\n                    vowel = String(word_list[i])\n              \
    \  }\n                continue\n            }\n            if (!vowel_list.contains(String(word_list[i\
    \ - 1])) && !vowel_list.contains(String(word_list[i + 1]))) {\n              \
    \  vowel = String(word_list[i])\n            }\n        }\n    }\n    return vowel\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(get_closest_vowel(word: \"yogurt\") == \"u\")\n\
    assert(get_closest_vowel(word: \"full\") == \"u\")\nassert(get_closest_vowel(word:\
    \ \"easy\") == \"\")\nassert(get_closest_vowel(word: \"eAsy\") == \"\")\nassert(get_closest_vowel(word:\
    \ \"ali\") == \"\")\nassert(get_closest_vowel(word: \"bad\") == \"a\")\nassert(get_closest_vowel(word:\
    \ \"most\") == \"o\")\nassert(get_closest_vowel(word: \"ab\") == \"\")\nassert(get_closest_vowel(word:\
    \ \"ba\") == \"\")\nassert(get_closest_vowel(word: \"quick\") == \"\")\nassert(get_closest_vowel(word:\
    \ \"anime\") == \"i\")\nassert(get_closest_vowel(word: \"Asia\") == \"\")\nassert(get_closest_vowel(word:\
    \ \"Above\") == \"o\")"
  status: Exception
  stderr: 'tmplahdyvwc/tmplahdyvwc.swift:56: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b040b1f3c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b040aeeab6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b040aeea988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b040aee97b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmplahdyvwc                        0x0000565386f66c8b <unavailable> + 7307

    5    libc.so.6                          0x00002b040b3df460 __libc_start_main +
    245

    6    tmplahdyvwc                        0x0000565386f66489 <unavailable> + 5257

    '
  stdout: ''
  timestamp: 1660013566
- exit_code: -4
  program: "\n/// You are given a word. Your task is to find the closest vowel that\
    \ stands between \n/// two consonants from the right side of the word (case sensitive).\n\
    /// Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n/// find any vowel met the above condition. \n/// You may assume that\
    \ the given string contains English letter only.\n/// Example:\n/// >>> get_closest_vowel(word:\
    \ \"yogurt\")\n/// \"u\"\n/// >>> get_closest_vowel(word: \"FULL\")\n/// \"U\"\
    \n/// >>> get_closest_vowel(word: \"quick\")\n/// \"\"\n/// >>> get_closest_vowel(word:\
    \ \"ab\")\n/// \"\"\nfunc get_closest_vowel(word: String) -> String {\n    let\
    \ vowels = \"aeiou\"\n    var vowel = \"\"\n    for (index, char) in word.enumerated()\
    \ {\n        if (vowels.contains(char)) {\n            vowel = String(char)\n\
    \            let c = word.index(word.startIndex, offsetBy: index)\n          \
    \  if (word[word.startIndex ..< c].contains(\"a\") || word[word.startIndex ..<\
    \ c].contains(\"e\") || word[word.startIndex ..< c].contains(\"i\") || word[word.startIndex\
    \ ..< c].contains(\"o\") || word[word.startIndex ..< c].contains(\"u\")) {\n \
    \               vowel = \"\"\n            }\n            if (word[c ..< word.endIndex].contains(\"\
    a\") || word[c ..< word.endIndex].contains(\"e\") || word[c ..< word.endIndex].contains(\"\
    i\") || word[c ..< word.endIndex].contains(\"o\") || word[c ..< word.endIndex].contains(\"\
    u\")) {\n                vowel = \"\"\n            }\n        }\n    }\n    return\
    \ vowel\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n \
    \   if left.count != right.count {\n        return false\n    }\n    for (l, r)\
    \ in zip(left, right) {\n        if l != r {\n            return false\n     \
    \   }\n    }\n    return true\n}\n            \nassert(get_closest_vowel(word:\
    \ \"yogurt\") == \"u\")\nassert(get_closest_vowel(word: \"full\") == \"u\")\n\
    assert(get_closest_vowel(word: \"easy\") == \"\")\nassert(get_closest_vowel(word:\
    \ \"eAsy\") == \"\")\nassert(get_closest_vowel(word: \"ali\") == \"\")\nassert(get_closest_vowel(word:\
    \ \"bad\") == \"a\")\nassert(get_closest_vowel(word: \"most\") == \"o\")\nassert(get_closest_vowel(word:\
    \ \"ab\") == \"\")\nassert(get_closest_vowel(word: \"ba\") == \"\")\nassert(get_closest_vowel(word:\
    \ \"quick\") == \"\")\nassert(get_closest_vowel(word: \"anime\") == \"i\")\nassert(get_closest_vowel(word:\
    \ \"Asia\") == \"\")\nassert(get_closest_vowel(word: \"Above\") == \"o\")"
  status: Exception
  stderr: 'tmpflw_o8qo/tmpflw_o8qo.swift:47: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b53b2acec80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b53b27c5b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b53b27c5988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b53b27c47b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpflw_o8qo                        0x000055b6c17fa997 <unavailable> + 6551

    5    libc.so.6                          0x00002b53b2cba460 __libc_start_main +
    245

    6    tmpflw_o8qo                        0x000055b6c17fa5d9 <unavailable> + 5593

    '
  stdout: ''
  timestamp: 1660013566
- exit_code: 1
  program: "\n/// You are given a word. Your task is to find the closest vowel that\
    \ stands between \n/// two consonants from the right side of the word (case sensitive).\n\
    /// Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n/// find any vowel met the above condition. \n/// You may assume that\
    \ the given string contains English letter only.\n/// Example:\n/// >>> get_closest_vowel(word:\
    \ \"yogurt\")\n/// \"u\"\n/// >>> get_closest_vowel(word: \"FULL\")\n/// \"U\"\
    \n/// >>> get_closest_vowel(word: \"quick\")\n/// \"\"\n/// >>> get_closest_vowel(word:\
    \ \"ab\")\n/// \"\"\nfunc get_closest_vowel(word: String) -> String {\n    let\
    \ vowels = \"aeiouAEIOU\"\n    let consonants = \"bcdfghjklmnpqrstvwxyzBCDFGHJKLMNPQRSTVWXYZ\"\
    \n    let numbers = \"0123456789\"\n    var vowels_array: [Character] = []\n \
    \   var consonants_array: [Character] = []\n    var numbers_array: [Character]\
    \ = []\n    for i in vowels {\n        vowels_array.append(i)\n    }\n    for\
    \ i in consonants {\n        consonants_array.append(i)\n    }\n    for i in numbers\
    \ {\n        numbers_array.append(i)\n    }\n    var word_array: [Character] =\
    \ []\n    for i in word {\n        word_array.append(i)\n    }\n    var vowel_index:\
    \ Int = -1\n    var first_vowel_index: Int = -1\n    var second_vowel_index: Int\
    \ = -1\n    var consonant_index: Int = -1\n    var first_consonant_index: Int\
    \ = -1\n    var second_consonant_index: Int = -1\n    for i in (0..<word_array.count).reversed()\
    \ {\n        if consonants_array.contains(word_array[i]) && !numbers_array.contains(word_array[i])\
    \ {\n            consonant_index = i\n            if second_consonant_index ==\
    \ -1 {\n                second_consonant_index = i\n            } else {\n   \
    \             first_consonant_index = i\n            }\n        }\n        if\
    \ vowels_array.contains(word_array[i]) && !numbers_array.contains(word_array[i])\
    \ {\n            vowel_index = i\n            if second_vowel_index == -1 {\n\
    \                second_vowel_index = i\n            } else {\n              \
    \  first_vowel_index = i\n            }\n        }\n    }\n    if first_vowel_index\
    \ == -1 {\n        return \"\"\n    }\n    if second_consonant_index == -1\n}\n\
    \n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(get_closest_vowel(word: \"yogurt\") == \"u\")\n\
    assert(get_closest_vowel(word: \"full\") == \"u\")\nassert(get_closest_vowel(word:\
    \ \"easy\") == \"\")\nassert(get_closest_vowel(word: \"eAsy\") == \"\")\nassert(get_closest_vowel(word:\
    \ \"ali\") == \"\")\nassert(get_closest_vowel(word: \"bad\") == \"a\")\nassert(get_closest_vowel(word:\
    \ \"most\") == \"o\")\nassert(get_closest_vowel(word: \"ab\") == \"\")\nassert(get_closest_vowel(word:\
    \ \"ba\") == \"\")\nassert(get_closest_vowel(word: \"quick\") == \"\")\nassert(get_closest_vowel(word:\
    \ \"anime\") == \"i\")\nassert(get_closest_vowel(word: \"Asia\") == \"\")\nassert(get_closest_vowel(word:\
    \ \"Above\") == \"o\")"
  status: SyntaxError
  stderr: "/tmp/tmpgb5ofd_o.swift:63:36: error: expected '{' after 'if' condition\n\
    \    if second_consonant_index == -1\n                                   ^\n/tmp/tmpgb5ofd_o.swift:36:9:\
    \ warning: variable 'vowel_index' was written to, but never read\n    var vowel_index:\
    \ Int = -1\n        ^\n/tmp/tmpgb5ofd_o.swift:39:9: warning: variable 'consonant_index'\
    \ was written to, but never read\n    var consonant_index: Int = -1\n        ^\n\
    /tmp/tmpgb5ofd_o.swift:40:9: warning: variable 'first_consonant_index' was written\
    \ to, but never read\n    var first_consonant_index: Int = -1\n        ^\n"
  stdout: ''
  timestamp: 1660013566
- exit_code: -4
  program: "\n/// You are given a word. Your task is to find the closest vowel that\
    \ stands between \n/// two consonants from the right side of the word (case sensitive).\n\
    /// Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n/// find any vowel met the above condition. \n/// You may assume that\
    \ the given string contains English letter only.\n/// Example:\n/// >>> get_closest_vowel(word:\
    \ \"yogurt\")\n/// \"u\"\n/// >>> get_closest_vowel(word: \"FULL\")\n/// \"U\"\
    \n/// >>> get_closest_vowel(word: \"quick\")\n/// \"\"\n/// >>> get_closest_vowel(word:\
    \ \"ab\")\n/// \"\"\nfunc get_closest_vowel(word: String) -> String {\n    let\
    \ vowels = \"aeiou\"\n    let wordChar = Array(word)\n    var temp: String = \"\
    \"\n    var index = wordChar.count - 1\n    while index >= 0 {\n        if vowels.contains(wordChar[index])\
    \ {\n            temp = String(wordChar[index])\n            index -= 1\n    \
    \        if index >= 0 {\n                if !vowels.contains(wordChar[index])\
    \ {\n                    return temp\n                }\n            }\n     \
    \   } else {\n            index -= 1\n        }\n    }\n    return \"\"\n}\n\n\
    \nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(get_closest_vowel(word: \"yogurt\") == \"u\")\n\
    assert(get_closest_vowel(word: \"full\") == \"u\")\nassert(get_closest_vowel(word:\
    \ \"easy\") == \"\")\nassert(get_closest_vowel(word: \"eAsy\") == \"\")\nassert(get_closest_vowel(word:\
    \ \"ali\") == \"\")\nassert(get_closest_vowel(word: \"bad\") == \"a\")\nassert(get_closest_vowel(word:\
    \ \"most\") == \"o\")\nassert(get_closest_vowel(word: \"ab\") == \"\")\nassert(get_closest_vowel(word:\
    \ \"ba\") == \"\")\nassert(get_closest_vowel(word: \"quick\") == \"\")\nassert(get_closest_vowel(word:\
    \ \"anime\") == \"i\")\nassert(get_closest_vowel(word: \"Asia\") == \"\")\nassert(get_closest_vowel(word:\
    \ \"Above\") == \"o\")"
  status: Exception
  stderr: 'tmp9oy_q5iy/tmp9oy_q5iy.swift:54: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002ac39efd3c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002ac39eccab6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002ac39ecca988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002ac39ecc97b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmp9oy_q5iy                        0x00005605b58329fb <unavailable> + 6651

    5    libc.so.6                          0x00002ac39f1bf460 __libc_start_main +
    245

    6    tmp9oy_q5iy                        0x00005605b58321f9 <unavailable> + 4601

    '
  stdout: ''
  timestamp: 1660013566
- exit_code: -4
  program: "\n/// You are given a word. Your task is to find the closest vowel that\
    \ stands between \n/// two consonants from the right side of the word (case sensitive).\n\
    /// Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n/// find any vowel met the above condition. \n/// You may assume that\
    \ the given string contains English letter only.\n/// Example:\n/// >>> get_closest_vowel(word:\
    \ \"yogurt\")\n/// \"u\"\n/// >>> get_closest_vowel(word: \"FULL\")\n/// \"U\"\
    \n/// >>> get_closest_vowel(word: \"quick\")\n/// \"\"\n/// >>> get_closest_vowel(word:\
    \ \"ab\")\n/// \"\"\nfunc get_closest_vowel(word: String) -> String {\n    //\
    \ TODO: Write some code to solve this coding problem\n    return \"\"\n}\n\n\n\
    func ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(get_closest_vowel(word: \"yogurt\") == \"u\")\n\
    assert(get_closest_vowel(word: \"full\") == \"u\")\nassert(get_closest_vowel(word:\
    \ \"easy\") == \"\")\nassert(get_closest_vowel(word: \"eAsy\") == \"\")\nassert(get_closest_vowel(word:\
    \ \"ali\") == \"\")\nassert(get_closest_vowel(word: \"bad\") == \"a\")\nassert(get_closest_vowel(word:\
    \ \"most\") == \"o\")\nassert(get_closest_vowel(word: \"ab\") == \"\")\nassert(get_closest_vowel(word:\
    \ \"ba\") == \"\")\nassert(get_closest_vowel(word: \"quick\") == \"\")\nassert(get_closest_vowel(word:\
    \ \"anime\") == \"i\")\nassert(get_closest_vowel(word: \"Asia\") == \"\")\nassert(get_closest_vowel(word:\
    \ \"Above\") == \"o\")"
  status: Exception
  stderr: 'tmpdaezjosf/tmpdaezjosf.swift:34: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002ad9022c8c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002ad901fbfb6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002ad901fbf988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002ad901fbe7b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpdaezjosf                        0x000056168166d307 <unavailable> + 4871

    5    libc.so.6                          0x00002ad9024b4460 __libc_start_main +
    245

    6    tmpdaezjosf                        0x000056168166cf49 <unavailable> + 3913

    '
  stdout: ''
  timestamp: 1660013566
- exit_code: -4
  program: "\n/// You are given a word. Your task is to find the closest vowel that\
    \ stands between \n/// two consonants from the right side of the word (case sensitive).\n\
    /// Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n/// find any vowel met the above condition. \n/// You may assume that\
    \ the given string contains English letter only.\n/// Example:\n/// >>> get_closest_vowel(word:\
    \ \"yogurt\")\n/// \"u\"\n/// >>> get_closest_vowel(word: \"FULL\")\n/// \"U\"\
    \n/// >>> get_closest_vowel(word: \"quick\")\n/// \"\"\n/// >>> get_closest_vowel(word:\
    \ \"ab\")\n/// \"\"\nfunc get_closest_vowel(word: String) -> String {\n\t// TODO:\
    \ Write some code to solve this coding challenge\n\treturn \"\"\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(get_closest_vowel(word: \"yogurt\") == \"u\")\nassert(get_closest_vowel(word:\
    \ \"full\") == \"u\")\nassert(get_closest_vowel(word: \"easy\") == \"\")\nassert(get_closest_vowel(word:\
    \ \"eAsy\") == \"\")\nassert(get_closest_vowel(word: \"ali\") == \"\")\nassert(get_closest_vowel(word:\
    \ \"bad\") == \"a\")\nassert(get_closest_vowel(word: \"most\") == \"o\")\nassert(get_closest_vowel(word:\
    \ \"ab\") == \"\")\nassert(get_closest_vowel(word: \"ba\") == \"\")\nassert(get_closest_vowel(word:\
    \ \"quick\") == \"\")\nassert(get_closest_vowel(word: \"anime\") == \"i\")\nassert(get_closest_vowel(word:\
    \ \"Asia\") == \"\")\nassert(get_closest_vowel(word: \"Above\") == \"o\")"
  status: Exception
  stderr: 'tmpkxyxa3ps/tmpkxyxa3ps.swift:34: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b8dad9adc80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b8dad6a4b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b8dad6a4988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b8dad6a37b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpkxyxa3ps                        0x0000557ffc46f307 <unavailable> + 4871

    5    libc.so.6                          0x00002b8dadb99460 __libc_start_main +
    245

    6    tmpkxyxa3ps                        0x0000557ffc46ef49 <unavailable> + 3913

    '
  stdout: ''
  timestamp: 1660013566
- exit_code: -4
  program: "\n/// You are given a word. Your task is to find the closest vowel that\
    \ stands between \n/// two consonants from the right side of the word (case sensitive).\n\
    /// Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n/// find any vowel met the above condition. \n/// You may assume that\
    \ the given string contains English letter only.\n/// Example:\n/// >>> get_closest_vowel(word:\
    \ \"yogurt\")\n/// \"u\"\n/// >>> get_closest_vowel(word: \"FULL\")\n/// \"U\"\
    \n/// >>> get_closest_vowel(word: \"quick\")\n/// \"\"\n/// >>> get_closest_vowel(word:\
    \ \"ab\")\n/// \"\"\nfunc get_closest_vowel(word: String) -> String {\n    let\
    \ vowels = [\"a\", \"e\", \"i\", \"o\", \"u\"]\n    var result = \"\"\n    var\
    \ vowelIndex = -1\n    for i in (1..<word.count).reversed() {\n        let character\
    \ = String(word[word.index(word.startIndex, offsetBy: i)])\n        if vowels.contains(character)\
    \ {\n            vowelIndex = i\n            break\n        }\n    }\n    if vowelIndex\
    \ > 0 {\n        let left = String(word[word.index(word.startIndex, offsetBy:\
    \ vowelIndex - 1)])\n        let right = String(word[word.index(word.startIndex,\
    \ offsetBy: vowelIndex + 1)])\n        if !vowels.contains(left) && !vowels.contains(right)\
    \ {\n            result = String(word[word.index(word.startIndex, offsetBy: vowelIndex)])\n\
    \        }\n    }\n    return result\n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(get_closest_vowel(word: \"yogurt\") == \"u\")\nassert(get_closest_vowel(word:\
    \ \"full\") == \"u\")\nassert(get_closest_vowel(word: \"easy\") == \"\")\nassert(get_closest_vowel(word:\
    \ \"eAsy\") == \"\")\nassert(get_closest_vowel(word: \"ali\") == \"\")\nassert(get_closest_vowel(word:\
    \ \"bad\") == \"a\")\nassert(get_closest_vowel(word: \"most\") == \"o\")\nassert(get_closest_vowel(word:\
    \ \"ab\") == \"\")\nassert(get_closest_vowel(word: \"ba\") == \"\")\nassert(get_closest_vowel(word:\
    \ \"quick\") == \"\")\nassert(get_closest_vowel(word: \"anime\") == \"i\")\nassert(get_closest_vowel(word:\
    \ \"Asia\") == \"\")\nassert(get_closest_vowel(word: \"Above\") == \"o\")"
  status: Exception
  stderr: 'Swift/StringIndexValidation.swift:120: Fatal error: String index is out
    of bounds

    Current stack trace:

    0    libswiftCore.so                    0x00002af4b9770c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002af4b9467561 <unavailable> + 1434977

    2    libswiftCore.so                    0x00002af4b9467286 <unavailable> + 1434246

    3    libswiftCore.so                    0x00002af4b946713c <unavailable> + 1433916

    4    libswiftCore.so                    0x00002af4b9466bb0 _assertionFailure(_:_:file:line:flags:)
    + 251

    5    libswiftCore.so                    0x00002af4b959aec2 <unavailable> + 2694850

    6    libswiftCore.so                    0x00002af4b9553660 String.subscript.getter
    + 34

    7    tmph91esaul                        0x000055bcf4ea5cc1 <unavailable> + 11457

    8    tmph91esaul                        0x000055bcf4ea4d4b <unavailable> + 7499

    9    libc.so.6                          0x00002af4b995c460 __libc_start_main +
    245

    10   tmph91esaul                        0x000055bcf4ea4639 <unavailable> + 5689

    '
  stdout: ''
  timestamp: 1660013566
- exit_code: -4
  program: "\n/// You are given a word. Your task is to find the closest vowel that\
    \ stands between \n/// two consonants from the right side of the word (case sensitive).\n\
    /// Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n/// find any vowel met the above condition. \n/// You may assume that\
    \ the given string contains English letter only.\n/// Example:\n/// >>> get_closest_vowel(word:\
    \ \"yogurt\")\n/// \"u\"\n/// >>> get_closest_vowel(word: \"FULL\")\n/// \"U\"\
    \n/// >>> get_closest_vowel(word: \"quick\")\n/// \"\"\n/// >>> get_closest_vowel(word:\
    \ \"ab\")\n/// \"\"\nfunc get_closest_vowel(word: String) -> String {\n\tlet vowels\
    \ = \"aeiou\"\n\tlet consonants = \"bcdfghjklmnpqrstvwxyz\"\n\t\n\tvar vowelQueue\
    \ = [Character]()\n\tvar consonantQueue = [Character]()\n\tvar result = [Character]()\n\
    \t\n\tfor (index, letter) in word.enumerated() {\n\t\tif vowels.contains(letter)\
    \ {\n\t\t\tvowelQueue.append(letter)\n\t\t} else if consonants.contains(letter)\
    \ {\n\t\t\tconsonantQueue.append(letter)\n\t\t}\n\t\tif index == word.count -\
    \ 1 {\n\t\t\tif vowelQueue.count == 0 || consonantQueue.count == 0 {\n\t\t\t\t\
    return \"\"\n\t\t\t}\n\t\t\tvar minAbsVal = abs(vowelQueue.count - consonantQueue.count)\n\
    \t\t\tfor i in 0..<vowelQueue.count {\n\t\t\t\tlet absVal = abs(vowelQueue.count\
    \ - consonantQueue.count - i)\n\t\t\t\tif absVal <= minAbsVal {\n\t\t\t\t\tminAbsVal\
    \ = absVal\n\t\t\t\t\tresult.append(vowelQueue[i])\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\
    \t}\n\t\n\treturn String(result)\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int,\
    \ Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n\
    \    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n          \
    \  return false\n        }\n    }\n    return true\n}\n            \nassert(get_closest_vowel(word:\
    \ \"yogurt\") == \"u\")\nassert(get_closest_vowel(word: \"full\") == \"u\")\n\
    assert(get_closest_vowel(word: \"easy\") == \"\")\nassert(get_closest_vowel(word:\
    \ \"eAsy\") == \"\")\nassert(get_closest_vowel(word: \"ali\") == \"\")\nassert(get_closest_vowel(word:\
    \ \"bad\") == \"a\")\nassert(get_closest_vowel(word: \"most\") == \"o\")\nassert(get_closest_vowel(word:\
    \ \"ab\") == \"\")\nassert(get_closest_vowel(word: \"ba\") == \"\")\nassert(get_closest_vowel(word:\
    \ \"quick\") == \"\")\nassert(get_closest_vowel(word: \"anime\") == \"i\")\nassert(get_closest_vowel(word:\
    \ \"Asia\") == \"\")\nassert(get_closest_vowel(word: \"Above\") == \"o\")"
  status: Exception
  stderr: 'tmpo2g8vkrl/tmpo2g8vkrl.swift:61: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002afe7bb12c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002afe7b809b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002afe7b809988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002afe7b8087b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpo2g8vkrl                        0x0000556d87641af7 <unavailable> + 6903

    5    libc.so.6                          0x00002afe7bcfe460 __libc_start_main +
    245

    6    tmpo2g8vkrl                        0x0000556d87641739 <unavailable> + 5945

    '
  stdout: ''
  timestamp: 1660013566
- exit_code: 1
  program: "\n/// You are given a word. Your task is to find the closest vowel that\
    \ stands between \n/// two consonants from the right side of the word (case sensitive).\n\
    /// Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n/// find any vowel met the above condition. \n/// You may assume that\
    \ the given string contains English letter only.\n/// Example:\n/// >>> get_closest_vowel(word:\
    \ \"yogurt\")\n/// \"u\"\n/// >>> get_closest_vowel(word: \"FULL\")\n/// \"U\"\
    \n/// >>> get_closest_vowel(word: \"quick\")\n/// \"\"\n/// >>> get_closest_vowel(word:\
    \ \"ab\")\n/// \"\"\nfunc get_closest_vowel(word: String) -> String {\n    let\
    \ vowels = [\"a\", \"e\", \"i\", \"o\", \"u\"]\n    let split_string = word.lowercased().characters.map\
    \ { String($0) }\n    let index = split_string.index(of: \" \")\n    if index\
    \ != nil {\n        return \"\"\n    }\n    let reversed_word = String(split_string.reversed())\n\
    \    var results = \"\"\n    for i in 1..<reversed_word.characters.count {\n \
    \       let range = Range(uncheckedBounds: (lower: reversed_word.characters.index(reversed_word.startIndex,\
    \ offsetBy: i), upper: reversed_word.characters.index(reversed_word.startIndex,\
    \ offsetBy: i + 1)))\n        if vowels.contains(reversed_word.substring(with:\
    \ range)) && !vowels.contains(reversed_word.substring(with: Range(uncheckedBounds:\
    \ (lower: reversed_word.characters.index(reversed_word.startIndex, offsetBy: i\
    \ - 1), upper: reversed_word.characters.index(reversed_word.startIndex, offsetBy:\
    \ i))))) && !vowels.contains(reversed_word.substring(with: Range(uncheckedBounds:\
    \ (lower: reversed_word.characters.index(reversed_word.startIndex, offsetBy: i\
    \ + 1), upper: reversed_word.characters.index(reversed_word.startIndex, offsetBy:\
    \ i + 2))))) {\n            results = reversed_word.substring(with: range)\n \
    \           break\n        }\n    }\n    return results\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(get_closest_vowel(word: \"yogurt\") == \"u\")\nassert(get_closest_vowel(word:\
    \ \"full\") == \"u\")\nassert(get_closest_vowel(word: \"easy\") == \"\")\nassert(get_closest_vowel(word:\
    \ \"eAsy\") == \"\")\nassert(get_closest_vowel(word: \"ali\") == \"\")\nassert(get_closest_vowel(word:\
    \ \"bad\") == \"a\")\nassert(get_closest_vowel(word: \"most\") == \"o\")\nassert(get_closest_vowel(word:\
    \ \"ab\") == \"\")\nassert(get_closest_vowel(word: \"ba\") == \"\")\nassert(get_closest_vowel(word:\
    \ \"quick\") == \"\")\nassert(get_closest_vowel(word: \"anime\") == \"i\")\nassert(get_closest_vowel(word:\
    \ \"Asia\") == \"\")\nassert(get_closest_vowel(word: \"Above\") == \"o\")"
  status: SyntaxError
  stderr: "/tmp/tmpxwdv3y4m.swift:18:42: error: 'characters' is unavailable: Please\
    \ use String directly\n    let split_string = word.lowercased().characters.map\
    \ { String($0) }\n                                         ^~~~~~~~~~\nSwift.String:5:16:\
    \ note: 'characters' was obsoleted in Swift 5.0\n    public var characters: String\
    \ { get set }\n               ^\n/tmp/tmpxwdv3y4m.swift:19:30: warning: 'index(of:)'\
    \ is deprecated: renamed to 'firstIndex(of:)'\n    let index = split_string.index(of:\
    \ \" \")\n                             ^\n/tmp/tmpxwdv3y4m.swift:19:30: note:\
    \ use 'firstIndex(of:)' instead\n    let index = split_string.index(of: \" \"\
    )\n                             ^~~~~\n                             firstIndex\n\
    /tmp/tmpxwdv3y4m.swift:23:25: error: no exact matches in call to initializer \n\
    \    let reversed_word = String(split_string.reversed())\n                   \
    \     ^\nSwift.String:4:12: note: candidate requires that the types 'String' and\
    \ 'Character' be equivalent (requirement specified as 'S.Element' == 'Character')\n\
    \    public init<S>(_ characters: S) where S : Sequence, S.Element == Character\n\
    \           ^\nSwift.RangeReplaceableCollection:3:23: note: candidate requires\
    \ that the types 'String.Element' (aka 'Character') and 'String' be equivalent\
    \ (requirement specified as 'Self.Element' == 'S.Element')\n    @inlinable public\
    \ init<S>(_ elements: S) where S : Sequence, Self.Element == S.Element\n     \
    \                 ^\nSwift.String:2:12: note: incorrect labels for candidate (have:\
    \ '(_:)', expected: '(describing:)')\n    public init<Subject>(describing instance:\
    \ Subject)\n           ^\nSwift.String:3:23: note: incorrect labels for candidate\
    \ (have: '(_:)', expected: '(describing:)')\n    @inlinable public init<Subject>(describing\
    \ instance: Subject) where Subject : CustomStringConvertible\n               \
    \       ^\nSwift.String:6:12: note: incorrect labels for candidate (have: '(_:)',\
    \ expected: '(reflecting:)')\n    public init<Subject>(reflecting subject: Subject)\n\
    \           ^\n"
  stdout: ''
  timestamp: 1660013566
- exit_code: -4
  program: "\n/// You are given a word. Your task is to find the closest vowel that\
    \ stands between \n/// two consonants from the right side of the word (case sensitive).\n\
    /// Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n/// find any vowel met the above condition. \n/// You may assume that\
    \ the given string contains English letter only.\n/// Example:\n/// >>> get_closest_vowel(word:\
    \ \"yogurt\")\n/// \"u\"\n/// >>> get_closest_vowel(word: \"FULL\")\n/// \"U\"\
    \n/// >>> get_closest_vowel(word: \"quick\")\n/// \"\"\n/// >>> get_closest_vowel(word:\
    \ \"ab\")\n/// \"\"\nfunc get_closest_vowel(word: String) -> String {\n    var\
    \ closest_vowel = \"\"\n    var dist_to_vowel = 999\n    let vowels = [\"a\",\
    \ \"e\", \"i\", \"o\", \"u\"]\n    var dist_to_last_consonant = 999\n    let consonants\
    \ = [\"b\", \"c\", \"d\", \"f\", \"g\", \"h\", \"j\", \"k\", \"l\", \"m\", \"\
    n\", \"p\", \"q\", \"r\", \"s\", \"t\", \"v\", \"w\", \"x\", \"y\", \"z\"]\n \
    \   for i in 0..<word.count {\n        if(vowels.contains(String(word[word.index(word.startIndex,\
    \ offsetBy: i)]).lowercased())) {\n            dist_to_vowel = word.count - i\
    \ - 1\n            if(dist_to_vowel < dist_to_last_consonant) {\n            \
    \    closest_vowel = String(word[word.index(word.startIndex, offsetBy: i)])\n\
    \            }\n        }\n        if(consonants.contains(String(word[word.index(word.startIndex,\
    \ offsetBy: i)]).lowercased())) {\n            dist_to_last_consonant = word.count\
    \ - i - 1\n        }\n    }\n    return closest_vowel\n}\n\n\nfunc ==(left: [(Int,\
    \ Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n\
    \        return false\n    }\n    for (l, r) in zip(left, right) {\n        if\
    \ l != r {\n            return false\n        }\n    }\n    return true\n}\n \
    \           \nassert(get_closest_vowel(word: \"yogurt\") == \"u\")\nassert(get_closest_vowel(word:\
    \ \"full\") == \"u\")\nassert(get_closest_vowel(word: \"easy\") == \"\")\nassert(get_closest_vowel(word:\
    \ \"eAsy\") == \"\")\nassert(get_closest_vowel(word: \"ali\") == \"\")\nassert(get_closest_vowel(word:\
    \ \"bad\") == \"a\")\nassert(get_closest_vowel(word: \"most\") == \"o\")\nassert(get_closest_vowel(word:\
    \ \"ab\") == \"\")\nassert(get_closest_vowel(word: \"ba\") == \"\")\nassert(get_closest_vowel(word:\
    \ \"quick\") == \"\")\nassert(get_closest_vowel(word: \"anime\") == \"i\")\nassert(get_closest_vowel(word:\
    \ \"Asia\") == \"\")\nassert(get_closest_vowel(word: \"Above\") == \"o\")"
  status: Exception
  stderr: 'tmpej2gkvh2/tmpej2gkvh2.swift:51: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b59b401ec80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b59b3d15b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b59b3d15988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b59b3d147b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpej2gkvh2                        0x000056323719aa83 <unavailable> + 6787

    5    libc.so.6                          0x00002b59b420a460 __libc_start_main +
    245

    6    tmpej2gkvh2                        0x000056323719a4b9 <unavailable> + 5305

    '
  stdout: ''
  timestamp: 1660013566
- exit_code: -4
  program: "\n/// You are given a word. Your task is to find the closest vowel that\
    \ stands between \n/// two consonants from the right side of the word (case sensitive).\n\
    /// Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n/// find any vowel met the above condition. \n/// You may assume that\
    \ the given string contains English letter only.\n/// Example:\n/// >>> get_closest_vowel(word:\
    \ \"yogurt\")\n/// \"u\"\n/// >>> get_closest_vowel(word: \"FULL\")\n/// \"U\"\
    \n/// >>> get_closest_vowel(word: \"quick\")\n/// \"\"\n/// >>> get_closest_vowel(word:\
    \ \"ab\")\n/// \"\"\nfunc get_closest_vowel(word: String) -> String {\n    var\
    \ vowels = [String]()\n    for char in word {\n        if \"AEIOUaeiou\".contains(char)\
    \ {\n            vowels.append(String(char))\n        }\n    }\n    if vowels.count\
    \ == 0 {\n        return \"\"\n    }\n    if vowels.count == 1 {\n        return\
    \ vowels[0]\n    }\n    let first = vowels[0]\n    let last = vowels[vowels.count\
    \ - 1]\n    return first == last ? first : last\n}\n\n\nfunc ==(left: [(Int, Int)],\
    \ right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n       \
    \ return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r\
    \ {\n            return false\n        }\n    }\n    return true\n}\n        \
    \    \nassert(get_closest_vowel(word: \"yogurt\") == \"u\")\nassert(get_closest_vowel(word:\
    \ \"full\") == \"u\")\nassert(get_closest_vowel(word: \"easy\") == \"\")\nassert(get_closest_vowel(word:\
    \ \"eAsy\") == \"\")\nassert(get_closest_vowel(word: \"ali\") == \"\")\nassert(get_closest_vowel(word:\
    \ \"bad\") == \"a\")\nassert(get_closest_vowel(word: \"most\") == \"o\")\nassert(get_closest_vowel(word:\
    \ \"ab\") == \"\")\nassert(get_closest_vowel(word: \"ba\") == \"\")\nassert(get_closest_vowel(word:\
    \ \"quick\") == \"\")\nassert(get_closest_vowel(word: \"anime\") == \"i\")\nassert(get_closest_vowel(word:\
    \ \"Asia\") == \"\")\nassert(get_closest_vowel(word: \"Above\") == \"o\")"
  status: Exception
  stderr: 'tmptbsdd_d9/tmptbsdd_d9.swift:49: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002af71f11dc80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002af71ee14b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002af71ee14988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002af71ee137b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmptbsdd_d9                        0x000055dfefe618d3 <unavailable> + 6355

    5    libc.so.6                          0x00002af71f309460 __libc_start_main +
    245

    6    tmptbsdd_d9                        0x000055dfefe61309 <unavailable> + 4873

    '
  stdout: ''
  timestamp: 1660013566
- exit_code: -4
  program: "\n/// You are given a word. Your task is to find the closest vowel that\
    \ stands between \n/// two consonants from the right side of the word (case sensitive).\n\
    /// Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n/// find any vowel met the above condition. \n/// You may assume that\
    \ the given string contains English letter only.\n/// Example:\n/// >>> get_closest_vowel(word:\
    \ \"yogurt\")\n/// \"u\"\n/// >>> get_closest_vowel(word: \"FULL\")\n/// \"U\"\
    \n/// >>> get_closest_vowel(word: \"quick\")\n/// \"\"\n/// >>> get_closest_vowel(word:\
    \ \"ab\")\n/// \"\"\nfunc get_closest_vowel(word: String) -> String {\n    return\
    \ \"\"\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n  \
    \  if left.count != right.count {\n        return false\n    }\n    for (l, r)\
    \ in zip(left, right) {\n        if l != r {\n            return false\n     \
    \   }\n    }\n    return true\n}\n            \nassert(get_closest_vowel(word:\
    \ \"yogurt\") == \"u\")\nassert(get_closest_vowel(word: \"full\") == \"u\")\n\
    assert(get_closest_vowel(word: \"easy\") == \"\")\nassert(get_closest_vowel(word:\
    \ \"eAsy\") == \"\")\nassert(get_closest_vowel(word: \"ali\") == \"\")\nassert(get_closest_vowel(word:\
    \ \"bad\") == \"a\")\nassert(get_closest_vowel(word: \"most\") == \"o\")\nassert(get_closest_vowel(word:\
    \ \"ab\") == \"\")\nassert(get_closest_vowel(word: \"ba\") == \"\")\nassert(get_closest_vowel(word:\
    \ \"quick\") == \"\")\nassert(get_closest_vowel(word: \"anime\") == \"i\")\nassert(get_closest_vowel(word:\
    \ \"Asia\") == \"\")\nassert(get_closest_vowel(word: \"Above\") == \"o\")"
  status: Exception
  stderr: 'tmpvf1hzub_/tmpvf1hzub_.swift:33: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002ba694399c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002ba694090b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002ba694090988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002ba69408f7b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpvf1hzub_                        0x00005567315f8307 <unavailable> + 4871

    5    libc.so.6                          0x00002ba694585460 __libc_start_main +
    245

    6    tmpvf1hzub_                        0x00005567315f7f49 <unavailable> + 3913

    '
  stdout: ''
  timestamp: 1660013566
- exit_code: -4
  program: "\n/// You are given a word. Your task is to find the closest vowel that\
    \ stands between \n/// two consonants from the right side of the word (case sensitive).\n\
    /// Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n/// find any vowel met the above condition. \n/// You may assume that\
    \ the given string contains English letter only.\n/// Example:\n/// >>> get_closest_vowel(word:\
    \ \"yogurt\")\n/// \"u\"\n/// >>> get_closest_vowel(word: \"FULL\")\n/// \"U\"\
    \n/// >>> get_closest_vowel(word: \"quick\")\n/// \"\"\n/// >>> get_closest_vowel(word:\
    \ \"ab\")\n/// \"\"\nfunc get_closest_vowel(word: String) -> String {\n    let\
    \ vowels = \"aeiouAEIOU\"\n    var closest: String = \"\"\n    for (i, c) in word.enumerated()\
    \ {\n        let c = String(c)\n        if vowels.contains(c) {\n            if\
    \ let prev = word.index(word.startIndex, offsetBy: i - 1, limitedBy: word.startIndex),\n\
    \                let next = word.index(word.startIndex, offsetBy: i + 1, limitedBy:\
    \ word.endIndex) {\n                let prev_c = String(word[prev])\n        \
    \        let next_c = String(word[next])\n                if !vowels.contains(prev_c)\
    \ && !vowels.contains(next_c) {\n                    closest = c\n           \
    \     }\n            }\n        }\n    }\n    return closest\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(get_closest_vowel(word: \"yogurt\") == \"u\")\nassert(get_closest_vowel(word:\
    \ \"full\") == \"u\")\nassert(get_closest_vowel(word: \"easy\") == \"\")\nassert(get_closest_vowel(word:\
    \ \"eAsy\") == \"\")\nassert(get_closest_vowel(word: \"ali\") == \"\")\nassert(get_closest_vowel(word:\
    \ \"bad\") == \"a\")\nassert(get_closest_vowel(word: \"most\") == \"o\")\nassert(get_closest_vowel(word:\
    \ \"ab\") == \"\")\nassert(get_closest_vowel(word: \"ba\") == \"\")\nassert(get_closest_vowel(word:\
    \ \"quick\") == \"\")\nassert(get_closest_vowel(word: \"anime\") == \"i\")\nassert(get_closest_vowel(word:\
    \ \"Asia\") == \"\")\nassert(get_closest_vowel(word: \"Above\") == \"o\")"
  status: Exception
  stderr: 'tmptfnx8_gn/tmptfnx8_gn.swift:48: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b698dff1c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b698dce8b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b698dce8988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b698dce77b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmptfnx8_gn                        0x000055d6012617f7 <unavailable> + 6135

    5    libc.so.6                          0x00002b698e1dd460 __libc_start_main +
    245

    6    tmptfnx8_gn                        0x000055d601261439 <unavailable> + 5177

    '
  stdout: ''
  timestamp: 1660013566
- exit_code: -4
  program: "\n/// You are given a word. Your task is to find the closest vowel that\
    \ stands between \n/// two consonants from the right side of the word (case sensitive).\n\
    /// Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n/// find any vowel met the above condition. \n/// You may assume that\
    \ the given string contains English letter only.\n/// Example:\n/// >>> get_closest_vowel(word:\
    \ \"yogurt\")\n/// \"u\"\n/// >>> get_closest_vowel(word: \"FULL\")\n/// \"U\"\
    \n/// >>> get_closest_vowel(word: \"quick\")\n/// \"\"\n/// >>> get_closest_vowel(word:\
    \ \"ab\")\n/// \"\"\nfunc get_closest_vowel(word: String) -> String {\n    let\
    \ vowels = [\"a\", \"e\", \"i\", \"o\", \"u\"]\n    let consonants = [\"b\", \"\
    c\", \"d\", \"f\", \"g\", \"h\", \"j\", \"k\", \"l\", \"m\", \"n\", \"p\", \"\
    q\", \"r\", \"s\", \"t\", \"v\", \"w\", \"x\", \"y\", \"z\"]\n    let word_array\
    \ = Array(word)\n    var prev_vowel: String = \"\"\n    for i in (0..<word_array.count).reversed()\
    \ {\n        if vowels.contains(String(word_array[i]).lowercased()) {\n      \
    \      if prev_vowel == \"\" {\n                prev_vowel = String(word_array[i])\n\
    \            } else {\n                if consonants.contains(String(word_array[i-1]).lowercased())\
    \ {\n                    return prev_vowel\n                }\n            }\n\
    \        }\n    }\n    return \"\"\n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(get_closest_vowel(word: \"yogurt\") == \"u\")\nassert(get_closest_vowel(word:\
    \ \"full\") == \"u\")\nassert(get_closest_vowel(word: \"easy\") == \"\")\nassert(get_closest_vowel(word:\
    \ \"eAsy\") == \"\")\nassert(get_closest_vowel(word: \"ali\") == \"\")\nassert(get_closest_vowel(word:\
    \ \"bad\") == \"a\")\nassert(get_closest_vowel(word: \"most\") == \"o\")\nassert(get_closest_vowel(word:\
    \ \"ab\") == \"\")\nassert(get_closest_vowel(word: \"ba\") == \"\")\nassert(get_closest_vowel(word:\
    \ \"quick\") == \"\")\nassert(get_closest_vowel(word: \"anime\") == \"i\")\nassert(get_closest_vowel(word:\
    \ \"Asia\") == \"\")\nassert(get_closest_vowel(word: \"Above\") == \"o\")"
  status: Exception
  stderr: 'tmps570yjft/tmps570yjft.swift:49: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002af877fbbc80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002af877cb2b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002af877cb2988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002af877cb17b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmps570yjft                        0x0000559de2430b67 <unavailable> + 7015

    5    libc.so.6                          0x00002af8781a7460 __libc_start_main +
    245

    6    tmps570yjft                        0x0000559de24306b9 <unavailable> + 5817

    '
  stdout: ''
  timestamp: 1660013566
- exit_code: -4
  program: "\n/// You are given a word. Your task is to find the closest vowel that\
    \ stands between \n/// two consonants from the right side of the word (case sensitive).\n\
    /// Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n/// find any vowel met the above condition. \n/// You may assume that\
    \ the given string contains English letter only.\n/// Example:\n/// >>> get_closest_vowel(word:\
    \ \"yogurt\")\n/// \"u\"\n/// >>> get_closest_vowel(word: \"FULL\")\n/// \"U\"\
    \n/// >>> get_closest_vowel(word: \"quick\")\n/// \"\"\n/// >>> get_closest_vowel(word:\
    \ \"ab\")\n/// \"\"\nfunc get_closest_vowel(word: String) -> String {\n    let\
    \ vowels = \"AEIOUaeiou\"\n    let consonants = \"BCDFGHJKLMNPQRSTVWXYZbcdfghjklmnpqrstvwxyz\"\
    \n    var result = \"\"\n    for i in (0..<word.count-1).reversed() {\n      \
    \  let char = word[word.index(word.startIndex, offsetBy: i)]\n        if consonants.contains(char)\
    \ {\n            for j in (i+1..<word.count).reversed() {\n                let\
    \ char2 = word[word.index(word.startIndex, offsetBy: j)]\n                if vowels.contains(char2)\
    \ {\n                    result = String(char2)\n                    break\n \
    \               }\n            }\n            break\n        }\n    }\n    return\
    \ result\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n\
    \    if left.count != right.count {\n        return false\n    }\n    for (l,\
    \ r) in zip(left, right) {\n        if l != r {\n            return false\n  \
    \      }\n    }\n    return true\n}\n            \nassert(get_closest_vowel(word:\
    \ \"yogurt\") == \"u\")\nassert(get_closest_vowel(word: \"full\") == \"u\")\n\
    assert(get_closest_vowel(word: \"easy\") == \"\")\nassert(get_closest_vowel(word:\
    \ \"eAsy\") == \"\")\nassert(get_closest_vowel(word: \"ali\") == \"\")\nassert(get_closest_vowel(word:\
    \ \"bad\") == \"a\")\nassert(get_closest_vowel(word: \"most\") == \"o\")\nassert(get_closest_vowel(word:\
    \ \"ab\") == \"\")\nassert(get_closest_vowel(word: \"ba\") == \"\")\nassert(get_closest_vowel(word:\
    \ \"quick\") == \"\")\nassert(get_closest_vowel(word: \"anime\") == \"i\")\nassert(get_closest_vowel(word:\
    \ \"Asia\") == \"\")\nassert(get_closest_vowel(word: \"Above\") == \"o\")"
  status: Exception
  stderr: 'tmpb158d4fh/tmpb158d4fh.swift:49: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b2669a90c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b2669787b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b2669787988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b26697867b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpb158d4fh                        0x0000561752eeb927 <unavailable> + 6439

    5    libc.so.6                          0x00002b2669c7c460 __libc_start_main +
    245

    6    tmpb158d4fh                        0x0000561752eeb569 <unavailable> + 5481

    '
  stdout: ''
  timestamp: 1660013566
- exit_code: -4
  program: "\n/// You are given a word. Your task is to find the closest vowel that\
    \ stands between \n/// two consonants from the right side of the word (case sensitive).\n\
    /// Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n/// find any vowel met the above condition. \n/// You may assume that\
    \ the given string contains English letter only.\n/// Example:\n/// >>> get_closest_vowel(word:\
    \ \"yogurt\")\n/// \"u\"\n/// >>> get_closest_vowel(word: \"FULL\")\n/// \"U\"\
    \n/// >>> get_closest_vowel(word: \"quick\")\n/// \"\"\n/// >>> get_closest_vowel(word:\
    \ \"ab\")\n/// \"\"\nfunc get_closest_vowel(word: String) -> String {\n    let\
    \ consonants = \"bcdfghjklmnpqrstvwxyz\"\n    let vowels = \"aeiou\"\n    var\
    \ new_word = \"\"\n    for letter in word {\n        if !consonants.contains(letter)\
    \ && !vowels.contains(letter) {\n            return \"\"\n        }\n        new_word.append(letter)\n\
    \    }\n    let split_by_consonants = new_word.split(separator: \"a\")\n    if\
    \ split_by_consonants.count == 1 {\n        return \"\"\n    }\n    let last_consonant_index\
    \ = split_by_consonants.count - 1\n    let last_consonant = String(split_by_consonants[last_consonant_index])\n\
    \    let split_by_vowels = last_consonant.split(separator: \"a\")\n    if split_by_vowels.count\
    \ == 1 {\n        return \"\"\n    }\n    return String(split_by_vowels[1].first!)\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(get_closest_vowel(word: \"yogurt\") == \"u\")\n\
    assert(get_closest_vowel(word: \"full\") == \"u\")\nassert(get_closest_vowel(word:\
    \ \"easy\") == \"\")\nassert(get_closest_vowel(word: \"eAsy\") == \"\")\nassert(get_closest_vowel(word:\
    \ \"ali\") == \"\")\nassert(get_closest_vowel(word: \"bad\") == \"a\")\nassert(get_closest_vowel(word:\
    \ \"most\") == \"o\")\nassert(get_closest_vowel(word: \"ab\") == \"\")\nassert(get_closest_vowel(word:\
    \ \"ba\") == \"\")\nassert(get_closest_vowel(word: \"quick\") == \"\")\nassert(get_closest_vowel(word:\
    \ \"anime\") == \"i\")\nassert(get_closest_vowel(word: \"Asia\") == \"\")\nassert(get_closest_vowel(word:\
    \ \"Above\") == \"o\")"
  status: Exception
  stderr: 'tmp5usmwbgt/tmp5usmwbgt.swift:52: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b6e5659cc80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b6e56293b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b6e56293988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b6e562927b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmp5usmwbgt                        0x000055593c4ad8f7 <unavailable> + 6391

    5    libc.so.6                          0x00002b6e56788460 __libc_start_main +
    245

    6    tmp5usmwbgt                        0x000055593c4ad539 <unavailable> + 5433

    '
  stdout: ''
  timestamp: 1660013566
- exit_code: -4
  program: "\n/// You are given a word. Your task is to find the closest vowel that\
    \ stands between \n/// two consonants from the right side of the word (case sensitive).\n\
    /// Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n/// find any vowel met the above condition. \n/// You may assume that\
    \ the given string contains English letter only.\n/// Example:\n/// >>> get_closest_vowel(word:\
    \ \"yogurt\")\n/// \"u\"\n/// >>> get_closest_vowel(word: \"FULL\")\n/// \"U\"\
    \n/// >>> get_closest_vowel(word: \"quick\")\n/// \"\"\n/// >>> get_closest_vowel(word:\
    \ \"ab\")\n/// \"\"\nfunc get_closest_vowel(word: String) -> String {\n    let\
    \ vowels = [\"a\", \"e\", \"i\", \"o\", \"u\"]\n    var vowelIndex: Int?\n   \
    \ let chars = Array(word)\n    for i in stride(from: chars.count - 1, through:\
    \ 0, by: -1) {\n        if vowels.contains(String(chars[i])) {\n            vowelIndex\
    \ = i\n            break\n        }\n    }\n    if vowelIndex == nil {\n     \
    \   return \"\"\n    }\n    for i in stride(from: vowelIndex! - 1, through: 0,\
    \ by: -1) {\n        if !vowels.contains(String(chars[i])) {\n            return\
    \ String(chars[vowelIndex!])\n        }\n    }\n    return \"\"\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(get_closest_vowel(word: \"yogurt\") == \"u\")\nassert(get_closest_vowel(word:\
    \ \"full\") == \"u\")\nassert(get_closest_vowel(word: \"easy\") == \"\")\nassert(get_closest_vowel(word:\
    \ \"eAsy\") == \"\")\nassert(get_closest_vowel(word: \"ali\") == \"\")\nassert(get_closest_vowel(word:\
    \ \"bad\") == \"a\")\nassert(get_closest_vowel(word: \"most\") == \"o\")\nassert(get_closest_vowel(word:\
    \ \"ab\") == \"\")\nassert(get_closest_vowel(word: \"ba\") == \"\")\nassert(get_closest_vowel(word:\
    \ \"quick\") == \"\")\nassert(get_closest_vowel(word: \"anime\") == \"i\")\nassert(get_closest_vowel(word:\
    \ \"Asia\") == \"\")\nassert(get_closest_vowel(word: \"Above\") == \"o\")"
  status: Exception
  stderr: 'tmpdzo_7y98/tmpdzo_7y98.swift:54: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b09743a3c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b097409ab6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b097409a988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b09740997b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpdzo_7y98                        0x000055990ccbadbb <unavailable> + 7611

    5    libc.so.6                          0x00002b097458f460 __libc_start_main +
    245

    6    tmpdzo_7y98                        0x000055990ccba5b9 <unavailable> + 5561

    '
  stdout: ''
  timestamp: 1660013566
- exit_code: -4
  program: "\n/// You are given a word. Your task is to find the closest vowel that\
    \ stands between \n/// two consonants from the right side of the word (case sensitive).\n\
    /// Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n/// find any vowel met the above condition. \n/// You may assume that\
    \ the given string contains English letter only.\n/// Example:\n/// >>> get_closest_vowel(word:\
    \ \"yogurt\")\n/// \"u\"\n/// >>> get_closest_vowel(word: \"FULL\")\n/// \"U\"\
    \n/// >>> get_closest_vowel(word: \"quick\")\n/// \"\"\n/// >>> get_closest_vowel(word:\
    \ \"ab\")\n/// \"\"\nfunc get_closest_vowel(word: String) -> String {\n    let\
    \ vowels = [\"a\", \"e\", \"i\", \"o\", \"u\"]\n    var output: String = \"\"\n\
    \    for (index, char) in word.lowercased().reversed().enumerated() {\n      \
    \  if vowels.contains(String(char)) {\n            if index == word.count - 1\
    \ {\n                break\n            }\n            if vowels.contains(String(word[word.index(word.endIndex,\
    \ offsetBy: -(index + 2))])) {\n                continue\n            }\n    \
    \        if index == 0 {\n                output = String(char)\n            \
    \    break\n            }\n            output = String(char)\n            break\n\
    \        }\n    }\n    return output\n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(get_closest_vowel(word: \"yogurt\") == \"u\")\nassert(get_closest_vowel(word:\
    \ \"full\") == \"u\")\nassert(get_closest_vowel(word: \"easy\") == \"\")\nassert(get_closest_vowel(word:\
    \ \"eAsy\") == \"\")\nassert(get_closest_vowel(word: \"ali\") == \"\")\nassert(get_closest_vowel(word:\
    \ \"bad\") == \"a\")\nassert(get_closest_vowel(word: \"most\") == \"o\")\nassert(get_closest_vowel(word:\
    \ \"ab\") == \"\")\nassert(get_closest_vowel(word: \"ba\") == \"\")\nassert(get_closest_vowel(word:\
    \ \"quick\") == \"\")\nassert(get_closest_vowel(word: \"anime\") == \"i\")\nassert(get_closest_vowel(word:\
    \ \"Asia\") == \"\")\nassert(get_closest_vowel(word: \"Above\") == \"o\")"
  status: Exception
  stderr: 'tmpcaikm90l/tmpcaikm90l.swift:55: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b400916fc80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b4008e66b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b4008e66988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b4008e657b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpcaikm90l                        0x0000558d5e0cbe9b <unavailable> + 7835

    5    libc.so.6                          0x00002b400935b460 __libc_start_main +
    245

    6    tmpcaikm90l                        0x0000558d5e0cb699 <unavailable> + 5785

    '
  stdout: ''
  timestamp: 1660013566
- exit_code: 1
  program: "\n/// You are given a word. Your task is to find the closest vowel that\
    \ stands between \n/// two consonants from the right side of the word (case sensitive).\n\
    /// Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n/// find any vowel met the above condition. \n/// You may assume that\
    \ the given string contains English letter only.\n/// Example:\n/// >>> get_closest_vowel(word:\
    \ \"yogurt\")\n/// \"u\"\n/// >>> get_closest_vowel(word: \"FULL\")\n/// \"U\"\
    \n/// >>> get_closest_vowel(word: \"quick\")\n/// \"\"\n/// >>> get_closest_vowel(word:\
    \ \"ab\")\n/// \"\"\nfunc get_closest_vowel(word: String) -> String {\n    //\
    \ Find the longest vowel substring and return the last character\n    var longest_vowel_substring\
    \ = \"\"\n    var current_vowel_substring = \"\"\n    var prev_char_is_consonant\
    \ = false\n    for char in word {\n        if is_vowel(char: char) {\n       \
    \     current_vowel_substring.append(char)\n            if prev_char_is_consonant\
    \ {\n                if current_vowel_substring.count > longest_vowel_substring.count\
    \ {\n                    longest_vowel_substring = current_vowel_substring\n \
    \               }\n                current_vowel_substring = \"\"\n          \
    \  }\n        } else {\n            prev_char_is_consonant = true\n        }\n\
    \    }\n    if longest_vowel_substring.count == 0 {\n        return \"\"\n   \
    \ }\n    return longest_vowel_substring.last!\n}\n\n\nfunc ==(left: [(Int, Int)],\
    \ right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n       \
    \ return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r\
    \ {\n            return false\n        }\n    }\n    return true\n}\n        \
    \    \nassert(get_closest_vowel(word: \"yogurt\") == \"u\")\nassert(get_closest_vowel(word:\
    \ \"full\") == \"u\")\nassert(get_closest_vowel(word: \"easy\") == \"\")\nassert(get_closest_vowel(word:\
    \ \"eAsy\") == \"\")\nassert(get_closest_vowel(word: \"ali\") == \"\")\nassert(get_closest_vowel(word:\
    \ \"bad\") == \"a\")\nassert(get_closest_vowel(word: \"most\") == \"o\")\nassert(get_closest_vowel(word:\
    \ \"ab\") == \"\")\nassert(get_closest_vowel(word: \"ba\") == \"\")\nassert(get_closest_vowel(word:\
    \ \"quick\") == \"\")\nassert(get_closest_vowel(word: \"anime\") == \"i\")\nassert(get_closest_vowel(word:\
    \ \"Asia\") == \"\")\nassert(get_closest_vowel(word: \"Above\") == \"o\")"
  status: SyntaxError
  stderr: "/tmp/tmpixl4evk6.swift:22:12: error: cannot find 'is_vowel' in scope\n\
    \        if is_vowel(char: char) {\n           ^~~~~~~~\n/tmp/tmpixl4evk6.swift:37:40:\
    \ error: cannot convert return expression of type 'String.Element' (aka 'Character')\
    \ to return type 'String'\n    return longest_vowel_substring.last!\n        \
    \   ~~~~~~~~~~~~~~~~~~~~~~~~~~~~^\n"
  stdout: ''
  timestamp: 1660013566
- exit_code: 1
  program: "\n/// You are given a word. Your task is to find the closest vowel that\
    \ stands between \n/// two consonants from the right side of the word (case sensitive).\n\
    /// Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n/// find any vowel met the above condition. \n/// You may assume that\
    \ the given string contains English letter only.\n/// Example:\n/// >>> get_closest_vowel(word:\
    \ \"yogurt\")\n/// \"u\"\n/// >>> get_closest_vowel(word: \"FULL\")\n/// \"U\"\
    \n/// >>> get_closest_vowel(word: \"quick\")\n/// \"\"\n/// >>> get_closest_vowel(word:\
    \ \"ab\")\n/// \"\"\nfunc get_closest_vowel(word: String) -> String {\n    let\
    \ vowels = [\"a\", \"e\", \"i\", \"o\", \"u\"]\n    let reversed = String(word.reversed())\n\
    \    var match: String = \"\"\n    for i in 0..<reversed.count {\n        for\
    \ vowel in vowels {\n            if reversed[i] == vowel {\n                if\
    \ i < reversed.count - 1 && !vowels.contains(reversed[i + 1]) {\n            \
    \        if i > 0 && !vowels.contains(reversed[i - 1]) {\n                   \
    \     match = String(reversed[i])\n                        break\n           \
    \         }\n                }\n            }\n        }\n    }\n    return String(match.reversed())\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(get_closest_vowel(word: \"yogurt\") == \"u\")\n\
    assert(get_closest_vowel(word: \"full\") == \"u\")\nassert(get_closest_vowel(word:\
    \ \"easy\") == \"\")\nassert(get_closest_vowel(word: \"eAsy\") == \"\")\nassert(get_closest_vowel(word:\
    \ \"ali\") == \"\")\nassert(get_closest_vowel(word: \"bad\") == \"a\")\nassert(get_closest_vowel(word:\
    \ \"most\") == \"o\")\nassert(get_closest_vowel(word: \"ab\") == \"\")\nassert(get_closest_vowel(word:\
    \ \"ba\") == \"\")\nassert(get_closest_vowel(word: \"quick\") == \"\")\nassert(get_closest_vowel(word:\
    \ \"anime\") == \"i\")\nassert(get_closest_vowel(word: \"Asia\") == \"\")\nassert(get_closest_vowel(word:\
    \ \"Above\") == \"o\")"
  status: SyntaxError
  stderr: "/tmp/tmpqhqwmiib.swift:22:24: error: no exact matches in call to subscript\
    \ \n            if reversed[i] == vowel {\n                       ^\nSwift.String:3:12:\
    \ note: candidate expects value of type 'Range<String.Index>' for parameter #1\
    \ (got 'Int')\n    public subscript(r: Range<String.Index>) -> Substring { get\
    \ }\n           ^\nSwift.Collection:3:23: note: candidate expects value of type\
    \ '(UnboundedRange_) -> ()' for parameter #1 (got 'Int')\n    @inlinable public\
    \ subscript(x: (UnboundedRange_) -> ()) -> Self.SubSequence { get }\n        \
    \              ^\n/tmp/tmpqhqwmiib.swift:23:71: error: cannot convert value of\
    \ type 'Character' to expected argument type 'String'\n                if i <\
    \ reversed.count - 1 && !vowels.contains(reversed[i + 1]) {\n                \
    \                                                      ^\n/tmp/tmpqhqwmiib.swift:24:58:\
    \ error: cannot convert value of type 'Character' to expected argument type 'String'\n\
    \                    if i > 0 && !vowels.contains(reversed[i - 1]) {\n       \
    \                                                  ^\n/tmp/tmpqhqwmiib.swift:25:40:\
    \ error: 'subscript(_:)' is unavailable: cannot subscript String with an Int,\
    \ use a String.Index instead.\n                        match = String(reversed[i])\n\
    \                                       ^~~~~~~~~~~\nSwift.String:3:12: note:\
    \ 'subscript(_:)' has been explicitly marked unavailable here\n    public subscript(i:\
    \ Int) -> Character { get }\n           ^\n"
  stdout: ''
  timestamp: 1660013566
- exit_code: 1
  program: "\n/// You are given a word. Your task is to find the closest vowel that\
    \ stands between \n/// two consonants from the right side of the word (case sensitive).\n\
    /// Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n/// find any vowel met the above condition. \n/// You may assume that\
    \ the given string contains English letter only.\n/// Example:\n/// >>> get_closest_vowel(word:\
    \ \"yogurt\")\n/// \"u\"\n/// >>> get_closest_vowel(word: \"FULL\")\n/// \"U\"\
    \n/// >>> get_closest_vowel(word: \"quick\")\n/// \"\"\n/// >>> get_closest_vowel(word:\
    \ \"ab\")\n/// \"\"\nfunc get_closest_vowel(word: String) -> String {\n    var\
    \ result = \"\"\n    var vowels = [\"a\", \"e\", \"i\", \"o\", \"u\"]\n    var\
    \ consonants = [\"b\", \"c\", \"d\", \"f\", \"g\", \"h\", \"j\", \"k\", \"l\"\
    , \"m\", \"n\", \"p\", \"q\", \"r\", \"s\", \"t\", \"v\", \"w\", \"x\", \"y\"\
    , \"z\"]\n    var foundVowel = false\n    var foundConsonant = false\n    var\
    \ vowelsDistance = [Int]()\n    var closestVowelDistance = Int.max\n    for (index,\
    \ character) in word.characters.enumerated() {\n        if vowels.contains(String(character).lowercased())\
    \ {\n            foundVowel = true\n            for (vowelIndex, vowelCharacter)\
    \ in word.characters.enumerated() {\n                if consonants.contains(String(vowelCharacter).lowercased())\
    \ {\n                    if vowelIndex > index {\n                        foundConsonant\
    \ = true\n                        if vowelIndex - index < closestVowelDistance\
    \ {\n                            closestVowelDistance = vowelIndex - index\n \
    \                           result = String(character)\n                     \
    \   }\n                    }\n                }\n            }\n        }\n  \
    \  }\n    if !foundVowel || !foundConsonant {\n        result = \"\"\n    }\n\
    \    return result\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) ->\
    \ Bool {\n    if left.count != right.count {\n        return false\n    }\n  \
    \  for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(get_closest_vowel(word:\
    \ \"yogurt\") == \"u\")\nassert(get_closest_vowel(word: \"full\") == \"u\")\n\
    assert(get_closest_vowel(word: \"easy\") == \"\")\nassert(get_closest_vowel(word:\
    \ \"eAsy\") == \"\")\nassert(get_closest_vowel(word: \"ali\") == \"\")\nassert(get_closest_vowel(word:\
    \ \"bad\") == \"a\")\nassert(get_closest_vowel(word: \"most\") == \"o\")\nassert(get_closest_vowel(word:\
    \ \"ab\") == \"\")\nassert(get_closest_vowel(word: \"ba\") == \"\")\nassert(get_closest_vowel(word:\
    \ \"quick\") == \"\")\nassert(get_closest_vowel(word: \"anime\") == \"i\")\nassert(get_closest_vowel(word:\
    \ \"Asia\") == \"\")\nassert(get_closest_vowel(word: \"Above\") == \"o\")"
  status: SyntaxError
  stderr: "/tmp/tmpckrz53dg.swift:24:36: error: 'characters' is unavailable: Please\
    \ use String directly\n    for (index, character) in word.characters.enumerated()\
    \ {\n                                   ^~~~~~~~~~\nSwift.String:5:16: note: 'characters'\
    \ was obsoleted in Swift 5.0\n    public var characters: String { get set }\n\
    \               ^\n/tmp/tmpckrz53dg.swift:27:54: error: 'characters' is unavailable:\
    \ Please use String directly\n            for (vowelIndex, vowelCharacter) in\
    \ word.characters.enumerated() {\n                                           \
    \          ^~~~~~~~~~\nSwift.String:5:16: note: 'characters' was obsoleted in\
    \ Swift 5.0\n    public var characters: String { get set }\n               ^\n\
    /tmp/tmpckrz53dg.swift:18:9: warning: variable 'vowels' was never mutated; consider\
    \ changing to 'let' constant\n    var vowels = [\"a\", \"e\", \"i\", \"o\", \"\
    u\"]\n    ~~~ ^\n    let\n/tmp/tmpckrz53dg.swift:19:9: warning: variable 'consonants'\
    \ was never mutated; consider changing to 'let' constant\n    var consonants =\
    \ [\"b\", \"c\", \"d\", \"f\", \"g\", \"h\", \"j\", \"k\", \"l\", \"m\", \"n\"\
    , \"p\", \"q\", \"r\", \"s\", \"t\", \"v\", \"w\", \"x\", \"y\", \"z\"]\n    ~~~\
    \ ^\n    let\n/tmp/tmpckrz53dg.swift:22:9: warning: initialization of variable\
    \ 'vowelsDistance' was never used; consider replacing with assignment to '_' or\
    \ removing it\n    var vowelsDistance = [Int]()\n    ~~~~^~~~~~~~~~~~~~\n    _\n"
  stdout: ''
  timestamp: 1660013566
- exit_code: -4
  program: "\n/// You are given a word. Your task is to find the closest vowel that\
    \ stands between \n/// two consonants from the right side of the word (case sensitive).\n\
    /// Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n/// find any vowel met the above condition. \n/// You may assume that\
    \ the given string contains English letter only.\n/// Example:\n/// >>> get_closest_vowel(word:\
    \ \"yogurt\")\n/// \"u\"\n/// >>> get_closest_vowel(word: \"FULL\")\n/// \"U\"\
    \n/// >>> get_closest_vowel(word: \"quick\")\n/// \"\"\n/// >>> get_closest_vowel(word:\
    \ \"ab\")\n/// \"\"\nfunc get_closest_vowel(word: String) -> String {\n    var\
    \ vowels = [\"a\", \"e\", \"i\", \"o\", \"u\"]\n    var temp = word.lowercased()\n\
    \    var vowelsIndex = 0\n    var consonantsIndex = 1\n    var tempVowels = \"\
    \"\n    var tempConsonants = \"\"\n    var closest = \"\"\n    while consonantsIndex\
    \ < temp.count {\n        if vowels.contains(String(temp[temp.index(temp.startIndex,\
    \ offsetBy: consonantsIndex)])) {\n            tempVowels = String(temp[temp.index(temp.startIndex,\
    \ offsetBy: consonantsIndex)])\n            tempConsonants = String(temp[temp.index(temp.startIndex,\
    \ offsetBy: vowelsIndex)])\n            if consonantsIndex - vowelsIndex > 1 &&\
    \ vowels.contains(tempConsonants) == false {\n                closest = tempVowels\n\
    \                break\n            }\n            vowelsIndex += 1\n        \
    \    consonantsIndex += 1\n        } else {\n            consonantsIndex += 1\n\
    \        }\n    }\n    return closest\n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(get_closest_vowel(word: \"yogurt\") == \"u\")\nassert(get_closest_vowel(word:\
    \ \"full\") == \"u\")\nassert(get_closest_vowel(word: \"easy\") == \"\")\nassert(get_closest_vowel(word:\
    \ \"eAsy\") == \"\")\nassert(get_closest_vowel(word: \"ali\") == \"\")\nassert(get_closest_vowel(word:\
    \ \"bad\") == \"a\")\nassert(get_closest_vowel(word: \"most\") == \"o\")\nassert(get_closest_vowel(word:\
    \ \"ab\") == \"\")\nassert(get_closest_vowel(word: \"ba\") == \"\")\nassert(get_closest_vowel(word:\
    \ \"quick\") == \"\")\nassert(get_closest_vowel(word: \"anime\") == \"i\")\nassert(get_closest_vowel(word:\
    \ \"Asia\") == \"\")\nassert(get_closest_vowel(word: \"Above\") == \"o\")"
  status: Exception
  stderr: 'tmpps0pexg6/tmpps0pexg6.swift:54: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b6901c47c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b690193eb6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b690193e988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b690193d7b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpps0pexg6                        0x0000563bd167e6f7 <unavailable> + 5879

    5    libc.so.6                          0x00002b6901e33460 __libc_start_main +
    245

    6    tmpps0pexg6                        0x0000563bd167e339 <unavailable> + 4921

    '
  stdout: ''
  timestamp: 1660013566
- exit_code: -4
  program: "\n/// You are given a word. Your task is to find the closest vowel that\
    \ stands between \n/// two consonants from the right side of the word (case sensitive).\n\
    /// Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n/// find any vowel met the above condition. \n/// You may assume that\
    \ the given string contains English letter only.\n/// Example:\n/// >>> get_closest_vowel(word:\
    \ \"yogurt\")\n/// \"u\"\n/// >>> get_closest_vowel(word: \"FULL\")\n/// \"U\"\
    \n/// >>> get_closest_vowel(word: \"quick\")\n/// \"\"\n/// >>> get_closest_vowel(word:\
    \ \"ab\")\n/// \"\"\nfunc get_closest_vowel(word: String) -> String {\n    let\
    \ vowels = [\"a\", \"e\", \"i\", \"o\", \"u\"]\n    var result = \"\"\n    var\
    \ indexOfVowel = -1\n    for (index, character) in word.enumerated() {\n     \
    \   if vowels.contains(String(character)) {\n            indexOfVowel = index\n\
    \            break\n        }\n    }\n    if indexOfVowel == -1 {\n        return\
    \ result\n    }\n    for (index, character) in word.enumerated() {\n        if\
    \ vowels.contains(String(character)) {\n            if index > indexOfVowel {\n\
    \                result = String(character)\n                indexOfVowel = index\n\
    \            }\n        }\n    }\n    return result\n}\n\n\nfunc ==(left: [(Int,\
    \ Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n\
    \        return false\n    }\n    for (l, r) in zip(left, right) {\n        if\
    \ l != r {\n            return false\n        }\n    }\n    return true\n}\n \
    \           \nassert(get_closest_vowel(word: \"yogurt\") == \"u\")\nassert(get_closest_vowel(word:\
    \ \"full\") == \"u\")\nassert(get_closest_vowel(word: \"easy\") == \"\")\nassert(get_closest_vowel(word:\
    \ \"eAsy\") == \"\")\nassert(get_closest_vowel(word: \"ali\") == \"\")\nassert(get_closest_vowel(word:\
    \ \"bad\") == \"a\")\nassert(get_closest_vowel(word: \"most\") == \"o\")\nassert(get_closest_vowel(word:\
    \ \"ab\") == \"\")\nassert(get_closest_vowel(word: \"ba\") == \"\")\nassert(get_closest_vowel(word:\
    \ \"quick\") == \"\")\nassert(get_closest_vowel(word: \"anime\") == \"i\")\nassert(get_closest_vowel(word:\
    \ \"Asia\") == \"\")\nassert(get_closest_vowel(word: \"Above\") == \"o\")"
  status: Exception
  stderr: 'tmp07pgkwqo/tmp07pgkwqo.swift:54: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b3c7c82ec80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b3c7c525b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b3c7c525988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b3c7c5247b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmp07pgkwqo                        0x00005597ec476877 <unavailable> + 6263

    5    libc.so.6                          0x00002b3c7ca1a460 __libc_start_main +
    245

    6    tmp07pgkwqo                        0x00005597ec4763c9 <unavailable> + 5065

    '
  stdout: ''
  timestamp: 1660013567
- exit_code: -4
  program: "\n/// You are given a word. Your task is to find the closest vowel that\
    \ stands between \n/// two consonants from the right side of the word (case sensitive).\n\
    /// Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n/// find any vowel met the above condition. \n/// You may assume that\
    \ the given string contains English letter only.\n/// Example:\n/// >>> get_closest_vowel(word:\
    \ \"yogurt\")\n/// \"u\"\n/// >>> get_closest_vowel(word: \"FULL\")\n/// \"U\"\
    \n/// >>> get_closest_vowel(word: \"quick\")\n/// \"\"\n/// >>> get_closest_vowel(word:\
    \ \"ab\")\n/// \"\"\nfunc get_closest_vowel(word: String) -> String {\n    let\
    \ vowels = \"aeiou\"\n    var vowel_char = \"\"\n    for letter in word.lowercased().reversed()\
    \ {\n        if vowels.contains(letter) {\n            vowel_char = String(letter)\n\
    \            break\n        }\n    }\n    return vowel_char\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(get_closest_vowel(word: \"yogurt\") == \"u\")\nassert(get_closest_vowel(word:\
    \ \"full\") == \"u\")\nassert(get_closest_vowel(word: \"easy\") == \"\")\nassert(get_closest_vowel(word:\
    \ \"eAsy\") == \"\")\nassert(get_closest_vowel(word: \"ali\") == \"\")\nassert(get_closest_vowel(word:\
    \ \"bad\") == \"a\")\nassert(get_closest_vowel(word: \"most\") == \"o\")\nassert(get_closest_vowel(word:\
    \ \"ab\") == \"\")\nassert(get_closest_vowel(word: \"ba\") == \"\")\nassert(get_closest_vowel(word:\
    \ \"quick\") == \"\")\nassert(get_closest_vowel(word: \"anime\") == \"i\")\nassert(get_closest_vowel(word:\
    \ \"Asia\") == \"\")\nassert(get_closest_vowel(word: \"Above\") == \"o\")"
  status: Exception
  stderr: 'tmpv84r7fnc/tmpv84r7fnc.swift:43: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b8afbfecc80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b8afbce3b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b8afbce3988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b8afbce27b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpv84r7fnc                        0x000055fe8b588903 <unavailable> + 6403

    5    libc.so.6                          0x00002b8afc1d8460 __libc_start_main +
    245

    6    tmpv84r7fnc                        0x000055fe8b588339 <unavailable> + 4921

    '
  stdout: ''
  timestamp: 1660013567
- exit_code: -4
  program: "\n/// You are given a word. Your task is to find the closest vowel that\
    \ stands between \n/// two consonants from the right side of the word (case sensitive).\n\
    /// Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n/// find any vowel met the above condition. \n/// You may assume that\
    \ the given string contains English letter only.\n/// Example:\n/// >>> get_closest_vowel(word:\
    \ \"yogurt\")\n/// \"u\"\n/// >>> get_closest_vowel(word: \"FULL\")\n/// \"U\"\
    \n/// >>> get_closest_vowel(word: \"quick\")\n/// \"\"\n/// >>> get_closest_vowel(word:\
    \ \"ab\")\n/// \"\"\nfunc get_closest_vowel(word: String) -> String {\n    let\
    \ vowels = \"AEIOUaeiou\"\n    let consonants = \"BCDFGHJKLMNPQRSTVWXYZbcdfghjklmnpqrstvwxyz\"\
    \n    var closest_vowel = \"\"\n    for i in 0..<word.count {\n        let character\
    \ = word[word.index(word.startIndex, offsetBy: i)]\n        if vowels.contains(character)\
    \ {\n            if consonants.contains(word[word.index(word.startIndex, offsetBy:\
    \ i - 1)]) && i < word.count {\n                closest_vowel = String(character)\n\
    \            }\n        }\n    }\n    return closest_vowel\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(get_closest_vowel(word: \"yogurt\") == \"u\")\nassert(get_closest_vowel(word:\
    \ \"full\") == \"u\")\nassert(get_closest_vowel(word: \"easy\") == \"\")\nassert(get_closest_vowel(word:\
    \ \"eAsy\") == \"\")\nassert(get_closest_vowel(word: \"ali\") == \"\")\nassert(get_closest_vowel(word:\
    \ \"bad\") == \"a\")\nassert(get_closest_vowel(word: \"most\") == \"o\")\nassert(get_closest_vowel(word:\
    \ \"ab\") == \"\")\nassert(get_closest_vowel(word: \"ba\") == \"\")\nassert(get_closest_vowel(word:\
    \ \"quick\") == \"\")\nassert(get_closest_vowel(word: \"anime\") == \"i\")\nassert(get_closest_vowel(word:\
    \ \"Asia\") == \"\")\nassert(get_closest_vowel(word: \"Above\") == \"o\")"
  status: Exception
  stderr: 'Swift/StringCharacterView.swift:158: Fatal error: String index is out of
    bounds

    Current stack trace:

    0    libswiftCore.so                    0x00002b06e5891c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b06e5588561 <unavailable> + 1434977

    2    libswiftCore.so                    0x00002b06e5588286 <unavailable> + 1434246

    3    libswiftCore.so                    0x00002b06e558813c <unavailable> + 1433916

    4    libswiftCore.so                    0x00002b06e5587bb0 _assertionFailure(_:_:file:line:flags:)
    + 251

    5    libswiftCore.so                    0x00002b06e56bbb0d <unavailable> + 2693901

    6    tmpx5bok65s                        0x0000557e9dea47e5 <unavailable> + 10213

    7    tmpx5bok65s                        0x0000557e9dea3873 <unavailable> + 6259

    8    libc.so.6                          0x00002b06e5a7d460 __libc_start_main +
    245

    9    tmpx5bok65s                        0x0000557e9dea3399 <unavailable> + 5017

    '
  stdout: ''
  timestamp: 1660013567
- exit_code: -4
  program: "\n/// You are given a word. Your task is to find the closest vowel that\
    \ stands between \n/// two consonants from the right side of the word (case sensitive).\n\
    /// Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n/// find any vowel met the above condition. \n/// You may assume that\
    \ the given string contains English letter only.\n/// Example:\n/// >>> get_closest_vowel(word:\
    \ \"yogurt\")\n/// \"u\"\n/// >>> get_closest_vowel(word: \"FULL\")\n/// \"U\"\
    \n/// >>> get_closest_vowel(word: \"quick\")\n/// \"\"\n/// >>> get_closest_vowel(word:\
    \ \"ab\")\n/// \"\"\nfunc get_closest_vowel(word: String) -> String {\n    var\
    \ result = \"\"\n    let consonants = \"bcdfghjklmnpqrstvwxyz\"\n    let vowels\
    \ = \"aeiou\"\n    var left_index = 0\n    for i in stride(from: word.count -\
    \ 1, through: 0, by: -1) {\n        let index = word.index(word.startIndex, offsetBy:\
    \ i)\n        if consonants.contains(word[index]) {\n            left_index =\
    \ i\n            break\n        }\n    }\n    var min_dist = word.count\n    for\
    \ i in stride(from: word.count - 1, through: left_index, by: -1) {\n        let\
    \ index = word.index(word.startIndex, offsetBy: i)\n        if vowels.contains(word[index])\
    \ {\n            if i - left_index < min_dist {\n                min_dist = i\
    \ - left_index\n                result = String(word[index])\n            }\n\
    \        }\n    }\n    return result\n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(get_closest_vowel(word: \"yogurt\") == \"u\")\nassert(get_closest_vowel(word:\
    \ \"full\") == \"u\")\nassert(get_closest_vowel(word: \"easy\") == \"\")\nassert(get_closest_vowel(word:\
    \ \"eAsy\") == \"\")\nassert(get_closest_vowel(word: \"ali\") == \"\")\nassert(get_closest_vowel(word:\
    \ \"bad\") == \"a\")\nassert(get_closest_vowel(word: \"most\") == \"o\")\nassert(get_closest_vowel(word:\
    \ \"ab\") == \"\")\nassert(get_closest_vowel(word: \"ba\") == \"\")\nassert(get_closest_vowel(word:\
    \ \"quick\") == \"\")\nassert(get_closest_vowel(word: \"anime\") == \"i\")\nassert(get_closest_vowel(word:\
    \ \"Asia\") == \"\")\nassert(get_closest_vowel(word: \"Above\") == \"o\")"
  status: Exception
  stderr: 'tmpotjmoool/tmpotjmoool.swift:54: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b258cbb7c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b258c8aeb6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b258c8ae988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b258c8ad7b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpotjmoool                        0x000055c3319107f7 <unavailable> + 6135

    5    libc.so.6                          0x00002b258cda3460 __libc_start_main +
    245

    6    tmpotjmoool                        0x000055c331910439 <unavailable> + 5177

    '
  stdout: ''
  timestamp: 1660013567
- exit_code: -4
  program: "\n/// You are given a word. Your task is to find the closest vowel that\
    \ stands between \n/// two consonants from the right side of the word (case sensitive).\n\
    /// Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n/// find any vowel met the above condition. \n/// You may assume that\
    \ the given string contains English letter only.\n/// Example:\n/// >>> get_closest_vowel(word:\
    \ \"yogurt\")\n/// \"u\"\n/// >>> get_closest_vowel(word: \"FULL\")\n/// \"U\"\
    \n/// >>> get_closest_vowel(word: \"quick\")\n/// \"\"\n/// >>> get_closest_vowel(word:\
    \ \"ab\")\n/// \"\"\nfunc get_closest_vowel(word: String) -> String {\n    return\
    \ \"\"\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n  \
    \  if left.count != right.count {\n        return false\n    }\n    for (l, r)\
    \ in zip(left, right) {\n        if l != r {\n            return false\n     \
    \   }\n    }\n    return true\n}\n            \nassert(get_closest_vowel(word:\
    \ \"yogurt\") == \"u\")\nassert(get_closest_vowel(word: \"full\") == \"u\")\n\
    assert(get_closest_vowel(word: \"easy\") == \"\")\nassert(get_closest_vowel(word:\
    \ \"eAsy\") == \"\")\nassert(get_closest_vowel(word: \"ali\") == \"\")\nassert(get_closest_vowel(word:\
    \ \"bad\") == \"a\")\nassert(get_closest_vowel(word: \"most\") == \"o\")\nassert(get_closest_vowel(word:\
    \ \"ab\") == \"\")\nassert(get_closest_vowel(word: \"ba\") == \"\")\nassert(get_closest_vowel(word:\
    \ \"quick\") == \"\")\nassert(get_closest_vowel(word: \"anime\") == \"i\")\nassert(get_closest_vowel(word:\
    \ \"Asia\") == \"\")\nassert(get_closest_vowel(word: \"Above\") == \"o\")"
  status: Exception
  stderr: 'tmpvf1hzub_/tmpvf1hzub_.swift:33: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002ba694399c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002ba694090b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002ba694090988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002ba69408f7b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpvf1hzub_                        0x00005567315f8307 <unavailable> + 4871

    5    libc.so.6                          0x00002ba694585460 __libc_start_main +
    245

    6    tmpvf1hzub_                        0x00005567315f7f49 <unavailable> + 3913

    '
  stdout: ''
  timestamp: 1660013566
- exit_code: -4
  program: "\n/// You are given a word. Your task is to find the closest vowel that\
    \ stands between \n/// two consonants from the right side of the word (case sensitive).\n\
    /// Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n/// find any vowel met the above condition. \n/// You may assume that\
    \ the given string contains English letter only.\n/// Example:\n/// >>> get_closest_vowel(word:\
    \ \"yogurt\")\n/// \"u\"\n/// >>> get_closest_vowel(word: \"FULL\")\n/// \"U\"\
    \n/// >>> get_closest_vowel(word: \"quick\")\n/// \"\"\n/// >>> get_closest_vowel(word:\
    \ \"ab\")\n/// \"\"\nfunc get_closest_vowel(word: String) -> String {\n    let\
    \ vowels = [\"a\", \"e\", \"i\", \"o\", \"u\"]\n    let string = Array(word)\n\
    \    var vowel_index: Int?\n    for (index, character) in string.enumerated()\
    \ {\n        let char = String(character)\n        if vowels.contains(char) {\n\
    \            vowel_index = index\n            break\n        }\n    }\n    if\
    \ vowel_index == nil {\n        return \"\"\n    }\n    var vowel_distance = string.count\
    \ - vowel_index!\n    var closest_vowel: String?\n    for (index, character) in\
    \ string.enumerated() {\n        let char = String(character)\n        if vowels.contains(char)\
    \ {\n            let distance = string.count - index\n            if distance\
    \ > vowel_distance {\n                vowel_distance = distance\n            \
    \    closest_vowel = char\n            }\n        }\n    }\n    return closest_vowel\
    \ ?? \"\"\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n\
    \    if left.count != right.count {\n        return false\n    }\n    for (l,\
    \ r) in zip(left, right) {\n        if l != r {\n            return false\n  \
    \      }\n    }\n    return true\n}\n            \nassert(get_closest_vowel(word:\
    \ \"yogurt\") == \"u\")\nassert(get_closest_vowel(word: \"full\") == \"u\")\n\
    assert(get_closest_vowel(word: \"easy\") == \"\")\nassert(get_closest_vowel(word:\
    \ \"eAsy\") == \"\")\nassert(get_closest_vowel(word: \"ali\") == \"\")\nassert(get_closest_vowel(word:\
    \ \"bad\") == \"a\")\nassert(get_closest_vowel(word: \"most\") == \"o\")\nassert(get_closest_vowel(word:\
    \ \"ab\") == \"\")\nassert(get_closest_vowel(word: \"ba\") == \"\")\nassert(get_closest_vowel(word:\
    \ \"quick\") == \"\")\nassert(get_closest_vowel(word: \"anime\") == \"i\")\nassert(get_closest_vowel(word:\
    \ \"Asia\") == \"\")\nassert(get_closest_vowel(word: \"Above\") == \"o\")"
  status: Exception
  stderr: 'tmpy2_f1w3e/tmpy2_f1w3e.swift:58: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b15debd6c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b15de8cdb6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b15de8cd988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b15de8cc7b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpy2_f1w3e                        0x00005561b19bc917 <unavailable> + 6423

    5    libc.so.6                          0x00002b15dedc2460 __libc_start_main +
    245

    6    tmpy2_f1w3e                        0x00005561b19bc559 <unavailable> + 5465

    '
  stdout: ''
  timestamp: 1660013567
- exit_code: -4
  program: "\n/// You are given a word. Your task is to find the closest vowel that\
    \ stands between \n/// two consonants from the right side of the word (case sensitive).\n\
    /// Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n/// find any vowel met the above condition. \n/// You may assume that\
    \ the given string contains English letter only.\n/// Example:\n/// >>> get_closest_vowel(word:\
    \ \"yogurt\")\n/// \"u\"\n/// >>> get_closest_vowel(word: \"FULL\")\n/// \"U\"\
    \n/// >>> get_closest_vowel(word: \"quick\")\n/// \"\"\n/// >>> get_closest_vowel(word:\
    \ \"ab\")\n/// \"\"\nfunc get_closest_vowel(word: String) -> String {\n    let\
    \ vowels = \"AEIOU\"\n    let consonants = \"BCDFGHJKLMNPQRSTVWXYZ\"\n    var\
    \ result = \"\"\n    var temp = \"\"\n    for char in word.reversed() {\n    \
    \    if !vowels.contains(char) && !consonants.contains(char) {\n            return\
    \ \"\"\n        }\n        if vowels.contains(char) {\n            result = temp\
    \ + String(char)\n            temp = \"\"\n        } else {\n            temp\
    \ += String(char)\n        }\n    }\n    return result\n}\n\n\nfunc ==(left: [(Int,\
    \ Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n\
    \        return false\n    }\n    for (l, r) in zip(left, right) {\n        if\
    \ l != r {\n            return false\n        }\n    }\n    return true\n}\n \
    \           \nassert(get_closest_vowel(word: \"yogurt\") == \"u\")\nassert(get_closest_vowel(word:\
    \ \"full\") == \"u\")\nassert(get_closest_vowel(word: \"easy\") == \"\")\nassert(get_closest_vowel(word:\
    \ \"eAsy\") == \"\")\nassert(get_closest_vowel(word: \"ali\") == \"\")\nassert(get_closest_vowel(word:\
    \ \"bad\") == \"a\")\nassert(get_closest_vowel(word: \"most\") == \"o\")\nassert(get_closest_vowel(word:\
    \ \"ab\") == \"\")\nassert(get_closest_vowel(word: \"ba\") == \"\")\nassert(get_closest_vowel(word:\
    \ \"quick\") == \"\")\nassert(get_closest_vowel(word: \"anime\") == \"i\")\nassert(get_closest_vowel(word:\
    \ \"Asia\") == \"\")\nassert(get_closest_vowel(word: \"Above\") == \"o\")"
  status: Exception
  stderr: 'tmpsdlg6oeg/tmpsdlg6oeg.swift:48: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002aff76ce8c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002aff769dfb6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002aff769df988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002aff769de7b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpsdlg6oeg                        0x000055b020bfd757 <unavailable> + 5975

    5    libc.so.6                          0x00002aff76ed4460 __libc_start_main +
    245

    6    tmpsdlg6oeg                        0x000055b020bfd399 <unavailable> + 5017

    '
  stdout: ''
  timestamp: 1660013567
- exit_code: 1
  program: "\n/// You are given a word. Your task is to find the closest vowel that\
    \ stands between \n/// two consonants from the right side of the word (case sensitive).\n\
    /// Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n/// find any vowel met the above condition. \n/// You may assume that\
    \ the given string contains English letter only.\n/// Example:\n/// >>> get_closest_vowel(word:\
    \ \"yogurt\")\n/// \"u\"\n/// >>> get_closest_vowel(word: \"FULL\")\n/// \"U\"\
    \n/// >>> get_closest_vowel(word: \"quick\")\n/// \"\"\n/// >>> get_closest_vowel(word:\
    \ \"ab\")\n/// \"\"\nfunc get_closest_vowel(word: String) -> String {\n    var\
    \ copyWord = word\n    var closestVowel = \"\"\n    var vowelDictionary = [\"\
    a\": 0, \"e\": 0, \"i\": 0, \"o\": 0, \"u\": 0]\n    let vowels = \"aeiou\"\n\
    \    let consonants = \"bcdfghjklmnpqrstvwxyz\"\n    let empty = \"\"\n    var\
    \ currentIndex: String.Index\n    var vowelIndex: String.Index\n    var vowelString:\
    \ String\n    var distanceFromVowel: Int\n    var originalVowelDistance: Int\n\
    \    var consonantIndex: String.Index\n    var consonantString: String\n    var\
    \ originalConsonantDistance: Int\n    var distanceFromConsonant: Int\n    var\
    \ endOfWord: String.Index\n    var vowelDistance: Int\n    var stringDistance:\
    \ Int\n    var vowelStringDistance: Int\n    var greatestDistance: Int\n    var\
    \ booleanFindVowel = false\n    var booleanFoundVowel = false\n    var booleanFindConsonant\
    \ = false\n    var booleanFoundConsonant = false\n    var booleanFoundVowelAndConsonant\
    \ = false\n    var booleanFindVowelAndConsonant = false\n    var booleanFoundIt\
    \ = false\n    var currentLetter: String\n    var previousLetter: String\n   \
    \ var nextLetter: String\n    let i = copyWord.endIndex\n    endOfWord = copyWord.index(before:\
    \ i)\n    currentIndex = copyWord.index(copyWord.startIndex, offsetBy: 0)\n  \
    \  vowelIndex = copyWord.index(copyWord.startIndex, offsetBy: 0)\n    consonantIndex\
    \ = copyWord.index(copyWord.startIndex, offsetBy: 0)\n    originalVowelDistance\
    \ = copyWord.distance(from: currentIndex, to: endOfWord)\n    originalConsonantDistance\
    \ = copyWord.distance(from: currentIndex, to: endOfWord)\n    greatestDistance\
    \ = 0\n    while currentIndex != endOfWord {\n        currentLetter = String(copyWord[currentIndex])\n\
    \        previousLetter = String(copyWord[copyWord.index(before: currentIndex)])\n\
    \        nextLetter = String(copyWord[copyWord.index(after: currentIndex\n}\n\n\
    \nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(get_closest_vowel(word: \"yogurt\") == \"u\")\n\
    assert(get_closest_vowel(word: \"full\") == \"u\")\nassert(get_closest_vowel(word:\
    \ \"easy\") == \"\")\nassert(get_closest_vowel(word: \"eAsy\") == \"\")\nassert(get_closest_vowel(word:\
    \ \"ali\") == \"\")\nassert(get_closest_vowel(word: \"bad\") == \"a\")\nassert(get_closest_vowel(word:\
    \ \"most\") == \"o\")\nassert(get_closest_vowel(word: \"ab\") == \"\")\nassert(get_closest_vowel(word:\
    \ \"ba\") == \"\")\nassert(get_closest_vowel(word: \"quick\") == \"\")\nassert(get_closest_vowel(word:\
    \ \"anime\") == \"i\")\nassert(get_closest_vowel(word: \"Asia\") == \"\")\nassert(get_closest_vowel(word:\
    \ \"Above\") == \"o\")"
  status: SyntaxError
  stderr: "/tmp/tmp98nqv9dn.swift:59:1: error: expected ')' in expression list\n}\n\
    ^\n/tmp/tmp98nqv9dn.swift:58:52: note: to match this opening '('\n        nextLetter\
    \ = String(copyWord[copyWord.index(after: currentIndex\n                     \
    \                              ^\n/tmp/tmp98nqv9dn.swift:86:48: error: expected\
    \ '}' at end of brace statement\nassert(get_closest_vowel(word: \"Above\") ==\
    \ \"o\")\n                                               ^\n/tmp/tmp98nqv9dn.swift:16:48:\
    \ note: to match this opening '{'\nfunc get_closest_vowel(word: String) -> String\
    \ {\n                                               ^\n/tmp/tmp98nqv9dn.swift:62:6:\
    \ error: operator functions can only be declared at global or in type scope\n\
    func ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n     ^\n/tmp/tmp98nqv9dn.swift:17:9:\
    \ warning: variable 'copyWord' was never mutated; consider changing to 'let' constant\n\
    \    var copyWord = word\n    ~~~ ^\n    let\n/tmp/tmp98nqv9dn.swift:18:9: warning:\
    \ initialization of variable 'closestVowel' was never used; consider replacing\
    \ with assignment to '_' or removing it\n    var closestVowel = \"\"\n    ~~~~^~~~~~~~~~~~\n\
    \    _\n/tmp/tmp98nqv9dn.swift:19:9: warning: initialization of variable 'vowelDictionary'\
    \ was never used; consider replacing with assignment to '_' or removing it\n \
    \   var vowelDictionary = [\"a\": 0, \"e\": 0, \"i\": 0, \"o\": 0, \"u\": 0]\n\
    \    ~~~~^~~~~~~~~~~~~~~\n    _\n/tmp/tmp98nqv9dn.swift:20:9: warning: initialization\
    \ of immutable value 'vowels' was never used; consider replacing with assignment\
    \ to '_' or removing it\n    let vowels = \"aeiou\"\n    ~~~~^~~~~~\n    _\n/tmp/tmp98nqv9dn.swift:21:9:\
    \ warning: initialization of immutable value 'consonants' was never used; consider\
    \ replacing with assignment to '_' or removing it\n    let consonants = \"bcdfghjklmnpqrstvwxyz\"\
    \n    ~~~~^~~~~~~~~~\n    _\n/tmp/tmp98nqv9dn.swift:22:9: warning: initialization\
    \ of immutable value 'empty' was never used; consider replacing with assignment\
    \ to '_' or removing it\n    let empty = \"\"\n    ~~~~^~~~~\n    _\n/tmp/tmp98nqv9dn.swift:24:9:\
    \ warning: variable 'vowel"
  stdout: ''
  timestamp: 1660013566
- exit_code: -4
  program: "\n/// You are given a word. Your task is to find the closest vowel that\
    \ stands between \n/// two consonants from the right side of the word (case sensitive).\n\
    /// Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n/// find any vowel met the above condition. \n/// You may assume that\
    \ the given string contains English letter only.\n/// Example:\n/// >>> get_closest_vowel(word:\
    \ \"yogurt\")\n/// \"u\"\n/// >>> get_closest_vowel(word: \"FULL\")\n/// \"U\"\
    \n/// >>> get_closest_vowel(word: \"quick\")\n/// \"\"\n/// >>> get_closest_vowel(word:\
    \ \"ab\")\n/// \"\"\nfunc get_closest_vowel(word: String) -> String {\n    return\
    \ \"\";\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n \
    \   if left.count != right.count {\n        return false\n    }\n    for (l, r)\
    \ in zip(left, right) {\n        if l != r {\n            return false\n     \
    \   }\n    }\n    return true\n}\n            \nassert(get_closest_vowel(word:\
    \ \"yogurt\") == \"u\")\nassert(get_closest_vowel(word: \"full\") == \"u\")\n\
    assert(get_closest_vowel(word: \"easy\") == \"\")\nassert(get_closest_vowel(word:\
    \ \"eAsy\") == \"\")\nassert(get_closest_vowel(word: \"ali\") == \"\")\nassert(get_closest_vowel(word:\
    \ \"bad\") == \"a\")\nassert(get_closest_vowel(word: \"most\") == \"o\")\nassert(get_closest_vowel(word:\
    \ \"ab\") == \"\")\nassert(get_closest_vowel(word: \"ba\") == \"\")\nassert(get_closest_vowel(word:\
    \ \"quick\") == \"\")\nassert(get_closest_vowel(word: \"anime\") == \"i\")\nassert(get_closest_vowel(word:\
    \ \"Asia\") == \"\")\nassert(get_closest_vowel(word: \"Above\") == \"o\")"
  status: Exception
  stderr: 'tmpt5rfwauv/tmpt5rfwauv.swift:33: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002ad44b068c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002ad44ad5fb6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002ad44ad5f988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002ad44ad5e7b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpt5rfwauv                        0x000055ef9f1d9307 <unavailable> + 4871

    5    libc.so.6                          0x00002ad44b254460 __libc_start_main +
    245

    6    tmpt5rfwauv                        0x000055ef9f1d8f49 <unavailable> + 3913

    '
  stdout: ''
  timestamp: 1660013567
- exit_code: -4
  program: "\n/// You are given a word. Your task is to find the closest vowel that\
    \ stands between \n/// two consonants from the right side of the word (case sensitive).\n\
    /// Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n/// find any vowel met the above condition. \n/// You may assume that\
    \ the given string contains English letter only.\n/// Example:\n/// >>> get_closest_vowel(word:\
    \ \"yogurt\")\n/// \"u\"\n/// >>> get_closest_vowel(word: \"FULL\")\n/// \"U\"\
    \n/// >>> get_closest_vowel(word: \"quick\")\n/// \"\"\n/// >>> get_closest_vowel(word:\
    \ \"ab\")\n/// \"\"\nfunc get_closest_vowel(word: String) -> String {\n    let\
    \ vowels = [\"a\", \"e\", \"i\", \"o\", \"u\"]\n    var result = \"\"\n    for\
    \ i in (0..<word.count).reversed() {\n        if i > 0 {\n            if !vowels.contains(String(word[word.index(word.startIndex,\
    \ offsetBy: i)])) {\n                if vowels.contains(String(word[word.index(word.startIndex,\
    \ offsetBy: i - 1)])) {\n                    result = String(word[word.index(word.startIndex,\
    \ offsetBy: i - 1)])\n                    break\n                }\n         \
    \   }\n        }\n    }\n    return result\n}\n\n\nfunc ==(left: [(Int, Int)],\
    \ right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n       \
    \ return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r\
    \ {\n            return false\n        }\n    }\n    return true\n}\n        \
    \    \nassert(get_closest_vowel(word: \"yogurt\") == \"u\")\nassert(get_closest_vowel(word:\
    \ \"full\") == \"u\")\nassert(get_closest_vowel(word: \"easy\") == \"\")\nassert(get_closest_vowel(word:\
    \ \"eAsy\") == \"\")\nassert(get_closest_vowel(word: \"ali\") == \"\")\nassert(get_closest_vowel(word:\
    \ \"bad\") == \"a\")\nassert(get_closest_vowel(word: \"most\") == \"o\")\nassert(get_closest_vowel(word:\
    \ \"ab\") == \"\")\nassert(get_closest_vowel(word: \"ba\") == \"\")\nassert(get_closest_vowel(word:\
    \ \"quick\") == \"\")\nassert(get_closest_vowel(word: \"anime\") == \"i\")\nassert(get_closest_vowel(word:\
    \ \"Asia\") == \"\")\nassert(get_closest_vowel(word: \"Above\") == \"o\")"
  status: Exception
  stderr: 'tmpl0wvtlcv/tmpl0wvtlcv.swift:47: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002ae608415c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002ae60810cb6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002ae60810c988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002ae60810b7b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpl0wvtlcv                        0x000055e440f6bc03 <unavailable> + 7171

    5    libc.so.6                          0x00002ae608601460 __libc_start_main +
    245

    6    tmpl0wvtlcv                        0x000055e440f6b639 <unavailable> + 5689

    '
  stdout: ''
  timestamp: 1660013567
- exit_code: 0
  program: "\n/// You are given a word. Your task is to find the closest vowel that\
    \ stands between \n/// two consonants from the right side of the word (case sensitive).\n\
    /// Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n/// find any vowel met the above condition. \n/// You may assume that\
    \ the given string contains English letter only.\n/// Example:\n/// >>> get_closest_vowel(word:\
    \ \"yogurt\")\n/// \"u\"\n/// >>> get_closest_vowel(word: \"FULL\")\n/// \"U\"\
    \n/// >>> get_closest_vowel(word: \"quick\")\n/// \"\"\n/// >>> get_closest_vowel(word:\
    \ \"ab\")\n/// \"\"\nfunc get_closest_vowel(word: String) -> String {\n    //YOUR\
    \ CODE GOES HERE\n    let vowels: [Character] = [\"a\", \"e\", \"i\", \"o\", \"\
    u\"]\n    let chars = Array(word)\n    for i in (0..<chars.count).reversed() {\n\
    \        if vowels.contains(chars[i]) {\n            if (i == 0) || (i == chars.count\
    \ - 1) {\n                continue\n            }\n            else if vowels.contains(chars[i\
    \ - 1]) || vowels.contains(chars[i + 1]) {\n                continue\n       \
    \     }\n            else {\n                return String(chars[i])\n       \
    \     }\n        }\n    }\n    return \"\"\n}\n\n\nfunc ==(left: [(Int, Int)],\
    \ right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n       \
    \ return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r\
    \ {\n            return false\n        }\n    }\n    return true\n}\n        \
    \    \nassert(get_closest_vowel(word: \"yogurt\") == \"u\")\nassert(get_closest_vowel(word:\
    \ \"full\") == \"u\")\nassert(get_closest_vowel(word: \"easy\") == \"\")\nassert(get_closest_vowel(word:\
    \ \"eAsy\") == \"\")\nassert(get_closest_vowel(word: \"ali\") == \"\")\nassert(get_closest_vowel(word:\
    \ \"bad\") == \"a\")\nassert(get_closest_vowel(word: \"most\") == \"o\")\nassert(get_closest_vowel(word:\
    \ \"ab\") == \"\")\nassert(get_closest_vowel(word: \"ba\") == \"\")\nassert(get_closest_vowel(word:\
    \ \"quick\") == \"\")\nassert(get_closest_vowel(word: \"anime\") == \"i\")\nassert(get_closest_vowel(word:\
    \ \"Asia\") == \"\")\nassert(get_closest_vowel(word: \"Above\") == \"o\")"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660013567
- exit_code: -4
  program: "\n/// You are given a word. Your task is to find the closest vowel that\
    \ stands between \n/// two consonants from the right side of the word (case sensitive).\n\
    /// Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n/// find any vowel met the above condition. \n/// You may assume that\
    \ the given string contains English letter only.\n/// Example:\n/// >>> get_closest_vowel(word:\
    \ \"yogurt\")\n/// \"u\"\n/// >>> get_closest_vowel(word: \"FULL\")\n/// \"U\"\
    \n/// >>> get_closest_vowel(word: \"quick\")\n/// \"\"\n/// >>> get_closest_vowel(word:\
    \ \"ab\")\n/// \"\"\nfunc get_closest_vowel(word: String) -> String {\n    //\
    \ \n    var temp_index: Int = 0\n    var vowel_index: Int = 0\n    var vowel_index_arr:\
    \ [Int] = []\n    var vowel_index_arr_abs: [Int] = []\n    var vowel_index_abs:\
    \ Int = 0\n    let vowels = [\"a\", \"e\", \"i\", \"o\", \"u\", \"A\", \"E\",\
    \ \"I\", \"O\", \"U\"]\n    for (index, character) in word.enumerated() {\n  \
    \      if vowels.contains(String(character)) {\n            vowel_index_arr.append(index)\n\
    \        }\n    }\n    if vowel_index_arr.count > 0 {\n        vowel_index = vowel_index_arr.last!\n\
    \        for i in vowel_index_arr {\n            vowel_index_arr_abs.append(abs(vowel_index\
    \ - i))\n        }\n        vowel_index_abs = vowel_index_arr_abs.min()!\n   \
    \     temp_index = vowel_index_arr.count - 1 - vowel_index_arr_abs.lastIndex(of:\
    \ vowel_index_abs)!\n        vowel_index = vowel_index_arr[temp_index]\n     \
    \   return String(word[word.index(word.startIndex, offsetBy: vowel_index)])\n\
    \    } else {\n        return \"\"\n    }\n}\n\n\nfunc ==(left: [(Int, Int)],\
    \ right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n       \
    \ return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r\
    \ {\n            return false\n        }\n    }\n    return true\n}\n        \
    \    \nassert(get_closest_vowel(word: \"yogurt\") == \"u\")\nassert(get_closest_vowel(word:\
    \ \"full\") == \"u\")\nassert(get_closest_vowel(word: \"easy\") == \"\")\nassert(get_closest_vowel(word:\
    \ \"eAsy\") == \"\")\nassert(get_closest_vowel(word: \"ali\") == \"\")\nassert(get_closest_vowel(word:\
    \ \"bad\") == \"a\")\nassert(get_closest_vowel(word: \"most\") == \"o\")\nassert(get_closest_vowel(word:\
    \ \"ab\") == \"\")\nassert(get_closest_vowel(word: \"ba\") == \"\")\nassert(get_closest_vowel(word:\
    \ \"quick\") == \"\")\nassert(get_closest_vowel(word: \"anime\") == \"i\")\nassert(get_closest_vowel(word:\
    \ \"Asia\") == \"\")\nassert(get_closest_vowel(word: \"Above\") == \"o\")"
  status: Exception
  stderr: 'tmpp68c1ywf/tmpp68c1ywf.swift:56: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b2fc0e40c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b2fc0b37b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b2fc0b37988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b2fc0b367b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpp68c1ywf                        0x00005634f2644df7 <unavailable> + 7671

    5    libc.so.6                          0x00002b2fc102c460 __libc_start_main +
    245

    6    tmpp68c1ywf                        0x00005634f2644a39 <unavailable> + 6713

    '
  stdout: ''
  timestamp: 1660013567
- exit_code: -4
  program: "\n/// You are given a word. Your task is to find the closest vowel that\
    \ stands between \n/// two consonants from the right side of the word (case sensitive).\n\
    /// Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n/// find any vowel met the above condition. \n/// You may assume that\
    \ the given string contains English letter only.\n/// Example:\n/// >>> get_closest_vowel(word:\
    \ \"yogurt\")\n/// \"u\"\n/// >>> get_closest_vowel(word: \"FULL\")\n/// \"U\"\
    \n/// >>> get_closest_vowel(word: \"quick\")\n/// \"\"\n/// >>> get_closest_vowel(word:\
    \ \"ab\")\n/// \"\"\nfunc get_closest_vowel(word: String) -> String {\n    var\
    \ previousVowel: Character?\n    var currentVowel: Character?\n    var stop: Bool\
    \ = false\n    var letters = Array(word)\n    for i in (0..<letters.count).reversed()\
    \ {\n        if stop {\n            break\n        }\n        let char = letters[i]\n\
    \        switch char {\n        case \"a\", \"e\", \"i\", \"o\", \"u\", \"A\"\
    , \"E\", \"I\", \"O\", \"U\":\n            if currentVowel == nil {\n        \
    \        currentVowel = char\n            } else {\n                if previousVowel\
    \ == nil {\n                    previousVowel = char\n                    stop\
    \ = true\n                }\n            }\n        default:\n            if previousVowel\
    \ != nil && currentVowel != nil {\n                stop = true\n            }\n\
    \        }\n    }\n    if previousVowel != nil && currentVowel != nil {\n    \
    \    return String(previousVowel!)\n    }\n    return \"\"\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(get_closest_vowel(word: \"yogurt\") == \"u\")\nassert(get_closest_vowel(word:\
    \ \"full\") == \"u\")\nassert(get_closest_vowel(word: \"easy\") == \"\")\nassert(get_closest_vowel(word:\
    \ \"eAsy\") == \"\")\nassert(get_closest_vowel(word: \"ali\") == \"\")\nassert(get_closest_vowel(word:\
    \ \"bad\") == \"a\")\nassert(get_closest_vowel(word: \"most\") == \"o\")\nassert(get_closest_vowel(word:\
    \ \"ab\") == \"\")\nassert(get_closest_vowel(word: \"ba\") == \"\")\nassert(get_closest_vowel(word:\
    \ \"quick\") == \"\")\nassert(get_closest_vowel(word: \"anime\") == \"i\")\nassert(get_closest_vowel(word:\
    \ \"Asia\") == \"\")\nassert(get_closest_vowel(word: \"Above\") == \"o\")"
  status: Exception
  stderr: 'tmpg9gyn6o_/tmpg9gyn6o_.swift:61: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002abe18f63c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002abe18c5ab6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002abe18c5a988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002abe18c597b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpg9gyn6o_                        0x000055f59f1629a7 <unavailable> + 6567

    5    libc.so.6                          0x00002abe1914f460 __libc_start_main +
    245

    6    tmpg9gyn6o_                        0x000055f59f1625e9 <unavailable> + 5609

    '
  stdout: ''
  timestamp: 1660013567
- exit_code: 1
  program: "\n/// You are given a word. Your task is to find the closest vowel that\
    \ stands between \n/// two consonants from the right side of the word (case sensitive).\n\
    /// Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n/// find any vowel met the above condition. \n/// You may assume that\
    \ the given string contains English letter only.\n/// Example:\n/// >>> get_closest_vowel(word:\
    \ \"yogurt\")\n/// \"u\"\n/// >>> get_closest_vowel(word: \"FULL\")\n/// \"U\"\
    \n/// >>> get_closest_vowel(word: \"quick\")\n/// \"\"\n/// >>> get_closest_vowel(word:\
    \ \"ab\")\n/// \"\"\nfunc get_closest_vowel(word: String) -> String {\n    let\
    \ vowels = Set(\"aeiouAEIOU\")\n    for ch in word.characters.reversed() {\n \
    \       if vowels.contains(ch) {\n            return String(ch)\n        }\n \
    \   }\n    return \"\"\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(get_closest_vowel(word:\
    \ \"yogurt\") == \"u\")\nassert(get_closest_vowel(word: \"full\") == \"u\")\n\
    assert(get_closest_vowel(word: \"easy\") == \"\")\nassert(get_closest_vowel(word:\
    \ \"eAsy\") == \"\")\nassert(get_closest_vowel(word: \"ali\") == \"\")\nassert(get_closest_vowel(word:\
    \ \"bad\") == \"a\")\nassert(get_closest_vowel(word: \"most\") == \"o\")\nassert(get_closest_vowel(word:\
    \ \"ab\") == \"\")\nassert(get_closest_vowel(word: \"ba\") == \"\")\nassert(get_closest_vowel(word:\
    \ \"quick\") == \"\")\nassert(get_closest_vowel(word: \"anime\") == \"i\")\nassert(get_closest_vowel(word:\
    \ \"Asia\") == \"\")\nassert(get_closest_vowel(word: \"Above\") == \"o\")"
  status: SyntaxError
  stderr: "/tmp/tmpoaap1d7q.swift:18:20: error: 'characters' is unavailable: Please\
    \ use String directly\n    for ch in word.characters.reversed() {\n          \
    \         ^~~~~~~~~~\nSwift.String:5:16: note: 'characters' was obsoleted in Swift\
    \ 5.0\n    public var characters: String { get set }\n               ^\n"
  stdout: ''
  timestamp: 1660013567
- exit_code: -4
  program: "\n/// You are given a word. Your task is to find the closest vowel that\
    \ stands between \n/// two consonants from the right side of the word (case sensitive).\n\
    /// Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n/// find any vowel met the above condition. \n/// You may assume that\
    \ the given string contains English letter only.\n/// Example:\n/// >>> get_closest_vowel(word:\
    \ \"yogurt\")\n/// \"u\"\n/// >>> get_closest_vowel(word: \"FULL\")\n/// \"U\"\
    \n/// >>> get_closest_vowel(word: \"quick\")\n/// \"\"\n/// >>> get_closest_vowel(word:\
    \ \"ab\")\n/// \"\"\nfunc get_closest_vowel(word: String) -> String {\n    let\
    \ vowels = \"aeiou\"\n    let consonants = \"bcdfghjklmnpqrstvwxyz\"\n    let\
    \ count = word.count\n    if count < 3 {\n        return \"\"\n    }\n    let\
    \ end_index = word.index(word.endIndex, offsetBy: -2)\n    let sub_str = word[..<end_index]\n\
    \    let reversed_str = String(sub_str.reversed())\n    var min_distance = 0\n\
    \    var result = \"\"\n    for vowel in vowels {\n        if let index = reversed_str.firstIndex(of:\
    \ vowel) {\n            let distance = reversed_str.distance(from: reversed_str.startIndex,\
    \ to: index)\n            if vowels.contains(word[word.index(word.startIndex,\
    \ offsetBy: distance)])\n                || consonants.contains(word[word.index(word.startIndex,\
    \ offsetBy: distance+2)]) {\n                continue\n            }\n       \
    \     if min_distance == 0 || distance < min_distance {\n                min_distance\
    \ = distance\n                result = String(vowel)\n            }\n        }\n\
    \    }\n    return result\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(get_closest_vowel(word:\
    \ \"yogurt\") == \"u\")\nassert(get_closest_vowel(word: \"full\") == \"u\")\n\
    assert(get_closest_vowel(word: \"easy\") == \"\")\nassert(get_closest_vowel(word:\
    \ \"eAsy\") == \"\")\nassert(get_closest_vowel(word: \"ali\") == \"\")\nassert(get_closest_vowel(word:\
    \ \"bad\") == \"a\")\nassert(get_closest_vowel(word: \"most\") == \"o\")\nassert(get_closest_vowel(word:\
    \ \"ab\") == \"\")\nassert(get_closest_vowel(word: \"ba\") == \"\")\nassert(get_closest_vowel(word:\
    \ \"quick\") == \"\")\nassert(get_closest_vowel(word: \"anime\") == \"i\")\nassert(get_closest_vowel(word:\
    \ \"Asia\") == \"\")\nassert(get_closest_vowel(word: \"Above\") == \"o\")"
  status: Exception
  stderr: 'tmpi4dvndqo/tmpi4dvndqo.swift:57: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b372132ec80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b3721025b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b3721025988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b37210247b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpi4dvndqo                        0x000055aecfb9bbc7 <unavailable> + 7111

    5    libc.so.6                          0x00002b372151a460 __libc_start_main +
    245

    6    tmpi4dvndqo                        0x000055aecfb9b809 <unavailable> + 6153

    '
  stdout: ''
  timestamp: 1660013567
- exit_code: 1
  program: "\n/// You are given a word. Your task is to find the closest vowel that\
    \ stands between \n/// two consonants from the right side of the word (case sensitive).\n\
    /// Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n/// find any vowel met the above condition. \n/// You may assume that\
    \ the given string contains English letter only.\n/// Example:\n/// >>> get_closest_vowel(word:\
    \ \"yogurt\")\n/// \"u\"\n/// >>> get_closest_vowel(word: \"FULL\")\n/// \"U\"\
    \n/// >>> get_closest_vowel(word: \"quick\")\n/// \"\"\n/// >>> get_closest_vowel(word:\
    \ \"ab\")\n/// \"\"\nfunc get_closest_vowel(word: String) -> String {\n    let\
    \ vowels = [\"a\", \"e\", \"i\", \"o\", \"u\"]\n    var closestVowel: String =\
    \ \"\"\n    for (index, letter) in word.enumerated() {\n        if vowels.contains(String(letter))\
    \ {\n            var position = index\n            for (index, letter) in word.enumerated()\
    \ {\n                if vowels.contains(String(letter)) {\n                  \
    \  position = index\n                }\n            }\n            closestVowel\
    \ = String(word[index])\n        }\n    }\n    return closestVowel\n}\n\n\nfunc\
    \ ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count !=\
    \ right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(get_closest_vowel(word: \"yogurt\") == \"u\")\n\
    assert(get_closest_vowel(word: \"full\") == \"u\")\nassert(get_closest_vowel(word:\
    \ \"easy\") == \"\")\nassert(get_closest_vowel(word: \"eAsy\") == \"\")\nassert(get_closest_vowel(word:\
    \ \"ali\") == \"\")\nassert(get_closest_vowel(word: \"bad\") == \"a\")\nassert(get_closest_vowel(word:\
    \ \"most\") == \"o\")\nassert(get_closest_vowel(word: \"ab\") == \"\")\nassert(get_closest_vowel(word:\
    \ \"ba\") == \"\")\nassert(get_closest_vowel(word: \"quick\") == \"\")\nassert(get_closest_vowel(word:\
    \ \"anime\") == \"i\")\nassert(get_closest_vowel(word: \"Asia\") == \"\")\nassert(get_closest_vowel(word:\
    \ \"Above\") == \"o\")"
  status: SyntaxError
  stderr: "/tmp/tmpytbhwhl9.swift:27:35: error: 'subscript(_:)' is unavailable: cannot\
    \ subscript String with an Int, use a String.Index instead.\n            closestVowel\
    \ = String(word[index])\n                                  ^~~~~~~~~~~\nSwift.String:3:12:\
    \ note: 'subscript(_:)' has been explicitly marked unavailable here\n    public\
    \ subscript(i: Int) -> Character { get }\n           ^\n/tmp/tmpytbhwhl9.swift:21:17:\
    \ warning: variable 'position' was written to, but never read\n            var\
    \ position = index\n                ^\n"
  stdout: ''
  timestamp: 1660013567
- exit_code: 0
  program: "\n/// You are given a word. Your task is to find the closest vowel that\
    \ stands between \n/// two consonants from the right side of the word (case sensitive).\n\
    /// Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n/// find any vowel met the above condition. \n/// You may assume that\
    \ the given string contains English letter only.\n/// Example:\n/// >>> get_closest_vowel(word:\
    \ \"yogurt\")\n/// \"u\"\n/// >>> get_closest_vowel(word: \"FULL\")\n/// \"U\"\
    \n/// >>> get_closest_vowel(word: \"quick\")\n/// \"\"\n/// >>> get_closest_vowel(word:\
    \ \"ab\")\n/// \"\"\nfunc get_closest_vowel(word: String) -> String {\n    let\
    \ vowels = [\"a\", \"e\", \"i\", \"o\", \"u\"]\n    let chars = Array(word)\n\
    \    for i in (0..<chars.count).reversed() {\n        if vowels.contains(String(chars[i]))\
    \ {\n            if i > 0 && i < chars.count - 1 {\n                if !vowels.contains(String(chars[i\
    \ - 1])) && !vowels.contains(String(chars[i + 1])) {\n                    return\
    \ String(chars[i])\n                }\n            }\n        }\n    }\n    return\
    \ \"\"\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n  \
    \  if left.count != right.count {\n        return false\n    }\n    for (l, r)\
    \ in zip(left, right) {\n        if l != r {\n            return false\n     \
    \   }\n    }\n    return true\n}\n            \nassert(get_closest_vowel(word:\
    \ \"yogurt\") == \"u\")\nassert(get_closest_vowel(word: \"full\") == \"u\")\n\
    assert(get_closest_vowel(word: \"easy\") == \"\")\nassert(get_closest_vowel(word:\
    \ \"eAsy\") == \"\")\nassert(get_closest_vowel(word: \"ali\") == \"\")\nassert(get_closest_vowel(word:\
    \ \"bad\") == \"a\")\nassert(get_closest_vowel(word: \"most\") == \"o\")\nassert(get_closest_vowel(word:\
    \ \"ab\") == \"\")\nassert(get_closest_vowel(word: \"ba\") == \"\")\nassert(get_closest_vowel(word:\
    \ \"quick\") == \"\")\nassert(get_closest_vowel(word: \"anime\") == \"i\")\nassert(get_closest_vowel(word:\
    \ \"Asia\") == \"\")\nassert(get_closest_vowel(word: \"Above\") == \"o\")"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660013567
- exit_code: 1
  program: "\n/// You are given a word. Your task is to find the closest vowel that\
    \ stands between \n/// two consonants from the right side of the word (case sensitive).\n\
    /// Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n/// find any vowel met the above condition. \n/// You may assume that\
    \ the given string contains English letter only.\n/// Example:\n/// >>> get_closest_vowel(word:\
    \ \"yogurt\")\n/// \"u\"\n/// >>> get_closest_vowel(word: \"FULL\")\n/// \"U\"\
    \n/// >>> get_closest_vowel(word: \"quick\")\n/// \"\"\n/// >>> get_closest_vowel(word:\
    \ \"ab\")\n/// \"\"\nfunc get_closest_vowel(word: String) -> String {\n    let\
    \ vowels = [\"a\", \"e\", \"i\", \"o\", \"u\"]\n    let vowels_set = Set(vowels)\n\
    \    let word_set = Set(word)\n    if word_set.isSubset(of: vowels_set) {\n  \
    \      return \"\"\n    }\n    var reverse_word = String(word.reversed())\n  \
    \  var closest_vowel = \"\"\n    for char in reverse_word {\n        if vowels.contains(String(char))\
    \ {\n            closest_vowel = String(char)\n            break\n        }\n\
    \    }\n    return closest_vowel\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int,\
    \ Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n\
    \    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n          \
    \  return false\n        }\n    }\n    return true\n}\n            \nassert(get_closest_vowel(word:\
    \ \"yogurt\") == \"u\")\nassert(get_closest_vowel(word: \"full\") == \"u\")\n\
    assert(get_closest_vowel(word: \"easy\") == \"\")\nassert(get_closest_vowel(word:\
    \ \"eAsy\") == \"\")\nassert(get_closest_vowel(word: \"ali\") == \"\")\nassert(get_closest_vowel(word:\
    \ \"bad\") == \"a\")\nassert(get_closest_vowel(word: \"most\") == \"o\")\nassert(get_closest_vowel(word:\
    \ \"ab\") == \"\")\nassert(get_closest_vowel(word: \"ba\") == \"\")\nassert(get_closest_vowel(word:\
    \ \"quick\") == \"\")\nassert(get_closest_vowel(word: \"anime\") == \"i\")\nassert(get_closest_vowel(word:\
    \ \"Asia\") == \"\")\nassert(get_closest_vowel(word: \"Above\") == \"o\")"
  status: SyntaxError
  stderr: "/tmp/tmpiw5dvsa_.swift:20:17: error: no exact matches in call to instance\
    \ method 'isSubset'\n    if word_set.isSubset(of: vowels_set) {\n            \
    \    ^\nSwift.Set:15:28: note: candidate requires that the types 'String.Element'\
    \ (aka 'Character') and 'String' be equivalent (requirement specified as 'Element'\
    \ == 'S.Element')\n    @inlinable public func isSubset<S>(of possibleSuperset:\
    \ S) -> Bool where Element == S.Element, S : Sequence\n                      \
    \     ^\nSwift.Set:3:28: note: found candidate with type 'Set<String>'\n    @inlinable\
    \ public func isSubset(of other: Set<Element>) -> Bool\n                     \
    \      ^\nSwift.SetAlgebra:4:28: note: found candidate with type 'Set<String>'\n\
    \    @inlinable public func isSubset(of other: Self) -> Bool\n               \
    \            ^\n"
  stdout: ''
  timestamp: 1660013567
- exit_code: -4
  program: "\n/// You are given a word. Your task is to find the closest vowel that\
    \ stands between \n/// two consonants from the right side of the word (case sensitive).\n\
    /// Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n/// find any vowel met the above condition. \n/// You may assume that\
    \ the given string contains English letter only.\n/// Example:\n/// >>> get_closest_vowel(word:\
    \ \"yogurt\")\n/// \"u\"\n/// >>> get_closest_vowel(word: \"FULL\")\n/// \"U\"\
    \n/// >>> get_closest_vowel(word: \"quick\")\n/// \"\"\n/// >>> get_closest_vowel(word:\
    \ \"ab\")\n/// \"\"\nfunc get_closest_vowel(word: String) -> String {\n    let\
    \ vowels = \"aeiou\"\n    var idx = word.count - 1\n    var isConsonant = false\n\
    \    while idx >= 0 {\n        let s = word[word.index(word.startIndex, offsetBy:\
    \ idx)]\n        if vowels.contains(s) {\n            if isConsonant {\n     \
    \           return String(s)\n            }\n        } else {\n            isConsonant\
    \ = true\n        }\n        idx -= 1\n    }\n    return \"\"\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(get_closest_vowel(word: \"yogurt\") == \"u\")\nassert(get_closest_vowel(word:\
    \ \"full\") == \"u\")\nassert(get_closest_vowel(word: \"easy\") == \"\")\nassert(get_closest_vowel(word:\
    \ \"eAsy\") == \"\")\nassert(get_closest_vowel(word: \"ali\") == \"\")\nassert(get_closest_vowel(word:\
    \ \"bad\") == \"a\")\nassert(get_closest_vowel(word: \"most\") == \"o\")\nassert(get_closest_vowel(word:\
    \ \"ab\") == \"\")\nassert(get_closest_vowel(word: \"ba\") == \"\")\nassert(get_closest_vowel(word:\
    \ \"quick\") == \"\")\nassert(get_closest_vowel(word: \"anime\") == \"i\")\nassert(get_closest_vowel(word:\
    \ \"Asia\") == \"\")\nassert(get_closest_vowel(word: \"Above\") == \"o\")"
  status: Exception
  stderr: 'tmp8top2lfe/tmp8top2lfe.swift:49: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b8dfcf68c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b8dfcc5fb6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b8dfcc5f988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b8dfcc5e7b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmp8top2lfe                        0x000055b6d321d7e3 <unavailable> + 6115

    5    libc.so.6                          0x00002b8dfd154460 __libc_start_main +
    245

    6    tmp8top2lfe                        0x000055b6d321d219 <unavailable> + 4633

    '
  stdout: ''
  timestamp: 1660013567
- exit_code: 1
  program: "\n/// You are given a word. Your task is to find the closest vowel that\
    \ stands between \n/// two consonants from the right side of the word (case sensitive).\n\
    /// Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n/// find any vowel met the above condition. \n/// You may assume that\
    \ the given string contains English letter only.\n/// Example:\n/// >>> get_closest_vowel(word:\
    \ \"yogurt\")\n/// \"u\"\n/// >>> get_closest_vowel(word: \"FULL\")\n/// \"U\"\
    \n/// >>> get_closest_vowel(word: \"quick\")\n/// \"\"\n/// >>> get_closest_vowel(word:\
    \ \"ab\")\n/// \"\"\nfunc get_closest_vowel(word: String) -> String {\n    var\
    \ outStr = \"\"\n    var check = false\n    for char in word.characters.reversed()\
    \ {\n        if char == \"a\" || char == \"e\" || char == \"i\" || char == \"\
    o\" || char == \"u\" {\n            if check {\n                outStr = String(char)\n\
    \                break\n            }\n        } else {\n            check = true\n\
    \        }\n    }\n    return outStr\n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(get_closest_vowel(word: \"yogurt\") == \"u\")\nassert(get_closest_vowel(word:\
    \ \"full\") == \"u\")\nassert(get_closest_vowel(word: \"easy\") == \"\")\nassert(get_closest_vowel(word:\
    \ \"eAsy\") == \"\")\nassert(get_closest_vowel(word: \"ali\") == \"\")\nassert(get_closest_vowel(word:\
    \ \"bad\") == \"a\")\nassert(get_closest_vowel(word: \"most\") == \"o\")\nassert(get_closest_vowel(word:\
    \ \"ab\") == \"\")\nassert(get_closest_vowel(word: \"ba\") == \"\")\nassert(get_closest_vowel(word:\
    \ \"quick\") == \"\")\nassert(get_closest_vowel(word: \"anime\") == \"i\")\nassert(get_closest_vowel(word:\
    \ \"Asia\") == \"\")\nassert(get_closest_vowel(word: \"Above\") == \"o\")"
  status: SyntaxError
  stderr: "/tmp/tmpjzd7hnpk.swift:19:22: error: 'characters' is unavailable: Please\
    \ use String directly\n    for char in word.characters.reversed() {\n        \
    \             ^~~~~~~~~~\nSwift.String:5:16: note: 'characters' was obsoleted\
    \ in Swift 5.0\n    public var characters: String { get set }\n              \
    \ ^\n"
  stdout: ''
  timestamp: 1660013567
- exit_code: 1
  program: "\n/// You are given a word. Your task is to find the closest vowel that\
    \ stands between \n/// two consonants from the right side of the word (case sensitive).\n\
    /// Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n/// find any vowel met the above condition. \n/// You may assume that\
    \ the given string contains English letter only.\n/// Example:\n/// >>> get_closest_vowel(word:\
    \ \"yogurt\")\n/// \"u\"\n/// >>> get_closest_vowel(word: \"FULL\")\n/// \"U\"\
    \n/// >>> get_closest_vowel(word: \"quick\")\n/// \"\"\n/// >>> get_closest_vowel(word:\
    \ \"ab\")\n/// \"\"\nfunc get_closest_vowel(word: String) -> String {\n    let\
    \ vowels = \"aeiou\"\n    var vowel_index: Int?\n    for (i, char) in word.characters.enumerated().reversed()\
    \ {\n        if !vowels.containsString(String(char)) {\n            vowel_index\
    \ = i + 1\n            break\n        }\n    }\n    if vowel_index == nil {\n\
    \        return \"\"\n    }\n    for (i, char) in word.characters.enumerated().reversed()\
    \ {\n        if i <= vowel_index! {\n            return \"\"\n        }\n    \
    \    if vowels.containsString(String(char)) {\n            return String(char)\n\
    \        }\n    }\n    return \"\"\n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(get_closest_vowel(word: \"yogurt\") == \"u\")\nassert(get_closest_vowel(word:\
    \ \"full\") == \"u\")\nassert(get_closest_vowel(word: \"easy\") == \"\")\nassert(get_closest_vowel(word:\
    \ \"eAsy\") == \"\")\nassert(get_closest_vowel(word: \"ali\") == \"\")\nassert(get_closest_vowel(word:\
    \ \"bad\") == \"a\")\nassert(get_closest_vowel(word: \"most\") == \"o\")\nassert(get_closest_vowel(word:\
    \ \"ab\") == \"\")\nassert(get_closest_vowel(word: \"ba\") == \"\")\nassert(get_closest_vowel(word:\
    \ \"quick\") == \"\")\nassert(get_closest_vowel(word: \"anime\") == \"i\")\nassert(get_closest_vowel(word:\
    \ \"Asia\") == \"\")\nassert(get_closest_vowel(word: \"Above\") == \"o\")"
  status: SyntaxError
  stderr: "/tmp/tmp727ej_3d.swift:19:27: error: 'characters' is unavailable: Please\
    \ use String directly\n    for (i, char) in word.characters.enumerated().reversed()\
    \ {\n                          ^~~~~~~~~~\nSwift.String:5:16: note: 'characters'\
    \ was obsoleted in Swift 5.0\n    public var characters: String { get set }\n\
    \               ^\n/tmp/tmp727ej_3d.swift:20:20: error: value of type 'String'\
    \ has no member 'containsString'\n        if !vowels.containsString(String(char))\
    \ {\n            ~~~~~~ ^~~~~~~~~~~~~~\n/tmp/tmp727ej_3d.swift:28:27: error: 'characters'\
    \ is unavailable: Please use String directly\n    for (i, char) in word.characters.enumerated().reversed()\
    \ {\n                          ^~~~~~~~~~\nSwift.String:5:16: note: 'characters'\
    \ was obsoleted in Swift 5.0\n    public var characters: String { get set }\n\
    \               ^\n/tmp/tmp727ej_3d.swift:32:19: error: value of type 'String'\
    \ has no member 'containsString'\n        if vowels.containsString(String(char))\
    \ {\n           ~~~~~~ ^~~~~~~~~~~~~~\n"
  stdout: ''
  timestamp: 1660013567
- exit_code: 1
  program: "\n/// You are given a word. Your task is to find the closest vowel that\
    \ stands between \n/// two consonants from the right side of the word (case sensitive).\n\
    /// Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n/// find any vowel met the above condition. \n/// You may assume that\
    \ the given string contains English letter only.\n/// Example:\n/// >>> get_closest_vowel(word:\
    \ \"yogurt\")\n/// \"u\"\n/// >>> get_closest_vowel(word: \"FULL\")\n/// \"U\"\
    \n/// >>> get_closest_vowel(word: \"quick\")\n/// \"\"\n/// >>> get_closest_vowel(word:\
    \ \"ab\")\n/// \"\"\nfunc get_closest_vowel(word: String) -> String {\n    let\
    \ vowels = [\"a\", \"e\", \"i\", \"o\", \"u\"]\n    let first = word.prefix(2)\n\
    \    let last = word.suffix(2)\n    if vowels.contains(first) || vowels.contains(last)\
    \ {\n        return \"\"\n    } else {\n        for character in word.reversed()\
    \ {\n            if vowels.contains(String(character)) {\n                return\
    \ String(character)\n            }\n        }\n    }\n    return \"\"\n}\n\n\n\
    func ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(get_closest_vowel(word: \"yogurt\") == \"u\")\n\
    assert(get_closest_vowel(word: \"full\") == \"u\")\nassert(get_closest_vowel(word:\
    \ \"easy\") == \"\")\nassert(get_closest_vowel(word: \"eAsy\") == \"\")\nassert(get_closest_vowel(word:\
    \ \"ali\") == \"\")\nassert(get_closest_vowel(word: \"bad\") == \"a\")\nassert(get_closest_vowel(word:\
    \ \"most\") == \"o\")\nassert(get_closest_vowel(word: \"ab\") == \"\")\nassert(get_closest_vowel(word:\
    \ \"ba\") == \"\")\nassert(get_closest_vowel(word: \"quick\") == \"\")\nassert(get_closest_vowel(word:\
    \ \"anime\") == \"i\")\nassert(get_closest_vowel(word: \"Asia\") == \"\")\nassert(get_closest_vowel(word:\
    \ \"Above\") == \"o\")"
  status: SyntaxError
  stderr: "/tmp/tmp2i07nh4d.swift:20:8: error: instance method 'contains' requires\
    \ the types 'String' and 'Character' be equivalent\n    if vowels.contains(first)\
    \ || vowels.contains(last) {\n       ^\n_StringProcessing.Collection:3:17: note:\
    \ where 'Self.Element' = 'String', 'C.Element' = 'Character'\n    public func\
    \ contains<C>(_ other: C) -> Bool where C : Collection, Self.Element == C.Element\n\
    \                ^\n/tmp/tmp2i07nh4d.swift:20:34: error: instance method 'contains'\
    \ requires the types 'String' and 'Character' be equivalent\n    if vowels.contains(first)\
    \ || vowels.contains(last) {\n                                 ^\n_StringProcessing.Collection:3:17:\
    \ note: where 'Self.Element' = 'String', 'C.Element' = 'Character'\n    public\
    \ func contains<C>(_ other: C) -> Bool where C : Collection, Self.Element == C.Element\n\
    \                ^\n"
  stdout: ''
  timestamp: 1660013567
- exit_code: -4
  program: "\n/// You are given a word. Your task is to find the closest vowel that\
    \ stands between \n/// two consonants from the right side of the word (case sensitive).\n\
    /// Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n/// find any vowel met the above condition. \n/// You may assume that\
    \ the given string contains English letter only.\n/// Example:\n/// >>> get_closest_vowel(word:\
    \ \"yogurt\")\n/// \"u\"\n/// >>> get_closest_vowel(word: \"FULL\")\n/// \"U\"\
    \n/// >>> get_closest_vowel(word: \"quick\")\n/// \"\"\n/// >>> get_closest_vowel(word:\
    \ \"ab\")\n/// \"\"\nfunc get_closest_vowel(word: String) -> String {\n    let\
    \ vowels = [\"a\", \"e\", \"i\", \"o\", \"u\"]\n    let chars = Array(word)\n\
    \    var closest_vowel = \"\"\n    for i in 0..<chars.count {\n        if !vowels.contains(String(chars[i]))\
    \ {\n            for j in (i+1)..<chars.count {\n                if vowels.contains(String(chars[j]))\
    \ {\n                    closest_vowel = String(chars[j])\n                  \
    \  break\n                }\n            }\n            break\n        }\n   \
    \ }\n    return closest_vowel\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int,\
    \ Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n\
    \    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n          \
    \  return false\n        }\n    }\n    return true\n}\n            \nassert(get_closest_vowel(word:\
    \ \"yogurt\") == \"u\")\nassert(get_closest_vowel(word: \"full\") == \"u\")\n\
    assert(get_closest_vowel(word: \"easy\") == \"\")\nassert(get_closest_vowel(word:\
    \ \"eAsy\") == \"\")\nassert(get_closest_vowel(word: \"ali\") == \"\")\nassert(get_closest_vowel(word:\
    \ \"bad\") == \"a\")\nassert(get_closest_vowel(word: \"most\") == \"o\")\nassert(get_closest_vowel(word:\
    \ \"ab\") == \"\")\nassert(get_closest_vowel(word: \"ba\") == \"\")\nassert(get_closest_vowel(word:\
    \ \"quick\") == \"\")\nassert(get_closest_vowel(word: \"anime\") == \"i\")\nassert(get_closest_vowel(word:\
    \ \"Asia\") == \"\")\nassert(get_closest_vowel(word: \"Above\") == \"o\")"
  status: Exception
  stderr: 'tmpw9sbfx9q/tmpw9sbfx9q.swift:47: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b89a4ed7c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b89a4bceb6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b89a4bce988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b89a4bcd7b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpw9sbfx9q                        0x000055d227d76847 <unavailable> + 6215

    5    libc.so.6                          0x00002b89a50c3460 __libc_start_main +
    245

    6    tmpw9sbfx9q                        0x000055d227d76489 <unavailable> + 5257

    '
  stdout: ''
  timestamp: 1660013567
- exit_code: -4
  program: "\n/// You are given a word. Your task is to find the closest vowel that\
    \ stands between \n/// two consonants from the right side of the word (case sensitive).\n\
    /// Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n/// find any vowel met the above condition. \n/// You may assume that\
    \ the given string contains English letter only.\n/// Example:\n/// >>> get_closest_vowel(word:\
    \ \"yogurt\")\n/// \"u\"\n/// >>> get_closest_vowel(word: \"FULL\")\n/// \"U\"\
    \n/// >>> get_closest_vowel(word: \"quick\")\n/// \"\"\n/// >>> get_closest_vowel(word:\
    \ \"ab\")\n/// \"\"\nfunc get_closest_vowel(word: String) -> String {\n    let\
    \ vowels = \"AEIOU\"\n    let consonants = \"BCDFGHJKLMNPQRSTVWXYZ\"\n    for\
    \ (index, char) in word.reversed().enumerated() {\n        let string_char = String(char)\n\
    \        if vowels.contains(string_char) {\n            if consonants.contains(String(word[word.index(word.endIndex,\
    \ offsetBy: -(index + 1))])) &&\n                consonants.contains(String(word[word.index(word.endIndex,\
    \ offsetBy: -(index + 2))])) {\n                return string_char\n         \
    \   }\n        }\n    }\n    return \"\"\n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(get_closest_vowel(word: \"yogurt\") == \"u\")\nassert(get_closest_vowel(word:\
    \ \"full\") == \"u\")\nassert(get_closest_vowel(word: \"easy\") == \"\")\nassert(get_closest_vowel(word:\
    \ \"eAsy\") == \"\")\nassert(get_closest_vowel(word: \"ali\") == \"\")\nassert(get_closest_vowel(word:\
    \ \"bad\") == \"a\")\nassert(get_closest_vowel(word: \"most\") == \"o\")\nassert(get_closest_vowel(word:\
    \ \"ab\") == \"\")\nassert(get_closest_vowel(word: \"ba\") == \"\")\nassert(get_closest_vowel(word:\
    \ \"quick\") == \"\")\nassert(get_closest_vowel(word: \"anime\") == \"i\")\nassert(get_closest_vowel(word:\
    \ \"Asia\") == \"\")\nassert(get_closest_vowel(word: \"Above\") == \"o\")"
  status: Exception
  stderr: 'tmpp58nsifh/tmpp58nsifh.swift:44: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b8cb8918c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b8cb860fb6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b8cb860f988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b8cb860e7b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpp58nsifh                        0x00005586a76788a7 <unavailable> + 6311

    5    libc.so.6                          0x00002b8cb8b04460 __libc_start_main +
    245

    6    tmpp58nsifh                        0x00005586a76784e9 <unavailable> + 5353

    '
  stdout: ''
  timestamp: 1660013567
- exit_code: -4
  program: "\n/// You are given a word. Your task is to find the closest vowel that\
    \ stands between \n/// two consonants from the right side of the word (case sensitive).\n\
    /// Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n/// find any vowel met the above condition. \n/// You may assume that\
    \ the given string contains English letter only.\n/// Example:\n/// >>> get_closest_vowel(word:\
    \ \"yogurt\")\n/// \"u\"\n/// >>> get_closest_vowel(word: \"FULL\")\n/// \"U\"\
    \n/// >>> get_closest_vowel(word: \"quick\")\n/// \"\"\n/// >>> get_closest_vowel(word:\
    \ \"ab\")\n/// \"\"\nfunc get_closest_vowel(word: String) -> String {\n    let\
    \ vowels = Set(\"aeiou\")\n    var closestVowel = \"\"\n    for (index, char)\
    \ in word.reversed().enumerated() {\n        if closestVowel.isEmpty && !vowels.contains(char)\
    \ {\n            continue\n        }\n        if vowels.contains(char) {\n   \
    \         closestVowel = String(char)\n            continue\n        }\n     \
    \   if !vowels.contains(char) && !closestVowel.isEmpty {\n            break\n\
    \        }\n    }\n    return closestVowel\n}\n\n\nfunc ==(left: [(Int, Int)],\
    \ right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n       \
    \ return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r\
    \ {\n            return false\n        }\n    }\n    return true\n}\n        \
    \    \nassert(get_closest_vowel(word: \"yogurt\") == \"u\")\nassert(get_closest_vowel(word:\
    \ \"full\") == \"u\")\nassert(get_closest_vowel(word: \"easy\") == \"\")\nassert(get_closest_vowel(word:\
    \ \"eAsy\") == \"\")\nassert(get_closest_vowel(word: \"ali\") == \"\")\nassert(get_closest_vowel(word:\
    \ \"bad\") == \"a\")\nassert(get_closest_vowel(word: \"most\") == \"o\")\nassert(get_closest_vowel(word:\
    \ \"ab\") == \"\")\nassert(get_closest_vowel(word: \"ba\") == \"\")\nassert(get_closest_vowel(word:\
    \ \"quick\") == \"\")\nassert(get_closest_vowel(word: \"anime\") == \"i\")\nassert(get_closest_vowel(word:\
    \ \"Asia\") == \"\")\nassert(get_closest_vowel(word: \"Above\") == \"o\")"
  status: Exception
  stderr: 'tmp5xrg9c7b/tmp5xrg9c7b.swift:49: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b28379f1c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b28376e8b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b28376e8988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b28376e77b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmp5xrg9c7b                        0x0000563d656e1ab3 <unavailable> + 6835

    5    libc.so.6                          0x00002b2837bdd460 __libc_start_main +
    245

    6    tmp5xrg9c7b                        0x0000563d656e14e9 <unavailable> + 5353

    '
  stdout: ''
  timestamp: 1660013567
- exit_code: -4
  program: "\n/// You are given a word. Your task is to find the closest vowel that\
    \ stands between \n/// two consonants from the right side of the word (case sensitive).\n\
    /// Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n/// find any vowel met the above condition. \n/// You may assume that\
    \ the given string contains English letter only.\n/// Example:\n/// >>> get_closest_vowel(word:\
    \ \"yogurt\")\n/// \"u\"\n/// >>> get_closest_vowel(word: \"FULL\")\n/// \"U\"\
    \n/// >>> get_closest_vowel(word: \"quick\")\n/// \"\"\n/// >>> get_closest_vowel(word:\
    \ \"ab\")\n/// \"\"\nfunc get_closest_vowel(word: String) -> String {\n    var\
    \ closest_vowel = \"\"\n    let vowels = [\"a\", \"e\", \"i\", \"o\", \"u\"]\n\
    \    var first_consonant = true\n    var closest_consonant_distance = 0\n    var\
    \ closest_vowel_distance = 0\n    for (index, char) in word.lowercased().enumerated()\
    \ {\n        let distance = word.distance(from: word.startIndex, to: word.index(word.startIndex,\
    \ offsetBy: index))\n        if !vowels.contains(String(char)) {\n           \
    \ if first_consonant {\n                first_consonant = false\n            }\
    \ else {\n                closest_consonant_distance = distance\n            }\n\
    \        } else {\n            if (distance - closest_consonant_distance) < closest_vowel_distance\
    \ || closest_vowel_distance == 0 {\n                closest_vowel_distance = distance\
    \ - closest_consonant_distance\n                closest_vowel = String(char)\n\
    \            }\n        }\n    }\n    return closest_vowel\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(get_closest_vowel(word: \"yogurt\") == \"u\")\nassert(get_closest_vowel(word:\
    \ \"full\") == \"u\")\nassert(get_closest_vowel(word: \"easy\") == \"\")\nassert(get_closest_vowel(word:\
    \ \"eAsy\") == \"\")\nassert(get_closest_vowel(word: \"ali\") == \"\")\nassert(get_closest_vowel(word:\
    \ \"bad\") == \"a\")\nassert(get_closest_vowel(word: \"most\") == \"o\")\nassert(get_closest_vowel(word:\
    \ \"ab\") == \"\")\nassert(get_closest_vowel(word: \"ba\") == \"\")\nassert(get_closest_vowel(word:\
    \ \"quick\") == \"\")\nassert(get_closest_vowel(word: \"anime\") == \"i\")\nassert(get_closest_vowel(word:\
    \ \"Asia\") == \"\")\nassert(get_closest_vowel(word: \"Above\") == \"o\")"
  status: Exception
  stderr: 'tmpwbmm7vd2/tmpwbmm7vd2.swift:53: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002ad812051c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002ad811d48b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002ad811d48988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002ad811d477b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpwbmm7vd2                        0x000055bc2cf4d907 <unavailable> + 6407

    5    libc.so.6                          0x00002ad81223d460 __libc_start_main +
    245

    6    tmpwbmm7vd2                        0x000055bc2cf4d549 <unavailable> + 5449

    '
  stdout: ''
  timestamp: 1660013567
- exit_code: -4
  program: "\n/// You are given a word. Your task is to find the closest vowel that\
    \ stands between \n/// two consonants from the right side of the word (case sensitive).\n\
    /// Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n/// find any vowel met the above condition. \n/// You may assume that\
    \ the given string contains English letter only.\n/// Example:\n/// >>> get_closest_vowel(word:\
    \ \"yogurt\")\n/// \"u\"\n/// >>> get_closest_vowel(word: \"FULL\")\n/// \"U\"\
    \n/// >>> get_closest_vowel(word: \"quick\")\n/// \"\"\n/// >>> get_closest_vowel(word:\
    \ \"ab\")\n/// \"\"\nfunc get_closest_vowel(word: String) -> String {\n    let\
    \ vowels = \"aeiouAEIOU\"\n    let consonants = \"bcdfghjklmnpqrstvwxyzBCDFGHJKLMNPQRSTVWXYZ\"\
    \n    var closest_vowel = \"\"\n    for index in word.indices {\n        if consonants.contains(word[index])\
    \ {\n            let word_sub = word[index...].dropFirst()\n            for w_index\
    \ in word_sub.indices {\n                if vowels.contains(word_sub[w_index])\
    \ {\n                    closest_vowel = String(word_sub[w_index])\n         \
    \           break\n                }\n            }\n            if !closest_vowel.isEmpty\
    \ {\n                break\n            }\n        }\n    }\n    return closest_vowel\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(get_closest_vowel(word: \"yogurt\") == \"u\")\n\
    assert(get_closest_vowel(word: \"full\") == \"u\")\nassert(get_closest_vowel(word:\
    \ \"easy\") == \"\")\nassert(get_closest_vowel(word: \"eAsy\") == \"\")\nassert(get_closest_vowel(word:\
    \ \"ali\") == \"\")\nassert(get_closest_vowel(word: \"bad\") == \"a\")\nassert(get_closest_vowel(word:\
    \ \"most\") == \"o\")\nassert(get_closest_vowel(word: \"ab\") == \"\")\nassert(get_closest_vowel(word:\
    \ \"ba\") == \"\")\nassert(get_closest_vowel(word: \"quick\") == \"\")\nassert(get_closest_vowel(word:\
    \ \"anime\") == \"i\")\nassert(get_closest_vowel(word: \"Asia\") == \"\")\nassert(get_closest_vowel(word:\
    \ \"Above\") == \"o\")"
  status: Exception
  stderr: 'tmp07xneln8/tmp07xneln8.swift:50: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002aae43737c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002aae4342eb6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002aae4342e988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002aae4342d7b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmp07xneln8                        0x000055ee4ade3a37 <unavailable> + 6711

    5    libc.so.6                          0x00002aae43923460 __libc_start_main +
    245

    6    tmp07xneln8                        0x000055ee4ade3679 <unavailable> + 5753

    '
  stdout: ''
  timestamp: 1660013567
- exit_code: 1
  program: "\n/// You are given a word. Your task is to find the closest vowel that\
    \ stands between \n/// two consonants from the right side of the word (case sensitive).\n\
    /// Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n/// find any vowel met the above condition. \n/// You may assume that\
    \ the given string contains English letter only.\n/// Example:\n/// >>> get_closest_vowel(word:\
    \ \"yogurt\")\n/// \"u\"\n/// >>> get_closest_vowel(word: \"FULL\")\n/// \"U\"\
    \n/// >>> get_closest_vowel(word: \"quick\")\n/// \"\"\n/// >>> get_closest_vowel(word:\
    \ \"ab\")\n/// \"\"\nfunc get_closest_vowel(word: String) -> String {\n    //\
    \ If a word has no vowel, return empty string\n    if word.rangeOfCharacter(from:\
    \ CharacterSet(charactersIn: \"aeiou\")) == nil {\n        return \"\"\n    }\n\
    \    \n    // Make a array of all vowels in word\n    var wordArray = Array(word)\n\
    \    var vowelArray = [Character]()\n    for char in wordArray {\n        if char\
    \ == \"a\" || char == \"e\" || char == \"i\" || char == \"o\" || char == \"u\"\
    \ {\n            vowelArray.append(char)\n        }\n    }\n    \n    // Make\
    \ a array of all consonants in word\n    var consonantArray = [Character]()\n\
    \    for char in wordArray {\n        if char != \"a\" && char != \"e\" && char\
    \ != \"i\" && char != \"o\" && char != \"u\" {\n            consonantArray.append(char)\n\
    \        }\n    }\n    \n    // If vowelArray contains first character in word,\
    \ append empty string to consonantArray\n    if vowelArray.first == wordArray.first\
    \ {\n        consonantArray.append(\"\")\n    }\n    \n    // If vowelArray contains\
    \ last character in word, prepend empty string to consonantArray\n    if vowelArray.last\
    \ == wordArray.last {\n        consonantArray.insert(\"\", at: 0)\n    }\n   \
    \ \n    // Create a array of indices of consontants in word\n    var consonantIndices\
    \ = [Int]()\n    for letter in consonantArray {\n        consonantIndices.append(wordArray.index(of:\
    \ letter)!)\n    }\n    \n    // Create a array of arrays of indices of vowels\
    \ between consonants\n    var vowelBetweenIndices = [[Int]]()\n    var current\
    \ = [Int]()\n    var next = consonantIndices[0]\n    for i in 0..<vowelArray.count\
    \ {\n        if vowelArray[i] == wordArray[next] {\n            current.append(i)\n\
    \            if next < consonantIndices.count - 1 {\n                next = consonantIndices[consonantIndices.index(of:\
    \ next)! + 1]\n            }\n            vowelBetweenIndices.append\n}\n\n\n\
    func ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(get_closest_vowel(word: \"yogurt\") == \"u\")\n\
    assert(get_closest_vowel(word: \"full\") == \"u\")\nassert(get_closest_vowel(word:\
    \ \"easy\") == \"\")\nassert(get_closest_vowel(word: \"eAsy\") == \"\")\nassert(get_closest_vowel(word:\
    \ \"ali\") == \"\")\nassert(get_closest_vowel(word: \"bad\") == \"a\")\nassert(get_closest_vowel(word:\
    \ \"most\") == \"o\")\nassert(get_closest_vowel(word: \"ab\") == \"\")\nassert(get_closest_vowel(word:\
    \ \"ba\") == \"\")\nassert(get_closest_vowel(word: \"quick\") == \"\")\nassert(get_closest_vowel(word:\
    \ \"anime\") == \"i\")\nassert(get_closest_vowel(word: \"Asia\") == \"\")\nassert(get_closest_vowel(word:\
    \ \"Above\") == \"o\")"
  status: SyntaxError
  stderr: "/tmp/tmpo1y0mq7a.swift:93:48: error: expected '}' at end of brace statement\n\
    assert(get_closest_vowel(word: \"Above\") == \"o\")\n                        \
    \                       ^\n/tmp/tmpo1y0mq7a.swift:59:35: note: to match this opening\
    \ '{'\n    for i in 0..<vowelArray.count {\n                                 \
    \ ^\n/tmp/tmpo1y0mq7a.swift:93:48: error: expected '}' at end of brace statement\n\
    assert(get_closest_vowel(word: \"Above\") == \"o\")\n                        \
    \                       ^\n/tmp/tmpo1y0mq7a.swift:16:48: note: to match this opening\
    \ '{'\nfunc get_closest_vowel(word: String) -> String {\n                    \
    \                           ^\n/tmp/tmpo1y0mq7a.swift:18:36: error: cannot find\
    \ 'CharacterSet' in scope\n    if word.rangeOfCharacter(from: CharacterSet(charactersIn:\
    \ \"aeiou\")) == nil {\n                                   ^~~~~~~~~~~~\n/tmp/tmpo1y0mq7a.swift:18:13:\
    \ error: value of type 'String' has no member 'rangeOfCharacter'\n    if word.rangeOfCharacter(from:\
    \ CharacterSet(charactersIn: \"aeiou\")) == nil {\n       ~~~~ ^~~~~~~~~~~~~~~~\n\
    /tmp/tmpo1y0mq7a.swift:41:24: error: no exact matches in call to instance method\
    \ 'append'\n        consonantArray.append(\"\")\n                       ^\nSwift.Array:7:37:\
    \ note: incorrect labels for candidate (have: '(_:)', expected: '(contentsOf:)')\n\
    \    @inlinable public mutating func append<S>(contentsOf newElements: __owned\
    \ S) where Element == S.Element, S : Sequence\n                              \
    \      ^\nSwift.RangeReplaceableCollection:5:37: note: incorrect labels for candidate\
    \ (have: '(_:)', expected: '(contentsOf:)')\n    @inlinable public mutating func\
    \ append<S>(contentsOf newElements: __owned S) where S : Sequence, Self.Element\
    \ == S.Element\n                                    ^\n/tmp/tmpo1y0mq7a.swift:46:30:\
    \ error: missing argument label 'contentsOf:' in call\n        consonantArray.insert(\"\
    \", at: 0)\n                             ^\n                              contentsOf:\
    \ \n/tmp/tmpo1y0mq7a.swift:52:43: warning: 'index(of:)' is deprecated: renamed\
    \ to 'firstIndex(of:)'\n        consonantIndi"
  stdout: ''
  timestamp: 1660013567
- exit_code: -4
  program: "\n/// You are given a word. Your task is to find the closest vowel that\
    \ stands between \n/// two consonants from the right side of the word (case sensitive).\n\
    /// Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n/// find any vowel met the above condition. \n/// You may assume that\
    \ the given string contains English letter only.\n/// Example:\n/// >>> get_closest_vowel(word:\
    \ \"yogurt\")\n/// \"u\"\n/// >>> get_closest_vowel(word: \"FULL\")\n/// \"U\"\
    \n/// >>> get_closest_vowel(word: \"quick\")\n/// \"\"\n/// >>> get_closest_vowel(word:\
    \ \"ab\")\n/// \"\"\nfunc get_closest_vowel(word: String) -> String {\n    var\
    \ a = \"\"\n    var b = \"\"\n    var flag = false\n    let vowels = [\"a\", \"\
    e\", \"i\", \"o\", \"u\"]\n    for c in word.reversed() {\n        if vowels.contains(String(c))\
    \ {\n            if !flag {\n                b = String(c)\n            } else\
    \ {\n                return b\n            }\n        } else {\n            flag\
    \ = true\n        }\n    }\n    return \"\"\n}\n\n\nfunc ==(left: [(Int, Int)],\
    \ right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n       \
    \ return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r\
    \ {\n            return false\n        }\n    }\n    return true\n}\n        \
    \    \nassert(get_closest_vowel(word: \"yogurt\") == \"u\")\nassert(get_closest_vowel(word:\
    \ \"full\") == \"u\")\nassert(get_closest_vowel(word: \"easy\") == \"\")\nassert(get_closest_vowel(word:\
    \ \"eAsy\") == \"\")\nassert(get_closest_vowel(word: \"ali\") == \"\")\nassert(get_closest_vowel(word:\
    \ \"bad\") == \"a\")\nassert(get_closest_vowel(word: \"most\") == \"o\")\nassert(get_closest_vowel(word:\
    \ \"ab\") == \"\")\nassert(get_closest_vowel(word: \"ba\") == \"\")\nassert(get_closest_vowel(word:\
    \ \"quick\") == \"\")\nassert(get_closest_vowel(word: \"anime\") == \"i\")\nassert(get_closest_vowel(word:\
    \ \"Asia\") == \"\")\nassert(get_closest_vowel(word: \"Above\") == \"o\")"
  status: Exception
  stderr: 'tmpw7lygv31/tmpw7lygv31.swift:48: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002ac9dc940c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002ac9dc637b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002ac9dc637988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002ac9dc6367b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpw7lygv31                        0x0000562654c5b777 <unavailable> + 6007

    5    libc.so.6                          0x00002ac9dcb2c460 __libc_start_main +
    245

    6    tmpw7lygv31                        0x0000562654c5b3b9 <unavailable> + 5049

    '
  stdout: ''
  timestamp: 1660013567
- exit_code: 1
  program: "\n/// You are given a word. Your task is to find the closest vowel that\
    \ stands between \n/// two consonants from the right side of the word (case sensitive).\n\
    /// Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n/// find any vowel met the above condition. \n/// You may assume that\
    \ the given string contains English letter only.\n/// Example:\n/// >>> get_closest_vowel(word:\
    \ \"yogurt\")\n/// \"u\"\n/// >>> get_closest_vowel(word: \"FULL\")\n/// \"U\"\
    \n/// >>> get_closest_vowel(word: \"quick\")\n/// \"\"\n/// >>> get_closest_vowel(word:\
    \ \"ab\")\n/// \"\"\nfunc get_closest_vowel(word: String) -> String {\n    let\
    \ vowels = \"aeiouAEIOU\"\n    let consonants = \"bcdfghjklmnpqrstvwxyzBCDFGHJKLMNPQRSTVWXYZ\"\
    \n    var result = \"\"\n    var i = word.characters.count - 1\n    while i >=\
    \ 0 {\n        let index = word.index(word.startIndex, offsetBy: i)\n        let\
    \ char = word[index]\n        if vowels.contains(char) {\n            result =\
    \ String(char)\n            break\n        }\n        if !consonants.contains(char)\
    \ {\n            break\n        }\n        i -= 1\n    }\n    return result\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(get_closest_vowel(word: \"yogurt\") == \"u\")\n\
    assert(get_closest_vowel(word: \"full\") == \"u\")\nassert(get_closest_vowel(word:\
    \ \"easy\") == \"\")\nassert(get_closest_vowel(word: \"eAsy\") == \"\")\nassert(get_closest_vowel(word:\
    \ \"ali\") == \"\")\nassert(get_closest_vowel(word: \"bad\") == \"a\")\nassert(get_closest_vowel(word:\
    \ \"most\") == \"o\")\nassert(get_closest_vowel(word: \"ab\") == \"\")\nassert(get_closest_vowel(word:\
    \ \"ba\") == \"\")\nassert(get_closest_vowel(word: \"quick\") == \"\")\nassert(get_closest_vowel(word:\
    \ \"anime\") == \"i\")\nassert(get_closest_vowel(word: \"Asia\") == \"\")\nassert(get_closest_vowel(word:\
    \ \"Above\") == \"o\")"
  status: SyntaxError
  stderr: "/tmp/tmpvtqjokq3.swift:20:18: error: 'characters' is unavailable: Please\
    \ use String directly\n    var i = word.characters.count - 1\n               \
    \  ^~~~~~~~~~\nSwift.String:5:16: note: 'characters' was obsoleted in Swift 5.0\n\
    \    public var characters: String { get set }\n               ^\n"
  stdout: ''
  timestamp: 1660013567
- exit_code: -4
  program: "\n/// You are given a word. Your task is to find the closest vowel that\
    \ stands between \n/// two consonants from the right side of the word (case sensitive).\n\
    /// Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n/// find any vowel met the above condition. \n/// You may assume that\
    \ the given string contains English letter only.\n/// Example:\n/// >>> get_closest_vowel(word:\
    \ \"yogurt\")\n/// \"u\"\n/// >>> get_closest_vowel(word: \"FULL\")\n/// \"U\"\
    \n/// >>> get_closest_vowel(word: \"quick\")\n/// \"\"\n/// >>> get_closest_vowel(word:\
    \ \"ab\")\n/// \"\"\nfunc get_closest_vowel(word: String) -> String {\n    var\
    \ result = String()\n    var consons = String()\n    let vowels = \"AEIOUaeiou\"\
    \n    let charArray = Array(word)\n    for i in stride(from: charArray.count -\
    \ 1, through: 0, by: -1) {\n        if vowels.contains(charArray[i]) {\n     \
    \       if consons.count != 0 {\n                result = String(charArray[i])\n\
    \                break\n            }\n        } else {\n            consons.append(charArray[i])\n\
    \        }\n    }\n    return result\n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(get_closest_vowel(word: \"yogurt\") == \"u\")\nassert(get_closest_vowel(word:\
    \ \"full\") == \"u\")\nassert(get_closest_vowel(word: \"easy\") == \"\")\nassert(get_closest_vowel(word:\
    \ \"eAsy\") == \"\")\nassert(get_closest_vowel(word: \"ali\") == \"\")\nassert(get_closest_vowel(word:\
    \ \"bad\") == \"a\")\nassert(get_closest_vowel(word: \"most\") == \"o\")\nassert(get_closest_vowel(word:\
    \ \"ab\") == \"\")\nassert(get_closest_vowel(word: \"ba\") == \"\")\nassert(get_closest_vowel(word:\
    \ \"quick\") == \"\")\nassert(get_closest_vowel(word: \"anime\") == \"i\")\nassert(get_closest_vowel(word:\
    \ \"Asia\") == \"\")\nassert(get_closest_vowel(word: \"Above\") == \"o\")"
  status: Exception
  stderr: 'tmpd0xxfp4b/tmpd0xxfp4b.swift:49: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002ac055c19c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002ac055910b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002ac055910988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002ac05590f7b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpd0xxfp4b                        0x00005606f3fa7ae3 <unavailable> + 6883

    5    libc.so.6                          0x00002ac055e05460 __libc_start_main +
    245

    6    tmpd0xxfp4b                        0x00005606f3fa7519 <unavailable> + 5401

    '
  stdout: ''
  timestamp: 1660013567
- exit_code: 1
  program: "\n/// You are given a word. Your task is to find the closest vowel that\
    \ stands between \n/// two consonants from the right side of the word (case sensitive).\n\
    /// Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n/// find any vowel met the above condition. \n/// You may assume that\
    \ the given string contains English letter only.\n/// Example:\n/// >>> get_closest_vowel(word:\
    \ \"yogurt\")\n/// \"u\"\n/// >>> get_closest_vowel(word: \"FULL\")\n/// \"U\"\
    \n/// >>> get_closest_vowel(word: \"quick\")\n/// \"\"\n/// >>> get_closest_vowel(word:\
    \ \"ab\")\n/// \"\"\nfunc get_closest_vowel(word: String) -> String {\n    var\
    \ index = 0\n    let vowels = \"aeiouAEIOU\"\n    var prev = \"\"\n    var next\
    \ = \"\"\n    for character in word.characters {\n        if (vowels.characters.contains(character))\
    \ {\n            prev = String(character)\n            if (index != word.characters.count\
    \ - 1) {\n                next = String(word[word.index(word.startIndex, offsetBy:\
    \ index + 1)])\n            }\n            if (prev != \"\" && next != \"\" &&\
    \ !vowels.characters.contains(next.characters.first!)) {\n                return\
    \ prev\n            }\n        }\n        index += 1\n    }\n    return \"\"\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(get_closest_vowel(word: \"yogurt\") == \"u\")\n\
    assert(get_closest_vowel(word: \"full\") == \"u\")\nassert(get_closest_vowel(word:\
    \ \"easy\") == \"\")\nassert(get_closest_vowel(word: \"eAsy\") == \"\")\nassert(get_closest_vowel(word:\
    \ \"ali\") == \"\")\nassert(get_closest_vowel(word: \"bad\") == \"a\")\nassert(get_closest_vowel(word:\
    \ \"most\") == \"o\")\nassert(get_closest_vowel(word: \"ab\") == \"\")\nassert(get_closest_vowel(word:\
    \ \"ba\") == \"\")\nassert(get_closest_vowel(word: \"quick\") == \"\")\nassert(get_closest_vowel(word:\
    \ \"anime\") == \"i\")\nassert(get_closest_vowel(word: \"Asia\") == \"\")\nassert(get_closest_vowel(word:\
    \ \"Above\") == \"o\")"
  status: SyntaxError
  stderr: "/tmp/tmpv6aj06hj.swift:21:27: error: 'characters' is unavailable: Please\
    \ use String directly\n    for character in word.characters {\n              \
    \            ^~~~~~~~~~\nSwift.String:5:16: note: 'characters' was obsoleted in\
    \ Swift 5.0\n    public var characters: String { get set }\n               ^\n\
    /tmp/tmpv6aj06hj.swift:22:20: error: 'characters' is unavailable: Please use String\
    \ directly\n        if (vowels.characters.contains(character)) {\n           \
    \        ^~~~~~~~~~\nSwift.String:5:16: note: 'characters' was obsoleted in Swift\
    \ 5.0\n    public var characters: String { get set }\n               ^\n/tmp/tmpv6aj06hj.swift:24:31:\
    \ error: 'characters' is unavailable: Please use String directly\n           \
    \ if (index != word.characters.count - 1) {\n                              ^~~~~~~~~~\n\
    Swift.String:5:16: note: 'characters' was obsoleted in Swift 5.0\n    public var\
    \ characters: String { get set }\n               ^\n/tmp/tmpv6aj06hj.swift:27:53:\
    \ error: 'characters' is unavailable: Please use String directly\n           \
    \ if (prev != \"\" && next != \"\" && !vowels.characters.contains(next.characters.first!))\
    \ {\n                                                    ^~~~~~~~~~\nSwift.String:5:16:\
    \ note: 'characters' was obsoleted in Swift 5.0\n    public var characters: String\
    \ { get set }\n               ^\n/tmp/tmpv6aj06hj.swift:27:78: error: 'characters'\
    \ is unavailable: Please use String directly\n            if (prev != \"\" &&\
    \ next != \"\" && !vowels.characters.contains(next.characters.first!)) {\n   \
    \                                                                          ^~~~~~~~~~\n\
    Swift.String:5:16: note: 'characters' was obsoleted in Swift 5.0\n    public var\
    \ characters: String { get set }\n               ^\n"
  stdout: ''
  timestamp: 1660013567
- exit_code: 1
  program: "\n/// You are given a word. Your task is to find the closest vowel that\
    \ stands between \n/// two consonants from the right side of the word (case sensitive).\n\
    /// Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n/// find any vowel met the above condition. \n/// You may assume that\
    \ the given string contains English letter only.\n/// Example:\n/// >>> get_closest_vowel(word:\
    \ \"yogurt\")\n/// \"u\"\n/// >>> get_closest_vowel(word: \"FULL\")\n/// \"U\"\
    \n/// >>> get_closest_vowel(word: \"quick\")\n/// \"\"\n/// >>> get_closest_vowel(word:\
    \ \"ab\")\n/// \"\"\nfunc get_closest_vowel(word: String) -> String {\n    var\
    \ result = \"\"\n    for letter in word.reversed() {\n        if !isVowel(letter:\
    \ letter) {\n            continue\n        }\n        if result.count > 0 {\n\
    \            return result\n        }\n        result = String(letter)\n    }\n\
    \    return result\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) ->\
    \ Bool {\n    if left.count != right.count {\n        return false\n    }\n  \
    \  for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(get_closest_vowel(word:\
    \ \"yogurt\") == \"u\")\nassert(get_closest_vowel(word: \"full\") == \"u\")\n\
    assert(get_closest_vowel(word: \"easy\") == \"\")\nassert(get_closest_vowel(word:\
    \ \"eAsy\") == \"\")\nassert(get_closest_vowel(word: \"ali\") == \"\")\nassert(get_closest_vowel(word:\
    \ \"bad\") == \"a\")\nassert(get_closest_vowel(word: \"most\") == \"o\")\nassert(get_closest_vowel(word:\
    \ \"ab\") == \"\")\nassert(get_closest_vowel(word: \"ba\") == \"\")\nassert(get_closest_vowel(word:\
    \ \"quick\") == \"\")\nassert(get_closest_vowel(word: \"anime\") == \"i\")\nassert(get_closest_vowel(word:\
    \ \"Asia\") == \"\")\nassert(get_closest_vowel(word: \"Above\") == \"o\")"
  status: SyntaxError
  stderr: "/tmp/tmpic3wwl82.swift:19:13: error: cannot find 'isVowel' in scope\n \
    \       if !isVowel(letter: letter) {\n            ^~~~~~~\n"
  stdout: ''
  timestamp: 1660013567
- exit_code: -4
  program: "\n/// You are given a word. Your task is to find the closest vowel that\
    \ stands between \n/// two consonants from the right side of the word (case sensitive).\n\
    /// Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n/// find any vowel met the above condition. \n/// You may assume that\
    \ the given string contains English letter only.\n/// Example:\n/// >>> get_closest_vowel(word:\
    \ \"yogurt\")\n/// \"u\"\n/// >>> get_closest_vowel(word: \"FULL\")\n/// \"U\"\
    \n/// >>> get_closest_vowel(word: \"quick\")\n/// \"\"\n/// >>> get_closest_vowel(word:\
    \ \"ab\")\n/// \"\"\nfunc get_closest_vowel(word: String) -> String {\n    let\
    \ vowels = \"aeiou\"\n    var result = \"\"\n    var i = word.count - 1\n    var\
    \ j = 0\n    while i >= 0 {\n        if vowels.contains(word[word.index(word.startIndex,\
    \ offsetBy: i)]) {\n            break\n        }\n        i -= 1\n    }\n    if\
    \ i < 0 {\n        return \"\"\n    }\n    j = i - 1\n    while j >= 0 {\n   \
    \     if vowels.contains(word[word.index(word.startIndex, offsetBy: j)]) {\n \
    \           break\n        }\n        j -= 1\n    }\n    if j < 0 {\n        return\
    \ \"\"\n    }\n    result = String(word[word.index(word.startIndex, offsetBy:\
    \ j + 1)])\n    return result\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int,\
    \ Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n\
    \    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n          \
    \  return false\n        }\n    }\n    return true\n}\n            \nassert(get_closest_vowel(word:\
    \ \"yogurt\") == \"u\")\nassert(get_closest_vowel(word: \"full\") == \"u\")\n\
    assert(get_closest_vowel(word: \"easy\") == \"\")\nassert(get_closest_vowel(word:\
    \ \"eAsy\") == \"\")\nassert(get_closest_vowel(word: \"ali\") == \"\")\nassert(get_closest_vowel(word:\
    \ \"bad\") == \"a\")\nassert(get_closest_vowel(word: \"most\") == \"o\")\nassert(get_closest_vowel(word:\
    \ \"ab\") == \"\")\nassert(get_closest_vowel(word: \"ba\") == \"\")\nassert(get_closest_vowel(word:\
    \ \"quick\") == \"\")\nassert(get_closest_vowel(word: \"anime\") == \"i\")\nassert(get_closest_vowel(word:\
    \ \"Asia\") == \"\")\nassert(get_closest_vowel(word: \"Above\") == \"o\")"
  status: Exception
  stderr: 'tmpd_rnwsq7/tmpd_rnwsq7.swift:57: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002abcf1e1ec80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002abcf1b15b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002abcf1b15988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002abcf1b147b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpd_rnwsq7                        0x00005617fbe895d7 <unavailable> + 5591

    5    libc.so.6                          0x00002abcf200a460 __libc_start_main +
    245

    6    tmpd_rnwsq7                        0x00005617fbe89219 <unavailable> + 4633

    '
  stdout: ''
  timestamp: 1660013567
- exit_code: 1
  program: "\n/// You are given a word. Your task is to find the closest vowel that\
    \ stands between \n/// two consonants from the right side of the word (case sensitive).\n\
    /// Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n/// find any vowel met the above condition. \n/// You may assume that\
    \ the given string contains English letter only.\n/// Example:\n/// >>> get_closest_vowel(word:\
    \ \"yogurt\")\n/// \"u\"\n/// >>> get_closest_vowel(word: \"FULL\")\n/// \"U\"\
    \n/// >>> get_closest_vowel(word: \"quick\")\n/// \"\"\n/// >>> get_closest_vowel(word:\
    \ \"ab\")\n/// \"\"\nfunc get_closest_vowel(word: String) -> String {\n    var\
    \ word = word\n    var closest_vowel = \"\"\n    var is_the_first_vowel = true\n\
    \    while word.count > 0 {\n        let previous_letter = word.popLast()\n  \
    \      if !is_the_first_vowel && previous_letter != nil {\n            if !is_vowel(letter:\
    \ previous_letter!) {\n                closest_vowel = \"\"\n            } else\
    \ {\n                closest_vowel = String(previous_letter!)\n            }\n\
    \        }\n        if word.count > 0 {\n            let next_letter = word.last\n\
    \            if previous_letter != nil && is_vowel(letter: previous_letter!) &&\
    \ next_letter != nil && !is_vowel(letter: next_letter!) {\n                return\
    \ closest_vowel\n            }\n        }\n        is_the_first_vowel = false\n\
    \    }\n    return closest_vowel\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int,\
    \ Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n\
    \    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n          \
    \  return false\n        }\n    }\n    return true\n}\n            \nassert(get_closest_vowel(word:\
    \ \"yogurt\") == \"u\")\nassert(get_closest_vowel(word: \"full\") == \"u\")\n\
    assert(get_closest_vowel(word: \"easy\") == \"\")\nassert(get_closest_vowel(word:\
    \ \"eAsy\") == \"\")\nassert(get_closest_vowel(word: \"ali\") == \"\")\nassert(get_closest_vowel(word:\
    \ \"bad\") == \"a\")\nassert(get_closest_vowel(word: \"most\") == \"o\")\nassert(get_closest_vowel(word:\
    \ \"ab\") == \"\")\nassert(get_closest_vowel(word: \"ba\") == \"\")\nassert(get_closest_vowel(word:\
    \ \"quick\") == \"\")\nassert(get_closest_vowel(word: \"anime\") == \"i\")\nassert(get_closest_vowel(word:\
    \ \"Asia\") == \"\")\nassert(get_closest_vowel(word: \"Above\") == \"o\")"
  status: SyntaxError
  stderr: "/tmp/tmptf80zhh0.swift:23:17: error: cannot find 'is_vowel' in scope\n\
    \            if !is_vowel(letter: previous_letter!) {\n                ^~~~~~~~\n\
    /tmp/tmptf80zhh0.swift:31:42: error: cannot find 'is_vowel' in scope\n       \
    \     if previous_letter != nil && is_vowel(letter: previous_letter!) && next_letter\
    \ != nil && !is_vowel(letter: next_letter!) {\n                              \
    \           ^~~~~~~~\n/tmp/tmptf80zhh0.swift:31:103: error: cannot find 'is_vowel'\
    \ in scope\n            if previous_letter != nil && is_vowel(letter: previous_letter!)\
    \ && next_letter != nil && !is_vowel(letter: next_letter!) {\n               \
    \                                                                            \
    \           ^~~~~~~~\n"
  stdout: ''
  timestamp: 1660013567
- exit_code: 1
  program: "\n/// You are given a word. Your task is to find the closest vowel that\
    \ stands between \n/// two consonants from the right side of the word (case sensitive).\n\
    /// Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n/// find any vowel met the above condition. \n/// You may assume that\
    \ the given string contains English letter only.\n/// Example:\n/// >>> get_closest_vowel(word:\
    \ \"yogurt\")\n/// \"u\"\n/// >>> get_closest_vowel(word: \"FULL\")\n/// \"U\"\
    \n/// >>> get_closest_vowel(word: \"quick\")\n/// \"\"\n/// >>> get_closest_vowel(word:\
    \ \"ab\")\n/// \"\"\nfunc get_closest_vowel(word: String) -> String {\n    let\
    \ vowels = [\"a\", \"e\", \"i\", \"o\", \"u\"]\n    let b = word.characters.reversed()\n\
    \    var lastConsonant: String = \"\"\n    var firstVowel: String = \"\"\n   \
    \ for c in b {\n        if vowels.contains(String(c)) {\n            firstVowel\
    \ = String(c)\n            break\n        }\n        lastConsonant = String(c)\n\
    \    }\n    return firstVowel.isEmpty || lastConsonant.isEmpty ? \"\" : firstVowel\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(get_closest_vowel(word: \"yogurt\") == \"u\")\n\
    assert(get_closest_vowel(word: \"full\") == \"u\")\nassert(get_closest_vowel(word:\
    \ \"easy\") == \"\")\nassert(get_closest_vowel(word: \"eAsy\") == \"\")\nassert(get_closest_vowel(word:\
    \ \"ali\") == \"\")\nassert(get_closest_vowel(word: \"bad\") == \"a\")\nassert(get_closest_vowel(word:\
    \ \"most\") == \"o\")\nassert(get_closest_vowel(word: \"ab\") == \"\")\nassert(get_closest_vowel(word:\
    \ \"ba\") == \"\")\nassert(get_closest_vowel(word: \"quick\") == \"\")\nassert(get_closest_vowel(word:\
    \ \"anime\") == \"i\")\nassert(get_closest_vowel(word: \"Asia\") == \"\")\nassert(get_closest_vowel(word:\
    \ \"Above\") == \"o\")"
  status: SyntaxError
  stderr: "/tmp/tmpvo2a6sxo.swift:18:18: error: 'characters' is unavailable: Please\
    \ use String directly\n    let b = word.characters.reversed()\n              \
    \   ^~~~~~~~~~\nSwift.String:5:16: note: 'characters' was obsoleted in Swift 5.0\n\
    \    public var characters: String { get set }\n               ^\n"
  stdout: ''
  timestamp: 1660013567
- exit_code: 1
  program: "\n/// You are given a word. Your task is to find the closest vowel that\
    \ stands between \n/// two consonants from the right side of the word (case sensitive).\n\
    /// Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n/// find any vowel met the above condition. \n/// You may assume that\
    \ the given string contains English letter only.\n/// Example:\n/// >>> get_closest_vowel(word:\
    \ \"yogurt\")\n/// \"u\"\n/// >>> get_closest_vowel(word: \"FULL\")\n/// \"U\"\
    \n/// >>> get_closest_vowel(word: \"quick\")\n/// \"\"\n/// >>> get_closest_vowel(word:\
    \ \"ab\")\n/// \"\"\nfunc get_closest_vowel(word: String) -> String {\n    var\
    \ result: String = \"\"\n    for (index, value) in word.enumerated() {\n     \
    \   let element = String(value)\n        if index == 0 || index == word.count\
    \ - 1 {\n            continue\n        }\n        if element.isVowel() {\n   \
    \         let before = String(word[word.index(word.startIndex, offsetBy: index\
    \ - 1)])\n            let after = String(word[word.index(word.startIndex, offsetBy:\
    \ index + 1)])\n            if before.isConsonant() && after.isConsonant() {\n\
    \                result = element\n                break\n            }\n    \
    \    }\n    }\n    return result\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int,\
    \ Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n\
    \    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n          \
    \  return false\n        }\n    }\n    return true\n}\n            \nassert(get_closest_vowel(word:\
    \ \"yogurt\") == \"u\")\nassert(get_closest_vowel(word: \"full\") == \"u\")\n\
    assert(get_closest_vowel(word: \"easy\") == \"\")\nassert(get_closest_vowel(word:\
    \ \"eAsy\") == \"\")\nassert(get_closest_vowel(word: \"ali\") == \"\")\nassert(get_closest_vowel(word:\
    \ \"bad\") == \"a\")\nassert(get_closest_vowel(word: \"most\") == \"o\")\nassert(get_closest_vowel(word:\
    \ \"ab\") == \"\")\nassert(get_closest_vowel(word: \"ba\") == \"\")\nassert(get_closest_vowel(word:\
    \ \"quick\") == \"\")\nassert(get_closest_vowel(word: \"anime\") == \"i\")\nassert(get_closest_vowel(word:\
    \ \"Asia\") == \"\")\nassert(get_closest_vowel(word: \"Above\") == \"o\")"
  status: SyntaxError
  stderr: "/tmp/tmp0tp74t2n.swift:23:20: error: value of type 'String' has no member\
    \ 'isVowel'\n        if element.isVowel() {\n           ~~~~~~~ ^~~~~~~\n/tmp/tmp0tp74t2n.swift:26:23:\
    \ error: value of type 'String' has no member 'isConsonant'\n            if before.isConsonant()\
    \ && after.isConsonant() {\n               ~~~~~~ ^~~~~~~~~~~\n/tmp/tmp0tp74t2n.swift:26:46:\
    \ error: value of type 'String' has no member 'isConsonant'\n            if before.isConsonant()\
    \ && after.isConsonant() {\n                                       ~~~~~ ^~~~~~~~~~~\n"
  stdout: ''
  timestamp: 1660013567
- exit_code: -4
  program: "\n/// You are given a word. Your task is to find the closest vowel that\
    \ stands between \n/// two consonants from the right side of the word (case sensitive).\n\
    /// Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n/// find any vowel met the above condition. \n/// You may assume that\
    \ the given string contains English letter only.\n/// Example:\n/// >>> get_closest_vowel(word:\
    \ \"yogurt\")\n/// \"u\"\n/// >>> get_closest_vowel(word: \"FULL\")\n/// \"U\"\
    \n/// >>> get_closest_vowel(word: \"quick\")\n/// \"\"\n/// >>> get_closest_vowel(word:\
    \ \"ab\")\n/// \"\"\nfunc get_closest_vowel(word: String) -> String {\n  guard\
    \ word.count > 1 else { return \"\" }\n  let vowels = \"aeiouAEIOU\"\n  for (i,\
    \ char) in word.enumerated().reversed() {\n    if vowels.contains(char) {\n  \
    \    if i == word.count - 1 {\n        return \"\"\n      }\n      let left_is_consonant\
    \ = !vowels.contains(Array(word)[i - 1])\n      let right_is_consonant = !vowels.contains(Array(word)[i\
    \ + 1])\n      if left_is_consonant && right_is_consonant {\n        return String(char)\n\
    \      }\n    }\n  }\n  return \"\"\n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(get_closest_vowel(word: \"yogurt\") == \"u\")\nassert(get_closest_vowel(word:\
    \ \"full\") == \"u\")\nassert(get_closest_vowel(word: \"easy\") == \"\")\nassert(get_closest_vowel(word:\
    \ \"eAsy\") == \"\")\nassert(get_closest_vowel(word: \"ali\") == \"\")\nassert(get_closest_vowel(word:\
    \ \"bad\") == \"a\")\nassert(get_closest_vowel(word: \"most\") == \"o\")\nassert(get_closest_vowel(word:\
    \ \"ab\") == \"\")\nassert(get_closest_vowel(word: \"ba\") == \"\")\nassert(get_closest_vowel(word:\
    \ \"quick\") == \"\")\nassert(get_closest_vowel(word: \"anime\") == \"i\")\nassert(get_closest_vowel(word:\
    \ \"Asia\") == \"\")\nassert(get_closest_vowel(word: \"Above\") == \"o\")"
  status: Exception
  stderr: 'Swift/ContiguousArrayBuffer.swift:600: Fatal error: Index out of range

    Current stack trace:

    0    libswiftCore.so                    0x00002b78ff1f5c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b78feeec561 <unavailable> + 1434977

    2    libswiftCore.so                    0x00002b78feeec286 <unavailable> + 1434246

    3    libswiftCore.so                    0x00002b78feeec13c <unavailable> + 1433916

    4    libswiftCore.so                    0x00002b78feeebbb0 _assertionFailure(_:_:file:line:flags:)
    + 251

    5    libswiftSwiftOnoneSupport.so       0x00002b78fecec0a3 <unavailable> + 188579

    6    tmpolzkrute                        0x000055754180e9cc <unavailable> + 10700

    7    tmpolzkrute                        0x000055754180d9b3 <unavailable> + 6579

    8    libc.so.6                          0x00002b78ff3e1460 __libc_start_main +
    245

    9    tmpolzkrute                        0x000055754180d4d9 <unavailable> + 5337

    '
  stdout: ''
  timestamp: 1660013567
- exit_code: -4
  program: "\n/// You are given a word. Your task is to find the closest vowel that\
    \ stands between \n/// two consonants from the right side of the word (case sensitive).\n\
    /// Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n/// find any vowel met the above condition. \n/// You may assume that\
    \ the given string contains English letter only.\n/// Example:\n/// >>> get_closest_vowel(word:\
    \ \"yogurt\")\n/// \"u\"\n/// >>> get_closest_vowel(word: \"FULL\")\n/// \"U\"\
    \n/// >>> get_closest_vowel(word: \"quick\")\n/// \"\"\n/// >>> get_closest_vowel(word:\
    \ \"ab\")\n/// \"\"\nfunc get_closest_vowel(word: String) -> String {\n    let\
    \ vowels = [\"a\", \"e\", \"i\", \"o\", \"u\"]\n    let consonants = [\"b\", \"\
    c\", \"d\", \"f\", \"g\", \"h\", \"j\", \"k\", \"l\", \"m\", \"n\", \"p\", \"\
    q\", \"r\", \"s\", \"t\", \"v\", \"w\", \"x\", \"y\", \"z\"]\n    var result:\
    \ String = \"\"\n    var index = word.count - 1\n    var count = 0\n    for i\
    \ in word.lowercased() {\n        if index == 0 {\n            break\n       \
    \ }\n        if vowels.contains(String(i)) {\n            if consonants.contains(String(word[word.index(word.startIndex,\
    \ offsetBy: index-1)])) && consonants.contains(String(word[word.index(word.startIndex,\
    \ offsetBy: index+1)])) {\n                result = String(i)\n              \
    \  break\n            }\n        }\n        index -= 1\n        count += 1\n \
    \   }\n    if count == word.count - 1 {\n        result = \"\"\n    }\n    return\
    \ result\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n\
    \    if left.count != right.count {\n        return false\n    }\n    for (l,\
    \ r) in zip(left, right) {\n        if l != r {\n            return false\n  \
    \      }\n    }\n    return true\n}\n            \nassert(get_closest_vowel(word:\
    \ \"yogurt\") == \"u\")\nassert(get_closest_vowel(word: \"full\") == \"u\")\n\
    assert(get_closest_vowel(word: \"easy\") == \"\")\nassert(get_closest_vowel(word:\
    \ \"eAsy\") == \"\")\nassert(get_closest_vowel(word: \"ali\") == \"\")\nassert(get_closest_vowel(word:\
    \ \"bad\") == \"a\")\nassert(get_closest_vowel(word: \"most\") == \"o\")\nassert(get_closest_vowel(word:\
    \ \"ab\") == \"\")\nassert(get_closest_vowel(word: \"ba\") == \"\")\nassert(get_closest_vowel(word:\
    \ \"quick\") == \"\")\nassert(get_closest_vowel(word: \"anime\") == \"i\")\nassert(get_closest_vowel(word:\
    \ \"Asia\") == \"\")\nassert(get_closest_vowel(word: \"Above\") == \"o\")"
  status: Exception
  stderr: 'tmpgz92zwaq/tmpgz92zwaq.swift:54: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002aad44c58c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002aad4494fb6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002aad4494f988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002aad4494e7b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpgz92zwaq                        0x000056023b7f17a7 <unavailable> + 6055

    5    libc.so.6                          0x00002aad44e44460 __libc_start_main +
    245

    6    tmpgz92zwaq                        0x000056023b7f13e9 <unavailable> + 5097

    '
  stdout: ''
  timestamp: 1660013567
- exit_code: -4
  program: "\n/// You are given a word. Your task is to find the closest vowel that\
    \ stands between \n/// two consonants from the right side of the word (case sensitive).\n\
    /// Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n/// find any vowel met the above condition. \n/// You may assume that\
    \ the given string contains English letter only.\n/// Example:\n/// >>> get_closest_vowel(word:\
    \ \"yogurt\")\n/// \"u\"\n/// >>> get_closest_vowel(word: \"FULL\")\n/// \"U\"\
    \n/// >>> get_closest_vowel(word: \"quick\")\n/// \"\"\n/// >>> get_closest_vowel(word:\
    \ \"ab\")\n/// \"\"\nfunc get_closest_vowel(word: String) -> String {\n    let\
    \ vowels = Set(\"aeiouAEIOU\")\n    let consonants = Set(\"bcdfghjklmnpqrstvwxyzBCDFGHJKLMNPQRSTVWXYZ\"\
    )\n    var consonantCount = 0\n    var vowelCount = 0\n    var lastIndex = 0\n\
    \    var closestVowel = \"\"\n    for index in 0..<word.count {\n        let char\
    \ = word[word.index(word.startIndex, offsetBy: index)]\n        if consonants.contains(char)\
    \ {\n            consonantCount += 1\n            if vowelCount > 0 {\n      \
    \          lastIndex = index\n            }\n        } else if vowels.contains(char)\
    \ {\n            vowelCount += 1\n            if consonantCount > 0 {\n      \
    \          closestVowel = String(char)\n            }\n        }\n    }\n    return\
    \ closestVowel\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool\
    \ {\n    if left.count != right.count {\n        return false\n    }\n    for\
    \ (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(get_closest_vowel(word:\
    \ \"yogurt\") == \"u\")\nassert(get_closest_vowel(word: \"full\") == \"u\")\n\
    assert(get_closest_vowel(word: \"easy\") == \"\")\nassert(get_closest_vowel(word:\
    \ \"eAsy\") == \"\")\nassert(get_closest_vowel(word: \"ali\") == \"\")\nassert(get_closest_vowel(word:\
    \ \"bad\") == \"a\")\nassert(get_closest_vowel(word: \"most\") == \"o\")\nassert(get_closest_vowel(word:\
    \ \"ab\") == \"\")\nassert(get_closest_vowel(word: \"ba\") == \"\")\nassert(get_closest_vowel(word:\
    \ \"quick\") == \"\")\nassert(get_closest_vowel(word: \"anime\") == \"i\")\nassert(get_closest_vowel(word:\
    \ \"Asia\") == \"\")\nassert(get_closest_vowel(word: \"Above\") == \"o\")"
  status: Exception
  stderr: 'tmphs_vzhdc/tmphs_vzhdc.swift:57: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002ad0f178dc80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002ad0f1484b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002ad0f1484988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002ad0f14837b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmphs_vzhdc                        0x0000559f5a350c2b <unavailable> + 7211

    5    libc.so.6                          0x00002ad0f1979460 __libc_start_main +
    245

    6    tmphs_vzhdc                        0x0000559f5a350429 <unavailable> + 5161

    '
  stdout: ''
  timestamp: 1660013567
- exit_code: 1
  program: "\n/// You are given a word. Your task is to find the closest vowel that\
    \ stands between \n/// two consonants from the right side of the word (case sensitive).\n\
    /// Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n/// find any vowel met the above condition. \n/// You may assume that\
    \ the given string contains English letter only.\n/// Example:\n/// >>> get_closest_vowel(word:\
    \ \"yogurt\")\n/// \"u\"\n/// >>> get_closest_vowel(word: \"FULL\")\n/// \"U\"\
    \n/// >>> get_closest_vowel(word: \"quick\")\n/// \"\"\n/// >>> get_closest_vowel(word:\
    \ \"ab\")\n/// \"\"\nfunc get_closest_vowel(word: String) -> String {\n    //Start\
    \ writing your code here\n    let vowels = \"aeiou\"\n    var vowelIndex = word.characters.count\
    \ - 1\n    var vowelFound = false\n    var closestVowel: Character = \" \"\n \
    \   while vowelIndex >= 0 {\n        if vowels.contains(word[vowelIndex]) && vowelFound\
    \ {\n            break\n        }\n        if vowels.contains(word[vowelIndex])\
    \ {\n            vowelFound = true\n            closestVowel = word[vowelIndex]\n\
    \        }\n        vowelIndex -= 1\n    }\n    return vowelFound ? String(closestVowel)\
    \ : \"\"\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n\
    \    if left.count != right.count {\n        return false\n    }\n    for (l,\
    \ r) in zip(left, right) {\n        if l != r {\n            return false\n  \
    \      }\n    }\n    return true\n}\n            \nassert(get_closest_vowel(word:\
    \ \"yogurt\") == \"u\")\nassert(get_closest_vowel(word: \"full\") == \"u\")\n\
    assert(get_closest_vowel(word: \"easy\") == \"\")\nassert(get_closest_vowel(word:\
    \ \"eAsy\") == \"\")\nassert(get_closest_vowel(word: \"ali\") == \"\")\nassert(get_closest_vowel(word:\
    \ \"bad\") == \"a\")\nassert(get_closest_vowel(word: \"most\") == \"o\")\nassert(get_closest_vowel(word:\
    \ \"ab\") == \"\")\nassert(get_closest_vowel(word: \"ba\") == \"\")\nassert(get_closest_vowel(word:\
    \ \"quick\") == \"\")\nassert(get_closest_vowel(word: \"anime\") == \"i\")\nassert(get_closest_vowel(word:\
    \ \"Asia\") == \"\")\nassert(get_closest_vowel(word: \"Above\") == \"o\")"
  status: SyntaxError
  stderr: "/tmp/tmpvnybf66y.swift:19:27: error: 'characters' is unavailable: Please\
    \ use String directly\n    var vowelIndex = word.characters.count - 1\n      \
    \                    ^~~~~~~~~~\nSwift.String:5:16: note: 'characters' was obsoleted\
    \ in Swift 5.0\n    public var characters: String { get set }\n              \
    \ ^\n/tmp/tmpvnybf66y.swift:23:28: error: 'subscript(_:)' is unavailable: cannot\
    \ subscript String with an Int, use a String.Index instead.\n        if vowels.contains(word[vowelIndex])\
    \ && vowelFound {\n                           ^~~~~~~~~~~~~~~~\nSwift.String:3:12:\
    \ note: 'subscript(_:)' has been explicitly marked unavailable here\n    public\
    \ subscript(i: Int) -> Character { get }\n           ^\n/tmp/tmpvnybf66y.swift:26:28:\
    \ error: 'subscript(_:)' is unavailable: cannot subscript String with an Int,\
    \ use a String.Index instead.\n        if vowels.contains(word[vowelIndex]) {\n\
    \                           ^~~~~~~~~~~~~~~~\nSwift.String:3:12: note: 'subscript(_:)'\
    \ has been explicitly marked unavailable here\n    public subscript(i: Int) ->\
    \ Character { get }\n           ^\n/tmp/tmpvnybf66y.swift:28:28: error: 'subscript(_:)'\
    \ is unavailable: cannot subscript String with an Int, use a String.Index instead.\n\
    \            closestVowel = word[vowelIndex]\n                           ^~~~~~~~~~~~~~~~\n\
    Swift.String:3:12: note: 'subscript(_:)' has been explicitly marked unavailable\
    \ here\n    public subscript(i: Int) -> Character { get }\n           ^\n"
  stdout: ''
  timestamp: 1660013567
- exit_code: 1
  program: "\n/// You are given a word. Your task is to find the closest vowel that\
    \ stands between \n/// two consonants from the right side of the word (case sensitive).\n\
    /// Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n/// find any vowel met the above condition. \n/// You may assume that\
    \ the given string contains English letter only.\n/// Example:\n/// >>> get_closest_vowel(word:\
    \ \"yogurt\")\n/// \"u\"\n/// >>> get_closest_vowel(word: \"FULL\")\n/// \"U\"\
    \n/// >>> get_closest_vowel(word: \"quick\")\n/// \"\"\n/// >>> get_closest_vowel(word:\
    \ \"ab\")\n/// \"\"\nfunc get_closest_vowel(word: String) -> String {\n    let\
    \ vowels = \"aeiouAEIOU\"\n    var furthestVowel = \"\"\n    var furthestIndex\
    \ = -1\n    for (index, char) in word.enumerated() {\n        if vowels.contains(char)\
    \ {\n            furthestVowel = String(char)\n            furthestIndex = index\n\
    \        }\n    }\n    if furthestIndex == -1 {\n        return \"\"\n    }\n\
    \    for index in (0..<furthestIndex).reversed() {\n        if !vowels.contains(word[index])\
    \ {\n            return furthestVowel\n        }\n    }\n    return \"\"\n}\n\n\
    \nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(get_closest_vowel(word: \"yogurt\") == \"u\")\n\
    assert(get_closest_vowel(word: \"full\") == \"u\")\nassert(get_closest_vowel(word:\
    \ \"easy\") == \"\")\nassert(get_closest_vowel(word: \"eAsy\") == \"\")\nassert(get_closest_vowel(word:\
    \ \"ali\") == \"\")\nassert(get_closest_vowel(word: \"bad\") == \"a\")\nassert(get_closest_vowel(word:\
    \ \"most\") == \"o\")\nassert(get_closest_vowel(word: \"ab\") == \"\")\nassert(get_closest_vowel(word:\
    \ \"ba\") == \"\")\nassert(get_closest_vowel(word: \"quick\") == \"\")\nassert(get_closest_vowel(word:\
    \ \"anime\") == \"i\")\nassert(get_closest_vowel(word: \"Asia\") == \"\")\nassert(get_closest_vowel(word:\
    \ \"Above\") == \"o\")"
  status: SyntaxError
  stderr: "/tmp/tmpz5l2z2yr.swift:30:29: error: 'subscript(_:)' is unavailable: cannot\
    \ subscript String with an Int, use a String.Index instead.\n        if !vowels.contains(word[index])\
    \ {\n                            ^~~~~~~~~~~\nSwift.String:3:12: note: 'subscript(_:)'\
    \ has been explicitly marked unavailable here\n    public subscript(i: Int) ->\
    \ Character { get }\n           ^\n"
  stdout: ''
  timestamp: 1660013567
- exit_code: -4
  program: "\n/// You are given a word. Your task is to find the closest vowel that\
    \ stands between \n/// two consonants from the right side of the word (case sensitive).\n\
    /// Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n/// find any vowel met the above condition. \n/// You may assume that\
    \ the given string contains English letter only.\n/// Example:\n/// >>> get_closest_vowel(word:\
    \ \"yogurt\")\n/// \"u\"\n/// >>> get_closest_vowel(word: \"FULL\")\n/// \"U\"\
    \n/// >>> get_closest_vowel(word: \"quick\")\n/// \"\"\n/// >>> get_closest_vowel(word:\
    \ \"ab\")\n/// \"\"\nfunc get_closest_vowel(word: String) -> String {\n    let\
    \ vowels = Set(\"aeiouAEIOU\")\n    let chars = Array(word)\n    let indexes =\
    \ (0..<chars.count).filter { vowels.contains(chars[$0]) }\n    let last = indexes.isEmpty\
    \ ? -1 : indexes.last!\n    for i in (0..<chars.count).reversed() {\n        if\
    \ last == -1 || i < last {\n            if i - 1 >= 0 && vowels.contains(chars[i\
    \ - 1]) {\n                continue\n            }\n            if i + 1 < chars.count\
    \ && vowels.contains(chars[i + 1]) {\n                continue\n            }\n\
    \            return String(chars[i])\n        }\n    }\n    return \"\"\n}\n\n\
    \nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(get_closest_vowel(word: \"yogurt\") == \"u\")\n\
    assert(get_closest_vowel(word: \"full\") == \"u\")\nassert(get_closest_vowel(word:\
    \ \"easy\") == \"\")\nassert(get_closest_vowel(word: \"eAsy\") == \"\")\nassert(get_closest_vowel(word:\
    \ \"ali\") == \"\")\nassert(get_closest_vowel(word: \"bad\") == \"a\")\nassert(get_closest_vowel(word:\
    \ \"most\") == \"o\")\nassert(get_closest_vowel(word: \"ab\") == \"\")\nassert(get_closest_vowel(word:\
    \ \"ba\") == \"\")\nassert(get_closest_vowel(word: \"quick\") == \"\")\nassert(get_closest_vowel(word:\
    \ \"anime\") == \"i\")\nassert(get_closest_vowel(word: \"Asia\") == \"\")\nassert(get_closest_vowel(word:\
    \ \"Above\") == \"o\")"
  status: Exception
  stderr: 'tmpnrk3wfeg/tmpnrk3wfeg.swift:48: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b09d36dcc80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b09d33d3b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b09d33d3988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b09d33d27b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpnrk3wfeg                        0x00005625bf91bba7 <unavailable> + 7079

    5    libc.so.6                          0x00002b09d38c8460 __libc_start_main +
    245

    6    tmpnrk3wfeg                        0x00005625bf91b7e9 <unavailable> + 6121

    '
  stdout: ''
  timestamp: 1660013567
- exit_code: -4
  program: "\n/// You are given a word. Your task is to find the closest vowel that\
    \ stands between \n/// two consonants from the right side of the word (case sensitive).\n\
    /// Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n/// find any vowel met the above condition. \n/// You may assume that\
    \ the given string contains English letter only.\n/// Example:\n/// >>> get_closest_vowel(word:\
    \ \"yogurt\")\n/// \"u\"\n/// >>> get_closest_vowel(word: \"FULL\")\n/// \"U\"\
    \n/// >>> get_closest_vowel(word: \"quick\")\n/// \"\"\n/// >>> get_closest_vowel(word:\
    \ \"ab\")\n/// \"\"\nfunc get_closest_vowel(word: String) -> String {\n    //\
    \ TODO: Implement this function\n    // Hint: You may need to consider more than\
    \ one cases\n    var vowel: String = \"\"\n    let vowels: Set<Character> = [\"\
    a\", \"e\", \"i\", \"o\", \"u\"]\n    let consonants: Set<Character> = [\"b\"\
    , \"c\", \"d\", \"f\", \"g\", \"h\", \"j\", \"k\", \"l\", \"m\", \"n\", \"p\"\
    , \"q\", \"r\", \"s\", \"t\", \"v\", \"w\", \"x\", \"y\", \"z\"]\n    if(consonants.contains(word.last!)){\n\
    \        for i in stride(from: word.count-1, to: 0, by: -1){\n            if(vowels.contains(word[word.index(word.startIndex,\
    \ offsetBy: i)])){\n                vowel = String(word[word.index(word.startIndex,\
    \ offsetBy: i)])\n                break\n            }\n        }\n    }\n   \
    \ return vowel\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool\
    \ {\n    if left.count != right.count {\n        return false\n    }\n    for\
    \ (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(get_closest_vowel(word:\
    \ \"yogurt\") == \"u\")\nassert(get_closest_vowel(word: \"full\") == \"u\")\n\
    assert(get_closest_vowel(word: \"easy\") == \"\")\nassert(get_closest_vowel(word:\
    \ \"eAsy\") == \"\")\nassert(get_closest_vowel(word: \"ali\") == \"\")\nassert(get_closest_vowel(word:\
    \ \"bad\") == \"a\")\nassert(get_closest_vowel(word: \"most\") == \"o\")\nassert(get_closest_vowel(word:\
    \ \"ab\") == \"\")\nassert(get_closest_vowel(word: \"ba\") == \"\")\nassert(get_closest_vowel(word:\
    \ \"quick\") == \"\")\nassert(get_closest_vowel(word: \"anime\") == \"i\")\nassert(get_closest_vowel(word:\
    \ \"Asia\") == \"\")\nassert(get_closest_vowel(word: \"Above\") == \"o\")"
  status: Exception
  stderr: 'tmpgiall6vk/tmpgiall6vk.swift:48: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002af5a8c2ac80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002af5a8921b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002af5a8921988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002af5a89207b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpgiall6vk                        0x000055a26372dd03 <unavailable> + 7427

    5    libc.so.6                          0x00002af5a8e16460 __libc_start_main +
    245

    6    tmpgiall6vk                        0x000055a26372d739 <unavailable> + 5945

    '
  stdout: ''
  timestamp: 1660013567
- exit_code: 1
  program: "\n/// You are given a word. Your task is to find the closest vowel that\
    \ stands between \n/// two consonants from the right side of the word (case sensitive).\n\
    /// Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n/// find any vowel met the above condition. \n/// You may assume that\
    \ the given string contains English letter only.\n/// Example:\n/// >>> get_closest_vowel(word:\
    \ \"yogurt\")\n/// \"u\"\n/// >>> get_closest_vowel(word: \"FULL\")\n/// \"U\"\
    \n/// >>> get_closest_vowel(word: \"quick\")\n/// \"\"\n/// >>> get_closest_vowel(word:\
    \ \"ab\")\n/// \"\"\nfunc get_closest_vowel(word: String) -> String {\n    var\
    \ count = word.count\n    var curr = \"\"\n    var prev = \"\"\n    var next =\
    \ \"\"\n    var vowel = \"\"\n    var count1 = 0\n    var count2 = 0\n    for\
    \ w in word {\n        switch w {\n        case \"a\", \"e\", \"i\", \"o\", \"\
    u\", \"A\", \"E\", \"I\", \"O\", \"U\":\n            vowel = String(w)\n     \
    \       break\n        default:\n            vowel = \"\"\n        }\n       \
    \ if !(prev == \"\" && vowel == \"\") && prev != \"\" && vowel != \"\" {\n   \
    \         if !(next == \"\" && vowel == \"\") && next != \"\" && vowel != \"\"\
    \ {\n                count1 = count\n                if vowel == \"a\" || vowel\
    \ == \"e\" || vowel == \"i\" || vowel == \"o\" || vowel == \"u\" {\n         \
    \           if prev == \"b\" || prev == \"c\" || prev == \"d\" || prev == \"f\"\
    \ || prev == \"g\" || prev == \"h\" || prev == \"j\" || prev == \"k\" || prev\
    \ == \"l\" || prev == \"m\" || prev == \"n\" || prev == \"p\" || prev == \"q\"\
    \ || prev == \"r\" || prev == \"s\" || prev == \"t\" || prev == \"v\" || prev\
    \ == \"w\" || prev == \"x\" || prev == \"y\" || prev == \"z\" {\n            \
    \            if next == \"b\" || next == \"c\" || next == \"d\" || next == \"\
    f\" || next == \"g\" || next == \"h\" || next == \"j\" || next == \"k\" || next\
    \ == \"l\" || next == \"m\" || next == \"n\" || next == \"p\" || next == \"q\"\
    \ || next == \"r\" || next == \"s\" || next == \"t\" || next == \"v\" || next\
    \ == \"w\" || next == \"x\" || next == \"y\" || next == \"z\" {\n            \
    \                curr = vowel\n                            count2 = count\n  \
    \                      }\n                    }\n                }\n         \
    \       if count1 < count2 {\n                    curr = vowel\n             \
    \   }\n            }\n        }\n        prev = vowel\n        count -=\n}\n\n\
    \nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(get_closest_vowel(word: \"yogurt\") == \"u\")\n\
    assert(get_closest_vowel(word: \"full\") == \"u\")\nassert(get_closest_vowel(word:\
    \ \"easy\") == \"\")\nassert(get_closest_vowel(word: \"eAsy\") == \"\")\nassert(get_closest_vowel(word:\
    \ \"ali\") == \"\")\nassert(get_closest_vowel(word: \"bad\") == \"a\")\nassert(get_closest_vowel(word:\
    \ \"most\") == \"o\")\nassert(get_closest_vowel(word: \"ab\") == \"\")\nassert(get_closest_vowel(word:\
    \ \"ba\") == \"\")\nassert(get_closest_vowel(word: \"quick\") == \"\")\nassert(get_closest_vowel(word:\
    \ \"anime\") == \"i\")\nassert(get_closest_vowel(word: \"Asia\") == \"\")\nassert(get_closest_vowel(word:\
    \ \"Above\") == \"o\")"
  status: SyntaxError
  stderr: "/tmp/tmp21jk51py.swift:50:1: error: expected expression after operator\n\
    }\n^\n/tmp/tmp21jk51py.swift:77:48: error: expected '}' at end of brace statement\n\
    assert(get_closest_vowel(word: \"Above\") == \"o\")\n                        \
    \                       ^\n/tmp/tmp21jk51py.swift:16:48: note: to match this opening\
    \ '{'\nfunc get_closest_vowel(word: String) -> String {\n                    \
    \                           ^\n/tmp/tmp21jk51py.swift:53:6: error: operator functions\
    \ can only be declared at global or in type scope\nfunc ==(left: [(Int, Int)],\
    \ right: [(Int, Int)]) -> Bool {\n     ^\n"
  stdout: ''
  timestamp: 1660013567
- exit_code: 1
  program: "\n/// You are given a word. Your task is to find the closest vowel that\
    \ stands between \n/// two consonants from the right side of the word (case sensitive).\n\
    /// Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n/// find any vowel met the above condition. \n/// You may assume that\
    \ the given string contains English letter only.\n/// Example:\n/// >>> get_closest_vowel(word:\
    \ \"yogurt\")\n/// \"u\"\n/// >>> get_closest_vowel(word: \"FULL\")\n/// \"U\"\
    \n/// >>> get_closest_vowel(word: \"quick\")\n/// \"\"\n/// >>> get_closest_vowel(word:\
    \ \"ab\")\n/// \"\"\nfunc get_closest_vowel(word: String) -> String {\n  let vowels\
    \ = \"aeiou\"\n  let consonants = \"bcdfghjklmnpqrstvwxyz\"\n  var temp = \"\"\
    \n  var a = 0\n  for char in word.characters.reversed() {\n    if vowels.contains(char)\
    \ {\n      temp = String(char)\n      break\n    }\n    if consonants.contains(char)\
    \ {\n      a += 1\n    }\n  }\n  if a > 1 {\n    return temp\n  }\n  return \"\
    \"\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if\
    \ left.count != right.count {\n        return false\n    }\n    for (l, r) in\
    \ zip(left, right) {\n        if l != r {\n            return false\n        }\n\
    \    }\n    return true\n}\n            \nassert(get_closest_vowel(word: \"yogurt\"\
    ) == \"u\")\nassert(get_closest_vowel(word: \"full\") == \"u\")\nassert(get_closest_vowel(word:\
    \ \"easy\") == \"\")\nassert(get_closest_vowel(word: \"eAsy\") == \"\")\nassert(get_closest_vowel(word:\
    \ \"ali\") == \"\")\nassert(get_closest_vowel(word: \"bad\") == \"a\")\nassert(get_closest_vowel(word:\
    \ \"most\") == \"o\")\nassert(get_closest_vowel(word: \"ab\") == \"\")\nassert(get_closest_vowel(word:\
    \ \"ba\") == \"\")\nassert(get_closest_vowel(word: \"quick\") == \"\")\nassert(get_closest_vowel(word:\
    \ \"anime\") == \"i\")\nassert(get_closest_vowel(word: \"Asia\") == \"\")\nassert(get_closest_vowel(word:\
    \ \"Above\") == \"o\")"
  status: SyntaxError
  stderr: "/tmp/tmpc47r98vd.swift:21:20: error: 'characters' is unavailable: Please\
    \ use String directly\n  for char in word.characters.reversed() {\n          \
    \         ^~~~~~~~~~\nSwift.String:5:16: note: 'characters' was obsoleted in Swift\
    \ 5.0\n    public var characters: String { get set }\n               ^\n"
  stdout: ''
  timestamp: 1660013567
- exit_code: 1
  program: "\n/// You are given a word. Your task is to find the closest vowel that\
    \ stands between \n/// two consonants from the right side of the word (case sensitive).\n\
    /// Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n/// find any vowel met the above condition. \n/// You may assume that\
    \ the given string contains English letter only.\n/// Example:\n/// >>> get_closest_vowel(word:\
    \ \"yogurt\")\n/// \"u\"\n/// >>> get_closest_vowel(word: \"FULL\")\n/// \"U\"\
    \n/// >>> get_closest_vowel(word: \"quick\")\n/// \"\"\n/// >>> get_closest_vowel(word:\
    \ \"ab\")\n/// \"\"\nfunc get_closest_vowel(word: String) -> String {\n    var\
    \ dist = Int.max\n    var res = \"\"\n    var i = word.count - 1\n    while i\
    \ >= 0 {\n        if i > 0 && is_vowel(word[i]) && !is_vowel(word[i - 1]) {\n\
    \            let d = word.count - i\n            if d < dist {\n             \
    \   dist = d\n                res = String(word[i])\n            }\n        }\n\
    \        i -= 1\n    }\n    return res\n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(get_closest_vowel(word: \"yogurt\") == \"u\")\nassert(get_closest_vowel(word:\
    \ \"full\") == \"u\")\nassert(get_closest_vowel(word: \"easy\") == \"\")\nassert(get_closest_vowel(word:\
    \ \"eAsy\") == \"\")\nassert(get_closest_vowel(word: \"ali\") == \"\")\nassert(get_closest_vowel(word:\
    \ \"bad\") == \"a\")\nassert(get_closest_vowel(word: \"most\") == \"o\")\nassert(get_closest_vowel(word:\
    \ \"ab\") == \"\")\nassert(get_closest_vowel(word: \"ba\") == \"\")\nassert(get_closest_vowel(word:\
    \ \"quick\") == \"\")\nassert(get_closest_vowel(word: \"anime\") == \"i\")\nassert(get_closest_vowel(word:\
    \ \"Asia\") == \"\")\nassert(get_closest_vowel(word: \"Above\") == \"o\")"
  status: SyntaxError
  stderr: "/tmp/tmp6j5xuobg.swift:21:21: error: cannot find 'is_vowel' in scope\n\
    \        if i > 0 && is_vowel(word[i]) && !is_vowel(word[i - 1]) {\n         \
    \           ^~~~~~~~\n/tmp/tmp6j5xuobg.swift:21:43: error: cannot find 'is_vowel'\
    \ in scope\n        if i > 0 && is_vowel(word[i]) && !is_vowel(word[i - 1]) {\n\
    \                                          ^~~~~~~~\n/tmp/tmp6j5xuobg.swift:25:30:\
    \ error: 'subscript(_:)' is unavailable: cannot subscript String with an Int,\
    \ use a String.Index instead.\n                res = String(word[i])\n       \
    \                      ^~~~~~~\nSwift.String:3:12: note: 'subscript(_:)' has been\
    \ explicitly marked unavailable here\n    public subscript(i: Int) -> Character\
    \ { get }\n           ^\n"
  stdout: ''
  timestamp: 1660013567
- exit_code: -4
  program: "\n/// You are given a word. Your task is to find the closest vowel that\
    \ stands between \n/// two consonants from the right side of the word (case sensitive).\n\
    /// Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n/// find any vowel met the above condition. \n/// You may assume that\
    \ the given string contains English letter only.\n/// Example:\n/// >>> get_closest_vowel(word:\
    \ \"yogurt\")\n/// \"u\"\n/// >>> get_closest_vowel(word: \"FULL\")\n/// \"U\"\
    \n/// >>> get_closest_vowel(word: \"quick\")\n/// \"\"\n/// >>> get_closest_vowel(word:\
    \ \"ab\")\n/// \"\"\nfunc get_closest_vowel(word: String) -> String {\n    let\
    \ v = \"AEIOU\".lowercased()\n    var g = \"\"\n    for c in word.reversed() {\n\
    \        if v.contains(c) { g = String(c) }\n        else if g != \"\" { return\
    \ g }\n    }\n    return \"\"\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int,\
    \ Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n\
    \    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n          \
    \  return false\n        }\n    }\n    return true\n}\n            \nassert(get_closest_vowel(word:\
    \ \"yogurt\") == \"u\")\nassert(get_closest_vowel(word: \"full\") == \"u\")\n\
    assert(get_closest_vowel(word: \"easy\") == \"\")\nassert(get_closest_vowel(word:\
    \ \"eAsy\") == \"\")\nassert(get_closest_vowel(word: \"ali\") == \"\")\nassert(get_closest_vowel(word:\
    \ \"bad\") == \"a\")\nassert(get_closest_vowel(word: \"most\") == \"o\")\nassert(get_closest_vowel(word:\
    \ \"ab\") == \"\")\nassert(get_closest_vowel(word: \"ba\") == \"\")\nassert(get_closest_vowel(word:\
    \ \"quick\") == \"\")\nassert(get_closest_vowel(word: \"anime\") == \"i\")\nassert(get_closest_vowel(word:\
    \ \"Asia\") == \"\")\nassert(get_closest_vowel(word: \"Above\") == \"o\")"
  status: Exception
  stderr: 'tmphwaa_bzv/tmphwaa_bzv.swift:43: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b924d4efc80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b924d1e6b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b924d1e6988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b924d1e57b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmphwaa_bzv                        0x0000561a259a5b3b <unavailable> + 6971

    5    libc.so.6                          0x00002b924d6db460 __libc_start_main +
    245

    6    tmphwaa_bzv                        0x0000561a259a5339 <unavailable> + 4921

    '
  stdout: ''
  timestamp: 1660013567
- exit_code: -4
  program: "\n/// You are given a word. Your task is to find the closest vowel that\
    \ stands between \n/// two consonants from the right side of the word (case sensitive).\n\
    /// Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n/// find any vowel met the above condition. \n/// You may assume that\
    \ the given string contains English letter only.\n/// Example:\n/// >>> get_closest_vowel(word:\
    \ \"yogurt\")\n/// \"u\"\n/// >>> get_closest_vowel(word: \"FULL\")\n/// \"U\"\
    \n/// >>> get_closest_vowel(word: \"quick\")\n/// \"\"\n/// >>> get_closest_vowel(word:\
    \ \"ab\")\n/// \"\"\nfunc get_closest_vowel(word: String) -> String {\n    let\
    \ vowels = \"aeiou\"\n    let consonants = \"bcdfghjklmnpqrstvwxyz\"\n    let\
    \ chars = Array(word)\n    var vowelList = [String]()\n    for i in (0..<chars.count).reversed()\
    \ {\n        if i < chars.count - 1 {\n            if vowels.contains(chars[i])\
    \ && consonants.contains(chars[i+1]) {\n                vowelList.append(String(chars[i]))\n\
    \            }\n        }\n    }\n    guard vowelList.count > 0 else {\n     \
    \   return \"\"\n    }\n    return vowelList[0]\n}\n\n\nfunc ==(left: [(Int, Int)],\
    \ right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n       \
    \ return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r\
    \ {\n            return false\n        }\n    }\n    return true\n}\n        \
    \    \nassert(get_closest_vowel(word: \"yogurt\") == \"u\")\nassert(get_closest_vowel(word:\
    \ \"full\") == \"u\")\nassert(get_closest_vowel(word: \"easy\") == \"\")\nassert(get_closest_vowel(word:\
    \ \"eAsy\") == \"\")\nassert(get_closest_vowel(word: \"ali\") == \"\")\nassert(get_closest_vowel(word:\
    \ \"bad\") == \"a\")\nassert(get_closest_vowel(word: \"most\") == \"o\")\nassert(get_closest_vowel(word:\
    \ \"ab\") == \"\")\nassert(get_closest_vowel(word: \"ba\") == \"\")\nassert(get_closest_vowel(word:\
    \ \"quick\") == \"\")\nassert(get_closest_vowel(word: \"anime\") == \"i\")\nassert(get_closest_vowel(word:\
    \ \"Asia\") == \"\")\nassert(get_closest_vowel(word: \"Above\") == \"o\")"
  status: Exception
  stderr: 'tmpxuwka3w6/tmpxuwka3w6.swift:49: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b3a8224dc80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b3a81f44b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b3a81f44988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b3a81f437b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpxuwka3w6                        0x000055a9d0b9bcc3 <unavailable> + 7363

    5    libc.so.6                          0x00002b3a82439460 __libc_start_main +
    245

    6    tmpxuwka3w6                        0x000055a9d0b9b6f9 <unavailable> + 5881

    '
  stdout: ''
  timestamp: 1660013567
- exit_code: -4
  program: "\n/// You are given a word. Your task is to find the closest vowel that\
    \ stands between \n/// two consonants from the right side of the word (case sensitive).\n\
    /// Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n/// find any vowel met the above condition. \n/// You may assume that\
    \ the given string contains English letter only.\n/// Example:\n/// >>> get_closest_vowel(word:\
    \ \"yogurt\")\n/// \"u\"\n/// >>> get_closest_vowel(word: \"FULL\")\n/// \"U\"\
    \n/// >>> get_closest_vowel(word: \"quick\")\n/// \"\"\n/// >>> get_closest_vowel(word:\
    \ \"ab\")\n/// \"\"\nfunc get_closest_vowel(word: String) -> String {\n    let\
    \ vowels = Set(\"aeiou\")\n    var result = \"\"\n    for (index, letter) in word.lowercased().reversed().enumerated()\
    \ {\n        if vowels.contains(letter) {\n            result = String(letter)\n\
    \            break\n        }\n        else if vowels.contains(String(word[word.index(word.startIndex,\
    \ offsetBy: word.count - index - 1)])) {\n            break\n        }\n    }\n\
    \    return result\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) ->\
    \ Bool {\n    if left.count != right.count {\n        return false\n    }\n  \
    \  for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(get_closest_vowel(word:\
    \ \"yogurt\") == \"u\")\nassert(get_closest_vowel(word: \"full\") == \"u\")\n\
    assert(get_closest_vowel(word: \"easy\") == \"\")\nassert(get_closest_vowel(word:\
    \ \"eAsy\") == \"\")\nassert(get_closest_vowel(word: \"ali\") == \"\")\nassert(get_closest_vowel(word:\
    \ \"bad\") == \"a\")\nassert(get_closest_vowel(word: \"most\") == \"o\")\nassert(get_closest_vowel(word:\
    \ \"ab\") == \"\")\nassert(get_closest_vowel(word: \"ba\") == \"\")\nassert(get_closest_vowel(word:\
    \ \"quick\") == \"\")\nassert(get_closest_vowel(word: \"anime\") == \"i\")\nassert(get_closest_vowel(word:\
    \ \"Asia\") == \"\")\nassert(get_closest_vowel(word: \"Above\") == \"o\")"
  status: Exception
  stderr: 'tmpuw2prc2r/tmpuw2prc2r.swift:46: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002ad093dcac80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002ad093ac1b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002ad093ac1988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002ad093ac07b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpuw2prc2r                        0x0000557620aa4d63 <unavailable> + 7523

    5    libc.so.6                          0x00002ad093fb6460 __libc_start_main +
    245

    6    tmpuw2prc2r                        0x0000557620aa4799 <unavailable> + 6041

    '
  stdout: ''
  timestamp: 1660013567
- exit_code: -4
  program: "\n/// You are given a word. Your task is to find the closest vowel that\
    \ stands between \n/// two consonants from the right side of the word (case sensitive).\n\
    /// Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n/// find any vowel met the above condition. \n/// You may assume that\
    \ the given string contains English letter only.\n/// Example:\n/// >>> get_closest_vowel(word:\
    \ \"yogurt\")\n/// \"u\"\n/// >>> get_closest_vowel(word: \"FULL\")\n/// \"U\"\
    \n/// >>> get_closest_vowel(word: \"quick\")\n/// \"\"\n/// >>> get_closest_vowel(word:\
    \ \"ab\")\n/// \"\"\nfunc get_closest_vowel(word: String) -> String {\n    let\
    \ vowels = [\"a\", \"e\", \"i\", \"o\", \"u\"]\n    var i = word.count - 1\n \
    \   while i >= 0 {\n        if vowels.contains(String(word[word.index(word.startIndex,\
    \ offsetBy: i)])) {\n            return String(word[word.index(word.startIndex,\
    \ offsetBy: i)])\n        }\n        i -= 1\n    }\n    return \"\"\n}\n\n\nfunc\
    \ ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count !=\
    \ right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(get_closest_vowel(word: \"yogurt\") == \"u\")\n\
    assert(get_closest_vowel(word: \"full\") == \"u\")\nassert(get_closest_vowel(word:\
    \ \"easy\") == \"\")\nassert(get_closest_vowel(word: \"eAsy\") == \"\")\nassert(get_closest_vowel(word:\
    \ \"ali\") == \"\")\nassert(get_closest_vowel(word: \"bad\") == \"a\")\nassert(get_closest_vowel(word:\
    \ \"most\") == \"o\")\nassert(get_closest_vowel(word: \"ab\") == \"\")\nassert(get_closest_vowel(word:\
    \ \"ba\") == \"\")\nassert(get_closest_vowel(word: \"quick\") == \"\")\nassert(get_closest_vowel(word:\
    \ \"anime\") == \"i\")\nassert(get_closest_vowel(word: \"Asia\") == \"\")\nassert(get_closest_vowel(word:\
    \ \"Above\") == \"o\")"
  status: Exception
  stderr: 'tmpnz7r3cs9/tmpnz7r3cs9.swift:43: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b1f48669c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b1f48360b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b1f48360988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b1f4835f7b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpnz7r3cs9                        0x000056474d3128a3 <unavailable> + 6307

    5    libc.so.6                          0x00002b1f48855460 __libc_start_main +
    245

    6    tmpnz7r3cs9                        0x000056474d3122d9 <unavailable> + 4825

    '
  stdout: ''
  timestamp: 1660013567
- exit_code: -4
  program: "\n/// You are given a word. Your task is to find the closest vowel that\
    \ stands between \n/// two consonants from the right side of the word (case sensitive).\n\
    /// Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n/// find any vowel met the above condition. \n/// You may assume that\
    \ the given string contains English letter only.\n/// Example:\n/// >>> get_closest_vowel(word:\
    \ \"yogurt\")\n/// \"u\"\n/// >>> get_closest_vowel(word: \"FULL\")\n/// \"U\"\
    \n/// >>> get_closest_vowel(word: \"quick\")\n/// \"\"\n/// >>> get_closest_vowel(word:\
    \ \"ab\")\n/// \"\"\nfunc get_closest_vowel(word: String) -> String {\n    //\
    \ Write your code here\n    return \"\"\n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(get_closest_vowel(word: \"yogurt\") == \"u\")\nassert(get_closest_vowel(word:\
    \ \"full\") == \"u\")\nassert(get_closest_vowel(word: \"easy\") == \"\")\nassert(get_closest_vowel(word:\
    \ \"eAsy\") == \"\")\nassert(get_closest_vowel(word: \"ali\") == \"\")\nassert(get_closest_vowel(word:\
    \ \"bad\") == \"a\")\nassert(get_closest_vowel(word: \"most\") == \"o\")\nassert(get_closest_vowel(word:\
    \ \"ab\") == \"\")\nassert(get_closest_vowel(word: \"ba\") == \"\")\nassert(get_closest_vowel(word:\
    \ \"quick\") == \"\")\nassert(get_closest_vowel(word: \"anime\") == \"i\")\nassert(get_closest_vowel(word:\
    \ \"Asia\") == \"\")\nassert(get_closest_vowel(word: \"Above\") == \"o\")"
  status: Exception
  stderr: 'tmpfxqgbac3/tmpfxqgbac3.swift:34: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b8d59fbec80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b8d59cb5b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b8d59cb5988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b8d59cb47b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpfxqgbac3                        0x0000558c46d03307 <unavailable> + 4871

    5    libc.so.6                          0x00002b8d5a1aa460 __libc_start_main +
    245

    6    tmpfxqgbac3                        0x0000558c46d02f49 <unavailable> + 3913

    '
  stdout: ''
  timestamp: 1660013448
- exit_code: -4
  program: "\n/// You are given a word. Your task is to find the closest vowel that\
    \ stands between \n/// two consonants from the right side of the word (case sensitive).\n\
    /// Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n/// find any vowel met the above condition. \n/// You may assume that\
    \ the given string contains English letter only.\n/// Example:\n/// >>> get_closest_vowel(word:\
    \ \"yogurt\")\n/// \"u\"\n/// >>> get_closest_vowel(word: \"FULL\")\n/// \"U\"\
    \n/// >>> get_closest_vowel(word: \"quick\")\n/// \"\"\n/// >>> get_closest_vowel(word:\
    \ \"ab\")\n/// \"\"\nfunc get_closest_vowel(word: String) -> String {\n    //\
    \ replace this return statement with your solution\n    return \"\"\n}\n\n\nfunc\
    \ ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count !=\
    \ right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(get_closest_vowel(word: \"yogurt\") == \"u\")\n\
    assert(get_closest_vowel(word: \"full\") == \"u\")\nassert(get_closest_vowel(word:\
    \ \"easy\") == \"\")\nassert(get_closest_vowel(word: \"eAsy\") == \"\")\nassert(get_closest_vowel(word:\
    \ \"ali\") == \"\")\nassert(get_closest_vowel(word: \"bad\") == \"a\")\nassert(get_closest_vowel(word:\
    \ \"most\") == \"o\")\nassert(get_closest_vowel(word: \"ab\") == \"\")\nassert(get_closest_vowel(word:\
    \ \"ba\") == \"\")\nassert(get_closest_vowel(word: \"quick\") == \"\")\nassert(get_closest_vowel(word:\
    \ \"anime\") == \"i\")\nassert(get_closest_vowel(word: \"Asia\") == \"\")\nassert(get_closest_vowel(word:\
    \ \"Above\") == \"o\")"
  status: Exception
  stderr: 'tmpt95twgy_/tmpt95twgy_.swift:34: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002adc27c3ac80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002adc27931b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002adc27931988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002adc279307b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpt95twgy_                        0x00005617a0496307 <unavailable> + 4871

    5    libc.so.6                          0x00002adc27e26460 __libc_start_main +
    245

    6    tmpt95twgy_                        0x00005617a0495f49 <unavailable> + 3913

    '
  stdout: ''
  timestamp: 1660013567
- exit_code: -4
  program: "\n/// You are given a word. Your task is to find the closest vowel that\
    \ stands between \n/// two consonants from the right side of the word (case sensitive).\n\
    /// Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n/// find any vowel met the above condition. \n/// You may assume that\
    \ the given string contains English letter only.\n/// Example:\n/// >>> get_closest_vowel(word:\
    \ \"yogurt\")\n/// \"u\"\n/// >>> get_closest_vowel(word: \"FULL\")\n/// \"U\"\
    \n/// >>> get_closest_vowel(word: \"quick\")\n/// \"\"\n/// >>> get_closest_vowel(word:\
    \ \"ab\")\n/// \"\"\nfunc get_closest_vowel(word: String) -> String {\n    var\
    \ idx = 0\n    var not_found = true\n    var vowel = \"\"\n    let vowels = [\"\
    a\", \"e\", \"i\", \"o\", \"u\"]\n    for letter in word.reversed() {\n      \
    \  if !vowels.contains(String(letter)) {\n            idx += 1\n        } else\
    \ {\n            vowel = String(letter)\n            not_found = false\n     \
    \       break\n        }\n    }\n    return not_found ? \"\" : vowel\n}\n\n\n\
    func ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(get_closest_vowel(word: \"yogurt\") == \"u\")\n\
    assert(get_closest_vowel(word: \"full\") == \"u\")\nassert(get_closest_vowel(word:\
    \ \"easy\") == \"\")\nassert(get_closest_vowel(word: \"eAsy\") == \"\")\nassert(get_closest_vowel(word:\
    \ \"ali\") == \"\")\nassert(get_closest_vowel(word: \"bad\") == \"a\")\nassert(get_closest_vowel(word:\
    \ \"most\") == \"o\")\nassert(get_closest_vowel(word: \"ab\") == \"\")\nassert(get_closest_vowel(word:\
    \ \"ba\") == \"\")\nassert(get_closest_vowel(word: \"quick\") == \"\")\nassert(get_closest_vowel(word:\
    \ \"anime\") == \"i\")\nassert(get_closest_vowel(word: \"Asia\") == \"\")\nassert(get_closest_vowel(word:\
    \ \"Above\") == \"o\")"
  status: Exception
  stderr: 'tmpvfamr6at/tmpvfamr6at.swift:48: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002ae6dbb6fc80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002ae6db866b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002ae6db866988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002ae6db8657b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpvfamr6at                        0x000055d6b8af9983 <unavailable> + 6531

    5    libc.so.6                          0x00002ae6dbd5b460 __libc_start_main +
    245

    6    tmpvfamr6at                        0x000055d6b8af93b9 <unavailable> + 5049

    '
  stdout: ''
  timestamp: 1660013567
- exit_code: -4
  program: "\n/// You are given a word. Your task is to find the closest vowel that\
    \ stands between \n/// two consonants from the right side of the word (case sensitive).\n\
    /// Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n/// find any vowel met the above condition. \n/// You may assume that\
    \ the given string contains English letter only.\n/// Example:\n/// >>> get_closest_vowel(word:\
    \ \"yogurt\")\n/// \"u\"\n/// >>> get_closest_vowel(word: \"FULL\")\n/// \"U\"\
    \n/// >>> get_closest_vowel(word: \"quick\")\n/// \"\"\n/// >>> get_closest_vowel(word:\
    \ \"ab\")\n/// \"\"\nfunc get_closest_vowel(word: String) -> String {\n    var\
    \ output: String = \"\"\n    let word = word.uppercased()\n    let vowels: [Character]\
    \ = [\"A\", \"E\", \"I\", \"O\", \"U\"]\n    for (i, character) in word.enumerated()\
    \ {\n        if !vowels.contains(character) {\n            if i + 1 != word.count\
    \ {\n                if vowels.contains(word[word.index(word.startIndex, offsetBy:\
    \ i + 1)]) {\n                    output = String(word[word.index(word.startIndex,\
    \ offsetBy: i + 1)])\n                    break\n                }\n         \
    \   }\n        }\n    }\n    return output\n}\n\n\nfunc ==(left: [(Int, Int)],\
    \ right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n       \
    \ return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r\
    \ {\n            return false\n        }\n    }\n    return true\n}\n        \
    \    \nassert(get_closest_vowel(word: \"yogurt\") == \"u\")\nassert(get_closest_vowel(word:\
    \ \"full\") == \"u\")\nassert(get_closest_vowel(word: \"easy\") == \"\")\nassert(get_closest_vowel(word:\
    \ \"eAsy\") == \"\")\nassert(get_closest_vowel(word: \"ali\") == \"\")\nassert(get_closest_vowel(word:\
    \ \"bad\") == \"a\")\nassert(get_closest_vowel(word: \"most\") == \"o\")\nassert(get_closest_vowel(word:\
    \ \"ab\") == \"\")\nassert(get_closest_vowel(word: \"ba\") == \"\")\nassert(get_closest_vowel(word:\
    \ \"quick\") == \"\")\nassert(get_closest_vowel(word: \"anime\") == \"i\")\nassert(get_closest_vowel(word:\
    \ \"Asia\") == \"\")\nassert(get_closest_vowel(word: \"Above\") == \"o\")"
  status: Exception
  stderr: 'tmp0mt4m15l/tmp0mt4m15l.swift:46: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002acccbce8c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002acccb9dfb6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002acccb9df988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002acccb9de7b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmp0mt4m15l                        0x00005637c41afa17 <unavailable> + 6679

    5    libc.so.6                          0x00002acccbed4460 __libc_start_main +
    245

    6    tmp0mt4m15l                        0x00005637c41af659 <unavailable> + 5721

    '
  stdout: ''
  timestamp: 1660013567
- exit_code: 1
  program: "\n/// You are given a word. Your task is to find the closest vowel that\
    \ stands between \n/// two consonants from the right side of the word (case sensitive).\n\
    /// Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n/// find any vowel met the above condition. \n/// You may assume that\
    \ the given string contains English letter only.\n/// Example:\n/// >>> get_closest_vowel(word:\
    \ \"yogurt\")\n/// \"u\"\n/// >>> get_closest_vowel(word: \"FULL\")\n/// \"U\"\
    \n/// >>> get_closest_vowel(word: \"quick\")\n/// \"\"\n/// >>> get_closest_vowel(word:\
    \ \"ab\")\n/// \"\"\nfunc get_closest_vowel(word: String) -> String {\n    let\
    \ vowels = [\"a\", \"e\", \"i\", \"o\", \"u\"]\n    var closestVowel = \"\"\n\
    \    for ch in word.characters.reversed() {\n        if vowels.contains(String(ch))\
    \ {\n            closestVowel = String(ch)\n            break\n        }\n   \
    \ }\n    return closestVowel\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int,\
    \ Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n\
    \    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n          \
    \  return false\n        }\n    }\n    return true\n}\n            \nassert(get_closest_vowel(word:\
    \ \"yogurt\") == \"u\")\nassert(get_closest_vowel(word: \"full\") == \"u\")\n\
    assert(get_closest_vowel(word: \"easy\") == \"\")\nassert(get_closest_vowel(word:\
    \ \"eAsy\") == \"\")\nassert(get_closest_vowel(word: \"ali\") == \"\")\nassert(get_closest_vowel(word:\
    \ \"bad\") == \"a\")\nassert(get_closest_vowel(word: \"most\") == \"o\")\nassert(get_closest_vowel(word:\
    \ \"ab\") == \"\")\nassert(get_closest_vowel(word: \"ba\") == \"\")\nassert(get_closest_vowel(word:\
    \ \"quick\") == \"\")\nassert(get_closest_vowel(word: \"anime\") == \"i\")\nassert(get_closest_vowel(word:\
    \ \"Asia\") == \"\")\nassert(get_closest_vowel(word: \"Above\") == \"o\")"
  status: SyntaxError
  stderr: "/tmp/tmpgxa5hdq5.swift:19:20: error: 'characters' is unavailable: Please\
    \ use String directly\n    for ch in word.characters.reversed() {\n          \
    \         ^~~~~~~~~~\nSwift.String:5:16: note: 'characters' was obsoleted in Swift\
    \ 5.0\n    public var characters: String { get set }\n               ^\n"
  stdout: ''
  timestamp: 1660013567
- exit_code: -4
  program: "\n/// You are given a word. Your task is to find the closest vowel that\
    \ stands between \n/// two consonants from the right side of the word (case sensitive).\n\
    /// Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n/// find any vowel met the above condition. \n/// You may assume that\
    \ the given string contains English letter only.\n/// Example:\n/// >>> get_closest_vowel(word:\
    \ \"yogurt\")\n/// \"u\"\n/// >>> get_closest_vowel(word: \"FULL\")\n/// \"U\"\
    \n/// >>> get_closest_vowel(word: \"quick\")\n/// \"\"\n/// >>> get_closest_vowel(word:\
    \ \"ab\")\n/// \"\"\nfunc get_closest_vowel(word: String) -> String {\n    var\
    \ vowels = [Character]()\n    for c in word {\n        if c == \"a\" || c == \"\
    e\" || c == \"i\" || c == \"o\" || c == \"u\" || c == \"A\" || c == \"E\" || c\
    \ == \"I\" || c == \"O\" || c == \"U\" {\n            vowels.append(c)\n     \
    \   }\n    }\n    if vowels.count < 2 {\n        return \"\"\n    }\n    var k\
    \ = vowels.count - 1\n    var first = vowels[k]\n    var second = \"\"\n    while\
    \ k > 0 {\n        k -= 1\n        if vowels[k] != first {\n            second\
    \ = String(vowels[k])\n            break\n        }\n    }\n    if second == \"\
    \" {\n        return \"\"\n    }\n    let distance = word.distance(from: word.index(of:\
    \ first)!, to: word.index(of: Character(second))!)\n    if distance < 1 {\n  \
    \      return \"\"\n    }\n    return String(first)\n}\n\n\nfunc ==(left: [(Int,\
    \ Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n\
    \        return false\n    }\n    for (l, r) in zip(left, right) {\n        if\
    \ l != r {\n            return false\n        }\n    }\n    return true\n}\n \
    \           \nassert(get_closest_vowel(word: \"yogurt\") == \"u\")\nassert(get_closest_vowel(word:\
    \ \"full\") == \"u\")\nassert(get_closest_vowel(word: \"easy\") == \"\")\nassert(get_closest_vowel(word:\
    \ \"eAsy\") == \"\")\nassert(get_closest_vowel(word: \"ali\") == \"\")\nassert(get_closest_vowel(word:\
    \ \"bad\") == \"a\")\nassert(get_closest_vowel(word: \"most\") == \"o\")\nassert(get_closest_vowel(word:\
    \ \"ab\") == \"\")\nassert(get_closest_vowel(word: \"ba\") == \"\")\nassert(get_closest_vowel(word:\
    \ \"quick\") == \"\")\nassert(get_closest_vowel(word: \"anime\") == \"i\")\nassert(get_closest_vowel(word:\
    \ \"Asia\") == \"\")\nassert(get_closest_vowel(word: \"Above\") == \"o\")"
  status: Exception
  stderr: 'tmpe_r183jn/tmpe_r183jn.swift:59: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b2ef17e4c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b2ef14dbb6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b2ef14db988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b2ef14da7b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpe_r183jn                        0x000055e0e076e917 <unavailable> + 6423

    5    libc.so.6                          0x00002b2ef19d0460 __libc_start_main +
    245

    6    tmpe_r183jn                        0x000055e0e076e559 <unavailable> + 5465

    '
  stdout: ''
  timestamp: 1660013567
- exit_code: -4
  program: "\n/// You are given a word. Your task is to find the closest vowel that\
    \ stands between \n/// two consonants from the right side of the word (case sensitive).\n\
    /// Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n/// find any vowel met the above condition. \n/// You may assume that\
    \ the given string contains English letter only.\n/// Example:\n/// >>> get_closest_vowel(word:\
    \ \"yogurt\")\n/// \"u\"\n/// >>> get_closest_vowel(word: \"FULL\")\n/// \"U\"\
    \n/// >>> get_closest_vowel(word: \"quick\")\n/// \"\"\n/// >>> get_closest_vowel(word:\
    \ \"ab\")\n/// \"\"\nfunc get_closest_vowel(word: String) -> String {\n  let vowels\
    \ = [\"a\", \"e\", \"i\", \"o\", \"u\"]\n  let strArr = Array(word)\n  var closestVowel:\
    \ String = \"\"\n  for (index, val) in strArr.enumerated() {\n    let char = String(val)\n\
    \    if vowels.contains(char) {\n      closestVowel = char\n      break\n    }\n\
    \  }\n  return closestVowel\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int,\
    \ Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n\
    \    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n          \
    \  return false\n        }\n    }\n    return true\n}\n            \nassert(get_closest_vowel(word:\
    \ \"yogurt\") == \"u\")\nassert(get_closest_vowel(word: \"full\") == \"u\")\n\
    assert(get_closest_vowel(word: \"easy\") == \"\")\nassert(get_closest_vowel(word:\
    \ \"eAsy\") == \"\")\nassert(get_closest_vowel(word: \"ali\") == \"\")\nassert(get_closest_vowel(word:\
    \ \"bad\") == \"a\")\nassert(get_closest_vowel(word: \"most\") == \"o\")\nassert(get_closest_vowel(word:\
    \ \"ab\") == \"\")\nassert(get_closest_vowel(word: \"ba\") == \"\")\nassert(get_closest_vowel(word:\
    \ \"quick\") == \"\")\nassert(get_closest_vowel(word: \"anime\") == \"i\")\nassert(get_closest_vowel(word:\
    \ \"Asia\") == \"\")\nassert(get_closest_vowel(word: \"Above\") == \"o\")"
  status: Exception
  stderr: 'tmprtx5cvp5/tmprtx5cvp5.swift:43: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002aedf4381c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002aedf4078b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002aedf4078988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002aedf40777b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmprtx5cvp5                        0x000056268c18d827 <unavailable> + 6183

    5    libc.so.6                          0x00002aedf456d460 __libc_start_main +
    245

    6    tmprtx5cvp5                        0x000056268c18d469 <unavailable> + 5225

    '
  stdout: ''
  timestamp: 1660013567
- exit_code: 1
  program: "\n/// You are given a word. Your task is to find the closest vowel that\
    \ stands between \n/// two consonants from the right side of the word (case sensitive).\n\
    /// Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n/// find any vowel met the above condition. \n/// You may assume that\
    \ the given string contains English letter only.\n/// Example:\n/// >>> get_closest_vowel(word:\
    \ \"yogurt\")\n/// \"u\"\n/// >>> get_closest_vowel(word: \"FULL\")\n/// \"U\"\
    \n/// >>> get_closest_vowel(word: \"quick\")\n/// \"\"\n/// >>> get_closest_vowel(word:\
    \ \"ab\")\n/// \"\"\nfunc get_closest_vowel(word: String) -> String {\n    var\
    \ length = word.count\n    if length < 3 {\n        return \"\"\n    }\n    var\
    \ temp = \"\"\n    var index = 0\n    for character in word {\n        let char\
    \ = String(character)\n        if is_vowel(char: char) {\n            if index\
    \ == 0 || (index == length - 1) {\n                index += 1\n              \
    \  continue\n            }\n            let before = String(word[word.index(word.startIndex,\
    \ offsetBy: index - 1)])\n            let after = String(word[word.index(word.startIndex,\
    \ offsetBy: index + 1)])\n            if !is_vowel(char: before) && !is_vowel(char:\
    \ after) {\n                temp = char\n                break\n            }\n\
    \        }\n        index += 1\n    }\n    return temp\n}\n\n\nfunc ==(left: [(Int,\
    \ Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n\
    \        return false\n    }\n    for (l, r) in zip(left, right) {\n        if\
    \ l != r {\n            return false\n        }\n    }\n    return true\n}\n \
    \           \nassert(get_closest_vowel(word: \"yogurt\") == \"u\")\nassert(get_closest_vowel(word:\
    \ \"full\") == \"u\")\nassert(get_closest_vowel(word: \"easy\") == \"\")\nassert(get_closest_vowel(word:\
    \ \"eAsy\") == \"\")\nassert(get_closest_vowel(word: \"ali\") == \"\")\nassert(get_closest_vowel(word:\
    \ \"bad\") == \"a\")\nassert(get_closest_vowel(word: \"most\") == \"o\")\nassert(get_closest_vowel(word:\
    \ \"ab\") == \"\")\nassert(get_closest_vowel(word: \"ba\") == \"\")\nassert(get_closest_vowel(word:\
    \ \"quick\") == \"\")\nassert(get_closest_vowel(word: \"anime\") == \"i\")\nassert(get_closest_vowel(word:\
    \ \"Asia\") == \"\")\nassert(get_closest_vowel(word: \"Above\") == \"o\")"
  status: SyntaxError
  stderr: "/tmp/tmpfzbhg9y8.swift:25:12: error: cannot find 'is_vowel' in scope\n\
    \        if is_vowel(char: char) {\n           ^~~~~~~~\n/tmp/tmpfzbhg9y8.swift:32:17:\
    \ error: cannot find 'is_vowel' in scope\n            if !is_vowel(char: before)\
    \ && !is_vowel(char: after) {\n                ^~~~~~~~\n/tmp/tmpfzbhg9y8.swift:32:44:\
    \ error: cannot find 'is_vowel' in scope\n            if !is_vowel(char: before)\
    \ && !is_vowel(char: after) {\n                                           ^~~~~~~~\n"
  stdout: ''
  timestamp: 1660013567
- exit_code: -4
  program: "\n/// You are given a word. Your task is to find the closest vowel that\
    \ stands between \n/// two consonants from the right side of the word (case sensitive).\n\
    /// Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n/// find any vowel met the above condition. \n/// You may assume that\
    \ the given string contains English letter only.\n/// Example:\n/// >>> get_closest_vowel(word:\
    \ \"yogurt\")\n/// \"u\"\n/// >>> get_closest_vowel(word: \"FULL\")\n/// \"U\"\
    \n/// >>> get_closest_vowel(word: \"quick\")\n/// \"\"\n/// >>> get_closest_vowel(word:\
    \ \"ab\")\n/// \"\"\nfunc get_closest_vowel(word: String) -> String {\n\tlet vowels\
    \ = \"aeiou\"\n\tvar isPrevConsonant = false\n\t\n\tfor (index, c) in word.lowercased().reversed().enumerated()\
    \ {\n\t\tif vowels.contains(c) {\n\t\t\tif index > 0 && isPrevConsonant {\n\t\t\
    \t\treturn String(c)\n\t\t\t}\n\t\t} else {\n\t\t\tisPrevConsonant = true\n\t\t\
    }\n\t}\n\t\n\treturn \"\"\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(get_closest_vowel(word:\
    \ \"yogurt\") == \"u\")\nassert(get_closest_vowel(word: \"full\") == \"u\")\n\
    assert(get_closest_vowel(word: \"easy\") == \"\")\nassert(get_closest_vowel(word:\
    \ \"eAsy\") == \"\")\nassert(get_closest_vowel(word: \"ali\") == \"\")\nassert(get_closest_vowel(word:\
    \ \"bad\") == \"a\")\nassert(get_closest_vowel(word: \"most\") == \"o\")\nassert(get_closest_vowel(word:\
    \ \"ab\") == \"\")\nassert(get_closest_vowel(word: \"ba\") == \"\")\nassert(get_closest_vowel(word:\
    \ \"quick\") == \"\")\nassert(get_closest_vowel(word: \"anime\") == \"i\")\nassert(get_closest_vowel(word:\
    \ \"Asia\") == \"\")\nassert(get_closest_vowel(word: \"Above\") == \"o\")"
  status: Exception
  stderr: 'tmpn86okwmb/tmpn86okwmb.swift:48: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b1c281d4c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b1c27ecbb6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b1c27ecb988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b1c27eca7b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpn86okwmb                        0x000055e5da96ea23 <unavailable> + 6691

    5    libc.so.6                          0x00002b1c283c0460 __libc_start_main +
    245

    6    tmpn86okwmb                        0x000055e5da96e459 <unavailable> + 5209

    '
  stdout: ''
  timestamp: 1660013567
- exit_code: 1
  program: "\n/// You are given a word. Your task is to find the closest vowel that\
    \ stands between \n/// two consonants from the right side of the word (case sensitive).\n\
    /// Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n/// find any vowel met the above condition. \n/// You may assume that\
    \ the given string contains English letter only.\n/// Example:\n/// >>> get_closest_vowel(word:\
    \ \"yogurt\")\n/// \"u\"\n/// >>> get_closest_vowel(word: \"FULL\")\n/// \"U\"\
    \n/// >>> get_closest_vowel(word: \"quick\")\n/// \"\"\n/// >>> get_closest_vowel(word:\
    \ \"ab\")\n/// \"\"\nfunc get_closest_vowel(word: String) -> String {\n    //\
    \ YOUR CODE GOES HERE\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(get_closest_vowel(word:\
    \ \"yogurt\") == \"u\")\nassert(get_closest_vowel(word: \"full\") == \"u\")\n\
    assert(get_closest_vowel(word: \"easy\") == \"\")\nassert(get_closest_vowel(word:\
    \ \"eAsy\") == \"\")\nassert(get_closest_vowel(word: \"ali\") == \"\")\nassert(get_closest_vowel(word:\
    \ \"bad\") == \"a\")\nassert(get_closest_vowel(word: \"most\") == \"o\")\nassert(get_closest_vowel(word:\
    \ \"ab\") == \"\")\nassert(get_closest_vowel(word: \"ba\") == \"\")\nassert(get_closest_vowel(word:\
    \ \"quick\") == \"\")\nassert(get_closest_vowel(word: \"anime\") == \"i\")\nassert(get_closest_vowel(word:\
    \ \"Asia\") == \"\")\nassert(get_closest_vowel(word: \"Above\") == \"o\")"
  status: SyntaxError
  stderr: '/tmp/tmpqqf65e2_.swift:18:1: error: missing return in global function expected
    to return ''String''

    }

    ^

    '
  stdout: ''
  timestamp: 1660013567
- exit_code: -4
  program: "\n/// You are given a word. Your task is to find the closest vowel that\
    \ stands between \n/// two consonants from the right side of the word (case sensitive).\n\
    /// Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n/// find any vowel met the above condition. \n/// You may assume that\
    \ the given string contains English letter only.\n/// Example:\n/// >>> get_closest_vowel(word:\
    \ \"yogurt\")\n/// \"u\"\n/// >>> get_closest_vowel(word: \"FULL\")\n/// \"U\"\
    \n/// >>> get_closest_vowel(word: \"quick\")\n/// \"\"\n/// >>> get_closest_vowel(word:\
    \ \"ab\")\n/// \"\"\nfunc get_closest_vowel(word: String) -> String {\n    let\
    \ vowels = [\"a\", \"e\", \"i\", \"o\", \"u\"]\n    let chars = Array(word)\n\
    \    var frontVowelIndex = -1\n    var backVowelIndex = -1\n    var i = 0\n  \
    \  while i < chars.count {\n        let char = String(chars[i])\n        if vowels.contains(char)\
    \ {\n            frontVowelIndex = i\n            break\n        }\n        i\
    \ += 1\n    }\n    i = chars.count - 1\n    while i >= 0 {\n        let char =\
    \ String(chars[i])\n        if vowels.contains(char) {\n            backVowelIndex\
    \ = i\n            break\n        }\n        i -= 1\n    }\n    if frontVowelIndex\
    \ == -1 || backVowelIndex == -1 {\n        return \"\"\n    }\n    if abs(frontVowelIndex\
    \ - backVowelIndex) < chars.count / 2 {\n        return String(chars[frontVowelIndex])\n\
    \    } else {\n        return String(chars[backVowelIndex])\n    }\n}\n\n\nfunc\
    \ ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count !=\
    \ right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(get_closest_vowel(word: \"yogurt\") == \"u\")\n\
    assert(get_closest_vowel(word: \"full\") == \"u\")\nassert(get_closest_vowel(word:\
    \ \"easy\") == \"\")\nassert(get_closest_vowel(word: \"eAsy\") == \"\")\nassert(get_closest_vowel(word:\
    \ \"ali\") == \"\")\nassert(get_closest_vowel(word: \"bad\") == \"a\")\nassert(get_closest_vowel(word:\
    \ \"most\") == \"o\")\nassert(get_closest_vowel(word: \"ab\") == \"\")\nassert(get_closest_vowel(word:\
    \ \"ba\") == \"\")\nassert(get_closest_vowel(word: \"quick\") == \"\")\nassert(get_closest_vowel(word:\
    \ \"anime\") == \"i\")\nassert(get_closest_vowel(word: \"Asia\") == \"\")\nassert(get_closest_vowel(word:\
    \ \"Above\") == \"o\")"
  status: Exception
  stderr: 'tmps_2x7vfe/tmps_2x7vfe.swift:62: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b7de4c10c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b7de4907b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b7de4907988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b7de49067b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmps_2x7vfe                        0x000055b7530e2847 <unavailable> + 6215

    5    libc.so.6                          0x00002b7de4dfc460 __libc_start_main +
    245

    6    tmps_2x7vfe                        0x000055b7530e2489 <unavailable> + 5257

    '
  stdout: ''
  timestamp: 1660013567
- exit_code: 1
  program: "\n/// You are given a word. Your task is to find the closest vowel that\
    \ stands between \n/// two consonants from the right side of the word (case sensitive).\n\
    /// Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n/// find any vowel met the above condition. \n/// You may assume that\
    \ the given string contains English letter only.\n/// Example:\n/// >>> get_closest_vowel(word:\
    \ \"yogurt\")\n/// \"u\"\n/// >>> get_closest_vowel(word: \"FULL\")\n/// \"U\"\
    \n/// >>> get_closest_vowel(word: \"quick\")\n/// \"\"\n/// >>> get_closest_vowel(word:\
    \ \"ab\")\n/// \"\"\nfunc get_closest_vowel(word: String) -> String {\n    var\
    \ vowels = [Character]()\n    for i in stride(from: word.count - 1, to: -1, by:\
    \ -1) {\n        let c = word[word.index(word.startIndex, offsetBy: i)]\n    \
    \    if is_vowel(c: c) {\n            vowels.append(c)\n        } else {\n   \
    \         if vowels.count > 0 {\n                return String(vowels[0])\n  \
    \          }\n        }\n    }\n    return \"\"\n}\n\n\nfunc ==(left: [(Int, Int)],\
    \ right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n       \
    \ return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r\
    \ {\n            return false\n        }\n    }\n    return true\n}\n        \
    \    \nassert(get_closest_vowel(word: \"yogurt\") == \"u\")\nassert(get_closest_vowel(word:\
    \ \"full\") == \"u\")\nassert(get_closest_vowel(word: \"easy\") == \"\")\nassert(get_closest_vowel(word:\
    \ \"eAsy\") == \"\")\nassert(get_closest_vowel(word: \"ali\") == \"\")\nassert(get_closest_vowel(word:\
    \ \"bad\") == \"a\")\nassert(get_closest_vowel(word: \"most\") == \"o\")\nassert(get_closest_vowel(word:\
    \ \"ab\") == \"\")\nassert(get_closest_vowel(word: \"ba\") == \"\")\nassert(get_closest_vowel(word:\
    \ \"quick\") == \"\")\nassert(get_closest_vowel(word: \"anime\") == \"i\")\nassert(get_closest_vowel(word:\
    \ \"Asia\") == \"\")\nassert(get_closest_vowel(word: \"Above\") == \"o\")"
  status: SyntaxError
  stderr: "/tmp/tmppul3qh_v.swift:20:12: error: cannot find 'is_vowel' in scope\n\
    \        if is_vowel(c: c) {\n           ^~~~~~~~\n"
  stdout: ''
  timestamp: 1660013567
- exit_code: 1
  program: "\n/// You are given a word. Your task is to find the closest vowel that\
    \ stands between \n/// two consonants from the right side of the word (case sensitive).\n\
    /// Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n/// find any vowel met the above condition. \n/// You may assume that\
    \ the given string contains English letter only.\n/// Example:\n/// >>> get_closest_vowel(word:\
    \ \"yogurt\")\n/// \"u\"\n/// >>> get_closest_vowel(word: \"FULL\")\n/// \"U\"\
    \n/// >>> get_closest_vowel(word: \"quick\")\n/// \"\"\n/// >>> get_closest_vowel(word:\
    \ \"ab\")\n/// \"\"\nfunc get_closest_vowel(word: String) -> String {\n    //\
    \ your code goes here\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(get_closest_vowel(word:\
    \ \"yogurt\") == \"u\")\nassert(get_closest_vowel(word: \"full\") == \"u\")\n\
    assert(get_closest_vowel(word: \"easy\") == \"\")\nassert(get_closest_vowel(word:\
    \ \"eAsy\") == \"\")\nassert(get_closest_vowel(word: \"ali\") == \"\")\nassert(get_closest_vowel(word:\
    \ \"bad\") == \"a\")\nassert(get_closest_vowel(word: \"most\") == \"o\")\nassert(get_closest_vowel(word:\
    \ \"ab\") == \"\")\nassert(get_closest_vowel(word: \"ba\") == \"\")\nassert(get_closest_vowel(word:\
    \ \"quick\") == \"\")\nassert(get_closest_vowel(word: \"anime\") == \"i\")\nassert(get_closest_vowel(word:\
    \ \"Asia\") == \"\")\nassert(get_closest_vowel(word: \"Above\") == \"o\")"
  status: SyntaxError
  stderr: '/tmp/tmpv1_fgypj.swift:18:1: error: missing return in global function expected
    to return ''String''

    }

    ^

    '
  stdout: ''
  timestamp: 1660013567
- exit_code: -4
  program: "\n/// You are given a word. Your task is to find the closest vowel that\
    \ stands between \n/// two consonants from the right side of the word (case sensitive).\n\
    /// Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n/// find any vowel met the above condition. \n/// You may assume that\
    \ the given string contains English letter only.\n/// Example:\n/// >>> get_closest_vowel(word:\
    \ \"yogurt\")\n/// \"u\"\n/// >>> get_closest_vowel(word: \"FULL\")\n/// \"U\"\
    \n/// >>> get_closest_vowel(word: \"quick\")\n/// \"\"\n/// >>> get_closest_vowel(word:\
    \ \"ab\")\n/// \"\"\nfunc get_closest_vowel(word: String) -> String {\n    var\
    \ rightVowel = \"\"\n    var right = 0\n    let vowel = \"aeiou\"\n    for (i,\
    \ c) in word.enumerated().reversed() {\n        if vowel.contains(c) {\n     \
    \       rightVowel = String(c)\n            right = i\n            break\n   \
    \     }\n    }\n    for (i, c) in word.enumerated().reversed() {\n        if !vowel.contains(c)\
    \ && i < right {\n            return rightVowel\n        }\n    }\n    return\
    \ \"\"\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n  \
    \  if left.count != right.count {\n        return false\n    }\n    for (l, r)\
    \ in zip(left, right) {\n        if l != r {\n            return false\n     \
    \   }\n    }\n    return true\n}\n            \nassert(get_closest_vowel(word:\
    \ \"yogurt\") == \"u\")\nassert(get_closest_vowel(word: \"full\") == \"u\")\n\
    assert(get_closest_vowel(word: \"easy\") == \"\")\nassert(get_closest_vowel(word:\
    \ \"eAsy\") == \"\")\nassert(get_closest_vowel(word: \"ali\") == \"\")\nassert(get_closest_vowel(word:\
    \ \"bad\") == \"a\")\nassert(get_closest_vowel(word: \"most\") == \"o\")\nassert(get_closest_vowel(word:\
    \ \"ab\") == \"\")\nassert(get_closest_vowel(word: \"ba\") == \"\")\nassert(get_closest_vowel(word:\
    \ \"quick\") == \"\")\nassert(get_closest_vowel(word: \"anime\") == \"i\")\nassert(get_closest_vowel(word:\
    \ \"Asia\") == \"\")\nassert(get_closest_vowel(word: \"Above\") == \"o\")"
  status: Exception
  stderr: 'tmp99kj5mmu/tmp99kj5mmu.swift:52: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002acc05683c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002acc0537ab6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002acc0537a988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002acc053797b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmp99kj5mmu                        0x000055f453a27b8b <unavailable> + 7051

    5    libc.so.6                          0x00002acc0586f460 __libc_start_main +
    245

    6    tmp99kj5mmu                        0x000055f453a27389 <unavailable> + 5001

    '
  stdout: ''
  timestamp: 1660013567
- exit_code: 1
  program: "\n/// You are given a word. Your task is to find the closest vowel that\
    \ stands between \n/// two consonants from the right side of the word (case sensitive).\n\
    /// Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n/// find any vowel met the above condition. \n/// You may assume that\
    \ the given string contains English letter only.\n/// Example:\n/// >>> get_closest_vowel(word:\
    \ \"yogurt\")\n/// \"u\"\n/// >>> get_closest_vowel(word: \"FULL\")\n/// \"U\"\
    \n/// >>> get_closest_vowel(word: \"quick\")\n/// \"\"\n/// >>> get_closest_vowel(word:\
    \ \"ab\")\n/// \"\"\nfunc get_closest_vowel(word: String) -> String {\n    var\
    \ vowels = \"aeiou\"\n    var consonants = \"bcdfghjklmnpqrstvwxyz\"\n    var\
    \ closest = \"\"\n    for c in word.characters {\n        let ch = String(c)\n\
    \        if vowels.contains(ch) {\n            closest = ch\n        } else if\
    \ consonants.contains(ch) {\n            closest = \"\"\n        }\n    }\n  \
    \  return closest\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) ->\
    \ Bool {\n    if left.count != right.count {\n        return false\n    }\n  \
    \  for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(get_closest_vowel(word:\
    \ \"yogurt\") == \"u\")\nassert(get_closest_vowel(word: \"full\") == \"u\")\n\
    assert(get_closest_vowel(word: \"easy\") == \"\")\nassert(get_closest_vowel(word:\
    \ \"eAsy\") == \"\")\nassert(get_closest_vowel(word: \"ali\") == \"\")\nassert(get_closest_vowel(word:\
    \ \"bad\") == \"a\")\nassert(get_closest_vowel(word: \"most\") == \"o\")\nassert(get_closest_vowel(word:\
    \ \"ab\") == \"\")\nassert(get_closest_vowel(word: \"ba\") == \"\")\nassert(get_closest_vowel(word:\
    \ \"quick\") == \"\")\nassert(get_closest_vowel(word: \"anime\") == \"i\")\nassert(get_closest_vowel(word:\
    \ \"Asia\") == \"\")\nassert(get_closest_vowel(word: \"Above\") == \"o\")"
  status: SyntaxError
  stderr: "/tmp/tmp3pjvz1i7.swift:20:19: error: 'characters' is unavailable: Please\
    \ use String directly\n    for c in word.characters {\n                  ^~~~~~~~~~\n\
    Swift.String:5:16: note: 'characters' was obsoleted in Swift 5.0\n    public var\
    \ characters: String { get set }\n               ^\n/tmp/tmp3pjvz1i7.swift:17:9:\
    \ warning: variable 'vowels' was never mutated; consider changing to 'let' constant\n\
    \    var vowels = \"aeiou\"\n    ~~~ ^\n    let\n/tmp/tmp3pjvz1i7.swift:18:9:\
    \ warning: variable 'consonants' was never mutated; consider changing to 'let'\
    \ constant\n    var consonants = \"bcdfghjklmnpqrstvwxyz\"\n    ~~~ ^\n    let\n"
  stdout: ''
  timestamp: 1660013567
- exit_code: -4
  program: "\n/// You are given a word. Your task is to find the closest vowel that\
    \ stands between \n/// two consonants from the right side of the word (case sensitive).\n\
    /// Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n/// find any vowel met the above condition. \n/// You may assume that\
    \ the given string contains English letter only.\n/// Example:\n/// >>> get_closest_vowel(word:\
    \ \"yogurt\")\n/// \"u\"\n/// >>> get_closest_vowel(word: \"FULL\")\n/// \"U\"\
    \n/// >>> get_closest_vowel(word: \"quick\")\n/// \"\"\n/// >>> get_closest_vowel(word:\
    \ \"ab\")\n/// \"\"\nfunc get_closest_vowel(word: String) -> String {\n    let\
    \ vowels = [\"a\", \"e\", \"i\", \"o\", \"u\"]\n    var new_word = \"\"\n    let\
    \ reversed_word = String(word.reversed())\n    var count = 0\n    for letter in\
    \ reversed_word {\n        if vowels.contains(String(letter)) {\n            new_word\
    \ += String(letter)\n            count += 1\n        }\n        if count == 2\
    \ {\n            return String(new_word.reversed())\n        }\n    }\n    return\
    \ \"\"\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n  \
    \  if left.count != right.count {\n        return false\n    }\n    for (l, r)\
    \ in zip(left, right) {\n        if l != r {\n            return false\n     \
    \   }\n    }\n    return true\n}\n            \nassert(get_closest_vowel(word:\
    \ \"yogurt\") == \"u\")\nassert(get_closest_vowel(word: \"full\") == \"u\")\n\
    assert(get_closest_vowel(word: \"easy\") == \"\")\nassert(get_closest_vowel(word:\
    \ \"eAsy\") == \"\")\nassert(get_closest_vowel(word: \"ali\") == \"\")\nassert(get_closest_vowel(word:\
    \ \"bad\") == \"a\")\nassert(get_closest_vowel(word: \"most\") == \"o\")\nassert(get_closest_vowel(word:\
    \ \"ab\") == \"\")\nassert(get_closest_vowel(word: \"ba\") == \"\")\nassert(get_closest_vowel(word:\
    \ \"quick\") == \"\")\nassert(get_closest_vowel(word: \"anime\") == \"i\")\nassert(get_closest_vowel(word:\
    \ \"Asia\") == \"\")\nassert(get_closest_vowel(word: \"Above\") == \"o\")"
  status: Exception
  stderr: 'tmp647h8oer/tmp647h8oer.swift:46: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b911d8dfc80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b911d5d6b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b911d5d6988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b911d5d57b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmp647h8oer                        0x0000555f201ec7e7 <unavailable> + 6119

    5    libc.so.6                          0x00002b911dacb460 __libc_start_main +
    245

    6    tmp647h8oer                        0x0000555f201ec429 <unavailable> + 5161

    '
  stdout: ''
  timestamp: 1660013567
- exit_code: -4
  program: "\n/// You are given a word. Your task is to find the closest vowel that\
    \ stands between \n/// two consonants from the right side of the word (case sensitive).\n\
    /// Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n/// find any vowel met the above condition. \n/// You may assume that\
    \ the given string contains English letter only.\n/// Example:\n/// >>> get_closest_vowel(word:\
    \ \"yogurt\")\n/// \"u\"\n/// >>> get_closest_vowel(word: \"FULL\")\n/// \"U\"\
    \n/// >>> get_closest_vowel(word: \"quick\")\n/// \"\"\n/// >>> get_closest_vowel(word:\
    \ \"ab\")\n/// \"\"\nfunc get_closest_vowel(word: String) -> String {\n    return\
    \ \"\"\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n  \
    \  if left.count != right.count {\n        return false\n    }\n    for (l, r)\
    \ in zip(left, right) {\n        if l != r {\n            return false\n     \
    \   }\n    }\n    return true\n}\n            \nassert(get_closest_vowel(word:\
    \ \"yogurt\") == \"u\")\nassert(get_closest_vowel(word: \"full\") == \"u\")\n\
    assert(get_closest_vowel(word: \"easy\") == \"\")\nassert(get_closest_vowel(word:\
    \ \"eAsy\") == \"\")\nassert(get_closest_vowel(word: \"ali\") == \"\")\nassert(get_closest_vowel(word:\
    \ \"bad\") == \"a\")\nassert(get_closest_vowel(word: \"most\") == \"o\")\nassert(get_closest_vowel(word:\
    \ \"ab\") == \"\")\nassert(get_closest_vowel(word: \"ba\") == \"\")\nassert(get_closest_vowel(word:\
    \ \"quick\") == \"\")\nassert(get_closest_vowel(word: \"anime\") == \"i\")\nassert(get_closest_vowel(word:\
    \ \"Asia\") == \"\")\nassert(get_closest_vowel(word: \"Above\") == \"o\")"
  status: Exception
  stderr: 'tmpvf1hzub_/tmpvf1hzub_.swift:33: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002ba694399c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002ba694090b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002ba694090988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002ba69408f7b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpvf1hzub_                        0x00005567315f8307 <unavailable> + 4871

    5    libc.so.6                          0x00002ba694585460 __libc_start_main +
    245

    6    tmpvf1hzub_                        0x00005567315f7f49 <unavailable> + 3913

    '
  stdout: ''
  timestamp: 1660013566
- exit_code: -4
  program: "\n/// You are given a word. Your task is to find the closest vowel that\
    \ stands between \n/// two consonants from the right side of the word (case sensitive).\n\
    /// Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n/// find any vowel met the above condition. \n/// You may assume that\
    \ the given string contains English letter only.\n/// Example:\n/// >>> get_closest_vowel(word:\
    \ \"yogurt\")\n/// \"u\"\n/// >>> get_closest_vowel(word: \"FULL\")\n/// \"U\"\
    \n/// >>> get_closest_vowel(word: \"quick\")\n/// \"\"\n/// >>> get_closest_vowel(word:\
    \ \"ab\")\n/// \"\"\nfunc get_closest_vowel(word: String) -> String {\n    return\
    \ \"-\"\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n \
    \   if left.count != right.count {\n        return false\n    }\n    for (l, r)\
    \ in zip(left, right) {\n        if l != r {\n            return false\n     \
    \   }\n    }\n    return true\n}\n            \nassert(get_closest_vowel(word:\
    \ \"yogurt\") == \"u\")\nassert(get_closest_vowel(word: \"full\") == \"u\")\n\
    assert(get_closest_vowel(word: \"easy\") == \"\")\nassert(get_closest_vowel(word:\
    \ \"eAsy\") == \"\")\nassert(get_closest_vowel(word: \"ali\") == \"\")\nassert(get_closest_vowel(word:\
    \ \"bad\") == \"a\")\nassert(get_closest_vowel(word: \"most\") == \"o\")\nassert(get_closest_vowel(word:\
    \ \"ab\") == \"\")\nassert(get_closest_vowel(word: \"ba\") == \"\")\nassert(get_closest_vowel(word:\
    \ \"quick\") == \"\")\nassert(get_closest_vowel(word: \"anime\") == \"i\")\nassert(get_closest_vowel(word:\
    \ \"Asia\") == \"\")\nassert(get_closest_vowel(word: \"Above\") == \"o\")"
  status: Exception
  stderr: 'tmp34if5y_t/tmp34if5y_t.swift:33: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b572a45cc80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b572a153b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b572a153988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b572a1527b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmp34if5y_t                        0x0000564ec001c307 <unavailable> + 4871

    5    libc.so.6                          0x00002b572a648460 __libc_start_main +
    245

    6    tmp34if5y_t                        0x0000564ec001bf49 <unavailable> + 3913

    '
  stdout: ''
  timestamp: 1660013567
- exit_code: -4
  program: "\n/// You are given a word. Your task is to find the closest vowel that\
    \ stands between \n/// two consonants from the right side of the word (case sensitive).\n\
    /// Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n/// find any vowel met the above condition. \n/// You may assume that\
    \ the given string contains English letter only.\n/// Example:\n/// >>> get_closest_vowel(word:\
    \ \"yogurt\")\n/// \"u\"\n/// >>> get_closest_vowel(word: \"FULL\")\n/// \"U\"\
    \n/// >>> get_closest_vowel(word: \"quick\")\n/// \"\"\n/// >>> get_closest_vowel(word:\
    \ \"ab\")\n/// \"\"\nfunc get_closest_vowel(word: String) -> String {\n    //\
    \ TODO: Implement\n    return \"\"\n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(get_closest_vowel(word: \"yogurt\") == \"u\")\nassert(get_closest_vowel(word:\
    \ \"full\") == \"u\")\nassert(get_closest_vowel(word: \"easy\") == \"\")\nassert(get_closest_vowel(word:\
    \ \"eAsy\") == \"\")\nassert(get_closest_vowel(word: \"ali\") == \"\")\nassert(get_closest_vowel(word:\
    \ \"bad\") == \"a\")\nassert(get_closest_vowel(word: \"most\") == \"o\")\nassert(get_closest_vowel(word:\
    \ \"ab\") == \"\")\nassert(get_closest_vowel(word: \"ba\") == \"\")\nassert(get_closest_vowel(word:\
    \ \"quick\") == \"\")\nassert(get_closest_vowel(word: \"anime\") == \"i\")\nassert(get_closest_vowel(word:\
    \ \"Asia\") == \"\")\nassert(get_closest_vowel(word: \"Above\") == \"o\")"
  status: Exception
  stderr: 'tmp10wyi_xt/tmp10wyi_xt.swift:34: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b561191bc80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b5611612b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b5611612988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b56116117b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmp10wyi_xt                        0x000055e2aef9f307 <unavailable> + 4871

    5    libc.so.6                          0x00002b5611b07460 __libc_start_main +
    245

    6    tmp10wyi_xt                        0x000055e2aef9ef49 <unavailable> + 3913

    '
  stdout: ''
  timestamp: 1660013567
- exit_code: -4
  program: "\n/// You are given a word. Your task is to find the closest vowel that\
    \ stands between \n/// two consonants from the right side of the word (case sensitive).\n\
    /// Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n/// find any vowel met the above condition. \n/// You may assume that\
    \ the given string contains English letter only.\n/// Example:\n/// >>> get_closest_vowel(word:\
    \ \"yogurt\")\n/// \"u\"\n/// >>> get_closest_vowel(word: \"FULL\")\n/// \"U\"\
    \n/// >>> get_closest_vowel(word: \"quick\")\n/// \"\"\n/// >>> get_closest_vowel(word:\
    \ \"ab\")\n/// \"\"\nfunc get_closest_vowel(word: String) -> String {\n    //\
    \ your code goes here\n    let vowels = [\"a\", \"e\", \"i\", \"o\", \"u\"]\n\
    \    let chars = Array(word)\n    var consonants = [Character]()\n    for char\
    \ in chars {\n        if !vowels.contains(String(char).lowercased()) {\n     \
    \       consonants.append(char)\n        }\n    }\n    var index = chars.count\
    \ - 1\n    while index >= 0 {\n        let char = chars[index]\n        if !vowels.contains(String(char).lowercased())\
    \ {\n            consonants.removeLast()\n        } else {\n            if consonants.count\
    \ >= 2 {\n                return String(char)\n            }\n        }\n    \
    \    index -= 1\n    }\n    return \"\"\n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(get_closest_vowel(word: \"yogurt\") == \"u\")\nassert(get_closest_vowel(word:\
    \ \"full\") == \"u\")\nassert(get_closest_vowel(word: \"easy\") == \"\")\nassert(get_closest_vowel(word:\
    \ \"eAsy\") == \"\")\nassert(get_closest_vowel(word: \"ali\") == \"\")\nassert(get_closest_vowel(word:\
    \ \"bad\") == \"a\")\nassert(get_closest_vowel(word: \"most\") == \"o\")\nassert(get_closest_vowel(word:\
    \ \"ab\") == \"\")\nassert(get_closest_vowel(word: \"ba\") == \"\")\nassert(get_closest_vowel(word:\
    \ \"quick\") == \"\")\nassert(get_closest_vowel(word: \"anime\") == \"i\")\nassert(get_closest_vowel(word:\
    \ \"Asia\") == \"\")\nassert(get_closest_vowel(word: \"Above\") == \"o\")"
  status: Exception
  stderr: 'tmpq6cz9gq0/tmpq6cz9gq0.swift:55: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b4378198c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b4377e8fb6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b4377e8f988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b4377e8e7b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpq6cz9gq0                        0x000055b91c2b4b07 <unavailable> + 6919

    5    libc.so.6                          0x00002b4378384460 __libc_start_main +
    245

    6    tmpq6cz9gq0                        0x000055b91c2b4659 <unavailable> + 5721

    '
  stdout: ''
  timestamp: 1660013567
- exit_code: 1
  program: "\n/// You are given a word. Your task is to find the closest vowel that\
    \ stands between \n/// two consonants from the right side of the word (case sensitive).\n\
    /// Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n/// find any vowel met the above condition. \n/// You may assume that\
    \ the given string contains English letter only.\n/// Example:\n/// >>> get_closest_vowel(word:\
    \ \"yogurt\")\n/// \"u\"\n/// >>> get_closest_vowel(word: \"FULL\")\n/// \"U\"\
    \n/// >>> get_closest_vowel(word: \"quick\")\n/// \"\"\n/// >>> get_closest_vowel(word:\
    \ \"ab\")\n/// \"\"\nfunc get_closest_vowel(word: String) -> String {\n    let\
    \ vowels = \"aeiouAEIOU\"\n    let cons = \"bcdfghjklmnpqrstvwxyzBCDFGHJKLMNPQRSTVWXYZ\"\
    \n    var last_index = -1\n\n    for i in (0..<word.count).reversed() {\n    \
    \    let char = word[i]\n        if vowels.contains(char) {\n            last_index\
    \ = i\n            break\n        }\n    }\n\n    for i in (0..<last_index).reversed()\
    \ {\n        let char = word[i]\n        if cons.contains(char) {\n          \
    \  return String(word[last_index])\n        }\n    }\n\n    return \"\"\n}\n\n\
    \nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(get_closest_vowel(word: \"yogurt\") == \"u\")\n\
    assert(get_closest_vowel(word: \"full\") == \"u\")\nassert(get_closest_vowel(word:\
    \ \"easy\") == \"\")\nassert(get_closest_vowel(word: \"eAsy\") == \"\")\nassert(get_closest_vowel(word:\
    \ \"ali\") == \"\")\nassert(get_closest_vowel(word: \"bad\") == \"a\")\nassert(get_closest_vowel(word:\
    \ \"most\") == \"o\")\nassert(get_closest_vowel(word: \"ab\") == \"\")\nassert(get_closest_vowel(word:\
    \ \"ba\") == \"\")\nassert(get_closest_vowel(word: \"quick\") == \"\")\nassert(get_closest_vowel(word:\
    \ \"anime\") == \"i\")\nassert(get_closest_vowel(word: \"Asia\") == \"\")\nassert(get_closest_vowel(word:\
    \ \"Above\") == \"o\")"
  status: SyntaxError
  stderr: "/tmp/tmpwizdgmw4.swift:22:20: error: 'subscript(_:)' is unavailable: cannot\
    \ subscript String with an Int, use a String.Index instead.\n        let char\
    \ = word[i]\n                   ^~~~~~~\nSwift.String:3:12: note: 'subscript(_:)'\
    \ has been explicitly marked unavailable here\n    public subscript(i: Int) ->\
    \ Character { get }\n           ^\n/tmp/tmpwizdgmw4.swift:30:20: error: 'subscript(_:)'\
    \ is unavailable: cannot subscript String with an Int, use a String.Index instead.\n\
    \        let char = word[i]\n                   ^~~~~~~\nSwift.String:3:12: note:\
    \ 'subscript(_:)' has been explicitly marked unavailable here\n    public subscript(i:\
    \ Int) -> Character { get }\n           ^\n/tmp/tmpwizdgmw4.swift:32:27: error:\
    \ 'subscript(_:)' is unavailable: cannot subscript String with an Int, use a String.Index\
    \ instead.\n            return String(word[last_index])\n                    \
    \      ^~~~~~~~~~~~~~~~\nSwift.String:3:12: note: 'subscript(_:)' has been explicitly\
    \ marked unavailable here\n    public subscript(i: Int) -> Character { get }\n\
    \           ^\n"
  stdout: ''
  timestamp: 1660013567
- exit_code: -4
  program: "\n/// You are given a word. Your task is to find the closest vowel that\
    \ stands between \n/// two consonants from the right side of the word (case sensitive).\n\
    /// Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n/// find any vowel met the above condition. \n/// You may assume that\
    \ the given string contains English letter only.\n/// Example:\n/// >>> get_closest_vowel(word:\
    \ \"yogurt\")\n/// \"u\"\n/// >>> get_closest_vowel(word: \"FULL\")\n/// \"U\"\
    \n/// >>> get_closest_vowel(word: \"quick\")\n/// \"\"\n/// >>> get_closest_vowel(word:\
    \ \"ab\")\n/// \"\"\nfunc get_closest_vowel(word: String) -> String {\n    let\
    \ vowels = [\"a\", \"e\", \"i\", \"o\", \"u\"]\n    let reversed_word = String(word.reversed())\n\
    \    var result: String = \"\"\n    var consonant_count = 0\n    for ch in reversed_word\
    \ {\n        if vowels.contains(String(ch)) {\n            if consonant_count\
    \ == 1 {\n                result = String(ch)\n                break\n       \
    \     }\n        } else {\n            consonant_count += 1\n        }\n    }\n\
    \    return result\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) ->\
    \ Bool {\n    if left.count != right.count {\n        return false\n    }\n  \
    \  for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(get_closest_vowel(word:\
    \ \"yogurt\") == \"u\")\nassert(get_closest_vowel(word: \"full\") == \"u\")\n\
    assert(get_closest_vowel(word: \"easy\") == \"\")\nassert(get_closest_vowel(word:\
    \ \"eAsy\") == \"\")\nassert(get_closest_vowel(word: \"ali\") == \"\")\nassert(get_closest_vowel(word:\
    \ \"bad\") == \"a\")\nassert(get_closest_vowel(word: \"most\") == \"o\")\nassert(get_closest_vowel(word:\
    \ \"ab\") == \"\")\nassert(get_closest_vowel(word: \"ba\") == \"\")\nassert(get_closest_vowel(word:\
    \ \"quick\") == \"\")\nassert(get_closest_vowel(word: \"anime\") == \"i\")\nassert(get_closest_vowel(word:\
    \ \"Asia\") == \"\")\nassert(get_closest_vowel(word: \"Above\") == \"o\")"
  status: Exception
  stderr: 'tmpcqk8h564/tmpcqk8h564.swift:47: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b09a5363c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b09a505ab6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b09a505a988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b09a50597b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpcqk8h564                        0x000055d71dd27797 <unavailable> + 6039

    5    libc.so.6                          0x00002b09a554f460 __libc_start_main +
    245

    6    tmpcqk8h564                        0x000055d71dd273d9 <unavailable> + 5081

    '
  stdout: ''
  timestamp: 1660013568
- exit_code: -4
  program: "\n/// You are given a word. Your task is to find the closest vowel that\
    \ stands between \n/// two consonants from the right side of the word (case sensitive).\n\
    /// Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n/// find any vowel met the above condition. \n/// You may assume that\
    \ the given string contains English letter only.\n/// Example:\n/// >>> get_closest_vowel(word:\
    \ \"yogurt\")\n/// \"u\"\n/// >>> get_closest_vowel(word: \"FULL\")\n/// \"U\"\
    \n/// >>> get_closest_vowel(word: \"quick\")\n/// \"\"\n/// >>> get_closest_vowel(word:\
    \ \"ab\")\n/// \"\"\nfunc get_closest_vowel(word: String) -> String {\n    var\
    \ closest = \"\"\n    var start = 0\n    var end = 0\n    let vowels = [\"a\"\
    , \"e\", \"i\", \"o\", \"u\"]\n    for i in 0..<word.count {\n        var ch =\
    \ String(word[word.index(word.startIndex, offsetBy: i)])\n        if vowels.contains(ch)\
    \ {\n            start = i\n            break\n        }\n    }\n    for i in\
    \ start..<word.count {\n        var ch = String(word[word.index(word.startIndex,\
    \ offsetBy: i)])\n        if !vowels.contains(ch) {\n            end = i\n   \
    \         break\n        }\n    }\n    if end != 0 {\n        closest = String(word[word.index(word.startIndex,\
    \ offsetBy: end)])\n    }\n    return closest\n}\n\n\nfunc ==(left: [(Int, Int)],\
    \ right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n       \
    \ return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r\
    \ {\n            return false\n        }\n    }\n    return true\n}\n        \
    \    \nassert(get_closest_vowel(word: \"yogurt\") == \"u\")\nassert(get_closest_vowel(word:\
    \ \"full\") == \"u\")\nassert(get_closest_vowel(word: \"easy\") == \"\")\nassert(get_closest_vowel(word:\
    \ \"eAsy\") == \"\")\nassert(get_closest_vowel(word: \"ali\") == \"\")\nassert(get_closest_vowel(word:\
    \ \"bad\") == \"a\")\nassert(get_closest_vowel(word: \"most\") == \"o\")\nassert(get_closest_vowel(word:\
    \ \"ab\") == \"\")\nassert(get_closest_vowel(word: \"ba\") == \"\")\nassert(get_closest_vowel(word:\
    \ \"quick\") == \"\")\nassert(get_closest_vowel(word: \"anime\") == \"i\")\nassert(get_closest_vowel(word:\
    \ \"Asia\") == \"\")\nassert(get_closest_vowel(word: \"Above\") == \"o\")"
  status: Exception
  stderr: 'tmpjhre66s5/tmpjhre66s5.swift:54: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b19cbaf6c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b19cb7edb6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b19cb7ed988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b19cb7ec7b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpjhre66s5                        0x000055a03eef8827 <unavailable> + 6183

    5    libc.so.6                          0x00002b19cbce2460 __libc_start_main +
    245

    6    tmpjhre66s5                        0x000055a03eef8469 <unavailable> + 5225

    '
  stdout: ''
  timestamp: 1660013568
- exit_code: -4
  program: "\n/// You are given a word. Your task is to find the closest vowel that\
    \ stands between \n/// two consonants from the right side of the word (case sensitive).\n\
    /// Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n/// find any vowel met the above condition. \n/// You may assume that\
    \ the given string contains English letter only.\n/// Example:\n/// >>> get_closest_vowel(word:\
    \ \"yogurt\")\n/// \"u\"\n/// >>> get_closest_vowel(word: \"FULL\")\n/// \"U\"\
    \n/// >>> get_closest_vowel(word: \"quick\")\n/// \"\"\n/// >>> get_closest_vowel(word:\
    \ \"ab\")\n/// \"\"\nfunc get_closest_vowel(word: String) -> String {\n    let\
    \ vowels = \"aeiouAEIOU\"\n    let consonants = \"bcdfghjklmnpqrstvwxyzBCDFGHJKLMNPQRSTVWXYZ\"\
    \n    var closestVowel: String = \"\"\n    var word = word\n    while word.count\
    \ > 0 {\n        let popped = word.popLast()\n        if vowels.contains(popped!)\
    \ {\n            closestVowel = String(popped!)\n            break\n        }\n\
    \    }\n    var isConsonant: Bool = false\n    for char in word {\n        if\
    \ consonants.contains(char) {\n            isConsonant = true\n        } else\
    \ if isConsonant == true {\n            return String(char)\n        }\n    }\n\
    \    return closestVowel\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(get_closest_vowel(word:\
    \ \"yogurt\") == \"u\")\nassert(get_closest_vowel(word: \"full\") == \"u\")\n\
    assert(get_closest_vowel(word: \"easy\") == \"\")\nassert(get_closest_vowel(word:\
    \ \"eAsy\") == \"\")\nassert(get_closest_vowel(word: \"ali\") == \"\")\nassert(get_closest_vowel(word:\
    \ \"bad\") == \"a\")\nassert(get_closest_vowel(word: \"most\") == \"o\")\nassert(get_closest_vowel(word:\
    \ \"ab\") == \"\")\nassert(get_closest_vowel(word: \"ba\") == \"\")\nassert(get_closest_vowel(word:\
    \ \"quick\") == \"\")\nassert(get_closest_vowel(word: \"anime\") == \"i\")\nassert(get_closest_vowel(word:\
    \ \"Asia\") == \"\")\nassert(get_closest_vowel(word: \"Above\") == \"o\")"
  status: Exception
  stderr: 'tmp6wsjyh9_/tmp6wsjyh9_.swift:52: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b5be5efac80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b5be5bf1b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b5be5bf1988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b5be5bf07b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmp6wsjyh9_                        0x000055e12cef76e7 <unavailable> + 5863

    5    libc.so.6                          0x00002b5be60e6460 __libc_start_main +
    245

    6    tmp6wsjyh9_                        0x000055e12cef7329 <unavailable> + 4905

    '
  stdout: ''
  timestamp: 1660013568
- exit_code: 1
  program: "\n/// You are given a word. Your task is to find the closest vowel that\
    \ stands between \n/// two consonants from the right side of the word (case sensitive).\n\
    /// Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n/// find any vowel met the above condition. \n/// You may assume that\
    \ the given string contains English letter only.\n/// Example:\n/// >>> get_closest_vowel(word:\
    \ \"yogurt\")\n/// \"u\"\n/// >>> get_closest_vowel(word: \"FULL\")\n/// \"U\"\
    \n/// >>> get_closest_vowel(word: \"quick\")\n/// \"\"\n/// >>> get_closest_vowel(word:\
    \ \"ab\")\n/// \"\"\nfunc get_closest_vowel(word: String) -> String {\n  let vowels\
    \ = [\"a\", \"e\", \"i\", \"o\", \"u\"]\n  var word = word.lowercased()\n  word\
    \ = word.reversed()\n  var lastVowel = String()\n  var result = String()\n  for\
    \ char in word {\n    if vowels.contains(String(char)) {\n      lastVowel = String(char)\n\
    \      break\n    }\n  }\n  if lastVowel == \"\" {\n    return result\n  }\n \
    \ var foundConsonant = false\n  for char in word {\n    if vowels.contains(String(char))\
    \ {\n      if foundConsonant {\n        result = String(char)\n        break\n\
    \      }\n    } else {\n      foundConsonant = true\n    }\n  }\n  if result ==\
    \ \"\" {\n    return lastVowel\n  }\n  return result\n}\n\n\nfunc ==(left: [(Int,\
    \ Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n\
    \        return false\n    }\n    for (l, r) in zip(left, right) {\n        if\
    \ l != r {\n            return false\n        }\n    }\n    return true\n}\n \
    \           \nassert(get_closest_vowel(word: \"yogurt\") == \"u\")\nassert(get_closest_vowel(word:\
    \ \"full\") == \"u\")\nassert(get_closest_vowel(word: \"easy\") == \"\")\nassert(get_closest_vowel(word:\
    \ \"eAsy\") == \"\")\nassert(get_closest_vowel(word: \"ali\") == \"\")\nassert(get_closest_vowel(word:\
    \ \"bad\") == \"a\")\nassert(get_closest_vowel(word: \"most\") == \"o\")\nassert(get_closest_vowel(word:\
    \ \"ab\") == \"\")\nassert(get_closest_vowel(word: \"ba\") == \"\")\nassert(get_closest_vowel(word:\
    \ \"quick\") == \"\")\nassert(get_closest_vowel(word: \"anime\") == \"i\")\nassert(get_closest_vowel(word:\
    \ \"Asia\") == \"\")\nassert(get_closest_vowel(word: \"Above\") == \"o\")"
  status: SyntaxError
  stderr: "/tmp/tmp9g3ph9il.swift:19:15: error: no 'reversed' candidates produce the\
    \ expected contextual result type 'String'\n  word = word.reversed()\n       \
    \       ^\nSwift.Sequence:2:40: note: 'reversed()' produces '[String.Element]'\
    \ (aka 'Array<Character>'), not the expected contextual result type 'String'\n\
    \    @inlinable public __consuming func reversed() -> [Self.Element]\n       \
    \                                ^\nSwift.BidirectionalCollection:2:40: note:\
    \ 'reversed()' produces 'ReversedCollection<String>', not the expected contextual\
    \ result type 'String'\n    @inlinable public __consuming func reversed() -> ReversedCollection<Self>\n\
    \                                       ^\n"
  stdout: ''
  timestamp: 1660013567
- exit_code: -4
  program: "\n/// You are given a word. Your task is to find the closest vowel that\
    \ stands between \n/// two consonants from the right side of the word (case sensitive).\n\
    /// Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n/// find any vowel met the above condition. \n/// You may assume that\
    \ the given string contains English letter only.\n/// Example:\n/// >>> get_closest_vowel(word:\
    \ \"yogurt\")\n/// \"u\"\n/// >>> get_closest_vowel(word: \"FULL\")\n/// \"U\"\
    \n/// >>> get_closest_vowel(word: \"quick\")\n/// \"\"\n/// >>> get_closest_vowel(word:\
    \ \"ab\")\n/// \"\"\nfunc get_closest_vowel(word: String) -> String {\n    //\
    \ Your code here\n    return \"\"\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int,\
    \ Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n\
    \    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n          \
    \  return false\n        }\n    }\n    return true\n}\n            \nassert(get_closest_vowel(word:\
    \ \"yogurt\") == \"u\")\nassert(get_closest_vowel(word: \"full\") == \"u\")\n\
    assert(get_closest_vowel(word: \"easy\") == \"\")\nassert(get_closest_vowel(word:\
    \ \"eAsy\") == \"\")\nassert(get_closest_vowel(word: \"ali\") == \"\")\nassert(get_closest_vowel(word:\
    \ \"bad\") == \"a\")\nassert(get_closest_vowel(word: \"most\") == \"o\")\nassert(get_closest_vowel(word:\
    \ \"ab\") == \"\")\nassert(get_closest_vowel(word: \"ba\") == \"\")\nassert(get_closest_vowel(word:\
    \ \"quick\") == \"\")\nassert(get_closest_vowel(word: \"anime\") == \"i\")\nassert(get_closest_vowel(word:\
    \ \"Asia\") == \"\")\nassert(get_closest_vowel(word: \"Above\") == \"o\")"
  status: Exception
  stderr: 'tmp9x8r15w2/tmp9x8r15w2.swift:34: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002ac48eb3ec80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002ac48e835b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002ac48e835988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002ac48e8347b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmp9x8r15w2                        0x0000555b727e0307 <unavailable> + 4871

    5    libc.so.6                          0x00002ac48ed2a460 __libc_start_main +
    245

    6    tmp9x8r15w2                        0x0000555b727dff49 <unavailable> + 3913

    '
  stdout: ''
  timestamp: 1660013568
- exit_code: 1
  program: "\n/// You are given a word. Your task is to find the closest vowel that\
    \ stands between \n/// two consonants from the right side of the word (case sensitive).\n\
    /// Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n/// find any vowel met the above condition. \n/// You may assume that\
    \ the given string contains English letter only.\n/// Example:\n/// >>> get_closest_vowel(word:\
    \ \"yogurt\")\n/// \"u\"\n/// >>> get_closest_vowel(word: \"FULL\")\n/// \"U\"\
    \n/// >>> get_closest_vowel(word: \"quick\")\n/// \"\"\n/// >>> get_closest_vowel(word:\
    \ \"ab\")\n/// \"\"\nfunc get_closest_vowel(word: String) -> String {\n    let\
    \ vowels = [\"a\", \"e\", \"i\", \"o\", \"u\"]\n    var result = \"\"\n    for\
    \ i in stride(from: word.count - 1, to: 0, by: -1) {\n        let c = String(word[i])\n\
    \        if vowels.contains(c) {\n            for j in stride(from: i - 1, to:\
    \ 0, by: -1) {\n                let d = String(word[j])\n                if !vowels.contains(d)\
    \ {\n                    result = c\n                    break\n             \
    \   }\n            }\n        }\n    }\n    return result\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(get_closest_vowel(word: \"yogurt\") == \"u\")\nassert(get_closest_vowel(word:\
    \ \"full\") == \"u\")\nassert(get_closest_vowel(word: \"easy\") == \"\")\nassert(get_closest_vowel(word:\
    \ \"eAsy\") == \"\")\nassert(get_closest_vowel(word: \"ali\") == \"\")\nassert(get_closest_vowel(word:\
    \ \"bad\") == \"a\")\nassert(get_closest_vowel(word: \"most\") == \"o\")\nassert(get_closest_vowel(word:\
    \ \"ab\") == \"\")\nassert(get_closest_vowel(word: \"ba\") == \"\")\nassert(get_closest_vowel(word:\
    \ \"quick\") == \"\")\nassert(get_closest_vowel(word: \"anime\") == \"i\")\nassert(get_closest_vowel(word:\
    \ \"Asia\") == \"\")\nassert(get_closest_vowel(word: \"Above\") == \"o\")"
  status: SyntaxError
  stderr: "/tmp/tmp7vo4gqry.swift:20:24: error: 'subscript(_:)' is unavailable: cannot\
    \ subscript String with an Int, use a String.Index instead.\n        let c = String(word[i])\n\
    \                       ^~~~~~~\nSwift.String:3:12: note: 'subscript(_:)' has\
    \ been explicitly marked unavailable here\n    public subscript(i: Int) -> Character\
    \ { get }\n           ^\n/tmp/tmp7vo4gqry.swift:23:32: error: 'subscript(_:)'\
    \ is unavailable: cannot subscript String with an Int, use a String.Index instead.\n\
    \                let d = String(word[j])\n                               ^~~~~~~\n\
    Swift.String:3:12: note: 'subscript(_:)' has been explicitly marked unavailable\
    \ here\n    public subscript(i: Int) -> Character { get }\n           ^\n"
  stdout: ''
  timestamp: 1660013567
- exit_code: -4
  program: "\n/// You are given a word. Your task is to find the closest vowel that\
    \ stands between \n/// two consonants from the right side of the word (case sensitive).\n\
    /// Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n/// find any vowel met the above condition. \n/// You may assume that\
    \ the given string contains English letter only.\n/// Example:\n/// >>> get_closest_vowel(word:\
    \ \"yogurt\")\n/// \"u\"\n/// >>> get_closest_vowel(word: \"FULL\")\n/// \"U\"\
    \n/// >>> get_closest_vowel(word: \"quick\")\n/// \"\"\n/// >>> get_closest_vowel(word:\
    \ \"ab\")\n/// \"\"\nfunc get_closest_vowel(word: String) -> String {\n    let\
    \ vowels = [\"a\", \"e\", \"i\", \"o\", \"u\"]\n    var closestVowel = \"\"\n\
    \    var result = \"\"\n    for char in word.reversed() {\n        if vowels.contains(String(char))\
    \ {\n            closestVowel = String(char)\n            break\n        }\n \
    \   }\n    var current = 0\n    for char in word {\n        if vowels.contains(String(char))\
    \ {\n            if word.distance(from: word.startIndex, to: word.index(of: char)!)\
    \ > current {\n                result = String(char)\n                current\
    \ = word.distance(from: word.startIndex, to: word.index(of: char)!)\n        \
    \    }\n        }\n    }\n    if result == \"\" {\n        return result\n   \
    \ }\n    if word.distance(from: word.startIndex, to: word.index(of: Character(result))!)\
    \ > word.distance(from: word.startIndex, to: word.index(of: Character(closestVowel))!)\
    \ {\n        return closestVowel\n    }\n    return result\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(get_closest_vowel(word: \"yogurt\") == \"u\")\nassert(get_closest_vowel(word:\
    \ \"full\") == \"u\")\nassert(get_closest_vowel(word: \"easy\") == \"\")\nassert(get_closest_vowel(word:\
    \ \"eAsy\") == \"\")\nassert(get_closest_vowel(word: \"ali\") == \"\")\nassert(get_closest_vowel(word:\
    \ \"bad\") == \"a\")\nassert(get_closest_vowel(word: \"most\") == \"o\")\nassert(get_closest_vowel(word:\
    \ \"ab\") == \"\")\nassert(get_closest_vowel(word: \"ba\") == \"\")\nassert(get_closest_vowel(word:\
    \ \"quick\") == \"\")\nassert(get_closest_vowel(word: \"anime\") == \"i\")\nassert(get_closest_vowel(word:\
    \ \"Asia\") == \"\")\nassert(get_closest_vowel(word: \"Above\") == \"o\")"
  status: Exception
  stderr: 'tmp0b_ox7vi/tmp0b_ox7vi.swift:59: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002af79c691c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002af79c388b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002af79c388988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002af79c3877b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmp0b_ox7vi                        0x000055e6e16b9cc3 <unavailable> + 7363

    5    libc.so.6                          0x00002af79c87d460 __libc_start_main +
    245

    6    tmp0b_ox7vi                        0x000055e6e16b96f9 <unavailable> + 5881

    '
  stdout: ''
  timestamp: 1660013568
- exit_code: -4
  program: "\n/// You are given a word. Your task is to find the closest vowel that\
    \ stands between \n/// two consonants from the right side of the word (case sensitive).\n\
    /// Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n/// find any vowel met the above condition. \n/// You may assume that\
    \ the given string contains English letter only.\n/// Example:\n/// >>> get_closest_vowel(word:\
    \ \"yogurt\")\n/// \"u\"\n/// >>> get_closest_vowel(word: \"FULL\")\n/// \"U\"\
    \n/// >>> get_closest_vowel(word: \"quick\")\n/// \"\"\n/// >>> get_closest_vowel(word:\
    \ \"ab\")\n/// \"\"\nfunc get_closest_vowel(word: String) -> String {\n    let\
    \ vowels = [\"a\", \"e\", \"i\", \"o\", \"u\"]\n    let consonants = [\"b\", \"\
    c\", \"d\", \"f\", \"g\", \"h\", \"j\", \"k\", \"l\", \"m\", \"n\", \"p\", \"\
    q\", \"r\", \"s\", \"t\", \"v\", \"w\", \"x\", \"y\", \"z\"]\n    let upperVowels\
    \ = [\"A\", \"E\", \"I\", \"O\", \"U\"]\n    let upperConsonants = [\"B\", \"\
    C\", \"D\", \"F\", \"G\", \"H\", \"J\", \"K\", \"L\", \"M\", \"N\", \"P\", \"\
    Q\", \"R\", \"S\", \"T\", \"V\", \"W\", \"X\", \"Y\", \"Z\"]\n    var position:\
    \ Int = 0\n    for i in (0...word.count - 1).reversed() {\n        var char: Character\
    \ = Array(word)[i]\n        let charString = String(char)\n        if vowels.contains(charString)\
    \ || upperVowels.contains(charString) {\n            position = i\n          \
    \  break\n        }\n    }\n    if position != 0 {\n        var j = 0\n      \
    \  while j <= position - 1 {\n            var char = Array(word)[j]\n        \
    \    let charString = String(char)\n            if consonants.contains(charString)\
    \ || upperConsonants.contains(charString) {\n                return String(Array(word)[position])\n\
    \            }\n            j += 1\n        }\n    }\n    return \"\"\n}\n\n\n\
    func ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(get_closest_vowel(word: \"yogurt\") == \"u\")\n\
    assert(get_closest_vowel(word: \"full\") == \"u\")\nassert(get_closest_vowel(word:\
    \ \"easy\") == \"\")\nassert(get_closest_vowel(word: \"eAsy\") == \"\")\nassert(get_closest_vowel(word:\
    \ \"ali\") == \"\")\nassert(get_closest_vowel(word: \"bad\") == \"a\")\nassert(get_closest_vowel(word:\
    \ \"most\") == \"o\")\nassert(get_closest_vowel(word: \"ab\") == \"\")\nassert(get_closest_vowel(word:\
    \ \"ba\") == \"\")\nassert(get_closest_vowel(word: \"quick\") == \"\")\nassert(get_closest_vowel(word:\
    \ \"anime\") == \"i\")\nassert(get_closest_vowel(word: \"Asia\") == \"\")\nassert(get_closest_vowel(word:\
    \ \"Above\") == \"o\")"
  status: Exception
  stderr: 'tmpz8nnkz7u/tmpz8nnkz7u.swift:61: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b57a1d3fc80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b57a1a36b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b57a1a36988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b57a1a357b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpz8nnkz7u                        0x000055e1a4666e5b <unavailable> + 7771

    5    libc.so.6                          0x00002b57a1f2b460 __libc_start_main +
    245

    6    tmpz8nnkz7u                        0x000055e1a4666659 <unavailable> + 5721

    '
  stdout: ''
  timestamp: 1660013568
- exit_code: -4
  program: "\n/// You are given a word. Your task is to find the closest vowel that\
    \ stands between \n/// two consonants from the right side of the word (case sensitive).\n\
    /// Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n/// find any vowel met the above condition. \n/// You may assume that\
    \ the given string contains English letter only.\n/// Example:\n/// >>> get_closest_vowel(word:\
    \ \"yogurt\")\n/// \"u\"\n/// >>> get_closest_vowel(word: \"FULL\")\n/// \"U\"\
    \n/// >>> get_closest_vowel(word: \"quick\")\n/// \"\"\n/// >>> get_closest_vowel(word:\
    \ \"ab\")\n/// \"\"\nfunc get_closest_vowel(word: String) -> String {\n    let\
    \ vowels = \"AEIOU\"\n    var closestVowel: String = \"\"\n    let word_array\
    \ = Array(word)\n    var prevCharIsVowel = false\n    var nextCharIsVowel = false\n\
    \    for (index, char) in word_array.enumerated() {\n        if vowels.contains(char)\
    \ {\n            prevCharIsVowel = true\n            nextCharIsVowel = true\n\
    \            if index > 0 {\n                let prevChar = word_array[index -\
    \ 1]\n                if !vowels.contains(prevChar) {\n                    closestVowel\
    \ = String(char)\n                    break\n                }\n            }\n\
    \            if index < word_array.count - 1 {\n                let nextChar =\
    \ word_array[index + 1]\n                if !vowels.contains(nextChar) {\n   \
    \                 closestVowel = String(char)\n                    break\n   \
    \             }\n            }\n        }\n    }\n    return closestVowel\n}\n\
    \n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(get_closest_vowel(word: \"yogurt\") == \"u\")\n\
    assert(get_closest_vowel(word: \"full\") == \"u\")\nassert(get_closest_vowel(word:\
    \ \"easy\") == \"\")\nassert(get_closest_vowel(word: \"eAsy\") == \"\")\nassert(get_closest_vowel(word:\
    \ \"ali\") == \"\")\nassert(get_closest_vowel(word: \"bad\") == \"a\")\nassert(get_closest_vowel(word:\
    \ \"most\") == \"o\")\nassert(get_closest_vowel(word: \"ab\") == \"\")\nassert(get_closest_vowel(word:\
    \ \"ba\") == \"\")\nassert(get_closest_vowel(word: \"quick\") == \"\")\nassert(get_closest_vowel(word:\
    \ \"anime\") == \"i\")\nassert(get_closest_vowel(word: \"Asia\") == \"\")\nassert(get_closest_vowel(word:\
    \ \"Above\") == \"o\")"
  status: Exception
  stderr: 'tmppt6ho7ft/tmppt6ho7ft.swift:58: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002ac2b231fc80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002ac2b2016b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002ac2b2016988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002ac2b20157b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmppt6ho7ft                        0x000055a90a36f7c7 <unavailable> + 6087

    5    libc.so.6                          0x00002ac2b250b460 __libc_start_main +
    245

    6    tmppt6ho7ft                        0x000055a90a36f409 <unavailable> + 5129

    '
  stdout: ''
  timestamp: 1660013568
- exit_code: 1
  program: "\n/// You are given a word. Your task is to find the closest vowel that\
    \ stands between \n/// two consonants from the right side of the word (case sensitive).\n\
    /// Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n/// find any vowel met the above condition. \n/// You may assume that\
    \ the given string contains English letter only.\n/// Example:\n/// >>> get_closest_vowel(word:\
    \ \"yogurt\")\n/// \"u\"\n/// >>> get_closest_vowel(word: \"FULL\")\n/// \"U\"\
    \n/// >>> get_closest_vowel(word: \"quick\")\n/// \"\"\n/// >>> get_closest_vowel(word:\
    \ \"ab\")\n/// \"\"\nfunc get_closest_vowel(word: String) -> String {\n    var\
    \ vowels = [\"a\", \"e\", \"i\", \"o\", \"u\"]\n    var loop_word = word\n   \
    \ var closest_vowel: String = \"\"\n    let sorted_vowels = vowels.sorted(by:\
    \ {$0.count > $1.count})\n    while loop_word.count > 0 {\n        var loop_char\
    \ = loop_word.last\n        loop_word.removeLast()\n        if loop_char == nil\
    \ { break }\n        if vowels.contains(loop_char!) {\n            if loop_word.count\
    \ > 0 {\n                let before_char = loop_word.last\n                if\
    \ before_char == nil { break }\n                if !vowels.contains(before_char!)\
    \ {\n                    closest_vowel = loop_char!\n                    break\n\
    \                }\n            }\n        }\n    }\n    return closest_vowel\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(get_closest_vowel(word: \"yogurt\") == \"u\")\n\
    assert(get_closest_vowel(word: \"full\") == \"u\")\nassert(get_closest_vowel(word:\
    \ \"easy\") == \"\")\nassert(get_closest_vowel(word: \"eAsy\") == \"\")\nassert(get_closest_vowel(word:\
    \ \"ali\") == \"\")\nassert(get_closest_vowel(word: \"bad\") == \"a\")\nassert(get_closest_vowel(word:\
    \ \"most\") == \"o\")\nassert(get_closest_vowel(word: \"ab\") == \"\")\nassert(get_closest_vowel(word:\
    \ \"ba\") == \"\")\nassert(get_closest_vowel(word: \"quick\") == \"\")\nassert(get_closest_vowel(word:\
    \ \"anime\") == \"i\")\nassert(get_closest_vowel(word: \"Asia\") == \"\")\nassert(get_closest_vowel(word:\
    \ \"Above\") == \"o\")"
  status: SyntaxError
  stderr: "/tmp/tmp5ui5o2zq.swift:25:37: error: cannot convert value of type 'String.Element'\
    \ (aka 'Character') to expected argument type 'String'\n        if vowels.contains(loop_char!)\
    \ {\n                                    ^\n/tmp/tmp5ui5o2zq.swift:29:48: error:\
    \ cannot convert value of type 'String.Element' (aka 'Character') to expected\
    \ argument type 'String'\n                if !vowels.contains(before_char!) {\n\
    \                                               ^\n/tmp/tmp5ui5o2zq.swift:30:46:\
    \ error: cannot assign value of type 'String.Element' (aka 'Character') to type\
    \ 'String'\n                    closest_vowel = loop_char!\n                 \
    \                   ~~~~~~~~~^\n"
  stdout: ''
  timestamp: 1660013567
- exit_code: -4
  program: "\n/// You are given a word. Your task is to find the closest vowel that\
    \ stands between \n/// two consonants from the right side of the word (case sensitive).\n\
    /// Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n/// find any vowel met the above condition. \n/// You may assume that\
    \ the given string contains English letter only.\n/// Example:\n/// >>> get_closest_vowel(word:\
    \ \"yogurt\")\n/// \"u\"\n/// >>> get_closest_vowel(word: \"FULL\")\n/// \"U\"\
    \n/// >>> get_closest_vowel(word: \"quick\")\n/// \"\"\n/// >>> get_closest_vowel(word:\
    \ \"ab\")\n/// \"\"\nfunc get_closest_vowel(word: String) -> String {\n    let\
    \ vowels = [\"a\", \"e\", \"i\", \"o\", \"u\"]\n    var matches = [String]()\n\
    \    var closest_vowel = \"\"\n    for index in 1...word.count-1 {\n        let\
    \ vowel = String(word[word.index(word.startIndex, offsetBy: index)])\n       \
    \ let previous = String(word[word.index(word.startIndex, offsetBy: index-1)])\n\
    \        if vowels.contains(vowel) && !vowels.contains(previous) {\n         \
    \   matches.append(vowel)\n        }\n    }\n    if matches.count == 0 {\n   \
    \     return \"\"\n    }\n    let last_consonant = word.lastIndex(of: \"a\")!\n\
    \    for index in 0...matches.count-1 {\n        let match = word.lastIndex(of:\
    \ Character(matches[index]))!\n        if match > last_consonant {\n         \
    \   closest_vowel = matches[index]\n            break\n        }\n    }\n    return\
    \ closest_vowel\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool\
    \ {\n    if left.count != right.count {\n        return false\n    }\n    for\
    \ (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(get_closest_vowel(word:\
    \ \"yogurt\") == \"u\")\nassert(get_closest_vowel(word: \"full\") == \"u\")\n\
    assert(get_closest_vowel(word: \"easy\") == \"\")\nassert(get_closest_vowel(word:\
    \ \"eAsy\") == \"\")\nassert(get_closest_vowel(word: \"ali\") == \"\")\nassert(get_closest_vowel(word:\
    \ \"bad\") == \"a\")\nassert(get_closest_vowel(word: \"most\") == \"o\")\nassert(get_closest_vowel(word:\
    \ \"ab\") == \"\")\nassert(get_closest_vowel(word: \"ba\") == \"\")\nassert(get_closest_vowel(word:\
    \ \"quick\") == \"\")\nassert(get_closest_vowel(word: \"anime\") == \"i\")\nassert(get_closest_vowel(word:\
    \ \"Asia\") == \"\")\nassert(get_closest_vowel(word: \"Above\") == \"o\")"
  status: Exception
  stderr: 'tmpkdweg7vl/tmpkdweg7vl.swift:30: Fatal error: Unexpectedly found nil while
    unwrapping an Optional value

    Current stack trace:

    0    libswiftCore.so                    0x00002b2efbd8fc80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b2efba86561 <unavailable> + 1434977

    2    libswiftCore.so                    0x00002b2efba86286 <unavailable> + 1434246

    3    libswiftCore.so                    0x00002b2efba8613c <unavailable> + 1433916

    4    libswiftCore.so                    0x00002b2efba85bb0 _assertionFailure(_:_:file:line:flags:)
    + 251

    5    tmpkdweg7vl                        0x0000558afcc5c123 <unavailable> + 12579

    6    tmpkdweg7vl                        0x0000558afcc5ab66 <unavailable> + 7014

    7    libc.so.6                          0x00002b2efbf7b460 __libc_start_main +
    245

    8    tmpkdweg7vl                        0x0000558afcc5a869 <unavailable> + 6249

    '
  stdout: ''
  timestamp: 1660013568
- exit_code: -4
  program: "\n/// You are given a word. Your task is to find the closest vowel that\
    \ stands between \n/// two consonants from the right side of the word (case sensitive).\n\
    /// Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n/// find any vowel met the above condition. \n/// You may assume that\
    \ the given string contains English letter only.\n/// Example:\n/// >>> get_closest_vowel(word:\
    \ \"yogurt\")\n/// \"u\"\n/// >>> get_closest_vowel(word: \"FULL\")\n/// \"U\"\
    \n/// >>> get_closest_vowel(word: \"quick\")\n/// \"\"\n/// >>> get_closest_vowel(word:\
    \ \"ab\")\n/// \"\"\nfunc get_closest_vowel(word: String) -> String {\n    //\
    \ find the closest vowel that stands between two consonants from the right side\
    \ of the word\n    var vowel: String = \"\"\n    let vowels: Set<Character> =\
    \ [\"a\", \"e\", \"i\", \"o\", \"u\"]\n    var wordStart: String = \"\"\n    var\
    \ wordEnd: String = \"\"\n    var isVowelFound: Bool = false\n    var isVowel:\
    \ Bool = false\n    var consonantBeforeVowelFound: Bool = false\n    var consonantAfterVowelFound:\
    \ Bool = false\n    let word_array = Array(word)\n    let word_reverse_array =\
    \ word_array.reversed()\n    for letter in word_reverse_array {\n        if vowels.contains(letter)\
    \ {\n            isVowel = true\n            if isVowelFound == false {\n    \
    \            if consonantBeforeVowelFound && consonantAfterVowelFound {\n    \
    \                isVowelFound = true\n                    vowel = String(letter)\n\
    \                }\n            }\n        } else {\n            if isVowel {\n\
    \                consonantAfterVowelFound = true\n            } else {\n     \
    \           consonantBeforeVowelFound = true\n            }\n        }\n    }\n\
    \    return vowel\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) ->\
    \ Bool {\n    if left.count != right.count {\n        return false\n    }\n  \
    \  for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(get_closest_vowel(word:\
    \ \"yogurt\") == \"u\")\nassert(get_closest_vowel(word: \"full\") == \"u\")\n\
    assert(get_closest_vowel(word: \"easy\") == \"\")\nassert(get_closest_vowel(word:\
    \ \"eAsy\") == \"\")\nassert(get_closest_vowel(word: \"ali\") == \"\")\nassert(get_closest_vowel(word:\
    \ \"bad\") == \"a\")\nassert(get_closest_vowel(word: \"most\") == \"o\")\nassert(get_closest_vowel(word:\
    \ \"ab\") == \"\")\nassert(get_closest_vowel(word: \"ba\") == \"\")\nassert(get_closest_vowel(word:\
    \ \"quick\") == \"\")\nassert(get_closest_vowel(word: \"anime\") == \"i\")\nassert(get_closest_vowel(word:\
    \ \"Asia\") == \"\")\nassert(get_closest_vowel(word: \"Above\") == \"o\")"
  status: Exception
  stderr: 'tmp_vemfcy5/tmp_vemfcy5.swift:61: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b60bcfabc80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b60bcca2b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b60bcca2988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b60bcca17b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmp_vemfcy5                        0x000056132958c907 <unavailable> + 6407

    5    libc.so.6                          0x00002b60bd197460 __libc_start_main +
    245

    6    tmp_vemfcy5                        0x000056132958c549 <unavailable> + 5449

    '
  stdout: ''
  timestamp: 1660013568
- exit_code: -4
  program: "\n/// You are given a word. Your task is to find the closest vowel that\
    \ stands between \n/// two consonants from the right side of the word (case sensitive).\n\
    /// Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n/// find any vowel met the above condition. \n/// You may assume that\
    \ the given string contains English letter only.\n/// Example:\n/// >>> get_closest_vowel(word:\
    \ \"yogurt\")\n/// \"u\"\n/// >>> get_closest_vowel(word: \"FULL\")\n/// \"U\"\
    \n/// >>> get_closest_vowel(word: \"quick\")\n/// \"\"\n/// >>> get_closest_vowel(word:\
    \ \"ab\")\n/// \"\"\nfunc get_closest_vowel(word: String) -> String {\n    //\
    \ Your answer goes here:\n    var vowel : String = \"\"\n    let vowels = [\"\
    a\",\"e\",\"i\",\"o\",\"u\"]\n    var distance = word.count\n    for i in 0...word.count-1{\n\
    \        if vowels.contains(String(word[word.index(word.startIndex, offsetBy:\
    \ i)])) {\n            var left = i-1\n            var right = i+1\n         \
    \   while left >= 0 {\n                if vowels.contains(String(word[word.index(word.startIndex,\
    \ offsetBy: left)])) {\n                    left -= 1\n                } else\
    \ {\n                    break\n                }\n            }\n           \
    \ while right < word.count {\n                if vowels.contains(String(word[word.index(word.startIndex,\
    \ offsetBy: right)])) {\n                    right += 1\n                } else\
    \ {\n                    break\n                }\n            }\n           \
    \ if (right-left-1) < distance && right-left-1 > 1 {\n                distance\
    \ = right-left-1\n                vowel = String(word[word.index(word.startIndex,\
    \ offsetBy: i)])\n            }\n        }\n    }\n    return vowel\n}\n\n\nfunc\
    \ ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count !=\
    \ right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(get_closest_vowel(word: \"yogurt\") == \"u\")\n\
    assert(get_closest_vowel(word: \"full\") == \"u\")\nassert(get_closest_vowel(word:\
    \ \"easy\") == \"\")\nassert(get_closest_vowel(word: \"eAsy\") == \"\")\nassert(get_closest_vowel(word:\
    \ \"ali\") == \"\")\nassert(get_closest_vowel(word: \"bad\") == \"a\")\nassert(get_closest_vowel(word:\
    \ \"most\") == \"o\")\nassert(get_closest_vowel(word: \"ab\") == \"\")\nassert(get_closest_vowel(word:\
    \ \"ba\") == \"\")\nassert(get_closest_vowel(word: \"quick\") == \"\")\nassert(get_closest_vowel(word:\
    \ \"anime\") == \"i\")\nassert(get_closest_vowel(word: \"Asia\") == \"\")\nassert(get_closest_vowel(word:\
    \ \"Above\") == \"o\")"
  status: Exception
  stderr: 'tmpf4pjbdu3/tmpf4pjbdu3.swift:61: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b6b62d79c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b6b62a70b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b6b62a70988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b6b62a6f7b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpf4pjbdu3                        0x0000557875883827 <unavailable> + 6183

    5    libc.so.6                          0x00002b6b62f65460 __libc_start_main +
    245

    6    tmpf4pjbdu3                        0x0000557875883469 <unavailable> + 5225

    '
  stdout: ''
  timestamp: 1660013568
- exit_code: -4
  program: "\n/// You are given a word. Your task is to find the closest vowel that\
    \ stands between \n/// two consonants from the right side of the word (case sensitive).\n\
    /// Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n/// find any vowel met the above condition. \n/// You may assume that\
    \ the given string contains English letter only.\n/// Example:\n/// >>> get_closest_vowel(word:\
    \ \"yogurt\")\n/// \"u\"\n/// >>> get_closest_vowel(word: \"FULL\")\n/// \"U\"\
    \n/// >>> get_closest_vowel(word: \"quick\")\n/// \"\"\n/// >>> get_closest_vowel(word:\
    \ \"ab\")\n/// \"\"\nfunc get_closest_vowel(word: String) -> String {\n    let\
    \ vowels = \"aeiouAEIOU\"\n    let cons = \"bcdfghjklmnpqrstvwxyzBCDFGHJKLMNPQRSTVWXYZ\"\
    \n    var res = \"\"\n    for i in (0..<word.count-1).reversed() {\n        let\
    \ index1 = word.index(word.startIndex, offsetBy: i)\n        let index2 = word.index(word.startIndex,\
    \ offsetBy: i+1)\n        if cons.contains(word[index1]) && cons.contains(word[index2])\
    \ {\n            for j in i+1..<word.count {\n                let index3 = word.index(word.startIndex,\
    \ offsetBy: j)\n                if vowels.contains(word[index3]) {\n         \
    \           res += String(word[index3])\n                    break\n         \
    \       }\n            }\n            break\n        }\n    }\n    return res\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(get_closest_vowel(word: \"yogurt\") == \"u\")\n\
    assert(get_closest_vowel(word: \"full\") == \"u\")\nassert(get_closest_vowel(word:\
    \ \"easy\") == \"\")\nassert(get_closest_vowel(word: \"eAsy\") == \"\")\nassert(get_closest_vowel(word:\
    \ \"ali\") == \"\")\nassert(get_closest_vowel(word: \"bad\") == \"a\")\nassert(get_closest_vowel(word:\
    \ \"most\") == \"o\")\nassert(get_closest_vowel(word: \"ab\") == \"\")\nassert(get_closest_vowel(word:\
    \ \"ba\") == \"\")\nassert(get_closest_vowel(word: \"quick\") == \"\")\nassert(get_closest_vowel(word:\
    \ \"anime\") == \"i\")\nassert(get_closest_vowel(word: \"Asia\") == \"\")\nassert(get_closest_vowel(word:\
    \ \"Above\") == \"o\")"
  status: Exception
  stderr: 'tmpu8llmt5s/tmpu8llmt5s.swift:50: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002abf880b9c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002abf87db0b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002abf87db0988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002abf87daf7b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpu8llmt5s                        0x000055ef04d3aa77 <unavailable> + 6775

    5    libc.so.6                          0x00002abf882a5460 __libc_start_main +
    245

    6    tmpu8llmt5s                        0x000055ef04d3a6b9 <unavailable> + 5817

    '
  stdout: ''
  timestamp: 1660013568
- exit_code: -4
  program: "\n/// You are given a word. Your task is to find the closest vowel that\
    \ stands between \n/// two consonants from the right side of the word (case sensitive).\n\
    /// Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n/// find any vowel met the above condition. \n/// You may assume that\
    \ the given string contains English letter only.\n/// Example:\n/// >>> get_closest_vowel(word:\
    \ \"yogurt\")\n/// \"u\"\n/// >>> get_closest_vowel(word: \"FULL\")\n/// \"U\"\
    \n/// >>> get_closest_vowel(word: \"quick\")\n/// \"\"\n/// >>> get_closest_vowel(word:\
    \ \"ab\")\n/// \"\"\nfunc get_closest_vowel(word: String) -> String {\n    let\
    \ vowels = \"aeiouAEIOU\"\n    let consonants = \"bcdfghjklmnpqrstvwxyzBCDFGHJKLMNPQRSTVWXYZ\"\
    \n    var firstVowel = \"\"\n    var closestVowel = \"\"\n    var previous_character\
    \ = \"\"\n    var current_character = \"\"\n    var next_character = \"\"\n  \
    \  var index = 0\n    var found_vowel = false\n    var found_consonant = false\n\
    \    // Find first vowel\n    for character in word {\n        if vowels.contains(character)\
    \ {\n            firstVowel = String(character)\n            found_vowel = true\n\
    \            break\n        }\n    }\n    // If no vowel found, return empty string\n\
    \    if found_vowel == false {\n        return \"\"\n    }\n    // If no consonant\
    \ found in first position, return first vowel\n    if word.index(of: word[word.startIndex])\
    \ == nil {\n        return firstVowel\n    }\n    // Loop through the word to\
    \ find closest vowel\n    while index < word.count {\n        if index < word.count\
    \ - 1 {\n            current_character = String(word[word.index(word.startIndex,\
    \ offsetBy: index)])\n            next_character = String(word[word.index(word.startIndex,\
    \ offsetBy: index + 1)])\n        }\n        // Reset closest vowel if consonant\
    \ is found\n        if consonants.contains(current_character) {\n            found_consonant\
    \ = true\n            closestVowel = \"\"\n        }\n        // Save vowel if\
    \ found after consonant\n        if found_consonant && vowels.contains(current_character)\
    \ {\n            closestVowel = current_character\n        }\n        // If vowel\
    \ found, and it is the closest to the end, return it\n        if found_consonant\
    \ && closestVowel != \"\" &&\n            !vowels.contains(next_character) {\n\
    \            return closestVowel\n        }\n        index += 1\n    }\n    return\
    \ closestVowel\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool\
    \ {\n    if left.count != right.count {\n        return false\n    }\n    for\
    \ (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(get_closest_vowel(word:\
    \ \"yogurt\") == \"u\")\nassert(get_closest_vowel(word: \"full\") == \"u\")\n\
    assert(get_closest_vowel(word: \"easy\") == \"\")\nassert(get_closest_vowel(word:\
    \ \"eAsy\") == \"\")\nassert(get_closest_vowel(word: \"ali\") == \"\")\nassert(get_closest_vowel(word:\
    \ \"bad\") == \"a\")\nassert(get_closest_vowel(word: \"most\") == \"o\")\nassert(get_closest_vowel(word:\
    \ \"ab\") == \"\")\nassert(get_closest_vowel(word: \"ba\") == \"\")\nassert(get_closest_vowel(word:\
    \ \"quick\") == \"\")\nassert(get_closest_vowel(word: \"anime\") == \"i\")\nassert(get_closest_vowel(word:\
    \ \"Asia\") == \"\")\nassert(get_closest_vowel(word: \"Above\") == \"o\")"
  status: Exception
  stderr: 'tmp8qt5qjxl/tmp8qt5qjxl.swift:81: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b5708a43c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b570873ab6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b570873a988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b57087397b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmp8qt5qjxl                        0x000056107b8427d7 <unavailable> + 6103

    5    libc.so.6                          0x00002b5708c2f460 __libc_start_main +
    245

    6    tmp8qt5qjxl                        0x000056107b842419 <unavailable> + 5145

    '
  stdout: ''
  timestamp: 1660013568
- exit_code: 1
  program: "\n/// You are given a word. Your task is to find the closest vowel that\
    \ stands between \n/// two consonants from the right side of the word (case sensitive).\n\
    /// Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n/// find any vowel met the above condition. \n/// You may assume that\
    \ the given string contains English letter only.\n/// Example:\n/// >>> get_closest_vowel(word:\
    \ \"yogurt\")\n/// \"u\"\n/// >>> get_closest_vowel(word: \"FULL\")\n/// \"U\"\
    \n/// >>> get_closest_vowel(word: \"quick\")\n/// \"\"\n/// >>> get_closest_vowel(word:\
    \ \"ab\")\n/// \"\"\nfunc get_closest_vowel(word: String) -> String {\n\t\n\t\
    let vowels = \"aeiou\"\n\tlet consonents = \"bcdfghjklmnpqrstvwxyz\"\n\tvar indexOfVowel\
    \ : Int = 0\n\tvar count : Int = 0\n\tvar temp : Int = 0\n\tvar found : Bool =\
    \ false\n\tfor char in word.characters.reversed() {\n\t\tif vowels.contains(char)\
    \ {\n\t\t\tif found {\n\t\t\t\tbreak\n\t\t\t}\n\t\t\tcount = 0\n\t\t\tindexOfVowel\
    \ = temp\n\t\t} else if consonents.contains(char) {\n\t\t\tcount += 1\n\t\t\t\
    if count == 2 {\n\t\t\t\tfound = true\n\t\t\t}\n\t\t}\n\t\ttemp += 1\n\t}\n\t\n\
    \tif !found {\n\t\treturn \"\"\n\t}\n\t\n\treturn String(word.characters.suffix(from:\
    \ word.index(word.startIndex, offsetBy: indexOfVowel)))\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(get_closest_vowel(word: \"yogurt\") == \"u\")\nassert(get_closest_vowel(word:\
    \ \"full\") == \"u\")\nassert(get_closest_vowel(word: \"easy\") == \"\")\nassert(get_closest_vowel(word:\
    \ \"eAsy\") == \"\")\nassert(get_closest_vowel(word: \"ali\") == \"\")\nassert(get_closest_vowel(word:\
    \ \"bad\") == \"a\")\nassert(get_closest_vowel(word: \"most\") == \"o\")\nassert(get_closest_vowel(word:\
    \ \"ab\") == \"\")\nassert(get_closest_vowel(word: \"ba\") == \"\")\nassert(get_closest_vowel(word:\
    \ \"quick\") == \"\")\nassert(get_closest_vowel(word: \"anime\") == \"i\")\nassert(get_closest_vowel(word:\
    \ \"Asia\") == \"\")\nassert(get_closest_vowel(word: \"Above\") == \"o\")"
  status: SyntaxError
  stderr: "/tmp/tmpovobqt0z.swift:24:19: error: 'characters' is unavailable: Please\
    \ use String directly\n        for char in word.characters.reversed() {\n    \
    \                     ^~~~~~~~~~\nSwift.String:5:16: note: 'characters' was obsoleted\
    \ in Swift 5.0\n    public var characters: String { get set }\n              \
    \ ^\n/tmp/tmpovobqt0z.swift:44:21: error: 'characters' is unavailable: Please\
    \ use String directly\n        return String(word.characters.suffix(from: word.index(word.startIndex,\
    \ offsetBy: indexOfVowel)))\n                           ^~~~~~~~~~\nSwift.String:5:16:\
    \ note: 'characters' was obsoleted in Swift 5.0\n    public var characters: String\
    \ { get set }\n               ^\n"
  stdout: ''
  timestamp: 1660013568
- exit_code: 1
  program: "\n/// You are given a word. Your task is to find the closest vowel that\
    \ stands between \n/// two consonants from the right side of the word (case sensitive).\n\
    /// Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n/// find any vowel met the above condition. \n/// You may assume that\
    \ the given string contains English letter only.\n/// Example:\n/// >>> get_closest_vowel(word:\
    \ \"yogurt\")\n/// \"u\"\n/// >>> get_closest_vowel(word: \"FULL\")\n/// \"U\"\
    \n/// >>> get_closest_vowel(word: \"quick\")\n/// \"\"\n/// >>> get_closest_vowel(word:\
    \ \"ab\")\n/// \"\"\nfunc get_closest_vowel(word: String) -> String {\n    let\
    \ vowel = \"aeiouAEIOU\"\n    let consonant = \"bcdfghjklmnpqrstvwxyzBCDFGHJKLMNPQRSTVWXYZ\"\
    \n    let front = word.components(separatedBy: consonant)\n    let back = front.filter{$0\
    \ != \"\"}\n    let back2 = back.filter{vowel.contains($0.first!)}\n    if back2.count\
    \ > 0 {\n        return back2.last!\n    }\n    return \"\"\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(get_closest_vowel(word: \"yogurt\") == \"u\")\nassert(get_closest_vowel(word:\
    \ \"full\") == \"u\")\nassert(get_closest_vowel(word: \"easy\") == \"\")\nassert(get_closest_vowel(word:\
    \ \"eAsy\") == \"\")\nassert(get_closest_vowel(word: \"ali\") == \"\")\nassert(get_closest_vowel(word:\
    \ \"bad\") == \"a\")\nassert(get_closest_vowel(word: \"most\") == \"o\")\nassert(get_closest_vowel(word:\
    \ \"ab\") == \"\")\nassert(get_closest_vowel(word: \"ba\") == \"\")\nassert(get_closest_vowel(word:\
    \ \"quick\") == \"\")\nassert(get_closest_vowel(word: \"anime\") == \"i\")\nassert(get_closest_vowel(word:\
    \ \"Asia\") == \"\")\nassert(get_closest_vowel(word: \"Above\") == \"o\")"
  status: SyntaxError
  stderr: "/tmp/tmp9jduqh3b.swift:19:22: error: value of type 'String' has no member\
    \ 'components'\n    let front = word.components(separatedBy: consonant)\n    \
    \            ~~~~ ^~~~~~~~~~\n"
  stdout: ''
  timestamp: 1660013568
- exit_code: -4
  program: "\n/// You are given a word. Your task is to find the closest vowel that\
    \ stands between \n/// two consonants from the right side of the word (case sensitive).\n\
    /// Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n/// find any vowel met the above condition. \n/// You may assume that\
    \ the given string contains English letter only.\n/// Example:\n/// >>> get_closest_vowel(word:\
    \ \"yogurt\")\n/// \"u\"\n/// >>> get_closest_vowel(word: \"FULL\")\n/// \"U\"\
    \n/// >>> get_closest_vowel(word: \"quick\")\n/// \"\"\n/// >>> get_closest_vowel(word:\
    \ \"ab\")\n/// \"\"\nfunc get_closest_vowel(word: String) -> String {\n    //\
    \ Write your code here!\n    return \"\"\n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(get_closest_vowel(word: \"yogurt\") == \"u\")\nassert(get_closest_vowel(word:\
    \ \"full\") == \"u\")\nassert(get_closest_vowel(word: \"easy\") == \"\")\nassert(get_closest_vowel(word:\
    \ \"eAsy\") == \"\")\nassert(get_closest_vowel(word: \"ali\") == \"\")\nassert(get_closest_vowel(word:\
    \ \"bad\") == \"a\")\nassert(get_closest_vowel(word: \"most\") == \"o\")\nassert(get_closest_vowel(word:\
    \ \"ab\") == \"\")\nassert(get_closest_vowel(word: \"ba\") == \"\")\nassert(get_closest_vowel(word:\
    \ \"quick\") == \"\")\nassert(get_closest_vowel(word: \"anime\") == \"i\")\nassert(get_closest_vowel(word:\
    \ \"Asia\") == \"\")\nassert(get_closest_vowel(word: \"Above\") == \"o\")"
  status: Exception
  stderr: 'tmpjr64m24q/tmpjr64m24q.swift:34: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002ac838063c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002ac837d5ab6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002ac837d5a988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002ac837d597b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpjr64m24q                        0x0000556b4f90e307 <unavailable> + 4871

    5    libc.so.6                          0x00002ac83824f460 __libc_start_main +
    245

    6    tmpjr64m24q                        0x0000556b4f90df49 <unavailable> + 3913

    '
  stdout: ''
  timestamp: 1660013568
- exit_code: 1
  program: "\n/// You are given a word. Your task is to find the closest vowel that\
    \ stands between \n/// two consonants from the right side of the word (case sensitive).\n\
    /// Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n/// find any vowel met the above condition. \n/// You may assume that\
    \ the given string contains English letter only.\n/// Example:\n/// >>> get_closest_vowel(word:\
    \ \"yogurt\")\n/// \"u\"\n/// >>> get_closest_vowel(word: \"FULL\")\n/// \"U\"\
    \n/// >>> get_closest_vowel(word: \"quick\")\n/// \"\"\n/// >>> get_closest_vowel(word:\
    \ \"ab\")\n/// \"\"\nfunc get_closest_vowel(word: String) -> String {\n    let\
    \ vowels = \"aeiou\"\n    let consonants = \"bcdfghjklmnpqrstvwxyz\"\n    var\
    \ closestVowel = \"\"\n    for char in word.characters {\n        if consonants.contains(char)\
    \ {\n            for vowel in vowels.characters {\n                if word.contains(vowel)\
    \ {\n                    closestVowel = String(vowel)\n                }\n   \
    \         }\n        }\n    }\n    return closestVowel\n}\n\n\nfunc ==(left: [(Int,\
    \ Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n\
    \        return false\n    }\n    for (l, r) in zip(left, right) {\n        if\
    \ l != r {\n            return false\n        }\n    }\n    return true\n}\n \
    \           \nassert(get_closest_vowel(word: \"yogurt\") == \"u\")\nassert(get_closest_vowel(word:\
    \ \"full\") == \"u\")\nassert(get_closest_vowel(word: \"easy\") == \"\")\nassert(get_closest_vowel(word:\
    \ \"eAsy\") == \"\")\nassert(get_closest_vowel(word: \"ali\") == \"\")\nassert(get_closest_vowel(word:\
    \ \"bad\") == \"a\")\nassert(get_closest_vowel(word: \"most\") == \"o\")\nassert(get_closest_vowel(word:\
    \ \"ab\") == \"\")\nassert(get_closest_vowel(word: \"ba\") == \"\")\nassert(get_closest_vowel(word:\
    \ \"quick\") == \"\")\nassert(get_closest_vowel(word: \"anime\") == \"i\")\nassert(get_closest_vowel(word:\
    \ \"Asia\") == \"\")\nassert(get_closest_vowel(word: \"Above\") == \"o\")"
  status: SyntaxError
  stderr: "/tmp/tmphxri9lkh.swift:20:22: error: 'characters' is unavailable: Please\
    \ use String directly\n    for char in word.characters {\n                   \
    \  ^~~~~~~~~~\nSwift.String:5:16: note: 'characters' was obsoleted in Swift 5.0\n\
    \    public var characters: String { get set }\n               ^\n/tmp/tmphxri9lkh.swift:22:33:\
    \ error: 'characters' is unavailable: Please use String directly\n           \
    \ for vowel in vowels.characters {\n                                ^~~~~~~~~~\n\
    Swift.String:5:16: note: 'characters' was obsoleted in Swift 5.0\n    public var\
    \ characters: String { get set }\n               ^\n"
  stdout: ''
  timestamp: 1660013568
- exit_code: 1
  program: "\n/// You are given a word. Your task is to find the closest vowel that\
    \ stands between \n/// two consonants from the right side of the word (case sensitive).\n\
    /// Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n/// find any vowel met the above condition. \n/// You may assume that\
    \ the given string contains English letter only.\n/// Example:\n/// >>> get_closest_vowel(word:\
    \ \"yogurt\")\n/// \"u\"\n/// >>> get_closest_vowel(word: \"FULL\")\n/// \"U\"\
    \n/// >>> get_closest_vowel(word: \"quick\")\n/// \"\"\n/// >>> get_closest_vowel(word:\
    \ \"ab\")\n/// \"\"\nfunc get_closest_vowel(word: String) -> String {\n    let\
    \ consonants = \"bcdfghjklmnpqrstvwxyz\"\n    let vowels = \"aeiou\"\n    var\
    \ vowelIndex = -1\n    var consIndex = -1\n    for (index, char) in word.characters.enumerated()\
    \ {\n        if vowels.contains(char) {\n            vowelIndex = index\n    \
    \    }\n        if consonants.contains(char) {\n            consIndex = index\n\
    \        }\n        if vowelIndex > -1 && consIndex > -1 && consIndex > vowelIndex\
    \ {\n            return String(char)\n        }\n    }\n    return \"\"\n}\n\n\
    \nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(get_closest_vowel(word: \"yogurt\") == \"u\")\n\
    assert(get_closest_vowel(word: \"full\") == \"u\")\nassert(get_closest_vowel(word:\
    \ \"easy\") == \"\")\nassert(get_closest_vowel(word: \"eAsy\") == \"\")\nassert(get_closest_vowel(word:\
    \ \"ali\") == \"\")\nassert(get_closest_vowel(word: \"bad\") == \"a\")\nassert(get_closest_vowel(word:\
    \ \"most\") == \"o\")\nassert(get_closest_vowel(word: \"ab\") == \"\")\nassert(get_closest_vowel(word:\
    \ \"ba\") == \"\")\nassert(get_closest_vowel(word: \"quick\") == \"\")\nassert(get_closest_vowel(word:\
    \ \"anime\") == \"i\")\nassert(get_closest_vowel(word: \"Asia\") == \"\")\nassert(get_closest_vowel(word:\
    \ \"Above\") == \"o\")"
  status: SyntaxError
  stderr: "/tmp/tmpehfcbfzz.swift:21:31: error: 'characters' is unavailable: Please\
    \ use String directly\n    for (index, char) in word.characters.enumerated() {\n\
    \                              ^~~~~~~~~~\nSwift.String:5:16: note: 'characters'\
    \ was obsoleted in Swift 5.0\n    public var characters: String { get set }\n\
    \               ^\n"
  stdout: ''
  timestamp: 1660013568
- exit_code: -4
  program: "\n/// You are given a word. Your task is to find the closest vowel that\
    \ stands between \n/// two consonants from the right side of the word (case sensitive).\n\
    /// Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n/// find any vowel met the above condition. \n/// You may assume that\
    \ the given string contains English letter only.\n/// Example:\n/// >>> get_closest_vowel(word:\
    \ \"yogurt\")\n/// \"u\"\n/// >>> get_closest_vowel(word: \"FULL\")\n/// \"U\"\
    \n/// >>> get_closest_vowel(word: \"quick\")\n/// \"\"\n/// >>> get_closest_vowel(word:\
    \ \"ab\")\n/// \"\"\nfunc get_closest_vowel(word: String) -> String {\n    let\
    \ vowels = \"aeiouAEIOU\"\n    let consonants = \"bcdfghjklmnpqrstvwxyzBCDFGHJKLMNPQRSTVWXYZ\"\
    \n    var result = \"\"\n    var found = false\n    for i in word.indices.reversed()\
    \ {\n        let index = word.index(after: i)\n        if !found && vowels.contains(word[i])\
    \ {\n            result = String(word[i])\n            found = true\n        }\n\
    \        if found && consonants.contains(word[index]) {\n            return result\n\
    \        }\n    }\n    return \"\"\n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(get_closest_vowel(word: \"yogurt\") == \"u\")\nassert(get_closest_vowel(word:\
    \ \"full\") == \"u\")\nassert(get_closest_vowel(word: \"easy\") == \"\")\nassert(get_closest_vowel(word:\
    \ \"eAsy\") == \"\")\nassert(get_closest_vowel(word: \"ali\") == \"\")\nassert(get_closest_vowel(word:\
    \ \"bad\") == \"a\")\nassert(get_closest_vowel(word: \"most\") == \"o\")\nassert(get_closest_vowel(word:\
    \ \"ab\") == \"\")\nassert(get_closest_vowel(word: \"ba\") == \"\")\nassert(get_closest_vowel(word:\
    \ \"quick\") == \"\")\nassert(get_closest_vowel(word: \"anime\") == \"i\")\nassert(get_closest_vowel(word:\
    \ \"Asia\") == \"\")\nassert(get_closest_vowel(word: \"Above\") == \"o\")"
  status: Exception
  stderr: 'tmpc919lahk/tmpc919lahk.swift:49: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b2ce0ccfc80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b2ce09c6b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b2ce09c6988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b2ce09c57b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpc919lahk                        0x00005561ca01fa53 <unavailable> + 6739

    5    libc.so.6                          0x00002b2ce0ebb460 __libc_start_main +
    245

    6    tmpc919lahk                        0x00005561ca01f489 <unavailable> + 5257

    '
  stdout: ''
  timestamp: 1660013568
- exit_code: -4
  program: "\n/// You are given a word. Your task is to find the closest vowel that\
    \ stands between \n/// two consonants from the right side of the word (case sensitive).\n\
    /// Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n/// find any vowel met the above condition. \n/// You may assume that\
    \ the given string contains English letter only.\n/// Example:\n/// >>> get_closest_vowel(word:\
    \ \"yogurt\")\n/// \"u\"\n/// >>> get_closest_vowel(word: \"FULL\")\n/// \"U\"\
    \n/// >>> get_closest_vowel(word: \"quick\")\n/// \"\"\n/// >>> get_closest_vowel(word:\
    \ \"ab\")\n/// \"\"\nfunc get_closest_vowel(word: String) -> String {\n\tlet vowels\
    \ = [\"a\", \"e\", \"i\", \"o\", \"u\"]\n\tvar found = \"\"\n\tfor i in 0..<word.count\
    \ {\n\t\tlet index = word.index(word.endIndex, offsetBy: -i - 1)\n\t\tlet cur\
    \ = String(word[index])\n\t\tif vowels.contains(cur) {\n\t\t\tfound = cur\n\t\t\
    } else if found != \"\" {\n\t\t\treturn found\n\t\t}\n\t}\n\treturn \"\"\n}\n\n\
    \nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(get_closest_vowel(word: \"yogurt\") == \"u\")\n\
    assert(get_closest_vowel(word: \"full\") == \"u\")\nassert(get_closest_vowel(word:\
    \ \"easy\") == \"\")\nassert(get_closest_vowel(word: \"eAsy\") == \"\")\nassert(get_closest_vowel(word:\
    \ \"ali\") == \"\")\nassert(get_closest_vowel(word: \"bad\") == \"a\")\nassert(get_closest_vowel(word:\
    \ \"most\") == \"o\")\nassert(get_closest_vowel(word: \"ab\") == \"\")\nassert(get_closest_vowel(word:\
    \ \"ba\") == \"\")\nassert(get_closest_vowel(word: \"quick\") == \"\")\nassert(get_closest_vowel(word:\
    \ \"anime\") == \"i\")\nassert(get_closest_vowel(word: \"Asia\") == \"\")\nassert(get_closest_vowel(word:\
    \ \"Above\") == \"o\")"
  status: Exception
  stderr: 'tmpz7916axb/tmpz7916axb.swift:48: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b790ed8ac80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b790ea81b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b790ea81988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b790ea807b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpz7916axb                        0x000055c4b3d9ac6b <unavailable> + 7275

    5    libc.so.6                          0x00002b790ef76460 __libc_start_main +
    245

    6    tmpz7916axb                        0x000055c4b3d9a469 <unavailable> + 5225

    '
  stdout: ''
  timestamp: 1660013568
- exit_code: -4
  program: "\n/// You are given a word. Your task is to find the closest vowel that\
    \ stands between \n/// two consonants from the right side of the word (case sensitive).\n\
    /// Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n/// find any vowel met the above condition. \n/// You may assume that\
    \ the given string contains English letter only.\n/// Example:\n/// >>> get_closest_vowel(word:\
    \ \"yogurt\")\n/// \"u\"\n/// >>> get_closest_vowel(word: \"FULL\")\n/// \"U\"\
    \n/// >>> get_closest_vowel(word: \"quick\")\n/// \"\"\n/// >>> get_closest_vowel(word:\
    \ \"ab\")\n/// \"\"\nfunc get_closest_vowel(word: String) -> String {\n    //\
    \ TODO: implement your solution here\n    fatalError(\"TODO: implement your solution\
    \ here\")\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n\
    \    if left.count != right.count {\n        return false\n    }\n    for (l,\
    \ r) in zip(left, right) {\n        if l != r {\n            return false\n  \
    \      }\n    }\n    return true\n}\n            \nassert(get_closest_vowel(word:\
    \ \"yogurt\") == \"u\")\nassert(get_closest_vowel(word: \"full\") == \"u\")\n\
    assert(get_closest_vowel(word: \"easy\") == \"\")\nassert(get_closest_vowel(word:\
    \ \"eAsy\") == \"\")\nassert(get_closest_vowel(word: \"ali\") == \"\")\nassert(get_closest_vowel(word:\
    \ \"bad\") == \"a\")\nassert(get_closest_vowel(word: \"most\") == \"o\")\nassert(get_closest_vowel(word:\
    \ \"ab\") == \"\")\nassert(get_closest_vowel(word: \"ba\") == \"\")\nassert(get_closest_vowel(word:\
    \ \"quick\") == \"\")\nassert(get_closest_vowel(word: \"anime\") == \"i\")\nassert(get_closest_vowel(word:\
    \ \"Asia\") == \"\")\nassert(get_closest_vowel(word: \"Above\") == \"o\")"
  status: Exception
  stderr: 'tmpxozgb7lw/tmpxozgb7lw.swift:18: Fatal error: TODO: implement your solution
    here

    Current stack trace:

    0    libswiftCore.so                    0x00002b2924963c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b292465ab6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b292465a988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b29246597b0 _assertionFailure(_:_:file:line:flags:)
    + 365

    4    tmpxozgb7lw                        0x00005556f46cb0d8 <unavailable> + 8408

    5    tmpxozgb7lw                        0x00005556f46ca246 <unavailable> + 4678

    6    libc.so.6                          0x00002b2924b4f460 __libc_start_main +
    245

    7    tmpxozgb7lw                        0x00005556f46c9f49 <unavailable> + 3913

    '
  stdout: ''
  timestamp: 1660013568
- exit_code: -4
  program: "\n/// You are given a word. Your task is to find the closest vowel that\
    \ stands between \n/// two consonants from the right side of the word (case sensitive).\n\
    /// Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n/// find any vowel met the above condition. \n/// You may assume that\
    \ the given string contains English letter only.\n/// Example:\n/// >>> get_closest_vowel(word:\
    \ \"yogurt\")\n/// \"u\"\n/// >>> get_closest_vowel(word: \"FULL\")\n/// \"U\"\
    \n/// >>> get_closest_vowel(word: \"quick\")\n/// \"\"\n/// >>> get_closest_vowel(word:\
    \ \"ab\")\n/// \"\"\nfunc get_closest_vowel(word: String) -> String {\n    let\
    \ letters = Array(word)\n    let vowels = \"aeiouAEIOU\"\n    var prevVowel =\
    \ \"\"\n    var nextVowel = \"\"\n    var prevConsonant = \"\"\n    var nextConsonant\
    \ = \"\"\n    var minDistance = word.count\n    var result = \"\"\n    for index\
    \ in 0..<letters.count {\n        let l = String(letters[index])\n        if vowels.contains(l)\
    \ {\n            if prevConsonant != \"\" {\n                let currentDistance\
    \ = letters.count - index\n                if currentDistance < minDistance {\n\
    \                    result = l\n                    minDistance = currentDistance\n\
    \                }\n            }\n            prevVowel = l\n        } else {\n\
    \            if prevVowel != \"\" {\n                nextConsonant = l\n     \
    \       }\n            prevConsonant = l\n        }\n    }\n    return result\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(get_closest_vowel(word: \"yogurt\") == \"u\")\n\
    assert(get_closest_vowel(word: \"full\") == \"u\")\nassert(get_closest_vowel(word:\
    \ \"easy\") == \"\")\nassert(get_closest_vowel(word: \"eAsy\") == \"\")\nassert(get_closest_vowel(word:\
    \ \"ali\") == \"\")\nassert(get_closest_vowel(word: \"bad\") == \"a\")\nassert(get_closest_vowel(word:\
    \ \"most\") == \"o\")\nassert(get_closest_vowel(word: \"ab\") == \"\")\nassert(get_closest_vowel(word:\
    \ \"ba\") == \"\")\nassert(get_closest_vowel(word: \"quick\") == \"\")\nassert(get_closest_vowel(word:\
    \ \"anime\") == \"i\")\nassert(get_closest_vowel(word: \"Asia\") == \"\")\nassert(get_closest_vowel(word:\
    \ \"Above\") == \"o\")"
  status: Exception
  stderr: 'tmp7paks5do/tmp7paks5do.swift:63: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b5e11753c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b5e1144ab6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b5e1144a988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b5e114497b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmp7paks5do                        0x0000556df5355bdb <unavailable> + 7131

    5    libc.so.6                          0x00002b5e1193f460 __libc_start_main +
    245

    6    tmp7paks5do                        0x0000556df53553d9 <unavailable> + 5081

    '
  stdout: ''
  timestamp: 1660013568
- exit_code: -4
  program: "\n/// You are given a word. Your task is to find the closest vowel that\
    \ stands between \n/// two consonants from the right side of the word (case sensitive).\n\
    /// Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n/// find any vowel met the above condition. \n/// You may assume that\
    \ the given string contains English letter only.\n/// Example:\n/// >>> get_closest_vowel(word:\
    \ \"yogurt\")\n/// \"u\"\n/// >>> get_closest_vowel(word: \"FULL\")\n/// \"U\"\
    \n/// >>> get_closest_vowel(word: \"quick\")\n/// \"\"\n/// >>> get_closest_vowel(word:\
    \ \"ab\")\n/// \"\"\nfunc get_closest_vowel(word: String) -> String {\n    let\
    \ vowels = Set(\"aeiouAEIOU\")\n    let constant = Set(\"bcdfghjklmnpqrstvwxyzBCDFGHJKLMNPQRSTVWXYZ\"\
    )\n    let count = word.count\n    var closest_vowel = \"\"\n    for i in 1...count\
    \ {\n        let index = word.index(word.endIndex, offsetBy: -i)\n        let\
    \ key = word[index]\n        if vowels.contains(key) {\n            closest_vowel\
    \ = String(key)\n            break\n        }\n    }\n    let closest_vowel_index\
    \ = word.firstIndex(of: Character(closest_vowel))\n    if closest_vowel_index\
    \ == nil {\n        return \"\"\n    }\n    let right_to_closest_vowel = word[word.index(after:\
    \ closest_vowel_index!)...]\n    let right_to_closest_vowel_string = String(right_to_closest_vowel)\n\
    \    for i in 0..<right_to_closest_vowel_string.count {\n        let key = right_to_closest_vowel_string[right_to_closest_vowel_string.index(right_to_closest_vowel_string.startIndex,\
    \ offsetBy: i)]\n        if constant.contains(key) {\n            return closest_vowel\n\
    \        }\n    }\n    return \"\"\n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(get_closest_vowel(word: \"yogurt\") == \"u\")\nassert(get_closest_vowel(word:\
    \ \"full\") == \"u\")\nassert(get_closest_vowel(word: \"easy\") == \"\")\nassert(get_closest_vowel(word:\
    \ \"eAsy\") == \"\")\nassert(get_closest_vowel(word: \"ali\") == \"\")\nassert(get_closest_vowel(word:\
    \ \"bad\") == \"a\")\nassert(get_closest_vowel(word: \"most\") == \"o\")\nassert(get_closest_vowel(word:\
    \ \"ab\") == \"\")\nassert(get_closest_vowel(word: \"ba\") == \"\")\nassert(get_closest_vowel(word:\
    \ \"quick\") == \"\")\nassert(get_closest_vowel(word: \"anime\") == \"i\")\nassert(get_closest_vowel(word:\
    \ \"Asia\") == \"\")\nassert(get_closest_vowel(word: \"Above\") == \"o\")"
  status: Exception
  stderr: 'tmpp1n88ojt/tmpp1n88ojt.swift:59: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b75dc582c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b75dc279b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b75dc279988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b75dc2787b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpp1n88ojt                        0x0000557123768e83 <unavailable> + 7811

    5    libc.so.6                          0x00002b75dc76e460 __libc_start_main +
    245

    6    tmpp1n88ojt                        0x00005571237688b9 <unavailable> + 6329

    '
  stdout: ''
  timestamp: 1660013568
- exit_code: -4
  program: "\n/// You are given a word. Your task is to find the closest vowel that\
    \ stands between \n/// two consonants from the right side of the word (case sensitive).\n\
    /// Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n/// find any vowel met the above condition. \n/// You may assume that\
    \ the given string contains English letter only.\n/// Example:\n/// >>> get_closest_vowel(word:\
    \ \"yogurt\")\n/// \"u\"\n/// >>> get_closest_vowel(word: \"FULL\")\n/// \"U\"\
    \n/// >>> get_closest_vowel(word: \"quick\")\n/// \"\"\n/// >>> get_closest_vowel(word:\
    \ \"ab\")\n/// \"\"\nfunc get_closest_vowel(word: String) -> String {\n    let\
    \ vowels = [\"a\", \"e\", \"i\", \"o\", \"u\"]\n    var vowelsFound = [Int]()\n\
    \    var counter = 0\n    for character in word {\n        let index = word.index(word.startIndex,\
    \ offsetBy: counter)\n        let letter = word[index]\n        let stringLetter\
    \ = String(letter)\n        if vowels.contains(stringLetter) {\n            vowelsFound.append(counter)\n\
    \        }\n        counter += 1\n    }\n    if vowelsFound.count == 0 {\n   \
    \     return \"\"\n    }\n    var maxValid = vowelsFound.count - 1\n    for index\
    \ in (0...vowelsFound.count - 1).reversed() {\n        let location = vowelsFound[index]\n\
    \        if location < word.count - 1 {\n            let nextLetter = word[word.index(word.startIndex,\
    \ offsetBy: location + 1)]\n            if !vowels.contains(String(nextLetter))\
    \ {\n                maxValid = index\n                break\n            }\n\
    \        }\n    }\n    var minValid = 0\n    for index in 0...vowelsFound.count\
    \ - 1 {\n        let location = vowelsFound[index]\n        if location > 0 {\n\
    \            let prevLetter = word[word.index(word.startIndex, offsetBy: location\
    \ - 1)]\n            if !vowels.contains(String(prevLetter)) {\n             \
    \   minValid = index\n                break\n            }\n        }\n    }\n\
    \    if maxValid < minValid {\n        return \"\"\n    }\n    let closest = vowelsFound[maxValid]\n\
    \    let closestLetter = word[word.index(word.startIndex, offsetBy: closest)]\n\
    \    return String(closestLetter)\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int,\
    \ Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n\
    \    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n          \
    \  return false\n        }\n    }\n    return true\n}\n            \nassert(get_closest_vowel(word:\
    \ \"yogurt\") == \"u\")\nassert(get_closest_vowel(word: \"full\") == \"u\")\n\
    assert(get_closest_vowel(word: \"easy\") == \"\")\nassert(get_closest_vowel(word:\
    \ \"eAsy\") == \"\")\nassert(get_closest_vowel(word: \"ali\") == \"\")\nassert(get_closest_vowel(word:\
    \ \"bad\") == \"a\")\nassert(get_closest_vowel(word: \"most\") == \"o\")\nassert(get_closest_vowel(word:\
    \ \"ab\") == \"\")\nassert(get_closest_vowel(word: \"ba\") == \"\")\nassert(get_closest_vowel(word:\
    \ \"quick\") == \"\")\nassert(get_closest_vowel(word: \"anime\") == \"i\")\nassert(get_closest_vowel(word:\
    \ \"Asia\") == \"\")\nassert(get_closest_vowel(word: \"Above\") == \"o\")"
  status: Exception
  stderr: 'tmpuh1_ai9q/tmpuh1_ai9q.swift:77: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b172eb50c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b172e847b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b172e847988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b172e8467b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpuh1_ai9q                        0x000055c36b983f13 <unavailable> + 7955

    5    libc.so.6                          0x00002b172ed3c460 __libc_start_main +
    245

    6    tmpuh1_ai9q                        0x000055c36b983949 <unavailable> + 6473

    '
  stdout: ''
  timestamp: 1660013568
- exit_code: -4
  program: "\n/// You are given a word. Your task is to find the closest vowel that\
    \ stands between \n/// two consonants from the right side of the word (case sensitive).\n\
    /// Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n/// find any vowel met the above condition. \n/// You may assume that\
    \ the given string contains English letter only.\n/// Example:\n/// >>> get_closest_vowel(word:\
    \ \"yogurt\")\n/// \"u\"\n/// >>> get_closest_vowel(word: \"FULL\")\n/// \"U\"\
    \n/// >>> get_closest_vowel(word: \"quick\")\n/// \"\"\n/// >>> get_closest_vowel(word:\
    \ \"ab\")\n/// \"\"\nfunc get_closest_vowel(word: String) -> String {\n    let\
    \ vowels = [\"a\", \"e\", \"i\", \"o\", \"u\"]\n    let wordReversed = String(word.reversed())\n\
    \    var closest = \"\"\n    var close = false\n    var index = 0\n    while !close\
    \ && index < wordReversed.count {\n        let char = String(wordReversed[wordReversed.index(wordReversed.startIndex,\
    \ offsetBy: index)])\n        index += 1\n        if vowels.contains(char) {\n\
    \            closest = char\n            close = true\n        }\n    }\n    return\
    \ closest\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n\
    \    if left.count != right.count {\n        return false\n    }\n    for (l,\
    \ r) in zip(left, right) {\n        if l != r {\n            return false\n  \
    \      }\n    }\n    return true\n}\n            \nassert(get_closest_vowel(word:\
    \ \"yogurt\") == \"u\")\nassert(get_closest_vowel(word: \"full\") == \"u\")\n\
    assert(get_closest_vowel(word: \"easy\") == \"\")\nassert(get_closest_vowel(word:\
    \ \"eAsy\") == \"\")\nassert(get_closest_vowel(word: \"ali\") == \"\")\nassert(get_closest_vowel(word:\
    \ \"bad\") == \"a\")\nassert(get_closest_vowel(word: \"most\") == \"o\")\nassert(get_closest_vowel(word:\
    \ \"ab\") == \"\")\nassert(get_closest_vowel(word: \"ba\") == \"\")\nassert(get_closest_vowel(word:\
    \ \"quick\") == \"\")\nassert(get_closest_vowel(word: \"anime\") == \"i\")\nassert(get_closest_vowel(word:\
    \ \"Asia\") == \"\")\nassert(get_closest_vowel(word: \"Above\") == \"o\")"
  status: Exception
  stderr: 'tmpua90u0yk/tmpua90u0yk.swift:48: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b4063acbc80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b40637c2b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b40637c2988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b40637c17b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpua90u0yk                        0x000055a6bf27da53 <unavailable> + 6739

    5    libc.so.6                          0x00002b4063cb7460 __libc_start_main +
    245

    6    tmpua90u0yk                        0x000055a6bf27d489 <unavailable> + 5257

    '
  stdout: ''
  timestamp: 1660013568
- exit_code: 1
  program: "\n/// You are given a word. Your task is to find the closest vowel that\
    \ stands between \n/// two consonants from the right side of the word (case sensitive).\n\
    /// Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n/// find any vowel met the above condition. \n/// You may assume that\
    \ the given string contains English letter only.\n/// Example:\n/// >>> get_closest_vowel(word:\
    \ \"yogurt\")\n/// \"u\"\n/// >>> get_closest_vowel(word: \"FULL\")\n/// \"U\"\
    \n/// >>> get_closest_vowel(word: \"quick\")\n/// \"\"\n/// >>> get_closest_vowel(word:\
    \ \"ab\")\n/// \"\"\nfunc get_closest_vowel(word: String) -> String {\n    //\
    \ Your code here.\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) ->\
    \ Bool {\n    if left.count != right.count {\n        return false\n    }\n  \
    \  for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(get_closest_vowel(word:\
    \ \"yogurt\") == \"u\")\nassert(get_closest_vowel(word: \"full\") == \"u\")\n\
    assert(get_closest_vowel(word: \"easy\") == \"\")\nassert(get_closest_vowel(word:\
    \ \"eAsy\") == \"\")\nassert(get_closest_vowel(word: \"ali\") == \"\")\nassert(get_closest_vowel(word:\
    \ \"bad\") == \"a\")\nassert(get_closest_vowel(word: \"most\") == \"o\")\nassert(get_closest_vowel(word:\
    \ \"ab\") == \"\")\nassert(get_closest_vowel(word: \"ba\") == \"\")\nassert(get_closest_vowel(word:\
    \ \"quick\") == \"\")\nassert(get_closest_vowel(word: \"anime\") == \"i\")\nassert(get_closest_vowel(word:\
    \ \"Asia\") == \"\")\nassert(get_closest_vowel(word: \"Above\") == \"o\")"
  status: SyntaxError
  stderr: '/tmp/tmp2_sycrgf.swift:18:1: error: missing return in global function expected
    to return ''String''

    }

    ^

    '
  stdout: ''
  timestamp: 1660013568
- exit_code: 1
  program: "\n/// You are given a word. Your task is to find the closest vowel that\
    \ stands between \n/// two consonants from the right side of the word (case sensitive).\n\
    /// Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n/// find any vowel met the above condition. \n/// You may assume that\
    \ the given string contains English letter only.\n/// Example:\n/// >>> get_closest_vowel(word:\
    \ \"yogurt\")\n/// \"u\"\n/// >>> get_closest_vowel(word: \"FULL\")\n/// \"U\"\
    \n/// >>> get_closest_vowel(word: \"quick\")\n/// \"\"\n/// >>> get_closest_vowel(word:\
    \ \"ab\")\n/// \"\"\nfunc get_closest_vowel(word: String) -> String {\n\tlet vowels\
    \ = [\"a\", \"e\", \"i\", \"o\", \"u\"]\n\tlet letters = word.characters.map {\
    \ String($0) }\n\tfor (i, letter) in letters.enumerated() {\n\t\tif vowels.contains(letter)\
    \ {\n\t\t\tif i > 0 && i < letters.count - 1 {\n\t\t\t\tif !vowels.contains(letters[i\
    \ - 1]) && !vowels.contains(letters[i + 1]) {\n\t\t\t\t\treturn letter\n\t\t\t\
    \t}\n\t\t\t}\n\t\t}\n\t}\n\treturn \"\"\n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(get_closest_vowel(word: \"yogurt\") == \"u\")\nassert(get_closest_vowel(word:\
    \ \"full\") == \"u\")\nassert(get_closest_vowel(word: \"easy\") == \"\")\nassert(get_closest_vowel(word:\
    \ \"eAsy\") == \"\")\nassert(get_closest_vowel(word: \"ali\") == \"\")\nassert(get_closest_vowel(word:\
    \ \"bad\") == \"a\")\nassert(get_closest_vowel(word: \"most\") == \"o\")\nassert(get_closest_vowel(word:\
    \ \"ab\") == \"\")\nassert(get_closest_vowel(word: \"ba\") == \"\")\nassert(get_closest_vowel(word:\
    \ \"quick\") == \"\")\nassert(get_closest_vowel(word: \"anime\") == \"i\")\nassert(get_closest_vowel(word:\
    \ \"Asia\") == \"\")\nassert(get_closest_vowel(word: \"Above\") == \"o\")"
  status: SyntaxError
  stderr: "/tmp/tmp4lopohlo.swift:18:21: error: 'characters' is unavailable: Please\
    \ use String directly\n        let letters = word.characters.map { String($0)\
    \ }\n                           ^~~~~~~~~~\nSwift.String:5:16: note: 'characters'\
    \ was obsoleted in Swift 5.0\n    public var characters: String { get set }\n\
    \               ^\n"
  stdout: ''
  timestamp: 1660013568
- exit_code: 1
  program: "\n/// You are given a word. Your task is to find the closest vowel that\
    \ stands between \n/// two consonants from the right side of the word (case sensitive).\n\
    /// Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n/// find any vowel met the above condition. \n/// You may assume that\
    \ the given string contains English letter only.\n/// Example:\n/// >>> get_closest_vowel(word:\
    \ \"yogurt\")\n/// \"u\"\n/// >>> get_closest_vowel(word: \"FULL\")\n/// \"U\"\
    \n/// >>> get_closest_vowel(word: \"quick\")\n/// \"\"\n/// >>> get_closest_vowel(word:\
    \ \"ab\")\n/// \"\"\nfunc get_closest_vowel(word: String) -> String {\n    var\
    \ string = word.filter { $0.isLetter }.reversed()\n    let vowels = \"aeiou\"\n\
    \    let consonants = \"bcdfghjklmnpqrstvwxyz\"\n    var counter = 0\n    while\
    \ counter < string.count - 1 {\n        if !vowels.contains(string[counter]) &&\
    \ !consonants.contains(string[counter + 1]) {\n            return String(string[counter\
    \ + 1])\n        }\n        counter += 1\n    }\n    return \"\"\n}\n\n\nfunc\
    \ ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count !=\
    \ right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(get_closest_vowel(word: \"yogurt\") == \"u\")\n\
    assert(get_closest_vowel(word: \"full\") == \"u\")\nassert(get_closest_vowel(word:\
    \ \"easy\") == \"\")\nassert(get_closest_vowel(word: \"eAsy\") == \"\")\nassert(get_closest_vowel(word:\
    \ \"ali\") == \"\")\nassert(get_closest_vowel(word: \"bad\") == \"a\")\nassert(get_closest_vowel(word:\
    \ \"most\") == \"o\")\nassert(get_closest_vowel(word: \"ab\") == \"\")\nassert(get_closest_vowel(word:\
    \ \"ba\") == \"\")\nassert(get_closest_vowel(word: \"quick\") == \"\")\nassert(get_closest_vowel(word:\
    \ \"anime\") == \"i\")\nassert(get_closest_vowel(word: \"Asia\") == \"\")\nassert(get_closest_vowel(word:\
    \ \"Above\") == \"o\")"
  status: SyntaxError
  stderr: "/tmp/tmp_kse_tq9.swift:22:36: error: cannot convert value of type 'Int'\
    \ to expected argument type 'ReversedCollection<String>.Index'\n        if !vowels.contains(string[counter])\
    \ && !consonants.contains(string[counter + 1]) {\n                           \
    \        ^\n/tmp/tmp_kse_tq9.swift:22:85: error: cannot convert value of type\
    \ 'Int' to expected argument type 'ReversedCollection<String>.Index'\n       \
    \ if !vowels.contains(string[counter]) && !consonants.contains(string[counter\
    \ + 1]) {\n                                                                  \
    \                  ^\n/tmp/tmp_kse_tq9.swift:23:33: error: no exact matches in\
    \ call to subscript \n            return String(string[counter + 1])\n       \
    \                         ^\nSwift.ReversedCollection:9:23: note: candidate expects\
    \ value of type 'ReversedCollection<String>.Index' for parameter #1 (got 'Int')\n\
    \    @inlinable public subscript(position: ReversedCollection<Base>.Index) ->\
    \ ReversedCollection<Base>.Element { get }\n                      ^\nSwift.Collection:2:23:\
    \ note: candidate expects value of type 'Range<ReversedCollection<String>.Index>'\
    \ for parameter #1 (got 'Int')\n    @inlinable public subscript(bounds: Range<Self.Index>)\
    \ -> Slice<Self> { get }\n                      ^\nSwift.Collection:3:23: note:\
    \ candidate expects value of type '(UnboundedRange_) -> ()' for parameter #1 (got\
    \ 'Int')\n    @inlinable public subscript(x: (UnboundedRange_) -> ()) -> Self.SubSequence\
    \ { get }\n                      ^\n"
  stdout: ''
  timestamp: 1660013568
- exit_code: -4
  program: "\n/// You are given a word. Your task is to find the closest vowel that\
    \ stands between \n/// two consonants from the right side of the word (case sensitive).\n\
    /// Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n/// find any vowel met the above condition. \n/// You may assume that\
    \ the given string contains English letter only.\n/// Example:\n/// >>> get_closest_vowel(word:\
    \ \"yogurt\")\n/// \"u\"\n/// >>> get_closest_vowel(word: \"FULL\")\n/// \"U\"\
    \n/// >>> get_closest_vowel(word: \"quick\")\n/// \"\"\n/// >>> get_closest_vowel(word:\
    \ \"ab\")\n/// \"\"\nfunc get_closest_vowel(word: String) -> String {\n    //\
    \ Write your code here\n    return \"\"\n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(get_closest_vowel(word: \"yogurt\") == \"u\")\nassert(get_closest_vowel(word:\
    \ \"full\") == \"u\")\nassert(get_closest_vowel(word: \"easy\") == \"\")\nassert(get_closest_vowel(word:\
    \ \"eAsy\") == \"\")\nassert(get_closest_vowel(word: \"ali\") == \"\")\nassert(get_closest_vowel(word:\
    \ \"bad\") == \"a\")\nassert(get_closest_vowel(word: \"most\") == \"o\")\nassert(get_closest_vowel(word:\
    \ \"ab\") == \"\")\nassert(get_closest_vowel(word: \"ba\") == \"\")\nassert(get_closest_vowel(word:\
    \ \"quick\") == \"\")\nassert(get_closest_vowel(word: \"anime\") == \"i\")\nassert(get_closest_vowel(word:\
    \ \"Asia\") == \"\")\nassert(get_closest_vowel(word: \"Above\") == \"o\")"
  status: Exception
  stderr: 'tmpfxqgbac3/tmpfxqgbac3.swift:34: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b8d59fbec80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b8d59cb5b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b8d59cb5988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b8d59cb47b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpfxqgbac3                        0x0000558c46d03307 <unavailable> + 4871

    5    libc.so.6                          0x00002b8d5a1aa460 __libc_start_main +
    245

    6    tmpfxqgbac3                        0x0000558c46d02f49 <unavailable> + 3913

    '
  stdout: ''
  timestamp: 1660013448
- exit_code: -4
  program: "\n/// You are given a word. Your task is to find the closest vowel that\
    \ stands between \n/// two consonants from the right side of the word (case sensitive).\n\
    /// Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n/// find any vowel met the above condition. \n/// You may assume that\
    \ the given string contains English letter only.\n/// Example:\n/// >>> get_closest_vowel(word:\
    \ \"yogurt\")\n/// \"u\"\n/// >>> get_closest_vowel(word: \"FULL\")\n/// \"U\"\
    \n/// >>> get_closest_vowel(word: \"quick\")\n/// \"\"\n/// >>> get_closest_vowel(word:\
    \ \"ab\")\n/// \"\"\nfunc get_closest_vowel(word: String) -> String {\n\treturn\
    \ \"\"\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n  \
    \  if left.count != right.count {\n        return false\n    }\n    for (l, r)\
    \ in zip(left, right) {\n        if l != r {\n            return false\n     \
    \   }\n    }\n    return true\n}\n            \nassert(get_closest_vowel(word:\
    \ \"yogurt\") == \"u\")\nassert(get_closest_vowel(word: \"full\") == \"u\")\n\
    assert(get_closest_vowel(word: \"easy\") == \"\")\nassert(get_closest_vowel(word:\
    \ \"eAsy\") == \"\")\nassert(get_closest_vowel(word: \"ali\") == \"\")\nassert(get_closest_vowel(word:\
    \ \"bad\") == \"a\")\nassert(get_closest_vowel(word: \"most\") == \"o\")\nassert(get_closest_vowel(word:\
    \ \"ab\") == \"\")\nassert(get_closest_vowel(word: \"ba\") == \"\")\nassert(get_closest_vowel(word:\
    \ \"quick\") == \"\")\nassert(get_closest_vowel(word: \"anime\") == \"i\")\nassert(get_closest_vowel(word:\
    \ \"Asia\") == \"\")\nassert(get_closest_vowel(word: \"Above\") == \"o\")"
  status: Exception
  stderr: 'tmpn1nhe2gl/tmpn1nhe2gl.swift:33: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b611fa0bc80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b611f702b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b611f702988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b611f7017b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpn1nhe2gl                        0x0000564138d6b307 <unavailable> + 4871

    5    libc.so.6                          0x00002b611fbf7460 __libc_start_main +
    245

    6    tmpn1nhe2gl                        0x0000564138d6af49 <unavailable> + 3913

    '
  stdout: ''
  timestamp: 1660013568
- exit_code: -4
  program: "\n/// You are given a word. Your task is to find the closest vowel that\
    \ stands between \n/// two consonants from the right side of the word (case sensitive).\n\
    /// Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n/// find any vowel met the above condition. \n/// You may assume that\
    \ the given string contains English letter only.\n/// Example:\n/// >>> get_closest_vowel(word:\
    \ \"yogurt\")\n/// \"u\"\n/// >>> get_closest_vowel(word: \"FULL\")\n/// \"U\"\
    \n/// >>> get_closest_vowel(word: \"quick\")\n/// \"\"\n/// >>> get_closest_vowel(word:\
    \ \"ab\")\n/// \"\"\nfunc get_closest_vowel(word: String) -> String {\n    let\
    \ consonants = \"BCDFGHJKLMNPQRSTVWXYZbcdfghjklmnpqrstvwxyz\"\n    let vowels\
    \ = \"AEIOUaeiou\"\n    for i in (0..<word.count).reversed() {\n        let index\
    \ = word.index(word.startIndex, offsetBy: i)\n        let char = String(word[index])\n\
    \        if consonants.contains(char) {\n            continue\n        }\n   \
    \     if vowels.contains(char) {\n            if i + 1 < word.count {\n      \
    \          let nextIndex = word.index(word.startIndex, offsetBy: i + 1)\n    \
    \            let nextChar = String(word[nextIndex])\n                if consonants.contains(nextChar)\
    \ {\n                    return char\n                }\n            }\n     \
    \   }\n    }\n    return \"\"\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int,\
    \ Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n\
    \    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n          \
    \  return false\n        }\n    }\n    return true\n}\n            \nassert(get_closest_vowel(word:\
    \ \"yogurt\") == \"u\")\nassert(get_closest_vowel(word: \"full\") == \"u\")\n\
    assert(get_closest_vowel(word: \"easy\") == \"\")\nassert(get_closest_vowel(word:\
    \ \"eAsy\") == \"\")\nassert(get_closest_vowel(word: \"ali\") == \"\")\nassert(get_closest_vowel(word:\
    \ \"bad\") == \"a\")\nassert(get_closest_vowel(word: \"most\") == \"o\")\nassert(get_closest_vowel(word:\
    \ \"ab\") == \"\")\nassert(get_closest_vowel(word: \"ba\") == \"\")\nassert(get_closest_vowel(word:\
    \ \"quick\") == \"\")\nassert(get_closest_vowel(word: \"anime\") == \"i\")\nassert(get_closest_vowel(word:\
    \ \"Asia\") == \"\")\nassert(get_closest_vowel(word: \"Above\") == \"o\")"
  status: Exception
  stderr: 'tmpat9vs6mc/tmpat9vs6mc.swift:53: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b2f6c9ffc80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b2f6c6f6b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b2f6c6f6988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b2f6c6f57b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpat9vs6mc                        0x0000555c4258db03 <unavailable> + 6915

    5    libc.so.6                          0x00002b2f6cbeb460 __libc_start_main +
    245

    6    tmpat9vs6mc                        0x0000555c4258d539 <unavailable> + 5433

    '
  stdout: ''
  timestamp: 1660013568
- exit_code: 1
  program: "\n/// You are given a word. Your task is to find the closest vowel that\
    \ stands between \n/// two consonants from the right side of the word (case sensitive).\n\
    /// Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n/// find any vowel met the above condition. \n/// You may assume that\
    \ the given string contains English letter only.\n/// Example:\n/// >>> get_closest_vowel(word:\
    \ \"yogurt\")\n/// \"u\"\n/// >>> get_closest_vowel(word: \"FULL\")\n/// \"U\"\
    \n/// >>> get_closest_vowel(word: \"quick\")\n/// \"\"\n/// >>> get_closest_vowel(word:\
    \ \"ab\")\n/// \"\"\nfunc get_closest_vowel(word: String) -> String {\n    let\
    \ vowels = \"aeiou\"\n    let consonants = \"bcdfghjklmnpqrstvwxyz\"\n    var\
    \ val = \"\"\n    for char in word.characters {\n        for v in vowels.characters\
    \ {\n            if char == v {\n                val += \"\\(char)\"\n       \
    \     }\n        }\n    }\n    var ret = \"\"\n    var val2 = \"\"\n    var val3\
    \ = \"\"\n    for char in word.characters {\n        for c in consonants.characters\
    \ {\n            if char == c {\n                val2 += \"\\(char)\"\n      \
    \      }\n        }\n    }\n    if val2.characters.count < 2 {\n        return\
    \ \"\"\n    }\n    for char in val2.characters {\n        if char == val2.characters.last!\
    \ {\n            val3 += \"\\(char)\"\n        }\n    }\n    val2 = val2.replacingOccurrences(of:\
    \ val3, with: \"\")\n    for char in val.characters {\n        if char == val.characters.last!\
    \ {\n            ret += \"\\(char)\"\n        }\n    }\n    if val2.characters.count\
    \ == 1 {\n        return \"\"\n    }\n    if ret == \"\" {\n        return \"\"\
    \n    }\n    return ret\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(get_closest_vowel(word:\
    \ \"yogurt\") == \"u\")\nassert(get_closest_vowel(word: \"full\") == \"u\")\n\
    assert(get_closest_vowel(word: \"easy\") == \"\")\nassert(get_closest_vowel(word:\
    \ \"eAsy\") == \"\")\nassert(get_closest_vowel(word: \"ali\") == \"\")\nassert(get_closest_vowel(word:\
    \ \"bad\") == \"a\")\nassert(get_closest_vowel(word: \"most\") == \"o\")\nassert(get_closest_vowel(word:\
    \ \"ab\") == \"\")\nassert(get_closest_vowel(word: \"ba\") == \"\")\nassert(get_closest_vowel(word:\
    \ \"quick\") == \"\")\nassert(get_closest_vowel(word: \"anime\") == \"i\")\nassert(get_closest_vowel(word:\
    \ \"Asia\") == \"\")\nassert(get_closest_vowel(word: \"Above\") == \"o\")"
  status: SyntaxError
  stderr: "/tmp/tmp74twk7sp.swift:20:22: error: 'characters' is unavailable: Please\
    \ use String directly\n    for char in word.characters {\n                   \
    \  ^~~~~~~~~~\nSwift.String:5:16: note: 'characters' was obsoleted in Swift 5.0\n\
    \    public var characters: String { get set }\n               ^\n/tmp/tmp74twk7sp.swift:21:25:\
    \ error: 'characters' is unavailable: Please use String directly\n        for\
    \ v in vowels.characters {\n                        ^~~~~~~~~~\nSwift.String:5:16:\
    \ note: 'characters' was obsoleted in Swift 5.0\n    public var characters: String\
    \ { get set }\n               ^\n/tmp/tmp74twk7sp.swift:30:22: error: 'characters'\
    \ is unavailable: Please use String directly\n    for char in word.characters\
    \ {\n                     ^~~~~~~~~~\nSwift.String:5:16: note: 'characters' was\
    \ obsoleted in Swift 5.0\n    public var characters: String { get set }\n    \
    \           ^\n/tmp/tmp74twk7sp.swift:31:29: error: 'characters' is unavailable:\
    \ Please use String directly\n        for c in consonants.characters {\n     \
    \                       ^~~~~~~~~~\nSwift.String:5:16: note: 'characters' was\
    \ obsoleted in Swift 5.0\n    public var characters: String { get set }\n    \
    \           ^\n/tmp/tmp74twk7sp.swift:37:13: error: 'characters' is unavailable:\
    \ Please use String directly\n    if val2.characters.count < 2 {\n           \
    \ ^~~~~~~~~~\nSwift.String:5:16: note: 'characters' was obsoleted in Swift 5.0\n\
    \    public var characters: String { get set }\n               ^\n/tmp/tmp74twk7sp.swift:40:22:\
    \ error: 'characters' is unavailable: Please use String directly\n    for char\
    \ in val2.characters {\n                     ^~~~~~~~~~\nSwift.String:5:16: note:\
    \ 'characters' was obsoleted in Swift 5.0\n    public var characters: String {\
    \ get set }\n               ^\n/tmp/tmp74twk7sp.swift:41:25: error: 'characters'\
    \ is unavailable: Please use String directly\n        if char == val2.characters.last!\
    \ {\n                        ^~~~~~~~~~\nSwift.String:5:16: note: 'characters'\
    \ was obsoleted in Swift 5.0\n    public var characters: String { get set }\n\
    \               ^\n/tmp/tmp74twk7s"
  stdout: ''
  timestamp: 1660013568
- exit_code: 1
  program: "\n/// You are given a word. Your task is to find the closest vowel that\
    \ stands between \n/// two consonants from the right side of the word (case sensitive).\n\
    /// Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n/// find any vowel met the above condition. \n/// You may assume that\
    \ the given string contains English letter only.\n/// Example:\n/// >>> get_closest_vowel(word:\
    \ \"yogurt\")\n/// \"u\"\n/// >>> get_closest_vowel(word: \"FULL\")\n/// \"U\"\
    \n/// >>> get_closest_vowel(word: \"quick\")\n/// \"\"\n/// >>> get_closest_vowel(word:\
    \ \"ab\")\n/// \"\"\nfunc get_closest_vowel(word: String) -> String {\n    let\
    \ vowels = [\"a\", \"e\", \"i\", \"o\", \"u\"]\n    var i = word.count - 1\n \
    \   while i >= 0 {\n        let char = word[i]\n        if !vowels.contains(char)\
    \ {\n            i -= 1\n        } else {\n            return String(char)\n \
    \       }\n    }\n    return \"\"\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int,\
    \ Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n\
    \    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n          \
    \  return false\n        }\n    }\n    return true\n}\n            \nassert(get_closest_vowel(word:\
    \ \"yogurt\") == \"u\")\nassert(get_closest_vowel(word: \"full\") == \"u\")\n\
    assert(get_closest_vowel(word: \"easy\") == \"\")\nassert(get_closest_vowel(word:\
    \ \"eAsy\") == \"\")\nassert(get_closest_vowel(word: \"ali\") == \"\")\nassert(get_closest_vowel(word:\
    \ \"bad\") == \"a\")\nassert(get_closest_vowel(word: \"most\") == \"o\")\nassert(get_closest_vowel(word:\
    \ \"ab\") == \"\")\nassert(get_closest_vowel(word: \"ba\") == \"\")\nassert(get_closest_vowel(word:\
    \ \"quick\") == \"\")\nassert(get_closest_vowel(word: \"anime\") == \"i\")\nassert(get_closest_vowel(word:\
    \ \"Asia\") == \"\")\nassert(get_closest_vowel(word: \"Above\") == \"o\")"
  status: SyntaxError
  stderr: "/tmp/tmp_kjh3610.swift:20:20: error: 'subscript(_:)' is unavailable: cannot\
    \ subscript String with an Int, use a String.Index instead.\n        let char\
    \ = word[i]\n                   ^~~~~~~\nSwift.String:3:12: note: 'subscript(_:)'\
    \ has been explicitly marked unavailable here\n    public subscript(i: Int) ->\
    \ Character { get }\n           ^\n/tmp/tmp_kjh3610.swift:21:29: error: cannot\
    \ convert value of type 'Character' to expected argument type 'String'\n     \
    \   if !vowels.contains(char) {\n                            ^\n"
  stdout: ''
  timestamp: 1660013568
- exit_code: -4
  program: "\n/// You are given a word. Your task is to find the closest vowel that\
    \ stands between \n/// two consonants from the right side of the word (case sensitive).\n\
    /// Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n/// find any vowel met the above condition. \n/// You may assume that\
    \ the given string contains English letter only.\n/// Example:\n/// >>> get_closest_vowel(word:\
    \ \"yogurt\")\n/// \"u\"\n/// >>> get_closest_vowel(word: \"FULL\")\n/// \"U\"\
    \n/// >>> get_closest_vowel(word: \"quick\")\n/// \"\"\n/// >>> get_closest_vowel(word:\
    \ \"ab\")\n/// \"\"\nfunc get_closest_vowel(word: String) -> String {\n    return\
    \ \"\"\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n  \
    \  if left.count != right.count {\n        return false\n    }\n    for (l, r)\
    \ in zip(left, right) {\n        if l != r {\n            return false\n     \
    \   }\n    }\n    return true\n}\n            \nassert(get_closest_vowel(word:\
    \ \"yogurt\") == \"u\")\nassert(get_closest_vowel(word: \"full\") == \"u\")\n\
    assert(get_closest_vowel(word: \"easy\") == \"\")\nassert(get_closest_vowel(word:\
    \ \"eAsy\") == \"\")\nassert(get_closest_vowel(word: \"ali\") == \"\")\nassert(get_closest_vowel(word:\
    \ \"bad\") == \"a\")\nassert(get_closest_vowel(word: \"most\") == \"o\")\nassert(get_closest_vowel(word:\
    \ \"ab\") == \"\")\nassert(get_closest_vowel(word: \"ba\") == \"\")\nassert(get_closest_vowel(word:\
    \ \"quick\") == \"\")\nassert(get_closest_vowel(word: \"anime\") == \"i\")\nassert(get_closest_vowel(word:\
    \ \"Asia\") == \"\")\nassert(get_closest_vowel(word: \"Above\") == \"o\")"
  status: Exception
  stderr: 'tmpvf1hzub_/tmpvf1hzub_.swift:33: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002ba694399c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002ba694090b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002ba694090988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002ba69408f7b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpvf1hzub_                        0x00005567315f8307 <unavailable> + 4871

    5    libc.so.6                          0x00002ba694585460 __libc_start_main +
    245

    6    tmpvf1hzub_                        0x00005567315f7f49 <unavailable> + 3913

    '
  stdout: ''
  timestamp: 1660013566
- exit_code: -4
  program: "\n/// You are given a word. Your task is to find the closest vowel that\
    \ stands between \n/// two consonants from the right side of the word (case sensitive).\n\
    /// Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n/// find any vowel met the above condition. \n/// You may assume that\
    \ the given string contains English letter only.\n/// Example:\n/// >>> get_closest_vowel(word:\
    \ \"yogurt\")\n/// \"u\"\n/// >>> get_closest_vowel(word: \"FULL\")\n/// \"U\"\
    \n/// >>> get_closest_vowel(word: \"quick\")\n/// \"\"\n/// >>> get_closest_vowel(word:\
    \ \"ab\")\n/// \"\"\nfunc get_closest_vowel(word: String) -> String {\n    let\
    \ vowels = [\"a\", \"e\", \"i\", \"o\", \"u\"]\n    var consonants = [String]()\n\
    \    for character in word {\n        if !vowels.contains(String(character)) {\n\
    \            consonants.append(String(character))\n        }\n    }\n    if consonants.count\
    \ > 1 {\n        for i in (0...consonants.count - 2).reversed() {\n          \
    \  if vowels.contains(String(word[word.index(word.startIndex, offsetBy: i)]))\
    \ {\n                return String(word[word.index(word.startIndex, offsetBy:\
    \ i)])\n            }\n        }\n    }\n    return \"\"\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(get_closest_vowel(word: \"yogurt\") == \"u\")\nassert(get_closest_vowel(word:\
    \ \"full\") == \"u\")\nassert(get_closest_vowel(word: \"easy\") == \"\")\nassert(get_closest_vowel(word:\
    \ \"eAsy\") == \"\")\nassert(get_closest_vowel(word: \"ali\") == \"\")\nassert(get_closest_vowel(word:\
    \ \"bad\") == \"a\")\nassert(get_closest_vowel(word: \"most\") == \"o\")\nassert(get_closest_vowel(word:\
    \ \"ab\") == \"\")\nassert(get_closest_vowel(word: \"ba\") == \"\")\nassert(get_closest_vowel(word:\
    \ \"quick\") == \"\")\nassert(get_closest_vowel(word: \"anime\") == \"i\")\nassert(get_closest_vowel(word:\
    \ \"Asia\") == \"\")\nassert(get_closest_vowel(word: \"Above\") == \"o\")"
  status: Exception
  stderr: 'tmpn31d4_du/tmpn31d4_du.swift:47: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b5dba9f8c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b5dba6efb6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b5dba6ef988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b5dba6ee7b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpn31d4_du                        0x0000555e20497b67 <unavailable> + 7015

    5    libc.so.6                          0x00002b5dbabe4460 __libc_start_main +
    245

    6    tmpn31d4_du                        0x0000555e204977a9 <unavailable> + 6057

    '
  stdout: ''
  timestamp: 1660013568
- exit_code: -4
  program: "\n/// You are given a word. Your task is to find the closest vowel that\
    \ stands between \n/// two consonants from the right side of the word (case sensitive).\n\
    /// Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n/// find any vowel met the above condition. \n/// You may assume that\
    \ the given string contains English letter only.\n/// Example:\n/// >>> get_closest_vowel(word:\
    \ \"yogurt\")\n/// \"u\"\n/// >>> get_closest_vowel(word: \"FULL\")\n/// \"U\"\
    \n/// >>> get_closest_vowel(word: \"quick\")\n/// \"\"\n/// >>> get_closest_vowel(word:\
    \ \"ab\")\n/// \"\"\nfunc get_closest_vowel(word: String) -> String {\n    let\
    \ vowels = \"aeiouAEIOU\"\n    let cons = \"bcdfghjklmnpqrstvwxyzBCDFGHJKLMNPQRSTVWXYZ\"\
    \n    for i in stride(from: word.count - 1, to: 0, by: -1) {\n        let index\
    \ = word.index(word.startIndex, offsetBy: i)\n        if vowels.contains(word[index])\
    \ {\n            for j in (0...i).reversed() {\n                let consIndex\
    \ = word.index(word.startIndex, offsetBy: j)\n                if cons.contains(word[consIndex])\
    \ {\n                    return String(word[index])\n                }\n     \
    \       }\n        }\n    }\n    return \"\"\n}\n\n\nfunc ==(left: [(Int, Int)],\
    \ right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n       \
    \ return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r\
    \ {\n            return false\n        }\n    }\n    return true\n}\n        \
    \    \nassert(get_closest_vowel(word: \"yogurt\") == \"u\")\nassert(get_closest_vowel(word:\
    \ \"full\") == \"u\")\nassert(get_closest_vowel(word: \"easy\") == \"\")\nassert(get_closest_vowel(word:\
    \ \"eAsy\") == \"\")\nassert(get_closest_vowel(word: \"ali\") == \"\")\nassert(get_closest_vowel(word:\
    \ \"bad\") == \"a\")\nassert(get_closest_vowel(word: \"most\") == \"o\")\nassert(get_closest_vowel(word:\
    \ \"ab\") == \"\")\nassert(get_closest_vowel(word: \"ba\") == \"\")\nassert(get_closest_vowel(word:\
    \ \"quick\") == \"\")\nassert(get_closest_vowel(word: \"anime\") == \"i\")\nassert(get_closest_vowel(word:\
    \ \"Asia\") == \"\")\nassert(get_closest_vowel(word: \"Above\") == \"o\")"
  status: Exception
  stderr: 'tmpr6a8bz1b/tmpr6a8bz1b.swift:50: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b368bc02c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b368b8f9b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b368b8f9988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b368b8f87b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpr6a8bz1b                        0x000056286664ff3b <unavailable> + 7995

    5    libc.so.6                          0x00002b368bdee460 __libc_start_main +
    245

    6    tmpr6a8bz1b                        0x000056286664f739 <unavailable> + 5945

    '
  stdout: ''
  timestamp: 1660013568
- exit_code: -4
  program: "\n/// You are given a word. Your task is to find the closest vowel that\
    \ stands between \n/// two consonants from the right side of the word (case sensitive).\n\
    /// Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n/// find any vowel met the above condition. \n/// You may assume that\
    \ the given string contains English letter only.\n/// Example:\n/// >>> get_closest_vowel(word:\
    \ \"yogurt\")\n/// \"u\"\n/// >>> get_closest_vowel(word: \"FULL\")\n/// \"U\"\
    \n/// >>> get_closest_vowel(word: \"quick\")\n/// \"\"\n/// >>> get_closest_vowel(word:\
    \ \"ab\")\n/// \"\"\nfunc get_closest_vowel(word: String) -> String {\n    let\
    \ vowels = Set(\"aeiouAEIOU\")\n    var closest_vowel: String = \"\"\n    var\
    \ index: Int = word.count - 1\n    while index >= 0 {\n        let character =\
    \ word[word.index(word.startIndex, offsetBy: index)]\n        if vowels.contains(character)\
    \ {\n            closest_vowel = String(character)\n            break\n      \
    \  }\n        index -= 1\n    }\n    return closest_vowel\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(get_closest_vowel(word: \"yogurt\") == \"u\")\nassert(get_closest_vowel(word:\
    \ \"full\") == \"u\")\nassert(get_closest_vowel(word: \"easy\") == \"\")\nassert(get_closest_vowel(word:\
    \ \"eAsy\") == \"\")\nassert(get_closest_vowel(word: \"ali\") == \"\")\nassert(get_closest_vowel(word:\
    \ \"bad\") == \"a\")\nassert(get_closest_vowel(word: \"most\") == \"o\")\nassert(get_closest_vowel(word:\
    \ \"ab\") == \"\")\nassert(get_closest_vowel(word: \"ba\") == \"\")\nassert(get_closest_vowel(word:\
    \ \"quick\") == \"\")\nassert(get_closest_vowel(word: \"anime\") == \"i\")\nassert(get_closest_vowel(word:\
    \ \"Asia\") == \"\")\nassert(get_closest_vowel(word: \"Above\") == \"o\")"
  status: Exception
  stderr: 'tmpepjpiw95/tmpepjpiw95.swift:46: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b98192b9c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b9818fb0b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b9818fb0988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b9818faf7b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpepjpiw95                        0x0000560be1553873 <unavailable> + 6259

    5    libc.so.6                          0x00002b98194a5460 __libc_start_main +
    245

    6    tmpepjpiw95                        0x0000560be15532a9 <unavailable> + 4777

    '
  stdout: ''
  timestamp: 1660013568
- exit_code: -4
  program: "\n/// You are given a word. Your task is to find the closest vowel that\
    \ stands between \n/// two consonants from the right side of the word (case sensitive).\n\
    /// Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n/// find any vowel met the above condition. \n/// You may assume that\
    \ the given string contains English letter only.\n/// Example:\n/// >>> get_closest_vowel(word:\
    \ \"yogurt\")\n/// \"u\"\n/// >>> get_closest_vowel(word: \"FULL\")\n/// \"U\"\
    \n/// >>> get_closest_vowel(word: \"quick\")\n/// \"\"\n/// >>> get_closest_vowel(word:\
    \ \"ab\")\n/// \"\"\nfunc get_closest_vowel(word: String) -> String {\n    let\
    \ vowels = Set(\"aeiouAEIOU\")\n    let consonants = Set(\"bcdfghjklmnpqrstvwxyzBCDFGHJKLMNPQRSTVWXYZ\"\
    )\n    var distance_from_right = 0\n    for char in word.reversed() {\n      \
    \  distance_from_right += 1\n        if vowels.contains(char) {\n            if\
    \ distance_from_right > 1 {\n                return String(char)\n           \
    \ }\n        } else if consonants.contains(char) {\n            if distance_from_right\
    \ > 1 {\n                return \"\"\n            }\n        }\n    }\n    return\
    \ \"\"\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n  \
    \  if left.count != right.count {\n        return false\n    }\n    for (l, r)\
    \ in zip(left, right) {\n        if l != r {\n            return false\n     \
    \   }\n    }\n    return true\n}\n            \nassert(get_closest_vowel(word:\
    \ \"yogurt\") == \"u\")\nassert(get_closest_vowel(word: \"full\") == \"u\")\n\
    assert(get_closest_vowel(word: \"easy\") == \"\")\nassert(get_closest_vowel(word:\
    \ \"eAsy\") == \"\")\nassert(get_closest_vowel(word: \"ali\") == \"\")\nassert(get_closest_vowel(word:\
    \ \"bad\") == \"a\")\nassert(get_closest_vowel(word: \"most\") == \"o\")\nassert(get_closest_vowel(word:\
    \ \"ab\") == \"\")\nassert(get_closest_vowel(word: \"ba\") == \"\")\nassert(get_closest_vowel(word:\
    \ \"quick\") == \"\")\nassert(get_closest_vowel(word: \"anime\") == \"i\")\nassert(get_closest_vowel(word:\
    \ \"Asia\") == \"\")\nassert(get_closest_vowel(word: \"Above\") == \"o\")"
  status: Exception
  stderr: 'tmptga14o47/tmptga14o47.swift:48: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002af5f9663c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002af5f935ab6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002af5f935a988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002af5f93597b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmptga14o47                        0x000055f8e990e737 <unavailable> + 5943

    5    libc.so.6                          0x00002af5f984f460 __libc_start_main +
    245

    6    tmptga14o47                        0x000055f8e990e379 <unavailable> + 4985

    '
  stdout: ''
  timestamp: 1660013568
- exit_code: -4
  program: "\n/// You are given a word. Your task is to find the closest vowel that\
    \ stands between \n/// two consonants from the right side of the word (case sensitive).\n\
    /// Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n/// find any vowel met the above condition. \n/// You may assume that\
    \ the given string contains English letter only.\n/// Example:\n/// >>> get_closest_vowel(word:\
    \ \"yogurt\")\n/// \"u\"\n/// >>> get_closest_vowel(word: \"FULL\")\n/// \"U\"\
    \n/// >>> get_closest_vowel(word: \"quick\")\n/// \"\"\n/// >>> get_closest_vowel(word:\
    \ \"ab\")\n/// \"\"\nfunc get_closest_vowel(word: String) -> String {\n    let\
    \ vowels = \"AEIOUaeiou\"\n    let wordList = Array(word)\n    var result: String\
    \ = \"\"\n    for i in 0..<wordList.count {\n        if (vowels.contains(wordList[i]))\
    \ {\n            if (i == 0) {\n                continue\n            }\n    \
    \        if (i == wordList.count - 1) {\n                continue\n          \
    \  }\n            if (vowels.contains(wordList[i - 1]) || vowels.contains(wordList[i\
    \ + 1])) {\n                continue\n            }\n            result = String(wordList[i])\n\
    \            break\n        }\n    }\n    return result\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(get_closest_vowel(word: \"yogurt\") == \"u\")\nassert(get_closest_vowel(word:\
    \ \"full\") == \"u\")\nassert(get_closest_vowel(word: \"easy\") == \"\")\nassert(get_closest_vowel(word:\
    \ \"eAsy\") == \"\")\nassert(get_closest_vowel(word: \"ali\") == \"\")\nassert(get_closest_vowel(word:\
    \ \"bad\") == \"a\")\nassert(get_closest_vowel(word: \"most\") == \"o\")\nassert(get_closest_vowel(word:\
    \ \"ab\") == \"\")\nassert(get_closest_vowel(word: \"ba\") == \"\")\nassert(get_closest_vowel(word:\
    \ \"quick\") == \"\")\nassert(get_closest_vowel(word: \"anime\") == \"i\")\nassert(get_closest_vowel(word:\
    \ \"Asia\") == \"\")\nassert(get_closest_vowel(word: \"Above\") == \"o\")"
  status: Exception
  stderr: 'tmppkxwa8wo/tmppkxwa8wo.swift:51: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b1c20847c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b1c2053eb6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b1c2053e988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b1c2053d7b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmppkxwa8wo                        0x000055bd3e22a797 <unavailable> + 6039

    5    libc.so.6                          0x00002b1c20a33460 __libc_start_main +
    245

    6    tmppkxwa8wo                        0x000055bd3e22a3d9 <unavailable> + 5081

    '
  stdout: ''
  timestamp: 1660013568
- exit_code: 1
  program: "\n/// You are given a word. Your task is to find the closest vowel that\
    \ stands between \n/// two consonants from the right side of the word (case sensitive).\n\
    /// Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n/// find any vowel met the above condition. \n/// You may assume that\
    \ the given string contains English letter only.\n/// Example:\n/// >>> get_closest_vowel(word:\
    \ \"yogurt\")\n/// \"u\"\n/// >>> get_closest_vowel(word: \"FULL\")\n/// \"U\"\
    \n/// >>> get_closest_vowel(word: \"quick\")\n/// \"\"\n/// >>> get_closest_vowel(word:\
    \ \"ab\")\n/// \"\"\nfunc get_closest_vowel(word: String) -> String {\n    let\
    \ vowels = \"aeiouAEIOU\"\n    var result = \"\"\n    var distance = word.count\n\
    \    for char in word {\n        if vowels.contains(char) {\n            if let\
    \ index = word.lastIndex(of: char) {\n                if index > 0 && index <\
    \ word.count - 1 {\n                    if !vowels.contains(word[word.index(before:\
    \ index)])\n                        && !vowels.contains(word[word.index(after:\
    \ index)]) {\n                        if index < distance {\n                \
    \            distance = index\n                            result = String(char)\n\
    \                        }\n                    }\n                }\n       \
    \     }\n        }\n    }\n    return result\n}\n\n\nfunc ==(left: [(Int, Int)],\
    \ right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n       \
    \ return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r\
    \ {\n            return false\n        }\n    }\n    return true\n}\n        \
    \    \nassert(get_closest_vowel(word: \"yogurt\") == \"u\")\nassert(get_closest_vowel(word:\
    \ \"full\") == \"u\")\nassert(get_closest_vowel(word: \"easy\") == \"\")\nassert(get_closest_vowel(word:\
    \ \"eAsy\") == \"\")\nassert(get_closest_vowel(word: \"ali\") == \"\")\nassert(get_closest_vowel(word:\
    \ \"bad\") == \"a\")\nassert(get_closest_vowel(word: \"most\") == \"o\")\nassert(get_closest_vowel(word:\
    \ \"ab\") == \"\")\nassert(get_closest_vowel(word: \"ba\") == \"\")\nassert(get_closest_vowel(word:\
    \ \"quick\") == \"\")\nassert(get_closest_vowel(word: \"anime\") == \"i\")\nassert(get_closest_vowel(word:\
    \ \"Asia\") == \"\")\nassert(get_closest_vowel(word: \"Above\") == \"o\")"
  status: SyntaxError
  stderr: "/tmp/tmp_m4x_qpf.swift:23:26: error: referencing operator function '>'\
    \ on 'BinaryInteger' requires that 'String.Index' conform to 'BinaryInteger'\n\
    \                if index > 0 && index < word.count - 1 {\n                  \
    \       ^\nSwift.BinaryInteger:1:11: note: where 'Self' = 'String.Index'\nextension\
    \ BinaryInteger {\n          ^\n/tmp/tmp_m4x_qpf.swift:23:39: error: referencing\
    \ operator function '<' on 'BinaryInteger' requires that 'String.Index' conform\
    \ to 'BinaryInteger'\n                if index > 0 && index < word.count - 1 {\n\
    \                                      ^\nSwift.BinaryInteger:1:11: note: where\
    \ 'Self' = 'String.Index'\nextension BinaryInteger {\n          ^\n/tmp/tmp_m4x_qpf.swift:26:34:\
    \ error: referencing operator function '<' on 'BinaryInteger' requires that 'String.Index'\
    \ conform to 'BinaryInteger'\n                        if index < distance {\n\
    \                                 ^\nSwift.BinaryInteger:1:11: note: where 'Self'\
    \ = 'String.Index'\nextension BinaryInteger {\n          ^\n/tmp/tmp_m4x_qpf.swift:27:40:\
    \ error: cannot assign value of type 'String.Index' to type 'Int'\n          \
    \                  distance = index\n                                       ^~~~~\n"
  stdout: ''
  timestamp: 1660013568
- exit_code: -4
  program: "\n/// You are given a word. Your task is to find the closest vowel that\
    \ stands between \n/// two consonants from the right side of the word (case sensitive).\n\
    /// Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n/// find any vowel met the above condition. \n/// You may assume that\
    \ the given string contains English letter only.\n/// Example:\n/// >>> get_closest_vowel(word:\
    \ \"yogurt\")\n/// \"u\"\n/// >>> get_closest_vowel(word: \"FULL\")\n/// \"U\"\
    \n/// >>> get_closest_vowel(word: \"quick\")\n/// \"\"\n/// >>> get_closest_vowel(word:\
    \ \"ab\")\n/// \"\"\nfunc get_closest_vowel(word: String) -> String {\n    let\
    \ vowels = \"aeiou\"\n    var closest: Character = \" \"\n    var result = \"\"\
    \n    for i in word.indices {\n        if word[i] == \" \" {\n            closest\
    \ = word[i]\n        }\n        if vowels.contains(word[i]) {\n            closest\
    \ = word[i]\n        }\n        if closest != \" \" {\n            result = String(closest)\n\
    \        }\n    }\n    return result\n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(get_closest_vowel(word: \"yogurt\") == \"u\")\nassert(get_closest_vowel(word:\
    \ \"full\") == \"u\")\nassert(get_closest_vowel(word: \"easy\") == \"\")\nassert(get_closest_vowel(word:\
    \ \"eAsy\") == \"\")\nassert(get_closest_vowel(word: \"ali\") == \"\")\nassert(get_closest_vowel(word:\
    \ \"bad\") == \"a\")\nassert(get_closest_vowel(word: \"most\") == \"o\")\nassert(get_closest_vowel(word:\
    \ \"ab\") == \"\")\nassert(get_closest_vowel(word: \"ba\") == \"\")\nassert(get_closest_vowel(word:\
    \ \"quick\") == \"\")\nassert(get_closest_vowel(word: \"anime\") == \"i\")\nassert(get_closest_vowel(word:\
    \ \"Asia\") == \"\")\nassert(get_closest_vowel(word: \"Above\") == \"o\")"
  status: Exception
  stderr: 'tmpskg4vekm/tmpskg4vekm.swift:49: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b5ebccd4c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b5ebc9cbb6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b5ebc9cb988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b5ebc9ca7b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpskg4vekm                        0x0000564b365f59c3 <unavailable> + 6595

    5    libc.so.6                          0x00002b5ebcec0460 __libc_start_main +
    245

    6    tmpskg4vekm                        0x0000564b365f53f9 <unavailable> + 5113

    '
  stdout: ''
  timestamp: 1660013568
- exit_code: -4
  program: "\n/// You are given a word. Your task is to find the closest vowel that\
    \ stands between \n/// two consonants from the right side of the word (case sensitive).\n\
    /// Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n/// find any vowel met the above condition. \n/// You may assume that\
    \ the given string contains English letter only.\n/// Example:\n/// >>> get_closest_vowel(word:\
    \ \"yogurt\")\n/// \"u\"\n/// >>> get_closest_vowel(word: \"FULL\")\n/// \"U\"\
    \n/// >>> get_closest_vowel(word: \"quick\")\n/// \"\"\n/// >>> get_closest_vowel(word:\
    \ \"ab\")\n/// \"\"\nfunc get_closest_vowel(word: String) -> String {\n    let\
    \ vowels = \"AEIOUaeiou\"\n    let consonants = \"BCDFGHJKLMNPQRSTVWXYZbcdfghjklmnpqrstvwxyz\"\
    \n    var counter = 0\n    for index in (0..<word.count).reversed() {\n      \
    \  let char = String(word[word.index(word.startIndex, offsetBy: index)])\n   \
    \     if vowels.contains(char) {\n            return char\n        } else if consonants.contains(char)\
    \ {\n            counter += 1\n        }\n        if counter == 2 {\n        \
    \    return \"\"\n        }\n    }\n    return \"\"\n}\n\n\nfunc ==(left: [(Int,\
    \ Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n\
    \        return false\n    }\n    for (l, r) in zip(left, right) {\n        if\
    \ l != r {\n            return false\n        }\n    }\n    return true\n}\n \
    \           \nassert(get_closest_vowel(word: \"yogurt\") == \"u\")\nassert(get_closest_vowel(word:\
    \ \"full\") == \"u\")\nassert(get_closest_vowel(word: \"easy\") == \"\")\nassert(get_closest_vowel(word:\
    \ \"eAsy\") == \"\")\nassert(get_closest_vowel(word: \"ali\") == \"\")\nassert(get_closest_vowel(word:\
    \ \"bad\") == \"a\")\nassert(get_closest_vowel(word: \"most\") == \"o\")\nassert(get_closest_vowel(word:\
    \ \"ab\") == \"\")\nassert(get_closest_vowel(word: \"ba\") == \"\")\nassert(get_closest_vowel(word:\
    \ \"quick\") == \"\")\nassert(get_closest_vowel(word: \"anime\") == \"i\")\nassert(get_closest_vowel(word:\
    \ \"Asia\") == \"\")\nassert(get_closest_vowel(word: \"Above\") == \"o\")"
  status: Exception
  stderr: 'tmp17yvjebn/tmp17yvjebn.swift:47: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002ba4ae5bec80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002ba4ae2b5b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002ba4ae2b5988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002ba4ae2b47b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmp17yvjebn                        0x000055eecaad88f7 <unavailable> + 6391

    5    libc.so.6                          0x00002ba4ae7aa460 __libc_start_main +
    245

    6    tmp17yvjebn                        0x000055eecaad8539 <unavailable> + 5433

    '
  stdout: ''
  timestamp: 1660013568
- exit_code: 1
  program: "\n/// You are given a word. Your task is to find the closest vowel that\
    \ stands between \n/// two consonants from the right side of the word (case sensitive).\n\
    /// Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n/// find any vowel met the above condition. \n/// You may assume that\
    \ the given string contains English letter only.\n/// Example:\n/// >>> get_closest_vowel(word:\
    \ \"yogurt\")\n/// \"u\"\n/// >>> get_closest_vowel(word: \"FULL\")\n/// \"U\"\
    \n/// >>> get_closest_vowel(word: \"quick\")\n/// \"\"\n/// >>> get_closest_vowel(word:\
    \ \"ab\")\n/// \"\"\nfunc get_closest_vowel(word: String) -> String {\n    var\
    \ minDistance: Int = word.count\n    var vowel: String = \"\"\n    for c in word\
    \ {\n        if is_vowel(c: c) {\n            let distance = word.distance(from:\
    \ word.endIndex, to: word.firstIndex(of: c)!)\n            if distance < minDistance\
    \ {\n                minDistance = distance\n                vowel = String(c)\n\
    \            }\n        }\n    }\n    return vowel\n}\n\n\nfunc ==(left: [(Int,\
    \ Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n\
    \        return false\n    }\n    for (l, r) in zip(left, right) {\n        if\
    \ l != r {\n            return false\n        }\n    }\n    return true\n}\n \
    \           \nassert(get_closest_vowel(word: \"yogurt\") == \"u\")\nassert(get_closest_vowel(word:\
    \ \"full\") == \"u\")\nassert(get_closest_vowel(word: \"easy\") == \"\")\nassert(get_closest_vowel(word:\
    \ \"eAsy\") == \"\")\nassert(get_closest_vowel(word: \"ali\") == \"\")\nassert(get_closest_vowel(word:\
    \ \"bad\") == \"a\")\nassert(get_closest_vowel(word: \"most\") == \"o\")\nassert(get_closest_vowel(word:\
    \ \"ab\") == \"\")\nassert(get_closest_vowel(word: \"ba\") == \"\")\nassert(get_closest_vowel(word:\
    \ \"quick\") == \"\")\nassert(get_closest_vowel(word: \"anime\") == \"i\")\nassert(get_closest_vowel(word:\
    \ \"Asia\") == \"\")\nassert(get_closest_vowel(word: \"Above\") == \"o\")"
  status: SyntaxError
  stderr: "/tmp/tmpccb2r_p6.swift:20:12: error: cannot find 'is_vowel' in scope\n\
    \        if is_vowel(c: c) {\n           ^~~~~~~~\n"
  stdout: ''
  timestamp: 1660013568
- exit_code: 1
  program: "\n/// You are given a word. Your task is to find the closest vowel that\
    \ stands between \n/// two consonants from the right side of the word (case sensitive).\n\
    /// Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n/// find any vowel met the above condition. \n/// You may assume that\
    \ the given string contains English letter only.\n/// Example:\n/// >>> get_closest_vowel(word:\
    \ \"yogurt\")\n/// \"u\"\n/// >>> get_closest_vowel(word: \"FULL\")\n/// \"U\"\
    \n/// >>> get_closest_vowel(word: \"quick\")\n/// \"\"\n/// >>> get_closest_vowel(word:\
    \ \"ab\")\n/// \"\"\nfunc get_closest_vowel(word: String) -> String {\n    let\
    \ vowels = [\"a\", \"e\", \"i\", \"o\", \"u\"]\n    var closest_vowel = \"\"\n\
    \    for (i, char) in word.characters.enumerated() {\n        if vowels.contains(String(char))\
    \ {\n            if i > 0 && i < word.characters.count - 1 {\n               \
    \ if !vowels.contains(String(word[word.index(word.startIndex, offsetBy: i - 1)]))\
    \ && !vowels.contains(String(word[word.index(word.startIndex, offsetBy: i + 1)]))\
    \ {\n                    closest_vowel = String(char)\n                    break\n\
    \                }\n            }\n        }\n    }\n    return closest_vowel\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(get_closest_vowel(word: \"yogurt\") == \"u\")\n\
    assert(get_closest_vowel(word: \"full\") == \"u\")\nassert(get_closest_vowel(word:\
    \ \"easy\") == \"\")\nassert(get_closest_vowel(word: \"eAsy\") == \"\")\nassert(get_closest_vowel(word:\
    \ \"ali\") == \"\")\nassert(get_closest_vowel(word: \"bad\") == \"a\")\nassert(get_closest_vowel(word:\
    \ \"most\") == \"o\")\nassert(get_closest_vowel(word: \"ab\") == \"\")\nassert(get_closest_vowel(word:\
    \ \"ba\") == \"\")\nassert(get_closest_vowel(word: \"quick\") == \"\")\nassert(get_closest_vowel(word:\
    \ \"anime\") == \"i\")\nassert(get_closest_vowel(word: \"Asia\") == \"\")\nassert(get_closest_vowel(word:\
    \ \"Above\") == \"o\")"
  status: SyntaxError
  stderr: "/tmp/tmpak32lz4y.swift:19:27: error: 'characters' is unavailable: Please\
    \ use String directly\n    for (i, char) in word.characters.enumerated() {\n \
    \                         ^~~~~~~~~~\nSwift.String:5:16: note: 'characters' was\
    \ obsoleted in Swift 5.0\n    public var characters: String { get set }\n    \
    \           ^\n/tmp/tmpak32lz4y.swift:21:34: error: 'characters' is unavailable:\
    \ Please use String directly\n            if i > 0 && i < word.characters.count\
    \ - 1 {\n                                 ^~~~~~~~~~\nSwift.String:5:16: note:\
    \ 'characters' was obsoleted in Swift 5.0\n    public var characters: String {\
    \ get set }\n               ^\n"
  stdout: ''
  timestamp: 1660013568
- exit_code: 1
  program: "\n/// You are given a word. Your task is to find the closest vowel that\
    \ stands between \n/// two consonants from the right side of the word (case sensitive).\n\
    /// Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n/// find any vowel met the above condition. \n/// You may assume that\
    \ the given string contains English letter only.\n/// Example:\n/// >>> get_closest_vowel(word:\
    \ \"yogurt\")\n/// \"u\"\n/// >>> get_closest_vowel(word: \"FULL\")\n/// \"U\"\
    \n/// >>> get_closest_vowel(word: \"quick\")\n/// \"\"\n/// >>> get_closest_vowel(word:\
    \ \"ab\")\n/// \"\"\nfunc get_closest_vowel(word: String) -> String {\n    let\
    \ vowels = [\"a\", \"e\", \"i\", \"o\", \"u\"]\n    var vowelArray: [String] =\
    \ []\n    for i in 0..<word.count {\n        let character = word[i]\n       \
    \ if vowels.contains(String(character)) {\n            vowelArray.append(String(character))\n\
    \        }\n    }\n    if vowelArray.count < 2 {\n        return \"\"\n    }\n\
    \    var counter = word.count - 1\n    var leftVowelIndex = word.count - 1\n \
    \   var rightVowelIndex = word.count - 1\n    while counter >= 0 {\n        let\
    \ character = word[counter]\n        if vowels.contains(String(character)) {\n\
    \            rightVowelIndex = counter\n            break\n        }\n       \
    \ counter -= 1\n    }\n    counter = 0\n    while counter < word.count {\n   \
    \     let character = word[counter]\n        if vowels.contains(String(character))\
    \ {\n            leftVowelIndex = counter\n            break\n        }\n    \
    \    counter += 1\n    }\n    if rightVowelIndex - leftVowelIndex > 1 {\n    \
    \    return vowelArray[1]\n    }\n    return \"\"\n}\n\n\nfunc ==(left: [(Int,\
    \ Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n\
    \        return false\n    }\n    for (l, r) in zip(left, right) {\n        if\
    \ l != r {\n            return false\n        }\n    }\n    return true\n}\n \
    \           \nassert(get_closest_vowel(word: \"yogurt\") == \"u\")\nassert(get_closest_vowel(word:\
    \ \"full\") == \"u\")\nassert(get_closest_vowel(word: \"easy\") == \"\")\nassert(get_closest_vowel(word:\
    \ \"eAsy\") == \"\")\nassert(get_closest_vowel(word: \"ali\") == \"\")\nassert(get_closest_vowel(word:\
    \ \"bad\") == \"a\")\nassert(get_closest_vowel(word: \"most\") == \"o\")\nassert(get_closest_vowel(word:\
    \ \"ab\") == \"\")\nassert(get_closest_vowel(word: \"ba\") == \"\")\nassert(get_closest_vowel(word:\
    \ \"quick\") == \"\")\nassert(get_closest_vowel(word: \"anime\") == \"i\")\nassert(get_closest_vowel(word:\
    \ \"Asia\") == \"\")\nassert(get_closest_vowel(word: \"Above\") == \"o\")"
  status: SyntaxError
  stderr: "/tmp/tmp2fzsifzh.swift:20:25: error: 'subscript(_:)' is unavailable: cannot\
    \ subscript String with an Int, use a String.Index instead.\n        let character\
    \ = word[i]\n                        ^~~~~~~\nSwift.String:3:12: note: 'subscript(_:)'\
    \ has been explicitly marked unavailable here\n    public subscript(i: Int) ->\
    \ Character { get }\n           ^\n/tmp/tmp2fzsifzh.swift:32:25: error: 'subscript(_:)'\
    \ is unavailable: cannot subscript String with an Int, use a String.Index instead.\n\
    \        let character = word[counter]\n                        ^~~~~~~~~~~~~\n\
    Swift.String:3:12: note: 'subscript(_:)' has been explicitly marked unavailable\
    \ here\n    public subscript(i: Int) -> Character { get }\n           ^\n/tmp/tmp2fzsifzh.swift:41:25:\
    \ error: 'subscript(_:)' is unavailable: cannot subscript String with an Int,\
    \ use a String.Index instead.\n        let character = word[counter]\n       \
    \                 ^~~~~~~~~~~~~\nSwift.String:3:12: note: 'subscript(_:)' has\
    \ been explicitly marked unavailable here\n    public subscript(i: Int) -> Character\
    \ { get }\n           ^\n"
  stdout: ''
  timestamp: 1660013568
- exit_code: -4
  program: "\n/// You are given a word. Your task is to find the closest vowel that\
    \ stands between \n/// two consonants from the right side of the word (case sensitive).\n\
    /// Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n/// find any vowel met the above condition. \n/// You may assume that\
    \ the given string contains English letter only.\n/// Example:\n/// >>> get_closest_vowel(word:\
    \ \"yogurt\")\n/// \"u\"\n/// >>> get_closest_vowel(word: \"FULL\")\n/// \"U\"\
    \n/// >>> get_closest_vowel(word: \"quick\")\n/// \"\"\n/// >>> get_closest_vowel(word:\
    \ \"ab\")\n/// \"\"\nfunc get_closest_vowel(word: String) -> String {\n    let\
    \ vowels = Set<Character>(\"aeiouAEIOU\")\n    let consonants = Set<Character>(\"\
    bcdfghjklmnpqrstvwxyzBCDFGHJKLMNPQRSTVWXYZ\")\n    var closestVowel = \"\"\n \
    \   var closestIndex = -1\n    for (index, char) in word.reversed().enumerated()\
    \ {\n        if vowels.contains(char) {\n            closestVowel = String(char)\n\
    \            closestIndex = index\n        } else if consonants.contains(char)\
    \ && closestIndex != -1 {\n            break\n        }\n    }\n    return closestVowel\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(get_closest_vowel(word: \"yogurt\") == \"u\")\n\
    assert(get_closest_vowel(word: \"full\") == \"u\")\nassert(get_closest_vowel(word:\
    \ \"easy\") == \"\")\nassert(get_closest_vowel(word: \"eAsy\") == \"\")\nassert(get_closest_vowel(word:\
    \ \"ali\") == \"\")\nassert(get_closest_vowel(word: \"bad\") == \"a\")\nassert(get_closest_vowel(word:\
    \ \"most\") == \"o\")\nassert(get_closest_vowel(word: \"ab\") == \"\")\nassert(get_closest_vowel(word:\
    \ \"ba\") == \"\")\nassert(get_closest_vowel(word: \"quick\") == \"\")\nassert(get_closest_vowel(word:\
    \ \"anime\") == \"i\")\nassert(get_closest_vowel(word: \"Asia\") == \"\")\nassert(get_closest_vowel(word:\
    \ \"Above\") == \"o\")"
  status: Exception
  stderr: 'tmprw4pj3iz/tmprw4pj3iz.swift:47: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002ba2edfdec80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002ba2edcd5b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002ba2edcd5988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002ba2edcd47b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmprw4pj3iz                        0x00005587f8223a63 <unavailable> + 6755

    5    libc.so.6                          0x00002ba2ee1ca460 __libc_start_main +
    245

    6    tmprw4pj3iz                        0x00005587f8223499 <unavailable> + 5273

    '
  stdout: ''
  timestamp: 1660013568
- exit_code: -4
  program: "\n/// You are given a word. Your task is to find the closest vowel that\
    \ stands between \n/// two consonants from the right side of the word (case sensitive).\n\
    /// Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n/// find any vowel met the above condition. \n/// You may assume that\
    \ the given string contains English letter only.\n/// Example:\n/// >>> get_closest_vowel(word:\
    \ \"yogurt\")\n/// \"u\"\n/// >>> get_closest_vowel(word: \"FULL\")\n/// \"U\"\
    \n/// >>> get_closest_vowel(word: \"quick\")\n/// \"\"\n/// >>> get_closest_vowel(word:\
    \ \"ab\")\n/// \"\"\nfunc get_closest_vowel(word: String) -> String {\n    let\
    \ consonants = [\"q\", \"w\", \"r\", \"t\", \"p\", \"s\", \"d\", \"f\", \"g\"\
    , \"h\", \"j\", \"k\", \"l\", \"z\", \"x\", \"c\", \"v\", \"b\", \"n\", \"m\"\
    ]\n    let vowels = [\"a\", \"e\", \"i\", \"o\", \"u\", \"y\"]\n    var closest_vowel\
    \ = \"\"\n    var has_vowel = false\n    for character in word.reversed() {\n\
    \        if consonants.contains(String(character)) {\n            if has_vowel\
    \ {\n                return closest_vowel\n            }\n        } else if vowels.contains(String(character))\
    \ {\n            has_vowel = true\n            closest_vowel = String(character)\n\
    \        }\n    }\n    return \"\"\n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(get_closest_vowel(word: \"yogurt\") == \"u\")\nassert(get_closest_vowel(word:\
    \ \"full\") == \"u\")\nassert(get_closest_vowel(word: \"easy\") == \"\")\nassert(get_closest_vowel(word:\
    \ \"eAsy\") == \"\")\nassert(get_closest_vowel(word: \"ali\") == \"\")\nassert(get_closest_vowel(word:\
    \ \"bad\") == \"a\")\nassert(get_closest_vowel(word: \"most\") == \"o\")\nassert(get_closest_vowel(word:\
    \ \"ab\") == \"\")\nassert(get_closest_vowel(word: \"ba\") == \"\")\nassert(get_closest_vowel(word:\
    \ \"quick\") == \"\")\nassert(get_closest_vowel(word: \"anime\") == \"i\")\nassert(get_closest_vowel(word:\
    \ \"Asia\") == \"\")\nassert(get_closest_vowel(word: \"Above\") == \"o\")"
  status: Exception
  stderr: 'tmpa0jc6hxs/tmpa0jc6hxs.swift:49: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002afc7c454c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002afc7c14bb6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002afc7c14b988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002afc7c14a7b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpa0jc6hxs                        0x000055ea1b7a9983 <unavailable> + 6531

    5    libc.so.6                          0x00002afc7c640460 __libc_start_main +
    245

    6    tmpa0jc6hxs                        0x000055ea1b7a93b9 <unavailable> + 5049

    '
  stdout: ''
  timestamp: 1660013568
- exit_code: 1
  program: "\n/// You are given a word. Your task is to find the closest vowel that\
    \ stands between \n/// two consonants from the right side of the word (case sensitive).\n\
    /// Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n/// find any vowel met the above condition. \n/// You may assume that\
    \ the given string contains English letter only.\n/// Example:\n/// >>> get_closest_vowel(word:\
    \ \"yogurt\")\n/// \"u\"\n/// >>> get_closest_vowel(word: \"FULL\")\n/// \"U\"\
    \n/// >>> get_closest_vowel(word: \"quick\")\n/// \"\"\n/// >>> get_closest_vowel(word:\
    \ \"ab\")\n/// \"\"\nfunc get_closest_vowel(word: String) -> String {\n    let\
    \ word = word.lowercased()\n    let vowels = \"aeiou\"\n    var result = \"\"\n\
    \    for i in stride(from: word.count - 1, through: 0, by: -1) {\n        let\
    \ character = word[i]\n        if vowels.contains(character) {\n            result\
    \ = String(character)\n            break\n        }\n    }\n    return result\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(get_closest_vowel(word: \"yogurt\") == \"u\")\n\
    assert(get_closest_vowel(word: \"full\") == \"u\")\nassert(get_closest_vowel(word:\
    \ \"easy\") == \"\")\nassert(get_closest_vowel(word: \"eAsy\") == \"\")\nassert(get_closest_vowel(word:\
    \ \"ali\") == \"\")\nassert(get_closest_vowel(word: \"bad\") == \"a\")\nassert(get_closest_vowel(word:\
    \ \"most\") == \"o\")\nassert(get_closest_vowel(word: \"ab\") == \"\")\nassert(get_closest_vowel(word:\
    \ \"ba\") == \"\")\nassert(get_closest_vowel(word: \"quick\") == \"\")\nassert(get_closest_vowel(word:\
    \ \"anime\") == \"i\")\nassert(get_closest_vowel(word: \"Asia\") == \"\")\nassert(get_closest_vowel(word:\
    \ \"Above\") == \"o\")"
  status: SyntaxError
  stderr: "/tmp/tmpo3h685io.swift:21:25: error: 'subscript(_:)' is unavailable: cannot\
    \ subscript String with an Int, use a String.Index instead.\n        let character\
    \ = word[i]\n                        ^~~~~~~\nSwift.String:3:12: note: 'subscript(_:)'\
    \ has been explicitly marked unavailable here\n    public subscript(i: Int) ->\
    \ Character { get }\n           ^\n"
  stdout: ''
  timestamp: 1660013568
- exit_code: -4
  program: "\n/// You are given a word. Your task is to find the closest vowel that\
    \ stands between \n/// two consonants from the right side of the word (case sensitive).\n\
    /// Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n/// find any vowel met the above condition. \n/// You may assume that\
    \ the given string contains English letter only.\n/// Example:\n/// >>> get_closest_vowel(word:\
    \ \"yogurt\")\n/// \"u\"\n/// >>> get_closest_vowel(word: \"FULL\")\n/// \"U\"\
    \n/// >>> get_closest_vowel(word: \"quick\")\n/// \"\"\n/// >>> get_closest_vowel(word:\
    \ \"ab\")\n/// \"\"\nfunc get_closest_vowel(word: String) -> String {\n    let\
    \ vowels = Set(\"aeiouAEIOU\")\n    let consonants = Set(\"bcdfghjklmnpqrstvwxyzBCDFGHJKLMNPQRSTVWXYZ\"\
    )\n    var closestVowel: Character?\n    var closestVowelDist = Int.max\n    for\
    \ (idx, char) in word.enumerated() {\n        if vowels.contains(char) {\n   \
    \         continue\n        }\n        if !consonants.contains(char) {\n     \
    \       continue\n        }\n        let possibleVowel = word.index(word.startIndex,\
    \ offsetBy: idx + 1)\n        let following = word[possibleVowel...]\n       \
    \ if let idxOfVowel = following.firstIndex(where: { vowels.contains($0) }) {\n\
    \            let dist = following.distance(from: idxOfVowel, to: following.endIndex)\n\
    \            if dist < closestVowelDist {\n                closestVowelDist =\
    \ dist\n                closestVowel = following[idxOfVowel]\n            }\n\
    \        }\n    }\n    return closestVowel != nil ? String(closestVowel!) : \"\
    \"\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if\
    \ left.count != right.count {\n        return false\n    }\n    for (l, r) in\
    \ zip(left, right) {\n        if l != r {\n            return false\n        }\n\
    \    }\n    return true\n}\n            \nassert(get_closest_vowel(word: \"yogurt\"\
    ) == \"u\")\nassert(get_closest_vowel(word: \"full\") == \"u\")\nassert(get_closest_vowel(word:\
    \ \"easy\") == \"\")\nassert(get_closest_vowel(word: \"eAsy\") == \"\")\nassert(get_closest_vowel(word:\
    \ \"ali\") == \"\")\nassert(get_closest_vowel(word: \"bad\") == \"a\")\nassert(get_closest_vowel(word:\
    \ \"most\") == \"o\")\nassert(get_closest_vowel(word: \"ab\") == \"\")\nassert(get_closest_vowel(word:\
    \ \"ba\") == \"\")\nassert(get_closest_vowel(word: \"quick\") == \"\")\nassert(get_closest_vowel(word:\
    \ \"anime\") == \"i\")\nassert(get_closest_vowel(word: \"Asia\") == \"\")\nassert(get_closest_vowel(word:\
    \ \"Above\") == \"o\")"
  status: Exception
  stderr: 'tmpyux7087i/tmpyux7087i.swift:58: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b6a134bdc80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b6a131b4b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b6a131b4988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b6a131b37b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpyux7087i                        0x0000561556a9003b <unavailable> + 8251

    5    libc.so.6                          0x00002b6a136a9460 __libc_start_main +
    245

    6    tmpyux7087i                        0x0000561556a8f839 <unavailable> + 6201

    '
  stdout: ''
  timestamp: 1660013568
- exit_code: -4
  program: "\n/// You are given a word. Your task is to find the closest vowel that\
    \ stands between \n/// two consonants from the right side of the word (case sensitive).\n\
    /// Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n/// find any vowel met the above condition. \n/// You may assume that\
    \ the given string contains English letter only.\n/// Example:\n/// >>> get_closest_vowel(word:\
    \ \"yogurt\")\n/// \"u\"\n/// >>> get_closest_vowel(word: \"FULL\")\n/// \"U\"\
    \n/// >>> get_closest_vowel(word: \"quick\")\n/// \"\"\n/// >>> get_closest_vowel(word:\
    \ \"ab\")\n/// \"\"\nfunc get_closest_vowel(word: String) -> String {\n    //\
    \ starting from the right, go until the first vowel\n    // and then return the\
    \ next vowel you see\n    var index = word.count - 1\n    while index >= 0 {\n\
    \        let char = word[word.index(word.startIndex, offsetBy: index)]\n     \
    \   if \"aeiou\".contains(char) {\n            break\n        }\n        index\
    \ -= 1\n    }\n    index += 1\n    while index < word.count {\n        let char\
    \ = word[word.index(word.startIndex, offsetBy: index)]\n        if \"aeiou\".contains(char)\
    \ {\n            return String(char)\n        }\n        index += 1\n    }\n \
    \   return \"\"\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool\
    \ {\n    if left.count != right.count {\n        return false\n    }\n    for\
    \ (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(get_closest_vowel(word:\
    \ \"yogurt\") == \"u\")\nassert(get_closest_vowel(word: \"full\") == \"u\")\n\
    assert(get_closest_vowel(word: \"easy\") == \"\")\nassert(get_closest_vowel(word:\
    \ \"eAsy\") == \"\")\nassert(get_closest_vowel(word: \"ali\") == \"\")\nassert(get_closest_vowel(word:\
    \ \"bad\") == \"a\")\nassert(get_closest_vowel(word: \"most\") == \"o\")\nassert(get_closest_vowel(word:\
    \ \"ab\") == \"\")\nassert(get_closest_vowel(word: \"ba\") == \"\")\nassert(get_closest_vowel(word:\
    \ \"quick\") == \"\")\nassert(get_closest_vowel(word: \"anime\") == \"i\")\nassert(get_closest_vowel(word:\
    \ \"Asia\") == \"\")\nassert(get_closest_vowel(word: \"Above\") == \"o\")"
  status: Exception
  stderr: 'tmp7q35saei/tmp7q35saei.swift:51: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b801a602c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b801a2f9b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b801a2f9988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b801a2f87b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmp7q35saei                        0x000055941c6775d7 <unavailable> + 5591

    5    libc.so.6                          0x00002b801a7ee460 __libc_start_main +
    245

    6    tmp7q35saei                        0x000055941c677219 <unavailable> + 4633

    '
  stdout: ''
  timestamp: 1660013568
- exit_code: -4
  program: "\n/// You are given a word. Your task is to find the closest vowel that\
    \ stands between \n/// two consonants from the right side of the word (case sensitive).\n\
    /// Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n/// find any vowel met the above condition. \n/// You may assume that\
    \ the given string contains English letter only.\n/// Example:\n/// >>> get_closest_vowel(word:\
    \ \"yogurt\")\n/// \"u\"\n/// >>> get_closest_vowel(word: \"FULL\")\n/// \"U\"\
    \n/// >>> get_closest_vowel(word: \"quick\")\n/// \"\"\n/// >>> get_closest_vowel(word:\
    \ \"ab\")\n/// \"\"\nfunc get_closest_vowel(word: String) -> String {\n    //\
    \ your code here\n    return \"\"\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int,\
    \ Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n\
    \    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n          \
    \  return false\n        }\n    }\n    return true\n}\n            \nassert(get_closest_vowel(word:\
    \ \"yogurt\") == \"u\")\nassert(get_closest_vowel(word: \"full\") == \"u\")\n\
    assert(get_closest_vowel(word: \"easy\") == \"\")\nassert(get_closest_vowel(word:\
    \ \"eAsy\") == \"\")\nassert(get_closest_vowel(word: \"ali\") == \"\")\nassert(get_closest_vowel(word:\
    \ \"bad\") == \"a\")\nassert(get_closest_vowel(word: \"most\") == \"o\")\nassert(get_closest_vowel(word:\
    \ \"ab\") == \"\")\nassert(get_closest_vowel(word: \"ba\") == \"\")\nassert(get_closest_vowel(word:\
    \ \"quick\") == \"\")\nassert(get_closest_vowel(word: \"anime\") == \"i\")\nassert(get_closest_vowel(word:\
    \ \"Asia\") == \"\")\nassert(get_closest_vowel(word: \"Above\") == \"o\")"
  status: Exception
  stderr: 'tmpa6wfme3m/tmpa6wfme3m.swift:34: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002ba5af6cec80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002ba5af3c5b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002ba5af3c5988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002ba5af3c47b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpa6wfme3m                        0x000055734e3d0307 <unavailable> + 4871

    5    libc.so.6                          0x00002ba5af8ba460 __libc_start_main +
    245

    6    tmpa6wfme3m                        0x000055734e3cff49 <unavailable> + 3913

    '
  stdout: ''
  timestamp: 1660013566
- exit_code: -4
  program: "\n/// You are given a word. Your task is to find the closest vowel that\
    \ stands between \n/// two consonants from the right side of the word (case sensitive).\n\
    /// Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n/// find any vowel met the above condition. \n/// You may assume that\
    \ the given string contains English letter only.\n/// Example:\n/// >>> get_closest_vowel(word:\
    \ \"yogurt\")\n/// \"u\"\n/// >>> get_closest_vowel(word: \"FULL\")\n/// \"U\"\
    \n/// >>> get_closest_vowel(word: \"quick\")\n/// \"\"\n/// >>> get_closest_vowel(word:\
    \ \"ab\")\n/// \"\"\nfunc get_closest_vowel(word: String) -> String {\n    var\
    \ result = \"\"\n    let vowels = \"aeiouAEIOU\"\n    var current = 0\n    var\
    \ closest = word.count\n    for c in word {\n        if vowels.contains(c) {\n\
    \            let distance = word.count - current\n            if distance < closest\
    \ && distance > 1 {\n                closest = distance\n                result\
    \ = String(c)\n            }\n        }\n        current += 1\n    }\n    return\
    \ result\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n\
    \    if left.count != right.count {\n        return false\n    }\n    for (l,\
    \ r) in zip(left, right) {\n        if l != r {\n            return false\n  \
    \      }\n    }\n    return true\n}\n            \nassert(get_closest_vowel(word:\
    \ \"yogurt\") == \"u\")\nassert(get_closest_vowel(word: \"full\") == \"u\")\n\
    assert(get_closest_vowel(word: \"easy\") == \"\")\nassert(get_closest_vowel(word:\
    \ \"eAsy\") == \"\")\nassert(get_closest_vowel(word: \"ali\") == \"\")\nassert(get_closest_vowel(word:\
    \ \"bad\") == \"a\")\nassert(get_closest_vowel(word: \"most\") == \"o\")\nassert(get_closest_vowel(word:\
    \ \"ab\") == \"\")\nassert(get_closest_vowel(word: \"ba\") == \"\")\nassert(get_closest_vowel(word:\
    \ \"quick\") == \"\")\nassert(get_closest_vowel(word: \"anime\") == \"i\")\nassert(get_closest_vowel(word:\
    \ \"Asia\") == \"\")\nassert(get_closest_vowel(word: \"Above\") == \"o\")"
  status: Exception
  stderr: 'tmpsjam7lvn/tmpsjam7lvn.swift:49: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002ac150fc2c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002ac150cb9b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002ac150cb9988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002ac150cb87b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpsjam7lvn                        0x000055c20d87d783 <unavailable> + 6019

    5    libc.so.6                          0x00002ac1511ae460 __libc_start_main +
    245

    6    tmpsjam7lvn                        0x000055c20d87d1b9 <unavailable> + 4537

    '
  stdout: ''
  timestamp: 1660013568
- exit_code: 1
  program: "\n/// You are given a word. Your task is to find the closest vowel that\
    \ stands between \n/// two consonants from the right side of the word (case sensitive).\n\
    /// Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n/// find any vowel met the above condition. \n/// You may assume that\
    \ the given string contains English letter only.\n/// Example:\n/// >>> get_closest_vowel(word:\
    \ \"yogurt\")\n/// \"u\"\n/// >>> get_closest_vowel(word: \"FULL\")\n/// \"U\"\
    \n/// >>> get_closest_vowel(word: \"quick\")\n/// \"\"\n/// >>> get_closest_vowel(word:\
    \ \"ab\")\n/// \"\"\nfunc get_closest_vowel(word: String) -> String {\n    if\
    \ word.isEmpty {\n        return \"\"\n    }\n    var index: String.Index = word.startIndex\n\
    \    var prev: Character = \" \"\n    var curr: Character = \" \"\n    var next:\
    \ Character = \" \"\n    var i = 0\n    while i < word.count {\n        if i ==\
    \ 0 {\n            prev = \" \"\n        } else {\n            prev = word[word.index(before:\
    \ index)]\n        }\n        curr = word[index]\n        if i < word.count -\
    \ 1 {\n            next = word[word.index(after: index)]\n        } else {\n \
    \           next = \" \"\n        }\n        index = word.index(after: index)\n\
    \        i += 1\n        if !is_vowel(ch: prev) && is_vowel(ch: curr) && !is_vowel(ch:\
    \ next) {\n            return String(curr)\n        }\n    }\n    return \"\"\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(get_closest_vowel(word: \"yogurt\") == \"u\")\n\
    assert(get_closest_vowel(word: \"full\") == \"u\")\nassert(get_closest_vowel(word:\
    \ \"easy\") == \"\")\nassert(get_closest_vowel(word: \"eAsy\") == \"\")\nassert(get_closest_vowel(word:\
    \ \"ali\") == \"\")\nassert(get_closest_vowel(word: \"bad\") == \"a\")\nassert(get_closest_vowel(word:\
    \ \"most\") == \"o\")\nassert(get_closest_vowel(word: \"ab\") == \"\")\nassert(get_closest_vowel(word:\
    \ \"ba\") == \"\")\nassert(get_closest_vowel(word: \"quick\") == \"\")\nassert(get_closest_vowel(word:\
    \ \"anime\") == \"i\")\nassert(get_closest_vowel(word: \"Asia\") == \"\")\nassert(get_closest_vowel(word:\
    \ \"Above\") == \"o\")"
  status: SyntaxError
  stderr: "/tmp/tmph0lkn3m7.swift:39:13: error: cannot find 'is_vowel' in scope\n\
    \        if !is_vowel(ch: prev) && is_vowel(ch: curr) && !is_vowel(ch: next) {\n\
    \            ^~~~~~~~\n/tmp/tmph0lkn3m7.swift:39:35: error: cannot find 'is_vowel'\
    \ in scope\n        if !is_vowel(ch: prev) && is_vowel(ch: curr) && !is_vowel(ch:\
    \ next) {\n                                  ^~~~~~~~\n/tmp/tmph0lkn3m7.swift:39:58:\
    \ error: cannot find 'is_vowel' in scope\n        if !is_vowel(ch: prev) && is_vowel(ch:\
    \ curr) && !is_vowel(ch: next) {\n                                           \
    \              ^~~~~~~~\n"
  stdout: ''
  timestamp: 1660013568
- exit_code: -4
  program: "\n/// You are given a word. Your task is to find the closest vowel that\
    \ stands between \n/// two consonants from the right side of the word (case sensitive).\n\
    /// Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n/// find any vowel met the above condition. \n/// You may assume that\
    \ the given string contains English letter only.\n/// Example:\n/// >>> get_closest_vowel(word:\
    \ \"yogurt\")\n/// \"u\"\n/// >>> get_closest_vowel(word: \"FULL\")\n/// \"U\"\
    \n/// >>> get_closest_vowel(word: \"quick\")\n/// \"\"\n/// >>> get_closest_vowel(word:\
    \ \"ab\")\n/// \"\"\nfunc get_closest_vowel(word: String) -> String {\n    let\
    \ vowels = \"aeiou\"\n    var minDistance = Int.max\n    var result = \"\"\n \
    \   for (i, char) in word.enumerated() {\n        if vowels.contains(char) {\n\
    \            var lastConsonantIndex = -1\n            for (j, char) in word.enumerated()\
    \ {\n                if (i != j) && (!vowels.contains(char)) {\n             \
    \       lastConsonantIndex = j\n                }\n            }\n           \
    \ if lastConsonantIndex != -1 {\n                let distance = i - lastConsonantIndex\n\
    \                if distance < minDistance {\n                    minDistance\
    \ = distance\n                    result = String(char)\n                }\n \
    \           }\n        }\n    }\n    return result\n}\n\n\nfunc ==(left: [(Int,\
    \ Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n\
    \        return false\n    }\n    for (l, r) in zip(left, right) {\n        if\
    \ l != r {\n            return false\n        }\n    }\n    return true\n}\n \
    \           \nassert(get_closest_vowel(word: \"yogurt\") == \"u\")\nassert(get_closest_vowel(word:\
    \ \"full\") == \"u\")\nassert(get_closest_vowel(word: \"easy\") == \"\")\nassert(get_closest_vowel(word:\
    \ \"eAsy\") == \"\")\nassert(get_closest_vowel(word: \"ali\") == \"\")\nassert(get_closest_vowel(word:\
    \ \"bad\") == \"a\")\nassert(get_closest_vowel(word: \"most\") == \"o\")\nassert(get_closest_vowel(word:\
    \ \"ab\") == \"\")\nassert(get_closest_vowel(word: \"ba\") == \"\")\nassert(get_closest_vowel(word:\
    \ \"quick\") == \"\")\nassert(get_closest_vowel(word: \"anime\") == \"i\")\nassert(get_closest_vowel(word:\
    \ \"Asia\") == \"\")\nassert(get_closest_vowel(word: \"Above\") == \"o\")"
  status: Exception
  stderr: 'tmpg17ywn60/tmpg17ywn60.swift:53: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b13d8645c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b13d833cb6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b13d833c988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b13d833b7b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpg17ywn60                        0x0000557df4f6b677 <unavailable> + 5751

    5    libc.so.6                          0x00002b13d8831460 __libc_start_main +
    245

    6    tmpg17ywn60                        0x0000557df4f6b2b9 <unavailable> + 4793

    '
  stdout: ''
  timestamp: 1660013568
- exit_code: 1
  program: "\n/// You are given a word. Your task is to find the closest vowel that\
    \ stands between \n/// two consonants from the right side of the word (case sensitive).\n\
    /// Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n/// find any vowel met the above condition. \n/// You may assume that\
    \ the given string contains English letter only.\n/// Example:\n/// >>> get_closest_vowel(word:\
    \ \"yogurt\")\n/// \"u\"\n/// >>> get_closest_vowel(word: \"FULL\")\n/// \"U\"\
    \n/// >>> get_closest_vowel(word: \"quick\")\n/// \"\"\n/// >>> get_closest_vowel(word:\
    \ \"ab\")\n/// \"\"\nfunc get_closest_vowel(word: String) -> String {\n\tlet vowels\
    \ = \"aeiou\"\n\tvar closest = \"\"\n\tvar index = 0\n\tfor var currentIndex =\
    \ word.count - 1; currentIndex >= 0; currentIndex -= 1 {\n\t\tlet currentChar\
    \ = word[word.index(word.startIndex, offsetBy: currentIndex)]\n\t\tif vowels.contains(currentChar)\
    \ {\n\t\t\tindex = currentIndex\n\t\t\tclosest = String(currentChar)\n\t\t\tbreak\n\
    \t\t}\n\t}\n\tif index > 0 {\n\t\tlet possibleIndex = index - 1\n\t\tlet possibleChar\
    \ = word[word.index(word.startIndex, offsetBy: possibleIndex)]\n\t\tif !vowels.contains(possibleChar)\
    \ {\n\t\t\treturn closest\n\t\t}\n\t}\n\treturn \"\"\n}\n\n\nfunc ==(left: [(Int,\
    \ Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n\
    \        return false\n    }\n    for (l, r) in zip(left, right) {\n        if\
    \ l != r {\n            return false\n        }\n    }\n    return true\n}\n \
    \           \nassert(get_closest_vowel(word: \"yogurt\") == \"u\")\nassert(get_closest_vowel(word:\
    \ \"full\") == \"u\")\nassert(get_closest_vowel(word: \"easy\") == \"\")\nassert(get_closest_vowel(word:\
    \ \"eAsy\") == \"\")\nassert(get_closest_vowel(word: \"ali\") == \"\")\nassert(get_closest_vowel(word:\
    \ \"bad\") == \"a\")\nassert(get_closest_vowel(word: \"most\") == \"o\")\nassert(get_closest_vowel(word:\
    \ \"ab\") == \"\")\nassert(get_closest_vowel(word: \"ba\") == \"\")\nassert(get_closest_vowel(word:\
    \ \"quick\") == \"\")\nassert(get_closest_vowel(word: \"anime\") == \"i\")\nassert(get_closest_vowel(word:\
    \ \"Asia\") == \"\")\nassert(get_closest_vowel(word: \"Above\") == \"o\")"
  status: SyntaxError
  stderr: "/tmp/tmp3gnxwpzk.swift:20:2: error: C-style for statement has been removed\
    \ in Swift 3\n        for var currentIndex = word.count - 1; currentIndex >= 0;\
    \ currentIndex -= 1 {\n        ^   ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n"
  stdout: ''
  timestamp: 1660013568
- exit_code: -4
  program: "\n/// You are given a word. Your task is to find the closest vowel that\
    \ stands between \n/// two consonants from the right side of the word (case sensitive).\n\
    /// Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n/// find any vowel met the above condition. \n/// You may assume that\
    \ the given string contains English letter only.\n/// Example:\n/// >>> get_closest_vowel(word:\
    \ \"yogurt\")\n/// \"u\"\n/// >>> get_closest_vowel(word: \"FULL\")\n/// \"U\"\
    \n/// >>> get_closest_vowel(word: \"quick\")\n/// \"\"\n/// >>> get_closest_vowel(word:\
    \ \"ab\")\n/// \"\"\nfunc get_closest_vowel(word: String) -> String {\n    var\
    \ i = 0\n    var startIndex = 0\n    var endIndex = 0\n    var minDistance = Int.max\n\
    \    var closestVowel = \"\"\n    let vowels = \"aeiou\"\n    let consonants =\
    \ \"bcdfghjklmnpqrstvwxyz\"\n    while i < word.count {\n        let idx = word.index(word.startIndex,\
    \ offsetBy: i)\n        if vowels.contains(word[idx]) {\n            let distance\
    \ = i - startIndex\n            if distance < minDistance {\n                minDistance\
    \ = distance\n                closestVowel = String(word[idx])\n            }\n\
    \        } else if consonants.contains(word[idx]) {\n            if i == word.count\
    \ - 1 {\n                break\n            }\n            startIndex = i\n  \
    \      }\n        i += 1\n    }\n    return closestVowel\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(get_closest_vowel(word: \"yogurt\") == \"u\")\nassert(get_closest_vowel(word:\
    \ \"full\") == \"u\")\nassert(get_closest_vowel(word: \"easy\") == \"\")\nassert(get_closest_vowel(word:\
    \ \"eAsy\") == \"\")\nassert(get_closest_vowel(word: \"ali\") == \"\")\nassert(get_closest_vowel(word:\
    \ \"bad\") == \"a\")\nassert(get_closest_vowel(word: \"most\") == \"o\")\nassert(get_closest_vowel(word:\
    \ \"ab\") == \"\")\nassert(get_closest_vowel(word: \"ba\") == \"\")\nassert(get_closest_vowel(word:\
    \ \"quick\") == \"\")\nassert(get_closest_vowel(word: \"anime\") == \"i\")\nassert(get_closest_vowel(word:\
    \ \"Asia\") == \"\")\nassert(get_closest_vowel(word: \"Above\") == \"o\")"
  status: Exception
  stderr: 'tmpza4w77i1/tmpza4w77i1.swift:56: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b100f099c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b100ed90b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b100ed90988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b100ed8f7b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpza4w77i1                        0x000055af26fb75d7 <unavailable> + 5591

    5    libc.so.6                          0x00002b100f285460 __libc_start_main +
    245

    6    tmpza4w77i1                        0x000055af26fb7219 <unavailable> + 4633

    '
  stdout: ''
  timestamp: 1660013568
- exit_code: -4
  program: "\n/// You are given a word. Your task is to find the closest vowel that\
    \ stands between \n/// two consonants from the right side of the word (case sensitive).\n\
    /// Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n/// find any vowel met the above condition. \n/// You may assume that\
    \ the given string contains English letter only.\n/// Example:\n/// >>> get_closest_vowel(word:\
    \ \"yogurt\")\n/// \"u\"\n/// >>> get_closest_vowel(word: \"FULL\")\n/// \"U\"\
    \n/// >>> get_closest_vowel(word: \"quick\")\n/// \"\"\n/// >>> get_closest_vowel(word:\
    \ \"ab\")\n/// \"\"\nfunc get_closest_vowel(word: String) -> String {\n    return\
    \ \"\"\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n  \
    \  if left.count != right.count {\n        return false\n    }\n    for (l, r)\
    \ in zip(left, right) {\n        if l != r {\n            return false\n     \
    \   }\n    }\n    return true\n}\n            \nassert(get_closest_vowel(word:\
    \ \"yogurt\") == \"u\")\nassert(get_closest_vowel(word: \"full\") == \"u\")\n\
    assert(get_closest_vowel(word: \"easy\") == \"\")\nassert(get_closest_vowel(word:\
    \ \"eAsy\") == \"\")\nassert(get_closest_vowel(word: \"ali\") == \"\")\nassert(get_closest_vowel(word:\
    \ \"bad\") == \"a\")\nassert(get_closest_vowel(word: \"most\") == \"o\")\nassert(get_closest_vowel(word:\
    \ \"ab\") == \"\")\nassert(get_closest_vowel(word: \"ba\") == \"\")\nassert(get_closest_vowel(word:\
    \ \"quick\") == \"\")\nassert(get_closest_vowel(word: \"anime\") == \"i\")\nassert(get_closest_vowel(word:\
    \ \"Asia\") == \"\")\nassert(get_closest_vowel(word: \"Above\") == \"o\")"
  status: Exception
  stderr: 'tmpvf1hzub_/tmpvf1hzub_.swift:33: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002ba694399c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002ba694090b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002ba694090988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002ba69408f7b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpvf1hzub_                        0x00005567315f8307 <unavailable> + 4871

    5    libc.so.6                          0x00002ba694585460 __libc_start_main +
    245

    6    tmpvf1hzub_                        0x00005567315f7f49 <unavailable> + 3913

    '
  stdout: ''
  timestamp: 1660013566
- exit_code: -4
  program: "\n/// You are given a word. Your task is to find the closest vowel that\
    \ stands between \n/// two consonants from the right side of the word (case sensitive).\n\
    /// Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n/// find any vowel met the above condition. \n/// You may assume that\
    \ the given string contains English letter only.\n/// Example:\n/// >>> get_closest_vowel(word:\
    \ \"yogurt\")\n/// \"u\"\n/// >>> get_closest_vowel(word: \"FULL\")\n/// \"U\"\
    \n/// >>> get_closest_vowel(word: \"quick\")\n/// \"\"\n/// >>> get_closest_vowel(word:\
    \ \"ab\")\n/// \"\"\nfunc get_closest_vowel(word: String) -> String {\n    var\
    \ vowel = \"\"\n    let cons = [\"b\", \"c\", \"d\", \"f\", \"g\", \"h\", \"j\"\
    , \"k\", \"l\", \"m\", \"n\", \"p\", \"q\", \"r\", \"s\", \"t\", \"v\", \"w\"\
    , \"x\", \"y\", \"z\"]\n    let vowels = [\"a\", \"e\", \"i\", \"o\", \"u\"]\n\
    \    for var i in 0...word.count-1 {\n        if vowels.contains(String(word[word.index(word.startIndex,\
    \ offsetBy: i)])) {\n            for var j in (i+1)...word.count-1 {\n       \
    \         if cons.contains(String(word[word.index(word.startIndex, offsetBy: j)]))\
    \ {\n                    vowel = String(word[word.index(word.startIndex, offsetBy:\
    \ i)])\n                    break\n                }\n            }\n        }\n\
    \    }\n    return vowel\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(get_closest_vowel(word:\
    \ \"yogurt\") == \"u\")\nassert(get_closest_vowel(word: \"full\") == \"u\")\n\
    assert(get_closest_vowel(word: \"easy\") == \"\")\nassert(get_closest_vowel(word:\
    \ \"eAsy\") == \"\")\nassert(get_closest_vowel(word: \"ali\") == \"\")\nassert(get_closest_vowel(word:\
    \ \"bad\") == \"a\")\nassert(get_closest_vowel(word: \"most\") == \"o\")\nassert(get_closest_vowel(word:\
    \ \"ab\") == \"\")\nassert(get_closest_vowel(word: \"ba\") == \"\")\nassert(get_closest_vowel(word:\
    \ \"quick\") == \"\")\nassert(get_closest_vowel(word: \"anime\") == \"i\")\nassert(get_closest_vowel(word:\
    \ \"Asia\") == \"\")\nassert(get_closest_vowel(word: \"Above\") == \"o\")"
  status: Exception
  stderr: 'tmpxic1pgb4/tmpxic1pgb4.swift:48: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b222e62ec80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b222e325b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b222e325988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b222e3247b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpxic1pgb4                        0x000055c0cfd31a33 <unavailable> + 6707

    5    libc.so.6                          0x00002b222e81a460 __libc_start_main +
    245

    6    tmpxic1pgb4                        0x000055c0cfd31469 <unavailable> + 5225

    '
  stdout: ''
  timestamp: 1660013568
- exit_code: -4
  program: "\n/// You are given a word. Your task is to find the closest vowel that\
    \ stands between \n/// two consonants from the right side of the word (case sensitive).\n\
    /// Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n/// find any vowel met the above condition. \n/// You may assume that\
    \ the given string contains English letter only.\n/// Example:\n/// >>> get_closest_vowel(word:\
    \ \"yogurt\")\n/// \"u\"\n/// >>> get_closest_vowel(word: \"FULL\")\n/// \"U\"\
    \n/// >>> get_closest_vowel(word: \"quick\")\n/// \"\"\n/// >>> get_closest_vowel(word:\
    \ \"ab\")\n/// \"\"\nfunc get_closest_vowel(word: String) -> String {\n    return\
    \ \"\"\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n  \
    \  if left.count != right.count {\n        return false\n    }\n    for (l, r)\
    \ in zip(left, right) {\n        if l != r {\n            return false\n     \
    \   }\n    }\n    return true\n}\n            \nassert(get_closest_vowel(word:\
    \ \"yogurt\") == \"u\")\nassert(get_closest_vowel(word: \"full\") == \"u\")\n\
    assert(get_closest_vowel(word: \"easy\") == \"\")\nassert(get_closest_vowel(word:\
    \ \"eAsy\") == \"\")\nassert(get_closest_vowel(word: \"ali\") == \"\")\nassert(get_closest_vowel(word:\
    \ \"bad\") == \"a\")\nassert(get_closest_vowel(word: \"most\") == \"o\")\nassert(get_closest_vowel(word:\
    \ \"ab\") == \"\")\nassert(get_closest_vowel(word: \"ba\") == \"\")\nassert(get_closest_vowel(word:\
    \ \"quick\") == \"\")\nassert(get_closest_vowel(word: \"anime\") == \"i\")\nassert(get_closest_vowel(word:\
    \ \"Asia\") == \"\")\nassert(get_closest_vowel(word: \"Above\") == \"o\")"
  status: Exception
  stderr: 'tmpvf1hzub_/tmpvf1hzub_.swift:33: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002ba694399c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002ba694090b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002ba694090988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002ba69408f7b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpvf1hzub_                        0x00005567315f8307 <unavailable> + 4871

    5    libc.so.6                          0x00002ba694585460 __libc_start_main +
    245

    6    tmpvf1hzub_                        0x00005567315f7f49 <unavailable> + 3913

    '
  stdout: ''
  timestamp: 1660013566
- exit_code: -4
  program: "\n/// You are given a word. Your task is to find the closest vowel that\
    \ stands between \n/// two consonants from the right side of the word (case sensitive).\n\
    /// Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n/// find any vowel met the above condition. \n/// You may assume that\
    \ the given string contains English letter only.\n/// Example:\n/// >>> get_closest_vowel(word:\
    \ \"yogurt\")\n/// \"u\"\n/// >>> get_closest_vowel(word: \"FULL\")\n/// \"U\"\
    \n/// >>> get_closest_vowel(word: \"quick\")\n/// \"\"\n/// >>> get_closest_vowel(word:\
    \ \"ab\")\n/// \"\"\nfunc get_closest_vowel(word: String) -> String {\n    //\
    \ TODO: Implement your solution here\n    let vowels = [\"a\", \"e\", \"i\", \"\
    o\", \"u\"]\n    var result = \"\"\n    var count = 0\n    for i in word.lowercased().reversed()\
    \ {\n        if vowels.contains(String(i)) {\n            if count > 1 {\n   \
    \             result = String(i)\n                break\n            }\n     \
    \   } else {\n            count += 1\n        }\n    }\n    return result\n}\n\
    \n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(get_closest_vowel(word: \"yogurt\") == \"u\")\n\
    assert(get_closest_vowel(word: \"full\") == \"u\")\nassert(get_closest_vowel(word:\
    \ \"easy\") == \"\")\nassert(get_closest_vowel(word: \"eAsy\") == \"\")\nassert(get_closest_vowel(word:\
    \ \"ali\") == \"\")\nassert(get_closest_vowel(word: \"bad\") == \"a\")\nassert(get_closest_vowel(word:\
    \ \"most\") == \"o\")\nassert(get_closest_vowel(word: \"ab\") == \"\")\nassert(get_closest_vowel(word:\
    \ \"ba\") == \"\")\nassert(get_closest_vowel(word: \"quick\") == \"\")\nassert(get_closest_vowel(word:\
    \ \"anime\") == \"i\")\nassert(get_closest_vowel(word: \"Asia\") == \"\")\nassert(get_closest_vowel(word:\
    \ \"Above\") == \"o\")"
  status: Exception
  stderr: 'tmpjgxnv2it/tmpjgxnv2it.swift:49: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b79f6505c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b79f61fcb6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b79f61fc988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b79f61fb7b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpjgxnv2it                        0x00005614301209d3 <unavailable> + 6611

    5    libc.so.6                          0x00002b79f66f1460 __libc_start_main +
    245

    6    tmpjgxnv2it                        0x0000561430120409 <unavailable> + 5129

    '
  stdout: ''
  timestamp: 1660013568
- exit_code: -4
  program: "\n/// You are given a word. Your task is to find the closest vowel that\
    \ stands between \n/// two consonants from the right side of the word (case sensitive).\n\
    /// Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n/// find any vowel met the above condition. \n/// You may assume that\
    \ the given string contains English letter only.\n/// Example:\n/// >>> get_closest_vowel(word:\
    \ \"yogurt\")\n/// \"u\"\n/// >>> get_closest_vowel(word: \"FULL\")\n/// \"U\"\
    \n/// >>> get_closest_vowel(word: \"quick\")\n/// \"\"\n/// >>> get_closest_vowel(word:\
    \ \"ab\")\n/// \"\"\nfunc get_closest_vowel(word: String) -> String {\n  /// TODO:\
    \ Write your implementation here\n  return \"\"\n}\n\n\nfunc ==(left: [(Int, Int)],\
    \ right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n       \
    \ return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r\
    \ {\n            return false\n        }\n    }\n    return true\n}\n        \
    \    \nassert(get_closest_vowel(word: \"yogurt\") == \"u\")\nassert(get_closest_vowel(word:\
    \ \"full\") == \"u\")\nassert(get_closest_vowel(word: \"easy\") == \"\")\nassert(get_closest_vowel(word:\
    \ \"eAsy\") == \"\")\nassert(get_closest_vowel(word: \"ali\") == \"\")\nassert(get_closest_vowel(word:\
    \ \"bad\") == \"a\")\nassert(get_closest_vowel(word: \"most\") == \"o\")\nassert(get_closest_vowel(word:\
    \ \"ab\") == \"\")\nassert(get_closest_vowel(word: \"ba\") == \"\")\nassert(get_closest_vowel(word:\
    \ \"quick\") == \"\")\nassert(get_closest_vowel(word: \"anime\") == \"i\")\nassert(get_closest_vowel(word:\
    \ \"Asia\") == \"\")\nassert(get_closest_vowel(word: \"Above\") == \"o\")"
  status: Exception
  stderr: 'tmp9243ldd8/tmp9243ldd8.swift:34: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b6426125c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b6425e1cb6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b6425e1c988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b6425e1b7b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmp9243ldd8                        0x000056484be5d307 <unavailable> + 4871

    5    libc.so.6                          0x00002b6426311460 __libc_start_main +
    245

    6    tmp9243ldd8                        0x000056484be5cf49 <unavailable> + 3913

    '
  stdout: ''
  timestamp: 1660013568
- exit_code: 1
  program: "\n/// You are given a word. Your task is to find the closest vowel that\
    \ stands between \n/// two consonants from the right side of the word (case sensitive).\n\
    /// Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n/// find any vowel met the above condition. \n/// You may assume that\
    \ the given string contains English letter only.\n/// Example:\n/// >>> get_closest_vowel(word:\
    \ \"yogurt\")\n/// \"u\"\n/// >>> get_closest_vowel(word: \"FULL\")\n/// \"U\"\
    \n/// >>> get_closest_vowel(word: \"quick\")\n/// \"\"\n/// >>> get_closest_vowel(word:\
    \ \"ab\")\n/// \"\"\nfunc get_closest_vowel(word: String) -> String {\n    let\
    \ vowels = \"aAeEiIoOuU\"\n    var vowelsIndex = [Int]()\n    var consonantsIndex\
    \ = [Int]()\n    var max = 0\n    var closest: Int = 0\n    for i in 0...word.count\
    \ - 1 {\n        if vowels.contains(word[i]) {\n            vowelsIndex.append(i)\n\
    \        } else {\n            consonantsIndex.append(i)\n        }\n    }\n \
    \   for i in 1...vowelsIndex.count - 1 {\n        if consonantsIndex.count < 2\
    \ {\n            return \"\"\n        }\n        if (vowelsIndex[i] - consonantsIndex[consonantsIndex.count\
    \ - 1]) < max {\n            closest = vowelsIndex[i]\n            max = vowelsIndex[i]\
    \ - consonantsIndex[consonantsIndex.count - 1]\n        }\n    }\n    return \"\
    \\(word[closest])\"\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) ->\
    \ Bool {\n    if left.count != right.count {\n        return false\n    }\n  \
    \  for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(get_closest_vowel(word:\
    \ \"yogurt\") == \"u\")\nassert(get_closest_vowel(word: \"full\") == \"u\")\n\
    assert(get_closest_vowel(word: \"easy\") == \"\")\nassert(get_closest_vowel(word:\
    \ \"eAsy\") == \"\")\nassert(get_closest_vowel(word: \"ali\") == \"\")\nassert(get_closest_vowel(word:\
    \ \"bad\") == \"a\")\nassert(get_closest_vowel(word: \"most\") == \"o\")\nassert(get_closest_vowel(word:\
    \ \"ab\") == \"\")\nassert(get_closest_vowel(word: \"ba\") == \"\")\nassert(get_closest_vowel(word:\
    \ \"quick\") == \"\")\nassert(get_closest_vowel(word: \"anime\") == \"i\")\nassert(get_closest_vowel(word:\
    \ \"Asia\") == \"\")\nassert(get_closest_vowel(word: \"Above\") == \"o\")"
  status: SyntaxError
  stderr: "/tmp/tmpjy5046_o.swift:23:28: error: 'subscript(_:)' is unavailable: cannot\
    \ subscript String with an Int, use a String.Index instead.\n        if vowels.contains(word[i])\
    \ {\n                           ^~~~~~~\nSwift.String:3:12: note: 'subscript(_:)'\
    \ has been explicitly marked unavailable here\n    public subscript(i: Int) ->\
    \ Character { get }\n           ^\n/tmp/tmpjy5046_o.swift:38:15: error: 'subscript(_:)'\
    \ is unavailable: cannot subscript String with an Int, use a String.Index instead.\n\
    \    return \"\\(word[closest])\"\n              ^~~~~~~~~~~~~\nSwift.String:3:12:\
    \ note: 'subscript(_:)' has been explicitly marked unavailable here\n    public\
    \ subscript(i: Int) -> Character { get }\n           ^\n"
  stdout: ''
  timestamp: 1660013568
- exit_code: -4
  program: "\n/// You are given a word. Your task is to find the closest vowel that\
    \ stands between \n/// two consonants from the right side of the word (case sensitive).\n\
    /// Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n/// find any vowel met the above condition. \n/// You may assume that\
    \ the given string contains English letter only.\n/// Example:\n/// >>> get_closest_vowel(word:\
    \ \"yogurt\")\n/// \"u\"\n/// >>> get_closest_vowel(word: \"FULL\")\n/// \"U\"\
    \n/// >>> get_closest_vowel(word: \"quick\")\n/// \"\"\n/// >>> get_closest_vowel(word:\
    \ \"ab\")\n/// \"\"\nfunc get_closest_vowel(word: String) -> String {\n    //\
    \ Write your code here\n    let vowels = [\"a\", \"e\", \"i\", \"o\", \"u\"]\n\
    \    var result: String = \"\"\n    let words = Array(word)\n    for index in\
    \ 0..<words.count {\n        if (words[index] != \"a\" && words[index] != \"e\"\
    \ && words[index] != \"i\" && words[index] != \"o\" && words[index] != \"u\")\
    \ {\n            for idx in index+1..<words.count {\n                if (words[idx]\
    \ == \"a\" || words[idx] == \"e\" || words[idx] == \"i\" || words[idx] == \"o\"\
    \ || words[idx] == \"u\") {\n                    result += String(words[idx])\n\
    \                    break\n                }\n            }\n        }\n    }\n\
    \    return result\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) ->\
    \ Bool {\n    if left.count != right.count {\n        return false\n    }\n  \
    \  for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(get_closest_vowel(word:\
    \ \"yogurt\") == \"u\")\nassert(get_closest_vowel(word: \"full\") == \"u\")\n\
    assert(get_closest_vowel(word: \"easy\") == \"\")\nassert(get_closest_vowel(word:\
    \ \"eAsy\") == \"\")\nassert(get_closest_vowel(word: \"ali\") == \"\")\nassert(get_closest_vowel(word:\
    \ \"bad\") == \"a\")\nassert(get_closest_vowel(word: \"most\") == \"o\")\nassert(get_closest_vowel(word:\
    \ \"ab\") == \"\")\nassert(get_closest_vowel(word: \"ba\") == \"\")\nassert(get_closest_vowel(word:\
    \ \"quick\") == \"\")\nassert(get_closest_vowel(word: \"anime\") == \"i\")\nassert(get_closest_vowel(word:\
    \ \"Asia\") == \"\")\nassert(get_closest_vowel(word: \"Above\") == \"o\")"
  status: Exception
  stderr: 'tmp32dd12rh/tmp32dd12rh.swift:47: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b35d3836c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b35d352db6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b35d352d988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b35d352c7b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmp32dd12rh                        0x000055d1ef77d8f7 <unavailable> + 6391

    5    libc.so.6                          0x00002b35d3a22460 __libc_start_main +
    245

    6    tmp32dd12rh                        0x000055d1ef77d539 <unavailable> + 5433

    '
  stdout: ''
  timestamp: 1660013568
- exit_code: -4
  program: "\n/// You are given a word. Your task is to find the closest vowel that\
    \ stands between \n/// two consonants from the right side of the word (case sensitive).\n\
    /// Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n/// find any vowel met the above condition. \n/// You may assume that\
    \ the given string contains English letter only.\n/// Example:\n/// >>> get_closest_vowel(word:\
    \ \"yogurt\")\n/// \"u\"\n/// >>> get_closest_vowel(word: \"FULL\")\n/// \"U\"\
    \n/// >>> get_closest_vowel(word: \"quick\")\n/// \"\"\n/// >>> get_closest_vowel(word:\
    \ \"ab\")\n/// \"\"\nfunc get_closest_vowel(word: String) -> String {\n    let\
    \ vowels = [\"a\", \"e\", \"i\", \"o\", \"u\"]\n    var closest_vowel = \"\"\n\
    \    let characters = Array(word)\n    for i in 0...characters.count - 1 {\n \
    \       if vowels.contains(String(characters[i])) {\n            if i + 1 < characters.count\
    \ {\n                if !vowels.contains(String(characters[i + 1])) {\n      \
    \              closest_vowel = String(characters[i])\n                    break\n\
    \                }\n            }\n        }\n    }\n    return closest_vowel\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(get_closest_vowel(word: \"yogurt\") == \"u\")\n\
    assert(get_closest_vowel(word: \"full\") == \"u\")\nassert(get_closest_vowel(word:\
    \ \"easy\") == \"\")\nassert(get_closest_vowel(word: \"eAsy\") == \"\")\nassert(get_closest_vowel(word:\
    \ \"ali\") == \"\")\nassert(get_closest_vowel(word: \"bad\") == \"a\")\nassert(get_closest_vowel(word:\
    \ \"most\") == \"o\")\nassert(get_closest_vowel(word: \"ab\") == \"\")\nassert(get_closest_vowel(word:\
    \ \"ba\") == \"\")\nassert(get_closest_vowel(word: \"quick\") == \"\")\nassert(get_closest_vowel(word:\
    \ \"anime\") == \"i\")\nassert(get_closest_vowel(word: \"Asia\") == \"\")\nassert(get_closest_vowel(word:\
    \ \"Above\") == \"o\")"
  status: Exception
  stderr: 'tmpa70bgwb3/tmpa70bgwb3.swift:46: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b9e67dc9c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b9e67ac0b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b9e67ac0988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b9e67abf7b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpa70bgwb3                        0x000055d526898847 <unavailable> + 6215

    5    libc.so.6                          0x00002b9e67fb5460 __libc_start_main +
    245

    6    tmpa70bgwb3                        0x000055d526898489 <unavailable> + 5257

    '
  stdout: ''
  timestamp: 1660013568
- exit_code: 1
  program: "\n/// You are given a word. Your task is to find the closest vowel that\
    \ stands between \n/// two consonants from the right side of the word (case sensitive).\n\
    /// Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n/// find any vowel met the above condition. \n/// You may assume that\
    \ the given string contains English letter only.\n/// Example:\n/// >>> get_closest_vowel(word:\
    \ \"yogurt\")\n/// \"u\"\n/// >>> get_closest_vowel(word: \"FULL\")\n/// \"U\"\
    \n/// >>> get_closest_vowel(word: \"quick\")\n/// \"\"\n/// >>> get_closest_vowel(word:\
    \ \"ab\")\n/// \"\"\nfunc get_closest_vowel(word: String) -> String {\n    var\
    \ vowel = \"\"\n    let vowels = [\"a\", \"e\", \"i\", \"o\", \"u\"]\n    let\
    \ consonants = [\"b\", \"c\", \"d\", \"f\", \"g\", \"h\", \"j\", \"k\", \"l\"\
    , \"m\", \"n\", \"p\", \"q\", \"r\", \"s\", \"t\", \"v\", \"w\", \"x\", \"y\"\
    , \"z\"]\n    var letter = Array(word)\n    var words = letter.filter { $0 !=\
    \ \" \" }\n    var count = words.count\n    while count > 1 {\n        if vowels.contains(words[count\
    \ - 1]) {\n            if vowels.contains(words[count - 2]) {\n              \
    \  vowel = words[count - 1].uppercased()\n                return vowel\n     \
    \       }\n        }\n        if consonants.contains(words[count - 1]) {\n   \
    \         if consonants.contains(words[count - 2]) {\n                vowel =\
    \ words[count - 1].uppercased()\n                return vowel\n            }\n\
    \        }\n        count -= 1\n    }\n    return vowel\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(get_closest_vowel(word: \"yogurt\") == \"u\")\nassert(get_closest_vowel(word:\
    \ \"full\") == \"u\")\nassert(get_closest_vowel(word: \"easy\") == \"\")\nassert(get_closest_vowel(word:\
    \ \"eAsy\") == \"\")\nassert(get_closest_vowel(word: \"ali\") == \"\")\nassert(get_closest_vowel(word:\
    \ \"bad\") == \"a\")\nassert(get_closest_vowel(word: \"most\") == \"o\")\nassert(get_closest_vowel(word:\
    \ \"ab\") == \"\")\nassert(get_closest_vowel(word: \"ba\") == \"\")\nassert(get_closest_vowel(word:\
    \ \"quick\") == \"\")\nassert(get_closest_vowel(word: \"anime\") == \"i\")\nassert(get_closest_vowel(word:\
    \ \"Asia\") == \"\")\nassert(get_closest_vowel(word: \"Above\") == \"o\")"
  status: SyntaxError
  stderr: "/tmp/tmpr9ftglgv.swift:24:33: error: cannot convert value of type 'String.Element'\
    \ (aka 'Character') to expected argument type 'String'\n        if vowels.contains(words[count\
    \ - 1]) {\n                                ^\n/tmp/tmpr9ftglgv.swift:25:37: error:\
    \ cannot convert value of type 'String.Element' (aka 'Character') to expected\
    \ argument type 'String'\n            if vowels.contains(words[count - 2]) {\n\
    \                                    ^\n/tmp/tmpr9ftglgv.swift:30:37: error: cannot\
    \ convert value of type 'String.Element' (aka 'Character') to expected argument\
    \ type 'String'\n        if consonants.contains(words[count - 1]) {\n        \
    \                            ^\n/tmp/tmpr9ftglgv.swift:31:41: error: cannot convert\
    \ value of type 'String.Element' (aka 'Character') to expected argument type 'String'\n\
    \            if consonants.contains(words[count - 2]) {\n                    \
    \                    ^\n"
  stdout: ''
  timestamp: 1660013568
- exit_code: -4
  program: "\n/// You are given a word. Your task is to find the closest vowel that\
    \ stands between \n/// two consonants from the right side of the word (case sensitive).\n\
    /// Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n/// find any vowel met the above condition. \n/// You may assume that\
    \ the given string contains English letter only.\n/// Example:\n/// >>> get_closest_vowel(word:\
    \ \"yogurt\")\n/// \"u\"\n/// >>> get_closest_vowel(word: \"FULL\")\n/// \"U\"\
    \n/// >>> get_closest_vowel(word: \"quick\")\n/// \"\"\n/// >>> get_closest_vowel(word:\
    \ \"ab\")\n/// \"\"\nfunc get_closest_vowel(word: String) -> String {\n    let\
    \ consonants = Set(\"bcdfghjklmnpqrstvwxyzBCDFGHJKLMNPQRSTVWXYZ\")\n    let vowels\
    \ = Set(\"aeiouAEIOU\")\n    var result = \"\"\n    var prev = \"\"\n    var next\
    \ = \"\"\n    var prevCount = 0\n    var nextCount = 0\n    for char in word.reversed()\
    \ {\n        if consonants.contains(char) {\n            prevCount += 1\n    \
    \        prev = char.description\n        } else if vowels.contains(char) {\n\
    \            if next == \"\" {\n                next = char.description\n    \
    \        }\n            nextCount += 1\n        }\n    }\n    if nextCount > prevCount\
    \ {\n        result = next\n    }\n    return result\n}\n\n\nfunc ==(left: [(Int,\
    \ Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n\
    \        return false\n    }\n    for (l, r) in zip(left, right) {\n        if\
    \ l != r {\n            return false\n        }\n    }\n    return true\n}\n \
    \           \nassert(get_closest_vowel(word: \"yogurt\") == \"u\")\nassert(get_closest_vowel(word:\
    \ \"full\") == \"u\")\nassert(get_closest_vowel(word: \"easy\") == \"\")\nassert(get_closest_vowel(word:\
    \ \"eAsy\") == \"\")\nassert(get_closest_vowel(word: \"ali\") == \"\")\nassert(get_closest_vowel(word:\
    \ \"bad\") == \"a\")\nassert(get_closest_vowel(word: \"most\") == \"o\")\nassert(get_closest_vowel(word:\
    \ \"ab\") == \"\")\nassert(get_closest_vowel(word: \"ba\") == \"\")\nassert(get_closest_vowel(word:\
    \ \"quick\") == \"\")\nassert(get_closest_vowel(word: \"anime\") == \"i\")\nassert(get_closest_vowel(word:\
    \ \"Asia\") == \"\")\nassert(get_closest_vowel(word: \"Above\") == \"o\")"
  status: Exception
  stderr: 'tmp4jsli42y/tmp4jsli42y.swift:54: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b726d04ec80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b726cd45b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b726cd45988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b726cd447b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmp4jsli42y                        0x000055fde9511747 <unavailable> + 5959

    5    libc.so.6                          0x00002b726d23a460 __libc_start_main +
    245

    6    tmp4jsli42y                        0x000055fde9511389 <unavailable> + 5001

    '
  stdout: ''
  timestamp: 1660013568
- exit_code: -4
  program: "\n/// You are given a word. Your task is to find the closest vowel that\
    \ stands between \n/// two consonants from the right side of the word (case sensitive).\n\
    /// Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n/// find any vowel met the above condition. \n/// You may assume that\
    \ the given string contains English letter only.\n/// Example:\n/// >>> get_closest_vowel(word:\
    \ \"yogurt\")\n/// \"u\"\n/// >>> get_closest_vowel(word: \"FULL\")\n/// \"U\"\
    \n/// >>> get_closest_vowel(word: \"quick\")\n/// \"\"\n/// >>> get_closest_vowel(word:\
    \ \"ab\")\n/// \"\"\nfunc get_closest_vowel(word: String) -> String {\n    return\
    \ \"\"\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n  \
    \  if left.count != right.count {\n        return false\n    }\n    for (l, r)\
    \ in zip(left, right) {\n        if l != r {\n            return false\n     \
    \   }\n    }\n    return true\n}\n            \nassert(get_closest_vowel(word:\
    \ \"yogurt\") == \"u\")\nassert(get_closest_vowel(word: \"full\") == \"u\")\n\
    assert(get_closest_vowel(word: \"easy\") == \"\")\nassert(get_closest_vowel(word:\
    \ \"eAsy\") == \"\")\nassert(get_closest_vowel(word: \"ali\") == \"\")\nassert(get_closest_vowel(word:\
    \ \"bad\") == \"a\")\nassert(get_closest_vowel(word: \"most\") == \"o\")\nassert(get_closest_vowel(word:\
    \ \"ab\") == \"\")\nassert(get_closest_vowel(word: \"ba\") == \"\")\nassert(get_closest_vowel(word:\
    \ \"quick\") == \"\")\nassert(get_closest_vowel(word: \"anime\") == \"i\")\nassert(get_closest_vowel(word:\
    \ \"Asia\") == \"\")\nassert(get_closest_vowel(word: \"Above\") == \"o\")"
  status: Exception
  stderr: 'tmpvf1hzub_/tmpvf1hzub_.swift:33: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002ba694399c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002ba694090b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002ba694090988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002ba69408f7b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpvf1hzub_                        0x00005567315f8307 <unavailable> + 4871

    5    libc.so.6                          0x00002ba694585460 __libc_start_main +
    245

    6    tmpvf1hzub_                        0x00005567315f7f49 <unavailable> + 3913

    '
  stdout: ''
  timestamp: 1660013566
- exit_code: -4
  program: "\n/// You are given a word. Your task is to find the closest vowel that\
    \ stands between \n/// two consonants from the right side of the word (case sensitive).\n\
    /// Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n/// find any vowel met the above condition. \n/// You may assume that\
    \ the given string contains English letter only.\n/// Example:\n/// >>> get_closest_vowel(word:\
    \ \"yogurt\")\n/// \"u\"\n/// >>> get_closest_vowel(word: \"FULL\")\n/// \"U\"\
    \n/// >>> get_closest_vowel(word: \"quick\")\n/// \"\"\n/// >>> get_closest_vowel(word:\
    \ \"ab\")\n/// \"\"\nfunc get_closest_vowel(word: String) -> String {\n    let\
    \ vowels = [\"a\", \"e\", \"i\", \"o\", \"u\"]\n    let word = word.lowercased()\n\
    \    var index = 0\n    var found = false\n    while index < word.count - 1 {\n\
    \        let start = word.index(word.startIndex, offsetBy: index)\n        let\
    \ end = word.index(word.startIndex, offsetBy: index + 1)\n        let range =\
    \ start..<end\n        let pair = String(word[range])\n        if vowels.contains(pair)\
    \ {\n            if index + 2 < word.count {\n                let start = word.index(word.startIndex,\
    \ offsetBy: index + 2)\n                let end = word.index(word.startIndex,\
    \ offsetBy: index + 3)\n                let range = start..<end\n            \
    \    let letter = String(word[range])\n                if !vowels.contains(letter)\
    \ {\n                    found = true\n                    break\n           \
    \     }\n            }\n        }\n        index += 1\n    }\n    if !found {\n\
    \        return \"\"\n    }\n    let start = word.index(word.startIndex, offsetBy:\
    \ index)\n    let end = word.index(word.startIndex, offsetBy: index + 1)\n   \
    \ let range = start..<end\n    return String(word[range])\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(get_closest_vowel(word: \"yogurt\") == \"u\")\nassert(get_closest_vowel(word:\
    \ \"full\") == \"u\")\nassert(get_closest_vowel(word: \"easy\") == \"\")\nassert(get_closest_vowel(word:\
    \ \"eAsy\") == \"\")\nassert(get_closest_vowel(word: \"ali\") == \"\")\nassert(get_closest_vowel(word:\
    \ \"bad\") == \"a\")\nassert(get_closest_vowel(word: \"most\") == \"o\")\nassert(get_closest_vowel(word:\
    \ \"ab\") == \"\")\nassert(get_closest_vowel(word: \"ba\") == \"\")\nassert(get_closest_vowel(word:\
    \ \"quick\") == \"\")\nassert(get_closest_vowel(word: \"anime\") == \"i\")\nassert(get_closest_vowel(word:\
    \ \"Asia\") == \"\")\nassert(get_closest_vowel(word: \"Above\") == \"o\")"
  status: Exception
  stderr: 'tmp2r5ms0wu/tmp2r5ms0wu.swift:64: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b2bf5572c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b2bf5269b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b2bf5269988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b2bf52687b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmp2r5ms0wu                        0x0000561cd5f749a3 <unavailable> + 6563

    5    libc.so.6                          0x00002b2bf575e460 __libc_start_main +
    245

    6    tmp2r5ms0wu                        0x0000561cd5f743d9 <unavailable> + 5081

    '
  stdout: ''
  timestamp: 1660013568
- exit_code: -4
  program: "\n/// You are given a word. Your task is to find the closest vowel that\
    \ stands between \n/// two consonants from the right side of the word (case sensitive).\n\
    /// Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n/// find any vowel met the above condition. \n/// You may assume that\
    \ the given string contains English letter only.\n/// Example:\n/// >>> get_closest_vowel(word:\
    \ \"yogurt\")\n/// \"u\"\n/// >>> get_closest_vowel(word: \"FULL\")\n/// \"U\"\
    \n/// >>> get_closest_vowel(word: \"quick\")\n/// \"\"\n/// >>> get_closest_vowel(word:\
    \ \"ab\")\n/// \"\"\nfunc get_closest_vowel(word: String) -> String {\n    if\
    \ word.isEmpty {\n        return \"\"\n    }\n    let vowels = [\"a\", \"e\",\
    \ \"i\", \"o\", \"u\"]\n    var find_vowel = false\n    var closest_vowel = \"\
    \"\n    var index = word.endIndex\n    while !find_vowel && index > word.startIndex\
    \ {\n        index = word.index(before: index)\n        if vowels.contains(String(word[index]))\
    \ {\n            find_vowel = true\n            closest_vowel = String(word[index])\n\
    \        }\n    }\n    return closest_vowel\n}\n\n\nfunc ==(left: [(Int, Int)],\
    \ right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n       \
    \ return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r\
    \ {\n            return false\n        }\n    }\n    return true\n}\n        \
    \    \nassert(get_closest_vowel(word: \"yogurt\") == \"u\")\nassert(get_closest_vowel(word:\
    \ \"full\") == \"u\")\nassert(get_closest_vowel(word: \"easy\") == \"\")\nassert(get_closest_vowel(word:\
    \ \"eAsy\") == \"\")\nassert(get_closest_vowel(word: \"ali\") == \"\")\nassert(get_closest_vowel(word:\
    \ \"bad\") == \"a\")\nassert(get_closest_vowel(word: \"most\") == \"o\")\nassert(get_closest_vowel(word:\
    \ \"ab\") == \"\")\nassert(get_closest_vowel(word: \"ba\") == \"\")\nassert(get_closest_vowel(word:\
    \ \"quick\") == \"\")\nassert(get_closest_vowel(word: \"anime\") == \"i\")\nassert(get_closest_vowel(word:\
    \ \"Asia\") == \"\")\nassert(get_closest_vowel(word: \"Above\") == \"o\")"
  status: Exception
  stderr: 'tmp8rvu_xfm/tmp8rvu_xfm.swift:49: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002acedd181c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002acedce78b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002acedce78988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002acedce777b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmp8rvu_xfm                        0x000055c8a25fb9d3 <unavailable> + 6611

    5    libc.so.6                          0x00002acedd36d460 __libc_start_main +
    245

    6    tmp8rvu_xfm                        0x000055c8a25fb409 <unavailable> + 5129

    '
  stdout: ''
  timestamp: 1660013568
- exit_code: 1
  program: "\n/// You are given a word. Your task is to find the closest vowel that\
    \ stands between \n/// two consonants from the right side of the word (case sensitive).\n\
    /// Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n/// find any vowel met the above condition. \n/// You may assume that\
    \ the given string contains English letter only.\n/// Example:\n/// >>> get_closest_vowel(word:\
    \ \"yogurt\")\n/// \"u\"\n/// >>> get_closest_vowel(word: \"FULL\")\n/// \"U\"\
    \n/// >>> get_closest_vowel(word: \"quick\")\n/// \"\"\n/// >>> get_closest_vowel(word:\
    \ \"ab\")\n/// \"\"\nfunc get_closest_vowel(word: String) -> String {\n    var\
    \ vowel = \"\"\n    var target_found = false\n    for i in 0..<word.count {\n\
    \        if is_vowel(word[i]) {\n            target_found = true\n           \
    \ vowel = String(word[i])\n        } else if target_found {\n            if i\
    \ == word.count - 1 {\n                return vowel\n            } else if is_vowel(word[i\
    \ + 1]) {\n                continue\n            } else {\n                return\
    \ vowel\n            }\n        }\n    }\n    return \"\"\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(get_closest_vowel(word: \"yogurt\") == \"u\")\nassert(get_closest_vowel(word:\
    \ \"full\") == \"u\")\nassert(get_closest_vowel(word: \"easy\") == \"\")\nassert(get_closest_vowel(word:\
    \ \"eAsy\") == \"\")\nassert(get_closest_vowel(word: \"ali\") == \"\")\nassert(get_closest_vowel(word:\
    \ \"bad\") == \"a\")\nassert(get_closest_vowel(word: \"most\") == \"o\")\nassert(get_closest_vowel(word:\
    \ \"ab\") == \"\")\nassert(get_closest_vowel(word: \"ba\") == \"\")\nassert(get_closest_vowel(word:\
    \ \"quick\") == \"\")\nassert(get_closest_vowel(word: \"anime\") == \"i\")\nassert(get_closest_vowel(word:\
    \ \"Asia\") == \"\")\nassert(get_closest_vowel(word: \"Above\") == \"o\")"
  status: SyntaxError
  stderr: "/tmp/tmp7frrv78m.swift:20:12: error: cannot find 'is_vowel' in scope\n\
    \        if is_vowel(word[i]) {\n           ^~~~~~~~\n/tmp/tmp7frrv78m.swift:22:28:\
    \ error: 'subscript(_:)' is unavailable: cannot subscript String with an Int,\
    \ use a String.Index instead.\n            vowel = String(word[i])\n         \
    \                  ^~~~~~~\nSwift.String:3:12: note: 'subscript(_:)' has been\
    \ explicitly marked unavailable here\n    public subscript(i: Int) -> Character\
    \ { get }\n           ^\n/tmp/tmp7frrv78m.swift:26:23: error: cannot find 'is_vowel'\
    \ in scope\n            } else if is_vowel(word[i + 1]) {\n                  \
    \    ^~~~~~~~\n"
  stdout: ''
  timestamp: 1660013568
- exit_code: -4
  program: "\n/// You are given a word. Your task is to find the closest vowel that\
    \ stands between \n/// two consonants from the right side of the word (case sensitive).\n\
    /// Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n/// find any vowel met the above condition. \n/// You may assume that\
    \ the given string contains English letter only.\n/// Example:\n/// >>> get_closest_vowel(word:\
    \ \"yogurt\")\n/// \"u\"\n/// >>> get_closest_vowel(word: \"FULL\")\n/// \"U\"\
    \n/// >>> get_closest_vowel(word: \"quick\")\n/// \"\"\n/// >>> get_closest_vowel(word:\
    \ \"ab\")\n/// \"\"\nfunc get_closest_vowel(word: String) -> String {\n    let\
    \ vowels = [\"a\", \"e\", \"i\", \"o\", \"u\"]\n    let word1 = word.lowercased()\n\
    \    var nextConsonant = true\n    var found = \"\"\n    for i in 0...word1.count-1\
    \ {\n        let index = word1.index(word1.startIndex, offsetBy: i)\n        let\
    \ c = String(word1[index])\n        if vowels.contains(c) {\n            if nextConsonant\
    \ {\n                found = c\n                nextConsonant = false\n      \
    \      }\n        } else {\n            nextConsonant = true\n        }\n    }\n\
    \    return found\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) ->\
    \ Bool {\n    if left.count != right.count {\n        return false\n    }\n  \
    \  for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(get_closest_vowel(word:\
    \ \"yogurt\") == \"u\")\nassert(get_closest_vowel(word: \"full\") == \"u\")\n\
    assert(get_closest_vowel(word: \"easy\") == \"\")\nassert(get_closest_vowel(word:\
    \ \"eAsy\") == \"\")\nassert(get_closest_vowel(word: \"ali\") == \"\")\nassert(get_closest_vowel(word:\
    \ \"bad\") == \"a\")\nassert(get_closest_vowel(word: \"most\") == \"o\")\nassert(get_closest_vowel(word:\
    \ \"ab\") == \"\")\nassert(get_closest_vowel(word: \"ba\") == \"\")\nassert(get_closest_vowel(word:\
    \ \"quick\") == \"\")\nassert(get_closest_vowel(word: \"anime\") == \"i\")\nassert(get_closest_vowel(word:\
    \ \"Asia\") == \"\")\nassert(get_closest_vowel(word: \"Above\") == \"o\")"
  status: Exception
  stderr: 'tmpgi7ax75_/tmpgi7ax75_.swift:51: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b1f3664bc80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b1f36342b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b1f36342988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b1f363417b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpgi7ax75_                        0x000056308d09da83 <unavailable> + 6787

    5    libc.so.6                          0x00002b1f36837460 __libc_start_main +
    245

    6    tmpgi7ax75_                        0x000056308d09d4b9 <unavailable> + 5305

    '
  stdout: ''
  timestamp: 1660013568
- exit_code: -4
  program: "\n/// You are given a word. Your task is to find the closest vowel that\
    \ stands between \n/// two consonants from the right side of the word (case sensitive).\n\
    /// Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n/// find any vowel met the above condition. \n/// You may assume that\
    \ the given string contains English letter only.\n/// Example:\n/// >>> get_closest_vowel(word:\
    \ \"yogurt\")\n/// \"u\"\n/// >>> get_closest_vowel(word: \"FULL\")\n/// \"U\"\
    \n/// >>> get_closest_vowel(word: \"quick\")\n/// \"\"\n/// >>> get_closest_vowel(word:\
    \ \"ab\")\n/// \"\"\nfunc get_closest_vowel(word: String) -> String {\n\tlet vowels\
    \ = \"AEIOUaeiou\"\n\tvar closest_vowel: String = \"\"\n\tfor i in 1..<word.count\
    \ {\n\t\tlet index = word.index(word.endIndex, offsetBy: -i)\n\t\tlet start_consonant\
    \ = word[word.index(before: index)]\n\t\tlet end_consonant = word[index]\n\t\t\
    if vowels.contains(start_consonant) == false && vowels.contains(end_consonant)\
    \ == false {\n\t\t\tfor j in 1..<i {\n\t\t\t\tlet vowel_index = word.index(word.endIndex,\
    \ offsetBy: -(i - j))\n\t\t\t\tlet vowel = word[vowel_index]\n\t\t\t\tif vowels.contains(vowel)\
    \ {\n\t\t\t\t\tclosest_vowel = String(vowel)\n\t\t\t\t\tbreak\n\t\t\t\t}\n\t\t\
    \t}\n\t\t\tbreak\n\t\t}\n\t}\n\treturn closest_vowel\n}\n\n\nfunc ==(left: [(Int,\
    \ Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n\
    \        return false\n    }\n    for (l, r) in zip(left, right) {\n        if\
    \ l != r {\n            return false\n        }\n    }\n    return true\n}\n \
    \           \nassert(get_closest_vowel(word: \"yogurt\") == \"u\")\nassert(get_closest_vowel(word:\
    \ \"full\") == \"u\")\nassert(get_closest_vowel(word: \"easy\") == \"\")\nassert(get_closest_vowel(word:\
    \ \"eAsy\") == \"\")\nassert(get_closest_vowel(word: \"ali\") == \"\")\nassert(get_closest_vowel(word:\
    \ \"bad\") == \"a\")\nassert(get_closest_vowel(word: \"most\") == \"o\")\nassert(get_closest_vowel(word:\
    \ \"ab\") == \"\")\nassert(get_closest_vowel(word: \"ba\") == \"\")\nassert(get_closest_vowel(word:\
    \ \"quick\") == \"\")\nassert(get_closest_vowel(word: \"anime\") == \"i\")\nassert(get_closest_vowel(word:\
    \ \"Asia\") == \"\")\nassert(get_closest_vowel(word: \"Above\") == \"o\")"
  status: Exception
  stderr: 'tmpkfo3npqm/tmpkfo3npqm.swift:51: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002ab7f056ec80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002ab7f0265b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002ab7f0265988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002ab7f02647b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpkfo3npqm                        0x000055eb9d8d37b7 <unavailable> + 6071

    5    libc.so.6                          0x00002ab7f075a460 __libc_start_main +
    245

    6    tmpkfo3npqm                        0x000055eb9d8d33f9 <unavailable> + 5113

    '
  stdout: ''
  timestamp: 1660013568
- exit_code: -4
  program: "\n/// You are given a word. Your task is to find the closest vowel that\
    \ stands between \n/// two consonants from the right side of the word (case sensitive).\n\
    /// Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n/// find any vowel met the above condition. \n/// You may assume that\
    \ the given string contains English letter only.\n/// Example:\n/// >>> get_closest_vowel(word:\
    \ \"yogurt\")\n/// \"u\"\n/// >>> get_closest_vowel(word: \"FULL\")\n/// \"U\"\
    \n/// >>> get_closest_vowel(word: \"quick\")\n/// \"\"\n/// >>> get_closest_vowel(word:\
    \ \"ab\")\n/// \"\"\nfunc get_closest_vowel(word: String) -> String {\n    let\
    \ vowels = [\"a\", \"e\", \"i\", \"o\", \"u\"]\n    let consonants = [\"b\", \"\
    c\", \"d\", \"f\", \"g\", \"h\", \"j\", \"k\", \"l\", \"m\", \"n\", \"p\", \"\
    q\", \"r\", \"s\", \"t\", \"v\", \"w\", \"x\", \"y\", \"z\"]\n    let array =\
    \ Array(word)\n    var i = 0\n    for i in 0...array.count-1 {\n        if let\
    \ _ = consonants.index(of: String(array[i]).lowercased()) {\n            break\n\
    \        }\n    }\n    for j in i+1...array.count-1 {\n        if let _ = vowels.index(of:\
    \ String(array[j]).lowercased()) {\n            return String(array[j])\n    \
    \    }\n    }\n    return \"\"\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int,\
    \ Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n\
    \    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n          \
    \  return false\n        }\n    }\n    return true\n}\n            \nassert(get_closest_vowel(word:\
    \ \"yogurt\") == \"u\")\nassert(get_closest_vowel(word: \"full\") == \"u\")\n\
    assert(get_closest_vowel(word: \"easy\") == \"\")\nassert(get_closest_vowel(word:\
    \ \"eAsy\") == \"\")\nassert(get_closest_vowel(word: \"ali\") == \"\")\nassert(get_closest_vowel(word:\
    \ \"bad\") == \"a\")\nassert(get_closest_vowel(word: \"most\") == \"o\")\nassert(get_closest_vowel(word:\
    \ \"ab\") == \"\")\nassert(get_closest_vowel(word: \"ba\") == \"\")\nassert(get_closest_vowel(word:\
    \ \"quick\") == \"\")\nassert(get_closest_vowel(word: \"anime\") == \"i\")\nassert(get_closest_vowel(word:\
    \ \"Asia\") == \"\")\nassert(get_closest_vowel(word: \"Above\") == \"o\")"
  status: Exception
  stderr: 'tmpn5071ftu/tmpn5071ftu.swift:47: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002acba4605c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002acba42fcb6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002acba42fc988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002acba42fb7b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpn5071ftu                        0x00005631971b08e7 <unavailable> + 6375

    5    libc.so.6                          0x00002acba47f1460 __libc_start_main +
    245

    6    tmpn5071ftu                        0x00005631971b0529 <unavailable> + 5417

    '
  stdout: ''
  timestamp: 1660013568
- exit_code: 1
  program: "\n/// You are given a word. Your task is to find the closest vowel that\
    \ stands between \n/// two consonants from the right side of the word (case sensitive).\n\
    /// Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n/// find any vowel met the above condition. \n/// You may assume that\
    \ the given string contains English letter only.\n/// Example:\n/// >>> get_closest_vowel(word:\
    \ \"yogurt\")\n/// \"u\"\n/// >>> get_closest_vowel(word: \"FULL\")\n/// \"U\"\
    \n/// >>> get_closest_vowel(word: \"quick\")\n/// \"\"\n/// >>> get_closest_vowel(word:\
    \ \"ab\")\n/// \"\"\nfunc get_closest_vowel(word: String) -> String {\n    let\
    \ word = word.lowercased()\n    var closest_vowel = \"\"\n    var closest_distance\
    \ = Int.max\n    let vowels = [\"a\", \"e\", \"i\", \"o\", \"u\"]\n    for (i,\
    \ char) in word.characters.enumerated() {\n        // not vowel, but we're looking\
    \ for vowel, so skip\n        if !vowels.contains(String(char)) {\n          \
    \  continue\n        }\n        let prefix = String(word.characters.prefix(i))\n\
    \        let suffix = String(word.characters.suffix(word.characters.count - i))\n\
    \        // character is vowel, but it's in the beginning or end of the word,\
    \ skip\n        if !suffix.contains(\"a\") && !suffix.contains(\"e\") && !suffix.contains(\"\
    i\") && !suffix.contains(\"o\") && !suffix.contains(\"u\") {\n            continue\n\
    \        }\n        // we have both vowels and consonants, so we have a contender\n\
    \        let distance = word.characters.count - suffix.characters.count\n    \
    \    if distance < closest_distance {\n            closest_distance = distance\n\
    \            closest_vowel = String(char)\n        }\n    }\n    return closest_vowel\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(get_closest_vowel(word: \"yogurt\") == \"u\")\n\
    assert(get_closest_vowel(word: \"full\") == \"u\")\nassert(get_closest_vowel(word:\
    \ \"easy\") == \"\")\nassert(get_closest_vowel(word: \"eAsy\") == \"\")\nassert(get_closest_vowel(word:\
    \ \"ali\") == \"\")\nassert(get_closest_vowel(word: \"bad\") == \"a\")\nassert(get_closest_vowel(word:\
    \ \"most\") == \"o\")\nassert(get_closest_vowel(word: \"ab\") == \"\")\nassert(get_closest_vowel(word:\
    \ \"ba\") == \"\")\nassert(get_closest_vowel(word: \"quick\") == \"\")\nassert(get_closest_vowel(word:\
    \ \"anime\") == \"i\")\nassert(get_closest_vowel(word: \"Asia\") == \"\")\nassert(get_closest_vowel(word:\
    \ \"Above\") == \"o\")"
  status: SyntaxError
  stderr: "/tmp/tmpt1m53b18.swift:21:27: error: 'characters' is unavailable: Please\
    \ use String directly\n    for (i, char) in word.characters.enumerated() {\n \
    \                         ^~~~~~~~~~\nSwift.String:5:16: note: 'characters' was\
    \ obsoleted in Swift 5.0\n    public var characters: String { get set }\n    \
    \           ^\n/tmp/tmpt1m53b18.swift:26:34: error: 'characters' is unavailable:\
    \ Please use String directly\n        let prefix = String(word.characters.prefix(i))\n\
    \                                 ^~~~~~~~~~\nSwift.String:5:16: note: 'characters'\
    \ was obsoleted in Swift 5.0\n    public var characters: String { get set }\n\
    \               ^\n/tmp/tmpt1m53b18.swift:27:34: error: 'characters' is unavailable:\
    \ Please use String directly\n        let suffix = String(word.characters.suffix(word.characters.count\
    \ - i))\n                                 ^~~~~~~~~~\nSwift.String:5:16: note:\
    \ 'characters' was obsoleted in Swift 5.0\n    public var characters: String {\
    \ get set }\n               ^\n/tmp/tmpt1m53b18.swift:27:57: error: 'characters'\
    \ is unavailable: Please use String directly\n        let suffix = String(word.characters.suffix(word.characters.count\
    \ - i))\n                                                        ^~~~~~~~~~\n\
    Swift.String:5:16: note: 'characters' was obsoleted in Swift 5.0\n    public var\
    \ characters: String { get set }\n               ^\n/tmp/tmpt1m53b18.swift:33:29:\
    \ error: 'characters' is unavailable: Please use String directly\n        let\
    \ distance = word.characters.count - suffix.characters.count\n               \
    \             ^~~~~~~~~~\nSwift.String:5:16: note: 'characters' was obsoleted\
    \ in Swift 5.0\n    public var characters: String { get set }\n              \
    \ ^\n/tmp/tmpt1m53b18.swift:33:55: error: 'characters' is unavailable: Please\
    \ use String directly\n        let distance = word.characters.count - suffix.characters.count\n\
    \                                                      ^~~~~~~~~~\nSwift.String:5:16:\
    \ note: 'characters' was obsoleted in Swift 5.0\n    public var characters: String\
    \ { get set }\n               ^\n/tmp/tmpt1m53b18.sw"
  stdout: ''
  timestamp: 1660013568
- exit_code: -4
  program: "\n/// You are given a word. Your task is to find the closest vowel that\
    \ stands between \n/// two consonants from the right side of the word (case sensitive).\n\
    /// Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n/// find any vowel met the above condition. \n/// You may assume that\
    \ the given string contains English letter only.\n/// Example:\n/// >>> get_closest_vowel(word:\
    \ \"yogurt\")\n/// \"u\"\n/// >>> get_closest_vowel(word: \"FULL\")\n/// \"U\"\
    \n/// >>> get_closest_vowel(word: \"quick\")\n/// \"\"\n/// >>> get_closest_vowel(word:\
    \ \"ab\")\n/// \"\"\nfunc get_closest_vowel(word: String) -> String {\n    let\
    \ vowels = \"aeiou\"\n    let consonants = \"bcdfghjklmnpqrstvwxyz\"\n    var\
    \ result = \"\"\n    for (index, char) in word.enumerated() {\n        var next_letter_consonant\
    \ = false\n        if index < word.count - 1 {\n            let next_letter =\
    \ word[word.index(word.startIndex, offsetBy: index + 1)]\n            next_letter_consonant\
    \ = consonants.contains(next_letter)\n        }\n        if vowels.contains(char)\
    \ && next_letter_consonant {\n            result = String(char)\n            break\n\
    \        }\n    }\n    return result\n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(get_closest_vowel(word: \"yogurt\") == \"u\")\nassert(get_closest_vowel(word:\
    \ \"full\") == \"u\")\nassert(get_closest_vowel(word: \"easy\") == \"\")\nassert(get_closest_vowel(word:\
    \ \"eAsy\") == \"\")\nassert(get_closest_vowel(word: \"ali\") == \"\")\nassert(get_closest_vowel(word:\
    \ \"bad\") == \"a\")\nassert(get_closest_vowel(word: \"most\") == \"o\")\nassert(get_closest_vowel(word:\
    \ \"ab\") == \"\")\nassert(get_closest_vowel(word: \"ba\") == \"\")\nassert(get_closest_vowel(word:\
    \ \"quick\") == \"\")\nassert(get_closest_vowel(word: \"anime\") == \"i\")\nassert(get_closest_vowel(word:\
    \ \"Asia\") == \"\")\nassert(get_closest_vowel(word: \"Above\") == \"o\")"
  status: Exception
  stderr: 'tmp86d3tuz0/tmp86d3tuz0.swift:47: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002ae461649c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002ae461340b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002ae461340988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002ae46133f7b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmp86d3tuz0                        0x00005583485a77e7 <unavailable> + 6119

    5    libc.so.6                          0x00002ae461835460 __libc_start_main +
    245

    6    tmp86d3tuz0                        0x00005583485a7429 <unavailable> + 5161

    '
  stdout: ''
  timestamp: 1660013569
- exit_code: -4
  program: "\n/// You are given a word. Your task is to find the closest vowel that\
    \ stands between \n/// two consonants from the right side of the word (case sensitive).\n\
    /// Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n/// find any vowel met the above condition. \n/// You may assume that\
    \ the given string contains English letter only.\n/// Example:\n/// >>> get_closest_vowel(word:\
    \ \"yogurt\")\n/// \"u\"\n/// >>> get_closest_vowel(word: \"FULL\")\n/// \"U\"\
    \n/// >>> get_closest_vowel(word: \"quick\")\n/// \"\"\n/// >>> get_closest_vowel(word:\
    \ \"ab\")\n/// \"\"\nfunc get_closest_vowel(word: String) -> String {\n    let\
    \ vowels = \"AEIOUaeiou\"\n    let consonants = \"bcdfghjklmnpqrstvwxyzBCDFGHJKLMNPQRSTVWXYZ\"\
    \n    let word_arr = Array(word)\n    var vowel_arr = [String]()\n    var consonant_arr\
    \ = [String]()\n    var result = \"\"\n    if vowels.contains(word[word.startIndex])\
    \ || vowels.contains(word[word.index(before: word.endIndex)]){\n        return\
    \ \"\"\n    }\n    for i in word_arr{\n        if vowels.contains(i){\n      \
    \      vowel_arr.append(String(i))\n        }\n        if consonants.contains(i){\n\
    \            consonant_arr.append(String(i))\n        }\n    }\n    for i in 0..<consonant_arr.count\
    \ - 1{\n        if consonant_arr[i] != consonant_arr[i + 1]{\n            result\
    \ = vowel_arr[i]\n            break\n        }\n    }\n    return result\n}\n\n\
    \nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(get_closest_vowel(word: \"yogurt\") == \"u\")\n\
    assert(get_closest_vowel(word: \"full\") == \"u\")\nassert(get_closest_vowel(word:\
    \ \"easy\") == \"\")\nassert(get_closest_vowel(word: \"eAsy\") == \"\")\nassert(get_closest_vowel(word:\
    \ \"ali\") == \"\")\nassert(get_closest_vowel(word: \"bad\") == \"a\")\nassert(get_closest_vowel(word:\
    \ \"most\") == \"o\")\nassert(get_closest_vowel(word: \"ab\") == \"\")\nassert(get_closest_vowel(word:\
    \ \"ba\") == \"\")\nassert(get_closest_vowel(word: \"quick\") == \"\")\nassert(get_closest_vowel(word:\
    \ \"anime\") == \"i\")\nassert(get_closest_vowel(word: \"Asia\") == \"\")\nassert(get_closest_vowel(word:\
    \ \"Above\") == \"o\")"
  status: Exception
  stderr: 'tmpi5ix3jt4/tmpi5ix3jt4.swift:56: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b2bc7af3c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b2bc77eab6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b2bc77ea988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b2bc77e97b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpi5ix3jt4                        0x000055e327080b17 <unavailable> + 6935

    5    libc.so.6                          0x00002b2bc7cdf460 __libc_start_main +
    245

    6    tmpi5ix3jt4                        0x000055e327080759 <unavailable> + 5977

    '
  stdout: ''
  timestamp: 1660013569
- exit_code: 1
  program: "\n/// You are given a word. Your task is to find the closest vowel that\
    \ stands between \n/// two consonants from the right side of the word (case sensitive).\n\
    /// Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n/// find any vowel met the above condition. \n/// You may assume that\
    \ the given string contains English letter only.\n/// Example:\n/// >>> get_closest_vowel(word:\
    \ \"yogurt\")\n/// \"u\"\n/// >>> get_closest_vowel(word: \"FULL\")\n/// \"U\"\
    \n/// >>> get_closest_vowel(word: \"quick\")\n/// \"\"\n/// >>> get_closest_vowel(word:\
    \ \"ab\")\n/// \"\"\nfunc get_closest_vowel(word: String) -> String {\n    var\
    \ consonants = [String]()\n    var vowels = [String]()\n    let characters = word.characters\n\
    \    for char in characters {\n        switch char {\n        case \"a\",\"e\"\
    ,\"i\",\"o\",\"u\",\"A\",\"E\",\"I\",\"O\",\"U\":\n            vowels.append(String(char))\n\
    \        default:\n            consonants.append(String(char))\n        }\n  \
    \  }\n    var index = 0\n    for cons in consonants {\n        index += 1\n  \
    \      if let first = vowels.firstIndex(of: cons) {\n            return vowels[first\
    \ - index]\n        }\n    }\n    return \"\"\n}\n\n\nfunc ==(left: [(Int, Int)],\
    \ right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n       \
    \ return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r\
    \ {\n            return false\n        }\n    }\n    return true\n}\n        \
    \    \nassert(get_closest_vowel(word: \"yogurt\") == \"u\")\nassert(get_closest_vowel(word:\
    \ \"full\") == \"u\")\nassert(get_closest_vowel(word: \"easy\") == \"\")\nassert(get_closest_vowel(word:\
    \ \"eAsy\") == \"\")\nassert(get_closest_vowel(word: \"ali\") == \"\")\nassert(get_closest_vowel(word:\
    \ \"bad\") == \"a\")\nassert(get_closest_vowel(word: \"most\") == \"o\")\nassert(get_closest_vowel(word:\
    \ \"ab\") == \"\")\nassert(get_closest_vowel(word: \"ba\") == \"\")\nassert(get_closest_vowel(word:\
    \ \"quick\") == \"\")\nassert(get_closest_vowel(word: \"anime\") == \"i\")\nassert(get_closest_vowel(word:\
    \ \"Asia\") == \"\")\nassert(get_closest_vowel(word: \"Above\") == \"o\")"
  status: SyntaxError
  stderr: "/tmp/tmpbihdjazb.swift:19:27: error: 'characters' is unavailable: Please\
    \ use String directly\n    let characters = word.characters\n                \
    \          ^~~~~~~~~~\nSwift.String:5:16: note: 'characters' was obsoleted in\
    \ Swift 5.0\n    public var characters: String { get set }\n               ^\n"
  stdout: ''
  timestamp: 1660013568
