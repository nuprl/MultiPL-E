language: swift
name: HumanEval_153_Strongest_Extension
results:
- exit_code: 1
  program: "\n/// You will be given the name of a class (a string) and an array of\
    \ extensions.\n/// The extensions are to be used to load additional classes to\
    \ the class. The\n/// strength of the extension is as follows: Let CAP be the\
    \ number of the uppercase\n/// letters in the extension's name, and let SM be\
    \ the number of lowercase letters \n/// in the extension's name, the strength\
    \ is given by the fraction CAP - SM. \n/// You should find the strongest extension\
    \ and return a string in this \n/// format: ClassName.StrongestExtensionName.\n\
    /// If there are two or more extensions with the same strength, you should\n///\
    \ choose the one that comes first in the array.\n/// For example, if you are given\
    \ \"Slices\" as the class and an array of the\n/// extensions: ['SErviNGSliCes',\
    \ 'Cheese', 'StuFfed'] then you should\n/// return 'Slices.SErviNGSliCes' since\
    \ 'SErviNGSliCes' is the strongest extension \n/// (its strength is -1).\n///\
    \ Example:\n/// >>> Strongest_Extension(class_name: \"my_class\", extensions:\
    \ [\"AA\", \"Be\", \"CC\"])\n/// \"my_class.AA\"\nfunc Strongest_Extension(class_name:\
    \ String, extensions: [String]) -> String {\n    let CAPs = \"ABCDEFGHIJKLMNOPQRSTUVWXYZ\"\
    \n    let SMs = \"abcdefghijklmnopqrstuvwxyz\"\n    var strengths = [Float]()\n\
    \    for i in 0..<extensions.count {\n        var CAP = 0\n        var SM = 0\n\
    \        for j in 0..<extensions[i].count {\n            for a in 0..<CAPs.count\
    \ {\n                if extensions[i][j] == CAPs[a] {\n                    CAP\
    \ += 1\n                }\n            }\n            for b in 0..<SMs.count {\n\
    \                if extensions[i][j] == SMs[b] {\n                    SM += 1\n\
    \                }\n            }\n        }\n        strengths.append(Float(CAP\
    \ - SM))\n    }\n    let max = strengths.max()\n    let index = strengths.firstIndex(of:\
    \ max!)\n    return class_name + \".\" + extensions[index!]\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(Strongest_Extension(class_name: \"Watashi\", extensions:\
    \ [\"tEN\", \"niNE\", \"eIGHt8OKe\"]) == \"Watashi.eIGHt8OKe\")\nassert(Strongest_Extension(class_name:\
    \ \"Boku123\", extensions: [\"nani\", \"NazeDa\", \"YEs.WeCaNe\", \"32145tggg\"\
    ]) == \"Boku123.YEs.WeCaNe\")\nassert(Strongest_Extension(class_name: \"__YESIMHERE\"\
    , extensions: [\"t\", \"eMptY\", \"nothing\", \"zeR00\", \"NuLl__\", \"123NoooneB321\"\
    ]) == \"__YESIMHERE.NuLl__\")\nassert(Strongest_Extension(class_name: \"K\", extensions:\
    \ [\"Ta\", \"TAR\", \"t234An\", \"cosSo\"]) == \"K.TAR\")\nassert(Strongest_Extension(class_name:\
    \ \"__HAHA\", extensions: [\"Tab\", \"123\", \"781345\", \"-_-\"]) == \"__HAHA.123\"\
    )\nassert(Strongest_Extension(class_name: \"YameRore\", extensions: [\"HhAas\"\
    , \"okIWILL123\", \"WorkOut\", \"Fails\", \"-_-\"]) == \"YameRore.okIWILL123\"\
    )\nassert(Strongest_Extension(class_name: \"finNNalLLly\", extensions: [\"Die\"\
    , \"NowW\", \"Wow\", \"WoW\"]) == \"finNNalLLly.WoW\")\nassert(Strongest_Extension(class_name:\
    \ \"_\", extensions: [\"Bb\", \"91245\"]) == \"_.Bb\")\nassert(Strongest_Extension(class_name:\
    \ \"Sp\", extensions: [\"671235\", \"Bb\"]) == \"Sp.671235\")"
  status: SyntaxError
  stderr: "/tmp/tmp_p4y30f3.swift:27:20: error: 'subscript(_:)' is unavailable: cannot\
    \ subscript String with an Int, use a String.Index instead.\n                if\
    \ extensions[i][j] == CAPs[a] {\n                   ^~~~~~~~~~~~~~~~\nSwift.String:3:12:\
    \ note: 'subscript(_:)' has been explicitly marked unavailable here\n    public\
    \ subscript(i: Int) -> Character { get }\n           ^\n/tmp/tmp_p4y30f3.swift:27:40:\
    \ error: 'subscript(_:)' is unavailable: cannot subscript String with an Int,\
    \ use a String.Index instead.\n                if extensions[i][j] == CAPs[a]\
    \ {\n                                       ^~~~~~~\nSwift.String:3:12: note:\
    \ 'subscript(_:)' has been explicitly marked unavailable here\n    public subscript(i:\
    \ Int) -> Character { get }\n           ^\n/tmp/tmp_p4y30f3.swift:32:20: error:\
    \ 'subscript(_:)' is unavailable: cannot subscript String with an Int, use a String.Index\
    \ instead.\n                if extensions[i][j] == SMs[b] {\n                \
    \   ^~~~~~~~~~~~~~~~\nSwift.String:3:12: note: 'subscript(_:)' has been explicitly\
    \ marked unavailable here\n    public subscript(i: Int) -> Character { get }\n\
    \           ^\n/tmp/tmp_p4y30f3.swift:32:40: error: 'subscript(_:)' is unavailable:\
    \ cannot subscript String with an Int, use a String.Index instead.\n         \
    \       if extensions[i][j] == SMs[b] {\n                                    \
    \   ^~~~~~\nSwift.String:3:12: note: 'subscript(_:)' has been explicitly marked\
    \ unavailable here\n    public subscript(i: Int) -> Character { get }\n      \
    \     ^\n"
  stdout: ''
  timestamp: 1660009431
- exit_code: 1
  program: "\n/// You will be given the name of a class (a string) and an array of\
    \ extensions.\n/// The extensions are to be used to load additional classes to\
    \ the class. The\n/// strength of the extension is as follows: Let CAP be the\
    \ number of the uppercase\n/// letters in the extension's name, and let SM be\
    \ the number of lowercase letters \n/// in the extension's name, the strength\
    \ is given by the fraction CAP - SM. \n/// You should find the strongest extension\
    \ and return a string in this \n/// format: ClassName.StrongestExtensionName.\n\
    /// If there are two or more extensions with the same strength, you should\n///\
    \ choose the one that comes first in the array.\n/// For example, if you are given\
    \ \"Slices\" as the class and an array of the\n/// extensions: ['SErviNGSliCes',\
    \ 'Cheese', 'StuFfed'] then you should\n/// return 'Slices.SErviNGSliCes' since\
    \ 'SErviNGSliCes' is the strongest extension \n/// (its strength is -1).\n///\
    \ Example:\n/// >>> Strongest_Extension(class_name: \"my_class\", extensions:\
    \ [\"AA\", \"Be\", \"CC\"])\n/// \"my_class.AA\"\nfunc Strongest_Extension(class_name:\
    \ String, extensions: [String]) -> String {\n    var fraction = 0.0\n    var fraction_ind\
    \ = 0\n    for i in 0..<extensions.count {\n        let cap = Double(extensions[i].uppercased().filter\
    \ {\n            CharacterSet.uppercaseLetters.contains($0.unicodeScalars.first!)\n\
    \        }.count)\n        let sm = Double(extensions[i].lowercased().filter {\n\
    \            CharacterSet.lowercaseLetters.contains($0.unicodeScalars.first!)\n\
    \        }.count)\n        let extension_fraction = cap - sm\n        if extension_fraction\
    \ > fraction {\n            fraction = extension_fraction\n            fraction_ind\
    \ = i\n        }\n    }\n    return \"\\(class_name).\\(extensions[fraction_ind])\"\
    \n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(Strongest_Extension(class_name: \"Watashi\", extensions:\
    \ [\"tEN\", \"niNE\", \"eIGHt8OKe\"]) == \"Watashi.eIGHt8OKe\")\nassert(Strongest_Extension(class_name:\
    \ \"Boku123\", extensions: [\"nani\", \"NazeDa\", \"YEs.WeCaNe\", \"32145tggg\"\
    ]) == \"Boku123.YEs.WeCaNe\")\nassert(Strongest_Extension(class_name: \"__YESIMHERE\"\
    , extensions: [\"t\", \"eMptY\", \"nothing\", \"zeR00\", \"NuLl__\", \"123NoooneB321\"\
    ]) == \"__YESIMHERE.NuLl__\")\nassert(Strongest_Extension(class_name: \"K\", extensions:\
    \ [\"Ta\", \"TAR\", \"t234An\", \"cosSo\"]) == \"K.TAR\")\nassert(Strongest_Extension(class_name:\
    \ \"__HAHA\", extensions: [\"Tab\", \"123\", \"781345\", \"-_-\"]) == \"__HAHA.123\"\
    )\nassert(Strongest_Extension(class_name: \"YameRore\", extensions: [\"HhAas\"\
    , \"okIWILL123\", \"WorkOut\", \"Fails\", \"-_-\"]) == \"YameRore.okIWILL123\"\
    )\nassert(Strongest_Extension(class_name: \"finNNalLLly\", extensions: [\"Die\"\
    , \"NowW\", \"Wow\", \"WoW\"]) == \"finNNalLLly.WoW\")\nassert(Strongest_Extension(class_name:\
    \ \"_\", extensions: [\"Bb\", \"91245\"]) == \"_.Bb\")\nassert(Strongest_Extension(class_name:\
    \ \"Sp\", extensions: [\"671235\", \"Bb\"]) == \"Sp.671235\")"
  status: SyntaxError
  stderr: "/tmp/tmprpphvf5g.swift:23:13: error: cannot find 'CharacterSet' in scope\n\
    \            CharacterSet.uppercaseLetters.contains($0.unicodeScalars.first!)\n\
    \            ^~~~~~~~~~~~\n/tmp/tmprpphvf5g.swift:26:13: error: cannot find 'CharacterSet'\
    \ in scope\n            CharacterSet.lowercaseLetters.contains($0.unicodeScalars.first!)\n\
    \            ^~~~~~~~~~~~\n"
  stdout: ''
  timestamp: 1660009431
- exit_code: -4
  program: "\n/// You will be given the name of a class (a string) and an array of\
    \ extensions.\n/// The extensions are to be used to load additional classes to\
    \ the class. The\n/// strength of the extension is as follows: Let CAP be the\
    \ number of the uppercase\n/// letters in the extension's name, and let SM be\
    \ the number of lowercase letters \n/// in the extension's name, the strength\
    \ is given by the fraction CAP - SM. \n/// You should find the strongest extension\
    \ and return a string in this \n/// format: ClassName.StrongestExtensionName.\n\
    /// If there are two or more extensions with the same strength, you should\n///\
    \ choose the one that comes first in the array.\n/// For example, if you are given\
    \ \"Slices\" as the class and an array of the\n/// extensions: ['SErviNGSliCes',\
    \ 'Cheese', 'StuFfed'] then you should\n/// return 'Slices.SErviNGSliCes' since\
    \ 'SErviNGSliCes' is the strongest extension \n/// (its strength is -1).\n///\
    \ Example:\n/// >>> Strongest_Extension(class_name: \"my_class\", extensions:\
    \ [\"AA\", \"Be\", \"CC\"])\n/// \"my_class.AA\"\nfunc Strongest_Extension(class_name:\
    \ String, extensions: [String]) -> String {\n    var strongest = [String]()\n\
    \    var strongest_score = 0\n    for extension_ in extensions {\n        var\
    \ score = 0\n        for letter in extension_ {\n            if letter.isUppercase\
    \ {\n                score += 1\n            } else {\n                score -=\
    \ 1\n            }\n        }\n        if score == strongest_score {\n       \
    \     strongest.append(extension_)\n        } else if score > strongest_score\
    \ {\n            strongest = [extension_]\n            strongest_score = score\n\
    \        }\n    }\n    return \"\\(class_name).\\(strongest[0])\"\n}\n\n\nfunc\
    \ ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count !=\
    \ right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(Strongest_Extension(class_name: \"Watashi\", extensions:\
    \ [\"tEN\", \"niNE\", \"eIGHt8OKe\"]) == \"Watashi.eIGHt8OKe\")\nassert(Strongest_Extension(class_name:\
    \ \"Boku123\", extensions: [\"nani\", \"NazeDa\", \"YEs.WeCaNe\", \"32145tggg\"\
    ]) == \"Boku123.YEs.WeCaNe\")\nassert(Strongest_Extension(class_name: \"__YESIMHERE\"\
    , extensions: [\"t\", \"eMptY\", \"nothing\", \"zeR00\", \"NuLl__\", \"123NoooneB321\"\
    ]) == \"__YESIMHERE.NuLl__\")\nassert(Strongest_Extension(class_name: \"K\", extensions:\
    \ [\"Ta\", \"TAR\", \"t234An\", \"cosSo\"]) == \"K.TAR\")\nassert(Strongest_Extension(class_name:\
    \ \"__HAHA\", extensions: [\"Tab\", \"123\", \"781345\", \"-_-\"]) == \"__HAHA.123\"\
    )\nassert(Strongest_Extension(class_name: \"YameRore\", extensions: [\"HhAas\"\
    , \"okIWILL123\", \"WorkOut\", \"Fails\", \"-_-\"]) == \"YameRore.okIWILL123\"\
    )\nassert(Strongest_Extension(class_name: \"finNNalLLly\", extensions: [\"Die\"\
    , \"NowW\", \"Wow\", \"WoW\"]) == \"finNNalLLly.WoW\")\nassert(Strongest_Extension(class_name:\
    \ \"_\", extensions: [\"Bb\", \"91245\"]) == \"_.Bb\")\nassert(Strongest_Extension(class_name:\
    \ \"Sp\", extensions: [\"671235\", \"Bb\"]) == \"Sp.671235\")"
  status: Exception
  stderr: 'tmpr0qryx21/tmpr0qryx21.swift:53: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b51e164cc80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b51e1343b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b51e1343988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b51e13427b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpr0qryx21                        0x000055fe16eedb3d <unavailable> + 6973

    5    libc.so.6                          0x00002b51e1838460 __libc_start_main +
    245

    6    tmpr0qryx21                        0x000055fe16eed6c9 <unavailable> + 5833

    '
  stdout: ''
  timestamp: 1660009432
- exit_code: 1
  program: "\n/// You will be given the name of a class (a string) and an array of\
    \ extensions.\n/// The extensions are to be used to load additional classes to\
    \ the class. The\n/// strength of the extension is as follows: Let CAP be the\
    \ number of the uppercase\n/// letters in the extension's name, and let SM be\
    \ the number of lowercase letters \n/// in the extension's name, the strength\
    \ is given by the fraction CAP - SM. \n/// You should find the strongest extension\
    \ and return a string in this \n/// format: ClassName.StrongestExtensionName.\n\
    /// If there are two or more extensions with the same strength, you should\n///\
    \ choose the one that comes first in the array.\n/// For example, if you are given\
    \ \"Slices\" as the class and an array of the\n/// extensions: ['SErviNGSliCes',\
    \ 'Cheese', 'StuFfed'] then you should\n/// return 'Slices.SErviNGSliCes' since\
    \ 'SErviNGSliCes' is the strongest extension \n/// (its strength is -1).\n///\
    \ Example:\n/// >>> Strongest_Extension(class_name: \"my_class\", extensions:\
    \ [\"AA\", \"Be\", \"CC\"])\n/// \"my_class.AA\"\nfunc Strongest_Extension(class_name:\
    \ String, extensions: [String]) -> String {\n    var strongest_extension = \"\"\
    \n    var strongest_strength = -100000\n    for extension_name in extensions {\n\
    \        var capital_letter_count = 0\n        var small_letter_count = 0\n  \
    \      for letter in extension_name {\n            if String(letter).uppercased()\
    \ == String(letter) {\n                capital_letter_count += 1\n           \
    \ } else {\n                small_letter_count += 1\n            }\n        }\n\
    \        let strength = Double(capital_letter_count) - Double(small_letter_count)\n\
    \        if strength > strongest_strength {\n            strongest_strength =\
    \ strength\n            strongest_extension = extension_name\n        }\n    }\n\
    \    return \"\\(class_name).\\(strongest_extension)\"\n}\n\n\nfunc ==(left: [(Int,\
    \ Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n\
    \        return false\n    }\n    for (l, r) in zip(left, right) {\n        if\
    \ l != r {\n            return false\n        }\n    }\n    return true\n}\n \
    \           \nassert(Strongest_Extension(class_name: \"Watashi\", extensions:\
    \ [\"tEN\", \"niNE\", \"eIGHt8OKe\"]) == \"Watashi.eIGHt8OKe\")\nassert(Strongest_Extension(class_name:\
    \ \"Boku123\", extensions: [\"nani\", \"NazeDa\", \"YEs.WeCaNe\", \"32145tggg\"\
    ]) == \"Boku123.YEs.WeCaNe\")\nassert(Strongest_Extension(class_name: \"__YESIMHERE\"\
    , extensions: [\"t\", \"eMptY\", \"nothing\", \"zeR00\", \"NuLl__\", \"123NoooneB321\"\
    ]) == \"__YESIMHERE.NuLl__\")\nassert(Strongest_Extension(class_name: \"K\", extensions:\
    \ [\"Ta\", \"TAR\", \"t234An\", \"cosSo\"]) == \"K.TAR\")\nassert(Strongest_Extension(class_name:\
    \ \"__HAHA\", extensions: [\"Tab\", \"123\", \"781345\", \"-_-\"]) == \"__HAHA.123\"\
    )\nassert(Strongest_Extension(class_name: \"YameRore\", extensions: [\"HhAas\"\
    , \"okIWILL123\", \"WorkOut\", \"Fails\", \"-_-\"]) == \"YameRore.okIWILL123\"\
    )\nassert(Strongest_Extension(class_name: \"finNNalLLly\", extensions: [\"Die\"\
    , \"NowW\", \"Wow\", \"WoW\"]) == \"finNNalLLly.WoW\")\nassert(Strongest_Extension(class_name:\
    \ \"_\", extensions: [\"Bb\", \"91245\"]) == \"_.Bb\")\nassert(Strongest_Extension(class_name:\
    \ \"Sp\", extensions: [\"671235\", \"Bb\"]) == \"Sp.671235\")"
  status: SyntaxError
  stderr: "/tmp/tmp1mtorcle.swift:32:21: error: binary operator '>' cannot be applied\
    \ to operands of type 'Double' and 'Int'\n        if strength > strongest_strength\
    \ {\n           ~~~~~~~~ ^ ~~~~~~~~~~~~~~~~~~\n/tmp/tmp1mtorcle.swift:32:21: note:\
    \ overloads for '>' exist with these partially matching parameter lists: (Int,\
    \ Int)\n        if strength > strongest_strength {\n                    ^\n/tmp/tmp1mtorcle.swift:33:34:\
    \ error: cannot assign value of type 'Double' to type 'Int'\n            strongest_strength\
    \ = strength\n                                 ^~~~~~~~\n                    \
    \             Int(    )\n"
  stdout: ''
  timestamp: 1660009431
- exit_code: -4
  program: "\n/// You will be given the name of a class (a string) and an array of\
    \ extensions.\n/// The extensions are to be used to load additional classes to\
    \ the class. The\n/// strength of the extension is as follows: Let CAP be the\
    \ number of the uppercase\n/// letters in the extension's name, and let SM be\
    \ the number of lowercase letters \n/// in the extension's name, the strength\
    \ is given by the fraction CAP - SM. \n/// You should find the strongest extension\
    \ and return a string in this \n/// format: ClassName.StrongestExtensionName.\n\
    /// If there are two or more extensions with the same strength, you should\n///\
    \ choose the one that comes first in the array.\n/// For example, if you are given\
    \ \"Slices\" as the class and an array of the\n/// extensions: ['SErviNGSliCes',\
    \ 'Cheese', 'StuFfed'] then you should\n/// return 'Slices.SErviNGSliCes' since\
    \ 'SErviNGSliCes' is the strongest extension \n/// (its strength is -1).\n///\
    \ Example:\n/// >>> Strongest_Extension(class_name: \"my_class\", extensions:\
    \ [\"AA\", \"Be\", \"CC\"])\n/// \"my_class.AA\"\nfunc Strongest_Extension(class_name:\
    \ String, extensions: [String]) -> String {\n\treturn \"Implement this\"\n}\n\n\
    \nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(Strongest_Extension(class_name: \"Watashi\", extensions:\
    \ [\"tEN\", \"niNE\", \"eIGHt8OKe\"]) == \"Watashi.eIGHt8OKe\")\nassert(Strongest_Extension(class_name:\
    \ \"Boku123\", extensions: [\"nani\", \"NazeDa\", \"YEs.WeCaNe\", \"32145tggg\"\
    ]) == \"Boku123.YEs.WeCaNe\")\nassert(Strongest_Extension(class_name: \"__YESIMHERE\"\
    , extensions: [\"t\", \"eMptY\", \"nothing\", \"zeR00\", \"NuLl__\", \"123NoooneB321\"\
    ]) == \"__YESIMHERE.NuLl__\")\nassert(Strongest_Extension(class_name: \"K\", extensions:\
    \ [\"Ta\", \"TAR\", \"t234An\", \"cosSo\"]) == \"K.TAR\")\nassert(Strongest_Extension(class_name:\
    \ \"__HAHA\", extensions: [\"Tab\", \"123\", \"781345\", \"-_-\"]) == \"__HAHA.123\"\
    )\nassert(Strongest_Extension(class_name: \"YameRore\", extensions: [\"HhAas\"\
    , \"okIWILL123\", \"WorkOut\", \"Fails\", \"-_-\"]) == \"YameRore.okIWILL123\"\
    )\nassert(Strongest_Extension(class_name: \"finNNalLLly\", extensions: [\"Die\"\
    , \"NowW\", \"Wow\", \"WoW\"]) == \"finNNalLLly.WoW\")\nassert(Strongest_Extension(class_name:\
    \ \"_\", extensions: [\"Bb\", \"91245\"]) == \"_.Bb\")\nassert(Strongest_Extension(class_name:\
    \ \"Sp\", extensions: [\"671235\", \"Bb\"]) == \"Sp.671235\")"
  status: Exception
  stderr: 'tmpvd6xzj0n/tmpvd6xzj0n.swift:35: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b70540ccc80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b7053dc3b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b7053dc3988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b7053dc27b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpvd6xzj0n                        0x000055fbc463e4fd <unavailable> + 5373

    5    libc.so.6                          0x00002b70542b8460 __libc_start_main +
    245

    6    tmpvd6xzj0n                        0x000055fbc463e089 <unavailable> + 4233

    '
  stdout: ''
  timestamp: 1660009431
- exit_code: -4
  program: "\n/// You will be given the name of a class (a string) and an array of\
    \ extensions.\n/// The extensions are to be used to load additional classes to\
    \ the class. The\n/// strength of the extension is as follows: Let CAP be the\
    \ number of the uppercase\n/// letters in the extension's name, and let SM be\
    \ the number of lowercase letters \n/// in the extension's name, the strength\
    \ is given by the fraction CAP - SM. \n/// You should find the strongest extension\
    \ and return a string in this \n/// format: ClassName.StrongestExtensionName.\n\
    /// If there are two or more extensions with the same strength, you should\n///\
    \ choose the one that comes first in the array.\n/// For example, if you are given\
    \ \"Slices\" as the class and an array of the\n/// extensions: ['SErviNGSliCes',\
    \ 'Cheese', 'StuFfed'] then you should\n/// return 'Slices.SErviNGSliCes' since\
    \ 'SErviNGSliCes' is the strongest extension \n/// (its strength is -1).\n///\
    \ Example:\n/// >>> Strongest_Extension(class_name: \"my_class\", extensions:\
    \ [\"AA\", \"Be\", \"CC\"])\n/// \"my_class.AA\"\nfunc Strongest_Extension(class_name:\
    \ String, extensions: [String]) -> String {\n    var strongest_extension = extensions[0]\n\
    \    var strongest_strength = 0\n    for i in 0..<extensions.count {\n       \
    \ var cap = 0\n        var sm = 0\n        for j in 0..<extensions[i].count {\n\
    \            if \"A\"...\"Z\" ~= extensions[i][extensions[i].index(extensions[i].startIndex,\
    \ offsetBy: j)] {\n                cap += 1\n            } else {\n          \
    \      sm += 1\n            }\n        }\n        if cap - sm > strongest_strength\
    \ {\n            strongest_strength = cap - sm\n            strongest_extension\
    \ = extensions[i]\n        }\n    }\n    return class_name + \".\" + strongest_extension\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(Strongest_Extension(class_name: \"Watashi\", extensions:\
    \ [\"tEN\", \"niNE\", \"eIGHt8OKe\"]) == \"Watashi.eIGHt8OKe\")\nassert(Strongest_Extension(class_name:\
    \ \"Boku123\", extensions: [\"nani\", \"NazeDa\", \"YEs.WeCaNe\", \"32145tggg\"\
    ]) == \"Boku123.YEs.WeCaNe\")\nassert(Strongest_Extension(class_name: \"__YESIMHERE\"\
    , extensions: [\"t\", \"eMptY\", \"nothing\", \"zeR00\", \"NuLl__\", \"123NoooneB321\"\
    ]) == \"__YESIMHERE.NuLl__\")\nassert(Strongest_Extension(class_name: \"K\", extensions:\
    \ [\"Ta\", \"TAR\", \"t234An\", \"cosSo\"]) == \"K.TAR\")\nassert(Strongest_Extension(class_name:\
    \ \"__HAHA\", extensions: [\"Tab\", \"123\", \"781345\", \"-_-\"]) == \"__HAHA.123\"\
    )\nassert(Strongest_Extension(class_name: \"YameRore\", extensions: [\"HhAas\"\
    , \"okIWILL123\", \"WorkOut\", \"Fails\", \"-_-\"]) == \"YameRore.okIWILL123\"\
    )\nassert(Strongest_Extension(class_name: \"finNNalLLly\", extensions: [\"Die\"\
    , \"NowW\", \"Wow\", \"WoW\"]) == \"finNNalLLly.WoW\")\nassert(Strongest_Extension(class_name:\
    \ \"_\", extensions: [\"Bb\", \"91245\"]) == \"_.Bb\")\nassert(Strongest_Extension(class_name:\
    \ \"Sp\", extensions: [\"671235\", \"Bb\"]) == \"Sp.671235\")"
  status: Exception
  stderr: 'tmpb31_d12r/tmpb31_d12r.swift:52: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002ad9ccc46c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002ad9cc93db6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002ad9cc93d988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002ad9cc93c7b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpb31_d12r                        0x00005587bd407a7d <unavailable> + 6781

    5    libc.so.6                          0x00002ad9cce32460 __libc_start_main +
    245

    6    tmpb31_d12r                        0x00005587bd407609 <unavailable> + 5641

    '
  stdout: ''
  timestamp: 1660009432
- exit_code: -4
  program: "\n/// You will be given the name of a class (a string) and an array of\
    \ extensions.\n/// The extensions are to be used to load additional classes to\
    \ the class. The\n/// strength of the extension is as follows: Let CAP be the\
    \ number of the uppercase\n/// letters in the extension's name, and let SM be\
    \ the number of lowercase letters \n/// in the extension's name, the strength\
    \ is given by the fraction CAP - SM. \n/// You should find the strongest extension\
    \ and return a string in this \n/// format: ClassName.StrongestExtensionName.\n\
    /// If there are two or more extensions with the same strength, you should\n///\
    \ choose the one that comes first in the array.\n/// For example, if you are given\
    \ \"Slices\" as the class and an array of the\n/// extensions: ['SErviNGSliCes',\
    \ 'Cheese', 'StuFfed'] then you should\n/// return 'Slices.SErviNGSliCes' since\
    \ 'SErviNGSliCes' is the strongest extension \n/// (its strength is -1).\n///\
    \ Example:\n/// >>> Strongest_Extension(class_name: \"my_class\", extensions:\
    \ [\"AA\", \"Be\", \"CC\"])\n/// \"my_class.AA\"\nfunc Strongest_Extension(class_name:\
    \ String, extensions: [String]) -> String {\n    var strongest_extension: String\
    \ = \"null\"\n    var strongest_extension_strength: Double = 0.0\n    for extension_name\
    \ in extensions {\n        var extension_strength: Double = 0.0\n        for character\
    \ in extension_name {\n            if character.isUppercase {\n              \
    \  extension_strength += 1\n            } else {\n                extension_strength\
    \ -= 1\n            }\n        }\n        if extension_strength > strongest_extension_strength\
    \ {\n            strongest_extension = extension_name\n            strongest_extension_strength\
    \ = extension_strength\n        }\n    }\n    return class_name + \".\" + strongest_extension\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(Strongest_Extension(class_name: \"Watashi\", extensions:\
    \ [\"tEN\", \"niNE\", \"eIGHt8OKe\"]) == \"Watashi.eIGHt8OKe\")\nassert(Strongest_Extension(class_name:\
    \ \"Boku123\", extensions: [\"nani\", \"NazeDa\", \"YEs.WeCaNe\", \"32145tggg\"\
    ]) == \"Boku123.YEs.WeCaNe\")\nassert(Strongest_Extension(class_name: \"__YESIMHERE\"\
    , extensions: [\"t\", \"eMptY\", \"nothing\", \"zeR00\", \"NuLl__\", \"123NoooneB321\"\
    ]) == \"__YESIMHERE.NuLl__\")\nassert(Strongest_Extension(class_name: \"K\", extensions:\
    \ [\"Ta\", \"TAR\", \"t234An\", \"cosSo\"]) == \"K.TAR\")\nassert(Strongest_Extension(class_name:\
    \ \"__HAHA\", extensions: [\"Tab\", \"123\", \"781345\", \"-_-\"]) == \"__HAHA.123\"\
    )\nassert(Strongest_Extension(class_name: \"YameRore\", extensions: [\"HhAas\"\
    , \"okIWILL123\", \"WorkOut\", \"Fails\", \"-_-\"]) == \"YameRore.okIWILL123\"\
    )\nassert(Strongest_Extension(class_name: \"finNNalLLly\", extensions: [\"Die\"\
    , \"NowW\", \"Wow\", \"WoW\"]) == \"finNNalLLly.WoW\")\nassert(Strongest_Extension(class_name:\
    \ \"_\", extensions: [\"Bb\", \"91245\"]) == \"_.Bb\")\nassert(Strongest_Extension(class_name:\
    \ \"Sp\", extensions: [\"671235\", \"Bb\"]) == \"Sp.671235\")"
  status: Exception
  stderr: 'tmpq494sdbk/tmpq494sdbk.swift:51: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b278b996c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b278b68db6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b278b68d988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b278b68c7b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpq494sdbk                        0x000055595456f7cd <unavailable> + 6093

    5    libc.so.6                          0x00002b278bb82460 __libc_start_main +
    245

    6    tmpq494sdbk                        0x000055595456f359 <unavailable> + 4953

    '
  stdout: ''
  timestamp: 1660009432
- exit_code: -4
  program: "\n/// You will be given the name of a class (a string) and an array of\
    \ extensions.\n/// The extensions are to be used to load additional classes to\
    \ the class. The\n/// strength of the extension is as follows: Let CAP be the\
    \ number of the uppercase\n/// letters in the extension's name, and let SM be\
    \ the number of lowercase letters \n/// in the extension's name, the strength\
    \ is given by the fraction CAP - SM. \n/// You should find the strongest extension\
    \ and return a string in this \n/// format: ClassName.StrongestExtensionName.\n\
    /// If there are two or more extensions with the same strength, you should\n///\
    \ choose the one that comes first in the array.\n/// For example, if you are given\
    \ \"Slices\" as the class and an array of the\n/// extensions: ['SErviNGSliCes',\
    \ 'Cheese', 'StuFfed'] then you should\n/// return 'Slices.SErviNGSliCes' since\
    \ 'SErviNGSliCes' is the strongest extension \n/// (its strength is -1).\n///\
    \ Example:\n/// >>> Strongest_Extension(class_name: \"my_class\", extensions:\
    \ [\"AA\", \"Be\", \"CC\"])\n/// \"my_class.AA\"\nfunc Strongest_Extension(class_name:\
    \ String, extensions: [String]) -> String {\n    var max: String = extensions[0]\n\
    \    var num_cap = 0\n    var num_low = 0\n    for char in max {\n        if char.isUppercase\
    \ {\n            num_cap += 1\n        } else {\n            num_low += 1\n  \
    \      }\n    }\n    var biggest = num_cap - num_low\n    for ext in extensions\
    \ {\n        var cap = 0\n        var low = 0\n        for char in ext {\n   \
    \         if char.isUppercase {\n                cap += 1\n            } else\
    \ {\n                low += 1\n            }\n        }\n        let strength\
    \ = cap - low\n        if strength > biggest {\n            biggest = strength\n\
    \            max = ext\n        }\n    }\n    return \"\\(class_name).\\(max)\"\
    \n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(Strongest_Extension(class_name: \"Watashi\", extensions:\
    \ [\"tEN\", \"niNE\", \"eIGHt8OKe\"]) == \"Watashi.eIGHt8OKe\")\nassert(Strongest_Extension(class_name:\
    \ \"Boku123\", extensions: [\"nani\", \"NazeDa\", \"YEs.WeCaNe\", \"32145tggg\"\
    ]) == \"Boku123.YEs.WeCaNe\")\nassert(Strongest_Extension(class_name: \"__YESIMHERE\"\
    , extensions: [\"t\", \"eMptY\", \"nothing\", \"zeR00\", \"NuLl__\", \"123NoooneB321\"\
    ]) == \"__YESIMHERE.NuLl__\")\nassert(Strongest_Extension(class_name: \"K\", extensions:\
    \ [\"Ta\", \"TAR\", \"t234An\", \"cosSo\"]) == \"K.TAR\")\nassert(Strongest_Extension(class_name:\
    \ \"__HAHA\", extensions: [\"Tab\", \"123\", \"781345\", \"-_-\"]) == \"__HAHA.123\"\
    )\nassert(Strongest_Extension(class_name: \"YameRore\", extensions: [\"HhAas\"\
    , \"okIWILL123\", \"WorkOut\", \"Fails\", \"-_-\"]) == \"YameRore.okIWILL123\"\
    )\nassert(Strongest_Extension(class_name: \"finNNalLLly\", extensions: [\"Die\"\
    , \"NowW\", \"Wow\", \"WoW\"]) == \"finNNalLLly.WoW\")\nassert(Strongest_Extension(class_name:\
    \ \"_\", extensions: [\"Bb\", \"91245\"]) == \"_.Bb\")\nassert(Strongest_Extension(class_name:\
    \ \"Sp\", extensions: [\"671235\", \"Bb\"]) == \"Sp.671235\")"
  status: Exception
  stderr: 'tmpcnpu_agm/tmpcnpu_agm.swift:62: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b17df965c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b17df65cb6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b17df65c988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b17df65b7b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpcnpu_agm                        0x0000556a2abd1a8d <unavailable> + 6797

    5    libc.so.6                          0x00002b17dfb51460 __libc_start_main +
    245

    6    tmpcnpu_agm                        0x0000556a2abd1619 <unavailable> + 5657

    '
  stdout: ''
  timestamp: 1660009432
- exit_code: 1
  program: "\n/// You will be given the name of a class (a string) and an array of\
    \ extensions.\n/// The extensions are to be used to load additional classes to\
    \ the class. The\n/// strength of the extension is as follows: Let CAP be the\
    \ number of the uppercase\n/// letters in the extension's name, and let SM be\
    \ the number of lowercase letters \n/// in the extension's name, the strength\
    \ is given by the fraction CAP - SM. \n/// You should find the strongest extension\
    \ and return a string in this \n/// format: ClassName.StrongestExtensionName.\n\
    /// If there are two or more extensions with the same strength, you should\n///\
    \ choose the one that comes first in the array.\n/// For example, if you are given\
    \ \"Slices\" as the class and an array of the\n/// extensions: ['SErviNGSliCes',\
    \ 'Cheese', 'StuFfed'] then you should\n/// return 'Slices.SErviNGSliCes' since\
    \ 'SErviNGSliCes' is the strongest extension \n/// (its strength is -1).\n///\
    \ Example:\n/// >>> Strongest_Extension(class_name: \"my_class\", extensions:\
    \ [\"AA\", \"Be\", \"CC\"])\n/// \"my_class.AA\"\nfunc Strongest_Extension(class_name:\
    \ String, extensions: [String]) -> String {\n    let cap_regex = \"([A-Z])\"\n\
    \    let sm_regex = \"([a-z])\"\n    var strength = -Double.infinity\n    var\
    \ strongest_extension = \"\"\n    for extension_ in extensions {\n        var\
    \ cap_matches = find_all_matches(input: extension_, regex: cap_regex)\n      \
    \  var sm_matches = find_all_matches(input: extension_, regex: sm_regex)\n   \
    \     var cap_count = Double(cap_matches.count)\n        var sm_count = Double(sm_matches.count)\n\
    \        var current_strength = cap_count - sm_count\n        if current_strength\
    \ > strength {\n            strength = current_strength\n            strongest_extension\
    \ = extension_\n        }\n    }\n    return \"\\(class_name).\\(strongest_extension)\"\
    \n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(Strongest_Extension(class_name: \"Watashi\", extensions:\
    \ [\"tEN\", \"niNE\", \"eIGHt8OKe\"]) == \"Watashi.eIGHt8OKe\")\nassert(Strongest_Extension(class_name:\
    \ \"Boku123\", extensions: [\"nani\", \"NazeDa\", \"YEs.WeCaNe\", \"32145tggg\"\
    ]) == \"Boku123.YEs.WeCaNe\")\nassert(Strongest_Extension(class_name: \"__YESIMHERE\"\
    , extensions: [\"t\", \"eMptY\", \"nothing\", \"zeR00\", \"NuLl__\", \"123NoooneB321\"\
    ]) == \"__YESIMHERE.NuLl__\")\nassert(Strongest_Extension(class_name: \"K\", extensions:\
    \ [\"Ta\", \"TAR\", \"t234An\", \"cosSo\"]) == \"K.TAR\")\nassert(Strongest_Extension(class_name:\
    \ \"__HAHA\", extensions: [\"Tab\", \"123\", \"781345\", \"-_-\"]) == \"__HAHA.123\"\
    )\nassert(Strongest_Extension(class_name: \"YameRore\", extensions: [\"HhAas\"\
    , \"okIWILL123\", \"WorkOut\", \"Fails\", \"-_-\"]) == \"YameRore.okIWILL123\"\
    )\nassert(Strongest_Extension(class_name: \"finNNalLLly\", extensions: [\"Die\"\
    , \"NowW\", \"Wow\", \"WoW\"]) == \"finNNalLLly.WoW\")\nassert(Strongest_Extension(class_name:\
    \ \"_\", extensions: [\"Bb\", \"91245\"]) == \"_.Bb\")\nassert(Strongest_Extension(class_name:\
    \ \"Sp\", extensions: [\"671235\", \"Bb\"]) == \"Sp.671235\")"
  status: SyntaxError
  stderr: "/tmp/tmp9tk5ziog.swift:24:27: error: cannot find 'find_all_matches' in\
    \ scope\n        var cap_matches = find_all_matches(input: extension_, regex:\
    \ cap_regex)\n                          ^~~~~~~~~~~~~~~~\n/tmp/tmp9tk5ziog.swift:25:26:\
    \ error: cannot find 'find_all_matches' in scope\n        var sm_matches = find_all_matches(input:\
    \ extension_, regex: sm_regex)\n                         ^~~~~~~~~~~~~~~~\n"
  stdout: ''
  timestamp: 1660009431
- exit_code: -4
  program: "\n/// You will be given the name of a class (a string) and an array of\
    \ extensions.\n/// The extensions are to be used to load additional classes to\
    \ the class. The\n/// strength of the extension is as follows: Let CAP be the\
    \ number of the uppercase\n/// letters in the extension's name, and let SM be\
    \ the number of lowercase letters \n/// in the extension's name, the strength\
    \ is given by the fraction CAP - SM. \n/// You should find the strongest extension\
    \ and return a string in this \n/// format: ClassName.StrongestExtensionName.\n\
    /// If there are two or more extensions with the same strength, you should\n///\
    \ choose the one that comes first in the array.\n/// For example, if you are given\
    \ \"Slices\" as the class and an array of the\n/// extensions: ['SErviNGSliCes',\
    \ 'Cheese', 'StuFfed'] then you should\n/// return 'Slices.SErviNGSliCes' since\
    \ 'SErviNGSliCes' is the strongest extension \n/// (its strength is -1).\n///\
    \ Example:\n/// >>> Strongest_Extension(class_name: \"my_class\", extensions:\
    \ [\"AA\", \"Be\", \"CC\"])\n/// \"my_class.AA\"\nfunc Strongest_Extension(class_name:\
    \ String, extensions: [String]) -> String {\n    return \"\"\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(Strongest_Extension(class_name: \"Watashi\", extensions:\
    \ [\"tEN\", \"niNE\", \"eIGHt8OKe\"]) == \"Watashi.eIGHt8OKe\")\nassert(Strongest_Extension(class_name:\
    \ \"Boku123\", extensions: [\"nani\", \"NazeDa\", \"YEs.WeCaNe\", \"32145tggg\"\
    ]) == \"Boku123.YEs.WeCaNe\")\nassert(Strongest_Extension(class_name: \"__YESIMHERE\"\
    , extensions: [\"t\", \"eMptY\", \"nothing\", \"zeR00\", \"NuLl__\", \"123NoooneB321\"\
    ]) == \"__YESIMHERE.NuLl__\")\nassert(Strongest_Extension(class_name: \"K\", extensions:\
    \ [\"Ta\", \"TAR\", \"t234An\", \"cosSo\"]) == \"K.TAR\")\nassert(Strongest_Extension(class_name:\
    \ \"__HAHA\", extensions: [\"Tab\", \"123\", \"781345\", \"-_-\"]) == \"__HAHA.123\"\
    )\nassert(Strongest_Extension(class_name: \"YameRore\", extensions: [\"HhAas\"\
    , \"okIWILL123\", \"WorkOut\", \"Fails\", \"-_-\"]) == \"YameRore.okIWILL123\"\
    )\nassert(Strongest_Extension(class_name: \"finNNalLLly\", extensions: [\"Die\"\
    , \"NowW\", \"Wow\", \"WoW\"]) == \"finNNalLLly.WoW\")\nassert(Strongest_Extension(class_name:\
    \ \"_\", extensions: [\"Bb\", \"91245\"]) == \"_.Bb\")\nassert(Strongest_Extension(class_name:\
    \ \"Sp\", extensions: [\"671235\", \"Bb\"]) == \"Sp.671235\")"
  status: Exception
  stderr: 'tmpuhmbxdp4/tmpuhmbxdp4.swift:35: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002abeef348c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002abeef03fb6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002abeef03f988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002abeef03e7b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpuhmbxdp4                        0x0000559ee0d614fd <unavailable> + 5373

    5    libc.so.6                          0x00002abeef534460 __libc_start_main +
    245

    6    tmpuhmbxdp4                        0x0000559ee0d61089 <unavailable> + 4233

    '
  stdout: ''
  timestamp: 1660009431
- exit_code: -4
  program: "\n/// You will be given the name of a class (a string) and an array of\
    \ extensions.\n/// The extensions are to be used to load additional classes to\
    \ the class. The\n/// strength of the extension is as follows: Let CAP be the\
    \ number of the uppercase\n/// letters in the extension's name, and let SM be\
    \ the number of lowercase letters \n/// in the extension's name, the strength\
    \ is given by the fraction CAP - SM. \n/// You should find the strongest extension\
    \ and return a string in this \n/// format: ClassName.StrongestExtensionName.\n\
    /// If there are two or more extensions with the same strength, you should\n///\
    \ choose the one that comes first in the array.\n/// For example, if you are given\
    \ \"Slices\" as the class and an array of the\n/// extensions: ['SErviNGSliCes',\
    \ 'Cheese', 'StuFfed'] then you should\n/// return 'Slices.SErviNGSliCes' since\
    \ 'SErviNGSliCes' is the strongest extension \n/// (its strength is -1).\n///\
    \ Example:\n/// >>> Strongest_Extension(class_name: \"my_class\", extensions:\
    \ [\"AA\", \"Be\", \"CC\"])\n/// \"my_class.AA\"\nfunc Strongest_Extension(class_name:\
    \ String, extensions: [String]) -> String {\n  var strongest_extension = \"\"\
    ;\n  var strongest_strength = 0.0;\n  for extension_ in extensions {\n    var\
    \ strength = 0.0;\n    for letter in extension_ {\n      if letter.isUppercase\
    \ {\n        strength += 1.0;\n      } else {\n        strength -= 1.0;\n    \
    \  }\n    }\n    if strength > strongest_strength {\n      strongest_strength\
    \ = strength;\n      strongest_extension = extension_;\n    }\n  }\n  return \"\
    \\(class_name).\\(strongest_extension)\";\n}\n\n\nfunc ==(left: [(Int, Int)],\
    \ right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n       \
    \ return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r\
    \ {\n            return false\n        }\n    }\n    return true\n}\n        \
    \    \nassert(Strongest_Extension(class_name: \"Watashi\", extensions: [\"tEN\"\
    , \"niNE\", \"eIGHt8OKe\"]) == \"Watashi.eIGHt8OKe\")\nassert(Strongest_Extension(class_name:\
    \ \"Boku123\", extensions: [\"nani\", \"NazeDa\", \"YEs.WeCaNe\", \"32145tggg\"\
    ]) == \"Boku123.YEs.WeCaNe\")\nassert(Strongest_Extension(class_name: \"__YESIMHERE\"\
    , extensions: [\"t\", \"eMptY\", \"nothing\", \"zeR00\", \"NuLl__\", \"123NoooneB321\"\
    ]) == \"__YESIMHERE.NuLl__\")\nassert(Strongest_Extension(class_name: \"K\", extensions:\
    \ [\"Ta\", \"TAR\", \"t234An\", \"cosSo\"]) == \"K.TAR\")\nassert(Strongest_Extension(class_name:\
    \ \"__HAHA\", extensions: [\"Tab\", \"123\", \"781345\", \"-_-\"]) == \"__HAHA.123\"\
    )\nassert(Strongest_Extension(class_name: \"YameRore\", extensions: [\"HhAas\"\
    , \"okIWILL123\", \"WorkOut\", \"Fails\", \"-_-\"]) == \"YameRore.okIWILL123\"\
    )\nassert(Strongest_Extension(class_name: \"finNNalLLly\", extensions: [\"Die\"\
    , \"NowW\", \"Wow\", \"WoW\"]) == \"finNNalLLly.WoW\")\nassert(Strongest_Extension(class_name:\
    \ \"_\", extensions: [\"Bb\", \"91245\"]) == \"_.Bb\")\nassert(Strongest_Extension(class_name:\
    \ \"Sp\", extensions: [\"671235\", \"Bb\"]) == \"Sp.671235\")"
  status: Exception
  stderr: 'tmp87b7o674/tmp87b7o674.swift:51: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002adc06cf3c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002adc069eab6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002adc069ea988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002adc069e97b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmp87b7o674                        0x0000559cd3b24a3d <unavailable> + 6717

    5    libc.so.6                          0x00002adc06edf460 __libc_start_main +
    245

    6    tmp87b7o674                        0x0000559cd3b245c9 <unavailable> + 5577

    '
  stdout: ''
  timestamp: 1660009432
- exit_code: 1
  program: "\n/// You will be given the name of a class (a string) and an array of\
    \ extensions.\n/// The extensions are to be used to load additional classes to\
    \ the class. The\n/// strength of the extension is as follows: Let CAP be the\
    \ number of the uppercase\n/// letters in the extension's name, and let SM be\
    \ the number of lowercase letters \n/// in the extension's name, the strength\
    \ is given by the fraction CAP - SM. \n/// You should find the strongest extension\
    \ and return a string in this \n/// format: ClassName.StrongestExtensionName.\n\
    /// If there are two or more extensions with the same strength, you should\n///\
    \ choose the one that comes first in the array.\n/// For example, if you are given\
    \ \"Slices\" as the class and an array of the\n/// extensions: ['SErviNGSliCes',\
    \ 'Cheese', 'StuFfed'] then you should\n/// return 'Slices.SErviNGSliCes' since\
    \ 'SErviNGSliCes' is the strongest extension \n/// (its strength is -1).\n///\
    \ Example:\n/// >>> Strongest_Extension(class_name: \"my_class\", extensions:\
    \ [\"AA\", \"Be\", \"CC\"])\n/// \"my_class.AA\"\nfunc Strongest_Extension(class_name:\
    \ String, extensions: [String]) -> String {\n    // Put your code here.\n}\n\n\
    \nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(Strongest_Extension(class_name: \"Watashi\", extensions:\
    \ [\"tEN\", \"niNE\", \"eIGHt8OKe\"]) == \"Watashi.eIGHt8OKe\")\nassert(Strongest_Extension(class_name:\
    \ \"Boku123\", extensions: [\"nani\", \"NazeDa\", \"YEs.WeCaNe\", \"32145tggg\"\
    ]) == \"Boku123.YEs.WeCaNe\")\nassert(Strongest_Extension(class_name: \"__YESIMHERE\"\
    , extensions: [\"t\", \"eMptY\", \"nothing\", \"zeR00\", \"NuLl__\", \"123NoooneB321\"\
    ]) == \"__YESIMHERE.NuLl__\")\nassert(Strongest_Extension(class_name: \"K\", extensions:\
    \ [\"Ta\", \"TAR\", \"t234An\", \"cosSo\"]) == \"K.TAR\")\nassert(Strongest_Extension(class_name:\
    \ \"__HAHA\", extensions: [\"Tab\", \"123\", \"781345\", \"-_-\"]) == \"__HAHA.123\"\
    )\nassert(Strongest_Extension(class_name: \"YameRore\", extensions: [\"HhAas\"\
    , \"okIWILL123\", \"WorkOut\", \"Fails\", \"-_-\"]) == \"YameRore.okIWILL123\"\
    )\nassert(Strongest_Extension(class_name: \"finNNalLLly\", extensions: [\"Die\"\
    , \"NowW\", \"Wow\", \"WoW\"]) == \"finNNalLLly.WoW\")\nassert(Strongest_Extension(class_name:\
    \ \"_\", extensions: [\"Bb\", \"91245\"]) == \"_.Bb\")\nassert(Strongest_Extension(class_name:\
    \ \"Sp\", extensions: [\"671235\", \"Bb\"]) == \"Sp.671235\")"
  status: SyntaxError
  stderr: '/tmp/tmp1cstrpin.swift:20:1: error: missing return in global function expected
    to return ''String''

    }

    ^

    '
  stdout: ''
  timestamp: 1660009431
- exit_code: 1
  program: "\n/// You will be given the name of a class (a string) and an array of\
    \ extensions.\n/// The extensions are to be used to load additional classes to\
    \ the class. The\n/// strength of the extension is as follows: Let CAP be the\
    \ number of the uppercase\n/// letters in the extension's name, and let SM be\
    \ the number of lowercase letters \n/// in the extension's name, the strength\
    \ is given by the fraction CAP - SM. \n/// You should find the strongest extension\
    \ and return a string in this \n/// format: ClassName.StrongestExtensionName.\n\
    /// If there are two or more extensions with the same strength, you should\n///\
    \ choose the one that comes first in the array.\n/// For example, if you are given\
    \ \"Slices\" as the class and an array of the\n/// extensions: ['SErviNGSliCes',\
    \ 'Cheese', 'StuFfed'] then you should\n/// return 'Slices.SErviNGSliCes' since\
    \ 'SErviNGSliCes' is the strongest extension \n/// (its strength is -1).\n///\
    \ Example:\n/// >>> Strongest_Extension(class_name: \"my_class\", extensions:\
    \ [\"AA\", \"Be\", \"CC\"])\n/// \"my_class.AA\"\nfunc Strongest_Extension(class_name:\
    \ String, extensions: [String]) -> String {\n    // You code here!\n}\n\n\nfunc\
    \ ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count !=\
    \ right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(Strongest_Extension(class_name: \"Watashi\", extensions:\
    \ [\"tEN\", \"niNE\", \"eIGHt8OKe\"]) == \"Watashi.eIGHt8OKe\")\nassert(Strongest_Extension(class_name:\
    \ \"Boku123\", extensions: [\"nani\", \"NazeDa\", \"YEs.WeCaNe\", \"32145tggg\"\
    ]) == \"Boku123.YEs.WeCaNe\")\nassert(Strongest_Extension(class_name: \"__YESIMHERE\"\
    , extensions: [\"t\", \"eMptY\", \"nothing\", \"zeR00\", \"NuLl__\", \"123NoooneB321\"\
    ]) == \"__YESIMHERE.NuLl__\")\nassert(Strongest_Extension(class_name: \"K\", extensions:\
    \ [\"Ta\", \"TAR\", \"t234An\", \"cosSo\"]) == \"K.TAR\")\nassert(Strongest_Extension(class_name:\
    \ \"__HAHA\", extensions: [\"Tab\", \"123\", \"781345\", \"-_-\"]) == \"__HAHA.123\"\
    )\nassert(Strongest_Extension(class_name: \"YameRore\", extensions: [\"HhAas\"\
    , \"okIWILL123\", \"WorkOut\", \"Fails\", \"-_-\"]) == \"YameRore.okIWILL123\"\
    )\nassert(Strongest_Extension(class_name: \"finNNalLLly\", extensions: [\"Die\"\
    , \"NowW\", \"Wow\", \"WoW\"]) == \"finNNalLLly.WoW\")\nassert(Strongest_Extension(class_name:\
    \ \"_\", extensions: [\"Bb\", \"91245\"]) == \"_.Bb\")\nassert(Strongest_Extension(class_name:\
    \ \"Sp\", extensions: [\"671235\", \"Bb\"]) == \"Sp.671235\")"
  status: SyntaxError
  stderr: '/tmp/tmp3whtnig_.swift:20:1: error: missing return in global function expected
    to return ''String''

    }

    ^

    '
  stdout: ''
  timestamp: 1660009431
- exit_code: 1
  program: "\n/// You will be given the name of a class (a string) and an array of\
    \ extensions.\n/// The extensions are to be used to load additional classes to\
    \ the class. The\n/// strength of the extension is as follows: Let CAP be the\
    \ number of the uppercase\n/// letters in the extension's name, and let SM be\
    \ the number of lowercase letters \n/// in the extension's name, the strength\
    \ is given by the fraction CAP - SM. \n/// You should find the strongest extension\
    \ and return a string in this \n/// format: ClassName.StrongestExtensionName.\n\
    /// If there are two or more extensions with the same strength, you should\n///\
    \ choose the one that comes first in the array.\n/// For example, if you are given\
    \ \"Slices\" as the class and an array of the\n/// extensions: ['SErviNGSliCes',\
    \ 'Cheese', 'StuFfed'] then you should\n/// return 'Slices.SErviNGSliCes' since\
    \ 'SErviNGSliCes' is the strongest extension \n/// (its strength is -1).\n///\
    \ Example:\n/// >>> Strongest_Extension(class_name: \"my_class\", extensions:\
    \ [\"AA\", \"Be\", \"CC\"])\n/// \"my_class.AA\"\nfunc Strongest_Extension(class_name:\
    \ String, extensions: [String]) -> String {\n    var strongest_extension: String\
    \ = \"\";\n    var max_strength: Double = -1.0;\n    for ext in extensions {\n\
    \        let cap = ext.uppercased().characters.filter {$0 >= \"A\" && $0 <= \"\
    Z\"}.count;\n        let sm = ext.characters.filter {$0 >= \"a\" && $0 <= \"z\"\
    }.count;\n        let strength = Double(cap) - Double(sm);\n        if (strength\
    \ > max_strength) {\n            max_strength = strength;\n            strongest_extension\
    \ = ext;\n        }\n    }\n    return class_name + \".\" + strongest_extension;\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(Strongest_Extension(class_name: \"Watashi\", extensions:\
    \ [\"tEN\", \"niNE\", \"eIGHt8OKe\"]) == \"Watashi.eIGHt8OKe\")\nassert(Strongest_Extension(class_name:\
    \ \"Boku123\", extensions: [\"nani\", \"NazeDa\", \"YEs.WeCaNe\", \"32145tggg\"\
    ]) == \"Boku123.YEs.WeCaNe\")\nassert(Strongest_Extension(class_name: \"__YESIMHERE\"\
    , extensions: [\"t\", \"eMptY\", \"nothing\", \"zeR00\", \"NuLl__\", \"123NoooneB321\"\
    ]) == \"__YESIMHERE.NuLl__\")\nassert(Strongest_Extension(class_name: \"K\", extensions:\
    \ [\"Ta\", \"TAR\", \"t234An\", \"cosSo\"]) == \"K.TAR\")\nassert(Strongest_Extension(class_name:\
    \ \"__HAHA\", extensions: [\"Tab\", \"123\", \"781345\", \"-_-\"]) == \"__HAHA.123\"\
    )\nassert(Strongest_Extension(class_name: \"YameRore\", extensions: [\"HhAas\"\
    , \"okIWILL123\", \"WorkOut\", \"Fails\", \"-_-\"]) == \"YameRore.okIWILL123\"\
    )\nassert(Strongest_Extension(class_name: \"finNNalLLly\", extensions: [\"Die\"\
    , \"NowW\", \"Wow\", \"WoW\"]) == \"finNNalLLly.WoW\")\nassert(Strongest_Extension(class_name:\
    \ \"_\", extensions: [\"Bb\", \"91245\"]) == \"_.Bb\")\nassert(Strongest_Extension(class_name:\
    \ \"Sp\", extensions: [\"671235\", \"Bb\"]) == \"Sp.671235\")"
  status: SyntaxError
  stderr: "/tmp/tmpitqy6r3y.swift:22:36: error: 'characters' is unavailable: Please\
    \ use String directly\n        let cap = ext.uppercased().characters.filter {$0\
    \ >= \"A\" && $0 <= \"Z\"}.count;\n                                   ^~~~~~~~~~\n\
    Swift.String:5:16: note: 'characters' was obsoleted in Swift 5.0\n    public var\
    \ characters: String { get set }\n               ^\n/tmp/tmpitqy6r3y.swift:23:22:\
    \ error: 'characters' is unavailable: Please use String directly\n        let\
    \ sm = ext.characters.filter {$0 >= \"a\" && $0 <= \"z\"}.count;\n           \
    \          ^~~~~~~~~~\nSwift.String:5:16: note: 'characters' was obsoleted in\
    \ Swift 5.0\n    public var characters: String { get set }\n               ^\n"
  stdout: ''
  timestamp: 1660009431
- exit_code: -4
  program: "\n/// You will be given the name of a class (a string) and an array of\
    \ extensions.\n/// The extensions are to be used to load additional classes to\
    \ the class. The\n/// strength of the extension is as follows: Let CAP be the\
    \ number of the uppercase\n/// letters in the extension's name, and let SM be\
    \ the number of lowercase letters \n/// in the extension's name, the strength\
    \ is given by the fraction CAP - SM. \n/// You should find the strongest extension\
    \ and return a string in this \n/// format: ClassName.StrongestExtensionName.\n\
    /// If there are two or more extensions with the same strength, you should\n///\
    \ choose the one that comes first in the array.\n/// For example, if you are given\
    \ \"Slices\" as the class and an array of the\n/// extensions: ['SErviNGSliCes',\
    \ 'Cheese', 'StuFfed'] then you should\n/// return 'Slices.SErviNGSliCes' since\
    \ 'SErviNGSliCes' is the strongest extension \n/// (its strength is -1).\n///\
    \ Example:\n/// >>> Strongest_Extension(class_name: \"my_class\", extensions:\
    \ [\"AA\", \"Be\", \"CC\"])\n/// \"my_class.AA\"\nfunc Strongest_Extension(class_name:\
    \ String, extensions: [String]) -> String {\n    var max = -1.0\n    var s = \"\
    \"\n    for i in extensions {\n        var upper = 0\n        var lower = 0\n\
    \        for char in i {\n            if char.isUppercase {\n                upper\
    \ += 1\n            } else {\n                lower += 1\n            }\n    \
    \    }\n        let current = Double(upper) - Double(lower)\n        if current\
    \ > max {\n            max = current\n            s = i\n        }\n    }\n  \
    \  return \"\\(class_name).\\(s)\"\n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(Strongest_Extension(class_name: \"Watashi\", extensions: [\"tEN\", \"niNE\"\
    , \"eIGHt8OKe\"]) == \"Watashi.eIGHt8OKe\")\nassert(Strongest_Extension(class_name:\
    \ \"Boku123\", extensions: [\"nani\", \"NazeDa\", \"YEs.WeCaNe\", \"32145tggg\"\
    ]) == \"Boku123.YEs.WeCaNe\")\nassert(Strongest_Extension(class_name: \"__YESIMHERE\"\
    , extensions: [\"t\", \"eMptY\", \"nothing\", \"zeR00\", \"NuLl__\", \"123NoooneB321\"\
    ]) == \"__YESIMHERE.NuLl__\")\nassert(Strongest_Extension(class_name: \"K\", extensions:\
    \ [\"Ta\", \"TAR\", \"t234An\", \"cosSo\"]) == \"K.TAR\")\nassert(Strongest_Extension(class_name:\
    \ \"__HAHA\", extensions: [\"Tab\", \"123\", \"781345\", \"-_-\"]) == \"__HAHA.123\"\
    )\nassert(Strongest_Extension(class_name: \"YameRore\", extensions: [\"HhAas\"\
    , \"okIWILL123\", \"WorkOut\", \"Fails\", \"-_-\"]) == \"YameRore.okIWILL123\"\
    )\nassert(Strongest_Extension(class_name: \"finNNalLLly\", extensions: [\"Die\"\
    , \"NowW\", \"Wow\", \"WoW\"]) == \"finNNalLLly.WoW\")\nassert(Strongest_Extension(class_name:\
    \ \"_\", extensions: [\"Bb\", \"91245\"]) == \"_.Bb\")\nassert(Strongest_Extension(class_name:\
    \ \"Sp\", extensions: [\"671235\", \"Bb\"]) == \"Sp.671235\")"
  status: Exception
  stderr: 'tmpiwh8dxqp/tmpiwh8dxqp.swift:53: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b46d5a1ec80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b46d5715b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b46d5715988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b46d57147b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpiwh8dxqp                        0x000055e79c4caa3d <unavailable> + 6717

    5    libc.so.6                          0x00002b46d5c0a460 __libc_start_main +
    245

    6    tmpiwh8dxqp                        0x000055e79c4ca5c9 <unavailable> + 5577

    '
  stdout: ''
  timestamp: 1660009431
- exit_code: -4
  program: "\n/// You will be given the name of a class (a string) and an array of\
    \ extensions.\n/// The extensions are to be used to load additional classes to\
    \ the class. The\n/// strength of the extension is as follows: Let CAP be the\
    \ number of the uppercase\n/// letters in the extension's name, and let SM be\
    \ the number of lowercase letters \n/// in the extension's name, the strength\
    \ is given by the fraction CAP - SM. \n/// You should find the strongest extension\
    \ and return a string in this \n/// format: ClassName.StrongestExtensionName.\n\
    /// If there are two or more extensions with the same strength, you should\n///\
    \ choose the one that comes first in the array.\n/// For example, if you are given\
    \ \"Slices\" as the class and an array of the\n/// extensions: ['SErviNGSliCes',\
    \ 'Cheese', 'StuFfed'] then you should\n/// return 'Slices.SErviNGSliCes' since\
    \ 'SErviNGSliCes' is the strongest extension \n/// (its strength is -1).\n///\
    \ Example:\n/// >>> Strongest_Extension(class_name: \"my_class\", extensions:\
    \ [\"AA\", \"Be\", \"CC\"])\n/// \"my_class.AA\"\nfunc Strongest_Extension(class_name:\
    \ String, extensions: [String]) -> String {\n    let class_name = class_name\n\
    \    var extensions = extensions\n    var strong = extensions[0]\n    var strong_num\
    \ = 0.0\n    var ext_num = 0.0\n    for extension_name in extensions {\n     \
    \   for letter in extension_name {\n            if letter.isUppercase {\n    \
    \            ext_num += 1\n            } else {\n                ext_num -= 1\n\
    \            }\n        }\n        if ext_num > strong_num {\n            strong_num\
    \ = ext_num\n            strong = extension_name\n        }\n        ext_num =\
    \ 0\n    }\n    let result = \"\\(class_name).\\(strong)\"\n    return result\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(Strongest_Extension(class_name: \"Watashi\", extensions:\
    \ [\"tEN\", \"niNE\", \"eIGHt8OKe\"]) == \"Watashi.eIGHt8OKe\")\nassert(Strongest_Extension(class_name:\
    \ \"Boku123\", extensions: [\"nani\", \"NazeDa\", \"YEs.WeCaNe\", \"32145tggg\"\
    ]) == \"Boku123.YEs.WeCaNe\")\nassert(Strongest_Extension(class_name: \"__YESIMHERE\"\
    , extensions: [\"t\", \"eMptY\", \"nothing\", \"zeR00\", \"NuLl__\", \"123NoooneB321\"\
    ]) == \"__YESIMHERE.NuLl__\")\nassert(Strongest_Extension(class_name: \"K\", extensions:\
    \ [\"Ta\", \"TAR\", \"t234An\", \"cosSo\"]) == \"K.TAR\")\nassert(Strongest_Extension(class_name:\
    \ \"__HAHA\", extensions: [\"Tab\", \"123\", \"781345\", \"-_-\"]) == \"__HAHA.123\"\
    )\nassert(Strongest_Extension(class_name: \"YameRore\", extensions: [\"HhAas\"\
    , \"okIWILL123\", \"WorkOut\", \"Fails\", \"-_-\"]) == \"YameRore.okIWILL123\"\
    )\nassert(Strongest_Extension(class_name: \"finNNalLLly\", extensions: [\"Die\"\
    , \"NowW\", \"Wow\", \"WoW\"]) == \"finNNalLLly.WoW\")\nassert(Strongest_Extension(class_name:\
    \ \"_\", extensions: [\"Bb\", \"91245\"]) == \"_.Bb\")\nassert(Strongest_Extension(class_name:\
    \ \"Sp\", extensions: [\"671235\", \"Bb\"]) == \"Sp.671235\")"
  status: Exception
  stderr: 'tmp7b7f70l5/tmp7b7f70l5.swift:55: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b8a29a0ec80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b8a29705b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b8a29705988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b8a297047b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmp7b7f70l5                        0x000055d84eca2a8d <unavailable> + 6797

    5    libc.so.6                          0x00002b8a29bfa460 __libc_start_main +
    245

    6    tmp7b7f70l5                        0x000055d84eca2619 <unavailable> + 5657

    '
  stdout: ''
  timestamp: 1660009432
- exit_code: -4
  program: "\n/// You will be given the name of a class (a string) and an array of\
    \ extensions.\n/// The extensions are to be used to load additional classes to\
    \ the class. The\n/// strength of the extension is as follows: Let CAP be the\
    \ number of the uppercase\n/// letters in the extension's name, and let SM be\
    \ the number of lowercase letters \n/// in the extension's name, the strength\
    \ is given by the fraction CAP - SM. \n/// You should find the strongest extension\
    \ and return a string in this \n/// format: ClassName.StrongestExtensionName.\n\
    /// If there are two or more extensions with the same strength, you should\n///\
    \ choose the one that comes first in the array.\n/// For example, if you are given\
    \ \"Slices\" as the class and an array of the\n/// extensions: ['SErviNGSliCes',\
    \ 'Cheese', 'StuFfed'] then you should\n/// return 'Slices.SErviNGSliCes' since\
    \ 'SErviNGSliCes' is the strongest extension \n/// (its strength is -1).\n///\
    \ Example:\n/// >>> Strongest_Extension(class_name: \"my_class\", extensions:\
    \ [\"AA\", \"Be\", \"CC\"])\n/// \"my_class.AA\"\nfunc Strongest_Extension(class_name:\
    \ String, extensions: [String]) -> String {\n    // Write your code here.\n  \
    \  return \"\"\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool\
    \ {\n    if left.count != right.count {\n        return false\n    }\n    for\
    \ (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(Strongest_Extension(class_name:\
    \ \"Watashi\", extensions: [\"tEN\", \"niNE\", \"eIGHt8OKe\"]) == \"Watashi.eIGHt8OKe\"\
    )\nassert(Strongest_Extension(class_name: \"Boku123\", extensions: [\"nani\",\
    \ \"NazeDa\", \"YEs.WeCaNe\", \"32145tggg\"]) == \"Boku123.YEs.WeCaNe\")\nassert(Strongest_Extension(class_name:\
    \ \"__YESIMHERE\", extensions: [\"t\", \"eMptY\", \"nothing\", \"zeR00\", \"NuLl__\"\
    , \"123NoooneB321\"]) == \"__YESIMHERE.NuLl__\")\nassert(Strongest_Extension(class_name:\
    \ \"K\", extensions: [\"Ta\", \"TAR\", \"t234An\", \"cosSo\"]) == \"K.TAR\")\n\
    assert(Strongest_Extension(class_name: \"__HAHA\", extensions: [\"Tab\", \"123\"\
    , \"781345\", \"-_-\"]) == \"__HAHA.123\")\nassert(Strongest_Extension(class_name:\
    \ \"YameRore\", extensions: [\"HhAas\", \"okIWILL123\", \"WorkOut\", \"Fails\"\
    , \"-_-\"]) == \"YameRore.okIWILL123\")\nassert(Strongest_Extension(class_name:\
    \ \"finNNalLLly\", extensions: [\"Die\", \"NowW\", \"Wow\", \"WoW\"]) == \"finNNalLLly.WoW\"\
    )\nassert(Strongest_Extension(class_name: \"_\", extensions: [\"Bb\", \"91245\"\
    ]) == \"_.Bb\")\nassert(Strongest_Extension(class_name: \"Sp\", extensions: [\"\
    671235\", \"Bb\"]) == \"Sp.671235\")"
  status: Exception
  stderr: 'tmp7h5sins9/tmp7h5sins9.swift:36: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002aff37a2dc80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002aff37724b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002aff37724988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002aff377237b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmp7h5sins9                        0x0000557babc784fd <unavailable> + 5373

    5    libc.so.6                          0x00002aff37c19460 __libc_start_main +
    245

    6    tmp7h5sins9                        0x0000557babc78089 <unavailable> + 4233

    '
  stdout: ''
  timestamp: 1660009431
- exit_code: 1
  program: "\n/// You will be given the name of a class (a string) and an array of\
    \ extensions.\n/// The extensions are to be used to load additional classes to\
    \ the class. The\n/// strength of the extension is as follows: Let CAP be the\
    \ number of the uppercase\n/// letters in the extension's name, and let SM be\
    \ the number of lowercase letters \n/// in the extension's name, the strength\
    \ is given by the fraction CAP - SM. \n/// You should find the strongest extension\
    \ and return a string in this \n/// format: ClassName.StrongestExtensionName.\n\
    /// If there are two or more extensions with the same strength, you should\n///\
    \ choose the one that comes first in the array.\n/// For example, if you are given\
    \ \"Slices\" as the class and an array of the\n/// extensions: ['SErviNGSliCes',\
    \ 'Cheese', 'StuFfed'] then you should\n/// return 'Slices.SErviNGSliCes' since\
    \ 'SErviNGSliCes' is the strongest extension \n/// (its strength is -1).\n///\
    \ Example:\n/// >>> Strongest_Extension(class_name: \"my_class\", extensions:\
    \ [\"AA\", \"Be\", \"CC\"])\n/// \"my_class.AA\"\nfunc Strongest_Extension(class_name:\
    \ String, extensions: [String]) -> String {\n    var strongest = [\"class\" :\
    \ class_name, \"extension\" : \"\", \"strength\" : 0]\n    for ext in extensions\
    \ {\n        var capital_count = 0\n        var small_count = 0\n        for letter\
    \ in ext {\n            if letter.isUppercase {\n                capital_count\
    \ += 1\n            } else {\n                small_count += 1\n            }\n\
    \        }\n        let strength = capital_count - small_count\n        if strength\
    \ > strongest[\"strength\"]! {\n            strongest[\"extension\"] = ext\n \
    \           strongest[\"strength\"] = strength\n        }\n    }\n    return strongest[\"\
    class\"]! + \".\" + strongest[\"extension\"]!\n}\n\n\nfunc ==(left: [(Int, Int)],\
    \ right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n       \
    \ return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r\
    \ {\n            return false\n        }\n    }\n    return true\n}\n        \
    \    \nassert(Strongest_Extension(class_name: \"Watashi\", extensions: [\"tEN\"\
    , \"niNE\", \"eIGHt8OKe\"]) == \"Watashi.eIGHt8OKe\")\nassert(Strongest_Extension(class_name:\
    \ \"Boku123\", extensions: [\"nani\", \"NazeDa\", \"YEs.WeCaNe\", \"32145tggg\"\
    ]) == \"Boku123.YEs.WeCaNe\")\nassert(Strongest_Extension(class_name: \"__YESIMHERE\"\
    , extensions: [\"t\", \"eMptY\", \"nothing\", \"zeR00\", \"NuLl__\", \"123NoooneB321\"\
    ]) == \"__YESIMHERE.NuLl__\")\nassert(Strongest_Extension(class_name: \"K\", extensions:\
    \ [\"Ta\", \"TAR\", \"t234An\", \"cosSo\"]) == \"K.TAR\")\nassert(Strongest_Extension(class_name:\
    \ \"__HAHA\", extensions: [\"Tab\", \"123\", \"781345\", \"-_-\"]) == \"__HAHA.123\"\
    )\nassert(Strongest_Extension(class_name: \"YameRore\", extensions: [\"HhAas\"\
    , \"okIWILL123\", \"WorkOut\", \"Fails\", \"-_-\"]) == \"YameRore.okIWILL123\"\
    )\nassert(Strongest_Extension(class_name: \"finNNalLLly\", extensions: [\"Die\"\
    , \"NowW\", \"Wow\", \"WoW\"]) == \"finNNalLLly.WoW\")\nassert(Strongest_Extension(class_name:\
    \ \"_\", extensions: [\"Bb\", \"91245\"]) == \"_.Bb\")\nassert(Strongest_Extension(class_name:\
    \ \"Sp\", extensions: [\"671235\", \"Bb\"]) == \"Sp.671235\")"
  status: SyntaxError
  stderr: "/tmp/tmp1koncawh.swift:19:21: error: heterogeneous collection literal could\
    \ only be inferred to '[String : Any]'; add explicit type annotation if this is\
    \ intentional\n    var strongest = [\"class\" : class_name, \"extension\" : \"\
    \", \"strength\" : 0]\n                    ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n\
    \                                                                            \
    \ as [String : Any]\n/tmp/tmp1koncawh.swift:31:44: error: cannot convert value\
    \ of type 'Any' to expected argument type 'Int'\n        if strength > strongest[\"\
    strength\"]! {\n                                           ^\n               \
    \                              as! Int\n/tmp/tmp1koncawh.swift:36:30: error: cannot\
    \ convert value of type 'Any' to expected argument type 'String'\n    return strongest[\"\
    class\"]! + \".\" + strongest[\"extension\"]!\n                             ^\n\
    \                               as! String\n/tmp/tmp1koncawh.swift:36:62: error:\
    \ cannot convert value of type 'Any' to expected argument type 'String'\n    return\
    \ strongest[\"class\"]! + \".\" + strongest[\"extension\"]!\n                \
    \                                             ^\n                            \
    \                                   as! String\n"
  stdout: ''
  timestamp: 1660009431
- exit_code: -4
  program: "\n/// You will be given the name of a class (a string) and an array of\
    \ extensions.\n/// The extensions are to be used to load additional classes to\
    \ the class. The\n/// strength of the extension is as follows: Let CAP be the\
    \ number of the uppercase\n/// letters in the extension's name, and let SM be\
    \ the number of lowercase letters \n/// in the extension's name, the strength\
    \ is given by the fraction CAP - SM. \n/// You should find the strongest extension\
    \ and return a string in this \n/// format: ClassName.StrongestExtensionName.\n\
    /// If there are two or more extensions with the same strength, you should\n///\
    \ choose the one that comes first in the array.\n/// For example, if you are given\
    \ \"Slices\" as the class and an array of the\n/// extensions: ['SErviNGSliCes',\
    \ 'Cheese', 'StuFfed'] then you should\n/// return 'Slices.SErviNGSliCes' since\
    \ 'SErviNGSliCes' is the strongest extension \n/// (its strength is -1).\n///\
    \ Example:\n/// >>> Strongest_Extension(class_name: \"my_class\", extensions:\
    \ [\"AA\", \"Be\", \"CC\"])\n/// \"my_class.AA\"\nfunc Strongest_Extension(class_name:\
    \ String, extensions: [String]) -> String {\n    var strongest_extension: String\
    \ = \"\"\n    var strongest_strength: Float = 0.0\n    for extension_name in extensions\
    \ {\n        var num_upper: Int = 0\n        var num_lower: Int = 0\n        for\
    \ char in extension_name {\n            if char.isUppercase {\n              \
    \  num_upper += 1\n            } else {\n                num_lower += 1\n    \
    \        }\n        }\n        let strength: Float = Float(num_upper) - Float(num_lower)\n\
    \        if strength > strongest_strength {\n            strongest_strength =\
    \ strength\n            strongest_extension = extension_name\n        }\n    }\n\
    \    return \"\\(class_name).\\(strongest_extension)\"\n}\n\n\nfunc ==(left: [(Int,\
    \ Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n\
    \        return false\n    }\n    for (l, r) in zip(left, right) {\n        if\
    \ l != r {\n            return false\n        }\n    }\n    return true\n}\n \
    \           \nassert(Strongest_Extension(class_name: \"Watashi\", extensions:\
    \ [\"tEN\", \"niNE\", \"eIGHt8OKe\"]) == \"Watashi.eIGHt8OKe\")\nassert(Strongest_Extension(class_name:\
    \ \"Boku123\", extensions: [\"nani\", \"NazeDa\", \"YEs.WeCaNe\", \"32145tggg\"\
    ]) == \"Boku123.YEs.WeCaNe\")\nassert(Strongest_Extension(class_name: \"__YESIMHERE\"\
    , extensions: [\"t\", \"eMptY\", \"nothing\", \"zeR00\", \"NuLl__\", \"123NoooneB321\"\
    ]) == \"__YESIMHERE.NuLl__\")\nassert(Strongest_Extension(class_name: \"K\", extensions:\
    \ [\"Ta\", \"TAR\", \"t234An\", \"cosSo\"]) == \"K.TAR\")\nassert(Strongest_Extension(class_name:\
    \ \"__HAHA\", extensions: [\"Tab\", \"123\", \"781345\", \"-_-\"]) == \"__HAHA.123\"\
    )\nassert(Strongest_Extension(class_name: \"YameRore\", extensions: [\"HhAas\"\
    , \"okIWILL123\", \"WorkOut\", \"Fails\", \"-_-\"]) == \"YameRore.okIWILL123\"\
    )\nassert(Strongest_Extension(class_name: \"finNNalLLly\", extensions: [\"Die\"\
    , \"NowW\", \"Wow\", \"WoW\"]) == \"finNNalLLly.WoW\")\nassert(Strongest_Extension(class_name:\
    \ \"_\", extensions: [\"Bb\", \"91245\"]) == \"_.Bb\")\nassert(Strongest_Extension(class_name:\
    \ \"Sp\", extensions: [\"671235\", \"Bb\"]) == \"Sp.671235\")"
  status: Exception
  stderr: 'tmpn6n9o32f/tmpn6n9o32f.swift:53: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b57aea23c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b57ae71ab6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b57ae71a988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b57ae7197b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpn6n9o32f                        0x000055c95ae72a3d <unavailable> + 6717

    5    libc.so.6                          0x00002b57aec0f460 __libc_start_main +
    245

    6    tmpn6n9o32f                        0x000055c95ae725c9 <unavailable> + 5577

    '
  stdout: ''
  timestamp: 1660009432
- exit_code: 1
  program: "\n/// You will be given the name of a class (a string) and an array of\
    \ extensions.\n/// The extensions are to be used to load additional classes to\
    \ the class. The\n/// strength of the extension is as follows: Let CAP be the\
    \ number of the uppercase\n/// letters in the extension's name, and let SM be\
    \ the number of lowercase letters \n/// in the extension's name, the strength\
    \ is given by the fraction CAP - SM. \n/// You should find the strongest extension\
    \ and return a string in this \n/// format: ClassName.StrongestExtensionName.\n\
    /// If there are two or more extensions with the same strength, you should\n///\
    \ choose the one that comes first in the array.\n/// For example, if you are given\
    \ \"Slices\" as the class and an array of the\n/// extensions: ['SErviNGSliCes',\
    \ 'Cheese', 'StuFfed'] then you should\n/// return 'Slices.SErviNGSliCes' since\
    \ 'SErviNGSliCes' is the strongest extension \n/// (its strength is -1).\n///\
    \ Example:\n/// >>> Strongest_Extension(class_name: \"my_class\", extensions:\
    \ [\"AA\", \"Be\", \"CC\"])\n/// \"my_class.AA\"\nfunc Strongest_Extension(class_name:\
    \ String, extensions: [String]) -> String {\n    let upp = \"[A-Z]\"\n    let\
    \ low = \"[a-z]\"\n    var strongest = 0.0\n    var strongest_str = String()\n\
    \    for ext in extensions {\n        let reg = try! NSRegularExpression(pattern:\
    \ upp, options: [])\n        let uppercase_number = reg.numberOfMatches(in: ext,\
    \ options: [], range: NSRange(location: 0, length: ext.count))\n        let reg2\
    \ = try! NSRegularExpression(pattern: low, options: [])\n        let lowercase_number\
    \ = reg2.numberOfMatches(in: ext, options: [], range: NSRange(location: 0, length:\
    \ ext.count))\n        let strength = Double(uppercase_number) - Double(lowercase_number)\n\
    \        if strength > strongest {\n            strongest = strength\n       \
    \     strongest_str = ext\n        }\n    }\n    return \"\\(class_name).\\(strongest_str)\"\
    \n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(Strongest_Extension(class_name: \"Watashi\", extensions:\
    \ [\"tEN\", \"niNE\", \"eIGHt8OKe\"]) == \"Watashi.eIGHt8OKe\")\nassert(Strongest_Extension(class_name:\
    \ \"Boku123\", extensions: [\"nani\", \"NazeDa\", \"YEs.WeCaNe\", \"32145tggg\"\
    ]) == \"Boku123.YEs.WeCaNe\")\nassert(Strongest_Extension(class_name: \"__YESIMHERE\"\
    , extensions: [\"t\", \"eMptY\", \"nothing\", \"zeR00\", \"NuLl__\", \"123NoooneB321\"\
    ]) == \"__YESIMHERE.NuLl__\")\nassert(Strongest_Extension(class_name: \"K\", extensions:\
    \ [\"Ta\", \"TAR\", \"t234An\", \"cosSo\"]) == \"K.TAR\")\nassert(Strongest_Extension(class_name:\
    \ \"__HAHA\", extensions: [\"Tab\", \"123\", \"781345\", \"-_-\"]) == \"__HAHA.123\"\
    )\nassert(Strongest_Extension(class_name: \"YameRore\", extensions: [\"HhAas\"\
    , \"okIWILL123\", \"WorkOut\", \"Fails\", \"-_-\"]) == \"YameRore.okIWILL123\"\
    )\nassert(Strongest_Extension(class_name: \"finNNalLLly\", extensions: [\"Die\"\
    , \"NowW\", \"Wow\", \"WoW\"]) == \"finNNalLLly.WoW\")\nassert(Strongest_Extension(class_name:\
    \ \"_\", extensions: [\"Bb\", \"91245\"]) == \"_.Bb\")\nassert(Strongest_Extension(class_name:\
    \ \"Sp\", extensions: [\"671235\", \"Bb\"]) == \"Sp.671235\")"
  status: SyntaxError
  stderr: "/tmp/tmpd78kzxq8.swift:24:24: error: cannot find 'NSRegularExpression'\
    \ in scope\n        let reg = try! NSRegularExpression(pattern: upp, options:\
    \ [])\n                       ^~~~~~~~~~~~~~~~~~~\n/tmp/tmpd78kzxq8.swift:25:81:\
    \ error: cannot find 'NSRange' in scope\n        let uppercase_number = reg.numberOfMatches(in:\
    \ ext, options: [], range: NSRange(location: 0, length: ext.count))\n        \
    \                                                                        ^~~~~~~\n\
    /tmp/tmpd78kzxq8.swift:26:25: error: cannot find 'NSRegularExpression' in scope\n\
    \        let reg2 = try! NSRegularExpression(pattern: low, options: [])\n    \
    \                    ^~~~~~~~~~~~~~~~~~~\n/tmp/tmpd78kzxq8.swift:27:82: error:\
    \ cannot find 'NSRange' in scope\n        let lowercase_number = reg2.numberOfMatches(in:\
    \ ext, options: [], range: NSRange(location: 0, length: ext.count))\n        \
    \                                                                         ^~~~~~~\n"
  stdout: ''
  timestamp: 1660009431
- exit_code: -4
  program: "\n/// You will be given the name of a class (a string) and an array of\
    \ extensions.\n/// The extensions are to be used to load additional classes to\
    \ the class. The\n/// strength of the extension is as follows: Let CAP be the\
    \ number of the uppercase\n/// letters in the extension's name, and let SM be\
    \ the number of lowercase letters \n/// in the extension's name, the strength\
    \ is given by the fraction CAP - SM. \n/// You should find the strongest extension\
    \ and return a string in this \n/// format: ClassName.StrongestExtensionName.\n\
    /// If there are two or more extensions with the same strength, you should\n///\
    \ choose the one that comes first in the array.\n/// For example, if you are given\
    \ \"Slices\" as the class and an array of the\n/// extensions: ['SErviNGSliCes',\
    \ 'Cheese', 'StuFfed'] then you should\n/// return 'Slices.SErviNGSliCes' since\
    \ 'SErviNGSliCes' is the strongest extension \n/// (its strength is -1).\n///\
    \ Example:\n/// >>> Strongest_Extension(class_name: \"my_class\", extensions:\
    \ [\"AA\", \"Be\", \"CC\"])\n/// \"my_class.AA\"\nfunc Strongest_Extension(class_name:\
    \ String, extensions: [String]) -> String {\n    // Get strength of each extensions\n\
    \    var strengths = [Double]()\n    for ext in extensions {\n        var CAP_count\
    \ = 0\n        var SM_count = 0\n        for char in ext {\n            if char.isUppercase\
    \ {\n                CAP_count += 1\n            } else {\n                SM_count\
    \ += 1\n            }\n        }\n        let strength = Double(CAP_count) - Double(SM_count)\n\
    \        strengths.append(strength)\n    }\n    // Get the max strength and the\
    \ index\n    var (max_strength, idx) = (strengths[0], 0)\n    for i in 1..<strengths.count\
    \ {\n        if strengths[i] > max_strength {\n            max_strength = strengths[i]\n\
    \            idx = i\n        }\n    }\n    // Return the string\n    return \"\
    \\(class_name).\\(extensions[idx])\"\n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(Strongest_Extension(class_name: \"Watashi\", extensions: [\"tEN\", \"niNE\"\
    , \"eIGHt8OKe\"]) == \"Watashi.eIGHt8OKe\")\nassert(Strongest_Extension(class_name:\
    \ \"Boku123\", extensions: [\"nani\", \"NazeDa\", \"YEs.WeCaNe\", \"32145tggg\"\
    ]) == \"Boku123.YEs.WeCaNe\")\nassert(Strongest_Extension(class_name: \"__YESIMHERE\"\
    , extensions: [\"t\", \"eMptY\", \"nothing\", \"zeR00\", \"NuLl__\", \"123NoooneB321\"\
    ]) == \"__YESIMHERE.NuLl__\")\nassert(Strongest_Extension(class_name: \"K\", extensions:\
    \ [\"Ta\", \"TAR\", \"t234An\", \"cosSo\"]) == \"K.TAR\")\nassert(Strongest_Extension(class_name:\
    \ \"__HAHA\", extensions: [\"Tab\", \"123\", \"781345\", \"-_-\"]) == \"__HAHA.123\"\
    )\nassert(Strongest_Extension(class_name: \"YameRore\", extensions: [\"HhAas\"\
    , \"okIWILL123\", \"WorkOut\", \"Fails\", \"-_-\"]) == \"YameRore.okIWILL123\"\
    )\nassert(Strongest_Extension(class_name: \"finNNalLLly\", extensions: [\"Die\"\
    , \"NowW\", \"Wow\", \"WoW\"]) == \"finNNalLLly.WoW\")\nassert(Strongest_Extension(class_name:\
    \ \"_\", extensions: [\"Bb\", \"91245\"]) == \"_.Bb\")\nassert(Strongest_Extension(class_name:\
    \ \"Sp\", extensions: [\"671235\", \"Bb\"]) == \"Sp.671235\")"
  status: Exception
  stderr: 'tmpsjfx1tvr/tmpsjfx1tvr.swift:59: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b1ded2b5c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b1decfacb6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b1decfac988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b1decfab7b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpsjfx1tvr                        0x0000556684136d7d <unavailable> + 7549

    5    libc.so.6                          0x00002b1ded4a1460 __libc_start_main +
    245

    6    tmpsjfx1tvr                        0x0000556684136909 <unavailable> + 6409

    '
  stdout: ''
  timestamp: 1660009432
- exit_code: 1
  program: "\n/// You will be given the name of a class (a string) and an array of\
    \ extensions.\n/// The extensions are to be used to load additional classes to\
    \ the class. The\n/// strength of the extension is as follows: Let CAP be the\
    \ number of the uppercase\n/// letters in the extension's name, and let SM be\
    \ the number of lowercase letters \n/// in the extension's name, the strength\
    \ is given by the fraction CAP - SM. \n/// You should find the strongest extension\
    \ and return a string in this \n/// format: ClassName.StrongestExtensionName.\n\
    /// If there are two or more extensions with the same strength, you should\n///\
    \ choose the one that comes first in the array.\n/// For example, if you are given\
    \ \"Slices\" as the class and an array of the\n/// extensions: ['SErviNGSliCes',\
    \ 'Cheese', 'StuFfed'] then you should\n/// return 'Slices.SErviNGSliCes' since\
    \ 'SErviNGSliCes' is the strongest extension \n/// (its strength is -1).\n///\
    \ Example:\n/// >>> Strongest_Extension(class_name: \"my_class\", extensions:\
    \ [\"AA\", \"Be\", \"CC\"])\n/// \"my_class.AA\"\nfunc Strongest_Extension(class_name:\
    \ String, extensions: [String]) -> String {\n    let uppercase_reg_ex = \"([A-Z])\"\
    \n    let lowercase_reg_ex = \"([a-z])\"\n    var uppercase_cap = 0\n    var lowercase_sm\
    \ = 0\n    var curr_extension = \"\"\n    var strongest_extension = \"\"\n   \
    \ var strength = 0.0\n    var strongest_strength = 0.0\n    for extension_name\
    \ in extensions {\n        let uppercase_matches = matches_for_reg_ex(reg_ex:\
    \ uppercase_reg_ex, string: extension_name)\n        let lowercase_matches = matches_for_reg_ex(reg_ex:\
    \ lowercase_reg_ex, string: extension_name)\n        uppercase_cap = uppercase_matches.count\n\
    \        lowercase_sm = lowercase_matches.count\n        strength = Double(uppercase_cap)\
    \ - Double(lowercase_sm)\n        if strength > strongest_strength {\n       \
    \     strongest_strength = strength\n            strongest_extension = extension_name\n\
    \        }\n    }\n    return \"\\(class_name).\\(strongest_extension)\"\n}\n\n\
    \nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(Strongest_Extension(class_name: \"Watashi\", extensions:\
    \ [\"tEN\", \"niNE\", \"eIGHt8OKe\"]) == \"Watashi.eIGHt8OKe\")\nassert(Strongest_Extension(class_name:\
    \ \"Boku123\", extensions: [\"nani\", \"NazeDa\", \"YEs.WeCaNe\", \"32145tggg\"\
    ]) == \"Boku123.YEs.WeCaNe\")\nassert(Strongest_Extension(class_name: \"__YESIMHERE\"\
    , extensions: [\"t\", \"eMptY\", \"nothing\", \"zeR00\", \"NuLl__\", \"123NoooneB321\"\
    ]) == \"__YESIMHERE.NuLl__\")\nassert(Strongest_Extension(class_name: \"K\", extensions:\
    \ [\"Ta\", \"TAR\", \"t234An\", \"cosSo\"]) == \"K.TAR\")\nassert(Strongest_Extension(class_name:\
    \ \"__HAHA\", extensions: [\"Tab\", \"123\", \"781345\", \"-_-\"]) == \"__HAHA.123\"\
    )\nassert(Strongest_Extension(class_name: \"YameRore\", extensions: [\"HhAas\"\
    , \"okIWILL123\", \"WorkOut\", \"Fails\", \"-_-\"]) == \"YameRore.okIWILL123\"\
    )\nassert(Strongest_Extension(class_name: \"finNNalLLly\", extensions: [\"Die\"\
    , \"NowW\", \"Wow\", \"WoW\"]) == \"finNNalLLly.WoW\")\nassert(Strongest_Extension(class_name:\
    \ \"_\", extensions: [\"Bb\", \"91245\"]) == \"_.Bb\")\nassert(Strongest_Extension(class_name:\
    \ \"Sp\", extensions: [\"671235\", \"Bb\"]) == \"Sp.671235\")"
  status: SyntaxError
  stderr: "/tmp/tmp6nkrava0.swift:28:33: error: cannot find 'matches_for_reg_ex' in\
    \ scope\n        let uppercase_matches = matches_for_reg_ex(reg_ex: uppercase_reg_ex,\
    \ string: extension_name)\n                                ^~~~~~~~~~~~~~~~~~\n\
    /tmp/tmp6nkrava0.swift:29:33: error: cannot find 'matches_for_reg_ex' in scope\n\
    \        let lowercase_matches = matches_for_reg_ex(reg_ex: lowercase_reg_ex,\
    \ string: extension_name)\n                                ^~~~~~~~~~~~~~~~~~\n"
  stdout: ''
  timestamp: 1660009431
- exit_code: -4
  program: "\n/// You will be given the name of a class (a string) and an array of\
    \ extensions.\n/// The extensions are to be used to load additional classes to\
    \ the class. The\n/// strength of the extension is as follows: Let CAP be the\
    \ number of the uppercase\n/// letters in the extension's name, and let SM be\
    \ the number of lowercase letters \n/// in the extension's name, the strength\
    \ is given by the fraction CAP - SM. \n/// You should find the strongest extension\
    \ and return a string in this \n/// format: ClassName.StrongestExtensionName.\n\
    /// If there are two or more extensions with the same strength, you should\n///\
    \ choose the one that comes first in the array.\n/// For example, if you are given\
    \ \"Slices\" as the class and an array of the\n/// extensions: ['SErviNGSliCes',\
    \ 'Cheese', 'StuFfed'] then you should\n/// return 'Slices.SErviNGSliCes' since\
    \ 'SErviNGSliCes' is the strongest extension \n/// (its strength is -1).\n///\
    \ Example:\n/// >>> Strongest_Extension(class_name: \"my_class\", extensions:\
    \ [\"AA\", \"Be\", \"CC\"])\n/// \"my_class.AA\"\nfunc Strongest_Extension(class_name:\
    \ String, extensions: [String]) -> String {\n    let strength = extensions.map\
    \ { (str) -> Int in\n        var numOfUpper = 0\n        var numOfLower = 0\n\
    \        for char in str {\n            if char.isUppercase {\n              \
    \  numOfUpper += 1\n            } else {\n                numOfLower += 1\n  \
    \          }\n        }\n        return numOfUpper - numOfLower\n    }\n    let\
    \ strongestIndex = strength.firstIndex(of: strength.max()!)!\n    return \"\\\
    (class_name).\\(extensions[strongestIndex])\"\n}\n\n\nfunc ==(left: [(Int, Int)],\
    \ right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n       \
    \ return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r\
    \ {\n            return false\n        }\n    }\n    return true\n}\n        \
    \    \nassert(Strongest_Extension(class_name: \"Watashi\", extensions: [\"tEN\"\
    , \"niNE\", \"eIGHt8OKe\"]) == \"Watashi.eIGHt8OKe\")\nassert(Strongest_Extension(class_name:\
    \ \"Boku123\", extensions: [\"nani\", \"NazeDa\", \"YEs.WeCaNe\", \"32145tggg\"\
    ]) == \"Boku123.YEs.WeCaNe\")\nassert(Strongest_Extension(class_name: \"__YESIMHERE\"\
    , extensions: [\"t\", \"eMptY\", \"nothing\", \"zeR00\", \"NuLl__\", \"123NoooneB321\"\
    ]) == \"__YESIMHERE.NuLl__\")\nassert(Strongest_Extension(class_name: \"K\", extensions:\
    \ [\"Ta\", \"TAR\", \"t234An\", \"cosSo\"]) == \"K.TAR\")\nassert(Strongest_Extension(class_name:\
    \ \"__HAHA\", extensions: [\"Tab\", \"123\", \"781345\", \"-_-\"]) == \"__HAHA.123\"\
    )\nassert(Strongest_Extension(class_name: \"YameRore\", extensions: [\"HhAas\"\
    , \"okIWILL123\", \"WorkOut\", \"Fails\", \"-_-\"]) == \"YameRore.okIWILL123\"\
    )\nassert(Strongest_Extension(class_name: \"finNNalLLly\", extensions: [\"Die\"\
    , \"NowW\", \"Wow\", \"WoW\"]) == \"finNNalLLly.WoW\")\nassert(Strongest_Extension(class_name:\
    \ \"_\", extensions: [\"Bb\", \"91245\"]) == \"_.Bb\")\nassert(Strongest_Extension(class_name:\
    \ \"Sp\", extensions: [\"671235\", \"Bb\"]) == \"Sp.671235\")"
  status: Exception
  stderr: 'tmpk6rrzwzp/tmpk6rrzwzp.swift:48: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b0643ce1c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b06439d8b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b06439d8988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b06439d77b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpk6rrzwzp                        0x0000557828902b7d <unavailable> + 7037

    5    libc.so.6                          0x00002b0643ecd460 __libc_start_main +
    245

    6    tmpk6rrzwzp                        0x0000557828902709 <unavailable> + 5897

    '
  stdout: ''
  timestamp: 1660009432
- exit_code: -4
  program: "\n/// You will be given the name of a class (a string) and an array of\
    \ extensions.\n/// The extensions are to be used to load additional classes to\
    \ the class. The\n/// strength of the extension is as follows: Let CAP be the\
    \ number of the uppercase\n/// letters in the extension's name, and let SM be\
    \ the number of lowercase letters \n/// in the extension's name, the strength\
    \ is given by the fraction CAP - SM. \n/// You should find the strongest extension\
    \ and return a string in this \n/// format: ClassName.StrongestExtensionName.\n\
    /// If there are two or more extensions with the same strength, you should\n///\
    \ choose the one that comes first in the array.\n/// For example, if you are given\
    \ \"Slices\" as the class and an array of the\n/// extensions: ['SErviNGSliCes',\
    \ 'Cheese', 'StuFfed'] then you should\n/// return 'Slices.SErviNGSliCes' since\
    \ 'SErviNGSliCes' is the strongest extension \n/// (its strength is -1).\n///\
    \ Example:\n/// >>> Strongest_Extension(class_name: \"my_class\", extensions:\
    \ [\"AA\", \"Be\", \"CC\"])\n/// \"my_class.AA\"\nfunc Strongest_Extension(class_name:\
    \ String, extensions: [String]) -> String {\n    var strength = 0\n    var answer\
    \ = \"\"\n    for extension_ in extensions {\n        var cap = 0\n        var\
    \ sm = 0\n        for letter in extension_ {\n            if String(letter).uppercased()\
    \ == String(letter) {\n                cap += 1\n            } else {\n      \
    \          sm += 1\n            }\n        }\n        if strength < cap - sm {\n\
    \            strength = cap - sm\n            answer = extension_\n        }\n\
    \    }\n    return class_name + \".\" + answer\n}\n\n\nfunc ==(left: [(Int, Int)],\
    \ right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n       \
    \ return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r\
    \ {\n            return false\n        }\n    }\n    return true\n}\n        \
    \    \nassert(Strongest_Extension(class_name: \"Watashi\", extensions: [\"tEN\"\
    , \"niNE\", \"eIGHt8OKe\"]) == \"Watashi.eIGHt8OKe\")\nassert(Strongest_Extension(class_name:\
    \ \"Boku123\", extensions: [\"nani\", \"NazeDa\", \"YEs.WeCaNe\", \"32145tggg\"\
    ]) == \"Boku123.YEs.WeCaNe\")\nassert(Strongest_Extension(class_name: \"__YESIMHERE\"\
    , extensions: [\"t\", \"eMptY\", \"nothing\", \"zeR00\", \"NuLl__\", \"123NoooneB321\"\
    ]) == \"__YESIMHERE.NuLl__\")\nassert(Strongest_Extension(class_name: \"K\", extensions:\
    \ [\"Ta\", \"TAR\", \"t234An\", \"cosSo\"]) == \"K.TAR\")\nassert(Strongest_Extension(class_name:\
    \ \"__HAHA\", extensions: [\"Tab\", \"123\", \"781345\", \"-_-\"]) == \"__HAHA.123\"\
    )\nassert(Strongest_Extension(class_name: \"YameRore\", extensions: [\"HhAas\"\
    , \"okIWILL123\", \"WorkOut\", \"Fails\", \"-_-\"]) == \"YameRore.okIWILL123\"\
    )\nassert(Strongest_Extension(class_name: \"finNNalLLly\", extensions: [\"Die\"\
    , \"NowW\", \"Wow\", \"WoW\"]) == \"finNNalLLly.WoW\")\nassert(Strongest_Extension(class_name:\
    \ \"_\", extensions: [\"Bb\", \"91245\"]) == \"_.Bb\")\nassert(Strongest_Extension(class_name:\
    \ \"Sp\", extensions: [\"671235\", \"Bb\"]) == \"Sp.671235\")"
  status: Exception
  stderr: 'tmpirvnyfsk/tmpirvnyfsk.swift:54: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b0241d1ec80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b0241a15b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b0241a15988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b0241a147b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpirvnyfsk                        0x0000563344826c9c <unavailable> + 7324

    5    libc.so.6                          0x00002b0241f0a460 __libc_start_main +
    245

    6    tmpirvnyfsk                        0x00005633448263a9 <unavailable> + 5033

    '
  stdout: ''
  timestamp: 1660009432
- exit_code: 0
  program: "\n/// You will be given the name of a class (a string) and an array of\
    \ extensions.\n/// The extensions are to be used to load additional classes to\
    \ the class. The\n/// strength of the extension is as follows: Let CAP be the\
    \ number of the uppercase\n/// letters in the extension's name, and let SM be\
    \ the number of lowercase letters \n/// in the extension's name, the strength\
    \ is given by the fraction CAP - SM. \n/// You should find the strongest extension\
    \ and return a string in this \n/// format: ClassName.StrongestExtensionName.\n\
    /// If there are two or more extensions with the same strength, you should\n///\
    \ choose the one that comes first in the array.\n/// For example, if you are given\
    \ \"Slices\" as the class and an array of the\n/// extensions: ['SErviNGSliCes',\
    \ 'Cheese', 'StuFfed'] then you should\n/// return 'Slices.SErviNGSliCes' since\
    \ 'SErviNGSliCes' is the strongest extension \n/// (its strength is -1).\n///\
    \ Example:\n/// >>> Strongest_Extension(class_name: \"my_class\", extensions:\
    \ [\"AA\", \"Be\", \"CC\"])\n/// \"my_class.AA\"\nfunc Strongest_Extension(class_name:\
    \ String, extensions: [String]) -> String {\n    if extensions.count == 0 {\n\
    \        return \"\\(class_name)\"\n    }\n    var strongestExtension: String\
    \ = extensions[0]\n    var maxStrength: Double = -Double.infinity\n    for ext\
    \ in extensions {\n        let cap = ext.filter { $0.isUppercase }.count\n   \
    \     let sm = ext.filter { $0.isLowercase }.count\n        let strength = Double(cap)\
    \ - Double(sm)\n        if strength > maxStrength {\n            maxStrength =\
    \ strength\n            strongestExtension = ext\n        }\n    }\n    return\
    \ \"\\(class_name).\\(strongestExtension)\"\n}\n\n\nfunc ==(left: [(Int, Int)],\
    \ right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n       \
    \ return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r\
    \ {\n            return false\n        }\n    }\n    return true\n}\n        \
    \    \nassert(Strongest_Extension(class_name: \"Watashi\", extensions: [\"tEN\"\
    , \"niNE\", \"eIGHt8OKe\"]) == \"Watashi.eIGHt8OKe\")\nassert(Strongest_Extension(class_name:\
    \ \"Boku123\", extensions: [\"nani\", \"NazeDa\", \"YEs.WeCaNe\", \"32145tggg\"\
    ]) == \"Boku123.YEs.WeCaNe\")\nassert(Strongest_Extension(class_name: \"__YESIMHERE\"\
    , extensions: [\"t\", \"eMptY\", \"nothing\", \"zeR00\", \"NuLl__\", \"123NoooneB321\"\
    ]) == \"__YESIMHERE.NuLl__\")\nassert(Strongest_Extension(class_name: \"K\", extensions:\
    \ [\"Ta\", \"TAR\", \"t234An\", \"cosSo\"]) == \"K.TAR\")\nassert(Strongest_Extension(class_name:\
    \ \"__HAHA\", extensions: [\"Tab\", \"123\", \"781345\", \"-_-\"]) == \"__HAHA.123\"\
    )\nassert(Strongest_Extension(class_name: \"YameRore\", extensions: [\"HhAas\"\
    , \"okIWILL123\", \"WorkOut\", \"Fails\", \"-_-\"]) == \"YameRore.okIWILL123\"\
    )\nassert(Strongest_Extension(class_name: \"finNNalLLly\", extensions: [\"Die\"\
    , \"NowW\", \"Wow\", \"WoW\"]) == \"finNNalLLly.WoW\")\nassert(Strongest_Extension(class_name:\
    \ \"_\", extensions: [\"Bb\", \"91245\"]) == \"_.Bb\")\nassert(Strongest_Extension(class_name:\
    \ \"Sp\", extensions: [\"671235\", \"Bb\"]) == \"Sp.671235\")"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660009432
- exit_code: -4
  program: "\n/// You will be given the name of a class (a string) and an array of\
    \ extensions.\n/// The extensions are to be used to load additional classes to\
    \ the class. The\n/// strength of the extension is as follows: Let CAP be the\
    \ number of the uppercase\n/// letters in the extension's name, and let SM be\
    \ the number of lowercase letters \n/// in the extension's name, the strength\
    \ is given by the fraction CAP - SM. \n/// You should find the strongest extension\
    \ and return a string in this \n/// format: ClassName.StrongestExtensionName.\n\
    /// If there are two or more extensions with the same strength, you should\n///\
    \ choose the one that comes first in the array.\n/// For example, if you are given\
    \ \"Slices\" as the class and an array of the\n/// extensions: ['SErviNGSliCes',\
    \ 'Cheese', 'StuFfed'] then you should\n/// return 'Slices.SErviNGSliCes' since\
    \ 'SErviNGSliCes' is the strongest extension \n/// (its strength is -1).\n///\
    \ Example:\n/// >>> Strongest_Extension(class_name: \"my_class\", extensions:\
    \ [\"AA\", \"Be\", \"CC\"])\n/// \"my_class.AA\"\nfunc Strongest_Extension(class_name:\
    \ String, extensions: [String]) -> String {\n    var strongest = \".\"\n    var\
    \ strongest_strength = 0\n    for extension_name in extensions {\n        var\
    \ cap = 0\n        var sm = 0\n        for char in extension_name {\n        \
    \    if char.isUppercase {\n                cap += 1\n            } else {\n \
    \               sm += 1\n            }\n        }\n        let strength = cap\
    \ - sm\n        if strength > strongest_strength {\n            strongest = extension_name\n\
    \            strongest_strength = strength\n        }\n    }\n    return class_name\
    \ + \".\" + strongest\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(Strongest_Extension(class_name:\
    \ \"Watashi\", extensions: [\"tEN\", \"niNE\", \"eIGHt8OKe\"]) == \"Watashi.eIGHt8OKe\"\
    )\nassert(Strongest_Extension(class_name: \"Boku123\", extensions: [\"nani\",\
    \ \"NazeDa\", \"YEs.WeCaNe\", \"32145tggg\"]) == \"Boku123.YEs.WeCaNe\")\nassert(Strongest_Extension(class_name:\
    \ \"__YESIMHERE\", extensions: [\"t\", \"eMptY\", \"nothing\", \"zeR00\", \"NuLl__\"\
    , \"123NoooneB321\"]) == \"__YESIMHERE.NuLl__\")\nassert(Strongest_Extension(class_name:\
    \ \"K\", extensions: [\"Ta\", \"TAR\", \"t234An\", \"cosSo\"]) == \"K.TAR\")\n\
    assert(Strongest_Extension(class_name: \"__HAHA\", extensions: [\"Tab\", \"123\"\
    , \"781345\", \"-_-\"]) == \"__HAHA.123\")\nassert(Strongest_Extension(class_name:\
    \ \"YameRore\", extensions: [\"HhAas\", \"okIWILL123\", \"WorkOut\", \"Fails\"\
    , \"-_-\"]) == \"YameRore.okIWILL123\")\nassert(Strongest_Extension(class_name:\
    \ \"finNNalLLly\", extensions: [\"Die\", \"NowW\", \"Wow\", \"WoW\"]) == \"finNNalLLly.WoW\"\
    )\nassert(Strongest_Extension(class_name: \"_\", extensions: [\"Bb\", \"91245\"\
    ]) == \"_.Bb\")\nassert(Strongest_Extension(class_name: \"Sp\", extensions: [\"\
    671235\", \"Bb\"]) == \"Sp.671235\")"
  status: Exception
  stderr: 'tmpsz0rzmnv/tmpsz0rzmnv.swift:53: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b312a0d4c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b3129dcbb6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b3129dcb988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b3129dca7b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpsz0rzmnv                        0x000055a32ec737cd <unavailable> + 6093

    5    libc.so.6                          0x00002b312a2c0460 __libc_start_main +
    245

    6    tmpsz0rzmnv                        0x000055a32ec73359 <unavailable> + 4953

    '
  stdout: ''
  timestamp: 1660009432
- exit_code: -4
  program: "\n/// You will be given the name of a class (a string) and an array of\
    \ extensions.\n/// The extensions are to be used to load additional classes to\
    \ the class. The\n/// strength of the extension is as follows: Let CAP be the\
    \ number of the uppercase\n/// letters in the extension's name, and let SM be\
    \ the number of lowercase letters \n/// in the extension's name, the strength\
    \ is given by the fraction CAP - SM. \n/// You should find the strongest extension\
    \ and return a string in this \n/// format: ClassName.StrongestExtensionName.\n\
    /// If there are two or more extensions with the same strength, you should\n///\
    \ choose the one that comes first in the array.\n/// For example, if you are given\
    \ \"Slices\" as the class and an array of the\n/// extensions: ['SErviNGSliCes',\
    \ 'Cheese', 'StuFfed'] then you should\n/// return 'Slices.SErviNGSliCes' since\
    \ 'SErviNGSliCes' is the strongest extension \n/// (its strength is -1).\n///\
    \ Example:\n/// >>> Strongest_Extension(class_name: \"my_class\", extensions:\
    \ [\"AA\", \"Be\", \"CC\"])\n/// \"my_class.AA\"\nfunc Strongest_Extension(class_name:\
    \ String, extensions: [String]) -> String {\n    var strongest_extension = \"\"\
    \n    var strongest_extension_strength = 0.0\n    for ext in extensions {\n  \
    \      var number_of_uppercase_letters = 0\n        var number_of_lowercase_letters\
    \ = 0\n        for c in ext {\n            if c.isUppercase {\n              \
    \  number_of_uppercase_letters += 1\n            } else if c.isLowercase {\n \
    \               number_of_lowercase_letters += 1\n            }\n        }\n \
    \       let strength = Double(number_of_uppercase_letters) - Double(number_of_lowercase_letters)\n\
    \        if strength > strongest_extension_strength {\n            strongest_extension_strength\
    \ = strength\n            strongest_extension = ext\n        }\n    }\n    return\
    \ \"\\(class_name).\\(strongest_extension)\"\n}\n\n\nfunc ==(left: [(Int, Int)],\
    \ right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n       \
    \ return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r\
    \ {\n            return false\n        }\n    }\n    return true\n}\n        \
    \    \nassert(Strongest_Extension(class_name: \"Watashi\", extensions: [\"tEN\"\
    , \"niNE\", \"eIGHt8OKe\"]) == \"Watashi.eIGHt8OKe\")\nassert(Strongest_Extension(class_name:\
    \ \"Boku123\", extensions: [\"nani\", \"NazeDa\", \"YEs.WeCaNe\", \"32145tggg\"\
    ]) == \"Boku123.YEs.WeCaNe\")\nassert(Strongest_Extension(class_name: \"__YESIMHERE\"\
    , extensions: [\"t\", \"eMptY\", \"nothing\", \"zeR00\", \"NuLl__\", \"123NoooneB321\"\
    ]) == \"__YESIMHERE.NuLl__\")\nassert(Strongest_Extension(class_name: \"K\", extensions:\
    \ [\"Ta\", \"TAR\", \"t234An\", \"cosSo\"]) == \"K.TAR\")\nassert(Strongest_Extension(class_name:\
    \ \"__HAHA\", extensions: [\"Tab\", \"123\", \"781345\", \"-_-\"]) == \"__HAHA.123\"\
    )\nassert(Strongest_Extension(class_name: \"YameRore\", extensions: [\"HhAas\"\
    , \"okIWILL123\", \"WorkOut\", \"Fails\", \"-_-\"]) == \"YameRore.okIWILL123\"\
    )\nassert(Strongest_Extension(class_name: \"finNNalLLly\", extensions: [\"Die\"\
    , \"NowW\", \"Wow\", \"WoW\"]) == \"finNNalLLly.WoW\")\nassert(Strongest_Extension(class_name:\
    \ \"_\", extensions: [\"Bb\", \"91245\"]) == \"_.Bb\")\nassert(Strongest_Extension(class_name:\
    \ \"Sp\", extensions: [\"671235\", \"Bb\"]) == \"Sp.671235\")"
  status: Exception
  stderr: 'tmpd6143njb/tmpd6143njb.swift:55: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b3e4392ac80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b3e43621b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b3e43621988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b3e436207b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpd6143njb                        0x0000558c340a8f1c <unavailable> + 7964

    5    libc.so.6                          0x00002b3e43b16460 __libc_start_main +
    245

    6    tmpd6143njb                        0x0000558c340a8629 <unavailable> + 5673

    '
  stdout: ''
  timestamp: 1660009432
- exit_code: -4
  program: "\n/// You will be given the name of a class (a string) and an array of\
    \ extensions.\n/// The extensions are to be used to load additional classes to\
    \ the class. The\n/// strength of the extension is as follows: Let CAP be the\
    \ number of the uppercase\n/// letters in the extension's name, and let SM be\
    \ the number of lowercase letters \n/// in the extension's name, the strength\
    \ is given by the fraction CAP - SM. \n/// You should find the strongest extension\
    \ and return a string in this \n/// format: ClassName.StrongestExtensionName.\n\
    /// If there are two or more extensions with the same strength, you should\n///\
    \ choose the one that comes first in the array.\n/// For example, if you are given\
    \ \"Slices\" as the class and an array of the\n/// extensions: ['SErviNGSliCes',\
    \ 'Cheese', 'StuFfed'] then you should\n/// return 'Slices.SErviNGSliCes' since\
    \ 'SErviNGSliCes' is the strongest extension \n/// (its strength is -1).\n///\
    \ Example:\n/// >>> Strongest_Extension(class_name: \"my_class\", extensions:\
    \ [\"AA\", \"Be\", \"CC\"])\n/// \"my_class.AA\"\nfunc Strongest_Extension(class_name:\
    \ String, extensions: [String]) -> String {\n    var strongest = extensions[0]\n\
    \    var strongest_strength = 0\n    var current_strength = 0\n    for name in\
    \ extensions {\n        for char in name {\n            if char.isUppercase {\n\
    \                current_strength += 1\n            } else {\n               \
    \ current_strength -= 1\n            }\n        }\n        if current_strength\
    \ > strongest_strength {\n            strongest = name\n            strongest_strength\
    \ = current_strength\n        }\n        current_strength = 0\n    }\n    return\
    \ \"\\(class_name).\\(strongest)\"\n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(Strongest_Extension(class_name: \"Watashi\", extensions: [\"tEN\", \"niNE\"\
    , \"eIGHt8OKe\"]) == \"Watashi.eIGHt8OKe\")\nassert(Strongest_Extension(class_name:\
    \ \"Boku123\", extensions: [\"nani\", \"NazeDa\", \"YEs.WeCaNe\", \"32145tggg\"\
    ]) == \"Boku123.YEs.WeCaNe\")\nassert(Strongest_Extension(class_name: \"__YESIMHERE\"\
    , extensions: [\"t\", \"eMptY\", \"nothing\", \"zeR00\", \"NuLl__\", \"123NoooneB321\"\
    ]) == \"__YESIMHERE.NuLl__\")\nassert(Strongest_Extension(class_name: \"K\", extensions:\
    \ [\"Ta\", \"TAR\", \"t234An\", \"cosSo\"]) == \"K.TAR\")\nassert(Strongest_Extension(class_name:\
    \ \"__HAHA\", extensions: [\"Tab\", \"123\", \"781345\", \"-_-\"]) == \"__HAHA.123\"\
    )\nassert(Strongest_Extension(class_name: \"YameRore\", extensions: [\"HhAas\"\
    , \"okIWILL123\", \"WorkOut\", \"Fails\", \"-_-\"]) == \"YameRore.okIWILL123\"\
    )\nassert(Strongest_Extension(class_name: \"finNNalLLly\", extensions: [\"Die\"\
    , \"NowW\", \"Wow\", \"WoW\"]) == \"finNNalLLly.WoW\")\nassert(Strongest_Extension(class_name:\
    \ \"_\", extensions: [\"Bb\", \"91245\"]) == \"_.Bb\")\nassert(Strongest_Extension(class_name:\
    \ \"Sp\", extensions: [\"671235\", \"Bb\"]) == \"Sp.671235\")"
  status: Exception
  stderr: 'tmpxg0htgtd/tmpxg0htgtd.swift:52: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b9e818a0c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b9e81597b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b9e81597988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b9e815967b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpxg0htgtd                        0x000055fa19795a8d <unavailable> + 6797

    5    libc.so.6                          0x00002b9e81a8c460 __libc_start_main +
    245

    6    tmpxg0htgtd                        0x000055fa19795619 <unavailable> + 5657

    '
  stdout: ''
  timestamp: 1660009432
- exit_code: -4
  program: "\n/// You will be given the name of a class (a string) and an array of\
    \ extensions.\n/// The extensions are to be used to load additional classes to\
    \ the class. The\n/// strength of the extension is as follows: Let CAP be the\
    \ number of the uppercase\n/// letters in the extension's name, and let SM be\
    \ the number of lowercase letters \n/// in the extension's name, the strength\
    \ is given by the fraction CAP - SM. \n/// You should find the strongest extension\
    \ and return a string in this \n/// format: ClassName.StrongestExtensionName.\n\
    /// If there are two or more extensions with the same strength, you should\n///\
    \ choose the one that comes first in the array.\n/// For example, if you are given\
    \ \"Slices\" as the class and an array of the\n/// extensions: ['SErviNGSliCes',\
    \ 'Cheese', 'StuFfed'] then you should\n/// return 'Slices.SErviNGSliCes' since\
    \ 'SErviNGSliCes' is the strongest extension \n/// (its strength is -1).\n///\
    \ Example:\n/// >>> Strongest_Extension(class_name: \"my_class\", extensions:\
    \ [\"AA\", \"Be\", \"CC\"])\n/// \"my_class.AA\"\nfunc Strongest_Extension(class_name:\
    \ String, extensions: [String]) -> String {\n    var res = class_name\n    var\
    \ max = -100\n    for e in extensions {\n        var cap = 0\n        var sm =\
    \ 0\n        for i in e {\n            if i.isUppercase {\n                cap\
    \ += 1\n            } else {\n                sm += 1\n            }\n       \
    \ }\n        if max < (cap - sm) {\n            max = cap - sm\n            res\
    \ += \".\" + e\n        }\n    }\n    return res\n}\n\n\nfunc ==(left: [(Int,\
    \ Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n\
    \        return false\n    }\n    for (l, r) in zip(left, right) {\n        if\
    \ l != r {\n            return false\n        }\n    }\n    return true\n}\n \
    \           \nassert(Strongest_Extension(class_name: \"Watashi\", extensions:\
    \ [\"tEN\", \"niNE\", \"eIGHt8OKe\"]) == \"Watashi.eIGHt8OKe\")\nassert(Strongest_Extension(class_name:\
    \ \"Boku123\", extensions: [\"nani\", \"NazeDa\", \"YEs.WeCaNe\", \"32145tggg\"\
    ]) == \"Boku123.YEs.WeCaNe\")\nassert(Strongest_Extension(class_name: \"__YESIMHERE\"\
    , extensions: [\"t\", \"eMptY\", \"nothing\", \"zeR00\", \"NuLl__\", \"123NoooneB321\"\
    ]) == \"__YESIMHERE.NuLl__\")\nassert(Strongest_Extension(class_name: \"K\", extensions:\
    \ [\"Ta\", \"TAR\", \"t234An\", \"cosSo\"]) == \"K.TAR\")\nassert(Strongest_Extension(class_name:\
    \ \"__HAHA\", extensions: [\"Tab\", \"123\", \"781345\", \"-_-\"]) == \"__HAHA.123\"\
    )\nassert(Strongest_Extension(class_name: \"YameRore\", extensions: [\"HhAas\"\
    , \"okIWILL123\", \"WorkOut\", \"Fails\", \"-_-\"]) == \"YameRore.okIWILL123\"\
    )\nassert(Strongest_Extension(class_name: \"finNNalLLly\", extensions: [\"Die\"\
    , \"NowW\", \"Wow\", \"WoW\"]) == \"finNNalLLly.WoW\")\nassert(Strongest_Extension(class_name:\
    \ \"_\", extensions: [\"Bb\", \"91245\"]) == \"_.Bb\")\nassert(Strongest_Extension(class_name:\
    \ \"Sp\", extensions: [\"671235\", \"Bb\"]) == \"Sp.671235\")"
  status: Exception
  stderr: 'tmp55io48ud/tmp55io48ud.swift:52: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b545665bc80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b5456352b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b5456352988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b54563517b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmp55io48ud                        0x000055c54ccec81d <unavailable> + 6173

    5    libc.so.6                          0x00002b5456847460 __libc_start_main +
    245

    6    tmp55io48ud                        0x000055c54ccec3a9 <unavailable> + 5033

    '
  stdout: ''
  timestamp: 1660009432
- exit_code: -4
  program: "\n/// You will be given the name of a class (a string) and an array of\
    \ extensions.\n/// The extensions are to be used to load additional classes to\
    \ the class. The\n/// strength of the extension is as follows: Let CAP be the\
    \ number of the uppercase\n/// letters in the extension's name, and let SM be\
    \ the number of lowercase letters \n/// in the extension's name, the strength\
    \ is given by the fraction CAP - SM. \n/// You should find the strongest extension\
    \ and return a string in this \n/// format: ClassName.StrongestExtensionName.\n\
    /// If there are two or more extensions with the same strength, you should\n///\
    \ choose the one that comes first in the array.\n/// For example, if you are given\
    \ \"Slices\" as the class and an array of the\n/// extensions: ['SErviNGSliCes',\
    \ 'Cheese', 'StuFfed'] then you should\n/// return 'Slices.SErviNGSliCes' since\
    \ 'SErviNGSliCes' is the strongest extension \n/// (its strength is -1).\n///\
    \ Example:\n/// >>> Strongest_Extension(class_name: \"my_class\", extensions:\
    \ [\"AA\", \"Be\", \"CC\"])\n/// \"my_class.AA\"\nfunc Strongest_Extension(class_name:\
    \ String, extensions: [String]) -> String {\n    var strongest_ext = \"\"\n  \
    \  var strongest_ext_str = 0\n    for ext in extensions {\n        var cap = 0\n\
    \        var sm = 0\n        for ch in ext {\n            if String(ch).uppercased()\
    \ == String(ch) {\n                cap += 1\n            } else {\n          \
    \      sm += 1\n            }\n        }\n        if abs(cap - sm) > strongest_ext_str\
    \ {\n            strongest_ext_str = abs(cap - sm)\n            strongest_ext\
    \ = ext\n        }\n    }\n    return class_name + \".\" + strongest_ext\n}\n\n\
    \nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(Strongest_Extension(class_name: \"Watashi\", extensions:\
    \ [\"tEN\", \"niNE\", \"eIGHt8OKe\"]) == \"Watashi.eIGHt8OKe\")\nassert(Strongest_Extension(class_name:\
    \ \"Boku123\", extensions: [\"nani\", \"NazeDa\", \"YEs.WeCaNe\", \"32145tggg\"\
    ]) == \"Boku123.YEs.WeCaNe\")\nassert(Strongest_Extension(class_name: \"__YESIMHERE\"\
    , extensions: [\"t\", \"eMptY\", \"nothing\", \"zeR00\", \"NuLl__\", \"123NoooneB321\"\
    ]) == \"__YESIMHERE.NuLl__\")\nassert(Strongest_Extension(class_name: \"K\", extensions:\
    \ [\"Ta\", \"TAR\", \"t234An\", \"cosSo\"]) == \"K.TAR\")\nassert(Strongest_Extension(class_name:\
    \ \"__HAHA\", extensions: [\"Tab\", \"123\", \"781345\", \"-_-\"]) == \"__HAHA.123\"\
    )\nassert(Strongest_Extension(class_name: \"YameRore\", extensions: [\"HhAas\"\
    , \"okIWILL123\", \"WorkOut\", \"Fails\", \"-_-\"]) == \"YameRore.okIWILL123\"\
    )\nassert(Strongest_Extension(class_name: \"finNNalLLly\", extensions: [\"Die\"\
    , \"NowW\", \"Wow\", \"WoW\"]) == \"finNNalLLly.WoW\")\nassert(Strongest_Extension(class_name:\
    \ \"_\", extensions: [\"Bb\", \"91245\"]) == \"_.Bb\")\nassert(Strongest_Extension(class_name:\
    \ \"Sp\", extensions: [\"671235\", \"Bb\"]) == \"Sp.671235\")"
  status: Exception
  stderr: 'tmp7up0if45/tmp7up0if45.swift:53: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b01a2d32c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b01a2a29b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b01a2a29988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b01a2a287b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmp7up0if45                        0x00005606ee34fb17 <unavailable> + 6935

    5    libc.so.6                          0x00002b01a2f1e460 __libc_start_main +
    245

    6    tmp7up0if45                        0x00005606ee34f499 <unavailable> + 5273

    '
  stdout: ''
  timestamp: 1660009432
- exit_code: 1
  program: "\n/// You will be given the name of a class (a string) and an array of\
    \ extensions.\n/// The extensions are to be used to load additional classes to\
    \ the class. The\n/// strength of the extension is as follows: Let CAP be the\
    \ number of the uppercase\n/// letters in the extension's name, and let SM be\
    \ the number of lowercase letters \n/// in the extension's name, the strength\
    \ is given by the fraction CAP - SM. \n/// You should find the strongest extension\
    \ and return a string in this \n/// format: ClassName.StrongestExtensionName.\n\
    /// If there are two or more extensions with the same strength, you should\n///\
    \ choose the one that comes first in the array.\n/// For example, if you are given\
    \ \"Slices\" as the class and an array of the\n/// extensions: ['SErviNGSliCes',\
    \ 'Cheese', 'StuFfed'] then you should\n/// return 'Slices.SErviNGSliCes' since\
    \ 'SErviNGSliCes' is the strongest extension \n/// (its strength is -1).\n///\
    \ Example:\n/// >>> Strongest_Extension(class_name: \"my_class\", extensions:\
    \ [\"AA\", \"Be\", \"CC\"])\n/// \"my_class.AA\"\nfunc Strongest_Extension(class_name:\
    \ String, extensions: [String]) -> String {\n\tlet class_name = class_name\n\t\
    var strongest = 0\n\tvar str = \"\"\n\tfor i in extensions {\n\t\tvar str_length\
    \ = i.count\n\t\tvar upp_count = 0\n\t\tvar low_count = 0\n\t\tfor j in i {\n\t\
    \t\tif j.isUppercase {\n\t\t\t\tupp_count += 1\n\t\t\t} else {\n\t\t\t\tlow_count\
    \ += 1\n\t\t\t}\n\t\t}\n\t\tlet strength = Float(upp_count - low_count) / Float(str_length)\n\
    \t\tif strength >= strongest {\n\t\t\tstrongest = strength\n\t\t\tstr = i\n\t\t\
    }\n\t}\n\treturn \"\\(class_name).\\(str)\"\n}\n\n\nfunc ==(left: [(Int, Int)],\
    \ right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n       \
    \ return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r\
    \ {\n            return false\n        }\n    }\n    return true\n}\n        \
    \    \nassert(Strongest_Extension(class_name: \"Watashi\", extensions: [\"tEN\"\
    , \"niNE\", \"eIGHt8OKe\"]) == \"Watashi.eIGHt8OKe\")\nassert(Strongest_Extension(class_name:\
    \ \"Boku123\", extensions: [\"nani\", \"NazeDa\", \"YEs.WeCaNe\", \"32145tggg\"\
    ]) == \"Boku123.YEs.WeCaNe\")\nassert(Strongest_Extension(class_name: \"__YESIMHERE\"\
    , extensions: [\"t\", \"eMptY\", \"nothing\", \"zeR00\", \"NuLl__\", \"123NoooneB321\"\
    ]) == \"__YESIMHERE.NuLl__\")\nassert(Strongest_Extension(class_name: \"K\", extensions:\
    \ [\"Ta\", \"TAR\", \"t234An\", \"cosSo\"]) == \"K.TAR\")\nassert(Strongest_Extension(class_name:\
    \ \"__HAHA\", extensions: [\"Tab\", \"123\", \"781345\", \"-_-\"]) == \"__HAHA.123\"\
    )\nassert(Strongest_Extension(class_name: \"YameRore\", extensions: [\"HhAas\"\
    , \"okIWILL123\", \"WorkOut\", \"Fails\", \"-_-\"]) == \"YameRore.okIWILL123\"\
    )\nassert(Strongest_Extension(class_name: \"finNNalLLly\", extensions: [\"Die\"\
    , \"NowW\", \"Wow\", \"WoW\"]) == \"finNNalLLly.WoW\")\nassert(Strongest_Extension(class_name:\
    \ \"_\", extensions: [\"Bb\", \"91245\"]) == \"_.Bb\")\nassert(Strongest_Extension(class_name:\
    \ \"Sp\", extensions: [\"671235\", \"Bb\"]) == \"Sp.671235\")"
  status: SyntaxError
  stderr: "/tmp/tmpvp4_cv93.swift:34:15: error: binary operator '>=' cannot be applied\
    \ to operands of type 'Float' and 'Int'\n                if strength >= strongest\
    \ {\n                   ~~~~~~~~ ^  ~~~~~~~~~\n/tmp/tmpvp4_cv93.swift:34:15: note:\
    \ overloads for '>=' exist with these partially matching parameter lists: (Int,\
    \ Int)\n                if strength >= strongest {\n                         \
    \   ^\n/tmp/tmpvp4_cv93.swift:35:16: error: cannot assign value of type 'Float'\
    \ to type 'Int'\n                        strongest = strength\n              \
    \                      ^~~~~~~~\n                                    Int(    )\n"
  stdout: ''
  timestamp: 1660009432
- exit_code: 1
  program: "\n/// You will be given the name of a class (a string) and an array of\
    \ extensions.\n/// The extensions are to be used to load additional classes to\
    \ the class. The\n/// strength of the extension is as follows: Let CAP be the\
    \ number of the uppercase\n/// letters in the extension's name, and let SM be\
    \ the number of lowercase letters \n/// in the extension's name, the strength\
    \ is given by the fraction CAP - SM. \n/// You should find the strongest extension\
    \ and return a string in this \n/// format: ClassName.StrongestExtensionName.\n\
    /// If there are two or more extensions with the same strength, you should\n///\
    \ choose the one that comes first in the array.\n/// For example, if you are given\
    \ \"Slices\" as the class and an array of the\n/// extensions: ['SErviNGSliCes',\
    \ 'Cheese', 'StuFfed'] then you should\n/// return 'Slices.SErviNGSliCes' since\
    \ 'SErviNGSliCes' is the strongest extension \n/// (its strength is -1).\n///\
    \ Example:\n/// >>> Strongest_Extension(class_name: \"my_class\", extensions:\
    \ [\"AA\", \"Be\", \"CC\"])\n/// \"my_class.AA\"\nfunc Strongest_Extension(class_name:\
    \ String, extensions: [String]) -> String {\n    var strongestExtension = extensions[0]\n\
    \    var strongestExtensionCapCount = 0\n    var strongestExtensionSmallCount\
    \ = 0\n    for i in 0..<extensions.count {\n        var capsCount = 0\n      \
    \  var smallCount = 0\n        for j in 0..<extensions[i].count {\n          \
    \  let strArr = Array(extensions[i])\n            if isUpperCase(str: strArr[j])\
    \ {\n                capsCount += 1\n            } else {\n                smallCount\
    \ += 1\n            }\n        }\n        if (capsCount - smallCount) > (strongestExtensionCapCount\
    \ - strongestExtensionSmallCount) {\n            strongestExtension = extensions[i]\n\
    \            strongestExtensionCapCount = capsCount\n            strongestExtensionSmallCount\
    \ = smallCount\n        }\n    }\n    return class_name + \".\" + strongestExtension\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(Strongest_Extension(class_name: \"Watashi\", extensions:\
    \ [\"tEN\", \"niNE\", \"eIGHt8OKe\"]) == \"Watashi.eIGHt8OKe\")\nassert(Strongest_Extension(class_name:\
    \ \"Boku123\", extensions: [\"nani\", \"NazeDa\", \"YEs.WeCaNe\", \"32145tggg\"\
    ]) == \"Boku123.YEs.WeCaNe\")\nassert(Strongest_Extension(class_name: \"__YESIMHERE\"\
    , extensions: [\"t\", \"eMptY\", \"nothing\", \"zeR00\", \"NuLl__\", \"123NoooneB321\"\
    ]) == \"__YESIMHERE.NuLl__\")\nassert(Strongest_Extension(class_name: \"K\", extensions:\
    \ [\"Ta\", \"TAR\", \"t234An\", \"cosSo\"]) == \"K.TAR\")\nassert(Strongest_Extension(class_name:\
    \ \"__HAHA\", extensions: [\"Tab\", \"123\", \"781345\", \"-_-\"]) == \"__HAHA.123\"\
    )\nassert(Strongest_Extension(class_name: \"YameRore\", extensions: [\"HhAas\"\
    , \"okIWILL123\", \"WorkOut\", \"Fails\", \"-_-\"]) == \"YameRore.okIWILL123\"\
    )\nassert(Strongest_Extension(class_name: \"finNNalLLly\", extensions: [\"Die\"\
    , \"NowW\", \"Wow\", \"WoW\"]) == \"finNNalLLly.WoW\")\nassert(Strongest_Extension(class_name:\
    \ \"_\", extensions: [\"Bb\", \"91245\"]) == \"_.Bb\")\nassert(Strongest_Extension(class_name:\
    \ \"Sp\", extensions: [\"671235\", \"Bb\"]) == \"Sp.671235\")"
  status: SyntaxError
  stderr: "/tmp/tmpw_ixojns.swift:27:16: error: cannot find 'isUpperCase' in scope\n\
    \            if isUpperCase(str: strArr[j]) {\n               ^~~~~~~~~~~\n"
  stdout: ''
  timestamp: 1660009432
- exit_code: 1
  program: "\n/// You will be given the name of a class (a string) and an array of\
    \ extensions.\n/// The extensions are to be used to load additional classes to\
    \ the class. The\n/// strength of the extension is as follows: Let CAP be the\
    \ number of the uppercase\n/// letters in the extension's name, and let SM be\
    \ the number of lowercase letters \n/// in the extension's name, the strength\
    \ is given by the fraction CAP - SM. \n/// You should find the strongest extension\
    \ and return a string in this \n/// format: ClassName.StrongestExtensionName.\n\
    /// If there are two or more extensions with the same strength, you should\n///\
    \ choose the one that comes first in the array.\n/// For example, if you are given\
    \ \"Slices\" as the class and an array of the\n/// extensions: ['SErviNGSliCes',\
    \ 'Cheese', 'StuFfed'] then you should\n/// return 'Slices.SErviNGSliCes' since\
    \ 'SErviNGSliCes' is the strongest extension \n/// (its strength is -1).\n///\
    \ Example:\n/// >>> Strongest_Extension(class_name: \"my_class\", extensions:\
    \ [\"AA\", \"Be\", \"CC\"])\n/// \"my_class.AA\"\nfunc Strongest_Extension(class_name:\
    \ String, extensions: [String]) -> String {\n  var strength_and_name = [\"\",\
    \ class_name, 0.0]\n  for ext in extensions {\n    var strength = 0.0\n    for\
    \ char in ext {\n      if char.isUppercase {\n        strength += 1\n      } else\
    \ {\n        strength -= 1\n      }\n    }\n    if strength > strength_and_name[2]\
    \ {\n      strength_and_name = [ext, class_name, strength]\n    }\n  }\n  return\
    \ strength_and_name[1] + \".\" + strength_and_name[0]\n}\n\n\nfunc ==(left: [(Int,\
    \ Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n\
    \        return false\n    }\n    for (l, r) in zip(left, right) {\n        if\
    \ l != r {\n            return false\n        }\n    }\n    return true\n}\n \
    \           \nassert(Strongest_Extension(class_name: \"Watashi\", extensions:\
    \ [\"tEN\", \"niNE\", \"eIGHt8OKe\"]) == \"Watashi.eIGHt8OKe\")\nassert(Strongest_Extension(class_name:\
    \ \"Boku123\", extensions: [\"nani\", \"NazeDa\", \"YEs.WeCaNe\", \"32145tggg\"\
    ]) == \"Boku123.YEs.WeCaNe\")\nassert(Strongest_Extension(class_name: \"__YESIMHERE\"\
    , extensions: [\"t\", \"eMptY\", \"nothing\", \"zeR00\", \"NuLl__\", \"123NoooneB321\"\
    ]) == \"__YESIMHERE.NuLl__\")\nassert(Strongest_Extension(class_name: \"K\", extensions:\
    \ [\"Ta\", \"TAR\", \"t234An\", \"cosSo\"]) == \"K.TAR\")\nassert(Strongest_Extension(class_name:\
    \ \"__HAHA\", extensions: [\"Tab\", \"123\", \"781345\", \"-_-\"]) == \"__HAHA.123\"\
    )\nassert(Strongest_Extension(class_name: \"YameRore\", extensions: [\"HhAas\"\
    , \"okIWILL123\", \"WorkOut\", \"Fails\", \"-_-\"]) == \"YameRore.okIWILL123\"\
    )\nassert(Strongest_Extension(class_name: \"finNNalLLly\", extensions: [\"Die\"\
    , \"NowW\", \"Wow\", \"WoW\"]) == \"finNNalLLly.WoW\")\nassert(Strongest_Extension(class_name:\
    \ \"_\", extensions: [\"Bb\", \"91245\"]) == \"_.Bb\")\nassert(Strongest_Extension(class_name:\
    \ \"Sp\", extensions: [\"671235\", \"Bb\"]) == \"Sp.671235\")"
  status: SyntaxError
  stderr: "/tmp/tmp5kk6vbtd.swift:19:27: error: heterogeneous collection literal could\
    \ only be inferred to '[Any]'; add explicit type annotation if this is intentional\n\
    \  var strength_and_name = [\"\", class_name, 0.0]\n                         \
    \ ^~~~~~~~~~~~~~~~~~~~~\n                                                as [Any]\n\
    /tmp/tmp5kk6vbtd.swift:29:36: error: cannot convert value of type 'Any' to expected\
    \ argument type 'Double'\n    if strength > strength_and_name[2] {\n         \
    \                          ^\n                                       as! Double\n\
    /tmp/tmp5kk6vbtd.swift:33:27: error: cannot convert value of type 'Any' to expected\
    \ argument type 'String'\n  return strength_and_name[1] + \".\" + strength_and_name[0]\n\
    \                          ^\n                              as! String\n/tmp/tmp5kk6vbtd.swift:33:56:\
    \ error: cannot convert value of type 'Any' to expected argument type 'String'\n\
    \  return strength_and_name[1] + \".\" + strength_and_name[0]\n              \
    \                                         ^\n                                \
    \                           as! String\n"
  stdout: ''
  timestamp: 1660009432
- exit_code: 1
  program: "\n/// You will be given the name of a class (a string) and an array of\
    \ extensions.\n/// The extensions are to be used to load additional classes to\
    \ the class. The\n/// strength of the extension is as follows: Let CAP be the\
    \ number of the uppercase\n/// letters in the extension's name, and let SM be\
    \ the number of lowercase letters \n/// in the extension's name, the strength\
    \ is given by the fraction CAP - SM. \n/// You should find the strongest extension\
    \ and return a string in this \n/// format: ClassName.StrongestExtensionName.\n\
    /// If there are two or more extensions with the same strength, you should\n///\
    \ choose the one that comes first in the array.\n/// For example, if you are given\
    \ \"Slices\" as the class and an array of the\n/// extensions: ['SErviNGSliCes',\
    \ 'Cheese', 'StuFfed'] then you should\n/// return 'Slices.SErviNGSliCes' since\
    \ 'SErviNGSliCes' is the strongest extension \n/// (its strength is -1).\n///\
    \ Example:\n/// >>> Strongest_Extension(class_name: \"my_class\", extensions:\
    \ [\"AA\", \"Be\", \"CC\"])\n/// \"my_class.AA\"\nfunc Strongest_Extension(class_name:\
    \ String, extensions: [String]) -> String {\n    var strongest: String = \"\"\n\
    \    var strongest_strength: Float = 0.0\n    for extension_ in extensions {\n\
    \        let strength = strength_of_extension(extension_: extension_)\n      \
    \  if strength > strongest_strength {\n            strongest = extension_\n  \
    \          strongest_strength = strength\n        }\n    }\n    return class_name\
    \ + \".\" + strongest\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(Strongest_Extension(class_name:\
    \ \"Watashi\", extensions: [\"tEN\", \"niNE\", \"eIGHt8OKe\"]) == \"Watashi.eIGHt8OKe\"\
    )\nassert(Strongest_Extension(class_name: \"Boku123\", extensions: [\"nani\",\
    \ \"NazeDa\", \"YEs.WeCaNe\", \"32145tggg\"]) == \"Boku123.YEs.WeCaNe\")\nassert(Strongest_Extension(class_name:\
    \ \"__YESIMHERE\", extensions: [\"t\", \"eMptY\", \"nothing\", \"zeR00\", \"NuLl__\"\
    , \"123NoooneB321\"]) == \"__YESIMHERE.NuLl__\")\nassert(Strongest_Extension(class_name:\
    \ \"K\", extensions: [\"Ta\", \"TAR\", \"t234An\", \"cosSo\"]) == \"K.TAR\")\n\
    assert(Strongest_Extension(class_name: \"__HAHA\", extensions: [\"Tab\", \"123\"\
    , \"781345\", \"-_-\"]) == \"__HAHA.123\")\nassert(Strongest_Extension(class_name:\
    \ \"YameRore\", extensions: [\"HhAas\", \"okIWILL123\", \"WorkOut\", \"Fails\"\
    , \"-_-\"]) == \"YameRore.okIWILL123\")\nassert(Strongest_Extension(class_name:\
    \ \"finNNalLLly\", extensions: [\"Die\", \"NowW\", \"Wow\", \"WoW\"]) == \"finNNalLLly.WoW\"\
    )\nassert(Strongest_Extension(class_name: \"_\", extensions: [\"Bb\", \"91245\"\
    ]) == \"_.Bb\")\nassert(Strongest_Extension(class_name: \"Sp\", extensions: [\"\
    671235\", \"Bb\"]) == \"Sp.671235\")"
  status: SyntaxError
  stderr: "/tmp/tmp7cem7n4d.swift:22:24: error: cannot find 'strength_of_extension'\
    \ in scope\n        let strength = strength_of_extension(extension_: extension_)\n\
    \                       ^~~~~~~~~~~~~~~~~~~~~\n"
  stdout: ''
  timestamp: 1660009432
- exit_code: 1
  program: "\n/// You will be given the name of a class (a string) and an array of\
    \ extensions.\n/// The extensions are to be used to load additional classes to\
    \ the class. The\n/// strength of the extension is as follows: Let CAP be the\
    \ number of the uppercase\n/// letters in the extension's name, and let SM be\
    \ the number of lowercase letters \n/// in the extension's name, the strength\
    \ is given by the fraction CAP - SM. \n/// You should find the strongest extension\
    \ and return a string in this \n/// format: ClassName.StrongestExtensionName.\n\
    /// If there are two or more extensions with the same strength, you should\n///\
    \ choose the one that comes first in the array.\n/// For example, if you are given\
    \ \"Slices\" as the class and an array of the\n/// extensions: ['SErviNGSliCes',\
    \ 'Cheese', 'StuFfed'] then you should\n/// return 'Slices.SErviNGSliCes' since\
    \ 'SErviNGSliCes' is the strongest extension \n/// (its strength is -1).\n///\
    \ Example:\n/// >>> Strongest_Extension(class_name: \"my_class\", extensions:\
    \ [\"AA\", \"Be\", \"CC\"])\n/// \"my_class.AA\"\nfunc Strongest_Extension(class_name:\
    \ String, extensions: [String]) -> String {\n    let strongest_extension_index\
    \ = strongest_extension_index_helper(extensions: extensions)\n    return class_name\
    \ + \".\" + extensions[strongest_extension_index]\n}\n\n\nfunc ==(left: [(Int,\
    \ Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n\
    \        return false\n    }\n    for (l, r) in zip(left, right) {\n        if\
    \ l != r {\n            return false\n        }\n    }\n    return true\n}\n \
    \           \nassert(Strongest_Extension(class_name: \"Watashi\", extensions:\
    \ [\"tEN\", \"niNE\", \"eIGHt8OKe\"]) == \"Watashi.eIGHt8OKe\")\nassert(Strongest_Extension(class_name:\
    \ \"Boku123\", extensions: [\"nani\", \"NazeDa\", \"YEs.WeCaNe\", \"32145tggg\"\
    ]) == \"Boku123.YEs.WeCaNe\")\nassert(Strongest_Extension(class_name: \"__YESIMHERE\"\
    , extensions: [\"t\", \"eMptY\", \"nothing\", \"zeR00\", \"NuLl__\", \"123NoooneB321\"\
    ]) == \"__YESIMHERE.NuLl__\")\nassert(Strongest_Extension(class_name: \"K\", extensions:\
    \ [\"Ta\", \"TAR\", \"t234An\", \"cosSo\"]) == \"K.TAR\")\nassert(Strongest_Extension(class_name:\
    \ \"__HAHA\", extensions: [\"Tab\", \"123\", \"781345\", \"-_-\"]) == \"__HAHA.123\"\
    )\nassert(Strongest_Extension(class_name: \"YameRore\", extensions: [\"HhAas\"\
    , \"okIWILL123\", \"WorkOut\", \"Fails\", \"-_-\"]) == \"YameRore.okIWILL123\"\
    )\nassert(Strongest_Extension(class_name: \"finNNalLLly\", extensions: [\"Die\"\
    , \"NowW\", \"Wow\", \"WoW\"]) == \"finNNalLLly.WoW\")\nassert(Strongest_Extension(class_name:\
    \ \"_\", extensions: [\"Bb\", \"91245\"]) == \"_.Bb\")\nassert(Strongest_Extension(class_name:\
    \ \"Sp\", extensions: [\"671235\", \"Bb\"]) == \"Sp.671235\")"
  status: SyntaxError
  stderr: "/tmp/tmpapfxjvej.swift:19:37: error: cannot find 'strongest_extension_index_helper'\
    \ in scope\n    let strongest_extension_index = strongest_extension_index_helper(extensions:\
    \ extensions)\n                                    ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n"
  stdout: ''
  timestamp: 1660009432
- exit_code: -4
  program: "\n/// You will be given the name of a class (a string) and an array of\
    \ extensions.\n/// The extensions are to be used to load additional classes to\
    \ the class. The\n/// strength of the extension is as follows: Let CAP be the\
    \ number of the uppercase\n/// letters in the extension's name, and let SM be\
    \ the number of lowercase letters \n/// in the extension's name, the strength\
    \ is given by the fraction CAP - SM. \n/// You should find the strongest extension\
    \ and return a string in this \n/// format: ClassName.StrongestExtensionName.\n\
    /// If there are two or more extensions with the same strength, you should\n///\
    \ choose the one that comes first in the array.\n/// For example, if you are given\
    \ \"Slices\" as the class and an array of the\n/// extensions: ['SErviNGSliCes',\
    \ 'Cheese', 'StuFfed'] then you should\n/// return 'Slices.SErviNGSliCes' since\
    \ 'SErviNGSliCes' is the strongest extension \n/// (its strength is -1).\n///\
    \ Example:\n/// >>> Strongest_Extension(class_name: \"my_class\", extensions:\
    \ [\"AA\", \"Be\", \"CC\"])\n/// \"my_class.AA\"\nfunc Strongest_Extension(class_name:\
    \ String, extensions: [String]) -> String {\n    return \"\"\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(Strongest_Extension(class_name: \"Watashi\", extensions:\
    \ [\"tEN\", \"niNE\", \"eIGHt8OKe\"]) == \"Watashi.eIGHt8OKe\")\nassert(Strongest_Extension(class_name:\
    \ \"Boku123\", extensions: [\"nani\", \"NazeDa\", \"YEs.WeCaNe\", \"32145tggg\"\
    ]) == \"Boku123.YEs.WeCaNe\")\nassert(Strongest_Extension(class_name: \"__YESIMHERE\"\
    , extensions: [\"t\", \"eMptY\", \"nothing\", \"zeR00\", \"NuLl__\", \"123NoooneB321\"\
    ]) == \"__YESIMHERE.NuLl__\")\nassert(Strongest_Extension(class_name: \"K\", extensions:\
    \ [\"Ta\", \"TAR\", \"t234An\", \"cosSo\"]) == \"K.TAR\")\nassert(Strongest_Extension(class_name:\
    \ \"__HAHA\", extensions: [\"Tab\", \"123\", \"781345\", \"-_-\"]) == \"__HAHA.123\"\
    )\nassert(Strongest_Extension(class_name: \"YameRore\", extensions: [\"HhAas\"\
    , \"okIWILL123\", \"WorkOut\", \"Fails\", \"-_-\"]) == \"YameRore.okIWILL123\"\
    )\nassert(Strongest_Extension(class_name: \"finNNalLLly\", extensions: [\"Die\"\
    , \"NowW\", \"Wow\", \"WoW\"]) == \"finNNalLLly.WoW\")\nassert(Strongest_Extension(class_name:\
    \ \"_\", extensions: [\"Bb\", \"91245\"]) == \"_.Bb\")\nassert(Strongest_Extension(class_name:\
    \ \"Sp\", extensions: [\"671235\", \"Bb\"]) == \"Sp.671235\")"
  status: Exception
  stderr: 'tmpuhmbxdp4/tmpuhmbxdp4.swift:35: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002abeef348c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002abeef03fb6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002abeef03f988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002abeef03e7b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpuhmbxdp4                        0x0000559ee0d614fd <unavailable> + 5373

    5    libc.so.6                          0x00002abeef534460 __libc_start_main +
    245

    6    tmpuhmbxdp4                        0x0000559ee0d61089 <unavailable> + 4233

    '
  stdout: ''
  timestamp: 1660009431
- exit_code: 1
  program: "\n/// You will be given the name of a class (a string) and an array of\
    \ extensions.\n/// The extensions are to be used to load additional classes to\
    \ the class. The\n/// strength of the extension is as follows: Let CAP be the\
    \ number of the uppercase\n/// letters in the extension's name, and let SM be\
    \ the number of lowercase letters \n/// in the extension's name, the strength\
    \ is given by the fraction CAP - SM. \n/// You should find the strongest extension\
    \ and return a string in this \n/// format: ClassName.StrongestExtensionName.\n\
    /// If there are two or more extensions with the same strength, you should\n///\
    \ choose the one that comes first in the array.\n/// For example, if you are given\
    \ \"Slices\" as the class and an array of the\n/// extensions: ['SErviNGSliCes',\
    \ 'Cheese', 'StuFfed'] then you should\n/// return 'Slices.SErviNGSliCes' since\
    \ 'SErviNGSliCes' is the strongest extension \n/// (its strength is -1).\n///\
    \ Example:\n/// >>> Strongest_Extension(class_name: \"my_class\", extensions:\
    \ [\"AA\", \"Be\", \"CC\"])\n/// \"my_class.AA\"\nfunc Strongest_Extension(class_name:\
    \ String, extensions: [String]) -> String {\n    let sorted = extensions.sorted(by:\
    \ {extension_name in \n        let a = extension_name.uppercased().filter{$0.isUppercase}.count\n\
    \        let b = extension_name.lowercased().filter{$0.isLowercase}.count\n  \
    \      return a - b\n    })\n    return class_name + \".\" + sorted.last!\n}\n\
    \n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(Strongest_Extension(class_name: \"Watashi\", extensions:\
    \ [\"tEN\", \"niNE\", \"eIGHt8OKe\"]) == \"Watashi.eIGHt8OKe\")\nassert(Strongest_Extension(class_name:\
    \ \"Boku123\", extensions: [\"nani\", \"NazeDa\", \"YEs.WeCaNe\", \"32145tggg\"\
    ]) == \"Boku123.YEs.WeCaNe\")\nassert(Strongest_Extension(class_name: \"__YESIMHERE\"\
    , extensions: [\"t\", \"eMptY\", \"nothing\", \"zeR00\", \"NuLl__\", \"123NoooneB321\"\
    ]) == \"__YESIMHERE.NuLl__\")\nassert(Strongest_Extension(class_name: \"K\", extensions:\
    \ [\"Ta\", \"TAR\", \"t234An\", \"cosSo\"]) == \"K.TAR\")\nassert(Strongest_Extension(class_name:\
    \ \"__HAHA\", extensions: [\"Tab\", \"123\", \"781345\", \"-_-\"]) == \"__HAHA.123\"\
    )\nassert(Strongest_Extension(class_name: \"YameRore\", extensions: [\"HhAas\"\
    , \"okIWILL123\", \"WorkOut\", \"Fails\", \"-_-\"]) == \"YameRore.okIWILL123\"\
    )\nassert(Strongest_Extension(class_name: \"finNNalLLly\", extensions: [\"Die\"\
    , \"NowW\", \"Wow\", \"WoW\"]) == \"finNNalLLly.WoW\")\nassert(Strongest_Extension(class_name:\
    \ \"_\", extensions: [\"Bb\", \"91245\"]) == \"_.Bb\")\nassert(Strongest_Extension(class_name:\
    \ \"Sp\", extensions: [\"671235\", \"Bb\"]) == \"Sp.671235\")"
  status: SyntaxError
  stderr: "/tmp/tmprvnc88ps.swift:19:41: error: contextual closure type '(String,\
    \ String) throws -> Bool' expects 2 arguments, but 1 was used in closure body\n\
    \    let sorted = extensions.sorted(by: {extension_name in \n                \
    \                        ^\n                                                 \
    \     ,<#arg#> \n/tmp/tmprvnc88ps.swift:22:18: error: type 'Int' cannot be used\
    \ as a boolean; test for '!= 0' instead\n        return a - b\n              \
    \   ^\n               ((   ) != 0)\n"
  stdout: ''
  timestamp: 1660009432
- exit_code: -4
  program: "\n/// You will be given the name of a class (a string) and an array of\
    \ extensions.\n/// The extensions are to be used to load additional classes to\
    \ the class. The\n/// strength of the extension is as follows: Let CAP be the\
    \ number of the uppercase\n/// letters in the extension's name, and let SM be\
    \ the number of lowercase letters \n/// in the extension's name, the strength\
    \ is given by the fraction CAP - SM. \n/// You should find the strongest extension\
    \ and return a string in this \n/// format: ClassName.StrongestExtensionName.\n\
    /// If there are two or more extensions with the same strength, you should\n///\
    \ choose the one that comes first in the array.\n/// For example, if you are given\
    \ \"Slices\" as the class and an array of the\n/// extensions: ['SErviNGSliCes',\
    \ 'Cheese', 'StuFfed'] then you should\n/// return 'Slices.SErviNGSliCes' since\
    \ 'SErviNGSliCes' is the strongest extension \n/// (its strength is -1).\n///\
    \ Example:\n/// >>> Strongest_Extension(class_name: \"my_class\", extensions:\
    \ [\"AA\", \"Be\", \"CC\"])\n/// \"my_class.AA\"\nfunc Strongest_Extension(class_name:\
    \ String, extensions: [String]) -> String {\n    if extensions.count < 1 { return\
    \ \"There are no extensions to \\(class_name)\" }\n    if extensions.count ==\
    \ 1 { return \"\\(class_name).\\(extensions[0])\" }\n    var differences = [Int]()\n\
    \    var extension_dict = [String: Int]()\n    var strongest_extension = \"\"\n\
    \    var strongest_score = 0\n    var extension_score = 0\n    for ext in extensions\
    \ {\n        for char in ext {\n            if char.isUppercase { extension_score\
    \ += 1 }\n            if char.isLowercase { extension_score -= 1 }\n        }\n\
    \        differences.append(extension_score)\n        extension_dict[ext] = extension_score\n\
    \        extension_score = 0\n    }\n    for (key, value) in extension_dict {\n\
    \        if value > strongest_score {\n            strongest_score = value\n \
    \           strongest_extension = key\n        }\n    }\n    return \"\\(class_name).\\\
    (strongest_extension)\"\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(Strongest_Extension(class_name:\
    \ \"Watashi\", extensions: [\"tEN\", \"niNE\", \"eIGHt8OKe\"]) == \"Watashi.eIGHt8OKe\"\
    )\nassert(Strongest_Extension(class_name: \"Boku123\", extensions: [\"nani\",\
    \ \"NazeDa\", \"YEs.WeCaNe\", \"32145tggg\"]) == \"Boku123.YEs.WeCaNe\")\nassert(Strongest_Extension(class_name:\
    \ \"__YESIMHERE\", extensions: [\"t\", \"eMptY\", \"nothing\", \"zeR00\", \"NuLl__\"\
    , \"123NoooneB321\"]) == \"__YESIMHERE.NuLl__\")\nassert(Strongest_Extension(class_name:\
    \ \"K\", extensions: [\"Ta\", \"TAR\", \"t234An\", \"cosSo\"]) == \"K.TAR\")\n\
    assert(Strongest_Extension(class_name: \"__HAHA\", extensions: [\"Tab\", \"123\"\
    , \"781345\", \"-_-\"]) == \"__HAHA.123\")\nassert(Strongest_Extension(class_name:\
    \ \"YameRore\", extensions: [\"HhAas\", \"okIWILL123\", \"WorkOut\", \"Fails\"\
    , \"-_-\"]) == \"YameRore.okIWILL123\")\nassert(Strongest_Extension(class_name:\
    \ \"finNNalLLly\", extensions: [\"Die\", \"NowW\", \"Wow\", \"WoW\"]) == \"finNNalLLly.WoW\"\
    )\nassert(Strongest_Extension(class_name: \"_\", extensions: [\"Bb\", \"91245\"\
    ]) == \"_.Bb\")\nassert(Strongest_Extension(class_name: \"Sp\", extensions: [\"\
    671235\", \"Bb\"]) == \"Sp.671235\")"
  status: Exception
  stderr: 'tmpp_o1j2wu/tmpp_o1j2wu.swift:59: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b2d6cc80c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b2d6c977b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b2d6c977988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b2d6c9767b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpp_o1j2wu                        0x00005612791ae2bc <unavailable> + 8892

    5    libc.so.6                          0x00002b2d6ce6c460 __libc_start_main +
    245

    6    tmpp_o1j2wu                        0x00005612791ad9c9 <unavailable> + 6601

    '
  stdout: ''
  timestamp: 1660009432
- exit_code: 1
  program: "\n/// You will be given the name of a class (a string) and an array of\
    \ extensions.\n/// The extensions are to be used to load additional classes to\
    \ the class. The\n/// strength of the extension is as follows: Let CAP be the\
    \ number of the uppercase\n/// letters in the extension's name, and let SM be\
    \ the number of lowercase letters \n/// in the extension's name, the strength\
    \ is given by the fraction CAP - SM. \n/// You should find the strongest extension\
    \ and return a string in this \n/// format: ClassName.StrongestExtensionName.\n\
    /// If there are two or more extensions with the same strength, you should\n///\
    \ choose the one that comes first in the array.\n/// For example, if you are given\
    \ \"Slices\" as the class and an array of the\n/// extensions: ['SErviNGSliCes',\
    \ 'Cheese', 'StuFfed'] then you should\n/// return 'Slices.SErviNGSliCes' since\
    \ 'SErviNGSliCes' is the strongest extension \n/// (its strength is -1).\n///\
    \ Example:\n/// >>> Strongest_Extension(class_name: \"my_class\", extensions:\
    \ [\"AA\", \"Be\", \"CC\"])\n/// \"my_class.AA\"\nfunc Strongest_Extension(class_name:\
    \ String, extensions: [String]) -> String {\n\tvar output = class_name + \".\"\
    \n\tvar strongest_strength = 0.0\n\tvar strongest_index = 0\n\tfor (index, extension)\
    \ in extensions.enumerated() {\n\t\tvar strength = 0.0\n\t\tfor i in extension\
    \ {\n\t\t\tif i.isUppercase {\n\t\t\t\tstrength += 1\n\t\t\t} else {\n\t\t\t\t\
    strength -= 1\n\t\t\t}\n\t\t}\n\t\tif strength > strongest_strength {\n\t\t\t\
    strongest_strength = strength\n\t\t\tstrongest_index = index\n\t\t}\n\t}\n\toutput\
    \ += extensions[strongest_index]\n\treturn output\n}\n\n\nfunc ==(left: [(Int,\
    \ Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n\
    \        return false\n    }\n    for (l, r) in zip(left, right) {\n        if\
    \ l != r {\n            return false\n        }\n    }\n    return true\n}\n \
    \           \nassert(Strongest_Extension(class_name: \"Watashi\", extensions:\
    \ [\"tEN\", \"niNE\", \"eIGHt8OKe\"]) == \"Watashi.eIGHt8OKe\")\nassert(Strongest_Extension(class_name:\
    \ \"Boku123\", extensions: [\"nani\", \"NazeDa\", \"YEs.WeCaNe\", \"32145tggg\"\
    ]) == \"Boku123.YEs.WeCaNe\")\nassert(Strongest_Extension(class_name: \"__YESIMHERE\"\
    , extensions: [\"t\", \"eMptY\", \"nothing\", \"zeR00\", \"NuLl__\", \"123NoooneB321\"\
    ]) == \"__YESIMHERE.NuLl__\")\nassert(Strongest_Extension(class_name: \"K\", extensions:\
    \ [\"Ta\", \"TAR\", \"t234An\", \"cosSo\"]) == \"K.TAR\")\nassert(Strongest_Extension(class_name:\
    \ \"__HAHA\", extensions: [\"Tab\", \"123\", \"781345\", \"-_-\"]) == \"__HAHA.123\"\
    )\nassert(Strongest_Extension(class_name: \"YameRore\", extensions: [\"HhAas\"\
    , \"okIWILL123\", \"WorkOut\", \"Fails\", \"-_-\"]) == \"YameRore.okIWILL123\"\
    )\nassert(Strongest_Extension(class_name: \"finNNalLLly\", extensions: [\"Die\"\
    , \"NowW\", \"Wow\", \"WoW\"]) == \"finNNalLLly.WoW\")\nassert(Strongest_Extension(class_name:\
    \ \"_\", extensions: [\"Bb\", \"91245\"]) == \"_.Bb\")\nassert(Strongest_Extension(class_name:\
    \ \"Sp\", extensions: [\"671235\", \"Bb\"]) == \"Sp.671235\")"
  status: SyntaxError
  stderr: "/tmp/tmp_8bel1vk.swift:22:14: error: expected pattern\n        for (index,\
    \ extension) in extensions.enumerated() {\n                    ^\n/tmp/tmp_8bel1vk.swift:22:14:\
    \ error: expected 'in' after for-each pattern\n        for (index, extension)\
    \ in extensions.enumerated() {\n                    ^\n/tmp/tmp_8bel1vk.swift:22:14:\
    \ error: expected Sequence expression for for-each loop\n        for (index, extension)\
    \ in extensions.enumerated() {\n                    ^\n/tmp/tmp_8bel1vk.swift:22:14:\
    \ error: expected '{' to start the body of for-each loop\n        for (index,\
    \ extension) in extensions.enumerated() {\n                    ^\n/tmp/tmp_8bel1vk.swift:24:12:\
    \ error: expected Sequence expression for for-each loop\n                for i\
    \ in extension {\n                         ^\n/tmp/tmp_8bel1vk.swift:24:12: error:\
    \ expected '{' to start the body of for-each loop\n                for i in extension\
    \ {\n                         ^\n"
  stdout: ''
  timestamp: 1660009432
- exit_code: 1
  program: "\n/// You will be given the name of a class (a string) and an array of\
    \ extensions.\n/// The extensions are to be used to load additional classes to\
    \ the class. The\n/// strength of the extension is as follows: Let CAP be the\
    \ number of the uppercase\n/// letters in the extension's name, and let SM be\
    \ the number of lowercase letters \n/// in the extension's name, the strength\
    \ is given by the fraction CAP - SM. \n/// You should find the strongest extension\
    \ and return a string in this \n/// format: ClassName.StrongestExtensionName.\n\
    /// If there are two or more extensions with the same strength, you should\n///\
    \ choose the one that comes first in the array.\n/// For example, if you are given\
    \ \"Slices\" as the class and an array of the\n/// extensions: ['SErviNGSliCes',\
    \ 'Cheese', 'StuFfed'] then you should\n/// return 'Slices.SErviNGSliCes' since\
    \ 'SErviNGSliCes' is the strongest extension \n/// (its strength is -1).\n///\
    \ Example:\n/// >>> Strongest_Extension(class_name: \"my_class\", extensions:\
    \ [\"AA\", \"Be\", \"CC\"])\n/// \"my_class.AA\"\nfunc Strongest_Extension(class_name:\
    \ String, extensions: [String]) -> String {\n    var strongest = \"\"\n    var\
    \ strongest_strength = 0\n    for extension in extensions {\n        var strength\
    \ = 0\n        for letter in extension {\n            if letter.isUppercase {\n\
    \                strength += 1\n            } else {\n                strength\
    \ -= 1\n            }\n        }\n        if strength > strongest_strength {\n\
    \            strongest = extension\n            strongest_strength = strength\n\
    \        }\n    }\n    return \"\\(class_name).\\(strongest)\"\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(Strongest_Extension(class_name: \"Watashi\", extensions:\
    \ [\"tEN\", \"niNE\", \"eIGHt8OKe\"]) == \"Watashi.eIGHt8OKe\")\nassert(Strongest_Extension(class_name:\
    \ \"Boku123\", extensions: [\"nani\", \"NazeDa\", \"YEs.WeCaNe\", \"32145tggg\"\
    ]) == \"Boku123.YEs.WeCaNe\")\nassert(Strongest_Extension(class_name: \"__YESIMHERE\"\
    , extensions: [\"t\", \"eMptY\", \"nothing\", \"zeR00\", \"NuLl__\", \"123NoooneB321\"\
    ]) == \"__YESIMHERE.NuLl__\")\nassert(Strongest_Extension(class_name: \"K\", extensions:\
    \ [\"Ta\", \"TAR\", \"t234An\", \"cosSo\"]) == \"K.TAR\")\nassert(Strongest_Extension(class_name:\
    \ \"__HAHA\", extensions: [\"Tab\", \"123\", \"781345\", \"-_-\"]) == \"__HAHA.123\"\
    )\nassert(Strongest_Extension(class_name: \"YameRore\", extensions: [\"HhAas\"\
    , \"okIWILL123\", \"WorkOut\", \"Fails\", \"-_-\"]) == \"YameRore.okIWILL123\"\
    )\nassert(Strongest_Extension(class_name: \"finNNalLLly\", extensions: [\"Die\"\
    , \"NowW\", \"Wow\", \"WoW\"]) == \"finNNalLLly.WoW\")\nassert(Strongest_Extension(class_name:\
    \ \"_\", extensions: [\"Bb\", \"91245\"]) == \"_.Bb\")\nassert(Strongest_Extension(class_name:\
    \ \"Sp\", extensions: [\"671235\", \"Bb\"]) == \"Sp.671235\")"
  status: SyntaxError
  stderr: "/tmp/tmpm157b9zw.swift:21:9: error: expected pattern\n    for extension\
    \ in extensions {\n        ^\n/tmp/tmpm157b9zw.swift:21:9: error: expected Sequence\
    \ expression for for-each loop\n    for extension in extensions {\n        ^\n\
    /tmp/tmpm157b9zw.swift:21:9: error: expected '{' to start the body of for-each\
    \ loop\n    for extension in extensions {\n        ^\n/tmp/tmpm157b9zw.swift:23:23:\
    \ error: expected Sequence expression for for-each loop\n        for letter in\
    \ extension {\n                      ^\n/tmp/tmpm157b9zw.swift:23:23: error: expected\
    \ '{' to start the body of for-each loop\n        for letter in extension {\n\
    \                      ^\n/tmp/tmpm157b9zw.swift:31:25: error: expected expression\
    \ in assignment\n            strongest = extension\n                        ^\n\
    /tmp/tmpm157b9zw.swift:32:32: error: expected '{' in extension\n            strongest_strength\
    \ = strength\n                               ^\n/tmp/tmpm157b9zw.swift:31:25:\
    \ error: declaration is only valid at file scope\n            strongest = extension\n\
    \                        ^\n/tmp/tmpm157b9zw.swift:32:13: error: cannot find type\
    \ 'strongest_strength' in scope\n            strongest_strength = strength\n \
    \           ^~~~~~~~~~~~~~~~~~\n"
  stdout: ''
  timestamp: 1660009432
- exit_code: -4
  program: "\n/// You will be given the name of a class (a string) and an array of\
    \ extensions.\n/// The extensions are to be used to load additional classes to\
    \ the class. The\n/// strength of the extension is as follows: Let CAP be the\
    \ number of the uppercase\n/// letters in the extension's name, and let SM be\
    \ the number of lowercase letters \n/// in the extension's name, the strength\
    \ is given by the fraction CAP - SM. \n/// You should find the strongest extension\
    \ and return a string in this \n/// format: ClassName.StrongestExtensionName.\n\
    /// If there are two or more extensions with the same strength, you should\n///\
    \ choose the one that comes first in the array.\n/// For example, if you are given\
    \ \"Slices\" as the class and an array of the\n/// extensions: ['SErviNGSliCes',\
    \ 'Cheese', 'StuFfed'] then you should\n/// return 'Slices.SErviNGSliCes' since\
    \ 'SErviNGSliCes' is the strongest extension \n/// (its strength is -1).\n///\
    \ Example:\n/// >>> Strongest_Extension(class_name: \"my_class\", extensions:\
    \ [\"AA\", \"Be\", \"CC\"])\n/// \"my_class.AA\"\nfunc Strongest_Extension(class_name:\
    \ String, extensions: [String]) -> String {\n    return \"\"\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(Strongest_Extension(class_name: \"Watashi\", extensions:\
    \ [\"tEN\", \"niNE\", \"eIGHt8OKe\"]) == \"Watashi.eIGHt8OKe\")\nassert(Strongest_Extension(class_name:\
    \ \"Boku123\", extensions: [\"nani\", \"NazeDa\", \"YEs.WeCaNe\", \"32145tggg\"\
    ]) == \"Boku123.YEs.WeCaNe\")\nassert(Strongest_Extension(class_name: \"__YESIMHERE\"\
    , extensions: [\"t\", \"eMptY\", \"nothing\", \"zeR00\", \"NuLl__\", \"123NoooneB321\"\
    ]) == \"__YESIMHERE.NuLl__\")\nassert(Strongest_Extension(class_name: \"K\", extensions:\
    \ [\"Ta\", \"TAR\", \"t234An\", \"cosSo\"]) == \"K.TAR\")\nassert(Strongest_Extension(class_name:\
    \ \"__HAHA\", extensions: [\"Tab\", \"123\", \"781345\", \"-_-\"]) == \"__HAHA.123\"\
    )\nassert(Strongest_Extension(class_name: \"YameRore\", extensions: [\"HhAas\"\
    , \"okIWILL123\", \"WorkOut\", \"Fails\", \"-_-\"]) == \"YameRore.okIWILL123\"\
    )\nassert(Strongest_Extension(class_name: \"finNNalLLly\", extensions: [\"Die\"\
    , \"NowW\", \"Wow\", \"WoW\"]) == \"finNNalLLly.WoW\")\nassert(Strongest_Extension(class_name:\
    \ \"_\", extensions: [\"Bb\", \"91245\"]) == \"_.Bb\")\nassert(Strongest_Extension(class_name:\
    \ \"Sp\", extensions: [\"671235\", \"Bb\"]) == \"Sp.671235\")"
  status: Exception
  stderr: 'tmpuhmbxdp4/tmpuhmbxdp4.swift:35: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002abeef348c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002abeef03fb6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002abeef03f988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002abeef03e7b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpuhmbxdp4                        0x0000559ee0d614fd <unavailable> + 5373

    5    libc.so.6                          0x00002abeef534460 __libc_start_main +
    245

    6    tmpuhmbxdp4                        0x0000559ee0d61089 <unavailable> + 4233

    '
  stdout: ''
  timestamp: 1660009431
- exit_code: 1
  program: "\n/// You will be given the name of a class (a string) and an array of\
    \ extensions.\n/// The extensions are to be used to load additional classes to\
    \ the class. The\n/// strength of the extension is as follows: Let CAP be the\
    \ number of the uppercase\n/// letters in the extension's name, and let SM be\
    \ the number of lowercase letters \n/// in the extension's name, the strength\
    \ is given by the fraction CAP - SM. \n/// You should find the strongest extension\
    \ and return a string in this \n/// format: ClassName.StrongestExtensionName.\n\
    /// If there are two or more extensions with the same strength, you should\n///\
    \ choose the one that comes first in the array.\n/// For example, if you are given\
    \ \"Slices\" as the class and an array of the\n/// extensions: ['SErviNGSliCes',\
    \ 'Cheese', 'StuFfed'] then you should\n/// return 'Slices.SErviNGSliCes' since\
    \ 'SErviNGSliCes' is the strongest extension \n/// (its strength is -1).\n///\
    \ Example:\n/// >>> Strongest_Extension(class_name: \"my_class\", extensions:\
    \ [\"AA\", \"Be\", \"CC\"])\n/// \"my_class.AA\"\nfunc Strongest_Extension(class_name:\
    \ String, extensions: [String]) -> String {\n    let extensions = extensions.map\
    \ { ($0, strength($0)) }\n    let (strongest, _) = extensions.max(by: { $0.1 <\
    \ $1.1 }) ?? (\"\", 0)\n    return \"\\(class_name).\\(strongest ?? \"\")\"\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(Strongest_Extension(class_name: \"Watashi\", extensions:\
    \ [\"tEN\", \"niNE\", \"eIGHt8OKe\"]) == \"Watashi.eIGHt8OKe\")\nassert(Strongest_Extension(class_name:\
    \ \"Boku123\", extensions: [\"nani\", \"NazeDa\", \"YEs.WeCaNe\", \"32145tggg\"\
    ]) == \"Boku123.YEs.WeCaNe\")\nassert(Strongest_Extension(class_name: \"__YESIMHERE\"\
    , extensions: [\"t\", \"eMptY\", \"nothing\", \"zeR00\", \"NuLl__\", \"123NoooneB321\"\
    ]) == \"__YESIMHERE.NuLl__\")\nassert(Strongest_Extension(class_name: \"K\", extensions:\
    \ [\"Ta\", \"TAR\", \"t234An\", \"cosSo\"]) == \"K.TAR\")\nassert(Strongest_Extension(class_name:\
    \ \"__HAHA\", extensions: [\"Tab\", \"123\", \"781345\", \"-_-\"]) == \"__HAHA.123\"\
    )\nassert(Strongest_Extension(class_name: \"YameRore\", extensions: [\"HhAas\"\
    , \"okIWILL123\", \"WorkOut\", \"Fails\", \"-_-\"]) == \"YameRore.okIWILL123\"\
    )\nassert(Strongest_Extension(class_name: \"finNNalLLly\", extensions: [\"Die\"\
    , \"NowW\", \"Wow\", \"WoW\"]) == \"finNNalLLly.WoW\")\nassert(Strongest_Extension(class_name:\
    \ \"_\", extensions: [\"Bb\", \"91245\"]) == \"_.Bb\")\nassert(Strongest_Extension(class_name:\
    \ \"Sp\", extensions: [\"671235\", \"Bb\"]) == \"Sp.671235\")"
  status: SyntaxError
  stderr: "/tmp/tmpdtpara3g.swift:19:44: error: cannot find 'strength' in scope\n\
    \    let extensions = extensions.map { ($0, strength($0)) }\n                \
    \                           ^~~~~~~~\n"
  stdout: ''
  timestamp: 1660009432
- exit_code: -4
  program: "\n/// You will be given the name of a class (a string) and an array of\
    \ extensions.\n/// The extensions are to be used to load additional classes to\
    \ the class. The\n/// strength of the extension is as follows: Let CAP be the\
    \ number of the uppercase\n/// letters in the extension's name, and let SM be\
    \ the number of lowercase letters \n/// in the extension's name, the strength\
    \ is given by the fraction CAP - SM. \n/// You should find the strongest extension\
    \ and return a string in this \n/// format: ClassName.StrongestExtensionName.\n\
    /// If there are two or more extensions with the same strength, you should\n///\
    \ choose the one that comes first in the array.\n/// For example, if you are given\
    \ \"Slices\" as the class and an array of the\n/// extensions: ['SErviNGSliCes',\
    \ 'Cheese', 'StuFfed'] then you should\n/// return 'Slices.SErviNGSliCes' since\
    \ 'SErviNGSliCes' is the strongest extension \n/// (its strength is -1).\n///\
    \ Example:\n/// >>> Strongest_Extension(class_name: \"my_class\", extensions:\
    \ [\"AA\", \"Be\", \"CC\"])\n/// \"my_class.AA\"\nfunc Strongest_Extension(class_name:\
    \ String, extensions: [String]) -> String {\n    var strongest = \"\"\n    var\
    \ strength = 0\n    for extension_name in extensions {\n        var current_strength\
    \ = 0\n        for char in extension_name {\n            if char.isUppercase {\n\
    \                current_strength += 1\n            } else {\n               \
    \ current_strength -= 1\n            }\n        }\n        if current_strength\
    \ > strength {\n            strength = current_strength\n            strongest\
    \ = extension_name\n        }\n    }\n    return \"\\(class_name).\\(strongest)\"\
    \n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(Strongest_Extension(class_name: \"Watashi\", extensions:\
    \ [\"tEN\", \"niNE\", \"eIGHt8OKe\"]) == \"Watashi.eIGHt8OKe\")\nassert(Strongest_Extension(class_name:\
    \ \"Boku123\", extensions: [\"nani\", \"NazeDa\", \"YEs.WeCaNe\", \"32145tggg\"\
    ]) == \"Boku123.YEs.WeCaNe\")\nassert(Strongest_Extension(class_name: \"__YESIMHERE\"\
    , extensions: [\"t\", \"eMptY\", \"nothing\", \"zeR00\", \"NuLl__\", \"123NoooneB321\"\
    ]) == \"__YESIMHERE.NuLl__\")\nassert(Strongest_Extension(class_name: \"K\", extensions:\
    \ [\"Ta\", \"TAR\", \"t234An\", \"cosSo\"]) == \"K.TAR\")\nassert(Strongest_Extension(class_name:\
    \ \"__HAHA\", extensions: [\"Tab\", \"123\", \"781345\", \"-_-\"]) == \"__HAHA.123\"\
    )\nassert(Strongest_Extension(class_name: \"YameRore\", extensions: [\"HhAas\"\
    , \"okIWILL123\", \"WorkOut\", \"Fails\", \"-_-\"]) == \"YameRore.okIWILL123\"\
    )\nassert(Strongest_Extension(class_name: \"finNNalLLly\", extensions: [\"Die\"\
    , \"NowW\", \"Wow\", \"WoW\"]) == \"finNNalLLly.WoW\")\nassert(Strongest_Extension(class_name:\
    \ \"_\", extensions: [\"Bb\", \"91245\"]) == \"_.Bb\")\nassert(Strongest_Extension(class_name:\
    \ \"Sp\", extensions: [\"671235\", \"Bb\"]) == \"Sp.671235\")"
  status: Exception
  stderr: 'tmpc6p1tu7k/tmpc6p1tu7k.swift:51: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b510557dc80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b5105274b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b5105274988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b51052737b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpc6p1tu7k                        0x0000564662368a3d <unavailable> + 6717

    5    libc.so.6                          0x00002b5105769460 __libc_start_main +
    245

    6    tmpc6p1tu7k                        0x00005646623685c9 <unavailable> + 5577

    '
  stdout: ''
  timestamp: 1660009432
- exit_code: 0
  program: "\n/// You will be given the name of a class (a string) and an array of\
    \ extensions.\n/// The extensions are to be used to load additional classes to\
    \ the class. The\n/// strength of the extension is as follows: Let CAP be the\
    \ number of the uppercase\n/// letters in the extension's name, and let SM be\
    \ the number of lowercase letters \n/// in the extension's name, the strength\
    \ is given by the fraction CAP - SM. \n/// You should find the strongest extension\
    \ and return a string in this \n/// format: ClassName.StrongestExtensionName.\n\
    /// If there are two or more extensions with the same strength, you should\n///\
    \ choose the one that comes first in the array.\n/// For example, if you are given\
    \ \"Slices\" as the class and an array of the\n/// extensions: ['SErviNGSliCes',\
    \ 'Cheese', 'StuFfed'] then you should\n/// return 'Slices.SErviNGSliCes' since\
    \ 'SErviNGSliCes' is the strongest extension \n/// (its strength is -1).\n///\
    \ Example:\n/// >>> Strongest_Extension(class_name: \"my_class\", extensions:\
    \ [\"AA\", \"Be\", \"CC\"])\n/// \"my_class.AA\"\nfunc Strongest_Extension(class_name:\
    \ String, extensions: [String]) -> String {\n\tvar strength = -9999\n\tvar strongest_extension\
    \ = \"\"\n\tvar current_strength = 0\n\tfor ext in extensions {\n\t\tcurrent_strength\
    \ = ext.filter({$0.isUppercase}).count - ext.filter({$0.isLowercase}).count\n\t\
    \tif current_strength > strength {\n\t\t\tstrength = current_strength\n\t\t\t\
    strongest_extension = ext\n\t\t}\n\t}\n\treturn \"\\(class_name).\\(strongest_extension)\"\
    \n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(Strongest_Extension(class_name: \"Watashi\", extensions:\
    \ [\"tEN\", \"niNE\", \"eIGHt8OKe\"]) == \"Watashi.eIGHt8OKe\")\nassert(Strongest_Extension(class_name:\
    \ \"Boku123\", extensions: [\"nani\", \"NazeDa\", \"YEs.WeCaNe\", \"32145tggg\"\
    ]) == \"Boku123.YEs.WeCaNe\")\nassert(Strongest_Extension(class_name: \"__YESIMHERE\"\
    , extensions: [\"t\", \"eMptY\", \"nothing\", \"zeR00\", \"NuLl__\", \"123NoooneB321\"\
    ]) == \"__YESIMHERE.NuLl__\")\nassert(Strongest_Extension(class_name: \"K\", extensions:\
    \ [\"Ta\", \"TAR\", \"t234An\", \"cosSo\"]) == \"K.TAR\")\nassert(Strongest_Extension(class_name:\
    \ \"__HAHA\", extensions: [\"Tab\", \"123\", \"781345\", \"-_-\"]) == \"__HAHA.123\"\
    )\nassert(Strongest_Extension(class_name: \"YameRore\", extensions: [\"HhAas\"\
    , \"okIWILL123\", \"WorkOut\", \"Fails\", \"-_-\"]) == \"YameRore.okIWILL123\"\
    )\nassert(Strongest_Extension(class_name: \"finNNalLLly\", extensions: [\"Die\"\
    , \"NowW\", \"Wow\", \"WoW\"]) == \"finNNalLLly.WoW\")\nassert(Strongest_Extension(class_name:\
    \ \"_\", extensions: [\"Bb\", \"91245\"]) == \"_.Bb\")\nassert(Strongest_Extension(class_name:\
    \ \"Sp\", extensions: [\"671235\", \"Bb\"]) == \"Sp.671235\")"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660009432
- exit_code: 1
  program: "\n/// You will be given the name of a class (a string) and an array of\
    \ extensions.\n/// The extensions are to be used to load additional classes to\
    \ the class. The\n/// strength of the extension is as follows: Let CAP be the\
    \ number of the uppercase\n/// letters in the extension's name, and let SM be\
    \ the number of lowercase letters \n/// in the extension's name, the strength\
    \ is given by the fraction CAP - SM. \n/// You should find the strongest extension\
    \ and return a string in this \n/// format: ClassName.StrongestExtensionName.\n\
    /// If there are two or more extensions with the same strength, you should\n///\
    \ choose the one that comes first in the array.\n/// For example, if you are given\
    \ \"Slices\" as the class and an array of the\n/// extensions: ['SErviNGSliCes',\
    \ 'Cheese', 'StuFfed'] then you should\n/// return 'Slices.SErviNGSliCes' since\
    \ 'SErviNGSliCes' is the strongest extension \n/// (its strength is -1).\n///\
    \ Example:\n/// >>> Strongest_Extension(class_name: \"my_class\", extensions:\
    \ [\"AA\", \"Be\", \"CC\"])\n/// \"my_class.AA\"\nfunc Strongest_Extension(class_name:\
    \ String, extensions: [String]) -> String {\n    let cap_sm_dict = [Character:\
    \ Int]()\n    var strongest = extensions[0]\n    var max_strength = 0.0\n    for\
    \ extension in extensions {\n        var cap = 0\n        var sm = 0\n       \
    \ for letter in extension {\n            if letter.isUppercase {\n           \
    \     cap += 1\n            } else {\n                sm += 1\n            }\n\
    \        }\n        let strength = Double(cap) - Double(sm)\n        if strength\
    \ > max_strength {\n            max_strength = strength\n            strongest\
    \ = extension\n        }\n    }\n    return \"\\(class_name).\\(strongest)\"\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(Strongest_Extension(class_name: \"Watashi\", extensions:\
    \ [\"tEN\", \"niNE\", \"eIGHt8OKe\"]) == \"Watashi.eIGHt8OKe\")\nassert(Strongest_Extension(class_name:\
    \ \"Boku123\", extensions: [\"nani\", \"NazeDa\", \"YEs.WeCaNe\", \"32145tggg\"\
    ]) == \"Boku123.YEs.WeCaNe\")\nassert(Strongest_Extension(class_name: \"__YESIMHERE\"\
    , extensions: [\"t\", \"eMptY\", \"nothing\", \"zeR00\", \"NuLl__\", \"123NoooneB321\"\
    ]) == \"__YESIMHERE.NuLl__\")\nassert(Strongest_Extension(class_name: \"K\", extensions:\
    \ [\"Ta\", \"TAR\", \"t234An\", \"cosSo\"]) == \"K.TAR\")\nassert(Strongest_Extension(class_name:\
    \ \"__HAHA\", extensions: [\"Tab\", \"123\", \"781345\", \"-_-\"]) == \"__HAHA.123\"\
    )\nassert(Strongest_Extension(class_name: \"YameRore\", extensions: [\"HhAas\"\
    , \"okIWILL123\", \"WorkOut\", \"Fails\", \"-_-\"]) == \"YameRore.okIWILL123\"\
    )\nassert(Strongest_Extension(class_name: \"finNNalLLly\", extensions: [\"Die\"\
    , \"NowW\", \"Wow\", \"WoW\"]) == \"finNNalLLly.WoW\")\nassert(Strongest_Extension(class_name:\
    \ \"_\", extensions: [\"Bb\", \"91245\"]) == \"_.Bb\")\nassert(Strongest_Extension(class_name:\
    \ \"Sp\", extensions: [\"671235\", \"Bb\"]) == \"Sp.671235\")"
  status: SyntaxError
  stderr: "/tmp/tmp9pbmt5xy.swift:22:9: error: expected pattern\n    for extension\
    \ in extensions {\n        ^\n/tmp/tmp9pbmt5xy.swift:22:9: error: expected Sequence\
    \ expression for for-each loop\n    for extension in extensions {\n        ^\n\
    /tmp/tmp9pbmt5xy.swift:22:9: error: expected '{' to start the body of for-each\
    \ loop\n    for extension in extensions {\n        ^\n/tmp/tmp9pbmt5xy.swift:25:23:\
    \ error: expected Sequence expression for for-each loop\n        for letter in\
    \ extension {\n                      ^\n/tmp/tmp9pbmt5xy.swift:25:23: error: expected\
    \ '{' to start the body of for-each loop\n        for letter in extension {\n\
    \                      ^\n/tmp/tmp9pbmt5xy.swift:35:25: error: expected expression\
    \ in assignment\n            strongest = extension\n                        ^\n\
    /tmp/tmp9pbmt5xy.swift:36:9: error: expected type name in extension declaration\n\
    \        }\n        ^\n/tmp/tmp9pbmt5xy.swift:35:34: error: expected '{' in extension\n\
    \            strongest = extension\n                                 ^\n/tmp/tmp9pbmt5xy.swift:35:25:\
    \ error: declaration is only valid at file scope\n            strongest = extension\n\
    \                        ^\n"
  stdout: ''
  timestamp: 1660009432
- exit_code: 1
  program: "\n/// You will be given the name of a class (a string) and an array of\
    \ extensions.\n/// The extensions are to be used to load additional classes to\
    \ the class. The\n/// strength of the extension is as follows: Let CAP be the\
    \ number of the uppercase\n/// letters in the extension's name, and let SM be\
    \ the number of lowercase letters \n/// in the extension's name, the strength\
    \ is given by the fraction CAP - SM. \n/// You should find the strongest extension\
    \ and return a string in this \n/// format: ClassName.StrongestExtensionName.\n\
    /// If there are two or more extensions with the same strength, you should\n///\
    \ choose the one that comes first in the array.\n/// For example, if you are given\
    \ \"Slices\" as the class and an array of the\n/// extensions: ['SErviNGSliCes',\
    \ 'Cheese', 'StuFfed'] then you should\n/// return 'Slices.SErviNGSliCes' since\
    \ 'SErviNGSliCes' is the strongest extension \n/// (its strength is -1).\n///\
    \ Example:\n/// >>> Strongest_Extension(class_name: \"my_class\", extensions:\
    \ [\"AA\", \"Be\", \"CC\"])\n/// \"my_class.AA\"\nfunc Strongest_Extension(class_name:\
    \ String, extensions: [String]) -> String {\n    var strongest_index = 0\n   \
    \ var strongest_strength = 0\n    for (index, ext) in extensions.enumerated()\
    \ {\n        let caps = ext.uppercased().replacingOccurrences(of: \"[^A-Z]\",\
    \ with: \"\", options: .regularExpression)\n        let sm = ext.lowercased().replacingOccurrences(of:\
    \ \"[^a-z]\", with: \"\", options: .regularExpression)\n        let strength =\
    \ caps.count - sm.count\n        if strength > strongest_strength {\n        \
    \    strongest_index = index\n            strongest_strength = strength\n    \
    \    }\n    }\n    return \"\\(class_name).\\(extensions[strongest_index])\"\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(Strongest_Extension(class_name: \"Watashi\", extensions:\
    \ [\"tEN\", \"niNE\", \"eIGHt8OKe\"]) == \"Watashi.eIGHt8OKe\")\nassert(Strongest_Extension(class_name:\
    \ \"Boku123\", extensions: [\"nani\", \"NazeDa\", \"YEs.WeCaNe\", \"32145tggg\"\
    ]) == \"Boku123.YEs.WeCaNe\")\nassert(Strongest_Extension(class_name: \"__YESIMHERE\"\
    , extensions: [\"t\", \"eMptY\", \"nothing\", \"zeR00\", \"NuLl__\", \"123NoooneB321\"\
    ]) == \"__YESIMHERE.NuLl__\")\nassert(Strongest_Extension(class_name: \"K\", extensions:\
    \ [\"Ta\", \"TAR\", \"t234An\", \"cosSo\"]) == \"K.TAR\")\nassert(Strongest_Extension(class_name:\
    \ \"__HAHA\", extensions: [\"Tab\", \"123\", \"781345\", \"-_-\"]) == \"__HAHA.123\"\
    )\nassert(Strongest_Extension(class_name: \"YameRore\", extensions: [\"HhAas\"\
    , \"okIWILL123\", \"WorkOut\", \"Fails\", \"-_-\"]) == \"YameRore.okIWILL123\"\
    )\nassert(Strongest_Extension(class_name: \"finNNalLLly\", extensions: [\"Die\"\
    , \"NowW\", \"Wow\", \"WoW\"]) == \"finNNalLLly.WoW\")\nassert(Strongest_Extension(class_name:\
    \ \"_\", extensions: [\"Bb\", \"91245\"]) == \"_.Bb\")\nassert(Strongest_Extension(class_name:\
    \ \"Sp\", extensions: [\"671235\", \"Bb\"]) == \"Sp.671235\")"
  status: SyntaxError
  stderr: "/tmp/tmpdfk0rlnb.swift:22:37: error: value of type 'String' has no member\
    \ 'replacingOccurrences'\n        let caps = ext.uppercased().replacingOccurrences(of:\
    \ \"[^A-Z]\", with: \"\", options: .regularExpression)\n                   ~~~~~~~~~~~~~~~~\
    \ ^~~~~~~~~~~~~~~~~~~~\n/tmp/tmpdfk0rlnb.swift:22:92: error: cannot infer contextual\
    \ base in reference to member 'regularExpression'\n        let caps = ext.uppercased().replacingOccurrences(of:\
    \ \"[^A-Z]\", with: \"\", options: .regularExpression)\n                     \
    \                                                                     ~^~~~~~~~~~~~~~~~~\n\
    /tmp/tmpdfk0rlnb.swift:23:35: error: value of type 'String' has no member 'replacingOccurrences'\n\
    \        let sm = ext.lowercased().replacingOccurrences(of: \"[^a-z]\", with:\
    \ \"\", options: .regularExpression)\n                 ~~~~~~~~~~~~~~~~ ^~~~~~~~~~~~~~~~~~~~\n\
    /tmp/tmpdfk0rlnb.swift:23:90: error: cannot infer contextual base in reference\
    \ to member 'regularExpression'\n        let sm = ext.lowercased().replacingOccurrences(of:\
    \ \"[^a-z]\", with: \"\", options: .regularExpression)\n                     \
    \                                                                   ~^~~~~~~~~~~~~~~~~\n"
  stdout: ''
  timestamp: 1660009432
- exit_code: -4
  program: "\n/// You will be given the name of a class (a string) and an array of\
    \ extensions.\n/// The extensions are to be used to load additional classes to\
    \ the class. The\n/// strength of the extension is as follows: Let CAP be the\
    \ number of the uppercase\n/// letters in the extension's name, and let SM be\
    \ the number of lowercase letters \n/// in the extension's name, the strength\
    \ is given by the fraction CAP - SM. \n/// You should find the strongest extension\
    \ and return a string in this \n/// format: ClassName.StrongestExtensionName.\n\
    /// If there are two or more extensions with the same strength, you should\n///\
    \ choose the one that comes first in the array.\n/// For example, if you are given\
    \ \"Slices\" as the class and an array of the\n/// extensions: ['SErviNGSliCes',\
    \ 'Cheese', 'StuFfed'] then you should\n/// return 'Slices.SErviNGSliCes' since\
    \ 'SErviNGSliCes' is the strongest extension \n/// (its strength is -1).\n///\
    \ Example:\n/// >>> Strongest_Extension(class_name: \"my_class\", extensions:\
    \ [\"AA\", \"Be\", \"CC\"])\n/// \"my_class.AA\"\nfunc Strongest_Extension(class_name:\
    \ String, extensions: [String]) -> String {\n    var strongest_extension = \"\"\
    \n    var strongest_strength = 0.0\n    for extension_ in extensions {\n     \
    \   let cap = extension_.uppercased().filter({ $0 >= \"A\" && $0 <= \"Z\" }).count\n\
    \        let sm = extension_.lowercased().filter({ $0 >= \"a\" && $0 <= \"z\"\
    \ }).count\n        let strength = Double(cap) - Double(sm)\n        if strength\
    \ > strongest_strength {\n            strongest_strength = strength\n        \
    \    strongest_extension = extension_\n        }\n    }\n    return \"\\(class_name).\\\
    (strongest_extension)\"\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(Strongest_Extension(class_name:\
    \ \"Watashi\", extensions: [\"tEN\", \"niNE\", \"eIGHt8OKe\"]) == \"Watashi.eIGHt8OKe\"\
    )\nassert(Strongest_Extension(class_name: \"Boku123\", extensions: [\"nani\",\
    \ \"NazeDa\", \"YEs.WeCaNe\", \"32145tggg\"]) == \"Boku123.YEs.WeCaNe\")\nassert(Strongest_Extension(class_name:\
    \ \"__YESIMHERE\", extensions: [\"t\", \"eMptY\", \"nothing\", \"zeR00\", \"NuLl__\"\
    , \"123NoooneB321\"]) == \"__YESIMHERE.NuLl__\")\nassert(Strongest_Extension(class_name:\
    \ \"K\", extensions: [\"Ta\", \"TAR\", \"t234An\", \"cosSo\"]) == \"K.TAR\")\n\
    assert(Strongest_Extension(class_name: \"__HAHA\", extensions: [\"Tab\", \"123\"\
    , \"781345\", \"-_-\"]) == \"__HAHA.123\")\nassert(Strongest_Extension(class_name:\
    \ \"YameRore\", extensions: [\"HhAas\", \"okIWILL123\", \"WorkOut\", \"Fails\"\
    , \"-_-\"]) == \"YameRore.okIWILL123\")\nassert(Strongest_Extension(class_name:\
    \ \"finNNalLLly\", extensions: [\"Die\", \"NowW\", \"Wow\", \"WoW\"]) == \"finNNalLLly.WoW\"\
    )\nassert(Strongest_Extension(class_name: \"_\", extensions: [\"Bb\", \"91245\"\
    ]) == \"_.Bb\")\nassert(Strongest_Extension(class_name: \"Sp\", extensions: [\"\
    671235\", \"Bb\"]) == \"Sp.671235\")"
  status: Exception
  stderr: 'tmpiz_ifzi1/tmpiz_ifzi1.swift:46: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002ae657bd0c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002ae6578c7b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002ae6578c7988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002ae6578c67b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpiz_ifzi1                        0x000056379c716c8d <unavailable> + 7309

    5    libc.so.6                          0x00002ae657dbc460 __libc_start_main +
    245

    6    tmpiz_ifzi1                        0x000056379c716819 <unavailable> + 6169

    '
  stdout: ''
  timestamp: 1660009432
- exit_code: 1
  program: "\n/// You will be given the name of a class (a string) and an array of\
    \ extensions.\n/// The extensions are to be used to load additional classes to\
    \ the class. The\n/// strength of the extension is as follows: Let CAP be the\
    \ number of the uppercase\n/// letters in the extension's name, and let SM be\
    \ the number of lowercase letters \n/// in the extension's name, the strength\
    \ is given by the fraction CAP - SM. \n/// You should find the strongest extension\
    \ and return a string in this \n/// format: ClassName.StrongestExtensionName.\n\
    /// If there are two or more extensions with the same strength, you should\n///\
    \ choose the one that comes first in the array.\n/// For example, if you are given\
    \ \"Slices\" as the class and an array of the\n/// extensions: ['SErviNGSliCes',\
    \ 'Cheese', 'StuFfed'] then you should\n/// return 'Slices.SErviNGSliCes' since\
    \ 'SErviNGSliCes' is the strongest extension \n/// (its strength is -1).\n///\
    \ Example:\n/// >>> Strongest_Extension(class_name: \"my_class\", extensions:\
    \ [\"AA\", \"Be\", \"CC\"])\n/// \"my_class.AA\"\nfunc Strongest_Extension(class_name:\
    \ String, extensions: [String]) -> String {\n    var strongest_extension = extensions[0]\n\
    \    var strength = 0\n    var strength_of_current_extension = 0\n    for ext\
    \ in extensions {\n        strength_of_current_extension = strength_of_extension(extension:\
    \ ext)\n        if strength_of_current_extension > strength {\n            strength\
    \ = strength_of_current_extension\n            strongest_extension = ext\n   \
    \     }\n    }\n    return class_name + \".\" + strongest_extension\n}\n\n\nfunc\
    \ ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count !=\
    \ right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(Strongest_Extension(class_name: \"Watashi\", extensions:\
    \ [\"tEN\", \"niNE\", \"eIGHt8OKe\"]) == \"Watashi.eIGHt8OKe\")\nassert(Strongest_Extension(class_name:\
    \ \"Boku123\", extensions: [\"nani\", \"NazeDa\", \"YEs.WeCaNe\", \"32145tggg\"\
    ]) == \"Boku123.YEs.WeCaNe\")\nassert(Strongest_Extension(class_name: \"__YESIMHERE\"\
    , extensions: [\"t\", \"eMptY\", \"nothing\", \"zeR00\", \"NuLl__\", \"123NoooneB321\"\
    ]) == \"__YESIMHERE.NuLl__\")\nassert(Strongest_Extension(class_name: \"K\", extensions:\
    \ [\"Ta\", \"TAR\", \"t234An\", \"cosSo\"]) == \"K.TAR\")\nassert(Strongest_Extension(class_name:\
    \ \"__HAHA\", extensions: [\"Tab\", \"123\", \"781345\", \"-_-\"]) == \"__HAHA.123\"\
    )\nassert(Strongest_Extension(class_name: \"YameRore\", extensions: [\"HhAas\"\
    , \"okIWILL123\", \"WorkOut\", \"Fails\", \"-_-\"]) == \"YameRore.okIWILL123\"\
    )\nassert(Strongest_Extension(class_name: \"finNNalLLly\", extensions: [\"Die\"\
    , \"NowW\", \"Wow\", \"WoW\"]) == \"finNNalLLly.WoW\")\nassert(Strongest_Extension(class_name:\
    \ \"_\", extensions: [\"Bb\", \"91245\"]) == \"_.Bb\")\nassert(Strongest_Extension(class_name:\
    \ \"Sp\", extensions: [\"671235\", \"Bb\"]) == \"Sp.671235\")"
  status: SyntaxError
  stderr: "/tmp/tmp3ek8r1q2.swift:23:41: error: cannot find 'strength_of_extension'\
    \ in scope\n        strength_of_current_extension = strength_of_extension(extension:\
    \ ext)\n                                        ^~~~~~~~~~~~~~~~~~~~~\n"
  stdout: ''
  timestamp: 1660009432
- exit_code: 1
  program: "\n/// You will be given the name of a class (a string) and an array of\
    \ extensions.\n/// The extensions are to be used to load additional classes to\
    \ the class. The\n/// strength of the extension is as follows: Let CAP be the\
    \ number of the uppercase\n/// letters in the extension's name, and let SM be\
    \ the number of lowercase letters \n/// in the extension's name, the strength\
    \ is given by the fraction CAP - SM. \n/// You should find the strongest extension\
    \ and return a string in this \n/// format: ClassName.StrongestExtensionName.\n\
    /// If there are two or more extensions with the same strength, you should\n///\
    \ choose the one that comes first in the array.\n/// For example, if you are given\
    \ \"Slices\" as the class and an array of the\n/// extensions: ['SErviNGSliCes',\
    \ 'Cheese', 'StuFfed'] then you should\n/// return 'Slices.SErviNGSliCes' since\
    \ 'SErviNGSliCes' is the strongest extension \n/// (its strength is -1).\n///\
    \ Example:\n/// >>> Strongest_Extension(class_name: \"my_class\", extensions:\
    \ [\"AA\", \"Be\", \"CC\"])\n/// \"my_class.AA\"\nfunc Strongest_Extension(class_name:\
    \ String, extensions: [String]) -> String {\n    var max_strength = 0.0\n    var\
    \ min_index = 0\n    for (index, extension) in extensions.enumerated() {\n   \
    \     var upper_case_letters = 0\n        var lower_case_letters = 0\n       \
    \ for char in extension {\n            switch char {\n            case \"A\"...\"\
    Z\":\n                upper_case_letters += 1\n            case \"a\"...\"z\"\
    :\n                lower_case_letters += 1\n            default:\n           \
    \     break\n            }\n        }\n        if (Double(upper_case_letters)\
    \ - Double(lower_case_letters)) > max_strength {\n            max_strength = Double(upper_case_letters)\
    \ - Double(lower_case_letters)\n            min_index = index\n        }\n   \
    \ }\n    return \"\\(class_name).\\(extensions[min_index])\"\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(Strongest_Extension(class_name: \"Watashi\", extensions:\
    \ [\"tEN\", \"niNE\", \"eIGHt8OKe\"]) == \"Watashi.eIGHt8OKe\")\nassert(Strongest_Extension(class_name:\
    \ \"Boku123\", extensions: [\"nani\", \"NazeDa\", \"YEs.WeCaNe\", \"32145tggg\"\
    ]) == \"Boku123.YEs.WeCaNe\")\nassert(Strongest_Extension(class_name: \"__YESIMHERE\"\
    , extensions: [\"t\", \"eMptY\", \"nothing\", \"zeR00\", \"NuLl__\", \"123NoooneB321\"\
    ]) == \"__YESIMHERE.NuLl__\")\nassert(Strongest_Extension(class_name: \"K\", extensions:\
    \ [\"Ta\", \"TAR\", \"t234An\", \"cosSo\"]) == \"K.TAR\")\nassert(Strongest_Extension(class_name:\
    \ \"__HAHA\", extensions: [\"Tab\", \"123\", \"781345\", \"-_-\"]) == \"__HAHA.123\"\
    )\nassert(Strongest_Extension(class_name: \"YameRore\", extensions: [\"HhAas\"\
    , \"okIWILL123\", \"WorkOut\", \"Fails\", \"-_-\"]) == \"YameRore.okIWILL123\"\
    )\nassert(Strongest_Extension(class_name: \"finNNalLLly\", extensions: [\"Die\"\
    , \"NowW\", \"Wow\", \"WoW\"]) == \"finNNalLLly.WoW\")\nassert(Strongest_Extension(class_name:\
    \ \"_\", extensions: [\"Bb\", \"91245\"]) == \"_.Bb\")\nassert(Strongest_Extension(class_name:\
    \ \"Sp\", extensions: [\"671235\", \"Bb\"]) == \"Sp.671235\")"
  status: SyntaxError
  stderr: "/tmp/tmp4es2rfvf.swift:21:17: error: expected pattern\n    for (index,\
    \ extension) in extensions.enumerated() {\n                ^\n/tmp/tmp4es2rfvf.swift:21:17:\
    \ error: expected 'in' after for-each pattern\n    for (index, extension) in extensions.enumerated()\
    \ {\n                ^\n/tmp/tmp4es2rfvf.swift:21:17: error: expected Sequence\
    \ expression for for-each loop\n    for (index, extension) in extensions.enumerated()\
    \ {\n                ^\n/tmp/tmp4es2rfvf.swift:21:17: error: expected '{' to start\
    \ the body of for-each loop\n    for (index, extension) in extensions.enumerated()\
    \ {\n                ^\n/tmp/tmp4es2rfvf.swift:24:21: error: expected Sequence\
    \ expression for for-each loop\n        for char in extension {\n            \
    \        ^\n/tmp/tmp4es2rfvf.swift:24:21: error: expected '{' to start the body\
    \ of for-each loop\n        for char in extension {\n                    ^\n"
  stdout: ''
  timestamp: 1660009432
- exit_code: -4
  program: "\n/// You will be given the name of a class (a string) and an array of\
    \ extensions.\n/// The extensions are to be used to load additional classes to\
    \ the class. The\n/// strength of the extension is as follows: Let CAP be the\
    \ number of the uppercase\n/// letters in the extension's name, and let SM be\
    \ the number of lowercase letters \n/// in the extension's name, the strength\
    \ is given by the fraction CAP - SM. \n/// You should find the strongest extension\
    \ and return a string in this \n/// format: ClassName.StrongestExtensionName.\n\
    /// If there are two or more extensions with the same strength, you should\n///\
    \ choose the one that comes first in the array.\n/// For example, if you are given\
    \ \"Slices\" as the class and an array of the\n/// extensions: ['SErviNGSliCes',\
    \ 'Cheese', 'StuFfed'] then you should\n/// return 'Slices.SErviNGSliCes' since\
    \ 'SErviNGSliCes' is the strongest extension \n/// (its strength is -1).\n///\
    \ Example:\n/// >>> Strongest_Extension(class_name: \"my_class\", extensions:\
    \ [\"AA\", \"Be\", \"CC\"])\n/// \"my_class.AA\"\nfunc Strongest_Extension(class_name:\
    \ String, extensions: [String]) -> String {\n    let sorted = extensions.sorted\
    \ { (first, second) -> Bool in\n        let numUpFirst = first.filter{ $0.isUppercase\
    \ }.count\n        let numLoFirst = first.filter{ $0.isLowercase }.count\n   \
    \     let strengthFirst = Double(numUpFirst - numLoFirst) / Double(first.count)\n\
    \        \n        let numUpSecond = second.filter{ $0.isUppercase }.count\n \
    \       let numLoSecond = second.filter{ $0.isLowercase }.count\n        let strengthSecond\
    \ = Double(numUpSecond - numLoSecond) / Double(second.count)\n        \n     \
    \   return strengthFirst > strengthSecond\n    }\n    return \"\\(class_name).\\\
    (sorted.first!)\"\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) ->\
    \ Bool {\n    if left.count != right.count {\n        return false\n    }\n  \
    \  for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(Strongest_Extension(class_name:\
    \ \"Watashi\", extensions: [\"tEN\", \"niNE\", \"eIGHt8OKe\"]) == \"Watashi.eIGHt8OKe\"\
    )\nassert(Strongest_Extension(class_name: \"Boku123\", extensions: [\"nani\",\
    \ \"NazeDa\", \"YEs.WeCaNe\", \"32145tggg\"]) == \"Boku123.YEs.WeCaNe\")\nassert(Strongest_Extension(class_name:\
    \ \"__YESIMHERE\", extensions: [\"t\", \"eMptY\", \"nothing\", \"zeR00\", \"NuLl__\"\
    , \"123NoooneB321\"]) == \"__YESIMHERE.NuLl__\")\nassert(Strongest_Extension(class_name:\
    \ \"K\", extensions: [\"Ta\", \"TAR\", \"t234An\", \"cosSo\"]) == \"K.TAR\")\n\
    assert(Strongest_Extension(class_name: \"__HAHA\", extensions: [\"Tab\", \"123\"\
    , \"781345\", \"-_-\"]) == \"__HAHA.123\")\nassert(Strongest_Extension(class_name:\
    \ \"YameRore\", extensions: [\"HhAas\", \"okIWILL123\", \"WorkOut\", \"Fails\"\
    , \"-_-\"]) == \"YameRore.okIWILL123\")\nassert(Strongest_Extension(class_name:\
    \ \"finNNalLLly\", extensions: [\"Die\", \"NowW\", \"Wow\", \"WoW\"]) == \"finNNalLLly.WoW\"\
    )\nassert(Strongest_Extension(class_name: \"_\", extensions: [\"Bb\", \"91245\"\
    ]) == \"_.Bb\")\nassert(Strongest_Extension(class_name: \"Sp\", extensions: [\"\
    671235\", \"Bb\"]) == \"Sp.671235\")"
  status: Exception
  stderr: 'tmp8f_gofcc/tmp8f_gofcc.swift:46: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b6214989c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b6214680b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b6214680988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b621467f7b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmp8f_gofcc                        0x00005602a0f56afd <unavailable> + 6909

    5    libc.so.6                          0x00002b6214b75460 __libc_start_main +
    245

    6    tmp8f_gofcc                        0x00005602a0f56689 <unavailable> + 5769

    '
  stdout: ''
  timestamp: 1660009432
- exit_code: -4
  program: "\n/// You will be given the name of a class (a string) and an array of\
    \ extensions.\n/// The extensions are to be used to load additional classes to\
    \ the class. The\n/// strength of the extension is as follows: Let CAP be the\
    \ number of the uppercase\n/// letters in the extension's name, and let SM be\
    \ the number of lowercase letters \n/// in the extension's name, the strength\
    \ is given by the fraction CAP - SM. \n/// You should find the strongest extension\
    \ and return a string in this \n/// format: ClassName.StrongestExtensionName.\n\
    /// If there are two or more extensions with the same strength, you should\n///\
    \ choose the one that comes first in the array.\n/// For example, if you are given\
    \ \"Slices\" as the class and an array of the\n/// extensions: ['SErviNGSliCes',\
    \ 'Cheese', 'StuFfed'] then you should\n/// return 'Slices.SErviNGSliCes' since\
    \ 'SErviNGSliCes' is the strongest extension \n/// (its strength is -1).\n///\
    \ Example:\n/// >>> Strongest_Extension(class_name: \"my_class\", extensions:\
    \ [\"AA\", \"Be\", \"CC\"])\n/// \"my_class.AA\"\nfunc Strongest_Extension(class_name:\
    \ String, extensions: [String]) -> String {\n\treturn class_name + \".\" + extensions.reduce((\"\
    \", 0), { (prev, curr) -> (String, Int) in\n\t\tlet a = curr.filter { $0.isUppercase\
    \ }.count\n\t\tlet b = curr.filter { $0.isLowercase }.count\n\t\tif a - b > prev.1\
    \ {\n\t\t\treturn (curr, a - b)\n\t\t}\n\t\treturn prev\n\t}).0\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(Strongest_Extension(class_name: \"Watashi\", extensions:\
    \ [\"tEN\", \"niNE\", \"eIGHt8OKe\"]) == \"Watashi.eIGHt8OKe\")\nassert(Strongest_Extension(class_name:\
    \ \"Boku123\", extensions: [\"nani\", \"NazeDa\", \"YEs.WeCaNe\", \"32145tggg\"\
    ]) == \"Boku123.YEs.WeCaNe\")\nassert(Strongest_Extension(class_name: \"__YESIMHERE\"\
    , extensions: [\"t\", \"eMptY\", \"nothing\", \"zeR00\", \"NuLl__\", \"123NoooneB321\"\
    ]) == \"__YESIMHERE.NuLl__\")\nassert(Strongest_Extension(class_name: \"K\", extensions:\
    \ [\"Ta\", \"TAR\", \"t234An\", \"cosSo\"]) == \"K.TAR\")\nassert(Strongest_Extension(class_name:\
    \ \"__HAHA\", extensions: [\"Tab\", \"123\", \"781345\", \"-_-\"]) == \"__HAHA.123\"\
    )\nassert(Strongest_Extension(class_name: \"YameRore\", extensions: [\"HhAas\"\
    , \"okIWILL123\", \"WorkOut\", \"Fails\", \"-_-\"]) == \"YameRore.okIWILL123\"\
    )\nassert(Strongest_Extension(class_name: \"finNNalLLly\", extensions: [\"Die\"\
    , \"NowW\", \"Wow\", \"WoW\"]) == \"finNNalLLly.WoW\")\nassert(Strongest_Extension(class_name:\
    \ \"_\", extensions: [\"Bb\", \"91245\"]) == \"_.Bb\")\nassert(Strongest_Extension(class_name:\
    \ \"Sp\", extensions: [\"671235\", \"Bb\"]) == \"Sp.671235\")"
  status: Exception
  stderr: 'tmp0nkk3nei/tmp0nkk3nei.swift:44: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b1321bedc80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b13218e4b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b13218e4988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b13218e37b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmp0nkk3nei                        0x0000555c294c6bdc <unavailable> + 7132

    5    libc.so.6                          0x00002b1321dd9460 __libc_start_main +
    245

    6    tmp0nkk3nei                        0x0000555c294c62e9 <unavailable> + 4841

    '
  stdout: ''
  timestamp: 1660009432
- exit_code: -4
  program: "\n/// You will be given the name of a class (a string) and an array of\
    \ extensions.\n/// The extensions are to be used to load additional classes to\
    \ the class. The\n/// strength of the extension is as follows: Let CAP be the\
    \ number of the uppercase\n/// letters in the extension's name, and let SM be\
    \ the number of lowercase letters \n/// in the extension's name, the strength\
    \ is given by the fraction CAP - SM. \n/// You should find the strongest extension\
    \ and return a string in this \n/// format: ClassName.StrongestExtensionName.\n\
    /// If there are two or more extensions with the same strength, you should\n///\
    \ choose the one that comes first in the array.\n/// For example, if you are given\
    \ \"Slices\" as the class and an array of the\n/// extensions: ['SErviNGSliCes',\
    \ 'Cheese', 'StuFfed'] then you should\n/// return 'Slices.SErviNGSliCes' since\
    \ 'SErviNGSliCes' is the strongest extension \n/// (its strength is -1).\n///\
    \ Example:\n/// >>> Strongest_Extension(class_name: \"my_class\", extensions:\
    \ [\"AA\", \"Be\", \"CC\"])\n/// \"my_class.AA\"\nfunc Strongest_Extension(class_name:\
    \ String, extensions: [String]) -> String {\n    var strongest = 0\n    var index\
    \ = 0\n    for (i, letter) in extensions.enumerated() {\n        var cap = 0\n\
    \        var small = 0\n        for each in letter {\n            if each.isUppercase\
    \ {\n                cap += 1\n            } else {\n                small +=\
    \ 1\n            }\n        }\n        let x = cap - small\n        if x > strongest\
    \ {\n            strongest = x\n            index = i\n        }\n    }\n    return\
    \ class_name + \".\" + extensions[index]\n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(Strongest_Extension(class_name: \"Watashi\", extensions: [\"tEN\", \"niNE\"\
    , \"eIGHt8OKe\"]) == \"Watashi.eIGHt8OKe\")\nassert(Strongest_Extension(class_name:\
    \ \"Boku123\", extensions: [\"nani\", \"NazeDa\", \"YEs.WeCaNe\", \"32145tggg\"\
    ]) == \"Boku123.YEs.WeCaNe\")\nassert(Strongest_Extension(class_name: \"__YESIMHERE\"\
    , extensions: [\"t\", \"eMptY\", \"nothing\", \"zeR00\", \"NuLl__\", \"123NoooneB321\"\
    ]) == \"__YESIMHERE.NuLl__\")\nassert(Strongest_Extension(class_name: \"K\", extensions:\
    \ [\"Ta\", \"TAR\", \"t234An\", \"cosSo\"]) == \"K.TAR\")\nassert(Strongest_Extension(class_name:\
    \ \"__HAHA\", extensions: [\"Tab\", \"123\", \"781345\", \"-_-\"]) == \"__HAHA.123\"\
    )\nassert(Strongest_Extension(class_name: \"YameRore\", extensions: [\"HhAas\"\
    , \"okIWILL123\", \"WorkOut\", \"Fails\", \"-_-\"]) == \"YameRore.okIWILL123\"\
    )\nassert(Strongest_Extension(class_name: \"finNNalLLly\", extensions: [\"Die\"\
    , \"NowW\", \"Wow\", \"WoW\"]) == \"finNNalLLly.WoW\")\nassert(Strongest_Extension(class_name:\
    \ \"_\", extensions: [\"Bb\", \"91245\"]) == \"_.Bb\")\nassert(Strongest_Extension(class_name:\
    \ \"Sp\", extensions: [\"671235\", \"Bb\"]) == \"Sp.671235\")"
  status: Exception
  stderr: 'tmpeao08ff8/tmpeao08ff8.swift:53: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b5878aa8c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b587879fb6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b587879f988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b587879e7b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpeao08ff8                        0x0000557b6ca798cd <unavailable> + 6349

    5    libc.so.6                          0x00002b5878c94460 __libc_start_main +
    245

    6    tmpeao08ff8                        0x0000557b6ca79459 <unavailable> + 5209

    '
  stdout: ''
  timestamp: 1660009432
- exit_code: 1
  program: "\n/// You will be given the name of a class (a string) and an array of\
    \ extensions.\n/// The extensions are to be used to load additional classes to\
    \ the class. The\n/// strength of the extension is as follows: Let CAP be the\
    \ number of the uppercase\n/// letters in the extension's name, and let SM be\
    \ the number of lowercase letters \n/// in the extension's name, the strength\
    \ is given by the fraction CAP - SM. \n/// You should find the strongest extension\
    \ and return a string in this \n/// format: ClassName.StrongestExtensionName.\n\
    /// If there are two or more extensions with the same strength, you should\n///\
    \ choose the one that comes first in the array.\n/// For example, if you are given\
    \ \"Slices\" as the class and an array of the\n/// extensions: ['SErviNGSliCes',\
    \ 'Cheese', 'StuFfed'] then you should\n/// return 'Slices.SErviNGSliCes' since\
    \ 'SErviNGSliCes' is the strongest extension \n/// (its strength is -1).\n///\
    \ Example:\n/// >>> Strongest_Extension(class_name: \"my_class\", extensions:\
    \ [\"AA\", \"Be\", \"CC\"])\n/// \"my_class.AA\"\nfunc Strongest_Extension(class_name:\
    \ String, extensions: [String]) -> String {\n  let strength = strength_extensions(extensions:\
    \ extensions)\n  let max_strength = strength.max { a, b in a.value < b.value }\n\
    \  return \"\\(class_name).\\(max_strength!.key)\"\n}\n\n\nfunc ==(left: [(Int,\
    \ Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n\
    \        return false\n    }\n    for (l, r) in zip(left, right) {\n        if\
    \ l != r {\n            return false\n        }\n    }\n    return true\n}\n \
    \           \nassert(Strongest_Extension(class_name: \"Watashi\", extensions:\
    \ [\"tEN\", \"niNE\", \"eIGHt8OKe\"]) == \"Watashi.eIGHt8OKe\")\nassert(Strongest_Extension(class_name:\
    \ \"Boku123\", extensions: [\"nani\", \"NazeDa\", \"YEs.WeCaNe\", \"32145tggg\"\
    ]) == \"Boku123.YEs.WeCaNe\")\nassert(Strongest_Extension(class_name: \"__YESIMHERE\"\
    , extensions: [\"t\", \"eMptY\", \"nothing\", \"zeR00\", \"NuLl__\", \"123NoooneB321\"\
    ]) == \"__YESIMHERE.NuLl__\")\nassert(Strongest_Extension(class_name: \"K\", extensions:\
    \ [\"Ta\", \"TAR\", \"t234An\", \"cosSo\"]) == \"K.TAR\")\nassert(Strongest_Extension(class_name:\
    \ \"__HAHA\", extensions: [\"Tab\", \"123\", \"781345\", \"-_-\"]) == \"__HAHA.123\"\
    )\nassert(Strongest_Extension(class_name: \"YameRore\", extensions: [\"HhAas\"\
    , \"okIWILL123\", \"WorkOut\", \"Fails\", \"-_-\"]) == \"YameRore.okIWILL123\"\
    )\nassert(Strongest_Extension(class_name: \"finNNalLLly\", extensions: [\"Die\"\
    , \"NowW\", \"Wow\", \"WoW\"]) == \"finNNalLLly.WoW\")\nassert(Strongest_Extension(class_name:\
    \ \"_\", extensions: [\"Bb\", \"91245\"]) == \"_.Bb\")\nassert(Strongest_Extension(class_name:\
    \ \"Sp\", extensions: [\"671235\", \"Bb\"]) == \"Sp.671235\")"
  status: SyntaxError
  stderr: "/tmp/tmpm6llyjim.swift:19:18: error: cannot find 'strength_extensions'\
    \ in scope\n  let strength = strength_extensions(extensions: extensions)\n   \
    \              ^~~~~~~~~~~~~~~~~~~\n"
  stdout: ''
  timestamp: 1660009432
- exit_code: -4
  program: "\n/// You will be given the name of a class (a string) and an array of\
    \ extensions.\n/// The extensions are to be used to load additional classes to\
    \ the class. The\n/// strength of the extension is as follows: Let CAP be the\
    \ number of the uppercase\n/// letters in the extension's name, and let SM be\
    \ the number of lowercase letters \n/// in the extension's name, the strength\
    \ is given by the fraction CAP - SM. \n/// You should find the strongest extension\
    \ and return a string in this \n/// format: ClassName.StrongestExtensionName.\n\
    /// If there are two or more extensions with the same strength, you should\n///\
    \ choose the one that comes first in the array.\n/// For example, if you are given\
    \ \"Slices\" as the class and an array of the\n/// extensions: ['SErviNGSliCes',\
    \ 'Cheese', 'StuFfed'] then you should\n/// return 'Slices.SErviNGSliCes' since\
    \ 'SErviNGSliCes' is the strongest extension \n/// (its strength is -1).\n///\
    \ Example:\n/// >>> Strongest_Extension(class_name: \"my_class\", extensions:\
    \ [\"AA\", \"Be\", \"CC\"])\n/// \"my_class.AA\"\nfunc Strongest_Extension(class_name:\
    \ String, extensions: [String]) -> String {\n  var strongest = 0.0\n  var strongest_index\
    \ = 0\n  for (index, ext) in extensions.enumerated() {\n    let cap = ext.filter{$0.isUppercase}.count\n\
    \    let sm = ext.filter{$0.isLowercase}.count\n    let fraction = Double(cap)\
    \ - Double(sm)\n    if fraction > strongest {\n      strongest = fraction\n  \
    \    strongest_index = index\n    }\n  }\n  return \"\\(class_name).\\(extensions[strongest_index])\"\
    \n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(Strongest_Extension(class_name: \"Watashi\", extensions:\
    \ [\"tEN\", \"niNE\", \"eIGHt8OKe\"]) == \"Watashi.eIGHt8OKe\")\nassert(Strongest_Extension(class_name:\
    \ \"Boku123\", extensions: [\"nani\", \"NazeDa\", \"YEs.WeCaNe\", \"32145tggg\"\
    ]) == \"Boku123.YEs.WeCaNe\")\nassert(Strongest_Extension(class_name: \"__YESIMHERE\"\
    , extensions: [\"t\", \"eMptY\", \"nothing\", \"zeR00\", \"NuLl__\", \"123NoooneB321\"\
    ]) == \"__YESIMHERE.NuLl__\")\nassert(Strongest_Extension(class_name: \"K\", extensions:\
    \ [\"Ta\", \"TAR\", \"t234An\", \"cosSo\"]) == \"K.TAR\")\nassert(Strongest_Extension(class_name:\
    \ \"__HAHA\", extensions: [\"Tab\", \"123\", \"781345\", \"-_-\"]) == \"__HAHA.123\"\
    )\nassert(Strongest_Extension(class_name: \"YameRore\", extensions: [\"HhAas\"\
    , \"okIWILL123\", \"WorkOut\", \"Fails\", \"-_-\"]) == \"YameRore.okIWILL123\"\
    )\nassert(Strongest_Extension(class_name: \"finNNalLLly\", extensions: [\"Die\"\
    , \"NowW\", \"Wow\", \"WoW\"]) == \"finNNalLLly.WoW\")\nassert(Strongest_Extension(class_name:\
    \ \"_\", extensions: [\"Bb\", \"91245\"]) == \"_.Bb\")\nassert(Strongest_Extension(class_name:\
    \ \"Sp\", extensions: [\"671235\", \"Bb\"]) == \"Sp.671235\")"
  status: Exception
  stderr: 'tmpjmsk66h5/tmpjmsk66h5.swift:48: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002ab77f162c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002ab77ee59b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002ab77ee59988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002ab77ee587b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpjmsk66h5                        0x00005639711a604c <unavailable> + 8268

    5    libc.so.6                          0x00002ab77f34e460 __libc_start_main +
    245

    6    tmpjmsk66h5                        0x00005639711a5759 <unavailable> + 5977

    '
  stdout: ''
  timestamp: 1660009432
- exit_code: -4
  program: "\n/// You will be given the name of a class (a string) and an array of\
    \ extensions.\n/// The extensions are to be used to load additional classes to\
    \ the class. The\n/// strength of the extension is as follows: Let CAP be the\
    \ number of the uppercase\n/// letters in the extension's name, and let SM be\
    \ the number of lowercase letters \n/// in the extension's name, the strength\
    \ is given by the fraction CAP - SM. \n/// You should find the strongest extension\
    \ and return a string in this \n/// format: ClassName.StrongestExtensionName.\n\
    /// If there are two or more extensions with the same strength, you should\n///\
    \ choose the one that comes first in the array.\n/// For example, if you are given\
    \ \"Slices\" as the class and an array of the\n/// extensions: ['SErviNGSliCes',\
    \ 'Cheese', 'StuFfed'] then you should\n/// return 'Slices.SErviNGSliCes' since\
    \ 'SErviNGSliCes' is the strongest extension \n/// (its strength is -1).\n///\
    \ Example:\n/// >>> Strongest_Extension(class_name: \"my_class\", extensions:\
    \ [\"AA\", \"Be\", \"CC\"])\n/// \"my_class.AA\"\nfunc Strongest_Extension(class_name:\
    \ String, extensions: [String]) -> String {\n    var strongest_extension: String\
    \ = \"\"\n    var strongest_extension_strength: Double = 0.0\n    var index: Int\
    \ = 0\n    while index < extensions.count {\n        var extension_name: String\
    \ = extensions[index]\n        var capital_count: Int = 0\n        var small_count:\
    \ Int = 0\n        for letter in extension_name {\n            if letter.isUppercase\
    \ {\n                capital_count += 1\n            } else {\n              \
    \  small_count += 1\n            }\n        }\n        var extension_strength:\
    \ Double = Double(capital_count) - Double(small_count)\n        if extension_strength\
    \ > strongest_extension_strength {\n            strongest_extension = extension_name\n\
    \            strongest_extension_strength = extension_strength\n        }\n  \
    \      index += 1\n    }\n    return \"\\(class_name).\\(strongest_extension)\"\
    \n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(Strongest_Extension(class_name: \"Watashi\", extensions:\
    \ [\"tEN\", \"niNE\", \"eIGHt8OKe\"]) == \"Watashi.eIGHt8OKe\")\nassert(Strongest_Extension(class_name:\
    \ \"Boku123\", extensions: [\"nani\", \"NazeDa\", \"YEs.WeCaNe\", \"32145tggg\"\
    ]) == \"Boku123.YEs.WeCaNe\")\nassert(Strongest_Extension(class_name: \"__YESIMHERE\"\
    , extensions: [\"t\", \"eMptY\", \"nothing\", \"zeR00\", \"NuLl__\", \"123NoooneB321\"\
    ]) == \"__YESIMHERE.NuLl__\")\nassert(Strongest_Extension(class_name: \"K\", extensions:\
    \ [\"Ta\", \"TAR\", \"t234An\", \"cosSo\"]) == \"K.TAR\")\nassert(Strongest_Extension(class_name:\
    \ \"__HAHA\", extensions: [\"Tab\", \"123\", \"781345\", \"-_-\"]) == \"__HAHA.123\"\
    )\nassert(Strongest_Extension(class_name: \"YameRore\", extensions: [\"HhAas\"\
    , \"okIWILL123\", \"WorkOut\", \"Fails\", \"-_-\"]) == \"YameRore.okIWILL123\"\
    )\nassert(Strongest_Extension(class_name: \"finNNalLLly\", extensions: [\"Die\"\
    , \"NowW\", \"Wow\", \"WoW\"]) == \"finNNalLLly.WoW\")\nassert(Strongest_Extension(class_name:\
    \ \"_\", extensions: [\"Bb\", \"91245\"]) == \"_.Bb\")\nassert(Strongest_Extension(class_name:\
    \ \"Sp\", extensions: [\"671235\", \"Bb\"]) == \"Sp.671235\")"
  status: Exception
  stderr: 'tmp9w3x6jdg/tmp9w3x6jdg.swift:56: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b90f5c17c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b90f590eb6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b90f590e988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b90f590d7b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmp9w3x6jdg                        0x0000560c4ccd697d <unavailable> + 6525

    5    libc.so.6                          0x00002b90f5e03460 __libc_start_main +
    245

    6    tmp9w3x6jdg                        0x0000560c4ccd6509 <unavailable> + 5385

    '
  stdout: ''
  timestamp: 1660009432
- exit_code: 1
  program: "\n/// You will be given the name of a class (a string) and an array of\
    \ extensions.\n/// The extensions are to be used to load additional classes to\
    \ the class. The\n/// strength of the extension is as follows: Let CAP be the\
    \ number of the uppercase\n/// letters in the extension's name, and let SM be\
    \ the number of lowercase letters \n/// in the extension's name, the strength\
    \ is given by the fraction CAP - SM. \n/// You should find the strongest extension\
    \ and return a string in this \n/// format: ClassName.StrongestExtensionName.\n\
    /// If there are two or more extensions with the same strength, you should\n///\
    \ choose the one that comes first in the array.\n/// For example, if you are given\
    \ \"Slices\" as the class and an array of the\n/// extensions: ['SErviNGSliCes',\
    \ 'Cheese', 'StuFfed'] then you should\n/// return 'Slices.SErviNGSliCes' since\
    \ 'SErviNGSliCes' is the strongest extension \n/// (its strength is -1).\n///\
    \ Example:\n/// >>> Strongest_Extension(class_name: \"my_class\", extensions:\
    \ [\"AA\", \"Be\", \"CC\"])\n/// \"my_class.AA\"\nfunc Strongest_Extension(class_name:\
    \ String, extensions: [String]) -> String {\n    let count_upper = CAP(my_string:\
    \ class_name)\n    let count_lower = SM(my_string: class_name)\n    let fraction\
    \ = Float(count_upper - count_lower)\n    let strongest_extension = extensions.min{CAP(my_string:\
    \ $0) - SM(my_string: $0) < CAP(my_string: $1) - SM(my_string: $1)}\n    return\
    \ \"\\(class_name).\\(strongest_extension!)\"\n}\n\n\nfunc ==(left: [(Int, Int)],\
    \ right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n       \
    \ return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r\
    \ {\n            return false\n        }\n    }\n    return true\n}\n        \
    \    \nassert(Strongest_Extension(class_name: \"Watashi\", extensions: [\"tEN\"\
    , \"niNE\", \"eIGHt8OKe\"]) == \"Watashi.eIGHt8OKe\")\nassert(Strongest_Extension(class_name:\
    \ \"Boku123\", extensions: [\"nani\", \"NazeDa\", \"YEs.WeCaNe\", \"32145tggg\"\
    ]) == \"Boku123.YEs.WeCaNe\")\nassert(Strongest_Extension(class_name: \"__YESIMHERE\"\
    , extensions: [\"t\", \"eMptY\", \"nothing\", \"zeR00\", \"NuLl__\", \"123NoooneB321\"\
    ]) == \"__YESIMHERE.NuLl__\")\nassert(Strongest_Extension(class_name: \"K\", extensions:\
    \ [\"Ta\", \"TAR\", \"t234An\", \"cosSo\"]) == \"K.TAR\")\nassert(Strongest_Extension(class_name:\
    \ \"__HAHA\", extensions: [\"Tab\", \"123\", \"781345\", \"-_-\"]) == \"__HAHA.123\"\
    )\nassert(Strongest_Extension(class_name: \"YameRore\", extensions: [\"HhAas\"\
    , \"okIWILL123\", \"WorkOut\", \"Fails\", \"-_-\"]) == \"YameRore.okIWILL123\"\
    )\nassert(Strongest_Extension(class_name: \"finNNalLLly\", extensions: [\"Die\"\
    , \"NowW\", \"Wow\", \"WoW\"]) == \"finNNalLLly.WoW\")\nassert(Strongest_Extension(class_name:\
    \ \"_\", extensions: [\"Bb\", \"91245\"]) == \"_.Bb\")\nassert(Strongest_Extension(class_name:\
    \ \"Sp\", extensions: [\"671235\", \"Bb\"]) == \"Sp.671235\")"
  status: SyntaxError
  stderr: "/tmp/tmp0c0s_psi.swift:19:23: error: cannot find 'CAP' in scope\n    let\
    \ count_upper = CAP(my_string: class_name)\n                      ^~~\n/tmp/tmp0c0s_psi.swift:20:23:\
    \ error: cannot find 'SM' in scope\n    let count_lower = SM(my_string: class_name)\n\
    \                      ^~\n/tmp/tmp0c0s_psi.swift:21:20: error: no exact matches\
    \ in call to initializer \n    let fraction = Float(count_upper - count_lower)\n\
    \                   ^\n/tmp/tmp0c0s_psi.swift:21:20: note: found candidate with\
    \ type '(Builtin.FPIEEE32) -> Float'\n    let fraction = Float(count_upper - count_lower)\n\
    \                   ^\n/tmp/tmp0c0s_psi.swift:21:20: note: found candidate with\
    \ type '(Substring) -> Float?'\n    let fraction = Float(count_upper - count_lower)\n\
    \                   ^\n/tmp/tmp0c0s_psi.swift:21:20: note: found candidate with\
    \ type '(Int) -> Float'\n    let fraction = Float(count_upper - count_lower)\n\
    \                   ^\n/tmp/tmp0c0s_psi.swift:21:20: note: found candidate with\
    \ type '(Float16) -> Float'\n    let fraction = Float(count_upper - count_lower)\n\
    \                   ^\n/tmp/tmp0c0s_psi.swift:21:20: note: found candidate with\
    \ type '(Float) -> Float'\n    let fraction = Float(count_upper - count_lower)\n\
    \                   ^\n/tmp/tmp0c0s_psi.swift:21:20: note: found candidate with\
    \ type '(Double) -> Float'\n    let fraction = Float(count_upper - count_lower)\n\
    \                   ^\n/tmp/tmp0c0s_psi.swift:21:20: note: found candidate with\
    \ type '(Float80) -> Float'\n    let fraction = Float(count_upper - count_lower)\n\
    \                   ^\n/tmp/tmp0c0s_psi.swift:22:46: error: cannot find 'CAP'\
    \ in scope\n    let strongest_extension = extensions.min{CAP(my_string: $0) -\
    \ SM(my_string: $0) < CAP(my_string: $1) - SM(my_string: $1)}\n              \
    \                               ^~~\n/tmp/tmp0c0s_psi.swift:22:67: error: cannot\
    \ find 'SM' in scope\n    let strongest_extension = extensions.min{CAP(my_string:\
    \ $0) - SM(my_string: $0) < CAP(my_string: $1) - SM(my_string: $1)}\n        \
    \                                                          ^~\n/tmp/tmp0c0s_psi.swift:22:87"
  stdout: ''
  timestamp: 1660009432
- exit_code: -4
  program: "\n/// You will be given the name of a class (a string) and an array of\
    \ extensions.\n/// The extensions are to be used to load additional classes to\
    \ the class. The\n/// strength of the extension is as follows: Let CAP be the\
    \ number of the uppercase\n/// letters in the extension's name, and let SM be\
    \ the number of lowercase letters \n/// in the extension's name, the strength\
    \ is given by the fraction CAP - SM. \n/// You should find the strongest extension\
    \ and return a string in this \n/// format: ClassName.StrongestExtensionName.\n\
    /// If there are two or more extensions with the same strength, you should\n///\
    \ choose the one that comes first in the array.\n/// For example, if you are given\
    \ \"Slices\" as the class and an array of the\n/// extensions: ['SErviNGSliCes',\
    \ 'Cheese', 'StuFfed'] then you should\n/// return 'Slices.SErviNGSliCes' since\
    \ 'SErviNGSliCes' is the strongest extension \n/// (its strength is -1).\n///\
    \ Example:\n/// >>> Strongest_Extension(class_name: \"my_class\", extensions:\
    \ [\"AA\", \"Be\", \"CC\"])\n/// \"my_class.AA\"\nfunc Strongest_Extension(class_name:\
    \ String, extensions: [String]) -> String {\n    var temp_strongest = -10\n  \
    \  var temp_strongest_ext = \"\"\n    for ext in extensions {\n        var uppercase_letters\
    \ = 0\n        var lowercase_letters = 0\n        for character in ext {\n   \
    \         if character.isUppercase {\n                uppercase_letters += 1\n\
    \            } else {\n                lowercase_letters += 1\n            }\n\
    \        }\n        let temp_ext_strength = uppercase_letters - lowercase_letters\n\
    \        if temp_ext_strength > temp_strongest {\n            temp_strongest =\
    \ temp_ext_strength\n            temp_strongest_ext = ext\n        }\n    }\n\
    \    return class_name + \".\" + temp_strongest_ext\n}\n\n\nfunc ==(left: [(Int,\
    \ Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n\
    \        return false\n    }\n    for (l, r) in zip(left, right) {\n        if\
    \ l != r {\n            return false\n        }\n    }\n    return true\n}\n \
    \           \nassert(Strongest_Extension(class_name: \"Watashi\", extensions:\
    \ [\"tEN\", \"niNE\", \"eIGHt8OKe\"]) == \"Watashi.eIGHt8OKe\")\nassert(Strongest_Extension(class_name:\
    \ \"Boku123\", extensions: [\"nani\", \"NazeDa\", \"YEs.WeCaNe\", \"32145tggg\"\
    ]) == \"Boku123.YEs.WeCaNe\")\nassert(Strongest_Extension(class_name: \"__YESIMHERE\"\
    , extensions: [\"t\", \"eMptY\", \"nothing\", \"zeR00\", \"NuLl__\", \"123NoooneB321\"\
    ]) == \"__YESIMHERE.NuLl__\")\nassert(Strongest_Extension(class_name: \"K\", extensions:\
    \ [\"Ta\", \"TAR\", \"t234An\", \"cosSo\"]) == \"K.TAR\")\nassert(Strongest_Extension(class_name:\
    \ \"__HAHA\", extensions: [\"Tab\", \"123\", \"781345\", \"-_-\"]) == \"__HAHA.123\"\
    )\nassert(Strongest_Extension(class_name: \"YameRore\", extensions: [\"HhAas\"\
    , \"okIWILL123\", \"WorkOut\", \"Fails\", \"-_-\"]) == \"YameRore.okIWILL123\"\
    )\nassert(Strongest_Extension(class_name: \"finNNalLLly\", extensions: [\"Die\"\
    , \"NowW\", \"Wow\", \"WoW\"]) == \"finNNalLLly.WoW\")\nassert(Strongest_Extension(class_name:\
    \ \"_\", extensions: [\"Bb\", \"91245\"]) == \"_.Bb\")\nassert(Strongest_Extension(class_name:\
    \ \"Sp\", extensions: [\"671235\", \"Bb\"]) == \"Sp.671235\")"
  status: Exception
  stderr: 'tmp0uibhgvn/tmp0uibhgvn.swift:53: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b44bfb48c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b44bf83fb6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b44bf83f988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b44bf83e7b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmp0uibhgvn                        0x00005648a51647cd <unavailable> + 6093

    5    libc.so.6                          0x00002b44bfd34460 __libc_start_main +
    245

    6    tmp0uibhgvn                        0x00005648a5164359 <unavailable> + 4953

    '
  stdout: ''
  timestamp: 1660009432
- exit_code: 1
  program: "\n/// You will be given the name of a class (a string) and an array of\
    \ extensions.\n/// The extensions are to be used to load additional classes to\
    \ the class. The\n/// strength of the extension is as follows: Let CAP be the\
    \ number of the uppercase\n/// letters in the extension's name, and let SM be\
    \ the number of lowercase letters \n/// in the extension's name, the strength\
    \ is given by the fraction CAP - SM. \n/// You should find the strongest extension\
    \ and return a string in this \n/// format: ClassName.StrongestExtensionName.\n\
    /// If there are two or more extensions with the same strength, you should\n///\
    \ choose the one that comes first in the array.\n/// For example, if you are given\
    \ \"Slices\" as the class and an array of the\n/// extensions: ['SErviNGSliCes',\
    \ 'Cheese', 'StuFfed'] then you should\n/// return 'Slices.SErviNGSliCes' since\
    \ 'SErviNGSliCes' is the strongest extension \n/// (its strength is -1).\n///\
    \ Example:\n/// >>> Strongest_Extension(class_name: \"my_class\", extensions:\
    \ [\"AA\", \"Be\", \"CC\"])\n/// \"my_class.AA\"\nfunc Strongest_Extension(class_name:\
    \ String, extensions: [String]) -> String {\n    var strongest: String = \"\"\n\
    \    var strength: Double = 0\n    var name: String = \"\"\n    var cap: Int =\
    \ 0\n    var sm: Int = 0\n    for i in extensions {\n        name = i\n      \
    \  cap = count_caps(word: name)\n        sm = count_small(word: name)\n      \
    \  if (Double(cap) - Double(sm)) > strength {\n            strength = Double(cap)\
    \ - Double(sm)\n            strongest = name\n        }\n    }\n    return \"\\\
    (class_name).\\(strongest)\"\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int,\
    \ Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n\
    \    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n          \
    \  return false\n        }\n    }\n    return true\n}\n            \nassert(Strongest_Extension(class_name:\
    \ \"Watashi\", extensions: [\"tEN\", \"niNE\", \"eIGHt8OKe\"]) == \"Watashi.eIGHt8OKe\"\
    )\nassert(Strongest_Extension(class_name: \"Boku123\", extensions: [\"nani\",\
    \ \"NazeDa\", \"YEs.WeCaNe\", \"32145tggg\"]) == \"Boku123.YEs.WeCaNe\")\nassert(Strongest_Extension(class_name:\
    \ \"__YESIMHERE\", extensions: [\"t\", \"eMptY\", \"nothing\", \"zeR00\", \"NuLl__\"\
    , \"123NoooneB321\"]) == \"__YESIMHERE.NuLl__\")\nassert(Strongest_Extension(class_name:\
    \ \"K\", extensions: [\"Ta\", \"TAR\", \"t234An\", \"cosSo\"]) == \"K.TAR\")\n\
    assert(Strongest_Extension(class_name: \"__HAHA\", extensions: [\"Tab\", \"123\"\
    , \"781345\", \"-_-\"]) == \"__HAHA.123\")\nassert(Strongest_Extension(class_name:\
    \ \"YameRore\", extensions: [\"HhAas\", \"okIWILL123\", \"WorkOut\", \"Fails\"\
    , \"-_-\"]) == \"YameRore.okIWILL123\")\nassert(Strongest_Extension(class_name:\
    \ \"finNNalLLly\", extensions: [\"Die\", \"NowW\", \"Wow\", \"WoW\"]) == \"finNNalLLly.WoW\"\
    )\nassert(Strongest_Extension(class_name: \"_\", extensions: [\"Bb\", \"91245\"\
    ]) == \"_.Bb\")\nassert(Strongest_Extension(class_name: \"Sp\", extensions: [\"\
    671235\", \"Bb\"]) == \"Sp.671235\")"
  status: SyntaxError
  stderr: "/tmp/tmprlo09u_n.swift:26:15: error: cannot find 'count_caps' in scope\n\
    \        cap = count_caps(word: name)\n              ^~~~~~~~~~\n/tmp/tmprlo09u_n.swift:27:14:\
    \ error: cannot find 'count_small' in scope\n        sm = count_small(word: name)\n\
    \             ^~~~~~~~~~~\n"
  stdout: ''
  timestamp: 1660009432
- exit_code: 1
  program: "\n/// You will be given the name of a class (a string) and an array of\
    \ extensions.\n/// The extensions are to be used to load additional classes to\
    \ the class. The\n/// strength of the extension is as follows: Let CAP be the\
    \ number of the uppercase\n/// letters in the extension's name, and let SM be\
    \ the number of lowercase letters \n/// in the extension's name, the strength\
    \ is given by the fraction CAP - SM. \n/// You should find the strongest extension\
    \ and return a string in this \n/// format: ClassName.StrongestExtensionName.\n\
    /// If there are two or more extensions with the same strength, you should\n///\
    \ choose the one that comes first in the array.\n/// For example, if you are given\
    \ \"Slices\" as the class and an array of the\n/// extensions: ['SErviNGSliCes',\
    \ 'Cheese', 'StuFfed'] then you should\n/// return 'Slices.SErviNGSliCes' since\
    \ 'SErviNGSliCes' is the strongest extension \n/// (its strength is -1).\n///\
    \ Example:\n/// >>> Strongest_Extension(class_name: \"my_class\", extensions:\
    \ [\"AA\", \"Be\", \"CC\"])\n/// \"my_class.AA\"\nfunc Strongest_Extension(class_name:\
    \ String, extensions: [String]) -> String {\n    var strongest_extension = \"\"\
    \n    var strongest_strength = 0.0\n    for extension_name in extensions {\n \
    \       let strength = Double(extension_name.count { $0.isUppercase }) - Double(extension_name.count\
    \ { $0.isLowercase })\n        if strength > strongest_strength {\n          \
    \  strongest_strength = strength\n            strongest_extension = extension_name\n\
    \        }\n    }\n    return \"\\(class_name).\\(strongest_extension)\"\n}\n\n\
    \nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(Strongest_Extension(class_name: \"Watashi\", extensions:\
    \ [\"tEN\", \"niNE\", \"eIGHt8OKe\"]) == \"Watashi.eIGHt8OKe\")\nassert(Strongest_Extension(class_name:\
    \ \"Boku123\", extensions: [\"nani\", \"NazeDa\", \"YEs.WeCaNe\", \"32145tggg\"\
    ]) == \"Boku123.YEs.WeCaNe\")\nassert(Strongest_Extension(class_name: \"__YESIMHERE\"\
    , extensions: [\"t\", \"eMptY\", \"nothing\", \"zeR00\", \"NuLl__\", \"123NoooneB321\"\
    ]) == \"__YESIMHERE.NuLl__\")\nassert(Strongest_Extension(class_name: \"K\", extensions:\
    \ [\"Ta\", \"TAR\", \"t234An\", \"cosSo\"]) == \"K.TAR\")\nassert(Strongest_Extension(class_name:\
    \ \"__HAHA\", extensions: [\"Tab\", \"123\", \"781345\", \"-_-\"]) == \"__HAHA.123\"\
    )\nassert(Strongest_Extension(class_name: \"YameRore\", extensions: [\"HhAas\"\
    , \"okIWILL123\", \"WorkOut\", \"Fails\", \"-_-\"]) == \"YameRore.okIWILL123\"\
    )\nassert(Strongest_Extension(class_name: \"finNNalLLly\", extensions: [\"Die\"\
    , \"NowW\", \"Wow\", \"WoW\"]) == \"finNNalLLly.WoW\")\nassert(Strongest_Extension(class_name:\
    \ \"_\", extensions: [\"Bb\", \"91245\"]) == \"_.Bb\")\nassert(Strongest_Extension(class_name:\
    \ \"Sp\", extensions: [\"671235\", \"Bb\"]) == \"Sp.671235\")"
  status: SyntaxError
  stderr: "/tmp/tmp6z7qz7k6.swift:22:46: error: cannot call value of non-function\
    \ type 'Int'\n        let strength = Double(extension_name.count { $0.isUppercase\
    \ }) - Double(extension_name.count { $0.isLowercase })\n                     \
    \                        ^\n/tmp/tmp6z7qz7k6.swift:22:96: error: cannot call value\
    \ of non-function type 'Int'\n        let strength = Double(extension_name.count\
    \ { $0.isUppercase }) - Double(extension_name.count { $0.isLowercase })\n    \
    \                                                                            \
    \               ^\n"
  stdout: ''
  timestamp: 1660009432
- exit_code: 1
  program: "\n/// You will be given the name of a class (a string) and an array of\
    \ extensions.\n/// The extensions are to be used to load additional classes to\
    \ the class. The\n/// strength of the extension is as follows: Let CAP be the\
    \ number of the uppercase\n/// letters in the extension's name, and let SM be\
    \ the number of lowercase letters \n/// in the extension's name, the strength\
    \ is given by the fraction CAP - SM. \n/// You should find the strongest extension\
    \ and return a string in this \n/// format: ClassName.StrongestExtensionName.\n\
    /// If there are two or more extensions with the same strength, you should\n///\
    \ choose the one that comes first in the array.\n/// For example, if you are given\
    \ \"Slices\" as the class and an array of the\n/// extensions: ['SErviNGSliCes',\
    \ 'Cheese', 'StuFfed'] then you should\n/// return 'Slices.SErviNGSliCes' since\
    \ 'SErviNGSliCes' is the strongest extension \n/// (its strength is -1).\n///\
    \ Example:\n/// >>> Strongest_Extension(class_name: \"my_class\", extensions:\
    \ [\"AA\", \"Be\", \"CC\"])\n/// \"my_class.AA\"\nfunc Strongest_Extension(class_name:\
    \ String, extensions: [String]) -> String {\n    var strength = 0\n    var strong_class\
    \ = \"\"\n    for extension in extensions {\n        let extension_str = extension.components(separatedBy:\
    \ CharacterSet.uppercaseLetters)\n        let extension_cap = extension.components(separatedBy:\
    \ CharacterSet.lowercaseLetters)\n        if (extension_str.count - extension_cap.count)\
    \ > strength {\n            strength = extension_str.count - extension_cap.count\n\
    \            strong_class = extension\n        }\n    }\n    return \"\\(class_name).\\\
    (strong_class)\"\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool\
    \ {\n    if left.count != right.count {\n        return false\n    }\n    for\
    \ (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(Strongest_Extension(class_name:\
    \ \"Watashi\", extensions: [\"tEN\", \"niNE\", \"eIGHt8OKe\"]) == \"Watashi.eIGHt8OKe\"\
    )\nassert(Strongest_Extension(class_name: \"Boku123\", extensions: [\"nani\",\
    \ \"NazeDa\", \"YEs.WeCaNe\", \"32145tggg\"]) == \"Boku123.YEs.WeCaNe\")\nassert(Strongest_Extension(class_name:\
    \ \"__YESIMHERE\", extensions: [\"t\", \"eMptY\", \"nothing\", \"zeR00\", \"NuLl__\"\
    , \"123NoooneB321\"]) == \"__YESIMHERE.NuLl__\")\nassert(Strongest_Extension(class_name:\
    \ \"K\", extensions: [\"Ta\", \"TAR\", \"t234An\", \"cosSo\"]) == \"K.TAR\")\n\
    assert(Strongest_Extension(class_name: \"__HAHA\", extensions: [\"Tab\", \"123\"\
    , \"781345\", \"-_-\"]) == \"__HAHA.123\")\nassert(Strongest_Extension(class_name:\
    \ \"YameRore\", extensions: [\"HhAas\", \"okIWILL123\", \"WorkOut\", \"Fails\"\
    , \"-_-\"]) == \"YameRore.okIWILL123\")\nassert(Strongest_Extension(class_name:\
    \ \"finNNalLLly\", extensions: [\"Die\", \"NowW\", \"Wow\", \"WoW\"]) == \"finNNalLLly.WoW\"\
    )\nassert(Strongest_Extension(class_name: \"_\", extensions: [\"Bb\", \"91245\"\
    ]) == \"_.Bb\")\nassert(Strongest_Extension(class_name: \"Sp\", extensions: [\"\
    671235\", \"Bb\"]) == \"Sp.671235\")"
  status: SyntaxError
  stderr: "/tmp/tmp6jbw2e5i.swift:21:9: error: expected pattern\n    for extension\
    \ in extensions {\n        ^\n/tmp/tmp6jbw2e5i.swift:21:9: error: expected Sequence\
    \ expression for for-each loop\n    for extension in extensions {\n        ^\n\
    /tmp/tmp6jbw2e5i.swift:21:9: error: expected '{' to start the body of for-each\
    \ loop\n    for extension in extensions {\n        ^\n/tmp/tmp6jbw2e5i.swift:22:29:\
    \ error: expected initial value after '='\n        let extension_str = extension.components(separatedBy:\
    \ CharacterSet.uppercaseLetters)\n                            ^\n/tmp/tmp6jbw2e5i.swift:22:28:\
    \ error: consecutive statements on a line must be separated by ';'\n        let\
    \ extension_str = extension.components(separatedBy: CharacterSet.uppercaseLetters)\n\
    \                           ^\n                           ;\n/tmp/tmp6jbw2e5i.swift:22:38:\
    \ error: expected type name in extension declaration\n        let extension_str\
    \ = extension.components(separatedBy: CharacterSet.uppercaseLetters)\n       \
    \                              ^\n/tmp/tmp6jbw2e5i.swift:22:38: error: expected\
    \ '{' in extension\n        let extension_str = extension.components(separatedBy:\
    \ CharacterSet.uppercaseLetters)\n                                     ^\n/tmp/tmp6jbw2e5i.swift:22:29:\
    \ error: declaration is only valid at file scope\n        let extension_str =\
    \ extension.components(separatedBy: CharacterSet.uppercaseLetters)\n         \
    \                   ^\n/tmp/tmp6jbw2e5i.swift:23:29: error: expected initial value\
    \ after '='\n        let extension_cap = extension.components(separatedBy: CharacterSet.lowercaseLetters)\n\
    \                            ^\n/tmp/tmp6jbw2e5i.swift:23:28: error: consecutive\
    \ statements on a line must be separated by ';'\n        let extension_cap = extension.components(separatedBy:\
    \ CharacterSet.lowercaseLetters)\n                           ^\n             \
    \              ;\n/tmp/tmp6jbw2e5i.swift:23:38: error: expected type name in extension\
    \ declaration\n        let extension_cap = extension.components(separatedBy: CharacterSet.lowercaseLetters)\n\
    \                                    "
  stdout: ''
  timestamp: 1660009432
- exit_code: 1
  program: "\n/// You will be given the name of a class (a string) and an array of\
    \ extensions.\n/// The extensions are to be used to load additional classes to\
    \ the class. The\n/// strength of the extension is as follows: Let CAP be the\
    \ number of the uppercase\n/// letters in the extension's name, and let SM be\
    \ the number of lowercase letters \n/// in the extension's name, the strength\
    \ is given by the fraction CAP - SM. \n/// You should find the strongest extension\
    \ and return a string in this \n/// format: ClassName.StrongestExtensionName.\n\
    /// If there are two or more extensions with the same strength, you should\n///\
    \ choose the one that comes first in the array.\n/// For example, if you are given\
    \ \"Slices\" as the class and an array of the\n/// extensions: ['SErviNGSliCes',\
    \ 'Cheese', 'StuFfed'] then you should\n/// return 'Slices.SErviNGSliCes' since\
    \ 'SErviNGSliCes' is the strongest extension \n/// (its strength is -1).\n///\
    \ Example:\n/// >>> Strongest_Extension(class_name: \"my_class\", extensions:\
    \ [\"AA\", \"Be\", \"CC\"])\n/// \"my_class.AA\"\nfunc Strongest_Extension(class_name:\
    \ String, extensions: [String]) -> String {\n    let ext_strength = extensions.map({\
    \ (extension_name) -> (String, Int) in\n        return (extension_name, extension_name.components(separatedBy:\
    \ CharacterSet.uppercaseLetters).count - extension_name.components(separatedBy:\
    \ CharacterSet.lowercaseLetters).count)\n    })\n    let max_strength = ext_strength.map({$0.1}).max()\n\
    \    let max_strength_extensions = ext_strength.filter({$0.1 == max_strength})\n\
    \    let sorted_extensions = max_strength_extensions.sorted(by: {$0.0 < $1.0})\n\
    \    return \"\\(class_name).\\(sorted_extensions[0].0)\"\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(Strongest_Extension(class_name: \"Watashi\", extensions:\
    \ [\"tEN\", \"niNE\", \"eIGHt8OKe\"]) == \"Watashi.eIGHt8OKe\")\nassert(Strongest_Extension(class_name:\
    \ \"Boku123\", extensions: [\"nani\", \"NazeDa\", \"YEs.WeCaNe\", \"32145tggg\"\
    ]) == \"Boku123.YEs.WeCaNe\")\nassert(Strongest_Extension(class_name: \"__YESIMHERE\"\
    , extensions: [\"t\", \"eMptY\", \"nothing\", \"zeR00\", \"NuLl__\", \"123NoooneB321\"\
    ]) == \"__YESIMHERE.NuLl__\")\nassert(Strongest_Extension(class_name: \"K\", extensions:\
    \ [\"Ta\", \"TAR\", \"t234An\", \"cosSo\"]) == \"K.TAR\")\nassert(Strongest_Extension(class_name:\
    \ \"__HAHA\", extensions: [\"Tab\", \"123\", \"781345\", \"-_-\"]) == \"__HAHA.123\"\
    )\nassert(Strongest_Extension(class_name: \"YameRore\", extensions: [\"HhAas\"\
    , \"okIWILL123\", \"WorkOut\", \"Fails\", \"-_-\"]) == \"YameRore.okIWILL123\"\
    )\nassert(Strongest_Extension(class_name: \"finNNalLLly\", extensions: [\"Die\"\
    , \"NowW\", \"Wow\", \"WoW\"]) == \"finNNalLLly.WoW\")\nassert(Strongest_Extension(class_name:\
    \ \"_\", extensions: [\"Bb\", \"91245\"]) == \"_.Bb\")\nassert(Strongest_Extension(class_name:\
    \ \"Sp\", extensions: [\"671235\", \"Bb\"]) == \"Sp.671235\")"
  status: SyntaxError
  stderr: "/tmp/tmpb1rb30pu.swift:20:72: error: cannot find 'CharacterSet' in scope\n\
    \        return (extension_name, extension_name.components(separatedBy: CharacterSet.uppercaseLetters).count\
    \ - extension_name.components(separatedBy: CharacterSet.lowercaseLetters).count)\n\
    \                                                                       ^~~~~~~~~~~~\n\
    /tmp/tmpb1rb30pu.swift:20:150: error: cannot find 'CharacterSet' in scope\n  \
    \      return (extension_name, extension_name.components(separatedBy: CharacterSet.uppercaseLetters).count\
    \ - extension_name.components(separatedBy: CharacterSet.lowercaseLetters).count)\n\
    \                                                                            \
    \                                                                         ^~~~~~~~~~~~\n"
  stdout: ''
  timestamp: 1660009432
- exit_code: 0
  program: "\n/// You will be given the name of a class (a string) and an array of\
    \ extensions.\n/// The extensions are to be used to load additional classes to\
    \ the class. The\n/// strength of the extension is as follows: Let CAP be the\
    \ number of the uppercase\n/// letters in the extension's name, and let SM be\
    \ the number of lowercase letters \n/// in the extension's name, the strength\
    \ is given by the fraction CAP - SM. \n/// You should find the strongest extension\
    \ and return a string in this \n/// format: ClassName.StrongestExtensionName.\n\
    /// If there are two or more extensions with the same strength, you should\n///\
    \ choose the one that comes first in the array.\n/// For example, if you are given\
    \ \"Slices\" as the class and an array of the\n/// extensions: ['SErviNGSliCes',\
    \ 'Cheese', 'StuFfed'] then you should\n/// return 'Slices.SErviNGSliCes' since\
    \ 'SErviNGSliCes' is the strongest extension \n/// (its strength is -1).\n///\
    \ Example:\n/// >>> Strongest_Extension(class_name: \"my_class\", extensions:\
    \ [\"AA\", \"Be\", \"CC\"])\n/// \"my_class.AA\"\nfunc Strongest_Extension(class_name:\
    \ String, extensions: [String]) -> String {\n    let number_upper = extensions.map({String($0.filter({$0.isUppercase}))})\n\
    \    let number_lower = extensions.map({String($0.filter({$0.isLowercase}))})\n\
    \    let strength = zip(number_upper, number_lower).map({Double($0.count - $1.count)})\n\
    \    let strongest = zip(extensions, strength).sorted(by: {$0.1 > $1.1}).first!.0\n\
    \    return \"\\(class_name).\\(strongest)\"\n}\n\n\nfunc ==(left: [(Int, Int)],\
    \ right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n       \
    \ return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r\
    \ {\n            return false\n        }\n    }\n    return true\n}\n        \
    \    \nassert(Strongest_Extension(class_name: \"Watashi\", extensions: [\"tEN\"\
    , \"niNE\", \"eIGHt8OKe\"]) == \"Watashi.eIGHt8OKe\")\nassert(Strongest_Extension(class_name:\
    \ \"Boku123\", extensions: [\"nani\", \"NazeDa\", \"YEs.WeCaNe\", \"32145tggg\"\
    ]) == \"Boku123.YEs.WeCaNe\")\nassert(Strongest_Extension(class_name: \"__YESIMHERE\"\
    , extensions: [\"t\", \"eMptY\", \"nothing\", \"zeR00\", \"NuLl__\", \"123NoooneB321\"\
    ]) == \"__YESIMHERE.NuLl__\")\nassert(Strongest_Extension(class_name: \"K\", extensions:\
    \ [\"Ta\", \"TAR\", \"t234An\", \"cosSo\"]) == \"K.TAR\")\nassert(Strongest_Extension(class_name:\
    \ \"__HAHA\", extensions: [\"Tab\", \"123\", \"781345\", \"-_-\"]) == \"__HAHA.123\"\
    )\nassert(Strongest_Extension(class_name: \"YameRore\", extensions: [\"HhAas\"\
    , \"okIWILL123\", \"WorkOut\", \"Fails\", \"-_-\"]) == \"YameRore.okIWILL123\"\
    )\nassert(Strongest_Extension(class_name: \"finNNalLLly\", extensions: [\"Die\"\
    , \"NowW\", \"Wow\", \"WoW\"]) == \"finNNalLLly.WoW\")\nassert(Strongest_Extension(class_name:\
    \ \"_\", extensions: [\"Bb\", \"91245\"]) == \"_.Bb\")\nassert(Strongest_Extension(class_name:\
    \ \"Sp\", extensions: [\"671235\", \"Bb\"]) == \"Sp.671235\")"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660009433
- exit_code: -4
  program: "\n/// You will be given the name of a class (a string) and an array of\
    \ extensions.\n/// The extensions are to be used to load additional classes to\
    \ the class. The\n/// strength of the extension is as follows: Let CAP be the\
    \ number of the uppercase\n/// letters in the extension's name, and let SM be\
    \ the number of lowercase letters \n/// in the extension's name, the strength\
    \ is given by the fraction CAP - SM. \n/// You should find the strongest extension\
    \ and return a string in this \n/// format: ClassName.StrongestExtensionName.\n\
    /// If there are two or more extensions with the same strength, you should\n///\
    \ choose the one that comes first in the array.\n/// For example, if you are given\
    \ \"Slices\" as the class and an array of the\n/// extensions: ['SErviNGSliCes',\
    \ 'Cheese', 'StuFfed'] then you should\n/// return 'Slices.SErviNGSliCes' since\
    \ 'SErviNGSliCes' is the strongest extension \n/// (its strength is -1).\n///\
    \ Example:\n/// >>> Strongest_Extension(class_name: \"my_class\", extensions:\
    \ [\"AA\", \"Be\", \"CC\"])\n/// \"my_class.AA\"\nfunc Strongest_Extension(class_name:\
    \ String, extensions: [String]) -> String {\n\tvar strongest_extension = \"\"\n\
    \tvar strongest_extension_value = 0.0\n\tvar current_extension_value = 0.0\n\t\
    \n\tfor extension_name in extensions {\n\t\tcurrent_extension_value = Double(extension_name.filter{\
    \ $0.isUppercase }.count)\n\t\tcurrent_extension_value -= Double(extension_name.filter{\
    \ $0.isLowercase }.count)\n\t\t\n\t\tif strongest_extension_value < current_extension_value\
    \ {\n\t\t\tstrongest_extension_value = current_extension_value\n\t\t\tstrongest_extension\
    \ = extension_name\n\t\t}\n\t}\n\t\n\treturn \"\\(class_name).\\(strongest_extension)\"\
    \n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(Strongest_Extension(class_name: \"Watashi\", extensions:\
    \ [\"tEN\", \"niNE\", \"eIGHt8OKe\"]) == \"Watashi.eIGHt8OKe\")\nassert(Strongest_Extension(class_name:\
    \ \"Boku123\", extensions: [\"nani\", \"NazeDa\", \"YEs.WeCaNe\", \"32145tggg\"\
    ]) == \"Boku123.YEs.WeCaNe\")\nassert(Strongest_Extension(class_name: \"__YESIMHERE\"\
    , extensions: [\"t\", \"eMptY\", \"nothing\", \"zeR00\", \"NuLl__\", \"123NoooneB321\"\
    ]) == \"__YESIMHERE.NuLl__\")\nassert(Strongest_Extension(class_name: \"K\", extensions:\
    \ [\"Ta\", \"TAR\", \"t234An\", \"cosSo\"]) == \"K.TAR\")\nassert(Strongest_Extension(class_name:\
    \ \"__HAHA\", extensions: [\"Tab\", \"123\", \"781345\", \"-_-\"]) == \"__HAHA.123\"\
    )\nassert(Strongest_Extension(class_name: \"YameRore\", extensions: [\"HhAas\"\
    , \"okIWILL123\", \"WorkOut\", \"Fails\", \"-_-\"]) == \"YameRore.okIWILL123\"\
    )\nassert(Strongest_Extension(class_name: \"finNNalLLly\", extensions: [\"Die\"\
    , \"NowW\", \"Wow\", \"WoW\"]) == \"finNNalLLly.WoW\")\nassert(Strongest_Extension(class_name:\
    \ \"_\", extensions: [\"Bb\", \"91245\"]) == \"_.Bb\")\nassert(Strongest_Extension(class_name:\
    \ \"Sp\", extensions: [\"671235\", \"Bb\"]) == \"Sp.671235\")"
  status: Exception
  stderr: 'tmpkx4ve0e_/tmpkx4ve0e_.swift:51: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b65c7e1dc80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b65c7b14b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b65c7b14988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b65c7b137b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpkx4ve0e_                        0x000055eb4d0e4f4c <unavailable> + 8012

    5    libc.so.6                          0x00002b65c8009460 __libc_start_main +
    245

    6    tmpkx4ve0e_                        0x000055eb4d0e4659 <unavailable> + 5721

    '
  stdout: ''
  timestamp: 1660009432
- exit_code: -4
  program: "\n/// You will be given the name of a class (a string) and an array of\
    \ extensions.\n/// The extensions are to be used to load additional classes to\
    \ the class. The\n/// strength of the extension is as follows: Let CAP be the\
    \ number of the uppercase\n/// letters in the extension's name, and let SM be\
    \ the number of lowercase letters \n/// in the extension's name, the strength\
    \ is given by the fraction CAP - SM. \n/// You should find the strongest extension\
    \ and return a string in this \n/// format: ClassName.StrongestExtensionName.\n\
    /// If there are two or more extensions with the same strength, you should\n///\
    \ choose the one that comes first in the array.\n/// For example, if you are given\
    \ \"Slices\" as the class and an array of the\n/// extensions: ['SErviNGSliCes',\
    \ 'Cheese', 'StuFfed'] then you should\n/// return 'Slices.SErviNGSliCes' since\
    \ 'SErviNGSliCes' is the strongest extension \n/// (its strength is -1).\n///\
    \ Example:\n/// >>> Strongest_Extension(class_name: \"my_class\", extensions:\
    \ [\"AA\", \"Be\", \"CC\"])\n/// \"my_class.AA\"\nfunc Strongest_Extension(class_name:\
    \ String, extensions: [String]) -> String {\n    var class_extension = \"\"\n\
    \    var strength = 0\n    var class_extension_strength = 0\n    for (i, ext)\
    \ in extensions.enumerated() {\n        for c in ext {\n            if c.isUppercase\
    \ {\n                strength += 1\n            } else {\n                strength\
    \ -= 1\n            }\n        }\n        if i == 0 {\n            class_extension\
    \ = ext\n            class_extension_strength = strength\n        } else if strength\
    \ > class_extension_strength {\n            class_extension = ext\n          \
    \  class_extension_strength = strength\n        }\n        strength = 0\n    }\n\
    \    return \"\\(class_name).\\(class_extension)\"\n}\n\n\nfunc ==(left: [(Int,\
    \ Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n\
    \        return false\n    }\n    for (l, r) in zip(left, right) {\n        if\
    \ l != r {\n            return false\n        }\n    }\n    return true\n}\n \
    \           \nassert(Strongest_Extension(class_name: \"Watashi\", extensions:\
    \ [\"tEN\", \"niNE\", \"eIGHt8OKe\"]) == \"Watashi.eIGHt8OKe\")\nassert(Strongest_Extension(class_name:\
    \ \"Boku123\", extensions: [\"nani\", \"NazeDa\", \"YEs.WeCaNe\", \"32145tggg\"\
    ]) == \"Boku123.YEs.WeCaNe\")\nassert(Strongest_Extension(class_name: \"__YESIMHERE\"\
    , extensions: [\"t\", \"eMptY\", \"nothing\", \"zeR00\", \"NuLl__\", \"123NoooneB321\"\
    ]) == \"__YESIMHERE.NuLl__\")\nassert(Strongest_Extension(class_name: \"K\", extensions:\
    \ [\"Ta\", \"TAR\", \"t234An\", \"cosSo\"]) == \"K.TAR\")\nassert(Strongest_Extension(class_name:\
    \ \"__HAHA\", extensions: [\"Tab\", \"123\", \"781345\", \"-_-\"]) == \"__HAHA.123\"\
    )\nassert(Strongest_Extension(class_name: \"YameRore\", extensions: [\"HhAas\"\
    , \"okIWILL123\", \"WorkOut\", \"Fails\", \"-_-\"]) == \"YameRore.okIWILL123\"\
    )\nassert(Strongest_Extension(class_name: \"finNNalLLly\", extensions: [\"Die\"\
    , \"NowW\", \"Wow\", \"WoW\"]) == \"finNNalLLly.WoW\")\nassert(Strongest_Extension(class_name:\
    \ \"_\", extensions: [\"Bb\", \"91245\"]) == \"_.Bb\")\nassert(Strongest_Extension(class_name:\
    \ \"Sp\", extensions: [\"671235\", \"Bb\"]) == \"Sp.671235\")"
  status: Exception
  stderr: 'tmpjd24_1i3/tmpjd24_1i3.swift:55: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b3f0a7e9c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b3f0a4e0b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b3f0a4e0988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b3f0a4df7b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpjd24_1i3                        0x000055fada368aed <unavailable> + 6893

    5    libc.so.6                          0x00002b3f0a9d5460 __libc_start_main +
    245

    6    tmpjd24_1i3                        0x000055fada368679 <unavailable> + 5753

    '
  stdout: ''
  timestamp: 1660009432
- exit_code: -4
  program: "\n/// You will be given the name of a class (a string) and an array of\
    \ extensions.\n/// The extensions are to be used to load additional classes to\
    \ the class. The\n/// strength of the extension is as follows: Let CAP be the\
    \ number of the uppercase\n/// letters in the extension's name, and let SM be\
    \ the number of lowercase letters \n/// in the extension's name, the strength\
    \ is given by the fraction CAP - SM. \n/// You should find the strongest extension\
    \ and return a string in this \n/// format: ClassName.StrongestExtensionName.\n\
    /// If there are two or more extensions with the same strength, you should\n///\
    \ choose the one that comes first in the array.\n/// For example, if you are given\
    \ \"Slices\" as the class and an array of the\n/// extensions: ['SErviNGSliCes',\
    \ 'Cheese', 'StuFfed'] then you should\n/// return 'Slices.SErviNGSliCes' since\
    \ 'SErviNGSliCes' is the strongest extension \n/// (its strength is -1).\n///\
    \ Example:\n/// >>> Strongest_Extension(class_name: \"my_class\", extensions:\
    \ [\"AA\", \"Be\", \"CC\"])\n/// \"my_class.AA\"\nfunc Strongest_Extension(class_name:\
    \ String, extensions: [String]) -> String {\n    return \"You should have implemented\
    \ this task\"\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool\
    \ {\n    if left.count != right.count {\n        return false\n    }\n    for\
    \ (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(Strongest_Extension(class_name:\
    \ \"Watashi\", extensions: [\"tEN\", \"niNE\", \"eIGHt8OKe\"]) == \"Watashi.eIGHt8OKe\"\
    )\nassert(Strongest_Extension(class_name: \"Boku123\", extensions: [\"nani\",\
    \ \"NazeDa\", \"YEs.WeCaNe\", \"32145tggg\"]) == \"Boku123.YEs.WeCaNe\")\nassert(Strongest_Extension(class_name:\
    \ \"__YESIMHERE\", extensions: [\"t\", \"eMptY\", \"nothing\", \"zeR00\", \"NuLl__\"\
    , \"123NoooneB321\"]) == \"__YESIMHERE.NuLl__\")\nassert(Strongest_Extension(class_name:\
    \ \"K\", extensions: [\"Ta\", \"TAR\", \"t234An\", \"cosSo\"]) == \"K.TAR\")\n\
    assert(Strongest_Extension(class_name: \"__HAHA\", extensions: [\"Tab\", \"123\"\
    , \"781345\", \"-_-\"]) == \"__HAHA.123\")\nassert(Strongest_Extension(class_name:\
    \ \"YameRore\", extensions: [\"HhAas\", \"okIWILL123\", \"WorkOut\", \"Fails\"\
    , \"-_-\"]) == \"YameRore.okIWILL123\")\nassert(Strongest_Extension(class_name:\
    \ \"finNNalLLly\", extensions: [\"Die\", \"NowW\", \"Wow\", \"WoW\"]) == \"finNNalLLly.WoW\"\
    )\nassert(Strongest_Extension(class_name: \"_\", extensions: [\"Bb\", \"91245\"\
    ]) == \"_.Bb\")\nassert(Strongest_Extension(class_name: \"Sp\", extensions: [\"\
    671235\", \"Bb\"]) == \"Sp.671235\")"
  status: Exception
  stderr: 'tmpquvpu2ud/tmpquvpu2ud.swift:35: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002aebaaaaac80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002aebaa7a1b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002aebaa7a1988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002aebaa7a07b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpquvpu2ud                        0x000055f2a5cdf4fd <unavailable> + 5373

    5    libc.so.6                          0x00002aebaac96460 __libc_start_main +
    245

    6    tmpquvpu2ud                        0x000055f2a5cdf089 <unavailable> + 4233

    '
  stdout: ''
  timestamp: 1660009432
- exit_code: 1
  program: "\n/// You will be given the name of a class (a string) and an array of\
    \ extensions.\n/// The extensions are to be used to load additional classes to\
    \ the class. The\n/// strength of the extension is as follows: Let CAP be the\
    \ number of the uppercase\n/// letters in the extension's name, and let SM be\
    \ the number of lowercase letters \n/// in the extension's name, the strength\
    \ is given by the fraction CAP - SM. \n/// You should find the strongest extension\
    \ and return a string in this \n/// format: ClassName.StrongestExtensionName.\n\
    /// If there are two or more extensions with the same strength, you should\n///\
    \ choose the one that comes first in the array.\n/// For example, if you are given\
    \ \"Slices\" as the class and an array of the\n/// extensions: ['SErviNGSliCes',\
    \ 'Cheese', 'StuFfed'] then you should\n/// return 'Slices.SErviNGSliCes' since\
    \ 'SErviNGSliCes' is the strongest extension \n/// (its strength is -1).\n///\
    \ Example:\n/// >>> Strongest_Extension(class_name: \"my_class\", extensions:\
    \ [\"AA\", \"Be\", \"CC\"])\n/// \"my_class.AA\"\nfunc Strongest_Extension(class_name:\
    \ String, extensions: [String]) -> String {\n    var strongest_extension = extensions[0]\n\
    \    var strongest_strength = Int.min\n    for extension_ in extensions {\n  \
    \      let strength = Strength(extension_: extension_)\n        if strength >\
    \ strongest_strength {\n            strongest_strength = strength\n          \
    \  strongest_extension = extension_\n        }\n    }\n    return \"\\(class_name).\\\
    (strongest_extension)\"\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(Strongest_Extension(class_name:\
    \ \"Watashi\", extensions: [\"tEN\", \"niNE\", \"eIGHt8OKe\"]) == \"Watashi.eIGHt8OKe\"\
    )\nassert(Strongest_Extension(class_name: \"Boku123\", extensions: [\"nani\",\
    \ \"NazeDa\", \"YEs.WeCaNe\", \"32145tggg\"]) == \"Boku123.YEs.WeCaNe\")\nassert(Strongest_Extension(class_name:\
    \ \"__YESIMHERE\", extensions: [\"t\", \"eMptY\", \"nothing\", \"zeR00\", \"NuLl__\"\
    , \"123NoooneB321\"]) == \"__YESIMHERE.NuLl__\")\nassert(Strongest_Extension(class_name:\
    \ \"K\", extensions: [\"Ta\", \"TAR\", \"t234An\", \"cosSo\"]) == \"K.TAR\")\n\
    assert(Strongest_Extension(class_name: \"__HAHA\", extensions: [\"Tab\", \"123\"\
    , \"781345\", \"-_-\"]) == \"__HAHA.123\")\nassert(Strongest_Extension(class_name:\
    \ \"YameRore\", extensions: [\"HhAas\", \"okIWILL123\", \"WorkOut\", \"Fails\"\
    , \"-_-\"]) == \"YameRore.okIWILL123\")\nassert(Strongest_Extension(class_name:\
    \ \"finNNalLLly\", extensions: [\"Die\", \"NowW\", \"Wow\", \"WoW\"]) == \"finNNalLLly.WoW\"\
    )\nassert(Strongest_Extension(class_name: \"_\", extensions: [\"Bb\", \"91245\"\
    ]) == \"_.Bb\")\nassert(Strongest_Extension(class_name: \"Sp\", extensions: [\"\
    671235\", \"Bb\"]) == \"Sp.671235\")"
  status: SyntaxError
  stderr: "/tmp/tmpj2531ke0.swift:22:24: error: cannot find 'Strength' in scope\n\
    \        let strength = Strength(extension_: extension_)\n                   \
    \    ^~~~~~~~\n"
  stdout: ''
  timestamp: 1660009432
- exit_code: 1
  program: "\n/// You will be given the name of a class (a string) and an array of\
    \ extensions.\n/// The extensions are to be used to load additional classes to\
    \ the class. The\n/// strength of the extension is as follows: Let CAP be the\
    \ number of the uppercase\n/// letters in the extension's name, and let SM be\
    \ the number of lowercase letters \n/// in the extension's name, the strength\
    \ is given by the fraction CAP - SM. \n/// You should find the strongest extension\
    \ and return a string in this \n/// format: ClassName.StrongestExtensionName.\n\
    /// If there are two or more extensions with the same strength, you should\n///\
    \ choose the one that comes first in the array.\n/// For example, if you are given\
    \ \"Slices\" as the class and an array of the\n/// extensions: ['SErviNGSliCes',\
    \ 'Cheese', 'StuFfed'] then you should\n/// return 'Slices.SErviNGSliCes' since\
    \ 'SErviNGSliCes' is the strongest extension \n/// (its strength is -1).\n///\
    \ Example:\n/// >>> Strongest_Extension(class_name: \"my_class\", extensions:\
    \ [\"AA\", \"Be\", \"CC\"])\n/// \"my_class.AA\"\nfunc Strongest_Extension(class_name:\
    \ String, extensions: [String]) -> String {\n    var strongest_extension = extensions[0]\n\
    \    var strongest_extension_strength = calculate_strength(extension_name: extensions[0])\n\
    \    for i in 1..<extensions.count {\n        let strength = calculate_strength(extension_name:\
    \ extensions[i])\n        if strength > strongest_extension_strength {\n     \
    \       strongest_extension = extensions[i]\n            strongest_extension_strength\
    \ = strength\n        }\n    }\n    return \"\\(class_name).\\(strongest_extension)\"\
    \n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(Strongest_Extension(class_name: \"Watashi\", extensions:\
    \ [\"tEN\", \"niNE\", \"eIGHt8OKe\"]) == \"Watashi.eIGHt8OKe\")\nassert(Strongest_Extension(class_name:\
    \ \"Boku123\", extensions: [\"nani\", \"NazeDa\", \"YEs.WeCaNe\", \"32145tggg\"\
    ]) == \"Boku123.YEs.WeCaNe\")\nassert(Strongest_Extension(class_name: \"__YESIMHERE\"\
    , extensions: [\"t\", \"eMptY\", \"nothing\", \"zeR00\", \"NuLl__\", \"123NoooneB321\"\
    ]) == \"__YESIMHERE.NuLl__\")\nassert(Strongest_Extension(class_name: \"K\", extensions:\
    \ [\"Ta\", \"TAR\", \"t234An\", \"cosSo\"]) == \"K.TAR\")\nassert(Strongest_Extension(class_name:\
    \ \"__HAHA\", extensions: [\"Tab\", \"123\", \"781345\", \"-_-\"]) == \"__HAHA.123\"\
    )\nassert(Strongest_Extension(class_name: \"YameRore\", extensions: [\"HhAas\"\
    , \"okIWILL123\", \"WorkOut\", \"Fails\", \"-_-\"]) == \"YameRore.okIWILL123\"\
    )\nassert(Strongest_Extension(class_name: \"finNNalLLly\", extensions: [\"Die\"\
    , \"NowW\", \"Wow\", \"WoW\"]) == \"finNNalLLly.WoW\")\nassert(Strongest_Extension(class_name:\
    \ \"_\", extensions: [\"Bb\", \"91245\"]) == \"_.Bb\")\nassert(Strongest_Extension(class_name:\
    \ \"Sp\", extensions: [\"671235\", \"Bb\"]) == \"Sp.671235\")"
  status: SyntaxError
  stderr: "/tmp/tmp9o5mqxj9.swift:20:40: error: cannot find 'calculate_strength' in\
    \ scope\n    var strongest_extension_strength = calculate_strength(extension_name:\
    \ extensions[0])\n                                       ^~~~~~~~~~~~~~~~~~\n\
    /tmp/tmp9o5mqxj9.swift:22:24: error: cannot find 'calculate_strength' in scope\n\
    \        let strength = calculate_strength(extension_name: extensions[i])\n  \
    \                     ^~~~~~~~~~~~~~~~~~\n"
  stdout: ''
  timestamp: 1660009432
- exit_code: -4
  program: "\n/// You will be given the name of a class (a string) and an array of\
    \ extensions.\n/// The extensions are to be used to load additional classes to\
    \ the class. The\n/// strength of the extension is as follows: Let CAP be the\
    \ number of the uppercase\n/// letters in the extension's name, and let SM be\
    \ the number of lowercase letters \n/// in the extension's name, the strength\
    \ is given by the fraction CAP - SM. \n/// You should find the strongest extension\
    \ and return a string in this \n/// format: ClassName.StrongestExtensionName.\n\
    /// If there are two or more extensions with the same strength, you should\n///\
    \ choose the one that comes first in the array.\n/// For example, if you are given\
    \ \"Slices\" as the class and an array of the\n/// extensions: ['SErviNGSliCes',\
    \ 'Cheese', 'StuFfed'] then you should\n/// return 'Slices.SErviNGSliCes' since\
    \ 'SErviNGSliCes' is the strongest extension \n/// (its strength is -1).\n///\
    \ Example:\n/// >>> Strongest_Extension(class_name: \"my_class\", extensions:\
    \ [\"AA\", \"Be\", \"CC\"])\n/// \"my_class.AA\"\nfunc Strongest_Extension(class_name:\
    \ String, extensions: [String]) -> String {\n    var strongest_extension = \"\"\
    , strongest_strength = 0\n    for ext in extensions {\n        var uppercase_count\
    \ = 0, lowercase_count = 0\n        for character in ext {\n            if character.isUppercase\
    \ {\n                uppercase_count += 1\n            } else if character.isLowercase\
    \ {\n                lowercase_count += 1\n            }\n        }\n        let\
    \ strength = uppercase_count - lowercase_count\n        if strength > strongest_strength\
    \ {\n            strongest_strength = strength\n            strongest_extension\
    \ = ext\n        }\n    }\n    return \"\\(class_name).\\(strongest_extension)\"\
    \n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(Strongest_Extension(class_name: \"Watashi\", extensions:\
    \ [\"tEN\", \"niNE\", \"eIGHt8OKe\"]) == \"Watashi.eIGHt8OKe\")\nassert(Strongest_Extension(class_name:\
    \ \"Boku123\", extensions: [\"nani\", \"NazeDa\", \"YEs.WeCaNe\", \"32145tggg\"\
    ]) == \"Boku123.YEs.WeCaNe\")\nassert(Strongest_Extension(class_name: \"__YESIMHERE\"\
    , extensions: [\"t\", \"eMptY\", \"nothing\", \"zeR00\", \"NuLl__\", \"123NoooneB321\"\
    ]) == \"__YESIMHERE.NuLl__\")\nassert(Strongest_Extension(class_name: \"K\", extensions:\
    \ [\"Ta\", \"TAR\", \"t234An\", \"cosSo\"]) == \"K.TAR\")\nassert(Strongest_Extension(class_name:\
    \ \"__HAHA\", extensions: [\"Tab\", \"123\", \"781345\", \"-_-\"]) == \"__HAHA.123\"\
    )\nassert(Strongest_Extension(class_name: \"YameRore\", extensions: [\"HhAas\"\
    , \"okIWILL123\", \"WorkOut\", \"Fails\", \"-_-\"]) == \"YameRore.okIWILL123\"\
    )\nassert(Strongest_Extension(class_name: \"finNNalLLly\", extensions: [\"Die\"\
    , \"NowW\", \"Wow\", \"WoW\"]) == \"finNNalLLly.WoW\")\nassert(Strongest_Extension(class_name:\
    \ \"_\", extensions: [\"Bb\", \"91245\"]) == \"_.Bb\")\nassert(Strongest_Extension(class_name:\
    \ \"Sp\", extensions: [\"671235\", \"Bb\"]) == \"Sp.671235\")"
  status: Exception
  stderr: 'tmp6orozht7/tmp6orozht7.swift:53: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002ade2f451c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002ade2f148b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002ade2f148988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002ade2f1477b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmp6orozht7                        0x0000558b3a1cbf1c <unavailable> + 7964

    5    libc.so.6                          0x00002ade2f63d460 __libc_start_main +
    245

    6    tmp6orozht7                        0x0000558b3a1cb629 <unavailable> + 5673

    '
  stdout: ''
  timestamp: 1660009433
- exit_code: -4
  program: "\n/// You will be given the name of a class (a string) and an array of\
    \ extensions.\n/// The extensions are to be used to load additional classes to\
    \ the class. The\n/// strength of the extension is as follows: Let CAP be the\
    \ number of the uppercase\n/// letters in the extension's name, and let SM be\
    \ the number of lowercase letters \n/// in the extension's name, the strength\
    \ is given by the fraction CAP - SM. \n/// You should find the strongest extension\
    \ and return a string in this \n/// format: ClassName.StrongestExtensionName.\n\
    /// If there are two or more extensions with the same strength, you should\n///\
    \ choose the one that comes first in the array.\n/// For example, if you are given\
    \ \"Slices\" as the class and an array of the\n/// extensions: ['SErviNGSliCes',\
    \ 'Cheese', 'StuFfed'] then you should\n/// return 'Slices.SErviNGSliCes' since\
    \ 'SErviNGSliCes' is the strongest extension \n/// (its strength is -1).\n///\
    \ Example:\n/// >>> Strongest_Extension(class_name: \"my_class\", extensions:\
    \ [\"AA\", \"Be\", \"CC\"])\n/// \"my_class.AA\"\nfunc Strongest_Extension(class_name:\
    \ String, extensions: [String]) -> String {\n    var max_strength = 0.0\n    var\
    \ strongest_extension = \"\"\n    for ext in extensions {\n        let uppers\
    \ = ext.filter { (char) -> Bool in return char.isUppercase }\n        let lowers\
    \ = ext.filter { (char) -> Bool in return char.isLowercase }\n        let strength\
    \ = Double(uppers.count) - Double(lowers.count)\n        if strength > max_strength\
    \ {\n            max_strength = strength\n            strongest_extension = ext\n\
    \        }\n    }\n    return \"\\(class_name).\\(strongest_extension)\"\n}\n\n\
    \nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(Strongest_Extension(class_name: \"Watashi\", extensions:\
    \ [\"tEN\", \"niNE\", \"eIGHt8OKe\"]) == \"Watashi.eIGHt8OKe\")\nassert(Strongest_Extension(class_name:\
    \ \"Boku123\", extensions: [\"nani\", \"NazeDa\", \"YEs.WeCaNe\", \"32145tggg\"\
    ]) == \"Boku123.YEs.WeCaNe\")\nassert(Strongest_Extension(class_name: \"__YESIMHERE\"\
    , extensions: [\"t\", \"eMptY\", \"nothing\", \"zeR00\", \"NuLl__\", \"123NoooneB321\"\
    ]) == \"__YESIMHERE.NuLl__\")\nassert(Strongest_Extension(class_name: \"K\", extensions:\
    \ [\"Ta\", \"TAR\", \"t234An\", \"cosSo\"]) == \"K.TAR\")\nassert(Strongest_Extension(class_name:\
    \ \"__HAHA\", extensions: [\"Tab\", \"123\", \"781345\", \"-_-\"]) == \"__HAHA.123\"\
    )\nassert(Strongest_Extension(class_name: \"YameRore\", extensions: [\"HhAas\"\
    , \"okIWILL123\", \"WorkOut\", \"Fails\", \"-_-\"]) == \"YameRore.okIWILL123\"\
    )\nassert(Strongest_Extension(class_name: \"finNNalLLly\", extensions: [\"Die\"\
    , \"NowW\", \"Wow\", \"WoW\"]) == \"finNNalLLly.WoW\")\nassert(Strongest_Extension(class_name:\
    \ \"_\", extensions: [\"Bb\", \"91245\"]) == \"_.Bb\")\nassert(Strongest_Extension(class_name:\
    \ \"Sp\", extensions: [\"671235\", \"Bb\"]) == \"Sp.671235\")"
  status: Exception
  stderr: 'tmpfe801o0e/tmpfe801o0e.swift:48: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b8300a86c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b830077db6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b830077d988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b830077c7b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpfe801o0e                        0x0000563a85979f4c <unavailable> + 8012

    5    libc.so.6                          0x00002b8300c72460 __libc_start_main +
    245

    6    tmpfe801o0e                        0x0000563a85979659 <unavailable> + 5721

    '
  stdout: ''
  timestamp: 1660009433
- exit_code: -4
  program: "\n/// You will be given the name of a class (a string) and an array of\
    \ extensions.\n/// The extensions are to be used to load additional classes to\
    \ the class. The\n/// strength of the extension is as follows: Let CAP be the\
    \ number of the uppercase\n/// letters in the extension's name, and let SM be\
    \ the number of lowercase letters \n/// in the extension's name, the strength\
    \ is given by the fraction CAP - SM. \n/// You should find the strongest extension\
    \ and return a string in this \n/// format: ClassName.StrongestExtensionName.\n\
    /// If there are two or more extensions with the same strength, you should\n///\
    \ choose the one that comes first in the array.\n/// For example, if you are given\
    \ \"Slices\" as the class and an array of the\n/// extensions: ['SErviNGSliCes',\
    \ 'Cheese', 'StuFfed'] then you should\n/// return 'Slices.SErviNGSliCes' since\
    \ 'SErviNGSliCes' is the strongest extension \n/// (its strength is -1).\n///\
    \ Example:\n/// >>> Strongest_Extension(class_name: \"my_class\", extensions:\
    \ [\"AA\", \"Be\", \"CC\"])\n/// \"my_class.AA\"\nfunc Strongest_Extension(class_name:\
    \ String, extensions: [String]) -> String {\n    var extended_class_name = class_name\n\
    \    var strongest_extension_name = \"\"\n    var extension_strength = Double(0)\n\
    \    for extension_name in extensions {\n        var strength = Double(0)\n  \
    \      for extension_char in extension_name {\n            if extension_char.isUppercase\
    \ {\n                strength += 1\n            } else {\n                strength\
    \ -= 1\n            }\n        }\n        if strength > extension_strength {\n\
    \            extension_strength = strength\n            strongest_extension_name\
    \ = extension_name\n        }\n    }\n    extended_class_name += \".\" + strongest_extension_name\n\
    \    return extended_class_name\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int,\
    \ Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n\
    \    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n          \
    \  return false\n        }\n    }\n    return true\n}\n            \nassert(Strongest_Extension(class_name:\
    \ \"Watashi\", extensions: [\"tEN\", \"niNE\", \"eIGHt8OKe\"]) == \"Watashi.eIGHt8OKe\"\
    )\nassert(Strongest_Extension(class_name: \"Boku123\", extensions: [\"nani\",\
    \ \"NazeDa\", \"YEs.WeCaNe\", \"32145tggg\"]) == \"Boku123.YEs.WeCaNe\")\nassert(Strongest_Extension(class_name:\
    \ \"__YESIMHERE\", extensions: [\"t\", \"eMptY\", \"nothing\", \"zeR00\", \"NuLl__\"\
    , \"123NoooneB321\"]) == \"__YESIMHERE.NuLl__\")\nassert(Strongest_Extension(class_name:\
    \ \"K\", extensions: [\"Ta\", \"TAR\", \"t234An\", \"cosSo\"]) == \"K.TAR\")\n\
    assert(Strongest_Extension(class_name: \"__HAHA\", extensions: [\"Tab\", \"123\"\
    , \"781345\", \"-_-\"]) == \"__HAHA.123\")\nassert(Strongest_Extension(class_name:\
    \ \"YameRore\", extensions: [\"HhAas\", \"okIWILL123\", \"WorkOut\", \"Fails\"\
    , \"-_-\"]) == \"YameRore.okIWILL123\")\nassert(Strongest_Extension(class_name:\
    \ \"finNNalLLly\", extensions: [\"Die\", \"NowW\", \"Wow\", \"WoW\"]) == \"finNNalLLly.WoW\"\
    )\nassert(Strongest_Extension(class_name: \"_\", extensions: [\"Bb\", \"91245\"\
    ]) == \"_.Bb\")\nassert(Strongest_Extension(class_name: \"Sp\", extensions: [\"\
    671235\", \"Bb\"]) == \"Sp.671235\")"
  status: Exception
  stderr: 'tmpllb2lwa4/tmpllb2lwa4.swift:53: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002ba7b0d24c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002ba7b0a1bb6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002ba7b0a1b988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002ba7b0a1a7b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpllb2lwa4                        0x000055cf3a16f81d <unavailable> + 6173

    5    libc.so.6                          0x00002ba7b0f10460 __libc_start_main +
    245

    6    tmpllb2lwa4                        0x000055cf3a16f3a9 <unavailable> + 5033

    '
  stdout: ''
  timestamp: 1660009433
- exit_code: 1
  program: "\n/// You will be given the name of a class (a string) and an array of\
    \ extensions.\n/// The extensions are to be used to load additional classes to\
    \ the class. The\n/// strength of the extension is as follows: Let CAP be the\
    \ number of the uppercase\n/// letters in the extension's name, and let SM be\
    \ the number of lowercase letters \n/// in the extension's name, the strength\
    \ is given by the fraction CAP - SM. \n/// You should find the strongest extension\
    \ and return a string in this \n/// format: ClassName.StrongestExtensionName.\n\
    /// If there are two or more extensions with the same strength, you should\n///\
    \ choose the one that comes first in the array.\n/// For example, if you are given\
    \ \"Slices\" as the class and an array of the\n/// extensions: ['SErviNGSliCes',\
    \ 'Cheese', 'StuFfed'] then you should\n/// return 'Slices.SErviNGSliCes' since\
    \ 'SErviNGSliCes' is the strongest extension \n/// (its strength is -1).\n///\
    \ Example:\n/// >>> Strongest_Extension(class_name: \"my_class\", extensions:\
    \ [\"AA\", \"Be\", \"CC\"])\n/// \"my_class.AA\"\nfunc Strongest_Extension(class_name:\
    \ String, extensions: [String]) -> String {\n    let cap = CharacterSet.uppercaseLetters\n\
    \    let sm = CharacterSet.lowercaseLetters\n    var strongest_extension = \"\"\
    \n    var strongest_strength = 0.0\n    for extension_word in extensions {\n \
    \       var strength = 0.0\n        for letter in extension_word.characters {\n\
    \            if cap.contains(UnicodeScalar(String(letter))!) {\n             \
    \   strength += 1\n            } else if sm.contains(UnicodeScalar(String(letter))!)\
    \ {\n                strength -= 1\n            }\n        }\n        if strength\
    \ >= strongest_strength {\n            strongest_strength = strength\n       \
    \     strongest_extension = extension_word\n        }\n    }\n    return \"\\\
    (class_name).\\(strongest_extension)\"\n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(Strongest_Extension(class_name: \"Watashi\", extensions: [\"tEN\", \"niNE\"\
    , \"eIGHt8OKe\"]) == \"Watashi.eIGHt8OKe\")\nassert(Strongest_Extension(class_name:\
    \ \"Boku123\", extensions: [\"nani\", \"NazeDa\", \"YEs.WeCaNe\", \"32145tggg\"\
    ]) == \"Boku123.YEs.WeCaNe\")\nassert(Strongest_Extension(class_name: \"__YESIMHERE\"\
    , extensions: [\"t\", \"eMptY\", \"nothing\", \"zeR00\", \"NuLl__\", \"123NoooneB321\"\
    ]) == \"__YESIMHERE.NuLl__\")\nassert(Strongest_Extension(class_name: \"K\", extensions:\
    \ [\"Ta\", \"TAR\", \"t234An\", \"cosSo\"]) == \"K.TAR\")\nassert(Strongest_Extension(class_name:\
    \ \"__HAHA\", extensions: [\"Tab\", \"123\", \"781345\", \"-_-\"]) == \"__HAHA.123\"\
    )\nassert(Strongest_Extension(class_name: \"YameRore\", extensions: [\"HhAas\"\
    , \"okIWILL123\", \"WorkOut\", \"Fails\", \"-_-\"]) == \"YameRore.okIWILL123\"\
    )\nassert(Strongest_Extension(class_name: \"finNNalLLly\", extensions: [\"Die\"\
    , \"NowW\", \"Wow\", \"WoW\"]) == \"finNNalLLly.WoW\")\nassert(Strongest_Extension(class_name:\
    \ \"_\", extensions: [\"Bb\", \"91245\"]) == \"_.Bb\")\nassert(Strongest_Extension(class_name:\
    \ \"Sp\", extensions: [\"671235\", \"Bb\"]) == \"Sp.671235\")"
  status: SyntaxError
  stderr: "/tmp/tmp6s0ykdjt.swift:19:15: error: cannot find 'CharacterSet' in scope\n\
    \    let cap = CharacterSet.uppercaseLetters\n              ^~~~~~~~~~~~\n/tmp/tmp6s0ykdjt.swift:20:14:\
    \ error: cannot find 'CharacterSet' in scope\n    let sm = CharacterSet.lowercaseLetters\n\
    \             ^~~~~~~~~~~~\n/tmp/tmp6s0ykdjt.swift:25:38: error: 'characters'\
    \ is unavailable: Please use String directly\n        for letter in extension_word.characters\
    \ {\n                                     ^~~~~~~~~~\nSwift.String:5:16: note:\
    \ 'characters' was obsoleted in Swift 5.0\n    public var characters: String {\
    \ get set }\n               ^\n"
  stdout: ''
  timestamp: 1660009432
- exit_code: -4
  program: "\n/// You will be given the name of a class (a string) and an array of\
    \ extensions.\n/// The extensions are to be used to load additional classes to\
    \ the class. The\n/// strength of the extension is as follows: Let CAP be the\
    \ number of the uppercase\n/// letters in the extension's name, and let SM be\
    \ the number of lowercase letters \n/// in the extension's name, the strength\
    \ is given by the fraction CAP - SM. \n/// You should find the strongest extension\
    \ and return a string in this \n/// format: ClassName.StrongestExtensionName.\n\
    /// If there are two or more extensions with the same strength, you should\n///\
    \ choose the one that comes first in the array.\n/// For example, if you are given\
    \ \"Slices\" as the class and an array of the\n/// extensions: ['SErviNGSliCes',\
    \ 'Cheese', 'StuFfed'] then you should\n/// return 'Slices.SErviNGSliCes' since\
    \ 'SErviNGSliCes' is the strongest extension \n/// (its strength is -1).\n///\
    \ Example:\n/// >>> Strongest_Extension(class_name: \"my_class\", extensions:\
    \ [\"AA\", \"Be\", \"CC\"])\n/// \"my_class.AA\"\nfunc Strongest_Extension(class_name:\
    \ String, extensions: [String]) -> String {\n    return \"\"\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(Strongest_Extension(class_name: \"Watashi\", extensions:\
    \ [\"tEN\", \"niNE\", \"eIGHt8OKe\"]) == \"Watashi.eIGHt8OKe\")\nassert(Strongest_Extension(class_name:\
    \ \"Boku123\", extensions: [\"nani\", \"NazeDa\", \"YEs.WeCaNe\", \"32145tggg\"\
    ]) == \"Boku123.YEs.WeCaNe\")\nassert(Strongest_Extension(class_name: \"__YESIMHERE\"\
    , extensions: [\"t\", \"eMptY\", \"nothing\", \"zeR00\", \"NuLl__\", \"123NoooneB321\"\
    ]) == \"__YESIMHERE.NuLl__\")\nassert(Strongest_Extension(class_name: \"K\", extensions:\
    \ [\"Ta\", \"TAR\", \"t234An\", \"cosSo\"]) == \"K.TAR\")\nassert(Strongest_Extension(class_name:\
    \ \"__HAHA\", extensions: [\"Tab\", \"123\", \"781345\", \"-_-\"]) == \"__HAHA.123\"\
    )\nassert(Strongest_Extension(class_name: \"YameRore\", extensions: [\"HhAas\"\
    , \"okIWILL123\", \"WorkOut\", \"Fails\", \"-_-\"]) == \"YameRore.okIWILL123\"\
    )\nassert(Strongest_Extension(class_name: \"finNNalLLly\", extensions: [\"Die\"\
    , \"NowW\", \"Wow\", \"WoW\"]) == \"finNNalLLly.WoW\")\nassert(Strongest_Extension(class_name:\
    \ \"_\", extensions: [\"Bb\", \"91245\"]) == \"_.Bb\")\nassert(Strongest_Extension(class_name:\
    \ \"Sp\", extensions: [\"671235\", \"Bb\"]) == \"Sp.671235\")"
  status: Exception
  stderr: 'tmpuhmbxdp4/tmpuhmbxdp4.swift:35: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002abeef348c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002abeef03fb6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002abeef03f988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002abeef03e7b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpuhmbxdp4                        0x0000559ee0d614fd <unavailable> + 5373

    5    libc.so.6                          0x00002abeef534460 __libc_start_main +
    245

    6    tmpuhmbxdp4                        0x0000559ee0d61089 <unavailable> + 4233

    '
  stdout: ''
  timestamp: 1660009431
- exit_code: -4
  program: "\n/// You will be given the name of a class (a string) and an array of\
    \ extensions.\n/// The extensions are to be used to load additional classes to\
    \ the class. The\n/// strength of the extension is as follows: Let CAP be the\
    \ number of the uppercase\n/// letters in the extension's name, and let SM be\
    \ the number of lowercase letters \n/// in the extension's name, the strength\
    \ is given by the fraction CAP - SM. \n/// You should find the strongest extension\
    \ and return a string in this \n/// format: ClassName.StrongestExtensionName.\n\
    /// If there are two or more extensions with the same strength, you should\n///\
    \ choose the one that comes first in the array.\n/// For example, if you are given\
    \ \"Slices\" as the class and an array of the\n/// extensions: ['SErviNGSliCes',\
    \ 'Cheese', 'StuFfed'] then you should\n/// return 'Slices.SErviNGSliCes' since\
    \ 'SErviNGSliCes' is the strongest extension \n/// (its strength is -1).\n///\
    \ Example:\n/// >>> Strongest_Extension(class_name: \"my_class\", extensions:\
    \ [\"AA\", \"Be\", \"CC\"])\n/// \"my_class.AA\"\nfunc Strongest_Extension(class_name:\
    \ String, extensions: [String]) -> String {\n    return \"\"\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(Strongest_Extension(class_name: \"Watashi\", extensions:\
    \ [\"tEN\", \"niNE\", \"eIGHt8OKe\"]) == \"Watashi.eIGHt8OKe\")\nassert(Strongest_Extension(class_name:\
    \ \"Boku123\", extensions: [\"nani\", \"NazeDa\", \"YEs.WeCaNe\", \"32145tggg\"\
    ]) == \"Boku123.YEs.WeCaNe\")\nassert(Strongest_Extension(class_name: \"__YESIMHERE\"\
    , extensions: [\"t\", \"eMptY\", \"nothing\", \"zeR00\", \"NuLl__\", \"123NoooneB321\"\
    ]) == \"__YESIMHERE.NuLl__\")\nassert(Strongest_Extension(class_name: \"K\", extensions:\
    \ [\"Ta\", \"TAR\", \"t234An\", \"cosSo\"]) == \"K.TAR\")\nassert(Strongest_Extension(class_name:\
    \ \"__HAHA\", extensions: [\"Tab\", \"123\", \"781345\", \"-_-\"]) == \"__HAHA.123\"\
    )\nassert(Strongest_Extension(class_name: \"YameRore\", extensions: [\"HhAas\"\
    , \"okIWILL123\", \"WorkOut\", \"Fails\", \"-_-\"]) == \"YameRore.okIWILL123\"\
    )\nassert(Strongest_Extension(class_name: \"finNNalLLly\", extensions: [\"Die\"\
    , \"NowW\", \"Wow\", \"WoW\"]) == \"finNNalLLly.WoW\")\nassert(Strongest_Extension(class_name:\
    \ \"_\", extensions: [\"Bb\", \"91245\"]) == \"_.Bb\")\nassert(Strongest_Extension(class_name:\
    \ \"Sp\", extensions: [\"671235\", \"Bb\"]) == \"Sp.671235\")"
  status: Exception
  stderr: 'tmpuhmbxdp4/tmpuhmbxdp4.swift:35: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002abeef348c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002abeef03fb6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002abeef03f988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002abeef03e7b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpuhmbxdp4                        0x0000559ee0d614fd <unavailable> + 5373

    5    libc.so.6                          0x00002abeef534460 __libc_start_main +
    245

    6    tmpuhmbxdp4                        0x0000559ee0d61089 <unavailable> + 4233

    '
  stdout: ''
  timestamp: 1660009431
- exit_code: 1
  program: "\n/// You will be given the name of a class (a string) and an array of\
    \ extensions.\n/// The extensions are to be used to load additional classes to\
    \ the class. The\n/// strength of the extension is as follows: Let CAP be the\
    \ number of the uppercase\n/// letters in the extension's name, and let SM be\
    \ the number of lowercase letters \n/// in the extension's name, the strength\
    \ is given by the fraction CAP - SM. \n/// You should find the strongest extension\
    \ and return a string in this \n/// format: ClassName.StrongestExtensionName.\n\
    /// If there are two or more extensions with the same strength, you should\n///\
    \ choose the one that comes first in the array.\n/// For example, if you are given\
    \ \"Slices\" as the class and an array of the\n/// extensions: ['SErviNGSliCes',\
    \ 'Cheese', 'StuFfed'] then you should\n/// return 'Slices.SErviNGSliCes' since\
    \ 'SErviNGSliCes' is the strongest extension \n/// (its strength is -1).\n///\
    \ Example:\n/// >>> Strongest_Extension(class_name: \"my_class\", extensions:\
    \ [\"AA\", \"Be\", \"CC\"])\n/// \"my_class.AA\"\nfunc Strongest_Extension(class_name:\
    \ String, extensions: [String]) -> String {\n    let uppercase = CharacterSet.uppercaseLetters\n\
    \    let lowercase = CharacterSet.lowercaseLetters\n    var strongest = \"\"\n\
    \    var strength = -1.0\n    for ext in extensions {\n        var uppercase_count\
    \ = 0\n        var lowercase_count = 0\n        for char in ext.unicodeScalars\
    \ {\n            if uppercase.contains(char) {\n                uppercase_count\
    \ += 1\n            } else if lowercase.contains(char) {\n                lowercase_count\
    \ += 1\n            }\n        }\n        let string_strength = Double(uppercase_count)\
    \ - Double(lowercase_count)\n        if string_strength > strength {\n       \
    \     strength = string_strength\n            strongest = ext\n        }\n   \
    \ }\n    return \"\\(class_name).\\(strongest)\"\n}\n\n\nfunc ==(left: [(Int,\
    \ Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n\
    \        return false\n    }\n    for (l, r) in zip(left, right) {\n        if\
    \ l != r {\n            return false\n        }\n    }\n    return true\n}\n \
    \           \nassert(Strongest_Extension(class_name: \"Watashi\", extensions:\
    \ [\"tEN\", \"niNE\", \"eIGHt8OKe\"]) == \"Watashi.eIGHt8OKe\")\nassert(Strongest_Extension(class_name:\
    \ \"Boku123\", extensions: [\"nani\", \"NazeDa\", \"YEs.WeCaNe\", \"32145tggg\"\
    ]) == \"Boku123.YEs.WeCaNe\")\nassert(Strongest_Extension(class_name: \"__YESIMHERE\"\
    , extensions: [\"t\", \"eMptY\", \"nothing\", \"zeR00\", \"NuLl__\", \"123NoooneB321\"\
    ]) == \"__YESIMHERE.NuLl__\")\nassert(Strongest_Extension(class_name: \"K\", extensions:\
    \ [\"Ta\", \"TAR\", \"t234An\", \"cosSo\"]) == \"K.TAR\")\nassert(Strongest_Extension(class_name:\
    \ \"__HAHA\", extensions: [\"Tab\", \"123\", \"781345\", \"-_-\"]) == \"__HAHA.123\"\
    )\nassert(Strongest_Extension(class_name: \"YameRore\", extensions: [\"HhAas\"\
    , \"okIWILL123\", \"WorkOut\", \"Fails\", \"-_-\"]) == \"YameRore.okIWILL123\"\
    )\nassert(Strongest_Extension(class_name: \"finNNalLLly\", extensions: [\"Die\"\
    , \"NowW\", \"Wow\", \"WoW\"]) == \"finNNalLLly.WoW\")\nassert(Strongest_Extension(class_name:\
    \ \"_\", extensions: [\"Bb\", \"91245\"]) == \"_.Bb\")\nassert(Strongest_Extension(class_name:\
    \ \"Sp\", extensions: [\"671235\", \"Bb\"]) == \"Sp.671235\")"
  status: SyntaxError
  stderr: "/tmp/tmppws94dl5.swift:19:21: error: cannot find 'CharacterSet' in scope\n\
    \    let uppercase = CharacterSet.uppercaseLetters\n                    ^~~~~~~~~~~~\n\
    /tmp/tmppws94dl5.swift:20:21: error: cannot find 'CharacterSet' in scope\n   \
    \ let lowercase = CharacterSet.lowercaseLetters\n                    ^~~~~~~~~~~~\n"
  stdout: ''
  timestamp: 1660009432
- exit_code: 1
  program: "\n/// You will be given the name of a class (a string) and an array of\
    \ extensions.\n/// The extensions are to be used to load additional classes to\
    \ the class. The\n/// strength of the extension is as follows: Let CAP be the\
    \ number of the uppercase\n/// letters in the extension's name, and let SM be\
    \ the number of lowercase letters \n/// in the extension's name, the strength\
    \ is given by the fraction CAP - SM. \n/// You should find the strongest extension\
    \ and return a string in this \n/// format: ClassName.StrongestExtensionName.\n\
    /// If there are two or more extensions with the same strength, you should\n///\
    \ choose the one that comes first in the array.\n/// For example, if you are given\
    \ \"Slices\" as the class and an array of the\n/// extensions: ['SErviNGSliCes',\
    \ 'Cheese', 'StuFfed'] then you should\n/// return 'Slices.SErviNGSliCes' since\
    \ 'SErviNGSliCes' is the strongest extension \n/// (its strength is -1).\n///\
    \ Example:\n/// >>> Strongest_Extension(class_name: \"my_class\", extensions:\
    \ [\"AA\", \"Be\", \"CC\"])\n/// \"my_class.AA\"\nfunc Strongest_Extension(class_name:\
    \ String, extensions: [String]) -> String {\n    let upperCaseRegEx = try! NSRegularExpression(pattern:\
    \ \"[A-Z]\", options: .caseInsensitive)\n    let lowerCaseRegEx = try! NSRegularExpression(pattern:\
    \ \"[a-z]\", options: .caseInsensitive)\n    var max_strength: Float = 0.0\n \
    \   var strength: Float = 0.0\n    var strongest_extension = \"\"\n    for extension_name\
    \ in extensions {\n        let upperCaseMatches = upperCaseRegEx.matches(in: extension_name,\
    \ options: [], range: NSRange(location: 0, length: extension_name.count))\n  \
    \      let lowerCaseMatches = lowerCaseRegEx.matches(in: extension_name, options:\
    \ [], range: NSRange(location: 0, length: extension_name.count))\n        strength\
    \ = Float(upperCaseMatches.count) - Float(lowerCaseMatches.count)\n        if\
    \ strength > max_strength {\n            max_strength = strength\n           \
    \ strongest_extension = extension_name\n        }\n    }\n    return class_name\
    \ + \".\" + strongest_extension\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int,\
    \ Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n\
    \    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n          \
    \  return false\n        }\n    }\n    return true\n}\n            \nassert(Strongest_Extension(class_name:\
    \ \"Watashi\", extensions: [\"tEN\", \"niNE\", \"eIGHt8OKe\"]) == \"Watashi.eIGHt8OKe\"\
    )\nassert(Strongest_Extension(class_name: \"Boku123\", extensions: [\"nani\",\
    \ \"NazeDa\", \"YEs.WeCaNe\", \"32145tggg\"]) == \"Boku123.YEs.WeCaNe\")\nassert(Strongest_Extension(class_name:\
    \ \"__YESIMHERE\", extensions: [\"t\", \"eMptY\", \"nothing\", \"zeR00\", \"NuLl__\"\
    , \"123NoooneB321\"]) == \"__YESIMHERE.NuLl__\")\nassert(Strongest_Extension(class_name:\
    \ \"K\", extensions: [\"Ta\", \"TAR\", \"t234An\", \"cosSo\"]) == \"K.TAR\")\n\
    assert(Strongest_Extension(class_name: \"__HAHA\", extensions: [\"Tab\", \"123\"\
    , \"781345\", \"-_-\"]) == \"__HAHA.123\")\nassert(Strongest_Extension(class_name:\
    \ \"YameRore\", extensions: [\"HhAas\", \"okIWILL123\", \"WorkOut\", \"Fails\"\
    , \"-_-\"]) == \"YameRore.okIWILL123\")\nassert(Strongest_Extension(class_name:\
    \ \"finNNalLLly\", extensions: [\"Die\", \"NowW\", \"Wow\", \"WoW\"]) == \"finNNalLLly.WoW\"\
    )\nassert(Strongest_Extension(class_name: \"_\", extensions: [\"Bb\", \"91245\"\
    ]) == \"_.Bb\")\nassert(Strongest_Extension(class_name: \"Sp\", extensions: [\"\
    671235\", \"Bb\"]) == \"Sp.671235\")"
  status: SyntaxError
  stderr: "/tmp/tmprl8tjs6s.swift:19:31: error: cannot find 'NSRegularExpression'\
    \ in scope\n    let upperCaseRegEx = try! NSRegularExpression(pattern: \"[A-Z]\"\
    , options: .caseInsensitive)\n                              ^~~~~~~~~~~~~~~~~~~\n\
    /tmp/tmprl8tjs6s.swift:19:79: error: cannot infer contextual base in reference\
    \ to member 'caseInsensitive'\n    let upperCaseRegEx = try! NSRegularExpression(pattern:\
    \ \"[A-Z]\", options: .caseInsensitive)\n                                    \
    \                                         ~^~~~~~~~~~~~~~~\n/tmp/tmprl8tjs6s.swift:20:31:\
    \ error: cannot find 'NSRegularExpression' in scope\n    let lowerCaseRegEx =\
    \ try! NSRegularExpression(pattern: \"[a-z]\", options: .caseInsensitive)\n  \
    \                            ^~~~~~~~~~~~~~~~~~~\n/tmp/tmprl8tjs6s.swift:20:79:\
    \ error: cannot infer contextual base in reference to member 'caseInsensitive'\n\
    \    let lowerCaseRegEx = try! NSRegularExpression(pattern: \"[a-z]\", options:\
    \ .caseInsensitive)\n                                                        \
    \                     ~^~~~~~~~~~~~~~~\n/tmp/tmprl8tjs6s.swift:25:95: error: cannot\
    \ find 'NSRange' in scope\n        let upperCaseMatches = upperCaseRegEx.matches(in:\
    \ extension_name, options: [], range: NSRange(location: 0, length: extension_name.count))\n\
    \                                                                            \
    \                  ^~~~~~~\n/tmp/tmprl8tjs6s.swift:26:95: error: cannot find 'NSRange'\
    \ in scope\n        let lowerCaseMatches = lowerCaseRegEx.matches(in: extension_name,\
    \ options: [], range: NSRange(location: 0, length: extension_name.count))\n  \
    \                                                                            \
    \                ^~~~~~~\n"
  stdout: ''
  timestamp: 1660009433
- exit_code: 1
  program: "\n/// You will be given the name of a class (a string) and an array of\
    \ extensions.\n/// The extensions are to be used to load additional classes to\
    \ the class. The\n/// strength of the extension is as follows: Let CAP be the\
    \ number of the uppercase\n/// letters in the extension's name, and let SM be\
    \ the number of lowercase letters \n/// in the extension's name, the strength\
    \ is given by the fraction CAP - SM. \n/// You should find the strongest extension\
    \ and return a string in this \n/// format: ClassName.StrongestExtensionName.\n\
    /// If there are two or more extensions with the same strength, you should\n///\
    \ choose the one that comes first in the array.\n/// For example, if you are given\
    \ \"Slices\" as the class and an array of the\n/// extensions: ['SErviNGSliCes',\
    \ 'Cheese', 'StuFfed'] then you should\n/// return 'Slices.SErviNGSliCes' since\
    \ 'SErviNGSliCes' is the strongest extension \n/// (its strength is -1).\n///\
    \ Example:\n/// >>> Strongest_Extension(class_name: \"my_class\", extensions:\
    \ [\"AA\", \"Be\", \"CC\"])\n/// \"my_class.AA\"\nfunc Strongest_Extension(class_name:\
    \ String, extensions: [String]) -> String {\n    if extensions.count == 0 {\n\
    \        return class_name\n    }\n    var strongest_extension = extensions[0]\n\
    \    var strongest_strength = strength(of: extensions[0])\n    for i in 1..<extensions.count\
    \ {\n        let next_strength = strength(of: extensions[i])\n        if next_strength\
    \ > strongest_strength {\n            strongest_strength = next_strength\n   \
    \         strongest_extension = extensions[i]\n        }\n    }\n    return class_name\
    \ + \".\" + strongest_extension\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int,\
    \ Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n\
    \    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n          \
    \  return false\n        }\n    }\n    return true\n}\n            \nassert(Strongest_Extension(class_name:\
    \ \"Watashi\", extensions: [\"tEN\", \"niNE\", \"eIGHt8OKe\"]) == \"Watashi.eIGHt8OKe\"\
    )\nassert(Strongest_Extension(class_name: \"Boku123\", extensions: [\"nani\",\
    \ \"NazeDa\", \"YEs.WeCaNe\", \"32145tggg\"]) == \"Boku123.YEs.WeCaNe\")\nassert(Strongest_Extension(class_name:\
    \ \"__YESIMHERE\", extensions: [\"t\", \"eMptY\", \"nothing\", \"zeR00\", \"NuLl__\"\
    , \"123NoooneB321\"]) == \"__YESIMHERE.NuLl__\")\nassert(Strongest_Extension(class_name:\
    \ \"K\", extensions: [\"Ta\", \"TAR\", \"t234An\", \"cosSo\"]) == \"K.TAR\")\n\
    assert(Strongest_Extension(class_name: \"__HAHA\", extensions: [\"Tab\", \"123\"\
    , \"781345\", \"-_-\"]) == \"__HAHA.123\")\nassert(Strongest_Extension(class_name:\
    \ \"YameRore\", extensions: [\"HhAas\", \"okIWILL123\", \"WorkOut\", \"Fails\"\
    , \"-_-\"]) == \"YameRore.okIWILL123\")\nassert(Strongest_Extension(class_name:\
    \ \"finNNalLLly\", extensions: [\"Die\", \"NowW\", \"Wow\", \"WoW\"]) == \"finNNalLLly.WoW\"\
    )\nassert(Strongest_Extension(class_name: \"_\", extensions: [\"Bb\", \"91245\"\
    ]) == \"_.Bb\")\nassert(Strongest_Extension(class_name: \"Sp\", extensions: [\"\
    671235\", \"Bb\"]) == \"Sp.671235\")"
  status: SyntaxError
  stderr: "/tmp/tmpz1fw0x1q.swift:23:30: error: cannot find 'strength' in scope\n\
    \    var strongest_strength = strength(of: extensions[0])\n                  \
    \           ^~~~~~~~\n/tmp/tmpz1fw0x1q.swift:25:29: error: cannot find 'strength'\
    \ in scope\n        let next_strength = strength(of: extensions[i])\n        \
    \                    ^~~~~~~~\n"
  stdout: ''
  timestamp: 1660009432
- exit_code: -4
  program: "\n/// You will be given the name of a class (a string) and an array of\
    \ extensions.\n/// The extensions are to be used to load additional classes to\
    \ the class. The\n/// strength of the extension is as follows: Let CAP be the\
    \ number of the uppercase\n/// letters in the extension's name, and let SM be\
    \ the number of lowercase letters \n/// in the extension's name, the strength\
    \ is given by the fraction CAP - SM. \n/// You should find the strongest extension\
    \ and return a string in this \n/// format: ClassName.StrongestExtensionName.\n\
    /// If there are two or more extensions with the same strength, you should\n///\
    \ choose the one that comes first in the array.\n/// For example, if you are given\
    \ \"Slices\" as the class and an array of the\n/// extensions: ['SErviNGSliCes',\
    \ 'Cheese', 'StuFfed'] then you should\n/// return 'Slices.SErviNGSliCes' since\
    \ 'SErviNGSliCes' is the strongest extension \n/// (its strength is -1).\n///\
    \ Example:\n/// >>> Strongest_Extension(class_name: \"my_class\", extensions:\
    \ [\"AA\", \"Be\", \"CC\"])\n/// \"my_class.AA\"\nfunc Strongest_Extension(class_name:\
    \ String, extensions: [String]) -> String {\n    var score = 0\n    var strong\
    \ = \"\"\n    for e in extensions {\n        let cap = e.filter{ $0.isUppercase\
    \ }.count\n        let sm = e.filter{ $0.isLowercase }.count\n        let result\
    \ = cap - sm\n        if result > score {\n            score = result\n      \
    \      strong = e\n        }\n    }\n    return class_name + \".\" + strong\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(Strongest_Extension(class_name: \"Watashi\", extensions:\
    \ [\"tEN\", \"niNE\", \"eIGHt8OKe\"]) == \"Watashi.eIGHt8OKe\")\nassert(Strongest_Extension(class_name:\
    \ \"Boku123\", extensions: [\"nani\", \"NazeDa\", \"YEs.WeCaNe\", \"32145tggg\"\
    ]) == \"Boku123.YEs.WeCaNe\")\nassert(Strongest_Extension(class_name: \"__YESIMHERE\"\
    , extensions: [\"t\", \"eMptY\", \"nothing\", \"zeR00\", \"NuLl__\", \"123NoooneB321\"\
    ]) == \"__YESIMHERE.NuLl__\")\nassert(Strongest_Extension(class_name: \"K\", extensions:\
    \ [\"Ta\", \"TAR\", \"t234An\", \"cosSo\"]) == \"K.TAR\")\nassert(Strongest_Extension(class_name:\
    \ \"__HAHA\", extensions: [\"Tab\", \"123\", \"781345\", \"-_-\"]) == \"__HAHA.123\"\
    )\nassert(Strongest_Extension(class_name: \"YameRore\", extensions: [\"HhAas\"\
    , \"okIWILL123\", \"WorkOut\", \"Fails\", \"-_-\"]) == \"YameRore.okIWILL123\"\
    )\nassert(Strongest_Extension(class_name: \"finNNalLLly\", extensions: [\"Die\"\
    , \"NowW\", \"Wow\", \"WoW\"]) == \"finNNalLLly.WoW\")\nassert(Strongest_Extension(class_name:\
    \ \"_\", extensions: [\"Bb\", \"91245\"]) == \"_.Bb\")\nassert(Strongest_Extension(class_name:\
    \ \"Sp\", extensions: [\"671235\", \"Bb\"]) == \"Sp.671235\")"
  status: Exception
  stderr: 'tmp0bclqxew/tmp0bclqxew.swift:48: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002ab6be6c9c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002ab6be3c0b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002ab6be3c0988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002ab6be3bf7b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmp0bclqxew                        0x000056356eef4cdc <unavailable> + 7388

    5    libc.so.6                          0x00002ab6be8b5460 __libc_start_main +
    245

    6    tmp0bclqxew                        0x000056356eef43e9 <unavailable> + 5097

    '
  stdout: ''
  timestamp: 1660009433
- exit_code: -4
  program: "\n/// You will be given the name of a class (a string) and an array of\
    \ extensions.\n/// The extensions are to be used to load additional classes to\
    \ the class. The\n/// strength of the extension is as follows: Let CAP be the\
    \ number of the uppercase\n/// letters in the extension's name, and let SM be\
    \ the number of lowercase letters \n/// in the extension's name, the strength\
    \ is given by the fraction CAP - SM. \n/// You should find the strongest extension\
    \ and return a string in this \n/// format: ClassName.StrongestExtensionName.\n\
    /// If there are two or more extensions with the same strength, you should\n///\
    \ choose the one that comes first in the array.\n/// For example, if you are given\
    \ \"Slices\" as the class and an array of the\n/// extensions: ['SErviNGSliCes',\
    \ 'Cheese', 'StuFfed'] then you should\n/// return 'Slices.SErviNGSliCes' since\
    \ 'SErviNGSliCes' is the strongest extension \n/// (its strength is -1).\n///\
    \ Example:\n/// >>> Strongest_Extension(class_name: \"my_class\", extensions:\
    \ [\"AA\", \"Be\", \"CC\"])\n/// \"my_class.AA\"\nfunc Strongest_Extension(class_name:\
    \ String, extensions: [String]) -> String {\n    let arr = extensions.map { (ext)\
    \ -> (String, Double) in\n        let caps = ext.filter({ $0.isUppercase }).count\n\
    \        let smalls = ext.filter({ $0.isLowercase }).count\n        return (ext,\
    \ Double(caps - smalls))\n    }\n    let sorted = arr.sorted { (first, second)\
    \ -> Bool in\n        if first.1 == second.1 {\n            return first.0 < second.0\n\
    \        }\n        return first.1 > second.1\n    }\n    return class_name +\
    \ \".\" + sorted.first!.0\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(Strongest_Extension(class_name:\
    \ \"Watashi\", extensions: [\"tEN\", \"niNE\", \"eIGHt8OKe\"]) == \"Watashi.eIGHt8OKe\"\
    )\nassert(Strongest_Extension(class_name: \"Boku123\", extensions: [\"nani\",\
    \ \"NazeDa\", \"YEs.WeCaNe\", \"32145tggg\"]) == \"Boku123.YEs.WeCaNe\")\nassert(Strongest_Extension(class_name:\
    \ \"__YESIMHERE\", extensions: [\"t\", \"eMptY\", \"nothing\", \"zeR00\", \"NuLl__\"\
    , \"123NoooneB321\"]) == \"__YESIMHERE.NuLl__\")\nassert(Strongest_Extension(class_name:\
    \ \"K\", extensions: [\"Ta\", \"TAR\", \"t234An\", \"cosSo\"]) == \"K.TAR\")\n\
    assert(Strongest_Extension(class_name: \"__HAHA\", extensions: [\"Tab\", \"123\"\
    , \"781345\", \"-_-\"]) == \"__HAHA.123\")\nassert(Strongest_Extension(class_name:\
    \ \"YameRore\", extensions: [\"HhAas\", \"okIWILL123\", \"WorkOut\", \"Fails\"\
    , \"-_-\"]) == \"YameRore.okIWILL123\")\nassert(Strongest_Extension(class_name:\
    \ \"finNNalLLly\", extensions: [\"Die\", \"NowW\", \"Wow\", \"WoW\"]) == \"finNNalLLly.WoW\"\
    )\nassert(Strongest_Extension(class_name: \"_\", extensions: [\"Bb\", \"91245\"\
    ]) == \"_.Bb\")\nassert(Strongest_Extension(class_name: \"Sp\", extensions: [\"\
    671235\", \"Bb\"]) == \"Sp.671235\")"
  status: Exception
  stderr: 'tmp0h5bzooj/tmp0h5bzooj.swift:50: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b457eb49c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b457e840b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b457e840988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b457e83f7b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmp0h5bzooj                        0x0000560adb16720a <unavailable> + 8714

    5    libc.so.6                          0x00002b457ed35460 __libc_start_main +
    245

    6    tmp0h5bzooj                        0x0000560adb1664d9 <unavailable> + 5337

    '
  stdout: ''
  timestamp: 1660009433
- exit_code: -4
  program: "\n/// You will be given the name of a class (a string) and an array of\
    \ extensions.\n/// The extensions are to be used to load additional classes to\
    \ the class. The\n/// strength of the extension is as follows: Let CAP be the\
    \ number of the uppercase\n/// letters in the extension's name, and let SM be\
    \ the number of lowercase letters \n/// in the extension's name, the strength\
    \ is given by the fraction CAP - SM. \n/// You should find the strongest extension\
    \ and return a string in this \n/// format: ClassName.StrongestExtensionName.\n\
    /// If there are two or more extensions with the same strength, you should\n///\
    \ choose the one that comes first in the array.\n/// For example, if you are given\
    \ \"Slices\" as the class and an array of the\n/// extensions: ['SErviNGSliCes',\
    \ 'Cheese', 'StuFfed'] then you should\n/// return 'Slices.SErviNGSliCes' since\
    \ 'SErviNGSliCes' is the strongest extension \n/// (its strength is -1).\n///\
    \ Example:\n/// >>> Strongest_Extension(class_name: \"my_class\", extensions:\
    \ [\"AA\", \"Be\", \"CC\"])\n/// \"my_class.AA\"\nfunc Strongest_Extension(class_name:\
    \ String, extensions: [String]) -> String {\n    let strongest_extension = extensions.max\
    \ { (ext1, ext2) -> Bool in\n        let ext1_uppercase_count = ext1.reduce(0)\
    \ { $1.isUppercase ? $0 + 1 : $0 }\n        let ext1_lowercase_count = ext1.reduce(0)\
    \ { $1.isLowercase ? $0 + 1 : $0 }\n        let ext1_strength = ext1_uppercase_count\
    \ - ext1_lowercase_count\n        \n        let ext2_uppercase_count = ext2.reduce(0)\
    \ { $1.isUppercase ? $0 + 1 : $0 }\n        let ext2_lowercase_count = ext2.reduce(0)\
    \ { $1.isLowercase ? $0 + 1 : $0 }\n        let ext2_strength = ext2_uppercase_count\
    \ - ext2_lowercase_count\n        \n        return ext1_strength > ext2_strength\n\
    \    }\n    \n    return \"\\(class_name).\\(strongest_extension!)\"\n}\n\n\n\
    func ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(Strongest_Extension(class_name: \"Watashi\", extensions:\
    \ [\"tEN\", \"niNE\", \"eIGHt8OKe\"]) == \"Watashi.eIGHt8OKe\")\nassert(Strongest_Extension(class_name:\
    \ \"Boku123\", extensions: [\"nani\", \"NazeDa\", \"YEs.WeCaNe\", \"32145tggg\"\
    ]) == \"Boku123.YEs.WeCaNe\")\nassert(Strongest_Extension(class_name: \"__YESIMHERE\"\
    , extensions: [\"t\", \"eMptY\", \"nothing\", \"zeR00\", \"NuLl__\", \"123NoooneB321\"\
    ]) == \"__YESIMHERE.NuLl__\")\nassert(Strongest_Extension(class_name: \"K\", extensions:\
    \ [\"Ta\", \"TAR\", \"t234An\", \"cosSo\"]) == \"K.TAR\")\nassert(Strongest_Extension(class_name:\
    \ \"__HAHA\", extensions: [\"Tab\", \"123\", \"781345\", \"-_-\"]) == \"__HAHA.123\"\
    )\nassert(Strongest_Extension(class_name: \"YameRore\", extensions: [\"HhAas\"\
    , \"okIWILL123\", \"WorkOut\", \"Fails\", \"-_-\"]) == \"YameRore.okIWILL123\"\
    )\nassert(Strongest_Extension(class_name: \"finNNalLLly\", extensions: [\"Die\"\
    , \"NowW\", \"Wow\", \"WoW\"]) == \"finNNalLLly.WoW\")\nassert(Strongest_Extension(class_name:\
    \ \"_\", extensions: [\"Bb\", \"91245\"]) == \"_.Bb\")\nassert(Strongest_Extension(class_name:\
    \ \"Sp\", extensions: [\"671235\", \"Bb\"]) == \"Sp.671235\")"
  status: Exception
  stderr: 'tmp63fwjm_0/tmp63fwjm_0.swift:47: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002ad03a996c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002ad03a68db6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002ad03a68d988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002ad03a68c7b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmp63fwjm_0                        0x00005653c7377a2d <unavailable> + 6701

    5    libc.so.6                          0x00002ad03ab82460 __libc_start_main +
    245

    6    tmp63fwjm_0                        0x00005653c73775b9 <unavailable> + 5561

    '
  stdout: ''
  timestamp: 1660009433
- exit_code: -4
  program: "\n/// You will be given the name of a class (a string) and an array of\
    \ extensions.\n/// The extensions are to be used to load additional classes to\
    \ the class. The\n/// strength of the extension is as follows: Let CAP be the\
    \ number of the uppercase\n/// letters in the extension's name, and let SM be\
    \ the number of lowercase letters \n/// in the extension's name, the strength\
    \ is given by the fraction CAP - SM. \n/// You should find the strongest extension\
    \ and return a string in this \n/// format: ClassName.StrongestExtensionName.\n\
    /// If there are two or more extensions with the same strength, you should\n///\
    \ choose the one that comes first in the array.\n/// For example, if you are given\
    \ \"Slices\" as the class and an array of the\n/// extensions: ['SErviNGSliCes',\
    \ 'Cheese', 'StuFfed'] then you should\n/// return 'Slices.SErviNGSliCes' since\
    \ 'SErviNGSliCes' is the strongest extension \n/// (its strength is -1).\n///\
    \ Example:\n/// >>> Strongest_Extension(class_name: \"my_class\", extensions:\
    \ [\"AA\", \"Be\", \"CC\"])\n/// \"my_class.AA\"\nfunc Strongest_Extension(class_name:\
    \ String, extensions: [String]) -> String {\n    // Write your code here.\n  \
    \  return \"\"\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool\
    \ {\n    if left.count != right.count {\n        return false\n    }\n    for\
    \ (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(Strongest_Extension(class_name:\
    \ \"Watashi\", extensions: [\"tEN\", \"niNE\", \"eIGHt8OKe\"]) == \"Watashi.eIGHt8OKe\"\
    )\nassert(Strongest_Extension(class_name: \"Boku123\", extensions: [\"nani\",\
    \ \"NazeDa\", \"YEs.WeCaNe\", \"32145tggg\"]) == \"Boku123.YEs.WeCaNe\")\nassert(Strongest_Extension(class_name:\
    \ \"__YESIMHERE\", extensions: [\"t\", \"eMptY\", \"nothing\", \"zeR00\", \"NuLl__\"\
    , \"123NoooneB321\"]) == \"__YESIMHERE.NuLl__\")\nassert(Strongest_Extension(class_name:\
    \ \"K\", extensions: [\"Ta\", \"TAR\", \"t234An\", \"cosSo\"]) == \"K.TAR\")\n\
    assert(Strongest_Extension(class_name: \"__HAHA\", extensions: [\"Tab\", \"123\"\
    , \"781345\", \"-_-\"]) == \"__HAHA.123\")\nassert(Strongest_Extension(class_name:\
    \ \"YameRore\", extensions: [\"HhAas\", \"okIWILL123\", \"WorkOut\", \"Fails\"\
    , \"-_-\"]) == \"YameRore.okIWILL123\")\nassert(Strongest_Extension(class_name:\
    \ \"finNNalLLly\", extensions: [\"Die\", \"NowW\", \"Wow\", \"WoW\"]) == \"finNNalLLly.WoW\"\
    )\nassert(Strongest_Extension(class_name: \"_\", extensions: [\"Bb\", \"91245\"\
    ]) == \"_.Bb\")\nassert(Strongest_Extension(class_name: \"Sp\", extensions: [\"\
    671235\", \"Bb\"]) == \"Sp.671235\")"
  status: Exception
  stderr: 'tmp7h5sins9/tmp7h5sins9.swift:36: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002aff37a2dc80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002aff37724b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002aff37724988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002aff377237b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmp7h5sins9                        0x0000557babc784fd <unavailable> + 5373

    5    libc.so.6                          0x00002aff37c19460 __libc_start_main +
    245

    6    tmp7h5sins9                        0x0000557babc78089 <unavailable> + 4233

    '
  stdout: ''
  timestamp: 1660009431
- exit_code: -4
  program: "\n/// You will be given the name of a class (a string) and an array of\
    \ extensions.\n/// The extensions are to be used to load additional classes to\
    \ the class. The\n/// strength of the extension is as follows: Let CAP be the\
    \ number of the uppercase\n/// letters in the extension's name, and let SM be\
    \ the number of lowercase letters \n/// in the extension's name, the strength\
    \ is given by the fraction CAP - SM. \n/// You should find the strongest extension\
    \ and return a string in this \n/// format: ClassName.StrongestExtensionName.\n\
    /// If there are two or more extensions with the same strength, you should\n///\
    \ choose the one that comes first in the array.\n/// For example, if you are given\
    \ \"Slices\" as the class and an array of the\n/// extensions: ['SErviNGSliCes',\
    \ 'Cheese', 'StuFfed'] then you should\n/// return 'Slices.SErviNGSliCes' since\
    \ 'SErviNGSliCes' is the strongest extension \n/// (its strength is -1).\n///\
    \ Example:\n/// >>> Strongest_Extension(class_name: \"my_class\", extensions:\
    \ [\"AA\", \"Be\", \"CC\"])\n/// \"my_class.AA\"\nfunc Strongest_Extension(class_name:\
    \ String, extensions: [String]) -> String {\n    var strongest: String = \"\"\n\
    \    var strongest_score: Double = 0\n    for ex in extensions {\n        var\
    \ score: Double = 0\n        for c in ex {\n            if c.isUppercase {\n \
    \               score += 1\n            } else {\n                score -= 1\n\
    \            }\n        }\n        if score > strongest_score {\n            strongest_score\
    \ = score\n            strongest = ex\n        }\n    }\n    return class_name\
    \ + \".\" + strongest\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(Strongest_Extension(class_name:\
    \ \"Watashi\", extensions: [\"tEN\", \"niNE\", \"eIGHt8OKe\"]) == \"Watashi.eIGHt8OKe\"\
    )\nassert(Strongest_Extension(class_name: \"Boku123\", extensions: [\"nani\",\
    \ \"NazeDa\", \"YEs.WeCaNe\", \"32145tggg\"]) == \"Boku123.YEs.WeCaNe\")\nassert(Strongest_Extension(class_name:\
    \ \"__YESIMHERE\", extensions: [\"t\", \"eMptY\", \"nothing\", \"zeR00\", \"NuLl__\"\
    , \"123NoooneB321\"]) == \"__YESIMHERE.NuLl__\")\nassert(Strongest_Extension(class_name:\
    \ \"K\", extensions: [\"Ta\", \"TAR\", \"t234An\", \"cosSo\"]) == \"K.TAR\")\n\
    assert(Strongest_Extension(class_name: \"__HAHA\", extensions: [\"Tab\", \"123\"\
    , \"781345\", \"-_-\"]) == \"__HAHA.123\")\nassert(Strongest_Extension(class_name:\
    \ \"YameRore\", extensions: [\"HhAas\", \"okIWILL123\", \"WorkOut\", \"Fails\"\
    , \"-_-\"]) == \"YameRore.okIWILL123\")\nassert(Strongest_Extension(class_name:\
    \ \"finNNalLLly\", extensions: [\"Die\", \"NowW\", \"Wow\", \"WoW\"]) == \"finNNalLLly.WoW\"\
    )\nassert(Strongest_Extension(class_name: \"_\", extensions: [\"Bb\", \"91245\"\
    ]) == \"_.Bb\")\nassert(Strongest_Extension(class_name: \"Sp\", extensions: [\"\
    671235\", \"Bb\"]) == \"Sp.671235\")"
  status: Exception
  stderr: 'tmpnreoeywr/tmpnreoeywr.swift:51: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002afd682aec80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002afd67fa5b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002afd67fa5988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002afd67fa47b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpnreoeywr                        0x000055d5f245d7cd <unavailable> + 6093

    5    libc.so.6                          0x00002afd6849a460 __libc_start_main +
    245

    6    tmpnreoeywr                        0x000055d5f245d359 <unavailable> + 4953

    '
  stdout: ''
  timestamp: 1660009433
- exit_code: -4
  program: "\n/// You will be given the name of a class (a string) and an array of\
    \ extensions.\n/// The extensions are to be used to load additional classes to\
    \ the class. The\n/// strength of the extension is as follows: Let CAP be the\
    \ number of the uppercase\n/// letters in the extension's name, and let SM be\
    \ the number of lowercase letters \n/// in the extension's name, the strength\
    \ is given by the fraction CAP - SM. \n/// You should find the strongest extension\
    \ and return a string in this \n/// format: ClassName.StrongestExtensionName.\n\
    /// If there are two or more extensions with the same strength, you should\n///\
    \ choose the one that comes first in the array.\n/// For example, if you are given\
    \ \"Slices\" as the class and an array of the\n/// extensions: ['SErviNGSliCes',\
    \ 'Cheese', 'StuFfed'] then you should\n/// return 'Slices.SErviNGSliCes' since\
    \ 'SErviNGSliCes' is the strongest extension \n/// (its strength is -1).\n///\
    \ Example:\n/// >>> Strongest_Extension(class_name: \"my_class\", extensions:\
    \ [\"AA\", \"Be\", \"CC\"])\n/// \"my_class.AA\"\nfunc Strongest_Extension(class_name:\
    \ String, extensions: [String]) -> String {\n    return \"Hello world!\"\n}\n\n\
    \nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(Strongest_Extension(class_name: \"Watashi\", extensions:\
    \ [\"tEN\", \"niNE\", \"eIGHt8OKe\"]) == \"Watashi.eIGHt8OKe\")\nassert(Strongest_Extension(class_name:\
    \ \"Boku123\", extensions: [\"nani\", \"NazeDa\", \"YEs.WeCaNe\", \"32145tggg\"\
    ]) == \"Boku123.YEs.WeCaNe\")\nassert(Strongest_Extension(class_name: \"__YESIMHERE\"\
    , extensions: [\"t\", \"eMptY\", \"nothing\", \"zeR00\", \"NuLl__\", \"123NoooneB321\"\
    ]) == \"__YESIMHERE.NuLl__\")\nassert(Strongest_Extension(class_name: \"K\", extensions:\
    \ [\"Ta\", \"TAR\", \"t234An\", \"cosSo\"]) == \"K.TAR\")\nassert(Strongest_Extension(class_name:\
    \ \"__HAHA\", extensions: [\"Tab\", \"123\", \"781345\", \"-_-\"]) == \"__HAHA.123\"\
    )\nassert(Strongest_Extension(class_name: \"YameRore\", extensions: [\"HhAas\"\
    , \"okIWILL123\", \"WorkOut\", \"Fails\", \"-_-\"]) == \"YameRore.okIWILL123\"\
    )\nassert(Strongest_Extension(class_name: \"finNNalLLly\", extensions: [\"Die\"\
    , \"NowW\", \"Wow\", \"WoW\"]) == \"finNNalLLly.WoW\")\nassert(Strongest_Extension(class_name:\
    \ \"_\", extensions: [\"Bb\", \"91245\"]) == \"_.Bb\")\nassert(Strongest_Extension(class_name:\
    \ \"Sp\", extensions: [\"671235\", \"Bb\"]) == \"Sp.671235\")"
  status: Exception
  stderr: 'tmpsqmne353/tmpsqmne353.swift:35: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002ad6440a8c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002ad643d9fb6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002ad643d9f988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002ad643d9e7b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpsqmne353                        0x000055eeb48e84fd <unavailable> + 5373

    5    libc.so.6                          0x00002ad644294460 __libc_start_main +
    245

    6    tmpsqmne353                        0x000055eeb48e8089 <unavailable> + 4233

    '
  stdout: ''
  timestamp: 1660009433
- exit_code: -4
  program: "\n/// You will be given the name of a class (a string) and an array of\
    \ extensions.\n/// The extensions are to be used to load additional classes to\
    \ the class. The\n/// strength of the extension is as follows: Let CAP be the\
    \ number of the uppercase\n/// letters in the extension's name, and let SM be\
    \ the number of lowercase letters \n/// in the extension's name, the strength\
    \ is given by the fraction CAP - SM. \n/// You should find the strongest extension\
    \ and return a string in this \n/// format: ClassName.StrongestExtensionName.\n\
    /// If there are two or more extensions with the same strength, you should\n///\
    \ choose the one that comes first in the array.\n/// For example, if you are given\
    \ \"Slices\" as the class and an array of the\n/// extensions: ['SErviNGSliCes',\
    \ 'Cheese', 'StuFfed'] then you should\n/// return 'Slices.SErviNGSliCes' since\
    \ 'SErviNGSliCes' is the strongest extension \n/// (its strength is -1).\n///\
    \ Example:\n/// >>> Strongest_Extension(class_name: \"my_class\", extensions:\
    \ [\"AA\", \"Be\", \"CC\"])\n/// \"my_class.AA\"\nfunc Strongest_Extension(class_name:\
    \ String, extensions: [String]) -> String {\n  var strongest_extension = \"\"\n\
    \  var strongest_strength = 0.0\n  for extension_name in extensions {\n    let\
    \ cap = extension_name.filter{$0.isUppercase}.count\n    let sm = extension_name.filter{$0.isLowercase}.count\n\
    \    let strength = Double(cap) - Double(sm)\n    if strength > strongest_strength\
    \ {\n      strongest_strength = strength\n      strongest_extension = extension_name\n\
    \    }\n  }\n  return \"\\(class_name).\\(strongest_extension)\"\n}\n\n\nfunc\
    \ ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count !=\
    \ right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(Strongest_Extension(class_name: \"Watashi\", extensions:\
    \ [\"tEN\", \"niNE\", \"eIGHt8OKe\"]) == \"Watashi.eIGHt8OKe\")\nassert(Strongest_Extension(class_name:\
    \ \"Boku123\", extensions: [\"nani\", \"NazeDa\", \"YEs.WeCaNe\", \"32145tggg\"\
    ]) == \"Boku123.YEs.WeCaNe\")\nassert(Strongest_Extension(class_name: \"__YESIMHERE\"\
    , extensions: [\"t\", \"eMptY\", \"nothing\", \"zeR00\", \"NuLl__\", \"123NoooneB321\"\
    ]) == \"__YESIMHERE.NuLl__\")\nassert(Strongest_Extension(class_name: \"K\", extensions:\
    \ [\"Ta\", \"TAR\", \"t234An\", \"cosSo\"]) == \"K.TAR\")\nassert(Strongest_Extension(class_name:\
    \ \"__HAHA\", extensions: [\"Tab\", \"123\", \"781345\", \"-_-\"]) == \"__HAHA.123\"\
    )\nassert(Strongest_Extension(class_name: \"YameRore\", extensions: [\"HhAas\"\
    , \"okIWILL123\", \"WorkOut\", \"Fails\", \"-_-\"]) == \"YameRore.okIWILL123\"\
    )\nassert(Strongest_Extension(class_name: \"finNNalLLly\", extensions: [\"Die\"\
    , \"NowW\", \"Wow\", \"WoW\"]) == \"finNNalLLly.WoW\")\nassert(Strongest_Extension(class_name:\
    \ \"_\", extensions: [\"Bb\", \"91245\"]) == \"_.Bb\")\nassert(Strongest_Extension(class_name:\
    \ \"Sp\", extensions: [\"671235\", \"Bb\"]) == \"Sp.671235\")"
  status: Exception
  stderr: 'tmp_y4k9w5_/tmp_y4k9w5_.swift:48: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b2cf925bc80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b2cf8f52b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b2cf8f52988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b2cf8f517b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmp_y4k9w5_                        0x000055a11f0ddf4c <unavailable> + 8012

    5    libc.so.6                          0x00002b2cf9447460 __libc_start_main +
    245

    6    tmp_y4k9w5_                        0x000055a11f0dd659 <unavailable> + 5721

    '
  stdout: ''
  timestamp: 1660009433
- exit_code: 1
  program: "\n/// You will be given the name of a class (a string) and an array of\
    \ extensions.\n/// The extensions are to be used to load additional classes to\
    \ the class. The\n/// strength of the extension is as follows: Let CAP be the\
    \ number of the uppercase\n/// letters in the extension's name, and let SM be\
    \ the number of lowercase letters \n/// in the extension's name, the strength\
    \ is given by the fraction CAP - SM. \n/// You should find the strongest extension\
    \ and return a string in this \n/// format: ClassName.StrongestExtensionName.\n\
    /// If there are two or more extensions with the same strength, you should\n///\
    \ choose the one that comes first in the array.\n/// For example, if you are given\
    \ \"Slices\" as the class and an array of the\n/// extensions: ['SErviNGSliCes',\
    \ 'Cheese', 'StuFfed'] then you should\n/// return 'Slices.SErviNGSliCes' since\
    \ 'SErviNGSliCes' is the strongest extension \n/// (its strength is -1).\n///\
    \ Example:\n/// >>> Strongest_Extension(class_name: \"my_class\", extensions:\
    \ [\"AA\", \"Be\", \"CC\"])\n/// \"my_class.AA\"\nfunc Strongest_Extension(class_name:\
    \ String, extensions: [String]) -> String {\n    var cap = 0\n    var sm = 0\n\
    \    var strength = 0\n    var strongest_extension = \"\"\n    for var i in 0..<extensions.count\
    \ {\n        cap = 0\n        sm = 0\n        strength = 0\n        for j in extensions[i].characters\
    \ {\n            if j.isUpperCase() {\n                cap += 1\n            }\
    \ else {\n                sm += 1\n            }\n        }\n        strength\
    \ = cap - sm\n        if strongest_extension == \"\" {\n            strongest_extension\
    \ = extensions[i]\n        } else if strength > 0 {\n            if strength >\
    \ cap - sm {\n                strongest_extension = extensions[i]\n          \
    \  }\n        } else if strength < 0 {\n            if strength < cap - sm {\n\
    \                strongest_extension = extensions[i]\n            }\n        }\n\
    \    }\n    return class_name + \".\" + strongest_extension\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(Strongest_Extension(class_name: \"Watashi\", extensions:\
    \ [\"tEN\", \"niNE\", \"eIGHt8OKe\"]) == \"Watashi.eIGHt8OKe\")\nassert(Strongest_Extension(class_name:\
    \ \"Boku123\", extensions: [\"nani\", \"NazeDa\", \"YEs.WeCaNe\", \"32145tggg\"\
    ]) == \"Boku123.YEs.WeCaNe\")\nassert(Strongest_Extension(class_name: \"__YESIMHERE\"\
    , extensions: [\"t\", \"eMptY\", \"nothing\", \"zeR00\", \"NuLl__\", \"123NoooneB321\"\
    ]) == \"__YESIMHERE.NuLl__\")\nassert(Strongest_Extension(class_name: \"K\", extensions:\
    \ [\"Ta\", \"TAR\", \"t234An\", \"cosSo\"]) == \"K.TAR\")\nassert(Strongest_Extension(class_name:\
    \ \"__HAHA\", extensions: [\"Tab\", \"123\", \"781345\", \"-_-\"]) == \"__HAHA.123\"\
    )\nassert(Strongest_Extension(class_name: \"YameRore\", extensions: [\"HhAas\"\
    , \"okIWILL123\", \"WorkOut\", \"Fails\", \"-_-\"]) == \"YameRore.okIWILL123\"\
    )\nassert(Strongest_Extension(class_name: \"finNNalLLly\", extensions: [\"Die\"\
    , \"NowW\", \"Wow\", \"WoW\"]) == \"finNNalLLly.WoW\")\nassert(Strongest_Extension(class_name:\
    \ \"_\", extensions: [\"Bb\", \"91245\"]) == \"_.Bb\")\nassert(Strongest_Extension(class_name:\
    \ \"Sp\", extensions: [\"671235\", \"Bb\"]) == \"Sp.671235\")"
  status: SyntaxError
  stderr: "/tmp/tmpq0ch_q70.swift:27:32: error: 'characters' is unavailable: Please\
    \ use String directly\n        for j in extensions[i].characters {\n         \
    \                      ^~~~~~~~~~\nSwift.String:5:16: note: 'characters' was obsoleted\
    \ in Swift 5.0\n    public var characters: String { get set }\n              \
    \ ^\n/tmp/tmpq0ch_q70.swift:28:18: error: value of type 'Character' has no member\
    \ 'isUpperCase'\n            if j.isUpperCase() {\n               ~ ^~~~~~~~~~~\n"
  stdout: ''
  timestamp: 1660009433
- exit_code: -4
  program: "\n/// You will be given the name of a class (a string) and an array of\
    \ extensions.\n/// The extensions are to be used to load additional classes to\
    \ the class. The\n/// strength of the extension is as follows: Let CAP be the\
    \ number of the uppercase\n/// letters in the extension's name, and let SM be\
    \ the number of lowercase letters \n/// in the extension's name, the strength\
    \ is given by the fraction CAP - SM. \n/// You should find the strongest extension\
    \ and return a string in this \n/// format: ClassName.StrongestExtensionName.\n\
    /// If there are two or more extensions with the same strength, you should\n///\
    \ choose the one that comes first in the array.\n/// For example, if you are given\
    \ \"Slices\" as the class and an array of the\n/// extensions: ['SErviNGSliCes',\
    \ 'Cheese', 'StuFfed'] then you should\n/// return 'Slices.SErviNGSliCes' since\
    \ 'SErviNGSliCes' is the strongest extension \n/// (its strength is -1).\n///\
    \ Example:\n/// >>> Strongest_Extension(class_name: \"my_class\", extensions:\
    \ [\"AA\", \"Be\", \"CC\"])\n/// \"my_class.AA\"\nfunc Strongest_Extension(class_name:\
    \ String, extensions: [String]) -> String {\n    //! It is a good approach to\
    \ first find the strength of the strongest extension.\n    //! Then once you find\
    \ it, to return \"class_name.strongest_extension\"\n    return \"\"\n}\n\n\nfunc\
    \ ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count !=\
    \ right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(Strongest_Extension(class_name: \"Watashi\", extensions:\
    \ [\"tEN\", \"niNE\", \"eIGHt8OKe\"]) == \"Watashi.eIGHt8OKe\")\nassert(Strongest_Extension(class_name:\
    \ \"Boku123\", extensions: [\"nani\", \"NazeDa\", \"YEs.WeCaNe\", \"32145tggg\"\
    ]) == \"Boku123.YEs.WeCaNe\")\nassert(Strongest_Extension(class_name: \"__YESIMHERE\"\
    , extensions: [\"t\", \"eMptY\", \"nothing\", \"zeR00\", \"NuLl__\", \"123NoooneB321\"\
    ]) == \"__YESIMHERE.NuLl__\")\nassert(Strongest_Extension(class_name: \"K\", extensions:\
    \ [\"Ta\", \"TAR\", \"t234An\", \"cosSo\"]) == \"K.TAR\")\nassert(Strongest_Extension(class_name:\
    \ \"__HAHA\", extensions: [\"Tab\", \"123\", \"781345\", \"-_-\"]) == \"__HAHA.123\"\
    )\nassert(Strongest_Extension(class_name: \"YameRore\", extensions: [\"HhAas\"\
    , \"okIWILL123\", \"WorkOut\", \"Fails\", \"-_-\"]) == \"YameRore.okIWILL123\"\
    )\nassert(Strongest_Extension(class_name: \"finNNalLLly\", extensions: [\"Die\"\
    , \"NowW\", \"Wow\", \"WoW\"]) == \"finNNalLLly.WoW\")\nassert(Strongest_Extension(class_name:\
    \ \"_\", extensions: [\"Bb\", \"91245\"]) == \"_.Bb\")\nassert(Strongest_Extension(class_name:\
    \ \"Sp\", extensions: [\"671235\", \"Bb\"]) == \"Sp.671235\")"
  status: Exception
  stderr: 'tmpk5k67hyg/tmpk5k67hyg.swift:37: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b916ac25c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b916a91cb6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b916a91c988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b916a91b7b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpk5k67hyg                        0x0000557c17bbf4fd <unavailable> + 5373

    5    libc.so.6                          0x00002b916ae11460 __libc_start_main +
    245

    6    tmpk5k67hyg                        0x0000557c17bbf089 <unavailable> + 4233

    '
  stdout: ''
  timestamp: 1660009433
- exit_code: -4
  program: "\n/// You will be given the name of a class (a string) and an array of\
    \ extensions.\n/// The extensions are to be used to load additional classes to\
    \ the class. The\n/// strength of the extension is as follows: Let CAP be the\
    \ number of the uppercase\n/// letters in the extension's name, and let SM be\
    \ the number of lowercase letters \n/// in the extension's name, the strength\
    \ is given by the fraction CAP - SM. \n/// You should find the strongest extension\
    \ and return a string in this \n/// format: ClassName.StrongestExtensionName.\n\
    /// If there are two or more extensions with the same strength, you should\n///\
    \ choose the one that comes first in the array.\n/// For example, if you are given\
    \ \"Slices\" as the class and an array of the\n/// extensions: ['SErviNGSliCes',\
    \ 'Cheese', 'StuFfed'] then you should\n/// return 'Slices.SErviNGSliCes' since\
    \ 'SErviNGSliCes' is the strongest extension \n/// (its strength is -1).\n///\
    \ Example:\n/// >>> Strongest_Extension(class_name: \"my_class\", extensions:\
    \ [\"AA\", \"Be\", \"CC\"])\n/// \"my_class.AA\"\nfunc Strongest_Extension(class_name:\
    \ String, extensions: [String]) -> String {\n    let class_name = class_name\n\
    \    var strengths: [Double] = []\n    for string in extensions {\n        let\
    \ uppercase_letters = string.uppercased().filter { $0.isUppercase }\n        let\
    \ lowercase_letters = string.lowercased().filter { $0.isLowercase }\n        strengths.append(Double(uppercase_letters.count)\
    \ - Double(lowercase_letters.count))\n    }\n    let strongest_extension = extensions[strengths.firstIndex(of:\
    \ strengths.max()!)!]\n    return \"\\(class_name).\\(strongest_extension)\"\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(Strongest_Extension(class_name: \"Watashi\", extensions:\
    \ [\"tEN\", \"niNE\", \"eIGHt8OKe\"]) == \"Watashi.eIGHt8OKe\")\nassert(Strongest_Extension(class_name:\
    \ \"Boku123\", extensions: [\"nani\", \"NazeDa\", \"YEs.WeCaNe\", \"32145tggg\"\
    ]) == \"Boku123.YEs.WeCaNe\")\nassert(Strongest_Extension(class_name: \"__YESIMHERE\"\
    , extensions: [\"t\", \"eMptY\", \"nothing\", \"zeR00\", \"NuLl__\", \"123NoooneB321\"\
    ]) == \"__YESIMHERE.NuLl__\")\nassert(Strongest_Extension(class_name: \"K\", extensions:\
    \ [\"Ta\", \"TAR\", \"t234An\", \"cosSo\"]) == \"K.TAR\")\nassert(Strongest_Extension(class_name:\
    \ \"__HAHA\", extensions: [\"Tab\", \"123\", \"781345\", \"-_-\"]) == \"__HAHA.123\"\
    )\nassert(Strongest_Extension(class_name: \"YameRore\", extensions: [\"HhAas\"\
    , \"okIWILL123\", \"WorkOut\", \"Fails\", \"-_-\"]) == \"YameRore.okIWILL123\"\
    )\nassert(Strongest_Extension(class_name: \"finNNalLLly\", extensions: [\"Die\"\
    , \"NowW\", \"Wow\", \"WoW\"]) == \"finNNalLLly.WoW\")\nassert(Strongest_Extension(class_name:\
    \ \"_\", extensions: [\"Bb\", \"91245\"]) == \"_.Bb\")\nassert(Strongest_Extension(class_name:\
    \ \"Sp\", extensions: [\"671235\", \"Bb\"]) == \"Sp.671235\")"
  status: Exception
  stderr: 'tmpt7xncs7k/tmpt7xncs7k.swift:43: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002aca5308cc80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002aca52d83b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002aca52d83988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002aca52d827b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpt7xncs7k                        0x000055bd6e84ee3d <unavailable> + 7741

    5    libc.so.6                          0x00002aca53278460 __libc_start_main +
    245

    6    tmpt7xncs7k                        0x000055bd6e84e9c9 <unavailable> + 6601

    '
  stdout: ''
  timestamp: 1660009433
- exit_code: 1
  program: "\n/// You will be given the name of a class (a string) and an array of\
    \ extensions.\n/// The extensions are to be used to load additional classes to\
    \ the class. The\n/// strength of the extension is as follows: Let CAP be the\
    \ number of the uppercase\n/// letters in the extension's name, and let SM be\
    \ the number of lowercase letters \n/// in the extension's name, the strength\
    \ is given by the fraction CAP - SM. \n/// You should find the strongest extension\
    \ and return a string in this \n/// format: ClassName.StrongestExtensionName.\n\
    /// If there are two or more extensions with the same strength, you should\n///\
    \ choose the one that comes first in the array.\n/// For example, if you are given\
    \ \"Slices\" as the class and an array of the\n/// extensions: ['SErviNGSliCes',\
    \ 'Cheese', 'StuFfed'] then you should\n/// return 'Slices.SErviNGSliCes' since\
    \ 'SErviNGSliCes' is the strongest extension \n/// (its strength is -1).\n///\
    \ Example:\n/// >>> Strongest_Extension(class_name: \"my_class\", extensions:\
    \ [\"AA\", \"Be\", \"CC\"])\n/// \"my_class.AA\"\nfunc Strongest_Extension(class_name:\
    \ String, extensions: [String]) -> String {\n    var strongest: String = \"my_class.Be\"\
    \n    var strength: Double = 0.0\n    for extension in extensions {\n        let\
    \ strength_temp = Double(String(extension.uppercased().filter{$0.isUppercase}).count\
    \ - String(extension.lowercased().filter{$0.isLowercase}).count)\n        if strength_temp\
    \ > strength {\n            strength = strength_temp\n            strongest =\
    \ \"\\(class_name).\\(extension)\"\n        }\n    }\n    return strongest\n}\n\
    \n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(Strongest_Extension(class_name: \"Watashi\", extensions:\
    \ [\"tEN\", \"niNE\", \"eIGHt8OKe\"]) == \"Watashi.eIGHt8OKe\")\nassert(Strongest_Extension(class_name:\
    \ \"Boku123\", extensions: [\"nani\", \"NazeDa\", \"YEs.WeCaNe\", \"32145tggg\"\
    ]) == \"Boku123.YEs.WeCaNe\")\nassert(Strongest_Extension(class_name: \"__YESIMHERE\"\
    , extensions: [\"t\", \"eMptY\", \"nothing\", \"zeR00\", \"NuLl__\", \"123NoooneB321\"\
    ]) == \"__YESIMHERE.NuLl__\")\nassert(Strongest_Extension(class_name: \"K\", extensions:\
    \ [\"Ta\", \"TAR\", \"t234An\", \"cosSo\"]) == \"K.TAR\")\nassert(Strongest_Extension(class_name:\
    \ \"__HAHA\", extensions: [\"Tab\", \"123\", \"781345\", \"-_-\"]) == \"__HAHA.123\"\
    )\nassert(Strongest_Extension(class_name: \"YameRore\", extensions: [\"HhAas\"\
    , \"okIWILL123\", \"WorkOut\", \"Fails\", \"-_-\"]) == \"YameRore.okIWILL123\"\
    )\nassert(Strongest_Extension(class_name: \"finNNalLLly\", extensions: [\"Die\"\
    , \"NowW\", \"Wow\", \"WoW\"]) == \"finNNalLLly.WoW\")\nassert(Strongest_Extension(class_name:\
    \ \"_\", extensions: [\"Bb\", \"91245\"]) == \"_.Bb\")\nassert(Strongest_Extension(class_name:\
    \ \"Sp\", extensions: [\"671235\", \"Bb\"]) == \"Sp.671235\")"
  status: SyntaxError
  stderr: "/tmp/tmpyp3gfxax.swift:21:9: error: expected pattern\n    for extension\
    \ in extensions {\n        ^\n/tmp/tmpyp3gfxax.swift:21:9: error: expected Sequence\
    \ expression for for-each loop\n    for extension in extensions {\n        ^\n\
    /tmp/tmpyp3gfxax.swift:21:9: error: expected '{' to start the body of for-each\
    \ loop\n    for extension in extensions {\n        ^\n/tmp/tmpyp3gfxax.swift:22:43:\
    \ error: expected expression in list of expressions\n        let strength_temp\
    \ = Double(String(extension.uppercased().filter{$0.isUppercase}).count - String(extension.lowercased().filter{$0.isLowercase}).count)\n\
    \                                          ^\n/tmp/tmpyp3gfxax.swift:22:43: error:\
    \ consecutive statements on a line must be separated by ';'\n        let strength_temp\
    \ = Double(String(extension.uppercased().filter{$0.isUppercase}).count - String(extension.lowercased().filter{$0.isLowercase}).count)\n\
    \                                          ^\n                               \
    \           ;\n/tmp/tmpyp3gfxax.swift:22:52: error: expected type name in extension\
    \ declaration\n        let strength_temp = Double(String(extension.uppercased().filter{$0.isUppercase}).count\
    \ - String(extension.lowercased().filter{$0.isLowercase}).count)\n           \
    \                                        ^\n/tmp/tmpyp3gfxax.swift:22:52: error:\
    \ expected '{' in extension\n        let strength_temp = Double(String(extension.uppercased().filter{$0.isUppercase}).count\
    \ - String(extension.lowercased().filter{$0.isLowercase}).count)\n           \
    \                                        ^\n/tmp/tmpyp3gfxax.swift:22:43: error:\
    \ declaration is only valid at file scope\n        let strength_temp = Double(String(extension.uppercased().filter{$0.isUppercase}).count\
    \ - String(extension.lowercased().filter{$0.isLowercase}).count)\n           \
    \                               ^\n/tmp/tmpyp3gfxax.swift:25:42: error: expected\
    \ expression in list of expressions\n            strongest = \"\\(class_name).\\\
    (extension)\"\n                                         ^\n"
  stdout: ''
  timestamp: 1660009433
- exit_code: -4
  program: "\n/// You will be given the name of a class (a string) and an array of\
    \ extensions.\n/// The extensions are to be used to load additional classes to\
    \ the class. The\n/// strength of the extension is as follows: Let CAP be the\
    \ number of the uppercase\n/// letters in the extension's name, and let SM be\
    \ the number of lowercase letters \n/// in the extension's name, the strength\
    \ is given by the fraction CAP - SM. \n/// You should find the strongest extension\
    \ and return a string in this \n/// format: ClassName.StrongestExtensionName.\n\
    /// If there are two or more extensions with the same strength, you should\n///\
    \ choose the one that comes first in the array.\n/// For example, if you are given\
    \ \"Slices\" as the class and an array of the\n/// extensions: ['SErviNGSliCes',\
    \ 'Cheese', 'StuFfed'] then you should\n/// return 'Slices.SErviNGSliCes' since\
    \ 'SErviNGSliCes' is the strongest extension \n/// (its strength is -1).\n///\
    \ Example:\n/// >>> Strongest_Extension(class_name: \"my_class\", extensions:\
    \ [\"AA\", \"Be\", \"CC\"])\n/// \"my_class.AA\"\nfunc Strongest_Extension(class_name:\
    \ String, extensions: [String]) -> String {\n\t// Write your code here.\n\treturn\
    \ \"\"\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n  \
    \  if left.count != right.count {\n        return false\n    }\n    for (l, r)\
    \ in zip(left, right) {\n        if l != r {\n            return false\n     \
    \   }\n    }\n    return true\n}\n            \nassert(Strongest_Extension(class_name:\
    \ \"Watashi\", extensions: [\"tEN\", \"niNE\", \"eIGHt8OKe\"]) == \"Watashi.eIGHt8OKe\"\
    )\nassert(Strongest_Extension(class_name: \"Boku123\", extensions: [\"nani\",\
    \ \"NazeDa\", \"YEs.WeCaNe\", \"32145tggg\"]) == \"Boku123.YEs.WeCaNe\")\nassert(Strongest_Extension(class_name:\
    \ \"__YESIMHERE\", extensions: [\"t\", \"eMptY\", \"nothing\", \"zeR00\", \"NuLl__\"\
    , \"123NoooneB321\"]) == \"__YESIMHERE.NuLl__\")\nassert(Strongest_Extension(class_name:\
    \ \"K\", extensions: [\"Ta\", \"TAR\", \"t234An\", \"cosSo\"]) == \"K.TAR\")\n\
    assert(Strongest_Extension(class_name: \"__HAHA\", extensions: [\"Tab\", \"123\"\
    , \"781345\", \"-_-\"]) == \"__HAHA.123\")\nassert(Strongest_Extension(class_name:\
    \ \"YameRore\", extensions: [\"HhAas\", \"okIWILL123\", \"WorkOut\", \"Fails\"\
    , \"-_-\"]) == \"YameRore.okIWILL123\")\nassert(Strongest_Extension(class_name:\
    \ \"finNNalLLly\", extensions: [\"Die\", \"NowW\", \"Wow\", \"WoW\"]) == \"finNNalLLly.WoW\"\
    )\nassert(Strongest_Extension(class_name: \"_\", extensions: [\"Bb\", \"91245\"\
    ]) == \"_.Bb\")\nassert(Strongest_Extension(class_name: \"Sp\", extensions: [\"\
    671235\", \"Bb\"]) == \"Sp.671235\")"
  status: Exception
  stderr: 'tmp2b5y3ln3/tmp2b5y3ln3.swift:36: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b7d58025c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b7d57d1cb6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b7d57d1c988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b7d57d1b7b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmp2b5y3ln3                        0x000055a95abc84fd <unavailable> + 5373

    5    libc.so.6                          0x00002b7d58211460 __libc_start_main +
    245

    6    tmp2b5y3ln3                        0x000055a95abc8089 <unavailable> + 4233

    '
  stdout: ''
  timestamp: 1660009433
- exit_code: -4
  program: "\n/// You will be given the name of a class (a string) and an array of\
    \ extensions.\n/// The extensions are to be used to load additional classes to\
    \ the class. The\n/// strength of the extension is as follows: Let CAP be the\
    \ number of the uppercase\n/// letters in the extension's name, and let SM be\
    \ the number of lowercase letters \n/// in the extension's name, the strength\
    \ is given by the fraction CAP - SM. \n/// You should find the strongest extension\
    \ and return a string in this \n/// format: ClassName.StrongestExtensionName.\n\
    /// If there are two or more extensions with the same strength, you should\n///\
    \ choose the one that comes first in the array.\n/// For example, if you are given\
    \ \"Slices\" as the class and an array of the\n/// extensions: ['SErviNGSliCes',\
    \ 'Cheese', 'StuFfed'] then you should\n/// return 'Slices.SErviNGSliCes' since\
    \ 'SErviNGSliCes' is the strongest extension \n/// (its strength is -1).\n///\
    \ Example:\n/// >>> Strongest_Extension(class_name: \"my_class\", extensions:\
    \ [\"AA\", \"Be\", \"CC\"])\n/// \"my_class.AA\"\nfunc Strongest_Extension(class_name:\
    \ String, extensions: [String]) -> String {\n    // \u2193\u2193\u2193\u2193 your\
    \ code goes here \u2193\u2193\u2193\u2193\n    var new_class = [String]()\n  \
    \  var max = 0\n    var value = 0\n    for ext in extensions {\n        for letter\
    \ in ext {\n            if letter.isUppercase {\n                value += 1\n\
    \            }\n            else {\n                value -= 1\n            }\n\
    \        }\n        if value > max {\n            max = value\n            new_class.removeAll()\n\
    \            new_class.append(ext)\n        }\n        else if value == max {\n\
    \            new_class.append(ext)\n        }\n        value = 0\n    }\n    new_class.sort()\n\
    \    return \"\\(class_name).\\(new_class[0])\"\n}\n\n\nfunc ==(left: [(Int, Int)],\
    \ right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n       \
    \ return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r\
    \ {\n            return false\n        }\n    }\n    return true\n}\n        \
    \    \nassert(Strongest_Extension(class_name: \"Watashi\", extensions: [\"tEN\"\
    , \"niNE\", \"eIGHt8OKe\"]) == \"Watashi.eIGHt8OKe\")\nassert(Strongest_Extension(class_name:\
    \ \"Boku123\", extensions: [\"nani\", \"NazeDa\", \"YEs.WeCaNe\", \"32145tggg\"\
    ]) == \"Boku123.YEs.WeCaNe\")\nassert(Strongest_Extension(class_name: \"__YESIMHERE\"\
    , extensions: [\"t\", \"eMptY\", \"nothing\", \"zeR00\", \"NuLl__\", \"123NoooneB321\"\
    ]) == \"__YESIMHERE.NuLl__\")\nassert(Strongest_Extension(class_name: \"K\", extensions:\
    \ [\"Ta\", \"TAR\", \"t234An\", \"cosSo\"]) == \"K.TAR\")\nassert(Strongest_Extension(class_name:\
    \ \"__HAHA\", extensions: [\"Tab\", \"123\", \"781345\", \"-_-\"]) == \"__HAHA.123\"\
    )\nassert(Strongest_Extension(class_name: \"YameRore\", extensions: [\"HhAas\"\
    , \"okIWILL123\", \"WorkOut\", \"Fails\", \"-_-\"]) == \"YameRore.okIWILL123\"\
    )\nassert(Strongest_Extension(class_name: \"finNNalLLly\", extensions: [\"Die\"\
    , \"NowW\", \"Wow\", \"WoW\"]) == \"finNNalLLly.WoW\")\nassert(Strongest_Extension(class_name:\
    \ \"_\", extensions: [\"Bb\", \"91245\"]) == \"_.Bb\")\nassert(Strongest_Extension(class_name:\
    \ \"Sp\", extensions: [\"671235\", \"Bb\"]) == \"Sp.671235\")"
  status: Exception
  stderr: 'Swift/ContiguousArrayBuffer.swift:600: Fatal error: Index out of range

    Current stack trace:

    0    libswiftCore.so                    0x00002baa83014c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002baa82d0b561 <unavailable> + 1434977

    2    libswiftCore.so                    0x00002baa82d0b286 <unavailable> + 1434246

    3    libswiftCore.so                    0x00002baa82d0b13c <unavailable> + 1433916

    4    libswiftCore.so                    0x00002baa82d0abb0 _assertionFailure(_:_:file:line:flags:)
    + 251

    5    libswiftSwiftOnoneSupport.so       0x00002baa82b0afc3 <unavailable> + 188355

    6    tmpb77lw06j                        0x000055ca2fb9b315 <unavailable> + 13077

    7    tmpb77lw06j                        0x000055ca2fb9a0bf <unavailable> + 8383

    8    libc.so.6                          0x00002baa83200460 __libc_start_main +
    245

    9    tmpb77lw06j                        0x000055ca2fb998c9 <unavailable> + 6345

    '
  stdout: ''
  timestamp: 1660009433
- exit_code: -4
  program: "\n/// You will be given the name of a class (a string) and an array of\
    \ extensions.\n/// The extensions are to be used to load additional classes to\
    \ the class. The\n/// strength of the extension is as follows: Let CAP be the\
    \ number of the uppercase\n/// letters in the extension's name, and let SM be\
    \ the number of lowercase letters \n/// in the extension's name, the strength\
    \ is given by the fraction CAP - SM. \n/// You should find the strongest extension\
    \ and return a string in this \n/// format: ClassName.StrongestExtensionName.\n\
    /// If there are two or more extensions with the same strength, you should\n///\
    \ choose the one that comes first in the array.\n/// For example, if you are given\
    \ \"Slices\" as the class and an array of the\n/// extensions: ['SErviNGSliCes',\
    \ 'Cheese', 'StuFfed'] then you should\n/// return 'Slices.SErviNGSliCes' since\
    \ 'SErviNGSliCes' is the strongest extension \n/// (its strength is -1).\n///\
    \ Example:\n/// >>> Strongest_Extension(class_name: \"my_class\", extensions:\
    \ [\"AA\", \"Be\", \"CC\"])\n/// \"my_class.AA\"\nfunc Strongest_Extension(class_name:\
    \ String, extensions: [String]) -> String {\n    let className = class_name\n\
    \    var biggestDiff = 0\n    var strongestExtension = \"\"\n    for element in\
    \ extensions {\n        let upperCaseCount = element.filter{ $0.isUppercase }.count\n\
    \        let lowerCaseCount = element.filter{ $0.isLowercase }.count\n       \
    \ let difference = upperCaseCount - lowerCaseCount\n        if difference > biggestDiff\
    \ {\n            biggestDiff = difference\n            strongestExtension = element\n\
    \        }\n    }\n    return \"\\(className).\\(strongestExtension)\"\n}\n\n\n\
    func ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(Strongest_Extension(class_name: \"Watashi\", extensions:\
    \ [\"tEN\", \"niNE\", \"eIGHt8OKe\"]) == \"Watashi.eIGHt8OKe\")\nassert(Strongest_Extension(class_name:\
    \ \"Boku123\", extensions: [\"nani\", \"NazeDa\", \"YEs.WeCaNe\", \"32145tggg\"\
    ]) == \"Boku123.YEs.WeCaNe\")\nassert(Strongest_Extension(class_name: \"__YESIMHERE\"\
    , extensions: [\"t\", \"eMptY\", \"nothing\", \"zeR00\", \"NuLl__\", \"123NoooneB321\"\
    ]) == \"__YESIMHERE.NuLl__\")\nassert(Strongest_Extension(class_name: \"K\", extensions:\
    \ [\"Ta\", \"TAR\", \"t234An\", \"cosSo\"]) == \"K.TAR\")\nassert(Strongest_Extension(class_name:\
    \ \"__HAHA\", extensions: [\"Tab\", \"123\", \"781345\", \"-_-\"]) == \"__HAHA.123\"\
    )\nassert(Strongest_Extension(class_name: \"YameRore\", extensions: [\"HhAas\"\
    , \"okIWILL123\", \"WorkOut\", \"Fails\", \"-_-\"]) == \"YameRore.okIWILL123\"\
    )\nassert(Strongest_Extension(class_name: \"finNNalLLly\", extensions: [\"Die\"\
    , \"NowW\", \"Wow\", \"WoW\"]) == \"finNNalLLly.WoW\")\nassert(Strongest_Extension(class_name:\
    \ \"_\", extensions: [\"Bb\", \"91245\"]) == \"_.Bb\")\nassert(Strongest_Extension(class_name:\
    \ \"Sp\", extensions: [\"671235\", \"Bb\"]) == \"Sp.671235\")"
  status: Exception
  stderr: 'tmp5_yhs4ra/tmp5_yhs4ra.swift:49: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002aaac0645c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002aaac033cb6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002aaac033c988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002aaac033b7b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmp5_yhs4ra                        0x0000558bb43ddf4c <unavailable> + 8012

    5    libc.so.6                          0x00002aaac0831460 __libc_start_main +
    245

    6    tmp5_yhs4ra                        0x0000558bb43dd659 <unavailable> + 5721

    '
  stdout: ''
  timestamp: 1660009433
- exit_code: -4
  program: "\n/// You will be given the name of a class (a string) and an array of\
    \ extensions.\n/// The extensions are to be used to load additional classes to\
    \ the class. The\n/// strength of the extension is as follows: Let CAP be the\
    \ number of the uppercase\n/// letters in the extension's name, and let SM be\
    \ the number of lowercase letters \n/// in the extension's name, the strength\
    \ is given by the fraction CAP - SM. \n/// You should find the strongest extension\
    \ and return a string in this \n/// format: ClassName.StrongestExtensionName.\n\
    /// If there are two or more extensions with the same strength, you should\n///\
    \ choose the one that comes first in the array.\n/// For example, if you are given\
    \ \"Slices\" as the class and an array of the\n/// extensions: ['SErviNGSliCes',\
    \ 'Cheese', 'StuFfed'] then you should\n/// return 'Slices.SErviNGSliCes' since\
    \ 'SErviNGSliCes' is the strongest extension \n/// (its strength is -1).\n///\
    \ Example:\n/// >>> Strongest_Extension(class_name: \"my_class\", extensions:\
    \ [\"AA\", \"Be\", \"CC\"])\n/// \"my_class.AA\"\nfunc Strongest_Extension(class_name:\
    \ String, extensions: [String]) -> String {\n\treturn \"\"\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(Strongest_Extension(class_name: \"Watashi\", extensions:\
    \ [\"tEN\", \"niNE\", \"eIGHt8OKe\"]) == \"Watashi.eIGHt8OKe\")\nassert(Strongest_Extension(class_name:\
    \ \"Boku123\", extensions: [\"nani\", \"NazeDa\", \"YEs.WeCaNe\", \"32145tggg\"\
    ]) == \"Boku123.YEs.WeCaNe\")\nassert(Strongest_Extension(class_name: \"__YESIMHERE\"\
    , extensions: [\"t\", \"eMptY\", \"nothing\", \"zeR00\", \"NuLl__\", \"123NoooneB321\"\
    ]) == \"__YESIMHERE.NuLl__\")\nassert(Strongest_Extension(class_name: \"K\", extensions:\
    \ [\"Ta\", \"TAR\", \"t234An\", \"cosSo\"]) == \"K.TAR\")\nassert(Strongest_Extension(class_name:\
    \ \"__HAHA\", extensions: [\"Tab\", \"123\", \"781345\", \"-_-\"]) == \"__HAHA.123\"\
    )\nassert(Strongest_Extension(class_name: \"YameRore\", extensions: [\"HhAas\"\
    , \"okIWILL123\", \"WorkOut\", \"Fails\", \"-_-\"]) == \"YameRore.okIWILL123\"\
    )\nassert(Strongest_Extension(class_name: \"finNNalLLly\", extensions: [\"Die\"\
    , \"NowW\", \"Wow\", \"WoW\"]) == \"finNNalLLly.WoW\")\nassert(Strongest_Extension(class_name:\
    \ \"_\", extensions: [\"Bb\", \"91245\"]) == \"_.Bb\")\nassert(Strongest_Extension(class_name:\
    \ \"Sp\", extensions: [\"671235\", \"Bb\"]) == \"Sp.671235\")"
  status: Exception
  stderr: 'tmpozbdndmc/tmpozbdndmc.swift:35: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002acc95275c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002acc94f6cb6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002acc94f6c988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002acc94f6b7b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpozbdndmc                        0x000055c3068954fd <unavailable> + 5373

    5    libc.so.6                          0x00002acc95461460 __libc_start_main +
    245

    6    tmpozbdndmc                        0x000055c306895089 <unavailable> + 4233

    '
  stdout: ''
  timestamp: 1660009433
- exit_code: 1
  program: "\n/// You will be given the name of a class (a string) and an array of\
    \ extensions.\n/// The extensions are to be used to load additional classes to\
    \ the class. The\n/// strength of the extension is as follows: Let CAP be the\
    \ number of the uppercase\n/// letters in the extension's name, and let SM be\
    \ the number of lowercase letters \n/// in the extension's name, the strength\
    \ is given by the fraction CAP - SM. \n/// You should find the strongest extension\
    \ and return a string in this \n/// format: ClassName.StrongestExtensionName.\n\
    /// If there are two or more extensions with the same strength, you should\n///\
    \ choose the one that comes first in the array.\n/// For example, if you are given\
    \ \"Slices\" as the class and an array of the\n/// extensions: ['SErviNGSliCes',\
    \ 'Cheese', 'StuFfed'] then you should\n/// return 'Slices.SErviNGSliCes' since\
    \ 'SErviNGSliCes' is the strongest extension \n/// (its strength is -1).\n///\
    \ Example:\n/// >>> Strongest_Extension(class_name: \"my_class\", extensions:\
    \ [\"AA\", \"Be\", \"CC\"])\n/// \"my_class.AA\"\nfunc Strongest_Extension(class_name:\
    \ String, extensions: [String]) -> String {\n    var strongest_extension = extensions[0]\n\
    \    var strongest_extension_strength = Strength(extension: extensions[0])\n \
    \   for ext in extensions[1..<extensions.count] {\n        let strength = Strength(extension:\
    \ ext)\n        if strength > strongest_extension_strength {\n            strongest_extension\
    \ = ext\n            strongest_extension_strength = strength\n        }\n    }\n\
    \    return \"\\(class_name).\\(strongest_extension)\"\n}\n\n\nfunc ==(left: [(Int,\
    \ Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n\
    \        return false\n    }\n    for (l, r) in zip(left, right) {\n        if\
    \ l != r {\n            return false\n        }\n    }\n    return true\n}\n \
    \           \nassert(Strongest_Extension(class_name: \"Watashi\", extensions:\
    \ [\"tEN\", \"niNE\", \"eIGHt8OKe\"]) == \"Watashi.eIGHt8OKe\")\nassert(Strongest_Extension(class_name:\
    \ \"Boku123\", extensions: [\"nani\", \"NazeDa\", \"YEs.WeCaNe\", \"32145tggg\"\
    ]) == \"Boku123.YEs.WeCaNe\")\nassert(Strongest_Extension(class_name: \"__YESIMHERE\"\
    , extensions: [\"t\", \"eMptY\", \"nothing\", \"zeR00\", \"NuLl__\", \"123NoooneB321\"\
    ]) == \"__YESIMHERE.NuLl__\")\nassert(Strongest_Extension(class_name: \"K\", extensions:\
    \ [\"Ta\", \"TAR\", \"t234An\", \"cosSo\"]) == \"K.TAR\")\nassert(Strongest_Extension(class_name:\
    \ \"__HAHA\", extensions: [\"Tab\", \"123\", \"781345\", \"-_-\"]) == \"__HAHA.123\"\
    )\nassert(Strongest_Extension(class_name: \"YameRore\", extensions: [\"HhAas\"\
    , \"okIWILL123\", \"WorkOut\", \"Fails\", \"-_-\"]) == \"YameRore.okIWILL123\"\
    )\nassert(Strongest_Extension(class_name: \"finNNalLLly\", extensions: [\"Die\"\
    , \"NowW\", \"Wow\", \"WoW\"]) == \"finNNalLLly.WoW\")\nassert(Strongest_Extension(class_name:\
    \ \"_\", extensions: [\"Bb\", \"91245\"]) == \"_.Bb\")\nassert(Strongest_Extension(class_name:\
    \ \"Sp\", extensions: [\"671235\", \"Bb\"]) == \"Sp.671235\")"
  status: SyntaxError
  stderr: "/tmp/tmpxbb0bjvw.swift:20:40: error: cannot find 'Strength' in scope\n\
    \    var strongest_extension_strength = Strength(extension: extensions[0])\n \
    \                                      ^~~~~~~~\n/tmp/tmpxbb0bjvw.swift:22:24:\
    \ error: cannot find 'Strength' in scope\n        let strength = Strength(extension:\
    \ ext)\n                       ^~~~~~~~\n"
  stdout: ''
  timestamp: 1660009433
- exit_code: -4
  program: "\n/// You will be given the name of a class (a string) and an array of\
    \ extensions.\n/// The extensions are to be used to load additional classes to\
    \ the class. The\n/// strength of the extension is as follows: Let CAP be the\
    \ number of the uppercase\n/// letters in the extension's name, and let SM be\
    \ the number of lowercase letters \n/// in the extension's name, the strength\
    \ is given by the fraction CAP - SM. \n/// You should find the strongest extension\
    \ and return a string in this \n/// format: ClassName.StrongestExtensionName.\n\
    /// If there are two or more extensions with the same strength, you should\n///\
    \ choose the one that comes first in the array.\n/// For example, if you are given\
    \ \"Slices\" as the class and an array of the\n/// extensions: ['SErviNGSliCes',\
    \ 'Cheese', 'StuFfed'] then you should\n/// return 'Slices.SErviNGSliCes' since\
    \ 'SErviNGSliCes' is the strongest extension \n/// (its strength is -1).\n///\
    \ Example:\n/// >>> Strongest_Extension(class_name: \"my_class\", extensions:\
    \ [\"AA\", \"Be\", \"CC\"])\n/// \"my_class.AA\"\nfunc Strongest_Extension(class_name:\
    \ String, extensions: [String]) -> String {\n    let class_name = class_name\n\
    \    var strengths = [Double]()\n    var names = [String]()\n    var max_strength\
    \ = 0.0\n    var max_strength_name = \"\"\n    for (index, element) in extensions.enumerated()\
    \ {\n        var upper_case_count = 0\n        var lower_case_count = 0\n    \
    \    for letter in element {\n            if letter.isUppercase {\n          \
    \      upper_case_count += 1\n            } else {\n                lower_case_count\
    \ += 1\n            }\n        }\n        var strength = Double(upper_case_count)\
    \ - Double(lower_case_count)\n        strength = strength == 0 ? 0.0 : strength\n\
    \        strengths.append(strength)\n        names.append(element)\n        if\
    \ strength == max_strength {\n            let name_length_1 = names[index - 1].count\n\
    \            let name_length_2 = names[index].count\n            if name_length_1\
    \ > name_length_2 {\n                max_strength_name = names[index]\n      \
    \      } else {\n                max_strength_name = names[index - 1]\n      \
    \      }\n        } else if strength > max_strength {\n            max_strength\
    \ = strength\n            max_strength_name = names[index]\n        }\n    }\n\
    \    let final_result = \"\\(class_name).\\(max_strength_name)\"\n    return final_result\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(Strongest_Extension(class_name: \"Watashi\", extensions:\
    \ [\"tEN\", \"niNE\", \"eIGHt8OKe\"]) == \"Watashi.eIGHt8OKe\")\nassert(Strongest_Extension(class_name:\
    \ \"Boku123\", extensions: [\"nani\", \"NazeDa\", \"YEs.WeCaNe\", \"32145tggg\"\
    ]) == \"Boku123.YEs.WeCaNe\")\nassert(Strongest_Extension(class_name: \"__YESIMHERE\"\
    , extensions: [\"t\", \"eMptY\", \"nothing\", \"zeR00\", \"NuLl__\", \"123NoooneB321\"\
    ]) == \"__YESIMHERE.NuLl__\")\nassert(Strongest_Extension(class_name: \"K\", extensions:\
    \ [\"Ta\", \"TAR\", \"t234An\", \"cosSo\"]) == \"K.TAR\")\nassert(Strongest_Extension(class_name:\
    \ \"__HAHA\", extensions: [\"Tab\", \"123\", \"781345\", \"-_-\"]) == \"__HAHA.123\"\
    )\nassert(Strongest_Extension(class_name: \"YameRore\", extensions: [\"HhAas\"\
    , \"okIWILL123\", \"WorkOut\", \"Fails\", \"-_-\"]) == \"YameRore.okIWILL123\"\
    )\nassert(Strongest_Extension(class_name: \"finNNalLLly\", extensions: [\"Die\"\
    , \"NowW\", \"Wow\", \"WoW\"]) == \"finNNalLLly.WoW\")\nassert(Strongest_Extension(class_name:\
    \ \"_\", extensions: [\"Bb\", \"91245\"]) == \"_.Bb\")\nassert(Strongest_Extension(class_name:\
    \ \"Sp\", extensions: [\"671235\", \"Bb\"]) == \"Sp.671235\")"
  status: Exception
  stderr: 'tmpltnax0gm/tmpltnax0gm.swift:68: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002ac77d2aac80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002ac77cfa1b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002ac77cfa1988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002ac77cfa07b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpltnax0gm                        0x00005645313aaced <unavailable> + 7405

    5    libc.so.6                          0x00002ac77d496460 __libc_start_main +
    245

    6    tmpltnax0gm                        0x00005645313aa879 <unavailable> + 6265

    '
  stdout: ''
  timestamp: 1660009433
- exit_code: -4
  program: "\n/// You will be given the name of a class (a string) and an array of\
    \ extensions.\n/// The extensions are to be used to load additional classes to\
    \ the class. The\n/// strength of the extension is as follows: Let CAP be the\
    \ number of the uppercase\n/// letters in the extension's name, and let SM be\
    \ the number of lowercase letters \n/// in the extension's name, the strength\
    \ is given by the fraction CAP - SM. \n/// You should find the strongest extension\
    \ and return a string in this \n/// format: ClassName.StrongestExtensionName.\n\
    /// If there are two or more extensions with the same strength, you should\n///\
    \ choose the one that comes first in the array.\n/// For example, if you are given\
    \ \"Slices\" as the class and an array of the\n/// extensions: ['SErviNGSliCes',\
    \ 'Cheese', 'StuFfed'] then you should\n/// return 'Slices.SErviNGSliCes' since\
    \ 'SErviNGSliCes' is the strongest extension \n/// (its strength is -1).\n///\
    \ Example:\n/// >>> Strongest_Extension(class_name: \"my_class\", extensions:\
    \ [\"AA\", \"Be\", \"CC\"])\n/// \"my_class.AA\"\nfunc Strongest_Extension(class_name:\
    \ String, extensions: [String]) -> String {\n    let num_uppercase = { (word:\
    \ String) -> Int in\n        return word.filter({ (char: Character) -> Bool in\n\
    \            return char.isUppercase\n        }).count\n    }\n    let num_lowercase\
    \ = { (word: String) -> Int in\n        return word.filter({ (char: Character)\
    \ -> Bool in\n            return char.isLowercase\n        }).count\n    }\n \
    \   var strongest_extension = extensions[0]\n    var strongest_strength = (Double(num_uppercase(strongest_extension))\
    \ / Double(num_lowercase(strongest_extension)))\n    for index in 1..<extensions.count\
    \ {\n        let strength = (Double(num_uppercase(extensions[index])) / Double(num_lowercase(extensions[index])))\n\
    \        if strength > strongest_strength {\n            strongest_strength =\
    \ strength\n            strongest_extension = extensions[index]\n        }\n \
    \   }\n    return \"\\(class_name).\\(strongest_extension)\"\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(Strongest_Extension(class_name: \"Watashi\", extensions:\
    \ [\"tEN\", \"niNE\", \"eIGHt8OKe\"]) == \"Watashi.eIGHt8OKe\")\nassert(Strongest_Extension(class_name:\
    \ \"Boku123\", extensions: [\"nani\", \"NazeDa\", \"YEs.WeCaNe\", \"32145tggg\"\
    ]) == \"Boku123.YEs.WeCaNe\")\nassert(Strongest_Extension(class_name: \"__YESIMHERE\"\
    , extensions: [\"t\", \"eMptY\", \"nothing\", \"zeR00\", \"NuLl__\", \"123NoooneB321\"\
    ]) == \"__YESIMHERE.NuLl__\")\nassert(Strongest_Extension(class_name: \"K\", extensions:\
    \ [\"Ta\", \"TAR\", \"t234An\", \"cosSo\"]) == \"K.TAR\")\nassert(Strongest_Extension(class_name:\
    \ \"__HAHA\", extensions: [\"Tab\", \"123\", \"781345\", \"-_-\"]) == \"__HAHA.123\"\
    )\nassert(Strongest_Extension(class_name: \"YameRore\", extensions: [\"HhAas\"\
    , \"okIWILL123\", \"WorkOut\", \"Fails\", \"-_-\"]) == \"YameRore.okIWILL123\"\
    )\nassert(Strongest_Extension(class_name: \"finNNalLLly\", extensions: [\"Die\"\
    , \"NowW\", \"Wow\", \"WoW\"]) == \"finNNalLLly.WoW\")\nassert(Strongest_Extension(class_name:\
    \ \"_\", extensions: [\"Bb\", \"91245\"]) == \"_.Bb\")\nassert(Strongest_Extension(class_name:\
    \ \"Sp\", extensions: [\"671235\", \"Bb\"]) == \"Sp.671235\")"
  status: Exception
  stderr: 'tmp3zecbvgd/tmp3zecbvgd.swift:54: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b30ce61dc80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b30ce314b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b30ce314988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b30ce3137b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmp3zecbvgd                        0x000055a38d883b9d <unavailable> + 7069

    5    libc.so.6                          0x00002b30ce809460 __libc_start_main +
    245

    6    tmp3zecbvgd                        0x000055a38d883729 <unavailable> + 5929

    '
  stdout: ''
  timestamp: 1660009433
- exit_code: -4
  program: "\n/// You will be given the name of a class (a string) and an array of\
    \ extensions.\n/// The extensions are to be used to load additional classes to\
    \ the class. The\n/// strength of the extension is as follows: Let CAP be the\
    \ number of the uppercase\n/// letters in the extension's name, and let SM be\
    \ the number of lowercase letters \n/// in the extension's name, the strength\
    \ is given by the fraction CAP - SM. \n/// You should find the strongest extension\
    \ and return a string in this \n/// format: ClassName.StrongestExtensionName.\n\
    /// If there are two or more extensions with the same strength, you should\n///\
    \ choose the one that comes first in the array.\n/// For example, if you are given\
    \ \"Slices\" as the class and an array of the\n/// extensions: ['SErviNGSliCes',\
    \ 'Cheese', 'StuFfed'] then you should\n/// return 'Slices.SErviNGSliCes' since\
    \ 'SErviNGSliCes' is the strongest extension \n/// (its strength is -1).\n///\
    \ Example:\n/// >>> Strongest_Extension(class_name: \"my_class\", extensions:\
    \ [\"AA\", \"Be\", \"CC\"])\n/// \"my_class.AA\"\nfunc Strongest_Extension(class_name:\
    \ String, extensions: [String]) -> String {\n    var strongest: Int = 0\n    var\
    \ strongest_extension: String = \"\"\n    for extension_name in extensions {\n\
    \        var cap_count: Int = 0\n        var sm_count: Int = 0\n        for char\
    \ in extension_name {\n            if char.isUppercase {\n                cap_count\
    \ += 1\n            } else {\n                sm_count += 1\n            }\n \
    \       }\n        if cap_count - sm_count > strongest {\n            strongest\
    \ = cap_count - sm_count\n            strongest_extension = extension_name\n \
    \       }\n    }\n    return \"\\(class_name).\\(strongest_extension)\"\n}\n\n\
    \nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(Strongest_Extension(class_name: \"Watashi\", extensions:\
    \ [\"tEN\", \"niNE\", \"eIGHt8OKe\"]) == \"Watashi.eIGHt8OKe\")\nassert(Strongest_Extension(class_name:\
    \ \"Boku123\", extensions: [\"nani\", \"NazeDa\", \"YEs.WeCaNe\", \"32145tggg\"\
    ]) == \"Boku123.YEs.WeCaNe\")\nassert(Strongest_Extension(class_name: \"__YESIMHERE\"\
    , extensions: [\"t\", \"eMptY\", \"nothing\", \"zeR00\", \"NuLl__\", \"123NoooneB321\"\
    ]) == \"__YESIMHERE.NuLl__\")\nassert(Strongest_Extension(class_name: \"K\", extensions:\
    \ [\"Ta\", \"TAR\", \"t234An\", \"cosSo\"]) == \"K.TAR\")\nassert(Strongest_Extension(class_name:\
    \ \"__HAHA\", extensions: [\"Tab\", \"123\", \"781345\", \"-_-\"]) == \"__HAHA.123\"\
    )\nassert(Strongest_Extension(class_name: \"YameRore\", extensions: [\"HhAas\"\
    , \"okIWILL123\", \"WorkOut\", \"Fails\", \"-_-\"]) == \"YameRore.okIWILL123\"\
    )\nassert(Strongest_Extension(class_name: \"finNNalLLly\", extensions: [\"Die\"\
    , \"NowW\", \"Wow\", \"WoW\"]) == \"finNNalLLly.WoW\")\nassert(Strongest_Extension(class_name:\
    \ \"_\", extensions: [\"Bb\", \"91245\"]) == \"_.Bb\")\nassert(Strongest_Extension(class_name:\
    \ \"Sp\", extensions: [\"671235\", \"Bb\"]) == \"Sp.671235\")"
  status: Exception
  stderr: 'tmphdfjixeg/tmphdfjixeg.swift:52: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b2322a97c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b232278eb6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b232278e988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b232278d7b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmphdfjixeg                        0x000055a9c8ff5a3d <unavailable> + 6717

    5    libc.so.6                          0x00002b2322c83460 __libc_start_main +
    245

    6    tmphdfjixeg                        0x000055a9c8ff55c9 <unavailable> + 5577

    '
  stdout: ''
  timestamp: 1660009433
- exit_code: 0
  program: "\n/// You will be given the name of a class (a string) and an array of\
    \ extensions.\n/// The extensions are to be used to load additional classes to\
    \ the class. The\n/// strength of the extension is as follows: Let CAP be the\
    \ number of the uppercase\n/// letters in the extension's name, and let SM be\
    \ the number of lowercase letters \n/// in the extension's name, the strength\
    \ is given by the fraction CAP - SM. \n/// You should find the strongest extension\
    \ and return a string in this \n/// format: ClassName.StrongestExtensionName.\n\
    /// If there are two or more extensions with the same strength, you should\n///\
    \ choose the one that comes first in the array.\n/// For example, if you are given\
    \ \"Slices\" as the class and an array of the\n/// extensions: ['SErviNGSliCes',\
    \ 'Cheese', 'StuFfed'] then you should\n/// return 'Slices.SErviNGSliCes' since\
    \ 'SErviNGSliCes' is the strongest extension \n/// (its strength is -1).\n///\
    \ Example:\n/// >>> Strongest_Extension(class_name: \"my_class\", extensions:\
    \ [\"AA\", \"Be\", \"CC\"])\n/// \"my_class.AA\"\nfunc Strongest_Extension(class_name:\
    \ String, extensions: [String]) -> String {\n    var ret_ext = \"my_class.AA\"\
    \n    var ret_stre = -100.0\n    for ext in extensions {\n        let cap = Double(ext.filter\
    \ { $0.isUppercase }.count)\n        let sm = Double(ext.filter { $0.isLowercase\
    \ }.count)\n        let stre = cap - sm\n        if stre > ret_stre {\n      \
    \      ret_stre = stre\n            ret_ext = class_name + \".\" + ext\n     \
    \   }\n    }\n    return ret_ext\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int,\
    \ Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n\
    \    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n          \
    \  return false\n        }\n    }\n    return true\n}\n            \nassert(Strongest_Extension(class_name:\
    \ \"Watashi\", extensions: [\"tEN\", \"niNE\", \"eIGHt8OKe\"]) == \"Watashi.eIGHt8OKe\"\
    )\nassert(Strongest_Extension(class_name: \"Boku123\", extensions: [\"nani\",\
    \ \"NazeDa\", \"YEs.WeCaNe\", \"32145tggg\"]) == \"Boku123.YEs.WeCaNe\")\nassert(Strongest_Extension(class_name:\
    \ \"__YESIMHERE\", extensions: [\"t\", \"eMptY\", \"nothing\", \"zeR00\", \"NuLl__\"\
    , \"123NoooneB321\"]) == \"__YESIMHERE.NuLl__\")\nassert(Strongest_Extension(class_name:\
    \ \"K\", extensions: [\"Ta\", \"TAR\", \"t234An\", \"cosSo\"]) == \"K.TAR\")\n\
    assert(Strongest_Extension(class_name: \"__HAHA\", extensions: [\"Tab\", \"123\"\
    , \"781345\", \"-_-\"]) == \"__HAHA.123\")\nassert(Strongest_Extension(class_name:\
    \ \"YameRore\", extensions: [\"HhAas\", \"okIWILL123\", \"WorkOut\", \"Fails\"\
    , \"-_-\"]) == \"YameRore.okIWILL123\")\nassert(Strongest_Extension(class_name:\
    \ \"finNNalLLly\", extensions: [\"Die\", \"NowW\", \"Wow\", \"WoW\"]) == \"finNNalLLly.WoW\"\
    )\nassert(Strongest_Extension(class_name: \"_\", extensions: [\"Bb\", \"91245\"\
    ]) == \"_.Bb\")\nassert(Strongest_Extension(class_name: \"Sp\", extensions: [\"\
    671235\", \"Bb\"]) == \"Sp.671235\")"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660009433
- exit_code: 1
  program: "\n/// You will be given the name of a class (a string) and an array of\
    \ extensions.\n/// The extensions are to be used to load additional classes to\
    \ the class. The\n/// strength of the extension is as follows: Let CAP be the\
    \ number of the uppercase\n/// letters in the extension's name, and let SM be\
    \ the number of lowercase letters \n/// in the extension's name, the strength\
    \ is given by the fraction CAP - SM. \n/// You should find the strongest extension\
    \ and return a string in this \n/// format: ClassName.StrongestExtensionName.\n\
    /// If there are two or more extensions with the same strength, you should\n///\
    \ choose the one that comes first in the array.\n/// For example, if you are given\
    \ \"Slices\" as the class and an array of the\n/// extensions: ['SErviNGSliCes',\
    \ 'Cheese', 'StuFfed'] then you should\n/// return 'Slices.SErviNGSliCes' since\
    \ 'SErviNGSliCes' is the strongest extension \n/// (its strength is -1).\n///\
    \ Example:\n/// >>> Strongest_Extension(class_name: \"my_class\", extensions:\
    \ [\"AA\", \"Be\", \"CC\"])\n/// \"my_class.AA\"\nfunc Strongest_Extension(class_name:\
    \ String, extensions: [String]) -> String {\n    let class_extensions = extensions.map({\
    \ (extension_name) -> ClassExtension in\n        ClassExtension(name: extension_name)\n\
    \    })\n    class_extensions.sort { (class_extension_left, class_extension_right)\
    \ -> Bool in\n        class_extension_left.strength > class_extension_right.strength\n\
    \    }\n    return \"\\(class_name).\\(class_extensions.first!.name)\"\n}\n\n\n\
    func ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(Strongest_Extension(class_name: \"Watashi\", extensions:\
    \ [\"tEN\", \"niNE\", \"eIGHt8OKe\"]) == \"Watashi.eIGHt8OKe\")\nassert(Strongest_Extension(class_name:\
    \ \"Boku123\", extensions: [\"nani\", \"NazeDa\", \"YEs.WeCaNe\", \"32145tggg\"\
    ]) == \"Boku123.YEs.WeCaNe\")\nassert(Strongest_Extension(class_name: \"__YESIMHERE\"\
    , extensions: [\"t\", \"eMptY\", \"nothing\", \"zeR00\", \"NuLl__\", \"123NoooneB321\"\
    ]) == \"__YESIMHERE.NuLl__\")\nassert(Strongest_Extension(class_name: \"K\", extensions:\
    \ [\"Ta\", \"TAR\", \"t234An\", \"cosSo\"]) == \"K.TAR\")\nassert(Strongest_Extension(class_name:\
    \ \"__HAHA\", extensions: [\"Tab\", \"123\", \"781345\", \"-_-\"]) == \"__HAHA.123\"\
    )\nassert(Strongest_Extension(class_name: \"YameRore\", extensions: [\"HhAas\"\
    , \"okIWILL123\", \"WorkOut\", \"Fails\", \"-_-\"]) == \"YameRore.okIWILL123\"\
    )\nassert(Strongest_Extension(class_name: \"finNNalLLly\", extensions: [\"Die\"\
    , \"NowW\", \"Wow\", \"WoW\"]) == \"finNNalLLly.WoW\")\nassert(Strongest_Extension(class_name:\
    \ \"_\", extensions: [\"Bb\", \"91245\"]) == \"_.Bb\")\nassert(Strongest_Extension(class_name:\
    \ \"Sp\", extensions: [\"671235\", \"Bb\"]) == \"Sp.671235\")"
  status: SyntaxError
  stderr: "/tmp/tmpcyo3kyds.swift:20:9: error: cannot find 'ClassExtension' in scope\n\
    \        ClassExtension(name: extension_name)\n        ^~~~~~~~~~~~~~\n"
  stdout: ''
  timestamp: 1660009433
- exit_code: -4
  program: "\n/// You will be given the name of a class (a string) and an array of\
    \ extensions.\n/// The extensions are to be used to load additional classes to\
    \ the class. The\n/// strength of the extension is as follows: Let CAP be the\
    \ number of the uppercase\n/// letters in the extension's name, and let SM be\
    \ the number of lowercase letters \n/// in the extension's name, the strength\
    \ is given by the fraction CAP - SM. \n/// You should find the strongest extension\
    \ and return a string in this \n/// format: ClassName.StrongestExtensionName.\n\
    /// If there are two or more extensions with the same strength, you should\n///\
    \ choose the one that comes first in the array.\n/// For example, if you are given\
    \ \"Slices\" as the class and an array of the\n/// extensions: ['SErviNGSliCes',\
    \ 'Cheese', 'StuFfed'] then you should\n/// return 'Slices.SErviNGSliCes' since\
    \ 'SErviNGSliCes' is the strongest extension \n/// (its strength is -1).\n///\
    \ Example:\n/// >>> Strongest_Extension(class_name: \"my_class\", extensions:\
    \ [\"AA\", \"Be\", \"CC\"])\n/// \"my_class.AA\"\nfunc Strongest_Extension(class_name:\
    \ String, extensions: [String]) -> String {\n    var result: (String, Float) =\
    \ (\"\", 0)\n    for extension_name in extensions {\n        var c_count = 0\n\
    \        var s_count = 0\n        for c in extension_name {\n            if c\
    \ >= \"A\" && c <= \"Z\" {\n                c_count += 1\n            } else if\
    \ c >= \"a\" && c <= \"z\" {\n                s_count += 1\n            }\n  \
    \      }\n        let strength = Float(c_count) - Float(s_count)\n        if strength\
    \ > result.1 {\n            result = (extension_name, strength)\n        }\n \
    \   }\n    return \"\\(class_name).\\(result.0)\"\n}\n\n\nfunc ==(left: [(Int,\
    \ Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n\
    \        return false\n    }\n    for (l, r) in zip(left, right) {\n        if\
    \ l != r {\n            return false\n        }\n    }\n    return true\n}\n \
    \           \nassert(Strongest_Extension(class_name: \"Watashi\", extensions:\
    \ [\"tEN\", \"niNE\", \"eIGHt8OKe\"]) == \"Watashi.eIGHt8OKe\")\nassert(Strongest_Extension(class_name:\
    \ \"Boku123\", extensions: [\"nani\", \"NazeDa\", \"YEs.WeCaNe\", \"32145tggg\"\
    ]) == \"Boku123.YEs.WeCaNe\")\nassert(Strongest_Extension(class_name: \"__YESIMHERE\"\
    , extensions: [\"t\", \"eMptY\", \"nothing\", \"zeR00\", \"NuLl__\", \"123NoooneB321\"\
    ]) == \"__YESIMHERE.NuLl__\")\nassert(Strongest_Extension(class_name: \"K\", extensions:\
    \ [\"Ta\", \"TAR\", \"t234An\", \"cosSo\"]) == \"K.TAR\")\nassert(Strongest_Extension(class_name:\
    \ \"__HAHA\", extensions: [\"Tab\", \"123\", \"781345\", \"-_-\"]) == \"__HAHA.123\"\
    )\nassert(Strongest_Extension(class_name: \"YameRore\", extensions: [\"HhAas\"\
    , \"okIWILL123\", \"WorkOut\", \"Fails\", \"-_-\"]) == \"YameRore.okIWILL123\"\
    )\nassert(Strongest_Extension(class_name: \"finNNalLLly\", extensions: [\"Die\"\
    , \"NowW\", \"Wow\", \"WoW\"]) == \"finNNalLLly.WoW\")\nassert(Strongest_Extension(class_name:\
    \ \"_\", extensions: [\"Bb\", \"91245\"]) == \"_.Bb\")\nassert(Strongest_Extension(class_name:\
    \ \"Sp\", extensions: [\"671235\", \"Bb\"]) == \"Sp.671235\")"
  status: Exception
  stderr: 'tmp2vdeeu0x/tmp2vdeeu0x.swift:53: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002ade47310c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002ade47007b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002ade47007988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002ade470067b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmp2vdeeu0x                        0x000055c8c4c1001c <unavailable> + 8220

    5    libc.so.6                          0x00002ade474fc460 __libc_start_main +
    245

    6    tmp2vdeeu0x                        0x000055c8c4c0f729 <unavailable> + 5929

    '
  stdout: ''
  timestamp: 1660009433
- exit_code: 1
  program: "\n/// You will be given the name of a class (a string) and an array of\
    \ extensions.\n/// The extensions are to be used to load additional classes to\
    \ the class. The\n/// strength of the extension is as follows: Let CAP be the\
    \ number of the uppercase\n/// letters in the extension's name, and let SM be\
    \ the number of lowercase letters \n/// in the extension's name, the strength\
    \ is given by the fraction CAP - SM. \n/// You should find the strongest extension\
    \ and return a string in this \n/// format: ClassName.StrongestExtensionName.\n\
    /// If there are two or more extensions with the same strength, you should\n///\
    \ choose the one that comes first in the array.\n/// For example, if you are given\
    \ \"Slices\" as the class and an array of the\n/// extensions: ['SErviNGSliCes',\
    \ 'Cheese', 'StuFfed'] then you should\n/// return 'Slices.SErviNGSliCes' since\
    \ 'SErviNGSliCes' is the strongest extension \n/// (its strength is -1).\n///\
    \ Example:\n/// >>> Strongest_Extension(class_name: \"my_class\", extensions:\
    \ [\"AA\", \"Be\", \"CC\"])\n/// \"my_class.AA\"\nfunc Strongest_Extension(class_name:\
    \ String, extensions: [String]) -> String {\n    var extension_strength = [String:Int]()\n\
    \    var strongest_extension = 0\n    var strongest_extension_name = \"\"\n  \
    \  for item in extensions {\n        var strength = 0\n        for character in\
    \ item {\n            if String(character).rangeOfCharacter(from: CharacterSet.uppercaseLetters)\
    \ != nil {\n                strength += 1\n            } else if String(character).rangeOfCharacter(from:\
    \ CharacterSet.lowercaseLetters) != nil {\n                strength -= 1\n   \
    \         }\n        }\n        extension_strength[item] = strength\n        if\
    \ strongest_extension < strength {\n            strongest_extension = strength\n\
    \            strongest_extension_name = item\n        }\n    }\n    return \"\\\
    (class_name).\\(strongest_extension_name)\"\n}\n\n\nfunc ==(left: [(Int, Int)],\
    \ right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n       \
    \ return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r\
    \ {\n            return false\n        }\n    }\n    return true\n}\n        \
    \    \nassert(Strongest_Extension(class_name: \"Watashi\", extensions: [\"tEN\"\
    , \"niNE\", \"eIGHt8OKe\"]) == \"Watashi.eIGHt8OKe\")\nassert(Strongest_Extension(class_name:\
    \ \"Boku123\", extensions: [\"nani\", \"NazeDa\", \"YEs.WeCaNe\", \"32145tggg\"\
    ]) == \"Boku123.YEs.WeCaNe\")\nassert(Strongest_Extension(class_name: \"__YESIMHERE\"\
    , extensions: [\"t\", \"eMptY\", \"nothing\", \"zeR00\", \"NuLl__\", \"123NoooneB321\"\
    ]) == \"__YESIMHERE.NuLl__\")\nassert(Strongest_Extension(class_name: \"K\", extensions:\
    \ [\"Ta\", \"TAR\", \"t234An\", \"cosSo\"]) == \"K.TAR\")\nassert(Strongest_Extension(class_name:\
    \ \"__HAHA\", extensions: [\"Tab\", \"123\", \"781345\", \"-_-\"]) == \"__HAHA.123\"\
    )\nassert(Strongest_Extension(class_name: \"YameRore\", extensions: [\"HhAas\"\
    , \"okIWILL123\", \"WorkOut\", \"Fails\", \"-_-\"]) == \"YameRore.okIWILL123\"\
    )\nassert(Strongest_Extension(class_name: \"finNNalLLly\", extensions: [\"Die\"\
    , \"NowW\", \"Wow\", \"WoW\"]) == \"finNNalLLly.WoW\")\nassert(Strongest_Extension(class_name:\
    \ \"_\", extensions: [\"Bb\", \"91245\"]) == \"_.Bb\")\nassert(Strongest_Extension(class_name:\
    \ \"Sp\", extensions: [\"671235\", \"Bb\"]) == \"Sp.671235\")"
  status: SyntaxError
  stderr: "/tmp/tmpxbsgqg2i.swift:25:57: error: cannot find 'CharacterSet' in scope\n\
    \            if String(character).rangeOfCharacter(from: CharacterSet.uppercaseLetters)\
    \ != nil {\n                                                        ^~~~~~~~~~~~\n\
    /tmp/tmpxbsgqg2i.swift:25:34: error: value of type 'String' has no member 'rangeOfCharacter'\n\
    \            if String(character).rangeOfCharacter(from: CharacterSet.uppercaseLetters)\
    \ != nil {\n               ~~~~~~~~~~~~~~~~~ ^~~~~~~~~~~~~~~~\n/tmp/tmpxbsgqg2i.swift:27:64:\
    \ error: cannot find 'CharacterSet' in scope\n            } else if String(character).rangeOfCharacter(from:\
    \ CharacterSet.lowercaseLetters) != nil {\n                                  \
    \                             ^~~~~~~~~~~~\n/tmp/tmpxbsgqg2i.swift:27:41: error:\
    \ value of type 'String' has no member 'rangeOfCharacter'\n            } else\
    \ if String(character).rangeOfCharacter(from: CharacterSet.lowercaseLetters) !=\
    \ nil {\n                      ~~~~~~~~~~~~~~~~~ ^~~~~~~~~~~~~~~~\n"
  stdout: ''
  timestamp: 1660009433
- exit_code: 1
  program: "\n/// You will be given the name of a class (a string) and an array of\
    \ extensions.\n/// The extensions are to be used to load additional classes to\
    \ the class. The\n/// strength of the extension is as follows: Let CAP be the\
    \ number of the uppercase\n/// letters in the extension's name, and let SM be\
    \ the number of lowercase letters \n/// in the extension's name, the strength\
    \ is given by the fraction CAP - SM. \n/// You should find the strongest extension\
    \ and return a string in this \n/// format: ClassName.StrongestExtensionName.\n\
    /// If there are two or more extensions with the same strength, you should\n///\
    \ choose the one that comes first in the array.\n/// For example, if you are given\
    \ \"Slices\" as the class and an array of the\n/// extensions: ['SErviNGSliCes',\
    \ 'Cheese', 'StuFfed'] then you should\n/// return 'Slices.SErviNGSliCes' since\
    \ 'SErviNGSliCes' is the strongest extension \n/// (its strength is -1).\n///\
    \ Example:\n/// >>> Strongest_Extension(class_name: \"my_class\", extensions:\
    \ [\"AA\", \"Be\", \"CC\"])\n/// \"my_class.AA\"\nfunc Strongest_Extension(class_name:\
    \ String, extensions: [String]) -> String {\n    var strongestExtension: String\
    \ = \"\"\n    var strength: Double = 0\n    for extension_ in extensions {\n \
    \       let upperCaseCount = extension_.components(separatedBy: .uppercaseLetters).count\
    \ - 1\n        let lowerCaseCount = extension_.components(separatedBy: .lowercaseLetters).count\
    \ - 1\n        if upperCaseCount - lowerCaseCount > strength {\n            strength\
    \ = Double(upperCaseCount - lowerCaseCount)\n            strongestExtension =\
    \ extension_\n        }\n    }\n    return \"\\(class_name).\\(strongestExtension)\"\
    \n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(Strongest_Extension(class_name: \"Watashi\", extensions:\
    \ [\"tEN\", \"niNE\", \"eIGHt8OKe\"]) == \"Watashi.eIGHt8OKe\")\nassert(Strongest_Extension(class_name:\
    \ \"Boku123\", extensions: [\"nani\", \"NazeDa\", \"YEs.WeCaNe\", \"32145tggg\"\
    ]) == \"Boku123.YEs.WeCaNe\")\nassert(Strongest_Extension(class_name: \"__YESIMHERE\"\
    , extensions: [\"t\", \"eMptY\", \"nothing\", \"zeR00\", \"NuLl__\", \"123NoooneB321\"\
    ]) == \"__YESIMHERE.NuLl__\")\nassert(Strongest_Extension(class_name: \"K\", extensions:\
    \ [\"Ta\", \"TAR\", \"t234An\", \"cosSo\"]) == \"K.TAR\")\nassert(Strongest_Extension(class_name:\
    \ \"__HAHA\", extensions: [\"Tab\", \"123\", \"781345\", \"-_-\"]) == \"__HAHA.123\"\
    )\nassert(Strongest_Extension(class_name: \"YameRore\", extensions: [\"HhAas\"\
    , \"okIWILL123\", \"WorkOut\", \"Fails\", \"-_-\"]) == \"YameRore.okIWILL123\"\
    )\nassert(Strongest_Extension(class_name: \"finNNalLLly\", extensions: [\"Die\"\
    , \"NowW\", \"Wow\", \"WoW\"]) == \"finNNalLLly.WoW\")\nassert(Strongest_Extension(class_name:\
    \ \"_\", extensions: [\"Bb\", \"91245\"]) == \"_.Bb\")\nassert(Strongest_Extension(class_name:\
    \ \"Sp\", extensions: [\"671235\", \"Bb\"]) == \"Sp.671235\")"
  status: SyntaxError
  stderr: "/tmp/tmpkavge6cz.swift:22:41: error: value of type 'String' has no member\
    \ 'components'\n        let upperCaseCount = extension_.components(separatedBy:\
    \ .uppercaseLetters).count - 1\n                             ~~~~~~~~~~ ^~~~~~~~~~\n\
    /tmp/tmpkavge6cz.swift:22:66: error: cannot infer contextual base in reference\
    \ to member 'uppercaseLetters'\n        let upperCaseCount = extension_.components(separatedBy:\
    \ .uppercaseLetters).count - 1\n                                             \
    \                   ~^~~~~~~~~~~~~~~~\n/tmp/tmpkavge6cz.swift:23:41: error: value\
    \ of type 'String' has no member 'components'\n        let lowerCaseCount = extension_.components(separatedBy:\
    \ .lowercaseLetters).count - 1\n                             ~~~~~~~~~~ ^~~~~~~~~~\n\
    /tmp/tmpkavge6cz.swift:23:66: error: cannot infer contextual base in reference\
    \ to member 'lowercaseLetters'\n        let lowerCaseCount = extension_.components(separatedBy:\
    \ .lowercaseLetters).count - 1\n                                             \
    \                   ~^~~~~~~~~~~~~~~~\n/tmp/tmpkavge6cz.swift:24:44: error: binary\
    \ operator '>' cannot be applied to operands of type 'Duration' and 'Double'\n\
    \        if upperCaseCount - lowerCaseCount > strength {\n           ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\
    \ ^ ~~~~~~~~\n/tmp/tmpkavge6cz.swift:25:24: error: no exact matches in call to\
    \ initializer \n            strength = Double(upperCaseCount - lowerCaseCount)\n\
    \                       ^\n/tmp/tmpkavge6cz.swift:25:24: note: found candidate\
    \ with type '(Builtin.FPIEEE64) -> Double'\n            strength = Double(upperCaseCount\
    \ - lowerCaseCount)\n                       ^\n/tmp/tmpkavge6cz.swift:25:24: note:\
    \ found candidate with type '(Int) -> Double'\n            strength = Double(upperCaseCount\
    \ - lowerCaseCount)\n                       ^\n/tmp/tmpkavge6cz.swift:25:24: note:\
    \ found candidate with type '(Float16) -> Double'\n            strength = Double(upperCaseCount\
    \ - lowerCaseCount)\n                       ^\n/tmp/tmpkavge6cz.swift:25:24: note:\
    \ found candidate with type '(Float) -> Double'\n            strength ="
  stdout: ''
  timestamp: 1660009433
- exit_code: -4
  program: "\n/// You will be given the name of a class (a string) and an array of\
    \ extensions.\n/// The extensions are to be used to load additional classes to\
    \ the class. The\n/// strength of the extension is as follows: Let CAP be the\
    \ number of the uppercase\n/// letters in the extension's name, and let SM be\
    \ the number of lowercase letters \n/// in the extension's name, the strength\
    \ is given by the fraction CAP - SM. \n/// You should find the strongest extension\
    \ and return a string in this \n/// format: ClassName.StrongestExtensionName.\n\
    /// If there are two or more extensions with the same strength, you should\n///\
    \ choose the one that comes first in the array.\n/// For example, if you are given\
    \ \"Slices\" as the class and an array of the\n/// extensions: ['SErviNGSliCes',\
    \ 'Cheese', 'StuFfed'] then you should\n/// return 'Slices.SErviNGSliCes' since\
    \ 'SErviNGSliCes' is the strongest extension \n/// (its strength is -1).\n///\
    \ Example:\n/// >>> Strongest_Extension(class_name: \"my_class\", extensions:\
    \ [\"AA\", \"Be\", \"CC\"])\n/// \"my_class.AA\"\nfunc Strongest_Extension(class_name:\
    \ String, extensions: [String]) -> String {\n    var strength = extensions.map\
    \ { (extension_name) -> (String, Double) in\n        var upper = 0\n        var\
    \ lower = 0\n        for char in extension_name {\n            switch char {\n\
    \            case \"A\"...\"Z\":\n                upper += 1\n            case\
    \ \"a\"...\"z\":\n                lower += 1\n            default:\n         \
    \       continue\n            }\n        }\n        return (extension_name, Double(upper\
    \ - lower))\n    }\n    strength.sort { (extension1, extension2) -> Bool in\n\
    \        if extension1.1 == extension2.1 {\n            return extension1.0 <\
    \ extension2.0\n        }\n        return extension1.1 > extension2.1\n    }\n\
    \    if let strongest = strength.first {\n        return \"\\(class_name).\\(strongest.0)\"\
    \n    }\n    return \"\\(class_name).null\"\n}\n\n\nfunc ==(left: [(Int, Int)],\
    \ right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n       \
    \ return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r\
    \ {\n            return false\n        }\n    }\n    return true\n}\n        \
    \    \nassert(Strongest_Extension(class_name: \"Watashi\", extensions: [\"tEN\"\
    , \"niNE\", \"eIGHt8OKe\"]) == \"Watashi.eIGHt8OKe\")\nassert(Strongest_Extension(class_name:\
    \ \"Boku123\", extensions: [\"nani\", \"NazeDa\", \"YEs.WeCaNe\", \"32145tggg\"\
    ]) == \"Boku123.YEs.WeCaNe\")\nassert(Strongest_Extension(class_name: \"__YESIMHERE\"\
    , extensions: [\"t\", \"eMptY\", \"nothing\", \"zeR00\", \"NuLl__\", \"123NoooneB321\"\
    ]) == \"__YESIMHERE.NuLl__\")\nassert(Strongest_Extension(class_name: \"K\", extensions:\
    \ [\"Ta\", \"TAR\", \"t234An\", \"cosSo\"]) == \"K.TAR\")\nassert(Strongest_Extension(class_name:\
    \ \"__HAHA\", extensions: [\"Tab\", \"123\", \"781345\", \"-_-\"]) == \"__HAHA.123\"\
    )\nassert(Strongest_Extension(class_name: \"YameRore\", extensions: [\"HhAas\"\
    , \"okIWILL123\", \"WorkOut\", \"Fails\", \"-_-\"]) == \"YameRore.okIWILL123\"\
    )\nassert(Strongest_Extension(class_name: \"finNNalLLly\", extensions: [\"Die\"\
    , \"NowW\", \"Wow\", \"WoW\"]) == \"finNNalLLly.WoW\")\nassert(Strongest_Extension(class_name:\
    \ \"_\", extensions: [\"Bb\", \"91245\"]) == \"_.Bb\")\nassert(Strongest_Extension(class_name:\
    \ \"Sp\", extensions: [\"671235\", \"Bb\"]) == \"Sp.671235\")"
  status: Exception
  stderr: 'tmpi8v_pn7p/tmpi8v_pn7p.swift:63: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b8599dffc80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b8599af6b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b8599af6988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b8599af57b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpi8v_pn7p                        0x0000561fc06155aa <unavailable> + 9642

    5    libc.so.6                          0x00002b8599feb460 __libc_start_main +
    245

    6    tmpi8v_pn7p                        0x0000561fc0614879 <unavailable> + 6265

    '
  stdout: ''
  timestamp: 1660009433
- exit_code: -4
  program: "\n/// You will be given the name of a class (a string) and an array of\
    \ extensions.\n/// The extensions are to be used to load additional classes to\
    \ the class. The\n/// strength of the extension is as follows: Let CAP be the\
    \ number of the uppercase\n/// letters in the extension's name, and let SM be\
    \ the number of lowercase letters \n/// in the extension's name, the strength\
    \ is given by the fraction CAP - SM. \n/// You should find the strongest extension\
    \ and return a string in this \n/// format: ClassName.StrongestExtensionName.\n\
    /// If there are two or more extensions with the same strength, you should\n///\
    \ choose the one that comes first in the array.\n/// For example, if you are given\
    \ \"Slices\" as the class and an array of the\n/// extensions: ['SErviNGSliCes',\
    \ 'Cheese', 'StuFfed'] then you should\n/// return 'Slices.SErviNGSliCes' since\
    \ 'SErviNGSliCes' is the strongest extension \n/// (its strength is -1).\n///\
    \ Example:\n/// >>> Strongest_Extension(class_name: \"my_class\", extensions:\
    \ [\"AA\", \"Be\", \"CC\"])\n/// \"my_class.AA\"\nfunc Strongest_Extension(class_name:\
    \ String, extensions: [String]) -> String {\n    var strongestExtension = \"\"\
    \n    var strongExtensionStrength = -2\n    for ext in extensions {\n        var\
    \ extensionStrength = -1\n        var cap = 0\n        var sm = 0\n        for\
    \ char in ext {\n            if char.isUppercase {\n                cap += 1\n\
    \            } else {\n                sm += 1\n            }\n        }\n   \
    \     extensionStrength = cap - sm\n        if extensionStrength > strongExtensionStrength\
    \ {\n            strongExtensionStrength = extensionStrength\n            strongestExtension\
    \ = ext\n        }\n    }\n    return class_name + \".\" + strongestExtension\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(Strongest_Extension(class_name: \"Watashi\", extensions:\
    \ [\"tEN\", \"niNE\", \"eIGHt8OKe\"]) == \"Watashi.eIGHt8OKe\")\nassert(Strongest_Extension(class_name:\
    \ \"Boku123\", extensions: [\"nani\", \"NazeDa\", \"YEs.WeCaNe\", \"32145tggg\"\
    ]) == \"Boku123.YEs.WeCaNe\")\nassert(Strongest_Extension(class_name: \"__YESIMHERE\"\
    , extensions: [\"t\", \"eMptY\", \"nothing\", \"zeR00\", \"NuLl__\", \"123NoooneB321\"\
    ]) == \"__YESIMHERE.NuLl__\")\nassert(Strongest_Extension(class_name: \"K\", extensions:\
    \ [\"Ta\", \"TAR\", \"t234An\", \"cosSo\"]) == \"K.TAR\")\nassert(Strongest_Extension(class_name:\
    \ \"__HAHA\", extensions: [\"Tab\", \"123\", \"781345\", \"-_-\"]) == \"__HAHA.123\"\
    )\nassert(Strongest_Extension(class_name: \"YameRore\", extensions: [\"HhAas\"\
    , \"okIWILL123\", \"WorkOut\", \"Fails\", \"-_-\"]) == \"YameRore.okIWILL123\"\
    )\nassert(Strongest_Extension(class_name: \"finNNalLLly\", extensions: [\"Die\"\
    , \"NowW\", \"Wow\", \"WoW\"]) == \"finNNalLLly.WoW\")\nassert(Strongest_Extension(class_name:\
    \ \"_\", extensions: [\"Bb\", \"91245\"]) == \"_.Bb\")\nassert(Strongest_Extension(class_name:\
    \ \"Sp\", extensions: [\"671235\", \"Bb\"]) == \"Sp.671235\")"
  status: Exception
  stderr: 'tmp7au3tt4b/tmp7au3tt4b.swift:54: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002aff2967ac80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002aff29371b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002aff29371988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002aff293707b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmp7au3tt4b                        0x00005589f13737cd <unavailable> + 6093

    5    libc.so.6                          0x00002aff29866460 __libc_start_main +
    245

    6    tmp7au3tt4b                        0x00005589f1373359 <unavailable> + 4953

    '
  stdout: ''
  timestamp: 1660009433
- exit_code: -4
  program: "\n/// You will be given the name of a class (a string) and an array of\
    \ extensions.\n/// The extensions are to be used to load additional classes to\
    \ the class. The\n/// strength of the extension is as follows: Let CAP be the\
    \ number of the uppercase\n/// letters in the extension's name, and let SM be\
    \ the number of lowercase letters \n/// in the extension's name, the strength\
    \ is given by the fraction CAP - SM. \n/// You should find the strongest extension\
    \ and return a string in this \n/// format: ClassName.StrongestExtensionName.\n\
    /// If there are two or more extensions with the same strength, you should\n///\
    \ choose the one that comes first in the array.\n/// For example, if you are given\
    \ \"Slices\" as the class and an array of the\n/// extensions: ['SErviNGSliCes',\
    \ 'Cheese', 'StuFfed'] then you should\n/// return 'Slices.SErviNGSliCes' since\
    \ 'SErviNGSliCes' is the strongest extension \n/// (its strength is -1).\n///\
    \ Example:\n/// >>> Strongest_Extension(class_name: \"my_class\", extensions:\
    \ [\"AA\", \"Be\", \"CC\"])\n/// \"my_class.AA\"\nfunc Strongest_Extension(class_name:\
    \ String, extensions: [String]) -> String {\n    let upperCaseCount: (String)\
    \ -> Int = {\n        $0.filter {$0.isUppercase}.count\n    }\n    let lowerCaseCount:\
    \ (String) -> Int = {\n        $0.filter {$0.isLowercase}.count\n    }\n    let\
    \ totalCount: (String) -> Int = {\n        upperCaseCount($0) - lowerCaseCount($0)\n\
    \    }\n    let extensionWithMaxStrength = extensions.max(by: {totalCount($0)\
    \ < totalCount($1)})\n    let strength = totalCount(extensionWithMaxStrength!)\n\
    \    let finalExtension = strength > 0 ? extensionWithMaxStrength! : extensions[0]\n\
    \    return \"\\(class_name).\\(finalExtension)\"\n}\n\n\nfunc ==(left: [(Int,\
    \ Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n\
    \        return false\n    }\n    for (l, r) in zip(left, right) {\n        if\
    \ l != r {\n            return false\n        }\n    }\n    return true\n}\n \
    \           \nassert(Strongest_Extension(class_name: \"Watashi\", extensions:\
    \ [\"tEN\", \"niNE\", \"eIGHt8OKe\"]) == \"Watashi.eIGHt8OKe\")\nassert(Strongest_Extension(class_name:\
    \ \"Boku123\", extensions: [\"nani\", \"NazeDa\", \"YEs.WeCaNe\", \"32145tggg\"\
    ]) == \"Boku123.YEs.WeCaNe\")\nassert(Strongest_Extension(class_name: \"__YESIMHERE\"\
    , extensions: [\"t\", \"eMptY\", \"nothing\", \"zeR00\", \"NuLl__\", \"123NoooneB321\"\
    ]) == \"__YESIMHERE.NuLl__\")\nassert(Strongest_Extension(class_name: \"K\", extensions:\
    \ [\"Ta\", \"TAR\", \"t234An\", \"cosSo\"]) == \"K.TAR\")\nassert(Strongest_Extension(class_name:\
    \ \"__HAHA\", extensions: [\"Tab\", \"123\", \"781345\", \"-_-\"]) == \"__HAHA.123\"\
    )\nassert(Strongest_Extension(class_name: \"YameRore\", extensions: [\"HhAas\"\
    , \"okIWILL123\", \"WorkOut\", \"Fails\", \"-_-\"]) == \"YameRore.okIWILL123\"\
    )\nassert(Strongest_Extension(class_name: \"finNNalLLly\", extensions: [\"Die\"\
    , \"NowW\", \"Wow\", \"WoW\"]) == \"finNNalLLly.WoW\")\nassert(Strongest_Extension(class_name:\
    \ \"_\", extensions: [\"Bb\", \"91245\"]) == \"_.Bb\")\nassert(Strongest_Extension(class_name:\
    \ \"Sp\", extensions: [\"671235\", \"Bb\"]) == \"Sp.671235\")"
  status: Exception
  stderr: 'tmp96m7d_1b/tmp96m7d_1b.swift:49: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b0145286c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b0144f7db6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b0144f7d988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b0144f7c7b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmp96m7d_1b                        0x000055a43a9fc00c <unavailable> + 8204

    5    libc.so.6                          0x00002b0145472460 __libc_start_main +
    245

    6    tmp96m7d_1b                        0x000055a43a9fb719 <unavailable> + 5913

    '
  stdout: ''
  timestamp: 1660009433
- exit_code: -4
  program: "\n/// You will be given the name of a class (a string) and an array of\
    \ extensions.\n/// The extensions are to be used to load additional classes to\
    \ the class. The\n/// strength of the extension is as follows: Let CAP be the\
    \ number of the uppercase\n/// letters in the extension's name, and let SM be\
    \ the number of lowercase letters \n/// in the extension's name, the strength\
    \ is given by the fraction CAP - SM. \n/// You should find the strongest extension\
    \ and return a string in this \n/// format: ClassName.StrongestExtensionName.\n\
    /// If there are two or more extensions with the same strength, you should\n///\
    \ choose the one that comes first in the array.\n/// For example, if you are given\
    \ \"Slices\" as the class and an array of the\n/// extensions: ['SErviNGSliCes',\
    \ 'Cheese', 'StuFfed'] then you should\n/// return 'Slices.SErviNGSliCes' since\
    \ 'SErviNGSliCes' is the strongest extension \n/// (its strength is -1).\n///\
    \ Example:\n/// >>> Strongest_Extension(class_name: \"my_class\", extensions:\
    \ [\"AA\", \"Be\", \"CC\"])\n/// \"my_class.AA\"\nfunc Strongest_Extension(class_name:\
    \ String, extensions: [String]) -> String {\n    var strongest_extension: String\
    \ = \"\"\n    var current_extension_strength: Double = 0.0\n    var strongest_extension_strength:\
    \ Double = 0.0\n    var CAP: Int = 0\n    var SM: Int = 0\n    var strength: Double\
    \ = 0.0\n    for extension_name in extensions {\n        CAP = 0\n        SM =\
    \ 0\n        strength = 0.0\n        for char in extension_name {\n          \
    \  if char.isUppercase {\n                CAP += 1\n            } else {\n   \
    \             SM += 1\n            }\n        }\n        strength = Double(CAP)\
    \ - Double(SM)\n        if strongest_extension_strength == 0.0 {\n           \
    \ strongest_extension_strength = strength\n            strongest_extension = extension_name\n\
    \        } else if strength > strongest_extension_strength {\n            strongest_extension_strength\
    \ = strength\n            strongest_extension = extension_name\n        }\n  \
    \  }\n    return \"\\(class_name).\\(strongest_extension)\"\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(Strongest_Extension(class_name: \"Watashi\", extensions:\
    \ [\"tEN\", \"niNE\", \"eIGHt8OKe\"]) == \"Watashi.eIGHt8OKe\")\nassert(Strongest_Extension(class_name:\
    \ \"Boku123\", extensions: [\"nani\", \"NazeDa\", \"YEs.WeCaNe\", \"32145tggg\"\
    ]) == \"Boku123.YEs.WeCaNe\")\nassert(Strongest_Extension(class_name: \"__YESIMHERE\"\
    , extensions: [\"t\", \"eMptY\", \"nothing\", \"zeR00\", \"NuLl__\", \"123NoooneB321\"\
    ]) == \"__YESIMHERE.NuLl__\")\nassert(Strongest_Extension(class_name: \"K\", extensions:\
    \ [\"Ta\", \"TAR\", \"t234An\", \"cosSo\"]) == \"K.TAR\")\nassert(Strongest_Extension(class_name:\
    \ \"__HAHA\", extensions: [\"Tab\", \"123\", \"781345\", \"-_-\"]) == \"__HAHA.123\"\
    )\nassert(Strongest_Extension(class_name: \"YameRore\", extensions: [\"HhAas\"\
    , \"okIWILL123\", \"WorkOut\", \"Fails\", \"-_-\"]) == \"YameRore.okIWILL123\"\
    )\nassert(Strongest_Extension(class_name: \"finNNalLLly\", extensions: [\"Die\"\
    , \"NowW\", \"Wow\", \"WoW\"]) == \"finNNalLLly.WoW\")\nassert(Strongest_Extension(class_name:\
    \ \"_\", extensions: [\"Bb\", \"91245\"]) == \"_.Bb\")\nassert(Strongest_Extension(class_name:\
    \ \"Sp\", extensions: [\"671235\", \"Bb\"]) == \"Sp.671235\")"
  status: Exception
  stderr: 'tmpnd2lsjkv/tmpnd2lsjkv.swift:61: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002ba4fb843c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002ba4fb53ab6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002ba4fb53a988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002ba4fb5397b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpnd2lsjkv                        0x000056341b277a3d <unavailable> + 6717

    5    libc.so.6                          0x00002ba4fba2f460 __libc_start_main +
    245

    6    tmpnd2lsjkv                        0x000056341b2775c9 <unavailable> + 5577

    '
  stdout: ''
  timestamp: 1660009433
- exit_code: -4
  program: "\n/// You will be given the name of a class (a string) and an array of\
    \ extensions.\n/// The extensions are to be used to load additional classes to\
    \ the class. The\n/// strength of the extension is as follows: Let CAP be the\
    \ number of the uppercase\n/// letters in the extension's name, and let SM be\
    \ the number of lowercase letters \n/// in the extension's name, the strength\
    \ is given by the fraction CAP - SM. \n/// You should find the strongest extension\
    \ and return a string in this \n/// format: ClassName.StrongestExtensionName.\n\
    /// If there are two or more extensions with the same strength, you should\n///\
    \ choose the one that comes first in the array.\n/// For example, if you are given\
    \ \"Slices\" as the class and an array of the\n/// extensions: ['SErviNGSliCes',\
    \ 'Cheese', 'StuFfed'] then you should\n/// return 'Slices.SErviNGSliCes' since\
    \ 'SErviNGSliCes' is the strongest extension \n/// (its strength is -1).\n///\
    \ Example:\n/// >>> Strongest_Extension(class_name: \"my_class\", extensions:\
    \ [\"AA\", \"Be\", \"CC\"])\n/// \"my_class.AA\"\nfunc Strongest_Extension(class_name:\
    \ String, extensions: [String]) -> String {\n    let num_upper = { (str: String)\
    \ -> Int in\n        var count = 0\n        for c in str {\n            if c.isUppercase\
    \ {\n                count += 1\n            }\n        }\n        return count\n\
    \    }\n    let num_lower = { (str: String) -> Int in\n        var count = 0\n\
    \        for c in str {\n            if c.isLowercase {\n                count\
    \ += 1\n            }\n        }\n        return count\n    }\n    var strongest_extension\
    \ = \"\"\n    var strongest_strength = Double.leastNormalMagnitude\n    for ext\
    \ in extensions {\n        let str = Double(num_upper(ext) - num_lower(ext))\n\
    \        if str > strongest_strength {\n            strongest_strength = str\n\
    \            strongest_extension = ext\n        }\n    }\n    return \"\\(class_name).\\\
    (strongest_extension)\"\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(Strongest_Extension(class_name:\
    \ \"Watashi\", extensions: [\"tEN\", \"niNE\", \"eIGHt8OKe\"]) == \"Watashi.eIGHt8OKe\"\
    )\nassert(Strongest_Extension(class_name: \"Boku123\", extensions: [\"nani\",\
    \ \"NazeDa\", \"YEs.WeCaNe\", \"32145tggg\"]) == \"Boku123.YEs.WeCaNe\")\nassert(Strongest_Extension(class_name:\
    \ \"__YESIMHERE\", extensions: [\"t\", \"eMptY\", \"nothing\", \"zeR00\", \"NuLl__\"\
    , \"123NoooneB321\"]) == \"__YESIMHERE.NuLl__\")\nassert(Strongest_Extension(class_name:\
    \ \"K\", extensions: [\"Ta\", \"TAR\", \"t234An\", \"cosSo\"]) == \"K.TAR\")\n\
    assert(Strongest_Extension(class_name: \"__HAHA\", extensions: [\"Tab\", \"123\"\
    , \"781345\", \"-_-\"]) == \"__HAHA.123\")\nassert(Strongest_Extension(class_name:\
    \ \"YameRore\", extensions: [\"HhAas\", \"okIWILL123\", \"WorkOut\", \"Fails\"\
    , \"-_-\"]) == \"YameRore.okIWILL123\")\nassert(Strongest_Extension(class_name:\
    \ \"finNNalLLly\", extensions: [\"Die\", \"NowW\", \"Wow\", \"WoW\"]) == \"finNNalLLly.WoW\"\
    )\nassert(Strongest_Extension(class_name: \"_\", extensions: [\"Bb\", \"91245\"\
    ]) == \"_.Bb\")\nassert(Strongest_Extension(class_name: \"Sp\", extensions: [\"\
    671235\", \"Bb\"]) == \"Sp.671235\")"
  status: Exception
  stderr: 'tmpws5s4o79/tmpws5s4o79.swift:64: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b047a7f2c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b047a4e9b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b047a4e9988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b047a4e87b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpws5s4o79                        0x0000558187f33f7c <unavailable> + 8060

    5    libc.so.6                          0x00002b047a9de460 __libc_start_main +
    245

    6    tmpws5s4o79                        0x0000558187f33689 <unavailable> + 5769

    '
  stdout: ''
  timestamp: 1660009433
- exit_code: -4
  program: "\n/// You will be given the name of a class (a string) and an array of\
    \ extensions.\n/// The extensions are to be used to load additional classes to\
    \ the class. The\n/// strength of the extension is as follows: Let CAP be the\
    \ number of the uppercase\n/// letters in the extension's name, and let SM be\
    \ the number of lowercase letters \n/// in the extension's name, the strength\
    \ is given by the fraction CAP - SM. \n/// You should find the strongest extension\
    \ and return a string in this \n/// format: ClassName.StrongestExtensionName.\n\
    /// If there are two or more extensions with the same strength, you should\n///\
    \ choose the one that comes first in the array.\n/// For example, if you are given\
    \ \"Slices\" as the class and an array of the\n/// extensions: ['SErviNGSliCes',\
    \ 'Cheese', 'StuFfed'] then you should\n/// return 'Slices.SErviNGSliCes' since\
    \ 'SErviNGSliCes' is the strongest extension \n/// (its strength is -1).\n///\
    \ Example:\n/// >>> Strongest_Extension(class_name: \"my_class\", extensions:\
    \ [\"AA\", \"Be\", \"CC\"])\n/// \"my_class.AA\"\nfunc Strongest_Extension(class_name:\
    \ String, extensions: [String]) -> String {\n    var strongestExt = extensions[0]\n\
    \    var strongestExtStrength = 0\n    for ext in extensions {\n        let strength\
    \ = ext.filter({ $0.isUppercase }).count - ext.filter({ $0.isLowercase }).count\n\
    \        if strength > strongestExtStrength {\n            strongestExtStrength\
    \ = strength\n            strongestExt = ext\n        }\n    }\n    return \"\\\
    (class_name).\\(strongestExt)\"\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int,\
    \ Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n\
    \    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n          \
    \  return false\n        }\n    }\n    return true\n}\n            \nassert(Strongest_Extension(class_name:\
    \ \"Watashi\", extensions: [\"tEN\", \"niNE\", \"eIGHt8OKe\"]) == \"Watashi.eIGHt8OKe\"\
    )\nassert(Strongest_Extension(class_name: \"Boku123\", extensions: [\"nani\",\
    \ \"NazeDa\", \"YEs.WeCaNe\", \"32145tggg\"]) == \"Boku123.YEs.WeCaNe\")\nassert(Strongest_Extension(class_name:\
    \ \"__YESIMHERE\", extensions: [\"t\", \"eMptY\", \"nothing\", \"zeR00\", \"NuLl__\"\
    , \"123NoooneB321\"]) == \"__YESIMHERE.NuLl__\")\nassert(Strongest_Extension(class_name:\
    \ \"K\", extensions: [\"Ta\", \"TAR\", \"t234An\", \"cosSo\"]) == \"K.TAR\")\n\
    assert(Strongest_Extension(class_name: \"__HAHA\", extensions: [\"Tab\", \"123\"\
    , \"781345\", \"-_-\"]) == \"__HAHA.123\")\nassert(Strongest_Extension(class_name:\
    \ \"YameRore\", extensions: [\"HhAas\", \"okIWILL123\", \"WorkOut\", \"Fails\"\
    , \"-_-\"]) == \"YameRore.okIWILL123\")\nassert(Strongest_Extension(class_name:\
    \ \"finNNalLLly\", extensions: [\"Die\", \"NowW\", \"Wow\", \"WoW\"]) == \"finNNalLLly.WoW\"\
    )\nassert(Strongest_Extension(class_name: \"_\", extensions: [\"Bb\", \"91245\"\
    ]) == \"_.Bb\")\nassert(Strongest_Extension(class_name: \"Sp\", extensions: [\"\
    671235\", \"Bb\"]) == \"Sp.671235\")"
  status: Exception
  stderr: 'tmpfqxm_9h_/tmpfqxm_9h_.swift:46: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b42fcb8fc80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b42fc886b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b42fc886988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b42fc8857b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpfqxm_9h_                        0x000055806dd9efac <unavailable> + 8108

    5    libc.so.6                          0x00002b42fcd7b460 __libc_start_main +
    245

    6    tmpfqxm_9h_                        0x000055806dd9e6b9 <unavailable> + 5817

    '
  stdout: ''
  timestamp: 1660009433
- exit_code: 1
  program: "\n/// You will be given the name of a class (a string) and an array of\
    \ extensions.\n/// The extensions are to be used to load additional classes to\
    \ the class. The\n/// strength of the extension is as follows: Let CAP be the\
    \ number of the uppercase\n/// letters in the extension's name, and let SM be\
    \ the number of lowercase letters \n/// in the extension's name, the strength\
    \ is given by the fraction CAP - SM. \n/// You should find the strongest extension\
    \ and return a string in this \n/// format: ClassName.StrongestExtensionName.\n\
    /// If there are two or more extensions with the same strength, you should\n///\
    \ choose the one that comes first in the array.\n/// For example, if you are given\
    \ \"Slices\" as the class and an array of the\n/// extensions: ['SErviNGSliCes',\
    \ 'Cheese', 'StuFfed'] then you should\n/// return 'Slices.SErviNGSliCes' since\
    \ 'SErviNGSliCes' is the strongest extension \n/// (its strength is -1).\n///\
    \ Example:\n/// >>> Strongest_Extension(class_name: \"my_class\", extensions:\
    \ [\"AA\", \"Be\", \"CC\"])\n/// \"my_class.AA\"\nfunc Strongest_Extension(class_name:\
    \ String, extensions: [String]) -> String {\n  let strongest_extension_strength\
    \ = extensions.reduce(0.0) { \n    max($0, Double(extensions[0].uppercased().filter{\
    \ $0 >= \"A\" && $0 <= \"Z\" }.count) - Double(extensions[0].lowercased().filter{\
    \ $0 >= \"a\" && $0 <= \"z\" }.count))\n  }\n  return \"\\(class_name).\\(extensions.first(where:\
    \ {\n    (Double($0.uppercased().filter{ $0 >= \"A\" && $0 <= \"Z\" }.count) -\
    \ Double($0.lowercased().filter{ $0 >= \"a\" && $0 <= \"z\" }.count)) == strongest_extension_strength\n\
    \  }))\"\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n\
    \    if left.count != right.count {\n        return false\n    }\n    for (l,\
    \ r) in zip(left, right) {\n        if l != r {\n            return false\n  \
    \      }\n    }\n    return true\n}\n            \nassert(Strongest_Extension(class_name:\
    \ \"Watashi\", extensions: [\"tEN\", \"niNE\", \"eIGHt8OKe\"]) == \"Watashi.eIGHt8OKe\"\
    )\nassert(Strongest_Extension(class_name: \"Boku123\", extensions: [\"nani\",\
    \ \"NazeDa\", \"YEs.WeCaNe\", \"32145tggg\"]) == \"Boku123.YEs.WeCaNe\")\nassert(Strongest_Extension(class_name:\
    \ \"__YESIMHERE\", extensions: [\"t\", \"eMptY\", \"nothing\", \"zeR00\", \"NuLl__\"\
    , \"123NoooneB321\"]) == \"__YESIMHERE.NuLl__\")\nassert(Strongest_Extension(class_name:\
    \ \"K\", extensions: [\"Ta\", \"TAR\", \"t234An\", \"cosSo\"]) == \"K.TAR\")\n\
    assert(Strongest_Extension(class_name: \"__HAHA\", extensions: [\"Tab\", \"123\"\
    , \"781345\", \"-_-\"]) == \"__HAHA.123\")\nassert(Strongest_Extension(class_name:\
    \ \"YameRore\", extensions: [\"HhAas\", \"okIWILL123\", \"WorkOut\", \"Fails\"\
    , \"-_-\"]) == \"YameRore.okIWILL123\")\nassert(Strongest_Extension(class_name:\
    \ \"finNNalLLly\", extensions: [\"Die\", \"NowW\", \"Wow\", \"WoW\"]) == \"finNNalLLly.WoW\"\
    )\nassert(Strongest_Extension(class_name: \"_\", extensions: [\"Bb\", \"91245\"\
    ]) == \"_.Bb\")\nassert(Strongest_Extension(class_name: \"Sp\", extensions: [\"\
    671235\", \"Bb\"]) == \"Sp.671235\")"
  status: SyntaxError
  stderr: "/tmp/tmp0w0l_k10.swift:22:26: error: cannot find ')' to match opening '('\
    \ in string interpolation\n  return \"\\(class_name).\\(extensions.first(where:\
    \ {\n                         ^\n/tmp/tmp0w0l_k10.swift:22:10: error: unterminated\
    \ string literal\n  return \"\\(class_name).\\(extensions.first(where: {\n   \
    \      ^\n/tmp/tmp0w0l_k10.swift:24:4: error: consecutive statements on a line\
    \ must be separated by ';'\n  }))\"\n   ^\n   ;\n/tmp/tmp0w0l_k10.swift:24:4:\
    \ error: expected expression\n  }))\"\n   ^\n/tmp/tmp0w0l_k10.swift:24:6: error:\
    \ unterminated string literal\n  }))\"\n     ^\n/tmp/tmp0w0l_k10.swift:25:1: error:\
    \ extraneous '}' at top level\n}\n^\n/tmp/tmp0w0l_k10.swift:19:61: error: contextual\
    \ closure type '(Double, String) throws -> Double' expects 2 arguments, but 1\
    \ was used in closure body\n  let strongest_extension_strength = extensions.reduce(0.0)\
    \ { \n                                                            ^\n"
  stdout: ''
  timestamp: 1660009434
- exit_code: -4
  program: "\n/// You will be given the name of a class (a string) and an array of\
    \ extensions.\n/// The extensions are to be used to load additional classes to\
    \ the class. The\n/// strength of the extension is as follows: Let CAP be the\
    \ number of the uppercase\n/// letters in the extension's name, and let SM be\
    \ the number of lowercase letters \n/// in the extension's name, the strength\
    \ is given by the fraction CAP - SM. \n/// You should find the strongest extension\
    \ and return a string in this \n/// format: ClassName.StrongestExtensionName.\n\
    /// If there are two or more extensions with the same strength, you should\n///\
    \ choose the one that comes first in the array.\n/// For example, if you are given\
    \ \"Slices\" as the class and an array of the\n/// extensions: ['SErviNGSliCes',\
    \ 'Cheese', 'StuFfed'] then you should\n/// return 'Slices.SErviNGSliCes' since\
    \ 'SErviNGSliCes' is the strongest extension \n/// (its strength is -1).\n///\
    \ Example:\n/// >>> Strongest_Extension(class_name: \"my_class\", extensions:\
    \ [\"AA\", \"Be\", \"CC\"])\n/// \"my_class.AA\"\nfunc Strongest_Extension(class_name:\
    \ String, extensions: [String]) -> String {\n    var strongest_extension: String\
    \ = \"\";\n    var strongest_extension_strength: Double = 0;\n    for ext in extensions\
    \ {\n        let ext_strength = Double(ext.uppercased().count) - Double(ext.lowercased().count);\n\
    \        if ext_strength > strongest_extension_strength {\n            strongest_extension\
    \ = ext;\n            strongest_extension_strength = ext_strength;\n        }\n\
    \    }\n    return \"\\(class_name).\\(strongest_extension)\";\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(Strongest_Extension(class_name: \"Watashi\", extensions:\
    \ [\"tEN\", \"niNE\", \"eIGHt8OKe\"]) == \"Watashi.eIGHt8OKe\")\nassert(Strongest_Extension(class_name:\
    \ \"Boku123\", extensions: [\"nani\", \"NazeDa\", \"YEs.WeCaNe\", \"32145tggg\"\
    ]) == \"Boku123.YEs.WeCaNe\")\nassert(Strongest_Extension(class_name: \"__YESIMHERE\"\
    , extensions: [\"t\", \"eMptY\", \"nothing\", \"zeR00\", \"NuLl__\", \"123NoooneB321\"\
    ]) == \"__YESIMHERE.NuLl__\")\nassert(Strongest_Extension(class_name: \"K\", extensions:\
    \ [\"Ta\", \"TAR\", \"t234An\", \"cosSo\"]) == \"K.TAR\")\nassert(Strongest_Extension(class_name:\
    \ \"__HAHA\", extensions: [\"Tab\", \"123\", \"781345\", \"-_-\"]) == \"__HAHA.123\"\
    )\nassert(Strongest_Extension(class_name: \"YameRore\", extensions: [\"HhAas\"\
    , \"okIWILL123\", \"WorkOut\", \"Fails\", \"-_-\"]) == \"YameRore.okIWILL123\"\
    )\nassert(Strongest_Extension(class_name: \"finNNalLLly\", extensions: [\"Die\"\
    , \"NowW\", \"Wow\", \"WoW\"]) == \"finNNalLLly.WoW\")\nassert(Strongest_Extension(class_name:\
    \ \"_\", extensions: [\"Bb\", \"91245\"]) == \"_.Bb\")\nassert(Strongest_Extension(class_name:\
    \ \"Sp\", extensions: [\"671235\", \"Bb\"]) == \"Sp.671235\")"
  status: Exception
  stderr: 'tmp57sl_24o/tmp57sl_24o.swift:44: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002ab54dbdfc80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002ab54d8d6b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002ab54d8d6988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002ab54d8d57b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmp57sl_24o                        0x000055b757c25a2d <unavailable> + 6701

    5    libc.so.6                          0x00002ab54ddcb460 __libc_start_main +
    245

    6    tmp57sl_24o                        0x000055b757c255b9 <unavailable> + 5561

    '
  stdout: ''
  timestamp: 1660009433
- exit_code: -4
  program: "\n/// You will be given the name of a class (a string) and an array of\
    \ extensions.\n/// The extensions are to be used to load additional classes to\
    \ the class. The\n/// strength of the extension is as follows: Let CAP be the\
    \ number of the uppercase\n/// letters in the extension's name, and let SM be\
    \ the number of lowercase letters \n/// in the extension's name, the strength\
    \ is given by the fraction CAP - SM. \n/// You should find the strongest extension\
    \ and return a string in this \n/// format: ClassName.StrongestExtensionName.\n\
    /// If there are two or more extensions with the same strength, you should\n///\
    \ choose the one that comes first in the array.\n/// For example, if you are given\
    \ \"Slices\" as the class and an array of the\n/// extensions: ['SErviNGSliCes',\
    \ 'Cheese', 'StuFfed'] then you should\n/// return 'Slices.SErviNGSliCes' since\
    \ 'SErviNGSliCes' is the strongest extension \n/// (its strength is -1).\n///\
    \ Example:\n/// >>> Strongest_Extension(class_name: \"my_class\", extensions:\
    \ [\"AA\", \"Be\", \"CC\"])\n/// \"my_class.AA\"\nfunc Strongest_Extension(class_name:\
    \ String, extensions: [String]) -> String {\n    var strength = 0\n    var strongest\
    \ = \"\"\n    for ext in extensions {\n        let cap = ext.filter { Int(String($0))\
    \ != nil || String($0) == \"_\" }.count\n        let sm = ext.filter { Int(String($0))\
    \ == nil && String($0) != \"_\" }.count\n        if cap - sm > strength {\n  \
    \          strength = cap - sm\n            strongest = ext\n        }\n    }\n\
    \    return \"\\(class_name).\\(strongest)\"\n}\n\n\nfunc ==(left: [(Int, Int)],\
    \ right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n       \
    \ return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r\
    \ {\n            return false\n        }\n    }\n    return true\n}\n        \
    \    \nassert(Strongest_Extension(class_name: \"Watashi\", extensions: [\"tEN\"\
    , \"niNE\", \"eIGHt8OKe\"]) == \"Watashi.eIGHt8OKe\")\nassert(Strongest_Extension(class_name:\
    \ \"Boku123\", extensions: [\"nani\", \"NazeDa\", \"YEs.WeCaNe\", \"32145tggg\"\
    ]) == \"Boku123.YEs.WeCaNe\")\nassert(Strongest_Extension(class_name: \"__YESIMHERE\"\
    , extensions: [\"t\", \"eMptY\", \"nothing\", \"zeR00\", \"NuLl__\", \"123NoooneB321\"\
    ]) == \"__YESIMHERE.NuLl__\")\nassert(Strongest_Extension(class_name: \"K\", extensions:\
    \ [\"Ta\", \"TAR\", \"t234An\", \"cosSo\"]) == \"K.TAR\")\nassert(Strongest_Extension(class_name:\
    \ \"__HAHA\", extensions: [\"Tab\", \"123\", \"781345\", \"-_-\"]) == \"__HAHA.123\"\
    )\nassert(Strongest_Extension(class_name: \"YameRore\", extensions: [\"HhAas\"\
    , \"okIWILL123\", \"WorkOut\", \"Fails\", \"-_-\"]) == \"YameRore.okIWILL123\"\
    )\nassert(Strongest_Extension(class_name: \"finNNalLLly\", extensions: [\"Die\"\
    , \"NowW\", \"Wow\", \"WoW\"]) == \"finNNalLLly.WoW\")\nassert(Strongest_Extension(class_name:\
    \ \"_\", extensions: [\"Bb\", \"91245\"]) == \"_.Bb\")\nassert(Strongest_Extension(class_name:\
    \ \"Sp\", extensions: [\"671235\", \"Bb\"]) == \"Sp.671235\")"
  status: Exception
  stderr: 'tmp8956br8y/tmp8956br8y.swift:45: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b6cab2aec80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b6caafa5b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b6caafa5988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b6caafa47b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmp8956br8y                        0x000055809533cb1d <unavailable> + 6941

    5    libc.so.6                          0x00002b6cab49a460 __libc_start_main +
    245

    6    tmp8956br8y                        0x000055809533c6a9 <unavailable> + 5801

    '
  stdout: ''
  timestamp: 1660009433
- exit_code: -4
  program: "\n/// You will be given the name of a class (a string) and an array of\
    \ extensions.\n/// The extensions are to be used to load additional classes to\
    \ the class. The\n/// strength of the extension is as follows: Let CAP be the\
    \ number of the uppercase\n/// letters in the extension's name, and let SM be\
    \ the number of lowercase letters \n/// in the extension's name, the strength\
    \ is given by the fraction CAP - SM. \n/// You should find the strongest extension\
    \ and return a string in this \n/// format: ClassName.StrongestExtensionName.\n\
    /// If there are two or more extensions with the same strength, you should\n///\
    \ choose the one that comes first in the array.\n/// For example, if you are given\
    \ \"Slices\" as the class and an array of the\n/// extensions: ['SErviNGSliCes',\
    \ 'Cheese', 'StuFfed'] then you should\n/// return 'Slices.SErviNGSliCes' since\
    \ 'SErviNGSliCes' is the strongest extension \n/// (its strength is -1).\n///\
    \ Example:\n/// >>> Strongest_Extension(class_name: \"my_class\", extensions:\
    \ [\"AA\", \"Be\", \"CC\"])\n/// \"my_class.AA\"\nfunc Strongest_Extension(class_name:\
    \ String, extensions: [String]) -> String {\n    var current_strongest = 0.0\n\
    \    var current_strongest_extension = \"\"\n    for ext in extensions {\n   \
    \     let uppercase_count = Double(ext.filter { $0.isUppercase }.count)\n    \
    \    let lowercase_count = Double(ext.filter { $0.isLowercase }.count)\n     \
    \   let strength = uppercase_count - lowercase_count\n        if strength > current_strongest\
    \ {\n            current_strongest = strength\n            current_strongest_extension\
    \ = ext\n        }\n    }\n    return \"\\(class_name).\\(current_strongest_extension)\"\
    \n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(Strongest_Extension(class_name: \"Watashi\", extensions:\
    \ [\"tEN\", \"niNE\", \"eIGHt8OKe\"]) == \"Watashi.eIGHt8OKe\")\nassert(Strongest_Extension(class_name:\
    \ \"Boku123\", extensions: [\"nani\", \"NazeDa\", \"YEs.WeCaNe\", \"32145tggg\"\
    ]) == \"Boku123.YEs.WeCaNe\")\nassert(Strongest_Extension(class_name: \"__YESIMHERE\"\
    , extensions: [\"t\", \"eMptY\", \"nothing\", \"zeR00\", \"NuLl__\", \"123NoooneB321\"\
    ]) == \"__YESIMHERE.NuLl__\")\nassert(Strongest_Extension(class_name: \"K\", extensions:\
    \ [\"Ta\", \"TAR\", \"t234An\", \"cosSo\"]) == \"K.TAR\")\nassert(Strongest_Extension(class_name:\
    \ \"__HAHA\", extensions: [\"Tab\", \"123\", \"781345\", \"-_-\"]) == \"__HAHA.123\"\
    )\nassert(Strongest_Extension(class_name: \"YameRore\", extensions: [\"HhAas\"\
    , \"okIWILL123\", \"WorkOut\", \"Fails\", \"-_-\"]) == \"YameRore.okIWILL123\"\
    )\nassert(Strongest_Extension(class_name: \"finNNalLLly\", extensions: [\"Die\"\
    , \"NowW\", \"Wow\", \"WoW\"]) == \"finNNalLLly.WoW\")\nassert(Strongest_Extension(class_name:\
    \ \"_\", extensions: [\"Bb\", \"91245\"]) == \"_.Bb\")\nassert(Strongest_Extension(class_name:\
    \ \"Sp\", extensions: [\"671235\", \"Bb\"]) == \"Sp.671235\")"
  status: Exception
  stderr: 'tmpcs0ctszo/tmpcs0ctszo.swift:48: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b4a7cbeec80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b4a7c8e5b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b4a7c8e5988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b4a7c8e47b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpcs0ctszo                        0x00005615f1b57f4c <unavailable> + 8012

    5    libc.so.6                          0x00002b4a7cdda460 __libc_start_main +
    245

    6    tmpcs0ctszo                        0x00005615f1b57659 <unavailable> + 5721

    '
  stdout: ''
  timestamp: 1660009433
- exit_code: -4
  program: "\n/// You will be given the name of a class (a string) and an array of\
    \ extensions.\n/// The extensions are to be used to load additional classes to\
    \ the class. The\n/// strength of the extension is as follows: Let CAP be the\
    \ number of the uppercase\n/// letters in the extension's name, and let SM be\
    \ the number of lowercase letters \n/// in the extension's name, the strength\
    \ is given by the fraction CAP - SM. \n/// You should find the strongest extension\
    \ and return a string in this \n/// format: ClassName.StrongestExtensionName.\n\
    /// If there are two or more extensions with the same strength, you should\n///\
    \ choose the one that comes first in the array.\n/// For example, if you are given\
    \ \"Slices\" as the class and an array of the\n/// extensions: ['SErviNGSliCes',\
    \ 'Cheese', 'StuFfed'] then you should\n/// return 'Slices.SErviNGSliCes' since\
    \ 'SErviNGSliCes' is the strongest extension \n/// (its strength is -1).\n///\
    \ Example:\n/// >>> Strongest_Extension(class_name: \"my_class\", extensions:\
    \ [\"AA\", \"Be\", \"CC\"])\n/// \"my_class.AA\"\nfunc Strongest_Extension(class_name:\
    \ String, extensions: [String]) -> String {\n    // Write your code here.\n  \
    \  return \"\"\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool\
    \ {\n    if left.count != right.count {\n        return false\n    }\n    for\
    \ (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(Strongest_Extension(class_name:\
    \ \"Watashi\", extensions: [\"tEN\", \"niNE\", \"eIGHt8OKe\"]) == \"Watashi.eIGHt8OKe\"\
    )\nassert(Strongest_Extension(class_name: \"Boku123\", extensions: [\"nani\",\
    \ \"NazeDa\", \"YEs.WeCaNe\", \"32145tggg\"]) == \"Boku123.YEs.WeCaNe\")\nassert(Strongest_Extension(class_name:\
    \ \"__YESIMHERE\", extensions: [\"t\", \"eMptY\", \"nothing\", \"zeR00\", \"NuLl__\"\
    , \"123NoooneB321\"]) == \"__YESIMHERE.NuLl__\")\nassert(Strongest_Extension(class_name:\
    \ \"K\", extensions: [\"Ta\", \"TAR\", \"t234An\", \"cosSo\"]) == \"K.TAR\")\n\
    assert(Strongest_Extension(class_name: \"__HAHA\", extensions: [\"Tab\", \"123\"\
    , \"781345\", \"-_-\"]) == \"__HAHA.123\")\nassert(Strongest_Extension(class_name:\
    \ \"YameRore\", extensions: [\"HhAas\", \"okIWILL123\", \"WorkOut\", \"Fails\"\
    , \"-_-\"]) == \"YameRore.okIWILL123\")\nassert(Strongest_Extension(class_name:\
    \ \"finNNalLLly\", extensions: [\"Die\", \"NowW\", \"Wow\", \"WoW\"]) == \"finNNalLLly.WoW\"\
    )\nassert(Strongest_Extension(class_name: \"_\", extensions: [\"Bb\", \"91245\"\
    ]) == \"_.Bb\")\nassert(Strongest_Extension(class_name: \"Sp\", extensions: [\"\
    671235\", \"Bb\"]) == \"Sp.671235\")"
  status: Exception
  stderr: 'tmp7h5sins9/tmp7h5sins9.swift:36: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002aff37a2dc80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002aff37724b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002aff37724988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002aff377237b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmp7h5sins9                        0x0000557babc784fd <unavailable> + 5373

    5    libc.so.6                          0x00002aff37c19460 __libc_start_main +
    245

    6    tmp7h5sins9                        0x0000557babc78089 <unavailable> + 4233

    '
  stdout: ''
  timestamp: 1660009431
- exit_code: 0
  program: "\n/// You will be given the name of a class (a string) and an array of\
    \ extensions.\n/// The extensions are to be used to load additional classes to\
    \ the class. The\n/// strength of the extension is as follows: Let CAP be the\
    \ number of the uppercase\n/// letters in the extension's name, and let SM be\
    \ the number of lowercase letters \n/// in the extension's name, the strength\
    \ is given by the fraction CAP - SM. \n/// You should find the strongest extension\
    \ and return a string in this \n/// format: ClassName.StrongestExtensionName.\n\
    /// If there are two or more extensions with the same strength, you should\n///\
    \ choose the one that comes first in the array.\n/// For example, if you are given\
    \ \"Slices\" as the class and an array of the\n/// extensions: ['SErviNGSliCes',\
    \ 'Cheese', 'StuFfed'] then you should\n/// return 'Slices.SErviNGSliCes' since\
    \ 'SErviNGSliCes' is the strongest extension \n/// (its strength is -1).\n///\
    \ Example:\n/// >>> Strongest_Extension(class_name: \"my_class\", extensions:\
    \ [\"AA\", \"Be\", \"CC\"])\n/// \"my_class.AA\"\nfunc Strongest_Extension(class_name:\
    \ String, extensions: [String]) -> String {\n    let capital_counts = extensions.map\
    \ { $0.filter { $0.isUppercase }.count }\n    let small_counts = extensions.map\
    \ { $0.filter { $0.isLowercase }.count }\n    let strength = zip(capital_counts,\
    \ small_counts).map { $0.0 - $0.1 }\n    return class_name + \".\" + extensions[strength.firstIndex(of:\
    \ strength.max()!)!]\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(Strongest_Extension(class_name:\
    \ \"Watashi\", extensions: [\"tEN\", \"niNE\", \"eIGHt8OKe\"]) == \"Watashi.eIGHt8OKe\"\
    )\nassert(Strongest_Extension(class_name: \"Boku123\", extensions: [\"nani\",\
    \ \"NazeDa\", \"YEs.WeCaNe\", \"32145tggg\"]) == \"Boku123.YEs.WeCaNe\")\nassert(Strongest_Extension(class_name:\
    \ \"__YESIMHERE\", extensions: [\"t\", \"eMptY\", \"nothing\", \"zeR00\", \"NuLl__\"\
    , \"123NoooneB321\"]) == \"__YESIMHERE.NuLl__\")\nassert(Strongest_Extension(class_name:\
    \ \"K\", extensions: [\"Ta\", \"TAR\", \"t234An\", \"cosSo\"]) == \"K.TAR\")\n\
    assert(Strongest_Extension(class_name: \"__HAHA\", extensions: [\"Tab\", \"123\"\
    , \"781345\", \"-_-\"]) == \"__HAHA.123\")\nassert(Strongest_Extension(class_name:\
    \ \"YameRore\", extensions: [\"HhAas\", \"okIWILL123\", \"WorkOut\", \"Fails\"\
    , \"-_-\"]) == \"YameRore.okIWILL123\")\nassert(Strongest_Extension(class_name:\
    \ \"finNNalLLly\", extensions: [\"Die\", \"NowW\", \"Wow\", \"WoW\"]) == \"finNNalLLly.WoW\"\
    )\nassert(Strongest_Extension(class_name: \"_\", extensions: [\"Bb\", \"91245\"\
    ]) == \"_.Bb\")\nassert(Strongest_Extension(class_name: \"Sp\", extensions: [\"\
    671235\", \"Bb\"]) == \"Sp.671235\")"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660009433
- exit_code: 1
  program: "\n/// You will be given the name of a class (a string) and an array of\
    \ extensions.\n/// The extensions are to be used to load additional classes to\
    \ the class. The\n/// strength of the extension is as follows: Let CAP be the\
    \ number of the uppercase\n/// letters in the extension's name, and let SM be\
    \ the number of lowercase letters \n/// in the extension's name, the strength\
    \ is given by the fraction CAP - SM. \n/// You should find the strongest extension\
    \ and return a string in this \n/// format: ClassName.StrongestExtensionName.\n\
    /// If there are two or more extensions with the same strength, you should\n///\
    \ choose the one that comes first in the array.\n/// For example, if you are given\
    \ \"Slices\" as the class and an array of the\n/// extensions: ['SErviNGSliCes',\
    \ 'Cheese', 'StuFfed'] then you should\n/// return 'Slices.SErviNGSliCes' since\
    \ 'SErviNGSliCes' is the strongest extension \n/// (its strength is -1).\n///\
    \ Example:\n/// >>> Strongest_Extension(class_name: \"my_class\", extensions:\
    \ [\"AA\", \"Be\", \"CC\"])\n/// \"my_class.AA\"\nfunc Strongest_Extension(class_name:\
    \ String, extensions: [String]) -> String {\n    var strongest_extension = \"\"\
    \n    var strongest_strength = 0.0\n    for extension_name in extensions {\n \
    \       let lower_case_chars = extension_name.filter({$0.isLowercase})\n     \
    \   let upper_case_chars = extension_name.filter({$0.isUppercase})\n        let\
    \ strength = Float(upper_case_chars.count) - Float(lower_case_chars.count)\n \
    \       if strength > strongest_strength {\n            strongest_strength = strength\n\
    \            strongest_extension = extension_name\n        }\n    }\n    return\
    \ \"\\(class_name).\\(strongest_extension)\"\n}\n\n\nfunc ==(left: [(Int, Int)],\
    \ right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n       \
    \ return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r\
    \ {\n            return false\n        }\n    }\n    return true\n}\n        \
    \    \nassert(Strongest_Extension(class_name: \"Watashi\", extensions: [\"tEN\"\
    , \"niNE\", \"eIGHt8OKe\"]) == \"Watashi.eIGHt8OKe\")\nassert(Strongest_Extension(class_name:\
    \ \"Boku123\", extensions: [\"nani\", \"NazeDa\", \"YEs.WeCaNe\", \"32145tggg\"\
    ]) == \"Boku123.YEs.WeCaNe\")\nassert(Strongest_Extension(class_name: \"__YESIMHERE\"\
    , extensions: [\"t\", \"eMptY\", \"nothing\", \"zeR00\", \"NuLl__\", \"123NoooneB321\"\
    ]) == \"__YESIMHERE.NuLl__\")\nassert(Strongest_Extension(class_name: \"K\", extensions:\
    \ [\"Ta\", \"TAR\", \"t234An\", \"cosSo\"]) == \"K.TAR\")\nassert(Strongest_Extension(class_name:\
    \ \"__HAHA\", extensions: [\"Tab\", \"123\", \"781345\", \"-_-\"]) == \"__HAHA.123\"\
    )\nassert(Strongest_Extension(class_name: \"YameRore\", extensions: [\"HhAas\"\
    , \"okIWILL123\", \"WorkOut\", \"Fails\", \"-_-\"]) == \"YameRore.okIWILL123\"\
    )\nassert(Strongest_Extension(class_name: \"finNNalLLly\", extensions: [\"Die\"\
    , \"NowW\", \"Wow\", \"WoW\"]) == \"finNNalLLly.WoW\")\nassert(Strongest_Extension(class_name:\
    \ \"_\", extensions: [\"Bb\", \"91245\"]) == \"_.Bb\")\nassert(Strongest_Extension(class_name:\
    \ \"Sp\", extensions: [\"671235\", \"Bb\"]) == \"Sp.671235\")"
  status: SyntaxError
  stderr: "/tmp/tmp3biiwjk4.swift:25:21: error: binary operator '>' cannot be applied\
    \ to operands of type 'Float' and 'Double'\n        if strength > strongest_strength\
    \ {\n           ~~~~~~~~ ^ ~~~~~~~~~~~~~~~~~~\n/tmp/tmp3biiwjk4.swift:26:34: error:\
    \ cannot assign value of type 'Float' to type 'Double'\n            strongest_strength\
    \ = strength\n                                 ^~~~~~~~\n                    \
    \             Double( )\n"
  stdout: ''
  timestamp: 1660009433
- exit_code: 1
  program: "\n/// You will be given the name of a class (a string) and an array of\
    \ extensions.\n/// The extensions are to be used to load additional classes to\
    \ the class. The\n/// strength of the extension is as follows: Let CAP be the\
    \ number of the uppercase\n/// letters in the extension's name, and let SM be\
    \ the number of lowercase letters \n/// in the extension's name, the strength\
    \ is given by the fraction CAP - SM. \n/// You should find the strongest extension\
    \ and return a string in this \n/// format: ClassName.StrongestExtensionName.\n\
    /// If there are two or more extensions with the same strength, you should\n///\
    \ choose the one that comes first in the array.\n/// For example, if you are given\
    \ \"Slices\" as the class and an array of the\n/// extensions: ['SErviNGSliCes',\
    \ 'Cheese', 'StuFfed'] then you should\n/// return 'Slices.SErviNGSliCes' since\
    \ 'SErviNGSliCes' is the strongest extension \n/// (its strength is -1).\n///\
    \ Example:\n/// >>> Strongest_Extension(class_name: \"my_class\", extensions:\
    \ [\"AA\", \"Be\", \"CC\"])\n/// \"my_class.AA\"\nfunc Strongest_Extension(class_name:\
    \ String, extensions: [String]) -> String {\n    var strongest = extensions[0]\n\
    \    var strongest_value = strength(strongest)\n    for extension in extensions\
    \ {\n        let value = strength(extension)\n        if value > strongest_value\
    \ {\n            strongest = extension\n            strongest_value = value\n\
    \        }\n    }\n    return \"\\(class_name).\\(strongest)\"\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(Strongest_Extension(class_name: \"Watashi\", extensions:\
    \ [\"tEN\", \"niNE\", \"eIGHt8OKe\"]) == \"Watashi.eIGHt8OKe\")\nassert(Strongest_Extension(class_name:\
    \ \"Boku123\", extensions: [\"nani\", \"NazeDa\", \"YEs.WeCaNe\", \"32145tggg\"\
    ]) == \"Boku123.YEs.WeCaNe\")\nassert(Strongest_Extension(class_name: \"__YESIMHERE\"\
    , extensions: [\"t\", \"eMptY\", \"nothing\", \"zeR00\", \"NuLl__\", \"123NoooneB321\"\
    ]) == \"__YESIMHERE.NuLl__\")\nassert(Strongest_Extension(class_name: \"K\", extensions:\
    \ [\"Ta\", \"TAR\", \"t234An\", \"cosSo\"]) == \"K.TAR\")\nassert(Strongest_Extension(class_name:\
    \ \"__HAHA\", extensions: [\"Tab\", \"123\", \"781345\", \"-_-\"]) == \"__HAHA.123\"\
    )\nassert(Strongest_Extension(class_name: \"YameRore\", extensions: [\"HhAas\"\
    , \"okIWILL123\", \"WorkOut\", \"Fails\", \"-_-\"]) == \"YameRore.okIWILL123\"\
    )\nassert(Strongest_Extension(class_name: \"finNNalLLly\", extensions: [\"Die\"\
    , \"NowW\", \"Wow\", \"WoW\"]) == \"finNNalLLly.WoW\")\nassert(Strongest_Extension(class_name:\
    \ \"_\", extensions: [\"Bb\", \"91245\"]) == \"_.Bb\")\nassert(Strongest_Extension(class_name:\
    \ \"Sp\", extensions: [\"671235\", \"Bb\"]) == \"Sp.671235\")"
  status: SyntaxError
  stderr: "/tmp/tmppx9pd29v.swift:21:9: error: expected pattern\n    for extension\
    \ in extensions {\n        ^\n/tmp/tmppx9pd29v.swift:21:9: error: expected Sequence\
    \ expression for for-each loop\n    for extension in extensions {\n        ^\n\
    /tmp/tmppx9pd29v.swift:21:9: error: expected '{' to start the body of for-each\
    \ loop\n    for extension in extensions {\n        ^\n/tmp/tmppx9pd29v.swift:22:30:\
    \ error: expected expression in list of expressions\n        let value = strength(extension)\n\
    \                             ^\n/tmp/tmppx9pd29v.swift:22:30: error: consecutive\
    \ statements on a line must be separated by ';'\n        let value = strength(extension)\n\
    \                             ^\n                             ;\n/tmp/tmppx9pd29v.swift:22:39:\
    \ error: expected type name in extension declaration\n        let value = strength(extension)\n\
    \                                      ^\n                                   \
    \    <#type#>\n/tmp/tmppx9pd29v.swift:22:39: error: expected '{' in extension\n\
    \        let value = strength(extension)\n                                   \
    \   ^\n/tmp/tmppx9pd29v.swift:22:30: error: declaration is only valid at file\
    \ scope\n        let value = strength(extension)\n                           \
    \  ^\n/tmp/tmppx9pd29v.swift:24:25: error: expected expression in assignment\n\
    \            strongest = extension\n                        ^\n/tmp/tmppx9pd29v.swift:25:29:\
    \ error: expected '{' in extension\n            strongest_value = value\n    \
    \                        ^\n/tmp/tmppx9pd29v.swift:24:25: error: declaration is\
    \ only valid at file scope\n            strongest = extension\n              \
    \          ^\n/tmp/tmppx9pd29v.swift:25:13: error: cannot find type 'strongest_value'\
    \ in scope\n            strongest_value = value\n            ^~~~~~~~~~~~~~~\n\
    /tmp/tmppx9pd29v.swift:20:27: error: cannot find 'strength' in scope\n    var\
    \ strongest_value = strength(strongest)\n                          ^~~~~~~~\n\
    /tmp/tmppx9pd29v.swift:22:21: error: cannot find 'strength' in scope\n       \
    \ let value = strength(extension)\n                    ^~~~~~~~\n"
  stdout: ''
  timestamp: 1660009433
- exit_code: 1
  program: "\n/// You will be given the name of a class (a string) and an array of\
    \ extensions.\n/// The extensions are to be used to load additional classes to\
    \ the class. The\n/// strength of the extension is as follows: Let CAP be the\
    \ number of the uppercase\n/// letters in the extension's name, and let SM be\
    \ the number of lowercase letters \n/// in the extension's name, the strength\
    \ is given by the fraction CAP - SM. \n/// You should find the strongest extension\
    \ and return a string in this \n/// format: ClassName.StrongestExtensionName.\n\
    /// If there are two or more extensions with the same strength, you should\n///\
    \ choose the one that comes first in the array.\n/// For example, if you are given\
    \ \"Slices\" as the class and an array of the\n/// extensions: ['SErviNGSliCes',\
    \ 'Cheese', 'StuFfed'] then you should\n/// return 'Slices.SErviNGSliCes' since\
    \ 'SErviNGSliCes' is the strongest extension \n/// (its strength is -1).\n///\
    \ Example:\n/// >>> Strongest_Extension(class_name: \"my_class\", extensions:\
    \ [\"AA\", \"Be\", \"CC\"])\n/// \"my_class.AA\"\nfunc Strongest_Extension(class_name:\
    \ String, extensions: [String]) -> String {\n    var strongest_extension: (strength:\
    \ Double, ext: String) = (0, \"\")\n    for ext in extensions {\n        var CAP\
    \ = 0\n        var SM = 0\n        for c in ext {\n            if CharacterSet.uppercaseLetters.contains(UnicodeScalar(String(c))!)\
    \ {\n                CAP += 1\n            } else {\n                SM += 1\n\
    \            }\n        }\n        if (Double(CAP) - Double(SM)) > strongest_extension.strength\
    \ {\n            strongest_extension = (Double(CAP) - Double(SM), ext)\n     \
    \   }\n    }\n    return class_name + \".\" + strongest_extension.ext\n}\n\n\n\
    func ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(Strongest_Extension(class_name: \"Watashi\", extensions:\
    \ [\"tEN\", \"niNE\", \"eIGHt8OKe\"]) == \"Watashi.eIGHt8OKe\")\nassert(Strongest_Extension(class_name:\
    \ \"Boku123\", extensions: [\"nani\", \"NazeDa\", \"YEs.WeCaNe\", \"32145tggg\"\
    ]) == \"Boku123.YEs.WeCaNe\")\nassert(Strongest_Extension(class_name: \"__YESIMHERE\"\
    , extensions: [\"t\", \"eMptY\", \"nothing\", \"zeR00\", \"NuLl__\", \"123NoooneB321\"\
    ]) == \"__YESIMHERE.NuLl__\")\nassert(Strongest_Extension(class_name: \"K\", extensions:\
    \ [\"Ta\", \"TAR\", \"t234An\", \"cosSo\"]) == \"K.TAR\")\nassert(Strongest_Extension(class_name:\
    \ \"__HAHA\", extensions: [\"Tab\", \"123\", \"781345\", \"-_-\"]) == \"__HAHA.123\"\
    )\nassert(Strongest_Extension(class_name: \"YameRore\", extensions: [\"HhAas\"\
    , \"okIWILL123\", \"WorkOut\", \"Fails\", \"-_-\"]) == \"YameRore.okIWILL123\"\
    )\nassert(Strongest_Extension(class_name: \"finNNalLLly\", extensions: [\"Die\"\
    , \"NowW\", \"Wow\", \"WoW\"]) == \"finNNalLLly.WoW\")\nassert(Strongest_Extension(class_name:\
    \ \"_\", extensions: [\"Bb\", \"91245\"]) == \"_.Bb\")\nassert(Strongest_Extension(class_name:\
    \ \"Sp\", extensions: [\"671235\", \"Bb\"]) == \"Sp.671235\")"
  status: SyntaxError
  stderr: "/tmp/tmpq0usdcgk.swift:24:16: error: cannot find 'CharacterSet' in scope\n\
    \            if CharacterSet.uppercaseLetters.contains(UnicodeScalar(String(c))!)\
    \ {\n               ^~~~~~~~~~~~\n"
  stdout: ''
  timestamp: 1660009433
- exit_code: -4
  program: "\n/// You will be given the name of a class (a string) and an array of\
    \ extensions.\n/// The extensions are to be used to load additional classes to\
    \ the class. The\n/// strength of the extension is as follows: Let CAP be the\
    \ number of the uppercase\n/// letters in the extension's name, and let SM be\
    \ the number of lowercase letters \n/// in the extension's name, the strength\
    \ is given by the fraction CAP - SM. \n/// You should find the strongest extension\
    \ and return a string in this \n/// format: ClassName.StrongestExtensionName.\n\
    /// If there are two or more extensions with the same strength, you should\n///\
    \ choose the one that comes first in the array.\n/// For example, if you are given\
    \ \"Slices\" as the class and an array of the\n/// extensions: ['SErviNGSliCes',\
    \ 'Cheese', 'StuFfed'] then you should\n/// return 'Slices.SErviNGSliCes' since\
    \ 'SErviNGSliCes' is the strongest extension \n/// (its strength is -1).\n///\
    \ Example:\n/// >>> Strongest_Extension(class_name: \"my_class\", extensions:\
    \ [\"AA\", \"Be\", \"CC\"])\n/// \"my_class.AA\"\nfunc Strongest_Extension(class_name:\
    \ String, extensions: [String]) -> String {\n    let count = (extensions.count)\n\
    \    if count == 0 {\n        return \"\"\n    }\n    var strongest_extension\
    \ = \"\"\n    var strongest_strength = 0.0\n    for extension_name in extensions\
    \ {\n        let cap = extension_name.filter {$0.isUppercase}.count\n        let\
    \ sm = extension_name.filter {$0.isLowercase}.count\n        let strength = Double(cap\
    \ - sm)\n        if strength > strongest_strength {\n            strongest_strength\
    \ = strength\n            strongest_extension = extension_name\n        }\n  \
    \  }\n    return \"\\(class_name).\\(strongest_extension)\"\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(Strongest_Extension(class_name: \"Watashi\", extensions:\
    \ [\"tEN\", \"niNE\", \"eIGHt8OKe\"]) == \"Watashi.eIGHt8OKe\")\nassert(Strongest_Extension(class_name:\
    \ \"Boku123\", extensions: [\"nani\", \"NazeDa\", \"YEs.WeCaNe\", \"32145tggg\"\
    ]) == \"Boku123.YEs.WeCaNe\")\nassert(Strongest_Extension(class_name: \"__YESIMHERE\"\
    , extensions: [\"t\", \"eMptY\", \"nothing\", \"zeR00\", \"NuLl__\", \"123NoooneB321\"\
    ]) == \"__YESIMHERE.NuLl__\")\nassert(Strongest_Extension(class_name: \"K\", extensions:\
    \ [\"Ta\", \"TAR\", \"t234An\", \"cosSo\"]) == \"K.TAR\")\nassert(Strongest_Extension(class_name:\
    \ \"__HAHA\", extensions: [\"Tab\", \"123\", \"781345\", \"-_-\"]) == \"__HAHA.123\"\
    )\nassert(Strongest_Extension(class_name: \"YameRore\", extensions: [\"HhAas\"\
    , \"okIWILL123\", \"WorkOut\", \"Fails\", \"-_-\"]) == \"YameRore.okIWILL123\"\
    )\nassert(Strongest_Extension(class_name: \"finNNalLLly\", extensions: [\"Die\"\
    , \"NowW\", \"Wow\", \"WoW\"]) == \"finNNalLLly.WoW\")\nassert(Strongest_Extension(class_name:\
    \ \"_\", extensions: [\"Bb\", \"91245\"]) == \"_.Bb\")\nassert(Strongest_Extension(class_name:\
    \ \"Sp\", extensions: [\"671235\", \"Bb\"]) == \"Sp.671235\")"
  status: Exception
  stderr: 'tmpmoex0alb/tmpmoex0alb.swift:52: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b28126b0c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b28123a7b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b28123a7988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b28123a67b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpmoex0alb                        0x00005647ba7f7fac <unavailable> + 8108

    5    libc.so.6                          0x00002b281289c460 __libc_start_main +
    245

    6    tmpmoex0alb                        0x00005647ba7f76b9 <unavailable> + 5817

    '
  stdout: ''
  timestamp: 1660009433
- exit_code: 1
  program: "\n/// You will be given the name of a class (a string) and an array of\
    \ extensions.\n/// The extensions are to be used to load additional classes to\
    \ the class. The\n/// strength of the extension is as follows: Let CAP be the\
    \ number of the uppercase\n/// letters in the extension's name, and let SM be\
    \ the number of lowercase letters \n/// in the extension's name, the strength\
    \ is given by the fraction CAP - SM. \n/// You should find the strongest extension\
    \ and return a string in this \n/// format: ClassName.StrongestExtensionName.\n\
    /// If there are two or more extensions with the same strength, you should\n///\
    \ choose the one that comes first in the array.\n/// For example, if you are given\
    \ \"Slices\" as the class and an array of the\n/// extensions: ['SErviNGSliCes',\
    \ 'Cheese', 'StuFfed'] then you should\n/// return 'Slices.SErviNGSliCes' since\
    \ 'SErviNGSliCes' is the strongest extension \n/// (its strength is -1).\n///\
    \ Example:\n/// >>> Strongest_Extension(class_name: \"my_class\", extensions:\
    \ [\"AA\", \"Be\", \"CC\"])\n/// \"my_class.AA\"\nfunc Strongest_Extension(class_name:\
    \ String, extensions: [String]) -> String {\n    let className = \"my_class\"\n\
    \    let exts = [\"AA\", \"Be\", \"CC\"]\n    var strongestExt = \"\"\n    var\
    \ strongestStrength = 0.0\n    for ext in exts {\n        let strength = calculateStrength(ext)\n\
    \        if strength > strongestStrength {\n            strongestStrength = strength\n\
    \            strongestExt = ext\n        }\n    }\n    return className + \".\"\
    \ + strongestExt\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool\
    \ {\n    if left.count != right.count {\n        return false\n    }\n    for\
    \ (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(Strongest_Extension(class_name:\
    \ \"Watashi\", extensions: [\"tEN\", \"niNE\", \"eIGHt8OKe\"]) == \"Watashi.eIGHt8OKe\"\
    )\nassert(Strongest_Extension(class_name: \"Boku123\", extensions: [\"nani\",\
    \ \"NazeDa\", \"YEs.WeCaNe\", \"32145tggg\"]) == \"Boku123.YEs.WeCaNe\")\nassert(Strongest_Extension(class_name:\
    \ \"__YESIMHERE\", extensions: [\"t\", \"eMptY\", \"nothing\", \"zeR00\", \"NuLl__\"\
    , \"123NoooneB321\"]) == \"__YESIMHERE.NuLl__\")\nassert(Strongest_Extension(class_name:\
    \ \"K\", extensions: [\"Ta\", \"TAR\", \"t234An\", \"cosSo\"]) == \"K.TAR\")\n\
    assert(Strongest_Extension(class_name: \"__HAHA\", extensions: [\"Tab\", \"123\"\
    , \"781345\", \"-_-\"]) == \"__HAHA.123\")\nassert(Strongest_Extension(class_name:\
    \ \"YameRore\", extensions: [\"HhAas\", \"okIWILL123\", \"WorkOut\", \"Fails\"\
    , \"-_-\"]) == \"YameRore.okIWILL123\")\nassert(Strongest_Extension(class_name:\
    \ \"finNNalLLly\", extensions: [\"Die\", \"NowW\", \"Wow\", \"WoW\"]) == \"finNNalLLly.WoW\"\
    )\nassert(Strongest_Extension(class_name: \"_\", extensions: [\"Bb\", \"91245\"\
    ]) == \"_.Bb\")\nassert(Strongest_Extension(class_name: \"Sp\", extensions: [\"\
    671235\", \"Bb\"]) == \"Sp.671235\")"
  status: SyntaxError
  stderr: "/tmp/tmp0iyex3li.swift:24:24: error: cannot find 'calculateStrength' in\
    \ scope\n        let strength = calculateStrength(ext)\n                     \
    \  ^~~~~~~~~~~~~~~~~\n"
  stdout: ''
  timestamp: 1660009433
- exit_code: -4
  program: "\n/// You will be given the name of a class (a string) and an array of\
    \ extensions.\n/// The extensions are to be used to load additional classes to\
    \ the class. The\n/// strength of the extension is as follows: Let CAP be the\
    \ number of the uppercase\n/// letters in the extension's name, and let SM be\
    \ the number of lowercase letters \n/// in the extension's name, the strength\
    \ is given by the fraction CAP - SM. \n/// You should find the strongest extension\
    \ and return a string in this \n/// format: ClassName.StrongestExtensionName.\n\
    /// If there are two or more extensions with the same strength, you should\n///\
    \ choose the one that comes first in the array.\n/// For example, if you are given\
    \ \"Slices\" as the class and an array of the\n/// extensions: ['SErviNGSliCes',\
    \ 'Cheese', 'StuFfed'] then you should\n/// return 'Slices.SErviNGSliCes' since\
    \ 'SErviNGSliCes' is the strongest extension \n/// (its strength is -1).\n///\
    \ Example:\n/// >>> Strongest_Extension(class_name: \"my_class\", extensions:\
    \ [\"AA\", \"Be\", \"CC\"])\n/// \"my_class.AA\"\nfunc Strongest_Extension(class_name:\
    \ String, extensions: [String]) -> String {\n    var strongest: Int = 0\n    var\
    \ strongest_extension: String = \"\"\n    for each in extensions {\n        var\
    \ count_upper: Int = 0\n        var count_lower: Int = 0\n        for char in\
    \ each {\n            if char.isUppercase {\n                count_upper += 1\n\
    \            } else {\n                count_lower += 1\n            }\n     \
    \   }\n        let strength: Int = count_upper - count_lower\n        if strength\
    \ > strongest {\n            strongest = strength\n            strongest_extension\
    \ = each\n        }\n    }\n    return class_name + \".\" + strongest_extension\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(Strongest_Extension(class_name: \"Watashi\", extensions:\
    \ [\"tEN\", \"niNE\", \"eIGHt8OKe\"]) == \"Watashi.eIGHt8OKe\")\nassert(Strongest_Extension(class_name:\
    \ \"Boku123\", extensions: [\"nani\", \"NazeDa\", \"YEs.WeCaNe\", \"32145tggg\"\
    ]) == \"Boku123.YEs.WeCaNe\")\nassert(Strongest_Extension(class_name: \"__YESIMHERE\"\
    , extensions: [\"t\", \"eMptY\", \"nothing\", \"zeR00\", \"NuLl__\", \"123NoooneB321\"\
    ]) == \"__YESIMHERE.NuLl__\")\nassert(Strongest_Extension(class_name: \"K\", extensions:\
    \ [\"Ta\", \"TAR\", \"t234An\", \"cosSo\"]) == \"K.TAR\")\nassert(Strongest_Extension(class_name:\
    \ \"__HAHA\", extensions: [\"Tab\", \"123\", \"781345\", \"-_-\"]) == \"__HAHA.123\"\
    )\nassert(Strongest_Extension(class_name: \"YameRore\", extensions: [\"HhAas\"\
    , \"okIWILL123\", \"WorkOut\", \"Fails\", \"-_-\"]) == \"YameRore.okIWILL123\"\
    )\nassert(Strongest_Extension(class_name: \"finNNalLLly\", extensions: [\"Die\"\
    , \"NowW\", \"Wow\", \"WoW\"]) == \"finNNalLLly.WoW\")\nassert(Strongest_Extension(class_name:\
    \ \"_\", extensions: [\"Bb\", \"91245\"]) == \"_.Bb\")\nassert(Strongest_Extension(class_name:\
    \ \"Sp\", extensions: [\"671235\", \"Bb\"]) == \"Sp.671235\")"
  status: Exception
  stderr: 'tmpl6qr20m1/tmpl6qr20m1.swift:53: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b6883187c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b6882e7eb6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b6882e7e988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b6882e7d7b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpl6qr20m1                        0x000055a67bcfb7cd <unavailable> + 6093

    5    libc.so.6                          0x00002b6883373460 __libc_start_main +
    245

    6    tmpl6qr20m1                        0x000055a67bcfb359 <unavailable> + 4953

    '
  stdout: ''
  timestamp: 1660009433
- exit_code: -4
  program: "\n/// You will be given the name of a class (a string) and an array of\
    \ extensions.\n/// The extensions are to be used to load additional classes to\
    \ the class. The\n/// strength of the extension is as follows: Let CAP be the\
    \ number of the uppercase\n/// letters in the extension's name, and let SM be\
    \ the number of lowercase letters \n/// in the extension's name, the strength\
    \ is given by the fraction CAP - SM. \n/// You should find the strongest extension\
    \ and return a string in this \n/// format: ClassName.StrongestExtensionName.\n\
    /// If there are two or more extensions with the same strength, you should\n///\
    \ choose the one that comes first in the array.\n/// For example, if you are given\
    \ \"Slices\" as the class and an array of the\n/// extensions: ['SErviNGSliCes',\
    \ 'Cheese', 'StuFfed'] then you should\n/// return 'Slices.SErviNGSliCes' since\
    \ 'SErviNGSliCes' is the strongest extension \n/// (its strength is -1).\n///\
    \ Example:\n/// >>> Strongest_Extension(class_name: \"my_class\", extensions:\
    \ [\"AA\", \"Be\", \"CC\"])\n/// \"my_class.AA\"\nfunc Strongest_Extension(class_name:\
    \ String, extensions: [String]) -> String {\n    var strongest_extension: String\
    \ = \"\"\n    var strongest_extension_strength: Float = 0.0\n    for item in extensions\
    \ {\n        let upper_count = item.uppercased().filter({ \"ABCDEFGHIJKLMNOPQRSTUVWXYZ\"\
    .contains($0) }).count\n        let lower_count = item.lowercased().filter({ \"\
    abcdefghijklmnopqrstuvwxyz\".contains($0) }).count\n        let current_strength\
    \ = Float(upper_count) - Float(lower_count)\n        if current_strength > strongest_extension_strength\
    \ {\n            strongest_extension = item\n            strongest_extension_strength\
    \ = current_strength\n        }\n    }\n    return class_name + \".\" + strongest_extension\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(Strongest_Extension(class_name: \"Watashi\", extensions:\
    \ [\"tEN\", \"niNE\", \"eIGHt8OKe\"]) == \"Watashi.eIGHt8OKe\")\nassert(Strongest_Extension(class_name:\
    \ \"Boku123\", extensions: [\"nani\", \"NazeDa\", \"YEs.WeCaNe\", \"32145tggg\"\
    ]) == \"Boku123.YEs.WeCaNe\")\nassert(Strongest_Extension(class_name: \"__YESIMHERE\"\
    , extensions: [\"t\", \"eMptY\", \"nothing\", \"zeR00\", \"NuLl__\", \"123NoooneB321\"\
    ]) == \"__YESIMHERE.NuLl__\")\nassert(Strongest_Extension(class_name: \"K\", extensions:\
    \ [\"Ta\", \"TAR\", \"t234An\", \"cosSo\"]) == \"K.TAR\")\nassert(Strongest_Extension(class_name:\
    \ \"__HAHA\", extensions: [\"Tab\", \"123\", \"781345\", \"-_-\"]) == \"__HAHA.123\"\
    )\nassert(Strongest_Extension(class_name: \"YameRore\", extensions: [\"HhAas\"\
    , \"okIWILL123\", \"WorkOut\", \"Fails\", \"-_-\"]) == \"YameRore.okIWILL123\"\
    )\nassert(Strongest_Extension(class_name: \"finNNalLLly\", extensions: [\"Die\"\
    , \"NowW\", \"Wow\", \"WoW\"]) == \"finNNalLLly.WoW\")\nassert(Strongest_Extension(class_name:\
    \ \"_\", extensions: [\"Bb\", \"91245\"]) == \"_.Bb\")\nassert(Strongest_Extension(class_name:\
    \ \"Sp\", extensions: [\"671235\", \"Bb\"]) == \"Sp.671235\")"
  status: Exception
  stderr: 'tmp457ul1ja/tmp457ul1ja.swift:46: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002aeedc5f9c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002aeedc2f0b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002aeedc2f0988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002aeedc2ef7b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmp457ul1ja                        0x000055941a0ed93d <unavailable> + 6461

    5    libc.so.6                          0x00002aeedc7e5460 __libc_start_main +
    245

    6    tmp457ul1ja                        0x000055941a0ed4c9 <unavailable> + 5321

    '
  stdout: ''
  timestamp: 1660009433
- exit_code: 0
  program: "\n/// You will be given the name of a class (a string) and an array of\
    \ extensions.\n/// The extensions are to be used to load additional classes to\
    \ the class. The\n/// strength of the extension is as follows: Let CAP be the\
    \ number of the uppercase\n/// letters in the extension's name, and let SM be\
    \ the number of lowercase letters \n/// in the extension's name, the strength\
    \ is given by the fraction CAP - SM. \n/// You should find the strongest extension\
    \ and return a string in this \n/// format: ClassName.StrongestExtensionName.\n\
    /// If there are two or more extensions with the same strength, you should\n///\
    \ choose the one that comes first in the array.\n/// For example, if you are given\
    \ \"Slices\" as the class and an array of the\n/// extensions: ['SErviNGSliCes',\
    \ 'Cheese', 'StuFfed'] then you should\n/// return 'Slices.SErviNGSliCes' since\
    \ 'SErviNGSliCes' is the strongest extension \n/// (its strength is -1).\n///\
    \ Example:\n/// >>> Strongest_Extension(class_name: \"my_class\", extensions:\
    \ [\"AA\", \"Be\", \"CC\"])\n/// \"my_class.AA\"\nfunc Strongest_Extension(class_name:\
    \ String, extensions: [String]) -> String {\n    var strongest_extension: String\
    \ = \"\"\n    var strongest_extension_strength: Float = -5\n    for item in extensions\
    \ {\n        let lowercase_letters = item.filter { $0.isLowercase }\n        let\
    \ uppercase_letters = item.filter { $0.isUppercase }\n        let strength = Float(uppercase_letters.count)\
    \ - Float(lowercase_letters.count)\n        if strength > strongest_extension_strength\
    \ {\n            strongest_extension = item\n            strongest_extension_strength\
    \ = strength\n        }\n    }\n    return \"\\(class_name).\\(strongest_extension)\"\
    \n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(Strongest_Extension(class_name: \"Watashi\", extensions:\
    \ [\"tEN\", \"niNE\", \"eIGHt8OKe\"]) == \"Watashi.eIGHt8OKe\")\nassert(Strongest_Extension(class_name:\
    \ \"Boku123\", extensions: [\"nani\", \"NazeDa\", \"YEs.WeCaNe\", \"32145tggg\"\
    ]) == \"Boku123.YEs.WeCaNe\")\nassert(Strongest_Extension(class_name: \"__YESIMHERE\"\
    , extensions: [\"t\", \"eMptY\", \"nothing\", \"zeR00\", \"NuLl__\", \"123NoooneB321\"\
    ]) == \"__YESIMHERE.NuLl__\")\nassert(Strongest_Extension(class_name: \"K\", extensions:\
    \ [\"Ta\", \"TAR\", \"t234An\", \"cosSo\"]) == \"K.TAR\")\nassert(Strongest_Extension(class_name:\
    \ \"__HAHA\", extensions: [\"Tab\", \"123\", \"781345\", \"-_-\"]) == \"__HAHA.123\"\
    )\nassert(Strongest_Extension(class_name: \"YameRore\", extensions: [\"HhAas\"\
    , \"okIWILL123\", \"WorkOut\", \"Fails\", \"-_-\"]) == \"YameRore.okIWILL123\"\
    )\nassert(Strongest_Extension(class_name: \"finNNalLLly\", extensions: [\"Die\"\
    , \"NowW\", \"Wow\", \"WoW\"]) == \"finNNalLLly.WoW\")\nassert(Strongest_Extension(class_name:\
    \ \"_\", extensions: [\"Bb\", \"91245\"]) == \"_.Bb\")\nassert(Strongest_Extension(class_name:\
    \ \"Sp\", extensions: [\"671235\", \"Bb\"]) == \"Sp.671235\")"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660009434
- exit_code: -4
  program: "\n/// You will be given the name of a class (a string) and an array of\
    \ extensions.\n/// The extensions are to be used to load additional classes to\
    \ the class. The\n/// strength of the extension is as follows: Let CAP be the\
    \ number of the uppercase\n/// letters in the extension's name, and let SM be\
    \ the number of lowercase letters \n/// in the extension's name, the strength\
    \ is given by the fraction CAP - SM. \n/// You should find the strongest extension\
    \ and return a string in this \n/// format: ClassName.StrongestExtensionName.\n\
    /// If there are two or more extensions with the same strength, you should\n///\
    \ choose the one that comes first in the array.\n/// For example, if you are given\
    \ \"Slices\" as the class and an array of the\n/// extensions: ['SErviNGSliCes',\
    \ 'Cheese', 'StuFfed'] then you should\n/// return 'Slices.SErviNGSliCes' since\
    \ 'SErviNGSliCes' is the strongest extension \n/// (its strength is -1).\n///\
    \ Example:\n/// >>> Strongest_Extension(class_name: \"my_class\", extensions:\
    \ [\"AA\", \"Be\", \"CC\"])\n/// \"my_class.AA\"\nfunc Strongest_Extension(class_name:\
    \ String, extensions: [String]) -> String {\n    var strongest: String = \"\"\n\
    \    var strongest_strength: Double = 0\n    for (i, ext) in extensions.enumerated()\
    \ {\n        var CAP: Int = 0\n        var SM: Int = 0\n        for c in ext {\n\
    \            if c.isUppercase {\n                CAP += 1\n            } else\
    \ {\n                SM += 1\n            }\n        }\n        let strength:\
    \ Double = Double(CAP) - Double(SM)\n        if strength > strongest_strength\
    \ {\n            strongest = ext\n            strongest_strength = strength\n\
    \        } else if strength == strongest_strength {\n            if extensions.firstIndex(of:\
    \ ext) ?? 0 < extensions.firstIndex(of: strongest) ?? 0 {\n                strongest\
    \ = ext\n                strongest_strength = strength\n            }\n      \
    \  }\n    }\n    return \"\\(class_name).\\(strongest)\"\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(Strongest_Extension(class_name: \"Watashi\", extensions:\
    \ [\"tEN\", \"niNE\", \"eIGHt8OKe\"]) == \"Watashi.eIGHt8OKe\")\nassert(Strongest_Extension(class_name:\
    \ \"Boku123\", extensions: [\"nani\", \"NazeDa\", \"YEs.WeCaNe\", \"32145tggg\"\
    ]) == \"Boku123.YEs.WeCaNe\")\nassert(Strongest_Extension(class_name: \"__YESIMHERE\"\
    , extensions: [\"t\", \"eMptY\", \"nothing\", \"zeR00\", \"NuLl__\", \"123NoooneB321\"\
    ]) == \"__YESIMHERE.NuLl__\")\nassert(Strongest_Extension(class_name: \"K\", extensions:\
    \ [\"Ta\", \"TAR\", \"t234An\", \"cosSo\"]) == \"K.TAR\")\nassert(Strongest_Extension(class_name:\
    \ \"__HAHA\", extensions: [\"Tab\", \"123\", \"781345\", \"-_-\"]) == \"__HAHA.123\"\
    )\nassert(Strongest_Extension(class_name: \"YameRore\", extensions: [\"HhAas\"\
    , \"okIWILL123\", \"WorkOut\", \"Fails\", \"-_-\"]) == \"YameRore.okIWILL123\"\
    )\nassert(Strongest_Extension(class_name: \"finNNalLLly\", extensions: [\"Die\"\
    , \"NowW\", \"Wow\", \"WoW\"]) == \"finNNalLLly.WoW\")\nassert(Strongest_Extension(class_name:\
    \ \"_\", extensions: [\"Bb\", \"91245\"]) == \"_.Bb\")\nassert(Strongest_Extension(class_name:\
    \ \"Sp\", extensions: [\"671235\", \"Bb\"]) == \"Sp.671235\")"
  status: Exception
  stderr: 'tmpb2ud1ae9/tmpb2ud1ae9.swift:58: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b1437634c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b143732bb6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b143732b988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b143732a7b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpb2ud1ae9                        0x000055bbc6600bdd <unavailable> + 7133

    5    libc.so.6                          0x00002b1437820460 __libc_start_main +
    245

    6    tmpb2ud1ae9                        0x000055bbc6600769 <unavailable> + 5993

    '
  stdout: ''
  timestamp: 1660009434
- exit_code: 1
  program: "\n/// You will be given the name of a class (a string) and an array of\
    \ extensions.\n/// The extensions are to be used to load additional classes to\
    \ the class. The\n/// strength of the extension is as follows: Let CAP be the\
    \ number of the uppercase\n/// letters in the extension's name, and let SM be\
    \ the number of lowercase letters \n/// in the extension's name, the strength\
    \ is given by the fraction CAP - SM. \n/// You should find the strongest extension\
    \ and return a string in this \n/// format: ClassName.StrongestExtensionName.\n\
    /// If there are two or more extensions with the same strength, you should\n///\
    \ choose the one that comes first in the array.\n/// For example, if you are given\
    \ \"Slices\" as the class and an array of the\n/// extensions: ['SErviNGSliCes',\
    \ 'Cheese', 'StuFfed'] then you should\n/// return 'Slices.SErviNGSliCes' since\
    \ 'SErviNGSliCes' is the strongest extension \n/// (its strength is -1).\n///\
    \ Example:\n/// >>> Strongest_Extension(class_name: \"my_class\", extensions:\
    \ [\"AA\", \"Be\", \"CC\"])\n/// \"my_class.AA\"\nfunc Strongest_Extension(class_name:\
    \ String, extensions: [String]) -> String {\n    var strongestExtension = extensions[0]\n\
    \    var strongestStrength = 0\n    for i in 0..<extensions.count {\n        let\
    \ strength = strengthOfExtension(string: extensions[i])\n        if strength >\
    \ strongestStrength {\n            strongestStrength = strength\n            strongestExtension\
    \ = extensions[i]\n        }\n    }\n    return \"\\(class_name).\\(strongestExtension)\"\
    \n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(Strongest_Extension(class_name: \"Watashi\", extensions:\
    \ [\"tEN\", \"niNE\", \"eIGHt8OKe\"]) == \"Watashi.eIGHt8OKe\")\nassert(Strongest_Extension(class_name:\
    \ \"Boku123\", extensions: [\"nani\", \"NazeDa\", \"YEs.WeCaNe\", \"32145tggg\"\
    ]) == \"Boku123.YEs.WeCaNe\")\nassert(Strongest_Extension(class_name: \"__YESIMHERE\"\
    , extensions: [\"t\", \"eMptY\", \"nothing\", \"zeR00\", \"NuLl__\", \"123NoooneB321\"\
    ]) == \"__YESIMHERE.NuLl__\")\nassert(Strongest_Extension(class_name: \"K\", extensions:\
    \ [\"Ta\", \"TAR\", \"t234An\", \"cosSo\"]) == \"K.TAR\")\nassert(Strongest_Extension(class_name:\
    \ \"__HAHA\", extensions: [\"Tab\", \"123\", \"781345\", \"-_-\"]) == \"__HAHA.123\"\
    )\nassert(Strongest_Extension(class_name: \"YameRore\", extensions: [\"HhAas\"\
    , \"okIWILL123\", \"WorkOut\", \"Fails\", \"-_-\"]) == \"YameRore.okIWILL123\"\
    )\nassert(Strongest_Extension(class_name: \"finNNalLLly\", extensions: [\"Die\"\
    , \"NowW\", \"Wow\", \"WoW\"]) == \"finNNalLLly.WoW\")\nassert(Strongest_Extension(class_name:\
    \ \"_\", extensions: [\"Bb\", \"91245\"]) == \"_.Bb\")\nassert(Strongest_Extension(class_name:\
    \ \"Sp\", extensions: [\"671235\", \"Bb\"]) == \"Sp.671235\")"
  status: SyntaxError
  stderr: "/tmp/tmpwngfkog8.swift:22:24: error: cannot find 'strengthOfExtension'\
    \ in scope\n        let strength = strengthOfExtension(string: extensions[i])\n\
    \                       ^~~~~~~~~~~~~~~~~~~\n"
  stdout: ''
  timestamp: 1660009433
- exit_code: 0
  program: "\n/// You will be given the name of a class (a string) and an array of\
    \ extensions.\n/// The extensions are to be used to load additional classes to\
    \ the class. The\n/// strength of the extension is as follows: Let CAP be the\
    \ number of the uppercase\n/// letters in the extension's name, and let SM be\
    \ the number of lowercase letters \n/// in the extension's name, the strength\
    \ is given by the fraction CAP - SM. \n/// You should find the strongest extension\
    \ and return a string in this \n/// format: ClassName.StrongestExtensionName.\n\
    /// If there are two or more extensions with the same strength, you should\n///\
    \ choose the one that comes first in the array.\n/// For example, if you are given\
    \ \"Slices\" as the class and an array of the\n/// extensions: ['SErviNGSliCes',\
    \ 'Cheese', 'StuFfed'] then you should\n/// return 'Slices.SErviNGSliCes' since\
    \ 'SErviNGSliCes' is the strongest extension \n/// (its strength is -1).\n///\
    \ Example:\n/// >>> Strongest_Extension(class_name: \"my_class\", extensions:\
    \ [\"AA\", \"Be\", \"CC\"])\n/// \"my_class.AA\"\nfunc Strongest_Extension(class_name:\
    \ String, extensions: [String]) -> String {\n    var strongest_extension = \"\"\
    \n    var strongest_extension_strength = Int.min\n    for extension_name in extensions\
    \ {\n        let strength = extension_name.filter { $0.isUppercase }.count -\n\
    \            extension_name.filter { $0.isLowercase }.count\n        if strength\
    \ > strongest_extension_strength {\n            strongest_extension_strength =\
    \ strength\n            strongest_extension = extension_name\n        }\n    }\n\
    \    return \"\\(class_name).\\(strongest_extension)\"\n}\n\n\nfunc ==(left: [(Int,\
    \ Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n\
    \        return false\n    }\n    for (l, r) in zip(left, right) {\n        if\
    \ l != r {\n            return false\n        }\n    }\n    return true\n}\n \
    \           \nassert(Strongest_Extension(class_name: \"Watashi\", extensions:\
    \ [\"tEN\", \"niNE\", \"eIGHt8OKe\"]) == \"Watashi.eIGHt8OKe\")\nassert(Strongest_Extension(class_name:\
    \ \"Boku123\", extensions: [\"nani\", \"NazeDa\", \"YEs.WeCaNe\", \"32145tggg\"\
    ]) == \"Boku123.YEs.WeCaNe\")\nassert(Strongest_Extension(class_name: \"__YESIMHERE\"\
    , extensions: [\"t\", \"eMptY\", \"nothing\", \"zeR00\", \"NuLl__\", \"123NoooneB321\"\
    ]) == \"__YESIMHERE.NuLl__\")\nassert(Strongest_Extension(class_name: \"K\", extensions:\
    \ [\"Ta\", \"TAR\", \"t234An\", \"cosSo\"]) == \"K.TAR\")\nassert(Strongest_Extension(class_name:\
    \ \"__HAHA\", extensions: [\"Tab\", \"123\", \"781345\", \"-_-\"]) == \"__HAHA.123\"\
    )\nassert(Strongest_Extension(class_name: \"YameRore\", extensions: [\"HhAas\"\
    , \"okIWILL123\", \"WorkOut\", \"Fails\", \"-_-\"]) == \"YameRore.okIWILL123\"\
    )\nassert(Strongest_Extension(class_name: \"finNNalLLly\", extensions: [\"Die\"\
    , \"NowW\", \"Wow\", \"WoW\"]) == \"finNNalLLly.WoW\")\nassert(Strongest_Extension(class_name:\
    \ \"_\", extensions: [\"Bb\", \"91245\"]) == \"_.Bb\")\nassert(Strongest_Extension(class_name:\
    \ \"Sp\", extensions: [\"671235\", \"Bb\"]) == \"Sp.671235\")"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660009434
- exit_code: -4
  program: "\n/// You will be given the name of a class (a string) and an array of\
    \ extensions.\n/// The extensions are to be used to load additional classes to\
    \ the class. The\n/// strength of the extension is as follows: Let CAP be the\
    \ number of the uppercase\n/// letters in the extension's name, and let SM be\
    \ the number of lowercase letters \n/// in the extension's name, the strength\
    \ is given by the fraction CAP - SM. \n/// You should find the strongest extension\
    \ and return a string in this \n/// format: ClassName.StrongestExtensionName.\n\
    /// If there are two or more extensions with the same strength, you should\n///\
    \ choose the one that comes first in the array.\n/// For example, if you are given\
    \ \"Slices\" as the class and an array of the\n/// extensions: ['SErviNGSliCes',\
    \ 'Cheese', 'StuFfed'] then you should\n/// return 'Slices.SErviNGSliCes' since\
    \ 'SErviNGSliCes' is the strongest extension \n/// (its strength is -1).\n///\
    \ Example:\n/// >>> Strongest_Extension(class_name: \"my_class\", extensions:\
    \ [\"AA\", \"Be\", \"CC\"])\n/// \"my_class.AA\"\nfunc Strongest_Extension(class_name:\
    \ String, extensions: [String]) -> String {\n    // Your code here\n    return\
    \ \"\"\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n  \
    \  if left.count != right.count {\n        return false\n    }\n    for (l, r)\
    \ in zip(left, right) {\n        if l != r {\n            return false\n     \
    \   }\n    }\n    return true\n}\n            \nassert(Strongest_Extension(class_name:\
    \ \"Watashi\", extensions: [\"tEN\", \"niNE\", \"eIGHt8OKe\"]) == \"Watashi.eIGHt8OKe\"\
    )\nassert(Strongest_Extension(class_name: \"Boku123\", extensions: [\"nani\",\
    \ \"NazeDa\", \"YEs.WeCaNe\", \"32145tggg\"]) == \"Boku123.YEs.WeCaNe\")\nassert(Strongest_Extension(class_name:\
    \ \"__YESIMHERE\", extensions: [\"t\", \"eMptY\", \"nothing\", \"zeR00\", \"NuLl__\"\
    , \"123NoooneB321\"]) == \"__YESIMHERE.NuLl__\")\nassert(Strongest_Extension(class_name:\
    \ \"K\", extensions: [\"Ta\", \"TAR\", \"t234An\", \"cosSo\"]) == \"K.TAR\")\n\
    assert(Strongest_Extension(class_name: \"__HAHA\", extensions: [\"Tab\", \"123\"\
    , \"781345\", \"-_-\"]) == \"__HAHA.123\")\nassert(Strongest_Extension(class_name:\
    \ \"YameRore\", extensions: [\"HhAas\", \"okIWILL123\", \"WorkOut\", \"Fails\"\
    , \"-_-\"]) == \"YameRore.okIWILL123\")\nassert(Strongest_Extension(class_name:\
    \ \"finNNalLLly\", extensions: [\"Die\", \"NowW\", \"Wow\", \"WoW\"]) == \"finNNalLLly.WoW\"\
    )\nassert(Strongest_Extension(class_name: \"_\", extensions: [\"Bb\", \"91245\"\
    ]) == \"_.Bb\")\nassert(Strongest_Extension(class_name: \"Sp\", extensions: [\"\
    671235\", \"Bb\"]) == \"Sp.671235\")"
  status: Exception
  stderr: 'tmp2rvht6cr/tmp2rvht6cr.swift:36: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b8ffe34fc80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b8ffe046b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b8ffe046988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b8ffe0457b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmp2rvht6cr                        0x0000556f258ff4fd <unavailable> + 5373

    5    libc.so.6                          0x00002b8ffe53b460 __libc_start_main +
    245

    6    tmp2rvht6cr                        0x0000556f258ff089 <unavailable> + 4233

    '
  stdout: ''
  timestamp: 1660009434
- exit_code: 1
  program: "\n/// You will be given the name of a class (a string) and an array of\
    \ extensions.\n/// The extensions are to be used to load additional classes to\
    \ the class. The\n/// strength of the extension is as follows: Let CAP be the\
    \ number of the uppercase\n/// letters in the extension's name, and let SM be\
    \ the number of lowercase letters \n/// in the extension's name, the strength\
    \ is given by the fraction CAP - SM. \n/// You should find the strongest extension\
    \ and return a string in this \n/// format: ClassName.StrongestExtensionName.\n\
    /// If there are two or more extensions with the same strength, you should\n///\
    \ choose the one that comes first in the array.\n/// For example, if you are given\
    \ \"Slices\" as the class and an array of the\n/// extensions: ['SErviNGSliCes',\
    \ 'Cheese', 'StuFfed'] then you should\n/// return 'Slices.SErviNGSliCes' since\
    \ 'SErviNGSliCes' is the strongest extension \n/// (its strength is -1).\n///\
    \ Example:\n/// >>> Strongest_Extension(class_name: \"my_class\", extensions:\
    \ [\"AA\", \"Be\", \"CC\"])\n/// \"my_class.AA\"\nfunc Strongest_Extension(class_name:\
    \ String, extensions: [String]) -> String {\n  var strongestExtension = \"\"\n\
    \  var strongestExtensionStrength = 0.0\n  for extension in extensions {\n   \
    \ let cap = Double(extension.uppercased().filter { $0.isUppercase }.count)\n \
    \   let sm = Double(extension.lowercased().filter { $0.isLowercase }.count)\n\
    \    let strength = cap - sm\n    if strength > strongestExtensionStrength {\n\
    \      strongestExtensionStrength = strength\n      strongestExtension = extension\n\
    \    }\n  }\n  return \"\\(class_name).\\(strongestExtension)\"\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(Strongest_Extension(class_name: \"Watashi\", extensions:\
    \ [\"tEN\", \"niNE\", \"eIGHt8OKe\"]) == \"Watashi.eIGHt8OKe\")\nassert(Strongest_Extension(class_name:\
    \ \"Boku123\", extensions: [\"nani\", \"NazeDa\", \"YEs.WeCaNe\", \"32145tggg\"\
    ]) == \"Boku123.YEs.WeCaNe\")\nassert(Strongest_Extension(class_name: \"__YESIMHERE\"\
    , extensions: [\"t\", \"eMptY\", \"nothing\", \"zeR00\", \"NuLl__\", \"123NoooneB321\"\
    ]) == \"__YESIMHERE.NuLl__\")\nassert(Strongest_Extension(class_name: \"K\", extensions:\
    \ [\"Ta\", \"TAR\", \"t234An\", \"cosSo\"]) == \"K.TAR\")\nassert(Strongest_Extension(class_name:\
    \ \"__HAHA\", extensions: [\"Tab\", \"123\", \"781345\", \"-_-\"]) == \"__HAHA.123\"\
    )\nassert(Strongest_Extension(class_name: \"YameRore\", extensions: [\"HhAas\"\
    , \"okIWILL123\", \"WorkOut\", \"Fails\", \"-_-\"]) == \"YameRore.okIWILL123\"\
    )\nassert(Strongest_Extension(class_name: \"finNNalLLly\", extensions: [\"Die\"\
    , \"NowW\", \"Wow\", \"WoW\"]) == \"finNNalLLly.WoW\")\nassert(Strongest_Extension(class_name:\
    \ \"_\", extensions: [\"Bb\", \"91245\"]) == \"_.Bb\")\nassert(Strongest_Extension(class_name:\
    \ \"Sp\", extensions: [\"671235\", \"Bb\"]) == \"Sp.671235\")"
  status: SyntaxError
  stderr: "/tmp/tmp3p2kw6t8.swift:21:7: error: expected pattern\n  for extension in\
    \ extensions {\n      ^\n/tmp/tmp3p2kw6t8.swift:21:7: error: expected Sequence\
    \ expression for for-each loop\n  for extension in extensions {\n      ^\n/tmp/tmp3p2kw6t8.swift:21:7:\
    \ error: expected '{' to start the body of for-each loop\n  for extension in extensions\
    \ {\n      ^\n/tmp/tmp3p2kw6t8.swift:22:22: error: expected expression in list\
    \ of expressions\n    let cap = Double(extension.uppercased().filter { $0.isUppercase\
    \ }.count)\n                     ^\n/tmp/tmp3p2kw6t8.swift:22:22: error: consecutive\
    \ statements on a line must be separated by ';'\n    let cap = Double(extension.uppercased().filter\
    \ { $0.isUppercase }.count)\n                     ^\n                     ;\n\
    /tmp/tmp3p2kw6t8.swift:22:31: error: expected type name in extension declaration\n\
    \    let cap = Double(extension.uppercased().filter { $0.isUppercase }.count)\n\
    \                              ^\n/tmp/tmp3p2kw6t8.swift:22:31: error: expected\
    \ '{' in extension\n    let cap = Double(extension.uppercased().filter { $0.isUppercase\
    \ }.count)\n                              ^\n/tmp/tmp3p2kw6t8.swift:22:22: error:\
    \ declaration is only valid at file scope\n    let cap = Double(extension.uppercased().filter\
    \ { $0.isUppercase }.count)\n                     ^\n/tmp/tmp3p2kw6t8.swift:23:21:\
    \ error: expected expression in list of expressions\n    let sm = Double(extension.lowercased().filter\
    \ { $0.isLowercase }.count)\n                    ^\n/tmp/tmp3p2kw6t8.swift:23:21:\
    \ error: consecutive statements on a line must be separated by ';'\n    let sm\
    \ = Double(extension.lowercased().filter { $0.isLowercase }.count)\n         \
    \           ^\n                    ;\n/tmp/tmp3p2kw6t8.swift:23:30: error: expected\
    \ type name in extension declaration\n    let sm = Double(extension.lowercased().filter\
    \ { $0.isLowercase }.count)\n                             ^\n/tmp/tmp3p2kw6t8.swift:23:30:\
    \ error: expected '{' in extension\n    let sm = Double(extension.lowercased().filter\
    \ { $0.isLowercase }.count)\n                             ^\n/tmp/tmp3p2kw6t8.swi"
  stdout: ''
  timestamp: 1660009433
- exit_code: -4
  program: "\n/// You will be given the name of a class (a string) and an array of\
    \ extensions.\n/// The extensions are to be used to load additional classes to\
    \ the class. The\n/// strength of the extension is as follows: Let CAP be the\
    \ number of the uppercase\n/// letters in the extension's name, and let SM be\
    \ the number of lowercase letters \n/// in the extension's name, the strength\
    \ is given by the fraction CAP - SM. \n/// You should find the strongest extension\
    \ and return a string in this \n/// format: ClassName.StrongestExtensionName.\n\
    /// If there are two or more extensions with the same strength, you should\n///\
    \ choose the one that comes first in the array.\n/// For example, if you are given\
    \ \"Slices\" as the class and an array of the\n/// extensions: ['SErviNGSliCes',\
    \ 'Cheese', 'StuFfed'] then you should\n/// return 'Slices.SErviNGSliCes' since\
    \ 'SErviNGSliCes' is the strongest extension \n/// (its strength is -1).\n///\
    \ Example:\n/// >>> Strongest_Extension(class_name: \"my_class\", extensions:\
    \ [\"AA\", \"Be\", \"CC\"])\n/// \"my_class.AA\"\nfunc Strongest_Extension(class_name:\
    \ String, extensions: [String]) -> String {\n  var strength = 0\n  var strongest_extension\
    \ = \"\"\n  for extension_name in extensions {\n    let uppercase_count = extension_name.uppercased().filter\
    \ { $0.isUppercase }.count\n    let lowercase_count = extension_name.lowercased().filter\
    \ { $0.isLowercase }.count\n    let new_strength = uppercase_count - lowercase_count\n\
    \    if new_strength > strength {\n      strength = new_strength\n      strongest_extension\
    \ = extension_name\n    }\n  }\n  return \"\\(class_name).\\(strongest_extension)\"\
    \n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(Strongest_Extension(class_name: \"Watashi\", extensions:\
    \ [\"tEN\", \"niNE\", \"eIGHt8OKe\"]) == \"Watashi.eIGHt8OKe\")\nassert(Strongest_Extension(class_name:\
    \ \"Boku123\", extensions: [\"nani\", \"NazeDa\", \"YEs.WeCaNe\", \"32145tggg\"\
    ]) == \"Boku123.YEs.WeCaNe\")\nassert(Strongest_Extension(class_name: \"__YESIMHERE\"\
    , extensions: [\"t\", \"eMptY\", \"nothing\", \"zeR00\", \"NuLl__\", \"123NoooneB321\"\
    ]) == \"__YESIMHERE.NuLl__\")\nassert(Strongest_Extension(class_name: \"K\", extensions:\
    \ [\"Ta\", \"TAR\", \"t234An\", \"cosSo\"]) == \"K.TAR\")\nassert(Strongest_Extension(class_name:\
    \ \"__HAHA\", extensions: [\"Tab\", \"123\", \"781345\", \"-_-\"]) == \"__HAHA.123\"\
    )\nassert(Strongest_Extension(class_name: \"YameRore\", extensions: [\"HhAas\"\
    , \"okIWILL123\", \"WorkOut\", \"Fails\", \"-_-\"]) == \"YameRore.okIWILL123\"\
    )\nassert(Strongest_Extension(class_name: \"finNNalLLly\", extensions: [\"Die\"\
    , \"NowW\", \"Wow\", \"WoW\"]) == \"finNNalLLly.WoW\")\nassert(Strongest_Extension(class_name:\
    \ \"_\", extensions: [\"Bb\", \"91245\"]) == \"_.Bb\")\nassert(Strongest_Extension(class_name:\
    \ \"Sp\", extensions: [\"671235\", \"Bb\"]) == \"Sp.671235\")"
  status: Exception
  stderr: 'tmp8oqiszf4/tmp8oqiszf4.swift:46: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b83a2bd0c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b83a28c7b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b83a28c7988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b83a28c67b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmp8oqiszf4                        0x00005621ec453b7d <unavailable> + 7037

    5    libc.so.6                          0x00002b83a2dbc460 __libc_start_main +
    245

    6    tmp8oqiszf4                        0x00005621ec453709 <unavailable> + 5897

    '
  stdout: ''
  timestamp: 1660009434
- exit_code: -4
  program: "\n/// You will be given the name of a class (a string) and an array of\
    \ extensions.\n/// The extensions are to be used to load additional classes to\
    \ the class. The\n/// strength of the extension is as follows: Let CAP be the\
    \ number of the uppercase\n/// letters in the extension's name, and let SM be\
    \ the number of lowercase letters \n/// in the extension's name, the strength\
    \ is given by the fraction CAP - SM. \n/// You should find the strongest extension\
    \ and return a string in this \n/// format: ClassName.StrongestExtensionName.\n\
    /// If there are two or more extensions with the same strength, you should\n///\
    \ choose the one that comes first in the array.\n/// For example, if you are given\
    \ \"Slices\" as the class and an array of the\n/// extensions: ['SErviNGSliCes',\
    \ 'Cheese', 'StuFfed'] then you should\n/// return 'Slices.SErviNGSliCes' since\
    \ 'SErviNGSliCes' is the strongest extension \n/// (its strength is -1).\n///\
    \ Example:\n/// >>> Strongest_Extension(class_name: \"my_class\", extensions:\
    \ [\"AA\", \"Be\", \"CC\"])\n/// \"my_class.AA\"\nfunc Strongest_Extension(class_name:\
    \ String, extensions: [String]) -> String {\n    let strongest = extensions.map\
    \ { (ext) -> (Int, Int, String) in\n        let count_upper = ext.filter({$0.isUppercase}).count\n\
    \        let count_lower = ext.filter({$0.isLowercase}).count\n        return\
    \ (count_upper, count_lower, ext)\n    }.sorted { (a, b) -> Bool in\n        let\
    \ a_strength = (a.0 - a.1)\n        let b_strength = (b.0 - b.1)\n        if a_strength\
    \ == b_strength {\n            return a.2 < b.2\n        }\n        return a_strength\
    \ > b_strength\n    }\n    return class_name + \".\" + strongest.first!.2\n}\n\
    \n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(Strongest_Extension(class_name: \"Watashi\", extensions:\
    \ [\"tEN\", \"niNE\", \"eIGHt8OKe\"]) == \"Watashi.eIGHt8OKe\")\nassert(Strongest_Extension(class_name:\
    \ \"Boku123\", extensions: [\"nani\", \"NazeDa\", \"YEs.WeCaNe\", \"32145tggg\"\
    ]) == \"Boku123.YEs.WeCaNe\")\nassert(Strongest_Extension(class_name: \"__YESIMHERE\"\
    , extensions: [\"t\", \"eMptY\", \"nothing\", \"zeR00\", \"NuLl__\", \"123NoooneB321\"\
    ]) == \"__YESIMHERE.NuLl__\")\nassert(Strongest_Extension(class_name: \"K\", extensions:\
    \ [\"Ta\", \"TAR\", \"t234An\", \"cosSo\"]) == \"K.TAR\")\nassert(Strongest_Extension(class_name:\
    \ \"__HAHA\", extensions: [\"Tab\", \"123\", \"781345\", \"-_-\"]) == \"__HAHA.123\"\
    )\nassert(Strongest_Extension(class_name: \"YameRore\", extensions: [\"HhAas\"\
    , \"okIWILL123\", \"WorkOut\", \"Fails\", \"-_-\"]) == \"YameRore.okIWILL123\"\
    )\nassert(Strongest_Extension(class_name: \"finNNalLLly\", extensions: [\"Die\"\
    , \"NowW\", \"Wow\", \"WoW\"]) == \"finNNalLLly.WoW\")\nassert(Strongest_Extension(class_name:\
    \ \"_\", extensions: [\"Bb\", \"91245\"]) == \"_.Bb\")\nassert(Strongest_Extension(class_name:\
    \ \"Sp\", extensions: [\"671235\", \"Bb\"]) == \"Sp.671235\")"
  status: Exception
  stderr: 'tmpcnhq2cgg/tmpcnhq2cgg.swift:51: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b47827f2c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b47824e9b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b47824e9988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b47824e87b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpcnhq2cgg                        0x000055f483a5420a <unavailable> + 8714

    5    libc.so.6                          0x00002b47829de460 __libc_start_main +
    245

    6    tmpcnhq2cgg                        0x000055f483a534d9 <unavailable> + 5337

    '
  stdout: ''
  timestamp: 1660009434
- exit_code: 1
  program: "\n/// You will be given the name of a class (a string) and an array of\
    \ extensions.\n/// The extensions are to be used to load additional classes to\
    \ the class. The\n/// strength of the extension is as follows: Let CAP be the\
    \ number of the uppercase\n/// letters in the extension's name, and let SM be\
    \ the number of lowercase letters \n/// in the extension's name, the strength\
    \ is given by the fraction CAP - SM. \n/// You should find the strongest extension\
    \ and return a string in this \n/// format: ClassName.StrongestExtensionName.\n\
    /// If there are two or more extensions with the same strength, you should\n///\
    \ choose the one that comes first in the array.\n/// For example, if you are given\
    \ \"Slices\" as the class and an array of the\n/// extensions: ['SErviNGSliCes',\
    \ 'Cheese', 'StuFfed'] then you should\n/// return 'Slices.SErviNGSliCes' since\
    \ 'SErviNGSliCes' is the strongest extension \n/// (its strength is -1).\n///\
    \ Example:\n/// >>> Strongest_Extension(class_name: \"my_class\", extensions:\
    \ [\"AA\", \"Be\", \"CC\"])\n/// \"my_class.AA\"\nfunc Strongest_Extension(class_name:\
    \ String, extensions: [String]) -> String {\n    var highest: Int = 0\n    var\
    \ highestIndex: Int = 0\n    var i: Int = 0\n    for ext in extensions {\n   \
    \     var strength: Int = 0\n        for ch in ext {\n            if(CharacterSet.uppercaseLetters.contains(UnicodeScalar(String(ch))!))\
    \ {\n                strength += 1\n            } else {\n                strength\
    \ -= 1\n            }\n        }\n        if(strength > highest) {\n         \
    \   highest = strength\n            highestIndex = i\n        }\n        i +=\
    \ 1\n    }\n    return \"\\(class_name).\\(extensions[highestIndex])\"\n}\n\n\n\
    func ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(Strongest_Extension(class_name: \"Watashi\", extensions:\
    \ [\"tEN\", \"niNE\", \"eIGHt8OKe\"]) == \"Watashi.eIGHt8OKe\")\nassert(Strongest_Extension(class_name:\
    \ \"Boku123\", extensions: [\"nani\", \"NazeDa\", \"YEs.WeCaNe\", \"32145tggg\"\
    ]) == \"Boku123.YEs.WeCaNe\")\nassert(Strongest_Extension(class_name: \"__YESIMHERE\"\
    , extensions: [\"t\", \"eMptY\", \"nothing\", \"zeR00\", \"NuLl__\", \"123NoooneB321\"\
    ]) == \"__YESIMHERE.NuLl__\")\nassert(Strongest_Extension(class_name: \"K\", extensions:\
    \ [\"Ta\", \"TAR\", \"t234An\", \"cosSo\"]) == \"K.TAR\")\nassert(Strongest_Extension(class_name:\
    \ \"__HAHA\", extensions: [\"Tab\", \"123\", \"781345\", \"-_-\"]) == \"__HAHA.123\"\
    )\nassert(Strongest_Extension(class_name: \"YameRore\", extensions: [\"HhAas\"\
    , \"okIWILL123\", \"WorkOut\", \"Fails\", \"-_-\"]) == \"YameRore.okIWILL123\"\
    )\nassert(Strongest_Extension(class_name: \"finNNalLLly\", extensions: [\"Die\"\
    , \"NowW\", \"Wow\", \"WoW\"]) == \"finNNalLLly.WoW\")\nassert(Strongest_Extension(class_name:\
    \ \"_\", extensions: [\"Bb\", \"91245\"]) == \"_.Bb\")\nassert(Strongest_Extension(class_name:\
    \ \"Sp\", extensions: [\"671235\", \"Bb\"]) == \"Sp.671235\")"
  status: SyntaxError
  stderr: "/tmp/tmpozj40fz0.swift:25:16: error: cannot find 'CharacterSet' in scope\n\
    \            if(CharacterSet.uppercaseLetters.contains(UnicodeScalar(String(ch))!))\
    \ {\n               ^~~~~~~~~~~~\n"
  stdout: ''
  timestamp: 1660009433
- exit_code: -4
  program: "\n/// You will be given the name of a class (a string) and an array of\
    \ extensions.\n/// The extensions are to be used to load additional classes to\
    \ the class. The\n/// strength of the extension is as follows: Let CAP be the\
    \ number of the uppercase\n/// letters in the extension's name, and let SM be\
    \ the number of lowercase letters \n/// in the extension's name, the strength\
    \ is given by the fraction CAP - SM. \n/// You should find the strongest extension\
    \ and return a string in this \n/// format: ClassName.StrongestExtensionName.\n\
    /// If there are two or more extensions with the same strength, you should\n///\
    \ choose the one that comes first in the array.\n/// For example, if you are given\
    \ \"Slices\" as the class and an array of the\n/// extensions: ['SErviNGSliCes',\
    \ 'Cheese', 'StuFfed'] then you should\n/// return 'Slices.SErviNGSliCes' since\
    \ 'SErviNGSliCes' is the strongest extension \n/// (its strength is -1).\n///\
    \ Example:\n/// >>> Strongest_Extension(class_name: \"my_class\", extensions:\
    \ [\"AA\", \"Be\", \"CC\"])\n/// \"my_class.AA\"\nfunc Strongest_Extension(class_name:\
    \ String, extensions: [String]) -> String {\n    return \"\"\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(Strongest_Extension(class_name: \"Watashi\", extensions:\
    \ [\"tEN\", \"niNE\", \"eIGHt8OKe\"]) == \"Watashi.eIGHt8OKe\")\nassert(Strongest_Extension(class_name:\
    \ \"Boku123\", extensions: [\"nani\", \"NazeDa\", \"YEs.WeCaNe\", \"32145tggg\"\
    ]) == \"Boku123.YEs.WeCaNe\")\nassert(Strongest_Extension(class_name: \"__YESIMHERE\"\
    , extensions: [\"t\", \"eMptY\", \"nothing\", \"zeR00\", \"NuLl__\", \"123NoooneB321\"\
    ]) == \"__YESIMHERE.NuLl__\")\nassert(Strongest_Extension(class_name: \"K\", extensions:\
    \ [\"Ta\", \"TAR\", \"t234An\", \"cosSo\"]) == \"K.TAR\")\nassert(Strongest_Extension(class_name:\
    \ \"__HAHA\", extensions: [\"Tab\", \"123\", \"781345\", \"-_-\"]) == \"__HAHA.123\"\
    )\nassert(Strongest_Extension(class_name: \"YameRore\", extensions: [\"HhAas\"\
    , \"okIWILL123\", \"WorkOut\", \"Fails\", \"-_-\"]) == \"YameRore.okIWILL123\"\
    )\nassert(Strongest_Extension(class_name: \"finNNalLLly\", extensions: [\"Die\"\
    , \"NowW\", \"Wow\", \"WoW\"]) == \"finNNalLLly.WoW\")\nassert(Strongest_Extension(class_name:\
    \ \"_\", extensions: [\"Bb\", \"91245\"]) == \"_.Bb\")\nassert(Strongest_Extension(class_name:\
    \ \"Sp\", extensions: [\"671235\", \"Bb\"]) == \"Sp.671235\")"
  status: Exception
  stderr: 'tmpuhmbxdp4/tmpuhmbxdp4.swift:35: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002abeef348c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002abeef03fb6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002abeef03f988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002abeef03e7b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpuhmbxdp4                        0x0000559ee0d614fd <unavailable> + 5373

    5    libc.so.6                          0x00002abeef534460 __libc_start_main +
    245

    6    tmpuhmbxdp4                        0x0000559ee0d61089 <unavailable> + 4233

    '
  stdout: ''
  timestamp: 1660009431
- exit_code: -4
  program: "\n/// You will be given the name of a class (a string) and an array of\
    \ extensions.\n/// The extensions are to be used to load additional classes to\
    \ the class. The\n/// strength of the extension is as follows: Let CAP be the\
    \ number of the uppercase\n/// letters in the extension's name, and let SM be\
    \ the number of lowercase letters \n/// in the extension's name, the strength\
    \ is given by the fraction CAP - SM. \n/// You should find the strongest extension\
    \ and return a string in this \n/// format: ClassName.StrongestExtensionName.\n\
    /// If there are two or more extensions with the same strength, you should\n///\
    \ choose the one that comes first in the array.\n/// For example, if you are given\
    \ \"Slices\" as the class and an array of the\n/// extensions: ['SErviNGSliCes',\
    \ 'Cheese', 'StuFfed'] then you should\n/// return 'Slices.SErviNGSliCes' since\
    \ 'SErviNGSliCes' is the strongest extension \n/// (its strength is -1).\n///\
    \ Example:\n/// >>> Strongest_Extension(class_name: \"my_class\", extensions:\
    \ [\"AA\", \"Be\", \"CC\"])\n/// \"my_class.AA\"\nfunc Strongest_Extension(class_name:\
    \ String, extensions: [String]) -> String {\n    var strongest_extension: (strength:\
    \ Float, extension: String) = (0, \"\")\n    for ext in extensions {\n       \
    \ var cap_count = 0\n        var sm_count = 0\n        for char in ext {\n   \
    \         if char.isUppercase {\n                cap_count += 1\n            }\
    \ else {\n                sm_count += 1\n            }\n        }\n        let\
    \ strength = Float(cap_count) - Float(sm_count)\n        if strength > strongest_extension.strength\
    \ {\n            strongest_extension = (strength, ext)\n        }\n    }\n   \
    \ return \"\\(class_name).\\(strongest_extension.extension)\"\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(Strongest_Extension(class_name: \"Watashi\", extensions:\
    \ [\"tEN\", \"niNE\", \"eIGHt8OKe\"]) == \"Watashi.eIGHt8OKe\")\nassert(Strongest_Extension(class_name:\
    \ \"Boku123\", extensions: [\"nani\", \"NazeDa\", \"YEs.WeCaNe\", \"32145tggg\"\
    ]) == \"Boku123.YEs.WeCaNe\")\nassert(Strongest_Extension(class_name: \"__YESIMHERE\"\
    , extensions: [\"t\", \"eMptY\", \"nothing\", \"zeR00\", \"NuLl__\", \"123NoooneB321\"\
    ]) == \"__YESIMHERE.NuLl__\")\nassert(Strongest_Extension(class_name: \"K\", extensions:\
    \ [\"Ta\", \"TAR\", \"t234An\", \"cosSo\"]) == \"K.TAR\")\nassert(Strongest_Extension(class_name:\
    \ \"__HAHA\", extensions: [\"Tab\", \"123\", \"781345\", \"-_-\"]) == \"__HAHA.123\"\
    )\nassert(Strongest_Extension(class_name: \"YameRore\", extensions: [\"HhAas\"\
    , \"okIWILL123\", \"WorkOut\", \"Fails\", \"-_-\"]) == \"YameRore.okIWILL123\"\
    )\nassert(Strongest_Extension(class_name: \"finNNalLLly\", extensions: [\"Die\"\
    , \"NowW\", \"Wow\", \"WoW\"]) == \"finNNalLLly.WoW\")\nassert(Strongest_Extension(class_name:\
    \ \"_\", extensions: [\"Bb\", \"91245\"]) == \"_.Bb\")\nassert(Strongest_Extension(class_name:\
    \ \"Sp\", extensions: [\"671235\", \"Bb\"]) == \"Sp.671235\")"
  status: Exception
  stderr: 'tmpie1uxnil/tmpie1uxnil.swift:51: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b756483fc80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b7564536b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b7564536988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b75645357b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpie1uxnil                        0x0000556d55fb3a3d <unavailable> + 6717

    5    libc.so.6                          0x00002b7564a2b460 __libc_start_main +
    245

    6    tmpie1uxnil                        0x0000556d55fb35c9 <unavailable> + 5577

    '
  stdout: ''
  timestamp: 1660009434
- exit_code: 0
  program: "\n/// You will be given the name of a class (a string) and an array of\
    \ extensions.\n/// The extensions are to be used to load additional classes to\
    \ the class. The\n/// strength of the extension is as follows: Let CAP be the\
    \ number of the uppercase\n/// letters in the extension's name, and let SM be\
    \ the number of lowercase letters \n/// in the extension's name, the strength\
    \ is given by the fraction CAP - SM. \n/// You should find the strongest extension\
    \ and return a string in this \n/// format: ClassName.StrongestExtensionName.\n\
    /// If there are two or more extensions with the same strength, you should\n///\
    \ choose the one that comes first in the array.\n/// For example, if you are given\
    \ \"Slices\" as the class and an array of the\n/// extensions: ['SErviNGSliCes',\
    \ 'Cheese', 'StuFfed'] then you should\n/// return 'Slices.SErviNGSliCes' since\
    \ 'SErviNGSliCes' is the strongest extension \n/// (its strength is -1).\n///\
    \ Example:\n/// >>> Strongest_Extension(class_name: \"my_class\", extensions:\
    \ [\"AA\", \"Be\", \"CC\"])\n/// \"my_class.AA\"\nfunc Strongest_Extension(class_name:\
    \ String, extensions: [String]) -> String {\n    var temp: (extension_name: String,\
    \ extension_score: Double)?\n    for extension_name in extensions {\n        let\
    \ cap_count = extension_name.filter({ (char) -> Bool in\n            return char.isUppercase\n\
    \        }).count\n        let sm_count = extension_name.filter({ (char) -> Bool\
    \ in\n            return char.isLowercase\n        }).count\n        let extension_score\
    \ = Double(cap_count) - Double(sm_count)\n        if temp == nil {\n         \
    \   temp = (extension_name, extension_score)\n        } else {\n            if\
    \ extension_score > temp!.extension_score {\n                temp = (extension_name,\
    \ extension_score)\n            }\n        }\n    }\n    return \"\\(class_name).\\\
    (temp!.extension_name)\"\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(Strongest_Extension(class_name:\
    \ \"Watashi\", extensions: [\"tEN\", \"niNE\", \"eIGHt8OKe\"]) == \"Watashi.eIGHt8OKe\"\
    )\nassert(Strongest_Extension(class_name: \"Boku123\", extensions: [\"nani\",\
    \ \"NazeDa\", \"YEs.WeCaNe\", \"32145tggg\"]) == \"Boku123.YEs.WeCaNe\")\nassert(Strongest_Extension(class_name:\
    \ \"__YESIMHERE\", extensions: [\"t\", \"eMptY\", \"nothing\", \"zeR00\", \"NuLl__\"\
    , \"123NoooneB321\"]) == \"__YESIMHERE.NuLl__\")\nassert(Strongest_Extension(class_name:\
    \ \"K\", extensions: [\"Ta\", \"TAR\", \"t234An\", \"cosSo\"]) == \"K.TAR\")\n\
    assert(Strongest_Extension(class_name: \"__HAHA\", extensions: [\"Tab\", \"123\"\
    , \"781345\", \"-_-\"]) == \"__HAHA.123\")\nassert(Strongest_Extension(class_name:\
    \ \"YameRore\", extensions: [\"HhAas\", \"okIWILL123\", \"WorkOut\", \"Fails\"\
    , \"-_-\"]) == \"YameRore.okIWILL123\")\nassert(Strongest_Extension(class_name:\
    \ \"finNNalLLly\", extensions: [\"Die\", \"NowW\", \"Wow\", \"WoW\"]) == \"finNNalLLly.WoW\"\
    )\nassert(Strongest_Extension(class_name: \"_\", extensions: [\"Bb\", \"91245\"\
    ]) == \"_.Bb\")\nassert(Strongest_Extension(class_name: \"Sp\", extensions: [\"\
    671235\", \"Bb\"]) == \"Sp.671235\")"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660009434
- exit_code: 1
  program: "\n/// You will be given the name of a class (a string) and an array of\
    \ extensions.\n/// The extensions are to be used to load additional classes to\
    \ the class. The\n/// strength of the extension is as follows: Let CAP be the\
    \ number of the uppercase\n/// letters in the extension's name, and let SM be\
    \ the number of lowercase letters \n/// in the extension's name, the strength\
    \ is given by the fraction CAP - SM. \n/// You should find the strongest extension\
    \ and return a string in this \n/// format: ClassName.StrongestExtensionName.\n\
    /// If there are two or more extensions with the same strength, you should\n///\
    \ choose the one that comes first in the array.\n/// For example, if you are given\
    \ \"Slices\" as the class and an array of the\n/// extensions: ['SErviNGSliCes',\
    \ 'Cheese', 'StuFfed'] then you should\n/// return 'Slices.SErviNGSliCes' since\
    \ 'SErviNGSliCes' is the strongest extension \n/// (its strength is -1).\n///\
    \ Example:\n/// >>> Strongest_Extension(class_name: \"my_class\", extensions:\
    \ [\"AA\", \"Be\", \"CC\"])\n/// \"my_class.AA\"\nfunc Strongest_Extension(class_name:\
    \ String, extensions: [String]) -> String {\n    let uppCase = CharacterSet.uppercaseLetters\n\
    \    let lowCase = CharacterSet.lowercaseLetters\n    var strengths = [String:\
    \ Double]()\n    for ext in extensions {\n        var uppCount = 0\n        var\
    \ lowCount = 0\n        for char in ext.unicodeScalars {\n            if uppCase.contains(char)\
    \ {\n                uppCount += 1\n            } else if lowCase.contains(char)\
    \ {\n                lowCount += 1\n            }\n        }\n        strengths[ext]\
    \ = Double(uppCount - lowCount)\n    }\n    let strongest = extensions.sorted\
    \ {(ext1, ext2) in\n        return strengths[ext1]! > strengths[ext2]!\n    }\n\
    \    return \"\\(class_name).\\(strongest[0])\"\n}\n\n\nfunc ==(left: [(Int, Int)],\
    \ right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n       \
    \ return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r\
    \ {\n            return false\n        }\n    }\n    return true\n}\n        \
    \    \nassert(Strongest_Extension(class_name: \"Watashi\", extensions: [\"tEN\"\
    , \"niNE\", \"eIGHt8OKe\"]) == \"Watashi.eIGHt8OKe\")\nassert(Strongest_Extension(class_name:\
    \ \"Boku123\", extensions: [\"nani\", \"NazeDa\", \"YEs.WeCaNe\", \"32145tggg\"\
    ]) == \"Boku123.YEs.WeCaNe\")\nassert(Strongest_Extension(class_name: \"__YESIMHERE\"\
    , extensions: [\"t\", \"eMptY\", \"nothing\", \"zeR00\", \"NuLl__\", \"123NoooneB321\"\
    ]) == \"__YESIMHERE.NuLl__\")\nassert(Strongest_Extension(class_name: \"K\", extensions:\
    \ [\"Ta\", \"TAR\", \"t234An\", \"cosSo\"]) == \"K.TAR\")\nassert(Strongest_Extension(class_name:\
    \ \"__HAHA\", extensions: [\"Tab\", \"123\", \"781345\", \"-_-\"]) == \"__HAHA.123\"\
    )\nassert(Strongest_Extension(class_name: \"YameRore\", extensions: [\"HhAas\"\
    , \"okIWILL123\", \"WorkOut\", \"Fails\", \"-_-\"]) == \"YameRore.okIWILL123\"\
    )\nassert(Strongest_Extension(class_name: \"finNNalLLly\", extensions: [\"Die\"\
    , \"NowW\", \"Wow\", \"WoW\"]) == \"finNNalLLly.WoW\")\nassert(Strongest_Extension(class_name:\
    \ \"_\", extensions: [\"Bb\", \"91245\"]) == \"_.Bb\")\nassert(Strongest_Extension(class_name:\
    \ \"Sp\", extensions: [\"671235\", \"Bb\"]) == \"Sp.671235\")"
  status: SyntaxError
  stderr: "/tmp/tmplx878aid.swift:19:19: error: cannot find 'CharacterSet' in scope\n\
    \    let uppCase = CharacterSet.uppercaseLetters\n                  ^~~~~~~~~~~~\n\
    /tmp/tmplx878aid.swift:20:19: error: cannot find 'CharacterSet' in scope\n   \
    \ let lowCase = CharacterSet.lowercaseLetters\n                  ^~~~~~~~~~~~\n"
  stdout: ''
  timestamp: 1660009433
- exit_code: 1
  program: "\n/// You will be given the name of a class (a string) and an array of\
    \ extensions.\n/// The extensions are to be used to load additional classes to\
    \ the class. The\n/// strength of the extension is as follows: Let CAP be the\
    \ number of the uppercase\n/// letters in the extension's name, and let SM be\
    \ the number of lowercase letters \n/// in the extension's name, the strength\
    \ is given by the fraction CAP - SM. \n/// You should find the strongest extension\
    \ and return a string in this \n/// format: ClassName.StrongestExtensionName.\n\
    /// If there are two or more extensions with the same strength, you should\n///\
    \ choose the one that comes first in the array.\n/// For example, if you are given\
    \ \"Slices\" as the class and an array of the\n/// extensions: ['SErviNGSliCes',\
    \ 'Cheese', 'StuFfed'] then you should\n/// return 'Slices.SErviNGSliCes' since\
    \ 'SErviNGSliCes' is the strongest extension \n/// (its strength is -1).\n///\
    \ Example:\n/// >>> Strongest_Extension(class_name: \"my_class\", extensions:\
    \ [\"AA\", \"Be\", \"CC\"])\n/// \"my_class.AA\"\nfunc Strongest_Extension(class_name:\
    \ String, extensions: [String]) -> String {\n    var extension_strength = [Float]()\n\
    \    var upper_count = 0\n    var lower_count = 0\n    var extension_name = [String]()\n\
    \    var strength = 0.0\n    var extension_total = \"\"\n    for extension in\
    \ extensions {\n        upper_count = 0\n        lower_count = 0\n        for\
    \ value in extension {\n            if value.isUppercase {\n                upper_count\
    \ += 1\n            } else {\n                lower_count += 1\n            }\n\
    \        }\n        strength = Float(upper_count) - Float(lower_count)\n     \
    \   extension_strength.append(strength)\n        extension_name.append(extension)\n\
    \    }\n    let index = extension_strength.firstIndex(of: extension_strength.max()!)\n\
    \    extension_total = class_name + \".\" + extension_name[index!]\n    return\
    \ extension_total\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) ->\
    \ Bool {\n    if left.count != right.count {\n        return false\n    }\n  \
    \  for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(Strongest_Extension(class_name:\
    \ \"Watashi\", extensions: [\"tEN\", \"niNE\", \"eIGHt8OKe\"]) == \"Watashi.eIGHt8OKe\"\
    )\nassert(Strongest_Extension(class_name: \"Boku123\", extensions: [\"nani\",\
    \ \"NazeDa\", \"YEs.WeCaNe\", \"32145tggg\"]) == \"Boku123.YEs.WeCaNe\")\nassert(Strongest_Extension(class_name:\
    \ \"__YESIMHERE\", extensions: [\"t\", \"eMptY\", \"nothing\", \"zeR00\", \"NuLl__\"\
    , \"123NoooneB321\"]) == \"__YESIMHERE.NuLl__\")\nassert(Strongest_Extension(class_name:\
    \ \"K\", extensions: [\"Ta\", \"TAR\", \"t234An\", \"cosSo\"]) == \"K.TAR\")\n\
    assert(Strongest_Extension(class_name: \"__HAHA\", extensions: [\"Tab\", \"123\"\
    , \"781345\", \"-_-\"]) == \"__HAHA.123\")\nassert(Strongest_Extension(class_name:\
    \ \"YameRore\", extensions: [\"HhAas\", \"okIWILL123\", \"WorkOut\", \"Fails\"\
    , \"-_-\"]) == \"YameRore.okIWILL123\")\nassert(Strongest_Extension(class_name:\
    \ \"finNNalLLly\", extensions: [\"Die\", \"NowW\", \"Wow\", \"WoW\"]) == \"finNNalLLly.WoW\"\
    )\nassert(Strongest_Extension(class_name: \"_\", extensions: [\"Bb\", \"91245\"\
    ]) == \"_.Bb\")\nassert(Strongest_Extension(class_name: \"Sp\", extensions: [\"\
    671235\", \"Bb\"]) == \"Sp.671235\")"
  status: SyntaxError
  stderr: "/tmp/tmp0sd8hwe9.swift:25:9: error: expected pattern\n    for extension\
    \ in extensions {\n        ^\n/tmp/tmp0sd8hwe9.swift:25:9: error: expected Sequence\
    \ expression for for-each loop\n    for extension in extensions {\n        ^\n\
    /tmp/tmp0sd8hwe9.swift:25:9: error: expected '{' to start the body of for-each\
    \ loop\n    for extension in extensions {\n        ^\n/tmp/tmp0sd8hwe9.swift:28:22:\
    \ error: expected Sequence expression for for-each loop\n        for value in\
    \ extension {\n                     ^\n/tmp/tmp0sd8hwe9.swift:28:22: error: expected\
    \ '{' to start the body of for-each loop\n        for value in extension {\n \
    \                    ^\n"
  stdout: ''
  timestamp: 1660009433
- exit_code: 1
  program: "\n/// You will be given the name of a class (a string) and an array of\
    \ extensions.\n/// The extensions are to be used to load additional classes to\
    \ the class. The\n/// strength of the extension is as follows: Let CAP be the\
    \ number of the uppercase\n/// letters in the extension's name, and let SM be\
    \ the number of lowercase letters \n/// in the extension's name, the strength\
    \ is given by the fraction CAP - SM. \n/// You should find the strongest extension\
    \ and return a string in this \n/// format: ClassName.StrongestExtensionName.\n\
    /// If there are two or more extensions with the same strength, you should\n///\
    \ choose the one that comes first in the array.\n/// For example, if you are given\
    \ \"Slices\" as the class and an array of the\n/// extensions: ['SErviNGSliCes',\
    \ 'Cheese', 'StuFfed'] then you should\n/// return 'Slices.SErviNGSliCes' since\
    \ 'SErviNGSliCes' is the strongest extension \n/// (its strength is -1).\n///\
    \ Example:\n/// >>> Strongest_Extension(class_name: \"my_class\", extensions:\
    \ [\"AA\", \"Be\", \"CC\"])\n/// \"my_class.AA\"\nfunc Strongest_Extension(class_name:\
    \ String, extensions: [String]) -> String {\n    var max_strength = 0.0\n    var\
    \ max_index = 0\n    for index in 0..<extensions.count {\n        let current_strength\
    \ = Strength(extensions[index])\n        if current_strength > max_strength {\n\
    \            max_strength = current_strength\n            max_index = index\n\
    \        }\n    }\n    return \"\\(class_name).\\(extensions[max_index])\"\n}\n\
    \n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(Strongest_Extension(class_name: \"Watashi\", extensions:\
    \ [\"tEN\", \"niNE\", \"eIGHt8OKe\"]) == \"Watashi.eIGHt8OKe\")\nassert(Strongest_Extension(class_name:\
    \ \"Boku123\", extensions: [\"nani\", \"NazeDa\", \"YEs.WeCaNe\", \"32145tggg\"\
    ]) == \"Boku123.YEs.WeCaNe\")\nassert(Strongest_Extension(class_name: \"__YESIMHERE\"\
    , extensions: [\"t\", \"eMptY\", \"nothing\", \"zeR00\", \"NuLl__\", \"123NoooneB321\"\
    ]) == \"__YESIMHERE.NuLl__\")\nassert(Strongest_Extension(class_name: \"K\", extensions:\
    \ [\"Ta\", \"TAR\", \"t234An\", \"cosSo\"]) == \"K.TAR\")\nassert(Strongest_Extension(class_name:\
    \ \"__HAHA\", extensions: [\"Tab\", \"123\", \"781345\", \"-_-\"]) == \"__HAHA.123\"\
    )\nassert(Strongest_Extension(class_name: \"YameRore\", extensions: [\"HhAas\"\
    , \"okIWILL123\", \"WorkOut\", \"Fails\", \"-_-\"]) == \"YameRore.okIWILL123\"\
    )\nassert(Strongest_Extension(class_name: \"finNNalLLly\", extensions: [\"Die\"\
    , \"NowW\", \"Wow\", \"WoW\"]) == \"finNNalLLly.WoW\")\nassert(Strongest_Extension(class_name:\
    \ \"_\", extensions: [\"Bb\", \"91245\"]) == \"_.Bb\")\nassert(Strongest_Extension(class_name:\
    \ \"Sp\", extensions: [\"671235\", \"Bb\"]) == \"Sp.671235\")"
  status: SyntaxError
  stderr: "/tmp/tmpsxhxvcg6.swift:22:32: error: cannot find 'Strength' in scope\n\
    \        let current_strength = Strength(extensions[index])\n                \
    \               ^~~~~~~~\n"
  stdout: ''
  timestamp: 1660009433
- exit_code: 1
  program: "\n/// You will be given the name of a class (a string) and an array of\
    \ extensions.\n/// The extensions are to be used to load additional classes to\
    \ the class. The\n/// strength of the extension is as follows: Let CAP be the\
    \ number of the uppercase\n/// letters in the extension's name, and let SM be\
    \ the number of lowercase letters \n/// in the extension's name, the strength\
    \ is given by the fraction CAP - SM. \n/// You should find the strongest extension\
    \ and return a string in this \n/// format: ClassName.StrongestExtensionName.\n\
    /// If there are two or more extensions with the same strength, you should\n///\
    \ choose the one that comes first in the array.\n/// For example, if you are given\
    \ \"Slices\" as the class and an array of the\n/// extensions: ['SErviNGSliCes',\
    \ 'Cheese', 'StuFfed'] then you should\n/// return 'Slices.SErviNGSliCes' since\
    \ 'SErviNGSliCes' is the strongest extension \n/// (its strength is -1).\n///\
    \ Example:\n/// >>> Strongest_Extension(class_name: \"my_class\", extensions:\
    \ [\"AA\", \"Be\", \"CC\"])\n/// \"my_class.AA\"\nfunc Strongest_Extension(class_name:\
    \ String, extensions: [String]) -> String {\n    var strongest: Double = 0.0\n\
    \    var strongestIndex: Int = 0\n    for (index, extension) in extensions.enumerated()\
    \ {\n        var capital: Double = 0.0\n        var small: Double = 0.0\n    \
    \    for char in extension {\n            if \"A\"...\"Z\" ~= char {\n       \
    \         capital += 1\n            } else if \"a\"...\"z\" ~= char {\n      \
    \          small += 1\n            }\n        }\n        let currentStrength =\
    \ capital - small\n        if currentStrength > strongest {\n            strongest\
    \ = currentStrength\n            strongestIndex = index\n        }\n    }\n  \
    \  return \"\\(class_name).\\(extensions[strongestIndex])\"\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(Strongest_Extension(class_name: \"Watashi\", extensions:\
    \ [\"tEN\", \"niNE\", \"eIGHt8OKe\"]) == \"Watashi.eIGHt8OKe\")\nassert(Strongest_Extension(class_name:\
    \ \"Boku123\", extensions: [\"nani\", \"NazeDa\", \"YEs.WeCaNe\", \"32145tggg\"\
    ]) == \"Boku123.YEs.WeCaNe\")\nassert(Strongest_Extension(class_name: \"__YESIMHERE\"\
    , extensions: [\"t\", \"eMptY\", \"nothing\", \"zeR00\", \"NuLl__\", \"123NoooneB321\"\
    ]) == \"__YESIMHERE.NuLl__\")\nassert(Strongest_Extension(class_name: \"K\", extensions:\
    \ [\"Ta\", \"TAR\", \"t234An\", \"cosSo\"]) == \"K.TAR\")\nassert(Strongest_Extension(class_name:\
    \ \"__HAHA\", extensions: [\"Tab\", \"123\", \"781345\", \"-_-\"]) == \"__HAHA.123\"\
    )\nassert(Strongest_Extension(class_name: \"YameRore\", extensions: [\"HhAas\"\
    , \"okIWILL123\", \"WorkOut\", \"Fails\", \"-_-\"]) == \"YameRore.okIWILL123\"\
    )\nassert(Strongest_Extension(class_name: \"finNNalLLly\", extensions: [\"Die\"\
    , \"NowW\", \"Wow\", \"WoW\"]) == \"finNNalLLly.WoW\")\nassert(Strongest_Extension(class_name:\
    \ \"_\", extensions: [\"Bb\", \"91245\"]) == \"_.Bb\")\nassert(Strongest_Extension(class_name:\
    \ \"Sp\", extensions: [\"671235\", \"Bb\"]) == \"Sp.671235\")"
  status: SyntaxError
  stderr: "/tmp/tmpua3ou3w5.swift:21:17: error: expected pattern\n    for (index,\
    \ extension) in extensions.enumerated() {\n                ^\n/tmp/tmpua3ou3w5.swift:21:17:\
    \ error: expected 'in' after for-each pattern\n    for (index, extension) in extensions.enumerated()\
    \ {\n                ^\n/tmp/tmpua3ou3w5.swift:21:17: error: expected Sequence\
    \ expression for for-each loop\n    for (index, extension) in extensions.enumerated()\
    \ {\n                ^\n/tmp/tmpua3ou3w5.swift:21:17: error: expected '{' to start\
    \ the body of for-each loop\n    for (index, extension) in extensions.enumerated()\
    \ {\n                ^\n/tmp/tmpua3ou3w5.swift:24:21: error: expected Sequence\
    \ expression for for-each loop\n        for char in extension {\n            \
    \        ^\n/tmp/tmpua3ou3w5.swift:24:21: error: expected '{' to start the body\
    \ of for-each loop\n        for char in extension {\n                    ^\n"
  stdout: ''
  timestamp: 1660009434
- exit_code: -4
  program: "\n/// You will be given the name of a class (a string) and an array of\
    \ extensions.\n/// The extensions are to be used to load additional classes to\
    \ the class. The\n/// strength of the extension is as follows: Let CAP be the\
    \ number of the uppercase\n/// letters in the extension's name, and let SM be\
    \ the number of lowercase letters \n/// in the extension's name, the strength\
    \ is given by the fraction CAP - SM. \n/// You should find the strongest extension\
    \ and return a string in this \n/// format: ClassName.StrongestExtensionName.\n\
    /// If there are two or more extensions with the same strength, you should\n///\
    \ choose the one that comes first in the array.\n/// For example, if you are given\
    \ \"Slices\" as the class and an array of the\n/// extensions: ['SErviNGSliCes',\
    \ 'Cheese', 'StuFfed'] then you should\n/// return 'Slices.SErviNGSliCes' since\
    \ 'SErviNGSliCes' is the strongest extension \n/// (its strength is -1).\n///\
    \ Example:\n/// >>> Strongest_Extension(class_name: \"my_class\", extensions:\
    \ [\"AA\", \"Be\", \"CC\"])\n/// \"my_class.AA\"\nfunc Strongest_Extension(class_name:\
    \ String, extensions: [String]) -> String {\n    var strongest_extension = extensions[0]\n\
    \    var strongest_strength = 0\n    for extension_name in extensions {\n    \
    \    var strength = 0\n        for char in extension_name {\n            if char.isUppercase\
    \ {\n                strength += 1\n            } else {\n                strength\
    \ -= 1\n            }\n        }\n        if strength > strongest_strength {\n\
    \            strongest_strength = strength\n            strongest_extension =\
    \ extension_name\n        }\n    }\n    return class_name + \".\" + strongest_extension\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(Strongest_Extension(class_name: \"Watashi\", extensions:\
    \ [\"tEN\", \"niNE\", \"eIGHt8OKe\"]) == \"Watashi.eIGHt8OKe\")\nassert(Strongest_Extension(class_name:\
    \ \"Boku123\", extensions: [\"nani\", \"NazeDa\", \"YEs.WeCaNe\", \"32145tggg\"\
    ]) == \"Boku123.YEs.WeCaNe\")\nassert(Strongest_Extension(class_name: \"__YESIMHERE\"\
    , extensions: [\"t\", \"eMptY\", \"nothing\", \"zeR00\", \"NuLl__\", \"123NoooneB321\"\
    ]) == \"__YESIMHERE.NuLl__\")\nassert(Strongest_Extension(class_name: \"K\", extensions:\
    \ [\"Ta\", \"TAR\", \"t234An\", \"cosSo\"]) == \"K.TAR\")\nassert(Strongest_Extension(class_name:\
    \ \"__HAHA\", extensions: [\"Tab\", \"123\", \"781345\", \"-_-\"]) == \"__HAHA.123\"\
    )\nassert(Strongest_Extension(class_name: \"YameRore\", extensions: [\"HhAas\"\
    , \"okIWILL123\", \"WorkOut\", \"Fails\", \"-_-\"]) == \"YameRore.okIWILL123\"\
    )\nassert(Strongest_Extension(class_name: \"finNNalLLly\", extensions: [\"Die\"\
    , \"NowW\", \"Wow\", \"WoW\"]) == \"finNNalLLly.WoW\")\nassert(Strongest_Extension(class_name:\
    \ \"_\", extensions: [\"Bb\", \"91245\"]) == \"_.Bb\")\nassert(Strongest_Extension(class_name:\
    \ \"Sp\", extensions: [\"671235\", \"Bb\"]) == \"Sp.671235\")"
  status: Exception
  stderr: 'tmpjzniffix/tmpjzniffix.swift:51: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b97fb9dcc80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b97fb6d3b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b97fb6d3988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b97fb6d27b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpjzniffix                        0x000055dde8ef681d <unavailable> + 6173

    5    libc.so.6                          0x00002b97fbbc8460 __libc_start_main +
    245

    6    tmpjzniffix                        0x000055dde8ef63a9 <unavailable> + 5033

    '
  stdout: ''
  timestamp: 1660009434
- exit_code: -4
  program: "\n/// You will be given the name of a class (a string) and an array of\
    \ extensions.\n/// The extensions are to be used to load additional classes to\
    \ the class. The\n/// strength of the extension is as follows: Let CAP be the\
    \ number of the uppercase\n/// letters in the extension's name, and let SM be\
    \ the number of lowercase letters \n/// in the extension's name, the strength\
    \ is given by the fraction CAP - SM. \n/// You should find the strongest extension\
    \ and return a string in this \n/// format: ClassName.StrongestExtensionName.\n\
    /// If there are two or more extensions with the same strength, you should\n///\
    \ choose the one that comes first in the array.\n/// For example, if you are given\
    \ \"Slices\" as the class and an array of the\n/// extensions: ['SErviNGSliCes',\
    \ 'Cheese', 'StuFfed'] then you should\n/// return 'Slices.SErviNGSliCes' since\
    \ 'SErviNGSliCes' is the strongest extension \n/// (its strength is -1).\n///\
    \ Example:\n/// >>> Strongest_Extension(class_name: \"my_class\", extensions:\
    \ [\"AA\", \"Be\", \"CC\"])\n/// \"my_class.AA\"\nfunc Strongest_Extension(class_name:\
    \ String, extensions: [String]) -> String {\n    var strongest_extension = \"\"\
    \n    var strongest_strength = 0.0\n    for extension_name in extensions {\n \
    \       var CAP = 0\n        var SM = 0\n        for letter in extension_name\
    \ {\n            if letter.isUppercase {\n                CAP += 1\n         \
    \   } else {\n                SM += 1\n            }\n        }\n        let strength\
    \ = Double(CAP) - Double(SM)\n        if strength > strongest_strength {\n   \
    \         strongest_strength = strength\n            strongest_extension = extension_name\n\
    \        }\n    }\n    return \"\\(class_name).\\(strongest_extension)\"\n}\n\n\
    \nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(Strongest_Extension(class_name: \"Watashi\", extensions:\
    \ [\"tEN\", \"niNE\", \"eIGHt8OKe\"]) == \"Watashi.eIGHt8OKe\")\nassert(Strongest_Extension(class_name:\
    \ \"Boku123\", extensions: [\"nani\", \"NazeDa\", \"YEs.WeCaNe\", \"32145tggg\"\
    ]) == \"Boku123.YEs.WeCaNe\")\nassert(Strongest_Extension(class_name: \"__YESIMHERE\"\
    , extensions: [\"t\", \"eMptY\", \"nothing\", \"zeR00\", \"NuLl__\", \"123NoooneB321\"\
    ]) == \"__YESIMHERE.NuLl__\")\nassert(Strongest_Extension(class_name: \"K\", extensions:\
    \ [\"Ta\", \"TAR\", \"t234An\", \"cosSo\"]) == \"K.TAR\")\nassert(Strongest_Extension(class_name:\
    \ \"__HAHA\", extensions: [\"Tab\", \"123\", \"781345\", \"-_-\"]) == \"__HAHA.123\"\
    )\nassert(Strongest_Extension(class_name: \"YameRore\", extensions: [\"HhAas\"\
    , \"okIWILL123\", \"WorkOut\", \"Fails\", \"-_-\"]) == \"YameRore.okIWILL123\"\
    )\nassert(Strongest_Extension(class_name: \"finNNalLLly\", extensions: [\"Die\"\
    , \"NowW\", \"Wow\", \"WoW\"]) == \"finNNalLLly.WoW\")\nassert(Strongest_Extension(class_name:\
    \ \"_\", extensions: [\"Bb\", \"91245\"]) == \"_.Bb\")\nassert(Strongest_Extension(class_name:\
    \ \"Sp\", extensions: [\"671235\", \"Bb\"]) == \"Sp.671235\")"
  status: Exception
  stderr: 'tmp51vg5rt7/tmp51vg5rt7.swift:53: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b4bf50b5c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b4bf4dacb6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b4bf4dac988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b4bf4dab7b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmp51vg5rt7                        0x000055c2de443a3d <unavailable> + 6717

    5    libc.so.6                          0x00002b4bf52a1460 __libc_start_main +
    245

    6    tmp51vg5rt7                        0x000055c2de4435c9 <unavailable> + 5577

    '
  stdout: ''
  timestamp: 1660009434
- exit_code: -4
  program: "\n/// You will be given the name of a class (a string) and an array of\
    \ extensions.\n/// The extensions are to be used to load additional classes to\
    \ the class. The\n/// strength of the extension is as follows: Let CAP be the\
    \ number of the uppercase\n/// letters in the extension's name, and let SM be\
    \ the number of lowercase letters \n/// in the extension's name, the strength\
    \ is given by the fraction CAP - SM. \n/// You should find the strongest extension\
    \ and return a string in this \n/// format: ClassName.StrongestExtensionName.\n\
    /// If there are two or more extensions with the same strength, you should\n///\
    \ choose the one that comes first in the array.\n/// For example, if you are given\
    \ \"Slices\" as the class and an array of the\n/// extensions: ['SErviNGSliCes',\
    \ 'Cheese', 'StuFfed'] then you should\n/// return 'Slices.SErviNGSliCes' since\
    \ 'SErviNGSliCes' is the strongest extension \n/// (its strength is -1).\n///\
    \ Example:\n/// >>> Strongest_Extension(class_name: \"my_class\", extensions:\
    \ [\"AA\", \"Be\", \"CC\"])\n/// \"my_class.AA\"\nfunc Strongest_Extension(class_name:\
    \ String, extensions: [String]) -> String {\n\tvar fraction = 0.0\n\tvar strongest_extension\
    \ = \"\"\n\tfor ext in extensions {\n\t\tlet capital_letters = ext.filter { $0.isUppercase\
    \ }\n\t\tlet small_letters = ext.filter { $0.isLowercase }\n\t\tlet s = Double(capital_letters.count)\
    \ - Double(small_letters.count)\n\t\tif s > fraction {\n\t\t\tfraction = s\n\t\
    \t\tstrongest_extension = ext\n\t\t}\n\t}\n\treturn \"\\(class_name).\\(strongest_extension)\"\
    \n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(Strongest_Extension(class_name: \"Watashi\", extensions:\
    \ [\"tEN\", \"niNE\", \"eIGHt8OKe\"]) == \"Watashi.eIGHt8OKe\")\nassert(Strongest_Extension(class_name:\
    \ \"Boku123\", extensions: [\"nani\", \"NazeDa\", \"YEs.WeCaNe\", \"32145tggg\"\
    ]) == \"Boku123.YEs.WeCaNe\")\nassert(Strongest_Extension(class_name: \"__YESIMHERE\"\
    , extensions: [\"t\", \"eMptY\", \"nothing\", \"zeR00\", \"NuLl__\", \"123NoooneB321\"\
    ]) == \"__YESIMHERE.NuLl__\")\nassert(Strongest_Extension(class_name: \"K\", extensions:\
    \ [\"Ta\", \"TAR\", \"t234An\", \"cosSo\"]) == \"K.TAR\")\nassert(Strongest_Extension(class_name:\
    \ \"__HAHA\", extensions: [\"Tab\", \"123\", \"781345\", \"-_-\"]) == \"__HAHA.123\"\
    )\nassert(Strongest_Extension(class_name: \"YameRore\", extensions: [\"HhAas\"\
    , \"okIWILL123\", \"WorkOut\", \"Fails\", \"-_-\"]) == \"YameRore.okIWILL123\"\
    )\nassert(Strongest_Extension(class_name: \"finNNalLLly\", extensions: [\"Die\"\
    , \"NowW\", \"Wow\", \"WoW\"]) == \"finNNalLLly.WoW\")\nassert(Strongest_Extension(class_name:\
    \ \"_\", extensions: [\"Bb\", \"91245\"]) == \"_.Bb\")\nassert(Strongest_Extension(class_name:\
    \ \"Sp\", extensions: [\"671235\", \"Bb\"]) == \"Sp.671235\")"
  status: Exception
  stderr: 'tmp60hhsamm/tmp60hhsamm.swift:48: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002aefc9dc9c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002aefc9ac0b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002aefc9ac0988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002aefc9abf7b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmp60hhsamm                        0x0000556cc2c0cf4c <unavailable> + 8012

    5    libc.so.6                          0x00002aefc9fb5460 __libc_start_main +
    245

    6    tmp60hhsamm                        0x0000556cc2c0c659 <unavailable> + 5721

    '
  stdout: ''
  timestamp: 1660009434
- exit_code: 1
  program: "\n/// You will be given the name of a class (a string) and an array of\
    \ extensions.\n/// The extensions are to be used to load additional classes to\
    \ the class. The\n/// strength of the extension is as follows: Let CAP be the\
    \ number of the uppercase\n/// letters in the extension's name, and let SM be\
    \ the number of lowercase letters \n/// in the extension's name, the strength\
    \ is given by the fraction CAP - SM. \n/// You should find the strongest extension\
    \ and return a string in this \n/// format: ClassName.StrongestExtensionName.\n\
    /// If there are two or more extensions with the same strength, you should\n///\
    \ choose the one that comes first in the array.\n/// For example, if you are given\
    \ \"Slices\" as the class and an array of the\n/// extensions: ['SErviNGSliCes',\
    \ 'Cheese', 'StuFfed'] then you should\n/// return 'Slices.SErviNGSliCes' since\
    \ 'SErviNGSliCes' is the strongest extension \n/// (its strength is -1).\n///\
    \ Example:\n/// >>> Strongest_Extension(class_name: \"my_class\", extensions:\
    \ [\"AA\", \"Be\", \"CC\"])\n/// \"my_class.AA\"\nfunc Strongest_Extension(class_name:\
    \ String, extensions: [String]) -> String {\n\tvar dict = [String: Float]()\n\t\
    var cap = 0\n\tvar sm = 0\n\tfor i in extensions {\n\t\tfor _ in i {\n\t\t\tif\
    \ \"A\"...\"Z\" ~= i.characters.first! {\n\t\t\t\tcap += 1\n\t\t\t} else {\n\t\
    \t\t\tsm += 1\n\t\t\t}\n\t\t}\n\t\tdict[i] = Float(cap - sm)\n\t\tcap = 0\n\t\t\
    sm = 0\n\t}\n\tlet orderedArray = dict.sort{ $0.0 < $1.0 }\n\treturn \"\\(class_name).\\\
    (orderedArray.last!.0)\"\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(Strongest_Extension(class_name:\
    \ \"Watashi\", extensions: [\"tEN\", \"niNE\", \"eIGHt8OKe\"]) == \"Watashi.eIGHt8OKe\"\
    )\nassert(Strongest_Extension(class_name: \"Boku123\", extensions: [\"nani\",\
    \ \"NazeDa\", \"YEs.WeCaNe\", \"32145tggg\"]) == \"Boku123.YEs.WeCaNe\")\nassert(Strongest_Extension(class_name:\
    \ \"__YESIMHERE\", extensions: [\"t\", \"eMptY\", \"nothing\", \"zeR00\", \"NuLl__\"\
    , \"123NoooneB321\"]) == \"__YESIMHERE.NuLl__\")\nassert(Strongest_Extension(class_name:\
    \ \"K\", extensions: [\"Ta\", \"TAR\", \"t234An\", \"cosSo\"]) == \"K.TAR\")\n\
    assert(Strongest_Extension(class_name: \"__HAHA\", extensions: [\"Tab\", \"123\"\
    , \"781345\", \"-_-\"]) == \"__HAHA.123\")\nassert(Strongest_Extension(class_name:\
    \ \"YameRore\", extensions: [\"HhAas\", \"okIWILL123\", \"WorkOut\", \"Fails\"\
    , \"-_-\"]) == \"YameRore.okIWILL123\")\nassert(Strongest_Extension(class_name:\
    \ \"finNNalLLly\", extensions: [\"Die\", \"NowW\", \"Wow\", \"WoW\"]) == \"finNNalLLly.WoW\"\
    )\nassert(Strongest_Extension(class_name: \"_\", extensions: [\"Bb\", \"91245\"\
    ]) == \"_.Bb\")\nassert(Strongest_Extension(class_name: \"Sp\", extensions: [\"\
    671235\", \"Bb\"]) == \"Sp.671235\")"
  status: SyntaxError
  stderr: "/tmp/tmph4ow32he.swift:24:22: error: 'characters' is unavailable: Please\
    \ use String directly\n                        if \"A\"...\"Z\" ~= i.characters.first!\
    \ {\n                                          ^~~~~~~~~~\nSwift.String:5:16:\
    \ note: 'characters' was obsoleted in Swift 5.0\n    public var characters: String\
    \ { get set }\n               ^\n/tmp/tmph4ow32he.swift:34:26: error: value of\
    \ type '[String : Float]' has no member 'sort'\n        let orderedArray = dict.sort{\
    \ $0.0 < $1.0 }\n                           ~~~~ ^~~~\n"
  stdout: ''
  timestamp: 1660009434
- exit_code: 0
  program: "\n/// You will be given the name of a class (a string) and an array of\
    \ extensions.\n/// The extensions are to be used to load additional classes to\
    \ the class. The\n/// strength of the extension is as follows: Let CAP be the\
    \ number of the uppercase\n/// letters in the extension's name, and let SM be\
    \ the number of lowercase letters \n/// in the extension's name, the strength\
    \ is given by the fraction CAP - SM. \n/// You should find the strongest extension\
    \ and return a string in this \n/// format: ClassName.StrongestExtensionName.\n\
    /// If there are two or more extensions with the same strength, you should\n///\
    \ choose the one that comes first in the array.\n/// For example, if you are given\
    \ \"Slices\" as the class and an array of the\n/// extensions: ['SErviNGSliCes',\
    \ 'Cheese', 'StuFfed'] then you should\n/// return 'Slices.SErviNGSliCes' since\
    \ 'SErviNGSliCes' is the strongest extension \n/// (its strength is -1).\n///\
    \ Example:\n/// >>> Strongest_Extension(class_name: \"my_class\", extensions:\
    \ [\"AA\", \"Be\", \"CC\"])\n/// \"my_class.AA\"\nfunc Strongest_Extension(class_name:\
    \ String, extensions: [String]) -> String {\n    // Determine the strongest extension\
    \ name in the array\n    var strongest_name = \"\";\n    var strongest_strength\
    \ = -2;\n    for extension_name in extensions {\n        var letters = 0;\n  \
    \      var uppercase = 0;\n        for char in extension_name {\n            if\
    \ char.isLetter {\n                letters += 1;\n                if char.isUppercase\
    \ {\n                    uppercase += 1;\n                }\n            }\n \
    \       }\n        let strength = uppercase - (letters - uppercase);\n       \
    \ if strength > strongest_strength {\n            strongest_name = extension_name;\n\
    \            strongest_strength = strength;\n        }\n    }\n    // Concatenate\
    \ the class name and the strongest extension name\n    return class_name + \"\
    .\" + strongest_name;\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(Strongest_Extension(class_name:\
    \ \"Watashi\", extensions: [\"tEN\", \"niNE\", \"eIGHt8OKe\"]) == \"Watashi.eIGHt8OKe\"\
    )\nassert(Strongest_Extension(class_name: \"Boku123\", extensions: [\"nani\",\
    \ \"NazeDa\", \"YEs.WeCaNe\", \"32145tggg\"]) == \"Boku123.YEs.WeCaNe\")\nassert(Strongest_Extension(class_name:\
    \ \"__YESIMHERE\", extensions: [\"t\", \"eMptY\", \"nothing\", \"zeR00\", \"NuLl__\"\
    , \"123NoooneB321\"]) == \"__YESIMHERE.NuLl__\")\nassert(Strongest_Extension(class_name:\
    \ \"K\", extensions: [\"Ta\", \"TAR\", \"t234An\", \"cosSo\"]) == \"K.TAR\")\n\
    assert(Strongest_Extension(class_name: \"__HAHA\", extensions: [\"Tab\", \"123\"\
    , \"781345\", \"-_-\"]) == \"__HAHA.123\")\nassert(Strongest_Extension(class_name:\
    \ \"YameRore\", extensions: [\"HhAas\", \"okIWILL123\", \"WorkOut\", \"Fails\"\
    , \"-_-\"]) == \"YameRore.okIWILL123\")\nassert(Strongest_Extension(class_name:\
    \ \"finNNalLLly\", extensions: [\"Die\", \"NowW\", \"Wow\", \"WoW\"]) == \"finNNalLLly.WoW\"\
    )\nassert(Strongest_Extension(class_name: \"_\", extensions: [\"Bb\", \"91245\"\
    ]) == \"_.Bb\")\nassert(Strongest_Extension(class_name: \"Sp\", extensions: [\"\
    671235\", \"Bb\"]) == \"Sp.671235\")"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660009434
- exit_code: 1
  program: "\n/// You will be given the name of a class (a string) and an array of\
    \ extensions.\n/// The extensions are to be used to load additional classes to\
    \ the class. The\n/// strength of the extension is as follows: Let CAP be the\
    \ number of the uppercase\n/// letters in the extension's name, and let SM be\
    \ the number of lowercase letters \n/// in the extension's name, the strength\
    \ is given by the fraction CAP - SM. \n/// You should find the strongest extension\
    \ and return a string in this \n/// format: ClassName.StrongestExtensionName.\n\
    /// If there are two or more extensions with the same strength, you should\n///\
    \ choose the one that comes first in the array.\n/// For example, if you are given\
    \ \"Slices\" as the class and an array of the\n/// extensions: ['SErviNGSliCes',\
    \ 'Cheese', 'StuFfed'] then you should\n/// return 'Slices.SErviNGSliCes' since\
    \ 'SErviNGSliCes' is the strongest extension \n/// (its strength is -1).\n///\
    \ Example:\n/// >>> Strongest_Extension(class_name: \"my_class\", extensions:\
    \ [\"AA\", \"Be\", \"CC\"])\n/// \"my_class.AA\"\nfunc Strongest_Extension(class_name:\
    \ String, extensions: [String]) -> String {\n    let sorted_extensions = extensions.sorted(by:\
    \ { (ext1, ext2) -> Bool in\n        let ext1_strength = calculate_strength(extension_name:\
    \ ext1)\n        let ext2_strength = calculate_strength(extension_name: ext2)\n\
    \        return ext1_strength > ext2_strength\n    })\n    let strongest_extension\
    \ = sorted_extensions.first!\n    return \"\\(class_name).\\(strongest_extension)\"\
    \n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(Strongest_Extension(class_name: \"Watashi\", extensions:\
    \ [\"tEN\", \"niNE\", \"eIGHt8OKe\"]) == \"Watashi.eIGHt8OKe\")\nassert(Strongest_Extension(class_name:\
    \ \"Boku123\", extensions: [\"nani\", \"NazeDa\", \"YEs.WeCaNe\", \"32145tggg\"\
    ]) == \"Boku123.YEs.WeCaNe\")\nassert(Strongest_Extension(class_name: \"__YESIMHERE\"\
    , extensions: [\"t\", \"eMptY\", \"nothing\", \"zeR00\", \"NuLl__\", \"123NoooneB321\"\
    ]) == \"__YESIMHERE.NuLl__\")\nassert(Strongest_Extension(class_name: \"K\", extensions:\
    \ [\"Ta\", \"TAR\", \"t234An\", \"cosSo\"]) == \"K.TAR\")\nassert(Strongest_Extension(class_name:\
    \ \"__HAHA\", extensions: [\"Tab\", \"123\", \"781345\", \"-_-\"]) == \"__HAHA.123\"\
    )\nassert(Strongest_Extension(class_name: \"YameRore\", extensions: [\"HhAas\"\
    , \"okIWILL123\", \"WorkOut\", \"Fails\", \"-_-\"]) == \"YameRore.okIWILL123\"\
    )\nassert(Strongest_Extension(class_name: \"finNNalLLly\", extensions: [\"Die\"\
    , \"NowW\", \"Wow\", \"WoW\"]) == \"finNNalLLly.WoW\")\nassert(Strongest_Extension(class_name:\
    \ \"_\", extensions: [\"Bb\", \"91245\"]) == \"_.Bb\")\nassert(Strongest_Extension(class_name:\
    \ \"Sp\", extensions: [\"671235\", \"Bb\"]) == \"Sp.671235\")"
  status: SyntaxError
  stderr: "/tmp/tmpjebx5fjn.swift:20:29: error: cannot find 'calculate_strength' in\
    \ scope\n        let ext1_strength = calculate_strength(extension_name: ext1)\n\
    \                            ^~~~~~~~~~~~~~~~~~\n/tmp/tmpjebx5fjn.swift:21:29:\
    \ error: cannot find 'calculate_strength' in scope\n        let ext2_strength\
    \ = calculate_strength(extension_name: ext2)\n                            ^~~~~~~~~~~~~~~~~~\n"
  stdout: ''
  timestamp: 1660009434
- exit_code: 1
  program: "\n/// You will be given the name of a class (a string) and an array of\
    \ extensions.\n/// The extensions are to be used to load additional classes to\
    \ the class. The\n/// strength of the extension is as follows: Let CAP be the\
    \ number of the uppercase\n/// letters in the extension's name, and let SM be\
    \ the number of lowercase letters \n/// in the extension's name, the strength\
    \ is given by the fraction CAP - SM. \n/// You should find the strongest extension\
    \ and return a string in this \n/// format: ClassName.StrongestExtensionName.\n\
    /// If there are two or more extensions with the same strength, you should\n///\
    \ choose the one that comes first in the array.\n/// For example, if you are given\
    \ \"Slices\" as the class and an array of the\n/// extensions: ['SErviNGSliCes',\
    \ 'Cheese', 'StuFfed'] then you should\n/// return 'Slices.SErviNGSliCes' since\
    \ 'SErviNGSliCes' is the strongest extension \n/// (its strength is -1).\n///\
    \ Example:\n/// >>> Strongest_Extension(class_name: \"my_class\", extensions:\
    \ [\"AA\", \"Be\", \"CC\"])\n/// \"my_class.AA\"\nfunc Strongest_Extension(class_name:\
    \ String, extensions: [String]) -> String {\n  return class_name + \".\" + extensions.max\
    \ { (a, b) -> Bool in\n    let aStrength = (a.components(separatedBy: CharacterSet.uppercaseLetters).joined()).count\
    \ -\n                    (a.components(separatedBy: CharacterSet.lowercaseLetters).joined()).count\n\
    \    let bStrength = (b.components(separatedBy: CharacterSet.uppercaseLetters).joined()).count\
    \ -\n                    (b.components(separatedBy: CharacterSet.lowercaseLetters).joined()).count\n\
    \    return aStrength < bStrength\n  }!\n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(Strongest_Extension(class_name: \"Watashi\", extensions: [\"tEN\", \"niNE\"\
    , \"eIGHt8OKe\"]) == \"Watashi.eIGHt8OKe\")\nassert(Strongest_Extension(class_name:\
    \ \"Boku123\", extensions: [\"nani\", \"NazeDa\", \"YEs.WeCaNe\", \"32145tggg\"\
    ]) == \"Boku123.YEs.WeCaNe\")\nassert(Strongest_Extension(class_name: \"__YESIMHERE\"\
    , extensions: [\"t\", \"eMptY\", \"nothing\", \"zeR00\", \"NuLl__\", \"123NoooneB321\"\
    ]) == \"__YESIMHERE.NuLl__\")\nassert(Strongest_Extension(class_name: \"K\", extensions:\
    \ [\"Ta\", \"TAR\", \"t234An\", \"cosSo\"]) == \"K.TAR\")\nassert(Strongest_Extension(class_name:\
    \ \"__HAHA\", extensions: [\"Tab\", \"123\", \"781345\", \"-_-\"]) == \"__HAHA.123\"\
    )\nassert(Strongest_Extension(class_name: \"YameRore\", extensions: [\"HhAas\"\
    , \"okIWILL123\", \"WorkOut\", \"Fails\", \"-_-\"]) == \"YameRore.okIWILL123\"\
    )\nassert(Strongest_Extension(class_name: \"finNNalLLly\", extensions: [\"Die\"\
    , \"NowW\", \"Wow\", \"WoW\"]) == \"finNNalLLly.WoW\")\nassert(Strongest_Extension(class_name:\
    \ \"_\", extensions: [\"Bb\", \"91245\"]) == \"_.Bb\")\nassert(Strongest_Extension(class_name:\
    \ \"Sp\", extensions: [\"671235\", \"Bb\"]) == \"Sp.671235\")"
  status: SyntaxError
  stderr: "/tmp/tmpgk74yt5x.swift:20:48: error: cannot find 'CharacterSet' in scope\n\
    \    let aStrength = (a.components(separatedBy: CharacterSet.uppercaseLetters).joined()).count\
    \ -\n                                               ^~~~~~~~~~~~\n/tmp/tmpgk74yt5x.swift:21:48:\
    \ error: cannot find 'CharacterSet' in scope\n                    (a.components(separatedBy:\
    \ CharacterSet.lowercaseLetters).joined()).count\n                           \
    \                    ^~~~~~~~~~~~\n/tmp/tmpgk74yt5x.swift:22:48: error: cannot\
    \ find 'CharacterSet' in scope\n    let bStrength = (b.components(separatedBy:\
    \ CharacterSet.uppercaseLetters).joined()).count -\n                         \
    \                      ^~~~~~~~~~~~\n/tmp/tmpgk74yt5x.swift:23:48: error: cannot\
    \ find 'CharacterSet' in scope\n                    (b.components(separatedBy:\
    \ CharacterSet.lowercaseLetters).joined()).count\n                           \
    \                    ^~~~~~~~~~~~\n"
  stdout: ''
  timestamp: 1660009434
- exit_code: -4
  program: "\n/// You will be given the name of a class (a string) and an array of\
    \ extensions.\n/// The extensions are to be used to load additional classes to\
    \ the class. The\n/// strength of the extension is as follows: Let CAP be the\
    \ number of the uppercase\n/// letters in the extension's name, and let SM be\
    \ the number of lowercase letters \n/// in the extension's name, the strength\
    \ is given by the fraction CAP - SM. \n/// You should find the strongest extension\
    \ and return a string in this \n/// format: ClassName.StrongestExtensionName.\n\
    /// If there are two or more extensions with the same strength, you should\n///\
    \ choose the one that comes first in the array.\n/// For example, if you are given\
    \ \"Slices\" as the class and an array of the\n/// extensions: ['SErviNGSliCes',\
    \ 'Cheese', 'StuFfed'] then you should\n/// return 'Slices.SErviNGSliCes' since\
    \ 'SErviNGSliCes' is the strongest extension \n/// (its strength is -1).\n///\
    \ Example:\n/// >>> Strongest_Extension(class_name: \"my_class\", extensions:\
    \ [\"AA\", \"Be\", \"CC\"])\n/// \"my_class.AA\"\nfunc Strongest_Extension(class_name:\
    \ String, extensions: [String]) -> String {\n    return \"\"\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(Strongest_Extension(class_name: \"Watashi\", extensions:\
    \ [\"tEN\", \"niNE\", \"eIGHt8OKe\"]) == \"Watashi.eIGHt8OKe\")\nassert(Strongest_Extension(class_name:\
    \ \"Boku123\", extensions: [\"nani\", \"NazeDa\", \"YEs.WeCaNe\", \"32145tggg\"\
    ]) == \"Boku123.YEs.WeCaNe\")\nassert(Strongest_Extension(class_name: \"__YESIMHERE\"\
    , extensions: [\"t\", \"eMptY\", \"nothing\", \"zeR00\", \"NuLl__\", \"123NoooneB321\"\
    ]) == \"__YESIMHERE.NuLl__\")\nassert(Strongest_Extension(class_name: \"K\", extensions:\
    \ [\"Ta\", \"TAR\", \"t234An\", \"cosSo\"]) == \"K.TAR\")\nassert(Strongest_Extension(class_name:\
    \ \"__HAHA\", extensions: [\"Tab\", \"123\", \"781345\", \"-_-\"]) == \"__HAHA.123\"\
    )\nassert(Strongest_Extension(class_name: \"YameRore\", extensions: [\"HhAas\"\
    , \"okIWILL123\", \"WorkOut\", \"Fails\", \"-_-\"]) == \"YameRore.okIWILL123\"\
    )\nassert(Strongest_Extension(class_name: \"finNNalLLly\", extensions: [\"Die\"\
    , \"NowW\", \"Wow\", \"WoW\"]) == \"finNNalLLly.WoW\")\nassert(Strongest_Extension(class_name:\
    \ \"_\", extensions: [\"Bb\", \"91245\"]) == \"_.Bb\")\nassert(Strongest_Extension(class_name:\
    \ \"Sp\", extensions: [\"671235\", \"Bb\"]) == \"Sp.671235\")"
  status: Exception
  stderr: 'tmpuhmbxdp4/tmpuhmbxdp4.swift:35: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002abeef348c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002abeef03fb6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002abeef03f988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002abeef03e7b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpuhmbxdp4                        0x0000559ee0d614fd <unavailable> + 5373

    5    libc.so.6                          0x00002abeef534460 __libc_start_main +
    245

    6    tmpuhmbxdp4                        0x0000559ee0d61089 <unavailable> + 4233

    '
  stdout: ''
  timestamp: 1660009431
- exit_code: -4
  program: "\n/// You will be given the name of a class (a string) and an array of\
    \ extensions.\n/// The extensions are to be used to load additional classes to\
    \ the class. The\n/// strength of the extension is as follows: Let CAP be the\
    \ number of the uppercase\n/// letters in the extension's name, and let SM be\
    \ the number of lowercase letters \n/// in the extension's name, the strength\
    \ is given by the fraction CAP - SM. \n/// You should find the strongest extension\
    \ and return a string in this \n/// format: ClassName.StrongestExtensionName.\n\
    /// If there are two or more extensions with the same strength, you should\n///\
    \ choose the one that comes first in the array.\n/// For example, if you are given\
    \ \"Slices\" as the class and an array of the\n/// extensions: ['SErviNGSliCes',\
    \ 'Cheese', 'StuFfed'] then you should\n/// return 'Slices.SErviNGSliCes' since\
    \ 'SErviNGSliCes' is the strongest extension \n/// (its strength is -1).\n///\
    \ Example:\n/// >>> Strongest_Extension(class_name: \"my_class\", extensions:\
    \ [\"AA\", \"Be\", \"CC\"])\n/// \"my_class.AA\"\nfunc Strongest_Extension(class_name:\
    \ String, extensions: [String]) -> String {\n    var strongest = \"\"\n    var\
    \ strength = 0\n    for ext in extensions {\n        let cap = ext.filter{$0.isUppercase}.count\n\
    \        let sm = ext.filter{$0.isLowercase}.count\n        let str = cap - sm\n\
    \        if str > strength {\n            strength = str\n            strongest\
    \ = ext\n        }\n    }\n    return \"\\(class_name).\\(strongest)\"\n}\n\n\n\
    func ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(Strongest_Extension(class_name: \"Watashi\", extensions:\
    \ [\"tEN\", \"niNE\", \"eIGHt8OKe\"]) == \"Watashi.eIGHt8OKe\")\nassert(Strongest_Extension(class_name:\
    \ \"Boku123\", extensions: [\"nani\", \"NazeDa\", \"YEs.WeCaNe\", \"32145tggg\"\
    ]) == \"Boku123.YEs.WeCaNe\")\nassert(Strongest_Extension(class_name: \"__YESIMHERE\"\
    , extensions: [\"t\", \"eMptY\", \"nothing\", \"zeR00\", \"NuLl__\", \"123NoooneB321\"\
    ]) == \"__YESIMHERE.NuLl__\")\nassert(Strongest_Extension(class_name: \"K\", extensions:\
    \ [\"Ta\", \"TAR\", \"t234An\", \"cosSo\"]) == \"K.TAR\")\nassert(Strongest_Extension(class_name:\
    \ \"__HAHA\", extensions: [\"Tab\", \"123\", \"781345\", \"-_-\"]) == \"__HAHA.123\"\
    )\nassert(Strongest_Extension(class_name: \"YameRore\", extensions: [\"HhAas\"\
    , \"okIWILL123\", \"WorkOut\", \"Fails\", \"-_-\"]) == \"YameRore.okIWILL123\"\
    )\nassert(Strongest_Extension(class_name: \"finNNalLLly\", extensions: [\"Die\"\
    , \"NowW\", \"Wow\", \"WoW\"]) == \"finNNalLLly.WoW\")\nassert(Strongest_Extension(class_name:\
    \ \"_\", extensions: [\"Bb\", \"91245\"]) == \"_.Bb\")\nassert(Strongest_Extension(class_name:\
    \ \"Sp\", extensions: [\"671235\", \"Bb\"]) == \"Sp.671235\")"
  status: Exception
  stderr: 'tmpg75nndy6/tmpg75nndy6.swift:48: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b4b85e2ac80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b4b85b21b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b4b85b21988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b4b85b207b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpg75nndy6                        0x000055d34350bf4c <unavailable> + 8012

    5    libc.so.6                          0x00002b4b86016460 __libc_start_main +
    245

    6    tmpg75nndy6                        0x000055d34350b659 <unavailable> + 5721

    '
  stdout: ''
  timestamp: 1660009434
- exit_code: -4
  program: "\n/// You will be given the name of a class (a string) and an array of\
    \ extensions.\n/// The extensions are to be used to load additional classes to\
    \ the class. The\n/// strength of the extension is as follows: Let CAP be the\
    \ number of the uppercase\n/// letters in the extension's name, and let SM be\
    \ the number of lowercase letters \n/// in the extension's name, the strength\
    \ is given by the fraction CAP - SM. \n/// You should find the strongest extension\
    \ and return a string in this \n/// format: ClassName.StrongestExtensionName.\n\
    /// If there are two or more extensions with the same strength, you should\n///\
    \ choose the one that comes first in the array.\n/// For example, if you are given\
    \ \"Slices\" as the class and an array of the\n/// extensions: ['SErviNGSliCes',\
    \ 'Cheese', 'StuFfed'] then you should\n/// return 'Slices.SErviNGSliCes' since\
    \ 'SErviNGSliCes' is the strongest extension \n/// (its strength is -1).\n///\
    \ Example:\n/// >>> Strongest_Extension(class_name: \"my_class\", extensions:\
    \ [\"AA\", \"Be\", \"CC\"])\n/// \"my_class.AA\"\nfunc Strongest_Extension(class_name:\
    \ String, extensions: [String]) -> String {\n    let capital_count = { (string:\
    \ String) -> Int in\n        var counter = 0\n        for letter in string {\n\
    \            let char = String(letter)\n            if char.uppercased() == char\
    \ {\n                counter += 1\n            }\n        }\n        return counter\n\
    \    }\n    let small_count = { (string: String) -> Int in\n        var counter\
    \ = 0\n        for letter in string {\n            let char = String(letter)\n\
    \            if char.lowercased() == char {\n                counter += 1\n  \
    \          }\n        }\n        return counter\n    }\n    var max_strength =\
    \ 0.0\n    var max_strength_class = \"\"\n    for extension_class in extensions\
    \ {\n        let strength = Double(capital_count(extension_class) - small_count(extension_class))\n\
    \        if strength > max_strength {\n            max_strength = strength\n \
    \           max_strength_class = extension_class\n        }\n    }\n    return\
    \ \"\\(class_name).\\(max_strength_class)\"\n}\n\n\nfunc ==(left: [(Int, Int)],\
    \ right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n       \
    \ return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r\
    \ {\n            return false\n        }\n    }\n    return true\n}\n        \
    \    \nassert(Strongest_Extension(class_name: \"Watashi\", extensions: [\"tEN\"\
    , \"niNE\", \"eIGHt8OKe\"]) == \"Watashi.eIGHt8OKe\")\nassert(Strongest_Extension(class_name:\
    \ \"Boku123\", extensions: [\"nani\", \"NazeDa\", \"YEs.WeCaNe\", \"32145tggg\"\
    ]) == \"Boku123.YEs.WeCaNe\")\nassert(Strongest_Extension(class_name: \"__YESIMHERE\"\
    , extensions: [\"t\", \"eMptY\", \"nothing\", \"zeR00\", \"NuLl__\", \"123NoooneB321\"\
    ]) == \"__YESIMHERE.NuLl__\")\nassert(Strongest_Extension(class_name: \"K\", extensions:\
    \ [\"Ta\", \"TAR\", \"t234An\", \"cosSo\"]) == \"K.TAR\")\nassert(Strongest_Extension(class_name:\
    \ \"__HAHA\", extensions: [\"Tab\", \"123\", \"781345\", \"-_-\"]) == \"__HAHA.123\"\
    )\nassert(Strongest_Extension(class_name: \"YameRore\", extensions: [\"HhAas\"\
    , \"okIWILL123\", \"WorkOut\", \"Fails\", \"-_-\"]) == \"YameRore.okIWILL123\"\
    )\nassert(Strongest_Extension(class_name: \"finNNalLLly\", extensions: [\"Die\"\
    , \"NowW\", \"Wow\", \"WoW\"]) == \"finNNalLLly.WoW\")\nassert(Strongest_Extension(class_name:\
    \ \"_\", extensions: [\"Bb\", \"91245\"]) == \"_.Bb\")\nassert(Strongest_Extension(class_name:\
    \ \"Sp\", extensions: [\"671235\", \"Bb\"]) == \"Sp.671235\")"
  status: Exception
  stderr: 'tmpvnzi0t1k/tmpvnzi0t1k.swift:66: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002afa26b4ac80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002afa26841b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002afa26841988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002afa268407b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpvnzi0t1k                        0x0000563766246f5c <unavailable> + 8028

    5    libc.so.6                          0x00002afa26d36460 __libc_start_main +
    245

    6    tmpvnzi0t1k                        0x0000563766246669 <unavailable> + 5737

    '
  stdout: ''
  timestamp: 1660009434
- exit_code: 1
  program: "\n/// You will be given the name of a class (a string) and an array of\
    \ extensions.\n/// The extensions are to be used to load additional classes to\
    \ the class. The\n/// strength of the extension is as follows: Let CAP be the\
    \ number of the uppercase\n/// letters in the extension's name, and let SM be\
    \ the number of lowercase letters \n/// in the extension's name, the strength\
    \ is given by the fraction CAP - SM. \n/// You should find the strongest extension\
    \ and return a string in this \n/// format: ClassName.StrongestExtensionName.\n\
    /// If there are two or more extensions with the same strength, you should\n///\
    \ choose the one that comes first in the array.\n/// For example, if you are given\
    \ \"Slices\" as the class and an array of the\n/// extensions: ['SErviNGSliCes',\
    \ 'Cheese', 'StuFfed'] then you should\n/// return 'Slices.SErviNGSliCes' since\
    \ 'SErviNGSliCes' is the strongest extension \n/// (its strength is -1).\n///\
    \ Example:\n/// >>> Strongest_Extension(class_name: \"my_class\", extensions:\
    \ [\"AA\", \"Be\", \"CC\"])\n/// \"my_class.AA\"\nfunc Strongest_Extension(class_name:\
    \ String, extensions: [String]) -> String {\n    // Write your solution below.\n\
    \    var max_string: String = \"\";\n    var max_strength: Double = -1;\n    for\
    \ extension_name in extensions {\n        let strength = get_strength(str: extension_name);\n\
    \        if strength > max_strength {\n            max_strength = strength;\n\
    \            max_string = extension_name;\n        }\n    }\n    return class_name\
    \ + \".\" + max_string;\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(Strongest_Extension(class_name:\
    \ \"Watashi\", extensions: [\"tEN\", \"niNE\", \"eIGHt8OKe\"]) == \"Watashi.eIGHt8OKe\"\
    )\nassert(Strongest_Extension(class_name: \"Boku123\", extensions: [\"nani\",\
    \ \"NazeDa\", \"YEs.WeCaNe\", \"32145tggg\"]) == \"Boku123.YEs.WeCaNe\")\nassert(Strongest_Extension(class_name:\
    \ \"__YESIMHERE\", extensions: [\"t\", \"eMptY\", \"nothing\", \"zeR00\", \"NuLl__\"\
    , \"123NoooneB321\"]) == \"__YESIMHERE.NuLl__\")\nassert(Strongest_Extension(class_name:\
    \ \"K\", extensions: [\"Ta\", \"TAR\", \"t234An\", \"cosSo\"]) == \"K.TAR\")\n\
    assert(Strongest_Extension(class_name: \"__HAHA\", extensions: [\"Tab\", \"123\"\
    , \"781345\", \"-_-\"]) == \"__HAHA.123\")\nassert(Strongest_Extension(class_name:\
    \ \"YameRore\", extensions: [\"HhAas\", \"okIWILL123\", \"WorkOut\", \"Fails\"\
    , \"-_-\"]) == \"YameRore.okIWILL123\")\nassert(Strongest_Extension(class_name:\
    \ \"finNNalLLly\", extensions: [\"Die\", \"NowW\", \"Wow\", \"WoW\"]) == \"finNNalLLly.WoW\"\
    )\nassert(Strongest_Extension(class_name: \"_\", extensions: [\"Bb\", \"91245\"\
    ]) == \"_.Bb\")\nassert(Strongest_Extension(class_name: \"Sp\", extensions: [\"\
    671235\", \"Bb\"]) == \"Sp.671235\")"
  status: SyntaxError
  stderr: "/tmp/tmpauha4a5v.swift:23:24: error: cannot find 'get_strength' in scope\n\
    \        let strength = get_strength(str: extension_name);\n                 \
    \      ^~~~~~~~~~~~\n"
  stdout: ''
  timestamp: 1660009434
- exit_code: -4
  program: "\n/// You will be given the name of a class (a string) and an array of\
    \ extensions.\n/// The extensions are to be used to load additional classes to\
    \ the class. The\n/// strength of the extension is as follows: Let CAP be the\
    \ number of the uppercase\n/// letters in the extension's name, and let SM be\
    \ the number of lowercase letters \n/// in the extension's name, the strength\
    \ is given by the fraction CAP - SM. \n/// You should find the strongest extension\
    \ and return a string in this \n/// format: ClassName.StrongestExtensionName.\n\
    /// If there are two or more extensions with the same strength, you should\n///\
    \ choose the one that comes first in the array.\n/// For example, if you are given\
    \ \"Slices\" as the class and an array of the\n/// extensions: ['SErviNGSliCes',\
    \ 'Cheese', 'StuFfed'] then you should\n/// return 'Slices.SErviNGSliCes' since\
    \ 'SErviNGSliCes' is the strongest extension \n/// (its strength is -1).\n///\
    \ Example:\n/// >>> Strongest_Extension(class_name: \"my_class\", extensions:\
    \ [\"AA\", \"Be\", \"CC\"])\n/// \"my_class.AA\"\nfunc Strongest_Extension(class_name:\
    \ String, extensions: [String]) -> String {\n    return \"\"\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(Strongest_Extension(class_name: \"Watashi\", extensions:\
    \ [\"tEN\", \"niNE\", \"eIGHt8OKe\"]) == \"Watashi.eIGHt8OKe\")\nassert(Strongest_Extension(class_name:\
    \ \"Boku123\", extensions: [\"nani\", \"NazeDa\", \"YEs.WeCaNe\", \"32145tggg\"\
    ]) == \"Boku123.YEs.WeCaNe\")\nassert(Strongest_Extension(class_name: \"__YESIMHERE\"\
    , extensions: [\"t\", \"eMptY\", \"nothing\", \"zeR00\", \"NuLl__\", \"123NoooneB321\"\
    ]) == \"__YESIMHERE.NuLl__\")\nassert(Strongest_Extension(class_name: \"K\", extensions:\
    \ [\"Ta\", \"TAR\", \"t234An\", \"cosSo\"]) == \"K.TAR\")\nassert(Strongest_Extension(class_name:\
    \ \"__HAHA\", extensions: [\"Tab\", \"123\", \"781345\", \"-_-\"]) == \"__HAHA.123\"\
    )\nassert(Strongest_Extension(class_name: \"YameRore\", extensions: [\"HhAas\"\
    , \"okIWILL123\", \"WorkOut\", \"Fails\", \"-_-\"]) == \"YameRore.okIWILL123\"\
    )\nassert(Strongest_Extension(class_name: \"finNNalLLly\", extensions: [\"Die\"\
    , \"NowW\", \"Wow\", \"WoW\"]) == \"finNNalLLly.WoW\")\nassert(Strongest_Extension(class_name:\
    \ \"_\", extensions: [\"Bb\", \"91245\"]) == \"_.Bb\")\nassert(Strongest_Extension(class_name:\
    \ \"Sp\", extensions: [\"671235\", \"Bb\"]) == \"Sp.671235\")"
  status: Exception
  stderr: 'tmpuhmbxdp4/tmpuhmbxdp4.swift:35: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002abeef348c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002abeef03fb6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002abeef03f988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002abeef03e7b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpuhmbxdp4                        0x0000559ee0d614fd <unavailable> + 5373

    5    libc.so.6                          0x00002abeef534460 __libc_start_main +
    245

    6    tmpuhmbxdp4                        0x0000559ee0d61089 <unavailable> + 4233

    '
  stdout: ''
  timestamp: 1660009431
- exit_code: -4
  program: "\n/// You will be given the name of a class (a string) and an array of\
    \ extensions.\n/// The extensions are to be used to load additional classes to\
    \ the class. The\n/// strength of the extension is as follows: Let CAP be the\
    \ number of the uppercase\n/// letters in the extension's name, and let SM be\
    \ the number of lowercase letters \n/// in the extension's name, the strength\
    \ is given by the fraction CAP - SM. \n/// You should find the strongest extension\
    \ and return a string in this \n/// format: ClassName.StrongestExtensionName.\n\
    /// If there are two or more extensions with the same strength, you should\n///\
    \ choose the one that comes first in the array.\n/// For example, if you are given\
    \ \"Slices\" as the class and an array of the\n/// extensions: ['SErviNGSliCes',\
    \ 'Cheese', 'StuFfed'] then you should\n/// return 'Slices.SErviNGSliCes' since\
    \ 'SErviNGSliCes' is the strongest extension \n/// (its strength is -1).\n///\
    \ Example:\n/// >>> Strongest_Extension(class_name: \"my_class\", extensions:\
    \ [\"AA\", \"Be\", \"CC\"])\n/// \"my_class.AA\"\nfunc Strongest_Extension(class_name:\
    \ String, extensions: [String]) -> String {\n    var strongest_extension: String\
    \ = \"\"\n    var strongest_extension_strength: Double = 0.0\n    for extension_name\
    \ in extensions {\n        var uppercase_letters_count: Int = 0\n        var lowercase_letters_count:\
    \ Int = 0\n        for letter in extension_name {\n            if letter.isUppercase\
    \ {\n                uppercase_letters_count += 1\n            } else if letter.isLowercase\
    \ {\n                lowercase_letters_count += 1\n            }\n        }\n\
    \        let extension_strength: Double = Double(uppercase_letters_count) - Double(lowercase_letters_count)\n\
    \        if extension_strength > strongest_extension_strength {\n            strongest_extension_strength\
    \ = extension_strength\n            strongest_extension = extension_name\n   \
    \     }\n    }\n    return class_name + \".\" + strongest_extension\n}\n\n\nfunc\
    \ ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count !=\
    \ right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(Strongest_Extension(class_name: \"Watashi\", extensions:\
    \ [\"tEN\", \"niNE\", \"eIGHt8OKe\"]) == \"Watashi.eIGHt8OKe\")\nassert(Strongest_Extension(class_name:\
    \ \"Boku123\", extensions: [\"nani\", \"NazeDa\", \"YEs.WeCaNe\", \"32145tggg\"\
    ]) == \"Boku123.YEs.WeCaNe\")\nassert(Strongest_Extension(class_name: \"__YESIMHERE\"\
    , extensions: [\"t\", \"eMptY\", \"nothing\", \"zeR00\", \"NuLl__\", \"123NoooneB321\"\
    ]) == \"__YESIMHERE.NuLl__\")\nassert(Strongest_Extension(class_name: \"K\", extensions:\
    \ [\"Ta\", \"TAR\", \"t234An\", \"cosSo\"]) == \"K.TAR\")\nassert(Strongest_Extension(class_name:\
    \ \"__HAHA\", extensions: [\"Tab\", \"123\", \"781345\", \"-_-\"]) == \"__HAHA.123\"\
    )\nassert(Strongest_Extension(class_name: \"YameRore\", extensions: [\"HhAas\"\
    , \"okIWILL123\", \"WorkOut\", \"Fails\", \"-_-\"]) == \"YameRore.okIWILL123\"\
    )\nassert(Strongest_Extension(class_name: \"finNNalLLly\", extensions: [\"Die\"\
    , \"NowW\", \"Wow\", \"WoW\"]) == \"finNNalLLly.WoW\")\nassert(Strongest_Extension(class_name:\
    \ \"_\", extensions: [\"Bb\", \"91245\"]) == \"_.Bb\")\nassert(Strongest_Extension(class_name:\
    \ \"Sp\", extensions: [\"671235\", \"Bb\"]) == \"Sp.671235\")"
  status: Exception
  stderr: 'tmp5nts4jp9/tmp5nts4jp9.swift:55: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b1d07bf8c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b1d078efb6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b1d078ef988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b1d078ee7b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmp5nts4jp9                        0x0000563fa4aa2c9c <unavailable> + 7324

    5    libc.so.6                          0x00002b1d07de4460 __libc_start_main +
    245

    6    tmp5nts4jp9                        0x0000563fa4aa23a9 <unavailable> + 5033

    '
  stdout: ''
  timestamp: 1660009434
- exit_code: 1
  program: "\n/// You will be given the name of a class (a string) and an array of\
    \ extensions.\n/// The extensions are to be used to load additional classes to\
    \ the class. The\n/// strength of the extension is as follows: Let CAP be the\
    \ number of the uppercase\n/// letters in the extension's name, and let SM be\
    \ the number of lowercase letters \n/// in the extension's name, the strength\
    \ is given by the fraction CAP - SM. \n/// You should find the strongest extension\
    \ and return a string in this \n/// format: ClassName.StrongestExtensionName.\n\
    /// If there are two or more extensions with the same strength, you should\n///\
    \ choose the one that comes first in the array.\n/// For example, if you are given\
    \ \"Slices\" as the class and an array of the\n/// extensions: ['SErviNGSliCes',\
    \ 'Cheese', 'StuFfed'] then you should\n/// return 'Slices.SErviNGSliCes' since\
    \ 'SErviNGSliCes' is the strongest extension \n/// (its strength is -1).\n///\
    \ Example:\n/// >>> Strongest_Extension(class_name: \"my_class\", extensions:\
    \ [\"AA\", \"Be\", \"CC\"])\n/// \"my_class.AA\"\nfunc Strongest_Extension(class_name:\
    \ String, extensions: [String]) -> String {\n    let capRegEx = \"([A-Z])\"\n\
    \    let smRegEx = \"([a-z])\"\n    var strongestExtension: String = \"\"\n  \
    \  var strongestStrength: Double = 0.0\n    for extensionName in extensions {\n\
    \        let capCharacters = matches(for: capRegEx, in: extensionName)\n     \
    \   let smCharacters = matches(for: smRegEx, in: extensionName)\n        let cap\
    \ = Double(capCharacters.count)\n        let sm = Double(smCharacters.count)\n\
    \        let strength = cap - sm\n        if strength > strongestStrength {\n\
    \            strongestStrength = strength\n            strongestExtension = extensionName\n\
    \        }\n    }\n    return class_name + \".\" + strongestExtension\n}\n\n\n\
    func ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(Strongest_Extension(class_name: \"Watashi\", extensions:\
    \ [\"tEN\", \"niNE\", \"eIGHt8OKe\"]) == \"Watashi.eIGHt8OKe\")\nassert(Strongest_Extension(class_name:\
    \ \"Boku123\", extensions: [\"nani\", \"NazeDa\", \"YEs.WeCaNe\", \"32145tggg\"\
    ]) == \"Boku123.YEs.WeCaNe\")\nassert(Strongest_Extension(class_name: \"__YESIMHERE\"\
    , extensions: [\"t\", \"eMptY\", \"nothing\", \"zeR00\", \"NuLl__\", \"123NoooneB321\"\
    ]) == \"__YESIMHERE.NuLl__\")\nassert(Strongest_Extension(class_name: \"K\", extensions:\
    \ [\"Ta\", \"TAR\", \"t234An\", \"cosSo\"]) == \"K.TAR\")\nassert(Strongest_Extension(class_name:\
    \ \"__HAHA\", extensions: [\"Tab\", \"123\", \"781345\", \"-_-\"]) == \"__HAHA.123\"\
    )\nassert(Strongest_Extension(class_name: \"YameRore\", extensions: [\"HhAas\"\
    , \"okIWILL123\", \"WorkOut\", \"Fails\", \"-_-\"]) == \"YameRore.okIWILL123\"\
    )\nassert(Strongest_Extension(class_name: \"finNNalLLly\", extensions: [\"Die\"\
    , \"NowW\", \"Wow\", \"WoW\"]) == \"finNNalLLly.WoW\")\nassert(Strongest_Extension(class_name:\
    \ \"_\", extensions: [\"Bb\", \"91245\"]) == \"_.Bb\")\nassert(Strongest_Extension(class_name:\
    \ \"Sp\", extensions: [\"671235\", \"Bb\"]) == \"Sp.671235\")"
  status: SyntaxError
  stderr: "/tmp/tmppjjwnaeu.swift:24:29: error: cannot find 'matches' in scope\n \
    \       let capCharacters = matches(for: capRegEx, in: extensionName)\n      \
    \                      ^~~~~~~\n/tmp/tmppjjwnaeu.swift:25:28: error: cannot find\
    \ 'matches' in scope\n        let smCharacters = matches(for: smRegEx, in: extensionName)\n\
    \                           ^~~~~~~\n"
  stdout: ''
  timestamp: 1660009434
- exit_code: 1
  program: "\n/// You will be given the name of a class (a string) and an array of\
    \ extensions.\n/// The extensions are to be used to load additional classes to\
    \ the class. The\n/// strength of the extension is as follows: Let CAP be the\
    \ number of the uppercase\n/// letters in the extension's name, and let SM be\
    \ the number of lowercase letters \n/// in the extension's name, the strength\
    \ is given by the fraction CAP - SM. \n/// You should find the strongest extension\
    \ and return a string in this \n/// format: ClassName.StrongestExtensionName.\n\
    /// If there are two or more extensions with the same strength, you should\n///\
    \ choose the one that comes first in the array.\n/// For example, if you are given\
    \ \"Slices\" as the class and an array of the\n/// extensions: ['SErviNGSliCes',\
    \ 'Cheese', 'StuFfed'] then you should\n/// return 'Slices.SErviNGSliCes' since\
    \ 'SErviNGSliCes' is the strongest extension \n/// (its strength is -1).\n///\
    \ Example:\n/// >>> Strongest_Extension(class_name: \"my_class\", extensions:\
    \ [\"AA\", \"Be\", \"CC\"])\n/// \"my_class.AA\"\nfunc Strongest_Extension(class_name:\
    \ String, extensions: [String]) -> String {\n    var best_extension = \"\"\n \
    \   var best_strength = 0.0\n    var cap = 0\n    var sm = 0\n    var strength\
    \ = 0.0\n    for extension in extensions {\n        cap = 0\n        sm = 0\n\
    \        for letter in extension {\n            if letter >= \"A\" && letter <=\
    \ \"Z\" {\n                cap += 1\n            } else if letter >= \"a\" &&\
    \ letter <= \"z\" {\n                sm += 1\n            }\n        }\n     \
    \   strength = Double(cap) - Double(sm)\n        if strength > best_strength {\n\
    \            best_strength = strength\n            best_extension = extension\n\
    \        }\n    }\n    return \"\\(class_name).\\(best_extension)\"\n}\n\n\nfunc\
    \ ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count !=\
    \ right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(Strongest_Extension(class_name: \"Watashi\", extensions:\
    \ [\"tEN\", \"niNE\", \"eIGHt8OKe\"]) == \"Watashi.eIGHt8OKe\")\nassert(Strongest_Extension(class_name:\
    \ \"Boku123\", extensions: [\"nani\", \"NazeDa\", \"YEs.WeCaNe\", \"32145tggg\"\
    ]) == \"Boku123.YEs.WeCaNe\")\nassert(Strongest_Extension(class_name: \"__YESIMHERE\"\
    , extensions: [\"t\", \"eMptY\", \"nothing\", \"zeR00\", \"NuLl__\", \"123NoooneB321\"\
    ]) == \"__YESIMHERE.NuLl__\")\nassert(Strongest_Extension(class_name: \"K\", extensions:\
    \ [\"Ta\", \"TAR\", \"t234An\", \"cosSo\"]) == \"K.TAR\")\nassert(Strongest_Extension(class_name:\
    \ \"__HAHA\", extensions: [\"Tab\", \"123\", \"781345\", \"-_-\"]) == \"__HAHA.123\"\
    )\nassert(Strongest_Extension(class_name: \"YameRore\", extensions: [\"HhAas\"\
    , \"okIWILL123\", \"WorkOut\", \"Fails\", \"-_-\"]) == \"YameRore.okIWILL123\"\
    )\nassert(Strongest_Extension(class_name: \"finNNalLLly\", extensions: [\"Die\"\
    , \"NowW\", \"Wow\", \"WoW\"]) == \"finNNalLLly.WoW\")\nassert(Strongest_Extension(class_name:\
    \ \"_\", extensions: [\"Bb\", \"91245\"]) == \"_.Bb\")\nassert(Strongest_Extension(class_name:\
    \ \"Sp\", extensions: [\"671235\", \"Bb\"]) == \"Sp.671235\")"
  status: SyntaxError
  stderr: "/tmp/tmpqwi36kmh.swift:24:9: error: expected pattern\n    for extension\
    \ in extensions {\n        ^\n/tmp/tmpqwi36kmh.swift:24:9: error: expected Sequence\
    \ expression for for-each loop\n    for extension in extensions {\n        ^\n\
    /tmp/tmpqwi36kmh.swift:24:9: error: expected '{' to start the body of for-each\
    \ loop\n    for extension in extensions {\n        ^\n/tmp/tmpqwi36kmh.swift:27:23:\
    \ error: expected Sequence expression for for-each loop\n        for letter in\
    \ extension {\n                      ^\n/tmp/tmpqwi36kmh.swift:27:23: error: expected\
    \ '{' to start the body of for-each loop\n        for letter in extension {\n\
    \                      ^\n/tmp/tmpqwi36kmh.swift:37:30: error: expected expression\
    \ in assignment\n            best_extension = extension\n                    \
    \         ^\n/tmp/tmpqwi36kmh.swift:38:9: error: expected type name in extension\
    \ declaration\n        }\n        ^\n/tmp/tmpqwi36kmh.swift:37:39: error: expected\
    \ '{' in extension\n            best_extension = extension\n                 \
    \                     ^\n/tmp/tmpqwi36kmh.swift:37:30: error: declaration is only\
    \ valid at file scope\n            best_extension = extension\n              \
    \               ^\n"
  stdout: ''
  timestamp: 1660009434
- exit_code: -4
  program: "\n/// You will be given the name of a class (a string) and an array of\
    \ extensions.\n/// The extensions are to be used to load additional classes to\
    \ the class. The\n/// strength of the extension is as follows: Let CAP be the\
    \ number of the uppercase\n/// letters in the extension's name, and let SM be\
    \ the number of lowercase letters \n/// in the extension's name, the strength\
    \ is given by the fraction CAP - SM. \n/// You should find the strongest extension\
    \ and return a string in this \n/// format: ClassName.StrongestExtensionName.\n\
    /// If there are two or more extensions with the same strength, you should\n///\
    \ choose the one that comes first in the array.\n/// For example, if you are given\
    \ \"Slices\" as the class and an array of the\n/// extensions: ['SErviNGSliCes',\
    \ 'Cheese', 'StuFfed'] then you should\n/// return 'Slices.SErviNGSliCes' since\
    \ 'SErviNGSliCes' is the strongest extension \n/// (its strength is -1).\n///\
    \ Example:\n/// >>> Strongest_Extension(class_name: \"my_class\", extensions:\
    \ [\"AA\", \"Be\", \"CC\"])\n/// \"my_class.AA\"\nfunc Strongest_Extension(class_name:\
    \ String, extensions: [String]) -> String {\n    var strongest: String = \"\"\n\
    \    var strongestStrength: Double = 0\n    for ext in extensions {\n        var\
    \ caps: Int = 0\n        var smal: Int = 0\n        for c in ext {\n         \
    \   if c.isUppercase {\n                caps += 1\n            } else {\n    \
    \            smal += 1\n            }\n        }\n        if strongestStrength\
    \ == 0 || (Double(caps) - Double(smal)) > strongestStrength {\n            strongestStrength\
    \ = Double(caps) - Double(smal)\n            strongest = ext\n        }\n    }\n\
    \    return \"\\(class_name).\\(strongest)\"\n}\n\n\nfunc ==(left: [(Int, Int)],\
    \ right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n       \
    \ return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r\
    \ {\n            return false\n        }\n    }\n    return true\n}\n        \
    \    \nassert(Strongest_Extension(class_name: \"Watashi\", extensions: [\"tEN\"\
    , \"niNE\", \"eIGHt8OKe\"]) == \"Watashi.eIGHt8OKe\")\nassert(Strongest_Extension(class_name:\
    \ \"Boku123\", extensions: [\"nani\", \"NazeDa\", \"YEs.WeCaNe\", \"32145tggg\"\
    ]) == \"Boku123.YEs.WeCaNe\")\nassert(Strongest_Extension(class_name: \"__YESIMHERE\"\
    , extensions: [\"t\", \"eMptY\", \"nothing\", \"zeR00\", \"NuLl__\", \"123NoooneB321\"\
    ]) == \"__YESIMHERE.NuLl__\")\nassert(Strongest_Extension(class_name: \"K\", extensions:\
    \ [\"Ta\", \"TAR\", \"t234An\", \"cosSo\"]) == \"K.TAR\")\nassert(Strongest_Extension(class_name:\
    \ \"__HAHA\", extensions: [\"Tab\", \"123\", \"781345\", \"-_-\"]) == \"__HAHA.123\"\
    )\nassert(Strongest_Extension(class_name: \"YameRore\", extensions: [\"HhAas\"\
    , \"okIWILL123\", \"WorkOut\", \"Fails\", \"-_-\"]) == \"YameRore.okIWILL123\"\
    )\nassert(Strongest_Extension(class_name: \"finNNalLLly\", extensions: [\"Die\"\
    , \"NowW\", \"Wow\", \"WoW\"]) == \"finNNalLLly.WoW\")\nassert(Strongest_Extension(class_name:\
    \ \"_\", extensions: [\"Bb\", \"91245\"]) == \"_.Bb\")\nassert(Strongest_Extension(class_name:\
    \ \"Sp\", extensions: [\"671235\", \"Bb\"]) == \"Sp.671235\")"
  status: Exception
  stderr: 'tmpuqah4tzm/tmpuqah4tzm.swift:52: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b432920cc80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b4328f03b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b4328f03988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b4328f027b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpuqah4tzm                        0x0000555c71d10a3d <unavailable> + 6717

    5    libc.so.6                          0x00002b43293f8460 __libc_start_main +
    245

    6    tmpuqah4tzm                        0x0000555c71d105c9 <unavailable> + 5577

    '
  stdout: ''
  timestamp: 1660009434
- exit_code: 1
  program: "\n/// You will be given the name of a class (a string) and an array of\
    \ extensions.\n/// The extensions are to be used to load additional classes to\
    \ the class. The\n/// strength of the extension is as follows: Let CAP be the\
    \ number of the uppercase\n/// letters in the extension's name, and let SM be\
    \ the number of lowercase letters \n/// in the extension's name, the strength\
    \ is given by the fraction CAP - SM. \n/// You should find the strongest extension\
    \ and return a string in this \n/// format: ClassName.StrongestExtensionName.\n\
    /// If there are two or more extensions with the same strength, you should\n///\
    \ choose the one that comes first in the array.\n/// For example, if you are given\
    \ \"Slices\" as the class and an array of the\n/// extensions: ['SErviNGSliCes',\
    \ 'Cheese', 'StuFfed'] then you should\n/// return 'Slices.SErviNGSliCes' since\
    \ 'SErviNGSliCes' is the strongest extension \n/// (its strength is -1).\n///\
    \ Example:\n/// >>> Strongest_Extension(class_name: \"my_class\", extensions:\
    \ [\"AA\", \"Be\", \"CC\"])\n/// \"my_class.AA\"\nfunc Strongest_Extension(class_name:\
    \ String, extensions: [String]) -> String {\n    var strongest_extension = extensions[0]\n\
    \    for index in 1..<extensions.count {\n        if strength(extension_name:\
    \ extensions[index]) > strength(extension_name: strongest_extension) {\n     \
    \       strongest_extension = extensions[index]\n        }\n    }\n    return\
    \ \"\\(class_name).\\(strongest_extension)\"\n}\n\n\nfunc ==(left: [(Int, Int)],\
    \ right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n       \
    \ return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r\
    \ {\n            return false\n        }\n    }\n    return true\n}\n        \
    \    \nassert(Strongest_Extension(class_name: \"Watashi\", extensions: [\"tEN\"\
    , \"niNE\", \"eIGHt8OKe\"]) == \"Watashi.eIGHt8OKe\")\nassert(Strongest_Extension(class_name:\
    \ \"Boku123\", extensions: [\"nani\", \"NazeDa\", \"YEs.WeCaNe\", \"32145tggg\"\
    ]) == \"Boku123.YEs.WeCaNe\")\nassert(Strongest_Extension(class_name: \"__YESIMHERE\"\
    , extensions: [\"t\", \"eMptY\", \"nothing\", \"zeR00\", \"NuLl__\", \"123NoooneB321\"\
    ]) == \"__YESIMHERE.NuLl__\")\nassert(Strongest_Extension(class_name: \"K\", extensions:\
    \ [\"Ta\", \"TAR\", \"t234An\", \"cosSo\"]) == \"K.TAR\")\nassert(Strongest_Extension(class_name:\
    \ \"__HAHA\", extensions: [\"Tab\", \"123\", \"781345\", \"-_-\"]) == \"__HAHA.123\"\
    )\nassert(Strongest_Extension(class_name: \"YameRore\", extensions: [\"HhAas\"\
    , \"okIWILL123\", \"WorkOut\", \"Fails\", \"-_-\"]) == \"YameRore.okIWILL123\"\
    )\nassert(Strongest_Extension(class_name: \"finNNalLLly\", extensions: [\"Die\"\
    , \"NowW\", \"Wow\", \"WoW\"]) == \"finNNalLLly.WoW\")\nassert(Strongest_Extension(class_name:\
    \ \"_\", extensions: [\"Bb\", \"91245\"]) == \"_.Bb\")\nassert(Strongest_Extension(class_name:\
    \ \"Sp\", extensions: [\"671235\", \"Bb\"]) == \"Sp.671235\")"
  status: SyntaxError
  stderr: "/tmp/tmpuy88k23_.swift:21:12: error: cannot find 'strength' in scope\n\
    \        if strength(extension_name: extensions[index]) > strength(extension_name:\
    \ strongest_extension) {\n           ^~~~~~~~\n/tmp/tmpuy88k23_.swift:21:58: error:\
    \ cannot find 'strength' in scope\n        if strength(extension_name: extensions[index])\
    \ > strength(extension_name: strongest_extension) {\n                        \
    \                                 ^~~~~~~~\n"
  stdout: ''
  timestamp: 1660009434
- exit_code: 1
  program: "\n/// You will be given the name of a class (a string) and an array of\
    \ extensions.\n/// The extensions are to be used to load additional classes to\
    \ the class. The\n/// strength of the extension is as follows: Let CAP be the\
    \ number of the uppercase\n/// letters in the extension's name, and let SM be\
    \ the number of lowercase letters \n/// in the extension's name, the strength\
    \ is given by the fraction CAP - SM. \n/// You should find the strongest extension\
    \ and return a string in this \n/// format: ClassName.StrongestExtensionName.\n\
    /// If there are two or more extensions with the same strength, you should\n///\
    \ choose the one that comes first in the array.\n/// For example, if you are given\
    \ \"Slices\" as the class and an array of the\n/// extensions: ['SErviNGSliCes',\
    \ 'Cheese', 'StuFfed'] then you should\n/// return 'Slices.SErviNGSliCes' since\
    \ 'SErviNGSliCes' is the strongest extension \n/// (its strength is -1).\n///\
    \ Example:\n/// >>> Strongest_Extension(class_name: \"my_class\", extensions:\
    \ [\"AA\", \"Be\", \"CC\"])\n/// \"my_class.AA\"\nfunc Strongest_Extension(class_name:\
    \ String, extensions: [String]) -> String {\n    // Enter your code between the\
    \ two comment markers\n    let class_name = \"my_class\"\n    let extensions =\
    \ [\"AA\", \"Be\", \"CC\"]\n    let strengthArray = extensions.map { (extension)\
    \ -> (String, Double) in\n        let upperArray = Array(extension.uppercased().characters)\n\
    \        let lowerArray = Array(extension.lowercased().characters)\n        let\
    \ upperCount = upperArray.reduce(0, { $0 + ($1 >= \"A\" && $1 <= \"Z\" ? 1 : 0)\
    \ })\n        let lowerCount = lowerArray.reduce(0, { $0 + ($1 >= \"a\" && $1\
    \ <= \"z\" ? 1 : 0) })\n        return (extension, Double(upperCount - lowerCount))\n\
    \    }\n    let result = strengthArray.sorted { $0.1 < $1.1 }.last!.0\n    return\
    \ \"\\(class_name).\\(result)\"\n    // End code\n}\n\n\nfunc ==(left: [(Int,\
    \ Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n\
    \        return false\n    }\n    for (l, r) in zip(left, right) {\n        if\
    \ l != r {\n            return false\n        }\n    }\n    return true\n}\n \
    \           \nassert(Strongest_Extension(class_name: \"Watashi\", extensions:\
    \ [\"tEN\", \"niNE\", \"eIGHt8OKe\"]) == \"Watashi.eIGHt8OKe\")\nassert(Strongest_Extension(class_name:\
    \ \"Boku123\", extensions: [\"nani\", \"NazeDa\", \"YEs.WeCaNe\", \"32145tggg\"\
    ]) == \"Boku123.YEs.WeCaNe\")\nassert(Strongest_Extension(class_name: \"__YESIMHERE\"\
    , extensions: [\"t\", \"eMptY\", \"nothing\", \"zeR00\", \"NuLl__\", \"123NoooneB321\"\
    ]) == \"__YESIMHERE.NuLl__\")\nassert(Strongest_Extension(class_name: \"K\", extensions:\
    \ [\"Ta\", \"TAR\", \"t234An\", \"cosSo\"]) == \"K.TAR\")\nassert(Strongest_Extension(class_name:\
    \ \"__HAHA\", extensions: [\"Tab\", \"123\", \"781345\", \"-_-\"]) == \"__HAHA.123\"\
    )\nassert(Strongest_Extension(class_name: \"YameRore\", extensions: [\"HhAas\"\
    , \"okIWILL123\", \"WorkOut\", \"Fails\", \"-_-\"]) == \"YameRore.okIWILL123\"\
    )\nassert(Strongest_Extension(class_name: \"finNNalLLly\", extensions: [\"Die\"\
    , \"NowW\", \"Wow\", \"WoW\"]) == \"finNNalLLly.WoW\")\nassert(Strongest_Extension(class_name:\
    \ \"_\", extensions: [\"Bb\", \"91245\"]) == \"_.Bb\")\nassert(Strongest_Extension(class_name:\
    \ \"Sp\", extensions: [\"671235\", \"Bb\"]) == \"Sp.671235\")"
  status: SyntaxError
  stderr: "/tmp/tmpt991i94u.swift:23:32: error: expected expression in list of expressions\n\
    \        let upperArray = Array(extension.uppercased().characters)\n         \
    \                      ^\n/tmp/tmpt991i94u.swift:23:32: error: consecutive statements\
    \ on a line must be separated by ';'\n        let upperArray = Array(extension.uppercased().characters)\n\
    \                               ^\n                               ;\n/tmp/tmpt991i94u.swift:23:41:\
    \ error: expected type name in extension declaration\n        let upperArray =\
    \ Array(extension.uppercased().characters)\n                                 \
    \       ^\n/tmp/tmpt991i94u.swift:23:41: error: expected '{' in extension\n  \
    \      let upperArray = Array(extension.uppercased().characters)\n           \
    \                             ^\n/tmp/tmpt991i94u.swift:23:32: error: declaration\
    \ is only valid at file scope\n        let upperArray = Array(extension.uppercased().characters)\n\
    \                               ^\n/tmp/tmpt991i94u.swift:24:32: error: expected\
    \ expression in list of expressions\n        let lowerArray = Array(extension.lowercased().characters)\n\
    \                               ^\n/tmp/tmpt991i94u.swift:24:32: error: consecutive\
    \ statements on a line must be separated by ';'\n        let lowerArray = Array(extension.lowercased().characters)\n\
    \                               ^\n                               ;\n/tmp/tmpt991i94u.swift:24:41:\
    \ error: expected type name in extension declaration\n        let lowerArray =\
    \ Array(extension.lowercased().characters)\n                                 \
    \       ^\n/tmp/tmpt991i94u.swift:24:41: error: expected '{' in extension\n  \
    \      let lowerArray = Array(extension.lowercased().characters)\n           \
    \                             ^\n/tmp/tmpt991i94u.swift:24:32: error: declaration\
    \ is only valid at file scope\n        let lowerArray = Array(extension.lowercased().characters)\n\
    \                               ^\n/tmp/tmpt991i94u.swift:27:17: error: expected\
    \ expression in list of expressions\n        return (extension, Double(upperCount\
    \ - lowerCount))\n                ^\n/tmp/t"
  stdout: ''
  timestamp: 1660009434
- exit_code: -4
  program: "\n/// You will be given the name of a class (a string) and an array of\
    \ extensions.\n/// The extensions are to be used to load additional classes to\
    \ the class. The\n/// strength of the extension is as follows: Let CAP be the\
    \ number of the uppercase\n/// letters in the extension's name, and let SM be\
    \ the number of lowercase letters \n/// in the extension's name, the strength\
    \ is given by the fraction CAP - SM. \n/// You should find the strongest extension\
    \ and return a string in this \n/// format: ClassName.StrongestExtensionName.\n\
    /// If there are two or more extensions with the same strength, you should\n///\
    \ choose the one that comes first in the array.\n/// For example, if you are given\
    \ \"Slices\" as the class and an array of the\n/// extensions: ['SErviNGSliCes',\
    \ 'Cheese', 'StuFfed'] then you should\n/// return 'Slices.SErviNGSliCes' since\
    \ 'SErviNGSliCes' is the strongest extension \n/// (its strength is -1).\n///\
    \ Example:\n/// >>> Strongest_Extension(class_name: \"my_class\", extensions:\
    \ [\"AA\", \"Be\", \"CC\"])\n/// \"my_class.AA\"\nfunc Strongest_Extension(class_name:\
    \ String, extensions: [String]) -> String {\n    var strongest_extension = extensions[0]\n\
    \    var strongest_extension_strength = 0.0\n    for ext in extensions {\n   \
    \     let ext_strength = Double(ext.filter{$0.isUppercase}.count) - Double(ext.filter{$0.isLowercase}.count)\n\
    \        if ext_strength > strongest_extension_strength {\n            strongest_extension\
    \ = ext\n            strongest_extension_strength = ext_strength\n        }\n\
    \    }\n    return \"\\(class_name).\\(strongest_extension)\"\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(Strongest_Extension(class_name: \"Watashi\", extensions:\
    \ [\"tEN\", \"niNE\", \"eIGHt8OKe\"]) == \"Watashi.eIGHt8OKe\")\nassert(Strongest_Extension(class_name:\
    \ \"Boku123\", extensions: [\"nani\", \"NazeDa\", \"YEs.WeCaNe\", \"32145tggg\"\
    ]) == \"Boku123.YEs.WeCaNe\")\nassert(Strongest_Extension(class_name: \"__YESIMHERE\"\
    , extensions: [\"t\", \"eMptY\", \"nothing\", \"zeR00\", \"NuLl__\", \"123NoooneB321\"\
    ]) == \"__YESIMHERE.NuLl__\")\nassert(Strongest_Extension(class_name: \"K\", extensions:\
    \ [\"Ta\", \"TAR\", \"t234An\", \"cosSo\"]) == \"K.TAR\")\nassert(Strongest_Extension(class_name:\
    \ \"__HAHA\", extensions: [\"Tab\", \"123\", \"781345\", \"-_-\"]) == \"__HAHA.123\"\
    )\nassert(Strongest_Extension(class_name: \"YameRore\", extensions: [\"HhAas\"\
    , \"okIWILL123\", \"WorkOut\", \"Fails\", \"-_-\"]) == \"YameRore.okIWILL123\"\
    )\nassert(Strongest_Extension(class_name: \"finNNalLLly\", extensions: [\"Die\"\
    , \"NowW\", \"Wow\", \"WoW\"]) == \"finNNalLLly.WoW\")\nassert(Strongest_Extension(class_name:\
    \ \"_\", extensions: [\"Bb\", \"91245\"]) == \"_.Bb\")\nassert(Strongest_Extension(class_name:\
    \ \"Sp\", extensions: [\"671235\", \"Bb\"]) == \"Sp.671235\")"
  status: Exception
  stderr: 'tmph_4knasp/tmph_4knasp.swift:46: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b509691fc80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b5096616b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b5096616988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b50966157b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmph_4knasp                        0x000055e5c9ed6fac <unavailable> + 8108

    5    libc.so.6                          0x00002b5096b0b460 __libc_start_main +
    245

    6    tmph_4knasp                        0x000055e5c9ed66b9 <unavailable> + 5817

    '
  stdout: ''
  timestamp: 1660009434
- exit_code: -4
  program: "\n/// You will be given the name of a class (a string) and an array of\
    \ extensions.\n/// The extensions are to be used to load additional classes to\
    \ the class. The\n/// strength of the extension is as follows: Let CAP be the\
    \ number of the uppercase\n/// letters in the extension's name, and let SM be\
    \ the number of lowercase letters \n/// in the extension's name, the strength\
    \ is given by the fraction CAP - SM. \n/// You should find the strongest extension\
    \ and return a string in this \n/// format: ClassName.StrongestExtensionName.\n\
    /// If there are two or more extensions with the same strength, you should\n///\
    \ choose the one that comes first in the array.\n/// For example, if you are given\
    \ \"Slices\" as the class and an array of the\n/// extensions: ['SErviNGSliCes',\
    \ 'Cheese', 'StuFfed'] then you should\n/// return 'Slices.SErviNGSliCes' since\
    \ 'SErviNGSliCes' is the strongest extension \n/// (its strength is -1).\n///\
    \ Example:\n/// >>> Strongest_Extension(class_name: \"my_class\", extensions:\
    \ [\"AA\", \"Be\", \"CC\"])\n/// \"my_class.AA\"\nfunc Strongest_Extension(class_name:\
    \ String, extensions: [String]) -> String {\n    var strength = 0\n    var strongest\
    \ = \"\"\n    for i in extensions {\n        var cap = 0\n        var sm = 0\n\
    \        for j in i {\n            if j >= \"A\" && j <= \"Z\" {\n           \
    \     cap += 1\n            } else if j >= \"a\" && j <= \"z\" {\n           \
    \     sm += 1\n            }\n        }\n        let st = cap - sm\n        if\
    \ st > strength {\n            strength = st\n            strongest = i\n    \
    \    }\n    }\n    return class_name + \".\" + strongest\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(Strongest_Extension(class_name: \"Watashi\", extensions:\
    \ [\"tEN\", \"niNE\", \"eIGHt8OKe\"]) == \"Watashi.eIGHt8OKe\")\nassert(Strongest_Extension(class_name:\
    \ \"Boku123\", extensions: [\"nani\", \"NazeDa\", \"YEs.WeCaNe\", \"32145tggg\"\
    ]) == \"Boku123.YEs.WeCaNe\")\nassert(Strongest_Extension(class_name: \"__YESIMHERE\"\
    , extensions: [\"t\", \"eMptY\", \"nothing\", \"zeR00\", \"NuLl__\", \"123NoooneB321\"\
    ]) == \"__YESIMHERE.NuLl__\")\nassert(Strongest_Extension(class_name: \"K\", extensions:\
    \ [\"Ta\", \"TAR\", \"t234An\", \"cosSo\"]) == \"K.TAR\")\nassert(Strongest_Extension(class_name:\
    \ \"__HAHA\", extensions: [\"Tab\", \"123\", \"781345\", \"-_-\"]) == \"__HAHA.123\"\
    )\nassert(Strongest_Extension(class_name: \"YameRore\", extensions: [\"HhAas\"\
    , \"okIWILL123\", \"WorkOut\", \"Fails\", \"-_-\"]) == \"YameRore.okIWILL123\"\
    )\nassert(Strongest_Extension(class_name: \"finNNalLLly\", extensions: [\"Die\"\
    , \"NowW\", \"Wow\", \"WoW\"]) == \"finNNalLLly.WoW\")\nassert(Strongest_Extension(class_name:\
    \ \"_\", extensions: [\"Bb\", \"91245\"]) == \"_.Bb\")\nassert(Strongest_Extension(class_name:\
    \ \"Sp\", extensions: [\"671235\", \"Bb\"]) == \"Sp.671235\")"
  status: Exception
  stderr: 'tmpzo3ga1s0/tmpzo3ga1s0.swift:55: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b4e02062c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b4e01d59b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b4e01d59988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b4e01d587b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpzo3ga1s0                        0x0000556d99d4adac <unavailable> + 7596

    5    libc.so.6                          0x00002b4e0224e460 __libc_start_main +
    245

    6    tmpzo3ga1s0                        0x0000556d99d4a4b9 <unavailable> + 5305

    '
  stdout: ''
  timestamp: 1660009434
- exit_code: -4
  program: "\n/// You will be given the name of a class (a string) and an array of\
    \ extensions.\n/// The extensions are to be used to load additional classes to\
    \ the class. The\n/// strength of the extension is as follows: Let CAP be the\
    \ number of the uppercase\n/// letters in the extension's name, and let SM be\
    \ the number of lowercase letters \n/// in the extension's name, the strength\
    \ is given by the fraction CAP - SM. \n/// You should find the strongest extension\
    \ and return a string in this \n/// format: ClassName.StrongestExtensionName.\n\
    /// If there are two or more extensions with the same strength, you should\n///\
    \ choose the one that comes first in the array.\n/// For example, if you are given\
    \ \"Slices\" as the class and an array of the\n/// extensions: ['SErviNGSliCes',\
    \ 'Cheese', 'StuFfed'] then you should\n/// return 'Slices.SErviNGSliCes' since\
    \ 'SErviNGSliCes' is the strongest extension \n/// (its strength is -1).\n///\
    \ Example:\n/// >>> Strongest_Extension(class_name: \"my_class\", extensions:\
    \ [\"AA\", \"Be\", \"CC\"])\n/// \"my_class.AA\"\nfunc Strongest_Extension(class_name:\
    \ String, extensions: [String]) -> String {\n    var strongest_extension = extensions[0]\n\
    \    var strongest_extension_strength = 0.0\n    var current_extension_strength\
    \ = 0.0\n    var uppercase_letters = 0\n    var lowercase_letters = 0\n    for\
    \ extension_name in extensions {\n        uppercase_letters = 0\n        lowercase_letters\
    \ = 0\n        for character in extension_name {\n            if String(character).uppercased()\
    \ == String(character) {\n                uppercase_letters += 1\n           \
    \ } else {\n                lowercase_letters += 1\n            }\n        }\n\
    \        current_extension_strength = Double(uppercase_letters) - Double(lowercase_letters)\n\
    \        if current_extension_strength > strongest_extension_strength {\n    \
    \        strongest_extension_strength = current_extension_strength\n         \
    \   strongest_extension = extension_name\n        }\n    }\n    return class_name\
    \ + \".\" + strongest_extension\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int,\
    \ Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n\
    \    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n          \
    \  return false\n        }\n    }\n    return true\n}\n            \nassert(Strongest_Extension(class_name:\
    \ \"Watashi\", extensions: [\"tEN\", \"niNE\", \"eIGHt8OKe\"]) == \"Watashi.eIGHt8OKe\"\
    )\nassert(Strongest_Extension(class_name: \"Boku123\", extensions: [\"nani\",\
    \ \"NazeDa\", \"YEs.WeCaNe\", \"32145tggg\"]) == \"Boku123.YEs.WeCaNe\")\nassert(Strongest_Extension(class_name:\
    \ \"__YESIMHERE\", extensions: [\"t\", \"eMptY\", \"nothing\", \"zeR00\", \"NuLl__\"\
    , \"123NoooneB321\"]) == \"__YESIMHERE.NuLl__\")\nassert(Strongest_Extension(class_name:\
    \ \"K\", extensions: [\"Ta\", \"TAR\", \"t234An\", \"cosSo\"]) == \"K.TAR\")\n\
    assert(Strongest_Extension(class_name: \"__HAHA\", extensions: [\"Tab\", \"123\"\
    , \"781345\", \"-_-\"]) == \"__HAHA.123\")\nassert(Strongest_Extension(class_name:\
    \ \"YameRore\", extensions: [\"HhAas\", \"okIWILL123\", \"WorkOut\", \"Fails\"\
    , \"-_-\"]) == \"YameRore.okIWILL123\")\nassert(Strongest_Extension(class_name:\
    \ \"finNNalLLly\", extensions: [\"Die\", \"NowW\", \"Wow\", \"WoW\"]) == \"finNNalLLly.WoW\"\
    )\nassert(Strongest_Extension(class_name: \"_\", extensions: [\"Bb\", \"91245\"\
    ]) == \"_.Bb\")\nassert(Strongest_Extension(class_name: \"Sp\", extensions: [\"\
    671235\", \"Bb\"]) == \"Sp.671235\")"
  status: Exception
  stderr: 'tmpu1mwj98x/tmpu1mwj98x.swift:58: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b287b422c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b287b119b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b287b119988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b287b1187b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpu1mwj98x                        0x000055ab84790cec <unavailable> + 7404

    5    libc.so.6                          0x00002b287b60e460 __libc_start_main +
    245

    6    tmpu1mwj98x                        0x000055ab847903f9 <unavailable> + 5113

    '
  stdout: ''
  timestamp: 1660009434
- exit_code: -4
  program: "\n/// You will be given the name of a class (a string) and an array of\
    \ extensions.\n/// The extensions are to be used to load additional classes to\
    \ the class. The\n/// strength of the extension is as follows: Let CAP be the\
    \ number of the uppercase\n/// letters in the extension's name, and let SM be\
    \ the number of lowercase letters \n/// in the extension's name, the strength\
    \ is given by the fraction CAP - SM. \n/// You should find the strongest extension\
    \ and return a string in this \n/// format: ClassName.StrongestExtensionName.\n\
    /// If there are two or more extensions with the same strength, you should\n///\
    \ choose the one that comes first in the array.\n/// For example, if you are given\
    \ \"Slices\" as the class and an array of the\n/// extensions: ['SErviNGSliCes',\
    \ 'Cheese', 'StuFfed'] then you should\n/// return 'Slices.SErviNGSliCes' since\
    \ 'SErviNGSliCes' is the strongest extension \n/// (its strength is -1).\n///\
    \ Example:\n/// >>> Strongest_Extension(class_name: \"my_class\", extensions:\
    \ [\"AA\", \"Be\", \"CC\"])\n/// \"my_class.AA\"\nfunc Strongest_Extension(class_name:\
    \ String, extensions: [String]) -> String {\n    return \"my_class.AA\"\n}\n\n\
    \nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(Strongest_Extension(class_name: \"Watashi\", extensions:\
    \ [\"tEN\", \"niNE\", \"eIGHt8OKe\"]) == \"Watashi.eIGHt8OKe\")\nassert(Strongest_Extension(class_name:\
    \ \"Boku123\", extensions: [\"nani\", \"NazeDa\", \"YEs.WeCaNe\", \"32145tggg\"\
    ]) == \"Boku123.YEs.WeCaNe\")\nassert(Strongest_Extension(class_name: \"__YESIMHERE\"\
    , extensions: [\"t\", \"eMptY\", \"nothing\", \"zeR00\", \"NuLl__\", \"123NoooneB321\"\
    ]) == \"__YESIMHERE.NuLl__\")\nassert(Strongest_Extension(class_name: \"K\", extensions:\
    \ [\"Ta\", \"TAR\", \"t234An\", \"cosSo\"]) == \"K.TAR\")\nassert(Strongest_Extension(class_name:\
    \ \"__HAHA\", extensions: [\"Tab\", \"123\", \"781345\", \"-_-\"]) == \"__HAHA.123\"\
    )\nassert(Strongest_Extension(class_name: \"YameRore\", extensions: [\"HhAas\"\
    , \"okIWILL123\", \"WorkOut\", \"Fails\", \"-_-\"]) == \"YameRore.okIWILL123\"\
    )\nassert(Strongest_Extension(class_name: \"finNNalLLly\", extensions: [\"Die\"\
    , \"NowW\", \"Wow\", \"WoW\"]) == \"finNNalLLly.WoW\")\nassert(Strongest_Extension(class_name:\
    \ \"_\", extensions: [\"Bb\", \"91245\"]) == \"_.Bb\")\nassert(Strongest_Extension(class_name:\
    \ \"Sp\", extensions: [\"671235\", \"Bb\"]) == \"Sp.671235\")"
  status: Exception
  stderr: 'tmpb5tys6fa/tmpb5tys6fa.swift:35: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b35b960ac80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b35b9301b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b35b9301988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b35b93007b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpb5tys6fa                        0x00005564e72294fd <unavailable> + 5373

    5    libc.so.6                          0x00002b35b97f6460 __libc_start_main +
    245

    6    tmpb5tys6fa                        0x00005564e7229089 <unavailable> + 4233

    '
  stdout: ''
  timestamp: 1660009434
- exit_code: -4
  program: "\n/// You will be given the name of a class (a string) and an array of\
    \ extensions.\n/// The extensions are to be used to load additional classes to\
    \ the class. The\n/// strength of the extension is as follows: Let CAP be the\
    \ number of the uppercase\n/// letters in the extension's name, and let SM be\
    \ the number of lowercase letters \n/// in the extension's name, the strength\
    \ is given by the fraction CAP - SM. \n/// You should find the strongest extension\
    \ and return a string in this \n/// format: ClassName.StrongestExtensionName.\n\
    /// If there are two or more extensions with the same strength, you should\n///\
    \ choose the one that comes first in the array.\n/// For example, if you are given\
    \ \"Slices\" as the class and an array of the\n/// extensions: ['SErviNGSliCes',\
    \ 'Cheese', 'StuFfed'] then you should\n/// return 'Slices.SErviNGSliCes' since\
    \ 'SErviNGSliCes' is the strongest extension \n/// (its strength is -1).\n///\
    \ Example:\n/// >>> Strongest_Extension(class_name: \"my_class\", extensions:\
    \ [\"AA\", \"Be\", \"CC\"])\n/// \"my_class.AA\"\nfunc Strongest_Extension(class_name:\
    \ String, extensions: [String]) -> String {\n    // Write your code here!\n  \
    \  return \"\"\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool\
    \ {\n    if left.count != right.count {\n        return false\n    }\n    for\
    \ (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(Strongest_Extension(class_name:\
    \ \"Watashi\", extensions: [\"tEN\", \"niNE\", \"eIGHt8OKe\"]) == \"Watashi.eIGHt8OKe\"\
    )\nassert(Strongest_Extension(class_name: \"Boku123\", extensions: [\"nani\",\
    \ \"NazeDa\", \"YEs.WeCaNe\", \"32145tggg\"]) == \"Boku123.YEs.WeCaNe\")\nassert(Strongest_Extension(class_name:\
    \ \"__YESIMHERE\", extensions: [\"t\", \"eMptY\", \"nothing\", \"zeR00\", \"NuLl__\"\
    , \"123NoooneB321\"]) == \"__YESIMHERE.NuLl__\")\nassert(Strongest_Extension(class_name:\
    \ \"K\", extensions: [\"Ta\", \"TAR\", \"t234An\", \"cosSo\"]) == \"K.TAR\")\n\
    assert(Strongest_Extension(class_name: \"__HAHA\", extensions: [\"Tab\", \"123\"\
    , \"781345\", \"-_-\"]) == \"__HAHA.123\")\nassert(Strongest_Extension(class_name:\
    \ \"YameRore\", extensions: [\"HhAas\", \"okIWILL123\", \"WorkOut\", \"Fails\"\
    , \"-_-\"]) == \"YameRore.okIWILL123\")\nassert(Strongest_Extension(class_name:\
    \ \"finNNalLLly\", extensions: [\"Die\", \"NowW\", \"Wow\", \"WoW\"]) == \"finNNalLLly.WoW\"\
    )\nassert(Strongest_Extension(class_name: \"_\", extensions: [\"Bb\", \"91245\"\
    ]) == \"_.Bb\")\nassert(Strongest_Extension(class_name: \"Sp\", extensions: [\"\
    671235\", \"Bb\"]) == \"Sp.671235\")"
  status: Exception
  stderr: 'tmpmzsugftl/tmpmzsugftl.swift:36: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b9f0a035c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b9f09d2cb6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b9f09d2c988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b9f09d2b7b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpmzsugftl                        0x0000563df1fb94fd <unavailable> + 5373

    5    libc.so.6                          0x00002b9f0a221460 __libc_start_main +
    245

    6    tmpmzsugftl                        0x0000563df1fb9089 <unavailable> + 4233

    '
  stdout: ''
  timestamp: 1660009434
- exit_code: -4
  program: "\n/// You will be given the name of a class (a string) and an array of\
    \ extensions.\n/// The extensions are to be used to load additional classes to\
    \ the class. The\n/// strength of the extension is as follows: Let CAP be the\
    \ number of the uppercase\n/// letters in the extension's name, and let SM be\
    \ the number of lowercase letters \n/// in the extension's name, the strength\
    \ is given by the fraction CAP - SM. \n/// You should find the strongest extension\
    \ and return a string in this \n/// format: ClassName.StrongestExtensionName.\n\
    /// If there are two or more extensions with the same strength, you should\n///\
    \ choose the one that comes first in the array.\n/// For example, if you are given\
    \ \"Slices\" as the class and an array of the\n/// extensions: ['SErviNGSliCes',\
    \ 'Cheese', 'StuFfed'] then you should\n/// return 'Slices.SErviNGSliCes' since\
    \ 'SErviNGSliCes' is the strongest extension \n/// (its strength is -1).\n///\
    \ Example:\n/// >>> Strongest_Extension(class_name: \"my_class\", extensions:\
    \ [\"AA\", \"Be\", \"CC\"])\n/// \"my_class.AA\"\nfunc Strongest_Extension(class_name:\
    \ String, extensions: [String]) -> String {\n    var extension_strength: [String:\
    \ Int] = [:]\n    for ext in extensions {\n        let capital_letters = ext.filter\
    \ { $0.isUppercase }\n        let small_letters = ext.filter { $0.isLowercase\
    \ }\n        extension_strength[ext] = capital_letters.count - small_letters.count\n\
    \    }\n    // Find max value in the dictionary\n    let strongest_extension =\
    \ extension_strength.values.max()\n    // Find the keys with the strongest values\n\
    \    let strongest_extension_names = extension_strength.filter { $0.value == strongest_extension\
    \ }\n    // Find the first element in the dictionary\n    let strongest_extension_name\
    \ = strongest_extension_names.first?.key\n    return class_name + \".\" + strongest_extension_name!\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(Strongest_Extension(class_name: \"Watashi\", extensions:\
    \ [\"tEN\", \"niNE\", \"eIGHt8OKe\"]) == \"Watashi.eIGHt8OKe\")\nassert(Strongest_Extension(class_name:\
    \ \"Boku123\", extensions: [\"nani\", \"NazeDa\", \"YEs.WeCaNe\", \"32145tggg\"\
    ]) == \"Boku123.YEs.WeCaNe\")\nassert(Strongest_Extension(class_name: \"__YESIMHERE\"\
    , extensions: [\"t\", \"eMptY\", \"nothing\", \"zeR00\", \"NuLl__\", \"123NoooneB321\"\
    ]) == \"__YESIMHERE.NuLl__\")\nassert(Strongest_Extension(class_name: \"K\", extensions:\
    \ [\"Ta\", \"TAR\", \"t234An\", \"cosSo\"]) == \"K.TAR\")\nassert(Strongest_Extension(class_name:\
    \ \"__HAHA\", extensions: [\"Tab\", \"123\", \"781345\", \"-_-\"]) == \"__HAHA.123\"\
    )\nassert(Strongest_Extension(class_name: \"YameRore\", extensions: [\"HhAas\"\
    , \"okIWILL123\", \"WorkOut\", \"Fails\", \"-_-\"]) == \"YameRore.okIWILL123\"\
    )\nassert(Strongest_Extension(class_name: \"finNNalLLly\", extensions: [\"Die\"\
    , \"NowW\", \"Wow\", \"WoW\"]) == \"finNNalLLly.WoW\")\nassert(Strongest_Extension(class_name:\
    \ \"_\", extensions: [\"Bb\", \"91245\"]) == \"_.Bb\")\nassert(Strongest_Extension(class_name:\
    \ \"Sp\", extensions: [\"671235\", \"Bb\"]) == \"Sp.671235\")"
  status: Exception
  stderr: 'tmpnhsemzp9/tmpnhsemzp9.swift:51: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b3fc36cbc80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b3fc33c2b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b3fc33c2988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b3fc33c17b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpnhsemzp9                        0x000055f72170753a <unavailable> + 9530

    5    libc.so.6                          0x00002b3fc38b7460 __libc_start_main +
    245

    6    tmpnhsemzp9                        0x000055f721706809 <unavailable> + 6153

    '
  stdout: ''
  timestamp: 1660009434
- exit_code: 0
  program: "\n/// You will be given the name of a class (a string) and an array of\
    \ extensions.\n/// The extensions are to be used to load additional classes to\
    \ the class. The\n/// strength of the extension is as follows: Let CAP be the\
    \ number of the uppercase\n/// letters in the extension's name, and let SM be\
    \ the number of lowercase letters \n/// in the extension's name, the strength\
    \ is given by the fraction CAP - SM. \n/// You should find the strongest extension\
    \ and return a string in this \n/// format: ClassName.StrongestExtensionName.\n\
    /// If there are two or more extensions with the same strength, you should\n///\
    \ choose the one that comes first in the array.\n/// For example, if you are given\
    \ \"Slices\" as the class and an array of the\n/// extensions: ['SErviNGSliCes',\
    \ 'Cheese', 'StuFfed'] then you should\n/// return 'Slices.SErviNGSliCes' since\
    \ 'SErviNGSliCes' is the strongest extension \n/// (its strength is -1).\n///\
    \ Example:\n/// >>> Strongest_Extension(class_name: \"my_class\", extensions:\
    \ [\"AA\", \"Be\", \"CC\"])\n/// \"my_class.AA\"\nfunc Strongest_Extension(class_name:\
    \ String, extensions: [String]) -> String {\n    var max_strength = Float(Int.min)\n\
    \    var strongest_class_extension = \"\"\n    for ext in extensions {\n     \
    \   let cap = ext.filter{$0.isUppercase}.count\n        let sm = ext.filter{$0.isLowercase}.count\n\
    \        let strength = Float(cap - sm)\n        if strength > max_strength {\n\
    \            max_strength = strength\n            strongest_class_extension =\
    \ ext\n        }\n    }\n    return class_name + \".\" + strongest_class_extension\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(Strongest_Extension(class_name: \"Watashi\", extensions:\
    \ [\"tEN\", \"niNE\", \"eIGHt8OKe\"]) == \"Watashi.eIGHt8OKe\")\nassert(Strongest_Extension(class_name:\
    \ \"Boku123\", extensions: [\"nani\", \"NazeDa\", \"YEs.WeCaNe\", \"32145tggg\"\
    ]) == \"Boku123.YEs.WeCaNe\")\nassert(Strongest_Extension(class_name: \"__YESIMHERE\"\
    , extensions: [\"t\", \"eMptY\", \"nothing\", \"zeR00\", \"NuLl__\", \"123NoooneB321\"\
    ]) == \"__YESIMHERE.NuLl__\")\nassert(Strongest_Extension(class_name: \"K\", extensions:\
    \ [\"Ta\", \"TAR\", \"t234An\", \"cosSo\"]) == \"K.TAR\")\nassert(Strongest_Extension(class_name:\
    \ \"__HAHA\", extensions: [\"Tab\", \"123\", \"781345\", \"-_-\"]) == \"__HAHA.123\"\
    )\nassert(Strongest_Extension(class_name: \"YameRore\", extensions: [\"HhAas\"\
    , \"okIWILL123\", \"WorkOut\", \"Fails\", \"-_-\"]) == \"YameRore.okIWILL123\"\
    )\nassert(Strongest_Extension(class_name: \"finNNalLLly\", extensions: [\"Die\"\
    , \"NowW\", \"Wow\", \"WoW\"]) == \"finNNalLLly.WoW\")\nassert(Strongest_Extension(class_name:\
    \ \"_\", extensions: [\"Bb\", \"91245\"]) == \"_.Bb\")\nassert(Strongest_Extension(class_name:\
    \ \"Sp\", extensions: [\"671235\", \"Bb\"]) == \"Sp.671235\")"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660009434
- exit_code: -4
  program: "\n/// You will be given the name of a class (a string) and an array of\
    \ extensions.\n/// The extensions are to be used to load additional classes to\
    \ the class. The\n/// strength of the extension is as follows: Let CAP be the\
    \ number of the uppercase\n/// letters in the extension's name, and let SM be\
    \ the number of lowercase letters \n/// in the extension's name, the strength\
    \ is given by the fraction CAP - SM. \n/// You should find the strongest extension\
    \ and return a string in this \n/// format: ClassName.StrongestExtensionName.\n\
    /// If there are two or more extensions with the same strength, you should\n///\
    \ choose the one that comes first in the array.\n/// For example, if you are given\
    \ \"Slices\" as the class and an array of the\n/// extensions: ['SErviNGSliCes',\
    \ 'Cheese', 'StuFfed'] then you should\n/// return 'Slices.SErviNGSliCes' since\
    \ 'SErviNGSliCes' is the strongest extension \n/// (its strength is -1).\n///\
    \ Example:\n/// >>> Strongest_Extension(class_name: \"my_class\", extensions:\
    \ [\"AA\", \"Be\", \"CC\"])\n/// \"my_class.AA\"\nfunc Strongest_Extension(class_name:\
    \ String, extensions: [String]) -> String {\n    return \"\"\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(Strongest_Extension(class_name: \"Watashi\", extensions:\
    \ [\"tEN\", \"niNE\", \"eIGHt8OKe\"]) == \"Watashi.eIGHt8OKe\")\nassert(Strongest_Extension(class_name:\
    \ \"Boku123\", extensions: [\"nani\", \"NazeDa\", \"YEs.WeCaNe\", \"32145tggg\"\
    ]) == \"Boku123.YEs.WeCaNe\")\nassert(Strongest_Extension(class_name: \"__YESIMHERE\"\
    , extensions: [\"t\", \"eMptY\", \"nothing\", \"zeR00\", \"NuLl__\", \"123NoooneB321\"\
    ]) == \"__YESIMHERE.NuLl__\")\nassert(Strongest_Extension(class_name: \"K\", extensions:\
    \ [\"Ta\", \"TAR\", \"t234An\", \"cosSo\"]) == \"K.TAR\")\nassert(Strongest_Extension(class_name:\
    \ \"__HAHA\", extensions: [\"Tab\", \"123\", \"781345\", \"-_-\"]) == \"__HAHA.123\"\
    )\nassert(Strongest_Extension(class_name: \"YameRore\", extensions: [\"HhAas\"\
    , \"okIWILL123\", \"WorkOut\", \"Fails\", \"-_-\"]) == \"YameRore.okIWILL123\"\
    )\nassert(Strongest_Extension(class_name: \"finNNalLLly\", extensions: [\"Die\"\
    , \"NowW\", \"Wow\", \"WoW\"]) == \"finNNalLLly.WoW\")\nassert(Strongest_Extension(class_name:\
    \ \"_\", extensions: [\"Bb\", \"91245\"]) == \"_.Bb\")\nassert(Strongest_Extension(class_name:\
    \ \"Sp\", extensions: [\"671235\", \"Bb\"]) == \"Sp.671235\")"
  status: Exception
  stderr: 'tmpuhmbxdp4/tmpuhmbxdp4.swift:35: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002abeef348c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002abeef03fb6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002abeef03f988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002abeef03e7b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpuhmbxdp4                        0x0000559ee0d614fd <unavailable> + 5373

    5    libc.so.6                          0x00002abeef534460 __libc_start_main +
    245

    6    tmpuhmbxdp4                        0x0000559ee0d61089 <unavailable> + 4233

    '
  stdout: ''
  timestamp: 1660009431
- exit_code: 1
  program: "\n/// You will be given the name of a class (a string) and an array of\
    \ extensions.\n/// The extensions are to be used to load additional classes to\
    \ the class. The\n/// strength of the extension is as follows: Let CAP be the\
    \ number of the uppercase\n/// letters in the extension's name, and let SM be\
    \ the number of lowercase letters \n/// in the extension's name, the strength\
    \ is given by the fraction CAP - SM. \n/// You should find the strongest extension\
    \ and return a string in this \n/// format: ClassName.StrongestExtensionName.\n\
    /// If there are two or more extensions with the same strength, you should\n///\
    \ choose the one that comes first in the array.\n/// For example, if you are given\
    \ \"Slices\" as the class and an array of the\n/// extensions: ['SErviNGSliCes',\
    \ 'Cheese', 'StuFfed'] then you should\n/// return 'Slices.SErviNGSliCes' since\
    \ 'SErviNGSliCes' is the strongest extension \n/// (its strength is -1).\n///\
    \ Example:\n/// >>> Strongest_Extension(class_name: \"my_class\", extensions:\
    \ [\"AA\", \"Be\", \"CC\"])\n/// \"my_class.AA\"\nfunc Strongest_Extension(class_name:\
    \ String, extensions: [String]) -> String {\n\tvar strongestExtension: String\
    \ = \"\"\n\tvar strongestExtensionStrength: Double = 0\n\tfor extension_ in extensions\
    \ {\n\t\tlet extensionStrength = strength(of: extension_)\n\t\tif extensionStrength\
    \ > strongestExtensionStrength {\n\t\t\tstrongestExtensionStrength = extensionStrength\n\
    \t\t\tstrongestExtension = extension_\n\t\t}\n\t}\n\treturn \"\\(class_name).\\\
    (strongestExtension)\"\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(Strongest_Extension(class_name:\
    \ \"Watashi\", extensions: [\"tEN\", \"niNE\", \"eIGHt8OKe\"]) == \"Watashi.eIGHt8OKe\"\
    )\nassert(Strongest_Extension(class_name: \"Boku123\", extensions: [\"nani\",\
    \ \"NazeDa\", \"YEs.WeCaNe\", \"32145tggg\"]) == \"Boku123.YEs.WeCaNe\")\nassert(Strongest_Extension(class_name:\
    \ \"__YESIMHERE\", extensions: [\"t\", \"eMptY\", \"nothing\", \"zeR00\", \"NuLl__\"\
    , \"123NoooneB321\"]) == \"__YESIMHERE.NuLl__\")\nassert(Strongest_Extension(class_name:\
    \ \"K\", extensions: [\"Ta\", \"TAR\", \"t234An\", \"cosSo\"]) == \"K.TAR\")\n\
    assert(Strongest_Extension(class_name: \"__HAHA\", extensions: [\"Tab\", \"123\"\
    , \"781345\", \"-_-\"]) == \"__HAHA.123\")\nassert(Strongest_Extension(class_name:\
    \ \"YameRore\", extensions: [\"HhAas\", \"okIWILL123\", \"WorkOut\", \"Fails\"\
    , \"-_-\"]) == \"YameRore.okIWILL123\")\nassert(Strongest_Extension(class_name:\
    \ \"finNNalLLly\", extensions: [\"Die\", \"NowW\", \"Wow\", \"WoW\"]) == \"finNNalLLly.WoW\"\
    )\nassert(Strongest_Extension(class_name: \"_\", extensions: [\"Bb\", \"91245\"\
    ]) == \"_.Bb\")\nassert(Strongest_Extension(class_name: \"Sp\", extensions: [\"\
    671235\", \"Bb\"]) == \"Sp.671235\")"
  status: SyntaxError
  stderr: "/tmp/tmpyb4bf6qf.swift:22:27: error: cannot find 'strength' in scope\n\
    \                let extensionStrength = strength(of: extension_)\n          \
    \                              ^~~~~~~~\n"
  stdout: ''
  timestamp: 1660009434
- exit_code: -4
  program: "\n/// You will be given the name of a class (a string) and an array of\
    \ extensions.\n/// The extensions are to be used to load additional classes to\
    \ the class. The\n/// strength of the extension is as follows: Let CAP be the\
    \ number of the uppercase\n/// letters in the extension's name, and let SM be\
    \ the number of lowercase letters \n/// in the extension's name, the strength\
    \ is given by the fraction CAP - SM. \n/// You should find the strongest extension\
    \ and return a string in this \n/// format: ClassName.StrongestExtensionName.\n\
    /// If there are two or more extensions with the same strength, you should\n///\
    \ choose the one that comes first in the array.\n/// For example, if you are given\
    \ \"Slices\" as the class and an array of the\n/// extensions: ['SErviNGSliCes',\
    \ 'Cheese', 'StuFfed'] then you should\n/// return 'Slices.SErviNGSliCes' since\
    \ 'SErviNGSliCes' is the strongest extension \n/// (its strength is -1).\n///\
    \ Example:\n/// >>> Strongest_Extension(class_name: \"my_class\", extensions:\
    \ [\"AA\", \"Be\", \"CC\"])\n/// \"my_class.AA\"\nfunc Strongest_Extension(class_name:\
    \ String, extensions: [String]) -> String {\n    var strength = 0\n    var index\
    \ = 0\n    for i in 0...extensions.count - 1 {\n        let uppercase_letters\
    \ = Array(extensions[i]).filter({(char: Character) -> Bool in\n            return\
    \ char.isUppercase\n        })\n        let lowercase_letters = Array(extensions[i]).filter({(char:\
    \ Character) -> Bool in\n            return char.isLowercase\n        })\n   \
    \     if ((uppercase_letters.count - lowercase_letters.count) > strength) {\n\
    \            strength = uppercase_letters.count - lowercase_letters.count\n  \
    \          index = i\n        }\n    }\n    return \"\\(class_name).\\(extensions[index])\"\
    \n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(Strongest_Extension(class_name: \"Watashi\", extensions:\
    \ [\"tEN\", \"niNE\", \"eIGHt8OKe\"]) == \"Watashi.eIGHt8OKe\")\nassert(Strongest_Extension(class_name:\
    \ \"Boku123\", extensions: [\"nani\", \"NazeDa\", \"YEs.WeCaNe\", \"32145tggg\"\
    ]) == \"Boku123.YEs.WeCaNe\")\nassert(Strongest_Extension(class_name: \"__YESIMHERE\"\
    , extensions: [\"t\", \"eMptY\", \"nothing\", \"zeR00\", \"NuLl__\", \"123NoooneB321\"\
    ]) == \"__YESIMHERE.NuLl__\")\nassert(Strongest_Extension(class_name: \"K\", extensions:\
    \ [\"Ta\", \"TAR\", \"t234An\", \"cosSo\"]) == \"K.TAR\")\nassert(Strongest_Extension(class_name:\
    \ \"__HAHA\", extensions: [\"Tab\", \"123\", \"781345\", \"-_-\"]) == \"__HAHA.123\"\
    )\nassert(Strongest_Extension(class_name: \"YameRore\", extensions: [\"HhAas\"\
    , \"okIWILL123\", \"WorkOut\", \"Fails\", \"-_-\"]) == \"YameRore.okIWILL123\"\
    )\nassert(Strongest_Extension(class_name: \"finNNalLLly\", extensions: [\"Die\"\
    , \"NowW\", \"Wow\", \"WoW\"]) == \"finNNalLLly.WoW\")\nassert(Strongest_Extension(class_name:\
    \ \"_\", extensions: [\"Bb\", \"91245\"]) == \"_.Bb\")\nassert(Strongest_Extension(class_name:\
    \ \"Sp\", extensions: [\"671235\", \"Bb\"]) == \"Sp.671235\")"
  status: Exception
  stderr: 'tmpe5h1t0ud/tmpe5h1t0ud.swift:51: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b653bd97c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b653ba8eb6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b653ba8e988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b653ba8d7b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpe5h1t0ud                        0x000056524045811c <unavailable> + 8476

    5    libc.so.6                          0x00002b653bf83460 __libc_start_main +
    245

    6    tmpe5h1t0ud                        0x0000565240457829 <unavailable> + 6185

    '
  stdout: ''
  timestamp: 1660009434
- exit_code: 1
  program: "\n/// You will be given the name of a class (a string) and an array of\
    \ extensions.\n/// The extensions are to be used to load additional classes to\
    \ the class. The\n/// strength of the extension is as follows: Let CAP be the\
    \ number of the uppercase\n/// letters in the extension's name, and let SM be\
    \ the number of lowercase letters \n/// in the extension's name, the strength\
    \ is given by the fraction CAP - SM. \n/// You should find the strongest extension\
    \ and return a string in this \n/// format: ClassName.StrongestExtensionName.\n\
    /// If there are two or more extensions with the same strength, you should\n///\
    \ choose the one that comes first in the array.\n/// For example, if you are given\
    \ \"Slices\" as the class and an array of the\n/// extensions: ['SErviNGSliCes',\
    \ 'Cheese', 'StuFfed'] then you should\n/// return 'Slices.SErviNGSliCes' since\
    \ 'SErviNGSliCes' is the strongest extension \n/// (its strength is -1).\n///\
    \ Example:\n/// >>> Strongest_Extension(class_name: \"my_class\", extensions:\
    \ [\"AA\", \"Be\", \"CC\"])\n/// \"my_class.AA\"\nfunc Strongest_Extension(class_name:\
    \ String, extensions: [String]) -> String {\n    let result = extensions.enumerated().reduce((\"\
    \", 0.0)) {(first, second) in\n        let value = second.element.uppercased().count\
    \ - second.element.lowercased().count\n        return value > first.1 ? (second.element,\
    \ value) : first\n    }\n    return \"\\(class_name).\\(result.0)\"\n}\n\n\nfunc\
    \ ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count !=\
    \ right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(Strongest_Extension(class_name: \"Watashi\", extensions:\
    \ [\"tEN\", \"niNE\", \"eIGHt8OKe\"]) == \"Watashi.eIGHt8OKe\")\nassert(Strongest_Extension(class_name:\
    \ \"Boku123\", extensions: [\"nani\", \"NazeDa\", \"YEs.WeCaNe\", \"32145tggg\"\
    ]) == \"Boku123.YEs.WeCaNe\")\nassert(Strongest_Extension(class_name: \"__YESIMHERE\"\
    , extensions: [\"t\", \"eMptY\", \"nothing\", \"zeR00\", \"NuLl__\", \"123NoooneB321\"\
    ]) == \"__YESIMHERE.NuLl__\")\nassert(Strongest_Extension(class_name: \"K\", extensions:\
    \ [\"Ta\", \"TAR\", \"t234An\", \"cosSo\"]) == \"K.TAR\")\nassert(Strongest_Extension(class_name:\
    \ \"__HAHA\", extensions: [\"Tab\", \"123\", \"781345\", \"-_-\"]) == \"__HAHA.123\"\
    )\nassert(Strongest_Extension(class_name: \"YameRore\", extensions: [\"HhAas\"\
    , \"okIWILL123\", \"WorkOut\", \"Fails\", \"-_-\"]) == \"YameRore.okIWILL123\"\
    )\nassert(Strongest_Extension(class_name: \"finNNalLLly\", extensions: [\"Die\"\
    , \"NowW\", \"Wow\", \"WoW\"]) == \"finNNalLLly.WoW\")\nassert(Strongest_Extension(class_name:\
    \ \"_\", extensions: [\"Bb\", \"91245\"]) == \"_.Bb\")\nassert(Strongest_Extension(class_name:\
    \ \"Sp\", extensions: [\"671235\", \"Bb\"]) == \"Sp.671235\")"
  status: SyntaxError
  stderr: "/tmp/tmpr6rjv89f.swift:21:30: error: cannot convert value of type 'Double'\
    \ to expected argument type 'Int'\n        return value > first.1 ? (second.element,\
    \ value) : first\n                             ^\n                       Int(\
    \   )\n/tmp/tmpr6rjv89f.swift:21:34: error: cannot convert return expression of\
    \ type '(String, Int)' to return type '(String, Double)'\n        return value\
    \ > first.1 ? (second.element, value) : first\n                              \
    \   ^\n"
  stdout: ''
  timestamp: 1660009434
- exit_code: 1
  program: "\n/// You will be given the name of a class (a string) and an array of\
    \ extensions.\n/// The extensions are to be used to load additional classes to\
    \ the class. The\n/// strength of the extension is as follows: Let CAP be the\
    \ number of the uppercase\n/// letters in the extension's name, and let SM be\
    \ the number of lowercase letters \n/// in the extension's name, the strength\
    \ is given by the fraction CAP - SM. \n/// You should find the strongest extension\
    \ and return a string in this \n/// format: ClassName.StrongestExtensionName.\n\
    /// If there are two or more extensions with the same strength, you should\n///\
    \ choose the one that comes first in the array.\n/// For example, if you are given\
    \ \"Slices\" as the class and an array of the\n/// extensions: ['SErviNGSliCes',\
    \ 'Cheese', 'StuFfed'] then you should\n/// return 'Slices.SErviNGSliCes' since\
    \ 'SErviNGSliCes' is the strongest extension \n/// (its strength is -1).\n///\
    \ Example:\n/// >>> Strongest_Extension(class_name: \"my_class\", extensions:\
    \ [\"AA\", \"Be\", \"CC\"])\n/// \"my_class.AA\"\nfunc Strongest_Extension(class_name:\
    \ String, extensions: [String]) -> String {\n    let class_name = class_name\n\
    \    var ext_strength = 0.0\n    var strongest_ext = \"\"\n    for ext in extensions\
    \ {\n        let capital_count = ext.count { $0.isUppercase }\n        let small_count\
    \ = ext.count { $0.isLowercase }\n        let strength = (Double(capital_count)\
    \ - Double(small_count))\n        if strength > ext_strength {\n            ext_strength\
    \ = strength\n            strongest_ext = ext\n        }\n    }\n    return class_name\
    \ + \".\" + strongest_ext\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(Strongest_Extension(class_name:\
    \ \"Watashi\", extensions: [\"tEN\", \"niNE\", \"eIGHt8OKe\"]) == \"Watashi.eIGHt8OKe\"\
    )\nassert(Strongest_Extension(class_name: \"Boku123\", extensions: [\"nani\",\
    \ \"NazeDa\", \"YEs.WeCaNe\", \"32145tggg\"]) == \"Boku123.YEs.WeCaNe\")\nassert(Strongest_Extension(class_name:\
    \ \"__YESIMHERE\", extensions: [\"t\", \"eMptY\", \"nothing\", \"zeR00\", \"NuLl__\"\
    , \"123NoooneB321\"]) == \"__YESIMHERE.NuLl__\")\nassert(Strongest_Extension(class_name:\
    \ \"K\", extensions: [\"Ta\", \"TAR\", \"t234An\", \"cosSo\"]) == \"K.TAR\")\n\
    assert(Strongest_Extension(class_name: \"__HAHA\", extensions: [\"Tab\", \"123\"\
    , \"781345\", \"-_-\"]) == \"__HAHA.123\")\nassert(Strongest_Extension(class_name:\
    \ \"YameRore\", extensions: [\"HhAas\", \"okIWILL123\", \"WorkOut\", \"Fails\"\
    , \"-_-\"]) == \"YameRore.okIWILL123\")\nassert(Strongest_Extension(class_name:\
    \ \"finNNalLLly\", extensions: [\"Die\", \"NowW\", \"Wow\", \"WoW\"]) == \"finNNalLLly.WoW\"\
    )\nassert(Strongest_Extension(class_name: \"_\", extensions: [\"Bb\", \"91245\"\
    ]) == \"_.Bb\")\nassert(Strongest_Extension(class_name: \"Sp\", extensions: [\"\
    671235\", \"Bb\"]) == \"Sp.671235\")"
  status: SyntaxError
  stderr: "/tmp/tmpd7fqqr72.swift:23:33: error: cannot call value of non-function\
    \ type 'Int'\n        let capital_count = ext.count { $0.isUppercase }\n     \
    \                           ^\n/tmp/tmpd7fqqr72.swift:24:31: error: cannot call\
    \ value of non-function type 'Int'\n        let small_count = ext.count { $0.isLowercase\
    \ }\n                              ^\n"
  stdout: ''
  timestamp: 1660009434
- exit_code: -4
  program: "\n/// You will be given the name of a class (a string) and an array of\
    \ extensions.\n/// The extensions are to be used to load additional classes to\
    \ the class. The\n/// strength of the extension is as follows: Let CAP be the\
    \ number of the uppercase\n/// letters in the extension's name, and let SM be\
    \ the number of lowercase letters \n/// in the extension's name, the strength\
    \ is given by the fraction CAP - SM. \n/// You should find the strongest extension\
    \ and return a string in this \n/// format: ClassName.StrongestExtensionName.\n\
    /// If there are two or more extensions with the same strength, you should\n///\
    \ choose the one that comes first in the array.\n/// For example, if you are given\
    \ \"Slices\" as the class and an array of the\n/// extensions: ['SErviNGSliCes',\
    \ 'Cheese', 'StuFfed'] then you should\n/// return 'Slices.SErviNGSliCes' since\
    \ 'SErviNGSliCes' is the strongest extension \n/// (its strength is -1).\n///\
    \ Example:\n/// >>> Strongest_Extension(class_name: \"my_class\", extensions:\
    \ [\"AA\", \"Be\", \"CC\"])\n/// \"my_class.AA\"\nfunc Strongest_Extension(class_name:\
    \ String, extensions: [String]) -> String {\n    var class_extensions = [String:\
    \ Int]()\n    for item in extensions {\n        let capital_letters = item.filter\
    \ { $0.isUppercase }\n        let small_letters = item.filter { $0.isLowercase\
    \ }\n        class_extensions[item] = capital_letters.count - small_letters.count\n\
    \    }\n    let sorted_class_extensions = class_extensions.sorted { $0.value >\
    \ $1.value }\n    return class_name + \".\" + sorted_class_extensions[0].key\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(Strongest_Extension(class_name: \"Watashi\", extensions:\
    \ [\"tEN\", \"niNE\", \"eIGHt8OKe\"]) == \"Watashi.eIGHt8OKe\")\nassert(Strongest_Extension(class_name:\
    \ \"Boku123\", extensions: [\"nani\", \"NazeDa\", \"YEs.WeCaNe\", \"32145tggg\"\
    ]) == \"Boku123.YEs.WeCaNe\")\nassert(Strongest_Extension(class_name: \"__YESIMHERE\"\
    , extensions: [\"t\", \"eMptY\", \"nothing\", \"zeR00\", \"NuLl__\", \"123NoooneB321\"\
    ]) == \"__YESIMHERE.NuLl__\")\nassert(Strongest_Extension(class_name: \"K\", extensions:\
    \ [\"Ta\", \"TAR\", \"t234An\", \"cosSo\"]) == \"K.TAR\")\nassert(Strongest_Extension(class_name:\
    \ \"__HAHA\", extensions: [\"Tab\", \"123\", \"781345\", \"-_-\"]) == \"__HAHA.123\"\
    )\nassert(Strongest_Extension(class_name: \"YameRore\", extensions: [\"HhAas\"\
    , \"okIWILL123\", \"WorkOut\", \"Fails\", \"-_-\"]) == \"YameRore.okIWILL123\"\
    )\nassert(Strongest_Extension(class_name: \"finNNalLLly\", extensions: [\"Die\"\
    , \"NowW\", \"Wow\", \"WoW\"]) == \"finNNalLLly.WoW\")\nassert(Strongest_Extension(class_name:\
    \ \"_\", extensions: [\"Bb\", \"91245\"]) == \"_.Bb\")\nassert(Strongest_Extension(class_name:\
    \ \"Sp\", extensions: [\"671235\", \"Bb\"]) == \"Sp.671235\")"
  status: Exception
  stderr: 'tmp6l83hphk/tmp6l83hphk.swift:46: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002ac687ce8c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002ac6879dfb6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002ac6879df988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002ac6879de7b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmp6l83hphk                        0x0000560c071bc2fa <unavailable> + 8954

    5    libc.so.6                          0x00002ac687ed4460 __libc_start_main +
    245

    6    tmp6l83hphk                        0x0000560c071bb5c9 <unavailable> + 5577

    '
  stdout: ''
  timestamp: 1660009434
- exit_code: 1
  program: "\n/// You will be given the name of a class (a string) and an array of\
    \ extensions.\n/// The extensions are to be used to load additional classes to\
    \ the class. The\n/// strength of the extension is as follows: Let CAP be the\
    \ number of the uppercase\n/// letters in the extension's name, and let SM be\
    \ the number of lowercase letters \n/// in the extension's name, the strength\
    \ is given by the fraction CAP - SM. \n/// You should find the strongest extension\
    \ and return a string in this \n/// format: ClassName.StrongestExtensionName.\n\
    /// If there are two or more extensions with the same strength, you should\n///\
    \ choose the one that comes first in the array.\n/// For example, if you are given\
    \ \"Slices\" as the class and an array of the\n/// extensions: ['SErviNGSliCes',\
    \ 'Cheese', 'StuFfed'] then you should\n/// return 'Slices.SErviNGSliCes' since\
    \ 'SErviNGSliCes' is the strongest extension \n/// (its strength is -1).\n///\
    \ Example:\n/// >>> Strongest_Extension(class_name: \"my_class\", extensions:\
    \ [\"AA\", \"Be\", \"CC\"])\n/// \"my_class.AA\"\nfunc Strongest_Extension(class_name:\
    \ String, extensions: [String]) -> String {\n    // Fill out this function!\n\
    \    var strongest = extensions[0]\n    var strongestStrength = strongest.count_upper_case()\
    \ - strongest.count_lower_case()\n    var currentStrength = 0\n    for (i, current)\
    \ in extensions.enumerated() {\n        currentStrength = current.count_upper_case()\
    \ - current.count_lower_case()\n        if currentStrength > strongestStrength\
    \ {\n            strongest = current\n            strongestStrength = currentStrength\n\
    \        }\n    }\n    let className = class_name\n    let strongestExtension\
    \ = strongest\n    return className + \".\" + strongestExtension\n}\n\n\nfunc\
    \ ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count !=\
    \ right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(Strongest_Extension(class_name: \"Watashi\", extensions:\
    \ [\"tEN\", \"niNE\", \"eIGHt8OKe\"]) == \"Watashi.eIGHt8OKe\")\nassert(Strongest_Extension(class_name:\
    \ \"Boku123\", extensions: [\"nani\", \"NazeDa\", \"YEs.WeCaNe\", \"32145tggg\"\
    ]) == \"Boku123.YEs.WeCaNe\")\nassert(Strongest_Extension(class_name: \"__YESIMHERE\"\
    , extensions: [\"t\", \"eMptY\", \"nothing\", \"zeR00\", \"NuLl__\", \"123NoooneB321\"\
    ]) == \"__YESIMHERE.NuLl__\")\nassert(Strongest_Extension(class_name: \"K\", extensions:\
    \ [\"Ta\", \"TAR\", \"t234An\", \"cosSo\"]) == \"K.TAR\")\nassert(Strongest_Extension(class_name:\
    \ \"__HAHA\", extensions: [\"Tab\", \"123\", \"781345\", \"-_-\"]) == \"__HAHA.123\"\
    )\nassert(Strongest_Extension(class_name: \"YameRore\", extensions: [\"HhAas\"\
    , \"okIWILL123\", \"WorkOut\", \"Fails\", \"-_-\"]) == \"YameRore.okIWILL123\"\
    )\nassert(Strongest_Extension(class_name: \"finNNalLLly\", extensions: [\"Die\"\
    , \"NowW\", \"Wow\", \"WoW\"]) == \"finNNalLLly.WoW\")\nassert(Strongest_Extension(class_name:\
    \ \"_\", extensions: [\"Bb\", \"91245\"]) == \"_.Bb\")\nassert(Strongest_Extension(class_name:\
    \ \"Sp\", extensions: [\"671235\", \"Bb\"]) == \"Sp.671235\")"
  status: SyntaxError
  stderr: "/tmp/tmpikky5x22.swift:21:39: error: value of type 'String' has no member\
    \ 'count_upper_case'\n    var strongestStrength = strongest.count_upper_case()\
    \ - strongest.count_lower_case()\n                            ~~~~~~~~~ ^~~~~~~~~~~~~~~~\n\
    /tmp/tmpikky5x22.swift:21:70: error: value of type 'String' has no member 'count_lower_case'\n\
    \    var strongestStrength = strongest.count_upper_case() - strongest.count_lower_case()\n\
    \                                                           ~~~~~~~~~ ^~~~~~~~~~~~~~~~\n\
    /tmp/tmpikky5x22.swift:24:35: error: value of type 'String' has no member 'count_upper_case'\n\
    \        currentStrength = current.count_upper_case() - current.count_lower_case()\n\
    \                          ~~~~~~~ ^~~~~~~~~~~~~~~~\n/tmp/tmpikky5x22.swift:24:64:\
    \ error: value of type 'String' has no member 'count_lower_case'\n        currentStrength\
    \ = current.count_upper_case() - current.count_lower_case()\n                \
    \                                       ~~~~~~~ ^~~~~~~~~~~~~~~~\n"
  stdout: ''
  timestamp: 1660009434
- exit_code: -4
  program: "\n/// You will be given the name of a class (a string) and an array of\
    \ extensions.\n/// The extensions are to be used to load additional classes to\
    \ the class. The\n/// strength of the extension is as follows: Let CAP be the\
    \ number of the uppercase\n/// letters in the extension's name, and let SM be\
    \ the number of lowercase letters \n/// in the extension's name, the strength\
    \ is given by the fraction CAP - SM. \n/// You should find the strongest extension\
    \ and return a string in this \n/// format: ClassName.StrongestExtensionName.\n\
    /// If there are two or more extensions with the same strength, you should\n///\
    \ choose the one that comes first in the array.\n/// For example, if you are given\
    \ \"Slices\" as the class and an array of the\n/// extensions: ['SErviNGSliCes',\
    \ 'Cheese', 'StuFfed'] then you should\n/// return 'Slices.SErviNGSliCes' since\
    \ 'SErviNGSliCes' is the strongest extension \n/// (its strength is -1).\n///\
    \ Example:\n/// >>> Strongest_Extension(class_name: \"my_class\", extensions:\
    \ [\"AA\", \"Be\", \"CC\"])\n/// \"my_class.AA\"\nfunc Strongest_Extension(class_name:\
    \ String, extensions: [String]) -> String {\n    var strongest_class_extension\
    \ = \"\"\n    var strongest_strength = Double.infinity\n    var current_strength\
    \ = 0.0\n    for extension_name in extensions {\n        current_strength = Double(extension_name.filter({$0.isUppercase}).count\
    \ - extension_name.filter({$0.isLowercase}).count)\n        if current_strength\
    \ == 0 { continue }\n        if current_strength < strongest_strength {\n    \
    \        strongest_strength = current_strength\n            strongest_class_extension\
    \ = extension_name\n        }\n    }\n    return class_name + \".\" + strongest_class_extension\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(Strongest_Extension(class_name: \"Watashi\", extensions:\
    \ [\"tEN\", \"niNE\", \"eIGHt8OKe\"]) == \"Watashi.eIGHt8OKe\")\nassert(Strongest_Extension(class_name:\
    \ \"Boku123\", extensions: [\"nani\", \"NazeDa\", \"YEs.WeCaNe\", \"32145tggg\"\
    ]) == \"Boku123.YEs.WeCaNe\")\nassert(Strongest_Extension(class_name: \"__YESIMHERE\"\
    , extensions: [\"t\", \"eMptY\", \"nothing\", \"zeR00\", \"NuLl__\", \"123NoooneB321\"\
    ]) == \"__YESIMHERE.NuLl__\")\nassert(Strongest_Extension(class_name: \"K\", extensions:\
    \ [\"Ta\", \"TAR\", \"t234An\", \"cosSo\"]) == \"K.TAR\")\nassert(Strongest_Extension(class_name:\
    \ \"__HAHA\", extensions: [\"Tab\", \"123\", \"781345\", \"-_-\"]) == \"__HAHA.123\"\
    )\nassert(Strongest_Extension(class_name: \"YameRore\", extensions: [\"HhAas\"\
    , \"okIWILL123\", \"WorkOut\", \"Fails\", \"-_-\"]) == \"YameRore.okIWILL123\"\
    )\nassert(Strongest_Extension(class_name: \"finNNalLLly\", extensions: [\"Die\"\
    , \"NowW\", \"Wow\", \"WoW\"]) == \"finNNalLLly.WoW\")\nassert(Strongest_Extension(class_name:\
    \ \"_\", extensions: [\"Bb\", \"91245\"]) == \"_.Bb\")\nassert(Strongest_Extension(class_name:\
    \ \"Sp\", extensions: [\"671235\", \"Bb\"]) == \"Sp.671235\")"
  status: Exception
  stderr: 'tmpqhhddp05/tmpqhhddp05.swift:46: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b3a4ed19c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b3a4ea10b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b3a4ea10988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b3a4ea0f7b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpqhhddp05                        0x000055a97be578ad <unavailable> + 6317

    5    libc.so.6                          0x00002b3a4ef05460 __libc_start_main +
    245

    6    tmpqhhddp05                        0x000055a97be57439 <unavailable> + 5177

    '
  stdout: ''
  timestamp: 1660009434
- exit_code: -4
  program: "\n/// You will be given the name of a class (a string) and an array of\
    \ extensions.\n/// The extensions are to be used to load additional classes to\
    \ the class. The\n/// strength of the extension is as follows: Let CAP be the\
    \ number of the uppercase\n/// letters in the extension's name, and let SM be\
    \ the number of lowercase letters \n/// in the extension's name, the strength\
    \ is given by the fraction CAP - SM. \n/// You should find the strongest extension\
    \ and return a string in this \n/// format: ClassName.StrongestExtensionName.\n\
    /// If there are two or more extensions with the same strength, you should\n///\
    \ choose the one that comes first in the array.\n/// For example, if you are given\
    \ \"Slices\" as the class and an array of the\n/// extensions: ['SErviNGSliCes',\
    \ 'Cheese', 'StuFfed'] then you should\n/// return 'Slices.SErviNGSliCes' since\
    \ 'SErviNGSliCes' is the strongest extension \n/// (its strength is -1).\n///\
    \ Example:\n/// >>> Strongest_Extension(class_name: \"my_class\", extensions:\
    \ [\"AA\", \"Be\", \"CC\"])\n/// \"my_class.AA\"\nfunc Strongest_Extension(class_name:\
    \ String, extensions: [String]) -> String {\n    var strongest_extension = \"\"\
    \n    var strongest_strength = 0.0\n    for extension_name in extensions {\n \
    \       let strength = Double(extension_name.filter{$0.isUppercase}.count) - Double(extension_name.filter{$0.isLowercase}.count)\n\
    \        if strength > strongest_strength {\n            strongest_strength =\
    \ strength\n            strongest_extension = extension_name\n        }\n    }\n\
    \    return class_name + \".\" + strongest_extension\n}\n\n\nfunc ==(left: [(Int,\
    \ Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n\
    \        return false\n    }\n    for (l, r) in zip(left, right) {\n        if\
    \ l != r {\n            return false\n        }\n    }\n    return true\n}\n \
    \           \nassert(Strongest_Extension(class_name: \"Watashi\", extensions:\
    \ [\"tEN\", \"niNE\", \"eIGHt8OKe\"]) == \"Watashi.eIGHt8OKe\")\nassert(Strongest_Extension(class_name:\
    \ \"Boku123\", extensions: [\"nani\", \"NazeDa\", \"YEs.WeCaNe\", \"32145tggg\"\
    ]) == \"Boku123.YEs.WeCaNe\")\nassert(Strongest_Extension(class_name: \"__YESIMHERE\"\
    , extensions: [\"t\", \"eMptY\", \"nothing\", \"zeR00\", \"NuLl__\", \"123NoooneB321\"\
    ]) == \"__YESIMHERE.NuLl__\")\nassert(Strongest_Extension(class_name: \"K\", extensions:\
    \ [\"Ta\", \"TAR\", \"t234An\", \"cosSo\"]) == \"K.TAR\")\nassert(Strongest_Extension(class_name:\
    \ \"__HAHA\", extensions: [\"Tab\", \"123\", \"781345\", \"-_-\"]) == \"__HAHA.123\"\
    )\nassert(Strongest_Extension(class_name: \"YameRore\", extensions: [\"HhAas\"\
    , \"okIWILL123\", \"WorkOut\", \"Fails\", \"-_-\"]) == \"YameRore.okIWILL123\"\
    )\nassert(Strongest_Extension(class_name: \"finNNalLLly\", extensions: [\"Die\"\
    , \"NowW\", \"Wow\", \"WoW\"]) == \"finNNalLLly.WoW\")\nassert(Strongest_Extension(class_name:\
    \ \"_\", extensions: [\"Bb\", \"91245\"]) == \"_.Bb\")\nassert(Strongest_Extension(class_name:\
    \ \"Sp\", extensions: [\"671235\", \"Bb\"]) == \"Sp.671235\")"
  status: Exception
  stderr: 'tmpv41qogo_/tmpv41qogo_.swift:46: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b0aac9f5c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b0aac6ecb6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b0aac6ec988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b0aac6eb7b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpv41qogo_                        0x00005615585e8cdc <unavailable> + 7388

    5    libc.so.6                          0x00002b0aacbe1460 __libc_start_main +
    245

    6    tmpv41qogo_                        0x00005615585e83e9 <unavailable> + 5097

    '
  stdout: ''
  timestamp: 1660009434
- exit_code: -4
  program: "\n/// You will be given the name of a class (a string) and an array of\
    \ extensions.\n/// The extensions are to be used to load additional classes to\
    \ the class. The\n/// strength of the extension is as follows: Let CAP be the\
    \ number of the uppercase\n/// letters in the extension's name, and let SM be\
    \ the number of lowercase letters \n/// in the extension's name, the strength\
    \ is given by the fraction CAP - SM. \n/// You should find the strongest extension\
    \ and return a string in this \n/// format: ClassName.StrongestExtensionName.\n\
    /// If there are two or more extensions with the same strength, you should\n///\
    \ choose the one that comes first in the array.\n/// For example, if you are given\
    \ \"Slices\" as the class and an array of the\n/// extensions: ['SErviNGSliCes',\
    \ 'Cheese', 'StuFfed'] then you should\n/// return 'Slices.SErviNGSliCes' since\
    \ 'SErviNGSliCes' is the strongest extension \n/// (its strength is -1).\n///\
    \ Example:\n/// >>> Strongest_Extension(class_name: \"my_class\", extensions:\
    \ [\"AA\", \"Be\", \"CC\"])\n/// \"my_class.AA\"\nfunc Strongest_Extension(class_name:\
    \ String, extensions: [String]) -> String {\n    var strongest = \"\"\n    var\
    \ greatest = 0\n    for ext in extensions {\n        var strength = 0\n      \
    \  for letter in ext {\n            if letter.isUppercase {\n                strength\
    \ += 1\n            } else {\n                strength -= 1\n            }\n \
    \       }\n        if strength >= greatest {\n            greatest = strength\n\
    \            strongest = ext\n        }\n    }\n    return class_name + \".\"\
    \ + strongest\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool\
    \ {\n    if left.count != right.count {\n        return false\n    }\n    for\
    \ (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(Strongest_Extension(class_name:\
    \ \"Watashi\", extensions: [\"tEN\", \"niNE\", \"eIGHt8OKe\"]) == \"Watashi.eIGHt8OKe\"\
    )\nassert(Strongest_Extension(class_name: \"Boku123\", extensions: [\"nani\",\
    \ \"NazeDa\", \"YEs.WeCaNe\", \"32145tggg\"]) == \"Boku123.YEs.WeCaNe\")\nassert(Strongest_Extension(class_name:\
    \ \"__YESIMHERE\", extensions: [\"t\", \"eMptY\", \"nothing\", \"zeR00\", \"NuLl__\"\
    , \"123NoooneB321\"]) == \"__YESIMHERE.NuLl__\")\nassert(Strongest_Extension(class_name:\
    \ \"K\", extensions: [\"Ta\", \"TAR\", \"t234An\", \"cosSo\"]) == \"K.TAR\")\n\
    assert(Strongest_Extension(class_name: \"__HAHA\", extensions: [\"Tab\", \"123\"\
    , \"781345\", \"-_-\"]) == \"__HAHA.123\")\nassert(Strongest_Extension(class_name:\
    \ \"YameRore\", extensions: [\"HhAas\", \"okIWILL123\", \"WorkOut\", \"Fails\"\
    , \"-_-\"]) == \"YameRore.okIWILL123\")\nassert(Strongest_Extension(class_name:\
    \ \"finNNalLLly\", extensions: [\"Die\", \"NowW\", \"Wow\", \"WoW\"]) == \"finNNalLLly.WoW\"\
    )\nassert(Strongest_Extension(class_name: \"_\", extensions: [\"Bb\", \"91245\"\
    ]) == \"_.Bb\")\nassert(Strongest_Extension(class_name: \"Sp\", extensions: [\"\
    671235\", \"Bb\"]) == \"Sp.671235\")"
  status: Exception
  stderr: 'tmpfilbctya/tmpfilbctya.swift:53: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002ab08053fc80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002ab080236b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002ab080236988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002ab0802357b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpfilbctya                        0x00005570e547ec4c <unavailable> + 7244

    5    libc.so.6                          0x00002ab08072b460 __libc_start_main +
    245

    6    tmpfilbctya                        0x00005570e547e359 <unavailable> + 4953

    '
  stdout: ''
  timestamp: 1660009434
- exit_code: 0
  program: "\n/// You will be given the name of a class (a string) and an array of\
    \ extensions.\n/// The extensions are to be used to load additional classes to\
    \ the class. The\n/// strength of the extension is as follows: Let CAP be the\
    \ number of the uppercase\n/// letters in the extension's name, and let SM be\
    \ the number of lowercase letters \n/// in the extension's name, the strength\
    \ is given by the fraction CAP - SM. \n/// You should find the strongest extension\
    \ and return a string in this \n/// format: ClassName.StrongestExtensionName.\n\
    /// If there are two or more extensions with the same strength, you should\n///\
    \ choose the one that comes first in the array.\n/// For example, if you are given\
    \ \"Slices\" as the class and an array of the\n/// extensions: ['SErviNGSliCes',\
    \ 'Cheese', 'StuFfed'] then you should\n/// return 'Slices.SErviNGSliCes' since\
    \ 'SErviNGSliCes' is the strongest extension \n/// (its strength is -1).\n///\
    \ Example:\n/// >>> Strongest_Extension(class_name: \"my_class\", extensions:\
    \ [\"AA\", \"Be\", \"CC\"])\n/// \"my_class.AA\"\nfunc Strongest_Extension(class_name:\
    \ String, extensions: [String]) -> String {\n    return class_name + \".\" + extensions.sorted(by:\
    \ { (s1, s2) -> Bool in\n        let s1strength = s1.filter({ $0.isUppercase }).count\
    \ - s1.filter({ $0.isLowercase }).count\n        let s2strength = s2.filter({\
    \ $0.isUppercase }).count - s2.filter({ $0.isLowercase }).count\n        return\
    \ s1strength > s2strength\n    }).first!\n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(Strongest_Extension(class_name: \"Watashi\", extensions: [\"tEN\", \"niNE\"\
    , \"eIGHt8OKe\"]) == \"Watashi.eIGHt8OKe\")\nassert(Strongest_Extension(class_name:\
    \ \"Boku123\", extensions: [\"nani\", \"NazeDa\", \"YEs.WeCaNe\", \"32145tggg\"\
    ]) == \"Boku123.YEs.WeCaNe\")\nassert(Strongest_Extension(class_name: \"__YESIMHERE\"\
    , extensions: [\"t\", \"eMptY\", \"nothing\", \"zeR00\", \"NuLl__\", \"123NoooneB321\"\
    ]) == \"__YESIMHERE.NuLl__\")\nassert(Strongest_Extension(class_name: \"K\", extensions:\
    \ [\"Ta\", \"TAR\", \"t234An\", \"cosSo\"]) == \"K.TAR\")\nassert(Strongest_Extension(class_name:\
    \ \"__HAHA\", extensions: [\"Tab\", \"123\", \"781345\", \"-_-\"]) == \"__HAHA.123\"\
    )\nassert(Strongest_Extension(class_name: \"YameRore\", extensions: [\"HhAas\"\
    , \"okIWILL123\", \"WorkOut\", \"Fails\", \"-_-\"]) == \"YameRore.okIWILL123\"\
    )\nassert(Strongest_Extension(class_name: \"finNNalLLly\", extensions: [\"Die\"\
    , \"NowW\", \"Wow\", \"WoW\"]) == \"finNNalLLly.WoW\")\nassert(Strongest_Extension(class_name:\
    \ \"_\", extensions: [\"Bb\", \"91245\"]) == \"_.Bb\")\nassert(Strongest_Extension(class_name:\
    \ \"Sp\", extensions: [\"671235\", \"Bb\"]) == \"Sp.671235\")"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660009434
- exit_code: -4
  program: "\n/// You will be given the name of a class (a string) and an array of\
    \ extensions.\n/// The extensions are to be used to load additional classes to\
    \ the class. The\n/// strength of the extension is as follows: Let CAP be the\
    \ number of the uppercase\n/// letters in the extension's name, and let SM be\
    \ the number of lowercase letters \n/// in the extension's name, the strength\
    \ is given by the fraction CAP - SM. \n/// You should find the strongest extension\
    \ and return a string in this \n/// format: ClassName.StrongestExtensionName.\n\
    /// If there are two or more extensions with the same strength, you should\n///\
    \ choose the one that comes first in the array.\n/// For example, if you are given\
    \ \"Slices\" as the class and an array of the\n/// extensions: ['SErviNGSliCes',\
    \ 'Cheese', 'StuFfed'] then you should\n/// return 'Slices.SErviNGSliCes' since\
    \ 'SErviNGSliCes' is the strongest extension \n/// (its strength is -1).\n///\
    \ Example:\n/// >>> Strongest_Extension(class_name: \"my_class\", extensions:\
    \ [\"AA\", \"Be\", \"CC\"])\n/// \"my_class.AA\"\nfunc Strongest_Extension(class_name:\
    \ String, extensions: [String]) -> String {\n    var strongest_extension = extensions[0]\n\
    \    var strength = 0\n    var upper_case_count = 0\n    var lower_case_count\
    \ = 0\n    for index in 0..<extensions.count {\n        var ext = extensions[index]\n\
    \        for letter in ext {\n            if letter.isUppercase {\n          \
    \      upper_case_count += 1\n            } else {\n                lower_case_count\
    \ += 1\n            }\n        }\n        var new_strength = upper_case_count\
    \ - lower_case_count\n        if strength < new_strength {\n            strength\
    \ = new_strength\n            strongest_extension = ext\n        }\n        upper_case_count\
    \ = 0\n        lower_case_count = 0\n    }\n    return \"\\(class_name).\\(strongest_extension)\"\
    \n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(Strongest_Extension(class_name: \"Watashi\", extensions:\
    \ [\"tEN\", \"niNE\", \"eIGHt8OKe\"]) == \"Watashi.eIGHt8OKe\")\nassert(Strongest_Extension(class_name:\
    \ \"Boku123\", extensions: [\"nani\", \"NazeDa\", \"YEs.WeCaNe\", \"32145tggg\"\
    ]) == \"Boku123.YEs.WeCaNe\")\nassert(Strongest_Extension(class_name: \"__YESIMHERE\"\
    , extensions: [\"t\", \"eMptY\", \"nothing\", \"zeR00\", \"NuLl__\", \"123NoooneB321\"\
    ]) == \"__YESIMHERE.NuLl__\")\nassert(Strongest_Extension(class_name: \"K\", extensions:\
    \ [\"Ta\", \"TAR\", \"t234An\", \"cosSo\"]) == \"K.TAR\")\nassert(Strongest_Extension(class_name:\
    \ \"__HAHA\", extensions: [\"Tab\", \"123\", \"781345\", \"-_-\"]) == \"__HAHA.123\"\
    )\nassert(Strongest_Extension(class_name: \"YameRore\", extensions: [\"HhAas\"\
    , \"okIWILL123\", \"WorkOut\", \"Fails\", \"-_-\"]) == \"YameRore.okIWILL123\"\
    )\nassert(Strongest_Extension(class_name: \"finNNalLLly\", extensions: [\"Die\"\
    , \"NowW\", \"Wow\", \"WoW\"]) == \"finNNalLLly.WoW\")\nassert(Strongest_Extension(class_name:\
    \ \"_\", extensions: [\"Bb\", \"91245\"]) == \"_.Bb\")\nassert(Strongest_Extension(class_name:\
    \ \"Sp\", extensions: [\"671235\", \"Bb\"]) == \"Sp.671235\")"
  status: Exception
  stderr: 'tmp0kohm968/tmp0kohm968.swift:56: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b360e4fec80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b360e1f5b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b360e1f5988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b360e1f47b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmp0kohm968                        0x000055bd7f0d9b0d <unavailable> + 6925

    5    libc.so.6                          0x00002b360e6ea460 __libc_start_main +
    245

    6    tmp0kohm968                        0x000055bd7f0d9699 <unavailable> + 5785

    '
  stdout: ''
  timestamp: 1660009434
- exit_code: -4
  program: "\n/// You will be given the name of a class (a string) and an array of\
    \ extensions.\n/// The extensions are to be used to load additional classes to\
    \ the class. The\n/// strength of the extension is as follows: Let CAP be the\
    \ number of the uppercase\n/// letters in the extension's name, and let SM be\
    \ the number of lowercase letters \n/// in the extension's name, the strength\
    \ is given by the fraction CAP - SM. \n/// You should find the strongest extension\
    \ and return a string in this \n/// format: ClassName.StrongestExtensionName.\n\
    /// If there are two or more extensions with the same strength, you should\n///\
    \ choose the one that comes first in the array.\n/// For example, if you are given\
    \ \"Slices\" as the class and an array of the\n/// extensions: ['SErviNGSliCes',\
    \ 'Cheese', 'StuFfed'] then you should\n/// return 'Slices.SErviNGSliCes' since\
    \ 'SErviNGSliCes' is the strongest extension \n/// (its strength is -1).\n///\
    \ Example:\n/// >>> Strongest_Extension(class_name: \"my_class\", extensions:\
    \ [\"AA\", \"Be\", \"CC\"])\n/// \"my_class.AA\"\nfunc Strongest_Extension(class_name:\
    \ String, extensions: [String]) -> String {\n    var max_strength: Double = -1\n\
    \    var strongest_extension = \"\"\n    for extension_ in extensions {\n    \
    \    var cap_num = 0\n        var sm_num = 0\n        for char in extension_ {\n\
    \            if char.isUppercase {\n                cap_num += 1\n           \
    \ } else {\n                sm_num += 1\n            }\n        }\n        if\
    \ Double(cap_num - sm_num) > max_strength {\n            max_strength = Double(cap_num\
    \ - sm_num)\n            strongest_extension = extension_\n        }\n    }\n\
    \    return class_name + \".\" + strongest_extension\n}\n\n\nfunc ==(left: [(Int,\
    \ Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n\
    \        return false\n    }\n    for (l, r) in zip(left, right) {\n        if\
    \ l != r {\n            return false\n        }\n    }\n    return true\n}\n \
    \           \nassert(Strongest_Extension(class_name: \"Watashi\", extensions:\
    \ [\"tEN\", \"niNE\", \"eIGHt8OKe\"]) == \"Watashi.eIGHt8OKe\")\nassert(Strongest_Extension(class_name:\
    \ \"Boku123\", extensions: [\"nani\", \"NazeDa\", \"YEs.WeCaNe\", \"32145tggg\"\
    ]) == \"Boku123.YEs.WeCaNe\")\nassert(Strongest_Extension(class_name: \"__YESIMHERE\"\
    , extensions: [\"t\", \"eMptY\", \"nothing\", \"zeR00\", \"NuLl__\", \"123NoooneB321\"\
    ]) == \"__YESIMHERE.NuLl__\")\nassert(Strongest_Extension(class_name: \"K\", extensions:\
    \ [\"Ta\", \"TAR\", \"t234An\", \"cosSo\"]) == \"K.TAR\")\nassert(Strongest_Extension(class_name:\
    \ \"__HAHA\", extensions: [\"Tab\", \"123\", \"781345\", \"-_-\"]) == \"__HAHA.123\"\
    )\nassert(Strongest_Extension(class_name: \"YameRore\", extensions: [\"HhAas\"\
    , \"okIWILL123\", \"WorkOut\", \"Fails\", \"-_-\"]) == \"YameRore.okIWILL123\"\
    )\nassert(Strongest_Extension(class_name: \"finNNalLLly\", extensions: [\"Die\"\
    , \"NowW\", \"Wow\", \"WoW\"]) == \"finNNalLLly.WoW\")\nassert(Strongest_Extension(class_name:\
    \ \"_\", extensions: [\"Bb\", \"91245\"]) == \"_.Bb\")\nassert(Strongest_Extension(class_name:\
    \ \"Sp\", extensions: [\"671235\", \"Bb\"]) == \"Sp.671235\")"
  status: Exception
  stderr: 'tmpfvwlmixs/tmpfvwlmixs.swift:52: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b266b0efc80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b266ade6b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b266ade6988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b266ade57b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpfvwlmixs                        0x000055c92438e7cd <unavailable> + 6093

    5    libc.so.6                          0x00002b266b2db460 __libc_start_main +
    245

    6    tmpfvwlmixs                        0x000055c92438e359 <unavailable> + 4953

    '
  stdout: ''
  timestamp: 1660009434
- exit_code: 0
  program: "\n/// You will be given the name of a class (a string) and an array of\
    \ extensions.\n/// The extensions are to be used to load additional classes to\
    \ the class. The\n/// strength of the extension is as follows: Let CAP be the\
    \ number of the uppercase\n/// letters in the extension's name, and let SM be\
    \ the number of lowercase letters \n/// in the extension's name, the strength\
    \ is given by the fraction CAP - SM. \n/// You should find the strongest extension\
    \ and return a string in this \n/// format: ClassName.StrongestExtensionName.\n\
    /// If there are two or more extensions with the same strength, you should\n///\
    \ choose the one that comes first in the array.\n/// For example, if you are given\
    \ \"Slices\" as the class and an array of the\n/// extensions: ['SErviNGSliCes',\
    \ 'Cheese', 'StuFfed'] then you should\n/// return 'Slices.SErviNGSliCes' since\
    \ 'SErviNGSliCes' is the strongest extension \n/// (its strength is -1).\n///\
    \ Example:\n/// >>> Strongest_Extension(class_name: \"my_class\", extensions:\
    \ [\"AA\", \"Be\", \"CC\"])\n/// \"my_class.AA\"\nfunc Strongest_Extension(class_name:\
    \ String, extensions: [String]) -> String {\n    var current_strength = -Double.infinity\n\
    \    var strongest_extension = \"\"\n    for extension_name in extensions {\n\
    \        let capitals = extension_name.filter { $0.isUppercase }\n        let\
    \ smalls = extension_name.filter { $0.isLowercase }\n        let strength = Double(capitals.count)\
    \ - Double(smalls.count)\n        if strength > current_strength {\n         \
    \   current_strength = strength\n            strongest_extension = extension_name\n\
    \        }\n    }\n    return \"\\(class_name).\\(strongest_extension)\"\n}\n\n\
    \nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(Strongest_Extension(class_name: \"Watashi\", extensions:\
    \ [\"tEN\", \"niNE\", \"eIGHt8OKe\"]) == \"Watashi.eIGHt8OKe\")\nassert(Strongest_Extension(class_name:\
    \ \"Boku123\", extensions: [\"nani\", \"NazeDa\", \"YEs.WeCaNe\", \"32145tggg\"\
    ]) == \"Boku123.YEs.WeCaNe\")\nassert(Strongest_Extension(class_name: \"__YESIMHERE\"\
    , extensions: [\"t\", \"eMptY\", \"nothing\", \"zeR00\", \"NuLl__\", \"123NoooneB321\"\
    ]) == \"__YESIMHERE.NuLl__\")\nassert(Strongest_Extension(class_name: \"K\", extensions:\
    \ [\"Ta\", \"TAR\", \"t234An\", \"cosSo\"]) == \"K.TAR\")\nassert(Strongest_Extension(class_name:\
    \ \"__HAHA\", extensions: [\"Tab\", \"123\", \"781345\", \"-_-\"]) == \"__HAHA.123\"\
    )\nassert(Strongest_Extension(class_name: \"YameRore\", extensions: [\"HhAas\"\
    , \"okIWILL123\", \"WorkOut\", \"Fails\", \"-_-\"]) == \"YameRore.okIWILL123\"\
    )\nassert(Strongest_Extension(class_name: \"finNNalLLly\", extensions: [\"Die\"\
    , \"NowW\", \"Wow\", \"WoW\"]) == \"finNNalLLly.WoW\")\nassert(Strongest_Extension(class_name:\
    \ \"_\", extensions: [\"Bb\", \"91245\"]) == \"_.Bb\")\nassert(Strongest_Extension(class_name:\
    \ \"Sp\", extensions: [\"671235\", \"Bb\"]) == \"Sp.671235\")"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660009435
- exit_code: 0
  program: "\n/// You will be given the name of a class (a string) and an array of\
    \ extensions.\n/// The extensions are to be used to load additional classes to\
    \ the class. The\n/// strength of the extension is as follows: Let CAP be the\
    \ number of the uppercase\n/// letters in the extension's name, and let SM be\
    \ the number of lowercase letters \n/// in the extension's name, the strength\
    \ is given by the fraction CAP - SM. \n/// You should find the strongest extension\
    \ and return a string in this \n/// format: ClassName.StrongestExtensionName.\n\
    /// If there are two or more extensions with the same strength, you should\n///\
    \ choose the one that comes first in the array.\n/// For example, if you are given\
    \ \"Slices\" as the class and an array of the\n/// extensions: ['SErviNGSliCes',\
    \ 'Cheese', 'StuFfed'] then you should\n/// return 'Slices.SErviNGSliCes' since\
    \ 'SErviNGSliCes' is the strongest extension \n/// (its strength is -1).\n///\
    \ Example:\n/// >>> Strongest_Extension(class_name: \"my_class\", extensions:\
    \ [\"AA\", \"Be\", \"CC\"])\n/// \"my_class.AA\"\nfunc Strongest_Extension(class_name:\
    \ String, extensions: [String]) -> String {\n    let strength = extensions.map\
    \ { extension_name in\n        let capital_count = extension_name.filter { $0.isUppercase\
    \ }.count\n        let small_count = extension_name.filter { $0.isLowercase }.count\n\
    \        return (extension_name, capital_count - small_count)\n    }\n    var\
    \ strongest_extension_name = \"\"\n    var strongest_extension_strength = Int.min\n\
    \    for ext in strength {\n        if ext.1 > strongest_extension_strength {\n\
    \            strongest_extension_name = ext.0\n            strongest_extension_strength\
    \ = ext.1\n        }\n    }\n    return \"\\(class_name).\\(strongest_extension_name)\"\
    \n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(Strongest_Extension(class_name: \"Watashi\", extensions:\
    \ [\"tEN\", \"niNE\", \"eIGHt8OKe\"]) == \"Watashi.eIGHt8OKe\")\nassert(Strongest_Extension(class_name:\
    \ \"Boku123\", extensions: [\"nani\", \"NazeDa\", \"YEs.WeCaNe\", \"32145tggg\"\
    ]) == \"Boku123.YEs.WeCaNe\")\nassert(Strongest_Extension(class_name: \"__YESIMHERE\"\
    , extensions: [\"t\", \"eMptY\", \"nothing\", \"zeR00\", \"NuLl__\", \"123NoooneB321\"\
    ]) == \"__YESIMHERE.NuLl__\")\nassert(Strongest_Extension(class_name: \"K\", extensions:\
    \ [\"Ta\", \"TAR\", \"t234An\", \"cosSo\"]) == \"K.TAR\")\nassert(Strongest_Extension(class_name:\
    \ \"__HAHA\", extensions: [\"Tab\", \"123\", \"781345\", \"-_-\"]) == \"__HAHA.123\"\
    )\nassert(Strongest_Extension(class_name: \"YameRore\", extensions: [\"HhAas\"\
    , \"okIWILL123\", \"WorkOut\", \"Fails\", \"-_-\"]) == \"YameRore.okIWILL123\"\
    )\nassert(Strongest_Extension(class_name: \"finNNalLLly\", extensions: [\"Die\"\
    , \"NowW\", \"Wow\", \"WoW\"]) == \"finNNalLLly.WoW\")\nassert(Strongest_Extension(class_name:\
    \ \"_\", extensions: [\"Bb\", \"91245\"]) == \"_.Bb\")\nassert(Strongest_Extension(class_name:\
    \ \"Sp\", extensions: [\"671235\", \"Bb\"]) == \"Sp.671235\")"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660009435
- exit_code: 1
  program: "\n/// You will be given the name of a class (a string) and an array of\
    \ extensions.\n/// The extensions are to be used to load additional classes to\
    \ the class. The\n/// strength of the extension is as follows: Let CAP be the\
    \ number of the uppercase\n/// letters in the extension's name, and let SM be\
    \ the number of lowercase letters \n/// in the extension's name, the strength\
    \ is given by the fraction CAP - SM. \n/// You should find the strongest extension\
    \ and return a string in this \n/// format: ClassName.StrongestExtensionName.\n\
    /// If there are two or more extensions with the same strength, you should\n///\
    \ choose the one that comes first in the array.\n/// For example, if you are given\
    \ \"Slices\" as the class and an array of the\n/// extensions: ['SErviNGSliCes',\
    \ 'Cheese', 'StuFfed'] then you should\n/// return 'Slices.SErviNGSliCes' since\
    \ 'SErviNGSliCes' is the strongest extension \n/// (its strength is -1).\n///\
    \ Example:\n/// >>> Strongest_Extension(class_name: \"my_class\", extensions:\
    \ [\"AA\", \"Be\", \"CC\"])\n/// \"my_class.AA\"\nfunc Strongest_Extension(class_name:\
    \ String, extensions: [String]) -> String {\n  return class_name + \".\" + find_strongest_extension(extensions)\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(Strongest_Extension(class_name: \"Watashi\", extensions:\
    \ [\"tEN\", \"niNE\", \"eIGHt8OKe\"]) == \"Watashi.eIGHt8OKe\")\nassert(Strongest_Extension(class_name:\
    \ \"Boku123\", extensions: [\"nani\", \"NazeDa\", \"YEs.WeCaNe\", \"32145tggg\"\
    ]) == \"Boku123.YEs.WeCaNe\")\nassert(Strongest_Extension(class_name: \"__YESIMHERE\"\
    , extensions: [\"t\", \"eMptY\", \"nothing\", \"zeR00\", \"NuLl__\", \"123NoooneB321\"\
    ]) == \"__YESIMHERE.NuLl__\")\nassert(Strongest_Extension(class_name: \"K\", extensions:\
    \ [\"Ta\", \"TAR\", \"t234An\", \"cosSo\"]) == \"K.TAR\")\nassert(Strongest_Extension(class_name:\
    \ \"__HAHA\", extensions: [\"Tab\", \"123\", \"781345\", \"-_-\"]) == \"__HAHA.123\"\
    )\nassert(Strongest_Extension(class_name: \"YameRore\", extensions: [\"HhAas\"\
    , \"okIWILL123\", \"WorkOut\", \"Fails\", \"-_-\"]) == \"YameRore.okIWILL123\"\
    )\nassert(Strongest_Extension(class_name: \"finNNalLLly\", extensions: [\"Die\"\
    , \"NowW\", \"Wow\", \"WoW\"]) == \"finNNalLLly.WoW\")\nassert(Strongest_Extension(class_name:\
    \ \"_\", extensions: [\"Bb\", \"91245\"]) == \"_.Bb\")\nassert(Strongest_Extension(class_name:\
    \ \"Sp\", extensions: [\"671235\", \"Bb\"]) == \"Sp.671235\")"
  status: SyntaxError
  stderr: "/tmp/tmp7dr0e39d.swift:19:29: error: cannot find 'find_strongest_extension'\
    \ in scope\n  return class_name + \".\" + find_strongest_extension(extensions)\n\
    \                            ^~~~~~~~~~~~~~~~~~~~~~~~\n"
  stdout: ''
  timestamp: 1660009434
- exit_code: 0
  program: "\n/// You will be given the name of a class (a string) and an array of\
    \ extensions.\n/// The extensions are to be used to load additional classes to\
    \ the class. The\n/// strength of the extension is as follows: Let CAP be the\
    \ number of the uppercase\n/// letters in the extension's name, and let SM be\
    \ the number of lowercase letters \n/// in the extension's name, the strength\
    \ is given by the fraction CAP - SM. \n/// You should find the strongest extension\
    \ and return a string in this \n/// format: ClassName.StrongestExtensionName.\n\
    /// If there are two or more extensions with the same strength, you should\n///\
    \ choose the one that comes first in the array.\n/// For example, if you are given\
    \ \"Slices\" as the class and an array of the\n/// extensions: ['SErviNGSliCes',\
    \ 'Cheese', 'StuFfed'] then you should\n/// return 'Slices.SErviNGSliCes' since\
    \ 'SErviNGSliCes' is the strongest extension \n/// (its strength is -1).\n///\
    \ Example:\n/// >>> Strongest_Extension(class_name: \"my_class\", extensions:\
    \ [\"AA\", \"Be\", \"CC\"])\n/// \"my_class.AA\"\nfunc Strongest_Extension(class_name:\
    \ String, extensions: [String]) -> String {\n    let strongest_extension = extensions.enumerated().max(by:\
    \ {(extension1, extension2) -> Bool in\n        let strength1 = (extension1.element.filter({$0.isUppercase}).count\
    \ - extension1.element.filter({$0.isLowercase}).count)\n        let strength2\
    \ = (extension2.element.filter({$0.isUppercase}).count - extension2.element.filter({$0.isLowercase}).count)\n\
    \        return strength1 < strength2\n    })\n    return class_name + \".\" +\
    \ strongest_extension!.element\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int,\
    \ Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n\
    \    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n          \
    \  return false\n        }\n    }\n    return true\n}\n            \nassert(Strongest_Extension(class_name:\
    \ \"Watashi\", extensions: [\"tEN\", \"niNE\", \"eIGHt8OKe\"]) == \"Watashi.eIGHt8OKe\"\
    )\nassert(Strongest_Extension(class_name: \"Boku123\", extensions: [\"nani\",\
    \ \"NazeDa\", \"YEs.WeCaNe\", \"32145tggg\"]) == \"Boku123.YEs.WeCaNe\")\nassert(Strongest_Extension(class_name:\
    \ \"__YESIMHERE\", extensions: [\"t\", \"eMptY\", \"nothing\", \"zeR00\", \"NuLl__\"\
    , \"123NoooneB321\"]) == \"__YESIMHERE.NuLl__\")\nassert(Strongest_Extension(class_name:\
    \ \"K\", extensions: [\"Ta\", \"TAR\", \"t234An\", \"cosSo\"]) == \"K.TAR\")\n\
    assert(Strongest_Extension(class_name: \"__HAHA\", extensions: [\"Tab\", \"123\"\
    , \"781345\", \"-_-\"]) == \"__HAHA.123\")\nassert(Strongest_Extension(class_name:\
    \ \"YameRore\", extensions: [\"HhAas\", \"okIWILL123\", \"WorkOut\", \"Fails\"\
    , \"-_-\"]) == \"YameRore.okIWILL123\")\nassert(Strongest_Extension(class_name:\
    \ \"finNNalLLly\", extensions: [\"Die\", \"NowW\", \"Wow\", \"WoW\"]) == \"finNNalLLly.WoW\"\
    )\nassert(Strongest_Extension(class_name: \"_\", extensions: [\"Bb\", \"91245\"\
    ]) == \"_.Bb\")\nassert(Strongest_Extension(class_name: \"Sp\", extensions: [\"\
    671235\", \"Bb\"]) == \"Sp.671235\")"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660009435
- exit_code: -4
  program: "\n/// You will be given the name of a class (a string) and an array of\
    \ extensions.\n/// The extensions are to be used to load additional classes to\
    \ the class. The\n/// strength of the extension is as follows: Let CAP be the\
    \ number of the uppercase\n/// letters in the extension's name, and let SM be\
    \ the number of lowercase letters \n/// in the extension's name, the strength\
    \ is given by the fraction CAP - SM. \n/// You should find the strongest extension\
    \ and return a string in this \n/// format: ClassName.StrongestExtensionName.\n\
    /// If there are two or more extensions with the same strength, you should\n///\
    \ choose the one that comes first in the array.\n/// For example, if you are given\
    \ \"Slices\" as the class and an array of the\n/// extensions: ['SErviNGSliCes',\
    \ 'Cheese', 'StuFfed'] then you should\n/// return 'Slices.SErviNGSliCes' since\
    \ 'SErviNGSliCes' is the strongest extension \n/// (its strength is -1).\n///\
    \ Example:\n/// >>> Strongest_Extension(class_name: \"my_class\", extensions:\
    \ [\"AA\", \"Be\", \"CC\"])\n/// \"my_class.AA\"\nfunc Strongest_Extension(class_name:\
    \ String, extensions: [String]) -> String {\n    return \"\"\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(Strongest_Extension(class_name: \"Watashi\", extensions:\
    \ [\"tEN\", \"niNE\", \"eIGHt8OKe\"]) == \"Watashi.eIGHt8OKe\")\nassert(Strongest_Extension(class_name:\
    \ \"Boku123\", extensions: [\"nani\", \"NazeDa\", \"YEs.WeCaNe\", \"32145tggg\"\
    ]) == \"Boku123.YEs.WeCaNe\")\nassert(Strongest_Extension(class_name: \"__YESIMHERE\"\
    , extensions: [\"t\", \"eMptY\", \"nothing\", \"zeR00\", \"NuLl__\", \"123NoooneB321\"\
    ]) == \"__YESIMHERE.NuLl__\")\nassert(Strongest_Extension(class_name: \"K\", extensions:\
    \ [\"Ta\", \"TAR\", \"t234An\", \"cosSo\"]) == \"K.TAR\")\nassert(Strongest_Extension(class_name:\
    \ \"__HAHA\", extensions: [\"Tab\", \"123\", \"781345\", \"-_-\"]) == \"__HAHA.123\"\
    )\nassert(Strongest_Extension(class_name: \"YameRore\", extensions: [\"HhAas\"\
    , \"okIWILL123\", \"WorkOut\", \"Fails\", \"-_-\"]) == \"YameRore.okIWILL123\"\
    )\nassert(Strongest_Extension(class_name: \"finNNalLLly\", extensions: [\"Die\"\
    , \"NowW\", \"Wow\", \"WoW\"]) == \"finNNalLLly.WoW\")\nassert(Strongest_Extension(class_name:\
    \ \"_\", extensions: [\"Bb\", \"91245\"]) == \"_.Bb\")\nassert(Strongest_Extension(class_name:\
    \ \"Sp\", extensions: [\"671235\", \"Bb\"]) == \"Sp.671235\")"
  status: Exception
  stderr: 'tmpuhmbxdp4/tmpuhmbxdp4.swift:35: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002abeef348c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002abeef03fb6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002abeef03f988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002abeef03e7b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpuhmbxdp4                        0x0000559ee0d614fd <unavailable> + 5373

    5    libc.so.6                          0x00002abeef534460 __libc_start_main +
    245

    6    tmpuhmbxdp4                        0x0000559ee0d61089 <unavailable> + 4233

    '
  stdout: ''
  timestamp: 1660009431
- exit_code: -4
  program: "\n/// You will be given the name of a class (a string) and an array of\
    \ extensions.\n/// The extensions are to be used to load additional classes to\
    \ the class. The\n/// strength of the extension is as follows: Let CAP be the\
    \ number of the uppercase\n/// letters in the extension's name, and let SM be\
    \ the number of lowercase letters \n/// in the extension's name, the strength\
    \ is given by the fraction CAP - SM. \n/// You should find the strongest extension\
    \ and return a string in this \n/// format: ClassName.StrongestExtensionName.\n\
    /// If there are two or more extensions with the same strength, you should\n///\
    \ choose the one that comes first in the array.\n/// For example, if you are given\
    \ \"Slices\" as the class and an array of the\n/// extensions: ['SErviNGSliCes',\
    \ 'Cheese', 'StuFfed'] then you should\n/// return 'Slices.SErviNGSliCes' since\
    \ 'SErviNGSliCes' is the strongest extension \n/// (its strength is -1).\n///\
    \ Example:\n/// >>> Strongest_Extension(class_name: \"my_class\", extensions:\
    \ [\"AA\", \"Be\", \"CC\"])\n/// \"my_class.AA\"\nfunc Strongest_Extension(class_name:\
    \ String, extensions: [String]) -> String {\n    var strongest = \"\"\n    var\
    \ strength = 0\n    for extension_name in extensions {\n        var caps = 0\n\
    \        var sms = 0\n        for c in extension_name {\n            if c.isUppercase\
    \ {\n                caps += 1\n            } else {\n                sms += 1\n\
    \            }\n        }\n        let strength_of_extension = caps - sms\n  \
    \      if strength_of_extension > strength {\n            strength = strength_of_extension\n\
    \            strongest = extension_name\n        }\n    }\n    return \"\\(class_name).\\\
    (strongest)\"\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool\
    \ {\n    if left.count != right.count {\n        return false\n    }\n    for\
    \ (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(Strongest_Extension(class_name:\
    \ \"Watashi\", extensions: [\"tEN\", \"niNE\", \"eIGHt8OKe\"]) == \"Watashi.eIGHt8OKe\"\
    )\nassert(Strongest_Extension(class_name: \"Boku123\", extensions: [\"nani\",\
    \ \"NazeDa\", \"YEs.WeCaNe\", \"32145tggg\"]) == \"Boku123.YEs.WeCaNe\")\nassert(Strongest_Extension(class_name:\
    \ \"__YESIMHERE\", extensions: [\"t\", \"eMptY\", \"nothing\", \"zeR00\", \"NuLl__\"\
    , \"123NoooneB321\"]) == \"__YESIMHERE.NuLl__\")\nassert(Strongest_Extension(class_name:\
    \ \"K\", extensions: [\"Ta\", \"TAR\", \"t234An\", \"cosSo\"]) == \"K.TAR\")\n\
    assert(Strongest_Extension(class_name: \"__HAHA\", extensions: [\"Tab\", \"123\"\
    , \"781345\", \"-_-\"]) == \"__HAHA.123\")\nassert(Strongest_Extension(class_name:\
    \ \"YameRore\", extensions: [\"HhAas\", \"okIWILL123\", \"WorkOut\", \"Fails\"\
    , \"-_-\"]) == \"YameRore.okIWILL123\")\nassert(Strongest_Extension(class_name:\
    \ \"finNNalLLly\", extensions: [\"Die\", \"NowW\", \"Wow\", \"WoW\"]) == \"finNNalLLly.WoW\"\
    )\nassert(Strongest_Extension(class_name: \"_\", extensions: [\"Bb\", \"91245\"\
    ]) == \"_.Bb\")\nassert(Strongest_Extension(class_name: \"Sp\", extensions: [\"\
    671235\", \"Bb\"]) == \"Sp.671235\")"
  status: Exception
  stderr: 'tmp5_w3gt06/tmp5_w3gt06.swift:53: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002ac16f539c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002ac16f230b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002ac16f230988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002ac16f22f7b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmp5_w3gt06                        0x0000562a88e24a3d <unavailable> + 6717

    5    libc.so.6                          0x00002ac16f725460 __libc_start_main +
    245

    6    tmp5_w3gt06                        0x0000562a88e245c9 <unavailable> + 5577

    '
  stdout: ''
  timestamp: 1660009434
- exit_code: 1
  program: "\n/// You will be given the name of a class (a string) and an array of\
    \ extensions.\n/// The extensions are to be used to load additional classes to\
    \ the class. The\n/// strength of the extension is as follows: Let CAP be the\
    \ number of the uppercase\n/// letters in the extension's name, and let SM be\
    \ the number of lowercase letters \n/// in the extension's name, the strength\
    \ is given by the fraction CAP - SM. \n/// You should find the strongest extension\
    \ and return a string in this \n/// format: ClassName.StrongestExtensionName.\n\
    /// If there are two or more extensions with the same strength, you should\n///\
    \ choose the one that comes first in the array.\n/// For example, if you are given\
    \ \"Slices\" as the class and an array of the\n/// extensions: ['SErviNGSliCes',\
    \ 'Cheese', 'StuFfed'] then you should\n/// return 'Slices.SErviNGSliCes' since\
    \ 'SErviNGSliCes' is the strongest extension \n/// (its strength is -1).\n///\
    \ Example:\n/// >>> Strongest_Extension(class_name: \"my_class\", extensions:\
    \ [\"AA\", \"Be\", \"CC\"])\n/// \"my_class.AA\"\nfunc Strongest_Extension(class_name:\
    \ String, extensions: [String]) -> String {\n    let class_name = class_name\n\
    \    let extensions = extensions\n    let new_array = extensions.map { [$0,($0.filter{$0.isUppercase}.count)\
    \ - ($0.filter{$0.isLowercase}.count)] }\n    let sorted_array = new_array.sorted\
    \ { ($0[1] > $1[1]) || ($0[1] == $1[1] && $0[0] < $1[0]) }\n    let strong_extension\
    \ = sorted_array[0][0]\n    return \"\\(class_name).\\(strong_extension)\"\n}\n\
    \n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(Strongest_Extension(class_name: \"Watashi\", extensions:\
    \ [\"tEN\", \"niNE\", \"eIGHt8OKe\"]) == \"Watashi.eIGHt8OKe\")\nassert(Strongest_Extension(class_name:\
    \ \"Boku123\", extensions: [\"nani\", \"NazeDa\", \"YEs.WeCaNe\", \"32145tggg\"\
    ]) == \"Boku123.YEs.WeCaNe\")\nassert(Strongest_Extension(class_name: \"__YESIMHERE\"\
    , extensions: [\"t\", \"eMptY\", \"nothing\", \"zeR00\", \"NuLl__\", \"123NoooneB321\"\
    ]) == \"__YESIMHERE.NuLl__\")\nassert(Strongest_Extension(class_name: \"K\", extensions:\
    \ [\"Ta\", \"TAR\", \"t234An\", \"cosSo\"]) == \"K.TAR\")\nassert(Strongest_Extension(class_name:\
    \ \"__HAHA\", extensions: [\"Tab\", \"123\", \"781345\", \"-_-\"]) == \"__HAHA.123\"\
    )\nassert(Strongest_Extension(class_name: \"YameRore\", extensions: [\"HhAas\"\
    , \"okIWILL123\", \"WorkOut\", \"Fails\", \"-_-\"]) == \"YameRore.okIWILL123\"\
    )\nassert(Strongest_Extension(class_name: \"finNNalLLly\", extensions: [\"Die\"\
    , \"NowW\", \"Wow\", \"WoW\"]) == \"finNNalLLly.WoW\")\nassert(Strongest_Extension(class_name:\
    \ \"_\", extensions: [\"Bb\", \"91245\"]) == \"_.Bb\")\nassert(Strongest_Extension(class_name:\
    \ \"Sp\", extensions: [\"671235\", \"Bb\"]) == \"Sp.671235\")"
  status: SyntaxError
  stderr: "/tmp/tmpsuw20jit.swift:22:50: error: binary operator '>' cannot be applied\
    \ to two 'Any' operands\n    let sorted_array = new_array.sorted { ($0[1] > $1[1])\
    \ || ($0[1] == $1[1] && $0[0] < $1[0]) }\n                                   \
    \        ~~~~~ ^ ~~~~~\n/tmp/tmpsuw20jit.swift:22:50: note: overloads for '>'\
    \ exist with these partially matching parameter lists: ((), ()), (Int, Int), (Int16,\
    \ Int16), (Int32, Int32), (Int64, Int64), (Int8, Int8), (TaskPriority, TaskPriority),\
    \ (UInt, UInt), (UInt16, UInt16), (UInt32, UInt32), (UInt64, UInt64), (UInt8,\
    \ UInt8)\n    let sorted_array = new_array.sorted { ($0[1] > $1[1]) || ($0[1]\
    \ == $1[1] && $0[0] < $1[0]) }\n                                             \
    \    ^\n/tmp/tmpsuw20jit.swift:22:87: error: binary operator '<' cannot be applied\
    \ to two 'Any' operands\n    let sorted_array = new_array.sorted { ($0[1] > $1[1])\
    \ || ($0[1] == $1[1] && $0[0] < $1[0]) }\n                                   \
    \                                             ~~~~~ ^ ~~~~~\n/tmp/tmpsuw20jit.swift:22:87:\
    \ note: overloads for '<' exist with these partially matching parameter lists:\
    \ ((), ()), (AnyIndex, AnyIndex), (Character, Character), (ContinuousClock.Instant,\
    \ ContinuousClock.Instant), (Duration, Duration), (Int, Int), (Int16, Int16),\
    \ (Int32, Int32), (Int64, Int64), (Int8, Int8), (Never, Never), (ObjectIdentifier,\
    \ ObjectIdentifier), (String, String), (String.Index, String.Index), (SuspendingClock.Instant,\
    \ SuspendingClock.Instant), (TaskPriority, TaskPriority), (UInt, UInt), (UInt16,\
    \ UInt16), (UInt32, UInt32), (UInt64, UInt64), (UInt8, UInt8), (Unicode.CanonicalCombiningClass,\
    \ Unicode.CanonicalCombiningClass), (Unicode.Scalar, Unicode.Scalar), (_ValidUTF8Buffer.Index,\
    \ _ValidUTF8Buffer.Index)\n    let sorted_array = new_array.sorted { ($0[1] >\
    \ $1[1]) || ($0[1] == $1[1] && $0[0] < $1[0]) }\n                            \
    \                                                          ^\n/tmp/tmpsuw20jit.swift:22:69:\
    \ error: type 'Any' cannot conform to 'RawRepresentable'\n    let sorted_array\
    \ = new_array.sorted { ($0[1] > $1[1])"
  stdout: ''
  timestamp: 1660009434
- exit_code: -4
  program: "\n/// You will be given the name of a class (a string) and an array of\
    \ extensions.\n/// The extensions are to be used to load additional classes to\
    \ the class. The\n/// strength of the extension is as follows: Let CAP be the\
    \ number of the uppercase\n/// letters in the extension's name, and let SM be\
    \ the number of lowercase letters \n/// in the extension's name, the strength\
    \ is given by the fraction CAP - SM. \n/// You should find the strongest extension\
    \ and return a string in this \n/// format: ClassName.StrongestExtensionName.\n\
    /// If there are two or more extensions with the same strength, you should\n///\
    \ choose the one that comes first in the array.\n/// For example, if you are given\
    \ \"Slices\" as the class and an array of the\n/// extensions: ['SErviNGSliCes',\
    \ 'Cheese', 'StuFfed'] then you should\n/// return 'Slices.SErviNGSliCes' since\
    \ 'SErviNGSliCes' is the strongest extension \n/// (its strength is -1).\n///\
    \ Example:\n/// >>> Strongest_Extension(class_name: \"my_class\", extensions:\
    \ [\"AA\", \"Be\", \"CC\"])\n/// \"my_class.AA\"\nfunc Strongest_Extension(class_name:\
    \ String, extensions: [String]) -> String {\n    var strg: [String: Double] =\
    \ [:]\n    for i in extensions {\n        var num = 0\n        for j in i {\n\
    \            if j.isUppercase {\n                num += 1\n            }\n   \
    \     }\n        for j in i {\n            if j.isLowercase {\n              \
    \  num -= 1\n            }\n        }\n        strg[i] = Double(num)\n    }\n\
    \    let value = strg.max { a, b in a.value < b.value }\n    if value != nil {\n\
    \        return \"\\(class_name).\\(value!.key)\"\n    }\n    return \"\"\n}\n\
    \n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(Strongest_Extension(class_name: \"Watashi\", extensions:\
    \ [\"tEN\", \"niNE\", \"eIGHt8OKe\"]) == \"Watashi.eIGHt8OKe\")\nassert(Strongest_Extension(class_name:\
    \ \"Boku123\", extensions: [\"nani\", \"NazeDa\", \"YEs.WeCaNe\", \"32145tggg\"\
    ]) == \"Boku123.YEs.WeCaNe\")\nassert(Strongest_Extension(class_name: \"__YESIMHERE\"\
    , extensions: [\"t\", \"eMptY\", \"nothing\", \"zeR00\", \"NuLl__\", \"123NoooneB321\"\
    ]) == \"__YESIMHERE.NuLl__\")\nassert(Strongest_Extension(class_name: \"K\", extensions:\
    \ [\"Ta\", \"TAR\", \"t234An\", \"cosSo\"]) == \"K.TAR\")\nassert(Strongest_Extension(class_name:\
    \ \"__HAHA\", extensions: [\"Tab\", \"123\", \"781345\", \"-_-\"]) == \"__HAHA.123\"\
    )\nassert(Strongest_Extension(class_name: \"YameRore\", extensions: [\"HhAas\"\
    , \"okIWILL123\", \"WorkOut\", \"Fails\", \"-_-\"]) == \"YameRore.okIWILL123\"\
    )\nassert(Strongest_Extension(class_name: \"finNNalLLly\", extensions: [\"Die\"\
    , \"NowW\", \"Wow\", \"WoW\"]) == \"finNNalLLly.WoW\")\nassert(Strongest_Extension(class_name:\
    \ \"_\", extensions: [\"Bb\", \"91245\"]) == \"_.Bb\")\nassert(Strongest_Extension(class_name:\
    \ \"Sp\", extensions: [\"671235\", \"Bb\"]) == \"Sp.671235\")"
  status: Exception
  stderr: 'tmpzo4f80yw/tmpzo4f80yw.swift:58: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b5080adac80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b50807d1b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b50807d1988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b50807d07b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpzo4f80yw                        0x000055a4cd7595ca <unavailable> + 9674

    5    libc.so.6                          0x00002b5080cc6460 __libc_start_main +
    245

    6    tmpzo4f80yw                        0x000055a4cd758899 <unavailable> + 6297

    '
  stdout: ''
  timestamp: 1660009435
- exit_code: 1
  program: "\n/// You will be given the name of a class (a string) and an array of\
    \ extensions.\n/// The extensions are to be used to load additional classes to\
    \ the class. The\n/// strength of the extension is as follows: Let CAP be the\
    \ number of the uppercase\n/// letters in the extension's name, and let SM be\
    \ the number of lowercase letters \n/// in the extension's name, the strength\
    \ is given by the fraction CAP - SM. \n/// You should find the strongest extension\
    \ and return a string in this \n/// format: ClassName.StrongestExtensionName.\n\
    /// If there are two or more extensions with the same strength, you should\n///\
    \ choose the one that comes first in the array.\n/// For example, if you are given\
    \ \"Slices\" as the class and an array of the\n/// extensions: ['SErviNGSliCes',\
    \ 'Cheese', 'StuFfed'] then you should\n/// return 'Slices.SErviNGSliCes' since\
    \ 'SErviNGSliCes' is the strongest extension \n/// (its strength is -1).\n///\
    \ Example:\n/// >>> Strongest_Extension(class_name: \"my_class\", extensions:\
    \ [\"AA\", \"Be\", \"CC\"])\n/// \"my_class.AA\"\nfunc Strongest_Extension(class_name:\
    \ String, extensions: [String]) -> String {\n    let class_strength = Class_Strength(class_name:\
    \ class_name)\n    var strongest_extension = \"\"\n    var strongest_extension_name\
    \ = \"\"\n    var strongest_extension_strength = class_strength\n    for i in\
    \ 0..<extensions.count {\n        let extension_strength = Extension_Strength(extension_name:\
    \ extensions[i])\n        if extension_strength > strongest_extension_strength\
    \ {\n            strongest_extension = extensions[i]\n            strongest_extension_name\
    \ = extensions[i]\n            strongest_extension_strength = extension_strength\n\
    \        }\n    }\n    return \"\\(class_name).\\(strongest_extension_name)\"\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(Strongest_Extension(class_name: \"Watashi\", extensions:\
    \ [\"tEN\", \"niNE\", \"eIGHt8OKe\"]) == \"Watashi.eIGHt8OKe\")\nassert(Strongest_Extension(class_name:\
    \ \"Boku123\", extensions: [\"nani\", \"NazeDa\", \"YEs.WeCaNe\", \"32145tggg\"\
    ]) == \"Boku123.YEs.WeCaNe\")\nassert(Strongest_Extension(class_name: \"__YESIMHERE\"\
    , extensions: [\"t\", \"eMptY\", \"nothing\", \"zeR00\", \"NuLl__\", \"123NoooneB321\"\
    ]) == \"__YESIMHERE.NuLl__\")\nassert(Strongest_Extension(class_name: \"K\", extensions:\
    \ [\"Ta\", \"TAR\", \"t234An\", \"cosSo\"]) == \"K.TAR\")\nassert(Strongest_Extension(class_name:\
    \ \"__HAHA\", extensions: [\"Tab\", \"123\", \"781345\", \"-_-\"]) == \"__HAHA.123\"\
    )\nassert(Strongest_Extension(class_name: \"YameRore\", extensions: [\"HhAas\"\
    , \"okIWILL123\", \"WorkOut\", \"Fails\", \"-_-\"]) == \"YameRore.okIWILL123\"\
    )\nassert(Strongest_Extension(class_name: \"finNNalLLly\", extensions: [\"Die\"\
    , \"NowW\", \"Wow\", \"WoW\"]) == \"finNNalLLly.WoW\")\nassert(Strongest_Extension(class_name:\
    \ \"_\", extensions: [\"Bb\", \"91245\"]) == \"_.Bb\")\nassert(Strongest_Extension(class_name:\
    \ \"Sp\", extensions: [\"671235\", \"Bb\"]) == \"Sp.671235\")"
  status: SyntaxError
  stderr: "/tmp/tmpl_r2hdm9.swift:19:26: error: cannot find 'Class_Strength' in scope\n\
    \    let class_strength = Class_Strength(class_name: class_name)\n           \
    \              ^~~~~~~~~~~~~~\n/tmp/tmpl_r2hdm9.swift:24:34: error: cannot find\
    \ 'Extension_Strength' in scope\n        let extension_strength = Extension_Strength(extension_name:\
    \ extensions[i])\n                                 ^~~~~~~~~~~~~~~~~~\n"
  stdout: ''
  timestamp: 1660009434
- exit_code: -4
  program: "\n/// You will be given the name of a class (a string) and an array of\
    \ extensions.\n/// The extensions are to be used to load additional classes to\
    \ the class. The\n/// strength of the extension is as follows: Let CAP be the\
    \ number of the uppercase\n/// letters in the extension's name, and let SM be\
    \ the number of lowercase letters \n/// in the extension's name, the strength\
    \ is given by the fraction CAP - SM. \n/// You should find the strongest extension\
    \ and return a string in this \n/// format: ClassName.StrongestExtensionName.\n\
    /// If there are two or more extensions with the same strength, you should\n///\
    \ choose the one that comes first in the array.\n/// For example, if you are given\
    \ \"Slices\" as the class and an array of the\n/// extensions: ['SErviNGSliCes',\
    \ 'Cheese', 'StuFfed'] then you should\n/// return 'Slices.SErviNGSliCes' since\
    \ 'SErviNGSliCes' is the strongest extension \n/// (its strength is -1).\n///\
    \ Example:\n/// >>> Strongest_Extension(class_name: \"my_class\", extensions:\
    \ [\"AA\", \"Be\", \"CC\"])\n/// \"my_class.AA\"\nfunc Strongest_Extension(class_name:\
    \ String, extensions: [String]) -> String {\n    var strongest = 0.0\n    var\
    \ new_ext = \"\"\n    for ext in extensions {\n        var uppercase_count = 0\n\
    \        var lowercase_count = 0\n        for char in ext {\n            if String(char).uppercased()\
    \ == String(char) {\n                uppercase_count += 1\n            } else\
    \ {\n                lowercase_count += 1\n            }\n        }\n        let\
    \ strength = Double(uppercase_count) - Double(lowercase_count)\n        if strength\
    \ > strongest {\n            strongest = strength\n            new_ext = ext\n\
    \        }\n    }\n    return \"\\(class_name).\\(new_ext)\"\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(Strongest_Extension(class_name: \"Watashi\", extensions:\
    \ [\"tEN\", \"niNE\", \"eIGHt8OKe\"]) == \"Watashi.eIGHt8OKe\")\nassert(Strongest_Extension(class_name:\
    \ \"Boku123\", extensions: [\"nani\", \"NazeDa\", \"YEs.WeCaNe\", \"32145tggg\"\
    ]) == \"Boku123.YEs.WeCaNe\")\nassert(Strongest_Extension(class_name: \"__YESIMHERE\"\
    , extensions: [\"t\", \"eMptY\", \"nothing\", \"zeR00\", \"NuLl__\", \"123NoooneB321\"\
    ]) == \"__YESIMHERE.NuLl__\")\nassert(Strongest_Extension(class_name: \"K\", extensions:\
    \ [\"Ta\", \"TAR\", \"t234An\", \"cosSo\"]) == \"K.TAR\")\nassert(Strongest_Extension(class_name:\
    \ \"__HAHA\", extensions: [\"Tab\", \"123\", \"781345\", \"-_-\"]) == \"__HAHA.123\"\
    )\nassert(Strongest_Extension(class_name: \"YameRore\", extensions: [\"HhAas\"\
    , \"okIWILL123\", \"WorkOut\", \"Fails\", \"-_-\"]) == \"YameRore.okIWILL123\"\
    )\nassert(Strongest_Extension(class_name: \"finNNalLLly\", extensions: [\"Die\"\
    , \"NowW\", \"Wow\", \"WoW\"]) == \"finNNalLLly.WoW\")\nassert(Strongest_Extension(class_name:\
    \ \"_\", extensions: [\"Bb\", \"91245\"]) == \"_.Bb\")\nassert(Strongest_Extension(class_name:\
    \ \"Sp\", extensions: [\"671235\", \"Bb\"]) == \"Sp.671235\")"
  status: Exception
  stderr: 'tmp106b357l/tmp106b357l.swift:55: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002ac618eb6c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002ac618badb6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002ac618bad988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002ac618bac7b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmp106b357l                        0x0000557097787f0c <unavailable> + 7948

    5    libc.so.6                          0x00002ac6190a2460 __libc_start_main +
    245

    6    tmp106b357l                        0x0000557097787619 <unavailable> + 5657

    '
  stdout: ''
  timestamp: 1660009435
- exit_code: -4
  program: "\n/// You will be given the name of a class (a string) and an array of\
    \ extensions.\n/// The extensions are to be used to load additional classes to\
    \ the class. The\n/// strength of the extension is as follows: Let CAP be the\
    \ number of the uppercase\n/// letters in the extension's name, and let SM be\
    \ the number of lowercase letters \n/// in the extension's name, the strength\
    \ is given by the fraction CAP - SM. \n/// You should find the strongest extension\
    \ and return a string in this \n/// format: ClassName.StrongestExtensionName.\n\
    /// If there are two or more extensions with the same strength, you should\n///\
    \ choose the one that comes first in the array.\n/// For example, if you are given\
    \ \"Slices\" as the class and an array of the\n/// extensions: ['SErviNGSliCes',\
    \ 'Cheese', 'StuFfed'] then you should\n/// return 'Slices.SErviNGSliCes' since\
    \ 'SErviNGSliCes' is the strongest extension \n/// (its strength is -1).\n///\
    \ Example:\n/// >>> Strongest_Extension(class_name: \"my_class\", extensions:\
    \ [\"AA\", \"Be\", \"CC\"])\n/// \"my_class.AA\"\nfunc Strongest_Extension(class_name:\
    \ String, extensions: [String]) -> String {\n    return \"\"\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(Strongest_Extension(class_name: \"Watashi\", extensions:\
    \ [\"tEN\", \"niNE\", \"eIGHt8OKe\"]) == \"Watashi.eIGHt8OKe\")\nassert(Strongest_Extension(class_name:\
    \ \"Boku123\", extensions: [\"nani\", \"NazeDa\", \"YEs.WeCaNe\", \"32145tggg\"\
    ]) == \"Boku123.YEs.WeCaNe\")\nassert(Strongest_Extension(class_name: \"__YESIMHERE\"\
    , extensions: [\"t\", \"eMptY\", \"nothing\", \"zeR00\", \"NuLl__\", \"123NoooneB321\"\
    ]) == \"__YESIMHERE.NuLl__\")\nassert(Strongest_Extension(class_name: \"K\", extensions:\
    \ [\"Ta\", \"TAR\", \"t234An\", \"cosSo\"]) == \"K.TAR\")\nassert(Strongest_Extension(class_name:\
    \ \"__HAHA\", extensions: [\"Tab\", \"123\", \"781345\", \"-_-\"]) == \"__HAHA.123\"\
    )\nassert(Strongest_Extension(class_name: \"YameRore\", extensions: [\"HhAas\"\
    , \"okIWILL123\", \"WorkOut\", \"Fails\", \"-_-\"]) == \"YameRore.okIWILL123\"\
    )\nassert(Strongest_Extension(class_name: \"finNNalLLly\", extensions: [\"Die\"\
    , \"NowW\", \"Wow\", \"WoW\"]) == \"finNNalLLly.WoW\")\nassert(Strongest_Extension(class_name:\
    \ \"_\", extensions: [\"Bb\", \"91245\"]) == \"_.Bb\")\nassert(Strongest_Extension(class_name:\
    \ \"Sp\", extensions: [\"671235\", \"Bb\"]) == \"Sp.671235\")"
  status: Exception
  stderr: 'tmpuhmbxdp4/tmpuhmbxdp4.swift:35: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002abeef348c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002abeef03fb6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002abeef03f988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002abeef03e7b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpuhmbxdp4                        0x0000559ee0d614fd <unavailable> + 5373

    5    libc.so.6                          0x00002abeef534460 __libc_start_main +
    245

    6    tmpuhmbxdp4                        0x0000559ee0d61089 <unavailable> + 4233

    '
  stdout: ''
  timestamp: 1660009431
- exit_code: 1
  program: "\n/// You will be given the name of a class (a string) and an array of\
    \ extensions.\n/// The extensions are to be used to load additional classes to\
    \ the class. The\n/// strength of the extension is as follows: Let CAP be the\
    \ number of the uppercase\n/// letters in the extension's name, and let SM be\
    \ the number of lowercase letters \n/// in the extension's name, the strength\
    \ is given by the fraction CAP - SM. \n/// You should find the strongest extension\
    \ and return a string in this \n/// format: ClassName.StrongestExtensionName.\n\
    /// If there are two or more extensions with the same strength, you should\n///\
    \ choose the one that comes first in the array.\n/// For example, if you are given\
    \ \"Slices\" as the class and an array of the\n/// extensions: ['SErviNGSliCes',\
    \ 'Cheese', 'StuFfed'] then you should\n/// return 'Slices.SErviNGSliCes' since\
    \ 'SErviNGSliCes' is the strongest extension \n/// (its strength is -1).\n///\
    \ Example:\n/// >>> Strongest_Extension(class_name: \"my_class\", extensions:\
    \ [\"AA\", \"Be\", \"CC\"])\n/// \"my_class.AA\"\nfunc Strongest_Extension(class_name:\
    \ String, extensions: [String]) -> String {\n    // enter code here\n    var strength\
    \ = Double(0)\n    var strongest = String()\n    for ext in extensions {\n   \
    \     var cap = 0\n        var sm = 0\n        for ch in ext {\n            if\
    \ CharacterSet.uppercaseLetters.contains(ch.unicodeScalars.first!) {\n       \
    \         cap += 1\n            } else {\n                sm += 1\n          \
    \  }\n        }\n        if Double(cap) - Double(sm) > strength {\n          \
    \  strength = Double(cap) - Double(sm)\n            strongest = ext\n        }\n\
    \    }\n    return \"\\(class_name).\\(strongest)\"\n}\n\n\nfunc ==(left: [(Int,\
    \ Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n\
    \        return false\n    }\n    for (l, r) in zip(left, right) {\n        if\
    \ l != r {\n            return false\n        }\n    }\n    return true\n}\n \
    \           \nassert(Strongest_Extension(class_name: \"Watashi\", extensions:\
    \ [\"tEN\", \"niNE\", \"eIGHt8OKe\"]) == \"Watashi.eIGHt8OKe\")\nassert(Strongest_Extension(class_name:\
    \ \"Boku123\", extensions: [\"nani\", \"NazeDa\", \"YEs.WeCaNe\", \"32145tggg\"\
    ]) == \"Boku123.YEs.WeCaNe\")\nassert(Strongest_Extension(class_name: \"__YESIMHERE\"\
    , extensions: [\"t\", \"eMptY\", \"nothing\", \"zeR00\", \"NuLl__\", \"123NoooneB321\"\
    ]) == \"__YESIMHERE.NuLl__\")\nassert(Strongest_Extension(class_name: \"K\", extensions:\
    \ [\"Ta\", \"TAR\", \"t234An\", \"cosSo\"]) == \"K.TAR\")\nassert(Strongest_Extension(class_name:\
    \ \"__HAHA\", extensions: [\"Tab\", \"123\", \"781345\", \"-_-\"]) == \"__HAHA.123\"\
    )\nassert(Strongest_Extension(class_name: \"YameRore\", extensions: [\"HhAas\"\
    , \"okIWILL123\", \"WorkOut\", \"Fails\", \"-_-\"]) == \"YameRore.okIWILL123\"\
    )\nassert(Strongest_Extension(class_name: \"finNNalLLly\", extensions: [\"Die\"\
    , \"NowW\", \"Wow\", \"WoW\"]) == \"finNNalLLly.WoW\")\nassert(Strongest_Extension(class_name:\
    \ \"_\", extensions: [\"Bb\", \"91245\"]) == \"_.Bb\")\nassert(Strongest_Extension(class_name:\
    \ \"Sp\", extensions: [\"671235\", \"Bb\"]) == \"Sp.671235\")"
  status: SyntaxError
  stderr: "/tmp/tmpmwknkh71.swift:26:16: error: cannot find 'CharacterSet' in scope\n\
    \            if CharacterSet.uppercaseLetters.contains(ch.unicodeScalars.first!)\
    \ {\n               ^~~~~~~~~~~~\n"
  stdout: ''
  timestamp: 1660009434
- exit_code: -4
  program: "\n/// You will be given the name of a class (a string) and an array of\
    \ extensions.\n/// The extensions are to be used to load additional classes to\
    \ the class. The\n/// strength of the extension is as follows: Let CAP be the\
    \ number of the uppercase\n/// letters in the extension's name, and let SM be\
    \ the number of lowercase letters \n/// in the extension's name, the strength\
    \ is given by the fraction CAP - SM. \n/// You should find the strongest extension\
    \ and return a string in this \n/// format: ClassName.StrongestExtensionName.\n\
    /// If there are two or more extensions with the same strength, you should\n///\
    \ choose the one that comes first in the array.\n/// For example, if you are given\
    \ \"Slices\" as the class and an array of the\n/// extensions: ['SErviNGSliCes',\
    \ 'Cheese', 'StuFfed'] then you should\n/// return 'Slices.SErviNGSliCes' since\
    \ 'SErviNGSliCes' is the strongest extension \n/// (its strength is -1).\n///\
    \ Example:\n/// >>> Strongest_Extension(class_name: \"my_class\", extensions:\
    \ [\"AA\", \"Be\", \"CC\"])\n/// \"my_class.AA\"\nfunc Strongest_Extension(class_name:\
    \ String, extensions: [String]) -> String {\n  let strength = extensions.map({\
    \ (extension_name) -> (extension_name: String, strength: Double) in\n    return\
    \ (extension_name: extension_name, strength: Double(extension_name.filter({ char\
    \ in char.isUppercase }).count) - Double(extension_name.filter({ char in char.isLowercase\
    \ }).count))\n  })\n  var strongest_extension = \"\"\n  var strongest_strength\
    \ = 0.0\n  for i in 0..<strength.count {\n    if (strongest_strength < strength[i].strength)\
    \ {\n      strongest_strength = strength[i].strength\n      strongest_extension\
    \ = strength[i].extension_name\n    }\n  }\n  return class_name + \".\" + strongest_extension\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(Strongest_Extension(class_name: \"Watashi\", extensions:\
    \ [\"tEN\", \"niNE\", \"eIGHt8OKe\"]) == \"Watashi.eIGHt8OKe\")\nassert(Strongest_Extension(class_name:\
    \ \"Boku123\", extensions: [\"nani\", \"NazeDa\", \"YEs.WeCaNe\", \"32145tggg\"\
    ]) == \"Boku123.YEs.WeCaNe\")\nassert(Strongest_Extension(class_name: \"__YESIMHERE\"\
    , extensions: [\"t\", \"eMptY\", \"nothing\", \"zeR00\", \"NuLl__\", \"123NoooneB321\"\
    ]) == \"__YESIMHERE.NuLl__\")\nassert(Strongest_Extension(class_name: \"K\", extensions:\
    \ [\"Ta\", \"TAR\", \"t234An\", \"cosSo\"]) == \"K.TAR\")\nassert(Strongest_Extension(class_name:\
    \ \"__HAHA\", extensions: [\"Tab\", \"123\", \"781345\", \"-_-\"]) == \"__HAHA.123\"\
    )\nassert(Strongest_Extension(class_name: \"YameRore\", extensions: [\"HhAas\"\
    , \"okIWILL123\", \"WorkOut\", \"Fails\", \"-_-\"]) == \"YameRore.okIWILL123\"\
    )\nassert(Strongest_Extension(class_name: \"finNNalLLly\", extensions: [\"Die\"\
    , \"NowW\", \"Wow\", \"WoW\"]) == \"finNNalLLly.WoW\")\nassert(Strongest_Extension(class_name:\
    \ \"_\", extensions: [\"Bb\", \"91245\"]) == \"_.Bb\")\nassert(Strongest_Extension(class_name:\
    \ \"Sp\", extensions: [\"671235\", \"Bb\"]) == \"Sp.671235\")"
  status: Exception
  stderr: 'tmp9x58cqgj/tmp9x58cqgj.swift:48: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b14343a6c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b143409db6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b143409d988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b143409c7b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmp9x58cqgj                        0x000055ef30114dec <unavailable> + 7660

    5    libc.so.6                          0x00002b1434592460 __libc_start_main +
    245

    6    tmp9x58cqgj                        0x000055ef301144f9 <unavailable> + 5369

    '
  stdout: ''
  timestamp: 1660009435
- exit_code: 1
  program: "\n/// You will be given the name of a class (a string) and an array of\
    \ extensions.\n/// The extensions are to be used to load additional classes to\
    \ the class. The\n/// strength of the extension is as follows: Let CAP be the\
    \ number of the uppercase\n/// letters in the extension's name, and let SM be\
    \ the number of lowercase letters \n/// in the extension's name, the strength\
    \ is given by the fraction CAP - SM. \n/// You should find the strongest extension\
    \ and return a string in this \n/// format: ClassName.StrongestExtensionName.\n\
    /// If there are two or more extensions with the same strength, you should\n///\
    \ choose the one that comes first in the array.\n/// For example, if you are given\
    \ \"Slices\" as the class and an array of the\n/// extensions: ['SErviNGSliCes',\
    \ 'Cheese', 'StuFfed'] then you should\n/// return 'Slices.SErviNGSliCes' since\
    \ 'SErviNGSliCes' is the strongest extension \n/// (its strength is -1).\n///\
    \ Example:\n/// >>> Strongest_Extension(class_name: \"my_class\", extensions:\
    \ [\"AA\", \"Be\", \"CC\"])\n/// \"my_class.AA\"\nfunc Strongest_Extension(class_name:\
    \ String, extensions: [String]) -> String {\n    var best_extension: String =\
    \ \"\"\n    var best_extension_strength: Double = 0.0\n    for e in extensions\
    \ {\n        let regex = try! NSRegularExpression(pattern: \"[A-Z]\", options:\
    \ .caseInsensitive)\n        let cap = regex.matches(in: e, options: [], range:\
    \ NSRange(location: 0, length: e.count)).count\n        let sm = e.count - cap\n\
    \        let strength = Double(cap) - Double(sm)\n        if strength > best_extension_strength\
    \ {\n            best_extension = e\n            best_extension_strength = strength\n\
    \        }\n    }\n    return \"\\(class_name).\\(best_extension)\"\n}\n\n\nfunc\
    \ ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count !=\
    \ right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(Strongest_Extension(class_name: \"Watashi\", extensions:\
    \ [\"tEN\", \"niNE\", \"eIGHt8OKe\"]) == \"Watashi.eIGHt8OKe\")\nassert(Strongest_Extension(class_name:\
    \ \"Boku123\", extensions: [\"nani\", \"NazeDa\", \"YEs.WeCaNe\", \"32145tggg\"\
    ]) == \"Boku123.YEs.WeCaNe\")\nassert(Strongest_Extension(class_name: \"__YESIMHERE\"\
    , extensions: [\"t\", \"eMptY\", \"nothing\", \"zeR00\", \"NuLl__\", \"123NoooneB321\"\
    ]) == \"__YESIMHERE.NuLl__\")\nassert(Strongest_Extension(class_name: \"K\", extensions:\
    \ [\"Ta\", \"TAR\", \"t234An\", \"cosSo\"]) == \"K.TAR\")\nassert(Strongest_Extension(class_name:\
    \ \"__HAHA\", extensions: [\"Tab\", \"123\", \"781345\", \"-_-\"]) == \"__HAHA.123\"\
    )\nassert(Strongest_Extension(class_name: \"YameRore\", extensions: [\"HhAas\"\
    , \"okIWILL123\", \"WorkOut\", \"Fails\", \"-_-\"]) == \"YameRore.okIWILL123\"\
    )\nassert(Strongest_Extension(class_name: \"finNNalLLly\", extensions: [\"Die\"\
    , \"NowW\", \"Wow\", \"WoW\"]) == \"finNNalLLly.WoW\")\nassert(Strongest_Extension(class_name:\
    \ \"_\", extensions: [\"Bb\", \"91245\"]) == \"_.Bb\")\nassert(Strongest_Extension(class_name:\
    \ \"Sp\", extensions: [\"671235\", \"Bb\"]) == \"Sp.671235\")"
  status: SyntaxError
  stderr: "/tmp/tmpcnjqx76m.swift:22:26: error: cannot find 'NSRegularExpression'\
    \ in scope\n        let regex = try! NSRegularExpression(pattern: \"[A-Z]\", options:\
    \ .caseInsensitive)\n                         ^~~~~~~~~~~~~~~~~~~\n/tmp/tmpcnjqx76m.swift:22:74:\
    \ error: cannot infer contextual base in reference to member 'caseInsensitive'\n\
    \        let regex = try! NSRegularExpression(pattern: \"[A-Z]\", options: .caseInsensitive)\n\
    \                                                                        ~^~~~~~~~~~~~~~~\n\
    /tmp/tmpcnjqx76m.swift:23:60: error: cannot find 'NSRange' in scope\n        let\
    \ cap = regex.matches(in: e, options: [], range: NSRange(location: 0, length:\
    \ e.count)).count\n                                                          \
    \ ^~~~~~~\n"
  stdout: ''
  timestamp: 1660009435
- exit_code: -4
  program: "\n/// You will be given the name of a class (a string) and an array of\
    \ extensions.\n/// The extensions are to be used to load additional classes to\
    \ the class. The\n/// strength of the extension is as follows: Let CAP be the\
    \ number of the uppercase\n/// letters in the extension's name, and let SM be\
    \ the number of lowercase letters \n/// in the extension's name, the strength\
    \ is given by the fraction CAP - SM. \n/// You should find the strongest extension\
    \ and return a string in this \n/// format: ClassName.StrongestExtensionName.\n\
    /// If there are two or more extensions with the same strength, you should\n///\
    \ choose the one that comes first in the array.\n/// For example, if you are given\
    \ \"Slices\" as the class and an array of the\n/// extensions: ['SErviNGSliCes',\
    \ 'Cheese', 'StuFfed'] then you should\n/// return 'Slices.SErviNGSliCes' since\
    \ 'SErviNGSliCes' is the strongest extension \n/// (its strength is -1).\n///\
    \ Example:\n/// >>> Strongest_Extension(class_name: \"my_class\", extensions:\
    \ [\"AA\", \"Be\", \"CC\"])\n/// \"my_class.AA\"\nfunc Strongest_Extension(class_name:\
    \ String, extensions: [String]) -> String {\n    var upperCase: Int = 0\n    var\
    \ lowerCase: Int = 0\n    var strongest: Int = 0\n    var strongestIndex: Int\
    \ = 0\n    for i in 0..<extensions.count {\n        for letter in extensions[i]\
    \ {\n            if letter.isUppercase {\n                upperCase += 1\n   \
    \         } else {\n                lowerCase += 1\n            }\n        }\n\
    \        if upperCase - lowerCase > strongest {\n            strongest = upperCase\
    \ - lowerCase\n            strongestIndex = i\n        }\n        upperCase =\
    \ 0\n        lowerCase = 0\n    }\n    return \"\\(class_name).\\(extensions[strongestIndex])\"\
    \n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(Strongest_Extension(class_name: \"Watashi\", extensions:\
    \ [\"tEN\", \"niNE\", \"eIGHt8OKe\"]) == \"Watashi.eIGHt8OKe\")\nassert(Strongest_Extension(class_name:\
    \ \"Boku123\", extensions: [\"nani\", \"NazeDa\", \"YEs.WeCaNe\", \"32145tggg\"\
    ]) == \"Boku123.YEs.WeCaNe\")\nassert(Strongest_Extension(class_name: \"__YESIMHERE\"\
    , extensions: [\"t\", \"eMptY\", \"nothing\", \"zeR00\", \"NuLl__\", \"123NoooneB321\"\
    ]) == \"__YESIMHERE.NuLl__\")\nassert(Strongest_Extension(class_name: \"K\", extensions:\
    \ [\"Ta\", \"TAR\", \"t234An\", \"cosSo\"]) == \"K.TAR\")\nassert(Strongest_Extension(class_name:\
    \ \"__HAHA\", extensions: [\"Tab\", \"123\", \"781345\", \"-_-\"]) == \"__HAHA.123\"\
    )\nassert(Strongest_Extension(class_name: \"YameRore\", extensions: [\"HhAas\"\
    , \"okIWILL123\", \"WorkOut\", \"Fails\", \"-_-\"]) == \"YameRore.okIWILL123\"\
    )\nassert(Strongest_Extension(class_name: \"finNNalLLly\", extensions: [\"Die\"\
    , \"NowW\", \"Wow\", \"WoW\"]) == \"finNNalLLly.WoW\")\nassert(Strongest_Extension(class_name:\
    \ \"_\", extensions: [\"Bb\", \"91245\"]) == \"_.Bb\")\nassert(Strongest_Extension(class_name:\
    \ \"Sp\", extensions: [\"671235\", \"Bb\"]) == \"Sp.671235\")"
  status: Exception
  stderr: 'tmp0a_61fro/tmp0a_61fro.swift:54: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b363f85ac80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b363f551b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b363f551988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b363f5507b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmp0a_61fro                        0x000055e8ef96bb0d <unavailable> + 6925

    5    libc.so.6                          0x00002b363fa46460 __libc_start_main +
    245

    6    tmp0a_61fro                        0x000055e8ef96b699 <unavailable> + 5785

    '
  stdout: ''
  timestamp: 1660009435
- exit_code: -4
  program: "\n/// You will be given the name of a class (a string) and an array of\
    \ extensions.\n/// The extensions are to be used to load additional classes to\
    \ the class. The\n/// strength of the extension is as follows: Let CAP be the\
    \ number of the uppercase\n/// letters in the extension's name, and let SM be\
    \ the number of lowercase letters \n/// in the extension's name, the strength\
    \ is given by the fraction CAP - SM. \n/// You should find the strongest extension\
    \ and return a string in this \n/// format: ClassName.StrongestExtensionName.\n\
    /// If there are two or more extensions with the same strength, you should\n///\
    \ choose the one that comes first in the array.\n/// For example, if you are given\
    \ \"Slices\" as the class and an array of the\n/// extensions: ['SErviNGSliCes',\
    \ 'Cheese', 'StuFfed'] then you should\n/// return 'Slices.SErviNGSliCes' since\
    \ 'SErviNGSliCes' is the strongest extension \n/// (its strength is -1).\n///\
    \ Example:\n/// >>> Strongest_Extension(class_name: \"my_class\", extensions:\
    \ [\"AA\", \"Be\", \"CC\"])\n/// \"my_class.AA\"\nfunc Strongest_Extension(class_name:\
    \ String, extensions: [String]) -> String {\n    var strongest_extension = \"\"\
    ;\n    var strongest_strength = 0;\n    for extension_name in extensions {\n \
    \       let num_uppercase = extension_name.filter { $0.isUppercase }.count;\n\
    \        let num_lowercase = extension_name.filter { $0.isLowercase }.count;\n\
    \        let strength = num_uppercase - num_lowercase;\n        if strength >\
    \ strongest_strength {\n            strongest_strength = strength;\n         \
    \   strongest_extension = extension_name;\n        }\n    }\n    return \"\\(class_name).\\\
    (strongest_extension)\";\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(Strongest_Extension(class_name:\
    \ \"Watashi\", extensions: [\"tEN\", \"niNE\", \"eIGHt8OKe\"]) == \"Watashi.eIGHt8OKe\"\
    )\nassert(Strongest_Extension(class_name: \"Boku123\", extensions: [\"nani\",\
    \ \"NazeDa\", \"YEs.WeCaNe\", \"32145tggg\"]) == \"Boku123.YEs.WeCaNe\")\nassert(Strongest_Extension(class_name:\
    \ \"__YESIMHERE\", extensions: [\"t\", \"eMptY\", \"nothing\", \"zeR00\", \"NuLl__\"\
    , \"123NoooneB321\"]) == \"__YESIMHERE.NuLl__\")\nassert(Strongest_Extension(class_name:\
    \ \"K\", extensions: [\"Ta\", \"TAR\", \"t234An\", \"cosSo\"]) == \"K.TAR\")\n\
    assert(Strongest_Extension(class_name: \"__HAHA\", extensions: [\"Tab\", \"123\"\
    , \"781345\", \"-_-\"]) == \"__HAHA.123\")\nassert(Strongest_Extension(class_name:\
    \ \"YameRore\", extensions: [\"HhAas\", \"okIWILL123\", \"WorkOut\", \"Fails\"\
    , \"-_-\"]) == \"YameRore.okIWILL123\")\nassert(Strongest_Extension(class_name:\
    \ \"finNNalLLly\", extensions: [\"Die\", \"NowW\", \"Wow\", \"WoW\"]) == \"finNNalLLly.WoW\"\
    )\nassert(Strongest_Extension(class_name: \"_\", extensions: [\"Bb\", \"91245\"\
    ]) == \"_.Bb\")\nassert(Strongest_Extension(class_name: \"Sp\", extensions: [\"\
    671235\", \"Bb\"]) == \"Sp.671235\")"
  status: Exception
  stderr: 'tmpi9f7ck4z/tmpi9f7ck4z.swift:48: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b582d96cc80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b582d663b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b582d663988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b582d6627b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpi9f7ck4z                        0x0000561da5c33f4c <unavailable> + 8012

    5    libc.so.6                          0x00002b582db58460 __libc_start_main +
    245

    6    tmpi9f7ck4z                        0x0000561da5c33659 <unavailable> + 5721

    '
  stdout: ''
  timestamp: 1660009435
- exit_code: -4
  program: "\n/// You will be given the name of a class (a string) and an array of\
    \ extensions.\n/// The extensions are to be used to load additional classes to\
    \ the class. The\n/// strength of the extension is as follows: Let CAP be the\
    \ number of the uppercase\n/// letters in the extension's name, and let SM be\
    \ the number of lowercase letters \n/// in the extension's name, the strength\
    \ is given by the fraction CAP - SM. \n/// You should find the strongest extension\
    \ and return a string in this \n/// format: ClassName.StrongestExtensionName.\n\
    /// If there are two or more extensions with the same strength, you should\n///\
    \ choose the one that comes first in the array.\n/// For example, if you are given\
    \ \"Slices\" as the class and an array of the\n/// extensions: ['SErviNGSliCes',\
    \ 'Cheese', 'StuFfed'] then you should\n/// return 'Slices.SErviNGSliCes' since\
    \ 'SErviNGSliCes' is the strongest extension \n/// (its strength is -1).\n///\
    \ Example:\n/// >>> Strongest_Extension(class_name: \"my_class\", extensions:\
    \ [\"AA\", \"Be\", \"CC\"])\n/// \"my_class.AA\"\nfunc Strongest_Extension(class_name:\
    \ String, extensions: [String]) -> String {\n    // Your code here\n    var class_name\
    \ = class_name\n    var extensions = extensions\n    var mx: Int = 0\n    var\
    \ mx_string: String = \"\"\n    for i in extensions {\n        var strength: Int\
    \ = 0\n        for j in i {\n            if j.isLowercase {\n                strength\
    \ -= 1\n            } else {\n                strength += 1\n            }\n \
    \       }\n        if abs(strength) > mx {\n            mx = abs(strength)\n \
    \           mx_string = i\n        }\n    }\n    class_name += \".\" + mx_string\n\
    \    return class_name\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(Strongest_Extension(class_name:\
    \ \"Watashi\", extensions: [\"tEN\", \"niNE\", \"eIGHt8OKe\"]) == \"Watashi.eIGHt8OKe\"\
    )\nassert(Strongest_Extension(class_name: \"Boku123\", extensions: [\"nani\",\
    \ \"NazeDa\", \"YEs.WeCaNe\", \"32145tggg\"]) == \"Boku123.YEs.WeCaNe\")\nassert(Strongest_Extension(class_name:\
    \ \"__YESIMHERE\", extensions: [\"t\", \"eMptY\", \"nothing\", \"zeR00\", \"NuLl__\"\
    , \"123NoooneB321\"]) == \"__YESIMHERE.NuLl__\")\nassert(Strongest_Extension(class_name:\
    \ \"K\", extensions: [\"Ta\", \"TAR\", \"t234An\", \"cosSo\"]) == \"K.TAR\")\n\
    assert(Strongest_Extension(class_name: \"__HAHA\", extensions: [\"Tab\", \"123\"\
    , \"781345\", \"-_-\"]) == \"__HAHA.123\")\nassert(Strongest_Extension(class_name:\
    \ \"YameRore\", extensions: [\"HhAas\", \"okIWILL123\", \"WorkOut\", \"Fails\"\
    , \"-_-\"]) == \"YameRore.okIWILL123\")\nassert(Strongest_Extension(class_name:\
    \ \"finNNalLLly\", extensions: [\"Die\", \"NowW\", \"Wow\", \"WoW\"]) == \"finNNalLLly.WoW\"\
    )\nassert(Strongest_Extension(class_name: \"_\", extensions: [\"Bb\", \"91245\"\
    ]) == \"_.Bb\")\nassert(Strongest_Extension(class_name: \"Sp\", extensions: [\"\
    671235\", \"Bb\"]) == \"Sp.671235\")"
  status: Exception
  stderr: 'tmp9ml023xg/tmp9ml023xg.swift:56: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b75f8ddbc80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b75f8ad2b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b75f8ad2988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b75f8ad17b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmp9ml023xg                        0x0000563f692bfb17 <unavailable> + 6935

    5    libc.so.6                          0x00002b75f8fc7460 __libc_start_main +
    245

    6    tmp9ml023xg                        0x0000563f692bf499 <unavailable> + 5273

    '
  stdout: ''
  timestamp: 1660009435
- exit_code: -4
  program: "\n/// You will be given the name of a class (a string) and an array of\
    \ extensions.\n/// The extensions are to be used to load additional classes to\
    \ the class. The\n/// strength of the extension is as follows: Let CAP be the\
    \ number of the uppercase\n/// letters in the extension's name, and let SM be\
    \ the number of lowercase letters \n/// in the extension's name, the strength\
    \ is given by the fraction CAP - SM. \n/// You should find the strongest extension\
    \ and return a string in this \n/// format: ClassName.StrongestExtensionName.\n\
    /// If there are two or more extensions with the same strength, you should\n///\
    \ choose the one that comes first in the array.\n/// For example, if you are given\
    \ \"Slices\" as the class and an array of the\n/// extensions: ['SErviNGSliCes',\
    \ 'Cheese', 'StuFfed'] then you should\n/// return 'Slices.SErviNGSliCes' since\
    \ 'SErviNGSliCes' is the strongest extension \n/// (its strength is -1).\n///\
    \ Example:\n/// >>> Strongest_Extension(class_name: \"my_class\", extensions:\
    \ [\"AA\", \"Be\", \"CC\"])\n/// \"my_class.AA\"\nfunc Strongest_Extension(class_name:\
    \ String, extensions: [String]) -> String {\n    return \"\"\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(Strongest_Extension(class_name: \"Watashi\", extensions:\
    \ [\"tEN\", \"niNE\", \"eIGHt8OKe\"]) == \"Watashi.eIGHt8OKe\")\nassert(Strongest_Extension(class_name:\
    \ \"Boku123\", extensions: [\"nani\", \"NazeDa\", \"YEs.WeCaNe\", \"32145tggg\"\
    ]) == \"Boku123.YEs.WeCaNe\")\nassert(Strongest_Extension(class_name: \"__YESIMHERE\"\
    , extensions: [\"t\", \"eMptY\", \"nothing\", \"zeR00\", \"NuLl__\", \"123NoooneB321\"\
    ]) == \"__YESIMHERE.NuLl__\")\nassert(Strongest_Extension(class_name: \"K\", extensions:\
    \ [\"Ta\", \"TAR\", \"t234An\", \"cosSo\"]) == \"K.TAR\")\nassert(Strongest_Extension(class_name:\
    \ \"__HAHA\", extensions: [\"Tab\", \"123\", \"781345\", \"-_-\"]) == \"__HAHA.123\"\
    )\nassert(Strongest_Extension(class_name: \"YameRore\", extensions: [\"HhAas\"\
    , \"okIWILL123\", \"WorkOut\", \"Fails\", \"-_-\"]) == \"YameRore.okIWILL123\"\
    )\nassert(Strongest_Extension(class_name: \"finNNalLLly\", extensions: [\"Die\"\
    , \"NowW\", \"Wow\", \"WoW\"]) == \"finNNalLLly.WoW\")\nassert(Strongest_Extension(class_name:\
    \ \"_\", extensions: [\"Bb\", \"91245\"]) == \"_.Bb\")\nassert(Strongest_Extension(class_name:\
    \ \"Sp\", extensions: [\"671235\", \"Bb\"]) == \"Sp.671235\")"
  status: Exception
  stderr: 'tmpuhmbxdp4/tmpuhmbxdp4.swift:35: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002abeef348c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002abeef03fb6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002abeef03f988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002abeef03e7b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpuhmbxdp4                        0x0000559ee0d614fd <unavailable> + 5373

    5    libc.so.6                          0x00002abeef534460 __libc_start_main +
    245

    6    tmpuhmbxdp4                        0x0000559ee0d61089 <unavailable> + 4233

    '
  stdout: ''
  timestamp: 1660009431
- exit_code: -4
  program: "\n/// You will be given the name of a class (a string) and an array of\
    \ extensions.\n/// The extensions are to be used to load additional classes to\
    \ the class. The\n/// strength of the extension is as follows: Let CAP be the\
    \ number of the uppercase\n/// letters in the extension's name, and let SM be\
    \ the number of lowercase letters \n/// in the extension's name, the strength\
    \ is given by the fraction CAP - SM. \n/// You should find the strongest extension\
    \ and return a string in this \n/// format: ClassName.StrongestExtensionName.\n\
    /// If there are two or more extensions with the same strength, you should\n///\
    \ choose the one that comes first in the array.\n/// For example, if you are given\
    \ \"Slices\" as the class and an array of the\n/// extensions: ['SErviNGSliCes',\
    \ 'Cheese', 'StuFfed'] then you should\n/// return 'Slices.SErviNGSliCes' since\
    \ 'SErviNGSliCes' is the strongest extension \n/// (its strength is -1).\n///\
    \ Example:\n/// >>> Strongest_Extension(class_name: \"my_class\", extensions:\
    \ [\"AA\", \"Be\", \"CC\"])\n/// \"my_class.AA\"\nfunc Strongest_Extension(class_name:\
    \ String, extensions: [String]) -> String {\n    return \"my_class.AA\"\n}\n\n\
    \nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(Strongest_Extension(class_name: \"Watashi\", extensions:\
    \ [\"tEN\", \"niNE\", \"eIGHt8OKe\"]) == \"Watashi.eIGHt8OKe\")\nassert(Strongest_Extension(class_name:\
    \ \"Boku123\", extensions: [\"nani\", \"NazeDa\", \"YEs.WeCaNe\", \"32145tggg\"\
    ]) == \"Boku123.YEs.WeCaNe\")\nassert(Strongest_Extension(class_name: \"__YESIMHERE\"\
    , extensions: [\"t\", \"eMptY\", \"nothing\", \"zeR00\", \"NuLl__\", \"123NoooneB321\"\
    ]) == \"__YESIMHERE.NuLl__\")\nassert(Strongest_Extension(class_name: \"K\", extensions:\
    \ [\"Ta\", \"TAR\", \"t234An\", \"cosSo\"]) == \"K.TAR\")\nassert(Strongest_Extension(class_name:\
    \ \"__HAHA\", extensions: [\"Tab\", \"123\", \"781345\", \"-_-\"]) == \"__HAHA.123\"\
    )\nassert(Strongest_Extension(class_name: \"YameRore\", extensions: [\"HhAas\"\
    , \"okIWILL123\", \"WorkOut\", \"Fails\", \"-_-\"]) == \"YameRore.okIWILL123\"\
    )\nassert(Strongest_Extension(class_name: \"finNNalLLly\", extensions: [\"Die\"\
    , \"NowW\", \"Wow\", \"WoW\"]) == \"finNNalLLly.WoW\")\nassert(Strongest_Extension(class_name:\
    \ \"_\", extensions: [\"Bb\", \"91245\"]) == \"_.Bb\")\nassert(Strongest_Extension(class_name:\
    \ \"Sp\", extensions: [\"671235\", \"Bb\"]) == \"Sp.671235\")"
  status: Exception
  stderr: 'tmpb5tys6fa/tmpb5tys6fa.swift:35: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b35b960ac80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b35b9301b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b35b9301988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b35b93007b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpb5tys6fa                        0x00005564e72294fd <unavailable> + 5373

    5    libc.so.6                          0x00002b35b97f6460 __libc_start_main +
    245

    6    tmpb5tys6fa                        0x00005564e7229089 <unavailable> + 4233

    '
  stdout: ''
  timestamp: 1660009434
- exit_code: 1
  program: "\n/// You will be given the name of a class (a string) and an array of\
    \ extensions.\n/// The extensions are to be used to load additional classes to\
    \ the class. The\n/// strength of the extension is as follows: Let CAP be the\
    \ number of the uppercase\n/// letters in the extension's name, and let SM be\
    \ the number of lowercase letters \n/// in the extension's name, the strength\
    \ is given by the fraction CAP - SM. \n/// You should find the strongest extension\
    \ and return a string in this \n/// format: ClassName.StrongestExtensionName.\n\
    /// If there are two or more extensions with the same strength, you should\n///\
    \ choose the one that comes first in the array.\n/// For example, if you are given\
    \ \"Slices\" as the class and an array of the\n/// extensions: ['SErviNGSliCes',\
    \ 'Cheese', 'StuFfed'] then you should\n/// return 'Slices.SErviNGSliCes' since\
    \ 'SErviNGSliCes' is the strongest extension \n/// (its strength is -1).\n///\
    \ Example:\n/// >>> Strongest_Extension(class_name: \"my_class\", extensions:\
    \ [\"AA\", \"Be\", \"CC\"])\n/// \"my_class.AA\"\nfunc Strongest_Extension(class_name:\
    \ String, extensions: [String]) -> String {\n    var strongest = (\"\", 0)\n \
    \   var diff: Float = 0\n    for ext in extensions {\n        diff = 0\n     \
    \   for char in ext {\n            if char.isUppercase {\n                diff\
    \ += 1\n            } else {\n                diff -= 1\n            }\n     \
    \   }\n        if diff > strongest.1 {\n            strongest = (ext, diff)\n\
    \        }\n    }\n    return \"\\(class_name).\\(strongest.0)\"\n}\n\n\nfunc\
    \ ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count !=\
    \ right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(Strongest_Extension(class_name: \"Watashi\", extensions:\
    \ [\"tEN\", \"niNE\", \"eIGHt8OKe\"]) == \"Watashi.eIGHt8OKe\")\nassert(Strongest_Extension(class_name:\
    \ \"Boku123\", extensions: [\"nani\", \"NazeDa\", \"YEs.WeCaNe\", \"32145tggg\"\
    ]) == \"Boku123.YEs.WeCaNe\")\nassert(Strongest_Extension(class_name: \"__YESIMHERE\"\
    , extensions: [\"t\", \"eMptY\", \"nothing\", \"zeR00\", \"NuLl__\", \"123NoooneB321\"\
    ]) == \"__YESIMHERE.NuLl__\")\nassert(Strongest_Extension(class_name: \"K\", extensions:\
    \ [\"Ta\", \"TAR\", \"t234An\", \"cosSo\"]) == \"K.TAR\")\nassert(Strongest_Extension(class_name:\
    \ \"__HAHA\", extensions: [\"Tab\", \"123\", \"781345\", \"-_-\"]) == \"__HAHA.123\"\
    )\nassert(Strongest_Extension(class_name: \"YameRore\", extensions: [\"HhAas\"\
    , \"okIWILL123\", \"WorkOut\", \"Fails\", \"-_-\"]) == \"YameRore.okIWILL123\"\
    )\nassert(Strongest_Extension(class_name: \"finNNalLLly\", extensions: [\"Die\"\
    , \"NowW\", \"Wow\", \"WoW\"]) == \"finNNalLLly.WoW\")\nassert(Strongest_Extension(class_name:\
    \ \"_\", extensions: [\"Bb\", \"91245\"]) == \"_.Bb\")\nassert(Strongest_Extension(class_name:\
    \ \"Sp\", extensions: [\"671235\", \"Bb\"]) == \"Sp.671235\")"
  status: SyntaxError
  stderr: "/tmp/tmpgmjo28tf.swift:30:17: error: binary operator '>' cannot be applied\
    \ to operands of type 'Float' and 'Int'\n        if diff > strongest.1 {\n   \
    \        ~~~~ ^ ~~~~~~~~~~~\n/tmp/tmpgmjo28tf.swift:30:17: note: overloads for\
    \ '>' exist with these partially matching parameter lists: (Int, Int)\n      \
    \  if diff > strongest.1 {\n                ^\n/tmp/tmpgmjo28tf.swift:31:23: error:\
    \ cannot assign value of type '(String, Float)' to type '(String, Int)'\n    \
    \        strongest = (ext, diff)\n                      ^\n"
  stdout: ''
  timestamp: 1660009435
- exit_code: 1
  program: "\n/// You will be given the name of a class (a string) and an array of\
    \ extensions.\n/// The extensions are to be used to load additional classes to\
    \ the class. The\n/// strength of the extension is as follows: Let CAP be the\
    \ number of the uppercase\n/// letters in the extension's name, and let SM be\
    \ the number of lowercase letters \n/// in the extension's name, the strength\
    \ is given by the fraction CAP - SM. \n/// You should find the strongest extension\
    \ and return a string in this \n/// format: ClassName.StrongestExtensionName.\n\
    /// If there are two or more extensions with the same strength, you should\n///\
    \ choose the one that comes first in the array.\n/// For example, if you are given\
    \ \"Slices\" as the class and an array of the\n/// extensions: ['SErviNGSliCes',\
    \ 'Cheese', 'StuFfed'] then you should\n/// return 'Slices.SErviNGSliCes' since\
    \ 'SErviNGSliCes' is the strongest extension \n/// (its strength is -1).\n///\
    \ Example:\n/// >>> Strongest_Extension(class_name: \"my_class\", extensions:\
    \ [\"AA\", \"Be\", \"CC\"])\n/// \"my_class.AA\"\nfunc Strongest_Extension(class_name:\
    \ String, extensions: [String]) -> String {\n    var strongest = \"\"\n    var\
    \ strongestStrength = 0.0\n    for extension in extensions {\n        var numUpper\
    \ = 0\n        var numLower = 0\n        for letter in extension {\n         \
    \   if letter.isUppercase {\n                numUpper += 1\n            } else\
    \ {\n                numLower += 1\n            }\n        }\n        let strength\
    \ = Double(numUpper) - Double(numLower)\n        if strength > strongestStrength\
    \ {\n            strongestStrength = strength\n            strongest = extension\n\
    \        }\n    }\n    return \"\\(class_name).\\(strongest)\"\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(Strongest_Extension(class_name: \"Watashi\", extensions:\
    \ [\"tEN\", \"niNE\", \"eIGHt8OKe\"]) == \"Watashi.eIGHt8OKe\")\nassert(Strongest_Extension(class_name:\
    \ \"Boku123\", extensions: [\"nani\", \"NazeDa\", \"YEs.WeCaNe\", \"32145tggg\"\
    ]) == \"Boku123.YEs.WeCaNe\")\nassert(Strongest_Extension(class_name: \"__YESIMHERE\"\
    , extensions: [\"t\", \"eMptY\", \"nothing\", \"zeR00\", \"NuLl__\", \"123NoooneB321\"\
    ]) == \"__YESIMHERE.NuLl__\")\nassert(Strongest_Extension(class_name: \"K\", extensions:\
    \ [\"Ta\", \"TAR\", \"t234An\", \"cosSo\"]) == \"K.TAR\")\nassert(Strongest_Extension(class_name:\
    \ \"__HAHA\", extensions: [\"Tab\", \"123\", \"781345\", \"-_-\"]) == \"__HAHA.123\"\
    )\nassert(Strongest_Extension(class_name: \"YameRore\", extensions: [\"HhAas\"\
    , \"okIWILL123\", \"WorkOut\", \"Fails\", \"-_-\"]) == \"YameRore.okIWILL123\"\
    )\nassert(Strongest_Extension(class_name: \"finNNalLLly\", extensions: [\"Die\"\
    , \"NowW\", \"Wow\", \"WoW\"]) == \"finNNalLLly.WoW\")\nassert(Strongest_Extension(class_name:\
    \ \"_\", extensions: [\"Bb\", \"91245\"]) == \"_.Bb\")\nassert(Strongest_Extension(class_name:\
    \ \"Sp\", extensions: [\"671235\", \"Bb\"]) == \"Sp.671235\")"
  status: SyntaxError
  stderr: "/tmp/tmph346jqtu.swift:21:9: error: expected pattern\n    for extension\
    \ in extensions {\n        ^\n/tmp/tmph346jqtu.swift:21:9: error: expected Sequence\
    \ expression for for-each loop\n    for extension in extensions {\n        ^\n\
    /tmp/tmph346jqtu.swift:21:9: error: expected '{' to start the body of for-each\
    \ loop\n    for extension in extensions {\n        ^\n/tmp/tmph346jqtu.swift:24:23:\
    \ error: expected Sequence expression for for-each loop\n        for letter in\
    \ extension {\n                      ^\n/tmp/tmph346jqtu.swift:24:23: error: expected\
    \ '{' to start the body of for-each loop\n        for letter in extension {\n\
    \                      ^\n/tmp/tmph346jqtu.swift:34:25: error: expected expression\
    \ in assignment\n            strongest = extension\n                        ^\n\
    /tmp/tmph346jqtu.swift:35:9: error: expected type name in extension declaration\n\
    \        }\n        ^\n/tmp/tmph346jqtu.swift:34:34: error: expected '{' in extension\n\
    \            strongest = extension\n                                 ^\n/tmp/tmph346jqtu.swift:34:25:\
    \ error: declaration is only valid at file scope\n            strongest = extension\n\
    \                        ^\n"
  stdout: ''
  timestamp: 1660009435
- exit_code: 1
  program: "\n/// You will be given the name of a class (a string) and an array of\
    \ extensions.\n/// The extensions are to be used to load additional classes to\
    \ the class. The\n/// strength of the extension is as follows: Let CAP be the\
    \ number of the uppercase\n/// letters in the extension's name, and let SM be\
    \ the number of lowercase letters \n/// in the extension's name, the strength\
    \ is given by the fraction CAP - SM. \n/// You should find the strongest extension\
    \ and return a string in this \n/// format: ClassName.StrongestExtensionName.\n\
    /// If there are two or more extensions with the same strength, you should\n///\
    \ choose the one that comes first in the array.\n/// For example, if you are given\
    \ \"Slices\" as the class and an array of the\n/// extensions: ['SErviNGSliCes',\
    \ 'Cheese', 'StuFfed'] then you should\n/// return 'Slices.SErviNGSliCes' since\
    \ 'SErviNGSliCes' is the strongest extension \n/// (its strength is -1).\n///\
    \ Example:\n/// >>> Strongest_Extension(class_name: \"my_class\", extensions:\
    \ [\"AA\", \"Be\", \"CC\"])\n/// \"my_class.AA\"\nfunc Strongest_Extension(class_name:\
    \ String, extensions: [String]) -> String {\n    let upperCase = CharacterSet.uppercaseLetters\n\
    \    let lowerCase = CharacterSet.lowercaseLetters\n    var return_string = class_name\n\
    \    var max_strength = 0.0\n    for extension_name in extensions {\n        var\
    \ caps_strength = 0\n        var small_strength = 0\n        for character in\
    \ extension_name.characters {\n            if character.isLowercase {\n      \
    \          small_strength += 1\n            } else if character.isUppercase {\n\
    \                caps_strength += 1\n            }\n        }\n        let current_strength\
    \ = Double(caps_strength) - Double(small_strength)\n        if max_strength <\
    \ current_strength {\n            max_strength = current_strength\n          \
    \  return_string = return_string + \".\" + extension_name\n        }\n    }\n\
    \    return return_string\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(Strongest_Extension(class_name:\
    \ \"Watashi\", extensions: [\"tEN\", \"niNE\", \"eIGHt8OKe\"]) == \"Watashi.eIGHt8OKe\"\
    )\nassert(Strongest_Extension(class_name: \"Boku123\", extensions: [\"nani\",\
    \ \"NazeDa\", \"YEs.WeCaNe\", \"32145tggg\"]) == \"Boku123.YEs.WeCaNe\")\nassert(Strongest_Extension(class_name:\
    \ \"__YESIMHERE\", extensions: [\"t\", \"eMptY\", \"nothing\", \"zeR00\", \"NuLl__\"\
    , \"123NoooneB321\"]) == \"__YESIMHERE.NuLl__\")\nassert(Strongest_Extension(class_name:\
    \ \"K\", extensions: [\"Ta\", \"TAR\", \"t234An\", \"cosSo\"]) == \"K.TAR\")\n\
    assert(Strongest_Extension(class_name: \"__HAHA\", extensions: [\"Tab\", \"123\"\
    , \"781345\", \"-_-\"]) == \"__HAHA.123\")\nassert(Strongest_Extension(class_name:\
    \ \"YameRore\", extensions: [\"HhAas\", \"okIWILL123\", \"WorkOut\", \"Fails\"\
    , \"-_-\"]) == \"YameRore.okIWILL123\")\nassert(Strongest_Extension(class_name:\
    \ \"finNNalLLly\", extensions: [\"Die\", \"NowW\", \"Wow\", \"WoW\"]) == \"finNNalLLly.WoW\"\
    )\nassert(Strongest_Extension(class_name: \"_\", extensions: [\"Bb\", \"91245\"\
    ]) == \"_.Bb\")\nassert(Strongest_Extension(class_name: \"Sp\", extensions: [\"\
    671235\", \"Bb\"]) == \"Sp.671235\")"
  status: SyntaxError
  stderr: "/tmp/tmpv8i6lmfl.swift:19:21: error: cannot find 'CharacterSet' in scope\n\
    \    let upperCase = CharacterSet.uppercaseLetters\n                    ^~~~~~~~~~~~\n\
    /tmp/tmpv8i6lmfl.swift:20:21: error: cannot find 'CharacterSet' in scope\n   \
    \ let lowerCase = CharacterSet.lowercaseLetters\n                    ^~~~~~~~~~~~\n\
    /tmp/tmpv8i6lmfl.swift:26:41: error: 'characters' is unavailable: Please use String\
    \ directly\n        for character in extension_name.characters {\n           \
    \                             ^~~~~~~~~~\nSwift.String:5:16: note: 'characters'\
    \ was obsoleted in Swift 5.0\n    public var characters: String { get set }\n\
    \               ^\n"
  stdout: ''
  timestamp: 1660009435
- exit_code: 1
  program: "\n/// You will be given the name of a class (a string) and an array of\
    \ extensions.\n/// The extensions are to be used to load additional classes to\
    \ the class. The\n/// strength of the extension is as follows: Let CAP be the\
    \ number of the uppercase\n/// letters in the extension's name, and let SM be\
    \ the number of lowercase letters \n/// in the extension's name, the strength\
    \ is given by the fraction CAP - SM. \n/// You should find the strongest extension\
    \ and return a string in this \n/// format: ClassName.StrongestExtensionName.\n\
    /// If there are two or more extensions with the same strength, you should\n///\
    \ choose the one that comes first in the array.\n/// For example, if you are given\
    \ \"Slices\" as the class and an array of the\n/// extensions: ['SErviNGSliCes',\
    \ 'Cheese', 'StuFfed'] then you should\n/// return 'Slices.SErviNGSliCes' since\
    \ 'SErviNGSliCes' is the strongest extension \n/// (its strength is -1).\n///\
    \ Example:\n/// >>> Strongest_Extension(class_name: \"my_class\", extensions:\
    \ [\"AA\", \"Be\", \"CC\"])\n/// \"my_class.AA\"\nfunc Strongest_Extension(class_name:\
    \ String, extensions: [String]) -> String {\n    var strongest_extension: String\
    \ = \"\"\n    var strength: Float = 0\n    for extension_name in extensions {\n\
    \        let letters = Array(extension_name)\n        var sm: Float = 0\n    \
    \    var cap: Float = 0\n        for letter in letters {\n            if letter.lowercased()\
    \ == letter {\n                sm += 1\n            } else {\n               \
    \ cap += 1\n            }\n        }\n        let extension_strength = cap - sm\n\
    \        if strength < extension_strength {\n            strength = extension_strength\n\
    \            strongest_extension = extension_name\n        }\n    }\n    return\
    \ \"\\(class_name).\\(strongest_extension)\"\n}\n\n\nfunc ==(left: [(Int, Int)],\
    \ right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n       \
    \ return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r\
    \ {\n            return false\n        }\n    }\n    return true\n}\n        \
    \    \nassert(Strongest_Extension(class_name: \"Watashi\", extensions: [\"tEN\"\
    , \"niNE\", \"eIGHt8OKe\"]) == \"Watashi.eIGHt8OKe\")\nassert(Strongest_Extension(class_name:\
    \ \"Boku123\", extensions: [\"nani\", \"NazeDa\", \"YEs.WeCaNe\", \"32145tggg\"\
    ]) == \"Boku123.YEs.WeCaNe\")\nassert(Strongest_Extension(class_name: \"__YESIMHERE\"\
    , extensions: [\"t\", \"eMptY\", \"nothing\", \"zeR00\", \"NuLl__\", \"123NoooneB321\"\
    ]) == \"__YESIMHERE.NuLl__\")\nassert(Strongest_Extension(class_name: \"K\", extensions:\
    \ [\"Ta\", \"TAR\", \"t234An\", \"cosSo\"]) == \"K.TAR\")\nassert(Strongest_Extension(class_name:\
    \ \"__HAHA\", extensions: [\"Tab\", \"123\", \"781345\", \"-_-\"]) == \"__HAHA.123\"\
    )\nassert(Strongest_Extension(class_name: \"YameRore\", extensions: [\"HhAas\"\
    , \"okIWILL123\", \"WorkOut\", \"Fails\", \"-_-\"]) == \"YameRore.okIWILL123\"\
    )\nassert(Strongest_Extension(class_name: \"finNNalLLly\", extensions: [\"Die\"\
    , \"NowW\", \"Wow\", \"WoW\"]) == \"finNNalLLly.WoW\")\nassert(Strongest_Extension(class_name:\
    \ \"_\", extensions: [\"Bb\", \"91245\"]) == \"_.Bb\")\nassert(Strongest_Extension(class_name:\
    \ \"Sp\", extensions: [\"671235\", \"Bb\"]) == \"Sp.671235\")"
  status: SyntaxError
  stderr: "/tmp/tmp2ovkv5az.swift:26:36: error: binary operator '==' cannot be applied\
    \ to operands of type 'String' and 'String.Element' (aka 'Character')\n      \
    \      if letter.lowercased() == letter {\n               ~~~~~~~~~~~~~~~~~~~\
    \ ^  ~~~~~~\n/tmp/tmp2ovkv5az.swift:26:36: note: overloads for '==' exist with\
    \ these partially matching parameter lists: (Character, Character), (String, String)\n\
    \            if letter.lowercased() == letter {\n                            \
    \       ^\n"
  stdout: ''
  timestamp: 1660009435
- exit_code: 1
  program: "\n/// You will be given the name of a class (a string) and an array of\
    \ extensions.\n/// The extensions are to be used to load additional classes to\
    \ the class. The\n/// strength of the extension is as follows: Let CAP be the\
    \ number of the uppercase\n/// letters in the extension's name, and let SM be\
    \ the number of lowercase letters \n/// in the extension's name, the strength\
    \ is given by the fraction CAP - SM. \n/// You should find the strongest extension\
    \ and return a string in this \n/// format: ClassName.StrongestExtensionName.\n\
    /// If there are two or more extensions with the same strength, you should\n///\
    \ choose the one that comes first in the array.\n/// For example, if you are given\
    \ \"Slices\" as the class and an array of the\n/// extensions: ['SErviNGSliCes',\
    \ 'Cheese', 'StuFfed'] then you should\n/// return 'Slices.SErviNGSliCes' since\
    \ 'SErviNGSliCes' is the strongest extension \n/// (its strength is -1).\n///\
    \ Example:\n/// >>> Strongest_Extension(class_name: \"my_class\", extensions:\
    \ [\"AA\", \"Be\", \"CC\"])\n/// \"my_class.AA\"\nfunc Strongest_Extension(class_name:\
    \ String, extensions: [String]) -> String {\n    var strongest = extensions[0]\n\
    \    for i in 1..<extensions.count {\n        let strength1 = strength(string:\
    \ strongest)\n        let strength2 = strength(string: extensions[i])\n      \
    \  if (strength1 < strength2) {\n            strongest = extensions[i]\n     \
    \   }\n    }\n    return class_name + \".\" + strongest\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(Strongest_Extension(class_name: \"Watashi\", extensions:\
    \ [\"tEN\", \"niNE\", \"eIGHt8OKe\"]) == \"Watashi.eIGHt8OKe\")\nassert(Strongest_Extension(class_name:\
    \ \"Boku123\", extensions: [\"nani\", \"NazeDa\", \"YEs.WeCaNe\", \"32145tggg\"\
    ]) == \"Boku123.YEs.WeCaNe\")\nassert(Strongest_Extension(class_name: \"__YESIMHERE\"\
    , extensions: [\"t\", \"eMptY\", \"nothing\", \"zeR00\", \"NuLl__\", \"123NoooneB321\"\
    ]) == \"__YESIMHERE.NuLl__\")\nassert(Strongest_Extension(class_name: \"K\", extensions:\
    \ [\"Ta\", \"TAR\", \"t234An\", \"cosSo\"]) == \"K.TAR\")\nassert(Strongest_Extension(class_name:\
    \ \"__HAHA\", extensions: [\"Tab\", \"123\", \"781345\", \"-_-\"]) == \"__HAHA.123\"\
    )\nassert(Strongest_Extension(class_name: \"YameRore\", extensions: [\"HhAas\"\
    , \"okIWILL123\", \"WorkOut\", \"Fails\", \"-_-\"]) == \"YameRore.okIWILL123\"\
    )\nassert(Strongest_Extension(class_name: \"finNNalLLly\", extensions: [\"Die\"\
    , \"NowW\", \"Wow\", \"WoW\"]) == \"finNNalLLly.WoW\")\nassert(Strongest_Extension(class_name:\
    \ \"_\", extensions: [\"Bb\", \"91245\"]) == \"_.Bb\")\nassert(Strongest_Extension(class_name:\
    \ \"Sp\", extensions: [\"671235\", \"Bb\"]) == \"Sp.671235\")"
  status: SyntaxError
  stderr: "/tmp/tmpzij53jzs.swift:21:25: error: cannot find 'strength' in scope\n\
    \        let strength1 = strength(string: strongest)\n                       \
    \ ^~~~~~~~\n/tmp/tmpzij53jzs.swift:22:25: error: cannot find 'strength' in scope\n\
    \        let strength2 = strength(string: extensions[i])\n                   \
    \     ^~~~~~~~\n"
  stdout: ''
  timestamp: 1660009435
- exit_code: -4
  program: "\n/// You will be given the name of a class (a string) and an array of\
    \ extensions.\n/// The extensions are to be used to load additional classes to\
    \ the class. The\n/// strength of the extension is as follows: Let CAP be the\
    \ number of the uppercase\n/// letters in the extension's name, and let SM be\
    \ the number of lowercase letters \n/// in the extension's name, the strength\
    \ is given by the fraction CAP - SM. \n/// You should find the strongest extension\
    \ and return a string in this \n/// format: ClassName.StrongestExtensionName.\n\
    /// If there are two or more extensions with the same strength, you should\n///\
    \ choose the one that comes first in the array.\n/// For example, if you are given\
    \ \"Slices\" as the class and an array of the\n/// extensions: ['SErviNGSliCes',\
    \ 'Cheese', 'StuFfed'] then you should\n/// return 'Slices.SErviNGSliCes' since\
    \ 'SErviNGSliCes' is the strongest extension \n/// (its strength is -1).\n///\
    \ Example:\n/// >>> Strongest_Extension(class_name: \"my_class\", extensions:\
    \ [\"AA\", \"Be\", \"CC\"])\n/// \"my_class.AA\"\nfunc Strongest_Extension(class_name:\
    \ String, extensions: [String]) -> String {\n    return \"\"\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(Strongest_Extension(class_name: \"Watashi\", extensions:\
    \ [\"tEN\", \"niNE\", \"eIGHt8OKe\"]) == \"Watashi.eIGHt8OKe\")\nassert(Strongest_Extension(class_name:\
    \ \"Boku123\", extensions: [\"nani\", \"NazeDa\", \"YEs.WeCaNe\", \"32145tggg\"\
    ]) == \"Boku123.YEs.WeCaNe\")\nassert(Strongest_Extension(class_name: \"__YESIMHERE\"\
    , extensions: [\"t\", \"eMptY\", \"nothing\", \"zeR00\", \"NuLl__\", \"123NoooneB321\"\
    ]) == \"__YESIMHERE.NuLl__\")\nassert(Strongest_Extension(class_name: \"K\", extensions:\
    \ [\"Ta\", \"TAR\", \"t234An\", \"cosSo\"]) == \"K.TAR\")\nassert(Strongest_Extension(class_name:\
    \ \"__HAHA\", extensions: [\"Tab\", \"123\", \"781345\", \"-_-\"]) == \"__HAHA.123\"\
    )\nassert(Strongest_Extension(class_name: \"YameRore\", extensions: [\"HhAas\"\
    , \"okIWILL123\", \"WorkOut\", \"Fails\", \"-_-\"]) == \"YameRore.okIWILL123\"\
    )\nassert(Strongest_Extension(class_name: \"finNNalLLly\", extensions: [\"Die\"\
    , \"NowW\", \"Wow\", \"WoW\"]) == \"finNNalLLly.WoW\")\nassert(Strongest_Extension(class_name:\
    \ \"_\", extensions: [\"Bb\", \"91245\"]) == \"_.Bb\")\nassert(Strongest_Extension(class_name:\
    \ \"Sp\", extensions: [\"671235\", \"Bb\"]) == \"Sp.671235\")"
  status: Exception
  stderr: 'tmpuhmbxdp4/tmpuhmbxdp4.swift:35: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002abeef348c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002abeef03fb6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002abeef03f988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002abeef03e7b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpuhmbxdp4                        0x0000559ee0d614fd <unavailable> + 5373

    5    libc.so.6                          0x00002abeef534460 __libc_start_main +
    245

    6    tmpuhmbxdp4                        0x0000559ee0d61089 <unavailable> + 4233

    '
  stdout: ''
  timestamp: 1660009431
- exit_code: -4
  program: "\n/// You will be given the name of a class (a string) and an array of\
    \ extensions.\n/// The extensions are to be used to load additional classes to\
    \ the class. The\n/// strength of the extension is as follows: Let CAP be the\
    \ number of the uppercase\n/// letters in the extension's name, and let SM be\
    \ the number of lowercase letters \n/// in the extension's name, the strength\
    \ is given by the fraction CAP - SM. \n/// You should find the strongest extension\
    \ and return a string in this \n/// format: ClassName.StrongestExtensionName.\n\
    /// If there are two or more extensions with the same strength, you should\n///\
    \ choose the one that comes first in the array.\n/// For example, if you are given\
    \ \"Slices\" as the class and an array of the\n/// extensions: ['SErviNGSliCes',\
    \ 'Cheese', 'StuFfed'] then you should\n/// return 'Slices.SErviNGSliCes' since\
    \ 'SErviNGSliCes' is the strongest extension \n/// (its strength is -1).\n///\
    \ Example:\n/// >>> Strongest_Extension(class_name: \"my_class\", extensions:\
    \ [\"AA\", \"Be\", \"CC\"])\n/// \"my_class.AA\"\nfunc Strongest_Extension(class_name:\
    \ String, extensions: [String]) -> String {\n    var strongestExt = \"\"\n   \
    \ var strength = 0\n    for ext in extensions {\n        let countOfUpper = ext.filter{\
    \ $0.isUppercase }.count\n        let countOfLower = ext.filter{ $0.isLowercase\
    \ }.count\n        let currentStrength = countOfUpper - countOfLower\n       \
    \ if currentStrength > strength {\n            strength = currentStrength\n  \
    \          strongestExt = ext\n        }\n    }\n    return \"\\(class_name).\\\
    (strongestExt)\"\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool\
    \ {\n    if left.count != right.count {\n        return false\n    }\n    for\
    \ (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(Strongest_Extension(class_name:\
    \ \"Watashi\", extensions: [\"tEN\", \"niNE\", \"eIGHt8OKe\"]) == \"Watashi.eIGHt8OKe\"\
    )\nassert(Strongest_Extension(class_name: \"Boku123\", extensions: [\"nani\",\
    \ \"NazeDa\", \"YEs.WeCaNe\", \"32145tggg\"]) == \"Boku123.YEs.WeCaNe\")\nassert(Strongest_Extension(class_name:\
    \ \"__YESIMHERE\", extensions: [\"t\", \"eMptY\", \"nothing\", \"zeR00\", \"NuLl__\"\
    , \"123NoooneB321\"]) == \"__YESIMHERE.NuLl__\")\nassert(Strongest_Extension(class_name:\
    \ \"K\", extensions: [\"Ta\", \"TAR\", \"t234An\", \"cosSo\"]) == \"K.TAR\")\n\
    assert(Strongest_Extension(class_name: \"__HAHA\", extensions: [\"Tab\", \"123\"\
    , \"781345\", \"-_-\"]) == \"__HAHA.123\")\nassert(Strongest_Extension(class_name:\
    \ \"YameRore\", extensions: [\"HhAas\", \"okIWILL123\", \"WorkOut\", \"Fails\"\
    , \"-_-\"]) == \"YameRore.okIWILL123\")\nassert(Strongest_Extension(class_name:\
    \ \"finNNalLLly\", extensions: [\"Die\", \"NowW\", \"Wow\", \"WoW\"]) == \"finNNalLLly.WoW\"\
    )\nassert(Strongest_Extension(class_name: \"_\", extensions: [\"Bb\", \"91245\"\
    ]) == \"_.Bb\")\nassert(Strongest_Extension(class_name: \"Sp\", extensions: [\"\
    671235\", \"Bb\"]) == \"Sp.671235\")"
  status: Exception
  stderr: 'tmpwa7sz54e/tmpwa7sz54e.swift:48: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b23afac4c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b23af7bbb6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b23af7bb988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b23af7ba7b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpwa7sz54e                        0x000055d9c5e00f4c <unavailable> + 8012

    5    libc.so.6                          0x00002b23afcb0460 __libc_start_main +
    245

    6    tmpwa7sz54e                        0x000055d9c5e00659 <unavailable> + 5721

    '
  stdout: ''
  timestamp: 1660009435
- exit_code: 1
  program: "\n/// You will be given the name of a class (a string) and an array of\
    \ extensions.\n/// The extensions are to be used to load additional classes to\
    \ the class. The\n/// strength of the extension is as follows: Let CAP be the\
    \ number of the uppercase\n/// letters in the extension's name, and let SM be\
    \ the number of lowercase letters \n/// in the extension's name, the strength\
    \ is given by the fraction CAP - SM. \n/// You should find the strongest extension\
    \ and return a string in this \n/// format: ClassName.StrongestExtensionName.\n\
    /// If there are two or more extensions with the same strength, you should\n///\
    \ choose the one that comes first in the array.\n/// For example, if you are given\
    \ \"Slices\" as the class and an array of the\n/// extensions: ['SErviNGSliCes',\
    \ 'Cheese', 'StuFfed'] then you should\n/// return 'Slices.SErviNGSliCes' since\
    \ 'SErviNGSliCes' is the strongest extension \n/// (its strength is -1).\n///\
    \ Example:\n/// >>> Strongest_Extension(class_name: \"my_class\", extensions:\
    \ [\"AA\", \"Be\", \"CC\"])\n/// \"my_class.AA\"\nfunc Strongest_Extension(class_name:\
    \ String, extensions: [String]) -> String {\n    var extension_strength = 0\n\
    \    var strongest_extension = \"\"\n    for extension in extensions {\n     \
    \   var num_capital = 0\n        var num_lowercase = 0\n        for char in extension\
    \ {\n            if char.isUppercase {\n                num_capital += 1\n   \
    \         } else {\n                num_lowercase += 1\n            }\n      \
    \  }\n        if num_capital - num_lowercase > extension_strength {\n        \
    \    extension_strength = num_capital - num_lowercase\n            strongest_extension\
    \ = extension\n        }\n    }\n    return \"\\(class_name).\\(strongest_extension)\"\
    \n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(Strongest_Extension(class_name: \"Watashi\", extensions:\
    \ [\"tEN\", \"niNE\", \"eIGHt8OKe\"]) == \"Watashi.eIGHt8OKe\")\nassert(Strongest_Extension(class_name:\
    \ \"Boku123\", extensions: [\"nani\", \"NazeDa\", \"YEs.WeCaNe\", \"32145tggg\"\
    ]) == \"Boku123.YEs.WeCaNe\")\nassert(Strongest_Extension(class_name: \"__YESIMHERE\"\
    , extensions: [\"t\", \"eMptY\", \"nothing\", \"zeR00\", \"NuLl__\", \"123NoooneB321\"\
    ]) == \"__YESIMHERE.NuLl__\")\nassert(Strongest_Extension(class_name: \"K\", extensions:\
    \ [\"Ta\", \"TAR\", \"t234An\", \"cosSo\"]) == \"K.TAR\")\nassert(Strongest_Extension(class_name:\
    \ \"__HAHA\", extensions: [\"Tab\", \"123\", \"781345\", \"-_-\"]) == \"__HAHA.123\"\
    )\nassert(Strongest_Extension(class_name: \"YameRore\", extensions: [\"HhAas\"\
    , \"okIWILL123\", \"WorkOut\", \"Fails\", \"-_-\"]) == \"YameRore.okIWILL123\"\
    )\nassert(Strongest_Extension(class_name: \"finNNalLLly\", extensions: [\"Die\"\
    , \"NowW\", \"Wow\", \"WoW\"]) == \"finNNalLLly.WoW\")\nassert(Strongest_Extension(class_name:\
    \ \"_\", extensions: [\"Bb\", \"91245\"]) == \"_.Bb\")\nassert(Strongest_Extension(class_name:\
    \ \"Sp\", extensions: [\"671235\", \"Bb\"]) == \"Sp.671235\")"
  status: SyntaxError
  stderr: "/tmp/tmpmlr1hk30.swift:21:9: error: expected pattern\n    for extension\
    \ in extensions {\n        ^\n/tmp/tmpmlr1hk30.swift:21:9: error: expected Sequence\
    \ expression for for-each loop\n    for extension in extensions {\n        ^\n\
    /tmp/tmpmlr1hk30.swift:21:9: error: expected '{' to start the body of for-each\
    \ loop\n    for extension in extensions {\n        ^\n/tmp/tmpmlr1hk30.swift:24:21:\
    \ error: expected Sequence expression for for-each loop\n        for char in extension\
    \ {\n                    ^\n/tmp/tmpmlr1hk30.swift:24:21: error: expected '{'\
    \ to start the body of for-each loop\n        for char in extension {\n      \
    \              ^\n/tmp/tmpmlr1hk30.swift:33:35: error: expected expression in\
    \ assignment\n            strongest_extension = extension\n                  \
    \                ^\n/tmp/tmpmlr1hk30.swift:34:9: error: expected type name in\
    \ extension declaration\n        }\n        ^\n/tmp/tmpmlr1hk30.swift:33:44: error:\
    \ expected '{' in extension\n            strongest_extension = extension\n   \
    \                                        ^\n/tmp/tmpmlr1hk30.swift:33:35: error:\
    \ declaration is only valid at file scope\n            strongest_extension = extension\n\
    \                                  ^\n"
  stdout: ''
  timestamp: 1660009435
