name: HumanEval_10_make_palindrome
language: swift
prompt: "\n/// Find the shortest palindrome that begins with a supplied string.\n\
  /// Algorithm idea is simple:\n/// - Find the longest postfix of supplied string\
  \ that is a palindrome.\n/// - Append to the end of the string reverse of a string\
  \ prefix that comes before the palindromic suffix.\n/// >>> make_palindrome(string:\
  \ \"\")\n/// \"\"\n/// >>> make_palindrome(string: \"cat\")\n/// \"catac\"\n///\
  \ >>> make_palindrome(string: \"cata\")\n/// \"catac\"\nfunc make_palindrome(string:\
  \ String) -> String {\n"
tests: "}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if\
  \ left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left,\
  \ right) {\n        if l != r {\n            return false\n        }\n    }\n  \
  \  return true\n}\n            \nassert(make_palindrome(string: \"\") == \"\")\n\
  assert(make_palindrome(string: \"x\") == \"x\")\nassert(make_palindrome(string:\
  \ \"xyz\") == \"xyzyx\")\nassert(make_palindrome(string: \"xyx\") == \"xyx\")\n\
  assert(make_palindrome(string: \"jerry\") == \"jerryrrej\")"
completions: ["  if string.count == 0 {\n    return \"\"\n  }\n  if is_palindrome(string:\
    \ string) {\n    return string\n  }\n  let reversedString = String(string.reversed())\n\
    \  let palindromeSuffix = string.commonPrefix(with: reversedString)\n  let prefixBeforePalindromeSuffix\
    \ = String(string.dropFirst(palindromeSuffix.count))\n  let reversedPrefixBeforePalindromeSuffix\
    \ = String(prefixBeforePalindromeSuffix.reversed())\n  return string + reversedPrefixBeforePalindromeSuffix",
  "    var mutableString = string\n    let palindromeSuffix = longest_palindrome_postfix(string:\
    \ string)\n    for character in string.prefix(string.count - palindromeSuffix.count).reversed()\
    \ {\n        mutableString.append(character)\n    }\n    return mutableString",
  "    guard !string.isEmpty else { return \"\" }\n    guard string.count > 1 else\
    \ { return string }\n    var postfix_palindrome = String(string.last!)\n    for\
    \ idx in (0..<string.count).reversed() {\n        if is_palindrome(string: String(string[string.index(string.startIndex,\
    \ offsetBy: idx)...])) {\n            postfix_palindrome = String(string[string.index(string.startIndex,\
    \ offsetBy: idx)...])\n            break\n        }\n    }\n    return string\
    \ + String(string[..<string.index(string.startIndex, offsetBy: string.count -\
    \ postfix_palindrome.count)].reversed())", "    if string.count <= 1 {\n     \
    \   return string\n    }\n    let suffix = longest_palindromic_suffix(string:\
    \ string)\n    let prefix = string.prefix(string.count - suffix.count)\n    return\
    \ string + prefix.reversed()", "    let string_length = string.count\n    let\
    \ suffix = String(string.reversed())\n    let length = get_longest_common_substring_length(string_a:\
    \ string, string_b: suffix)\n    return String(string + suffix.suffix(string_length\
    \ - length))", "    var rev_string = string.characters.reversed()\n    let string_count\
    \ = string.count\n    let string_characters = Array(string.characters)\n    let\
    \ rev_string_characters = Array(rev_string)\n    var lps = get_lps(string: string)\n\
    \    lps.insert(0, at: 0)\n    lps.append(0)\n    var prefix_length = 1\n    while\
    \ (prefix_length <= string_count && lps[prefix_length] < string_count - prefix_length)\
    \ {\n        prefix_length += 1\n    }\n    let prefix = Array(string_characters[0..<(string_count\
    \ - prefix_length + 1)])\n    let suffix = Array(rev_string_characters[0..<prefix_length])\n\
    \    let result = string + String(suffix.reversed())\n    return result", "  \
    \  let chars = string.map { $0 }\n    var result: [Character] = chars\n    let\
    \ end_index = chars.count - 1\n    var longest_palindrome_suffix = 0\n    for\
    \ index in (0...end_index).reversed() {\n        let start_index = chars.startIndex\n\
    \        if is_palindrome(string: String(chars[start_index...index])) {\n    \
    \        longest_palindrome_suffix = index\n            break\n        }\n   \
    \ }\n    let longest_palindrome_suffix_length = longest_palindrome_suffix + 1\n\
    \    let string_prefix = chars[chars.startIndex..<chars.startIndex.advanced(by:\
    \ longest_palindrome_suffix_length)]\n    result.append(contentsOf: string_prefix.reversed())\n\
    \    return String(result)", "  var lps = longest_postfix_palindrome(string: string)\n\
    \  if lps == string {\n    return string\n  }\n  let prefix = string.prefix(string.count\
    \ - lps.count)\n  return string + prefix.reversed()", "    if string.isEmpty {\n\
    \        return string\n    }\n    let suffix = longest_palindromic_suffix(string:\
    \ string)\n    let prefix = String(string.dropLast(suffix.count).reversed())\n\
    \    return string + prefix", "    var start = string.startIndex\n    var end\
    \ = string.endIndex\n    let suffix = longest_postfix_palindrome(string: string)\n\
    \    if suffix.isEmpty {\n        return String(string.reversed()) + string\n\
    \    }\n    if suffix.count < string.count {\n        end = string.index(end,\
    \ offsetBy: -suffix.count)\n    }\n    return String(string[start..<end].reversed())\
    \ + string", "    var suffix = string\n    while suffix.count > 0 && !is_palindrome(string:\
    \ suffix) {\n        suffix.removeFirst()\n    }\n    var prefix = string\n  \
    \  while prefix.count > 0 && !is_palindrome(string: prefix) {\n        prefix.removeLast()\n\
    \    }\n    return string + prefix.reversed()", "    let stringLength = string.count\n\
    \    guard stringLength > 0 else {\n        return \"\"\n    }\n    let characters\
    \ = Array(string)\n    for length in (1...stringLength).reversed() {\n       \
    \ let middle = length / 2\n        var firstHalf = String(characters[0..<middle])\n\
    \        var secondHalf = String(characters[(length-middle)..<length])\n     \
    \   if firstHalf == secondHalf {\n            let prefix = String(characters[middle..<stringLength])\n\
    \            let reversedPrefix = String(prefix.reversed())\n            return\
    \ string + reversedPrefix\n        }\n    }\n    return \"\"", "    guard string.isEmpty\
    \ == false else {\n        return string\n    }\n    // Find the longest palindromic\
    \ suffix in supplied string.\n    // There is always one!\n    let suffix = longest_palindromic_suffix(string:\
    \ string)\n    // Find the prefix that comes before the palindromic suffix.\n\
    \    // It should be reversed and then appended to the original string.\n    let\
    \ prefix = String(string.dropLast(suffix.count).reversed())\n    return string\
    \ + prefix", "    var longest_palindrome_suffix = \"\";\n    for suffix in suffixes(of:\
    \ string) {\n        if is_palindrome(string: suffix) {\n            longest_palindrome_suffix\
    \ = suffix;\n            break;\n        }\n    }\n    let non_palindrome_prefix\
    \ = String(string.dropLast(longest_palindrome_suffix.count));\n    return string\
    \ + String(non_palindrome_prefix.reversed());", "    if string.isEmpty {\n   \
    \     return string\n    }\n    if is_palindrome(string: string) {\n        return\
    \ string\n    }\n    let front = string.index(string.startIndex, offsetBy: 1)\n\
    \    let back = string.index(string.endIndex, offsetBy: -1)\n    let to_front\
    \ = string[front..<string.endIndex]\n    let to_back = string[string.startIndex..<back]\n\
    \    if is_palindrome(string: to_front) {\n        return \"\\(string)\\(String(to_back.reversed()))\"\
    \n    }\n    if is_palindrome(string: to_back) {\n        return \"\\(String(to_front.reversed()))\\\
    (string)\"\n    }\n    return \"\\(string)\\(String(to_front.reversed()))\"",
  "    if string.isEmpty {\n        return string\n    }\n    let reverse = string.reversed()\n\
    \    let s = string + \"#\" + reverse\n    let z = z_function(string: s)\n   \
    \ let i = z.count - 2 - z.last!\n    let prefix = String(string.prefix(i))\n \
    \   return string + prefix.reversed()", "    let characters = Array(string)\n\
    \    if characters.count <= 1 {\n        return string\n    }\n    var max_suffix_len\
    \ = 0\n    for i in 1 ..< characters.count {\n        if characters[0 ..< i] ==\
    \ characters[i ..< characters.count].reversed() {\n            max_suffix_len\
    \ = i\n        }\n    }\n    let prefix = characters[max_suffix_len ..< characters.count].reversed()\n\
    \    return String(characters) + String(prefix)", "    guard !string.isEmpty else\
    \ { return \"\" }\n    guard string.count > 1 else { return string }\n    guard\
    \ string.count > 2 else { return string + String(string.prefix(1).reversed())\
    \ }\n    \n    // Simple case if string is already a palindrome\n    if is_palindrome(string:\
    \ string) { return string }\n    \n    // Find longest postfix of string that\
    \ is a palindrome\n    // and append reverse of its prefix\n    for count in (1\
    \ ..< string.count).reversed() {\n        if is_palindrome(string: String(string.suffix(count)))\
    \ {\n            return string + String(string.prefix(string.count - count).reversed())\n\
    \        }\n    }\n    \n    // Default case: string can't be shortened\n    return\
    \ string", "    //\n    // The idea is to find the longest palindromic prefix\
    \ of the supplied string.\n    // Then we need to append to the end of the string\
    \ a reverse of the\n    // prefix that comes before the palindromic suffix.\n\
    \    //\n    let string = string.unicodeScalars.map { $0 }\n    //\n    // Find\
    \ the longest palindromic prefix of the string.\n    //\n    var longest_palindromic_prefix\
    \ = String(string.suffix(from: string.count / 2))\n    //\n    // If the length\
    \ of the string is odd, then the palindromic prefix may be located in the center.\n\
    \    //\n    if string.count % 2 == 1 {\n        longest_palindromic_prefix =\
    \ String(string.suffix(from: string.count / 2 + 1))\n    }\n    //\n    // Append\
    \ a reverse of a string prefix that comes before the palindromic suffix.\n   \
    \ //\n    return string.prefix(string.count / 2).reversed().reduce(String(string),\
    \ { (result, char) -> String in\n        return result + String(char)\n    })\
    \ + longest_palindromic_prefix", "    guard !string.isEmpty else { return \"\"\
    \ }\n    guard string.count > 1 else { return string }\n    let string = Array(string)\n\
    \    let longest_palindrome_suffix = string.suffix(string.count - 1).longest_palindrome_suffix()\n\
    \    let last_index = string.count - 1\n    let palindrome_prefix = String(string.prefix(last_index\
    \ - longest_palindrome_suffix))\n    return String(string) + String(palindrome_prefix.reversed())",
  "    let chars = Array(string)\n    let palindrome = longest_postfix_palindrome(string:\
    \ chars)\n    let prefix = chars[..<chars.endIndex - palindrome.length]\n    let\
    \ reverse = String(prefix.reversed())\n    return string + reverse", "    guard\
    \ !string.isEmpty else { return \"\" }\n    let stringReversed = String(string.reversed())\n\
    \    let palindromeEnd = longest_common_substring(string1: string, string2: stringReversed)\n\
    \    let stringWithoutPalindromeEnd = String(string.dropLast(palindromeEnd.count))\n\
    \    return string + String(stringWithoutPalindromeEnd.reversed())", "    let\
    \ n = string.count\n    let str = String(string.reversed())\n    let s = str +\
    \ \"#\" + string\n    let size = s.count\n    var p = [Int](repeating: 0, count:\
    \ size)\n    var id = 0\n    var ans = 0\n    var ansId = 0\n    var ansSize =\
    \ 0\n    for i in 1..<size {\n        p[i] = max(0, min(p[2 * id - i], (ans +\
    \ ansId - i)))\n        while i + p[i] + 1 < size && i - p[i] - 1 >= 0 && s[s.index(s.startIndex,\
    \ offsetBy: i + p[i] + 1)] == s[s.index(s.startIndex, offsetBy: i - p[i] - 1)]\
    \ {\n            p[i] += 1\n        }\n        if i + p[i] > ans + ansId {\n \
    \           ans = p[i]\n            ansId = i\n        }\n        if i + p[i]\
    \ == size - 1 {\n            ansSize = p[i]\n            break\n        }\n  \
    \  }\n    return String(str.suffix(n - ansSize)) + string", "    guard string.count\
    \ > 0 else { return \"\" }\n    let array = Array(string)\n    let n = array.count\n\
    \    var longest_suffix_length = 0\n    let last_index = n - 1\n    for i in 0..<n\
    \ {\n        if array[i] == array[last_index - i] {\n            longest_suffix_length\
    \ += 1\n        } else {\n            break\n        }\n    }\n    if longest_suffix_length\
    \ == n {\n        return string\n    }\n    let suffix = String(array[last_index\
    \ - longest_suffix_length + 1..<n])\n    return string + String(suffix.reversed())",
  "  var suffix = reverse(string)\n  let stringLength = count(string)\n  let longestPalindrome\
    \ = find_longest_palindrome(string)\n  let longestPalindromeLength = count(longestPalindrome)\n\
    \  if longestPalindromeLength == stringLength {\n    return string\n  }\n  suffix.removeRange(Range(start:\
    \ advance(suffix.startIndex, longestPalindromeLength), end: suffix.endIndex))\n\
    \  return string + suffix", "    if string.isEmpty {\n        return string\n\
    \    }\n    let postfix = Array(string.suffix(\n        from: string.index(string.startIndex,\
    \ offsetBy: lps(string: string))))\n    let prefix = Array(string.prefix(string.count\
    \ - postfix.count))\n    let palindrome = String(prefix.reversed()) + string\n\
    \    return palindrome", "    let n = string.count\n    var lps: [Int] = [Int](repeating:\
    \ 0, count: n)\n    var i = 1\n    var j = 0\n    while i < n {\n        if string[string.index(string.startIndex,\
    \ offsetBy: i)] == string[string.index(string.startIndex, offsetBy: j)] {\n  \
    \          lps[i] = j + 1\n            i += 1\n            j += 1\n        } else\
    \ if j == 0 {\n            lps[i] = 0\n            i += 1\n        } else {\n\
    \            j = lps[j - 1]\n        }\n    }\n    return string + String(string.prefix(n\
    \ - lps[n - 1])[...]).reversed()", "    let stringLength = string.lengthOfBytes(using:\
    \ .utf8)\n    guard stringLength > 0 else {\n        return string\n    }\n  \
    \  let isPalindrome = { (string: String) -> Bool in\n        let stringLength\
    \ = string.lengthOfBytes(using: .utf8)\n        guard stringLength > 0 else {\n\
    \            return true\n        }\n        for i in 0..<stringLength/2 {\n \
    \           let firstCharacter = string[string.index(string.startIndex, offsetBy:\
    \ i)]\n            let lastCharacter = string[string.index(string.startIndex,\
    \ offsetBy: stringLength - i - 1)]\n            if firstCharacter != lastCharacter\
    \ {\n                return false\n            }\n        }\n        return true\n\
    \    }\n    let prefix = string.prefix(stringLength - 1)\n    let postfix = string.suffix(stringLength\
    \ - 1)\n    guard !isPalindrome(string: String(prefix)) else {\n        return\
    \ string\n    }\n    let postfixLength = postfix.lengthOfBytes(using: .utf8)\n\
    \    for i in (0..<postfixLength).reversed() {\n        let substring = String(postfix.suffix(i\
    \ + 1))\n        if isPalindrome(string: substring) {\n            let prefixToAppend\
    \ = String(prefix.prefix(prefix.lengthOfBytes(using: .utf8) - substring.lengthOfBytes(using:\
    \ .utf8)))\n            return String(prefixToAppend.reversed()) + string\n  \
    \      }\n    }\n    fatalError(\"Code never reach this point\")", "    let str\
    \ = string.utf8CString\n    let pal_suffix = make_palindrome_suffix(substring:\
    \ str)\n    let pal_prefix = make_palindrome_prefix(substring: pal_suffix)\n \
    \   let palindrome = String(string) + String(pal_prefix)\n    return palindrome",
  "    guard !string.isEmpty else { return \"\" }\n    let string_length = string.count\n\
    \    let str = Array(string)\n    var reversed_prefix = [Character]()\n    var\
    \ string_i = 0\n    var palindrome_length = 0\n    // This is the trickiest part.\n\
    \    // See it as a magic that search for the longest suffix of the string that\
    \ is a palindrome.\n    for i in 0..<string_length {\n        let right_bound\
    \ = string_length - i - 1\n        if str[i] == str[right_bound] {\n         \
    \   let current_length = i - string_i + 1\n            palindrome_length = max(palindrome_length,\
    \ current_length)\n        } else {\n            string_i = i + 1\n        }\n\
    \    }\n    // Here we reverse the prefix of the string that comes before the\
    \ palindromic suffix.\n    for i in 0..<(string_length - palindrome_length) {\n\
    \        reversed_prefix.append(str[i])\n    }\n    // Reverse the prefix and\
    \ append it to the end of the string.\n    reversed_prefix.reverse()\n    return\
    \ string + String(reversed_prefix)", "    guard string.isEmpty == false else {\n\
    \        return string\n    }\n    var longest = -1\n    var a = string.index(before:\
    \ string.endIndex)\n    var b = string.startIndex\n    while a > b {\n       \
    \ if string[a] == string[b] {\n            longest = string.distance(from: a,\
    \ to: b)\n            a = string.index(before: a)\n            b = string.index(after:\
    \ b)\n        } else {\n            a = string.index(before: a)\n            b\
    \ = string.startIndex\n        }\n    }\n    let suffix = string.suffix(from:\
    \ string.index(string.startIndex, offsetBy: string.count - longest))\n    let\
    \ prefix = string.prefix(upTo: string.index(string.startIndex, offsetBy: longest))\n\
    \    return \"\\(string)\\(String(prefix.reversed()))\"", "    if string.isEmpty\
    \ {\n        return string\n    }\n    let prefix = String(string.prefix(string.count\
    \ - 1))\n    let suffix = String(string.suffix(string.count - 1))\n    return\
    \ (suffix == prefix ? string : string + make_palindrome(string: prefix).reversed())",
  "    if string.isEmpty {\n        return string\n    }\n    let reversedString =\
    \ String(string.reversed())\n    let addedString = string + \"#\" + reversedString\n\
    \    let zArray = ZAlgorithm.make_z_array(text: addedString)\n    let palindromeSuffix\
    \ = String(addedString.dropFirst(zArray.last!))\n    let palindromePrefix = String(palindromeSuffix.reversed())\n\
    \    return palindromePrefix + string", "    if string.isEmpty {\n        return\
    \ string\n    }\n    let suffix_with_mid = string.suffix_with_mid()\n    let mid_string\
    \ = suffix_with_mid.mid\n    if let palindrome_suffix = suffix_with_mid.suffix\
    \ {\n        return String(string.prefix(upTo: palindrome_suffix.startIndex))\
    \ + mid_string + String(string.suffix(from: palindrome_suffix.endIndex))\n   \
    \ }\n    return string + mid_string + String(string.reversed())", '    return
    string + postfix_palindrome(string: string).reversed()', "    let text = string.characters\n\
    \    let n = text.count\n    let m = n - 1\n    var s = n\n    var l = n\n   \
    \ var t = n\n    var p = n\n    for i in 0..<m {\n        if i > l && text[i -\
    \ l - 1] == text[i] {\n            l += 2\n            s = i - l + 1\n       \
    \ } else {\n            t = i\n            p = s\n            while t - p < 0\
    \ || t - p > m || text[t - p] != text[t] {\n                if p < t {\n     \
    \               p += 1\n                } else {\n                    l = t -\
    \ p + 1\n                    s = p\n                    break\n              \
    \  }\n            }\n        }\n    }\n    let suffix = string[string.index(string.startIndex,\
    \ offsetBy: n - l - 1)..<string.endIndex]\n    return string + String(suffix.characters.reversed())",
  "    var prefix = string\n    var suffix = \"\"\n    let length = string.characters.count\n\
    \    if length == 0 {\n        return \"\"\n    }\n    var i = 0\n    while i\
    \ < length {\n        // Find the longest palindromic suffix.\n        if is_palindrome(string:\
    \ prefix) {\n            suffix = String(prefix.characters.reversed())\n     \
    \       break\n        }\n        prefix.remove(at: prefix.startIndex)\n     \
    \   i += 1\n    }\n    // Append suffix to the end of the string.\n    return\
    \ string + suffix", "    guard string.characters.count > 0 else {\n        return\
    \ string\n    }\n    // Find the longest postfix that is a palindrome\n    let\
    \ (lps, _) = longest_palindromic_substring(string: string)\n    // Reverse the\
    \ prefix\n    let prefix = String(string.characters.prefix(upTo: string.index(string.startIndex,\
    \ offsetBy: string.characters.count - lps.characters.count)))\n    let reversed_prefix\
    \ = String(prefix.characters.reversed())\n    return prefix + string + reversed_prefix",
  "    let n = string.characters.count\n    var i = 0\n    var j = n - 1\n    let\
    \ str = string.characters.map { String($0) }\n    while i < j {\n        if str[i]\
    \ != str[j] {\n            break\n        }\n        i += 1\n        j -= 1\n\
    \    }\n    if i >= j {\n        return string\n    }\n    let p = longest_palindrome_postfix(str:\
    \ str, start: i)\n    var s = string\n    for k in (0 ..< i).reversed() {\n  \
    \      s.append(str[k])\n    }\n    return s", "    let string = String(string.reversed())\n\
    \    for i in 0..<string.count {\n        if string.prefix(i).is_palindrome()\
    \ {\n            return string.prefix(i) + string\n        }\n    }\n    return\
    \ string", "    guard string.count > 0 else { return \"\" }\n    let s = Array(string)\n\
    \    var n = s.count\n    while n > 0 {\n        var matches = true\n        for\
    \ i in 0..<n {\n            if s[i] != s[s.count - n + i] {\n                matches\
    \ = false\n                break\n            }\n        }\n        if matches\
    \ {\n            break\n        }\n        n -= 1\n    }\n    let prefix = String(s[0..<s.count\
    \ - n])\n    let reversed_prefix = String(prefix.reversed())\n    return prefix\
    \ + reversed_prefix + String(s[s.count - n..<s.count])", "    if string.count\
    \ <= 1 {\n        return string\n    }\n    if let palindrome = longest_palindrome_postfix(string:\
    \ string) {\n        let prefix = String(string.prefix(string.count - palindrome.count))\n\
    \        return prefix + String(palindrome.reversed()) + palindrome\n    }\n \
    \   return \"\"", "    let suffix = longest_palindromic_suffix(string: string)\n\
    \    let reversed_prefix = string.prefix(string.count - suffix.count).reversed()\n\
    \    return string + String(reversed_prefix)", "    if string.count <= 1 {\n \
    \       return string\n    }\n    let (longest_palindrome_suffix, _) = longest_palindrome_at_suffix(string:\
    \ string)\n    let prefix = String(string.prefix(string.count - longest_palindrome_suffix.count))\n\
    \    return string + String(prefix.reversed())", "    if string.isEmpty {\n  \
    \      return string\n    }\n    let suffix_count = suffix_that_is_palindrome(string:\
    \ string)\n    let prefix = string.prefix(string.count - suffix_count)\n    return\
    \ \"\\(string)\\(prefix.reversed())\"", '  return string + String(string.prefix(string.count
    - palindrome_suffix(string: string).count).reversed())', "  // Base case\n  if\
    \ string.isEmpty {\n    return string\n  }\n  var string = string\n  var longest_palindrome_prefix\
    \ = String(string.dropLast(1))\n  // Find the longest palindrome suffix.\n  while\
    \ longest_palindrome_prefix.count > 0 {\n    let longest_palindrome_suffix = String(longest_palindrome_prefix.reversed())\n\
    \    if string.hasSuffix(longest_palindrome_suffix) {\n      // Append the reverse\
    \ of prefix from the beginning of the string to the beginning of the suffix.\n\
    \      string += String(string.prefix(longest_palindrome_prefix.count).reversed())\n\
    \      return string\n    }\n    longest_palindrome_prefix = String(longest_palindrome_prefix.dropLast(1))\n\
    \  }\n  // If we're here, it means there's no palindrome suffix.\n  string +=\
    \ String(string.reversed())\n  return string", "    let str = Array(string)\n\
    \    let n = str.count\n    if n == 0 {\n        return \"\"\n    }\n    var t\
    \ = Array(repeating: 0, count: n)\n    let (p, m) = find_longest_palindrome_postfix(string:\
    \ str, table: &t)\n    var pal = str[p ..< m]\n    let left = str[0 ..< p]\n \
    \   for i in (0 ..< left.count).reversed() {\n        pal.append(left[i])\n  \
    \  }\n    return String(pal)", "    let reversed = string.reversed()\n    let\
    \ z = z_algorithm(string: string + \".\" + reversed)\n    let split = z.split(separator:\
    \ \".\")\n    let suffix = String(split[0])\n    let prefix = String(split[1])\n\
    \    let to_append = prefix.reversed()\n    return string + to_append", '    return
    string + String(string.dropLast(longest_palindrome_suffix(string: string).count).reversed())',
  "    let array = Array(string)\n    var substring = String(array.suffix(from: array.count\
    \ / 2))\n    while (!is_palindrome(string: substring)) {\n        if (substring.count\
    \ == 0) {\n            return string\n        }\n        substring = String(substring.dropLast())\n\
    \    }\n    let prefix = String(array.prefix(array.count / 2))\n    return string\
    \ + String(prefix.reversed())", "    if string.isEmpty {\n        return string\n\
    \    }\n    let reversed = String(string.characters.reversed())\n    let postfix\
    \ = string.has_suffix(reversed) ? String(string.characters.dropLast(string.characters.count/2))\
    \ : string\n    let prefix = String(postfix.characters.reversed())\n    return\
    \ string + prefix", "    if string.isEmpty {\n        return string\n    }\n \
    \   var palindrome = string\n    let string_reversed = String(string.reversed())\n\
    \    let postfix_palindrome = find_longest_common_postfix(string1: string_reversed,\
    \ string2: string)\n    palindrome += String(string.prefix(string.count - postfix_palindrome.count).reversed())\n\
    \    return palindrome", "    // Find the longest palindromic substring that is\
    \ also a suffix of the input string.\n    let reversed = string.reversed()\n \
    \   let longest_palindromic_substring = string.longest_common_substring(with:\
    \ reversed)\n    let prefix = String(string.dropLast(longest_palindromic_substring.count))\n\
    \    let reversed_prefix = prefix.reversed()\n    return string + reversed_prefix",
  "    // If the string is already a palindrome, we are done.\n    if is_palindrome(string:\
    \ string) {\n        return string\n    }\n    // Otherwise we find the longest\
    \ suffix that is a palindrome.\n    for l in stride(from: string.count - 1, through:\
    \ 0, by: -1) {\n        let suffix = String(string[string.index(string.endIndex,\
    \ offsetBy: -l)...])\n        if is_palindrome(string: suffix) {\n           \
    \ let prefix = String(string[..<string.index(string.endIndex, offsetBy: -l)])\n\
    \            return prefix + String(suffix.reversed()) + suffix\n        }\n \
    \   }\n    // If no suffix is a palindrome, then string is empty.\n    return\
    \ \"\"", "    let chars = Array(string)\n    let reversed_chars = chars.reversed()\n\
    \    var longest_suffix_index = 0\n    for suffix_length in (0...string.count).reversed()\
    \ {\n        let prefix_length = chars.count - suffix_length\n        let prefix\
    \ = chars[0..<prefix_length]\n        let suffix = reversed_chars[0..<suffix_length]\n\
    \        if prefix == suffix {\n            longest_suffix_index = suffix_length\n\
    \            break\n        }\n    }\n    return string + reversed_chars[longest_suffix_index..<reversed_chars.count].joined()",
  "    let reversed = string.reversed()\n    for i in 0..<string.count {\n       \
    \ let j = reversed.index(reversed.startIndex, offsetBy: i)\n        let substring\
    \ = reversed[..<j]\n        if string.hasSuffix(substring) {\n            return\
    \ String(string + substring.reversed())\n        }\n    }\n    return string",
  "\tvar postfix = string\n\tvar reverse = String(string.characters.reversed())\n\t\
    for _ in 0..<string.characters.count {\n\t\tif postfix == reverse {\n\t\t\tbreak\n\
    \t\t}\n\t\tpostfix.remove(at: postfix.startIndex)\n\t\treverse.remove(at: reverse.endIndex.predecessor())\n\
    \t}\n\treturn string + String(string.characters.prefix(string.characters.count\
    \ - postfix.characters.count).reversed())", "\tguard string.count > 0 else { return\
    \ \"\" }\n\t\n\tlet string = Array(string)\n\tvar longest_palindrome_suffix =\
    \ longest_palindrome_suffix_kmp(string: string)\n\t\n\tlet string_prefix = string[0..<string.count\
    \ - longest_palindrome_suffix.count]\n\tlet string_prefix_reverse = string_prefix.reversed()\n\
    \t\n\treturn String(string + string_prefix_reverse)", "    let string_length =\
    \ string.count\n    if string_length == 0 {\n        return \"\"\n    }\n    var\
    \ string_start = string.startIndex\n    var string_end = string.index(before:\
    \ string.endIndex)\n    var palindrome_end = string_end\n    while string_start\
    \ < string_end {\n        if string[string_start] == string[string_end] {\n  \
    \          string_start = string.index(after: string_start)\n            string_end\
    \ = string.index(before: string_end)\n            palindrome_end = string_end\n\
    \        } else {\n            string_start = string.startIndex\n            string_end\
    \ = string.index(before: palindrome_end)\n            palindrome_end = string_end\n\
    \        }\n    }\n    let pre: String = String(string[string.startIndex...palindrome_end])\n\
    \    let post: String = String(pre.reversed())\n    return pre + post", "    guard\
    \ string.count > 0 else { return \"\" }\n    let str_length = string.count\n \
    \   let palindrome_length = str_length + longest_palindrome_length(string: string)\n\
    \    var output = String(string.prefix(palindrome_length))\n    for char in string.dropFirst(palindrome_length).reversed()\
    \ {\n        output.append(char)\n    }\n    return output", "    let (suffix,\
    \ remainder) = LongestPalindromicSubstring.longestPalindromicSubstring(text: string)\n\
    \    return string + String(remainder.characters.reversed())", "    let length\
    \ = string.count\n    if length == 0 {\n        return \"\"\n    }\n    let str\
    \ = string.utf8\n    var j = 0\n    var end = length\n    while j < length {\n\
    \        if str[length - 1 - j] == str[j] {\n            j += 1\n        } else\
    \ {\n            end = length - j\n            break\n        }\n    }\n    var\
    \ result = String(string[...string.index(string.startIndex, offsetBy: end - 1)])\n\
    \    for i in (0 ..< end).reversed() {\n        let index = string.index(string.startIndex,\
    \ offsetBy: i)\n        result.append(string[index])\n    }\n    return result",
  "    let str = string.characters.map { $0 }\n    let n = str.count\n    var rev\
    \ = [Character](str.reversed())\n    var z = z_function(str: rev)\n    for i in\
    \ 0..<n {\n        if z[i] == n - i {\n            return string + String(rev[i..<n])\n\
    \        }\n    }\n    return string + String(rev[1..<n])", "    let index = find_max_postfix_palindrome(string:\
    \ string)\n    let prefix = String(string.prefix(upTo: index))\n    let suffix\
    \ = String(string.suffix(from: index))\n    return suffix + prefix.reversed()",
  "    // LPS of string\n    let lps_ = lps(string: string)\n    let reversed = String(string.dropLast(lps_.count).reversed())\n\
    \    return string + reversed", "    let stringLength = string.characters.count\n\
    \    if stringLength == 0 {\n        return \"\"\n    }\n    var suffix = String(string.characters.reversed())\n\
    \    let index = string.range(of: suffix, options: .backwards)?.lowerBound\n \
    \   if index == string.startIndex {\n        return string\n    }\n    let prefix\
    \ = string.substring(to: index!)\n    suffix = prefix.characters.reversed().map\
    \ { String($0) }.joined()\n    return string + suffix", "    guard !string.isEmpty\
    \ else { return \"\" }\n    guard !string.isPalindrome else { return string }\n\
    \    let string = String(string.reversed())\n    let prefix = string.find_longest_prefix_that_is_palindrome()\n\
    \    let suffix = string.find_longest_suffix_that_is_palindrome()\n    return\
    \ prefix + suffix + string.suffix(from: prefix.endIndex)", "    let string = String(string.reversed())\n\
    \    let (last_index, length) = longest_palindrome_suffix(string: string)\n  \
    \  return string.substring(from: last_index) + string", "    guard string.characters.count\
    \ > 0 else {\n        return string\n    }\n    var longest = 0\n    let buffer\
    \ = Array(string.characters)\n    for i in 0 ..< buffer.count {\n        var j\
    \ = 0\n        while i - j >= 0 && i + j < buffer.count && buffer[i - j] == buffer[i\
    \ + j] {\n            j += 1\n        }\n        if j > longest {\n          \
    \  longest = j\n        }\n    }\n    var reversed_prefix = Array(string.characters.prefix(buffer.count\
    \ - longest))\n    reversed_prefix.reverse()\n    return string + String(reversed_prefix)",
  "    if string.count == 0 {\n        return \"\"\n    }\n    if is_palindrome(string:\
    \ string) {\n        return string\n    }\n    let suffix = make_palindrome_suffix(string:\
    \ string)\n    let prefix = String(string.prefix(string.count - suffix.count).reversed())\n\
    \    return string + prefix", "    var string = string\n    if string.isEmpty\
    \ {\n        return string\n    }\n    if let longest_palindrome_suffix = longest_palindrome_suffix(string:\
    \ string) {\n        let reverse_prefix = string.prefix(string.count - longest_palindrome_suffix.count).reversed()\n\
    \        string.append(contentsOf: reverse_prefix)\n    }\n    return string",
  "  if (string.characters.count <= 1) {\n    return string\n  }\n  let index = longest_palindromic_suffix(string:\
    \ string)\n  if (index == string.characters.count) {\n    return string\n  }\n\
    \  return String(string.characters.suffix(from: string.index(string.startIndex,\
    \ offsetBy: index))) + make_palindrome(string: String(string.characters.prefix(index)))\
    \ + String(string.characters.suffix(from: string.index(string.startIndex, offsetBy:\
    \ index)))", "    guard !string.isEmpty else { return \"\" }\n    let str = string\
    \ + \"*\" + string.reversed()\n    var z: [Int] = [Int](repeating: 0, count: str.count)\n\
    \    z[0] = str.count\n    var l = 0\n    var r = 0\n    for i in 1..<str.count\
    \ {\n        if i > r {\n            l = r = i\n            while l > 0 && r <\
    \ str.count && str[str.index(str.startIndex, offsetBy: l)] == str[str.index(str.startIndex,\
    \ offsetBy: r)] {\n                l -= 1\n                r += 1\n          \
    \  }\n            z[i] = r - l\n            r -= 1\n        } else {\n       \
    \     let k = i - l\n            if z[k] < r - i + 1 {\n                z[i] =\
    \ z[k]\n            } else {\n                l = i\n                while r <\
    \ str.count && str[str.index(str.startIndex, offsetBy: r)] == str[str.index(str.startIndex,\
    \ offsetBy: l)] {\n                    r += 1\n                    l += 1\n  \
    \              }\n                z[i] = r - l\n                r -= 1\n     \
    \       }\n        }\n    }\n    // Check where we found a palindrome that starts\
    \ with s and ends with '*'. That would be the longest palindrome that starts with\
    \ s.\n    let max_z = z.enumerated().sorted { (a, b) -> Bool in\n        if a.element\
    \ == b.element {\n            return a.offset < b.offset\n        }\n        return\
    \ a.element > b.element\n    }\n    let left_prefix = str[str.index(str.startIndex,\
    \ offsetBy: max_z[0].offset + 1)..<str.index(str.startIndex, offsetBy: str.count\
    \ - max_z[0].element)]\n    let result = string + left_prefix.reversed()\n   \
    \ return result", "    let longest_palindrome_suffix = string.longest_palindrome_suffix()\n\
    \    let reverse_string_prefix = String(string.prefix(string.count - longest_palindrome_suffix.count).reversed())\n\
    \    return string + reverse_string_prefix", "    var shifted = Array(string)\n\
    \    if shifted.count < 2 {\n        return string\n    }\n    shifted.insert(contentsOf:\
    \ shifted.reversed(), at: shifted.count)\n    let s = String(shifted)\n    var\
    \ lps = Array(repeating: 0, count: shifted.count)\n    for i in 1..<shifted.count\
    \ {\n        var j = lps[i - 1]\n        while j > 0 && shifted[i] != shifted[j]\
    \ {\n            j = lps[j - 1]\n        }\n        if shifted[i] == shifted[j]\
    \ {\n            j += 1\n        }\n        lps[i] = j\n    }\n    return s.prefix(string.count\
    \ + (string.count - lps.last!))", "    let l = string.count\n    let prefix =\
    \ find_longest_palindrome_postfix(string: string)\n    if prefix == l {\n    \
    \    return string\n    }\n    let a = string.index(string.startIndex, offsetBy:\
    \ 0)\n    let b = string.index(string.startIndex, offsetBy: l - prefix)\n    let\
    \ prefix_string = String(string[a..<b].reversed())\n    return string + prefix_string",
  "    var string = string\n    let palindrome = longest_palindrome_suffix(string:\
    \ string)\n    string.append(palindrome.characters.reversed())\n    return string",
  "    if string.isEmpty {\n        return string\n    }\n    let start_index = string.startIndex\n\
    \    let end_index = string.index(before: string.endIndex)\n    let range = start_index..<end_index\n\
    \    let prefix = string[range]\n    let long_palindrome = get_longest_palindrome(string:\
    \ prefix)\n    if long_palindrome.count == prefix.count {\n        return string\
    \ + String(string.reversed())\n    }\n    let suffix = String(prefix.suffix(prefix.count\
    \ - long_palindrome.count))\n    return suffix + string + String(suffix.reversed())",
  "    let count = string.count\n    let nsstring = string as NSString\n    var index\
    \ = count\n    while index > 0 {\n        let prefix = nsstring.substring(to:\
    \ index)\n        if prefix == String(prefix.reversed()) {\n            return\
    \ string + String(nsstring.substring(to: count - index).reversed())\n        }\n\
    \        index -= 1\n    }\n    return string", "    guard string.count > 0 else\
    \ { return \"\" }\n    let extended_string = string + \".\" + string.reversed()\n\
    \    let z_array = compute_z_array(extended_string: extended_string)\n    let\
    \ max_index = z_array.firstIndex(of: z_array.max()!)!\n    let prefix = string[..<string.index(string.startIndex,\
    \ offsetBy: max_index)]\n    return string + prefix.reversed()", "  // TODO: Determine\
    \ if there is a better way to convert to NSString\n  // TODO: Remove this intermediate\
    \ NSString conversion\n  let nsstring = string as NSString\n  var longest_palindrome_length\
    \ = 0\n  for position in 1...string.count {\n    // If the current position is\
    \ a palindrome, and it is the longest palindrome found so far,\n    // remember\
    \ it.\n    if is_palindrome(string: nsstring.substring(to: position)) {\n    \
    \  longest_palindrome_length = position\n    }\n  }\n  // If the supplied string\
    \ is a palindrome, no need to do anything.\n  if longest_palindrome_length ==\
    \ string.count {\n    return string\n  } else {\n    let remaining_part = nsstring.substring(from:\
    \ longest_palindrome_length)\n    let remaining_part_reversed = String(remaining_part.reversed())\n\
    \    return remaining_part_reversed + string\n  }", "    let reversed_string =\
    \ String(string.reversed())\n    let reversed_string_length = reversed_string.count\n\
    \    var postfix_length = string.commonPrefix(with: reversed_string).count\n \
    \   while postfix_length < reversed_string_length {\n        postfix_length +=\
    \ 1\n        let postfix = String(reversed_string.prefix(postfix_length))\n  \
    \      if string.hasSuffix(postfix) {\n            break\n        }\n    }\n \
    \   return string + String(reversed_string.dropFirst(postfix_length))", "    guard\
    \ string.count > 0 else { return \"\" }\n    let half_index = string.count / 2\n\
    \    let prefix = string.prefix(upTo: string.index(string.startIndex, offsetBy:\
    \ half_index))\n    let mirrored_prefix = prefix.reversed()\n    let postfix =\
    \ string.suffix(from: string.index(string.startIndex, offsetBy: half_index))\n\
    \    let result = prefix + postfix + mirrored_prefix\n    return String(result)",
  "  let n = string.count\n  let s = Array(string)\n  let rev_s = string.reversed()\n\
    \  for i in 0..<n {\n    if s[i..<n] == rev_s[0..<n-i] {\n      return string\
    \ + String(rev_s[n-i..<n])\n    }\n  }\n  return string", "    let reversed_string\
    \ = String(string.reversed())\n    let postfix = reversed_string.longest_common_suffix(string)\n\
    \    let prefix = String(string.dropLast(postfix.count))\n    return string +\
    \ String(prefix.reversed())", "    // find the longest postfix that is a palindrome\n\
    \    var postfix_palindrome_length = 0\n    var postfix_palindrome_location =\
    \ 0\n    for i in 0..<string.count {\n        if let length = longest_palindrome_length(string:\
    \ string, start: i) {\n            if length > postfix_palindrome_length {\n \
    \               postfix_palindrome_length = length\n                postfix_palindrome_location\
    \ = i\n            }\n        }\n    }\n    // append reverse of the string prefix\n\
    \    let prefix_end = postfix_palindrome_location - postfix_palindrome_length\n\
    \    let reversed_prefix = String(string[..<string.index(string.startIndex, offsetBy:\
    \ prefix_end)].reversed())\n    return string + reversed_prefix", "    let string\
    \ = string.characters.map { $0 }\n    if string.count <= 1 {\n        return String(string)\n\
    \    }\n    // Find the longest palindromic suffix.\n    var (max_suffix_length,\
    \ max_suffix_end) = longest_palindromic_suffix(string)\n    // Find the longest\
    \ palindromic prefix.\n    let (max_prefix_length, _) = longest_palindromic_prefix(string)\n\
    \    // The string is already a palindrome.\n    if max_suffix_length + max_prefix_length\
    \ == string.count {\n        return String(string)\n    }\n    // String prefix\
    \ is already a palindrome.\n    if max_prefix_length == max_suffix_length {\n\
    \        return String(string + string.reverse())\n    }\n    var new_string =\
    \ string\n    // Reverse the prefix and append it to the end of the string.\n\
    \    new_string.appendContentsOf(string[0..<(max_suffix_end - max_suffix_length)].reverse())\n\
    \    return String(new_string)", "    var end_index = string.count\n    while\
    \ end_index > 0 {\n        if is_palindrome(string: string[0..<end_index]) {\n\
    \            break\n        }\n        end_index -= 1\n    }\n    return string\
    \ + String(string[0..<(string.count - end_index)].reversed())", "\tlet new_string\
    \ = string + String(string.reversed())\n\tlet string_length = new_string.count\n\
    \tlet Z = Z_function(string: new_string)\n\treturn new_string[new_string.index(new_string.startIndex,\
    \ offsetBy: string_length - Z[string_length - 1])...]", "    var longest_palindrome_suffix\
    \ = longest_palindrome_suffix_array(string: string)\n    var palindrome_string\
    \ = string\n    for i in (0..<string.count).reversed() {\n        if (longest_palindrome_suffix[i]\
    \ > 0) {\n            let reversed_prefix = string.prefix(i)\n            let\
    \ reversed_prefix_string = String(reversed_prefix.reversed())\n            palindrome_string\
    \ += reversed_prefix_string\n            break\n        }\n    }\n    return palindrome_string",
  "    if string.isEmpty {\n        return string\n    }\n    var string = string\n\
    \    let postfix = longest_postfix_palindrome(string: string)\n    string.removeSubrange(string.startIndex..<string.index(string.endIndex,\
    \ offsetBy: -postfix.count))\n    string.append(String(string.prefix(string.count\
    \ - postfix.count).reversed()))\n    return string", "    guard string.count >\
    \ 0 else { return \"\" }\n    let prefix = String(string.prefix(upTo: string.index(before:\
    \ string.endIndex)))\n    let postfix = String(string.suffix(from: string.index(after:\
    \ string.startIndex)))\n    let is_palindrome = is_palindrome_ref(str: postfix)\n\
    \    if is_palindrome {\n        return string + String(string.reversed())\n \
    \   } else {\n        return make_palindrome(string: prefix) + postfix + String(postfix.reversed())\n\
    \    }", "    let chars = Array(string)\n    var prefix: String = \"\"\n    var\
    \ postfix: String = \"\"\n    let reversed_prefix = String(chars.reversed())\n\
    \    for (i, _) in chars.enumerated() {\n        let pre = String(chars[0...i])\n\
    \        let post = String(chars[i+1..<chars.count])\n        if palindrome(string:\
    \ pre) {\n            prefix = pre\n            postfix = post\n            break\n\
    \        }\n    }\n    return prefix + postfix + reversed_prefix", "    let reversed\
    \ = String(string.reversed())\n    let longest_postfix = longest_common_substring(string1:\
    \ string, string2: reversed)\n    let non_palindromic_prefix = string.substring(from:\
    \ string.index(string.startIndex, offsetBy: longest_postfix.count))\n    return\
    \ string + String(non_palindromic_prefix.reversed())", "    // Build the trie\n\
    \    let trie = Trie(from: string)\n    let prefix = trie.longest_palindromic_suffix()\n\
    \    let suffix = String(prefix.reversed())\n    return string + suffix", "  \
    \  let count = string.characters.count\n    if count == 0 {\n        return \"\
    \"\n    }\n    var len = count\n    while len > 0 {\n        if is_palindrome(string:\
    \ string, start: 0, end: len) {\n            break\n        }\n        len -=\
    \ 1\n    }\n    var res = string\n    for idx in (1..<(count - len)).reversed()\
    \ {\n        res.append(string[string.index(string.startIndex, offsetBy: idx)])\n\
    \    }\n    return res", "  let src = Array(string)\n  let dst = Array(string.reversed())\n\
    \  let N = src.count\n  let L = lps(text: src)\n  if L[N - 1] != N {\n    let\
    \ diff = N - L[N - 1]\n    return String(src) + String(dst[0..<diff])\n  }\n \
    \ return String(src)", "    let s = Array(string)\n    let n = s.count\n    let\
    \ z = z_function(string: string)\n    let z_rev = z_function(string: String(s.reversed()))\n\
    \    let prefix = String(s[0 ..< (n - z[n])].reversed())\n    let suffix = String(s[(n\
    \ - z_rev[n]) ..< n])\n    return string + prefix + suffix", "    var palindrome\
    \ = string\n    let count = string.count\n    guard count > 0 else { return \"\
    \" }\n    let chars = Array(string)\n    for _ in 1..<count {\n        let left\
    \ = Array(chars[0..<count-1])\n        let right = left.reversed()\n        let\
    \ reversed = String(right)\n        let postfix = chars[count-1] + reversed\n\
    \        if postfix == String(postfix.reversed()) {\n            palindrome =\
    \ postfix\n            break\n        }\n    }\n    return palindrome", "    var\
    \ string = string\n    let postfix = longest_postfix_palindrome(string: string)\n\
    \    var prefix = string.dropLast(postfix.count)\n    prefix = prefix.reversed()\n\
    \    string.append(prefix)\n    return string", "    let chars = Array(string)\n\
    \    let n = chars.count\n    var longest_palindrome = Array(repeating: 0, count:\
    \ n)\n    var left = 0\n    var right = 0\n    for i in 0..<n {\n        var offset\
    \ = 1\n        while i - offset >= 0 && i + offset < n && chars[i - offset] ==\
    \ chars[i + offset] {\n            offset += 1\n        }\n        longest_palindrome[i]\
    \ = offset\n    }\n    for i in 1..<n - 1 {\n        if i > right {\n        \
    \    left = right = i\n        }\n        var min_mirror = 2 * left - right\n\
    \        if i < right {\n            longest_palindrome[i] = min(longest_palindrome[min_mirror],\
    \ right - i)\n        }\n        var offset = 1\n        while i - offset >= 0\
    \ && i + offset < n && i + offset < right && i - offset > left {\n           \
    \ offset += 1\n        }\n        longest_palindrome[i] = offset\n        if i\
    \ + longest_palindrome[i] > right {\n            left = i\n            right =\
    \ i + longest_palindrome[i]\n        }\n    }\n    let mid = right / 2\n    return\
    \ string + String(chars[0..<mid].reversed())", "    var result = string\n    let\
    \ length = string.count\n    let reversed = String(string.reversed())\n    for\
    \ i in 0..<length {\n        let postfix = String(string.suffix(length - i))\n\
    \        let prefix = String(string.prefix(i))\n        if postfix == reversed.suffix(length\
    \ - i) {\n            result.append(String(prefix.reversed()))\n            break\n\
    \        }\n    }\n    return result", "    let string = Array(string)\n    guard\
    \ string.count > 1 else { return string.count == 0 ? \"\" : String(string[0])\
    \ }\n    // reverse the string\n    let reversed_string = string.reversed()\n\
    \    // find the longest palindromic suffix\n    let lps = longest_palindromic_suffix(string:\
    \ string)\n    // reverse suffix and append to the end of original string\n  \
    \  return string + reversed_string[reversed_string.index(reversed_string.startIndex,\
    \ offsetBy: reversed_string.count - lps.count)..<reversed_string.endIndex]", " \
    \   let reversed = String(string.reversed())\n    let combined = string + reversed\n\
    \    let z_array = z_algorithm(string: combined)\n    let z_length = z_array.last!\n\
    \    let prefix_length = string.count - z_length\n    let prefix = string.prefix(prefix_length)\n\
    \    let reversed_prefix = String(prefix.reversed())\n    return string + reversed_prefix",
  "    let characters = Array(string)\n    var longest_suffix_palindrome = \"\"\n\
    \    for i in 0..<characters.count {\n        let pre_palindrome = characters[0..<i]\n\
    \        let palindrome = characters[i..<characters.count]\n        if is_palindrome(string:\
    \ palindrome) && palindrome.count > longest_suffix_palindrome.count {\n      \
    \      longest_suffix_palindrome = palindrome\n        }\n    }\n    let left\
    \ = characters[0..<characters.count - longest_suffix_palindrome.count]\n    let\
    \ right = characters[characters.count - longest_suffix_palindrome.count..<characters.count]\n\
    \    return left + right + reverse(string: left)", "    let prefix_reversed =\
    \ String(string.characters.reversed())\n    let candidate = string + prefix_reversed\n\
    \    let x = longest_palindromic_suffix(string: candidate)\n    return String(candidate.characters.dropLast(candidate.characters.count\
    \ - x))", "    let string_length = string.count\n    let buffer_length = 2 * string_length\
    \ + 1\n    let string_chars = [Character](string)\n    var buffer = [Character](repeating:\
    \ \"#\", count: buffer_length)\n    for i in 0..<string_length {\n        buffer[2\
    \ * i + 1] = string_chars[i]\n    }\n    var right = 0\n    var left = 0\n   \
    \ var center = 0\n    var end = 1\n    var max_palindrome_length = 0\n    var\
    \ max_palindrome_center = 0\n    while right < buffer_length {\n        var current_length\
    \ = right > left ? min(right - left, p[left * 2 - right]) : 0\n        while right\
    \ + current_length < buffer_length && left - current_length >= 0 && buffer[right\
    \ + current_length] == buffer[left - current_length] {\n            current_length\
    \ += 1\n        }\n        p[right] = current_length\n        if right + current_length\
    \ > end {\n            center = right\n            end = right + current_length\n\
    \        }\n        if p[right] > max_palindrome_length {\n            max_palindrome_length\
    \ = p[right]\n            max_palindrome_center = right\n        }\n        if\
    \ right < left + p[left] {\n            p[right] = p[left]\n        }\n      \
    \  right += 1\n        left = right\n    }\n    var left_prefix = \"\"\n    var\
    \ right_prefix = \"\"\n    if max_palindrome_center % 2 == 0 {\n        right_prefix\
    \ = String(string_chars[(max_palindrome_center / 2) - max_palindrome_length /\
    \ 2..<(max_palindrome_center / 2)])\n        left_prefix = String(right_prefix.reversed())\n\
    \    } else {\n        right_prefix = String(string_chars[(max_palindrome_center\
    \ / 2) - max_palindrome_length / 2..<(max_palindrome_center / 2) + max_palindrome_length\
    \ / 2])\n        left_prefix = String(right_prefix", "    // base case: string\
    \ is empty or palindrome\n    if string.count <= 1 {\n        return string\n\
    \    }\n    let prefix_length = (string.count - 1) / 2\n    let prefix = string[0..<prefix_length]\n\
    \    let middle = string[prefix_length]\n    let suffix = string[prefix_length\
    \ + 1..<string.count]\n    let suffix_palindrome = make_palindrome(string: String(suffix.reversed()))\n\
    \    if string.count % 2 == 0 {\n        return prefix + middle + suffix_palindrome\n\
    \    } else {\n        let matching_prefix = matching_prefix_palindrome(string:\
    \ prefix, suffix: suffix_palindrome)\n        return prefix + middle + suffix_palindrome[matching_prefix.count..<suffix_palindrome.count]\n\
    \    }", "    let stringLength = string.count\n    if stringLength == 0 {\n  \
    \      return \"\"\n    }\n    let array = Array(string)\n    let stringLengthM1\
    \ = stringLength - 1\n    var i = stringLength - 1\n    var j = 0\n    var k =\
    \ 0\n    var l = 0\n    for j in 0..<stringLength {\n        if j > i {\n    \
    \        break\n        }\n        for k in 0...stringLengthM1 {\n           \
    \ if k > j {\n                break\n            }\n            if array[k] !=\
    \ array[stringLengthM1 - k] {\n                break\n            }\n        \
    \    if k == j {\n                l = j + 1\n                break\n         \
    \   }\n        }\n        if k > j {\n            break\n        }\n        i\
    \ -= 1\n    }\n    var result = \"\"\n    for j in 0..<stringLength {\n      \
    \  result.append(array[j])\n    }\n    if l == 0 {\n        l = 1\n    }\n   \
    \ for k in (l...stringLengthM1).reversed() {\n        result.append(array[k])\n\
    \    }\n    return result", "    let s = Array(string)\n    let n = s.count\n\
    \    var p = [Int](repeating: 0, count: n)\n    for i in 0..<n {\n        p[i]\
    \ = 1\n        if i >= 1 && s[i] == s[i - 1] {\n            p[i] = 2\n       \
    \ }\n        if i >= 2 && s[i] == s[i - 2] {\n            p[i] = 3\n        }\n\
    \        for j in 1..<i {\n            if i - j < j && s[i] == s[i - j - 1] &&\
    \ p[i - j] == j {\n                p[i] = j + 1\n            }\n        }\n  \
    \  }\n    var left = Array(string.prefix(n - p[n - 1]))\n    left.reverse()\n\
    \    return string + String(left)", "    // FIXME: Simplify to O(n) by reversing\
    \ prefix. Then you only have to move 1 pointer.\n    let n = string.count\n  \
    \  let chars = Array(string)\n    var longest_pali = [Int](repeating: 0, count:\
    \ n)\n    var end = 0\n    for i in 0..<n {\n        if i < end {\n          \
    \  let mirror = end - (i - end)\n            if longest_pali[mirror] < end - i\
    \ {\n                longest_pali[i] = longest_pali[mirror]\n            } else\
    \ {\n                longest_pali[i] = end - i\n            }\n        }\n   \
    \     while i - longest_pali[i] - 1 >= 0 && i + longest_pali[i] + 1 < n && chars[i\
    \ - longest_pali[i] - 1] == chars[i + longest_pali[i] + 1] {\n            longest_pali[i]\
    \ += 1\n        }\n        if i + longest_pali[i] > end {\n            end = i\
    \ + longest_pali[i]\n        }\n    }\n    let prefix = String(chars[0..<n - longest_pali[n\
    \ - 1]])\n    return prefix + String(prefix.reversed())", "    let index = string.index(string.endIndex,\
    \ offsetBy: -(string.count)/2)\n    let substring = string[..<index]\n    let\
    \ reverse = String(substring.reversed())\n    let postfix = string.suffix(from:\
    \ index)\n    let match = postfix.range(of: reverse)\n    if match != nil {\n\
    \        let count = string.distance(from: string.startIndex, to: match!.lowerBound)\n\
    \        let reversePrefix = String(substring.prefix(count).reversed())\n    \
    \    return string + reversePrefix\n    } else {\n        return make_palindrome(string:\
    \ string + reverse)\n    }", "    let char_array = string.characters.map { String($0)\
    \ }\n    let lps = longest_palindromic_suffix(string: char_array)\n    let offset\
    \ = lps.count > 0 ? char_array.count - lps.count : char_array.count\n    let prefix\
    \ = Array(char_array[0..<offset]).reversed()\n    return \"\\(string)\\(prefix.joined())\"",
  "    if string.count == 0 {\n        return \"\"\n    }\n    let prefix_length =\
    \ longest_palindromic_prefix(string: string)\n    let suffix = string.suffix(string.count\
    \ - prefix_length)\n    let prefix = string.prefix(prefix_length)\n    return\
    \ string + String(suffix.reversed())", "    // This ia the only way to avoid O(N^2)\
    \ time and memory.\n    // We pre-compute the palindrome radius of every letter\
    \ in the string and then use it in a loop.\n    // In the loop we find the radius\
    \ at every position and compare it to the longest radius found so far.\n    let\
    \ palindrome_radii = palindrome_radii_of_string(string: string)\n    let string_length\
    \ = string.count\n    // Start with the longest palindrome that is not the whole\
    \ string.\n    var longest_palindrome_length = palindrome_radii[string_length\
    \ - 1] + 1\n    var longest_palindrome_start = string_length - 1 - longest_palindrome_length\n\
    \    for i in 1 ..< string_length {\n        // Even and odd palindromes can have\
    \ different radii at the same position.\n        let even_palindrome_length =\
    \ palindrome_radii[i]\n        let odd_palindrome_length = palindrome_radii[string_length\
    \ - 1 - i]\n        let even_palindrome_start = i - even_palindrome_length\n \
    \       let odd_palindrome_start = string_length - 1 - i - odd_palindrome_length\n\
    \        // Compare lengths to the longest palindrome length.\n        if even_palindrome_length\
    \ > longest_palindrome_length && even_palindrome_start == 0 {\n            longest_palindrome_length\
    \ = even_palindrome_length\n            longest_palindrome_start = even_palindrome_start\n\
    \        }\n        if odd_palindrome_length > longest_palindrome_length && odd_palindrome_start\
    \ == 0 {\n            longest_palindrome_length = odd_palindrome_length\n    \
    \        longest_palindrome_start = odd_palindrome_start\n        }\n    }\n \
    \   // There are string_length - longest_palindrome_length characters to append.\n\
    \    // We can do it in O(1) with the help of a string builder.\n    var result\
    \ = string\n    for i in 0 ..< string_length - longest_palindrome_length {", " \
    \   let characters = Array(string)\n    let string_len = characters.count\n  \
    \  if string_len <= 1 {\n        return string\n    }\n    let (suffix_start,\
    \ suffix_end) = longest_palindrome_suffix(characters: characters)\n    if suffix_end\
    \ == string_len {\n        return string\n    }\n    return characters[0..<suffix_start].reversed().joined()\
    \ + string", "\tvar palindrome = string\n\tlet reverse = string.reversed()\n\t\
    if !is_palindrome(string: string) {\n\t\tlet prefix_length = find_longest_palindrome_suffix(string:\
    \ string)\n\t\tlet prefix = string.prefix(prefix_length)\n\t\tpalindrome.append(reverse[reverse.index(reverse.startIndex,\
    \ offsetBy: prefix_length)...])\n\t}\n\treturn palindrome", "    guard !string.isEmpty\
    \ else { return \"\" }\n    let len = string.characters.count\n    var end = len\n\
    \    while end > 0 {\n        let idx = string.startIndex.advancedBy(end)\n  \
    \      let prefix = string.substringToIndex(idx)\n        if is_palindrome(string:\
    \ prefix) {\n            let suffix = string.substringFromIndex(idx)\n       \
    \     return string + reverse(string: suffix)\n        }\n        end -= 1\n \
    \   }\n    return \"\"", '    return string + String(string.prefix(reverse_postfix_palindrome(string:
    string).count).reversed())', "    let reverse = string.reversed()\n    for i in\
    \ 0..<string.count {\n        if string.suffix(i) == reverse.prefix(i) {\n   \
    \         return string + reverse.suffix(string.count - i)\n        }\n    }\n\
    \    return string", "    let lowercased = string.lowercased()\n    if is_palindrome(string:\
    \ lowercased) {\n        return lowercased\n    }\n    var prefix_size = 0\n \
    \   for index in 0..<lowercased.count {\n        if is_palindrome(string: String(lowercased.suffix(from:\
    \ lowercased.index(lowercased.startIndex, offsetBy: index)))) {\n            prefix_size\
    \ = index\n            break\n        }\n    }\n    var reversed_prefix = \"\"\
    \n    for index in 0..<prefix_size {\n        reversed_prefix.append(lowercased[lowercased.index(lowercased.startIndex,\
    \ offsetBy: prefix_size - index - 1)])\n    }\n    return lowercased + reversed_prefix",
  "    let prefix = String(string.prefix(string.count - longest_palindromic_suffix(string:\
    \ string).count))\n    return string + String(prefix.reversed())", "    let reversed\
    \ = string.reversed()\n    let string = string + \"\\0\" + reversed\n    let n\
    \ = string.count\n    var z = [Int](repeating: 0, count: n)\n    var l = 0\n \
    \   var r = 0\n    for i in 1..<n {\n        if i <= r {\n            z[i] = min(r\
    \ - i + 1, z[i - l])\n        }\n        while i + z[i] < n && string[string.index(string.startIndex,\
    \ offsetBy: z[i])] == string[string.index(string.startIndex, offsetBy: i + z[i])]\
    \ {\n            z[i] += 1\n        }\n        if i + z[i] - 1 > r {\n       \
    \     l = i\n            r = i + z[i] - 1\n        }\n    }\n    var result =\
    \ string\n    let substring = reversed.prefix(n - z[n - 1])\n    result.append(substring)\n\
    \    return result", "    let reversed = string.reversed()\n    let longest_palindrome_suffix\
    \ = longest_palindrome_suffix_checker(string: string, reversed: reversed)\n  \
    \  return string + String(reversed.dropFirst(longest_palindrome_suffix))", " \
    \   // Handle the simplest case.\n    if is_palindrome(string: string) {\n   \
    \     return string\n    }\n    \n    // The longest palindromic suffix will be\
    \ used later to reverse the prefix.\n    let longest_palindromic_suffix = longest_palindromic_suffix_of(string:\
    \ string)\n    \n    let prefix = string.prefix(upTo: string.index(string.endIndex,\
    \ offsetBy: -longest_palindromic_suffix.count))\n    let reverse_prefix = String(prefix.reversed())\n\
    \    \n    return prefix + reverse_prefix + longest_palindromic_suffix", "   \
    \ guard string.count > 0 else { return \"\" }\n    guard string.count > 1 else\
    \ { return string }\n    var temp = string\n    let prefix = String(temp.dropLast())\n\
    \    let postfix = prefix.reversed()\n    temp.append(postfix)\n    return temp",
  "    var chars = string.characters\n    var prefix_chars = chars.reversed()\n  \
    \  var length = chars.count\n    var length_limit = chars.count / 2\n    for idx\
    \ in 0..<length_limit {\n        if chars[idx] != chars[length - idx - 1] {\n\
    \            length = idx\n            break\n        }\n    }\n    return String(chars)\
    \ + String(prefix_chars[length..<prefix_chars.count])", "    if string.count <=\
    \ 1 {\n        return string\n    }\n    // As the longest palindrome suffix is\
    \ always a string itself,\n    // we can start with the full string.\n    var\
    \ suffix = string\n    // Subtract 1 from the length to skip a single character.\n\
    \    for i in 1..<string.count {\n        // Get prefix to the left of the suffix.\n\
    \        let prefix = string[..<string.index(string.startIndex, offsetBy: i)]\n\
    \        if is_palindrome(string: String(prefix)) {\n            // Append reverse\
    \ of prefix.\n            suffix.append(String(prefix.reversed()))\n         \
    \   return suffix\n        }\n    }\n    // The entire string is a palindrome,\
    \ nothing to append.\n    return string", "    if string.isEmpty {\n        return\
    \ string\n    }\n    let suffix = suffix_palindrome(string: string)\n    let prefix\
    \ = string.prefix(string.count - suffix.count)\n    return string + String(prefix.reversed())",
  "    guard string.isEmpty == false else {\n        return string\n    }\n    let\
    \ suffix = longest_palindromic_suffix(string: string)\n    let prefix = string.prefix(string.count\
    \ - suffix.count)\n    return string + String(prefix.reversed())", "    let s\
    \ = Array(string)\n    let n = s.count\n    if n == 0 {\n        return \"\"\n\
    \    }\n    let t = s + [Character(\"$\")] + s.reversed()\n    let z = z_function(string:\
    \ t)\n    var i = n\n    while i > 0 && z[i] != i {\n        i -= 1\n    }\n \
    \   let prefix = String(s[0..<(n - i)])\n    return string + prefix.reversed()",
  "    let length = string.count\n    var suffix = String(string.reversed())\n   \
    \ var prefix = string\n    while !is_palindrome(string: prefix) {\n        suffix.removeFirst()\n\
    \        prefix.removeLast()\n    }\n    return string + suffix", "  let string_array\
    \ = Array(string)\n  let long = string_array.count\n  if long == 0 {\n    return\
    \ \"\"\n  }\n  // Find the longest suffix of a string that is a palindrome.\n\
    \  var end = long - 1\n  var palindrome_end = -1\n  var palindrome_start = -1\n\
    \  while end >= 0 {\n    var start = 0\n    while start <= end {\n      if string_array[start]\
    \ == string_array[end] {\n        start += 1\n        end -= 1\n      } else {\n\
    \        start = 0\n        end -= 1\n      }\n    }\n    if start == end {\n\
    \      palindrome_end = end\n      palindrome_start = start\n      break\n   \
    \ }\n  }\n  // At this point, palindrome_end points to the end of the palindromic\
    \ suffix.\n  // Prefix before the palindromic suffix is string_array[0..<palindrome_end].\n\
    \  // Palindromic suffix is string_array[palindrome_end..<long].\n  // We need\
    \ to append the reverse of a prefix before the palindromic suffix to the end of\
    \ the string.\n  // result = string_array[0..<palindrome_end] + string_array[palindrome_end..<long]\
    \ + string_array[palindrome_end-1..<0].reversed()\n  let new_chars = string_array[0..<palindrome_end].reversed()\n\
    \  var result = string\n  for c in new_chars {\n    result += String(c)\n  }\n\
    \  return result", "    // TODO: implement me\n    return string", '  return string
    + String(string.characters.reversed())', "    let (lps, palindrome_length) = longest_palindromic_suffix(string:\
    \ string)\n    let prefix = string.substring(to: string.index(string.startIndex,\
    \ offsetBy: string.count - palindrome_length))\n    return string + String(prefix.reversed())",
  '    return [string, String(string.dropLast(find_longest_palindrome_postfix(string:
    string).count))].joined(separator: "")', "    if string.count == 0 {\n       \
    \ return \"\"\n    }\n    if is_palindrome(string: string) {\n        return string\n\
    \    }\n    let suffix_size = palindromic_suffix_size(string: string)\n    let\
    \ prefix = String(string.prefix(string.count - suffix_size))\n    return prefix\
    \ + String(prefix.reversed()) + string", "    let len = string.count\n    let\
    \ s = string.utf8CString\n    guard len > 0 else { return \"\" }\n    var lp =\
    \ 0\n    var rp = len - 1\n    while lp < rp {\n        if s[lp] != s[rp] { break\
    \ }\n        lp += 1\n        rp -= 1\n    }\n    var beg = lp\n    var end =\
    \ lp\n    for i in lp...(len - 1) {\n        var j = 1\n        while (i - j >=\
    \ 0) && (i + j < len) && (s[i - j] == s[i + j]) {\n            j += 1\n      \
    \  }\n        if (j > end - beg) {\n            beg = i - j + 1\n            end\
    \ = i + j - 1\n        }\n    }\n    for i in lp...(len - 1) {\n        var j\
    \ = 0\n        while (i - j >= 0) && (i + j + 1 < len) && (s[i - j] == s[i + j\
    \ + 1]) {\n            j += 1\n        }\n        if (j > end - beg) {\n     \
    \       beg = i - j + 1\n            end = i + j\n        }\n    }\n    var reverse\
    \ = \"\"\n    for i in 0..<beg {\n        reverse.append(String(s[i]))\n    }\n\
    \    let rlen = reverse.count\n    var i = 0\n    while i < rlen {\n        reverse.append(String(reverse[rlen\
    \ - i - 1]))\n        i += 1\n    }\n    for i in end + 1..<len {\n        reverse.append(String(s[i]))\n\
    \    }\n    return reverse", "    guard !string.isEmpty else { return \"\" }\n\
    \    let prefix_reversed = String(string.prefix(string.count - longest_palindromic_suffix(string:\
    \ string).count).reversed())\n    return string + prefix_reversed", "    // Find\
    \ the longest palindromic suffix\n    let palindromic_suffix = find_longest_palindromic_suffix(string:\
    \ string)\n    // Find the prefix of the string that comes before the palindromic\
    \ suffix\n    let prefix = string.substring(to: string.index(string.endIndex,\
    \ offsetBy: -palindromic_suffix.count))\n    // Append to the string reverse of\
    \ a prefix\n    return string + reverse(string: prefix)", "    var string = string\n\
    \    var position = string.startIndex\n    var end = string.endIndex\n    while\
    \ position < end {\n        var s = string.suffix(from: position)\n        if\
    \ is_palindrome(string: s) {\n            var prefix = string.prefix(upTo: position)\n\
    \            prefix.removeLast()\n            string += String(prefix.reversed())\n\
    \            return string\n        }\n        string.removeLast()\n        end\
    \ = string.endIndex\n    }\n    return string", "    var postfix = reverse(string:\
    \ string)\n    let (_, first_palindrome_length) = find_palindrome(string: string\
    \ + postfix)\n    if postfix.characters.count > first_palindrome_length {\n  \
    \      postfix = String(postfix.characters.dropFirst(postfix.characters.count\
    \ - first_palindrome_length))\n    }\n    return string + postfix", "    if string.isEmpty\
    \ {\n        return string\n    }\n    let s_n = string.count\n    let suffix_length\
    \ = get_max_palindrome_suffix_length(string: string)\n    return string + String(string.prefix(s_n\
    \ - suffix_length).reversed())", "    let suffix = String(string.suffix { string.is_palindrome(prefix:\
    \ string.prefix(upTo: $0.utf16Offset(in: string))) })\n    return string + String(suffix.reversed())",
  "    if is_palindrome(string: string) {\n        return string\n    }\n    let reverse\
    \ = string.reversed()\n    let longest_common_postfix = longest_common_substring(s1:\
    \ string, s2: reverse).0\n    return string + String(reverse.dropFirst(string.count\
    \ - longest_common_postfix.count))", "    guard string.count > 0 else { return\
    \ \"\" }\n    let suffix = find_longest_suffix_palindrome(string: string)\n  \
    \  let prefix = String(string.prefix(string.count - suffix.count))\n    return\
    \ string + String(prefix.reversed())", "    let string = string.lowercased()\n\
    \    if string.count <= 1 {\n        return string\n    }\n    if is_palindrome(string:\
    \ string) {\n        return string\n    }\n    let suffix = find_longest_palindromic_suffix(string:\
    \ string)\n    let prefix = String(string.prefix(string.count - suffix.count).reversed())\n\
    \    return string + prefix", "    if string.isEmpty {\n        return string\n\
    \    }\n    if let range = string.range(of: string.reversed(), options: .anchored)\
    \ {\n        if range.upperBound == string.endIndex {\n            return string\n\
    \        }\n        return \"\\(string)\\(string[..<range.lowerBound].reversed())\"\
    \n    }\n    return \"\"", "    let str_len = string.count\n    if str_len ==\
    \ 0 {\n        return \"\"\n    }\n    if str_len == 1 {\n        return string\n\
    \    }\n    let input_chars = Array(string)\n    // Find the longest postfix of\
    \ supplied string that is a palindrome.\n    var palindrome_len = 1\n    for i\
    \ in (1..<str_len).reversed() {\n        if input_chars[i] == input_chars[i -\
    \ 1] {\n            palindrome_len += 1\n        } else {\n            break\n\
    \        }\n    }\n    if palindrome_len == str_len {\n        return string\n\
    \    }\n    // Append to the end of the string reverse of a string prefix that\
    \ comes before the palindromic suffix.\n    var result = string\n    var start_index\
    \ = str_len - palindrome_len - 1\n    while start_index >= 0 {\n        result.append(input_chars[start_index])\n\
    \        start_index -= 1\n    }\n    return result", "    guard !string.isEmpty\
    \ else { return \"\" }\n    let remaining = String(string.characters.dropLast())\n\
    \    let remaining_palindrome = make_palindrome(string: remaining)\n    let remaining_index\
    \ = remaining.index(remaining.endIndex, offsetBy: -remaining_palindrome.characters.count)\n\
    \    let reversed_prefix = String(remaining[..<remaining_index].characters.reversed())\n\
    \    return remaining + string.last! + reversed_prefix", "    if string.isEmpty\
    \ {\n        return string\n    }\n    let longest_palindrome_suffix = longest_palindrome_suffix_of(string:\
    \ string)\n    let suffix_slice = string.index(string.endIndex, offsetBy: -longest_palindrome_suffix.count)\n\
    \    let prefix = String(string[..<suffix_slice].reversed())\n    return string\
    \ + prefix", "    let max_len_suffix = find_longest_palindromic_suffix(string:\
    \ string)\n    if max_len_suffix == string.count {\n        return string\n  \
    \  }\n    let prefix = String(string.prefix(string.count - max_len_suffix))\n\
    \    return string + String(prefix.reversed())", "    // Base case\n    if string.isEmpty\
    \ {\n        return string\n    }\n    \n    let n = string.count\n    let array\
    \ = Array(string)\n    var lps = Array(repeating: 0, count: n)\n    // If string\
    \ is palindrome itself.\n    if is_palindrome(string: string) {\n        return\
    \ string\n    }\n    \n    // Longest palindromic suffix\n    let max_length =\
    \ find_longest_palindromic_suffix(array: array, lps: &lps)\n    let prefix = Array(string.prefix(n\
    \ - max_length))\n    let reversed_prefix = String(prefix.reversed())\n    return\
    \ string + reversed_prefix", "  guard string.count > 0 else { return \"\" }\n\
    \  var suffix = \"\"\n  var prefix = \"\"\n  var longest = \"\"\n  for i in 0..<string.count\
    \ {\n    suffix = String(string[string.index(string.startIndex, offsetBy: i)...])\n\
    \    prefix = String(string[string.startIndex..<string.index(string.startIndex,\
    \ offsetBy: i)])\n    if is_palindrome(string: suffix) && suffix.count > longest.count\
    \ {\n      longest = suffix\n    }\n  }\n  return string + String(prefix.reversed())",
  "    let reverse_string = String(string.reversed())\n    let string_len = string.count\n\
    \    let reversed_string_len = reverse_string.count\n    let end_index = string_len\n\
    \    let reversed_string_start_index = reversed_string_len - string_len\n    let\
    \ reversed_string_end_index = reversed_string_len\n    for i in 0..<string_len\
    \ {\n        let sub_string = string[i..<end_index]\n        let reverse_sub_string\
    \ = reverse_string[reversed_string_start_index..<reversed_string_end_index]\n\
    \        if sub_string == reverse_sub_string {\n            let left_string =\
    \ string[0..<i]\n            let right_string = String(left_string.reversed())\n\
    \            return string + right_string\n        }\n    }\n    return string",
  "    var result = string\n    let prefix = String(string.dropLast(find_longest_palindrome_suffix(string:\
    \ string).count))\n    result.append(String(prefix.reversed()))\n    return result",
  "    var result = string\n    let suffix = longest_palindromic_suffix(string: string)\n\
    \    result += suffix.reversed()\n    return result", "\tif string.isEmpty {\n\
    \t\treturn string\n\t}\n\t// find longest palindromic postfix\n\tvar postfix_string\
    \ = String(string.dropFirst())\n\twhile !is_palindrome(string: postfix_string)\
    \ {\n\t\tpostfix_string = String(postfix_string.dropFirst())\n\t}\n\t// reverse\
    \ it and append\n\tvar prefix_string = String(postfix_string.reversed())\n\tif\
    \ prefix_string.count != string.count {\n\t\tprefix_string = String(prefix_string.dropLast())\n\
    \t}\n\treturn string + prefix_string", '    return string + String(string.dropLast(palindrome_suffix_length(string:
    string)).reversed())', "    if string.isEmpty {\n        return string\n    }\n\
    \    let charArray = Array(string)\n    let table = SuffixTrie(string: charArray).buildSuffixTrie()\n\
    \    let postfix = table.longest_postfix()\n    let prefix = String(charArray[charArray.startIndex..<(charArray.endIndex\
    \ - postfix.characters.count)])\n    return prefix + String(charArray.reversed())",
  "    // Find the longest palindromic postfix.\n    let lps = longest_palindromic_substring(input:\
    \ string)\n    // Remove longest palindromic postfix from the input string.\n\
    \    let prefix = string.prefix(string.count - lps.count)\n    // Reverse the\
    \ prefix and append it to the input string.\n    return \"\\(string)\\(String(prefix.reversed()))\"",
  "    // First find the longest palindromic suffix.\n    // Start with the middle\
    \ of the string, and\n    //  iterate through the string on both sides of the\
    \ center.\n    //  If the letters match, increment palindrome length.\n    //\
    \  If they don't match, break the iteration.\n    //  Skip the iteration if the\
    \ length of the suffix is already equal to length of the string,\n    //   because\
    \ then the whole string is already a palindrome.\n    let chars = Array(string)\n\
    \    let middle = Int(floor(Double(chars.count) / 2.0))\n    var palindrome_length\
    \ = 1\n    for idx in 1..<middle {\n        if chars[middle - idx] == chars[middle\
    \ + idx] {\n            palindrome_length += 2\n        } else {\n           \
    \ break\n        }\n    }\n    // If whole string is a palindrome, just return\
    \ it.\n    if palindrome_length == chars.count {\n        return string\n    }\n\
    \    // Otherwise, reverse the prefix of the string that comes before the longest\
    \ palindromic suffix,\n    //  and append it to the end of the string.\n    var\
    \ new_string = string\n    for idx in 0..<(chars.count - palindrome_length) {\n\
    \        new_string.append(chars[chars.count - idx - 1])\n    }\n    return new_string",
  "    // Empty string is always palindrome.\n    if string.isEmpty {\n        return\
    \ string\n    }\n    // Find the longest palindromic suffix.\n    let palindromic_suffix\
    \ = find_palindromic_suffix(string: string)\n    // Reverse the prefix that comes\
    \ before the palindromic suffix.\n    let reversed_prefix = String(string.prefix(string.count\
    \ - palindromic_suffix.count).reversed())\n    // Append reversed prefix to the\
    \ end of the string.\n    return string + reversed_prefix", "    let string_array\
    \ = Array(string)\n    let palindrome_suffix = longest_palindrome_suffix(string:\
    \ string_array)\n    var prefix = string_array[0..<string_array.count - palindrome_suffix.count]\n\
    \    prefix.reverse()\n    return String(string_array) + String(prefix)", "  \
    \  let string_as_array = string.map { $0 }\n    var tail_palindrome_length: Int\n\
    \    if let suffix_palindrome_length = find_longest_suffix_palindrome(string:\
    \ string_as_array) {\n        tail_palindrome_length = suffix_palindrome_length\n\
    \    } else {\n        return string\n    }\n    let suffix_length = string_as_array.count\
    \ - tail_palindrome_length\n    let prefix = string_as_array[0..<suffix_length]\n\
    \    let reversed_prefix = Array(prefix.reversed())\n    return string + String(reversed_prefix)",
  "    var prefix: String = string\n    var postfix: String = String(string.reversed())\n\
    \    let length = string.count\n    for i in 0..<length {\n        let end_of_prefix\
    \ = prefix.index(prefix.startIndex, offsetBy: i + 1)\n        let end_of_postfix\
    \ = postfix.index(postfix.startIndex, offsetBy: length - i)\n        let new_prefix\
    \ = String(prefix[..<end_of_prefix])\n        let new_postfix = String(postfix[..<end_of_postfix])\n\
    \        if new_prefix == new_postfix {\n            prefix = new_prefix\n   \
    \         postfix = new_postfix\n        }\n    }\n    return prefix + String(postfix.reversed())",
  "    let palindrome_suffix = find_largest_palindrome_suffix(string: string)\n  \
    \  let palindrome_prefix = String(string.prefix(string.count - palindrome_suffix.count).reversed())\n\
    \    return string + palindrome_prefix", "    let reversed = string.reversed()\n\
    \    var prefix_to_suffix = string.suffix(max_common_prefix(with: reversed))\n\
    \    let suffix_to_prefix = string.prefix(string.count - prefix_to_suffix.count)\n\
    \    return \"\\(string)\\(suffix_to_prefix.reversed())\"", "    let length =\
    \ string.count\n    if length <= 1 {\n        return string\n    }\n    var string\
    \ = string\n    let postfix_length = longest_palindromic_postfix_length(string:\
    \ string)\n    let prefix = string.prefix(length - postfix_length)\n    string.append(prefix.reversed())\n\
    \    return string", "    let reversed = String(string.reversed())\n    let prefix\
    \ = longest_common_prefix(string1: string, string2: reversed)\n    return prefix\
    \ + String(string.dropFirst(prefix.count).reversed())", "    let characters =\
    \ Array(string)\n    let n = characters.count\n    if n == 0 {\n        return\
    \ \"\"\n    }\n    // Find the longest palindromic suffix of `string`.\n    var\
    \ z = z_function(string: string + characters.reversed().map { String($0) }.joined())\n\
    \    let suffix = characters.suffix(z[n + n - 1])\n    let prefix = characters.prefix(n\
    \ - suffix.count)\n    return string + prefix.reversed().map { String($0) }.joined()",
  "  let reversed = String(string.reversed())\n  let palindromeSuffix = reversed.suffix(string.count\
    \ - longest_common_substring(string, reversed).count)\n  return string + String(palindromeSuffix.reversed())",
  "    let string_length = string.count\n    var max_postfix_palindrome_length = 0\n\
    \    var offset = string_length - 1\n    var suffix_range = string.endIndex..<string.endIndex\n\
    \    while offset >= 0 {\n        let range = string.index(string.startIndex,\
    \ offsetBy: offset)..<string.endIndex\n        if range.is_palindrome() {\n  \
    \          max_postfix_palindrome_length = string_length - offset\n          \
    \  suffix_range = range\n            break\n        }\n        offset -= 1\n \
    \   }\n    let prefix_range = string.startIndex..<string.index(string.startIndex,\
    \ offsetBy: string_length - max_postfix_palindrome_length)\n    return String(string[prefix_range])\
    \ + String(string[suffix_range].reversed())", "    let middle = find_middle(string:\
    \ string)\n    return string.prefix(string.count - middle.count) + String(string.suffix(middle.count).reversed())",
  "    let s = Array(string)\n    let n = s.count\n    let s0 = Array(repeating: 0,\
    \ count: n)\n    var result = Array(repeating: 0, count: n)\n    var i = 0\n \
    \   while i < n - 1 {\n        s0[i] = i\n        if s[i] == s[i + 1] {\n    \
    \        s0[i + 1] = i\n            i += 1\n        }\n        i += 1\n    }\n\
    \    s0[n - 1] = n - 1\n    var l = 1\n    var r = 1\n    var max_l = 1\n    var\
    \ max_r = 1\n    var max_i = 0\n    while l < n - 1 {\n        if l > r {\n  \
    \          i = l\n            l = 1\n            r = i\n        }\n        while\
    \ r < n - 1 && 2 * r - l < n - 1 && s[2 * r - l] == s[r + 1] {\n            r\
    \ += 1\n        }\n        s0[r] = l\n        if 2 * r - l > max_r {\n       \
    \     max_l = l\n            max_r = 2 * r - l\n            max_i = r\n      \
    \  }\n        l += 1\n    }\n    for i in 0..<n {\n        if max_l <= i && i\
    \ <= max_r {\n            result[i] = s[max_r - i]\n        } else {\n       \
    \     result[i] = s[i]\n        }\n    }\n    return String(result)", "    if\
    \ string.isEmpty {\n        return string\n    }\n    let s = string.appending(string.reversed())\n\
    \    return kmp(text: s, pattern: string).1!", "    let chars = Array(string)\n\
    \    let n = chars.count\n    var res = \"\"\n    for i in (0..<n).reversed()\
    \ {\n        var check = true\n        for j in 0..<n/2 {\n            if i -\
    \ j < 0 || chars[i - j] != chars[i + j] {\n                check = false\n   \
    \             break\n            }\n        }\n        if check {\n          \
    \  res = String(chars[0..<i])\n            break\n        }\n    }\n    return\
    \ string + String(res.reversed())", "  guard !string.isEmpty else { return \"\"\
    \ }\n  let length = string.count\n  var result = string\n  for i in (0..<length).reversed()\
    \ {\n    let suffix = String(string[string.index(string.startIndex, offsetBy:\
    \ i)...])\n    if is_palindrome(string: suffix) {\n      let prefix = String(string[..<string.index(string.startIndex,\
    \ offsetBy: i)])\n      result += String(prefix.reversed())\n      break\n   \
    \ }\n  }\n  return result", "    // String must be longer than 1 character\n \
    \   // if length of the string is 0 - return the same string\n    // if length\
    \ of the string is 1 - return the same string\n    // if length of the string\
    \ is 2 - check if palindrome is odd or even (assume that even is true)\n    //\
    \ if length of the string is 3 - then we also need to check if palindrome is odd\
    \ or even (assume that even is true)\n    // use loop to go thru the characters\
    \ of string and check if they are the same from start and end of the string\n\
    \    // make a new variable of type int, which will be equal to length of the\
    \ string - 1\n    // use for loop to run thru each character of the string\n \
    \   // check if the string is even (1) and character from beginning of the string\
    \ is equal to a char from end of the string\n    // we need to divide the length\
    \ of the string by 2\n    // if the string is odd (2) and character from beginning\
    \ of the string is equal to a char from end of the string\n    // we need to divide\
    \ the length of the string by 2 and add 1\n    //\n    // if length of the string\
    \ is more than 3 - then we also need to check if palindrome is odd or even (assume\
    \ that even is true)\n    // use loop to go thru the characters of string and\
    \ check if they are the same from start and end of the string\n    // make a new\
    \ variable of type int, which will be equal to length of the string - 1\n    //\
    \ use for loop to run thru each character of the string\n    // check if the string\
    \ is even (1) and character from beginning of the string is equal to a char from\
    \ end of the string\n    // we need to divide the length of the string by 2\n\
    \    // if the string is odd (2) and character from beginning of the string is\
    \ equal to a char from end of the string\n    // we need to divide the length\
    \ of the string by 2 and add 1\n    //\n    //\n    // if length of the string\
    \ is more than 4 - then we also need to check if palindrome is odd or even (assume\
    \ that even is true)\n    // use loop to go thru the characters of string and\
    \ check if they are the same from start and end of the string\n    // make a new",
  "    let length = string.count\n    let suffix = postfix_palindrome(string: string)\n\
    \    let prefix = string.prefix(length - suffix.count)\n    return prefix.reversed()\
    \ + string", "    guard string.characters.count > 0 else {\n        return string\n\
    \    }\n    let (suffix_length, _) = longest_palindromic_substring(string: string)\n\
    \    let prefix = string.substring(to: string.index(string.startIndex, offsetBy:\
    \ string.characters.count - suffix_length))\n    return string + prefix.characters.reversed()",
  "    if string.isEmpty {\n        return string\n    }\n    return make_palindrome(string:\
    \ string.dropLast()) + String(string.reversed())", "    if string.isEmpty {\n\
    \        return string\n    }\n    var biggest_palindrome_suffix = \"\"\n    for\
    \ suffix in suffixes(string: string) {\n        if is_palindrome(string: suffix)\
    \ {\n            biggest_palindrome_suffix = suffix\n            break\n     \
    \   }\n    }\n    var prefix = string.substring(to: string.characters.index(string.endIndex,\
    \ offsetBy: -biggest_palindrome_suffix.characters.count))\n    return prefix +\
    \ string", "    var string = string\n    let string_length = string.count\n  \
    \  if string_length == 0 {\n        return \"\"\n    }\n    let string_suffix\
    \ = String(string.suffix(string_length - 1))\n    if string_suffix.is_palindrome()\
    \ {\n        string.append(string.prefix(1))\n        return string\n    }\n \
    \   let reversed_prefix = String(string.prefix(string_length - 1).reversed())\n\
    \    string.append(reversed_prefix)\n    return string", "    // If a string is\
    \ a palindrome, return it immediately.\n    if (is_palindrome(string: string))\
    \ {\n        return string\n    }\n    // Find the longest palindromic postfix\
    \ for the supplied string.\n    let longest_palindromic_postfix = find_longest_palindromic_postfix(string:\
    \ string)\n    // Find the prefix (from the beginning of the string) which comes\
    \ before the postfix.\n    let prefix = String(string.prefix(string.count - longest_palindromic_postfix.count))\n\
    \    // Return the palindrome.\n    return prefix + String(string.reversed())",
  "    guard string.count > 0 else { return \"\" }\n    guard string.count > 1 else\
    \ { return string }\n    guard let postfix = longest_palindromic_postfix(string:\
    \ string) else { return \"\" }\n    return string + string.prefix(upTo: string.index(string.endIndex,\
    \ offsetBy: -postfix.count))\n        .reversed()", "    // we need to get a string\
    \ prefix that comes before the palindromic suffix,\n    // and we can get it by\
    \ simply dropping the palindromic suffix from the end of the string.\n    let\
    \ suffix = find_palindromic_suffix(string: string)\n    let prefix = String(string.dropLast(suffix.count))\n\
    \    return string + String(prefix.reversed())", "    if string.count == 0 {\n\
    \        return \"\"\n    }\n    if string.count == 1 {\n        return string\n\
    \    }\n    let lps = longest_palindromic_suffix(string: string)\n    let prefix\
    \ = String(string.prefix(string.count - lps.count))\n    let reversed_prefix =\
    \ String(prefix.reversed())\n    return prefix + reversed_prefix + lps", "   \
    \ let s = Array(string)\n    let n = s.count\n    guard n > 0 else { return \"\
    \" }\n    var i = 1\n    while i < n && s[i] != s[i - 1] {\n        i += 1\n \
    \   }\n    if i == n {\n        return \"\\(s)\\(String(s.dropFirst().reversed()))\"\
    \n    }\n    else {\n        let suffix = String(s.dropFirst(i))\n        let\
    \ prefix = String(s.dropLast(suffix.count).reversed())\n        return \"\\(suffix)\\\
    (prefix)\\(suffix)\"\n    }", "    var reverseString = string.reversed()\n   \
    \ let suffix = find_suffix(string: string, reverseString: reverseString)\n   \
    \ let prefix = String(string.prefix(string.count - suffix.count))\n    reverseString\
    \ = String(prefix.reversed())\n    return string + reverseString", "    var s\
    \ = string\n    let lps = longest_palindromic_suffix(string: s)\n    let prefix\
    \ = s.prefix(s.count - lps.count)\n    s.append(prefix.reversed())\n    return\
    \ s", "    var string = string\n    var reverse = string.characters.reversed()\n\
    \    string.append(contentsOf: reverse)\n    return string", "    guard !string.isEmpty\
    \ else { return \"\" }\n    guard string.count > 1 else { return string }\n  \
    \  var string = string\n    let initial_count = string.count\n    // Find the\
    \ longest suffix that is a palindrome\n    while !is_palindrome(string: string)\
    \ {\n        // Drop last char from the string\n        string.removeLast()\n\
    \    }\n    // Reverse the string and append to itself\n    return string + string.reversed()",
  "    let reverse = String(string.reversed())\n    let length = string.count\n  \
    \  if string == reverse {\n        return string\n    }\n    var max_suffix_suffix_length\
    \ = 0\n    var suffix_length = 1\n    while suffix_length <= length {\n      \
    \  let suffix = string.suffix(suffix_length)\n        let reverse_suffix = reverse.prefix(suffix_length)\n\
    \        if suffix == reverse_suffix {\n            max_suffix_suffix_length =\
    \ suffix_length\n        }\n        suffix_length += 1\n    }\n    let prefix\
    \ = string.prefix(length - max_suffix_suffix_length)\n    let reverse_prefix =\
    \ String(prefix.reversed())\n    return string + reverse_prefix", "    let rev\
    \ = String(string.reversed())\n    let concat = string + \"#\" + rev\n    let\
    \ s = string\n    let n = s.count\n    let z = get_z_function(string: concat)\n\
    \    var best = 0\n    for i in 1..<n {\n        if i + z[i] == n {\n        \
    \    best = max(best, z[i])\n        }\n    }\n    return string + String(rev.suffix(n\
    \ - best))", "    let n = string.characters.count\n    if n == 0 {\n        return\
    \ \"\"\n    }\n    var suffix = make_suffix_array(string: string)\n    let lcp\
    \ = make_lcp_array(suffix: suffix, string: string)\n    var k = 0\n    while k\
    \ < n - 1 && lcp[k] > lcp[k + 1] {\n        k += 1\n    }\n    let palindrome\
    \ = string.substring(from: suffix[k])\n    let prefix = palindrome.substring(to:\
    \ palindrome.index(palindrome.startIndex, offsetBy: lcp[k]))\n    return palindrome\
    \ + prefix.characters.reversed()", "    let string = Array(string)\n    let prefix\
    \ = string[0..<string.count]\n    let suffix = string[0..<string.count].reversed()\n\
    \    let palindrome_suffix = longest_prefix_suffix(arr: prefix, mask: suffix)\n\
    \    let palindrome_prefix = string[0..<(string.count - palindrome_suffix.count)].reversed()\n\
    \    return String(prefix + palindrome_prefix)", "    let chars = Array(string)\n\
    \    var prefix: [Character] = []\n    var suffix: [Character] = []\n    var longest_palindrome_length\
    \ = 0\n    // Find the longest suffix that is a palindrome\n    for i in 0..<chars.count\
    \ {\n        // i == 0 is the case when the suffix is empty\n        if is_palindrome(string:\
    \ String(chars[0..<i])) {\n            suffix = Array(chars[0..<i])\n        \
    \    longest_palindrome_length = i\n        }\n    }\n    // Reverse the prefix\
    \ and append it to the end of the string\n    // The prefix starts right after\
    \ the found palindromic suffix\n    prefix = Array(chars[longest_palindrome_length..<chars.count])\n\
    \    return string + String(prefix.reversed())"]
stop_tokens:
- "\n}"
