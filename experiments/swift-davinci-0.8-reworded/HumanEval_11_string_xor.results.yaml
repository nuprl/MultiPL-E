language: swift
name: HumanEval_11_string_xor
results:
- exit_code: 1
  program: "\n/// Input are two strings a and b consisting only of 1s and 0s.\n///\
    \ Perform binary XOR on these inputs and return result also as a string.\n///\
    \ >>> string_xor(a: \"010\", b: \"110\")\n/// \"100\"\nfunc string_xor(a: String,\
    \ b: String) -> String {\n    var result = \"\"\n    for i in 0..<a.characters.count\
    \ {\n        let a_i = a[a.index(a.startIndex, offsetBy: i)]\n        let b_i\
    \ = b[b.index(b.startIndex, offsetBy: i)]\n        if a_i == b_i {\n         \
    \   result += \"0\"\n        } else {\n            result += \"1\"\n        }\n\
    \    }\n    return result\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(string_xor(a:\
    \ \"111000\", b: \"101010\") == \"010010\")\nassert(string_xor(a: \"1\", b: \"\
    1\") == \"0\")\nassert(string_xor(a: \"0101\", b: \"0000\") == \"0101\")"
  status: SyntaxError
  stderr: "/tmp/tmpfbsgpsgf.swift:8:20: error: 'characters' is unavailable: Please\
    \ use String directly\n    for i in 0..<a.characters.count {\n               \
    \    ^~~~~~~~~~\nSwift.String:5:16: note: 'characters' was obsoleted in Swift\
    \ 5.0\n    public var characters: String { get set }\n               ^\n"
  stdout: ''
  timestamp: 1659978479
- exit_code: 1
  program: "\n/// Input are two strings a and b consisting only of 1s and 0s.\n///\
    \ Perform binary XOR on these inputs and return result also as a string.\n///\
    \ >>> string_xor(a: \"010\", b: \"110\")\n/// \"100\"\nfunc string_xor(a: String,\
    \ b: String) -> String {\n    var s = \"\"\n    for (i, ac) in a.characters.enumerated()\
    \ {\n        let bc = b[b.characters.index(b.startIndex, offsetBy: i)]\n     \
    \   s += String(ac != bc ? \"1\" : \"0\")\n    }\n    return s\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(string_xor(a: \"111000\", b: \"101010\") == \"010010\"\
    )\nassert(string_xor(a: \"1\", b: \"1\") == \"0\")\nassert(string_xor(a: \"0101\"\
    , b: \"0000\") == \"0101\")"
  status: SyntaxError
  stderr: "/tmp/tmpatuv_vtt.swift:8:22: error: 'characters' is unavailable: Please\
    \ use String directly\n    for (i, ac) in a.characters.enumerated() {\n      \
    \               ^~~~~~~~~~\nSwift.String:5:16: note: 'characters' was obsoleted\
    \ in Swift 5.0\n    public var characters: String { get set }\n              \
    \ ^\n/tmp/tmpatuv_vtt.swift:9:22: error: 'characters' is unavailable: Please use\
    \ String directly\n        let bc = b[b.characters.index(b.startIndex, offsetBy:\
    \ i)]\n                     ^~~~~~~~~~\nSwift.String:5:16: note: 'characters'\
    \ was obsoleted in Swift 5.0\n    public var characters: String { get set }\n\
    \               ^\n"
  stdout: ''
  timestamp: 1659978479
- exit_code: 0
  program: "\n/// Input are two strings a and b consisting only of 1s and 0s.\n///\
    \ Perform binary XOR on these inputs and return result also as a string.\n///\
    \ >>> string_xor(a: \"010\", b: \"110\")\n/// \"100\"\nfunc string_xor(a: String,\
    \ b: String) -> String {\n    var a = a, b = b\n    if a.count < b.count {\n \
    \       let diff = b.count - a.count\n        a = String(repeating: \"0\", count:\
    \ diff) + a\n    } else if a.count > b.count {\n        let diff = a.count - b.count\n\
    \        b = String(repeating: \"0\", count: diff) + b\n    }\n    var result\
    \ = \"\"\n    for i in 0..<a.count {\n        let a_char = Array(a)[i]\n     \
    \   let b_char = Array(b)[i]\n        let a_int = Int(String(a_char)) ?? 0\n \
    \       let b_int = Int(String(b_char)) ?? 0\n        result += String(a_int ^\
    \ b_int)\n    }\n    return result\n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(string_xor(a: \"111000\", b: \"101010\") == \"010010\")\nassert(string_xor(a:\
    \ \"1\", b: \"1\") == \"0\")\nassert(string_xor(a: \"0101\", b: \"0000\") == \"\
    0101\")"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659978479
- exit_code: 1
  program: "\n/// Input are two strings a and b consisting only of 1s and 0s.\n///\
    \ Perform binary XOR on these inputs and return result also as a string.\n///\
    \ >>> string_xor(a: \"010\", b: \"110\")\n/// \"100\"\nfunc string_xor(a: String,\
    \ b: String) -> String {\n    var result = \"\"\n    for i in 0..<a.count {\n\
    \        result += a[i] == b[i] ? \"0\" : \"1\"\n    }\n    return result\n}\n\
    \n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(string_xor(a: \"111000\", b: \"101010\") == \"\
    010010\")\nassert(string_xor(a: \"1\", b: \"1\") == \"0\")\nassert(string_xor(a:\
    \ \"0101\", b: \"0000\") == \"0101\")"
  status: SyntaxError
  stderr: "/tmp/tmpiw2x8zpn.swift:9:19: error: 'subscript(_:)' is unavailable: cannot\
    \ subscript String with an Int, use a String.Index instead.\n        result +=\
    \ a[i] == b[i] ? \"0\" : \"1\"\n                  ^~~~\nSwift.String:3:12: note:\
    \ 'subscript(_:)' has been explicitly marked unavailable here\n    public subscript(i:\
    \ Int) -> Character { get }\n           ^\n/tmp/tmpiw2x8zpn.swift:9:27: error:\
    \ 'subscript(_:)' is unavailable: cannot subscript String with an Int, use a String.Index\
    \ instead.\n        result += a[i] == b[i] ? \"0\" : \"1\"\n                 \
    \         ^~~~\nSwift.String:3:12: note: 'subscript(_:)' has been explicitly marked\
    \ unavailable here\n    public subscript(i: Int) -> Character { get }\n      \
    \     ^\n"
  stdout: ''
  timestamp: 1659978479
- exit_code: 1
  program: "\n/// Input are two strings a and b consisting only of 1s and 0s.\n///\
    \ Perform binary XOR on these inputs and return result also as a string.\n///\
    \ >>> string_xor(a: \"010\", b: \"110\")\n/// \"100\"\nfunc string_xor(a: String,\
    \ b: String) -> String {\n    return a.binaryXor(b).binaryString\n}\n\n\nfunc\
    \ ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count !=\
    \ right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(string_xor(a: \"111000\", b: \"101010\") == \"\
    010010\")\nassert(string_xor(a: \"1\", b: \"1\") == \"0\")\nassert(string_xor(a:\
    \ \"0101\", b: \"0000\") == \"0101\")"
  status: SyntaxError
  stderr: "/tmp/tmp0yd690wj.swift:7:14: error: value of type 'String' has no member\
    \ 'binaryXor'\n    return a.binaryXor(b).binaryString\n           ~ ^~~~~~~~~\n"
  stdout: ''
  timestamp: 1659978479
- exit_code: 1
  program: "\n/// Input are two strings a and b consisting only of 1s and 0s.\n///\
    \ Perform binary XOR on these inputs and return result also as a string.\n///\
    \ >>> string_xor(a: \"010\", b: \"110\")\n/// \"100\"\nfunc string_xor(a: String,\
    \ b: String) -> String {\n    if (a.characters.count != b.characters.count) {\n\
    \        return \"\"\n    }\n    var result = String()\n    for index in 0..<a.characters.count\
    \ {\n        let a_char = a[a.index(a.startIndex, offsetBy: index)]\n        let\
    \ b_char = b[b.index(b.startIndex, offsetBy: index)]\n        result.append(a_char\
    \ == b_char ? \"0\" : \"1\")\n    }\n    return result\n}\n\n\nfunc ==(left: [(Int,\
    \ Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n\
    \        return false\n    }\n    for (l, r) in zip(left, right) {\n        if\
    \ l != r {\n            return false\n        }\n    }\n    return true\n}\n \
    \           \nassert(string_xor(a: \"111000\", b: \"101010\") == \"010010\")\n\
    assert(string_xor(a: \"1\", b: \"1\") == \"0\")\nassert(string_xor(a: \"0101\"\
    , b: \"0000\") == \"0101\")"
  status: SyntaxError
  stderr: "/tmp/tmpojp4n_2v.swift:7:11: error: 'characters' is unavailable: Please\
    \ use String directly\n    if (a.characters.count != b.characters.count) {\n \
    \         ^~~~~~~~~~\nSwift.String:5:16: note: 'characters' was obsoleted in Swift\
    \ 5.0\n    public var characters: String { get set }\n               ^\n/tmp/tmpojp4n_2v.swift:7:33:\
    \ error: 'characters' is unavailable: Please use String directly\n    if (a.characters.count\
    \ != b.characters.count) {\n                                ^~~~~~~~~~\nSwift.String:5:16:\
    \ note: 'characters' was obsoleted in Swift 5.0\n    public var characters: String\
    \ { get set }\n               ^\n/tmp/tmpojp4n_2v.swift:11:24: error: 'characters'\
    \ is unavailable: Please use String directly\n    for index in 0..<a.characters.count\
    \ {\n                       ^~~~~~~~~~\nSwift.String:5:16: note: 'characters'\
    \ was obsoleted in Swift 5.0\n    public var characters: String { get set }\n\
    \               ^\n"
  stdout: ''
  timestamp: 1659978479
- exit_code: 1
  program: "\n/// Input are two strings a and b consisting only of 1s and 0s.\n///\
    \ Perform binary XOR on these inputs and return result also as a string.\n///\
    \ >>> string_xor(a: \"010\", b: \"110\")\n/// \"100\"\nfunc string_xor(a: String,\
    \ b: String) -> String {\n    var result = String()\n    for (var i = 0; i < a.characters.count;\
    \ i++) {\n        result.append(a[i] == b[i] ? \"0\" : \"1\")\n    }\n    return\
    \ result\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n\
    \    if left.count != right.count {\n        return false\n    }\n    for (l,\
    \ r) in zip(left, right) {\n        if l != r {\n            return false\n  \
    \      }\n    }\n    return true\n}\n            \nassert(string_xor(a: \"111000\"\
    , b: \"101010\") == \"010010\")\nassert(string_xor(a: \"1\", b: \"1\") == \"0\"\
    )\nassert(string_xor(a: \"0101\", b: \"0000\") == \"0101\")"
  status: SyntaxError
  stderr: "/tmp/tmpyxtmvekj.swift:8:5: error: C-style for statement has been removed\
    \ in Swift 3\n    for (var i = 0; i < a.characters.count; i++) {\n    ^   ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n"
  stdout: ''
  timestamp: 1659978479
- exit_code: 1
  program: "\n/// Input are two strings a and b consisting only of 1s and 0s.\n///\
    \ Perform binary XOR on these inputs and return result also as a string.\n///\
    \ >>> string_xor(a: \"010\", b: \"110\")\n/// \"100\"\nfunc string_xor(a: String,\
    \ b: String) -> String {\n    var result = \"\"\n    var i = 0\n    while i <\
    \ a.count && i < b.count {\n        if a[i] == b[i] {\n            result += \"\
    0\"\n        } else {\n            result += \"1\"\n        }\n        i += 1\n\
    \    }\n    return result\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(string_xor(a:\
    \ \"111000\", b: \"101010\") == \"010010\")\nassert(string_xor(a: \"1\", b: \"\
    1\") == \"0\")\nassert(string_xor(a: \"0101\", b: \"0000\") == \"0101\")"
  status: SyntaxError
  stderr: "/tmp/tmpizyh3vxx.swift:10:12: error: 'subscript(_:)' is unavailable: cannot\
    \ subscript String with an Int, use a String.Index instead.\n        if a[i] ==\
    \ b[i] {\n           ^~~~\nSwift.String:3:12: note: 'subscript(_:)' has been explicitly\
    \ marked unavailable here\n    public subscript(i: Int) -> Character { get }\n\
    \           ^\n/tmp/tmpizyh3vxx.swift:10:20: error: 'subscript(_:)' is unavailable:\
    \ cannot subscript String with an Int, use a String.Index instead.\n        if\
    \ a[i] == b[i] {\n                   ^~~~\nSwift.String:3:12: note: 'subscript(_:)'\
    \ has been explicitly marked unavailable here\n    public subscript(i: Int) ->\
    \ Character { get }\n           ^\n"
  stdout: ''
  timestamp: 1659978479
- exit_code: 0
  program: "\n/// Input are two strings a and b consisting only of 1s and 0s.\n///\
    \ Perform binary XOR on these inputs and return result also as a string.\n///\
    \ >>> string_xor(a: \"010\", b: \"110\")\n/// \"100\"\nfunc string_xor(a: String,\
    \ b: String) -> String {\n    if a.count != b.count {\n        return \"invalid\
    \ arguments\"\n    }\n    var result = \"\"\n    for i in 0..<a.count {\n    \
    \    let a_char = a[a.index(a.startIndex, offsetBy: i)]\n        let b_char =\
    \ b[b.index(b.startIndex, offsetBy: i)]\n        if a_char == b_char {\n     \
    \       result += \"0\"\n        } else {\n            result += \"1\"\n     \
    \   }\n    }\n    return result\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int,\
    \ Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n\
    \    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n          \
    \  return false\n        }\n    }\n    return true\n}\n            \nassert(string_xor(a:\
    \ \"111000\", b: \"101010\") == \"010010\")\nassert(string_xor(a: \"1\", b: \"\
    1\") == \"0\")\nassert(string_xor(a: \"0101\", b: \"0000\") == \"0101\")"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659978479
- exit_code: 1
  program: "\n/// Input are two strings a and b consisting only of 1s and 0s.\n///\
    \ Perform binary XOR on these inputs and return result also as a string.\n///\
    \ >>> string_xor(a: \"010\", b: \"110\")\n/// \"100\"\nfunc string_xor(a: String,\
    \ b: String) -> String {\n    var x = \"\"\n    for (i, ch) in a.characters.enumerated()\
    \ {\n        let ai = ch\n        let bi = b[b.index(b.startIndex, offsetBy: i)]\n\
    \        x.append(ai == bi ? \"0\" : \"1\")\n    }\n    return x\n}\n\n\nfunc\
    \ ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count !=\
    \ right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(string_xor(a: \"111000\", b: \"101010\") == \"\
    010010\")\nassert(string_xor(a: \"1\", b: \"1\") == \"0\")\nassert(string_xor(a:\
    \ \"0101\", b: \"0000\") == \"0101\")"
  status: SyntaxError
  stderr: "/tmp/tmp8sgz872h.swift:8:22: error: 'characters' is unavailable: Please\
    \ use String directly\n    for (i, ch) in a.characters.enumerated() {\n      \
    \               ^~~~~~~~~~\nSwift.String:5:16: note: 'characters' was obsoleted\
    \ in Swift 5.0\n    public var characters: String { get set }\n              \
    \ ^\n"
  stdout: ''
  timestamp: 1659978479
- exit_code: 1
  program: "\n/// Input are two strings a and b consisting only of 1s and 0s.\n///\
    \ Perform binary XOR on these inputs and return result also as a string.\n///\
    \ >>> string_xor(a: \"010\", b: \"110\")\n/// \"100\"\nfunc string_xor(a: String,\
    \ b: String) -> String {\n    if let a1 = a.int8(), let b1 = b.int8() {\n    \
    \    return (a1 ^ b1).hex()\n    }\n    return \"ERROR\"\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(string_xor(a: \"111000\", b: \"101010\") == \"010010\"\
    )\nassert(string_xor(a: \"1\", b: \"1\") == \"0\")\nassert(string_xor(a: \"0101\"\
    , b: \"0000\") == \"0101\")"
  status: SyntaxError
  stderr: "/tmp/tmpssju4vti.swift:7:19: error: value of type 'String' has no member\
    \ 'int8'\n    if let a1 = a.int8(), let b1 = b.int8() {\n                ~ ^~~~\n\
    /tmp/tmpssju4vti.swift:7:38: error: value of type 'String' has no member 'int8'\n\
    \    if let a1 = a.int8(), let b1 = b.int8() {\n                             \
    \      ~ ^~~~\n/tmp/tmpssju4vti.swift:8:26: error: value of type 'UInt8' has no\
    \ member 'hex'\n        return (a1 ^ b1).hex()\n               ~~~~~~~~~ ^~~\n"
  stdout: ''
  timestamp: 1659978479
- exit_code: 0
  program: "\n/// Input are two strings a and b consisting only of 1s and 0s.\n///\
    \ Perform binary XOR on these inputs and return result also as a string.\n///\
    \ >>> string_xor(a: \"010\", b: \"110\")\n/// \"100\"\nfunc string_xor(a: String,\
    \ b: String) -> String {\n    var c = \"\"\n    let aArr = a.utf8.map { Int($0)\
    \ }\n    let bArr = b.utf8.map { Int($0) }\n    for i in 0..<max(aArr.count, bArr.count)\
    \ {\n        let x = i < aArr.count ? aArr[i] : 0\n        let y = i < bArr.count\
    \ ? bArr[i] : 0\n        let z = (x + y) % 2\n        c += String(z)\n    }\n\
    \    return c\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool\
    \ {\n    if left.count != right.count {\n        return false\n    }\n    for\
    \ (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(string_xor(a: \"111000\"\
    , b: \"101010\") == \"010010\")\nassert(string_xor(a: \"1\", b: \"1\") == \"0\"\
    )\nassert(string_xor(a: \"0101\", b: \"0000\") == \"0101\")"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659978479
- exit_code: 1
  program: "\n/// Input are two strings a and b consisting only of 1s and 0s.\n///\
    \ Perform binary XOR on these inputs and return result also as a string.\n///\
    \ >>> string_xor(a: \"010\", b: \"110\")\n/// \"100\"\nfunc string_xor(a: String,\
    \ b: String) -> String {\n    return String(repeating: \" \", count: a.count).map\
    \ { $0 }\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n\
    \    if left.count != right.count {\n        return false\n    }\n    for (l,\
    \ r) in zip(left, right) {\n        if l != r {\n            return false\n  \
    \      }\n    }\n    return true\n}\n            \nassert(string_xor(a: \"111000\"\
    , b: \"101010\") == \"010010\")\nassert(string_xor(a: \"1\", b: \"1\") == \"0\"\
    )\nassert(string_xor(a: \"0101\", b: \"0000\") == \"0101\")"
  status: SyntaxError
  stderr: "/tmp/tmpfzfvjbb7.swift:7:51: error: cannot convert return expression of\
    \ type '[String.Element]' (aka 'Array<Character>') to return type 'String'\n \
    \   return String(repeating: \" \", count: a.count).map { $0 }\n           ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~^~~~~~~~~~\n"
  stdout: ''
  timestamp: 1659978479
- exit_code: 1
  program: "\n/// Input are two strings a and b consisting only of 1s and 0s.\n///\
    \ Perform binary XOR on these inputs and return result also as a string.\n///\
    \ >>> string_xor(a: \"010\", b: \"110\")\n/// \"100\"\nfunc string_xor(a: String,\
    \ b: String) -> String {\n    let a = a.utf8.map { UInt8(bitPattern: $0) }\n \
    \   let b = b.utf8.map { UInt8(bitPattern: $0) }\n    var xor = \"\"\n    for\
    \ i in 0..<max(a.count, b.count) {\n        if i < a.count && i < b.count {\n\
    \            xor += String(a[i] ^ b[i], radix: 2)\n        } else if i < a.count\
    \ {\n            xor += String(a[i], radix: 2)\n        } else {\n           \
    \ xor += String(b[i], radix: 2)\n        }\n    }\n    return xor\n}\n\n\nfunc\
    \ ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count !=\
    \ right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(string_xor(a: \"111000\", b: \"101010\") == \"\
    010010\")\nassert(string_xor(a: \"1\", b: \"1\") == \"0\")\nassert(string_xor(a:\
    \ \"0101\", b: \"0000\") == \"0101\")"
  status: SyntaxError
  stderr: "/tmp/tmppzqdzs43.swift:7:44: error: cannot convert value of type 'String.UTF8View.Element'\
    \ (aka 'UInt8') to expected argument type 'Int8'\n    let a = a.utf8.map { UInt8(bitPattern:\
    \ $0) }\n                                           ^\n                      \
    \                     Int8( )\n/tmp/tmppzqdzs43.swift:8:44: error: cannot convert\
    \ value of type 'String.UTF8View.Element' (aka 'UInt8') to expected argument type\
    \ 'Int8'\n    let b = b.utf8.map { UInt8(bitPattern: $0) }\n                 \
    \                          ^\n                                           Int8(\
    \ )\n"
  stdout: ''
  timestamp: 1659978479
- exit_code: 0
  program: "\n/// Input are two strings a and b consisting only of 1s and 0s.\n///\
    \ Perform binary XOR on these inputs and return result also as a string.\n///\
    \ >>> string_xor(a: \"010\", b: \"110\")\n/// \"100\"\nfunc string_xor(a: String,\
    \ b: String) -> String {\n    if a.count != b.count { return \"\" }\n    let arrA\
    \ = Array(a)\n    let arrB = Array(b)\n    var result = \"\"\n    for i in 0..<a.count\
    \ {\n        result += \"\\(Int(String(arrA[i]))! ^ Int(String(arrB[i]))!)\"\n\
    \    }\n    return result\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(string_xor(a:\
    \ \"111000\", b: \"101010\") == \"010010\")\nassert(string_xor(a: \"1\", b: \"\
    1\") == \"0\")\nassert(string_xor(a: \"0101\", b: \"0000\") == \"0101\")"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659978479
- exit_code: 1
  program: "\n/// Input are two strings a and b consisting only of 1s and 0s.\n///\
    \ Perform binary XOR on these inputs and return result also as a string.\n///\
    \ >>> string_xor(a: \"010\", b: \"110\")\n/// \"100\"\nfunc string_xor(a: String,\
    \ b: String) -> String {\n    let a = a.unicodeScalars.map { Int(bitPattern: $0.value)\
    \ }\n    let b = b.unicodeScalars.map { Int(bitPattern: $0.value) }\n    var c\
    \ = [Int]()\n    for i in 0..<min(a.count, b.count) {\n        c.append(a[i] ^\
    \ b[i])\n    }\n    return String(c.map { Character(UnicodeScalar(bitPattern:\
    \ $0)!) })\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n\
    \    if left.count != right.count {\n        return false\n    }\n    for (l,\
    \ r) in zip(left, right) {\n        if l != r {\n            return false\n  \
    \      }\n    }\n    return true\n}\n            \nassert(string_xor(a: \"111000\"\
    , b: \"101010\") == \"010010\")\nassert(string_xor(a: \"1\", b: \"1\") == \"0\"\
    )\nassert(string_xor(a: \"0101\", b: \"0000\") == \"0101\")"
  status: SyntaxError
  stderr: "/tmp/tmpxmhf6pi4.swift:7:36: error: no exact matches in call to initializer\
    \ \n    let a = a.unicodeScalars.map { Int(bitPattern: $0.value) }\n         \
    \                          ^\nSwift.Int:5:12: note: candidate expects value of\
    \ type 'UInt' for parameter #1 (got 'UInt32')\n    public init(bitPattern x: UInt)\n\
    \           ^\nSwift.Int:2:23: note: candidate expects value of type 'ObjectIdentifier'\
    \ for parameter #1 (got 'UInt32')\n    @inlinable public init(bitPattern objectID:\
    \ ObjectIdentifier)\n                      ^\n/tmp/tmpxmhf6pi4.swift:8:36: error:\
    \ no exact matches in call to initializer \n    let b = b.unicodeScalars.map {\
    \ Int(bitPattern: $0.value) }\n                                   ^\nSwift.Int:5:12:\
    \ note: candidate expects value of type 'UInt' for parameter #1 (got 'UInt32')\n\
    \    public init(bitPattern x: UInt)\n           ^\nSwift.Int:2:23: note: candidate\
    \ expects value of type 'ObjectIdentifier' for parameter #1 (got 'UInt32')\n \
    \   @inlinable public init(bitPattern objectID: ObjectIdentifier)\n          \
    \            ^\n/tmp/tmpxmhf6pi4.swift:13:50: error: extraneous argument label\
    \ 'bitPattern:' in call\n    return String(c.map { Character(UnicodeScalar(bitPattern:\
    \ $0)!) })\n                                                 ^~~~~~~~~~~~~\n \
    \                                                 \n"
  stdout: ''
  timestamp: 1659978479
- exit_code: 1
  program: "\n/// Input are two strings a and b consisting only of 1s and 0s.\n///\
    \ Perform binary XOR on these inputs and return result also as a string.\n///\
    \ >>> string_xor(a: \"010\", b: \"110\")\n/// \"100\"\nfunc string_xor(a: String,\
    \ b: String) -> String {\n    let asciiA = a.unicodeScalars.map { $0.value }\n\
    \    let asciiB = b.unicodeScalars.map { $0.value }\n    let result = zip(asciiA,\
    \ asciiB).map { $0.0 ^ $0.1 }\n    return String(bytes: result, encoding: String.Encoding.ascii)!\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(string_xor(a: \"111000\", b: \"101010\") == \"\
    010010\")\nassert(string_xor(a: \"1\", b: \"1\") == \"0\")\nassert(string_xor(a:\
    \ \"0101\", b: \"0000\") == \"0101\")"
  status: SyntaxError
  stderr: "/tmp/tmpa6c8ujiz.swift:10:12: error: no exact matches in call to initializer\
    \ \n    return String(bytes: result, encoding: String.Encoding.ascii)!\n     \
    \      ^\n/tmp/tmpa6c8ujiz.swift:10:12: note: found candidate with type '([UInt32])\
    \ -> String'\n    return String(bytes: result, encoding: String.Encoding.ascii)!\n\
    \           ^\n/tmp/tmpa6c8ujiz.swift:10:12: note: found candidate with type '(Substring.UTF8View)\
    \ -> String?'\n    return String(bytes: result, encoding: String.Encoding.ascii)!\n\
    \           ^\n/tmp/tmpa6c8ujiz.swift:10:12: note: found candidate with type '(Substring.UTF16View)\
    \ -> String?'\n    return String(bytes: result, encoding: String.Encoding.ascii)!\n\
    \           ^\n/tmp/tmpa6c8ujiz.swift:10:51: error: type 'String' has no member\
    \ 'Encoding'\n    return String(bytes: result, encoding: String.Encoding.ascii)!\n\
    \                                           ~~~~~~ ^~~~~~~~\n"
  stdout: ''
  timestamp: 1659978479
- exit_code: 1
  program: "\n/// Input are two strings a and b consisting only of 1s and 0s.\n///\
    \ Perform binary XOR on these inputs and return result also as a string.\n///\
    \ >>> string_xor(a: \"010\", b: \"110\")\n/// \"100\"\nfunc string_xor(a: String,\
    \ b: String) -> String {\n    var chars = zip(a, b).map{ $0 == $1 ? \"0\" : \"\
    1\" }\n    return String(chars)\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int,\
    \ Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n\
    \    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n          \
    \  return false\n        }\n    }\n    return true\n}\n            \nassert(string_xor(a:\
    \ \"111000\", b: \"101010\") == \"010010\")\nassert(string_xor(a: \"1\", b: \"\
    1\") == \"0\")\nassert(string_xor(a: \"0101\", b: \"0000\") == \"0101\")"
  status: SyntaxError
  stderr: "/tmp/tmpvjf2w1tf.swift:8:12: error: no exact matches in call to initializer\
    \ \n    return String(chars)\n           ^\nSwift.String:4:12: note: candidate\
    \ requires that the types 'String' and 'Character' be equivalent (requirement\
    \ specified as 'S.Element' == 'Character')\n    public init<S>(_ characters: S)\
    \ where S : Sequence, S.Element == Character\n           ^\nSwift.RangeReplaceableCollection:3:23:\
    \ note: candidate requires that the types 'String.Element' (aka 'Character') and\
    \ 'String' be equivalent (requirement specified as 'Self.Element' == 'S.Element')\n\
    \    @inlinable public init<S>(_ elements: S) where S : Sequence, Self.Element\
    \ == S.Element\n                      ^\nSwift.String:2:12: note: incorrect labels\
    \ for candidate (have: '(_:)', expected: '(describing:)')\n    public init<Subject>(describing\
    \ instance: Subject)\n           ^\nSwift.String:3:23: note: incorrect labels\
    \ for candidate (have: '(_:)', expected: '(describing:)')\n    @inlinable public\
    \ init<Subject>(describing instance: Subject) where Subject : CustomStringConvertible\n\
    \                      ^\nSwift.String:6:12: note: incorrect labels for candidate\
    \ (have: '(_:)', expected: '(reflecting:)')\n    public init<Subject>(reflecting\
    \ subject: Subject)\n           ^\n"
  stdout: ''
  timestamp: 1659978479
- exit_code: 1
  program: "\n/// Input are two strings a and b consisting only of 1s and 0s.\n///\
    \ Perform binary XOR on these inputs and return result also as a string.\n///\
    \ >>> string_xor(a: \"010\", b: \"110\")\n/// \"100\"\nfunc string_xor(a: String,\
    \ b: String) -> String {\n    return a.string_xor(b)\n}\n\n\nfunc ==(left: [(Int,\
    \ Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n\
    \        return false\n    }\n    for (l, r) in zip(left, right) {\n        if\
    \ l != r {\n            return false\n        }\n    }\n    return true\n}\n \
    \           \nassert(string_xor(a: \"111000\", b: \"101010\") == \"010010\")\n\
    assert(string_xor(a: \"1\", b: \"1\") == \"0\")\nassert(string_xor(a: \"0101\"\
    , b: \"0000\") == \"0101\")"
  status: SyntaxError
  stderr: "/tmp/tmpndeqp5y_.swift:7:14: error: value of type 'String' has no member\
    \ 'string_xor'\n    return a.string_xor(b)\n           ~ ^~~~~~~~~~\n"
  stdout: ''
  timestamp: 1659978479
- exit_code: 0
  program: "\n/// Input are two strings a and b consisting only of 1s and 0s.\n///\
    \ Perform binary XOR on these inputs and return result also as a string.\n///\
    \ >>> string_xor(a: \"010\", b: \"110\")\n/// \"100\"\nfunc string_xor(a: String,\
    \ b: String) -> String {\n    var ret = \"\"\n    var i = 0\n    while i < a.count\
    \ {\n        let a_i = Int(String(a[a.index(a.startIndex, offsetBy: i)]))!\n \
    \       let b_i = Int(String(b[b.index(b.startIndex, offsetBy: i)]))!\n      \
    \  ret += String(a_i ^ b_i)\n        i += 1\n    }\n    return ret\n}\n\n\nfunc\
    \ ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count !=\
    \ right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(string_xor(a: \"111000\", b: \"101010\") == \"\
    010010\")\nassert(string_xor(a: \"1\", b: \"1\") == \"0\")\nassert(string_xor(a:\
    \ \"0101\", b: \"0000\") == \"0101\")"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659978479
- exit_code: 0
  program: "\n/// Input are two strings a and b consisting only of 1s and 0s.\n///\
    \ Perform binary XOR on these inputs and return result also as a string.\n///\
    \ >>> string_xor(a: \"010\", b: \"110\")\n/// \"100\"\nfunc string_xor(a: String,\
    \ b: String) -> String {\n    var xorResult = \"\"\n    var a = a\n    var b =\
    \ b\n    while a.count > 0 || b.count > 0 {\n        if a.count > 0 {\n      \
    \      let charA = a.removeFirst()\n            if b.count > 0 {\n           \
    \     let charB = b.removeFirst()\n                if charA == charB {\n     \
    \               xorResult.append(\"0\")\n                } else {\n          \
    \          xorResult.append(\"1\")\n                }\n            } else {\n\
    \                xorResult.append(charA)\n            }\n        } else {\n  \
    \          let charB = b.removeFirst()\n            xorResult.append(charB)\n\
    \        }\n    }\n    return xorResult\n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(string_xor(a: \"111000\", b: \"101010\") == \"010010\")\nassert(string_xor(a:\
    \ \"1\", b: \"1\") == \"0\")\nassert(string_xor(a: \"0101\", b: \"0000\") == \"\
    0101\")"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659978479
- exit_code: 1
  program: "\n/// Input are two strings a and b consisting only of 1s and 0s.\n///\
    \ Perform binary XOR on these inputs and return result also as a string.\n///\
    \ >>> string_xor(a: \"010\", b: \"110\")\n/// \"100\"\nfunc string_xor(a: String,\
    \ b: String) -> String {\n    let a = Array(a.utf8)\n    let b = Array(b.utf8)\n\
    \    let n = a.count\n    var res = [UInt8]()\n    for i in 0..<n {\n        res.append(a[i]\
    \ ^ b[i])\n    }\n    return String(bytes: res, encoding: .utf8)!\n}\n\n\nfunc\
    \ ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count !=\
    \ right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(string_xor(a: \"111000\", b: \"101010\") == \"\
    010010\")\nassert(string_xor(a: \"1\", b: \"1\") == \"0\")\nassert(string_xor(a:\
    \ \"0101\", b: \"0000\") == \"0101\")"
  status: SyntaxError
  stderr: "/tmp/tmp6jk08nbw.swift:14:12: error: no exact matches in call to initializer\
    \ \n    return String(bytes: res, encoding: .utf8)!\n           ^\n/tmp/tmp6jk08nbw.swift:14:12:\
    \ note: found candidate with type '(Array<_>, _.Type) -> String'\n    return String(bytes:\
    \ res, encoding: .utf8)!\n           ^\n/tmp/tmp6jk08nbw.swift:14:12: note: found\
    \ candidate with type '([UInt8]) -> String'\n    return String(bytes: res, encoding:\
    \ .utf8)!\n           ^\n/tmp/tmp6jk08nbw.swift:14:12: note: found candidate with\
    \ type '(Substring.UTF8View) -> String?'\n    return String(bytes: res, encoding:\
    \ .utf8)!\n           ^\n/tmp/tmp6jk08nbw.swift:14:12: note: found candidate with\
    \ type '(Substring.UTF16View) -> String?'\n    return String(bytes: res, encoding:\
    \ .utf8)!\n           ^\n"
  stdout: ''
  timestamp: 1659978479
- exit_code: -4
  program: "\n/// Input are two strings a and b consisting only of 1s and 0s.\n///\
    \ Perform binary XOR on these inputs and return result also as a string.\n///\
    \ >>> string_xor(a: \"010\", b: \"110\")\n/// \"100\"\nfunc string_xor(a: String,\
    \ b: String) -> String {\n    // TODO: Implement this function.\n    // In case\
    \ of invalid input, return empty string.\n    return \"\"\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(string_xor(a: \"111000\", b: \"101010\") == \"010010\"\
    )\nassert(string_xor(a: \"1\", b: \"1\") == \"0\")\nassert(string_xor(a: \"0101\"\
    , b: \"0000\") == \"0101\")"
  status: Exception
  stderr: 'tmp634he7dk/tmp634he7dk.swift:25: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b7a4115dc80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b7a40e54b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b7a40e54988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b7a40e537b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmp634he7dk                        0x0000556e845d233b <unavailable> + 4923

    5    libc.so.6                          0x00002b7a41349460 __libc_start_main +
    245

    6    tmp634he7dk                        0x0000556e845d1f49 <unavailable> + 3913

    '
  stdout: ''
  timestamp: 1659978479
- exit_code: 1
  program: "\n/// Input are two strings a and b consisting only of 1s and 0s.\n///\
    \ Perform binary XOR on these inputs and return result also as a string.\n///\
    \ >>> string_xor(a: \"010\", b: \"110\")\n/// \"100\"\nfunc string_xor(a: String,\
    \ b: String) -> String {\n    return String(zip(a, b).map(^))\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(string_xor(a: \"111000\", b: \"101010\") == \"010010\"\
    )\nassert(string_xor(a: \"1\", b: \"1\") == \"0\")\nassert(string_xor(a: \"0101\"\
    , b: \"0000\") == \"0101\")"
  status: SyntaxError
  stderr: "/tmp/tmp5qiefeh9.swift:7:33: error: no exact matches in reference to operator\
    \ function '^'\n    return String(zip(a, b).map(^))\n                        \
    \        ^\nSwift.BinaryInteger:1:17: note: candidate requires that 'String.Element'\
    \ (aka 'Character') conform to 'BinaryInteger' (requirement specified as 'Self'\
    \ : 'BinaryInteger')\npublic protocol BinaryInteger : CustomStringConvertible,\
    \ Hashable, Numeric, Strideable where Self.Magnitude : BinaryInteger, Self.Magnitude\
    \ == Self.Magnitude.Magnitude {\n                ^\nSwift.BinaryInteger:1:11:\
    \ note: candidate requires that 'String.Element' (aka 'Character') conform to\
    \ 'BinaryInteger' (requirement specified as 'Self' : 'BinaryInteger')\nextension\
    \ BinaryInteger {\n          ^\nSwift.SIMD:1:11: note: candidate requires that\
    \ 'String.Element' (aka 'Character') conform to 'SIMD' (requirement specified\
    \ as 'Self' : 'SIMD')\nextension SIMD where Self.Scalar : FixedWidthInteger {\n\
    \          ^\n"
  stdout: ''
  timestamp: 1659978479
- exit_code: 1
  program: "\n/// Input are two strings a and b consisting only of 1s and 0s.\n///\
    \ Perform binary XOR on these inputs and return result also as a string.\n///\
    \ >>> string_xor(a: \"010\", b: \"110\")\n/// \"100\"\nfunc string_xor(a: String,\
    \ b: String) -> String {\n\tlet a: UInt8 = UInt8(strtoul(a, nil, 2))\n\tlet b:\
    \ UInt8 = UInt8(strtoul(b, nil, 2))\n\tlet result: UInt8 = a ^ b\n\treturn String(result,\
    \ radix: 2)\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n\
    \    if left.count != right.count {\n        return false\n    }\n    for (l,\
    \ r) in zip(left, right) {\n        if l != r {\n            return false\n  \
    \      }\n    }\n    return true\n}\n            \nassert(string_xor(a: \"111000\"\
    , b: \"101010\") == \"010010\")\nassert(string_xor(a: \"1\", b: \"1\") == \"0\"\
    )\nassert(string_xor(a: \"0101\", b: \"0000\") == \"0101\")"
  status: SyntaxError
  stderr: "/tmp/tmprdr_qhs7.swift:7:23: error: cannot find 'strtoul' in scope\n  \
    \      let a: UInt8 = UInt8(strtoul(a, nil, 2))\n                            \
    \ ^~~~~~~\n/tmp/tmprdr_qhs7.swift:7:34: error: 'nil' requires a contextual type\n\
    \        let a: UInt8 = UInt8(strtoul(a, nil, 2))\n                          \
    \              ^\n/tmp/tmprdr_qhs7.swift:8:23: error: cannot find 'strtoul' in\
    \ scope\n        let b: UInt8 = UInt8(strtoul(b, nil, 2))\n                  \
    \           ^~~~~~~\n/tmp/tmprdr_qhs7.swift:8:34: error: 'nil' requires a contextual\
    \ type\n        let b: UInt8 = UInt8(strtoul(b, nil, 2))\n                   \
    \                     ^\n"
  stdout: ''
  timestamp: 1659978479
- exit_code: 0
  program: "\n/// Input are two strings a and b consisting only of 1s and 0s.\n///\
    \ Perform binary XOR on these inputs and return result also as a string.\n///\
    \ >>> string_xor(a: \"010\", b: \"110\")\n/// \"100\"\nfunc string_xor(a: String,\
    \ b: String) -> String {\n    return String(zip(a, b).map { $0.0 != $0.1 ? \"\
    1\" : \"0\" })\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool\
    \ {\n    if left.count != right.count {\n        return false\n    }\n    for\
    \ (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(string_xor(a: \"111000\"\
    , b: \"101010\") == \"010010\")\nassert(string_xor(a: \"1\", b: \"1\") == \"0\"\
    )\nassert(string_xor(a: \"0101\", b: \"0000\") == \"0101\")"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659978479
- exit_code: 1
  program: "\n/// Input are two strings a and b consisting only of 1s and 0s.\n///\
    \ Perform binary XOR on these inputs and return result also as a string.\n///\
    \ >>> string_xor(a: \"010\", b: \"110\")\n/// \"100\"\nfunc string_xor(a: String,\
    \ b: String) -> String {\n    var xor = \"\"\n    for i in 0..<a.characters.count\
    \ {\n        let str1 = a.substring(with: a.index(a.startIndex, offsetBy: i)..<a.index(a.startIndex,\
    \ offsetBy: i+1))\n        let str2 = b.substring(with: b.index(b.startIndex,\
    \ offsetBy: i)..<b.index(b.startIndex, offsetBy: i+1))\n        let s = str1 ^\
    \ str2\n        xor.append(s)\n    }\n    return xor\n}\n\n\nfunc ==(left: [(Int,\
    \ Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n\
    \        return false\n    }\n    for (l, r) in zip(left, right) {\n        if\
    \ l != r {\n            return false\n        }\n    }\n    return true\n}\n \
    \           \nassert(string_xor(a: \"111000\", b: \"101010\") == \"010010\")\n\
    assert(string_xor(a: \"1\", b: \"1\") == \"0\")\nassert(string_xor(a: \"0101\"\
    , b: \"0000\") == \"0101\")"
  status: SyntaxError
  stderr: "/tmp/tmp2u1vb5of.swift:8:20: error: 'characters' is unavailable: Please\
    \ use String directly\n    for i in 0..<a.characters.count {\n               \
    \    ^~~~~~~~~~\nSwift.String:5:16: note: 'characters' was obsoleted in Swift\
    \ 5.0\n    public var characters: String { get set }\n               ^\n/tmp/tmp2u1vb5of.swift:9:22:\
    \ error: value of type 'String' has no member 'substring'\n        let str1 =\
    \ a.substring(with: a.index(a.startIndex, offsetBy: i)..<a.index(a.startIndex,\
    \ offsetBy: i+1))\n                   ~ ^~~~~~~~~\n/tmp/tmp2u1vb5of.swift:10:22:\
    \ error: value of type 'String' has no member 'substring'\n        let str2 =\
    \ b.substring(with: b.index(b.startIndex, offsetBy: i)..<b.index(b.startIndex,\
    \ offsetBy: i+1))\n                   ~ ^~~~~~~~~\n"
  stdout: ''
  timestamp: 1659978479
- exit_code: 1
  program: "\n/// Input are two strings a and b consisting only of 1s and 0s.\n///\
    \ Perform binary XOR on these inputs and return result also as a string.\n///\
    \ >>> string_xor(a: \"010\", b: \"110\")\n/// \"100\"\nfunc string_xor(a: String,\
    \ b: String) -> String {\n    var r = String()\n    for i in 0..<a.characters.count\
    \ {\n        if a[i] == b[i] {\n            r.append(\"0\")\n        } else {\n\
    \            r.append(\"1\")\n        }\n    }\n    return r\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(string_xor(a: \"111000\", b: \"101010\") == \"010010\"\
    )\nassert(string_xor(a: \"1\", b: \"1\") == \"0\")\nassert(string_xor(a: \"0101\"\
    , b: \"0000\") == \"0101\")"
  status: SyntaxError
  stderr: "/tmp/tmpltg6jcop.swift:8:20: error: 'characters' is unavailable: Please\
    \ use String directly\n    for i in 0..<a.characters.count {\n               \
    \    ^~~~~~~~~~\nSwift.String:5:16: note: 'characters' was obsoleted in Swift\
    \ 5.0\n    public var characters: String { get set }\n               ^\n/tmp/tmpltg6jcop.swift:9:12:\
    \ error: 'subscript(_:)' is unavailable: cannot subscript String with an Int,\
    \ use a String.Index instead.\n        if a[i] == b[i] {\n           ^~~~\nSwift.String:3:12:\
    \ note: 'subscript(_:)' has been explicitly marked unavailable here\n    public\
    \ subscript(i: Int) -> Character { get }\n           ^\n/tmp/tmpltg6jcop.swift:9:20:\
    \ error: 'subscript(_:)' is unavailable: cannot subscript String with an Int,\
    \ use a String.Index instead.\n        if a[i] == b[i] {\n                   ^~~~\n\
    Swift.String:3:12: note: 'subscript(_:)' has been explicitly marked unavailable\
    \ here\n    public subscript(i: Int) -> Character { get }\n           ^\n"
  stdout: ''
  timestamp: 1659978479
- exit_code: 1
  program: "\n/// Input are two strings a and b consisting only of 1s and 0s.\n///\
    \ Perform binary XOR on these inputs and return result also as a string.\n///\
    \ >>> string_xor(a: \"010\", b: \"110\")\n/// \"100\"\nfunc string_xor(a: String,\
    \ b: String) -> String {\n    var ret = \"\"\n    for (index, character) in a.characters.enumerated()\
    \ {\n        let a = String(character)\n        let b = String(b[b.index(b.startIndex,\
    \ offsetBy: index)])\n        ret += xor(a: a, b: b)\n    }\n    return ret\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(string_xor(a: \"111000\", b: \"101010\") == \"\
    010010\")\nassert(string_xor(a: \"1\", b: \"1\") == \"0\")\nassert(string_xor(a:\
    \ \"0101\", b: \"0000\") == \"0101\")"
  status: SyntaxError
  stderr: "/tmp/tmp9d2bi91b.swift:8:33: error: 'characters' is unavailable: Please\
    \ use String directly\n    for (index, character) in a.characters.enumerated()\
    \ {\n                                ^~~~~~~~~~\nSwift.String:5:16: note: 'characters'\
    \ was obsoleted in Swift 5.0\n    public var characters: String { get set }\n\
    \               ^\n/tmp/tmp9d2bi91b.swift:11:16: error: cannot find 'xor' in scope\n\
    \        ret += xor(a: a, b: b)\n               ^~~\n"
  stdout: ''
  timestamp: 1659978479
- exit_code: 1
  program: "\n/// Input are two strings a and b consisting only of 1s and 0s.\n///\
    \ Perform binary XOR on these inputs and return result also as a string.\n///\
    \ >>> string_xor(a: \"010\", b: \"110\")\n/// \"100\"\nfunc string_xor(a: String,\
    \ b: String) -> String {\n  guard a.characters.count == b.characters.count else\
    \ { return \"\" }\n  var result = \"\"\n  for (i, j) in zip(a.characters, b.characters)\
    \ {\n    let n = a[a.index(a.startIndex, offsetBy: i)]\n    let m = b[b.index(b.startIndex,\
    \ offsetBy: j)]\n    let c = Int(String(n))! ^ Int(String(m))!\n    result +=\
    \ String(c)\n  }\n  return result\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int,\
    \ Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n\
    \    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n          \
    \  return false\n        }\n    }\n    return true\n}\n            \nassert(string_xor(a:\
    \ \"111000\", b: \"101010\") == \"010010\")\nassert(string_xor(a: \"1\", b: \"\
    1\") == \"0\")\nassert(string_xor(a: \"0101\", b: \"0000\") == \"0101\")"
  status: SyntaxError
  stderr: "/tmp/tmpb_sq5zuo.swift:7:11: error: 'characters' is unavailable: Please\
    \ use String directly\n  guard a.characters.count == b.characters.count else {\
    \ return \"\" }\n          ^~~~~~~~~~\nSwift.String:5:16: note: 'characters' was\
    \ obsoleted in Swift 5.0\n    public var characters: String { get set }\n    \
    \           ^\n/tmp/tmpb_sq5zuo.swift:7:33: error: 'characters' is unavailable:\
    \ Please use String directly\n  guard a.characters.count == b.characters.count\
    \ else { return \"\" }\n                                ^~~~~~~~~~\nSwift.String:5:16:\
    \ note: 'characters' was obsoleted in Swift 5.0\n    public var characters: String\
    \ { get set }\n               ^\n/tmp/tmpb_sq5zuo.swift:9:23: error: 'characters'\
    \ is unavailable: Please use String directly\n  for (i, j) in zip(a.characters,\
    \ b.characters) {\n                      ^~~~~~~~~~\nSwift.String:5:16: note:\
    \ 'characters' was obsoleted in Swift 5.0\n    public var characters: String {\
    \ get set }\n               ^\n/tmp/tmpb_sq5zuo.swift:9:37: error: 'characters'\
    \ is unavailable: Please use String directly\n  for (i, j) in zip(a.characters,\
    \ b.characters) {\n                                    ^~~~~~~~~~\nSwift.String:5:16:\
    \ note: 'characters' was obsoleted in Swift 5.0\n    public var characters: String\
    \ { get set }\n               ^\n/tmp/tmpb_sq5zuo.swift:10:47: error: cannot convert\
    \ value of type 'String.Element' (aka 'Character') to expected argument type 'Int'\n\
    \    let n = a[a.index(a.startIndex, offsetBy: i)]\n                         \
    \                     ^\n/tmp/tmpb_sq5zuo.swift:11:47: error: cannot convert value\
    \ of type 'String.Element' (aka 'Character') to expected argument type 'Int'\n\
    \    let m = b[b.index(b.startIndex, offsetBy: j)]\n                         \
    \                     ^\n"
  stdout: ''
  timestamp: 1659978479
- exit_code: 1
  program: "\n/// Input are two strings a and b consisting only of 1s and 0s.\n///\
    \ Perform binary XOR on these inputs and return result also as a string.\n///\
    \ >>> string_xor(a: \"010\", b: \"110\")\n/// \"100\"\nfunc string_xor(a: String,\
    \ b: String) -> String {\n    var result = \"\"\n    for (idx, char) in a.characters.enumerated()\
    \ {\n        let int_a = Int(String(char))!\n        let int_b = Int(String(b[b.index(b.startIndex,\
    \ offsetBy: idx)]))!\n        let xor = int_a ^ int_b\n        result.append(String(xor))\n\
    \    }\n    return result\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(string_xor(a:\
    \ \"111000\", b: \"101010\") == \"010010\")\nassert(string_xor(a: \"1\", b: \"\
    1\") == \"0\")\nassert(string_xor(a: \"0101\", b: \"0000\") == \"0101\")"
  status: SyntaxError
  stderr: "/tmp/tmpgreb3qqm.swift:8:26: error: 'characters' is unavailable: Please\
    \ use String directly\n    for (idx, char) in a.characters.enumerated() {\n  \
    \                       ^~~~~~~~~~\nSwift.String:5:16: note: 'characters' was\
    \ obsoleted in Swift 5.0\n    public var characters: String { get set }\n    \
    \           ^\n"
  stdout: ''
  timestamp: 1659978479
- exit_code: 0
  program: "\n/// Input are two strings a and b consisting only of 1s and 0s.\n///\
    \ Perform binary XOR on these inputs and return result also as a string.\n///\
    \ >>> string_xor(a: \"010\", b: \"110\")\n/// \"100\"\nfunc string_xor(a: String,\
    \ b: String) -> String {\n    let aa = Array(a)\n    let bb = Array(b)\n    var\
    \ result = \"\"\n    for (i, _) in aa.enumerated() {\n        result += String(Int(String(aa[i]))!\
    \ ^ Int(String(bb[i]))!)\n    }\n    return result\n}\n\n\nfunc ==(left: [(Int,\
    \ Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n\
    \        return false\n    }\n    for (l, r) in zip(left, right) {\n        if\
    \ l != r {\n            return false\n        }\n    }\n    return true\n}\n \
    \           \nassert(string_xor(a: \"111000\", b: \"101010\") == \"010010\")\n\
    assert(string_xor(a: \"1\", b: \"1\") == \"0\")\nassert(string_xor(a: \"0101\"\
    , b: \"0000\") == \"0101\")"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659978479
- exit_code: 1
  program: "\n/// Input are two strings a and b consisting only of 1s and 0s.\n///\
    \ Perform binary XOR on these inputs and return result also as a string.\n///\
    \ >>> string_xor(a: \"010\", b: \"110\")\n/// \"100\"\nfunc string_xor(a: String,\
    \ b: String) -> String {\n    var res = String()\n    let l = min(a.count, b.count)\n\
    \    for i in 0..<l {\n        res.append(a[i] == b[i] ? \"0\" : \"1\")\n    }\n\
    \    return res\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool\
    \ {\n    if left.count != right.count {\n        return false\n    }\n    for\
    \ (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(string_xor(a: \"111000\"\
    , b: \"101010\") == \"010010\")\nassert(string_xor(a: \"1\", b: \"1\") == \"0\"\
    )\nassert(string_xor(a: \"0101\", b: \"0000\") == \"0101\")"
  status: SyntaxError
  stderr: "/tmp/tmp62ax8syf.swift:10:20: error: 'subscript(_:)' is unavailable: cannot\
    \ subscript String with an Int, use a String.Index instead.\n        res.append(a[i]\
    \ == b[i] ? \"0\" : \"1\")\n                   ^~~~\nSwift.String:3:12: note:\
    \ 'subscript(_:)' has been explicitly marked unavailable here\n    public subscript(i:\
    \ Int) -> Character { get }\n           ^\n/tmp/tmp62ax8syf.swift:10:28: error:\
    \ 'subscript(_:)' is unavailable: cannot subscript String with an Int, use a String.Index\
    \ instead.\n        res.append(a[i] == b[i] ? \"0\" : \"1\")\n               \
    \            ^~~~\nSwift.String:3:12: note: 'subscript(_:)' has been explicitly\
    \ marked unavailable here\n    public subscript(i: Int) -> Character { get }\n\
    \           ^\n"
  stdout: ''
  timestamp: 1659978479
- exit_code: 1
  program: "\n/// Input are two strings a and b consisting only of 1s and 0s.\n///\
    \ Perform binary XOR on these inputs and return result also as a string.\n///\
    \ >>> string_xor(a: \"010\", b: \"110\")\n/// \"100\"\nfunc string_xor(a: String,\
    \ b: String) -> String {\n    let a_bytes = Array(a.utf8)\n    let b_bytes = Array(b.utf8)\n\
    \    var ret_bytes = [UInt8]()\n    for (a_byte, b_byte) in zip(a_bytes, b_bytes)\
    \ {\n        let xor_byte = UInt8(a_byte) ^ UInt8(b_byte)\n        ret_bytes.append(xor_byte)\n\
    \    }\n    return String(bytes: ret_bytes, encoding: .utf8)!\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(string_xor(a: \"111000\", b: \"101010\") == \"010010\"\
    )\nassert(string_xor(a: \"1\", b: \"1\") == \"0\")\nassert(string_xor(a: \"0101\"\
    , b: \"0000\") == \"0101\")"
  status: SyntaxError
  stderr: "/tmp/tmpapfcawi6.swift:14:12: error: no exact matches in call to initializer\
    \ \n    return String(bytes: ret_bytes, encoding: .utf8)!\n           ^\n/tmp/tmpapfcawi6.swift:14:12:\
    \ note: found candidate with type '(Array<_>, _.Type) -> String'\n    return String(bytes:\
    \ ret_bytes, encoding: .utf8)!\n           ^\n/tmp/tmpapfcawi6.swift:14:12: note:\
    \ found candidate with type '([UInt8]) -> String'\n    return String(bytes: ret_bytes,\
    \ encoding: .utf8)!\n           ^\n/tmp/tmpapfcawi6.swift:14:12: note: found candidate\
    \ with type '(Substring.UTF8View) -> String?'\n    return String(bytes: ret_bytes,\
    \ encoding: .utf8)!\n           ^\n/tmp/tmpapfcawi6.swift:14:12: note: found candidate\
    \ with type '(Substring.UTF16View) -> String?'\n    return String(bytes: ret_bytes,\
    \ encoding: .utf8)!\n           ^\n"
  stdout: ''
  timestamp: 1659978479
- exit_code: 0
  program: "\n/// Input are two strings a and b consisting only of 1s and 0s.\n///\
    \ Perform binary XOR on these inputs and return result also as a string.\n///\
    \ >>> string_xor(a: \"010\", b: \"110\")\n/// \"100\"\nfunc string_xor(a: String,\
    \ b: String) -> String {\n    var result = \"\"\n    for index in 0..<a.count\
    \ {\n        let a_char = a[a.index(a.startIndex, offsetBy: index)]\n        let\
    \ b_char = b[b.index(b.startIndex, offsetBy: index)]\n        let xor = a_char\
    \ == b_char ? \"0\" : \"1\"\n        result += xor\n    }\n    return result\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(string_xor(a: \"111000\", b: \"101010\") == \"\
    010010\")\nassert(string_xor(a: \"1\", b: \"1\") == \"0\")\nassert(string_xor(a:\
    \ \"0101\", b: \"0000\") == \"0101\")"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659978479
- exit_code: 1
  program: "\n/// Input are two strings a and b consisting only of 1s and 0s.\n///\
    \ Perform binary XOR on these inputs and return result also as a string.\n///\
    \ >>> string_xor(a: \"010\", b: \"110\")\n/// \"100\"\nfunc string_xor(a: String,\
    \ b: String) -> String {\n    let bytes1 = a.utf8\n    let bytes2 = b.utf8\n \
    \   return bytes1.enumerated().map { (i, byte1) -> UInt8 in\n        byte1 ^ bytes2[i]\n\
    \    }.map { String($0, radix: 2) }.joined()\n}\n\n\nfunc ==(left: [(Int, Int)],\
    \ right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n       \
    \ return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r\
    \ {\n            return false\n        }\n    }\n    return true\n}\n        \
    \    \nassert(string_xor(a: \"111000\", b: \"101010\") == \"010010\")\nassert(string_xor(a:\
    \ \"1\", b: \"1\") == \"0\")\nassert(string_xor(a: \"0101\", b: \"0000\") == \"\
    0101\")"
  status: SyntaxError
  stderr: "/tmp/tmplm8xfx71.swift:10:24: error: cannot convert value of type 'Int'\
    \ to expected argument type 'String.UTF8View.Index' (aka 'String.Index')\n   \
    \     byte1 ^ bytes2[i]\n                       ^\n"
  stdout: ''
  timestamp: 1659978479
- exit_code: -4
  program: "\n/// Input are two strings a and b consisting only of 1s and 0s.\n///\
    \ Perform binary XOR on these inputs and return result also as a string.\n///\
    \ >>> string_xor(a: \"010\", b: \"110\")\n/// \"100\"\nfunc string_xor(a: String,\
    \ b: String) -> String {\n    // integer a and b\n    let intA = Int(a, radix:\
    \ 2)!\n    let intB = Int(b, radix: 2)!\n    let intResult = intA ^ intB\n   \
    \ // string result\n    let strResult = String(intResult, radix: 2)\n    return\
    \ strResult\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n\
    \    if left.count != right.count {\n        return false\n    }\n    for (l,\
    \ r) in zip(left, right) {\n        if l != r {\n            return false\n  \
    \      }\n    }\n    return true\n}\n            \nassert(string_xor(a: \"111000\"\
    , b: \"101010\") == \"010010\")\nassert(string_xor(a: \"1\", b: \"1\") == \"0\"\
    )\nassert(string_xor(a: \"0101\", b: \"0000\") == \"0101\")"
  status: Exception
  stderr: 'tmpy3pnpyde/tmpy3pnpyde.swift:29: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b22bb76ac80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b22bb461b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b22bb461988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b22bb4607b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpy3pnpyde                        0x000055dde9fd05ab <unavailable> + 5547

    5    libc.so.6                          0x00002b22bb956460 __libc_start_main +
    245

    6    tmpy3pnpyde                        0x000055dde9fd01b9 <unavailable> + 4537

    '
  stdout: ''
  timestamp: 1659978479
- exit_code: 1
  program: "\n/// Input are two strings a and b consisting only of 1s and 0s.\n///\
    \ Perform binary XOR on these inputs and return result also as a string.\n///\
    \ >>> string_xor(a: \"010\", b: \"110\")\n/// \"100\"\nfunc string_xor(a: String,\
    \ b: String) -> String {\n    return String(zip(a, b).map { $0 != $1 })\n}\n\n\
    \nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(string_xor(a: \"111000\", b: \"101010\") == \"\
    010010\")\nassert(string_xor(a: \"1\", b: \"1\") == \"0\")\nassert(string_xor(a:\
    \ \"0101\", b: \"0000\") == \"0101\")"
  status: SyntaxError
  stderr: "/tmp/tmpbl47f_cj.swift:7:12: error: type of expression is ambiguous without\
    \ more context\n    return String(zip(a, b).map { $0 != $1 })\n           ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n"
  stdout: ''
  timestamp: 1659978479
- exit_code: 1
  program: "\n/// Input are two strings a and b consisting only of 1s and 0s.\n///\
    \ Perform binary XOR on these inputs and return result also as a string.\n///\
    \ >>> string_xor(a: \"010\", b: \"110\")\n/// \"100\"\nfunc string_xor(a: String,\
    \ b: String) -> String {\n    let result = String(a.utf8.enumerated().map { $0.1\
    \ ^ b[$0.0] })\n    print(result)\n    return result\n}\n\n\nfunc ==(left: [(Int,\
    \ Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n\
    \        return false\n    }\n    for (l, r) in zip(left, right) {\n        if\
    \ l != r {\n            return false\n        }\n    }\n    return true\n}\n \
    \           \nassert(string_xor(a: \"111000\", b: \"101010\") == \"010010\")\n\
    assert(string_xor(a: \"1\", b: \"1\") == \"0\")\nassert(string_xor(a: \"0101\"\
    , b: \"0000\") == \"0101\")"
  status: SyntaxError
  stderr: "/tmp/tmpugu2io48.swift:7:18: error: no exact matches in call to initializer\
    \ \n    let result = String(a.utf8.enumerated().map { $0.1 ^ b[$0.0] })\n    \
    \             ^\n/tmp/tmpugu2io48.swift:7:18: note: found candidate with type\
    \ '([Character]) -> String'\n    let result = String(a.utf8.enumerated().map {\
    \ $0.1 ^ b[$0.0] })\n                 ^\n/tmp/tmpugu2io48.swift:7:18: note: candidate\
    \ expects value of type '[UInt8]' for parameter #1 (got '[UInt8]')\n    let result\
    \ = String(a.utf8.enumerated().map { $0.1 ^ b[$0.0] })\n                 ^\n/tmp/tmpugu2io48.swift:7:18:\
    \ note: candidate expects value of type '[UInt8]' for parameter #1 (got '[UInt8]')\n\
    \    let result = String(a.utf8.enumerated().map { $0.1 ^ b[$0.0] })\n       \
    \          ^\n/tmp/tmpugu2io48.swift:7:18: note: candidate expects value of type\
    \ '[UInt8]' for parameter #1 (got '[UInt8]')\n    let result = String(a.utf8.enumerated().map\
    \ { $0.1 ^ b[$0.0] })\n                 ^\n/tmp/tmpugu2io48.swift:7:18: note:\
    \ candidate expects value of type '[UInt8]' for parameter #1 (got '[UInt8]')\n\
    \    let result = String(a.utf8.enumerated().map { $0.1 ^ b[$0.0] })\n       \
    \          ^\n/tmp/tmpugu2io48.swift:7:59: error: cannot convert value of type\
    \ 'Character' to expected argument type 'UInt8'\n    let result = String(a.utf8.enumerated().map\
    \ { $0.1 ^ b[$0.0] })\n                                                      \
    \    ^\n"
  stdout: ''
  timestamp: 1659978479
- exit_code: -4
  program: "\n/// Input are two strings a and b consisting only of 1s and 0s.\n///\
    \ Perform binary XOR on these inputs and return result also as a string.\n///\
    \ >>> string_xor(a: \"010\", b: \"110\")\n/// \"100\"\nfunc string_xor(a: String,\
    \ b: String) -> String {\n    return \"\"\n}\n\n\nfunc ==(left: [(Int, Int)],\
    \ right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n       \
    \ return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r\
    \ {\n            return false\n        }\n    }\n    return true\n}\n        \
    \    \nassert(string_xor(a: \"111000\", b: \"101010\") == \"010010\")\nassert(string_xor(a:\
    \ \"1\", b: \"1\") == \"0\")\nassert(string_xor(a: \"0101\", b: \"0000\") == \"\
    0101\")"
  status: Exception
  stderr: 'tmp1ma40nkp/tmp1ma40nkp.swift:23: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b0563602c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b05632f9b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b05632f9988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b05632f87b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmp1ma40nkp                        0x0000563c4899b33b <unavailable> + 4923

    5    libc.so.6                          0x00002b05637ee460 __libc_start_main +
    245

    6    tmp1ma40nkp                        0x0000563c4899af49 <unavailable> + 3913

    '
  stdout: ''
  timestamp: 1659978479
- exit_code: 0
  program: "\n/// Input are two strings a and b consisting only of 1s and 0s.\n///\
    \ Perform binary XOR on these inputs and return result also as a string.\n///\
    \ >>> string_xor(a: \"010\", b: \"110\")\n/// \"100\"\nfunc string_xor(a: String,\
    \ b: String) -> String {\n    //Prepare the inputs\n    let a = a.map{Int(String($0))!}\n\
    \    let b = b.map{Int(String($0))!}\n    //Perform XOR for each bit\n    let\
    \ xor = zip(a, b).map{$0 ^ $1}\n    //Convert to String\n    return xor.map{String($0)}.joined()\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(string_xor(a: \"111000\", b: \"101010\") == \"\
    010010\")\nassert(string_xor(a: \"1\", b: \"1\") == \"0\")\nassert(string_xor(a:\
    \ \"0101\", b: \"0000\") == \"0101\")"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659978479
- exit_code: 0
  program: "\n/// Input are two strings a and b consisting only of 1s and 0s.\n///\
    \ Perform binary XOR on these inputs and return result also as a string.\n///\
    \ >>> string_xor(a: \"010\", b: \"110\")\n/// \"100\"\nfunc string_xor(a: String,\
    \ b: String) -> String {\n    guard a.count == b.count else {\n        return\
    \ \"\"\n    }\n    let c = zip(a, b).map { Int(String($0))! ^ Int(String($1))!\
    \ }\n    return c.map { String($0) }.joined()\n}\n\n\nfunc ==(left: [(Int, Int)],\
    \ right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n       \
    \ return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r\
    \ {\n            return false\n        }\n    }\n    return true\n}\n        \
    \    \nassert(string_xor(a: \"111000\", b: \"101010\") == \"010010\")\nassert(string_xor(a:\
    \ \"1\", b: \"1\") == \"0\")\nassert(string_xor(a: \"0101\", b: \"0000\") == \"\
    0101\")"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659978479
- exit_code: 1
  program: "\n/// Input are two strings a and b consisting only of 1s and 0s.\n///\
    \ Perform binary XOR on these inputs and return result also as a string.\n///\
    \ >>> string_xor(a: \"010\", b: \"110\")\n/// \"100\"\nfunc string_xor(a: String,\
    \ b: String) -> String {\n    let axor = a.utf8.map { UInt8(bitPattern: $0) }\n\
    \    let bxor = b.utf8.map { UInt8(bitPattern: $0) }\n    var result = [UInt8]()\n\
    \    for i in 0..<axor.count {\n        result.append(axor[i] ^ bxor[i])\n   \
    \ }\n    let resultxor = result.map { Character(UnicodeScalar(UInt8(bitPattern:\
    \ $0))) }\n    return String(resultxor)\n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(string_xor(a: \"111000\", b: \"101010\") == \"010010\")\nassert(string_xor(a:\
    \ \"1\", b: \"1\") == \"0\")\nassert(string_xor(a: \"0101\", b: \"0000\") == \"\
    0101\")"
  status: SyntaxError
  stderr: "/tmp/tmp_0j4bn40.swift:7:47: error: cannot convert value of type 'String.UTF8View.Element'\
    \ (aka 'UInt8') to expected argument type 'Int8'\n    let axor = a.utf8.map {\
    \ UInt8(bitPattern: $0) }\n                                              ^\n \
    \                                             Int8( )\n/tmp/tmp_0j4bn40.swift:8:47:\
    \ error: cannot convert value of type 'String.UTF8View.Element' (aka 'UInt8')\
    \ to expected argument type 'Int8'\n    let bxor = b.utf8.map { UInt8(bitPattern:\
    \ $0) }\n                                              ^\n                   \
    \                           Int8( )\n/tmp/tmp_0j4bn40.swift:13:76: error: cannot\
    \ convert value of type 'UInt8' to expected argument type 'Int8'\n    let resultxor\
    \ = result.map { Character(UnicodeScalar(UInt8(bitPattern: $0))) }\n         \
    \                                                                  ^\n       \
    \                                                                    Int8( )\n"
  stdout: ''
  timestamp: 1659978479
- exit_code: 0
  program: "\n/// Input are two strings a and b consisting only of 1s and 0s.\n///\
    \ Perform binary XOR on these inputs and return result also as a string.\n///\
    \ >>> string_xor(a: \"010\", b: \"110\")\n/// \"100\"\nfunc string_xor(a: String,\
    \ b: String) -> String {\n    var out: [Character] = []\n    var index = a.startIndex\n\
    \    while index != a.endIndex {\n        let c = a[index]\n        let d = b[index]\n\
    \        out.append(c == d ? \"0\" : \"1\")\n        index = a.index(after: index)\n\
    \    }\n    return String(out)\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int,\
    \ Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n\
    \    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n          \
    \  return false\n        }\n    }\n    return true\n}\n            \nassert(string_xor(a:\
    \ \"111000\", b: \"101010\") == \"010010\")\nassert(string_xor(a: \"1\", b: \"\
    1\") == \"0\")\nassert(string_xor(a: \"0101\", b: \"0000\") == \"0101\")"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659978479
- exit_code: 1
  program: "\n/// Input are two strings a and b consisting only of 1s and 0s.\n///\
    \ Perform binary XOR on these inputs and return result also as a string.\n///\
    \ >>> string_xor(a: \"010\", b: \"110\")\n/// \"100\"\nfunc string_xor(a: String,\
    \ b: String) -> String {\n    if a.characters.count != b.characters.count {\n\
    \        print(\"Strings are not of equal length!\")\n        return String(0)\n\
    \    }\n    var result = String()\n    for i in 0..<a.characters.count {\n   \
    \     if a[i] == b[i] {\n            result.append(\"0\")\n        } else {\n\
    \            result.append(\"1\")\n        }\n    }\n    return result\n}\n\n\n\
    func ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(string_xor(a: \"111000\", b: \"101010\") == \"\
    010010\")\nassert(string_xor(a: \"1\", b: \"1\") == \"0\")\nassert(string_xor(a:\
    \ \"0101\", b: \"0000\") == \"0101\")"
  status: SyntaxError
  stderr: "/tmp/tmpwc5p10wd.swift:7:10: error: 'characters' is unavailable: Please\
    \ use String directly\n    if a.characters.count != b.characters.count {\n   \
    \      ^~~~~~~~~~\nSwift.String:5:16: note: 'characters' was obsoleted in Swift\
    \ 5.0\n    public var characters: String { get set }\n               ^\n/tmp/tmpwc5p10wd.swift:7:32:\
    \ error: 'characters' is unavailable: Please use String directly\n    if a.characters.count\
    \ != b.characters.count {\n                               ^~~~~~~~~~\nSwift.String:5:16:\
    \ note: 'characters' was obsoleted in Swift 5.0\n    public var characters: String\
    \ { get set }\n               ^\n/tmp/tmpwc5p10wd.swift:12:20: error: 'characters'\
    \ is unavailable: Please use String directly\n    for i in 0..<a.characters.count\
    \ {\n                   ^~~~~~~~~~\nSwift.String:5:16: note: 'characters' was\
    \ obsoleted in Swift 5.0\n    public var characters: String { get set }\n    \
    \           ^\n/tmp/tmpwc5p10wd.swift:13:12: error: 'subscript(_:)' is unavailable:\
    \ cannot subscript String with an Int, use a String.Index instead.\n        if\
    \ a[i] == b[i] {\n           ^~~~\nSwift.String:3:12: note: 'subscript(_:)' has\
    \ been explicitly marked unavailable here\n    public subscript(i: Int) -> Character\
    \ { get }\n           ^\n/tmp/tmpwc5p10wd.swift:13:20: error: 'subscript(_:)'\
    \ is unavailable: cannot subscript String with an Int, use a String.Index instead.\n\
    \        if a[i] == b[i] {\n                   ^~~~\nSwift.String:3:12: note:\
    \ 'subscript(_:)' has been explicitly marked unavailable here\n    public subscript(i:\
    \ Int) -> Character { get }\n           ^\n"
  stdout: ''
  timestamp: 1659978479
- exit_code: 1
  program: "\n/// Input are two strings a and b consisting only of 1s and 0s.\n///\
    \ Perform binary XOR on these inputs and return result also as a string.\n///\
    \ >>> string_xor(a: \"010\", b: \"110\")\n/// \"100\"\nfunc string_xor(a: String,\
    \ b: String) -> String {\n    if a.count != b.count {\n        return \"\"\n \
    \   }\n    let aBits = [Int](a.utf8).map { Int($0 - 48) }\n    let bBits = [Int](b.utf8).map\
    \ { Int($0 - 48) }\n    var result = \"\"\n    for i in 0..<a.count {\n      \
    \  result += \"\\(aBits[i] ^ bBits[i])\"\n    }\n    return result\n}\n\n\nfunc\
    \ ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count !=\
    \ right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(string_xor(a: \"111000\", b: \"101010\") == \"\
    010010\")\nassert(string_xor(a: \"1\", b: \"1\") == \"0\")\nassert(string_xor(a:\
    \ \"0101\", b: \"0000\") == \"0101\")"
  status: SyntaxError
  stderr: "/tmp/tmpgfft_hbi.swift:10:17: error: no exact matches in call to initializer\
    \ \n    let aBits = [Int](a.utf8).map { Int($0 - 48) }\n                ^\nSwift.Array:3:23:\
    \ note: candidate requires that the types 'Int' and 'String.UTF8View.Element'\
    \ (aka 'UInt8') be equivalent (requirement specified as 'Element' == 'S.Element')\n\
    \    @inlinable public init<S>(_ s: S) where Element == S.Element, S : Sequence\n\
    \                      ^\nSwift.RangeReplaceableCollection:3:23: note: candidate\
    \ requires that the types 'Int' and 'String.UTF8View.Element' (aka 'UInt8') be\
    \ equivalent (requirement specified as 'Self.Element' == 'S.Element')\n    @inlinable\
    \ public init<S>(_ elements: S) where S : Sequence, Self.Element == S.Element\n\
    \                      ^\n/tmp/tmpgfft_hbi.swift:11:17: error: no exact matches\
    \ in call to initializer \n    let bBits = [Int](b.utf8).map { Int($0 - 48) }\n\
    \                ^\nSwift.Array:3:23: note: candidate requires that the types\
    \ 'Int' and 'String.UTF8View.Element' (aka 'UInt8') be equivalent (requirement\
    \ specified as 'Element' == 'S.Element')\n    @inlinable public init<S>(_ s: S)\
    \ where Element == S.Element, S : Sequence\n                      ^\nSwift.RangeReplaceableCollection:3:23:\
    \ note: candidate requires that the types 'Int' and 'String.UTF8View.Element'\
    \ (aka 'UInt8') be equivalent (requirement specified as 'Self.Element' == 'S.Element')\n\
    \    @inlinable public init<S>(_ elements: S) where S : Sequence, Self.Element\
    \ == S.Element\n                      ^\n"
  stdout: ''
  timestamp: 1659978479
- exit_code: 1
  program: "\n/// Input are two strings a and b consisting only of 1s and 0s.\n///\
    \ Perform binary XOR on these inputs and return result also as a string.\n///\
    \ >>> string_xor(a: \"010\", b: \"110\")\n/// \"100\"\nfunc string_xor(a: String,\
    \ b: String) -> String {\n    var ans = \"\"\n    for i in 0..<a.count {\n   \
    \     ans += a[i] == b[i] ? \"0\" : \"1\"\n    }\n    return ans\n}\n\n\nfunc\
    \ ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count !=\
    \ right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(string_xor(a: \"111000\", b: \"101010\") == \"\
    010010\")\nassert(string_xor(a: \"1\", b: \"1\") == \"0\")\nassert(string_xor(a:\
    \ \"0101\", b: \"0000\") == \"0101\")"
  status: SyntaxError
  stderr: "/tmp/tmpueea030h.swift:9:16: error: 'subscript(_:)' is unavailable: cannot\
    \ subscript String with an Int, use a String.Index instead.\n        ans += a[i]\
    \ == b[i] ? \"0\" : \"1\"\n               ^~~~\nSwift.String:3:12: note: 'subscript(_:)'\
    \ has been explicitly marked unavailable here\n    public subscript(i: Int) ->\
    \ Character { get }\n           ^\n/tmp/tmpueea030h.swift:9:24: error: 'subscript(_:)'\
    \ is unavailable: cannot subscript String with an Int, use a String.Index instead.\n\
    \        ans += a[i] == b[i] ? \"0\" : \"1\"\n                       ^~~~\nSwift.String:3:12:\
    \ note: 'subscript(_:)' has been explicitly marked unavailable here\n    public\
    \ subscript(i: Int) -> Character { get }\n           ^\n"
  stdout: ''
  timestamp: 1659978479
- exit_code: -4
  program: "\n/// Input are two strings a and b consisting only of 1s and 0s.\n///\
    \ Perform binary XOR on these inputs and return result also as a string.\n///\
    \ >>> string_xor(a: \"010\", b: \"110\")\n/// \"100\"\nfunc string_xor(a: String,\
    \ b: String) -> String {\n    let intA = Int(a, radix: 2)!\n    let intB = Int(b,\
    \ radix: 2)!\n    let result = intA ^ intB\n    return String(result, radix: 2)\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(string_xor(a: \"111000\", b: \"101010\") == \"\
    010010\")\nassert(string_xor(a: \"1\", b: \"1\") == \"0\")\nassert(string_xor(a:\
    \ \"0101\", b: \"0000\") == \"0101\")"
  status: Exception
  stderr: 'tmpm4jyhhxd/tmpm4jyhhxd.swift:26: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b9a19e3ec80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b9a19b35b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b9a19b35988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b9a19b347b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpm4jyhhxd                        0x00005570483135ab <unavailable> + 5547

    5    libc.so.6                          0x00002b9a1a02a460 __libc_start_main +
    245

    6    tmpm4jyhhxd                        0x00005570483131b9 <unavailable> + 4537

    '
  stdout: ''
  timestamp: 1659978479
- exit_code: 1
  program: "\n/// Input are two strings a and b consisting only of 1s and 0s.\n///\
    \ Perform binary XOR on these inputs and return result also as a string.\n///\
    \ >>> string_xor(a: \"010\", b: \"110\")\n/// \"100\"\nfunc string_xor(a: String,\
    \ b: String) -> String {\n    // Get minimum length between a and b\n    let length\
    \ = min(a.count, b.count)\n    var result = \"\"\n    // Iterate through chars\
    \ in both strings\n    for i in 0 ..< length {\n        // Append 0 or 1 to result\n\
    \        result += String(a[i] ^ b[i])\n    }\n    return result\n}\n\n\nfunc\
    \ ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count !=\
    \ right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(string_xor(a: \"111000\", b: \"101010\") == \"\
    010010\")\nassert(string_xor(a: \"1\", b: \"1\") == \"0\")\nassert(string_xor(a:\
    \ \"0101\", b: \"0000\") == \"0101\")"
  status: SyntaxError
  stderr: "/tmp/tmp48kuj692.swift:13:31: error: binary operator '^' cannot be applied\
    \ to two 'Character' operands\n        result += String(a[i] ^ b[i])\n       \
    \                  ~~~~ ^ ~~~~\n"
  stdout: ''
  timestamp: 1659978480
- exit_code: 1
  program: "\n/// Input are two strings a and b consisting only of 1s and 0s.\n///\
    \ Perform binary XOR on these inputs and return result also as a string.\n///\
    \ >>> string_xor(a: \"010\", b: \"110\")\n/// \"100\"\nfunc string_xor(a: String,\
    \ b: String) -> String {\n    return String(zip(a, b).map(^))\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(string_xor(a: \"111000\", b: \"101010\") == \"010010\"\
    )\nassert(string_xor(a: \"1\", b: \"1\") == \"0\")\nassert(string_xor(a: \"0101\"\
    , b: \"0000\") == \"0101\")"
  status: SyntaxError
  stderr: "/tmp/tmp5qiefeh9.swift:7:33: error: no exact matches in reference to operator\
    \ function '^'\n    return String(zip(a, b).map(^))\n                        \
    \        ^\nSwift.BinaryInteger:1:17: note: candidate requires that 'String.Element'\
    \ (aka 'Character') conform to 'BinaryInteger' (requirement specified as 'Self'\
    \ : 'BinaryInteger')\npublic protocol BinaryInteger : CustomStringConvertible,\
    \ Hashable, Numeric, Strideable where Self.Magnitude : BinaryInteger, Self.Magnitude\
    \ == Self.Magnitude.Magnitude {\n                ^\nSwift.BinaryInteger:1:11:\
    \ note: candidate requires that 'String.Element' (aka 'Character') conform to\
    \ 'BinaryInteger' (requirement specified as 'Self' : 'BinaryInteger')\nextension\
    \ BinaryInteger {\n          ^\nSwift.SIMD:1:11: note: candidate requires that\
    \ 'String.Element' (aka 'Character') conform to 'SIMD' (requirement specified\
    \ as 'Self' : 'SIMD')\nextension SIMD where Self.Scalar : FixedWidthInteger {\n\
    \          ^\n"
  stdout: ''
  timestamp: 1659978479
- exit_code: 0
  program: "\n/// Input are two strings a and b consisting only of 1s and 0s.\n///\
    \ Perform binary XOR on these inputs and return result also as a string.\n///\
    \ >>> string_xor(a: \"010\", b: \"110\")\n/// \"100\"\nfunc string_xor(a: String,\
    \ b: String) -> String {\n    let z = zip(a, b)\n    let res = z.map { Int(String($0))!\
    \ ^ Int(String($1))! }\n    return res.map { String($0) }.joined()\n}\n\n\nfunc\
    \ ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count !=\
    \ right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(string_xor(a: \"111000\", b: \"101010\") == \"\
    010010\")\nassert(string_xor(a: \"1\", b: \"1\") == \"0\")\nassert(string_xor(a:\
    \ \"0101\", b: \"0000\") == \"0101\")"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659978479
- exit_code: 0
  program: "\n/// Input are two strings a and b consisting only of 1s and 0s.\n///\
    \ Perform binary XOR on these inputs and return result also as a string.\n///\
    \ >>> string_xor(a: \"010\", b: \"110\")\n/// \"100\"\nfunc string_xor(a: String,\
    \ b: String) -> String {\n    let a_bin = [UInt8](a.utf8)\n    let b_bin = [UInt8](b.utf8)\n\
    \    var result = \"\"\n    for i in 0..<a_bin.count {\n        result += a_bin[i]\
    \ == b_bin[i] ? \"0\" : \"1\"\n    }\n    return result\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(string_xor(a: \"111000\", b: \"101010\") == \"010010\"\
    )\nassert(string_xor(a: \"1\", b: \"1\") == \"0\")\nassert(string_xor(a: \"0101\"\
    , b: \"0000\") == \"0101\")"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659978479
- exit_code: 1
  program: "\n/// Input are two strings a and b consisting only of 1s and 0s.\n///\
    \ Perform binary XOR on these inputs and return result also as a string.\n///\
    \ >>> string_xor(a: \"010\", b: \"110\")\n/// \"100\"\nfunc string_xor(a: String,\
    \ b: String) -> String {\n    let res = String(zip(a, b).map { String(Int(String($0))!\
    \ ^ Int(String($1))!) })\n    return res\n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(string_xor(a: \"111000\", b: \"101010\") == \"010010\")\nassert(string_xor(a:\
    \ \"1\", b: \"1\") == \"0\")\nassert(string_xor(a: \"0101\", b: \"0000\") == \"\
    0101\")"
  status: SyntaxError
  stderr: "/tmp/tmpfoqam4ov.swift:7:15: error: the compiler is unable to type-check\
    \ this expression in reasonable time; try breaking up the expression into distinct\
    \ sub-expressions\n    let res = String(zip(a, b).map { String(Int(String($0))!\
    \ ^ Int(String($1))!) })\n              ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n"
  stdout: ''
  timestamp: 1659978653
- exit_code: 1
  program: "\n/// Input are two strings a and b consisting only of 1s and 0s.\n///\
    \ Perform binary XOR on these inputs and return result also as a string.\n///\
    \ >>> string_xor(a: \"010\", b: \"110\")\n/// \"100\"\nfunc string_xor(a: String,\
    \ b: String) -> String {\n    let intA = BigUInt(a, radix: 2)!\n    let intB =\
    \ BigUInt(b, radix: 2)!\n    let result = intA ^ intB\n    return String(result,\
    \ radix: 2)\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n\
    \    if left.count != right.count {\n        return false\n    }\n    for (l,\
    \ r) in zip(left, right) {\n        if l != r {\n            return false\n  \
    \      }\n    }\n    return true\n}\n            \nassert(string_xor(a: \"111000\"\
    , b: \"101010\") == \"010010\")\nassert(string_xor(a: \"1\", b: \"1\") == \"0\"\
    )\nassert(string_xor(a: \"0101\", b: \"0000\") == \"0101\")"
  status: SyntaxError
  stderr: "/tmp/tmpvzm7h8ys.swift:7:16: error: cannot find 'BigUInt' in scope\n  \
    \  let intA = BigUInt(a, radix: 2)!\n               ^~~~~~~\n/tmp/tmpvzm7h8ys.swift:8:16:\
    \ error: cannot find 'BigUInt' in scope\n    let intB = BigUInt(b, radix: 2)!\n\
    \               ^~~~~~~\n"
  stdout: ''
  timestamp: 1659978479
- exit_code: 1
  program: "\n/// Input are two strings a and b consisting only of 1s and 0s.\n///\
    \ Perform binary XOR on these inputs and return result also as a string.\n///\
    \ >>> string_xor(a: \"010\", b: \"110\")\n/// \"100\"\nfunc string_xor(a: String,\
    \ b: String) -> String {\n    var result = \"\"\n    for (index, _) in a.characters.enumerated()\
    \ {\n        let a_bit = a[index]\n        let b_bit = b[index]\n        result\
    \ += \"\\(a_bit ^ b_bit)\"\n    }\n    return result\n}\n\n\nfunc ==(left: [(Int,\
    \ Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n\
    \        return false\n    }\n    for (l, r) in zip(left, right) {\n        if\
    \ l != r {\n            return false\n        }\n    }\n    return true\n}\n \
    \           \nassert(string_xor(a: \"111000\", b: \"101010\") == \"010010\")\n\
    assert(string_xor(a: \"1\", b: \"1\") == \"0\")\nassert(string_xor(a: \"0101\"\
    , b: \"0000\") == \"0101\")"
  status: SyntaxError
  stderr: "/tmp/tmp54pgdvmv.swift:8:25: error: 'characters' is unavailable: Please\
    \ use String directly\n    for (index, _) in a.characters.enumerated() {\n   \
    \                     ^~~~~~~~~~\nSwift.String:5:16: note: 'characters' was obsoleted\
    \ in Swift 5.0\n    public var characters: String { get set }\n              \
    \ ^\n/tmp/tmp54pgdvmv.swift:9:21: error: 'subscript(_:)' is unavailable: cannot\
    \ subscript String with an Int, use a String.Index instead.\n        let a_bit\
    \ = a[index]\n                    ^~~~~~~~\nSwift.String:3:12: note: 'subscript(_:)'\
    \ has been explicitly marked unavailable here\n    public subscript(i: Int) ->\
    \ Character { get }\n           ^\n/tmp/tmp54pgdvmv.swift:10:21: error: 'subscript(_:)'\
    \ is unavailable: cannot subscript String with an Int, use a String.Index instead.\n\
    \        let b_bit = b[index]\n                    ^~~~~~~~\nSwift.String:3:12:\
    \ note: 'subscript(_:)' has been explicitly marked unavailable here\n    public\
    \ subscript(i: Int) -> Character { get }\n           ^\n/tmp/tmp54pgdvmv.swift:11:28:\
    \ error: binary operator '^' cannot be applied to two 'Character' operands\n \
    \       result += \"\\(a_bit ^ b_bit)\"\n                     ~~~~~ ^ ~~~~~\n"
  stdout: ''
  timestamp: 1659978479
- exit_code: -4
  program: "\n/// Input are two strings a and b consisting only of 1s and 0s.\n///\
    \ Perform binary XOR on these inputs and return result also as a string.\n///\
    \ >>> string_xor(a: \"010\", b: \"110\")\n/// \"100\"\nfunc string_xor(a: String,\
    \ b: String) -> String {\n    return \"\"\n}\n\n\nfunc ==(left: [(Int, Int)],\
    \ right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n       \
    \ return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r\
    \ {\n            return false\n        }\n    }\n    return true\n}\n        \
    \    \nassert(string_xor(a: \"111000\", b: \"101010\") == \"010010\")\nassert(string_xor(a:\
    \ \"1\", b: \"1\") == \"0\")\nassert(string_xor(a: \"0101\", b: \"0000\") == \"\
    0101\")"
  status: Exception
  stderr: 'tmp1ma40nkp/tmp1ma40nkp.swift:23: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b0563602c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b05632f9b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b05632f9988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b05632f87b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmp1ma40nkp                        0x0000563c4899b33b <unavailable> + 4923

    5    libc.so.6                          0x00002b05637ee460 __libc_start_main +
    245

    6    tmp1ma40nkp                        0x0000563c4899af49 <unavailable> + 3913

    '
  stdout: ''
  timestamp: 1659978479
- exit_code: 1
  program: "\n/// Input are two strings a and b consisting only of 1s and 0s.\n///\
    \ Perform binary XOR on these inputs and return result also as a string.\n///\
    \ >>> string_xor(a: \"010\", b: \"110\")\n/// \"100\"\nfunc string_xor(a: String,\
    \ b: String) -> String {\n    var result = \"\"\n    for i in 0..<a.characters.count\
    \ {\n        let aChar = a[a.startIndex.advancedBy(i)]\n        let bChar = b[b.startIndex.advancedBy(i)]\n\
    \        if aChar == bChar {\n            result.append(\"0\")\n        } else\
    \ {\n            result.append(\"1\")\n        }\n    }\n    return result\n}\n\
    \n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(string_xor(a: \"111000\", b: \"101010\") == \"\
    010010\")\nassert(string_xor(a: \"1\", b: \"1\") == \"0\")\nassert(string_xor(a:\
    \ \"0101\", b: \"0000\") == \"0101\")"
  status: SyntaxError
  stderr: "/tmp/tmpk8fzn2j5.swift:8:20: error: 'characters' is unavailable: Please\
    \ use String directly\n    for i in 0..<a.characters.count {\n               \
    \    ^~~~~~~~~~\nSwift.String:5:16: note: 'characters' was obsoleted in Swift\
    \ 5.0\n    public var characters: String { get set }\n               ^\n/tmp/tmpk8fzn2j5.swift:9:36:\
    \ error: value of type 'String.Index' has no member 'advancedBy'\n        let\
    \ aChar = a[a.startIndex.advancedBy(i)]\n                      ~~~~~~~~~~~~ ^~~~~~~~~~\n\
    /tmp/tmpk8fzn2j5.swift:10:36: error: value of type 'String.Index' has no member\
    \ 'advancedBy'\n        let bChar = b[b.startIndex.advancedBy(i)]\n          \
    \            ~~~~~~~~~~~~ ^~~~~~~~~~\n"
  stdout: ''
  timestamp: 1659978479
- exit_code: 0
  program: "\n/// Input are two strings a and b consisting only of 1s and 0s.\n///\
    \ Perform binary XOR on these inputs and return result also as a string.\n///\
    \ >>> string_xor(a: \"010\", b: \"110\")\n/// \"100\"\nfunc string_xor(a: String,\
    \ b: String) -> String {\n    if a.count != b.count {\n        print(\"lengths\
    \ of strings are not equal\")\n        return \"Error\"\n    }\n    var a_nums\
    \ = [Int]()\n    var b_nums = [Int]()\n    for i in a {\n        if i == \"0\"\
    \ {\n            a_nums.append(0)\n        } else if i == \"1\" {\n          \
    \  a_nums.append(1)\n        } else {\n            print(\"a has a char that is\
    \ not 0 or 1\")\n            return \"Error\"\n        }\n    }\n    for i in\
    \ b {\n        if i == \"0\" {\n            b_nums.append(0)\n        } else if\
    \ i == \"1\" {\n            b_nums.append(1)\n        } else {\n            print(\"\
    b has a char that is not 0 or 1\")\n            return \"Error\"\n        }\n\
    \    }\n    var result = [Int]()\n    for i in 0..<a_nums.count {\n        if\
    \ a_nums[i] != b_nums[i] {\n            result.append(1)\n        } else {\n \
    \           result.append(0)\n        }\n    }\n    var result_string = \"\"\n\
    \    for i in result {\n        result_string.append(String(i))\n    }\n    return\
    \ result_string\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool\
    \ {\n    if left.count != right.count {\n        return false\n    }\n    for\
    \ (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(string_xor(a: \"111000\"\
    , b: \"101010\") == \"010010\")\nassert(string_xor(a: \"1\", b: \"1\") == \"0\"\
    )\nassert(string_xor(a: \"0101\", b: \"0000\") == \"0101\")"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659978479
- exit_code: 0
  program: "\n/// Input are two strings a and b consisting only of 1s and 0s.\n///\
    \ Perform binary XOR on these inputs and return result also as a string.\n///\
    \ >>> string_xor(a: \"010\", b: \"110\")\n/// \"100\"\nfunc string_xor(a: String,\
    \ b: String) -> String {\n    let aa = a.unicodeScalars.map { UInt8($0.value)\
    \ }\n    let bb = b.unicodeScalars.map { UInt8($0.value) }\n    let l = zip(aa,\
    \ bb).map { String(Int($0) ^ Int($1)) }\n    return l.joined()\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(string_xor(a: \"111000\", b: \"101010\") == \"010010\"\
    )\nassert(string_xor(a: \"1\", b: \"1\") == \"0\")\nassert(string_xor(a: \"0101\"\
    , b: \"0000\") == \"0101\")"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659978479
- exit_code: 1
  program: "\n/// Input are two strings a and b consisting only of 1s and 0s.\n///\
    \ Perform binary XOR on these inputs and return result also as a string.\n///\
    \ >>> string_xor(a: \"010\", b: \"110\")\n/// \"100\"\nfunc string_xor(a: String,\
    \ b: String) -> String {\n    var output: String = \"\"\n    let a: String = String(a.reversed())\n\
    \    let b: String = String(b.reversed())\n    for i in 0..<min(a.count, b.count)\
    \ {\n        if a[i] == b[i] {\n            output.append(\"0\")\n        } else\
    \ {\n            output.append(\"1\")\n        }\n    }\n    if a.count > b.count\
    \ {\n        for i in b.count..<a.count {\n            output.append(a[i])\n \
    \       }\n    } else if b.count > a.count {\n        for i in a.count..<b.count\
    \ {\n            output.append(b[i])\n        }\n    }\n    return String(output.reversed())\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(string_xor(a: \"111000\", b: \"101010\") == \"\
    010010\")\nassert(string_xor(a: \"1\", b: \"1\") == \"0\")\nassert(string_xor(a:\
    \ \"0101\", b: \"0000\") == \"0101\")"
  status: SyntaxError
  stderr: "/tmp/tmpjl0a2zzk.swift:11:12: error: 'subscript(_:)' is unavailable: cannot\
    \ subscript String with an Int, use a String.Index instead.\n        if a[i] ==\
    \ b[i] {\n           ^~~~\nSwift.String:3:12: note: 'subscript(_:)' has been explicitly\
    \ marked unavailable here\n    public subscript(i: Int) -> Character { get }\n\
    \           ^\n/tmp/tmpjl0a2zzk.swift:11:20: error: 'subscript(_:)' is unavailable:\
    \ cannot subscript String with an Int, use a String.Index instead.\n        if\
    \ a[i] == b[i] {\n                   ^~~~\nSwift.String:3:12: note: 'subscript(_:)'\
    \ has been explicitly marked unavailable here\n    public subscript(i: Int) ->\
    \ Character { get }\n           ^\n/tmp/tmpjl0a2zzk.swift:19:27: error: 'subscript(_:)'\
    \ is unavailable: cannot subscript String with an Int, use a String.Index instead.\n\
    \            output.append(a[i])\n                          ^~~~\nSwift.String:3:12:\
    \ note: 'subscript(_:)' has been explicitly marked unavailable here\n    public\
    \ subscript(i: Int) -> Character { get }\n           ^\n/tmp/tmpjl0a2zzk.swift:23:27:\
    \ error: 'subscript(_:)' is unavailable: cannot subscript String with an Int,\
    \ use a String.Index instead.\n            output.append(b[i])\n             \
    \             ^~~~\nSwift.String:3:12: note: 'subscript(_:)' has been explicitly\
    \ marked unavailable here\n    public subscript(i: Int) -> Character { get }\n\
    \           ^\n"
  stdout: ''
  timestamp: 1659978479
- exit_code: 0
  program: "\n/// Input are two strings a and b consisting only of 1s and 0s.\n///\
    \ Perform binary XOR on these inputs and return result also as a string.\n///\
    \ >>> string_xor(a: \"010\", b: \"110\")\n/// \"100\"\nfunc string_xor(a: String,\
    \ b: String) -> String {\n    var result = [Character]()\n    let arr_a = Array(a)\n\
    \    let arr_b = Array(b)\n    for (index, _) in arr_a.enumerated() {\n      \
    \  if arr_a[index] == arr_b[index] {\n            result.append(\"0\")\n     \
    \   } else {\n            result.append(\"1\")\n        }\n    }\n    return String(result)\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(string_xor(a: \"111000\", b: \"101010\") == \"\
    010010\")\nassert(string_xor(a: \"1\", b: \"1\") == \"0\")\nassert(string_xor(a:\
    \ \"0101\", b: \"0000\") == \"0101\")"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659978479
- exit_code: 0
  program: "\n/// Input are two strings a and b consisting only of 1s and 0s.\n///\
    \ Perform binary XOR on these inputs and return result also as a string.\n///\
    \ >>> string_xor(a: \"010\", b: \"110\")\n/// \"100\"\nfunc string_xor(a: String,\
    \ b: String) -> String {\n\treturn String(\n\t\tzip(a, b).map { a, b in\n\t\t\t\
    return a == b ? \"0\" : \"1\"\n\t\t})\n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(string_xor(a: \"111000\", b: \"101010\") == \"010010\")\nassert(string_xor(a:\
    \ \"1\", b: \"1\") == \"0\")\nassert(string_xor(a: \"0101\", b: \"0000\") == \"\
    0101\")"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659978479
- exit_code: 1
  program: "\n/// Input are two strings a and b consisting only of 1s and 0s.\n///\
    \ Perform binary XOR on these inputs and return result also as a string.\n///\
    \ >>> string_xor(a: \"010\", b: \"110\")\n/// \"100\"\nfunc string_xor(a: String,\
    \ b: String) -> String {\n    var result = \"\"\n    for i in 0..<a.count {\n\
    \        result += String(Int(String(a[i]))! ^ Int(String(b[i]))!)\n    }\n  \
    \  return result\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool\
    \ {\n    if left.count != right.count {\n        return false\n    }\n    for\
    \ (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(string_xor(a: \"111000\"\
    , b: \"101010\") == \"010010\")\nassert(string_xor(a: \"1\", b: \"1\") == \"0\"\
    )\nassert(string_xor(a: \"0101\", b: \"0000\") == \"0101\")"
  status: SyntaxError
  stderr: "/tmp/tmpaqw33skn.swift:9:37: error: 'subscript(_:)' is unavailable: cannot\
    \ subscript String with an Int, use a String.Index instead.\n        result +=\
    \ String(Int(String(a[i]))! ^ Int(String(b[i]))!)\n                          \
    \          ^~~~\nSwift.String:3:12: note: 'subscript(_:)' has been explicitly\
    \ marked unavailable here\n    public subscript(i: Int) -> Character { get }\n\
    \           ^\n/tmp/tmpaqw33skn.swift:9:58: error: 'subscript(_:)' is unavailable:\
    \ cannot subscript String with an Int, use a String.Index instead.\n        result\
    \ += String(Int(String(a[i]))! ^ Int(String(b[i]))!)\n                       \
    \                                  ^~~~\nSwift.String:3:12: note: 'subscript(_:)'\
    \ has been explicitly marked unavailable here\n    public subscript(i: Int) ->\
    \ Character { get }\n           ^\n"
  stdout: ''
  timestamp: 1659978480
- exit_code: 0
  program: "\n/// Input are two strings a and b consisting only of 1s and 0s.\n///\
    \ Perform binary XOR on these inputs and return result also as a string.\n///\
    \ >>> string_xor(a: \"010\", b: \"110\")\n/// \"100\"\nfunc string_xor(a: String,\
    \ b: String) -> String {\n\tvar result = \"\"\n\tfor (i,j) in zip(a,b) {\n\t\t\
    let char_a = i.asciiValue! - 48\n\t\tlet char_b = j.asciiValue! - 48\n\t\tresult\
    \ += String(char_a ^ char_b)\n\t}\n\treturn result\n}\n\n\nfunc ==(left: [(Int,\
    \ Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n\
    \        return false\n    }\n    for (l, r) in zip(left, right) {\n        if\
    \ l != r {\n            return false\n        }\n    }\n    return true\n}\n \
    \           \nassert(string_xor(a: \"111000\", b: \"101010\") == \"010010\")\n\
    assert(string_xor(a: \"1\", b: \"1\") == \"0\")\nassert(string_xor(a: \"0101\"\
    , b: \"0000\") == \"0101\")"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659978479
- exit_code: 0
  program: "\n/// Input are two strings a and b consisting only of 1s and 0s.\n///\
    \ Perform binary XOR on these inputs and return result also as a string.\n///\
    \ >>> string_xor(a: \"010\", b: \"110\")\n/// \"100\"\nfunc string_xor(a: String,\
    \ b: String) -> String {\n    var output = \"\"\n    let a = Array(a)\n    let\
    \ b = Array(b)\n    for index in 0 ..< a.count {\n        output += a[index] ==\
    \ b[index] ? \"0\" : \"1\"\n    }\n    return output\n}\n\n\nfunc ==(left: [(Int,\
    \ Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n\
    \        return false\n    }\n    for (l, r) in zip(left, right) {\n        if\
    \ l != r {\n            return false\n        }\n    }\n    return true\n}\n \
    \           \nassert(string_xor(a: \"111000\", b: \"101010\") == \"010010\")\n\
    assert(string_xor(a: \"1\", b: \"1\") == \"0\")\nassert(string_xor(a: \"0101\"\
    , b: \"0000\") == \"0101\")"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659978479
- exit_code: 1
  program: "\n/// Input are two strings a and b consisting only of 1s and 0s.\n///\
    \ Perform binary XOR on these inputs and return result also as a string.\n///\
    \ >>> string_xor(a: \"010\", b: \"110\")\n/// \"100\"\nfunc string_xor(a: String,\
    \ b: String) -> String {\n    guard a.count == b.count else {\n        fatalError(\"\
    Expected inputs to be of same length.\")\n    }\n    var result = \"\"\n    for\
    \ i in 0..<a.count {\n        if a[i] == b[i] {\n            result += \"0\"\n\
    \        } else {\n            result += \"1\"\n        }\n    }\n    return result\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(string_xor(a: \"111000\", b: \"101010\") == \"\
    010010\")\nassert(string_xor(a: \"1\", b: \"1\") == \"0\")\nassert(string_xor(a:\
    \ \"0101\", b: \"0000\") == \"0101\")"
  status: SyntaxError
  stderr: "/tmp/tmp2mf4dgvi.swift:12:12: error: 'subscript(_:)' is unavailable: cannot\
    \ subscript String with an Int, use a String.Index instead.\n        if a[i] ==\
    \ b[i] {\n           ^~~~\nSwift.String:3:12: note: 'subscript(_:)' has been explicitly\
    \ marked unavailable here\n    public subscript(i: Int) -> Character { get }\n\
    \           ^\n/tmp/tmp2mf4dgvi.swift:12:20: error: 'subscript(_:)' is unavailable:\
    \ cannot subscript String with an Int, use a String.Index instead.\n        if\
    \ a[i] == b[i] {\n                   ^~~~\nSwift.String:3:12: note: 'subscript(_:)'\
    \ has been explicitly marked unavailable here\n    public subscript(i: Int) ->\
    \ Character { get }\n           ^\n"
  stdout: ''
  timestamp: 1659978479
- exit_code: -4
  program: "\n/// Input are two strings a and b consisting only of 1s and 0s.\n///\
    \ Perform binary XOR on these inputs and return result also as a string.\n///\
    \ >>> string_xor(a: \"010\", b: \"110\")\n/// \"100\"\nfunc string_xor(a: String,\
    \ b: String) -> String {\n    guard a.count == b.count else { return \"\" }\n\
    \    let aCharSet = Set(a)\n    let bCharSet = Set(b)\n    let count = a.count\n\
    \    let hasAll1 = aCharSet.contains(\"1\") && bCharSet.contains(\"1\")\n    let\
    \ hasAll0 = aCharSet.contains(\"0\") && bCharSet.contains(\"0\")\n    if hasAll1\
    \ {\n        return String(repeating: \"0\", count: count)\n    } else if hasAll0\
    \ {\n        return String(repeating: \"0\", count: count)\n    } else {\n   \
    \     var result = \"\"\n        for i in 0..<count {\n            let a = String(a[a.index(a.startIndex,\
    \ offsetBy: i)])\n            let b = String(b[b.index(b.startIndex, offsetBy:\
    \ i)])\n            result += \"\\(Int(a)! ^ Int(b)!)\"\n        }\n        return\
    \ result\n    }\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool\
    \ {\n    if left.count != right.count {\n        return false\n    }\n    for\
    \ (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(string_xor(a: \"111000\"\
    , b: \"101010\") == \"010010\")\nassert(string_xor(a: \"1\", b: \"1\") == \"0\"\
    )\nassert(string_xor(a: \"0101\", b: \"0000\") == \"0101\")"
  status: Exception
  stderr: 'tmppycjhxjb/tmppycjhxjb.swift:41: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002af4ce541c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002af4ce238b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002af4ce238988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002af4ce2377b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmppycjhxjb                        0x0000558d7ec10c8b <unavailable> + 7307

    5    libc.so.6                          0x00002af4ce72d460 __libc_start_main +
    245

    6    tmppycjhxjb                        0x0000558d7ec10899 <unavailable> + 6297

    '
  stdout: ''
  timestamp: 1659978479
- exit_code: 1
  program: "\n/// Input are two strings a and b consisting only of 1s and 0s.\n///\
    \ Perform binary XOR on these inputs and return result also as a string.\n///\
    \ >>> string_xor(a: \"010\", b: \"110\")\n/// \"100\"\nfunc string_xor(a: String,\
    \ b: String) -> String {\n    var output = \"\"\n    for i in 0..<a.count {\n\
    \        let charA = a[i]\n        let charB = b[i]\n        let char: Character\
    \ = charA == charB ? \"0\" : \"1\"\n        output.append(char)\n    }\n    return\
    \ output\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n\
    \    if left.count != right.count {\n        return false\n    }\n    for (l,\
    \ r) in zip(left, right) {\n        if l != r {\n            return false\n  \
    \      }\n    }\n    return true\n}\n            \nassert(string_xor(a: \"111000\"\
    , b: \"101010\") == \"010010\")\nassert(string_xor(a: \"1\", b: \"1\") == \"0\"\
    )\nassert(string_xor(a: \"0101\", b: \"0000\") == \"0101\")"
  status: SyntaxError
  stderr: "/tmp/tmp1xxis0ti.swift:9:21: error: 'subscript(_:)' is unavailable: cannot\
    \ subscript String with an Int, use a String.Index instead.\n        let charA\
    \ = a[i]\n                    ^~~~\nSwift.String:3:12: note: 'subscript(_:)' has\
    \ been explicitly marked unavailable here\n    public subscript(i: Int) -> Character\
    \ { get }\n           ^\n/tmp/tmp1xxis0ti.swift:10:21: error: 'subscript(_:)'\
    \ is unavailable: cannot subscript String with an Int, use a String.Index instead.\n\
    \        let charB = b[i]\n                    ^~~~\nSwift.String:3:12: note:\
    \ 'subscript(_:)' has been explicitly marked unavailable here\n    public subscript(i:\
    \ Int) -> Character { get }\n           ^\n"
  stdout: ''
  timestamp: 1659978479
- exit_code: 0
  program: "\n/// Input are two strings a and b consisting only of 1s and 0s.\n///\
    \ Perform binary XOR on these inputs and return result also as a string.\n///\
    \ >>> string_xor(a: \"010\", b: \"110\")\n/// \"100\"\nfunc string_xor(a: String,\
    \ b: String) -> String {\n    var result = \"\"\n    let digits = zip(a, b)\n\
    \    for pair in digits {\n        let (a, b) = pair\n        let a_num = Int(String(a))!\n\
    \        let b_num = Int(String(b))!\n        result += String(a_num ^ b_num)\n\
    \    }\n    return result\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(string_xor(a:\
    \ \"111000\", b: \"101010\") == \"010010\")\nassert(string_xor(a: \"1\", b: \"\
    1\") == \"0\")\nassert(string_xor(a: \"0101\", b: \"0000\") == \"0101\")"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659978479
- exit_code: 1
  program: "\n/// Input are two strings a and b consisting only of 1s and 0s.\n///\
    \ Perform binary XOR on these inputs and return result also as a string.\n///\
    \ >>> string_xor(a: \"010\", b: \"110\")\n/// \"100\"\nfunc string_xor(a: String,\
    \ b: String) -> String {\n\tlet c = zip(a, b).map { $0 == $1 ? \"0\" : \"1\" }\n\
    \treturn String(c)\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) ->\
    \ Bool {\n    if left.count != right.count {\n        return false\n    }\n  \
    \  for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(string_xor(a: \"111000\"\
    , b: \"101010\") == \"010010\")\nassert(string_xor(a: \"1\", b: \"1\") == \"0\"\
    )\nassert(string_xor(a: \"0101\", b: \"0000\") == \"0101\")"
  status: SyntaxError
  stderr: "/tmp/tmpn_gy5exz.swift:8:9: error: no exact matches in call to initializer\
    \ \n        return String(c)\n               ^\nSwift.String:4:12: note: candidate\
    \ requires that the types 'String' and 'Character' be equivalent (requirement\
    \ specified as 'S.Element' == 'Character')\n    public init<S>(_ characters: S)\
    \ where S : Sequence, S.Element == Character\n           ^\nSwift.RangeReplaceableCollection:3:23:\
    \ note: candidate requires that the types 'String.Element' (aka 'Character') and\
    \ 'String' be equivalent (requirement specified as 'Self.Element' == 'S.Element')\n\
    \    @inlinable public init<S>(_ elements: S) where S : Sequence, Self.Element\
    \ == S.Element\n                      ^\nSwift.String:2:12: note: incorrect labels\
    \ for candidate (have: '(_:)', expected: '(describing:)')\n    public init<Subject>(describing\
    \ instance: Subject)\n           ^\nSwift.String:3:23: note: incorrect labels\
    \ for candidate (have: '(_:)', expected: '(describing:)')\n    @inlinable public\
    \ init<Subject>(describing instance: Subject) where Subject : CustomStringConvertible\n\
    \                      ^\nSwift.String:6:12: note: incorrect labels for candidate\
    \ (have: '(_:)', expected: '(reflecting:)')\n    public init<Subject>(reflecting\
    \ subject: Subject)\n           ^\n"
  stdout: ''
  timestamp: 1659978479
- exit_code: 1
  program: "\n/// Input are two strings a and b consisting only of 1s and 0s.\n///\
    \ Perform binary XOR on these inputs and return result also as a string.\n///\
    \ >>> string_xor(a: \"010\", b: \"110\")\n/// \"100\"\nfunc string_xor(a: String,\
    \ b: String) -> String {\n    let result = zip(a, b).map {\n        switch ($0,\
    \ $1) {\n        case (\"0\", \"0\"): return \"0\"\n        case (\"1\", \"1\"\
    ): return \"0\"\n        default: return \"1\"\n        }\n    }\n    return String(result)\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(string_xor(a: \"111000\", b: \"101010\") == \"\
    010010\")\nassert(string_xor(a: \"1\", b: \"1\") == \"0\")\nassert(string_xor(a:\
    \ \"0101\", b: \"0000\") == \"0101\")"
  status: SyntaxError
  stderr: "/tmp/tmpsqioudds.swift:14:12: error: no exact matches in call to initializer\
    \ \n    return String(result)\n           ^\nSwift.String:4:12: note: candidate\
    \ requires that the types 'String' and 'Character' be equivalent (requirement\
    \ specified as 'S.Element' == 'Character')\n    public init<S>(_ characters: S)\
    \ where S : Sequence, S.Element == Character\n           ^\nSwift.RangeReplaceableCollection:3:23:\
    \ note: candidate requires that the types 'String.Element' (aka 'Character') and\
    \ 'String' be equivalent (requirement specified as 'Self.Element' == 'S.Element')\n\
    \    @inlinable public init<S>(_ elements: S) where S : Sequence, Self.Element\
    \ == S.Element\n                      ^\nSwift.String:2:12: note: incorrect labels\
    \ for candidate (have: '(_:)', expected: '(describing:)')\n    public init<Subject>(describing\
    \ instance: Subject)\n           ^\nSwift.String:3:23: note: incorrect labels\
    \ for candidate (have: '(_:)', expected: '(describing:)')\n    @inlinable public\
    \ init<Subject>(describing instance: Subject) where Subject : CustomStringConvertible\n\
    \                      ^\nSwift.String:6:12: note: incorrect labels for candidate\
    \ (have: '(_:)', expected: '(reflecting:)')\n    public init<Subject>(reflecting\
    \ subject: Subject)\n           ^\n"
  stdout: ''
  timestamp: 1659978479
- exit_code: 1
  program: "\n/// Input are two strings a and b consisting only of 1s and 0s.\n///\
    \ Perform binary XOR on these inputs and return result also as a string.\n///\
    \ >>> string_xor(a: \"010\", b: \"110\")\n/// \"100\"\nfunc string_xor(a: String,\
    \ b: String) -> String {\n    let aa = a.toIntArray()\n    let bb = b.toIntArray()\n\
    \    return binary_xor(a: aa, b: bb).toBinaryString()\n}\n\n\nfunc ==(left: [(Int,\
    \ Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n\
    \        return false\n    }\n    for (l, r) in zip(left, right) {\n        if\
    \ l != r {\n            return false\n        }\n    }\n    return true\n}\n \
    \           \nassert(string_xor(a: \"111000\", b: \"101010\") == \"010010\")\n\
    assert(string_xor(a: \"1\", b: \"1\") == \"0\")\nassert(string_xor(a: \"0101\"\
    , b: \"0000\") == \"0101\")"
  status: SyntaxError
  stderr: "/tmp/tmpfw06irlx.swift:7:16: error: value of type 'String' has no member\
    \ 'toIntArray'\n    let aa = a.toIntArray()\n             ~ ^~~~~~~~~~\n/tmp/tmpfw06irlx.swift:8:16:\
    \ error: value of type 'String' has no member 'toIntArray'\n    let bb = b.toIntArray()\n\
    \             ~ ^~~~~~~~~~\n/tmp/tmpfw06irlx.swift:9:12: error: cannot find 'binary_xor'\
    \ in scope\n    return binary_xor(a: aa, b: bb).toBinaryString()\n           ^~~~~~~~~~\n"
  stdout: ''
  timestamp: 1659978479
- exit_code: -4
  program: "\n/// Input are two strings a and b consisting only of 1s and 0s.\n///\
    \ Perform binary XOR on these inputs and return result also as a string.\n///\
    \ >>> string_xor(a: \"010\", b: \"110\")\n/// \"100\"\nfunc string_xor(a: String,\
    \ b: String) -> String {\n    let x = UInt8(a, radix: 2)!\n    let y = UInt8(b,\
    \ radix: 2)!\n    let res = x ^ y\n    return String(res, radix: 2)\n}\n\n\nfunc\
    \ ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count !=\
    \ right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(string_xor(a: \"111000\", b: \"101010\") == \"\
    010010\")\nassert(string_xor(a: \"1\", b: \"1\") == \"0\")\nassert(string_xor(a:\
    \ \"0101\", b: \"0000\") == \"0101\")"
  status: Exception
  stderr: 'tmpb_uyo6z2/tmpb_uyo6z2.swift:26: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002ba735dc1c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002ba735ab8b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002ba735ab8988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002ba735ab77b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpb_uyo6z2                        0x00005615009325fb <unavailable> + 5627

    5    libc.so.6                          0x00002ba735fad460 __libc_start_main +
    245

    6    tmpb_uyo6z2                        0x0000561500932209 <unavailable> + 4617

    '
  stdout: ''
  timestamp: 1659978479
- exit_code: 1
  program: "\n/// Input are two strings a and b consisting only of 1s and 0s.\n///\
    \ Perform binary XOR on these inputs and return result also as a string.\n///\
    \ >>> string_xor(a: \"010\", b: \"110\")\n/// \"100\"\nfunc string_xor(a: String,\
    \ b: String) -> String {\n    let set1 = CharacterSet(charactersIn: a)\n    let\
    \ set2 = CharacterSet(charactersIn: b)\n    let nums = CharacterSet.decimalDigits\n\
    \    let alphabet = CharacterSet.letters\n    let alphanums = CharacterSet.alphanumerics\n\
    \    let a_valid = set1.isSubset(of: nums)\n    let b_valid = set2.isSubset(of:\
    \ nums)\n    if !a_valid || !b_valid {\n        print(\"a and b must be strings\
    \ of 1s and 0s\")\n        return \"\"\n    }\n    let a_len = a.count\n    let\
    \ b_len = b.count\n    if a_len != b_len {\n        print(\"a and b must be the\
    \ same length\")\n        return \"\"\n    }\n    var c = \"\"\n    for i in 0..<a_len\
    \ {\n        if (a[i] == \"0\" && b[i] == \"0\") || (a[i] == \"1\" && b[i] ==\
    \ \"1\") {\n            c += \"0\"\n        } else {\n            c += \"1\"\n\
    \        }\n    }\n    return c\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int,\
    \ Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n\
    \    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n          \
    \  return false\n        }\n    }\n    return true\n}\n            \nassert(string_xor(a:\
    \ \"111000\", b: \"101010\") == \"010010\")\nassert(string_xor(a: \"1\", b: \"\
    1\") == \"0\")\nassert(string_xor(a: \"0101\", b: \"0000\") == \"0101\")"
  status: SyntaxError
  stderr: "/tmp/tmpmz7m36j6.swift:7:16: error: cannot find 'CharacterSet' in scope\n\
    \    let set1 = CharacterSet(charactersIn: a)\n               ^~~~~~~~~~~~\n/tmp/tmpmz7m36j6.swift:8:16:\
    \ error: cannot find 'CharacterSet' in scope\n    let set2 = CharacterSet(charactersIn:\
    \ b)\n               ^~~~~~~~~~~~\n/tmp/tmpmz7m36j6.swift:9:16: error: cannot\
    \ find 'CharacterSet' in scope\n    let nums = CharacterSet.decimalDigits\n  \
    \             ^~~~~~~~~~~~\n/tmp/tmpmz7m36j6.swift:10:20: error: cannot find 'CharacterSet'\
    \ in scope\n    let alphabet = CharacterSet.letters\n                   ^~~~~~~~~~~~\n\
    /tmp/tmpmz7m36j6.swift:11:21: error: cannot find 'CharacterSet' in scope\n   \
    \ let alphanums = CharacterSet.alphanumerics\n                    ^~~~~~~~~~~~\n\
    /tmp/tmpmz7m36j6.swift:26:13: error: 'subscript(_:)' is unavailable: cannot subscript\
    \ String with an Int, use a String.Index instead.\n        if (a[i] == \"0\" &&\
    \ b[i] == \"0\") || (a[i] == \"1\" && b[i] == \"1\") {\n            ^~~~\nSwift.String:3:12:\
    \ note: 'subscript(_:)' has been explicitly marked unavailable here\n    public\
    \ subscript(i: Int) -> Character { get }\n           ^\n/tmp/tmpmz7m36j6.swift:26:28:\
    \ error: 'subscript(_:)' is unavailable: cannot subscript String with an Int,\
    \ use a String.Index instead.\n        if (a[i] == \"0\" && b[i] == \"0\") ||\
    \ (a[i] == \"1\" && b[i] == \"1\") {\n                           ^~~~\nSwift.String:3:12:\
    \ note: 'subscript(_:)' has been explicitly marked unavailable here\n    public\
    \ subscript(i: Int) -> Character { get }\n           ^\n/tmp/tmpmz7m36j6.swift:26:45:\
    \ error: 'subscript(_:)' is unavailable: cannot subscript String with an Int,\
    \ use a String.Index instead.\n        if (a[i] == \"0\" && b[i] == \"0\") ||\
    \ (a[i] == \"1\" && b[i] == \"1\") {\n                                       \
    \     ^~~~\nSwift.String:3:12: note: 'subscript(_:)' has been explicitly marked\
    \ unavailable here\n    public subscript(i: Int) -> Character { get }\n      \
    \     ^\n/tmp/tmpmz7m36j6.swift:26:60: error: 'subscript(_:)' is unavailable:\
    \ cannot subscript String with an Int, use a String.Index instead.\n        if\
    \ (a[i] ="
  stdout: ''
  timestamp: 1659978479
- exit_code: 0
  program: "\n/// Input are two strings a and b consisting only of 1s and 0s.\n///\
    \ Perform binary XOR on these inputs and return result also as a string.\n///\
    \ >>> string_xor(a: \"010\", b: \"110\")\n/// \"100\"\nfunc string_xor(a: String,\
    \ b: String) -> String {\n    //Binary XOR is 0 if a and b are equal, 1 otherwise\n\
    \    return Array(zip(a, b)).map { $0 == $1 ? \"0\" : \"1\" }.joined()\n}\n\n\n\
    func ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(string_xor(a: \"111000\", b: \"101010\") == \"\
    010010\")\nassert(string_xor(a: \"1\", b: \"1\") == \"0\")\nassert(string_xor(a:\
    \ \"0101\", b: \"0000\") == \"0101\")"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659978480
- exit_code: 1
  program: "\n/// Input are two strings a and b consisting only of 1s and 0s.\n///\
    \ Perform binary XOR on these inputs and return result also as a string.\n///\
    \ >>> string_xor(a: \"010\", b: \"110\")\n/// \"100\"\nfunc string_xor(a: String,\
    \ b: String) -> String {\n    var result = \"\"\n    for i in 0..<a.characters.count\
    \ {\n        let c = a[a.startIndex.advancedBy(i)]\n        let d = b[b.startIndex.advancedBy(i)]\n\
    \        if c == d {\n            result += \"0\"\n        } else {\n        \
    \    result += \"1\"\n        }\n    }\n    return result\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(string_xor(a: \"111000\", b: \"101010\") == \"010010\"\
    )\nassert(string_xor(a: \"1\", b: \"1\") == \"0\")\nassert(string_xor(a: \"0101\"\
    , b: \"0000\") == \"0101\")"
  status: SyntaxError
  stderr: "/tmp/tmpun9saxh_.swift:8:20: error: 'characters' is unavailable: Please\
    \ use String directly\n    for i in 0..<a.characters.count {\n               \
    \    ^~~~~~~~~~\nSwift.String:5:16: note: 'characters' was obsoleted in Swift\
    \ 5.0\n    public var characters: String { get set }\n               ^\n/tmp/tmpun9saxh_.swift:9:32:\
    \ error: value of type 'String.Index' has no member 'advancedBy'\n        let\
    \ c = a[a.startIndex.advancedBy(i)]\n                  ~~~~~~~~~~~~ ^~~~~~~~~~\n\
    /tmp/tmpun9saxh_.swift:10:32: error: value of type 'String.Index' has no member\
    \ 'advancedBy'\n        let d = b[b.startIndex.advancedBy(i)]\n              \
    \    ~~~~~~~~~~~~ ^~~~~~~~~~\n"
  stdout: ''
  timestamp: 1659978479
- exit_code: -4
  program: "\n/// Input are two strings a and b consisting only of 1s and 0s.\n///\
    \ Perform binary XOR on these inputs and return result also as a string.\n///\
    \ >>> string_xor(a: \"010\", b: \"110\")\n/// \"100\"\nfunc string_xor(a: String,\
    \ b: String) -> String {\n    return \"\"\n}\n\n\nfunc ==(left: [(Int, Int)],\
    \ right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n       \
    \ return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r\
    \ {\n            return false\n        }\n    }\n    return true\n}\n        \
    \    \nassert(string_xor(a: \"111000\", b: \"101010\") == \"010010\")\nassert(string_xor(a:\
    \ \"1\", b: \"1\") == \"0\")\nassert(string_xor(a: \"0101\", b: \"0000\") == \"\
    0101\")"
  status: Exception
  stderr: 'tmp1ma40nkp/tmp1ma40nkp.swift:23: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b0563602c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b05632f9b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b05632f9988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b05632f87b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmp1ma40nkp                        0x0000563c4899b33b <unavailable> + 4923

    5    libc.so.6                          0x00002b05637ee460 __libc_start_main +
    245

    6    tmp1ma40nkp                        0x0000563c4899af49 <unavailable> + 3913

    '
  stdout: ''
  timestamp: 1659978479
- exit_code: 0
  program: "\n/// Input are two strings a and b consisting only of 1s and 0s.\n///\
    \ Perform binary XOR on these inputs and return result also as a string.\n///\
    \ >>> string_xor(a: \"010\", b: \"110\")\n/// \"100\"\nfunc string_xor(a: String,\
    \ b: String) -> String {\n    if a.count != b.count {\n        return \"\"\n \
    \   }\n    var result = \"\"\n    for (index, c) in a.enumerated() {\n       \
    \ if c == \"0\" && b[b.index(b.startIndex, offsetBy: index)] == \"0\" {\n    \
    \        result += \"0\"\n        } else if c == \"1\" && b[b.index(b.startIndex,\
    \ offsetBy: index)] == \"1\" {\n            result += \"0\"\n        } else {\n\
    \            result += \"1\"\n        }\n    }\n    return result\n}\n\n\nfunc\
    \ ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count !=\
    \ right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(string_xor(a: \"111000\", b: \"101010\") == \"\
    010010\")\nassert(string_xor(a: \"1\", b: \"1\") == \"0\")\nassert(string_xor(a:\
    \ \"0101\", b: \"0000\") == \"0101\")"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659978480
- exit_code: 1
  program: "\n/// Input are two strings a and b consisting only of 1s and 0s.\n///\
    \ Perform binary XOR on these inputs and return result also as a string.\n///\
    \ >>> string_xor(a: \"010\", b: \"110\")\n/// \"100\"\nfunc string_xor(a: String,\
    \ b: String) -> String {\n    guard a.count == b.count else { return \"\" }\n\
    \    let aInt = a.int\n    let bInt = b.int\n    let resultInt = aInt ^ bInt\n\
    \    return String(resultInt, radix: 2)\n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(string_xor(a: \"111000\", b: \"101010\") == \"010010\")\nassert(string_xor(a:\
    \ \"1\", b: \"1\") == \"0\")\nassert(string_xor(a: \"0101\", b: \"0000\") == \"\
    0101\")"
  status: SyntaxError
  stderr: "/tmp/tmpsj9x0c5v.swift:8:18: error: value of type 'String' has no member\
    \ 'int'\n    let aInt = a.int\n               ~ ^~~\n/tmp/tmpsj9x0c5v.swift:9:18:\
    \ error: value of type 'String' has no member 'int'\n    let bInt = b.int\n  \
    \             ~ ^~~\n"
  stdout: ''
  timestamp: 1659978479
- exit_code: 1
  program: "\n/// Input are two strings a and b consisting only of 1s and 0s.\n///\
    \ Perform binary XOR on these inputs and return result also as a string.\n///\
    \ >>> string_xor(a: \"010\", b: \"110\")\n/// \"100\"\nfunc string_xor(a: String,\
    \ b: String) -> String {\n    return String(zip(a, b).map(^))\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(string_xor(a: \"111000\", b: \"101010\") == \"010010\"\
    )\nassert(string_xor(a: \"1\", b: \"1\") == \"0\")\nassert(string_xor(a: \"0101\"\
    , b: \"0000\") == \"0101\")"
  status: SyntaxError
  stderr: "/tmp/tmp5qiefeh9.swift:7:33: error: no exact matches in reference to operator\
    \ function '^'\n    return String(zip(a, b).map(^))\n                        \
    \        ^\nSwift.BinaryInteger:1:17: note: candidate requires that 'String.Element'\
    \ (aka 'Character') conform to 'BinaryInteger' (requirement specified as 'Self'\
    \ : 'BinaryInteger')\npublic protocol BinaryInteger : CustomStringConvertible,\
    \ Hashable, Numeric, Strideable where Self.Magnitude : BinaryInteger, Self.Magnitude\
    \ == Self.Magnitude.Magnitude {\n                ^\nSwift.BinaryInteger:1:11:\
    \ note: candidate requires that 'String.Element' (aka 'Character') conform to\
    \ 'BinaryInteger' (requirement specified as 'Self' : 'BinaryInteger')\nextension\
    \ BinaryInteger {\n          ^\nSwift.SIMD:1:11: note: candidate requires that\
    \ 'String.Element' (aka 'Character') conform to 'SIMD' (requirement specified\
    \ as 'Self' : 'SIMD')\nextension SIMD where Self.Scalar : FixedWidthInteger {\n\
    \          ^\n"
  stdout: ''
  timestamp: 1659978479
- exit_code: 1
  program: "\n/// Input are two strings a and b consisting only of 1s and 0s.\n///\
    \ Perform binary XOR on these inputs and return result also as a string.\n///\
    \ >>> string_xor(a: \"010\", b: \"110\")\n/// \"100\"\nfunc string_xor(a: String,\
    \ b: String) -> String {\n    // make sure that a and b are both of the same length\n\
    \    var a = a\n    var b = b\n    if a.characters.count < b.characters.count\
    \ {\n        let aCount = a.characters.count\n        for _ in 0..<b.characters.count\
    \ - aCount {\n            a = \"0\" + a\n        }\n    } else if a.characters.count\
    \ > b.characters.count {\n        let bCount = b.characters.count\n        for\
    \ _ in 0..<a.characters.count - bCount {\n            b = \"0\" + b\n        }\n\
    \    }\n    // now perform xor\n    var result = \"\"\n    for i in 0..<a.characters.count\
    \ {\n        let aIndex = a.index(a.startIndex, offsetBy: i)\n        let bIndex\
    \ = b.index(b.startIndex, offsetBy: i)\n        let aChar = a[aIndex]\n      \
    \  let bChar = b[bIndex]\n        let aInt = String(aChar).toInt()!\n        let\
    \ bInt = String(bChar).toInt()!\n        let resultInt = aInt ^ bInt\n       \
    \ result += String(resultInt)\n    }\n    return result\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(string_xor(a: \"111000\", b: \"101010\") == \"010010\"\
    )\nassert(string_xor(a: \"1\", b: \"1\") == \"0\")\nassert(string_xor(a: \"0101\"\
    , b: \"0000\") == \"0101\")"
  status: SyntaxError
  stderr: "/tmp/tmpon737bc1.swift:10:10: error: 'characters' is unavailable: Please\
    \ use String directly\n    if a.characters.count < b.characters.count {\n    \
    \     ^~~~~~~~~~\nSwift.String:5:16: note: 'characters' was obsoleted in Swift\
    \ 5.0\n    public var characters: String { get set }\n               ^\n/tmp/tmpon737bc1.swift:10:31:\
    \ error: 'characters' is unavailable: Please use String directly\n    if a.characters.count\
    \ < b.characters.count {\n                              ^~~~~~~~~~\nSwift.String:5:16:\
    \ note: 'characters' was obsoleted in Swift 5.0\n    public var characters: String\
    \ { get set }\n               ^\n/tmp/tmpon737bc1.swift:11:24: error: 'characters'\
    \ is unavailable: Please use String directly\n        let aCount = a.characters.count\n\
    \                       ^~~~~~~~~~\nSwift.String:5:16: note: 'characters' was\
    \ obsoleted in Swift 5.0\n    public var characters: String { get set }\n    \
    \           ^\n/tmp/tmpon737bc1.swift:12:24: error: 'characters' is unavailable:\
    \ Please use String directly\n        for _ in 0..<b.characters.count - aCount\
    \ {\n                       ^~~~~~~~~~\nSwift.String:5:16: note: 'characters'\
    \ was obsoleted in Swift 5.0\n    public var characters: String { get set }\n\
    \               ^\n/tmp/tmpon737bc1.swift:15:17: error: 'characters' is unavailable:\
    \ Please use String directly\n    } else if a.characters.count > b.characters.count\
    \ {\n                ^~~~~~~~~~\nSwift.String:5:16: note: 'characters' was obsoleted\
    \ in Swift 5.0\n    public var characters: String { get set }\n              \
    \ ^\n/tmp/tmpon737bc1.swift:15:38: error: 'characters' is unavailable: Please\
    \ use String directly\n    } else if a.characters.count > b.characters.count {\n\
    \                                     ^~~~~~~~~~\nSwift.String:5:16: note: 'characters'\
    \ was obsoleted in Swift 5.0\n    public var characters: String { get set }\n\
    \               ^\n/tmp/tmpon737bc1.swift:16:24: error: 'characters' is unavailable:\
    \ Please use String directly\n        let bCount = b.characters.count\n      \
    \                 ^~~~~~~~~~\nSwift.String:5:16: note: 'characters' was obsolete"
  stdout: ''
  timestamp: 1659978480
- exit_code: 1
  program: "\n/// Input are two strings a and b consisting only of 1s and 0s.\n///\
    \ Perform binary XOR on these inputs and return result also as a string.\n///\
    \ >>> string_xor(a: \"010\", b: \"110\")\n/// \"100\"\nfunc string_xor(a: String,\
    \ b: String) -> String {\n  let aBytes = [UInt8](a.utf8)\n  let bBytes = [UInt8](b.utf8)\n\
    \  var resultBytes = [UInt8](repeating: 0, count: Swift.max(aBytes.count, bBytes.count))\n\
    \  for i in 0..<resultBytes.count {\n    if i < aBytes.count {\n      resultBytes[i]\
    \ ^= aBytes[i]\n    }\n    if i < bBytes.count {\n      resultBytes[i] ^= bBytes[i]\n\
    \    }\n  }\n  return String(bytes: resultBytes, encoding: .utf8)!\n}\n\n\nfunc\
    \ ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count !=\
    \ right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(string_xor(a: \"111000\", b: \"101010\") == \"\
    010010\")\nassert(string_xor(a: \"1\", b: \"1\") == \"0\")\nassert(string_xor(a:\
    \ \"0101\", b: \"0000\") == \"0101\")"
  status: SyntaxError
  stderr: "/tmp/tmp0m0hkdmz.swift:18:10: error: no exact matches in call to initializer\
    \ \n  return String(bytes: resultBytes, encoding: .utf8)!\n         ^\n/tmp/tmp0m0hkdmz.swift:18:10:\
    \ note: found candidate with type '(Array<_>, _.Type) -> String'\n  return String(bytes:\
    \ resultBytes, encoding: .utf8)!\n         ^\n/tmp/tmp0m0hkdmz.swift:18:10: note:\
    \ found candidate with type '([UInt8]) -> String'\n  return String(bytes: resultBytes,\
    \ encoding: .utf8)!\n         ^\n/tmp/tmp0m0hkdmz.swift:18:10: note: found candidate\
    \ with type '(Substring.UTF8View) -> String?'\n  return String(bytes: resultBytes,\
    \ encoding: .utf8)!\n         ^\n/tmp/tmp0m0hkdmz.swift:18:10: note: found candidate\
    \ with type '(Substring.UTF16View) -> String?'\n  return String(bytes: resultBytes,\
    \ encoding: .utf8)!\n         ^\n"
  stdout: ''
  timestamp: 1659978479
- exit_code: 1
  program: "\n/// Input are two strings a and b consisting only of 1s and 0s.\n///\
    \ Perform binary XOR on these inputs and return result also as a string.\n///\
    \ >>> string_xor(a: \"010\", b: \"110\")\n/// \"100\"\nfunc string_xor(a: String,\
    \ b: String) -> String {\n    var c = \"\"\n    for i in 0..<a.count {\n     \
    \   let a_bit = a[i]\n        let b_bit = b[i]\n        if a_bit == b_bit {\n\
    \            c.append(\"0\")\n        } else {\n            c.append(\"1\")\n\
    \        }\n    }\n    return c\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int,\
    \ Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n\
    \    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n          \
    \  return false\n        }\n    }\n    return true\n}\n            \nassert(string_xor(a:\
    \ \"111000\", b: \"101010\") == \"010010\")\nassert(string_xor(a: \"1\", b: \"\
    1\") == \"0\")\nassert(string_xor(a: \"0101\", b: \"0000\") == \"0101\")"
  status: SyntaxError
  stderr: "/tmp/tmpttcl01d9.swift:9:21: error: 'subscript(_:)' is unavailable: cannot\
    \ subscript String with an Int, use a String.Index instead.\n        let a_bit\
    \ = a[i]\n                    ^~~~\nSwift.String:3:12: note: 'subscript(_:)' has\
    \ been explicitly marked unavailable here\n    public subscript(i: Int) -> Character\
    \ { get }\n           ^\n/tmp/tmpttcl01d9.swift:10:21: error: 'subscript(_:)'\
    \ is unavailable: cannot subscript String with an Int, use a String.Index instead.\n\
    \        let b_bit = b[i]\n                    ^~~~\nSwift.String:3:12: note:\
    \ 'subscript(_:)' has been explicitly marked unavailable here\n    public subscript(i:\
    \ Int) -> Character { get }\n           ^\n"
  stdout: ''
  timestamp: 1659978479
- exit_code: 1
  program: "\n/// Input are two strings a and b consisting only of 1s and 0s.\n///\
    \ Perform binary XOR on these inputs and return result also as a string.\n///\
    \ >>> string_xor(a: \"010\", b: \"110\")\n/// \"100\"\nfunc string_xor(a: String,\
    \ b: String) -> String {\n    var result = \"\"\n    for i in 0..<a.count {\n\
    \        result += String(Int(String(a[i]))! ^ Int(String(b[i]))!)\n    }\n  \
    \  return result\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool\
    \ {\n    if left.count != right.count {\n        return false\n    }\n    for\
    \ (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(string_xor(a: \"111000\"\
    , b: \"101010\") == \"010010\")\nassert(string_xor(a: \"1\", b: \"1\") == \"0\"\
    )\nassert(string_xor(a: \"0101\", b: \"0000\") == \"0101\")"
  status: SyntaxError
  stderr: "/tmp/tmpaqw33skn.swift:9:37: error: 'subscript(_:)' is unavailable: cannot\
    \ subscript String with an Int, use a String.Index instead.\n        result +=\
    \ String(Int(String(a[i]))! ^ Int(String(b[i]))!)\n                          \
    \          ^~~~\nSwift.String:3:12: note: 'subscript(_:)' has been explicitly\
    \ marked unavailable here\n    public subscript(i: Int) -> Character { get }\n\
    \           ^\n/tmp/tmpaqw33skn.swift:9:58: error: 'subscript(_:)' is unavailable:\
    \ cannot subscript String with an Int, use a String.Index instead.\n        result\
    \ += String(Int(String(a[i]))! ^ Int(String(b[i]))!)\n                       \
    \                                  ^~~~\nSwift.String:3:12: note: 'subscript(_:)'\
    \ has been explicitly marked unavailable here\n    public subscript(i: Int) ->\
    \ Character { get }\n           ^\n"
  stdout: ''
  timestamp: 1659978480
- exit_code: 1
  program: "\n/// Input are two strings a and b consisting only of 1s and 0s.\n///\
    \ Perform binary XOR on these inputs and return result also as a string.\n///\
    \ >>> string_xor(a: \"010\", b: \"110\")\n/// \"100\"\nfunc string_xor(a: String,\
    \ b: String) -> String {\n    let xor = zip(a, b).map(String.init).map {\n   \
    \     return Int(String($0))! ^ Int(String($1))!\n    }\n    return xor.map(String.init).joined()\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(string_xor(a: \"111000\", b: \"101010\") == \"\
    010010\")\nassert(string_xor(a: \"1\", b: \"1\") == \"0\")\nassert(string_xor(a:\
    \ \"0101\", b: \"0000\") == \"0101\")"
  status: SyntaxError
  stderr: "/tmp/tmppvz137ai.swift:7:15: error: the compiler is unable to type-check\
    \ this expression in reasonable time; try breaking up the expression into distinct\
    \ sub-expressions\n    let xor = zip(a, b).map(String.init).map {\n          \
    \    ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n"
  stdout: ''
  timestamp: 1659978625
- exit_code: 0
  program: "\n/// Input are two strings a and b consisting only of 1s and 0s.\n///\
    \ Perform binary XOR on these inputs and return result also as a string.\n///\
    \ >>> string_xor(a: \"010\", b: \"110\")\n/// \"100\"\nfunc string_xor(a: String,\
    \ b: String) -> String {\n    let numbers1 = a.flatMap{ Int(String($0)) }\n  \
    \  let numbers2 = b.flatMap{ Int(String($0)) }\n    return zip(numbers1, numbers2).map\
    \ { $0 ^ $1 }.map{ String($0) }.joined()\n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(string_xor(a: \"111000\", b: \"101010\") == \"010010\")\nassert(string_xor(a:\
    \ \"1\", b: \"1\") == \"0\")\nassert(string_xor(a: \"0101\", b: \"0000\") == \"\
    0101\")"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659978480
- exit_code: 1
  program: "\n/// Input are two strings a and b consisting only of 1s and 0s.\n///\
    \ Perform binary XOR on these inputs and return result also as a string.\n///\
    \ >>> string_xor(a: \"010\", b: \"110\")\n/// \"100\"\nfunc string_xor(a: String,\
    \ b: String) -> String {\n    var result = \"\"\n    for (idx, charA) in a.characters.enumerated()\
    \ {\n        let charB = b[b.index(b.startIndex, offsetBy: idx)]\n        result\
    \ += String(charA) == String(charB) ? \"0\" : \"1\"\n    }\n    return result\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(string_xor(a: \"111000\", b: \"101010\") == \"\
    010010\")\nassert(string_xor(a: \"1\", b: \"1\") == \"0\")\nassert(string_xor(a:\
    \ \"0101\", b: \"0000\") == \"0101\")"
  status: SyntaxError
  stderr: "/tmp/tmpd4plxrl7.swift:8:27: error: 'characters' is unavailable: Please\
    \ use String directly\n    for (idx, charA) in a.characters.enumerated() {\n \
    \                         ^~~~~~~~~~\nSwift.String:5:16: note: 'characters' was\
    \ obsoleted in Swift 5.0\n    public var characters: String { get set }\n    \
    \           ^\n"
  stdout: ''
  timestamp: 1659978480
- exit_code: 1
  program: "\n/// Input are two strings a and b consisting only of 1s and 0s.\n///\
    \ Perform binary XOR on these inputs and return result also as a string.\n///\
    \ >>> string_xor(a: \"010\", b: \"110\")\n/// \"100\"\nfunc string_xor(a: String,\
    \ b: String) -> String {\n  if a.count != b.count {\n    fatalError(\"given parameters\
    \ must have the same size\")\n  }\n  let result: String = String(zip(a, b).map\
    \ { String(Int(String($0))! ^ Int(String($1))!) })\n  return result\n}\n\n\nfunc\
    \ ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count !=\
    \ right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(string_xor(a: \"111000\", b: \"101010\") == \"\
    010010\")\nassert(string_xor(a: \"1\", b: \"1\") == \"0\")\nassert(string_xor(a:\
    \ \"0101\", b: \"0000\") == \"0101\")"
  status: SyntaxError
  stderr: "/tmp/tmp50v0k2kl.swift:10:24: error: the compiler is unable to type-check\
    \ this expression in reasonable time; try breaking up the expression into distinct\
    \ sub-expressions\n  let result: String = String(zip(a, b).map { String(Int(String($0))!\
    \ ^ Int(String($1))!) })\n                       ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n"
  stdout: ''
  timestamp: 1659978655
- exit_code: 0
  program: "\n/// Input are two strings a and b consisting only of 1s and 0s.\n///\
    \ Perform binary XOR on these inputs and return result also as a string.\n///\
    \ >>> string_xor(a: \"010\", b: \"110\")\n/// \"100\"\nfunc string_xor(a: String,\
    \ b: String) -> String {\n    return zip(a, b).map { String(Int(String($0))! ^\
    \ Int(String($1))!) }.joined()\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int,\
    \ Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n\
    \    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n          \
    \  return false\n        }\n    }\n    return true\n}\n            \nassert(string_xor(a:\
    \ \"111000\", b: \"101010\") == \"010010\")\nassert(string_xor(a: \"1\", b: \"\
    1\") == \"0\")\nassert(string_xor(a: \"0101\", b: \"0000\") == \"0101\")"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659978480
- exit_code: 1
  program: "\n/// Input are two strings a and b consisting only of 1s and 0s.\n///\
    \ Perform binary XOR on these inputs and return result also as a string.\n///\
    \ >>> string_xor(a: \"010\", b: \"110\")\n/// \"100\"\nfunc string_xor(a: String,\
    \ b: String) -> String {\n    var res = \"\"\n    if a.count == b.count {\n  \
    \      for i in 0..<a.count {\n            res += xor(a[i], b[i])\n        }\n\
    \    }\n    return res\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(string_xor(a:\
    \ \"111000\", b: \"101010\") == \"010010\")\nassert(string_xor(a: \"1\", b: \"\
    1\") == \"0\")\nassert(string_xor(a: \"0101\", b: \"0000\") == \"0101\")"
  status: SyntaxError
  stderr: "/tmp/tmp5z02lgxr.swift:10:20: error: cannot find 'xor' in scope\n     \
    \       res += xor(a[i], b[i])\n                   ^~~\n"
  stdout: ''
  timestamp: 1659978480
- exit_code: 0
  program: "\n/// Input are two strings a and b consisting only of 1s and 0s.\n///\
    \ Perform binary XOR on these inputs and return result also as a string.\n///\
    \ >>> string_xor(a: \"010\", b: \"110\")\n/// \"100\"\nfunc string_xor(a: String,\
    \ b: String) -> String {\n    //# write your code here\n    var stringToReturn\
    \ = \"\"\n    if a.count != b.count {\n        return stringToReturn\n    }\n\
    \    for i in 0..<a.count {\n        if a[a.index(a.startIndex, offsetBy: i)]\
    \ == b[b.index(b.startIndex, offsetBy: i)] {\n            stringToReturn.append(\"\
    0\")\n        } else {\n            stringToReturn.append(\"1\")\n        }\n\
    \    }\n    return stringToReturn\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int,\
    \ Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n\
    \    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n          \
    \  return false\n        }\n    }\n    return true\n}\n            \nassert(string_xor(a:\
    \ \"111000\", b: \"101010\") == \"010010\")\nassert(string_xor(a: \"1\", b: \"\
    1\") == \"0\")\nassert(string_xor(a: \"0101\", b: \"0000\") == \"0101\")"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659978480
- exit_code: 1
  program: "\n/// Input are two strings a and b consisting only of 1s and 0s.\n///\
    \ Perform binary XOR on these inputs and return result also as a string.\n///\
    \ >>> string_xor(a: \"010\", b: \"110\")\n/// \"100\"\nfunc string_xor(a: String,\
    \ b: String) -> String {\n    var result = \"\"\n    for (index, char) in a.characters.enumerated()\
    \ {\n        let left = char\n        let right = b[b.index(b.startIndex, offsetBy:\
    \ index)]\n        result += \"\\(left == right ? \"0\" : \"1\")\"\n    }\n  \
    \  return result\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool\
    \ {\n    if left.count != right.count {\n        return false\n    }\n    for\
    \ (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(string_xor(a: \"111000\"\
    , b: \"101010\") == \"010010\")\nassert(string_xor(a: \"1\", b: \"1\") == \"0\"\
    )\nassert(string_xor(a: \"0101\", b: \"0000\") == \"0101\")"
  status: SyntaxError
  stderr: "/tmp/tmp3coo0d3c.swift:8:28: error: 'characters' is unavailable: Please\
    \ use String directly\n    for (index, char) in a.characters.enumerated() {\n\
    \                           ^~~~~~~~~~\nSwift.String:5:16: note: 'characters'\
    \ was obsoleted in Swift 5.0\n    public var characters: String { get set }\n\
    \               ^\n"
  stdout: ''
  timestamp: 1659978480
- exit_code: 0
  program: "\n/// Input are two strings a and b consisting only of 1s and 0s.\n///\
    \ Perform binary XOR on these inputs and return result also as a string.\n///\
    \ >>> string_xor(a: \"010\", b: \"110\")\n/// \"100\"\nfunc string_xor(a: String,\
    \ b: String) -> String {\n    if a.count != b.count {\n        print(\"Invalid\
    \ input strings\")\n        return \"\"\n    }\n    var result = \"\"\n    let\
    \ a_bytes = Array(a.utf8)\n    let b_bytes = Array(b.utf8)\n    for i in 0 ..<\
    \ a.count {\n        let a_byte = a_bytes[i]\n        let b_byte = b_bytes[i]\n\
    \        if (a_byte == b_byte) {\n            result += \"0\"\n        } else\
    \ {\n            result += \"1\"\n        }\n    }\n    return result\n}\n\n\n\
    func ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(string_xor(a: \"111000\", b: \"101010\") == \"\
    010010\")\nassert(string_xor(a: \"1\", b: \"1\") == \"0\")\nassert(string_xor(a:\
    \ \"0101\", b: \"0000\") == \"0101\")"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659978480
- exit_code: 0
  program: "\n/// Input are two strings a and b consisting only of 1s and 0s.\n///\
    \ Perform binary XOR on these inputs and return result also as a string.\n///\
    \ >>> string_xor(a: \"010\", b: \"110\")\n/// \"100\"\nfunc string_xor(a: String,\
    \ b: String) -> String {\n    var r = \"\"\n    for (c1, c2) in zip(a, b) {\n\
    \        let c = c1 == c2 ? \"0\" : \"1\"\n        r += c\n    }\n    return r\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(string_xor(a: \"111000\", b: \"101010\") == \"\
    010010\")\nassert(string_xor(a: \"1\", b: \"1\") == \"0\")\nassert(string_xor(a:\
    \ \"0101\", b: \"0000\") == \"0101\")"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659978480
- exit_code: 0
  program: "\n/// Input are two strings a and b consisting only of 1s and 0s.\n///\
    \ Perform binary XOR on these inputs and return result also as a string.\n///\
    \ >>> string_xor(a: \"010\", b: \"110\")\n/// \"100\"\nfunc string_xor(a: String,\
    \ b: String) -> String {\n    let aa = [UInt8](a.utf8)\n    let bb = [UInt8](b.utf8)\n\
    \    let count = aa.count\n    var result = \"\"\n    for i in 0..<count {\n \
    \       result += String(aa[i] ^ bb[i])\n    }\n    return result\n}\n\n\nfunc\
    \ ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count !=\
    \ right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(string_xor(a: \"111000\", b: \"101010\") == \"\
    010010\")\nassert(string_xor(a: \"1\", b: \"1\") == \"0\")\nassert(string_xor(a:\
    \ \"0101\", b: \"0000\") == \"0101\")"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659978480
- exit_code: 0
  program: "\n/// Input are two strings a and b consisting only of 1s and 0s.\n///\
    \ Perform binary XOR on these inputs and return result also as a string.\n///\
    \ >>> string_xor(a: \"010\", b: \"110\")\n/// \"100\"\nfunc string_xor(a: String,\
    \ b: String) -> String {\n  assert(a.count == b.count)\n  var c = \"\"\n  for\
    \ i in 0..<a.count {\n    let a_val = a[a.index(a.startIndex, offsetBy: i)]\n\
    \    let b_val = b[b.index(b.startIndex, offsetBy: i)]\n    assert(a_val == \"\
    0\" || a_val == \"1\")\n    assert(b_val == \"0\" || b_val == \"1\")\n    if a_val\
    \ == b_val {\n      c += \"0\"\n    } else {\n      c += \"1\"\n    }\n  }\n \
    \ return c\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n\
    \    if left.count != right.count {\n        return false\n    }\n    for (l,\
    \ r) in zip(left, right) {\n        if l != r {\n            return false\n  \
    \      }\n    }\n    return true\n}\n            \nassert(string_xor(a: \"111000\"\
    , b: \"101010\") == \"010010\")\nassert(string_xor(a: \"1\", b: \"1\") == \"0\"\
    )\nassert(string_xor(a: \"0101\", b: \"0000\") == \"0101\")"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659978480
- exit_code: 1
  program: "\n/// Input are two strings a and b consisting only of 1s and 0s.\n///\
    \ Perform binary XOR on these inputs and return result also as a string.\n///\
    \ >>> string_xor(a: \"010\", b: \"110\")\n/// \"100\"\nfunc string_xor(a: String,\
    \ b: String) -> String {\n    var result = \"\"\n    for i in 0..<max(a.count,\
    \ b.count) {\n        let ai = i < a.count ? a[i] : \"0\"\n        let bi = i\
    \ < b.count ? b[i] : \"0\"\n        result += String(Int(ai)! ^ Int(bi)!)\n  \
    \  }\n    return result\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(string_xor(a:\
    \ \"111000\", b: \"101010\") == \"010010\")\nassert(string_xor(a: \"1\", b: \"\
    1\") == \"0\")\nassert(string_xor(a: \"0101\", b: \"0000\") == \"0101\")"
  status: SyntaxError
  stderr: "/tmp/tmphntzo2m3.swift:9:32: error: 'subscript(_:)' is unavailable: cannot\
    \ subscript String with an Int, use a String.Index instead.\n        let ai =\
    \ i < a.count ? a[i] : \"0\"\n                               ^~~~\nSwift.String:3:12:\
    \ note: 'subscript(_:)' has been explicitly marked unavailable here\n    public\
    \ subscript(i: Int) -> Character { get }\n           ^\n/tmp/tmphntzo2m3.swift:10:32:\
    \ error: 'subscript(_:)' is unavailable: cannot subscript String with an Int,\
    \ use a String.Index instead.\n        let bi = i < b.count ? b[i] : \"0\"\n \
    \                              ^~~~\nSwift.String:3:12: note: 'subscript(_:)'\
    \ has been explicitly marked unavailable here\n    public subscript(i: Int) ->\
    \ Character { get }\n           ^\n/tmp/tmphntzo2m3.swift:11:41: error: cannot\
    \ convert value of type 'Character' to expected argument type 'String'\n     \
    \   result += String(Int(ai)! ^ Int(bi)!)\n                                  \
    \      ^\n/tmp/tmphntzo2m3.swift:11:30: error: cannot convert value of type 'Character'\
    \ to expected argument type 'String'\n        result += String(Int(ai)! ^ Int(bi)!)\n\
    \                             ^\n"
  stdout: ''
  timestamp: 1659978480
- exit_code: 0
  program: "\n/// Input are two strings a and b consisting only of 1s and 0s.\n///\
    \ Perform binary XOR on these inputs and return result also as a string.\n///\
    \ >>> string_xor(a: \"010\", b: \"110\")\n/// \"100\"\nfunc string_xor(a: String,\
    \ b: String) -> String {\n    var result = String()\n    var aString = a\n   \
    \ var bString = b\n    while aString.count < bString.count {\n        aString\
    \ = \"0\" + aString\n    }\n    while bString.count < aString.count {\n      \
    \  bString = \"0\" + bString\n    }\n    for i in 0..<aString.count {\n      \
    \  let aChar = aString[aString.index(aString.startIndex, offsetBy: i)]\n     \
    \   let bChar = bString[bString.index(bString.startIndex, offsetBy: i)]\n    \
    \    let aInt = Int(String(aChar))!\n        let bInt = Int(String(bChar))!\n\
    \        let xor = (aInt + bInt) % 2\n        result += String(xor)\n    }\n \
    \   return result\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) ->\
    \ Bool {\n    if left.count != right.count {\n        return false\n    }\n  \
    \  for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(string_xor(a: \"111000\"\
    , b: \"101010\") == \"010010\")\nassert(string_xor(a: \"1\", b: \"1\") == \"0\"\
    )\nassert(string_xor(a: \"0101\", b: \"0000\") == \"0101\")"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659978480
- exit_code: 0
  program: "\n/// Input are two strings a and b consisting only of 1s and 0s.\n///\
    \ Perform binary XOR on these inputs and return result also as a string.\n///\
    \ >>> string_xor(a: \"010\", b: \"110\")\n/// \"100\"\nfunc string_xor(a: String,\
    \ b: String) -> String {\n    var result = \"\"\n    let a = Array(a)\n    let\
    \ b = Array(b)\n    for i in 0..<max(a.count, b.count) {\n        if a[i] == b[i]\
    \ {\n            result.append(\"0\")\n        } else {\n            result.append(\"\
    1\")\n        }\n    }\n    return result\n}\n\n\nfunc ==(left: [(Int, Int)],\
    \ right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n       \
    \ return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r\
    \ {\n            return false\n        }\n    }\n    return true\n}\n        \
    \    \nassert(string_xor(a: \"111000\", b: \"101010\") == \"010010\")\nassert(string_xor(a:\
    \ \"1\", b: \"1\") == \"0\")\nassert(string_xor(a: \"0101\", b: \"0000\") == \"\
    0101\")"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659978480
- exit_code: 1
  program: "\n/// Input are two strings a and b consisting only of 1s and 0s.\n///\
    \ Perform binary XOR on these inputs and return result also as a string.\n///\
    \ >>> string_xor(a: \"010\", b: \"110\")\n/// \"100\"\nfunc string_xor(a: String,\
    \ b: String) -> String {\n    var result = \"\"\n    for i in 0..<a.count {\n\
    \        if a[i] == b[i] {\n            result += \"0\"\n        } else {\n  \
    \          result += \"1\"\n        }\n    }\n    return result\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(string_xor(a: \"111000\", b: \"101010\") == \"010010\"\
    )\nassert(string_xor(a: \"1\", b: \"1\") == \"0\")\nassert(string_xor(a: \"0101\"\
    , b: \"0000\") == \"0101\")"
  status: SyntaxError
  stderr: "/tmp/tmpj2ew69yc.swift:9:12: error: 'subscript(_:)' is unavailable: cannot\
    \ subscript String with an Int, use a String.Index instead.\n        if a[i] ==\
    \ b[i] {\n           ^~~~\nSwift.String:3:12: note: 'subscript(_:)' has been explicitly\
    \ marked unavailable here\n    public subscript(i: Int) -> Character { get }\n\
    \           ^\n/tmp/tmpj2ew69yc.swift:9:20: error: 'subscript(_:)' is unavailable:\
    \ cannot subscript String with an Int, use a String.Index instead.\n        if\
    \ a[i] == b[i] {\n                   ^~~~\nSwift.String:3:12: note: 'subscript(_:)'\
    \ has been explicitly marked unavailable here\n    public subscript(i: Int) ->\
    \ Character { get }\n           ^\n"
  stdout: ''
  timestamp: 1659978480
- exit_code: 1
  program: "\n/// Input are two strings a and b consisting only of 1s and 0s.\n///\
    \ Perform binary XOR on these inputs and return result also as a string.\n///\
    \ >>> string_xor(a: \"010\", b: \"110\")\n/// \"100\"\nfunc string_xor(a: String,\
    \ b: String) -> String {\n    let length = min(a.count, b.count)\n    var result\
    \ = \"\"\n    for i in 0..<length {\n        result += (a[i] == b[i]) ? \"0\"\
    \ : \"1\"\n    }\n    return result\n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(string_xor(a: \"111000\", b: \"101010\") == \"010010\")\nassert(string_xor(a:\
    \ \"1\", b: \"1\") == \"0\")\nassert(string_xor(a: \"0101\", b: \"0000\") == \"\
    0101\")"
  status: SyntaxError
  stderr: "/tmp/tmpn_qnlipu.swift:10:20: error: 'subscript(_:)' is unavailable: cannot\
    \ subscript String with an Int, use a String.Index instead.\n        result +=\
    \ (a[i] == b[i]) ? \"0\" : \"1\"\n                   ^~~~\nSwift.String:3:12:\
    \ note: 'subscript(_:)' has been explicitly marked unavailable here\n    public\
    \ subscript(i: Int) -> Character { get }\n           ^\n/tmp/tmpn_qnlipu.swift:10:28:\
    \ error: 'subscript(_:)' is unavailable: cannot subscript String with an Int,\
    \ use a String.Index instead.\n        result += (a[i] == b[i]) ? \"0\" : \"1\"\
    \n                           ^~~~\nSwift.String:3:12: note: 'subscript(_:)' has\
    \ been explicitly marked unavailable here\n    public subscript(i: Int) -> Character\
    \ { get }\n           ^\n"
  stdout: ''
  timestamp: 1659978480
- exit_code: 1
  program: "\n/// Input are two strings a and b consisting only of 1s and 0s.\n///\
    \ Perform binary XOR on these inputs and return result also as a string.\n///\
    \ >>> string_xor(a: \"010\", b: \"110\")\n/// \"100\"\nfunc string_xor(a: String,\
    \ b: String) -> String {\n\tlet string_and = { (a: String, b: String) -> String\
    \ in\n\t\tvar andString = \"\"\n\t\tlet aChars = Array(a.characters)\n\t\tlet\
    \ bChars = Array(b.characters)\n\t\tfor index in 0..<aChars.count {\n\t\t\tif\
    \ aChars[index] == \"1\" && bChars[index] == \"1\" {\n\t\t\t\tandString += \"\
    1\"\n\t\t\t} else {\n\t\t\t\tandString += \"0\"\n\t\t\t}\n\t\t}\n\t\treturn andString\n\
    \t}\n\t\n\tlet string_or = { (a: String, b: String) -> String in\n\t\tvar orString\
    \ = \"\"\n\t\tlet aChars = Array(a.characters)\n\t\tlet bChars = Array(b.characters)\n\
    \t\tfor index in 0..<aChars.count {\n\t\t\tif aChars[index] == \"1\" || bChars[index]\
    \ == \"1\" {\n\t\t\t\torString += \"1\"\n\t\t\t} else {\n\t\t\t\torString += \"\
    0\"\n\t\t\t}\n\t\t}\n\t\treturn orString\n\t}\n\t\n\tlet string_not = { (a: String)\
    \ -> String in\n\t\tvar notString = \"\"\n\t\tlet aChars = Array(a.characters)\n\
    \t\tfor index in 0..<aChars.count {\n\t\t\tif aChars[index] == \"1\" {\n\t\t\t\
    \tnotString += \"0\"\n\t\t\t} else {\n\t\t\t\tnotString += \"1\"\n\t\t\t}\n\t\t\
    }\n\t\treturn notString\n\t}\n\t\n\tlet aNot = string_not(a)\n\tlet bNot = string_not(b)\n\
    \tlet andResult = string_and(aNot, b: bNot)\n\tlet orResult = string_or(a, b:\
    \ b)\n\treturn string_and(andResult, b: orResult)\n}\n\n\nfunc ==(left: [(Int,\
    \ Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n\
    \        return false\n    }\n    for (l, r) in zip(left, right) {\n        if\
    \ l != r {\n            return false\n        }\n    }\n    return true\n}\n \
    \           \nassert(string_xor(a: \"111000\", b: \"101010\") == \"010010\")\n\
    assert(string_xor(a: \"1\", b: \"1\") == \"0\")\nassert(string_xor(a: \"0101\"\
    , b: \"0000\") == \"0101\")"
  status: SyntaxError
  stderr: "/tmp/tmpe4k0_pw8.swift:9:24: error: 'characters' is unavailable: Please\
    \ use String directly\n                let aChars = Array(a.characters)\n    \
    \                                 ^~~~~~~~~~\nSwift.String:5:16: note: 'characters'\
    \ was obsoleted in Swift 5.0\n    public var characters: String { get set }\n\
    \               ^\n/tmp/tmpe4k0_pw8.swift:10:24: error: 'characters' is unavailable:\
    \ Please use String directly\n                let bChars = Array(b.characters)\n\
    \                                     ^~~~~~~~~~\nSwift.String:5:16: note: 'characters'\
    \ was obsoleted in Swift 5.0\n    public var characters: String { get set }\n\
    \               ^\n/tmp/tmpe4k0_pw8.swift:23:24: error: 'characters' is unavailable:\
    \ Please use String directly\n                let aChars = Array(a.characters)\n\
    \                                     ^~~~~~~~~~\nSwift.String:5:16: note: 'characters'\
    \ was obsoleted in Swift 5.0\n    public var characters: String { get set }\n\
    \               ^\n/tmp/tmpe4k0_pw8.swift:24:24: error: 'characters' is unavailable:\
    \ Please use String directly\n                let bChars = Array(b.characters)\n\
    \                                     ^~~~~~~~~~\nSwift.String:5:16: note: 'characters'\
    \ was obsoleted in Swift 5.0\n    public var characters: String { get set }\n\
    \               ^\n/tmp/tmpe4k0_pw8.swift:37:24: error: 'characters' is unavailable:\
    \ Please use String directly\n                let aChars = Array(a.characters)\n\
    \                                     ^~~~~~~~~~\nSwift.String:5:16: note: 'characters'\
    \ was obsoleted in Swift 5.0\n    public var characters: String { get set }\n\
    \               ^\n/tmp/tmpe4k0_pw8.swift:50:28: error: extraneous argument label\
    \ 'b:' in call\n        let andResult = string_and(aNot, b: bNot)\n          \
    \                        ^      ~~~\n                                        \
    \ \n/tmp/tmpe4k0_pw8.swift:51:26: error: extraneous argument label 'b:' in call\n\
    \        let orResult = string_or(a, b: b)\n                                ^\
    \   ~~~\n                                    \n/tmp/tmpe4k0_pw8.swift:52:19: error:\
    \ extraneous arg"
  stdout: ''
  timestamp: 1659978480
- exit_code: 1
  program: "\n/// Input are two strings a and b consisting only of 1s and 0s.\n///\
    \ Perform binary XOR on these inputs and return result also as a string.\n///\
    \ >>> string_xor(a: \"010\", b: \"110\")\n/// \"100\"\nfunc string_xor(a: String,\
    \ b: String) -> String {\n\tvar diffs = \"\"\n\tlet m = min(a.count, b.count)\n\
    \tfor i in 0..<m {\n\t\tdiffs += ((a[i] == b[i]) ? \"0\" : \"1\")\n\t}\n\tlet\
    \ rest = a.count > b.count ? a[m..<a.count] : b[m..<b.count]\n\treturn diffs +\
    \ rest\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n  \
    \  if left.count != right.count {\n        return false\n    }\n    for (l, r)\
    \ in zip(left, right) {\n        if l != r {\n            return false\n     \
    \   }\n    }\n    return true\n}\n            \nassert(string_xor(a: \"111000\"\
    , b: \"101010\") == \"010010\")\nassert(string_xor(a: \"1\", b: \"1\") == \"0\"\
    )\nassert(string_xor(a: \"0101\", b: \"0000\") == \"0101\")"
  status: SyntaxError
  stderr: "/tmp/tmpkvwgy2ej.swift:10:14: error: 'subscript(_:)' is unavailable: cannot\
    \ subscript String with an Int, use a String.Index instead.\n                diffs\
    \ += ((a[i] == b[i]) ? \"0\" : \"1\")\n                           ^~~~\nSwift.String:3:12:\
    \ note: 'subscript(_:)' has been explicitly marked unavailable here\n    public\
    \ subscript(i: Int) -> Character { get }\n           ^\n/tmp/tmpkvwgy2ej.swift:10:22:\
    \ error: 'subscript(_:)' is unavailable: cannot subscript String with an Int,\
    \ use a String.Index instead.\n                diffs += ((a[i] == b[i]) ? \"0\"\
    \ : \"1\")\n                                   ^~~~\nSwift.String:3:12: note:\
    \ 'subscript(_:)' has been explicitly marked unavailable here\n    public subscript(i:\
    \ Int) -> Character { get }\n           ^\n/tmp/tmpkvwgy2ej.swift:12:33: error:\
    \ 'subscript(_:)' is unavailable: cannot subscript String with an integer range,\
    \ use a String.Index range instead.\n        let rest = a.count > b.count ? a[m..<a.count]\
    \ : b[m..<b.count]\n                                       ^~~~~~~~~~~~~~\nSwift.String:5:12:\
    \ note: 'subscript(_:)' has been explicitly marked unavailable here\n    public\
    \ subscript<R>(bounds: R) -> String where R : RangeExpression, R.Bound == Int\
    \ { get }\n           ^\n/tmp/tmpkvwgy2ej.swift:12:50: error: 'subscript(_:)'\
    \ is unavailable: cannot subscript String with an integer range, use a String.Index\
    \ range instead.\n        let rest = a.count > b.count ? a[m..<a.count] : b[m..<b.count]\n\
    \                                                        ^~~~~~~~~~~~~~\nSwift.String:5:12:\
    \ note: 'subscript(_:)' has been explicitly marked unavailable here\n    public\
    \ subscript<R>(bounds: R) -> String where R : RangeExpression, R.Bound == Int\
    \ { get }\n           ^\n"
  stdout: ''
  timestamp: 1659978480
- exit_code: 1
  program: "\n/// Input are two strings a and b consisting only of 1s and 0s.\n///\
    \ Perform binary XOR on these inputs and return result also as a string.\n///\
    \ >>> string_xor(a: \"010\", b: \"110\")\n/// \"100\"\nfunc string_xor(a: String,\
    \ b: String) -> String {\n    var aInts = [UInt8]()\n    var bInts = [UInt8]()\n\
    \    for aChar in a.characters {\n        aInts.append(UInt8(String(aChar))!)\n\
    \    }\n    for bChar in b.characters {\n        bInts.append(UInt8(String(bChar))!)\n\
    \    }\n    var result = \"\"\n    for i in 0..<aInts.count {\n        result\
    \ += String(aInts[i] ^ bInts[i])\n    }\n    return result\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(string_xor(a: \"111000\", b: \"101010\") == \"010010\"\
    )\nassert(string_xor(a: \"1\", b: \"1\") == \"0\")\nassert(string_xor(a: \"0101\"\
    , b: \"0000\") == \"0101\")"
  status: SyntaxError
  stderr: "/tmp/tmphew4x81m.swift:9:20: error: 'characters' is unavailable: Please\
    \ use String directly\n    for aChar in a.characters {\n                   ^~~~~~~~~~\n\
    Swift.String:5:16: note: 'characters' was obsoleted in Swift 5.0\n    public var\
    \ characters: String { get set }\n               ^\n/tmp/tmphew4x81m.swift:12:20:\
    \ error: 'characters' is unavailable: Please use String directly\n    for bChar\
    \ in b.characters {\n                   ^~~~~~~~~~\nSwift.String:5:16: note: 'characters'\
    \ was obsoleted in Swift 5.0\n    public var characters: String { get set }\n\
    \               ^\n"
  stdout: ''
  timestamp: 1659978480
- exit_code: 1
  program: "\n/// Input are two strings a and b consisting only of 1s and 0s.\n///\
    \ Perform binary XOR on these inputs and return result also as a string.\n///\
    \ >>> string_xor(a: \"010\", b: \"110\")\n/// \"100\"\nfunc string_xor(a: String,\
    \ b: String) -> String {\n    let r = zip(a, b).map { $0 != $1 ? \"1\" : \"0\"\
    \ }\n    return String(r)\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(string_xor(a:\
    \ \"111000\", b: \"101010\") == \"010010\")\nassert(string_xor(a: \"1\", b: \"\
    1\") == \"0\")\nassert(string_xor(a: \"0101\", b: \"0000\") == \"0101\")"
  status: SyntaxError
  stderr: "/tmp/tmp1uee26w2.swift:8:12: error: no exact matches in call to initializer\
    \ \n    return String(r)\n           ^\nSwift.String:4:12: note: candidate requires\
    \ that the types 'String' and 'Character' be equivalent (requirement specified\
    \ as 'S.Element' == 'Character')\n    public init<S>(_ characters: S) where S\
    \ : Sequence, S.Element == Character\n           ^\nSwift.RangeReplaceableCollection:3:23:\
    \ note: candidate requires that the types 'String.Element' (aka 'Character') and\
    \ 'String' be equivalent (requirement specified as 'Self.Element' == 'S.Element')\n\
    \    @inlinable public init<S>(_ elements: S) where S : Sequence, Self.Element\
    \ == S.Element\n                      ^\nSwift.String:2:12: note: incorrect labels\
    \ for candidate (have: '(_:)', expected: '(describing:)')\n    public init<Subject>(describing\
    \ instance: Subject)\n           ^\nSwift.String:3:23: note: incorrect labels\
    \ for candidate (have: '(_:)', expected: '(describing:)')\n    @inlinable public\
    \ init<Subject>(describing instance: Subject) where Subject : CustomStringConvertible\n\
    \                      ^\nSwift.String:6:12: note: incorrect labels for candidate\
    \ (have: '(_:)', expected: '(reflecting:)')\n    public init<Subject>(reflecting\
    \ subject: Subject)\n           ^\n"
  stdout: ''
  timestamp: 1659978480
- exit_code: -4
  program: "\n/// Input are two strings a and b consisting only of 1s and 0s.\n///\
    \ Perform binary XOR on these inputs and return result also as a string.\n///\
    \ >>> string_xor(a: \"010\", b: \"110\")\n/// \"100\"\nfunc string_xor(a: String,\
    \ b: String) -> String {\n  // TODO\n  return String(1)\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(string_xor(a: \"111000\", b: \"101010\") == \"010010\"\
    )\nassert(string_xor(a: \"1\", b: \"1\") == \"0\")\nassert(string_xor(a: \"0101\"\
    , b: \"0000\") == \"0101\")"
  status: Exception
  stderr: 'tmpngn8fjyv/tmpngn8fjyv.swift:24: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b5bf31a1c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b5bf2e98b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b5bf2e98988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b5bf2e977b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpngn8fjyv                        0x00005584d51b03fb <unavailable> + 5115

    5    libc.so.6                          0x00002b5bf338d460 __libc_start_main +
    245

    6    tmpngn8fjyv                        0x00005584d51b0009 <unavailable> + 4105

    '
  stdout: ''
  timestamp: 1659978480
- exit_code: 1
  program: "\n/// Input are two strings a and b consisting only of 1s and 0s.\n///\
    \ Perform binary XOR on these inputs and return result also as a string.\n///\
    \ >>> string_xor(a: \"010\", b: \"110\")\n/// \"100\"\nfunc string_xor(a: String,\
    \ b: String) -> String {\n    let xor = a.hexlify ^ b.hexlify\n    return String(data:\
    \ xor, encoding: .utf8)!\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(string_xor(a:\
    \ \"111000\", b: \"101010\") == \"010010\")\nassert(string_xor(a: \"1\", b: \"\
    1\") == \"0\")\nassert(string_xor(a: \"0101\", b: \"0000\") == \"0101\")"
  status: SyntaxError
  stderr: "/tmp/tmp1qrbyt0a.swift:7:17: error: value of type 'String' has no member\
    \ 'hexlify'\n    let xor = a.hexlify ^ b.hexlify\n              ~ ^~~~~~~\n/tmp/tmp1qrbyt0a.swift:7:29:\
    \ error: value of type 'String' has no member 'hexlify'\n    let xor = a.hexlify\
    \ ^ b.hexlify\n                          ~ ^~~~~~~\n/tmp/tmp1qrbyt0a.swift:8:41:\
    \ error: extra argument 'encoding' in call\n    return String(data: xor, encoding:\
    \ .utf8)!\n                 ~~~~~~~~~~~~~~~~~~~~~~~^~~~~\n/tmp/tmp1qrbyt0a.swift:8:41:\
    \ error: cannot infer contextual base in reference to member 'utf8'\n    return\
    \ String(data: xor, encoding: .utf8)!\n                                      \
    \ ~^~~~\n"
  stdout: ''
  timestamp: 1659978480
- exit_code: 1
  program: "\n/// Input are two strings a and b consisting only of 1s and 0s.\n///\
    \ Perform binary XOR on these inputs and return result also as a string.\n///\
    \ >>> string_xor(a: \"010\", b: \"110\")\n/// \"100\"\nfunc string_xor(a: String,\
    \ b: String) -> String {\n    var result = \"\"\n    for i in 0..<a.characters.count\
    \ {\n        let aIndex = a.index(a.startIndex, offsetBy: i)\n        let bIndex\
    \ = b.index(b.startIndex, offsetBy: i)\n        let aString = String(a[aIndex])\n\
    \        let bString = String(b[bIndex])\n        let aInt = Int(aString)\n  \
    \      let bInt = Int(bString)\n        if aInt == bInt {\n            result.append(\"\
    0\")\n        } else {\n            result.append(\"1\")\n        }\n    }\n \
    \   return result\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) ->\
    \ Bool {\n    if left.count != right.count {\n        return false\n    }\n  \
    \  for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(string_xor(a: \"111000\"\
    , b: \"101010\") == \"010010\")\nassert(string_xor(a: \"1\", b: \"1\") == \"0\"\
    )\nassert(string_xor(a: \"0101\", b: \"0000\") == \"0101\")"
  status: SyntaxError
  stderr: "/tmp/tmp2hyb_pn9.swift:8:20: error: 'characters' is unavailable: Please\
    \ use String directly\n    for i in 0..<a.characters.count {\n               \
    \    ^~~~~~~~~~\nSwift.String:5:16: note: 'characters' was obsoleted in Swift\
    \ 5.0\n    public var characters: String { get set }\n               ^\n"
  stdout: ''
  timestamp: 1659978480
- exit_code: 0
  program: "\n/// Input are two strings a and b consisting only of 1s and 0s.\n///\
    \ Perform binary XOR on these inputs and return result also as a string.\n///\
    \ >>> string_xor(a: \"010\", b: \"110\")\n/// \"100\"\nfunc string_xor(a: String,\
    \ b: String) -> String {\n    var z = \"\"\n    for i in 0..<max(a.count, b.count)\
    \ {\n        let x = Int(a[a.index(a.startIndex, offsetBy: i % a.count)..<a.index(a.startIndex,\
    \ offsetBy: i % a.count + 1)], radix: 2) ?? 0\n        let y = Int(b[b.index(b.startIndex,\
    \ offsetBy: i % b.count)..<b.index(b.startIndex, offsetBy: i % b.count + 1)],\
    \ radix: 2) ?? 0\n        z += String(x ^ y, radix: 2)\n    }\n    return z\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(string_xor(a: \"111000\", b: \"101010\") == \"\
    010010\")\nassert(string_xor(a: \"1\", b: \"1\") == \"0\")\nassert(string_xor(a:\
    \ \"0101\", b: \"0000\") == \"0101\")"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659978480
- exit_code: -1
  program: "\n/// Input are two strings a and b consisting only of 1s and 0s.\n///\
    \ Perform binary XOR on these inputs and return result also as a string.\n///\
    \ >>> string_xor(a: \"010\", b: \"110\")\n/// \"100\"\nfunc string_xor(a: String,\
    \ b: String) -> String {\n    var result = \"\"\n    let length = max(a.count,\
    \ b.count)\n    for i in 0..<length {\n        let a_bit = i < a.count ? String(a[a.index(a.startIndex,\
    \ offsetBy: i)]) : \"0\"\n        let b_bit = i < b.count ? String(b[b.index(b.startIndex,\
    \ offsetBy: i)]) : \"0\"\n        result.append(string_xor(a: a_bit, b: b_bit))\n\
    \    }\n    return result\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(string_xor(a:\
    \ \"111000\", b: \"101010\") == \"010010\")\nassert(string_xor(a: \"1\", b: \"\
    1\") == \"0\")\nassert(string_xor(a: \"0101\", b: \"0000\") == \"0101\")"
  status: Timeout
  stderr: ''
  stdout: ''
  timestamp: 1659978485
- exit_code: 1
  program: "\n/// Input are two strings a and b consisting only of 1s and 0s.\n///\
    \ Perform binary XOR on these inputs and return result also as a string.\n///\
    \ >>> string_xor(a: \"010\", b: \"110\")\n/// \"100\"\nfunc string_xor(a: String,\
    \ b: String) -> String {\n    // Check if string lengths are equal.\n    guard\
    \ a.characters.count == b.characters.count else {\n        return String()\n \
    \   }\n    \n    // Assume the two strings are of equal length.\n    var result\
    \ = String()\n    for (char_a, char_b) in zip(a.characters, b.characters) {\n\
    \        // Check if both characters are equal.\n        if char_a == char_b {\n\
    \            result.append(\"0\")\n        } else {\n            result.append(\"\
    1\")\n        }\n    }\n    \n    return result\n}\n\n\nfunc ==(left: [(Int, Int)],\
    \ right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n       \
    \ return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r\
    \ {\n            return false\n        }\n    }\n    return true\n}\n        \
    \    \nassert(string_xor(a: \"111000\", b: \"101010\") == \"010010\")\nassert(string_xor(a:\
    \ \"1\", b: \"1\") == \"0\")\nassert(string_xor(a: \"0101\", b: \"0000\") == \"\
    0101\")"
  status: SyntaxError
  stderr: "/tmp/tmp48pp6fxx.swift:8:13: error: 'characters' is unavailable: Please\
    \ use String directly\n    guard a.characters.count == b.characters.count else\
    \ {\n            ^~~~~~~~~~\nSwift.String:5:16: note: 'characters' was obsoleted\
    \ in Swift 5.0\n    public var characters: String { get set }\n              \
    \ ^\n/tmp/tmp48pp6fxx.swift:8:35: error: 'characters' is unavailable: Please use\
    \ String directly\n    guard a.characters.count == b.characters.count else {\n\
    \                                  ^~~~~~~~~~\nSwift.String:5:16: note: 'characters'\
    \ was obsoleted in Swift 5.0\n    public var characters: String { get set }\n\
    \               ^\n/tmp/tmp48pp6fxx.swift:14:35: error: 'characters' is unavailable:\
    \ Please use String directly\n    for (char_a, char_b) in zip(a.characters, b.characters)\
    \ {\n                                  ^~~~~~~~~~\nSwift.String:5:16: note: 'characters'\
    \ was obsoleted in Swift 5.0\n    public var characters: String { get set }\n\
    \               ^\n/tmp/tmp48pp6fxx.swift:14:49: error: 'characters' is unavailable:\
    \ Please use String directly\n    for (char_a, char_b) in zip(a.characters, b.characters)\
    \ {\n                                                ^~~~~~~~~~\nSwift.String:5:16:\
    \ note: 'characters' was obsoleted in Swift 5.0\n    public var characters: String\
    \ { get set }\n               ^\n"
  stdout: ''
  timestamp: 1659978480
- exit_code: 1
  program: "\n/// Input are two strings a and b consisting only of 1s and 0s.\n///\
    \ Perform binary XOR on these inputs and return result also as a string.\n///\
    \ >>> string_xor(a: \"010\", b: \"110\")\n/// \"100\"\nfunc string_xor(a: String,\
    \ b: String) -> String {\n    var res = \"\"\n    for (i, c) in a.characters.enumerated()\
    \ {\n        let c2 = b[b.index(b.startIndex, offsetBy: i)]\n        if c == c2\
    \ {\n            res += \"0\"\n        } else {\n            res += \"1\"\n  \
    \      }\n    }\n    return res\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int,\
    \ Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n\
    \    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n          \
    \  return false\n        }\n    }\n    return true\n}\n            \nassert(string_xor(a:\
    \ \"111000\", b: \"101010\") == \"010010\")\nassert(string_xor(a: \"1\", b: \"\
    1\") == \"0\")\nassert(string_xor(a: \"0101\", b: \"0000\") == \"0101\")"
  status: SyntaxError
  stderr: "/tmp/tmptexmomu3.swift:8:21: error: 'characters' is unavailable: Please\
    \ use String directly\n    for (i, c) in a.characters.enumerated() {\n       \
    \             ^~~~~~~~~~\nSwift.String:5:16: note: 'characters' was obsoleted\
    \ in Swift 5.0\n    public var characters: String { get set }\n              \
    \ ^\n"
  stdout: ''
  timestamp: 1659978480
- exit_code: 1
  program: "\n/// Input are two strings a and b consisting only of 1s and 0s.\n///\
    \ Perform binary XOR on these inputs and return result also as a string.\n///\
    \ >>> string_xor(a: \"010\", b: \"110\")\n/// \"100\"\nfunc string_xor(a: String,\
    \ b: String) -> String {\n    var result = \"\"\n    for (index, character) in\
    \ a.characters.enumerated() {\n        result += String(Int(String(character))!\
    \ ^ Int(String(b[b.index(b.startIndex, offsetBy: index)]))!)\n    }\n    return\
    \ result\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n\
    \    if left.count != right.count {\n        return false\n    }\n    for (l,\
    \ r) in zip(left, right) {\n        if l != r {\n            return false\n  \
    \      }\n    }\n    return true\n}\n            \nassert(string_xor(a: \"111000\"\
    , b: \"101010\") == \"010010\")\nassert(string_xor(a: \"1\", b: \"1\") == \"0\"\
    )\nassert(string_xor(a: \"0101\", b: \"0000\") == \"0101\")"
  status: SyntaxError
  stderr: "/tmp/tmpv7x6hamx.swift:8:33: error: 'characters' is unavailable: Please\
    \ use String directly\n    for (index, character) in a.characters.enumerated()\
    \ {\n                                ^~~~~~~~~~\nSwift.String:5:16: note: 'characters'\
    \ was obsoleted in Swift 5.0\n    public var characters: String { get set }\n\
    \               ^\n"
  stdout: ''
  timestamp: 1659978480
- exit_code: 0
  program: "\n/// Input are two strings a and b consisting only of 1s and 0s.\n///\
    \ Perform binary XOR on these inputs and return result also as a string.\n///\
    \ >>> string_xor(a: \"010\", b: \"110\")\n/// \"100\"\nfunc string_xor(a: String,\
    \ b: String) -> String {\n    // TODO: your code here\n    let arrayA = Array(a)\n\
    \    let arrayB = Array(b)\n    var xorResult = \"\"\n    for i in 0..<arrayA.count\
    \ {\n        if arrayA[i] == arrayB[i] {\n            xorResult.append(\"0\")\n\
    \        } else {\n            xorResult.append(\"1\")\n        }\n    }\n   \
    \ return xorResult\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) ->\
    \ Bool {\n    if left.count != right.count {\n        return false\n    }\n  \
    \  for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(string_xor(a: \"111000\"\
    , b: \"101010\") == \"010010\")\nassert(string_xor(a: \"1\", b: \"1\") == \"0\"\
    )\nassert(string_xor(a: \"0101\", b: \"0000\") == \"0101\")"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659978480
- exit_code: 0
  program: "\n/// Input are two strings a and b consisting only of 1s and 0s.\n///\
    \ Perform binary XOR on these inputs and return result also as a string.\n///\
    \ >>> string_xor(a: \"010\", b: \"110\")\n/// \"100\"\nfunc string_xor(a: String,\
    \ b: String) -> String {\n    // a.utf8.count is same as a.characters.count\n\
    \    var result = String()\n    let a_chars = Array(a.utf8)\n    let b_chars =\
    \ Array(b.utf8)\n    for i in 0..<a_chars.count {\n        result += String(a_chars[i]\
    \ ^ b_chars[i])\n    }\n    return result\n}\n\n\nfunc ==(left: [(Int, Int)],\
    \ right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n       \
    \ return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r\
    \ {\n            return false\n        }\n    }\n    return true\n}\n        \
    \    \nassert(string_xor(a: \"111000\", b: \"101010\") == \"010010\")\nassert(string_xor(a:\
    \ \"1\", b: \"1\") == \"0\")\nassert(string_xor(a: \"0101\", b: \"0000\") == \"\
    0101\")"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659978480
- exit_code: 0
  program: "\n/// Input are two strings a and b consisting only of 1s and 0s.\n///\
    \ Perform binary XOR on these inputs and return result also as a string.\n///\
    \ >>> string_xor(a: \"010\", b: \"110\")\n/// \"100\"\nfunc string_xor(a: String,\
    \ b: String) -> String {\n    let ca = Array(a)\n    let cb = Array(b)\n    var\
    \ res = [Character]()\n    for i in 0..<a.count {\n        let cai = ca[i]\n \
    \       let cbi = cb[i]\n        var va: UInt8 = 0\n        var vb: UInt8 = 0\n\
    \        if cai == \"1\" {\n            va = 1\n        }\n        if cbi == \"\
    1\" {\n            vb = 1\n        }\n        if va ^ vb == 1 {\n            res.append(\"\
    1\")\n        } else {\n            res.append(\"0\")\n        }\n    }\n    return\
    \ String(res)\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool\
    \ {\n    if left.count != right.count {\n        return false\n    }\n    for\
    \ (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(string_xor(a: \"111000\"\
    , b: \"101010\") == \"010010\")\nassert(string_xor(a: \"1\", b: \"1\") == \"0\"\
    )\nassert(string_xor(a: \"0101\", b: \"0000\") == \"0101\")"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659978480
- exit_code: 1
  program: "\n/// Input are two strings a and b consisting only of 1s and 0s.\n///\
    \ Perform binary XOR on these inputs and return result also as a string.\n///\
    \ >>> string_xor(a: \"010\", b: \"110\")\n/// \"100\"\nfunc string_xor(a: String,\
    \ b: String) -> String {\n    let aa = [UInt8](a.utf8)\n    let bb = [UInt8](b.utf8)\n\
    \    let length = min(aa.count, bb.count)\n    var output = [UInt8]()\n    for\
    \ i in 0..<length {\n        output.append(aa[i] ^ bb[i])\n    }\n    return String(bytes:\
    \ output, encoding: .utf8)!\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int,\
    \ Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n\
    \    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n          \
    \  return false\n        }\n    }\n    return true\n}\n            \nassert(string_xor(a:\
    \ \"111000\", b: \"101010\") == \"010010\")\nassert(string_xor(a: \"1\", b: \"\
    1\") == \"0\")\nassert(string_xor(a: \"0101\", b: \"0000\") == \"0101\")"
  status: SyntaxError
  stderr: "/tmp/tmp85svo8hd.swift:14:12: error: no exact matches in call to initializer\
    \ \n    return String(bytes: output, encoding: .utf8)!\n           ^\n/tmp/tmp85svo8hd.swift:14:12:\
    \ note: found candidate with type '(Array<_>, _.Type) -> String'\n    return String(bytes:\
    \ output, encoding: .utf8)!\n           ^\n/tmp/tmp85svo8hd.swift:14:12: note:\
    \ found candidate with type '([UInt8]) -> String'\n    return String(bytes: output,\
    \ encoding: .utf8)!\n           ^\n/tmp/tmp85svo8hd.swift:14:12: note: found candidate\
    \ with type '(Substring.UTF8View) -> String?'\n    return String(bytes: output,\
    \ encoding: .utf8)!\n           ^\n/tmp/tmp85svo8hd.swift:14:12: note: found candidate\
    \ with type '(Substring.UTF16View) -> String?'\n    return String(bytes: output,\
    \ encoding: .utf8)!\n           ^\n"
  stdout: ''
  timestamp: 1659978480
- exit_code: 1
  program: "\n/// Input are two strings a and b consisting only of 1s and 0s.\n///\
    \ Perform binary XOR on these inputs and return result also as a string.\n///\
    \ >>> string_xor(a: \"010\", b: \"110\")\n/// \"100\"\nfunc string_xor(a: String,\
    \ b: String) -> String {\n    let result = zip(a, b).map { $0 != $1 ? \"1\" :\
    \ \"0\" }\n    return String(result)\n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(string_xor(a: \"111000\", b: \"101010\") == \"010010\")\nassert(string_xor(a:\
    \ \"1\", b: \"1\") == \"0\")\nassert(string_xor(a: \"0101\", b: \"0000\") == \"\
    0101\")"
  status: SyntaxError
  stderr: "/tmp/tmpo907d70h.swift:8:12: error: no exact matches in call to initializer\
    \ \n    return String(result)\n           ^\nSwift.String:4:12: note: candidate\
    \ requires that the types 'String' and 'Character' be equivalent (requirement\
    \ specified as 'S.Element' == 'Character')\n    public init<S>(_ characters: S)\
    \ where S : Sequence, S.Element == Character\n           ^\nSwift.RangeReplaceableCollection:3:23:\
    \ note: candidate requires that the types 'String.Element' (aka 'Character') and\
    \ 'String' be equivalent (requirement specified as 'Self.Element' == 'S.Element')\n\
    \    @inlinable public init<S>(_ elements: S) where S : Sequence, Self.Element\
    \ == S.Element\n                      ^\nSwift.String:2:12: note: incorrect labels\
    \ for candidate (have: '(_:)', expected: '(describing:)')\n    public init<Subject>(describing\
    \ instance: Subject)\n           ^\nSwift.String:3:23: note: incorrect labels\
    \ for candidate (have: '(_:)', expected: '(describing:)')\n    @inlinable public\
    \ init<Subject>(describing instance: Subject) where Subject : CustomStringConvertible\n\
    \                      ^\nSwift.String:6:12: note: incorrect labels for candidate\
    \ (have: '(_:)', expected: '(reflecting:)')\n    public init<Subject>(reflecting\
    \ subject: Subject)\n           ^\n"
  stdout: ''
  timestamp: 1659978480
- exit_code: 1
  program: "\n/// Input are two strings a and b consisting only of 1s and 0s.\n///\
    \ Perform binary XOR on these inputs and return result also as a string.\n///\
    \ >>> string_xor(a: \"010\", b: \"110\")\n/// \"100\"\nfunc string_xor(a: String,\
    \ b: String) -> String {\n  assert(a.characters.count == b.characters.count)\n\
    \  var result = \"\"\n  for i in 0..<a.characters.count {\n    if a[i] == b[i]\
    \ {\n      result += \"0\"\n    } else {\n      result += \"1\"\n    }\n  }\n\
    \  return result\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool\
    \ {\n    if left.count != right.count {\n        return false\n    }\n    for\
    \ (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(string_xor(a: \"111000\"\
    , b: \"101010\") == \"010010\")\nassert(string_xor(a: \"1\", b: \"1\") == \"0\"\
    )\nassert(string_xor(a: \"0101\", b: \"0000\") == \"0101\")"
  status: SyntaxError
  stderr: "/tmp/tmpxvz5vk24.swift:7:12: error: 'characters' is unavailable: Please\
    \ use String directly\n  assert(a.characters.count == b.characters.count)\n  \
    \         ^~~~~~~~~~\nSwift.String:5:16: note: 'characters' was obsoleted in Swift\
    \ 5.0\n    public var characters: String { get set }\n               ^\n/tmp/tmpxvz5vk24.swift:7:34:\
    \ error: 'characters' is unavailable: Please use String directly\n  assert(a.characters.count\
    \ == b.characters.count)\n                                 ^~~~~~~~~~\nSwift.String:5:16:\
    \ note: 'characters' was obsoleted in Swift 5.0\n    public var characters: String\
    \ { get set }\n               ^\n/tmp/tmpxvz5vk24.swift:9:18: error: 'characters'\
    \ is unavailable: Please use String directly\n  for i in 0..<a.characters.count\
    \ {\n                 ^~~~~~~~~~\nSwift.String:5:16: note: 'characters' was obsoleted\
    \ in Swift 5.0\n    public var characters: String { get set }\n              \
    \ ^\n/tmp/tmpxvz5vk24.swift:10:8: error: 'subscript(_:)' is unavailable: cannot\
    \ subscript String with an Int, use a String.Index instead.\n    if a[i] == b[i]\
    \ {\n       ^~~~\nSwift.String:3:12: note: 'subscript(_:)' has been explicitly\
    \ marked unavailable here\n    public subscript(i: Int) -> Character { get }\n\
    \           ^\n/tmp/tmpxvz5vk24.swift:10:16: error: 'subscript(_:)' is unavailable:\
    \ cannot subscript String with an Int, use a String.Index instead.\n    if a[i]\
    \ == b[i] {\n               ^~~~\nSwift.String:3:12: note: 'subscript(_:)' has\
    \ been explicitly marked unavailable here\n    public subscript(i: Int) -> Character\
    \ { get }\n           ^\n"
  stdout: ''
  timestamp: 1659978480
- exit_code: 1
  program: "\n/// Input are two strings a and b consisting only of 1s and 0s.\n///\
    \ Perform binary XOR on these inputs and return result also as a string.\n///\
    \ >>> string_xor(a: \"010\", b: \"110\")\n/// \"100\"\nfunc string_xor(a: String,\
    \ b: String) -> String {\n    var str = \"\"\n    for i in 0..<a.count {\n   \
    \     let n1 = (a[i] == \"1\")\n        let n2 = (b[i] == \"1\")\n        if n1\
    \ != n2 {\n            str += \"1\"\n        } else {\n            str += \"0\"\
    \n        }\n    }\n    return str\n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(string_xor(a: \"111000\", b: \"101010\") == \"010010\")\nassert(string_xor(a:\
    \ \"1\", b: \"1\") == \"0\")\nassert(string_xor(a: \"0101\", b: \"0000\") == \"\
    0101\")"
  status: SyntaxError
  stderr: "/tmp/tmpodx5bfh4.swift:9:19: error: 'subscript(_:)' is unavailable: cannot\
    \ subscript String with an Int, use a String.Index instead.\n        let n1 =\
    \ (a[i] == \"1\")\n                  ^~~~\nSwift.String:3:12: note: 'subscript(_:)'\
    \ has been explicitly marked unavailable here\n    public subscript(i: Int) ->\
    \ Character { get }\n           ^\n/tmp/tmpodx5bfh4.swift:10:19: error: 'subscript(_:)'\
    \ is unavailable: cannot subscript String with an Int, use a String.Index instead.\n\
    \        let n2 = (b[i] == \"1\")\n                  ^~~~\nSwift.String:3:12:\
    \ note: 'subscript(_:)' has been explicitly marked unavailable here\n    public\
    \ subscript(i: Int) -> Character { get }\n           ^\n"
  stdout: ''
  timestamp: 1659978480
- exit_code: 1
  program: "\n/// Input are two strings a and b consisting only of 1s and 0s.\n///\
    \ Perform binary XOR on these inputs and return result also as a string.\n///\
    \ >>> string_xor(a: \"010\", b: \"110\")\n/// \"100\"\nfunc string_xor(a: String,\
    \ b: String) -> String {\n    var xorStr = \"\"\n    for idx in 0..<a.count {\n\
    \        xorStr += String(Int(String(a[idx]))! ^ Int(String(b[idx]))!)\n    }\n\
    \    return xorStr\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) ->\
    \ Bool {\n    if left.count != right.count {\n        return false\n    }\n  \
    \  for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(string_xor(a: \"111000\"\
    , b: \"101010\") == \"010010\")\nassert(string_xor(a: \"1\", b: \"1\") == \"0\"\
    )\nassert(string_xor(a: \"0101\", b: \"0000\") == \"0101\")"
  status: SyntaxError
  stderr: "/tmp/tmpvhfvuu1f.swift:9:37: error: 'subscript(_:)' is unavailable: cannot\
    \ subscript String with an Int, use a String.Index instead.\n        xorStr +=\
    \ String(Int(String(a[idx]))! ^ Int(String(b[idx]))!)\n                      \
    \              ^~~~~~\nSwift.String:3:12: note: 'subscript(_:)' has been explicitly\
    \ marked unavailable here\n    public subscript(i: Int) -> Character { get }\n\
    \           ^\n/tmp/tmpvhfvuu1f.swift:9:60: error: 'subscript(_:)' is unavailable:\
    \ cannot subscript String with an Int, use a String.Index instead.\n        xorStr\
    \ += String(Int(String(a[idx]))! ^ Int(String(b[idx]))!)\n                   \
    \                                        ^~~~~~\nSwift.String:3:12: note: 'subscript(_:)'\
    \ has been explicitly marked unavailable here\n    public subscript(i: Int) ->\
    \ Character { get }\n           ^\n"
  stdout: ''
  timestamp: 1659978481
- exit_code: 0
  program: "\n/// Input are two strings a and b consisting only of 1s and 0s.\n///\
    \ Perform binary XOR on these inputs and return result also as a string.\n///\
    \ >>> string_xor(a: \"010\", b: \"110\")\n/// \"100\"\nfunc string_xor(a: String,\
    \ b: String) -> String {\n    var result = String()\n    for i in 0..<a.count\
    \ {\n        let a_char = String(a[a.index(a.startIndex, offsetBy: i)])\n    \
    \    let b_char = String(b[b.index(b.startIndex, offsetBy: i)])\n        if a_char\
    \ == b_char {\n            result.append(\"0\")\n        } else {\n          \
    \  result.append(\"1\")\n        }\n    }\n    return result\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(string_xor(a: \"111000\", b: \"101010\") == \"010010\"\
    )\nassert(string_xor(a: \"1\", b: \"1\") == \"0\")\nassert(string_xor(a: \"0101\"\
    , b: \"0000\") == \"0101\")"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659978480
- exit_code: 1
  program: "\n/// Input are two strings a and b consisting only of 1s and 0s.\n///\
    \ Perform binary XOR on these inputs and return result also as a string.\n///\
    \ >>> string_xor(a: \"010\", b: \"110\")\n/// \"100\"\nfunc string_xor(a: String,\
    \ b: String) -> String {\n    let sum = Array(zip(a, b)).map(^)\n    return String(sum)\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(string_xor(a: \"111000\", b: \"101010\") == \"\
    010010\")\nassert(string_xor(a: \"1\", b: \"1\") == \"0\")\nassert(string_xor(a:\
    \ \"0101\", b: \"0000\") == \"0101\")"
  status: SyntaxError
  stderr: "/tmp/tmpfg6229fx.swift:7:21: error: missing argument label 'arrayLiteral:'\
    \ in call\n    let sum = Array(zip(a, b)).map(^)\n                    ^\n    \
    \                arrayLiteral: \n/tmp/tmpfg6229fx.swift:7:36: error: cannot convert\
    \ value of type '(UInt8, UInt8) -> UInt8' to expected argument type '(Zip2Sequence<String,\
    \ String>) throws -> UInt8'\n    let sum = Array(zip(a, b)).map(^)\n         \
    \                          ^\n"
  stdout: ''
  timestamp: 1659978480
- exit_code: 0
  program: "\n/// Input are two strings a and b consisting only of 1s and 0s.\n///\
    \ Perform binary XOR on these inputs and return result also as a string.\n///\
    \ >>> string_xor(a: \"010\", b: \"110\")\n/// \"100\"\nfunc string_xor(a: String,\
    \ b: String) -> String {\n    let aChars = Array(a.utf8)\n    let bChars = Array(b.utf8)\n\
    \    var result = String()\n    for i in 0..<aChars.count {\n        if aChars[i]\
    \ == bChars[i] {\n            result.append(\"0\")\n        } else {\n       \
    \     result.append(\"1\")\n        }\n    }\n    return result\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(string_xor(a: \"111000\", b: \"101010\") == \"010010\"\
    )\nassert(string_xor(a: \"1\", b: \"1\") == \"0\")\nassert(string_xor(a: \"0101\"\
    , b: \"0000\") == \"0101\")"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659978480
- exit_code: 1
  program: "\n/// Input are two strings a and b consisting only of 1s and 0s.\n///\
    \ Perform binary XOR on these inputs and return result also as a string.\n///\
    \ >>> string_xor(a: \"010\", b: \"110\")\n/// \"100\"\nfunc string_xor(a: String,\
    \ b: String) -> String {\n    let a: UInt8 = UInt8(strtoul(a, nil, 2))\n    let\
    \ b: UInt8 = UInt8(strtoul(b, nil, 2))\n    let c: UInt8 = a ^ b\n    return String(c,\
    \ radix: 2)\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n\
    \    if left.count != right.count {\n        return false\n    }\n    for (l,\
    \ r) in zip(left, right) {\n        if l != r {\n            return false\n  \
    \      }\n    }\n    return true\n}\n            \nassert(string_xor(a: \"111000\"\
    , b: \"101010\") == \"010010\")\nassert(string_xor(a: \"1\", b: \"1\") == \"0\"\
    )\nassert(string_xor(a: \"0101\", b: \"0000\") == \"0101\")"
  status: SyntaxError
  stderr: "/tmp/tmprmp9qctd.swift:7:26: error: cannot find 'strtoul' in scope\n  \
    \  let a: UInt8 = UInt8(strtoul(a, nil, 2))\n                         ^~~~~~~\n\
    /tmp/tmprmp9qctd.swift:7:37: error: 'nil' requires a contextual type\n    let\
    \ a: UInt8 = UInt8(strtoul(a, nil, 2))\n                                    ^\n\
    /tmp/tmprmp9qctd.swift:8:26: error: cannot find 'strtoul' in scope\n    let b:\
    \ UInt8 = UInt8(strtoul(b, nil, 2))\n                         ^~~~~~~\n/tmp/tmprmp9qctd.swift:8:37:\
    \ error: 'nil' requires a contextual type\n    let b: UInt8 = UInt8(strtoul(b,\
    \ nil, 2))\n                                    ^\n"
  stdout: ''
  timestamp: 1659978480
- exit_code: 1
  program: "\n/// Input are two strings a and b consisting only of 1s and 0s.\n///\
    \ Perform binary XOR on these inputs and return result also as a string.\n///\
    \ >>> string_xor(a: \"010\", b: \"110\")\n/// \"100\"\nfunc string_xor(a: String,\
    \ b: String) -> String {\n    var result = \"\"\n    for i in 0..<a.count {\n\
    \        let x = a[i]\n        let y = b[i]\n        result += String(Int(String(x))!\
    \ ^ Int(String(y))!)\n    }\n    return result\n}\n\n\nfunc ==(left: [(Int, Int)],\
    \ right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n       \
    \ return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r\
    \ {\n            return false\n        }\n    }\n    return true\n}\n        \
    \    \nassert(string_xor(a: \"111000\", b: \"101010\") == \"010010\")\nassert(string_xor(a:\
    \ \"1\", b: \"1\") == \"0\")\nassert(string_xor(a: \"0101\", b: \"0000\") == \"\
    0101\")"
  status: SyntaxError
  stderr: "/tmp/tmpklc5xn3b.swift:9:17: error: 'subscript(_:)' is unavailable: cannot\
    \ subscript String with an Int, use a String.Index instead.\n        let x = a[i]\n\
    \                ^~~~\nSwift.String:3:12: note: 'subscript(_:)' has been explicitly\
    \ marked unavailable here\n    public subscript(i: Int) -> Character { get }\n\
    \           ^\n/tmp/tmpklc5xn3b.swift:10:17: error: 'subscript(_:)' is unavailable:\
    \ cannot subscript String with an Int, use a String.Index instead.\n        let\
    \ y = b[i]\n                ^~~~\nSwift.String:3:12: note: 'subscript(_:)' has\
    \ been explicitly marked unavailable here\n    public subscript(i: Int) -> Character\
    \ { get }\n           ^\n"
  stdout: ''
  timestamp: 1659978480
- exit_code: 1
  program: "\n/// Input are two strings a and b consisting only of 1s and 0s.\n///\
    \ Perform binary XOR on these inputs and return result also as a string.\n///\
    \ >>> string_xor(a: \"010\", b: \"110\")\n/// \"100\"\nfunc string_xor(a: String,\
    \ b: String) -> String {\n    let a_array = Array(a.characters)\n    let b_array\
    \ = Array(b.characters)\n    var res = \"\"\n    for i in 0..<a_array.count {\n\
    \        res += String(a_array[i] != b_array[i])\n    }\n    return res\n}\n\n\
    \nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(string_xor(a: \"111000\", b: \"101010\") == \"\
    010010\")\nassert(string_xor(a: \"1\", b: \"1\") == \"0\")\nassert(string_xor(a:\
    \ \"0101\", b: \"0000\") == \"0101\")"
  status: SyntaxError
  stderr: "/tmp/tmpihyo82s_.swift:7:27: error: 'characters' is unavailable: Please\
    \ use String directly\n    let a_array = Array(a.characters)\n               \
    \           ^~~~~~~~~~\nSwift.String:5:16: note: 'characters' was obsoleted in\
    \ Swift 5.0\n    public var characters: String { get set }\n               ^\n\
    /tmp/tmpihyo82s_.swift:8:27: error: 'characters' is unavailable: Please use String\
    \ directly\n    let b_array = Array(b.characters)\n                          ^~~~~~~~~~\n\
    Swift.String:5:16: note: 'characters' was obsoleted in Swift 5.0\n    public var\
    \ characters: String { get set }\n               ^\n"
  stdout: ''
  timestamp: 1659978480
- exit_code: 0
  program: "\n/// Input are two strings a and b consisting only of 1s and 0s.\n///\
    \ Perform binary XOR on these inputs and return result also as a string.\n///\
    \ >>> string_xor(a: \"010\", b: \"110\")\n/// \"100\"\nfunc string_xor(a: String,\
    \ b: String) -> String {\n    guard a.count == b.count else {\n        preconditionFailure(\"\
    Length of input strings are different!\")\n    }\n    var result = \"\"\n    for\
    \ (c1, c2) in zip(a, b) {\n        let i1 = Int(String(c1))!\n        let i2 =\
    \ Int(String(c2))!\n        result += \"\\(i1 ^ i2)\"\n    }\n    return result\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(string_xor(a: \"111000\", b: \"101010\") == \"\
    010010\")\nassert(string_xor(a: \"1\", b: \"1\") == \"0\")\nassert(string_xor(a:\
    \ \"0101\", b: \"0000\") == \"0101\")"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659978480
- exit_code: 0
  program: "\n/// Input are two strings a and b consisting only of 1s and 0s.\n///\
    \ Perform binary XOR on these inputs and return result also as a string.\n///\
    \ >>> string_xor(a: \"010\", b: \"110\")\n/// \"100\"\nfunc string_xor(a: String,\
    \ b: String) -> String {\n    var result = \"\"\n    let a_arr = Array(a)\n  \
    \  let b_arr = Array(b)\n    for i in 0..<a_arr.count {\n        if a_arr[i] ==\
    \ b_arr[i] {\n            result += \"0\"\n        } else {\n            result\
    \ += \"1\"\n        }\n    }\n    return result\n}\n\n\nfunc ==(left: [(Int, Int)],\
    \ right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n       \
    \ return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r\
    \ {\n            return false\n        }\n    }\n    return true\n}\n        \
    \    \nassert(string_xor(a: \"111000\", b: \"101010\") == \"010010\")\nassert(string_xor(a:\
    \ \"1\", b: \"1\") == \"0\")\nassert(string_xor(a: \"0101\", b: \"0000\") == \"\
    0101\")"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659978480
- exit_code: 1
  program: "\n/// Input are two strings a and b consisting only of 1s and 0s.\n///\
    \ Perform binary XOR on these inputs and return result also as a string.\n///\
    \ >>> string_xor(a: \"010\", b: \"110\")\n/// \"100\"\nfunc string_xor(a: String,\
    \ b: String) -> String {\n    return to_bin_string(string_to_int(a) ^ string_to_int(b))\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(string_xor(a: \"111000\", b: \"101010\") == \"\
    010010\")\nassert(string_xor(a: \"1\", b: \"1\") == \"0\")\nassert(string_xor(a:\
    \ \"0101\", b: \"0000\") == \"0101\")"
  status: SyntaxError
  stderr: "/tmp/tmphipke3uc.swift:7:12: error: cannot find 'to_bin_string' in scope\n\
    \    return to_bin_string(string_to_int(a) ^ string_to_int(b))\n           ^~~~~~~~~~~~~\n\
    /tmp/tmphipke3uc.swift:7:26: error: cannot find 'string_to_int' in scope\n   \
    \ return to_bin_string(string_to_int(a) ^ string_to_int(b))\n                \
    \         ^~~~~~~~~~~~~\n/tmp/tmphipke3uc.swift:7:45: error: cannot find 'string_to_int'\
    \ in scope\n    return to_bin_string(string_to_int(a) ^ string_to_int(b))\n  \
    \                                          ^~~~~~~~~~~~~\n"
  stdout: ''
  timestamp: 1659978480
- exit_code: 1
  program: "\n/// Input are two strings a and b consisting only of 1s and 0s.\n///\
    \ Perform binary XOR on these inputs and return result also as a string.\n///\
    \ >>> string_xor(a: \"010\", b: \"110\")\n/// \"100\"\nfunc string_xor(a: String,\
    \ b: String) -> String {\n  var result = \"\"\n  for i in 0..<a.characters.count\
    \ {\n    let index = a.startIndex.advancedBy(i)\n    let a_digit = a[index]\n\
    \    let b_digit = b[index]\n    switch (a_digit, b_digit) {\n    case (\"0\"\
    , \"0\"):\n      result += \"0\"\n    case (\"0\", \"1\"):\n      result += \"\
    1\"\n    case (\"1\", \"0\"):\n      result += \"1\"\n    case (\"1\", \"1\"):\n\
    \      result += \"0\"\n    default:\n      break\n    }\n  }\n  return result\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(string_xor(a: \"111000\", b: \"101010\") == \"\
    010010\")\nassert(string_xor(a: \"1\", b: \"1\") == \"0\")\nassert(string_xor(a:\
    \ \"0101\", b: \"0000\") == \"0101\")"
  status: SyntaxError
  stderr: "/tmp/tmpan0eqe3g.swift:8:18: error: 'characters' is unavailable: Please\
    \ use String directly\n  for i in 0..<a.characters.count {\n                 ^~~~~~~~~~\n\
    Swift.String:5:16: note: 'characters' was obsoleted in Swift 5.0\n    public var\
    \ characters: String { get set }\n               ^\n/tmp/tmpan0eqe3g.swift:9:30:\
    \ error: value of type 'String.Index' has no member 'advancedBy'\n    let index\
    \ = a.startIndex.advancedBy(i)\n                ~~~~~~~~~~~~ ^~~~~~~~~~\n"
  stdout: ''
  timestamp: 1659978480
- exit_code: 0
  program: "\n/// Input are two strings a and b consisting only of 1s and 0s.\n///\
    \ Perform binary XOR on these inputs and return result also as a string.\n///\
    \ >>> string_xor(a: \"010\", b: \"110\")\n/// \"100\"\nfunc string_xor(a: String,\
    \ b: String) -> String {\n    var output = \"\"\n    for (c, d) in zip(a, b) {\n\
    \        let c_value = c.wholeNumberValue!\n        let d_value = d.wholeNumberValue!\n\
    \        let xor = c_value ^ d_value\n        output += String(xor)\n    }\n \
    \   return output\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) ->\
    \ Bool {\n    if left.count != right.count {\n        return false\n    }\n  \
    \  for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(string_xor(a: \"111000\"\
    , b: \"101010\") == \"010010\")\nassert(string_xor(a: \"1\", b: \"1\") == \"0\"\
    )\nassert(string_xor(a: \"0101\", b: \"0000\") == \"0101\")"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659978480
- exit_code: 1
  program: "\n/// Input are two strings a and b consisting only of 1s and 0s.\n///\
    \ Perform binary XOR on these inputs and return result also as a string.\n///\
    \ >>> string_xor(a: \"010\", b: \"110\")\n/// \"100\"\nfunc string_xor(a: String,\
    \ b: String) -> String {\n    let a_bits = BitSet(input: a)\n    let b_bits =\
    \ BitSet(input: b)\n    return (a_bits ^ b_bits).description\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(string_xor(a: \"111000\", b: \"101010\") == \"010010\"\
    )\nassert(string_xor(a: \"1\", b: \"1\") == \"0\")\nassert(string_xor(a: \"0101\"\
    , b: \"0000\") == \"0101\")"
  status: SyntaxError
  stderr: "/tmp/tmpaornm9zp.swift:7:18: error: cannot find 'BitSet' in scope\n   \
    \ let a_bits = BitSet(input: a)\n                 ^~~~~~\n/tmp/tmpaornm9zp.swift:8:18:\
    \ error: cannot find 'BitSet' in scope\n    let b_bits = BitSet(input: b)\n  \
    \               ^~~~~~\n"
  stdout: ''
  timestamp: 1659978480
- exit_code: 0
  program: "\n/// Input are two strings a and b consisting only of 1s and 0s.\n///\
    \ Perform binary XOR on these inputs and return result also as a string.\n///\
    \ >>> string_xor(a: \"010\", b: \"110\")\n/// \"100\"\nfunc string_xor(a: String,\
    \ b: String) -> String {\n    let a_len = a.count\n    let b_len = b.count\n \
    \   let diff = abs(a_len - b_len)\n    let bits = diff + (a_len < b_len ? a_len\
    \ : b_len)\n    var c = String()\n    for i in 0..<bits {\n        let a_ch =\
    \ i < a_len ? a[a.index(a.startIndex, offsetBy: i)] : \"0\"\n        let b_ch\
    \ = i < b_len ? b[b.index(b.startIndex, offsetBy: i)] : \"0\"\n        if a_ch\
    \ == b_ch {\n            c.append(\"0\")\n        } else {\n            c.append(\"\
    1\")\n        }\n    }\n    return c\n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(string_xor(a: \"111000\", b: \"101010\") == \"010010\")\nassert(string_xor(a:\
    \ \"1\", b: \"1\") == \"0\")\nassert(string_xor(a: \"0101\", b: \"0000\") == \"\
    0101\")"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659978480
- exit_code: 0
  program: "\n/// Input are two strings a and b consisting only of 1s and 0s.\n///\
    \ Perform binary XOR on these inputs and return result also as a string.\n///\
    \ >>> string_xor(a: \"010\", b: \"110\")\n/// \"100\"\nfunc string_xor(a: String,\
    \ b: String) -> String {\n    var result = \"\"\n    for i in 0..<a.count {\n\
    \        let aChar = a[a.index(a.startIndex, offsetBy: i)]\n        let bChar\
    \ = b[b.index(b.startIndex, offsetBy: i)]\n        result += (aChar == bChar)\
    \ ? \"0\" : \"1\"\n    }\n    return result\n}\n\n\nfunc ==(left: [(Int, Int)],\
    \ right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n       \
    \ return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r\
    \ {\n            return false\n        }\n    }\n    return true\n}\n        \
    \    \nassert(string_xor(a: \"111000\", b: \"101010\") == \"010010\")\nassert(string_xor(a:\
    \ \"1\", b: \"1\") == \"0\")\nassert(string_xor(a: \"0101\", b: \"0000\") == \"\
    0101\")"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659978480
- exit_code: 1
  program: "\n/// Input are two strings a and b consisting only of 1s and 0s.\n///\
    \ Perform binary XOR on these inputs and return result also as a string.\n///\
    \ >>> string_xor(a: \"010\", b: \"110\")\n/// \"100\"\nfunc string_xor(a: String,\
    \ b: String) -> String {\n    let arrayA = Array(a.characters)\n    let arrayB\
    \ = Array(b.characters)\n    var ret = \"\"\n    for i in 0..<arrayA.count {\n\
    \        if arrayA[i] == arrayB[i] {\n            ret += \"0\"\n        } else\
    \ {\n            ret += \"1\"\n        }\n    }\n    return ret\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(string_xor(a: \"111000\", b: \"101010\") == \"010010\"\
    )\nassert(string_xor(a: \"1\", b: \"1\") == \"0\")\nassert(string_xor(a: \"0101\"\
    , b: \"0000\") == \"0101\")"
  status: SyntaxError
  stderr: "/tmp/tmphmt6jos8.swift:7:26: error: 'characters' is unavailable: Please\
    \ use String directly\n    let arrayA = Array(a.characters)\n                \
    \         ^~~~~~~~~~\nSwift.String:5:16: note: 'characters' was obsoleted in Swift\
    \ 5.0\n    public var characters: String { get set }\n               ^\n/tmp/tmphmt6jos8.swift:8:26:\
    \ error: 'characters' is unavailable: Please use String directly\n    let arrayB\
    \ = Array(b.characters)\n                         ^~~~~~~~~~\nSwift.String:5:16:\
    \ note: 'characters' was obsoleted in Swift 5.0\n    public var characters: String\
    \ { get set }\n               ^\n"
  stdout: ''
  timestamp: 1659978480
- exit_code: 1
  program: "\n/// Input are two strings a and b consisting only of 1s and 0s.\n///\
    \ Perform binary XOR on these inputs and return result also as a string.\n///\
    \ >>> string_xor(a: \"010\", b: \"110\")\n/// \"100\"\nfunc string_xor(a: String,\
    \ b: String) -> String {\n    return String(zip(a, b).map(^))\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(string_xor(a: \"111000\", b: \"101010\") == \"010010\"\
    )\nassert(string_xor(a: \"1\", b: \"1\") == \"0\")\nassert(string_xor(a: \"0101\"\
    , b: \"0000\") == \"0101\")"
  status: SyntaxError
  stderr: "/tmp/tmp5qiefeh9.swift:7:33: error: no exact matches in reference to operator\
    \ function '^'\n    return String(zip(a, b).map(^))\n                        \
    \        ^\nSwift.BinaryInteger:1:17: note: candidate requires that 'String.Element'\
    \ (aka 'Character') conform to 'BinaryInteger' (requirement specified as 'Self'\
    \ : 'BinaryInteger')\npublic protocol BinaryInteger : CustomStringConvertible,\
    \ Hashable, Numeric, Strideable where Self.Magnitude : BinaryInteger, Self.Magnitude\
    \ == Self.Magnitude.Magnitude {\n                ^\nSwift.BinaryInteger:1:11:\
    \ note: candidate requires that 'String.Element' (aka 'Character') conform to\
    \ 'BinaryInteger' (requirement specified as 'Self' : 'BinaryInteger')\nextension\
    \ BinaryInteger {\n          ^\nSwift.SIMD:1:11: note: candidate requires that\
    \ 'String.Element' (aka 'Character') conform to 'SIMD' (requirement specified\
    \ as 'Self' : 'SIMD')\nextension SIMD where Self.Scalar : FixedWidthInteger {\n\
    \          ^\n"
  stdout: ''
  timestamp: 1659978479
- exit_code: 0
  program: "\n/// Input are two strings a and b consisting only of 1s and 0s.\n///\
    \ Perform binary XOR on these inputs and return result also as a string.\n///\
    \ >>> string_xor(a: \"010\", b: \"110\")\n/// \"100\"\nfunc string_xor(a: String,\
    \ b: String) -> String {\n  var result = \"\"\n  for index in a.indices {\n  \
    \  if a[index] == b[index] {\n      result.append(\"0\")\n    } else {\n     \
    \ result.append(\"1\")\n    }\n  }\n  return result\n}\n\n\nfunc ==(left: [(Int,\
    \ Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n\
    \        return false\n    }\n    for (l, r) in zip(left, right) {\n        if\
    \ l != r {\n            return false\n        }\n    }\n    return true\n}\n \
    \           \nassert(string_xor(a: \"111000\", b: \"101010\") == \"010010\")\n\
    assert(string_xor(a: \"1\", b: \"1\") == \"0\")\nassert(string_xor(a: \"0101\"\
    , b: \"0000\") == \"0101\")"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659978480
- exit_code: 1
  program: "\n/// Input are two strings a and b consisting only of 1s and 0s.\n///\
    \ Perform binary XOR on these inputs and return result also as a string.\n///\
    \ >>> string_xor(a: \"010\", b: \"110\")\n/// \"100\"\nfunc string_xor(a: String,\
    \ b: String) -> String {\n    let input_size = a.count\n    let a_bit_map = a.makeBitmap()\n\
    \    let b_bit_map = b.makeBitmap()\n    var output = [UInt8](repeating: 0, count:\
    \ input_size)\n    for index in 0..<input_size {\n        output[index] = a_bit_map[index]\
    \ ^ b_bit_map[index]\n    }\n    return output.map { String($0) }.joined()\n}\n\
    \n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(string_xor(a: \"111000\", b: \"101010\") == \"\
    010010\")\nassert(string_xor(a: \"1\", b: \"1\") == \"0\")\nassert(string_xor(a:\
    \ \"0101\", b: \"0000\") == \"0101\")"
  status: SyntaxError
  stderr: "/tmp/tmp1twkd1fd.swift:8:23: error: value of type 'String' has no member\
    \ 'makeBitmap'\n    let a_bit_map = a.makeBitmap()\n                    ~ ^~~~~~~~~~\n\
    /tmp/tmp1twkd1fd.swift:9:23: error: value of type 'String' has no member 'makeBitmap'\n\
    \    let b_bit_map = b.makeBitmap()\n                    ~ ^~~~~~~~~~\n"
  stdout: ''
  timestamp: 1659978480
- exit_code: 0
  program: "\n/// Input are two strings a and b consisting only of 1s and 0s.\n///\
    \ Perform binary XOR on these inputs and return result also as a string.\n///\
    \ >>> string_xor(a: \"010\", b: \"110\")\n/// \"100\"\nfunc string_xor(a: String,\
    \ b: String) -> String {\n    let aAsBits = Array(a).map { UInt8(String($0), radix:\
    \ 2)! }\n    let bAsBits = Array(b).map { UInt8(String($0), radix: 2)! }\n   \
    \ let xorAsBits = zip(aAsBits, bAsBits).map { $0 ^ $1 }\n    return xorAsBits.map\
    \ { String($0, radix: 2) }.joined()\n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(string_xor(a: \"111000\", b: \"101010\") == \"010010\")\nassert(string_xor(a:\
    \ \"1\", b: \"1\") == \"0\")\nassert(string_xor(a: \"0101\", b: \"0000\") == \"\
    0101\")"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659978480
- exit_code: 0
  program: "\n/// Input are two strings a and b consisting only of 1s and 0s.\n///\
    \ Perform binary XOR on these inputs and return result also as a string.\n///\
    \ >>> string_xor(a: \"010\", b: \"110\")\n/// \"100\"\nfunc string_xor(a: String,\
    \ b: String) -> String {\n  // IMPLEMENT ME\n  var xor = \"\"\n  let a_arr = Array(a)\n\
    \  let b_arr = Array(b)\n  if a_arr.count != b_arr.count {\n    return xor\n \
    \ }\n  for i in 0..<a_arr.count {\n    let a_int = Int(String(a_arr[i]))!\n  \
    \  let b_int = Int(String(b_arr[i]))!\n    let c_int = a_int ^ b_int\n    xor\
    \ += String(c_int)\n  }\n  return xor\n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(string_xor(a: \"111000\", b: \"101010\") == \"010010\")\nassert(string_xor(a:\
    \ \"1\", b: \"1\") == \"0\")\nassert(string_xor(a: \"0101\", b: \"0000\") == \"\
    0101\")"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659978480
- exit_code: 1
  program: "\n/// Input are two strings a and b consisting only of 1s and 0s.\n///\
    \ Perform binary XOR on these inputs and return result also as a string.\n///\
    \ >>> string_xor(a: \"010\", b: \"110\")\n/// \"100\"\nfunc string_xor(a: String,\
    \ b: String) -> String {\n    let aa = Array(a)\n    let bb = Array(b)\n    let\
    \ cc = zip(aa, bb).map { $0 != $1 ? \"1\" : \"0\" }\n    return String(cc)\n}\n\
    \n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(string_xor(a: \"111000\", b: \"101010\") == \"\
    010010\")\nassert(string_xor(a: \"1\", b: \"1\") == \"0\")\nassert(string_xor(a:\
    \ \"0101\", b: \"0000\") == \"0101\")"
  status: SyntaxError
  stderr: "/tmp/tmp6ualkwkz.swift:10:12: error: no exact matches in call to initializer\
    \ \n    return String(cc)\n           ^\nSwift.String:4:12: note: candidate requires\
    \ that the types 'String' and 'Character' be equivalent (requirement specified\
    \ as 'S.Element' == 'Character')\n    public init<S>(_ characters: S) where S\
    \ : Sequence, S.Element == Character\n           ^\nSwift.RangeReplaceableCollection:3:23:\
    \ note: candidate requires that the types 'String.Element' (aka 'Character') and\
    \ 'String' be equivalent (requirement specified as 'Self.Element' == 'S.Element')\n\
    \    @inlinable public init<S>(_ elements: S) where S : Sequence, Self.Element\
    \ == S.Element\n                      ^\nSwift.String:2:12: note: incorrect labels\
    \ for candidate (have: '(_:)', expected: '(describing:)')\n    public init<Subject>(describing\
    \ instance: Subject)\n           ^\nSwift.String:3:23: note: incorrect labels\
    \ for candidate (have: '(_:)', expected: '(describing:)')\n    @inlinable public\
    \ init<Subject>(describing instance: Subject) where Subject : CustomStringConvertible\n\
    \                      ^\nSwift.String:6:12: note: incorrect labels for candidate\
    \ (have: '(_:)', expected: '(reflecting:)')\n    public init<Subject>(reflecting\
    \ subject: Subject)\n           ^\n"
  stdout: ''
  timestamp: 1659978480
- exit_code: 0
  program: "\n/// Input are two strings a and b consisting only of 1s and 0s.\n///\
    \ Perform binary XOR on these inputs and return result also as a string.\n///\
    \ >>> string_xor(a: \"010\", b: \"110\")\n/// \"100\"\nfunc string_xor(a: String,\
    \ b: String) -> String {\n    let byteA = Array(a.utf8)\n    let byteB = Array(b.utf8)\n\
    \    if byteA.count != byteB.count {\n        return \"\"\n    }\n    var result\
    \ = String()\n    for i in 0..<byteA.count {\n        let res = byteA[i] ^ byteB[i]\n\
    \        result += String(res, radix: 2)\n    }\n    return result\n}\n\n\nfunc\
    \ ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count !=\
    \ right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(string_xor(a: \"111000\", b: \"101010\") == \"\
    010010\")\nassert(string_xor(a: \"1\", b: \"1\") == \"0\")\nassert(string_xor(a:\
    \ \"0101\", b: \"0000\") == \"0101\")"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659978480
- exit_code: 1
  program: "\n/// Input are two strings a and b consisting only of 1s and 0s.\n///\
    \ Perform binary XOR on these inputs and return result also as a string.\n///\
    \ >>> string_xor(a: \"010\", b: \"110\")\n/// \"100\"\nfunc string_xor(a: String,\
    \ b: String) -> String {\n    var res = String()\n    for i in 0..<a.count {\n\
    \        if a[i] == b[i] {\n            res.append(\"0\")\n        } else {\n\
    \            res.append(\"1\")\n        }\n    }\n    return res\n}\n\n\nfunc\
    \ ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count !=\
    \ right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(string_xor(a: \"111000\", b: \"101010\") == \"\
    010010\")\nassert(string_xor(a: \"1\", b: \"1\") == \"0\")\nassert(string_xor(a:\
    \ \"0101\", b: \"0000\") == \"0101\")"
  status: SyntaxError
  stderr: "/tmp/tmpwp3hgd6m.swift:9:12: error: 'subscript(_:)' is unavailable: cannot\
    \ subscript String with an Int, use a String.Index instead.\n        if a[i] ==\
    \ b[i] {\n           ^~~~\nSwift.String:3:12: note: 'subscript(_:)' has been explicitly\
    \ marked unavailable here\n    public subscript(i: Int) -> Character { get }\n\
    \           ^\n/tmp/tmpwp3hgd6m.swift:9:20: error: 'subscript(_:)' is unavailable:\
    \ cannot subscript String with an Int, use a String.Index instead.\n        if\
    \ a[i] == b[i] {\n                   ^~~~\nSwift.String:3:12: note: 'subscript(_:)'\
    \ has been explicitly marked unavailable here\n    public subscript(i: Int) ->\
    \ Character { get }\n           ^\n"
  stdout: ''
  timestamp: 1659978480
- exit_code: 1
  program: "\n/// Input are two strings a and b consisting only of 1s and 0s.\n///\
    \ Perform binary XOR on these inputs and return result also as a string.\n///\
    \ >>> string_xor(a: \"010\", b: \"110\")\n/// \"100\"\nfunc string_xor(a: String,\
    \ b: String) -> String {\n    var output = \"\"\n    let aChars = Array(a.characters)\n\
    \    let bChars = Array(b.characters)\n    for i in 0..<aChars.count {\n     \
    \   output.append(aChars[i] == bChars[i] ? \"0\" : \"1\")\n    }\n    return output\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(string_xor(a: \"111000\", b: \"101010\") == \"\
    010010\")\nassert(string_xor(a: \"1\", b: \"1\") == \"0\")\nassert(string_xor(a:\
    \ \"0101\", b: \"0000\") == \"0101\")"
  status: SyntaxError
  stderr: "/tmp/tmpd0914f0h.swift:8:26: error: 'characters' is unavailable: Please\
    \ use String directly\n    let aChars = Array(a.characters)\n                \
    \         ^~~~~~~~~~\nSwift.String:5:16: note: 'characters' was obsoleted in Swift\
    \ 5.0\n    public var characters: String { get set }\n               ^\n/tmp/tmpd0914f0h.swift:9:26:\
    \ error: 'characters' is unavailable: Please use String directly\n    let bChars\
    \ = Array(b.characters)\n                         ^~~~~~~~~~\nSwift.String:5:16:\
    \ note: 'characters' was obsoleted in Swift 5.0\n    public var characters: String\
    \ { get set }\n               ^\n"
  stdout: ''
  timestamp: 1659978480
- exit_code: 1
  program: "\n/// Input are two strings a and b consisting only of 1s and 0s.\n///\
    \ Perform binary XOR on these inputs and return result also as a string.\n///\
    \ >>> string_xor(a: \"010\", b: \"110\")\n/// \"100\"\nfunc string_xor(a: String,\
    \ b: String) -> String {\n    let l = a.characters.count < b.characters.count\
    \ ? a.characters.count : b.characters.count\n    var s = \"\"\n    for i in 0..<l\
    \ {\n        let a1 = a.characters[a.characters.index(a.startIndex, offsetBy:\
    \ i)]\n        let b1 = b.characters[b.characters.index(b.startIndex, offsetBy:\
    \ i)]\n        let c1 = (Int(String(a1))! ^ Int(String(b1))!)\n        s += String(c1)\n\
    \    }\n    return s\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(string_xor(a:\
    \ \"111000\", b: \"101010\") == \"010010\")\nassert(string_xor(a: \"1\", b: \"\
    1\") == \"0\")\nassert(string_xor(a: \"0101\", b: \"0000\") == \"0101\")"
  status: SyntaxError
  stderr: "/tmp/tmp22h9lsn4.swift:7:15: error: 'characters' is unavailable: Please\
    \ use String directly\n    let l = a.characters.count < b.characters.count ? a.characters.count\
    \ : b.characters.count\n              ^~~~~~~~~~\nSwift.String:5:16: note: 'characters'\
    \ was obsoleted in Swift 5.0\n    public var characters: String { get set }\n\
    \               ^\n/tmp/tmp22h9lsn4.swift:7:36: error: 'characters' is unavailable:\
    \ Please use String directly\n    let l = a.characters.count < b.characters.count\
    \ ? a.characters.count : b.characters.count\n                                \
    \   ^~~~~~~~~~\nSwift.String:5:16: note: 'characters' was obsoleted in Swift 5.0\n\
    \    public var characters: String { get set }\n               ^\n/tmp/tmp22h9lsn4.swift:7:57:\
    \ error: 'characters' is unavailable: Please use String directly\n    let l =\
    \ a.characters.count < b.characters.count ? a.characters.count : b.characters.count\n\
    \                                                        ^~~~~~~~~~\nSwift.String:5:16:\
    \ note: 'characters' was obsoleted in Swift 5.0\n    public var characters: String\
    \ { get set }\n               ^\n/tmp/tmp22h9lsn4.swift:7:78: error: 'characters'\
    \ is unavailable: Please use String directly\n    let l = a.characters.count <\
    \ b.characters.count ? a.characters.count : b.characters.count\n             \
    \                                                                ^~~~~~~~~~\n\
    Swift.String:5:16: note: 'characters' was obsoleted in Swift 5.0\n    public var\
    \ characters: String { get set }\n               ^\n/tmp/tmp22h9lsn4.swift:10:20:\
    \ error: 'characters' is unavailable: Please use String directly\n        let\
    \ a1 = a.characters[a.characters.index(a.startIndex, offsetBy: i)]\n         \
    \          ^~~~~~~~~~\nSwift.String:5:16: note: 'characters' was obsoleted in\
    \ Swift 5.0\n    public var characters: String { get set }\n               ^\n\
    /tmp/tmp22h9lsn4.swift:10:33: error: 'characters' is unavailable: Please use String\
    \ directly\n        let a1 = a.characters[a.characters.index(a.startIndex, offsetBy:\
    \ i)]\n                                ^~~~~~~~~~\nSwift.String:5:16: note: "
  stdout: ''
  timestamp: 1659978480
- exit_code: 1
  program: "\n/// Input are two strings a and b consisting only of 1s and 0s.\n///\
    \ Perform binary XOR on these inputs and return result also as a string.\n///\
    \ >>> string_xor(a: \"010\", b: \"110\")\n/// \"100\"\nfunc string_xor(a: String,\
    \ b: String) -> String {\n    return String(bytes: zip(a.utf8, b.utf8).map(^),\
    \ encoding: .utf8)!\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) ->\
    \ Bool {\n    if left.count != right.count {\n        return false\n    }\n  \
    \  for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(string_xor(a: \"111000\"\
    , b: \"101010\") == \"010010\")\nassert(string_xor(a: \"1\", b: \"1\") == \"0\"\
    )\nassert(string_xor(a: \"0101\", b: \"0000\") == \"0101\")"
  status: SyntaxError
  stderr: "/tmp/tmp52sb5lnz.swift:7:12: error: no exact matches in call to initializer\
    \ \n    return String(bytes: zip(a.utf8, b.utf8).map(^), encoding: .utf8)!\n \
    \          ^\n/tmp/tmp52sb5lnz.swift:7:12: note: found candidate with type '(Array<_>,\
    \ _.Type) -> String'\n    return String(bytes: zip(a.utf8, b.utf8).map(^), encoding:\
    \ .utf8)!\n           ^\n/tmp/tmp52sb5lnz.swift:7:12: note: found candidate with\
    \ type '(Substring.UTF8View) -> String?'\n    return String(bytes: zip(a.utf8,\
    \ b.utf8).map(^), encoding: .utf8)!\n           ^\n/tmp/tmp52sb5lnz.swift:7:12:\
    \ note: found candidate with type '(Substring.UTF16View) -> String?'\n    return\
    \ String(bytes: zip(a.utf8, b.utf8).map(^), encoding: .utf8)!\n           ^\n"
  stdout: ''
  timestamp: 1659978480
- exit_code: 1
  program: "\n/// Input are two strings a and b consisting only of 1s and 0s.\n///\
    \ Perform binary XOR on these inputs and return result also as a string.\n///\
    \ >>> string_xor(a: \"010\", b: \"110\")\n/// \"100\"\nfunc string_xor(a: String,\
    \ b: String) -> String {\n    if a.count != b.count {\n        return \"nil\"\n\
    \    }\n    var result = \"\"\n    for i in 0..<a.count {\n        let aa = a[i]\n\
    \        let bb = b[i]\n        if aa == bb {\n            result += \"0\"\n \
    \       } else {\n            result += \"1\"\n        }\n    }\n    return result\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(string_xor(a: \"111000\", b: \"101010\") == \"\
    010010\")\nassert(string_xor(a: \"1\", b: \"1\") == \"0\")\nassert(string_xor(a:\
    \ \"0101\", b: \"0000\") == \"0101\")"
  status: SyntaxError
  stderr: "/tmp/tmpvb6c9820.swift:12:18: error: 'subscript(_:)' is unavailable: cannot\
    \ subscript String with an Int, use a String.Index instead.\n        let aa =\
    \ a[i]\n                 ^~~~\nSwift.String:3:12: note: 'subscript(_:)' has been\
    \ explicitly marked unavailable here\n    public subscript(i: Int) -> Character\
    \ { get }\n           ^\n/tmp/tmpvb6c9820.swift:13:18: error: 'subscript(_:)'\
    \ is unavailable: cannot subscript String with an Int, use a String.Index instead.\n\
    \        let bb = b[i]\n                 ^~~~\nSwift.String:3:12: note: 'subscript(_:)'\
    \ has been explicitly marked unavailable here\n    public subscript(i: Int) ->\
    \ Character { get }\n           ^\n"
  stdout: ''
  timestamp: 1659978480
- exit_code: 1
  program: "\n/// Input are two strings a and b consisting only of 1s and 0s.\n///\
    \ Perform binary XOR on these inputs and return result also as a string.\n///\
    \ >>> string_xor(a: \"010\", b: \"110\")\n/// \"100\"\nfunc string_xor(a: String,\
    \ b: String) -> String {\n    let ai = a.compactMap { $0.wholeNumberValue }\n\
    \    let bi = b.compactMap { $0.wholeNumberValue }\n    return String(zip(ai,\
    \ bi).map { $0 ^ $1 })\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(string_xor(a:\
    \ \"111000\", b: \"101010\") == \"010010\")\nassert(string_xor(a: \"1\", b: \"\
    1\") == \"0\")\nassert(string_xor(a: \"0101\", b: \"0000\") == \"0101\")"
  status: SyntaxError
  stderr: "/tmp/tmp221_63hm.swift:9:12: error: type of expression is ambiguous without\
    \ more context\n    return String(zip(ai, bi).map { $0 ^ $1 })\n           ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n"
  stdout: ''
  timestamp: 1659978481
- exit_code: 1
  program: "\n/// Input are two strings a and b consisting only of 1s and 0s.\n///\
    \ Perform binary XOR on these inputs and return result also as a string.\n///\
    \ >>> string_xor(a: \"010\", b: \"110\")\n/// \"100\"\nfunc string_xor(a: String,\
    \ b: String) -> String {\n    let aChars = Array(a.characters)\n    let bChars\
    \ = Array(b.characters)\n    var result = \"\"\n    for i in 0..<aChars.count\
    \ {\n        result += xor(a: Int(String(aChars[i]))!, b: Int(String(bChars[i]))!)\
    \ ? \"1\" : \"0\"\n    }\n    return result\n}\n\n\nfunc ==(left: [(Int, Int)],\
    \ right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n       \
    \ return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r\
    \ {\n            return false\n        }\n    }\n    return true\n}\n        \
    \    \nassert(string_xor(a: \"111000\", b: \"101010\") == \"010010\")\nassert(string_xor(a:\
    \ \"1\", b: \"1\") == \"0\")\nassert(string_xor(a: \"0101\", b: \"0000\") == \"\
    0101\")"
  status: SyntaxError
  stderr: "/tmp/tmpfbrl89rc.swift:7:26: error: 'characters' is unavailable: Please\
    \ use String directly\n    let aChars = Array(a.characters)\n                \
    \         ^~~~~~~~~~\nSwift.String:5:16: note: 'characters' was obsoleted in Swift\
    \ 5.0\n    public var characters: String { get set }\n               ^\n/tmp/tmpfbrl89rc.swift:8:26:\
    \ error: 'characters' is unavailable: Please use String directly\n    let bChars\
    \ = Array(b.characters)\n                         ^~~~~~~~~~\nSwift.String:5:16:\
    \ note: 'characters' was obsoleted in Swift 5.0\n    public var characters: String\
    \ { get set }\n               ^\n/tmp/tmpfbrl89rc.swift:11:19: error: cannot find\
    \ 'xor' in scope\n        result += xor(a: Int(String(aChars[i]))!, b: Int(String(bChars[i]))!)\
    \ ? \"1\" : \"0\"\n                  ^~~\n"
  stdout: ''
  timestamp: 1659978481
- exit_code: 1
  program: "\n/// Input are two strings a and b consisting only of 1s and 0s.\n///\
    \ Perform binary XOR on these inputs and return result also as a string.\n///\
    \ >>> string_xor(a: \"010\", b: \"110\")\n/// \"100\"\nfunc string_xor(a: String,\
    \ b: String) -> String {\n    var r = \"\"\n    for i in 0..<a.characters.count\
    \ {\n        r += String(a[i] == b[i] ? \"0\" : \"1\")\n    }\n    return r\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(string_xor(a: \"111000\", b: \"101010\") == \"\
    010010\")\nassert(string_xor(a: \"1\", b: \"1\") == \"0\")\nassert(string_xor(a:\
    \ \"0101\", b: \"0000\") == \"0101\")"
  status: SyntaxError
  stderr: "/tmp/tmpz9gxxa2v.swift:8:20: error: 'characters' is unavailable: Please\
    \ use String directly\n    for i in 0..<a.characters.count {\n               \
    \    ^~~~~~~~~~\nSwift.String:5:16: note: 'characters' was obsoleted in Swift\
    \ 5.0\n    public var characters: String { get set }\n               ^\n/tmp/tmpz9gxxa2v.swift:9:21:\
    \ error: 'subscript(_:)' is unavailable: cannot subscript String with an Int,\
    \ use a String.Index instead.\n        r += String(a[i] == b[i] ? \"0\" : \"1\"\
    )\n                    ^~~~\nSwift.String:3:12: note: 'subscript(_:)' has been\
    \ explicitly marked unavailable here\n    public subscript(i: Int) -> Character\
    \ { get }\n           ^\n/tmp/tmpz9gxxa2v.swift:9:29: error: 'subscript(_:)' is\
    \ unavailable: cannot subscript String with an Int, use a String.Index instead.\n\
    \        r += String(a[i] == b[i] ? \"0\" : \"1\")\n                         \
    \   ^~~~\nSwift.String:3:12: note: 'subscript(_:)' has been explicitly marked\
    \ unavailable here\n    public subscript(i: Int) -> Character { get }\n      \
    \     ^\n"
  stdout: ''
  timestamp: 1659978481
- exit_code: 1
  program: "\n/// Input are two strings a and b consisting only of 1s and 0s.\n///\
    \ Perform binary XOR on these inputs and return result also as a string.\n///\
    \ >>> string_xor(a: \"010\", b: \"110\")\n/// \"100\"\nfunc string_xor(a: String,\
    \ b: String) -> String {\n    let length = a.characters.count\n    if length !=\
    \ b.characters.count {\n        return \"\"\n    }\n    var result = String()\n\
    \    var index = 0\n    let a = [Character](a.characters)\n    let b = [Character](b.characters)\n\
    \    while index < length {\n        if a[index] == b[index] {\n            result.append(\"\
    0\")\n        } else {\n            result.append(\"1\")\n        }\n        index\
    \ += 1\n    }\n    return result\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int,\
    \ Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n\
    \    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n          \
    \  return false\n        }\n    }\n    return true\n}\n            \nassert(string_xor(a:\
    \ \"111000\", b: \"101010\") == \"010010\")\nassert(string_xor(a: \"1\", b: \"\
    1\") == \"0\")\nassert(string_xor(a: \"0101\", b: \"0000\") == \"0101\")"
  status: SyntaxError
  stderr: "/tmp/tmp4ziy6y5l.swift:7:20: error: 'characters' is unavailable: Please\
    \ use String directly\n    let length = a.characters.count\n                 \
    \  ^~~~~~~~~~\nSwift.String:5:16: note: 'characters' was obsoleted in Swift 5.0\n\
    \    public var characters: String { get set }\n               ^\n/tmp/tmp4ziy6y5l.swift:8:20:\
    \ error: 'characters' is unavailable: Please use String directly\n    if length\
    \ != b.characters.count {\n                   ^~~~~~~~~~\nSwift.String:5:16: note:\
    \ 'characters' was obsoleted in Swift 5.0\n    public var characters: String {\
    \ get set }\n               ^\n/tmp/tmp4ziy6y5l.swift:13:27: error: 'characters'\
    \ is unavailable: Please use String directly\n    let a = [Character](a.characters)\n\
    \                          ^~~~~~~~~~\nSwift.String:5:16: note: 'characters' was\
    \ obsoleted in Swift 5.0\n    public var characters: String { get set }\n    \
    \           ^\n/tmp/tmp4ziy6y5l.swift:14:27: error: 'characters' is unavailable:\
    \ Please use String directly\n    let b = [Character](b.characters)\n        \
    \                  ^~~~~~~~~~\nSwift.String:5:16: note: 'characters' was obsoleted\
    \ in Swift 5.0\n    public var characters: String { get set }\n              \
    \ ^\n"
  stdout: ''
  timestamp: 1659978481
- exit_code: 1
  program: "\n/// Input are two strings a and b consisting only of 1s and 0s.\n///\
    \ Perform binary XOR on these inputs and return result also as a string.\n///\
    \ >>> string_xor(a: \"010\", b: \"110\")\n/// \"100\"\nfunc string_xor(a: String,\
    \ b: String) -> String {\n    var result = \"\"\n    for i in 0..<a.characters.count\
    \ {\n        let a = a[a.startIndex.advancedBy(i)]\n        let b = b[b.startIndex.advancedBy(i)]\n\
    \        result += \"\\(Int(String(a))! ^ Int(String(b))!)\"\n    }\n    return\
    \ result\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n\
    \    if left.count != right.count {\n        return false\n    }\n    for (l,\
    \ r) in zip(left, right) {\n        if l != r {\n            return false\n  \
    \      }\n    }\n    return true\n}\n            \nassert(string_xor(a: \"111000\"\
    , b: \"101010\") == \"010010\")\nassert(string_xor(a: \"1\", b: \"1\") == \"0\"\
    )\nassert(string_xor(a: \"0101\", b: \"0000\") == \"0101\")"
  status: SyntaxError
  stderr: "/tmp/tmp17738t1v.swift:8:20: error: 'characters' is unavailable: Please\
    \ use String directly\n    for i in 0..<a.characters.count {\n               \
    \    ^~~~~~~~~~\nSwift.String:5:16: note: 'characters' was obsoleted in Swift\
    \ 5.0\n    public var characters: String { get set }\n               ^\n/tmp/tmp17738t1v.swift:9:32:\
    \ error: value of type 'String.Index' has no member 'advancedBy'\n        let\
    \ a = a[a.startIndex.advancedBy(i)]\n                  ~~~~~~~~~~~~ ^~~~~~~~~~\n\
    /tmp/tmp17738t1v.swift:10:32: error: value of type 'String.Index' has no member\
    \ 'advancedBy'\n        let b = b[b.startIndex.advancedBy(i)]\n              \
    \    ~~~~~~~~~~~~ ^~~~~~~~~~\n"
  stdout: ''
  timestamp: 1659978481
- exit_code: 1
  program: "\n/// Input are two strings a and b consisting only of 1s and 0s.\n///\
    \ Perform binary XOR on these inputs and return result also as a string.\n///\
    \ >>> string_xor(a: \"010\", b: \"110\")\n/// \"100\"\nfunc string_xor(a: String,\
    \ b: String) -> String {\n    var res = \"\"\n    for i in 0..<a.count {\n   \
    \     if a[i] == b[i] {\n            res += \"0\"\n        } else {\n        \
    \    res += \"1\"\n        }\n    }\n    return res\n}\n\n\nfunc ==(left: [(Int,\
    \ Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n\
    \        return false\n    }\n    for (l, r) in zip(left, right) {\n        if\
    \ l != r {\n            return false\n        }\n    }\n    return true\n}\n \
    \           \nassert(string_xor(a: \"111000\", b: \"101010\") == \"010010\")\n\
    assert(string_xor(a: \"1\", b: \"1\") == \"0\")\nassert(string_xor(a: \"0101\"\
    , b: \"0000\") == \"0101\")"
  status: SyntaxError
  stderr: "/tmp/tmpdl6dwrb8.swift:9:12: error: 'subscript(_:)' is unavailable: cannot\
    \ subscript String with an Int, use a String.Index instead.\n        if a[i] ==\
    \ b[i] {\n           ^~~~\nSwift.String:3:12: note: 'subscript(_:)' has been explicitly\
    \ marked unavailable here\n    public subscript(i: Int) -> Character { get }\n\
    \           ^\n/tmp/tmpdl6dwrb8.swift:9:20: error: 'subscript(_:)' is unavailable:\
    \ cannot subscript String with an Int, use a String.Index instead.\n        if\
    \ a[i] == b[i] {\n                   ^~~~\nSwift.String:3:12: note: 'subscript(_:)'\
    \ has been explicitly marked unavailable here\n    public subscript(i: Int) ->\
    \ Character { get }\n           ^\n"
  stdout: ''
  timestamp: 1659978481
- exit_code: 1
  program: "\n/// Input are two strings a and b consisting only of 1s and 0s.\n///\
    \ Perform binary XOR on these inputs and return result also as a string.\n///\
    \ >>> string_xor(a: \"010\", b: \"110\")\n/// \"100\"\nfunc string_xor(a: String,\
    \ b: String) -> String {\n    var a_ = Array(a)\n    var b_ = Array(b)\n    if\
    \ a_.count > b_.count {\n        let add = Array(repeating: \"0\", count: a_.count\
    \ - b_.count)\n        b_.insert(contentsOf: add, at: 0)\n    } else if a_.count\
    \ < b_.count {\n        let add = Array(repeating: \"0\", count: b_.count - a_.count)\n\
    \        a_.insert(contentsOf: add, at: 0)\n    }\n    var result = [String]()\n\
    \    for i in 0..<a_.count {\n        if a_[i] == b_[i] {\n            result.append(\"\
    0\")\n        } else {\n            result.append(\"1\")\n        }\n    }\n \
    \   return result.joined()\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(string_xor(a:\
    \ \"111000\", b: \"101010\") == \"010010\")\nassert(string_xor(a: \"1\", b: \"\
    1\") == \"0\")\nassert(string_xor(a: \"0101\", b: \"0000\") == \"0101\")"
  status: SyntaxError
  stderr: "/tmp/tmpuar79mut.swift:11:12: error: type of expression is ambiguous without\
    \ more context\n        b_.insert(contentsOf: add, at: 0)\n        ~~~^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n\
    /tmp/tmpuar79mut.swift:14:12: error: type of expression is ambiguous without more\
    \ context\n        a_.insert(contentsOf: add, at: 0)\n        ~~~^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n"
  stdout: ''
  timestamp: 1659978481
- exit_code: 1
  program: "\n/// Input are two strings a and b consisting only of 1s and 0s.\n///\
    \ Perform binary XOR on these inputs and return result also as a string.\n///\
    \ >>> string_xor(a: \"010\", b: \"110\")\n/// \"100\"\nfunc string_xor(a: String,\
    \ b: String) -> String {\n    var result = \"\"\n    for i in 0..<a.characters.count\
    \ {\n        let ia = Int(String(a[a.index(a.startIndex, offsetBy: i)]))!\n  \
    \      let ib = Int(String(b[b.index(b.startIndex, offsetBy: i)]))!\n        result\
    \ += String(ia ^ ib)\n    }\n    return result\n}\n\n\nfunc ==(left: [(Int, Int)],\
    \ right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n       \
    \ return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r\
    \ {\n            return false\n        }\n    }\n    return true\n}\n        \
    \    \nassert(string_xor(a: \"111000\", b: \"101010\") == \"010010\")\nassert(string_xor(a:\
    \ \"1\", b: \"1\") == \"0\")\nassert(string_xor(a: \"0101\", b: \"0000\") == \"\
    0101\")"
  status: SyntaxError
  stderr: "/tmp/tmp2z09owki.swift:8:20: error: 'characters' is unavailable: Please\
    \ use String directly\n    for i in 0..<a.characters.count {\n               \
    \    ^~~~~~~~~~\nSwift.String:5:16: note: 'characters' was obsoleted in Swift\
    \ 5.0\n    public var characters: String { get set }\n               ^\n"
  stdout: ''
  timestamp: 1659978481
- exit_code: 0
  program: "\n/// Input are two strings a and b consisting only of 1s and 0s.\n///\
    \ Perform binary XOR on these inputs and return result also as a string.\n///\
    \ >>> string_xor(a: \"010\", b: \"110\")\n/// \"100\"\nfunc string_xor(a: String,\
    \ b: String) -> String {\n    let x = zip(a, b).map{String(Int(String($0.0))!\
    \ ^ Int(String($0.1))!)}\n    return x.joined()\n}\n\n\nfunc ==(left: [(Int, Int)],\
    \ right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n       \
    \ return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r\
    \ {\n            return false\n        }\n    }\n    return true\n}\n        \
    \    \nassert(string_xor(a: \"111000\", b: \"101010\") == \"010010\")\nassert(string_xor(a:\
    \ \"1\", b: \"1\") == \"0\")\nassert(string_xor(a: \"0101\", b: \"0000\") == \"\
    0101\")"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659978481
- exit_code: 1
  program: "\n/// Input are two strings a and b consisting only of 1s and 0s.\n///\
    \ Perform binary XOR on these inputs and return result also as a string.\n///\
    \ >>> string_xor(a: \"010\", b: \"110\")\n/// \"100\"\nfunc string_xor(a: String,\
    \ b: String) -> String {\n    return xor(a.data(using: .utf8)!, b.data(using:\
    \ .utf8)!).toHex()\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) ->\
    \ Bool {\n    if left.count != right.count {\n        return false\n    }\n  \
    \  for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(string_xor(a: \"111000\"\
    , b: \"101010\") == \"010010\")\nassert(string_xor(a: \"1\", b: \"1\") == \"0\"\
    )\nassert(string_xor(a: \"0101\", b: \"0000\") == \"0101\")"
  status: SyntaxError
  stderr: "/tmp/tmpa8u27zuo.swift:7:12: error: cannot find 'xor' in scope\n    return\
    \ xor(a.data(using: .utf8)!, b.data(using: .utf8)!).toHex()\n           ^~~\n\
    /tmp/tmpa8u27zuo.swift:7:18: error: value of type 'String' has no member 'data'\n\
    \    return xor(a.data(using: .utf8)!, b.data(using: .utf8)!).toHex()\n      \
    \         ~ ^~~~\n/tmp/tmpa8u27zuo.swift:7:31: error: cannot infer contextual\
    \ base in reference to member 'utf8'\n    return xor(a.data(using: .utf8)!, b.data(using:\
    \ .utf8)!).toHex()\n                             ~^~~~\n/tmp/tmpa8u27zuo.swift:7:41:\
    \ error: value of type 'String' has no member 'data'\n    return xor(a.data(using:\
    \ .utf8)!, b.data(using: .utf8)!).toHex()\n                                  \
    \    ~ ^~~~\n/tmp/tmpa8u27zuo.swift:7:54: error: cannot infer contextual base\
    \ in reference to member 'utf8'\n    return xor(a.data(using: .utf8)!, b.data(using:\
    \ .utf8)!).toHex()\n                                                    ~^~~~\n"
  stdout: ''
  timestamp: 1659978481
- exit_code: 0
  program: "\n/// Input are two strings a and b consisting only of 1s and 0s.\n///\
    \ Perform binary XOR on these inputs and return result also as a string.\n///\
    \ >>> string_xor(a: \"010\", b: \"110\")\n/// \"100\"\nfunc string_xor(a: String,\
    \ b: String) -> String {\n    return String(\n        zip(a, b).map {\n      \
    \      if $0.0 == $0.1 {\n                return \"0\"\n            } else {\n\
    \                return \"1\"\n            }\n        }\n    )\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(string_xor(a: \"111000\", b: \"101010\") == \"010010\"\
    )\nassert(string_xor(a: \"1\", b: \"1\") == \"0\")\nassert(string_xor(a: \"0101\"\
    , b: \"0000\") == \"0101\")"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659978481
- exit_code: 1
  program: "\n/// Input are two strings a and b consisting only of 1s and 0s.\n///\
    \ Perform binary XOR on these inputs and return result also as a string.\n///\
    \ >>> string_xor(a: \"010\", b: \"110\")\n/// \"100\"\nfunc string_xor(a: String,\
    \ b: String) -> String {\n    var xored: String = \"\"\n    for i in 0..<a.count\
    \ {\n        xored.append(a[i] == b[i] ? \"0\" : \"1\")\n    }\n    return xored\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(string_xor(a: \"111000\", b: \"101010\") == \"\
    010010\")\nassert(string_xor(a: \"1\", b: \"1\") == \"0\")\nassert(string_xor(a:\
    \ \"0101\", b: \"0000\") == \"0101\")"
  status: SyntaxError
  stderr: "/tmp/tmpo90pc8lg.swift:9:22: error: 'subscript(_:)' is unavailable: cannot\
    \ subscript String with an Int, use a String.Index instead.\n        xored.append(a[i]\
    \ == b[i] ? \"0\" : \"1\")\n                     ^~~~\nSwift.String:3:12: note:\
    \ 'subscript(_:)' has been explicitly marked unavailable here\n    public subscript(i:\
    \ Int) -> Character { get }\n           ^\n/tmp/tmpo90pc8lg.swift:9:30: error:\
    \ 'subscript(_:)' is unavailable: cannot subscript String with an Int, use a String.Index\
    \ instead.\n        xored.append(a[i] == b[i] ? \"0\" : \"1\")\n             \
    \                ^~~~\nSwift.String:3:12: note: 'subscript(_:)' has been explicitly\
    \ marked unavailable here\n    public subscript(i: Int) -> Character { get }\n\
    \           ^\n"
  stdout: ''
  timestamp: 1659978481
- exit_code: 1
  program: "\n/// Input are two strings a and b consisting only of 1s and 0s.\n///\
    \ Perform binary XOR on these inputs and return result also as a string.\n///\
    \ >>> string_xor(a: \"010\", b: \"110\")\n/// \"100\"\nfunc string_xor(a: String,\
    \ b: String) -> String {\n    let aa = [UInt8](a.utf8)\n    let bb = [UInt8](b.utf8)\n\
    \    let zip = zip(aa, bb)\n    let xored = zip.map { $0 ^ $1 }\n    let result\
    \ = String(bytes: xored, encoding: .utf8)!\n    return result\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(string_xor(a: \"111000\", b: \"101010\") == \"010010\"\
    )\nassert(string_xor(a: \"1\", b: \"1\") == \"0\")\nassert(string_xor(a: \"0101\"\
    , b: \"0000\") == \"0101\")"
  status: SyntaxError
  stderr: "/tmp/tmpf9m1umjy.swift:11:18: error: no exact matches in call to initializer\
    \ \n    let result = String(bytes: xored, encoding: .utf8)!\n                \
    \ ^\n/tmp/tmpf9m1umjy.swift:11:18: note: found candidate with type '(Array<_>,\
    \ _.Type) -> String'\n    let result = String(bytes: xored, encoding: .utf8)!\n\
    \                 ^\n/tmp/tmpf9m1umjy.swift:11:18: note: found candidate with\
    \ type '([UInt8]) -> String'\n    let result = String(bytes: xored, encoding:\
    \ .utf8)!\n                 ^\n/tmp/tmpf9m1umjy.swift:11:18: note: found candidate\
    \ with type '(Substring.UTF8View) -> String?'\n    let result = String(bytes:\
    \ xored, encoding: .utf8)!\n                 ^\n/tmp/tmpf9m1umjy.swift:11:18:\
    \ note: found candidate with type '(Substring.UTF16View) -> String?'\n    let\
    \ result = String(bytes: xored, encoding: .utf8)!\n                 ^\n"
  stdout: ''
  timestamp: 1659978481
- exit_code: 1
  program: "\n/// Input are two strings a and b consisting only of 1s and 0s.\n///\
    \ Perform binary XOR on these inputs and return result also as a string.\n///\
    \ >>> string_xor(a: \"010\", b: \"110\")\n/// \"100\"\nfunc string_xor(a: String,\
    \ b: String) -> String {\n    let aa = parse_string_as_int_array(a)\n    let bb\
    \ = parse_string_as_int_array(b)\n    var result: [Int] = []\n    for i in 0..<aa.count\
    \ {\n        result.append(aa[i] ^ bb[i])\n    }\n    return format_int_array_as_string(result)\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(string_xor(a: \"111000\", b: \"101010\") == \"\
    010010\")\nassert(string_xor(a: \"1\", b: \"1\") == \"0\")\nassert(string_xor(a:\
    \ \"0101\", b: \"0000\") == \"0101\")"
  status: SyntaxError
  stderr: "/tmp/tmpyr4lajwl.swift:7:14: error: cannot find 'parse_string_as_int_array'\
    \ in scope\n    let aa = parse_string_as_int_array(a)\n             ^~~~~~~~~~~~~~~~~~~~~~~~~\n\
    /tmp/tmpyr4lajwl.swift:8:14: error: cannot find 'parse_string_as_int_array' in\
    \ scope\n    let bb = parse_string_as_int_array(b)\n             ^~~~~~~~~~~~~~~~~~~~~~~~~\n\
    /tmp/tmpyr4lajwl.swift:13:12: error: cannot find 'format_int_array_as_string'\
    \ in scope\n    return format_int_array_as_string(result)\n           ^~~~~~~~~~~~~~~~~~~~~~~~~~\n"
  stdout: ''
  timestamp: 1659978481
- exit_code: 1
  program: "\n/// Input are two strings a and b consisting only of 1s and 0s.\n///\
    \ Perform binary XOR on these inputs and return result also as a string.\n///\
    \ >>> string_xor(a: \"010\", b: \"110\")\n/// \"100\"\nfunc string_xor(a: String,\
    \ b: String) -> String {\n    let length = min(a.characters.count, b.characters.count)\n\
    \    var result = \"\"\n    for i in 0..<length {\n        let a = a[a.startIndex.advancedBy(i)]\n\
    \        let b = b[b.startIndex.advancedBy(i)]\n        result.append(String(Int(String(a))!\
    \ ^ Int(String(b))!))\n    }\n    return result\n}\n\n\nfunc ==(left: [(Int, Int)],\
    \ right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n       \
    \ return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r\
    \ {\n            return false\n        }\n    }\n    return true\n}\n        \
    \    \nassert(string_xor(a: \"111000\", b: \"101010\") == \"010010\")\nassert(string_xor(a:\
    \ \"1\", b: \"1\") == \"0\")\nassert(string_xor(a: \"0101\", b: \"0000\") == \"\
    0101\")"
  status: SyntaxError
  stderr: "/tmp/tmpw1ycrts_.swift:7:24: error: 'characters' is unavailable: Please\
    \ use String directly\n    let length = min(a.characters.count, b.characters.count)\n\
    \                       ^~~~~~~~~~\nSwift.String:5:16: note: 'characters' was\
    \ obsoleted in Swift 5.0\n    public var characters: String { get set }\n    \
    \           ^\n/tmp/tmpw1ycrts_.swift:7:44: error: 'characters' is unavailable:\
    \ Please use String directly\n    let length = min(a.characters.count, b.characters.count)\n\
    \                                           ^~~~~~~~~~\nSwift.String:5:16: note:\
    \ 'characters' was obsoleted in Swift 5.0\n    public var characters: String {\
    \ get set }\n               ^\n/tmp/tmpw1ycrts_.swift:10:32: error: value of type\
    \ 'String.Index' has no member 'advancedBy'\n        let a = a[a.startIndex.advancedBy(i)]\n\
    \                  ~~~~~~~~~~~~ ^~~~~~~~~~\n/tmp/tmpw1ycrts_.swift:11:32: error:\
    \ value of type 'String.Index' has no member 'advancedBy'\n        let b = b[b.startIndex.advancedBy(i)]\n\
    \                  ~~~~~~~~~~~~ ^~~~~~~~~~\n"
  stdout: ''
  timestamp: 1659978481
- exit_code: 0
  program: "\n/// Input are two strings a and b consisting only of 1s and 0s.\n///\
    \ Perform binary XOR on these inputs and return result also as a string.\n///\
    \ >>> string_xor(a: \"010\", b: \"110\")\n/// \"100\"\nfunc string_xor(a: String,\
    \ b: String) -> String {\n    let count_a = a.count\n    let count_b = b.count\n\
    \    var a_array = [Character]()\n    var b_array = [Character]()\n    var xor_array\
    \ = [Character]()\n    for i in 0..<count_a {\n        a_array.append(a[a.index(a.startIndex,\
    \ offsetBy: i)])\n    }\n    for i in 0..<count_b {\n        b_array.append(b[b.index(b.startIndex,\
    \ offsetBy: i)])\n    }\n    for i in 0..<count_a {\n        if (a_array[i] ==\
    \ \"0\" && b_array[i] == \"0\") || (a_array[i] == \"1\" && b_array[i] == \"1\"\
    ) {\n            xor_array.append(\"0\")\n        } else {\n            xor_array.append(\"\
    1\")\n        }\n    }\n    return String(xor_array)\n}\n\n\nfunc ==(left: [(Int,\
    \ Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n\
    \        return false\n    }\n    for (l, r) in zip(left, right) {\n        if\
    \ l != r {\n            return false\n        }\n    }\n    return true\n}\n \
    \           \nassert(string_xor(a: \"111000\", b: \"101010\") == \"010010\")\n\
    assert(string_xor(a: \"1\", b: \"1\") == \"0\")\nassert(string_xor(a: \"0101\"\
    , b: \"0000\") == \"0101\")"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659978481
- exit_code: 1
  program: "\n/// Input are two strings a and b consisting only of 1s and 0s.\n///\
    \ Perform binary XOR on these inputs and return result also as a string.\n///\
    \ >>> string_xor(a: \"010\", b: \"110\")\n/// \"100\"\nfunc string_xor(a: String,\
    \ b: String) -> String {\n    let aVal = getStringValue(string: a)\n    let bVal\
    \ = getStringValue(string: b)\n    let result = aVal ^ bVal\n    return convertToBinaryString(val:\
    \ result)\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n\
    \    if left.count != right.count {\n        return false\n    }\n    for (l,\
    \ r) in zip(left, right) {\n        if l != r {\n            return false\n  \
    \      }\n    }\n    return true\n}\n            \nassert(string_xor(a: \"111000\"\
    , b: \"101010\") == \"010010\")\nassert(string_xor(a: \"1\", b: \"1\") == \"0\"\
    )\nassert(string_xor(a: \"0101\", b: \"0000\") == \"0101\")"
  status: SyntaxError
  stderr: "/tmp/tmpc99u8rsh.swift:7:16: error: cannot find 'getStringValue' in scope\n\
    \    let aVal = getStringValue(string: a)\n               ^~~~~~~~~~~~~~\n/tmp/tmpc99u8rsh.swift:8:16:\
    \ error: cannot find 'getStringValue' in scope\n    let bVal = getStringValue(string:\
    \ b)\n               ^~~~~~~~~~~~~~\n/tmp/tmpc99u8rsh.swift:10:12: error: cannot\
    \ find 'convertToBinaryString' in scope\n    return convertToBinaryString(val:\
    \ result)\n           ^~~~~~~~~~~~~~~~~~~~~\n"
  stdout: ''
  timestamp: 1659978481
- exit_code: 1
  program: "\n/// Input are two strings a and b consisting only of 1s and 0s.\n///\
    \ Perform binary XOR on these inputs and return result also as a string.\n///\
    \ >>> string_xor(a: \"010\", b: \"110\")\n/// \"100\"\nfunc string_xor(a: String,\
    \ b: String) -> String {\n    return String(zip(a, b).map { String(($0 ^ $1).toUInt8())\
    \ }.joined())\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool\
    \ {\n    if left.count != right.count {\n        return false\n    }\n    for\
    \ (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(string_xor(a: \"111000\"\
    , b: \"101010\") == \"010010\")\nassert(string_xor(a: \"1\", b: \"1\") == \"0\"\
    )\nassert(string_xor(a: \"0101\", b: \"0000\") == \"0101\")"
  status: SyntaxError
  stderr: "/tmp/tmpy7nshx5t.swift:7:46: error: binary operator '^' cannot be applied\
    \ to two 'String.Element' (aka 'Character') operands\n    return String(zip(a,\
    \ b).map { String(($0 ^ $1).toUInt8()) }.joined())\n                         \
    \                 ~~ ^ ~~\n/tmp/tmpy7nshx5t.swift:7:52: error: value of type 'String.Element'\
    \ (aka 'Character') has no member 'toUInt8'\n    return String(zip(a, b).map {\
    \ String(($0 ^ $1).toUInt8()) }.joined())\n                                  \
    \       ~~~~~~~~~ ^~~~~~~\n"
  stdout: ''
  timestamp: 1659978495
- exit_code: 0
  program: "\n/// Input are two strings a and b consisting only of 1s and 0s.\n///\
    \ Perform binary XOR on these inputs and return result also as a string.\n///\
    \ >>> string_xor(a: \"010\", b: \"110\")\n/// \"100\"\nfunc string_xor(a: String,\
    \ b: String) -> String {\n    var result = \"\"\n    for i in 0..<a.count {\n\
    \        let aChar = a[a.index(a.startIndex, offsetBy: i)]\n        let bChar\
    \ = b[b.index(b.startIndex, offsetBy: i)]\n        if aChar == bChar {\n     \
    \       result += \"0\"\n        } else {\n            result += \"1\"\n     \
    \   }\n    }\n    return result\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int,\
    \ Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n\
    \    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n          \
    \  return false\n        }\n    }\n    return true\n}\n            \nassert(string_xor(a:\
    \ \"111000\", b: \"101010\") == \"010010\")\nassert(string_xor(a: \"1\", b: \"\
    1\") == \"0\")\nassert(string_xor(a: \"0101\", b: \"0000\") == \"0101\")"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659978481
- exit_code: 1
  program: "\n/// Input are two strings a and b consisting only of 1s and 0s.\n///\
    \ Perform binary XOR on these inputs and return result also as a string.\n///\
    \ >>> string_xor(a: \"010\", b: \"110\")\n/// \"100\"\nfunc string_xor(a: String,\
    \ b: String) -> String {\n\tvar xors = [String]()\n\tfor i in 0..<a.characters.count\
    \ {\n\t\tlet x = a[i]\n\t\tlet y = b[i]\n\t\tlet xor = String(Int(String(x))!\
    \ ^ Int(String(y))!)\n\t\txors.append(xor)\n\t}\n\treturn xors.joined()\n}\n\n\
    \nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(string_xor(a: \"111000\", b: \"101010\") == \"\
    010010\")\nassert(string_xor(a: \"1\", b: \"1\") == \"0\")\nassert(string_xor(a:\
    \ \"0101\", b: \"0000\") == \"0101\")"
  status: SyntaxError
  stderr: "/tmp/tmpt_9iyq_q.swift:8:17: error: 'characters' is unavailable: Please\
    \ use String directly\n        for i in 0..<a.characters.count {\n           \
    \            ^~~~~~~~~~\nSwift.String:5:16: note: 'characters' was obsoleted in\
    \ Swift 5.0\n    public var characters: String { get set }\n               ^\n\
    /tmp/tmpt_9iyq_q.swift:9:11: error: 'subscript(_:)' is unavailable: cannot subscript\
    \ String with an Int, use a String.Index instead.\n                let x = a[i]\n\
    \                        ^~~~\nSwift.String:3:12: note: 'subscript(_:)' has been\
    \ explicitly marked unavailable here\n    public subscript(i: Int) -> Character\
    \ { get }\n           ^\n/tmp/tmpt_9iyq_q.swift:10:11: error: 'subscript(_:)'\
    \ is unavailable: cannot subscript String with an Int, use a String.Index instead.\n\
    \                let y = b[i]\n                        ^~~~\nSwift.String:3:12:\
    \ note: 'subscript(_:)' has been explicitly marked unavailable here\n    public\
    \ subscript(i: Int) -> Character { get }\n           ^\n"
  stdout: ''
  timestamp: 1659978481
- exit_code: 1
  program: "\n/// Input are two strings a and b consisting only of 1s and 0s.\n///\
    \ Perform binary XOR on these inputs and return result also as a string.\n///\
    \ >>> string_xor(a: \"010\", b: \"110\")\n/// \"100\"\nfunc string_xor(a: String,\
    \ b: String) -> String {\n    // Initialize output variable\n    var output =\
    \ \"\"\n    \n    // Loop through each element in both strings\n    for i in 0..<a.count\
    \ {\n        // Get the i-th element of a\n        let a_element = a[i]\n    \
    \    \n        // Get the i-th element of b\n        let b_element = b[i]\n  \
    \      \n        // XOR operation on two integers\n        let xored = a_element\
    \ ^ b_element\n        \n        // Append to the output\n        output.append(String(xored))\n\
    \    }\n    \n    // Return output\n    return output\n}\n\n\nfunc ==(left: [(Int,\
    \ Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n\
    \        return false\n    }\n    for (l, r) in zip(left, right) {\n        if\
    \ l != r {\n            return false\n        }\n    }\n    return true\n}\n \
    \           \nassert(string_xor(a: \"111000\", b: \"101010\") == \"010010\")\n\
    assert(string_xor(a: \"1\", b: \"1\") == \"0\")\nassert(string_xor(a: \"0101\"\
    , b: \"0000\") == \"0101\")"
  status: SyntaxError
  stderr: "/tmp/tmpbkkuxl69.swift:13:25: error: 'subscript(_:)' is unavailable: cannot\
    \ subscript String with an Int, use a String.Index instead.\n        let a_element\
    \ = a[i]\n                        ^~~~\nSwift.String:3:12: note: 'subscript(_:)'\
    \ has been explicitly marked unavailable here\n    public subscript(i: Int) ->\
    \ Character { get }\n           ^\n/tmp/tmpbkkuxl69.swift:16:25: error: 'subscript(_:)'\
    \ is unavailable: cannot subscript String with an Int, use a String.Index instead.\n\
    \        let b_element = b[i]\n                        ^~~~\nSwift.String:3:12:\
    \ note: 'subscript(_:)' has been explicitly marked unavailable here\n    public\
    \ subscript(i: Int) -> Character { get }\n           ^\n/tmp/tmpbkkuxl69.swift:19:31:\
    \ error: binary operator '^' cannot be applied to two 'Character' operands\n \
    \       let xored = a_element ^ b_element\n                    ~~~~~~~~~ ^ ~~~~~~~~~\n"
  stdout: ''
  timestamp: 1659978481
- exit_code: 1
  program: "\n/// Input are two strings a and b consisting only of 1s and 0s.\n///\
    \ Perform binary XOR on these inputs and return result also as a string.\n///\
    \ >>> string_xor(a: \"010\", b: \"110\")\n/// \"100\"\nfunc string_xor(a: String,\
    \ b: String) -> String {\n    var s = \"\"\n    var i = 0\n    for c in a.characters\
    \ {\n        if a[i] == b[i] {\n            s += \"0\"\n        } else {\n   \
    \         s += \"1\"\n        }\n        i += 1\n    }\n    return s\n}\n\n\n\
    func ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(string_xor(a: \"111000\", b: \"101010\") == \"\
    010010\")\nassert(string_xor(a: \"1\", b: \"1\") == \"0\")\nassert(string_xor(a:\
    \ \"0101\", b: \"0000\") == \"0101\")"
  status: SyntaxError
  stderr: "/tmp/tmpvl2gxazv.swift:9:16: error: 'characters' is unavailable: Please\
    \ use String directly\n    for c in a.characters {\n               ^~~~~~~~~~\n\
    Swift.String:5:16: note: 'characters' was obsoleted in Swift 5.0\n    public var\
    \ characters: String { get set }\n               ^\n/tmp/tmpvl2gxazv.swift:10:12:\
    \ error: 'subscript(_:)' is unavailable: cannot subscript String with an Int,\
    \ use a String.Index instead.\n        if a[i] == b[i] {\n           ^~~~\nSwift.String:3:12:\
    \ note: 'subscript(_:)' has been explicitly marked unavailable here\n    public\
    \ subscript(i: Int) -> Character { get }\n           ^\n/tmp/tmpvl2gxazv.swift:10:20:\
    \ error: 'subscript(_:)' is unavailable: cannot subscript String with an Int,\
    \ use a String.Index instead.\n        if a[i] == b[i] {\n                   ^~~~\n\
    Swift.String:3:12: note: 'subscript(_:)' has been explicitly marked unavailable\
    \ here\n    public subscript(i: Int) -> Character { get }\n           ^\n/tmp/tmpvl2gxazv.swift:9:9:\
    \ warning: immutable value 'c' was never used; consider replacing with '_' or\
    \ removing it\n    for c in a.characters {\n        ^\n        _\n"
  stdout: ''
  timestamp: 1659978481
- exit_code: 1
  program: "\n/// Input are two strings a and b consisting only of 1s and 0s.\n///\
    \ Perform binary XOR on these inputs and return result also as a string.\n///\
    \ >>> string_xor(a: \"010\", b: \"110\")\n/// \"100\"\nfunc string_xor(a: String,\
    \ b: String) -> String {\n    let aBinary = Array(a.utf8)\n    let bBinary = Array(b.utf8)\n\
    \    var resultBinary = [UInt8]()\n    for i in 0..<aBinary.count {\n        if\
    \ aBinary[i] == bBinary[i] {\n            resultBinary.append(0)\n        } else\
    \ {\n            resultBinary.append(1)\n        }\n    }\n    return String(bytes:\
    \ resultBinary, encoding: .utf8)!\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int,\
    \ Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n\
    \    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n          \
    \  return false\n        }\n    }\n    return true\n}\n            \nassert(string_xor(a:\
    \ \"111000\", b: \"101010\") == \"010010\")\nassert(string_xor(a: \"1\", b: \"\
    1\") == \"0\")\nassert(string_xor(a: \"0101\", b: \"0000\") == \"0101\")"
  status: SyntaxError
  stderr: "/tmp/tmpqlq5o35m.swift:17:12: error: no exact matches in call to initializer\
    \ \n    return String(bytes: resultBinary, encoding: .utf8)!\n           ^\n/tmp/tmpqlq5o35m.swift:17:12:\
    \ note: found candidate with type '(Array<_>, _.Type) -> String'\n    return String(bytes:\
    \ resultBinary, encoding: .utf8)!\n           ^\n/tmp/tmpqlq5o35m.swift:17:12:\
    \ note: found candidate with type '([UInt8]) -> String'\n    return String(bytes:\
    \ resultBinary, encoding: .utf8)!\n           ^\n/tmp/tmpqlq5o35m.swift:17:12:\
    \ note: found candidate with type '(Substring.UTF8View) -> String?'\n    return\
    \ String(bytes: resultBinary, encoding: .utf8)!\n           ^\n/tmp/tmpqlq5o35m.swift:17:12:\
    \ note: found candidate with type '(Substring.UTF16View) -> String?'\n    return\
    \ String(bytes: resultBinary, encoding: .utf8)!\n           ^\n"
  stdout: ''
  timestamp: 1659978481
- exit_code: 1
  program: "\n/// Input are two strings a and b consisting only of 1s and 0s.\n///\
    \ Perform binary XOR on these inputs and return result also as a string.\n///\
    \ >>> string_xor(a: \"010\", b: \"110\")\n/// \"100\"\nfunc string_xor(a: String,\
    \ b: String) -> String {\n  let a_uint8 = Array(a.utf8)\n  let b_uint8 = Array(b.utf8)\n\
    \  let c_uint8 = zip(a_uint8, b_uint8).map { $0 ^ $1 }\n  let c = String(bytes:\
    \ c_uint8, encoding: .utf8)!\n  return c\n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(string_xor(a: \"111000\", b: \"101010\") == \"010010\")\nassert(string_xor(a:\
    \ \"1\", b: \"1\") == \"0\")\nassert(string_xor(a: \"0101\", b: \"0000\") == \"\
    0101\")"
  status: SyntaxError
  stderr: "/tmp/tmph8i2fvq3.swift:10:11: error: no exact matches in call to initializer\
    \ \n  let c = String(bytes: c_uint8, encoding: .utf8)!\n          ^\n/tmp/tmph8i2fvq3.swift:10:11:\
    \ note: found candidate with type '(Array<_>, _.Type) -> String'\n  let c = String(bytes:\
    \ c_uint8, encoding: .utf8)!\n          ^\n/tmp/tmph8i2fvq3.swift:10:11: note:\
    \ found candidate with type '([UInt8]) -> String'\n  let c = String(bytes: c_uint8,\
    \ encoding: .utf8)!\n          ^\n/tmp/tmph8i2fvq3.swift:10:11: note: found candidate\
    \ with type '(Substring.UTF8View) -> String?'\n  let c = String(bytes: c_uint8,\
    \ encoding: .utf8)!\n          ^\n/tmp/tmph8i2fvq3.swift:10:11: note: found candidate\
    \ with type '(Substring.UTF16View) -> String?'\n  let c = String(bytes: c_uint8,\
    \ encoding: .utf8)!\n          ^\n"
  stdout: ''
  timestamp: 1659978481
- exit_code: 1
  program: "\n/// Input are two strings a and b consisting only of 1s and 0s.\n///\
    \ Perform binary XOR on these inputs and return result also as a string.\n///\
    \ >>> string_xor(a: \"010\", b: \"110\")\n/// \"100\"\nfunc string_xor(a: String,\
    \ b: String) -> String {\n    let buffer = NSMutableString(capacity: a.count)\n\
    \    for (l, r) in zip(a, b) {\n        buffer.append(l == r ? \"0\" : \"1\")\n\
    \    }\n    return buffer as String\n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(string_xor(a: \"111000\", b: \"101010\") == \"010010\")\nassert(string_xor(a:\
    \ \"1\", b: \"1\") == \"0\")\nassert(string_xor(a: \"0101\", b: \"0000\") == \"\
    0101\")"
  status: SyntaxError
  stderr: "/tmp/tmpo2m78kly.swift:7:18: error: cannot find 'NSMutableString' in scope\n\
    \    let buffer = NSMutableString(capacity: a.count)\n                 ^~~~~~~~~~~~~~~\n"
  stdout: ''
  timestamp: 1659978481
- exit_code: 1
  program: "\n/// Input are two strings a and b consisting only of 1s and 0s.\n///\
    \ Perform binary XOR on these inputs and return result also as a string.\n///\
    \ >>> string_xor(a: \"010\", b: \"110\")\n/// \"100\"\nfunc string_xor(a: String,\
    \ b: String) -> String {\n    let a_length = a.characters.count\n    let b_length\
    \ = b.characters.count\n    var c = \"\"\n    var j = 0\n    var k = 0\n    if\
    \ (a_length > b_length) {\n        j = a_length\n        k = b_length\n    } else\
    \ {\n        j = b_length\n        k = a_length\n    }\n    for i in 0..<j {\n\
    \        if (i < k) {\n            if (a[i] == b[i]) {\n                c += \"\
    0\"\n            } else {\n                c += \"1\"\n            }\n       \
    \ } else {\n            if (a_length > b_length) {\n                c += a[i]\n\
    \            } else {\n                c += b[i]\n            }\n        }\n \
    \   }\n    return c\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) ->\
    \ Bool {\n    if left.count != right.count {\n        return false\n    }\n  \
    \  for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(string_xor(a: \"111000\"\
    , b: \"101010\") == \"010010\")\nassert(string_xor(a: \"1\", b: \"1\") == \"0\"\
    )\nassert(string_xor(a: \"0101\", b: \"0000\") == \"0101\")"
  status: SyntaxError
  stderr: "/tmp/tmpfe61llaq.swift:7:22: error: 'characters' is unavailable: Please\
    \ use String directly\n    let a_length = a.characters.count\n               \
    \      ^~~~~~~~~~\nSwift.String:5:16: note: 'characters' was obsoleted in Swift\
    \ 5.0\n    public var characters: String { get set }\n               ^\n/tmp/tmpfe61llaq.swift:8:22:\
    \ error: 'characters' is unavailable: Please use String directly\n    let b_length\
    \ = b.characters.count\n                     ^~~~~~~~~~\nSwift.String:5:16: note:\
    \ 'characters' was obsoleted in Swift 5.0\n    public var characters: String {\
    \ get set }\n               ^\n/tmp/tmpfe61llaq.swift:21:17: error: 'subscript(_:)'\
    \ is unavailable: cannot subscript String with an Int, use a String.Index instead.\n\
    \            if (a[i] == b[i]) {\n                ^~~~\nSwift.String:3:12: note:\
    \ 'subscript(_:)' has been explicitly marked unavailable here\n    public subscript(i:\
    \ Int) -> Character { get }\n           ^\n/tmp/tmpfe61llaq.swift:21:25: error:\
    \ 'subscript(_:)' is unavailable: cannot subscript String with an Int, use a String.Index\
    \ instead.\n            if (a[i] == b[i]) {\n                        ^~~~\nSwift.String:3:12:\
    \ note: 'subscript(_:)' has been explicitly marked unavailable here\n    public\
    \ subscript(i: Int) -> Character { get }\n           ^\n/tmp/tmpfe61llaq.swift:28:23:\
    \ error: no exact matches in call to subscript \n                c += a[i]\n \
    \                     ^\nSwift.String:3:12: note: candidate expects value of type\
    \ 'Range<String.Index>' for parameter #1 (got 'Int')\n    public subscript(r:\
    \ Range<String.Index>) -> Substring { get }\n           ^\nSwift.Collection:3:23:\
    \ note: candidate expects value of type '(UnboundedRange_) -> ()' for parameter\
    \ #1 (got 'Int')\n    @inlinable public subscript(x: (UnboundedRange_) -> ())\
    \ -> Self.SubSequence { get }\n                      ^\n/tmp/tmpfe61llaq.swift:30:23:\
    \ error: no exact matches in call to subscript \n                c += b[i]\n \
    \                     ^\nSwift.String:3:12: note: candidate expects value of type\
    \ 'Range<String.Index>' for parameter #1 (got 'Int')\n    public subs"
  stdout: ''
  timestamp: 1659978481
- exit_code: 1
  program: "\n/// Input are two strings a and b consisting only of 1s and 0s.\n///\
    \ Perform binary XOR on these inputs and return result also as a string.\n///\
    \ >>> string_xor(a: \"010\", b: \"110\")\n/// \"100\"\nfunc string_xor(a: String,\
    \ b: String) -> String {\n    var xored = \"\"\n    for (index, char) in a.characters.enumerated()\
    \ {\n        let c = String(char)\n        let b_c = String(b[b.index(b.startIndex,\
    \ offsetBy: index)])\n        if c == b_c {\n            xored.append(\"0\")\n\
    \        } else {\n            xored.append(\"1\")\n        }\n    }\n    return\
    \ xored\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n \
    \   if left.count != right.count {\n        return false\n    }\n    for (l, r)\
    \ in zip(left, right) {\n        if l != r {\n            return false\n     \
    \   }\n    }\n    return true\n}\n            \nassert(string_xor(a: \"111000\"\
    , b: \"101010\") == \"010010\")\nassert(string_xor(a: \"1\", b: \"1\") == \"0\"\
    )\nassert(string_xor(a: \"0101\", b: \"0000\") == \"0101\")"
  status: SyntaxError
  stderr: "/tmp/tmpdu39avjx.swift:8:28: error: 'characters' is unavailable: Please\
    \ use String directly\n    for (index, char) in a.characters.enumerated() {\n\
    \                           ^~~~~~~~~~\nSwift.String:5:16: note: 'characters'\
    \ was obsoleted in Swift 5.0\n    public var characters: String { get set }\n\
    \               ^\n"
  stdout: ''
  timestamp: 1659978481
- exit_code: 1
  program: "\n/// Input are two strings a and b consisting only of 1s and 0s.\n///\
    \ Perform binary XOR on these inputs and return result also as a string.\n///\
    \ >>> string_xor(a: \"010\", b: \"110\")\n/// \"100\"\nfunc string_xor(a: String,\
    \ b: String) -> String {\n    let a = a.utf8.map{UInt8($0)}\n    let b = b.utf8.map{UInt8($0)}\n\
    \    let c = zip(a, b).map{Int($0) ^ Int($1)}\n    return String(c.map{Character(UnicodeScalar($0))})\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(string_xor(a: \"111000\", b: \"101010\") == \"\
    010010\")\nassert(string_xor(a: \"1\", b: \"1\") == \"0\")\nassert(string_xor(a:\
    \ \"0101\", b: \"0000\") == \"0101\")"
  status: SyntaxError
  stderr: "/tmp/tmpouioxaub.swift:10:35: error: value of optional type 'UnicodeScalar?'\
    \ (aka 'Optional<Unicode.Scalar>') must be unwrapped to a value of type 'UnicodeScalar'\
    \ (aka 'Unicode.Scalar')\n    return String(c.map{Character(UnicodeScalar($0))})\n\
    \                                  ^\n/tmp/tmpouioxaub.swift:10:35: note: coalesce\
    \ using '??' to provide a default when the optional value contains 'nil'\n   \
    \ return String(c.map{Character(UnicodeScalar($0))})\n                       \
    \           ^\n                                                    ?? <#default\
    \ value#>\n/tmp/tmpouioxaub.swift:10:35: note: force-unwrap using '!' to abort\
    \ execution if the optional value contains 'nil'\n    return String(c.map{Character(UnicodeScalar($0))})\n\
    \                                  ^\n                                       \
    \            !\n"
  stdout: ''
  timestamp: 1659978481
- exit_code: 0
  program: "\n/// Input are two strings a and b consisting only of 1s and 0s.\n///\
    \ Perform binary XOR on these inputs and return result also as a string.\n///\
    \ >>> string_xor(a: \"010\", b: \"110\")\n/// \"100\"\nfunc string_xor(a: String,\
    \ b: String) -> String {\n    let inputA = a.utf8.map { Int($0) - 48 }\n    let\
    \ inputB = b.utf8.map { Int($0) - 48 }\n    let str = zip(inputA, inputB).map\
    \ { $0 ^ $1 }.map { String($0) }.joined()\n    return str\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(string_xor(a: \"111000\", b: \"101010\") == \"010010\"\
    )\nassert(string_xor(a: \"1\", b: \"1\") == \"0\")\nassert(string_xor(a: \"0101\"\
    , b: \"0000\") == \"0101\")"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659978481
- exit_code: 1
  program: "\n/// Input are two strings a and b consisting only of 1s and 0s.\n///\
    \ Perform binary XOR on these inputs and return result also as a string.\n///\
    \ >>> string_xor(a: \"010\", b: \"110\")\n/// \"100\"\nfunc string_xor(a: String,\
    \ b: String) -> String {\n    // There is no XOR operator in Swift, but we can\
    \ use bitwise functions\n    var result = \"\"\n    // Loop over characters in\
    \ a\n    for (index, char) in a.characters.enumerated() {\n        // Get character\
    \ in b at same position\n        let charB = b[b.characters.index(b.startIndex,\
    \ offsetBy: index)]\n        // Convert to integers and XOR\n        result +=\
    \ String(Int(String(char))! ^ Int(String(charB))!)\n    }\n    return result\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(string_xor(a: \"111000\", b: \"101010\") == \"\
    010010\")\nassert(string_xor(a: \"1\", b: \"1\") == \"0\")\nassert(string_xor(a:\
    \ \"0101\", b: \"0000\") == \"0101\")"
  status: SyntaxError
  stderr: "/tmp/tmpvd5b7yaz.swift:10:28: error: 'characters' is unavailable: Please\
    \ use String directly\n    for (index, char) in a.characters.enumerated() {\n\
    \                           ^~~~~~~~~~\nSwift.String:5:16: note: 'characters'\
    \ was obsoleted in Swift 5.0\n    public var characters: String { get set }\n\
    \               ^\n/tmp/tmpvd5b7yaz.swift:12:25: error: 'characters' is unavailable:\
    \ Please use String directly\n        let charB = b[b.characters.index(b.startIndex,\
    \ offsetBy: index)]\n                        ^~~~~~~~~~\nSwift.String:5:16: note:\
    \ 'characters' was obsoleted in Swift 5.0\n    public var characters: String {\
    \ get set }\n               ^\n"
  stdout: ''
  timestamp: 1659978481
- exit_code: 1
  program: "\n/// Input are two strings a and b consisting only of 1s and 0s.\n///\
    \ Perform binary XOR on these inputs and return result also as a string.\n///\
    \ >>> string_xor(a: \"010\", b: \"110\")\n/// \"100\"\nfunc string_xor(a: String,\
    \ b: String) -> String {\n    var out = \"\"\n    for i in 0..<a.characters.count\
    \ {\n        let a1 = String(a[a.index(a.startIndex, offsetBy: i)])\n        let\
    \ b1 = String(b[b.index(b.startIndex, offsetBy: i)])\n        out += string_xor_char(a:\
    \ a1, b: b1)\n    }\n    return out\n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(string_xor(a: \"111000\", b: \"101010\") == \"010010\")\nassert(string_xor(a:\
    \ \"1\", b: \"1\") == \"0\")\nassert(string_xor(a: \"0101\", b: \"0000\") == \"\
    0101\")"
  status: SyntaxError
  stderr: "/tmp/tmpb0ulit19.swift:8:20: error: 'characters' is unavailable: Please\
    \ use String directly\n    for i in 0..<a.characters.count {\n               \
    \    ^~~~~~~~~~\nSwift.String:5:16: note: 'characters' was obsoleted in Swift\
    \ 5.0\n    public var characters: String { get set }\n               ^\n/tmp/tmpb0ulit19.swift:11:16:\
    \ error: cannot find 'string_xor_char' in scope\n        out += string_xor_char(a:\
    \ a1, b: b1)\n               ^~~~~~~~~~~~~~~\n"
  stdout: ''
  timestamp: 1659978481
- exit_code: 1
  program: "\n/// Input are two strings a and b consisting only of 1s and 0s.\n///\
    \ Perform binary XOR on these inputs and return result also as a string.\n///\
    \ >>> string_xor(a: \"010\", b: \"110\")\n/// \"100\"\nfunc string_xor(a: String,\
    \ b: String) -> String {\n\tvar result = \"\"\n\tfor i in 0..<a.characters.count\
    \ {\n\t\tlet a_char = a[a.startIndex.advancedBy(i)]\n\t\tlet b_char = b[b.startIndex.advancedBy(i)]\n\
    \t\tif a_char == b_char {\n\t\t\tresult.append(\"0\")\n\t\t} else {\n\t\t\tresult.append(\"\
    1\")\n\t\t}\n\t}\n\treturn result\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int,\
    \ Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n\
    \    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n          \
    \  return false\n        }\n    }\n    return true\n}\n            \nassert(string_xor(a:\
    \ \"111000\", b: \"101010\") == \"010010\")\nassert(string_xor(a: \"1\", b: \"\
    1\") == \"0\")\nassert(string_xor(a: \"0101\", b: \"0000\") == \"0101\")"
  status: SyntaxError
  stderr: "/tmp/tmprvu_z942.swift:8:17: error: 'characters' is unavailable: Please\
    \ use String directly\n        for i in 0..<a.characters.count {\n           \
    \            ^~~~~~~~~~\nSwift.String:5:16: note: 'characters' was obsoleted in\
    \ Swift 5.0\n    public var characters: String { get set }\n               ^\n\
    /tmp/tmprvu_z942.swift:9:31: error: value of type 'String.Index' has no member\
    \ 'advancedBy'\n                let a_char = a[a.startIndex.advancedBy(i)]\n \
    \                              ~~~~~~~~~~~~ ^~~~~~~~~~\n/tmp/tmprvu_z942.swift:10:31:\
    \ error: value of type 'String.Index' has no member 'advancedBy'\n           \
    \     let b_char = b[b.startIndex.advancedBy(i)]\n                           \
    \    ~~~~~~~~~~~~ ^~~~~~~~~~\n"
  stdout: ''
  timestamp: 1659978481
- exit_code: 1
  program: "\n/// Input are two strings a and b consisting only of 1s and 0s.\n///\
    \ Perform binary XOR on these inputs and return result also as a string.\n///\
    \ >>> string_xor(a: \"010\", b: \"110\")\n/// \"100\"\nfunc string_xor(a: String,\
    \ b: String) -> String {\n    var length = min(a.characters.count, b.characters.count)\n\
    \    let achars = a.characters.map { Int(String($0))! }\n    let bchars = b.characters.map\
    \ { Int(String($0))! }\n    var result: [Int] = []\n    for (idx, _) in achars.enumerated()\
    \ {\n        if idx < length {\n            result.append(achars[idx] ^ bchars[idx])\n\
    \        }\n    }\n    return result.map { String($0) }.joined()\n}\n\n\nfunc\
    \ ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count !=\
    \ right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(string_xor(a: \"111000\", b: \"101010\") == \"\
    010010\")\nassert(string_xor(a: \"1\", b: \"1\") == \"0\")\nassert(string_xor(a:\
    \ \"0101\", b: \"0000\") == \"0101\")"
  status: SyntaxError
  stderr: "/tmp/tmpk6uksp2g.swift:7:24: error: 'characters' is unavailable: Please\
    \ use String directly\n    var length = min(a.characters.count, b.characters.count)\n\
    \                       ^~~~~~~~~~\nSwift.String:5:16: note: 'characters' was\
    \ obsoleted in Swift 5.0\n    public var characters: String { get set }\n    \
    \           ^\n/tmp/tmpk6uksp2g.swift:7:44: error: 'characters' is unavailable:\
    \ Please use String directly\n    var length = min(a.characters.count, b.characters.count)\n\
    \                                           ^~~~~~~~~~\nSwift.String:5:16: note:\
    \ 'characters' was obsoleted in Swift 5.0\n    public var characters: String {\
    \ get set }\n               ^\n/tmp/tmpk6uksp2g.swift:8:20: error: 'characters'\
    \ is unavailable: Please use String directly\n    let achars = a.characters.map\
    \ { Int(String($0))! }\n                   ^~~~~~~~~~\nSwift.String:5:16: note:\
    \ 'characters' was obsoleted in Swift 5.0\n    public var characters: String {\
    \ get set }\n               ^\n/tmp/tmpk6uksp2g.swift:9:20: error: 'characters'\
    \ is unavailable: Please use String directly\n    let bchars = b.characters.map\
    \ { Int(String($0))! }\n                   ^~~~~~~~~~\nSwift.String:5:16: note:\
    \ 'characters' was obsoleted in Swift 5.0\n    public var characters: String {\
    \ get set }\n               ^\n/tmp/tmpk6uksp2g.swift:7:9: warning: variable 'length'\
    \ was never mutated; consider changing to 'let' constant\n    var length = min(a.characters.count,\
    \ b.characters.count)\n    ~~~ ^\n    let\n"
  stdout: ''
  timestamp: 1659978481
- exit_code: -4
  program: "\n/// Input are two strings a and b consisting only of 1s and 0s.\n///\
    \ Perform binary XOR on these inputs and return result also as a string.\n///\
    \ >>> string_xor(a: \"010\", b: \"110\")\n/// \"100\"\nfunc string_xor(a: String,\
    \ b: String) -> String {\n    return \"\"\n}\n\n\nfunc ==(left: [(Int, Int)],\
    \ right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n       \
    \ return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r\
    \ {\n            return false\n        }\n    }\n    return true\n}\n        \
    \    \nassert(string_xor(a: \"111000\", b: \"101010\") == \"010010\")\nassert(string_xor(a:\
    \ \"1\", b: \"1\") == \"0\")\nassert(string_xor(a: \"0101\", b: \"0000\") == \"\
    0101\")"
  status: Exception
  stderr: 'tmp1ma40nkp/tmp1ma40nkp.swift:23: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b0563602c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b05632f9b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b05632f9988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b05632f87b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmp1ma40nkp                        0x0000563c4899b33b <unavailable> + 4923

    5    libc.so.6                          0x00002b05637ee460 __libc_start_main +
    245

    6    tmp1ma40nkp                        0x0000563c4899af49 <unavailable> + 3913

    '
  stdout: ''
  timestamp: 1659978479
- exit_code: 1
  program: "\n/// Input are two strings a and b consisting only of 1s and 0s.\n///\
    \ Perform binary XOR on these inputs and return result also as a string.\n///\
    \ >>> string_xor(a: \"010\", b: \"110\")\n/// \"100\"\nfunc string_xor(a: String,\
    \ b: String) -> String {\n    var result = [UInt8]()\n    var aIter = a.makeIterator()\n\
    \    var bIter = b.makeIterator()\n    while let a = aIter.next(), let b = bIter.next()\
    \ {\n        result.append(UInt8(a) ^ UInt8(b))\n    }\n    return String(bytes:\
    \ result, encoding: .utf8)!\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int,\
    \ Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n\
    \    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n          \
    \  return false\n        }\n    }\n    return true\n}\n            \nassert(string_xor(a:\
    \ \"111000\", b: \"101010\") == \"010010\")\nassert(string_xor(a: \"1\", b: \"\
    1\") == \"0\")\nassert(string_xor(a: \"0101\", b: \"0000\") == \"0101\")"
  status: SyntaxError
  stderr: "/tmp/tmpv79nmnak.swift:11:34: error: no exact matches in call to initializer\
    \ \n        result.append(UInt8(a) ^ UInt8(b))\n                             \
    \    ^\n/tmp/tmpv79nmnak.swift:11:34: note: candidate expects value of type 'Float16'\
    \ for parameter #1 (got 'Character')\n        result.append(UInt8(a) ^ UInt8(b))\n\
    \                                 ^\n/tmp/tmpv79nmnak.swift:11:34: note: candidate\
    \ expects value of type 'Float' for parameter #1 (got 'Character')\n        result.append(UInt8(a)\
    \ ^ UInt8(b))\n                                 ^\n/tmp/tmpv79nmnak.swift:11:34:\
    \ note: candidate expects value of type 'Double' for parameter #1 (got 'Character')\n\
    \        result.append(UInt8(a) ^ UInt8(b))\n                                \
    \ ^\n/tmp/tmpv79nmnak.swift:11:34: note: candidate expects value of type 'Float80'\
    \ for parameter #1 (got 'Character')\n        result.append(UInt8(a) ^ UInt8(b))\n\
    \                                 ^\n/tmp/tmpv79nmnak.swift:11:34: note: candidate\
    \ expects value of type 'Builtin.Int8' for parameter #1 (got 'Character')\n  \
    \      result.append(UInt8(a) ^ UInt8(b))\n                                 ^\n\
    /tmp/tmpv79nmnak.swift:11:23: error: no exact matches in call to initializer \n\
    \        result.append(UInt8(a) ^ UInt8(b))\n                      ^\n/tmp/tmpv79nmnak.swift:11:23:\
    \ note: candidate expects value of type 'Float16' for parameter #1 (got 'Character')\n\
    \        result.append(UInt8(a) ^ UInt8(b))\n                      ^\n/tmp/tmpv79nmnak.swift:11:23:\
    \ note: candidate expects value of type 'Float' for parameter #1 (got 'Character')\n\
    \        result.append(UInt8(a) ^ UInt8(b))\n                      ^\n/tmp/tmpv79nmnak.swift:11:23:\
    \ note: candidate expects value of type 'Double' for parameter #1 (got 'Character')\n\
    \        result.append(UInt8(a) ^ UInt8(b))\n                      ^\n/tmp/tmpv79nmnak.swift:11:23:\
    \ note: candidate expects value of type 'Float80' for parameter #1 (got 'Character')\n\
    \        result.append(UInt8(a) ^ UInt8(b))\n                      ^\n/tmp/tmpv79nmnak.swift:11:23:\
    \ note: candidate expects value of type 'Buil"
  stdout: ''
  timestamp: 1659978481
- exit_code: 1
  program: "\n/// Input are two strings a and b consisting only of 1s and 0s.\n///\
    \ Perform binary XOR on these inputs and return result also as a string.\n///\
    \ >>> string_xor(a: \"010\", b: \"110\")\n/// \"100\"\nfunc string_xor(a: String,\
    \ b: String) -> String {\n    return String(a.utf8.lazy.map { $0 ^ b.utf8[a.utf8.startIndex]\
    \ })\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if\
    \ left.count != right.count {\n        return false\n    }\n    for (l, r) in\
    \ zip(left, right) {\n        if l != r {\n            return false\n        }\n\
    \    }\n    return true\n}\n            \nassert(string_xor(a: \"111000\", b:\
    \ \"101010\") == \"010010\")\nassert(string_xor(a: \"1\", b: \"1\") == \"0\")\n\
    assert(string_xor(a: \"0101\", b: \"0000\") == \"0101\")"
  status: SyntaxError
  stderr: "/tmp/tmp1xdqrxod.swift:7:12: error: no exact matches in call to initializer\
    \ \n    return String(a.utf8.lazy.map { $0 ^ b.utf8[a.utf8.startIndex] })\n  \
    \         ^\nSwift.String:4:12: note: candidate requires that the types 'UInt8'\
    \ and 'Character' be equivalent (requirement specified as 'S.Element' == 'Character')\n\
    \    public init<S>(_ characters: S) where S : Sequence, S.Element == Character\n\
    \           ^\nSwift.RangeReplaceableCollection:3:23: note: candidate requires\
    \ that the types 'String.Element' (aka 'Character') and 'UInt8' be equivalent\
    \ (requirement specified as 'Self.Element' == 'S.Element')\n    @inlinable public\
    \ init<S>(_ elements: S) where S : Sequence, Self.Element == S.Element\n     \
    \                 ^\nSwift.String:2:12: note: incorrect labels for candidate (have:\
    \ '(_:)', expected: '(describing:)')\n    public init<Subject>(describing instance:\
    \ Subject)\n           ^\nSwift.String:6:12: note: incorrect labels for candidate\
    \ (have: '(_:)', expected: '(reflecting:)')\n    public init<Subject>(reflecting\
    \ subject: Subject)\n           ^\nSwift.String:7:23: note: incorrect labels for\
    \ candidate (have: '(_:)', expected: '(cString:)')\n    @inlinable public init(cString\
    \ nullTerminatedUTF8: [UInt8])\n                      ^\nSwift.String:3:23: note:\
    \ incorrect labels for candidate (have: '(_:)', expected: '(describing:)')\n \
    \   @inlinable public init<Subject>(describing instance: Subject) where Subject\
    \ : CustomStringConvertible\n                      ^\n"
  stdout: ''
  timestamp: 1659978481
- exit_code: 1
  program: "\n/// Input are two strings a and b consisting only of 1s and 0s.\n///\
    \ Perform binary XOR on these inputs and return result also as a string.\n///\
    \ >>> string_xor(a: \"010\", b: \"110\")\n/// \"100\"\nfunc string_xor(a: String,\
    \ b: String) -> String {\n    let len = a.characters.count\n    var xor_result\
    \ = \"\"\n    for i in 0..<len {\n        let x = a[a.startIndex.advancedBy(i)]\n\
    \        let y = b[b.startIndex.advancedBy(i)]\n        xor_result += String(Int(String(x))!\
    \ ^ Int(String(y))!)\n    }\n    return xor_result\n}\n\n\nfunc ==(left: [(Int,\
    \ Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n\
    \        return false\n    }\n    for (l, r) in zip(left, right) {\n        if\
    \ l != r {\n            return false\n        }\n    }\n    return true\n}\n \
    \           \nassert(string_xor(a: \"111000\", b: \"101010\") == \"010010\")\n\
    assert(string_xor(a: \"1\", b: \"1\") == \"0\")\nassert(string_xor(a: \"0101\"\
    , b: \"0000\") == \"0101\")"
  status: SyntaxError
  stderr: "/tmp/tmpwyhe1ne_.swift:7:17: error: 'characters' is unavailable: Please\
    \ use String directly\n    let len = a.characters.count\n                ^~~~~~~~~~\n\
    Swift.String:5:16: note: 'characters' was obsoleted in Swift 5.0\n    public var\
    \ characters: String { get set }\n               ^\n/tmp/tmpwyhe1ne_.swift:10:32:\
    \ error: value of type 'String.Index' has no member 'advancedBy'\n        let\
    \ x = a[a.startIndex.advancedBy(i)]\n                  ~~~~~~~~~~~~ ^~~~~~~~~~\n\
    /tmp/tmpwyhe1ne_.swift:11:32: error: value of type 'String.Index' has no member\
    \ 'advancedBy'\n        let y = b[b.startIndex.advancedBy(i)]\n              \
    \    ~~~~~~~~~~~~ ^~~~~~~~~~\n"
  stdout: ''
  timestamp: 1659978481
- exit_code: -4
  program: "\n/// Input are two strings a and b consisting only of 1s and 0s.\n///\
    \ Perform binary XOR on these inputs and return result also as a string.\n///\
    \ >>> string_xor(a: \"010\", b: \"110\")\n/// \"100\"\nfunc string_xor(a: String,\
    \ b: String) -> String {\n    return String(repeating: \"1\", count: a.count)\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(string_xor(a: \"111000\", b: \"101010\") == \"\
    010010\")\nassert(string_xor(a: \"1\", b: \"1\") == \"0\")\nassert(string_xor(a:\
    \ \"0101\", b: \"0000\") == \"0101\")"
  status: Exception
  stderr: 'tmphy64mfde/tmphy64mfde.swift:23: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002aee589ecc80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002aee586e3b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002aee586e3988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002aee586e27b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmphy64mfde                        0x00005643f48e23eb <unavailable> + 5099

    5    libc.so.6                          0x00002aee58bd8460 __libc_start_main +
    245

    6    tmphy64mfde                        0x00005643f48e1ff9 <unavailable> + 4089

    '
  stdout: ''
  timestamp: 1659978481
- exit_code: 0
  program: "\n/// Input are two strings a and b consisting only of 1s and 0s.\n///\
    \ Perform binary XOR on these inputs and return result also as a string.\n///\
    \ >>> string_xor(a: \"010\", b: \"110\")\n/// \"100\"\nfunc string_xor(a: String,\
    \ b: String) -> String {\n    var result = \"\"\n    for (a_char, b_char) in zip(a,\
    \ b) {\n        if a_char == b_char {\n            result.append(\"0\")\n    \
    \    } else {\n            result.append(\"1\")\n        }\n    }\n    return\
    \ result\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n\
    \    if left.count != right.count {\n        return false\n    }\n    for (l,\
    \ r) in zip(left, right) {\n        if l != r {\n            return false\n  \
    \      }\n    }\n    return true\n}\n            \nassert(string_xor(a: \"111000\"\
    , b: \"101010\") == \"010010\")\nassert(string_xor(a: \"1\", b: \"1\") == \"0\"\
    )\nassert(string_xor(a: \"0101\", b: \"0000\") == \"0101\")"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659978481
- exit_code: 1
  program: "\n/// Input are two strings a and b consisting only of 1s and 0s.\n///\
    \ Perform binary XOR on these inputs and return result also as a string.\n///\
    \ >>> string_xor(a: \"010\", b: \"110\")\n/// \"100\"\nfunc string_xor(a: String,\
    \ b: String) -> String {\n\tlet charsA = a.characters.map{Int(String($0))!}\n\t\
    let charsB = b.characters.map{Int(String($0))!}\n\t\n\tvar charsXor = [Int]()\n\
    \t\n\tfor i in 0..<charsA.count {\n\t\tif charsA[i] == 0 && charsB[i] == 0 {\n\
    \t\t\tcharsXor.append(0)\n\t\t} else if charsA[i] == 1 && charsB[i] == 1 {\n\t\
    \t\tcharsXor.append(0)\n\t\t} else {\n\t\t\tcharsXor.append(1)\n\t\t}\n\t}\n\t\
    \n\treturn charsXor.map{String($0)}.reduce(\"\", combine: +)\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(string_xor(a: \"111000\", b: \"101010\") == \"010010\"\
    )\nassert(string_xor(a: \"1\", b: \"1\") == \"0\")\nassert(string_xor(a: \"0101\"\
    , b: \"0000\") == \"0101\")"
  status: SyntaxError
  stderr: "/tmp/tmp8avfpoa1.swift:7:17: error: 'characters' is unavailable: Please\
    \ use String directly\n        let charsA = a.characters.map{Int(String($0))!}\n\
    \                       ^~~~~~~~~~\nSwift.String:5:16: note: 'characters' was\
    \ obsoleted in Swift 5.0\n    public var characters: String { get set }\n    \
    \           ^\n/tmp/tmp8avfpoa1.swift:8:17: error: 'characters' is unavailable:\
    \ Please use String directly\n        let charsB = b.characters.map{Int(String($0))!}\n\
    \                       ^~~~~~~~~~\nSwift.String:5:16: note: 'characters' was\
    \ obsoleted in Swift 5.0\n    public var characters: String { get set }\n    \
    \           ^\n/tmp/tmp8avfpoa1.swift:22:40: error: extraneous argument label\
    \ 'combine:' in call\n        return charsXor.map{String($0)}.reduce(\"\", combine:\
    \ +)\n                                              ^    ~~~~~~~~~\n         \
    \                                          \n"
  stdout: ''
  timestamp: 1659978481
- exit_code: 1
  program: "\n/// Input are two strings a and b consisting only of 1s and 0s.\n///\
    \ Perform binary XOR on these inputs and return result also as a string.\n///\
    \ >>> string_xor(a: \"010\", b: \"110\")\n/// \"100\"\nfunc string_xor(a: String,\
    \ b: String) -> String {\n    let charsA = Array(a.characters)\n    let charsB\
    \ = Array(b.characters)\n    let count = charsA.count\n    assert(charsB.count\
    \ == count)\n    var result = [Character]()\n    for i in 0..<count {\n      \
    \  if charsA[i] == charsB[i] {\n            result.append(\"0\")\n        } else\
    \ {\n            result.append(\"1\")\n        }\n    }\n    return String(result)\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(string_xor(a: \"111000\", b: \"101010\") == \"\
    010010\")\nassert(string_xor(a: \"1\", b: \"1\") == \"0\")\nassert(string_xor(a:\
    \ \"0101\", b: \"0000\") == \"0101\")"
  status: SyntaxError
  stderr: "/tmp/tmpxsw21bl6.swift:7:26: error: 'characters' is unavailable: Please\
    \ use String directly\n    let charsA = Array(a.characters)\n                \
    \         ^~~~~~~~~~\nSwift.String:5:16: note: 'characters' was obsoleted in Swift\
    \ 5.0\n    public var characters: String { get set }\n               ^\n/tmp/tmpxsw21bl6.swift:8:26:\
    \ error: 'characters' is unavailable: Please use String directly\n    let charsB\
    \ = Array(b.characters)\n                         ^~~~~~~~~~\nSwift.String:5:16:\
    \ note: 'characters' was obsoleted in Swift 5.0\n    public var characters: String\
    \ { get set }\n               ^\n"
  stdout: ''
  timestamp: 1659978481
- exit_code: 1
  program: "\n/// Input are two strings a and b consisting only of 1s and 0s.\n///\
    \ Perform binary XOR on these inputs and return result also as a string.\n///\
    \ >>> string_xor(a: \"010\", b: \"110\")\n/// \"100\"\nfunc string_xor(a: String,\
    \ b: String) -> String {\n    let a = a.utf8\n    let b = b.utf8\n    let c =\
    \ zip(a, b).map {\n        UInt8(($0.0 ^ $0.1).toString, radix: 2)!\n    }\n \
    \   return String(bytes: c, encoding: String.Encoding.utf8)!\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(string_xor(a: \"111000\", b: \"101010\") == \"010010\"\
    )\nassert(string_xor(a: \"1\", b: \"1\") == \"0\")\nassert(string_xor(a: \"0101\"\
    , b: \"0000\") == \"0101\")"
  status: SyntaxError
  stderr: "/tmp/tmpw4qfj0bj.swift:10:29: error: value of type 'UInt8' has no member\
    \ 'toString'\n        UInt8(($0.0 ^ $0.1).toString, radix: 2)!\n             \
    \ ~~~~~~~~~~~~~ ^~~~~~~~\n/tmp/tmpw4qfj0bj.swift:12:55: error: extra argument\
    \ 'encoding' in call\n    return String(bytes: c, encoding: String.Encoding.utf8)!\n\
    \                 ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~^~~~~\n/tmp/tmpw4qfj0bj.swift:12:46:\
    \ error: type 'String' has no member 'Encoding'\n    return String(bytes: c, encoding:\
    \ String.Encoding.utf8)!\n                                      ~~~~~~ ^~~~~~~~\n"
  stdout: ''
  timestamp: 1659978481
- exit_code: 1
  program: "\n/// Input are two strings a and b consisting only of 1s and 0s.\n///\
    \ Perform binary XOR on these inputs and return result also as a string.\n///\
    \ >>> string_xor(a: \"010\", b: \"110\")\n/// \"100\"\nfunc string_xor(a: String,\
    \ b: String) -> String {\n    return a.utf8.lazy.map{ UInt8(bitPattern: $0) }.map{\
    \ Int($0) }.zip(b.utf8.lazy.map{ UInt8(bitPattern: $0) }.map{ Int($0) }).map{\
    \ $0 == $1 ? \"0\" : \"1\" }.reduce(\"\", +)\n}\n\n\nfunc ==(left: [(Int, Int)],\
    \ right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n       \
    \ return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r\
    \ {\n            return false\n        }\n    }\n    return true\n}\n        \
    \    \nassert(string_xor(a: \"111000\", b: \"101010\") == \"010010\")\nassert(string_xor(a:\
    \ \"1\", b: \"1\") == \"0\")\nassert(string_xor(a: \"0101\", b: \"0000\") == \"\
    0101\")"
  status: SyntaxError
  stderr: "/tmp/tmpuxjazg_t.swift:7:12: error: the compiler is unable to type-check\
    \ this expression in reasonable time; try breaking up the expression into distinct\
    \ sub-expressions\n    return a.utf8.lazy.map{ UInt8(bitPattern: $0) }.map{ Int($0)\
    \ }.zip(b.utf8.lazy.map{ UInt8(bitPattern: $0) }.map{ Int($0) }).map{ $0 == $1\
    \ ? \"0\" : \"1\" }.reduce(\"\", +)\n           ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n"
  stdout: ''
  timestamp: 1659978579
- exit_code: 1
  program: "\n/// Input are two strings a and b consisting only of 1s and 0s.\n///\
    \ Perform binary XOR on these inputs and return result also as a string.\n///\
    \ >>> string_xor(a: \"010\", b: \"110\")\n/// \"100\"\nfunc string_xor(a: String,\
    \ b: String) -> String {\n    let aa = a.to_string_as_array_of_ints()\n    let\
    \ bb = b.to_string_as_array_of_ints()\n    let cc = zip(aa, bb).map { $0 ^ $1\
    \ }\n    return cc.to_string()\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int,\
    \ Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n\
    \    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n          \
    \  return false\n        }\n    }\n    return true\n}\n            \nassert(string_xor(a:\
    \ \"111000\", b: \"101010\") == \"010010\")\nassert(string_xor(a: \"1\", b: \"\
    1\") == \"0\")\nassert(string_xor(a: \"0101\", b: \"0000\") == \"0101\")"
  status: SyntaxError
  stderr: "/tmp/tmpq4qkqr2e.swift:7:16: error: value of type 'String' has no member\
    \ 'to_string_as_array_of_ints'\n    let aa = a.to_string_as_array_of_ints()\n\
    \             ~ ^~~~~~~~~~~~~~~~~~~~~~~~~~\n/tmp/tmpq4qkqr2e.swift:8:16: error:\
    \ value of type 'String' has no member 'to_string_as_array_of_ints'\n    let bb\
    \ = b.to_string_as_array_of_ints()\n             ~ ^~~~~~~~~~~~~~~~~~~~~~~~~~\n"
  stdout: ''
  timestamp: 1659978481
- exit_code: 0
  program: "\n/// Input are two strings a and b consisting only of 1s and 0s.\n///\
    \ Perform binary XOR on these inputs and return result also as a string.\n///\
    \ >>> string_xor(a: \"010\", b: \"110\")\n/// \"100\"\nfunc string_xor(a: String,\
    \ b: String) -> String {\n    let arrayA = Array(a)\n    let arrayB = Array(b)\n\
    \    var result = [String]()\n    for (i, char) in arrayA.enumerated() {\n   \
    \     if char == arrayB[i] {\n            result.append(\"0\")\n        } else\
    \ {\n            result.append(\"1\")\n        }\n    }\n    return result.joined()\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(string_xor(a: \"111000\", b: \"101010\") == \"\
    010010\")\nassert(string_xor(a: \"1\", b: \"1\") == \"0\")\nassert(string_xor(a:\
    \ \"0101\", b: \"0000\") == \"0101\")"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659978481
- exit_code: -4
  program: "\n/// Input are two strings a and b consisting only of 1s and 0s.\n///\
    \ Perform binary XOR on these inputs and return result also as a string.\n///\
    \ >>> string_xor(a: \"010\", b: \"110\")\n/// \"100\"\nfunc string_xor(a: String,\
    \ b: String) -> String {\n    return \"\"\n}\n\n\nfunc ==(left: [(Int, Int)],\
    \ right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n       \
    \ return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r\
    \ {\n            return false\n        }\n    }\n    return true\n}\n        \
    \    \nassert(string_xor(a: \"111000\", b: \"101010\") == \"010010\")\nassert(string_xor(a:\
    \ \"1\", b: \"1\") == \"0\")\nassert(string_xor(a: \"0101\", b: \"0000\") == \"\
    0101\")"
  status: Exception
  stderr: 'tmp1ma40nkp/tmp1ma40nkp.swift:23: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b0563602c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b05632f9b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b05632f9988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b05632f87b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmp1ma40nkp                        0x0000563c4899b33b <unavailable> + 4923

    5    libc.so.6                          0x00002b05637ee460 __libc_start_main +
    245

    6    tmp1ma40nkp                        0x0000563c4899af49 <unavailable> + 3913

    '
  stdout: ''
  timestamp: 1659978479
- exit_code: 1
  program: "\n/// Input are two strings a and b consisting only of 1s and 0s.\n///\
    \ Perform binary XOR on these inputs and return result also as a string.\n///\
    \ >>> string_xor(a: \"010\", b: \"110\")\n/// \"100\"\nfunc string_xor(a: String,\
    \ b: String) -> String {\n    // Create an array of UInt8 values then XOR them.\n\
    \    let xor = Array(a.utf8).map{ UInt8($0) }.enumerated().map { $1 ^ Array(b.utf8)[$0]\
    \ }\n    return String(bytes: xor, encoding: .utf8)!\n}\n\n\nfunc ==(left: [(Int,\
    \ Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n\
    \        return false\n    }\n    for (l, r) in zip(left, right) {\n        if\
    \ l != r {\n            return false\n        }\n    }\n    return true\n}\n \
    \           \nassert(string_xor(a: \"111000\", b: \"101010\") == \"010010\")\n\
    assert(string_xor(a: \"1\", b: \"1\") == \"0\")\nassert(string_xor(a: \"0101\"\
    , b: \"0000\") == \"0101\")"
  status: SyntaxError
  stderr: "/tmp/tmpdjw881cy.swift:9:12: error: no exact matches in call to initializer\
    \ \n    return String(bytes: xor, encoding: .utf8)!\n           ^\n/tmp/tmpdjw881cy.swift:9:12:\
    \ note: found candidate with type '(Array<_>, _.Type) -> String'\n    return String(bytes:\
    \ xor, encoding: .utf8)!\n           ^\n/tmp/tmpdjw881cy.swift:9:12: note: found\
    \ candidate with type '([UInt8]) -> String'\n    return String(bytes: xor, encoding:\
    \ .utf8)!\n           ^\n/tmp/tmpdjw881cy.swift:9:12: note: found candidate with\
    \ type '(Substring.UTF8View) -> String?'\n    return String(bytes: xor, encoding:\
    \ .utf8)!\n           ^\n/tmp/tmpdjw881cy.swift:9:12: note: found candidate with\
    \ type '(Substring.UTF16View) -> String?'\n    return String(bytes: xor, encoding:\
    \ .utf8)!\n           ^\n"
  stdout: ''
  timestamp: 1659978481
- exit_code: 0
  program: "\n/// Input are two strings a and b consisting only of 1s and 0s.\n///\
    \ Perform binary XOR on these inputs and return result also as a string.\n///\
    \ >>> string_xor(a: \"010\", b: \"110\")\n/// \"100\"\nfunc string_xor(a: String,\
    \ b: String) -> String {\n    var result = \"\"\n    for (chara, charb) in zip(a,\
    \ b) {\n        if chara == charb {\n            result.append(\"0\")\n      \
    \  } else {\n            result.append(\"1\")\n        }\n    }\n    return result\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(string_xor(a: \"111000\", b: \"101010\") == \"\
    010010\")\nassert(string_xor(a: \"1\", b: \"1\") == \"0\")\nassert(string_xor(a:\
    \ \"0101\", b: \"0000\") == \"0101\")"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659978481
- exit_code: 0
  program: "\n/// Input are two strings a and b consisting only of 1s and 0s.\n///\
    \ Perform binary XOR on these inputs and return result also as a string.\n///\
    \ >>> string_xor(a: \"010\", b: \"110\")\n/// \"100\"\nfunc string_xor(a: String,\
    \ b: String) -> String {\n    var output: [Int] = []\n    let a_array = Array(a.utf8).map{\
    \ Int($0) - 48 }\n    let b_array = Array(b.utf8).map{ Int($0) - 48 }\n    for\
    \ index in 0...a_array.count-1 {\n        if a_array[index] == b_array[index]\
    \ {\n            output.append(0)\n        } else {\n            output.append(1)\n\
    \        }\n    }\n    return output.map(String.init).joined()\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(string_xor(a: \"111000\", b: \"101010\") == \"010010\"\
    )\nassert(string_xor(a: \"1\", b: \"1\") == \"0\")\nassert(string_xor(a: \"0101\"\
    , b: \"0000\") == \"0101\")"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659978481
- exit_code: 1
  program: "\n/// Input are two strings a and b consisting only of 1s and 0s.\n///\
    \ Perform binary XOR on these inputs and return result also as a string.\n///\
    \ >>> string_xor(a: \"010\", b: \"110\")\n/// \"100\"\nfunc string_xor(a: String,\
    \ b: String) -> String {\n    var ans = \"\"\n    for i in 0..<a.characters.count\
    \ {\n        if a[i] == b[i] {\n            ans += \"0\"\n        } else {\n \
    \           ans += \"1\"\n        }\n    }\n    return ans\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(string_xor(a: \"111000\", b: \"101010\") == \"010010\"\
    )\nassert(string_xor(a: \"1\", b: \"1\") == \"0\")\nassert(string_xor(a: \"0101\"\
    , b: \"0000\") == \"0101\")"
  status: SyntaxError
  stderr: "/tmp/tmpfwm0r4rx.swift:8:20: error: 'characters' is unavailable: Please\
    \ use String directly\n    for i in 0..<a.characters.count {\n               \
    \    ^~~~~~~~~~\nSwift.String:5:16: note: 'characters' was obsoleted in Swift\
    \ 5.0\n    public var characters: String { get set }\n               ^\n/tmp/tmpfwm0r4rx.swift:9:12:\
    \ error: 'subscript(_:)' is unavailable: cannot subscript String with an Int,\
    \ use a String.Index instead.\n        if a[i] == b[i] {\n           ^~~~\nSwift.String:3:12:\
    \ note: 'subscript(_:)' has been explicitly marked unavailable here\n    public\
    \ subscript(i: Int) -> Character { get }\n           ^\n/tmp/tmpfwm0r4rx.swift:9:20:\
    \ error: 'subscript(_:)' is unavailable: cannot subscript String with an Int,\
    \ use a String.Index instead.\n        if a[i] == b[i] {\n                   ^~~~\n\
    Swift.String:3:12: note: 'subscript(_:)' has been explicitly marked unavailable\
    \ here\n    public subscript(i: Int) -> Character { get }\n           ^\n"
  stdout: ''
  timestamp: 1659978481
- exit_code: -4
  program: "\n/// Input are two strings a and b consisting only of 1s and 0s.\n///\
    \ Perform binary XOR on these inputs and return result also as a string.\n///\
    \ >>> string_xor(a: \"010\", b: \"110\")\n/// \"100\"\nfunc string_xor(a: String,\
    \ b: String) -> String {\n    return \"100\"\n}\n\n\nfunc ==(left: [(Int, Int)],\
    \ right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n       \
    \ return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r\
    \ {\n            return false\n        }\n    }\n    return true\n}\n        \
    \    \nassert(string_xor(a: \"111000\", b: \"101010\") == \"010010\")\nassert(string_xor(a:\
    \ \"1\", b: \"1\") == \"0\")\nassert(string_xor(a: \"0101\", b: \"0000\") == \"\
    0101\")"
  status: Exception
  stderr: 'tmp30mxpdof/tmp30mxpdof.swift:23: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002ae2d564ac80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002ae2d5341b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002ae2d5341988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002ae2d53407b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmp30mxpdof                        0x000056251b6b633b <unavailable> + 4923

    5    libc.so.6                          0x00002ae2d5836460 __libc_start_main +
    245

    6    tmp30mxpdof                        0x000056251b6b5f49 <unavailable> + 3913

    '
  stdout: ''
  timestamp: 1659978481
- exit_code: 1
  program: "\n/// Input are two strings a and b consisting only of 1s and 0s.\n///\
    \ Perform binary XOR on these inputs and return result also as a string.\n///\
    \ >>> string_xor(a: \"010\", b: \"110\")\n/// \"100\"\nfunc string_xor(a: String,\
    \ b: String) -> String {\n    let a_bytes = [UInt8](a.utf8)\n    let b_bytes =\
    \ [UInt8](b.utf8)\n    var answer = [UInt8]()\n    var ctr = 0\n    while ctr\
    \ < a_bytes.count {\n        answer.append(a_bytes[ctr] ^ b_bytes[ctr])\n    \
    \    ctr += 1\n    }\n    return String(bytes: answer, encoding: .utf8)!\n}\n\n\
    \nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(string_xor(a: \"111000\", b: \"101010\") == \"\
    010010\")\nassert(string_xor(a: \"1\", b: \"1\") == \"0\")\nassert(string_xor(a:\
    \ \"0101\", b: \"0000\") == \"0101\")"
  status: SyntaxError
  stderr: "/tmp/tmpl4x_oziw.swift:15:12: error: no exact matches in call to initializer\
    \ \n    return String(bytes: answer, encoding: .utf8)!\n           ^\n/tmp/tmpl4x_oziw.swift:15:12:\
    \ note: found candidate with type '(Array<_>, _.Type) -> String'\n    return String(bytes:\
    \ answer, encoding: .utf8)!\n           ^\n/tmp/tmpl4x_oziw.swift:15:12: note:\
    \ found candidate with type '([UInt8]) -> String'\n    return String(bytes: answer,\
    \ encoding: .utf8)!\n           ^\n/tmp/tmpl4x_oziw.swift:15:12: note: found candidate\
    \ with type '(Substring.UTF8View) -> String?'\n    return String(bytes: answer,\
    \ encoding: .utf8)!\n           ^\n/tmp/tmpl4x_oziw.swift:15:12: note: found candidate\
    \ with type '(Substring.UTF16View) -> String?'\n    return String(bytes: answer,\
    \ encoding: .utf8)!\n           ^\n"
  stdout: ''
  timestamp: 1659978481
