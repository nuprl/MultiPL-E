name: HumanEval_132_is_nested
language: swift
prompt: "\n/// Create a function that takes a string as input which contains only\
  \ square brackets.\n/// The function should return true if and only if there is\
  \ a valid subsequence of brackets \n/// where at least one bracket in the subsequence\
  \ is nested.\n/// >>> is_nested(string: \"[[]]\")\n/// true\n/// >>> is_nested(string:\
  \ \"[]]]]]]][[[[[]\")\n/// false\n/// >>> is_nested(string: \"[][]\")\n/// false\n\
  /// >>> is_nested(string: \"[]\")\n/// false\n/// >>> is_nested(string: \"[[][]]\"\
  )\n/// true\n/// >>> is_nested(string: \"[[]][[\")\n/// true\nfunc is_nested(string:\
  \ String) -> Bool {\n"
tests: "}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if\
  \ left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left,\
  \ right) {\n        if l != r {\n            return false\n        }\n    }\n  \
  \  return true\n}\n            \nassert(is_nested(string: \"[[]]\") == true)\nassert(is_nested(string:\
  \ \"[]]]]]]][[[[[]\") == false)\nassert(is_nested(string: \"[][]\") == false)\n\
  assert(is_nested(string: \"[]\") == false)\nassert(is_nested(string: \"[[[[]]]]\"\
  ) == true)\nassert(is_nested(string: \"[]]]]]]]]]]\") == false)\nassert(is_nested(string:\
  \ \"[][][[]]\") == true)\nassert(is_nested(string: \"[[]\") == false)\nassert(is_nested(string:\
  \ \"[]]\") == false)\nassert(is_nested(string: \"[[]][[\") == true)\nassert(is_nested(string:\
  \ \"[[][]]\") == true)\nassert(is_nested(string: \"\") == false)\nassert(is_nested(string:\
  \ \"[[[[[[[[\") == false)\nassert(is_nested(string: \"]]]]]]]]\") == false)"
completions: ["    var open = 0\n    var close = 0\n    for char in string {\n   \
    \     if char == \"[\" {\n            open += 1\n        } else if char == \"\
    ]\" {\n            close += 1\n        }\n    }\n    return open > 0 && open ==\
    \ close", "    // square bracket only\n    if !string.contains(\"[\") || !string.contains(\"\
    ]\") {\n        return false\n    }\n    \n    let string = Array(string)\n  \
    \  var stack: [String] = []\n    \n    for bracket in string {\n        // push\
    \ all left bracket into stack\n        if bracket == \"[\" {\n            stack.append(String(bracket))\n\
    \        } else {\n            // check if the stack is empty\n            //\
    \ if it is empty, the string is invalid because\n            // there are no more\
    \ left bracket to match with the right bracket\n            if stack.isEmpty {\n\
    \                return false\n            }\n            \n            // pop\
    \ off the last bracket in the stack\n            stack.removeLast()\n        }\n\
    \    }\n    \n    // check if the stack is empty\n    // if it is empty, all brackets\
    \ has been matched\n    // if not, the string is invalid because the number of\
    \ left brackets and right brackets is not equal\n    return stack.isEmpty", " \
    \   if string.isEmpty {\n        return false\n    }\n    var stack = Stack<Character>()\n\
    \    for bracket in string {\n        if bracket == \"[\" {\n            stack.push(bracket)\n\
    \        } else {\n            if stack.isEmpty {\n                return false\n\
    \            }\n            _ = stack.pop()\n        }\n    }\n    return stack.isEmpty",
  "  // your code here\n  return false", "    var index = string.startIndex\n    var\
    \ openCount = 0\n    var closeCount = 0\n    while index != string.endIndex {\n\
    \        let char = string[index]\n        if char == \"[\" {\n            openCount\
    \ += 1\n        } else if char == \"]\" {\n            closeCount += 1\n     \
    \   }\n        if closeCount > openCount {\n            return false\n       \
    \ }\n        index = string.index(after: index)\n    }\n    return openCount >\
    \ closeCount ? false : openCount > 0", "    let leftBracket = Character(\"[\"\
    )\n    let rightBracket = Character(\"]\")\n    let characters = Array(string)\n\
    \    let reversedCharacters = characters.reversed()\n    var leftBracketCount\
    \ = 0\n    var rightBracketCount = 0\n    for char in characters {\n        if\
    \ char == leftBracket {\n            leftBracketCount += 1\n        }\n    }\n\
    \    for char in reversedCharacters {\n        if char == rightBracket {\n   \
    \         rightBracketCount += 1\n        }\n    }\n    if rightBracketCount >\
    \ leftBracketCount {\n        return false\n    }\n    var leftBracketOpened =\
    \ 0\n    var rightBracketOpened = 0\n    for char in characters {\n        if\
    \ char == leftBracket {\n            leftBracketOpened += 1\n        } else if\
    \ char == rightBracket {\n            rightBracketOpened += 1\n        }\n   \
    \     if rightBracketOpened > leftBracketOpened {\n            return false\n\
    \        }\n    }\n    return true", "    let string = string.map { char -> Character\
    \ in\n        if char == \"[\" {\n            return char\n        } else {\n\
    \            return \"]\"\n        }\n    }\n    var stack = [Character]()\n \
    \   for char in string {\n        if char == \"[\" {\n            stack.append(char)\n\
    \        } else {\n            if let last = stack.last {\n                if\
    \ last == \"[\" {\n                    stack.removeLast()\n                } else\
    \ {\n                    return false\n                }\n            } else {\n\
    \                return false\n            }\n        }\n    }\n    return stack.isEmpty",
  '    return false', "    var count = 0\n    for char in string {\n        if char\
    \ == \"[\" {\n            count += 1\n        } else if char == \"]\" {\n    \
    \        count -= 1\n        }\n        if count < 0 {\n            return false\n\
    \        }\n    }\n    return count == 0", "    // TODO\n    return false", " \
    \   var stack = [Character]()\n    for char in string {\n        if char == \"\
    [\" {\n            stack.append(char)\n        } else if char == \"]\" {\n   \
    \         if let poppedChar = stack.popLast() {\n                if poppedChar\
    \ != \"[\" {\n                    return false\n                }\n          \
    \  } else {\n                return false\n            }\n        }\n    }\n \
    \   return stack.isEmpty", "    let openingBrackets = Set<Character>(arrayLiteral:\
    \ \"[\")\n    let validSequence = [Character]()\n    var currentSequence = [Character]()\n\
    \    var stack = [Character]()\n    \n    for bracket in string {\n        if\
    \ openingBrackets.contains(bracket) {\n            stack.append(bracket)\n   \
    \     } else {\n            // check if there is any opening bracket\n       \
    \     if stack.isEmpty {\n                return false\n            }\n      \
    \      stack.removeLast()\n        }\n    }\n    \n    return stack.isEmpty",
  "    \n    var queue: [Character] = []\n    \n    for char in string {\n       \
    \ if char == \"[\" {\n            queue.append(char)\n        } else if char ==\
    \ \"]\" {\n            if queue.isEmpty {\n                return false\n    \
    \        } else {\n                queue.removeFirst()\n            }\n      \
    \  }\n    }\n    \n    return queue.isEmpty", "    let list = string.map { $0\
    \ == \"[\" ? 1 : -1 }\n    return (0 ..< list.count).map { list.prefix($0).reduce(0,\
    \ +) }.filter { $0 < 0 }.count == 0", "    var openBrackets: [Character] = []\n\
    \    for c in string {\n        if c == \"[\" {\n            openBrackets.append(c)\n\
    \        } else if c == \"]\" {\n            if openBrackets.count == 0 {\n  \
    \              return false\n            }\n            openBrackets.removeLast()\n\
    \        }\n    }\n    return openBrackets.count == 0", "    var left = 0\n  \
    \  var right = 0\n    for c in string {\n        if c == \"[\" {\n           \
    \ left += 1\n        } else if c == \"]\" {\n            right += 1\n        }\n\
    \        if right > left {\n            return false\n        }\n    }\n    return\
    \ left == right", "    var queue = Queue<Character>()\n    for bracket in string\
    \ {\n        if bracket == \"[\" {\n            queue.enqueue(item: bracket)\n\
    \        } else {\n            if queue.isEmpty() {\n                return false\n\
    \            } else {\n                _ = queue.dequeue()\n            }\n  \
    \      }\n    }\n    return queue.isEmpty()", "    var stack = Stack<Character>()\n\
    \    for bracket in string {\n        if bracket == \"[\" {\n            stack.push(bracket)\n\
    \        } else if bracket == \"]\" {\n            if stack.isEmpty() {\n    \
    \            return false\n            } else {\n                stack.pop()\n\
    \            }\n        }\n    }\n    return stack.isEmpty()", "    let chars\
    \ = Array(string)\n    var count = 0\n    for c in chars {\n        if c == \"\
    [\" {\n            count += 1\n        } else if c == \"]\" {\n            count\
    \ -= 1\n        }\n        if count < 0 {\n            return false\n        }\n\
    \    }\n    return count == 0", "    // add code here\n    var stack: [Character]\
    \ = []\n    for char in string {\n        if char == \"[\" {\n            stack.append(char)\n\
    \        } else if char == \"]\" {\n            if stack.count == 0 {\n      \
    \          return false\n            } else {\n                stack.removeLast()\n\
    \            }\n        }\n    }\n    return stack.count == 0", "    var stack:\
    \ [String] = []\n    for i in string {\n        if i == \"[\" {\n            stack.append(\"\
    [\")\n        } else if i == \"]\" {\n            if stack.count == 0 {\n    \
    \            return false\n            } else {\n                stack.removeLast()\n\
    \            }\n        }\n    }\n    return stack.count > 0", "    var stack\
    \ = Stack<Character>()\n    for char in string {\n        if char == \"[\" {\n\
    \            stack.push(value: char)\n        } else if char == \"]\" {\n    \
    \        if stack.peek() == \"[\" {\n                stack.pop()\n           \
    \ } else {\n                return false\n            }\n        }\n    }\n  \
    \  return stack.isEmpty()", "    var stack = Stack<Character>()\n    for character\
    \ in string {\n        if character == \"[\" {\n            stack.push(character)\n\
    \        } else if character == \"]\" {\n            if let bracket = stack.pop()\
    \ {\n                if bracket != \"[\" {\n                    return false\n\
    \                }\n            } else {\n                return false\n     \
    \       }\n        }\n    }\n    return stack.isEmpty", "    var stack = Stack<Character>()\n\
    \    for char in string {\n        if char == \"[\" {\n            stack.push(char)\n\
    \        } else if char == \"]\" {\n            if stack.isEmpty {\n         \
    \       return false\n            } else {\n                stack.pop()\n    \
    \        }\n        }\n    }\n    return stack.isEmpty", '    return true', " \
    \   \n    var array_of_characters = Array(string)\n    var counter_of_open_brackets\
    \ = 0\n    var counter_of_closed_brackets = 0\n    \n    for i in 0..<array_of_characters.count\
    \ {\n        if array_of_characters[i] == \"[\" {\n            counter_of_open_brackets\
    \ += 1\n        } else if array_of_characters[i] == \"]\" {\n            counter_of_closed_brackets\
    \ += 1\n        }\n    }\n    \n    if counter_of_open_brackets == counter_of_closed_brackets\
    \ {\n        return false\n    } else {\n        return true\n    }", "    \n\
    \    var stack: [Character] = []\n    \n    for bracket in string {\n        if\
    \ bracket == \"[\" {\n            stack.append(bracket)\n        } else if bracket\
    \ == \"]\" {\n            if stack.isEmpty {\n                return false\n \
    \           } else {\n                let _ = stack.popLast()\n            }\n\
    \        }\n    }\n    \n    return stack.isEmpty", "    \n    var open = 0\n\
    \    var close = 0\n    \n    for bracket in string {\n        if bracket == \"\
    [\" {\n            open += 1\n        } else if bracket == \"]\" {\n         \
    \   close += 1\n        }\n    }\n    \n    return open == close", "    var stack\
    \ = Stack<Character>()\n    for c in string {\n        if c == \"[\" {\n     \
    \       stack.push(c)\n        } else if c == \"]\" {\n            if stack.isEmpty\
    \ {\n                return false\n            } else {\n                stack.pop()\n\
    \            }\n        }\n    }\n    return stack.isEmpty", '    return false',
  "    var stack = Stack<Character>()\n    for bracket in string {\n        if bracket\
    \ == \"[\" {\n            stack.push(bracket)\n        } else if bracket == \"\
    ]\" {\n            if stack.isEmpty {\n                return false\n        \
    \    } else {\n                stack.pop()\n            }\n        }\n    }\n\
    \    return stack.isEmpty", "    var index = 0\n    var last = 0\n    var stack\
    \ = [Int]()\n    for c in string {\n        if c == \"[\" {\n            stack.append(index)\n\
    \        } else {\n            if stack.count == 0 {\n                return false\n\
    \            }\n            last = stack.popLast()!\n        }\n        index\
    \ += 1\n    }\n    return index - last > 1", "    \n    var stack = Stack<Character>()\n\
    \    \n    for character in string {\n        switch character {\n        case\
    \ \"[\":\n            stack.push(character)\n        case \"]\":\n           \
    \ if stack.isEmpty {\n                return false\n            } else {\n   \
    \             stack.pop()\n            }\n        default:\n            print(\"\
    wrong character\")\n        }\n    }\n    \n    return stack.isEmpty", '    return
    true', "  var stack = [Character]()\n  for c in string {\n    if c == \"[\" {\n\
    \      stack.append(c)\n    } else if c == \"]\" {\n      if stack.isEmpty {\n\
    \        return false\n      }\n      stack.removeLast()\n    }\n  }\n  return\
    \ stack.isEmpty", "    var stack = [Character]()\n    for char in string {\n \
    \       if char == \"[\" {\n            stack.append(char)\n        } else if\
    \ !stack.isEmpty {\n            stack.removeLast()\n        } else {\n       \
    \     return false\n        }\n    }\n    return stack.isEmpty", "  var stack\
    \ = [Character]()\n  for bracket in string {\n    if bracket == \"[\" {\n    \
    \  stack.append(bracket)\n    } else if bracket == \"]\" {\n      if stack.last\
    \ == \"[\" {\n        stack.removeLast()\n      } else {\n        return false\n\
    \      }\n    }\n  }\n  return stack.isEmpty", "    var count = 0\n    for char\
    \ in string {\n        if char == \"[\" {\n            count += 1\n        } else\
    \ if char == \"]\" {\n            count -= 1\n        }\n        if count < 0\
    \ {\n            return false\n        }\n    }\n    return count == 0", "   \
    \ var maxDepth = 0\n    var depth = 0\n    for char in string {\n        if char\
    \ == \"[\" {\n            depth += 1\n            maxDepth = max(maxDepth, depth)\n\
    \        } else if char == \"]\" {\n            depth -= 1\n        }\n    }\n\
    \    return maxDepth > 1", "    \n    var stack = [Character]()\n    \n    for\
    \ character in string {\n        switch character {\n        case \"[\":\n   \
    \         stack.append(character)\n        case \"]\":\n            if stack.isEmpty\
    \ {\n                return false\n            } else {\n                let left\
    \ = stack.popLast()\n                if left != \"[\" {\n                    return\
    \ false\n                }\n            }\n        default:\n            continue\n\
    \        }\n    }\n    \n    return stack.isEmpty", "    // your code here\n \
    \   return false", "    var stack = [Character]()\n    var valid_subsequence =\
    \ false\n    var found_subsequence = false\n    for c in string {\n        if\
    \ (c == \"[\") {\n            if (stack.count > 0) {\n                valid_subsequence\
    \ = true\n            }\n            stack.append(c)\n        } else if (c ==\
    \ \"]\") {\n            if (stack.count > 0) {\n                stack.removeLast()\n\
    \            } else {\n                return false\n            }\n        }\n\
    \    }\n    if (stack.count == 0 && valid_subsequence) {\n        return true\n\
    \    }\n    return false", "    var leftBracketsCount = 0\n    var rightBracketsCount\
    \ = 0\n    for char in string {\n        if char == \"[\" {\n            leftBracketsCount\
    \ += 1\n        } else if char == \"]\" {\n            rightBracketsCount += 1\n\
    \        }\n    }\n    return leftBracketsCount == rightBracketsCount", "    //\
    \ your code goes here\n    // loop through the string\n    // filter the brackets\
    \ if it's not empty\n    let brackets = string.filter { $0 == \"[\" || $0 == \"\
    ]\" }\n    // check if brackets contains a valid subsequence of brackets where\
    \ at least one bracket in the subsequence is nested.\n    return brackets.contains(\"\
    [\") && brackets.contains(\"]\")", "    // Initialize a dictionary to keep track\
    \ of the count of open and closed brackets\n    var dict = [Character: Int]()\n\
    \    // Add the brackets to the dictionary\n    for bracket in string {\n    \
    \    dict[bracket] = dict[bracket, default: 0] + 1\n    }\n    // If there are\
    \ no open brackets, then there is no nesting\n    if dict[\"[\"] == nil {\n  \
    \      return false\n    }\n    // If there are more closed brackets than open\
    \ brackets, then there is no nesting\n    if dict[\"[\"]! < dict[\"]\"]! {\n \
    \       return false\n    }\n    // If there are equal numbers of open and closed\
    \ brackets, then there is no nesting\n    if dict[\"[\"]! == dict[\"]\"]! {\n\
    \        return false\n    }\n    // Otherwise, there is nesting\n    return true",
  "    var brackets = [Character]()\n    for i in string {\n        if i == \"[\"\
    \ {\n            brackets.append(i)\n        } else if i == \"]\" {\n        \
    \    if brackets.isEmpty {\n                return false\n            } else {\n\
    \                brackets.removeLast()\n            }\n        }\n    }\n    return\
    \ brackets.isEmpty", "    var temp = \"\"\n    for ch in string {\n        if\
    \ ch == \"[\" {\n            temp.append(ch)\n        } else if temp != \"\" {\n\
    \            temp.removeLast()\n        }\n    }\n    return temp == \"\"", " \
    \   var openBrackets = 0\n    var nestedBrackets = 0\n    for c in string {\n\
    \        if c == \"[\" {\n            openBrackets += 1\n        } else if c ==\
    \ \"]\" {\n            if openBrackets > 0 {\n                openBrackets -=\
    \ 1\n                nestedBrackets += 1\n            }\n        }\n    }\n  \
    \  return nestedBrackets > 0", "    // First, we need to remove all the non-bracket\
    \ characters\n    let clean_string = string.filter { $0 == \"[\" || $0 == \"]\"\
    \ }\n    // Then, we need to make sure we can parse the string\n    if let parsed_string\
    \ = try? Parse.any_brackets(clean_string) {\n        // This function will parse\
    \ the string for us\n        return is_nested(string: parsed_string)\n    }\n\
    \    return false", "    let array = Array(string)\n    var map = [Character:\
    \ Int]()\n    for char in array {\n        if char == \"[\" {\n            map[\"\
    [\"] = (map[\"[\"] ?? 0) + 1\n        } else {\n            if let value = map[\"\
    [\"] {\n                if value == 0 {\n                    return false\n  \
    \              } else {\n                    map[\"[\"] = value - 1\n        \
    \        }\n            } else {\n                return false\n            }\n\
    \        }\n    }\n    return map[\"[\"] == 0", "    if string.count == 0 {\n\
    \        return false\n    }\n    if string.count % 2 != 0 {\n        return false\n\
    \    }\n    var opened = 0\n    var closed = 0\n    var arr = Array(string)\n\
    \    var lastSeen = \"\"\n    for bracket in arr {\n        if bracket == \"[\"\
    \ {\n            opened += 1\n            lastSeen = \"[\"\n        } else {\n\
    \            closed += 1\n            lastSeen = \"]\"\n        }\n        if\
    \ closed > opened {\n            return false\n        }\n    }\n    if opened\
    \ != closed {\n        return false\n    }\n    if lastSeen == \"[\" {\n     \
    \   return false\n    }\n    return true", "    if string.isEmpty {\n        return\
    \ false\n    }\n    var stack = [Character]()\n    for c in string {\n       \
    \ if c == \"[\" {\n            stack.append(c)\n        } else if c == \"]\" {\n\
    \            if let last = stack.last {\n                if last == \"[\" {\n\
    \                    stack.removeLast()\n                } else {\n          \
    \          return false\n                }\n            } else {\n           \
    \     return false\n            }\n        }\n    }\n    return stack.isEmpty",
  "    var stack = Stack<Character>()\n    for c in string {\n        if c == \"[\"\
    \ {\n            stack.push(c)\n        } else if c == \"]\" {\n            if\
    \ let last = stack.last {\n                if last == \"[\" {\n              \
    \      stack.pop()\n                } else {\n                    stack.push(c)\n\
    \                }\n            } else {\n                stack.push(c)\n    \
    \        }\n        }\n    }\n    return stack.isEmpty", "  let stack = Stack<Character>()\n\
    \  for char in string {\n    switch char {\n    case \"[\":\n      stack.push(value:\
    \ char)\n    case \"]\":\n      if stack.isEmpty() {\n        return false\n \
    \     }\n      if stack.pop() == \"[\" {\n        return true\n      }\n    default:\n\
    \      return false\n    }\n  }\n  return false", "    var queue: [String] = []\n\
    \    for char in string {\n        if let first = queue.first, first == \"\",\
    \ let last = queue.last, last == \"\" {\n            queue.append(String(char))\n\
    \        } else if let first = queue.first, first == \"[\", let last = queue.last,\
    \ last == \"]\" {\n            queue.append(String(char))\n        } else if let\
    \ first = queue.first, first == \"[\", let last = queue.last, last == \"[\" {\n\
    \            queue.append(String(char))\n        } else if let first = queue.first,\
    \ first == \"]\", let last = queue.last, last == \"]\" {\n            queue.append(String(char))\n\
    \        } else if let first = queue.first, first == \"]\", let last = queue.last,\
    \ last == \"[\" {\n            queue.append(String(char))\n        } else {\n\
    \            queue.append(String(char))\n        }\n    }\n    if let first =\
    \ queue.first, first == \"[\", let last = queue.last, last == \"]\" {\n      \
    \  return true\n    } else {\n        return false\n    }", "    let allowedChars\
    \ = Set<Character>(\"[]\")\n    let filtered = string.filter { allowedChars.contains($0)\
    \ }\n    let filteredCount = filtered.count\n    if filteredCount == 0 {\n   \
    \     return false\n    }\n    if filteredCount % 2 != 0 {\n        return false\n\
    \    }\n    var characterStack = [Character]()\n    for char in filtered {\n \
    \       if char == \"[\" {\n            characterStack.append(char)\n        }\
    \ else {\n            if characterStack.count == 0 {\n                return false\n\
    \            }\n            characterStack.removeLast()\n        }\n    }\n  \
    \  return characterStack.count == 0", "    let stack = Stack<Character>()\n  \
    \  var is_subsequence = false\n    for c in string {\n        if c == \"[\" {\n\
    \            stack.push(elem: c)\n        } else if c == \"]\" {\n           \
    \ if stack.is_empty() {\n                is_subsequence = true\n            }\
    \ else {\n                stack.pop()\n            }\n        }\n    }\n    return\
    \ stack.is_empty() && is_subsequence", "    var stack = Stack<Character>()\n \
    \   for c in string {\n        if c == \"[\" {\n            stack.push(c)\n  \
    \      } else if c == \"]\" {\n            if stack.isEmpty {\n              \
    \  return false\n            } else {\n                stack.pop()\n         \
    \   }\n        }\n    }\n    return stack.isEmpty", "    let chars = Array(string)\n\
    \    var stack = [Character]()\n    for c in chars {\n        if c == \"[\" {\n\
    \            stack.append(c)\n        } else if c == \"]\" {\n            if stack.isEmpty\
    \ {\n                return false\n            } else {\n                stack.removeLast()\n\
    \            }\n        }\n    }\n    return stack.isEmpty", "    // TODO: Complete\
    \ this function\n    return false", '    return false', "    \n    var stack =\
    \ Stack<Character>()\n    \n    for character in string {\n        if character\
    \ == \"[\" {\n            stack.push(element: character)\n        } else if character\
    \ == \"]\" {\n            if stack.isEmpty() {\n                return false\n\
    \            } else {\n                stack.pop()\n            }\n        }\n\
    \    }\n    \n    return stack.isEmpty()", '    return false', "    var left =\
    \ 0\n    var right = 0\n    var found = false\n    for char in string {\n    \
    \    if left < right {\n            return false\n        }\n        if char ==\
    \ \"[\" {\n            left += 1\n        } else if char == \"]\" {\n        \
    \    right += 1\n        }\n        if left > 0 && right > 0 {\n            found\
    \ = true\n        }\n    }\n    return left == right && found", "    var stack\
    \ = Stack<Character>()\n    for char in string {\n        if char == \"[\" {\n\
    \            stack.push(item: char)\n        } else if char == \"]\" {\n     \
    \       if stack.isEmpty() {\n                return false\n            } else\
    \ {\n                stack.pop()\n            }\n        }\n    }\n    return\
    \ stack.isEmpty()", "    var characterArray = [Character]()\n    for character\
    \ in string {\n        characterArray.append(character)\n    }\n    var result\
    \ = false\n    while !characterArray.isEmpty {\n        let character = characterArray.removeFirst()\n\
    \        if character == \"[\" {\n            if characterArray.first == \"[\"\
    \ {\n                let _ = characterArray.removeFirst()\n                result\
    \ = true\n            }\n        }\n    }\n    return result", "    \n    var\
    \ string_: String = string\n    var found_open_bracket: Bool = false\n    var\
    \ found_closed_bracket: Bool = false\n    \n    // Remove all spaces from string\n\
    \    let string_no_space = string_.replacingOccurrences(of: \" \", with: \"\"\
    )\n    \n    // Count the brackets in the string\n    if let count_open_bracket\
    \ = string_no_space.components(separatedBy: \"[\").count as? Int,\n        let\
    \ count_closed_bracket = string_no_space.components(separatedBy: \"]\").count\
    \ as? Int {\n        if count_open_bracket != count_closed_bracket {\n       \
    \     return false\n        }\n    }\n    \n    // Loop through the string checking\
    \ for brackets\n    for char in string_no_space {\n        if char == \"[\" {\n\
    \            found_open_bracket = true\n        }\n        if char == \"]\" {\n\
    \            found_closed_bracket = true\n        }\n    }\n    \n    // Return\
    \ result\n    if found_open_bracket && found_closed_bracket {\n        return\
    \ true\n    } else {\n        return false\n    }", "    let brackets = string.characters.map\
    \ { $0 }\n    var count = 0\n    var max = 0\n    for i in 0..<brackets.count\
    \ {\n        if brackets[i] == \"[\" {\n            count += 1\n        } else\
    \ {\n            count -= 1\n        }\n        if count > max {\n           \
    \ max = count\n        }\n    }\n    return count == 0 && max >= 2", "    var\
    \ string = string\n    var stack = Stack<Character>()\n    var previous: Character\
    \ = \".\"\n    var current: Character\n    for c in string {\n        current\
    \ = c\n        if c == \"[\" {\n            stack.push(c)\n        } else if c\
    \ == \"]\" {\n            if !stack.isEmpty {\n                stack.pop()\n \
    \           } else {\n                return false\n            }\n        }\n\
    \        previous = current\n    }\n    return stack.isEmpty", "    var stack\
    \ = [Character]()\n    for c in string {\n        if c == \"[\" {\n          \
    \  stack.append(c)\n        } else if !stack.isEmpty {\n            stack.removeLast()\n\
    \        } else {\n            return false\n        }\n    }\n    return stack.isEmpty",
  "    var stack = [Character]()\n    for char in string {\n        if char == \"\
    [\" {\n            stack.append(char)\n        } else if char == \"]\" {\n   \
    \         if stack.isEmpty {\n                return false\n            } else\
    \ {\n                stack.removeLast()\n            }\n        }\n    }\n   \
    \ return stack.isEmpty", "    if string.characters.count % 2 != 0 {\n        return\
    \ false\n    }\n    var characters = string.characters\n    var nest = true\n\
    \    while nest {\n        var firstIndex = characters.startIndex\n        var\
    \ lastIndex = characters.endIndex.advancedBy(-1)\n        while firstIndex !=\
    \ lastIndex {\n            let firstChar = characters[firstIndex]\n          \
    \  let lastChar = characters[lastIndex]\n            if firstChar == \"[\" &&\
    \ lastChar == \"]\" {\n                characters.removeAtIndex(firstIndex)\n\
    \                characters.removeAtIndex(lastIndex.predecessor())\n         \
    \       break\n            }\n            firstIndex = firstIndex.successor()\n\
    \            lastIndex = lastIndex.predecessor()\n        }\n        if firstIndex\
    \ == lastIndex {\n            return false\n        }\n        if characters.count\
    \ == 0 {\n            nest = false\n        }\n    }\n    return true", "    var\
    \ count = 0\n    for char in string {\n        switch char {\n        case \"\
    [\":\n            count += 1\n        case \"]\":\n            count -= 1\n  \
    \      default:\n            break\n        }\n        if count < 0 {\n      \
    \      return false\n        }\n    }\n    return count == 0", "    var stack\
    \ = [Character]()\n    for char in string {\n        if char == \"[\" {\n    \
    \        stack.append(char)\n        } else if char == \"]\" {\n            if\
    \ let last = stack.last {\n                if last == \"[\" {\n              \
    \      stack.removeLast()\n                } else {\n                    return\
    \ false\n                }\n            } else {\n                return false\n\
    \            }\n        }\n    }\n    return stack.isEmpty", "    // your code\
    \ here\n    return false", "    let bracketSet = Set(\"[]\")\n    var stringSet\
    \ = Set(string)\n    if stringSet.isSubset(of: bracketSet) {\n        for _ in\
    \ 1...string.count {\n            stringSet.remove(\"[]\")\n            stringSet.remove(\"\
    []\")\n            if stringSet.isEmpty {\n                return true\n     \
    \       }\n        }\n    }\n    return false", '    return false', "    let str\
    \ = Array(string)\n    var leftCount = 0\n    var rightCount = 0\n    var isNested\
    \ = false\n    for char in str {\n        if leftCount == rightCount {\n     \
    \       isNested = false\n        }\n        if char == \"[\" {\n            leftCount\
    \ += 1\n        } else if char == \"]\" {\n            rightCount += 1\n     \
    \   }\n        if leftCount < rightCount {\n            return false\n       \
    \ }\n        if leftCount > rightCount {\n            isNested = true\n      \
    \  }\n    }\n    return isNested", "    let brackets = string.map { String($0)\
    \ }\n    var stack = [String]()\n    for bracket in brackets {\n        if bracket\
    \ == \"[\" {\n            stack.append(bracket)\n        } else {\n          \
    \  if stack.count == 0 {\n                return false\n            } else {\n\
    \                stack.removeLast()\n            }\n        }\n    }\n    return\
    \ stack.count == 0", "    let count_left_bracket = string.reduce(0) {\n      \
    \  let (acc, curr) = ($0, $1)\n        return curr == \"[\" ? acc + 1 : acc\n\
    \    }\n    let count_right_bracket = string.reduce(0) {\n        let (acc, curr)\
    \ = ($0, $1)\n        return curr == \"]\" ? acc + 1 : acc\n    }\n    return\
    \ count_left_bracket == count_right_bracket", "    let brackets = string.split(separator:\
    \ \"[\")\n    var stack = Stack<String>()\n    for i in brackets.indices {\n \
    \       let bracket = brackets[i]\n        if bracket == \"\" {\n            continue\n\
    \        }\n        if bracket.last == \"]\" {\n            stack.pop()\n    \
    \    } else {\n            stack.push(element: bracket)\n        }\n    }\n  \
    \  return stack.isEmpty", '    return true', "  var stack = Stack<Character>()\n\
    \  for char in string {\n    if char == \"[\" {\n      stack.push(char)\n    }\
    \ else if char == \"]\" {\n      if stack.isEmpty {\n        return false\n  \
    \    } else {\n        stack.pop()\n      }\n    }\n  }\n  return stack.isEmpty",
  "    var stack = [Character]()\n    let str = Array(string)\n    for char in str\
    \ {\n        if char == \"[\" {\n            stack.append(char)\n        } else\
    \ if char == \"]\" {\n            guard let lastChar = stack.popLast() else {\n\
    \                return false\n            }\n            if lastChar != \"[\"\
    \ {\n                return false\n            }\n        }\n    }\n    return\
    \ stack.isEmpty", "    var stack: [Character] = []\n    for char in string {\n\
    \        if char == \"[\" {\n            stack.append(char)\n        } else if\
    \ char == \"]\" {\n            if let topChar = stack.last {\n               \
    \ if topChar == \"[\" {\n                    stack.removeLast()\n            \
    \    } else {\n                    stack.append(char)\n                }\n   \
    \         } else {\n                stack.append(char)\n            }\n      \
    \  }\n    }\n    return stack.isEmpty", "    var leftBrackets = 0\n    var isNested\
    \ = false\n    for character in string {\n        switch character {\n       \
    \ case \"[\":\n            leftBrackets += 1\n        case \"]\":\n          \
    \  if leftBrackets == 0 {\n                return false\n            }\n     \
    \       if leftBrackets == 1 {\n                isNested = true\n            }\n\
    \            leftBrackets -= 1\n        default:\n            continue\n     \
    \   }\n    }\n    return isNested", "    var bracketsStack = [Character]()\n \
    \   var firstBracketIndex = 0\n    var lastBracketIndex = 0\n    for i in 0 ..<\
    \ string.count {\n        if string[i] == \"[\" {\n            bracketsStack.append(string[i])\n\
    \            if firstBracketIndex == 0 {\n                firstBracketIndex =\
    \ i\n            }\n        } else if string[i] == \"]\" {\n            if bracketsStack.count\
    \ > 0 {\n                bracketsStack.removeLast()\n            } else {\n  \
    \              firstBracketIndex = 0\n            }\n            lastBracketIndex\
    \ = i\n        }\n    }\n    return firstBracketIndex < lastBracketIndex", " \
    \   let chars = Array(string)\n    var level = 0\n    for char in chars {\n  \
    \      if char == \"[\" {\n            level += 1\n        } else if char == \"\
    ]\" {\n            level -= 1\n        }\n        if level < 0 {\n           \
    \ return false\n        }\n    }\n    return level == 0", "    var stack: [Character]\
    \ = []\n    for c in string {\n        if c == \"[\" {\n            stack.append(c)\n\
    \        } else if c == \"]\" {\n            if stack.isEmpty {\n            \
    \    return false\n            } else {\n                stack.removeLast()\n\
    \            }\n        }\n    }\n    return stack.isEmpty", "    var stack =\
    \ Stack<Character>()\n    var isNested = false\n    for c in string {\n      \
    \  if c == \"[\" {\n            stack.push(c)\n        } else if c == \"]\" {\n\
    \            if stack.empty() {\n                return false\n            } else\
    \ {\n                if stack.pop() == \"[\" {\n                    isNested =\
    \ true\n                }\n            }\n        }\n    }\n    return isNested",
  "    // Implement your function here\n    return false", "    var stack = [Character]()\n\
    \    for character in string {\n        if character == \"[\" {\n            stack.append(character)\n\
    \        } else if character == \"]\" {\n            if stack.isEmpty {\n    \
    \            return false\n            } else {\n                stack.removeLast()\n\
    \            }\n        }\n    }\n    return stack.isEmpty", "    var closureCount\
    \ = 0\n    for char in string {\n        if char == \"[\" {\n            closureCount\
    \ += 1\n        } else if char == \"]\" {\n            closureCount -= 1\n   \
    \     }\n        if closureCount < 0 {\n            return false\n        }\n\
    \    }\n    return closureCount == 0", "    var stack: [Character] = []\n    for\
    \ char in string {\n        if char == \"[\" {\n            stack.append(char)\n\
    \        } else if char == \"]\" {\n            if stack.isEmpty {\n         \
    \       return false\n            } else {\n                stack.removeLast()\n\
    \            }\n        }\n    }\n    return stack.isEmpty", "    let stack =\
    \ Stack<Character>()\n    for c in string {\n        if c == \"[\" {\n       \
    \     stack.push(c)\n        } else if c == \"]\" {\n            if let _ = stack.pop()\
    \ {\n                // Do nothing\n            } else {\n                return\
    \ false\n            }\n        }\n    }\n    return stack.isEmpty()", "    var\
    \ leftBrackets: Int = 0\n    var rightBrackets: Int = 0\n    var hasNestedBrackets:\
    \ Bool = false\n    for bracket in string {\n        if bracket == \"[\" {\n \
    \           leftBrackets += 1\n        } else if bracket == \"]\" {\n        \
    \    rightBrackets += 1\n        }\n        if leftBrackets == rightBrackets +\
    \ 1 {\n            hasNestedBrackets = true\n        }\n    }\n    return leftBrackets\
    \ == rightBrackets && hasNestedBrackets", "    \n    var bracketStack = [String]()\n\
    \    \n    for character in string {\n        switch character {\n        case\
    \ \"[\":\n            bracketStack.append(\"[\")\n        case \"]\":\n      \
    \      if bracketStack.last == \"[\" {\n                bracketStack.removeLast()\n\
    \            } else {\n                bracketStack.append(\"]\")\n          \
    \  }\n        default:\n            break\n        }\n    }\n    \n    if bracketStack.isEmpty\
    \ {\n        return true\n    } else {\n        return false\n    }", "    let\
    \ toArr = Array(string)\n    var stack = Stack<Character>()\n    for char in toArr\
    \ {\n        if char == \"[\" {\n            stack.push(char)\n        } else\
    \ if char == \"]\" {\n            if stack.isEmpty() {\n                return\
    \ false\n            } else {\n                stack.pop()\n            }\n  \
    \      }\n    }\n    return stack.isEmpty()", "    var openBracketsCount = 0\n\
    \    var closedBracketsCount = 0\n    var cannotBeNested = false\n    for s in\
    \ string {\n        if s == \"[\" {\n            openBracketsCount += 1\n    \
    \    } else if s == \"]\" {\n            closedBracketsCount += 1\n        }\n\
    \        if closedBracketsCount > openBracketsCount {\n            cannotBeNested\
    \ = true\n        }\n    }\n    if openBracketsCount == closedBracketsCount &&\
    \ !cannotBeNested {\n        return true\n    }\n    return false", "  var stack\
    \ = Stack<Character>()\n  for c in string {\n    if stack.isEmpty() || c == \"\
    [\" {\n      stack.push(element: c)\n    } else {\n      if let top = stack.pop()\
    \ {\n        if top != \"[\" {\n          return false\n        }\n      }\n \
    \   }\n  }\n  return stack.isEmpty()", "    if string.isEmpty {\n        return\
    \ false\n    }\n    if string.count % 2 != 0 {\n        return false\n    }\n\
    \    var stack = Stack<Character>()\n    for character in string {\n        if\
    \ stack.isEmpty {\n            stack.push(element: character)\n        } else\
    \ {\n            if stack.peek() == character {\n                stack.push(element:\
    \ character)\n            } else {\n                stack.pop()\n            }\n\
    \        }\n    }\n    return stack.isEmpty", "    var openSquareBrackets = 0\n\
    \    var openSquareBracketsRequireClosing = 0\n    for c in string {\n       \
    \ if c == \"[\" {\n            openSquareBrackets += 1\n            openSquareBracketsRequireClosing\
    \ += 1\n        } else if c == \"]\" {\n            if openSquareBracketsRequireClosing\
    \ > 0 {\n                openSquareBracketsRequireClosing -= 1\n            }\
    \ else {\n                return false\n            }\n        }\n    }\n    return\
    \ openSquareBracketsRequireClosing > 0 ? false : true", "    var openingCount\
    \ = 0\n    var closingCount = 0\n    for char in string {\n        if char ==\
    \ \"[\" {\n            openingCount += 1\n        } else if char == \"]\" {\n\
    \            closingCount += 1\n        }\n    }\n    return closingCount < openingCount",
  "    var count = 0\n    for character in string {\n        if character == \"[\"\
    \ {\n            count += 1\n        } else if character == \"]\" {\n        \
    \    count -= 1\n        }\n        if count < 0 {\n            return false\n\
    \        }\n    }\n    return count == 0", "    var stack = [Character]()\n  \
    \  for char in string {\n        if char == \"[\" {\n            stack.append(char)\n\
    \        } else if char == \"]\" {\n            if stack.isEmpty {\n         \
    \       return false\n            } else {\n                stack.removeLast()\n\
    \            }\n        }\n    }\n    return stack.isEmpty", "    // YOUR CODE\
    \ HERE\n    return false", "    var bracketStack = Stack<Character>()\n    var\
    \ seenCorrectBracket = false\n    for bracket in string {\n        if bracket\
    \ == \"[\" {\n            bracketStack.push(bracket)\n        } else if bracket\
    \ == \"]\" {\n            if bracketStack.count == 0 {\n                return\
    \ false\n            } else {\n                if bracketStack.pop() == \"[\"\
    \ {\n                    seenCorrectBracket = true\n                }\n      \
    \      }\n        }\n    }\n    return bracketStack.count == 0 && seenCorrectBracket",
  "    var stack: [Character] = []\n    for char in string {\n        if char == \"\
    [\" {\n            stack.append(char)\n        } else if char == \"]\" {\n   \
    \         if stack.isEmpty {\n                return false\n            } else\
    \ {\n                stack.removeLast()\n            }\n        }\n    }\n   \
    \ return stack.isEmpty", "    var stack = [Character]()\n    var charArray = Array(string)\n\
    \    for char in charArray {\n        if char == \"[\" {\n            stack.append(char)\n\
    \        } else if char == \"]\" {\n            if stack.isEmpty {\n         \
    \       return false\n            } else {\n                stack.removeLast()\n\
    \            }\n        }\n    }\n    return stack.isEmpty", "    var stack: [Character]\
    \ = []\n    let string = Array(string)\n    var matching = true\n    for c in\
    \ string {\n        if stack.isEmpty && c == \"]\" {\n            matching = false\n\
    \            break\n        }\n        if c == \"[\" {\n            stack.append(c)\n\
    \        } else if c == \"]\" {\n            if stack.isEmpty {\n            \
    \    matching = false\n                break\n            }\n            stack.removeLast()\n\
    \        }\n    }\n    if !stack.isEmpty {\n        matching = false\n    }\n\
    \    return matching", "    var stack: [Character] = []\n    for c in string {\n\
    \        if c == \"[\" {\n            stack.append(c)\n        } else if c ==\
    \ \"]\" {\n            if stack.isEmpty {\n                return false\n    \
    \        } else {\n                stack.removeLast()\n            }\n       \
    \ }\n    }\n    return stack.isEmpty", "    var isNested = false\n    var stack\
    \ = Stack<Character>()\n    for char in string {\n        if stack.count > 0 {\n\
    \            if char == \"]\" {\n                if stack.peek() == \"[\" {\n\
    \                    stack.pop()\n                    isNested = true\n      \
    \          } else {\n                    stack.push(char)\n                }\n\
    \            } else {\n                stack.push(char)\n            }\n     \
    \   } else {\n            stack.push(char)\n        }\n    }\n    return isNested",
  "    var stack = Stack<Character>()\n    var invalid = false\n    for c in string\
    \ {\n        if c == \"[\" {\n            stack.push(element: c)\n        } else\
    \ if c == \"]\" {\n            if stack.isEmpty() {\n                invalid =\
    \ true\n            } else {\n                stack.pop()\n            }\n   \
    \     }\n    }\n    return !invalid && stack.isEmpty()", "    var count = 0\n\
    \    for char in string {\n        if char == \"[\" {\n            count += 1\n\
    \        } else if char == \"]\" {\n            count -= 1\n        }\n      \
    \  if count < 0 {\n            return false\n        }\n    }\n    return count\
    \ == 0", "    let stringArray = Array(string)\n    var stack = [Character]()\n\
    \    for i in 0..<stringArray.count {\n        let char = stringArray[i]\n   \
    \     if char == \"[\" {\n            stack.append(char)\n        } else if char\
    \ == \"]\" {\n            if stack.count == 0 {\n                return false\n\
    \            } else {\n                stack.removeLast()\n            }\n   \
    \     }\n    }\n    return stack.count == 0", "    if string.count == 0 {\n  \
    \      return false\n    }\n    var stack = Stack<Character>()\n    for character\
    \ in string {\n        if character == \"[\" {\n            stack.push(character)\n\
    \        } else if character == \"]\" {\n            if let topElement = stack.peek()\
    \ {\n                if topElement == \"[\" {\n                    stack.pop()\n\
    \                } else {\n                    stack.push(character)\n       \
    \         }\n            } else {\n                stack.push(character)\n   \
    \         }\n        }\n    }\n    return stack.isEmpty", "    var stack: [Character]\
    \ = []\n    for char in string {\n        if stack.count == 0 {\n            stack.append(char)\n\
    \        } else {\n            if char == \"[\" {\n                stack.append(char)\n\
    \            } else {\n                if stack.last == \"[\" {\n            \
    \        stack.removeLast()\n                } else {\n                    stack.append(char)\n\
    \                }\n            }\n        }\n    }\n    return stack.count ==\
    \ 0", "    var stack = [String]()\n    var index = 0\n    while index < string.count\
    \ {\n        let element = string[index]\n        if element == \"[\" {\n    \
    \        stack.append(element)\n        } else {\n            if stack.isEmpty\
    \ {\n                return false\n            }\n            stack.removeLast()\n\
    \        }\n        index += 1\n    }\n    return stack.isEmpty", "    var count\
    \ = 0\n    for bracket in string {\n        if bracket == \"[\" {\n          \
    \  count += 1\n        } else if bracket == \"]\" {\n            count -= 1\n\
    \        }\n        if count < 0 {\n            return false\n        }\n    }\n\
    \    return count == 0", "    let string = string.filter{$0 == \"[\" || $0 ==\
    \ \"]\"}\n    guard string.count % 2 == 0 else { return false }\n    var count\
    \ = 0\n    for char in string {\n        if char == \"[\" {\n            count\
    \ += 1\n        } else {\n            count -= 1\n        }\n        if count\
    \ < 0 {\n            return false\n        }\n    }\n    return count == 0", '    return
    false', '    return false', "    var count = 0\n    var isNested = false\n   \
    \ for char in string {\n        if char == \"[\" {\n            count += 1\n \
    \       } else if char == \"]\" {\n            count -= 1\n        }\n       \
    \ if count == -1 {\n            return false\n        }\n        if count == 0\
    \ {\n            isNested = true\n        }\n    }\n    return isNested", "  \
    \  var nested = true\n    var string = string\n    while nested {\n        if\
    \ string.contains(\"[[\") || string.contains(\"]]\") {\n            string = string.replacingOccurrences(of:\
    \ \"[[\", with: \"\")\n            string = string.replacingOccurrences(of: \"\
    ]]\", with: \"\")\n        } else {\n            nested = false\n        }\n \
    \   }\n    return string.isEmpty", "    let length = string.count\n    guard length\
    \ > 0 else { return false }\n    var stack = Stack<Character>()\n    var index\
    \ = 0\n    for char in string {\n        if char == \"[\" {\n            stack.push(element:\
    \ char)\n        } else if !stack.isEmpty() {\n            stack.pop()\n     \
    \   } else {\n            return false\n        }\n        index += 1\n    }\n\
    \    return stack.isEmpty()", "    var storage = [Character]()\n    var count\
    \ = 0\n    for ch in string {\n        switch ch {\n        case \"[\":\n    \
    \        storage.append(ch)\n        case \"]\":\n            count += 1\n   \
    \         if !storage.isEmpty {\n                storage.removeLast()\n      \
    \      }\n        default:\n            break\n        }\n    }\n    return count\
    \ > 0 && storage.isEmpty", "    var stack: [Character] = []\n    for character\
    \ in string {\n        if character == \"[\" {\n            stack.append(character)\n\
    \        } else if character == \"]\" {\n            if let last = stack.last\
    \ {\n                if last == \"[\" {\n                    stack.removeLast()\n\
    \                } else {\n                    return false\n                }\n\
    \            } else {\n                return false\n            }\n        }\n\
    \    }\n    return stack.isEmpty", "    \n    var brackets = [Character]()\n \
    \   \n    for bracket in string {\n        if bracket == \"[\" {\n           \
    \ brackets.append(bracket)\n        } else if bracket == \"]\" {\n           \
    \ if brackets.count == 0 {\n                return false\n            } else {\n\
    \                brackets.removeLast()\n            }\n        }\n    }\n    \n\
    \    return brackets.count == 0", '    return false', "    var string = string\n\
    \    var bracketStack = Stack<Character>()\n    for character in string {\n  \
    \      if character == \"[\" {\n            bracketStack.push(item: character)\n\
    \        } else if character == \"]\" {\n            if bracketStack.isEmpty()\
    \ {\n                return false\n            } else {\n                bracketStack.pop()\n\
    \            }\n        }\n    }\n    return bracketStack.isEmpty()", "    guard\
    \ !string.isEmpty else { return false }\n    guard string.filter({$0 == \"[\"\
    }).count == string.filter({$0 == \"]\"}).count else { return false }\n    if string.contains(\"\
    ][\") { return false }\n    var cur = 0\n    var result = true\n    for (i, c)\
    \ in string.enumerated() {\n        if c == \"[\" {\n            cur += 1\n  \
    \      } else {\n            cur -= 1\n        }\n        if cur < 0 { return\
    \ false }\n        result = result && cur > 0\n    }\n    return result", "  \
    \  var stack: [Character] = []\n    for letter in string {\n        if letter\
    \ == \"[\" {\n            stack.append(letter)\n        } else if letter == \"\
    ]\" {\n            if let last = stack.last {\n                if last == \"[\"\
    \ {\n                    stack.removeLast()\n                } else {\n      \
    \              return false\n                }\n            } else {\n       \
    \         return false\n            }\n        }\n    }\n    return stack.isEmpty",
  "    let arr = string.split(separator: \"[\")\n    \n    if arr.count == 0 {\n \
    \       return false\n    }\n    \n    for i in 0..<arr.count {\n        let nested\
    \ = arr[i].split(separator: \"]\")\n        if nested.count > 1 {\n          \
    \  return true\n        }\n    }\n    \n    return false", "    var stack = Stack<Character>()\n\
    \    for char in string {\n        if char == \"[\" {\n            stack.push(char)\n\
    \        } else if char == \"]\" {\n            if stack.isEmpty {\n         \
    \       return false\n            } else {\n                stack.pop()\n    \
    \        }\n        }\n    }\n    return stack.isEmpty", "    var count = 0\n\
    \    for char in string {\n        if char == \"[\" {\n            count += 1\n\
    \        } else if char == \"]\" {\n            count -= 1\n        }\n      \
    \  if count < 0 {\n            return false\n        }\n    }\n    return count\
    \ == 0", '    return nil', "    var stack = Stack<Character>()\n    for bracket\
    \ in string {\n        if bracket == \"[\" {\n            stack.push(item: bracket)\n\
    \        } else if bracket == \"]\" {\n            if stack.peek() == \"[\" {\n\
    \                stack.pop()\n            } else {\n                return false\n\
    \            }\n        }\n    }\n    return stack.isEmpty()", "  var stack =\
    \ Array<Character>()\n  for char in string {\n    if char == \"[\" {\n      stack.append(char)\n\
    \    } else if char == \"]\" {\n      if stack.isEmpty {\n        return false\n\
    \      } else {\n        stack.removeLast()\n      }\n    }\n  }\n  return stack.isEmpty",
  "  let opening: Character = \"[\"\n  let closing: Character = \"]\"\n  var stack:\
    \ [Character] = []\n  for char in string {\n    if char == opening {\n      stack.append(char)\n\
    \    } else if char == closing {\n      if stack.last == opening {\n        stack.removeLast()\n\
    \      } else {\n        return false\n      }\n    }\n  }\n  return true", " \
    \   var dict: [Character: Int] = [:]\n    for char in string {\n        dict[char]\
    \ = (dict[char] ?? 0) + 1\n    }\n    if dict[\"[\"] == dict[\"]\"] {\n      \
    \  return false\n    }\n    return true", "    let stack = Stack<Character>()\n\
    \    for ch in string {\n        if ch == \"[\" {\n            stack.push(ch)\n\
    \        } else if ch == \"]\" {\n            if stack.isEmpty {\n           \
    \     return false\n            } else {\n                stack.pop()\n      \
    \      }\n        }\n    }\n    return stack.isEmpty", "    if string.count ==\
    \ 0 {\n        return false\n    }\n    if string.count == 1 {\n        return\
    \ false\n    }\n    if string.count == 2 {\n        return string.prefix(1) ==\
    \ \"[\" && string.suffix(1) == \"]\"\n    }\n    var minimum_length = string.count\n\
    \    for index in 0..<string.count {\n        var temp_string = string\n     \
    \   temp_string.remove(at: temp_string.index(temp_string.startIndex, offsetBy:\
    \ index))\n        if is_nested(string: temp_string) {\n            return true\n\
    \        }\n        if temp_string.count < minimum_length {\n            minimum_length\
    \ = temp_string.count\n        }\n    }\n    return false", "    var arr = [Character]()\n\
    \    for character in string {\n        if character == \"[\" {\n            arr.append(character)\n\
    \        } else if character == \"]\" {\n            if arr.count == 0 {\n   \
    \             return false\n            } else {\n                arr.removeLast()\n\
    \            }\n        }\n    }\n    return arr.count == 0", "    var depth =\
    \ 0\n    for character in string {\n        if character == \"[\" {\n        \
    \    depth += 1\n        } else if character == \"]\" {\n            depth -=\
    \ 1\n        }\n        if depth < 0 {\n            return false\n        }\n\
    \    }\n    return depth == 0", '    return false', "    var previous: String?\n\
    \    var count = 0\n    for char in string {\n        let character = String(char)\n\
    \        if character == \"[\" {\n            count += 1\n        } else if character\
    \ == \"]\" {\n            count -= 1\n        }\n        if count < 0 {\n    \
    \        return false\n        }\n        if let p = previous {\n            if\
    \ p == \"[\" && character == \"]\" {\n                previous = nil\n       \
    \     } else {\n                previous = character\n            }\n        }\
    \ else {\n            previous = character\n        }\n    }\n    return previous\
    \ == nil", "    var stack: [Character] = []\n    for char in string {\n      \
    \  if char == \"[\" {\n            stack.append(char)\n        } else if char\
    \ == \"]\" {\n            if stack.isEmpty {\n                return false\n \
    \           } else {\n                stack.removeLast()\n            }\n    \
    \    }\n    }\n    return stack.isEmpty", "    var stack = [Character]()\n   \
    \ for c in string {\n        if stack.isEmpty {\n            stack.append(c)\n\
    \        } else {\n            if stack.last == \"[\" && c == \"]\" {\n      \
    \          stack.removeLast()\n            } else {\n                stack.append(c)\n\
    \            }\n        }\n    }\n    return stack.isEmpty", "    var stack =\
    \ [String]()\n    for c in string {\n        if c == \"[\" {\n            stack.append(\"\
    [\")\n        } else if c == \"]\" {\n            if stack.last == \"[\" {\n \
    \               stack.removeLast()\n            } else {\n                return\
    \ false\n            }\n        }\n    }\n    return stack.isEmpty", "    \n \
    \   func isClosingBracket(_ bracket: Character) -> Bool {\n        return bracket\
    \ == \"]\"\n    }\n    \n    func isOpeningBracket(_ bracket: Character) -> Bool\
    \ {\n        return bracket == \"[\"\n    }\n    \n    // If a string is empty\
    \ it is not a bracket sequence\n    guard !string.isEmpty else {\n        return\
    \ false\n    }\n    \n    // If a string only contains one bracket, it is not\
    \ a bracket sequence\n    guard string.count > 1 else {\n        return false\n\
    \    }\n    \n    // Filter by closing brackets\n    let closingBrackets = string.filter\
    \ { isClosingBracket($0) }\n    \n    // If a string only contains one closing\
    \ bracket, it is not a bracket sequence\n    guard closingBrackets.count > 1 else\
    \ {\n        return false\n    }\n    \n    // Filter by opening brackets\n  \
    \  let openingBrackets = string.filter { isOpeningBracket($0) }\n    \n    //\
    \ If a string only contains one opening bracket, it is not a bracket sequence\n\
    \    guard openingBrackets.count > 1 else {\n        return false\n    }\n   \
    \ \n    // Is the number of opening and closing brackets the same?\n    guard\
    \ openingBrackets.count == closingBrackets.count else {\n        return false\n\
    \    }\n    \n    // If the first bracket is a closing bracket, the bracket sequence\
    \ is invalid\n    guard isOpeningBracket(string.first!) else {\n        return\
    \ false\n    }\n    \n    // If the last bracket is an opening bracket, the bracket\
    \ sequence is invalid\n    guard isClosingBracket(string.last!) else {\n     \
    \   return false\n    }\n    \n    return true", '    return false', "    var\
    \ left = 0\n    var right = 0\n    for char in string {\n        if char == \"\
    [\" {\n            left += 1\n        } else if char == \"]\" {\n            right\
    \ += 1\n        }\n        if right > left {\n            return false\n     \
    \   }\n    }\n    return left == right && left != 0", "    var stack: [Character]\
    \ = []\n    var isNested = false\n    for character in string {\n        switch\
    \ character {\n        case \"[\":\n            stack.append(character)\n    \
    \    case \"]\":\n            if stack.isEmpty || stack.last! != \"[\" {\n   \
    \             return false\n            }\n            stack.removeLast()\n  \
    \          if !stack.isEmpty {\n                isNested = true\n            }\n\
    \        default:\n            return false\n        }\n    }\n    return stack.isEmpty\
    \ && isNested", "    \n    let openBrackets = string.filter({ $0 == \"[\" })\n\
    \    let closeBrackets = string.filter({ $0 == \"]\" })\n    \n    if openBrackets.count\
    \ == closeBrackets.count {\n        return false\n    }\n    \n    var currentOpenBrackets\
    \ = 0\n    var currentCloseBrackets = 0\n    \n    for char in string {\n    \
    \    if char == \"[\" {\n            currentOpenBrackets += 1\n        } else\
    \ if char == \"]\" {\n            currentCloseBrackets += 1\n        }\n     \
    \   \n        if currentCloseBrackets > currentOpenBrackets {\n            return\
    \ false\n        }\n    }\n    \n    return true", "    var valid_nested_string\
    \ = false\n    var stack = Stack<Character>()\n    for c in string {\n       \
    \ switch c {\n        case \"[\":\n            stack.push(item: c)\n        case\
    \ \"]\":\n            if stack.peek() == \"[\" {\n                valid_nested_string\
    \ = true\n            }\n            stack.pop()\n        default:\n         \
    \   print(\"Unexpected character!\")\n        }\n    }\n    return valid_nested_string",
  '    return false', "    var stack = [Character]()\n    for char in string {\n \
    \       if char == \"[\" {\n            stack.append(char)\n        } else if\
    \ stack.count > 0 {\n            stack.removeLast()\n        } else {\n      \
    \      return false\n        }\n    }\n    return stack.count == 0", "    // 1.\n\
    \    var new_string = string\n    for i in 0...new_string.count - 1 {\n      \
    \  if i < new_string.count - 1 {\n            let index_first = new_string.index(new_string.startIndex,\
    \ offsetBy: i)\n            let index_second = new_string.index(new_string.startIndex,\
    \ offsetBy: i + 1)\n            if new_string[index_first] == \"[\" && new_string[index_second]\
    \ == \"]\" {\n                new_string.remove(at: index_first)\n           \
    \     new_string.remove(at: index_second)\n                i -= 2\n          \
    \  }\n        }\n    }\n    // 2.\n    if new_string.count == 0 {\n        return\
    \ true\n    }\n    return false", "    let pairs = string.reduce(into: []) { (result,\
    \ char) in\n        if char == \"[\" {\n            result.append(char)\n    \
    \    } else if let last = result.last, last == \"[\" {\n            result.removeLast()\n\
    \        } else {\n            result.append(char)\n        }\n    }\n    return\
    \ pairs.isEmpty", "    let stack = Stack<Character>()\n    var is_nested = false\n\
    \    for char in string {\n        if char == \"[\" {\n            stack.push(char)\n\
    \        } else if char == \"]\" {\n            if stack.pop() == \"[\" {\n  \
    \              is_nested = true\n            }\n        }\n    }\n    return is_nested",
  '    return true', "    // Write your code here\n    var stack = [Character]()\n\
    \    var brackets: [Character] = [\"[\", \"]\"]\n    for char in string {\n  \
    \      if char == brackets[0] {\n            stack.append(char)\n        } else\
    \ if !stack.isEmpty && char == brackets[1] {\n            stack.removeLast()\n\
    \        } else {\n            return false\n        }\n    }\n    return stack.isEmpty",
  '    return false', "    // TODO\n    return false", "    let brackets = string.filter\
    \ { $0 == \"[\" || $0 == \"]\" }\n    var max_length = 0\n    var current_length\
    \ = 0\n    var depth = 0\n    for bracket in brackets {\n        if bracket ==\
    \ \"[\" {\n            depth += 1\n            current_length += 1\n        }\
    \ else {\n            depth -= 1\n            if depth < 0 {\n               \
    \ current_length = 0\n                depth = 0\n            } else {\n      \
    \          current_length += 1\n            }\n        }\n        max_length =\
    \ max(max_length, current_length)\n    }\n    return max_length >= 2", "    var\
    \ buffer: [Character] = []\n    var bracketCount = 0\n    var lastBracket: Character?\n\
    \    for char in string {\n        if char == \"]\" {\n            bracketCount\
    \ += 1\n            lastBracket = char\n        } else if char == \"[\" {\n  \
    \          bracketCount -= 1\n            lastBracket = char\n        }\n    \
    \    \n        if (bracketCount < 0) {\n            return false\n        }\n\
    \    }\n    \n    if (bracketCount != 0) {\n        return false\n    }\n    \n\
    \    return true", "    \n    if string.count == 0 {\n        return false\n \
    \   }\n    \n    // Stack to store the brackets\n    var stack = [Character]()\n\
    \    \n    for char in string {\n        // Push if it is an opening bracket\n\
    \        if char == \"[\" {\n            stack.append(char)\n        }\n     \
    \   // Pop if it is an closing bracket\n        else if char == \"]\" {\n    \
    \        // If stack is empty, string is not valid\n            if stack.count\
    \ == 0 {\n                return false\n            }\n            else {\n  \
    \              stack.removeLast()\n            }\n        }\n    }\n    \n   \
    \ // Return true if stack is empty, false otherwise\n    return stack.count ==\
    \ 0", "    var stack = Stack<String>()\n    for char in string {\n        let\
    \ charString = String(char)\n        if charString == \"[\" {\n            stack.push(item:\
    \ charString)\n        } else if charString == \"]\" {\n            if let top\
    \ = stack.top() {\n                if top == \"[\" {\n                    stack.pop()\n\
    \                } else {\n                    return false\n                }\n\
    \            } else {\n                return false\n            }\n        }\n\
    \    }\n    return stack.isEmpty()", "    var stack = [Character]()\n    for char\
    \ in string {\n        if char == \"[\" {\n            stack.append(char)\n  \
    \      } else if char == \"]\" {\n            if stack.isEmpty {\n           \
    \     return false\n            } else {\n                stack.removeLast()\n\
    \            }\n        }\n    }\n    return stack.isEmpty", '    return false',
  '    return string.nested()', "    \n    var stringArray = Array(string)\n    var\
    \ check = [String]()\n    \n    for index in 0..<stringArray.count {\n       \
    \ if stringArray[index] == \"[\" {\n            check.append(\"[\")\n        }\
    \ else if stringArray[index] == \"]\" {\n            if check.count > 0 {\n  \
    \              check.removeLast()\n            } else {\n                return\
    \ false\n            }\n        }\n    }\n    \n    if check.count > 0 {\n   \
    \     return false\n    } else {\n        return true\n    }", '    return true',
  "    var stack = [Character]()\n    for s in string {\n        if (s == \"[\") {\n\
    \            stack.append(s)\n        } else if (s == \"]\") {\n            if\
    \ (stack.count > 0) {\n                stack.removeLast()\n            } else\
    \ {\n                return false\n            }\n        }\n    }\n    return\
    \ stack.count == 0", '    return true', "  // TODO: Implement function here\n\
    \  return false", "    let chars = string.map {String($0)}\n    var stack = Stack<String>()\n\
    \    if chars.count % 2 != 0 {\n        return false\n    }\n    for char in chars\
    \ {\n        if char == \"[\" {\n            stack.push(char)\n        } else\
    \ {\n            if stack.isEmpty() {\n                return false\n        \
    \    } else {\n                _ = stack.pop()\n            }\n        }\n   \
    \ }\n    return stack.isEmpty()", "    var left_count = 0\n    var right_count\
    \ = 0\n    for char in string {\n        if char == \"[\" {\n            left_count\
    \ += 1\n        } else if char == \"]\" {\n            right_count += 1\n    \
    \    }\n        if right_count > left_count {\n            return false\n    \
    \    }\n    }\n    return left_count > right_count", "    var chars = [Character]()\n\
    \    var depth = 0\n    for char in string {\n        if char == \"[\" {\n   \
    \         depth += 1\n        } else if char == \"]\" {\n            depth -=\
    \ 1\n        }\n        if depth < 0 {\n            return false\n        }\n\
    \        chars.append(char)\n    }\n    var nestedCount = 0\n    for i in 0..<chars.count\
    \ {\n        let char = chars[i]\n        if char == \"[\" {\n            for\
    \ j in i+1..<chars.count {\n                if chars[j] == \"]\" {\n         \
    \           nestedCount += 1\n                    break\n                }\n \
    \           }\n        }\n    }\n    return nestedCount > 0", "    var counter\
    \ = 0\n    for char in string {\n        if char == \"[\" {\n            counter\
    \ += 1\n        } else if char == \"]\" {\n            counter -= 1\n        }\n\
    \        if counter < 0 {\n            return false\n        }\n    }\n    return\
    \ counter == 0", "    var stack = Stack<Character>()\n    for char in string {\n\
    \        if char == \"[\" {\n            stack.push(item: char)\n        } else\
    \ if char == \"]\" {\n            if stack.isEmpty() {\n                return\
    \ false\n            } else {\n                stack.pop()\n            }\n  \
    \      }\n    }\n    return stack.isEmpty()", "    var stack = Stack<Character>()\n\
    \    for ch in string {\n        if ch == \"[\" {\n            stack.push(ch)\n\
    \        } else if ch == \"]\" {\n            if stack.isEmpty() {\n         \
    \       return false\n            } else {\n                let _ = stack.pop()\n\
    \            }\n        }\n    }\n    return stack.isEmpty()", "    \n    var\
    \ nested = true\n    var counts = 0\n    \n    for char in string {\n        switch\
    \ char {\n        case \"[\":\n            counts += 1\n        case \"]\":\n\
    \            counts -= 1\n        default:\n            fatalError(\"Not a valid\
    \ bracket\")\n        }\n        \n        if counts < 0 {\n            nested\
    \ = false\n        }\n    }\n    \n    if counts != 0 {\n        nested = false\n\
    \    }\n    \n    return nested", "    \n    let closingBrackets: [Character]\
    \ = [\"}\", \"]\", \")\"]\n    let mapping: [Character: Character] = [\"]\": \"\
    [\", \"}\": \"{\", \")\": \"(\"]\n    var stack: [Character] = []\n    \n    for\
    \ char in string {\n        if closingBrackets.contains(char) {\n            if\
    \ stack.last == mapping[char] {\n                stack.removeLast()\n        \
    \    } else {\n                return false\n            }\n        } else {\n\
    \            stack.append(char)\n        }\n    }\n    \n    return stack.isEmpty",
  "    var brackets = Stack<Character>()\n    for char in string {\n        if char\
    \ == \"[\" {\n            brackets.push(char)\n        } else if char == \"]\"\
    \ {\n            if brackets.isEmpty {\n                return false\n       \
    \     } else {\n                brackets.pop()\n            }\n        }\n   \
    \ }\n    return brackets.isEmpty", '    return false', "    return string.trimmingCharacters(in:\
    \ .whitespaces).reduce(into: (first: [Character](), second: [Character]())) {\
    \ (result, char) in\n        if char == \"[\" {\n            result.first.append(char)\n\
    \        } else {\n            if let last = result.first.last {\n           \
    \     if last == \"[\" {\n                    result.first.removeLast()\n    \
    \            } else {\n                    result.second.append(char)\n      \
    \          }\n            } else {\n                result.second.append(char)\n\
    \            }\n        }\n    }.first.isEmpty && !string.hasPrefix(\"]\")", " \
    \ var openBrackets = 0\n  var closeBrackets = 0\n  var hasOpen = false\n  var\
    \ hasClose = false\n  var nested = false\n  for c in string {\n    if c == \"\
    [\" {\n      openBrackets += 1\n      hasOpen = true\n    } else if c == \"]\"\
    \ {\n      closeBrackets += 1\n      hasClose = true\n    }\n    if hasOpen &&\
    \ hasClose {\n      nested = true\n    }\n  }\n  return nested && (openBrackets\
    \ == closeBrackets)", "    var stack = [Character]()\n    for char in string {\n\
    \        if stack.isEmpty || char == \"[\" {\n            stack.append(char)\n\
    \        } else {\n            stack.removeLast()\n        }\n    }\n    return\
    \ stack.isEmpty", "    var stack = [Character]()\n    for char in string {\n \
    \       if char == \"[\" {\n            stack.append(char)\n        } else if\
    \ !stack.isEmpty {\n            stack.removeLast()\n        } else {\n       \
    \     return false\n        }\n    }\n    return stack.isEmpty", "    let reversed\
    \ = string.reversed()\n    var brackets = [[Character]]()\n    for char in reversed\
    \ {\n        if let sub = brackets.last, sub.count == 1, sub.last! == char {\n\
    \            brackets.removeLast()\n        } else {\n            brackets.append([char])\n\
    \        }\n    }\n    return brackets.count == 0", "    var nested = false\n\
    \    let startingCount = string.filter { $0 == \"[\" }.count\n    let endingCount\
    \ = string.filter { $0 == \"]\" }.count\n    let numbers = [startingCount, endingCount]\n\
    \    let maxNumber = numbers.max()\n    if startingCount == endingCount && startingCount\
    \ != 0 {\n        nested = true\n    } else if endingCount < startingCount &&\
    \ startingCount != 0 {\n        nested = true\n    } else if endingCount > startingCount\
    \ && endingCount != 0 {\n        nested = true\n    }\n    if startingCount ==\
    \ endingCount && startingCount == 0 {\n        nested = false\n    }\n    return\
    \ nested", "    let input = string.filter { $0 == \"[\" || $0 == \"]\" }\n   \
    \ guard input.count > 1 else { return false }\n    var stack = [Character]()\n\
    \    for char in input {\n        if char == \"[\" {\n            stack.append(char)\n\
    \        } else {\n            if let last = stack.last, last == \"[\" {\n   \
    \             stack.removeLast()\n            } else {\n                return\
    \ false\n            }\n        }\n    }\n    return stack.isEmpty", "    // implement\
    \ your code here\n    return false", "    var bStack = [Character]()\n    for\
    \ c in string {\n        if c == \"[\" {\n            bStack.append(c)\n     \
    \   } else if c == \"]\" {\n            if bStack.count == 0 {\n             \
    \   return false\n            } else {\n                bStack.removeLast()\n\
    \            }\n        }\n    }\n    return bStack.count == 0", "    var stack:\
    \ [Character] = []\n    for char in string {\n        if char == \"[\" {\n   \
    \         stack.append(char)\n        } else if char == \"]\" {\n            if\
    \ stack.isEmpty {\n                return false\n            } else {\n      \
    \          if stack.last! == \"[\" {\n                    stack.removeLast()\n\
    \                } else {\n                    return false\n                }\n\
    \            }\n        }\n    }\n    return stack.isEmpty", "    // create empty\
    \ stack\n    var stack = Stack<Character>()\n    // for each character in string\n\
    \    for character in string {\n        // if character is an opening bracket\n\
    \        if character == \"[\" {\n            // push it onto the stack\n    \
    \        stack.push(character)\n        }\n        // else\n        else {\n \
    \           // pop bracket off of stack\n            // return false if no brackets\
    \ are on stack\n            guard let bracket = stack.pop() else { return false\
    \ }\n            // return false if bracket is not a closing bracket\n       \
    \     if bracket != \"[\" { return false }\n        }\n    }\n    // return true\
    \ if stack is empty\n    // return false if stack has brackets on it\n    return\
    \ stack.isEmpty", '    return false', "    var string = string\n    while string.count\
    \ > 1 {\n        string = string.replacingOccurrences(of: \"[]\", with: \"\")\n\
    \    }\n    return string == \"\"", "    var stack = [Character]()\n    for char\
    \ in string {\n        if char == \"[\" {\n            stack.append(char)\n  \
    \      } else if char == \"]\" {\n            if stack.isEmpty {\n           \
    \     return false\n            } else {\n                stack.removeLast()\n\
    \            }\n        }\n    }\n    return stack.isEmpty"]
stop_tokens:
- "\n}"
