language: swift
name: HumanEval_158_find_max
results:
- exit_code: -4
  program: "\n/// Write a function that accepts an array of strings.\n/// The array\
    \ contains different words. Return the word with maximum number\n/// of unique\
    \ characters. If multiple strings have maximum number of unique\n/// characters,\
    \ return the one which comes first in lexicographical order.\n/// >>> find_max(words:\
    \ [\"name\", \"of\", \"string\"])\n/// \"string\"\n/// >>> find_max(words: [\"\
    name\", \"enam\", \"game\"])\n/// \"enam\"\n/// >>> find_max(words: [\"aaaaaaa\"\
    , \"bb\", \"cc\"])\n/// \"aaaaaaa\"\nfunc find_max(words: [String]) -> String\
    \ {\n    var max_word = \"\"\n    var max_chars = 0\n    for w in words {\n  \
    \      let uniques = Set(w)\n        if uniques.count > max_chars {\n        \
    \    max_chars = uniques.count\n            max_word = w\n        }\n    }\n \
    \   return max_word\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) ->\
    \ Bool {\n    if left.count != right.count {\n        return false\n    }\n  \
    \  for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(find_max(words: [\"\
    name\", \"of\", \"string\"]) == \"string\")\nassert(find_max(words: [\"name\"\
    , \"enam\", \"game\"]) == \"enam\")\nassert(find_max(words: [\"aaaaaaa\", \"bb\"\
    , \"cc\"]) == \"aaaaaaa\")\nassert(find_max(words: [\"abc\", \"cba\"]) == \"abc\"\
    )\nassert(find_max(words: [\"play\", \"this\", \"game\", \"of\", \"footbott\"\
    ]) == \"footbott\")\nassert(find_max(words: [\"we\", \"are\", \"gonna\", \"rock\"\
    ]) == \"gonna\")\nassert(find_max(words: [\"we\", \"are\", \"a\", \"mad\", \"\
    nation\"]) == \"nation\")\nassert(find_max(words: [\"this\", \"is\", \"a\", \"\
    prrk\"]) == \"this\")\nassert(find_max(words: [\"b\"]) == \"b\")\nassert(find_max(words:\
    \ [\"play\", \"play\", \"play\"]) == \"play\")"
  status: Exception
  stderr: 'tmp1yaidx9c/tmp1yaidx9c.swift:39: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002ac00b41ac80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002ac00b111b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002ac00b111988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002ac00b1107b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmp1yaidx9c                        0x000055f7d133b933 <unavailable> + 6451

    5    libc.so.6                          0x00002ac00b606460 __libc_start_main +
    245

    6    tmp1yaidx9c                        0x000055f7d133b359 <unavailable> + 4953

    '
  stdout: ''
  timestamp: 1660013455
- exit_code: 0
  program: "\n/// Write a function that accepts an array of strings.\n/// The array\
    \ contains different words. Return the word with maximum number\n/// of unique\
    \ characters. If multiple strings have maximum number of unique\n/// characters,\
    \ return the one which comes first in lexicographical order.\n/// >>> find_max(words:\
    \ [\"name\", \"of\", \"string\"])\n/// \"string\"\n/// >>> find_max(words: [\"\
    name\", \"enam\", \"game\"])\n/// \"enam\"\n/// >>> find_max(words: [\"aaaaaaa\"\
    , \"bb\", \"cc\"])\n/// \"aaaaaaa\"\nfunc find_max(words: [String]) -> String\
    \ {\n    var uniqueChars = [Character]()\n    var uniqueCharsCount = 0\n    var\
    \ answer = \"\"\n    for word in words {\n        uniqueChars = [Character]()\n\
    \        uniqueCharsCount = 0\n        for char in word {\n            if !uniqueChars.contains(char)\
    \ {\n                uniqueChars.append(char)\n                uniqueCharsCount\
    \ += 1\n            }\n        }\n        if answer == \"\" {\n            answer\
    \ = word\n        } else if uniqueCharsCount > (answer.count - answer.filter{$0\
    \ == \" \"}.count) {\n            answer = word\n        } else if uniqueCharsCount\
    \ == (answer.count - answer.filter{$0 == \" \"}.count) && word < answer {\n  \
    \          answer = word\n        }\n    }\n    return answer\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(find_max(words: [\"name\", \"of\", \"string\"]) == \"\
    string\")\nassert(find_max(words: [\"name\", \"enam\", \"game\"]) == \"enam\"\
    )\nassert(find_max(words: [\"aaaaaaa\", \"bb\", \"cc\"]) == \"aaaaaaa\")\nassert(find_max(words:\
    \ [\"abc\", \"cba\"]) == \"abc\")\nassert(find_max(words: [\"play\", \"this\"\
    , \"game\", \"of\", \"footbott\"]) == \"footbott\")\nassert(find_max(words: [\"\
    we\", \"are\", \"gonna\", \"rock\"]) == \"gonna\")\nassert(find_max(words: [\"\
    we\", \"are\", \"a\", \"mad\", \"nation\"]) == \"nation\")\nassert(find_max(words:\
    \ [\"this\", \"is\", \"a\", \"prrk\"]) == \"this\")\nassert(find_max(words: [\"\
    b\"]) == \"b\")\nassert(find_max(words: [\"play\", \"play\", \"play\"]) == \"\
    play\")"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660013455
- exit_code: -4
  program: "\n/// Write a function that accepts an array of strings.\n/// The array\
    \ contains different words. Return the word with maximum number\n/// of unique\
    \ characters. If multiple strings have maximum number of unique\n/// characters,\
    \ return the one which comes first in lexicographical order.\n/// >>> find_max(words:\
    \ [\"name\", \"of\", \"string\"])\n/// \"string\"\n/// >>> find_max(words: [\"\
    name\", \"enam\", \"game\"])\n/// \"enam\"\n/// >>> find_max(words: [\"aaaaaaa\"\
    , \"bb\", \"cc\"])\n/// \"aaaaaaa\"\nfunc find_max(words: [String]) -> String\
    \ {\n    var max = 0\n    var maxStr = \"\"\n    for word in words {\n       \
    \ let set = Set(word)\n        if set.count > max {\n            max = set.count\n\
    \            maxStr = word\n        }\n    }\n    return maxStr\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(find_max(words: [\"name\", \"of\", \"string\"]) == \"\
    string\")\nassert(find_max(words: [\"name\", \"enam\", \"game\"]) == \"enam\"\
    )\nassert(find_max(words: [\"aaaaaaa\", \"bb\", \"cc\"]) == \"aaaaaaa\")\nassert(find_max(words:\
    \ [\"abc\", \"cba\"]) == \"abc\")\nassert(find_max(words: [\"play\", \"this\"\
    , \"game\", \"of\", \"footbott\"]) == \"footbott\")\nassert(find_max(words: [\"\
    we\", \"are\", \"gonna\", \"rock\"]) == \"gonna\")\nassert(find_max(words: [\"\
    we\", \"are\", \"a\", \"mad\", \"nation\"]) == \"nation\")\nassert(find_max(words:\
    \ [\"this\", \"is\", \"a\", \"prrk\"]) == \"this\")\nassert(find_max(words: [\"\
    b\"]) == \"b\")\nassert(find_max(words: [\"play\", \"play\", \"play\"]) == \"\
    play\")"
  status: Exception
  stderr: 'tmp0euns03b/tmp0euns03b.swift:39: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b14eaf9ac80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b14eac91b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b14eac91988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b14eac907b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmp0euns03b                        0x000055e16bd3e933 <unavailable> + 6451

    5    libc.so.6                          0x00002b14eb186460 __libc_start_main +
    245

    6    tmp0euns03b                        0x000055e16bd3e359 <unavailable> + 4953

    '
  stdout: ''
  timestamp: 1660013455
- exit_code: -4
  program: "\n/// Write a function that accepts an array of strings.\n/// The array\
    \ contains different words. Return the word with maximum number\n/// of unique\
    \ characters. If multiple strings have maximum number of unique\n/// characters,\
    \ return the one which comes first in lexicographical order.\n/// >>> find_max(words:\
    \ [\"name\", \"of\", \"string\"])\n/// \"string\"\n/// >>> find_max(words: [\"\
    name\", \"enam\", \"game\"])\n/// \"enam\"\n/// >>> find_max(words: [\"aaaaaaa\"\
    , \"bb\", \"cc\"])\n/// \"aaaaaaa\"\nfunc find_max(words: [String]) -> String\
    \ {\n    var finalWord = \"\"\n    var uniqueCharacters = Set<Character>()\n \
    \   var maxUniqueCharacters = 0\n    for word in words {\n        uniqueCharacters\
    \ = Set(word)\n        if uniqueCharacters.count > maxUniqueCharacters {\n   \
    \         maxUniqueCharacters = uniqueCharacters.count\n            finalWord\
    \ = word\n        }\n    }\n    return finalWord\n}\n\n\nfunc ==(left: [(Int,\
    \ Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n\
    \        return false\n    }\n    for (l, r) in zip(left, right) {\n        if\
    \ l != r {\n            return false\n        }\n    }\n    return true\n}\n \
    \           \nassert(find_max(words: [\"name\", \"of\", \"string\"]) == \"string\"\
    )\nassert(find_max(words: [\"name\", \"enam\", \"game\"]) == \"enam\")\nassert(find_max(words:\
    \ [\"aaaaaaa\", \"bb\", \"cc\"]) == \"aaaaaaa\")\nassert(find_max(words: [\"abc\"\
    , \"cba\"]) == \"abc\")\nassert(find_max(words: [\"play\", \"this\", \"game\"\
    , \"of\", \"footbott\"]) == \"footbott\")\nassert(find_max(words: [\"we\", \"\
    are\", \"gonna\", \"rock\"]) == \"gonna\")\nassert(find_max(words: [\"we\", \"\
    are\", \"a\", \"mad\", \"nation\"]) == \"nation\")\nassert(find_max(words: [\"\
    this\", \"is\", \"a\", \"prrk\"]) == \"this\")\nassert(find_max(words: [\"b\"\
    ]) == \"b\")\nassert(find_max(words: [\"play\", \"play\", \"play\"]) == \"play\"\
    )"
  status: Exception
  stderr: 'tmpydq1y4pw/tmpydq1y4pw.swift:40: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b6036b2ac80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b6036821b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b6036821988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b60368207b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpydq1y4pw                        0x00005652e9a02983 <unavailable> + 6531

    5    libc.so.6                          0x00002b6036d16460 __libc_start_main +
    245

    6    tmpydq1y4pw                        0x00005652e9a023a9 <unavailable> + 5033

    '
  stdout: ''
  timestamp: 1660013455
- exit_code: 0
  program: "\n/// Write a function that accepts an array of strings.\n/// The array\
    \ contains different words. Return the word with maximum number\n/// of unique\
    \ characters. If multiple strings have maximum number of unique\n/// characters,\
    \ return the one which comes first in lexicographical order.\n/// >>> find_max(words:\
    \ [\"name\", \"of\", \"string\"])\n/// \"string\"\n/// >>> find_max(words: [\"\
    name\", \"enam\", \"game\"])\n/// \"enam\"\n/// >>> find_max(words: [\"aaaaaaa\"\
    , \"bb\", \"cc\"])\n/// \"aaaaaaa\"\nfunc find_max(words: [String]) -> String\
    \ {\n  var max_count = 0\n  var res = \"\"\n  for word in words {\n    var count\
    \ = 0\n    var set = Set<Character>()\n    for char in word {\n      if !set.contains(char)\
    \ {\n        count += 1\n        set.insert(char)\n      }\n    }\n    if count\
    \ > max_count {\n      max_count = count\n      res = word\n    } else if count\
    \ == max_count && res > word {\n      res = word\n    }\n  }\n  return res\n}\n\
    \n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(find_max(words: [\"name\", \"of\", \"string\"\
    ]) == \"string\")\nassert(find_max(words: [\"name\", \"enam\", \"game\"]) == \"\
    enam\")\nassert(find_max(words: [\"aaaaaaa\", \"bb\", \"cc\"]) == \"aaaaaaa\"\
    )\nassert(find_max(words: [\"abc\", \"cba\"]) == \"abc\")\nassert(find_max(words:\
    \ [\"play\", \"this\", \"game\", \"of\", \"footbott\"]) == \"footbott\")\nassert(find_max(words:\
    \ [\"we\", \"are\", \"gonna\", \"rock\"]) == \"gonna\")\nassert(find_max(words:\
    \ [\"we\", \"are\", \"a\", \"mad\", \"nation\"]) == \"nation\")\nassert(find_max(words:\
    \ [\"this\", \"is\", \"a\", \"prrk\"]) == \"this\")\nassert(find_max(words: [\"\
    b\"]) == \"b\")\nassert(find_max(words: [\"play\", \"play\", \"play\"]) == \"\
    play\")"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660013455
- exit_code: -4
  program: "\n/// Write a function that accepts an array of strings.\n/// The array\
    \ contains different words. Return the word with maximum number\n/// of unique\
    \ characters. If multiple strings have maximum number of unique\n/// characters,\
    \ return the one which comes first in lexicographical order.\n/// >>> find_max(words:\
    \ [\"name\", \"of\", \"string\"])\n/// \"string\"\n/// >>> find_max(words: [\"\
    name\", \"enam\", \"game\"])\n/// \"enam\"\n/// >>> find_max(words: [\"aaaaaaa\"\
    , \"bb\", \"cc\"])\n/// \"aaaaaaa\"\nfunc find_max(words: [String]) -> String\
    \ {\n    var lex: (String, Int) = (\"\", 0)\n    var max: (String, Int) = (\"\"\
    , 0)\n    for i in words {\n        var counter = 0\n        for j in i {\n  \
    \          if !i.contains(String(j)) {\n                counter += 1\n       \
    \     }\n        }\n        if counter > max.1 {\n            max = (i, counter)\n\
    \        } else if counter == max.1 {\n            if i < lex.0 {\n          \
    \      lex = (i, counter)\n            }\n        }\n    }\n    if lex.0 == \"\
    \" {\n        return max.0\n    } else {\n        return lex.0\n    }\n}\n\n\n\
    func ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(find_max(words: [\"name\", \"of\", \"string\"\
    ]) == \"string\")\nassert(find_max(words: [\"name\", \"enam\", \"game\"]) == \"\
    enam\")\nassert(find_max(words: [\"aaaaaaa\", \"bb\", \"cc\"]) == \"aaaaaaa\"\
    )\nassert(find_max(words: [\"abc\", \"cba\"]) == \"abc\")\nassert(find_max(words:\
    \ [\"play\", \"this\", \"game\", \"of\", \"footbott\"]) == \"footbott\")\nassert(find_max(words:\
    \ [\"we\", \"are\", \"gonna\", \"rock\"]) == \"gonna\")\nassert(find_max(words:\
    \ [\"we\", \"are\", \"a\", \"mad\", \"nation\"]) == \"nation\")\nassert(find_max(words:\
    \ [\"this\", \"is\", \"a\", \"prrk\"]) == \"this\")\nassert(find_max(words: [\"\
    b\"]) == \"b\")\nassert(find_max(words: [\"play\", \"play\", \"play\"]) == \"\
    play\")"
  status: Exception
  stderr: 'tmprjb50usk/tmprjb50usk.swift:50: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b9fc8e6cc80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b9fc8b63b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b9fc8b63988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b9fc8b627b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmprjb50usk                        0x000055a0efde983e <unavailable> + 6206

    5    libc.so.6                          0x00002b9fc9058460 __libc_start_main +
    245

    6    tmprjb50usk                        0x000055a0efde93f9 <unavailable> + 5113

    '
  stdout: ''
  timestamp: 1660013455
- exit_code: 0
  program: "\n/// Write a function that accepts an array of strings.\n/// The array\
    \ contains different words. Return the word with maximum number\n/// of unique\
    \ characters. If multiple strings have maximum number of unique\n/// characters,\
    \ return the one which comes first in lexicographical order.\n/// >>> find_max(words:\
    \ [\"name\", \"of\", \"string\"])\n/// \"string\"\n/// >>> find_max(words: [\"\
    name\", \"enam\", \"game\"])\n/// \"enam\"\n/// >>> find_max(words: [\"aaaaaaa\"\
    , \"bb\", \"cc\"])\n/// \"aaaaaaa\"\nfunc find_max(words: [String]) -> String\
    \ {\n    var maxUniqueChars = 0\n    var maxString = \"\"\n    var maxIndex =\
    \ 0\n    for (index, word) in words.enumerated() {\n        let uniqueChars =\
    \ Set(word.unicodeScalars)\n        if uniqueChars.count > maxUniqueChars {\n\
    \            maxUniqueChars = uniqueChars.count\n            maxString = word\n\
    \            maxIndex = index\n        } else if uniqueChars.count == maxUniqueChars\
    \ {\n            if word < maxString {\n                maxString = word\n   \
    \             maxIndex = index\n            }\n        }\n    }\n    return maxString\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(find_max(words: [\"name\", \"of\", \"string\"\
    ]) == \"string\")\nassert(find_max(words: [\"name\", \"enam\", \"game\"]) == \"\
    enam\")\nassert(find_max(words: [\"aaaaaaa\", \"bb\", \"cc\"]) == \"aaaaaaa\"\
    )\nassert(find_max(words: [\"abc\", \"cba\"]) == \"abc\")\nassert(find_max(words:\
    \ [\"play\", \"this\", \"game\", \"of\", \"footbott\"]) == \"footbott\")\nassert(find_max(words:\
    \ [\"we\", \"are\", \"gonna\", \"rock\"]) == \"gonna\")\nassert(find_max(words:\
    \ [\"we\", \"are\", \"a\", \"mad\", \"nation\"]) == \"nation\")\nassert(find_max(words:\
    \ [\"this\", \"is\", \"a\", \"prrk\"]) == \"this\")\nassert(find_max(words: [\"\
    b\"]) == \"b\")\nassert(find_max(words: [\"play\", \"play\", \"play\"]) == \"\
    play\")"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660013455
- exit_code: -4
  program: "\n/// Write a function that accepts an array of strings.\n/// The array\
    \ contains different words. Return the word with maximum number\n/// of unique\
    \ characters. If multiple strings have maximum number of unique\n/// characters,\
    \ return the one which comes first in lexicographical order.\n/// >>> find_max(words:\
    \ [\"name\", \"of\", \"string\"])\n/// \"string\"\n/// >>> find_max(words: [\"\
    name\", \"enam\", \"game\"])\n/// \"enam\"\n/// >>> find_max(words: [\"aaaaaaa\"\
    , \"bb\", \"cc\"])\n/// \"aaaaaaa\"\nfunc find_max(words: [String]) -> String\
    \ {\n    if words.count == 0 {\n        return \"\"\n    }\n    if words.count\
    \ == 1 {\n        return words[0]\n    }\n    var currMaxWord = words[0]\n   \
    \ var currMaxCount = 0\n    for word in words {\n        if word.count > currMaxCount\
    \ {\n            currMaxCount = word.count\n            currMaxWord = word\n \
    \       }\n    }\n    return currMaxWord\n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(find_max(words: [\"name\", \"of\", \"string\"]) == \"string\")\nassert(find_max(words:\
    \ [\"name\", \"enam\", \"game\"]) == \"enam\")\nassert(find_max(words: [\"aaaaaaa\"\
    , \"bb\", \"cc\"]) == \"aaaaaaa\")\nassert(find_max(words: [\"abc\", \"cba\"])\
    \ == \"abc\")\nassert(find_max(words: [\"play\", \"this\", \"game\", \"of\", \"\
    footbott\"]) == \"footbott\")\nassert(find_max(words: [\"we\", \"are\", \"gonna\"\
    , \"rock\"]) == \"gonna\")\nassert(find_max(words: [\"we\", \"are\", \"a\", \"\
    mad\", \"nation\"]) == \"nation\")\nassert(find_max(words: [\"this\", \"is\",\
    \ \"a\", \"prrk\"]) == \"this\")\nassert(find_max(words: [\"b\"]) == \"b\")\n\
    assert(find_max(words: [\"play\", \"play\", \"play\"]) == \"play\")"
  status: Exception
  stderr: 'tmpqkd38cp_/tmpqkd38cp_.swift:44: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b253b4fbc80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b253b1f2b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b253b1f2988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b253b1f17b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpqkd38cp_                        0x0000565201c8a8c3 <unavailable> + 6339

    5    libc.so.6                          0x00002b253b6e7460 __libc_start_main +
    245

    6    tmpqkd38cp_                        0x0000565201c8a2e9 <unavailable> + 4841

    '
  stdout: ''
  timestamp: 1660013455
- exit_code: 0
  program: "\n/// Write a function that accepts an array of strings.\n/// The array\
    \ contains different words. Return the word with maximum number\n/// of unique\
    \ characters. If multiple strings have maximum number of unique\n/// characters,\
    \ return the one which comes first in lexicographical order.\n/// >>> find_max(words:\
    \ [\"name\", \"of\", \"string\"])\n/// \"string\"\n/// >>> find_max(words: [\"\
    name\", \"enam\", \"game\"])\n/// \"enam\"\n/// >>> find_max(words: [\"aaaaaaa\"\
    , \"bb\", \"cc\"])\n/// \"aaaaaaa\"\nfunc find_max(words: [String]) -> String\
    \ {\n    guard !words.isEmpty else { return \"\" }\n    var maxLen = 0\n    var\
    \ res = \"\"\n    for word in words {\n        let count = Set(word).count\n \
    \       if count > maxLen {\n            maxLen = count\n            res = word\n\
    \        } else if count == maxLen && word < res {\n            res = word\n \
    \       }\n    }\n    return res\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int,\
    \ Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n\
    \    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n          \
    \  return false\n        }\n    }\n    return true\n}\n            \nassert(find_max(words:\
    \ [\"name\", \"of\", \"string\"]) == \"string\")\nassert(find_max(words: [\"name\"\
    , \"enam\", \"game\"]) == \"enam\")\nassert(find_max(words: [\"aaaaaaa\", \"bb\"\
    , \"cc\"]) == \"aaaaaaa\")\nassert(find_max(words: [\"abc\", \"cba\"]) == \"abc\"\
    )\nassert(find_max(words: [\"play\", \"this\", \"game\", \"of\", \"footbott\"\
    ]) == \"footbott\")\nassert(find_max(words: [\"we\", \"are\", \"gonna\", \"rock\"\
    ]) == \"gonna\")\nassert(find_max(words: [\"we\", \"are\", \"a\", \"mad\", \"\
    nation\"]) == \"nation\")\nassert(find_max(words: [\"this\", \"is\", \"a\", \"\
    prrk\"]) == \"this\")\nassert(find_max(words: [\"b\"]) == \"b\")\nassert(find_max(words:\
    \ [\"play\", \"play\", \"play\"]) == \"play\")"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660013455
- exit_code: -4
  program: "\n/// Write a function that accepts an array of strings.\n/// The array\
    \ contains different words. Return the word with maximum number\n/// of unique\
    \ characters. If multiple strings have maximum number of unique\n/// characters,\
    \ return the one which comes first in lexicographical order.\n/// >>> find_max(words:\
    \ [\"name\", \"of\", \"string\"])\n/// \"string\"\n/// >>> find_max(words: [\"\
    name\", \"enam\", \"game\"])\n/// \"enam\"\n/// >>> find_max(words: [\"aaaaaaa\"\
    , \"bb\", \"cc\"])\n/// \"aaaaaaa\"\nfunc find_max(words: [String]) -> String\
    \ {\n    var maxCount = 0\n    var result: String = \"\"\n    for word in words\
    \ {\n        var count = 0\n        for char in word {\n            if word.filter({\
    \ $0 == char }).count == 1 {\n                count += 1\n            }\n    \
    \    }\n        if count > maxCount {\n            maxCount = count\n        \
    \    result = word\n        }\n    }\n    return result\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(find_max(words: [\"name\", \"of\", \"string\"]) == \"\
    string\")\nassert(find_max(words: [\"name\", \"enam\", \"game\"]) == \"enam\"\
    )\nassert(find_max(words: [\"aaaaaaa\", \"bb\", \"cc\"]) == \"aaaaaaa\")\nassert(find_max(words:\
    \ [\"abc\", \"cba\"]) == \"abc\")\nassert(find_max(words: [\"play\", \"this\"\
    , \"game\", \"of\", \"footbott\"]) == \"footbott\")\nassert(find_max(words: [\"\
    we\", \"are\", \"gonna\", \"rock\"]) == \"gonna\")\nassert(find_max(words: [\"\
    we\", \"are\", \"a\", \"mad\", \"nation\"]) == \"nation\")\nassert(find_max(words:\
    \ [\"this\", \"is\", \"a\", \"prrk\"]) == \"this\")\nassert(find_max(words: [\"\
    b\"]) == \"b\")\nassert(find_max(words: [\"play\", \"play\", \"play\"]) == \"\
    play\")"
  status: Exception
  stderr: 'tmp0wvmctwv/tmp0wvmctwv.swift:44: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b2679913c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b267960ab6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b267960a988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b26796097b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmp0wvmctwv                        0x000056437c32f9c3 <unavailable> + 6595

    5    libc.so.6                          0x00002b2679aff460 __libc_start_main +
    245

    6    tmp0wvmctwv                        0x000056437c32f3e9 <unavailable> + 5097

    '
  stdout: ''
  timestamp: 1660013455
- exit_code: -4
  program: "\n/// Write a function that accepts an array of strings.\n/// The array\
    \ contains different words. Return the word with maximum number\n/// of unique\
    \ characters. If multiple strings have maximum number of unique\n/// characters,\
    \ return the one which comes first in lexicographical order.\n/// >>> find_max(words:\
    \ [\"name\", \"of\", \"string\"])\n/// \"string\"\n/// >>> find_max(words: [\"\
    name\", \"enam\", \"game\"])\n/// \"enam\"\n/// >>> find_max(words: [\"aaaaaaa\"\
    , \"bb\", \"cc\"])\n/// \"aaaaaaa\"\nfunc find_max(words: [String]) -> String\
    \ {\n  var maxCharCount = 0\n  var charDict = [Character: Int]()\n  var maxString\
    \ = \"\"\n  for word in words {\n    for char in word {\n      if charDict[char]\
    \ == nil {\n        charDict[char] = 1\n      } else {\n        charDict[char]!\
    \ += 1\n      }\n    }\n    if charDict.count > maxCharCount {\n      maxCharCount\
    \ = charDict.count\n      maxString = word\n    }\n    charDict.removeAll()\n\
    \  }\n  return maxString\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(find_max(words:\
    \ [\"name\", \"of\", \"string\"]) == \"string\")\nassert(find_max(words: [\"name\"\
    , \"enam\", \"game\"]) == \"enam\")\nassert(find_max(words: [\"aaaaaaa\", \"bb\"\
    , \"cc\"]) == \"aaaaaaa\")\nassert(find_max(words: [\"abc\", \"cba\"]) == \"abc\"\
    )\nassert(find_max(words: [\"play\", \"this\", \"game\", \"of\", \"footbott\"\
    ]) == \"footbott\")\nassert(find_max(words: [\"we\", \"are\", \"gonna\", \"rock\"\
    ]) == \"gonna\")\nassert(find_max(words: [\"we\", \"are\", \"a\", \"mad\", \"\
    nation\"]) == \"nation\")\nassert(find_max(words: [\"this\", \"is\", \"a\", \"\
    prrk\"]) == \"this\")\nassert(find_max(words: [\"b\"]) == \"b\")\nassert(find_max(words:\
    \ [\"play\", \"play\", \"play\"]) == \"play\")"
  status: Exception
  stderr: 'tmpqvnxng0n/tmpqvnxng0n.swift:47: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b4e76b0fc80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b4e76806b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b4e76806988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b4e768057b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpqvnxng0n                        0x0000559eb4070b83 <unavailable> + 7043

    5    libc.so.6                          0x00002b4e76cfb460 __libc_start_main +
    245

    6    tmpqvnxng0n                        0x0000559eb40705a9 <unavailable> + 5545

    '
  stdout: ''
  timestamp: 1660013455
- exit_code: 0
  program: "\n/// Write a function that accepts an array of strings.\n/// The array\
    \ contains different words. Return the word with maximum number\n/// of unique\
    \ characters. If multiple strings have maximum number of unique\n/// characters,\
    \ return the one which comes first in lexicographical order.\n/// >>> find_max(words:\
    \ [\"name\", \"of\", \"string\"])\n/// \"string\"\n/// >>> find_max(words: [\"\
    name\", \"enam\", \"game\"])\n/// \"enam\"\n/// >>> find_max(words: [\"aaaaaaa\"\
    , \"bb\", \"cc\"])\n/// \"aaaaaaa\"\nfunc find_max(words: [String]) -> String\
    \ {\n  var max = words[0]\n  var maxUnique = Set(max).count\n  for word in words\
    \ {\n    let currentUnique = Set(word).count\n    if currentUnique > maxUnique\
    \ ||\n      (currentUnique == maxUnique && word < max) {\n      max = word\n \
    \     maxUnique = currentUnique\n    }\n  }\n  return max\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(find_max(words: [\"name\", \"of\", \"string\"]) == \"\
    string\")\nassert(find_max(words: [\"name\", \"enam\", \"game\"]) == \"enam\"\
    )\nassert(find_max(words: [\"aaaaaaa\", \"bb\", \"cc\"]) == \"aaaaaaa\")\nassert(find_max(words:\
    \ [\"abc\", \"cba\"]) == \"abc\")\nassert(find_max(words: [\"play\", \"this\"\
    , \"game\", \"of\", \"footbott\"]) == \"footbott\")\nassert(find_max(words: [\"\
    we\", \"are\", \"gonna\", \"rock\"]) == \"gonna\")\nassert(find_max(words: [\"\
    we\", \"are\", \"a\", \"mad\", \"nation\"]) == \"nation\")\nassert(find_max(words:\
    \ [\"this\", \"is\", \"a\", \"prrk\"]) == \"this\")\nassert(find_max(words: [\"\
    b\"]) == \"b\")\nassert(find_max(words: [\"play\", \"play\", \"play\"]) == \"\
    play\")"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660013455
- exit_code: 1
  program: "\n/// Write a function that accepts an array of strings.\n/// The array\
    \ contains different words. Return the word with maximum number\n/// of unique\
    \ characters. If multiple strings have maximum number of unique\n/// characters,\
    \ return the one which comes first in lexicographical order.\n/// >>> find_max(words:\
    \ [\"name\", \"of\", \"string\"])\n/// \"string\"\n/// >>> find_max(words: [\"\
    name\", \"enam\", \"game\"])\n/// \"enam\"\n/// >>> find_max(words: [\"aaaaaaa\"\
    , \"bb\", \"cc\"])\n/// \"aaaaaaa\"\nfunc find_max(words: [String]) -> String\
    \ {\n    guard !words.isEmpty else { return \"\" }\n    return (words.max(by:\
    \ { uniqueChars(word: $0) < uniqueChars(word: $1) }))!\n}\n\n\nfunc ==(left: [(Int,\
    \ Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n\
    \        return false\n    }\n    for (l, r) in zip(left, right) {\n        if\
    \ l != r {\n            return false\n        }\n    }\n    return true\n}\n \
    \           \nassert(find_max(words: [\"name\", \"of\", \"string\"]) == \"string\"\
    )\nassert(find_max(words: [\"name\", \"enam\", \"game\"]) == \"enam\")\nassert(find_max(words:\
    \ [\"aaaaaaa\", \"bb\", \"cc\"]) == \"aaaaaaa\")\nassert(find_max(words: [\"abc\"\
    , \"cba\"]) == \"abc\")\nassert(find_max(words: [\"play\", \"this\", \"game\"\
    , \"of\", \"footbott\"]) == \"footbott\")\nassert(find_max(words: [\"we\", \"\
    are\", \"gonna\", \"rock\"]) == \"gonna\")\nassert(find_max(words: [\"we\", \"\
    are\", \"a\", \"mad\", \"nation\"]) == \"nation\")\nassert(find_max(words: [\"\
    this\", \"is\", \"a\", \"prrk\"]) == \"this\")\nassert(find_max(words: [\"b\"\
    ]) == \"b\")\nassert(find_max(words: [\"play\", \"play\", \"play\"]) == \"play\"\
    )"
  status: SyntaxError
  stderr: "/tmp/tmpkono5sx4.swift:14:29: error: cannot find 'uniqueChars' in scope\n\
    \    return (words.max(by: { uniqueChars(word: $0) < uniqueChars(word: $1) }))!\n\
    \                            ^~~~~~~~~~~\n/tmp/tmpkono5sx4.swift:14:53: error:\
    \ cannot find 'uniqueChars' in scope\n    return (words.max(by: { uniqueChars(word:\
    \ $0) < uniqueChars(word: $1) }))!\n                                         \
    \           ^~~~~~~~~~~\n"
  stdout: ''
  timestamp: 1660013455
- exit_code: 1
  program: "\n/// Write a function that accepts an array of strings.\n/// The array\
    \ contains different words. Return the word with maximum number\n/// of unique\
    \ characters. If multiple strings have maximum number of unique\n/// characters,\
    \ return the one which comes first in lexicographical order.\n/// >>> find_max(words:\
    \ [\"name\", \"of\", \"string\"])\n/// \"string\"\n/// >>> find_max(words: [\"\
    name\", \"enam\", \"game\"])\n/// \"enam\"\n/// >>> find_max(words: [\"aaaaaaa\"\
    , \"bb\", \"cc\"])\n/// \"aaaaaaa\"\nfunc find_max(words: [String]) -> String\
    \ {\n    var max_word = words[0]\n    var max_count = count_unique_chars(word:\
    \ max_word)\n    for word in words {\n        let count = count_unique_chars(word:\
    \ word)\n        if count > max_count {\n            max_count = count\n     \
    \       max_word = word\n        }\n    }\n    return max_word\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(find_max(words: [\"name\", \"of\", \"string\"]) == \"\
    string\")\nassert(find_max(words: [\"name\", \"enam\", \"game\"]) == \"enam\"\
    )\nassert(find_max(words: [\"aaaaaaa\", \"bb\", \"cc\"]) == \"aaaaaaa\")\nassert(find_max(words:\
    \ [\"abc\", \"cba\"]) == \"abc\")\nassert(find_max(words: [\"play\", \"this\"\
    , \"game\", \"of\", \"footbott\"]) == \"footbott\")\nassert(find_max(words: [\"\
    we\", \"are\", \"gonna\", \"rock\"]) == \"gonna\")\nassert(find_max(words: [\"\
    we\", \"are\", \"a\", \"mad\", \"nation\"]) == \"nation\")\nassert(find_max(words:\
    \ [\"this\", \"is\", \"a\", \"prrk\"]) == \"this\")\nassert(find_max(words: [\"\
    b\"]) == \"b\")\nassert(find_max(words: [\"play\", \"play\", \"play\"]) == \"\
    play\")"
  status: SyntaxError
  stderr: "/tmp/tmp7gs45c7z.swift:14:21: error: cannot find 'count_unique_chars' in\
    \ scope\n    var max_count = count_unique_chars(word: max_word)\n            \
    \        ^~~~~~~~~~~~~~~~~~\n/tmp/tmp7gs45c7z.swift:16:21: error: cannot find\
    \ 'count_unique_chars' in scope\n        let count = count_unique_chars(word:\
    \ word)\n                    ^~~~~~~~~~~~~~~~~~\n"
  stdout: ''
  timestamp: 1660013455
- exit_code: -4
  program: "\n/// Write a function that accepts an array of strings.\n/// The array\
    \ contains different words. Return the word with maximum number\n/// of unique\
    \ characters. If multiple strings have maximum number of unique\n/// characters,\
    \ return the one which comes first in lexicographical order.\n/// >>> find_max(words:\
    \ [\"name\", \"of\", \"string\"])\n/// \"string\"\n/// >>> find_max(words: [\"\
    name\", \"enam\", \"game\"])\n/// \"enam\"\n/// >>> find_max(words: [\"aaaaaaa\"\
    , \"bb\", \"cc\"])\n/// \"aaaaaaa\"\nfunc find_max(words: [String]) -> String\
    \ {\n    let result = words.map { (word: String) -> (String, Int) in\n       \
    \ return (word, Set(word).count)\n    }\n    let max = result.max { (first: (String,\
    \ Int), second: (String, Int)) -> Bool in\n        if first.1 != second.1 {\n\
    \            return first.1 > second.1\n        } else {\n            return first.0\
    \ < second.0\n        }\n    }\n    return max?.0 ?? \"\"\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(find_max(words: [\"name\", \"of\", \"string\"]) == \"\
    string\")\nassert(find_max(words: [\"name\", \"enam\", \"game\"]) == \"enam\"\
    )\nassert(find_max(words: [\"aaaaaaa\", \"bb\", \"cc\"]) == \"aaaaaaa\")\nassert(find_max(words:\
    \ [\"abc\", \"cba\"]) == \"abc\")\nassert(find_max(words: [\"play\", \"this\"\
    , \"game\", \"of\", \"footbott\"]) == \"footbott\")\nassert(find_max(words: [\"\
    we\", \"are\", \"gonna\", \"rock\"]) == \"gonna\")\nassert(find_max(words: [\"\
    we\", \"are\", \"a\", \"mad\", \"nation\"]) == \"nation\")\nassert(find_max(words:\
    \ [\"this\", \"is\", \"a\", \"prrk\"]) == \"this\")\nassert(find_max(words: [\"\
    b\"]) == \"b\")\nassert(find_max(words: [\"play\", \"play\", \"play\"]) == \"\
    play\")"
  status: Exception
  stderr: 'tmpb8335dvq/tmpb8335dvq.swift:39: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002adc32fadc80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002adc32ca4b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002adc32ca4988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002adc32ca37b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpb8335dvq                        0x000055e94d3c779e <unavailable> + 6046

    5    libc.so.6                          0x00002adc33199460 __libc_start_main +
    245

    6    tmpb8335dvq                        0x000055e94d3c7359 <unavailable> + 4953

    '
  stdout: ''
  timestamp: 1660013455
- exit_code: -4
  program: "\n/// Write a function that accepts an array of strings.\n/// The array\
    \ contains different words. Return the word with maximum number\n/// of unique\
    \ characters. If multiple strings have maximum number of unique\n/// characters,\
    \ return the one which comes first in lexicographical order.\n/// >>> find_max(words:\
    \ [\"name\", \"of\", \"string\"])\n/// \"string\"\n/// >>> find_max(words: [\"\
    name\", \"enam\", \"game\"])\n/// \"enam\"\n/// >>> find_max(words: [\"aaaaaaa\"\
    , \"bb\", \"cc\"])\n/// \"aaaaaaa\"\nfunc find_max(words: [String]) -> String\
    \ {\n    return \"\"\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(find_max(words:\
    \ [\"name\", \"of\", \"string\"]) == \"string\")\nassert(find_max(words: [\"name\"\
    , \"enam\", \"game\"]) == \"enam\")\nassert(find_max(words: [\"aaaaaaa\", \"bb\"\
    , \"cc\"]) == \"aaaaaaa\")\nassert(find_max(words: [\"abc\", \"cba\"]) == \"abc\"\
    )\nassert(find_max(words: [\"play\", \"this\", \"game\", \"of\", \"footbott\"\
    ]) == \"footbott\")\nassert(find_max(words: [\"we\", \"are\", \"gonna\", \"rock\"\
    ]) == \"gonna\")\nassert(find_max(words: [\"we\", \"are\", \"a\", \"mad\", \"\
    nation\"]) == \"nation\")\nassert(find_max(words: [\"this\", \"is\", \"a\", \"\
    prrk\"]) == \"this\")\nassert(find_max(words: [\"b\"]) == \"b\")\nassert(find_max(words:\
    \ [\"play\", \"play\", \"play\"]) == \"play\")"
  status: Exception
  stderr: 'tmp9vfthvyx/tmp9vfthvyx.swift:29: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b5bb598bc80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b5bb5682b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b5bb5682988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b5bb56817b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmp9vfthvyx                        0x0000564c87ea64ce <unavailable> + 5326

    5    libc.so.6                          0x00002b5bb5b77460 __libc_start_main +
    245

    6    tmp9vfthvyx                        0x0000564c87ea6089 <unavailable> + 4233

    '
  stdout: ''
  timestamp: 1660013265
- exit_code: -4
  program: "\n/// Write a function that accepts an array of strings.\n/// The array\
    \ contains different words. Return the word with maximum number\n/// of unique\
    \ characters. If multiple strings have maximum number of unique\n/// characters,\
    \ return the one which comes first in lexicographical order.\n/// >>> find_max(words:\
    \ [\"name\", \"of\", \"string\"])\n/// \"string\"\n/// >>> find_max(words: [\"\
    name\", \"enam\", \"game\"])\n/// \"enam\"\n/// >>> find_max(words: [\"aaaaaaa\"\
    , \"bb\", \"cc\"])\n/// \"aaaaaaa\"\nfunc find_max(words: [String]) -> String\
    \ {\n    var max = words[0]\n    var maxCount = 0\n    for word in words {\n \
    \       let chars = Set(word)\n        if chars.count > maxCount {\n         \
    \   max = word\n            maxCount = chars.count\n        }\n    }\n    return\
    \ max\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n   \
    \ if left.count != right.count {\n        return false\n    }\n    for (l, r)\
    \ in zip(left, right) {\n        if l != r {\n            return false\n     \
    \   }\n    }\n    return true\n}\n            \nassert(find_max(words: [\"name\"\
    , \"of\", \"string\"]) == \"string\")\nassert(find_max(words: [\"name\", \"enam\"\
    , \"game\"]) == \"enam\")\nassert(find_max(words: [\"aaaaaaa\", \"bb\", \"cc\"\
    ]) == \"aaaaaaa\")\nassert(find_max(words: [\"abc\", \"cba\"]) == \"abc\")\nassert(find_max(words:\
    \ [\"play\", \"this\", \"game\", \"of\", \"footbott\"]) == \"footbott\")\nassert(find_max(words:\
    \ [\"we\", \"are\", \"gonna\", \"rock\"]) == \"gonna\")\nassert(find_max(words:\
    \ [\"we\", \"are\", \"a\", \"mad\", \"nation\"]) == \"nation\")\nassert(find_max(words:\
    \ [\"this\", \"is\", \"a\", \"prrk\"]) == \"this\")\nassert(find_max(words: [\"\
    b\"]) == \"b\")\nassert(find_max(words: [\"play\", \"play\", \"play\"]) == \"\
    play\")"
  status: Exception
  stderr: 'tmp4blkjyyb/tmp4blkjyyb.swift:39: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b4e17c22c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b4e17919b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b4e17919988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b4e179187b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmp4blkjyyb                        0x000055c986fb3993 <unavailable> + 6547

    5    libc.so.6                          0x00002b4e17e0e460 __libc_start_main +
    245

    6    tmp4blkjyyb                        0x000055c986fb33b9 <unavailable> + 5049

    '
  stdout: ''
  timestamp: 1660013455
- exit_code: -4
  program: "\n/// Write a function that accepts an array of strings.\n/// The array\
    \ contains different words. Return the word with maximum number\n/// of unique\
    \ characters. If multiple strings have maximum number of unique\n/// characters,\
    \ return the one which comes first in lexicographical order.\n/// >>> find_max(words:\
    \ [\"name\", \"of\", \"string\"])\n/// \"string\"\n/// >>> find_max(words: [\"\
    name\", \"enam\", \"game\"])\n/// \"enam\"\n/// >>> find_max(words: [\"aaaaaaa\"\
    , \"bb\", \"cc\"])\n/// \"aaaaaaa\"\nfunc find_max(words: [String]) -> String\
    \ {\n    return \"Your code here\"\n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(find_max(words: [\"name\", \"of\", \"string\"]) == \"string\")\nassert(find_max(words:\
    \ [\"name\", \"enam\", \"game\"]) == \"enam\")\nassert(find_max(words: [\"aaaaaaa\"\
    , \"bb\", \"cc\"]) == \"aaaaaaa\")\nassert(find_max(words: [\"abc\", \"cba\"])\
    \ == \"abc\")\nassert(find_max(words: [\"play\", \"this\", \"game\", \"of\", \"\
    footbott\"]) == \"footbott\")\nassert(find_max(words: [\"we\", \"are\", \"gonna\"\
    , \"rock\"]) == \"gonna\")\nassert(find_max(words: [\"we\", \"are\", \"a\", \"\
    mad\", \"nation\"]) == \"nation\")\nassert(find_max(words: [\"this\", \"is\",\
    \ \"a\", \"prrk\"]) == \"this\")\nassert(find_max(words: [\"b\"]) == \"b\")\n\
    assert(find_max(words: [\"play\", \"play\", \"play\"]) == \"play\")"
  status: Exception
  stderr: 'tmpgpabp_op/tmpgpabp_op.swift:29: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b75a4ca6c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b75a499db6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b75a499d988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b75a499c7b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpgpabp_op                        0x000056421045a4ce <unavailable> + 5326

    5    libc.so.6                          0x00002b75a4e92460 __libc_start_main +
    245

    6    tmpgpabp_op                        0x000056421045a089 <unavailable> + 4233

    '
  stdout: ''
  timestamp: 1660013455
- exit_code: -4
  program: "\n/// Write a function that accepts an array of strings.\n/// The array\
    \ contains different words. Return the word with maximum number\n/// of unique\
    \ characters. If multiple strings have maximum number of unique\n/// characters,\
    \ return the one which comes first in lexicographical order.\n/// >>> find_max(words:\
    \ [\"name\", \"of\", \"string\"])\n/// \"string\"\n/// >>> find_max(words: [\"\
    name\", \"enam\", \"game\"])\n/// \"enam\"\n/// >>> find_max(words: [\"aaaaaaa\"\
    , \"bb\", \"cc\"])\n/// \"aaaaaaa\"\nfunc find_max(words: [String]) -> String\
    \ {\n    var (bestWord, bestCount) = (\"\", 0)\n    for word in words {\n    \
    \    let chars = Set(word)\n        if chars.count > bestCount {\n           \
    \ (bestWord, bestCount) = (word, chars.count)\n        }\n    }\n    return bestWord\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(find_max(words: [\"name\", \"of\", \"string\"\
    ]) == \"string\")\nassert(find_max(words: [\"name\", \"enam\", \"game\"]) == \"\
    enam\")\nassert(find_max(words: [\"aaaaaaa\", \"bb\", \"cc\"]) == \"aaaaaaa\"\
    )\nassert(find_max(words: [\"abc\", \"cba\"]) == \"abc\")\nassert(find_max(words:\
    \ [\"play\", \"this\", \"game\", \"of\", \"footbott\"]) == \"footbott\")\nassert(find_max(words:\
    \ [\"we\", \"are\", \"gonna\", \"rock\"]) == \"gonna\")\nassert(find_max(words:\
    \ [\"we\", \"are\", \"a\", \"mad\", \"nation\"]) == \"nation\")\nassert(find_max(words:\
    \ [\"this\", \"is\", \"a\", \"prrk\"]) == \"this\")\nassert(find_max(words: [\"\
    b\"]) == \"b\")\nassert(find_max(words: [\"play\", \"play\", \"play\"]) == \"\
    play\")"
  status: Exception
  stderr: 'tmp6_8yjnt7/tmp6_8yjnt7.swift:37: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b6040c01c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b60408f8b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b60408f8988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b60408f77b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmp6_8yjnt7                        0x000055ee6f036933 <unavailable> + 6451

    5    libc.so.6                          0x00002b6040ded460 __libc_start_main +
    245

    6    tmp6_8yjnt7                        0x000055ee6f036359 <unavailable> + 4953

    '
  stdout: ''
  timestamp: 1660013455
- exit_code: -4
  program: "\n/// Write a function that accepts an array of strings.\n/// The array\
    \ contains different words. Return the word with maximum number\n/// of unique\
    \ characters. If multiple strings have maximum number of unique\n/// characters,\
    \ return the one which comes first in lexicographical order.\n/// >>> find_max(words:\
    \ [\"name\", \"of\", \"string\"])\n/// \"string\"\n/// >>> find_max(words: [\"\
    name\", \"enam\", \"game\"])\n/// \"enam\"\n/// >>> find_max(words: [\"aaaaaaa\"\
    , \"bb\", \"cc\"])\n/// \"aaaaaaa\"\nfunc find_max(words: [String]) -> String\
    \ {\n    var max = (word: \"\", count: 0)\n    for word in words {\n        var\
    \ unique = [Character]()\n        for char in word {\n            if !unique.contains(char)\
    \ {\n                unique.append(char)\n            }\n        }\n        if\
    \ unique.count > max.count {\n            max = (word, unique.count)\n       \
    \ }\n    }\n    return max.word\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int,\
    \ Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n\
    \    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n          \
    \  return false\n        }\n    }\n    return true\n}\n            \nassert(find_max(words:\
    \ [\"name\", \"of\", \"string\"]) == \"string\")\nassert(find_max(words: [\"name\"\
    , \"enam\", \"game\"]) == \"enam\")\nassert(find_max(words: [\"aaaaaaa\", \"bb\"\
    , \"cc\"]) == \"aaaaaaa\")\nassert(find_max(words: [\"abc\", \"cba\"]) == \"abc\"\
    )\nassert(find_max(words: [\"play\", \"this\", \"game\", \"of\", \"footbott\"\
    ]) == \"footbott\")\nassert(find_max(words: [\"we\", \"are\", \"gonna\", \"rock\"\
    ]) == \"gonna\")\nassert(find_max(words: [\"we\", \"are\", \"a\", \"mad\", \"\
    nation\"]) == \"nation\")\nassert(find_max(words: [\"this\", \"is\", \"a\", \"\
    prrk\"]) == \"this\")\nassert(find_max(words: [\"b\"]) == \"b\")\nassert(find_max(words:\
    \ [\"play\", \"play\", \"play\"]) == \"play\")"
  status: Exception
  stderr: 'tmpx80_ovyg/tmpx80_ovyg.swift:42: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002af51bbfdc80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002af51b8f4b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002af51b8f4988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002af51b8f37b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpx80_ovyg                        0x00005580dffaea23 <unavailable> + 6691

    5    libc.so.6                          0x00002af51bde9460 __libc_start_main +
    245

    6    tmpx80_ovyg                        0x00005580dffae449 <unavailable> + 5193

    '
  stdout: ''
  timestamp: 1660013455
- exit_code: -4
  program: "\n/// Write a function that accepts an array of strings.\n/// The array\
    \ contains different words. Return the word with maximum number\n/// of unique\
    \ characters. If multiple strings have maximum number of unique\n/// characters,\
    \ return the one which comes first in lexicographical order.\n/// >>> find_max(words:\
    \ [\"name\", \"of\", \"string\"])\n/// \"string\"\n/// >>> find_max(words: [\"\
    name\", \"enam\", \"game\"])\n/// \"enam\"\n/// >>> find_max(words: [\"aaaaaaa\"\
    , \"bb\", \"cc\"])\n/// \"aaaaaaa\"\nfunc find_max(words: [String]) -> String\
    \ {\n    var output = \"\"\n    for word in words {\n        if output.isEmpty\
    \ {\n            output = word\n        } else if word.count > output.count {\n\
    \            output = word\n        } else if word.count == output.count {\n \
    \           output = word > output ? word : output\n        }\n    }\n    return\
    \ output\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n\
    \    if left.count != right.count {\n        return false\n    }\n    for (l,\
    \ r) in zip(left, right) {\n        if l != r {\n            return false\n  \
    \      }\n    }\n    return true\n}\n            \nassert(find_max(words: [\"\
    name\", \"of\", \"string\"]) == \"string\")\nassert(find_max(words: [\"name\"\
    , \"enam\", \"game\"]) == \"enam\")\nassert(find_max(words: [\"aaaaaaa\", \"bb\"\
    , \"cc\"]) == \"aaaaaaa\")\nassert(find_max(words: [\"abc\", \"cba\"]) == \"abc\"\
    )\nassert(find_max(words: [\"play\", \"this\", \"game\", \"of\", \"footbott\"\
    ]) == \"footbott\")\nassert(find_max(words: [\"we\", \"are\", \"gonna\", \"rock\"\
    ]) == \"gonna\")\nassert(find_max(words: [\"we\", \"are\", \"a\", \"mad\", \"\
    nation\"]) == \"nation\")\nassert(find_max(words: [\"this\", \"is\", \"a\", \"\
    prrk\"]) == \"this\")\nassert(find_max(words: [\"b\"]) == \"b\")\nassert(find_max(words:\
    \ [\"play\", \"play\", \"play\"]) == \"play\")"
  status: Exception
  stderr: 'tmp2fa8npy0/tmp2fa8npy0.swift:40: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b0791632c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b0791329b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b0791329988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b07913287b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmp2fa8npy0                        0x0000562ce666d903 <unavailable> + 6403

    5    libc.so.6                          0x00002b079181e460 __libc_start_main +
    245

    6    tmp2fa8npy0                        0x0000562ce666d329 <unavailable> + 4905

    '
  stdout: ''
  timestamp: 1660013455
- exit_code: -4
  program: "\n/// Write a function that accepts an array of strings.\n/// The array\
    \ contains different words. Return the word with maximum number\n/// of unique\
    \ characters. If multiple strings have maximum number of unique\n/// characters,\
    \ return the one which comes first in lexicographical order.\n/// >>> find_max(words:\
    \ [\"name\", \"of\", \"string\"])\n/// \"string\"\n/// >>> find_max(words: [\"\
    name\", \"enam\", \"game\"])\n/// \"enam\"\n/// >>> find_max(words: [\"aaaaaaa\"\
    , \"bb\", \"cc\"])\n/// \"aaaaaaa\"\nfunc find_max(words: [String]) -> String\
    \ {\n    guard !words.isEmpty else { return \"\" }\n    var wordUniqueCharsCount:\
    \ [String: Int] = [:]\n    for word in words {\n        wordUniqueCharsCount[word]\
    \ = word.count\n    }\n    let sortedWords = wordUniqueCharsCount.sorted { $0.value\
    \ > $1.value }\n    let max = sortedWords.first!\n    return max.key\n}\n\n\n\
    func ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(find_max(words: [\"name\", \"of\", \"string\"\
    ]) == \"string\")\nassert(find_max(words: [\"name\", \"enam\", \"game\"]) == \"\
    enam\")\nassert(find_max(words: [\"aaaaaaa\", \"bb\", \"cc\"]) == \"aaaaaaa\"\
    )\nassert(find_max(words: [\"abc\", \"cba\"]) == \"abc\")\nassert(find_max(words:\
    \ [\"play\", \"this\", \"game\", \"of\", \"footbott\"]) == \"footbott\")\nassert(find_max(words:\
    \ [\"we\", \"are\", \"gonna\", \"rock\"]) == \"gonna\")\nassert(find_max(words:\
    \ [\"we\", \"are\", \"a\", \"mad\", \"nation\"]) == \"nation\")\nassert(find_max(words:\
    \ [\"this\", \"is\", \"a\", \"prrk\"]) == \"this\")\nassert(find_max(words: [\"\
    b\"]) == \"b\")\nassert(find_max(words: [\"play\", \"play\", \"play\"]) == \"\
    play\")"
  status: Exception
  stderr: 'tmpvbbc3woz/tmpvbbc3woz.swift:37: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002abab57afc80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002abab54a6b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002abab54a6988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002abab54a57b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpvbbc3woz                        0x000055a032c06b13 <unavailable> + 6931

    5    libc.so.6                          0x00002abab599b460 __libc_start_main +
    245

    6    tmpvbbc3woz                        0x000055a032c06539 <unavailable> + 5433

    '
  stdout: ''
  timestamp: 1660013455
- exit_code: 0
  program: "\n/// Write a function that accepts an array of strings.\n/// The array\
    \ contains different words. Return the word with maximum number\n/// of unique\
    \ characters. If multiple strings have maximum number of unique\n/// characters,\
    \ return the one which comes first in lexicographical order.\n/// >>> find_max(words:\
    \ [\"name\", \"of\", \"string\"])\n/// \"string\"\n/// >>> find_max(words: [\"\
    name\", \"enam\", \"game\"])\n/// \"enam\"\n/// >>> find_max(words: [\"aaaaaaa\"\
    , \"bb\", \"cc\"])\n/// \"aaaaaaa\"\nfunc find_max(words: [String]) -> String\
    \ {\n    return words.sorted(by: { (a, b) -> Bool in\n        let aUnique = Set(a.map\
    \ { String($0) })\n        let bUnique = Set(b.map { String($0) })\n        if\
    \ aUnique.count == bUnique.count {\n            return a < b\n        }\n    \
    \    return aUnique.count > bUnique.count\n    }).first!\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(find_max(words: [\"name\", \"of\", \"string\"]) == \"\
    string\")\nassert(find_max(words: [\"name\", \"enam\", \"game\"]) == \"enam\"\
    )\nassert(find_max(words: [\"aaaaaaa\", \"bb\", \"cc\"]) == \"aaaaaaa\")\nassert(find_max(words:\
    \ [\"abc\", \"cba\"]) == \"abc\")\nassert(find_max(words: [\"play\", \"this\"\
    , \"game\", \"of\", \"footbott\"]) == \"footbott\")\nassert(find_max(words: [\"\
    we\", \"are\", \"gonna\", \"rock\"]) == \"gonna\")\nassert(find_max(words: [\"\
    we\", \"are\", \"a\", \"mad\", \"nation\"]) == \"nation\")\nassert(find_max(words:\
    \ [\"this\", \"is\", \"a\", \"prrk\"]) == \"this\")\nassert(find_max(words: [\"\
    b\"]) == \"b\")\nassert(find_max(words: [\"play\", \"play\", \"play\"]) == \"\
    play\")"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660013455
- exit_code: -4
  program: "\n/// Write a function that accepts an array of strings.\n/// The array\
    \ contains different words. Return the word with maximum number\n/// of unique\
    \ characters. If multiple strings have maximum number of unique\n/// characters,\
    \ return the one which comes first in lexicographical order.\n/// >>> find_max(words:\
    \ [\"name\", \"of\", \"string\"])\n/// \"string\"\n/// >>> find_max(words: [\"\
    name\", \"enam\", \"game\"])\n/// \"enam\"\n/// >>> find_max(words: [\"aaaaaaa\"\
    , \"bb\", \"cc\"])\n/// \"aaaaaaa\"\nfunc find_max(words: [String]) -> String\
    \ {\n    // put your code here\n    return \"\"\n}\n\n\nfunc ==(left: [(Int, Int)],\
    \ right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n       \
    \ return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r\
    \ {\n            return false\n        }\n    }\n    return true\n}\n        \
    \    \nassert(find_max(words: [\"name\", \"of\", \"string\"]) == \"string\")\n\
    assert(find_max(words: [\"name\", \"enam\", \"game\"]) == \"enam\")\nassert(find_max(words:\
    \ [\"aaaaaaa\", \"bb\", \"cc\"]) == \"aaaaaaa\")\nassert(find_max(words: [\"abc\"\
    , \"cba\"]) == \"abc\")\nassert(find_max(words: [\"play\", \"this\", \"game\"\
    , \"of\", \"footbott\"]) == \"footbott\")\nassert(find_max(words: [\"we\", \"\
    are\", \"gonna\", \"rock\"]) == \"gonna\")\nassert(find_max(words: [\"we\", \"\
    are\", \"a\", \"mad\", \"nation\"]) == \"nation\")\nassert(find_max(words: [\"\
    this\", \"is\", \"a\", \"prrk\"]) == \"this\")\nassert(find_max(words: [\"b\"\
    ]) == \"b\")\nassert(find_max(words: [\"play\", \"play\", \"play\"]) == \"play\"\
    )"
  status: Exception
  stderr: 'tmpr80zb0vs/tmpr80zb0vs.swift:30: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b279a1b7c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b2799eaeb6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b2799eae988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b2799ead7b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpr80zb0vs                        0x000055a711b0c4ce <unavailable> + 5326

    5    libc.so.6                          0x00002b279a3a3460 __libc_start_main +
    245

    6    tmpr80zb0vs                        0x000055a711b0c089 <unavailable> + 4233

    '
  stdout: ''
  timestamp: 1660013455
- exit_code: -4
  program: "\n/// Write a function that accepts an array of strings.\n/// The array\
    \ contains different words. Return the word with maximum number\n/// of unique\
    \ characters. If multiple strings have maximum number of unique\n/// characters,\
    \ return the one which comes first in lexicographical order.\n/// >>> find_max(words:\
    \ [\"name\", \"of\", \"string\"])\n/// \"string\"\n/// >>> find_max(words: [\"\
    name\", \"enam\", \"game\"])\n/// \"enam\"\n/// >>> find_max(words: [\"aaaaaaa\"\
    , \"bb\", \"cc\"])\n/// \"aaaaaaa\"\nfunc find_max(words: [String]) -> String\
    \ {\n    var str = \"\"\n    var charCount = 0\n    for word in words {\n    \
    \    let set = Set(word)\n        if set.count > charCount {\n            str\
    \ = word\n            charCount = set.count\n        }\n    }\n    return str\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(find_max(words: [\"name\", \"of\", \"string\"\
    ]) == \"string\")\nassert(find_max(words: [\"name\", \"enam\", \"game\"]) == \"\
    enam\")\nassert(find_max(words: [\"aaaaaaa\", \"bb\", \"cc\"]) == \"aaaaaaa\"\
    )\nassert(find_max(words: [\"abc\", \"cba\"]) == \"abc\")\nassert(find_max(words:\
    \ [\"play\", \"this\", \"game\", \"of\", \"footbott\"]) == \"footbott\")\nassert(find_max(words:\
    \ [\"we\", \"are\", \"gonna\", \"rock\"]) == \"gonna\")\nassert(find_max(words:\
    \ [\"we\", \"are\", \"a\", \"mad\", \"nation\"]) == \"nation\")\nassert(find_max(words:\
    \ [\"this\", \"is\", \"a\", \"prrk\"]) == \"this\")\nassert(find_max(words: [\"\
    b\"]) == \"b\")\nassert(find_max(words: [\"play\", \"play\", \"play\"]) == \"\
    play\")"
  status: Exception
  stderr: 'tmpaz9va8_v/tmpaz9va8_v.swift:39: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002acb40b80c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002acb40877b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002acb40877988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002acb408767b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpaz9va8_v                        0x00005583add58933 <unavailable> + 6451

    5    libc.so.6                          0x00002acb40d6c460 __libc_start_main +
    245

    6    tmpaz9va8_v                        0x00005583add58359 <unavailable> + 4953

    '
  stdout: ''
  timestamp: 1660013455
- exit_code: -4
  program: "\n/// Write a function that accepts an array of strings.\n/// The array\
    \ contains different words. Return the word with maximum number\n/// of unique\
    \ characters. If multiple strings have maximum number of unique\n/// characters,\
    \ return the one which comes first in lexicographical order.\n/// >>> find_max(words:\
    \ [\"name\", \"of\", \"string\"])\n/// \"string\"\n/// >>> find_max(words: [\"\
    name\", \"enam\", \"game\"])\n/// \"enam\"\n/// >>> find_max(words: [\"aaaaaaa\"\
    , \"bb\", \"cc\"])\n/// \"aaaaaaa\"\nfunc find_max(words: [String]) -> String\
    \ {\n    return \"\"\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(find_max(words:\
    \ [\"name\", \"of\", \"string\"]) == \"string\")\nassert(find_max(words: [\"name\"\
    , \"enam\", \"game\"]) == \"enam\")\nassert(find_max(words: [\"aaaaaaa\", \"bb\"\
    , \"cc\"]) == \"aaaaaaa\")\nassert(find_max(words: [\"abc\", \"cba\"]) == \"abc\"\
    )\nassert(find_max(words: [\"play\", \"this\", \"game\", \"of\", \"footbott\"\
    ]) == \"footbott\")\nassert(find_max(words: [\"we\", \"are\", \"gonna\", \"rock\"\
    ]) == \"gonna\")\nassert(find_max(words: [\"we\", \"are\", \"a\", \"mad\", \"\
    nation\"]) == \"nation\")\nassert(find_max(words: [\"this\", \"is\", \"a\", \"\
    prrk\"]) == \"this\")\nassert(find_max(words: [\"b\"]) == \"b\")\nassert(find_max(words:\
    \ [\"play\", \"play\", \"play\"]) == \"play\")"
  status: Exception
  stderr: 'tmp9vfthvyx/tmp9vfthvyx.swift:29: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b5bb598bc80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b5bb5682b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b5bb5682988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b5bb56817b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmp9vfthvyx                        0x0000564c87ea64ce <unavailable> + 5326

    5    libc.so.6                          0x00002b5bb5b77460 __libc_start_main +
    245

    6    tmp9vfthvyx                        0x0000564c87ea6089 <unavailable> + 4233

    '
  stdout: ''
  timestamp: 1660013265
- exit_code: -4
  program: "\n/// Write a function that accepts an array of strings.\n/// The array\
    \ contains different words. Return the word with maximum number\n/// of unique\
    \ characters. If multiple strings have maximum number of unique\n/// characters,\
    \ return the one which comes first in lexicographical order.\n/// >>> find_max(words:\
    \ [\"name\", \"of\", \"string\"])\n/// \"string\"\n/// >>> find_max(words: [\"\
    name\", \"enam\", \"game\"])\n/// \"enam\"\n/// >>> find_max(words: [\"aaaaaaa\"\
    , \"bb\", \"cc\"])\n/// \"aaaaaaa\"\nfunc find_max(words: [String]) -> String\
    \ {\n    // YOUR CODE HERE\n    let uniqueChars = words.map { (word) -> [Character]\
    \ in\n        var unique = [Character]()\n        for char in word {\n       \
    \     if !unique.contains(char) {\n                unique.append(char)\n     \
    \       }\n        }\n        return unique\n    }\n    let max = uniqueChars.max\
    \ { (first, second) -> Bool in\n        first.count < second.count\n    }\n  \
    \  let index = uniqueChars.firstIndex(of: max!)\n    return words[index!]\n}\n\
    \n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(find_max(words: [\"name\", \"of\", \"string\"\
    ]) == \"string\")\nassert(find_max(words: [\"name\", \"enam\", \"game\"]) == \"\
    enam\")\nassert(find_max(words: [\"aaaaaaa\", \"bb\", \"cc\"]) == \"aaaaaaa\"\
    )\nassert(find_max(words: [\"abc\", \"cba\"]) == \"abc\")\nassert(find_max(words:\
    \ [\"play\", \"this\", \"game\", \"of\", \"footbott\"]) == \"footbott\")\nassert(find_max(words:\
    \ [\"we\", \"are\", \"gonna\", \"rock\"]) == \"gonna\")\nassert(find_max(words:\
    \ [\"we\", \"are\", \"a\", \"mad\", \"nation\"]) == \"nation\")\nassert(find_max(words:\
    \ [\"this\", \"is\", \"a\", \"prrk\"]) == \"this\")\nassert(find_max(words: [\"\
    b\"]) == \"b\")\nassert(find_max(words: [\"play\", \"play\", \"play\"]) == \"\
    play\")"
  status: Exception
  stderr: 'tmpp9mr984j/tmpp9mr984j.swift:44: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b708f287c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b708ef7eb6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b708ef7e988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b708ef7d7b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpp9mr984j                        0x000055a34f2b1b73 <unavailable> + 7027

    5    libc.so.6                          0x00002b708f473460 __libc_start_main +
    245

    6    tmpp9mr984j                        0x000055a34f2b1599 <unavailable> + 5529

    '
  stdout: ''
  timestamp: 1660013455
- exit_code: -4
  program: "\n/// Write a function that accepts an array of strings.\n/// The array\
    \ contains different words. Return the word with maximum number\n/// of unique\
    \ characters. If multiple strings have maximum number of unique\n/// characters,\
    \ return the one which comes first in lexicographical order.\n/// >>> find_max(words:\
    \ [\"name\", \"of\", \"string\"])\n/// \"string\"\n/// >>> find_max(words: [\"\
    name\", \"enam\", \"game\"])\n/// \"enam\"\n/// >>> find_max(words: [\"aaaaaaa\"\
    , \"bb\", \"cc\"])\n/// \"aaaaaaa\"\nfunc find_max(words: [String]) -> String\
    \ {\n    return words.reduce(words[0]) { (last, curr) in\n        if last.count\
    \ < curr.count {\n            return curr\n        } else if last.count == curr.count\
    \ {\n            if last < curr {\n                return last\n            }\
    \ else {\n                return curr\n            }\n        } else {\n     \
    \       return last\n        }\n    }\n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(find_max(words: [\"name\", \"of\", \"string\"]) == \"string\")\nassert(find_max(words:\
    \ [\"name\", \"enam\", \"game\"]) == \"enam\")\nassert(find_max(words: [\"aaaaaaa\"\
    , \"bb\", \"cc\"]) == \"aaaaaaa\")\nassert(find_max(words: [\"abc\", \"cba\"])\
    \ == \"abc\")\nassert(find_max(words: [\"play\", \"this\", \"game\", \"of\", \"\
    footbott\"]) == \"footbott\")\nassert(find_max(words: [\"we\", \"are\", \"gonna\"\
    , \"rock\"]) == \"gonna\")\nassert(find_max(words: [\"we\", \"are\", \"a\", \"\
    mad\", \"nation\"]) == \"nation\")\nassert(find_max(words: [\"this\", \"is\",\
    \ \"a\", \"prrk\"]) == \"this\")\nassert(find_max(words: [\"b\"]) == \"b\")\n\
    assert(find_max(words: [\"play\", \"play\", \"play\"]) == \"play\")"
  status: Exception
  stderr: 'tmp0i8of6lr/tmp0i8of6lr.swift:48: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b37c283cc80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b37c2533b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b37c2533988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b37c25327b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmp0i8of6lr                        0x000055cbf8a9e2ee <unavailable> + 8942

    5    libc.so.6                          0x00002b37c2a28460 __libc_start_main +
    245

    6    tmp0i8of6lr                        0x000055cbf8a9d1f9 <unavailable> + 4601

    '
  stdout: ''
  timestamp: 1660013455
- exit_code: 1
  program: "\n/// Write a function that accepts an array of strings.\n/// The array\
    \ contains different words. Return the word with maximum number\n/// of unique\
    \ characters. If multiple strings have maximum number of unique\n/// characters,\
    \ return the one which comes first in lexicographical order.\n/// >>> find_max(words:\
    \ [\"name\", \"of\", \"string\"])\n/// \"string\"\n/// >>> find_max(words: [\"\
    name\", \"enam\", \"game\"])\n/// \"enam\"\n/// >>> find_max(words: [\"aaaaaaa\"\
    , \"bb\", \"cc\"])\n/// \"aaaaaaa\"\nfunc find_max(words: [String]) -> String\
    \ {\n    var maxWords: [String] = []\n    var maxWord = \"\"\n    var maxUniqueChars\
    \ = 0\n    for word in words {\n        let uniqueChars = Set(word.characters)\n\
    \        if uniqueChars.count > maxUniqueChars {\n            maxWords = [word]\n\
    \            maxUniqueChars = uniqueChars.count\n        } else if uniqueChars.count\
    \ == maxUniqueChars {\n            maxWords.append(word)\n        }\n    }\n \
    \   for maxWord in maxWords {\n        if maxWord < maxWords[0] {\n          \
    \  maxWords[0] = maxWord\n        }\n    }\n    return maxWords[0]\n}\n\n\nfunc\
    \ ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count !=\
    \ right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(find_max(words: [\"name\", \"of\", \"string\"\
    ]) == \"string\")\nassert(find_max(words: [\"name\", \"enam\", \"game\"]) == \"\
    enam\")\nassert(find_max(words: [\"aaaaaaa\", \"bb\", \"cc\"]) == \"aaaaaaa\"\
    )\nassert(find_max(words: [\"abc\", \"cba\"]) == \"abc\")\nassert(find_max(words:\
    \ [\"play\", \"this\", \"game\", \"of\", \"footbott\"]) == \"footbott\")\nassert(find_max(words:\
    \ [\"we\", \"are\", \"gonna\", \"rock\"]) == \"gonna\")\nassert(find_max(words:\
    \ [\"we\", \"are\", \"a\", \"mad\", \"nation\"]) == \"nation\")\nassert(find_max(words:\
    \ [\"this\", \"is\", \"a\", \"prrk\"]) == \"this\")\nassert(find_max(words: [\"\
    b\"]) == \"b\")\nassert(find_max(words: [\"play\", \"play\", \"play\"]) == \"\
    play\")"
  status: SyntaxError
  stderr: "/tmp/tmpsv6o8v4h.swift:17:36: error: 'characters' is unavailable: Please\
    \ use String directly\n        let uniqueChars = Set(word.characters)\n      \
    \                             ^~~~~~~~~~\nSwift.String:5:16: note: 'characters'\
    \ was obsoleted in Swift 5.0\n    public var characters: String { get set }\n\
    \               ^\n/tmp/tmpsv6o8v4h.swift:14:9: warning: initialization of variable\
    \ 'maxWord' was never used; consider replacing with assignment to '_' or removing\
    \ it\n    var maxWord = \"\"\n    ~~~~^~~~~~~\n    _\n"
  stdout: ''
  timestamp: 1660013455
- exit_code: -4
  program: "\n/// Write a function that accepts an array of strings.\n/// The array\
    \ contains different words. Return the word with maximum number\n/// of unique\
    \ characters. If multiple strings have maximum number of unique\n/// characters,\
    \ return the one which comes first in lexicographical order.\n/// >>> find_max(words:\
    \ [\"name\", \"of\", \"string\"])\n/// \"string\"\n/// >>> find_max(words: [\"\
    name\", \"enam\", \"game\"])\n/// \"enam\"\n/// >>> find_max(words: [\"aaaaaaa\"\
    , \"bb\", \"cc\"])\n/// \"aaaaaaa\"\nfunc find_max(words: [String]) -> String\
    \ {\n    var maxWord = \"\"\n    var maxCount = 0\n    for word in words {\n \
    \       let set = Set(word)\n        if set.count > maxCount {\n            maxCount\
    \ = set.count\n            maxWord = word\n        }\n    }\n    return maxWord\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(find_max(words: [\"name\", \"of\", \"string\"\
    ]) == \"string\")\nassert(find_max(words: [\"name\", \"enam\", \"game\"]) == \"\
    enam\")\nassert(find_max(words: [\"aaaaaaa\", \"bb\", \"cc\"]) == \"aaaaaaa\"\
    )\nassert(find_max(words: [\"abc\", \"cba\"]) == \"abc\")\nassert(find_max(words:\
    \ [\"play\", \"this\", \"game\", \"of\", \"footbott\"]) == \"footbott\")\nassert(find_max(words:\
    \ [\"we\", \"are\", \"gonna\", \"rock\"]) == \"gonna\")\nassert(find_max(words:\
    \ [\"we\", \"are\", \"a\", \"mad\", \"nation\"]) == \"nation\")\nassert(find_max(words:\
    \ [\"this\", \"is\", \"a\", \"prrk\"]) == \"this\")\nassert(find_max(words: [\"\
    b\"]) == \"b\")\nassert(find_max(words: [\"play\", \"play\", \"play\"]) == \"\
    play\")"
  status: Exception
  stderr: 'tmpvm4n8qtq/tmpvm4n8qtq.swift:39: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b881b18cc80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b881ae83b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b881ae83988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b881ae827b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpvm4n8qtq                        0x00005612fbfa6933 <unavailable> + 6451

    5    libc.so.6                          0x00002b881b378460 __libc_start_main +
    245

    6    tmpvm4n8qtq                        0x00005612fbfa6359 <unavailable> + 4953

    '
  stdout: ''
  timestamp: 1660013455
- exit_code: -4
  program: "\n/// Write a function that accepts an array of strings.\n/// The array\
    \ contains different words. Return the word with maximum number\n/// of unique\
    \ characters. If multiple strings have maximum number of unique\n/// characters,\
    \ return the one which comes first in lexicographical order.\n/// >>> find_max(words:\
    \ [\"name\", \"of\", \"string\"])\n/// \"string\"\n/// >>> find_max(words: [\"\
    name\", \"enam\", \"game\"])\n/// \"enam\"\n/// >>> find_max(words: [\"aaaaaaa\"\
    , \"bb\", \"cc\"])\n/// \"aaaaaaa\"\nfunc find_max(words: [String]) -> String\
    \ {\n    var uniqueWords = [String:Int]()\n    for i in words {\n        uniqueWords[i]\
    \ = i.count\n    }\n    let myArray = uniqueWords.sorted {$0.value > $1.value\
    \ }\n    return myArray[0].key\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int,\
    \ Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n\
    \    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n          \
    \  return false\n        }\n    }\n    return true\n}\n            \nassert(find_max(words:\
    \ [\"name\", \"of\", \"string\"]) == \"string\")\nassert(find_max(words: [\"name\"\
    , \"enam\", \"game\"]) == \"enam\")\nassert(find_max(words: [\"aaaaaaa\", \"bb\"\
    , \"cc\"]) == \"aaaaaaa\")\nassert(find_max(words: [\"abc\", \"cba\"]) == \"abc\"\
    )\nassert(find_max(words: [\"play\", \"this\", \"game\", \"of\", \"footbott\"\
    ]) == \"footbott\")\nassert(find_max(words: [\"we\", \"are\", \"gonna\", \"rock\"\
    ]) == \"gonna\")\nassert(find_max(words: [\"we\", \"are\", \"a\", \"mad\", \"\
    nation\"]) == \"nation\")\nassert(find_max(words: [\"this\", \"is\", \"a\", \"\
    prrk\"]) == \"this\")\nassert(find_max(words: [\"b\"]) == \"b\")\nassert(find_max(words:\
    \ [\"play\", \"play\", \"play\"]) == \"play\")"
  status: Exception
  stderr: 'tmpf_ee0wub/tmpf_ee0wub.swift:41: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002af80028bc80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002af7fff82b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002af7fff82988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002af7fff817b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpf_ee0wub                        0x00005602b03bb50e <unavailable> + 9486

    5    libc.so.6                          0x00002af800477460 __libc_start_main +
    245

    6    tmpf_ee0wub                        0x00005602b03ba419 <unavailable> + 5145

    '
  stdout: ''
  timestamp: 1660013455
- exit_code: -4
  program: "\n/// Write a function that accepts an array of strings.\n/// The array\
    \ contains different words. Return the word with maximum number\n/// of unique\
    \ characters. If multiple strings have maximum number of unique\n/// characters,\
    \ return the one which comes first in lexicographical order.\n/// >>> find_max(words:\
    \ [\"name\", \"of\", \"string\"])\n/// \"string\"\n/// >>> find_max(words: [\"\
    name\", \"enam\", \"game\"])\n/// \"enam\"\n/// >>> find_max(words: [\"aaaaaaa\"\
    , \"bb\", \"cc\"])\n/// \"aaaaaaa\"\nfunc find_max(words: [String]) -> String\
    \ {\n    var ret = \"\"\n    var max_seen = 0\n    for word in words {\n     \
    \   let unique_chars = Set(word)\n        if unique_chars.count > max_seen {\n\
    \            max_seen = unique_chars.count\n            ret = word\n        }\n\
    \    }\n    return ret\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(find_max(words:\
    \ [\"name\", \"of\", \"string\"]) == \"string\")\nassert(find_max(words: [\"name\"\
    , \"enam\", \"game\"]) == \"enam\")\nassert(find_max(words: [\"aaaaaaa\", \"bb\"\
    , \"cc\"]) == \"aaaaaaa\")\nassert(find_max(words: [\"abc\", \"cba\"]) == \"abc\"\
    )\nassert(find_max(words: [\"play\", \"this\", \"game\", \"of\", \"footbott\"\
    ]) == \"footbott\")\nassert(find_max(words: [\"we\", \"are\", \"gonna\", \"rock\"\
    ]) == \"gonna\")\nassert(find_max(words: [\"we\", \"are\", \"a\", \"mad\", \"\
    nation\"]) == \"nation\")\nassert(find_max(words: [\"this\", \"is\", \"a\", \"\
    prrk\"]) == \"this\")\nassert(find_max(words: [\"b\"]) == \"b\")\nassert(find_max(words:\
    \ [\"play\", \"play\", \"play\"]) == \"play\")"
  status: Exception
  stderr: 'tmpfu4sjwoi/tmpfu4sjwoi.swift:39: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b85db962c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b85db659b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b85db659988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b85db6587b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpfu4sjwoi                        0x000055debd710933 <unavailable> + 6451

    5    libc.so.6                          0x00002b85dbb4e460 __libc_start_main +
    245

    6    tmpfu4sjwoi                        0x000055debd710359 <unavailable> + 4953

    '
  stdout: ''
  timestamp: 1660013455
- exit_code: 1
  program: "\n/// Write a function that accepts an array of strings.\n/// The array\
    \ contains different words. Return the word with maximum number\n/// of unique\
    \ characters. If multiple strings have maximum number of unique\n/// characters,\
    \ return the one which comes first in lexicographical order.\n/// >>> find_max(words:\
    \ [\"name\", \"of\", \"string\"])\n/// \"string\"\n/// >>> find_max(words: [\"\
    name\", \"enam\", \"game\"])\n/// \"enam\"\n/// >>> find_max(words: [\"aaaaaaa\"\
    , \"bb\", \"cc\"])\n/// \"aaaaaaa\"\nfunc find_max(words: [String]) -> String\
    \ {\n    return words.max { word1, word2 in\n        let n1 = word1.lengthOfLongestSubstring()\n\
    \        let n2 = word2.lengthOfLongestSubstring()\n        if n1 == n2 {\n  \
    \          return word1 < word2\n        }\n        return n1 > n2\n    }!\n}\n\
    \n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(find_max(words: [\"name\", \"of\", \"string\"\
    ]) == \"string\")\nassert(find_max(words: [\"name\", \"enam\", \"game\"]) == \"\
    enam\")\nassert(find_max(words: [\"aaaaaaa\", \"bb\", \"cc\"]) == \"aaaaaaa\"\
    )\nassert(find_max(words: [\"abc\", \"cba\"]) == \"abc\")\nassert(find_max(words:\
    \ [\"play\", \"this\", \"game\", \"of\", \"footbott\"]) == \"footbott\")\nassert(find_max(words:\
    \ [\"we\", \"are\", \"gonna\", \"rock\"]) == \"gonna\")\nassert(find_max(words:\
    \ [\"we\", \"are\", \"a\", \"mad\", \"nation\"]) == \"nation\")\nassert(find_max(words:\
    \ [\"this\", \"is\", \"a\", \"prrk\"]) == \"this\")\nassert(find_max(words: [\"\
    b\"]) == \"b\")\nassert(find_max(words: [\"play\", \"play\", \"play\"]) == \"\
    play\")"
  status: SyntaxError
  stderr: "/tmp/tmpew2_s91g.swift:14:24: error: value of type 'String' has no member\
    \ 'lengthOfLongestSubstring'\n        let n1 = word1.lengthOfLongestSubstring()\n\
    \                 ~~~~~ ^~~~~~~~~~~~~~~~~~~~~~~~\n"
  stdout: ''
  timestamp: 1660013455
- exit_code: -4
  program: "\n/// Write a function that accepts an array of strings.\n/// The array\
    \ contains different words. Return the word with maximum number\n/// of unique\
    \ characters. If multiple strings have maximum number of unique\n/// characters,\
    \ return the one which comes first in lexicographical order.\n/// >>> find_max(words:\
    \ [\"name\", \"of\", \"string\"])\n/// \"string\"\n/// >>> find_max(words: [\"\
    name\", \"enam\", \"game\"])\n/// \"enam\"\n/// >>> find_max(words: [\"aaaaaaa\"\
    , \"bb\", \"cc\"])\n/// \"aaaaaaa\"\nfunc find_max(words: [String]) -> String\
    \ {\n    return \"\"\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(find_max(words:\
    \ [\"name\", \"of\", \"string\"]) == \"string\")\nassert(find_max(words: [\"name\"\
    , \"enam\", \"game\"]) == \"enam\")\nassert(find_max(words: [\"aaaaaaa\", \"bb\"\
    , \"cc\"]) == \"aaaaaaa\")\nassert(find_max(words: [\"abc\", \"cba\"]) == \"abc\"\
    )\nassert(find_max(words: [\"play\", \"this\", \"game\", \"of\", \"footbott\"\
    ]) == \"footbott\")\nassert(find_max(words: [\"we\", \"are\", \"gonna\", \"rock\"\
    ]) == \"gonna\")\nassert(find_max(words: [\"we\", \"are\", \"a\", \"mad\", \"\
    nation\"]) == \"nation\")\nassert(find_max(words: [\"this\", \"is\", \"a\", \"\
    prrk\"]) == \"this\")\nassert(find_max(words: [\"b\"]) == \"b\")\nassert(find_max(words:\
    \ [\"play\", \"play\", \"play\"]) == \"play\")"
  status: Exception
  stderr: 'tmp9vfthvyx/tmp9vfthvyx.swift:29: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b5bb598bc80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b5bb5682b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b5bb5682988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b5bb56817b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmp9vfthvyx                        0x0000564c87ea64ce <unavailable> + 5326

    5    libc.so.6                          0x00002b5bb5b77460 __libc_start_main +
    245

    6    tmp9vfthvyx                        0x0000564c87ea6089 <unavailable> + 4233

    '
  stdout: ''
  timestamp: 1660013265
- exit_code: -4
  program: "\n/// Write a function that accepts an array of strings.\n/// The array\
    \ contains different words. Return the word with maximum number\n/// of unique\
    \ characters. If multiple strings have maximum number of unique\n/// characters,\
    \ return the one which comes first in lexicographical order.\n/// >>> find_max(words:\
    \ [\"name\", \"of\", \"string\"])\n/// \"string\"\n/// >>> find_max(words: [\"\
    name\", \"enam\", \"game\"])\n/// \"enam\"\n/// >>> find_max(words: [\"aaaaaaa\"\
    , \"bb\", \"cc\"])\n/// \"aaaaaaa\"\nfunc find_max(words: [String]) -> String\
    \ {\n  var maxString = \"\"\n  var maxCount = 0\n  for word in words {\n    let\
    \ set = Set(word)\n    if set.count > maxCount {\n      maxCount = set.count\n\
    \      maxString = word\n    }\n  }\n  return maxString\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(find_max(words: [\"name\", \"of\", \"string\"]) == \"\
    string\")\nassert(find_max(words: [\"name\", \"enam\", \"game\"]) == \"enam\"\
    )\nassert(find_max(words: [\"aaaaaaa\", \"bb\", \"cc\"]) == \"aaaaaaa\")\nassert(find_max(words:\
    \ [\"abc\", \"cba\"]) == \"abc\")\nassert(find_max(words: [\"play\", \"this\"\
    , \"game\", \"of\", \"footbott\"]) == \"footbott\")\nassert(find_max(words: [\"\
    we\", \"are\", \"gonna\", \"rock\"]) == \"gonna\")\nassert(find_max(words: [\"\
    we\", \"are\", \"a\", \"mad\", \"nation\"]) == \"nation\")\nassert(find_max(words:\
    \ [\"this\", \"is\", \"a\", \"prrk\"]) == \"this\")\nassert(find_max(words: [\"\
    b\"]) == \"b\")\nassert(find_max(words: [\"play\", \"play\", \"play\"]) == \"\
    play\")"
  status: Exception
  stderr: 'tmp763vcva3/tmp763vcva3.swift:39: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b604cebec80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b604cbb5b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b604cbb5988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b604cbb47b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmp763vcva3                        0x000055dff46f1933 <unavailable> + 6451

    5    libc.so.6                          0x00002b604d0aa460 __libc_start_main +
    245

    6    tmp763vcva3                        0x000055dff46f1359 <unavailable> + 4953

    '
  stdout: ''
  timestamp: 1660013455
- exit_code: -4
  program: "\n/// Write a function that accepts an array of strings.\n/// The array\
    \ contains different words. Return the word with maximum number\n/// of unique\
    \ characters. If multiple strings have maximum number of unique\n/// characters,\
    \ return the one which comes first in lexicographical order.\n/// >>> find_max(words:\
    \ [\"name\", \"of\", \"string\"])\n/// \"string\"\n/// >>> find_max(words: [\"\
    name\", \"enam\", \"game\"])\n/// \"enam\"\n/// >>> find_max(words: [\"aaaaaaa\"\
    , \"bb\", \"cc\"])\n/// \"aaaaaaa\"\nfunc find_max(words: [String]) -> String\
    \ {\n    return \"\"\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(find_max(words:\
    \ [\"name\", \"of\", \"string\"]) == \"string\")\nassert(find_max(words: [\"name\"\
    , \"enam\", \"game\"]) == \"enam\")\nassert(find_max(words: [\"aaaaaaa\", \"bb\"\
    , \"cc\"]) == \"aaaaaaa\")\nassert(find_max(words: [\"abc\", \"cba\"]) == \"abc\"\
    )\nassert(find_max(words: [\"play\", \"this\", \"game\", \"of\", \"footbott\"\
    ]) == \"footbott\")\nassert(find_max(words: [\"we\", \"are\", \"gonna\", \"rock\"\
    ]) == \"gonna\")\nassert(find_max(words: [\"we\", \"are\", \"a\", \"mad\", \"\
    nation\"]) == \"nation\")\nassert(find_max(words: [\"this\", \"is\", \"a\", \"\
    prrk\"]) == \"this\")\nassert(find_max(words: [\"b\"]) == \"b\")\nassert(find_max(words:\
    \ [\"play\", \"play\", \"play\"]) == \"play\")"
  status: Exception
  stderr: 'tmp9vfthvyx/tmp9vfthvyx.swift:29: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b5bb598bc80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b5bb5682b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b5bb5682988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b5bb56817b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmp9vfthvyx                        0x0000564c87ea64ce <unavailable> + 5326

    5    libc.so.6                          0x00002b5bb5b77460 __libc_start_main +
    245

    6    tmp9vfthvyx                        0x0000564c87ea6089 <unavailable> + 4233

    '
  stdout: ''
  timestamp: 1660013265
- exit_code: -4
  program: "\n/// Write a function that accepts an array of strings.\n/// The array\
    \ contains different words. Return the word with maximum number\n/// of unique\
    \ characters. If multiple strings have maximum number of unique\n/// characters,\
    \ return the one which comes first in lexicographical order.\n/// >>> find_max(words:\
    \ [\"name\", \"of\", \"string\"])\n/// \"string\"\n/// >>> find_max(words: [\"\
    name\", \"enam\", \"game\"])\n/// \"enam\"\n/// >>> find_max(words: [\"aaaaaaa\"\
    , \"bb\", \"cc\"])\n/// \"aaaaaaa\"\nfunc find_max(words: [String]) -> String\
    \ {\n    var currentWord = \"\"\n    var currentCount = 0\n    for word in words\
    \ {\n        let uniqueCount = Set(word).count\n        if uniqueCount > currentCount\
    \ {\n            currentCount = uniqueCount\n            currentWord = word\n\
    \        }\n    }\n    return currentWord\n}\n\n\nfunc ==(left: [(Int, Int)],\
    \ right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n       \
    \ return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r\
    \ {\n            return false\n        }\n    }\n    return true\n}\n        \
    \    \nassert(find_max(words: [\"name\", \"of\", \"string\"]) == \"string\")\n\
    assert(find_max(words: [\"name\", \"enam\", \"game\"]) == \"enam\")\nassert(find_max(words:\
    \ [\"aaaaaaa\", \"bb\", \"cc\"]) == \"aaaaaaa\")\nassert(find_max(words: [\"abc\"\
    , \"cba\"]) == \"abc\")\nassert(find_max(words: [\"play\", \"this\", \"game\"\
    , \"of\", \"footbott\"]) == \"footbott\")\nassert(find_max(words: [\"we\", \"\
    are\", \"gonna\", \"rock\"]) == \"gonna\")\nassert(find_max(words: [\"we\", \"\
    are\", \"a\", \"mad\", \"nation\"]) == \"nation\")\nassert(find_max(words: [\"\
    this\", \"is\", \"a\", \"prrk\"]) == \"this\")\nassert(find_max(words: [\"b\"\
    ]) == \"b\")\nassert(find_max(words: [\"play\", \"play\", \"play\"]) == \"play\"\
    )"
  status: Exception
  stderr: 'tmp3ks_crht/tmp3ks_crht.swift:39: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b402423dc80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b4023f34b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b4023f34988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b4023f337b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmp3ks_crht                        0x000055fc5c0a5933 <unavailable> + 6451

    5    libc.so.6                          0x00002b4024429460 __libc_start_main +
    245

    6    tmp3ks_crht                        0x000055fc5c0a5359 <unavailable> + 4953

    '
  stdout: ''
  timestamp: 1660013455
- exit_code: 1
  program: "\n/// Write a function that accepts an array of strings.\n/// The array\
    \ contains different words. Return the word with maximum number\n/// of unique\
    \ characters. If multiple strings have maximum number of unique\n/// characters,\
    \ return the one which comes first in lexicographical order.\n/// >>> find_max(words:\
    \ [\"name\", \"of\", \"string\"])\n/// \"string\"\n/// >>> find_max(words: [\"\
    name\", \"enam\", \"game\"])\n/// \"enam\"\n/// >>> find_max(words: [\"aaaaaaa\"\
    , \"bb\", \"cc\"])\n/// \"aaaaaaa\"\nfunc find_max(words: [String]) -> String\
    \ {\n    let max = words.max { (s1, s2) -> Bool in\n        return s1.unique_char_count()\
    \ < s2.unique_char_count()\n    }\n    return max ?? \"\"\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(find_max(words: [\"name\", \"of\", \"string\"]) == \"\
    string\")\nassert(find_max(words: [\"name\", \"enam\", \"game\"]) == \"enam\"\
    )\nassert(find_max(words: [\"aaaaaaa\", \"bb\", \"cc\"]) == \"aaaaaaa\")\nassert(find_max(words:\
    \ [\"abc\", \"cba\"]) == \"abc\")\nassert(find_max(words: [\"play\", \"this\"\
    , \"game\", \"of\", \"footbott\"]) == \"footbott\")\nassert(find_max(words: [\"\
    we\", \"are\", \"gonna\", \"rock\"]) == \"gonna\")\nassert(find_max(words: [\"\
    we\", \"are\", \"a\", \"mad\", \"nation\"]) == \"nation\")\nassert(find_max(words:\
    \ [\"this\", \"is\", \"a\", \"prrk\"]) == \"this\")\nassert(find_max(words: [\"\
    b\"]) == \"b\")\nassert(find_max(words: [\"play\", \"play\", \"play\"]) == \"\
    play\")"
  status: SyntaxError
  stderr: "/tmp/tmpki_sjjwi.swift:14:19: error: value of type 'String' has no member\
    \ 'unique_char_count'\n        return s1.unique_char_count() < s2.unique_char_count()\n\
    \               ~~ ^~~~~~~~~~~~~~~~~\n/tmp/tmpki_sjjwi.swift:14:44: error: value\
    \ of type 'String' has no member 'unique_char_count'\n        return s1.unique_char_count()\
    \ < s2.unique_char_count()\n                                        ~~ ^~~~~~~~~~~~~~~~~\n"
  stdout: ''
  timestamp: 1660013455
- exit_code: 1
  program: "\n/// Write a function that accepts an array of strings.\n/// The array\
    \ contains different words. Return the word with maximum number\n/// of unique\
    \ characters. If multiple strings have maximum number of unique\n/// characters,\
    \ return the one which comes first in lexicographical order.\n/// >>> find_max(words:\
    \ [\"name\", \"of\", \"string\"])\n/// \"string\"\n/// >>> find_max(words: [\"\
    name\", \"enam\", \"game\"])\n/// \"enam\"\n/// >>> find_max(words: [\"aaaaaaa\"\
    , \"bb\", \"cc\"])\n/// \"aaaaaaa\"\nfunc find_max(words: [String]) -> String\
    \ {\n    return words.max(by: {a, b in\n        let a_chars = Set(a.characters)\n\
    \        let b_chars = Set(b.characters)\n        return a_chars.count < b_chars.count\n\
    \    })!\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n\
    \    if left.count != right.count {\n        return false\n    }\n    for (l,\
    \ r) in zip(left, right) {\n        if l != r {\n            return false\n  \
    \      }\n    }\n    return true\n}\n            \nassert(find_max(words: [\"\
    name\", \"of\", \"string\"]) == \"string\")\nassert(find_max(words: [\"name\"\
    , \"enam\", \"game\"]) == \"enam\")\nassert(find_max(words: [\"aaaaaaa\", \"bb\"\
    , \"cc\"]) == \"aaaaaaa\")\nassert(find_max(words: [\"abc\", \"cba\"]) == \"abc\"\
    )\nassert(find_max(words: [\"play\", \"this\", \"game\", \"of\", \"footbott\"\
    ]) == \"footbott\")\nassert(find_max(words: [\"we\", \"are\", \"gonna\", \"rock\"\
    ]) == \"gonna\")\nassert(find_max(words: [\"we\", \"are\", \"a\", \"mad\", \"\
    nation\"]) == \"nation\")\nassert(find_max(words: [\"this\", \"is\", \"a\", \"\
    prrk\"]) == \"this\")\nassert(find_max(words: [\"b\"]) == \"b\")\nassert(find_max(words:\
    \ [\"play\", \"play\", \"play\"]) == \"play\")"
  status: SyntaxError
  stderr: "/tmp/tmp_08sarfw.swift:14:29: error: 'characters' is unavailable: Please\
    \ use String directly\n        let a_chars = Set(a.characters)\n             \
    \               ^~~~~~~~~~\nSwift.String:5:16: note: 'characters' was obsoleted\
    \ in Swift 5.0\n    public var characters: String { get set }\n              \
    \ ^\n/tmp/tmp_08sarfw.swift:15:29: error: 'characters' is unavailable: Please\
    \ use String directly\n        let b_chars = Set(b.characters)\n             \
    \               ^~~~~~~~~~\nSwift.String:5:16: note: 'characters' was obsoleted\
    \ in Swift 5.0\n    public var characters: String { get set }\n              \
    \ ^\n"
  stdout: ''
  timestamp: 1660013455
- exit_code: 1
  program: "\n/// Write a function that accepts an array of strings.\n/// The array\
    \ contains different words. Return the word with maximum number\n/// of unique\
    \ characters. If multiple strings have maximum number of unique\n/// characters,\
    \ return the one which comes first in lexicographical order.\n/// >>> find_max(words:\
    \ [\"name\", \"of\", \"string\"])\n/// \"string\"\n/// >>> find_max(words: [\"\
    name\", \"enam\", \"game\"])\n/// \"enam\"\n/// >>> find_max(words: [\"aaaaaaa\"\
    , \"bb\", \"cc\"])\n/// \"aaaaaaa\"\nfunc find_max(words: [String]) -> String\
    \ {\n    var max_word = words[0]\n    var max_count = 0\n    for word in words\
    \ {\n        let count = get_unique_letters(word: word)\n        if count > max_count\
    \ {\n            max_count = count\n            max_word = word\n        }\n \
    \   }\n    return max_word\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(find_max(words:\
    \ [\"name\", \"of\", \"string\"]) == \"string\")\nassert(find_max(words: [\"name\"\
    , \"enam\", \"game\"]) == \"enam\")\nassert(find_max(words: [\"aaaaaaa\", \"bb\"\
    , \"cc\"]) == \"aaaaaaa\")\nassert(find_max(words: [\"abc\", \"cba\"]) == \"abc\"\
    )\nassert(find_max(words: [\"play\", \"this\", \"game\", \"of\", \"footbott\"\
    ]) == \"footbott\")\nassert(find_max(words: [\"we\", \"are\", \"gonna\", \"rock\"\
    ]) == \"gonna\")\nassert(find_max(words: [\"we\", \"are\", \"a\", \"mad\", \"\
    nation\"]) == \"nation\")\nassert(find_max(words: [\"this\", \"is\", \"a\", \"\
    prrk\"]) == \"this\")\nassert(find_max(words: [\"b\"]) == \"b\")\nassert(find_max(words:\
    \ [\"play\", \"play\", \"play\"]) == \"play\")"
  status: SyntaxError
  stderr: "/tmp/tmpb869cs2w.swift:16:21: error: cannot find 'get_unique_letters' in\
    \ scope\n        let count = get_unique_letters(word: word)\n                \
    \    ^~~~~~~~~~~~~~~~~~\n"
  stdout: ''
  timestamp: 1660013455
- exit_code: 0
  program: "\n/// Write a function that accepts an array of strings.\n/// The array\
    \ contains different words. Return the word with maximum number\n/// of unique\
    \ characters. If multiple strings have maximum number of unique\n/// characters,\
    \ return the one which comes first in lexicographical order.\n/// >>> find_max(words:\
    \ [\"name\", \"of\", \"string\"])\n/// \"string\"\n/// >>> find_max(words: [\"\
    name\", \"enam\", \"game\"])\n/// \"enam\"\n/// >>> find_max(words: [\"aaaaaaa\"\
    , \"bb\", \"cc\"])\n/// \"aaaaaaa\"\nfunc find_max(words: [String]) -> String\
    \ {\n    var maxWord = \"\"\n    var maxSet = Set<Character>()\n    for word in\
    \ words {\n        let set = Set(word)\n        if set.count > maxSet.count {\n\
    \            maxSet = set\n            maxWord = word\n        } else if set.count\
    \ == maxSet.count && word < maxWord {\n            maxWord = word\n        }\n\
    \    }\n    return maxWord\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(find_max(words:\
    \ [\"name\", \"of\", \"string\"]) == \"string\")\nassert(find_max(words: [\"name\"\
    , \"enam\", \"game\"]) == \"enam\")\nassert(find_max(words: [\"aaaaaaa\", \"bb\"\
    , \"cc\"]) == \"aaaaaaa\")\nassert(find_max(words: [\"abc\", \"cba\"]) == \"abc\"\
    )\nassert(find_max(words: [\"play\", \"this\", \"game\", \"of\", \"footbott\"\
    ]) == \"footbott\")\nassert(find_max(words: [\"we\", \"are\", \"gonna\", \"rock\"\
    ]) == \"gonna\")\nassert(find_max(words: [\"we\", \"are\", \"a\", \"mad\", \"\
    nation\"]) == \"nation\")\nassert(find_max(words: [\"this\", \"is\", \"a\", \"\
    prrk\"]) == \"this\")\nassert(find_max(words: [\"b\"]) == \"b\")\nassert(find_max(words:\
    \ [\"play\", \"play\", \"play\"]) == \"play\")"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660013455
- exit_code: 0
  program: "\n/// Write a function that accepts an array of strings.\n/// The array\
    \ contains different words. Return the word with maximum number\n/// of unique\
    \ characters. If multiple strings have maximum number of unique\n/// characters,\
    \ return the one which comes first in lexicographical order.\n/// >>> find_max(words:\
    \ [\"name\", \"of\", \"string\"])\n/// \"string\"\n/// >>> find_max(words: [\"\
    name\", \"enam\", \"game\"])\n/// \"enam\"\n/// >>> find_max(words: [\"aaaaaaa\"\
    , \"bb\", \"cc\"])\n/// \"aaaaaaa\"\nfunc find_max(words: [String]) -> String\
    \ {\n  var maximumWord: String = \"\"\n  var maximumUniqueLetters: Set<Character>\
    \ = []\n  for word in words {\n    let uniqueCharacters = Set(word)\n    if uniqueCharacters.count\
    \ > maximumUniqueLetters.count {\n      maximumUniqueLetters = uniqueCharacters\n\
    \      maximumWord = word\n    } else if uniqueCharacters.count == maximumUniqueLetters.count\
    \ {\n      maximumWord = min(maximumWord, word)\n    }\n  }\n  return maximumWord\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(find_max(words: [\"name\", \"of\", \"string\"\
    ]) == \"string\")\nassert(find_max(words: [\"name\", \"enam\", \"game\"]) == \"\
    enam\")\nassert(find_max(words: [\"aaaaaaa\", \"bb\", \"cc\"]) == \"aaaaaaa\"\
    )\nassert(find_max(words: [\"abc\", \"cba\"]) == \"abc\")\nassert(find_max(words:\
    \ [\"play\", \"this\", \"game\", \"of\", \"footbott\"]) == \"footbott\")\nassert(find_max(words:\
    \ [\"we\", \"are\", \"gonna\", \"rock\"]) == \"gonna\")\nassert(find_max(words:\
    \ [\"we\", \"are\", \"a\", \"mad\", \"nation\"]) == \"nation\")\nassert(find_max(words:\
    \ [\"this\", \"is\", \"a\", \"prrk\"]) == \"this\")\nassert(find_max(words: [\"\
    b\"]) == \"b\")\nassert(find_max(words: [\"play\", \"play\", \"play\"]) == \"\
    play\")"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660013455
- exit_code: -4
  program: "\n/// Write a function that accepts an array of strings.\n/// The array\
    \ contains different words. Return the word with maximum number\n/// of unique\
    \ characters. If multiple strings have maximum number of unique\n/// characters,\
    \ return the one which comes first in lexicographical order.\n/// >>> find_max(words:\
    \ [\"name\", \"of\", \"string\"])\n/// \"string\"\n/// >>> find_max(words: [\"\
    name\", \"enam\", \"game\"])\n/// \"enam\"\n/// >>> find_max(words: [\"aaaaaaa\"\
    , \"bb\", \"cc\"])\n/// \"aaaaaaa\"\nfunc find_max(words: [String]) -> String\
    \ {\n    let chars = words.map { Set($0) }\n    let counts = chars.map { $0.count\
    \ }\n    let max_index = counts.index(of: counts.max()!)!\n    return words[max_index]\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(find_max(words: [\"name\", \"of\", \"string\"\
    ]) == \"string\")\nassert(find_max(words: [\"name\", \"enam\", \"game\"]) == \"\
    enam\")\nassert(find_max(words: [\"aaaaaaa\", \"bb\", \"cc\"]) == \"aaaaaaa\"\
    )\nassert(find_max(words: [\"abc\", \"cba\"]) == \"abc\")\nassert(find_max(words:\
    \ [\"play\", \"this\", \"game\", \"of\", \"footbott\"]) == \"footbott\")\nassert(find_max(words:\
    \ [\"we\", \"are\", \"gonna\", \"rock\"]) == \"gonna\")\nassert(find_max(words:\
    \ [\"we\", \"are\", \"a\", \"mad\", \"nation\"]) == \"nation\")\nassert(find_max(words:\
    \ [\"this\", \"is\", \"a\", \"prrk\"]) == \"this\")\nassert(find_max(words: [\"\
    b\"]) == \"b\")\nassert(find_max(words: [\"play\", \"play\", \"play\"]) == \"\
    play\")"
  status: Exception
  stderr: 'tmpzg50lw0h/tmpzg50lw0h.swift:33: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002ba7f9e7ec80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002ba7f9b75b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002ba7f9b75988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002ba7f9b747b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpzg50lw0h                        0x0000561deee0aa73 <unavailable> + 6771

    5    libc.so.6                          0x00002ba7fa06a460 __libc_start_main +
    245

    6    tmpzg50lw0h                        0x0000561deee0a499 <unavailable> + 5273

    '
  stdout: ''
  timestamp: 1660013455
- exit_code: -4
  program: "\n/// Write a function that accepts an array of strings.\n/// The array\
    \ contains different words. Return the word with maximum number\n/// of unique\
    \ characters. If multiple strings have maximum number of unique\n/// characters,\
    \ return the one which comes first in lexicographical order.\n/// >>> find_max(words:\
    \ [\"name\", \"of\", \"string\"])\n/// \"string\"\n/// >>> find_max(words: [\"\
    name\", \"enam\", \"game\"])\n/// \"enam\"\n/// >>> find_max(words: [\"aaaaaaa\"\
    , \"bb\", \"cc\"])\n/// \"aaaaaaa\"\nfunc find_max(words: [String]) -> String\
    \ {\n    var max_word = words[0]\n    var max_count = 0\n    for word in words\
    \ {\n        let unique_chars = Set(word)\n        if unique_chars.count > max_count\
    \ {\n            max_count = unique_chars.count\n            max_word = word\n\
    \        }\n    }\n    return max_word\n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(find_max(words: [\"name\", \"of\", \"string\"]) == \"string\")\nassert(find_max(words:\
    \ [\"name\", \"enam\", \"game\"]) == \"enam\")\nassert(find_max(words: [\"aaaaaaa\"\
    , \"bb\", \"cc\"]) == \"aaaaaaa\")\nassert(find_max(words: [\"abc\", \"cba\"])\
    \ == \"abc\")\nassert(find_max(words: [\"play\", \"this\", \"game\", \"of\", \"\
    footbott\"]) == \"footbott\")\nassert(find_max(words: [\"we\", \"are\", \"gonna\"\
    , \"rock\"]) == \"gonna\")\nassert(find_max(words: [\"we\", \"are\", \"a\", \"\
    mad\", \"nation\"]) == \"nation\")\nassert(find_max(words: [\"this\", \"is\",\
    \ \"a\", \"prrk\"]) == \"this\")\nassert(find_max(words: [\"b\"]) == \"b\")\n\
    assert(find_max(words: [\"play\", \"play\", \"play\"]) == \"play\")"
  status: Exception
  stderr: 'tmprusk6a8v/tmprusk6a8v.swift:39: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002acb46386c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002acb4607db6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002acb4607d988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002acb4607c7b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmprusk6a8v                        0x00005579fe481993 <unavailable> + 6547

    5    libc.so.6                          0x00002acb46572460 __libc_start_main +
    245

    6    tmprusk6a8v                        0x00005579fe4813b9 <unavailable> + 5049

    '
  stdout: ''
  timestamp: 1660013265
- exit_code: 1
  program: "\n/// Write a function that accepts an array of strings.\n/// The array\
    \ contains different words. Return the word with maximum number\n/// of unique\
    \ characters. If multiple strings have maximum number of unique\n/// characters,\
    \ return the one which comes first in lexicographical order.\n/// >>> find_max(words:\
    \ [\"name\", \"of\", \"string\"])\n/// \"string\"\n/// >>> find_max(words: [\"\
    name\", \"enam\", \"game\"])\n/// \"enam\"\n/// >>> find_max(words: [\"aaaaaaa\"\
    , \"bb\", \"cc\"])\n/// \"aaaaaaa\"\nfunc find_max(words: [String]) -> String\
    \ {\n    var maxUniq = words[0]\n    for i in 1 ..< words.count {\n        if\
    \ uniq_chars(words[i]) > uniq_chars(maxUniq) {\n            maxUniq = words[i]\n\
    \        }\n    }\n    return maxUniq\n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(find_max(words: [\"name\", \"of\", \"string\"]) == \"string\")\nassert(find_max(words:\
    \ [\"name\", \"enam\", \"game\"]) == \"enam\")\nassert(find_max(words: [\"aaaaaaa\"\
    , \"bb\", \"cc\"]) == \"aaaaaaa\")\nassert(find_max(words: [\"abc\", \"cba\"])\
    \ == \"abc\")\nassert(find_max(words: [\"play\", \"this\", \"game\", \"of\", \"\
    footbott\"]) == \"footbott\")\nassert(find_max(words: [\"we\", \"are\", \"gonna\"\
    , \"rock\"]) == \"gonna\")\nassert(find_max(words: [\"we\", \"are\", \"a\", \"\
    mad\", \"nation\"]) == \"nation\")\nassert(find_max(words: [\"this\", \"is\",\
    \ \"a\", \"prrk\"]) == \"this\")\nassert(find_max(words: [\"b\"]) == \"b\")\n\
    assert(find_max(words: [\"play\", \"play\", \"play\"]) == \"play\")"
  status: SyntaxError
  stderr: "/tmp/tmptgr0s5l_.swift:15:12: error: cannot find 'uniq_chars' in scope\n\
    \        if uniq_chars(words[i]) > uniq_chars(maxUniq) {\n           ^~~~~~~~~~\n\
    /tmp/tmptgr0s5l_.swift:15:35: error: cannot find 'uniq_chars' in scope\n     \
    \   if uniq_chars(words[i]) > uniq_chars(maxUniq) {\n                        \
    \          ^~~~~~~~~~\n"
  stdout: ''
  timestamp: 1660013455
- exit_code: -4
  program: "\n/// Write a function that accepts an array of strings.\n/// The array\
    \ contains different words. Return the word with maximum number\n/// of unique\
    \ characters. If multiple strings have maximum number of unique\n/// characters,\
    \ return the one which comes first in lexicographical order.\n/// >>> find_max(words:\
    \ [\"name\", \"of\", \"string\"])\n/// \"string\"\n/// >>> find_max(words: [\"\
    name\", \"enam\", \"game\"])\n/// \"enam\"\n/// >>> find_max(words: [\"aaaaaaa\"\
    , \"bb\", \"cc\"])\n/// \"aaaaaaa\"\nfunc find_max(words: [String]) -> String\
    \ {\n    var maxString = \"\"\n    var maxCount = 0\n    for word in words {\n\
    \        let count = Set(word).count\n        if count > maxCount {\n        \
    \    maxCount = count\n            maxString = word\n        }\n    }\n    return\
    \ maxString\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n\
    \    if left.count != right.count {\n        return false\n    }\n    for (l,\
    \ r) in zip(left, right) {\n        if l != r {\n            return false\n  \
    \      }\n    }\n    return true\n}\n            \nassert(find_max(words: [\"\
    name\", \"of\", \"string\"]) == \"string\")\nassert(find_max(words: [\"name\"\
    , \"enam\", \"game\"]) == \"enam\")\nassert(find_max(words: [\"aaaaaaa\", \"bb\"\
    , \"cc\"]) == \"aaaaaaa\")\nassert(find_max(words: [\"abc\", \"cba\"]) == \"abc\"\
    )\nassert(find_max(words: [\"play\", \"this\", \"game\", \"of\", \"footbott\"\
    ]) == \"footbott\")\nassert(find_max(words: [\"we\", \"are\", \"gonna\", \"rock\"\
    ]) == \"gonna\")\nassert(find_max(words: [\"we\", \"are\", \"a\", \"mad\", \"\
    nation\"]) == \"nation\")\nassert(find_max(words: [\"this\", \"is\", \"a\", \"\
    prrk\"]) == \"this\")\nassert(find_max(words: [\"b\"]) == \"b\")\nassert(find_max(words:\
    \ [\"play\", \"play\", \"play\"]) == \"play\")"
  status: Exception
  stderr: 'tmpfbdy7xrp/tmpfbdy7xrp.swift:39: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b53e30bcc80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b53e2db3b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b53e2db3988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b53e2db27b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpfbdy7xrp                        0x000055c4141e4933 <unavailable> + 6451

    5    libc.so.6                          0x00002b53e32a8460 __libc_start_main +
    245

    6    tmpfbdy7xrp                        0x000055c4141e4359 <unavailable> + 4953

    '
  stdout: ''
  timestamp: 1660013455
- exit_code: 1
  program: "\n/// Write a function that accepts an array of strings.\n/// The array\
    \ contains different words. Return the word with maximum number\n/// of unique\
    \ characters. If multiple strings have maximum number of unique\n/// characters,\
    \ return the one which comes first in lexicographical order.\n/// >>> find_max(words:\
    \ [\"name\", \"of\", \"string\"])\n/// \"string\"\n/// >>> find_max(words: [\"\
    name\", \"enam\", \"game\"])\n/// \"enam\"\n/// >>> find_max(words: [\"aaaaaaa\"\
    , \"bb\", \"cc\"])\n/// \"aaaaaaa\"\nfunc find_max(words: [String]) -> String\
    \ {\n    var word_and_char_count = [(word: String, char_count: Int)]()\n    for\
    \ i in 0..<words.count {\n        let unique_chars = unique_elements(array: words[i])\n\
    \        word_and_char_count.append((word: words[i], char_count: unique_chars.count))\n\
    \    }\n    let max_index = word_and_char_count.max { a, b in a.char_count < b.char_count\
    \ }?.char_count\n    let max_words = word_and_char_count.filter { $0.char_count\
    \ == max_index }\n    return max_words.first!.word\n}\n\n\nfunc ==(left: [(Int,\
    \ Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n\
    \        return false\n    }\n    for (l, r) in zip(left, right) {\n        if\
    \ l != r {\n            return false\n        }\n    }\n    return true\n}\n \
    \           \nassert(find_max(words: [\"name\", \"of\", \"string\"]) == \"string\"\
    )\nassert(find_max(words: [\"name\", \"enam\", \"game\"]) == \"enam\")\nassert(find_max(words:\
    \ [\"aaaaaaa\", \"bb\", \"cc\"]) == \"aaaaaaa\")\nassert(find_max(words: [\"abc\"\
    , \"cba\"]) == \"abc\")\nassert(find_max(words: [\"play\", \"this\", \"game\"\
    , \"of\", \"footbott\"]) == \"footbott\")\nassert(find_max(words: [\"we\", \"\
    are\", \"gonna\", \"rock\"]) == \"gonna\")\nassert(find_max(words: [\"we\", \"\
    are\", \"a\", \"mad\", \"nation\"]) == \"nation\")\nassert(find_max(words: [\"\
    this\", \"is\", \"a\", \"prrk\"]) == \"this\")\nassert(find_max(words: [\"b\"\
    ]) == \"b\")\nassert(find_max(words: [\"play\", \"play\", \"play\"]) == \"play\"\
    )"
  status: SyntaxError
  stderr: "/tmp/tmph494jg4p.swift:15:28: error: cannot find 'unique_elements' in scope\n\
    \        let unique_chars = unique_elements(array: words[i])\n               \
    \            ^~~~~~~~~~~~~~~\n"
  stdout: ''
  timestamp: 1660013455
- exit_code: -4
  program: "\n/// Write a function that accepts an array of strings.\n/// The array\
    \ contains different words. Return the word with maximum number\n/// of unique\
    \ characters. If multiple strings have maximum number of unique\n/// characters,\
    \ return the one which comes first in lexicographical order.\n/// >>> find_max(words:\
    \ [\"name\", \"of\", \"string\"])\n/// \"string\"\n/// >>> find_max(words: [\"\
    name\", \"enam\", \"game\"])\n/// \"enam\"\n/// >>> find_max(words: [\"aaaaaaa\"\
    , \"bb\", \"cc\"])\n/// \"aaaaaaa\"\nfunc find_max(words: [String]) -> String\
    \ {\n  var count = 0\n  var word = \"\"\n  for w in words {\n    let uniqueChars\
    \ = Set(w)\n    if uniqueChars.count > count {\n      count = uniqueChars.count\n\
    \      word = w\n    }\n  }\n  return word\n}\n\n\nfunc ==(left: [(Int, Int)],\
    \ right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n       \
    \ return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r\
    \ {\n            return false\n        }\n    }\n    return true\n}\n        \
    \    \nassert(find_max(words: [\"name\", \"of\", \"string\"]) == \"string\")\n\
    assert(find_max(words: [\"name\", \"enam\", \"game\"]) == \"enam\")\nassert(find_max(words:\
    \ [\"aaaaaaa\", \"bb\", \"cc\"]) == \"aaaaaaa\")\nassert(find_max(words: [\"abc\"\
    , \"cba\"]) == \"abc\")\nassert(find_max(words: [\"play\", \"this\", \"game\"\
    , \"of\", \"footbott\"]) == \"footbott\")\nassert(find_max(words: [\"we\", \"\
    are\", \"gonna\", \"rock\"]) == \"gonna\")\nassert(find_max(words: [\"we\", \"\
    are\", \"a\", \"mad\", \"nation\"]) == \"nation\")\nassert(find_max(words: [\"\
    this\", \"is\", \"a\", \"prrk\"]) == \"this\")\nassert(find_max(words: [\"b\"\
    ]) == \"b\")\nassert(find_max(words: [\"play\", \"play\", \"play\"]) == \"play\"\
    )"
  status: Exception
  stderr: 'tmpv6f1q_tz/tmpv6f1q_tz.swift:39: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b1aa9c49c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b1aa9940b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b1aa9940988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b1aa993f7b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpv6f1q_tz                        0x0000555f1a782933 <unavailable> + 6451

    5    libc.so.6                          0x00002b1aa9e35460 __libc_start_main +
    245

    6    tmpv6f1q_tz                        0x0000555f1a782359 <unavailable> + 4953

    '
  stdout: ''
  timestamp: 1660013455
- exit_code: 1
  program: "\n/// Write a function that accepts an array of strings.\n/// The array\
    \ contains different words. Return the word with maximum number\n/// of unique\
    \ characters. If multiple strings have maximum number of unique\n/// characters,\
    \ return the one which comes first in lexicographical order.\n/// >>> find_max(words:\
    \ [\"name\", \"of\", \"string\"])\n/// \"string\"\n/// >>> find_max(words: [\"\
    name\", \"enam\", \"game\"])\n/// \"enam\"\n/// >>> find_max(words: [\"aaaaaaa\"\
    , \"bb\", \"cc\"])\n/// \"aaaaaaa\"\nfunc find_max(words: [String]) -> String\
    \ {\n    return words.reduce(words[0]) { $0.countUniqueChars > $1.countUniqueChars\
    \ ? $0 : $1 }\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool\
    \ {\n    if left.count != right.count {\n        return false\n    }\n    for\
    \ (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(find_max(words: [\"\
    name\", \"of\", \"string\"]) == \"string\")\nassert(find_max(words: [\"name\"\
    , \"enam\", \"game\"]) == \"enam\")\nassert(find_max(words: [\"aaaaaaa\", \"bb\"\
    , \"cc\"]) == \"aaaaaaa\")\nassert(find_max(words: [\"abc\", \"cba\"]) == \"abc\"\
    )\nassert(find_max(words: [\"play\", \"this\", \"game\", \"of\", \"footbott\"\
    ]) == \"footbott\")\nassert(find_max(words: [\"we\", \"are\", \"gonna\", \"rock\"\
    ]) == \"gonna\")\nassert(find_max(words: [\"we\", \"are\", \"a\", \"mad\", \"\
    nation\"]) == \"nation\")\nassert(find_max(words: [\"this\", \"is\", \"a\", \"\
    prrk\"]) == \"this\")\nassert(find_max(words: [\"b\"]) == \"b\")\nassert(find_max(words:\
    \ [\"play\", \"play\", \"play\"]) == \"play\")"
  status: SyntaxError
  stderr: "/tmp/tmpus806rzg.swift:13:18: error: cannot convert return expression of\
    \ type '(_, _) -> _' to return type 'String'\n    return words.reduce(words[0])\
    \ { $0.countUniqueChars > $1.countUniqueChars ? $0 : $1 }\n           ~~~~~~^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n\
    /tmp/tmpus806rzg.swift:13:24: error: missing argument label 'into:' in call\n\
    \    return words.reduce(words[0]) { $0.countUniqueChars > $1.countUniqueChars\
    \ ? $0 : $1 }\n                       ^\n                        into: \n/tmp/tmpus806rzg.swift:13:30:\
    \ error: cannot convert value of type 'String' to expected argument type '(inout\
    \ @escaping (_, _) -> _, String) throws -> ()'\n    return words.reduce(words[0])\
    \ { $0.countUniqueChars > $1.countUniqueChars ? $0 : $1 }\n                  \
    \           ^\n"
  stdout: ''
  timestamp: 1660013455
- exit_code: 0
  program: "\n/// Write a function that accepts an array of strings.\n/// The array\
    \ contains different words. Return the word with maximum number\n/// of unique\
    \ characters. If multiple strings have maximum number of unique\n/// characters,\
    \ return the one which comes first in lexicographical order.\n/// >>> find_max(words:\
    \ [\"name\", \"of\", \"string\"])\n/// \"string\"\n/// >>> find_max(words: [\"\
    name\", \"enam\", \"game\"])\n/// \"enam\"\n/// >>> find_max(words: [\"aaaaaaa\"\
    , \"bb\", \"cc\"])\n/// \"aaaaaaa\"\nfunc find_max(words: [String]) -> String\
    \ {\n  var maxString = \"\"\n  var maxSet = Set<Character>()\n  for word in words\
    \ {\n    let set = Set(word)\n    if set.count > maxSet.count {\n      maxSet\
    \ = set\n      maxString = word\n    } else if set.count == maxSet.count && word\
    \ < maxString {\n      maxString = word\n    }\n  }\n  return maxString\n}\n\n\
    \nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(find_max(words: [\"name\", \"of\", \"string\"\
    ]) == \"string\")\nassert(find_max(words: [\"name\", \"enam\", \"game\"]) == \"\
    enam\")\nassert(find_max(words: [\"aaaaaaa\", \"bb\", \"cc\"]) == \"aaaaaaa\"\
    )\nassert(find_max(words: [\"abc\", \"cba\"]) == \"abc\")\nassert(find_max(words:\
    \ [\"play\", \"this\", \"game\", \"of\", \"footbott\"]) == \"footbott\")\nassert(find_max(words:\
    \ [\"we\", \"are\", \"gonna\", \"rock\"]) == \"gonna\")\nassert(find_max(words:\
    \ [\"we\", \"are\", \"a\", \"mad\", \"nation\"]) == \"nation\")\nassert(find_max(words:\
    \ [\"this\", \"is\", \"a\", \"prrk\"]) == \"this\")\nassert(find_max(words: [\"\
    b\"]) == \"b\")\nassert(find_max(words: [\"play\", \"play\", \"play\"]) == \"\
    play\")"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660013455
- exit_code: 1
  program: "\n/// Write a function that accepts an array of strings.\n/// The array\
    \ contains different words. Return the word with maximum number\n/// of unique\
    \ characters. If multiple strings have maximum number of unique\n/// characters,\
    \ return the one which comes first in lexicographical order.\n/// >>> find_max(words:\
    \ [\"name\", \"of\", \"string\"])\n/// \"string\"\n/// >>> find_max(words: [\"\
    name\", \"enam\", \"game\"])\n/// \"enam\"\n/// >>> find_max(words: [\"aaaaaaa\"\
    , \"bb\", \"cc\"])\n/// \"aaaaaaa\"\nfunc find_max(words: [String]) -> String\
    \ {\n    let distinct_words = words.map { word in word.removeDuplicates() }\n\
    \    return distinct_words.sorted { $0.count > $1.count }.first ?? \"\"\n}\n\n\
    \nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(find_max(words: [\"name\", \"of\", \"string\"\
    ]) == \"string\")\nassert(find_max(words: [\"name\", \"enam\", \"game\"]) == \"\
    enam\")\nassert(find_max(words: [\"aaaaaaa\", \"bb\", \"cc\"]) == \"aaaaaaa\"\
    )\nassert(find_max(words: [\"abc\", \"cba\"]) == \"abc\")\nassert(find_max(words:\
    \ [\"play\", \"this\", \"game\", \"of\", \"footbott\"]) == \"footbott\")\nassert(find_max(words:\
    \ [\"we\", \"are\", \"gonna\", \"rock\"]) == \"gonna\")\nassert(find_max(words:\
    \ [\"we\", \"are\", \"a\", \"mad\", \"nation\"]) == \"nation\")\nassert(find_max(words:\
    \ [\"this\", \"is\", \"a\", \"prrk\"]) == \"this\")\nassert(find_max(words: [\"\
    b\"]) == \"b\")\nassert(find_max(words: [\"play\", \"play\", \"play\"]) == \"\
    play\")"
  status: SyntaxError
  stderr: "/tmp/tmp2geatr9u.swift:13:51: error: value of type 'String' has no member\
    \ 'removeDuplicates'\n    let distinct_words = words.map { word in word.removeDuplicates()\
    \ }\n                                             ~~~~ ^~~~~~~~~~~~~~~~\n"
  stdout: ''
  timestamp: 1660013455
- exit_code: 0
  program: "\n/// Write a function that accepts an array of strings.\n/// The array\
    \ contains different words. Return the word with maximum number\n/// of unique\
    \ characters. If multiple strings have maximum number of unique\n/// characters,\
    \ return the one which comes first in lexicographical order.\n/// >>> find_max(words:\
    \ [\"name\", \"of\", \"string\"])\n/// \"string\"\n/// >>> find_max(words: [\"\
    name\", \"enam\", \"game\"])\n/// \"enam\"\n/// >>> find_max(words: [\"aaaaaaa\"\
    , \"bb\", \"cc\"])\n/// \"aaaaaaa\"\nfunc find_max(words: [String]) -> String\
    \ {\n    var result = words[0]\n    for word in words[1..<words.count] {\n   \
    \     if Set(word).count > Set(result).count ||\n            (Set(word).count\
    \ == Set(result).count && word < result) {\n            result = word\n      \
    \  }\n    }\n    return result\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int,\
    \ Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n\
    \    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n          \
    \  return false\n        }\n    }\n    return true\n}\n            \nassert(find_max(words:\
    \ [\"name\", \"of\", \"string\"]) == \"string\")\nassert(find_max(words: [\"name\"\
    , \"enam\", \"game\"]) == \"enam\")\nassert(find_max(words: [\"aaaaaaa\", \"bb\"\
    , \"cc\"]) == \"aaaaaaa\")\nassert(find_max(words: [\"abc\", \"cba\"]) == \"abc\"\
    )\nassert(find_max(words: [\"play\", \"this\", \"game\", \"of\", \"footbott\"\
    ]) == \"footbott\")\nassert(find_max(words: [\"we\", \"are\", \"gonna\", \"rock\"\
    ]) == \"gonna\")\nassert(find_max(words: [\"we\", \"are\", \"a\", \"mad\", \"\
    nation\"]) == \"nation\")\nassert(find_max(words: [\"this\", \"is\", \"a\", \"\
    prrk\"]) == \"this\")\nassert(find_max(words: [\"b\"]) == \"b\")\nassert(find_max(words:\
    \ [\"play\", \"play\", \"play\"]) == \"play\")"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660013455
- exit_code: 1
  program: "\n/// Write a function that accepts an array of strings.\n/// The array\
    \ contains different words. Return the word with maximum number\n/// of unique\
    \ characters. If multiple strings have maximum number of unique\n/// characters,\
    \ return the one which comes first in lexicographical order.\n/// >>> find_max(words:\
    \ [\"name\", \"of\", \"string\"])\n/// \"string\"\n/// >>> find_max(words: [\"\
    name\", \"enam\", \"game\"])\n/// \"enam\"\n/// >>> find_max(words: [\"aaaaaaa\"\
    , \"bb\", \"cc\"])\n/// \"aaaaaaa\"\nfunc find_max(words: [String]) -> String\
    \ {\n    var bestString = words[0]\n    var bestCount = 0\n    for word in words\
    \ {\n        let newCount = count_unique(s: word)\n        if newCount > bestCount\
    \ {\n            bestCount = newCount\n            bestString = word\n       \
    \ }\n    }\n    return bestString\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int,\
    \ Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n\
    \    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n          \
    \  return false\n        }\n    }\n    return true\n}\n            \nassert(find_max(words:\
    \ [\"name\", \"of\", \"string\"]) == \"string\")\nassert(find_max(words: [\"name\"\
    , \"enam\", \"game\"]) == \"enam\")\nassert(find_max(words: [\"aaaaaaa\", \"bb\"\
    , \"cc\"]) == \"aaaaaaa\")\nassert(find_max(words: [\"abc\", \"cba\"]) == \"abc\"\
    )\nassert(find_max(words: [\"play\", \"this\", \"game\", \"of\", \"footbott\"\
    ]) == \"footbott\")\nassert(find_max(words: [\"we\", \"are\", \"gonna\", \"rock\"\
    ]) == \"gonna\")\nassert(find_max(words: [\"we\", \"are\", \"a\", \"mad\", \"\
    nation\"]) == \"nation\")\nassert(find_max(words: [\"this\", \"is\", \"a\", \"\
    prrk\"]) == \"this\")\nassert(find_max(words: [\"b\"]) == \"b\")\nassert(find_max(words:\
    \ [\"play\", \"play\", \"play\"]) == \"play\")"
  status: SyntaxError
  stderr: "/tmp/tmpxxj95ymv.swift:16:24: error: cannot find 'count_unique' in scope\n\
    \        let newCount = count_unique(s: word)\n                       ^~~~~~~~~~~~\n"
  stdout: ''
  timestamp: 1660013455
- exit_code: -4
  program: "\n/// Write a function that accepts an array of strings.\n/// The array\
    \ contains different words. Return the word with maximum number\n/// of unique\
    \ characters. If multiple strings have maximum number of unique\n/// characters,\
    \ return the one which comes first in lexicographical order.\n/// >>> find_max(words:\
    \ [\"name\", \"of\", \"string\"])\n/// \"string\"\n/// >>> find_max(words: [\"\
    name\", \"enam\", \"game\"])\n/// \"enam\"\n/// >>> find_max(words: [\"aaaaaaa\"\
    , \"bb\", \"cc\"])\n/// \"aaaaaaa\"\nfunc find_max(words: [String]) -> String\
    \ {\n    var string_max = \"\"\n    var count_max = 0\n    for string in words\
    \ {\n        let new_set = Set(string)\n        if new_set.count > count_max {\n\
    \            count_max = new_set.count\n            string_max = string\n    \
    \    }\n    }\n    return string_max\n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(find_max(words: [\"name\", \"of\", \"string\"]) == \"string\")\nassert(find_max(words:\
    \ [\"name\", \"enam\", \"game\"]) == \"enam\")\nassert(find_max(words: [\"aaaaaaa\"\
    , \"bb\", \"cc\"]) == \"aaaaaaa\")\nassert(find_max(words: [\"abc\", \"cba\"])\
    \ == \"abc\")\nassert(find_max(words: [\"play\", \"this\", \"game\", \"of\", \"\
    footbott\"]) == \"footbott\")\nassert(find_max(words: [\"we\", \"are\", \"gonna\"\
    , \"rock\"]) == \"gonna\")\nassert(find_max(words: [\"we\", \"are\", \"a\", \"\
    mad\", \"nation\"]) == \"nation\")\nassert(find_max(words: [\"this\", \"is\",\
    \ \"a\", \"prrk\"]) == \"this\")\nassert(find_max(words: [\"b\"]) == \"b\")\n\
    assert(find_max(words: [\"play\", \"play\", \"play\"]) == \"play\")"
  status: Exception
  stderr: 'tmpbwu8uz0w/tmpbwu8uz0w.swift:39: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002acbcf8c3c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002acbcf5bab6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002acbcf5ba988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002acbcf5b97b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpbwu8uz0w                        0x0000562aff0b4933 <unavailable> + 6451

    5    libc.so.6                          0x00002acbcfaaf460 __libc_start_main +
    245

    6    tmpbwu8uz0w                        0x0000562aff0b4359 <unavailable> + 4953

    '
  stdout: ''
  timestamp: 1660013455
- exit_code: 1
  program: "\n/// Write a function that accepts an array of strings.\n/// The array\
    \ contains different words. Return the word with maximum number\n/// of unique\
    \ characters. If multiple strings have maximum number of unique\n/// characters,\
    \ return the one which comes first in lexicographical order.\n/// >>> find_max(words:\
    \ [\"name\", \"of\", \"string\"])\n/// \"string\"\n/// >>> find_max(words: [\"\
    name\", \"enam\", \"game\"])\n/// \"enam\"\n/// >>> find_max(words: [\"aaaaaaa\"\
    , \"bb\", \"cc\"])\n/// \"aaaaaaa\"\nfunc find_max(words: [String]) -> String\
    \ {\n    var maxWord = words[0]\n    var maxLength = count(maxWord)\n    var maxSet\
    \ = Set(maxWord)\n    for i in 1..<words.count {\n        var set = Set(words[i])\n\
    \        if set.count > maxSet.count {\n            maxSet = set\n           \
    \ maxWord = words[i]\n            maxLength = count(maxWord)\n        } else if\
    \ set.count == maxSet.count {\n            if count(words[i]) < maxLength {\n\
    \                maxWord = words[i]\n                maxLength = count(maxWord)\n\
    \            }\n        }\n    }\n    return maxWord\n}\n\n\nfunc ==(left: [(Int,\
    \ Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n\
    \        return false\n    }\n    for (l, r) in zip(left, right) {\n        if\
    \ l != r {\n            return false\n        }\n    }\n    return true\n}\n \
    \           \nassert(find_max(words: [\"name\", \"of\", \"string\"]) == \"string\"\
    )\nassert(find_max(words: [\"name\", \"enam\", \"game\"]) == \"enam\")\nassert(find_max(words:\
    \ [\"aaaaaaa\", \"bb\", \"cc\"]) == \"aaaaaaa\")\nassert(find_max(words: [\"abc\"\
    , \"cba\"]) == \"abc\")\nassert(find_max(words: [\"play\", \"this\", \"game\"\
    , \"of\", \"footbott\"]) == \"footbott\")\nassert(find_max(words: [\"we\", \"\
    are\", \"gonna\", \"rock\"]) == \"gonna\")\nassert(find_max(words: [\"we\", \"\
    are\", \"a\", \"mad\", \"nation\"]) == \"nation\")\nassert(find_max(words: [\"\
    this\", \"is\", \"a\", \"prrk\"]) == \"this\")\nassert(find_max(words: [\"b\"\
    ]) == \"b\")\nassert(find_max(words: [\"play\", \"play\", \"play\"]) == \"play\"\
    )"
  status: SyntaxError
  stderr: "/tmp/tmph8jb0oll.swift:14:21: error: cannot find 'count' in scope\n   \
    \ var maxLength = count(maxWord)\n                    ^~~~~\n/tmp/tmph8jb0oll.swift:21:25:\
    \ error: cannot find 'count' in scope\n            maxLength = count(maxWord)\n\
    \                        ^~~~~\n/tmp/tmph8jb0oll.swift:23:16: error: cannot find\
    \ 'count' in scope\n            if count(words[i]) < maxLength {\n           \
    \    ^~~~~\n/tmp/tmph8jb0oll.swift:25:29: error: cannot find 'count' in scope\n\
    \                maxLength = count(maxWord)\n                            ^~~~~\n"
  stdout: ''
  timestamp: 1660013455
- exit_code: -4
  program: "\n/// Write a function that accepts an array of strings.\n/// The array\
    \ contains different words. Return the word with maximum number\n/// of unique\
    \ characters. If multiple strings have maximum number of unique\n/// characters,\
    \ return the one which comes first in lexicographical order.\n/// >>> find_max(words:\
    \ [\"name\", \"of\", \"string\"])\n/// \"string\"\n/// >>> find_max(words: [\"\
    name\", \"enam\", \"game\"])\n/// \"enam\"\n/// >>> find_max(words: [\"aaaaaaa\"\
    , \"bb\", \"cc\"])\n/// \"aaaaaaa\"\nfunc find_max(words: [String]) -> String\
    \ {\n    \n    let wordsDict = words.reduce(into: [:]) { (dict, word) in\n   \
    \     dict[word, default: 0] += 1\n    }\n    \n    let maxValue = wordsDict.values.max()\n\
    \    \n    let maxDict = wordsDict.filter { (word, count) -> Bool in\n       \
    \ count == maxValue\n    }\n    \n    return maxDict.keys.sorted().first ?? \"\
    \"\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if\
    \ left.count != right.count {\n        return false\n    }\n    for (l, r) in\
    \ zip(left, right) {\n        if l != r {\n            return false\n        }\n\
    \    }\n    return true\n}\n            \nassert(find_max(words: [\"name\", \"\
    of\", \"string\"]) == \"string\")\nassert(find_max(words: [\"name\", \"enam\"\
    , \"game\"]) == \"enam\")\nassert(find_max(words: [\"aaaaaaa\", \"bb\", \"cc\"\
    ]) == \"aaaaaaa\")\nassert(find_max(words: [\"abc\", \"cba\"]) == \"abc\")\nassert(find_max(words:\
    \ [\"play\", \"this\", \"game\", \"of\", \"footbott\"]) == \"footbott\")\nassert(find_max(words:\
    \ [\"we\", \"are\", \"gonna\", \"rock\"]) == \"gonna\")\nassert(find_max(words:\
    \ [\"we\", \"are\", \"a\", \"mad\", \"nation\"]) == \"nation\")\nassert(find_max(words:\
    \ [\"this\", \"is\", \"a\", \"prrk\"]) == \"this\")\nassert(find_max(words: [\"\
    b\"]) == \"b\")\nassert(find_max(words: [\"play\", \"play\", \"play\"]) == \"\
    play\")"
  status: Exception
  stderr: 'tmp_b9bb3q6/tmp_b9bb3q6.swift:40: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002abe6dcb5c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002abe6d9acb6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002abe6d9ac988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002abe6d9ab7b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmp_b9bb3q6                        0x000055c288af2b3e <unavailable> + 6974

    5    libc.so.6                          0x00002abe6dea1460 __libc_start_main +
    245

    6    tmp_b9bb3q6                        0x000055c288af26f9 <unavailable> + 5881

    '
  stdout: ''
  timestamp: 1660013456
- exit_code: 0
  program: "\n/// Write a function that accepts an array of strings.\n/// The array\
    \ contains different words. Return the word with maximum number\n/// of unique\
    \ characters. If multiple strings have maximum number of unique\n/// characters,\
    \ return the one which comes first in lexicographical order.\n/// >>> find_max(words:\
    \ [\"name\", \"of\", \"string\"])\n/// \"string\"\n/// >>> find_max(words: [\"\
    name\", \"enam\", \"game\"])\n/// \"enam\"\n/// >>> find_max(words: [\"aaaaaaa\"\
    , \"bb\", \"cc\"])\n/// \"aaaaaaa\"\nfunc find_max(words: [String]) -> String\
    \ {\n    \n    guard !words.isEmpty else {\n        return \"\"\n    }\n    \n\
    \    var uniqueChar: [Character: Int] = [:]\n    var maxWord = words[0]\n    var\
    \ maxUnique = 0\n    \n    for (index, word) in words.enumerated() {\n       \
    \ if index == 0 {\n            for character in word {\n                uniqueChar[character]\
    \ = 1\n            }\n            maxUnique = uniqueChar.count\n            continue\n\
    \        }\n        \n        var temp: [Character: Int] = [:]\n        for character\
    \ in word {\n            temp[character] = 1\n        }\n        \n        let\
    \ tempUnique = temp.count\n        if tempUnique > maxUnique {\n            maxUnique\
    \ = tempUnique\n            maxWord = word\n        } else if tempUnique == maxUnique\
    \ {\n            if word < maxWord {\n                maxWord = word\n       \
    \     }\n        }\n    }\n    \n    return maxWord\n}\n\n\nfunc ==(left: [(Int,\
    \ Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n\
    \        return false\n    }\n    for (l, r) in zip(left, right) {\n        if\
    \ l != r {\n            return false\n        }\n    }\n    return true\n}\n \
    \           \nassert(find_max(words: [\"name\", \"of\", \"string\"]) == \"string\"\
    )\nassert(find_max(words: [\"name\", \"enam\", \"game\"]) == \"enam\")\nassert(find_max(words:\
    \ [\"aaaaaaa\", \"bb\", \"cc\"]) == \"aaaaaaa\")\nassert(find_max(words: [\"abc\"\
    , \"cba\"]) == \"abc\")\nassert(find_max(words: [\"play\", \"this\", \"game\"\
    , \"of\", \"footbott\"]) == \"footbott\")\nassert(find_max(words: [\"we\", \"\
    are\", \"gonna\", \"rock\"]) == \"gonna\")\nassert(find_max(words: [\"we\", \"\
    are\", \"a\", \"mad\", \"nation\"]) == \"nation\")\nassert(find_max(words: [\"\
    this\", \"is\", \"a\", \"prrk\"]) == \"this\")\nassert(find_max(words: [\"b\"\
    ]) == \"b\")\nassert(find_max(words: [\"play\", \"play\", \"play\"]) == \"play\"\
    )"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660013456
- exit_code: 1
  program: "\n/// Write a function that accepts an array of strings.\n/// The array\
    \ contains different words. Return the word with maximum number\n/// of unique\
    \ characters. If multiple strings have maximum number of unique\n/// characters,\
    \ return the one which comes first in lexicographical order.\n/// >>> find_max(words:\
    \ [\"name\", \"of\", \"string\"])\n/// \"string\"\n/// >>> find_max(words: [\"\
    name\", \"enam\", \"game\"])\n/// \"enam\"\n/// >>> find_max(words: [\"aaaaaaa\"\
    , \"bb\", \"cc\"])\n/// \"aaaaaaa\"\nfunc find_max(words: [String]) -> String\
    \ {\n    var maxCount = 0\n    var maxString = \"\"\n    for word in words {\n\
    \        let unique = uniqueLetters(in: word)\n        if unique.count > maxCount\
    \ {\n            maxCount = unique.count\n            maxString = word\n     \
    \   } else if unique.count == maxCount {\n            if maxString.compare(word)\
    \ == .orderedDescending {\n                maxString = word\n            }\n \
    \       }\n    }\n    return maxString\n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(find_max(words: [\"name\", \"of\", \"string\"]) == \"string\")\nassert(find_max(words:\
    \ [\"name\", \"enam\", \"game\"]) == \"enam\")\nassert(find_max(words: [\"aaaaaaa\"\
    , \"bb\", \"cc\"]) == \"aaaaaaa\")\nassert(find_max(words: [\"abc\", \"cba\"])\
    \ == \"abc\")\nassert(find_max(words: [\"play\", \"this\", \"game\", \"of\", \"\
    footbott\"]) == \"footbott\")\nassert(find_max(words: [\"we\", \"are\", \"gonna\"\
    , \"rock\"]) == \"gonna\")\nassert(find_max(words: [\"we\", \"are\", \"a\", \"\
    mad\", \"nation\"]) == \"nation\")\nassert(find_max(words: [\"this\", \"is\",\
    \ \"a\", \"prrk\"]) == \"this\")\nassert(find_max(words: [\"b\"]) == \"b\")\n\
    assert(find_max(words: [\"play\", \"play\", \"play\"]) == \"play\")"
  status: SyntaxError
  stderr: "/tmp/tmpkw9qp_t5.swift:16:22: error: cannot find 'uniqueLetters' in scope\n\
    \        let unique = uniqueLetters(in: word)\n                     ^~~~~~~~~~~~~\n\
    /tmp/tmpkw9qp_t5.swift:21:26: error: value of type 'String' has no member 'compare'\n\
    \            if maxString.compare(word) == .orderedDescending {\n            \
    \   ~~~~~~~~~ ^~~~~~~\n"
  stdout: ''
  timestamp: 1660013455
- exit_code: -4
  program: "\n/// Write a function that accepts an array of strings.\n/// The array\
    \ contains different words. Return the word with maximum number\n/// of unique\
    \ characters. If multiple strings have maximum number of unique\n/// characters,\
    \ return the one which comes first in lexicographical order.\n/// >>> find_max(words:\
    \ [\"name\", \"of\", \"string\"])\n/// \"string\"\n/// >>> find_max(words: [\"\
    name\", \"enam\", \"game\"])\n/// \"enam\"\n/// >>> find_max(words: [\"aaaaaaa\"\
    , \"bb\", \"cc\"])\n/// \"aaaaaaa\"\nfunc find_max(words: [String]) -> String\
    \ {\n    var uniques = [String: String]()\n    for word in words {\n        var\
    \ set = Set<Character>()\n        for c in word {\n            set.insert(c)\n\
    \        }\n        uniques[word] = String(set.count)\n    }\n    let sorted =\
    \ uniques.sorted(by: {$0.value > $1.value})\n    return sorted[0].key\n}\n\n\n\
    func ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(find_max(words: [\"name\", \"of\", \"string\"\
    ]) == \"string\")\nassert(find_max(words: [\"name\", \"enam\", \"game\"]) == \"\
    enam\")\nassert(find_max(words: [\"aaaaaaa\", \"bb\", \"cc\"]) == \"aaaaaaa\"\
    )\nassert(find_max(words: [\"abc\", \"cba\"]) == \"abc\")\nassert(find_max(words:\
    \ [\"play\", \"this\", \"game\", \"of\", \"footbott\"]) == \"footbott\")\nassert(find_max(words:\
    \ [\"we\", \"are\", \"gonna\", \"rock\"]) == \"gonna\")\nassert(find_max(words:\
    \ [\"we\", \"are\", \"a\", \"mad\", \"nation\"]) == \"nation\")\nassert(find_max(words:\
    \ [\"this\", \"is\", \"a\", \"prrk\"]) == \"this\")\nassert(find_max(words: [\"\
    b\"]) == \"b\")\nassert(find_max(words: [\"play\", \"play\", \"play\"]) == \"\
    play\")"
  status: Exception
  stderr: 'tmp6iixmye6/tmp6iixmye6.swift:39: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b7d4b535c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b7d4b22cb6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b7d4b22c988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b7d4b22b7b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmp6iixmye6                        0x0000560c0b42ad43 <unavailable> + 7491

    5    libc.so.6                          0x00002b7d4b721460 __libc_start_main +
    245

    6    tmp6iixmye6                        0x0000560c0b42a769 <unavailable> + 5993

    '
  stdout: ''
  timestamp: 1660013456
- exit_code: 1
  program: "\n/// Write a function that accepts an array of strings.\n/// The array\
    \ contains different words. Return the word with maximum number\n/// of unique\
    \ characters. If multiple strings have maximum number of unique\n/// characters,\
    \ return the one which comes first in lexicographical order.\n/// >>> find_max(words:\
    \ [\"name\", \"of\", \"string\"])\n/// \"string\"\n/// >>> find_max(words: [\"\
    name\", \"enam\", \"game\"])\n/// \"enam\"\n/// >>> find_max(words: [\"aaaaaaa\"\
    , \"bb\", \"cc\"])\n/// \"aaaaaaa\"\nfunc find_max(words: [String]) -> String\
    \ {\n    var result = words[0]\n    var max_unique_chars = 0\n    for i in 0..<words.count\
    \ {\n        let unique_chars = unique_letters(word: words[i])\n        if unique_chars\
    \ > max_unique_chars {\n            max_unique_chars = unique_chars\n        \
    \    result = words[i]\n        }\n    }\n    return result\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(find_max(words: [\"name\", \"of\", \"string\"]) == \"\
    string\")\nassert(find_max(words: [\"name\", \"enam\", \"game\"]) == \"enam\"\
    )\nassert(find_max(words: [\"aaaaaaa\", \"bb\", \"cc\"]) == \"aaaaaaa\")\nassert(find_max(words:\
    \ [\"abc\", \"cba\"]) == \"abc\")\nassert(find_max(words: [\"play\", \"this\"\
    , \"game\", \"of\", \"footbott\"]) == \"footbott\")\nassert(find_max(words: [\"\
    we\", \"are\", \"gonna\", \"rock\"]) == \"gonna\")\nassert(find_max(words: [\"\
    we\", \"are\", \"a\", \"mad\", \"nation\"]) == \"nation\")\nassert(find_max(words:\
    \ [\"this\", \"is\", \"a\", \"prrk\"]) == \"this\")\nassert(find_max(words: [\"\
    b\"]) == \"b\")\nassert(find_max(words: [\"play\", \"play\", \"play\"]) == \"\
    play\")"
  status: SyntaxError
  stderr: "/tmp/tmpe1n9gin6.swift:16:28: error: cannot find 'unique_letters' in scope\n\
    \        let unique_chars = unique_letters(word: words[i])\n                 \
    \          ^~~~~~~~~~~~~~\n"
  stdout: ''
  timestamp: 1660013455
- exit_code: -4
  program: "\n/// Write a function that accepts an array of strings.\n/// The array\
    \ contains different words. Return the word with maximum number\n/// of unique\
    \ characters. If multiple strings have maximum number of unique\n/// characters,\
    \ return the one which comes first in lexicographical order.\n/// >>> find_max(words:\
    \ [\"name\", \"of\", \"string\"])\n/// \"string\"\n/// >>> find_max(words: [\"\
    name\", \"enam\", \"game\"])\n/// \"enam\"\n/// >>> find_max(words: [\"aaaaaaa\"\
    , \"bb\", \"cc\"])\n/// \"aaaaaaa\"\nfunc find_max(words: [String]) -> String\
    \ {\n    if words.count < 1 {\n        return \"\"\n    }\n    var unique_words\
    \ = [String:Set<Character>]()\n    for word in words {\n        unique_words[word]\
    \ = Set(word)\n    }\n    var max_key = \"\"\n    var max_length = 0\n    for\
    \ (key, value) in unique_words {\n        if value.count > max_length {\n    \
    \        max_length = value.count\n            max_key = key\n        }\n    }\n\
    \    return max_key\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) ->\
    \ Bool {\n    if left.count != right.count {\n        return false\n    }\n  \
    \  for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(find_max(words: [\"\
    name\", \"of\", \"string\"]) == \"string\")\nassert(find_max(words: [\"name\"\
    , \"enam\", \"game\"]) == \"enam\")\nassert(find_max(words: [\"aaaaaaa\", \"bb\"\
    , \"cc\"]) == \"aaaaaaa\")\nassert(find_max(words: [\"abc\", \"cba\"]) == \"abc\"\
    )\nassert(find_max(words: [\"play\", \"this\", \"game\", \"of\", \"footbott\"\
    ]) == \"footbott\")\nassert(find_max(words: [\"we\", \"are\", \"gonna\", \"rock\"\
    ]) == \"gonna\")\nassert(find_max(words: [\"we\", \"are\", \"a\", \"mad\", \"\
    nation\"]) == \"nation\")\nassert(find_max(words: [\"this\", \"is\", \"a\", \"\
    prrk\"]) == \"this\")\nassert(find_max(words: [\"b\"]) == \"b\")\nassert(find_max(words:\
    \ [\"play\", \"play\", \"play\"]) == \"play\")"
  status: Exception
  stderr: 'tmp65a8xvi3/tmp65a8xvi3.swift:47: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b8e0b9ffc80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b8e0b6f6b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b8e0b6f6988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b8e0b6f57b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmp65a8xvi3                        0x000055cd1a6a1f24 <unavailable> + 7972

    5    libc.so.6                          0x00002b8e0bbeb460 __libc_start_main +
    245

    6    tmp65a8xvi3                        0x000055cd1a6a1609 <unavailable> + 5641

    '
  stdout: ''
  timestamp: 1660013456
- exit_code: -4
  program: "\n/// Write a function that accepts an array of strings.\n/// The array\
    \ contains different words. Return the word with maximum number\n/// of unique\
    \ characters. If multiple strings have maximum number of unique\n/// characters,\
    \ return the one which comes first in lexicographical order.\n/// >>> find_max(words:\
    \ [\"name\", \"of\", \"string\"])\n/// \"string\"\n/// >>> find_max(words: [\"\
    name\", \"enam\", \"game\"])\n/// \"enam\"\n/// >>> find_max(words: [\"aaaaaaa\"\
    , \"bb\", \"cc\"])\n/// \"aaaaaaa\"\nfunc find_max(words: [String]) -> String\
    \ {\n    // Write your code here.\n    return \"\"\n}\n\n\nfunc ==(left: [(Int,\
    \ Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n\
    \        return false\n    }\n    for (l, r) in zip(left, right) {\n        if\
    \ l != r {\n            return false\n        }\n    }\n    return true\n}\n \
    \           \nassert(find_max(words: [\"name\", \"of\", \"string\"]) == \"string\"\
    )\nassert(find_max(words: [\"name\", \"enam\", \"game\"]) == \"enam\")\nassert(find_max(words:\
    \ [\"aaaaaaa\", \"bb\", \"cc\"]) == \"aaaaaaa\")\nassert(find_max(words: [\"abc\"\
    , \"cba\"]) == \"abc\")\nassert(find_max(words: [\"play\", \"this\", \"game\"\
    , \"of\", \"footbott\"]) == \"footbott\")\nassert(find_max(words: [\"we\", \"\
    are\", \"gonna\", \"rock\"]) == \"gonna\")\nassert(find_max(words: [\"we\", \"\
    are\", \"a\", \"mad\", \"nation\"]) == \"nation\")\nassert(find_max(words: [\"\
    this\", \"is\", \"a\", \"prrk\"]) == \"this\")\nassert(find_max(words: [\"b\"\
    ]) == \"b\")\nassert(find_max(words: [\"play\", \"play\", \"play\"]) == \"play\"\
    )"
  status: Exception
  stderr: 'tmp6clqxzmf/tmp6clqxzmf.swift:30: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002ac2a6af6c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002ac2a67edb6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002ac2a67ed988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002ac2a67ec7b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmp6clqxzmf                        0x000055d31d03e4ce <unavailable> + 5326

    5    libc.so.6                          0x00002ac2a6ce2460 __libc_start_main +
    245

    6    tmp6clqxzmf                        0x000055d31d03e089 <unavailable> + 4233

    '
  stdout: ''
  timestamp: 1660013456
- exit_code: 0
  program: "\n/// Write a function that accepts an array of strings.\n/// The array\
    \ contains different words. Return the word with maximum number\n/// of unique\
    \ characters. If multiple strings have maximum number of unique\n/// characters,\
    \ return the one which comes first in lexicographical order.\n/// >>> find_max(words:\
    \ [\"name\", \"of\", \"string\"])\n/// \"string\"\n/// >>> find_max(words: [\"\
    name\", \"enam\", \"game\"])\n/// \"enam\"\n/// >>> find_max(words: [\"aaaaaaa\"\
    , \"bb\", \"cc\"])\n/// \"aaaaaaa\"\nfunc find_max(words: [String]) -> String\
    \ {\n    return words.reduce(\"\") {\n        guard $0 != \"\" else { return $1\
    \ }\n        let currentUnique = Set($1)\n        if currentUnique.count > Set($0).count\
    \ {\n            return $1\n        } else if currentUnique.count == Set($0).count\
    \ {\n            return $0 < $1 ? $0 : $1\n        } else {\n            return\
    \ $0\n        }\n    }\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(find_max(words:\
    \ [\"name\", \"of\", \"string\"]) == \"string\")\nassert(find_max(words: [\"name\"\
    , \"enam\", \"game\"]) == \"enam\")\nassert(find_max(words: [\"aaaaaaa\", \"bb\"\
    , \"cc\"]) == \"aaaaaaa\")\nassert(find_max(words: [\"abc\", \"cba\"]) == \"abc\"\
    )\nassert(find_max(words: [\"play\", \"this\", \"game\", \"of\", \"footbott\"\
    ]) == \"footbott\")\nassert(find_max(words: [\"we\", \"are\", \"gonna\", \"rock\"\
    ]) == \"gonna\")\nassert(find_max(words: [\"we\", \"are\", \"a\", \"mad\", \"\
    nation\"]) == \"nation\")\nassert(find_max(words: [\"this\", \"is\", \"a\", \"\
    prrk\"]) == \"this\")\nassert(find_max(words: [\"b\"]) == \"b\")\nassert(find_max(words:\
    \ [\"play\", \"play\", \"play\"]) == \"play\")"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660013456
- exit_code: 0
  program: "\n/// Write a function that accepts an array of strings.\n/// The array\
    \ contains different words. Return the word with maximum number\n/// of unique\
    \ characters. If multiple strings have maximum number of unique\n/// characters,\
    \ return the one which comes first in lexicographical order.\n/// >>> find_max(words:\
    \ [\"name\", \"of\", \"string\"])\n/// \"string\"\n/// >>> find_max(words: [\"\
    name\", \"enam\", \"game\"])\n/// \"enam\"\n/// >>> find_max(words: [\"aaaaaaa\"\
    , \"bb\", \"cc\"])\n/// \"aaaaaaa\"\nfunc find_max(words: [String]) -> String\
    \ {\n    var maxWords = [String]()\n    var maxCount = 0\n    for word in words\
    \ {\n        let set = Set(word)\n        if set.count > maxCount {\n        \
    \    maxCount = set.count\n            maxWords = [word]\n        } else if set.count\
    \ == maxCount {\n            maxWords.append(word)\n        }\n    }\n    maxWords.sort()\n\
    \    return maxWords[0]\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(find_max(words:\
    \ [\"name\", \"of\", \"string\"]) == \"string\")\nassert(find_max(words: [\"name\"\
    , \"enam\", \"game\"]) == \"enam\")\nassert(find_max(words: [\"aaaaaaa\", \"bb\"\
    , \"cc\"]) == \"aaaaaaa\")\nassert(find_max(words: [\"abc\", \"cba\"]) == \"abc\"\
    )\nassert(find_max(words: [\"play\", \"this\", \"game\", \"of\", \"footbott\"\
    ]) == \"footbott\")\nassert(find_max(words: [\"we\", \"are\", \"gonna\", \"rock\"\
    ]) == \"gonna\")\nassert(find_max(words: [\"we\", \"are\", \"a\", \"mad\", \"\
    nation\"]) == \"nation\")\nassert(find_max(words: [\"this\", \"is\", \"a\", \"\
    prrk\"]) == \"this\")\nassert(find_max(words: [\"b\"]) == \"b\")\nassert(find_max(words:\
    \ [\"play\", \"play\", \"play\"]) == \"play\")"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660013456
- exit_code: -4
  program: "\n/// Write a function that accepts an array of strings.\n/// The array\
    \ contains different words. Return the word with maximum number\n/// of unique\
    \ characters. If multiple strings have maximum number of unique\n/// characters,\
    \ return the one which comes first in lexicographical order.\n/// >>> find_max(words:\
    \ [\"name\", \"of\", \"string\"])\n/// \"string\"\n/// >>> find_max(words: [\"\
    name\", \"enam\", \"game\"])\n/// \"enam\"\n/// >>> find_max(words: [\"aaaaaaa\"\
    , \"bb\", \"cc\"])\n/// \"aaaaaaa\"\nfunc find_max(words: [String]) -> String\
    \ {\n    \n    var maxChar = 0\n    var finalWord = \"\"\n    \n    for word in\
    \ words {\n        var unique = Set<Character>()\n        for char in word {\n\
    \            unique.insert(char)\n        }\n        if unique.count > maxChar\
    \ {\n            maxChar = unique.count\n            finalWord = word\n      \
    \  }\n    }\n    return finalWord\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int,\
    \ Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n\
    \    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n          \
    \  return false\n        }\n    }\n    return true\n}\n            \nassert(find_max(words:\
    \ [\"name\", \"of\", \"string\"]) == \"string\")\nassert(find_max(words: [\"name\"\
    , \"enam\", \"game\"]) == \"enam\")\nassert(find_max(words: [\"aaaaaaa\", \"bb\"\
    , \"cc\"]) == \"aaaaaaa\")\nassert(find_max(words: [\"abc\", \"cba\"]) == \"abc\"\
    )\nassert(find_max(words: [\"play\", \"this\", \"game\", \"of\", \"footbott\"\
    ]) == \"footbott\")\nassert(find_max(words: [\"we\", \"are\", \"gonna\", \"rock\"\
    ]) == \"gonna\")\nassert(find_max(words: [\"we\", \"are\", \"a\", \"mad\", \"\
    nation\"]) == \"nation\")\nassert(find_max(words: [\"this\", \"is\", \"a\", \"\
    prrk\"]) == \"this\")\nassert(find_max(words: [\"b\"]) == \"b\")\nassert(find_max(words:\
    \ [\"play\", \"play\", \"play\"]) == \"play\")"
  status: Exception
  stderr: 'tmp4zbapinu/tmp4zbapinu.swift:44: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b21de6f3c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b21de3eab6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b21de3ea988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b21de3e97b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmp4zbapinu                        0x00005573ac9a4a03 <unavailable> + 6659

    5    libc.so.6                          0x00002b21de8df460 __libc_start_main +
    245

    6    tmp4zbapinu                        0x00005573ac9a4429 <unavailable> + 5161

    '
  stdout: ''
  timestamp: 1660013456
- exit_code: -4
  program: "\n/// Write a function that accepts an array of strings.\n/// The array\
    \ contains different words. Return the word with maximum number\n/// of unique\
    \ characters. If multiple strings have maximum number of unique\n/// characters,\
    \ return the one which comes first in lexicographical order.\n/// >>> find_max(words:\
    \ [\"name\", \"of\", \"string\"])\n/// \"string\"\n/// >>> find_max(words: [\"\
    name\", \"enam\", \"game\"])\n/// \"enam\"\n/// >>> find_max(words: [\"aaaaaaa\"\
    , \"bb\", \"cc\"])\n/// \"aaaaaaa\"\nfunc find_max(words: [String]) -> String\
    \ {\n    var max_string = \"\"\n    var max_value = 0\n    for word in words {\n\
    \        let value = Set(word).count\n        if value > max_value {\n       \
    \     max_value = value\n            max_string = word\n        }\n    }\n   \
    \ return max_string\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) ->\
    \ Bool {\n    if left.count != right.count {\n        return false\n    }\n  \
    \  for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(find_max(words: [\"\
    name\", \"of\", \"string\"]) == \"string\")\nassert(find_max(words: [\"name\"\
    , \"enam\", \"game\"]) == \"enam\")\nassert(find_max(words: [\"aaaaaaa\", \"bb\"\
    , \"cc\"]) == \"aaaaaaa\")\nassert(find_max(words: [\"abc\", \"cba\"]) == \"abc\"\
    )\nassert(find_max(words: [\"play\", \"this\", \"game\", \"of\", \"footbott\"\
    ]) == \"footbott\")\nassert(find_max(words: [\"we\", \"are\", \"gonna\", \"rock\"\
    ]) == \"gonna\")\nassert(find_max(words: [\"we\", \"are\", \"a\", \"mad\", \"\
    nation\"]) == \"nation\")\nassert(find_max(words: [\"this\", \"is\", \"a\", \"\
    prrk\"]) == \"this\")\nassert(find_max(words: [\"b\"]) == \"b\")\nassert(find_max(words:\
    \ [\"play\", \"play\", \"play\"]) == \"play\")"
  status: Exception
  stderr: 'tmp5jewje7_/tmp5jewje7_.swift:39: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b0ef5970c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b0ef5667b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b0ef5667988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b0ef56667b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmp5jewje7_                        0x00005615c3916933 <unavailable> + 6451

    5    libc.so.6                          0x00002b0ef5b5c460 __libc_start_main +
    245

    6    tmp5jewje7_                        0x00005615c3916359 <unavailable> + 4953

    '
  stdout: ''
  timestamp: 1660013456
- exit_code: -4
  program: "\n/// Write a function that accepts an array of strings.\n/// The array\
    \ contains different words. Return the word with maximum number\n/// of unique\
    \ characters. If multiple strings have maximum number of unique\n/// characters,\
    \ return the one which comes first in lexicographical order.\n/// >>> find_max(words:\
    \ [\"name\", \"of\", \"string\"])\n/// \"string\"\n/// >>> find_max(words: [\"\
    name\", \"enam\", \"game\"])\n/// \"enam\"\n/// >>> find_max(words: [\"aaaaaaa\"\
    , \"bb\", \"cc\"])\n/// \"aaaaaaa\"\nfunc find_max(words: [String]) -> String\
    \ {\n    return \"\"\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(find_max(words:\
    \ [\"name\", \"of\", \"string\"]) == \"string\")\nassert(find_max(words: [\"name\"\
    , \"enam\", \"game\"]) == \"enam\")\nassert(find_max(words: [\"aaaaaaa\", \"bb\"\
    , \"cc\"]) == \"aaaaaaa\")\nassert(find_max(words: [\"abc\", \"cba\"]) == \"abc\"\
    )\nassert(find_max(words: [\"play\", \"this\", \"game\", \"of\", \"footbott\"\
    ]) == \"footbott\")\nassert(find_max(words: [\"we\", \"are\", \"gonna\", \"rock\"\
    ]) == \"gonna\")\nassert(find_max(words: [\"we\", \"are\", \"a\", \"mad\", \"\
    nation\"]) == \"nation\")\nassert(find_max(words: [\"this\", \"is\", \"a\", \"\
    prrk\"]) == \"this\")\nassert(find_max(words: [\"b\"]) == \"b\")\nassert(find_max(words:\
    \ [\"play\", \"play\", \"play\"]) == \"play\")"
  status: Exception
  stderr: 'tmp9vfthvyx/tmp9vfthvyx.swift:29: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b5bb598bc80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b5bb5682b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b5bb5682988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b5bb56817b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmp9vfthvyx                        0x0000564c87ea64ce <unavailable> + 5326

    5    libc.so.6                          0x00002b5bb5b77460 __libc_start_main +
    245

    6    tmp9vfthvyx                        0x0000564c87ea6089 <unavailable> + 4233

    '
  stdout: ''
  timestamp: 1660013265
- exit_code: -4
  program: "\n/// Write a function that accepts an array of strings.\n/// The array\
    \ contains different words. Return the word with maximum number\n/// of unique\
    \ characters. If multiple strings have maximum number of unique\n/// characters,\
    \ return the one which comes first in lexicographical order.\n/// >>> find_max(words:\
    \ [\"name\", \"of\", \"string\"])\n/// \"string\"\n/// >>> find_max(words: [\"\
    name\", \"enam\", \"game\"])\n/// \"enam\"\n/// >>> find_max(words: [\"aaaaaaa\"\
    , \"bb\", \"cc\"])\n/// \"aaaaaaa\"\nfunc find_max(words: [String]) -> String\
    \ {\n    return words.max(by: { ($0.count, $0) < ($1.count, $1) })!\n}\n\n\nfunc\
    \ ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count !=\
    \ right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(find_max(words: [\"name\", \"of\", \"string\"\
    ]) == \"string\")\nassert(find_max(words: [\"name\", \"enam\", \"game\"]) == \"\
    enam\")\nassert(find_max(words: [\"aaaaaaa\", \"bb\", \"cc\"]) == \"aaaaaaa\"\
    )\nassert(find_max(words: [\"abc\", \"cba\"]) == \"abc\")\nassert(find_max(words:\
    \ [\"play\", \"this\", \"game\", \"of\", \"footbott\"]) == \"footbott\")\nassert(find_max(words:\
    \ [\"we\", \"are\", \"gonna\", \"rock\"]) == \"gonna\")\nassert(find_max(words:\
    \ [\"we\", \"are\", \"a\", \"mad\", \"nation\"]) == \"nation\")\nassert(find_max(words:\
    \ [\"this\", \"is\", \"a\", \"prrk\"]) == \"this\")\nassert(find_max(words: [\"\
    b\"]) == \"b\")\nassert(find_max(words: [\"play\", \"play\", \"play\"]) == \"\
    play\")"
  status: Exception
  stderr: 'tmphk574ba_/tmphk574ba_.swift:30: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002ad6fcc42c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002ad6fc939b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002ad6fc939988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002ad6fc9387b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmphk574ba_                        0x0000562dbeecd893 <unavailable> + 6291

    5    libc.so.6                          0x00002ad6fce2e460 __libc_start_main +
    245

    6    tmphk574ba_                        0x0000562dbeecd2b9 <unavailable> + 4793

    '
  stdout: ''
  timestamp: 1660013456
- exit_code: -4
  program: "\n/// Write a function that accepts an array of strings.\n/// The array\
    \ contains different words. Return the word with maximum number\n/// of unique\
    \ characters. If multiple strings have maximum number of unique\n/// characters,\
    \ return the one which comes first in lexicographical order.\n/// >>> find_max(words:\
    \ [\"name\", \"of\", \"string\"])\n/// \"string\"\n/// >>> find_max(words: [\"\
    name\", \"enam\", \"game\"])\n/// \"enam\"\n/// >>> find_max(words: [\"aaaaaaa\"\
    , \"bb\", \"cc\"])\n/// \"aaaaaaa\"\nfunc find_max(words: [String]) -> String\
    \ {\n    var maxCount = 0\n    var maxString = \"\"\n    for word in words {\n\
    \        let charSet = Set(word)\n        if charSet.count > maxCount {\n    \
    \        maxCount = charSet.count\n            maxString = word\n        }\n \
    \   }\n    return maxString\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int,\
    \ Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n\
    \    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n          \
    \  return false\n        }\n    }\n    return true\n}\n            \nassert(find_max(words:\
    \ [\"name\", \"of\", \"string\"]) == \"string\")\nassert(find_max(words: [\"name\"\
    , \"enam\", \"game\"]) == \"enam\")\nassert(find_max(words: [\"aaaaaaa\", \"bb\"\
    , \"cc\"]) == \"aaaaaaa\")\nassert(find_max(words: [\"abc\", \"cba\"]) == \"abc\"\
    )\nassert(find_max(words: [\"play\", \"this\", \"game\", \"of\", \"footbott\"\
    ]) == \"footbott\")\nassert(find_max(words: [\"we\", \"are\", \"gonna\", \"rock\"\
    ]) == \"gonna\")\nassert(find_max(words: [\"we\", \"are\", \"a\", \"mad\", \"\
    nation\"]) == \"nation\")\nassert(find_max(words: [\"this\", \"is\", \"a\", \"\
    prrk\"]) == \"this\")\nassert(find_max(words: [\"b\"]) == \"b\")\nassert(find_max(words:\
    \ [\"play\", \"play\", \"play\"]) == \"play\")"
  status: Exception
  stderr: 'tmpof29ypfb/tmpof29ypfb.swift:39: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002abd28443c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002abd2813ab6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002abd2813a988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002abd281397b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpof29ypfb                        0x000055acd4fb7933 <unavailable> + 6451

    5    libc.so.6                          0x00002abd2862f460 __libc_start_main +
    245

    6    tmpof29ypfb                        0x000055acd4fb7359 <unavailable> + 4953

    '
  stdout: ''
  timestamp: 1660013456
- exit_code: 0
  program: "\n/// Write a function that accepts an array of strings.\n/// The array\
    \ contains different words. Return the word with maximum number\n/// of unique\
    \ characters. If multiple strings have maximum number of unique\n/// characters,\
    \ return the one which comes first in lexicographical order.\n/// >>> find_max(words:\
    \ [\"name\", \"of\", \"string\"])\n/// \"string\"\n/// >>> find_max(words: [\"\
    name\", \"enam\", \"game\"])\n/// \"enam\"\n/// >>> find_max(words: [\"aaaaaaa\"\
    , \"bb\", \"cc\"])\n/// \"aaaaaaa\"\nfunc find_max(words: [String]) -> String\
    \ {\n    var max: (freq: Int, lex: String) = (0, \"\")\n    for word in words\
    \ {\n        var freq = 0\n        var set = Set<Character>()\n        for c in\
    \ word {\n            if !set.contains(c) {\n                freq += 1\n     \
    \           set.insert(c)\n            }\n        }\n        if freq > max.freq\
    \ {\n            max = (freq, word)\n        } else if freq == max.freq && word\
    \ < max.lex {\n            max = (freq, word)\n        }\n    }\n    return max.lex\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(find_max(words: [\"name\", \"of\", \"string\"\
    ]) == \"string\")\nassert(find_max(words: [\"name\", \"enam\", \"game\"]) == \"\
    enam\")\nassert(find_max(words: [\"aaaaaaa\", \"bb\", \"cc\"]) == \"aaaaaaa\"\
    )\nassert(find_max(words: [\"abc\", \"cba\"]) == \"abc\")\nassert(find_max(words:\
    \ [\"play\", \"this\", \"game\", \"of\", \"footbott\"]) == \"footbott\")\nassert(find_max(words:\
    \ [\"we\", \"are\", \"gonna\", \"rock\"]) == \"gonna\")\nassert(find_max(words:\
    \ [\"we\", \"are\", \"a\", \"mad\", \"nation\"]) == \"nation\")\nassert(find_max(words:\
    \ [\"this\", \"is\", \"a\", \"prrk\"]) == \"this\")\nassert(find_max(words: [\"\
    b\"]) == \"b\")\nassert(find_max(words: [\"play\", \"play\", \"play\"]) == \"\
    play\")"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660013456
- exit_code: -4
  program: "\n/// Write a function that accepts an array of strings.\n/// The array\
    \ contains different words. Return the word with maximum number\n/// of unique\
    \ characters. If multiple strings have maximum number of unique\n/// characters,\
    \ return the one which comes first in lexicographical order.\n/// >>> find_max(words:\
    \ [\"name\", \"of\", \"string\"])\n/// \"string\"\n/// >>> find_max(words: [\"\
    name\", \"enam\", \"game\"])\n/// \"enam\"\n/// >>> find_max(words: [\"aaaaaaa\"\
    , \"bb\", \"cc\"])\n/// \"aaaaaaa\"\nfunc find_max(words: [String]) -> String\
    \ {\n    return \"\"\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(find_max(words:\
    \ [\"name\", \"of\", \"string\"]) == \"string\")\nassert(find_max(words: [\"name\"\
    , \"enam\", \"game\"]) == \"enam\")\nassert(find_max(words: [\"aaaaaaa\", \"bb\"\
    , \"cc\"]) == \"aaaaaaa\")\nassert(find_max(words: [\"abc\", \"cba\"]) == \"abc\"\
    )\nassert(find_max(words: [\"play\", \"this\", \"game\", \"of\", \"footbott\"\
    ]) == \"footbott\")\nassert(find_max(words: [\"we\", \"are\", \"gonna\", \"rock\"\
    ]) == \"gonna\")\nassert(find_max(words: [\"we\", \"are\", \"a\", \"mad\", \"\
    nation\"]) == \"nation\")\nassert(find_max(words: [\"this\", \"is\", \"a\", \"\
    prrk\"]) == \"this\")\nassert(find_max(words: [\"b\"]) == \"b\")\nassert(find_max(words:\
    \ [\"play\", \"play\", \"play\"]) == \"play\")"
  status: Exception
  stderr: 'tmp9vfthvyx/tmp9vfthvyx.swift:29: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b5bb598bc80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b5bb5682b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b5bb5682988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b5bb56817b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmp9vfthvyx                        0x0000564c87ea64ce <unavailable> + 5326

    5    libc.so.6                          0x00002b5bb5b77460 __libc_start_main +
    245

    6    tmp9vfthvyx                        0x0000564c87ea6089 <unavailable> + 4233

    '
  stdout: ''
  timestamp: 1660013265
- exit_code: 1
  program: "\n/// Write a function that accepts an array of strings.\n/// The array\
    \ contains different words. Return the word with maximum number\n/// of unique\
    \ characters. If multiple strings have maximum number of unique\n/// characters,\
    \ return the one which comes first in lexicographical order.\n/// >>> find_max(words:\
    \ [\"name\", \"of\", \"string\"])\n/// \"string\"\n/// >>> find_max(words: [\"\
    name\", \"enam\", \"game\"])\n/// \"enam\"\n/// >>> find_max(words: [\"aaaaaaa\"\
    , \"bb\", \"cc\"])\n/// \"aaaaaaa\"\nfunc find_max(words: [String]) -> String\
    \ {\n  var max = (0, words[0])\n  for word in words {\n    let count = get_char_count(string:\
    \ word)\n    if count > max.0 {\n      max = (count, word)\n    }\n  }\n  return\
    \ max.1\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n \
    \   if left.count != right.count {\n        return false\n    }\n    for (l, r)\
    \ in zip(left, right) {\n        if l != r {\n            return false\n     \
    \   }\n    }\n    return true\n}\n            \nassert(find_max(words: [\"name\"\
    , \"of\", \"string\"]) == \"string\")\nassert(find_max(words: [\"name\", \"enam\"\
    , \"game\"]) == \"enam\")\nassert(find_max(words: [\"aaaaaaa\", \"bb\", \"cc\"\
    ]) == \"aaaaaaa\")\nassert(find_max(words: [\"abc\", \"cba\"]) == \"abc\")\nassert(find_max(words:\
    \ [\"play\", \"this\", \"game\", \"of\", \"footbott\"]) == \"footbott\")\nassert(find_max(words:\
    \ [\"we\", \"are\", \"gonna\", \"rock\"]) == \"gonna\")\nassert(find_max(words:\
    \ [\"we\", \"are\", \"a\", \"mad\", \"nation\"]) == \"nation\")\nassert(find_max(words:\
    \ [\"this\", \"is\", \"a\", \"prrk\"]) == \"this\")\nassert(find_max(words: [\"\
    b\"]) == \"b\")\nassert(find_max(words: [\"play\", \"play\", \"play\"]) == \"\
    play\")"
  status: SyntaxError
  stderr: "/tmp/tmp60a6t6hk.swift:15:17: error: cannot find 'get_char_count' in scope\n\
    \    let count = get_char_count(string: word)\n                ^~~~~~~~~~~~~~\n"
  stdout: ''
  timestamp: 1660013456
- exit_code: 1
  program: "\n/// Write a function that accepts an array of strings.\n/// The array\
    \ contains different words. Return the word with maximum number\n/// of unique\
    \ characters. If multiple strings have maximum number of unique\n/// characters,\
    \ return the one which comes first in lexicographical order.\n/// >>> find_max(words:\
    \ [\"name\", \"of\", \"string\"])\n/// \"string\"\n/// >>> find_max(words: [\"\
    name\", \"enam\", \"game\"])\n/// \"enam\"\n/// >>> find_max(words: [\"aaaaaaa\"\
    , \"bb\", \"cc\"])\n/// \"aaaaaaa\"\nfunc find_max(words: [String]) -> String\
    \ {\n    var max_word = words[0]\n    var max_count = 0\n    for var word in words\
    \ {\n        let count = num_unique_chars(word: word)\n        if count > max_count\
    \ {\n            max_count = count\n            max_word = word\n        }\n \
    \   }\n    return max_word\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(find_max(words:\
    \ [\"name\", \"of\", \"string\"]) == \"string\")\nassert(find_max(words: [\"name\"\
    , \"enam\", \"game\"]) == \"enam\")\nassert(find_max(words: [\"aaaaaaa\", \"bb\"\
    , \"cc\"]) == \"aaaaaaa\")\nassert(find_max(words: [\"abc\", \"cba\"]) == \"abc\"\
    )\nassert(find_max(words: [\"play\", \"this\", \"game\", \"of\", \"footbott\"\
    ]) == \"footbott\")\nassert(find_max(words: [\"we\", \"are\", \"gonna\", \"rock\"\
    ]) == \"gonna\")\nassert(find_max(words: [\"we\", \"are\", \"a\", \"mad\", \"\
    nation\"]) == \"nation\")\nassert(find_max(words: [\"this\", \"is\", \"a\", \"\
    prrk\"]) == \"this\")\nassert(find_max(words: [\"b\"]) == \"b\")\nassert(find_max(words:\
    \ [\"play\", \"play\", \"play\"]) == \"play\")"
  status: SyntaxError
  stderr: "/tmp/tmpuh6y7cw5.swift:16:21: error: cannot find 'num_unique_chars' in\
    \ scope\n        let count = num_unique_chars(word: word)\n                  \
    \  ^~~~~~~~~~~~~~~~\n"
  stdout: ''
  timestamp: 1660013456
- exit_code: 1
  program: "\n/// Write a function that accepts an array of strings.\n/// The array\
    \ contains different words. Return the word with maximum number\n/// of unique\
    \ characters. If multiple strings have maximum number of unique\n/// characters,\
    \ return the one which comes first in lexicographical order.\n/// >>> find_max(words:\
    \ [\"name\", \"of\", \"string\"])\n/// \"string\"\n/// >>> find_max(words: [\"\
    name\", \"enam\", \"game\"])\n/// \"enam\"\n/// >>> find_max(words: [\"aaaaaaa\"\
    , \"bb\", \"cc\"])\n/// \"aaaaaaa\"\nfunc find_max(words: [String]) -> String\
    \ {\n    var max_word = \"\"\n    var max_count = 0\n    for word in words {\n\
    \        let unique_letters = Set(word.characters)\n        if unique_letters.count\
    \ > max_count {\n            max_count = unique_letters.count\n            max_word\
    \ = word\n        }\n    }\n    return max_word\n}\n\n\nfunc ==(left: [(Int, Int)],\
    \ right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n       \
    \ return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r\
    \ {\n            return false\n        }\n    }\n    return true\n}\n        \
    \    \nassert(find_max(words: [\"name\", \"of\", \"string\"]) == \"string\")\n\
    assert(find_max(words: [\"name\", \"enam\", \"game\"]) == \"enam\")\nassert(find_max(words:\
    \ [\"aaaaaaa\", \"bb\", \"cc\"]) == \"aaaaaaa\")\nassert(find_max(words: [\"abc\"\
    , \"cba\"]) == \"abc\")\nassert(find_max(words: [\"play\", \"this\", \"game\"\
    , \"of\", \"footbott\"]) == \"footbott\")\nassert(find_max(words: [\"we\", \"\
    are\", \"gonna\", \"rock\"]) == \"gonna\")\nassert(find_max(words: [\"we\", \"\
    are\", \"a\", \"mad\", \"nation\"]) == \"nation\")\nassert(find_max(words: [\"\
    this\", \"is\", \"a\", \"prrk\"]) == \"this\")\nassert(find_max(words: [\"b\"\
    ]) == \"b\")\nassert(find_max(words: [\"play\", \"play\", \"play\"]) == \"play\"\
    )"
  status: SyntaxError
  stderr: "/tmp/tmp_nf6o7yv.swift:16:39: error: 'characters' is unavailable: Please\
    \ use String directly\n        let unique_letters = Set(word.characters)\n   \
    \                                   ^~~~~~~~~~\nSwift.String:5:16: note: 'characters'\
    \ was obsoleted in Swift 5.0\n    public var characters: String { get set }\n\
    \               ^\n"
  stdout: ''
  timestamp: 1660013456
- exit_code: 0
  program: "\n/// Write a function that accepts an array of strings.\n/// The array\
    \ contains different words. Return the word with maximum number\n/// of unique\
    \ characters. If multiple strings have maximum number of unique\n/// characters,\
    \ return the one which comes first in lexicographical order.\n/// >>> find_max(words:\
    \ [\"name\", \"of\", \"string\"])\n/// \"string\"\n/// >>> find_max(words: [\"\
    name\", \"enam\", \"game\"])\n/// \"enam\"\n/// >>> find_max(words: [\"aaaaaaa\"\
    , \"bb\", \"cc\"])\n/// \"aaaaaaa\"\nfunc find_max(words: [String]) -> String\
    \ {\n    guard words.count > 0 else {\n        return \"\"\n    }\n    let count\
    \ = words.count\n    var maxUniqueChars = Set<Character>()\n    var result = words[0]\n\
    \    for i in 0..<count {\n        let word = words[i]\n        var currentSet\
    \ = Set<Character>()\n        for j in 0..<word.count {\n            let char\
    \ = word[word.index(word.startIndex, offsetBy: j)]\n            currentSet.insert(char)\n\
    \        }\n        if currentSet.count > maxUniqueChars.count {\n           \
    \ maxUniqueChars = currentSet\n            result = word\n        } else if currentSet.count\
    \ == maxUniqueChars.count {\n            result = min(result, word)\n        }\n\
    \    }\n    return result\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(find_max(words:\
    \ [\"name\", \"of\", \"string\"]) == \"string\")\nassert(find_max(words: [\"name\"\
    , \"enam\", \"game\"]) == \"enam\")\nassert(find_max(words: [\"aaaaaaa\", \"bb\"\
    , \"cc\"]) == \"aaaaaaa\")\nassert(find_max(words: [\"abc\", \"cba\"]) == \"abc\"\
    )\nassert(find_max(words: [\"play\", \"this\", \"game\", \"of\", \"footbott\"\
    ]) == \"footbott\")\nassert(find_max(words: [\"we\", \"are\", \"gonna\", \"rock\"\
    ]) == \"gonna\")\nassert(find_max(words: [\"we\", \"are\", \"a\", \"mad\", \"\
    nation\"]) == \"nation\")\nassert(find_max(words: [\"this\", \"is\", \"a\", \"\
    prrk\"]) == \"this\")\nassert(find_max(words: [\"b\"]) == \"b\")\nassert(find_max(words:\
    \ [\"play\", \"play\", \"play\"]) == \"play\")"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660013456
- exit_code: -4
  program: "\n/// Write a function that accepts an array of strings.\n/// The array\
    \ contains different words. Return the word with maximum number\n/// of unique\
    \ characters. If multiple strings have maximum number of unique\n/// characters,\
    \ return the one which comes first in lexicographical order.\n/// >>> find_max(words:\
    \ [\"name\", \"of\", \"string\"])\n/// \"string\"\n/// >>> find_max(words: [\"\
    name\", \"enam\", \"game\"])\n/// \"enam\"\n/// >>> find_max(words: [\"aaaaaaa\"\
    , \"bb\", \"cc\"])\n/// \"aaaaaaa\"\nfunc find_max(words: [String]) -> String\
    \ {\n    let sorted = words.sorted()\n    guard sorted.count > 0 else { return\
    \ \"\" }\n    var dict = sorted.reduce(into: [:]) { $0[$1] = $1.count }\n    let\
    \ max = dict.max { a, b in a.value < b.value }\n    return max?.key ?? \"\"\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(find_max(words: [\"name\", \"of\", \"string\"\
    ]) == \"string\")\nassert(find_max(words: [\"name\", \"enam\", \"game\"]) == \"\
    enam\")\nassert(find_max(words: [\"aaaaaaa\", \"bb\", \"cc\"]) == \"aaaaaaa\"\
    )\nassert(find_max(words: [\"abc\", \"cba\"]) == \"abc\")\nassert(find_max(words:\
    \ [\"play\", \"this\", \"game\", \"of\", \"footbott\"]) == \"footbott\")\nassert(find_max(words:\
    \ [\"we\", \"are\", \"gonna\", \"rock\"]) == \"gonna\")\nassert(find_max(words:\
    \ [\"we\", \"are\", \"a\", \"mad\", \"nation\"]) == \"nation\")\nassert(find_max(words:\
    \ [\"this\", \"is\", \"a\", \"prrk\"]) == \"this\")\nassert(find_max(words: [\"\
    b\"]) == \"b\")\nassert(find_max(words: [\"play\", \"play\", \"play\"]) == \"\
    play\")"
  status: Exception
  stderr: 'tmpq5mgz6u8/tmpq5mgz6u8.swift:34: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b29bb72ec80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b29bb425b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b29bb425988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b29bb4247b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpq5mgz6u8                        0x00005604374fb9c3 <unavailable> + 6595

    5    libc.so.6                          0x00002b29bb91a460 __libc_start_main +
    245

    6    tmpq5mgz6u8                        0x00005604374fb3e9 <unavailable> + 5097

    '
  stdout: ''
  timestamp: 1660013456
- exit_code: 1
  program: "\n/// Write a function that accepts an array of strings.\n/// The array\
    \ contains different words. Return the word with maximum number\n/// of unique\
    \ characters. If multiple strings have maximum number of unique\n/// characters,\
    \ return the one which comes first in lexicographical order.\n/// >>> find_max(words:\
    \ [\"name\", \"of\", \"string\"])\n/// \"string\"\n/// >>> find_max(words: [\"\
    name\", \"enam\", \"game\"])\n/// \"enam\"\n/// >>> find_max(words: [\"aaaaaaa\"\
    , \"bb\", \"cc\"])\n/// \"aaaaaaa\"\nfunc find_max(words: [String]) -> String\
    \ {\n    var maxWord = words[0]\n    var maxNum = 0\n    for word in words {\n\
    \        let num = numOfUnique(word: word)\n        if num > maxNum {\n      \
    \      maxNum = num\n            maxWord = word\n        }\n    }\n    return\
    \ maxWord\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n\
    \    if left.count != right.count {\n        return false\n    }\n    for (l,\
    \ r) in zip(left, right) {\n        if l != r {\n            return false\n  \
    \      }\n    }\n    return true\n}\n            \nassert(find_max(words: [\"\
    name\", \"of\", \"string\"]) == \"string\")\nassert(find_max(words: [\"name\"\
    , \"enam\", \"game\"]) == \"enam\")\nassert(find_max(words: [\"aaaaaaa\", \"bb\"\
    , \"cc\"]) == \"aaaaaaa\")\nassert(find_max(words: [\"abc\", \"cba\"]) == \"abc\"\
    )\nassert(find_max(words: [\"play\", \"this\", \"game\", \"of\", \"footbott\"\
    ]) == \"footbott\")\nassert(find_max(words: [\"we\", \"are\", \"gonna\", \"rock\"\
    ]) == \"gonna\")\nassert(find_max(words: [\"we\", \"are\", \"a\", \"mad\", \"\
    nation\"]) == \"nation\")\nassert(find_max(words: [\"this\", \"is\", \"a\", \"\
    prrk\"]) == \"this\")\nassert(find_max(words: [\"b\"]) == \"b\")\nassert(find_max(words:\
    \ [\"play\", \"play\", \"play\"]) == \"play\")"
  status: SyntaxError
  stderr: "/tmp/tmpzcdqh6uw.swift:16:19: error: cannot find 'numOfUnique' in scope\n\
    \        let num = numOfUnique(word: word)\n                  ^~~~~~~~~~~\n"
  stdout: ''
  timestamp: 1660013456
- exit_code: -4
  program: "\n/// Write a function that accepts an array of strings.\n/// The array\
    \ contains different words. Return the word with maximum number\n/// of unique\
    \ characters. If multiple strings have maximum number of unique\n/// characters,\
    \ return the one which comes first in lexicographical order.\n/// >>> find_max(words:\
    \ [\"name\", \"of\", \"string\"])\n/// \"string\"\n/// >>> find_max(words: [\"\
    name\", \"enam\", \"game\"])\n/// \"enam\"\n/// >>> find_max(words: [\"aaaaaaa\"\
    , \"bb\", \"cc\"])\n/// \"aaaaaaa\"\nfunc find_max(words: [String]) -> String\
    \ {\n  // TODO: write your code here\n  return \"\"\n}\n\n\nfunc ==(left: [(Int,\
    \ Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n\
    \        return false\n    }\n    for (l, r) in zip(left, right) {\n        if\
    \ l != r {\n            return false\n        }\n    }\n    return true\n}\n \
    \           \nassert(find_max(words: [\"name\", \"of\", \"string\"]) == \"string\"\
    )\nassert(find_max(words: [\"name\", \"enam\", \"game\"]) == \"enam\")\nassert(find_max(words:\
    \ [\"aaaaaaa\", \"bb\", \"cc\"]) == \"aaaaaaa\")\nassert(find_max(words: [\"abc\"\
    , \"cba\"]) == \"abc\")\nassert(find_max(words: [\"play\", \"this\", \"game\"\
    , \"of\", \"footbott\"]) == \"footbott\")\nassert(find_max(words: [\"we\", \"\
    are\", \"gonna\", \"rock\"]) == \"gonna\")\nassert(find_max(words: [\"we\", \"\
    are\", \"a\", \"mad\", \"nation\"]) == \"nation\")\nassert(find_max(words: [\"\
    this\", \"is\", \"a\", \"prrk\"]) == \"this\")\nassert(find_max(words: [\"b\"\
    ]) == \"b\")\nassert(find_max(words: [\"play\", \"play\", \"play\"]) == \"play\"\
    )"
  status: Exception
  stderr: 'tmphwqh7ar9/tmphwqh7ar9.swift:30: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b22b92c7c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b22b8fbeb6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b22b8fbe988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b22b8fbd7b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmphwqh7ar9                        0x000055ce94b6f4ce <unavailable> + 5326

    5    libc.so.6                          0x00002b22b94b3460 __libc_start_main +
    245

    6    tmphwqh7ar9                        0x000055ce94b6f089 <unavailable> + 4233

    '
  stdout: ''
  timestamp: 1660013456
- exit_code: -4
  program: "\n/// Write a function that accepts an array of strings.\n/// The array\
    \ contains different words. Return the word with maximum number\n/// of unique\
    \ characters. If multiple strings have maximum number of unique\n/// characters,\
    \ return the one which comes first in lexicographical order.\n/// >>> find_max(words:\
    \ [\"name\", \"of\", \"string\"])\n/// \"string\"\n/// >>> find_max(words: [\"\
    name\", \"enam\", \"game\"])\n/// \"enam\"\n/// >>> find_max(words: [\"aaaaaaa\"\
    , \"bb\", \"cc\"])\n/// \"aaaaaaa\"\nfunc find_max(words: [String]) -> String\
    \ {\n    // initialise the variable which will store the maximum number of unique\
    \ characters\n    var maxUniques = 0\n    // initialise the variable which will\
    \ be used to return the correct word\n    var wordToReturn = \"\"\n    // iterate\
    \ through the array of strings\n    for word in words {\n        // create a set\
    \ from the word\n        let chars = Set(word)\n        // check if the number\
    \ of characters in the set is greater than the current max\n        if chars.count\
    \ > maxUniques {\n            // if it is, set the max to the new maximum and\
    \ the word to return to the correct word\n            maxUniques = chars.count\n\
    \            wordToReturn = word\n        }\n    }\n    // return the word to\
    \ return\n    return wordToReturn\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int,\
    \ Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n\
    \    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n          \
    \  return false\n        }\n    }\n    return true\n}\n            \nassert(find_max(words:\
    \ [\"name\", \"of\", \"string\"]) == \"string\")\nassert(find_max(words: [\"name\"\
    , \"enam\", \"game\"]) == \"enam\")\nassert(find_max(words: [\"aaaaaaa\", \"bb\"\
    , \"cc\"]) == \"aaaaaaa\")\nassert(find_max(words: [\"abc\", \"cba\"]) == \"abc\"\
    )\nassert(find_max(words: [\"play\", \"this\", \"game\", \"of\", \"footbott\"\
    ]) == \"footbott\")\nassert(find_max(words: [\"we\", \"are\", \"gonna\", \"rock\"\
    ]) == \"gonna\")\nassert(find_max(words: [\"we\", \"are\", \"a\", \"mad\", \"\
    nation\"]) == \"nation\")\nassert(find_max(words: [\"this\", \"is\", \"a\", \"\
    prrk\"]) == \"this\")\nassert(find_max(words: [\"b\"]) == \"b\")\nassert(find_max(words:\
    \ [\"play\", \"play\", \"play\"]) == \"play\")"
  status: Exception
  stderr: 'tmp21ucfear/tmp21ucfear.swift:46: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002afef562fc80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002afef5326b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002afef5326988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002afef53257b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmp21ucfear                        0x000055ce1db14933 <unavailable> + 6451

    5    libc.so.6                          0x00002afef581b460 __libc_start_main +
    245

    6    tmp21ucfear                        0x000055ce1db14359 <unavailable> + 4953

    '
  stdout: ''
  timestamp: 1660013456
- exit_code: -4
  program: "\n/// Write a function that accepts an array of strings.\n/// The array\
    \ contains different words. Return the word with maximum number\n/// of unique\
    \ characters. If multiple strings have maximum number of unique\n/// characters,\
    \ return the one which comes first in lexicographical order.\n/// >>> find_max(words:\
    \ [\"name\", \"of\", \"string\"])\n/// \"string\"\n/// >>> find_max(words: [\"\
    name\", \"enam\", \"game\"])\n/// \"enam\"\n/// >>> find_max(words: [\"aaaaaaa\"\
    , \"bb\", \"cc\"])\n/// \"aaaaaaa\"\nfunc find_max(words: [String]) -> String\
    \ {\n    var maxUniqueChars = 0\n    var maxWord = \"\"\n    for word in words\
    \ {\n        let unique = Set(word)\n        if unique.count > maxUniqueChars\
    \ {\n            maxUniqueChars = unique.count\n            maxWord = word\n \
    \       }\n    }\n    return maxWord\n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(find_max(words: [\"name\", \"of\", \"string\"]) == \"string\")\nassert(find_max(words:\
    \ [\"name\", \"enam\", \"game\"]) == \"enam\")\nassert(find_max(words: [\"aaaaaaa\"\
    , \"bb\", \"cc\"]) == \"aaaaaaa\")\nassert(find_max(words: [\"abc\", \"cba\"])\
    \ == \"abc\")\nassert(find_max(words: [\"play\", \"this\", \"game\", \"of\", \"\
    footbott\"]) == \"footbott\")\nassert(find_max(words: [\"we\", \"are\", \"gonna\"\
    , \"rock\"]) == \"gonna\")\nassert(find_max(words: [\"we\", \"are\", \"a\", \"\
    mad\", \"nation\"]) == \"nation\")\nassert(find_max(words: [\"this\", \"is\",\
    \ \"a\", \"prrk\"]) == \"this\")\nassert(find_max(words: [\"b\"]) == \"b\")\n\
    assert(find_max(words: [\"play\", \"play\", \"play\"]) == \"play\")"
  status: Exception
  stderr: 'tmp_402294n/tmp_402294n.swift:39: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002acc18f9bc80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002acc18c92b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002acc18c92988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002acc18c917b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmp_402294n                        0x000055a1f23f8933 <unavailable> + 6451

    5    libc.so.6                          0x00002acc19187460 __libc_start_main +
    245

    6    tmp_402294n                        0x000055a1f23f8359 <unavailable> + 4953

    '
  stdout: ''
  timestamp: 1660013456
- exit_code: 1
  program: "\n/// Write a function that accepts an array of strings.\n/// The array\
    \ contains different words. Return the word with maximum number\n/// of unique\
    \ characters. If multiple strings have maximum number of unique\n/// characters,\
    \ return the one which comes first in lexicographical order.\n/// >>> find_max(words:\
    \ [\"name\", \"of\", \"string\"])\n/// \"string\"\n/// >>> find_max(words: [\"\
    name\", \"enam\", \"game\"])\n/// \"enam\"\n/// >>> find_max(words: [\"aaaaaaa\"\
    , \"bb\", \"cc\"])\n/// \"aaaaaaa\"\nfunc find_max(words: [String]) -> String\
    \ {\n    return words.map { $0.reduce(into: [:]) { $0[$1, default: 0] += 1 } }\n\
    \        .map { $0.filter { $0.value == 1 }.count }\n        .enumerated()\n \
    \       .max { $0.element < $1.element }!.element\n}\n\n\nfunc ==(left: [(Int,\
    \ Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n\
    \        return false\n    }\n    for (l, r) in zip(left, right) {\n        if\
    \ l != r {\n            return false\n        }\n    }\n    return true\n}\n \
    \           \nassert(find_max(words: [\"name\", \"of\", \"string\"]) == \"string\"\
    )\nassert(find_max(words: [\"name\", \"enam\", \"game\"]) == \"enam\")\nassert(find_max(words:\
    \ [\"aaaaaaa\", \"bb\", \"cc\"]) == \"aaaaaaa\")\nassert(find_max(words: [\"abc\"\
    , \"cba\"]) == \"abc\")\nassert(find_max(words: [\"play\", \"this\", \"game\"\
    , \"of\", \"footbott\"]) == \"footbott\")\nassert(find_max(words: [\"we\", \"\
    are\", \"gonna\", \"rock\"]) == \"gonna\")\nassert(find_max(words: [\"we\", \"\
    are\", \"a\", \"mad\", \"nation\"]) == \"nation\")\nassert(find_max(words: [\"\
    this\", \"is\", \"a\", \"prrk\"]) == \"this\")\nassert(find_max(words: [\"b\"\
    ]) == \"b\")\nassert(find_max(words: [\"play\", \"play\", \"play\"]) == \"play\"\
    )"
  status: SyntaxError
  stderr: "/tmp/tmpbhr66jbo.swift:16:43: error: type of expression is ambiguous without\
    \ more context\n        .max { $0.element < $1.element }!.element\n~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~^~~~~~~\n"
  stdout: ''
  timestamp: 1660013472
- exit_code: -4
  program: "\n/// Write a function that accepts an array of strings.\n/// The array\
    \ contains different words. Return the word with maximum number\n/// of unique\
    \ characters. If multiple strings have maximum number of unique\n/// characters,\
    \ return the one which comes first in lexicographical order.\n/// >>> find_max(words:\
    \ [\"name\", \"of\", \"string\"])\n/// \"string\"\n/// >>> find_max(words: [\"\
    name\", \"enam\", \"game\"])\n/// \"enam\"\n/// >>> find_max(words: [\"aaaaaaa\"\
    , \"bb\", \"cc\"])\n/// \"aaaaaaa\"\nfunc find_max(words: [String]) -> String\
    \ {\n    return \"\"\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(find_max(words:\
    \ [\"name\", \"of\", \"string\"]) == \"string\")\nassert(find_max(words: [\"name\"\
    , \"enam\", \"game\"]) == \"enam\")\nassert(find_max(words: [\"aaaaaaa\", \"bb\"\
    , \"cc\"]) == \"aaaaaaa\")\nassert(find_max(words: [\"abc\", \"cba\"]) == \"abc\"\
    )\nassert(find_max(words: [\"play\", \"this\", \"game\", \"of\", \"footbott\"\
    ]) == \"footbott\")\nassert(find_max(words: [\"we\", \"are\", \"gonna\", \"rock\"\
    ]) == \"gonna\")\nassert(find_max(words: [\"we\", \"are\", \"a\", \"mad\", \"\
    nation\"]) == \"nation\")\nassert(find_max(words: [\"this\", \"is\", \"a\", \"\
    prrk\"]) == \"this\")\nassert(find_max(words: [\"b\"]) == \"b\")\nassert(find_max(words:\
    \ [\"play\", \"play\", \"play\"]) == \"play\")"
  status: Exception
  stderr: 'tmp9vfthvyx/tmp9vfthvyx.swift:29: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b5bb598bc80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b5bb5682b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b5bb5682988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b5bb56817b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmp9vfthvyx                        0x0000564c87ea64ce <unavailable> + 5326

    5    libc.so.6                          0x00002b5bb5b77460 __libc_start_main +
    245

    6    tmp9vfthvyx                        0x0000564c87ea6089 <unavailable> + 4233

    '
  stdout: ''
  timestamp: 1660013265
- exit_code: 1
  program: "\n/// Write a function that accepts an array of strings.\n/// The array\
    \ contains different words. Return the word with maximum number\n/// of unique\
    \ characters. If multiple strings have maximum number of unique\n/// characters,\
    \ return the one which comes first in lexicographical order.\n/// >>> find_max(words:\
    \ [\"name\", \"of\", \"string\"])\n/// \"string\"\n/// >>> find_max(words: [\"\
    name\", \"enam\", \"game\"])\n/// \"enam\"\n/// >>> find_max(words: [\"aaaaaaa\"\
    , \"bb\", \"cc\"])\n/// \"aaaaaaa\"\nfunc find_max(words: [String]) -> String\
    \ {\n    return words.reduce(\"\") {\n        (best, word) in\n        if word.countUniqueCharacters()\
    \ > best.countUniqueCharacters() {\n            return word\n        } else if\
    \ word.countUniqueCharacters() == best.countUniqueCharacters() {\n           \
    \ return word.compare(best) == .orderedAscending ? word : best\n        } else\
    \ {\n            return best\n        }\n    }\n}\n\n\nfunc ==(left: [(Int, Int)],\
    \ right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n       \
    \ return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r\
    \ {\n            return false\n        }\n    }\n    return true\n}\n        \
    \    \nassert(find_max(words: [\"name\", \"of\", \"string\"]) == \"string\")\n\
    assert(find_max(words: [\"name\", \"enam\", \"game\"]) == \"enam\")\nassert(find_max(words:\
    \ [\"aaaaaaa\", \"bb\", \"cc\"]) == \"aaaaaaa\")\nassert(find_max(words: [\"abc\"\
    , \"cba\"]) == \"abc\")\nassert(find_max(words: [\"play\", \"this\", \"game\"\
    , \"of\", \"footbott\"]) == \"footbott\")\nassert(find_max(words: [\"we\", \"\
    are\", \"gonna\", \"rock\"]) == \"gonna\")\nassert(find_max(words: [\"we\", \"\
    are\", \"a\", \"mad\", \"nation\"]) == \"nation\")\nassert(find_max(words: [\"\
    this\", \"is\", \"a\", \"prrk\"]) == \"this\")\nassert(find_max(words: [\"b\"\
    ]) == \"b\")\nassert(find_max(words: [\"play\", \"play\", \"play\"]) == \"play\"\
    )"
  status: SyntaxError
  stderr: "/tmp/tmpnl156acp.swift:15:17: error: value of type 'String' has no member\
    \ 'countUniqueCharacters'\n        if word.countUniqueCharacters() > best.countUniqueCharacters()\
    \ {\n           ~~~~ ^~~~~~~~~~~~~~~~~~~~~\n/tmp/tmpnl156acp.swift:15:48: error:\
    \ value of type 'String' has no member 'countUniqueCharacters'\n        if word.countUniqueCharacters()\
    \ > best.countUniqueCharacters() {\n                                         \
    \ ~~~~ ^~~~~~~~~~~~~~~~~~~~~\n"
  stdout: ''
  timestamp: 1660013456
- exit_code: -4
  program: "\n/// Write a function that accepts an array of strings.\n/// The array\
    \ contains different words. Return the word with maximum number\n/// of unique\
    \ characters. If multiple strings have maximum number of unique\n/// characters,\
    \ return the one which comes first in lexicographical order.\n/// >>> find_max(words:\
    \ [\"name\", \"of\", \"string\"])\n/// \"string\"\n/// >>> find_max(words: [\"\
    name\", \"enam\", \"game\"])\n/// \"enam\"\n/// >>> find_max(words: [\"aaaaaaa\"\
    , \"bb\", \"cc\"])\n/// \"aaaaaaa\"\nfunc find_max(words: [String]) -> String\
    \ {\n    var max = 0\n    var word = \"\"\n    for item in words {\n        let\
    \ s = Set(item)\n        if s.count > max {\n            max = s.count\n     \
    \       word = item\n        }\n    }\n    return word\n}\n\n\nfunc ==(left: [(Int,\
    \ Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n\
    \        return false\n    }\n    for (l, r) in zip(left, right) {\n        if\
    \ l != r {\n            return false\n        }\n    }\n    return true\n}\n \
    \           \nassert(find_max(words: [\"name\", \"of\", \"string\"]) == \"string\"\
    )\nassert(find_max(words: [\"name\", \"enam\", \"game\"]) == \"enam\")\nassert(find_max(words:\
    \ [\"aaaaaaa\", \"bb\", \"cc\"]) == \"aaaaaaa\")\nassert(find_max(words: [\"abc\"\
    , \"cba\"]) == \"abc\")\nassert(find_max(words: [\"play\", \"this\", \"game\"\
    , \"of\", \"footbott\"]) == \"footbott\")\nassert(find_max(words: [\"we\", \"\
    are\", \"gonna\", \"rock\"]) == \"gonna\")\nassert(find_max(words: [\"we\", \"\
    are\", \"a\", \"mad\", \"nation\"]) == \"nation\")\nassert(find_max(words: [\"\
    this\", \"is\", \"a\", \"prrk\"]) == \"this\")\nassert(find_max(words: [\"b\"\
    ]) == \"b\")\nassert(find_max(words: [\"play\", \"play\", \"play\"]) == \"play\"\
    )"
  status: Exception
  stderr: 'tmp2dmkhlmh/tmp2dmkhlmh.swift:39: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b776e88ec80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b776e585b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b776e585988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b776e5847b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmp2dmkhlmh                        0x000055dc70482933 <unavailable> + 6451

    5    libc.so.6                          0x00002b776ea7a460 __libc_start_main +
    245

    6    tmp2dmkhlmh                        0x000055dc70482359 <unavailable> + 4953

    '
  stdout: ''
  timestamp: 1660013456
- exit_code: -4
  program: "\n/// Write a function that accepts an array of strings.\n/// The array\
    \ contains different words. Return the word with maximum number\n/// of unique\
    \ characters. If multiple strings have maximum number of unique\n/// characters,\
    \ return the one which comes first in lexicographical order.\n/// >>> find_max(words:\
    \ [\"name\", \"of\", \"string\"])\n/// \"string\"\n/// >>> find_max(words: [\"\
    name\", \"enam\", \"game\"])\n/// \"enam\"\n/// >>> find_max(words: [\"aaaaaaa\"\
    , \"bb\", \"cc\"])\n/// \"aaaaaaa\"\nfunc find_max(words: [String]) -> String\
    \ {\n    var max = 0\n    var maxWord = \"\"\n    for word in words {\n      \
    \  var set = Set<Character>()\n        for char in word {\n            set.insert(char)\n\
    \        }\n        if set.count > max {\n            max = set.count\n      \
    \      maxWord = word\n        }\n    }\n    return maxWord\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(find_max(words: [\"name\", \"of\", \"string\"]) == \"\
    string\")\nassert(find_max(words: [\"name\", \"enam\", \"game\"]) == \"enam\"\
    )\nassert(find_max(words: [\"aaaaaaa\", \"bb\", \"cc\"]) == \"aaaaaaa\")\nassert(find_max(words:\
    \ [\"abc\", \"cba\"]) == \"abc\")\nassert(find_max(words: [\"play\", \"this\"\
    , \"game\", \"of\", \"footbott\"]) == \"footbott\")\nassert(find_max(words: [\"\
    we\", \"are\", \"gonna\", \"rock\"]) == \"gonna\")\nassert(find_max(words: [\"\
    we\", \"are\", \"a\", \"mad\", \"nation\"]) == \"nation\")\nassert(find_max(words:\
    \ [\"this\", \"is\", \"a\", \"prrk\"]) == \"this\")\nassert(find_max(words: [\"\
    b\"]) == \"b\")\nassert(find_max(words: [\"play\", \"play\", \"play\"]) == \"\
    play\")"
  status: Exception
  stderr: 'tmp32h7l1jz/tmp32h7l1jz.swift:42: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002ae71c735c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002ae71c42cb6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002ae71c42c988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002ae71c42b7b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmp32h7l1jz                        0x000055ea49b28a03 <unavailable> + 6659

    5    libc.so.6                          0x00002ae71c921460 __libc_start_main +
    245

    6    tmp32h7l1jz                        0x000055ea49b28429 <unavailable> + 5161

    '
  stdout: ''
  timestamp: 1660013456
- exit_code: -4
  program: "\n/// Write a function that accepts an array of strings.\n/// The array\
    \ contains different words. Return the word with maximum number\n/// of unique\
    \ characters. If multiple strings have maximum number of unique\n/// characters,\
    \ return the one which comes first in lexicographical order.\n/// >>> find_max(words:\
    \ [\"name\", \"of\", \"string\"])\n/// \"string\"\n/// >>> find_max(words: [\"\
    name\", \"enam\", \"game\"])\n/// \"enam\"\n/// >>> find_max(words: [\"aaaaaaa\"\
    , \"bb\", \"cc\"])\n/// \"aaaaaaa\"\nfunc find_max(words: [String]) -> String\
    \ {\n    \n    var count = 0\n    var tempCount = 0\n    var index = 0\n    var\
    \ tempIndex = 0\n    \n    for (i,word) in words.enumerated() {\n        tempCount\
    \ = 0\n        for char in word {\n            if !words[index].contains(char)\
    \ {\n                tempCount += 1\n            }\n        }\n        if tempCount\
    \ > count {\n            count = tempCount\n            index = i\n        }\n\
    \    }\n    return words[index]\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int,\
    \ Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n\
    \    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n          \
    \  return false\n        }\n    }\n    return true\n}\n            \nassert(find_max(words:\
    \ [\"name\", \"of\", \"string\"]) == \"string\")\nassert(find_max(words: [\"name\"\
    , \"enam\", \"game\"]) == \"enam\")\nassert(find_max(words: [\"aaaaaaa\", \"bb\"\
    , \"cc\"]) == \"aaaaaaa\")\nassert(find_max(words: [\"abc\", \"cba\"]) == \"abc\"\
    )\nassert(find_max(words: [\"play\", \"this\", \"game\", \"of\", \"footbott\"\
    ]) == \"footbott\")\nassert(find_max(words: [\"we\", \"are\", \"gonna\", \"rock\"\
    ]) == \"gonna\")\nassert(find_max(words: [\"we\", \"are\", \"a\", \"mad\", \"\
    nation\"]) == \"nation\")\nassert(find_max(words: [\"this\", \"is\", \"a\", \"\
    prrk\"]) == \"this\")\nassert(find_max(words: [\"b\"]) == \"b\")\nassert(find_max(words:\
    \ [\"play\", \"play\", \"play\"]) == \"play\")"
  status: Exception
  stderr: 'tmpehty54w8/tmpehty54w8.swift:48: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b865f644c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b865f33bb6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b865f33b988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b865f33a7b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpehty54w8                        0x000055844702ba63 <unavailable> + 6755

    5    libc.so.6                          0x00002b865f830460 __libc_start_main +
    245

    6    tmpehty54w8                        0x000055844702b489 <unavailable> + 5257

    '
  stdout: ''
  timestamp: 1660013456
- exit_code: 1
  program: "\n/// Write a function that accepts an array of strings.\n/// The array\
    \ contains different words. Return the word with maximum number\n/// of unique\
    \ characters. If multiple strings have maximum number of unique\n/// characters,\
    \ return the one which comes first in lexicographical order.\n/// >>> find_max(words:\
    \ [\"name\", \"of\", \"string\"])\n/// \"string\"\n/// >>> find_max(words: [\"\
    name\", \"enam\", \"game\"])\n/// \"enam\"\n/// >>> find_max(words: [\"aaaaaaa\"\
    , \"bb\", \"cc\"])\n/// \"aaaaaaa\"\nfunc find_max(words: [String]) -> String\
    \ {\n    guard !words.isEmpty else { return \"\" }\n    let sortedWords = words.sorted\
    \ { $0 < $1 }\n    let unique = sortedWords.map { Set($0) }\n    guard let max\
    \ = unique.max(by: { $0.count < $1.count }) else { return \"\" }\n    let maxWords\
    \ = unique.filter { $0.count == max.count }\n    return maxWords.first!\n}\n\n\
    \nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(find_max(words: [\"name\", \"of\", \"string\"\
    ]) == \"string\")\nassert(find_max(words: [\"name\", \"enam\", \"game\"]) == \"\
    enam\")\nassert(find_max(words: [\"aaaaaaa\", \"bb\", \"cc\"]) == \"aaaaaaa\"\
    )\nassert(find_max(words: [\"abc\", \"cba\"]) == \"abc\")\nassert(find_max(words:\
    \ [\"play\", \"this\", \"game\", \"of\", \"footbott\"]) == \"footbott\")\nassert(find_max(words:\
    \ [\"we\", \"are\", \"gonna\", \"rock\"]) == \"gonna\")\nassert(find_max(words:\
    \ [\"we\", \"are\", \"a\", \"mad\", \"nation\"]) == \"nation\")\nassert(find_max(words:\
    \ [\"this\", \"is\", \"a\", \"prrk\"]) == \"this\")\nassert(find_max(words: [\"\
    b\"]) == \"b\")\nassert(find_max(words: [\"play\", \"play\", \"play\"]) == \"\
    play\")"
  status: SyntaxError
  stderr: "/tmp/tmpd702yzw5.swift:18:26: error: cannot convert return expression of\
    \ type 'Set<String.Element>' (aka 'Set<Character>') to return type 'String'\n\
    \    return maxWords.first!\n           ~~~~~~~~~~~~~~^\n"
  stdout: ''
  timestamp: 1660013456
- exit_code: -4
  program: "\n/// Write a function that accepts an array of strings.\n/// The array\
    \ contains different words. Return the word with maximum number\n/// of unique\
    \ characters. If multiple strings have maximum number of unique\n/// characters,\
    \ return the one which comes first in lexicographical order.\n/// >>> find_max(words:\
    \ [\"name\", \"of\", \"string\"])\n/// \"string\"\n/// >>> find_max(words: [\"\
    name\", \"enam\", \"game\"])\n/// \"enam\"\n/// >>> find_max(words: [\"aaaaaaa\"\
    , \"bb\", \"cc\"])\n/// \"aaaaaaa\"\nfunc find_max(words: [String]) -> String\
    \ {\n    return \"\"\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(find_max(words:\
    \ [\"name\", \"of\", \"string\"]) == \"string\")\nassert(find_max(words: [\"name\"\
    , \"enam\", \"game\"]) == \"enam\")\nassert(find_max(words: [\"aaaaaaa\", \"bb\"\
    , \"cc\"]) == \"aaaaaaa\")\nassert(find_max(words: [\"abc\", \"cba\"]) == \"abc\"\
    )\nassert(find_max(words: [\"play\", \"this\", \"game\", \"of\", \"footbott\"\
    ]) == \"footbott\")\nassert(find_max(words: [\"we\", \"are\", \"gonna\", \"rock\"\
    ]) == \"gonna\")\nassert(find_max(words: [\"we\", \"are\", \"a\", \"mad\", \"\
    nation\"]) == \"nation\")\nassert(find_max(words: [\"this\", \"is\", \"a\", \"\
    prrk\"]) == \"this\")\nassert(find_max(words: [\"b\"]) == \"b\")\nassert(find_max(words:\
    \ [\"play\", \"play\", \"play\"]) == \"play\")"
  status: Exception
  stderr: 'tmp9vfthvyx/tmp9vfthvyx.swift:29: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b5bb598bc80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b5bb5682b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b5bb5682988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b5bb56817b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmp9vfthvyx                        0x0000564c87ea64ce <unavailable> + 5326

    5    libc.so.6                          0x00002b5bb5b77460 __libc_start_main +
    245

    6    tmp9vfthvyx                        0x0000564c87ea6089 <unavailable> + 4233

    '
  stdout: ''
  timestamp: 1660013265
- exit_code: 0
  program: "\n/// Write a function that accepts an array of strings.\n/// The array\
    \ contains different words. Return the word with maximum number\n/// of unique\
    \ characters. If multiple strings have maximum number of unique\n/// characters,\
    \ return the one which comes first in lexicographical order.\n/// >>> find_max(words:\
    \ [\"name\", \"of\", \"string\"])\n/// \"string\"\n/// >>> find_max(words: [\"\
    name\", \"enam\", \"game\"])\n/// \"enam\"\n/// >>> find_max(words: [\"aaaaaaa\"\
    , \"bb\", \"cc\"])\n/// \"aaaaaaa\"\nfunc find_max(words: [String]) -> String\
    \ {\n    var maxCount = 0\n    var maxWord = \"\"\n    for word in words {\n \
    \       let uniqCount = Set(word).count\n        if uniqCount > maxCount {\n \
    \           maxCount = uniqCount\n            maxWord = word\n        } else if\
    \ uniqCount == maxCount {\n            if word < maxWord {\n                maxWord\
    \ = word\n            }\n        }\n    }\n    return maxWord\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(find_max(words: [\"name\", \"of\", \"string\"]) == \"\
    string\")\nassert(find_max(words: [\"name\", \"enam\", \"game\"]) == \"enam\"\
    )\nassert(find_max(words: [\"aaaaaaa\", \"bb\", \"cc\"]) == \"aaaaaaa\")\nassert(find_max(words:\
    \ [\"abc\", \"cba\"]) == \"abc\")\nassert(find_max(words: [\"play\", \"this\"\
    , \"game\", \"of\", \"footbott\"]) == \"footbott\")\nassert(find_max(words: [\"\
    we\", \"are\", \"gonna\", \"rock\"]) == \"gonna\")\nassert(find_max(words: [\"\
    we\", \"are\", \"a\", \"mad\", \"nation\"]) == \"nation\")\nassert(find_max(words:\
    \ [\"this\", \"is\", \"a\", \"prrk\"]) == \"this\")\nassert(find_max(words: [\"\
    b\"]) == \"b\")\nassert(find_max(words: [\"play\", \"play\", \"play\"]) == \"\
    play\")"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660013456
- exit_code: -4
  program: "\n/// Write a function that accepts an array of strings.\n/// The array\
    \ contains different words. Return the word with maximum number\n/// of unique\
    \ characters. If multiple strings have maximum number of unique\n/// characters,\
    \ return the one which comes first in lexicographical order.\n/// >>> find_max(words:\
    \ [\"name\", \"of\", \"string\"])\n/// \"string\"\n/// >>> find_max(words: [\"\
    name\", \"enam\", \"game\"])\n/// \"enam\"\n/// >>> find_max(words: [\"aaaaaaa\"\
    , \"bb\", \"cc\"])\n/// \"aaaaaaa\"\nfunc find_max(words: [String]) -> String\
    \ {\n    // Implement this function\n    var compare = \"\"\n    for word in words\
    \ {\n        if compare.count < word.count {\n            compare = word\n   \
    \     }\n    }\n    return compare\n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(find_max(words: [\"name\", \"of\", \"string\"]) == \"string\")\nassert(find_max(words:\
    \ [\"name\", \"enam\", \"game\"]) == \"enam\")\nassert(find_max(words: [\"aaaaaaa\"\
    , \"bb\", \"cc\"]) == \"aaaaaaa\")\nassert(find_max(words: [\"abc\", \"cba\"])\
    \ == \"abc\")\nassert(find_max(words: [\"play\", \"this\", \"game\", \"of\", \"\
    footbott\"]) == \"footbott\")\nassert(find_max(words: [\"we\", \"are\", \"gonna\"\
    , \"rock\"]) == \"gonna\")\nassert(find_max(words: [\"we\", \"are\", \"a\", \"\
    mad\", \"nation\"]) == \"nation\")\nassert(find_max(words: [\"this\", \"is\",\
    \ \"a\", \"prrk\"]) == \"this\")\nassert(find_max(words: [\"b\"]) == \"b\")\n\
    assert(find_max(words: [\"play\", \"play\", \"play\"]) == \"play\")"
  status: Exception
  stderr: 'tmpt5c50jj6/tmpt5c50jj6.swift:37: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b5ea6922c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b5ea6619b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b5ea6619988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b5ea66187b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpt5c50jj6                        0x000055f3c9dd1823 <unavailable> + 6179

    5    libc.so.6                          0x00002b5ea6b0e460 __libc_start_main +
    245

    6    tmpt5c50jj6                        0x000055f3c9dd1249 <unavailable> + 4681

    '
  stdout: ''
  timestamp: 1660013456
- exit_code: -4
  program: "\n/// Write a function that accepts an array of strings.\n/// The array\
    \ contains different words. Return the word with maximum number\n/// of unique\
    \ characters. If multiple strings have maximum number of unique\n/// characters,\
    \ return the one which comes first in lexicographical order.\n/// >>> find_max(words:\
    \ [\"name\", \"of\", \"string\"])\n/// \"string\"\n/// >>> find_max(words: [\"\
    name\", \"enam\", \"game\"])\n/// \"enam\"\n/// >>> find_max(words: [\"aaaaaaa\"\
    , \"bb\", \"cc\"])\n/// \"aaaaaaa\"\nfunc find_max(words: [String]) -> String\
    \ {\n    return \"\"\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(find_max(words:\
    \ [\"name\", \"of\", \"string\"]) == \"string\")\nassert(find_max(words: [\"name\"\
    , \"enam\", \"game\"]) == \"enam\")\nassert(find_max(words: [\"aaaaaaa\", \"bb\"\
    , \"cc\"]) == \"aaaaaaa\")\nassert(find_max(words: [\"abc\", \"cba\"]) == \"abc\"\
    )\nassert(find_max(words: [\"play\", \"this\", \"game\", \"of\", \"footbott\"\
    ]) == \"footbott\")\nassert(find_max(words: [\"we\", \"are\", \"gonna\", \"rock\"\
    ]) == \"gonna\")\nassert(find_max(words: [\"we\", \"are\", \"a\", \"mad\", \"\
    nation\"]) == \"nation\")\nassert(find_max(words: [\"this\", \"is\", \"a\", \"\
    prrk\"]) == \"this\")\nassert(find_max(words: [\"b\"]) == \"b\")\nassert(find_max(words:\
    \ [\"play\", \"play\", \"play\"]) == \"play\")"
  status: Exception
  stderr: 'tmp9vfthvyx/tmp9vfthvyx.swift:29: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b5bb598bc80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b5bb5682b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b5bb5682988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b5bb56817b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmp9vfthvyx                        0x0000564c87ea64ce <unavailable> + 5326

    5    libc.so.6                          0x00002b5bb5b77460 __libc_start_main +
    245

    6    tmp9vfthvyx                        0x0000564c87ea6089 <unavailable> + 4233

    '
  stdout: ''
  timestamp: 1660013265
- exit_code: 0
  program: "\n/// Write a function that accepts an array of strings.\n/// The array\
    \ contains different words. Return the word with maximum number\n/// of unique\
    \ characters. If multiple strings have maximum number of unique\n/// characters,\
    \ return the one which comes first in lexicographical order.\n/// >>> find_max(words:\
    \ [\"name\", \"of\", \"string\"])\n/// \"string\"\n/// >>> find_max(words: [\"\
    name\", \"enam\", \"game\"])\n/// \"enam\"\n/// >>> find_max(words: [\"aaaaaaa\"\
    , \"bb\", \"cc\"])\n/// \"aaaaaaa\"\nfunc find_max(words: [String]) -> String\
    \ {\n    var maxCharSet: Set<Character> = []\n    var wordMax: String = \"\"\n\
    \    for word in words {\n        let set = Set(word)\n        if set.count >\
    \ maxCharSet.count {\n            maxCharSet = set\n            wordMax = word\n\
    \        } else if set.count == maxCharSet.count && word < wordMax {\n       \
    \     wordMax = word\n        }\n    }\n    return wordMax\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(find_max(words: [\"name\", \"of\", \"string\"]) == \"\
    string\")\nassert(find_max(words: [\"name\", \"enam\", \"game\"]) == \"enam\"\
    )\nassert(find_max(words: [\"aaaaaaa\", \"bb\", \"cc\"]) == \"aaaaaaa\")\nassert(find_max(words:\
    \ [\"abc\", \"cba\"]) == \"abc\")\nassert(find_max(words: [\"play\", \"this\"\
    , \"game\", \"of\", \"footbott\"]) == \"footbott\")\nassert(find_max(words: [\"\
    we\", \"are\", \"gonna\", \"rock\"]) == \"gonna\")\nassert(find_max(words: [\"\
    we\", \"are\", \"a\", \"mad\", \"nation\"]) == \"nation\")\nassert(find_max(words:\
    \ [\"this\", \"is\", \"a\", \"prrk\"]) == \"this\")\nassert(find_max(words: [\"\
    b\"]) == \"b\")\nassert(find_max(words: [\"play\", \"play\", \"play\"]) == \"\
    play\")"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660013456
- exit_code: 1
  program: "\n/// Write a function that accepts an array of strings.\n/// The array\
    \ contains different words. Return the word with maximum number\n/// of unique\
    \ characters. If multiple strings have maximum number of unique\n/// characters,\
    \ return the one which comes first in lexicographical order.\n/// >>> find_max(words:\
    \ [\"name\", \"of\", \"string\"])\n/// \"string\"\n/// >>> find_max(words: [\"\
    name\", \"enam\", \"game\"])\n/// \"enam\"\n/// >>> find_max(words: [\"aaaaaaa\"\
    , \"bb\", \"cc\"])\n/// \"aaaaaaa\"\nfunc find_max(words: [String]) -> String\
    \ {\n    var maxUniqChars: Int = 0\n    var maxWord: String = \"\"\n    for word\
    \ in words {\n        let uniqChars = word.countUniques()\n        if uniqChars\
    \ > maxUniqChars {\n            maxUniqChars = uniqChars\n            maxWord\
    \ = word\n        } else if uniqChars == maxUniqChars && maxWord > word {\n  \
    \          maxWord = word\n        }\n    }\n    return maxWord\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(find_max(words: [\"name\", \"of\", \"string\"]) == \"\
    string\")\nassert(find_max(words: [\"name\", \"enam\", \"game\"]) == \"enam\"\
    )\nassert(find_max(words: [\"aaaaaaa\", \"bb\", \"cc\"]) == \"aaaaaaa\")\nassert(find_max(words:\
    \ [\"abc\", \"cba\"]) == \"abc\")\nassert(find_max(words: [\"play\", \"this\"\
    , \"game\", \"of\", \"footbott\"]) == \"footbott\")\nassert(find_max(words: [\"\
    we\", \"are\", \"gonna\", \"rock\"]) == \"gonna\")\nassert(find_max(words: [\"\
    we\", \"are\", \"a\", \"mad\", \"nation\"]) == \"nation\")\nassert(find_max(words:\
    \ [\"this\", \"is\", \"a\", \"prrk\"]) == \"this\")\nassert(find_max(words: [\"\
    b\"]) == \"b\")\nassert(find_max(words: [\"play\", \"play\", \"play\"]) == \"\
    play\")"
  status: SyntaxError
  stderr: "/tmp/tmpcfa4m598.swift:16:30: error: value of type 'String' has no member\
    \ 'countUniques'\n        let uniqChars = word.countUniques()\n              \
    \          ~~~~ ^~~~~~~~~~~~\n"
  stdout: ''
  timestamp: 1660013456
- exit_code: -4
  program: "\n/// Write a function that accepts an array of strings.\n/// The array\
    \ contains different words. Return the word with maximum number\n/// of unique\
    \ characters. If multiple strings have maximum number of unique\n/// characters,\
    \ return the one which comes first in lexicographical order.\n/// >>> find_max(words:\
    \ [\"name\", \"of\", \"string\"])\n/// \"string\"\n/// >>> find_max(words: [\"\
    name\", \"enam\", \"game\"])\n/// \"enam\"\n/// >>> find_max(words: [\"aaaaaaa\"\
    , \"bb\", \"cc\"])\n/// \"aaaaaaa\"\nfunc find_max(words: [String]) -> String\
    \ {\n    var dictionary: [String: Int] = [:]\n    for word in words {\n      \
    \  let set = Set(word)\n        dictionary[word] = set.count\n    }\n    var maxValue\
    \ = 0\n    var word = \"\"\n    for (key, value) in dictionary {\n        if value\
    \ > maxValue {\n            maxValue = value\n            word = key\n       \
    \ }\n    }\n    return word\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int,\
    \ Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n\
    \    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n          \
    \  return false\n        }\n    }\n    return true\n}\n            \nassert(find_max(words:\
    \ [\"name\", \"of\", \"string\"]) == \"string\")\nassert(find_max(words: [\"name\"\
    , \"enam\", \"game\"]) == \"enam\")\nassert(find_max(words: [\"aaaaaaa\", \"bb\"\
    , \"cc\"]) == \"aaaaaaa\")\nassert(find_max(words: [\"abc\", \"cba\"]) == \"abc\"\
    )\nassert(find_max(words: [\"play\", \"this\", \"game\", \"of\", \"footbott\"\
    ]) == \"footbott\")\nassert(find_max(words: [\"we\", \"are\", \"gonna\", \"rock\"\
    ]) == \"gonna\")\nassert(find_max(words: [\"we\", \"are\", \"a\", \"mad\", \"\
    nation\"]) == \"nation\")\nassert(find_max(words: [\"this\", \"is\", \"a\", \"\
    prrk\"]) == \"this\")\nassert(find_max(words: [\"b\"]) == \"b\")\nassert(find_max(words:\
    \ [\"play\", \"play\", \"play\"]) == \"play\")"
  status: Exception
  stderr: 'tmp6sp30y8o/tmp6sp30y8o.swift:43: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b1baaf26c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b1baac1db6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b1baac1d988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b1baac1c7b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmp6sp30y8o                        0x000055d187028ba3 <unavailable> + 7075

    5    libc.so.6                          0x00002b1bab112460 __libc_start_main +
    245

    6    tmp6sp30y8o                        0x000055d1870285c9 <unavailable> + 5577

    '
  stdout: ''
  timestamp: 1660013456
- exit_code: -4
  program: "\n/// Write a function that accepts an array of strings.\n/// The array\
    \ contains different words. Return the word with maximum number\n/// of unique\
    \ characters. If multiple strings have maximum number of unique\n/// characters,\
    \ return the one which comes first in lexicographical order.\n/// >>> find_max(words:\
    \ [\"name\", \"of\", \"string\"])\n/// \"string\"\n/// >>> find_max(words: [\"\
    name\", \"enam\", \"game\"])\n/// \"enam\"\n/// >>> find_max(words: [\"aaaaaaa\"\
    , \"bb\", \"cc\"])\n/// \"aaaaaaa\"\nfunc find_max(words: [String]) -> String\
    \ {\n    return \"\"\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(find_max(words:\
    \ [\"name\", \"of\", \"string\"]) == \"string\")\nassert(find_max(words: [\"name\"\
    , \"enam\", \"game\"]) == \"enam\")\nassert(find_max(words: [\"aaaaaaa\", \"bb\"\
    , \"cc\"]) == \"aaaaaaa\")\nassert(find_max(words: [\"abc\", \"cba\"]) == \"abc\"\
    )\nassert(find_max(words: [\"play\", \"this\", \"game\", \"of\", \"footbott\"\
    ]) == \"footbott\")\nassert(find_max(words: [\"we\", \"are\", \"gonna\", \"rock\"\
    ]) == \"gonna\")\nassert(find_max(words: [\"we\", \"are\", \"a\", \"mad\", \"\
    nation\"]) == \"nation\")\nassert(find_max(words: [\"this\", \"is\", \"a\", \"\
    prrk\"]) == \"this\")\nassert(find_max(words: [\"b\"]) == \"b\")\nassert(find_max(words:\
    \ [\"play\", \"play\", \"play\"]) == \"play\")"
  status: Exception
  stderr: 'tmp9vfthvyx/tmp9vfthvyx.swift:29: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b5bb598bc80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b5bb5682b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b5bb5682988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b5bb56817b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmp9vfthvyx                        0x0000564c87ea64ce <unavailable> + 5326

    5    libc.so.6                          0x00002b5bb5b77460 __libc_start_main +
    245

    6    tmp9vfthvyx                        0x0000564c87ea6089 <unavailable> + 4233

    '
  stdout: ''
  timestamp: 1660013265
- exit_code: 0
  program: "\n/// Write a function that accepts an array of strings.\n/// The array\
    \ contains different words. Return the word with maximum number\n/// of unique\
    \ characters. If multiple strings have maximum number of unique\n/// characters,\
    \ return the one which comes first in lexicographical order.\n/// >>> find_max(words:\
    \ [\"name\", \"of\", \"string\"])\n/// \"string\"\n/// >>> find_max(words: [\"\
    name\", \"enam\", \"game\"])\n/// \"enam\"\n/// >>> find_max(words: [\"aaaaaaa\"\
    , \"bb\", \"cc\"])\n/// \"aaaaaaa\"\nfunc find_max(words: [String]) -> String\
    \ {\n    guard words.count > 0 else {\n        fatalError(\"Invalid input: array\
    \ is empty\")\n    }\n    var maxCount = 0\n    var maxWord = \"\"\n    for word\
    \ in words {\n        var set = Set<Character>()\n        for char in word {\n\
    \            set.insert(char)\n        }\n        if set.count > maxCount {\n\
    \            maxCount = set.count\n            maxWord = word\n        } else\
    \ if set.count == maxCount {\n            if word < maxWord {\n              \
    \  maxWord = word\n            }\n        }\n    }\n    return maxWord\n}\n\n\n\
    func ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(find_max(words: [\"name\", \"of\", \"string\"\
    ]) == \"string\")\nassert(find_max(words: [\"name\", \"enam\", \"game\"]) == \"\
    enam\")\nassert(find_max(words: [\"aaaaaaa\", \"bb\", \"cc\"]) == \"aaaaaaa\"\
    )\nassert(find_max(words: [\"abc\", \"cba\"]) == \"abc\")\nassert(find_max(words:\
    \ [\"play\", \"this\", \"game\", \"of\", \"footbott\"]) == \"footbott\")\nassert(find_max(words:\
    \ [\"we\", \"are\", \"gonna\", \"rock\"]) == \"gonna\")\nassert(find_max(words:\
    \ [\"we\", \"are\", \"a\", \"mad\", \"nation\"]) == \"nation\")\nassert(find_max(words:\
    \ [\"this\", \"is\", \"a\", \"prrk\"]) == \"this\")\nassert(find_max(words: [\"\
    b\"]) == \"b\")\nassert(find_max(words: [\"play\", \"play\", \"play\"]) == \"\
    play\")"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660013456
- exit_code: -4
  program: "\n/// Write a function that accepts an array of strings.\n/// The array\
    \ contains different words. Return the word with maximum number\n/// of unique\
    \ characters. If multiple strings have maximum number of unique\n/// characters,\
    \ return the one which comes first in lexicographical order.\n/// >>> find_max(words:\
    \ [\"name\", \"of\", \"string\"])\n/// \"string\"\n/// >>> find_max(words: [\"\
    name\", \"enam\", \"game\"])\n/// \"enam\"\n/// >>> find_max(words: [\"aaaaaaa\"\
    , \"bb\", \"cc\"])\n/// \"aaaaaaa\"\nfunc find_max(words: [String]) -> String\
    \ {\n    var result = \"\"\n    var uniqueCharacters: Set<Character>\n    var\
    \ maxNumCharacters = 0\n    for word in words {\n        uniqueCharacters = Set(word)\n\
    \        if maxNumCharacters < uniqueCharacters.count {\n            maxNumCharacters\
    \ = uniqueCharacters.count\n            result = word\n        }\n    }\n    return\
    \ result\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n\
    \    if left.count != right.count {\n        return false\n    }\n    for (l,\
    \ r) in zip(left, right) {\n        if l != r {\n            return false\n  \
    \      }\n    }\n    return true\n}\n            \nassert(find_max(words: [\"\
    name\", \"of\", \"string\"]) == \"string\")\nassert(find_max(words: [\"name\"\
    , \"enam\", \"game\"]) == \"enam\")\nassert(find_max(words: [\"aaaaaaa\", \"bb\"\
    , \"cc\"]) == \"aaaaaaa\")\nassert(find_max(words: [\"abc\", \"cba\"]) == \"abc\"\
    )\nassert(find_max(words: [\"play\", \"this\", \"game\", \"of\", \"footbott\"\
    ]) == \"footbott\")\nassert(find_max(words: [\"we\", \"are\", \"gonna\", \"rock\"\
    ]) == \"gonna\")\nassert(find_max(words: [\"we\", \"are\", \"a\", \"mad\", \"\
    nation\"]) == \"nation\")\nassert(find_max(words: [\"this\", \"is\", \"a\", \"\
    prrk\"]) == \"this\")\nassert(find_max(words: [\"b\"]) == \"b\")\nassert(find_max(words:\
    \ [\"play\", \"play\", \"play\"]) == \"play\")"
  status: Exception
  stderr: 'tmpbiqot19a/tmpbiqot19a.swift:40: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b4890737c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b489042eb6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b489042e988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b489042d7b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpbiqot19a                        0x000055ebfddd7933 <unavailable> + 6451

    5    libc.so.6                          0x00002b4890923460 __libc_start_main +
    245

    6    tmpbiqot19a                        0x000055ebfddd7359 <unavailable> + 4953

    '
  stdout: ''
  timestamp: 1660013456
- exit_code: 1
  program: "\n/// Write a function that accepts an array of strings.\n/// The array\
    \ contains different words. Return the word with maximum number\n/// of unique\
    \ characters. If multiple strings have maximum number of unique\n/// characters,\
    \ return the one which comes first in lexicographical order.\n/// >>> find_max(words:\
    \ [\"name\", \"of\", \"string\"])\n/// \"string\"\n/// >>> find_max(words: [\"\
    name\", \"enam\", \"game\"])\n/// \"enam\"\n/// >>> find_max(words: [\"aaaaaaa\"\
    , \"bb\", \"cc\"])\n/// \"aaaaaaa\"\nfunc find_max(words: [String]) -> String\
    \ {\n    guard !words.isEmpty else {\n        return \"\"\n    }\n    var minNumOfUniqueChars\
    \ = Int.max\n    var currentWord = \"\"\n    for word in words {\n        if let\
    \ numberOfChars = numberOfUniqueChars(word) {\n            if minNumOfUniqueChars\
    \ > numberOfChars {\n                minNumOfUniqueChars = numberOfChars\n   \
    \             currentWord = word\n            }\n        }\n    }\n    return\
    \ currentWord\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool\
    \ {\n    if left.count != right.count {\n        return false\n    }\n    for\
    \ (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(find_max(words: [\"\
    name\", \"of\", \"string\"]) == \"string\")\nassert(find_max(words: [\"name\"\
    , \"enam\", \"game\"]) == \"enam\")\nassert(find_max(words: [\"aaaaaaa\", \"bb\"\
    , \"cc\"]) == \"aaaaaaa\")\nassert(find_max(words: [\"abc\", \"cba\"]) == \"abc\"\
    )\nassert(find_max(words: [\"play\", \"this\", \"game\", \"of\", \"footbott\"\
    ]) == \"footbott\")\nassert(find_max(words: [\"we\", \"are\", \"gonna\", \"rock\"\
    ]) == \"gonna\")\nassert(find_max(words: [\"we\", \"are\", \"a\", \"mad\", \"\
    nation\"]) == \"nation\")\nassert(find_max(words: [\"this\", \"is\", \"a\", \"\
    prrk\"]) == \"this\")\nassert(find_max(words: [\"b\"]) == \"b\")\nassert(find_max(words:\
    \ [\"play\", \"play\", \"play\"]) == \"play\")"
  status: SyntaxError
  stderr: "/tmp/tmptdpvp77_.swift:19:32: error: cannot find 'numberOfUniqueChars'\
    \ in scope\n        if let numberOfChars = numberOfUniqueChars(word) {\n     \
    \                          ^~~~~~~~~~~~~~~~~~~\n"
  stdout: ''
  timestamp: 1660013456
- exit_code: -4
  program: "\n/// Write a function that accepts an array of strings.\n/// The array\
    \ contains different words. Return the word with maximum number\n/// of unique\
    \ characters. If multiple strings have maximum number of unique\n/// characters,\
    \ return the one which comes first in lexicographical order.\n/// >>> find_max(words:\
    \ [\"name\", \"of\", \"string\"])\n/// \"string\"\n/// >>> find_max(words: [\"\
    name\", \"enam\", \"game\"])\n/// \"enam\"\n/// >>> find_max(words: [\"aaaaaaa\"\
    , \"bb\", \"cc\"])\n/// \"aaaaaaa\"\nfunc find_max(words: [String]) -> String\
    \ {\n  var counts = [String: Int]()\n  for w in words {\n    counts[w] = Set(w).count\n\
    \  }\n  let maxValue = counts.values.max()\n  var result = \"\"\n  for (k, v)\
    \ in counts {\n    if v == maxValue {\n      result = k\n      break\n    }\n\
    \  }\n  return result\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(find_max(words:\
    \ [\"name\", \"of\", \"string\"]) == \"string\")\nassert(find_max(words: [\"name\"\
    , \"enam\", \"game\"]) == \"enam\")\nassert(find_max(words: [\"aaaaaaa\", \"bb\"\
    , \"cc\"]) == \"aaaaaaa\")\nassert(find_max(words: [\"abc\", \"cba\"]) == \"abc\"\
    )\nassert(find_max(words: [\"play\", \"this\", \"game\", \"of\", \"footbott\"\
    ]) == \"footbott\")\nassert(find_max(words: [\"we\", \"are\", \"gonna\", \"rock\"\
    ]) == \"gonna\")\nassert(find_max(words: [\"we\", \"are\", \"a\", \"mad\", \"\
    nation\"]) == \"nation\")\nassert(find_max(words: [\"this\", \"is\", \"a\", \"\
    prrk\"]) == \"this\")\nassert(find_max(words: [\"b\"]) == \"b\")\nassert(find_max(words:\
    \ [\"play\", \"play\", \"play\"]) == \"play\")"
  status: Exception
  stderr: 'tmp3desvo1m/tmp3desvo1m.swift:43: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b909c311c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b909c008b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b909c008988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b909c0077b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmp3desvo1m                        0x0000559b9bcc3ec9 <unavailable> + 7881

    5    libc.so.6                          0x00002b909c4fd460 __libc_start_main +
    245

    6    tmp3desvo1m                        0x0000559b9bcc3739 <unavailable> + 5945

    '
  stdout: ''
  timestamp: 1660013456
- exit_code: 1
  program: "\n/// Write a function that accepts an array of strings.\n/// The array\
    \ contains different words. Return the word with maximum number\n/// of unique\
    \ characters. If multiple strings have maximum number of unique\n/// characters,\
    \ return the one which comes first in lexicographical order.\n/// >>> find_max(words:\
    \ [\"name\", \"of\", \"string\"])\n/// \"string\"\n/// >>> find_max(words: [\"\
    name\", \"enam\", \"game\"])\n/// \"enam\"\n/// >>> find_max(words: [\"aaaaaaa\"\
    , \"bb\", \"cc\"])\n/// \"aaaaaaa\"\nfunc find_max(words: [String]) -> String\
    \ {\n    var max_word = \"\"\n    var max_count = 0\n    for i in 0..<words.count\
    \ {\n        let count = get_unique_count(word: words[i])\n        if count >\
    \ max_count {\n            max_count = count\n            max_word = words[i]\n\
    \        }\n    }\n    return max_word\n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(find_max(words: [\"name\", \"of\", \"string\"]) == \"string\")\nassert(find_max(words:\
    \ [\"name\", \"enam\", \"game\"]) == \"enam\")\nassert(find_max(words: [\"aaaaaaa\"\
    , \"bb\", \"cc\"]) == \"aaaaaaa\")\nassert(find_max(words: [\"abc\", \"cba\"])\
    \ == \"abc\")\nassert(find_max(words: [\"play\", \"this\", \"game\", \"of\", \"\
    footbott\"]) == \"footbott\")\nassert(find_max(words: [\"we\", \"are\", \"gonna\"\
    , \"rock\"]) == \"gonna\")\nassert(find_max(words: [\"we\", \"are\", \"a\", \"\
    mad\", \"nation\"]) == \"nation\")\nassert(find_max(words: [\"this\", \"is\",\
    \ \"a\", \"prrk\"]) == \"this\")\nassert(find_max(words: [\"b\"]) == \"b\")\n\
    assert(find_max(words: [\"play\", \"play\", \"play\"]) == \"play\")"
  status: SyntaxError
  stderr: "/tmp/tmpdnyvk658.swift:16:21: error: cannot find 'get_unique_count' in\
    \ scope\n        let count = get_unique_count(word: words[i])\n              \
    \      ^~~~~~~~~~~~~~~~\n"
  stdout: ''
  timestamp: 1660013456
- exit_code: 1
  program: "\n/// Write a function that accepts an array of strings.\n/// The array\
    \ contains different words. Return the word with maximum number\n/// of unique\
    \ characters. If multiple strings have maximum number of unique\n/// characters,\
    \ return the one which comes first in lexicographical order.\n/// >>> find_max(words:\
    \ [\"name\", \"of\", \"string\"])\n/// \"string\"\n/// >>> find_max(words: [\"\
    name\", \"enam\", \"game\"])\n/// \"enam\"\n/// >>> find_max(words: [\"aaaaaaa\"\
    , \"bb\", \"cc\"])\n/// \"aaaaaaa\"\nfunc find_max(words: [String]) -> String\
    \ {\n    var maxSoFar = words[0]\n    for word in words {\n        if uniqueCount(string:\
    \ word) > uniqueCount(string: maxSoFar) {\n            maxSoFar = word\n     \
    \   }\n    }\n    return maxSoFar\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int,\
    \ Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n\
    \    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n          \
    \  return false\n        }\n    }\n    return true\n}\n            \nassert(find_max(words:\
    \ [\"name\", \"of\", \"string\"]) == \"string\")\nassert(find_max(words: [\"name\"\
    , \"enam\", \"game\"]) == \"enam\")\nassert(find_max(words: [\"aaaaaaa\", \"bb\"\
    , \"cc\"]) == \"aaaaaaa\")\nassert(find_max(words: [\"abc\", \"cba\"]) == \"abc\"\
    )\nassert(find_max(words: [\"play\", \"this\", \"game\", \"of\", \"footbott\"\
    ]) == \"footbott\")\nassert(find_max(words: [\"we\", \"are\", \"gonna\", \"rock\"\
    ]) == \"gonna\")\nassert(find_max(words: [\"we\", \"are\", \"a\", \"mad\", \"\
    nation\"]) == \"nation\")\nassert(find_max(words: [\"this\", \"is\", \"a\", \"\
    prrk\"]) == \"this\")\nassert(find_max(words: [\"b\"]) == \"b\")\nassert(find_max(words:\
    \ [\"play\", \"play\", \"play\"]) == \"play\")"
  status: SyntaxError
  stderr: "/tmp/tmpxk2d49yw.swift:15:12: error: cannot find 'uniqueCount' in scope\n\
    \        if uniqueCount(string: word) > uniqueCount(string: maxSoFar) {\n    \
    \       ^~~~~~~~~~~\n/tmp/tmpxk2d49yw.swift:15:40: error: cannot find 'uniqueCount'\
    \ in scope\n        if uniqueCount(string: word) > uniqueCount(string: maxSoFar)\
    \ {\n                                       ^~~~~~~~~~~\n"
  stdout: ''
  timestamp: 1660013456
- exit_code: -4
  program: "\n/// Write a function that accepts an array of strings.\n/// The array\
    \ contains different words. Return the word with maximum number\n/// of unique\
    \ characters. If multiple strings have maximum number of unique\n/// characters,\
    \ return the one which comes first in lexicographical order.\n/// >>> find_max(words:\
    \ [\"name\", \"of\", \"string\"])\n/// \"string\"\n/// >>> find_max(words: [\"\
    name\", \"enam\", \"game\"])\n/// \"enam\"\n/// >>> find_max(words: [\"aaaaaaa\"\
    , \"bb\", \"cc\"])\n/// \"aaaaaaa\"\nfunc find_max(words: [String]) -> String\
    \ {\n    var max = words[0]\n    var maxUnique = Set(max).count\n    for w in\
    \ words {\n        let wUnique = Set(w).count\n        if wUnique > maxUnique\
    \ {\n            max = w\n            maxUnique = wUnique\n        }\n    }\n\
    \    return max\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool\
    \ {\n    if left.count != right.count {\n        return false\n    }\n    for\
    \ (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(find_max(words: [\"\
    name\", \"of\", \"string\"]) == \"string\")\nassert(find_max(words: [\"name\"\
    , \"enam\", \"game\"]) == \"enam\")\nassert(find_max(words: [\"aaaaaaa\", \"bb\"\
    , \"cc\"]) == \"aaaaaaa\")\nassert(find_max(words: [\"abc\", \"cba\"]) == \"abc\"\
    )\nassert(find_max(words: [\"play\", \"this\", \"game\", \"of\", \"footbott\"\
    ]) == \"footbott\")\nassert(find_max(words: [\"we\", \"are\", \"gonna\", \"rock\"\
    ]) == \"gonna\")\nassert(find_max(words: [\"we\", \"are\", \"a\", \"mad\", \"\
    nation\"]) == \"nation\")\nassert(find_max(words: [\"this\", \"is\", \"a\", \"\
    prrk\"]) == \"this\")\nassert(find_max(words: [\"b\"]) == \"b\")\nassert(find_max(words:\
    \ [\"play\", \"play\", \"play\"]) == \"play\")"
  status: Exception
  stderr: 'tmppwffasev/tmppwffasev.swift:39: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002aff2b9a3c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002aff2b69ab6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002aff2b69a988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002aff2b6997b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmppwffasev                        0x0000556be047c993 <unavailable> + 6547

    5    libc.so.6                          0x00002aff2bb8f460 __libc_start_main +
    245

    6    tmppwffasev                        0x0000556be047c3b9 <unavailable> + 5049

    '
  stdout: ''
  timestamp: 1660013456
- exit_code: -4
  program: "\n/// Write a function that accepts an array of strings.\n/// The array\
    \ contains different words. Return the word with maximum number\n/// of unique\
    \ characters. If multiple strings have maximum number of unique\n/// characters,\
    \ return the one which comes first in lexicographical order.\n/// >>> find_max(words:\
    \ [\"name\", \"of\", \"string\"])\n/// \"string\"\n/// >>> find_max(words: [\"\
    name\", \"enam\", \"game\"])\n/// \"enam\"\n/// >>> find_max(words: [\"aaaaaaa\"\
    , \"bb\", \"cc\"])\n/// \"aaaaaaa\"\nfunc find_max(words: [String]) -> String\
    \ {\n    /// Returns number of unique characters in a string\n    func distinct_count(of\
    \ word: String) -> Int {\n        let characters = Array(word)\n        var unique_characters\
    \ = Set<Character>()\n        for character in characters {\n            unique_characters.insert(character)\n\
    \        }\n        return unique_characters.count\n    }\n    \n    var max_word\
    \ = words[0]\n    var max_count = distinct_count(of: max_word)\n    for word in\
    \ words {\n        let count = distinct_count(of: word)\n        if count > max_count\
    \ {\n            max_count = count\n            max_word = word\n        }\n \
    \   }\n    return max_word\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(find_max(words:\
    \ [\"name\", \"of\", \"string\"]) == \"string\")\nassert(find_max(words: [\"name\"\
    , \"enam\", \"game\"]) == \"enam\")\nassert(find_max(words: [\"aaaaaaa\", \"bb\"\
    , \"cc\"]) == \"aaaaaaa\")\nassert(find_max(words: [\"abc\", \"cba\"]) == \"abc\"\
    )\nassert(find_max(words: [\"play\", \"this\", \"game\", \"of\", \"footbott\"\
    ]) == \"footbott\")\nassert(find_max(words: [\"we\", \"are\", \"gonna\", \"rock\"\
    ]) == \"gonna\")\nassert(find_max(words: [\"we\", \"are\", \"a\", \"mad\", \"\
    nation\"]) == \"nation\")\nassert(find_max(words: [\"this\", \"is\", \"a\", \"\
    prrk\"]) == \"this\")\nassert(find_max(words: [\"b\"]) == \"b\")\nassert(find_max(words:\
    \ [\"play\", \"play\", \"play\"]) == \"play\")"
  status: Exception
  stderr: 'tmpe_qyfp7w/tmpe_qyfp7w.swift:49: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b5bdaa9ec80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b5bda795b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b5bda795988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b5bda7947b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpe_qyfp7w                        0x000055b368072a53 <unavailable> + 6739

    5    libc.so.6                          0x00002b5bdac8a460 __libc_start_main +
    245

    6    tmpe_qyfp7w                        0x000055b368072479 <unavailable> + 5241

    '
  stdout: ''
  timestamp: 1660013456
- exit_code: 1
  program: "\n/// Write a function that accepts an array of strings.\n/// The array\
    \ contains different words. Return the word with maximum number\n/// of unique\
    \ characters. If multiple strings have maximum number of unique\n/// characters,\
    \ return the one which comes first in lexicographical order.\n/// >>> find_max(words:\
    \ [\"name\", \"of\", \"string\"])\n/// \"string\"\n/// >>> find_max(words: [\"\
    name\", \"enam\", \"game\"])\n/// \"enam\"\n/// >>> find_max(words: [\"aaaaaaa\"\
    , \"bb\", \"cc\"])\n/// \"aaaaaaa\"\nfunc find_max(words: [String]) -> String\
    \ {\n  var uniqueCharCount = [Int]()\n  for i in 0..<words.count {\n    uniqueCharCount.append(uniqueChar(str:\
    \ words[i]))\n  }\n  let maxCount = uniqueCharCount.max()\n  let index = uniqueCharCount.firstIndex(of:\
    \ maxCount!)\n  return words[index!]\n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(find_max(words: [\"name\", \"of\", \"string\"]) == \"string\")\nassert(find_max(words:\
    \ [\"name\", \"enam\", \"game\"]) == \"enam\")\nassert(find_max(words: [\"aaaaaaa\"\
    , \"bb\", \"cc\"]) == \"aaaaaaa\")\nassert(find_max(words: [\"abc\", \"cba\"])\
    \ == \"abc\")\nassert(find_max(words: [\"play\", \"this\", \"game\", \"of\", \"\
    footbott\"]) == \"footbott\")\nassert(find_max(words: [\"we\", \"are\", \"gonna\"\
    , \"rock\"]) == \"gonna\")\nassert(find_max(words: [\"we\", \"are\", \"a\", \"\
    mad\", \"nation\"]) == \"nation\")\nassert(find_max(words: [\"this\", \"is\",\
    \ \"a\", \"prrk\"]) == \"this\")\nassert(find_max(words: [\"b\"]) == \"b\")\n\
    assert(find_max(words: [\"play\", \"play\", \"play\"]) == \"play\")"
  status: SyntaxError
  stderr: "/tmp/tmpr4205ooz.swift:15:28: error: cannot find 'uniqueChar' in scope\n\
    \    uniqueCharCount.append(uniqueChar(str: words[i]))\n                     \
    \      ^~~~~~~~~~\n"
  stdout: ''
  timestamp: 1660013456
- exit_code: -4
  program: "\n/// Write a function that accepts an array of strings.\n/// The array\
    \ contains different words. Return the word with maximum number\n/// of unique\
    \ characters. If multiple strings have maximum number of unique\n/// characters,\
    \ return the one which comes first in lexicographical order.\n/// >>> find_max(words:\
    \ [\"name\", \"of\", \"string\"])\n/// \"string\"\n/// >>> find_max(words: [\"\
    name\", \"enam\", \"game\"])\n/// \"enam\"\n/// >>> find_max(words: [\"aaaaaaa\"\
    , \"bb\", \"cc\"])\n/// \"aaaaaaa\"\nfunc find_max(words: [String]) -> String\
    \ {\n    var max_count = 0\n    var max_string = \"\"\n    for item in words {\n\
    \        var set = Set<Character>()\n        for char in item {\n            set.insert(char)\n\
    \        }\n        if set.count > max_count {\n            max_count = set.count\n\
    \            max_string = item\n        }\n    }\n    return max_string\n}\n\n\
    \nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(find_max(words: [\"name\", \"of\", \"string\"\
    ]) == \"string\")\nassert(find_max(words: [\"name\", \"enam\", \"game\"]) == \"\
    enam\")\nassert(find_max(words: [\"aaaaaaa\", \"bb\", \"cc\"]) == \"aaaaaaa\"\
    )\nassert(find_max(words: [\"abc\", \"cba\"]) == \"abc\")\nassert(find_max(words:\
    \ [\"play\", \"this\", \"game\", \"of\", \"footbott\"]) == \"footbott\")\nassert(find_max(words:\
    \ [\"we\", \"are\", \"gonna\", \"rock\"]) == \"gonna\")\nassert(find_max(words:\
    \ [\"we\", \"are\", \"a\", \"mad\", \"nation\"]) == \"nation\")\nassert(find_max(words:\
    \ [\"this\", \"is\", \"a\", \"prrk\"]) == \"this\")\nassert(find_max(words: [\"\
    b\"]) == \"b\")\nassert(find_max(words: [\"play\", \"play\", \"play\"]) == \"\
    play\")"
  status: Exception
  stderr: 'tmpcf0nuznp/tmpcf0nuznp.swift:42: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b95633eec80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b95630e5b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b95630e5988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b95630e47b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpcf0nuznp                        0x00005648aa25ba03 <unavailable> + 6659

    5    libc.so.6                          0x00002b95635da460 __libc_start_main +
    245

    6    tmpcf0nuznp                        0x00005648aa25b429 <unavailable> + 5161

    '
  stdout: ''
  timestamp: 1660013456
- exit_code: 1
  program: "\n/// Write a function that accepts an array of strings.\n/// The array\
    \ contains different words. Return the word with maximum number\n/// of unique\
    \ characters. If multiple strings have maximum number of unique\n/// characters,\
    \ return the one which comes first in lexicographical order.\n/// >>> find_max(words:\
    \ [\"name\", \"of\", \"string\"])\n/// \"string\"\n/// >>> find_max(words: [\"\
    name\", \"enam\", \"game\"])\n/// \"enam\"\n/// >>> find_max(words: [\"aaaaaaa\"\
    , \"bb\", \"cc\"])\n/// \"aaaaaaa\"\nfunc find_max(words: [String]) -> String\
    \ {\n    guard !words.isEmpty else { return \"\" }\n    var max_unique = 0\n \
    \   var result = \"\"\n    words.forEach { word in\n        let len = Set(word).count\n\
    \        if len > max_unique {\n            max_unique = len\n            result\
    \ = word\n        } else if len == max_unique {\n            result = String(Array(Set(result))).compare(word)\
    \ == .orderedDescending ? word : result\n        }\n    }\n    return result\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(find_max(words: [\"name\", \"of\", \"string\"\
    ]) == \"string\")\nassert(find_max(words: [\"name\", \"enam\", \"game\"]) == \"\
    enam\")\nassert(find_max(words: [\"aaaaaaa\", \"bb\", \"cc\"]) == \"aaaaaaa\"\
    )\nassert(find_max(words: [\"abc\", \"cba\"]) == \"abc\")\nassert(find_max(words:\
    \ [\"play\", \"this\", \"game\", \"of\", \"footbott\"]) == \"footbott\")\nassert(find_max(words:\
    \ [\"we\", \"are\", \"gonna\", \"rock\"]) == \"gonna\")\nassert(find_max(words:\
    \ [\"we\", \"are\", \"a\", \"mad\", \"nation\"]) == \"nation\")\nassert(find_max(words:\
    \ [\"this\", \"is\", \"a\", \"prrk\"]) == \"this\")\nassert(find_max(words: [\"\
    b\"]) == \"b\")\nassert(find_max(words: [\"play\", \"play\", \"play\"]) == \"\
    play\")"
  status: SyntaxError
  stderr: "/tmp/tmpbop_jq07.swift:22:49: error: value of type 'String' has no member\
    \ 'compare'\n            result = String(Array(Set(result))).compare(word) ==\
    \ .orderedDescending ? word : result\n                     ~~~~~~~~~~~~~~~~~~~~~~~~~~\
    \ ^~~~~~~\n"
  stdout: ''
  timestamp: 1660013457
- exit_code: 1
  program: "\n/// Write a function that accepts an array of strings.\n/// The array\
    \ contains different words. Return the word with maximum number\n/// of unique\
    \ characters. If multiple strings have maximum number of unique\n/// characters,\
    \ return the one which comes first in lexicographical order.\n/// >>> find_max(words:\
    \ [\"name\", \"of\", \"string\"])\n/// \"string\"\n/// >>> find_max(words: [\"\
    name\", \"enam\", \"game\"])\n/// \"enam\"\n/// >>> find_max(words: [\"aaaaaaa\"\
    , \"bb\", \"cc\"])\n/// \"aaaaaaa\"\nfunc find_max(words: [String]) -> String\
    \ {\n    let uniqueCharacterCounts = words.map { $0.countUniqueCharacters() }\n\
    \    let maxUniqueCharacterCount = uniqueCharacterCounts.max()!\n    guard let\
    \ maxWordIndex = uniqueCharacterCounts.firstIndex(of: maxUniqueCharacterCount)\
    \ else {\n        fatalError(\"We've just calculated this value\")\n    }\n  \
    \  return words[maxWordIndex]\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int,\
    \ Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n\
    \    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n          \
    \  return false\n        }\n    }\n    return true\n}\n            \nassert(find_max(words:\
    \ [\"name\", \"of\", \"string\"]) == \"string\")\nassert(find_max(words: [\"name\"\
    , \"enam\", \"game\"]) == \"enam\")\nassert(find_max(words: [\"aaaaaaa\", \"bb\"\
    , \"cc\"]) == \"aaaaaaa\")\nassert(find_max(words: [\"abc\", \"cba\"]) == \"abc\"\
    )\nassert(find_max(words: [\"play\", \"this\", \"game\", \"of\", \"footbott\"\
    ]) == \"footbott\")\nassert(find_max(words: [\"we\", \"are\", \"gonna\", \"rock\"\
    ]) == \"gonna\")\nassert(find_max(words: [\"we\", \"are\", \"a\", \"mad\", \"\
    nation\"]) == \"nation\")\nassert(find_max(words: [\"this\", \"is\", \"a\", \"\
    prrk\"]) == \"this\")\nassert(find_max(words: [\"b\"]) == \"b\")\nassert(find_max(words:\
    \ [\"play\", \"play\", \"play\"]) == \"play\")"
  status: SyntaxError
  stderr: "/tmp/tmpqsmomcsr.swift:13:48: error: value of type 'String' has no member\
    \ 'countUniqueCharacters'\n    let uniqueCharacterCounts = words.map { $0.countUniqueCharacters()\
    \ }\n                                            ~~ ^~~~~~~~~~~~~~~~~~~~~\n"
  stdout: ''
  timestamp: 1660013456
- exit_code: -4
  program: "\n/// Write a function that accepts an array of strings.\n/// The array\
    \ contains different words. Return the word with maximum number\n/// of unique\
    \ characters. If multiple strings have maximum number of unique\n/// characters,\
    \ return the one which comes first in lexicographical order.\n/// >>> find_max(words:\
    \ [\"name\", \"of\", \"string\"])\n/// \"string\"\n/// >>> find_max(words: [\"\
    name\", \"enam\", \"game\"])\n/// \"enam\"\n/// >>> find_max(words: [\"aaaaaaa\"\
    , \"bb\", \"cc\"])\n/// \"aaaaaaa\"\nfunc find_max(words: [String]) -> String\
    \ {\n    var maxWord = \"\"\n    var maxCount = 0\n    for word in words {\n \
    \       let stringSet = Set(word)\n        if maxCount < stringSet.count {\n \
    \           maxCount = stringSet.count\n            maxWord = word\n        }\n\
    \    }\n    return maxWord\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(find_max(words:\
    \ [\"name\", \"of\", \"string\"]) == \"string\")\nassert(find_max(words: [\"name\"\
    , \"enam\", \"game\"]) == \"enam\")\nassert(find_max(words: [\"aaaaaaa\", \"bb\"\
    , \"cc\"]) == \"aaaaaaa\")\nassert(find_max(words: [\"abc\", \"cba\"]) == \"abc\"\
    )\nassert(find_max(words: [\"play\", \"this\", \"game\", \"of\", \"footbott\"\
    ]) == \"footbott\")\nassert(find_max(words: [\"we\", \"are\", \"gonna\", \"rock\"\
    ]) == \"gonna\")\nassert(find_max(words: [\"we\", \"are\", \"a\", \"mad\", \"\
    nation\"]) == \"nation\")\nassert(find_max(words: [\"this\", \"is\", \"a\", \"\
    prrk\"]) == \"this\")\nassert(find_max(words: [\"b\"]) == \"b\")\nassert(find_max(words:\
    \ [\"play\", \"play\", \"play\"]) == \"play\")"
  status: Exception
  stderr: 'tmp5yuuv09y/tmp5yuuv09y.swift:39: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b92773d9c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b92770d0b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b92770d0988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b92770cf7b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmp5yuuv09y                        0x0000563621682933 <unavailable> + 6451

    5    libc.so.6                          0x00002b92775c5460 __libc_start_main +
    245

    6    tmp5yuuv09y                        0x0000563621682359 <unavailable> + 4953

    '
  stdout: ''
  timestamp: 1660013456
- exit_code: 1
  program: "\n/// Write a function that accepts an array of strings.\n/// The array\
    \ contains different words. Return the word with maximum number\n/// of unique\
    \ characters. If multiple strings have maximum number of unique\n/// characters,\
    \ return the one which comes first in lexicographical order.\n/// >>> find_max(words:\
    \ [\"name\", \"of\", \"string\"])\n/// \"string\"\n/// >>> find_max(words: [\"\
    name\", \"enam\", \"game\"])\n/// \"enam\"\n/// >>> find_max(words: [\"aaaaaaa\"\
    , \"bb\", \"cc\"])\n/// \"aaaaaaa\"\nfunc find_max(words: [String]) -> String\
    \ {\n    var max = \"\"\n    for word in words {\n        if max == \"\" || is_lexicographically_greater(word,\
    \ max) ||\n            is_lexicographically_equal(word, max) &&\n            (unique_chars(word)\
    \ ?? 0) > (unique_chars(max) ?? 0) {\n            max = word\n        }\n    }\n\
    \    return max\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool\
    \ {\n    if left.count != right.count {\n        return false\n    }\n    for\
    \ (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(find_max(words: [\"\
    name\", \"of\", \"string\"]) == \"string\")\nassert(find_max(words: [\"name\"\
    , \"enam\", \"game\"]) == \"enam\")\nassert(find_max(words: [\"aaaaaaa\", \"bb\"\
    , \"cc\"]) == \"aaaaaaa\")\nassert(find_max(words: [\"abc\", \"cba\"]) == \"abc\"\
    )\nassert(find_max(words: [\"play\", \"this\", \"game\", \"of\", \"footbott\"\
    ]) == \"footbott\")\nassert(find_max(words: [\"we\", \"are\", \"gonna\", \"rock\"\
    ]) == \"gonna\")\nassert(find_max(words: [\"we\", \"are\", \"a\", \"mad\", \"\
    nation\"]) == \"nation\")\nassert(find_max(words: [\"this\", \"is\", \"a\", \"\
    prrk\"]) == \"this\")\nassert(find_max(words: [\"b\"]) == \"b\")\nassert(find_max(words:\
    \ [\"play\", \"play\", \"play\"]) == \"play\")"
  status: SyntaxError
  stderr: "/tmp/tmp5f_1qi8o.swift:15:25: error: cannot find 'is_lexicographically_greater'\
    \ in scope\n        if max == \"\" || is_lexicographically_greater(word, max)\
    \ ||\n                        ^~~~~~~~~~~~~~~~~~~~~~~~~~~~\n/tmp/tmp5f_1qi8o.swift:16:13:\
    \ error: cannot find 'is_lexicographically_equal' in scope\n            is_lexicographically_equal(word,\
    \ max) &&\n            ^~~~~~~~~~~~~~~~~~~~~~~~~~\n/tmp/tmp5f_1qi8o.swift:17:14:\
    \ error: cannot find 'unique_chars' in scope\n            (unique_chars(word)\
    \ ?? 0) > (unique_chars(max) ?? 0) {\n             ^~~~~~~~~~~~\n/tmp/tmp5f_1qi8o.swift:17:42:\
    \ error: cannot find 'unique_chars' in scope\n            (unique_chars(word)\
    \ ?? 0) > (unique_chars(max) ?? 0) {\n                                       \
    \  ^~~~~~~~~~~~\n"
  stdout: ''
  timestamp: 1660013456
- exit_code: -4
  program: "\n/// Write a function that accepts an array of strings.\n/// The array\
    \ contains different words. Return the word with maximum number\n/// of unique\
    \ characters. If multiple strings have maximum number of unique\n/// characters,\
    \ return the one which comes first in lexicographical order.\n/// >>> find_max(words:\
    \ [\"name\", \"of\", \"string\"])\n/// \"string\"\n/// >>> find_max(words: [\"\
    name\", \"enam\", \"game\"])\n/// \"enam\"\n/// >>> find_max(words: [\"aaaaaaa\"\
    , \"bb\", \"cc\"])\n/// \"aaaaaaa\"\nfunc find_max(words: [String]) -> String\
    \ {\n    return \"\"\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(find_max(words:\
    \ [\"name\", \"of\", \"string\"]) == \"string\")\nassert(find_max(words: [\"name\"\
    , \"enam\", \"game\"]) == \"enam\")\nassert(find_max(words: [\"aaaaaaa\", \"bb\"\
    , \"cc\"]) == \"aaaaaaa\")\nassert(find_max(words: [\"abc\", \"cba\"]) == \"abc\"\
    )\nassert(find_max(words: [\"play\", \"this\", \"game\", \"of\", \"footbott\"\
    ]) == \"footbott\")\nassert(find_max(words: [\"we\", \"are\", \"gonna\", \"rock\"\
    ]) == \"gonna\")\nassert(find_max(words: [\"we\", \"are\", \"a\", \"mad\", \"\
    nation\"]) == \"nation\")\nassert(find_max(words: [\"this\", \"is\", \"a\", \"\
    prrk\"]) == \"this\")\nassert(find_max(words: [\"b\"]) == \"b\")\nassert(find_max(words:\
    \ [\"play\", \"play\", \"play\"]) == \"play\")"
  status: Exception
  stderr: 'tmp9vfthvyx/tmp9vfthvyx.swift:29: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b5bb598bc80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b5bb5682b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b5bb5682988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b5bb56817b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmp9vfthvyx                        0x0000564c87ea64ce <unavailable> + 5326

    5    libc.so.6                          0x00002b5bb5b77460 __libc_start_main +
    245

    6    tmp9vfthvyx                        0x0000564c87ea6089 <unavailable> + 4233

    '
  stdout: ''
  timestamp: 1660013265
- exit_code: -4
  program: "\n/// Write a function that accepts an array of strings.\n/// The array\
    \ contains different words. Return the word with maximum number\n/// of unique\
    \ characters. If multiple strings have maximum number of unique\n/// characters,\
    \ return the one which comes first in lexicographical order.\n/// >>> find_max(words:\
    \ [\"name\", \"of\", \"string\"])\n/// \"string\"\n/// >>> find_max(words: [\"\
    name\", \"enam\", \"game\"])\n/// \"enam\"\n/// >>> find_max(words: [\"aaaaaaa\"\
    , \"bb\", \"cc\"])\n/// \"aaaaaaa\"\nfunc find_max(words: [String]) -> String\
    \ {\n    // TODO: Write implementation\n    return \"\"\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(find_max(words: [\"name\", \"of\", \"string\"]) == \"\
    string\")\nassert(find_max(words: [\"name\", \"enam\", \"game\"]) == \"enam\"\
    )\nassert(find_max(words: [\"aaaaaaa\", \"bb\", \"cc\"]) == \"aaaaaaa\")\nassert(find_max(words:\
    \ [\"abc\", \"cba\"]) == \"abc\")\nassert(find_max(words: [\"play\", \"this\"\
    , \"game\", \"of\", \"footbott\"]) == \"footbott\")\nassert(find_max(words: [\"\
    we\", \"are\", \"gonna\", \"rock\"]) == \"gonna\")\nassert(find_max(words: [\"\
    we\", \"are\", \"a\", \"mad\", \"nation\"]) == \"nation\")\nassert(find_max(words:\
    \ [\"this\", \"is\", \"a\", \"prrk\"]) == \"this\")\nassert(find_max(words: [\"\
    b\"]) == \"b\")\nassert(find_max(words: [\"play\", \"play\", \"play\"]) == \"\
    play\")"
  status: Exception
  stderr: 'tmpgp_dm8bq/tmpgp_dm8bq.swift:30: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002af015fe2c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002af015cd9b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002af015cd9988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002af015cd87b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpgp_dm8bq                        0x000055904e5984ce <unavailable> + 5326

    5    libc.so.6                          0x00002af0161ce460 __libc_start_main +
    245

    6    tmpgp_dm8bq                        0x000055904e598089 <unavailable> + 4233

    '
  stdout: ''
  timestamp: 1660013456
- exit_code: -4
  program: "\n/// Write a function that accepts an array of strings.\n/// The array\
    \ contains different words. Return the word with maximum number\n/// of unique\
    \ characters. If multiple strings have maximum number of unique\n/// characters,\
    \ return the one which comes first in lexicographical order.\n/// >>> find_max(words:\
    \ [\"name\", \"of\", \"string\"])\n/// \"string\"\n/// >>> find_max(words: [\"\
    name\", \"enam\", \"game\"])\n/// \"enam\"\n/// >>> find_max(words: [\"aaaaaaa\"\
    , \"bb\", \"cc\"])\n/// \"aaaaaaa\"\nfunc find_max(words: [String]) -> String\
    \ {\n    // TODO\n    return \"\"\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int,\
    \ Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n\
    \    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n          \
    \  return false\n        }\n    }\n    return true\n}\n            \nassert(find_max(words:\
    \ [\"name\", \"of\", \"string\"]) == \"string\")\nassert(find_max(words: [\"name\"\
    , \"enam\", \"game\"]) == \"enam\")\nassert(find_max(words: [\"aaaaaaa\", \"bb\"\
    , \"cc\"]) == \"aaaaaaa\")\nassert(find_max(words: [\"abc\", \"cba\"]) == \"abc\"\
    )\nassert(find_max(words: [\"play\", \"this\", \"game\", \"of\", \"footbott\"\
    ]) == \"footbott\")\nassert(find_max(words: [\"we\", \"are\", \"gonna\", \"rock\"\
    ]) == \"gonna\")\nassert(find_max(words: [\"we\", \"are\", \"a\", \"mad\", \"\
    nation\"]) == \"nation\")\nassert(find_max(words: [\"this\", \"is\", \"a\", \"\
    prrk\"]) == \"this\")\nassert(find_max(words: [\"b\"]) == \"b\")\nassert(find_max(words:\
    \ [\"play\", \"play\", \"play\"]) == \"play\")"
  status: Exception
  stderr: 'tmp7cz26xke/tmp7cz26xke.swift:30: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b1a6862fc80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b1a68326b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b1a68326988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b1a683257b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmp7cz26xke                        0x0000556d009f94ce <unavailable> + 5326

    5    libc.so.6                          0x00002b1a6881b460 __libc_start_main +
    245

    6    tmp7cz26xke                        0x0000556d009f9089 <unavailable> + 4233

    '
  stdout: ''
  timestamp: 1660013456
- exit_code: -4
  program: "\n/// Write a function that accepts an array of strings.\n/// The array\
    \ contains different words. Return the word with maximum number\n/// of unique\
    \ characters. If multiple strings have maximum number of unique\n/// characters,\
    \ return the one which comes first in lexicographical order.\n/// >>> find_max(words:\
    \ [\"name\", \"of\", \"string\"])\n/// \"string\"\n/// >>> find_max(words: [\"\
    name\", \"enam\", \"game\"])\n/// \"enam\"\n/// >>> find_max(words: [\"aaaaaaa\"\
    , \"bb\", \"cc\"])\n/// \"aaaaaaa\"\nfunc find_max(words: [String]) -> String\
    \ {\n    var maxWord = words[0]\n    var maxChars = 0\n    var count = 0\n   \
    \ for word in words {\n        count = Set(word).count\n        if count > maxChars\
    \ {\n            maxChars = count\n            maxWord = word\n        }\n   \
    \ }\n    return maxWord\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(find_max(words:\
    \ [\"name\", \"of\", \"string\"]) == \"string\")\nassert(find_max(words: [\"name\"\
    , \"enam\", \"game\"]) == \"enam\")\nassert(find_max(words: [\"aaaaaaa\", \"bb\"\
    , \"cc\"]) == \"aaaaaaa\")\nassert(find_max(words: [\"abc\", \"cba\"]) == \"abc\"\
    )\nassert(find_max(words: [\"play\", \"this\", \"game\", \"of\", \"footbott\"\
    ]) == \"footbott\")\nassert(find_max(words: [\"we\", \"are\", \"gonna\", \"rock\"\
    ]) == \"gonna\")\nassert(find_max(words: [\"we\", \"are\", \"a\", \"mad\", \"\
    nation\"]) == \"nation\")\nassert(find_max(words: [\"this\", \"is\", \"a\", \"\
    prrk\"]) == \"this\")\nassert(find_max(words: [\"b\"]) == \"b\")\nassert(find_max(words:\
    \ [\"play\", \"play\", \"play\"]) == \"play\")"
  status: Exception
  stderr: 'tmpam6nv2py/tmpam6nv2py.swift:40: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b669f29cc80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b669ef93b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b669ef93988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b669ef927b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpam6nv2py                        0x00005638f65af993 <unavailable> + 6547

    5    libc.so.6                          0x00002b669f488460 __libc_start_main +
    245

    6    tmpam6nv2py                        0x00005638f65af3b9 <unavailable> + 5049

    '
  stdout: ''
  timestamp: 1660013456
- exit_code: -4
  program: "\n/// Write a function that accepts an array of strings.\n/// The array\
    \ contains different words. Return the word with maximum number\n/// of unique\
    \ characters. If multiple strings have maximum number of unique\n/// characters,\
    \ return the one which comes first in lexicographical order.\n/// >>> find_max(words:\
    \ [\"name\", \"of\", \"string\"])\n/// \"string\"\n/// >>> find_max(words: [\"\
    name\", \"enam\", \"game\"])\n/// \"enam\"\n/// >>> find_max(words: [\"aaaaaaa\"\
    , \"bb\", \"cc\"])\n/// \"aaaaaaa\"\nfunc find_max(words: [String]) -> String\
    \ {\n    var max = Int.min\n    var index = 0\n    for i in 0..<words.count {\n\
    \        let string = words[i]\n        let unique_chars = Set(string)\n     \
    \   if unique_chars.count > max {\n            max = unique_chars.count\n    \
    \        index = i\n        }\n    }\n    return words[index]\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(find_max(words: [\"name\", \"of\", \"string\"]) == \"\
    string\")\nassert(find_max(words: [\"name\", \"enam\", \"game\"]) == \"enam\"\
    )\nassert(find_max(words: [\"aaaaaaa\", \"bb\", \"cc\"]) == \"aaaaaaa\")\nassert(find_max(words:\
    \ [\"abc\", \"cba\"]) == \"abc\")\nassert(find_max(words: [\"play\", \"this\"\
    , \"game\", \"of\", \"footbott\"]) == \"footbott\")\nassert(find_max(words: [\"\
    we\", \"are\", \"gonna\", \"rock\"]) == \"gonna\")\nassert(find_max(words: [\"\
    we\", \"are\", \"a\", \"mad\", \"nation\"]) == \"nation\")\nassert(find_max(words:\
    \ [\"this\", \"is\", \"a\", \"prrk\"]) == \"this\")\nassert(find_max(words: [\"\
    b\"]) == \"b\")\nassert(find_max(words: [\"play\", \"play\", \"play\"]) == \"\
    play\")"
  status: Exception
  stderr: 'tmp88guj286/tmp88guj286.swift:40: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002ae92cd58c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002ae92ca4fb6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002ae92ca4f988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002ae92ca4e7b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmp88guj286                        0x0000561309bdaa03 <unavailable> + 6659

    5    libc.so.6                          0x00002ae92cf44460 __libc_start_main +
    245

    6    tmp88guj286                        0x0000561309bda429 <unavailable> + 5161

    '
  stdout: ''
  timestamp: 1660013456
- exit_code: 1
  program: "\n/// Write a function that accepts an array of strings.\n/// The array\
    \ contains different words. Return the word with maximum number\n/// of unique\
    \ characters. If multiple strings have maximum number of unique\n/// characters,\
    \ return the one which comes first in lexicographical order.\n/// >>> find_max(words:\
    \ [\"name\", \"of\", \"string\"])\n/// \"string\"\n/// >>> find_max(words: [\"\
    name\", \"enam\", \"game\"])\n/// \"enam\"\n/// >>> find_max(words: [\"aaaaaaa\"\
    , \"bb\", \"cc\"])\n/// \"aaaaaaa\"\nfunc find_max(words: [String]) -> String\
    \ {\n    let chars = words.map { $0.characters }\n    let numberOfUniqueChars\
    \ = chars.map { Set($0) }\n    let max = numberOfUniqueChars.max { $0.count <\
    \ $1.count }!\n    let m = numberOfUniqueChars.indexOf(max)!\n    return words[m]\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(find_max(words: [\"name\", \"of\", \"string\"\
    ]) == \"string\")\nassert(find_max(words: [\"name\", \"enam\", \"game\"]) == \"\
    enam\")\nassert(find_max(words: [\"aaaaaaa\", \"bb\", \"cc\"]) == \"aaaaaaa\"\
    )\nassert(find_max(words: [\"abc\", \"cba\"]) == \"abc\")\nassert(find_max(words:\
    \ [\"play\", \"this\", \"game\", \"of\", \"footbott\"]) == \"footbott\")\nassert(find_max(words:\
    \ [\"we\", \"are\", \"gonna\", \"rock\"]) == \"gonna\")\nassert(find_max(words:\
    \ [\"we\", \"are\", \"a\", \"mad\", \"nation\"]) == \"nation\")\nassert(find_max(words:\
    \ [\"this\", \"is\", \"a\", \"prrk\"]) == \"this\")\nassert(find_max(words: [\"\
    b\"]) == \"b\")\nassert(find_max(words: [\"play\", \"play\", \"play\"]) == \"\
    play\")"
  status: SyntaxError
  stderr: "/tmp/tmp3o6e4tjt.swift:13:32: error: 'characters' is unavailable: Please\
    \ use String directly\n    let chars = words.map { $0.characters }\n         \
    \                      ^~~~~~~~~~\nSwift.String:5:16: note: 'characters' was obsoleted\
    \ in Swift 5.0\n    public var characters: String { get set }\n              \
    \ ^\n/tmp/tmp3o6e4tjt.swift:16:33: error: value of type '[Set<String.Element>]'\
    \ (aka 'Array<Set<Character>>') has no member 'indexOf'\n    let m = numberOfUniqueChars.indexOf(max)!\n\
    \            ~~~~~~~~~~~~~~~~~~~ ^~~~~~~\n"
  stdout: ''
  timestamp: 1660013456
- exit_code: 1
  program: "\n/// Write a function that accepts an array of strings.\n/// The array\
    \ contains different words. Return the word with maximum number\n/// of unique\
    \ characters. If multiple strings have maximum number of unique\n/// characters,\
    \ return the one which comes first in lexicographical order.\n/// >>> find_max(words:\
    \ [\"name\", \"of\", \"string\"])\n/// \"string\"\n/// >>> find_max(words: [\"\
    name\", \"enam\", \"game\"])\n/// \"enam\"\n/// >>> find_max(words: [\"aaaaaaa\"\
    , \"bb\", \"cc\"])\n/// \"aaaaaaa\"\nfunc find_max(words: [String]) -> String\
    \ {\n    var l: Int = 0\n    var r: Int = 0\n    var max_length: Int = 0\n   \
    \ for (index, word) in words.enumerated() {\n        if word.characters.count\
    \ == 1 {\n            return word\n        }\n        if Set(word.characters).count\
    \ > max_length {\n            max_length = Set(word.characters).count\n      \
    \      l = index\n        }\n    }\n    for (index, word) in words.enumerated()\
    \ {\n        if word.characters.count == max_length {\n            if word < words[l]\
    \ {\n                l = index\n            }\n        }\n    }\n    return words[l]\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(find_max(words: [\"name\", \"of\", \"string\"\
    ]) == \"string\")\nassert(find_max(words: [\"name\", \"enam\", \"game\"]) == \"\
    enam\")\nassert(find_max(words: [\"aaaaaaa\", \"bb\", \"cc\"]) == \"aaaaaaa\"\
    )\nassert(find_max(words: [\"abc\", \"cba\"]) == \"abc\")\nassert(find_max(words:\
    \ [\"play\", \"this\", \"game\", \"of\", \"footbott\"]) == \"footbott\")\nassert(find_max(words:\
    \ [\"we\", \"are\", \"gonna\", \"rock\"]) == \"gonna\")\nassert(find_max(words:\
    \ [\"we\", \"are\", \"a\", \"mad\", \"nation\"]) == \"nation\")\nassert(find_max(words:\
    \ [\"this\", \"is\", \"a\", \"prrk\"]) == \"this\")\nassert(find_max(words: [\"\
    b\"]) == \"b\")\nassert(find_max(words: [\"play\", \"play\", \"play\"]) == \"\
    play\")"
  status: SyntaxError
  stderr: "/tmp/tmpmzif6sou.swift:17:17: error: 'characters' is unavailable: Please\
    \ use String directly\n        if word.characters.count == 1 {\n             \
    \   ^~~~~~~~~~\nSwift.String:5:16: note: 'characters' was obsoleted in Swift 5.0\n\
    \    public var characters: String { get set }\n               ^\n/tmp/tmpmzif6sou.swift:20:21:\
    \ error: 'characters' is unavailable: Please use String directly\n        if Set(word.characters).count\
    \ > max_length {\n                    ^~~~~~~~~~\nSwift.String:5:16: note: 'characters'\
    \ was obsoleted in Swift 5.0\n    public var characters: String { get set }\n\
    \               ^\n/tmp/tmpmzif6sou.swift:21:35: error: 'characters' is unavailable:\
    \ Please use String directly\n            max_length = Set(word.characters).count\n\
    \                                  ^~~~~~~~~~\nSwift.String:5:16: note: 'characters'\
    \ was obsoleted in Swift 5.0\n    public var characters: String { get set }\n\
    \               ^\n/tmp/tmpmzif6sou.swift:26:17: error: 'characters' is unavailable:\
    \ Please use String directly\n        if word.characters.count == max_length {\n\
    \                ^~~~~~~~~~\nSwift.String:5:16: note: 'characters' was obsoleted\
    \ in Swift 5.0\n    public var characters: String { get set }\n              \
    \ ^\n/tmp/tmpmzif6sou.swift:14:9: warning: variable 'r' was never used; consider\
    \ replacing with '_' or removing it\n    var r: Int = 0\n        ^\n        _\n"
  stdout: ''
  timestamp: 1660013456
- exit_code: -4
  program: "\n/// Write a function that accepts an array of strings.\n/// The array\
    \ contains different words. Return the word with maximum number\n/// of unique\
    \ characters. If multiple strings have maximum number of unique\n/// characters,\
    \ return the one which comes first in lexicographical order.\n/// >>> find_max(words:\
    \ [\"name\", \"of\", \"string\"])\n/// \"string\"\n/// >>> find_max(words: [\"\
    name\", \"enam\", \"game\"])\n/// \"enam\"\n/// >>> find_max(words: [\"aaaaaaa\"\
    , \"bb\", \"cc\"])\n/// \"aaaaaaa\"\nfunc find_max(words: [String]) -> String\
    \ {\n    // TODO\n    return \"\"\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int,\
    \ Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n\
    \    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n          \
    \  return false\n        }\n    }\n    return true\n}\n            \nassert(find_max(words:\
    \ [\"name\", \"of\", \"string\"]) == \"string\")\nassert(find_max(words: [\"name\"\
    , \"enam\", \"game\"]) == \"enam\")\nassert(find_max(words: [\"aaaaaaa\", \"bb\"\
    , \"cc\"]) == \"aaaaaaa\")\nassert(find_max(words: [\"abc\", \"cba\"]) == \"abc\"\
    )\nassert(find_max(words: [\"play\", \"this\", \"game\", \"of\", \"footbott\"\
    ]) == \"footbott\")\nassert(find_max(words: [\"we\", \"are\", \"gonna\", \"rock\"\
    ]) == \"gonna\")\nassert(find_max(words: [\"we\", \"are\", \"a\", \"mad\", \"\
    nation\"]) == \"nation\")\nassert(find_max(words: [\"this\", \"is\", \"a\", \"\
    prrk\"]) == \"this\")\nassert(find_max(words: [\"b\"]) == \"b\")\nassert(find_max(words:\
    \ [\"play\", \"play\", \"play\"]) == \"play\")"
  status: Exception
  stderr: 'tmp7cz26xke/tmp7cz26xke.swift:30: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b1a6862fc80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b1a68326b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b1a68326988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b1a683257b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmp7cz26xke                        0x0000556d009f94ce <unavailable> + 5326

    5    libc.so.6                          0x00002b1a6881b460 __libc_start_main +
    245

    6    tmp7cz26xke                        0x0000556d009f9089 <unavailable> + 4233

    '
  stdout: ''
  timestamp: 1660013456
- exit_code: -4
  program: "\n/// Write a function that accepts an array of strings.\n/// The array\
    \ contains different words. Return the word with maximum number\n/// of unique\
    \ characters. If multiple strings have maximum number of unique\n/// characters,\
    \ return the one which comes first in lexicographical order.\n/// >>> find_max(words:\
    \ [\"name\", \"of\", \"string\"])\n/// \"string\"\n/// >>> find_max(words: [\"\
    name\", \"enam\", \"game\"])\n/// \"enam\"\n/// >>> find_max(words: [\"aaaaaaa\"\
    , \"bb\", \"cc\"])\n/// \"aaaaaaa\"\nfunc find_max(words: [String]) -> String\
    \ {\n    var maxUnique = 0\n    var maxWord = \"\"\n    for word in words {\n\
    \        let uniques = Set(word)\n        if uniques.count > maxUnique {\n   \
    \         maxUnique = uniques.count\n            maxWord = word\n        }\n \
    \   }\n    return maxWord\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(find_max(words:\
    \ [\"name\", \"of\", \"string\"]) == \"string\")\nassert(find_max(words: [\"name\"\
    , \"enam\", \"game\"]) == \"enam\")\nassert(find_max(words: [\"aaaaaaa\", \"bb\"\
    , \"cc\"]) == \"aaaaaaa\")\nassert(find_max(words: [\"abc\", \"cba\"]) == \"abc\"\
    )\nassert(find_max(words: [\"play\", \"this\", \"game\", \"of\", \"footbott\"\
    ]) == \"footbott\")\nassert(find_max(words: [\"we\", \"are\", \"gonna\", \"rock\"\
    ]) == \"gonna\")\nassert(find_max(words: [\"we\", \"are\", \"a\", \"mad\", \"\
    nation\"]) == \"nation\")\nassert(find_max(words: [\"this\", \"is\", \"a\", \"\
    prrk\"]) == \"this\")\nassert(find_max(words: [\"b\"]) == \"b\")\nassert(find_max(words:\
    \ [\"play\", \"play\", \"play\"]) == \"play\")"
  status: Exception
  stderr: 'tmpsngrsgjd/tmpsngrsgjd.swift:39: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b5b23f0dc80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b5b23c04b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b5b23c04988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b5b23c037b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpsngrsgjd                        0x000055d565692933 <unavailable> + 6451

    5    libc.so.6                          0x00002b5b240f9460 __libc_start_main +
    245

    6    tmpsngrsgjd                        0x000055d565692359 <unavailable> + 4953

    '
  stdout: ''
  timestamp: 1660013456
- exit_code: -4
  program: "\n/// Write a function that accepts an array of strings.\n/// The array\
    \ contains different words. Return the word with maximum number\n/// of unique\
    \ characters. If multiple strings have maximum number of unique\n/// characters,\
    \ return the one which comes first in lexicographical order.\n/// >>> find_max(words:\
    \ [\"name\", \"of\", \"string\"])\n/// \"string\"\n/// >>> find_max(words: [\"\
    name\", \"enam\", \"game\"])\n/// \"enam\"\n/// >>> find_max(words: [\"aaaaaaa\"\
    , \"bb\", \"cc\"])\n/// \"aaaaaaa\"\nfunc find_max(words: [String]) -> String\
    \ {\n    // yannic: todo, maybe a nicer solution with sorted(by: {$0.count > $1.count})\n\
    \    var max_element = words[0]\n    var max_element_count = Set(words[0]).count\n\
    \    for word in words {\n        let count = Set(word).count\n        if count\
    \ > max_element_count {\n            max_element = word\n            max_element_count\
    \ = count\n        }\n    }\n    return max_element\n}\n\n\nfunc ==(left: [(Int,\
    \ Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n\
    \        return false\n    }\n    for (l, r) in zip(left, right) {\n        if\
    \ l != r {\n            return false\n        }\n    }\n    return true\n}\n \
    \           \nassert(find_max(words: [\"name\", \"of\", \"string\"]) == \"string\"\
    )\nassert(find_max(words: [\"name\", \"enam\", \"game\"]) == \"enam\")\nassert(find_max(words:\
    \ [\"aaaaaaa\", \"bb\", \"cc\"]) == \"aaaaaaa\")\nassert(find_max(words: [\"abc\"\
    , \"cba\"]) == \"abc\")\nassert(find_max(words: [\"play\", \"this\", \"game\"\
    , \"of\", \"footbott\"]) == \"footbott\")\nassert(find_max(words: [\"we\", \"\
    are\", \"gonna\", \"rock\"]) == \"gonna\")\nassert(find_max(words: [\"we\", \"\
    are\", \"a\", \"mad\", \"nation\"]) == \"nation\")\nassert(find_max(words: [\"\
    this\", \"is\", \"a\", \"prrk\"]) == \"this\")\nassert(find_max(words: [\"b\"\
    ]) == \"b\")\nassert(find_max(words: [\"play\", \"play\", \"play\"]) == \"play\"\
    )"
  status: Exception
  stderr: 'tmp78i8t66w/tmp78i8t66w.swift:40: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b1ba9d83c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b1ba9a7ab6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b1ba9a7a988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b1ba9a797b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmp78i8t66w                        0x000055f4943bd993 <unavailable> + 6547

    5    libc.so.6                          0x00002b1ba9f6f460 __libc_start_main +
    245

    6    tmp78i8t66w                        0x000055f4943bd3b9 <unavailable> + 5049

    '
  stdout: ''
  timestamp: 1660013456
- exit_code: -4
  program: "\n/// Write a function that accepts an array of strings.\n/// The array\
    \ contains different words. Return the word with maximum number\n/// of unique\
    \ characters. If multiple strings have maximum number of unique\n/// characters,\
    \ return the one which comes first in lexicographical order.\n/// >>> find_max(words:\
    \ [\"name\", \"of\", \"string\"])\n/// \"string\"\n/// >>> find_max(words: [\"\
    name\", \"enam\", \"game\"])\n/// \"enam\"\n/// >>> find_max(words: [\"aaaaaaa\"\
    , \"bb\", \"cc\"])\n/// \"aaaaaaa\"\nfunc find_max(words: [String]) -> String\
    \ {\n    var maxWord: String = \"\"\n    var maxCharacters = 0\n    for word in\
    \ words {\n        let wordCharacters = Set(word)\n        if wordCharacters.count\
    \ > maxCharacters {\n            maxCharacters = wordCharacters.count\n      \
    \      maxWord = word\n        }\n    }\n    return maxWord\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(find_max(words: [\"name\", \"of\", \"string\"]) == \"\
    string\")\nassert(find_max(words: [\"name\", \"enam\", \"game\"]) == \"enam\"\
    )\nassert(find_max(words: [\"aaaaaaa\", \"bb\", \"cc\"]) == \"aaaaaaa\")\nassert(find_max(words:\
    \ [\"abc\", \"cba\"]) == \"abc\")\nassert(find_max(words: [\"play\", \"this\"\
    , \"game\", \"of\", \"footbott\"]) == \"footbott\")\nassert(find_max(words: [\"\
    we\", \"are\", \"gonna\", \"rock\"]) == \"gonna\")\nassert(find_max(words: [\"\
    we\", \"are\", \"a\", \"mad\", \"nation\"]) == \"nation\")\nassert(find_max(words:\
    \ [\"this\", \"is\", \"a\", \"prrk\"]) == \"this\")\nassert(find_max(words: [\"\
    b\"]) == \"b\")\nassert(find_max(words: [\"play\", \"play\", \"play\"]) == \"\
    play\")"
  status: Exception
  stderr: 'tmp0dgguet_/tmp0dgguet_.swift:39: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b8811051c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b8810d48b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b8810d48988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b8810d477b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmp0dgguet_                        0x000055faffb40933 <unavailable> + 6451

    5    libc.so.6                          0x00002b881123d460 __libc_start_main +
    245

    6    tmp0dgguet_                        0x000055faffb40359 <unavailable> + 4953

    '
  stdout: ''
  timestamp: 1660013456
- exit_code: 0
  program: "\n/// Write a function that accepts an array of strings.\n/// The array\
    \ contains different words. Return the word with maximum number\n/// of unique\
    \ characters. If multiple strings have maximum number of unique\n/// characters,\
    \ return the one which comes first in lexicographical order.\n/// >>> find_max(words:\
    \ [\"name\", \"of\", \"string\"])\n/// \"string\"\n/// >>> find_max(words: [\"\
    name\", \"enam\", \"game\"])\n/// \"enam\"\n/// >>> find_max(words: [\"aaaaaaa\"\
    , \"bb\", \"cc\"])\n/// \"aaaaaaa\"\nfunc find_max(words: [String]) -> String\
    \ {\n    var counter = [String: Set<Character>]()\n    for word in words {\n \
    \       var unique = Set<Character>()\n        for character in word {\n     \
    \       unique.insert(character)\n        }\n        counter[word] = unique\n\
    \    }\n    let max_size = counter.map({ $0.value.count }).max()\n    var results\
    \ = [String]()\n    for (word, value) in counter {\n        if value.count ==\
    \ max_size {\n            results.append(word)\n        }\n    }\n    return results.min()!\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(find_max(words: [\"name\", \"of\", \"string\"\
    ]) == \"string\")\nassert(find_max(words: [\"name\", \"enam\", \"game\"]) == \"\
    enam\")\nassert(find_max(words: [\"aaaaaaa\", \"bb\", \"cc\"]) == \"aaaaaaa\"\
    )\nassert(find_max(words: [\"abc\", \"cba\"]) == \"abc\")\nassert(find_max(words:\
    \ [\"play\", \"this\", \"game\", \"of\", \"footbott\"]) == \"footbott\")\nassert(find_max(words:\
    \ [\"we\", \"are\", \"gonna\", \"rock\"]) == \"gonna\")\nassert(find_max(words:\
    \ [\"we\", \"are\", \"a\", \"mad\", \"nation\"]) == \"nation\")\nassert(find_max(words:\
    \ [\"this\", \"is\", \"a\", \"prrk\"]) == \"this\")\nassert(find_max(words: [\"\
    b\"]) == \"b\")\nassert(find_max(words: [\"play\", \"play\", \"play\"]) == \"\
    play\")"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660013456
- exit_code: -4
  program: "\n/// Write a function that accepts an array of strings.\n/// The array\
    \ contains different words. Return the word with maximum number\n/// of unique\
    \ characters. If multiple strings have maximum number of unique\n/// characters,\
    \ return the one which comes first in lexicographical order.\n/// >>> find_max(words:\
    \ [\"name\", \"of\", \"string\"])\n/// \"string\"\n/// >>> find_max(words: [\"\
    name\", \"enam\", \"game\"])\n/// \"enam\"\n/// >>> find_max(words: [\"aaaaaaa\"\
    , \"bb\", \"cc\"])\n/// \"aaaaaaa\"\nfunc find_max(words: [String]) -> String\
    \ {\n    var word_map = [Character: Int]()\n    var max_word = String()\n    var\
    \ max_num = 0\n    for word in words {\n        if word.count == 1 {\n       \
    \     max_word = word\n            break\n        }\n        word_map.removeAll()\n\
    \        for char in word {\n            if let i = word_map[char] {\n       \
    \         word_map[char] = i + 1\n            } else {\n                word_map[char]\
    \ = 1\n            }\n        }\n        var count = 0\n        for _ in word_map\
    \ {\n            count += 1\n        }\n        if count > max_num {\n       \
    \     max_num = count\n            max_word = word\n        } else if count ==\
    \ max_num {\n            if word < max_word {\n                max_word = word\n\
    \            }\n        }\n    }\n    return max_word\n}\n\n\nfunc ==(left: [(Int,\
    \ Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n\
    \        return false\n    }\n    for (l, r) in zip(left, right) {\n        if\
    \ l != r {\n            return false\n        }\n    }\n    return true\n}\n \
    \           \nassert(find_max(words: [\"name\", \"of\", \"string\"]) == \"string\"\
    )\nassert(find_max(words: [\"name\", \"enam\", \"game\"]) == \"enam\")\nassert(find_max(words:\
    \ [\"aaaaaaa\", \"bb\", \"cc\"]) == \"aaaaaaa\")\nassert(find_max(words: [\"abc\"\
    , \"cba\"]) == \"abc\")\nassert(find_max(words: [\"play\", \"this\", \"game\"\
    , \"of\", \"footbott\"]) == \"footbott\")\nassert(find_max(words: [\"we\", \"\
    are\", \"gonna\", \"rock\"]) == \"gonna\")\nassert(find_max(words: [\"we\", \"\
    are\", \"a\", \"mad\", \"nation\"]) == \"nation\")\nassert(find_max(words: [\"\
    this\", \"is\", \"a\", \"prrk\"]) == \"this\")\nassert(find_max(words: [\"b\"\
    ]) == \"b\")\nassert(find_max(words: [\"play\", \"play\", \"play\"]) == \"play\"\
    )"
  status: Exception
  stderr: 'tmpurex872v/tmpurex872v.swift:64: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b280edb3c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b280eaaab6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b280eaaa988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b280eaa97b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpurex872v                        0x000055645aed05ed <unavailable> + 9709

    5    libc.so.6                          0x00002b280ef9f460 __libc_start_main +
    245

    6    tmpurex872v                        0x000055645aecf6d9 <unavailable> + 5849

    '
  stdout: ''
  timestamp: 1660013456
- exit_code: -4
  program: "\n/// Write a function that accepts an array of strings.\n/// The array\
    \ contains different words. Return the word with maximum number\n/// of unique\
    \ characters. If multiple strings have maximum number of unique\n/// characters,\
    \ return the one which comes first in lexicographical order.\n/// >>> find_max(words:\
    \ [\"name\", \"of\", \"string\"])\n/// \"string\"\n/// >>> find_max(words: [\"\
    name\", \"enam\", \"game\"])\n/// \"enam\"\n/// >>> find_max(words: [\"aaaaaaa\"\
    , \"bb\", \"cc\"])\n/// \"aaaaaaa\"\nfunc find_max(words: [String]) -> String\
    \ {\n    var maxCount = 0\n    var maxWord = \"\"\n    for word in words {\n \
    \       var unique = Set<Character>()\n        for char in word {\n          \
    \  unique.insert(char)\n        }\n        if unique.count > maxCount {\n    \
    \        maxCount = unique.count\n            maxWord = word\n        }\n    }\n\
    \    return maxWord\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) ->\
    \ Bool {\n    if left.count != right.count {\n        return false\n    }\n  \
    \  for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(find_max(words: [\"\
    name\", \"of\", \"string\"]) == \"string\")\nassert(find_max(words: [\"name\"\
    , \"enam\", \"game\"]) == \"enam\")\nassert(find_max(words: [\"aaaaaaa\", \"bb\"\
    , \"cc\"]) == \"aaaaaaa\")\nassert(find_max(words: [\"abc\", \"cba\"]) == \"abc\"\
    )\nassert(find_max(words: [\"play\", \"this\", \"game\", \"of\", \"footbott\"\
    ]) == \"footbott\")\nassert(find_max(words: [\"we\", \"are\", \"gonna\", \"rock\"\
    ]) == \"gonna\")\nassert(find_max(words: [\"we\", \"are\", \"a\", \"mad\", \"\
    nation\"]) == \"nation\")\nassert(find_max(words: [\"this\", \"is\", \"a\", \"\
    prrk\"]) == \"this\")\nassert(find_max(words: [\"b\"]) == \"b\")\nassert(find_max(words:\
    \ [\"play\", \"play\", \"play\"]) == \"play\")"
  status: Exception
  stderr: 'tmpy2_m8nyi/tmpy2_m8nyi.swift:42: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b05c43c8c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b05c40bfb6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b05c40bf988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b05c40be7b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpy2_m8nyi                        0x000055a373116a03 <unavailable> + 6659

    5    libc.so.6                          0x00002b05c45b4460 __libc_start_main +
    245

    6    tmpy2_m8nyi                        0x000055a373116429 <unavailable> + 5161

    '
  stdout: ''
  timestamp: 1660013456
- exit_code: 1
  program: "\n/// Write a function that accepts an array of strings.\n/// The array\
    \ contains different words. Return the word with maximum number\n/// of unique\
    \ characters. If multiple strings have maximum number of unique\n/// characters,\
    \ return the one which comes first in lexicographical order.\n/// >>> find_max(words:\
    \ [\"name\", \"of\", \"string\"])\n/// \"string\"\n/// >>> find_max(words: [\"\
    name\", \"enam\", \"game\"])\n/// \"enam\"\n/// >>> find_max(words: [\"aaaaaaa\"\
    , \"bb\", \"cc\"])\n/// \"aaaaaaa\"\nfunc find_max(words: [String]) -> String\
    \ {\n    var dictionary = [String: String]()\n    var maxChar = 0\n    var result\
    \ = \"\"\n    for word in words {\n        var wordArr = word.characters.map {\
    \ String($0) }\n        var total = 0\n        for char in wordArr {\n       \
    \     if !dictionary.keys.contains(char) {\n                dictionary[char] =\
    \ \"\"\n                total += 1\n            }\n        }\n        if total\
    \ > maxChar {\n            maxChar = total\n            result = word\n      \
    \  }\n    }\n    return result\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int,\
    \ Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n\
    \    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n          \
    \  return false\n        }\n    }\n    return true\n}\n            \nassert(find_max(words:\
    \ [\"name\", \"of\", \"string\"]) == \"string\")\nassert(find_max(words: [\"name\"\
    , \"enam\", \"game\"]) == \"enam\")\nassert(find_max(words: [\"aaaaaaa\", \"bb\"\
    , \"cc\"]) == \"aaaaaaa\")\nassert(find_max(words: [\"abc\", \"cba\"]) == \"abc\"\
    )\nassert(find_max(words: [\"play\", \"this\", \"game\", \"of\", \"footbott\"\
    ]) == \"footbott\")\nassert(find_max(words: [\"we\", \"are\", \"gonna\", \"rock\"\
    ]) == \"gonna\")\nassert(find_max(words: [\"we\", \"are\", \"a\", \"mad\", \"\
    nation\"]) == \"nation\")\nassert(find_max(words: [\"this\", \"is\", \"a\", \"\
    prrk\"]) == \"this\")\nassert(find_max(words: [\"b\"]) == \"b\")\nassert(find_max(words:\
    \ [\"play\", \"play\", \"play\"]) == \"play\")"
  status: SyntaxError
  stderr: "/tmp/tmpc57jfgs3.swift:17:28: error: 'characters' is unavailable: Please\
    \ use String directly\n        var wordArr = word.characters.map { String($0)\
    \ }\n                           ^~~~~~~~~~\nSwift.String:5:16: note: 'characters'\
    \ was obsoleted in Swift 5.0\n    public var characters: String { get set }\n\
    \               ^\n/tmp/tmpc57jfgs3.swift:17:13: warning: variable 'wordArr' was\
    \ never mutated; consider changing to 'let' constant\n        var wordArr = word.characters.map\
    \ { String($0) }\n        ~~~ ^\n        let\n"
  stdout: ''
  timestamp: 1660013456
- exit_code: 1
  program: "\n/// Write a function that accepts an array of strings.\n/// The array\
    \ contains different words. Return the word with maximum number\n/// of unique\
    \ characters. If multiple strings have maximum number of unique\n/// characters,\
    \ return the one which comes first in lexicographical order.\n/// >>> find_max(words:\
    \ [\"name\", \"of\", \"string\"])\n/// \"string\"\n/// >>> find_max(words: [\"\
    name\", \"enam\", \"game\"])\n/// \"enam\"\n/// >>> find_max(words: [\"aaaaaaa\"\
    , \"bb\", \"cc\"])\n/// \"aaaaaaa\"\nfunc find_max(words: [String]) -> String\
    \ {\n    let uniqueWords = words.map { $0.filterDuplicates() }\n    let uniqueCounts\
    \ = uniqueWords.map { $0.count }\n    let resultIndex = uniqueCounts.argmax()\n\
    \    return words[resultIndex]\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int,\
    \ Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n\
    \    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n          \
    \  return false\n        }\n    }\n    return true\n}\n            \nassert(find_max(words:\
    \ [\"name\", \"of\", \"string\"]) == \"string\")\nassert(find_max(words: [\"name\"\
    , \"enam\", \"game\"]) == \"enam\")\nassert(find_max(words: [\"aaaaaaa\", \"bb\"\
    , \"cc\"]) == \"aaaaaaa\")\nassert(find_max(words: [\"abc\", \"cba\"]) == \"abc\"\
    )\nassert(find_max(words: [\"play\", \"this\", \"game\", \"of\", \"footbott\"\
    ]) == \"footbott\")\nassert(find_max(words: [\"we\", \"are\", \"gonna\", \"rock\"\
    ]) == \"gonna\")\nassert(find_max(words: [\"we\", \"are\", \"a\", \"mad\", \"\
    nation\"]) == \"nation\")\nassert(find_max(words: [\"this\", \"is\", \"a\", \"\
    prrk\"]) == \"this\")\nassert(find_max(words: [\"b\"]) == \"b\")\nassert(find_max(words:\
    \ [\"play\", \"play\", \"play\"]) == \"play\")"
  status: SyntaxError
  stderr: "/tmp/tmpm7iz48y8.swift:13:38: error: value of type 'String' has no member\
    \ 'filterDuplicates'\n    let uniqueWords = words.map { $0.filterDuplicates()\
    \ }\n                                  ~~ ^~~~~~~~~~~~~~~~\n"
  stdout: ''
  timestamp: 1660013456
- exit_code: -4
  program: "\n/// Write a function that accepts an array of strings.\n/// The array\
    \ contains different words. Return the word with maximum number\n/// of unique\
    \ characters. If multiple strings have maximum number of unique\n/// characters,\
    \ return the one which comes first in lexicographical order.\n/// >>> find_max(words:\
    \ [\"name\", \"of\", \"string\"])\n/// \"string\"\n/// >>> find_max(words: [\"\
    name\", \"enam\", \"game\"])\n/// \"enam\"\n/// >>> find_max(words: [\"aaaaaaa\"\
    , \"bb\", \"cc\"])\n/// \"aaaaaaa\"\nfunc find_max(words: [String]) -> String\
    \ {\n    // You need to implement this function.\n    return \"\"\n}\n\n\nfunc\
    \ ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count !=\
    \ right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(find_max(words: [\"name\", \"of\", \"string\"\
    ]) == \"string\")\nassert(find_max(words: [\"name\", \"enam\", \"game\"]) == \"\
    enam\")\nassert(find_max(words: [\"aaaaaaa\", \"bb\", \"cc\"]) == \"aaaaaaa\"\
    )\nassert(find_max(words: [\"abc\", \"cba\"]) == \"abc\")\nassert(find_max(words:\
    \ [\"play\", \"this\", \"game\", \"of\", \"footbott\"]) == \"footbott\")\nassert(find_max(words:\
    \ [\"we\", \"are\", \"gonna\", \"rock\"]) == \"gonna\")\nassert(find_max(words:\
    \ [\"we\", \"are\", \"a\", \"mad\", \"nation\"]) == \"nation\")\nassert(find_max(words:\
    \ [\"this\", \"is\", \"a\", \"prrk\"]) == \"this\")\nassert(find_max(words: [\"\
    b\"]) == \"b\")\nassert(find_max(words: [\"play\", \"play\", \"play\"]) == \"\
    play\")"
  status: Exception
  stderr: 'tmpb8cn7mbz/tmpb8cn7mbz.swift:30: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002ba823d56c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002ba823a4db6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002ba823a4d988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002ba823a4c7b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpb8cn7mbz                        0x000055e85ba8b4ce <unavailable> + 5326

    5    libc.so.6                          0x00002ba823f42460 __libc_start_main +
    245

    6    tmpb8cn7mbz                        0x000055e85ba8b089 <unavailable> + 4233

    '
  stdout: ''
  timestamp: 1660013456
- exit_code: 1
  program: "\n/// Write a function that accepts an array of strings.\n/// The array\
    \ contains different words. Return the word with maximum number\n/// of unique\
    \ characters. If multiple strings have maximum number of unique\n/// characters,\
    \ return the one which comes first in lexicographical order.\n/// >>> find_max(words:\
    \ [\"name\", \"of\", \"string\"])\n/// \"string\"\n/// >>> find_max(words: [\"\
    name\", \"enam\", \"game\"])\n/// \"enam\"\n/// >>> find_max(words: [\"aaaaaaa\"\
    , \"bb\", \"cc\"])\n/// \"aaaaaaa\"\nfunc find_max(words: [String]) -> String\
    \ {\n  guard let first = words.first else { return \"\" }\n  return words.reduce(first)\
    \ { (result, word) in\n    if count_unique_characters(word) > count_unique_characters(result)\
    \ {\n      return word\n    } else if count_unique_characters(word) == count_unique_characters(result)\
    \ && word < result {\n      return word\n    } else {\n      return result\n \
    \   }\n  }\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n\
    \    if left.count != right.count {\n        return false\n    }\n    for (l,\
    \ r) in zip(left, right) {\n        if l != r {\n            return false\n  \
    \      }\n    }\n    return true\n}\n            \nassert(find_max(words: [\"\
    name\", \"of\", \"string\"]) == \"string\")\nassert(find_max(words: [\"name\"\
    , \"enam\", \"game\"]) == \"enam\")\nassert(find_max(words: [\"aaaaaaa\", \"bb\"\
    , \"cc\"]) == \"aaaaaaa\")\nassert(find_max(words: [\"abc\", \"cba\"]) == \"abc\"\
    )\nassert(find_max(words: [\"play\", \"this\", \"game\", \"of\", \"footbott\"\
    ]) == \"footbott\")\nassert(find_max(words: [\"we\", \"are\", \"gonna\", \"rock\"\
    ]) == \"gonna\")\nassert(find_max(words: [\"we\", \"are\", \"a\", \"mad\", \"\
    nation\"]) == \"nation\")\nassert(find_max(words: [\"this\", \"is\", \"a\", \"\
    prrk\"]) == \"this\")\nassert(find_max(words: [\"b\"]) == \"b\")\nassert(find_max(words:\
    \ [\"play\", \"play\", \"play\"]) == \"play\")"
  status: SyntaxError
  stderr: "/tmp/tmpgi08inlu.swift:15:8: error: cannot find 'count_unique_characters'\
    \ in scope\n    if count_unique_characters(word) > count_unique_characters(result)\
    \ {\n       ^~~~~~~~~~~~~~~~~~~~~~~\n/tmp/tmpgi08inlu.swift:15:40: error: cannot\
    \ find 'count_unique_characters' in scope\n    if count_unique_characters(word)\
    \ > count_unique_characters(result) {\n                                      \
    \ ^~~~~~~~~~~~~~~~~~~~~~~\n/tmp/tmpgi08inlu.swift:17:15: error: cannot find 'count_unique_characters'\
    \ in scope\n    } else if count_unique_characters(word) == count_unique_characters(result)\
    \ && word < result {\n              ^~~~~~~~~~~~~~~~~~~~~~~\n/tmp/tmpgi08inlu.swift:17:48:\
    \ error: cannot find 'count_unique_characters' in scope\n    } else if count_unique_characters(word)\
    \ == count_unique_characters(result) && word < result {\n                    \
    \                           ^~~~~~~~~~~~~~~~~~~~~~~\n"
  stdout: ''
  timestamp: 1660013456
- exit_code: -4
  program: "\n/// Write a function that accepts an array of strings.\n/// The array\
    \ contains different words. Return the word with maximum number\n/// of unique\
    \ characters. If multiple strings have maximum number of unique\n/// characters,\
    \ return the one which comes first in lexicographical order.\n/// >>> find_max(words:\
    \ [\"name\", \"of\", \"string\"])\n/// \"string\"\n/// >>> find_max(words: [\"\
    name\", \"enam\", \"game\"])\n/// \"enam\"\n/// >>> find_max(words: [\"aaaaaaa\"\
    , \"bb\", \"cc\"])\n/// \"aaaaaaa\"\nfunc find_max(words: [String]) -> String\
    \ {\n    // TODO\n    return \"\"\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int,\
    \ Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n\
    \    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n          \
    \  return false\n        }\n    }\n    return true\n}\n            \nassert(find_max(words:\
    \ [\"name\", \"of\", \"string\"]) == \"string\")\nassert(find_max(words: [\"name\"\
    , \"enam\", \"game\"]) == \"enam\")\nassert(find_max(words: [\"aaaaaaa\", \"bb\"\
    , \"cc\"]) == \"aaaaaaa\")\nassert(find_max(words: [\"abc\", \"cba\"]) == \"abc\"\
    )\nassert(find_max(words: [\"play\", \"this\", \"game\", \"of\", \"footbott\"\
    ]) == \"footbott\")\nassert(find_max(words: [\"we\", \"are\", \"gonna\", \"rock\"\
    ]) == \"gonna\")\nassert(find_max(words: [\"we\", \"are\", \"a\", \"mad\", \"\
    nation\"]) == \"nation\")\nassert(find_max(words: [\"this\", \"is\", \"a\", \"\
    prrk\"]) == \"this\")\nassert(find_max(words: [\"b\"]) == \"b\")\nassert(find_max(words:\
    \ [\"play\", \"play\", \"play\"]) == \"play\")"
  status: Exception
  stderr: 'tmp7cz26xke/tmp7cz26xke.swift:30: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b1a6862fc80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b1a68326b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b1a68326988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b1a683257b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmp7cz26xke                        0x0000556d009f94ce <unavailable> + 5326

    5    libc.so.6                          0x00002b1a6881b460 __libc_start_main +
    245

    6    tmp7cz26xke                        0x0000556d009f9089 <unavailable> + 4233

    '
  stdout: ''
  timestamp: 1660013456
- exit_code: -4
  program: "\n/// Write a function that accepts an array of strings.\n/// The array\
    \ contains different words. Return the word with maximum number\n/// of unique\
    \ characters. If multiple strings have maximum number of unique\n/// characters,\
    \ return the one which comes first in lexicographical order.\n/// >>> find_max(words:\
    \ [\"name\", \"of\", \"string\"])\n/// \"string\"\n/// >>> find_max(words: [\"\
    name\", \"enam\", \"game\"])\n/// \"enam\"\n/// >>> find_max(words: [\"aaaaaaa\"\
    , \"bb\", \"cc\"])\n/// \"aaaaaaa\"\nfunc find_max(words: [String]) -> String\
    \ {\n  let array1 = words.map { $0.count }\n  let maxcount = array1.max()\n  let\
    \ index = array1.firstIndex(of: maxcount!)\n  return words[index!]\n}\n\n\nfunc\
    \ ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count !=\
    \ right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(find_max(words: [\"name\", \"of\", \"string\"\
    ]) == \"string\")\nassert(find_max(words: [\"name\", \"enam\", \"game\"]) == \"\
    enam\")\nassert(find_max(words: [\"aaaaaaa\", \"bb\", \"cc\"]) == \"aaaaaaa\"\
    )\nassert(find_max(words: [\"abc\", \"cba\"]) == \"abc\")\nassert(find_max(words:\
    \ [\"play\", \"this\", \"game\", \"of\", \"footbott\"]) == \"footbott\")\nassert(find_max(words:\
    \ [\"we\", \"are\", \"gonna\", \"rock\"]) == \"gonna\")\nassert(find_max(words:\
    \ [\"we\", \"are\", \"a\", \"mad\", \"nation\"]) == \"nation\")\nassert(find_max(words:\
    \ [\"this\", \"is\", \"a\", \"prrk\"]) == \"this\")\nassert(find_max(words: [\"\
    b\"]) == \"b\")\nassert(find_max(words: [\"play\", \"play\", \"play\"]) == \"\
    play\")"
  status: Exception
  stderr: 'tmpd1tor7_j/tmpd1tor7_j.swift:33: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002af53f66ec80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002af53f365b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002af53f365988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002af53f3647b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpd1tor7_j                        0x000055eca2447953 <unavailable> + 6483

    5    libc.so.6                          0x00002af53f85a460 __libc_start_main +
    245

    6    tmpd1tor7_j                        0x000055eca2447379 <unavailable> + 4985

    '
  stdout: ''
  timestamp: 1660013456
- exit_code: -4
  program: "\n/// Write a function that accepts an array of strings.\n/// The array\
    \ contains different words. Return the word with maximum number\n/// of unique\
    \ characters. If multiple strings have maximum number of unique\n/// characters,\
    \ return the one which comes first in lexicographical order.\n/// >>> find_max(words:\
    \ [\"name\", \"of\", \"string\"])\n/// \"string\"\n/// >>> find_max(words: [\"\
    name\", \"enam\", \"game\"])\n/// \"enam\"\n/// >>> find_max(words: [\"aaaaaaa\"\
    , \"bb\", \"cc\"])\n/// \"aaaaaaa\"\nfunc find_max(words: [String]) -> String\
    \ {\n    return \"\"\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(find_max(words:\
    \ [\"name\", \"of\", \"string\"]) == \"string\")\nassert(find_max(words: [\"name\"\
    , \"enam\", \"game\"]) == \"enam\")\nassert(find_max(words: [\"aaaaaaa\", \"bb\"\
    , \"cc\"]) == \"aaaaaaa\")\nassert(find_max(words: [\"abc\", \"cba\"]) == \"abc\"\
    )\nassert(find_max(words: [\"play\", \"this\", \"game\", \"of\", \"footbott\"\
    ]) == \"footbott\")\nassert(find_max(words: [\"we\", \"are\", \"gonna\", \"rock\"\
    ]) == \"gonna\")\nassert(find_max(words: [\"we\", \"are\", \"a\", \"mad\", \"\
    nation\"]) == \"nation\")\nassert(find_max(words: [\"this\", \"is\", \"a\", \"\
    prrk\"]) == \"this\")\nassert(find_max(words: [\"b\"]) == \"b\")\nassert(find_max(words:\
    \ [\"play\", \"play\", \"play\"]) == \"play\")"
  status: Exception
  stderr: 'tmp9vfthvyx/tmp9vfthvyx.swift:29: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b5bb598bc80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b5bb5682b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b5bb5682988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b5bb56817b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmp9vfthvyx                        0x0000564c87ea64ce <unavailable> + 5326

    5    libc.so.6                          0x00002b5bb5b77460 __libc_start_main +
    245

    6    tmp9vfthvyx                        0x0000564c87ea6089 <unavailable> + 4233

    '
  stdout: ''
  timestamp: 1660013265
- exit_code: -4
  program: "\n/// Write a function that accepts an array of strings.\n/// The array\
    \ contains different words. Return the word with maximum number\n/// of unique\
    \ characters. If multiple strings have maximum number of unique\n/// characters,\
    \ return the one which comes first in lexicographical order.\n/// >>> find_max(words:\
    \ [\"name\", \"of\", \"string\"])\n/// \"string\"\n/// >>> find_max(words: [\"\
    name\", \"enam\", \"game\"])\n/// \"enam\"\n/// >>> find_max(words: [\"aaaaaaa\"\
    , \"bb\", \"cc\"])\n/// \"aaaaaaa\"\nfunc find_max(words: [String]) -> String\
    \ {\n    return \"\"\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(find_max(words:\
    \ [\"name\", \"of\", \"string\"]) == \"string\")\nassert(find_max(words: [\"name\"\
    , \"enam\", \"game\"]) == \"enam\")\nassert(find_max(words: [\"aaaaaaa\", \"bb\"\
    , \"cc\"]) == \"aaaaaaa\")\nassert(find_max(words: [\"abc\", \"cba\"]) == \"abc\"\
    )\nassert(find_max(words: [\"play\", \"this\", \"game\", \"of\", \"footbott\"\
    ]) == \"footbott\")\nassert(find_max(words: [\"we\", \"are\", \"gonna\", \"rock\"\
    ]) == \"gonna\")\nassert(find_max(words: [\"we\", \"are\", \"a\", \"mad\", \"\
    nation\"]) == \"nation\")\nassert(find_max(words: [\"this\", \"is\", \"a\", \"\
    prrk\"]) == \"this\")\nassert(find_max(words: [\"b\"]) == \"b\")\nassert(find_max(words:\
    \ [\"play\", \"play\", \"play\"]) == \"play\")"
  status: Exception
  stderr: 'tmp9vfthvyx/tmp9vfthvyx.swift:29: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b5bb598bc80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b5bb5682b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b5bb5682988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b5bb56817b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmp9vfthvyx                        0x0000564c87ea64ce <unavailable> + 5326

    5    libc.so.6                          0x00002b5bb5b77460 __libc_start_main +
    245

    6    tmp9vfthvyx                        0x0000564c87ea6089 <unavailable> + 4233

    '
  stdout: ''
  timestamp: 1660013265
- exit_code: -4
  program: "\n/// Write a function that accepts an array of strings.\n/// The array\
    \ contains different words. Return the word with maximum number\n/// of unique\
    \ characters. If multiple strings have maximum number of unique\n/// characters,\
    \ return the one which comes first in lexicographical order.\n/// >>> find_max(words:\
    \ [\"name\", \"of\", \"string\"])\n/// \"string\"\n/// >>> find_max(words: [\"\
    name\", \"enam\", \"game\"])\n/// \"enam\"\n/// >>> find_max(words: [\"aaaaaaa\"\
    , \"bb\", \"cc\"])\n/// \"aaaaaaa\"\nfunc find_max(words: [String]) -> String\
    \ {\n    return \"\"\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(find_max(words:\
    \ [\"name\", \"of\", \"string\"]) == \"string\")\nassert(find_max(words: [\"name\"\
    , \"enam\", \"game\"]) == \"enam\")\nassert(find_max(words: [\"aaaaaaa\", \"bb\"\
    , \"cc\"]) == \"aaaaaaa\")\nassert(find_max(words: [\"abc\", \"cba\"]) == \"abc\"\
    )\nassert(find_max(words: [\"play\", \"this\", \"game\", \"of\", \"footbott\"\
    ]) == \"footbott\")\nassert(find_max(words: [\"we\", \"are\", \"gonna\", \"rock\"\
    ]) == \"gonna\")\nassert(find_max(words: [\"we\", \"are\", \"a\", \"mad\", \"\
    nation\"]) == \"nation\")\nassert(find_max(words: [\"this\", \"is\", \"a\", \"\
    prrk\"]) == \"this\")\nassert(find_max(words: [\"b\"]) == \"b\")\nassert(find_max(words:\
    \ [\"play\", \"play\", \"play\"]) == \"play\")"
  status: Exception
  stderr: 'tmp9vfthvyx/tmp9vfthvyx.swift:29: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b5bb598bc80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b5bb5682b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b5bb5682988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b5bb56817b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmp9vfthvyx                        0x0000564c87ea64ce <unavailable> + 5326

    5    libc.so.6                          0x00002b5bb5b77460 __libc_start_main +
    245

    6    tmp9vfthvyx                        0x0000564c87ea6089 <unavailable> + 4233

    '
  stdout: ''
  timestamp: 1660013265
- exit_code: 1
  program: "\n/// Write a function that accepts an array of strings.\n/// The array\
    \ contains different words. Return the word with maximum number\n/// of unique\
    \ characters. If multiple strings have maximum number of unique\n/// characters,\
    \ return the one which comes first in lexicographical order.\n/// >>> find_max(words:\
    \ [\"name\", \"of\", \"string\"])\n/// \"string\"\n/// >>> find_max(words: [\"\
    name\", \"enam\", \"game\"])\n/// \"enam\"\n/// >>> find_max(words: [\"aaaaaaa\"\
    , \"bb\", \"cc\"])\n/// \"aaaaaaa\"\nfunc find_max(words: [String]) -> String\
    \ {\n    var maxCharsCount = 0\n    var maxWord = \"\"\n    for (index, word)\
    \ in words.enumerated() {\n        let uniqueCharsCount = word.uniqueCharsCount()\n\
    \        if uniqueCharsCount > maxCharsCount {\n            maxCharsCount = uniqueCharsCount\n\
    \            maxWord = word\n        } else if uniqueCharsCount == maxCharsCount\
    \ && word < maxWord {\n            maxWord = word\n        }\n    }\n    return\
    \ maxWord\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n\
    \    if left.count != right.count {\n        return false\n    }\n    for (l,\
    \ r) in zip(left, right) {\n        if l != r {\n            return false\n  \
    \      }\n    }\n    return true\n}\n            \nassert(find_max(words: [\"\
    name\", \"of\", \"string\"]) == \"string\")\nassert(find_max(words: [\"name\"\
    , \"enam\", \"game\"]) == \"enam\")\nassert(find_max(words: [\"aaaaaaa\", \"bb\"\
    , \"cc\"]) == \"aaaaaaa\")\nassert(find_max(words: [\"abc\", \"cba\"]) == \"abc\"\
    )\nassert(find_max(words: [\"play\", \"this\", \"game\", \"of\", \"footbott\"\
    ]) == \"footbott\")\nassert(find_max(words: [\"we\", \"are\", \"gonna\", \"rock\"\
    ]) == \"gonna\")\nassert(find_max(words: [\"we\", \"are\", \"a\", \"mad\", \"\
    nation\"]) == \"nation\")\nassert(find_max(words: [\"this\", \"is\", \"a\", \"\
    prrk\"]) == \"this\")\nassert(find_max(words: [\"b\"]) == \"b\")\nassert(find_max(words:\
    \ [\"play\", \"play\", \"play\"]) == \"play\")"
  status: SyntaxError
  stderr: "/tmp/tmpoh5n8e_r.swift:16:37: error: value of type 'String' has no member\
    \ 'uniqueCharsCount'\n        let uniqueCharsCount = word.uniqueCharsCount()\n\
    \                               ~~~~ ^~~~~~~~~~~~~~~~\n"
  stdout: ''
  timestamp: 1660013456
- exit_code: 1
  program: "\n/// Write a function that accepts an array of strings.\n/// The array\
    \ contains different words. Return the word with maximum number\n/// of unique\
    \ characters. If multiple strings have maximum number of unique\n/// characters,\
    \ return the one which comes first in lexicographical order.\n/// >>> find_max(words:\
    \ [\"name\", \"of\", \"string\"])\n/// \"string\"\n/// >>> find_max(words: [\"\
    name\", \"enam\", \"game\"])\n/// \"enam\"\n/// >>> find_max(words: [\"aaaaaaa\"\
    , \"bb\", \"cc\"])\n/// \"aaaaaaa\"\nfunc find_max(words: [String]) -> String\
    \ {\n    if words.count == 0 {\n        return \"\"\n    }\n    var maxWord =\
    \ words[0]\n    var maxCount = count_chars(word: words[0])\n    for i in 1..<words.count\
    \ {\n        let currCount = count_chars(word: words[i])\n        if currCount\
    \ > maxCount {\n            maxCount = currCount\n            maxWord = words[i]\n\
    \        } else if currCount == maxCount {\n            if words[i] < maxWord\
    \ {\n                maxWord = words[i]\n            }\n        }\n    }\n   \
    \ return maxWord\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool\
    \ {\n    if left.count != right.count {\n        return false\n    }\n    for\
    \ (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(find_max(words: [\"\
    name\", \"of\", \"string\"]) == \"string\")\nassert(find_max(words: [\"name\"\
    , \"enam\", \"game\"]) == \"enam\")\nassert(find_max(words: [\"aaaaaaa\", \"bb\"\
    , \"cc\"]) == \"aaaaaaa\")\nassert(find_max(words: [\"abc\", \"cba\"]) == \"abc\"\
    )\nassert(find_max(words: [\"play\", \"this\", \"game\", \"of\", \"footbott\"\
    ]) == \"footbott\")\nassert(find_max(words: [\"we\", \"are\", \"gonna\", \"rock\"\
    ]) == \"gonna\")\nassert(find_max(words: [\"we\", \"are\", \"a\", \"mad\", \"\
    nation\"]) == \"nation\")\nassert(find_max(words: [\"this\", \"is\", \"a\", \"\
    prrk\"]) == \"this\")\nassert(find_max(words: [\"b\"]) == \"b\")\nassert(find_max(words:\
    \ [\"play\", \"play\", \"play\"]) == \"play\")"
  status: SyntaxError
  stderr: "/tmp/tmpclon0uvs.swift:17:20: error: cannot find 'count_chars' in scope\n\
    \    var maxCount = count_chars(word: words[0])\n                   ^~~~~~~~~~~\n\
    /tmp/tmpclon0uvs.swift:19:25: error: cannot find 'count_chars' in scope\n    \
    \    let currCount = count_chars(word: words[i])\n                        ^~~~~~~~~~~\n"
  stdout: ''
  timestamp: 1660013456
- exit_code: 1
  program: "\n/// Write a function that accepts an array of strings.\n/// The array\
    \ contains different words. Return the word with maximum number\n/// of unique\
    \ characters. If multiple strings have maximum number of unique\n/// characters,\
    \ return the one which comes first in lexicographical order.\n/// >>> find_max(words:\
    \ [\"name\", \"of\", \"string\"])\n/// \"string\"\n/// >>> find_max(words: [\"\
    name\", \"enam\", \"game\"])\n/// \"enam\"\n/// >>> find_max(words: [\"aaaaaaa\"\
    , \"bb\", \"cc\"])\n/// \"aaaaaaa\"\nfunc find_max(words: [String]) -> String\
    \ {\n    var max_count = 0\n    var max_word = \"\"\n    for word in words {\n\
    \        let count = count_unique_characters(word: word)\n        if count > max_count\
    \ {\n            max_count = count\n            max_word = word\n        }\n \
    \   }\n    return max_word\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(find_max(words:\
    \ [\"name\", \"of\", \"string\"]) == \"string\")\nassert(find_max(words: [\"name\"\
    , \"enam\", \"game\"]) == \"enam\")\nassert(find_max(words: [\"aaaaaaa\", \"bb\"\
    , \"cc\"]) == \"aaaaaaa\")\nassert(find_max(words: [\"abc\", \"cba\"]) == \"abc\"\
    )\nassert(find_max(words: [\"play\", \"this\", \"game\", \"of\", \"footbott\"\
    ]) == \"footbott\")\nassert(find_max(words: [\"we\", \"are\", \"gonna\", \"rock\"\
    ]) == \"gonna\")\nassert(find_max(words: [\"we\", \"are\", \"a\", \"mad\", \"\
    nation\"]) == \"nation\")\nassert(find_max(words: [\"this\", \"is\", \"a\", \"\
    prrk\"]) == \"this\")\nassert(find_max(words: [\"b\"]) == \"b\")\nassert(find_max(words:\
    \ [\"play\", \"play\", \"play\"]) == \"play\")"
  status: SyntaxError
  stderr: "/tmp/tmp897ljl89.swift:16:21: error: cannot find 'count_unique_characters'\
    \ in scope\n        let count = count_unique_characters(word: word)\n        \
    \            ^~~~~~~~~~~~~~~~~~~~~~~\n"
  stdout: ''
  timestamp: 1660013456
- exit_code: 1
  program: "\n/// Write a function that accepts an array of strings.\n/// The array\
    \ contains different words. Return the word with maximum number\n/// of unique\
    \ characters. If multiple strings have maximum number of unique\n/// characters,\
    \ return the one which comes first in lexicographical order.\n/// >>> find_max(words:\
    \ [\"name\", \"of\", \"string\"])\n/// \"string\"\n/// >>> find_max(words: [\"\
    name\", \"enam\", \"game\"])\n/// \"enam\"\n/// >>> find_max(words: [\"aaaaaaa\"\
    , \"bb\", \"cc\"])\n/// \"aaaaaaa\"\nfunc find_max(words: [String]) -> String\
    \ {\n    guard words.count > 0 else {\n        return \"\"\n    }\n    let chars\
    \ = words.map { String($0.characters.sorted()) }\n    let result = chars.max {\
    \ $0.characters.count < $1.characters.count }\n    if let idx = chars.index(of:\
    \ result ?? \"\") {\n        return words[idx]\n    }\n    return \"\"\n}\n\n\n\
    func ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(find_max(words: [\"name\", \"of\", \"string\"\
    ]) == \"string\")\nassert(find_max(words: [\"name\", \"enam\", \"game\"]) == \"\
    enam\")\nassert(find_max(words: [\"aaaaaaa\", \"bb\", \"cc\"]) == \"aaaaaaa\"\
    )\nassert(find_max(words: [\"abc\", \"cba\"]) == \"abc\")\nassert(find_max(words:\
    \ [\"play\", \"this\", \"game\", \"of\", \"footbott\"]) == \"footbott\")\nassert(find_max(words:\
    \ [\"we\", \"are\", \"gonna\", \"rock\"]) == \"gonna\")\nassert(find_max(words:\
    \ [\"we\", \"are\", \"a\", \"mad\", \"nation\"]) == \"nation\")\nassert(find_max(words:\
    \ [\"this\", \"is\", \"a\", \"prrk\"]) == \"this\")\nassert(find_max(words: [\"\
    b\"]) == \"b\")\nassert(find_max(words: [\"play\", \"play\", \"play\"]) == \"\
    play\")"
  status: SyntaxError
  stderr: "/tmp/tmpnuvkgzix.swift:16:39: error: 'characters' is unavailable: Please\
    \ use String directly\n    let chars = words.map { String($0.characters.sorted())\
    \ }\n                                      ^~~~~~~~~~\nSwift.String:5:16: note:\
    \ 'characters' was obsoleted in Swift 5.0\n    public var characters: String {\
    \ get set }\n               ^\n/tmp/tmpnuvkgzix.swift:17:33: error: 'characters'\
    \ is unavailable: Please use String directly\n    let result = chars.max { $0.characters.count\
    \ < $1.characters.count }\n                                ^~~~~~~~~~\nSwift.String:5:16:\
    \ note: 'characters' was obsoleted in Swift 5.0\n    public var characters: String\
    \ { get set }\n               ^\n/tmp/tmpnuvkgzix.swift:17:55: error: 'characters'\
    \ is unavailable: Please use String directly\n    let result = chars.max { $0.characters.count\
    \ < $1.characters.count }\n                                                  \
    \    ^~~~~~~~~~\nSwift.String:5:16: note: 'characters' was obsoleted in Swift\
    \ 5.0\n    public var characters: String { get set }\n               ^\n/tmp/tmpnuvkgzix.swift:18:24:\
    \ warning: 'index(of:)' is deprecated: renamed to 'firstIndex(of:)'\n    if let\
    \ idx = chars.index(of: result ?? \"\") {\n                       ^\n/tmp/tmpnuvkgzix.swift:18:24:\
    \ note: use 'firstIndex(of:)' instead\n    if let idx = chars.index(of: result\
    \ ?? \"\") {\n                       ^~~~~\n                       firstIndex\n"
  stdout: ''
  timestamp: 1660013456
- exit_code: -4
  program: "\n/// Write a function that accepts an array of strings.\n/// The array\
    \ contains different words. Return the word with maximum number\n/// of unique\
    \ characters. If multiple strings have maximum number of unique\n/// characters,\
    \ return the one which comes first in lexicographical order.\n/// >>> find_max(words:\
    \ [\"name\", \"of\", \"string\"])\n/// \"string\"\n/// >>> find_max(words: [\"\
    name\", \"enam\", \"game\"])\n/// \"enam\"\n/// >>> find_max(words: [\"aaaaaaa\"\
    , \"bb\", \"cc\"])\n/// \"aaaaaaa\"\nfunc find_max(words: [String]) -> String\
    \ {\n    /// Write your solution here\n    return \"\"\n}\n\n\nfunc ==(left: [(Int,\
    \ Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n\
    \        return false\n    }\n    for (l, r) in zip(left, right) {\n        if\
    \ l != r {\n            return false\n        }\n    }\n    return true\n}\n \
    \           \nassert(find_max(words: [\"name\", \"of\", \"string\"]) == \"string\"\
    )\nassert(find_max(words: [\"name\", \"enam\", \"game\"]) == \"enam\")\nassert(find_max(words:\
    \ [\"aaaaaaa\", \"bb\", \"cc\"]) == \"aaaaaaa\")\nassert(find_max(words: [\"abc\"\
    , \"cba\"]) == \"abc\")\nassert(find_max(words: [\"play\", \"this\", \"game\"\
    , \"of\", \"footbott\"]) == \"footbott\")\nassert(find_max(words: [\"we\", \"\
    are\", \"gonna\", \"rock\"]) == \"gonna\")\nassert(find_max(words: [\"we\", \"\
    are\", \"a\", \"mad\", \"nation\"]) == \"nation\")\nassert(find_max(words: [\"\
    this\", \"is\", \"a\", \"prrk\"]) == \"this\")\nassert(find_max(words: [\"b\"\
    ]) == \"b\")\nassert(find_max(words: [\"play\", \"play\", \"play\"]) == \"play\"\
    )"
  status: Exception
  stderr: 'tmp7js61g5n/tmp7js61g5n.swift:30: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b1198799c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b1198490b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b1198490988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b119848f7b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmp7js61g5n                        0x00005564fe6c24ce <unavailable> + 5326

    5    libc.so.6                          0x00002b1198985460 __libc_start_main +
    245

    6    tmp7js61g5n                        0x00005564fe6c2089 <unavailable> + 4233

    '
  stdout: ''
  timestamp: 1660013456
- exit_code: 1
  program: "\n/// Write a function that accepts an array of strings.\n/// The array\
    \ contains different words. Return the word with maximum number\n/// of unique\
    \ characters. If multiple strings have maximum number of unique\n/// characters,\
    \ return the one which comes first in lexicographical order.\n/// >>> find_max(words:\
    \ [\"name\", \"of\", \"string\"])\n/// \"string\"\n/// >>> find_max(words: [\"\
    name\", \"enam\", \"game\"])\n/// \"enam\"\n/// >>> find_max(words: [\"aaaaaaa\"\
    , \"bb\", \"cc\"])\n/// \"aaaaaaa\"\nfunc find_max(words: [String]) -> String\
    \ {\n    \n    let results = words.map({\n        $0.countUniqueCharacters()\n\
    \    })\n    \n    let maxResult = results.max()\n    \n    let index = results.firstIndex(of:\
    \ maxResult!)\n    \n    return words[index!]\n}\n\n\nfunc ==(left: [(Int, Int)],\
    \ right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n       \
    \ return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r\
    \ {\n            return false\n        }\n    }\n    return true\n}\n        \
    \    \nassert(find_max(words: [\"name\", \"of\", \"string\"]) == \"string\")\n\
    assert(find_max(words: [\"name\", \"enam\", \"game\"]) == \"enam\")\nassert(find_max(words:\
    \ [\"aaaaaaa\", \"bb\", \"cc\"]) == \"aaaaaaa\")\nassert(find_max(words: [\"abc\"\
    , \"cba\"]) == \"abc\")\nassert(find_max(words: [\"play\", \"this\", \"game\"\
    , \"of\", \"footbott\"]) == \"footbott\")\nassert(find_max(words: [\"we\", \"\
    are\", \"gonna\", \"rock\"]) == \"gonna\")\nassert(find_max(words: [\"we\", \"\
    are\", \"a\", \"mad\", \"nation\"]) == \"nation\")\nassert(find_max(words: [\"\
    this\", \"is\", \"a\", \"prrk\"]) == \"this\")\nassert(find_max(words: [\"b\"\
    ]) == \"b\")\nassert(find_max(words: [\"play\", \"play\", \"play\"]) == \"play\"\
    )"
  status: SyntaxError
  stderr: "/tmp/tmpwjcj2syv.swift:15:12: error: value of type 'String' has no member\
    \ 'countUniqueCharacters'\n        $0.countUniqueCharacters()\n        ~~ ^~~~~~~~~~~~~~~~~~~~~\n"
  stdout: ''
  timestamp: 1660013456
- exit_code: -4
  program: "\n/// Write a function that accepts an array of strings.\n/// The array\
    \ contains different words. Return the word with maximum number\n/// of unique\
    \ characters. If multiple strings have maximum number of unique\n/// characters,\
    \ return the one which comes first in lexicographical order.\n/// >>> find_max(words:\
    \ [\"name\", \"of\", \"string\"])\n/// \"string\"\n/// >>> find_max(words: [\"\
    name\", \"enam\", \"game\"])\n/// \"enam\"\n/// >>> find_max(words: [\"aaaaaaa\"\
    , \"bb\", \"cc\"])\n/// \"aaaaaaa\"\nfunc find_max(words: [String]) -> String\
    \ {\n    \n    var wordCountDict = [String: [Character]]()\n    var maxCount =\
    \ 0\n    var maxWord = \"\"\n    \n    // create a hashmap of word and character\
    \ count\n    for word in words {\n        wordCountDict[word] = []\n        for\
    \ char in word {\n            wordCountDict[word]?.append(char)\n        }\n \
    \   }\n    \n    // create another hashmap of word and count of unique characters\n\
    \    var wordUniqCountDict = [String: Int]()\n    for (word, charCountArray) in\
    \ wordCountDict {\n        wordUniqCountDict[word] = charCountArray.count\n  \
    \  }\n    \n    // find the word with max count of unique characters\n    for\
    \ (word, charCount) in wordUniqCountDict {\n        if charCount > maxCount {\n\
    \            maxCount = charCount\n            maxWord = word\n        }\n   \
    \ }\n    \n    return maxWord\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int,\
    \ Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n\
    \    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n          \
    \  return false\n        }\n    }\n    return true\n}\n            \nassert(find_max(words:\
    \ [\"name\", \"of\", \"string\"]) == \"string\")\nassert(find_max(words: [\"name\"\
    , \"enam\", \"game\"]) == \"enam\")\nassert(find_max(words: [\"aaaaaaa\", \"bb\"\
    , \"cc\"]) == \"aaaaaaa\")\nassert(find_max(words: [\"abc\", \"cba\"]) == \"abc\"\
    )\nassert(find_max(words: [\"play\", \"this\", \"game\", \"of\", \"footbott\"\
    ]) == \"footbott\")\nassert(find_max(words: [\"we\", \"are\", \"gonna\", \"rock\"\
    ]) == \"gonna\")\nassert(find_max(words: [\"we\", \"are\", \"a\", \"mad\", \"\
    nation\"]) == \"nation\")\nassert(find_max(words: [\"this\", \"is\", \"a\", \"\
    prrk\"]) == \"this\")\nassert(find_max(words: [\"b\"]) == \"b\")\nassert(find_max(words:\
    \ [\"play\", \"play\", \"play\"]) == \"play\")"
  status: Exception
  stderr: 'tmp0vvsp0vx/tmp0vvsp0vx.swift:57: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b4b68449c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b4b68140b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b4b68140988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b4b6813f7b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmp0vvsp0vx                        0x000056058671cc13 <unavailable> + 7187

    5    libc.so.6                          0x00002b4b68635460 __libc_start_main +
    245

    6    tmp0vvsp0vx                        0x000056058671c639 <unavailable> + 5689

    '
  stdout: ''
  timestamp: 1660013457
- exit_code: -4
  program: "\n/// Write a function that accepts an array of strings.\n/// The array\
    \ contains different words. Return the word with maximum number\n/// of unique\
    \ characters. If multiple strings have maximum number of unique\n/// characters,\
    \ return the one which comes first in lexicographical order.\n/// >>> find_max(words:\
    \ [\"name\", \"of\", \"string\"])\n/// \"string\"\n/// >>> find_max(words: [\"\
    name\", \"enam\", \"game\"])\n/// \"enam\"\n/// >>> find_max(words: [\"aaaaaaa\"\
    , \"bb\", \"cc\"])\n/// \"aaaaaaa\"\nfunc find_max(words: [String]) -> String\
    \ {\n    var max = 0\n    var max_string = \"\"\n    for i in words {\n      \
    \  let set = Set(i)\n        if set.count > max {\n            max = set.count\n\
    \            max_string = i\n        }\n    }\n    return max_string\n}\n\n\n\
    func ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(find_max(words: [\"name\", \"of\", \"string\"\
    ]) == \"string\")\nassert(find_max(words: [\"name\", \"enam\", \"game\"]) == \"\
    enam\")\nassert(find_max(words: [\"aaaaaaa\", \"bb\", \"cc\"]) == \"aaaaaaa\"\
    )\nassert(find_max(words: [\"abc\", \"cba\"]) == \"abc\")\nassert(find_max(words:\
    \ [\"play\", \"this\", \"game\", \"of\", \"footbott\"]) == \"footbott\")\nassert(find_max(words:\
    \ [\"we\", \"are\", \"gonna\", \"rock\"]) == \"gonna\")\nassert(find_max(words:\
    \ [\"we\", \"are\", \"a\", \"mad\", \"nation\"]) == \"nation\")\nassert(find_max(words:\
    \ [\"this\", \"is\", \"a\", \"prrk\"]) == \"this\")\nassert(find_max(words: [\"\
    b\"]) == \"b\")\nassert(find_max(words: [\"play\", \"play\", \"play\"]) == \"\
    play\")"
  status: Exception
  stderr: 'tmpekga62ca/tmpekga62ca.swift:39: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b2486256c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b2485f4db6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b2485f4d988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b2485f4c7b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpekga62ca                        0x0000559fb4332933 <unavailable> + 6451

    5    libc.so.6                          0x00002b2486442460 __libc_start_main +
    245

    6    tmpekga62ca                        0x0000559fb4332359 <unavailable> + 4953

    '
  stdout: ''
  timestamp: 1660013457
- exit_code: -4
  program: "\n/// Write a function that accepts an array of strings.\n/// The array\
    \ contains different words. Return the word with maximum number\n/// of unique\
    \ characters. If multiple strings have maximum number of unique\n/// characters,\
    \ return the one which comes first in lexicographical order.\n/// >>> find_max(words:\
    \ [\"name\", \"of\", \"string\"])\n/// \"string\"\n/// >>> find_max(words: [\"\
    name\", \"enam\", \"game\"])\n/// \"enam\"\n/// >>> find_max(words: [\"aaaaaaa\"\
    , \"bb\", \"cc\"])\n/// \"aaaaaaa\"\nfunc find_max(words: [String]) -> String\
    \ {\n    var max = (word: \"\", count: 0)\n    for word in words {\n        let\
    \ set = Set(word)\n        if set.count > max.count {\n            max = (word,\
    \ set.count)\n        }\n    }\n    return max.word\n}\n\n\nfunc ==(left: [(Int,\
    \ Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n\
    \        return false\n    }\n    for (l, r) in zip(left, right) {\n        if\
    \ l != r {\n            return false\n        }\n    }\n    return true\n}\n \
    \           \nassert(find_max(words: [\"name\", \"of\", \"string\"]) == \"string\"\
    )\nassert(find_max(words: [\"name\", \"enam\", \"game\"]) == \"enam\")\nassert(find_max(words:\
    \ [\"aaaaaaa\", \"bb\", \"cc\"]) == \"aaaaaaa\")\nassert(find_max(words: [\"abc\"\
    , \"cba\"]) == \"abc\")\nassert(find_max(words: [\"play\", \"this\", \"game\"\
    , \"of\", \"footbott\"]) == \"footbott\")\nassert(find_max(words: [\"we\", \"\
    are\", \"gonna\", \"rock\"]) == \"gonna\")\nassert(find_max(words: [\"we\", \"\
    are\", \"a\", \"mad\", \"nation\"]) == \"nation\")\nassert(find_max(words: [\"\
    this\", \"is\", \"a\", \"prrk\"]) == \"this\")\nassert(find_max(words: [\"b\"\
    ]) == \"b\")\nassert(find_max(words: [\"play\", \"play\", \"play\"]) == \"play\"\
    )"
  status: Exception
  stderr: 'tmpdmaxxjb_/tmpdmaxxjb_.swift:37: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b8447247c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b8446f3eb6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b8446f3e988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b8446f3d7b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpdmaxxjb_                        0x000056336e459933 <unavailable> + 6451

    5    libc.so.6                          0x00002b8447433460 __libc_start_main +
    245

    6    tmpdmaxxjb_                        0x000056336e459359 <unavailable> + 4953

    '
  stdout: ''
  timestamp: 1660013457
- exit_code: 1
  program: "\n/// Write a function that accepts an array of strings.\n/// The array\
    \ contains different words. Return the word with maximum number\n/// of unique\
    \ characters. If multiple strings have maximum number of unique\n/// characters,\
    \ return the one which comes first in lexicographical order.\n/// >>> find_max(words:\
    \ [\"name\", \"of\", \"string\"])\n/// \"string\"\n/// >>> find_max(words: [\"\
    name\", \"enam\", \"game\"])\n/// \"enam\"\n/// >>> find_max(words: [\"aaaaaaa\"\
    , \"bb\", \"cc\"])\n/// \"aaaaaaa\"\nfunc find_max(words: [String]) -> String\
    \ {\n  var maxLength: Int = 0\n  var maxWord: String = \"\"\n  var maxIndex: Int\
    \ = 0\n  var index: Int = 0\n  for word in words {\n    if uniqueCharsInString(str:\
    \ word).count > maxLength {\n      maxLength = uniqueCharsInString(str: word).count\n\
    \      maxWord = word\n      maxIndex = index\n    }\n    index += 1\n  }\n  return\
    \ words[maxIndex]\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) ->\
    \ Bool {\n    if left.count != right.count {\n        return false\n    }\n  \
    \  for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(find_max(words: [\"\
    name\", \"of\", \"string\"]) == \"string\")\nassert(find_max(words: [\"name\"\
    , \"enam\", \"game\"]) == \"enam\")\nassert(find_max(words: [\"aaaaaaa\", \"bb\"\
    , \"cc\"]) == \"aaaaaaa\")\nassert(find_max(words: [\"abc\", \"cba\"]) == \"abc\"\
    )\nassert(find_max(words: [\"play\", \"this\", \"game\", \"of\", \"footbott\"\
    ]) == \"footbott\")\nassert(find_max(words: [\"we\", \"are\", \"gonna\", \"rock\"\
    ]) == \"gonna\")\nassert(find_max(words: [\"we\", \"are\", \"a\", \"mad\", \"\
    nation\"]) == \"nation\")\nassert(find_max(words: [\"this\", \"is\", \"a\", \"\
    prrk\"]) == \"this\")\nassert(find_max(words: [\"b\"]) == \"b\")\nassert(find_max(words:\
    \ [\"play\", \"play\", \"play\"]) == \"play\")"
  status: SyntaxError
  stderr: "/tmp/tmpydwdf9n_.swift:18:8: error: cannot find 'uniqueCharsInString' in\
    \ scope\n    if uniqueCharsInString(str: word).count > maxLength {\n       ^~~~~~~~~~~~~~~~~~~\n\
    /tmp/tmpydwdf9n_.swift:19:19: error: cannot find 'uniqueCharsInString' in scope\n\
    \      maxLength = uniqueCharsInString(str: word).count\n                  ^~~~~~~~~~~~~~~~~~~\n"
  stdout: ''
  timestamp: 1660013456
- exit_code: -4
  program: "\n/// Write a function that accepts an array of strings.\n/// The array\
    \ contains different words. Return the word with maximum number\n/// of unique\
    \ characters. If multiple strings have maximum number of unique\n/// characters,\
    \ return the one which comes first in lexicographical order.\n/// >>> find_max(words:\
    \ [\"name\", \"of\", \"string\"])\n/// \"string\"\n/// >>> find_max(words: [\"\
    name\", \"enam\", \"game\"])\n/// \"enam\"\n/// >>> find_max(words: [\"aaaaaaa\"\
    , \"bb\", \"cc\"])\n/// \"aaaaaaa\"\nfunc find_max(words: [String]) -> String\
    \ {\n    var maxWord = words[0]\n    var maxChars = Set<Character>()\n    for\
    \ word in words {\n        let chars = Set(word)\n        if chars.count > maxChars.count\
    \ {\n            maxChars = chars\n            maxWord = word\n        }\n   \
    \ }\n    return maxWord\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(find_max(words:\
    \ [\"name\", \"of\", \"string\"]) == \"string\")\nassert(find_max(words: [\"name\"\
    , \"enam\", \"game\"]) == \"enam\")\nassert(find_max(words: [\"aaaaaaa\", \"bb\"\
    , \"cc\"]) == \"aaaaaaa\")\nassert(find_max(words: [\"abc\", \"cba\"]) == \"abc\"\
    )\nassert(find_max(words: [\"play\", \"this\", \"game\", \"of\", \"footbott\"\
    ]) == \"footbott\")\nassert(find_max(words: [\"we\", \"are\", \"gonna\", \"rock\"\
    ]) == \"gonna\")\nassert(find_max(words: [\"we\", \"are\", \"a\", \"mad\", \"\
    nation\"]) == \"nation\")\nassert(find_max(words: [\"this\", \"is\", \"a\", \"\
    prrk\"]) == \"this\")\nassert(find_max(words: [\"b\"]) == \"b\")\nassert(find_max(words:\
    \ [\"play\", \"play\", \"play\"]) == \"play\")"
  status: Exception
  stderr: 'tmp5xi8gg43/tmp5xi8gg43.swift:39: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002af8ee048c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002af8edd3fb6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002af8edd3f988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002af8edd3e7b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmp5xi8gg43                        0x0000559a4fdf79d3 <unavailable> + 6611

    5    libc.so.6                          0x00002af8ee234460 __libc_start_main +
    245

    6    tmp5xi8gg43                        0x0000559a4fdf73f9 <unavailable> + 5113

    '
  stdout: ''
  timestamp: 1660013457
- exit_code: 1
  program: "\n/// Write a function that accepts an array of strings.\n/// The array\
    \ contains different words. Return the word with maximum number\n/// of unique\
    \ characters. If multiple strings have maximum number of unique\n/// characters,\
    \ return the one which comes first in lexicographical order.\n/// >>> find_max(words:\
    \ [\"name\", \"of\", \"string\"])\n/// \"string\"\n/// >>> find_max(words: [\"\
    name\", \"enam\", \"game\"])\n/// \"enam\"\n/// >>> find_max(words: [\"aaaaaaa\"\
    , \"bb\", \"cc\"])\n/// \"aaaaaaa\"\nfunc find_max(words: [String]) -> String\
    \ {\n    guard words.count > 0 else { return \"\" }\n    var max_word = words[0]\n\
    \    var max_chars = chars(in: words[0])\n    for word in words {\n        let\
    \ curr_chars = chars(in: word)\n        if curr_chars.count > max_chars.count\
    \ {\n            max_chars = curr_chars\n            max_word = word\n       \
    \ } else if curr_chars.count == max_chars.count && word < max_word {\n       \
    \     max_chars = curr_chars\n            max_word = word\n        }\n    }\n\
    \    return max_word\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(find_max(words:\
    \ [\"name\", \"of\", \"string\"]) == \"string\")\nassert(find_max(words: [\"name\"\
    , \"enam\", \"game\"]) == \"enam\")\nassert(find_max(words: [\"aaaaaaa\", \"bb\"\
    , \"cc\"]) == \"aaaaaaa\")\nassert(find_max(words: [\"abc\", \"cba\"]) == \"abc\"\
    )\nassert(find_max(words: [\"play\", \"this\", \"game\", \"of\", \"footbott\"\
    ]) == \"footbott\")\nassert(find_max(words: [\"we\", \"are\", \"gonna\", \"rock\"\
    ]) == \"gonna\")\nassert(find_max(words: [\"we\", \"are\", \"a\", \"mad\", \"\
    nation\"]) == \"nation\")\nassert(find_max(words: [\"this\", \"is\", \"a\", \"\
    prrk\"]) == \"this\")\nassert(find_max(words: [\"b\"]) == \"b\")\nassert(find_max(words:\
    \ [\"play\", \"play\", \"play\"]) == \"play\")"
  status: SyntaxError
  stderr: "/tmp/tmpkuv_k80p.swift:15:21: error: cannot find 'chars' in scope\n   \
    \ var max_chars = chars(in: words[0])\n                    ^~~~~\n/tmp/tmpkuv_k80p.swift:17:26:\
    \ error: cannot find 'chars' in scope\n        let curr_chars = chars(in: word)\n\
    \                         ^~~~~\n"
  stdout: ''
  timestamp: 1660013457
- exit_code: 1
  program: "\n/// Write a function that accepts an array of strings.\n/// The array\
    \ contains different words. Return the word with maximum number\n/// of unique\
    \ characters. If multiple strings have maximum number of unique\n/// characters,\
    \ return the one which comes first in lexicographical order.\n/// >>> find_max(words:\
    \ [\"name\", \"of\", \"string\"])\n/// \"string\"\n/// >>> find_max(words: [\"\
    name\", \"enam\", \"game\"])\n/// \"enam\"\n/// >>> find_max(words: [\"aaaaaaa\"\
    , \"bb\", \"cc\"])\n/// \"aaaaaaa\"\nfunc find_max(words: [String]) -> String\
    \ {\n    guard let minWord = words.min(by: {$0.count < $1.count}) else {\n   \
    \     return \"\"\n    }\n    let sortedWords = words.sorted {$0.count > $1.count}\n\
    \    var result = minWord\n    for word in sortedWords {\n        if word.count\
    \ == result.count {\n            continue\n        }\n        if let index = word.firstIndex(of:\
    \ result.first!) {\n            result = word.substring(from: index)\n       \
    \ }\n    }\n    return result\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int,\
    \ Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n\
    \    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n          \
    \  return false\n        }\n    }\n    return true\n}\n            \nassert(find_max(words:\
    \ [\"name\", \"of\", \"string\"]) == \"string\")\nassert(find_max(words: [\"name\"\
    , \"enam\", \"game\"]) == \"enam\")\nassert(find_max(words: [\"aaaaaaa\", \"bb\"\
    , \"cc\"]) == \"aaaaaaa\")\nassert(find_max(words: [\"abc\", \"cba\"]) == \"abc\"\
    )\nassert(find_max(words: [\"play\", \"this\", \"game\", \"of\", \"footbott\"\
    ]) == \"footbott\")\nassert(find_max(words: [\"we\", \"are\", \"gonna\", \"rock\"\
    ]) == \"gonna\")\nassert(find_max(words: [\"we\", \"are\", \"a\", \"mad\", \"\
    nation\"]) == \"nation\")\nassert(find_max(words: [\"this\", \"is\", \"a\", \"\
    prrk\"]) == \"this\")\nassert(find_max(words: [\"b\"]) == \"b\")\nassert(find_max(words:\
    \ [\"play\", \"play\", \"play\"]) == \"play\")"
  status: SyntaxError
  stderr: "/tmp/tmpe4fvwu8n.swift:23:27: error: value of type 'String' has no member\
    \ 'substring'\n            result = word.substring(from: index)\n            \
    \         ~~~~ ^~~~~~~~~\n"
  stdout: ''
  timestamp: 1660013457
- exit_code: -4
  program: "\n/// Write a function that accepts an array of strings.\n/// The array\
    \ contains different words. Return the word with maximum number\n/// of unique\
    \ characters. If multiple strings have maximum number of unique\n/// characters,\
    \ return the one which comes first in lexicographical order.\n/// >>> find_max(words:\
    \ [\"name\", \"of\", \"string\"])\n/// \"string\"\n/// >>> find_max(words: [\"\
    name\", \"enam\", \"game\"])\n/// \"enam\"\n/// >>> find_max(words: [\"aaaaaaa\"\
    , \"bb\", \"cc\"])\n/// \"aaaaaaa\"\nfunc find_max(words: [String]) -> String\
    \ {\n    // your code here\n    var result = \"\"\n    var unique_chars = 0\n\
    \    var unique_char_counter = [String: Int]()\n    for word in words {\n    \
    \    unique_char_counter[word] = 0\n        for char in word {\n            if\
    \ !unique_char_counter.keys.contains(String(char)) {\n                unique_char_counter[word]!\
    \ += 1\n            }\n        }\n        if unique_char_counter[word]! > unique_chars\
    \ {\n            unique_chars = unique_char_counter[word]!\n            result\
    \ = word\n        }\n    }\n    return result\n}\n\n\nfunc ==(left: [(Int, Int)],\
    \ right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n       \
    \ return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r\
    \ {\n            return false\n        }\n    }\n    return true\n}\n        \
    \    \nassert(find_max(words: [\"name\", \"of\", \"string\"]) == \"string\")\n\
    assert(find_max(words: [\"name\", \"enam\", \"game\"]) == \"enam\")\nassert(find_max(words:\
    \ [\"aaaaaaa\", \"bb\", \"cc\"]) == \"aaaaaaa\")\nassert(find_max(words: [\"abc\"\
    , \"cba\"]) == \"abc\")\nassert(find_max(words: [\"play\", \"this\", \"game\"\
    , \"of\", \"footbott\"]) == \"footbott\")\nassert(find_max(words: [\"we\", \"\
    are\", \"gonna\", \"rock\"]) == \"gonna\")\nassert(find_max(words: [\"we\", \"\
    are\", \"a\", \"mad\", \"nation\"]) == \"nation\")\nassert(find_max(words: [\"\
    this\", \"is\", \"a\", \"prrk\"]) == \"this\")\nassert(find_max(words: [\"b\"\
    ]) == \"b\")\nassert(find_max(words: [\"play\", \"play\", \"play\"]) == \"play\"\
    )"
  status: Exception
  stderr: 'tmp1rb2ib4o/tmp1rb2ib4o.swift:46: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b9fddcd4c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b9fdd9cbb6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b9fdd9cb988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b9fdd9ca7b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmp1rb2ib4o                        0x000055a48b57cc63 <unavailable> + 7267

    5    libc.so.6                          0x00002b9fddec0460 __libc_start_main +
    245

    6    tmp1rb2ib4o                        0x000055a48b57c689 <unavailable> + 5769

    '
  stdout: ''
  timestamp: 1660013457
- exit_code: 1
  program: "\n/// Write a function that accepts an array of strings.\n/// The array\
    \ contains different words. Return the word with maximum number\n/// of unique\
    \ characters. If multiple strings have maximum number of unique\n/// characters,\
    \ return the one which comes first in lexicographical order.\n/// >>> find_max(words:\
    \ [\"name\", \"of\", \"string\"])\n/// \"string\"\n/// >>> find_max(words: [\"\
    name\", \"enam\", \"game\"])\n/// \"enam\"\n/// >>> find_max(words: [\"aaaaaaa\"\
    , \"bb\", \"cc\"])\n/// \"aaaaaaa\"\nfunc find_max(words: [String]) -> String\
    \ {\n    let charSet: NSMutableSet = NSMutableSet()\n    var maxLength = -1\n\
    \    var maxWord = \"\"\n    for word in words {\n        charSet.removeAllObjects()\n\
    \        for c in word.characters {\n            charSet.add(c)\n        }\n \
    \       if charSet.count > maxLength {\n            maxLength = charSet.count\n\
    \            maxWord = word\n        }\n    }\n    return maxWord\n}\n\n\nfunc\
    \ ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count !=\
    \ right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(find_max(words: [\"name\", \"of\", \"string\"\
    ]) == \"string\")\nassert(find_max(words: [\"name\", \"enam\", \"game\"]) == \"\
    enam\")\nassert(find_max(words: [\"aaaaaaa\", \"bb\", \"cc\"]) == \"aaaaaaa\"\
    )\nassert(find_max(words: [\"abc\", \"cba\"]) == \"abc\")\nassert(find_max(words:\
    \ [\"play\", \"this\", \"game\", \"of\", \"footbott\"]) == \"footbott\")\nassert(find_max(words:\
    \ [\"we\", \"are\", \"gonna\", \"rock\"]) == \"gonna\")\nassert(find_max(words:\
    \ [\"we\", \"are\", \"a\", \"mad\", \"nation\"]) == \"nation\")\nassert(find_max(words:\
    \ [\"this\", \"is\", \"a\", \"prrk\"]) == \"this\")\nassert(find_max(words: [\"\
    b\"]) == \"b\")\nassert(find_max(words: [\"play\", \"play\", \"play\"]) == \"\
    play\")"
  status: SyntaxError
  stderr: "/tmp/tmpxp7tlfxp.swift:13:18: error: cannot find type 'NSMutableSet' in\
    \ scope\n    let charSet: NSMutableSet = NSMutableSet()\n                 ^~~~~~~~~~~~\n\
    /tmp/tmpxp7tlfxp.swift:18:23: error: 'characters' is unavailable: Please use String\
    \ directly\n        for c in word.characters {\n                      ^~~~~~~~~~\n\
    Swift.String:5:16: note: 'characters' was obsoleted in Swift 5.0\n    public var\
    \ characters: String { get set }\n               ^\n"
  stdout: ''
  timestamp: 1660013457
- exit_code: -4
  program: "\n/// Write a function that accepts an array of strings.\n/// The array\
    \ contains different words. Return the word with maximum number\n/// of unique\
    \ characters. If multiple strings have maximum number of unique\n/// characters,\
    \ return the one which comes first in lexicographical order.\n/// >>> find_max(words:\
    \ [\"name\", \"of\", \"string\"])\n/// \"string\"\n/// >>> find_max(words: [\"\
    name\", \"enam\", \"game\"])\n/// \"enam\"\n/// >>> find_max(words: [\"aaaaaaa\"\
    , \"bb\", \"cc\"])\n/// \"aaaaaaa\"\nfunc find_max(words: [String]) -> String\
    \ {\n    // TODO: Write a function that accepts an array of strings\n    // The\
    \ array contains different words. Return the word with maximum number\n    //\
    \ of unique characters. If multiple strings have maximum number of unique\n  \
    \  // characters, return the one which comes first in lexicographical order.\n\
    \    // >>> find_max(words: [\"name\", \"of\", \"string\"])\n    // \"string\"\
    \n    // >>> find_max(words: [\"name\", \"enam\", \"game\"])\n    // \"enam\"\n\
    \    // >>> find_max(words: [\"aaaaaaa\", \"bb\", \"cc\"])\n    // \"aaaaaaa\"\
    \n    var retVal = \"\"\n    var maxCharCount = 0\n    for word in words {\n \
    \       let uniqueCharsCount = Set(word).count\n        if uniqueCharsCount >\
    \ maxCharCount {\n            maxCharCount = uniqueCharsCount\n            retVal\
    \ = word\n        }\n    }\n    return retVal\n}\n\n\nfunc ==(left: [(Int, Int)],\
    \ right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n       \
    \ return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r\
    \ {\n            return false\n        }\n    }\n    return true\n}\n        \
    \    \nassert(find_max(words: [\"name\", \"of\", \"string\"]) == \"string\")\n\
    assert(find_max(words: [\"name\", \"enam\", \"game\"]) == \"enam\")\nassert(find_max(words:\
    \ [\"aaaaaaa\", \"bb\", \"cc\"]) == \"aaaaaaa\")\nassert(find_max(words: [\"abc\"\
    , \"cba\"]) == \"abc\")\nassert(find_max(words: [\"play\", \"this\", \"game\"\
    , \"of\", \"footbott\"]) == \"footbott\")\nassert(find_max(words: [\"we\", \"\
    are\", \"gonna\", \"rock\"]) == \"gonna\")\nassert(find_max(words: [\"we\", \"\
    are\", \"a\", \"mad\", \"nation\"]) == \"nation\")\nassert(find_max(words: [\"\
    this\", \"is\", \"a\", \"prrk\"]) == \"this\")\nassert(find_max(words: [\"b\"\
    ]) == \"b\")\nassert(find_max(words: [\"play\", \"play\", \"play\"]) == \"play\"\
    )"
  status: Exception
  stderr: 'tmp8s556kpv/tmp8s556kpv.swift:49: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b1871d85c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b1871a7cb6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b1871a7c988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b1871a7b7b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmp8s556kpv                        0x0000555660c34933 <unavailable> + 6451

    5    libc.so.6                          0x00002b1871f71460 __libc_start_main +
    245

    6    tmp8s556kpv                        0x0000555660c34359 <unavailable> + 4953

    '
  stdout: ''
  timestamp: 1660013457
- exit_code: 1
  program: "\n/// Write a function that accepts an array of strings.\n/// The array\
    \ contains different words. Return the word with maximum number\n/// of unique\
    \ characters. If multiple strings have maximum number of unique\n/// characters,\
    \ return the one which comes first in lexicographical order.\n/// >>> find_max(words:\
    \ [\"name\", \"of\", \"string\"])\n/// \"string\"\n/// >>> find_max(words: [\"\
    name\", \"enam\", \"game\"])\n/// \"enam\"\n/// >>> find_max(words: [\"aaaaaaa\"\
    , \"bb\", \"cc\"])\n/// \"aaaaaaa\"\nfunc find_max(words: [String]) -> String\
    \ {\n    \n    if words.count == 0 {\n        return \"\"\n    }\n    \n    var\
    \ unique_cnt = [Int]()\n    var unique_char_cnt = 0\n    var max_word = \"\"\n\
    \    \n    for var str in words {\n        unique_char_cnt = 0\n        for char\
    \ in str.characters {\n            if !str.containsString(String(char)) {\n  \
    \              unique_char_cnt += 1\n            }\n        }\n        unique_cnt.append(unique_char_cnt)\n\
    \    }\n    \n    let max = unique_cnt.maxElement()\n    let index = unique_cnt.indexOf(max!)\n\
    \    max_word = words[index!]\n    \n    return max_word\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(find_max(words: [\"name\", \"of\", \"string\"]) == \"\
    string\")\nassert(find_max(words: [\"name\", \"enam\", \"game\"]) == \"enam\"\
    )\nassert(find_max(words: [\"aaaaaaa\", \"bb\", \"cc\"]) == \"aaaaaaa\")\nassert(find_max(words:\
    \ [\"abc\", \"cba\"]) == \"abc\")\nassert(find_max(words: [\"play\", \"this\"\
    , \"game\", \"of\", \"footbott\"]) == \"footbott\")\nassert(find_max(words: [\"\
    we\", \"are\", \"gonna\", \"rock\"]) == \"gonna\")\nassert(find_max(words: [\"\
    we\", \"are\", \"a\", \"mad\", \"nation\"]) == \"nation\")\nassert(find_max(words:\
    \ [\"this\", \"is\", \"a\", \"prrk\"]) == \"this\")\nassert(find_max(words: [\"\
    b\"]) == \"b\")\nassert(find_max(words: [\"play\", \"play\", \"play\"]) == \"\
    play\")"
  status: SyntaxError
  stderr: "/tmp/tmpr2c7n3qu.swift:24:25: error: 'characters' is unavailable: Please\
    \ use String directly\n        for char in str.characters {\n                \
    \        ^~~~~~~~~~\nSwift.String:5:16: note: 'characters' was obsoleted in Swift\
    \ 5.0\n    public var characters: String { get set }\n               ^\n/tmp/tmpr2c7n3qu.swift:25:21:\
    \ error: value of type 'String' has no member 'containsString'\n            if\
    \ !str.containsString(String(char)) {\n                ~~~ ^~~~~~~~~~~~~~\n/tmp/tmpr2c7n3qu.swift:32:26:\
    \ error: value of type '[Int]' has no member 'maxElement'\n    let max = unique_cnt.maxElement()\n\
    \              ~~~~~~~~~~ ^~~~~~~~~~\n/tmp/tmpr2c7n3qu.swift:33:28: error: value\
    \ of type '[Int]' has no member 'indexOf'\n    let index = unique_cnt.indexOf(max!)\n\
    \                ~~~~~~~~~~ ^~~~~~~\n"
  stdout: ''
  timestamp: 1660013457
- exit_code: -4
  program: "\n/// Write a function that accepts an array of strings.\n/// The array\
    \ contains different words. Return the word with maximum number\n/// of unique\
    \ characters. If multiple strings have maximum number of unique\n/// characters,\
    \ return the one which comes first in lexicographical order.\n/// >>> find_max(words:\
    \ [\"name\", \"of\", \"string\"])\n/// \"string\"\n/// >>> find_max(words: [\"\
    name\", \"enam\", \"game\"])\n/// \"enam\"\n/// >>> find_max(words: [\"aaaaaaa\"\
    , \"bb\", \"cc\"])\n/// \"aaaaaaa\"\nfunc find_max(words: [String]) -> String\
    \ {\n    var the_most = 0\n    var name = words[0]\n    for word in words {\n\
    \        let tmp = word.count\n        if tmp > the_most {\n            the_most\
    \ = tmp\n            name = word\n        }\n    }\n    return name\n}\n\n\nfunc\
    \ ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count !=\
    \ right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(find_max(words: [\"name\", \"of\", \"string\"\
    ]) == \"string\")\nassert(find_max(words: [\"name\", \"enam\", \"game\"]) == \"\
    enam\")\nassert(find_max(words: [\"aaaaaaa\", \"bb\", \"cc\"]) == \"aaaaaaa\"\
    )\nassert(find_max(words: [\"abc\", \"cba\"]) == \"abc\")\nassert(find_max(words:\
    \ [\"play\", \"this\", \"game\", \"of\", \"footbott\"]) == \"footbott\")\nassert(find_max(words:\
    \ [\"we\", \"are\", \"gonna\", \"rock\"]) == \"gonna\")\nassert(find_max(words:\
    \ [\"we\", \"are\", \"a\", \"mad\", \"nation\"]) == \"nation\")\nassert(find_max(words:\
    \ [\"this\", \"is\", \"a\", \"prrk\"]) == \"this\")\nassert(find_max(words: [\"\
    b\"]) == \"b\")\nassert(find_max(words: [\"play\", \"play\", \"play\"]) == \"\
    play\")"
  status: Exception
  stderr: 'tmpd862rc6z/tmpd862rc6z.swift:39: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b0c0aeb0c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b0c0aba7b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b0c0aba7988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b0c0aba67b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpd862rc6z                        0x000055fb85af5873 <unavailable> + 6259

    5    libc.so.6                          0x00002b0c0b09c460 __libc_start_main +
    245

    6    tmpd862rc6z                        0x000055fb85af5299 <unavailable> + 4761

    '
  stdout: ''
  timestamp: 1660013457
- exit_code: -4
  program: "\n/// Write a function that accepts an array of strings.\n/// The array\
    \ contains different words. Return the word with maximum number\n/// of unique\
    \ characters. If multiple strings have maximum number of unique\n/// characters,\
    \ return the one which comes first in lexicographical order.\n/// >>> find_max(words:\
    \ [\"name\", \"of\", \"string\"])\n/// \"string\"\n/// >>> find_max(words: [\"\
    name\", \"enam\", \"game\"])\n/// \"enam\"\n/// >>> find_max(words: [\"aaaaaaa\"\
    , \"bb\", \"cc\"])\n/// \"aaaaaaa\"\nfunc find_max(words: [String]) -> String\
    \ {\n    var ans = \"\"\n    var max_count = 0\n    for word in words {\n    \
    \    var map: [Character: Int] = [:]\n        for char in word {\n           \
    \ if map[char] == nil {\n                map[char] = 1\n            } else {\n\
    \                map[char]! += 1\n            }\n        }\n        if map.count\
    \ > max_count {\n            max_count = map.count\n            ans = word\n \
    \       }\n    }\n    return ans\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int,\
    \ Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n\
    \    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n          \
    \  return false\n        }\n    }\n    return true\n}\n            \nassert(find_max(words:\
    \ [\"name\", \"of\", \"string\"]) == \"string\")\nassert(find_max(words: [\"name\"\
    , \"enam\", \"game\"]) == \"enam\")\nassert(find_max(words: [\"aaaaaaa\", \"bb\"\
    , \"cc\"]) == \"aaaaaaa\")\nassert(find_max(words: [\"abc\", \"cba\"]) == \"abc\"\
    )\nassert(find_max(words: [\"play\", \"this\", \"game\", \"of\", \"footbott\"\
    ]) == \"footbott\")\nassert(find_max(words: [\"we\", \"are\", \"gonna\", \"rock\"\
    ]) == \"gonna\")\nassert(find_max(words: [\"we\", \"are\", \"a\", \"mad\", \"\
    nation\"]) == \"nation\")\nassert(find_max(words: [\"this\", \"is\", \"a\", \"\
    prrk\"]) == \"this\")\nassert(find_max(words: [\"b\"]) == \"b\")\nassert(find_max(words:\
    \ [\"play\", \"play\", \"play\"]) == \"play\")"
  status: Exception
  stderr: 'tmpa6vuesmv/tmpa6vuesmv.swift:46: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b68ea1e8c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b68e9edfb6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b68e9edf988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b68e9ede7b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpa6vuesmv                        0x00005634dae4fb33 <unavailable> + 6963

    5    libc.so.6                          0x00002b68ea3d4460 __libc_start_main +
    245

    6    tmpa6vuesmv                        0x00005634dae4f559 <unavailable> + 5465

    '
  stdout: ''
  timestamp: 1660013457
- exit_code: 1
  program: "\n/// Write a function that accepts an array of strings.\n/// The array\
    \ contains different words. Return the word with maximum number\n/// of unique\
    \ characters. If multiple strings have maximum number of unique\n/// characters,\
    \ return the one which comes first in lexicographical order.\n/// >>> find_max(words:\
    \ [\"name\", \"of\", \"string\"])\n/// \"string\"\n/// >>> find_max(words: [\"\
    name\", \"enam\", \"game\"])\n/// \"enam\"\n/// >>> find_max(words: [\"aaaaaaa\"\
    , \"bb\", \"cc\"])\n/// \"aaaaaaa\"\nfunc find_max(words: [String]) -> String\
    \ {\n    guard !words.isEmpty else {\n        return \"\"\n    }\n    guard words.count\
    \ > 1 else {\n        return words[0]\n    }\n    let wordsDict = words.map {($0,\
    \ $0.unique())}\n    let maxUnique = wordsDict.max {a, b in a.1.count < b.1.count}\n\
    \    let maxNumUnique = maxUnique?.1.count ?? 0\n    var maxWords = wordsDict.filter\
    \ {$0.1.count == maxNumUnique}\n    maxWords.sort {a, b in a.0 < b.0}\n    return\
    \ maxWords[0].0\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool\
    \ {\n    if left.count != right.count {\n        return false\n    }\n    for\
    \ (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(find_max(words: [\"\
    name\", \"of\", \"string\"]) == \"string\")\nassert(find_max(words: [\"name\"\
    , \"enam\", \"game\"]) == \"enam\")\nassert(find_max(words: [\"aaaaaaa\", \"bb\"\
    , \"cc\"]) == \"aaaaaaa\")\nassert(find_max(words: [\"abc\", \"cba\"]) == \"abc\"\
    )\nassert(find_max(words: [\"play\", \"this\", \"game\", \"of\", \"footbott\"\
    ]) == \"footbott\")\nassert(find_max(words: [\"we\", \"are\", \"gonna\", \"rock\"\
    ]) == \"gonna\")\nassert(find_max(words: [\"we\", \"are\", \"a\", \"mad\", \"\
    nation\"]) == \"nation\")\nassert(find_max(words: [\"this\", \"is\", \"a\", \"\
    prrk\"]) == \"this\")\nassert(find_max(words: [\"b\"]) == \"b\")\nassert(find_max(words:\
    \ [\"play\", \"play\", \"play\"]) == \"play\")"
  status: SyntaxError
  stderr: "/tmp/tmpj_515qk_.swift:19:40: error: value of type 'String' has no member\
    \ 'unique'\n    let wordsDict = words.map {($0, $0.unique())}\n              \
    \                      ~~ ^~~~~~\n"
  stdout: ''
  timestamp: 1660013457
- exit_code: 0
  program: "\n/// Write a function that accepts an array of strings.\n/// The array\
    \ contains different words. Return the word with maximum number\n/// of unique\
    \ characters. If multiple strings have maximum number of unique\n/// characters,\
    \ return the one which comes first in lexicographical order.\n/// >>> find_max(words:\
    \ [\"name\", \"of\", \"string\"])\n/// \"string\"\n/// >>> find_max(words: [\"\
    name\", \"enam\", \"game\"])\n/// \"enam\"\n/// >>> find_max(words: [\"aaaaaaa\"\
    , \"bb\", \"cc\"])\n/// \"aaaaaaa\"\nfunc find_max(words: [String]) -> String\
    \ {\n    var max_unique = Set<Character>()\n    var result = \"\"\n    for word\
    \ in words {\n        let unique = Set(word)\n        if unique.count > max_unique.count\
    \ {\n            max_unique = unique\n            result = word\n        } else\
    \ if unique.count == max_unique.count && word < result {\n            result =\
    \ word\n        }\n    }\n    return result\n}\n\n\nfunc ==(left: [(Int, Int)],\
    \ right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n       \
    \ return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r\
    \ {\n            return false\n        }\n    }\n    return true\n}\n        \
    \    \nassert(find_max(words: [\"name\", \"of\", \"string\"]) == \"string\")\n\
    assert(find_max(words: [\"name\", \"enam\", \"game\"]) == \"enam\")\nassert(find_max(words:\
    \ [\"aaaaaaa\", \"bb\", \"cc\"]) == \"aaaaaaa\")\nassert(find_max(words: [\"abc\"\
    , \"cba\"]) == \"abc\")\nassert(find_max(words: [\"play\", \"this\", \"game\"\
    , \"of\", \"footbott\"]) == \"footbott\")\nassert(find_max(words: [\"we\", \"\
    are\", \"gonna\", \"rock\"]) == \"gonna\")\nassert(find_max(words: [\"we\", \"\
    are\", \"a\", \"mad\", \"nation\"]) == \"nation\")\nassert(find_max(words: [\"\
    this\", \"is\", \"a\", \"prrk\"]) == \"this\")\nassert(find_max(words: [\"b\"\
    ]) == \"b\")\nassert(find_max(words: [\"play\", \"play\", \"play\"]) == \"play\"\
    )"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660013457
- exit_code: 1
  program: "\n/// Write a function that accepts an array of strings.\n/// The array\
    \ contains different words. Return the word with maximum number\n/// of unique\
    \ characters. If multiple strings have maximum number of unique\n/// characters,\
    \ return the one which comes first in lexicographical order.\n/// >>> find_max(words:\
    \ [\"name\", \"of\", \"string\"])\n/// \"string\"\n/// >>> find_max(words: [\"\
    name\", \"enam\", \"game\"])\n/// \"enam\"\n/// >>> find_max(words: [\"aaaaaaa\"\
    , \"bb\", \"cc\"])\n/// \"aaaaaaa\"\nfunc find_max(words: [String]) -> String\
    \ {\n    var maxUnique = 0\n    var maxWord = \"\"\n    for word in words {\n\
    \        let unique = find_unique(word: word)\n        if unique > maxUnique {\n\
    \            maxUnique = unique\n            maxWord = word\n        }\n    }\n\
    \    return maxWord\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) ->\
    \ Bool {\n    if left.count != right.count {\n        return false\n    }\n  \
    \  for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(find_max(words: [\"\
    name\", \"of\", \"string\"]) == \"string\")\nassert(find_max(words: [\"name\"\
    , \"enam\", \"game\"]) == \"enam\")\nassert(find_max(words: [\"aaaaaaa\", \"bb\"\
    , \"cc\"]) == \"aaaaaaa\")\nassert(find_max(words: [\"abc\", \"cba\"]) == \"abc\"\
    )\nassert(find_max(words: [\"play\", \"this\", \"game\", \"of\", \"footbott\"\
    ]) == \"footbott\")\nassert(find_max(words: [\"we\", \"are\", \"gonna\", \"rock\"\
    ]) == \"gonna\")\nassert(find_max(words: [\"we\", \"are\", \"a\", \"mad\", \"\
    nation\"]) == \"nation\")\nassert(find_max(words: [\"this\", \"is\", \"a\", \"\
    prrk\"]) == \"this\")\nassert(find_max(words: [\"b\"]) == \"b\")\nassert(find_max(words:\
    \ [\"play\", \"play\", \"play\"]) == \"play\")"
  status: SyntaxError
  stderr: "/tmp/tmp7kutddbi.swift:16:22: error: cannot find 'find_unique' in scope\n\
    \        let unique = find_unique(word: word)\n                     ^~~~~~~~~~~\n"
  stdout: ''
  timestamp: 1660013457
- exit_code: 1
  program: "\n/// Write a function that accepts an array of strings.\n/// The array\
    \ contains different words. Return the word with maximum number\n/// of unique\
    \ characters. If multiple strings have maximum number of unique\n/// characters,\
    \ return the one which comes first in lexicographical order.\n/// >>> find_max(words:\
    \ [\"name\", \"of\", \"string\"])\n/// \"string\"\n/// >>> find_max(words: [\"\
    name\", \"enam\", \"game\"])\n/// \"enam\"\n/// >>> find_max(words: [\"aaaaaaa\"\
    , \"bb\", \"cc\"])\n/// \"aaaaaaa\"\nfunc find_max(words: [String]) -> String\
    \ {\n    let words = words.map {\n        ($0, Set($0.characters).count)\n   \
    \ }\n    let max = words.max {\n        if $0.1 == $1.1 {\n            return\
    \ $0.0 < $1.0\n        }\n        return $0.1 < $1.1\n    }\n    return max!.0\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(find_max(words: [\"name\", \"of\", \"string\"\
    ]) == \"string\")\nassert(find_max(words: [\"name\", \"enam\", \"game\"]) == \"\
    enam\")\nassert(find_max(words: [\"aaaaaaa\", \"bb\", \"cc\"]) == \"aaaaaaa\"\
    )\nassert(find_max(words: [\"abc\", \"cba\"]) == \"abc\")\nassert(find_max(words:\
    \ [\"play\", \"this\", \"game\", \"of\", \"footbott\"]) == \"footbott\")\nassert(find_max(words:\
    \ [\"we\", \"are\", \"gonna\", \"rock\"]) == \"gonna\")\nassert(find_max(words:\
    \ [\"we\", \"are\", \"a\", \"mad\", \"nation\"]) == \"nation\")\nassert(find_max(words:\
    \ [\"this\", \"is\", \"a\", \"prrk\"]) == \"this\")\nassert(find_max(words: [\"\
    b\"]) == \"b\")\nassert(find_max(words: [\"play\", \"play\", \"play\"]) == \"\
    play\")"
  status: SyntaxError
  stderr: "/tmp/tmpave2z7bg.swift:14:21: error: 'characters' is unavailable: Please\
    \ use String directly\n        ($0, Set($0.characters).count)\n              \
    \      ^~~~~~~~~~\nSwift.String:5:16: note: 'characters' was obsoleted in Swift\
    \ 5.0\n    public var characters: String { get set }\n               ^\n"
  stdout: ''
  timestamp: 1660013457
- exit_code: -4
  program: "\n/// Write a function that accepts an array of strings.\n/// The array\
    \ contains different words. Return the word with maximum number\n/// of unique\
    \ characters. If multiple strings have maximum number of unique\n/// characters,\
    \ return the one which comes first in lexicographical order.\n/// >>> find_max(words:\
    \ [\"name\", \"of\", \"string\"])\n/// \"string\"\n/// >>> find_max(words: [\"\
    name\", \"enam\", \"game\"])\n/// \"enam\"\n/// >>> find_max(words: [\"aaaaaaa\"\
    , \"bb\", \"cc\"])\n/// \"aaaaaaa\"\nfunc find_max(words: [String]) -> String\
    \ {\n    var result = \"\"\n    var temp = 0\n    for i in words {\n        if\
    \ i.count > temp {\n            temp = i.count\n            result = i\n     \
    \   }\n    }\n    return result\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int,\
    \ Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n\
    \    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n          \
    \  return false\n        }\n    }\n    return true\n}\n            \nassert(find_max(words:\
    \ [\"name\", \"of\", \"string\"]) == \"string\")\nassert(find_max(words: [\"name\"\
    , \"enam\", \"game\"]) == \"enam\")\nassert(find_max(words: [\"aaaaaaa\", \"bb\"\
    , \"cc\"]) == \"aaaaaaa\")\nassert(find_max(words: [\"abc\", \"cba\"]) == \"abc\"\
    )\nassert(find_max(words: [\"play\", \"this\", \"game\", \"of\", \"footbott\"\
    ]) == \"footbott\")\nassert(find_max(words: [\"we\", \"are\", \"gonna\", \"rock\"\
    ]) == \"gonna\")\nassert(find_max(words: [\"we\", \"are\", \"a\", \"mad\", \"\
    nation\"]) == \"nation\")\nassert(find_max(words: [\"this\", \"is\", \"a\", \"\
    prrk\"]) == \"this\")\nassert(find_max(words: [\"b\"]) == \"b\")\nassert(find_max(words:\
    \ [\"play\", \"play\", \"play\"]) == \"play\")"
  status: Exception
  stderr: 'tmpe0x8es7g/tmpe0x8es7g.swift:38: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b1f937dac80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b1f934d1b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b1f934d1988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b1f934d07b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpe0x8es7g                        0x000055c4dcc53823 <unavailable> + 6179

    5    libc.so.6                          0x00002b1f939c6460 __libc_start_main +
    245

    6    tmpe0x8es7g                        0x000055c4dcc53249 <unavailable> + 4681

    '
  stdout: ''
  timestamp: 1660013457
- exit_code: 1
  program: "\n/// Write a function that accepts an array of strings.\n/// The array\
    \ contains different words. Return the word with maximum number\n/// of unique\
    \ characters. If multiple strings have maximum number of unique\n/// characters,\
    \ return the one which comes first in lexicographical order.\n/// >>> find_max(words:\
    \ [\"name\", \"of\", \"string\"])\n/// \"string\"\n/// >>> find_max(words: [\"\
    name\", \"enam\", \"game\"])\n/// \"enam\"\n/// >>> find_max(words: [\"aaaaaaa\"\
    , \"bb\", \"cc\"])\n/// \"aaaaaaa\"\nfunc find_max(words: [String]) -> String\
    \ {\n    var maxCount = 0\n    var maxWord = \"\"\n    for word in words {\n \
    \       let count = count_unique_characters(word: word)\n        if count > maxCount\
    \ {\n            maxCount = count\n            maxWord = word\n        } else\
    \ if count == maxCount && word < maxWord {\n            maxWord = word\n     \
    \   }\n    }\n    return maxWord\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int,\
    \ Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n\
    \    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n          \
    \  return false\n        }\n    }\n    return true\n}\n            \nassert(find_max(words:\
    \ [\"name\", \"of\", \"string\"]) == \"string\")\nassert(find_max(words: [\"name\"\
    , \"enam\", \"game\"]) == \"enam\")\nassert(find_max(words: [\"aaaaaaa\", \"bb\"\
    , \"cc\"]) == \"aaaaaaa\")\nassert(find_max(words: [\"abc\", \"cba\"]) == \"abc\"\
    )\nassert(find_max(words: [\"play\", \"this\", \"game\", \"of\", \"footbott\"\
    ]) == \"footbott\")\nassert(find_max(words: [\"we\", \"are\", \"gonna\", \"rock\"\
    ]) == \"gonna\")\nassert(find_max(words: [\"we\", \"are\", \"a\", \"mad\", \"\
    nation\"]) == \"nation\")\nassert(find_max(words: [\"this\", \"is\", \"a\", \"\
    prrk\"]) == \"this\")\nassert(find_max(words: [\"b\"]) == \"b\")\nassert(find_max(words:\
    \ [\"play\", \"play\", \"play\"]) == \"play\")"
  status: SyntaxError
  stderr: "/tmp/tmp8yfskngh.swift:16:21: error: cannot find 'count_unique_characters'\
    \ in scope\n        let count = count_unique_characters(word: word)\n        \
    \            ^~~~~~~~~~~~~~~~~~~~~~~\n"
  stdout: ''
  timestamp: 1660013457
- exit_code: -4
  program: "\n/// Write a function that accepts an array of strings.\n/// The array\
    \ contains different words. Return the word with maximum number\n/// of unique\
    \ characters. If multiple strings have maximum number of unique\n/// characters,\
    \ return the one which comes first in lexicographical order.\n/// >>> find_max(words:\
    \ [\"name\", \"of\", \"string\"])\n/// \"string\"\n/// >>> find_max(words: [\"\
    name\", \"enam\", \"game\"])\n/// \"enam\"\n/// >>> find_max(words: [\"aaaaaaa\"\
    , \"bb\", \"cc\"])\n/// \"aaaaaaa\"\nfunc find_max(words: [String]) -> String\
    \ {\n    var max = words[0]\n    for word in words {\n        if word.count <\
    \ max.count {\n            continue\n        } else if word.count > max.count\
    \ {\n            max = word\n        } else {\n            if word < max {\n \
    \               max = word\n            }\n        }\n    }\n    return max\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(find_max(words: [\"name\", \"of\", \"string\"\
    ]) == \"string\")\nassert(find_max(words: [\"name\", \"enam\", \"game\"]) == \"\
    enam\")\nassert(find_max(words: [\"aaaaaaa\", \"bb\", \"cc\"]) == \"aaaaaaa\"\
    )\nassert(find_max(words: [\"abc\", \"cba\"]) == \"abc\")\nassert(find_max(words:\
    \ [\"play\", \"this\", \"game\", \"of\", \"footbott\"]) == \"footbott\")\nassert(find_max(words:\
    \ [\"we\", \"are\", \"gonna\", \"rock\"]) == \"gonna\")\nassert(find_max(words:\
    \ [\"we\", \"are\", \"a\", \"mad\", \"nation\"]) == \"nation\")\nassert(find_max(words:\
    \ [\"this\", \"is\", \"a\", \"prrk\"]) == \"this\")\nassert(find_max(words: [\"\
    b\"]) == \"b\")\nassert(find_max(words: [\"play\", \"play\", \"play\"]) == \"\
    play\")"
  status: Exception
  stderr: 'tmpef2hi8nb/tmpef2hi8nb.swift:48: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b41182f8c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b4117fefb6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b4117fef988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b4117fee7b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpef2hi8nb                        0x000055b2d0de93de <unavailable> + 9182

    5    libc.so.6                          0x00002b41184e4460 __libc_start_main +
    245

    6    tmpef2hi8nb                        0x000055b2d0de82e9 <unavailable> + 4841

    '
  stdout: ''
  timestamp: 1660013457
- exit_code: 1
  program: "\n/// Write a function that accepts an array of strings.\n/// The array\
    \ contains different words. Return the word with maximum number\n/// of unique\
    \ characters. If multiple strings have maximum number of unique\n/// characters,\
    \ return the one which comes first in lexicographical order.\n/// >>> find_max(words:\
    \ [\"name\", \"of\", \"string\"])\n/// \"string\"\n/// >>> find_max(words: [\"\
    name\", \"enam\", \"game\"])\n/// \"enam\"\n/// >>> find_max(words: [\"aaaaaaa\"\
    , \"bb\", \"cc\"])\n/// \"aaaaaaa\"\nfunc find_max(words: [String]) -> String\
    \ {\n    var unique_char_count = words.map { $0.countUniqueChars() }\n    var\
    \ max = unique_char_count.max()\n    if let i = unique_char_count.firstIndex(of:\
    \ max!) {\n        return words[i]\n    }\n    return \"\"\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(find_max(words: [\"name\", \"of\", \"string\"]) == \"\
    string\")\nassert(find_max(words: [\"name\", \"enam\", \"game\"]) == \"enam\"\
    )\nassert(find_max(words: [\"aaaaaaa\", \"bb\", \"cc\"]) == \"aaaaaaa\")\nassert(find_max(words:\
    \ [\"abc\", \"cba\"]) == \"abc\")\nassert(find_max(words: [\"play\", \"this\"\
    , \"game\", \"of\", \"footbott\"]) == \"footbott\")\nassert(find_max(words: [\"\
    we\", \"are\", \"gonna\", \"rock\"]) == \"gonna\")\nassert(find_max(words: [\"\
    we\", \"are\", \"a\", \"mad\", \"nation\"]) == \"nation\")\nassert(find_max(words:\
    \ [\"this\", \"is\", \"a\", \"prrk\"]) == \"this\")\nassert(find_max(words: [\"\
    b\"]) == \"b\")\nassert(find_max(words: [\"play\", \"play\", \"play\"]) == \"\
    play\")"
  status: SyntaxError
  stderr: "/tmp/tmp1ubf35rk.swift:13:44: error: value of type 'String' has no member\
    \ 'countUniqueChars'\n    var unique_char_count = words.map { $0.countUniqueChars()\
    \ }\n                                        ~~ ^~~~~~~~~~~~~~~~\n"
  stdout: ''
  timestamp: 1660013457
- exit_code: -4
  program: "\n/// Write a function that accepts an array of strings.\n/// The array\
    \ contains different words. Return the word with maximum number\n/// of unique\
    \ characters. If multiple strings have maximum number of unique\n/// characters,\
    \ return the one which comes first in lexicographical order.\n/// >>> find_max(words:\
    \ [\"name\", \"of\", \"string\"])\n/// \"string\"\n/// >>> find_max(words: [\"\
    name\", \"enam\", \"game\"])\n/// \"enam\"\n/// >>> find_max(words: [\"aaaaaaa\"\
    , \"bb\", \"cc\"])\n/// \"aaaaaaa\"\nfunc find_max(words: [String]) -> String\
    \ {\n  var result = \"\"\n  var maximum = 0\n  for word in words {\n    if Set(word).count\
    \ > maximum {\n      maximum = Set(word).count\n      result = word\n    }\n \
    \ }\n  return result\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(find_max(words:\
    \ [\"name\", \"of\", \"string\"]) == \"string\")\nassert(find_max(words: [\"name\"\
    , \"enam\", \"game\"]) == \"enam\")\nassert(find_max(words: [\"aaaaaaa\", \"bb\"\
    , \"cc\"]) == \"aaaaaaa\")\nassert(find_max(words: [\"abc\", \"cba\"]) == \"abc\"\
    )\nassert(find_max(words: [\"play\", \"this\", \"game\", \"of\", \"footbott\"\
    ]) == \"footbott\")\nassert(find_max(words: [\"we\", \"are\", \"gonna\", \"rock\"\
    ]) == \"gonna\")\nassert(find_max(words: [\"we\", \"are\", \"a\", \"mad\", \"\
    nation\"]) == \"nation\")\nassert(find_max(words: [\"this\", \"is\", \"a\", \"\
    prrk\"]) == \"this\")\nassert(find_max(words: [\"b\"]) == \"b\")\nassert(find_max(words:\
    \ [\"play\", \"play\", \"play\"]) == \"play\")"
  status: Exception
  stderr: 'tmpw6d7t872/tmpw6d7t872.swift:38: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b38bd4d2c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b38bd1c9b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b38bd1c9988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b38bd1c87b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpw6d7t872                        0x00005603f7942933 <unavailable> + 6451

    5    libc.so.6                          0x00002b38bd6be460 __libc_start_main +
    245

    6    tmpw6d7t872                        0x00005603f7942359 <unavailable> + 4953

    '
  stdout: ''
  timestamp: 1660013457
- exit_code: 1
  program: "\n/// Write a function that accepts an array of strings.\n/// The array\
    \ contains different words. Return the word with maximum number\n/// of unique\
    \ characters. If multiple strings have maximum number of unique\n/// characters,\
    \ return the one which comes first in lexicographical order.\n/// >>> find_max(words:\
    \ [\"name\", \"of\", \"string\"])\n/// \"string\"\n/// >>> find_max(words: [\"\
    name\", \"enam\", \"game\"])\n/// \"enam\"\n/// >>> find_max(words: [\"aaaaaaa\"\
    , \"bb\", \"cc\"])\n/// \"aaaaaaa\"\nfunc find_max(words: [String]) -> String\
    \ {\n    // 1. \uC81C\uC77C \uAE34 \uAE00\uC790\uC218\uB97C \uAC00\uC9C4 \uAC83\
    \uC744 \uCC3E\uC544\uB0B8\uB2E4.\n    // 1-1. \uAE00\uC790\uC218\uB97C \uBE44\uAD50\
    \uD558\uB294 \uD568\uC218\uB97C \uB9CC\uB4E0\uB2E4.\n    // 1-2. \uBC30\uC5F4\uC744\
    \ \uAE00\uC790\uC218\uC5D0 \uB530\uB77C \uC815\uB82C\uD55C\uB2E4.\n    // 1-3.\
    \ \uAC00\uC7A5 \uAE34 \uAE00\uC790\uC218\uB97C \uCC3E\uC544\uB0B8\uB2E4.\n   \
    \ // 2. \uAC00\uC7A5 \uAE34 \uAE00\uC790\uC218\uB97C \uAC00\uC9C4 \uBB38\uC790\
    \uC5F4\uC744 \uCC3E\uC544\uB0B8\uB2E4.\n    // 2-1. \uAE00\uC790\uC218\uAC00 \uAC19\
    \uC740 \uBB38\uC790\uC5F4 \uC911\uC5D0\uC11C \uC720\uB2C8\uD06C\uD55C \uBB38\uC790\
    \uC218\uB97C \uAC00\uC9C4 \uBB38\uC790\uC5F4\uC744 \uCC3E\uC544\uB0B8\uB2E4.\n\
    \    // 2-2. \uC720\uB2C8\uD06C\uD55C \uBB38\uC790\uC218\uAC00 \uAC19\uC740 \uBB38\
    \uC790\uC5F4 \uC911\uC5D0\uC11C \uAC00\uC7A5 \uC55E\uC5D0 \uC788\uB294 \uBB38\uC790\
    \uC5F4\uC744 \uCC3E\uC544\uB0B8\uB2E4.\n    // 3. \uC815\uB2F5\uC744 \uBC18\uD658\
    \uD55C\uB2E4.\n    let sorted = words.sorted {\n        if $0.count == $1.count\
    \ {\n            return $0 < $1\n        }\n        return $0.count > $1.count\n\
    \    }\n\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n\
    \    if left.count != right.count {\n        return false\n    }\n    for (l,\
    \ r) in zip(left, right) {\n        if l != r {\n            return false\n  \
    \      }\n    }\n    return true\n}\n            \nassert(find_max(words: [\"\
    name\", \"of\", \"string\"]) == \"string\")\nassert(find_max(words: [\"name\"\
    , \"enam\", \"game\"]) == \"enam\")\nassert(find_max(words: [\"aaaaaaa\", \"bb\"\
    , \"cc\"]) == \"aaaaaaa\")\nassert(find_max(words: [\"abc\", \"cba\"]) == \"abc\"\
    )\nassert(find_max(words: [\"play\", \"this\", \"game\", \"of\", \"footbott\"\
    ]) == \"footbott\")\nassert(find_max(words: [\"we\", \"are\", \"gonna\", \"rock\"\
    ]) == \"gonna\")\nassert(find_max(words: [\"we\", \"are\", \"a\", \"mad\", \"\
    nation\"]) == \"nation\")\nassert(find_max(words: [\"this\", \"is\", \"a\", \"\
    prrk\"]) == \"this\")\nassert(find_max(words: [\"b\"]) == \"b\")\nassert(find_max(words:\
    \ [\"play\", \"play\", \"play\"]) == \"play\")"
  status: SyntaxError
  stderr: "/tmp/tmpgf8kac60.swift:21:9: warning: initialization of immutable value\
    \ 'sorted' was never used; consider replacing with assignment to '_' or removing\
    \ it\n    let sorted = words.sorted {\n    ~~~~^~~~~~\n    _\n/tmp/tmpgf8kac60.swift:28:1:\
    \ error: missing return in global function expected to return 'String'\n}\n^\n"
  stdout: ''
  timestamp: 1660013457
- exit_code: 1
  program: "\n/// Write a function that accepts an array of strings.\n/// The array\
    \ contains different words. Return the word with maximum number\n/// of unique\
    \ characters. If multiple strings have maximum number of unique\n/// characters,\
    \ return the one which comes first in lexicographical order.\n/// >>> find_max(words:\
    \ [\"name\", \"of\", \"string\"])\n/// \"string\"\n/// >>> find_max(words: [\"\
    name\", \"enam\", \"game\"])\n/// \"enam\"\n/// >>> find_max(words: [\"aaaaaaa\"\
    , \"bb\", \"cc\"])\n/// \"aaaaaaa\"\nfunc find_max(words: [String]) -> String\
    \ {\n    var unique_count = [String: Int]()\n    for word in words {\n       \
    \ unique_count[word] = unique_chars(word: word)\n    }\n    var max_value = 0\n\
    \    var max_word = \"\"\n    for (key, value) in unique_count {\n        if value\
    \ > max_value {\n            max_value = value\n            max_word = key\n \
    \       }\n    }\n    return max_word\n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(find_max(words: [\"name\", \"of\", \"string\"]) == \"string\")\nassert(find_max(words:\
    \ [\"name\", \"enam\", \"game\"]) == \"enam\")\nassert(find_max(words: [\"aaaaaaa\"\
    , \"bb\", \"cc\"]) == \"aaaaaaa\")\nassert(find_max(words: [\"abc\", \"cba\"])\
    \ == \"abc\")\nassert(find_max(words: [\"play\", \"this\", \"game\", \"of\", \"\
    footbott\"]) == \"footbott\")\nassert(find_max(words: [\"we\", \"are\", \"gonna\"\
    , \"rock\"]) == \"gonna\")\nassert(find_max(words: [\"we\", \"are\", \"a\", \"\
    mad\", \"nation\"]) == \"nation\")\nassert(find_max(words: [\"this\", \"is\",\
    \ \"a\", \"prrk\"]) == \"this\")\nassert(find_max(words: [\"b\"]) == \"b\")\n\
    assert(find_max(words: [\"play\", \"play\", \"play\"]) == \"play\")"
  status: SyntaxError
  stderr: "/tmp/tmpca0f_vr6.swift:15:30: error: cannot find 'unique_chars' in scope\n\
    \        unique_count[word] = unique_chars(word: word)\n                     \
    \        ^~~~~~~~~~~~\n"
  stdout: ''
  timestamp: 1660013457
- exit_code: 1
  program: "\n/// Write a function that accepts an array of strings.\n/// The array\
    \ contains different words. Return the word with maximum number\n/// of unique\
    \ characters. If multiple strings have maximum number of unique\n/// characters,\
    \ return the one which comes first in lexicographical order.\n/// >>> find_max(words:\
    \ [\"name\", \"of\", \"string\"])\n/// \"string\"\n/// >>> find_max(words: [\"\
    name\", \"enam\", \"game\"])\n/// \"enam\"\n/// >>> find_max(words: [\"aaaaaaa\"\
    , \"bb\", \"cc\"])\n/// \"aaaaaaa\"\nfunc find_max(words: [String]) -> String\
    \ {\n    return words.max { (a, b) -> Bool in\n        if a.characters.count >\
    \ b.characters.count {\n            return true\n        } else if a.characters.count\
    \ == b.characters.count {\n            return a < b\n        } else {\n      \
    \      return false\n        }\n    }!\n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(find_max(words: [\"name\", \"of\", \"string\"]) == \"string\")\nassert(find_max(words:\
    \ [\"name\", \"enam\", \"game\"]) == \"enam\")\nassert(find_max(words: [\"aaaaaaa\"\
    , \"bb\", \"cc\"]) == \"aaaaaaa\")\nassert(find_max(words: [\"abc\", \"cba\"])\
    \ == \"abc\")\nassert(find_max(words: [\"play\", \"this\", \"game\", \"of\", \"\
    footbott\"]) == \"footbott\")\nassert(find_max(words: [\"we\", \"are\", \"gonna\"\
    , \"rock\"]) == \"gonna\")\nassert(find_max(words: [\"we\", \"are\", \"a\", \"\
    mad\", \"nation\"]) == \"nation\")\nassert(find_max(words: [\"this\", \"is\",\
    \ \"a\", \"prrk\"]) == \"this\")\nassert(find_max(words: [\"b\"]) == \"b\")\n\
    assert(find_max(words: [\"play\", \"play\", \"play\"]) == \"play\")"
  status: SyntaxError
  stderr: "/tmp/tmpz7pxpppx.swift:14:14: error: 'characters' is unavailable: Please\
    \ use String directly\n        if a.characters.count > b.characters.count {\n\
    \             ^~~~~~~~~~\nSwift.String:5:16: note: 'characters' was obsoleted\
    \ in Swift 5.0\n    public var characters: String { get set }\n              \
    \ ^\n/tmp/tmpz7pxpppx.swift:14:35: error: 'characters' is unavailable: Please\
    \ use String directly\n        if a.characters.count > b.characters.count {\n\
    \                                  ^~~~~~~~~~\nSwift.String:5:16: note: 'characters'\
    \ was obsoleted in Swift 5.0\n    public var characters: String { get set }\n\
    \               ^\n/tmp/tmpz7pxpppx.swift:16:21: error: 'characters' is unavailable:\
    \ Please use String directly\n        } else if a.characters.count == b.characters.count\
    \ {\n                    ^~~~~~~~~~\nSwift.String:5:16: note: 'characters' was\
    \ obsoleted in Swift 5.0\n    public var characters: String { get set }\n    \
    \           ^\n/tmp/tmpz7pxpppx.swift:16:43: error: 'characters' is unavailable:\
    \ Please use String directly\n        } else if a.characters.count == b.characters.count\
    \ {\n                                          ^~~~~~~~~~\nSwift.String:5:16:\
    \ note: 'characters' was obsoleted in Swift 5.0\n    public var characters: String\
    \ { get set }\n               ^\n"
  stdout: ''
  timestamp: 1660013457
- exit_code: -4
  program: "\n/// Write a function that accepts an array of strings.\n/// The array\
    \ contains different words. Return the word with maximum number\n/// of unique\
    \ characters. If multiple strings have maximum number of unique\n/// characters,\
    \ return the one which comes first in lexicographical order.\n/// >>> find_max(words:\
    \ [\"name\", \"of\", \"string\"])\n/// \"string\"\n/// >>> find_max(words: [\"\
    name\", \"enam\", \"game\"])\n/// \"enam\"\n/// >>> find_max(words: [\"aaaaaaa\"\
    , \"bb\", \"cc\"])\n/// \"aaaaaaa\"\nfunc find_max(words: [String]) -> String\
    \ {\n    var word: String = \"\"\n    var wordLength: Int = 0\n    for w in words\
    \ {\n        if Set(w).count > wordLength {\n            word = w\n          \
    \  wordLength = Set(w).count\n        }\n    }\n    return word\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(find_max(words: [\"name\", \"of\", \"string\"]) == \"\
    string\")\nassert(find_max(words: [\"name\", \"enam\", \"game\"]) == \"enam\"\
    )\nassert(find_max(words: [\"aaaaaaa\", \"bb\", \"cc\"]) == \"aaaaaaa\")\nassert(find_max(words:\
    \ [\"abc\", \"cba\"]) == \"abc\")\nassert(find_max(words: [\"play\", \"this\"\
    , \"game\", \"of\", \"footbott\"]) == \"footbott\")\nassert(find_max(words: [\"\
    we\", \"are\", \"gonna\", \"rock\"]) == \"gonna\")\nassert(find_max(words: [\"\
    we\", \"are\", \"a\", \"mad\", \"nation\"]) == \"nation\")\nassert(find_max(words:\
    \ [\"this\", \"is\", \"a\", \"prrk\"]) == \"this\")\nassert(find_max(words: [\"\
    b\"]) == \"b\")\nassert(find_max(words: [\"play\", \"play\", \"play\"]) == \"\
    play\")"
  status: Exception
  stderr: 'tmpz9abo7ch/tmpz9abo7ch.swift:38: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002ae63b90dc80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002ae63b604b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002ae63b604988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002ae63b6037b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpz9abo7ch                        0x00005644cb8bc933 <unavailable> + 6451

    5    libc.so.6                          0x00002ae63baf9460 __libc_start_main +
    245

    6    tmpz9abo7ch                        0x00005644cb8bc359 <unavailable> + 4953

    '
  stdout: ''
  timestamp: 1660013457
- exit_code: -4
  program: "\n/// Write a function that accepts an array of strings.\n/// The array\
    \ contains different words. Return the word with maximum number\n/// of unique\
    \ characters. If multiple strings have maximum number of unique\n/// characters,\
    \ return the one which comes first in lexicographical order.\n/// >>> find_max(words:\
    \ [\"name\", \"of\", \"string\"])\n/// \"string\"\n/// >>> find_max(words: [\"\
    name\", \"enam\", \"game\"])\n/// \"enam\"\n/// >>> find_max(words: [\"aaaaaaa\"\
    , \"bb\", \"cc\"])\n/// \"aaaaaaa\"\nfunc find_max(words: [String]) -> String\
    \ {\n    var maxWord = \"\"\n    var maxCharCount = 0\n    for word in words {\n\
    \        let charCount = word.count\n        if charCount > maxCharCount {\n \
    \           maxCharCount = charCount\n            maxWord = word\n        }\n\
    \    }\n    return maxWord\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(find_max(words:\
    \ [\"name\", \"of\", \"string\"]) == \"string\")\nassert(find_max(words: [\"name\"\
    , \"enam\", \"game\"]) == \"enam\")\nassert(find_max(words: [\"aaaaaaa\", \"bb\"\
    , \"cc\"]) == \"aaaaaaa\")\nassert(find_max(words: [\"abc\", \"cba\"]) == \"abc\"\
    )\nassert(find_max(words: [\"play\", \"this\", \"game\", \"of\", \"footbott\"\
    ]) == \"footbott\")\nassert(find_max(words: [\"we\", \"are\", \"gonna\", \"rock\"\
    ]) == \"gonna\")\nassert(find_max(words: [\"we\", \"are\", \"a\", \"mad\", \"\
    nation\"]) == \"nation\")\nassert(find_max(words: [\"this\", \"is\", \"a\", \"\
    prrk\"]) == \"this\")\nassert(find_max(words: [\"b\"]) == \"b\")\nassert(find_max(words:\
    \ [\"play\", \"play\", \"play\"]) == \"play\")"
  status: Exception
  stderr: 'tmpg6oaluyp/tmpg6oaluyp.swift:39: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002ab0976bfc80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002ab0973b6b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002ab0973b6988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002ab0973b57b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpg6oaluyp                        0x0000560e07c54823 <unavailable> + 6179

    5    libc.so.6                          0x00002ab0978ab460 __libc_start_main +
    245

    6    tmpg6oaluyp                        0x0000560e07c54249 <unavailable> + 4681

    '
  stdout: ''
  timestamp: 1660013457
- exit_code: 1
  program: "\n/// Write a function that accepts an array of strings.\n/// The array\
    \ contains different words. Return the word with maximum number\n/// of unique\
    \ characters. If multiple strings have maximum number of unique\n/// characters,\
    \ return the one which comes first in lexicographical order.\n/// >>> find_max(words:\
    \ [\"name\", \"of\", \"string\"])\n/// \"string\"\n/// >>> find_max(words: [\"\
    name\", \"enam\", \"game\"])\n/// \"enam\"\n/// >>> find_max(words: [\"aaaaaaa\"\
    , \"bb\", \"cc\"])\n/// \"aaaaaaa\"\nfunc find_max(words: [String]) -> String\
    \ {\n    var result = words[0]\n    var maxCount = words[0].count_uniq\n    for\
    \ word in words {\n        if word.count_uniq > maxCount {\n            maxCount\
    \ = word.count_uniq\n            result = word\n        }\n    }\n    return result\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(find_max(words: [\"name\", \"of\", \"string\"\
    ]) == \"string\")\nassert(find_max(words: [\"name\", \"enam\", \"game\"]) == \"\
    enam\")\nassert(find_max(words: [\"aaaaaaa\", \"bb\", \"cc\"]) == \"aaaaaaa\"\
    )\nassert(find_max(words: [\"abc\", \"cba\"]) == \"abc\")\nassert(find_max(words:\
    \ [\"play\", \"this\", \"game\", \"of\", \"footbott\"]) == \"footbott\")\nassert(find_max(words:\
    \ [\"we\", \"are\", \"gonna\", \"rock\"]) == \"gonna\")\nassert(find_max(words:\
    \ [\"we\", \"are\", \"a\", \"mad\", \"nation\"]) == \"nation\")\nassert(find_max(words:\
    \ [\"this\", \"is\", \"a\", \"prrk\"]) == \"this\")\nassert(find_max(words: [\"\
    b\"]) == \"b\")\nassert(find_max(words: [\"play\", \"play\", \"play\"]) == \"\
    play\")"
  status: SyntaxError
  stderr: "/tmp/tmpynzgf71j.swift:14:29: error: value of type 'String' has no member\
    \ 'count_uniq'\n    var maxCount = words[0].count_uniq\n                   ~~~~~~~~\
    \ ^~~~~~~~~~\n/tmp/tmpynzgf71j.swift:16:17: error: value of type 'String' has\
    \ no member 'count_uniq'\n        if word.count_uniq > maxCount {\n          \
    \ ~~~~ ^~~~~~~~~~\n/tmp/tmpynzgf71j.swift:17:29: error: value of type 'String'\
    \ has no member 'count_uniq'\n            maxCount = word.count_uniq\n       \
    \                ~~~~ ^~~~~~~~~~\n"
  stdout: ''
  timestamp: 1660013457
- exit_code: 1
  program: "\n/// Write a function that accepts an array of strings.\n/// The array\
    \ contains different words. Return the word with maximum number\n/// of unique\
    \ characters. If multiple strings have maximum number of unique\n/// characters,\
    \ return the one which comes first in lexicographical order.\n/// >>> find_max(words:\
    \ [\"name\", \"of\", \"string\"])\n/// \"string\"\n/// >>> find_max(words: [\"\
    name\", \"enam\", \"game\"])\n/// \"enam\"\n/// >>> find_max(words: [\"aaaaaaa\"\
    , \"bb\", \"cc\"])\n/// \"aaaaaaa\"\nfunc find_max(words: [String]) -> String\
    \ {\n    var max = 0\n    var max_index = 0\n    for i in 0..<words.count {\n\
    \        if num_distinct_characters(word: words[i]) > max {\n            max =\
    \ num_distinct_characters(word: words[i])\n            max_index = i\n       \
    \ }\n    }\n    return words[max_index]\n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(find_max(words: [\"name\", \"of\", \"string\"]) == \"string\")\nassert(find_max(words:\
    \ [\"name\", \"enam\", \"game\"]) == \"enam\")\nassert(find_max(words: [\"aaaaaaa\"\
    , \"bb\", \"cc\"]) == \"aaaaaaa\")\nassert(find_max(words: [\"abc\", \"cba\"])\
    \ == \"abc\")\nassert(find_max(words: [\"play\", \"this\", \"game\", \"of\", \"\
    footbott\"]) == \"footbott\")\nassert(find_max(words: [\"we\", \"are\", \"gonna\"\
    , \"rock\"]) == \"gonna\")\nassert(find_max(words: [\"we\", \"are\", \"a\", \"\
    mad\", \"nation\"]) == \"nation\")\nassert(find_max(words: [\"this\", \"is\",\
    \ \"a\", \"prrk\"]) == \"this\")\nassert(find_max(words: [\"b\"]) == \"b\")\n\
    assert(find_max(words: [\"play\", \"play\", \"play\"]) == \"play\")"
  status: SyntaxError
  stderr: "/tmp/tmp45mp7j48.swift:16:12: error: cannot find 'num_distinct_characters'\
    \ in scope\n        if num_distinct_characters(word: words[i]) > max {\n     \
    \      ^~~~~~~~~~~~~~~~~~~~~~~\n/tmp/tmp45mp7j48.swift:17:19: error: cannot find\
    \ 'num_distinct_characters' in scope\n            max = num_distinct_characters(word:\
    \ words[i])\n                  ^~~~~~~~~~~~~~~~~~~~~~~\n"
  stdout: ''
  timestamp: 1660013457
- exit_code: 1
  program: "\n/// Write a function that accepts an array of strings.\n/// The array\
    \ contains different words. Return the word with maximum number\n/// of unique\
    \ characters. If multiple strings have maximum number of unique\n/// characters,\
    \ return the one which comes first in lexicographical order.\n/// >>> find_max(words:\
    \ [\"name\", \"of\", \"string\"])\n/// \"string\"\n/// >>> find_max(words: [\"\
    name\", \"enam\", \"game\"])\n/// \"enam\"\n/// >>> find_max(words: [\"aaaaaaa\"\
    , \"bb\", \"cc\"])\n/// \"aaaaaaa\"\nfunc find_max(words: [String]) -> String\
    \ {\n    let wordDict = words.reduce(into: [String: Int]()) { $0[$1] = $1.countUniqueCharacters()\
    \ }\n    let max = wordDict.values.max()\n    let maxWords = wordDict.filter {\
    \ $0.value == max }\n    return maxWords.keys.sorted().first!\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(find_max(words: [\"name\", \"of\", \"string\"]) == \"\
    string\")\nassert(find_max(words: [\"name\", \"enam\", \"game\"]) == \"enam\"\
    )\nassert(find_max(words: [\"aaaaaaa\", \"bb\", \"cc\"]) == \"aaaaaaa\")\nassert(find_max(words:\
    \ [\"abc\", \"cba\"]) == \"abc\")\nassert(find_max(words: [\"play\", \"this\"\
    , \"game\", \"of\", \"footbott\"]) == \"footbott\")\nassert(find_max(words: [\"\
    we\", \"are\", \"gonna\", \"rock\"]) == \"gonna\")\nassert(find_max(words: [\"\
    we\", \"are\", \"a\", \"mad\", \"nation\"]) == \"nation\")\nassert(find_max(words:\
    \ [\"this\", \"is\", \"a\", \"prrk\"]) == \"this\")\nassert(find_max(words: [\"\
    b\"]) == \"b\")\nassert(find_max(words: [\"play\", \"play\", \"play\"]) == \"\
    play\")"
  status: SyntaxError
  stderr: "/tmp/tmpnx62xrva.swift:13:70: error: value of type 'String' has no member\
    \ 'countUniqueCharacters'\n    let wordDict = words.reduce(into: [String: Int]())\
    \ { $0[$1] = $1.countUniqueCharacters() }\n                                  \
    \                                ~~ ^~~~~~~~~~~~~~~~~~~~~\n"
  stdout: ''
  timestamp: 1660013457
- exit_code: -4
  program: "\n/// Write a function that accepts an array of strings.\n/// The array\
    \ contains different words. Return the word with maximum number\n/// of unique\
    \ characters. If multiple strings have maximum number of unique\n/// characters,\
    \ return the one which comes first in lexicographical order.\n/// >>> find_max(words:\
    \ [\"name\", \"of\", \"string\"])\n/// \"string\"\n/// >>> find_max(words: [\"\
    name\", \"enam\", \"game\"])\n/// \"enam\"\n/// >>> find_max(words: [\"aaaaaaa\"\
    , \"bb\", \"cc\"])\n/// \"aaaaaaa\"\nfunc find_max(words: [String]) -> String\
    \ {\n    return \"\"\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(find_max(words:\
    \ [\"name\", \"of\", \"string\"]) == \"string\")\nassert(find_max(words: [\"name\"\
    , \"enam\", \"game\"]) == \"enam\")\nassert(find_max(words: [\"aaaaaaa\", \"bb\"\
    , \"cc\"]) == \"aaaaaaa\")\nassert(find_max(words: [\"abc\", \"cba\"]) == \"abc\"\
    )\nassert(find_max(words: [\"play\", \"this\", \"game\", \"of\", \"footbott\"\
    ]) == \"footbott\")\nassert(find_max(words: [\"we\", \"are\", \"gonna\", \"rock\"\
    ]) == \"gonna\")\nassert(find_max(words: [\"we\", \"are\", \"a\", \"mad\", \"\
    nation\"]) == \"nation\")\nassert(find_max(words: [\"this\", \"is\", \"a\", \"\
    prrk\"]) == \"this\")\nassert(find_max(words: [\"b\"]) == \"b\")\nassert(find_max(words:\
    \ [\"play\", \"play\", \"play\"]) == \"play\")"
  status: Exception
  stderr: 'tmp9vfthvyx/tmp9vfthvyx.swift:29: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b5bb598bc80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b5bb5682b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b5bb5682988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b5bb56817b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmp9vfthvyx                        0x0000564c87ea64ce <unavailable> + 5326

    5    libc.so.6                          0x00002b5bb5b77460 __libc_start_main +
    245

    6    tmp9vfthvyx                        0x0000564c87ea6089 <unavailable> + 4233

    '
  stdout: ''
  timestamp: 1660013265
- exit_code: -4
  program: "\n/// Write a function that accepts an array of strings.\n/// The array\
    \ contains different words. Return the word with maximum number\n/// of unique\
    \ characters. If multiple strings have maximum number of unique\n/// characters,\
    \ return the one which comes first in lexicographical order.\n/// >>> find_max(words:\
    \ [\"name\", \"of\", \"string\"])\n/// \"string\"\n/// >>> find_max(words: [\"\
    name\", \"enam\", \"game\"])\n/// \"enam\"\n/// >>> find_max(words: [\"aaaaaaa\"\
    , \"bb\", \"cc\"])\n/// \"aaaaaaa\"\nfunc find_max(words: [String]) -> String\
    \ {\n    var max_string = words[0]\n    var max_count = 0\n    for word in words\
    \ {\n        let set = Set(word)\n        if set.count > max_count {\n       \
    \     max_count = set.count\n            max_string = word\n        }\n    }\n\
    \    return max_string\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(find_max(words:\
    \ [\"name\", \"of\", \"string\"]) == \"string\")\nassert(find_max(words: [\"name\"\
    , \"enam\", \"game\"]) == \"enam\")\nassert(find_max(words: [\"aaaaaaa\", \"bb\"\
    , \"cc\"]) == \"aaaaaaa\")\nassert(find_max(words: [\"abc\", \"cba\"]) == \"abc\"\
    )\nassert(find_max(words: [\"play\", \"this\", \"game\", \"of\", \"footbott\"\
    ]) == \"footbott\")\nassert(find_max(words: [\"we\", \"are\", \"gonna\", \"rock\"\
    ]) == \"gonna\")\nassert(find_max(words: [\"we\", \"are\", \"a\", \"mad\", \"\
    nation\"]) == \"nation\")\nassert(find_max(words: [\"this\", \"is\", \"a\", \"\
    prrk\"]) == \"this\")\nassert(find_max(words: [\"b\"]) == \"b\")\nassert(find_max(words:\
    \ [\"play\", \"play\", \"play\"]) == \"play\")"
  status: Exception
  stderr: 'tmpugh56fz0/tmpugh56fz0.swift:39: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002ba09298ac80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002ba092681b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002ba092681988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002ba0926807b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpugh56fz0                        0x000056031951c993 <unavailable> + 6547

    5    libc.so.6                          0x00002ba092b76460 __libc_start_main +
    245

    6    tmpugh56fz0                        0x000056031951c3b9 <unavailable> + 5049

    '
  stdout: ''
  timestamp: 1660013457
- exit_code: -4
  program: "\n/// Write a function that accepts an array of strings.\n/// The array\
    \ contains different words. Return the word with maximum number\n/// of unique\
    \ characters. If multiple strings have maximum number of unique\n/// characters,\
    \ return the one which comes first in lexicographical order.\n/// >>> find_max(words:\
    \ [\"name\", \"of\", \"string\"])\n/// \"string\"\n/// >>> find_max(words: [\"\
    name\", \"enam\", \"game\"])\n/// \"enam\"\n/// >>> find_max(words: [\"aaaaaaa\"\
    , \"bb\", \"cc\"])\n/// \"aaaaaaa\"\nfunc find_max(words: [String]) -> String\
    \ {\n    var maxLength = 0\n    var result = \"\"\n    for word in words {\n \
    \       if Set(word).count > maxLength {\n            maxLength = Set(word).count\n\
    \            result = word\n        }\n    }\n    return result\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(find_max(words: [\"name\", \"of\", \"string\"]) == \"\
    string\")\nassert(find_max(words: [\"name\", \"enam\", \"game\"]) == \"enam\"\
    )\nassert(find_max(words: [\"aaaaaaa\", \"bb\", \"cc\"]) == \"aaaaaaa\")\nassert(find_max(words:\
    \ [\"abc\", \"cba\"]) == \"abc\")\nassert(find_max(words: [\"play\", \"this\"\
    , \"game\", \"of\", \"footbott\"]) == \"footbott\")\nassert(find_max(words: [\"\
    we\", \"are\", \"gonna\", \"rock\"]) == \"gonna\")\nassert(find_max(words: [\"\
    we\", \"are\", \"a\", \"mad\", \"nation\"]) == \"nation\")\nassert(find_max(words:\
    \ [\"this\", \"is\", \"a\", \"prrk\"]) == \"this\")\nassert(find_max(words: [\"\
    b\"]) == \"b\")\nassert(find_max(words: [\"play\", \"play\", \"play\"]) == \"\
    play\")"
  status: Exception
  stderr: 'tmpd1extqcd/tmpd1extqcd.swift:38: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002ad1b87a7c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002ad1b849eb6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002ad1b849e988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002ad1b849d7b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpd1extqcd                        0x0000564433705933 <unavailable> + 6451

    5    libc.so.6                          0x00002ad1b8993460 __libc_start_main +
    245

    6    tmpd1extqcd                        0x0000564433705359 <unavailable> + 4953

    '
  stdout: ''
  timestamp: 1660013457
- exit_code: 1
  program: "\n/// Write a function that accepts an array of strings.\n/// The array\
    \ contains different words. Return the word with maximum number\n/// of unique\
    \ characters. If multiple strings have maximum number of unique\n/// characters,\
    \ return the one which comes first in lexicographical order.\n/// >>> find_max(words:\
    \ [\"name\", \"of\", \"string\"])\n/// \"string\"\n/// >>> find_max(words: [\"\
    name\", \"enam\", \"game\"])\n/// \"enam\"\n/// >>> find_max(words: [\"aaaaaaa\"\
    , \"bb\", \"cc\"])\n/// \"aaaaaaa\"\nfunc find_max(words: [String]) -> String\
    \ {\n    return words.reduce(words[0]) { (a, b) in\n        if a.unique_characters.count\
    \ < b.unique_characters.count {\n            return b\n        } else if a.unique_characters.count\
    \ == b.unique_characters.count {\n            return a < b ? a : b\n        }\
    \ else {\n            return a\n        }\n    }\n}\n\n\nfunc ==(left: [(Int,\
    \ Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n\
    \        return false\n    }\n    for (l, r) in zip(left, right) {\n        if\
    \ l != r {\n            return false\n        }\n    }\n    return true\n}\n \
    \           \nassert(find_max(words: [\"name\", \"of\", \"string\"]) == \"string\"\
    )\nassert(find_max(words: [\"name\", \"enam\", \"game\"]) == \"enam\")\nassert(find_max(words:\
    \ [\"aaaaaaa\", \"bb\", \"cc\"]) == \"aaaaaaa\")\nassert(find_max(words: [\"abc\"\
    , \"cba\"]) == \"abc\")\nassert(find_max(words: [\"play\", \"this\", \"game\"\
    , \"of\", \"footbott\"]) == \"footbott\")\nassert(find_max(words: [\"we\", \"\
    are\", \"gonna\", \"rock\"]) == \"gonna\")\nassert(find_max(words: [\"we\", \"\
    are\", \"a\", \"mad\", \"nation\"]) == \"nation\")\nassert(find_max(words: [\"\
    this\", \"is\", \"a\", \"prrk\"]) == \"this\")\nassert(find_max(words: [\"b\"\
    ]) == \"b\")\nassert(find_max(words: [\"play\", \"play\", \"play\"]) == \"play\"\
    )"
  status: SyntaxError
  stderr: "/tmp/tmpq_btt8t9.swift:14:14: error: value of type 'String' has no member\
    \ 'unique_characters'\n        if a.unique_characters.count < b.unique_characters.count\
    \ {\n           ~ ^~~~~~~~~~~~~~~~~\n/tmp/tmpq_btt8t9.swift:14:42: error: value\
    \ of type 'String' has no member 'unique_characters'\n        if a.unique_characters.count\
    \ < b.unique_characters.count {\n                                       ~ ^~~~~~~~~~~~~~~~~\n"
  stdout: ''
  timestamp: 1660013457
- exit_code: -4
  program: "\n/// Write a function that accepts an array of strings.\n/// The array\
    \ contains different words. Return the word with maximum number\n/// of unique\
    \ characters. If multiple strings have maximum number of unique\n/// characters,\
    \ return the one which comes first in lexicographical order.\n/// >>> find_max(words:\
    \ [\"name\", \"of\", \"string\"])\n/// \"string\"\n/// >>> find_max(words: [\"\
    name\", \"enam\", \"game\"])\n/// \"enam\"\n/// >>> find_max(words: [\"aaaaaaa\"\
    , \"bb\", \"cc\"])\n/// \"aaaaaaa\"\nfunc find_max(words: [String]) -> String\
    \ {\n    var dict = [String:Int]()\n    var result = \"\"\n    for item in words\
    \ {\n        var set = Set<Character>()\n        for char in item {\n        \
    \    set.insert(char)\n        }\n        dict[item] = set.count\n    }\n    let\
    \ max = dict.values.max()\n    for item in dict where item.value == max {\n  \
    \      result = item.key\n        break\n    }\n    return result\n}\n\n\nfunc\
    \ ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count !=\
    \ right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(find_max(words: [\"name\", \"of\", \"string\"\
    ]) == \"string\")\nassert(find_max(words: [\"name\", \"enam\", \"game\"]) == \"\
    enam\")\nassert(find_max(words: [\"aaaaaaa\", \"bb\", \"cc\"]) == \"aaaaaaa\"\
    )\nassert(find_max(words: [\"abc\", \"cba\"]) == \"abc\")\nassert(find_max(words:\
    \ [\"play\", \"this\", \"game\", \"of\", \"footbott\"]) == \"footbott\")\nassert(find_max(words:\
    \ [\"we\", \"are\", \"gonna\", \"rock\"]) == \"gonna\")\nassert(find_max(words:\
    \ [\"we\", \"are\", \"a\", \"mad\", \"nation\"]) == \"nation\")\nassert(find_max(words:\
    \ [\"this\", \"is\", \"a\", \"prrk\"]) == \"this\")\nassert(find_max(words: [\"\
    b\"]) == \"b\")\nassert(find_max(words: [\"play\", \"play\", \"play\"]) == \"\
    play\")"
  status: Exception
  stderr: 'tmphwf1xspc/tmphwf1xspc.swift:44: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b7ffe88fc80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b7ffe586b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b7ffe586988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b7ffe5857b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmphwf1xspc                        0x000055ddcfdc6de3 <unavailable> + 7651

    5    libc.so.6                          0x00002b7ffea7b460 __libc_start_main +
    245

    6    tmphwf1xspc                        0x000055ddcfdc6809 <unavailable> + 6153

    '
  stdout: ''
  timestamp: 1660013457
- exit_code: 0
  program: "\n/// Write a function that accepts an array of strings.\n/// The array\
    \ contains different words. Return the word with maximum number\n/// of unique\
    \ characters. If multiple strings have maximum number of unique\n/// characters,\
    \ return the one which comes first in lexicographical order.\n/// >>> find_max(words:\
    \ [\"name\", \"of\", \"string\"])\n/// \"string\"\n/// >>> find_max(words: [\"\
    name\", \"enam\", \"game\"])\n/// \"enam\"\n/// >>> find_max(words: [\"aaaaaaa\"\
    , \"bb\", \"cc\"])\n/// \"aaaaaaa\"\nfunc find_max(words: [String]) -> String\
    \ {\n    var maxWord = words[0]\n    var maxSet = Set(words[0])\n    for word\
    \ in words[1..<words.count] {\n        let set = Set(word)\n        if set.count\
    \ > maxSet.count {\n            maxSet = set\n            maxWord = word\n   \
    \     } else if set.count == maxSet.count {\n            if word < maxWord {\n\
    \                maxWord = word\n            }\n        }\n    }\n    return maxWord\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(find_max(words: [\"name\", \"of\", \"string\"\
    ]) == \"string\")\nassert(find_max(words: [\"name\", \"enam\", \"game\"]) == \"\
    enam\")\nassert(find_max(words: [\"aaaaaaa\", \"bb\", \"cc\"]) == \"aaaaaaa\"\
    )\nassert(find_max(words: [\"abc\", \"cba\"]) == \"abc\")\nassert(find_max(words:\
    \ [\"play\", \"this\", \"game\", \"of\", \"footbott\"]) == \"footbott\")\nassert(find_max(words:\
    \ [\"we\", \"are\", \"gonna\", \"rock\"]) == \"gonna\")\nassert(find_max(words:\
    \ [\"we\", \"are\", \"a\", \"mad\", \"nation\"]) == \"nation\")\nassert(find_max(words:\
    \ [\"this\", \"is\", \"a\", \"prrk\"]) == \"this\")\nassert(find_max(words: [\"\
    b\"]) == \"b\")\nassert(find_max(words: [\"play\", \"play\", \"play\"]) == \"\
    play\")"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660013457
- exit_code: 0
  program: "\n/// Write a function that accepts an array of strings.\n/// The array\
    \ contains different words. Return the word with maximum number\n/// of unique\
    \ characters. If multiple strings have maximum number of unique\n/// characters,\
    \ return the one which comes first in lexicographical order.\n/// >>> find_max(words:\
    \ [\"name\", \"of\", \"string\"])\n/// \"string\"\n/// >>> find_max(words: [\"\
    name\", \"enam\", \"game\"])\n/// \"enam\"\n/// >>> find_max(words: [\"aaaaaaa\"\
    , \"bb\", \"cc\"])\n/// \"aaaaaaa\"\nfunc find_max(words: [String]) -> String\
    \ {\n    if words.count <= 0 {\n        return \"\"\n    }\n    var max_word =\
    \ words[0]\n    var max_len = max_word.count\n    var uniques = [Character]()\n\
    \    for i in max_word {\n        if !uniques.contains(i) {\n            uniques.append(i)\n\
    \        }\n    }\n    max_len = uniques.count\n    if words.count == 1 {\n  \
    \      return max_word\n    }\n    for i in 1..<words.count {\n        var uniques\
    \ = [Character]()\n        let word = words[i]\n        for j in word {\n    \
    \        if !uniques.contains(j) {\n                uniques.append(j)\n      \
    \      }\n        }\n        if uniques.count > max_len {\n            max_len\
    \ = uniques.count\n            max_word = word\n        } else if uniques.count\
    \ == max_len {\n            if word < max_word {\n                max_word = word\n\
    \            }\n        }\n    }\n    return max_word\n}\n\n\nfunc ==(left: [(Int,\
    \ Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n\
    \        return false\n    }\n    for (l, r) in zip(left, right) {\n        if\
    \ l != r {\n            return false\n        }\n    }\n    return true\n}\n \
    \           \nassert(find_max(words: [\"name\", \"of\", \"string\"]) == \"string\"\
    )\nassert(find_max(words: [\"name\", \"enam\", \"game\"]) == \"enam\")\nassert(find_max(words:\
    \ [\"aaaaaaa\", \"bb\", \"cc\"]) == \"aaaaaaa\")\nassert(find_max(words: [\"abc\"\
    , \"cba\"]) == \"abc\")\nassert(find_max(words: [\"play\", \"this\", \"game\"\
    , \"of\", \"footbott\"]) == \"footbott\")\nassert(find_max(words: [\"we\", \"\
    are\", \"gonna\", \"rock\"]) == \"gonna\")\nassert(find_max(words: [\"we\", \"\
    are\", \"a\", \"mad\", \"nation\"]) == \"nation\")\nassert(find_max(words: [\"\
    this\", \"is\", \"a\", \"prrk\"]) == \"this\")\nassert(find_max(words: [\"b\"\
    ]) == \"b\")\nassert(find_max(words: [\"play\", \"play\", \"play\"]) == \"play\"\
    )"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660013457
- exit_code: 1
  program: "\n/// Write a function that accepts an array of strings.\n/// The array\
    \ contains different words. Return the word with maximum number\n/// of unique\
    \ characters. If multiple strings have maximum number of unique\n/// characters,\
    \ return the one which comes first in lexicographical order.\n/// >>> find_max(words:\
    \ [\"name\", \"of\", \"string\"])\n/// \"string\"\n/// >>> find_max(words: [\"\
    name\", \"enam\", \"game\"])\n/// \"enam\"\n/// >>> find_max(words: [\"aaaaaaa\"\
    , \"bb\", \"cc\"])\n/// \"aaaaaaa\"\nfunc find_max(words: [String]) -> String\
    \ {\n    var longestWord = \"\"\n    var highestCharCount = 0\n    for word in\
    \ words {\n        let count = word.getUniqueChars().count\n        if count >\
    \ highestCharCount {\n            highestCharCount = count\n            longestWord\
    \ = word\n        }\n    }\n    return longestWord\n}\n\n\nfunc ==(left: [(Int,\
    \ Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n\
    \        return false\n    }\n    for (l, r) in zip(left, right) {\n        if\
    \ l != r {\n            return false\n        }\n    }\n    return true\n}\n \
    \           \nassert(find_max(words: [\"name\", \"of\", \"string\"]) == \"string\"\
    )\nassert(find_max(words: [\"name\", \"enam\", \"game\"]) == \"enam\")\nassert(find_max(words:\
    \ [\"aaaaaaa\", \"bb\", \"cc\"]) == \"aaaaaaa\")\nassert(find_max(words: [\"abc\"\
    , \"cba\"]) == \"abc\")\nassert(find_max(words: [\"play\", \"this\", \"game\"\
    , \"of\", \"footbott\"]) == \"footbott\")\nassert(find_max(words: [\"we\", \"\
    are\", \"gonna\", \"rock\"]) == \"gonna\")\nassert(find_max(words: [\"we\", \"\
    are\", \"a\", \"mad\", \"nation\"]) == \"nation\")\nassert(find_max(words: [\"\
    this\", \"is\", \"a\", \"prrk\"]) == \"this\")\nassert(find_max(words: [\"b\"\
    ]) == \"b\")\nassert(find_max(words: [\"play\", \"play\", \"play\"]) == \"play\"\
    )"
  status: SyntaxError
  stderr: "/tmp/tmpb2v_4yi3.swift:16:26: error: value of type 'String' has no member\
    \ 'getUniqueChars'\n        let count = word.getUniqueChars().count\n        \
    \            ~~~~ ^~~~~~~~~~~~~~\n"
  stdout: ''
  timestamp: 1660013457
- exit_code: -4
  program: "\n/// Write a function that accepts an array of strings.\n/// The array\
    \ contains different words. Return the word with maximum number\n/// of unique\
    \ characters. If multiple strings have maximum number of unique\n/// characters,\
    \ return the one which comes first in lexicographical order.\n/// >>> find_max(words:\
    \ [\"name\", \"of\", \"string\"])\n/// \"string\"\n/// >>> find_max(words: [\"\
    name\", \"enam\", \"game\"])\n/// \"enam\"\n/// >>> find_max(words: [\"aaaaaaa\"\
    , \"bb\", \"cc\"])\n/// \"aaaaaaa\"\nfunc find_max(words: [String]) -> String\
    \ {\n    var result = \"\"\n    var max = 0\n    for word in words {\n       \
    \ let uniqueChars = Set(word)\n        if uniqueChars.count > max {\n        \
    \    max = uniqueChars.count\n            result = word\n        }\n    }\n  \
    \  return result\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool\
    \ {\n    if left.count != right.count {\n        return false\n    }\n    for\
    \ (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(find_max(words: [\"\
    name\", \"of\", \"string\"]) == \"string\")\nassert(find_max(words: [\"name\"\
    , \"enam\", \"game\"]) == \"enam\")\nassert(find_max(words: [\"aaaaaaa\", \"bb\"\
    , \"cc\"]) == \"aaaaaaa\")\nassert(find_max(words: [\"abc\", \"cba\"]) == \"abc\"\
    )\nassert(find_max(words: [\"play\", \"this\", \"game\", \"of\", \"footbott\"\
    ]) == \"footbott\")\nassert(find_max(words: [\"we\", \"are\", \"gonna\", \"rock\"\
    ]) == \"gonna\")\nassert(find_max(words: [\"we\", \"are\", \"a\", \"mad\", \"\
    nation\"]) == \"nation\")\nassert(find_max(words: [\"this\", \"is\", \"a\", \"\
    prrk\"]) == \"this\")\nassert(find_max(words: [\"b\"]) == \"b\")\nassert(find_max(words:\
    \ [\"play\", \"play\", \"play\"]) == \"play\")"
  status: Exception
  stderr: 'tmpbyedtl8v/tmpbyedtl8v.swift:39: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b1cd0699c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b1cd0390b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b1cd0390988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b1cd038f7b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpbyedtl8v                        0x0000559ec9bc4933 <unavailable> + 6451

    5    libc.so.6                          0x00002b1cd0885460 __libc_start_main +
    245

    6    tmpbyedtl8v                        0x0000559ec9bc4359 <unavailable> + 4953

    '
  stdout: ''
  timestamp: 1660013457
- exit_code: -4
  program: "\n/// Write a function that accepts an array of strings.\n/// The array\
    \ contains different words. Return the word with maximum number\n/// of unique\
    \ characters. If multiple strings have maximum number of unique\n/// characters,\
    \ return the one which comes first in lexicographical order.\n/// >>> find_max(words:\
    \ [\"name\", \"of\", \"string\"])\n/// \"string\"\n/// >>> find_max(words: [\"\
    name\", \"enam\", \"game\"])\n/// \"enam\"\n/// >>> find_max(words: [\"aaaaaaa\"\
    , \"bb\", \"cc\"])\n/// \"aaaaaaa\"\nfunc find_max(words: [String]) -> String\
    \ {\n    var max_word = \"\"\n    var max_count = 0\n    for word in words {\n\
    \        let unique_chars = Set(word)\n        if unique_chars.count > max_count\
    \ {\n            max_count = unique_chars.count\n            max_word = word\n\
    \        }\n    }\n    return max_word\n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(find_max(words: [\"name\", \"of\", \"string\"]) == \"string\")\nassert(find_max(words:\
    \ [\"name\", \"enam\", \"game\"]) == \"enam\")\nassert(find_max(words: [\"aaaaaaa\"\
    , \"bb\", \"cc\"]) == \"aaaaaaa\")\nassert(find_max(words: [\"abc\", \"cba\"])\
    \ == \"abc\")\nassert(find_max(words: [\"play\", \"this\", \"game\", \"of\", \"\
    footbott\"]) == \"footbott\")\nassert(find_max(words: [\"we\", \"are\", \"gonna\"\
    , \"rock\"]) == \"gonna\")\nassert(find_max(words: [\"we\", \"are\", \"a\", \"\
    mad\", \"nation\"]) == \"nation\")\nassert(find_max(words: [\"this\", \"is\",\
    \ \"a\", \"prrk\"]) == \"this\")\nassert(find_max(words: [\"b\"]) == \"b\")\n\
    assert(find_max(words: [\"play\", \"play\", \"play\"]) == \"play\")"
  status: Exception
  stderr: 'tmpknchxw8u/tmpknchxw8u.swift:39: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002aebd4630c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002aebd4327b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002aebd4327988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002aebd43267b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpknchxw8u                        0x000055efe3240933 <unavailable> + 6451

    5    libc.so.6                          0x00002aebd481c460 __libc_start_main +
    245

    6    tmpknchxw8u                        0x000055efe3240359 <unavailable> + 4953

    '
  stdout: ''
  timestamp: 1660013265
- exit_code: -4
  program: "\n/// Write a function that accepts an array of strings.\n/// The array\
    \ contains different words. Return the word with maximum number\n/// of unique\
    \ characters. If multiple strings have maximum number of unique\n/// characters,\
    \ return the one which comes first in lexicographical order.\n/// >>> find_max(words:\
    \ [\"name\", \"of\", \"string\"])\n/// \"string\"\n/// >>> find_max(words: [\"\
    name\", \"enam\", \"game\"])\n/// \"enam\"\n/// >>> find_max(words: [\"aaaaaaa\"\
    , \"bb\", \"cc\"])\n/// \"aaaaaaa\"\nfunc find_max(words: [String]) -> String\
    \ {\n    return \"\"\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(find_max(words:\
    \ [\"name\", \"of\", \"string\"]) == \"string\")\nassert(find_max(words: [\"name\"\
    , \"enam\", \"game\"]) == \"enam\")\nassert(find_max(words: [\"aaaaaaa\", \"bb\"\
    , \"cc\"]) == \"aaaaaaa\")\nassert(find_max(words: [\"abc\", \"cba\"]) == \"abc\"\
    )\nassert(find_max(words: [\"play\", \"this\", \"game\", \"of\", \"footbott\"\
    ]) == \"footbott\")\nassert(find_max(words: [\"we\", \"are\", \"gonna\", \"rock\"\
    ]) == \"gonna\")\nassert(find_max(words: [\"we\", \"are\", \"a\", \"mad\", \"\
    nation\"]) == \"nation\")\nassert(find_max(words: [\"this\", \"is\", \"a\", \"\
    prrk\"]) == \"this\")\nassert(find_max(words: [\"b\"]) == \"b\")\nassert(find_max(words:\
    \ [\"play\", \"play\", \"play\"]) == \"play\")"
  status: Exception
  stderr: 'tmp9vfthvyx/tmp9vfthvyx.swift:29: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b5bb598bc80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b5bb5682b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b5bb5682988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b5bb56817b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmp9vfthvyx                        0x0000564c87ea64ce <unavailable> + 5326

    5    libc.so.6                          0x00002b5bb5b77460 __libc_start_main +
    245

    6    tmp9vfthvyx                        0x0000564c87ea6089 <unavailable> + 4233

    '
  stdout: ''
  timestamp: 1660013265
- exit_code: -4
  program: "\n/// Write a function that accepts an array of strings.\n/// The array\
    \ contains different words. Return the word with maximum number\n/// of unique\
    \ characters. If multiple strings have maximum number of unique\n/// characters,\
    \ return the one which comes first in lexicographical order.\n/// >>> find_max(words:\
    \ [\"name\", \"of\", \"string\"])\n/// \"string\"\n/// >>> find_max(words: [\"\
    name\", \"enam\", \"game\"])\n/// \"enam\"\n/// >>> find_max(words: [\"aaaaaaa\"\
    , \"bb\", \"cc\"])\n/// \"aaaaaaa\"\nfunc find_max(words: [String]) -> String\
    \ {\n    // TODO: Write implementation\n    return \"a\"\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(find_max(words: [\"name\", \"of\", \"string\"]) == \"\
    string\")\nassert(find_max(words: [\"name\", \"enam\", \"game\"]) == \"enam\"\
    )\nassert(find_max(words: [\"aaaaaaa\", \"bb\", \"cc\"]) == \"aaaaaaa\")\nassert(find_max(words:\
    \ [\"abc\", \"cba\"]) == \"abc\")\nassert(find_max(words: [\"play\", \"this\"\
    , \"game\", \"of\", \"footbott\"]) == \"footbott\")\nassert(find_max(words: [\"\
    we\", \"are\", \"gonna\", \"rock\"]) == \"gonna\")\nassert(find_max(words: [\"\
    we\", \"are\", \"a\", \"mad\", \"nation\"]) == \"nation\")\nassert(find_max(words:\
    \ [\"this\", \"is\", \"a\", \"prrk\"]) == \"this\")\nassert(find_max(words: [\"\
    b\"]) == \"b\")\nassert(find_max(words: [\"play\", \"play\", \"play\"]) == \"\
    play\")"
  status: Exception
  stderr: 'tmp8tzyps5t/tmp8tzyps5t.swift:30: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b2e7e6e3c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b2e7e3dab6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b2e7e3da988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b2e7e3d97b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmp8tzyps5t                        0x000055b19b3234ce <unavailable> + 5326

    5    libc.so.6                          0x00002b2e7e8cf460 __libc_start_main +
    245

    6    tmp8tzyps5t                        0x000055b19b323089 <unavailable> + 4233

    '
  stdout: ''
  timestamp: 1660013457
- exit_code: -4
  program: "\n/// Write a function that accepts an array of strings.\n/// The array\
    \ contains different words. Return the word with maximum number\n/// of unique\
    \ characters. If multiple strings have maximum number of unique\n/// characters,\
    \ return the one which comes first in lexicographical order.\n/// >>> find_max(words:\
    \ [\"name\", \"of\", \"string\"])\n/// \"string\"\n/// >>> find_max(words: [\"\
    name\", \"enam\", \"game\"])\n/// \"enam\"\n/// >>> find_max(words: [\"aaaaaaa\"\
    , \"bb\", \"cc\"])\n/// \"aaaaaaa\"\nfunc find_max(words: [String]) -> String\
    \ {\n    return \"\"\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(find_max(words:\
    \ [\"name\", \"of\", \"string\"]) == \"string\")\nassert(find_max(words: [\"name\"\
    , \"enam\", \"game\"]) == \"enam\")\nassert(find_max(words: [\"aaaaaaa\", \"bb\"\
    , \"cc\"]) == \"aaaaaaa\")\nassert(find_max(words: [\"abc\", \"cba\"]) == \"abc\"\
    )\nassert(find_max(words: [\"play\", \"this\", \"game\", \"of\", \"footbott\"\
    ]) == \"footbott\")\nassert(find_max(words: [\"we\", \"are\", \"gonna\", \"rock\"\
    ]) == \"gonna\")\nassert(find_max(words: [\"we\", \"are\", \"a\", \"mad\", \"\
    nation\"]) == \"nation\")\nassert(find_max(words: [\"this\", \"is\", \"a\", \"\
    prrk\"]) == \"this\")\nassert(find_max(words: [\"b\"]) == \"b\")\nassert(find_max(words:\
    \ [\"play\", \"play\", \"play\"]) == \"play\")"
  status: Exception
  stderr: 'tmp9vfthvyx/tmp9vfthvyx.swift:29: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b5bb598bc80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b5bb5682b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b5bb5682988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b5bb56817b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmp9vfthvyx                        0x0000564c87ea64ce <unavailable> + 5326

    5    libc.so.6                          0x00002b5bb5b77460 __libc_start_main +
    245

    6    tmp9vfthvyx                        0x0000564c87ea6089 <unavailable> + 4233

    '
  stdout: ''
  timestamp: 1660013265
- exit_code: -4
  program: "\n/// Write a function that accepts an array of strings.\n/// The array\
    \ contains different words. Return the word with maximum number\n/// of unique\
    \ characters. If multiple strings have maximum number of unique\n/// characters,\
    \ return the one which comes first in lexicographical order.\n/// >>> find_max(words:\
    \ [\"name\", \"of\", \"string\"])\n/// \"string\"\n/// >>> find_max(words: [\"\
    name\", \"enam\", \"game\"])\n/// \"enam\"\n/// >>> find_max(words: [\"aaaaaaa\"\
    , \"bb\", \"cc\"])\n/// \"aaaaaaa\"\nfunc find_max(words: [String]) -> String\
    \ {\n    \n    if words.count > 0 {\n        var max = words[0]\n        var max_count\
    \ = 0\n        var count = 0\n        for i in 0...words.count-1 {\n         \
    \   count = Set(words[i]).count\n            if count > max_count {\n        \
    \        max = words[i]\n                max_count = count\n            }\n  \
    \      }\n        return max\n    }\n    return \"\"\n}\n\n\nfunc ==(left: [(Int,\
    \ Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n\
    \        return false\n    }\n    for (l, r) in zip(left, right) {\n        if\
    \ l != r {\n            return false\n        }\n    }\n    return true\n}\n \
    \           \nassert(find_max(words: [\"name\", \"of\", \"string\"]) == \"string\"\
    )\nassert(find_max(words: [\"name\", \"enam\", \"game\"]) == \"enam\")\nassert(find_max(words:\
    \ [\"aaaaaaa\", \"bb\", \"cc\"]) == \"aaaaaaa\")\nassert(find_max(words: [\"abc\"\
    , \"cba\"]) == \"abc\")\nassert(find_max(words: [\"play\", \"this\", \"game\"\
    , \"of\", \"footbott\"]) == \"footbott\")\nassert(find_max(words: [\"we\", \"\
    are\", \"gonna\", \"rock\"]) == \"gonna\")\nassert(find_max(words: [\"we\", \"\
    are\", \"a\", \"mad\", \"nation\"]) == \"nation\")\nassert(find_max(words: [\"\
    this\", \"is\", \"a\", \"prrk\"]) == \"this\")\nassert(find_max(words: [\"b\"\
    ]) == \"b\")\nassert(find_max(words: [\"play\", \"play\", \"play\"]) == \"play\"\
    )"
  status: Exception
  stderr: 'tmpyngtsp82/tmpyngtsp82.swift:44: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b7bac08bc80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b7babd82b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b7babd82988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b7babd817b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpyngtsp82                        0x00005571722f8a03 <unavailable> + 6659

    5    libc.so.6                          0x00002b7bac277460 __libc_start_main +
    245

    6    tmpyngtsp82                        0x00005571722f8429 <unavailable> + 5161

    '
  stdout: ''
  timestamp: 1660013457
- exit_code: -4
  program: "\n/// Write a function that accepts an array of strings.\n/// The array\
    \ contains different words. Return the word with maximum number\n/// of unique\
    \ characters. If multiple strings have maximum number of unique\n/// characters,\
    \ return the one which comes first in lexicographical order.\n/// >>> find_max(words:\
    \ [\"name\", \"of\", \"string\"])\n/// \"string\"\n/// >>> find_max(words: [\"\
    name\", \"enam\", \"game\"])\n/// \"enam\"\n/// >>> find_max(words: [\"aaaaaaa\"\
    , \"bb\", \"cc\"])\n/// \"aaaaaaa\"\nfunc find_max(words: [String]) -> String\
    \ {\n    return words.max() ?? \"\"\n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(find_max(words: [\"name\", \"of\", \"string\"]) == \"string\")\nassert(find_max(words:\
    \ [\"name\", \"enam\", \"game\"]) == \"enam\")\nassert(find_max(words: [\"aaaaaaa\"\
    , \"bb\", \"cc\"]) == \"aaaaaaa\")\nassert(find_max(words: [\"abc\", \"cba\"])\
    \ == \"abc\")\nassert(find_max(words: [\"play\", \"this\", \"game\", \"of\", \"\
    footbott\"]) == \"footbott\")\nassert(find_max(words: [\"we\", \"are\", \"gonna\"\
    , \"rock\"]) == \"gonna\")\nassert(find_max(words: [\"we\", \"are\", \"a\", \"\
    mad\", \"nation\"]) == \"nation\")\nassert(find_max(words: [\"this\", \"is\",\
    \ \"a\", \"prrk\"]) == \"this\")\nassert(find_max(words: [\"b\"]) == \"b\")\n\
    assert(find_max(words: [\"play\", \"play\", \"play\"]) == \"play\")"
  status: Exception
  stderr: 'tmp7pa2pcym/tmp7pa2pcym.swift:30: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b7679a41c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b7679738b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b7679738988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b76797377b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmp7pa2pcym                        0x0000564fd995b703 <unavailable> + 5891

    5    libc.so.6                          0x00002b7679c2d460 __libc_start_main +
    245

    6    tmp7pa2pcym                        0x0000564fd995b129 <unavailable> + 4393

    '
  stdout: ''
  timestamp: 1660013457
- exit_code: -4
  program: "\n/// Write a function that accepts an array of strings.\n/// The array\
    \ contains different words. Return the word with maximum number\n/// of unique\
    \ characters. If multiple strings have maximum number of unique\n/// characters,\
    \ return the one which comes first in lexicographical order.\n/// >>> find_max(words:\
    \ [\"name\", \"of\", \"string\"])\n/// \"string\"\n/// >>> find_max(words: [\"\
    name\", \"enam\", \"game\"])\n/// \"enam\"\n/// >>> find_max(words: [\"aaaaaaa\"\
    , \"bb\", \"cc\"])\n/// \"aaaaaaa\"\nfunc find_max(words: [String]) -> String\
    \ {\n    var maxWord = \"\"\n    var maxCount = 0\n    for word in words {\n \
    \       let uniqueCount = Set(word).count\n        if maxCount < uniqueCount {\n\
    \            maxCount = uniqueCount\n            maxWord = word\n        }\n \
    \   }\n    return maxWord\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(find_max(words:\
    \ [\"name\", \"of\", \"string\"]) == \"string\")\nassert(find_max(words: [\"name\"\
    , \"enam\", \"game\"]) == \"enam\")\nassert(find_max(words: [\"aaaaaaa\", \"bb\"\
    , \"cc\"]) == \"aaaaaaa\")\nassert(find_max(words: [\"abc\", \"cba\"]) == \"abc\"\
    )\nassert(find_max(words: [\"play\", \"this\", \"game\", \"of\", \"footbott\"\
    ]) == \"footbott\")\nassert(find_max(words: [\"we\", \"are\", \"gonna\", \"rock\"\
    ]) == \"gonna\")\nassert(find_max(words: [\"we\", \"are\", \"a\", \"mad\", \"\
    nation\"]) == \"nation\")\nassert(find_max(words: [\"this\", \"is\", \"a\", \"\
    prrk\"]) == \"this\")\nassert(find_max(words: [\"b\"]) == \"b\")\nassert(find_max(words:\
    \ [\"play\", \"play\", \"play\"]) == \"play\")"
  status: Exception
  stderr: 'tmptcq6xifj/tmptcq6xifj.swift:39: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b588d430c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b588d127b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b588d127988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b588d1267b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmptcq6xifj                        0x0000562208f4f933 <unavailable> + 6451

    5    libc.so.6                          0x00002b588d61c460 __libc_start_main +
    245

    6    tmptcq6xifj                        0x0000562208f4f359 <unavailable> + 4953

    '
  stdout: ''
  timestamp: 1660013457
- exit_code: -4
  program: "\n/// Write a function that accepts an array of strings.\n/// The array\
    \ contains different words. Return the word with maximum number\n/// of unique\
    \ characters. If multiple strings have maximum number of unique\n/// characters,\
    \ return the one which comes first in lexicographical order.\n/// >>> find_max(words:\
    \ [\"name\", \"of\", \"string\"])\n/// \"string\"\n/// >>> find_max(words: [\"\
    name\", \"enam\", \"game\"])\n/// \"enam\"\n/// >>> find_max(words: [\"aaaaaaa\"\
    , \"bb\", \"cc\"])\n/// \"aaaaaaa\"\nfunc find_max(words: [String]) -> String\
    \ {\n    var counts = [String: Int]()\n    for word in words {\n        var counted\
    \ = Set<Character>()\n        for char in word {\n            if counted.contains(char)\
    \ {\n                continue\n            }\n            counted.insert(char)\n\
    \        }\n        counts[word] = counted.count\n    }\n    let (max, _) = counts.max\
    \ { a, b in a.value < b.value }!\n    return max\n}\n\n\nfunc ==(left: [(Int,\
    \ Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n\
    \        return false\n    }\n    for (l, r) in zip(left, right) {\n        if\
    \ l != r {\n            return false\n        }\n    }\n    return true\n}\n \
    \           \nassert(find_max(words: [\"name\", \"of\", \"string\"]) == \"string\"\
    )\nassert(find_max(words: [\"name\", \"enam\", \"game\"]) == \"enam\")\nassert(find_max(words:\
    \ [\"aaaaaaa\", \"bb\", \"cc\"]) == \"aaaaaaa\")\nassert(find_max(words: [\"abc\"\
    , \"cba\"]) == \"abc\")\nassert(find_max(words: [\"play\", \"this\", \"game\"\
    , \"of\", \"footbott\"]) == \"footbott\")\nassert(find_max(words: [\"we\", \"\
    are\", \"gonna\", \"rock\"]) == \"gonna\")\nassert(find_max(words: [\"we\", \"\
    are\", \"a\", \"mad\", \"nation\"]) == \"nation\")\nassert(find_max(words: [\"\
    this\", \"is\", \"a\", \"prrk\"]) == \"this\")\nassert(find_max(words: [\"b\"\
    ]) == \"b\")\nassert(find_max(words: [\"play\", \"play\", \"play\"]) == \"play\"\
    )"
  status: Exception
  stderr: 'tmpsqiqt2w6/tmpsqiqt2w6.swift:43: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b745a870c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b745a567b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b745a567988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b745a5667b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpsqiqt2w6                        0x00005617967ede39 <unavailable> + 7737

    5    libc.so.6                          0x00002b745aa5c460 __libc_start_main +
    245

    6    tmpsqiqt2w6                        0x00005617967ed6a9 <unavailable> + 5801

    '
  stdout: ''
  timestamp: 1660013457
- exit_code: 1
  program: "\n/// Write a function that accepts an array of strings.\n/// The array\
    \ contains different words. Return the word with maximum number\n/// of unique\
    \ characters. If multiple strings have maximum number of unique\n/// characters,\
    \ return the one which comes first in lexicographical order.\n/// >>> find_max(words:\
    \ [\"name\", \"of\", \"string\"])\n/// \"string\"\n/// >>> find_max(words: [\"\
    name\", \"enam\", \"game\"])\n/// \"enam\"\n/// >>> find_max(words: [\"aaaaaaa\"\
    , \"bb\", \"cc\"])\n/// \"aaaaaaa\"\nfunc find_max(words: [String]) -> String\
    \ {\n    var words = words\n    let charSet = CharacterSet(charactersIn: \"abcdefghijklmnopqrstuvwxyz\"\
    )\n    for (i, word) in words.enumerated() {\n        let lowercased = word.lowercased()\n\
    \        words[i] = lowercased.components(separatedBy: charSet.inverted).joined(separator:\
    \ \"\")\n    }\n    var maxUnique = 0\n    var maxWord = \"\"\n    for word in\
    \ words {\n        var unique = 0\n        for char in word {\n            if\
    \ let index = word.index(of: char) {\n                let sub = word[word.index(after:\
    \ index)...]\n                if !sub.contains(char) {\n                    unique\
    \ += 1\n                }\n            }\n        }\n        if unique > maxUnique\
    \ {\n            maxUnique = unique\n            maxWord = word\n        }\n \
    \   }\n    return maxWord\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(find_max(words:\
    \ [\"name\", \"of\", \"string\"]) == \"string\")\nassert(find_max(words: [\"name\"\
    , \"enam\", \"game\"]) == \"enam\")\nassert(find_max(words: [\"aaaaaaa\", \"bb\"\
    , \"cc\"]) == \"aaaaaaa\")\nassert(find_max(words: [\"abc\", \"cba\"]) == \"abc\"\
    )\nassert(find_max(words: [\"play\", \"this\", \"game\", \"of\", \"footbott\"\
    ]) == \"footbott\")\nassert(find_max(words: [\"we\", \"are\", \"gonna\", \"rock\"\
    ]) == \"gonna\")\nassert(find_max(words: [\"we\", \"are\", \"a\", \"mad\", \"\
    nation\"]) == \"nation\")\nassert(find_max(words: [\"this\", \"is\", \"a\", \"\
    prrk\"]) == \"this\")\nassert(find_max(words: [\"b\"]) == \"b\")\nassert(find_max(words:\
    \ [\"play\", \"play\", \"play\"]) == \"play\")"
  status: SyntaxError
  stderr: "/tmp/tmp1h8jw92k.swift:14:19: error: cannot find 'CharacterSet' in scope\n\
    \    let charSet = CharacterSet(charactersIn: \"abcdefghijklmnopqrstuvwxyz\")\n\
    \                  ^~~~~~~~~~~~\n/tmp/tmp1h8jw92k.swift:17:31: error: value of\
    \ type 'String' has no member 'components'\n        words[i] = lowercased.components(separatedBy:\
    \ charSet.inverted).joined(separator: \"\")\n                   ~~~~~~~~~~ ^~~~~~~~~~\n\
    /tmp/tmp1h8jw92k.swift:24:33: warning: 'index(of:)' is deprecated: renamed to\
    \ 'firstIndex(of:)'\n            if let index = word.index(of: char) {\n     \
    \                           ^\n/tmp/tmp1h8jw92k.swift:24:33: note: use 'firstIndex(of:)'\
    \ instead\n            if let index = word.index(of: char) {\n               \
    \                 ^~~~~\n                                firstIndex\n"
  stdout: ''
  timestamp: 1660013457
- exit_code: -4
  program: "\n/// Write a function that accepts an array of strings.\n/// The array\
    \ contains different words. Return the word with maximum number\n/// of unique\
    \ characters. If multiple strings have maximum number of unique\n/// characters,\
    \ return the one which comes first in lexicographical order.\n/// >>> find_max(words:\
    \ [\"name\", \"of\", \"string\"])\n/// \"string\"\n/// >>> find_max(words: [\"\
    name\", \"enam\", \"game\"])\n/// \"enam\"\n/// >>> find_max(words: [\"aaaaaaa\"\
    , \"bb\", \"cc\"])\n/// \"aaaaaaa\"\nfunc find_max(words: [String]) -> String\
    \ {\n    var max_word = \"\"\n    var max_char = Set<Character>()\n    for word\
    \ in words {\n        let current_char = Set(word)\n        if current_char.count\
    \ > max_char.count {\n            max_char = current_char\n            max_word\
    \ = word\n        }\n    }\n    return max_word\n}\n\n\nfunc ==(left: [(Int, Int)],\
    \ right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n       \
    \ return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r\
    \ {\n            return false\n        }\n    }\n    return true\n}\n        \
    \    \nassert(find_max(words: [\"name\", \"of\", \"string\"]) == \"string\")\n\
    assert(find_max(words: [\"name\", \"enam\", \"game\"]) == \"enam\")\nassert(find_max(words:\
    \ [\"aaaaaaa\", \"bb\", \"cc\"]) == \"aaaaaaa\")\nassert(find_max(words: [\"abc\"\
    , \"cba\"]) == \"abc\")\nassert(find_max(words: [\"play\", \"this\", \"game\"\
    , \"of\", \"footbott\"]) == \"footbott\")\nassert(find_max(words: [\"we\", \"\
    are\", \"gonna\", \"rock\"]) == \"gonna\")\nassert(find_max(words: [\"we\", \"\
    are\", \"a\", \"mad\", \"nation\"]) == \"nation\")\nassert(find_max(words: [\"\
    this\", \"is\", \"a\", \"prrk\"]) == \"this\")\nassert(find_max(words: [\"b\"\
    ]) == \"b\")\nassert(find_max(words: [\"play\", \"play\", \"play\"]) == \"play\"\
    )"
  status: Exception
  stderr: 'tmp6vut9929/tmp6vut9929.swift:39: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b44175f1c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b44172e8b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b44172e8988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b44172e77b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmp6vut9929                        0x000055cd59968983 <unavailable> + 6531

    5    libc.so.6                          0x00002b44177dd460 __libc_start_main +
    245

    6    tmp6vut9929                        0x000055cd599683a9 <unavailable> + 5033

    '
  stdout: ''
  timestamp: 1660013457
- exit_code: -4
  program: "\n/// Write a function that accepts an array of strings.\n/// The array\
    \ contains different words. Return the word with maximum number\n/// of unique\
    \ characters. If multiple strings have maximum number of unique\n/// characters,\
    \ return the one which comes first in lexicographical order.\n/// >>> find_max(words:\
    \ [\"name\", \"of\", \"string\"])\n/// \"string\"\n/// >>> find_max(words: [\"\
    name\", \"enam\", \"game\"])\n/// \"enam\"\n/// >>> find_max(words: [\"aaaaaaa\"\
    , \"bb\", \"cc\"])\n/// \"aaaaaaa\"\nfunc find_max(words: [String]) -> String\
    \ {\n    guard !words.isEmpty else { return \"\" }\n    var maxLength = 0\n  \
    \  var bestChoice = \"\"\n    for word in words {\n        let unique_chars =\
    \ Set(word)\n        if unique_chars.count > maxLength {\n            maxLength\
    \ = unique_chars.count\n            bestChoice = word\n        }\n    }\n    return\
    \ bestChoice\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool\
    \ {\n    if left.count != right.count {\n        return false\n    }\n    for\
    \ (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(find_max(words: [\"\
    name\", \"of\", \"string\"]) == \"string\")\nassert(find_max(words: [\"name\"\
    , \"enam\", \"game\"]) == \"enam\")\nassert(find_max(words: [\"aaaaaaa\", \"bb\"\
    , \"cc\"]) == \"aaaaaaa\")\nassert(find_max(words: [\"abc\", \"cba\"]) == \"abc\"\
    )\nassert(find_max(words: [\"play\", \"this\", \"game\", \"of\", \"footbott\"\
    ]) == \"footbott\")\nassert(find_max(words: [\"we\", \"are\", \"gonna\", \"rock\"\
    ]) == \"gonna\")\nassert(find_max(words: [\"we\", \"are\", \"a\", \"mad\", \"\
    nation\"]) == \"nation\")\nassert(find_max(words: [\"this\", \"is\", \"a\", \"\
    prrk\"]) == \"this\")\nassert(find_max(words: [\"b\"]) == \"b\")\nassert(find_max(words:\
    \ [\"play\", \"play\", \"play\"]) == \"play\")"
  status: Exception
  stderr: 'tmpqsnyejsi/tmpqsnyejsi.swift:40: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002ad175dc5c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002ad175abcb6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002ad175abc988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002ad175abb7b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpqsnyejsi                        0x00005630c9351993 <unavailable> + 6547

    5    libc.so.6                          0x00002ad175fb1460 __libc_start_main +
    245

    6    tmpqsnyejsi                        0x00005630c93513b9 <unavailable> + 5049

    '
  stdout: ''
  timestamp: 1660013457
- exit_code: -4
  program: "\n/// Write a function that accepts an array of strings.\n/// The array\
    \ contains different words. Return the word with maximum number\n/// of unique\
    \ characters. If multiple strings have maximum number of unique\n/// characters,\
    \ return the one which comes first in lexicographical order.\n/// >>> find_max(words:\
    \ [\"name\", \"of\", \"string\"])\n/// \"string\"\n/// >>> find_max(words: [\"\
    name\", \"enam\", \"game\"])\n/// \"enam\"\n/// >>> find_max(words: [\"aaaaaaa\"\
    , \"bb\", \"cc\"])\n/// \"aaaaaaa\"\nfunc find_max(words: [String]) -> String\
    \ {\n    var res = \"\"\n    var set = Set<Character>()\n    var count: Int =\
    \ 0\n    for word in words {\n        set = Set<Character>()\n        for char\
    \ in word {\n            set.insert(char)\n        }\n        if set.count > count\
    \ {\n            count = set.count\n            res = word\n        }\n    }\n\
    \    return res\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool\
    \ {\n    if left.count != right.count {\n        return false\n    }\n    for\
    \ (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(find_max(words: [\"\
    name\", \"of\", \"string\"]) == \"string\")\nassert(find_max(words: [\"name\"\
    , \"enam\", \"game\"]) == \"enam\")\nassert(find_max(words: [\"aaaaaaa\", \"bb\"\
    , \"cc\"]) == \"aaaaaaa\")\nassert(find_max(words: [\"abc\", \"cba\"]) == \"abc\"\
    )\nassert(find_max(words: [\"play\", \"this\", \"game\", \"of\", \"footbott\"\
    ]) == \"footbott\")\nassert(find_max(words: [\"we\", \"are\", \"gonna\", \"rock\"\
    ]) == \"gonna\")\nassert(find_max(words: [\"we\", \"are\", \"a\", \"mad\", \"\
    nation\"]) == \"nation\")\nassert(find_max(words: [\"this\", \"is\", \"a\", \"\
    prrk\"]) == \"this\")\nassert(find_max(words: [\"b\"]) == \"b\")\nassert(find_max(words:\
    \ [\"play\", \"play\", \"play\"]) == \"play\")"
  status: Exception
  stderr: 'tmphtxemb0x/tmphtxemb0x.swift:43: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b8d190d2c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b8d18dc9b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b8d18dc9988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b8d18dc87b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmphtxemb0x                        0x000056027081da03 <unavailable> + 6659

    5    libc.so.6                          0x00002b8d192be460 __libc_start_main +
    245

    6    tmphtxemb0x                        0x000056027081d429 <unavailable> + 5161

    '
  stdout: ''
  timestamp: 1660013457
- exit_code: -4
  program: "\n/// Write a function that accepts an array of strings.\n/// The array\
    \ contains different words. Return the word with maximum number\n/// of unique\
    \ characters. If multiple strings have maximum number of unique\n/// characters,\
    \ return the one which comes first in lexicographical order.\n/// >>> find_max(words:\
    \ [\"name\", \"of\", \"string\"])\n/// \"string\"\n/// >>> find_max(words: [\"\
    name\", \"enam\", \"game\"])\n/// \"enam\"\n/// >>> find_max(words: [\"aaaaaaa\"\
    , \"bb\", \"cc\"])\n/// \"aaaaaaa\"\nfunc find_max(words: [String]) -> String\
    \ {\n    var max = words[0]\n    for word in words {\n        if Set(word).count\
    \ > Set(max).count {\n            max = word\n        }\n    }\n    return max\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(find_max(words: [\"name\", \"of\", \"string\"\
    ]) == \"string\")\nassert(find_max(words: [\"name\", \"enam\", \"game\"]) == \"\
    enam\")\nassert(find_max(words: [\"aaaaaaa\", \"bb\", \"cc\"]) == \"aaaaaaa\"\
    )\nassert(find_max(words: [\"abc\", \"cba\"]) == \"abc\")\nassert(find_max(words:\
    \ [\"play\", \"this\", \"game\", \"of\", \"footbott\"]) == \"footbott\")\nassert(find_max(words:\
    \ [\"we\", \"are\", \"gonna\", \"rock\"]) == \"gonna\")\nassert(find_max(words:\
    \ [\"we\", \"are\", \"a\", \"mad\", \"nation\"]) == \"nation\")\nassert(find_max(words:\
    \ [\"this\", \"is\", \"a\", \"prrk\"]) == \"this\")\nassert(find_max(words: [\"\
    b\"]) == \"b\")\nassert(find_max(words: [\"play\", \"play\", \"play\"]) == \"\
    play\")"
  status: Exception
  stderr: 'tmppmvzaykd/tmppmvzaykd.swift:36: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002adf6a4e1c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002adf6a1d8b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002adf6a1d8988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002adf6a1d77b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmppmvzaykd                        0x000055849e16d993 <unavailable> + 6547

    5    libc.so.6                          0x00002adf6a6cd460 __libc_start_main +
    245

    6    tmppmvzaykd                        0x000055849e16d3b9 <unavailable> + 5049

    '
  stdout: ''
  timestamp: 1660013265
- exit_code: 1
  program: "\n/// Write a function that accepts an array of strings.\n/// The array\
    \ contains different words. Return the word with maximum number\n/// of unique\
    \ characters. If multiple strings have maximum number of unique\n/// characters,\
    \ return the one which comes first in lexicographical order.\n/// >>> find_max(words:\
    \ [\"name\", \"of\", \"string\"])\n/// \"string\"\n/// >>> find_max(words: [\"\
    name\", \"enam\", \"game\"])\n/// \"enam\"\n/// >>> find_max(words: [\"aaaaaaa\"\
    , \"bb\", \"cc\"])\n/// \"aaaaaaa\"\nfunc find_max(words: [String]) -> String\
    \ {\n    var most_uniques = (word: \"\", count: 0)\n    for word in words {\n\
    \        let uniques = Set(word.characters).count\n        if uniques > most_uniques.count\
    \ {\n            most_uniques = (word, uniques)\n        }\n    }\n    return\
    \ most_uniques.word\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) ->\
    \ Bool {\n    if left.count != right.count {\n        return false\n    }\n  \
    \  for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(find_max(words: [\"\
    name\", \"of\", \"string\"]) == \"string\")\nassert(find_max(words: [\"name\"\
    , \"enam\", \"game\"]) == \"enam\")\nassert(find_max(words: [\"aaaaaaa\", \"bb\"\
    , \"cc\"]) == \"aaaaaaa\")\nassert(find_max(words: [\"abc\", \"cba\"]) == \"abc\"\
    )\nassert(find_max(words: [\"play\", \"this\", \"game\", \"of\", \"footbott\"\
    ]) == \"footbott\")\nassert(find_max(words: [\"we\", \"are\", \"gonna\", \"rock\"\
    ]) == \"gonna\")\nassert(find_max(words: [\"we\", \"are\", \"a\", \"mad\", \"\
    nation\"]) == \"nation\")\nassert(find_max(words: [\"this\", \"is\", \"a\", \"\
    prrk\"]) == \"this\")\nassert(find_max(words: [\"b\"]) == \"b\")\nassert(find_max(words:\
    \ [\"play\", \"play\", \"play\"]) == \"play\")"
  status: SyntaxError
  stderr: "/tmp/tmpfxr3zhmb.swift:15:32: error: 'characters' is unavailable: Please\
    \ use String directly\n        let uniques = Set(word.characters).count\n    \
    \                           ^~~~~~~~~~\nSwift.String:5:16: note: 'characters'\
    \ was obsoleted in Swift 5.0\n    public var characters: String { get set }\n\
    \               ^\n"
  stdout: ''
  timestamp: 1660013457
- exit_code: -4
  program: "\n/// Write a function that accepts an array of strings.\n/// The array\
    \ contains different words. Return the word with maximum number\n/// of unique\
    \ characters. If multiple strings have maximum number of unique\n/// characters,\
    \ return the one which comes first in lexicographical order.\n/// >>> find_max(words:\
    \ [\"name\", \"of\", \"string\"])\n/// \"string\"\n/// >>> find_max(words: [\"\
    name\", \"enam\", \"game\"])\n/// \"enam\"\n/// >>> find_max(words: [\"aaaaaaa\"\
    , \"bb\", \"cc\"])\n/// \"aaaaaaa\"\nfunc find_max(words: [String]) -> String\
    \ {\n    var max_uniq_chars_count = 0\n    var max_uniq_char_idx = 0\n    for\
    \ i in 0..<words.count {\n        let chars = Array(words[i])\n        var uniq_chars_count\
    \ = 0\n        for c in chars {\n            if !chars.contains(where: { $0 ==\
    \ c }) {\n                uniq_chars_count += 1\n            }\n        }\n  \
    \      if uniq_chars_count > max_uniq_chars_count {\n            max_uniq_chars_count\
    \ = uniq_chars_count\n            max_uniq_char_idx = i\n        }\n    }\n  \
    \  return words[max_uniq_char_idx]\n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(find_max(words: [\"name\", \"of\", \"string\"]) == \"string\")\nassert(find_max(words:\
    \ [\"name\", \"enam\", \"game\"]) == \"enam\")\nassert(find_max(words: [\"aaaaaaa\"\
    , \"bb\", \"cc\"]) == \"aaaaaaa\")\nassert(find_max(words: [\"abc\", \"cba\"])\
    \ == \"abc\")\nassert(find_max(words: [\"play\", \"this\", \"game\", \"of\", \"\
    footbott\"]) == \"footbott\")\nassert(find_max(words: [\"we\", \"are\", \"gonna\"\
    , \"rock\"]) == \"gonna\")\nassert(find_max(words: [\"we\", \"are\", \"a\", \"\
    mad\", \"nation\"]) == \"nation\")\nassert(find_max(words: [\"this\", \"is\",\
    \ \"a\", \"prrk\"]) == \"this\")\nassert(find_max(words: [\"b\"]) == \"b\")\n\
    assert(find_max(words: [\"play\", \"play\", \"play\"]) == \"play\")"
  status: Exception
  stderr: 'tmptve3fw1m/tmptve3fw1m.swift:44: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b6387e6dc80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b6387b64b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b6387b64988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b6387b637b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmptve3fw1m                        0x0000556d95197a0e <unavailable> + 6670

    5    libc.so.6                          0x00002b6388059460 __libc_start_main +
    245

    6    tmptve3fw1m                        0x0000556d951975c9 <unavailable> + 5577

    '
  stdout: ''
  timestamp: 1660013457
- exit_code: 1
  program: "\n/// Write a function that accepts an array of strings.\n/// The array\
    \ contains different words. Return the word with maximum number\n/// of unique\
    \ characters. If multiple strings have maximum number of unique\n/// characters,\
    \ return the one which comes first in lexicographical order.\n/// >>> find_max(words:\
    \ [\"name\", \"of\", \"string\"])\n/// \"string\"\n/// >>> find_max(words: [\"\
    name\", \"enam\", \"game\"])\n/// \"enam\"\n/// >>> find_max(words: [\"aaaaaaa\"\
    , \"bb\", \"cc\"])\n/// \"aaaaaaa\"\nfunc find_max(words: [String]) -> String\
    \ {\n    var max = 0\n    var max_word = \"\"\n    for word in words {\n     \
    \   let uniques = Set(word.characters)\n        if uniques.count > max {\n   \
    \         max = uniques.count\n            max_word = word\n        }\n    }\n\
    \    return max_word\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(find_max(words:\
    \ [\"name\", \"of\", \"string\"]) == \"string\")\nassert(find_max(words: [\"name\"\
    , \"enam\", \"game\"]) == \"enam\")\nassert(find_max(words: [\"aaaaaaa\", \"bb\"\
    , \"cc\"]) == \"aaaaaaa\")\nassert(find_max(words: [\"abc\", \"cba\"]) == \"abc\"\
    )\nassert(find_max(words: [\"play\", \"this\", \"game\", \"of\", \"footbott\"\
    ]) == \"footbott\")\nassert(find_max(words: [\"we\", \"are\", \"gonna\", \"rock\"\
    ]) == \"gonna\")\nassert(find_max(words: [\"we\", \"are\", \"a\", \"mad\", \"\
    nation\"]) == \"nation\")\nassert(find_max(words: [\"this\", \"is\", \"a\", \"\
    prrk\"]) == \"this\")\nassert(find_max(words: [\"b\"]) == \"b\")\nassert(find_max(words:\
    \ [\"play\", \"play\", \"play\"]) == \"play\")"
  status: SyntaxError
  stderr: "/tmp/tmplp5e8hsl.swift:16:32: error: 'characters' is unavailable: Please\
    \ use String directly\n        let uniques = Set(word.characters)\n          \
    \                     ^~~~~~~~~~\nSwift.String:5:16: note: 'characters' was obsoleted\
    \ in Swift 5.0\n    public var characters: String { get set }\n              \
    \ ^\n"
  stdout: ''
  timestamp: 1660013457
- exit_code: 1
  program: "\n/// Write a function that accepts an array of strings.\n/// The array\
    \ contains different words. Return the word with maximum number\n/// of unique\
    \ characters. If multiple strings have maximum number of unique\n/// characters,\
    \ return the one which comes first in lexicographical order.\n/// >>> find_max(words:\
    \ [\"name\", \"of\", \"string\"])\n/// \"string\"\n/// >>> find_max(words: [\"\
    name\", \"enam\", \"game\"])\n/// \"enam\"\n/// >>> find_max(words: [\"aaaaaaa\"\
    , \"bb\", \"cc\"])\n/// \"aaaaaaa\"\nfunc find_max(words: [String]) -> String\
    \ {\n    var max_word = \"\"\n    var max_count = 0\n    for word in words {\n\
    \        let curr_count = word.count_unique_characters()\n        if curr_count\
    \ > max_count {\n            max_count = curr_count\n            max_word = word\n\
    \        }\n    }\n    return max_word\n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(find_max(words: [\"name\", \"of\", \"string\"]) == \"string\")\nassert(find_max(words:\
    \ [\"name\", \"enam\", \"game\"]) == \"enam\")\nassert(find_max(words: [\"aaaaaaa\"\
    , \"bb\", \"cc\"]) == \"aaaaaaa\")\nassert(find_max(words: [\"abc\", \"cba\"])\
    \ == \"abc\")\nassert(find_max(words: [\"play\", \"this\", \"game\", \"of\", \"\
    footbott\"]) == \"footbott\")\nassert(find_max(words: [\"we\", \"are\", \"gonna\"\
    , \"rock\"]) == \"gonna\")\nassert(find_max(words: [\"we\", \"are\", \"a\", \"\
    mad\", \"nation\"]) == \"nation\")\nassert(find_max(words: [\"this\", \"is\",\
    \ \"a\", \"prrk\"]) == \"this\")\nassert(find_max(words: [\"b\"]) == \"b\")\n\
    assert(find_max(words: [\"play\", \"play\", \"play\"]) == \"play\")"
  status: SyntaxError
  stderr: "/tmp/tmpn33umq5n.swift:16:31: error: value of type 'String' has no member\
    \ 'count_unique_characters'\n        let curr_count = word.count_unique_characters()\n\
    \                         ~~~~ ^~~~~~~~~~~~~~~~~~~~~~~\n"
  stdout: ''
  timestamp: 1660013457
- exit_code: -4
  program: "\n/// Write a function that accepts an array of strings.\n/// The array\
    \ contains different words. Return the word with maximum number\n/// of unique\
    \ characters. If multiple strings have maximum number of unique\n/// characters,\
    \ return the one which comes first in lexicographical order.\n/// >>> find_max(words:\
    \ [\"name\", \"of\", \"string\"])\n/// \"string\"\n/// >>> find_max(words: [\"\
    name\", \"enam\", \"game\"])\n/// \"enam\"\n/// >>> find_max(words: [\"aaaaaaa\"\
    , \"bb\", \"cc\"])\n/// \"aaaaaaa\"\nfunc find_max(words: [String]) -> String\
    \ {\n    var maxCount = 0\n    var maxWord = \"\"\n    for word in words {\n \
    \       let wordSet = Set(word)\n        if wordSet.count > maxCount {\n     \
    \       maxCount = wordSet.count\n            maxWord = word\n        }\n    }\n\
    \    return maxWord\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) ->\
    \ Bool {\n    if left.count != right.count {\n        return false\n    }\n  \
    \  for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(find_max(words: [\"\
    name\", \"of\", \"string\"]) == \"string\")\nassert(find_max(words: [\"name\"\
    , \"enam\", \"game\"]) == \"enam\")\nassert(find_max(words: [\"aaaaaaa\", \"bb\"\
    , \"cc\"]) == \"aaaaaaa\")\nassert(find_max(words: [\"abc\", \"cba\"]) == \"abc\"\
    )\nassert(find_max(words: [\"play\", \"this\", \"game\", \"of\", \"footbott\"\
    ]) == \"footbott\")\nassert(find_max(words: [\"we\", \"are\", \"gonna\", \"rock\"\
    ]) == \"gonna\")\nassert(find_max(words: [\"we\", \"are\", \"a\", \"mad\", \"\
    nation\"]) == \"nation\")\nassert(find_max(words: [\"this\", \"is\", \"a\", \"\
    prrk\"]) == \"this\")\nassert(find_max(words: [\"b\"]) == \"b\")\nassert(find_max(words:\
    \ [\"play\", \"play\", \"play\"]) == \"play\")"
  status: Exception
  stderr: 'tmpwotq1vnn/tmpwotq1vnn.swift:39: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002af4b85adc80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002af4b82a4b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002af4b82a4988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002af4b82a37b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpwotq1vnn                        0x000055f2cf9a3933 <unavailable> + 6451

    5    libc.so.6                          0x00002af4b8799460 __libc_start_main +
    245

    6    tmpwotq1vnn                        0x000055f2cf9a3359 <unavailable> + 4953

    '
  stdout: ''
  timestamp: 1660013457
- exit_code: -4
  program: "\n/// Write a function that accepts an array of strings.\n/// The array\
    \ contains different words. Return the word with maximum number\n/// of unique\
    \ characters. If multiple strings have maximum number of unique\n/// characters,\
    \ return the one which comes first in lexicographical order.\n/// >>> find_max(words:\
    \ [\"name\", \"of\", \"string\"])\n/// \"string\"\n/// >>> find_max(words: [\"\
    name\", \"enam\", \"game\"])\n/// \"enam\"\n/// >>> find_max(words: [\"aaaaaaa\"\
    , \"bb\", \"cc\"])\n/// \"aaaaaaa\"\nfunc find_max(words: [String]) -> String\
    \ {\n    // TODO: write your solution here\n    return \"\"\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(find_max(words: [\"name\", \"of\", \"string\"]) == \"\
    string\")\nassert(find_max(words: [\"name\", \"enam\", \"game\"]) == \"enam\"\
    )\nassert(find_max(words: [\"aaaaaaa\", \"bb\", \"cc\"]) == \"aaaaaaa\")\nassert(find_max(words:\
    \ [\"abc\", \"cba\"]) == \"abc\")\nassert(find_max(words: [\"play\", \"this\"\
    , \"game\", \"of\", \"footbott\"]) == \"footbott\")\nassert(find_max(words: [\"\
    we\", \"are\", \"gonna\", \"rock\"]) == \"gonna\")\nassert(find_max(words: [\"\
    we\", \"are\", \"a\", \"mad\", \"nation\"]) == \"nation\")\nassert(find_max(words:\
    \ [\"this\", \"is\", \"a\", \"prrk\"]) == \"this\")\nassert(find_max(words: [\"\
    b\"]) == \"b\")\nassert(find_max(words: [\"play\", \"play\", \"play\"]) == \"\
    play\")"
  status: Exception
  stderr: 'tmpfx1x0k8i/tmpfx1x0k8i.swift:30: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b74faa8ec80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b74fa785b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b74fa785988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b74fa7847b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpfx1x0k8i                        0x0000555dd86c64ce <unavailable> + 5326

    5    libc.so.6                          0x00002b74fac7a460 __libc_start_main +
    245

    6    tmpfx1x0k8i                        0x0000555dd86c6089 <unavailable> + 4233

    '
  stdout: ''
  timestamp: 1660013457
- exit_code: -4
  program: "\n/// Write a function that accepts an array of strings.\n/// The array\
    \ contains different words. Return the word with maximum number\n/// of unique\
    \ characters. If multiple strings have maximum number of unique\n/// characters,\
    \ return the one which comes first in lexicographical order.\n/// >>> find_max(words:\
    \ [\"name\", \"of\", \"string\"])\n/// \"string\"\n/// >>> find_max(words: [\"\
    name\", \"enam\", \"game\"])\n/// \"enam\"\n/// >>> find_max(words: [\"aaaaaaa\"\
    , \"bb\", \"cc\"])\n/// \"aaaaaaa\"\nfunc find_max(words: [String]) -> String\
    \ {\n    return \"\"\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(find_max(words:\
    \ [\"name\", \"of\", \"string\"]) == \"string\")\nassert(find_max(words: [\"name\"\
    , \"enam\", \"game\"]) == \"enam\")\nassert(find_max(words: [\"aaaaaaa\", \"bb\"\
    , \"cc\"]) == \"aaaaaaa\")\nassert(find_max(words: [\"abc\", \"cba\"]) == \"abc\"\
    )\nassert(find_max(words: [\"play\", \"this\", \"game\", \"of\", \"footbott\"\
    ]) == \"footbott\")\nassert(find_max(words: [\"we\", \"are\", \"gonna\", \"rock\"\
    ]) == \"gonna\")\nassert(find_max(words: [\"we\", \"are\", \"a\", \"mad\", \"\
    nation\"]) == \"nation\")\nassert(find_max(words: [\"this\", \"is\", \"a\", \"\
    prrk\"]) == \"this\")\nassert(find_max(words: [\"b\"]) == \"b\")\nassert(find_max(words:\
    \ [\"play\", \"play\", \"play\"]) == \"play\")"
  status: Exception
  stderr: 'tmp9vfthvyx/tmp9vfthvyx.swift:29: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b5bb598bc80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b5bb5682b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b5bb5682988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b5bb56817b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmp9vfthvyx                        0x0000564c87ea64ce <unavailable> + 5326

    5    libc.so.6                          0x00002b5bb5b77460 __libc_start_main +
    245

    6    tmp9vfthvyx                        0x0000564c87ea6089 <unavailable> + 4233

    '
  stdout: ''
  timestamp: 1660013265
- exit_code: 1
  program: "\n/// Write a function that accepts an array of strings.\n/// The array\
    \ contains different words. Return the word with maximum number\n/// of unique\
    \ characters. If multiple strings have maximum number of unique\n/// characters,\
    \ return the one which comes first in lexicographical order.\n/// >>> find_max(words:\
    \ [\"name\", \"of\", \"string\"])\n/// \"string\"\n/// >>> find_max(words: [\"\
    name\", \"enam\", \"game\"])\n/// \"enam\"\n/// >>> find_max(words: [\"aaaaaaa\"\
    , \"bb\", \"cc\"])\n/// \"aaaaaaa\"\nfunc find_max(words: [String]) -> String\
    \ {\n    var max_word = \"\"\n    var max_count = 0\n    for word in words {\n\
    \        let count = count_unique_chars(word: word)\n        if count > max_count\
    \ {\n            max_count = count\n            max_word = word\n        }\n \
    \   }\n    return max_word\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(find_max(words:\
    \ [\"name\", \"of\", \"string\"]) == \"string\")\nassert(find_max(words: [\"name\"\
    , \"enam\", \"game\"]) == \"enam\")\nassert(find_max(words: [\"aaaaaaa\", \"bb\"\
    , \"cc\"]) == \"aaaaaaa\")\nassert(find_max(words: [\"abc\", \"cba\"]) == \"abc\"\
    )\nassert(find_max(words: [\"play\", \"this\", \"game\", \"of\", \"footbott\"\
    ]) == \"footbott\")\nassert(find_max(words: [\"we\", \"are\", \"gonna\", \"rock\"\
    ]) == \"gonna\")\nassert(find_max(words: [\"we\", \"are\", \"a\", \"mad\", \"\
    nation\"]) == \"nation\")\nassert(find_max(words: [\"this\", \"is\", \"a\", \"\
    prrk\"]) == \"this\")\nassert(find_max(words: [\"b\"]) == \"b\")\nassert(find_max(words:\
    \ [\"play\", \"play\", \"play\"]) == \"play\")"
  status: SyntaxError
  stderr: "/tmp/tmpuu6jvkix.swift:16:21: error: cannot find 'count_unique_chars' in\
    \ scope\n        let count = count_unique_chars(word: word)\n                \
    \    ^~~~~~~~~~~~~~~~~~\n"
  stdout: ''
  timestamp: 1660013457
- exit_code: 1
  program: "\n/// Write a function that accepts an array of strings.\n/// The array\
    \ contains different words. Return the word with maximum number\n/// of unique\
    \ characters. If multiple strings have maximum number of unique\n/// characters,\
    \ return the one which comes first in lexicographical order.\n/// >>> find_max(words:\
    \ [\"name\", \"of\", \"string\"])\n/// \"string\"\n/// >>> find_max(words: [\"\
    name\", \"enam\", \"game\"])\n/// \"enam\"\n/// >>> find_max(words: [\"aaaaaaa\"\
    , \"bb\", \"cc\"])\n/// \"aaaaaaa\"\nfunc find_max(words: [String]) -> String\
    \ {\n    var max = words[0]\n    for i in words {\n        if unique_count(word:\
    \ i) > unique_count(word: max) {\n            max = i\n        }\n    }\n    return\
    \ max\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n   \
    \ if left.count != right.count {\n        return false\n    }\n    for (l, r)\
    \ in zip(left, right) {\n        if l != r {\n            return false\n     \
    \   }\n    }\n    return true\n}\n            \nassert(find_max(words: [\"name\"\
    , \"of\", \"string\"]) == \"string\")\nassert(find_max(words: [\"name\", \"enam\"\
    , \"game\"]) == \"enam\")\nassert(find_max(words: [\"aaaaaaa\", \"bb\", \"cc\"\
    ]) == \"aaaaaaa\")\nassert(find_max(words: [\"abc\", \"cba\"]) == \"abc\")\nassert(find_max(words:\
    \ [\"play\", \"this\", \"game\", \"of\", \"footbott\"]) == \"footbott\")\nassert(find_max(words:\
    \ [\"we\", \"are\", \"gonna\", \"rock\"]) == \"gonna\")\nassert(find_max(words:\
    \ [\"we\", \"are\", \"a\", \"mad\", \"nation\"]) == \"nation\")\nassert(find_max(words:\
    \ [\"this\", \"is\", \"a\", \"prrk\"]) == \"this\")\nassert(find_max(words: [\"\
    b\"]) == \"b\")\nassert(find_max(words: [\"play\", \"play\", \"play\"]) == \"\
    play\")"
  status: SyntaxError
  stderr: "/tmp/tmpe__hroua.swift:15:12: error: cannot find 'unique_count' in scope\n\
    \        if unique_count(word: i) > unique_count(word: max) {\n           ^~~~~~~~~~~~\n\
    /tmp/tmpe__hroua.swift:15:36: error: cannot find 'unique_count' in scope\n   \
    \     if unique_count(word: i) > unique_count(word: max) {\n                 \
    \                  ^~~~~~~~~~~~\n"
  stdout: ''
  timestamp: 1660013457
- exit_code: 1
  program: "\n/// Write a function that accepts an array of strings.\n/// The array\
    \ contains different words. Return the word with maximum number\n/// of unique\
    \ characters. If multiple strings have maximum number of unique\n/// characters,\
    \ return the one which comes first in lexicographical order.\n/// >>> find_max(words:\
    \ [\"name\", \"of\", \"string\"])\n/// \"string\"\n/// >>> find_max(words: [\"\
    name\", \"enam\", \"game\"])\n/// \"enam\"\n/// >>> find_max(words: [\"aaaaaaa\"\
    , \"bb\", \"cc\"])\n/// \"aaaaaaa\"\nfunc find_max(words: [String]) -> String\
    \ {\n    if words.count == 0 {\n        return \"\"\n    }\n    var curr = words[0]\n\
    \    var curr_count = count_unique(curr)\n    for index in 1...words.count - 1\
    \ {\n        let w = words[index]\n        let count = count_unique(w)\n     \
    \   if count > curr_count {\n            curr = w\n            curr_count = count\n\
    \        } else if count == curr_count {\n            if curr > w {\n        \
    \        curr = w\n            }\n        }\n    }\n    return curr\n}\n\n\nfunc\
    \ ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count !=\
    \ right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(find_max(words: [\"name\", \"of\", \"string\"\
    ]) == \"string\")\nassert(find_max(words: [\"name\", \"enam\", \"game\"]) == \"\
    enam\")\nassert(find_max(words: [\"aaaaaaa\", \"bb\", \"cc\"]) == \"aaaaaaa\"\
    )\nassert(find_max(words: [\"abc\", \"cba\"]) == \"abc\")\nassert(find_max(words:\
    \ [\"play\", \"this\", \"game\", \"of\", \"footbott\"]) == \"footbott\")\nassert(find_max(words:\
    \ [\"we\", \"are\", \"gonna\", \"rock\"]) == \"gonna\")\nassert(find_max(words:\
    \ [\"we\", \"are\", \"a\", \"mad\", \"nation\"]) == \"nation\")\nassert(find_max(words:\
    \ [\"this\", \"is\", \"a\", \"prrk\"]) == \"this\")\nassert(find_max(words: [\"\
    b\"]) == \"b\")\nassert(find_max(words: [\"play\", \"play\", \"play\"]) == \"\
    play\")"
  status: SyntaxError
  stderr: "/tmp/tmpwyqhheg4.swift:17:22: error: cannot find 'count_unique' in scope\n\
    \    var curr_count = count_unique(curr)\n                     ^~~~~~~~~~~~\n\
    /tmp/tmpwyqhheg4.swift:20:21: error: cannot find 'count_unique' in scope\n   \
    \     let count = count_unique(w)\n                    ^~~~~~~~~~~~\n"
  stdout: ''
  timestamp: 1660013457
